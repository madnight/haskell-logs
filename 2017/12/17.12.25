00:18:51 <nickoralias> Anybody have a good idea for benchmarking foldr/foldl/foldl’?  I’m doing it with a sum over a large list but not seeing enough of a diff in performance
00:19:12 <Axman6> criterion?
00:19:33 <nickoralias> Ya I’m using criterion
00:20:13 <Axman6> I'm not sure I understand the question then
00:20:15 <nickoralias> I’m trying to figure out what arguments to use
00:20:26 <nickoralias> In order to see a diff in performance
00:20:45 * geekosaur would wonder about strictness: make sure they're all forced at the end
00:20:54 <Axman6> bench nf (fold(l|r|r') (+) 0) [1..1000000] ?
00:20:55 <geekosaur> within the criterion expression, that ios
00:21:04 <nickoralias> Yeah
00:21:14 <Axman6> (roughtly)
00:21:20 <nickoralias> Thant’s what I’ve got
00:21:29 <nickoralias> But foldl is actually faster than foldl’
00:22:05 <nickoralias> Actually I used whnf should I be using nf?
00:22:35 <Axman6> nf is probbly a better idea, depending on what your result type is
00:22:39 <geekosaur> yes, whnf only forces the outermost part and for a list that means basically the first element
00:23:04 <geekosaur> the rest of the list is forced outside the criterion run
00:23:12 <geekosaur> (if at all)
00:23:28 <geekosaur> hm, actually if this is sum, maybe whnf is enough
00:23:30 <Axman6> well, if you're doing the equivalent of sum, the result is a single number
00:23:34 <geekosaur> yeh
00:23:37 <Axman6> depends on the return type
00:24:26 <nickoralias> Right so then for that case it shouldn’t matter?
00:24:42 <Axman6> what is yourreturn type? Int? Integer? Nat?
00:24:56 <nickoralias> Int
00:25:04 <Axman6> then whnf should be fine
00:25:33 <nickoralias> Ya.  I’m just trying to figure out how to write a benchmark that will demonstrate better performance for foldl’
00:25:47 <Axman6> sum probably isnt a good benchmark
00:25:49 <geekosaur> (+) is a bad choice because it's already strict
00:25:56 <nickoralias> Yeah exactly
00:26:59 <nickoralias> Would (++) be better if I folded a list of lists
00:29:22 <nickoralias> Then nf would force the whole list right
00:33:43 <nickoralias> Ok wow that definitely showed better performance for foldl’.  I guess that answers it.  Mostly was just wondering if someone could think of an obvious choice for a good function to benchmark here
01:09:48 * hackage algebra 4.3.1 - Constructive abstract algebra  https://hackage.haskell.org/package/algebra-4.3.1 (HiromiIshii)
01:47:54 <bollu> Can I say that K x y = x is strict in x?
01:50:20 <ertes> bollu: yes
01:52:00 <bollu> ertes cool, ty, I wasn't 100% sure
02:59:19 * hackage process-streaming 0.9.2.1 - Streaming interface to system processes.  https://hackage.haskell.org/package/process-streaming-0.9.2.1 (DanielDiazCarrete)
03:04:06 <Yimo> hey em, I wanted to ask : what does `next` do?
03:06:34 <Yimo> nvm
03:19:39 <asheshambasta> hello everyone, I've been getting really interested in Haskell and I'm raeding the "Real World Haskell". While I like the book overall, I still find myself getting lost with the top-down approach the book takes. It first defines the "main" component of a chain of functions, putting alien function names in the main component and then going to define the smaller components. I've been writing Scala for a while now and I personally prefer
03:19:39 <asheshambasta> he bottom up approach.
03:20:18 <mniip> there's a huge problem with the bottom up approach wrt IO
03:20:30 <mniip> it's fairly... problematic
03:20:40 <asheshambasta> I just wanted to check if this is expected — or is a valid critique of this book, or am I doing something wrong here and should train myself to think from a broad → narrow direction as the book does.
03:20:41 <mniip> you "cannot" define IO using haskell itself
03:21:43 <mniip> GHC does it in its own messed up way that lets one peek at the internals of IO but that relies a lot on GHC specifics and doesn't help you be a better haskell programmer, in fact it might have a negative effect
03:22:15 <mniip> oh
03:22:21 <mniip> am I misreading what you're saying
03:22:37 <mniip> asheshambasta, are you talking about IO at all, "main" threw me off
03:23:02 <asheshambasta> yeah, sorry about the confusion mniip, I'm not talking about the "main" as in the main function.
03:23:08 <mniip> right
03:23:13 <mniip> just top down implementation of functional programs
03:23:19 <asheshambasta> yeah
03:24:00 <asheshambasta> for example, the book solves a raw PGM file parser with a function and presents the chief function first — this function then refers to a bunch of functions the book hasn't mentioned yet.
03:24:16 <asheshambasta> and then the book goes on to describe these "alien" functions.
03:24:53 <asheshambasta> I personally find that approach quite jarring — at least to read — because you're somehow expected to dive into the thought process of the writers, which in this case are the problem solvers.
03:25:09 <shafox> Megaparsec  question: How would I write something starts with {{ and endswith }} and in between there are many | with chars ?
03:26:29 <asheshambasta> and the book seems to go in a "tree" of smaller function definitions from the top-down.
03:26:36 <dminuoso> iqubic: The point is to write it in terms of traverse, you will see why.
03:26:54 <asheshambasta> what I want to ask is — is this kind of problem solving "style" common in Haskell?
03:27:07 <asheshambasta> & is it wrong of me to not to think similarly?
03:27:21 <mniip> I think everyone is for themselves there
03:28:10 <mniip> I usually start solving top-down in my mind - I start *thinking* what functions I need until I arrive at one I can write immediately, then it's bottom up, backtracking the trace
03:28:19 <mniip> the only exception is applying higher order functions
03:28:36 <mniip> where I would first write out the HOF, followed by, where foo = ...
03:28:46 <mniip> think something like
03:28:48 <asheshambasta> right
03:28:51 <mniip> sortOn foo bar where foo = ...
03:30:04 <mniip> I try not to write any code that I don't know will fit for sure
03:30:20 <mniip> you need to be very experienced to get a complicated functuion's architecture on the first try
03:30:29 <mniip> you need to be very experienced to get a complicated functuion's architecture right, on the first try
03:31:00 <asheshambasta> hm, yeah.
03:31:03 <dminuoso> mniip: I suppose that holds true for programming in general. It's really hard to get architecture of anything right on the first try without sufficient experience.
03:31:09 <mniip> right
03:31:36 <mniip> if you're okay with constant backtracking to the higher level code to correct it to adjust some arhitecture deficiency...
03:33:47 <ph88> merry christmas :)
03:38:07 <jle`> merry christmas! :)
03:39:22 <asheshambasta> I understand, thanks mniip
03:39:33 <asheshambasta> merry x'mas everyone
04:24:17 <LiaoTao> Happy Christmas #haskell
04:30:19 * hackage hakyll-ogmarkup 4.0 - Integrate ogmarkup document with Hakyll  https://hackage.haskell.org/package/hakyll-ogmarkup-4.0 (lethom)
04:35:32 <dminuoso> Is there a more elegant way to do `foldr1 (\x y -> x . a . y)` ?
04:38:37 <mniip> foldr (.) id . intersperse a
04:41:09 <int-e> :t \a -> (.) . (. a)
04:41:10 <lambdabot> (b1 -> b2) -> (b2 -> c) -> (a -> b1) -> a -> c
04:41:38 <dminuoso> mniip: Ohh neat. Thats exactly what I wanted to express :)
04:41:53 <gesindel> ravacauliculus
04:59:06 <ph88> i'm trying to use a modified version of base so i did   stack unpack base   and add base-4.10.1.0 to packages in stack.yaml  but when i make a syntax error and stack build base-4.10.1.0 i get no errors. The adding to packages was described in this FAQ https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-modify-an-upstream-package-how-should-i-do-it  anyone know how i can use modified upstream packages with stack ?
05:10:19 <AliSSa> Who want fuck me? - http://2018sexxx.com
05:10:59 <LiaoTao> Looks legit
05:25:11 <huss`> xd
05:39:01 <dxtr> haha
05:39:19 <dxtr> I haven't seen anything to suggest it isn't!
05:56:06 <s4ke> Merry christmas
05:56:50 <xormor> s4ke, same to you!
05:57:17 <s4ke> And happy holidays 😊
06:07:48 * hackage socks 0.5.6 - Socks proxy (ver 5)  https://hackage.haskell.org/package/socks-0.5.6 (VincentHanquez)
06:24:11 <yohotchoc> man I always get socks for christmas
06:24:16 <yohotchoc> now #haskell's doing it too
06:27:11 <Rembane> It's a good christmas present if you walk enough during the year.
06:41:05 <royal_screwup21> I'm trying to build a tree from a list of ints like so: https://thepasteb.in/p/LghN9KnXoxghZ
06:41:52 <royal_screwup21> the code compiles, but when I try something like: "maketree [4,5,6,7]", I get back "Node 7 Leaf Leaf"
06:42:41 <royal_screwup21> where am I going wrong?
06:45:27 <yohotchoc> you're discarding results in your insert
06:45:44 <yohotchoc> for example |x>a = insert x right
06:46:23 <POGtastic> ^
06:46:25 <yohotchoc> that means if you've got a (Node 7 Leaf Leaf) to begin with and insert 4, it'll give you back 4 inserted into x, which is Leaf
06:46:37 <yohotchoc> so you'll turn your Node 7 Leaf Leaf into Node 4 Leaf Leaf
06:46:59 <yohotchoc> you need to construct a new tree based on the result of that insert that doesn't discard your old tree
06:47:14 <royal_screwup21> Node 7 Leaf Leaf
06:47:14 <royal_screwup21> cool, thanks for the clarification
06:50:34 <royal_screwup21> hmm, I'd love a pointer or two, I'm stuck
06:50:42 <POGtastic> which part?
06:50:54 <royal_screwup21> how do I persist the tree?
06:50:54 <POGtastic> (i just worked through it, so I see your issue)
06:51:22 <POGtastic> you have your base case correct - it creates a new node with leaves as children
06:51:42 <POGtastic> but with the left and right, you need to replace the left with a recursive call to your insert function
06:51:45 <POGtastic> just the left
06:51:50 <POGtastic> the rest of that node remains the same
06:52:13 <POGtastic> same thing with the right
06:52:30 <POGtastic> right now, you're replacing the entire node with the call... which is not good :)
06:54:10 <royal_screwup21> Ah okay, I think I get it
06:55:13 <yohotchoc> just on your point on "persist the tree"
06:55:28 <yohotchoc> the more functional way to think about it isn't that your persisting the tree
06:55:49 <yohotchoc> a function is a transformation from one state to another, and you're transforming the tree from a state with just a 7 in it to a state with a 4 in it too
06:56:00 <yohotchoc> it's a whole new state, not a continuation of the previous tree
06:56:20 <yohotchoc> if you're familiar with bash scripting, it's similar to pipes
06:56:32 <royal_screwup21> hmm interesting, yeah that makes sense
07:11:21 <tabaqui> do we have MonadIO versions of functions from Control.Exception?
07:11:27 <escobar9282> hello
07:11:43 <escobar9282> everybody
07:17:14 <iqubic> dminuoso: Are you around?
07:17:48 <iqubic> Anyone know when dminuoso will be around next?
07:22:10 <iqubic> Can anyone write the traverse function using only sequenceA?
07:22:19 <iqubic> :t traverse
07:22:20 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:25:19 * hackage sparkle 0.7.2 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.7.2 (MathieuBoespflug)
07:25:44 <lyxia> :t fmap sequence . fmap
07:25:45 <lambdabot> (Monad m, Traversable t) => (a1 -> m a2) -> t a1 -> m (t a2)
07:25:58 <lyxia> :t fmap sequenceA . fmap
07:25:59 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a2) -> t a1 -> f (t a2)
07:26:10 <iqubic> Alright that works.
07:26:16 <iqubic> Why does that work?
07:26:22 <lyxia> tabaqui: https://hackage.haskell.org/package/lifted-base-0.2.3.11/docs/Control-Exception-Lifted.html
07:27:24 <lyxia> sequenceA = traverse id
07:27:42 <lyxia> I guess that may be sufficient to prove it?
07:28:19 <iqubic> I'm still not seeing it.
07:30:08 <lyxia> \f -> sequenceA . fmap f   -- fmap turns every element of the container into an action, sequenceA runs all the actions.
07:31:36 <ph88> i'm trying to use a modified version of base so i did   stack unpack base   and add base-4.10.1.0 to packages in stack.yaml  but when i make a syntax error and stack build base-4.10.1.0 i get no errors. The adding to packages was described in this FAQ https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-modify-an-upstream-package-how-should-i-do-it  anyone know how i can use modified upstream packages with stack ?
07:32:30 <lyxia> algebraically, sequenceA . fmap f = traverse id . fmap f = traverse (id . f) = traverse f, where I guess the middle step might be a consequence of parametricity.
07:39:10 <iqubic> how did you go from "traverse id . fmap f" to "traverse (id . f)"?
07:40:05 <iqubic> :t \f -> sequenceA . fmap f
07:40:06 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a2) -> t a1 -> f (t a2)
07:48:52 * hackage sparkle 0.7.2.1 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.7.2.1 (MathieuBoespflug)
07:49:13 <lyxia> Intuitively because fmap is pure
07:49:57 <iqubic> I still don't see the connection.
07:52:13 <lyxia> "traverse g . fmap f": transform every element with f, and for every resulting element, run g.
07:52:30 <lyxia> "traverse (g . f)", for every element, transform it with f and run g
07:55:22 <iqubic> I see now.
07:59:50 <iqubic> Why does traversable have a dependency on foldable?
08:02:36 <iqubic> So I want to write the applicative instance for "data V3 a = a a a", but I'm not sure how to do it.
08:03:37 <iqubic> My initial thought is that I need to make sure that my a is an applicative itself, but I'm not sure how to do that.
08:04:09 <iqubic> I'm not even sure that is what I need to make the thing work.
08:06:02 <nullie> how you done Functor instance?
08:07:32 <iqubic> I have.
08:07:33 <nullie> applicative could be  V3 f f f <*> V3 a a a = V3 (f a) (f a) (f a) or something else depending on why do you need applicative instance for it
08:08:07 <iqubic> I just want to write to help me practice.
08:08:45 <lyxia> iqubic: every traversable is foldable
08:09:05 <iqubic> lyxia: Why is that though?
08:09:30 <lyxia> because you can use a traversal to get the list of elements to fold over
08:09:44 <iqubic> You can? How?
08:10:38 <lyxia> use state, and for every element a, traverse with f a = (\as -> (a, (a : as)) :: State [a] a
08:10:50 <iqubic> Oh, I see.
08:10:53 <nullie> I still don't understand Traversable
08:11:10 <nullie> I need to redo that chapter
08:11:22 <iqubic> That chapter of what?
08:12:00 <nullie> the haskell book
08:12:42 <Rembane> nullie: This one? http://haskellbook.com/
08:12:45 <nullie> yes
08:14:42 <Guest2389> 11:13 AM <Guest2389> Hello, I'm trying to learn Haskell via lean you a Haskell for great good and can't seem to figure out one of the examples
08:16:44 <gour> hiya, tried to learn haskell in the fast 2 or 3 times (using Craft 2nd ed., RWH books), but for whatever reasons had to give up. now i wonder which one would be more suitable: LYAH or 'haskell book'?
08:16:58 <Guest2389> On page 9 it has a list b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] and it says b !! 2 displays [1,2,2,3,4] but shouldnt this say [5,3,3,3]?
08:17:59 <nullie> gour: I think LYAH is free, you can try it
08:19:08 <gour> nille: yes, but would rather pick the 'right one' sooner than later :-)
08:19:43 <nullie> gour: the haskell book is a serious investment
08:20:12 <nullie> I can't compare with LYAH
08:20:43 <nullie> the haskell book goes from very basics of lambda calculus
08:21:05 <gour> another concern is this one: http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=ghc&lang2=go i didn't expect that Go would be so competitive (despite the usual grain of salt when talkimng about benchmarks)?
08:21:23 <nullie> it's much lower level
08:21:25 <nullie> more like C
08:21:48 <gour> nullie: heh, i also expect that learning will take serious amount of free time :-)
08:22:01 <nullie> yes it will
08:22:53 <gour> what is general feedback about 'haskell book' here?
08:24:13 <Rembane> gour: Go is quite boring though. Try Rust if you want fun. :)
08:25:00 <grokkingStuff> gour: Honestly, I think it's the best book out there
08:25:02 <gour> i'm on linux (fedora)...is slack recommended way to install haskell/ghc or platform? does Cabal-2 bring some serious improve?ment
08:25:04 <Yimo> hey there guys, I'm still trying to get n `getLine`s in a single list
08:25:14 <Yimo> anyone knows a way to do so?
08:25:24 <gour> Rembane: i can't stand Rust's syntax ;)
08:25:26 <nullie> Yimo: replicateM
08:25:37 <Rembane> gour: Fair enough, syntax is important. :)
08:25:38 <grokkingStuff> gour: So a lot of tutorials about starting off and installing haskell recommends stack.
08:25:39 <gour> grokkingStuff: thanks!
08:25:55 <Yimo> nullie can you give me an example with replicateM? I tried it but was faced with errors
08:25:58 <Yimo> especially with getLine
08:26:00 <grokkingStuff> ^I'd recommend using stack because it's not too new and it's rather useable
08:26:39 <nullie> Yimo: l <- replicateM n getLine  should work
08:27:20 <Rembane> Yimo: replicateM 3 (putStrLn =<< getLine)
08:27:45 <nullie> doesn't pustStrLn return ()
08:27:52 <Yimo> hmm, getLine doesn't work like a usual function works
08:27:55 <Rembane> Good point
08:28:01 <mniip> getLine isn't a function
08:28:07 <mniip> so it's fair
08:28:14 <Rembane> :t getLine
08:28:15 <lambdabot> IO String
08:28:16 <Rembane> :i getLine
08:28:21 <mniip> yeah, no ->
08:28:25 <mniip> not a function
08:28:31 <mniip> % :i getLine
08:28:32 <yahb> mniip: getLine :: IO String -- Defined in `System.IO'
08:28:33 <Rembane> Oh, you need an arity of >1
08:29:00 <Rembane> mniip: So getLine is a value coming from the real world?
08:29:15 <mniip> that's vague
08:29:25 <nullie> it's a thing which describes an action in real world
08:29:42 <Yimo> there's some new syntax to me I guess : does anyone of you have a page explaining how to use getLine and similar `not` functions ?
08:29:46 <grokkingStuff> gour: while i like the haskell book, i think the exercises can be a bit dry (too much theory and no context.) the cis 194 lectures have better exercises in my opinion
08:29:47 <mniip> it's a description of an action that results in a String
08:29:55 <grokkingStuff> https://github.com/katychuang/getting-started-with-haskell <----- pretty good resources as well.
08:30:04 <mniip> Yimo, no new syntax so far
08:30:11 <mniip> replicateM and >>= are just functions
08:30:20 <mniip> replicateM is implemented using >>= in fact
08:30:22 <Rembane> mniip: Good point. Thank you.
08:30:32 <Yimo> alright, but what is >>= ? ( or =<< )
08:30:41 <iqubic> But they are more complex functions then you may have encountered
08:30:49 <iqubic> :t (>>=)
08:30:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:30:53 <mniip> if you have a description of an action that results in an X
08:30:56 <mniip> k :: IO X
08:31:09 <mniip> and a function that takes an X, and returns a description of an action that results in an Y
08:31:13 <mniip> f :: X -> IO Y
08:31:15 <yohotchoc> Yimo: are you familiar with do notation?
08:31:22 <mniip> then you can build an action that results in an Y
08:31:28 <mniip> k >>= f :: IO Y
08:31:28 <yohotchoc> you need to look at that and how it desugars
08:31:40 <mniip> >>= :: IO a -> (a -> IO b) -> IO b
08:31:43 <iqubic> % replicateM_  3 putStrLn "Hello World"
08:31:43 <yahb> iqubic: ()
08:31:45 <Yimo> yohotchoc I'm generally learning haskell right now, so nothing is too familiar to me
08:32:07 <iqubic> Yimo, What are you learning about right now?
08:32:07 <yohotchoc> read what mniip's saying, then look up monads and do notation
08:32:10 <mniip> iqubic, you replicated the reader monad
08:32:25 <yohotchoc> you'll need to understand that before you can really use getLine and understand what's going on
08:32:46 <iqubic> mniip: I was trying to run putStrLn "Hello World" 3 times.
08:32:53 <Yimo> iqubic my general way of doing it, is think of a problem, try to solve it with haskell, when I get stuck on something, I either turn back to reading tutorials or come ask here
08:33:02 <mniip> % replicateM_  3 (putStrLn "Hello World")
08:33:02 <yahb> mniip: Hello World; Hello World; Hello World
08:33:06 <Yimo> alright yohotchot
08:33:10 <iqubic> I see.
08:33:22 <mniip> :t replicateM_  3 putStrLn
08:33:23 <lambdabot> String -> ()
08:33:34 <iqubic> Yimo: What is your current problem?
08:33:59 <Yimo> store n inputs into an array, more precisely, n numbers
08:34:17 <Yimo> being given them 1 by 1
08:34:23 <iqubic> Instead of an array, try using a list.
08:34:37 <nullie> > replicateM  3 (putStrLn "Hello World") >>= print
08:34:39 <iqubic> Haskell uses lists and not arrays,
08:34:39 <lambdabot>  <IO ()>
08:34:52 <Yimo> yeah but lists cannot be changed after declared, no ?
08:35:03 <iqubic> nullie: lambdabot doesn't do IO.
08:35:15 <iqubic> use yahb instead.
08:35:35 <mniip> Yimo, that's a large misunderstanding of what is going on
08:35:37 <iqubic> % replicateM  3 (putStrLn "Hello World") >>= print
08:35:37 <grokkingStuff> iqubic: why doesn't lambdabot do IO?
08:35:37 <yahb> iqubic: Hello World; Hello World; Hello World; [(),(),()]
08:35:41 <Rembane> Yimo: You create a new list instead.
08:36:02 <iqubic> I don't know why lambdabot can't do IO.
08:36:14 <yohotchoc> % launchMissiles
08:36:14 <yahb> yohotchoc: ; <interactive>:14:1: error: Variable not in scope: launchMissiles
08:36:16 <Rembane> > 7:[1,2,3] -- This will give you a new list, Yimo
08:36:16 <Yimo> Rembane and then where is that new list stored?
08:36:17 <yohotchoc> rip
08:36:18 <lambdabot>  [7,1,2,3]
08:36:22 <Guest2389> On page 9 it has a list b = [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] and it says b !! 2 displays [1,2,2,3,4] but shouldnt this say [5,3,3,3]?
08:36:26 <Yimo> a = [7,8,9]
08:36:30 <Yimo> a = 5:a does not work
08:36:37 <yohotchoc> > [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] !! 2
08:36:38 <Rembane> Yimo: Give it a new name
08:36:39 <lambdabot>  [5,3,3,3]
08:36:46 <yohotchoc> Guest2389: does that answer your question?
08:36:55 <Yimo> Rembane : I can't do this arbitrarely for n inputs
08:36:57 <Guest2389> @yohotchoc: so the book is wrong :/ thanks
08:36:58 <lambdabot> Unknown command, try @list
08:37:01 <iqubic> > let x = 1:x in x
08:37:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:37:04 <Rembane> Yimo: Use recursion.
08:37:13 <iqubic> It does work if you do it that way.
08:37:19 <Yimo> ^ That's a good idea, hence I asked for how to use getLine ^^
08:37:32 <Yimo> well iqubic hmm
08:37:50 <Yimo> that's rather a recursive declaration of x
08:37:50 <Rembane> grokkingStuff: Lambdabot doesn't do IO because IO makes it much harder to have a secure bot.
08:38:07 <iqubic> Yimo: Yes, that's right.
08:38:18 <grokkingStuff> but yahb is able to?
08:38:25 <mniip> grokkingStuff, lambdabot is a language level sandbox
08:38:31 <iqubic> I'm not changing the value of x ever.
08:38:31 <mniip> it relies on security of safehaskell
08:38:39 <mniip> and lack of ghc bugs and the like
08:38:53 <iqubic> And yahb is ghci running in a sandboxed environment.
08:39:00 <mniip> yahb is a process level sandbox, it relies on the security of the linux kernel
08:39:11 <mniip> and we
08:39:12 <mniip> ll
08:39:13 <mniip> my code
08:39:55 <yohotchoc> % deleteMniipsFiles
08:39:55 <yahb> yohotchoc: ; <interactive>:15:1: error: Variable not in scope: deleteMniipsFiles
08:39:59 <yohotchoc> worth a shot
08:40:02 <Yimo> security over security
08:40:05 <Yimo> securiception
08:40:14 <mniip> %! rm -rf /*
08:40:15 <yahb> mniip: rm: failed to get attributes of '/': No such file or directory
08:40:19 <grokkingStuff> % :!ls
08:40:19 <yahb> grokkingStuff: cit.txt; test; toastV1X5eI; ym.txt
08:40:26 <grokkingStuff> huh, that's awesome
08:40:35 <grokkingStuff> % :!ls ~
08:40:35 <yahb> grokkingStuff: ls: cannot access /var/lib/xsbot: No such file or directory
08:40:39 <iqubic> let x = 0:y; y = 1:x in x
08:40:51 <iqubic> > let x = 0:y; y = 1:x in x
08:40:53 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
08:40:53 <mniip> PM it if you're going to experiment
08:41:02 <grokkingStuff> Thanks mniip! Learned something new.
08:41:12 <iqubic> Yimo: That technique is called tying the knot.
08:41:27 <grokkingStuff> mniip++
08:41:42 <iqubic> % :!pwd
08:41:43 <yahb> iqubic: /var/lib/xsbot/sandbox/root/data
08:41:57 <Yimo> iqubic good name for that technique xD
08:42:05 <grokkingStuff> iqubic: any resources on circular lists in haskell?
08:42:18 <iqubic> I don't have one.
08:42:35 <iqubic> > cycle [0,1]
08:42:37 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
08:42:43 <grokkingStuff> in c, i know how to mess around with circular lists because it's really just a list with a pointer at the end. But haskell lists are immutable.
08:42:51 <iqubic> It's the same list as you get there.
08:42:54 <grokkingStuff> How do you make changes to a circular list in haskell?
08:42:54 <mniip> they can be immutably cuclic
08:43:01 <mniip> you don't!
08:43:04 <mniip> (you can't)
08:43:08 <Yimo> grokkingStuff you can't
08:43:20 <Yimo> you can however, put it into a function, and save it in another constant
08:43:31 <Yimo> haskell + variables = disagreement
08:43:34 <grokkingStuff> let's say I want to add an element to a circular list.
08:43:43 <mniip> you can't
08:43:49 <Yimo> ^
08:43:51 <grokkingStuff> > cycle $ [1,0] ++ [1]
08:43:53 <lambdabot>  [1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1,1,0...
08:43:55 <mniip> if it's a tied-knot circular [] list
08:43:58 <mniip> then you cannot
08:44:10 <mniip> you cannot knot
08:44:12 <Rembane> You can prepend an element tohugh
08:44:21 <grokkingStuff> is there a circular list that i can modify?
08:44:23 <Yimo> at the start
08:44:25 <mniip> in fact, you can knot,
08:44:29 <mniip> but the problem is that you cannot unknot
08:44:38 <Yimo> grokkingStuff you can't modify anything in haskell
08:44:46 <mniip> well that's false
08:44:51 <Yimo> almost anything
08:44:58 <mniip> % i <- newIORef False
08:44:58 <yahb> mniip:
08:45:03 <mniip> % readIORef i
08:45:03 <yahb> mniip: False
08:45:08 <mniip> % writeIORef i True
08:45:09 <yahb> mniip:
08:45:10 <mniip> % readIORef i
08:45:10 <Rembane> Which lies should we tell? :)
08:45:10 <yahb> mniip: True
08:45:14 <grokkingStuff> mniip: so only use the knot if you want that list to extend forever and you're not planning on changing it. Got it.
08:45:43 <Rembane> > map (*2) $ cycle $ [1,0] -- This though...
08:45:45 <lambdabot>  [2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0...
08:45:58 <grokkingStuff> Yimo: I want a circular list so that i can make a function " append circularList newElement = newCircularList
08:46:23 <mniip> Rembane, that doesn't have a tied knot
08:46:35 <huss`> grokkingStuff: adventofcode ?
08:46:57 <iqubic> > let x = 0:y; y = 1:x in map (*2) x
08:46:59 <lambdabot>  [0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2,0,2...
08:47:03 <grokkingStuff> huss`: not really. Just curious. Circular lists did come up in the advent of code, though.
08:47:06 <grokkingStuff> On that note.
08:47:12 <grokkingStuff> Merry Christmass!
08:47:13 <iqubic> Yes, but mniip my thing works.
08:47:41 <Yimo> grokkingStuff the issue is that, you can't know the length of the cycle once the list is circular
08:47:47 <grokkingStuff> mniip: I think cycle just hides the knot-tying behind a function.
08:47:48 <Yimo> (unless you save it before)
08:47:58 <mniip> sure does
08:48:00 <mniip> but fmap breaks it
08:48:01 <mniip> kinda
08:48:08 <mniip> not entirely, it still has nice properties, but
08:48:20 <Rembane> mniip: Oh, okay.
08:48:25 <grokkingStuff> Yimo: So i should make a data structure that holds the original list and the actual circular list?
08:48:41 <kamyar> Guys plz see my ode: http://lpaste.net/1332304520281063424
08:48:44 <kamyar> cod
08:48:56 <iqubic> let x = [0,1]; y = x:x in y
08:48:57 <Yimo> grokkingStuff perhaps that'd work
08:49:04 <kamyar> I have a problem: the time increases gradualy
08:49:10 <iqubic> wait, my thing has an error.
08:49:27 <kamyar> while I expect approx. equal time result
08:49:33 <mniip> kamyar, have you tried a lorentzian transform/
08:49:46 <kamyar> mniip: What is it?
08:49:50 <grokkingStuff> Yimo: is there a library for data structures in haskell? surely someone has made one.
08:49:55 <Rembane> Okay, so a circular list isn't an infinite list. That's good to know.
08:49:57 <iqubic> what is a lorentzian transform?
08:50:13 <iqubic> Rembane: It actually is infinite.
08:50:13 <mniip> that was supposed to be a joke about spacetime continuum
08:50:27 <iqubic> that's what the ... in lambdabot's output shows.
08:50:29 <mniip> because of the peculiar way you stated your problem
08:51:53 <iqubic> I don't get it at all.
08:52:22 <yohotchoc> kamyar: what time increases gradually? what are you expecting to happen?
08:52:58 <iqubic> So let's say I have the data type "V3 a = a a a" and I have a functor instance for it. How do I tell GHC that it can only have an Applicative instance if the a is applicative?
08:52:59 <iqubic>  
08:53:07 <Rembane> iqubic: Maybe the other way around. An infinite list isn't automatically a circular list?
08:53:18 <iqubic> Yes, that is correct.
08:53:35 <iqubic> > iterate f x :: Expr
08:53:37 <lambdabot>  error:
08:53:37 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Expr]’
08:53:37 <lambdabot>      • In the expression: iterate f x :: Expr
08:53:54 <iqubic> > iterate f x :: [Expr]
08:53:57 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
08:54:14 <iqubic> That is also infinite, but certainly not circular.
08:54:30 <metahumor> parser and Applicative related question: is there a more idiomatic way of doing "(,,) <$> f parseFoo <*> f parseBar <*> parseBaz"?
08:54:36 <yohotchoc> well, it can be
08:54:40 <yohotchoc> depending on f
08:55:09 <metahumor> something like a "(,,) . weirdmap f <$> parseFoo <*> parseBar <*> parseBaz"
08:55:30 <metahumor> f :: Parser a -> Parser a, f = skipSomeTill anyChar
08:55:41 <nullie> I think you can fmap over parser
08:56:27 <nullie> oh that f
08:56:53 <metahumor> sorry, i'm missing a f parseBaz in my original statement
08:57:29 <metahumor> basically, simplify "g <$> f a <*> f b <*> f c" to some "g . f <?$?> a <*> b <*> c"
09:12:36 <Gurkenglas> a, b and c will have to have the same type for this to work
09:12:53 <Gurkenglas> (In particular f /= show)
09:13:55 * hackage extensible-effects 2.2.1.0 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.2.1.0 (shergill)
09:15:43 <Gurkenglas> :t \g f -> fmap g . traverse f -- metahumor
09:15:44 <lambdabot> (Applicative f, Traversable t) => (t b1 -> b2) -> (a -> f b1) -> t a -> f b2
09:16:12 <Gurkenglas> Used like "fmap g $ traverse f [a,b,c]"
09:16:43 <metahumor> but no way to keep it in " <$> <*> <*> <*>" format, i'd have to put the arguments in a list
09:18:49 * hackage twitter-conduit 0.2.3 - Twitter API package with conduit interface and Streaming API support.  https://hackage.haskell.org/package/twitter-conduit-0.2.3 (TakahiroHimura)
09:19:06 <Gurkenglas> "fmap (g :: (b,b,b) -> c) $ each f (a,b,c)" using lens if you'd like to emphasize the trinity
09:19:53 <Gurkenglas> "g <$> traverse f [a,b,c]" / "g <$> each f (a,b,c)" even
09:21:21 <metahumor> gotcha. thanks! i think i'll stick with writing out the "skip" in the parser for each token to be more explicit
09:30:44 <mniip> oh right
09:30:49 <mniip> because it's a traversal
09:31:00 <mniip> that actually makes hella lot of sense
09:31:31 <iqubic> What are we doing here?
09:32:00 <iqubic> Something about parsers?
09:32:11 <iqubic> I know nothing about Haskell Parsers.
09:32:27 * hackage ansi-terminal 0.8 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.8 (RomanCheplyaka)
09:33:43 <mniip> iqubic, putting lens traversals in place of traverse
09:33:56 <iqubic> Aren't they the same thing?
09:34:35 <mniip> > traverse ZipList [[1,2],[3,4,5],[6,7]]
09:34:37 <lambdabot>  ZipList {getZipList = [[1,3,6],[2,4,7]]}
09:34:44 <mniip> > each ZipList ([1,2],[3,4,5],[6,7])
09:34:46 <lambdabot>  ZipList {getZipList = [(1,3,6),(2,4,7)]}
09:35:02 <iqubic> What is the zipList newtype wrapper for?
09:35:21 <Gurkenglas> Look at the examples!
09:35:24 <mniip> it's got a different Applicative
09:35:28 <iqubic> And why do those yeild different results?
09:35:40 <iqubic> :t each
09:35:41 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
09:35:51 <iqubic> :t traverse
09:35:52 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:36:08 <iqubic> Those look more or less the same.
09:36:16 <iqubic> What does traverse even do???
09:36:27 <mniip> it's a traversal that selects every element
09:36:42 <iqubic> Huh? How does that work??
09:36:44 <Gurkenglas> Oh boy now you gotta explain the difference to each
09:36:52 <iqubic> Can I see a simple example?
09:37:09 <mniip> each assumes a homogeneous tuple and selects every component
09:37:19 <mniip> but there's probably other Each instances that I'm unaware of
09:37:37 <Gurkenglas> > each ZipList [[1,2],[3,4,5],[6,7]]
09:37:39 <lambdabot>  ZipList {getZipList = [[1,3,6],[2,4,7]]}
09:37:41 <metahumor> difference in python between map(list, zip(*my_list) and just zip(*my_list)
09:37:56 <iqubic> > traverse [1,2,3]
09:37:58 <lambdabot>  error:
09:37:58 <lambdabot>      • Couldn't match expected type ‘a -> f b’
09:37:58 <lambdabot>                    with actual type ‘[Integer]’
09:38:06 <iqubic> Why doesn't that work?
09:38:15 <metahumor> :t traverse [1..3]
09:38:15 <lambdabot> error:
09:38:16 <lambdabot>     • Couldn't match expected type ‘a -> f b’
09:38:16 <lambdabot>                   with actual type ‘[Integer]’
09:38:20 <mniip> :t traverse
09:38:22 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:38:23 <mniip> :t [1..3]
09:38:24 <lambdabot> (Enum a, Num a) => [a]
09:38:29 <iqubic> > traverse [Just 1, Just 2, Just 3]
09:38:32 <lambdabot>  error:
09:38:32 <lambdabot>      • Couldn't match expected type ‘a -> f b’
09:38:32 <lambdabot>                    with actual type ‘[Maybe Integer]’
09:38:34 <mniip> [] doesn't go with ((->) a)
09:38:41 <iqubic> Nope.
09:38:49 <metahumor> :t traverse . fmap const [1..3]
09:38:50 <lambdabot> error:
09:38:50 <lambdabot>     • Couldn't match expected type ‘a -> a1 -> f b’
09:38:50 <lambdabot>                   with actual type ‘[b0 -> Integer]’
09:38:58 <iqubic> > sequenceA [Just 1, Just 2, Just 3]
09:38:58 <metahumor> :t traverse $ fmap const [1..3]
09:38:59 <lambdabot> error:
09:38:59 <lambdabot>     • Couldn't match expected type ‘a -> f b’
09:38:59 <lambdabot>                   with actual type ‘[b0 -> Integer]’
09:38:59 <lambdabot>  Just [1,2,3]
09:39:12 <iqubic> Well my sequenceA thing worked
09:39:13 <metahumor> :t traverse $ fmap (Just . const) [1..3]
09:39:14 <lambdabot> error:
09:39:14 <lambdabot>     • Couldn't match expected type ‘a -> f b’
09:39:14 <lambdabot>                   with actual type ‘[Maybe (b0 -> Integer)]’
09:39:17 <Gurkenglas> I wonder how hard it'd be to set up an online scratchpad that respected types
09:39:28 <metahumor> :t traverse $ fmap (const . Just) [1..3]
09:39:28 <mniip> what do you mean
09:39:29 <lambdabot> error:
09:39:29 <lambdabot>     • Couldn't match expected type ‘a -> f b’
09:39:29 <lambdabot>                   with actual type ‘[b0 -> Maybe Integer]’
09:39:40 <mniip> metahumor, what are you even trying to do
09:39:40 <oak-> What would be the most state-of-the-art and maintained library for implementing websocket client? Should I try Wuss or are there better options? Servant.API provides a nice way to specify REST API and I would love to have something similar for Websockets
09:39:45 <Gurkenglas> iqubic, sequenceA = traverse id
09:39:50 <mniip> > traverse id $ fmap Just [1..3]
09:39:51 <lambdabot>  Just [1,2,3]
09:40:03 <iqubic> > traverse +1 (map Just [1..5])
09:40:04 <lambdabot>  error:
09:40:04 <lambdabot>      • Could not deduce (Enum a0)
09:40:04 <lambdabot>        from the context: (Enum a,
09:40:09 <iqubic> Huh?
09:40:13 <Gurkenglas> :t (+1)
09:40:14 <lambdabot> Num a => a -> a
09:40:16 <mniip> > (traverse id $ fmap const [1..3]) ()
09:40:18 <lambdabot>  [1,2,3]
09:40:23 <Gurkenglas> :t +1
09:40:25 <lambdabot> error: parse error on input ‘+’
09:40:49 <iqubic> Can I see an example of traverse that uses something other than id as the function?
09:41:00 <mniip> > (traverse id $ fmap (traverse id) $ fmap (Just . const) [1..3]) ()
09:41:01 <Gurkenglas> > traverse Just [1..3]
09:41:02 <lambdabot>  [Just 1,Just 2,Just 3]
09:41:03 <lambdabot>  Just [1,2,3]
09:41:20 <mniip> > traverse (\x -> [x, '_']) "hello"
09:41:21 <lambdabot>  ["hello","hell_","hel_o","hel__","he_lo","he_l_","he__o","he___","h_llo","h_...
09:41:26 <huss`> Is there any good example of a handwritten lens stuff (not using haskell template) ?
09:41:57 <mniip> traverse ZipList, also
09:42:01 <metahumor> huss`: I really like the lens over tea tutorials
09:42:05 <iqubic> > traverse (\x -> [x, '-']) "abc"
09:42:07 <lambdabot>  ["abc","ab-","a-c","a--","-bc","-b-","--c","---"]
09:42:12 <mniip> % traverse print [1..3]
09:42:12 <yahb> mniip: 1; 2; 3; [(),(),()]
09:42:14 <iqubic> I love that.
09:42:26 <metahumor> huss`: they handwrite many important lens things
09:42:35 <c_wraith> huss`: writing a lens by hand tends to be the just writing the simplest thing with the correct type
09:42:46 <iqubic> So traverse applies the same function to each element of the traversable thing?
09:42:53 <mniip> aLens _ _ _ = undefined
09:43:03 <c_wraith> ...  that's total
09:43:05 <Gurkenglas> iqubic, yes, and collects the results
09:43:08 <iqubic> What makes travesable different from fmap?
09:43:11 <mniip> bummer
09:43:16 <iqubic> Because fmap does that too.
09:43:17 <Gurkenglas> c_wraith, how about "that fits the type exactly"
09:43:38 <mniip> iqubic, research that yourself
09:43:42 <iqubic> :t fmap
09:43:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:43:50 <iqubic> :t traverse
09:43:52 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:44:01 <Gurkenglas> iqubic, from the docs on traverse: "Map each element of a structure to an action, evaluate these actions from left to right, and collect the results."
09:44:16 <nullie> Gurkenglas: how is it different from foldable?
09:44:21 <iqubic> I see. And an action is what exactly?
09:44:36 <c_wraith> :t traverse print [1..10]
09:44:38 <lambdabot> IO [()]
09:44:39 <Gurkenglas> nullie, the foldable destroys the structure
09:44:42 <c_wraith> iqubic: does that help?
09:44:44 <iqubic> nullie: traversal retains structure
09:44:55 <iqubic> c_wraith: yes.
09:45:04 <Gurkenglas> :t traverse_ -- nullie, see this, no need for Traversable because the structure is discarded
09:45:05 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
09:45:24 <mniip> curious
09:45:29 <mniip> I did not know about the relaxed context
09:45:43 <iqubic> fmap only works with total functions, but traverse accepts actions?
09:45:47 <Gurkenglas> mniip, what's your definition of context, by the way?
09:45:58 <c_wraith> :t fmap print [1..10]
09:45:59 <lambdabot> [IO ()]
09:46:01 <mniip> the thing to the left of =>
09:46:03 <Gurkenglas> iqubic, say pure instead of total there
09:46:04 <mniip> as per ghc slang
09:46:18 <c_wraith> iqubic: both have types that mean something.
09:46:19 <iqubic> mniip: traverse and traverse_ are in two different type classes even.
09:46:24 <c_wraith> iqubic: but they do different things
09:46:25 <Gurkenglas> So context = constraint?
09:46:33 <iqubic> c_wraith: I see.
09:46:36 <mniip> I suppose so
09:46:50 <nullie> > traverse (\a -> [a, a]) [1, 2, 3]
09:46:52 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
09:46:59 <mniip> in ghc slang constraint is reserved for something else
09:47:06 <c_wraith> Gurkenglas: point of view.  It's a constraint when you're calling a function.  It's a context when you're writing the function.
09:47:06 <mniip> I mean when not referring to the Constraint kind
09:47:38 <iqubic> > traverse (\a -> [a, a + 1]) [1..3]
09:47:40 <lambdabot>  [[1,2,3],[1,2,4],[1,3,3],[1,3,4],[2,2,3],[2,2,4],[2,3,3],[2,3,4]]
09:47:49 <Gurkenglas> … what do they mean by constraint, then, when they're ignoring the specification?
09:48:01 <mniip> the typechecker is a constraint solver
09:48:14 <mniip> there's typing constraints of various sorts
09:48:20 <mniip> and the typechecker solves them
09:48:50 <Gurkenglas> I thought that's unification :D
09:49:04 <Gurkenglas> What does unification mean in ghc slang, then?
09:49:16 <mniip> unification is just the process of structural dismantling of equality constraints into lesser equality constraints
09:49:42 <Gurkenglas> What constraints are there than aren't equality constraints?
09:49:44 <mniip> but don't quote me on that
09:49:46 <Gurkenglas> *that
09:49:51 <mniip> that I can't answer
09:51:00 <mniip> https://hackage.haskell.org/package/ghc-8.2.1/docs/TcRnTypes.html#t:Ct
09:52:03 <mniip> also
09:52:04 <mniip> https://hackage.haskell.org/package/ghc-8.2.1/docs/TcRnTypes.html#t:WantedConstraints
09:52:05 <Gurkenglas> Just messing with you, but the next step would be to suggest that in our functional paradigm we should give the name to the function, unification, rather than what it works on
09:52:19 <metahumor> what's the magic going on such that a strict iterate ends up taking more memory than a lazy iterate? http://lpaste.net/361101
09:53:47 <mniip> metahumor, interactively defined function
09:53:52 <mniip> compiled to BCO and not native code
09:54:31 <metahumor> and if i define iterate' in a module and import that, that's still an issue?
09:54:43 <mniip> if it's compiled
09:54:47 <mniip> make sure it's compiled
09:55:10 <Gurkenglas> Is Prelude compiled while we're using ghci?
09:57:27 <mniip> yes
09:57:45 <mniip> hrm
09:57:53 <mniip> time to update ghc!
09:58:00 <mniip> fun times ahead
09:58:56 <mniip> I have no idea how to configure it. hopefully config.log remembers
09:59:06 <mniip> it does
10:02:35 <mniip> configure: error: GHC version 8.0 or later is required to compile GHC.
10:02:37 <mniip> say what now
10:04:47 <mniip> yay
10:04:57 <mniip> let's do something that is known not to work
10:05:33 <Gurkenglas> How incredibly bad would be the idea to make TH and ghc use the same data types when they talk about types?
10:05:59 <mniip> TyThings in my Q?
10:06:31 <phadej> Gurkenglas: they will use same types in the longer run
10:06:54 <phadej> See goals in https://ghc.haskell.org/trac/ghc/wiki/ImplementingTreesThatGrow
10:07:25 <Gurkenglas> What stops people from just doing a PR right now that renames everything to match?
10:07:38 <phadej> because they don't match structurally
10:08:06 <Gurkenglas> Okay. And ghc should be renamed to the TH versions, right? Because TH is a library and ghc an app
10:08:16 <mniip> I don't think it's a good idea
10:08:30 <mniip> I mean ghc's internal structures are much less nice than haskell-src-exts
10:08:45 <iqubic> mniip: why do you need to update GHC?
10:08:52 <Gurkenglas> mniip, imagine the power we would have if there was a unify combinator in prelude
10:08:55 <mniip> iqubic, they fixed a bug
10:09:07 <iqubic> What bug was that?
10:09:08 <phadej> mniip: trees that grow work would change ghc types too
10:09:21 <mniip> % x = 3
10:09:25 <yahb> mniip:
10:09:25 <phadej> I recommend to read the paper
10:09:26 <mniip> % x
10:09:27 <yahb> mniip: ; <interactive>:2:1: error: Variable not in scope: x
10:09:30 <mniip> % :show bindings
10:09:31 <yahb> mniip: ghc: ^^ Could not load 'interactive_Ghci4_zdtrModule2_closure', dependency unresolved. See top entry above.; ghc: ^^ Could not load 'interactive_Ghci4_zdtrModule4_closure', dependency unresolved. See top entry above.; Ghci1.it :: () = (); Ghci2.it :: () = (); it :: () = (); $trModule :: GHC.Types.Module = _; $trModule1 :: GHC.Types.TrName = _; $trModule2 :: GHC.Prim.Addr# = *** Exception: ; ByteCodeLink
10:09:39 <phadej> it's by SPJ, so easy to follow
10:09:39 <phadej> :)
10:09:47 <iqubic> Gurkenglas: what would the unify combinator do?
10:09:58 <mniip> unify :: a -> a -> a
10:10:04 <mniip> ;)
10:10:05 <iqubic> mniip: That seems like an issue. Does it work with let?
10:10:07 <mniip> yes
10:10:09 <mniip> strangely
10:10:12 <Gurkenglas> unify :: Type -> Type -> Maybe Type -- iqubic
10:10:21 <mniip> Gurkenglas, that's too weak
10:10:33 <mniip> what about qualified types
10:10:41 <Gurkenglas> ?
10:10:44 <mniip> and with qualified types what about tyvar supplies
10:10:45 <iqubic> I thought that 8.x.y let you remove the let keyword.
10:10:59 <mniip> iqubic, it's a bug that only triggers with -fobject-code
10:11:08 <iqubic> this advanced haskell stuff boils my brain.
10:11:38 <Gurkenglas> Qualified as in qualified imports?
10:11:44 <mniip> forall-qualified
10:11:49 <mniip> and context-qualified
10:12:01 <iqubic> I lost you at tyvars.
10:12:06 <mniip> type variables
10:12:10 <mniip> ghc slang
10:12:24 <Gurkenglas> Where's the problem with Type -> Type -> Maybe Type handling these qualifications?
10:12:32 <iqubic> i got that. I just don't know what a tyvar is.
10:12:40 <mniip> Gurkenglas, everywhere
10:12:49 <iqubic> I know what it stands for, but not what it is.
10:13:08 <mniip> Gurkenglas, basically, welcome to the world of the GHC typechecker
10:13:22 <Gurkenglas> For example, (forall a b. a -> b -> C) and (forall b c. A -> b -> c) would be unified to Just (forall b. A -> b -> c)
10:13:29 <Gurkenglas> *"A -> b -> C" :(
10:13:46 <mniip> so no "free" variables?
10:14:18 <Gurkenglas> I... don't think so? What are free variables good for?
10:14:19 <iqubic> Why is your conversation so confusing to me?
10:14:26 <mniip> typing assumptions
10:14:40 <mniip> you can't typecheck a lambda without typing assumptions
10:14:43 <mniip> and rigid/skolem variables
10:14:58 <mniip> or as I started to call them
10:15:01 <mniip> {rigid,skolem}
10:15:07 <mniip> ;(
10:15:09 <mniip> ;) *
10:15:29 <Gurkenglas> What's a typing assumption and a rigid/skolem variable?
10:15:33 <mniip> sigh
10:15:47 <mniip> I'm just trying to scare you into doing your own research because there definitely be dragons
10:16:10 <mniip> in part because I only know so much
10:16:12 <iqubic> I know nothing about anything now.
10:16:15 <Gurkenglas> And I keep doing one step after the other and seeing more dragon pictures appear on the map wherever I'm not stepping
10:16:40 <mniip> Gurkenglas, ok, step back to simply typed lambda calculus
10:16:41 <iqubic> Your conversation got so confusing a few minutes ago.
10:16:49 <mniip> there's a typing rule that says
10:17:43 <mniip> Г,(x :: A) ⊦ e : B
10:17:48 <mniip> --------------
10:18:00 <mniip>   Г ⊦ (\x -> e) :: A -> B
10:18:04 <iqubic> I don't know those symbols. I guess I need to research them.
10:18:25 <dminuoso> iqubic: dont use sequenceA
10:18:37 <iqubic> dminuoso: What do you want me to use?
10:18:43 <mniip> apologies for poor typesetting but this is irc
10:18:48 <Gurkenglas> I happen to have seen some of these symbols in a university course. I guess you failed at using undefined symbols to make me stop asking questions.
10:18:51 <iqubic> How should I handle your first task?
10:19:30 <iqubic> dminuoso: do you want me to use traverse instead?
10:19:30 <dminuoso> iqubic: Do you have the Functor instance?
10:19:40 <dminuoso> iqubic: I want you to _implement_ traverse.
10:19:40 <iqubic> I do have the functor instance.
10:19:49 <iqubic> Ah. I see.
10:19:59 <monochrom> You can't stop people asking. You can only stop yourself answering. This is why I coined "don't answer to answer, just don't answer".
10:20:01 <Gurkenglas> "If we know that x being in A implies that e is in B, then the function (\x -> e) must be in A -> B.". Right?
10:20:04 <iqubic> Write the traversal instance using traverses.
10:20:15 <mniip> Gurkenglas, plus other assumptions in Gamma
10:20:47 <iqubic> dminuoso: I have no idea how the traverse function works.
10:20:58 <dminuoso> iqubic: And that is the important first step.
10:21:00 <dminuoso> :t traverse
10:21:01 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:21:06 <iqubic> I found it easier to reason about sequenceA.
10:21:19 <iqubic> But I can try to write traverse.
10:21:31 <dminuoso> iqubic: And dont do it in terms of sequenceA =)
10:21:40 <iqubic> I won't.
10:22:42 <mniip> Gurkenglas, how much do you know about formal systems
10:24:01 <Gurkenglas> Not enough to answer that question without more detail
10:24:16 <iqubic> dminuoso: I have done traverse.
10:24:17 <mniip> what does ⊦ mean
10:24:23 <mniip> and that long ------------ line
10:24:30 <dminuoso> iqubic: Can you show me your implementation for Functor and Traverse?
10:25:07 <iqubic> http://termbin.com/y95g
10:25:10 <iqubic> see that.
10:25:26 <Gurkenglas> ⊦ :: "Set of statements" -> "Statement" -> Bool
10:25:40 <iqubic> that is just the simplest way I could see to implement those functions.
10:26:03 <Gurkenglas> ---------- = "If we know the above, we know the below"
10:26:05 <iqubic> I also wrote foldMap too. Because I wanted experience with foldable.
10:26:10 <dminuoso> iqubic: Great. Now I want you to implement a new function, lets call it traverseX, which only traverses the first component ("X coordinate") but leaves the other two untouched.
10:26:25 <dminuoso> iqubic: Part of that requires finding a suitable type signature.
10:26:28 <mniip> Gurkenglas, that is informal
10:27:20 <Gurkenglas> ---------- = "Let us restrict the set of sets of statements to that such that every instance of the above implies the corresponding instance of the below"
10:27:32 <dminuoso> iqubic: But before you do, we could look at this.
10:27:52 <Gurkenglas> -"to that", I suppose
10:28:03 <benzrf> to what extent does ghc do thunk updating?
10:28:18 <benzrf> does it always update all thunks that get forced? and if so, wouldn't that incur stack frames for nested thunks?
10:28:19 <dminuoso> iqubic: So `traverse` has some interesting properties. In the first argument (a -> f b) you get to pick a functor. Now there's two very interesting Functors to consider.
10:28:33 <dminuoso> iqubic: For the regular traverse case, the interesting functor is the Identity functor. Can you see how?
10:28:44 <iqubic> Yes. I can.
10:29:05 <benzrf> e.g.: i have a thunk created from "Just 1", bound to x. then i make a thunk, "const x ()"
10:29:15 <iqubic> SequenceA = traverse id.
10:29:18 <iqubic> traverseX f (V3 x y z) = liftA3 V3 (f x) y z
10:29:31 <benzrf> if i then match on this second thunk, it must force the first thunk in the process - does the first thunk get updated? if so: that incurs a stack frame, right?
10:29:32 <iqubic> Not sure what the type of that function is, but it seems to work.
10:30:02 <Gurkenglas> We have a set of sets of statements, its elements are called models, and each "... \n -------- \n ..."-construct deletes all models that don't follow that construct everywhere
10:30:20 <iqubic> dminuoso: I can make traverseY and traverseZ similarly,, if you want.
10:30:29 <Gurkenglas> mniip, better?
10:30:33 <mniip> Gurkenglas, a formal system is an alphabet, a grammar that defines what formulae are well-formed, and a set of n-ary relations called inference rules.
10:30:41 <dminuoso> iqubic: That doesn't look right.
10:30:44 <dminuoso> iqubic: Check the type.
10:30:55 <iqubic> I don't know what the type is.
10:31:07 <iqubic> What type are we aiming for?
10:31:11 <dminuoso> iqubic: The function should be like traverse.
10:31:25 <dminuoso> Except it only "does its thing" on one component, leaving the other alone.
10:31:30 <mniip> Gurkenglas, a derivation is a finite sequence of well-formed formulae such that for every i'th formula there's an n-ary inference rule such that there are n-1 formulae of indices less than i such that that inference rule relates those n-1 formulae to the i'th
10:31:32 <benzrf> .....weird, i tried testing this using Debug.Trace and it doesnt seem to be saving thunks at all o.O
10:31:36 <iqubic> Yes, that is what I wrote.
10:31:59 <iqubic> My traverseX function only effects the X component
10:32:15 <mniip> "⊦ A" is saying that there's a derivation that contains the formula A
10:32:42 <mniip> if we allow our derivation to also contains arbitrary formulae from set Г
10:32:44 <dminuoso> iqubic: No it doesn't. It doesnt behave the same way.
10:32:49 <iqubic> How so?
10:32:54 <dminuoso> :t traverse
10:32:56 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:33:00 <iqubic> How is my function different?
10:33:08 <dminuoso> iqubic: Compare the type signatures.
10:33:14 <mniip> "Г ⊦ A" is saying that there's a derivation possibly making use of formulae in Г that contains A
10:33:21 <dminuoso> iqubic: Yours looks wildly different.
10:33:25 <Gurkenglas> Makes sense so far.
10:33:39 <dminuoso> iqubic: Like I said, _start_ with the type.
10:33:42 <dminuoso> Not the implementation
10:33:43 <iqubic> I don't have a type signature for my traverseX.
10:33:49 <dminuoso> iqubic: You have a type signature of traverse.
10:33:53 <mniip> the long horizontal line is usually used for rules of inference
10:34:07 <dminuoso> You should be able to derive the necessary signature for traverseX by considering how traverse works.
10:34:37 <dminuoso> iqubic: If not we should maybe look at what traverse does.
10:34:44 <mniip> ⊦A->B,  ⊦A
10:34:45 <mniip> ---------- (modus ponens)
10:34:45 <mniip>     ⊦B
10:34:53 <iqubic> Yeah. I need to learn how traverse works.
10:34:57 <amalloy> fwiw i think i understand traversable reasonably well and i don't understand what type you're trying to get iqubic to come up with for traverseX
10:35:16 <mniip> this is actually a ternary relation, containining exactly the tuples of the form <A->B, A, B>
10:35:23 <mniip> for all A, B, well-formed formulae
10:35:53 <iqubic> dminuoso: I'd like to see you explanation for how traverse works.
10:35:56 <Gurkenglas> All of that makes sense. I think you can speed up, I'll complain if you use something without having defined it or something ^^
10:36:04 <mniip> now, someone better correct me if I am wrong,
10:36:21 <mniip> but in things like type theory and the like, we actually go a bit meta
10:36:23 <iqubic> I feel like there are two conversations going on at once here.
10:36:33 <mniip> and ⊦ is one of the symbols in our alphabet
10:36:46 <iqubic> Me and dminuoso + mniip and Gurkenglas
10:37:04 <iqubic> dminuoso: What do you want me to do for traverseX?
10:37:04 <mniip> and "Г ⊦ A" is one possbile shape of a formula
10:37:17 <dminuoso> iqubic: The function (a -> f b) maps an element to an action (Applicative), traverse then runs these actions and collects the results.
10:37:29 <iqubic> Sure.
10:37:34 <iqubic> :t traverse
10:37:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:37:42 <dminuoso> iqubic: Try rewriting without liftA3 to make this a bit more obvious what it does.
10:37:48 <dminuoso> i.e. in terms of <$> and <*>
10:38:15 <mniip> and so ⊦ loses its meaning as the operator I defined in terms of a finite sequence of formulae
10:38:26 <mniip> and instead our type theory's equations define its meaning
10:38:36 <mniip> s/equations/inference rules/
10:38:40 <dminuoso> iqubic: So, the traverseX should only traverse (i.e. run that function) over a single component, but otherwise behave the same.
10:38:47 <iqubic> traverse f (V3 x y z) = V3 <$> (f x) <*> (f y) <*> (f z)
10:38:51 <mniip> which is usually similar
10:38:53 <mniip> but ymmv
10:39:18 <dminuoso> iqubic: Right. So this one traverses with `f` over each component.
10:39:24 <Gurkenglas> Surely there's a version of ⊦ inside quotes and one outside while we're talking about ⊦
10:39:26 <iqubic> Yes, that's right.
10:39:33 <mniip> right
10:39:42 <iqubic> With <*> doing the combining of the applicatives.
10:39:43 <mniip> usually the outer one is omitted and ----------- is used
10:39:43 <dminuoso> iqubic: And now "traverseX" is supposed to traverse over X, but leave the other two untouched.
10:39:46 <dminuoso> iqubic: Right.
10:40:42 <mniip> Gurkenglas, examine https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Typing_rules
10:41:04 <Gurkenglas> Makes sens up to before examine, *clicks link*
10:41:10 <iqubic> I don't think this is right, is it?
10:41:16 <iqubic> traverseX f (V3 x y z) = V3 <$> (f x) <*> y <*> z
10:41:31 <iqubic> No, that isn't right I don't think.
10:41:31 <dminuoso> iqubic: No it's not. Check the type signature.
10:41:42 <dminuoso> :t traverse
10:41:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:41:47 <dminuoso> Yours looks like: Applicative f => (f a -> f a) -> V3 (f a) -> f (V3 a)
10:42:12 <iqubic> traverseX f (V3 x y z) = V3 (f x) y z
10:42:16 <iqubic> there we are.
10:42:25 <dminuoso> iqubic: That does not run any effects.
10:42:32 <mniip> Gurkenglas, in this case we're implicitly including some kind of set theory in our formula language (it doesn't have to be anything advanced, to the point where we can basically ignore what it is)
10:42:33 <iqubic> Yeah, I noticed.
10:42:37 <dminuoso> iqubic: At the end you want an Applicative as the result.
10:42:42 <iqubic> I know.
10:42:49 <mniip> Gurkenglas, hence the ∈ symbol
10:42:55 <iqubic> How do I make an applicative?
10:43:07 <dminuoso> iqubic: Check your implementation of traverse. ;-)
10:43:16 <dminuoso> iqubic: Basically its an adapation of it.
10:43:29 <dminuoso> traverse f (V3 x y z) = V3 <$> (f x) <*> (f y) <*> (f z)
10:43:42 <iqubic> Why is traverseX f (V3 x y z) = V3 (f x) y z wrong?
10:44:02 <iqubic> because it doesn't run any effects.
10:44:06 <mniip> Gurkenglas, other formulae in our language are "Г ⊦ x : a" and "c is a constant of type a"
10:44:06 <dminuoso> At the end you need to get some `f (t b)` back
10:44:11 <iqubic> I know.
10:44:17 <dminuoso> iqubic: You just have something.. else
10:45:07 <dminuoso> iqubic: So basically you have to reconstruct the V3 inside the applicative if that helps.
10:45:11 <mniip> Gurkenglas, and then these four inference rules dictate how we can build a sequence of formulas
10:45:23 <dminuoso> iqubic: But only map X to the effect.
10:45:50 * hackage drifter-postgresql 0.2.1 - PostgreSQL support for the drifter schema migration tool  https://hackage.haskell.org/package/drifter-postgresql-0.2.1 (MichaelXavier)
10:45:53 <iqubic> why is this wrong: traverseX f (V3 x y z) = V3 <$> (f x) <*> y <*> z, wrong?
10:46:15 <dminuoso> iqubic: Thats assuming that y and z are applicatives.
10:46:21 <mniip> Gurkenglas, notice how the rule 4 "embeds" modus ponens into the inner ⊦ symbol
10:46:50 <dminuoso> iqubic: And since you're claiming they are, the type checker infers that your V3 must have applicatives inside. So it figures that `f` maps one applicative to another
10:46:52 <iqubic> And y and z aren't applicatives?
10:46:59 <dminuoso> iqubic: They can be anything.
10:46:59 <iqubic> I see.
10:47:04 <iqubic> Right.
10:47:33 <mniip> Gurkenglas, supposing T is a type, we can derive
10:48:06 <Gurkenglas> (Why do we want to have different formulae for ∈ and ⊦?)
10:48:33 <mniip> 1.  x:T ∈ {x:T}  (evident from whatever set theory we use)
10:48:56 <mniip> 2. {x:T} ⊦ x:T  (rule 1 applied to formula 1.)
10:49:02 <Gurkenglas> This set theory introduces additional inference rules, yes?
10:49:10 <mniip> yeah
10:49:39 <mniip> "{}, x:T" is syntactic sugar for "{x:T}", so
10:50:09 <mniip> 3.  {} ⊦ (\x:T -> x) : (T -> T)  (rule 3 applied to formula 2.)
10:50:43 <benzrf> oh wait duh of course it incurs a stack entry that's literally how thunk update is done :|
10:51:03 <iqubic> So I need to have an applicative as the result. And I only want to map the function f onto the x part.
10:51:13 <dminuoso> Yes.
10:52:03 <mniip> Gurkenglas, I could formulate the minimum necessary set of inference rules real quick
10:54:11 <iqubic> So I'm rather lost.
10:54:12 <mniip> oh it's simpler than I expected
10:54:39 <dminuoso> iqubic: Note that traverseX will be somewhat more limited. The original traverse was allowed to map _every_ element to an action, so it could change the underlying types.
10:55:15 <iqubic> Yeah, I got that.
10:55:32 <dminuoso> iqubic: traverseX cannot do that. Do you have the type signature?
10:55:33 <iqubic> Wait, what is the type signature of traverseX?
10:55:55 <iqubic> I don't have the type signature of traverseX
10:56:03 <dminuoso> iqubic: It's basically traverse with this limitation.
10:56:19 <dminuoso> i.e. it cannot change the underlying types.
10:56:45 <mniip> Gurkenglas, http://mathb.in/21314
10:57:09 <dminuoso> Because if you have a `V3 Int` then your action can't do (Int -> IO Double), otherwise you'd have one element changed to a Double but the other two with Int. This wont work.
10:57:50 <Gurkenglas> mniip, you have resumed using terms without defining them
10:57:56 <iqubic> Are we changing the underlying types in our full traversal?
10:57:57 <mniip> where
10:58:03 <dminuoso> :t traverse
10:58:04 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:58:10 <Gurkenglas> What's inductively quantified?
10:58:31 <mniip> okay remember we had an alphabet and a grammar
10:58:38 <dminuoso> iqubic: In here `a` is the type inside the original traversable. You have a function (a -> f b), and the result has some `t b`
10:58:58 <dminuoso> iqubic: So based on this you can see that traverse can (it doesnt have to though) change the entire thing while its traversing.
10:59:20 <mniip> the grammar for the language of our formulas includes nonterminals like variable, type, typing-judgement,
10:59:22 <dminuoso> iqubic: It's kind of like fmap.. except with effects.
10:59:48 <mniip> I am clarifying that a typing-context nonterminal is either a varnothing (a terminal) or a typing-context, comma, typing-judgement
11:00:09 <mniip> recalling that rules of inference are really just relations
11:00:30 <mniip> I am trying to clarify that \Gamma ranges over all sentences producible from the typing-context nonterminal
11:00:32 <iqubic> traverseX :: (Applicative f) => (a -> f a) -> V3 a -> f (V3 a)
11:00:45 <iqubic> That is the type signature I am aiming for.
11:00:47 <dminuoso> iqubic: That looks good.
11:00:52 <dminuoso> For now :)
11:01:06 <mniip> gosh I hope you're familiar with grammars
11:01:12 <Gurkenglas> Yes :3
11:01:23 <iqubic> Now to use hole driven development to write a function.
11:01:26 <Gurkenglas> Ah, Gamma is a finite set of typing assumptions
11:01:41 <mniip> well
11:01:45 <mniip> sort-of
11:01:56 <mniip> really it's just a sentence
11:02:03 <mniip> a sequence of symbols
11:02:14 <Gurkenglas> (I suppose it's a finite bag, since you didn't forbid duplication)
11:02:15 <mniip> it's not even a formula - a mere part of a formula
11:02:33 <Gurkenglas> sure, sure
11:02:45 <mniip> anyway
11:02:55 <mniip> I suppose it would be wiser to uh
11:03:00 <mniip> get rid of \in at all
11:03:03 <iqubic> dminuoso: traverseX f (V3 x y z) = V3 <$> (f x) <*> (pure y) <*> (pure z)
11:03:09 <iqubic> There we are.
11:03:11 <mniip> substitute (cons) and (refl) into (1)
11:03:17 <iqubic> I thing that works.
11:03:20 <mniip> and get 5 inference rules total and one less symbol to worry about
11:03:36 <dminuoso> iqubic: There we go. Before we proceed to the next step, lets talk about this for a moment.
11:03:57 <Gurkenglas> mniip, shouldn't those two "," be "⊦"?
11:04:08 <mniip> no
11:04:14 <dminuoso> iqubic: In the original traverse function, you take a mapping function, that maps an element to an Applicative. Now there's one interesting choice, namely that of Identity.
11:04:21 <iqubic> Sure.
11:04:22 <dminuoso> iqubic: Can you see what traverse using a function that maps to Identity does?
11:04:37 <mniip> (cons) and (refl) have nothing to do with ⊦
11:04:46 <dminuoso> iqubic: If not, you should go try it out using your V3.
11:04:52 <Gurkenglas> Okay, haven't understood yet then what your link is saying
11:05:01 <iqubic> It doesn't change the values in our V3, but it does wrap it up in an applicative.
11:05:09 <dminuoso> iqubic: Yeah but an Identity applicative!
11:05:15 <dminuoso> And it can change values.
11:05:21 <iqubic> It can? How.
11:05:35 <dminuoso> iqubic: Try it out.
11:05:49 <dminuoso> Just use some function: a -> Identity b
11:06:20 * hackage uulib 0.9.23 - Haskell Utrecht Tools Library  https://hackage.haskell.org/package/uulib-0.9.23 (AtzeDijkstra)
11:06:28 <mniip> Gurkenglas, definining what ∈ means
11:06:38 <iqubic> Right, I see.
11:06:49 <mniip> how to create a formula involving a ∈
11:07:04 <dminuoso> iqubic: Does traverse with Identity remind you of something?
11:07:04 <Gurkenglas> Ohh , binds more strongly than \in now it's obvious
11:07:40 <iqubic> What module do I need to import to get the Identity Newtype wrapper?
11:07:54 <mniip> % :i Identity
11:07:56 <yahb> mniip: newtype Identity a = Identity {runIdentity :: a} -- Defined in `Data.Functor.Identity'; instance Applicative Identity -- Defined in `Data.Functor.Identity'; instance Eq a => Eq (Identity a) -- Defined in `Data.Functor.Identity'; instance Functor Identity -- Defined in `Data.Functor.Identity'; instance Monad Identity -- Defined in `Data.Functor.Identity'; instance Monoid a => Monoid (Identity a) -- Def
11:11:14 <iqubic> dminuoso: That looks like it's doing the same things as my sequenceA did when I wrote that last night.
11:11:32 <dminuoso> iqubic: Well not exactly.
11:11:47 <dminuoso> iqubic: Try some function like \x -> Identity $ x * 2
11:12:27 <Adluc> sorry for next paste, but how can I one-line this snippet?
11:12:29 <Adluc> exampleParse = do
11:12:29 <Adluc>   x <- exampleInputLong
11:12:29 <Adluc>   return $ G.parseGerber x
11:12:46 <dminuoso> iqubic: sequenceA is just `traverse id`, it's assuming that the traversable already contains actions (i.e. applicatives)
11:12:48 <iqubic> How do I import things in GHCI?
11:13:13 <iqubic> I can't recall how to do that right now.
11:13:32 <dminuoso> iqubic: The same way you import anywhere in Haskell.
11:14:08 <iqubic> I see.
11:14:37 <dminuoso> iqubic: But in this case, create some `V3 10 5 17` maybe, and then use `traverse` on it - pick the Identity in your mapping function.
11:15:29 <dminuoso> iqubic: And be sure to transform the value in that mapping function too, otherwise its not very interesting.
11:17:00 <iqubic> clearly intero's version of GHCI doesn't want me to use Identity.
11:17:20 <iqubic> I tried importing Data.Functor, but that didn't really work all that well.
11:17:26 <dminuoso> iqubic: Data.Functor.Identity
11:17:49 <Yimo> Having the zipping of 2 lists, (aka a list of the form [()]), is there a quick way to get the element from the list with minimum value for a in (a,b) ?
11:18:18 <dminuoso> :t minimumBy
11:18:19 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
11:18:23 <Yimo> Ty
11:18:41 <dminuoso> Yimo: Mmm, well I wanted the one in Data.List
11:18:46 <dminuoso> That's the one from Foldable it seems.
11:18:57 <iqubic> dminuoso: That looks a lot like fmap, with an extra newtype wrapper.
11:19:04 <dminuoso> iqubic: Indeed. :)
11:19:14 <dminuoso> iqubic: The newtype wrapper aside, this is just fmap.
11:19:37 <dminuoso> iqubic: So in a way we could think of "Identity" acting as a setter under traverse because it has no actual effects on its own.
11:19:48 <iqubic> I see how that works.
11:20:22 <iqubic> What next?
11:20:28 <dminuoso> iqubic: Before we talk about traverseX however, there's something missing.
11:20:31 <dminuoso> Your constraints are wrong.
11:20:37 <iqubic> They are?
11:20:39 <dminuoso> Yes they are.
11:20:41 <iqubic> How so?
11:21:01 <iqubic> My constraints for what are wrong? traveseX?
11:21:03 <dminuoso> iqubic: Using the applicative laws you can lower the Applicative requirement to Functor.
11:21:14 <Yimo> eh, one quick other question xD, how do I pattern match against a list again? (x,y) is enough right?
11:21:27 <dminuoso> iqubic: (You need two applicative and one functor law)
11:21:29 <iqubic> I can?
11:21:37 <Yimo> not list, I mean eh
11:21:40 <dminuoso> iqubic: Yes you can. Its purely mechanical, you dont have to think or understand your code.
11:21:40 <Yimo> I mean tuple
11:21:48 <mniip> hmm
11:21:53 <mniip> I remember dealing with this before
11:22:11 <iqubic> Intero seems to thing that the minimum requirement is an applicative for f.
11:22:22 <dminuoso> iqubic: Right now it is because you are using <*> and pure
11:22:31 <dminuoso> iqubic: But you can transform the code so that you don't use anything from applicative.
11:22:43 <iqubic> I can?
11:23:06 <dminuoso> Yes.
11:23:07 <iqubic> How do I get rid of the pure though?
11:23:15 <dminuoso> iqubic: You have to transform code using the applicative and functor laws.
11:24:35 <iqubic> Can I transform traverse?
11:24:54 <dminuoso> No, traverse cannot.
11:25:04 <iqubic> Why is traverseX different?
11:25:12 <dminuoso> iqubic: Because it operates only on one component.
11:25:31 <dminuoso> iqubic: Also, the final form looks much cleaner and more revealing.
11:25:47 <mniip> fascinating
11:25:54 <mniip> cabal's bootstrap.sh is broken as always
11:26:12 <monochrom> How?
11:26:21 <mniip> it tests for -d ../.git
11:26:22 <dminuoso> iqubic: But first try this with traverseX, and if you like you can try it with traverse too and see why it wont work.
11:26:28 <mniip> to see if it's being installed from a git clone
11:26:28 <dminuoso> iqubic: But with traverseX it does work.
11:26:37 <mniip> but it's a submodule in the ghc repository
11:26:42 <mniip> and .git is a file not a directory
11:26:54 <Gurkenglas> mniip, so how do the typing assumptions that one allegedly needs to typecheck a lambda say that "Type -> Type -> Maybe Type" is too weak because of "free variables"?
11:27:23 <mniip> Gurkenglas, typecheck me (\x -> x ())
11:27:29 <iqubic> How do I get rid of pure? That seems like a thing that requires an applicative.
11:28:15 <dminuoso> iqubic: Check the Applicative laws: https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Applicative.html
11:28:23 <mniip> (no, not using the 4 inference rules. This is a differnt lambda calculus)
11:29:02 <dminuoso> iqubic: You also need the fact that <*> is left associative.
11:29:16 <iqubic> fmap f x = pure f <*> x
11:29:23 <mniip> monochrom, do you have a plan to act on this or were you just curious
11:29:27 <iqubic> That might help me.
11:30:07 <dminuoso> iqubic: Also you will need one Functor law, namely: fmap f (fmap g cx) = fmap (f . g) c
11:30:08 <Gurkenglas> Okay, so you want me to derive a typing judgement of form {} ⊦ (\x -> x ()) : \sigma for some \sigma.
11:30:23 <mniip> nah
11:30:23 <monochrom> Just curios.
11:30:38 <Gurkenglas> Whoops, missed the (no, not ...)
11:30:58 <mniip> there's the polymorhic lambda calculus
11:30:58 <Gurkenglas> So what do you mean by typecheck me (\x -> x ())?
11:31:05 <iqubic> I knew that functor law.
11:31:25 <mniip> and then there's girard-reynolds notation, and the hindley-milner notation
11:31:35 <iqubic> I have no idea where to begin reducing my traverseX function.
11:31:44 <dminuoso> iqubic: Also note that with liftA3 this would have been hidden from you, so the transformation to explicitly use <*> and <$> enables this goodie =)
11:31:48 <Gurkenglas> Are you back to trying to overwhelm me with undefined notation?
11:31:58 <mniip> in GR you explicitly introduce all type variables
11:32:04 <dminuoso> iqubic: Well consider it a nut to crack. It will be much more fun.
11:32:11 <dminuoso> iqubic: Its not hard, you just need the right angle.
11:32:17 <mniip> and typechecking is about as mild as in the simply typed lambda calculus
11:32:24 <monochrom> and a metric :)
11:32:35 <mniip> in hindley-milner the type checker actually has to come up with its own type variables!
11:32:36 <iqubic> I don't have the right anglr.
11:32:46 <iqubic> I'm not sure which applicative laws help me.
11:33:13 <iqubic> s/anglr/angle
11:33:57 <Yimo> guys, why is this invalid? minimumBy (\(x,y) -> x-y) [(1,2),(2,5)]
11:34:17 <Gurkenglas> :t minimumBy
11:34:18 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
11:34:42 <Gurkenglas> You want some sort of "minimumOn :: (Foldable t, Ord b) => (a -> b) -> t a -> a
11:34:45 <Gurkenglas> *"
11:35:30 <mniip> Yimo, you wrote an unary function that returns something numeric
11:35:40 <Gurkenglas> I suggest you define or import one.
11:35:41 <Yimo> hmm saw that
11:35:41 <mniip> minimumBy takes a binary function that returns an Ordering
11:35:55 <frerich> Yimo: Maybe you meant ' minimumBy (comparing (\(x,y) -> x -y)) [(1,2),(2,5)]'
11:36:04 <Yimo> although, is the \(x,y) part okay?
11:36:18 <mniip> fsvo okay
11:36:22 <iqubic> Yimo: the \(x,y) pare is fine.
11:36:25 <dminuoso> iqubic: Start by adding explicit parens. That will make it easier to show what you can work with.
11:36:56 <iqubic> Is <*> left or right assosiative?
11:37:16 <dminuoso> iqubic: Ask ghci
11:37:20 <mniip> (k <*> x) <*> y
11:37:33 <mniip> (frankly I don't remember whether this is an r or an l)
11:38:03 <iqubic> LOL.
11:38:12 <Yimo>    \minimumBy (comparing (\(x,y) -> x -y)) [(1,2),(2,5)] <interactive>:21:24: error:     Parse error in pattern: \ (x, y) -> x - y
11:38:13 <iqubic> I'd call that left.
11:38:42 <Yimo> this is why I asked for the \(x,y) part
11:38:52 <dminuoso> iqubic: Also you might want to rewrite one of those laws according to: pure f <*> g => f <$> g
11:39:17 <frerich> > minimumBy (comparing (\(x,y) -> x -y)) [(1,2),(2,5)]
11:39:19 <lambdabot>  (2,5)
11:39:25 <iqubic> traverseX f (V3 x y z) = ((V3 <$> (f x)) <*> (pure y)) <*> (pure z)
11:39:35 <Yimo> Huh
11:39:51 <Yimo> why did I get an error then xD
11:39:59 <dminuoso> iqubic: Id leave those parens around f x and pure away because they dont really help
11:40:37 <iqubic> ((V3 <$> f x) <*> pure y) <*> pure z
11:41:01 <iqubic> Now what?
11:41:19 <dminuoso> iqubic: Now transform with the goal of losing every `pure` and `<*>`
11:41:29 <dminuoso> (And dont you dare upgrade to a Monad!)
11:41:58 <monochrom> If you don't mind re-ordering parameter orders of V3, you will only need <$>
11:42:16 <dminuoso> Indeed. And that is the goal =)
11:42:27 <dminuoso> monochrom: Oh he still only needs <$>
11:42:31 <dminuoso> Even with traverseX.
11:42:36 <mniip> what's V3?
11:42:39 <Yimo> frerich which module contains `comparing`
11:42:46 <iqubic> Data V3 a = a a a
11:42:55 <mniip> hmm doesn't look right to me then
11:42:56 <dminuoso> monochrom: It requires turning a fragment into a lambda :)
11:43:03 <monochrom> V3 is a 3-parameter data constructor but you may as well have an arbitrary 3-parameter function there.
11:43:18 <iqubic> Why might I have that?
11:43:21 <frerich> Yimo: It's in Data.Ord
11:43:28 <Yimo> Danke
11:43:51 <iqubic> Oh, I see your point.
11:43:55 <mniip> maybe data V3 a b c = V3 c a b?
11:44:00 <Gurkenglas> mniip, so how/according to which lambda calculus/notation how do you expect me to typecheck (\x -> ()) in order to discover that "Type -> Type -> Maybe Type" is too weak?
11:44:12 <Gurkenglas> *(\x -> x ())
11:44:36 <mniip> I lost the line of reasoning
11:44:38 <iqubic> dminuoso: what do I need to do first?
11:44:39 <iqubic>  
11:45:27 <Gurkenglas> https://github.com/lspitzner/exference/blob/master/src/Language/Haskell/Exference/Core/Internal/Unify.hs#L58 seems to do just fine with something that doesn't look much more complicated than Type -> Type -> Maybe Type
11:45:56 <iqubic> I don't think the law of interchange will help me here, will it?
11:46:24 <dminuoso> iqubic: Lets actually play this game on the interchange law.
11:46:26 <grokkingStuff> onnommaattopiea: hey could you guys help me out in #haskell-in-depth?
11:46:34 <grokkingStuff> ^i;ve got an interesting question
11:46:47 <dminuoso> iqubic: u <*> pure y = pure ($ y) <*> u
11:46:55 <iqubic> Sure.
11:47:01 <dminuoso> iqubic: You can apply the following law to that law: pure f <*> g = f <$> g
11:47:38 <dminuoso> iqubic: Along the way you might want to switch between <$> and fmap to make the functor laws more obvious
11:47:40 <iqubic> u <*> pure y = ($ y) <$> u
11:47:50 <dminuoso> Right. There you go. making <*> and pure disappear =)
11:47:55 <iqubic> I see.
11:48:05 <Yimo> minimumBy (comparing (\(x,_) (y,_) -> x -y)) [(1,2),(2,5)]
11:48:13 <Yimo> > minimumBy (comparing (\(x,_) (y,_) -> x -y)) [(1,2),(2,5)]
11:48:15 <lambdabot>  error:
11:48:15 <lambdabot>      • Could not deduce (Ord ((a, b0) -> a))
11:48:15 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
11:48:33 <monochrom> I think you greatly misunderstood comparing.
11:48:40 <grokkingStuff> > minimumBy (comparing (\(x,_) (y,_) -> x -y)) (1,2) (2,5)
11:48:42 <lambdabot>  error:
11:48:42 <lambdabot>      • Couldn't match expected type ‘(Integer, Integer) -> t’
11:48:42 <lambdabot>                    with actual type ‘(Integer, b1)’
11:48:59 <monochrom> And frerich already showed the correct example, so you need to study that.
11:49:09 <Yimo> ^ comparing returns LT GT or  EQ right?
11:49:19 <monochrom> Yes and that's not your issue.
11:49:32 <Yimo> hmm alright
11:50:28 <monochrom> Study frerich's correct code first. You are not ready to mutate it.
11:51:17 <iqubic> traverseX f (V3 x y z) = fmap ($ z) (fmap ($ z) (V3 <$> f x))
11:51:32 <dminuoso> iqubic: Great. Now apply functor laws to simplify this
11:51:51 <dminuoso> iqubic: Also be sure to remember you still have a <$> in there
11:52:14 <dminuoso> (Or rewrite the functor law for <$>)
11:52:31 <iqubic> traverseX f (V3 x y z) = ($ z) <$> ($ z) <$> V3 <$> f x
11:52:41 <dminuoso> iqubic: Nope.. apply functor laws!
11:52:47 <dminuoso> Not replace fmap with <$>
11:53:14 <iqubic> Oh. Also, that first z should be a y
11:53:23 <dminuoso> iqubic: The form you just had a minute ago was good to work with.
11:54:39 <iqubic> Oh, I see.
11:55:34 <dminuoso> iqubic: Also note you have made a typo with two stray ($ z) in there.
11:55:58 <iqubic> the first z should be a y
11:56:08 <iqubic> I said that just a few moments ago.
11:56:40 <iqubic> I'm sorry, I have to go hang out with relatives. I'll be back later.
11:57:00 <dminuoso> Though come to think of it..
11:57:17 <iqubic> Yes?
11:57:19 * hackage uri-bytestring 0.3.1.0 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.3.1.0 (MichaelXavier)
11:57:34 <dminuoso> In this last form its even easier since: a <$> b <$> c == a . b <$> c
11:57:34 <fenedor> :t \f x z ($ z) <$> ($ z) <$> f x
11:57:35 <lambdabot> error: Parse error in pattern: $ z
11:57:40 <fenedor> :t \f x z -> ($ z) <$> ($ z) <$> f x
11:57:41 <lambdabot> Functor f => (t -> f (a -> a -> b)) -> t -> a -> f b
11:57:55 <dminuoso> I think?
11:58:25 <iqubic> :t \f x y z -> fmap ($ y) (fmap ($ z) (V3 <$> f x))
11:58:27 <lambdabot> error:
11:58:27 <lambdabot>     • Data constructor not in scope: V3 :: a -> a2 -> a1 -> b
11:58:27 <lambdabot>     • Perhaps you meant variable ‘_3’ (imported from Control.Lens)
11:59:14 <iqubic> Anyways, I have to go. Be back later.
11:59:22 <dminuoso> iqubic: Blergh right <$> is left associative. So..
11:59:45 <dminuoso> So it was wrong anyhow.
12:00:45 <dminuoso> iqubic: But yeah its even easier if you transform from fmap to <$> and then follow: a <$> (b <$> c) == a . b <$> c
12:01:01 <dminuoso> Or just fmap f (fmap g cx) = fmap (f . g) cx
12:08:19 * hackage ats-format 0.1.0.6 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.6 (vmchale)
12:09:48 <nha_> what is the cat theory name for mapAccumL?
12:11:10 <harpoforsh> Does anyone know of succinct way to implement a monadic 'or', an mplus-like function f that does this: f x y = x >>= (\bx -> if bx then return bx else y).
12:11:36 <dmj`> what’s the best way to go from Scientific -> Fixed E2
12:11:41 <dmwit> harpoforsh: Just like that, sadly.
12:12:05 <dmwit> harpoforsh: I know of no tool for taking a pure, lazy function and turning it into a monadic and appropriately "effect-lazy" version automatically.
12:12:21 <dmwit> harpoforsh: However, there may already be an implementation of that lying around. I would look in monad-loops first.
12:12:47 <dmwit> harpoforsh: (Indeed: http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:orM )
12:13:23 <dmwit> dmj`: fromIntegral, probably
12:13:40 <dmwit> err, no
12:13:52 <dmwit> the one that goes via Rational instead of Integer
12:14:06 <dmwit> :t realToFrac
12:14:06 <dmj`> realtoFrac?
12:14:07 <lambdabot> (Fractional b, Real a) => a -> b
12:14:12 <dmwit> yes =)
12:14:21 <dmj`> nice! thanks :)
12:15:53 <dmj`> now I just need a list of all precisions for all crypto currencies (ex: bitcoin has 8 digits of precision, ethereum has 16 iirc)
12:16:14 <dmj`> wil newtype Fixed E8 and Fixed E16 for these
12:16:18 <dmj`> s/wil/will
12:16:42 <dmwit> =)
12:17:52 <dmj`> :]
12:20:11 <pavonia> dmj`: What are you programming, if I may ask?
12:21:38 <dmj`> pavonia: just writing some API bindings to bittrex.com, https://github.com/dmjio/bittrex
12:22:10 <pavonia> Oh nice
12:22:21 <dmj`> maybe buy some ADA since IOHK uses acid-state, want to root for the home team you know
12:22:27 <dmj`> and exploit some of this https://coinranking.com/?sorton=change
12:23:02 * hackage servant-github-webhook 0.3.2.0 - Servant combinators to facilitate writing GitHub webhooks.  https://hackage.haskell.org/package/servant-github-webhook-0.3.2.0 (tsani)
12:28:14 <huss`> Guys i'm having trouble updating two subcomponent of a record type with lenses
12:28:28 <huss`> I would like to compose them to update it in one lines
12:28:51 <huss`> data a = a { int, c { int, int }}
12:29:02 <huss`> updating fst of a and fst of snd of a
12:30:00 <oak-> I also started implementing library for accessing various cryptocurrency markets, though I used Servant.API and Servant.Client to generate REST API calls
12:30:08 <oak-> Hence the websocket question earlier
12:32:13 <sfy> hey everyone; I'm a bit confused here: I'm running into a weird issue where my program produces correct output when run with profiling tools, but incorrect when run without
12:32:54 <sfy> the program is pretty substantial (it's a basic path tracer) so I can't really give any code examples, so I'm rather looking if someone knows how I can go about debugging this?
12:33:06 <sfy> I tried running through the steps manually in ghci but it produces the correct output also
12:33:25 <sfy> so I don't know what I can do to debug the program and figure out why I'm not getting the expected output?
12:36:04 <huss`> got it
12:42:44 <huss`> i have to say that the guys behind lenses are monsters
12:43:04 <huss`> especially Edward
12:43:34 <huss`> their brain is much more lifted
12:43:46 <dminuoso> huss`: Imagine if edward had written what feels like every second library on hackage..
12:43:47 <dminuoso> Oh wait..
12:43:51 <Rembane> liftBrain is the best function.
12:44:23 <huss`> genius literally
12:44:23 * hackage bittrex 0.3.0.0 - API bindings to bittrex.com  https://hackage.haskell.org/package/bittrex-0.3.0.0 (DavidJohnson)
12:44:58 <huss`> haskell is the only language where i find myself crying wtf this this so fucking op after having learnt a new concept
12:46:01 <huss`> Rembane: do you think that lifting a brain is pure ?
12:46:47 <phadej> remember, `lens` weren't written over night :)
12:47:05 <huss`> phadej: impossible
12:48:22 <phadej> lens-0.1 is from 2012!  data-lens is simpler http://hackage.haskell.org/package/data-lens-1.8.0/docs/Data-Lens-Common.html (2011!)
12:48:59 <Rembane> huss`: Nope, it has side effects in the real world.
12:49:14 <ph88> i'm trying to use a modified version of base so i did   stack unpack base   and add base-4.10.1.0 to packages in stack.yaml  but when i make a syntax error and stack build base-4.10.1.0 i get no errors. The adding to packages was described in this FAQ https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#i-need-to-modify-an-upstream-package-how-should-i-do-it  anyone know how i can use modified upstream packages with stack ?
12:51:24 <monochrom> You need to build your own GHC.
12:51:29 <phadej> ph88: base isn't re-installable package
12:51:41 <ph88> aw :(
12:52:03 <ph88> is that difficult to build my own ghc ?
12:52:10 <monochrom> And then you need to tell stack to use it rather than download another standard one again.
12:52:23 <monochrom> Alternatively, sideline stack.
12:52:48 <ph88> i've read how to let stack use a system ghc but i haven't tried it (didn't need it before)
12:53:00 <ph88> is it difficult to build ghc from source ?
12:53:01 <monochrom> Take the blue pill to exit the stack walled garden.
12:53:11 <ph88> <3 stack :p
12:53:15 <ph88> bliss
12:54:13 <frerich> Did anybody here do the Synacor challenge in Haskell? I wonder whether it's possible to disassemble the given VM - I always hit an unrecognised opcode '20000' but I cannot spot a bug in my disassembler :-}
12:54:21 <monochrom> stack is like wearing diving suit to a spa.
12:56:20 <huss`> guys why is ghc asking for the same number of argument when i pattern match
12:56:56 <monochrom> Because Haskell 2010 told it to.
12:57:28 <nullie> you have to use _ for non-used arguments
12:57:29 <huss`> doing safNlz v@(0, 0) = v, safNlz = normalizeV
12:57:43 <huss`> ghc can't infer that the second is more general ?
12:57:51 <monochrom> Right, Haskell 2010 disallows that flexibility.
12:58:02 <huss`> okay
12:58:04 <yohotchoc> huh TIL
12:58:19 <nullie> oh, that
12:58:22 <monochrom> It pays to read the Haskell 2010 Report cover to cover.
12:58:24 <huss`> monochrom: does the order matter when i match ?
12:58:30 <monochrom> Yes.
12:58:36 <huss`> okay i see
12:58:38 <huss`> thanks
13:46:10 <nilof> gah, the semigroup instance for Either is completely different from the one for Maybe?
13:47:32 <nilof> It just returns the first non-exceptional value in the product, rather than using a semigroup or monoid instance of the wrapped type
13:50:29 <nilof> so basically like the alternative instance of maybe
13:52:32 * hackage zifter 0.0.1.5 - zifter  https://hackage.haskell.org/package/zifter-0.0.1.5 (Norfair)
13:53:19 * hackage zifter-stack 0.0.0.8 - zifter-stack  https://hackage.haskell.org/package/zifter-stack-0.0.0.8 (Norfair)
14:37:05 <Costar> Merry christmas to everyone
14:47:13 <iqubic> Well, I'm back.
14:47:25 <iqubic> Time to learn more about lenses.
14:47:40 <iqubic> dminuoso: I'm not sure what to do from here:
14:47:43 <Average-user> someone knows what means the board that appears on top of the calendar when you finish AoC?
14:48:14 <iqubic> traverseX f (V3 x y z) = fmap ($ y) (fmap ($ z) (V3 <$> f x))
14:48:46 <amalloy> is Data.Sequence the best thing to use for a queue? i'm aware it has O(1) add/remove to either end, which seems like all i need; i was just wondering if there's something more suitable
14:49:30 <iqubic> What is this queue for?
14:51:13 <amalloy> does it matter? of course for a small queue any choice is fine; i'm asking what to use for queues in general
14:51:36 <iqubic> I think a sequence would be fine, but I'm no expert.
14:51:43 <xocolatl> hi.  how can I load a binary file into a UArray of Word16?
14:52:29 <sebastianrkg> I want to use a C physics engine within Haskell code that is highly concurrent. I'm planning on using `inline-c`, but it says that "safe" inlined C is inefficient
14:52:39 <sebastianrkg> and that unsafe inlined C will "block the RTS"
14:53:10 <sebastianrkg> I'd heard elsewhere that ffi calls can block all threads too -- is that what is meant by "block the RTS"?
14:53:46 <sebastianrkg> The lower performance for safe code scares me too, as this is for a videogame. Is anyone here experienced with calling C from Haskell and the benefits of safe vs unsafe?
14:54:13 <sebastianrkg> Not sure what I should do and if either safe or unsafe is acceptable -- the both seem to come with dealbreakers
14:54:55 <iqubic> What do you thing should happen?
14:55:56 <iqubic> s/thing/think
14:56:37 <sebastianrkg> is that directed at me, iqubic?
14:56:42 <iqubic> yes.
14:57:05 <iqubic> Though I'm not sure what I'm talking about even.
14:57:42 <sebastianrkg> I would like to run the C code inside one of the many threads in my application without interrupting the other threads, and do so performantly
14:58:03 <iqubic> That should be possible, but I have no idea how.
14:58:12 <geekosaur> can that code (a) block in the kernel (b) call back into Haskell?
14:58:48 <sebastianrkg> I'm not sure about (a), how would I evaluate that? (b), I don't think so
14:59:06 <sebastianrkg> It's Chipmunk2D that I'm trying to utilize https://github.com/slembcke/Chipmunk2D
14:59:50 <geekosaur> I'm tempted to say that if you don't know the answer to (a) then you cannot write performant/guaranteed latency code in *any* language or library
15:01:17 <iqubic> I agree with that.
15:01:52 <geekosaur> because blocking in the kernel is what causes you to miss latency guarantees, and is what causes the RTS blocking
15:02:27 <iqubic> Why do things sometimes block in the kernel?
15:02:37 <sebastianrkg> and would be caused by threads sleeping, waiting for locked memory locations, etc? Or is that blocking at a higher level
15:03:05 <dminuoso> iqubic: You just apply functor laws.
15:03:11 <dminuoso> iqubic: To get rid of all but one fmap.
15:03:31 <iqubic> I see. I'll try.
15:03:32 <dminuoso> iqubic: fmap a (fmap b c) = fmap (a . b) c
15:03:32 <geekosaur> those are higher level things. more generally, any I/O operation means you are handing control to the kernel and at minimum you wait for it to queue it somewhere and tell you it did so (or failed)
15:03:36 <dminuoso> iqubic: a <$> (b <$> c) == a . b <$> c
15:03:46 <dminuoso> iqubic: Both are equivalent, so feel free to use whatever you prefer.
15:03:52 <geekosaur> I/O at system level is neither mgic nor instantaneous.
15:04:58 <dminuoso> iqubic: Note that we have already achieved losening the constraint to Functor, so this is just to get the final concise form, which we are only 2 steps away from.
15:05:17 <geekosaur> how this impacts multiple threads is complex, because if you are holding any thread-level resource when you call a blocking function in C, and some other thread needs access to that resource, then that thread will block until your C call returns
15:06:05 <geekosaur> if this is done at Haskell level then things work differently. but the RTS's I/O manager can neither see nor control what is going on in an unsafe FFI call.
15:06:19 <iqubic> traverseX f (V3 x y z) = ($ y) . ($ z) . V3 <$> (f x)
15:06:30 <sebastianrkg> The Chipmunk2D code claims to be functional rather than that Box2D's more stateful approach. But I don't know, it's C
15:06:40 <dminuoso> iqubic: Great. Now take the term "($ y) . ($ z) . V3" and and think on it.
15:06:43 <sebastianrkg> *than, not than that
15:06:56 <dminuoso> iqubic: Can you rewrite this into something more expressive? Hint you actually need to unpointfree this. ;-)
15:06:59 <iqubic> Think on it? What does that mean?
15:07:18 <dminuoso> iqubic: Well its a convoluted way of expressing a rather simple idea really.
15:07:22 <geekosaur> sebastianrkg, that doesn;t matter so much, it's not going to change operational semantics
15:07:27 <iqubic> Can I use lambdabot's @pl? Or is that cheating?
15:07:37 <dminuoso> iqubic: Thats cheating.
15:07:52 <dminuoso> iqubic: Also it wont help. Just rewrite with an explicit lambda instead of function composition
15:08:27 <iqubic> traverseX f (V3 x y z) = (\w -> V3 w y z) <$> (f x)
15:08:35 <dminuoso> iqubic: Great thats it. :)
15:08:37 <iqubic> Yeah I see how that is a lot simpler.
15:08:48 <Eduard_Munteanu> (There's @unpl, by the way.)
15:08:59 <iqubic> I didn't use that.
15:09:23 <iqubic> Wait, dminuoso, that's just a setter fmapped onto a modifier.
15:09:30 <Eduard_Munteanu> @unpl ($ y) . ($ z) . V3 <$> (f x)
15:09:31 <lambdabot> ((\ x -> (V3) x z y) <$> f x)
15:09:44 <iqubic> I see.
15:09:47 <dminuoso> iqubic: Indeed. Now try this.
15:09:58 <dminuoso> iqubic: Again, use the Identity Functor (this time it doesnt have to be an Applicative)
15:10:06 <sebastianrkg> I'm not calling a simple function, but instead a complex library -- I'm not sure how I could make sure that no momentarily blocking operations occur
15:10:16 <iqubic> If you want me to write traverseY and traverseZ, I can do that really simply.
15:10:23 <kakashiAL> in javascript there are promises (they are like Either) and they are "then-able" the method then is like map and flatmap combined. My question is why is haskell not doing the same way? I mean if we have Either(Either(foo)), I have to know that I have a "nested" either and be smart enough to use (f)map, so again, I see no reason why I want to work with an Either(Either(foo))
15:10:35 <dminuoso> iqubic: ;)
15:10:36 <sebastianrkg> and I'm also not sure how this relates back -- let's say that it does block the kernel: do I use unsafe, then? If it doesn't: I use safe?
15:10:45 <iqubic> :t join
15:10:46 <lambdabot> Monad m => m (m a) -> m a
15:10:50 <dminuoso> iqubic: Just try this `traverseX` and observe what it does when you pick the Identity Functor.
15:10:55 <iqubic> I will.
15:11:04 <dminuoso> iqubic: Once you understood that, we will explore a second Functor that is of particular interest.
15:13:04 <kakashiAL> can anyone help me to understand that?
15:13:30 <dminuoso> kakashiAL: Promises are absolutely unlike Either.
15:13:40 <dminuoso> kakashiAL: JS promises are broken monads, and its a sad reality.
15:13:53 <dminuoso> kakashiAL: The fact that .then is "flatMap" and "map" bundled together is a mess.
15:14:18 <iqubic> traverseX (\x -> Identity $ x * 2) (V3 (Just 1) (Just 2) (Just 3)) doesn't work at all.
15:14:25 <kakashiAL> dminuoso: what ever you say, but there are similarities and I want to understand why combining flatMap and map on one function/method is a mess
15:14:31 <dminuoso> iqubic: Well compare the types.
15:14:39 <dminuoso> iqubic: check traverseX
15:14:50 <iqubic> Is that not how that works?
15:15:05 <dminuoso> iqubic: What is the type signature of traverseX?
15:15:47 <iqubic> Yeah, I found my mistake.
15:16:17 <iqubic> traverseX (\x -> Identity $ x * 2) (V3 1 2 3)
15:16:29 <iqubic> Identity (V3 2 2 3)
15:16:45 <kakashiAL> dminuoso: I try to understand it, I mean I never found myself that I need Promise(Promise(foo))
15:16:57 <dminuoso> iqubic: So "Identity" has the property of acting as a kind of "setter" for this traverseX.
15:17:05 <iqubic> yes. It does.
15:17:08 <iqubic> traverseX (\x -> Identity $ 100) (V3 1 2 3)
15:17:20 <iqubic> Identity (V3 100 2 3)
15:17:30 <iqubic> So, what next?
15:17:36 <dminuoso> iqubic: You can even prepened the whole thing with runIdentity to get rid of that wrapper.
15:17:49 <iqubic> Yeah, I know how that works.
15:17:54 <dminuoso> iqubic: Now there's an alternate Functor that you can pick, one that instead acts like a "Getter" instead, which only retrieves the thing that traverseX works on.
15:18:01 <yohotchoc> sebastianrkg: I think you may be optimising at the wrong level
15:18:10 <iqubic> Do I have to pick the functor?
15:18:20 <iqubic> I'm not sure what a good choice might be.
15:18:23 <yohotchoc> unless there's a huge difference in code style between safe and unsafe go with safe
15:18:24 <dminuoso> iqubic: Well yeah.. in that first function. Right now you picked Identity.
15:18:32 <yohotchoc> you can fix it if the performance sucks later
15:18:50 <iqubic> Is there a Const newtype wrapper?
15:18:58 <dminuoso> :i Const
15:19:02 <iqubic> Can we try that.
15:19:08 <iqubic> % :i const
15:19:08 <dminuoso> iqubic: There is a Const functor indeed. :-)
15:19:08 <yahb> iqubic: const :: a -> b -> a -- Defined in `GHC.Base'
15:19:18 <iqubic> % :i Const
15:19:19 <yahb> iqubic: type role Const representational phantom; newtype Const a (b :: k) = Const {getConst :: a}; -- Defined in `Data.Functor.Const'; instance Monoid m => Applicative (Const m) -- Defined in `Data.Functor.Const'; instance forall a k (b :: k). Eq a => Eq (Const a b) -- Defined in `Data.Functor.Const'; instance Functor (Const m) -- Defined in `Data.Functor.Const'; instance forall a k (b :: k). Monoid a => Mo
15:19:32 <iqubic> Let's try that out.
15:19:37 <sebastianrkg> yohotchoc: Yeah, you're right. I just want to make sure that `safe` is going to allow my threads to not be blocked? Is that a provided guarantee, so long as the C code returns?
15:19:50 <dminuoso> iqubic: Once you've played with that, there's one more thing
15:19:56 <sebastianrkg> This thing I'm making is a actor framework with tons and tons of threads running, so it's a big concern
15:20:12 <yohotchoc> if it says it can block it can block
15:20:24 <yohotchoc> what I'm saying is try it and see if that's actually an issue before you dwell on it
15:20:56 <iqubic> traverseX Const (V3 100 2 3)
15:20:59 <sebastianrkg> yohotchoc: it actually says that `unsafe` ones block. `safe` might just be slow
15:21:01 <iqubic> Const 100
15:21:07 <yohotchoc> oh, well
15:21:09 <sebastianrkg> I'll give it a shot with `safe`
15:21:12 <yohotchoc> other way around then
15:21:22 <dminuoso> iqubic: So you can see, `Const` acts as a "getter" in this particular "traverseX" function.
15:21:40 <yohotchoc> but either way if slow is an issue then you can try to work around blocking (or avoid it altogether) later
15:21:50 <yohotchoc> but I suspect that'll be harder than just going with slow for now
15:22:02 <iqubic> dminuoso: Yes, I see how that works.
15:22:04 <dminuoso> iqubic: So now comes the next part. Id like you to write a function that takes a function traverseX or traverseY or traverseZ, and uses that `Const` trick to "pull" the value out.
15:22:18 <dminuoso> iqubic: i.e. it takes two arguments. that `traverse_` function and a V3
15:22:19 <iqubic> I'll try that.
15:22:48 <dminuoso> iqubic: be sure to unwrap it with getConst
15:23:38 <iqubic> I will try that.
15:30:27 <iqubic> get traversal_ (V3 x y z) = getConst $ traversal_ Const (V3 x y z)
15:30:34 <iqubic> that is my get function.
15:32:00 <iqubic> And I wrote set too?
15:32:16 <dminuoso> iqubic: The deconstruction is unnecessary.
15:32:31 <dminuoso> iqubic: Sure, but instead of writing a generic "set" function, use one that takes a function (a -> a)
15:32:50 <dminuoso> and updates it. the set can be implemented as calling that `set` with const
15:33:08 * hackage ethereum-analyzer 3.3.4 - A Ethereum contract analyzer.  https://hackage.haskell.org/package/ethereum-analyzer-3.3.4 (zchn)
15:33:38 <iqubic> Yeah, so I have a set function now.
15:34:09 <nshepperd_> :t \t -> getConst . (t Const)
15:34:10 <lambdabot> forall k1 k2 a1 (b1 :: k2) a2 c (b2 :: k1). ((a1 -> Const a1 b1) -> a2 -> Const c b2) -> a2 -> c
15:34:39 * hackage ethereum-analyzer-deps 3.3.4, ethereum-analyzer-cli 3.3.4, ethereum-analyzer-webui 3.3.4 (zchn): https://qbin.io/8hgorg3gr
15:34:58 <iqubic> I now have a set function, and update function, and get function
15:35:30 <dminuoso> iqubic: Mind showing me those?
15:36:13 <iqubic> First, can you tell me a way to write set using only the update function?
15:36:46 <dminuoso> iqubic: If you have a generic `a -> a` function, you can use `const` to turn this into "I dont care what you have, Ill tell you the new value"
15:37:06 <dminuoso> :t const
15:37:07 <lambdabot> a -> b -> a
15:39:05 <iqubic> http://termbin.com/bw0d
15:39:12 <iqubic> See the end of the file.
15:39:12 <iqubic>  
15:39:45 <dminuoso> iqubic: Yeah, you could golf that a little further but thats it basically.
15:39:51 <iqubic> I know.
15:39:59 <dminuoso> iqubic: Now in lenses `set` retains that name, update is called `over` and get is called `view` =)
15:40:06 <iqubic> I'm sure there is a way to improve what I have gotten.
15:40:21 <iqubic> do I have the order of the parameters right?
15:40:35 <dminuoso> iqubic: Just try it out, I havent checked.
15:40:46 <dminuoso> iqubic: But please dont deconstruct your V3 - its silly
15:41:00 <iqubic> I know that it works. I tested all three functions.
15:41:31 <dminuoso> update l f v = runIdentity $ l (Identity . f) v
15:41:34 <dminuoso> is much easier to read =)
15:42:53 <dminuoso> iqubic: Lets say if now you had some V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9)  and I wanted you use only the tools you have right now to set the value where you can see the `7` to `70`
15:42:55 <iqubic> Yeah, I just changed them.
15:43:07 <iqubic> I don't know how to do that.
15:43:18 <dminuoso> iqubic: Well you do.. actually.
15:43:28 <dminuoso> Think about what traverseX does
15:43:57 <iqubic> I will.
15:44:38 <iqubic> I also didn't right the type signatures for get, set, or update, because they would be massive and long.
15:44:48 <iqubic> s/right/write/
15:44:54 <dminuoso> iqubic: You dont change `get` or `set`
15:45:07 <iqubic> What do you mean?
15:45:15 <dminuoso> iqubic: You just use them. :-)
15:45:19 <kakashiAL> dminuoso: so could you maybe explain why you want to have a Promise(Promise(x)) and not auto-flatmap it, if I understand this, it would make more sense for me why we have map and flatmap
15:45:35 <iqubic> I'm not trying to change anything.
15:45:46 <dminuoso> iqubic: Ohh I misunderstood. Yeah thats fine.
15:47:00 <dminuoso> kakashiAL: Monads are lawful constructions. These laws give certain guarantee that let you reason about code. If things violate such laws, you lose all the benefits about being able to reason about your code.
15:47:08 <iqubic> set (traverseZ . traverseX) 70 (V3 (V3 1 2 3) (V3 4 5 6) (V3 7 8 9))
15:47:16 <iqubic> sets the 7 to a 70.
15:47:23 <dminuoso> kakashiAL: In this particular case you lose the ability to express ideas such as deferring the construction of a deferred computation.
15:47:28 <dminuoso> iqubic: Indeed =)
15:47:45 <dminuoso> iqubic: And thats the basics of lenses.
15:47:52 <iqubic> First we do the traverseX, then the traverseZ.
15:47:59 <dminuoso> iqubic: traverseX/traverseZ are basically lenses. :)
15:48:15 <iqubic> dminuoso: Are they lenses, and not traversals?
15:48:51 <dminuoso> iqubic: well they are not really traverses.. I just used the name to let you start from `traverse`
15:49:03 <iqubic> What's the difference between a lens and a traversal?
15:49:15 <dminuoso> iqubic: a lens focuses on exactly one part of some structure
15:49:27 <iqubic> Right, so it is.
15:49:34 <dminuoso> iqubic: note how I emphasized that you could losen the constraint from Applicative to Functor exactly because of that?
15:49:47 <iqubic> Yes. I did notice that.
15:50:47 <iqubic> So the function traverse is the traversal over the entire V3?
15:51:24 * hackage tasty 0.12.0.1 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-0.12.0.1 (RomanCheplyaka)
15:51:25 <kakashiAL> dminuoso: so you agree that there is no need/use-case to have a Promise(Promise(x)), but its still hard to understand why you dont want to auto-flatMpa these :/
15:51:28 <dminuoso> Yeah. Though `traverse` has the ability to run computation over the entire structure
15:52:04 <iqubic> How does that differ from a lens traversal?
15:52:31 * hackage more-containers 0.1.0.0 - A few more collections  https://hackage.haskell.org/package/more-containers-0.1.0.0 (mtth)
15:52:36 <dminuoso> iqubic: "lens traversal" is a bit.. conflicting :)
15:53:08 <dminuoso> iqubic: a lens is a special traversal that focuses on just one point
15:53:23 <iqubic> If I were to write the fuction traverseXY, which traverses both the x and the y value, would I need an applicative constraint?
15:53:38 <dminuoso> iqubic: Try it.
15:53:54 <dminuoso> iqubic: Start from the same original traverse implementation, and try transforming using the applicative and functor laws.
15:54:20 <iqubic> I would need the applicative constraint, because there is no way to combine (f x) and (f y) without using <*>
15:54:39 <dminuoso> :)
15:56:39 <iqubic> traverseXY f (V3 x y z) = (\u v -> V3 u v z) <$> (f x) <*> (f y)
15:56:47 <iqubic> that's the best I can do with that.
15:57:12 <iqubic> I need the applicative constraint to combine multiple actions.
15:57:32 <fr33domlover> > 25
15:57:33 <lambdabot>  25
15:57:52 <fr33domlover> > "Merry " ++ "Christmas!"
15:57:54 <lambdabot>  "Merry Christmas!"
15:58:08 <fr33domlover> You too lambdabot ^_^
15:58:23 <kakashiAL> dminuoso: I dont understand your answer
15:58:53 <kakashiAL> dminuoso: but do you mean that we have map and flatmap because both have different type-signatures?
15:59:56 <dminuoso> iqubic: By the way: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Setter.hs#L357
16:00:01 <iqubic> Well, now I understand lenses and traversals a whole lot more than I did yesterday.
16:00:04 <dminuoso> iqubic: That is the inmplementation of over in Control.Lens =)
16:00:10 <dminuoso> iqubic: Look familiar?
16:00:28 <iqubic> Yes. Can I see set?
16:00:32 <dminuoso> iqubic: Or `view` https://github.com/ekmett/lens/blob/master/src/Control/Lens/Getter.hs#L254
16:00:48 <dminuoso> iqubic: Yes its here too: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Setter.hs#L383
16:00:50 <dminuoso> ;-)
16:01:06 <iqubic> view uses reader, which confuses me.
16:01:31 <dminuoso> Out of my league.
16:02:16 <dminuoso> iqubic: If you scroll down to (^.) you'll see that that implementation at least is identical to yours.
16:02:56 <iqubic> Well, that was informative.
16:03:04 <iqubic> Anything else I can try now?
16:05:17 <iqubic> Like what the heck is a prism? Or do you not know what that is?
16:06:40 <iqubic> Also, my set function falls apart if I feed it traverseXY
16:07:35 <iqubic> set traverseXY 10 (V3 1 2 3) doesn't yeild (V3 10 10 3)
16:07:47 <iqubic> It gives me a big fat compilation error.
16:08:03 <iqubic> Or rather, a runtime error.
16:10:44 <iqubic> So that's good.
16:11:38 <dminuoso> iqubic: Those functions you have only work with lenses not traverses.
16:11:49 <dminuoso> iqubic: What would `view traverseXY` do?
16:12:05 <iqubic> I'm not sure.
16:12:27 <iqubic> I'd like to try writting a set and an over function for traversals.
16:12:49 <kakashiAL> dminuoso: still there?
16:13:19 <iqubic> How are you supposed to use traversals?
16:13:26 <dminuoso> iqubic: well I thought we already covered that..
16:13:55 <dminuoso> iqubic: You use traverse the same way you use traverseX :-)
16:14:36 <iqubic> But I can't use traverseXY with set or over.
16:15:16 <iqubic> Which is the main issue.
16:15:37 <dminuoso> iqubic: They should I think.
16:15:43 <iqubic> Are there any uses for traverseX that don't include set, view, or over?
16:16:57 <dminuoso> The entirety of Control.Lens? :|
16:17:21 <dminuoso> I dont have much experience with lenses yet, so dont ask me really.
16:17:32 <iqubic> Can I see an example?
16:19:14 <Gurkenglas> > "asd" & partsOf traverse %~ reverse
16:19:16 <lambdabot>  "dsa"
16:20:41 <iqubic> What the heck does that do?
16:20:51 <iqubic> How does that work?
16:22:53 <Gurkenglas> You wanted witchcraft, there you have it
16:23:09 <iqubic> I wanted examples, not witchcraft.
16:23:24 <Gurkenglas> An example of something that set, view and over don't explain
16:23:31 * hackage more-containers 0.1.0.1 - A few more collections  https://hackage.haskell.org/package/more-containers-0.1.0.1 (mtth)
16:23:40 <Rembane> Is %~ fmap for lenses?
16:23:47 <Gurkenglas> %~ is just an alias for over.
16:24:00 <Rembane> :t over
16:24:01 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
16:24:07 <Rembane> Hm...
16:24:29 <Gurkenglas> But yes, fmap for lenses is a good analogy.
16:24:35 <iqubic> What does partsOf do?
16:25:04 <Rembane> :t partsOf
16:25:06 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
16:25:14 <Gurkenglas> In this case, it traverses "asd" with a state monad, gets the characters out and puts em in a list, then lets (%~ reverse) have its fun with it
16:25:29 <Gurkenglas> putting the results back in place.
16:25:29 <Rembane> I need to level up some more before the type signatures for lenses actually tell me something.
16:26:01 <iqubic> What is the general use for partsOf?
16:26:04 <Gurkenglas> Rembane, it turns a traversal into a lens over the traversal's targets
16:26:14 <Rembane> Gurkenglas: Ah. That's nice.
16:26:34 <Gurkenglas> *over a list contianing the traversal's targets
16:26:42 <kamyar> http://lpaste.net/1332304520281063424
16:26:45 <Rembane> Gurkenglas: The double a:s in the type signature, do they mean that it does that for both getters and setters?
16:26:51 <kamyar> please consider my code
16:27:21 <iqubic> I love partsOf.
16:27:37 <Rembane> kamyar: What does it do? What should it do?
16:27:44 <Gurkenglas> Rembane, it means that you can't change the type of the targets, because when the list you put back in is shorter than the ones you get out, it reuses old values.
16:27:50 <iqubic> and partsOf traverse just takes the list of targets, and traverses that list?
16:28:00 <Gurkenglas> *lenses that list
16:28:03 <Rembane> Gurkenglas: Okay, thank you.
16:28:09 <Gurkenglas> :t unsafePartsOf -- Rembane, this variant crashes instead
16:28:10 <lambdabot> Functor f => Traversing (->) f s t a b -> LensLike f s t [a] [b]
16:28:21 <Rembane> Gurkenglas: :D
16:28:42 <dminuoso> Gurkenglas: where does partsOf come from?
16:28:51 <dminuoso> Is that some lambdabot builtin?
16:28:51 <Gurkenglas> dminuoso, hoogle it
16:28:56 <dminuoso> Gurkenglas: I did, no results.
16:29:01 <Gurkenglas> Gimme a link
16:29:07 <dminuoso> https://www.haskell.org/hoogle/?hoogle=partsOf
16:29:38 <Gurkenglas> dminuoso, that doesn't find over either. Use hayoo
16:29:59 <dminuoso> Ahh great thanks for the tip.
16:30:19 <iqubic> So, what are prisms, and how do they work?
16:30:41 <iqubic> I get how lenses and traversals work.
16:32:06 <boj> iqubic: https://artyom.me/#lens-over-tea - part 5 covers prisms
16:32:21 <iqubic> "asd" & partsOf traverse %~ reverse seems like a common thing to want to do. Is there a function that let's you do this more generically?
16:32:37 <dminuoso> You mean.. reversing a string?
16:32:41 <Gurkenglas> @tell kamyar consider http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:forkMapM
16:32:41 <lambdabot> Consider it noted.
16:33:29 <Gurkenglas> iqubic, a Lens' s a is a witness that s looks like (a, b) for some b. A Prism' s a is a witness that s looks like Either a b for some b.
16:33:42 <Gurkenglas> Lenses are like record fields, prisms are like constructors.
16:33:54 <iqubic> dminuoso: No, I mean apply some function to all the targets of a traversal and then rebuild the structure.
16:34:04 <iqubic> Gurkenglas: I'm not sure what you mean by witness.
16:34:04 <dminuoso> Gurkenglas: So a Prism is basically a lens for coproduct types?
16:34:11 <Gurkenglas> dminuoso, yes
16:34:30 <Gurkenglas> iqubic, foo witnesses a property if the existence of foo proves the property
16:34:53 <iqubic> I see.
16:35:29 <iqubic> "a Lens' s a is a witness that s looks like (a, b) for some b" what does that mean?
16:36:09 <Gurkenglas> If you have (a, b) and don't know b, you can still get out the a and put in a new a.
16:36:20 * hackage stb-image-redux 0.2.1.1 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.2.1.1 (sasinestro)
16:36:35 <iqubic> Right I see.
16:36:56 <iqubic> So lenses let you target a single field in a record.
16:37:05 <Gurkenglas> Now tell me what you can do with an Either a b if you don't know b.
16:37:30 <iqubic> You can get a Maybe a?
16:37:41 <Gurkenglas> Yep. What else can you do with the type Either a b
16:37:50 <iqubic> I'm not sure.
16:38:04 <Gurkenglas> You can turn an a you have into an Either a b.
16:38:15 <iqubic> Right.
16:38:18 <dminuoso> Left.
16:38:22 <dminuoso> =)
16:38:31 <Gurkenglas> Those are the two things prisms allow you to do, and all the other uses derive from them just like technically there are more derivable uses for Either a b
16:38:35 <iqubic> How does that manifest in the actual code.
16:38:48 <kamyar_> http://lpaste.net/1332304520281063424
16:38:55 <kamyar_> please consider my code
16:39:03 <kamyar_> My problem is that the time increases gradually instead of being approx. the sam
16:39:06 <kamyar_> the same
16:39:07 <Gurkenglas> kamyar_, consider http://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:forkMapM
16:39:24 <iqubic> Prisms let you get a Maybe a, or turn an a into an Either a b.
16:39:59 <Gurkenglas> Yep. Just like a constructor lets you match and construct.
16:40:04 <kamyar_> Gurkenglas: What does this change?
16:40:21 <kamyar_> Gurkenglas: what is the problem with my code?
16:40:23 <Gurkenglas> kamyar_, not much, just takes some of the implementation out of your personal code
16:41:12 <iqubic> So lenses decompose sum types, and prisms decompose product types. Is that right?
16:41:21 <Gurkenglas> yes
16:41:32 <iqubic> I sorta get that.
16:41:39 <iqubic> :t _1
16:41:40 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
16:41:47 <dminuoso> Gurkenglas: Isn't sum and product types mixed up in that statement?
16:41:59 <iqubic> Nope.
16:42:13 <iqubic> A sum type is (a, bi)
16:42:28 <iqubic> a product type is "Either a b"
16:42:42 <iqubic> Or actually, I'm wrong
16:43:05 <iqubic> dminuoso: you are right.
16:43:31 <iqubic> lenses decompose Product types. prisms decompose Sum types.
16:43:44 <iqubic> Anyone have a simple prism I can try writting?
16:44:02 <Gurkenglas> Right, I didn't even read the sentence :D
16:44:22 <dminuoso> Gurkenglas: Judging from your name I can guess why.
16:44:51 <Gurkenglas> Pickles... don't have... eyes?
16:45:20 <dminuoso> No but it strongly implies that you are German.
16:45:37 <Rembane> Gurkenglas: If they aren't pickled eyes of course
16:45:39 <Gurkenglas> Germans... are... illiterate?
16:46:05 <dminuoso> Based on some of the kids I see outside that topic definitely needs more research.
16:46:24 <dminuoso> They are definitely not "der deutschen Sprache mächtig".
16:46:25 <Gurkenglas> iqubic, the prism into the left side of Either a b, of course.
16:47:38 <iqubic> How does one construct a prism?
16:47:38 <iqubic>  
16:48:00 <Gurkenglas> :t prism
16:48:01 <lambdabot> (Applicative f, Choice p) => (b1 -> t1) -> (s1 -> Either t1 a1) -> p a2 (f b2) -> p s2 (f t2)
16:48:08 <dminuoso> Gurkenglas: What you said about `Lens' s a` with s being a witness.. that didn't fully compute. Care to elaborate?
16:48:29 <Gurkenglas> dminuoso, a lens tells you how the big type is the product of the small type and something else.
16:49:06 <iqubic> What do I have to import to get access to prism?
16:49:24 <Gurkenglas> Control.Lens
16:49:44 <Gurkenglas> :t prism' -- You may use this one if you want.
16:49:45 <lambdabot> (Applicative f, Choice p) => (b1 -> s1) -> (s1 -> Maybe a1) -> p a2 (f b2) -> p s2 (f s2)
16:50:17 <iqubic> Is Control.Lens in standard libraries?
16:51:03 <dminuoso> iqubic: its on stackage at least :)
16:51:13 <iqubic> I see.
16:51:56 <dminuoso> Gurkenglas: Okay Im not going to try and understand that. The list of topics I want to really learn about is growing exponentially..
16:52:25 <dminuoso> I still have not done any IO..
16:52:36 <dminuoso> But that's overrated.
16:53:00 <iqubic> How do I add Control.Lens to an intero + stack project?
16:57:49 <iqubic> Nevermind, I figured it out.
17:01:41 <tinytusk> Hi. Is there a way to rewrite this using only Prisms?: map (\(x, y) -> (x, fromMaybe "" y))
17:03:47 <glguy_> :t view (mapping (non "")) -- maybe?
17:03:48 <lambdabot> (Functor g, MonadReader (g (Maybe [Char])) m) => m (g [Char])
17:04:50 <glguy_> I doubt it can be done using "only prisms"
17:05:39 <ph88> hey guys, i was already told that if i want to modify the base package that i need to recompile ghc from source. But i'm still a bit surprised about this, is there really no other way ?
17:06:20 <glguy_> Surprise!
17:07:31 * hackage stb-image-redux 0.2.1.2 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.2.1.2 (sasinestro)
17:10:26 <boj> ph88: you could rewrite the bits in your own module and import that?
17:19:23 <ph88> boj, ah ye .. that might be an idea. But then i think i would also have to update the libraries that use the base functions to use my function instead
17:26:19 * hackage more-containers 0.1.0.2 - A few more collections  https://hackage.haskell.org/package/more-containers-0.1.0.2 (mtth)
17:34:46 <iqubic> What is a container?
17:35:56 <yoho> it's like a functor :^)
17:36:23 <iqubic> Except what?
17:36:42 <yoho> I'm just making a joke about the usual description of a functor being "like a container"
17:36:58 <yoho> (usually with a "but not really" and then no further clarification)
17:38:09 <iqubic> Ah. I see.
17:38:15 <iqubic> I know what a functor is .
17:39:02 <iqubic> What is an affine traversal?
17:39:29 <iqubic> I saw it mentioned in Lens over Tea, but I have no idea what it is.
17:42:49 <grokkingStuff> anyone know what the container library is?
17:45:43 <yoho> Data.Map is in there
17:46:02 <yoho> here you go https://hackage.haskell.org/package/containers-0.4.0.0/docs/
17:46:09 <Gurkenglas> iqubic, read through glassery
17:49:09 <glguy_> Note that that documentation look for containers is 7 years out of date
17:49:14 <glguy_> Link*
17:50:18 <grokkingStuff> glguy_: the git repo seems to be updated regularly enough - changes were made a few days ago.
17:50:52 <jle`> grokkingStuff: the git repo has updated but you ar elooking at old docs
17:51:13 <grokkingStuff> jle`: i'm looking at the docs for 0.5
17:51:40 <glguy> grokkingStuff: No, the problem is that that link for for an ancient version of the package, not that the package is unmaintained
17:51:44 <jle`> oh sorry, meant to say that yoho was looking at the old links
17:51:53 <yoho> derp
17:51:59 <yoho> I just took the link google gave me
17:52:05 <grokkingStuff> :|
17:52:47 <yoho> if I'd gone one level up the directory tree I'd (possibly, given how bad I am at noticing things...) have seen the big list of versions...
17:52:54 <jle`> yes the latest versions of ghc come with containers-0.5.10.2
17:53:11 <jle`> grokkingStuff: but yeah, to answer your original question
17:53:22 <jle`> grokkingStuff: the containers library is a library of useful containers :)
17:53:30 <grokkingStuff> jle`: .........
17:53:35 <jle`> it's the standard library for these types of containers in haskell
17:53:42 <yoho> I mean, what else do you expect, grokkingStuff :D
17:53:43 <jle`> it's used by the ghc source code
17:54:10 <grokkingStuff> is it used outside ghc source code? save for data.map?
17:54:12 <yoho> is haskell self-hosting?
17:54:12 <jle`> and it's the standard place people find maps, sets, etc.
17:54:17 <jle`> grokkingStuff: nah it's the standard for everyone
17:54:23 <grokkingStuff> sweet
17:54:34 <jle`> it's the standard implementation of sets, maps, append-from-both-side sequences
17:55:02 <jle`> it's also the one that is given the most attention to when optimizing for performance
17:55:07 <jle`> since almost all haskell applications use it
17:55:28 * hackage more-containers 0.1.0.3 - A few more collections  https://hackage.haskell.org/package/more-containers-0.1.0.3 (mtth)
17:55:29 <jle`> there probably isn't a single non-trivial haskell application that doesn't use it, or doesn't use a library that uses it
17:56:05 <yoho> hotfix :D
17:56:22 <grokkingStuff> So if i want to do anything serious, i should probably use more than maps and hashmaps and actually understand how containers work
17:56:50 <jle`> well most serious haskell applications end up using maps or sets from containers
17:56:55 <jle`> you probably don't need to understand how they are implemented
17:56:59 <jle`> just the basics of the API
17:57:05 <Gurkenglas> One of the most meta libraries, for it contains containers, which pattern few other libraries can boast of.
17:57:15 <yoho> :D
17:57:43 <grokkingStuff> so read the functions and see what they do but don't worry about the internals save for performance?
17:58:10 <jle`> the most you'll need to know about the 'internals' is probably the asmyptotics, which the docs give
17:59:37 <grokkingStuff> asmyptotics? what are those?
18:01:11 <yoho> aymptotic time complexity
18:01:29 <yoho> a measure of how long you can expect a function to take as function of <something>
18:01:57 <yoho> in the case of containers it'll generally be a function of how many things are currently in the container, for example
18:02:21 <iqubic> So now that I have mastered lenses, what should I learn about now?
18:02:32 <Gurkenglas> pfft
18:03:07 <Gurkenglas> Try the rest of ekmetts ivory tower of libraries? ^^
18:03:23 <iqubic> What other libraries does he have/
18:03:27 <yoho> grokkingStuff: for example, say you've got a list with n random numbers in it and you want to check if a certain number is in the list - in the worst case you check all n items and find it's not there, so we say its asymptotic time complexity is of order n
18:03:34 <Gurkenglas> I think he's building it faster than I'm climbing it. search him on github
18:03:58 <iqubic> I don't want to do that.
18:04:01 <grokkingStuff> yoho: huh
18:04:16 <Gurkenglas> You don't want to search him on github?
18:04:17 <iqubic> Are we trying to explain Big O notation.
18:04:18 <yoho> (there are a few different measures of time complexity, worst case and average case are the most commonly discussed ones)
18:04:45 <iqubic> Gurkenglas:I don't want to keep learning about EdKmett's libraries.
18:04:51 <yoho> and that explanation's a bit of a simplification but covers about as much as you strictly need to know
18:05:29 <iqubic> I want to learn about Monad Transformers, but I haven't found a good guide for them.
18:06:35 <yoho> RWH?
18:06:38 <yoho> http://book.realworldhaskell.org/read/monad-transformers.html
18:06:52 <iqubic> I hear that RWH is out of date now.
18:07:32 <iqubic> I'm not sure I should use that right now, but I'll try.
18:07:38 <grokkingStuff> yoho: thank you. i'm googling it rn.
18:07:40 <glguy> The concept of monad transformers hasn't changed. Even better than reading some more would be to go and make something!
18:07:52 <yoho> ^
18:08:04 <grokkingStuff> i think what most people don't get is why we use monad transformers
18:08:11 <yoho> it has worked examples, but you can also try to implement a transformer for a differnet monad side by side
18:08:17 <iqubic> Yeah, I understand.
18:08:21 <yoho> grokkingStuff: curious, what's your programming background?
18:08:40 <grokkingStuff> I'm an engineering student who likes to program.
18:08:53 <iqubic> I think I should start with something simple, like the MaybeT monad.
18:09:24 <grokkingStuff> just going through mit's opencourseware for CS. Just like programming, Yoho :)
18:09:37 <yoho> ah, that's cool
18:11:37 <kakashiAL> "monads are all about map and flatmap" <--do you agree with that? I would say that monads there to make code with side effects and many brances in a way "pure", would you agree or disagree?
18:12:03 <jle`> iqubic: try making real projects first, before learning about more concepts :)
18:12:44 <jle`> kakashiAL: i wouldn't quite agree, and it's unclear what you mean by "there"
18:12:50 <iqubic> You think I should do that?
18:13:05 <iqubic> I like the theoretical side of Haskell so much more though.
18:13:13 <yoho> usually the best way to learn a language imo
18:13:13 <jle`> iqubic: yeah, learning about concepts are nice, but i think it's hard to retain them unless you start applying them
18:13:27 <iqubic> I get that.
18:13:28 <yoho> (applies to both programming and real ones :D)
18:13:46 <kakashiAL> jle`: "I would say we monads to make code with side effects...."
18:13:46 <iqubic> I just don't have any idea what I should make.
18:13:55 <jle`> iqubic: also as you do projects, you'll figure out what you might need to learn next
18:13:57 <yoho> kakashiAL: I usually see them touted more for their sequencing
18:14:10 <iqubic> Yeah, me too.
18:14:19 <iqubic> Monads let you sequence actions.
18:14:39 <kakashiAL> jle`, yoho: 1. do you agree with that: monads are all about map and flatmap?
18:14:55 <jle`> i don't think that's a useful or accurate sentiment
18:15:27 * yoho googles flatmap
18:16:01 <iqubic> yoho, I think flatmap is basically join.
18:16:08 <iqubic> :t join
18:16:09 <lambdabot> Monad m => m (m a) -> m a
18:16:15 <yoho> oh
18:16:19 <jle`> flatmap is bind
18:16:25 <iqubic> Oh.
18:16:30 <yoho> that makes more sense
18:16:39 <iqubic> So what should I work on in Haskell?
18:16:53 <yoho> whatever interests you is the only real answer here
18:16:58 <iqubic> So flatmap is (join id)
18:17:15 <iqubic> @src (>>=)
18:17:15 <lambdabot> Source not found. Take a stress pill and think things over.
18:17:37 <jle`> flatmap f is join . fmap f
18:17:40 <jle`> hence "a flat map"
18:18:34 <kakashiAL> jle`: okay, great monads are not about map and flatmap, good to know :)
18:19:39 <jle`> kakashiAL: there might be some truth to it, but, i don't think it's a super useful perspective
18:23:48 <vaibhavsagar> jle`: I thought flatMap was the Scala equivalent of concatMap
18:24:56 <grokkingStuff> iqubic: send notifications to your email when the contents of a web page change
18:25:16 <grokkingStuff> ^ super useful if your dick professor announces things on a website and doesn't bother doing so in class
18:26:56 <iqubic> But I never check my email, so that wouldn't be of much help to me.
18:27:38 <yoho> send notifications by text when the contents of a web page change
18:27:58 <yoho> send notifications by <means of communication that you can get an API for> when the contents of a web page change
18:28:33 <yoho> you could look at parsing
18:28:57 <yoho> build yourself a basic interpreter for a toy language and build the stack up yourself
18:29:00 * yoho -> bed
18:29:29 <glguy_> If there's nothing you want to build you're in luck, you don't need to know how to program!
18:29:56 <iqubic> glguy: Is that sarcasm?
18:30:04 <iqubic> I sense sarcasm.
18:30:29 <glguy_> Only partially
18:32:54 * hackage more-containers 0.1.0.4 - A few more collections  https://hackage.haskell.org/package/more-containers-0.1.0.4 (mtth)
18:34:36 <iqubic> Well, I knwo that I want to do
18:34:47 <iqubic> I want to build a parser for a toy language.
18:35:07 <iqubic> But first I'm going to spend a bit of time designing the language.
18:36:13 <iqubic> I know more or less what it's going to do.
18:36:33 <iqubic> It's going to be similar to PuzzleScript.
19:05:22 <kakashiAL> f x y = x + y   has the typesignatur:  f :: Int -> Int -> Int
19:05:43 <kakashiAL> but this typesignature does not show my that my function f has two arguments
19:05:48 <iqubic> kakashiAL: What is your point?
19:06:19 <hexfive> it does though
19:06:19 <vaibhavsagar> kakashiAl: the last type is the return type
19:06:23 <iqubic> Yes, it does actually show that.
19:06:34 <kakashiAL> for me f :: Int -> Int -> Int means  a called f which takes an Int and returns an function that takes an Int and returns an Int
19:06:48 <vaibhavsagar> kakashiAL: that's also correct
19:06:50 <iqubic> It takes two ints and returns a third int.
19:06:53 <hexfive> that is the correct way to read the type kakashiAL
19:07:01 <vaibhavsagar> the two definitions are equivalent in Haskell
19:07:15 <iqubic> However, you can quickly parse it as take two ints, and return a third int.
19:07:32 <kakashiAL> so for me there is a difference between f :: Int -> Int -> Int and  f :: (Int, Int) -> Int
19:07:46 <kakashiAL> the first f is a curried function
19:07:52 <vaibhavsagar> kakashiAL: yes, you are right, which is why those are two different type signatures
19:07:56 <kakashiAL> the second f is a function with two arguments
19:08:03 <hexfive> pretty much. the curried version is more flexible
19:08:17 <vaibhavsagar> kakashiAL: the second f is a function with one argument
19:08:20 <hexfive> although not really, (Int, Int) is one arg
19:08:21 <hexfive> ^^
19:09:02 <iqubic> kakashiAL: The function "f :: (Int, Int) -> Int" Only accepts one argument, a 2-tuple with both slots being Ints.
19:10:03 <kakashiAL> let me ask it this way: if I see f :: Int -> Int -> Int  where can I know if its curried or a function with two arguments?
19:10:17 <iqubic> kakashiAL: It is both.
19:10:34 <hexfive> i don't think a function with 2 arguments is even possible in haskell. that is, only curried functions can be made
19:10:38 <iqubic> It is both a curried function, and a function that takes two arguments.
19:10:40 <kakashiAL> iqubic: are functions in haskell automaticaly curried?
19:10:47 <iqubic> yes.
19:11:04 <iqubic> That is how that works.
19:11:40 <kakashiAL> thanks to all, now it makese sense since I know that functions in haskell are automaticaly curried :)
19:12:11 <iqubic> @let f x y = x + y
19:12:12 <lambdabot>  Defined.
19:12:17 <iqubic> :t f 5
19:12:18 <lambdabot> error:
19:12:18 <lambdabot>     Ambiguous occurrence ‘f’
19:12:18 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
19:12:39 <iqubic> @let add x y = x + y
19:12:40 <lambdabot>  Defined.
19:12:50 <iqubic> :t add 5
19:12:51 <lambdabot> Num a => a -> a
19:13:05 <hexfive> alternatively:
19:13:06 <iqubic> :t add 5 6
19:13:07 <lambdabot> Num a => a
19:13:08 <hexfive> :t (5+)
19:13:09 <lambdabot> Num a => a -> a
19:13:34 <iqubic> Yeah. that's a simple example of how currying works in haskell.
19:13:47 <iqubic> :t 5 + 6
19:13:48 <lambdabot> Num a => a
19:32:48 <Lokathor> i moved to lts10
19:32:55 <Lokathor> the first time i've had to build any of the big libraries in a while :/
19:34:30 <iqubic> What big library are you building?
19:40:47 <Lokathor> seemed to take a while on something called blaze-builder
19:41:03 <Lokathor> blaze-textual maybe
19:41:16 <Lokathor> it's just an IRC bot with Text and ByteString and NetworkSimple
19:41:56 <iqubic> What is for?
19:43:54 <Lokathor> the bot?
19:44:05 <Lokathor> just for fun
19:44:13 <Lokathor> however, it seems that CI is reporting an error :/
19:44:32 <Lokathor> http://lpaste.net/361102
19:51:59 <mniip> oh yay
19:52:04 <mniip> bootstrap hell again
19:53:48 <Lokathor> i figured it out!
19:53:58 <Lokathor> the docker image wasn't using the latest stack
19:54:10 <Lokathor> stack upgrade && stack build --install-ghc && stack test
19:54:13 <Lokathor> that's my new CI script
20:08:17 <Lokathor> welp, now to leave it running for days and days, and see if it keeps itself connected
20:13:51 <mniip> let's see if we can install lens with base-4.11.0.0
20:14:05 <hs_newb> hello, any purescript users here?
20:15:56 <kakashiAL> in haskell, if I define a function, haskell figures out what its signature is, so why bother with defining your own function type-signature?
20:18:45 <mniip> oh yeah I almost forgot
20:18:56 <mniip> Cabal-2.1.0.0 likes to eat all your ram
20:19:19 <mniip> kakashiAL, in some cases type inference is undecidable or impossible
20:20:37 <Lokathor> kakashiAL, also, GHC will sometimes be more restrictive that it strictly needs to be, or perhaps you want to pick a more restrictive type than it could be
20:20:50 <Lokathor> also, numbers default to Integer, but that is very bad for performance compared to Int
20:22:42 <kakashiAL> Lokathor: didnt know that there is is Int and Integer
20:23:00 <Lokathor> Integer is unbounded
20:23:18 <Lokathor> which is nice if you need it, but slower, and you often don't need it
20:23:55 <kakashiAL> what do you mean with "unbounded" ?
20:24:13 <kakashiAL> unlimited?
20:25:22 <Lokathor> yeah if the value it's supposed to be gets bigger than fits into Int64 it will switch to a multi-word version and keep going up
20:25:43 <Lokathor> and it can keep getting bigger until you run out of RAM basically
20:26:14 <kakashiAL> nice :)
20:26:30 <mniip> yay
20:26:38 <mniip> nothing supports base-4.11.0.0
20:27:17 <glguy> are you using http://head.hackage.haskell.org ?
20:27:41 <dmwit> kakashiAL: https://stackoverflow.com/q/19626801/791604
20:28:22 <kakashiAL> dmwit: thanks!
20:28:54 <mniip> glguy, what's that
20:29:52 <glguy> A hackage root with a bunch of packages patched for the development branch of ghc. click the image to go to github to see the patches
20:33:25 <sqooq> henlo, merry consumeristmas
20:34:50 <sqooq> is it possible to generalize the idea of a recursive function with a buffer into a single object I can compose with others? I've been trying for I think a week now, and starting to lose hope but I didn't want to do actual IO stuff, but if that's what it boils down to, I'm ok with it.
20:35:10 <sqooq> (kek there's probably overlap with discord haskell in here, they know)
20:35:23 <mniip> glguy, this doesn't seem to have a patch for vector
20:35:30 <mniip> which lens depends on
20:52:20 <Lokathor> sqooq, like a fold?
20:57:13 <mniip> hvr: your mirror needs a patch for vector's and primitive's base dependencies (if you strive to support lens)
20:59:14 <sqooq> Lokathor, no not like a fold at all lmao
20:59:24 <sqooq> though I guess you can engineer a fold function that keeps state
21:00:30 <sqooq> I guess it's kind of hard to explain what I want, I'm literally starting to think it's straight
21:00:38 <sqooq> impossible without a lot of IO
21:01:25 <sqooq> but I think I'm actually ok with just one final function doing all the IO shit, and somehow having two functions, one that stores, and one that grabs, that can be used inside the run function
21:01:51 <sqooq> I want to keep the codestyle as non-imperative as possible
21:02:39 <ertes> sqooq: what would be an application of that?
21:02:50 <sqooq> I'm writing a low-level audio library for synthesis/music
21:02:52 <ertes> (to understand what it is that you're trying to construct here)
21:03:22 <sqooq> and running into problems whenever "delays" (as in you send a sample in and it comes out n samples later) are used recursively
21:03:52 <sqooq> so I can define specific functions with storage/state quite easily, but creating a general "delay" function or similar is like really hard
21:04:01 <ertes> like an echo filter?
21:04:05 <sqooq> hopefully y'all know what I mean by samples
21:04:24 <sqooq> ertes: umm, if you mean echo effect, yes, that's one use of it
21:05:05 <sqooq> but like a onePole filter uses a 1 sample delay for example, and I cannot write that function without specifically specifying the carrying over of the value
21:05:26 <ertes> sqooq: this is something that FRP can model…  i've done a few experiments and have a few drafts for a buffered FRP implementation, but nothing serious right now
21:05:37 <sqooq> is it IO or no?
21:05:49 <sqooq> I want to do this non-IO if possible
21:05:51 <sqooq> or minimal IO
21:06:14 <ertes> triggering events is IO, but all the application semantics is pure
21:06:27 <sqooq> :thinking:
21:06:56 <ertes> it's possible to do this without any IO…  one option is AFRP, but that gets very ugly very quickly
21:07:20 <ertes> also triggering events in IO is more or less natural
21:07:37 <sqooq> what do you mean triggering events?
21:07:45 <sqooq> I just don't want the library to be used very imperatively
21:07:57 <sqooq> it would be nice to use it as though it was just regular ole functional haskell
21:07:58 <ertes> imagine a main loop that waits for the sound driver to ask for samples, at which points it triggers enough FRP frames to fill the buffer
21:08:05 <sqooq> aka no do blocks
21:08:21 <sqooq> ertes: o btw I don't care about this being real time
21:08:34 <ertes> basically triggering events (in a reflex-style framework) is the interface between the pure application and the IO world
21:08:38 <kakashiAL> stupid question but where can I get a list of all types that haskell has?
21:09:01 <sqooq> kakashiAL all types included with the base language or?
21:09:07 <ertes> kakashiAL: the same place where you can get a list of all the Integer values that haskell has
21:09:51 <ertes> sqooq: the whole point of FRP is that the actual application is pure…  you can design the API in such a way that it can work with ST, too
21:09:53 <ertes> even with lazy ST
21:10:01 <sqooq> :thinking:
21:10:05 <kakashiAL> I mean is there a doc or a book that you can recommend that lists all types that haskell has (String, Int, Integer, [ ], ...)
21:10:07 <sqooq> FRP never made much sense to me
21:10:19 <sqooq> ertes: can you give me a good clear resource perhaps?
21:10:47 <ertes> sqooq: i wish i could, but the best ones i know are the blog posts of heinrich apfelmus, the author of reactive-banana
21:11:09 <sqooq> so you can, or are they deleted?
21:11:11 <mniip> kakashiAL, all types?
21:11:15 <ertes> sqooq: it's often very r-b-specific, but it's easy to transfer r-b knowledge to other (real) FRP frameworks
21:11:30 <sqooq> ertes: ok I'll check it out thanks.
21:11:34 <mniip> how is that going to work if anyone can make up new types
21:11:49 <sqooq> kakashiAL, if you mean what's included by default, I think the prelude docs lists them, but I could be wrong
21:11:50 <sqooq> https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html
21:12:02 <ertes> sqooq: https://apfelmus.nfshost.com/blog.html#functional-reactive-programming-frp
21:12:37 <mniip> https://hackage.haskell.org/package/base-4.10.1.0/docs/doc-index-All.html
21:12:38 <sqooq> I'm guessing its listed there top latest, bottom earliest?
21:12:53 <ertes> sqooq: of course if you want something more academic, there are the paplers by conal elliot, including the original "functional reactive animation" paper by him and paul hudak
21:13:12 <sqooq> nah academic is crap unless you already are aware of things
21:13:26 <sqooq> they tend to assume that the reader already knows everything they know
21:13:34 <sqooq> and that they're just adding this new bit of information
21:13:39 <ertes> they can give you a deeper understanding of how FRP works and why it's designed the way it is, but it's not really necessary to understand how to apply it
21:13:44 <mniip> um
21:13:48 <mniip> that's how that works yes
21:13:48 <sqooq> I mean I've learnt from papers just fine
21:13:57 <mniip> no one is going to spoonfeed you
21:14:08 <sqooq> mniip, I don't expect to be spoonfed
21:14:22 <sqooq> but you can't deny that some things can be explained in easy ways and hard ways
21:14:26 <mniip> it's not "crap" it just how that works
21:14:40 <mniip> often easy ways are imprecise
21:14:42 <sqooq> I meant crap as in crap for learning something entirely new to you
21:14:43 <mniip> and unfit for an article
21:14:49 <sqooq> I shouldn't have used crap tbh
21:14:50 <sqooq> my bad
21:14:51 <ertes> sqooq: as for implementations currently the top two are reactive-banana and reflex
21:14:53 <sqooq> papers are great
21:14:58 <sqooq> but not for starting out
21:15:06 <sqooq> ertes: danke
21:15:24 <ertes> sqooq: personally i prefer reflex, but r-b is very good for learning, because its API is a lot simpler
21:16:13 <sqooq> "A common answer would be that “FRP is all about describing a system in terms of time-varying functions instead of mutable state”" sounds perfekt
21:16:32 <sqooq> and then gets better
21:16:34 <sqooq> " and that would certainly not be wrong. This is the semantic viewpoint. But in my opinion, the deeper, more satisfying answer is given by the following purely syntactic criterion:
21:16:34 <sqooq>     The essence of functional reactive programming is to specify the dynamic behavior of a value completely at the time of declaration.
21:16:34 <sqooq> "
21:16:58 <sqooq> that's what I actually attempted to do with all my formulations of this audio library
21:17:09 <sqooq> pretty much everything took a signal as argument
21:17:35 <ertes> sqooq: yeah, and FRP adds events to the mix
21:17:35 <sqooq> and that signal was just a list (in first implementation) or function (as in cartesian, in second implementation)
21:17:49 <sqooq> of every value through time
21:18:16 <ertes> sqooq: behaviours (time-varying functions) are easy enough to model in isolation…  it's events that make things complicated
21:18:30 <ertes> and that's where FRP comes in
21:18:45 <ertes> err
21:18:55 <ertes> s/time-varying functions/time-varying values/
21:22:12 <jchia> What's the purpose of Data.Tuple.OneTuple? It doesn't give you regular tuple syntax and it seems that all its functionality is already covered by Identity.
21:24:49 <sqooq> ertes: what do you mean by events?
21:31:05 <geekosaur> jchia, it doesn't really have one. some people were annoyed back in that toime period because Haskell has an "0-tuple" and n-tuples for n >= 2, but no 1-tuple
21:32:44 <geekosaur> iirc there's a couple other 1-tuple packages, but they're all kinda pointless because there's no way to fit them into the type system as actual 1-tuples
21:34:56 <jchia> geekosaur: OK, I was wondering why it's showing up as a dependency when I build stuff. Turns out it's used by the tuple package, which I can imagine to be at least somewhat popular.
21:37:47 <sqooq> ertes: ok so I always for whatever reason conflated FRP with arrows, and I never liked arrows
21:38:00 <geekosaur> looks like that is trying to treat tuples as variuous things they're not really meant to be
21:38:12 <sqooq> but this is pretty simple, I think I may have independentally rediscovered a really shit version of FRP actually
21:38:23 <sqooq> because it made sense for my problem
21:38:27 <geekosaur> but there's always someone who insists that a tuple must be a funny looking list or etc.
21:38:35 <sqooq> it's the events probably that kills me, like you said, that's the tricky part
21:39:55 <geekosaur> arrowized FRP is just one form of FRP. proc syntax is apparently fairly useful for connecting FRP elements
21:41:04 <sqooq> what's proc syntax?
21:42:18 <ReinH> After using Agda it’s hard to go back to Haskell’s use of ()
21:42:59 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#arrow-notation
21:43:03 <piyush-kurur> sqooq: it is related to arrows https://www.haskell.org/arrows/syntax.html
21:43:20 <piyush-kurur> geekosaur: darn you beat me
21:43:33 <sqooq> o
21:43:45 <sqooq> see proc syntax is what I don't like
21:45:31 <piyush-kurur> sqooq: some times it can cleanup code although I have used it only when Hakyll was arrow based
21:46:17 <piyush-kurur> it looks like arrows are not used that much (at least, I have used it only sparingly)
21:47:13 <geekosaur> no, for the most part arrows are these days used by HXT and by arrowized FRP. most other uses are better written with Applicative or Profunctor/Category
21:48:18 <geekosaur> (and arguably HXT could be redone as Applicative)
21:51:10 <sqooq> ertis: holy fuck I think this is along the lines of what I'm dealing with
21:51:15 <sqooq> but I don't understand the solutions so much just yet
21:51:16 <sqooq> https://apfelmus.nfshost.com/blog/2011/05/15-frp-dynamic-event-switching.html
22:01:36 <Wizek> Hello
22:01:49 <Wizek> Are people here who've used optparse-generic?
22:02:05 <ertes> sqooq: yes, as long as you don't have behaviours, FRP is really simple to implement, but with events things get tricky to make both nice *and* efficient
22:02:17 <ertes> sqooq: especially if you go full FRP, i.e. higher-order
22:03:23 <ertes> sqooq: AFRP is basically the easy way out…  you trade implementation simplicity for a terrible API and undesirable performance characteristics
22:03:47 <ertes> sqooq: AFRP is not *slow* (quite the contrary), but the API makes maintaining that speed in real applications rather probelamtic and hacky
22:04:16 <zaquest> does having cloneTMChan breaks something? or it just wasn't implemented?
22:05:31 <ertes> sqooq: the problem with AFRP is that arrows lack the higher-order composition of monads, so it forces all your events and behaviours to become "virtual"…  if you look at a piece of proc/do syntax, all the variables you see are fake…  there are no first-class behaviours/events in AFRP
22:05:40 <ertes> that's a problem with arrows in general
22:05:57 <ertes> you usually use arrows when you really can't come up with a monad for the job
22:06:08 <ertes> there is no other reason to use them
22:06:36 <ertes> and even then often an Applicative/Category framework is much easier to work with
22:11:47 <sqooq> ertes: interesting
22:14:29 <ertes> sqooq: if you ever come across the hxt library you'll see exactly what i mean (and as geekosaur has noted, its use of arrows is even pointless – it could use regular monads and have a much nicer API that way)
22:14:47 <ertes> their use of arrows was probably just an experiment, and it was successful in showing that arrows suck =)
22:15:14 <geekosaur> iirc it was exactly that, an experiment in arrows as an API
22:15:26 <geekosaur> there's a reason it hasn't been repeated :)
22:18:02 <sqooq> ok so glad everyone agrees they suck lmao
22:18:09 <sqooq> I don't think I'll ever need them for my use case
22:18:10 <ertes> sqooq: for a proper use of arrows check out an AFRP library like yampa or wires…  disclaimer: i'm the author of the latter =)
22:18:31 <sqooq> btw there are some tutorial slides for reactive-banana and i feel kind of special
22:18:44 <sqooq> He says the implementation is more complex, and more efficient
22:18:51 <geekosaur> arrows looked like a good idea. they sort-of were: out of them fell applicative, profunctor, and category
22:19:01 <sqooq> but I think I basically remade an inneficient, but intuitive FRP system
22:19:10 <geekosaur> but the three are much better than the comnination, which is kinda ruined by the arr combinator
22:19:18 <ertes> i think arrows were important – not as a tool, but as an exercise
22:19:18 <geekosaur> *combination
22:19:58 <ertes> sqooq: you can make a simple FRP implementation, as long as you don't touch the higher-order features of FRP
22:20:08 <geekosaur> also it was an experiment in generalizing the function arrow (hence its name), one that turned out to be less than useful as there's not much that abstracts well in that way
22:20:20 <sqooq> ertes: and maybe what I need for my issues is a higher-order feature
22:20:30 <sqooq> what's interesting is I started going the applicative route
22:20:39 <ertes> sqooq: example: joinE :: Event (Event a) -> Event a
22:21:02 <ertes> sqooq: this function is surprisingly difficult to implement *efficiently*
22:21:10 <sqooq> and I was so sure it would be perfekt
22:21:19 <sqooq> but then when I hit a bump I like immediately discarded it
22:21:26 <sqooq> but now looking at these slides I was on the right track
22:21:36 <ertes> sqooq: yes, you were
22:21:41 <ertes> Behavior is a monad
22:21:55 <flag_> How do I create a data type which "takes a type as input" (e.g., a Ring consists of two functions +, * : T x T --> T, and I want to have a Ring type for each T) ?
22:21:58 <ertes> and Event is a lot of things from the 'semigroupoids' package, up to Bind
22:22:26 <ertes> sqooq: Bind is Monad sans 'pure'
22:22:41 <ertes> it's also an 'Align' from the 'these' package
22:22:53 <ertes> align :: Event a -> Event b -> Event (These a b)
22:22:55 <sqooq> even the `<@` operator I see in this slide
22:23:04 <sqooq> I had my own operator `&>`
22:23:28 <sqooq> which wasn't the same really, because I didn't have events, but if I'm not mistaken was *supposed* to accomplish the same thing
22:23:29 <ertes> (<@) is FRP-specific…  it's the simplest bridge between events and behaviours
22:23:46 <ertes> another one is 'hold'
22:24:00 <sqooq> Since in my system time is discrete numbers
22:24:15 <sqooq> &> just bumped time up by one
22:24:33 <ertes> sqooq: there is this notion of "signal FRP", which is basically FRP without behaviours
22:24:44 <sqooq> :thinking:
22:24:46 <sqooq> well I mean
22:24:52 <sqooq> audio is working with "signals"
22:25:08 <sqooq> which are just samples over discrete time
22:25:21 <ertes> sqooq: i think it's better to model them as behaviours anyway
22:25:41 <ertes> they are continuous, and modelling them as such comes with distinct advantages
22:26:26 <ertes> sqooq: to be fully honest i think that "signal FRP" is not a good framework…  real FRP is far more powerful
22:26:50 <ertes> having Behaviour as a monad gives you a lot of expressivity
22:28:05 <sqooq> I'll take your word
22:28:22 <sqooq> my idea was always to have them be time functions and just at the last moment, evaluate all the discrete times for them
22:29:10 <ertes> sqooq: remember that continuous time is just semantics…  there is no actual time value passed around…  you still sample them at discrete intervals
22:29:31 <sqooq> well yeah
22:29:39 <sqooq> I know, it's a computer lmao
22:30:27 <sqooq> I'm curious how for a very nonIO frp system, how sampling occurs?
22:31:08 <ertes> sqooq: both r-b and reflex need IO for the application/world boundary
22:31:40 <ertes> sqooq: the main difference between the two is that r-b is based on callbacks, while reflex makes you write a main loop
22:31:47 <sqooq> like going from the functional to it actually applying and giving a result?
22:32:06 <sqooq> See if they use IO, then I was *definitely* on the right track
22:32:19 <ertes> r-b is designed mostly for GUI frameworks that have you register event callbacks, and its idea is that you just connect those callbacks to r-b
22:32:21 <sqooq> and if I understand you, r-b just keeps it sort of hidden out of the way
22:32:40 <sqooq> because that was my plan, I just didn't know how to do it
22:32:43 <sqooq> at all
22:32:58 <sqooq> like I couldn't imagine a way to do it without a main loop kek
22:32:58 <ertes> not really hidden, no
22:33:12 <sqooq> hmm
22:33:28 <ertes> you still have to write a main loop with r-b, but instead of *triggering* events, you come up with a mutable callback system
22:34:01 <ertes> reflex instead gives you a trigger function, so you just trigger events from the loop, and that sets the FRP system in motion for one single frame
22:34:19 <ertes> then you can observe the results of that time step (which events happened in response?  what's the new value of behaviours?)
22:34:43 <sqooq> interesting
22:34:50 <sqooq> sounds kind of like what I wanted to avoid
22:34:58 <sqooq> but if it's unavoidable I can give in
22:35:02 <ertes> honestly i much prefer the way reflex does it
22:35:31 <sqooq> so trigger applies the current time step to the behaviours?
22:35:34 <ertes> consider this:  the main loop is the boundary between the pure application and real world, in this case the sound driver
22:35:46 <sqooq> ertes: what if I just want to make wave files though
22:35:49 <ertes> you will have this boundary somewhere in some way
22:35:53 <sqooq> so really I don't need for actual time to be a thing
22:36:14 <sqooq> that's why I figured I could avoid io
22:36:19 <ertes> reflex gives you full control over that boundary without forcing a callback system or any other form of control on you
22:36:36 <ertes> time isn't a thing anyway
22:36:47 <sqooq> the loop just goes as fast as it can, I'm guessing
22:36:51 <ertes> if you want to write a wave file you just trigger events in a loop and observe the resulting samples
22:37:16 <sqooq> ok, interesting
22:37:31 <sqooq> I thought functional programming could do everything without effekts lmao
22:38:02 <ertes> you could do this with lazy ST
22:38:15 <ertes> reflex doesn't have an ST variant though
22:38:52 <sqooq> isn't ST still using IO though
22:39:30 <ertes> ST and IO are, in a sense, the same thing…  however, with ST you get runST, which can turn the main loop into a pure function
22:39:50 <sqooq> interesting
22:39:51 <ertes> you can turn the whole FRP application into a lazy stream/list
22:40:13 <sqooq> I mean I don't care about all that
22:40:17 <sqooq> I'll use IO if it's easy
22:40:21 <sqooq> well
22:40:24 <sqooq> if I have to use ST or IO
22:40:35 <sqooq> then i don't care I'll use whatever's easier
22:40:38 <ertes> well, unless you want to invent your own FRP system, it's easiest to just go with IO
22:40:49 <ertes> for the most part your main loop is at the real-world boundary anyway =)
22:40:59 <sqooq> ertes: I mean I almost kind of did, and the whole point of this was really an exercise in seeing if it could be done
22:41:38 <sqooq> so I might continue trying to make my own
22:41:51 <sqooq> but at least now I know it has a name, and I have resources and people who have already done it
22:41:53 <ertes> sqooq: i wouldn't really worry too much about IO/ST here…  the main loop is the smallest part of your application
22:42:15 <sqooq> and when I'm done or give up I'll write the real thing in a library like rb or reflex
22:42:16 <ertes> it's literally just setting the FRP system in motion and observes its results
22:42:26 <ertes> the FRP system itself is semantically pure
22:42:48 <sqooq> ertes: yeah, literally the first thing I said when I came in here, is that I don't care if it's IO as long as that IO was just one part of the thing and everything else was pure
22:42:59 <sqooq> so like this all sounds great tbh
22:43:01 <sqooq> I'm very happy
22:43:12 <ertes> have fun =)
22:43:12 <sqooq> ertes: thanks for the help.
22:43:42 <ertes> sqooq: i suggest that you have a look at one of those libraries or even both, just to get a feeling for how they work and how you would actually use them
22:44:03 <ertes> sqooq: they build on decades of knowledge
22:44:37 <ertes> after that you'll have a better understanding of what your framework needs to offer and how it should be designed, if you decide to write your own
22:46:45 <jchia> Suppose I have "data Foo = Foo { x :: [Int], y ::[Char] }; data Bar = Bar { x :: Int, y :: Char}". How do I given a Foo value calculate a "[Bar]" that is the cartesian product of the Foo value over all its fields (in this case, that's x & y)? I have 10 fields.
22:47:20 <jchia> I want to avoid boilerplate.
22:49:36 <ertes> > liftA2 (,) [1..3] [10,20,30]
22:49:38 <lambdabot>  [(1,10),(1,20),(1,30),(2,10),(2,20),(2,30),(3,10),(3,20),(3,30)]
22:49:42 <ertes> jchia: ^
22:49:48 <jchia> If the field types were all the same, I could put all the field values into a list and use sequence on it. But the field types are heterogeneous.
22:50:18 <jchia> ^ertes
22:50:30 <ertes> > liftA2 (,) [1..3] "abc"
22:50:32 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
22:50:32 <jchia> there's no liftA10, right?
22:50:49 <ertes> liftA2 f xs ys = f <$> xs <*> ys
22:50:55 <ertes> liftA3 f xs ys zs = f <$> xs <*> ys <*> zs
22:50:57 <ertes> etc.
22:50:58 <systemfault> With enough <*>, there are.
22:52:05 <ertes> jchia: alternatively just use a list comprehension
22:52:05 <jchia> OK, I can at least use an applicative approach. Bar <$> .. <*> .. <*> .. <*> ...
22:52:17 <ertes> [ f x y z | x <- xs, y <- ys, z <- zs ]
22:52:47 <ertes> the main difference is that in the applicative case you don't name the variables (unless you write a lambda)
22:53:09 <ertes> (\x y z -> f x y z) <$> xs <*> ys <*> zs
22:53:27 <jchia> ertes: Yeah, I think the applicative way is more succinct.
22:54:19 <ertes> usually if you know that the orders of the fields in Foo and Bar are compatible, the applicative variant is more succinct and also communicates the intent more directly
22:54:36 <ertes> so yeah, i'd go with (<*>)
22:55:44 <jchia> I'm wondering if there's some higher-level feature that doesn't involve TH so that I just need to give a list of field names to some high-level function.
22:56:13 <ertes> isn't that basically what you do with (<*>)?
22:57:00 <ertes> RecordWildCards can make this even shorter
22:57:15 <ertes> let Foo{..} = foo in Bar <$> x <*> y <*> z
22:57:26 <jchia> ertes: Sort of. I need to be careful about field order.
22:57:52 <ertes> jchia: one option would be to combine Foo and Bar into a single type
22:58:16 <ertes> data Foo f = Foo { fooX :: f Int, fooY :: f Char }
22:58:46 <ertes> then you can use Generic to turn Foo [] into Foo Identity mechanically
22:58:48 <ertes> err
22:58:50 <jchia> ertes: Sometimes I also want to project only some of the fields, maybe only take the first 1 or 2 fields out of ~10.
22:58:55 <ertes> then you can use Generic to turn Foo [] into [Foo Identity] mechanically
22:59:21 <ertes> cartesian :: (Applicative f) => Foo f -> f (Foo Identity)
22:59:50 <jchia> I'm been wanting to learn how to use Generic.
23:00:22 <ertes> jchia: in any case Applicative is the key
23:01:47 <jchia> Haskell has no facility for me to define a record type on top of another record type, right? E.g. I can't express a record type as the result of appending new fields to an existing record type.
23:02:07 <ertes> well, haskell has products
23:02:16 <ertes> (Record1, Record2)
23:02:52 <ertes> if you need something more flexible, there are extensible record systems for haskell like vinyl, but they are a pain to use
23:03:23 <jchia> ertes: Yeah, I took a quick look. Looks hairy.
23:07:10 <saurabhnanda> jchia: no, haskell doesn't
23:07:50 <saurabhnanda> jchia: the solution that we have found is the following -- generate one master record with all the fields that you need, and use TH to create type-level slices of that. Check out metamorphosis library and record-splicer library if this approach is acceptable to you.
23:08:31 <saurabhnanda> jchia: if your records are "short lived" then you can use the other approach, create a base record with the fields that all related records will have, and then use tuples for an ad-hoc way to say "this type is this record PLUS these two fields"
23:09:29 <saurabhnanda> jchia: I would not recommend any extensible records library for production-level use-cases a.t.m. We have spent a lot of time on this problem and the two approaches that I have outlines above ^^ are the only viable approaches that we found.
23:10:13 <saurabhnanda> jchia: curious, what's your actual domain-level problem?
23:12:09 <jchia> saurabhnanda: The simplified picture is that I have to calculate some complicated functions. Each function can be expressed as having inputs that are other complicated functions. I want to calculate the function values over a grid. Upstream functions have a subset of the parameters of downstream functions, hence the need for field projection.
23:12:30 <jchia> To be clear, not haskell functions
23:12:35 <jchia> you can think of them as math functions.
23:12:36 <saurabhnanda> jchia: wow, that was simplified? :)
23:12:54 <jchia> the non-simplified picture would involve job scheduling and other things :)
23:13:54 <saurabhnanda> okay, to rephrase: a function takes a bunch of params, and outputs something that is the input params PLUS some other data, which would then be getting piped to another function? is that correct?
23:13:55 <jchia> E.g. f(x, y, z) = i(g(x, y), h(x, y)).
23:14:14 <jchia> I have a grid for (x, y, z). I want to calculate f for the entire grid.
23:14:32 <saurabhnanda> is this the realistic size of your data fields? 2, 3, or 5?
23:14:39 <ertes> i'd actually prefer products honestly, because they are more algebraic and less ad-hoc
23:14:40 <saurabhnanda> if it is, then using tuples is not a bad solution.
23:14:41 <jchia> f, g, h are complicated functions that require computing jobs to calculate each point.
23:15:04 <jchia> realistic grid size is ~1e5
23:15:21 <jchia> ~10 params
23:15:22 <ertes> for example given a Foo1 and a Foo2, and a way to do cartesian products for both, there is an easy applicative way to do cartesian products for a product of them
23:15:41 <ertes> that's why i'd prefer tuples (or other product types) over anything else for the most part
23:15:57 <ertes> you just get a lot of stuff for free
23:16:07 <jchia> Correction: f(x, y, z) = i(g(x, y), h(x, y), z)
23:23:07 <jchia> ertes: If I use the tuple approach, I think I'll have to make different newtypes for the fields to guard against errors related to using the wrong position.
23:24:03 <jchia> saurabhnanda: I couldn't find the packages you mentioned. Do you mean https://github.com/maxigit/Metamorphosis and https://github.com/vacationlabs/record-splicer? Are they what you use?
23:29:52 <ertes> jchia: not really…  given (Foo f) and (Bar f), first you apply (cartesionFoo :: (Applicative f) => Foo f -> f (Foo Identity)) and (cartesionBar :: (Applicative f) => Bar f -> f (Bar Identity))
23:30:35 <ertes> then:  liftA2 (,) :: (Applicative f) => f (Foo Identity) -> f (Bar Identity) -> f (Foo Identity, Bar Identity)
23:30:39 <ertes> it's really natural
23:34:58 <sqooq> ertes: haha my code even had a really bad events to behavior function, it just took what amounted to [(Time,a)] and returned a stepwise function
23:35:07 <sqooq> now that I think about it
23:35:18 <sqooq> if I started to realize that events could be their own thing
23:35:24 <sqooq> would have simplified a lot
23:35:39 <ertes> sqooq: yeah, that's just 'hold' =)
23:35:46 <sqooq> in every other case, I actually had 2 functions defined
23:35:47 <sqooq> f
23:35:48 <sqooq> and f'
23:36:01 <sqooq> f' took an "event" or just a single number instead of a behavior itself
23:36:18 <sqooq> it's just that it took the event for every value
23:36:28 <sqooq> so it was more like the event was a constant valued behaviour
