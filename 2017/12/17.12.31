00:04:46 * hackage numhask-histogram 0.0.0.1 - See readme.md  https://hackage.haskell.org/package/numhask-histogram-0.0.0.1 (tonyday567)
00:22:41 <klntsky> I have a question related to MultiParamTypeClasses. Could anyone please give me an advice? https://pastebin.com/raw/AbE3mdDy
00:26:21 <amalloy> the compiler can't tell what type you want to use `b` at. in g'', for example, you tell the compiler that it must ensure that Two Int String is satisfied...but it already knows that's true, and it's not really related to your use of b, which could be for some other instance of Two
00:27:26 <amalloy> one way i think you could do something this would be to use TypeApplications, and then b @ Int String
00:29:19 <amalloy> alternatively, depending on what you are trying to do, you could use FunctionalDependencies to say that one of the parameter types forces the other. for example, you could say that b ~ String necessarily entails a ~ Int, and then the compiler doesn't have to worry about other possible overloads
00:41:08 <klntsky> I have defined g' and g'' using TypeApplications, but what about g? It seems strange to me that I can't define g equal to b while b is already defined and has exactly the same type.
00:44:24 <klntsky> AFAIK with FunctionalDependencies I will not be able to make b polymorphic (e.g. to allow coexisting instances for Int String and Int Char), right?
00:47:53 <amalloy> you can make either of them polymorphic but not both, with fundeps. a determines be, or b determines a
01:04:40 <platz> ghc warned me to use MonoLocalBinds so i did, but have no idea what it does
01:04:57 <platz> made the warnings go away at least
01:05:23 <platz> it involved class instances amd class constraints
01:05:34 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XMonoLocalBinds
01:05:35 <platz> never seem that warning before
01:08:30 <platz> the docs talk about let bindings but these were simple class instances with no bodies
01:39:12 * hackage setop 0.1.0.0 - Perform set operations on files.  https://hackage.haskell.org/package/setop-0.1.0.0 (fmind)
01:58:01 * hackage megaparsec 6.4.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-6.4.0 (mrkkrp)
01:58:51 <locusff> Mwlp
03:05:46 <younome> Can anyone here speak on the viability of using Haskell on embedded systems?
03:06:26 <younome> Or low level systems in general?
03:10:39 <JuanDaugherty> cray cray
03:29:29 <consus> Hi guys. Is there an existing way to strerror errno (say, from stuff in socket package) to text?
03:32:46 <ongy> The Haskell assembly at 34C3 was way to small and couldn't be found :( Next year we have to do better
03:35:24 <lassulus> the nixos assembly had similiar problems
03:37:51 <consus> ongy: > Two years ago, I was raped by a leader in the privacy/security community. The #CCC provided a supportive platform for him for years, and his abuse was not a secret.
03:37:56 <consus> Stay catchy
03:42:56 <ongy> hm?
03:43:13 <JuanDaugherty> e left
03:43:26 <ongy> ah, I was disconnected for a moment and didn't have the meta
03:57:15 * hackage movie-monad 0.0.4.0 - Plays videos using GStreamer and GTK+.  https://hackage.haskell.org/package/movie-monad-0.0.4.0 (lettier)
04:16:04 <klntsky> consus: does anybody provide any proof of the fact that the abuse wasn't a secret? Looks like an attack on the CCC community itself.
04:19:45 * hackage cue-sheet 1.0.1 - Support for construction, rendering, and parsing of CUE sheets  https://hackage.haskell.org/package/cue-sheet-1.0.1 (mrkkrp)
04:25:50 * hackage modern-uri 0.1.2.1 - Modern library for working with URIs  https://hackage.haskell.org/package/modern-uri-0.1.2.1 (mrkkrp)
04:36:18 <phadej> ryantrinkle: my backlog is growing during holidays, i'll try to go thru it early next year
04:46:48 <kakashiAL> is there a function in haskell that takes a function or variable and returns a string with the type signature
04:47:15 <kakashiAL> something like javascripts typeof OR is :t in the ghci the only way?
04:47:25 <vaibhavsagar> kakashiAL: I think :t in GHCi is the only way
04:47:51 <vaibhavsagar> do you have a use case for this?
04:48:00 <kakashiAL> vaibhavsagar: thanks :)
04:48:26 <kakashiAL> vaibhavsagar: just wanted to know ^_^
04:49:04 <hexagoxel> :t show . typeOf
04:49:05 <lambdabot> Typeable a => a -> String
04:49:19 <hexagoxel> > show (typeOf not)
04:49:21 <lambdabot>  "Bool -> Bool"
04:50:07 <hexagoxel> kakashiAL: it "breaks" for polymorphic stuff because of Typeable instance resolution, but otherwise seems what you want.
04:50:38 <kakashiAL> hexagoxel: so thats what you defined, right?
04:51:16 <kakashiAL> I dont understand it but I will try to parse it in my mind and come back later
04:51:34 <hexagoxel> what? i did not define anything there.
04:52:07 <Rembane> kakashiAL: Tutorial: http://chrisdone.com/posts/data-typeable
05:04:16 * hackage cgrep 6.6.20 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.20 (NicolaBonelli)
05:09:14 <sam__> is it possible to do a conditional trace? something like if i `mod` 1000 == 0 trace i else don't trace?
05:11:06 <hexagoxel> :t trace
05:11:07 <lambdabot> error: Variable not in scope: trace
05:11:57 <hexagoxel> sam__: yes. note that `trace "myString"` has the same type as `id`.
05:13:23 <yoho> i.e. you've pretty much already got it
05:13:53 <liste> @let trace :: String -> a -> a; trace _ = id
05:13:54 <lambdabot>  Defined.
05:14:21 * hackage setop 0.1.0.1 - Perform set operations on files.  https://hackage.haskell.org/package/setop-0.1.0.1 (fmind)
05:14:46 <hexagoxel> angerman: ping
05:14:49 <liste> :t \x -> if (x `mod` 1000) == 0 then trace "." x else x
05:14:50 <lambdabot> Integral p => p -> p
05:14:55 <termtim> Can somebody show me the steps to manually derive the type of `sequenceA $ fmap`? Clearly ($) has no effect on the type, but I can't see how to make meaningful progress by substituting `(a->b)->f a->f b` for `t(g p)` into `g(t p)`.
05:15:00 <angerman> hexagoxel: pong?
05:15:08 <rzhanka> I'm attempting to use the vector library. If I say: type Foo = V.Unbox Int; I get an error saying that this is an "Illegal constraint synonym of kind: 'Constraint'". What's going on here? How do I define a concrete type of vector?
05:16:24 <hexagoxel> angerman: ah, hi. i saw your "brick" discussion. I think it the kind of extensionality you are going for there is much easier with an FRP approach.
05:17:03 <angerman> hexagoxel: that doesn't preclude brick from having clean separation, does it?
05:17:15 <angerman> hexagoxel: or do you imply that I'm turning brick into an FRP then?
05:17:31 <glguy_> termtim: it doesn't
05:17:31 <hexagoxel> angerman: i wrote an FRP interface to brick already.
05:17:59 <angerman> hexagoxel: ahh that's what you mean. Yea I saw the brick + reflex. Not sure I'm following how the solution would look there though.
05:18:11 <angerman> hexagoxel: but please feel free to chime in on the ticket. that would be amazing!
05:18:32 <angerman> hexagoxel: and even it if it, using brick+reflex, this becomes a non-issue because ...
05:18:39 <termtim> glguy - can you elaborate. The answer I was hoping for was  step1, step2, voila `(Functor f, Traversable ((->) (a -> b))) =>      f a -> (a -> b) -> f b`
05:19:19 <glguy_> termtim: you left off the arguments to fmap, they matter,
05:19:19 <[exa]> hm, what is the best way to write a 'map' that also filters the elements based on whether they match a pattern?
05:19:21 <hexagoxel> angerman: yeah i am a bit cautious because my last interactions with the maintainer didn't end with a constructive result.
05:19:47 <termtim> glguy: ghci can do it
05:20:03 <angerman> hexagoxel: wow, how did you manage that? I've been pretty stupid on the brick and the vty issue tracker and never ran into an issue with him.
05:20:06 <yoho> [exa]: filter then map, map can't change the structure
05:20:11 <hexagoxel> jtdaugherty seems to be very protective of the current api. not saying that this is a bad thing entirely.
05:20:15 <glguy_> You're getting confused by $. Take it out and try again
05:20:29 <termtim> no, ($) changes nothing as I said, right?
05:20:37 <glguy_> No
05:21:05 <termtim> I am missing something
05:21:25 <termtim> sequenceA :: (Applicative f, Traversable t) => t (f a) -> f (t a)
05:21:25 <lavalike> termtim: fmap :: (->) ((a->b) -> f a) (f b) more easily unifies with sequenceA's first arg type
05:21:29 <glguy_> Yeah, it's sequence (fmap f x)
05:21:47 <angerman> hexagoxel: ahh, yea he is. It shines through in the discussion though.
05:22:12 <gopnikovitch> save
05:22:27 <angerman> hexagoxel: and yes, I believe it's his way. And that way seems to work quite well. brick and vty work, and have good to excellent documentation.
05:22:51 <termtim> and: ($) sequenceA   :: (Applicative f, Traversable t) => t (f a) -> f (t a)
05:23:19 <termtim> so why would the ($) make it any more likely to confuse?
05:23:26 <glguy_> termtim: yes, but you can't apply that to fmap
05:23:36 <termtim> ghci can
05:23:37 <hexagoxel> and my reflexive interface works, and it requires a forked brick.
05:23:52 <angerman> hexagoxel: ahh, I see.
05:23:59 <termtim> ($) sequenceA fmap   :: (Functor f, Traversable ((->) (a -> b))) =>      f a -> (a -> b) -> f b
05:24:05 <angerman> hexagoxel: well, maybe one just need to argue ones way into it.
05:24:07 <angerman> :D
05:24:22 <sam__> hexagoxel: ah yeah, thanks. should have been able to figure that out.
05:24:37 <glguy_> termtim: yeah, you get that nonsense type, is your question just asking why?
05:25:00 <termtim> well, why is that a nonsense type?
05:25:26 <termtim> it looks like flip fmap
05:25:29 <glguy_> a -> b is (->) a b
05:25:35 <termtim> OK
05:26:39 <yoho> > let f a x = sequenceA $ fmap
05:26:41 <lambdabot>  <no location info>: error:
05:26:41 <lambdabot>      not an expression: ‘let f a x = sequenceA $ fmap’
05:26:51 <glguy_> It's useless because of the Traversable constraint you get
05:26:52 <yoho> dammit lambdabot
05:27:17 <termtim> OK, so it is technically correct but unrealisable with real values
05:27:25 <yoho> @let f a x = sequenceA $ fmap
05:27:26 <lambdabot>  .L.hs:164:1: error:
05:27:26 <lambdabot>      Multiple declarations of ‘f’
05:27:26 <lambdabot>      Declared at: .L.hs:161:1
05:27:36 <yoho> @let nons a x = sequenceA $ fmap
05:27:37 <lambdabot>  Defined.
05:28:04 <yoho> I suppose it makes sense lambdabot has more stuff enabled than my ghci does
05:28:52 <termtim> OK, let's try a less nonsensical question; what are the steps to derive the type with the fmap args included?
05:29:25 <termtim> :t sequenceA
05:29:26 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
05:29:58 <termtim> now how do we do the next step?
05:30:52 <yoho> go right to left, not left to right
05:30:59 <termtim> assume [] for t if it makes it easier
05:31:17 <yoho> fmap a b is done first, so figure out the type of that, then figure out the type after sequenceA
05:31:57 <JuanDaugherty> hexagoxel, jtdaugherty is constrained by being a galois employee
05:33:18 <termtim>  the individual components are OK. I am just missing the manual technique for substituting into  t (f a) -> f (t a)
05:33:52 <yoho> I'm not understanding your issue
05:34:10 <termtim> I see are we saying that (->) becomes the t?
05:35:42 <termtim> I think the question would be easier to understand if I just say: can somebody please show me the steps to derive the type of traverse as defined using sequenceA and fmap
05:35:44 <termtim> ?
05:35:53 <termtim> is that more understandable?
05:36:36 <mniip> :t \f -> sequenceA . fmap f
05:36:37 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a2) -> t a1 -> f (t a2)
05:36:43 <mniip> termtim, you mean this one?
05:36:46 <hexagoxel> JuanDaugherty: if that was relevant, it might help a lot if he mentioned it in issues/PR discussions.
05:37:19 <termtim> mniip : exactly. How would I derive that from the definition in terms of sequenceA and fmap
05:37:20 <JuanDaugherty> lol
05:38:07 <mniip> termtim, gimme a minute
05:38:48 * hackage mmark 0.0.4.1 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.4.1 (mrkkrp)
05:39:21 <termtim> mniip: sure, thank you.
06:01:25 <mniip> termtim, http://lpaste.net/1261037097146384384
06:03:10 <u0_a193> Happy new year coders...
06:03:17 <termtim> so your f :: i -> j
06:03:54 <termtim> very nice, thank you.
06:06:34 <termtim> mniip: so, iiuc (from what glguy wrote), is it not possible to derive `sequenceA . fmap` (ie without the f) in a way which is meaningful?
06:07:21 <termtim>  :t sequenceA . fmap
06:08:26 <mniip> I think that's going to end up in an unsatisfiable constraint
06:08:27 <mniip> :t sequenceA . fmap
06:08:28 <lambdabot> (Applicative f, Traversable ((->) (f a1))) => (a1 -> a2) -> f (f a1 -> a2)
06:08:30 <mniip> ah
06:08:32 <mniip> worse
06:12:26 <termtim> it's the 2nd constraint that initially got me wondering how I would derive that myself
06:16:06 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/hw/10-applicative.pdf
06:16:15 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/extras/10-applicative/AParser.hs
06:16:23 <butterthebuddha> Can someone help me with Ex 3?
06:18:15 * hackage ploton 1.1.1.0 - A useful cli tool to draw figures  https://hackage.haskell.org/package/ploton-1.1.1.0 (ishiy)
06:18:49 <mniip> termtim, all required steps of the process are in the paste
06:18:57 <mniip> you can derive that type by yourself
06:19:07 <mniip> just keep in mind that
06:19:09 <mniip> a -> b
06:19:10 <mniip> is just
06:19:12 <mniip> (->) a b
06:20:30 <ggVGc> I'm confused
06:20:39 <ggVGc> I've never seen (->) like that in a constraint
06:20:47 <ggVGc> not sure I understand what it's saying
06:20:48 <termtim> mniip: your derivation is very helpful, thank you. Perhaps a better place to start for newbs is to fix the types in fmap to something like fmap (show) (Just '1') and then apply sequenceA to that, when f is then [] and t is Maybe. Much simpler.
06:21:32 <termtim> I suspect that's what yoho & glguy where pushing me towards
06:21:59 <mniip> I've missed that part of the conversation
06:22:15 <yoho> that was indeed what I was going for
06:22:23 <glguy_> ggVGc: (->) is just another type
06:22:23 <mniip> well anyway the trick is that the haskell compiler itself undergoes a very similar process
06:22:40 <yoho> mniip's generally much more knowledgeable/comprehensive than I am though :P
06:22:51 <mniip> so by replicating it in your mind you comprehend the typechecking process
06:22:57 <mniip> typechecking *and* type inference
06:23:14 <butterthebuddha> Uhm, can someone help me?
06:23:38 <liste> butterthebuddha: what trouble you have with ex3?
06:23:49 <termtim> that was partly the point, and also that 2nd constraint piqued my interest
06:24:21 <butterthebuddha> So, obviously I need to use the << char 'a' >> and the << char 'b' >> parsers
06:24:33 <termtim> mniip: it's great the way you reduce the constraints, in your paste, as well - that is the bit I had not seen before.
06:24:36 <butterthebuddha> and obviously this involves applicative functors
06:24:48 <butterthebuddha> But I'm not sure how to put it together
06:25:21 <butterthebuddha> Is the mapping function gonna be of type << Char -> Char -> (Char, Char) >>?
06:26:35 <Ulrar> Is there an easy way to parse "1-3" into 1 and 3 ? I tried with reads but looks like I can't have it parse three types
06:29:13 <ski> > [(m,n,s3) | let s0 = "1-3",(m,s1) <- (reads :: ReadS Int) s0,("-",s2) <- lex s1,(n,s3) <- (reads :: ReadS Int) s2]
06:29:14 <lambdabot>  [(1,3,"")]
06:29:45 <ski> > [(m,n) | let s0 = "1-3",(m,s1) <- (reads :: ReadS Int) s0,("-",s2) <- lex s1,(n,s3) <- (reads :: ReadS Int) s2,("","") <- lex s3]  -- if you want to check that there's no junk at the end
06:29:47 <lambdabot>  [(1,3)]
06:29:56 <ski> Ulrar : does that ^ work ?
06:30:11 <lavalike> :t lex
06:30:12 <lambdabot> ReadS String
06:30:39 <ski> > [(m,n,s3) | let s0 = "  -1 - -3  ",(m,s1) <- (reads :: ReadS Int) s0,("-",s2) <- lex s1,(n,s3) <- (reads :: ReadS Int) s2]
06:30:41 <lambdabot>  [(-1,-3,"  ")]
06:31:58 <ski> (if you want to require wrapping brackets in the case of negative numerals, you can use `readsPrec p' instead of `reads', with a high enough `p' (`6' or something ?)
06:32:01 <ski> )
06:32:18 <mniip> termtim, yeah if you're not familiar with this syntax, a~b means "types a and b are equal"
06:32:24 <mniip> it binds more loosely than ->
06:32:33 <mniip> a -> b ~ c meaning (a -> b) ~ c
06:33:23 * ski would possibly have preferred `<=' over `=>'
06:33:46 <ski> (or `<=>')
06:34:06 <mniip> the spaceship operator?
06:34:20 <butterthebuddha> Uhm
06:34:28 <ski> well, logical equivalence
06:36:06 <ski> (when solving an equation / equation system. then "equation => solution" means that we're found all solutions, but there may be false solutions among them, "equation <= solution" means that the solutions we've found are all true ones, but we may have missed some. and with "<=>" we get all and only true ones)
06:40:11 <u0_a193> How to makw
06:40:36 <u0_a193> *How to install haskell in terminal. Anybody know?
06:42:41 <Ulrar> ski: That does work, but I'm not sure I get how. How would I handle parsing failure with that ?
06:43:00 <Ulrar> case and plan for [] maybe ?
06:44:46 <Ulrar> Looks like that's it
06:45:09 <Ulrar> Well that's great, thanks ! I'll go take a look at the doc for lex, try to understand how that works
06:47:20 * hackage cgrep 6.6.22 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.22 (NicolaBonelli)
06:47:54 <ski> Ulrar : yes
06:48:24 <ski> `lex' reads the next (Haskell-syntax) lexical token, iirc
06:49:50 * hackage texbuilder 0.1.3.0 - View your latex output while editing  https://hackage.haskell.org/package/texbuilder-0.1.3.0 (xaverdh)
06:50:14 <cocreature> do we have a nice package for n-bit words?
06:50:36 <ski> > lex "(1,2)"
06:50:38 <lambdabot>  [("(","1,2)")]
06:50:55 <ski> > unfoldr (\s -> case lex s of [("","")] -> Nothing; [(t,s)] -> Just (t,s)) "(1,2)"
06:50:57 <lambdabot>  ["(","1",",","2",")"]
06:53:19 <termtim> mniip: yes, I use ~, but thanks for emphasising the precedence. ski, the implies/iff comment also makes sense, thanks.
06:55:09 <butterthebuddha> Um, can some help me with ex 3 here?
06:55:14 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/hw/10-applicative.pdf
06:55:19 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/hw/10-applicative.pdf
06:55:24 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/extras/10-applicative/AParser.hs
06:56:14 <butterthebuddha> I think the function I use to map over char 'a' and char 'b' has to be of type Char -> Char -> (Char, Char) but I'm confused because the Parser itself stores a function
07:04:44 <PiotrJander> I tried installing a package with stack but needed to install external dependencies manually with the package manager brew. Quite annoying since installation would break very time there was a package missing. Is there a way to install all external deps using brew automatically?
07:05:10 <PiotrJander> or apt-get etc, same thing I guess
07:06:18 <kadoban> PiotrJander: You can use nix, stack has some integration with that. Though I don't know how it works so much.
07:06:40 <kadoban> Typically haskell packages have pretty few C library dependencies, if it helps.
07:07:56 <PiotrJander> kadoban: Yup I knew nix could do it, I just suppose that using nix would be a deep dive
07:11:26 <geekosaur> stack can't operate your package manager for you, no. in particular, it can't know what package names are needed
07:13:55 <matsurago> why haskell packages depend on non-haskell code in the first place?
07:14:22 <Phyx-> is.. that a trick question?
07:14:25 <cocreature> because there is existing software not written in haskell?
07:16:03 <geekosaur> because nobody wants to reimplement gtk3 in haskell
07:16:17 <geekosaur> (for onbe very large example)
07:16:30 <matsurago> is it really packages from hackage depend on some C libs?
07:17:00 <geekosaur> if you have existing C libraries that are fast and work well, why do you want to reimplement them? other than because you have more free time than sense?
07:17:45 <matsurago> somehow java, swift and others manage to work without them
07:17:54 <matsurago> I mean, it's really unwise
07:18:10 <geekosaur> libz is a good example here. it *can* be reimplemented (and I think has been) but it'd be a lot slower and stupider, and likely require a fair amount of debugging. working, fast, thoroughly tested libraries are a plus
07:18:34 <cocreature> hf reimplementing all of llvm rather than reusing what other people have built
07:19:17 <geekosaur> no, I forgot this is the current hot religion. I think go is doing the same thing: reimplement from scratch with all your own bugs and misfeatures rather than commit the sin of reuse
07:19:41 <matsurago> at least it does not bring dependency hell to devs
07:19:42 <ahihi> java and swift both have facilities to work with C libraries
07:19:44 <geekosaur> maybe in a decade sanity will return
07:19:54 <cocreature> go does have a C ffi as well afaik
07:20:13 <geekosaur> (well, no, it'll just find a different way to be insane, again. that's how it's always worked...)
07:20:46 <kadoban> matsurago: In practice it's a list of libraries I need to install manually for large haskell packages that are pretty easy to do. It's like 5 extra minutes of "type a couple of things, then wait". It's far from hell.
07:20:59 <matsurago> I mean, in java I can use maven to get any third-party library without being concerned about some missing C libs of particular versions
07:21:52 <kadoban> Or if you're so inclined, there's nix, either via stack or on its own.
07:22:31 <matsurago> I am just learning ecosystem now...
07:23:43 <Phyx-> 15:17:23 < matsurago> somehow java, swift and others manage to work without them <--- this is just wrong
07:23:44 <matsurago> I am sure python reuses a lot of C code, but it doesn't require manual C lib dependency management either
07:24:13 <geekosaur> it does if it's binding to anything not in a default Linux install
07:24:25 <Athas> matsurago: I've had plenty of issues with Python libraries requiring me to install C libraries, actually.
07:24:31 <Athas> It's hard to avoid that in any language.
07:24:31 <cocreature> python requires about as much manual C lib management as Haskell does
07:25:38 <Athas> I think the only thing that can be realistically solved is that Stack should complain up-front about missing C libraries.
07:25:46 <Athas> That is still difficult to do, but at least technically feasible.
07:26:41 <[Leary]> butterthebuddha—you're pretty much at the solution, why not pull out a function with that signature and see what it does? You can go through the execution on pen and paper afterwards if you aren't sure why it works.
07:27:35 <Phyx-> I thought as part of package registration Cabal already did C dependency checks
07:27:45 <Phyx-> so stack should have inherited that
07:28:55 <butterthebuddha> [Leary]: I'm very confused - what is the function gonna do in the context of Parsers?
07:33:21 <Athas> Phyx-: I think it doesn't do the check until it starts building the package in question.
07:33:35 <Athas> does Cabal support C dependency checking for packages that have missing Haskell dependencies?
07:35:08 <[Leary]> Like you said, you're going to map it over char 'a' and char 'b', right? This isn't the solution, but you can literally do, e.g. fmap f (char 'a'). Maybe rereading the exposition in the previous exercise will help.
08:03:26 <huss`> Hey guys I would like to know, are functions like foldl using F-algebra behind the scene ?
08:11:39 <AndreasK> huss`: Not familiar with F-algebras but iirc at least the sources don't refer to it. But you can check the source on hackage for yourself
08:14:46 <nshepperd> huss`: foldl can be written in terms of foldr
08:14:51 <nshepperd> so, yes, sort of
08:14:55 <huss`> AndreasK: not good enough for that, just wanted to know (i'm learning F algebra)
08:16:26 <huss`> nshepperd: by f alg i meant using the Data.Functor.Foldable
08:17:49 <nullie> @src foldl
08:17:49 <lambdabot> foldl f z []     = z
08:17:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:18:42 <nshepperd> foldl f z xs = foldr (\x k acc -> k (f acc x)) id xs z
08:19:41 <nshepperd> huss`: no, they're not written using that
08:20:05 <nshepperd> but they could be, and it would be equivalent to the foldr definition
08:20:20 <huss`> nshepperd: equivalent yet but as effective ?
08:20:57 <AndreasK> https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Foldable.html#foldl
08:25:21 <huss`> Bartosz said that F algebra are better in terms of performance because it transform recursive code to non recursive
08:25:39 <huss`> That's why I wondered if foldl etc were implemented this way
08:25:42 <nshepperd> cata = foldr for lists
08:25:51 <huss`> yep
08:26:14 <ryantrinkle> phadej: awesome, thanks!
08:26:17 <huss`> thanks guys
08:27:33 <nshepperd> foldr is also good for performance because then you can buildr/foldr fusion
08:29:54 * hackage phoityne-vscode 0.0.20.0 - Haskell Debug Adapter for Visual Studio Code.  https://hackage.haskell.org/package/phoityne-vscode-0.0.20.0 (phoityne_hs)
08:47:25 <Average-user> How can I update multiple values of a map?
08:47:28 <Average-user> Map*
08:47:40 <Gurkenglas> Average-user, request a type signature
08:48:09 <Average-user> Gurkenglas: Don't know what you mean
08:49:08 <Gurkenglas> If you had asked "How can I modify all elements of a map using a given function?", the corresponding type signature would have been "Ord k => (a -> a) -> Map k a -> Map k a"
08:50:06 <Gurkenglas> (no Ord required in that specific case, I suppose)
08:51:39 <Gurkenglas> Average-user, if you use the language of types to ask your question, my answers are more likely to be what you want.
08:52:33 <yoho> and you can also use them to search hoogle and get the answer yourself
08:53:35 <Gurkenglas> and, ideally, you could ask exferenceBot for any but the most insight-requiring questions of this sort.
08:54:14 <yoho> we're still working on GurkenglasBot to replace this part of the conversation too
08:55:01 <Average-user> Ord k => (a -> a) -> [k] ->  (Map k a)  -> (Map k a)
08:55:16 <Average-user> hoogle just gives adjust, but isn't what I want
08:55:20 <Gurkenglas> (hoogle/hayoo work for types that are correctly specialized to a type as it is written in docs, djinn works for types constructed from simple type operators such as (->))
08:56:04 <huss`> Average-user: Data.Map.map ?
08:56:43 <Average-user> huss`: but I only want to update values that have keys in  [k]
08:57:13 <huss`> So, mapWithKey ?
08:57:14 <lavalike> :t Data.Map.union
08:57:15 <lambdabot> Ord k => M.Map k a -> M.Map k a -> M.Map k a
08:57:29 <yoho> mapWithKey
08:57:38 <yoho> then only perform the mapping when the key matches
08:58:03 <Gurkenglas> :t \f -> foldr (.) id . map (M.adjust f) -- Average-user
08:58:04 <lambdabot> Ord k => (a -> a) -> [k] -> M.Map k a -> M.Map k a
08:58:04 <huss`> mapWithKey (\k v -> if (elem k keys) f v else v) m
08:58:22 <Gurkenglas> Updates one key after the other, using (length ks) * log(n) time
08:58:42 <Gurkenglas> mapWithKey takes linear time in the size of the map
08:58:49 <yoho> yeah, that's the better solution
08:58:54 <huss`> foldr yep
08:58:59 <huss`> thanks Gurkenglas
08:59:19 <Average-user> thanks
08:59:24 <mox> I used Haskell for a few advent of code things exercises last year, but I haven't really found a use case for it with normal scripting things. Most of the times python/go/rusts fill my needs better. Haskell is so cool though
09:00:01 <Gurkenglas> Average-user, there should be another one that's asymptotically even a little better, but somewhat more complicated
09:00:02 <huss`> mox: useful for scripting parsers for reading logs etc
09:00:27 <huss`> Gurkenglas: please give the advice
09:01:42 <mox> huss`: more useful than Python?
09:02:38 <huss`> mox: I find it easier with a typed language anyway
09:02:55 <huss`> mox: and when my parser compiles i'm almost sure that it works :D
09:04:04 <mox> Hmm, that's true
09:04:34 <mox> Maybe I should revisit it one day
09:05:25 <Gurkenglas> :t \f -> Data.Map.Internal.merge (error "uncontained key") Data.Map.Internal.preserveMissing (Data.Map.Internal.zipWithMatched $ \k () x -> f x) . M.fromList . map (,()) -- huss`
09:05:26 <lambdabot> Ord k => (c -> c) -> [k] -> M.Map k c -> M.Map k c
09:05:57 <huss`> Gurkenglas: impressive thanks
09:09:39 <Gurkenglas> :t alaf Endo foldMap . M.adjust -- huss`, here's a pretty one if you're into lens
09:09:40 <lambdabot> (Ord a1, Foldable t) => (a2 -> a2) -> t a1 -> M.Map a1 a2 -> M.Map a1 a2
09:11:23 <huss`> Gurkenglas: having notions about it but you're missing me here :P
09:17:23 <Gurkenglas> Oh, turns out http://hackage.haskell.org/package/containers-0.5.10.2/docs/src/Data.Map.Internal.html#mergeA is strict in the strategies, the call to error will have to be wrapped in Data.Map.Internal.mapMissing or something
09:19:03 <Gurkenglas> Should we make the strategy arguments lazy?
09:28:39 <ezyang> Does anyone have a good recipe for 'assert but with a string message'
09:29:13 <Gurkenglas> ezyang, https://hackage.haskell.org/package/safe
09:39:33 <ezyang> euh, I want to write my own asserts?
09:42:00 <ezyang> never mind, I'll crib something from GHC :)
09:43:22 <MarcelineVQ> ezyang: he's probably referring to assertNote just in case you missed that in Safe
09:46:09 <ezyang> aha!
09:53:25 <Gurkenglas> ezyang, I do recommend you try to see if you can use, say, fromJustNote in place of assertNote, because of boolean blindness.
09:54:35 <Handle_> Hello!      Using the holidays to look into Haskell. Very nice to 'broaden the horizon'.        I have a question about GHC/toolchain.
09:56:40 <Handle_> I have some legacy operating systems running (both as physical and as virtual machines).        Say I want to have a haskell program to run on OS/2, will it work if I compile to C code and then compile that to an OS/2 executable?
09:56:59 <Handle_> Or will things like the RTS throw a spanner in the works?
10:12:24 <dubstep> What's the best way to listen 5 songs from youtube without hogging my laptop?
10:18:02 <[exa]> Handle_: wow, why OS/2 ?
10:19:03 <[exa]> Handle_: btw if OS/2 can provide similar low-level api as unixes/windowses, you shouldn't have much trouble porting it. except maybe executable formats
10:19:47 <monochrom> w00t OS/2
10:22:04 <monochrom> There is https://en.wikipedia.org/wiki/EMX_(programming_environment) for providing posix. On top of it, people have already ported gcc. Maybe you can start from there.
10:22:53 <[exa]> I insist on answering "why tho"
10:23:04 <monochrom> I know because I used it many years ago! Was a happy user.
10:26:06 <monochrom> Oh oh I have a cunning plan! Inside OS/2, run Windows 3. Maybe it can run exes made by GHC Windows version. #XYProblem #RubeGoldbergMachine
10:27:06 <[exa]> ok 2018 resolutions time
10:27:25 <monochrom> heh
10:27:26 <[exa]> write a workign haskell OS so that people can stop thinking about OS/2 and pals
10:27:35 <yoho> lol
10:27:36 <Phyx-> well, if you have a C compiler, you can build an unregistered backened for GHC and port it to OS/2
10:27:47 <Phyx-> you'll have to fill in the API gaps as you go through
10:28:02 <Phyx-> particularly, I doubt the RTS will work as is..
10:28:09 <monochrom> The only problem with OS/2 is that 32-bit is so 2017. :)
10:28:30 <doyougnu> ^^
10:29:03 <yoho> in my timezone that means you've got about 5 and a half hours to do whatever it is you want to do
10:29:06 <yoho> quick!
10:29:25 * hackage cabal-bounds 1.4.0 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-1.4.0 (DanielTrstenjak)
10:34:50 <Handle_> OS/2 was just an example. (Some things still run, so if it ain't broke ... : ) But I have made Virtual Machines of all OSes I have install media for. I was wondering if I could compile haskell to C and then use (open)Watcom to compile to executables.
10:35:42 <Handle_> Seems I can, but not easily. So I will look into that later. Will focus first on haskell itself.         Was mostly just wondering if it was possible.
10:35:45 <[exa]> well I guess you can compile it to javascript using GHCJS
10:36:15 <[exa]> also, there are some (older) haskell compilers that could be bootstrapped using C only (was it hugs or the other one?)
10:36:32 <glguy> Hugs isn't a compiler
10:36:58 <glguy> (so probably the other one)
10:38:21 <[exa]> was it utrecht?
10:38:31 <AndreasK> I think you can compile hugs from c, and interpret another haskell compiler with it then
10:41:37 <[exa]> Handle_: also maybe this https://ghc.haskell.org/trac/ghc/wiki/CrossCompilation
10:45:46 * hackage cabal-lenses 0.7.0 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.7.0 (DanielTrstenjak)
10:47:53 <monochrom> Bootstrapping GHC by Hugs?! Why haven't I thought of that :)
10:48:07 <AndreasK> https://elephly.net/posts/2017-01-09-bootstrapping-haskell-part-1.html
10:48:26 <Handle_> [exa]: Thanks. I had this: https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/code-generators.html which shows it is possible, but not something you could just attempt without being familar with the whole toolchain.
11:06:00 * hackage cabal-bounds 1.5.0 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-1.5.0 (DanielTrstenjak)
11:19:17 * hackage entropy 0.4 - A platform independent entropy source  https://hackage.haskell.org/package/entropy-0.4 (ThomasDuBuisson)
11:28:12 <amalloy> can someone explain to me what the deal is with the phantom (i think?) type variable 's' in ST s a? i understand it's somehow related to not allowing mutable things like STRef from escaping an ST computation but i don't quite get how that works
11:32:25 <monochrom> The other half you need is "runST :: (forall s. ST s a) -> a" as the only way to get anything useful out of ST.
11:33:02 <monochrom> such that if you attempt "runST (newSTRef True)" the forall will stop you.
11:33:25 <monochrom> and there is nothing else you could try.
11:37:21 <monochrom> But try a combination of unsafeSTToIO and unsafePerformIO to circumvent it. :)
11:52:46 * hackage successors 0.1.0.1 - An applicative functor to manage successors  https://hackage.haskell.org/package/successors-0.1.0.1 (JoachimBreitner)
11:57:38 <sqooq> why is "round" choosing to convert to Integer rather than Int?
11:58:22 <sqooq> hmm nevermind
12:06:29 * hackage hledger-lib 1.5 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.5 (SimonMichael)
12:07:54 * hackage hledger-ui 1.5, hledger 1.5, hledger-web 1.5 (SimonMichael): https://qbin.io/7dc2amiuh
12:09:41 * hackage hledger-api 1.5 - Web API server for the hledger accounting tool  https://hackage.haskell.org/package/hledger-api-1.5 (SimonMichael)
12:21:34 <ezyang> MarcelineVQ: assertNote is apparently still not what I want, because I want something that respects -fignore-assert
12:52:02 <EvanR> amalloy: it stops you from using ST actions from one state thread in another
12:52:19 <EvanR> and accessing the wrong implicit state, leading to chaos
12:52:51 <EvanR> if you try, the two s variables will not unify
12:53:19 <royal_screwup21> what's the difference between "$" and "."?
12:53:32 <EvanR> function application vs function composition
12:53:40 <EvanR> @src ($)
12:53:40 <lambdabot> f $ x = f x
12:53:49 <EvanR> @src (.)
12:53:49 <lambdabot> (f . g) x = f (g x)
12:54:26 <royal_screwup21> say I do: sum $ map (+3) [1,2,3]
12:54:29 <EvanR> f $ x is the return value of f appied to x, f . g is still a function
12:54:45 <royal_screwup21> that's essentially doing f (g (x)), correct>
12:55:04 <EvanR> not really because you applied map to 2 args
12:55:15 <EvanR> its essentially f (g x y)
12:55:44 <royal_screwup21> hmm
12:56:01 <royal_screwup21> what's a super simple example demonstrating function composition?
12:56:17 <EvanR> (sum . map (+3)) [1,2,3]
12:56:56 <royal_screwup21> ah okay
12:56:58 <EvanR> > map ((+1) . ord) "hello"
12:57:00 <lambdabot>  [105,102,109,109,112]
12:57:01 <huss```> guys, I would like to wrap a monoid with a monad and compose them
12:57:32 <huss```> how could I compose something m Monoid with n Monoid
12:57:52 <EvanR> royal_screwup21: composition tends to make refactorings easier, it pays to get an intuitive feel for it. start with the type signature of (.)
12:58:16 <EvanR> (b -> c) -> (a -> b) -> (a -> c)
12:59:04 <royal_screwup21> and the type of ($) is: (a -> b) -> a -> b
13:00:01 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/hw/10-applicative.pdf
13:00:02 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/extras/10-applicative/AParser.hs
13:00:07 <butterthebuddha> https://gist.github.com/anonymous/075c19526c3b3be36375655e4bc8c7fe
13:00:08 <EvanR> $ is really just identity... its only used (or abused) to avoid parentheses sometimes
13:00:35 <butterthebuddha> ^ Can someone help me figure out what's going wrong with my instance of Parser's applicative?
13:00:49 <EvanR> > (+1) `id` 9
13:00:51 <lambdabot>  10
13:01:12 <EvanR> it avoids parens because of its extra low precedence
13:01:59 <EvanR> but a chain of $ is bad style imo
13:02:17 <infinisil> and a chain of (.) is better?
13:02:21 <EvanR> yes
13:04:42 <glguy> butterthebuddha: line 9 of https://gist.github.com/anonymous/075c19526c3b3be36375655e4bc8c7fe is wrong
13:05:43 <butterthebuddha> glguy: Hmm, what should it be?
13:07:05 <monochrom> "x $ y $ z $ t" is another syntax for "x (y (z t))". "x . y . z" is a semantics change, it means you're now thinking in terms of pipelines. This is not even a style change.
13:09:05 <EvanR> its a style change if you change x $ y $ z $ t to (x . y . z) t then its a style change
13:09:34 <glguy> butterthebuddha: You'd probably learn more if you ponder what pure should do than if I just told you
13:09:42 <EvanR> and so on ad infinitum
13:09:48 <EvanR> etc
13:10:19 <butterthebuddha> If it's supposed to be the minimum context, the only thing that's more "minimum" that I can think of is Nothing
13:10:27 <butterthebuddha> But that wouldn't be putting x in a context
13:10:42 <glguy> butterthebuddha: I don't know what context means, think about it in terms of parsers
13:10:56 <glguy> (pure x) is the parser that...
13:11:21 <butterthebuddha> parses a value of type the type of x?
13:11:52 <glguy> and you'll be limited by the fact that: pure id <*> p === p
13:12:56 <glguy> parsers have about three interesting aspects, how much of the input string they use up, and what value they return, and if they succeed at doing that
13:13:54 <EvanR> type Parser x = (Int, Maybe x) ? :)
13:14:34 <EvanR> Maybe (Int, x)
13:15:24 <nullie> you also need remaining string
13:16:04 <EvanR> pure x = Just (0,x)
13:16:21 <EvanR> dont listen to me
13:17:54 <nyberg> newtype Parser a = Parser (String -> Maybe (a, String))
13:18:21 <butterthebuddha> Do I just return the entire string?
13:18:31 <butterthebuddha> Instead of the empty string?
13:19:16 <butterthebuddha> the entire input string
13:19:25 <glguy> and make a parser that consumes none of the input and always succeeds by returning the argument to pure as the result?
13:20:04 <butterthebuddha> I don't see how I can "parse" the input when I don't know it's type
13:20:07 <butterthebuddha> s/it's/its
13:21:13 <EvanR> in pure x, the x is already given and doesnt derive from the string input
13:21:24 <EvanR> you dont need to know, and cant know its type
13:32:16 <huss```> Guys I have a monoid wrapped into different monads
13:32:57 <huss```> m mymonoid, Identity mymonoid, i would like to combine that into m (mappend mymonoid mymonoid)
13:33:13 <huss```> is that possible ?
13:34:13 <platz> still trying to understand this warning http://lpaste.net/361239 . i can fix it with MonoLocalBinds but not sure what is does because the ghc users guide talks about let bindings, where i have none (just classes and instances)
13:35:01 <platz> basically there's a class constraint, and any number of instances could be selected to satisfy it
13:40:50 <glguy> platz: The instance in the warning message already satisfies the constraint
13:41:49 <monochrom> It is simplifiable to "MimeType mtype"
13:42:09 <monochrom> I do not know how MonoLocalBinds is involved either.
13:43:02 <monochrom> Oh, "this makes ... for inner bindings fragile" emphasis on "inner bindings".
13:43:06 <platz> ah, yes the simpmlification makes sense due to the defintion of Consumes
13:43:14 <platz> but yeah didn't understand the fagile part
13:44:00 <monochrom> So MonoLocalBinds kills polymorphism in inner bindings and therefore sidesteps class constraints completely.
13:44:50 <monochrom> But now I don't know why the emphasis is on inner bindings as though top-level bindings are fine.
13:45:25 <monochrom> And what's fragile about it, unless there is also IncoherentInstances
13:45:47 <monochrom> or UnthinkablyOverlappingInstances
13:46:22 <platz> nope just flexibleinstances
13:46:35 <platz> & flexiblecontexts
13:47:22 <monochrom> I guess "fragile" doesn't mean there is a problem right now, it just means there can be problems if you also turn on other extensions.
13:47:32 <platz> it seems to work with monolocalbinds , i'll just use that i guess
13:47:38 <butterthebuddha> Okay, so I figured the applicative out
13:47:45 <butterthebuddha> But I don't understand why this parser doesn't work: https://gist.github.com/anonymous/394c3dde0e5b6b19d1ec55846b4b5775
13:48:08 <monochrom> But hey this warning is new in 8.2 :)
13:48:35 <monochrom> But the example "Eq [a]" in the user guide is rather dull.
13:48:47 <platz> what did you mean by MonoLocalBinds "kills class constraints?"
13:49:05 <monochrom> It kills polymorphism altogether.
13:50:26 <monochrom> .h rather than .hs ?!
13:50:37 <platz> maybe i better just simplify the constraint in this case because that sounds like something that could affect users
13:51:43 <monochrom> I don't know what's Parser and what's posInt so there is nothing wrong in the gist.
13:51:50 <[Leary]> butterthebuddha—iirc posInt processes all successive digit characters to return one Integer. If that's true, when what's the second posInt parser going to see?
13:52:05 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
13:52:17 <butterthebuddha> [Leary] I just realized that the second parser sees a leading space
13:52:21 <butterthebuddha> which returns nothing
13:59:28 <ReinH> butterthebuddha: FYI, pure f <*> fx = f <$> fx is an applicative law
13:59:36 <butterthebuddha> http://lpaste.net/361240
13:59:41 <butterthebuddha> ^ Is there a way to abbreviate that?
14:01:03 <monochrom> look for "pattern guards".
14:08:16 * hackage bcrypt 0.0.11 - Haskell bindings to the bcrypt password hash  https://hackage.haskell.org/package/bcrypt-0.0.11 (AndrewMiller)
14:12:06 <butterthebuddha> Is there any way to use the alternative type to string together parsers of different type?
14:13:57 <monochrom> How do you mean?
14:14:32 <butterthebuddha> Something like f<|>g where f is an integer parser and g is a character parser>
14:15:15 <monochrom> No. But it's the same reason "if b then 5 else 'x'" is rejected.
14:15:27 <monochrom> But you can always get Either involved.
14:15:29 <hydraz> (Left <$> f) <|> (Right <$> g)
14:15:40 <monochrom> Yeah, like that.
14:40:53 <[Leary]> butterthebuddha—Just BTW, if you're still doing the 10th CIS194 assigment you can refactor to avoid needing that.
14:42:15 * hackage hledger-irr 0.1.1.13 - computes the internal rate of return of an investment  https://hackage.haskell.org/package/hledger-irr-0.1.1.13 (JoachimBreitner)
15:00:48 <Superjuju10> Happy New Year!
15:06:37 <Average-user> I have yet about 4 hours in 2017
15:16:21 * hackage unagi-chan 0.4.1.0 - Fast concurrent queues with a Chan-like API, and more  https://hackage.haskell.org/package/unagi-chan-0.4.1.0 (BrandonSimmons)
15:36:04 <ReinH> butterthebuddha: h = liftA2 (<|>) f g
15:36:14 <ReinH> or h x = f x <|> g x
16:03:19 <centril> lambdabot: unwords ["Happy", "New", "Year"]
16:06:18 <hydraz> > unwords ["happy", "new", "year"]
16:06:20 <lambdabot>  "happy new year"
16:07:56 <sebastianrkg> > (((unwords .) .) .) . (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:) $ "have" "a" "great" "2018"
16:07:58 <lambdabot>  error:
16:07:58 <lambdabot>      • Couldn't match expected type ‘[Char]
16:07:58 <lambdabot>                                      -> [Char] -> [Char] -> String’
16:08:02 <sebastianrkg> nooo
16:09:43 <jle`> sebastianrkg: you tried
16:09:53 <sebastianrkg> > ((((unwords .) .) .) . (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)) "have" "a" "great" "2018"
16:09:55 <lambdabot>  "have a great 2018"
16:10:04 <sebastianrkg> there we go
16:12:58 <MarcelineVQ> > text "so long 2017"
16:12:59 <lambdabot>  so long 2017
16:16:51 <hydraz> :t text
16:16:51 <lambdabot> String -> Doc
16:16:57 <hydraz> :t vcat
16:16:58 <lambdabot> [Doc] -> Doc
16:17:08 <hydraz> > vcat [text "a", text "b"]
16:17:10 <lambdabot>  a
16:17:10 <lambdabot>  b
16:17:20 <hydraz> very interesting.
16:17:22 <MarcelineVQ> uh oh
16:17:54 <int-e> this is where we learn why lambdabot cuts channel output off after 3 lines
16:18:21 <int-e> or 5
16:18:27 <hydraz> > hcat (repeat (text "a"))
16:18:34 <lambdabot>  mueval-core: Time limit exceeded
16:18:34 <lambdabot>  mueval: ExitFailure 1
16:18:39 <hydraz> :(
16:18:44 <ahihi> > (++"!") . ("happy "++) . show . foldl ((. (nubBy (fmap (1 /=) . gcd) [2..] !!)) . (*)) 1 $ [0,168]
16:18:46 <lambdabot>  "happy 2018!"
17:09:03 <statusbot> Maintenance update: Hackage is operational again; thank you for your patience! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5a4987f72b63db5786ca3ac7
17:27:25 <kakashiAL> > find (\x -> x == x + 0.01) [2 ^ x :: Double | x <- [1..]]
17:27:27 <lambdabot>  Just 1.40737488355328e14
17:50:23 <kakashiAL> does anybody know how I can check my results if I use Double?
17:52:46 <kadoban> kakashiAL: Wait, what?
17:54:11 <kakashiAL> kadoban: lets say you have a very very large number, with 4 numbers after the decimal point, how can you check if that number is correct?
17:54:27 <Gurkenglas> Ooh am I gonna be banned if I try to make lambdabot spam the channel and actually succeed?
17:54:49 <kadoban> Gurkenglas: IIRC it's not very hard to get it to do so, so it doesn't sound like a very fun thing to try.
17:55:19 <geekosaur> make a habiit of it and you'll likely find lambdabot ignoring you
17:56:35 <kadoban> kakashiAL: Well, if you need enough precision, you just can't use Double at all. I'm not 100% following what you need to do though.
17:57:35 <kakashiAL> kadoban: I know that Double has its issues with precesion, but how can I check where my limits are? how can I check if the result that I have is correct?
18:03:41 <kakashiAL> kadoban: got what I mean?
18:05:01 <kadoban> Not really
18:06:04 <kakashiAL> kadoban: okay, lets say you have a lit of thousand of number: 1124.3424, 24545.5509, .... and so on
18:06:17 <kakashiAL> now you want to add them together
18:06:44 <kakashiAL> kadoban: at the end you get a result like 354750387568483.28488  <--how do you know that there is no precision error`?
18:07:54 <kadoban> You don't.
18:08:29 <kakashiAL> kadoban: thanks a lot
18:08:41 <kadoban> Sorry :)
18:09:06 <kakashiAL> kadoban: no no, it was a struggle, I thought that there is something like a test or such :)
18:09:10 <kadoban> But I mean as stated, I don't think that has an answer in Double, it's just kind of impossible to tell from the end number how accurate you were.
18:09:13 <kakashiAL> you helped me a lot
18:09:19 <kadoban> Oh okay :)
18:09:56 <kakashiAL> kadoban: so if you would have thousands of decimals, and you want to add them together and maybe do some other stuff with them
18:10:47 <kakashiAL> there are one way that I know: create a new list where you multiply them by 10 or 100 (depends how much precesion you want), round it, and work with the integers
18:11:08 <kakashiAL> kadoban: is there a type that you would recommend, if you dont want a fast way with Ints?
18:11:43 <kadoban> Well you could just do them as Rationals I guess, depending on how huge they are and what operations you're going to be doing, that could be fine.
18:12:11 <kadoban> There's also that uhm, other type I can never remember the damn name of, it's not in base but some library. Sec *looks*
18:18:23 <kadoban> Can't find it xD
18:19:30 <kakashiAL> heared a lot about Rational, never used it
18:21:04 <geekosaur> CReal?
18:21:25 <kakashiAL> kadoban: but what I learned is: if you use Double, you never could be sure that your result is correct, so only use if precision does not realy matter (for example technical code, GUI or such)
18:21:49 <kakashiAL> geekosaur: whats the difference between CReal and Rational?
18:27:31 <kadoban> Yeah, CReal looks possible. I can't tell if that's the one I was thinking of. The difference is just what they try to represent. Rational is *just* rational numbers, It's a/b for a and b integers. So it really depends what your inputs are and what operations you need to do on them if that'll make sense or not.
18:29:33 <monochrom> Just yesterday n_sheppard told us the Kahan summation algorithm: https://en.wikipedia.org/wiki/Kahan_summation_algorithm
18:30:19 <monochrom> If you're asking generally, then the answer is take a numerical analysis/algorithm course, which will tell you how to estimate and prove your error bounds.
18:34:02 <carter> Also unless you know what your error bounds need to be, you’re probably wasting lots of compute on more precision
18:35:07 <kakashiAL> carter: what is if I want to use Double and say "I want exactly 2 digit precsion"?
18:35:51 <carter> Then make sure you know how your calculation works and what the domain of inputs and outputs should be
18:36:38 <jle`> kakashiAL: if you know the uncertainty/precision of your inputs, you can roughly compute the uncertainty/precision of your ouputs given a certain function of your inputs, in some situations
18:36:45 <jle`> and making some assumptions
18:36:48 <carter> Because when you say that, you actually are saying I want to get two decimal digits of accuracy input, and then know for all valid inputs that this is true for the outputs
18:37:18 <carter> jle`: but you never typically wanna use intervals to track that ;)
18:39:00 <kakashiAL> carter: I dont understand, you mean if I have a lot of thousands of numbers, lets even say that only have two digits, they are all Double, and I add them together, you can gurantee that the end result is correct, I would say no!
18:39:15 <carter> Nope
18:39:27 <carter> I didn’t say that. I said what’s the algorithm
18:39:48 <carter> White box not black box.  There’s no black box approach. Even if you use exact reals
18:39:52 <erisco> What's That Algorithm?!
18:39:53 <carter> Or computable ones
18:39:56 <carter> Yes
18:40:05 <carter> erisco: ;)
18:40:10 <carter> How’re you?
18:40:15 <monochrom> Looking for someone to commit to a one-size-fits-all answer. And when no one commits, put words into people's mouth.
18:40:28 <erisco> great! I don't remember the last time we spoke
18:40:36 <erisco> happy new year's to everyone!
18:40:37 <carter> monochrom: that dude is ??  How’re you?
18:40:47 <carter> Thx. What’ve y’all been up to?
18:40:49 <kakashiAL> carter: at the moment just "sum a list of Doubles" thats the algorithm
18:41:10 <carter> Sort them, put em in a priority list
18:41:19 <carter> Sort them by absolute magnitude
18:41:26 <kakashiAL> carter: but even there, no gurantee can be done
18:41:29 <carter> Add the smallest two.
18:41:39 <carter> Put it back In
18:41:45 <carter> Take the next smallest two
18:41:58 <carter> Nah it’s totally guaranteed.  It’s just slower
18:42:18 <carter> kakashiAL: do some background reading. I’m off to a fam dinner
18:42:20 <kakashiAL> carter: would it be not easier and more efficent to create a new list and map my Double list to a list of Ints
18:42:32 <carter> Lol you didn’t google
18:42:35 <carter> So nope
18:42:37 <kakashiAL> carter: sources and links please
18:42:51 <carter> Nope. You can google and I’m off to a family dinner.
18:43:02 <kakashiAL> carter: thanks, have fun :)
18:43:08 <carter> monochrom: erisco let’s catsup soon
18:43:14 <monochrom> And to think I have already linked the Kahan summation algorithm
18:43:32 <erisco> maybe I am someone different than you think, because we certainly haven't met in person before
18:43:51 <monochrom> which actually is linear-time and IIUC as good as pre-sorting
18:43:54 <kakashiAL> carter: sure, thats a nummeric algorithm that helps you to check how big the error is
18:44:29 <carter> It will never drop the two largest sig figures
18:44:45 <kakashiAL> I will keep that in mind and never use Double fpr stuff if I need precision
18:44:51 <kakashiAL> and stay with Ints
18:44:59 <carter> Nah.  You should use floats when it’s needed
18:45:16 <kakashiAL> if I need decimals I will install one of that packages like Rational
18:45:17 <carter> Int can’t do useful stuff
18:45:34 <carter> Sure. Whatever you want.  Then why are you asking :)
18:46:05 <kakashiAL> carter: I hoped for an easy answer, something more practical than the khan algorithm
18:46:42 <kakashiAL> the Rational or the CReal datatype looks more pragmatic
18:47:11 <carter> It’s in the compensated package so you can just use
18:47:20 <kadoban> The kahan algorithm looks quite practical to me
18:47:22 <hoon> hey guys
18:47:30 <kakashiAL> kadoban: I am not smart :(
18:47:37 <erisco> hi
18:47:50 <kakashiAL> carter: could you rephrase your last statement?
18:48:35 <monochrom> There is no easy answer.
18:50:03 <monochrom> It is OK to take the stance "I can't do the proofs, I need someone else to do the proofs and document the result formula for the error bound so I can just use the formula". This is totally reasonable.
18:50:58 <monochrom> But 1. different algorithms will be associated with different error bound formulas.  2. You still need some aptitude to even just use the formulas.
18:51:02 <carter> Busy. Look at the package I mentioned.  It has the summation alg. Your problem
18:51:39 <mnoonan_> is hmatrix the canonical linear algebra package, or are there other common alternatives?
18:51:52 <monochrom> There is nothing easier below that. Short of just being a management type and hire someone to do everything and you let go.
18:53:46 <carter> mnoonan: depends !!
18:55:22 <erisco> and then you recede into the dark corners of your own mind … and you program a VR replica of Star Trek … and you clone the people you hate, or want but can't have, into your world … and you torture them until they bend to your will
18:57:20 <carter> erisco: that sounds very specific.  Which fiction.
18:57:58 <erisco> Black Mirror
18:58:29 <kakashiAL> carter: what package did you mention?
18:58:48 <carter> Compensated
18:58:54 <carter> kakashiAL: that one.
18:59:06 <monochrom> I like hmatrix.
18:59:25 <carter> monochrom: I need to finish mine soon. Life got busy
19:00:07 <monochrom> I can't say it's canonical because under some hardware assumptions and performance requirements repa is more suitable.
19:00:33 <monochrom> As usual after a while you will find that nothing is canonical in the Haskell community. Just ask around about pipes and conduits.
19:01:17 <monochrom> (Or use a time machine to go back 7 years to watch the 4-some war of iteratees, enumeratees, pipes, conduits)
19:01:51 <kakashiAL> carter: hmm, Compensated is just a IEEE 754 with 128 bit :/
19:01:57 <monochrom> OK, I lied. GHC is canonical.
19:02:10 <carter> Nope. kakashiAL you don’t understand float
19:02:16 <carter> Go learn.
19:02:25 <carter> Ttyl and happy nye everyone
19:02:37 <monochrom> But the canonicity ends right there. You move just one step away and you see how there is no canonicity at the cabal vs stack level already.
19:03:05 <kakashiAL> carter: what do you think about Rational and CReal?
19:03:12 <monochrom> 128 bits are already longer than Int's 64 bits, for what it's worth.
19:03:44 <carter> kakashiAL: go write your actually code. Try em all then decide later.
19:03:49 <carter> Yup.
19:04:10 <kakashiAL> carter: sure, but what is your opinion ?:)
19:04:18 <carter> Go solve it.
19:04:49 <monochrom> This is not politics. "Opinion" is the wrong question.
19:05:36 <kakashiAL> monochrom: let me ask it this way: when yould you use Rational and when would you use CReal?
19:05:47 <carter> You’d never use creal
19:06:04 <carter> Use rational unless it’s too slow then use double.
19:06:09 <carter> Problem solved.
19:06:21 <kakashiAL> carter: thanks, clear and straight to the edge
19:06:53 <kakashiAL> carter: but I would use Int for money and save my stuff in cents :)
19:07:40 <erisco> Int for money… when having too much money actually plummets you into debt :)
19:07:43 <carter> Depends on what accounting rules.  Excel uses floats and every biz uses excel.  So probably not an issue
19:07:52 <carter> Integer ftw
19:08:17 <carter> erisco: I wanna lookup oldtimy accounting rounding rules
19:08:28 <monochrom> I would use Rational for kids' educational software "learn fractions!". I would use CReal for academic curiosity.
19:08:31 <erisco> like .5 goes up on evens and down on odds?
19:09:03 <kadoban> In practice you pretty much just use Double unless you have some pretty odd situation.
19:09:38 <carter> https://stackoverflow.com/questions/3840793/rounding-standards-financial-calculations
19:09:54 <carter> kadoban: yeah.
19:10:10 <carter> And creal is seldom the right approach.  At least the way it’s usually done
19:10:44 <monochrom> Rounding rules are going to be super client-specific.
19:11:45 <erisco> "I just asked a greybeard mainframe programmer at the financial software company I work for, and he said there is no well-known standard and it's up to programmer practice." - Joe Koberg
19:11:48 <EvanR> only use numbers constructible with compass and straight edge with finance
19:12:11 <erisco> what do my banking fees go towards then? sheesh
19:12:36 <monochrom> Here is an example. In Canada, due to a recent law to bannish the 1-cent coin (but we still accept the 5-cent coin), when you pay cash at the cashier, we round to the nearest multiple of 5.
19:13:21 <erisco> and everyone turned in their pennies like good citizens
19:13:29 <EvanR> what if it costed 3.725
19:13:57 <monochrom> The same law, however, requires that non-cash payments still round to the nearest cent.
19:14:17 <monochrom> But if you ask me "is that round up or round to even?", I really don't know.
19:14:45 * hackage ats-format 0.1.0.14 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.14 (vmchale)
19:14:49 <monochrom> (Fractional cents are possible because of oddball sale tax rates of 13% or the like)
19:15:24 <carter> monochrom: yeah I’m gonna need to spec out how we should specify rounding and precision stuff for some tools at work.
19:16:14 <monochrom> Another fun story while I'm at it. Some years ago, the Japanese government proposed to decrease their sales tax rate. This ran into much opposition in popular opinion.
19:16:58 <monochrom> Reason: The old, higher sales tax rate gave nicely rounded numbers, the proposed new lower rate would not.
19:17:12 <carter> Hehe
19:17:41 <erisco> do they pay by cash more often? because I rarely see cash anymore
19:18:01 <monochrom> I don't know about now. This was maybe 10 years ago.
19:18:15 <erisco> and when most of your purchases are made by tapping a RFID chip on a reader, I don't see who'd care
19:18:17 <EvanR> you see less cash now, and card services companies see more
19:18:22 <EvanR> $_$
19:18:32 <monochrom> But yeah 10 years ago or 15 years ago most people paid by coins.
19:18:40 <carter> Yeah.
19:19:26 <erisco> actually a lot of people paid for petrol with cash
19:19:47 <erisco> back when I worked the pumps… so you were practiced at squeezing out a few pennies to make it even
19:20:18 <EvanR> cash is king
19:20:43 <erisco> then again, our machine used dial up, so make the regulars wised up to that :P
19:21:06 <hoon> safe to assume that a ByteString type isn't going to do me much good if I was forced to unpack it first thing?
19:21:07 <erisco> made a connection on every transaction… otherwise you couldn't use the phone, of course
19:21:32 <monochrom> hoon: I think yes.
19:22:29 <hoon> I guess I don't HAVE to unpack it if I can work out a way to break it into chunks ala Data.List.Split.chunksOf
19:23:03 <EvanR> by unpack you mean -> [Word8] ?
19:23:16 <EvanR> consuming that list can be efficient
19:23:25 <erisco> mind, I think a lot of small towns are about a decade behind in technology
19:24:25 <monochrom> hoon: I think you may like to consider looping over splitAt
19:25:44 <hoon> I will toy with that
19:25:46 <hoon> thanks
19:34:29 <carter> kakashiAL: did you find the package ? Happy holidays!
20:35:16 * hackage data-lens 2.11.2 - Used to be Haskell 98 Lenses  https://hackage.haskell.org/package/data-lens-2.11.2 (RussellOConnor)
20:38:33 <aedificium> I'm writing a websockets application, and I want to set off a timer for a certain function to be run in 3 seconds, but I also want it to keep accepting other requests in the meantime
20:38:51 <aedificium> I imagine I need to do something like forking to a new thread and running with some delay? But I can't find any resources on this, any pointers?
20:39:10 <EvanR> look at forkIO and threadDelay in Control.Concurren
20:39:16 <EvanR> Control.Concurrent
20:41:17 <aedificium> EvanR: ah, great. thanks
20:46:27 <hoon> fg
21:17:15 * hackage wild-bind 0.1.1.0 - Dynamic key binding framework  https://hackage.haskell.org/package/wild-bind-0.1.1.0 (debugito)
21:19:33 <augur> what's the conventional alternative to MonadError now that that package is deprecated???
21:20:45 * hackage wild-bind-x11 0.2.0.0 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.2.0.0 (debugito)
21:22:28 <augur> oh, its Control.Monad.Error.Class
21:23:16 * hackage wild-bind-indicator 0.2.0.0 - Graphical indicator for WildBind  https://hackage.haskell.org/package/wild-bind-indicator-0.2.0.0 (debugito)
21:25:18 * hackage wild-bind-task-x11 0.2.0.0 - Task to install and export everything you need to use WildBind in X11  https://hackage.haskell.org/package/wild-bind-task-x11-0.2.0.0 (debugito)
21:38:40 <butterthebuddha> https://gist.github.com/anonymous/189a935d1c881ac02a2b01afdab5ed33
21:38:41 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/hw/10-applicative.pdf
21:39:08 <butterthebuddha> Does anybody have any style tips for my solutions?
21:43:29 <jle`> butterthebuddha: pretty solid style-wise
21:43:49 <jle`> butterthebuddha: (\x y -> (x,y)) is (,)
21:44:48 <butterthebuddha> Is there a similar function for lists?
21:44:58 <jle`> butterthebuddha: nope, i always wnated one though
21:45:12 <jle`> butterthebuddha: also (\_ _ -> ()) <$> x <*> y is probably easier using some variation of x *> y
21:45:30 <butterthebuddha> I was also hoping there was a better way to implement intOrUppercase
21:45:57 <jle`> void (x *> y), x *> y *> return (), x *> y <$ (), () <$ x <* y, etc.
21:46:10 <jle`> same thing with intOrUppercase
21:46:39 <jle`> you use a lot of const () and (\_ -> ()), those could all be void's
21:46:41 <jle`> or () <$'s
21:46:51 <butterthebuddha> Wait, I'm confused
21:46:53 <butterthebuddha> What's <$?
21:47:02 <jle`> > () <$ [1,2,3]
21:47:03 <lambdabot>  [(),(),()]
21:47:08 <jle`> it replaces the results with ()'s
21:48:02 <jle`> () <$ x = const () <$> x, but you can think of `() <$ x` as the same parser as x, but with the result replaced with ()
21:48:35 <jle`> butterthebuddha: but (() <$) is just void
21:48:37 <jle`> :t void
21:48:37 <lambdabot> Functor f => f a -> f ()
21:49:07 <butterthebuddha> So, const () <$> posInt == () <$ posInt == void posInt?
21:49:12 <jle`> butterthebuddha: intOrUppercase = void posInt <|> void satUpper
21:49:17 <[Leary]> You can avoid implementing rmSpace and used char instead.
21:49:42 <EvanR> > void [1,2,3]
21:49:44 <lambdabot>  [(),(),()]
21:49:46 <jle`> er, void posInt <|> void (satisfiy isUpper)
21:49:52 <EvanR> handy
21:50:05 <butterthebuddha> I don't understand this trickery
21:50:07 <butterthebuddha> but it's awesome
21:50:23 <jle`> butterthebuddha: void :: Parser a -> Parser ()
21:50:32 <jle`> butterthebuddha: takes a parser and returns the same parser
21:50:39 <jle`> but except replaces the reuslt with ()
21:51:14 <butterthebuddha> [Leary] char ' ' you mean?
21:51:20 <butterthebuddha> Oh of course
21:51:23 <[Leary]> Yes.
21:51:29 <butterthebuddha> jle`: Ah I get it now
21:54:47 <butterthebuddha> What's a good resource for learning Haskell after cis 194?
21:54:56 <butterthebuddha> I'm on the 11th homework, so I'm pretty close to being done
21:56:34 <[Leary]> You can also remove brackets from your definition of <|>, then use the Maybe instance of Alternative (and optionally Applicative) to write the rest of it more cleanly.
21:57:59 <glguy_> butterthebuddha: working on a small project is a good next step
22:00:52 <[Leary]> *and optionally the Applicative instance of (->) s)
22:01:04 <jle`> h f g x = f x <|> g x
22:01:22 <butterthebuddha> glguy_: idk, working on something in haskell is kinda intimidating because interacting with the "real world" sounds hard
22:01:35 <jle`> also it isn't too bad to use lambdas for Parser's
22:01:57 <jle`> butterthebuddha: the best way to get over the intimidation is by actually trying it
22:02:00 <jle`> and seeing that it isn't too bad :)
22:02:14 <butterthebuddha> Eh, true I suppose
22:02:15 <EvanR> i like how IO works
22:02:34 <EvanR> IO actions are first class
22:02:52 <jle`> butterthebuddha: you might see that there isn't much to worry about at all
22:03:01 <jle`> the fear is mostly in your head :)
22:03:26 <glguy_> If it's intimidating you can put off learning it for a while, but you won't learn how to actual make stuff from exercises
22:11:43 <butterthebuddha> How does liftA2 work?
22:12:02 <butterthebuddha> Especially in this context - << (.+) = liftA2 (+) >>
22:13:54 <glguy_> There's not enough context there to say
22:14:08 <glguy_> :t liftA2 (+)
22:14:09 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
22:14:30 <glguy_> Unless your question is more general than I had guessed
22:14:39 <glguy_> :t liftA2
22:14:40 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:14:44 * geekosaur is guessing they were tryingt o compose (.) and (+)
22:14:48 <glguy_> :t (+)
22:14:49 <lambdabot> Num a => a -> a -> a
22:15:00 <geekosaur> and what they're reaching for is the ((->) e) Applicative
22:17:47 <butterthebuddha> https://gist.github.com/anonymous/3b1cae73ef33a707669d578888167914
22:17:52 <butterthebuddha> This is the complete code
22:18:25 <geekosaur> ah, more general indeed
22:23:28 <geekosaur> haveyou tried to understand the Applicative typeclass?
22:28:13 <butterthebuddha> I understand it now after playing with the types in ghci
23:07:15 * hackage wai-routes 0.10.1 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.10.1 (AnupamJain)
23:09:43 --- mode: ChanServ set +o glguy
23:09:48 --- mode: glguy set -o glguy
23:17:07 <WinterFox[m]> Is it only possible to print variables that have a datatype deriving show?
23:17:27 <glguy> WinterFox[m]: correct
23:18:26 <WinterFox[m]> Is it possible to print it in some other way? I want to see whats in a variable for debug reasons but it doesn't derive show.
23:18:53 <bartavelle> ":print" in ghci
23:20:23 <bartavelle> you might also be able to use TH or Generic dependending on how much work you want to put in this
23:20:45 <WinterFox[m]> I'm gonna delete this print soon I just want to check that it contains what I think it does.
23:21:14 <bartavelle> yeah, the famous debugging print that requires putting Show constraints all over the place :)
23:21:31 <bartavelle> (this is annoying)
23:21:57 <WinterFox[m]> Is there a better way? In ruby I would just do `p foo` and it shows everything in foo.
23:22:10 <bartavelle> no, it clearly is annoying in haskell
23:22:19 <bartavelle> however, you can trace (myshow foo)
23:22:29 <bartavelle> if you know what foo is
23:22:38 <bartavelle> if it is parametric, you are on your own
23:22:44 <bartavelle> you can break with the ghci debugger
23:22:46 <bartavelle> and inspect it
23:23:28 <WinterFox[m]> How would I do that? I'm building by running `stack test`
23:23:36 <bartavelle> run it with stack ghci
23:23:54 <bartavelle> then I don't really remember how to use ghci as a debugger, only :print
