00:00:45 <ski> i think it's reasonable to give an error for negative counts
00:00:51 <POGtastic> groups don't include everyone? 0 solutions. groups hold too many people for everyone to fill? 0 solutions. negative amount of people in the group? 0 solutions. 0 groups? Doesn't matter.
00:01:33 <ski> but giving an empty list (iow failing to produce solutions) is also agreeable
00:02:45 * ski nods
00:03:06 <POGtastic> thanks for the help
00:03:13 <ski> np
00:04:36 <ski> POGtastic : i would suggest that you try using `(=<<)' (or `do' notation, or list comprehensions), instead of `concatMap'
00:04:54 <POGtastic> :t (=<<)
00:04:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
00:05:19 <POGtastic> i have some reading to do :)
00:05:34 <ski> @type \f -> concatMap f `asAppliedTo` []
00:05:36 <lambdabot> (a -> [b]) -> [a] -> [b]
00:06:13 <ski> you should be able to generalize the outermost `[]' to `m', with `MonadPlus m' constraint, i think
00:06:27 <ski> (the outermost `[]' in the result type, i mean)
00:08:04 <ski> i suspect that if you write `group', using `do'-notation, or even list comprehensions, that you'll find more scrutable
00:08:13 <ski> s/find/find it/
00:25:53 <jle`> dmj`: i was trying to incorporate as many puns as i could :)
00:26:03 <[exa]> mniip: good idea, thanks!
00:36:18 * hackage bitx-bitcoin 0.12.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.12.0.0 (tebello_thejane)
01:09:48 * hackage alternators 0.1.2.0 - Handy functions when using transformers  https://hackage.haskell.org/package/alternators-0.1.2.0 (louispan)
01:21:07 <mniip> [exa], other challenege ideas involve implementing C's methods via D's methods for C => D classes in Prelude
01:21:14 <mniip> also implementing basic lens machinery
01:21:25 <mniip> namely, sometimes coming up with your own functors
01:56:04 <Athas> Is it better for performance to keep the error monad (like MaybeT) at the bottom or top of a monad transformer stack?
02:01:14 <geekosaur> that seems like the wrong question to ask
02:01:26 <geekosaur> because position in the stack impacts how errors behave
02:01:56 <Athas> Not in my case.
02:11:53 <jle`> Athas: if it doesn't impact how errors behave then it doesn't matter
02:11:59 <jle`> Athas: since they are newtype wrappers
02:12:14 <jle`> the ordering of newtype wrappers disappears at runtime if the representations are isomorphic
02:12:30 <jle`> so after compilation there is literally no difference
02:13:15 <Athas> Surely the monadic bind operators will generate different code?
02:13:50 <jle`> Athas: if you're in doubt, just manually unwrap the newtype wrappers
02:14:02 <jle`> and you can see if there is actually any difference
02:14:45 <jle`> manually unwrap them in your mind, i mean, not in a benchmarking sense
02:16:23 <jle`> alternatively you can just benchmark
02:33:08 <ertes> :t (fmap Just .) :: Lens (Maybe a) (Maybe a) (Maybe a) a
02:33:09 <lambdabot> Functor f => (Maybe a -> f a) -> Maybe a -> f (Maybe a)
02:33:16 <ertes> is this predefined?  it basically always sets to Just
02:33:55 <crick_> Can someone please explain me how functions are applicative functors?
02:34:03 <crick_> I am reading fro LYAH
02:34:28 <ertes> crick_: pure = const; (f <*> g) x = f x (g x)
02:34:40 <ertes> crick_: it's reader monads in disguise
02:34:47 <Taneb> crick_, one way you can think of a function of type "r -> a" is an assignment of a value of type a for every value of type r
02:35:07 <crick_> Okay
02:35:18 <Taneb> crick_, "pure x" for functions is saying "for every value of type r, assign it the value of type a that is x"
02:35:21 <crick_> I am stuck with this: (+) <$> (+3) <*> (*100)
02:36:12 <Taneb> crick_, and "x <*> y" is saying "for every value of type r, take the function x assigns to it, and the value y assigns to it, and assign to it the value you get by applying the value from y to the function from x"
02:37:06 <Taneb> crick_, in that example, (+3) is like "for each number x, assign to it the number that is x + 3", similarly (*100) is "for each number x, assign x*100"
02:37:45 <Taneb> (+) <$> ... is the same as pure (+) <*> ..., which might be easier to think about
02:38:17 <Taneb> So pure (+) <*> (+ 3) is "for each x, assign (+) (x + 3)"
02:38:43 <Taneb> And pure (+) <*> (+ 3) <*> (* 100) is "for each x, assign (+) (x + 3) (x * 100)", or "(x + 3) + (x * 100)"
02:38:59 <Taneb> crick_, does this help?
02:39:34 <crick_> Taneb: Yes, I am reading it carefully, trying to understand
02:42:09 <Axman6> the Applicative insdtance for functions is known as Reader, it alows you to pass the same value to all the functions - they can all read the same value.
02:43:25 <crick_> Taneb: thanks, I am getting it now
02:43:32 <Taneb> crick_, :)
02:44:08 <Axman6> it might be helpful to explore using lambdas: (+) <$> (+3) <*> (*100) --> (\x y -> x + y) <$> (\a -> a + 3) <*> (\b -> b * 100)
02:44:23 <Axman6> it's a very useful instance, but takes a bit of getting used to
02:45:49 <crick_> Axman6 : Yes, this looks much readable to me
02:46:00 <Axman6> the value you give is passed to the two left most functions as the arguments a and b, and then the results of that are passed to x and y
02:47:15 <Axman6> if you use pure (+) <$> instead of (+) <$> and look at the definition of pure for functions, you'll see that it is the function which takes a value a, and returns a function which accepts an argument, and ignores it, and returns a (i.e. const)
02:58:28 <Axman6> ^/exit
02:58:49 <crick_> Axman6: Okay, we could also write pure x = \_ -> x
03:12:20 * hackage HSlippyMap 2.3 - OpenStreetMap Slippy Map  https://hackage.haskell.org/package/HSlippyMap-2.3 (apeyroux)
03:13:26 * hackage HSlippyMap 2.4 - OpenStreetMap Slippy Map  https://hackage.haskell.org/package/HSlippyMap-2.4 (apeyroux)
03:15:22 * hackage HSlippyMap 2.5 - OpenStreetMap Slippy Map  https://hackage.haskell.org/package/HSlippyMap-2.5 (apeyroux)
03:23:47 <pie__> anyone able to give a hand with a probably nixos problem?:
03:23:55 <pie__> this results in an error: ghc -O2 --make -fPIC -dynamic -lHSrts_thr-ghc8.0.2 -no-hs-main -optl '-shared' -optc '-DMODULE=Test' -o Test.so Test.hs
03:24:04 <pie__>  /nix/store/3iggy4d1wdwivs4kx9ic90npiwxvnrr8-binutils-2.27/bin/ld: -r and -shared may not be used together
03:25:30 <pie__> this shows the flags passed to ld https://pastebin.com/wX5LFGiV
03:26:53 <pie__> this is the gcc command:
03:27:17 <pie__> https://pastebin.com/RmwfKK3x
03:33:35 <pie__> apparently whichever haskekll wiki page i was looking at had a bad example
03:33:50 <pie__> should just be normal -shared afaict
03:35:10 <Axman6> yeah telling GHC to make shared libs should make it take care of getting ld to do the right thing
03:37:02 <geekosaur> iirc nixos puts wrappers around all the commands and those wrappers sometimes inject incompatible options
03:37:18 <geekosaur> ghc can't tell the wrappers are messing with its commands
03:37:36 <pie__> this is where i got it https://wiki.python.org/moin/PythonVsHaskell
03:37:48 <pie__> geekosaur, yeah i know
03:38:05 <pie__> anyway, turns out it was user-ish error
03:50:58 <dminuoso> Hi. How exactly are `f x = ...` and `f = \x -> ...` different?
03:51:29 <dminuoso> A pointer to the Haskell report would be fine as an answer, Im a bit lost - unsure what to look fpr.
03:51:48 <geekosaur> per the haskell report they are the same. ghc treats them slightly differently
03:52:36 * hackage pipes-transduce 0.4.1 - Interfacing pipes with foldl folds.  https://hackage.haskell.org/package/pipes-transduce-0.4.1 (DanielDiazCarrete)
03:53:56 <dminuoso> geekosaur: Is that just the monomorphism restriction, or are there other subtleties?
03:54:05 <geekosaur> also note there is a difference when the pattern isn;t irrefutable, `f (Just x) =` would evaluate the first parameter just enough to see if ti's Nothing vs. Just immediately, whereas `f = \(Just x) -> ...` wouldn't
03:54:27 <dminuoso> Oh?
03:55:38 * geekosaur is looking for the ghc specific thing
03:57:23 <geekosaur> `f =` means it's already in WHNF and produces a lambda. `f somePat =` if somePat is not irrefutable needs to force the pattern just enough to see if it matches the pattern
03:57:32 <dminuoso> geekosaur: The point you just tried to make.. so more broadly speaking `f x = ...` is equivalent to `f = \case ...` ?
03:57:37 <geekosaur> although as ghc implements it, it's not quite that way iirc
03:57:46 <dminuoso> Mmm
03:57:50 <geekosaur> sigh
03:57:55 <dminuoso> Ah I got it.
03:58:03 <geekosaur> if anything it would be the opposite but I guess I have confused you instead of helping
03:58:07 <geekosaur> f =
03:58:10 <geekosaur> this is done
03:58:15 <geekosaur> f SOMEHTING =
03:58:23 <geekosaur> this implies that SOMETHING needs to be processed
03:59:05 <geekosaur> but in practice there's desugaring that should make them look the same (f SOMETHING -> f = case SOMETHING of ...).
03:59:19 <geekosaur> but iirc in ghc it does not make them exactly the same
04:00:09 <geekosaur> here's one ghc-specific difference: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs.html#expressions-and-patterns
04:02:48 <geekosaur> mm, not finding the rest of it (which is the underlying behavior that leads to what that link talks about)
04:04:32 <dminuoso> @let f :: ([a] -> b -> b); f = \([]) -> error "urk
04:04:32 <lambdabot>  Parse failed: Improperly terminated string
04:04:37 <dminuoso> @let f :: ([a] -> b -> b)
04:04:38 <lambdabot>  .L.hs:184:1: error:
04:04:38 <lambdabot>      The type signature for ‘f’ lacks an accompanying binding
04:04:38 <lambdabot>        (The type signature must be given where ‘f’ is declared)
04:05:18 <geekosaur> woudln't want to @let a single character function name
04:05:36 <dminuoso> Oh.
04:06:15 <dminuoso> Ah well, I just threw it into GHCi and noticed that the equivalent code using a lambda is indeed different.
04:06:17 <geekosaur> if you were trying to test the example in the link, > let ... in ... should be good enough and won't pollute the bot's remembered definitions
04:07:29 <dminuoso> > let f = \([]) -> error "urk" :: ([a] -> b -> b) in print (f [] `seq` True)
04:07:32 <lambdabot>  <IO ()>
04:07:39 <dminuoso> O_o
04:08:00 <dminuoso> Shouldn't lambdabot execute that IO ()?
04:09:10 <geekosaur> lambdabot never executes IO
04:09:15 <Axman6> > let f = \([]) -> error "urk" :: ([a] -> b -> b) in (f [] `seq` True)
04:09:17 <lambdabot>  *Exception: urk
04:09:31 <dminuoso> Ah alright
04:10:15 <geekosaur> there's that other bot with the % command prefix that does limited I/O though
04:10:29 <geekosaur> % let f = \([]) -> error "urk" :: ([a] -> b -> b) in print (f [] `seq` True)
04:10:30 <yahb> geekosaur: *** Exception: urk; CallStack (from HasCallStack):; error, called at <interactive>:6:18 in interactive:Ghci6
04:10:59 <dminuoso> Ah I can see that yahb seems to run this through ghci somehow. Im guessing lambdabot does not.
04:11:14 <geekosaur> lambdabot uses mueval which implements a sandbox
04:18:33 <dminuoso> > let f undefined = 1 in f undefined
04:18:35 <lambdabot>  1
04:18:43 <fakenullie> heh
04:19:03 <geekosaur> probably not doing what you think
04:19:19 <geekosaur> > let f _ = 1 in f undefined -- exact same thing
04:19:21 <lambdabot>  1
04:19:32 <fakenullie> it defines function f with pattern match on undefined?
04:19:51 <fakenullie> > let f undefined = 1 in f 2
04:19:53 <lambdabot>  1
04:19:59 <fakenullie> interesting
04:20:09 <geekosaur> did you happen to read what I wrote?
04:20:12 <geekosaur> "exact same thing"
04:20:21 <fakenullie> I did, but I didn't believe
04:20:43 <geekosaur> "f undefined =" creates a *new* binding named 'undefined', which matches anything and is therefore not forced unless it is used. but it is not used
04:21:18 <geekosaur> which is why 'f _ =' is exactly the same; since it;s not used, there's no point in naming it
04:21:38 <fakenullie> > let f undefined = undefined + 1 in f 2
04:21:40 <lambdabot>  3
04:22:08 <fakenullie> I didn't know that undefined can be shadowed
04:22:23 <geekosaur> and that one is using the new local binding for 'undefined'; the original one is hidden by the new one
04:22:36 <geekosaur> anything can be shadowed that isn't defined in the same scope
04:23:03 <geekosaur> (well, any binding. things like typeclasses can't be)
04:23:11 <dminuoso> geekosaur: I think whas I just tried was silly anyhow. I mean if I could specifically match for bottom, I'd be rich for solving the unsolveable halting problem now?
04:23:29 <fakenullie> @src undefined
04:23:29 <lambdabot> undefined = error "Prelude.undefined"
04:23:32 <geekosaur> pretty much, yes
04:23:51 <geekosaur> also you could still get at the original undefined in that by qualifying it as Prelude.undefined
04:24:11 <geekosaur> (this won;t work in the pattern match though, it'd tell you you had an illegal qualified name in a binding)
04:27:42 <geekosaur> this also doesn't only affect undefined; a common beginner error is something like f minBound = ...
04:28:09 <geekosaur> which does not test against minBound, it creates a new local binding. this is why guards exist: f x | x == minBound = ...
04:28:43 <dminuoso> geekosaur: Yeah. I recently trained myself to think of "x" in `f x = ...` not as an "argument" but an irrefutable pattern with a binding for "x"
04:31:33 <dminuoso> geekosaur: When I tried with this with `undefined` I falsely thought that `undefined` was a data constructor.
04:31:49 <geekosaur> lowercase vs. uppercase initial :)
04:32:13 <dminuoso> geekosaur: Try telling that to numbers or array brackets! :-P
04:32:48 <geekosaur> both are a bit magical, yes
04:33:02 <geekosaur> numbers are really magical since they get turned into guards internally
04:33:37 <geekosaur> lists (not arrays!) desugar to (:), and for infix things leading : indicates a constructor
04:36:14 <geekosaur> > let f :: Num a => a -> a; f 1 = 5; f x = x + 1 in f 3 -- magic exposed as the fraud it is
04:36:16 <lambdabot>  error:
04:36:16 <lambdabot>      • Could not deduce (Eq a1) arising from the literal ‘1’
04:36:16 <lambdabot>        from the context: Num a
04:40:13 <dminuoso> Oh so f 1 = 5 would get turned into f x | x == 1 = 5 ?
04:40:20 <geekosaur> yes
04:40:38 <dminuoso> Alright, that implies if you dont specify the type, it will infer that it must also be Eq at minimum.
04:40:54 <geekosaur> and standard Haskell would actually hide even that because the standard says Num a implies Eq a. but for various reasons ghc doesn;t so that so you can catch it out on requiring the Eq constraint
04:41:14 <geekosaur> it'll infer (Num a, Eq a) => a -> a
04:41:41 <geekosaur> :t let f 1 = 5; f x = x + 1 in f
04:41:42 <lambdabot> (Eq p, Num p) => p -> p
04:42:02 <dminuoso> Huh. I get a slightly different signature
04:42:04 <geekosaur> modulo alpha equivalence because who knows what names the typechecker will pull out of its butt
04:42:07 <dminuoso> test :: (Eq a, Num a, Num p) => a -> p
04:42:27 <dminuoso> Ohh, your usage of x implies that they must have the same constraint.
04:42:27 <geekosaur> if you didn;t specify the second part, there's nothing linking a and p
04:42:31 <dminuoso> Yeah.
04:51:51 * hackage process-streaming 0.9.2 - Streaming interface to system processes.  https://hackage.haskell.org/package/process-streaming-0.9.2 (DanielDiazCarrete)
04:53:08 <dminuoso> geekosaur: Im guessing that GHC is strictly speaking not Haskell2010 compliant?
04:53:20 <dminuoso> I mean Ive heard this a few times that things in standard haskell are different than in GHC
04:53:34 <dminuoso> (And Im not talking about explicit language extensions)
04:58:03 <frerich> dminuoso: I think you're right, see e.g. http://downloads.haskell.org/~ghc/master/users-guide/bugs.html
05:01:56 <dminuoso> ah, that was linked by geekosaur before, maybe I should read this from the beginning indeed. :)
05:36:57 * hackage conduit-extra 1.2.3 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.2.3 (MichaelSnoyman)
05:38:29 <frerich> jle`: I think your 'select' definition in today's AoC solution is quite neat, but to my surprise it appears to be a lot slower than my naive 'select as = [(y, xs ⧺ ys) | (xs, (y:ys)) ← zip (inits as) (tails as)]'. Do you know if that's maybe because the given lists are quite short, so the list concatenation I'm doing doesn't hurt as much?
05:39:54 <frerich> I couldn't think of the clever version (which you did) so I went for my first idea but felt bad because of the ++ :-]
05:46:21 <frerich> Hm yes, I think my version was just lucky...
05:48:19 * hackage ploton 1.1.0.0 - A useful cli tool to draw figures  https://hackage.haskell.org/package/ploton-1.1.0.0 (ishiy)
05:51:11 <huss`> http://m.memegen.com/e06inf.jpg
05:51:59 <fakenullie> it can become superset of haskell soon
05:52:13 <huss`> superset of everything
05:55:54 <dminuoso> I used to find the template system amazing for the never-seen-before strength to express things in a typing system.
05:55:57 <dminuoso> And then I learned haskell.
05:56:27 <dminuoso> And I find templates to be the one of the most unergonomic and offensive features in any language
05:58:23 <pavonia> Is there a way to get Numeric.floatToDigits show an infinite list of digits? I tried with CReal but that just yields an exception "CReal.floatRadix"
05:59:53 <fakenullie> you could write this yourself
06:01:20 <dminuoso> fakenullie: Doing this efficiently seems rather hard though.
06:01:41 <fakenullie> Yeah
06:01:50 <Yimo> hello, I wanted to ask : how can I declare a variable inside an if statement, in order to use it later?
06:02:11 <Yimo> well not "variable"
06:02:13 <dminuoso> Yimo: You can use `let` to create bindings inside expressions.
06:02:17 <fakenullie> I wonder if conversion to ratio gives exact float value
06:02:28 <dminuoso> Yimo: (which is the word you were looking for)
06:02:41 <Yimo> dminuoso can you give me an example (if you don't mind?) ^^
06:03:38 <dminuoso> > f x = if x > 10 then let double = (*2) in double x else x
06:03:41 <lambdabot>  <hint>:1:5: error:
06:03:41 <lambdabot>      parse error on input ‘=’
06:03:41 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:03:56 <dminuoso> huh
06:04:02 <Yimo> you see why I asked you now ? xD
06:04:14 <dminuoso> No Im.. why?
06:04:32 <Yimo> because every time I try such a thing, it's simply errors that I get
06:04:34 <dminuoso> > f x = if x > 10 then let double = (*2) in double x else x :: (Num a) => a -> a
06:04:36 <lambdabot>  <hint>:1:5: error:
06:04:36 <lambdabot>      parse error on input ‘=’
06:04:36 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:05:09 <yohotchoc> weird, that works in ghci for me
06:05:32 <dminuoso> Same.. I didn't present this before trying it in GHCi..
06:05:36 <glguy_> Ghci is permissive with allowing declarations at the top level
06:05:44 <dminuoso> Ah!
06:05:59 <glguy_> lambdabot: expects an expression after >
06:05:59 <dminuoso> @let magic x = if x > 10 then let double = (*2) in double x else x :: (Num a) => a -> a -- Yimo there you go
06:06:00 <lambdabot>  .L.hs:192:7: error:
06:06:00 <lambdabot>      • Couldn't match type ‘a’ with ‘a1’
06:06:00 <lambdabot>          because type variable ‘a1’ would escape its scope
06:06:01 <yohotchoc> Yimo: would using a where work for you?
06:06:31 <dminuoso> Well great! On the upside I know what that error means.
06:07:08 <glguy_> > if 'a' == 'b' then 1 else let x = 2 in x+x
06:07:09 <lambdabot>  4
06:07:26 <Yimo> yohotchoc I'm actually simply trying to compare 2 values a in 2 tuples of the form (a, b), and return the value b following the comparison
06:07:40 <dminuoso> glguy_: ^- is this a result of MonoLocalBinds implied by GADT or whatever extension pulled this in?
06:09:01 <dminuoso> Oh well, maybe I should just
06:09:05 <dminuoso> @let magic x = if x > 10 then let double = (*2) in double x else x
06:09:07 <lambdabot>  Defined.
06:09:18 <glguy_> dminuoso: Were you trying to give the type of magic inside its definition?
06:09:24 <Tuplanolla> I recently faced this myself with `let y = f x in g y` not type checking while `case f x of y -> g y` did.
06:09:59 <dminuoso> Oh. :)
06:09:59 <glguy_> dminuoso: and the result has a type that uses a type variable that you can't name
06:10:23 <Yimo> This is what I tried :
06:10:24 <Yimo> https://prnt.sc/hrqdko
06:10:28 <Yimo> This is the error I got :
06:10:31 <Yimo> https://prnt.sc/hrqdom
06:11:05 <POGtastic> can you show the whole function?
06:11:10 <glguy_> Yimo: I think you trimmed away too much context to know what went wrong
06:11:21 <POGtastic> (pastebin rather than screenshot, please)
06:11:47 <dminuoso> glguy_: I just mindlessly slapped the type on after not realizing that lambdabot wouldn't let me specify top level declarations with >
06:11:54 <dminuoso> and then carried this garabage along
06:12:05 <Yimo> This is the full script : http://lpaste.net/6751075680298991616
06:12:10 <Yimo> I mean code
06:13:04 <dminuoso> Yimo: Just rename it so it reads: enemy1 <- getLine; enemy2 <- getLine
06:13:44 <glguy_> Yimo: Line 26 needs a let like the other lines that used let to bind variables
06:13:57 <Yimo> it doesn't make a difference dminuoso btw
06:14:13 <Yimo> glguy_ oh, so let enemy = ?
06:14:42 <dminuoso> Yimo: No but it removes some clutter.
06:15:36 <Yimo> http://lpaste.net/6751075680298991616 now this has a different error : /tmp/Answer.hs:32:14: error:     • Couldn't match type ‘IO String’ with ‘[Char]’       Expected type: String         Actual type: IO String     • In the first argument of ‘putStrLn’, namely ‘(enemy)’       In a stmt of a 'do' block: putStrLn (enemy)       In the expression:         do let enemy1 = getLine            input_line <- getLine         
06:16:19 <glguy_> Yimo: This line and the other like it isn't reading a line "let enemy2 = getLine"
06:16:30 <glguy_> Yimo: It's naming the action that reads a line
06:16:50 <Yimo> ohhh
06:16:51 <Yimo> alright
06:17:16 <Yimo> okay, now the code is fine
06:18:29 <Yimo> I'm eager to learn haskell, it requires way different thinking than imperative programming language
06:18:34 <Yimo> I'm eager to learn haskell fully, it requires way different thinking than imperative programming language
06:18:53 <Yimo> oh, freenode doesn't allow editing pre-sent messages, too bad
06:19:00 <dminuoso> IRC does not.
06:19:04 <yohotchoc> ^
06:39:37 * hackage ihaskell 0.9.0.2, ipython-kernel 0.9.0.1, ghc-parser 0.2.0.1 (VaibhavSagar): https://qbin.io/ecyg4bwj1
06:39:58 <vaibhavsagar> \o/
06:40:03 <vaibhavsagar> so much power
06:42:02 <fakenullie> > toLazyByteString  $ doubleDec 0.2
06:42:04 <lambdabot>  error:
06:42:05 <lambdabot>      Variable not in scope: toLazyByteString :: t0 -> terror:
06:42:05 <lambdabot>      Variable not in scope: doubleDec :: Double -> t0
06:43:42 <vaibhavsagar> Hackage y u so slow
06:43:53 * hackage ihaskell-aeson 0.3.0.1, ihaskell-blaze 0.3.0.1, ihaskell-charts 0.3.0.1, ihaskell-diagrams 0.3.1.1, ihaskell-gnuplot 0.1.0.1 (VaibhavSagar): https://qbin.io/0sq41qneq
06:44:31 <Yimo> Having an array [] ( let m = [] ) , I want to add elements to that array. Anyone knows how I can do that?
06:44:48 <fakenullie> pavonia: maybe this does what you want http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Builder.html#v:doubleDec
06:45:16 <bor0> > 1 : 2 : 3 : []
06:45:18 <lambdabot>  [1,2,3]
06:45:24 <bor0> Yimo, you can use : operator as above
06:45:38 <POGtastic> > 0 : [1, 2, 3]
06:45:40 <lambdabot>  [0,1,2,3]
06:45:49 * hackage ihaskell-juicypixels 1.1.0.1, ihaskell-hatex 0.2.1.1 (VaibhavSagar): https://qbin.io/9rgygsnah
06:46:15 <POGtastic> if you want to add to the end of the array, that's a lot less efficient.
06:46:21 <POGtastic> > [1, 2, 3] ++ [4]
06:46:23 <lambdabot>  [1,2,3,4]
06:47:03 <pavonia> fakenullie: This is only for base 10, no?
06:47:09 * hackage ihaskell-widgets 0.2.3.2, ihaskell-plot 0.3.0.1, ihaskell-magic 0.3.0.1 (VaibhavSagar): https://qbin.io/1hwp4n6f
06:47:13 <fakenullie> fakenullie: I guess so
06:48:33 <pavonia> Also it's just for double, so no
06:49:43 <dminuoso> Yimo: Do note that you can't really "add" to a _list_. You're still locked into a very imperative mindset.
06:49:54 <dminuoso> Yimo: You can only have a new exprssion that consists of one list linked with another.
06:50:03 <dminuoso> *one element linked with a list
06:50:22 <dminuoso> The idea being that things are immutable in very mathematical sense.
06:50:30 <Yimo> dminuoso You're right, but I couldn't think of a way to actually get n getLine's (turn them into a Int) and store them into one array
06:50:55 <Yimo> it should be done in one go
06:50:58 <dminuoso> Yimo: Maybe it might be a good step to not focus on IO too much. Maybe start writing a few programs using nothing but `interact`
06:51:08 <Yimo> hm
06:51:09 <Gurkenglas> Yimo, http://hackage.haskell.org/package/base-4.10.1.0/docs/src/Control.Monad.html#replicateM shows how you can do it
06:51:52 <Yimo> dminuoso how did you learn haskell the first time?
06:51:56 <Gurkenglas> By the way, why does so much of base have that "= loop where loop =" pattern? It seems like something the compiler should do instead.
06:52:27 <dminuoso> Yimo: I first read the Gentle Introduction (which is anything but gentle), dived into category theory, and now Im starting from scratch using Real World Haskell again.
06:52:53 <Yimo> Thanks
06:53:47 <POGtastic> Learn You A Haskell has been nice to me... all the way until i start encountering things that i didn't encounter with lisp :(
06:55:00 <fakenullie> > toRational 0.2
06:55:02 <lambdabot>  3602879701896397 % 18014398509481984
06:55:25 <POGtastic> yay floating point
06:55:33 <fakenullie> is this exact?
06:55:54 <fakenullie> not exact 0.2 but exact floating point
06:55:57 <fakenullie> binary
06:56:05 <dminuoso> Yimo: The idea of focusing on `interact` (or a similarly rigged function using an input and output file) is pretty neat since it forces you to practice thinking in terms of data transformation with functions, function composition, etc.
06:56:33 <dminuoso> Yimo: During which a lot of thought processes like "store an list", "modify a list" completely disappear.
06:57:21 <fakenullie> > 3602879701896397 / 18014398509481984 :: Scientfic
06:57:24 <lambdabot>  error:
06:57:24 <lambdabot>      Not in scope: type constructor or class ‘Scientfic’
06:57:59 <fakenullie> I guess 18014398509481984 must be power of 2
06:58:26 <dminuoso> fakenullie: yup its 2^54
06:58:32 <dminuoso> Clearly.
06:58:39 <POGtastic> > logBase 2 18014398509481984
06:58:41 <lambdabot>  54.0
06:59:30 <fakenullie> pavonia: you can use that ratio to expand to any number of digits
07:01:31 <pavonia> Is Scientific infinite precision?
07:02:08 <fakenullie> pavonia: exponent is Int
07:03:57 <fakenullie> that means you can't increase coefficient infinitely
07:04:30 <fakenullie> Ratio Integer should have infinite precision
07:04:49 <fakenullie> > maxBound :: Integer
07:04:52 <lambdabot>  error:
07:04:52 <lambdabot>      • No instance for (Bounded Integer)
07:04:52 <lambdabot>          arising from a use of ‘maxBound’
07:05:05 <yohotchoc> > maxBound :: Int
07:05:08 <lambdabot>  9223372036854775807
07:05:22 <yohotchoc> oh you were making a point nvm
07:05:30 <Gurkenglas> Is there a centralized location for issues in Haskell github projects that outsiders can work on, or an easy way to find them?
07:05:46 <hpc> > floor (1/0) :: Integer
07:05:48 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:05:59 <fakenullie> heh
07:06:01 <pavonia> Scientific doesn't have a RealFloat instance. I guess I'll just write my own version using Ratio then
07:06:30 <yohotchoc> hpc: wat
07:06:50 <hpc> yohotchoc: it has to do with the bit encoding of IEEE double's +inf
07:07:09 <Gurkenglas> > findIndex (==0) $ iterate (`div` 10) $ (floor (1/0) :: Integer)
07:07:11 <lambdabot>  Just 309
07:07:20 <fakenullie> > isInfinite (1/0)
07:07:22 <lambdabot>  True
07:08:08 <pie__> everybody is gonna think this is really dumb but is it possible to put haskell function signatures in a separate file like c headers?
07:09:05 <hpc> pie__: it's a stretch, but you might be able to use {-# LANGUAGE CPP #-} and #include a file with only type signatures
07:09:11 <hpc> i don't know why you would bother though
07:09:45 <hpc> what problem are you trying to solve?
07:09:48 <fakenullie> can't you just import it?
07:09:55 <fakenullie> oh, signatures
07:14:44 <yohotchoc> I'm looking at the source of floor to try understand hpc's thing... What does (x:%y) match? (in the definition of properFraction)
07:16:04 <fakenullie> :t (:%)
07:16:05 <lambdabot> error:
07:16:05 <lambdabot>     • Data constructor not in scope: :%
07:16:05 <lambdabot>     • Perhaps you meant one of these:
07:16:51 <fakenullie> looks like infix data constructor to me, but what do I know
07:18:19 <fakenullie> yohotchoc: data  Ratio a = !a :% !a  deriving (Eq)
07:18:37 <yohotchoc> oh that makes sense yeah
07:22:08 <Tuplanolla> All I wanted for Christmas is people arguing IEEE 754.
07:22:21 <yohotchoc> I'm just really confused tbh
07:22:32 <yohotchoc> trying to figure out what exactly floor's doing to cause that
07:22:50 <yohotchoc> > floor (1/0) :: Int -- especially given this
07:22:51 <lambdabot>  0
07:24:05 <fakenullie> @src floor :: Int
07:24:05 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:24:51 <yohotchoc> http://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.Real.html#floor
07:25:47 <fakenullie> floor for int may have different implementation
07:26:03 <fakenullie> ahm, no, I must be wrong
07:27:41 <fakenullie> > properFraction (0/1) :: (Int, Int)
07:27:44 <lambdabot>  error:
07:27:44 <lambdabot>      • No instance for (RealFrac Int)
07:27:44 <lambdabot>          arising from a use of ‘properFraction’
07:29:22 <fakenullie> :t (1/0)
07:29:23 <lambdabot> Fractional a => a
07:30:11 <yohotchoc> @let (q, r) = properFraction (1/0)
07:30:12 <lambdabot>  Defined.
07:30:30 <yohotchoc> > (toInteger q, fromInteger $ toInteger q :: Int)
07:30:32 <lambdabot>  error:
07:30:32 <lambdabot>      Ambiguous occurrence ‘q’
07:30:32 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.q’,
07:30:40 * yohotchoc rolls eyes
07:30:45 <yohotchoc> @let (qqq, _) = properFraction (1/0)
07:30:47 <lambdabot>  Defined.
07:30:52 <yohotchoc> > (toInteger qqq, fromInteger $ toInteger qqq :: Int)
07:30:54 <lambdabot>  (179769313486231590772930519078902473361797697894230657273430081157732675805...
07:31:03 <yohotchoc> dammit, well the second one is 0
07:34:02 <fakenullie> maybe r gets negative
07:34:04 <yohotchoc> > qqq `mod` (2^64)
07:34:06 <lambdabot>  0
07:34:18 <yohotchoc> pretty sure that explains the Int version being 0 anyway
07:34:37 <fakenullie> > (snd $ properFraction (1/0)) :: Int
07:34:39 <lambdabot>  error:
07:34:39 <lambdabot>      • No instance for (RealFrac Int)
07:34:39 <lambdabot>          arising from a use of ‘properFraction’
07:34:50 <fakenullie> what the hell
07:35:45 <iqubic> > fromInteger $ toInteger qqq
07:35:47 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
07:35:57 * hackage mmark 0.0.3.2 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.3.2 (mrkkrp)
07:36:11 <fakenullie> > toInt qqq
07:36:13 <lambdabot>  error:
07:36:13 <lambdabot>      Variable not in scope: toInt :: Integer -> t
07:36:38 <fakenullie> > fromIntegral qqq :: Int
07:36:39 <lambdabot>  0
07:37:02 <fakenullie> that's interesting
07:37:33 <iqubic> > toInteger $ fromIntegral qqq :: Int
07:37:35 <lambdabot>  error:
07:37:35 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Integer’
07:37:35 <lambdabot>      • In the expression: toInteger $ fromIntegral qqq :: Int
07:37:55 <iqubic> What the heck?
07:39:11 <fakenullie> toInteger result in Integer
07:39:21 <iqubic> Oh.
07:39:44 <iqubic> toInteger (fromIntergral qqq :: Int)
07:40:13 <yohotchoc> that'll just give you 0
07:40:45 <iqubic> > toInteger (fromIntergral qqq :: Int)
07:40:48 <lambdabot>  error:
07:40:48 <lambdabot>      • Variable not in scope: fromIntergral :: Integer -> Int
07:40:48 <lambdabot>      • Perhaps you meant ‘fromIntegral’ (imported from Prelude)
07:41:12 <yohotchoc> well, 0 after you fix the typo :D
07:41:15 <iqubic> > toInteger (fromIntegral qqq :: Int)
07:41:17 <lambdabot>  0
07:41:21 <iqubic> Yeah.
07:41:25 <fakenullie> yohotchoc: fromInteger :: Integer -> Int truncates it?
07:41:32 <iqubic> What is qqq again?
07:42:45 <yohotchoc> yeah, once it's converted to an Int you've lost all the information, it's just 0
07:43:12 <yohotchoc> @let (qqq, rrr) = properFraction (1/0)
07:43:13 <lambdabot>  .L.hs:160:2: error:
07:43:13 <lambdabot>      Multiple declarations of ‘qqq’
07:43:13 <lambdabot>      Declared at: .L.hs:159:2
07:43:20 <yohotchoc> well, that's what it is, anyway
07:43:28 <yohotchoc> (rrr is just 0.0)
07:43:59 <yohotchoc> anyway I need to get back to studying :D
07:59:55 <dario_> hi, can someone help me somethinig, I have input of N lines and I can proccess the function with the result for one input, but how can I sum those values
08:00:42 <yohotchoc> dario_: not sure what you mean
08:00:52 <yohotchoc> it sounds like you're looking for a fold?
08:01:41 <dario_> I have input like 1 \n 2 \n 3 \n 4 \n . And I need to print how many of them are odd?
08:02:59 <yohotchoc> you probably want to convert that to a list of Int first to be able to do things with them
08:03:05 <yohotchoc> have you managed to do that?
08:03:42 <tsm_> is there a shorthand for exporting all data constructors without the record functions? e.g. like `Data (..)`
08:04:53 <dario_> For that I need to declare local variable and I don't know if that is possible in do block
08:05:09 <yohotchoc> how are you currently doing it?
08:05:21 <yohotchoc> (you can put code on lpaste to share it if you want to show code)
08:05:42 <tsm_> use case: I have types with many constructors which are all records (so have the partial functions). I don't want the partial functions exposed, but I do want the constructors. The partial functions are used by aeson for generating nicer field names
08:06:14 <yohotchoc> I think the closest to that I've done I used patterns
08:06:24 <yohotchoc> but it was very manual and an absolute pain in the hole
08:11:07 <iqubic> dario_: use "let foo = bar" in a do block.
08:11:41 <yohotchoc> ?
08:11:55 <yohotchoc> he's disconnected now anyway
08:22:39 <dminuoso> Is `variable` actually an accurate term?
08:23:05 <dminuoso> Mmm, well the Haskell report uses the name.
08:23:17 <yohotchoc> it's an immutable variable
08:23:25 <yohotchoc> which is a bit paradoxical but hey
08:23:34 <dminuoso> An invariant variable.
08:23:37 <dminuoso> You mean. ;-)
08:23:41 <yohotchoc> :D
08:23:41 <dminuoso> Invariable variable.
08:23:59 <yohotchoc> I mean hey, if flammable and inflammable can mean the same thing...
08:24:08 <dminuoso> They can?
08:24:09 <iqubic> They can?
08:24:18 <yohotchoc> they mean the same thing yeah
08:24:26 <yohotchoc> different etymological roots
08:24:31 <dminuoso> Oh I see what you are getting at.
08:24:42 <dminuoso> The `in` does not negate, it just implies you can `inflame` it
08:24:58 <yohotchoc> oh nevermind, both are Latin roots
08:25:01 <yohotchoc> but yup, that's it
08:25:10 <dminuoso> Your loss. Could have won 10 bucks in a bet with that.
08:25:30 <yohotchoc> inflammable's dropped out of use for the most part though, while flammable's only gone up in use
08:26:02 <yohotchoc> it does give you this fun list of synonyms though https://i.imgur.com/SpLQiQa.png
08:27:15 <Eduard_Munteanu> I guess you can interpret it as in "type variable", i.e. it can have different values.
08:27:48 <dminuoso> Eduard_Munteanu: Kind of in time-varying manner you mean?
08:28:06 <yohotchoc> how do you apply that reasoning to something like let x = 1?
08:28:08 <Eduard_Munteanu> dminuoso, no
08:28:18 <yohotchoc> that ain't changing
08:28:54 <Eduard_Munteanu> I mean x could be 1 or could be 2
08:29:18 <dminuoso> Eduard_Munteanu: Oh, so in the way that when you look at how `x` is used you don't care, it could be anything.
08:29:57 <Eduard_Munteanu> Yeah. By the way, they use "constant variable" in other languages like C as well.
08:30:15 <yohotchoc> ah, dminuoso's phrasing makes sense
08:30:43 <yohotchoc> in that case it tends to make more sense since it being constant is a modifier on the normal "variable"
08:34:54 <dminuoso> Eduard_Munteanu: So all `let x = 1` does is just binding the variable to the value of `1`, much in the same way that a variable in a parameter-position pattern would bind to the matched value?
08:37:04 <Eduard_Munteanu> I guess so. Which doesn't imply any sort of mutability.
08:38:38 <Eduard_Munteanu> Type variables are immutable too.
08:41:13 <dminuoso> Eduard_Munteanu: I guess so, and considering relationship to first-class logic where x in `∀x. ...` is called a predicate variable
08:41:51 <dminuoso> The idea really does seem to mean "can have different values" rather than "can be mutated"
08:42:03 <dminuoso> Thank you, this was enlightening. :)
08:44:23 <POGtastic> well, it works... it's uglier than sin though. https://repl.it/@pogtastic/LankyUnfitAmericancrocodile
08:44:56 <POGtastic> in python i'd probably use a dictionary. i know that haskell has Data.Map
08:45:42 <POGtastic> repl.it is the bomb-diggity, by the way.
09:16:33 <Yimo> hey guys, is it me or !! only works in GHCi ?
09:17:01 <hpc> how are you using it?
09:17:47 <Yimo> getting the element out of a list by index ; let m = [2,5,9,7,6,3] !! 2
09:18:27 <dmwit> It is you.
09:18:32 <hpc> is that what you put in a .hs file as well?
09:18:42 <Yimo> mm
09:18:44 <dmwit> I would bet, if anything, it is the `let` that only works in GHCi.
09:18:50 <hpc> top-level definitions in a file don't use "let"
09:18:53 <POGtastic> > [1..5] !! 3
09:18:55 <lambdabot>  4
09:19:03 <Yimo> ah alright
09:19:03 <hpc> more specifically, ghci pretends to be a giant do-block
09:19:37 <Yimo> that clears it up, appreciated
09:20:23 <Yimo> now it works
09:20:45 <Yimo> let is only allowed within an expression like do ?
09:20:54 <dminuoso> Yimo: any expression.
09:21:00 <Yimo> (or if)
09:21:05 <Yimo> alright ty
09:21:19 <dmwit> `let` with no `in` is special to `do` blocks. `let` with `in` is allowed in any expression.
09:21:21 <dminuoso> Yimo: please note that "do" is a bit special in the sense that its a lot of syntax sugar.
09:21:43 <Yimo> alright, got it
09:22:49 <dminuoso> Yimo: And like I said, the faster you focus on writing code outside `do` for a bit a lot of this will become more obvious :)
09:22:52 <dminuoso> use
09:22:54 <dminuoso> :t interact
09:22:55 <lambdabot> (String -> String) -> IO ()
09:31:20 <Yimo> admittingly, interact is indeed useful
10:12:44 <pierrot> Hello. I have a variable `port :: Int` and I want to create a `PortNumber` value from it. How can I do it?
10:13:13 <fakenullie> PortNumber port
10:13:39 <pierrot> it gives me a type error
10:13:53 <fakenullie> how is PortNumber defined
10:14:08 <dmwit> pierrot: `fromIntegral`
10:14:43 <dmwit> fakenullie: It's abstract. https://hackage.haskell.org/package/network-2.6.3.2/docs/Network.html#t:PortNumber
10:14:59 <dmwit> :t fromIntegral
10:15:00 <lambdabot> (Num b, Integral a) => a -> b
10:15:00 <monochrom> Yes, please use fromIntegral
10:15:12 <pierrot> Oh, `fromIntegral`
10:15:15 <pierrot> thanks :)
10:15:35 <dminuoso> fakenullie: in fact the documentation explicitly says not to use PortNumber :-P
10:15:40 <dmwit> Also the whole "`PortNumber` is a type, and `PortNumber` is a constructor for a type that isn't `PortNumber`" is confusing as heck.
10:15:42 <dminuoso> *PortNum even
10:16:12 <fakenullie> yeah, sorry, I thought it was his own type
10:16:50 <dminuoso> In all fairness it still could be. =P
10:17:40 <dmwit> Also also, the Haskell numeric hierarchy is weird. Being forced to define `negate :: PortNumber -> PortNumber` just because you want `fromInteger :: Integer -> PortNumber` is... unfortunate.
10:17:59 <dmwit> Or, like, `(*) :: PortNumber -> PortNumber -> PortNumber`.
10:18:38 * monochrom takes the gcd of port 1024 with port 993
10:19:37 <hpc> you haven't lived until you write a program that needs Ratio PortNumber
10:19:45 <monochrom> haha
10:35:00 <dminuoso> > foldl (:) [] [1,2,3,4]
10:35:02 <lambdabot>  error:
10:35:03 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
10:35:03 <lambdabot>        Expected type: [a] -> [a] -> [a]
10:35:07 <dminuoso> Am I naive to expected this to work?
10:35:22 <dminuoso> > foldl (flip :) [] [1,2,3,4]
10:35:24 <lambdabot>  error:
10:35:24 <lambdabot>      • Couldn't match type ‘[(a -> b -> c) -> b -> a -> c]’
10:35:24 <lambdabot>                       with ‘Integer -> [(a -> b -> c) -> b -> a -> c]’
10:35:28 <dminuoso> I mean. :o
10:36:21 <dminuoso> > foldl (\a b -> b : a) [] [1,2,3,4]
10:36:23 <lambdabot>  [4,3,2,1]
10:36:25 <fakenullie> dminuoso: it's flip (:)
10:36:38 <dminuoso> Oi.
10:36:40 <fakenullie> (flip :) is a section
10:36:50 <fakenullie> ing?
10:36:53 <dminuoso> Yes indeed it is, thanks :)
10:36:59 <dminuoso> > foldl (flip (:)) [] [1,2,3,4]
10:37:01 <lambdabot>  [4,3,2,1]
10:37:32 <dmwit> :t iterate (flip :) []
10:37:33 <lambdabot> [[(a -> b -> c) -> b -> a -> c]]
10:38:36 <dmwit> gonna give you a flipping breathalyzer
10:57:45 <Yimo> can I do something like rhis ? : v = do let x = 5 let m = 6 return x+m
10:57:55 <Yimo> (not in one line btw)
10:58:14 <dmwit> Sure. You just need parens around `x+m`.
10:58:23 <Yimo> alright
10:58:36 <dmwit> > do { let { x=5 }; let { m=6 }; return (x+m) } :: [Int]
10:58:38 <lambdabot>  [11]
10:59:22 <Yimo> haskell is neat
10:59:56 <Jacoby6000> Does anybody here use leksah?
11:00:46 <dmwit> ?where justask
11:00:46 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
11:01:20 <Jacoby6000> eh. I was just wondering how many people use it compared to other IDEs. Also what the general opinion of it is.
11:02:14 <Jacoby6000> My normal workflow is write code, save, check compiler errors, repeat. So I wonder how useful it'll be
11:03:20 <Yimo> leksah is made in haskell, now that's interesting
11:04:00 <fakenullie> Jacoby6000: many ides have Haskell plugins
11:04:00 * hackage ethereum-analyzer 3.3.3 - A Ethereum contract analyzer.  https://hackage.haskell.org/package/ethereum-analyzer-3.3.3 (zchn)
11:04:00 <monochrom> I haven't needed leksah or any IDE.
11:04:32 <Yimo> Is it possible that a computer gets designed to work using functional programming languages ?
11:04:47 <Yimo> because clearly, from the way the RAM works, it's into storing and changing "variables"
11:05:02 <Tuplanolla> Look up Symbolics Genera, Yimo.
11:05:19 * hackage ethereum-analyzer-cli 3.3.3, ethereum-analyzer-webui 3.3.3, ethereum-analyzer-deps 3.3.3 (zchn): https://qbin.io/h50hd0d5
11:06:12 <dmwit> I believe the reduceron was designed for graph reduction of the kind one often does with functional programming evaluation.
11:08:27 <Jacoby6000> Is the intellij plugin better than just using leskah?
11:13:20 * hackage epub-tools 2.10 - Command line utilities for working with epub files  https://hackage.haskell.org/package/epub-tools-2.10 (DinoMorelli)
11:19:55 <dminuoso> Yimo: strictly speaking.. I know that theres compilers producing hardware description (used to create cicuitry from) written in Haskell. So yeah. =P
11:20:13 <dminuoso> Using functional programming languages one can design how a computer works. =P
11:24:08 <dmwit> I think he meant "is there a way to design a CPU to support functional programming more directly". And the "from the way the RAM works" comment was about the apparently fundamental mismatch between mutable memory and the immutability that is common in functional data structures.
11:25:01 <dminuoso> dmwit: Oh I understood that. I hoped the smileys at the end denoted would have conveyed the irony.
11:25:10 <dmwit> oh
11:29:30 <geekosaur> think about it a bit
11:29:59 <geekosaur> arguably both analog and quantum computers could be 'purely functional' in a way digital can't
11:30:18 <geekosaur> (for some definition of 'pure')
11:32:07 <geekosaur> but digital thinks more like our brains do (small steps, well defined states)
11:32:46 <geekosaur> well, our cognition. neural substrate is closer to analog
11:32:53 <hpc> geekosaur: when i looked at Q# there were definitely some hints of a functional language in it
11:34:42 <dminuoso> hpc: I tried thinking of type variables as types in superposition!
11:34:54 <dminuoso> Needless to say, it wasn't helpful.
11:36:50 <monochrom> Quantum is greatly misunderstood by most programmers.
11:38:22 <monochrom> Probability and nondeterminism are pretty classical, not quantum. They are not the point of quantum.
11:39:15 <monochrom> The point of quantum is destructive interference, equivalently complex numbers that may cancel each other. You can't get this from probability and nondeterminism.
11:39:34 <dminuoso> monochrom: Well the nondeterminism in quantum superposition gives you exponential degrees of freedom so to speak. The amount of information you can deal with with just 5 qubits is a lot more.
11:39:38 <geekosaur> I'd argue quantum is not well understood by even physicists, and probability is the only correct way to understand it
11:40:05 <dminuoso> monochrom: Everything I have looked at seems to imply that nondetermism is a rather important part of QC.
11:40:09 <fakenullie> accurately computable probability
11:40:11 <geekosaur> for example, the EPR "paradox" is only a paradox if you treat probabilities as something 'real' instead of as a statementr of your knowledge
11:41:09 <geekosaur> but QM interpretations (Borh/Copenhagen, many worlds, etc.) do exactly that
11:41:15 <geekosaur> *Bohr
11:41:55 <monochrom> You need to read Scott Aaronson's book. He actually studies computational complexity issues under quantum. You will find that even the "exponential" part is under doubt.
11:42:56 <geekosaur> sure. I think 'exponential' is an oversimplification people use to try to understand it. But it's just different and works in ways our cognition doesn't
11:43:04 <monochrom> Part of it is because "how many bits can you extract anyway?" but there are also other issues.
11:43:25 <geekosaur> Similarly analog --- there are still analog 'computers' in use because they get an answer in under a minute ti problems that digital simulations take days to solve
11:44:15 <monochrom> And just to be clear, I am not saying that quantum does not contain probability or nondeterminism.
11:44:22 <geekosaur> take a look at how theory of limits in math actually works. it's simple DSP for our essentially digital cognition :)
11:44:51 <monochrom> I am saying that probability and nondeterminism alone, which is what most programmers imagine, is not enough.
11:45:20 * dmwit . o O ( Both the conversation monochrom is having and the conversation geekosaur is having are interesting ones. )
11:45:33 <geekosaur> yes, they're somewhat disjoint
11:45:56 <geekosaur> about all they share at this point is where they started
11:46:12 <monochrom> Mere gas laws already have probability and nondeterminism. They lack complex numbers, so they lack entanglement for example.
11:46:53 <geekosaur> ideal gas law. a 'real' gas law would have to account for entanglement
11:47:09 <geekosaur> but we like our oversimplifications
11:57:18 <huss`> looking at the signature of a lens, could it be used to fold ?
11:57:46 <dmwit> :t foldMapOf
11:57:47 <lambdabot> Getting r s a -> (a -> r) -> s -> r
11:58:00 <huss`> dmwit: ohh thanks :)
11:58:07 <dmwit> :t foldrOf -- etc.
11:58:08 <lambdabot> Getting (Endo r) s a -> (a -> r -> r) -> r -> s -> r
11:58:44 <monochrom> https://www.youtube.com/watch?v=zcqZHYo7ONs  --- Start with two polaroids that together block out light. Then add a third one in the middle to unblock. Probability and nondeterminism are not enough for this.
12:00:03 <geekosaur> seems to me like probability is... but it's hard enough to figure out that the oversimplication is far easier to work with
12:00:37 <geekosaur> (I did recently try re-envisioning radio in terms of probabilistic photons instead of waves. I think it's doable... but it's NASTY.)
12:01:51 <monochrom> geekosaur: Basically you first add up the complex numbers to let them enhance each other or cancel out each other. After that you can turn the sum into a probablity. Just don't take probabilities before summing.
12:01:59 <geekosaur> in QM 'waves' are probabilistic constructs, so this actually has to work. but you might as well be doing the hairiest parts of QED to figure out even simple stuff
12:02:11 <geekosaur> sure
12:02:40 <monochrom> Premature taking absolute values is the root of classical physics?
12:02:52 <geekosaur> pretty much
12:03:19 <geekosaur> and playing with this stuff at this level is like trying to solve simple ballistics problems with GR
12:03:46 <geekosaur> massive overkill and you'll go nuts trying to do it, when there;s a massive simplification that gets you the right answer in most contexts we care about
12:04:32 <geekosaur> *nobody*'s figuring quaternions to figure out the trajectory fo a thrown ball
12:04:56 <monochrom> Oh I stick with classical physics, even non-probabilistic determinism, when doing von-Neumann computing or even functional programming.
12:17:15 <dminuoso> Is there a simple way to have QuickCheck generate [[Int]] such that the length of each inner list is the same?
12:17:39 <dminuoso> (i.e. I need it to be a matrix)
12:18:35 <ClaudiusMaximus> generate a pair of lengths, and make a longer list n*m and chunk it up, is probably what i would do
12:18:43 <dmwit> do { (m, n) <- arbitrary; replicateM m (replicateM n arbitrary) }
12:19:19 * dmwit high fives ClaudiusMaximus 
12:19:42 <ClaudiusMaximus> :)
12:19:43 <dmwit> You might want `(Positive m, Positive n) <- arbitrary`, I guess.
12:20:08 <dmwit> And you might also want to have a maximum length...
12:23:50 * hackage siren-json 0.1.2.0 - Siren Tools for Haskell  https://hackage.haskell.org/package/siren-json-0.1.2.0 (alunduil)
12:44:38 <dminuoso> dmwit: Something along those lines? https://gist.github.com/dminuoso/7d6b0f7cc146525cf5584ea6802b02ba
12:44:51 <dminuoso> Thank you by the way, still figuring out how to use QuickCheck :)
12:44:56 <dmwit> Sure.
12:45:12 <dmwit> I think there's also a way to generate a number in agiven range directly rather than rejection sampling like that.
12:46:28 <dminuoso> Mmm, there is: choose :: Random a => (a, a) -> Gen a
12:48:50 <dminuoso> do { m <- choose (0, 10); n <- choose (0, 10); replicateM m (replicateM n (arbitrary :: Gen Int)) }
12:48:55 <dminuoso> Seems to do the trick. Thanks :)
13:01:29 <karce> Would anyone mind showing me a Haskell project that is a good example of modern convention or just good code?
13:02:06 <nash_> conduit question: I'm trying to create a back-end agnostic data source for an ETL. Hit a roadblock when trying to read from S3 (using amazonka-s3 getObject) or database (using Persistent selectSource). both amazonka and persistent support streaming data as a conduit, but they require the data is also sunk inside their own monad. is there no way to _just_ extract a stream outside their monad?
13:02:47 <nash_> reason being, the application is meant to do some processing before sinking records back into a generic backend (file, s3 or db).
13:11:21 <dmj`> Anyone know how to parse fractional seconds with time
13:12:06 <dmj`> I’m trying,  > parseTimeM True defaultTimeLocale $ iso8601DateFormat (Just "%H:%M:%S.%S")
13:12:13 <dmj`> on "2014-07-09T07:22:16.72
13:12:20 <dmj`> but get, 2014-07-09 07:23:12 UTC
13:12:22 <Xal> %Q "decimal point and fraction of second, up to 12 second decimals, without trailing zeros"
13:12:51 <dmj`> Xal: thanks, that was it
13:12:52 <dmj`> Just "%H:%M:%S%Q"
13:12:59 <dmj`> Xal++
13:23:49 <ph88> why is exitSuccess not working here?  https://bpaste.net/show/f884141f0336  https://bpaste.net/show/244524cb9110
13:24:12 <nash_> this looks promising: sequenceSink (https://www.yesodweb.com/blog/2012/01/conduits-conduits). will try that.
13:30:55 * hackage cabal-bounds 1.3.0 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-1.3.0 (DanielTrstenjak)
13:47:59 <glguy_> You'd need to run exitSuccess from the main thread for it to kill the program
13:48:51 <ph88> glguy_, how can you tell it's not in the main thread right now ?
13:49:16 <yohotchoc> probably because it's not killing the program :D
13:49:53 <ph88> but the signal handler is the first action in main .. and here it's not put in the main thread ??
13:50:42 <fakenullie> do signals go to main thread?
13:50:48 <monochrom> No, they don't.
13:51:07 <monochrom> Have you read the doc? It already says "signal handler is run in a brand new thread"
13:51:19 <monochrom> You do an exitSuccess there, you're doing nop.
13:52:00 <ClaudiusMaximus> maybe something like   main = do{ tid <- myThreadId ; gracefulTerminate tid .... ; }  gracefulTerminate tid = ... throwTo tid ExitSuccess //
13:52:10 <ClaudiusMaximus> modulo what the functions are actually called
13:53:33 <ph88> monochrom, how can i shut down the program normally from the signal handler ?
13:54:09 <dmwit> I suppose you'll have to send a message to the main thread.
13:54:15 <ph88> ok
13:54:18 <monochrom> You code up main to wait for a "please quit message". Or you kill main.
13:54:52 <ph88> if i kill main will i still get a good .prof file when profiling ?
13:55:30 <monochrom> I don't know.
13:56:59 <monochrom> I'm beginning to wonder if this is an XY problem.
13:57:15 <Yimo> Is it possible to zip 3 arrays?
13:58:14 <monochrom> The standard library already has a way to notice SIGINT, turn it into an ordinary Haskell exception, throw it, and you can catch it. All without touching unix signals yourself at all.
13:58:19 <fakenullie> Yimo: zip3 lists
13:58:38 <Yimo> fakenullie what about n lists?
13:58:42 <monochrom> Read the doc of Control.Exception and look for the type "AsyncException" and its data constructor "UserInterrupt".
13:58:52 <monochrom> All you need to do is to catch it.
13:59:01 <fakenullie> Yimo: I think that's just transpose
13:59:11 <Yimo> alright
13:59:43 <monochrom> It pays to have read the doc from cover to cover. As opposed to randomly running into ad-hoc Stackoverflow Q&A's.
13:59:54 <dminuoso> fakenullie: well zip itself is just a special case of transpose too! :)
14:00:22 <iqubic> What is transpose?
14:00:27 <dminuoso> :t transpose
14:00:29 <lambdabot> [[a]] -> [[a]]
14:00:37 <dminuoso> iqubic: Matrix transposition.
14:01:08 <kamyar> Hello guys
14:01:15 <iqubic> :t zip
14:01:16 <lambdabot> [a] -> [b] -> [(a, b)]
14:01:17 <dmwit> zip is only sort of a special case of transpose. It can handle lists with two different types.
14:01:22 <iqubic> I see.
14:01:33 <kamyar> I just wanna run a function with no parameters a specific time
14:01:34 <iqubic> So tranpose swaps rows with columns
14:01:42 <ph88> do forkOS and forkIO have both thread id's ?
14:01:44 <kamyar> for example 100 times
14:01:55 <iqubic> kamyar: What is the function?
14:02:12 <dminuoso> iqubic: You could think of `zip l r` as `transpose [l, r]`
14:02:13 <kamyar> I cant use forM [1..100] myFunc
14:02:25 <iqubic> Why not?
14:02:27 <dmwit> :t replicateM
14:02:28 <lambdabot> Applicative m => Int -> m a -> m [a]
14:02:33 <kamyar> since myFunc does not get Int as input
14:02:41 <dmwit> % replicateM 3 (putStr "hi, kamyar! ")
14:02:41 <yahb> dmwit: hi, kamyar! hi, kamyar! hi, kamyar! [(),(),()]
14:02:59 <kamyar> dmwit: thanks
14:03:00 <dmwit> % replicateM_ 3 (putStr "now with less extraneous return ")
14:03:00 <yahb> dmwit: now with less extraneous return now with less extraneous return now with less extraneous return
14:03:12 <dminuoso> iqubic: of course if you consider an isomorphism between (a,b) ~~~ [a, b]
14:03:12 <dmwit> :t replicateM_
14:03:13 <lambdabot> Applicative m => Int -> m a -> m ()
14:03:28 <ph88> did error message improve in ghc 8 ? cool
14:03:33 <dminuoso> ph88: Yes they did! :)
14:03:36 <dmwit> what is [a, b]
14:03:41 <iqubic> yahb: ls
14:03:43 <dminuoso> ph88: No more skolem type variables
14:03:50 <iqubic> % ls
14:03:50 <yahb> iqubic: ; <interactive>:9:1: error: Variable not in scope: ls
14:03:53 <ph88> dminuoso, what's that ?
14:04:03 <dminuoso> Yes exactly!
14:04:03 <monochrom> There is no isomorphism between (Int, Bool) and any list type.
14:04:42 <dminuoso> monochrom: Mmm fair enough.
14:05:04 <fakenullie> I think there's a way to compose zips to get any number of lists you want
14:05:32 <dmwit> Yes, use ZipList.
14:06:01 <dmwit> :t \f x y z -> f <$> ZipList x <*> ZipList y <*> ZipList z
14:06:03 <lambdabot> (a1 -> a2 -> a3 -> b) -> [a1] -> [a2] -> [a3] -> ZipList b
14:06:34 <dmwit> (<*>) is `zipWith`; (<$>) is `repeat`.
14:06:44 <dminuoso> Okay Im amazed about QuickCheck now.. how does arbitrary.. uh. How does it know what to do when I specify `(Positive a, Positive b) <- arbitrary` ?
14:06:47 <dmwit> Well. (<*>) is `zipWith ($)`, I guess.
14:07:06 <monochrom> Yeah.
14:07:33 <amalloy> dminuoso: Positive is a newtype with an Arbitrary instance
14:07:55 <monochrom> dminuoso: Your (Positive a, Positive b) pattern determines type. Type determines which instance to use.
14:07:55 <dmwit> dminuoso: The `Positive` constructor gives a hint to type inference. Then the inferred type fixes an instance of `Arbitrary`.
14:08:12 <monochrom> Instance contains actual code.
14:08:14 <dmwit> whew. I was the slowest this time
14:08:29 <dminuoso> I actually smiled when I got 3 answers in that rapid succession.
14:08:36 <dminuoso> Thanks. :)
14:09:37 <monochrom> > maxBound :: Maybe Int
14:09:38 <lambdabot>  error:
14:09:39 <lambdabot>      • No instance for (Bounded (Maybe Int))
14:09:39 <lambdabot>          arising from a use of ‘maxBound’
14:09:43 <monochrom> Darn
14:12:12 <fakenullie> what would that be
14:12:48 <monochrom> I was hoping it would become Just (maxBound :: Int)
14:13:23 <amalloy> yeah, why isn't there an instance (Bounded a) => Bounded (Maybe a)?
14:13:32 <fakenullie> > Just maxBound :: Maybe Int
14:13:34 <lambdabot>  Just 9223372036854775807
14:13:56 <fakenullie> because that would be just this
14:14:08 <amalloy> so?
14:14:15 <amalloy> that's useful
14:15:05 <geekosaur> because Bounded is incestuous with Enum (and has to be for deriving to work), but Enum doesn't support constructors with parameters
14:15:40 * dmwit . o O ( fromEnum (maxBound :: Maybe Int) )
14:15:57 <monochrom> I would have trouble deciding whether minBound should be Nothing or should be Just (minBound)
14:16:07 <dmwit> I think `Nothing` is the clear answer here.
14:16:12 <geekosaur> or at least Enum deriving doesn;t, because you have to make decisions about how they relate... basically what monochrom just said
14:16:13 <dmwit> > Nothing < Just (minBound :: Int)
14:16:14 <lambdabot>  True
14:16:55 <geekosaur> you could also say it's underspecified *and* that we need a Ranged typeclass because Enum+Bounded is trying to simulate that, poorly
14:17:33 <dmwit> I would be very surprised to find an `x` for which `x < minBound` or `x > maxBound`. I also find `Double` very surprising, so don't try to spring some stupid NaN trap on me here.
14:17:40 <geekosaur> (and often can't make up its mind whether it wants to be a bounded enumeration or a bounded continuous range)
14:17:43 <monochrom> It's Christmas, let's also wish for a Deranged class while we're at it. :)
14:18:42 <geekosaur> isn;t that Num? :p
14:18:47 <monochrom> hahaha
14:19:11 <dminuoso> monochrom: So Im guessing the fact that there is no explicit (Positive a, Positive b) instance has something to do with Arbitrary2 doing this automagic lifting?
14:19:19 <dmwit> no no
14:19:24 <dmwit> There is an `Arbitrary (a, b)` instance.
14:19:35 <dminuoso> Ohh.
14:19:37 <dmwit> It demands `(Arbitrary a, Arbitrary b)` in its context.
14:19:43 <monochrom> Embrace recursive descent.
14:19:55 <dminuoso> What deep magic is this.
14:20:19 <monochrom> You know how no one writes "instance Ord [Int]", right?
14:20:19 <dmwit> So the search tree goes `(Arbitrary a, Arbitrary b) => (Arbitrary (Positive a), Arbitrary (Positive b) => Arbitrary (Positive a, Positive b)`.
14:20:39 <dminuoso> So this is why the constraint must be smaller than the instance head, so that if when the typechecker follows alice that it's guaranteed to halt?
14:20:48 <dmwit> I missed one parenthesis before the second `=>`.
14:20:55 <monochrom> You only need one "instance Int" and one "instance Ord a => Ord [a]". Then recursive descent will combine them to give you Ord [Int]. You already understand that, right?
14:20:57 <dmwit> dminuoso: correct
14:21:35 <monochrom> err "instance Ord Int"
14:21:50 <dmwit> (Actually, "search tree" is correct but misleading. Haskell has arranged things so that it is always a "search path"; the tree never branches.)
14:24:22 <monochrom> > maxBound :: (Int, Bool)
14:24:24 <lambdabot>  (9223372036854775807,True)
14:24:28 <dmwit> (...and then it arranged for a language pragma to allow branches, but it does not search both branches. It picks one and crosses its fingers. And then people ask why their program broke.)
14:24:28 <monochrom> \∩/
14:25:58 <dminuoso> dmwit: And ultimately the compiler needs to follow that proof based on some generic usage of Arbitrary (a, b) right?
14:26:24 <dmwit> I did not understand this question.
14:26:57 <dminuoso> dmwit: Let me rephrase. Is there some good outline that demonstrates how the compiler actually.. handles these types/constraints? I mean it feels like the compiler has to make proofs about types.
14:27:22 <monochrom> I know of a detailed outline. I don't know whether it fills your idea of "good".
14:27:32 <monochrom> But look for "typing haskell in haskell".
14:27:58 <dmwit> Oh, that's easy. It just looks at the type and the list of instances it knows. If any match, it replaces the constraint with the constraints demanded by the instance it chose. Eventually it will get to a point where no instances match, and then that becomes the context of your type.
14:28:02 <monochrom> But if you already know Prolog or Mercury, it's similar, just less powerful/flexible.
14:28:05 <ertes> which haddock flags do i need for hackage doc uploads?  i have a script to do it, but it's outdated and doesn't link some things properly
14:28:39 <geekosaur> ertes, don;t both cabal-install and stack have options for that these days? *** haddock --for-hackage
14:28:40 <monochrom> I wouldn't call haddock directly. I would use "cabal haddock".
14:29:05 <ertes> geekosaur: no other flags needed?
14:29:07 <monochrom> But you can do "cabal haddock -v" (or -v3?) to see how it calls haddock, then you can steal those flags.
14:29:10 <ertes> monochrom: yeah, that's what i'm doing
14:29:14 <geekosaur> it should supply the other flags itself
14:29:26 <ertes> except "./Setup haddock" rather "cabal haddock"
14:29:32 <dmwit> e.g. if it has `Arbitrary (Positive a, Whangamajig b)`, it says -- hey, I've got an instance for tuples! Now my context is `(Arbitrary (Positive a), Arbitrary (Whangamajig b))`. Then it goes, hey, that first one -- I've got an instance for `Positive`! So now it's `(Arbitrary a, Arbitrary (Whangamajig b))`. And now it doesn't know any further instances, so the inferred type is `(Arbitrary a, Arbitrary (Whangamajig b)) => ...`.
14:29:36 <ertes> geekosaur: ok, thanks
14:29:43 <geekosaur> just include --for-hackage in the cabal or stack hgaddock command, and add -v3 to see what it feeds haddock
14:29:46 <monochrom> And you will regret it. Because it is like 12 flags, each 40 characters long.
14:30:09 <dminuoso> monochrom: I think.. that could be what I was looking for (though its far more detailed than what I had hoped for) - but it seems readable at my level of expertise. .
14:30:11 <ertes> well, i'm not too interested in the actual flags…  i just want docs uploaded =)
14:30:29 <monochrom> I know because I once was curious. Overloaded my brain, I had to reboot it.
14:30:41 <ertes> that sounds almost lovecraftian
14:31:19 <ertes> i KNEW there was cosmic horror lurking in the depths of haskell's toolchain
14:31:23 <monochrom> "Curiosity killed the cat. Satisfaction brought it back!"
14:31:52 <monochrom> Oh do a "cabal build -v3" some time to spam yourself. :)
14:32:09 <ertes> that would be a nice cabal easer-egg
14:32:25 <ertes> "cabal cthulhu" outputs a randomly generated LaTeX error message
14:33:49 <kamyar> Hi Haskelllers!
14:34:01 <kamyar> I wanna get the time of execution of a function
14:34:05 <kamyar> How can I do it?
14:34:23 <dmwit> ?hackage timeit
14:34:23 <lambdabot> http://hackage.haskell.org/package/timeit
14:34:26 <dmwit> ?hackage criterion
14:34:26 <lambdabot> http://hackage.haskell.org/package/criterion
14:34:28 <ertes> kamyar: you can get various CPU and memory stats by using criterion
14:34:51 <kamyar> ertes: I just need the time
14:35:00 <kamyar> ertes: I am writing some performance testing code
14:35:19 <dmwit> Perhaps you would prefer to run a profiling-enabled executable.
14:35:26 <kamyar> ertes: I call some http API and check its response time
14:35:36 <ertes> kamyar: you should probably use criterion anyway
14:35:36 <dmwit> Ooop, never mind.
14:35:54 <ertes> kamyar: oh
14:36:18 <dmwit> For reference, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html, but profiling is probably not the right tool for timing HTTP APIs.
14:36:29 <ertes> kamyar: in that case just use 'time' (diffUTCTime) or 'clock' ((-))
14:37:12 <kamyar> ertes: Does Haskell lines run sequentially? I dont think so
14:37:30 <ertes> kamyar: sequencing is done by IO's (>>=)
14:37:45 <ertes> it's not related to source code order
14:37:52 <kamyar> ertes: Yes! You mean 'do'
14:38:05 <ertes> kamyar: IO actions in a do-block will run sequentially
14:38:44 <kamyar> ertes: So How should I use time or clock in IO funcs?
14:38:45 <dminuoso> IO actions without a do-block will run sequentially too! :-P
14:38:47 <ertes> kamyar: oh, scratch 'time' from the list…  you should use 'clock'
14:39:13 <dminuoso> ertes: By the way, I handrolled ListT, came up with the naive implementation and it was of course wrong.
14:39:17 <ertes> kamyar: do t0 <- getTime Monotonic; x <- action; t1 <- getTime Monotonic; let dt = t1 - t0; …
14:39:33 <dminuoso> But I was proud to have come up with the "standard" solution at least without knowing what I was doing.. just following types..
14:39:48 <dminuoso> Parametricity did not save me. :(
14:39:51 <ertes> dminuoso: great =)
14:39:54 <kdu584uti> kamyar: In ghci >>> :set +s
14:40:30 <kamyar> ertes: What about criterion?
14:40:34 <dmwit> Do not trust timings done in ghci. They are a very poor predictor of timings done in a compiled program.
14:40:58 <dmwit> Meanwhile, ertes suggests reimplementing the package I suggested within seconds of the question getting asked.
14:41:03 <ertes> dminuoso: you can implement a proper ListT using this type:  newtype ListT m a = ListT { runListT :: forall r. (a -> m r -> m r) -> m r -> m r }
14:41:17 <ertes> dmwit: you mean 'timeit'?
14:41:42 <dmwit> I guess it is not quite the same, since timeit uses getCPUTime.
14:41:46 <ertes> dmwit: timeit does CPU time though
14:41:54 <ertes> yeah
14:42:24 <kamyar> So I must use timeit?
14:42:25 <ertes> i'd rather suggest adding that functionality to 'clock', because then you can ask for different types of clocks, including CPU time
14:42:29 <ertes> kamyar: no
14:42:34 <ertes> use 'clock'
14:42:59 <dminuoso> ertes: Alright, so noted. Ill come back to monad transformers when Im done with this Haskell book. :)
14:43:01 * hackage cabal-lenses 0.6.0 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.6.0 (DanielTrstenjak)
14:43:03 <ertes> timeit will not return the timing you're interested in (how long the response takes)
14:43:46 <dmwit> ertes++ for the suggestion of clock. Now I have another tool in my belt.
14:43:48 <ertes> dminuoso: BTW, if you're interested in *using* a proper ListT, check out the 'logict' package
14:44:24 <kamyar> ertes: Thanks!
14:44:49 * hackage cabal-cargs 0.9.0 - A command line program for extracting compiler arguments from a cabal file.  https://hackage.haskell.org/package/cabal-cargs-0.9.0 (DanielTrstenjak)
14:45:05 <kamyar> I am writing a packahe liek JMeter with haskell!
14:45:10 <kdu584uti> dmwit: Noted. Thank you.
14:45:12 <ertes> kamyar: be sure to use Monotonic, not Realtime
14:45:25 <kamyar> ertes: Ok! Thanks
14:46:05 <kamyar> I think Jmeter is very robust but JVM consumes too much resource! So I got my feet wet and started writing one!
14:46:17 <kamyar> Anyone wanna contribute? It is an open source project
14:47:29 <ertes> kamyar: i'm just about to release a new version of progress-meter that you might find useful for that kind of project =)
14:47:31 <kamyar> Now another question:
14:47:53 <ertes> it's a complete API rewrite though, so if you want to use it, don't use the current version
14:48:23 <kamyar> ertes: Thanks! Give me a link plz
14:49:31 <kamyar> Another question: I use forkIO to run http requests in multiple threads! Now I am adding timing within my worker function
14:49:58 <kamyar> How can I hold the resulting time when I have to use the signature IO ()?
14:50:16 <kamyar> forkIO forces me to have an empty IO monad
14:51:10 <ertes> kamyar: use 'async'
14:51:45 <kamyar> ertes: Doesn;t GHC automatically create Green Thread or Thread when possible?
14:51:57 <ertes> kamyar: it does…  async is just a high-level interface to that
14:52:06 <ertes> it makes communicating results back to the main thread easy
14:52:12 <kamyar> ertes: Better than forkIO?
14:52:20 <ertes> and it also avoids some common pitfalls that can cause orphan threads
14:52:38 <kamyar> ertes: Yes I know it
14:52:46 <dmwit> async uses forkIO behind the scenes...
14:53:02 <kamyar> ertes: I am in doubt if async forces GHC to use Green Threads (Fibers) always
14:53:15 <ertes> kamyar: async doesn't have a choice
14:54:04 <kamyar> does async automatically distributes the execution among several threads each containing fibers?
14:54:13 <dmwit> Yes.
14:54:59 <kamyar> dmwit: So it is a masterpiece! Me coming from Python, asyncio is just creating fibers not threads there!
14:55:42 <ertes> kamyar: all concurrency libraries use GHC's lightweight threading…  it's not like in python, where every concurrency library does its own thing
14:56:05 <kamyar> ertes: Great! Thanks!
14:56:10 <ertes> kamyar: so you can even use forkIO, async and distributed-process at the same time and it will just work
14:57:01 <kamyar> Fantastic!
15:06:42 <jle`> @tell frerich my definition is actually a lot slower for most inputs
15:06:42 <lambdabot> Consider it noted.
15:06:57 <jle`> @tell frerich i make a note about it in my blog post in an aside :)
15:06:57 <lambdabot> Consider it noted.
15:07:27 * hackage euler-tour-tree 0.1.0.0 - Euler tour trees  https://hackage.haskell.org/package/euler-tour-tree-0.1.0.0 (koral)
15:16:34 <gfixler> quit
15:41:24 <ph88> how can i know something of the profile cost of things within a function? i have a profile file with  throwSocketErrorIfMinus1RetryMayBlock from Network.Socket.Internal  with no more levels below that
15:42:32 <nullie> ph88: I guess it waits for packets to arrive, no functions inside
15:42:51 <nullie> MayBlock
15:43:44 <dmwit> If you want more cost centers than "one per function", you have to add them manually.
15:43:48 <dmwit> There's details in the GHC manual.
15:44:08 <dmwit> You will then need to recompile that library dependency of course.
15:44:34 <ph88> nullie, the 3rd argument "the IO operation to be executed" i'm not seeing this in the profile file
15:44:49 <ph88> dmwit, where can i modify the source ?
15:44:49 <nullie> oh
15:45:07 <dmwit> You can use `cabal unpack` to get a copy of the source.
15:45:45 <ph88> won't i get conflicts with that copy ?
15:46:30 <dmwit> Yes, you will likely need to rebuild anything that depends on network. I recommend either a sandbox or new-* for this experiment.
15:47:14 <ph88> i'm using stack
15:47:45 <dmwit> Okay. I don't know enough about stack to make good recommendations about how to proceed.
15:48:39 <ph88> ok np
15:48:40 <ph88> thc
15:48:41 <ph88> thx
15:50:07 <geekosaur> extra-deps, with either an unversioned source tree or a sit tree with your local changes as committed but not pushed so the commit hash can be the version it uses to tell it apart from the normal one?
15:50:11 <geekosaur> *a git tree
15:50:54 <geekosaur> (pushed is also fine provided it's a fork as opposed to using network's own upstream)
15:56:46 <ph88> if i use an unversioned source tree how do i point to the right directory ?
15:59:30 <geekosaur> that's what I meant by extra-deps
15:59:33 <geekosaur> in stack.yaml
16:00:12 <geekosaur> you are telling stack to use your local 'network' instead of the standard one. it should rebuild anything else that needs it (I think) but keep those builds separate from the normal ones
16:01:03 <geekosaur> although instead it might throw an error that basically means you also have to extra-deps anything else depending on network, which would be a pain. you need someone who knows stack better for that part
16:10:59 <Gurkenglas> Why isn't THs Exp "data Exp :: * -> * where AppE :: Exp (a -> b) -> Exp a -> Exp b; ..."?
16:11:34 <dmwit> because polymorphism, probably
16:11:52 <Gurkenglas> Ah, foralls in there would need impredicative types?
16:12:35 <dmwit> Maybe. But that's not my objection.
16:13:34 <dmwit> You don't want `Exp (a -> b) -> Exp a -> Exp b`, you want some crazy `Unifies (c -> d) (a -> b) => Exp (a -> b) -> Exp c -> Exp d` or some such.
16:13:50 <dmwit> And nobody wants to implement unification and type inference inside Haskell's type system.
16:14:03 <Gurkenglas> Exp (a -> b) isn't automatically Exp (Int -> b)?
16:14:48 <Gurkenglas> ...what language does ghc implement it in?
16:15:13 <dmwit> In GHC, type inference is implemented inside Haskell's value system, which is much more amenable to that kind of thing.
16:15:23 * hackage progress-meter 1.0.0 - Live diagnostics for concurrent activity  https://hackage.haskell.org/package/progress-meter-1.0.0 (esz)
16:17:24 <dmwit> On `Exp (a -> b) isn't automatically Exp (Int -> b)`: no, because a given (polymorphic) expression might be used at multiple types in a single term.
16:18:26 <ertes> oh, "cabal upload -d"
16:18:28 <ertes> that was easy =)
16:18:29 <dmwit> For any single use, what you propose would be fine, and would force the polymorphic TH thing into an appropriately-typed monomorphic TH thing. But with multiple uses, this would try to force it into different types at once.
16:18:42 <Gurkenglas> Doesn't lens have that same problem, where you can't actually use polymorphic lenses in two different ways without routing through a universal element?
16:19:45 <dmwit> That sounds related.
16:20:01 * geekosaur is thinking typed TH sounds relevant
16:21:56 <Gurkenglas> Could you use the equivalent of cloneLens to explicitly specialize polymorphic values in the rare case you want to use a derived show-like as two different types?
16:28:13 <wormking> merry x-mas
16:31:10 <Gurkenglas> geekosaur, relevant to what?
16:32:56 <Gurkenglas> Oh, you mean with typed th not the object of this discussion, but https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/Typed . Yes.
16:34:23 <steveo> Does anyone know how I can measure the latency of garbage collection of GHC?
16:34:45 <steveo> I have a animation where I want constant time for a good frame rate
16:35:21 <steveo> I already brought down the latency but now I want to benchmark it accurately
16:35:30 <c_wraith> Gurkenglas: cloneLens requires an instance of Functor that exactly captures what Lens does.  You'd need to find something similar for any other type you wanted to do something like that with.
16:35:51 <c_wraith> steveo: threadscope will give you that information
16:36:20 <ClaudiusMaximus> steveo: +RTS -s   reports avg/max gc pauses, may not be detailed enough for you
16:37:20 <steveo> I would like it accurately enought so that I can measure the improvement going from 3000 Mhz to 4200 Mhz DDR4 ram
16:37:24 <steveo> Thanks for the 2 tips
16:41:39 <Gurkenglas> https://ghc.haskell.org/trac/ghc/wiki/TemplateHaskell/Typed <- "It can, of course, only be used in a context which is expecting a TExp ty." <- shouldn't this say "It can, of course, only be used in a context which is expecting a ty."?
16:42:23 <geekosaur> presumably you are using it in TH, not in actual code, so TExp is correct
16:42:47 <geekosaur> ty is what *results* from the splice; the splice itself needs the TExp ty
16:43:59 <Gurkenglas> "The term e must have type TExp ty, and the splice $$e then has type ty." <- that sounds like you'd use $$e in actual code in places where a ty goes
16:44:29 <geekosaur> that sounds more or less like what I said
16:49:55 <Gurkenglas> So I think the "It" in "It can, of course" refers to "$$e" and geekosaur thinks it refers to "TExp"?
16:52:53 <geekosaur> oh, hm. (I had not actually loaded up the context for that, largely because local network is playing up)
16:53:18 <geekosaur> yes, that seems like a thinko since it should be talking about $$e
16:54:11 <papand> > foldr (+) 0 [1,2,3,4,5,6,7] :: Expr
16:54:12 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + 0))))))
16:55:28 <papand> > foldr (+) 0 [1,2,3,4,5,6,7]
16:55:30 <lambdabot>  28
16:55:42 <papand> foldr (+) 0 [1,2,3,4,5,6,7]
17:16:28 <iqubic> What are we discussing?
17:18:14 <iqubic> Actually, I have a backlog I can read. Don't tell me.
17:26:49 <iqubic> What would a lens into the head of a list look like?
17:27:17 <Gurkenglas> iqubic, what if the list is empty?
17:27:23 <iqubic> :t lens
17:27:24 <lambdabot> Functor f => (s1 -> a1) -> (s1 -> b1 -> t1) -> (a2 -> f b2) -> s2 -> f t2
17:27:34 <iqubic> What the hell is that?
17:27:51 <Gurkenglas> That's what happens when type aliases are automatically unpacked.
17:28:02 <iqubic> Oh, I see.
17:28:12 <iqubic> Can I get that in a more friendly notation?
17:28:24 <Gurkenglas> The actual type of lens as found in the docs is (s -> a) -> (s -> b -> t) -> Lens s t a b, as hayoo shows
17:28:32 <iqubic> I see.
17:28:50 <Gurkenglas> You'll need [a] -> a to retrieve the head, and [a] -> a -> [a] to replace the head.
17:29:14 <yohotchoc> Lens s t a b is a great type
17:29:16 <iqubic> Can I see what that might look like?
17:29:30 <iqubic> I have no idea how to use lenses, but would like to learn.
17:30:34 <Gurkenglas> @let unsafeheadlens = lens head (\(_:xs) x -> x:xs)
17:30:35 <lambdabot>  Defined.
17:30:46 <iqubic> How does that work?
17:30:59 <Gurkenglas> unsafeheadlens is a Lens' [a] a.
17:31:04 <iqubic> Did you just define a lens by using a getter and a setter?
17:31:16 <Gurkenglas> Yes, as the lens function allows us to do.
17:31:19 <Gurkenglas> > view unsafeheadlens ["asd"]
17:31:20 <lambdabot>  "asd"
17:31:36 <Gurkenglas> > set unsafeheadlens "dsa" ["asd", "5"]
17:31:37 <lambdabot>  ["dsa","5"]
17:31:39 <iqubic> I want something a little bit more complex to try my hand at.
17:31:43 <Gurkenglas> > view unsafeheadlens []
17:31:44 <lambdabot>  *Exception: Prelude.head: empty list
17:31:53 <dminuoso> iqubic: data V3 a = V3 !a !a !a  deriving (Eq, Foldable, Ord, Show)
17:32:19 <dminuoso> iqubic: Write a Functor and Traversable instance for that.
17:32:23 <Gurkenglas> iqubic, the lens into the first element of a pair is all you need to do all that ordinary lenses can do
17:32:30 <iqubic> dminuoso: I'm not familiar with the bang pattern there.
17:32:41 <iqubic> Gurkenglas: Why do you say that?
17:33:03 <dminuoso> iqubic: Oh that just makes it strict, You can use V3 a a a if you prefer.
17:33:05 <Gurkenglas> iqubic, Lens' s a is a witness that s looks like (a, b) for some b
17:33:25 <Gurkenglas> unsafeheadlens makes [a] look like (a, somethingthatwedon'tgettoinvestigatefurther)
17:33:29 <dminuoso> iqubic: Note that this task is from a series of tasks that I was given to discover lenses on my own. It was an amazing excercise. :)
17:33:49 <dminuoso> iqubic: (Once you've done you'll get the next task)
17:34:13 <iqubic> @let fstLens = lens (\(a, b) -> a) (\(a, b) c -> (c, b))
17:34:14 <lambdabot>  Defined.
17:34:34 <iqubic> view fstLens (1,2)
17:34:47 <iqubic> > view fstLens (1,2)
17:34:48 <lambdabot>  1
17:35:11 <iqubic> over fstLens 1 (10, 100)
17:35:22 <iqubic> > over fstLens 1 (10, 100)
17:35:24 <lambdabot>  error:
17:35:24 <lambdabot>      • Could not deduce (Num a0)
17:35:24 <lambdabot>        from the context: (Num (a -> a2), Num b, Num a)
17:35:36 <Gurkenglas> :t over
17:35:37 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
17:35:39 <iqubic> Is that not how over works?
17:35:40 <Gurkenglas> :t set
17:35:42 <lambdabot> ASetter s t a b -> b -> s -> t
17:36:01 <iqubic> I just want to see if the setter of my fstLens is correct.
17:36:01 <Gurkenglas> > over fstLens (+1) (10, 100)
17:36:03 <lambdabot>  (11,100)
17:36:06 <dminuoso> iqubic: you can think of `set` as `over` using `const` in its second argument.
17:36:15 <iqubic> I see.
17:36:26 <iqubic> Did I define fstLens correctly?
17:37:04 <Gurkenglas> Yes.
17:37:14 <Gurkenglas> A lens, like all optics, turns small actions into big actions, where for lens actions is defined as just powerful enough to allow getting and setting. Therefore, lenses can be composed.
17:37:48 <iqubic> I see.
17:38:01 <iqubic> dminuoso: What was your challenge to me?
17:38:16 <dminuoso> iqubic: Just implementing Functor and Traversable for that V3.
17:38:17 <Gurkenglas> > set (fstLens . fstLens)
17:38:19 <lambdabot>  error:
17:38:19 <lambdabot>      • No instance for (Typeable a20)
17:38:19 <lambdabot>          arising from a use of ‘show_M1317976927344514412194’
17:38:37 <Gurkenglas> :t set (fstLens . fstLens) -- whoops
17:38:38 <lambdabot> a2 -> ((a1, b1), b2) -> ((a2, b1), b2)
17:38:59 <iqubic> > set 12 (fstLens . fstLens) ((102, 3), 17)
17:39:01 <lambdabot>  error:
17:39:01 <lambdabot>      • Could not deduce (Num b1)
17:39:01 <lambdabot>        from the context: (Num
17:39:13 <iqubic> What the heck??
17:39:15 <dminuoso> iqubic: the lens goes first =)
17:39:23 <iqubic> What is that?
17:39:31 <iqubic> Also, what is V3 again?
17:39:46 <dminuoso> iqubic: ata V3 a = V3 a a a  deriving (Eq, Foldable, Ord, Show)
17:39:51 <dminuoso> iqubic: data V3 a = V3 a a a  deriving (Eq, Foldable, Ord, Show)
17:40:26 <iqubic> I see. Is it important that it derives Foldable?
17:40:41 <dminuoso> iqubic: Yeah, but if you want you can implement it yourself.
17:40:48 <iqubic> I don't really.
17:40:58 <iqubic> I assume that the compiler will do the right thing.
17:41:15 <dminuoso> iqubic: Yes. You just need it because Traversable requires it.
17:41:31 <Gurkenglas> Whether you want it shouldn't depend on whether you trust the compiler, but whether you think you need the exercise
17:41:39 <iqubic> dminuoso: I'm going to take this as a time to learn intero and hole driven development as well.
17:42:00 <dminuoso> iqubic: The Foldable interface is not relevant to any of this, so up to you whether you want the excercise.
17:42:03 <iqubic> If that's fine with you.
17:43:45 <papand> foldr (+) 0 [1,2,3,4,5,6,7]
17:43:53 <papand> > foldr (+) 0 [1,2,3,4,5,6,7] :: Expr
17:43:55 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + 0))))))
17:44:04 <dminuoso> Huh! What is this?
17:44:37 <papand> someone here know hot to execute haskell code in emacs org-mode?
17:44:40 <dminuoso> That's a neat feature. :)
17:44:42 <papand> hot = how
17:44:57 <papand> yes :-)
17:45:40 <dminuoso> > [1,2,3,4,5,6,7] :: Expr
17:45:42 <lambdabot>  error:
17:45:42 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
17:45:42 <lambdabot>      • In the expression: [1, 2, 3, 4, ....] :: Expr
17:45:44 <dminuoso> Bummer. :(
17:45:56 <Gurkenglas> > [1,2,3,4,5,6,7] :: [Expr]
17:45:58 <lambdabot>  [1,2,3,4,5,6,7]
17:46:18 <papand> you need > before
17:46:23 <dminuoso> Gurkenglas: Yeah I was hoping for it to desugar into 1 : (2 : ...)
17:46:53 <papand> > foldl (+) 0 [1,2,3,4,5,6,7] :: Expr
17:46:55 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7
17:47:22 <yohotchoc> that's so cool
17:47:26 <papand> > foldr (+) 0 [1,2,3,4,5,6,7] :: Expr
17:47:28 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + 0))))))
17:48:04 <Gurkenglas> > fix (1+) :: Expr
17:48:06 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:48:07 <papand> why it dont do parentheses with foldl?
17:48:35 <yohotchoc> because + is left associative probably
17:48:46 <kakashiAL> QUOTE: "A more correct term for what a functor is would be computational context."  <--can someone please explain what context and computational context mean?
17:49:15 <yohotchoc> :i Expr
17:49:45 <papand> > foldl (\x y -> x + 2 * y) 0 [1,2,3,4,5,6,7] :: Expr
17:49:47 <lambdabot>  0 + 2 * 1 + 2 * 2 + 2 * 3 + 2 * 4 + 2 * 5 + 2 * 6 + 2 * 7
17:49:55 <dminuoso> kakashiAL: The closest "covering most cases" analogy of functor is "container" (but you have to take this in a very lose notion)
17:50:17 <papand> > foldl (\x y -> x + y * 2) 0 [1,2,3,4,5,6,7] :: Expr
17:50:18 <lambdabot>  0 + 1 * 2 + 2 * 2 + 3 * 2 + 4 * 2 + 5 * 2 + 6 * 2 + 7 * 2
17:50:38 <dmwit> kakashiAL: Oh, that's easy. A computational context is a functor.
17:50:52 <dminuoso> But the opposite does not hold true, no?
17:50:55 <dmwit> kakashiAL: More seriously: hopefully wherever you got that quote from goes on to explain what they mean by computational context.
17:51:10 <dminuoso> dmwit: It does, but it's a bit confusing.
17:51:18 <dminuoso> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
17:51:26 <dmwit> kakashiAL: It is not such a universal term that one should assume it has a meaning that's consistent from one document to the next.
17:51:33 <kakashiAL> dminuoso, dmwit: my source:  http://learnyouahaskell.com/functors-applicative-functors-and-monoids
17:51:35 <papand> > foldl (*) 1 [1,2,3,4,5,6,7] :: Expr
17:51:36 <lambdabot>  1 * 1 * 2 * 3 * 4 * 5 * 6 * 7
17:51:56 <dminuoso> kakashiAL: The closest term describing best what a functor is: Functor.
17:51:59 <papand> > foldl (:) [] [1,2,3,4,5,6,7] :: Expr
17:52:00 <lambdabot>  error:
17:52:00 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[a0]’
17:52:00 <lambdabot>      • In the expression: foldl (:) [] [1, 2, 3, ....] :: Expr
17:52:24 <dmwit> > foldl f a [x,y,z] -- there, now you have the general form
17:52:26 <lambdabot>  f (f (f a x) y) z
17:52:40 <dminuoso> dmwit: Whats the computational context of a Tree?
17:52:52 <papand> dwmit thanks!
17:52:57 <dminuoso> Or a Reader?
17:53:02 <dminuoso> Or Const? :|
17:53:03 <kakashiAL> I found many articles that use functor and context or computational context, but they dont explain these terms
17:53:15 <dmwit> dminuoso: I will give again my same answer: hopefully the document in which you see that phrase goes on to explain what it means.
17:54:06 <kakashiAL> so if I read "a functor is computational context" I understand "a functor is foo bar"
17:54:50 <papand> dmwit of course (sorry for that)
17:55:29 <papand> > foldl f x [1..10] :: Expr
17:55:31 <lambdabot>  f (f (f (f (f (f (f (f (f (f x 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
17:56:54 <dmwit> kakashiAL: Bummer, huh?
17:57:49 <iqubic> dminuoso: I am hanging out with my cousins. Sorry if it takes a while for me to get around to your tasks.
17:58:11 <iqubic> Do you have a link to the whole list of Lens based tasks, so that I can do them at my own rate?
17:58:15 <kakashiAL> dmwit: dont understand what you mean with that :(
17:58:52 <dmwit> kakashiAL: It is unfortunate that whatever you are reading used such nebulous words, and then did not make them more concrete and explain them.
17:59:08 <dmwit> kakashiAL: As a result, we can only guess what the author meant.
17:59:13 <iqubic> Because I don't have the time to sit down and do all the tasks right now, but I'd like to do the lens tasks at some point.
17:59:30 <iqubic> Relatives demand I hang out with them this holiday season.
17:59:46 <dmwit> kakashiAL: For what it's worth, I understand Functor well, and having now read the same document as you, I find his "word of advice" to be essentially useless.
18:00:13 <iqubic> Can I see the document? Because I also understand functor quite well too.
18:00:24 <kakashiAL> dmwit: just in case, if you google that with the extra keyword haskell or functor you will find more articles that use "context" or "conputational context"
18:00:25 <dmwit> (But then I have never really liked LYAH. Too much fluff, not enough meat.)
18:01:45 <iqubic> LYAH was a good introduction to me, but I never understood why it introduces monoids before functors, applicatives and monads.
18:05:23 <systemfault> The haskellbook also does that, I think it's fine
18:06:42 <dminuoso> iqubic: Well I want to give you as little as possible, making you discover them yourself.
18:06:44 <dminuoso> So..
18:07:00 <dminuoso> iqubic: But just let me know whenever really. :)
18:07:08 <geekosaur> because monoids are simpler to understand, and give you the framework needed to unravel the more complex ones
18:07:21 <geekosaur> (i.e. how typeclasses work)
18:17:11 <metahumor> has anyone tried using stack on the new WSL insider build?
18:17:25 <metahumor> i keep getting a BSOD due to something in lxcore
18:26:14 <steveo> Does anyone no projects which include large criterion benchmarks? I'd like to compare different GHC versions for speed but need e.g. 10 projects or so
18:39:40 <iqubic> dminuoso: I have some free time right now.
18:39:56 <iqubic> I'd like to tackle your lens tasks.
18:40:04 <iqubic> What was the first one?
18:43:52 <kakashiAL> re
18:54:29 <iqubic> dminuoso: I was setting up intero, and then erc decided to reconnect. I'm didn't catch what you said the first task was.
18:56:13 <iqubic> I have intero set up and what to get going on your lens tasks.
18:56:37 <iqubic> I think the first one was something or other to do with V3 a = !a !a !a
18:59:40 <amalloy> iqubic: my logs show:  <dminuoso> iqubic: data V3 a = V3 !a !a !a  deriving (Eq, Foldable, Ord, Show)   <dminuoso> iqubic: Write a Functor and Traversable instance for that.
19:00:01 <iqubic> Yes, that is what I remeber.
19:01:09 <iqubic> Also, amalloy: Good work on the AoC videos. Some of the later days are really hard. I loved hearing your explantions for the more complex programs.
19:01:44 <iqubic> I assume your YT channel is Alan Malloy. It is a haskell channel, and your are in #haskell.
19:01:48 <amalloy> yes, it's me
19:02:27 <amalloy> iqubic: i sadly kinda lost interest in recording it, for the moment anyway. maybe i'll get back to post-narrating them sometime. but i'm actually working on day 18 at the moment
19:02:41 <iqubic> Oh, that's a shame.
19:06:56 * hackage aeson-generic-compat 0.0.1.1 - Compatible generic class names of Aeson  https://hackage.haskell.org/package/aeson-generic-compat-0.0.1.1 (KeiHibino)
19:15:10 <iqubic> Thank you intero for 1) telling me I needed derivingFoldable and 2) just typing that in for me when I ask it to.
19:16:14 <amalloy> intero is pretty legit
19:17:11 <iqubic> Yeah, I'm only just now learing how to use it right now.
19:21:25 <heebo> hi what is total pattern matching?
19:22:16 <geekosaur> er, in what context?
19:22:40 <geekosaur> by itself it makes me think makking sure you match all possible patterns, as opposed to something like head that fails on an empty list
19:22:53 * JuanDaugherty will be surprised if it's not a pattern that describes all of the input
19:23:48 <heebo> https://twitter.com/themattchan/status/944858310079057920
19:23:55 <heebo> i was looking at that tweet
19:39:15 <dmwit> In the context of that tweet: total pattern matching is writing patterns which the compiler can confirm cover all cases.
19:40:01 <Zemyla> Is there a thing that's a combination of Monad and Traversable?
19:40:09 <Zemyla> With a function along the lines of:
19:40:48 <Zemyla> class (Monad m, Traversable m) => MonadTraversable m where tBInd :: Applicative f => (a -> f (m b)) -> m a -> f (m b)
19:41:33 <Zemyla> Oh, wait.
19:42:08 <Zemyla> :t \f -> fmap (>>= id) . traverse f
19:42:09 <lambdabot> (Applicative f, Traversable m, Monad m) => (a -> f (m b)) -> m a -> f (m b)
19:42:35 <Zemyla> So never mind, it's just something that all traversable monads can do.
19:43:58 <dmwit> #haskell is the finest rubber duck around, huh?
19:44:06 <Zemyla> Thanks.
19:45:19 <Gurkenglas> Zemyla, can I see the code you want to use this for? I've got a hunch there's another way
19:45:47 <mniip> there's gotta be a better way!
19:51:14 <Zemyla> Gurkenglas: I thought of it when I realized I'd need something like it for a type that's a monomorphic container.
19:52:25 <Zemyla> Dice with Integer keys and Rational probabilities.
19:54:07 <Zemyla> Like, I have a bind function of type (Integer -> Die) -> Die -> Die, and a traverse-type function with type (Integer -> f Integer) -> Die -> f Die, but I'd need one of type (Integer -> f Die) -> Die -> f Die.
19:55:22 <iqubic> I have no idea how to make a traversable instance for "data V3 a = !a !a !a"
19:55:52 <iqubic> I got the functor instance right away, but this is breaking my brain
19:56:07 <Zemyla> iqubic: You know how to make the Foldable instance, though, right?
19:56:55 <pacak> :t traverse
19:56:56 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
19:56:56 <nilOps> Is there any way to print function docs from ghci?
19:58:23 <iqubic> Zemyla: no. I just started with deriving foldable.
19:58:41 <iqubic> Perhaps I should write my own foldable instance first.
20:00:03 <iqubic> Well, let's try writting foldr
20:00:08 <Zemyla> If you write foldMap, and are familiar with how Applicatives work, then traverse should be similar.
20:00:10 <iqubic> :t foldr
20:00:11 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:00:30 <iqubic> I don't really get how Applicatives work. I'm sorry.
20:00:36 <Zemyla> iqubic: Write foldMap instead. It'll offer more insight.
20:00:57 <iqubic> :t foldMap
20:00:58 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
20:02:05 <Zemyla> You know what a Monoid is, right?
20:02:38 <iqubic> Yes.
20:02:56 <iqubic> is there an infix mappend. Is that <+>
20:03:26 <pacak> <>
20:03:31 <geekosaur> I kinbda feel like people who don;t get Monoid are looking for them to be something more than they are
20:03:41 <geekosaur> But the whole point is monoids are kinda dead simple
20:04:05 <geekosaur> it's a way to combine two things to get a third thing of the same type, and an identity value that makes it a no-op when needed
20:04:06 <iqubic> yeah.
20:04:13 <geekosaur> and that's *all* it is
20:04:29 <Zemyla> iqubic: I wouldn't recommend using Data.Monoid.<>, because it conflicts with Data.Semigroup.<>.
20:04:58 <Zemyla> But the infix mappend is simply `mappend`. :P
20:05:02 <iqubic> Oh. What would you recommend instead? `mappend`
20:05:51 <iqubic> I now have foldMap.
20:06:20 <iqubic> For V3 a = a a a, foldMap looks a lot like fmap.
20:06:36 <iqubic> Now, time to try writting the traversable instance.
20:06:56 <Zemyla> Traversable will look like a cross between foldMap and fmap.
20:07:06 <iqubic> Why do you say that?
20:07:35 <Zemyla> Because Applicatives are merely Functors that can be combined like Monoids.
20:07:44 <iqubic> Also, which should I write? Traverse, or SequnceA?
20:07:56 <amalloy> iqubic: fwiw i find it easier to think in terms of sequenceA than in terms of traverse
20:08:24 <iqubic> I see.
20:08:34 <iqubic> I'll try that.
20:08:41 <iqubic> :t sequenceA
20:08:42 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
20:08:52 <iqubic> Alright, how does that work?
20:09:24 <dmwit> In other words, your job is to implement the type `Applicative f => V3 (f a) -> f (V3 a)`.
20:09:34 <iqubic> Where does the applicative come from?
20:09:40 <dmwit> From the caller.
20:10:04 <iqubic> Oh. I see.
20:10:18 <dmwit> Here, I'll get it started for you: `sequenceA (V3 fx fy fz) = ...`
20:10:30 <dmwit> ;-)
20:10:33 <iqubic> I already knew that.
20:10:35 <iqubic> LOL
20:11:03 <amalloy> well, the variable names fx fy and fz are a bit of a hint to remind you that they're instances of the relevant applicative
20:11:42 <iqubic> And I need some way to combine them?
20:12:08 <iqubic> I think that is what I need here. Not too sure though.
20:13:33 <amalloy> there's good news on that front: they are applicative functors, which is all about combining things
20:13:36 <dmwit> Yes. Luckily there is an Applicative instance...
20:14:31 <Zemyla> :t liftA3
20:14:32 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
20:14:36 <iqubic> Yeah, I'm not sure about the link between applicatives and monoids.
20:14:48 <Zemyla> iqubic: Does that make you think of anything?
20:14:57 <iqubic> @src liftA3
20:14:57 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:14:59 <mniip> there's plenty of links
20:15:05 <iqubic> V3 looks like A3
20:15:29 <iqubic> In fact I think I can do this simply.
20:16:17 <iqubic> Why is liftA3 not in scope? What import do I need?
20:16:25 <Zemyla> iqubic: Control.Applicative.
20:17:57 <iqubic> Clearly "SequenceA (V3 fx fy fz) = liftA3 fx fy fz" doesn't work.
20:19:39 <iqubic> I'm not sure how to make this work properly.
20:19:55 <dmwit> Keep thinking and trying.
20:20:10 <iqubic> I will.
20:20:20 <iqubic> How does liftA3 help me?
20:20:22 <amalloy> indeed, the types don't quite line up. iqubic: were you the one saying you wanted to try out hole-oriented programming? you could try putting a hole in to see what type ghc says you need
20:20:54 <amalloy> but i guess in this case you kinda need to know where to put the hole in order to get a useful hint from ghc
20:22:04 <iqubic> I was the one who wanted to try hole-oriented programming.
20:22:30 <Welkin> that sounds sexual
20:23:26 <amalloy> hmm. i don't want to give you too much of a hint by telling you where to put the hole, but there is one place in your existing expression where a hole would give you quite a good hint
20:24:10 <iqubic> In what expressing?
20:24:20 <amalloy> what you said doesn't work: liftA3 fx fy fz
20:24:25 <iqubic> s/expressing/expression.
20:24:51 <dmwit> iqubic: `liftA3` takes four arguments. Why not put a hole in place of all four?
20:24:51 <Welkin> I don't like any kind of oriented programming
20:24:55 <Welkin> it's naive
20:25:47 <iqubic> Well, I'm trying "sequenceA (V3 fx fy fz) = _ fx fy fz" and that seems to work.
20:26:46 <iqubic> The hole needs the type "f a -> f a -> f a -> f (V3 a)" where f :: Applicative
20:27:53 <iqubic> or rather f :: (* -> *) where f is an Applicative.
20:28:26 <amalloy> :t liftA3
20:28:27 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
20:28:49 <amalloy> part of the signature of liftA3 looks a lot like the type of that hole, no?
20:28:54 <iqubic> Yes.
20:29:07 <iqubic> But that doesn't work for some reason.
20:29:14 <iqubic> Intero is giving me errors.
20:29:15 <amalloy> well it's not the whole signature, just part of it
20:29:29 <iqubic> I know.
20:32:03 <amalloy> notably, liftA3 has four arguments, where you want something with just three arguments. if you call liftA3 with one argument, it will curry down to something with three arguments
20:33:20 <iqubic> sequenceA (V3 fx fy fz) = liftA3 V3 fx fy fz
20:33:32 <iqubic> That typechecks.
20:34:21 <zerovector> I have a [[toUpper]] (some of these will be toLower) and [[Char]]. How do I apply each toUpper onto each Char?
20:35:06 <iqubic> Now, since dminuoso doesn't seem to be around, I can't get my next task in the lens discovery course.
20:35:19 <amalloy> it does typecheck! and if you'd like to see whether it also "works", you could try it like: sequenceA (V3 "ab" "xy" "z")
20:35:59 <Gurkenglas> zerovector, [[toUpper]] is not a type, what do you mean?
20:36:15 <iqubic> http://termbin.com/k2mo
20:36:46 <iqubic> What does sequenceA (V3 "ab" "xy" "z") do?
20:37:21 <Gurkenglas> > sequenceA ["ab, "xy", "z"]
20:37:22 <lambdabot>  <hint>:1:27: error:
20:37:23 <lambdabot>      lexical error in string/character literal at end of input
20:37:34 <amalloy> it gives you the cartesian product of the three lists "ab", "xy", and "z", wrapping each product in your V3 type
20:37:41 <Gurkenglas> > sequenceA ["ab", "xy", "z"] -- whoops
20:37:43 <lambdabot>  ["axz","ayz","bxz","byz"]
20:37:44 <zerovector> Gurk: I'm unsure of the type but it is a list of lists of functions. Each function is either toUpper or toLower.
20:38:28 <iqubic> What is a cartesian product?
20:38:32 <Gurkenglas> zerovector, ah so you want [[a -> a]] -> [[a]] -> _, where _ is [a] or [[a]] or [[[a]]] or [[[[a]]]]
20:38:45 <iqubic> How does liftA3 work?
20:38:51 <amalloy> iqubic: every combination of exactly one item from each list
20:39:02 <iqubic> Oh I see.
20:39:07 <zerovector> Gurk: yes. _ is [[a]]
20:39:53 <iqubic> amalloy: Do you know the Intero keybinding for opening a repl? Is there one?
20:40:02 <amalloy> C-c C-l
20:40:12 <Gurkenglas> zerovector, what does your desired function do with [[toUpper, toLower], [toLower, toUpper], [toUpper, toUpper]] and [['a','b'],['c','d']]?
20:40:25 <amalloy> really this opens a repl as well as loading your current file; i'm not sure how to just open a blank repl
20:40:37 <Gurkenglas> iqubic, "M-x intero-" should list you a bunch of stuff
20:40:50 <iqubic> amalloy: that's what I want.
20:40:58 <iqubic> Thank you.
20:41:33 <zerovector> Gurk: I see. There's a problem when the lists are different lengths. I think I can get around this by flattening each, then doing the application later.
20:42:08 <Gurkenglas> zerovector, so you want [a -> b] -> [a] -> [b], applying each function to each element?
20:42:23 <iqubic> sequenceA (V3 "ab" "xy" "z")
20:42:30 <Gurkenglas> :t (<*>) :: [a -> b] -> [a] -> [b] -- zerovector
20:42:32 <lambdabot> [a -> b] -> [a] -> [b]
20:42:46 <iqubic> [V3 'a' 'x' 'z',V3 'a' 'y' 'z',V3 'b' 'x' 'z',V3 'b' 'y' 'z']
20:42:54 <iqubic> Why is that the output?
20:42:55 * hackage sdl2-mixer 1.1.0 - Bindings to SDL2_mixer.  https://hackage.haskell.org/package/sdl2-mixer-1.1.0 (SinisaBidin)
20:42:56 <amalloy> iqubic: you could also try it in a different Applicative context: sequenceA (V3 (Just 1) (Just 2) (Just 3)), and try replacing some subset of the Justs with Nothing
20:43:24 <iqubic> I will try that.
20:43:31 <zerovector> Gurk: Yes. I already have that one solved. A new requirement had me break up a [Char] into [[Char]] by spaces. But I can intercalate the result with spaces after I've transformed it then apply the [a -> a].
20:48:03 <iqubic> Yeah I see how that works now.
20:48:12 <iqubic> Now I really want to know how liftA3 works.
20:48:42 <zerovector> Gurk: Thanks for the help!
20:50:37 <iqubic> Well, that's pretty simple.
20:50:42 <amalloy> iqubic: i don't have a syllabus planned for you like whoever it was did, i'm afraid. if liftA3 is a mystery to you, you might start with something simpler: how (<*>) works
20:51:07 <iqubic> I think the reason I get the cartesian product is because that's how the list functor works.
20:51:18 <iqubic> Err, list applicative rather
20:51:20 <amalloy> well, the list applicative
20:52:54 <iqubic> The list applicative repersents a non-deterministic computation.
20:53:10 <amalloy> that is one way of thinking of it, yes
20:53:28 <iqubic> How do you think of it, amalloy?
20:54:00 <amalloy> usually like that. but sometimes i find it useful to just forget that and think about fancier list comprehensions
20:55:12 <steveo> Is whnf enough when I benchmark a pure function (implemented in the ST monad) that sorts a vector and returns its first element?
20:56:24 <steveo> When I use "nfIO" I get back: No instance for (Control.DeepSeq.NFData MyRecord)      arising from a use of ‘nfIO’
20:56:26 <amalloy> i suggested also the Maybe applicative because it's even simpler: Just f <*> Just x = Just $ f x; _ <*> _ = Nothing
20:56:42 <iqubic> Yeah. I saw in your AoC videos you were like "Well, you could do a list comprehension here, but I think i'd mess this up, so I'm going to use do notation instead"
20:57:08 <amalloy> haha, well that's just because i forget the notation
20:57:24 <iqubic> Yeah, I ran into some troubles with that too.
20:58:03 <Average-user> glguy: last day
20:58:28 <jle`> hope i can finish before we open presents
20:58:31 <mniip> ooh
20:58:37 <mniip> 2 mins
20:59:04 <Average-user> mniip: Im happy because yesterdays was made for prolog
20:59:16 <jle`> Average-user: yes glguy_ and i were talking about how you might have enjoyed it
20:59:41 <Average-user> jaja
20:59:43 <Average-user> I did
21:00:01 <Gurkenglas> Is mniip streaming?
21:00:04 <mniip> no
21:00:08 <mniip> sorry
21:01:09 <metahumor> aoc timing out for me... =C
21:03:16 <dmwit> iqubic: I don't know what dminuoso's next exercise is. But since you seem puzzled about `liftA3`, I encourage you to try this one next: implement `sequenceA` again, but only using the bare basics of `Applicative`, namely, `pure`, `fmap`, and `(<*>)`.
21:03:22 <dmwit> i.e. no `liftA3`
21:04:35 <steveo> where is Seq defined: Not in scope: type constructor or class ‘Seq’
21:04:41 <dmwit> ?hoogle Seq
21:04:42 <lambdabot> Data.Sequence data Seq a
21:04:42 <lambdabot> Data.Sequence.Internal newtype Seq a
21:04:42 <lambdabot> Data.Sequence.Internal Seq :: (FingerTree (Elem a)) -> Seq a
21:04:56 <iqubic> dmwit: I already know how to do that.
21:05:52 <dmwit> huh
21:06:06 <iqubic> sequenceA (V3 fx fy fz) = V3 `fmap` fx <*> fy <*> fz
21:06:14 <dmwit> Yep, perfect.
21:06:17 <iqubic> I just now looked up the source for liftA3
21:06:19 <dmwit> Well, now you've implemented liftA3.
21:06:23 <iqubic> I know.
21:06:36 <iqubic> I just looked at the source because I was so confused.
21:06:44 <dmwit> Oh, that's cheating. =P
21:06:54 <dmwit> Anyway I'm glad you got unconfused.
21:07:39 <iqubic> LOL
21:07:45 <iqubic> I'm sorry.
21:10:42 <steveo> I am still running into problems....
21:10:43 <steveo> data Point = Point { x :: {-# UNPACK #-} !Float , y :: {-# UNPACK #-} !Float} deriving (Show, Read, NFData)
21:10:51 <steveo> Can't make a derived instance of ‘NFData Point’:
21:10:59 <steveo> Try enabling DeriveAnyClass
21:11:13 <iqubic> what does unpack do there?
21:11:29 <amalloy> iqubic: fwiw `fmap` is rather strange. usually you'd just <$> if you wanted an infix version of fmap
21:11:58 <steveo> 7.13.11. UNPACK pragma  The UNPACK indicates to the compiler that it should unpack the contents of a constructor field into the constructor itself, removing a level of indirection. For example:
21:11:59 <iqubic> amalloy, I couldn't remember the syntax for that.
21:12:25 <iqubic> I kept thinking it was <+> and intero kept yelling at me.
21:12:57 <steveo> iqubic: it also fails when I remove UNPACK
21:13:27 <jle`> woo hoo
21:13:30 <jle`> that was thrilling
21:13:38 <amalloy> jle`: did you save christmas?
21:13:44 <jle`> i saved christmas :D
21:13:50 <steveo> I did a definition: instance NFData a => NFData (Seq a) where     rnf = seqFoldable rdeepseq
21:14:16 <steveo> but this fails with duplicate instance definition: instance NFData a => NFData (Seq a) -- Defined in ‘Data.Sequence’
21:15:25 <iqubic> I have not saved christmas.
21:15:35 <iqubic> I have only done the first 4 days.
21:16:49 <steveo> I think I found a solution: instance (NFData Point) where   rnf (Point x y) = rnf x `seq` rnf y
21:17:39 <mniip> lit
21:18:31 <mniip> what's up with that naighty/nice list
21:18:47 <dmwit> metahumor++ for teaching me the alternative emoticon =C
21:20:08 <Lokathor> nice last program
21:20:09 <mniip> dmwit, it says here you are naughty
21:20:39 <dmwit> o no
21:21:00 <dmwit> Well who are you going to believe, that list or your senses??
21:21:16 <mniip> I have no senses
21:21:20 <Lokathor> and the list is never wrong
21:21:25 <iqubic> What is this naugthy or nice list we are consulting?
21:21:35 <mniip> http://tcpst.net/i0rx.png
21:21:41 <dmwit> Damn Empire loves their lists.
21:21:42 <mniip> I suppose it's different for everyone,
21:21:47 <mniip> but I have no idea what it means
21:22:29 <dmwit> =o
21:22:42 <mniip> people who finished shortly afterwards/beforehand?
21:22:42 <dmwit> Is that on the AoC website? I only attempted one day...
21:22:47 <mniip> yes
21:23:03 <iqubic> Is this the list of people who are in the haskell group and have completed all 25 days? I am in neither group.
21:23:59 <Lokathor> i did all the days but none in haskell :O
21:24:05 <mniip> oh
21:24:06 <mniip> it changes
21:24:09 <iqubic> I never joined the haskell group.
21:24:23 <iqubic> Lokathor: what language did you use?
21:24:31 <Lokathor> rust
21:24:57 <iqubic> Why? Who even uses rust these days?
21:25:07 <Lokathor> it's like a haskell that never leaves IO and has even worse type errors :P
21:25:09 <dmwit> mniip: Perhaps the naughty list is people who submitted a lot of wrong answers!
21:25:56 <iqubic> I only submitted on wrong answer when I did the first 4 days.
21:26:11 <iqubic> And this is why:
21:26:26 <iqubic> > permutations "aaa"
21:26:28 <lambdabot>  ["aaa","aaa","aaa","aaa","aaa","aaa"]
21:26:43 <Lokathor> :P
21:26:43 <iqubic> It gives the same thing a bunch of times, which I was not expecting.
21:26:53 <Lokathor> S.fromList (permutations theList)
21:27:02 <Lokathor> ;)
21:27:59 <iqubic> So for day 4 part two I ended up doing (nub . permutations) on every word in the input, and then I did one more additional nub for each line.
21:28:44 <iqubic> That was the day where you had a list of passphrases, and a valid passphrase contained no two words that were anagrams of each other.
21:28:57 <mniip> o no
21:29:00 <mniip> Lokathor, u naughty too
21:29:06 <mniip> and cocreature
21:29:08 <Lokathor> mniip, !!
21:29:24 <jle`> iqubic: you can just sort the words before nubbing
21:29:31 <iqubic> I didn't do that.
21:29:38 <jle`> > nub (sort <$> ["abc","bca","cab"])
21:29:39 <lambdabot>  ["abc"]
21:30:17 <mniip> that's not
21:30:19 <mniip> a good idea
21:30:39 <iqubic> See this: https://github.com/IQubic/AoC2017/tree/master/day4
21:30:46 <cocreature> if you do sort, use group and map head
21:30:49 <mniip> yeah
21:30:50 <steveo> The fun of criterion:
21:30:50 <steveo> benchmarking sort/nf 40 time                 992.2 ps   (972.0 ps .. 1.020 ns)                      0.997 R²   (0.992 R² .. 1.000 R²) mean                 NaN s      (NaN s .. NaN s) std dev              0.0 s      (0.0 s .. 0.0 s) variance introduced by outliers: -9223372036854775808% (severely inflated)  benchmarkVector: Statistics.Quantile.weightedAvg: Sample is empty CallStack (from HasCallStack):   error, called at ./Statis
21:30:53 <cocreature> sorting and then using "nub" is kind of silly
21:30:57 <mniip> exactly
21:31:04 <iqubic> I did that in a stupidly slow way.
21:31:04 <steveo> -9223372036854775808% is quite a lot
21:31:12 <Lokathor> a whole lot
21:31:17 <dmwit> (severely inflated)
21:31:50 <mniip> NaN s
21:32:39 <iqubic> So yeah, my implementation was stupidly slow.
21:36:48 <Lokathor> it only matters if the impl is so slow that it runs slower than the time it'd take to write the fast version
21:36:53 <Lokathor> which, often, it doesn't
21:38:29 <iqubic> No. I hae no idea what the faster verion of day 4 would be.
21:38:59 <iqubic> It only works if you prune the duplicates produced by permutations, before concating.
21:39:39 <iqubic> Otherwise the nub in the list comprehension eats the duplicates, and it fails the test.
21:40:06 <steveo> Because criterion crashes; can I show only the execution time? That part works.
21:40:48 <dmwit> Perhaps you should figure out why it's crashing...?
21:43:19 * hackage progress-meter 1.0.0.1 - Live diagnostics for concurrent activity  https://hackage.haskell.org/package/progress-meter-1.0.0.1 (esz)
21:48:05 <iqubic> is there a faster way to do day 4 part 2 of AoC
21:59:46 <iqubic> @src [a] fmap
21:59:46 <lambdabot> Source not found. Maybe you made a typo?
22:00:01 <iqubic> Worth a try.
22:06:56 <Gurkenglas> iqubic, http://hayoo.fh-wedel.de/?query=Functor gives an instance list which includes source links
22:10:46 <iqubic> Yeah, but for [a], fmap = map
22:11:47 <Gurkenglas> iqubic, where's the problem?
22:12:11 <Gurkenglas> Click on map to go to its source, or search on hayoo for map
22:14:11 <amalloy> i guess the question more is, what are you trying to find out
22:14:52 <iqubic> I want to see the implementation of "Instance Applicative [a]"
22:15:35 <dmwit> So search for Applicative, then click the source list next to the [] instance...?
22:16:11 <iqubic> I will.
22:31:40 <Average-user> I ended up doing last day in haskell, I didn't feel like doing it in Prolog
22:31:49 * hackage servant-proto-lens 0.1.0.0 - servant API Content-Type instances for use with proto-lens generated modules  https://hackage.haskell.org/package/servant-proto-lens-0.1.0.0 (plredmond)
22:36:19 <zerovector> How do I do something like a dot product on two lists where the first list is a list of functions? [Char -> Char] -> [Char] -> [Char]
22:37:14 <zerovector> I know I can zip the two lists, then map but I was wondering if there was something simpler
22:37:53 <geekosaur> :t zipWith ($)
22:37:54 <lambdabot> [a -> c] -> [a] -> [c]
22:43:35 <zerovector> geekosaur: Not exactly what I was looking for but I manipulated it to make it work. Thank you!
22:47:53 * hackage servant-proto-lens 0.1.0.1 - Servant Content-Type for proto-lens protobuf modules.  https://hackage.haskell.org/package/servant-proto-lens-0.1.0.1 (plredmond)
22:50:13 <metahumor> yay, finished AoC2017 using only haskell
22:50:27 <metahumor> learned so much on the way, mostly in Megaparsec land -_-
22:50:35 <zerovector> geekosaur: Nevermind. That was EXACTLY what I was looking for! Thanks again!
22:50:48 <metahumor> also about how ghci is not so forgiving with stack sizes
22:54:49 <metahumor> mniip: in my list, I'm nice instead of naughty (on yours), glguy is Nice, and dmwit and themattchan are Naughty. it's probably random
22:55:35 <mniip> and you're?
22:56:21 <JuanDaugherty> was that like 'i know you are but what am i?'
22:57:02 <JuanDaugherty> cause e said 'nice'
22:57:13 <mniip> no like what's your tag
22:57:23 <mniip> metahumor doesn't match anything
22:57:23 <JuanDaugherty> ah
22:59:22 * hackage pandoc-citeproc 0.12.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.12.2 (JohnMacFarlane)
23:22:14 <metahumor> mniip: my aoc tag is pechersky
23:22:21 <mniip> ah
23:34:20 <jle`> metahumor: congrats :)
23:34:42 <metahumor> thanks! your solutions were helpful after the fact for orienting myself
23:35:11 <metahumor> jle`: maybe one day we'll read your refls on the latter half
23:35:16 <cocreature> huh where are you seeing the “nice” and “naughty” stuff? I think I’m missing something
23:35:25 <metahumor> cocreature: its on the homepage of the puzzles
23:35:44 <jle`> vaibhavsagar: you showed up on my nice list :O
23:35:48 <metahumor> jle`: your blog post on StateT s [] a was very very usefyl
23:36:01 <jle`> thanks! i was surprised that it came up so often
23:36:34 <jle`> cocreature: it comes up after the circuit power reaches the top of the page
23:36:44 <metahumor> i guess its just an elegant way to have a pruning-tree-search
23:36:47 <jle`> it's the "printer" that we were trying to fix
23:36:49 <jle`> get it? :)
23:37:06 <cocreature> ah :)
23:37:17 <cocreature> haven’t been patient enough :)
23:37:28 <jle`> (me saying it as i just figured it out right now)
23:38:09 <jle`> the |O| tractor-feed paper is a nice touch
23:38:55 <metahumor> I wonder if The Easter Bunny also did the puzzles in haskell
23:39:12 <jle`> now just to go back and make my day 25 solution with a general parser
23:40:06 <jle`> my original 25 solution was a <spoilers> of Bool's but i realized that it could just be a <spoiler> of Int's
23:41:16 <metahumor> yeah... I ended up parsing the input with a nasty combo of `words` and `head . last` etc
23:42:02 <metahumor> couldn't get a nice `some parseInstruction` going
23:42:16 <jle`> oh i just typed mine in by hand
23:44:06 <jle`> i was in a hurry but i didn't even make the leaderboard
23:44:10 <jle`> but the ending made me happy
23:44:26 <metahumor> what was your fav day of the 25?
23:45:07 <jle`> good question! :O
23:45:09 <jle`> maybe day 23
23:45:36 <jle`> or that dance one that we reduced to a group/monoid action was nice too
23:45:58 <metahumor> that's the only one that's very difficult to do with solely a "inputFile -> answer" code
23:46:07 <metahumor> day23 i mean
23:57:11 <jle`> yeah i liked how it required some thinking beyond the actual literal algorithm
23:57:17 <jle`> ther ewere only a couple of those this year
23:57:22 <jle`> the dance one was the other one i tink
