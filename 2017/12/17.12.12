00:10:56 <clinton> I'm a bit confused about Template Haskell scope. When I use something like "lookupValueName", is the name resolved in the module "lookupValueName" is used, or the module it's called from (i.e. where the splice finally goes)?
00:17:12 <jle`> man i rewrote AoC today as a foldMap over a disjoint sets monoid
00:17:22 <jle`> and the runtime makes me sad
00:17:46 <jle`> newtype DisjointGroups a = DG (S.Set (S.Set a))
00:18:06 <jle`> instance Ord a => Monoid (DisjointGroups a) where ...
00:18:27 <jle`> i wonder what the bottleneck is
00:21:20 <koz_> jle`: A Set of Sets? Ow.
00:21:21 <jle`> 20 seconds for foldMapping 2000 lines, that means 10ms per mappend
00:21:29 <jle`> yeah i thought it'd be fast
00:21:34 <jle`> maybe if i use IntSet instead
00:21:44 <jle`> yeah it's just a set of disjoint sets, no biggie
00:25:17 <jle`> oh using `Set IntSet` cuts it down to about 3-4 seconds
00:27:21 <jle`> not bad but not ideal
00:30:11 <jle`> oh
00:30:17 <jle`> it was an assocation problem
00:32:30 <jle`> or a commutativity problem.  i flipped the arguments to mappend and now the whole thing is 52ms, so 20 microseconds per item, much more reasonable
00:37:17 <osa1> ugh BoundedChan also has the same behavior...
00:37:51 <Gurkenglas> Is there a way jle`'s problem could have been solved on the type level?
00:37:56 <Gurkenglas> *prevented
00:38:37 <jle`> maybe, but i think it mostly came down to the fact that my implementation was heavily biased
00:38:51 <jle`> i could have just done a quick check
00:39:06 <jle`> in mappend, and swap the arguments if they are improperly balanced
00:47:50 <dmwit> Perhaps mappend for Set/IntSet ought to already do that.
00:52:23 <jle`> it probablt does, but i'm writing my own mappend operation that's a bit different
00:54:06 <jle`> i foldl an operation updating one set over all of the items of another
00:54:09 <jle`> https://github.com/mstksg/advent-of-code-2017/blob/master/src/AOC2017/Day12.hs
01:03:45 <raduom> Hi everyone. Is FlexibleInstances something I should worry about?
01:04:26 <liste> raduom: no, FlexibleInstances is okay
01:08:59 <jle`> FlexibleInstances is one of those extensions that i feel like the people who made haskell intended things to work that way, but just made an oversight in the spec
01:09:19 <jle`> (even though it might have been a conscious decision, that's just what i want to believe :3)
01:09:28 <jle`> also in this category are -XTupleSections
01:30:52 <osa1> ScopedTypeVariables
01:47:12 <jle`> i'm traveling to a place tomorrow where AoC challenges will come out at 11pm in that time zone
01:47:53 <jle`> i wonder how much that would affect how i do
01:48:37 <cocreature> jle`: probably still better than my timezone where they come out at 6am :)
01:48:41 <pja> Kind of feel it was cheating to use Data.Graph today.
01:48:55 <jle`> i mean, use the right data structure :)
01:49:12 <jle`> it looks like the 2/1 solution used a graph library in python
01:49:43 <pja> I seem to spend longer writing parsers for some of these problems than I do writing the actual code to solve them.
01:50:40 <quchen> jle`: I’ve been told it makes the typechecker significantly harder
01:50:48 <quchen> …but then, so do type classes
01:51:34 <jle`> quchen: is that referring to my location change?
01:51:57 <quchen> jle`: The comment about flexible instances earlier
01:52:05 <quchen> Oh, that was almost an hour ago, I didn’t look at the timestamps
01:52:18 <jle`> ah that does make sense
01:53:17 <pja> I should probably have used the (read "["++data++"]") trick again instead of writing a full parser. Would have been quicker...
01:53:48 <jle`> probably better than me deleting all the commas in vim and using map read . words, heh
01:54:12 <jle`> i just did `map (read . filter isDigit) . words` this time
01:54:52 <quchen> That all sounds so dirty you might as well use regex
01:55:10 <quchen> And for me to consider Regex means something has to be *really* dirty
01:56:01 <SAW> ciao
01:59:32 <dminuoso> Wew. So after 2 months learning about monads and some category theory, I have not learned even the most basic ropes of IO. Now that Im taking all these IO things into hand, they are so easy to use. =)
02:00:06 <infinisil> dminuoso: You learned about this stuff for 2 months without ever using them once??
02:00:46 <dminuoso> infinisil: Oh I used monads alright, just not IO beyond just putStr/getLine
02:01:44 <dminuoso> Which for now was enough to do some rudimentary REPL. :)
02:02:29 <quchen> Why would you learn category theory (for Haskell) before doing IO :-S
02:02:43 <tdammers> well, there are two rather distinct things about IO: the monadic API, and the way it is a DSL for stateful real-world interactions
02:02:53 <quchen> (Why would you ever learn category theory for IO, for that matter)
02:03:26 <dminuoso> quchen: Well.. it all started with just stepping over a shrouded sentence "Monads are just monoids in the category of endofunctors", so I wanted to know what that exactly meant..
02:03:46 <quchen> It’s a joke, that’s what it means.
02:04:13 <quchen> It’s like learning quantum electrodynamics before using a light switch.
02:04:14 <dminuoso> Well only in the sense that that notion is not very helpful in Haskell. =P
02:04:27 <dminuoso> quchen: I didn't know that at the time!
02:04:34 <quchen> :-þ
02:05:02 <infinisil> The amount of monad tutorials is too damn high
02:05:24 <jle`> i still see people going "how does haskell do IO with pure functions? using monads!!"
02:05:38 <jle`> and so IO tutorial = monad tutorial, for some reason, explaining monads?
02:05:40 <jle`> but why
02:05:48 <jle`> this frustrates me a lot still heh.  i thought we had moved past this
02:06:21 <jle`> or "if you want to do IO you have to use monads"
02:07:03 <jle`> and people would avoid doing ny IO because they tried learning about monads and couldn't get it
02:07:07 <dminuoso> jle`: I've actually looked into pre-monad IO, my TODO list has an item called "Find a pre-monad haskell compiler and see how things wentback then"
02:07:08 <tdammers> yeah... the right answer to "how does haskell do IO with pure functions" is "it doesn't, it just *describes* the IO, and then the impure runtime does the dirty work"
02:07:25 <cocreature> learning a ton of category theory before understanding the basics of actually programming in Haskell is a trap that I fell into as well
02:07:42 <jle`> yeah saying you use monads to do IO is like saying that you use groups to do addition
02:07:48 <dminuoso> cocreature: In all honesty, while most doesn't seem to applicable it was highly enlightening regardless.
02:08:15 <jle`> "how do you add numbers in monad?    --- well FIRST OF ALL let's talk about group theory"
02:08:17 <tdammers> and in order to describe that IO in a pure language, we have this neat little EDSL, and it happens to be a match for the "Monad" pattern
02:08:35 <jle`> *how do you add numbers in haskell?
02:08:37 <cocreature> dminuoso: sure I don’t regret having learned it. but if your goal is becoming better at writing Haskell code, there are far more important things to learn
02:08:51 <tdammers> and because we like to be honest about things, we want things that match the Monad pattern to have an instance of the Monad typeclass
02:10:16 <tdammers> or, if you prefer, rather than ask "how do monads allow us to do IO in a pure language", you should ask, "how do IO operations fit the monad pattern"
02:10:27 <ggVGc> do you guys use DuplicateRecordNames?
02:10:34 <ggVGc> are there any pitfalls with it?
02:10:52 <dminuoso> tdammers: Yeah, I mean I now see monads in Haskell "just" as function composition with.. functions of a certain shape.
02:11:46 <TMA> jle`: the reply does not state, that there is a talk on another subject first. the reply to "how do you add numbers in haskell?" is "a monoid is a semigroup with identity"
02:12:36 <Logio> dminuoso: so you see them as a monoid in the category of endofunctors? :)
02:13:22 <hololeap> how do you add numbers in haskell? with sum types of course
02:13:53 <dminuoso> Logio: I suppose there's various ways to view them. The most useful that I have found now is "A monad is an endofunctor F, where arrows a -> F b form a category theory. That basically encompasses the idea how it fits into Haskell in a clean way
02:14:04 <sphinxo> Any hope pulling in stackage/hackage deps with bazel?
02:14:05 <dminuoso> *form a category
02:14:14 <jle`> ggVGc: we're still in the early days of their adoption i think
02:14:34 <TMA> Logio: incidentally that is the single explanation that somewhat makes sense if you stare at it long enough
02:14:40 <dminuoso> Logio: And by that I mean a clean category theory perspective, that directly implies these arrows are composable.
02:14:50 <Logio> TMA: yes, that's the conclusion I've come to
02:15:35 <Logio> I've been starting to lean towards focusing on the monoid structure when trying to teach monads 
02:16:08 <Logio> because the biggest part of using them is really just function composition with funny signatures
02:16:49 <dminuoso> Logio: I started out with that perspective, but it had less intuition for me. I mean what would IO (IO ()) mean?
02:17:22 <Logio> in what context?
02:17:24 <hololeap> monads in haskell are closer to kleisli arrows than monads in category theory, no?
02:17:24 <infinisil> STM (IO ()) <- really useful
02:17:42 <dminuoso> hololeap: they are directly related.
02:17:59 <hololeap> right...
02:18:02 <hololeap> and?
02:18:37 <hololeap> a monad in category theory is just a functor with a couple of natural transformations... there's not direction like the moands in haskell
02:18:40 <dminuoso> Logio: Well, what does IO x IO mean? What does that do?
02:19:17 <hololeap> the direction implies an arrow... a kleisli arrow
02:19:51 <dminuoso> hololeap: Like I said. I prefer the definition: An endofunctor F is exactly then a monad, if the arrows `a -> F b` for any a and b form a category (i.e. they compose)
02:19:52 <Logio> dminuoso: It's an IO action that provides another IO action
02:20:14 <Logio> dminuoso: but I don't really feel that that has anything to do with monads, other than the fact that IO happens to be one 
02:20:50 <hololeap> dminuoso: right, but only if you're talking about monads specifically in haskell, not monads in category theory
02:20:56 <infinisil> IO x IO = (IO a, IO b)  or  IO (IO a) ?
02:21:02 <Logio> the arrows a -> F b and >>= are where the magic happens
02:21:04 <dminuoso> hololeap: This holds true in any category.
02:21:07 <hololeap> (and all functors in haskell are endofunctors)
02:21:18 <Logio> not the compositions of the monadic types
02:21:52 <dminuoso> Logio: early on I didnt understand it. `join` is the category perspective, and >>= is the "programming related" perspective. Now I do :)
02:21:59 <hololeap> dminuoso: what you are defining is a kleisli arrow, which needs a monad to work, but isn't a monad itself
02:22:12 <dminuoso> hololeap: I just defined what a monad is.
02:22:21 <hololeap> ...
02:22:25 <dminuoso> hololeap: The endofunctor *F* itself is exactly then a monad, if the above condition holds true.
02:22:31 <dminuoso> *F* is the moand.
02:22:56 <hololeap> dminuoso: are you talking about a monad in category theory or haskell?
02:23:01 <dminuoso> Any category.
02:23:08 <hololeap> haskell isn't a category
02:23:19 <hololeap> it's a programming language
02:23:29 <hololeap> that uses rough analogies to category theory
02:24:01 <Athas> Haskell is category theory fanfiction.
02:25:39 <hololeap> https://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition
02:25:42 <Sornaensis> Hask is a category
02:26:20 <merijn> Sornaensis: Ish...
02:26:43 <hololeap> that's all a monad is in category theory... an endofunctor with two natural transformations that fufill the laws... there's nothing about composition because there's no arrows at that level
02:27:06 <merijn> Hask is "if I beat Haskell long enough it'll eventually fit!"
02:27:55 <Sornaensis> hask is a category if you squibt
02:27:59 <Sornaensis> squint also
02:28:08 * hololeap squibts
02:28:31 <dminuoso> hololeap: Im talking about category theory in general
02:28:43 <dminuoso> hololeap: Or rather that the definition holds true in CT in general, not that its generally useful.
02:28:56 <hololeap> dminuoso: i just posted the definition according to wikipedia
02:29:46 <hololeap> the composing (a -> F b) comes from an added structure, which is more akin to a kleisli arrow than a pure category-theory monad
02:29:50 <dminuoso> hololeap: The definition is equivalent.
02:30:17 <dminuoso> hololeap: Both work.
02:30:19 <hololeap> a functor with two natural transformations is just a set of mappings... there's no direction yet
02:31:34 <hololeap> anyway, my point is that a monad in category theory is not exactly the same as a monad in haskell
02:32:31 <hololeap> and so, yeah, that "a monad is a monoid in the category of endofunctors" thing is unnecissarily confusing to people who think they're talking about haskell monads
02:32:42 <merijn> Haskell's Monad is just Wadler mugging mathematicians for spare abstractions
02:33:03 <merijn> hololeap: That quote is also a joke, that keeps getting repeated too much to still be funny
02:33:46 <hololeap> i knew it was a joke, but thought the humor came from the fact that it sounds "mathy", not that it was not correct
02:33:56 <hololeap> when i first was like, "wtf is a monad?"
02:34:24 <hololeap> i mean it is correct in purely ct terms
02:34:36 <hololeap> but i wanted to know what a haskell monad was
02:34:36 <dminuoso> hololeap: Im unsure about what your point is really. Are you stating that monads in Haskell do not satisfy the formal conditions, or that it in any way conflicts with my definition?
02:34:53 <hololeap> dminuoso: they have extra structure that monads in ct don't have
02:35:15 <dminuoso> hololeap: What exactly?
02:35:32 <dminuoso> :i Monad
02:35:55 <merijn> hololeap: You might have more success with this discussion in a few hours when the CT addicts from the US come online :)
02:36:30 <dminuoso> hololeap: I mean Im honestly interested in how it's not an exact fit, because all the recent discussion with the CT crazy people in here have led me to believe otherwise.
02:36:56 <hololeap> the two natural transformations can wrap a value in a functor or unwap a twice-wrapped value...
02:37:15 <dminuoso> :t join
02:37:15 <dminuoso> :t return
02:37:16 <lambdabot> Monad m => m (m a) -> m a
02:37:17 <lambdabot> Monad m => a -> m a
02:37:17 <hololeap> this doesn't say anything about directionality... just that these options exist
02:37:24 <dminuoso> hololeap: ^-
02:38:08 <dminuoso> hololeap: all the kleisli arrow perspective is a natural result from it being a) an endofunctor and b) being equipped with those natural transformations.
02:38:11 <hololeap> it just says that you *could* go from a to F a, or from F (F b) to (F b)... there's no direction from this alone
02:38:18 * frerich thinks the Haskell code by Graham Hutton is so pretty that 'If in doubt, do as Hutton would do' should be his new mantra.
02:39:26 <hololeap> when you are going SPECIFICALLY from a wrapped value to an unwrapped value, to a wrapped value in that order, and forming a directionality, it is closer to a kleisli arrow than a monad. this is what monads in haskell do
02:39:59 <hololeap> `getChar >>= putChar` has a very specific order of events, which implies an arrow
02:40:07 <hololeap> does that make sense?
02:40:30 <hololeap> i'm honestly pretty new to all this but that is my understanding
02:41:03 <hololeap> a kleisli arrow needs a monad to work, so they are directly related, like you said
02:41:09 <hololeap> but not the same
02:43:58 <dminuoso> hololeap: m >>= f is 100% equivalent to `join $ fmap f m`
02:44:33 <merijn> alternatively, join is "m >>= id"
02:45:15 <dminuoso> hololeap: The kleisi perspective and the monad perspective are equivalent. Neither has "more" or "less" structure. They are equivalent.
02:45:38 <hololeap> in category theory, they are not equivalent
02:45:43 <dminuoso> Yes they are.
02:46:04 <hololeap> if you look it up, you will see they aren't. a kleisli arrow has a monad in its definition, but not the other way around
02:46:28 <merijn> hololeap: There is no kleisli arrow in the definition of any of this
02:50:48 <hololeap> (runKleisli $ Kleisli putChar . Kleisli (const getChar)) ()  ===  putChar >>= getChar
02:51:28 <hololeap> so a monad in haskell is pretty much a kleisli arrow, but a monad in category theory is a building block of a kleisli arrow
02:52:13 <merijn> monads in haskell aren't kleisli arrows
02:52:22 <merijn> they don't even have much to do with kleisli arrows
02:52:51 <hololeap> :i Kleisli
02:53:03 <merijn> It's just, that the most common way of using a monad is "a -> m b" in haskell, which happens to be a kleisli arrow, but that's not relevant to what monads are
02:54:44 <hololeap> well... the nature of computing means that certain mappings must happen before other mappings... they can't just exist simultaneously like they do in mathematics
02:55:16 <hololeap> and you could rewrite literally any code using monads with Kleisli instances
02:55:23 * hackage movie-monad 0.0.2.0 - Plays videos using GStreamer and GTK+.  https://hackage.haskell.org/package/movie-monad-0.0.2.0 (lettier)
02:56:10 <hololeap> (maybe instances isn't the best word choice... hopefully you know what i mean)
02:58:19 <dminuoso> hololeap: If you have a category C equipped with an Endofunctor F, then if F is equipped with natural transformations η and μ following the specified laws, then the arrows a -> F b form a category (namely the Kleisli category). These two are intimately related - you can derive one from the other I think.
02:59:11 <hololeap> but if you take out the part about arrows from a -> F b forming a category on your own, you still have a valid monad
02:59:15 <hololeap> in ct
02:59:36 <hololeap> *on their own
03:00:22 <hololeap> endofunctor and two natural transformations... that's it... nothing about kleisli categories in the ct definition of a monad
03:00:36 <kakashiAL> can anyone please explain me why they named this datatype "fromNullable"?
03:00:38 <kakashiAL> https://hackage.haskell.org/package/fay-base-0.21.0.0/docs/Data-Nullable.html
03:01:10 <cocreature> that’s not a datatype, that’s a function
03:01:26 <cocreature> and it’s called fromNullable because it converts from Nullable a to Maybe a
03:03:02 <kakashiAL> cocreature: ahh okay, thanks :)
03:03:22 <kakashiAL> cocreature: I would call it fromNullableToMaybe then
03:04:05 <cocreature> sure that’s also a valid option
03:04:13 <cocreature> although I would omit the "from" prefix in that case
03:05:00 <cocreature> naming things is hard
03:08:04 <merijn> cocreature: That's why I try and write everything pointfree ;)
03:08:52 <yushyin> it is also fromInteger and not fromIntegerToNum ... so fromNullable is ok, I guess
03:11:57 <kakashiAL> yushyin: so fromSOMETHING is a convention that means "from SOMETHING to Maybe" ?
03:12:23 <cocreature> no, “fromSOMETHING” just means “from SOMETHING to something else” :)
03:13:31 <kakashiAL> cocreature: hmm :( 
03:13:47 <kakashiAL> cocreature: so you have to know the X in fromSOMETHING to X :/
03:14:12 <cocreature> kakashiAL: well you can just look at the type of the thing.
03:14:14 <merijn> kakashiAL: That's usually implicit in the module
03:14:29 <cocreature> "Nullable a -> Maybe a" tells you about as much as calling it "nullableToMaybe"
03:22:35 <kakashiAL> cocreature, merijn: sure, but you need to look up the type but explicit is always better than implicit :)
03:23:30 <cocreature> kakashiAL: well a type signature is still explicit (at least if you don’t let GHC infer it and even then it’s explicit in the haddocks). it’s just not explicit in the name
03:25:09 <yushyin> names can lie, types not (usually)
03:25:53 * hackage modern-uri 0.1.2.0 - Modern library for working with URIs  https://hackage.haskell.org/package/modern-uri-0.1.2.0 (mrkkrp)
03:25:58 <cocreature> anyway, I think for this specific case I could agree that "nullableToMaybe" might be a better name but in general you just can’t put all the information about a function in its name
03:26:15 <sphinxo> why am I getting errors about not finding base? http://lpaste.net/3727464157553885184
03:26:46 <sphinxo> ( i'm passing -package base to ghc )
03:27:05 <cocreature> sphinxo: that looks bad, how did you install ghc?
03:28:23 <sphinxo> through my package manager ( pacman ), although I usually do everything through stack
03:29:13 <cocreature> that seems weird, archlinux has 8.2.2 in its repositories, not 8.2.1
03:29:19 <cocreature> did you do some partial update?
03:29:53 <sphinxo> just updated now
03:29:58 <sphinxo> ( right now)
03:31:10 <sphinxo> hmm
03:32:07 <cocreature> sphinxo: oh do you have ghc-static installed? the arch maintainer thought it would be a good idea to break the default linking mode of ghc
03:32:23 <sphinxo> so Applicative.dyn_hi exists in  /usr/lib/ghc-8.2.2/base-4.10.1.0/Control/ but not /Applicative.hi
03:32:43 <cocreature> sounds like you’re missing ghc-static
03:32:56 <merijn> Sounds it's "Blame Arch"-o'clock, again
03:33:27 <sphinxo> ( note I'm also trying to use bazel, so that may be it )
03:33:51 <cocreature> I’m fairly sure that all you need to do is install ghc-static as I’ve suggested multiple times by now :)
03:34:12 <sphinxo> ( yeah that fixes that error )
03:34:49 <sphinxo> thanks cocreature :)
03:47:53 <mockingsponge121> My anaconda don't, my anaconda don't My anaconda don't want none unless you got buns, hun Boy toy named Troy used to live in Detroit Big big big money, he was gettin' some coins Was in shootouts with the law, but he live in a palace Bought me Alexander McQueen, he was keeping me stylish Now that's real, real, real One in my purse, bitch, I came dressed to kill Who wanna go first? I had them pushing daffodils I'm high as hell
03:49:02 <mockingsponge121> My anaconda don't, my anaconda don't My anaconda don't want none unless you got buns, hun Boy toy named Troy used to live in Detroit Big big big money, he was gettin' some coins Was in shootouts with the law, but he live in a palace Bought me Alexander McQueen, he was keeping me stylish Now that's real, real, real One in my purse, bitch, I came dressed to kill Who wanna go first? I had them pushing daffodils I'm high as hell
03:49:12 <mockingsponge121> My anaconda don't, my anaconda don't My anaconda don't want none unless you got buns, hun Boy toy named Troy used to live in Detroit Big big big money, he was gettin' some coins Was in shootouts with the law, but he live in a palace Bought me Alexander McQueen, he was keeping me stylish Now that's real, real, real One in my purse, bitch, I came dressed to kill Who wanna go first? I had them pushing daffodils I'm high as hell
03:50:21 <mockingsponge121> My anaconda don't, my anaconda don't My anaconda don't want none unless you got buns, hun Boy toy named Troy used to live in Detroit Big big big money, he was gettin' some coins Was in shootouts with the law, but he live in a palace Bought me Alexander McQueen, he was keeping me stylish Now that's real, real, real One in my purse, bitch, I came dressed to kill Who wanna go first? I had them pushing daffodils I'm high as hell
03:50:22 --- mode: ChanServ set +o dibblego
03:50:26 --- mode: dibblego set +b *!*@gateway/web/freenode/ip.87.82.211.21
03:50:32 --- kick: mockingsponge121 was kicked by dibblego (mockingsponge121)
03:50:42 --- mode: dibblego set -o dibblego
03:50:44 <Saulzar> I have a question - which I guess is more general than Haskell, but I'm using Haskell... I'm using acid-state and I have some state which is not persistent - specifically I'm writing an image annotation backend, e.g. state like a particular user has open which document etc.  Would you put that state in the acid-state store or separately (e.g. MVar)? It seems tricky to keep two sources of state 
03:50:45 <yoneda> thx dibblego
03:53:29 <merijn> Saulzar: No, I would not put non-persistent state in acid-state
03:53:47 <merijn> That's only going to slow you down and clutter up your persistent state
03:57:54 <sphinxo> how can I get a topologically sorted list of dependencies?
03:58:53 <sphinxo> ok this looks helpful https://hackage.haskell.org/package/cabal-sort
03:59:05 <Saulzar> That was my assumption too, then I started thinking more and it seemed maybe it might actually be good to have a single source of state (i.e. it's easier to write an atomic operation over all sources of state that way).
03:59:51 <Saulzar> I'll try it separately first, anyway. Cheers
04:10:02 <ij> What are these ats(@) in front of _ in code(i.e. not pattern matching)? https://gist.github.com/Icelandjack/ae22c42b01c9be7e8a82f80bc8ab3f1c
04:10:44 <lyxia> ij: TypeApplications
04:11:03 <Bish> !balance
04:11:07 <Bish> oops
04:12:00 <lyxia> ij: if (f :: forall a b c . F a b c), then (f @x @y @z :: F x y z). @_ lets the compiler infer some of these arguments
04:13:43 <ij> That's hella cool. You can force type with (value :: forall a c . F a x c), but value value @_ @x will be shorter.
04:16:58 <lyxia> ij: there are cases where (_ :: _) is not sufficient, because the value's type is too ambiguous. For example, if F is a type family.
04:17:13 <lyxia> Before that extension we had to use proxies.
04:46:43 <Psybur> What do you guys think about Liquid Haskell?
04:48:55 <hpc> Psybur: it violates the principle of DRY :P
04:49:07 <hpc> (but seriously, it seems neat)
04:50:05 <Psybur> hpc, how does it do that? Seems like it would be DRY if you can keep logic pertaining to types with the types so you dont repeat those checks everywhere in your program
04:51:57 <hpc> it doesn't, it was a pun
04:53:24 <Psybur> Oh you
04:56:10 <ij> lyxia, Can you shine some more light on that or give a simple example?
05:03:05 <Nate712> hey I'm trying to write a type checker in haskell, and honestly... I don't know where to start
05:03:45 <sphinxo> Nate712: http://dev.stephendiehl.com/fun/004_type_systems.html
05:05:07 <sphinxo> Nate712: type checked arithmatic https://github.com/sdiehl/write-you-a-haskell/tree/master/chapter5/calc_typed
05:05:41 <Nate712> yeah I've been trying to follow that, but it lost me when it started using Except.. because trying to import that caused issues.
05:05:51 <Nate712> though it is admittedly something that has eased my confusion
05:06:34 <swaglord> yo
05:06:48 <Psybur> What is up, swaglord?
05:06:51 <Nate712> thank you for that second link in particular though, not managed to come across that before
05:07:14 <swaglord> they call me swaglord
05:07:20 <swaglord> aka the landmine lieutenant
05:07:27 <swaglord> aka frosty the snow thug
05:07:44 <swaglord> aka the granddaddy grenade man
05:07:44 <swaglord> aka the ammunition magician
05:07:50 <swaglord> aka the doctor of destruction
05:07:56 <swaglord> aka the motherfuckin mother molestor
05:08:02 <swaglord> aka jamuel jackson
05:08:07 <swaglord> aka captain crunk
05:08:15 <swaglord> aka the pastor of pimpin
05:08:21 <swaglord> aka the clitoris wrangler
05:08:26 <swaglord> aka the captain of decapitation
05:08:31 <swaglord> alright i have no more
05:08:33 <swaglord> call me kyle tho
05:08:41 <swaglord> arrays start at 1
05:08:49 <Psybur> You monster.
05:09:02 <sphinxo> no, arrays start at -1
05:09:17 <Rembane> Arrays always start and especially end where you don't expect them too.
05:09:27 <swaglord> get booty blasted
05:09:29 <swaglord> nerds
05:11:40 <sbrg> where does one go to get booty blasted?
05:11:44 <sbrg> i am intrigued
05:12:03 <zomg> I wonder where do arrays start at in Malbolge?
05:12:27 <sphinxo> sbrg: definitely not #haskell
05:12:32 <Rembane> My guess is at a random place.
05:12:50 <ventonegro> booty blasted at random places
05:12:51 <sbrg> zomg: they start in the ninth circle of hell
05:13:01 <zomg> plausible
05:13:03 <quchen> Reminder that PHP’s arrays start at 0 except when they don’t, which is much worse than most esoteric langauges you could come up with.
05:13:10 <swaglord> frosty the snow thug is gonna run up in your crib and put a bullet in your rib 
05:13:12 <hpc> php's arrays start at "0"
05:13:28 <Nate712> sphinxo: I can't follow the example because for some reason I don't have Control.Monad.Except is this something I am supposed to download from somewhere?
05:13:30 <quchen> They have an internal pointer, so sometimes where they start or are is stateful.
05:13:48 <sbrg> hpc: I'm visualizing someone saying that sentence outloud, doing quotes in the air with their fingers
05:13:51 <sbrg> winking
05:14:06 <sphinxo> Nate712: how are you building your project?
05:14:27 <sphinxo> are you running a command, if so what command?
05:14:48 <Nate712> currently I'm just using the base stuff, but it's going through emacs
05:15:10 <sphinxo> like stack build? ghc ?
05:16:01 <Nate712> i'm just looking in my config files now
05:18:37 <Nate712> sphinxo: it's currently going through emacs, using ghci
05:18:42 <sphinxo> ok cool
05:19:08 <sphinxo> and in your project do you have a .cabal file? 
05:20:08 <Nate712> no
05:20:16 <sphinxo> just .hs files?
05:20:19 <Nate712> I do not have a proper project folder yet
05:20:22 <Nate712> and yes, just .hs
05:22:09 <ggVGc> haskell development without stack is no fun, in my experience..
05:22:24 <ggVGc> I do stack new even for simple test scripts
05:22:33 <ggVGc> becuase then everything just works
05:22:36 <sphinxo> Nate712: do you have stack installed? 
05:22:48 <ggVGc> and it's even less work than making a shell script running ghc automatically
05:22:52 <sphinxo> ( try stack --version )
05:23:23 <Nate712> neither are installed
05:23:33 <myname_> hi
05:23:41 <myname_> does anybody use Spock here?
05:24:00 <sphinxo> Nate712: I'd recommend you install that curl -sSL https://get.haskellstack.org/ | sh
05:24:07 <sphinxo> or through your package manager
05:24:14 <myname_> I wish to know how to get current URL in Spock
05:24:56 <Nate712> just started it through my package manager... thankfully set up the haskell specific repos.
05:27:57 <myname_> :q
05:31:15 <hellcook> Hi
05:32:46 <hellcook> Haskell really seems awesome. I've tried many times to learn it, but I've always lacked a project to exercise on. So I'd like to ask: how did you learn and practiced haskell?
05:33:43 <sphinxo> hellcook: how do you learn other languages? ( if you have )
05:33:55 <fakenullie> hellcook: I'm currently through the haskell book
05:34:11 <Saulzar> hellcook: I wrote a tiny raytracer, find some familiar task and do it again :)
05:34:45 <fakenullie> made much more progress than trying to do it through tutorials
05:35:34 <hellcook> sphinxo: I learnt other languages out of necessity ( either as a student or at work )...
05:35:42 <sphinxo> ah ok
05:37:02 <Psybur> hellcook, I made an algorithmic trader/backtesting framework. Thats how Ive been learning haskell
05:37:11 <hellcook> fakenullie: I've tried through the "real world haskell" book, but I found it "too slow" and got bored in (what seem to me) not very interesting details
05:38:02 <ventonegro> hellcook: ray tracer, chess engine, compiler, neural network...
05:38:16 <fakenullie> well, you can skip chapters, but you could have to go back once you stopped understanding next ones
05:38:20 <hellcook> Saulzar: impressive, did you use some particular libraries?
05:39:29 <hellcook> Psybur: impressive too, same question: did you use any external library to connect it to the real world?
05:39:59 <hellcook> ventonegro: good ideas
05:40:10 <Psybur> hellcook, of course
05:40:52 <hellcook> cool
05:41:10 <Psybur> hellcook, https://github.com/jrciii/money-machine/blob/master/money-machine.cabal
05:41:23 * hackage docker-build-cacher 1.8.0 - Builds a services with docker and caches all of its intermediate stages  https://hackage.haskell.org/package/docker-build-cacher-1.8.0 (lorenzo)
05:44:05 <hellcook> Psybur: nice. It would benefit from a readme imho.
05:44:30 <Psybur> hellcook, I dont expect anybody to be using this yet :D
05:44:54 <Psybur> Just in git to save my work at this point. I suspect the backtesting is actually wrong, so Im in the middle of making some unit tests for it
05:45:10 <Psybur> Once its tested I might "release" it
05:47:16 <hellcook> thank you everyone
05:48:45 <saurabhn_> just x-posting this here: https://www.reddit.com/r/haskell/comments/7jat9s/looking_for_motivated_haskell_newbies_to/
05:56:22 <lyxia> ij: http://lpaste.net/360722
05:59:23 * hackage hoogle 5.0.15 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.15 (NeilMitchell)
06:03:23 * hackage lentil 1.0.9.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.0.9.1 (fffaaa)
06:06:21 <siwica> I am having issues with stack. I added 'import Data.List.Split' to my Lib.hs, ran 'stack install split' and added 'split' to the library build-depends section of my .cabal file. Still I get the error 'Failed to load interface for ‘Data.List.Split’. It is a member of the hidden package ‘split-0.2.3.2’.'
06:06:21 <siwica>  
06:06:23 * hackage dejafu 0.9.1.2 - Systematic testing for Haskell concurrency.  https://hackage.haskell.org/package/dejafu-0.9.1.2 (barrucadu)
06:06:27 <siwica> What am I doing wrong?!
06:09:06 <kadoban> siwica: Check which section you added it to in the .cabal file
06:09:14 <kadoban> siwica: Also, 'stack install split' was not needed.
06:11:10 <siwica> kadoban: I added it to the build-depends subsction of library
06:11:10 <siwica>  
06:12:02 <siwica> Which I thought is where it is supposed to go
06:13:40 <kadoban> sw1nn: Are you using it in the executable or test-suite directly?
06:14:04 <kadoban> If so, it needs to be there (every component you're directly using it in)
06:14:17 <siwica> I am simply running stack build and it throws an error
06:14:39 <siwica> And I am only using it directly in Lib.hs
06:14:53 * hackage hlint 2.0.12 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.0.12 (NeilMitchell)
06:14:55 <kadoban> You'd have to share your current files, I guess the .cabal file and the full error output
06:18:08 <hvze> hmm
06:18:35 <hvze> are states replacement for global variables? that are also “mutable”?
06:18:56 <siwica> kadoban: http://lpaste.net/3854892384072499200
06:20:03 <siwica> http://lpaste.net/360724
06:20:52 <kadoban> siwica: What stack version are you on? It looks like your .cabal file is actually generated from an hpack file, package.yaml. You should be editing that instead. If you switch to newest stack, the way that works gets a *lot* better, there's a nice warning and a fallback to the cabal file so it's less confusing.
06:21:15 <kadoban> (1.6.1 is newest)
06:21:30 <siwica> 1.3.0
06:21:44 <siwica> That's the most recent Ubuntu provides at the moment
06:22:15 <kadoban> I wouldn't stick with what ubuntu provides
06:22:31 <kadoban> But for this it probably won't matter, just the behavior is a lot better for hpack.
06:23:00 <Saulzar> hellcook: I think I found some code to write images to disk, but back around 2005 I'm not sure hackage existed - or at least I don't remember it so :)
06:23:28 <Saulzar> hellcook: So, not really - but it was super simple..
06:23:41 <siwica> kadoban: Ok, stupid me. I thought I'd have to edit foo.cabal directly. Adding the dependencies in package.yaml solves the issue
06:24:03 <siwica> I guess that's a case of RTFM, but I wanted to get started rather quickly
06:24:05 <kadoban> Yeah, it's a bit confusing before 1.6.1 unfortunately. Cool
06:25:01 <siwica> kadoban: Thank you anyways. I will checkout a more recent version of stack, if I find some time
06:25:14 <jcjf> RTFM doesn't belong to the modern computing world
06:25:28 <kadoban> siwica: It's pretty easy to do, just for future you: 'stack upgrade' should get you there with little work.
06:26:21 <siwica> jcjf: Elaborate on this?
06:26:56 <jcjf> siwica: It's an old attitude. Sometimes the manual is poorly written!
06:30:42 <hoon> looking for feedback on the function lcmFactors here: http://lpaste.net/360725 -- I realize this is not the best way to compute the least-common-multiple, I was curious if I could implement it this way.
06:33:56 <lyxia> there are two groups that you could merge in one
06:34:10 <lyxia> ... no sorry nvm.
06:34:41 <lyxia> that looks correct
06:35:52 <hoon> out of curiousity (and I'm aware of hoogle) is there a place I should go to try to find existing functions that might simplify my own functions
06:36:21 <hoon> or is that just something I'll learn as I get more familiar with Haskell?
06:37:13 <lyxia> Just scour the documentation looking for new functions.
06:37:24 <fakenullie> hoon: you can also try pointfree.io
06:37:30 <kadoban> hoon: Experience, asking here, hoogle, etc.
06:37:36 <Psybur> hoon, yeah just reading all of things like Data.Foldable, Control.Monad etc
06:37:40 <hoon> for example: someone told me yesterday that traverse_ f a = sequence_ $ liftM f a
06:37:42 <kadoban> hoon: Oh, hlint too
06:38:04 <hoon> so hackage scouring?
06:38:04 <frerich> hoon: Instead of `head a == head b` you could use `(==) `on` head'. And `\a b -> length a `compare` length b` is 'comparing length'.
06:38:08 <kadoban> hlint suggests a lot of simplifications, some bad, some good.
06:38:31 <hoon> kadoban: thanks for the suggestions
06:38:49 <hoon> frerich: thanks for those suggestions too. I recall `on` now
06:39:02 <hoon> sooooooooo many little functions to remember :)
06:39:21 <jcjf> Yeah... it's an overload for me... :(
06:39:21 <Psybur> :t on
06:39:22 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:39:32 <jcjf> :t comparing
06:39:34 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
06:40:11 <Psybur> > on (==) head [1,2] [1,3]
06:40:13 <lambdabot>  True
06:40:33 <Psybur> > (==) `on` head [1,2] [1,3]
06:40:36 <lambdabot>  error:
06:40:36 <lambdabot>      • Could not deduce (Num a0)
06:40:36 <lambdabot>        from the context: (Num ([a2] -> a3 -> a), Num a2, Eq a)
06:41:02 <Psybur> > ((==) `on` head) [1,2] [1,3]
06:41:04 <lambdabot>  True
06:41:28 <jcjf> Psybur: how did you quickly figure out which way you had an associativity problem?
06:41:53 <Psybur> jcjf, luck I guess heh
06:42:17 <jcjf> Argh... I need a more structured way to learn this stuff... it's paralysing
06:43:27 <Psybur> Im very comfortable with chaos. Double edged sword I guess. I can make stuff work but I cant explain how I do things sometimes
06:43:41 <hoon> haha
06:44:53 <mlehmk> Psybur, do you do things just cause it feels right without knowing why?
06:45:05 <Psybur> (comfort with chaos is actually a common attribute among programmers, not something I made up :D)
06:46:24 <Psybur> mlehmk, sometimes, generally only in programming where the worst that happens is i get a compile error and I try again :P
06:46:37 <jcjf> I've been working in nodejs... I don't find any comfort there, but I guess it's more comfortable than... socialising
06:46:49 <Psybur> I dont just go about life winging it if thats what you think :D
06:46:58 <mlehmk> jcjf, ever tried elm?
06:47:18 <jcjf> mlehmk: No... I'd rather learn ReasonML
06:47:33 <yen> uh, how do I use an MVar without overriding it?
06:47:47 <mlehmk> is there a target for JS in ReasonML?
06:48:11 <jcjf> yeah... it's Facebook's OCaml that targets JS
06:48:53 <jcjf> I'm not even a software programmer by day... just have to hack on random things between projects
06:49:26 <jcjf> And virtually nobody at work understands functional programming... :(
06:50:13 <yen> it sucks doesn't it?
06:50:22 <mlehmk> I understand enough of it to actually like it
06:50:47 <jcjf> mlehmk: me too... I understand too little to speak comfortably about it
06:50:57 <mlehmk> it also kinda changed my programming style in other languages, making use of immutables mostly and keeping methods pure if possible
06:51:08 <jcjf> mlehmk: yes!!
06:51:37 <mlehmk> I'd just like if I could get typescript and Immutablejs work better together
06:51:40 <jcjf> mlehmk: every kind of struct/object mutation makes you hesitate :)
07:03:45 <Nate712> sphinxo: ok, stack is currently installed and working, but still no Control.Monad.Except
07:07:31 <sphinxo> ok, best to make a project with the proper folder/file structure
07:08:17 <sphinxo> do: stack new <project_name> simple
07:09:11 <sphinxo> then in <project_name>.cabal edit the last line from
07:09:28 <sphinxo>   build-depends:       base >= 4.7 && < 5
07:09:37 <sphinxo> to:  build-depends:       base >= 4.7 && < 5, mtl
07:10:44 <lyxia> yen: readMVar
07:11:42 <lyxia> sphinxo: you can edit and make templates in .stack/
07:12:37 <sphinxo> Nate712: can you now import Control.Monad.Except?
07:13:02 <sphinxo> ( put your code in src/Main.hs )
07:13:46 <sphinxo> lyxia: ahh, good to know
07:14:40 <Nate712> o yep it allows me to sphinxo 
07:16:57 <sphinxo> Nate712: wonderful, have fun :)
07:20:40 <Nate712> thanks
07:38:53 * hackage top 0.2.4 - Top (typed oriented protocol) API  https://hackage.haskell.org/package/top-0.2.4 (PasqualinoAssini)
07:59:38 <rbo> Hello, I was wondering if someone can help me with this, I have never used Haskell, but here it is... https://gist.github.com/cocoabro/dd8c30c68a37667e973e3028722aa323
08:00:04 <rbo> How do I accept a command line argument in haskell?
08:00:41 <EvanR> :t getArgs
08:00:42 <lambdabot> error: Variable not in scope: getArgs
08:00:59 <EvanR> IO [String]
08:01:22 <EvanR> theres optparse-applicative for more complex arguments
08:05:28 <rbo> has anyone gotten this error on Mac OSX when using ghc? ld: can't open output file for writing: fizzbuzz, errno=21 for architecture x86_64
08:06:57 <mlehmk> rbo: 21 EISDIR Is a directory. An attempt was made to open a directory with write mode specified.
08:07:25 <mlehmk> probably a directory named fizzbuzz exists, while it attempted to create a file named fizzbuzz
08:07:31 <rbo> ahhh
08:07:32 <rbo> thanks!
08:10:00 <rbo> that worked mlehmk :) ty and now I know!
08:13:49 <mnoonan> is there a ghc plugin mechanism that would allow me to manipulate error messages coming out of the type checker? I have some little experiments I want to try..
08:26:32 <rbo> hey, I need some help, basically here is the challenge and the code that I have so far, but I want output like: 1, Fizz, 3, FizzBuzz, 5, Fizz as the output. I am extremely new to Haskell, any help would be greatly appreciated. https://gist.github.com/cocoabro/b4bd0254ad3b70ee60f37264f5b16a83
08:30:29 <frerich> rbo: I think a good start would be to move most of the code out of `main` and think about the involved types. For instance, it seems you identified that you need a function mapping integers to strings, so you could have a global `fizzBuzz :: Int -> String` function.
08:31:06 <glguy> rbo: Your code is almost perfect, you have a problem with your first divisibility check
08:31:12 <glguy> i `mod` s1 && s2 == 0
08:31:17 <glguy> This doesn't doe what you were hoping
08:31:26 <rbo> yea thats where I am stuck. 
08:31:29 <glguy> You need two separate uses of `mod` and ==
08:31:50 <rbo> ah
08:31:51 <glguy> && combines two booleans into one
08:32:34 <frerich> rbo: The second thing which seems noteworthy is that when a number is divisible by s1 then you get 'Fizz' and if it's divisible by s2 then you get 'buzz' and when it's divisible by both, you get the concatenation of those strings.
08:33:26 * hackage type-of-html 1.3.0.0 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.3.0.0 (knupfer)
08:33:35 <frerich> rbo: So you could maybe avoid two 'mod' uses by having something like 'let s = f ++ b in if null s then show i else s' and f is either 'Fuzz' or the empty string and 'b' is either 'Buzz' or the empty string.
08:33:36 <mlehmk> a thing that feels, like it could be optimized
08:33:53 <mlehmk> kind of a trap for interviews
08:33:53 <frerich> Not sure that'll be any prettier though :-]
08:34:14 <frerich> rbo: I like your code because it maps basically 1:1 to the problem description :-)
08:34:22 <frerich> It's easy to verify it.
08:34:22 <mlehmk> especially if it should print fizz or buzz except of the number
08:34:25 <rbo> Haha frerich this is my first time using Haskell, I was planning to get to it faster but... caught me off guard. 
08:34:31 <rbo> mlehmk yes it is for a job
08:35:06 <mlehmk> kind of a way to see, if the specs can be followed
08:35:09 <rbo> Junior programmer job. 
08:35:42 <rbo> mlehmk, do you think it is acceptable? I have 2 more challenges to finish after this. 
08:35:54 <rbo> I got the code working thanks glguy & frerich 
08:36:14 <rbo> It's sloppy... but they just want to see my flexibility with picking up new languages.
08:36:43 <frerich> rbo: Awesome job :-)
08:36:55 <frerich> rbo: (I mean, you did. Dunno about the job you're applying for ;-)
08:37:15 <rbo> Haha, it's a startup in las vegas, it will be awesome!  
08:37:45 <rbo> thanks, I had to use a lot of stack overflow... ok now to recreate a script I made in rust and then in swift and I can submit the commits and the pull requests
08:42:20 <EvanR> does this channel get a cut of your earnings after you get the job
08:45:34 <rbo> HAHA
08:45:36 <rbo> Maybe :)
08:45:44 <rbo> Or a nice lunch? :P
08:45:49 <Psybur> Quick poll: List comprehensions: For or against
08:46:10 <Taneb> For with moderation
08:47:54 <Psybur> I think I prefer: m = map fizzbuzz [0..s3]
08:48:23 <Taneb> Oh, in this case definitely
08:49:35 <Psybur> (or fmap if youve got beef with map :D)
08:50:13 <Taneb> m = do {n <- enumFromTo 0 s3; return (fizzbuzz n)}
08:51:17 <NemesisD> i've been mulling over this thought: i tend to use newtypes and smart constructors to restrict the values more than the underlying type allows, but i'm sort of bothered that once a newtyped value is constructed, i have to pay a line noise cost in unwrapping the newtype every time i use it
08:52:12 <lyxia> NemesisD: you just pay it once if you redefine the operations to operate on the newtype directly
08:52:13 <NemesisD> i think i'm looking for something in the type system that is a witness that a value was constructed correctly but for all intents and purposes, the value's type afterwards is equivalent to the underlying type
08:52:35 <geekosaur> there's evil stuff involving the wired-in Coercible typeclass, but in general I make my editor deal with line noise :)
08:52:39 <MarcelineVQ> when I'm feeling cheeky I use coerce :>
08:52:50 <NemesisD> lyxia: yeah but that's not very practical for things like text where there's a wealth of functions working on the Text directly
08:53:07 <cocreature> MarcelineVQ: and when you’re feeling really cheeky, you use unsafeCoerce? :)
08:53:40 <Psybur> NemesisD, youve got a problem with pattern matching your newtype?
08:53:46 <mnoonan> NemesisD, but how do you know which of those functions preserve <insert whatever invariant your newtype represents>?
08:54:19 <NemesisD> mnoonan: i guess that's true. can't really go down that route without dependent types i guess
08:54:24 <MarcelineVQ> cocreature: When I'm feeling really cheeky I use uncurry
08:55:47 <mnoonan> NemesisD: at least if the operations you care about belong to a typeclass, you can derive
08:56:50 <NemesisD> is this something that DT solves? where you may use some underlying type but where needed you state some predicates about the value (and I presume you can do stuff like give aliases to common sets of predicates, etc)
08:57:21 <MarcelineVQ> cocreature: 3rd level cheek   uncurry (subtract @Int) . coerce . foldMap ((Min &&& Max)) $ [11,4,9,16,1 :: Int]
08:57:27 <EvanR> well at a primitive level that is a sigma type
08:57:45 <ventonegro> NemesisD: You use the original type but also require a proof that the term satisfy some condition
08:57:46 <EvanR> Sigma (x : UnderlyingType) (P x)
08:57:47 <mnoonan> another way of thinking of it is if your smart constructor establishes a property P(x) of the constructed value x, then a function that unwraps, does f, and re-wraps is a proof of P(x) => P(f(x))
08:58:19 <ventonegro> NemesisD: the proof can be implicit so you don't need to pass it if the compiler can find it in the current scope
08:58:32 <mnoonan> (or rather, it is you asserting that P(x) => P(f(x)) is true.. not really a proof :)
08:58:38 <cocreature> MarcelineVQ: in case you don’t already know about it, "ala" can be useful for this https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Wrapped.html#v:ala
08:59:07 <MarcelineVQ> ye there's also a newtype package that provides this without len, I think
08:59:20 <cocreature> yeah but I already depend on lens in most projects ;)
09:00:01 <NemesisD> interesting. that seems really useful. i guess in the absence of DT i should be refining my techniques so that my unwrapping/wrapping happens at the outer edges of the code that depends on the invariant so i'm not overly cluttering the implementation
09:01:00 <EvanR> with DT you could prove the invariants are not violated by the operation
09:01:13 <EvanR> if you are really really smart (tm)
09:02:11 <NemesisD> DT doesn't really seem like a possibility for now though. i cannot rewrite my work code in idris for this functionality and it seems like haskell isn't there yet
09:05:07 <geekosaur> and likely won't be for some ti,me
09:05:46 <geekosaur> haskell doesn't have dependent types. it has some type level features that let you 'simulate' a simplified form of dependent types
09:06:11 <geekosaur> but that simulation is both limited and a bit syntax-heavy at present
09:07:03 <mnoonan> am I a bad PL nerd if I'm skeptical that dependent types will ever have a good power-to-weight ratio?
09:07:11 <geekosaur> (well. the flip side of that one is there aren't that many dependent type systems that aren't fairly syntax-heavy, since you have to describe your proofs as well as your operations)
09:08:11 <geekosaur> mnoonan, dunno but I find yourself in or at least near your camp
09:09:36 <geekosaur> er, I find myself. wtf
09:09:58 <geekosaur> think I switched phrasings midstream. this does not end wll
09:10:10 <mnoonan> heh
09:13:21 * EvanR nerds on
09:13:24 <rightfold> For example if you have data TBool :: Bool -> * where { TTrue :: TBool 'True; TFalse :: TBool 'False }.
09:14:16 <rightfold> Then whenever you have a TBool then you have the equivalent Bool at the type level. Which you can then use with type families and type classes to do computation. 👌🏼
09:15:42 <JordiGH> What's that symbol that is something like x (@#$#@$#@) f = f x ?
09:15:52 <glguy> :t (&)
09:15:53 <lambdabot> a -> (a -> b) -> b
09:47:55 <Athas> Why does 'stack install --profile' have to rebuild my program twice?
09:48:02 <Athas> I could understand once.
09:48:52 * hackage fitspec 0.4.4 - refining property sets for testing Haskell programs  https://hackage.haskell.org/package/fitspec-0.4.4 (rudymatela)
09:50:42 <geekosaur> I suspect 'install' always rebuilds (or something that works out to that) and (possibly only for programs as opposed to libraries) needs to build/install unprofiled for the executable but any libraries must then be built both unprofiled for the exe and profiled for the profiled libs
09:51:07 <geekosaur> the latter might be forcing the former
09:51:33 <geekosaur> since profiled vs. non-profiled is a bit of a messy situation in ghc
09:52:02 <Athas> I already had an unprofiled build, though.
09:57:52 * hackage speculate 0.3.2 - discovery of properties about Haskell functions  https://hackage.haskell.org/package/speculate-0.3.2 (rudymatela)
10:12:38 <yen_> is there a way I can get polymorphism constrained to one type? 
10:13:09 <yen_> I want to write functions that circle around type T, and I want other types to 'extend' T, so only types T and extensions of T work with my functions
10:13:15 <yen_> would those be Typeclasses?
10:13:23 <mniip> yes
10:13:35 <yen_> class Event a where ?
10:13:52 <mniip> could do that, yes
10:13:59 <yen_> so implement Event for any Type? I was initially with this until i tried to create some structures
10:14:20 <mniip> hmm?
10:14:30 <yen_> I wanted to have a structure that contained a list of events, but I realized haing Event a would constrain it to lets say, Event String, and not other implementations
10:14:34 <mniip> well if you could describe your situation in more detail
10:14:47 <mniip> uhh Event is a clas
10:14:48 <mniip> s
10:14:51 <yen_> okay, what would be the haskell way of creating a list of interfaces?
10:14:59 <geekosaur> this sounds more OO than FP, but at least to some extent typeclasses might work
10:15:11 <yen_> so I should rethink this 
10:15:12 <yen_> ?
10:15:13 <mniip> do you need to hold multiple events in a single list?
10:15:23 <geekosaur> I should note that often records make a better OO implementation than typeclasses
10:15:24 <yen_> Not necesarily
10:15:43 <geekosaur> (in Haskell)
10:15:52 <yen_> I just need (Event a, Event a -> () )
10:15:57 <yen_> Or a list of those
10:16:01 <mniip> Event a -> () ?
10:16:13 <yen_> The event, and a function to be executed when Event is called
10:16:14 <mniip> (this isn't ML)
10:17:07 <yen_> well here, maybe you guys can point out flaws in my thinking process
10:17:42 <yen_> I want to create a list of events, and each event is associated with a function. When I call an function, lets say Fire with an event, that event is passed to every function.
10:19:01 <yen_> I currently have an event Typeclass, and a Bus that is a list defined as [ (Event a, Event a -> () ) ] where a is a type constraint
10:19:07 <yen_> But i don't think this is the proper solution
10:25:41 <hoppfull> Hello! Is it possible to have an array of bytes in memory that Haskells GC don't touch? Just curious. Like for example if I wanted to pass a pointer to C++ to deal with that data in an efficient manner.
10:26:26 <hoppfull> I suspect it's not something you'd want to do in most cases. But it would still be cool to know if it's possible.
10:28:47 <koala_man> hoppfull: have you checked out the FFI?
10:29:10 <fakenullie> hoppfull: I guess that you still don't want to hold it forever
10:29:53 <mniip> hoppfull, a pinned bytearray
10:30:05 <mniip> also there's foreign pointers
10:30:10 <hoppfull> mniip: That sounds like it.
10:31:10 <hoppfull> mniip: That's it! Thanks man!
10:32:01 <hoppfull> This is so cool because we can get the best of both worlds. I suspect I'd never need to do this but it's damn good to know that it's possible!
10:39:12 <mniip> hoppfull, I used FFI extensively the other day
10:39:43 <mniip> I hate the idea of generated wrappers, so
10:39:55 <fresheyeball> Anyone know how to tell slack to use the global package database?
10:46:21 <kuekerino> hey i have this piece of code which throws parse error in pattern n + 1 and I have no idea whats wrong with it:
10:46:21 <kuekerino> data SimpleBT = L | N SimpleBT SimpleBT deriving Show
10:46:21 <kuekerino> gen :: Int -> SimpleBT
10:46:21 <kuekerino> gen 0 = L
10:46:21 <kuekerino> gen (n+1) = N (gen n) (gen n)
10:46:22 <kuekerino> It is supposed to be a tree structure and a generate function. 
10:46:51 <kuekerino> can somebody tell me what this error tells me and why it does not work?
10:47:43 <Rembane> kuekerino: There's something about addition and subtraction lhs that makes me hm... suspicious...
10:47:59 <EvanR> yeah
10:48:09 <EvanR> n + k patterns were deleted from haskell years ago
10:48:11 <Rembane> kuekerino: If you don't use it, it will probably work.
10:48:51 <Rembane> kuekerino: Here's some more information: https://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010
10:50:10 <kuekerino> oh wow, thanks. I just grabbed that piece of code from my current lecture, no comment there…
10:50:25 <geekosaur> it was valid in Haskell98, removed in Haskell2010
10:50:48 <geekosaur> for the reasons discussed in that SO
10:51:08 <geekosaur> you can turn on -XNPlusKPatterns to get them back, with all their warts
10:51:56 <geekosaur> or put at the very top of the source file: {-# LANGUAGE NPlusKPatterns #-}
10:52:29 <EvanR> i wonder if there is a slick way to expand n + k patterns so they arent so adhocy
10:52:33 <geekosaur> (the {-# stuff is part of the syntax; it indicates a pragma)
10:52:44 <kuekerino> but is that good style? especially in a lecture for new students? should you focus on the current state of art?
10:52:44 <geekosaur> it's not an expansion problem, it's that they're inherently partial
10:53:12 <geekosaur> and totality checking is a bit of a (halting) problem
10:53:17 <Tuplanolla> There's this thing called observational patterns, EvanR.
10:53:45 <EvanR> totality checking is up to the user for almost everything else in haskell though
10:54:05 <EvanR> Tuplanolla: oh like... copatterns?
10:55:29 <Tuplanolla> That's what it was called.
10:56:02 <Psybur> :t (~>)
10:56:03 <lambdabot> error:
10:56:03 <lambdabot>     • Variable not in scope: ~>
10:56:03 <lambdabot>     • Perhaps you meant one of these:
10:56:11 <Psybur> :t (<~)
10:56:12 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
10:59:45 <ranberry> Rembane: 
10:59:49 <ranberry> Thanks for the read
11:00:39 <Rembane> ranberry: No worries. 
11:04:45 <EvanR> i think i am missing something... a technique to prove to myself that my threads+mvars scheme isnt going to screw up
11:04:48 <geekosaur> kuekerino, if they did current state of the art, they'd be trying to teach you ghc's latest type level hackery and your brain would melt :)
11:05:10 <EvanR> what AOL keywords do i need to look up for that
11:07:05 <Rembane> Melting brains are the best kind of brains.
11:07:13 <EvanR> petri nets?
11:07:53 <kuekerino> geekosaur, thats probably true. What is the status of older haskell versions? Are they still in use? I am thinking of the python situation. By in use I mean still in active development
11:08:52 <geekosaur> ghc no longer supports full haskell98 (or even full haskell2010) because of a number of changes targeting the next standard, notably Monad requiring Applicative and Num no longer implying Eq or Show
11:09:22 * hackage universum 0.9.0 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-0.9.0 (shersh)
11:09:35 <geekosaur> I don;t think there are currently any other actively maintained Haskell implementations (students still hack on uhc but at this point it seems pretty clearly teaching only)
11:10:19 <Athas> kuekerino: approximately nobody is using anything but recent versions of GHC.
11:10:30 <Athas> Except for studying.
11:10:44 <Athas> Erik Meijer taught a course with Hugs recently, I think.
11:10:54 <geekosaur> quite a few courses still use hugs
11:11:02 <EvanR> GHC isn't designed to build older versions of itself, but what if software archeologists wanted to go back anyway?
11:11:09 <geekosaur> but hugs was on life support in 2007 and the plug got pulled years ago
11:12:12 <geekosaur> http://downloads.haskell.org/~ghc/0.29/ ?
11:15:04 <Darwin226> What's the easiest way to start a TCP client and a server and send serialized values between them?
11:15:20 <Darwin226> Basically just a layer above network-simple
11:15:31 <EvanR> the Network module
11:15:51 <kakashiAL> as a functional programming newbie, can you say: "functional programming is all about composition"
11:15:53 <kakashiAL> ?
11:15:54 <EvanR> and a serialization thing... like binary
11:15:57 <kuekerino> Followup to the structure above: Is there a way to create a structure with only 1 Node and 1 Leaf
11:16:14 <Lowl3v3l> kakashiAL: well on a foundational level, ALL programming is about composition ;)
11:16:47 <geekosaur> that sounds like missing the forest for the trees
11:17:03 <geekosaur> (focusing on composition, that is)
11:17:23 <kakashiAL> geekosaur: okay, I see that as a yes :)
11:17:32 <Psybur> kuekerino, data SingleBranch a = Node Leaf a ? D:
11:17:33 <geekosaur> ...
11:18:03 <geekosaur> I usppose you could count that as a yes if you like being lost int he weeds
11:18:09 <Psybur> (I cant see this type youre referencing_
11:18:15 <Darwin226> EvanR: I'd like to avoid functions that require me to specify the number of bytes I want to read from a socket
11:18:28 <geekosaur> if you're inetrested in getting things done, there's quite a lot of higher level you want to look at
11:18:37 <Lowl3v3l> kakashiAL: functional programming is about composition like writing a novel is about paper ;)
11:18:37 <EvanR> so you want a message protocol too
11:18:40 <kuekerino> Psybur: data SimpleBT = L | N SimpleBT SimpleBT deriving Show
11:18:40 <kuekerino> simple tree structure :)
11:19:00 <Darwin226> EvanR: Sure, any kind of protocol
11:19:05 <geekosaur> er
11:19:10 <EvanR> well UDP is message based :)
11:19:26 <kakashiAL> Lowl3v3l: if thats the case (what I dont belive) what would you say is FP all about?
11:19:26 <geekosaur> if you;re expecting some library that magically knows how to handle any protocol in existence, you are not talking about TCP/IP
11:19:42 <Darwin226> I want "send :: Something a => a -> IO ()" and "receive :: Something a => IO a"
11:19:46 <Psybur> data SingleBranch = N L L ?
11:19:47 <kakashiAL> Lowl3v3l: dont tell me pure functions and no mutation, I can do that also in OOP
11:19:56 <EvanR> Darwin226: you might want to look at one of the websockets libraries
11:20:07 <Darwin226> geekosaur: No, I'm saying I'm fine with any protocol :D
11:20:08 <geekosaur> kakashiAL, did it occur to you that perhaps *what* you compose is more important than *that* you compose?
11:20:10 <EvanR> which is technically overkill, but it gives you want you want
11:20:25 <Psybur> Guess that doesnt work :D
11:20:55 <Darwin226> EvanR: Yeah, that seems perfect. Thanks
11:21:36 <Psybur> kakashiAL, are you saying you want to make an "N L" and not an "N L L" ?
11:21:38 <kakashiAL> geekosaur: I dont understand what you mean, but FP for me it having a problem, and splitting it in little (testable) pure functions and later compose them
11:21:45 <Lowl3v3l> kakashiAL: oop and functional programming are not necessarily different things. Functional programming is about decoupling ;) and yeah, pure functions and immutability ARE important tools for it.  The goal in functional programming is decoupling the code in a way that makes them easy to reason about^^
11:22:31 <EvanR> i really appreciate the protocol used in the idris repl server, 6 hex specifying the length the next message, including the newline. the message is a textual S expression
11:23:12 <EvanR> its so dumb it cant be denied
11:23:31 <Psybur> kuekerino, data SimpleUBT = L | UN SimpleUBT | BN SimpleUBT SimpleUBT deriving Show :D?
11:24:16 <Psybur> singleBranch = UN L
11:25:18 <kuekerino> Psybur is that even a thing? right now I am not even sure what I want… Is a binary tree with only 1 root node and only 1 leaf even a thing?
11:28:52 <Psybur> kuekerino, off the top of my head theres this
11:28:53 <Psybur> data Tree a = Empty | Leaf a | Node (Tree a) (Tree a)
11:29:00 <Psybur> singleBranch = Node (Leaf 1) Empty
11:31:17 <Psybur> Thats technically not a single branch though. A single branch from a node doesnt exist in a binary tree. If it did is it a left branch or a right branch? :P
11:40:03 <qmm> when should i prefer to use newtype over a type alias and vice versa?
11:40:19 <Psybur> kuekerino, actually this type is probably more useful" data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a) deriving Show
11:40:37 <kuekerino> that last part makes sense ill just put it as an edge case
11:40:37 <Psybur> But I usually see data Tree a = Empty | Node (Tree a) a (Tree a)
11:41:13 * hackage type-of-html 1.3.0.1 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.3.0.1 (knupfer)
11:41:40 <Psybur> And then a "single branch" would look like Node (Node Empty 1 Empty) 2 Empty
11:42:25 <EvanR> a tree which branches once... [a]
11:42:32 <EvanR> very effective
11:48:23 <fakenullie> what's the point of both leaf and empty
11:48:47 <EvanR> you may want an empty tree
11:49:07 <glguy> Maybe the question is Why have Leaf when you already have    Node Empty val Empty
11:49:08 <fakenullie> that would be just Leaf
11:49:11 <Psybur> fakenullie, the leaf is superfluous yes. Just saves time from writing Node Empty 1 Empty :D ?
11:49:32 <EvanR> Leaf requires you to provide a value
11:49:44 <glguy> Psybur: It doesn't save time when you have 3 cases to handle, though
11:49:51 <glguy> You can always name: left x = Node Empty x Empty 
11:49:51 <fakenullie> well, I meant Leaf without value
11:50:03 <glguy> leaf*
12:01:52 * hackage docker-build-cacher 1.8.1 - Builds a services with docker and caches all of its intermediate stages  https://hackage.haskell.org/package/docker-build-cacher-1.8.1 (lorenzo)
12:07:44 <rightfold> Non-canonical ASTs are annoying
12:07:49 <rightfold> ADTs*
12:08:01 <mnoonan> Darwin226: this may be higher-level than you wanted, but have you looked at Cloud Haskell / distributed-process?
12:08:16 <rightfold> Where multiple representations mean the same thing, you have to handle all cases, and equivalence becomes more difficult
12:27:31 <maerwald> why can GHC not bootstrap itself
12:28:10 <shapr> on a new arch?
12:28:20 <maerwald> on my computer
12:28:37 <maerwald> https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Linux
12:29:40 <maerwald> ./configure just aborts when there is no ghc
12:30:16 <[exa]> maerwald: bootstrapping is hard. :]
12:35:31 <maerwald> not very impressive
12:36:42 <[exa]> maerwald: does cross-compilation somehow fail for you?
12:36:59 <maerwald> why would I cross compile
12:37:39 <maerwald> I just want to build ghc
12:37:51 <[exa]> maerwald: not 'cross' per se, just using a slightly different pre-available version of ghc
12:38:03 <maerwald> why does the build system not take care of that for me?
12:38:07 <maerwald> like any other compiler
12:38:23 <[exa]> maerwald: btw the situation that you can't compile a compiler without a working compiler is pretty common with compilers... :
12:38:29 <[exa]> :]
12:39:07 <[exa]> 'taking care of it' would probably mean installing some prebuilt ghc
12:39:19 <maerwald> not installing
12:39:32 <[exa]> at least 'making available' then
12:39:33 <maerwald> it can do that in a temporary directory or whatever
12:39:54 <maerwald> but there is basically no mechanism whatsoever, which is unimpressive
12:40:15 <[exa]> maerwald: so if I got the exact problem, you want to build ghc without having a systemwide ghc installed?
12:40:25 <maerwald> yes
12:40:38 <[exa]> maerwald: what system are you running on?
12:40:44 <maerwald> linux
12:42:08 <[exa]> I'd go with downloading your distro's package of GHC, manually extracting it to a directory and running GHC from there
12:42:27 <[exa]> maybe the builds are available somewhere though
12:42:35 <Clint> d/win 23
12:43:21 <[exa]> maerwald: similarly, I guess cabal sandbox package can get abused for this purpose
12:43:54 <spikey> Hi, can someone help me with extracting the string from the ReadP parser library? I know it returns ReadP String but I don't know how to show that in the REPL
12:46:15 <spikey> On hoogle it says the string method takes a string and returns a ReadP String which is a parser that takes a string and returns a string
12:46:44 <[exa]> spikey: you want to convert it to ReadS, which is a type synonym of the parsing function
12:47:28 <spikey> but I don't know how to extract that string from ReadP string
12:47:48 <[exa]> it returns a list of parsed-out possibilities
12:49:02 <[exa]> if you have (parser :: ReadP String) and (str :: String) that you want to parse, try: fst$head$readP_to_S parser str
12:50:41 <s4ke> hey lyxia: i noticed you starring my repo :D. cool :)
12:55:27 <[exa]> spikey: an example: readP_to_S (do { a <- many1 get; eof; return a} ) "asd"
12:59:27 <lyxia> s4ke: <3
13:00:22 <s4ke> lyxia: working hard to rework big parts of the paper
13:00:48 <[exa]> research?
13:01:04 * [exa] is curious
13:01:25 <s4ke> [exa]: https://github.com/s4ke/parrows
13:05:23 * hackage quickcheck-classes 0.3.1 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.3.1 (andrewthad)
13:07:51 <[exa]> s4ke: the figures 12, 16, 28 and 29 are generated by some existing software? (/me interested)
13:09:01 <s4ke> [exa]: That's output from EdenTV
13:09:21 <[exa]> oh so
13:10:15 <s4ke> [exa] : basically ThreadScope on steroids
13:10:40 <[exa]> yeah, extremely good. anyway, where are you going to submit it?
13:11:05 <Junior_> For a beginner who has basic understanding of Haskell, my goal is to build a ToDo Web Application with the Yesod framework.  The goal I set is to complete it within a 28 hour time frame.  For those who have experience, would that be a reachable goal?
13:11:14 <s4ke> [exa] planning on submitting to JFP.
13:11:38 <Junior_> I haven't created an app yet, just solved some coding problems.
13:11:48 <s4ke> but i keep adding +1 month to my personal deadline...
13:11:57 <s4ke> but i am refining a lot
13:13:58 <Junior_> s4ke:  You would say I should plan for more than 28 hours for this task?
13:14:54 <s4ke> Junior_: define basic understanding
13:15:30 <[exa]> s4ke: yeah, it looked a bit too long for ICFP :]
13:16:11 <s4ke> [exa]: "a bit" :D
13:16:32 <Junior_> s4ke: I've solved problems in http://exercism.io/languages/haskell/exercises on the "Zebra Puzzle" problem right now.
13:16:33 <s4ke> ICFP has a max of 12 pages?
13:17:42 <[exa]> a bit more now I guess, they are single-column smallpage-ish now
13:17:43 <Junior_> sfke: So completed 70 of the previous problems.
13:18:37 <[exa]> Junior_: if you know some HTML and have some experience with how web clicking tools work, I guess 28 hours is even more that you'd need
13:18:40 <s4ke> Junior_: i guess 28 hours should be possible
13:19:45 <s4ke> also depends on what application structure you want. tbh i dont have much experience with yesod
13:20:06 <s4ke> s/yesod/web development with haskell
13:20:38 <Junior_> exa, s4ke:  Thanks guys, just wanted to determine if my estimate is workable.
13:21:03 <[exa]> Junior_: if you'd be running out of time, ask #haskell. :]
13:23:05 <Junior_> exa:  Sounds good.  I was briefly looking at the different Haskell web frameworks.  Saw that Yesod seemed to have the best number of resources.  Which was what made me think of doing it with that one.
13:24:09 <[exa]> yesod is traditional. If you'd want to style the application as API-separated server and client parts, you want try Servant and Reflex-DOM
13:24:16 <[exa]> *to
13:24:44 <[exa]> or maybe miso, but I've no idea on how that works now
13:25:52 * hackage tidal 0.9.6 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.9.6 (AlexMcLean)
13:27:40 <[exa]> hmuh, is there a haskell parser/formatter for reStructuredText ?
13:28:00 <[exa]> oh, pandoc.
13:28:33 <[exa]> nice how asking the questions on this channel generally helps to the quick solution, even without any answers. :]
13:29:56 <hexagoxel> rubber duck effect scales with the number of idlers in the channel
13:30:38 <geekosaur> aka the number of people you're embarrassing yourself in front of :p (as someone who's done it too many times...)
13:35:58 <[exa]> IRC is brilliant, isn't it.
13:35:59 <[exa]> :]
13:36:28 <Tuplanolla> It stops working once you've established yourself as the village idiot.
13:51:55 <mniip> edwardk, did you take a look :o
13:53:52 * hackage wai-middleware-rollbar 0.7.0.1 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.7.0.1 (joneshf)
13:57:46 <s4ke> my experience with haskell: once you understand how to abuse the type system, you start doing it everywhere
13:57:53 <s4ke> :P
14:01:18 <mniip> yes
14:14:14 <pta2002> http://lpaste.net/3389155399033683968 anyone mind helping me here?
14:14:21 <pta2002> Can't get this to compile and I don't know why
14:14:40 <pta2002> "parse error (possibly incorrect indentation or mismatched brackets)" on 10:7
14:14:56 <Tuplanolla> Indent the guards more, pta2002.
14:15:25 <pta2002> ah there we go
14:15:45 <Tuplanolla> Putting `where` on its own line is also an option.
14:16:00 <Tuplanolla> Using `let` to make a `let go` pun is another option.
14:16:51 <s4ke> i like the go idiom :D
14:16:55 <pta2002> heh
14:24:57 <Ternary> Has anyone ever tried to compile GHCJS using GHCJS to get a Haskell compiler that would work in a browser?
14:28:52 * hackage wai-middleware-rollbar 0.8.0 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.8.0 (joneshf)
14:29:22 <dmwit> Ternary: GHC has nontrivial C components.
14:29:36 <s4ke> yup wanted to say that
14:31:41 <s4ke> Ternary: you could try Hugs
14:32:07 <Ternary> I guess that makes sense. I don't actually need one, I was just curious
14:33:08 <s4ke> i always find myself wanting a Android GHC compiler
14:33:17 <s4ke> so i can fiddle around with stuff on my phone
14:34:49 <s4ke> i've been wondering whether the eta compiler could be made to work on android
14:35:00 <Ternary> I imagine that would be far easier than JS, since C can compile to ARM no problem
14:35:05 <s4ke> but i don't feel like developing an Android App atm
14:35:56 <Ternary> I haven't looked at Eta at all, is it from scratch rather than a fork of GHC?
14:36:10 <s4ke> Ternary: it's GHC on the JVM
14:36:19 <s4ke> with really awesome Java bindings
14:36:34 <s4ke> (i am also a Java developer)
14:36:48 <Ternary> I know that, but I had just assumed they forked GHC and modified it to compile to JVM bytecode
14:37:04 <s4ke> afaik eta is deployed as a jar
14:37:31 <Ternary> Oh neat
14:37:38 <s4ke> Ternary: but let me try
14:37:38 <s4ke> sec
14:37:44 <s4ke> (wanted to install it anyways)
14:40:17 <s4ke> Ternary: oh seems like it's a fork
14:40:18 <s4ke> nvm
14:40:46 <s4ke> makes sense
14:41:39 <s4ke> but imo that's better than what Frege does... 
14:42:18 <UnB_Z> rs
14:45:47 <andirc8000> I want to have to be able to write in ghci 'puts 5+5' to print me 10. So far I have done this 'let puts z = putStrLn $ show $ z' and then 'puts $ 5+5' ... is there a way to have 'puts 5+5' (not $ 5+5)?
14:47:11 <tsani> nope
14:47:56 <tsani> andirc8000: function application binds tighter than the + operator
14:49:39 <tsani> andirc8000: so no matter how you try to redefine (+), it'll always parse as (puts 5) + 5, and puts 5 should simply print 5.
14:49:48 <tsani> andirc8000: Note that your "puts" is already defined in the Prelude as "print".
14:52:23 * hackage pretty-show 1.6.15 - Tools for working with derived `Show` instances and genericinspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.15 (IavorDiatchki)
14:53:18 <termtim> ... trying to update IORef in StateT using lenses. http://lpaste.net/360737  How would you change this so the IORef value is actually set to what getLine returns?
14:54:53 <Ternary> s4ke: That's too bad, but it makes way more sense from their perspective than doing parallel development with it
14:55:26 <s4ke> Ternary: but imo that's fine as long as i can have my Java eco system together with Haskell's eco system
14:55:51 <s4ke> looking forward to porting my parallel haskell to some java backends
14:57:18 <Ternary> That should be awesome. I'd love to have something similar for .NET so I can sneak in some Haskell in my day job
14:57:21 <termtim> or ... is it being set, but in a copy that's discarded?
14:59:59 <edwardk> mniip: not yet, busy replacing my lost luggage, etc
15:00:04 <mniip> ouch
15:00:13 <termtim> num is incremented, as intended, str:: IO (IORef String) is not.
15:01:14 <s4ke> so... i just tried compiling some of my code against eta
15:01:21 <s4ke> it didnt work out well :D
15:01:39 <s4ke> i guess eta does not like parallelism the GHC way
15:05:05 <Ternary> s4ke: Really? I thought they claimed complete parity with GHC 7.10 with the exception of TH
15:05:29 <s4ke> Ternary: welp. my code works on GHC
15:05:34 <s4ke> but let me try another example
15:05:51 <s4ke> (Also: i am on Windows right now, but that should not make a difference)
15:05:54 <termtim> is it abusing lenses to access a field which is an IORef to which I will writeIORef a new value, as in http://lpaste.net/360737?
15:06:06 <Ternary> s4ke: Are you using 8.0 or 8.2 specific features?
15:06:13 <Ternary> If not, that's good to know
15:06:14 <s4ke> Ternary: no
15:06:18 <termtim> data Domain = Domain{_num:: Int, _str:: IO (IORef String)}
15:06:27 <s4ke> but let me check whether a simpler benchmark works
15:07:22 <s4ke> (compile times are a lot slower as well)
15:08:55 <Ternary> That's not too surprising with how new it is. I would expect it to get better with time
15:09:29 <lyxia> termtim: IO (IORef String) in a field sounds very wrong
15:09:47 <lyxia> termtim: you're creating a new IORef every time
15:10:38 <termtim> lyxia - is that right, so the changed one *is* being discarded, right?
15:10:54 <s4ke> Ternary: sure. :)
15:11:01 <s4ke> i find their efforts really promising
15:11:29 <lyxia> termtim: yes
15:11:32 <s4ke> And for my purposes I don't really care about standard backends, if i somehow can access a distributed ExecutorService form java i am golden
15:11:59 <termtim> what is creating the new IORef?
15:12:53 <Ternary> s4ke: I also think it's really cool. It should open the door for a lot of Haskell in places it wouldn't normally be used
15:13:45 <termtim> is it in this line: `r <- liftIO $ fmap (`writeIORef` s) (view str d)` ?
15:14:00 <lyxia> termtim: newIORef "NEW"
15:14:32 <termtim> that is the initial state (or that's what the intention was)
15:14:42 <lyxia> termtim: view str d  is always equal to  newIORef "NEW"
15:14:46 <termtim> and that is then passed to be updated
15:15:02 <lyxia> newIORef "NEW" is not a reference, it's a program that allocates a new reference.
15:15:42 <lyxia> When you write Domain 1 (newIORef "NEW"), you're putting the program in, and every time, you run it again from scratch.
15:16:27 <lyxia> Instead you should run the program once, get the reference, and put it in Domain
15:16:37 <termtim> but should the thing that newly allocated reference is pointing to not then be updated?
15:17:08 <lyxia> No, it's a program that allocates a new reference and puts the string "NEW" in it
15:17:40 <termtim> so how do I do that?
15:18:10 <termtim> ("run the program one" - when everything is a function)
15:18:21 <lyxia> First, a reference of strings has type (IORef String)
15:18:34 <lyxia> So if you want a reference in your Domain, that should be the type of _str
15:19:16 <termtim> I wanted that too, but newIORef returns IO (IORef String)
15:19:46 <lyxia> Well then what needs to be fixed is the call to newIORef, not the definition of Domain
15:20:15 <geekosaur> termtim, this is what the <- syntax in do is for
15:20:22 <geekosaur> or the >>= operator
15:21:07 <lyxia> In ioAction, you want to create a new reference using newIORef, and then execute update with it.
15:21:27 <termtim> isn't that what I did? :)
15:21:27 <lyxia> as geekosaur explained, "and then" is >>=
15:21:58 <lyxia> newIORef "NEW" >>= \r -> execStateT update (Domain 1 r)
15:22:26 <termtim> aha! 
15:22:40 <ph88> does anyone know why haskell web frameworks are much slower than other languages (including php/ruby/python) in this benchmark ??  https://www.techempower.com/benchmarks/#section=data-r14&hw=ph&test=fortune
15:22:56 <Gurkenglas> termtim, why don't you just have _str :: String?
15:24:26 <termtim> Gurkenglas - it's a bit of a long story, but TLDR; it's a learning exercise. The reality is that I was using scalaz to try to write something in scalajs that get bits of state updated by the dom.document  in scalajs.  
15:25:13 <termtim> And I was trying to find a solution without using FRP or any other lib - just shared mutable state the UI can update 
15:25:21 <termtim> hence the IO'ness
15:26:25 <termtim> I thought  I could explore how faster in Haskell and writing the code was indeed quicker - but the "if it compiles it will be fine" mantra didn't work for me this time :)
15:27:03 <termtim> does that sound vaguely reasonable?
15:27:40 <MarcelineVQ> who keeps telling people that mantra <_<
15:29:46 <geekosaur> that mantra's fairly nonsense. you can code nonsense that typechecks in any language.
15:30:13 <geekosaur> well, any turing complete language
15:30:41 <termtim> of course - here it was a dumb error 
15:35:06 <termtim> the rest of the code becomes much neater too, once I've gotten rid of the superflous IO wrapper 
15:35:25 <s4ke> Ternary: so far i have managed to make eta crash more times than it worked
15:37:28 <Ternary> s4ke: That's pretty surprising to me
15:37:32 <s4ke> with as simple as a program as:
15:37:39 <s4ke> main = putStrLn $ show $ zipWith ($) (map (+) [1..]) ([1..1000000]::[Int])
15:37:44 <s4ke> i mean that's not that hard to do
15:38:16 <termtim> Gurkenglas - does that (sharing mutable state updated by UI event) sound like a reasonable excuse for using an IORef?
15:38:49 <s4ke> Ternary: i even eliminated my parallel code from the test, so far this looks... bad
15:39:11 <s4ke> Frege is in better shape than this
15:39:24 <Ternary> Is it the compiler crashing or the compiled binary?
15:39:29 <s4ke> the binary
15:39:35 <s4ke> "binary" jar
15:39:40 <termtim> What I would really like is to have only pure state in Domain, and hide the mutabilityness ina layer over the UI code
15:39:54 <termtim> and hopefully only refer to it in main
15:40:33 <termtim> s/refer/refer and be exposed to
15:41:11 <Gurkenglas> Hmm. https://stackoverflow.com/questions/15439966/when-why-use-an-mvar-over-a-tvar says tvars are safer at the cost of efficiency. If this is not the bottleneck, maybe use those instead, termtim? Are you using a library that you pass an IO action that it executes upon a UI event?
15:41:17 <s4ke> Ternary: Caused by: java.lang.IllegalStateException: getBoundedBuffer#0: The block that corresponds to the address 4521715800490012 is not allocated in memory
15:41:17 <s4ke>         at eta.runtime.io.MemoryManager.getBoundedBuffer(MemoryManager.java:630)
15:41:17 <s4ke>         at eta.base.HSIConv.initBuffer(HSIConv.java:137)
15:41:17 <s4ke>         at eta.base.HSIConv.hs_iconv(HSIConv.java:85)
15:41:17 <s4ke>         ... 31 more
15:41:38 <teurastaja> if i need to separate the records of a structure in lists and have records referring to those lists, how do you do that functionally without pointers? and dont tell me lenses, i dont know what you mean by that. im not efficient in haskell
15:42:15 <s4ke> define "records referring to those lists"
15:42:19 <s4ke> indexes?
15:42:29 <Ternary> s4ke: You could try allocating more memory to Java. I'm no Java expert, but that sounds like it ran out of memory to me
15:42:37 <Gurkenglas> termtim, see for example how gloss does it instead https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss.html#v:play with (Event -> world -> world)
15:42:48 <termtim> Gurkenglas - dom.document (a scalajs lib) is very low level facade over the dom. So you just register events with the document 
15:42:55 <s4ke> Ternary: but that code should not take much memory at all
15:42:56 <teurastaja> mappable records
15:43:00 <teurastaja> by parts
15:43:04 <s4ke> its fully lazy evaluatable
15:43:41 <Gurkenglas> teurastaja, you want [{a :: Int, b :: String}] -> {a :: [Int], b :: [String]}?
15:43:51 <teurastaja> i want to group record fields in chunks and be able to map it
15:43:58 <s4ke> Ternary: GHC does not even care, it just runs 
15:44:01 <termtim> yes, GLOS looks nice - but there must be some magic; you just pass in pure callbacks (like update and draw)
15:44:04 <Gurkenglas> teurastaja, can you give us a type signature for the thing you want,
15:44:05 <s4ke> but nvm let me try more ram
15:44:09 <Gurkenglas> -,+?
15:45:12 <teurastaja> hold on thinking about it
15:45:19 <termtim> and "handle" which is called on events. Somehow they do the "in IO" stuff without bothering the client. 
15:45:20 <Gurkenglas> :t each . _1 %~ (+10) $ [(1, 2), (3, 4), (5, 6)] -- are you sure you don't want lenses? :P
15:45:22 <lambdabot> (Num b2, Num b1) => [(b1, b2)]
15:45:29 <s4ke> Ternary: more ram seemso help
15:45:31 <Gurkenglas> > each . _1 %~ (+10) $ [(1, 2), (3, 4), (5, 6)] -- whoops :t instead of >
15:45:34 <lambdabot>  [(11,2),(13,4),(15,6)]
15:45:35 <s4ke> Ternary: but that's a joke...
15:45:46 <teurastaja> but just WHAT are lenses?!
15:46:06 <Gurkenglas> You can think of a lens as a witness of a record field
15:46:20 <teurastaja> develop
15:46:33 <Ternary> s4ke: Yeah, but GHC does a ton of work to optimize, and it's GC is designed for huge amounts of garbage
15:46:45 <Ternary> s4ke: I'm not saying it's good, but it kinda makes sense
15:46:48 <zenspider> my understanding (from an ungar paper iirc) was first class reflection
15:46:51 <teurastaja> a witness?
15:47:09 <s4ke> Ternary: sounds about right
15:47:20 <Gurkenglas> It tells you how to get, and how to set. It is implemented as turning a small action into a big action, where "action" is defined such that you get exactly enough power to get and set. Therefore, you can compose lenses as functions, to turn actions into even bigger actions.
15:47:33 <s4ke> Ternary: well I guess the eta guys will have to optimize
15:48:08 <Gurkenglas> _1 witnesses that the first element of a pair can be seen as a record field of that pair. "_1 . _1" witnesses the same for the a in ((a, b), c)
15:48:10 <s4ke> i mean it still crashes at some point with zipWith ($) (map (+) [1..]) [1..]
15:48:13 <teurastaja> are lenses some sort of monad class?
15:49:16 <Axman6> teurastaja: they're getters and setters, that's a good mental model to get startred with
15:49:21 <Gurkenglas> No. A "Lens' s a" can turn (a -> a) into (s -> s), and it can turn (a -> x) into (s -> x), where x is often a
15:49:24 <s4ke> Axman6: yes
15:49:45 <Gurkenglas> What a-thing it is currently turning into an s-thing is what I call the action.
15:49:48 <zenspider> s4ke: crashes?
15:50:11 <s4ke> zenspider: talking about eta-lang execution
15:50:14 <Axman6> teurastaja: the _1 lens points to the first element of a tuple (it uses a type class so it works with all tuple sizes)
15:50:30 <zenspider> ah. gotcha. unfamiliar. I'll shut up :P
15:50:44 <s4ke> zenspider: GHC that compiles to JVM code
15:50:46 <s4ke> :)
15:50:56 <Axman6> the each lens (actually a traversal) focuses on each element in the value, so for lists it lets you focus on all elements at once
15:51:13 <Gurkenglas> We're not at traversals yet :c
15:51:43 <teurastaja> yeah but i get the point of traversals
15:52:03 <Gurkenglas> Oh. Well, a lens is just a traversal that focuses on exactly one target.
15:52:39 <Axman6> right, but they have been introduced
15:52:41 <teurastaja> im not sure how to use a traversal but it seems like a map
15:53:03 <teurastaja> i come from Scheme
15:53:09 <Axman6> teurastaja: it's iomportant to think of lenses in terms of what data they accept and what they focus on
15:54:35 <Axman6> > zip [1,2,3] [4,5,6]
15:54:37 <lambdabot>  [(1,4),(2,5),(3,6)]
15:54:47 <Axman6> > zip [1,2,3] [4,5,6] ..^ each
15:54:49 <lambdabot>  error:
15:54:49 <lambdabot>      • Variable not in scope:
15:54:49 <lambdabot>          (..^)
15:55:01 <Axman6> bleh, what's it called?
15:55:42 <Gurkenglas> A traversal can also be seen as turning small actions into big actions, though this time "action" means less possible things. A "Traversal' s a" can turn (a -> a) into (s -> s), and s into [a].
15:55:45 <MarcelineVQ>  ^.. maybe, depending what you wanted
15:56:06 <Axman6> > zip [1,2,3] [4,5,6] ^.. each
15:56:09 <lambdabot>  [(1,4),(2,5),(3,6)]
15:56:15 <Axman6> > zip [1,2,3] [4,5,6] ^.. each . _1
15:56:17 <lambdabot>  [1,2,3]
15:56:57 <Axman6> teurastaja: are you familliar with query languages like XPath, jq or jmespath?
15:57:21 <Gurkenglas> termtim, if you need IO in the callbacks, https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Interface-IO-Game.html#v:playIO provides that
15:57:45 <Ternary> s4ke: Profiling that small bit shows quite a bit of memory usage, but low max residency
15:57:50 <teurastaja> no im hardware oriented. im an standalone AI guy
15:58:16 <Ternary> s4ke: So my guess would be the JVM probably can't handle that the same way GHC's GC can, and ends up with much higher memory usage
15:58:31 <s4ke> Ternary: yeah. but it's interesting to know
15:58:33 <s4ke> :)
15:58:54 <Axman6> ok, well languages likew these let you interrogate data with a succinct language which points at the bits of the structure you want. lenses let you do the same thing for Haskell data, but give you much more power
15:59:05 <teurastaja> haskell is an orgy of functional programming for me but im used to Scheme. i read many tutorials and i should make a program soon but im working on an LSTM neural network
15:59:23 <termtim> Gurkenglas - yes, that is what I was wondering about - how they hide the IO from their client
15:59:33 <teurastaja> so how is traversable usable? you define instances?
15:59:41 <teurastaja> i know C++
15:59:45 <Gurkenglas> Huh? You can turn playIO into play trivially, by adding return to the callbacks the user gives you.
15:59:47 <Ternary> s4ke: For sure. And it's always smart to be aware of the limitations of your target platform
15:59:50 <Gurkenglas> *termtim
16:00:28 <termtim> they have a pure bersion too
16:00:34 <termtim> *version
16:00:38 <Axman6> termtim: you should haver a look at Grenade, a Haskell library for maching learning
16:00:42 <s4ke> Ternary: i guess my "example" was no real world problem tbh
16:00:45 <Gurkenglas> termtim, you mean the play I linked, yes?
16:00:46 <teurastaja> i have
16:01:08 <teurastaja> i just dont understand the dependent type thingy
16:01:15 <termtim> yes - I was looking at that before (when I read about lens, I looked at the pong impl) 
16:01:23 <Gurkenglas> termtim, play is implemented in pretty much terms of playIO.
16:01:35 <teurastaja> and the 'S 'R whatever parameters that are supposed to fit the dimensions
16:02:06 <Gurkenglas> termtim, compare https://hackage.haskell.org/package/gloss-1.11.1.1/docs/src/Graphics-Gloss-Interface-Pure-Game.html#play to https://hackage.haskell.org/package/gloss-1.11.1.1/docs/src/Graphics-Gloss-Interface-IO-Game.html#playIO
16:02:16 <Axman6> there's no depedent types there (haskell doesn't really have them)
16:02:29 <termtim> pong has `draw :: Pong -> Picture` and then draw is passed to play
16:03:28 <termtim> once I get past this stage with the IORef in my state, I will see if I can achieve a similar effect over the dom api
16:03:41 <teurastaja> what does 'S mean in Grenade? how does it work? i dont understand what 'S is supposed to bind to
16:04:11 <termtim> so the client code looks pure, and all the IO is safely wrapped up where it should be
16:04:30 <termtim> client = client of the UI lib
16:04:38 <teurastaja> it refers me to dependent types but in simple terms what does 'S do?
16:04:59 <termtim> any other improvements to http://lpaste.net/360739
16:05:00 <termtim> ?
16:05:34 <Axman6> S appears to be a shape
16:07:25 <Gurkenglas> lpaste's chatbot appears inactive. termtim, http://lpaste.net/360739#a1896229384033927168
16:08:05 <teurastaja> so you apply a shape? where do you define the shape?
16:08:27 <geekosaur> it gets turned off every so often because of spam
16:08:51 <geekosaur> (anyone want to take over lpaste maint and improve its spam handling?)
16:09:20 <Axman6> these are all types - to make a 2D shame type, you'd use S (L m n) which has type S (D2 n m)
16:09:51 <termtim> Gurkenglas - thanks. 
16:09:58 <teurastaja> L?
16:10:51 <Axman6> L appears to be the type of matrices
16:11:03 <Gurkenglas> termtim, thought about the tvar remark?
16:11:15 <Axman6> have you read the readme though? it gives examples oif how you actually use it
16:11:22 <termtim> well, the browser is single-threaded
16:11:28 <teurastaja> what is that notation? i dont get it
16:11:51 <Axman6> these are just types
16:12:06 <teurastaja> witchcraft
16:12:39 <termtim> but, if it was to target different platforms, I suspect it has some merit. But I have not read about tvar yet
16:13:03 <Gurkenglas> termtim, want me to take a look and see if I can make the UI pure faster than my zeal runs out?
16:13:07 <teurastaja> so you use types in plain code?
16:13:16 <Axman6> of course
16:13:26 <teurastaja> wtf?
16:13:30 <teurastaja> really?
16:13:41 <Axman6> the types define the structure of the modelm in Grenage's case
16:14:27 <teurastaja> so for a LSTM type how would 'S be useful?
16:14:39 <Axman6> I don't know what a LSTM is
16:14:44 <Axman6> but types are always useful
16:15:06 <termtim> I have not got enough to show you yet, but hopefully I can take you up on it later this week, if you are here. It will take me a while to get used to scalaz - Haskell seems much easier :) 
16:15:14 <Axman6> they define what structure our code should adhear to, they're the specification for code, and are machine checked. types are extremely important
16:15:18 <teurastaja> a long short-term memory. a weird tensor with communicating layers
16:15:34 <teurastaja> some overlapping dimensions
16:16:00 <Axman6> the Grenade example gives you examples of using LSTM layers
16:16:30 <Axman6> https://hackage.haskell.org/package/grenade#readme
16:16:35 <teurastaja> yes, but how is 'S or 'R or 'thingy used?
16:16:55 <dibblego> termtim: Haskell is much better than Scala. Scalaz does not relate to Haskell as much as is often made out.
16:17:19 <Axman6> teurastaja: the examples show you exactly how they are used
16:17:25 <termtim> Scala is good, but it is not as good at Haskell as haskell is
16:17:41 <dibblego> no, Scala is not good, but I won't rob you of that lesson :)
16:18:09 <termtim> scalaz is great BTW, but Haskell is Haskell 
16:18:24 <Axman6> you define the structure of your network as a type, and this gives enough information to automatically generate a network which has the structure you've defined
16:18:50 <dibblego> termtim: the people who wrote Scalaz, are acutely aware of this. But you'll find contention, an inferiority complex even, among some scala programmers.
16:19:28 <Axman6> termtim: dibblegohas the battle scars to show he knows what he's talking about here
16:19:32 <termtim> the only reason I am here now is that I thought it would be quicker to make this simple prototype in Haskell than in scalaz, and it really was  
16:19:49 <Axman6> (having been one of the authors of scalaz)
16:19:54 <dibblego> termtim: every person who wrote Scalaz, could have told you that before you started :)
16:20:18 <teurastaja> so   '[ R (LSTM 40 80),   R a recurrent network atop?
16:20:30 <termtim> I find dibblego talks good sense, and many people appreciate straight talk 
16:20:42 <dibblego> termtim: we are over at #scalaz
16:21:09 <termtim> OK, you can maybe help me translate http://lpaste.net/360739#a1896229384033927168
16:21:12 <termtim> :)
16:21:58 <dibblego> termtim: It is a violation of my team's Code of Conduct to write Scala. However, I can tell you straight away that the code you have there is extraordinarily difficult to write in Scala, even with Scalaz. You've chosen the harder example.
16:22:19 <termtim> great! What a kop out :)
16:22:25 <Axman6> teurastaja: I beleieve so, but I'm not familliar with neural networks. what you need to know is that to use functions like backPropagate, you give it a network, and something of the shape it wants as input (the dimensions and shape of the input to the network) and the desired output (this is what Last is saying) and it gives you the gradients needed to modify each layer
16:22:38 <Axman6> and applyUpdate applies those gradients
16:22:50 <termtim> It's all the inference issues that slows one down 
16:22:53 <dibblego> termtim: you will need a decent lens library for a start (good luck Scala), and IORef requires an entire library underneath, see Scalaz.
16:23:14 <termtim> https://scastie.scala-lang.org/UQ7IYRZnQ9OYlTb4u3mRhg
16:23:24 <dibblego> termtim: it also becomes limited by performance, and there are certain programs for which the inferencer fails, and you cannot overcome it.
16:23:39 <termtim> but I want to learn how to do it anyway
16:23:53 <dibblego> what would you like me to do to help?
16:24:03 <teurastaja> is R the same type of thing as LSTM?
16:24:15 <termtim> I'll see you in the other room, thanks! 
16:24:19 <teurastaja> are they stacked?
16:24:20 <dibblego> termtim: ok
16:24:44 <Axman6> I think R says that the ... layer is recurrent?
16:25:02 <aberrant> would someone be willing to check my monad challenge code for style and simplicity? I've confirmed it outputs the right values.
16:25:12 <aberrant> http://lpaste.net/360742
16:25:44 <aberrant> oooh, fishythefish! wb
16:25:47 <aberrant> just in time, too :)
16:25:56 <fishythefish> yo
16:26:19 <teurastaja> but LSTM is already recurrent it doesnt make sense unless theyre stacked no?
16:26:33 <Axman6> teurastaja: hmm, yeah I'm not sure what R is supposed to do
16:27:04 <Axman6> aberrant: looks a lot like State Seed to me
16:27:07 <teurastaja> yeah thats the part where i got stuck and went back to scheme
16:27:26 <aberrant> Axman6: http://mightybyte.github.io/monad-challenges/pages/ex1-5.html is the challenge
16:27:54 <Gurkenglas> :t runState . traverse state -- aberrant 
16:27:56 <lambdabot> Traversable t => t (s -> (b, s)) -> s -> (t b, s)
16:29:01 <teurastaja> because LSTM is already defined, R must be some way to compose layers of different neural network types?
16:29:37 <teurastaja> like a way to fit the shapes automatically between network types?
16:29:40 <Axman6> It looks like it's saying it return real values
16:29:42 <Axman6> maybe...
16:29:45 <Axman6> needs better docs
16:29:51 <teurastaja> exactly
16:30:09 <teurastaja> please help...... :/
16:31:52 <Gurkenglas> aberrant, but as you are supposed to implement the state monad Gen here, it's not possible to do much better than you.
16:32:17 <Axman6> teurastaja: I want to know what F is now
16:32:36 <teurastaja> yup
16:32:36 <Axman6> ah, this all comes from Hmatrix!
16:32:43 <teurastaja> really?
16:32:49 <Axman6> maybe...
16:32:56 <teurastaja> cant they specify it?!
16:32:59 <Axman6> R is in Hmatrix
16:33:01 <Axman6> eh?
16:33:11 <teurastaja> dont know. will check
16:33:19 <Axman6> the docs link to the hmatrix docs - you click on the types to go to the docs for that type
16:33:58 <Gurkenglas> How do I currently search the #haskell logs for something I once said?
16:34:02 <Axman6> ok, you've piqued my interest, I'll install grenade and see what I can find out
16:34:13 <teurastaja> so far ive only been implementing everything from the ground up, not using an already written library
16:34:36 <teurastaja> thank you
16:38:53 <Gurkenglas> Ah, I google "site:tunes.org/~nef//logs/haskell/ Gurkenglas" with some more keywords :)
16:50:44 <Gurkenglas> Is there something that constructs drawings like "http://sketchtoy.com/66039859 http://sketchtoy.com/66039843 http://sketchtoy.com/66462297" for me? I'd like one for Cont r.
16:58:22 <mniip> Gurkenglas, hah
16:58:43 <mniip> I can only imagine knot magic
16:59:48 <Gurkenglas> Maybe I could post a reddit thread where people post such drawings, I get it started with those three and request the Cont one.
17:00:06 <mniip> hmm
17:00:15 <mniip> lemme see if I can come up with a tangible explanation
17:00:47 <Gurkenglas> iirc i made myself grok those monads back then by drawing those sketches
17:05:11 <Gurkenglas> @let traverse_gurk :: (Applicative f, Traversable t) => (a -> f ()) -> t a -> f (); traverse_gurk = traverse_
17:05:13 <lambdabot>  Defined.
17:06:00 <Gurkenglas> @let argument :: (a -> b) -> (b -> c) -> (a -> c); argument = flip (.)
17:06:02 <lambdabot>  Defined.
17:07:00 <mniip> hmm
17:07:06 <mniip> internal exponential in a braid category
17:07:21 <Gurkenglas> :t traverse_gurk cont . (fmap . over Lens.argument) ($()) -- (oh, argument already exists.)
17:07:22 <lambdabot> Traversable t => t (r -> r) -> ContT r Identity ()
17:09:24 <Gurkenglas> :t over Lens.argument const . runCont . traverse_gurk cont . (fmap . over Lens.argument) ($()) -- so there's ala Endo foldMap (except I used fmap)
17:09:25 <lambdabot> Traversable t => t (a -> a) -> a -> a
17:09:27 <dgpratt> Occasionally I like to think about the things I might change about Haskell if I had the proverbial magic wand. One little niggling thing is "return". I know there's the Applicative/pure angle to consider, but I got to wondering if e.g. simply wrapping the last expression in a "do" block with return/pure/whatever would've been a reasonable choice. Or should it really the way it is (an explicit function application)?
17:10:20 <Gurkenglas> dgpratt, so you'd want "foo = do x <- foo; x" instead of "foo = do foo"?
17:11:49 <Gurkenglas> dgpratt, I think applicative style is the natural conclusion of your suggestion: "foo = do a <- bar; b <- quu; c <- qux; return (f bar quu qux)" becomes "foo = f <$> bar <*> quu <*> qux"
17:15:49 <Gurkenglas> :t au (iso runCont cont . ?f) traverse_gurk -- how do I lift the iso between (() -> r) and r through Lens.argument?
17:15:50 <lambdabot> (Traversable t, ?f::Control.Lens.Internal.Iso.Exchange a b a (Identity b) -> Control.Lens.Internal.Iso.Exchange a b ((() -> r) -> r) (Identity ((() -> r) -> r))) => t b -> a
17:22:06 <Gurkenglas> The picture should be kinda like https://image.ibb.co/bOfDSw/contsequencepictureincomplete.jpg
17:22:40 <aplainzetakind> Is it not possible to define an empty type class, just to use with empty types and phantom types in type parameter constraints?
17:23:19 <Gurkenglas> aplainzetakind, sure: class Empty e where absurd :: e -> a
17:23:35 <Tuplanolla> @let class Empty where {}
17:23:37 <lambdabot>  Defined.
17:23:50 <Gurkenglas> Tuplanolla, he wants a class that says the type has no values
17:24:07 <Tuplanolla> Oh, I see.
17:24:31 <aplainzetakind> I actually don't want to say that specifically.
17:24:47 <dgpratt> Gurkenglas: Regrettably, I now realize I wasn't thinking about this idea very clearly. I think I had at one point worked out some (probably overly-complex) mechanism in my mind and then forgot the details. I appreciate you attempting to make sense of my question :)
17:26:12 <aplainzetakind> With GADTs, data T a b = T b { constructor :: EmtyClassIWant a => b -> T a b }
17:26:34 <aplainzetakind> This was my goal.
17:26:41 <Gurkenglas> Well, what properties should a have, if not that it has no values?
17:27:46 <aplainzetakind> It will be one of a few empty classes that will be used as markers without needing any values.
17:28:16 <geekosaur> um.
17:28:43 <geekosaur> you can't have a typeclass constraint unless you have a type which is a member of that typeclass
17:28:55 <Gurkenglas> You mean, EmtyClasIWant will be one of a few classes that will be used as markers without needing any operations?
17:29:25 <geekosaur> aplainzetakind, what problem are you trying to solve with this?
17:29:38 <aplainzetakind> Gurkenglas: Yes.
17:30:27 <Gurkenglas> Consider using dependent types and having a come not from * but from some (finite?) type
17:31:34 <aplainzetakind> geekosaur: It's probably not the good way to go about what I'm doing, I'm just experimenting to learn. I'm writing a data type for musical intervals, which have a magnitude and quality, but also can be viewed as ascending, descending or harmonic.
17:32:18 <Gurkenglas> It's not that a isn't supposed to have values, it's that a isn't supposed to be the kind of thing that has a set of values attached to it, yes?
17:32:58 <Gurkenglas> * is afaik the kind of types that have a set of values attached to them.
17:35:06 <aplainzetakind> I think empty types also have kind *
17:35:37 <aplainzetakind> Defining data Dummy; then :k Dummy returns * in ghci.
17:36:36 <mud> The emptyset is a set ;)
17:42:13 <aplainzetakind> Basically I want to use a type class only to use in "for all/some type in class" sort of quantifying signatures, without defining any methods. I can define a dummy method of course but that would be hackish.
17:45:33 <Wizek> Hey guys! Refinement types and dependent types are tickling my imagination at the moment. Would someone be kind enough to talk some sense into me before I take a deep dive into LH or Idris, and become an unproductive programmer for the next 5-10 years who just keeps experimenting?
17:46:07 <Tuplanolla> Good luck on your adventure, Wizek.
17:47:30 <mniip> Gurkenglas, I might have uh
17:47:38 <mniip> made it more complicated than it was before...
17:47:39 <mniip> https://sketchtoy.com/68443576
17:47:46 <Wizek> Tuplanolla: I take it you are a fan of those systems, am I right?
17:47:59 <Tuplanolla> Maybe a little.
17:48:17 <Wizek> Tuplanolla: could you tell me a bit about your esperiences?
17:48:30 <Tuplanolla> It matches your expectations.
17:49:34 <Wizek> Why doesn't hearing that make me physically recoil from the very idea...
17:49:46 <mniip> :t callCC
17:49:48 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
17:49:51 <Tuplanolla> See, the choice was already made for you.
17:51:10 <Gurkenglas> mniip, I'm not convinced the model fits even for specific r
17:51:31 <mniip> fits for general r
17:51:37 <Gurkenglas> um, interpret that line like "might not fit for specific r"
17:51:50 <mniip> hmm
17:51:51 <Wizek> "I need only to understand it now."
17:51:54 <mniip> indeed
17:51:58 <mniip> no wait
17:52:03 <mniip> this is correct
17:52:34 <mniip> for a specific r, Cont r a is a black box that does multiple requests of type a, and upon receiving responses of type r, it produces a final answer of type r
17:54:09 <Gurkenglas> (Written before seeing your last line) Can you make drawings for some specific boxes, then? Like "(cont $ \c -> c x ++ c y ++ c z) :: Cont [r] a"
17:56:09 <Tuplanolla> Destiny summons.
17:56:24 <mniip> Gurkenglas, https://sketchtoy.com/68443581
17:58:41 <Gurkenglas> mniip, how are the buses coming out of the bottoms of the fbox and the xbox combined?
17:59:11 <mniip> the <--> type arrow thing is kind of like a map
17:59:19 <mniip> "each request is to be satisfied in this way"
18:00:48 <Gurkenglas> but you can't map across two collections at the same time without telling me whether it's cartesian or zippy or what
18:02:08 <mniip> it's not two collections
18:02:35 <mniip> ok lemme try again
18:02:55 <mniip> actually the rs should arrive on the left...
18:03:18 <Gurkenglas> mniip, shouldn't one instead pass (a -> r)'s between the boxes?
18:03:31 <mniip> no
18:03:57 <mniip> how do I lambda calculus in the braid category...
18:04:32 <Gurkenglas> (Like I half-attempted in https://image.ibb.co/bOfDSw/contsequencepictureincomplete.jpg)
18:07:17 <crucify_me> hi wouldn't this be bad form to name the accumulator xs here? map_foldr :: (a -> b) -> [a] -> [b] ; map_foldr ff = foldr (\x xs -> ff x : xs) []    
18:07:50 <crucify_me> > map_foldr :: (a -> b) -> [a] -> [b] ; map_foldr ff = foldr (\x xs -> ff x : xs) [] 
18:07:52 <lambdabot>  <hint>:1:37: error: parse error on input ‘;’
18:08:13 <crucify_me> > map_foldr ff = foldr (\x xs -> ff x : xs) [] 
18:08:15 <lambdabot>  <hint>:1:14: error:
18:08:15 <lambdabot>      parse error on input ‘=’
18:08:15 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
18:08:57 <fishythefish> @let map_foldr ff = foldr (\x xs -> ff x : xs) []
18:08:59 <lambdabot>  Defined.
18:09:05 <fishythefish> :t map_foldr
18:09:06 <lambdabot> Foldable t1 => (t2 -> a) -> t1 t2 -> [a]
18:09:09 <crucify_me> ok sorry thanks
18:09:33 <crucify_me> yeah but I was looking at solutions. why would one want to name the acc 'xs'
18:09:51 <Gurkenglas> And shouldn't it be https://sketchtoy.com/68443594 at the end mniip?
18:09:53 <fishythefish> because it's a list of values
18:09:57 <aplainzetakind> Because it's a list?
18:10:21 <fishythefish> there aren't many hard and fast rules about variable naming in haskell, and because variables don't tend to be in scope for very long, terse names are common
18:10:55 <mniip> Gurkenglas, ugh
18:10:59 <mniip> I have a better idea
18:11:04 <crucify_me> isn't acc better there for readability?
18:11:13 <mniip> I'll just embed diagrams as literals and say these are lambdas
18:11:17 <mniip> and have a $ operator
18:11:19 <fishythefish> crucify_me: up to you
18:11:40 <crucify_me> it makes me confused as to what that does. it seems to me "anything but xs"
18:11:40 <fishythefish> "acc" tells me it's an accumulator, but I already knew that since we're using foldr
18:11:52 <fishythefish> "xs" at least clues me in to the type
18:13:08 <fishythefish> either way, that lambda is short enough that it's easy to read regardless of the naming. i'd be pickier if I were parsing a longer expression
18:13:16 <crucify_me> ok thanks, I thought that the updated acc value was different from the remainder of a list
18:14:16 <fishythefish> are you saying "remainder of a list" because of the usual (x : xs) pattern match on a list?
18:14:31 <crucify_me> yes
18:14:46 <crucify_me> so its a fundamental misunderstanding of mine
18:15:10 <fishythefish> well
18:15:31 <fishythefish> on one hand, it's important to realize that just because the name "xs" is chosen doesn't mean we're performing that pattern match I mentioned
18:15:50 <fishythefish> on the other hand, xs *is* being used as the tail of a list here, but we're building it up rather than breaking it down -- ff x : xs
18:16:08 <crucify_me> right, that's why I assumed it was bad form, because of a well-used notation elsewhere
18:16:28 <crucify_me> (re: two posts back)
18:16:51 <fishythefish> would you also only let "x" be used to match the head of a list?
18:17:10 <fishythefish> the general idea is that "x" is just "some value", and "xs" is the plural of "x" - a list of some values
18:18:08 <fishythefish> if you want to restrict yourself to only using those names to pattern match a list, that's up to you, but I'd say it's needlessly restrictive and the snippet you pasted isn't bad form
18:18:42 <crucify_me> one sec
18:19:28 <Axman6> teurastaja: I have come to the conclusion that the readme might be out of date
18:20:57 <aplainzetakind> Regarding pedantry over naming, why ff rather than f? I'm curious.
18:21:18 <aplainzetakind> crucify_me: ^
18:22:22 <crucify_me> its not pendantry aplainzetakind
18:22:40 <aplainzetakind> I didn't mean it to be pejorative. I like such concerns.
18:23:06 <crucify_me> no prob, its just I'm questioning my understanding of the role of the acc in certain cases
18:25:15 <aplainzetakind> So, what does ff signify?
18:25:49 <crucify_me> eyesight preservation. quicker to recognize it
18:25:55 <mniip> Gurkenglas, https://sketchtoy.com/68443605
18:27:14 <Average-user> glguy: How  long does it takes your solution to day 12 part B?
18:29:50 <crucify_me> because using foldr but not for map, the accumulator is a single value being replaced, whereas foldr 's use as a map function is returning a list. so I was confused for a minute
18:30:25 <crucify_me> the accumulator *can be* a single value being ...
18:31:25 <crucify_me> I got used to visualizing acc as an updated value, although I think saying updated is not proper
18:32:16 <crucify_me> correct me, was I told not to consider the acc an updated value, as its used in foldr ?
18:32:53 <crucify_me> like if you do a multiplication and the product increases after each iteration
18:33:45 <crucify_me> and a *single product -- the output -- increases ...
18:35:19 <fishythefish> I think it's fine to visualize acc as an "output thus far" which gets updated as you step over the list
18:35:48 <fishythefish> provided you understand that you're not mutating acc at each step
18:36:34 <crucify_me> right, so it makes sense that a list referred to as xs can be as the "output thus far" thanks
18:36:44 <crucify_me> be *seen as
18:36:55 <Gurkenglas> mniip, yes that's what I meant by "<Gurkenglas> mniip, shouldn't one instead pass (a -> r)'s between the boxes?" :) but in the f <*> k RHS shouldn't the (b -> r) that starts right after the = go through a vertical box border before going up?
18:37:31 <crucify_me> fishythefish: what exactly  ..
18:37:34 <crucify_me> is 
18:37:59 <Gurkenglas> like the (_ -> r) that starts right after the = in pure's definition does
18:38:13 <woodson> Hi guys I have been following a tutorial on how to setup persistent and servant but I am really getting tired of always modifying things because tutorials are hold and there are no tuts for newer versions. So I finally manage to get everything compiling but now I am getting this error.
18:38:14 <woodson> http://lpaste.net/360743
18:38:15 <crucify_me> the difference between mutation and a accumulative value being updated, or are they related/similar
18:38:29 <crucify_me> perhaps we went over this..
18:38:30 <woodson> This is the github of the tutorial https://github.com/parsonsmatt/servant-persistent/blob/0.7/src/Config.hs
18:39:17 <crucify_me> I guess I shouldn't think of it as an accumulative value, but rather..
18:39:23 <fishythefish> crucify_me: imagine variables as labels pointing to the various actual values in memory. mutating would be like keeping acc pointing to the same memory, but modifying the value there. we don't do that; we merely point acc to another place
18:39:26 <crucify_me> a new value
18:39:39 <woodson> But I dont understand why the ReaderT is not returning an IO instead of "Control.Monad.Logger.NoLoggingT (resourcet-1.1.9:Control.Monad.Trans.Resource.Internal.ResourceTIO)"
18:40:01 <Gurkenglas> oh, the whole rhs of f <*> k is supposed to be in a big box i suppose
18:40:03 <fishythefish> typically, the value at that new place is built out of the old one, which is why we call it an accumulator
18:40:28 <crucify_me> right utterly new and its location in memory is likely to be different.
18:41:05 <crucify_me> I guess update is not a horrible word
18:42:32 <fishythefish> it's imperative-sounding, but as long as we're agreeing that we're updating where variables point and not mutating what they point to, I think it's fine in a mental model
18:43:25 <crucify_me> thanks nice distinction fishythefish
18:43:53 <mniip> Gurkenglas, https://sketchtoy.com/68443629
18:43:55 <mniip> new notation
18:44:05 <mniip> resp eval morphism and construction of lambda in CCC
18:46:11 <Gurkenglas> Are we sure the (a -> r) shouldn't come from the right and the rs passed to the left?
18:46:40 <Gurkenglas> then maybe we could draw sequence without reversing the list
18:47:04 <mniip> nope
18:47:09 <mniip> cont reverses the direction of everything
18:47:45 <Gurkenglas> you say that like you couldn't traverse cont over an infinite list
18:50:06 <jle`> i've decided i'm going to use ghci tonight like mniip
18:50:33 <thebnq> woodson: the doMigrations is probably causing it
18:51:11 <mniip> Gurkenglas, https://sketchtoy.com/68443637
18:52:24 <mniip> now onto callCC
18:52:52 <mniip> :t callCC
18:52:53 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
18:54:18 <Gurkenglas> mniip, outermost input line: expected [a] -> r, actually a
18:54:35 <mniip> oh right
18:54:36 <mniip> lemme fix
18:55:18 <Gurkenglas> maybe we should use different colors for different types
18:56:24 <mniip> it's nontrivial
18:56:32 <mniip> I mean we've got functions and functions between functions
18:59:42 <mniip> Gurkenglas, https://sketchtoy.com/68443644
19:07:22 <shapr> mniip: pretty!
19:07:37 <mniip> Gurkenglas, https://sketchtoy.com/68443657
19:10:50 <koz_> What is the division op I should use to produce a Double?
19:11:57 <mniip> jle`, maybe I could stream too :p
19:12:08 <mniip> but there's a slight chance of me betraying haskell after all
19:12:17 <mniip> if the problem is particularly nasty
19:13:25 <mniip> also hmm
19:13:39 <jle`> koz_: without more context .... how about (/) ?
19:13:50 <koz_> jle`: OK, thought I'd check since that stuff always surprises me.
19:13:51 <jle`> mniip: yeah i have been sort of doing a hybrid thing in some situations
19:14:56 <zenspider> you can search hoogle by type signature alone... I've found useful stuff that way
19:14:59 <koz_> jle`: OK, let me rephrase. I need 'Int -> Int -> Double', where the answer is the first arg divided by the second.
19:15:52 <jle`> koz_: ok yeah, that's the mroe context i was talking about :)
19:16:00 <jle`> you can use fromIntegral x / fromIntegral y
19:16:11 <jle`> fromIntegral :: Int -> Double
19:18:10 <Gurkenglas> Maybe the (a -> r) should be delivered via the same line that takes the r to the right, looking like a line that one uses to emit an a. That line, then, should perhaps actually use a different color or texture because when someone knows something about r, it allows them to splice the line and put in multiple or no as and stuff like that
19:18:32 <Gurkenglas> What's the infamous way that mniip uses ghci?
19:18:37 <mniip> uhh
19:18:41 <mniip> is it infamous?
19:19:07 <jle`> oh i just realized how much more fluid i could be by just working interactively
19:19:13 <jle`> instead of setting up a pipeline and re-running/reconfiguring
19:19:19 <mniip> hmm
19:19:37 <jle`> using haskell like matlab
19:19:42 <jle`> with types ~
19:19:57 <jle`> i'm enabling default-extensions for the first time
19:20:05 <koz_> jle`: This is basically what I'm doing right now.
19:20:28 <koz_> Although asking GHCi to solve combinatorial problems as coded lazily by me isn't gonna have the fastest outcomes.
19:21:18 <koz_> Also, it is 4.20pm where I am, lol.
19:22:29 <jle`> okay cool, default-extensions affects stack ghci
19:22:49 <mniip> hmm
19:22:59 <mniip> if I stream in 4K will the text even be legible...
19:23:05 <koz_> LOL GHCi is burning ~10G of RAM.
19:23:07 <koz_> Whoops.
19:23:47 <jle`> i can stream from my hotel room
19:23:48 <jle`> or the lobby here
19:24:01 <koz_> jle`: Are you at a conference or something?
19:24:33 <jle`> mhm
19:25:31 <mniip> I should probably grab some cat5
19:29:06 <Gurkenglas> Why isn't it "callCC :: ((forall b. a -> ContT r m b) -> ContT r m a) -> ContT r m a"?
19:31:17 <mniip> Gurkenglas, isn't that the same
19:31:26 <mniip> callCC :: ((forall b. a -> ContT r m b) -> ContT r m a) -> ContT r m a
19:31:33 <mniip> callCC :: (exists b. ( a -> ContT r m b) -> ContT r m a) -> ContT r m a
19:31:39 <mniip> callCC :: forall b. (( a -> ContT r m b) -> ContT r m a) -> ContT r m a
19:32:06 <Gurkenglas> But without that forall don't you have to choose a single b for the first argument to use?
19:32:21 <Gurkenglas> I mean yes you can choose Void and then they have all the absurd power they need but still
19:34:56 <Gurkenglas> Could one construct (ContT r m s -> (s -> ContT r m ()) -> ContT r m a) -> s -> Cont r m a? (callCC simulates exceptions, this'd simulate state)
19:35:41 <Gurkenglas> " -> s -> ContT r m (a, s)", I suppose
19:37:09 <woodson> thebnq: what is wrong with the doMigrations?
19:39:57 <aberrant> aargh
19:40:14 <aberrant> how can flip be used in a function signature?
19:40:32 <aberrant> "flip lookupMay [] :: a -> Maybe b"
19:40:52 <aberrant> how do I read that?
19:41:32 <Gurkenglas> mniip, in your latest sketch shouldn't the rightmost application be the other way round?
19:46:03 <Gurkenglas> aberrant, flip lookupMay [] = \x -> lookupMay x []
19:46:28 <aberrant> oh, it's not really a function signature then
19:47:00 <Gurkenglas> (or equally: flip lookupMay [] x = lookupMay x [])
19:47:02 <aberrant> it's just showing what the signature IS.
19:47:08 <aberrant> right, ok
19:47:10 <aberrant> thank you.
19:54:19 <mniip> hmm
19:54:21 <Gurkenglas> hmm I think it'd be (Cont (s -> r) s -> (s -> Cont (s -> r) ()) -> Cont (s -> r) a) -> s -> Cont r m (a, s)
19:54:30 <Gurkenglas> -m
19:58:52 <aplainzetakind> Is it posible to define ClassFoo instances for all ClassBar instances? `instance ClassBar a => ClassFoo a where` does not work.
19:59:07 <jle`> what do you mean by "does not work"
19:59:12 <jle`> is that not the behavior you want?
19:59:17 <aplainzetakind> Raising an error.
19:59:28 <jle`> what is the error?
19:59:56 <jle`> does it give any suggestions for fixing it? :)
20:00:15 <aplainzetakind> Illegal instance declaration for 'Show a'
20:00:32 <jle`> that sounds like a completely unrelated thing, heh
20:00:42 <jle`> can you paste the whole error?
20:00:44 <aplainzetakind> Suggests using FlexibleInstances
20:00:49 <jle`> oh, it might be related if you are using Show instead of ClassFoo
20:00:56 <jle`> aplainzetakind: that's a good suggestion
20:02:28 <aplainzetakind> Didn't help, not that I understand what it does exactly. Hold on I'll paste both errors.
20:03:32 <dmwit> uh
20:03:44 <dmwit> why are we suggesting going forward with `instance ClassBar a => ClassFoo a`?
20:04:05 <dmwit> Even if you get it working, it is almost certainly going to lead to problems in a small number of seconds.
20:04:56 <dmwit> The correct answer to "is it possible to define ClassFoo instances for all ClassBar instances?" is "yes, by writing one ClassFoo instance for each ClassBar instance".
20:04:59 <mniip> jle`, do you ever get a problem where your stream is too fast?
20:05:18 <mniip> like
20:05:20 * dmwit struggles hard not to make a joke about splashback
20:05:33 <mniip> when viewed, it's at a faster rate than realtiem
20:06:08 <jle`> mniip: hm, like playing back at a different framerate than you were recording?
20:06:13 <mniip> yes
20:06:25 <mniip> I suspect it's when my machine can't uphold the right framerate
20:06:33 <aplainzetakind> dmwit: I just want to `show` each ClassBar instance in terms of their class methods. Is that so bad?
20:07:36 <jle`> aplainzetakind: what exactly are you writing?
20:07:54 <jle`> instance ClassBar a => Show a where ... ?
20:08:01 <jle`> then yes that is definitely a bad idea
20:08:10 <mniip> hmm
20:08:19 <mniip> let's see if -framerate instead of -r fixes it
20:08:29 <dmwit> aplainzetakind: No, it is not bad. Write one instance of `Show` for each instance of `ClassBar` and you can do that.
20:09:27 <dmwit> You can (and should) implement `showInTermsOfClassBar :: ClassBar a => a -> String` (or better yet, do `showsPrecInTermsOfClassBar` instead); then each instance is short and can be scripted in your editor.
20:09:39 <mniip> yup
20:09:40 <mniip> that helps
20:09:51 <jle`> mniip: nice :)
20:10:01 <jle`> this stuff is really out of my understanding
20:10:43 <mniip> I know how it works in general
20:10:59 <mniip> but as with any sufficiently advanced technology...
20:11:15 <aplainzetakind> dmwit: OK, will do. But what was so bad about the initial approach?
20:11:37 <Gurkenglas> What's the difference between (Cont (m r) a) and (ContT m r a)?
20:11:59 <Axman6> @unmtl Cont (m r) a
20:11:59 <lambdabot> (a -> m r) -> m r
20:12:07 <Axman6> @unmtl ContT m r a
20:12:07 <lambdabot> (a -> r m) -> r m
20:12:17 <Axman6> @unmtl ContT m m a
20:12:17 <lambdabot> (a -> m m) -> m m
20:12:19 <Gurkenglas> ContT r m a, I suppose.
20:12:23 <Axman6> @unmtl ContT r m a
20:12:23 <lambdabot> (a -> m r) -> m r
20:13:21 <Gurkenglas> Here might be to state what callCC is to exceptions http://lpaste.net/2853555750108659712
20:26:41 <mniip> time to reinstall the entirety of cabal
20:29:55 <Gurkenglas> The way ((->) s) stacks onto the r reminds me of Zoomed
20:31:46 <Gurkenglas> Or does it remind me of something else? I'm pretty sure I saw that sort of stacking somewhere before
20:32:00 * mniip wrote a sick import list
20:32:43 <Gurkenglas> What turns State s into Reader s, and Either e into Identity? (or is it Const e instead of Identity?)
20:41:38 <dmwit> mniip: NICE
20:41:52 <mniip> ?
20:42:09 <MarcelineVQ> mniip: grats on the slick list
20:42:16 <dmwit> ?tell aplainzetakind The problem with `instance Foo a => Bar a` is that this instance overlaps with every other instance for `Bar`. You might wish that it only did things when `Foo a` holds, but it doesn't.
20:42:16 <lambdabot> Consider it noted.
20:42:34 <mniip> no yOU DON"T UNDERSTAND
20:42:46 <mniip> 43 imports for swift AoC execution
20:43:20 <dmwit> ?tell aplainzetakind When choosing an instance to use, GHC inspects available instance heads only, not contexts.
20:43:20 <lambdabot> Consider it noted.
20:48:59 <MarcelineVQ> mniip: p. sick still
20:53:07 <monochrom> 43 is a prime number, too. :)
20:58:49 <BattleForTheNet> anyone interested in taking some time to protest for net neutrality? I'm just here to recruit some posters for fb or something to get the word out
20:59:16 <BattleForTheNet> we could really do some badass damage if you're in 
21:00:16 <mniip> I'll just leave this here https://www.twitch.tv/mniip
21:26:12 <Axman6> BattleForTheNet: I would imagine you're getting awfully close to breaching Freenode's spam rules (even if it is a good cause - a better option might be to see in #freenode if Freenode support the cause and see if they are doing things like making network announcements)
21:28:52 <mniip> well damn
21:30:13 <mniip> evidently I was slow because nervous!
21:36:34 <benzrf> spooky o_____o https://pbs.twimg.com/media/DQtO2RxW4AQgfgB.jpg
21:36:54 <MarcelineVQ> !
21:41:22 * hackage ListT 0.1.1.0 - List transformer  https://hackage.haskell.org/package/ListT-0.1.1.0 (MatthewFarkasDyck)
21:43:23 * hackage pandoc 2.0.5 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.0.5 (JohnMacFarlane)
21:43:53 <m1n> mniip: ever heard of text motions or the <{[ F f T t ; , ]}> keys in normal mode O_O
21:44:09 <mniip> only heard of f/t very recently :p
21:44:28 <mniip> I mean I've been using vim for like 5 years and haven't even learned hjkl
21:44:33 <m1n> lllllllllllhhhhhhhhhhhhhllllllllllllllllhhhhhhhhhhhhhh
21:45:08 <mniip> no dude
21:45:10 <mniip> those were arrows
21:45:58 <m1n> I don't know what to say, but I guess ... if your boat floats ... soul is a little raw though :P
21:47:18 <mniip> yeah not like I was limited by text editing there
21:50:36 <byorgey> mniip: how did you end up solving it?
21:50:47 <mniip> it's on the stream!
21:52:57 <mniip> in the end I wrote the second part super conscicely
21:53:03 <mniip> good d ds = all (\(s, h) -> (d + s) `mod` (2 * h - 2) /= 0) ds
21:53:10 <mniip> I suspect the first part could be easily solved that too
21:53:14 <mniip> with that
21:53:25 <byorgey> mniip: yeah, that's what I did for the second part too
21:54:00 <byorgey> and yes, the first part can be done pretty concisely
21:54:19 <byorgey> I just happened to think of the mod solution before I went down the path of simulation
21:54:20 <mniip> I was completely lost so I started simulating movements
21:54:43 <byorgey> my number theory/combinatorics background comes in handy now and then =)
21:55:13 <byorgey> my solution: https://github.com/byorgey/AoC/blob/master/2017/13/13.hs
22:00:01 <iqubic> Let's say I have a list of [a]. Is it possible to write the "reverse" function as a travesal, or a set of traverasals?
22:01:41 <mniip> yes
22:01:47 <mniip> quite unpleasant though
22:02:13 <iqubic> Why do you say that it is unpleasent?
22:03:05 <vaibhavsagar> thanks mniip!
22:03:34 <elvishjerricco> iqubic: https://elvishjerricco.github.io/2017/03/23/applicative-sorting.html Should be possible with something along these lines.
22:03:45 <iqubic> I'm trying a crazy method to solve an advent of code puzzle.
22:04:41 <elvishjerricco> Er wait, do you mean traversal as in the `Traversable` class? Or just structurally? That post is more relevant to the former
22:04:54 <iqubic> I did mean the former.
22:05:15 <iqubic> What is the best way to reverse a list?
22:06:02 <iqubic> Or rather, let's say I have a list of a [a] and I want to reverse the sublist from x to y inclusive.
22:06:16 <iqubic> Is that hard to do?
22:07:32 <iqubic> zero indexed of course
22:07:48 <dsal> That came up in here recently.    reverse.(take x) l <> drop x l
22:09:08 <iqubic> What about the end of the sublist.
22:09:54 <mniip> now to clean up my workspace
22:10:19 <iqubic> Let's say I have the list [0,1,2,3,4,5,6,7,8,9], and I what to reverse the sublist 3 - 7. I should get [0,1,2,7,6,5,4,3,8,9] out
22:11:25 <mniip> ah traversal as in lens traversal
22:11:30 <mniip> or what
22:12:55 <iqubic> mniip, just forget about traversal.
22:13:10 <iqubic> I want a way to reverse a sublist of a given list.
22:13:19 <iqubic> In anyway possible.
22:13:41 <MarcelineVQ> you want an answer to a challenge? :>
22:14:23 <koz_> iqubic: Isn't that just 'split, reverse one part, concat'?
22:14:25 <iqubic> This is part of an advent of code challenge, yes.
22:14:35 <iqubic> koz_ it might be.
22:14:43 <iqubic> I haven't thought about it much.
22:16:13 <iqubic> specifically this part of day 10: http://adventofcode.com/2017/day/10
22:17:02 <iqubic> I mean it is part of day 10 part 1.
22:17:24 <mniip> how come "take sublist from index i to index j" isn't a stock lens
22:17:32 <mniip> do I have to mconcat ixed myself?
22:17:36 <iqubic> I'm not sure.
22:17:45 <iqubic> Is that a possible lens to write?
22:18:07 <iqubic> Actually don't tell me, because this is a major part of day 10.
22:20:15 <iqubic> I think it's just (take j) . (drop i) to get a particular sublist.
22:20:32 <iqubic> Not sure how restore the list after that though.
22:21:57 <koz_> iqubic: This might not be in whatever you're using, but I recall some list package having a function that can break a list into two sublists at an index.
22:22:06 <koz_> So it splits one list into two.
22:22:16 <koz_> ANd then you can just pattern match for the win.
22:22:31 <iqubic> It's advent of code. I can use whatever deps I need.
22:23:06 <koz_> iqubic: I forget exactly what package it's in though...
22:23:16 <MarcelineVQ> koz_: splitAt is in Prelude
22:23:27 <koz_> MarcelineVQ: Thanks - that's the one.
22:24:07 <koz_> As a random question - I know ApplicativeDo will desugar into applicatives where possible. How does GHC know whether this is possible or not?
22:24:12 <Gurkenglas> > partsOf (traversed . Lens.indices (\x -> x >= 3 && x <= 7)) %~ reverse $ [100..110] -- iqubic
22:24:14 <lambdabot>  [100,101,102,107,106,105,104,103,108,109,110]
22:24:46 <iqubic> How the heck does that work?
22:25:03 <koz_> iqubic: The major question about lens anything. :P
22:25:15 <Gurkenglas> traversed . Lens.indices (\x -> x >= 3 && x <= 7) is a traversal of the 3rd-7th target of traversed
22:25:19 <mud> That's cool
22:25:38 <iqubic> How does the reverse function work?
22:25:59 <Gurkenglas> partsOf turns a traversal into a lens targeting a list. (you're supposed to make sure that you don't change its length)
22:26:18 <iqubic> I mean how does %~ reverse work?
22:26:34 <Gurkenglas> > _1 %~ reverse $ ([1..3], 5)
22:26:36 <lambdabot>  ([3,2,1],5)
22:27:19 <iqubic> yes, but how does it work in conjuction with a lens into a sublist?
22:28:40 <Gurkenglas> Any optic lets you turn small actions into big actions. For a lens, those actions are defined to be exactly so powerful that you can turn functions changing, say, the sublist into functions changing the whole list, or functions using the sublist into functions using the whole list.
22:29:10 <Gurkenglas> Do you mean "how can we turn a traversal into a lens over the list of its targets?"
22:30:00 <Junior_> I created a learning plan to create a todo application in Yesod.  My plan is as follows: 1) Install Haskell 2) Install Yesod 3) Hello World in Yesod 4) Connecting web component to database 5) Saving into database 6) Getting info from database
22:30:31 <Junior_> How does this sound?  Anything missing or should be in different order?
22:30:57 <Axman6> > ("Hello", Just "World", ["Foo"]) & partsOf plated %~ (reverse :: [String] -> [String])
22:30:59 <lambdabot>  error:
22:30:59 <lambdabot>      • Variable not in scope:
22:30:59 <lambdabot>          plated
22:31:12 <Axman6> > ("Hello", Just "World", ["Foo"]) & partsOf plate %~ (reverse :: [String] -> [String])
22:31:15 <lambdabot>  error:
22:31:15 <lambdabot>      • Couldn't match type ‘([Char], Maybe [Char], [[Char]])’
22:31:15 <lambdabot>                       with ‘[Char]’
22:32:28 <Gurkenglas> > ("Hello", Just "World", ["Foo"]) & partsOf template %~ (reverse :: String -> String)
22:32:31 <lambdabot>  ("ooFdl",Just "roWol",["leH"])
22:32:37 <Axman6> that's the one
22:33:33 <Axman6> > ("Hello", Just "World", ["Foo"]) & partsOf template %~ (reverse :: [String] -> [String]) 
22:33:35 <lambdabot>  ("Foo",Just "World",["Hello"])
22:34:08 <Axman6> > ("Hello", Just "World", ["Foo"]) & partsOf template . Lens.indices (>0) %~ (reverse :: [String] -> [String]) 
22:34:10 <lambdabot>  error:
22:34:10 <lambdabot>      • Couldn't match type ‘Indexed
22:34:10 <lambdabot>                               Integer [String] (Identity [String])’
22:34:16 <Axman6> :(
22:34:22 <boj> Junior_: that seems reasonable enough
22:34:54 <Junior_> boj: thanks
22:35:42 <Gurkenglas> I wonder why template doesn't give an indexed traversal
22:36:08 <Axman6> Junior_: I might start with getting from database - it's probably a little easier add things directly to the database and query them with yesod
22:36:53 * hackage category 0.2.0.0 - Categorical types and classes  https://hackage.haskell.org/package/category-0.2.0.0 (MatthewFarkasDyck)
22:37:07 <Gurkenglas> > ("Hello", Just "World", ["Foo"]) & partsOf template %~ partsOf (traversed . Lens.indices (>0)) %~ (reverse :: String -> String)
22:37:09 <lambdabot>  ("HooFd",Just "lroWo",["lle"])
22:37:22 <Junior_> Axman6: Thanks for the suggestion.  Any database you'd recommend.  I'm thinking Postgres.
22:38:49 <Axman6> yeah I woulds go with postgres
22:38:53 <Axman6> s/s//
22:40:35 <rightfold> There’s pretty much no reason to go with any other
22:44:52 * hackage drinkery 0 - Boozy streaming library  https://hackage.haskell.org/package/drinkery-0 (FumiakiKinoshita)
23:02:57 <mniip> Gurkenglas, you know the problem with getting a mic is that it's 8AM and people around are sleeping :p
23:16:46 <raduom> Hi. If anyone has time, could you please review this (partial) solution to the 'Write you a Morra' exercise from the book Haskell from first principles? Any feedback is appreciated. You can find the code at: https://github.com/raduom/ubb-map/blob/master/hs-imp/src/Morra.hs
23:18:22 * hackage conduit-extra 1.2.2 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.2.2 (MichaelSnoyman)
23:19:03 <jle`> aw man i couldn't start the advent of code today on time, i guess traveling makes things hard
23:19:15 <jle`> ill try to time myself personally though
23:50:03 <Lokathor> yeah i get off work as the puzzle releases on most weekdays
23:50:08 <Lokathor> so no good
23:51:17 <quchen> raduom: Let me have a look
23:57:52 * hackage sparkle 0.7.1 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.7.1 (MathieuBoespflug)
