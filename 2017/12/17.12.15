00:17:47 <tomlambda> Hey Everyone
00:18:18 <bigos_> hey
00:19:11 <tomlambda> I am trying to get the kind of a Maybe (Maybe a) in my ghci and it wont let me. I feel this highlights a confusion I have around types.
00:20:09 <tomlambda> Maybe (Maybe Bool) is a concrete type. However I am not sure how to get the kind of the abstract data type of a Maybe (Maybe a)
00:20:34 <bigos_> i am a new user and do not feel competent to answer your question, can someone else do it?
00:21:24 <glguy_> What did you try writing into ghci?
00:21:43 <glguy_> It's probably just not happy with the type variable
00:22:45 <glguy_> You can turn on an extension to be able to write :kind forall a. Maybe a
00:23:04 <MarcelineVQ> I think you can use _ to stand in for type variables when asking about kinds as well, unless I've got some weird option turned on     :k Maybe (Maybe _)
00:23:27 <tomlambda> I think it may be because Maybe (Maybe a) needs to be assigned to a type via a data declaration
00:23:39 <glguy_> That doesn't sound right
00:23:42 <frerich> Is anyone here familiar with profiling and optimizing Haskell programs? http://lpaste.net/5843463891387940864 shows my solution to today's Advent of Code challenge, but it runs quite slowly (~25 seconds). When profiling it, it seems that the function for testing divisibility of a number by 4 or 8 is responsible for ~53% of the runtime, do I read that correctly? Is there a faster way to do this? I tried using bit-arithmetic (masking 
00:23:43 <frerich> the lowest two or three bits) but that didn't seem to be faster. :-(
00:24:03 <tomlambda> What doesnt sound right?
00:25:26 <glguy_> What you wrote
00:25:30 <[exa]> frerich: I'd start with making it as strict as possible
00:26:04 <erikd> anyone have any links to a quickstart guide to dtsributed-process ?
00:26:17 <erikd> code samples? anything?
00:26:28 <glguy_> frerich: I suspect the problem is that you stored the lists as top level definitions. Your logic looks about the same as mine. Mine ran in under 3 seconds
00:26:28 <frerich> [exa]: Yeah, right now I'm in the somewhat chaotic "Let's try making things more strict" phase, but that doesn't seem like a terribly systematic approach :-]
00:27:11 <glguy_> Storing the lists like that means they are sticking around in memory the whole time
00:27:59 <tomlambda> glguy: In what way didnt it make sense?
00:29:20 <glguy_> I don't know what it was supposed to mean, but you can query the kind of that type like I said and a new data declaration isn't relevant
00:30:26 <[exa]> frerich: also, can you avoid length.filter id ?
00:30:38 <glguy_> You don't need to
00:30:54 <frerich> [exa]: I had hoped that it all fuses very nicely :-]
00:31:17 <[exa]> in an ideal world I'd expect that to get compiled out, but it wasn't the last time I checked
00:31:34 <glguy_> https://github.com/glguy/advent2017/blob/master/execs/Day15.hs
00:32:06 <glguy_> Storing the lists as top level things can interfere with fusion
00:32:22 <tomlambda> :glguy
00:32:41 <tomlambda> When I do :k Maybe Maybe in ghci it doesnt work
00:32:53 <tomlambda> I get     Expecting one more argument to `Maybe'
00:33:00 <glguy_> That would be a kind error
00:33:32 <glguy_> It's not ok to apply Maybe to Maybe
00:33:46 <glguy_> :k Maybe
00:33:48 <lambdabot> * -> *
00:33:58 <raek> :k Maybe Int
00:33:59 <lambdabot> *
00:34:03 <raek> :k Maybe (Maybe Int)
00:34:04 <lambdabot> *
00:34:13 <tomlambda> So the a in Maybe a must be a concrete type?
00:34:26 <raek> :k Maybe a
00:34:27 <lambdabot> error: Not in scope: type variable ‘a’
00:34:42 <raek> :k forall a. Maybe a
00:34:43 <lambdabot> *
00:34:55 <glguy_> Or quantified with a forall like I said a couple of times or an _ like MarcelineVQ said
00:35:33 <tomlambda> Ok i havent come across for all or _ yet
00:37:48 <tomlambda> So what does forall do?
00:38:01 <raek> I'm not familiar with the reason why "forall" is implied in type signatures but not in the :k ghci command
00:38:20 <glguy_> I'm not, either
00:39:06 <glguy_> Chatting on phone, so responses are terser than normal
00:39:12 <raek> tomlambda: are you familiar with type signatures that have variables (lower case names) in them? like this one: map :: (a -> b) -> [a] -> [b]
00:39:25 <tomlambda> yep
00:39:36 <[exa]> frerich, glguy_: anyway, solution without any unnecessary allocation of lists runs in 0m0.210s (on my phone)
00:39:39 <tomlambda> These variables denote values of a concrete type right?
00:39:54 <raek> that is a shorthand for map :: forall a. forall b. (a -> b) -> [a] -> [b]
00:40:11 <ventonegro> Did I lose another controversy?
00:40:41 <ventonegro> https://www.reddit.com/r/haskell/comments/7jlfi2/a_call_for_respect_by_spj/
00:40:50 <raek> in type signatures, there is an implied forall at the outermost level for all type variablies that are not in scope
00:43:04 <glguy_> [exa]: what're you using to compile code on your phone?
00:44:40 <raek> tomlambda: I don't think I know the right terminology, but perhaps I can try to answer anyway. when values with polymorphic types (types that have at foralls) are used somewhere, a fresh type variable is created at each use site
00:44:53 <MarcelineVQ> ventonegro: don't sweat the small stuff, reddit isn't even real
00:44:55 <[exa]> glguy_: tiny linux VM (it's a big phone)
00:45:17 <raek> that fresh type variable is unified by the type checker with some other type (for example Int) depending on what the types at the use site are
00:46:24 <raek> for example, 'id' has type "forall a. (a -> a)"
00:47:09 <raek> in the expression "id someInt", the type of the "id" parts gets specialized to "x -> x" where x is a new type variable
00:47:37 <raek> let's also assume that someInt has type Int
00:48:15 <raek> the type system mandates that the argument type of the function (x) and the type of the supplied argument (Int) has to be the same
00:48:34 <raek> so x becomes an alias for Int
00:49:01 <raek> so this usage of "id" gets the type "Int -> Int"
00:49:24 <raek> tomlambda: what do you mean by concrete type?
00:50:29 <MarcelineVQ> a type of kind *
00:51:55 <raek> so in "Maybe (Maybe a)" a must have kind *, so it is a concrete type
00:52:17 <raek> but type variable in general do not have to have kind * I think
00:52:21 <glguy_> The meaning varies by user, some people use it to mean no variables,
00:52:56 <raek> ah, like monotype?
00:52:57 <[exa]> glguy_: anyway, regarding the aoc-- is there a way in haskell to downcast integers (like, int64 to int16) ? That operation is free on most platforms, but ghc produces code that explicitly runs AND operations
00:53:01 <glguy_> It doesn't feature in the definition of Haskell
00:53:14 <ventonegro> stackabal FTW
00:53:31 <glguy_> No, please don't bring that into the channel
00:53:48 <MarcelineVQ> ventonegro: people suggesting that don't quite understand what stack is for, in fact most people don't, it's for reproducable builds with known packages versions
00:53:53 <MarcelineVQ> that's all~ :>
00:53:58 <glguy_> Reddit is a good place for that to stay
00:54:25 <ventonegro> Sorry, I'm just being lighthearted... I don't see the point of the raised tensions around this
00:54:32 <ventonegro> It
00:55:17 <frerich> [exa]: That sounds awesome, can you poste the code somewhere?
00:55:18 <ventonegro> It's actually fun to see these two microcommunities fight so hard for something most of the world doesn't know even exists
00:56:11 <frerich> glguy_: For what it's worth, based on your suggestion to tinker with the 'localities' of definitions, I indeed managed to bring the runtime from 25 seconds to ~4.5 -- alas I was not very structured about it, so it's not entirely clear which single change (if any) is responsible for this...
01:01:59 <[exa]> frerich: http://lpaste.net/360807
01:02:37 <[exa]> frerich: compile with -O3
01:03:25 <[exa]> frerich: and the sad truth: this is still 4x faster http://lpaste.net/360808
01:03:45 <frerich> [exa]: Wow, that's dense. I wonder whether I could maybe get a good speedup without as much manual inlining and recursion. :-)
01:04:49 <frerich> [exa]: I'm not really trying to make it run as fast as possible. I'm more interested in low-hanging fruit and basic lessons in optimising Haskell programs which I can also reuse for other programs (like "Use 'rem' instead of 'mod'" or "Use local definitions to help with fusion" or so)
01:05:10 <frerich> [exa]: It's quite sobering to see how fast it can get though 8-)
01:05:36 <[exa]> frerich: yeah, for singlecore speed you usually get to "use anything but dynamic allocation"
01:06:47 <frerich> [exa]: I'm currently experimenting with optimising partOne in http://lpaste.net/5843463891387940864  and noticed that if I just remove the 'drop 1' in the 'run' function, runtime decreases from 1.9s to 1.3s
01:08:00 <[exa]> frerich: anyway, if you'd succeed in getting any near to the C performance please let me know, I'm really, really interested in why haskell can't be pushed into something that simple
01:08:20 <[exa]> anyway, /me has a dirty idea
01:08:47 <frerich> [exa]: I guess if I'd _really_ need that bare metal performance, I'd probably consider just writing it in C and accessing that via FFI :-]
01:16:03 <cocreature> you can probably gain a decent amount of performance by hand-rolling the loop instead of building up lazy lists
01:17:24 <frerich> I just noticed something very surprising: if I _just_ do the 'print partOne' at the end, the program takes 1.9 seconds. If I _just_ do 'print partTwo', it takes 2.3 seconds. If I print both, it takes 28 seconds.
01:19:46 <[exa]> frerich: that's ugly isn't it.
01:22:00 <cocreature> frerich: printing both causes sequenceA and sequenceB to be retained instead of garbage collected
01:23:47 <[exa]> frerich: anyway, the dirty thing I had in mind: http://lpaste.net/5071430205533323264 (around 2.5 times faster than the original C, but clearly shows where aiming for the speed leads)
01:24:30 <frerich> cocreature: And retaining the data structure slows things down? I would have hoped that since both 'partOne' and 'partTwo' use both sequenceA as well as sequenceB, that retaining things helps somehow, but maybe this is just a symptom of me not understanding how things work under the hood...
01:25:05 <frerich> cocreature: I assumed that the first usage of e.g. sequenceA will build a linked list and the second usage will then re-use that list and traverse it again.
01:25:29 <cocreature> retaining might prevent other optimizations that would have result in the list not ever being produced. in addition to that, GC performance will also suffer from retaining the list
01:26:11 <dminuoso> Can someone give me a hint without spoonfeeding how to implement >>= for ListT?
01:26:44 <frerich> Another observation: if I omit the 'drop 1' in the 'run' function, printing just 'partTwo' will go from 2.3 seconds to 1.3 seconds.
01:27:08 <frerich> cocreature: Ah, that's a good point - maybe those lists wouldn't even have been created in the first place...
01:27:36 <cocreature> frerich: take a look at the core if you’re interested in what is going on
01:28:04 <quchen> dminuoso: ListT is difficult to get right
01:28:25 <quchen> dminuoso: The general idea to go from Foo to FooT is replacing all »let x =« with »do x <-« though. :-)
01:29:01 <dminuoso> quchen: Okay, so I might want to implement List first then to make this obvious. Let's see how far I can get. Thanks.
01:29:11 <quchen> Well, ListT is as hard or easy to write as most other basic transformers, but the naive implementation violates the monad laws. That’s why you sometimes read »ListT done right«, which is more complicated.
01:29:33 <dminuoso> quchen: Im actually willing to settle for "violating monad laws" if its some non-obvious subtletly.
01:29:33 <quchen> dminuoso: Yes, you should definitely know the monad before you consider writing its transformer
01:29:54 <dminuoso> quchen: ContT/ReaderT/WriterT was just simple mindless "follow the types" :)
01:30:02 <cocreature> in addition to violating the monad laws it also doesn’t stream the results which makes it not particularly useful in practise
01:30:06 <quchen> dminuoso: It’s probably a good exercise to implement naive ListT and then think about why it’s not a true transformer.
01:30:20 <quchen> cocreature: I think those two are the same
01:30:24 <dminuoso> quchen: Sounds like a good task. Let me get right on that.
01:30:36 <quchen> cocreature: Infinite lists with effects are what breaks the laws and streaming I think
01:31:54 <cocreature> quchen: right my point was that it’s not just some ivory tower problem of violating some laws that don’t matter in practise
01:32:18 <quchen> Right.
01:32:35 <quchen> Ivory towery is that Reader violates the Monad laws as well.
01:32:47 <quchen> …when there are bottoms at least.
01:32:53 <quchen> …which makes it ivory towery ;-)
01:35:01 <Gurkenglas_> Is there a way to unsafely cast Cont r a to forall m. Monad m => ContT r m a, by choosing one of the possible orders in which to do the (a -> m r) calls?
01:46:11 <hashendgame> I'm trying to prototype a typesafe background worker library, and I'm hitting snags around ambiguous types. http://lpaste.net/7432473852422127616 has code that typechecks, but what I'm really looking for is an enqueue function that can range over any MonadWorker instead of one that's constrained to Worker. Everything I've tried has tripped the ambiguity checker: putting a MonadWorker constraint in 
01:46:17 <hashendgame> HasEnqueue's enqueue', composing liftWorker with enqueue' before applying HVect.curry, defining a CPS'd version of enqueue' and passing liftWorker into that, so I'm all out of ideas. I'd appreciate a hand
01:50:18 <frerich> cocreature, glguy_ : Thanks for your comments regarding my performance issue. It turned out that not having global lists but rather defining them locally in partOne and partTwo indeed helped a lot, but _only_ if I also omit the 'drop 1' from the definition of 'run'. Since I didn't like duplicating those sequences very much, I refactored the code a bit and it's now http://lpaste.net/8227073902040317952 -- this runs in 2.8s for me and I 
01:50:19 <frerich> think I didn't loose _too_ much in readability...
01:50:34 <frerich> It's still a shame that I couldn't have more global definitions, I like those because I can test them nicely in ghci (I do this a lot).
01:57:35 <quchen> hashendgame: I think you should give the zipWith argument a better name.
01:57:54 <quchen> frerich: ^ not hashendgame sorry
02:02:20 <nshepperd> there's a strict Maybe type in the 'strict' package, that has a functor instance but no monad instance
02:02:34 <frerich> quchen: I tend to agree, yes. I'm also so-so on using `zipWith` to produce bools and then filtering using 'id' instead of doing a plain zip and then using the condition with 'filter'.
02:02:36 <nshepperd> apparently because it would violate the monad laws in the presence of ⊥
02:02:54 <nshepperd> which I think is silly, because it violates the functor laws too if you consider that to count
02:03:41 <merijn> nshepperd: There's a group of people who only consider instances "lawful" if they properly accommodate strictness and bottom too
02:04:00 <merijn> nshepperd: And then there's the sensible group who believe fast and loose reasoning is morally correct :p
02:04:41 <cocreature> nobody cares about bottom unless somebody else makes a statement that doesn’t take bottom into account. then people are very eager to point that out :)
02:04:55 <merijn> cocreature: Of course, being right is more important than being helpful!
02:05:07 <cocreature> merijn: that’s the spirit!
02:05:13 <merijn> That's why C++ programmers like C++!
02:05:26 <merijn> cocreature: You can almost always find a fault to nitpick when anyone says anything!
02:06:01 <merijn> nshepperd: My advise, smile, nod, and proceed to ignore anyone who cares bottoms when it concerns laws
02:06:14 <nshepperd> hehe
02:07:02 <merijn> nshepperd: Also, for pedants who argue bottom invalidates the law you can be a pedant back and point to the fast and loose reasoning paper and say it's perfectly sound to pretend bottom doesn't exist :p
02:07:47 <cocreature> fight pedantry with more pedantry!
02:07:58 <merijn> cocreature: It's the morally correct way!
02:08:04 <tdammers> the bottom line of that paper is "it's OK to ignore bottom and just assume all our conclusions come with an implicit 'as long as no bottoms appear'" isn't it?
02:08:20 <nshepperd> well, the important thing is that if a law fails because something might or might not be bottom, the only effect you can have on your program is to either 1. make it not crash where it previously crashed or 2. make it crash where it previously didn't
02:08:32 <nshepperd> it won't make your program produce the wrong result
02:08:38 <tdammers> right
02:08:53 <nshepperd> (unless you do unsafe stuff in IO to observe bottoms)
02:08:56 <tdammers> unless you consider crashing a result
02:09:29 <merijn> nshepperd: You can actually say stronger things than that
02:09:48 * hackage hw-kafka-client 2.3.0 - Kafka bindings for Haskell  https://hackage.haskell.org/package/hw-kafka-client-2.3.0 (alexeyraga)
02:11:02 <merijn> nshepperd: The entire point of "fast and loose" is that it shows "any assumption that holds in a total version of the program ALSO hold for the non-total version IF you don't pass bottoms into functions.
02:11:28 <merijn> So 1 is ruled out, actually
02:13:53 <tdammers> right, so it's strong than "as long as no bottoms appear": it's "as long as no bottoms are passed in"
02:14:40 <nshepperd> well, I mean that when you do program transformations that are justified by these laws
02:15:41 <nshepperd> such transformations might change the program behaviour but only from "crashes" to "produces the right answer" or vice versa
02:16:10 <nshepperd> they won't turn a non-crashing answer into a different non-crashing answer
02:16:20 <Gurkenglas_> How does "fast and loose" interact with all the problems with Hask?
02:16:28 <nshepperd> talking about things like fmap (f . g) <-> fmap f . fmap g
02:16:47 <quchen> merijn: actually, »morally« is wrong in this context, it should be »ethically«.
02:16:56 <quchen> }:-)
02:17:29 <quchen> A paper can’t pick my morals, or »the« morals for that matter.
02:17:35 <nshepperd> There's only one problem with Hask, which is that f . g is never ⊥. afaik
02:18:01 <quchen> Yup, since (f . g) = \x -> f (g x), and lambdas are not ⊥ 
02:20:46 <merijn> Gurkenglas_: I'm not sure it interacts with that at all, as fast & loose is about a traditional lambda calculus interpretation of Haskell/programming languages, not a CT one
02:21:12 <frerich> Does anyone know why the type of '1000' is 'Num a => a' but the type of '1e3' is 'Fractional a => a'?
02:21:38 <merijn> frerich: Because that's how the report defined it
02:21:43 <merijn> frerich: You want -XNumDecimals
02:22:07 <frerich> merijn: Oh, hmm. Thanks!
02:22:15 <merijn> frerich: NumDecimals allows float notation with "Num a => a" type for any literals that's an integral
02:31:26 <Gurkenglas_> > seq (undefined . id) () -- why isn't this undefined?
02:31:29 <lambdabot>  ()
02:32:41 <merijn> Why would it be?
02:32:54 <Gurkenglas_> (Oh hey I just spawned a discussion about this that I didn't notice because it didn't directly highlight me. Still, the quesiton remains :P)
02:32:54 <merijn> Why would undefined be evaluated?
02:33:29 <frerich> Gurkenglas: 'seq' would need to apply the function 'undefined . id' to something in order to hit 'undefined', no?
02:33:37 <merijn> Gurkenglas_: seq just evaluated to WHNF and as quchen points out the implementation of . produces a lambda
02:33:44 <frerich> Gurkenglas: The same is true for 'undefined . undefined'.
02:34:22 <Gurkenglas_> > seq (undefined :: Int -> Int) () -- Hm. Maybe the correct question then is why is this undefined?
02:34:24 <lambdabot>  *Exception: Prelude.undefined
02:34:31 <Gurkenglas_> Or even why can you apply seq to functions in the first place?
02:34:41 <merijn> Gurkenglas_: Because it's evaluating undefined to WHNF
02:34:54 <merijn> Gurkenglas_: Because functions can be thunks that produce a function?
02:35:28 <Gurkenglas_> so what I'm proposing is that partial applications never be evaluated?
02:35:28 <merijn> Gurkenglas_: "(+) 1 :: Int -> Int" <- still needs evaluation
02:35:50 <merijn> Gurkenglas_: I don't think that "Partial application is irrelevant
02:36:21 <merijn> Gurkenglas_: "\b -> case b of True -> succ; False -> pred" <- no partial application at all
02:36:51 <merijn> Gurkenglas_: It's just a result of the fact that functions can be the result of any arbitrarily complex expression
02:39:22 <frerich> So it seems 'seq' does not decide on whether it can/should evaluate the first argument based on the type? I.e. I can have 'x = (+1); seq x ()' but 'x = undefined :: (Num a => a -> a); seq x ()' barfs, even though 'x' has the same type in both cases.
02:39:28 <Gurkenglas_> But if you couldn't apply seq to (undefined :: Int -> Int), you could still have functions be such a result, you'd just have to apply the function at least once to actually evaluate the expression
02:40:24 <frerich> seq seems to use the 'real' (dynamic?) type of the value, not the 'static' declared type.
02:40:34 <dminuoso> quchen: Its totally not obvious. For some rudimentary List { runList :: [a] } I have a simple `List m >>= k = List $ m >>= runList . k` which was more than just obvious.
02:41:05 <dminuoso> But given some `newtype ListT m a = ListT { runListT :: m [a] }` I have no idea how to even just type fit: ListT m >>= k
02:41:05 <Gurkenglas_> There basically wouldn't be a bottom in any type of form "a -> b" afaic
02:42:51 <Gurkenglas_> "let x = x in x :: Int -> Int" would be equal to "const undefined"
02:48:37 <Gurkenglas_> Would any problems arise from allowing indexed monads in do notation by default?
02:49:15 <merijn> frerich: I don't see what the type has to do with seq's behaviour?
02:49:58 <merijn> frerich: seq is about evaluating things to WHNF. Whether something is in WHNF or not is completely orthogonal to it's type
02:51:38 <frerich> merijn: Yes, that's what I meant to show (having two values with the same type but 'seq' behaving differently). I thought this would be a good example to show why Gurkenglas_ 'seq (undefined :: Int -> Int) ()' example hits 'undefined' even though it has a function type.
02:51:53 <merijn> frerich: I disagree that seq behaves differently
02:52:07 <merijn> seq behaves the same, you're just passing it fundamentally different values
02:53:06 <merijn> I think saying "seq behaves differently" makes about as much sense as saying "even" behaves differently when comparing "even 1" and "even 2". Even is doing the exact same thing each time
02:53:35 <frerich> merijn: I agree, I should have said that the result is different even though the type of the argument is the same.
02:53:37 <merijn> Of course, in seq's case it's not actually required to do the same thing anyway, since the semantics of seq are mostly operational. It's denotational semantics are very loose
02:56:25 <frerich> merijn: I guess you would also disagree with people saying that division behaves differently depending on whether you divide by zero or something else, then? I think I see where you're coming from, but I think I'll accept this imprecision. ;-)
02:56:54 <geekosaur> frerich, it is doing the seq in both cases, which triggers on the undefined as expected. the seq-d form of a lambda is the lambda itself; of undefined will always be _|_
02:59:15 <geekosaur> the only sense in which the type matters is that a lambda is already in WHNF. but that does not prevent looking at the value, since there is still laziness to resolve (both are initially thunks, one becomes a lambda and the other bottoms)
03:05:51 <Sornaensis> isnt seq magical
03:07:07 <merijn> Sornaensis: Depends on your definition of magic?
03:07:20 <cocreature> it’s magic in the sense that it’s a compiler builtin
03:07:40 <merijn> Sornaensis: seq (in the report) is defined as "seq x y is bottom if either x or y is bottom, else it is 'y'"
03:07:52 <merijn> Sornaensis: GHC's implementation seq has a more detailed (operational) semantics
03:08:45 <merijn> In that "If neither x nor y are bottom, then at the end of evaluating "seq x y" to WHNF, both 'x' and 'y' will be in WHNF" <- note that the order is, indeed, unspecified
03:12:28 <merijn> Sornaensis: So in that sense, it's not magic as it has a perfectly clear operational semantics in GHC. Of course it IS magic in the sense that "it is impossible to implement the same semantics yourself without GHC's help (i.e. using seq)"
03:15:19 <Sornaensis> yes I meant magical in the sense that it is essentially a language construct
03:16:06 <Sornaensis> why is the order unspecified
03:16:07 <geekosaur> it is thagt, yes. and has to be because the only way at Haskell level to force a lambda from thunk to WHNF is to apply it
03:16:24 <geekosaur> (until that was realized, it was iirc a typeclass)
03:17:17 <geekosaur> and I think it's unspecified so that it can be optimized? there is also pseq for an order-specified version
03:17:27 <angerman> Say I have two lenses `a` and `b`. `x ^? a` gives me `Maybe Double`, same for `b`. Now what I'd like is a lens that returns `Maybe (Double, Double)`.
03:17:36 <ufomirc> !list
03:17:40 <geekosaur> @index pseq
03:17:40 <lambdabot> GHC.Conc.Sync, GHC.Conc
03:17:50 <Sornaensis> oh yes I see
03:17:58 <angerman> not sure if `(,) <$> a <*> b`, would work.
03:19:30 <Sornaensis> thinking about haskell programs as graphs can be difficult sometimes
03:31:43 <infinisil> Would it be correct to say that monads pretty much just specify a context?
03:32:05 <opqdonut> you can say that if you want to
03:32:22 <infinisil> IO monad has the context of the world, Random monad has a random generator in its context, State monad has some state as context
03:32:30 <opqdonut> but I don't think that applies to all monads. Reader and State have context
03:32:43 <opqdonut> but what about Cont? a free monad?
03:32:57 <infinisil> Hmm, I haven't looked into Cont
03:33:09 <opqdonut> how about just []?
03:33:23 <infinisil> I mean with lists the context is the list itself
03:33:41 <opqdonut> yeah but it's not really a context for a value, it's a multitude of values
03:33:46 <opqdonut> slightly different I think
03:33:46 <infinisil> hmm yeah
03:33:56 <opqdonut> but of course if you stretch the meaning of context... :)
03:34:01 <infinisil> Heh yes
03:35:19 * hackage log-warper 1.8.1 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.8.1 (shersh)
03:35:45 <geekosaur> which makes it about equal to any other view of a monad :)
03:35:54 <geekosaur> aside from 'it has bind and return'
03:42:07 <infinisil> Okay I might need some help with monad transformers
03:42:21 <infinisil> I think something like this is what I need: type RandLogSTM g a = RandT g (WriterT String STM) a
03:42:39 <infinisil> Which gives me STM, logging and randomness
03:42:55 <infinisil> But it looks ugly, and the more stuff I need the deeper the type
03:43:59 <opqdonut> that's how monad transformer stacks work
03:44:25 <opqdonut> usually people make a type alias or even a newtype for their stack
03:44:45 <cocreature> it seems kind of weird to have a stack on top of STM. usually STM transactions are relatively small, isolated pieces of code
03:45:50 <opqdonut> also, it might be wise to write your functions in terms of the classes, so do something like `mything :: (MonadRandom m, MonadWriter m) => Int -> m a`
03:46:18 <infinisil> cocreature: I'm pretty sure I need all of those in my case
03:46:24 <infinisil> opqdonut: Oh that seems nice
03:46:42 <infinisil> Well obviously I don't need logs, but they're nice
03:47:09 <infinisil> :t lift
03:47:10 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
03:53:54 <Philonous> Is «if x then a else b» preferable to «case x of True -> a; False -> b» ? If so, why?
03:55:04 <[exa]> Philonous: it's more inline-ish
03:55:52 <Philonous> Yes, it's shorter, nice for one-liners. But is there any other reason?
03:56:27 <quchen> No.
03:57:00 <Philonous> I guess I'll disable the hlint warning then 
03:57:02 <Philonous> Thanks
03:57:38 <infinisil> I sometimes prefer the case matching because it looks nicer, is easier to align
03:57:53 <geekosaur> :t bool
03:57:54 <lambdabot> a -> a -> Bool -> a
03:57:57 <geekosaur> another option
03:58:02 <quchen> HLint’s standard warnings are fairly opinionated, don’t worry about changing them.
03:58:25 <geekosaur> and sometimes wrong (heuristics have limits, like not understanding types)
03:59:22 <infinisil> Okay, I'm trying out the typeclass monad thing:
03:59:30 <infinisil> % test = do { x <- getRandom; tell $ show x }
03:59:32 <yahb> infinisil: ; <interactive>:1:18: error: Variable not in scope: getRandom :: m ()
03:59:43 <infinisil> % import Control.Monad.Random
03:59:43 <yahb> infinisil: ; <no location info>: error:; Could not find module `Control.Monad.Random'; Perhaps you meant; Control.Monad.Reader (from mtl-2.2.1); Control.Monad.Catch (from exceptions-0.8.3); Control.Monad.Co (from kan-extensions-5.0.2)
03:59:50 <infinisil> :(
04:00:12 <infinisil> Well whatever, my type is test :: (MonadRandom m, MonadWriter String m) => m ()
04:00:19 <infinisil> Now how do I get such an m?
04:00:20 <quchen> Did you install the package? stack ghci --package random
04:00:28 <quchen> …or whatever package Control.Monad.Random is from
04:00:33 <infinisil> Yeah I got it, it's just the bot that doesn't have it
04:00:48 <infinisil> It's this pkg: http://hackage.haskell.org/package/MonadRandom-0.1.1/docs/Control-Monad-Random.html#t:RandT
04:01:22 <quchen> Your error said you don’t have the package in scope (or as a dependency listed in your project).
04:01:35 <quchen> (And not the bot)
04:01:47 <infinisil> I don't have that error
04:02:02 <quchen> Wait, yahb is a bot?
04:02:05 <infinisil> yes
04:02:08 <quchen> Aaaah. Okay.
04:02:16 <infinisil> % putStrLn "hi!"
04:02:17 <yahb> infinisil: hi!
04:02:22 <infinisil> Haha
04:03:16 <quchen> You get »such an m« by finding out which types have instances for MonadRandom (and MonadWriter). You can do that with :i MonadRandom in GHCi.
04:03:28 <quchen> I’m guessing IO is an example.
04:03:48 <infinisil> Ohh, it might be just a matter of using WriterT and RandT
04:03:59 * hackage safe-money 0.4 - Type-safe and lossless encoding and manipulation of money, fiat currencies,crypto currencies and precious metals.  https://hackage.haskell.org/package/safe-money-0.4 (RenzoCarbonara)
04:04:15 <quchen> What kind of bot is yahb? A lambdabot?
04:04:18 <quchen> Something new?
04:04:22 <infinisil> No idea
04:05:23 <cocreature> quchen: it’s mniip bot. contrary to lambdabot it restricts evaluation using a sandbox instead of forbidding all IO and other unsafe operations
04:05:36 <merijn> quchen: iirc it's a bot that runs completely unconstrained (i.e. also IO) haskell bot running in a sandbox
04:05:46 <quchen> % :t unsafeCoerce
04:05:46 <yahb> quchen: unsafeCoerce :: a -> b
04:05:49 <quchen> Neat.
04:06:04 <quchen> % unsafeCoerce (Nothing :: Maybe Int) :: Bool
04:06:04 <yahb> quchen: False
04:06:12 <quchen> ヽ (＾▽＾) ﾉ 
04:06:28 <quchen> % import GHC.Prim
04:06:28 <yahb> quchen: 
04:06:36 <quchen> % :t tagToEnum#
04:06:37 <yahb> quchen: ; <interactive>:1:1: error:; * tagToEnum# must appear applied to one argument; * In the expression: tagToEnum#
04:07:40 <quchen> % tagToEnum# 1# :: Bool
04:07:40 <yahb> quchen: True
04:07:47 <quchen> Impressive.
04:07:53 <infinisil> % System.Process.readProcess "../bin/uname" ["-a"] ""
04:07:53 <yahb> infinisil: "Linux mniip.com 4.9.0-0.bpo.3-amd64 #1 SMP Debian 4.9.25-1~bpo8+1 (2017-05-19) x86_64 GNU/Linux\n"
04:08:05 <quchen> % tagToEnum# 2# :: Bool
04:08:05 <yahb> quchen: <interactive>: internal error: interpretBCO: hit a CASEFAIL; (GHC version 8.3.20170519 for x86_64_unknown_linux); Please report this as a GHC bug: http://www.haskell.org/ghc/reportabug; [Aborted]
04:08:56 <quchen> Interesting, that usually produces a segfault on the next major GC in local GHCi sessions ;-)
04:08:57 <Broli> Hello
04:08:59 <Broli> https://pastebin.com/fZ08uXvL
04:09:06 <Broli> please help
04:09:22 <mniip> quchen, segfault it at will
04:09:28 <mniip> it's safe
04:09:44 <quchen> mniip: Stop ruining the fun :-(
04:10:10 <quchen> % unsafeCoerce (id :: a -> a) :: (Int, Char)
04:10:12 <yahb> quchen: ([Segmentation fault]
04:10:15 <quchen> % unsafeCoerce (id :: a -> a) :: (Int, Char)
04:10:17 <yahb> quchen: ([Segmentation fault]
04:10:20 <quchen> Cool.
04:10:28 <quchen> No downtime even!
04:10:49 <quchen> On the serious side, it’s very useful to be able to ask for types involving unsafeCoerce etc.
04:11:09 <quchen> Lambdabot should also include a function of unsafeCoerce’s type (defined as an error or whatever) for examples.
04:11:22 <mniip> undefined
04:11:29 <Broli> mniip: i got PosNat from yesterday :)
04:11:43 <Broli> i mean FoldPosNat
04:12:11 <Broli> i mean from today at 4
04:12:39 <quchen> mniip: How is it sandboxed?
04:13:00 <quchen> Arbitrary code execution is famously hard to sandbox after all
04:13:22 <quchen> chrooted into a vm dockered into a chrooted userspace nix vm dockerbox?
04:13:39 <quchen> (The algebra of security, just pile more barriers ontop of it to converge to total security)
04:14:48 <Philonous> ssh makes everything more secure. Just create an ssh fixed point and you're golden. 
04:15:03 <infinisil> Okay that is pretty fancy, the monad typeclass thing
04:15:04 <quchen> ?let ssh = error
04:15:06 <lambdabot>  Defined.
04:15:07 <quchen> > fix ssh
04:15:09 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
04:17:53 <infinisil> I find it amazing that with test :: (MonadRandom m, MonadWriter String m) => m (). I can just do evalRand . runWriterT $ test :: RandomGen g => g -> ((), String)
04:18:00 <infinisil> Like magic
04:18:24 <infinisil> And no need to do awkward liftFoo's in the test function
04:18:38 <quchen> Type inference!
04:18:44 <infinisil> Indeed!
04:19:15 <sun777> man one of those days i will understand that line you just sent
04:19:33 <quchen> sun777: It’s not really that complicated, mostly just long and intimidating.
04:19:50 <quchen> sun777: In other words, »one of those days« might be closer than you think. :-)
04:19:53 <sun777> rn im all tangled up in IO sans exploring what monads are
04:19:57 <mniip> quchen, bunch of
04:19:58 <mniip> ptrace
04:20:00 <mniip> not even a chroot
04:20:09 <sun777> quchen: sure hope so im basically lurking here and reading a couple hask books
04:20:26 <quchen> sun777: Lurking here is an excellent thing to do.
04:20:32 <quchen> I learned half of what I know in here.
04:20:47 <quchen> I call it IRC osmosis.
04:20:59 <infinisil> I did need to use -XFlexibleContexts though to be able to declare test :: (..., MonadWriter String m) => ... though
04:21:11 <sun777> yeah, irc osmosis is so real actually
04:21:12 <infinisil> Which I found odd to not be supported by default
04:21:41 <Philonous> There should be a -XKitchenSink 
04:21:49 <quchen> There used to be.
04:21:53 <quchen> -fglasgow-exts
04:22:16 <infinisil> Umm, what's that supposed to do?
04:22:18 <Philonous> Didn't that used to enable IncoherentInstances and other undesirables as well? 
04:22:27 <quchen> infinisil: It enabled basically all extensions.
04:22:31 <infinisil> Ohh
04:22:33 <infinisil> Nasty
04:22:46 <quchen> Philonous: Yes, kitchen sinks have lots of dangerous and strange chemicals too :-D
04:23:59 <quchen> sun777: You’re on the right track to understanding monads if you just use IO, by the way. After using a couple of other common examples you’ll see the similarities.
04:24:13 <quchen> sun777: Common examples as in not IO but e.g. State and Reader.
04:24:40 <sun777> i think ill stick some more to IO before tackling monads in general then.
04:24:45 <quchen> And Monad then captures one way of chaining operations of those types in a certain way that’s fairly valuable. But realizing this takes some time, and probably can’t be taught in tutorials.
04:24:57 <Philonous> <snark>The only monad you need to understand is ContT</snark>
04:25:19 <quchen> Yeah, because when you understand ContT you have to be so smart that nothing else can shock you.
04:25:19 <Philonous> Cont, even
04:26:07 <Philonous> Also, you can encode all algebraic effects using Cont
04:26:25 <quchen> :t callCC (\c -> let x = c x in pure x) -- goto
04:26:26 <lambdabot> MonadCont m => m (m b)
04:27:23 <quchen> sun777: IO, State, Reader, Writer – try those out.
04:27:49 <infinisil> I haven't looked into Cont, will do eventually
04:27:51 <sun777> will do; have heard of State but not of Reader/Writer.
04:28:00 <quchen> Why am I even typing this when I have an FBUT section about it haha https://github.com/quchen/articles/blob/master/fbut.md#i-dont-understand-monads
04:28:01 <Philonous> I don't think you can have labels that come after the goto, though
04:28:16 <Philonous> So it's more like setjmp/longjmp than goto
04:28:42 <quchen> ..?
04:29:02 <quchen> do { x <- label; if p then x else liftIO (print 123) >> x }
04:29:12 <merijn> quchen: The best thing about fbut is all my opinions in there that I didn't even have to write myself :p
04:29:21 <quchen> merijn: Patches welcome :-)
04:29:39 <quchen> merijn: RFC, https://github.com/quchen/articles/blob/master/fbut.md#undefined-is-not-haskells-null
04:30:14 <quchen> merijn: Easteregg in the source as an HTML comment ;-)
04:30:34 <Philonous> quchen, How would you encode «if foo goto end; <do something>; end: cleanup" ?
04:31:20 <quchen> Philonous: Oh, I see. Ummmmmmmm recursive do?
04:31:33 <Philonous> Does that work?
04:32:07 <quchen> Maybe. Who knows, it’s Cont.
04:32:17 <quchen> Anything is possible. Especially ⊥.
04:32:22 <merijn> quchen: I strongly advocate getting rid off "One is during prototyping, where it can serve as a »I’ll fill this out later« value, much like a TODO comment that crashes the program,"
04:32:25 <Philonous> Hah, I'll have to play around with that. Nice puzzle for later.
04:32:36 <merijn> undefined during prototyping has to die now that we have typed-holes
04:32:48 <quchen> merijn: mmmh yeah I use it as a silent hole
04:33:08 <quchen> Having 10 holes makes the compilation spammy :-/
04:33:08 <merijn> There used to be exactly one reason to prefer undefined over typed holes in the past, and I patched that 2 GHC releases ago
04:33:15 <merijn> quchen: You can silence hole warnings
04:33:25 <merijn> quchen: I know, because I implemented it :p
04:33:28 <quchen> I want to silencse all hole warnings except the ones I’m developing
04:33:32 <merijn> quchen: For exactly that reason
04:33:49 <mniip> quchen, basically I overcame the limitation of ptrace on x86_64
04:33:50 <mniip> that let me write a secure ptrace sandbox
04:34:04 <quchen> mniip: I know nothing about ptrace :-/
04:34:05 <merijn> quchen: I mostly just keep hole warnings, but silence them in my editor (since I rely on error highligthing in said editor)
04:34:35 <merijn> I know enough about ptrace that I'm going to demand an elaborate blogpost describing how this works!
04:35:14 <merijn> quchen: Of course with new-build it's even better since I can selectively toggle flags like silencing hole warnings per project
04:35:32 <mniip> quchen, there's a serious issue regarding syscall entry
04:35:46 <mniip> that lets a malicious program fool a debugger or strace or a similar tool
04:36:05 <merijn> mniip: ^^^ see my previous remark
04:36:13 <mniip> sorry I missed it
04:36:19 <mniip> had to move between buildings
04:36:28 <quchen> merijn: Please repeat it so the blogpost will be written
04:36:38 <merijn> mniip: "<merijn> I know enough about ptrace that I'm going to demand an elaborate blogpost describing how this works!"
04:36:40 <quchen> Assuming your comment was the one about writing the blogpost. If not, then repeat that one anyway.
04:36:52 <mniip> uhh
04:37:03 <mniip> I never comment code
04:37:10 <mniip> you'll have to read the code instead :p
04:37:10 <quchen> :-C
04:37:11 <merijn> it being your sandbox, not ptrace :p
04:37:26 <quchen> Repeat after me, there is no self-documenting code
04:37:58 <merijn> Given that my entire phd code has 0 non fixme/todo comments I'm not going to comment :p
04:38:08 <mniip> basically, on x86_64 all 64-bit syscall entires place rflags in r11 temporarily
04:38:14 <mniip> and all 32-bit syscall entires zero r11
04:38:23 <mniip> no
04:38:32 <mniip> 32-bit syscall entries from 64-bit code
04:38:37 <mniip> so yeah
04:38:40 <mniip> rflags can never be zero
04:38:50 * frerich merijn: One use case I found for using 'undefined' instead of type holes; the former allows using hdevtools (e.g. as part of your Vim integration).
04:38:58 <mniip> so if you have something with a 64-bit register set, but a zero r11, know that it's actually a 32-bit syscall
04:39:05 <frerich> err oops, Ctrl+Return in this IRC editor does not work like I expected it to...
04:39:08 <mniip> that is using the 32-bit table despite %cs being 64-bit and so on
04:39:12 <merijn> frerich: I've used hdevtools with typed holes for ages
04:39:18 <merijn> frerich: Why would it not work?
04:39:33 <frerich> merijn: How can you check the type of an expression if the program does not even compile?
04:39:44 <merijn> frerich: Ah! But that's the oversight I fixed :)
04:40:01 <merijn> frerich: -fdefer-typed-holes turns them into runtime errors :)
04:40:21 <frerich> merijn: Ah! Now I'll only need to make hdevtools use that...
04:40:45 <merijn> frerich: So just configure hdvetools with "-fdefer-typed-holes" and optionally disable the warnings for typed holes since those are only distracting in your editor
04:41:06 <merijn> I had that setup, but I've dropped hdevtools since then, so no longer have that config
04:41:20 <merijn> frerich: While your at it, configure -O0 -fno-code for faster checking
04:42:53 <merijn> frerich: Although hdevtools is pretty much dead, atm, so you might wanna prepare for switching to something new
04:43:20 * hackage markdown-unlit 0.4.1 - Literate Haskell support for Markdown  https://hackage.haskell.org/package/markdown-unlit-0.4.1 (SimonHengel)
04:43:31 <infinisil> Umm, why do I now get `Expecting one fewer argument to ‘MonadWriter String’, Expected kind ‘(* -> *) -> Constraint’ but ‘MonadWriter String’ has kind ‘Constraint’. In the type signature: makePlayer :: (MonadSTM m, MonadRandom m, MonadWriter String m) =>
04:43:50 <frerich> merijn: I think I tried ghc-mod a couple of months ago, but back then there were issues with using it in combination with stack (IIRC it wouldn't see packages installed in a stack sandbox or something like that). Is there something else?
04:44:53 <quchen> :k MonadWriter
04:44:54 <lambdabot> * -> (* -> *) -> Constraint
04:44:55 <merijn> frerich: I've tried making it hdevtools play nicer with newer versions of hdevtools, but the implementation is overly complex (imo) for what it's doing and way to ad hoc (tied to very specific cabal versions and hard to port to newer versions)
04:45:06 <quchen> :k MonadWriter String
04:45:07 <lambdabot> (* -> *) -> Constraint
04:45:21 <quchen> infinisil: Sounds strange.
04:45:23 <merijn> frerich: I use ghc-mod now, because that's the only thing I've managed to (painfully and manually) make play nice with new-build
04:45:53 <merijn> frerich: ghcid and intero are supposedly a lot more robust, but don't have existing vim plugins, afaict
04:46:02 <infinisil> quchen: Indeed.. it worked with my simple test function in a ghci, but now that I'm wanting to use it in my project it doesn't work
04:47:33 <infinisil> Could it be different MonadWriter's from different packages confusing themselves?
04:47:53 <quchen> If you have two different MonadWriter you get an error.
04:48:00 <quchen> You might have imported the wrong one, but that also sounds strange.
04:48:06 <infinisil> relevant packages I have are transformers and monads-tf
04:48:07 <quchen> Try :i MonadWriter.
04:48:13 <quchen> Aaaaaa! Okay.
04:48:17 <quchen> Yeah that’s it. :-)
04:48:25 <quchen> …I think.
04:48:29 <merijn> monads-tf...that doesn't sound right...
04:48:39 <merijn> I don't think that's been used for years
04:48:44 <quchen> mtl and monads-tf don’t play along very well
04:48:48 <infinisil> I shall remove monads-tf from my packages
04:48:57 <infinisil> I'm not using mtl, I think
04:49:13 <merijn> everyone else is :p
04:49:15 <quchen> monads-tf is somewhat controversial I think, but I only heard that form others.
04:49:59 <infinisil> Hmm alright, I'll use mtl
04:50:16 <infinisil> Oh this is also very relevant: https://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice#2769664
04:50:48 <merijn> infinisil: Note, this question is from 2010
04:50:52 <infinisil> Oh
04:51:17 <merijn> infinisil: mtl right now is basically what used to be monads-fd
04:51:38 <merijn> The community at large having decided that the functional dependencies arppoach was the "best" one, for some value of best
04:51:46 <infinisil> Alright, I shall use mtl
04:53:01 <merijn> There was an idea that monads-tf was a "nicer" approach, in the end the others didn't really take off
04:53:35 <merijn> AH, see also the last answer (added early this year)
04:53:40 <merijn> "The factoring out Edward Kmett mentions in his answer was completed in late 2010. Its end result was monads-fd, built upon transformers, becoming version 2 of mtl. As a consequence of the ubiquitousness of mtl, monads-tf never really caught on. As of early 2017, mtl and transformers are the only monad transformer libraries that see widespread usage."
04:54:05 <merijn> mtl just being a convenience wrapper around transformers
04:54:34 <infinisil> Alright my error is gone, have mtl instead of transformers + monads-tf in my packages now
04:55:37 <quchen> FWIW you could have fixed the error with monads-tf just as well
04:55:58 <quchen> It was just a good time to suggest switching to MTL while you’re learning stuff
04:58:54 <infinisil> Yeah thanks!
04:59:22 <infinisil> Well I actually don't know the difference between all these, I'm happy as long as it work :)
05:01:05 <ocharles> brrrrrrain teaser. Does data RT a = RT a [RT a]  have a MonadFix instance?
05:01:30 * quchen doesn’t understand MonadFix :-(
05:01:41 <ocharles> nor me
05:01:42 <ocharles> magic
05:01:46 <merijn> quchen: What's not to understand?
05:02:05 <quchen> merijn: Everything.
05:02:10 <quchen> merijn: I don’t get the semantics.
05:02:13 <quchen> I do understand fix.
05:02:18 <quchen> I do not understand mfix.
05:02:39 <quchen> fix I can analyze for whether it contains infinite loops.
05:02:43 <quchen> With mfix I’m never sure.
05:02:54 <ocharles> Node <$> mfix (runTree . f . nodeValue) <*> fmap nodeChildren (runTree (mfix f))  -- is my attempt
05:02:59 <merijn> The monadic effect in mfix is only run once
05:03:05 * hackage hOff-parser 0.1.0.0, hOff-display 0.1.0.0 (qinka): https://qbin.io/p29pmcs
05:03:42 <ocharles> oh actually, my RT thing is not quite what I'm doing
05:03:53 <ocharles> http://hackage.haskell.org/package/hedgehog-0.5.1/docs/Hedgehog-Internal-Tree.html#t:Tree this is what I want to make MonadFix
05:04:06 <ocharles> It's a RoseTree where the leaves are held under some monadic context
05:04:36 <ocharles> my attempt is above, but that doesn't terminate
05:14:35 <Sornaensis> transformers, monads in disguise
05:15:11 * ocharles StackOverflow's it
05:19:54 * hackage debug 0.0 - Simple trace-based debugger  https://hackage.haskell.org/package/debug-0.0 (NeilMitchell)
05:22:18 <Psybur> Is there an Int version of ** ?
05:22:25 <cocreature> :t (^)
05:22:26 <lambdabot> (Num a, Integral b) => a -> b -> a
05:22:31 <Psybur> thanks
05:22:39 <cocreature> note that it fails on negative exponents
05:48:33 <tabaqui> can I use pthread_setname_np in GHC?
05:48:58 <tabaqui> I want to name os threads for readability
05:49:21 <tabaqui> Control.Concurrent hasn't this api
05:49:38 <merijn> tabaqui: eh, how would that work?
05:49:45 <merijn> tabaqui: Haskell threads are not pthreads
05:50:08 <tabaqui> haskell bound thread are pthreads
05:50:12 <tabaqui> *threads
05:50:24 <merijn> Eh, no
05:50:27 <tabaqui> I want like here: http://man7.org/linux/man-pages/man3/pthread_setname_np.3.html
05:50:31 <tabaqui> no, why?
05:50:41 <merijn> bound threads are threads that are always run by the same OS thread
05:50:56 <merijn> tabaqui: This doesn't mean OTHER haskell threads never run on the same OS thread
05:50:57 <tabaqui> hmm, unbound then?
05:51:03 <lseactuary> anyone here good at first order logic? i have tried to model my problem but now i am stuck
05:51:17 <merijn> tabaqui: bound threads are just never moved between OS threads
05:51:36 <tabaqui> okaay
05:51:37 <merijn> tabaqui: There's no reason why you couldn't have multiple bound threads being run by the same OS thread, for example
05:51:48 <tabaqui> but which threads I see in htop then?
05:52:11 <merijn> The runtimes worker threads and FFI threads, you don't know which Haskell thread is running on which of those
05:52:40 <tabaqui> GHC just spawns one thread for each logic core?
05:52:48 * hackage quickcheck-state-machine 0.3.0 - Test monadic programs using state machine based models  https://hackage.haskell.org/package/quickcheck-state-machine-0.3.0 (stevana)
05:52:51 <merijn> tabaqui: That depends what you tell the runtime
05:53:00 <tabaqui> numCapabilities?
05:53:16 <merijn> tabaqui: 1 capability = 1 OS thread that runs 1 or more Haskell threads
05:53:39 <tabaqui> and there is no correlation between 'fork' calls and os threads?
05:54:28 <merijn> No
05:58:24 <tabaqui> okay, thanks
05:59:23 <tabaqui> it starts from Python actually - huge memory leak in program, that my haskell starts as subprocess
05:59:44 <tabaqui> and we found that POSIX allow to rename the os threads, and thought "great idea!"
06:00:20 <tabaqui> but python doesn't provide such api, and haskell don't give a s* about os threads
06:12:18 <infinisil> lseactuary: Just ask your question
06:12:56 <lseactuary> i posted it here also: https://math.stackexchange.com/questions/2560154/first-order-logic-real-world-model
06:18:19 <Psybur> > [1] : L.unfoldr (\b -> Just(b,[(last b + 1)..(last b) + (length b) + 8])) [2..9]
06:18:21 <lambdabot>  error:
06:18:21 <lambdabot>      Not in scope: ‘L.unfoldr’
06:18:21 <lambdabot>      Perhaps you meant one of these:
06:18:28 <Psybur> > [1] : unfoldr (\b -> Just(b,[(last b + 1)..(last b) + (length b) + 8])) [2..9]
06:18:30 <lambdabot>  [[1],[2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25],[26...
06:18:40 <Psybur> Anyone recognize that? heh
06:21:07 <ertes> > fix (\go r s -> s : go (r + 1) (s + 2*r + 1)) 0 0
06:21:09 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
06:28:26 <infinisil> Lol
06:28:52 <infinisil> I actually searched oeis for that sequence
06:29:41 <Psybur> Find anything? :D
06:31:59 * hackage chronos 1.0.1 - A performant time library  https://hackage.haskell.org/package/chronos-1.0.1 (andrewthad)
06:35:02 <ocramz> hi all
06:35:53 <ocramz> can someone advise on reading a binary file in buffered mode  ? 
06:36:06 <ocramz> what are the available libraries, ec.
06:36:35 <ocramz> I'm writing bindings to a C library that accepts data in chunks
06:43:05 <[exa]> @pl \x a b -> f x (g x a) b
06:43:05 <lambdabot> liftM2 (.) f g
06:43:32 <s4ke> hey guys. i've been wondering where i could find the paper that introduced Profunctors
06:43:32 <hexagoxel> ocramz: i'd look at lazy bytestring readFile + toChunks
06:43:36 <s4ke> so i can cite it properly
06:43:56 <ocramz> hexagoxel : thanks!
06:47:16 <mnoonan> s4ke: do you mean in the context of Haskell, or in the context of category theory?
06:47:24 <s4ke> category theroy
06:47:26 <s4ke> category theory
06:47:44 <s4ke> and if you have it available, maybe haskell as well
06:48:46 <mnoonan> it is an old concept, not sure where it was first used.. digging...
06:49:18 <mnoonan> ah, ncatlab knows (see section 7): https://ncatlab.org/nlab/show/profunctor
06:50:33 <s4ke> mnoonan: welp that's old. hmm
06:50:34 <ocramz> hexagoxel also hGetContentsN from streaming-bytestring looks promising : https://hackage.haskell.org/package/streaming-bytestring-0.1.5/docs/Data-ByteString-Streaming.html#v:hGetContentsN 
06:52:59 <Psybur> Ah crap ncatlab is sucking me in
06:53:19 <Psybur> Whats that? Click. Whats that? ...
06:55:36 <Psybur> Is an example of a 2-morphism something like 1 + 1 = 2 and 1 - (-1) = 2
06:56:07 <Psybur> Wonder if thats better asked in #math? Is category theory math?
06:57:32 <Psybur> Or a 2 morphism transforms one morphism from x -> y to another morphism thats also x -> y?
06:58:53 <mnoonan> yeah, ##math is probably better.
06:59:28 <infinisil> @pl \ns -> (ns, sum ns)
06:59:28 <lambdabot> ap (,) sum
06:59:42 <infinisil> Nice
07:15:49 * hackage trigger 1.0.0.0 - Cross platform file system watcher  https://hackage.haskell.org/package/trigger-1.0.0.0 (rhyskeepence)
07:20:48 * hackage accelerate-cufft 1.0 - Accelerate frontend to the CUFFT library (Fourier transform)  https://hackage.haskell.org/package/accelerate-cufft-1.0 (HenningThielemann)
07:27:12 <oisdk> Question on generics: any way to detect recursion in data types? I'm fooling around with generics to automatically generate a church-encoded version of types, but currently it doesn't give the right answer for recursive types
07:28:07 <oisdk> Like for Bool, you'll get: fold True :: a -> a -> a, but for [a] you'll get: b -> (a -> [a] -> b) -> b
07:32:51 <[exa]> oisdk: you can run some version of occur-check
07:33:49 * hackage plot 0.2.3.9 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  https://hackage.haskell.org/package/plot-0.2.3.9 (VivianMcPhail)
07:34:53 <[exa]> oisdk: but I guess that the thing you showed isn't recursive type in the sense that would maeke problems with church encoding
07:35:32 <Psybur> > fix (False:)
07:35:34 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
07:35:47 <oisdk> [exa] sorry, the second version is what I'm getting now, but it's not the desired version
07:35:48 * hackage radius 0.5.0.0 - Remote Authentication Dial In User Service (RADIUS)  https://hackage.haskell.org/package/radius-0.5.0.0 (erick)
07:36:11 <ertes> is there a variant of 'ad' that can compute gradients with 'vector' vectors?
07:36:25 <ertes> in particular the unboxed ones like primitive, storable or unboxed
07:37:29 <oisdk> I have a function fold :: (Generic a, Church (Rep a)) => a -> Fold (Rep a) b; I'd like that to expand to fold :: [a] -> b -> (a -> b -> b) -> b for lists, currently it expands to fold :: [a] -> b -> (a -> [a] -> b)
07:37:59 <oisdk> oops. Currently it expands to: fold :: [a] -> b -> (a -> [a] -> b) -> b
07:39:56 <ertes> edwardk: ^
07:41:07 <rightfold> Is it possible to hoist Codensity?
07:41:19 <rightfold> Ie apply a natural transformation to the underlying monad
07:42:31 <ertes> @let import Control.Monad.Codensity
07:42:33 <lambdabot>  Defined.
07:43:11 <ertes> :t (\f (Codensity g) -> Codensity (f . g)) :: (forall a. m a -> n a) -> Codensity m r -> Codensity n r
07:43:12 <lambdabot> error:
07:43:12 <lambdabot>     • Couldn't match type ‘n1’ with ‘m1’
07:43:12 <lambdabot>       ‘n1’ is a rigid type variable bound by
07:43:59 <rightfold> Ah no it’s not possible
07:44:08 <rightfold> The m b occurs in both negative and positive position
07:44:29 <ertes> rightfold: if you can hoist ContT, you can also hoist Codensity
07:44:57 <rightfold> But can you hoist ContT?
07:44:57 <ertes> the converse is probably also true
07:45:07 <ertes> i don't think so
07:45:33 <ertes> unless m and n are isomorphic
07:46:15 <rightfold> Maybe I can use Free over Coproduct for what I want to do
07:46:23 <rightfold> Instead of hoisting
07:46:48 <rightfold> Ah yes I’m a fool
07:46:54 <ertes> or hoist after lowerCodensity
07:47:34 <ertes> s/hoist/switch/
07:47:43 <rightfold> Yeah exactly :)
07:48:22 <rightfold> Yes it works :3
07:48:26 <rightfold> Thanks so much
07:55:16 <rightfold> I’m so happy now
08:05:53 * hackage dsp 0.2.4 - Haskell Digital Signal Processing  https://hackage.haskell.org/package/dsp-0.2.4 (HenningThielemann)
08:13:10 <hoon> I was trying to understand the implemenation of liftIO for all the different mtl Monads, but the Control.Monad.IO.Class file doesn't seem to show up under the hackage listing for the latest transformers package. anyone know why?
08:13:58 <hoon> I found it for a previous version, so I was able to peek under the covers to understand it, but I'm curious if the structure of the package changed or if it's just an oversight on the package page
08:16:25 <ggVGc> if I have a set of rules and want to chain them and eventually perform some action if all of them passed, that's an applicative interface, right?
08:18:52 <hoon> I'm probably not the right guy to answer....but, it might be an applicative, it might be a monad
08:19:16 <infinisil> :t all
08:19:17 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
08:19:44 <infinisil> :t all id [ (>5), odd ]
08:19:45 <lambdabot> error:
08:19:46 <lambdabot>     • Couldn't match expected type ‘Bool’
08:19:46 <lambdabot>                   with actual type ‘Integer -> Bool’
08:20:07 <lyxia> hoon: it's in base
08:20:34 <ggVGc> hphuoc25_: well, I figured it's not a monad since each rules input should not depend on another ones output. The only thing is that the next rule should not be processed if previous ones failed
08:20:57 <ggVGc> sorry, hoon ^
08:20:57 <hoon> ggVGc -- sounds like a Maybe
08:21:05 <ggVGc> yeah, actually
08:21:06 <ggVGc> hah
08:21:17 <ggVGc> I guess that's all it is. every rule is just a maybe result
08:21:37 <ggVGc> well, except I don't care about the held value..
08:21:51 <ggVGc> so, Maybe ()?
08:22:07 <hoon> ggVGc
08:22:08 <ggVGc> I feel this is the applicative instance of Maybe
08:22:13 <infinisil> Oh got it:
08:22:15 <infinisil> % all id $ map ($10) [ (>5), odd ]
08:22:17 <hoon> ggVGc -- sounds plausible
08:22:17 <yahb> infinisil: False
08:22:25 <infinisil> something like this, ggVGc ^^?
08:22:55 <infinisil> (without monads though)
08:22:57 <hoon> lyxia: thanks
08:23:01 <ggVGc> infinisil: yeah, that looks like what I'm doing basically. thanks
08:24:44 <hoon> lyxia: when you hoogle liftIO, one of the references is Control.Monad.IO.Class -> it dumps you into https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-IO-Class.html#v:liftIO which doesn't exist
08:24:52 <hoon> hence the confusion
08:27:33 <infinisil> ggVGc: Oh, actually, that's the same as `all ($10) [ (>5), odd ]`
08:27:48 <ggVGc> infinisil: funny, I never thought about using $ to create functions like that
08:28:21 <infinisil> it is very neat
08:28:30 <ggVGc> yep, will be doing it from now on :)
08:28:31 <ggVGc> thanks
08:45:19 * hackage ochintin-daicho 0.1.0.1 - A module to manage payroll books for Japanese companies.  https://hackage.haskell.org/package/ochintin-daicho-0.1.0.1 (arowM)
08:51:36 <pmade> For anyone using a database migration package: How are you including SQL files with your package?  Seems like cabal's data-files would be very painful for something like this.
08:57:14 <pmade> Perhaps using TH to include the migration files in the binary is the right choice.
09:00:35 <pmade> Or I could put them in data-files and use TH to record their names so I can pull them out at runtime when needed.  Maybe that's better.
09:01:51 <rightfold> hoon: it’s in base
09:04:42 <hoon> rightfold: yeah I got that now, thanks
09:08:30 <c_wraith> pmade: if you put them in data-files, do you even need to use TH?  you can always just list the contents of the directory.
09:09:42 <pmade> c_wraith: Hmm, I suppose that's an option too.  I was thinking you could only access the files if you knew their names.  But there's a function to get the path to the data dir too huh?
09:09:44 <c_wraith> (I recommend against TH whenever another solution works, just because of the impact it has on compile times.
09:09:49 <c_wraith> )
09:10:37 <pmade> I'll do some experimenting.  Thanks.
09:11:04 <glguy> data-files is troublesome as they are only updated upon install, so they're likely to be out of date while developing if you aren't careful to override the data files directory during development with an envvar
09:11:15 <glguy> and then it makes it harder to deploy the binary to other systems
09:11:28 <c_wraith> that is a good point in the opposing direction
09:13:25 <pmade> glguy: good points.
09:25:20 <cocreature> the TH based solution is broken with new-build so if you use that, this might also be something to factor into your decision
09:26:13 <glguy> Is the specific breakage that new-build doesn't respect the file dependency information that TH registers with GHC, so it doesn't build enough?
09:26:18 <glguy> when something changes
09:26:20 <cocreature> yep
09:26:30 <cocreature> which is really annoying during development
09:26:39 <cocreature> there is an issue for it somewhere
09:42:27 <Scorchin> I'd like to write a toy programming language in Haskell, mainly because I've heard wonderful things about parsec. Are there any good blog posts, conference talks, or books on the subject that I should definitely check out?
09:43:59 <byorgey> Scorchin: on the subject of parsec, or on the subject of writing toy programming languages?
09:44:48 <Scorchin> byorgey: more on the latter, if I'm honest
09:45:02 <Scorchin> but with a skew towards using Haskell to do it
09:46:16 <pmade> I suppose the data-files solution is the best one so far.  Any idea if data-files copies directories recursively yet? GitHub issues suggest yes, but docs say no.
09:48:37 <int-e> mniip: hmm
09:49:36 <monochrom> Consider https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:50:32 <asoltysik_> Hi, I am using stack and I am uploading a package candidate to hackage. I am first building the library with `stack build` and `stack haddock`, then I run `stack sdist` and upload the tarball. However my haddock docs don't show up at all on the hackage page. How do include the docs in the tarball?
09:52:36 <byorgey> Scorchin: you may be interested in the notes & assignments from this course I taught: http://ozark.hendrix.edu/~yorgey/360/
09:52:54 <Scorchin> Thanks both. I'll check them out.
09:53:21 <cocreature> asoltysik_: you can’t. stack can’t produce docs suitable for hackage. hackage will try to build the docs of your package (although I’m not sure if it tries for candidates as well) but that can fail, e.g., due to missing foreign deps
09:54:45 <asoltysik_> cocreature: what are my options then?
09:55:06 <cocreature> asoltysik_: use cabal to build the docs or hope the hackage builder works
09:55:09 <byorgey> asoltysik_: how long ago did you upload the package?
09:55:32 <byorgey> asoltysik_: it takes a little while (up to a day?) before the docs are automatically built on Hackage
09:55:50 <cocreature> it’s relatively fast recently
09:55:57 <asoltysik_> oh, that may be the case, I've uploaded like 10 minutes ago
09:56:00 <cocreature> although as I’ve mentioned before, I’m not sure the builder runs for candidates
09:56:01 <byorgey> oh, is it? nice
09:56:20 <byorgey> asoltysik_: ok, wait a little while and see if the Haddocks show up
09:56:34 <asoltysik_> thanks for the help
09:59:30 <asoltysik_> also another question, does using SemVer instead of PVP break some tooling? I am currently deciding which one to use for my lib. Personally I prefer SemVer, but if that's any issue for the ecosystem I will use PVP
09:59:58 <cocreature> it breaks everyone’s expectation that you follow the pvp
10:00:03 <glguy> asoltysik_: If you don't have any users you won't violate their expectations
10:00:27 <monochrom> SemVer and PVP accomplish the same thing. But they differ in how many dots.
10:01:32 <monochrom> So you're basically saying if you write Japanese Kanji to Chinese readers what will happen.
10:01:40 <cocreature> I guess assuming that one of your dependencies uses pvp when it actually uses semver can only result in bounds that are too strict not the other way around but it’s still kind of annoying
10:02:35 <asoltysik_> Oh, so everyone expects PVP? I was curious because the haskeleton template automatically puts following line in the CHANGELOG.MD: "bloom uses Semantic Versioning." So I thought many people use SemVer
10:02:36 <monochrom> This will happen: Whereas you write "bath water" the readers will read "soup".
10:03:10 <cocreature> asoltysik_: the vast majority of Haskell packages use the PVP
10:03:16 <monochrom> True story: The converse actually happened.
10:04:00 <asoltysik_> Cool, I will stick with PVP then
10:05:18 <monochrom> A Chinese guy went to Japan for a trip. He brought ingredients for cooking soup. He handed the ingredients to the hotel staff and wrote the Chinese character "soup" on paper. The hotel staff put the ingredients in the bath tub and added hot water. Because the character means "bath water" in Japanese Kanji.
10:05:38 <monochrom> SemVer and PVP are in the same relation.
10:05:56 <glguy> That's a true story, I was there that day
10:06:38 <AdituV> heya!  anyone familiar with superrecord?  I'm trying to define a type that's effectively "record with at least these elements" but getting type unification errors like this: http://lpaste.net/738109195177426944
10:18:43 <AdituV> think I've got it, needed a newtype instead of a type
10:25:21 <infandum> Does hmatrix have a map with index function for matrices?
10:27:01 * hackage bunz 0.0.3 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.3 (sendyhalim)
10:27:23 <Average-user> join #Haskell-irc
10:27:32 <Average-user> pff
10:30:22 * hackage bunz 0.0.4 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.4 (sendyhalim)
10:33:32 <lyxia> hoon: also, use hoogle.haskell.org or the one on stackage instead of haskell.org/hoogle, which is getting very old.
10:34:47 <ocramz> hullo!
10:34:53 <mnoonan> lyxia: ...except the type search is still sometimes better with haskell.org/hoogle
10:35:38 <glguy> Average-user: You're still welcome to join, even though you forgot the / the first time
10:39:50 <hololeap> does anyone know how i can generate a doc index file for all the packages installed globally?
10:40:09 <Psybur> What is that book that everyone recommends for concurrency/parallelism in haskell?
10:40:36 <mnoonan> parallel and concurrent programming in haskell?
10:40:38 <cocreature> yep
10:40:42 <schell> Psybur: “Parallel and Concurrent PRogramming in Haskell"
10:41:03 <Psybur> Thanks.
10:41:05 <hololeap> all the packages are registered here: /usr/lib/ghc-8.0.2/package.conf.d
10:41:26 <hololeap> and i want to generate a master index file like cabal can do with the --doc-index-file option
10:41:44 <Psybur> Oh snap its free
10:46:24 <schell> how does one add an “if os(darwin)” ala cabal to package.yaml (to be processed with hpack)?
10:47:16 <Average-user> someone uses emacs to write haskell?
10:47:20 <fakenullie> Average-user: ues
10:47:36 <fakenullie> schell: I think hpack manual describes that
10:47:48 <cocreature> shapr: https://github.com/sol/hpack#-conditionals
10:47:55 <schell> trying to find that … i’m at the … perfect! thanks
10:48:11 <schell> thanks guys
10:48:18 <Average-user> when I try to install haskell-mode, after pasting the code in init.el and doing M-x packages-refresh-contents, It gets stuck in: Contacting host: elpa.gnu.org:80
10:48:42 <fakenullie> Average-user: maybe you don't have access to it
10:56:47 <Average-user> fakenullie: How can I get access to it?
10:57:02 <fakenullie> Average-user: I mean something is wrong with your network
10:57:28 <fakenullie> Average-user: try to open elpa.gnu.org in browser
10:57:45 <fakenullie> Average-user: or ask in #emacs, I don't have emacs running here
10:58:32 <hoon> lyxia: awesome! I didn't realize hoogle.haskell.org was available.
11:02:48 * hackage bunz 0.0.5 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.5 (sendyhalim)
11:06:16 <Average-user> fakenullie: No problems when I open it in the browser
11:12:17 <geekosaur> sounds like you're behind a proxy that only the browser knows about?
11:13:06 <geekosaur> (possibly because browsers do a javascript-based proxy detection thing; since it's js, it's hard for non-browsers to use)
11:15:55 <humanoyd> 1/quit
11:16:34 * hackage yesod-auth-oauth2 0.3.1 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.3.1 (PatrickBrisbin)
11:16:40 <Average-user> geekosaur: Any idea how to fix it?
11:18:42 <ph88^> i have stack in /usr/bin/stack but it's upgrading in ~/.local/bin/stack   how do i uninstall stack from my system folders ?
11:20:05 <monochrom> How did you install it? There is usually an official inverse for that.
11:20:23 <ph88^> i used the official installer script a long time ago as far as i remember
11:20:59 <monochrom> Does the official installer script have an uninstall option?
11:21:21 <Psybur> Anybody know how to install pangocairo on windows? >.> stack exec -- pacman -Qs pangocairo doesnt help
11:21:41 <ph88^> monochrom,  i don't think so     wget -qO- https://get.haskellstack.org/ | sh
11:22:07 <monochrom> That's too bad.
11:22:21 <monochrom> Have you tried vanilla cabal-install? >:)
11:22:32 <ph88^> never
11:22:55 <mnoonan> ph88^: what about just deleting it from /usr/bin?
11:23:23 <ph88^> yeah i will do that .. but i don't know if it left other files in other system dirs
11:23:51 <monochrom> It clearly does.
11:24:27 <ph88^> which files ?
11:25:01 <monochrom> I am not really surprised. The company has a senior executive who worked for Microsoft and was the very person who invented "embrace extend extinguish".
11:25:05 <geekosaur> Average-user, since I'm not your network admin, no
11:25:13 <mnoonan> I don't think so, afaik everything else ends up in sandboxes
11:25:26 * hackage discrete-intervals 0.0.1 - Discrete Intervals  https://hackage.haskell.org/package/discrete-intervals-0.0.1 (chessai)
11:25:42 <geekosaur> there's generally an environment variable you can set that *ix programs will use, but I have no way of knowing what you'd need to put into it
11:27:26 <geekosaur> Psybur ... that command you tried is hurting my brain
11:27:32 <monochrom> Oh the script may actually call "apt install stack" or "yum install stack" or whatever it is.
11:27:48 <Psybur> geekosaur, how so? :D
11:27:53 <ph88^> was there ever a ghc 8.1 ?
11:27:56 <mnoonan> ph88^: you can run "stack path" to see where stack might have put things. but also check if your other stack is using those same locations or not before deleting anything
11:27:58 <crucify_me> hi in CS is there a convention to display bits in reverse order, say converting 23 to [1,1,1,0,1]. ie why would you want it left in that sequence? I ask because the book doesn't make an effort to use reverse to display the actual bitcode
11:28:19 <monochrom> So you need to inverse it with "apt remove stack" or whatever it is for yum or whatever it is for your OS.
11:28:34 <Average-user> monochrom: I'm using Debian, and installed it with: apt install emacs25
11:28:36 <geekosaur> Psybur, you do not. ever. want system packages to be able to see inside of stack's package stash. best case is it'll ignore it completely, worst is stack will break, abd break badly
11:28:39 <ggVGc> okay guys, gonna write some haskell
11:28:47 <geekosaur> only stack should modify that
11:28:53 <monochrom> This is why I don't believe in "the user doesn't need to know". The user always needs to know.
11:28:59 <nf7> Hey, can someone explain to me why this code doesn't work? I don't understand the error from the compiler. What I'm confused about is if I put that `putStrLn $ head args` in the path function, it works perfectly fine, but I cannot return `head args` and then putStrLn that in the main function? 
11:29:04 <nf7> https://gist.githubusercontent.com/anonymous/1b78c76fd68c654c5ef39dcb8d308048/raw/94ae60e398c8ad89094a53731255a9a51affcbd6/test.hs
11:29:20 <ph88^> thx mnoonan 
11:29:23 <Psybur> Hmm, all over the net you get told to do stack exec -- pacman :D
11:29:31 <crucify_me> not a convention necessarily but I haven't made the connection why its left in reverse order
11:29:42 <[exa]> crucify_me: if it's visibly displayed as an array, reverse order is OK because array indices correspond to coefficients
11:29:58 <geekosaur> the reason stack works is it and it alone has full control over its package stash so it can stop ghc and Cabal-lib from seeing multiple or wrong versions of things. let something else modify the stash and you lose that
11:30:34 <Psybur> Hmm luckily my stack is working fine :D
11:30:42 <ggVGc> why is it we have such a hard time dealing with versioning and dependencies in haskell
11:30:54 <drdo> crucify_me: That is the one true way
11:30:55 <ph88^> monochrom, right that was it !! thx
11:30:57 <ggVGc> while other modern languages manage it quite well
11:31:05 <drdo> We write numbers backwards ordinarily for some reason
11:31:14 <drdo> Just makes sense to start from the lower indices
11:31:16 <[exa]> ggVGc: please have a look at NPM before you assume that :]
11:31:17 <Psybur> ggVGc, because you havent made that killer dep manager yet
11:31:28 <Psybur> And written up the docs and marketed it
11:31:28 <ggVGc> [exa]: yeah node isn't a good example
11:31:28 <ph88^> i guess the repository i got stack from wasn't updating stack anymore
11:31:29 <geekosaur> probably because most linux-origin package managers have policy and often sanity checks to stop them from modifying anything out of system directories
11:31:34 <geekosaur> it's still a bad idea
11:31:54 <crucify_me> [exa], do you mean if you sum it up using algebra ?
11:32:40 <ggVGc> [exa]: I think there's also a fairly big difference between compiled and dynamic languages in this area. Python for example has a pretty good situation with pip, but it's not applicable to something like haskell
11:32:48 <ggVGc> rust crates seem to be really good
11:32:54 <geekosaur> package managers should produce stable reproducible environments, not uncontrollable modifications to random user-owned files. (for that matter stack has the same policy)
11:33:07 <pta2002> is there any way I can apply a function to both values in a 2 value tuple
11:33:19 <ggVGc> Psybur: map?
11:33:25 <pta2002> e.g. succ <$> (1,1) producdes (1,2). I Want something that'd produce (2,2)
11:33:26 <ggVGc> eh, pta2002 
11:33:41 <pta2002> > map succ (1,1)
11:33:42 <lambdabot>  error:
11:33:42 <lambdabot>      • Couldn't match expected type ‘[b]’
11:33:42 <lambdabot>                    with actual type ‘(Integer, Integer)’
11:33:47 <s4ke> % fmap succ (1,1)
11:33:47 <yahb> s4ke: (1,2)
11:33:50 <[exa]> crucify_me: well, if the numbers are in an array, it's more natural to write 10 as [0,1,0,1] because the array indices correspond to the powers of two; and 1010b is for human processing
11:33:50 <s4ke> huh
11:33:53 <fresheyeball> hey out there
11:33:55 <ph88^> lol
11:33:57 <mnoonan> pta2002: are you ok with both members of the tuple having the same type?
11:33:59 <ggVGc> yeah, sorry, fmap
11:34:00 <Psybur> > let f g (a,b) = (g a, g b); f (+1) (1,2)
11:34:00 * ggVGc hides
11:34:01 <pta2002> monochrom: yes
11:34:02 <lambdabot>  <hint>:1:41: error:
11:34:02 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:34:05 <monochrom> Other modern languages have a hard time contemplating the idea of cross-package inlining instead. (GHC does it for breakfast every day.)
11:34:05 <fresheyeball> what operator do I use if I want to compose Prisms
11:34:07 <pta2002> uh, mnoonan 
11:34:08 <[exa]> ggVGc: rust doesn't have the interpretation/inlining problem :]
11:34:14 <nf7> Can anyone help me with my problem, or perhaps link me somewhere to get a better understanding of how it works?
11:34:22 <fresheyeball> x ? _Just . _Foo . at "bar"
11:34:22 <ggVGc> [exa]: yeah I was thinking it's the inlining that's the big issue eh
11:34:33 <fishythefish> nf7: probably, just ask it
11:34:39 <ggVGc> pta2002: fmap is the answer like 90% of the time in haskell I reckon
11:34:46 <pta2002> ggVGc: won't work here
11:34:52 <pta2002> % succ <$> (1,1)
11:34:52 <yahb> pta2002: (1,2)
11:35:12 <crucify_me> [exa], thanks got it
11:35:22 <nf7> fishythefish: I asked it a few screens up ^
11:35:41 <ph88^> hi fresheyeball 
11:35:42 <ph88^> :t (&&&)
11:35:42 <ph88^> >:t (&&&)
11:35:43 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:35:48 <mnoonan> > over both (+1) (3,4) -- pta2002, if you are ok with using microlens or some such
11:35:51 <lambdabot>  (4,5)
11:35:51 <fresheyeball> ph88^: howdy!
11:35:53 <geekosaur> the other thing is I'm not sure what problem you were trying to solve with it. pacman would be installing system level C/C++ libraries, not haskell libraries (unless it's a haskell specific package and in that case you should really not be trying to use them with stack)
11:36:01 <fishythefish> nf7: the issue is the type of path. what do you think it is?
11:36:07 <monochrom> Hugs would enjoy the same dependency robustness as Python and Lisps.
11:36:10 <pta2002> mnoonan: it works i guess
11:36:21 <nf7> fishythefish: I want it to be a String, but I think it's something else.
11:36:29 <mnoonan> pta2002: honestly, writing your own little helper function is probably best
11:36:43 <[exa]> ggVGc: the biggest problem is in fact that builds are not the same given different versions of dependencies and, unlike C/C++, it can break a lot of things
11:36:44 <fishythefish> nf7: right, it's an IO string. do you know what the "do" means?
11:36:50 <pta2002> mnoonan: probably
11:36:54 <fishythefish> IO String*
11:36:55 <pta2002> not like it's hard
11:36:57 <s4ke> % (succ *** succ) (1,1)
11:36:58 <yahb> s4ke: (2,2)
11:37:18 <nf7> fishythefish: I think it means to not be lazy, but to evaluate immediately?
11:37:21 <[exa]> (it can even in C/C++, but the people there fear the abi changes more than haskellers :])
11:37:24 <s4ke> Control.Arrow for that though pta2002
11:37:24 <pta2002> a f (b, b') = (f b, f b')
11:37:31 <geekosaur> nf7, you might want to read https://www.vex.net/~trebla/haskell/IO.xhtml
11:37:33 <pta2002> what is this *** magic
11:37:42 <s4ke> % :t (***)
11:37:42 <infinisil> :t (***)
11:37:43 <yahb> s4ke: (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:37:44 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:37:44 <geekosaur> pta2002, Arrow function
11:37:45 <ph88^> pta2002, it's part of the arrows package 
11:37:50 <infinisil> heh
11:37:53 <pta2002> What's arrow?
11:37:54 <ph88^> :t (&&&)
11:37:54 <fishythefish> nf7: no, not quite. it basically means that you're building up an IO action
11:37:55 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:38:05 <nf7> fishythefish: Ok
11:38:06 <ph88^> pta2002, it's the ->  in your function
11:38:17 <pta2002> Oh
11:38:23 <monochrom> (***) for functions means: (f *** g) (x,y) = (f x, g y)
11:38:30 <pta2002> Interesting
11:38:35 <geekosaur> nf7, short version is what happens in IO stays in IO. you can temporartily extract it with do's '<-' or the >>= operator but the final result has to go back into IO. which is not a problem in practice because 'main' is also in IO
11:38:40 <monochrom> But they generalized from functions to all Arrow instances.
11:38:56 <fishythefish> nf7: within the "do", you can extract values from other IO actions with "<-", and the last line of the "do" block will be the value produced by the IO action you're defining
11:38:59 <ggVGc> I still don't get the idea of arrows
11:39:02 <ph88^> pta2002, i think arrow is when you go from one type to another type (it can be the same type though)
11:39:18 <geekosaur> pta2002, Arrows are an attempt to generalize the notion of the function arrow (the -> in function types)
11:39:34 <ph88^> did they succeed ? :p
11:39:35 <s4ke> ggVGc: Arrows are Categories with first and a lifting arr
11:39:36 <ggVGc> why isn't arrows just function?
11:39:38 <fishythefish> nf7: so you could write `main = putStrLn =<< path` or `main = path >>= putStrLn` or `main = do p <- path; putStrLn p`
11:39:39 <s4ke> % :t arr
11:39:39 <yahb> s4ke: arr :: Arrow a => (b -> c) -> a b c
11:39:43 <pta2002> I'll check that out later then, thanks
11:39:48 <s4ke> % :t first
11:39:48 <ph88^> % :t (&&&)
11:39:48 <yahb> s4ke: first :: Arrow a => a b c -> a (b, d) (c, d)
11:39:49 <yahb> ph88^: (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
11:39:51 <geekosaur> in practice it wasn;t a very good one, and eventually it got split into categories, profunctors, and applicatives. but some of the functions are still fairly useful
11:39:53 <[exa]> ggVGc: arrows: instead of (a -> b) you write (a `SOMETHING` b) because what if someone wanted to put a different thing there
11:39:55 <monochrom> Because another example is "a -> IO b".
11:40:06 <monochrom> There are a few more other examples.
11:40:39 <ggVGc> [exa]: hm, yeah, okay, I get it I think. So you can define "something that makes A into B", but leave a hole for the "how to make it"
11:40:42 <[exa]> ggVGc: direct usage: function execution traces (similarly as monadic Writer)
11:40:46 <[exa]> yeah
11:41:00 <s4ke> Every Strong Profunctor which is also a Category should be an arrow
11:41:04 <s4ke> (if it obeys the laws)
11:41:06 <ggVGc> yeah, seems pretty powerful now that I think about it
11:41:21 <ggVGc> you can basically define a sequence of transformations, and then run it with different sets of actuators
11:41:22 <geekosaur> ggVGc, yeh, Arrow a b c is a generalization of b -> c, with -> replaced by a type variable with an Arrow instance
11:41:41 <s4ke> ggVGc yes. i am working on stuff like this atm. parallelizing Arrows
11:41:53 <nf7> fishythefish: Hmm ok I don't really understand that at all, I need to hit the books again. I've been studying Haskell for like a month in total now and I still can't write a program that can do anything useful (cause everything needs input, which I just cannot wrap my head around) :| 
11:42:11 <[exa]> yeah, parallelization is a nice usage
11:42:23 <geekosaur> nf7, do read that page I linked earlier. most people find it very helpful in figuring out how Haskell's IO works
11:42:30 <fishythefish> nf7: it's okay, IO is handled a bit differently in Haskell than in other languages. geekosaur's link is useful
11:42:33 <ggVGc> but why is this more powerful than just foo :: a -> (a->b) -> b
11:42:40 <nf7> geekosaur: Reading it right now!
11:43:02 <ph88^> when are we gonna talk about burrito's? :>
11:43:05 <ggVGc> or rather the other way around for the first arguments
11:43:12 <geekosaur> ggVGc, that question is more or less why Arrows aren't actually used very often as such
11:43:30 <s4ke> [exa] it really really works great 
11:43:39 <s4ke> finishing everything atm
11:43:45 <fishythefish> please, no burritos. I'm somewhat proud of #haskell for not mentioning the dreaded m-word in an introduction to IO
11:43:45 <[exa]> s4ke: mind a link?
11:43:54 <geekosaur> great idea, more limited than people hoped in the end. in practice the main instances are (->) itself and the Kleisli arrow (composing monad actions)
11:43:55 <s4ke> https://github.com/s4ke/Parrows
11:43:57 <monochrom> There is no burrito.
11:44:23 <[exa]> s4ke: oh yes I read your article like 3 days ago :]
11:44:57 <monochrom> But https://currito.com/ is Applicative >:)
11:45:04 <geekosaur> ...and those two instances have a tendency to diverge in usage, meaning there isn't a whole lot of use in having a generalization that covers both
11:45:21 <shapr> s4ke: wow, that's nifty
11:45:48 <ggVGc> are burritos monoids_
11:45:51 <ggVGc> ?
11:46:03 <monochrom> No, I can't <> them.
11:46:09 <fishythefish> probably in a few ways
11:46:14 <fishythefish> monochrom: not with that attitude
11:46:26 <shapr> What if I'm the container and I purely eat burritos?
11:46:29 <ggVGc> what if I wrap a burrito in a bigger burrito
11:46:29 <[exa]> s4ke: anyway, wanted to ask -- what are run-time requirements of the thing? (how much of parallelization can you prepare at compile time and how much of it requires a runtime?)
11:46:33 <ggVGc> to form a new large burrito
11:46:34 <fresheyeball> grr
11:46:43 <fresheyeball> can you just not compose Prisms with . ?
11:46:50 <fishythefish> ggVGc: or just line em up end to end and get a longer one
11:46:59 <shapr> yeah, like subway sandwiches
11:46:59 <ggVGc> fishythefish: can't make them stick
11:47:14 <fishythefish> that's what guac is for
11:47:27 <fresheyeball> lets say I have `foo :: Map Text (Map Text Int)` can I not `foo ^? at "a" . at "b"`?
11:47:32 <monochrom> You can't call two rice grains "one rice grain" by just juxtapositioning them.
11:47:46 <ggVGc> fmaping wrapped burritos is very expensive though, since you have to unwrap all of them and build it up again
11:47:51 <fresheyeball> I was expecting `foo ^? at "a" . at "b" :: Maybe Int`
11:48:01 <geekosaur> fresheyeball, just looking at that my first question would be whether you need parens
11:48:15 <schell> in cabal is there a way to specify extra-lib-dirs as relative to the cabal file? i found this (https://stackoverflow.com/questions/24444675/use-relative-paths-for-extra-lib-dirs-on-cabal#24448226) but it’s 3 years old … hoping things have gotten better since then 
11:48:20 <monochrom> But perhaps you can use a soldering iron.
11:48:26 <schell> fresheyeball: o/
11:48:30 <shapr> s4ke: interested in a spellcheck PR against that paper?
11:48:34 <lyxia> fresheyeball: at isn't a prism and no you can't compose at like that
11:48:36 <fresheyeball> schell: !!!
11:48:48 <s4ke> shapr in a week yes :)
11:48:52 <fresheyeball> lyxia: how can I compose them?
11:48:53 <shapr> ok :-)
11:48:56 <mnoonan> monochrom, iirc your rice argument is more or less how Galileo decided everything must fall at the same rate
11:49:03 <fishythefish> i wouldn't call two juxtaposed burritos one larger burrito, but like, if you partially unwrapped the ends and then spliced/guac'd them together...
11:49:11 <shapr> :t guac
11:49:12 <lambdabot> error: Variable not in scope: guac
11:49:18 <shapr> @hoogle guac
11:49:18 <lambdabot> Network.AWS.CognitoIdentityProvider.GetUser guAccessToken :: Lens' GetUser (Maybe Text)
11:49:18 <lambdabot> Network.Google.Resource.Analytics.Management.Goals.Update mguAccountId :: Lens' ManagementGoalsUpdate Text
11:49:18 <lambdabot> Network.Google.Resource.Monitoring.Projects.Groups.Update pguAccessToken :: Lens' ProjectsGroupsUpdate (Maybe Text)
11:49:19 <fishythefish> @let guac = (<>)
11:49:21 <lambdabot>  Defined.
11:49:22 <shapr> that was unexpected
11:49:22 <fishythefish> :t guac
11:49:24 <lambdabot> Monoid m => m -> m -> m
11:49:25 * hackage discrete-intervals 0.0.2 - Discrete Intervals  https://hackage.haskell.org/package/discrete-intervals-0.0.2 (chessai)
11:49:45 <ggVGc> fishythefish: a burrito is a "wrap of things". The only way to mappend them is to make a burrito "a thing", and wrap that to get a new "wrap of things" where each thing is a burrito
11:49:46 <lyxia> fresheyeball: it looks like you can use ix here
11:50:02 <fresheyeball> lyxia: I am not familiar with ix
11:50:10 <fresheyeball> can you enlighten me?
11:50:17 <lyxia> fresheyeball: just replace at with ix
11:50:18 <fishythefish> ggVGc: disagree with that being the only way to mappend them
11:50:21 <ggVGc> fishythefish: if you asked me for a burrito, and I took some ingredients and partially attached them to eachother, would you be happy with your burrito?
11:50:27 <ph88^> Ix /ˈɪks/ is a fictional planet featured in the Dune series of science fiction novels written by Frank Herbert, and derivative works.
11:51:03 <fishythefish> if you took two fully-made burritos and joined them at endpoints, i'd be okay calling that a longer burrito
11:51:17 <ph88^> i'd just be getting more hungry
11:51:20 <fishythefish> i'd be far more impressed with your tortillas if you could keep wrapping burritos
11:51:43 <fishythefish> that said, i am a fan of the free burrito construction, particularly when drunk
11:52:23 <ggVGc> I'm kind of stuck on the thought of why I would ever use Arrows instead of value level (a->b) functions
11:52:42 <monochrom> I don't think you should worry.
11:53:15 <ggVGc> I basically am not very good with type theory, so I generally try to stay as much value level as possible
11:53:17 <monochrom> I sometimes use map instead of fmap, too.
11:53:21 <lyxia> fresheyeball: You can think of (.) as having type   Lens' a b -> Lens' b c -> Lens' a c.   That doesn't line up with   at "a" :: Lens' (Map ...) (Maybe ...), at "b" :: Lens' (Map ...) (Maybe ...)
11:53:55 <[exa]> ggVGc: so well, this helps you, it makes plain values from the otherwise untouchable functions
11:54:32 <fresheyeball> lyxia: I get the problem. I just didn't see or understand the answer
11:54:42 <fresheyeball> still not 200% on lens
11:54:44 <[exa]> ggVGc: the motivation is that you can't get much information from plain (->), you can only run it and observe the result (or a bottom)
11:54:45 <fresheyeball> reading about ix now
11:54:55 <nf7> I'm going to decompose this concept in my own words, I hope I'm understanding it correctly: Typing a function as IO says that this function is the action of reading something, rather than the type of the thing that it returns. What I don't understand is why that distinction is necessary. If a function returns a string, then that's all that should matter, right? But I get that since we don't have state 
11:55:01 <nf7> mutation, the string returned would always have to be the same string. So using the IO type says that this function returns "a string" rather than "a specific string". So far so good?
11:55:20 <monochrom> putStrLn "hello" doesn't read something.
11:56:09 <nf7> monochrom: Well that throws a wrench in my understanding then.
11:56:10 <monochrom> My article already explains why this distinction is necessary. Or at least, what you gain from this distinction.
11:56:24 <ggVGc> [exa]: maybe I'm misunderstanding, but I am not talking about using foo :: a->b instead of arrows. I'm saying foo :: (a->b) -> a -> b vs Arrows, and I don't see what more information I would get from one over the other
11:56:31 <monochrom> Yes I love to throw wrenches into wrong concepts.
11:56:43 <monochrom> The bane of science.
11:57:02 <ggVGc> *banana of science
11:57:17 <monochrom> Dead simple counterexamples to flawed theories.
11:57:28 <[exa]> nf7: what about reading "x -> IO y" as "a function that takes x and produces some weird action at a distance together with result y that you can get if you accept the action"
11:58:33 <EvanR> huh...
11:59:12 <f-a> hello: I need to print some text in an image, and save it to disk. I tried diagrams but it doesn't play well with monospace fonts (I need this for ascii art). Is there any alternative?
11:59:21 <ph88^> be back later
11:59:51 <[exa]> ggVGc: ever tried using scheme? functions there are lists, you can read them, modify them, print them out, and put back as a code.
12:00:23 <fishythefish> nf7: think of IO as the gate between pure and impure code. pure, non-IO code behaves like a mathematical function. its behavior does not rely on external state. impure, IO code can depend on the state of the world - e.g. a file, user input, RNG
12:00:25 <monochrom> With that kind of reflection power, you lose extensional equality.
12:00:38 <[exa]> ggVGc: which is kindof a missing feature of (->) :]
12:00:51 <nf7> fishythefish: Right
12:00:58 <s4ke> [exa] sec
12:01:20 <monochrom> But losing extensional equality is nothing compared to losing sanity.
12:01:30 <monochrom> You lose sanity by going self-modifying code.
12:01:38 <fresheyeball> is there a way to make un-necissary constraints a warning?
12:02:13 <ggVGc> [exa]: and does Arrows bring that? In lisp is't simply because you're executing the AST
12:02:54 <fishythefish> nf7: we ultimately have to mix pure and impure code to write useful programs, so we ensure all of our impure stuff goes in these IO actions and our pure code can treat those IO actions as black boxes. IO actions can be passed around, but can't be unwrapped by your code
12:02:58 <fishythefish> you can use the "<-
12:03:10 <fishythefish> you can use the "<-" notation, but only in the context of building up an IO action
12:03:22 <[exa]> ggVGc: well, you can define one that does that. It's defined as a normal function, runs as a normal function, but you can access stuff inside to see what is done there
12:03:36 <mnoonan> ggVCc: remember that (->) is an instance of Arrows, so Arrows can't bring any new capabilities to the table. It can only generalize stuff that used to be (->)-only.
12:03:47 <mnoonan> *Arrow
12:03:51 <nf7> fishythefish: I'm not sure what you mean by "building up an IO action"?
12:04:02 <ggVGc> [exa]: and how is that different from defining a function and taking transformation functions as arguments?
12:04:23 <mnoonan> ^oops, ggVGc
12:04:28 <fishythefish> nf7: e.g. "path" is an IO action - its type is IO String. When I say "building up an IO action", I mean the do block you're using to define it
12:04:34 <s4ke> [exa] what do you mean by "requires a runtime"?
12:04:43 <lyxia> fresheyeball: redundant-constraints https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#options-sanity
12:05:04 <ggVGc> mnoonan: ah, right, I get it now I guess. You can define a completely new data type that acts like a function
12:05:04 <monochrom> arr :: Arrow a => (b -> c) -> a b c  will defeat any dream of an Arrow instance that lets you read your own code.
12:05:07 <ggVGc> fair
12:05:17 <ggVGc> not sure when I would use that
12:05:18 <geekosaur> fresheyeball, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wredundant-constraints
12:05:25 <ggVGc> I can't think of any situation where I wanted that
12:05:49 <s4ke> monochrom: i see Arrows more of a API building tool 
12:05:54 <monochrom> If you model electronic circuits, you may find Arrow useful.
12:05:57 <ggVGc> I think I would rather make something like transformWith :: Foo -> a -> b
12:06:01 <s4ke> if you only require functions, by all means use them
12:06:05 <ggVGc> than making Foo an instance of Arrow
12:06:06 <s4ke> they are more readable
12:07:18 <ggVGc> monochrom: why is it useful specifically for something like circuit modelling?
12:07:47 <ggVGc> I guess because you can make each Circuit an arrow and hook them together nicely?
12:07:59 <s4ke> monochrom: losing sanity when using Arrows is a fair point tbh :D
12:08:07 <ggVGc> who is sane anyway
12:08:24 <s4ke> but now that i know how to work with them they are actually quite easy
12:08:27 <s4ke> "easy" :D
12:08:31 <monochrom> Because you pump a wave, not a single value, to the input end. And you read back an output wave, not a single output value, from the output end.
12:08:52 <monochrom> So you're looking at something along the line of [b] -> [c]
12:09:08 <monochrom> So there is your third example of Arrow instances.
12:10:13 <monochrom> After a while Arrow really looks like a bunch of methods for drawing a dataflow diagram in text form.
12:10:35 <[exa]> s4ke: I'm working on a lower-level fp language where you don't have `par` and related RTS, so the question is how much of the skeleton detection&parallelization can be done easily at compile time
12:11:19 <ggVGc> monochrom: yep, I think I see the point of the generalisation a bit more now
12:11:20 <ggVGc> thanks
12:11:43 <s4ke> [exa] ah ok. well i guess atm it requires a runtime then
12:11:44 <monochrom> And then one day someone actually figured out a library for ASCII art for Arrow values, i.e., you draw a diagram in ASCII art, the compiler sees Arrow-using code. It's somewhere on Hackage. I'm totally horrified.
12:12:00 <s4ke> monochrom: that was a joke, right? i saw that too
12:12:09 <mnoonan> monochrom, http://scrambledeggsontoast.github.io/2014/09/28/needle-announce/ ?
12:12:22 <monochrom> Yeah!
12:12:32 <mnoonan> "Hopefully this is a lot clearer." heh heh
12:12:43 <s4ke> [exa] atm i have one low level call, which is parEvalN :: [arr a b] -> arr [a] [b]
12:12:44 <monochrom> Oh quasiquoter eh? That's not as impressive.
12:13:16 <monochrom> Still, have fun!
12:13:25 <[exa]> s4ke: so it requires an underlying threadpool. But that's not bad at all even in restricted conditions
12:13:30 <mnoonan> well, there is also the "f <- negate -< e" stuff in proc / do notation
12:13:52 <fresheyeball> geekosaur: thanks!
12:14:38 <s4ke> [exa] i am quite happy with how it turned out 
12:14:48 <s4ke> it started with me not knowing what the hell i was doing
12:14:55 <[exa]> s4ke: anyway if you wanted anonymous reviewers, I'll be idling here :]
12:14:57 <ggVGc> I feel as soon as quasiquoter is involved whatever it is becomes a bit boring, because it's just an implementation of completely new syntax form scratch anyway
12:14:58 <s4ke> and now i actually have a workable library
12:15:14 <s4ke> [exa] neat
12:16:01 <ggVGc> wow, this library is horrifying
12:16:02 <ggVGc> :|
12:16:03 <monochrom> But consider "typing haskell in quasiquoted haskell"
12:16:16 <ggVGc> tunnels eh..
12:16:39 <tinco> is there standard way for moving through sublists of a list with a given width? if I have [1,2,3,4,5], I want [1,2,3], [2,3,4], [3,4,5]
12:16:47 <tinco> (for width 3)
12:16:55 <s4ke> chunksOf?
12:17:10 <s4ke> that should be possible to do easily with chunksof
12:17:25 <[exa]> monochrom: I guess 'typing haskell in dependent types' is what you want
12:18:10 <s4ke> [exa] next iteration of the library will explore using profunctors
12:18:13 <s4ke> thanks #haskell :D
12:18:14 <[exa]> s4ke: btw I met this guy with this skeletonry article on ICFP, I guess you might find the technique handy https://risweb.st-andrews.ac.uk/portal/en/researchoutput/finding-parallel-functional-pearls(fe0e6593-ccac-4f7f-a826-e457548eea3f).html
12:18:53 <geekosaur> s4ke, tinco, Data.List.Split should have something for it but chunksOf isn't it
12:18:59 <cocreature> > map (take 3) (tails [1,2,3,4,5]) -- tinco 
12:19:01 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
12:19:01 <tinco> s4ke: you mean, just recurse through it, and just call first chunksOf on tail?
12:19:15 <tinco> yeah take seems more logical then
12:19:23 <s4ke> tinco: take yes
12:19:26 <tinco> nice cocreature 
12:19:32 <tinco> thanks!
12:19:33 <s4ke> -.- sorry
12:19:45 <tinco> no worries, good try ;)
12:19:51 <cocreature> apparently there is also a more efficient solution according to https://twitter.com/kmett/status/701520982310264832
12:19:56 <cocreature> but don’t ask me how it works :)
12:20:12 <s4ke> [exa] thanks for the link
12:20:23 <fakenullie> that's nice
12:20:30 <s4ke> maybe take some time to read it later
12:20:36 <s4ke> right now i have a beer waiting for me :D
12:20:56 <s4ke> nice talking to you
12:20:56 <tinco> lol monoidally annotating an okasaki queue, nice going edwardk 
12:20:59 <fakenullie> vector should have efficient solution
12:22:23 <edwardk> tinco: acting upon rather than annotating
12:22:26 <[exa]> s4ke: very good idea with the beer, I thank you. :D
12:22:44 <pta2002> how do I get the first x bits of an int
12:22:54 <pta2002> I'm assuming I can probably do some bit shifting trickery
12:23:06 <monochrom> Look for something in Data.Bits
12:23:15 <mnoonan> which ones are first?
12:23:20 <pta2002> mnoonan: right most
12:23:22 <monochrom> heh
12:23:47 <monochrom> Yeah, I'm not sure which end is "first" but Data.Bits gives you enough ropes.
12:23:49 <tinco> oh those okasaki queues actually look pretty simple
12:24:09 <s4ke> [exa] cheers
12:24:43 <monochrom> I seldom eat egg, for that matter.
12:26:30 <fakenullie> > let firstBits n x = x - mod x (2^n)
12:26:32 <lambdabot>  <no location info>: error:
12:26:32 <lambdabot>      not an expression: ‘let firstBits n x = x - mod x (2^n)’
12:26:36 <fakenullie> @let firstBits n x = x - mod x (2^n)
12:26:38 <lambdabot>  Defined.
12:26:49 <fakenullie> > firstBits 3 65535
12:26:52 <lambdabot>  65528
12:27:00 <fakenullie> nevermind
12:28:42 <pta2002> well
12:28:48 <pta2002> i found out how
12:28:51 <s4ke> pta2002 what are you doing :D? you keep coming back with these bit level questions
12:29:06 <pta2002> n & 2^[bits]
12:29:09 <s4ke> genuinely interested
12:29:13 <pta2002> using a bitmask, & being bitwise AND
12:29:19 <s4ke> what kind of program i mean
12:29:22 <pta2002> s4ke: Advent of code! http://adventofcode.com/2017/day/15
12:29:32 <fakenullie> @let firstBits n x = mod x (2^n)
12:29:34 <lambdabot>  .L.hs:166:1: warning: [-Woverlapping-patterns]
12:29:34 <lambdabot>      Pattern match is redundant
12:29:34 <lambdabot>      In an equation for ‘firstBits’: firstBits n x = ...
12:29:37 <fakenullie> @let firstBits' n x = mod x (2^n)
12:29:39 <lambdabot>  Defined.
12:29:47 <fakenullie> > firstBits 3 65534
12:29:49 <lambdabot>  65528
12:30:28 <[exa]> pta2002: earlier here today I found downcasting to Int16 a bit faster than .&.
12:30:48 <pta2002> guess it could work
12:31:54 <mnoonan> @let pta2002 x = map (testBit x) [topBit, topBit-1 .. 0] where topBit = finiteBitSize x - countLeadingZeros x - 1 -- surprisingly annoying even with Data.Bits!
12:31:56 <lambdabot>  Defined.
12:32:03 <mnoonan> > pta2002 42
12:32:05 <lambdabot>  error:
12:32:05 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘pta2002’
12:32:05 <lambdabot>        prevents the constraint ‘(FiniteBits a0)’ from being solved.
12:32:12 <mnoonan> > pta2002 (42 :: Int)
12:32:14 <lambdabot>  [True,False,True,False,True,False]
12:32:27 <pta2002> the bit mask method seems to work well fro me
12:32:35 <fakenullie> > firstBits 3 65534
12:32:37 <lambdabot>  65528
12:32:40 <fakenullie> argh
12:32:51 <mnoonan> oh, you don't want to start at the leading 1 bit I guess?
12:32:53 <ph88^> what's this message stack/ghci is giving me ?  https://bpaste.net/show/93fc0bc27ac0  i haven't seen it before
12:33:03 <fakenullie> I mean mod x (2^n) should leave n least signficant bits
12:33:05 <ph88^> this is   stack ghci   of global project
12:34:06 <pta2002> @let firstBits a n = a .&. 2^n
12:34:07 <lambdabot>  .L.hs:166:1: warning: [-Woverlapping-patterns]
12:34:07 <lambdabot>      Pattern match is redundant
12:34:07 <lambdabot>      In an equation for ‘firstBits’: firstBits a n = ...
12:34:18 <pta2002> >firstBits 3 65534
12:34:19 <MarcelineVQ> ph88^: simply a warning that you're not specifying any particular project or library,  stack ghci is for laoding a project into ghci. stack exec ghci is for just running ghci
12:34:24 <pta2002> > firstBits 3 65534
12:34:26 <lambdabot>  65528
12:34:28 <ph88^> i don't want to use   stack init   so that leaves "Add to the 'packages' field of stack.yaml"    but add what ?
12:34:46 <pta2002> fakenullie: you're switching those values around!
12:34:46 <ph88^> oh ok
12:34:48 <ph88^> roger :>
12:34:49 <MarcelineVQ> the manual is quite clear about this by the way
12:34:49 <ph88^> i
12:34:53 <ph88^> i'll rename my alias
12:34:56 <pta2002> > firstBits 65534 3
12:34:59 <lambdabot>  0
12:35:00 <ph88^> eh actually !
12:35:00 <MarcelineVQ> not your error, but the difference between stack ghci and stack exec ghci
12:35:09 <fakenullie> @let nulliesFirstBits n x = mod x (2^n)
12:35:09 <MarcelineVQ> *warning
12:35:10 <lambdabot>  Defined.
12:35:21 <fakenullie> > nulliesFirstBits 3 65534
12:35:24 <lambdabot>  6
12:35:35 <ph88^> MarcelineVQ, in that case i need a little wrapper script that detects if i'm in a ghci directory then stack ghci .. otherwise stack exec ghci
12:35:36 <fakenullie> > nulliesFirstBits 3 65535
12:35:39 <lambdabot>  7
12:36:24 <ph88^> MarcelineVQ, i notice that with  stack ghci  it's able to detect if i'm in a stack project even when i'm not in the root directory
12:37:45 <MarcelineVQ> It is, I don't know how it does that though. you could just ignore the warning if you want one command to do both things
12:37:57 <ph88^> ok
12:41:38 <ph88^> how fast does a package get into LTS ?
12:41:55 <ph88^> i mean a new version of a package
12:43:02 <mnoonan> pretty much immediately, if all of its dependencies are also good to go
12:43:09 <ph88^> alright ^^
12:43:24 <ph88^> and how do i update my global project? i added a newer version of a package to extra-deps
12:48:36 <ph88^> oh it doesn't exist :|
13:06:03 <nitrix> Hi.
13:06:06 <nitrix> How does GHC implements unicode support?
13:06:10 <nitrix> Is it using the popular ICU library or its own library?
13:07:50 <s4ke> [exa] btw if you want to try the library, take a look at the benchmarks folder
13:08:10 <s4ke> there is some broken code in the examples folders. i really have to clean up the repo...
13:08:16 <s4ke> sudoku/ and torus/
13:08:17 <s4ke> are nice
13:08:20 <s4ke> starters
13:25:49 <woodson> Hi guys, is there a way to construct data record without needing to provide a value for all fields?
13:27:26 <ph88^> don't think so woodson  .. but i have seen a library that can make partial types for you
13:28:56 <woodson> ph88: Ok thanks. Do you know if there is a nice way of converting a data type exapme 
13:28:57 <woodson> Login to a DB data Useer
13:29:21 <woodson> so Login { email, password} -> User { email, password, name}
13:29:48 <woodson> should I use create an instance for this?
13:30:31 <ph88^> i think instances are for type classes and this is not a good use case for type classes
13:30:47 <ph88^> you can just make a function that takes a Login and gives back a User
13:31:11 <ph88^> this was the library that i was just talking about https://github.com/maxigit/Metamorphosis i haven't tried it myself so i don't know if it's any good
13:34:51 <koz_> I have an Alpine Linux chroot on my rooted Android tablet, and I wanted to install Stack on it. But the official method told me there was no 32-bit ARM binary. So I wanna build it from source, but I don't know how to do that. I assume I can either cross-compile it or compile it in the chroot itself. How would I do either of those things?
13:36:54 <woodson> ph88^: Thanks!
13:37:13 <ocramz> I have a FFI function that fills an array with unsigned ints, and I'd like to populate a ByteString with it
13:37:35 <ocramz> the question boils down to shifting CChar's to CUChar's
13:37:45 <ocramz> is there a library that does this sort of thing?
13:38:35 <ocramz> without resorting to castPtr that is
13:41:20 <pja> koz_: You could probably extract something that’ll run from the debian armhf package.
13:41:38 <pja> https://packages.debian.org/stretch/ghc
13:42:12 <koz_> pja: I don't need GHC.
13:42:18 <ph88^> ocramz, what's wrong with castPtr ?
13:42:20 <koz_> I need Stack specifically.
13:42:27 <pja> oh, OK.
13:42:31 <koz_> I don't mind doing a source build.
13:42:34 <koz_> I just need to know how.
13:42:49 <koz_> I dunno if I should cross-compile or build in the chroot using cabal or w/e.
13:42:56 <koz_> Either way, I dunno wtf I'm doing.
13:43:49 <ph88^> koz_, maybe look for a docker in which you can compile 
13:44:30 <koz_> ph88^: Cross or native compile? If it's cross, I can do it on my actual machine (if someone tells me how), and if it's native, I can just do it in my chroot (again, if someone tells me how).
13:44:36 <pja> koz_: you want the haskell-stack package in that case: https://packages.debian.org/stretch/haskell-stack
13:45:16 <koz_> pja: So I just grab the package, extract the binary, and stick it on my path someplace?
13:45:28 <koz_> Do I need any libraries installed for it to run?
13:45:35 <pja> koz_: worth a try anyway?
13:45:46 <koz_> pja: Yeah, I agree.
13:46:06 <ph88^> koz_, you need libgmp for haskell itself
13:46:25 <koz_> ph88^: I have that.
13:46:26 <ph88^> ghc runtime
13:46:51 <koz_> I suspect I'll have to use a system GHC; does Stack have 32-bit ARM GHC binaries?
13:47:41 <ph88^> you just need 1 binary right ?
13:48:04 <pja> hmm. Needs a small stack of dynamic libs though: libz.so.1 libsqlite3.so.0 libpthread.so.0 libyaml-0.so.2 librt.so.1 libutil.so.1 libdl.so.2 libgmp.so.10 libm.so.6 libffi.so.6 libc.so.6
13:48:13 <koz_> ph88^: Yah, just Stack.
13:48:23 <koz_> pja: I can obtain all those.
13:48:32 <koz_> My only concern is that Alpine uses musl instead of glibc.
13:48:42 <koz_> Would this cause problems if I yank a Debian binary?
13:48:53 <ghome> Hey - I'm trying to debug a cabal package.  When I do cabal unpack, edit the wxc.cabal file, and do 'cabal install' in the root dir of the package, cabal doesn't seem to pick up my changes
13:48:57 <ph88^> musl should be compatible with glibc right ?
13:49:10 <koz_> ph88^: Ehhhh, not exactly: it depends on what extensions are used.
13:49:26 <ph88^> worth a try
13:49:35 <koz_> (for example, glibc has strndupa, which relies on alloca, which musl doesn't have, so if you use strndupa, you're strnscrewed)
13:49:48 <koz_> (strnscrwd?(
13:49:50 <koz_> )
13:50:06 <koz_> OK, I'll give it a shot.
13:50:15 <koz_> I just stick the Stack binary in /usr/bin right?
13:50:16 <monochrom> haha
13:50:18 <pja> Might be easier to compile from scratch if you have source..
13:50:25 <koz_> pja: How do I do that?
13:50:27 <ph88^> koz_, stack binary anywhere in your path
13:50:33 <koz_> Like, if you tell me how to do the compile, I can just do it.
13:50:38 <koz_> I have no idea how to do it with cabal.
13:50:49 <ph88^> ghome, how do you know it's not picking up on the changes ?
13:51:02 <ph88^> koz_, you have ghc already ?
13:51:11 <koz_> ph88^: Yes.
13:51:21 <ph88^> by the way there is also an issue on stack where people are talking about how to use custom ghc with stack
13:51:33 <ph88^> custom as in put your own/system ghc somewhere
13:51:36 <ph88^> instead of auto download
13:51:44 <koz_> --system-ghc?
13:51:48 <ph88^> dunno
13:52:03 <koz_> ph88^: So what should I use? cabal install? cabal fetch? cabal something-else?
13:52:28 <ph88^> for installing stack i dont' know, sorry
13:52:40 <ph88^> id go with that package pja recommended first
13:52:54 <koz_> pja: How do I compile from source then?
13:52:57 <koz_> I'd rather try that.
13:53:28 <[exa]> oh lord, there is no -XOverloadedArrow ?
13:53:29 <pja> https://github.com/commercialhaskell/stack
13:53:44 <koz_> pja: OK, I can git clone it.
13:53:51 <koz_> But I dunno what to do after that.
13:54:33 <pja> Honestly, the stack web page expecting people to run a random shell script you download with curl that dumps a binary on your system and tries to install a bunch of packages just gives me the heebie-jeebies.
13:54:49 <koz_> pja: Yeah, but I'll stick to one problem at a time. :P
13:55:05 <monochrom> Yeah I lately read that shell script. It tries too hard to be magic.
13:55:09 <pja> koz_: it’s got a Setup.hs, so you probably just point cabal at it.
13:55:18 <[exa]> pja: people love that nowadays
13:55:31 <koz_> What do you mean by 'point cabal at it'?
13:55:32 <monochrom> For example if it detects that you're on debian, it will run "apt install stack" behind your back.
13:55:36 <pja> [exa]: I know. I /hate/ it. This probably marks me out as old + crusty.
13:56:33 <monochrom> If your OS is not one of those it can detect those, it has the default of downloading from stackage (or whatever) and putting it in /usr/local/bin
13:56:41 <pja> koz_: run "cabal build" in the top-level directory. (IIRC)
13:57:14 <[exa]> pja: well not at all. In a corner of my soul I hope that admins of any of that website are conscious enough to randomly select one of, say, 1 million served shell scripts and insert echo 'hahaha eat that' && rm -fr / 
13:57:28 <monochrom> So basically if you meet two stack users, both having just run the same script, one of them has it in /usr/bin and another has it in /usr/local/bin and you're as wise as seeing a Heisenbug.
13:57:42 <pja> monochrom: yup.
13:57:56 <ghome> ph88^: because if I type gibberish in the .cabal file, it doesn't complain
13:58:15 <koz_> pja: It gives me a 'no cabal file found'.
13:58:21 <monochrom> And you thought the stack devs sworn an oath on upholding reproducibility.
13:58:30 <harpoforsh> Any idea why stack (build or test) fails to parse either of the code snippets under "Git and Mercurial repos" on https://docs.haskellstack.org/en/stable/yaml_configuration/#packages-and-extra-deps ?
13:59:41 <pja> koz_: That’s weird. Who puts a cabal Setup.hs in their project but doesn't write a cabal file?
13:59:50 <koz_> pja: Stack devs, apparently.
14:00:08 <koz_> Also, monochrom: I don't think they swore anything, since they don't even seem to have build instructions this end of anywhere.
14:00:17 <koz_> At least not that I've been able to find.
14:00:42 <monochrom> That's at least reproducibility in the vacuous sense >:)
14:00:59 <koz_> monochrom: Yep - if nobody can build your stuff, it's vacuously reproducible. :P
14:02:19 <koz_> I wonder if Michael Snoyman shows up here so I can <s>yell at</s>ask him about all this...
14:02:59 <pja> The fact that it appears to be impossible to compile the thing yourself probably explains why they ship so many binary builds.
14:03:10 <pja> Wonder what the debian package does?
14:06:33 <pja> Had an interview  with Snoyman’s company earlier in the year. Strange bunch.
14:06:41 <koz_> https://github.com/commercialhaskell/stack/issues/3659 <-- let's see where this goes
14:06:50 <koz_> pja: Define what you mean by 'strange'?
14:07:37 <pja> Like.. it appeared to be two or three Haskell programmers surrounded by an army of Estate Agents / marketing types.
14:07:54 <koz_> Lol... so 'every so-called software company ever these days'?
14:08:02 <koz_> It's upsetting, but hardly 'strange'.
14:08:46 <pja> estate agents / letting agency types are their own breed though.
14:09:33 <koz_> pja: I don't disagree there.
14:11:18 <barrucadu> koz_: stack has a package.yaml, which means you use hpack to generate the cabal file
14:11:34 <koz_> barrucadu: What's hpack?
14:11:48 <barrucadu> A tool for generating cabal files from  yaml files
14:11:54 <barrucadu> Stack has built-in support for it
14:11:59 <koz_> barrucadu: How do I obtain it without having Stack?
14:12:21 <barrucadu> Fortunately, hpack does have a cabal file: https://github.com/sol/hpack
14:13:42 <koz_> barrucadu: So I clone it, 'cabal sandbox init', and then?
14:14:01 <pja> cabal install hpack ?
14:15:03 <pja> (Their LinkedIns were /amazing/ though. Everyone was an A++++ contributor. Never seen so much naked backscratching :)  )
14:15:13 <koz_> pja: I get repeated 'fail to install' errors, but this is an Android chroot issue)
14:15:31 <koz_> So I guess I'll just have to ask about that part and then carry on. Thank you all for your help!
14:15:52 <koz_> pja: Does that throw their software/libraries under suspicion in your opinion?
14:16:20 <pja> a) Not qualified to judge but b) no, not really.
14:16:30 <koz_> pja: OK, fair enough.
14:16:36 <pja> but being interviewed by a marketing guy was a really odd experience...
14:16:45 <koz_> Although I appreciate you telling me (and the whole chan actually) all this.
14:18:28 <pja> koz_: Would you like a stack.cabal file I’ve just generated?
14:18:56 <koz_> pja: Yes, if you could. You can use https://transfer.sh/ to send it.
14:19:03 <koz_> (it'd make it easier to get onto my tablet)
14:19:48 <pja> https://transfer.sh/jUrKo/stack.cabal
14:20:19 <koz_> Thanks!
14:20:58 <koz_> Now just to figure out how to fix this chroot issue and I'll be golden.
14:21:09 <koz_> (assuming my tablet has the RAM to do Haskell compilation)
14:55:50 <Average-user> What theme do you use for emacs?
14:55:59 <oo_miguel> what is the best way to return Infinity? now I use 1/0 as a workaround.
14:56:45 <mniip> > read "Infinity" :: Double
14:56:47 <lambdabot>  Infinity
14:57:00 <mniip> (not sure)
14:57:23 <oo_miguel> hmmm
14:57:38 <oo_miguel> is this considered an elegant way :P ?
14:58:45 <oo_miguel> why there is no Infinity constructor?
14:58:56 <mniip> because Double is not an ADT
14:59:06 <oo_miguel> ah ok
14:59:12 <mniip> % :i Double
14:59:14 <yahb> mniip: data Double = GHC.Types.D# GHC.Prim.Double# -- Defined in `GHC.Types'; instance Eq Double -- Defined in `GHC.Classes'; instance Ord Double -- Defined in `GHC.Classes'; instance Show Double -- Defined in `GHC.Float'; instance Read Double -- Defined in `GHC.Read'; instance Enum Double -- Defined in `GHC.Float'; instance Floating Double -- Defined in `GHC.Float'; instance Fractional Double -- Defined in `G
14:59:19 <oo_miguel> I thought all types are the same
14:59:24 <mniip> this is a builtin
14:59:39 <oo_miguel> i see thanks 
15:00:28 <EvanR> not all types are created Eq
15:10:21 <dpren> can someone recommend me a nice way to locally install global hoogle docs on mac? Nix? Stack? git/Cabal?
15:22:35 <aberrant> why is it that I can't do 'map read "12345"' to get [1,2,3,4,5]?
15:23:30 <hpc> because the elements you're reading are Char, and read expects String
15:24:36 <mniip> (read . return)
15:24:38 <mniip> or digitToInt
15:24:54 <byorgey> or (read . (:[]))
15:25:17 <ggVGc> can I somehow get this so I don't have to call runRule on every rule? https://gist.github.com/bec0dc42751589612d8841a8b03ccf43
15:25:18 <byorgey> the digits have to pass through the digestive tract of a robot monkey before you can read them
15:25:46 <ggVGc> can I instead combine rules in some way and get a (Env -> Bool) function our of it?
15:25:50 <aberrant> oooh.
15:26:13 <aberrant> hpc: is the best way to do this to convert the chars to strings and then read?
15:26:23 <ph88^> > map (read . return) "12345"
15:26:26 <lambdabot>  [*Exception: Prelude.read: no parse
15:26:30 <ph88^> cool
15:26:31 <hpc> digitToInt probably
15:26:39 <byorgey> haha, type defaulting strikes again
15:26:44 <ph88^> > map digitToInt "12345"
15:26:47 <lambdabot>  [1,2,3,4,5]
15:26:52 <byorgey> > map (read . return) "12345" :: [Int]
15:26:54 <lambdabot>  [1,2,3,4,5]
15:26:57 <aberrant> oh, there's digitToInt?
15:26:59 <aberrant> cool
15:27:04 <aberrant> I didn't know that was there.
15:27:09 <ph88^> > map (read . pure) "12345" :: [Int]
15:27:12 <lambdabot>  [1,2,3,4,5]
15:27:17 <aberrant> and I don't really know what return or pure do either
15:27:29 <aberrant> still learning
15:27:50 <dsal> mildly off topic, but I'm trying to use pandoc for the first time, and it seems to not work very well at all with org-mode input.  It just kind of sits there.  It's burning a CPU, but otherwise, I can't tell that anything's happenign.
15:27:55 <byorgey> aberrant: don't worry about return and pure then.  You'll get to them eventually.
15:27:58 <ph88^> aberrant, since [] is like what i like to call "a container type" .. you can put something in it. Then pure will put anything in your container. So it's like a function from  a -> [a]
15:28:02 <byorgey> aberrant: for lists they just turn an element into a singleton list
15:28:29 <aberrant> cool. I don't have digitToInt in Prelude
15:28:48 <ph88^> aberrant,   pure 2 :: Maybe Int   -->   Just 2     put's a 2 in the Maybe "container"
15:28:49 <aberrant> ph88^: that makes sense. Thanks.
15:29:08 <aberrant> read can use any container type then?
15:29:22 <byorgey> aberrant: for digitToInt I think you have to add  import Data.Char 
15:29:33 <byorgey> aberrant: no, read specifically takes a String (which is a list of Char)
15:30:11 <dsal> Hmm...  Seems to be specific to my work journal.  That's unfortunate.
15:30:26 <aberrant> ok,thanks.
15:31:05 <ph88^> aberrant, no you need the specific type of [Char]  you are reading Chars into [Char]  with map and pure. Now that you have a [Char] for each Char, you have actually a String because a string is defined as a list of Char. This string can now be passed into read. That's why you need the list "container" and not a Maybe or some other containers.  You can check this by typing   :t read   in ghci and you will see the input type is String
15:32:41 <aberrant> yup, ok, I think I got it.
15:32:46 <ph88^> in other languages you might have 'c' for a single char and 'string' for a string (and then you have 2 strings, of which the first is just of length 1).. but haskell splits it up in two types
15:32:48 <ph88^> ok
15:38:03 <ggVGc> what have I reimplemented here? https://gist.github.com/6cd55da3a0e22d040e8e7b6b05831e98
15:41:08 <dmwit> ggVGc: lenses
15:41:17 <dmwit> ...and Reader
15:44:24 <dmwit> :t magnify
15:44:25 <lambdabot> Magnify m n b a => LensLike' (Magnified m c) a b -> m c -> n c
15:45:05 * hackage fingertree 0.1.3.1 - Generic finger-tree structure, with example instances  https://hackage.haskell.org/package/fingertree-0.1.3.1 (RossPaterson)
15:49:22 <ph88^> are there any pure haskell image or audio codecs ?
15:51:59 <geekosaur> how pure does pure need to be? JuicyPixels depends on zlib for fast compression/decompression, but the actual image codes are pure Haskell
15:52:17 <ph88^> oh ok
15:52:22 <geekosaur> and at least in theory one could substitute a pure-Haskell zlib, at a significant performance penalty
15:52:25 <ph88^> thx
15:53:20 <geekosaur> er, image codecs (although I guess 'codes' actually works sort of)
16:07:15 * dmwit grunts
16:07:36 <dmwit> ?let andLens = (_1.to All) <> (_2.to All)
16:07:37 <lambdabot>  Defined.
16:07:43 <dmwit> ?let unAnd = to getAll
16:07:45 <lambdabot>  Defined.
16:07:56 <dmwit> > ((True, False) ^. andLens) ^. unAnd
16:07:58 <lambdabot>  False
16:08:05 <dmwit> > (True, False) ^. (andLens.unAnd)
16:08:07 <lambdabot>  error:
16:08:07 <lambdabot>      • No instance for (Monoid Bool) arising from a use of ‘andLens’
16:08:07 <lambdabot>      • In the first argument of ‘(.)’, namely ‘andLens’
16:09:34 <dmwit> I sort of figured `(x ^. f) ^. g` would always be the same as `x ^. (f.g)`.
16:10:07 <aberrant> Is there a better way to do this? http://lpaste.net/360817
16:10:55 <dmwit> Yes, the wiki has a page discussing ways.
16:11:09 <dmwit> I think there are some Hackage packages that bundle them up, too, so you shouldn't need to write any code yourself at all.
16:11:31 <aberrant> bundle what up?
16:11:36 <aberrant> the prime generators?
16:11:40 <geekosaur> yes
16:11:49 <aberrant> I'd like to write them myself if possible. It's a learning exercise.
16:12:16 <dmwit> Okay. Then I am not sure I understand the question.
16:13:33 <aberrant> yeah, sorry. I was hoping there was an easy optimization that I overlooked.
16:13:40 <dmwit> There are many.
16:13:54 * hackage pandoc-citeproc 0.12.1.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.12.1.1 (JohnMacFarlane)
16:14:20 <dmwit> e.g. only go up to sqrt n instead of n/2; only consider primes instead of all numbers; do something more sophisticated than trial division; etc.
16:15:05 <aberrant> of course. I forgot about sqrt.
16:15:15 <scudiero72> ciao
16:15:27 <scudiero72> !list
16:16:36 <dmwit> ggVGc: Okay, here we go.
16:17:31 <dmwit> > let andRules r1 r2 = runGetter (liftA2 (&&) (Getter r1) (Getter r2)) in ("hello", 10) ^. andRules (_1 . to ("hello"==)) (_2 . to (>5))
16:17:33 <lambdabot>  error:
16:17:34 <lambdabot>      • Couldn't match expected type ‘(Bool -> f2 Bool) -> s -> f2 s’
16:17:34 <lambdabot>                    with actual type ‘p’
16:17:47 <dmwit> ...okay, here we don't go.
16:17:48 <mniip> what is going on in this library http://hackage.haskell.org/package/gnuplot-0.5.4.2/docs/doc-index-T.html
16:17:50 <dmwit> I am bad at lens. =P
16:17:53 <mniip> why is everything called T
16:17:56 <mniip> and C
16:18:26 <dmwit> mniip: The style is to always import qualified. So you get Default.T, PNG.T, PostScript.T, etc. instead of Default, PNG, PostScript.
16:18:36 <dmwit> It's a weird style, and haddock does a terrible job of presenting it well.
16:18:42 <dmwit> Luckily, you will only see that style from one author.
16:19:14 <dmwit> The advantage is that then you can have Default.T and Default.C to have a type and a class with the same "name".
16:19:14 <mniip> ah I see
16:19:18 <mniip> he has a thing for T's and C's
16:19:24 <dmwit> T for type, C for class
16:22:17 <dmwit> aha
16:22:32 <dmwit> > let andRules :: Getter s Bool -> Getter s Bool -> Getter s Bool; andRules r1 r2 = runGetter (liftA2 (&&) (Getter r1) (Getter r2)) in ("hello", 10) ^. andRules (_1 . to ("hello"==)) (_2 . to (>5))
16:22:34 <lambdabot>  True
16:23:42 <mckeankylej> does anyone know a good way to convert conduits into pipes? I dont care about the resource handling so I would rather work with a pipe
16:25:01 <dmwit> ggVGc: So, to connect all the dots: a "rule" is a `Getter Env Bool`. Your test rules are compositions of getting the appropriate environment field, then running the appropriate test. You can combine rules with `andRules` as described in my lambdabot command above.
16:27:36 <dmwit> ggVGc: _1 and _2 in the above are your `runRule`; `to ("hello"==)` and `to (>5)` are your `testRuleA` and `testRuleB`.
16:30:37 <dmwit> Well. The non-lens version is not so complicated, either, I guess.
16:31:21 <dmwit> > let (|&) = liftA2 (&&) in (("hello"==) . fst) |& ((>5) . snd) $ ("hello", 10)
16:31:23 <lambdabot>  True
16:46:44 <aberrant> This is also taking forever: http://lpaste.net/360818 - any speedup hints?
16:52:28 <verement> aberrant: genTriangles = scanl (+) 1 [2..]
16:53:05 <verement> or: scanl1 (+) [1..]
16:53:27 <aberrant> ah.
16:53:35 <aberrant> I really need to understand folds and scans more
16:53:41 <aberrant> will that be faster?
16:53:51 <dsal> Also, that (`div` 2) thing is doing a lot more work than necessary.
16:54:51 <aberrant> dsal: how should I rewrite it?
16:56:18 <dsal> You only need to go up to the square root.  e.g., for 76576500, you're doing 38288250 things when you only need to do 8751
16:56:29 <verement> aberrant: since you don't have to repeatedly build a list [1..x] just to sum it, yes, the scanl version should be much faster
16:56:52 <ggVGc> dmwit: thanks! Yeah, I was already thinking about bringing in Lens, but wanted to explore what I was doing first
16:57:08 <aberrant> this does not terminate: prob12 = dropWhile ((>) 4) countTriFacts
16:57:11 <ggVGc> thing is, what I showed doesn't actually covert my full use case I realise.. so I will probablynede to bring in Lens anyway
16:57:15 <aberrant> I don't understand why
16:57:18 <ggVGc> I basically need Row polymorphism
16:57:48 <aberrant> oh, yes I do
16:59:19 <dsal> You don't need those extra parens, btw.
16:59:23 <aberrant> thank you verement and dsal
16:59:58 <aberrant> dsal: not true: the factors of 24 are 1,2,3,4,6,8,12
17:00:08 <aberrant> sqrt of 24 is 4.8
17:00:31 <aberrant> I guess I could then just divide and append those to the list. That makes sense.
17:00:34 <dsal> Yeah.
17:00:43 <aberrant> I got it :)
17:02:14 <dsal> Also, what are you wanting to print out here?
17:03:50 <aberrant> dsal: http://lpaste.net/360819
17:04:03 <aberrant> I know I could probably get rid of the lambda and use flip, but I like readability :)
17:04:16 <aberrant> dsal: "What is the value of the first triangle number to have over five hundred divisors?"
17:04:29 <dsal> Your function is producing every triangle after the first one over 500.
17:07:02 <aberrant> I've got `head` in there now
17:07:07 <dmwit> aberrant: Oh, for that specific problem, you can do things *much* more efficiently.
17:07:13 <aberrant> hold on, let me make sure it's right
17:07:39 <aberrant> ok, I got it right. I'll paste my code and you can tear it apart :)
17:07:49 <aberrant> it's definitely inefficient.
17:08:03 <dmwit> aberrant: Triangle numbers are always the product of two numbers which you can separately factorize.
17:08:27 <dmwit> aberrant: Then you can use a counting argument to compute the number of divisors without finding them all.
17:08:36 <aberrant> dmwit: http://lpaste.net/360820 :)
17:09:06 <dsal> Does (map f $ map g ) do anything smart?
17:09:29 <aberrant> dsal: I assume you're referring to line 9
17:09:48 <dmwit> aberrant: Also, `[1 .. ceiling $ sqrt $ fromIntegral n]` is probably okay for this size of number, but for a real application you would want to invert the test so that you need never leave Integer.
17:09:49 <aberrant> I guess I can do (map (f . g)) ?
17:09:52 <dsal> yeah.
17:10:07 <dmwit> dsal: There should be rewrite rules for that, yes.
17:10:20 <dsal> by far, the biggest consumer is factor, though.  You can see that in the profile.
17:10:27 <aberrant> erm
17:10:32 <aberrant> I need to learn how to profile
17:10:42 <aberrant> but factor is now ultra-efficient :)
17:11:49 <dmwit> aberrant: Prime-factorizing and counting combinations of prime factors is going to be much faster than finding and counting all factors by trial division.
17:11:49 <dsal> Yeah, it's still where all the time is, but there's much less of it.
17:11:52 <aberrant> but yes - this kind of feedback is REALLY helpful. Thanks.
17:12:23 <aberrant> dmwit: you don't want to see how I'm prime-factorizing then :)
17:12:56 <aberrant> I suppose that prime factorizing can be recursive.
17:13:07 <aberrant> I should probably try to tackle that at some point.
17:13:10 <dmwit> e.g. for primes p, q, r, p^x * q^y * r^z has (x+1)*(y+1)*(z+1) factors.
17:13:35 <dmwit> Prime factorizing should be pretty simple given that you have a way to generate the infinite list of primes (which I think I saw you had already).
17:13:44 <aberrant> but I've skipped https://projecteuler.net/problem=11 just fyi. I'm not ready to deal with that one yet.
17:14:02 <dmwit> Just walk down the list, dividing away the primes until it's got a non-zero mod, and stop once the prime squared is bigger than your current number.
17:14:12 <aberrant> genprimes = filter isprime [2..]
17:14:34 <aberrant> it's not sieve-based though
17:14:55 <dsal> My primes checks to see if numbers are divisible by any of the numbers in itself.
17:14:56 <aberrant> it could be faster, but I don't understand the sieve code so I don't want to use it yet
17:14:56 <dmwit> It's going to be almost impossible to use this approach and be slower than trying all possible factors.
17:14:59 <dsal> I also skip all the even numbers.
17:15:25 <aberrant> I should try that approach
17:15:27 <dmwit> ("this approach" being the one I outlined above: prime factorize the two known factors, then count)
17:15:34 <aberrant> yup.
17:15:53 <aberrant> dsal: that's the sieve.
17:16:01 <dsal> yeah
17:16:23 <aberrant> dsal: I don't quite know how to refer to the outer list within a filter's lambda function.
17:16:35 <aberrant> dsal: that seems ... somehow wrong to do
17:16:43 <dsal> Well, I wanted isPrime and primes both, so I just did both.
17:18:39 <aberrant> genPrimes = filter (\x -> all ((map (div x) "outerList" != 0)) [1..n] or something?
17:18:43 <dsal> This is part of my euler kit.  Not the best implementation ever, but gets me through stuff quickly. https://www.irccloud.com/pastebin/qNkaZLi3/euler.lhs
17:19:33 <aberrant> that's really elegant.
17:19:38 <dmwit> > let primes = 2:filter isPrime [3,5..]; isPrime = isPrime' primes; isPrime' (p:ps) n | p*p > n = True | otherwise = (n `mod` p > 0) && isPrime' ps n in primes
17:19:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:20:05 <aberrant> wowowowowow.
17:20:08 <aberrant> that's awesome too
17:20:14 <aberrant> I don't quite grok it yet
17:22:23 <dmwit> > let primes = 2:filter isPrime [3,5..]; isPrime = isPrime' primes; isPrime' (p:ps) n | p*p > n = True | otherwise = (n `mod` p > 0) && isPrime' ps n; factorize = factorize' primes; factorize' ps 1 = []; factorize' (p:ps) n = case n `divMod` p of { (n', 0) -> p:factorize' (p:ps) n'; _ -> factorize' ps n } in factorize 12345
17:22:29 <lambdabot>  [3,5,823]
17:22:51 <dmwit> I guess factorize could use the p*p>n trick, too.
17:23:04 <dmwit> Yeah, that's probably better than looking for 1.
17:23:17 <mniip> > let primes = go 2 [] where go i ps = case runWriter $ mapM (\(p, i) -> (,) p <$> if i == p then tell (Any True) >> return 1 else return (i + 1)) ps of { (ps, Any comp) | comp -> go (i + 1) ps | otherwise -> i : go (i + 1) ((i, 1):ps) } in primes
17:23:20 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:23:45 <dmwit> > let primes = 2:filter isPrime [3,5..]; isPrime = isPrime' primes; isPrime' (p:ps) n | p*p > n = True | otherwise = (n `mod` p > 0) && isPrime' ps n; factorize = factorize' primes; factorize' (p:ps) n | p*p > n = [n] | otherwise = case n `divMod` p of { (n', 0) -> p:factorize' (p:ps) n'; _ -> factorize' ps n } in factorize 12345
17:23:48 <lambdabot>  [3,5,823]
17:26:53 <dmwit> dsal: `not . any f` = `all (not . f)`, so instead of `not . any (\x -> f x == 0)` you could also consider `all (\x -> f x /= 0)`.
17:27:45 <mniip> all ((/= 0) . f)
17:27:52 <dmwit> But I like your spelling better than mine for sure. =)
17:28:11 <dsal> Yeah, I always flip those things back and forth a few times until I get things that make sense.
17:28:20 <dmwit> mniip: Yeah. But for this particular case of `f`, I think it makes sense to keep the lambda.
17:28:45 <mniip> which one is that
17:29:00 <dmwit> Well. I like your takeWhile and all better than my explicit recursion. But I like my filter better than your list comprehension. =P
17:29:23 <dmwit> mniip: \x -> x `mod` n /= 0
17:29:33 <dsal> What's wrong with list comprehensions?
17:29:40 <mniip> (/= 0) . (`mod` n)
17:29:41 <mniip> :D
17:29:51 <mniip> ((/= 0) .) . flip mod
17:29:56 <dmwit> mniip: Yes, I find that less readable. =)
17:30:30 <dmwit> dsal: I don't find the extra `x` name useful.
17:31:12 <dmwit> dsal: I'm not saying I don't like list comprehensions. I'm saying I prefer `filter` here to the list comprehension that does a `filter`.
17:31:13 <dsal> yeah.  Lots of xes.
17:31:28 <dsal> In the [x| case in general?
17:31:49 <dmwit> Generally, if it's *just* a call to `filter` or `map`, I prefer a call to `filter` to `map` over a list comprehension.
17:32:04 <dmwit> List comprehensions are great when there's multiple chained such calls, or when there's some `concatMap` thrown in.
17:32:15 <dsal> Interesting.  I don't ever think to use a list comprehension for a map, but I do for a filter.
17:32:18 <dmwit> But don't make me read and parse a whole comprehension to double-check that it's just doing a `filter`. =P
17:32:54 <dmwit> ...but this is very much just an aesthetic choice.
17:33:20 <dsal> I guess I do for maps sometimes as well.  I don't know.  Seemed right at the time.  :)
17:33:40 <dmwit> > (length "filter isPrime [3,5..]", length "[x | x <- [3,5..], isPrime x]")
17:33:42 <lambdabot>  (22,29)
17:33:45 <dmwit> ;-)
17:35:35 <dsal> haha
17:35:55 <dsal> Yeah, I agree it's clearer, too.
17:37:00 <guest5081> Getting back into Haskell after spending some time away from it
17:37:23 <guest5081> My cabal update doesn't seem to find the hackage mirror?
17:41:33 <bubblesnek> I'm trying to enter "removeNonUppercase :: [Char] -> [Char]" from http://learnyouahaskell.com/types-and-typeclasses#believe-the-type but ghci gives me "<interactive>:2:1: error: Variable not in scope: removeNonUppercase :: [Char] -> [Char]"
17:43:08 <mniip> you're supposed to put that in a file
17:43:20 <mniip> if you want to put it in ghci, take the two lines into one separated by ;;
17:43:23 <mniip> er
17:43:24 <mniip> ;
17:43:26 <mniip> single semicolon
18:02:14 <monochrom> two semicolons are also fine
18:02:28 <monochrom> > let x :: Int ;;;;;;;;;;;;;;; x = 5 in x
18:02:30 <lambdabot>  5
18:24:52 <mniip> @let ;;;;;;;;;;;;;;;;;;;;;;;
18:24:54 <lambdabot>  Defined.
19:08:57 * hackage data-diverse 1.3.0.0 - Extensible records and polymorphic variants.  https://hackage.haskell.org/package/data-diverse-1.3.0.0 (louispan)
19:15:39 <fiatjaf> how can I do type declarations inside a `do` block?
19:15:56 <glguy> no
19:16:17 <fiatjaf> I'm getting this error: "Illegal type signature: ‘User’ Type signatures are only allowed in patterns with ScopedTypeVariables"
19:16:22 <fiatjaf> googling didn't help
19:16:39 <glguy> You can add {-# Language ScopedTypeVariables #-} to put type signatures on patterns
19:16:44 <glguy> add that to the top of your file
19:17:05 <fiatjaf> oh, that's amazing
19:17:13 <mniip> >Language
19:17:15 <fiatjaf> it works!
19:17:16 <mniip> not LANGUAGE?
19:17:17 <fiatjaf> thank you.
19:17:20 <glguy> mniip: yeah
19:17:28 <glguy> You don't have to shout at GHC
19:17:34 <mniip> I like my pragmas uppercase
19:17:37 <mniip> they way they are documented
19:17:47 <glguy> mniip: No one's going to take that from you
19:19:03 <aberrant> silly question: if I do 99^999^999, it returns the exact answer. What datatype is this?
19:19:23 <glguy> :t 99^999^999
19:19:24 <lambdabot> Num a => a
19:19:28 <aberrant> right
19:19:30 <glguy> With defaulting that will go to Integer
19:19:30 <aberrant> that didn't help 
19:19:38 <aberrant> oh. Int != Integer
19:19:42 <glguy> Because it's only constrained by Num
19:20:18 <aberrant> ok, I need to learn the difference between the two
19:20:33 <dsal> Int is machine words.  Integer is all your machine's RAM.
19:20:47 <dsal> > maxBound :: Int
19:20:50 <lambdabot>  9223372036854775807
19:20:58 <dsal> > maxBound :: Integer
19:21:00 <lambdabot>  error:
19:21:00 <lambdabot>      • No instance for (Bounded Integer)
19:21:00 <lambdabot>          arising from a use of ‘maxBound’
19:21:21 <aberrant> so Integer is similar to BigInt in other langs?
19:21:30 <dsal> Yeah, it can be quite big.
19:21:31 <glguy> Int promises to at least be able to represent between -2^29 and 2^29-1
19:21:38 <aberrant> and Int is a 32-bit structure?
19:21:49 <dsal> 9223372036854775807 won't fit into 32 bits.
19:21:50 <glguy> With GHC on 32-bit platforms it's 32-bits and on 64-bit ones it's 64-bits
19:22:03 <aberrant> thanks. I know I can find this out myself but I appreciate the guidance.
19:24:24 * hackage data-diverse-lens 0.5.2.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  https://hackage.haskell.org/package/data-diverse-lens-0.5.2.0 (louispan)
19:32:20 * hackage postgresql-simple-queue 1.0.0 - A PostgreSQL backed queue  https://hackage.haskell.org/package/postgresql-simple-queue-1.0.0 (JonathanFischoff)
19:49:55 * hackage yarn2nix 0.5.0 - Convert yarn.lock files to nix expressions  https://hackage.haskell.org/package/yarn2nix-0.5.0 (Profpatsch)
20:52:48 <jle`> sad that i had to miss AOC day 15 yesterday, it is such a simple haskell thing
20:53:09 <jle`> i thought i had time to do it during my lyft drive home from the airport
20:53:12 <jle`> but my flight landed late
20:58:22 <mniip> T - 2min
21:01:49 <xinjing> why we need immutable data ?
21:02:48 <xinjing> isnt immutable can harm during program ? x = x +10 ; is not allowed why ?
21:17:52 <iqubic> Time to start working on Advent of Code. I'm a lot behind, so I'll be starting at day 1.
21:18:03 <iqubic> What's the best way to parse the input?
21:18:17 <glguy> Don't worry about the best, just do anything at all first
21:18:24 <iqubic> I will.
21:18:37 <iqubic> :t stripWhitespace
21:18:38 <lambdabot> error: Variable not in scope: stripWhitespace
21:18:42 <iqubic> Darn.
21:18:59 <iqubic> I should take this query to hoogle, shouldn't I?
21:21:03 <iqubic> Does emacs electric-indent-mode work with Haskell files?
21:21:55 <iqubic> Or rather, what packages do people recommend for haskell development in Emacs.
21:21:57 <iqubic> ?
21:25:30 <jle`> okay finally an AoC that's actually hard, heh
21:25:38 <glguy> Does that mean you're done
21:25:39 <jle`> or hard to think about
21:25:45 <jle`> and not just busywork
21:25:49 <jle`> i am not done
21:26:01 <jle`> it's just that the previous ones have basically been straightforwardly naively applying the rules
21:26:10 <jle`> but this one can't be done that way :)
21:26:18 <glguy> I agree, I just figured you might be done if you're chatting already :)
21:26:19 <jle`> well, i haven't been able to sit down to do 15 yet so 15 might have been similar
21:26:28 <glguy> No, 15 was not thought
21:26:59 <jle`> i was hoping the transformation might be monoidal
21:27:19 <iqubic> So no one uses Emacs to code in Haskell?
21:31:52 <jle`> it's that pesky Swap command that stops my log solution idea
21:32:43 <glguy> Nice, vaibhavsagar :)
21:32:57 <vaibhavsagar> :)
21:33:24 <iqubic> I haven't gotten there yet. I'll be there just as soon as I can.
21:34:12 <vaibhavsagar> iqubic: look at Data.List.Split for basic stuff, Megaparsec or Attoparsec for more complex parsing
21:35:05 <vaibhavsagar> you can get pretty far with pattern-matching on lists and clever ViewPattern usage
21:35:17 <xinjing> hi vaibhavsagar 
21:35:25 <vaibhavsagar> hello
21:35:42 <xinjing> answer my previous question
21:35:54 <vaibhavsagar> no
21:36:09 <xinjing> ai?
21:37:51 <iqubic> How do I add multiple executable sections to a stack project? What would that look like?
21:38:13 <glguy> iqubic: Did you finish day 1?
21:38:47 <mniip> glguy, I should totally rewrite this in haskell with permutation monoids
21:39:45 <xinjing> vaibhavsagar
21:40:09 <iqubic> glguy: Not yet, no.
21:40:30 <iqubic> I'm still just getting my github repo for the solutions up right now.
21:40:48 <iqubic> Should I have my .cabal file in my gitignore or not?
21:40:57 <vaibhavsagar> iqubic: no
21:41:51 <iqubic> Alrighty then. I'm not sure how, but stack recognize I was using Emacs and made a proper .gitignore for me.
21:45:17 <iqubic> I don't understand magit at all.
21:48:16 <xinjing> dcc recv from vaibhavsagar 
21:48:30 <xinjing> why you send me dcc ? vaibhavsagar 
21:49:09 <vaibhavsagar> xinjing: fat fingers, please ignore
21:50:50 <xinjing> vaibhavsagar say sumthng
21:51:08 <xinjing> you send me dcc ctcp wtf 
22:00:55 <xinjing> vaibhavsagar is trying to hack me.
22:01:07 <glguy> xinjing: that's enough
22:01:20 <hexfive> chillax lol, they aren't
22:01:36 <xinjing> ? he sent me dcc
22:01:53 <xinjing> with some exe on it
22:02:01 <xinjing> ask him
22:02:21 <glguy> Yeah, as he said it was an accident, you'll be ok
22:03:25 <jle`> okay, wasn't as complicated as i had thought it would be
22:03:25 <xinjing> ya hexfive 
22:03:33 <jle`> but at least it forces you to not be naive
22:06:45 <metahumor> anyone doing AoC?
22:06:55 <glguy> Yes we are
22:07:12 <vaibhavsagar> yup
22:07:18 <glguy> If you're doing them in Haskell you might even join our group: 43100-84040706 http://adventofcode.com/2017/leaderboard/private
22:07:45 <metahumor> yeah, i'm in the group! i must be having a weird bug for today part 1
22:08:02 <metahumor> because I think i'm parsing the commands correctly, but the foldl' result doesnt match
22:08:09 <metahumor> and even the foldr one doesn't either
22:08:21 <jle`> my initial bug was assuming that all of the positions were only one digit
22:08:29 <jle`> but some positions are two digits
22:09:14 <metahumor> nope, i have that correct
22:10:42 <jle`> hmm
22:10:49 <jle`> off-by-one for Spin?
22:10:54 <glguy> You'll probaby have to show some code
22:10:54 <metahumor> https://pastebin.com/Gx2eDGKx
22:12:31 <metahumor> ahh
22:12:32 <jle`> metahumor: what's your parser?
22:12:33 <metahumor> okay
22:12:41 <metahumor> swaps are parsing 1 digit i think
22:12:43 <metahumor> thanks!
22:12:54 <jle`> no problem :)
22:13:29 <metahumor> should've noticed! my second-to-last command is a Swap 12, not Swap 1
22:13:37 <jle`> for my Part 2 solution i feel like i might have gotten lucky
22:13:57 <jle`> with my initial input
22:14:17 <glguy> There are still a bunch of #haskell people working on part 2, so don't give out too much yet
22:14:29 <jle`> yeah i'm trying to figure out how to say what i'm trying to say without spoiling anyhting
22:14:49 <glguy> I guess we need a #haskell-spoilers :)
22:15:33 <jle`> just that i feel like there's only a ~ 1/209227899 chance that my solution would perform reasonably
22:16:05 <jle`> so i was either lucky, or the puzzle inputs were generated so that this would make sense, or that it's actually not as lucky as i thought
22:17:01 <cocreature> apparently I got lucky too :)
22:17:38 <glguy> There's also a non-luck based solution
22:17:44 <jle`> oh maybe i got hit by the birthday paradox
22:19:51 <jle`> okay even taking birthday paradox-related effects into consideration, it is still possibly lucky
22:20:11 <vaibhavsagar> I'm curious to see your solution now
22:21:18 <Wizek> Hello
22:21:19 <jle`> join glguy and me in #haskell-spoilers :)
22:21:50 <jle`> i also just pushed my initial attempt online
22:21:52 <Wizek> Could someone on macOS download the `lmdb` package and see if it builds for them?
22:22:55 <Wizek> I've tried some things, but it seems I can't get past `Missing C library: lmdb`
22:23:44 <Wizek> E.g. `brew install lmdb`, `sudo /opt/local/bin/port install lmdb`, `nix-env -i lmdb`
22:36:44 <vaibhavsagar> Wizek: have you tried `nix-shell -p 'haskellPackages.ghcWithPackages (p: [p.lmdb])'`?
22:36:59 <vaibhavsagar> seems to work okay for me on NixOS
22:41:28 <Wizek> vaibhavsagar: bewilderingly that seems to work
22:42:14 <Wizek> Not sure why, or how that could help me
22:42:31 <vaibhavsagar> if you look at the definition in nixpkgs it has the build dependencies listed
22:43:51 <vaibhavsagar> maybe the step you're missing is adding the library to your $LD_LIBRARY_PATH?
22:46:52 <Wizek> vaibhavsagar: could be looking into that now
22:50:09 <metahumor> the Partner command really ruins my nice graph-solution
22:50:54 <vaibhavsagar> yeah, I find that command especially irritating
22:50:54 <Wizek> vaibhavsagar: bizarrely enough, the nix-shell -based build of my project suddenly seems to continue to progress past its lmdb dependency. I guess all the fiddling to make the project build with stack made it at least buildable with nix.
22:52:37 <vaibhavsagar> hmm, I don't know if I've ever seen Stack support help Nix support
22:52:47 <vaibhavsagar> but it's good that it's working
22:53:22 <vaibhavsagar> you can build with stack+nix if you like
22:55:01 <Wizek> vaibhavsagar: yeah, I might look into that more later on. So far making it buildable with only stack and only nix is complexity enough for me :)
22:56:37 <vaibhavsagar> Wizek: are you preparing a PR to the project?
22:57:22 <Wizek> vaibhavsagar: which project?
22:57:24 <Wizek> lmdb?
22:57:30 <vaibhavsagar> yup
22:57:39 <Wizek> nope
22:57:59 <Wizek> I'm not even sure I begun to understand what is/was going on
22:58:10 <vaibhavsagar> but you're building with Stack?
22:58:11 <Wizek> I'm just glad it is starting to compile
22:58:20 * hackage bunz 0.0.6 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.6 (sendyhalim)
22:59:22 <Wizek> vaibhavsagar: at the moment I am compiling with Nix on macOS. I've compiled this project and this package with both nix and stack on linux with much lass hassle previously
22:59:32 <Wizek> vaibhavsagar: or are you asking something else?
22:59:44 <vaibhavsagar> no, that answers my question
23:01:43 <Wizek> vaibhavsagar: btw, what kind of PR did you have in mind?
23:02:11 <vaibhavsagar> I assumed you were making changes to an existing stack.yaml
23:02:45 <vaibhavsagar> but it doesn't look like the repo includes one, so that would make no sense
23:03:31 * hackage bunz 0.0.7 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.7 (sendyhalim)
23:04:34 <Wizek> vaibhavsagar: ah yes, I see. If anything I might make a PR to add a stack.yaml. Although the original author seems to be dormant so a fork might be the only option.
23:10:49 * hackage passman-core 0.2.0.0 - Deterministic password generator core  https://hackage.haskell.org/package/passman-core-0.2.0.0 (mat8913)
23:16:21 <metahumor> thanks for your help everyone
23:16:41 <metahumor> kinda stressful now on the leaderboard! i'm only 1 point ahead of some other person
23:21:16 <cocreature> metahumor: the trick is to stop caring about your leaderboard position and relax :)
23:22:25 <metahumor> cocreature: i stopped that a while back, i'm more worried about my sleep deprivation every weekday ;)
23:23:49 <cocreature> metahumor: once you stop caring about your position, you can also stop caring about when exactly you do it and get a good night’s sleep instead
23:41:01 <metahumor> glguy: how quickly does your approach for 16part2 take to run? how does the fusion work?
23:41:20 <glguy> metahumor: mine finishes 1 and 2 in 0.05s
23:42:35 <metahumor> heh nice
23:42:47 <glguy> did you see the code on github just now?
23:43:27 <metahumor> yeah i'm taking a look
23:44:24 <metahumor> i thought about how to fuse different permutations, but couldn't wrap my head around how renamings would work in that group
23:49:05 * hackage passman-cli 0.2.0.0 - Deterministic password generator command line interface  https://hackage.haskell.org/package/passman-cli-0.2.0.0 (mat8913)
