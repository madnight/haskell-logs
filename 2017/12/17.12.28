00:00:02 <osa1> I guess you can only use n+k pattern in a case expression because otherwise you end up re-defining (+)
00:01:49 <geekosaur> n+k works fine for foo (n+1) = ...
00:02:06 <geekosaur> well, aside from the problems n+k patterns have
00:02:33 <geekosaur> (hidden partiality)
00:29:00 <nschoe> Hi everyone (merry xmas!). Can you help me out? I have installed raspbian stretch on a raspberry pi 3 and have been running / compiling some Haskell program quite fine until now when I added `aeson` to my list of deps.
00:29:45 <nschoe> when I'm doing `cbala install aeson` in my cabal sandbox the pi runs foreve rand ends up crashing ; while monitoring memory usage with `htop`, it maxes out during the `building aeson...` process.
00:30:08 <nschoe> I tried running with `-j1 -O0`, but it still fails (the pi becomes unresponsive, I lose the SSH connection and have to hard reboot)
00:30:25 <kadoban> nschoe: How much memory does the machine have?
00:31:35 <nschoe> kadoban, 1G (htop registers 987M)
00:31:59 <nschoe> kadoban, during the build I see it maxes out, then the 100M swap gets filled too. Then it fluctuates around the 950M RAM mark and ends up crashing.
00:32:39 <kadoban> Hm, that doesn't sound like typically enough for GHC I don't think. I used to have a bit of trouble occasionally with like 2-3GB free.
00:32:50 <kadoban> I don't know if there's a way to work around that though.
00:33:05 <nschoe> A temporary solution would be to find a way to compile `aeson` on the pi (if you guys can save my life ^^), but a bette rsolution would be to set up a cross-compilation toolchain. But I have seen too many different, often outdated version (so maybe one of you know a how-to that is pretty recent?)
00:33:48 <nschoe> kadoban, well until here it was working (I'm compiling with `binary`, `bytstring`, `text`, `websockets`). ANd it was compiling fine, it did took some time, though, but it worked.
00:33:52 <nschoe> It's just `aeson` ^^
00:35:15 <kadoban> Only trick I know is compiling in a VM on a different machine that's set up like the target. Not sure that's going to be easy though in your case.
00:36:16 <nschoe> Yeah so I'd have to set up a VM to run a armv7 and install raspbian.
00:36:50 <MarcelineVQ> hitting a limit at 1G doesn't sound surpsiring for an aeson build.  nschoe have a look at https://medium.com/@zw3rk  for cross-compiler info courtesy of angerman
00:36:52 <nschoe> I started thinking about running QEMu on my laptop too, my I don't know that field enough: can I run the same image, with more memory?
00:38:00 <nschoe> MarcelineVQ, thanks for answering:) Yes I found these posts yesterday night, but I could not really find explanations for how to setup the x-compilation.
00:39:43 <MarcelineVQ> I see dang
00:40:18 <nschoe> ?
00:43:12 <MarcelineVQ> Don't know anything about it myself
00:43:19 <nschoe> erf okay
00:43:21 <nschoe> Thanks anyway.
00:43:35 <nschoe> I'll re-read all of anger man's posts, maybe I missed smth.
00:43:59 <nschoe> In the meantime, if anyone (or angerman himself ^^) has an idea, I'm taking it!
00:45:03 <angerman> nschoe: hackage.mobilehaskell.org
00:45:32 <angerman> nschoe: you are lucky if you can use the binary distributions.
00:46:45 <angerman> Im currently at an airport in HCMC, VN. Won’t be home for another 5hs. Earliest I could give some in depth answers is probably in 7hs. Or tomorrow SGT.
00:46:51 <nschoe> OMg hi angerman sorry for pinging I didn't mean too (didn't know your IRC name was actually 'angerman'). Thanks for the link!
00:47:28 <angerman> Well. I like consistent nick names.
00:47:40 <nschoe> angerman, okay well I'll stick around / come back tomorrow. I'll be reading your posts in the meantime.
00:48:00 <nschoe> angerman, I guess I'll have to try 'ghc-8.3.20171210-arm-linux-gnueabihf.tar.xz - Raspberry Pi cross compiler', right?
00:48:16 <angerman> Yep.
00:48:44 <angerman> You’ll need llvm5; the toolchain wrapper and build yourself a raspberry pi toolchain.
00:49:25 <nschoe> angerman, thanks I'll try that. I know I'll sound like a newbie, but I have to confirm: the idea is to download this ghc binary on the host, and use this ghc compiler to compile the haskell program (on the host), it hsould procude a binary that is stuitable to copy on the rPi and run there, right?
00:49:37 <angerman> For the latter one, there’s a blogpost on medium.com/@zw3rk; don’t know the link from memory.
00:49:57 <angerman> nschoe: exactly.
00:50:03 <nschoe> angerman, okay perfect.
00:50:22 <nschoe> I'll look on medium.com to find your post about the rpi toolchain.
00:50:35 <nschoe> Thanks for answering ;)
00:51:33 <angerman> Be warned though: template Haskell is „fun“ and cabal is a mess.
00:51:47 <angerman> Will take some more time to iron out the kinks.
00:52:24 <nschoe> angerman, yeah I read that on some of your posts on medium. I'm not using TH myself (but I suppose I'm screwed if one of the dependencies I need do use it:/), as for cabal... well I do use cabal :/
00:52:59 <nschoe> angerman, does that mean that I have to stop using cabal and use the x-compiler ghc version directly to compile my project?
00:53:37 <angerman> Cabal „works“ just needs a lot of hand holding.
00:54:20 <nschoe> angerman, like specifying --with-ghc, etc.? That sort of hand-holding?
00:54:22 <angerman> TH „works“ for many cases, if you have a TH Slave on your RPi.
00:54:33 <angerman> Yep that kind of handholding.
00:54:44 <nschoe> erf I don't even know what a "TH Slave" is :/
00:54:56 <raduom> Hi. I am starting a new project and would like to do some unit testing. what is your advice as to the framework I should use?
00:54:59 <angerman> And unpacking dependencies to be able to use new-build.
00:55:19 <angerman> nschoe: it’s shown in one of the blog posts.
00:55:43 <angerman> nschoe: essentially running a slave process to compile TH on the RPi.
00:55:50 <nschoe> angerman, for now I'm going to read your posts on medium (I think you covered those topics) and then I'll try. I might come back to you when / if I'm desperate and think about harming myself :P
00:56:23 <angerman> Ha. Good luck! Let me know how it goes.
00:57:16 <nschoe> angerman, probably bad ^^ as I'm totally new into everything that touches "x-compilation" and not too versatile when it comes to customizing ghc, cabal or anything that touches it. So... but I'll try my best.
00:57:25 <nschoe> Thanks for answering and for writing those blog posts.
01:00:06 <nschoe> raduom, i think QuickCheck is used for this?
01:00:24 <raduom> nschoe, for property based testing, not unit testing.
01:01:30 <nschoe> raduom, oh sorry. HUnit then?
01:01:57 <raduom> nschoe, hunit, hspec and tasty is what I am looking at now. :)
01:09:16 <raduom> and tasty it is :)
01:09:30 <raduom> s/tasty/hspec and upgrade to tasty if i feel like it.
01:10:23 <raduom> I found this somewhat useful: https://www.reddit.com/r/haskell/comments/5mrk20/haskell_testing_frameworks_what_do_you_use/
01:12:06 <jle`> when did Last get a Monad instance o.O
01:34:41 <[exa]> jle`: why not? :]
02:18:04 <AndreasK> jle`: At least since base 4.8 (GHC 7.10) so for some time
02:20:15 <olligobber> > let b+1 = 2 in undefined+1
02:20:17 <lambdabot>  2
02:20:19 <olligobber> nice
02:31:21 <jle`> neat
02:32:35 <AndreasK> Operator overloading makes a great code obfuscation tool
02:33:58 <mniip> "overloading"
02:34:05 <mniip> I think you mean identifier shadowing
02:41:18 <AndreasK> mniip: No, but it isn
02:41:25 <AndreasK> 'nt overloading in this case
02:50:09 <geekosaur> >> in C++, anyone?
03:06:38 <Phyx-> geekosaur: they already added folds so :D
03:08:49 <lseactuary> hello can someone help me with an axiomatic definition? i have typed it but im unsure what other constraints i should add.
03:26:03 <[exa]> geekosaur: semicolon!
03:26:34 <[exa]> geekosaur: oh so, you're not searching for one. :]
03:28:09 <nullie> they should plug in replacement syntax in C++20
03:29:24 <manytears> I'm getting an error I'm almost certainly sure is associated with indentation but can't figure it out. The error I'm getting is empty do block with the following code:https://pastebin.com/X08zeEHZ .   I would be grateful for any help that could be provided.
03:30:46 <nullie> manytears: what's the error
03:30:57 <boj> manytears: runReader is a function. it's easier to picture if you consider: runReader(computation(MyContext "haksell" o))))
03:31:23 <manytears> reader.hs:6:15: error: Empty 'do' block
03:34:00 <toppler> Did I dream it, or did Semiring a => Monoid a not happen recently?
03:35:06 <jle`> toppler: it's happening in 8.4 i believe
03:35:10 <jle`> oh
03:35:21 <jle`> Semigroup a => Monoid a is, at least
03:35:28 <toppler> Semigroup, sorry!
03:35:35 <boj> yeah
03:35:36 <toppler> Definitely wouldn't want all monoids to be semirings.
03:36:17 <boj> it's slated for 8.4
03:36:26 <jle`> you can try it out today!
03:36:35 <jle`> since the alpha is out
03:39:53 <toppler> Sweet. I should be able to wait. Hope it rolls into nixpkgs/master soon enough.
03:41:43 <boj> 8.2.2 has barely made it in to nixpkgs, we have a ways to go :)
03:56:11 <lseactuary> i can upload what i have done - just want to check it is correct and see if you have any other ideas on anything i needed to add.
04:04:44 <ggVGc> with HUnit and Tasty (or any other test framework), can I somehow describe some text to be printed if the test fails, but that isn't part of the actual test expression
04:10:58 <osa1> ggVGc: yes, see e.g. assertFailure
04:11:19 <osa1> ggVGc: http://hackage.haskell.org/package/tasty-hunit-0.10.0.1/docs/Test-Tasty-HUnit.html#v:assertFailure
04:13:39 <ggVGc> not exactly what I'm looking for
04:14:01 <osa1> what do you need? assertEqual and co also let you give a string to show in case of a failure
04:14:01 <ggVGc> I basically want to declare some descriptive text, without affecting the test result, and if any other assertion fails I want that to be printed
04:15:19 <osa1> maybe try something like `let failure_msg = "check failed`; unless (and checks) (assertFailure failure_msg)` ?
04:15:20 <ggVGc> yeah, that's what I'm using now. But I'd like to print the involved data structures whenever any assertion fails, without building that description string myself for each assertion
04:15:27 <ggVGc> yeah, I guess I'll make it myself
04:15:34 <ggVGc> just figured Tasty could have something already
04:16:55 <osa1> hedgehog has pretty advanced failure reporting so I'd take a peek at that as an inspiration, maybe you can find some reusable functions or something
04:17:43 <jchia_1> Is there a concise way to get this function? "f:: (Monad m, Ord a) => [a] -> (a -> m b) -> m [(a, b)]". Despite duplicate values in the input list, "a -> m b" is called only once per unique value of a. The elements in the returned list correspond to the elements in the input list.
04:18:27 <ggVGc> osa1: thanks!
04:30:08 <nshepperd_> @pl (\xs f -> traverse (\x -> (,) x <$> f x) (nub xs))
04:30:08 <lambdabot> flip (traverse . liftM2 (<$>) (,)) . nub
04:30:23 <nshepperd_> :t flip (traverse . liftM2 (<$>) (,)) . nub
04:30:24 <lambdabot> (Eq a1, Applicative f) => [a1] -> (a1 -> f a2) -> f [(a1, a2)]
04:47:31 <jchia_1> nshepperd_: That returns a shorter list when there are duplicates. I was wondering if there was some lens or functor trick.
04:49:30 <Rembane> jchia_1: Use a fold.
04:49:48 <Rembane> jchia_1: Or hm...
04:54:47 <Gurkenglas> Perhaps "memoizeM :: MonadSomething m => (a -> m b) -> a -> m b" lies along the way
04:55:53 <Gurkenglas> jchias type request may be minimal and important. Karma to you!
04:56:55 <Gurkenglas> (though the argument order ought to be the other way)
04:58:45 <Gurkenglas> For the general Monad case, of course. We could have "memoizeIO :: (a -> IO b) -> IO (a -> IO b)"
05:00:15 <Gurkenglas> Eh, nah just (a -> IO b) -> a -> IO b
05:03:06 <Gurkenglas> And this can be decomposed into memoize and "buffer :: IO a -> IO a"
05:12:00 <nshepperd_> Could imagine a (illegal?) lens called 'nubbed'
05:13:13 <Gurkenglas> That doesn't sound like the right approach. I've never seen a place where I thought IO belongs in the f slot of a LensLike.
05:13:30 <nshepperd_> Actually a traversal
05:14:02 <Gurkenglas> Wait, I think I misunderstood how you want to apply that. Actually that should work, cool.
05:14:58 <Gurkenglas> Shouldn't be anything illegal about it
05:15:45 <[spook]> Hi there, don't mean to interject, but anyone here comfortable sharing their emacs/spacemacs configs for haskell? On a nix system using stack.
05:16:50 <Gurkenglas> At least as long as we assume that a == b implies f a == f b for all f
05:16:52 <lseactuary> the question and my solution is here: https://imgur.com/a/473b8 can someone help check if this is right and help me with the proof at the end?
05:24:18 <Gurkenglas> (and the minimal version of jchia's type signature wouldn't include the (a,) which I missed. <.<)
05:34:07 <Gurkenglas> :t let nubbed f xs = fmap (\m -> map (m M.!) xs) . sequenceA . M.fromSet f . S.fromList $ xs in nubbed
05:34:09 <lambdabot> (Ord k, Applicative f) => (k -> f b) -> [k] -> f [b]
05:35:03 <Gurkenglas> jchia_1, here's a traversal. ^
05:37:51 <Gurkenglas> ...note that the effects are ordered according to the order on k.
05:43:05 <jchia_1> Gurkenglas: Thanks.
05:44:21 <Gurkenglas> :t \f xs -> fmap (\t -> map (\x -> (x, fromJust $ lookup x t)) xs) . traverse (\x -> (,) x <$> f x) . nub $ xs -- :/
05:44:22 <lambdabot> (Applicative f, Eq a) => (a -> f b) -> [a] -> f [(a, b)]
05:46:16 <nyberg> @. pl djinn Arrow a => a b c -> a d c -> a (Either d b) c
05:46:16 <lambdabot> Error : Class not found : Arrow
05:47:08 <infinisil> Ugh, I thought of maybe using amqp/rabbitmq, but holy hell, that API in Haskell is horrible. IO everywhere, arguments you don't know what to do with, stuff you need to handle that the library doesn't enforce, ...
05:47:21 <infinisil> https://hackage.haskell.org/package/amqp-0.18.1/docs/Network-AMQP.html
05:59:48 <giuliohome> Hi All! A newbe question: if I install haskell on windows and I compile a pgm to an exe, can I deploy such exe to another (windows) machine? Which are the requirements there? Not any haskell setup aside from the exe itself? Thanks for your support
06:58:36 <infinisil> Oh my god, after like 2 hours of struggling with cabal and then stack, I now find out that the package I'd like to use doesn't even build
07:00:21 <infinisil> Oh I could use the same stack build plan as the package is using
07:01:56 <hyperisco> a destination does not change with the length of road traveled
07:03:26 <glguy_> Sure it does. Take too long a route up the mountain and you miss the ski season
07:05:40 <hyperisco> a destination will change during the time of travel :)
07:07:11 <lseactuary> can someone help me figure out the data structure of this problem so i can write the recursions?
07:07:11 <lseactuary> https://pastebin.com/ZBJ9wuka
07:09:50 <hyperisco> lseactuary, I don't know what all the notation means. I am going to guess that because it is called "RouteList" that a list will work.
07:10:06 <lseactuary> yeah
07:10:14 <lseactuary> but i am confused how this data structure looks
07:10:22 <lseactuary> i think x means a cartesian product?
07:10:40 <lseactuary> if i can have an example e.g. R1 = <<S2,S3,S4>,<S5>> i will understand better
07:11:08 <hyperisco> I don't know… that is all gibberish to me
07:11:13 <jchia_1> not sure what 'join', 'x', '<<>>', seq mean
07:11:25 <infinisil> lseactuary: how about just a list of lists: let r1 = [[2, 3, 4], [5]]
07:11:40 <infinisil> replace numbers with some Section type
07:11:46 <jchia_1> I don't think the join means the Haskell join
07:11:47 <nyberg> data RouteList x = Empty | Join (Seq SectionIDs) (RouteList x) ?
07:12:42 <lseactuary> Seq SectionIDs is just <S2,S3,S4> for example
07:13:12 <lseactuary> <> usually means sequence but it looks like the routeID is inside the sequence tuple?
07:13:49 <lseactuary> so maybe something like R1 = <<R1, <S2,S3,S4>>,<R1, <S5>>>
07:14:51 <jchia_1> The notation is really undefined. Hard to say anything.
07:14:52 <lseactuary> before I had R1 = <<S2,S3,S4>,<S5>> and had to make the recursion on this
07:14:54 <lseactuary> yeah
07:16:54 <lseactuary> infinisil the list of lists looks similar to what i did before with the sequence of a sequnece
07:18:04 <lseactuary> what is your best guess :)
07:26:44 <Yimo> Hey ehm, I wanted to ask. If I'm making a new data type data Vector = Vc {vx,vy::Float} and I want to evaluate the sum of two vectors a and b, so I have to make Vector an instance of Num ?
07:27:18 <metahumor> do you want to add them using (+)?
07:27:22 <Yimo> Yes
07:27:28 <bartavelle> Yimo: you might want to take a look at the linear package, which does taht kind of things
07:27:39 <bartavelle> the problem with Num is that you also have to define things that might be nonsensical
07:27:43 <metahumor> yeah, (+) works on Num a, but there's a ton of other stuff you'd have to define for the Num instance
07:27:47 <mnoonan> Yimo: if you do, you'll have to put in dummy definitions for lots of other Num methods that don't make sense for vectors
07:28:02 <metahumor> i agree with the suggestion to use Linear.V2
07:28:04 <bartavelle> well, you can decide (*) is vector product
07:28:05 <Yimo> you mean things like toIntegral?
07:28:05 <mnoonan> you could do a sensible Monoid instance, though
07:28:22 <Yimo> hm
07:28:56 <Yimo> bartavelle so I must define all the things that define the class Num in Vector in order to use (+) for that new datatype?
07:29:07 <mnoonan> signum, abs, (*), fromInteger are all questionable
07:29:14 <Yimo> oh man
07:29:15 <bartavelle> Yimo: you do not have to, but then you are at risk of calling undefined functions
07:29:16 <Yimo> that's a pain
07:29:32 <bartavelle> Yimo: yes, the num class is annoying
07:29:37 <Yimo> well, I remember trying not to define them, and ending up with the compiler whining at me
07:29:59 <mnoonan> you can define them using error or undefined, and then just hope they are never called at runtime.
07:30:10 <mnoonan> or just define your own (+.) operator :)
07:30:10 <Yimo> :/
07:30:26 <Yimo> I should think of linear package then
07:30:34 <metahumor> do you care about having a Functor instance for your Vector?
07:30:37 <Yimo> but really , I just wanted to know this info in general
07:30:39 <Yimo> what a pain :/
07:31:07 <bartavelle> Yimo: the linear package is pretty good. However, yeah, the Num typeclass is a pain point
07:31:37 <bartavelle> the whole numerical hierarchy even
07:31:45 <Yimo> I agree
07:32:01 <metahumor> you could do "data Vector a = Vc {vx,vy::a}" and then do "instance (Num a) => Num (Vector a)"
07:32:02 <mnoonan> but you could do Monoid easily, with mempty = Vc 0 0, mappend (Vc x y) (Vc x' y') = Vc (x + x') (y + y'). That's at least lawful.
07:32:04 <Yimo> mnoonan I can define a new operator that is inside ( )s and have them work like + - ... ?
07:32:14 <Yimo> hm
07:32:23 <Yimo> I still didn't learn Monoid, so I'll see
07:32:23 <mnoonan> Yimo: yes, that's right
07:32:36 <mnoonan> @let (+.) (x,y) (x',y') = (x + x', y + y')
07:32:37 <lambdabot>  Defined.
07:32:45 <mnoonan> > (1,2) +. (3,4)
07:32:46 <lambdabot>  (4,6)
07:32:56 <nyberg> Yimo: semigroup => monoid
07:32:57 <metahumor> :t (+.)
07:32:58 <lambdabot> (Num a, Num b) => (a, b) -> (a, b) -> (a, b)
07:33:05 <Yimo> alright, that's very useful:
07:33:08 <Yimo> !*
07:33:08 <nyberg> with zero added
07:33:55 <nyberg> it is as soon GHC will default to it
07:34:57 <metahumor> is there an easily accessible package that has a Ring class?
07:35:21 <nullie> @hoogle Ring
07:35:21 <lambdabot> module Algebra.Ring
07:35:21 <lambdabot> module NumHask.Algebra.Ring
07:35:21 <lambdabot> NumHask.Algebra.Ring class (AdditiveGroup a, MultiplicativeAssociative a, MultiplicativeUnital a, Distribution a) => Ring a
07:35:46 <metahumor> numhask has so much going on
07:36:51 <Yimo> It would of been amazing if haskell allowed type overloading for functions
07:37:10 <nyberg> what do you mean?
07:37:11 <Yimo> but that'll require a lot of more syntax I guess
07:37:17 <Yimo> by type overloading I mean
07:37:22 <Yimo> allow + on numbers
07:37:30 <Yimo> and allow + for chars for example
07:37:40 <nyberg> wouldn't make sense for Char
07:37:51 <mnoonan> you get type overloading from typeclasses, it's just that (+) is part of a relatively large typeclass
07:38:23 <nyberg> Idris Num class is a lot nicer but that's another story
07:38:30 <AlexSmart> Is anyone still doing advent of code?
07:38:53 <nyberg> Might start, didn't get a chance to
07:39:23 <Yimo> what's Advent of code AlexSmart?
07:39:49 <metahumor> Yimo: it's a set of programming/algorithmic puzzles
07:40:01 <metahumor> that were released once a day from Dec 1 - Dec 25
07:40:08 <AlexSmart> http://adventofcode.com/2017/
07:40:09 <Yimo> is it somehow like eulerproject ?
07:40:21 <Yimo> hm, I'll check that out
07:40:21 <AlexSmart> i learned about it here
07:40:40 <metahumor> it is like it, but its more "light" -- it has a story behind the problems, and it is less math heavy, more data structurues
07:41:12 <metahumor> the topic of the channel has the "haskell and friends" leaderboard on it, which lists how quickly people solved the problems using haskell (or related langs)
07:42:06 <AlexSmart> i was able to solve most problems in haskell, but for some i had to fall back to cpp, because my noob haskell implementation would use all four cores and all the memory on my laptop and cause it to freeze
07:42:29 <AlexSmart> i was actually impressed that haskell could do that, like automatically parallelize stuff in the background
07:42:47 <nyberg> space leaks
07:43:22 <nullie> time to do some strictness?
07:43:26 <Yimo> that's the downside of haskell : it's memory intensive
07:44:01 <Yimo> I'm not sure if it's possible to invent a CPU and "RAM" that works well with functional lazy programming
07:44:34 <AlexSmart> i guessed that could be the issue, but noob, so dont know how to fix i
07:45:13 <metahumor> AlexSmart: I had a similar issue for some problems. there, putting "!" in the right places helps a lot
07:45:25 <metahumor> from the -XBangPatterns pragma
07:45:41 <metahumor> that makes it strict in those arguments. for a lot of the problems, the strictness is very useful
07:46:03 <AlexSmart> http://lpaste.net/361166
07:46:06 <metahumor> especially in all of the problems where the solution is calling some function iteratively on itself a large number of times
07:46:31 <AlexSmart> metahumor: that's exactly the situation i am in
07:46:47 <yoho> you can also do it manually with seq :P
07:46:57 <AlexSmart> tried playing around with bang patterns too, but didn't know what the "right places" are :P
07:47:37 <metahumor> ah, dec25 problem
07:47:45 <metahumor> that's the one where i specifically had to use a "strict iterate"
07:47:57 <AlexSmart> i had the same issue with another one actually
07:47:59 <metahumor> which made it not go into a stack overflow
07:48:29 <metahumor> AlexSmart: can you say the definition of `iterate`?
07:49:16 <AlexSmart> applies the function repeatedly to create a lazy list of results
07:49:28 <metahumor> yeah, i mean haskell-code wise
07:50:48 <AlexSmart>  
07:50:48 <AlexSmart> iterate :: (a -> a) -> a -> [a]
07:50:48 <AlexSmart> iterate f a = a : f <$> iterate f a
07:50:54 <AlexSmart> something like this?
07:52:09 <Yimo> perhaps with a condition or counter
07:52:19 <metahumor> yeah that's right
07:52:26 <metahumor> can you think of a way to make that strict?
07:52:38 <Yimo> oh boy
07:52:47 <hyperisco> iterate f x = x : iterate f (f x)
07:52:59 <Yimo> maybe if it had a counter you can make it strict?
07:53:07 <hyperisco> make what strict?
07:53:18 <metahumor> make iterate strict
07:53:19 <Yimo> the iterate function
07:53:19 <AlexSmart> ooh, i didn't even think about pulling out my own version of iterate
07:53:26 <hyperisco> make what about it strict?
07:53:36 <metahumor> strict iterate is coming in ghc-8.4 i think
07:53:51 <metahumor> make evaluation of f on the x strict
07:53:59 <Yimo> make the function itself strict in all of it
07:54:34 <AlexSmart> Yimo: I think i tried that
07:54:40 <AlexSmart> that doesn't work
07:54:49 <Yimo> oh
07:54:56 <metahumor> what did you write?
07:55:25 <AlexSmart> i tried making a strict version of transition
07:55:33 <AlexSmart> (the function that i am iterating)
07:56:22 <metahumor> that helps to, but what i'm saying is that since iterate itself is lazy
07:56:34 <AlexSmart> sorry, i don't have that saved, i was just playing around and trying different versions
07:56:47 <pumita> Why does Haskell accept this expression between data type constructors: `True = False` and what does it mean?
07:56:49 <metahumor> you have a thunk of "f ( f ( f ... f (x)" that never got evaluated
07:57:18 <AlexSmart> metahumor: very good point!
07:57:30 <Yimo> hence why I thought a counter is necessary in the first place
07:57:38 <Yimo> but count what, is the issue
07:57:39 <metahumor> as iterate built up the list, it began with "[a, f a, f (f a), f (f (f a)), ...]"
07:57:49 <mnoonan> Yimo: you can just produce the list lazily, and then only consume however much you need
07:57:55 <metahumor> none of those actually get evaluated until you do the (!! index)
07:58:01 <hyperisco> iterate f x = let y = f x in x : y `seq` iterate f y
07:58:07 <metahumor> yeah
07:58:24 <metahumor> that's the way to do it (using seq, not bangpatterns)
07:58:30 <metahumor> iterate'
07:58:50 <metahumor> for my dec25 soln, changing iterate to this iterate' made me not have a stack overflow
07:59:11 <AlexSmart> iterate' :: (a -> a) -> a -> [a]
07:59:11 <AlexSmart> iterate' f !a = a : iterate' f a
07:59:11 <AlexSmart>  
07:59:23 <AlexSmart> something like that maybe?
07:59:25 <hyperisco> no that's different
07:59:36 <glguy> You can also get away with using normal iterate if you use an alternate list indexing function that forces evaluation of the elements that it skips over
07:59:45 <Yimo> every time I hear stack overflow I think of the website even though it's clear that it refers to the memory-saturation/cpu overload
07:59:51 <glguy> (not that that's better)
07:59:57 <hyperisco> but exactly how you want to make it more strict is variable
08:00:28 <glguy> AlexSmart: That definition you just pasted didn't use the 'f'
08:00:33 <metahumor> Yimo: makes it really annoying now for searching on google about "stack overflow" issues and not just defaulting to results from that site
08:00:56 <Yimo> metahumor haha I didn't face that issue yet thank God
08:01:12 <Yimo> (I did face stack overflows, but didn't have to google search it)
08:01:45 <hyperisco> the version I posted is still defined at bottom as long as f is
08:02:48 <Yimo> one thing I like about haskell is how giving missing arguments to a function returns a function that accepts the missing arguments
08:03:27 <Yimo> but I guess that's just memory intensive isn't it
08:03:49 <metahumor> that's called currying
08:03:50 <yoho> the word you're looking for is currying
08:03:52 <yoho> dammit metahumor
08:04:23 <metahumor> its not memory-intensive, you've just defined a different function. what is memory intensive is keeping the "evaluation" of a statement separate from the "expression" of a statement
08:04:32 <metahumor> s/memory/space
08:05:07 <hyperisco> well, the list spine is defined, at least, is what I mean
08:07:46 <hyperisco> Yimo, all functions take exactly one argument, and by accepting that the rest becomes clear
08:07:54 <AlexSmart> glguy: oops
08:07:58 <AlexSmart> i meant,
08:07:58 <AlexSmart> iterate' f !a = a : iterate' f (f a)
08:08:06 <lseactuary> when i have a data structure R1 = <<S1,S2,S3>,<S4>> I can use recursion length(<x>^s) = 1 + length(s) to get the number of <> (in this case 2). however now i have a data structure R1 = <<X1,<S1,S2,S3>>,<X1,<S4>>> how do i get the answer 2?
08:09:08 <hyperisco> @let strictIterate f x = let y = f x in x : y `seq` iterate f y
08:09:09 <lambdabot>  .L.hs:160:56: error:
08:09:09 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
08:09:09 <lambdabot>        Expected type: [a] -> [a]
08:09:27 <hyperisco> @let strictIterate f x = let y = f x in x : (y `seq` iterate f y)
08:09:28 <lambdabot>  Defined.
08:09:29 <metahumor> lseactuary: are X1 and <S1, S2, S3> of the same type?
08:09:39 <hyperisco> @let inf ~(x:xs) = x : inf xs
08:09:40 <lambdabot>  Defined.
08:10:17 <hyperisco> > (length . take 10) strictIterate undefined ()
08:10:18 <lambdabot>  error:
08:10:18 <lambdabot>      • Couldn't match expected type ‘t0 -> () -> t’
08:10:18 <lambdabot>                    with actual type ‘Int’
08:10:33 <hyperisco> > (length . take 10) (strictIterate undefined ())
08:10:34 <lambdabot>  *Exception: Prelude.undefined
08:10:41 <hyperisco> > (length . take 10) (iterate undefined ())
08:10:42 <lambdabot>  10
08:10:44 <Yimo> haskell's type system is ear deafening, I admit
08:10:57 <hyperisco> > (length . take 10 . inf) (strictIterate undefined ())
08:10:59 <lambdabot>  10
08:11:08 <Yimo> ^ when it was made lazy it worked
08:11:11 <Yimo> using inf
08:12:02 <hyperisco> it recovers the lazy iterate from strictIterate… just thought that was interesting
08:16:42 <pumita> Why does Haskell accept this expression between data type constructors: `True = False` and what does it mean?
08:17:03 <hyperisco> show us an example
08:19:48 <glguy> > let True = False in ()
08:19:50 <lambdabot>  ()
08:20:30 <glguy> pumita: In that context True is a pattern, but since there are no variables bound by it and let patterns are irrefutable by defualt there's nothing to force the match between that True pattern and the False value
08:20:33 <glguy> so it's ignored
08:20:37 <mnoonan> It is as if you wrote "let Just x = foo in bar", I think. You're decomposing a value with a pattern match on the LHS
08:20:43 <glguy> If we had:
08:20:50 <glguy> > case False of True -> ()
08:20:51 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
08:21:03 <glguy> We'd be forcing the pattern to match its value, which it doesn't
08:21:27 <glguy> It's also important to note that that let example isn't binding True:
08:21:31 <glguy> > let True = False in True
08:21:33 <lambdabot>  True
08:21:38 <glguy> Those two uses of True are unrelated
08:22:52 <hyperisco> > let !True = False in ()
08:22:54 <lambdabot>  *Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern True
08:25:02 <hyperisco> @let mkStrictPair x y = (x, x `seq` y)
08:25:03 <lambdabot>  Defined.
08:25:45 <metahumor> if I have a function f :: a -> a -> a, what's the idiomatic way to make a g such that "g f :: a -> a -> Maybe a", where the Maybe a is Just a
08:26:24 <mnoonan> metahumor: (Just .:) if you have defined (.:) = (.) . (.) already
08:26:52 <hyperisco> > snd (mkStrictPair (let !True = False in (), ()))
08:26:53 <lambdabot>  error:
08:26:53 <lambdabot>      • Couldn't match expected type ‘(a0, b)’
08:26:53 <lambdabot>                    with actual type ‘b0 -> (((), ()), b0)’
08:27:13 <hyperisco> > snd (mkStrictPair (let !True = False in ()) ())
08:27:15 <lambdabot>  *Exception: <interactive>:3:24-36: Irrefutable pattern failed for pattern True
08:27:17 <Yimo> http://prntscr.com/htfa7w can someone explain the error here ?
08:27:23 <mnoonan> or (Just ...) if you use Control.DotDotDot
08:27:31 <Yimo> (screenshot is better for me here than to paste it
08:27:33 <Yimo> )
08:27:35 <hyperisco> fun with strictness
08:27:50 <mnoonan> :t (Just ...) (+)
08:27:51 <lambdabot> error:
08:27:51 <lambdabot>     • Couldn't match type ‘Maybe (p a b -> p a (p a b))’
08:27:51 <lambdabot>                      with ‘s -> p a t’
08:28:00 <mnoonan> :t (Just .:) (+)
08:28:01 <lambdabot> error:
08:28:01 <lambdabot>     • Variable not in scope:
08:28:01 <lambdabot>         (.:) :: (a0 -> Maybe a0) -> (Integer -> Integer -> Integer) -> t
08:28:11 <mnoonan> I guess lambdabot doesn't know either :)
08:28:40 <hyperisco> lambdabot does not have that amazing library imported
08:28:45 <mnoonan> heh
08:29:53 <mnoonan> it sure beats https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html#v:.:
08:29:58 <metahumor> Yimo: read the error you got, in the defn for dotproduct, you are returning a Float instead of a Vector
08:30:09 <metahumor> but "a * b" expects a Vector
08:30:57 <hyperisco> well the difference is that ... is greedy
08:31:02 <Yimo> a and b are clearly vectors, but how is a*b expected as a vector ? am I supposed to do (*) :: Vector -> Vector -> Float ?
08:31:03 <metahumor> so you need to change your defn of dotproduct in this case, but I don't think the (*) instance for a 2D vector makes sense except for an elementwise (*)
08:31:16 <mnoonan> hyperisco: fair enough
08:32:28 <Yimo> metahumor I don't get the problem exactly
08:32:51 <Yimo> dotproduct is supposed to return a float, but how do I make a * b expect a float?
08:33:30 <metahumor> you can't make it expect a Float, that's the issue. The Num class expects (+), (-), and (*) to return the same type as the input types
08:34:00 <metahumor> mnoonan, hyperisco, so the suggestion is to use (...) from Control.DotDotDot, or just define (.:) locally to my module?
08:34:22 <Yimo> oh
08:34:25 <Yimo> :t (*)
08:34:26 <lambdabot> Num a => a -> a -> a
08:34:30 <Yimo> yeah I get it now
08:34:30 <mnoonan> metahumor: it is probably up to your taste, but I get a lot of mileage out of just having (.:) defined everywhere
08:34:44 <Yimo> :t (+)
08:34:45 <lambdabot> Num a => a -> a -> a
08:34:49 <hyperisco> metahumor, I am not sure if you really want ... in your program… I made it only because it was possible
08:35:01 <mnoonan> or, you know, just write (\f x y -> Just (f x y)) :)
08:35:19 <hyperisco> metahumor, you can  (fmap . fmap) Just  or a variety of ways to express this
08:35:28 <hyperisco> lens would be one of them… though don't ask me how…
08:35:51 <hyperisco> id ~> id ~> Just  with ~> from TypeCompose
08:36:16 <metahumor> all of this is just to get clean "mergeWithKey" usage
08:36:23 <metahumor> :t mergeWithKey
08:36:23 <lambdabot> error:
08:36:24 <lambdabot>     • Variable not in scope: mergeWithKey
08:36:24 <lambdabot>     • Perhaps you meant one of these:
08:36:46 <metahumor> > import qualified Data.IntMap as IM
08:36:48 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
08:37:11 <hyperisco> the problem you may experience with ... is obscure type errors, because it relies on some careful tricks
08:37:41 <hyperisco> and if you give a type to  (Just ...)  you may find it rather unintelligible
08:38:11 <hyperisco> though  (Just ...) :: (a -> a -> a) -> a -> a -> Maybe a   should type check just fine
08:38:25 <metahumor> :+m Data.IntMap
08:38:30 <hyperisco> the most general type will have some weird constraints
08:38:37 <metahumor> :t Data.IntMap.mergeWithKey
08:38:38 <lambdabot> (IS.Key -> a -> b -> Maybe c) -> (IM.IntMap a -> IM.IntMap c) -> (IM.IntMap b -> IM.IntMap c) -> IM.IntMap a -> IM.IntMap b -> IM.IntMap c
08:38:43 <mnoonan> metahumor: wait, if you're always returning a Just, aren't you just doing a unionWithKey?
08:39:02 <hyperisco> and if you happen to be interested in other variadic functions, check out my foldapp library :)
08:39:07 <metahumor> @let (.:) = (.) . (.)
08:39:08 <lambdabot>  Defined.
08:39:26 <nyberg> blackbird
08:39:33 <metahumor> :t IM.mergeWithKey (const (Just .: max))
08:39:33 <lambdabot> Ord c => (IM.IntMap c -> IM.IntMap c) -> (IM.IntMap c -> IM.IntMap c) -> IM.IntMap c -> IM.IntMap c -> IM.IntMap c
08:40:06 <mnoonan> and if you're doing const, you're not using the key..
08:40:18 <mnoonan> :t IM.unionWith max
08:40:19 <lambdabot> Ord a => IM.IntMap a -> IM.IntMap a -> IM.IntMap a
08:41:13 <metahumor> that's if i want to use "id id" as the next two arguments
08:41:19 <mnoonan> ah, I see.
08:41:45 <lseactuary> anyone please can you help me?
08:42:46 <mnoonan> metahumor: this seems like a situation where putting in a lambda is going to be clearer than any alternative
08:44:31 <metahumor> lseactuary: are X1 and <S1, S2, S3> of the same type?
08:48:03 <lseactuary> metahumor nope. X1 is the route name i.e. X1 = <<S2,S3,S4>,<S5>> for example. i wrote the recursion for this. now i am trying to do a recursion for a list. is the pastebin still working for you i write the exact definition there... perhaps i translated it wrong?
08:50:36 <lseactuary> metahumor happy to explain if it helps to provide context?
08:53:11 <metahumor> so is the type of your data [(Route, ???)]
08:53:16 <metahumor> i don't see a pastebin
08:55:31 <lseactuary> metahumor https://pastebin.com/qguAWiGk
08:55:45 <lseactuary> this explains it better but i can explain more if it helps
08:57:46 <lseactuary> i have not seen such notation before and cannot find it my notes / books etc so am confused
08:58:18 <lseactuary> in the other part an example is given so i know for sure R1 = <<S2,S3,S4>,<S5>> is correct and then the recursions follow
08:58:35 <lseactuary> but here i am not understanding the data structure of the list
08:58:50 <lseactuary> as there is an induction i need to do. i can roughly see the base case play out but not really getting it
08:58:53 <lseactuary> any help is appreciated
09:01:11 <metahumor> so one way to have this in haskell would be is data RouteList = RLEmpty | RLJoin (Route, [SectionID]) RouteList
09:01:15 <metahumor> right?
09:01:34 <metahumor> which is just isomorphic to [(Route, [SectionID])], if I understood your problem
09:01:45 <lseactuary> [SectionID] is a sequence
09:01:48 <lseactuary> but ye
09:01:59 <lseactuary> but what does this mean
09:02:02 <lseactuary> in normal English :)
09:02:07 <lseactuary> so i can understand better
09:04:05 <lseactuary> metahumor but yeah you are sounding correct
09:04:29 <metahumor> so in haskell, how did you get length R1 = 2 to work?
09:04:48 <lseactuary> i didnt program it yet. i only wrote the recursion in mathematics.
09:04:50 <lseactuary> but basically
09:05:19 <lseactuary> S is a sequence and <x> is the first element, s is a sequence
09:05:32 <lseactuary> so you have length(<x>^s) = 1 + length(s)
09:05:36 <lseactuary> that is the recursion
09:05:49 <metahumor> and are you asking how to write that in haskell?
09:05:55 <lseactuary> that is for just route -> seq(seq(section id))
09:06:05 <lseactuary> nope - that makes sense to me :)
09:06:11 <lseactuary> but now i have this new data structure
09:06:14 <lseactuary> and i cannot understand it
09:06:19 <lseactuary> so i want to write the recurision in math
09:06:24 <lseactuary> then i will try in haskell
09:07:01 <lseactuary> but hard to write when i dont understand the data structure
09:07:03 <metahumor> you have a seq((routename, seq(section id))), where (a, b) is a cartesion product
09:07:16 <lseactuary> so the example i pasted is correct?
09:07:25 <lseactuary> line 5?
09:08:17 <lseactuary> as a route is 2+ seq(section id) so there will be the same route name for a bunch of seq(section id) correct?
09:08:22 <metahumor> i dont really understand how the RouteList syntax is being used on line 5; in either case, your definition of length for some seq(X) shouldn't matter on what X is
09:08:49 <lseactuary> seq((routename, seq(section id)))
09:08:55 <lseactuary> i was just finding an example of this
09:09:03 <lseactuary> pretend the list is R1 and R2 for example
09:09:37 <lseactuary> it would be RouteList(R1,R2) = seq((R1, seq(section id)), (R2, seq(section id)))
09:09:41 <lseactuary> or
09:10:02 <lseactuary> = seq(((R1, seq(section id)), (R1, seq(section id set 2))), (R2, seq(section id)))
09:10:16 <lseactuary> as 2+ seq(section ids) form a route
09:12:22 <lseactuary> metahumor am i making sense?
09:13:22 <Yimo> reminds me of logical programming languages
09:13:24 <metahumor> sure, you could have those sequences -- the length of the larger sequence doesn't care about what's actually in it
09:13:31 <lseactuary> got ya
09:13:43 <lseactuary> ok cool i think im in the right direction now
09:14:03 <lseactuary> but now i am trying to write the recursion in math to get the number of sequences
09:14:13 <lseactuary> which in the example in pastebin should be 5
09:14:33 <lseactuary> but my old recursion lengthB(⟨x⟩^s) = 1 + lengthB(s) wont still work here will it ?
09:14:54 <metahumor> it will. you just need to have your base case from which you're inducting from
09:15:04 <lseactuary> interesting
09:15:47 <metahumor> in your case, it's where "[a, b]" and "[(a,x), (b,y)]" have the same length, which they do
09:16:01 <metahumor> even though they are "sequences" of different things
09:16:07 <lseactuary> isnt it RouteList(<>) = empty | join << <> >>
09:16:54 <lseactuary> it's where "[a, b]" and "[(a,x), (b,y)]" have the same length, which they do
09:16:58 <lseactuary> what is [a,b]
09:17:10 <lseactuary> a route could be made up of 2 sequences, 3, 4, 1 million
09:17:17 <lseactuary> so they are not the same length right?
09:18:24 <metahumor> sure, a route could have many sections to it, but if you're trying to find out the length of a list of routes
09:18:33 <metahumor> i.e. the number of routes in a sequence of routes
09:18:43 <metahumor> it doesn't matter how many sections each route has
09:18:50 <lseactuary> aha
09:18:57 <metahumor> since each route counts for 1, and only 1
09:19:07 <lseactuary> ah
09:19:14 <lseactuary> i am trying to find the number of sequences also
09:19:27 <lseactuary> and blocks i.e number of < > with S's inside
09:19:45 <lseactuary> see line 7/8 :)
09:20:08 <lseactuary> so in the example i provide, the number of routes from the list would give me 2
09:20:15 <lseactuary> the number of blocks should give me 5
09:20:37 <lseactuary> the number of sections should give me 3+1+2+3+1 = 10
09:20:44 <metahumor> then yes, your defn on liune 14 is right
09:20:47 <lseactuary> im trying to solve the latter 2
09:21:17 <lseactuary> the stuff on line 10 onwards was for Route = seq(seq SectionIDs) e.g. Route1 = <<S2,S3,S4>,<S5>> though
09:21:20 <lseactuary> a different structure
09:21:50 <metahumor> only you need to change your defn like this: lengthS((r,b)^s) = lengthB(b) + lengthS(s)
09:22:36 <metahumor> because now you throw away the route name information, you don't need to count how long the sequence of sections is
09:22:51 <metahumor> you get the sequence of sections by pattern-matching on the cartesian product
09:23:19 <lseactuary> oh what you are saying basically is last time the first element <x> was just a single element, and now its something like <x,y>
09:23:53 <lseactuary> so what was <x>^s previously is now <r,b>^s now
09:24:05 <metahumor> exactly
09:24:07 <lseactuary> ooh
09:24:10 <lseactuary> whoa
09:24:14 <lseactuary> that penny just dropped :P
09:25:07 <lseactuary> and the first one (to count blocks) is basically lengthB(<r,b>^s) = 1 + lengthB(s)
09:26:53 <metahumor> yes, but the original defn could still work if you have some way of identifying (r,s) as x
09:27:04 <lseactuary> got ya
09:27:35 <lseactuary> question
09:28:36 <lseactuary> last time i had to prove this by induction using the recursions: for all s : seq(seq1 Section Id) • lengthS(s) = lengthB(flattenR(s))
09:28:39 <lseactuary> which i did
09:28:53 <lseactuary> do i need to write RouteList ::= empty | join <<RouteList x (seq SectionIDs)>> in a similar format before induction?
09:28:58 <lseactuary> ive not seen this format before
09:30:15 <lseactuary> you mentioned i need to have the case base as (a,b) but is that r,b above or something else?
09:31:57 <metahumor> what is flattenR?
09:32:28 <lseactuary> <<a>,<b, c>,<d>> --> <a,b,c,d>
09:32:38 <lseactuary> i dont need to prove the same thing here
09:32:51 <lseactuary> i just need to prove RouteList ::= empty | join <<RouteList x (seq SectionIDs)>> by induction
09:33:01 <lseactuary> i can see it will work now but im unsure how to write it
09:33:23 <metahumor> i'm getting lost in the syntax, so i can't really help on how to write it
09:33:33 <lseactuary> no problems
09:33:38 <lseactuary> dont worry about syntax
09:33:45 <lseactuary> mainly just thinking about principal here
09:33:57 <lseactuary> you mentioned the base case is a,b
09:34:04 <lseactuary> can you explain this more please? then i can apply it
09:34:34 <metahumor> i mean the base case for any length function is length empty = 0
09:35:10 <metahumor> doesn't matter if the sequence if of a type "seq(x)" or "seq(r,b)"
09:35:15 <metahumor> doesn't matter if the sequence if of a type "seq(x)" or "seq((r,b))"
09:35:59 <lseactuary> ah
09:36:03 <lseactuary> yeah
09:36:09 <lseactuary> the empty sequence is what i did also :)
09:36:54 <lseactuary> just got confused by this line: they do
09:37:01 <lseactuary> *in your case, it's where "[a, b]" and "[(a,x), (b,y)]" have the same length, which they do
09:38:12 <lseactuary> it is just the recursions are functions so saying things like lengthB(s) makes sense
09:38:17 <lseactuary> but here idk what RoutList is
09:38:25 <lseactuary> is it possible to say RouteList(<>)
09:39:53 <metahumor> again, not sure what the syntax allows or now
09:39:56 <metahumor> not
09:40:44 <lseactuary> no problems :)
09:41:29 <lseactuary> can you explain this line please: where "[a, b]" and "[(a,x), (b,y)]" have the same length
09:42:41 <lseactuary> ah a = routename and b = seq(sectionid)
09:42:51 <lseactuary> just saw your line: seq((routename, seq(section id))), where (a, b) is a cartesion product
09:43:07 <lseactuary> but they dont have the same length right
09:43:18 <monochrom> [a,b]'s length is 2. [(a,x), (b,y)]'s length is 2. Same length.
09:43:53 <monochrom> > length [(3,'a'), (5,'x')]
09:43:54 <lambdabot>  2
09:43:59 <monochrom> worksforme
09:44:18 <metahumor> nope... it's my syntax for seq. [a, b] is a seq(x) that has two elements, a and b
09:44:36 <metahumor> and then [(a,x), (b,y)] is a seq((r,b)) with two elements (a,x) and (b,y)
09:45:04 <metahumor> so in the first case "[a, b]", your a and b can be seq(sectionid)-s
09:45:31 <metahumor> in the second case "[(a,x), (b,y)]", your a and b can be routenames, x and y can be seq(sectionid)-s
09:46:21 <lseactuary> but you can have one routename with 5 sequences (i.e. 5 blocks of sequences <>) and another routename with just 1
09:46:32 <lseactuary> well 2 otherwise it wouldnt be a route
09:49:52 <kamyar> Please consider my code
09:49:56 <kamyar> http://lpaste.net/2052315453417586688
09:50:01 <metahumor> > foldr1 (\(a,b) (c,d) -> a + c) [(3,'a'), (5,'x')]
09:50:03 <lambdabot>  error:
09:50:03 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ (a, Char)
09:50:03 <lambdabot>      • In the expression: a + c
09:50:25 <metahumor> > foldr (\(a,b) (c,d) -> a + c) 0 [(3,'a'), (5,'x')]
09:50:27 <lambdabot>  error:
09:50:27 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ (a, b)
09:50:27 <lambdabot>      • In the expression: a + c
09:50:33 <kamyar> I added the output
09:50:46 <metahumor> > foldr (\acc (a,b) -> acc + a) 0 [(3,'a'), (5,'x')]
09:50:48 <lambdabot>  error:
09:50:48 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ (a, Char)
09:50:48 <lambdabot>        Expected type: ((a, Char), Char)
09:51:17 <nullie> metahumor: result of function must be of the same type
09:51:21 <metahumor> > foldr (\(a,b) acc -> acc + a) 0 [(3,'a'), (5,'x')]
09:51:22 <lambdabot>  8
09:51:31 <nullie> as acc, right
09:51:48 <metahumor> sorry, just get the proper order of the acc inside the function mixed up bw foldl and foldr often
09:53:40 <kamyar> Please see my code
09:54:00 <kamyar> http://lpaste.net/2052315453417586688
09:55:03 <lseactuary> metahumor got it now - thanks man for the help :)
09:56:00 <metahumor> =)
09:57:23 <lyxia> kamyar: what is there to see
09:57:41 <kamyar> lyxia: Times are not correct
09:57:47 <kamyar> lyxia: They seem odd
09:58:14 <kamyar> I am testing the same url using ab (Apache Benchmark)
09:58:20 <kamyar> the numbers are not true and
09:58:30 <kamyar> the deviation is not normal
09:58:56 <lseactuary> metahumor - question - what could you induct on RouteList. we have a recursion for number of blocks and sessions. but im not sure this says anything lol.
10:00:07 <lseactuary> last time i showed the number of sessions = flatten number of sessions but that was explicit
10:00:11 <lseactuary> i guess i could do the same here
10:02:13 <yoyo_> a
10:02:47 <lseactuary> dont need to prove it mostly asking for my own interest
10:03:01 * hackage hasql-generic 0.1.0.5 - Generic encoder and decoder deriving for Hasql  https://hackage.haskell.org/package/hasql-generic-0.1.0.5 (kahnpro)
10:03:34 <kamyar> Ok leave it I guess I found the problem
10:03:58 <kamyar> please help me get the average and other statistical functions (stddve...) from a list of numbers within IO monad
10:05:21 <nullie> sum xs / length xs
10:06:55 <Psybur> > foldr (\x (s,l) -> (s+x,l+1)) (0,0) [1,1,1,1,1]
10:06:57 <lambdabot>  (5,5)
10:07:15 <Psybur> > foldl' (\x (s,l) -> (s+x,l+1)) (0,0) [1,1,1,1,1]
10:07:17 <lambdabot>  error:
10:07:17 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ (a, b)
10:07:17 <lambdabot>      • In the expression: s + x
10:07:22 <Psybur> Ops :D
10:07:43 <Psybur> Is there any advantage in foldr and foldl having different signatures?
10:08:48 <int-e> > foldr (+) 0 [a,b,c]
10:08:50 <lambdabot>  a + (b + (c + 0))
10:08:54 <int-e> > foldl (+) 0 [a,b,c]
10:08:56 <lambdabot>  0 + a + b + c
10:09:11 <int-e> Psybur: the order of the list elements is reflected in the function applications
10:09:24 <int-e> > foldl (flip (+)) 0 [a,b,c]
10:09:26 <lambdabot>  c + (b + (a + 0))
10:09:40 <int-e> > foldr (flip (+)) 0 [a,b,c] -- well let's complete the list
10:09:42 <lambdabot>  0 + c + b + a
10:09:46 <PiotrJander> @pl map (\(i, v) -> vector !! i * v)
10:09:46 <lambdabot> map (uncurry ((*) . (vector !!)))
10:12:36 <amalloy> Psybur: it helps me to think of it like, "in foldr, the result of folding the rest of the list is on the right", and "in foldl, what we've folded up so far is on the left"
10:15:54 <glguy> Oh, fun haddock bug, if you define: data Record = R { this, that :: Int } and export Record and R but not the field accessors, then haddock documents the data constructor as: R Int
10:15:58 * hackage nix-diff 1.0.1 - Explain why two Nix derivations differ  https://hackage.haskell.org/package/nix-diff-1.0.1 (GabrielGonzalez)
10:16:16 <monochrom> heh
10:20:54 <tinytusk> I have written a library that unifies both Gmail and Office365 under a single interface (via a type family). Both mail providers require different “environments” (a la the Reader Monad) for their functionality.
10:21:24 <tinytusk> (One task the environment does is manage delegated OAuth tokens, for example)
10:22:25 <tinytusk> This is what the type family looks like: https://gist.github.com/centromere/d25a1f18637be3f0a92c5a5e0a03e8ea
10:23:20 <tinytusk> I have a single executable which needs to interface with both mail providers simultaneously, at runtime.
10:24:21 <tinytusk> My application itself runs in a Reader Monad whose environment contains, “envGoogle” and “envOffice365” “managers".
10:26:28 <hyperisco> tinytusk, there are no functions in the class, so where is the genericity?
10:26:54 <tinytusk> There are 5 functions in the class.
10:26:55 <hyperisco> oh I misread the indentation, ha!
10:27:15 <tinytusk> Here is a snippet of my application code: https://gist.github.com/centromere/f18c463cdea6c3da4f933cf49ad45ff7
10:28:21 <hyperisco> well that's good, that is just the sort of thing you should be doing
10:28:27 <tinytusk> The issue is here: https://gist.github.com/centromere/e2af35e3eae480b857d68f00169a94f7
10:28:39 <hyperisco> then when it comes time to do offline testing you can write a dummy instance
10:29:02 <hyperisco> and you'd also be surprised in what other situations it makes sense to sandbox part of your program
10:29:23 <tinytusk> I get this error: Could not deduce (HasMailProvider App p) arising from a use of ‘getMailProvider’
10:29:33 <tinytusk> Now, I fully understand why this error is happening.
10:29:47 <tinytusk> What I don’t understand is, from an architectural standpoint, how I should proceed.
10:30:31 <hyperisco> why not just add that constraint then?
10:31:25 <hyperisco> it may also make sense to say  class MailProvider p => HasMailProvider m p where
10:31:53 <hyperisco> which has the added benefit that  HasMailProvider m p  implies  MailProvider p
10:32:09 <hyperisco> cue discussion about arrow directions
10:32:31 <tinytusk> I got an error about needing FlexibleContexts, but I’m not sure if that’s safe to use.
10:33:32 <hyperisco> it is safe
10:34:15 <hyperisco> though, really? I am not sure why
10:36:23 <hyperisco> but say MailProvider did not make sense as a super class, and we were also pained by the verbosity of listing two constraints
10:36:36 <hyperisco> then we can make a constraint alias using ConstraintKinds extension
10:36:39 <Ulrar> Anyone knows how to calculate the square magnitude of a vector in haskell ? Is that what quadrance from Linear.metric is ?
10:37:09 <hyperisco> Ulrar, that is what quadrance is
10:37:20 <amalloy> tinytusk: not really related to your question, but isn't `envGoogle <$> ask` just `asks envGoogle`?
10:37:32 <tinytusk> amalloy: You may be right.
10:37:33 <hyperisco> Ulrar, you should join the cult
10:37:45 <Ulrar> The cult ?
10:38:06 <hyperisco> so, this quadrance stuff comes from a guy who argues we're doing trigonometry wrong
10:38:42 <Franciman> Hi, I've got a sort of dumb question regarding State monad. If I defined the state monad to be (a, s) instead of s -> (a, s)
10:38:47 <Ulrar> Norman J. Wildberger I guess ? He's mentionned in the doc for quadrance indeed
10:38:54 <Franciman> and so define >>= and return accordingly
10:38:58 <Franciman> would there be any issue?
10:39:01 <Franciman> I can't see any
10:39:09 <hyperisco> Ulrar, mhm. Instead of length you have quadrance, and instead of angle you have spread.
10:39:12 <Ulrar> But I'll be honest, I have very little understand of the regular way to do trigonometry :)
10:39:34 <Ulrar> I see
10:39:50 <mnoonan> Franciman: well, you'll need to dig into how you really intend to define >>= and return to answer that
10:40:09 <Franciman> I would like to mimick State totally
10:40:18 <Ulrar> I'm not getting the results I want from the whole thing, so I'm trying to check it line by line, I figured I might have understood quadrance wrong
10:40:23 <Ulrar> but I guess my problem is elsewhere
10:40:24 <Ulrar> thanks !
10:40:25 <Franciman> I mean, the question is, to have the same semantics as State, can I use (a, s) instead of s -> (a, s) ?
10:40:25 <mnoonan> for example, how are you going to make a "return :: a -> (S, a)" for your state type S?
10:40:53 <Franciman> ah
10:40:59 <Franciman> that's an interesting question :P
10:41:03 <Franciman> ok thanks
10:42:20 <tinytusk> hyperisco: Thanks for your help. I got it to compile and added MailProvider as a superclass of HasMailProvider.
10:42:40 <hyperisco> the misconception is in the same… State is not a state, it is a transition
10:42:51 <hyperisco> is in the name*
10:43:21 <Franciman> hyperisco, yeah, basically It's computations on a given state
10:43:37 <Franciman> I didn't think about it, thanks
10:45:07 <mnoonan> Franciman: incidentally, if you dig into how you could define return and >>= for (S,a), you might re-invent the Writer monad
10:45:14 <hyperisco> and 'a' is the label type
10:45:33 <mnoonan> e.g. you *can* make "return :: a -> (S, a)" if you have a way of conjuring a value of type S out of thin air, which mempty gives you
10:45:38 <Franciman> mnoonan, you mean (memty, a) ?
10:45:45 <Franciman> ah yes!
10:45:46 <Franciman> ahah
10:45:47 <Franciman> ty
10:46:30 <hyperisco> amusingly, that makes this version of State an Alternative/MonadPlus
10:47:29 * hackage type-of-html 1.3.1.1 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.3.1.1 (knupfer)
10:48:17 <Ulrar> hyperisco: So if I understand this correctly, the norm of a vector is it's length, and the quadrance is the norm squared, and we should use that to avoid the square root calculation
10:48:44 <Ulrar> norm is magnitude and quadrance is square magnitude
10:49:25 <hyperisco> yes but the whole justification of it is more than avoiding a calculation
10:49:40 <ClaudiusMaximus> what are my chances if i want to cross-compile a GUI program for Windows from Linux?
10:52:00 <Xal> ClaudiusMaximus: what kind of gui?
10:53:03 <ClaudiusMaximus> Xal: gtk would be nice, but if that's too hard then winapi would be an ok fallback
10:53:38 <ClaudiusMaximus> i don't need much fancy
10:55:18 <ClaudiusMaximus> maybe i could embed a webserver and serve a gui that way
10:59:24 <EvanR> ClaudiusMaximus: mad science idea... use a browser-based front end like node webkit to interact with your program via websocket
10:59:55 <metahumor> thanks for introducing me to this Q-trig cult
11:00:01 <metahumor> its much better than the tau cult
11:00:15 <kamyar> What is the problem with this code:
11:00:19 <kamyar> avg :: (Fractional a, Foldable t) => t a -> a
11:00:19 <kamyar> avg x = sum x / length x
11:00:43 <EvanR> :t sum x / length x
11:00:44 <lambdabot> error:
11:00:44 <lambdabot>     • Couldn't match expected type ‘[Int]’ with actual type ‘Expr’
11:00:44 <lambdabot>     • In the first argument of ‘sum’, namely ‘x’
11:00:46 <hyperisco> yeah, if the tau cult is twice as good as the mainstream, then Q-trig is squared as good
11:00:55 <EvanR> :t \x -> sum x / length x
11:00:56 <lambdabot> error:
11:00:56 <lambdabot>     • Could not deduce (Fractional Int) arising from a use of ‘/’
11:00:56 <lambdabot>       from the context: Foldable t
11:01:04 <EvanR> length returns an Int
11:01:23 <hyperisco> try Data.List.genericLength
11:01:36 <EvanR> :t \x -> sum x / genericLength x
11:01:37 <lambdabot> Fractional a => [a] -> a
11:01:57 <EvanR> what happened to Foldable
11:02:09 <hyperisco> it is from the Data.List module…
11:03:13 <hyperisco> :t ala Sum foldMap (const 1)
11:03:15 <lambdabot> error:
11:03:15 <lambdabot>     • Could not deduce (Foldable ((->) b0))
11:03:15 <lambdabot>         arising from a use of ‘foldMap’
11:03:27 <hyperisco> well the chances of that working were really slim… can't remember how to use that
11:03:45 <mnoonan> :t foldMap `ala` Sum
11:03:46 <lambdabot> (Unwrapped m ~ t a, Unwrapped (t a -> m) ~ (a -> m), Monoid m, Foldable t, Rewrapped (t a -> m) m, Rewrapped m (t a -> m)) => Sum (Unwrapped (t a -> m))
11:04:15 <mnoonan> > (foldMap `ala` Sum) [1..10]
11:04:17 <lambdabot>  error:
11:04:17 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
11:04:18 <lambdabot>                    with actual type ‘Sum (Unwrapped ([a0] -> m0))’
11:04:27 <amalloy> :t ala
11:04:28 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
11:06:01 <glguy_> :t Sum `ala` foldMap
11:06:02 <lambdabot> (Num b, Foldable t) => t b -> b
11:06:30 <hyperisco> yeah but that isn't what I meant… I am just using the wrong tool
11:07:09 <hyperisco> :t getSum . foldMap (const (Sum 1))
11:07:10 <lambdabot> (Num c, Foldable t) => t b -> c
11:07:13 <hyperisco> golf away
11:13:12 <glguy_> :t from integral . length
11:13:13 <lambdabot> error:
11:13:13 <lambdabot>     • Couldn't match type ‘Int’ with ‘p Integer (f Integer)’
11:13:13 <lambdabot>       Expected type: t a -> p Integer (f Integer)
11:13:23 <glguy_> Thanks auto correct :)
11:13:32 <hyperisco> that isn't the same
11:13:33 * hackage mongoDB 2.3.0.1 - Driver (client) for MongoDB, a free, scalable, fast, documentDBMS  https://hackage.haskell.org/package/mongoDB-2.3.0.1 (VictorDenisov)
11:14:28 <hyperisco> modular arithmetic is like auto correct
11:15:22 <Rembane> Hilarious and dangerous?
11:15:29 <glguy_> It'll be the same for a reasonable Num instance
11:31:17 <ddellacosta> not exactly a haskell question, but...anyone know how to customize the ghci prompt when using intero?
11:31:33 <ddellacosta> I just realized it wasn't picking up my prompt setting from `.ghci`
11:34:39 <beauby> Not exactly a Haskell question either but is there any "monospace" font that displays some kind of arrow spanning two characters? (So that I can have nice unicode arrows in emacs to replace -> without breaking alignment)
11:35:35 <glguy> FiraCode
11:37:43 <liste> also https://github.com/i-tu/Hasklig/
11:38:01 <beauby> glguy: Damn, this is even better than what I was looking for
11:38:01 <liste> written by my classmate in uni :) I was quite surprised when I found out
11:38:22 <metahumor> why does -Wtype-defaults complain so much about (^2) in the context of a f :: Integer -> Integer; f = (^2)
11:38:44 <glguy> :t (^) -- because of that 'b'
11:38:45 <lambdabot> (Num a, Integral b) => a -> b -> a
11:39:22 <metahumor> so f = (^ (2 :: Integer)) is the best way of getting rid of that warning?
11:39:22 <glguy> :t (3 :: Double) ^ (2 :: Integer)
11:39:23 <lambdabot> Double
11:40:10 <glguy> Int will be big enough, it's promised to be able to value values up to 2^29-1
11:41:25 <glguy> As long as you use Int or Integer, however, there's a rewrite rule that will transform that into a multiplication with *
11:42:04 <[exa]> liste: mind asking your classmate if he'd like this packaged for debian? (the font is pure gold)
11:45:50 <tinytusk> In GHC 8.2, what’s the best way to create a TQueue (Foo p) with a typeclass constraint on `p`?
11:45:55 <tinytusk> Or is this a futile effort?
11:55:13 <fbauckho> heeeeeey everybody it's the guy whose xmonad got destroyed by arch updates a while ago
11:55:20 <fbauckho> guess what
11:55:44 <fbauckho> I updated again and now I've got spicy new mysterious errors!
11:56:20 <glguy> Sounds like you're getting the complete Arch experience!
11:56:24 <fbauckho> yay!
11:58:14 <fbauckho> so when I try to run my (rebuilt) xmonad executable, it complains that it can't load libHSprocess-something-ghc8.2.1.so
12:00:15 <fbauckho> But the version of ghc I have installed is ghc 8.2.2
12:01:08 <fbauckho> so the libs I can found using pacman -Qs I can only find ghc 8.2.2 libs
12:03:14 <int-e> fbauckho: I guess that means you have to rebuild xmonad again
12:04:51 <liste> [exa]: well I haven't seen him in a while and I don't use Debian, so I guess I'm not the right person to do that :)
12:08:00 <nullie> liste: wow, that's interesting approach
12:09:53 <[exa]> liste: going to try the font around a bit and ask him myself then :] thanks
12:15:59 <fbauckho> int-e while figuring out how, my memories are slowly coming back to me:
12:17:31 <fbauckho> It looks like the pacman xmonad is a red herring and I need to use cabal. When trying to reinstall it there it complains about missing files in Data.Default
12:18:38 <fbauckho> In my command history, I see that the last time my things broke, I just cabal reinstalled the entire tree xmonad depends on
12:19:13 <fbauckho> Do you think it's a reasonable if I just try to do that again?
12:19:59 <int-e> hmm, somehow I've dodged this bullet (I use Arch linux on one machine but I build my own ghcs... the distro ghc is only involved in building the first ghc I actually use...)
12:21:22 <nullie> eh, emacs is not supported
12:24:38 <int-e> glguy: Looking more closely it's almost brilliant, putting *only* shared library versions of haskell packages into a rolling release distribution without support for slots. (I was going to suggest building xmonad with haskell libraries linked statically, but it won't work)
12:24:55 * hackage logict-state 0.1.0.4 - Library for logic programming based on haskell package logict  https://hackage.haskell.org/package/logict-state-0.1.0.4 (AtzeDijkstra)
12:25:02 <int-e> (not without recompiling everything anyway, that is)
12:29:35 * hackage chr-pretty 0.1.0.0 - Pretty printing for chr library  https://hackage.haskell.org/package/chr-pretty-0.1.0.0 (AtzeDijkstra)
12:33:12 * hackage chr-data 0.1.0.0 - Datatypes required for chr library  https://hackage.haskell.org/package/chr-data-0.1.0.0 (AtzeDijkstra)
12:38:19 * hackage chr-core 0.1.0.0 - Constraint Handling Rules  https://hackage.haskell.org/package/chr-core-0.1.0.0 (AtzeDijkstra)
12:40:31 * hackage chr-parse 0.1.0.0 - Parsing for chr library  https://hackage.haskell.org/package/chr-parse-0.1.0.0 (AtzeDijkstra)
12:43:55 * hackage chr-lang 0.1.0.0 - AST + surface language around chr  https://hackage.haskell.org/package/chr-lang-0.1.0.0 (AtzeDijkstra)
12:44:35 <jpcooper> Hello. Does anyone know of something which will generate Haskell data definitions given a Swagger schema?
12:45:31 * hackage uhc-util 0.1.7.0 - UHC utilities  https://hackage.haskell.org/package/uhc-util-0.1.7.0 (AtzeDijkstra)
12:46:23 <dmj`> jpcooper: doesn’t exist
12:46:36 <dmj`> the other way does though
12:47:42 <dmj`> It’s a hairy template haskell task, would be a heroic undertaking though.
12:47:49 <jpcooper> dmj`, At least that does. I think I'll just write the data definitions by hand. Can you recommend a nice automated JSON serialisation library?
12:49:30 <dmj`> jpcooper: you can write your API in servant, then generate a swagger spec from that, and using servant-swagger there’s a way to check if your swagger models match the json produced from your ToJSON instance I believe.
12:49:53 <jpcooper> Brilliant. Thanks
12:50:13 <dmj`> jpcooper: http://hackage.haskell.org/package/servant-swagger-1.1.4/docs/Servant-Swagger-Test.html#v:validateEveryToJSON
13:10:04 * hackage hapistrano 0.3.5.1 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.3.5.1 (juanpaucar)
13:26:25 <kadoban> Is it me or are hackage "revisions" super janky? I really don't understand what the reasoning is behind not at least modifying the tarball when revisions are done ... I mean the sourcecode you can see on the site just blatantly doesn't match what you actually get when you install the thing then, right? It's "just" the metadata, but that seems to include the ability to add dependencies and etc.
13:26:37 <kamyar> Please check my code error
13:26:38 <kamyar> http://lpaste.net/2052315453417586688
13:26:48 <kamyar> How should I fix line 30?
13:27:40 <Rembane> kamyar: Replace $ with .
13:27:57 <Rembane> kamyar: $ and <$> never play well together when I use them so I guess it could be the same for you.
13:27:58 <kamyar> Rembane: Did not fix
13:28:01 <Rembane> kamyar: Same error?
13:28:21 <kamyar> Rembane: 2 errors
13:28:42 <Rembane> kamyar: You could move avg . nsec <$> to line 29 just before mapM.
13:28:46 <kadoban> kamyar: What's the type of 'nsec' ?
13:29:06 <kamyar> Rembane: You are absolutely wrong! I can not combine avg with nsec
13:29:22 <Rembane> kamyar: Cool.
13:29:33 <kamyar> Rembane: avg gets a list while nsec gets a single item
13:29:45 <ezyang> kadoban: Revisions have a huge discoverability problem, but I do think they solve a real problem
13:29:56 <Rembane> kamyar: What's the return type of nsec?
13:29:58 <kamyar> Rembane: You have ignored priority
13:30:10 <ezyang> which is that Hackage is a "distribution", and distributions generally need to be able to unilaterally make changes to upstream packages to make them play nice in the idstro
13:30:16 <kamyar> :t nsec
13:30:17 <lambdabot> error: Variable not in scope: nsec
13:30:31 <kamyar> :m System.Clock
13:30:36 <kamyar> :t nsec
13:30:37 <lambdabot> error: Variable not in scope: nsec
13:31:00 <kamyar> nsec :: TimeSpec -> GHC.Int.Int64
13:31:17 <kadoban> ezyang: I'm not really clear on exactly what it's even supposed to be used for.
13:31:40 <ezyang> kadoban: It's supposed to be used to fix metadata problems that stop the dep solver from working
13:31:53 <kamyar> no one can help me?
13:31:57 <ezyang> e.g., a package incorrectly advertising that it works with another package version that it doesn't actually work with
13:32:38 <ezyang> but really what should have been done is to let Hackage unilaterally issue new versions of packages
13:32:48 <monochrom> No one can help you. Everyone who helps you are absolutely wrong!
13:33:09 <kadoban> ezyang: Hmm. Yes that at least sounds a lot less weird to me ^  At least versions are already a thing I need to know about and work fairly okay.
13:33:40 * hackage fltkhs 0.5.4.3 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.4.3 (deech)
13:34:04 <yoho> kamyar: what's the type of avg $ nsec <$> rres?
13:34:20 <yoho> once you have the answer to that, what's the issue with what you're trying to do?
13:35:27 <kamyar> yoho: rres is holding IO [TimeSpec]
13:36:04 <kadoban> ezyang: Plus it seems like authors themselves are allowed to do revisions, which ... I mean why not just do a new version.
13:36:09 <yoho> 1) that's not what I asked 2) that's wrong
13:37:17 <ezyang> kadoban: Well, revisions happen to be a lower friction way to make "new releases" :)
13:37:31 <ezyang> oh, the other reason is the semantics are different
13:37:40 <kamyar> yoho: nsec holds Int64 and avg $ nsec <$> rres must return IO Float
13:37:43 <ezyang> releasing a new revision causes old revisions to be deselected from depsolving
13:37:49 <ezyang> a new version adds another candidate for depsolving
13:38:49 <yoho> kamyar: sure, but what does type does it actually have
13:40:00 <kamyar> yoho: how to check?
13:40:46 <kadoban> Yeah I guess. I can't think of why you'd actually need that meaning difference per se though. I think my big complaint though is just that it seems to make it intentionally hard to review code before I install it or to know when I have to review again.
13:40:53 <yoho> kamyar: look carefully
13:41:17 <yoho> run through the types of the individual things and see what the resulting type is
13:41:20 <ezyang> kadoban: That is why I think revisions are the wrong way of solving a real problem :)
13:41:24 <robertkennedy> How can I debugging "Access violation in generated code when reading <16 digit hex number>"? I compiled with prof but it seems to crash through -xc (before a stack could dump, I guess)
13:41:30 <yoho> you should be able to do this in your head
13:42:00 <kadoban> Alrighty, ya thanks for confirming/explaining.
13:42:20 <glguy> kadoban: Revisions don't change the code, so if all that's changed about your build plan is the revision numbers you don't have to do anything (coming in late so maybe I missed something)
13:42:42 <ezyang> glguy: Can't they affect how your code is built though?
13:42:53 <kadoban> glguy: They seem to allow adding dependencies though (in the setup stuff at least), so I still have to check if it added anything, right?
13:42:55 <ezyang> so if you're strictly auditing (which no one ever does) you still have to check
13:43:05 <glguy> kadoban: If your build plan didn't change then nothing was added
13:43:21 <glguy> ezyang: There's a restricted set of things that can change, which thing are you focusing on there?
13:43:58 <kamyar> yoho: I knwo but watch the code is really complicated
13:44:03 <ezyang> CPP macro could resolve differently :o)
13:44:25 <glguy> by which mechanism ?
13:45:35 <glguy> revisions are targeted at changing version constraints. If your build plan is the same it shouldn't matter that the constraints changed
13:46:00 <yoho> kamyar: well it's good practice for you then
13:46:06 <ezyang> ...in Setup.hs? (I'm grasping now :)
13:47:00 <glguy> You'd have caught this insane Setup.hs in your code review :)
13:47:13 <glguy> but OK, if that's the attack vector I guess you win!
13:48:00 * hackage vinyl-utils 0.3.0.1 - Utilities for vinyl  https://hackage.haskell.org/package/vinyl-utils-0.3.0.1 (mjmrotek)
13:49:13 <fbauckho> int-e I cabal reinstalled everything, but it doesn't seem to change anything
13:49:15 <chaoticsun> Hello. I'm trying to configure the Atom Text editor in Linus and running into difficulties with the latest build.
13:49:31 <chaoticsun> Linux...
13:50:02 <Rembane> chaoticsun: Have you tried the #atom channel?
13:50:20 <chaoticsun> Is there a proper way to send the output to IRC for assistance? Copy/Paste. It's actually stack build dependencies messing me up.
13:50:20 <Rembane> chaoticsun: Or do you try to combine Atom and Haskell? :)
13:50:27 <Rembane> chaoticsun: Ah.
13:50:58 <chaoticsun> Yes. I'm following the simonmichael / hasekell-atom-setup on github
13:51:01 <fbauckho> (actually it might be weirder than that: when I compile with -dynamic and then run ldd on the executable, it seems to include the right version of HSprocess-something. Yet, when I run it, it complains about not being able to find the wrong one)
13:52:12 <fbauckho> (by the right or wrong one, I mean the ghc2.2.2 and 2.2.1 versions, respectively)
13:53:07 <chaoticsun> All the errors appear to be because of dependencies mismatch because version numbering has changed. All the deps appear to be within the correct matches.
13:53:30 <chaoticsun> ex: In the dependencies for Cabal-1.24.2.0:
13:53:30 <chaoticsun>     process-1.6.1.0 from stack configuration does not match >=1.1.0.1 && <1.5 (latest matching
13:53:30 <chaoticsun>                     version is 1.4.3.0)
13:53:30 <chaoticsun> needed due to ghc-mod-5.8.0.0 -> Cabal-1.24.2.0
13:54:09 <chaoticsun> Notice how the point releases numbering system is different than the requirements.
13:54:43 <int-e> fbauckho: doesn't xmonad itself build an auxiliary executable based on your configuration?
13:55:02 <glguy> chaoticsun: You can paste the command you're trying to run and all the output into a pastebin like lpaste.net
13:55:06 <int-e> fbauckho: no idea where that is stored or how to rebuild it, but somebody here is bound to know
13:55:09 <glguy> and then share that with the channel
13:55:36 <chaoticsun> glguy: thanks, I'll give that a try and send a link.
13:57:38 <chaoticsun> glguy: will this help? http://lpaste.net/361171
14:00:36 <glguy_> chaoticsun: your global stack resolver is incompatible with the version of ghc-mod you're trying to build
14:02:00 <xpika> if there a function in prelude that satisfies \x -> fmap (const x)
14:02:10 <glguy_> <$
14:03:24 <chaoticsun> Can I change the resolver: lts-10.1 to the previous version?
14:03:40 <MarcelineVQ> chaoticsun: in case it's applicable, my experience is the correct way to use ghc-mod with stack and atom is to run  stack build ghc-mod  in each project you have so that each project has in scope the right ghc-mod for its resolver
14:03:45 <glguy_> You might be able to do it with a command line flag
14:04:13 <chaoticsun> I'm referring to the resolver: ... line in ~/.stack/global-project/stack.yaml file.
14:04:19 <glguy_> I don't use stack or ghc-mod, I'd go with MarcelineVQ 's help 😀
14:04:48 <metahumor> the latest lts release that has ghc-mod as a package is 8.24
14:04:58 <chaoticsun> Much appreciated guys. I will give it a try.
14:04:58 <fbauckho> int-e I hadn't even tried running whatever pacman puts into /usr/bin/xmonad, I just compiled and ran a "import XMonad; main = xmonad def" file
14:05:06 <kadoban> MarcelineVQ: You can do it once per compiler if you do 'stack build --copy-compiler-tool ghc-mod'
14:05:55 <MarcelineVQ> kadoban: good info thank you, I like to be general for this sort of thing in case I'm not smarter than the tool hehe
14:06:05 <kadoban> :)
14:07:23 <Xnuk> package "basement" compile fails in Arch Linux with: "Size_hsc_make.o: requires dynamic R_X86_64_32 reloc which may overflow at runtime; recompile with -fPIC", even if i do `stack build --ghc-options="-fPIC"`
14:07:33 <Xnuk> could somebody help me please
14:07:39 <jchia_1> chaoticsun: I understand you are trying to setup Atom+Haskell. The instructions on https://github.com/simonmichael/haskell-atom-setup are quite old (6mo). The feasibility of the instructions depends on which version of GHC you are trying to use and the stack resolver you are trying to use for building your project and building your tools. There's no mention of stack resolver in the instructions. ghc-mod is known to lag new GHC features.
14:07:40 <jchia_1>  Lots of things can go wrong.
14:09:26 <jchia_1> Do you have a hard constraint to use Atom? I don't know how to make it work. But I know how to make VSCode + Haskell work. Maybe the steps I do can also be applied to Atom. Basically, I use haskell-ide-engine from the github.
14:09:31 <lyxia> this looks like the usual mess on arch
14:10:00 <geekosaur> Xnuk, any more the answer is "don;t use Arch". :( there's a hack for stack that sometimes works but I don't know how it works with very recent versions of stack
14:10:08 <lyxia> there are a few stackage tickets with workarounds
14:10:38 <fbauckho> int-e now I did (after pacman reinstalling for good measure) and it behaves the same way.
14:10:39 <geekosaur> 2017 Dec 20 18:07:24 <cocreature>	JazzyEagle: what worked for me is install ncurses5-compat-libs from the AUR and set "ghc-build: nopie" in ~/.stack/config.yaml
14:11:13 <Xnuk> (cry)
14:11:31 <geekosaur> I *thought* recent stack was supposed to figure this out for you, but recognizing the specific case may be too unreliable given how many different weird Linux distributions there are, all with their own idiosyncrasies
14:12:11 <MarcelineVQ> Xnuk: it's probably no-pie you want   I have   ghc-build: nopie   at the bottom of my .stack/config.yaml   and use the  ghc-static  lib from pacman and ncurses5-compat-libs from the AUR
14:12:15 <geekosaur> (the real problem is the GHC binaries were built on debian, and debian 7 did ncurses 6 and changed the executable format at the same time. Arch doesn't support the latter, but has ncurses 6.)
14:12:26 <MarcelineVQ> oh geekosaur beat me to it hoho
14:13:13 <Xnuk> I'm already using nopie ghc for stack
14:13:40 <jchia_1> I'm using Arch Linux with the ncurses5-compat-libs AUR package.
14:13:46 <MarcelineVQ> but do you have this setting enabled?
14:13:55 <fbauckho> anyways I need some sleep, so I guess I'll just try to remember everything that's wrong and then ask people tomorrow. Thanks for your help int-e!
14:13:58 <jchia_1> Right now it's OK.
14:14:21 <jchia_1> And I don't use any pacman Haskell packages.
14:14:48 <lyxia> it's ok after the fix but figuring it out is such a waste of time
14:15:16 <Xnuk> MarcelineVQ: not enabled, I'll give a try
14:16:16 <jchia_1> I didn't do any explicit configuration about 'nopie' but my built binaries generally get put into .stack-work/install/x86_64-linux-tinfo6-nopie
14:19:28 <geekosaur> jchia_1, that's what I understood recent stack to be doing. but there are enough reports otherwise that either a lot of people are still running old versions or the check is unreliable for some reason
14:20:34 <jchia_1> geekosaur: OK, with older versions of tools or Arch Linux packages, I don't know what would happen.
14:21:12 <jchia_1> Some people who use Arch Linux misunderstand and seem to hate Haskell. https://www.reddit.com/r/archlinux/comments/7jtemw/which_package_do_you_hate_the_most/
14:21:19 <geekosaur> also you still lose if you have any Arch-installed Haskell libs around, but in a different way
14:22:19 <geekosaur> well, not if you have stack forced to use its own ghc in all cases.
14:22:54 <geekosaur> I still thik Arch brought this on itself. I understand they wanted to make pandoc a little more tractable, but they seem to have created a lot more problems for themselves (and us) than they solved
14:23:46 <MarcelineVQ> tractable is not the word I would use for pandoc now that it comes with 170 packages tacked on :'(
14:24:16 <geekosaur> that was more or less what I was about to write. they traded one problem for another and arguably the new one is worse than the old
14:24:36 <MarcelineVQ> it's enough to make a person want to try nixos
14:24:44 <geekosaur> and brings even more problems for anyone who wants to use Haskell stuff otger than pandoc
14:25:03 <fraktor> I tried to install hlint and ghc-mod with cabal, but I keep getting messages that each package is likely to be broken.
14:25:38 <fraktor> Also, even though it says that hlint was installed, I'm not able to run the hlint command.
14:25:52 <geekosaur> make sure ghc-static package is installed, and *no* other haskell library packages from arch. or force dynamic build.
14:26:07 <geekosaur> as for the latter, make sure ~/.cabal/bin is in $PATH
14:26:22 <Xnuk> "ghc-build: nopie" hack just worked, thanks
14:26:25 <fraktor> geekosaur: Are you talking to me?
14:26:32 <geekosaur> fraktor, yes
14:26:32 <jchia_1> MarcelineVQ: Incidentally, I recently started to tinker around with NixOS.
14:26:48 <fraktor> I'm running Ubuntu, not arch. But I'll check my path
14:27:15 <geekosaur> ubuntu would be different, I have hard there are issues with the most recent ubuntu release but no details
14:27:29 <geekosaur> (with respect to its ghc packages)
14:28:55 <fraktor> Well, it looks like hlint and ghc-mod both work, so
14:28:58 <fraktor> Thank you for your help.
14:29:35 <MarcelineVQ> jchia_1: it's gaining popularity, though that could just be a bias based on the crowd we hang out with
14:30:36 <jchia_1> MarcelineVQ: I was hoping it would be bring 'functional/declarative' relief to the usual 'imperative' and adhoc mess of configuring a Linux distro.
14:31:28 <geekosaur> it's just a *different* ad hoc mess
14:31:42 <geekosaur> this has more to do with linux than with the tools, tbh
14:36:10 <ph88> hey guys, does anyone know a good library or algorithm for the following problem? I have a bunch of switches to flip, the order of when they flip matters, only some orders lead to a correct (result :: Bool) now i like to know which switches depend on order (and which should go before them and after) and which switches don't care about the order
14:38:52 <beauby> ph88: looks like a SAT solver would be handy
14:39:21 <beauby> though you're not just interested in the satifiability
14:39:38 <jchia_1> If I get "executable-name: <<loop>>" when running my program, does it mean that an infinite loop has been detected? How do I figure out where it's happening?
14:39:46 <hpc> ph88: perhaps start with something like data SwitchChoice = Specific Int | AnyOne [Int] | AllUnordered [Int]?
14:40:48 <hpc> ultimately you're making a tree of switch decisions that leads to true when traversed
14:40:52 <hpc> and then compressing it in some way
14:41:45 <Cale> jchia_1: Yes, that's what it means. It *may* be helpful to compile with profiling on and run with +RTS -xc
14:43:23 <Cale> jchia_1: If your program is reasonably small, you can also usually just look for places where you're defining a variable recursively. Be wary of cases where you're shadowing a variable and then attempting to use the variable from the outer scope in a definition (getting recursion when you didn't intend it)
14:43:25 <ph88> hpc, how do you know it will be a tree ?
14:44:08 <hyperisco> or you might be using some recursive hof wrong, like some or many
14:44:24 <[matsalleh92]> Hello there. I'm just getting started with haskell. I'm going through learnyouahaskell and trying some of the problems. I'm stuck on problem (https://wiki.haskell.org/99_questions/1_to_10). Can anyone tell me why these two functions don't behave the same? https://pastebin.com/f72e6GMJ elem head is the same as an equality check no?
14:44:42 <[matsalleh92]> s/problem/problem 9
14:45:13 <hpc> ph88: actually probably a list of trees
14:45:21 <hpc> but once you pick your first switch it's a classic decision tree
14:45:36 <nullie> [matsalleh92]: no, elem head means checking first list of (myCompressNest xs)
14:45:39 <Cale> http://lpaste.net/361174 -- repaste of [matsalleh92]'s code
14:46:37 <ph88> hpc, i can randomly pick a switch and then randomly pick all the other switches .. where does the tree come in ?
14:46:41 <Cale> x `elem` head ys  means that x occurs anywhere in the list  head ys
14:46:58 <Cale> [x] == head ys  means that the list  head ys  is exactly [x]
14:47:24 <Cale> Note that ys here,  myCompressNest xs, is a list of lists, so its head is itself a list.
14:47:36 <nullie> ok
14:48:26 <Adluc> Hello guys, how can I transform this blob: print $ runState (evalM' sample1) initStateM
14:48:46 <Adluc> into something like: foldM initStateM [sample1, sample2]   (just for illustration purpose)
14:48:55 <Cale> In particular, though you might expect all the elements of head (myCompressNext xs) to be equal, it might be a list of the form [x,x] or [x,x,x]
14:49:05 <hpc> ph88: say you start at a node "pick switch 1"
14:49:13 <Cale> So the two versions of the function will behave differently at that point
14:49:19 <jchia_1> Cale: Found it.
14:49:29 <hyperisco> by the looks of things,  (\x -> runState (evalM' x) initStateM)  is a start
14:49:34 <hpc> ph88: the decision sub-trees below that node are all possible sequences of switch choices starting from the state of the current node
14:49:43 <hpc> (which is that switch 1 is picked)
14:49:43 <Cale> jchia_1: cool -- those can be really obnoxious to track down sometimes
14:49:47 <hyperisco> then you can map this over a list of samples
14:49:55 <hpc> ph88: if you start from "pick switch 2", there's different subtrees
14:50:18 <Adluc> hyperisco: will think about it, thanks
14:50:31 <hpc> ph88: at the leaves of each tree is the result for the sequence of node picks that takes you from the root to that leaf
14:50:57 <jchia_1> Cale: It was a one-character typo. I was essentially doing this: "let m = insertMap 1 1 m :: Map Int Int"
14:50:59 <ph88> hpc, when i have to choose between x amount of nodes the decisions below them all are same: all the remaining switches
14:51:21 <hpc> ph88: just don't include those nodes in the tree
14:51:37 <ph88> all switches need to be included
14:52:05 <hpc> i mean like, say you have two switches
14:52:44 <hpc> the tree is Root [Pick 1 [Pick 2 []], Pick 2 [Pick 1 []]]
14:52:59 <hpc> you just don't include nodes for Pick 1 [Pick 1 []] and such
14:53:02 <hpc> or Pick 1 []
14:53:17 <ph88> what's Pick 1 ?   if there is a Switch 1 it can either be True or False
14:53:26 <hpc> ah
14:54:14 <hpc> in that case you can include Pick 1 []
14:54:20 <hpc> and picking a switch is just setting it to true
14:54:27 <hpc> assuming they start at false
14:54:31 <ph88> my input would be like  [ (switches :: [Bool], result :: Bool)  ]  <-- all possible combinations
14:55:06 <ph88> where result is False that order if switches didn't work out
14:55:17 <hpc> wait, so
14:55:25 <ph88> when result is True ... it's nice but that doesn't tell me anything about the order of switches yet
14:55:32 <hpc> is "flip 1, then 2" the same as "flip 2, then 1"?
14:55:54 <ph88> if i flip Switch 1 to True and Switch 2 to False   that might give a different result than switch 2 to False and switch 1 to True
14:56:07 <hpc> ah
14:56:22 <ph88> if the order matters for these switches then there is a dependency of order between them
14:56:41 <ph88> if the order does not matter they probably still need to be in that state (True or False) but without order dependency
14:56:54 <hpc> so a switch's state is more like (index, Bool)
14:56:59 <ph88> ye
14:57:09 <hpc> and switches :: [(index, Bool)] with the condition that all indexes up to n are used
14:57:14 <ph88> yes
14:57:42 <hpc> cool, that's still a decision tree
14:57:51 <ph88> as a side note: it can also be that a switch state doesn't matter to the result  ... this is also an interesting case .. but i can worry about it later
14:58:19 <ph88> alright decision tree sounds good to me .. but i'm starting from a list
14:58:32 <[matsalleh92]> Cale, nullie : So in other words. [x] == [x] is true but [x] == [x,x] is false. x elem [[x,x,x,x,x,x]] is true?
14:59:09 <nullie> [matsalleh92]: no, x `elem` [x,x,x,y,z] is true, and your won't typecheck
14:59:22 <hpc> ph88: so the function you're traversing has the type [Bool] -> Bool?
14:59:38 <ph88> basically yes ..
14:59:49 <hpc> then you don't have temporal ordering at all
15:00:03 <hpc> [True, False] doesn't tell you which switch was flipped first
15:00:06 <ph88> probably something like [(Bool, switchID :: Int)] -> Bool
15:00:43 <Adluc> hyperisco: m = (\x -> runState (evalM' x) initStateM)
15:00:49 <Adluc> sequence [(m sample1), (m sample2)]
15:00:57 <Adluc> this is what i came up with and needed :)
15:00:58 <ph88> well either i need to include the switch ID or i need to program in such a way that the input order is always the same .. but then the output should contain indexes to indicate how things were moved around
15:00:59 <Adluc> thanks
15:01:14 <Adluc> i will also fmap it beforehand
15:01:16 <[matsalleh92]> nullie: okay is x elem (head [[x,x]]) true?
15:01:23 <hyperisco> cool, have fun
15:01:38 <nullie> [matsalleh92]: yes
15:02:20 <[matsalleh92]> nullie: think I've got it. So my function only works for single sized list of list because == is an exact comparison of the sub list?
15:02:28 <ph88> hpc, i simplified this a bit just to focus on the main thing .. but in reality most switches have a few states and carry a bunch of meta data with them (description and so forth)
15:02:55 <nullie> [matsalleh92]: yes
15:03:03 * hackage JuicyPixels 3.2.9.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.9.2 (VincentBerthoux)
15:03:28 <[matsalleh92]> nullie, Cale : Thanks for your help!
15:05:38 <anon136> my first program http://ix.io/DtW it takes an Int and tells you whether or not it is prime. someone can probably get a good laugh since it could have probably been done with between 1 and 3 lines.
15:08:22 <kadoban> anon136: Nice. Really not bad
15:08:47 <anon136> Thanks man! I'm only a few chapters into my book but I feel pretty good about it.
15:10:05 <emmanuel_erc> hello there
15:10:09 <emmanuel_erc> testing.. 1 2 3
15:10:42 <drdo> error: totally not working
15:11:29 <yoho> > let prime x = if x < 2 then False else not $ elem 0 $ map (mod x) [2..(x-1)]
15:11:31 <lambdabot>  <no location info>: error:
15:11:31 <lambdabot>      not an expression: ‘let prime x = if x < 2 then False else not $ elem 0 ...
15:11:37 <yoho> @ let prime x = if x < 2 then False else not $ elem 0 $ map (mod x) [2..(x-1)]
15:11:50 <yoho> some day I'll learn lambdabot
15:12:01 <yoho> @let prime x = if x < 2 then False else not $ elem 0 $ map (mod x) [2..(x-1)]
15:12:02 <lambdabot>  .L.hs:166:1: warning: [-Woverlapping-patterns]
15:12:02 <lambdabot>      Pattern match is redundant
15:12:02 <lambdabot>      In an equation for ‘prime’: prime x = ...
15:12:33 <yoho> (I think that's because I just defined that in PM?)
15:12:51 <emmanuel_erc> Is there a function similar to mapAccumL that instead of having a signature like (Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)) instead has one like ((Traversable t, Traversable f) => (a -> b -> (a, c)) -> a -> t b -> (a, f c))?
15:13:15 <emmanuel_erc> In effect you would collect  the second result in a different container?
15:13:33 <emmanuel_erc> After staring at this for a while, this seems impossible.
15:14:04 <anon136> yoho: that uses some syntax I havn't learned anything about yet.
15:14:37 <anon136> ill note it down though for later consideration. thanks.
15:14:55 <yoho> which syntax are you not familiar with?
15:15:05 <yoho> (also, I don't mean that to disparage your effort!)
15:15:12 <anon136> im assuming map is a keyword maybe elem also $
15:15:36 <anon136> just got my book yesterday
15:15:39 <yoho> map is a function that takes a function and applies it to every item in a list
15:15:48 <yoho> > map (+1) [1, 2, 3]
15:15:50 <lambdabot>  [2,3,4]
15:15:53 <anon136> oh cool
15:15:59 <yoho> elem checks if an item is in a list
15:16:05 <yoho> > elem 0 [1, 2, 3, 0]
15:16:07 <lambdabot>  True
15:16:16 <geekosaur> not literally keywords, just predefined functions
15:16:37 <anon136> thats basically my same program isnt it just written better
15:16:52 <yoho> I'm not familiar with the propery description of $, but it essentially puts things in brackets is the easy way to think of it
15:17:08 <lavalike> @src ($)
15:17:08 <lambdabot> f $ x = f x
15:17:10 <yoho> yup anon136, it's the more idiomatic way of writing the same thing
15:17:16 <anon136> thats amazing!
15:17:42 <yoho> @let prime x = if x < 2 then False else not (elem 0 (map (mod x) [2..(x-1)])) -- you could replace the $ with brackets like so
15:17:43 <lambdabot>  .L.hs:166:1: warning: [-Woverlapping-patterns]
15:17:43 <lambdabot>      Pattern match is redundant
15:17:43 <lambdabot>      In an equation for ‘prime’: prime x = ...
15:17:46 <ski> > take 25 (filter prime [0 ..])
15:17:47 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
15:17:48 <yoho> hush lambdabot
15:17:55 <ski> yoho : "I think that's because I just defined that in PM?" -- yes
15:18:10 <ski> > filter prime [0 ..]
15:18:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:18:16 <yoho> how long do these arbitrary definitions stick around for, do you know?
15:18:38 <ski> until anyone does `@undefine', or until lambdabot reboots, whichever occurs first
15:20:08 <yoho> I'll keep that in mind next time I test stuff in PM then
15:20:18 <lavalike> > 65537 `elem` filter prime [0..]
15:20:19 <kadoban> > let p n = if n < 2 then False else not $ any (`divides` n) [2 .. n-1] in p 6
15:20:21 <lambdabot>  False
15:20:24 <lambdabot>  mueval-core: Time limit exceeded
15:20:43 <ski> anon136 : tip : instead of `if blah then False else bleh', you can write `not (blah) && bleh'
15:21:07 <yoho> heh, oops
15:22:13 <int-e> > prime 65537
15:22:14 <lambdabot>  True
15:22:42 <ski> > prime (2^2^5 + 1)
15:22:44 <lambdabot>  False
15:23:29 <int-e> 641 is rather small
15:23:47 <ski> > [(i,n) | i <- [0 ..],let n = 2^2^i + 1,not (prime n)]
15:23:53 <lambdabot>  mueval-core: Time limit exceeded
15:23:58 <int-e> > prime (2^31 - 1)
15:24:04 <lambdabot>  mueval-core: Time limit exceeded
15:24:05 <ski> > head [(i,n) | i <- [0 ..],let n = 2^2^i + 1,not (prime n)]
15:24:07 <lambdabot>  (5,4294967297)
15:24:16 <ski> > take 2 [(i,n) | i <- [0 ..],let n = 2^2^i + 1,not (prime n)]
15:24:18 <lambdabot>  [(5,4294967297),(6,18446744073709551617)]
15:25:07 <int-e> :t prime
15:25:08 <lambdabot> Integral a => a -> Bool
15:25:09 <ski> > 4294967297 `divMod` 641
15:25:11 <lambdabot>  (6700417,0)
15:25:36 <int-e> > (2^64+1) `mod` 274177
15:25:38 <lambdabot>  0
15:25:49 <lavalike> (:
15:25:57 <yoho> @botsnack
15:25:58 <lambdabot> :)
15:26:01 <yoho> for all your hard word
15:26:02 <yoho> work*
15:26:16 <int-e> > (2^128+1) `mod` 59649589127497217
15:26:18 <lambdabot>  0
15:28:09 <lavalike> > (2^256+1) `mod` 1238926361552897
15:28:10 <lambdabot>  0
15:35:22 <int-e> http://www.prothsearch.com/fermat.html suggests that primality of 2^2^33+1 is unknown
15:39:15 <yoho> well why don't we just ask lambdabot
15:39:20 <yoho> we'll have a response lickety-split
15:40:19 <int-e> I know that response. It's " mueval-core: Time limit exceeded"
15:41:12 <yoho> > prime 2^2^33 + 1
15:41:14 <lambdabot>  error:
15:41:14 <lambdabot>      • No instance for (Num Bool) arising from a use of ‘+’
15:41:14 <lambdabot>      • In the expression: prime 2 ^ 2 ^ 33 + 1
15:41:20 <yoho> > prime (2^2^33 + 1)
15:41:27 <lambdabot>  mueval: ExitFailure 1
15:41:35 <int-e> oh right
15:41:36 <yoho> int-e: how you like them apples
15:41:51 <int-e> I didn't consider the memory requirements.
15:42:14 <kadoban> What's the thing to do @let from an lpaste essentially?
15:43:29 <MarcelineVQ> @letpaste 361174
15:43:30 <lambdabot>  .L.hs:165:1: error:
15:43:30 <lambdabot>      Duplicate type signatures for ‘myCompressNest’
15:43:30 <lambdabot>      at .L.hs:161:1-14
15:43:39 <kadoban> Thanks :)
15:45:31 <sebastianrkg> is there an easy way to make a local Scotty + Wai Websockets application accessible to other users on the same Wi-Fi network?
15:45:58 <sebastianrkg> e.g. another person in my house could connect to <my ip>:<the application port> and connect to my app?
15:46:22 <boj> that should be all there is to it
15:46:23 <sebastianrkg> This might have more to do with networking than with Scotty, I'm just not really sure. Networking is definitely my computer science weak point
15:46:38 <geekosaur> that's not up to haskell, but any OS firewalls or router configuration will matter
15:47:24 <sebastianrkg> okay. If the haskell side of things doesn't put any boundaries up, I'll move on to troubleshooting the router and such
15:47:26 <geekosaur> in particular, iirc ubuntu blocks  inbound connections by default
15:47:35 <sebastianrkg> I'm on Windows 10
15:47:40 <geekosaur> windows 10 also does
15:54:30 * hackage weeder 0.1.10 - Detect dead code  https://hackage.haskell.org/package/weeder-0.1.10 (NeilMitchell)
15:56:09 <Adluc> Is there some kind of abstraction over this? runState (foldM (const evalM') "" [sample1, sample2]) initStateM
15:57:44 <johnw> foldM (const f) seems strange
15:58:50 <johnw> I think you just mean: runState (mapM_ evalM' ...) initStateM
15:59:38 <Adluc> johnw: thanks! thats what I was looking for whole evening :D
16:00:13 <Adluc> I tried to satisfy type checked with least resistance
16:00:16 <Adluc> *checker
16:00:41 <johnw> you also probably want execState, since you don't care about the ()
16:03:30 <sebastianrkg> Apparently my home wi-fi works just fine, thankfully. Nothing to fix!
16:04:28 <Adluc> johnw: yeah :) also the execState will be useful, thanks
16:07:20 <dmwit> :t mapM_
16:07:21 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
16:08:26 <dmwit> :t ala Endo foldMap
16:08:27 <lambdabot> Foldable t => t (b -> b) -> b -> b
16:09:03 <dmwit> Hm, not quite.
16:10:40 <sqooq> continuous time is annoying
16:10:51 <sqooq> what does a continuous time integration algorithm even look like
16:11:12 <sqooq> it would have to reference the eventual discrete steps
16:11:52 <ski> perhaps ask c. elliott ?
16:12:09 <boj> yep, ping conal
16:12:15 <sqooq> conal, I've hit another roadblock
16:12:33 <dmwit> sqooq: CASs often have integration algorithms that do not reference discrete steps.
16:12:49 <sqooq> dmwit: interesting.
16:13:07 <dmwit> Though your question might have some context I don't know, one doesn't necessarily need discrete time steps to know that \int x^2 dx = x^3 + C.
16:13:14 <dmwit> x^3/3 + C -- hehe
16:13:31 <sqooq> dmwit: well the problem is that it's just a continuous signal, you may not know what the equation actually is
16:13:39 <sqooq> wait...
16:13:42 <ski> sqooq : for derivatives, you could look up "automatic differentiation" (edwardk has a Haskell package named `ad')
16:13:48 <sqooq> you can't have a non-determined continuous signal can you?
16:14:00 <dmwit> What is a "non-determined continuous signal"?
16:14:03 <sqooq> Idk
16:14:11 <conal> sqooq: even if you approximate the exact continuous integral, the approximation step size has nothing to do with, e.g., display sampling. and in particular, do *not* use euler's method.
16:14:11 <dmwit> What does "non-determined" mean?
16:14:12 <sqooq> a continuous signal that you don't know it's future state
16:14:42 <sqooq> like
16:14:44 <sqooq> a mic's input
16:15:10 <sqooq> but that gets discretized anyways
16:15:12 <dmwit> Is a mic's input continuous?
16:15:13 <ski> dmwit : itym a not necessarily algorithmic signal
16:15:27 <sqooq> maybe I shouldn't worry about that then
16:15:33 <sqooq> As of now
16:15:35 <dmwit> Stepwise linear functions are easy to integrate. =)
16:15:45 <hololeap> i think we all learned something here today
16:15:52 <conal> sqooq: by using an intrinsically continuous/exact specification, you'll have a chance to talk about approximation error and do some intelligent management, investing compute resources where they're most helpful. with a discrete system, an arbitrary error is built into the *specification* :( .
16:16:34 <sqooq> dmwit: it's just the y value * the width of the step right?
16:17:02 <sqooq> I guess that can be the one and probably only thing that's very discrete-like
16:17:08 <sqooq> but I guess it can fit into the continuous system
16:17:11 <conal> sqooq: iirc, i discussed some of these issues in this interview: http://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design
16:17:50 <sqooq> dmwit: aghhhh yeah and the step size is always the same, so the continuous integral is just the current output value*the constant width size (the 1/sampling rate)
16:17:56 <sqooq> ok
16:18:21 <sqooq> and right now I'm working with actual functions, which I can probably do actual integration, or approximate integration using trapezoid rule or whatever
16:18:34 <sqooq> of which the widths are unrelated to any sampling size
16:18:42 <dmwit> sqooq: You might also like "A Pixel Is *Not* A Little Square", which discusses very closely related issues.
16:19:16 <dmwit> "My purpose here is to, once and for all, rid the world of the misconception that a pixel is a little geometric square. This is not a religious issue. This is an issue that strikes right at the root of correct image (sprite) computing and the ability to correctly integrate (converge) the discrete and the continuous.
16:19:36 <dmwit> "
16:19:48 <hololeap> sounds like comonad time
16:20:03 <conal> sqooq: or use something better like a higher order runge kutta. and by all means keep the approximation entirely separate from your ideal continuous specification. makes for more modular apps, and it's then worth developing a good integrator, since it'll get reused.
16:20:44 <sqooq> conal, for the most part I'm working with periodic lines, steps, and sine waves, which I think I can actually do an exact integration of
16:20:53 <conal> sqooq: fun!
16:21:15 <sqooq> conal: but if not, the best I can do is approximate, but it's *not* an approximation in the sense of discrete
16:21:24 <sqooq> it would be calculated at runtime
16:21:29 <[Leary]> Just BTW, audio within a finite bandwidth is /encoded/ discretely, but corresponds to a true continuous signal as per Shannon sampling theorem. Treating it as a stepwise linear function will probably get weird results.
16:22:00 * hackage arbtt 0.10 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.10 (JoachimBreitner)
16:22:11 <conal> sqooq: great. just don't fall into the common habit of identifying approximation stepping with display sampling.
16:23:44 <sqooq> Leary, yeah you're right, I can already see a potential problem. Because the mic input will have a certain sampling rate, my continuous time last-step discretization may have an entirely different sampling rate, then for every sample that my system runs, the linear step function may get evaluated and added multiple times to the integration sum, when it should only be added once
16:23:51 <sqooq> I mean
16:24:32 <sqooq> I can always just figure out a way to let continuous and discrete coexist when needed, but keep it separate, so the discrete signal is processed using traditional DSP
16:24:45 <sqooq> but then my whole system would be useless
16:24:49 <sqooq> for inputs
16:24:52 <sqooq> I'm ok with that tbh
16:24:56 <sqooq> screw inputs
16:26:53 <conal> sqooq: the general scheme i use for time and space is to reconstruct (discrete to continuous) discrete inputs and sample (continuous to discrete) outputs. then all composition is on the continuous type, where nice laws hold, and you can get good results cheaply (w/o the under- or over-sampling that inevitably happen in discrete-based designs).
16:27:53 <sqooq> conal, for an audio signal in realtime how could a reconstruction work. My immediate thought is to just make an exponential curve between each sample, but doing that requires knowing the next sample
16:28:02 <sqooq> :thinking: wait, I guess this is what latency is for anyways
16:28:47 <conal> sqooq: yep. you can spend a small amount of latency to get better interpolation, say via cubic splines.
16:29:16 <sqooq> neat
16:29:30 <sqooq> ok well for now I'm using functions known in advance so I think I'm good
16:29:34 <sqooq> thanks for the illumination y'all
16:29:52 <conal> sqooq: same as mouse motion, which is also continuous but gets sampled before we see it.
16:30:28 <conal> sqooq: discrete systems implicitly choose the worst resampling method, namely piecewise-constant.
16:30:59 <conal> sqooq: it's easy to do so much better, once freed from the discrete mindset.
16:32:48 <sqooq> true
16:32:52 <sqooq> too bad everything is discrete
16:32:53 <sqooq> so like
16:32:58 <sqooq> to do so with say a mic input
16:33:20 <sqooq> I'd need really low level access to make sure it gets reconverted into a continuous signal with minimum latency
16:33:52 <sqooq> otherwise I'm stuck with whatever form I happen to get it with now. But like I said I'll worry about all this later. I started making this continuous time system for non-realtime music anyway
16:33:52 <conal> sqooq: everything *isn't* discrete. it's continuous, and we get partial information about it, namely some samples.
16:34:05 <sqooq> I mean
16:34:11 <sqooq> everything on computers
16:34:14 <sqooq> is done discretely
16:34:15 <conal> sqooq: even computers are continuous. discreteness is just an abstraction.
16:34:31 <sqooq> conal, woah you are like religiously continuous
16:34:32 <sqooq> I like it
16:34:33 <sqooq> haha
16:35:31 <conal> :) .  the discrete mindset has been terribly harmful to people's thinking. "We shape our tools and afterwards our tools shape us." - Marshall McLuhan
16:35:52 <conal> "Language etches the grooves through which your thoughts must flow." - Noam Chomsky
16:36:46 <conal> "The slovenliness of our language makes it easier for us to have foolish thoughts. The point is that the process is reversible." - George Orwell, Politics and the English Language
16:36:57 * hackage pandoc 2.0.6 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.0.6 (JohnMacFarlane)
16:36:58 <conal> another: "That language is an instrument of human reason, and not merely a medium for the expression of thought, is a truth generally admitted." - George Boole, The Laws of Thought
16:37:04 <johnw> we filter an analog world through digital representations, only to render them as analog again when we need to perceive them. Much is lost, but it's easier for us to reason about that intermediate, abstract form.
16:37:48 <yoho> I'd go further in the opposite direction and argue nothing is continuous but pure maths
16:37:58 <yoho> at least as far as we're able to perceive them
16:38:25 <conal> johnw: nicely put!
16:38:50 <EvanR> analog isnt continuous
16:39:08 <EvanR> if you have any bit of white noise, that signal cant be continuous in the school math sense
16:39:27 <conal> johnw: oh! by "that intermediate, abstract form", do you mean discrete or continuous? they show up in both roles from different perspectives.
16:39:36 <EvanR> but you could postulate a finite band width
16:40:04 <johnw> conal: I had meant discrete; and I wonder, does "continuous" consider the quantum level?
16:40:46 <johnw> because with the wave/particle duality, it's almost like actual reality is both smooth and grainy...
16:40:50 <conal> johnw: ah. i think of continuous as easier to reason about. the laws are so simple and correct.
16:41:30 <johnw> conal: ah, true; I was thinking of digital implementations, but you're right, semantically those divisions only complicate things
16:41:31 <conal> johnw: i don't think the quantum level is much like either of the continuous or discrete models we use in math and programming.
16:41:31 <johnw> interesting!
16:42:15 <johnw> denotationally, continuous means "without limits" and is easier to reason about; operationally, discrete means "finite limits", and is also easier to think about
16:42:40 <EvanR> no, tractible continuously stuff has finitary support
16:42:46 <johnw> that is, I want to reason with infinite integers, but I want to implement with 64-bit integers
16:43:11 <johnw> depending on which domain I'm in, I want the opposite for the same reason
16:43:22 <johnw> EvanR: oh?
16:43:40 <EvanR> like when you restrict to a certain class of functions that can be decomposed into modes
16:43:50 <EvanR> weighted sum of modes
16:44:07 <conal> johnw: similar to (same as?) low-level vs high-level programming. if you want to reason about denotation/math, pick the high-level; but if you want to reason about execution, pick the low-level.
16:44:09 <EvanR> you dont really have uncountable freedom
16:44:34 <johnw> conal: right; this is interesting, my thinking about continuous/discrete was muddled with my thoughts on infinite/finite
16:44:56 <conal> johnw: on the other hand, our low-level programming models (stateful & sequential) don't really reflect our hardware. so we lose on both counts: bad for math, bad for performance.
16:45:00 <johnw> EvanR: I like that, "uncountable freedom"
16:45:10 <johnw> conal: yes, true!
16:45:52 <johnw> a layering of models that suffers from impedance mismatch at each step
16:46:13 <conal> johnw: i think of continuous/discrete as a sort of inversion (like reciprocal) of infinite/finite time&space. one is about finite-vs-infinite resolution, and the other is about finite-vs-infinite extent.
16:46:56 <johnw> conal: I was wondering if we should rebuild ConCat.SMT on sbv
16:47:18 <erisco> what is sbv
16:47:30 <johnw> high-level interface to SMT solvers
16:47:31 <conal> johnw: sounds worth tinkering with.
16:47:47 <johnw> conal: it should be a straight name translation from one to the other
16:47:48 <erisco> ah, that thing
16:48:15 <erisco> the SQL of SMT solvers
16:48:18 <johnw> conal: and it makes concat applicable to CVC4 and other solvers
16:48:35 <zv> im pretty sure concat is smtlibv2 standardized
16:48:45 <conal> johnw: sweet. let's do it. btw, concat is getting better!
16:48:55 <zv> obv. different if you are using a lower logic
16:48:58 <johnw> zv: it uses the haskell z3 library, which uses the Z3 C API via FFI
16:49:09 <erisco> conal, the library, the theory, or both?
16:49:09 <zv> johnw: ???
16:49:13 <johnw> conal: nice! I hope to resync with you about it in Feb
16:49:30 <conal> erisco: some of each; mainly the library.
16:49:30 <johnw> zv: are we both talking about conal's concat library?
16:49:38 <zv> I'm talking about the operation `concat`
16:49:48 <johnw> oh, ok
16:49:51 <zv> like, take two bitvectors and coalesce them
16:50:02 <johnw> conal's library has the same name :)
16:50:18 <zv> oh gotcha
16:50:32 <erisco> no one saw the confusion coming
16:51:40 <EvanR> i'm on board with conal-style "continuity". i just wish i could be sure whatever stuff i'm thinking about is the same stuff he's thinkinga bout
16:51:52 <EvanR> since continuity is heavily overloaded
16:51:58 <erisco> it is the best thing since sliced bread!
16:52:26 <erisco> it slices up functional programming in a way that is more convenient to various applications :)
16:54:42 <EvanR> really? see i have no idea
16:55:45 <erisco> lauding concat… I don't know about this continuum stuff
16:56:26 <EvanR> oh
16:57:24 <erisco> it is too cold in Canada to think about stuff like that
16:58:27 <conal_> much of the motivation for continuity is identical to motivation for non-strictness/laziness/infiniteness, which is the topic of the classic paper "why functional programming matters". approximation of infinite to finite or continuous to discrete breaks modularity.
16:59:46 * erisco writes that one down
17:00:04 <erisco> must also help explain why continuous is valuable to FRP
17:00:52 <conal_> definitely. see https://github.com/conal/talk-2015-essence-and-origins-of-frp
17:01:05 <conal_> "approximately" doesn't compose, while exactly does.
17:01:11 <EvanR> the producer of information can make less assumptions about which aspects will be needed by the consumer
17:01:42 <EvanR> i see how laziness helps but i keep running into places where i want that to expand even more
17:02:21 <EvanR> "super laziness" or something
17:02:42 <erisco> and I wonder if you can squint at floats with these lenses and understand why they're awful
17:03:21 <EvanR> well, thats one part of gustafsons unum arguments
17:03:58 <EvanR> doubles take up a ton of bandwidth when many applications dont want that amount of precision, and if they do double might not be enough
17:05:05 <erisco> but there are problems too that hamper composability … operators that should be associative aren't, and relative magnitudes matter when they shouldn't
17:05:19 <EvanR> otoh the most efficient general real numbers libs dont utilize laziness
17:05:24 <EvanR> they just start everything over
17:06:21 <EvanR> the use of rationals also ends up using even more resources for the same "bang"
17:06:28 <conal_> i believe that we can beat hardware FPUs on both correctness/reliability and performance, perhaps via dynamically reprogrammable, massively parallel hardware.
17:06:56 <conal_> doing lazy exact real computation, exactly correctly.
17:07:36 <erisco> have you found a way to get back into working on that, after Tabula closed?
17:07:56 <EvanR> i would love to see anything on that front
17:08:03 <EvanR> however incomplete
17:09:00 <EvanR> whats mysterious to me is that real computations dont really sstand out as "numeric" to me, you can just draw pictures of the answers to geometric problems
17:09:44 <EvanR> but we are computing them using rational numbers, which are numbers
17:09:46 <conal_> erisco: i have a lot of freedom in my new gig, and i'm working on fun issues related to large data (machine learning, optimization, etc). i intend to tinker with hardware design there, though i'm not doing ityet.
17:09:52 <erisco> the notion of "number" expands to fit the theory…
17:10:14 <EvanR> but number theory is complex and jagged
17:10:20 <EvanR> geometry is smooth
17:10:23 <erisco> conal_, sounds like fun, congrats :)
17:10:25 * hackage perf 0.3.1.0 - low-level performance statistics  https://hackage.haskell.org/package/perf-0.3.1.0 (tonyday567)
17:10:52 <conal_> erisco: thanks. :)
17:11:31 <EvanR> you can tweak the position of a point in a diagram and not much changes, but any numeric representation of it will see sweeping updates
17:12:14 <yoho> I'm not sure all numeric problems lend themselves well to geometric approaches
17:16:12 <EvanR> im saying, casting geometric problems as a problem with real numbers seems to get you into something you cant get out of
17:16:32 <EvanR> what wasnt numeric now is
17:17:17 <yoho> sure, but it also means you may be able to apply things you could before
17:17:46 <yoho> things shown not in geometry but other fields that can be applied geometrically
17:18:09 <yoho> (maybe you can transform those things back into geometric concepts, but they could be unwieldy)
17:18:25 <yoho> not something I often consider though, so I don't really know
17:21:23 <erisco> EvanR, geometry is a lot more fun without measure…
17:23:48 <EvanR> without numbers, for sure
17:24:06 <EvanR> you can clearly measure things
17:24:27 <erisco> but that's done with numbers
17:24:42 <EvanR> no
17:25:02 <EvanR> numbers and lengths and areas used to be all different things
17:25:04 <erisco> I don't know what a measurement is other than a number of some unit
17:25:15 <jle`> is there a nice way to turn StateT s (State t) a -> StateT (s, t) a
17:25:37 <jle`> i'm looking at mmorph but StateT s is not an MMonad apparently
17:25:43 <EvanR> what is the area of this triangle, answer <constructs a particular square>
17:25:52 <jle`> right now i'm just manually unwrpping and re-wrapping, gross
17:25:58 <Costar> Greeks havent used numbers to measure
17:26:30 <erisco> well if that is measurement to you, then sure
17:27:14 <EvanR> if you ask how long a meter is... someone will probably show you a meter stick
17:27:24 <EvanR> otherwise the answer is... 1 meter
17:27:31 <EvanR> numerically
17:27:56 <EvanR> on a diagram, you can agree that a particular segment is 1 unit
17:29:19 <ggVGc> 1 meter is exactly 0.7 metres
17:30:00 <EvanR> giving other numbers in other units as the answer is just begging the question
17:31:48 <erisco> 1 metre is precisely the length it means to be. No longer, no shorter.
17:32:38 <yoho> I sometimes wish the metre was longer so I wouldn't have to walk as far to get places
18:10:40 <dmwit> jle`: I don't think MMonad would help anyway. Its return type, `t m b -> t n b`, can't change the state parameter.
18:15:24 <jle`> i was thinking of something like using zoom _1 and zoom _2 to get them to be nested StateT (s, t) (State (s, t) a)
18:15:32 <jle`> er, StateT (s, t) (State (s, t)) a
18:18:11 <beauby> haskell-mode (emacs) hangs when opening a .hs file since I started using stack. Anybody experiencing the same thing?
18:19:26 <yoho> big file, directives in the comments?
18:20:39 <beauby> yoho: Empty file :(
18:20:57 <yoho> oh
18:21:09 <yoho> well then
18:26:18 <beauby> There seems to be issues with stack and haskell-mode according to this: https://github.com/haskell/haskell-mode/issues/1526
18:42:29 <jle`> (simple_brain.jpg):  guard $ x + y < 3
18:42:40 <jle`> (transcendant_brain.jpg):  True <- return $ x + y < 3
18:47:35 <mniip> [() | x + y < 3]
19:00:39 <ggVGc> great
19:00:45 <ggVGc> stack is broken in arch again for me
19:00:47 <ggVGc> every month
19:03:36 <vaibhavsagar> ggVGc: could you use Nix?
19:04:42 <vaibhavsagar> "no, I'm uninterested in learning a completely new build and package ecosystem for ambiguous benefit" is a completely valid answer
19:06:10 <ggVGc> I've tried nix in the past, but honestly my harddrive isn't big enough
19:06:15 <ggVGc> that might be a stupid reason
19:06:21 <vaibhavsagar> that's fair too
19:06:48 <boj> makes sense. unless you constantly prune, the store can get out of hand
19:06:49 <vaibhavsagar> IME Nix assumes a big hard drive and a fast, reliable internet connection
19:07:51 <ggVGc> I find it quite sad that haskell is by far the hardest language I've used, to get my projects to build
19:07:59 <ggVGc> and I've done a lot of C++...
19:08:09 <ggVGc> I think it puts a lot of people off
19:08:42 <boj> in general, or because arch keeps breaking it because they are doing it wrong?
19:09:07 <ggVGc> well, a bit of both I think
19:09:08 <ggVGc> but fair
19:09:15 <ggVGc> on that note, what is arch doing wrong?
19:09:17 <ggVGc> I'd like to fix it
19:09:48 <boj> i don't know the specifics myself, but it comes up way too often. something about building static vs. dynamic
19:10:25 <mnoonan_> since stack came out, I’ve found Haskell better than other languages that I commonly use (C++, Objective C, Python)
19:10:39 <glguy_> It's a mix of intentionally breaking things for development in order to make things nicer for application deployment of executables they distribute
19:10:44 <tsani> ggVGc: FWIW I've completely given up on installing anything haskell-related from the arch repos
19:10:58 <glguy_> And stack not knowing about Arch that causes the issues
19:11:35 <tsani> ggVGc: I install everything via stack, and I install stack using curl -sSL https://get.haskellstack.org/ | sh :^)
19:11:43 <ggVGc> mnoonan_: yeah that's all good, until stack doesn't work either
19:12:22 <ggVGc> tsani: I still needed this to get dependencies to build, https://aur.archlinux.org/packages/ncurses5-compat-libs/
19:12:25 <ggVGc> and now that doesn't work either
19:12:30 <tsani> ah
19:12:45 <tsani> have you adjusted the ghc settings file?
19:12:51 <ggVGc> what do I need to do?
19:13:30 <tsani> edit  .stack/programs/x86_64-linux/ghc-nopie-8.2.2/lib/ghc-8.2.2/settings (adjust for the GHC version you're using) and change -fno-PIE to -no-pie
19:13:49 <tsani> sorry, that should read $HOME/.stack/...
19:14:16 <ggVGc> tsani: already says -no-pie
19:14:28 <tsani> ah shoot, then I don't know what might be the problem
19:14:36 <ggVGc> well, I did a system upgrade
19:14:39 <ggVGc> never do that when you have work to do
19:19:04 * hackage hidden-char 0.1.0.2 - Provides getHiddenChar function  https://hackage.haskell.org/package/hidden-char-0.1.0.2 (rcook)
19:20:11 <fraktor> Would I be wasting anyone's time if I asked some n00b questions about doing Project Euler in Haskell?
19:20:31 <tsani> fraktor: not at all
19:21:17 <ggVGc> we waste our own time well enogh anyway
19:22:47 <fraktor> So I've got some code: https://pastebin.com/nzcz7KTV And I'm a little confused about some of the syntax. I'm getting the wrong answer, but I'll worry about that later.
19:23:16 <jle`> fraktor: what part confuses you?
19:23:35 <ggVGc> tsani: I believe I found the fix, and it might be interesting to you since you probably will get broken your next upgrade, https://github.com/commercialhaskell/stack/issues/3509
19:23:37 <fraktor> I've got the function removeDuplicates (lines 5-6) implemented and working, but I want to know why I can't write it like this: removeDuplicates = init $ map head $ group $ sort
19:23:54 <jle`> fraktor: check out the definition of ($)
19:23:58 <jle`> f $ x = f x
19:24:10 <jle`> note that it associates from the left, so init $ map head $ group $ sort would be:
19:24:18 <jle`> init (map head (group (sort)))
19:24:27 <jle`> which means...
19:24:36 <jle`> you're mapping 'head' over 'group sort'
19:24:37 <tsani> ggVGc: oddly enough stack is working fine for me and I did a full system upgrade just earlier today
19:24:47 <ggVGc> haha
19:24:53 <ggVGc> tsani: maybe you already have the fix..
19:24:56 <jle`> fraktor: or more importantly, you're running 'group' on 'sort'
19:24:57 <ggVGc> or, well, computers
19:25:00 <jle`> but 'group' takes a list
19:25:02 <jle`> not a function
19:25:15 <jle`> fraktor: do you see why 'group sort' is sorta meaningless?
19:25:19 <jle`> not to mention a type error
19:25:41 <fraktor> How can I make this a (I believe this is the term) curried function so that it becomes a function that accepts a list of integers without having to define the arguments?
19:25:49 <jle`> you can use function composition
19:25:52 <fraktor> I do understand.
19:25:56 <jle`> the word you want is "function"
19:26:01 <jle`> not necessarily 'curried function' :)
19:26:09 <jle`> you can compose functions using the (.) operator
19:26:15 <jle`> so you can do something liek removeDuplications = init . map head . group . sort
19:26:19 <jle`> (.) is function composition
19:26:24 <jle`> you were using ($), which is function application
19:26:31 <tsani> fraktor: a function definition that doesn't introduce its arguments is called "point-free"
19:26:49 <fraktor> Oh.
19:26:59 <ggVGc> don't mix up the word "point" in "point-free" with the operator (.) which is a point
19:27:10 <ggVGc> you make things point-free with the point operator :)
19:27:12 <MarcelineVQ> tsani: you can add   ghc-build: nopie   to your ~/.stack/config.yaml to avoid doing it in multiple places
19:27:35 <MarcelineVQ> ggVGc: make sure you have done this as well if you're on arch
19:28:02 <fraktor> I'm trying to use the dot operator, but it says that I'm applying it to too few arguments.
19:28:05 <ggVGc> MarcelineVQ: didn't do it for me. Using ghc-build: tinfo6 does though
19:28:15 <fraktor> Which means I don't really understand what I'm asking haskell to do.
19:28:39 <MarcelineVQ> interesting, you shouldn't need that with the compat libs, we'll see if that comes up next time I update hehe
19:28:44 <jle`> fraktor: what is the code that is cuaa is causing the error
19:28:49 <jle`> *is causing
19:28:50 <zerovector> I'm doing the exercism.io haskell track and I've done 27 of the problems. Do they get any more interesting?
19:29:01 <ggVGc> MarcelineVQ: the compat lib hasn't caught up with the latest ncurses as far as I understand
19:29:32 <ggVGc> either way it's some bullshit we need compat libs to use stack on arch
19:29:35 <fraktor> removeDuplicates = init $ map head $ group . sort
19:29:36 <ggVGc> but whatyagonnado
19:29:46 <ggVGc> fraktor: no, the othe rway around
19:30:06 <fraktor> So like init . map head $ group $ sort?
19:30:12 <ggVGc> fraktor: you use (.) to compose functions, then you could use $ to apply it to an argument
19:30:13 <jle`> fraktor: init . map head . group . sort
19:30:22 <jle`> remember, we are composing functions here
19:30:25 <jle`> ($) is *applying* functions
19:30:29 <jle`> (.) is *composing* functions
19:30:46 <ggVGc> fraktor: foo . bar . baz $ x  is the exact same thing as (foo . bar . baz) x
19:31:23 <fraktor> Perfect. It's working now.
19:31:30 <jle`> fraktor: init . map head $ group $ sort is (init . map head) (group sort)
19:31:30 <fraktor> BTW, it seems to be running a bit faster. Is that common?
19:31:37 <jle`> faster than what?
19:31:41 <ggVGc> light
19:31:42 <jle`> python, etc.?
19:31:45 <jle`> yes :)
19:31:48 <fraktor> Faster than my previous code.
19:31:54 <jle`> oh
19:32:03 <jle`> no that shouldn't happen, usage of (.) usually compiles to the same code
19:32:07 <fraktor> init . map head . group . sort runs faster than init $ map head $ group $ sort n
19:32:15 <fraktor> Okay. Confirmation bias.
19:32:39 <jle`> would defnitely be neat though if it did :
19:32:41 <jle`> :)
19:32:50 <jle`> but it would be pretty havoc-wreaking for equational reasoning
19:32:50 <ggVGc> I'd be surprised if that made a difference. I think I'd consider it a bug of GHC even
19:33:13 <sqooq> I read
19:33:16 <sqooq> something somewhere
19:33:21 <ggVGc> me too
19:33:22 <sqooq> that said that can happen
19:33:28 <sqooq> because it calculates the n or something?
19:33:49 <sqooq> agh
19:33:50 <sqooq> I'm
19:34:00 <sqooq> here it is, I don't think it's similar
19:34:00 <sqooq> https://wiki.haskell.org/Let_vs._Where
19:34:02 <jle`> s/<CR>/ /
19:35:34 <zerovector> Has anyone done the exercism.io haskell track?
19:39:02 <sqooq> exorcism
19:41:04 <glguy> zerovector: No, but given the lack of response, you might like looking at advent of code if you're looking for some programming exercises to do in Haskell that a bunch of us have done recently
19:41:21 <zerovector> sqooq: Yeah they spelled it with an 'e'. http://exercism.io/about
19:42:31 <sqooq> print hello world
19:42:42 <sqooq> mfw I use a internet library and parsec
19:42:48 <sqooq> grab the wiki page for hello
19:42:51 <sqooq> parse it
19:42:57 <sqooq> for hello
19:43:00 <sqooq> grab the world page
19:43:04 <sqooq> parse it for world
19:43:15 <glguy> mfw when I press ENTER every 4 words I type :-S
19:43:23 <zerovector> glguy: Sounds good! I'll take a look at it. Thanks!
19:43:24 <sqooq> I
19:43:25 <sqooq> do
19:43:25 <sqooq> that
19:43:27 <sqooq> actually
19:43:34 <sqooq> Is that bad?
19:43:39 <sqooq> I'll stop if it is, it just feels natural
19:43:55 <sqooq> because in real life people don't just stop talking for like 1 minute, then explode with one huge block of words
19:43:59 <MarcelineVQ> tfw people don't know what I'm talking about but it still seems like a good idea to say
19:43:59 <sqooq> idk
19:44:03 <glguy> It's a bad habit that you should work on
19:44:16 <sqooq> rip
19:45:30 <sqooq> My isEven function: Always output True. Works 50% of the time.
19:45:39 <glguy> zerovector: If you start doing the exercises on adventofcode.com in Haskell, you should join our group. The code is in the channel /topic, but let me know if you need help figuring that out. It's good for seeing how far along others are and many of us link through to our solutions on github
19:57:02 <zerovector> glguy: "channel /topic" is this an IRC thing? I have almost no idea how to use IRC so I will likely need some guidance with this.
19:57:52 <glguy> Oh, well IRC channels have topics. Depending on the client there's different ways to see the topic. You'd have to go to http://adventofcode.com/2017/leaderboard/private and enter the code 43100-84040706
19:58:44 <[Leary]> How do people usually deal with type constructors (e.g. Functors) that have more than one polymorphic data constructor? In the following, the fmap definition should be complete with just first and second line, but it does not pass type check on e: http://lpaste.net/361179
19:59:29 <glguy> [Leary]: You'll need to write out one case for each constructor
19:59:40 <glguy> or you can just automatically derive the Functor instance
19:59:52 <[Leary]> Geh
20:00:46 <[Leary]> That might work for this functor instance, but this is a simplified case, I actually have the same problem with another type's non-trivial Applicative instance.
20:00:48 <glguy> Given a value (Cons5 :: PolyCons Int) you can't just use it as a (Cons5 :: PolyCons Char), it doesn't matter that there are no fields of that constructor that user the type parameter, it still has a conflicting type
20:00:52 <zerovector> glguy: Most excellent. Looks like I'm setup on the site itself
20:00:52 <mniip> there's no typechecking mechanism that would conclude from 'foo (Just x) = ...; foo y = _' that in _ y :: forall a. Maybe a
20:00:58 <mniip> even though evidently y can only be Nothing
20:03:45 <sqooq> it works fine for me?
20:03:48 <sqooq> [Leary]
20:04:18 <sqooq> it prints `Cons1 "" 6`
20:04:39 <sqooq> O you said first and second line
20:04:40 <sqooq> my bad...
20:04:42 <glguy> sqooq: That's not the question; [Leary] is asking why the commented out line was insufficient
20:05:44 <mniip> even worse,
20:06:09 <mniip> :t \l@(Left x) -> ?f l
20:06:10 <lambdabot> (?f::Either a b -> t) => Either a b -> t
20:06:12 <mniip> :t \l@(Left x) -> ?f (Left x)
20:06:13 <lambdabot> (?f::Either a b1 -> t) => Either a b2 -> t
20:06:23 <zerovector> glguy: I'm using weechat. Anyway to see the topic for the AOC?
20:06:26 <mniip> seemingly identical code, but different restrictions on f
20:06:52 <glguy> zerovector: I think weechat shows the channel topic if you enter the command: /topic
20:09:10 <zerovector> glguy: Got it. And you said there is code somewhere to download?
20:09:55 <glguy> No, it's just the number I mentioned above that you enter into the page at the URL I mentioned above: 43100-84040706 http://adventofcode.com/2017/leaderboard/private
20:10:56 * [Leary] breaks out unsafeCoerce
20:12:55 <zerovector> glguy: Cool. Is there a base git repository or is it just free for all?
20:13:27 <glguy_> free for all
20:16:53 <zerovector> project euler style. sweet
21:01:33 * hackage liquidhaskell 0.8.2.2, liquid-fixpoint 0.7.0.6 (ranjitjhala): https://qbin.io/jwv34nlxi
21:13:55 * hackage pandoc-citeproc 0.12.2.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.12.2.1 (JohnMacFarlane)
21:33:27 <jchia> Question about Data.Hashable.Hashable instances. There's an instance "Hashable a => Hashable [a]" but why isn't there an instance "(Hashable a, Foldable f) => Hashable (f a)"? They got instances for [], Maybe, Identity explicitly, but not for "Foldable f".
21:35:14 <kadoban> jchia: Isn't (r,) a Foldable? Also I'd guess Foldable wasn't really as much of a thing (or did it exist at all?) when Hashable started.
21:36:16 <MarcelineVQ> unless I'm not understanding things   (Hashable a, Foldable f) => Hashable (f a)  is too general an instance to be useful, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-resolution
21:36:30 <geekosaur> jchia, ^
21:36:40 <geekosaur> thta overlaps *every* instance of the shape "f a"
21:37:16 <geekosaur> including [], Identity, Maybe, etc.
21:37:59 <jchia> So, now I need to make an orphaned instance for Hashable a => Hashable (Vector a), correct?
21:40:24 <jchia> The Foldable instance for (r,) would indeed be bad.
21:40:46 <jchia> i mean the Hashable instance.
21:48:16 <localhorse> what is lifting exactly?
21:48:31 <localhorse> wrapping something in a monad?
22:03:57 <unyu> Do (n-ary) functors that commute have a special name? For example, "Foo (Bar a b)" being isomorphic to "Bar (Foo a) (Foo b)".
22:05:26 <uglyfigurine> anyone have aa resource to teach functional programming to kids?
22:10:38 <jchia> localhorse: Yeah, something like that, but not just monads. For example, consider liftA3. http://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Applicative.html#v:liftA3
22:11:35 <jchia> it lifts an "func :: (a -> b -> c -> d)" into "f a -> f b -> f c -> f d"
22:17:38 <dmwit> unyu: But that is distributing, not commuting!
22:20:08 <glguy_> I've seen commutative used similarly before as in a commutative monad, or at least it seemed similar to me
22:20:09 <dmwit> And see https://hackage.haskell.org/package/distributive-0.5.3/docs/Data-Distributive.html for some further thought on functors that distribute.
22:20:57 <dmwit> Saying `Foo` and `Bar a` commute would roughly be `Foo (Bar a b) ~= Bar a (Foo b)`.
22:21:34 <dmwit> Commutative monads are something different, I think -- there it's the arguments to `(>>=)` that commute, not the type-level terms.
22:51:24 <unyu> dmwit: Thanks.
22:51:29 <unyu> (Sorry, I got disconnected.)
22:53:25 * hackage http-reverse-proxy 0.5.0 - Reverse proxy HTTP requests, either over raw sockets or with WAI  https://hackage.haskell.org/package/http-reverse-proxy-0.5.0 (MichaelSnoyman)
22:54:57 * hackage pandoc-citeproc 0.12.2.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.12.2.2 (JohnMacFarlane)
22:57:34 * hackage yesod-test 1.5.9 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.9 (MichaelSnoyman)
23:01:25 <lyxia> uglyfigurine: https://code.world
23:02:58 * hackage mega-sdist 0.3.0.6 - Handles uploading to Hackage from mega repos  https://hackage.haskell.org/package/mega-sdist-0.3.0.6 (MichaelSnoyman)
23:05:07 <jchia> Does GHC optimize (==) by checking identity? E.g. if I have two values of the same type that under the hood have the same pointer, the result of (==) automatically True and the result of compare is automatically EQ. Can I write my types to work this way?
23:05:22 <jchia> I'm comparing huge values that are used as keys in a Map.
23:07:17 <dmwit> no
23:07:31 <dmwit> But perhaps I can interest you in a StableName.
23:08:19 <dmwit> IORefs and the like also have such an Eq instance.
23:11:52 <kadoban> StableName looks cool, never heard of that
23:12:14 <jchia> dmwit: So the advantage over StablePtr is that I don't have to mess with resource management and IO?
23:14:51 <dmwit> hm
23:15:18 <dmwit> I think they have completely different goals.
23:15:49 <dmwit> I think the advantage over StablePtr is that it isn't as hard on the garbage collector.
23:16:19 <dmwit> StableName's (and the things they refer to) still move around during the copying GC, unlike StablePtrs. So they don't need as much magic.
23:16:35 <jle`> this is neat, i wonder if we could get a similar experience in haskell
23:16:37 <jle`> https://github.com/A1kmm/proofsweeper
23:17:37 <jchia> dmwit: Can I use StableName to optimize Map operations? I have a large structured type A that's used as key. Somewhere nested in A there is a field of field B that contributes most of the size it doesn't change -- most or all of the A values share the same B.
23:18:23 <dmwit> jle`: There's a Haskell project that goes the other way: you never lose unless the clues you've uncovered so far absolutely recover it.
23:18:26 <dmwit> http://hackage.haskell.org/package/minesweeper
23:18:27 <jchia> without optimizing, compare will naively take a long time comparing two B values that are actually identical.
23:18:49 <jle`> dmwit: nice
23:19:01 <dmwit> s/recover/require/
23:19:35 <jle`> i was thinking of a web gui for this but it'd be hard without being able to compile haskell code essentially
23:20:11 <dmj`> jle`: go on
23:20:24 <jle`> i mean, the proof-required minesweeper version
23:20:44 <jle`> i'd want to be able to visually show the square, and the player has to type out a proof before they can make a move
23:21:08 <jle`> but the only way that'd work would probably to implement a small dependently typed language that the player can use
23:21:30 <jle`> maybe i can make a web gui for the idris one
23:21:36 <jle`> and have the player provide proofs in idris
23:21:45 <jle`> since like...ghcjs can compile idris...right ...
23:21:51 <dmwit> jchia: Sure. `compare (vl, sl) (vr, sr) = compare (hashStableName sl) (hashStableName sr) <> compare vl vr`
23:21:52 <jle`> so you could run a mini idris interpreter in the browser
23:22:02 <dmwit> jchia: Where `v*` is the value, `s*` is its StableName.
23:22:06 <MarcelineVQ> idris can compile to nodejs
23:22:28 <MarcelineVQ> no need to bother ghcjs about it
23:23:03 <dmwit> jchia: For even more performance boost, add a fastpath check for equality on the `StableName`s when their hashes are equal.
23:23:21 <jchia> dmwit: But I have to calculate the StableName from the value first, every time I make the value, right?
23:23:22 <jle`> MarcelineVQ: but then that means i'll have to write my web app frontend in idris
23:23:32 <jle`> i'd rather just write it all in haskell and use idris as a library hehe
23:23:36 <dmwit> jchia: Something like `case compare (hash... sl) (hash... sr) of EQ -> if sl == sr then EQ else compare vl vr; other -> other`
23:23:40 <jchia> In other words, is makeStableName slow?
23:23:44 <MarcelineVQ> use agda if you just want a proof lib :>
23:23:49 <dmwit> jchia: No, no, store the stable name next to the value.
23:24:31 <dmwit> jchia: I dunno. I mean, I guess you could recreate the StableName every time.
23:24:39 <jle`> is agda available as a haskell lib?
23:24:40 <jchia> dmwit: OK, so effectively, replace 'a' with (a, StableName a) whenever I use it that needs a comparison.
23:24:50 <jle`> oh hey
23:24:51 <dmwit> I would.
23:24:53 <jle`> @hackage Agda
23:24:53 <lambdabot> http://hackage.haskell.org/package/Agda
23:26:11 <dmwit> jchia: Seems like a tiny library wrapping StableName and offered an Ord instance would be pretty handy.
23:26:16 <dmwit> You should throw one up on Hackage. =)
23:27:11 <dmwit> data FastPathComparison a = FPC a (StableName a)
23:27:42 <jchia> dmwit: Is there a way to fully evaluate an expression? I want to avoid the StableName changing
23:28:33 <dmwit> Um. `seq` is almost certainly enough. But there is `deepseq` if you're convinced you need to fully evaluate.
23:28:43 <dmwit> There is `evaluate`, too.
23:30:20 <jchia> dmwit: deepseq seems more thorough, according to description.
23:31:03 <dmwit> Yes. But given that `makeStableName` promises not to evaluate its argument, I think it's unlikely that anything more than `seq` could possibly matter.
23:31:25 <dmwit> i.e. if it isn't going to evaluate its argument, it ain't looking anywhere under the first constructor.
23:32:43 <jchia> dmwit: Something else could evaluate the value later and cause makeStableName to return a different value.
23:33:47 <dmwit> I think you misunderstood the thrust of my claim: since makeStableName cannot look under the top constructor, *nothing you do there* (including unsafe mutations, further evaluations, segfaulting, whatever) can possibly affect what makeStableName does.
23:34:15 <jchia> dmwit: But sticking to using the original "FastPathComparison a" in lieu of "a" everywhere that involves comparison is good enough.
23:35:02 <jchia> dmwit: OK, I was just referring to the haddock's "Note in particular that makeStableName may return a different StableName after an object is evaluated." Didn't know it was shallow.
23:35:23 <dmwit> e.g. "unevaluated -> evaluated" can affect things because GHC mutates the contents of the thunk during that step. But "top-level evaluated -> fully evaluated" changes nothing about the top-level object GHC has in memory.
23:35:41 <jle`> it'd be nice if we had a scanl that worked on all Traversable
23:35:58 <dmwit> jle`: Are you okay with it always returing a list?
23:36:24 <jle`> if we modify the behavior a bit, we can have it return the same Traversable
23:36:35 <jle`> (in particular, to drop the first item)
23:36:36 <dmwit> jle`: Alternately, are you okay with the analog of `tail . scanl`?
23:36:40 <dmwit> ...yeah =)
23:36:53 <jle`> yeah i'd be happy with a tail'd scanl
23:37:01 <dmwit> FWIW, I don't think I've ever actually wanted scanl instead of tail ... scanl.
23:37:03 <jle`> well right now i only want it because of a really hacky thing i'm doing
23:37:10 <dmwit> (And I've paid attention.)
23:37:30 <jle`> non-tail-scanl works well with !! indexing
23:37:39 <jle`> but then you'd just use a foldl ;)
23:38:31 <dmwit> Is Foldable not enough? I think it might be.
23:38:31 <jle`> well the reason i want it now i soimething really hacky anyway
23:38:42 <dmwit> err... no.
23:38:42 <jle`> Foldable can't return the original type
23:38:45 <dmwit> right
23:39:11 <jle`> if you store the derivatives of a particle in motion in a list, with the highest derivative first
23:39:17 <jle`> then scanl (+) is the euler integration
23:39:33 <jle`> (tail-scanl)
23:39:43 <jle`> oh actually that's the non-tail scanl
23:39:47 <amalloy> (tail-scanl)? you're going to implement it in lisp now!?
23:41:42 <amalloy> dmwit: fwiw i looked at my uses of scanl in AoC 2015/2017. in 2015 (https://github.com/amalloy/advent-of-code) i always wanted scanl to include the init value, and in 2017 (https://github.com/amalloy/aoc-2017) i've so far been indifferent: either would be fine
23:43:39 <jle`> oh hey i didn't realize bitraversable was in base
23:43:49 <jle`> or maybe i did but just forgot
23:44:04 <jle`> it'd be nice if there was an alias for travLeft f = bitraverse f pure
23:44:07 <MarcelineVQ> it's pretty new
23:44:12 <jle`> since travRight = traverse already
23:44:57 <jle`> oh hey mapAccumL is generalized for all Traversable, i guess i can write scanl in terms of that
23:45:37 <jle`> oh heh the implementation of mapAccumL requires a minature implementation of the State applicative in base
23:46:00 <MarcelineVQ> yeah it's a little weird, there'sa few things in that Data.Functor.Utils
23:46:19 <MarcelineVQ> left and right biased state applicative instances, and max and min I think
