00:00:29 <sqooq> wut
00:00:56 <geekosaur> we tend to think of derivatives as "slope of a curve"
00:01:02 <geekosaur> which is a nice simple thing.
00:01:08 <geekosaur> but what happens when they vary over time?
00:01:22 <geekosaur> this is when derivatives turn into differential equations
00:01:32 <geekosaur> (well, time in this case because /dt)
00:02:01 <geekosaur> at least it's only *one* equation. when it gets really nasty is when you have to solve a system of them
00:04:13 <sqooq> i don't understand
00:04:17 <sqooq> everything is in terms of t
00:04:27 <sqooq> how is the derivative varying
00:04:30 <sqooq> well I mean it is
00:04:33 <sqooq> but that's normal
00:05:15 <geekosaur> I may have confused you into overthinking it. my point is we tend to say "derivative" with respect to a single (in this case) time.
00:05:53 <geekosaur> and yes, it's normal that here it varies, but that means it can turn out to be of similar nastiness as integrals
00:05:59 <georges-duperon> Hi! I have a package with "Build-Depends: hashable >= 1.2, …". When I run "cabal install", it complains that it "cannot satisfy -package-id hashable-1.2.6.1-JDYnvpSucMf1h1i2CUUtVb".
00:06:06 <geekosaur> (where likewise it varies over time)
00:06:41 <georges-duperon> Any idea what I might need? I don't know where this version hash comes from, and the package installs fine on another machine with ghc 8.2.1 (here I have 8.2.2).
00:07:28 <geekosaur> georges-duperon, where/how is hashable installed? also, can you put the result of trying to install with "cabal -v3 install" somewhere?
00:07:30 <geekosaur> @paste
00:07:30 <lambdabot> Haskell pastebin: http://lpaste.net/
00:08:05 <sqooq> I still don't understand
00:08:17 <sqooq> is it because the original "y" is a part of the equation?
00:08:23 <sqooq> what i was calling "recursive"
00:09:32 <geekosaur> you mean v?
00:11:27 <geekosaur> and yes, that's part of the complication. it's reflecting much the same thing as I described for how RC circuits work, but for a low pass filter it's an impedance instead of a capacitance.
00:12:15 <georges-duperon> geekosaur: Here's the log (I had tried -v, didn't know about -v3!): http://lpaste.net/3149891356613148672 .
00:12:18 <sqooq> i solved the equation
00:12:20 <geekosaur> (and RI / low-pass circuits don't work for generating resonant frequencies because they tend to peak at f = 0)
00:12:25 <sqooq> but y is still there twice
00:12:41 <kakashiAL> geekosaur: does haslkell only have Float, Double and Rational to show values with points?
00:12:50 <sqooq> 1/2*x=(y+C)/(x-y)
00:12:55 <sqooq> where x is vin, y is vout
00:13:07 <sqooq> not sure if I can combine the y's any further
00:13:44 <geekosaur> georges-duperon, this already reveals another problem: cabal: The program 'pkg-config' is required but it could not be found.
00:13:45 <georges-duperon> geekosaur: I'm not installing hashable by hand. It's listed as a dependency, and vaguely remember that cabal downloaded & installed dependencies on its own when I set up the other machine.
00:14:32 <geekosaur> yes, it's already known because it's including the encoded ABI hash in the error message. that's why I asked for the -v3 output, to see why it did that
00:15:39 <sqooq> according to my caclulator it's y=(x^2-2*c)/(2*RC+x)
00:15:51 <sqooq> where lowercase c is the constant from integration
00:15:54 <sqooq> not sure how to find that
00:16:41 <sqooq> I guess I can assume that for t<0, input is 0 and output is 0
00:17:25 <sqooq> i have a bad feeling I solved this wrong to begin with lololol
00:17:33 <sqooq> if you have RC*dy/dx
00:17:54 <sqooq> you can multiply both sides by dx right?
00:18:04 <sqooq> I know derivates aren't really fractions
00:18:12 <sqooq> but we seem to be fine with doing shit like that
00:18:19 <sqooq> but idk if RC* ruins it
00:18:33 <geekosaur> you "can do" that but it's still a differential
00:18:54 <sqooq> ye
00:18:58 <sqooq> then I integrated both sides
00:19:09 <sqooq> WAIT
00:19:10 <sqooq> fuck
00:19:13 <sqooq> x is a function derp
00:19:16 <sqooq> haha
00:19:29 <geekosaur> yes, x and y are functions of t
00:19:40 <georges-duperon> geekosaur: Thanks, good point :) . It still doesn't like it though. http://lpaste.net/8642279196682354688
00:19:49 <WinterFox[m]> Is there an easy way to tell if something is a function or an action?
00:19:51 <georges-duperon> geekosaur: Are lhc & lhc-pkg also needed? They didn't seem to ship with haskell-platform, and I doubt installing ubuntu's version via apt will work well with a different version of ghc…
00:19:54 <geekosaur> georges-duperon, I would start by making sure pkg-config is installed. beyond that, can you put the output of "ghc-pkg check" on lpaste?
00:20:11 <geekosaur> lhc is not needed, nor are happy or alex; they're just checked for by default
00:20:53 <geekosaur> it's a different haskell compiler (so is jhc), neither is widely used
00:21:41 <sqooq> wait if y=y(x)
00:21:52 <sqooq> and integral(y(x),dx) = y^2/2
00:22:11 <sqooq> then integral (x(t),dt) = x^2/2
00:22:13 <sqooq> ja?
00:22:59 <geekosaur> not for arbitrary y (consider y ::= sin)
00:23:10 <jchia_1> Can I tell "stack haddock" to only generate haddock for my project and not for the external packages that it depends on?
00:24:28 <Tops21> Winterfox[m]: I'm not sure what you mean with actions. Do you mean functions with effects? You can see that in the type then.
00:24:53 <georges-duperon> geekosaur: Ok, thanks. I had installed happy & alex on the other machine, but indeed they weren't necessary.
00:25:00 <georges-duperon> geekosaur: ghc-pkg recache actually fixed the problem, but I needed sudo (http://lpaste.net/1558343125741600768), which sounds highly dubious to me. I probably should have thrown a --user in there :)
00:25:07 <sqooq> geekosaur, haha shoot
00:25:07 <georges-duperon> geekosaur: thanks a lot :) !
00:25:34 <geekosaur> georges-duperon, are you on arch by any chance? that seems to be a known but not 100% reproducible problem with arch's upgrade to ghc 8.2.2
00:25:41 <geekosaur> you need to fix the global library cache
00:26:00 <sqooq> well then all I can say is that y(t)=integral(x(t)-y(t))+c/RC
00:26:11 <geekosaur> (which is indeed that sudo ghc-pkg recache --global)
00:26:23 <geekosaur> sqooq, this is what I meant by these things being nasty.
00:26:30 <kakashiAL> sorry for asking this, but does haskell only have Float, Double and Rational to present nummeric dot values?
00:26:32 <sqooq> I see that now
00:26:35 <geekosaur> integrals (and derivatives) are not at all simple in the general case
00:26:37 <sqooq> but like
00:26:46 <sqooq> x(t) is unknown, it can be literally anything
00:26:46 <nilof> That fun feeling, when you work on a (programming-unrelated) math course with a bunch of group objects, and suddenly you end up grokking the "monoid object in the category of endofunctors" thing without directly expecting it
00:26:50 <sqooq> that's the point of a lowpass filter
00:26:51 <georges-duperon> geekosaur: nope, ubuntu 16.04, installed haskell-platform using the default tarball (the one which isn't distro-specific).
00:27:02 <sqooq> but this is interesting, it shows a direct corellation with the discrete time case
00:27:03 <georges-duperon> geekosaur: love the nickname by the way :)
00:27:05 <geekosaur> interesting
00:27:27 <geekosaur> might file a bug against haskell-platform then, or drop an email to libraries@haskell.org
00:28:08 <geekosaur> sqooq, in a sense that equation is defining x(t) and y(t). it's not a simple definition though; that's literally what makes it a low pass filter
00:28:53 <georges-duperon> geekosaur: Ok, will do. I'll re-try on a clean machine (yay for virtual machines!), just to be sure that I have the exact steps.
00:28:55 <sqooq> ye this sucks
00:29:03 <liste> @hackage Decimal -- kakashiAL, also you can roll your own numeric types if necessary
00:29:04 <lambdabot> http://hackage.haskell.org/package/Decimal -- kakashiAL, also you can roll your own numeric types if necessary
00:29:04 <sqooq> I can always implement filters by doing fourier
00:29:11 <sqooq> if I'm gonna do integrals anyway
00:29:25 <sqooq> I guess I just really need to figure out a good integral approximation for continuous time
00:29:43 <sqooq> I mean I know a few, I just don't know how I'll implement it exactly
00:29:48 <sqooq> but that's a problem for another day
00:29:58 <geekosaur> sqooq, this is why electronic engineers tend to be well paid, and why circuit simulation ranges from PCSPIZCE which can just about deal with simple RC and RI circuits all the way up to expensive behemoths like Verilog
00:30:02 <Tops21> kakashiAL: Have a look at the instances for the classes Real, Fractional etc.: http://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html#t:Real
00:30:04 <geekosaur> er PSPICE
00:30:26 <sqooq> What's interesting is that I think technically all my signals will have well defined integrals
00:30:31 <kakashiAL> I dont mean stuff that you have to install
00:30:31 <geekosaur> (tiself a public domain reimplementation of (part of) the ancient commercial SPICE circuit simulator)
00:30:47 <sqooq> the integral of a piecewise is the piecewise of the integrals of the piecewises right?
00:30:55 <Tops21> yeah, that's all in Prelude
00:31:07 <geekosaur> roughly yes. sadly that doesn't always help
00:31:26 <sqooq> ye the hard part is then multiplying
00:31:30 <sqooq> well multiplying is ez
00:31:33 <sqooq> taking the inverse fourier
00:31:35 <sqooq> now that's hard
00:31:42 <sqooq> that's the step I think I'll have to approximate
00:32:29 <sqooq> this is starting to discourage me from continuous time
00:32:40 <sqooq> a lowpass in discrete time is SO easy
00:32:58 <sqooq> a basic one, and the harder one's can still all be done in the time domain with memory
00:33:03 <sqooq> delay lines to be precise
00:33:35 <sqooq> BUT
00:33:41 <sqooq> they're also a huge approximation
00:33:45 <sqooq> by necessity
00:34:00 <sqooq> so like, maybe I shouldn't be so worried about having to approximate an integral
00:35:10 <sqooq> and I can choose how much precision I want
00:35:32 <sqooq> I think... Yeah with the trapezoid one, you can choose the interval lengths that you break the integral up into.
00:35:42 <sqooq> ok
00:35:43 <sqooq> goodnight
00:35:48 <sqooq> thanks geekosaur
00:39:52 <georges-duperon> geekosaur: Couldn't reproduce the problem on a clean VM, so I won't file a report.
00:39:54 <georges-duperon> geekosaur: I had previously installed ghc 8.2.1 then overwrote it with 8.2.2, it was probably a stale file from the previous version or something like this.
00:40:03 <georges-duperon> geekosaur: Thanks again for the help :) !
00:40:20 <geekosaur> ah, if you wrote over it then it might not have generated a new package cache, con ceivably
00:40:47 <geekosaur> although I'd argue that is still a bug (and might well explain why Arch got caught by it as well)
00:44:06 <kakashiAL> what type would you use to represent pi with 200 digits after the dot?
00:44:38 <georges-duperon> kakashiAL: I think "Rational" is arbitrary-precision, IIRC.
00:48:34 <kakashiAL> georges-duperon: how would that look with pi and 200 digetes?
00:52:46 <geekosaur> oh whoops. hadrian is ghc specific, shake is the generic build component
00:52:49 <geekosaur> sigh
00:54:39 <georges-duperon> kakashiAL: import Data.Ratio -- then -- 3123456789012345678901234567890 % 1000000000000000000000000000000
00:57:30 <georges-duperon> kakashiAL: Probably not the cleanest way, there must be a way to parse a string of the form "3.14…", but my hoogle-fu doesn't find anything good with "String -> Rational" on https://www.haskell.org/hoogle .
01:00:30 <liste> > read "1.11111111111111111111111111111111111111111111111111111111111111111111111111111" :: Ratio Integer
01:00:32 <lambdabot>  *Exception: Prelude.read: no parse
01:00:56 <liste> :(
01:01:30 <liste> > read "1.11111111111" :: Rational
01:01:32 <lambdabot>  *Exception: Prelude.read: no parse
01:02:25 <liste> weird, since decimal literals are actually Rational (they're read using fromRational)
01:02:49 <liste> 1.111111111111111111111111111111111111111111111111 :: Rational
01:02:56 <liste> > 1.111111111111111111111111111111111111111111111111 :: Rational
01:02:58 <lambdabot>  1111111111111111111111111111111111111111111111111 % 100000000000000000000000...
01:42:36 <hitlrsociety> Where?
01:43:06 <hitlrsociety> Hello? Where are you from?
02:08:22 <dmwit> > showCReal 200 pi
02:08:24 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
02:08:29 <dmwit> kakashiAL: ^^
02:10:17 <dmwit> You could also use `Fixed` with a custom type for 200-decimal-digit precision, but it's up to you how you'll get digits of pi for it.
02:12:50 <dmwit> > fromInteger (round (pi * 10^12 :: CReal)) / (10^12) :: Data.Fixed.Fixed E12
02:12:52 <lambdabot>  3.141592653590
02:13:04 <dmwit> kind of nasty
02:17:24 <dmwit> :t fix (\x -> let r = fromInteger (resolution x) in fromInteger (round (pi * r :: CReal)) / r)
02:17:25 <lambdabot> error:
02:17:25 <lambdabot>     • Couldn't match expected type ‘p a’ with actual type ‘CReal’
02:17:25 <lambdabot>     • In the expression: fromInteger (round (pi * r :: CReal)) / r
02:17:59 <dmwit> :t fix (\x -> let r :: Num a => a; r = fromInteger (resolution x) in fromInteger (round (pi * r :: CReal)) / r)
02:18:00 <lambdabot> (HasResolution a, Fractional (p a)) => p a
02:19:05 <dmwit> ?let piFixed = let r :: Num a => a; r = fromInteger (resolution piFixed) in fromInteger (round (pi * r :: CReal)) / r
02:19:06 <lambdabot>  Defined.
02:19:13 <dmwit> > piFixed :: Data.Fixed.Fixed E6
02:19:15 <lambdabot>  3.141593
02:19:17 <dmwit> > piFixed :: Data.Fixed.Fixed E12
02:19:18 <lambdabot>  3.141592653590
02:19:37 <dmwit> ?let data E200; instance HasResolution E200 where resolution _ = 10^200
02:19:38 <lambdabot>  Defined.
02:19:41 <dmwit> > piFixed :: Data.Fixed.Fixed E200
02:19:43 <lambdabot>  3.14159265358979323846264338327950288419716939937510582097494459230781640628...
02:24:39 <nullie> where are 200 types of E?
02:24:44 <nullie> s/where/there/
02:27:17 <nullie> oh, I see
02:57:42 <Franciman> Hi, I'm reading through this example https://github.com/simonmar/parconc-examples/blob/master/geturls6.hs of parallel and concurrent programming in haskell, and I don't understand why this is correct
02:57:58 <Franciman> waitAny starts a thread for each async
02:58:11 <Franciman> each thread writes into an MVar
02:58:47 <Franciman> but then takeMVar is called only once. Why don't the other threads panic that putMVar is blocking indefinitely?
02:59:01 <Franciman> I thought that it was because the program was going to finish right after
02:59:16 <Franciman> but if I make the main thread loop forever, nothing seems to happen as well
03:27:04 <geekosaur> Franciman, because each one is going to its own MVar. the shared MVar is used only by waitAny; the other ones are still pending (or possibly completed but waiting their chance to be reaped); the final "mapM_ wait as" gets their results
03:27:15 <geekosaur> there's more than one MVar in play, in other words
03:27:57 <geekosaur> each thread gets its own MVar, then each wait* has its own MVar for communicating thread results to itself.
03:28:02 <Franciman> geekosaur, ok, but https://github.com/simonmar/parconc-examples/blob/master/geturls6.hs#L44
03:28:15 <Franciman> those threads created there, all have the same MVar
03:28:21 <Franciman> shouldn't they block forever?
03:28:59 <geekosaur> no. one "wait" finished; the others are still pending, and the final mapM_ wait "collects" those (doing takeMVar on each thread)
03:29:40 <Franciman> ok
03:29:55 <Franciman> but aren't the threads created at line 45 still running?
03:30:01 <geekosaur> yes
03:30:07 <Franciman> wait is over
03:30:09 <geekosaur> which, *again*, is why line 69
03:30:15 <geekosaur> *that* wait is over
03:30:20 <Franciman> ok
03:30:22 <geekosaur> that does not mean all threads reaped
03:30:25 <Franciman> and they do putMVar
03:30:37 <geekosaur> it means the other threads are running "free" until something else "wait"s
03:30:55 <geekosaur> on the MVar created on lin1 7
03:30:58 <Franciman> but shouldn't that putMVar hang forever?
03:30:59 <geekosaur> line 17
03:31:09 <geekosaur> *not* the one created on line 44
03:31:18 <geekosaur> er, line 43
03:31:34 <geekosaur> and that one won't hang forever, only until something does a wait on the thread,
03:31:45 <geekosaur> but you are continuing to think line 69 is pointless
03:31:54 <geekosaur> when line 69 is what allows those others to complete
03:32:46 <geekosaur> "aync" returns the (wrapped) MVar. some "wait" does the takeMVar at the end
03:33:22 <geekosaur> waitAny does a bunch of "wait"s until the first one returns; it then produces that, and the rest are left hanging but are still referenced by "as" on line 65
03:33:29 <geekosaur> then line 69 does the final "wait"s
03:33:38 <geekosaur> on "as"
03:33:43 <Franciman> perfect
03:33:57 <Franciman> but sorry, I can't still understand a thing
03:34:06 <Franciman> my as finish running
03:34:22 <geekosaur> the output is simply discarded (by mapM_)
03:34:22 <Franciman> but I still have the threads created by mapM_ forkwait as
03:34:39 <Franciman> or did they finish?
03:35:02 <geekosaur> they did their putMVar-s and finished. line 69 collects their output
03:35:17 <geekosaur> Haskell threads are not fork/join, they run independently and nothing monitors them
03:35:30 <geekosaur> except for explicit user code, which is what the whole async thing is about
03:35:53 <geekosaur> without that final putMVar, the thread would simply vanish and be reaped by the runtime
03:35:57 <Franciman> but all these mapM_ forkwait as put into the same MVar
03:36:07 <Franciman> right?
03:36:09 <geekosaur> no, they put into each thread's own MVar
03:36:12 <geekosaur> line 17
03:36:12 <Franciman> no
03:36:22 <geekosaur> each thread gets its own MVar
03:37:08 <Franciman> each thread created with async, you mean, right?
03:37:27 <geekosaur> yes. again, a forkIO thread has no synchronization by default
03:37:27 <Franciman> But those created with forkwait all refer to the common m
03:37:41 <geekosaur> yes, and those are separate threads internal to forkwait
03:37:45 <Franciman> ok
03:37:56 <Franciman> now, when the first finishes
03:38:00 <Franciman> and puts into the common mvar
03:38:03 <geekosaur> line 18 is the threads you care about
03:38:12 <geekosaur> the other forkIO-s are separate
03:38:44 <Franciman> Yes, but I don't understand why those other don't fire an error
03:38:53 <Franciman> waiting indefinitely to put into the common MVar m
03:39:05 <geekosaur> and have their own MVars. and are allowed to vanish on their own. (there *are* thread exceptions for those "manager" threads, but they vanish by default)
03:39:28 <geekosaur> which is why line 18 wraps the action in a try, to catch the exceptions from the "worker" threads and relay them
03:39:43 <geekosaur> but the exceptions from the "manager" threads go away because nothing is catching them
03:40:17 <geekosaur> raw threads are quite dumb, which is why you want an async library of some kind
03:40:53 <Franciman> ok, sorry for making you repeat many times, geekosaur. Thank you very much
03:40:59 <Franciman> I'll try to read more carefully
03:41:38 <geekosaur> well, you;re asusming a smarter thread library underneath. ghc threads are raw and dumb, you need to write your own smarts to handle e.g. exceptions in a thread
03:42:10 <geekosaur> which is why the async library exists (and part of what the parconc book was demonstrating is why you do need that)
03:42:13 <Franciman> so putMVar doesn't throw an exception
03:42:22 <geekosaur> it does. the exception jsyt vanishes if it isn't caught
03:42:26 <geekosaur> unless it is sent to the main thread
03:42:30 <Franciman> ah!
03:42:36 <geekosaur> but it's sent to the child thread, which is not catching it
03:42:37 <Franciman> that's what I was missing
03:42:46 <Franciman> and you told me :P
03:43:22 <geekosaur> except on line 18 the "try" catches the thread exception, and "wait" rethrows it if appropriate. but manager threads don't do that, they just watch for the PutMVar
03:43:26 <geekosaur> putMVar
03:43:36 <Franciman> so, to recap. Those other threads forkwait on putMVar do throw, but their exceptions vanish
03:43:45 <geekosaur> and let the exceptions from the manager threads vanish because they're not caught and rethrown
03:45:24 <geekosaur> actually they get rethrown to the threads created in firkwait, but those themsevles are not cathcing/rethrowing
03:45:37 <Franciman> ah perfect
03:45:39 <geekosaur> and if you don;t do all that catching.rethrowing the exceptions just vanish
03:45:47 <Franciman> thanks very much
03:45:58 * hackage word2vec-model 0.1.0.0 - Reading word2vec binary models  https://hackage.haskell.org/package/word2vec-model-0.1.0.0 (filipg)
03:46:12 <geekosaur> so unless you are aware of this and write a lot of scaffolding --- or use a library like async --- you get vanishing exceptions and unexpected bugs
03:46:53 <Franciman> all clear
03:50:15 <mpickering> Why do I see the error "cabal: There is no <pkgname>.cabal package file or cabal.project file"
03:50:24 <mpickering> when there is a cabal file in the directory
03:50:28 <mpickering> running "cabal new-build"
03:51:43 <geekosaur> because it's not named the same as the project (probably directory by default). new-build builds projects which can have multiple cabal files representing subprojects
03:52:27 <geekosaur> if it doesn't have a cabal.project telling it how the project fits together, it doesn't just guess the one cabal file is it, it checks that it matches the project.
03:52:37 <brki> hi folks
03:55:36 <mpickering> ok thanks geekosaur I just made a cabal.project and added projects: .
04:27:32 <contiver_> is there some way to use lists of at most N values? I've seen there are ways to express in the types that a list has size N, but not expressing an upper bound.
04:28:02 <jle`> contiver_: the same techniques could be applied to create bounded lists :)
04:28:16 <contiver_> I probably won't go that way, since I'm guessing it requires something like dependent types or something similar and that's currently over my head, but I was just wondering.
04:28:56 <jle`> you don't really quite need full dependent types unless you want to have bounds that vary at runtime
04:29:22 <jle`> but yeah all of the techniques for fixed-length lists could be applied to bounded lists too :)
04:29:42 <jle`> the easiest one being just the "smart constructor" wrapper around an unbounded list
04:30:10 <jle`> newtype LessThanFive a = LT5 [a]
04:30:25 <jle`> mkLessThanFive :: [a] -> Maybe (LessThanFive a), etc.
04:30:45 <jle`> or you can express it structurally
04:30:51 <contiver_> I currently have a data type in which I need to express that it takes a list of at most 2 values, for simplicity I'm just using 2 maybes, but that let's me express the case (Nothing, Just x), which is actually invalid in my case. It's more of a nuance than a real problem, still...
04:30:52 <jle`> you can think of 'Maybe' as a bounded list, actually
04:31:54 <jle`> if your case is just 2 then you can probably make a data type to represent it
04:31:57 <contiver_> thought about defining a custom maybe-like data type, having another constructor, say Two a a.
04:32:05 <contiver_> but was wondering if there was some other more standard way.
04:32:10 <jle`> and if you derive Foldable and Traversable, it's probably not too difficult to work with
04:32:30 <jle`> since you get toList, fmap, etc.
04:32:32 <geekosaur> there's These but it has the same problem arguably
04:32:45 <geekosaur> This a | That b | These a b
04:32:46 <jle`> These would not have the useful Functor instance
04:32:50 <contiver_> thought about These two, but yeah, same issue
04:32:51 <geekosaur> yeh
04:33:30 <jle`> there isn't quite a standard technique in this case, if that's what you're asking
04:33:39 <contiver_> I guess I'll go the 3-constructor-maybe way haha
04:33:44 <contiver_> thanks :)
04:35:59 <jle`> np :)  yeah if you derive Functor/Traversable then you probably have much of the same API as lists
04:36:55 * hackage fortytwo 1.0.3 - Interactive terminal prompt  https://hackage.haskell.org/package/fortytwo-1.0.3 (gianlucaguarini)
05:02:51 <lseactuary> anyone here good at set comprenension? i have made the solution but just wanted to double check the answer with someone (there are a couple of solutions but unsure which is good - i think its the final one)
05:02:54 <lseactuary> https://imgur.com/a/bJ1vO
05:05:31 <mniip> what the
05:06:31 <mniip> lseactuary, I'll be frank, I've seen you ask these types of questions on various channels (and SE) and it always looks like mathematical chicken scratch...
05:07:05 <lseactuary> im just following the book :(
05:07:19 <lseactuary> i can show you the book page pic if you want i am not making this notation up :/
05:08:37 <mniip> what's the book
05:09:03 <geekosaur> that's number theory. run away.
05:09:28 <geekosaur> (not the book, the notation)
05:10:38 <lseactuary> using Z: pecification, refinement and proof. jim woodcock.
05:10:42 <geekosaur> or ZFC set theory underlying it. and the $$ and \{ \} is TeX
05:10:49 <lseactuary> *specification
05:11:00 <mniip> like what is \bullet ? is this some logical connective?
05:11:28 <mniip> .1 and .2 I take are ordered pair projection functions?
05:13:03 <lseactuary> .1 etc is a projection yes. \bullet is just output. for example say you have a structure: <(1,hi),(2,bye),(5,greeting)>
05:13:17 <lseactuary> and you want to output all the words that have an index 2
05:13:35 <lseactuary> you would say x in set : x.1 = 2 (to set the condition)
05:13:39 <lseactuary> but this would output (2, bye)
05:13:42 <lseactuary> you just want bye
05:13:56 <lseactuary> so you do bullet x.2 to tell it to just output the second part of the tuple
05:14:29 <mniip> ok so he uses \forall x : \sigma \bullet e
05:16:46 <mniip> ok hmm
05:17:43 <mniip> mixing propositions and terms
05:18:11 <lseactuary> yes i think its wrong
05:18:17 <lseactuary> only the last line for each question looks correct to me
05:18:26 <lseactuary> there is no for all in set comprenshion
05:18:29 <lseactuary> my mistake
05:24:04 <lseactuary> i think a + b are correct it is c i am not sure about
05:24:11 <lseactuary> (the third line for b/c)
05:24:38 <mniip> okay, the book makes more sense
05:32:53 <lseactuary> mniip do you have thoughts on what i uploaded :)
05:51:41 <jchia_1> Suppose I have "data Foo = Foo Int; data Bar = Bar Int ()" Does Bar take more memory to store than Foo? The "()" has nothing to store, so does GHC optimize it away?
05:52:17 <jchia_1> Does the () actually take a pointer? What if I make it strict with a bag?
05:52:19 <jchia_1> bang
05:52:53 <mniip> () has something to store
05:53:10 <jchia_1> mniip: There's only one possible value. The only information is whether it's bottom
05:53:17 <mniip> that's plenty of information
05:53:28 <mniip> it's still a closure that you can enter
05:53:31 <jchia_1> if i make it strict, can it still bottom?
05:54:31 <geekosaur> it can't, and it's kinda pointless but might not be optimized away
05:54:35 <mniip> data Bar = Bar {-# UNPACK #-} Int !()
05:54:36 <mniip> does the trick
05:56:14 <jchia_1> I have "data PointF f1 f2 = PointF { x1 :: f1 Int, x2 :: f2 Int}". Sometimes, I may use "Identity", "Vector" or "Const ()" for the f's. That's why I want to know whether the '()' gets optimized away in cases when I use "Const ()".
05:56:17 <mniip> -funbox-strict-fields
05:56:47 <mniip> no. Const is not {-# UNPACK #-}
05:57:07 <jchia_1> Anything I can do to make the "Const ()" get optimized to nothing?
05:57:08 <mniip> actually
05:57:11 <mniip> I'm not sure
05:57:25 <mniip> it is a newtype, so it should desugar to ()
05:57:57 <mniip> however
05:58:05 * hackage fmlist 0.9.1 - FoldMap lists  https://hackage.haskell.org/package/fmlist-0.9.1 (SjoerdVisscher)
05:58:07 <mniip> obviously it cannot unbox polymorphic fields
05:58:23 <mniip> your plan is flawed from the start
05:59:29 <mniip> are you sure you're not doing premature optimization
05:59:47 <jchia_1> Right now, the bottleneck of my app is on comparison of PointF.
06:00:29 <jchia_1> The '-p' profiler output shows 'compare' as the largest item at 12%.
06:00:47 <jchia_1> largest cost center
06:01:09 <phadej> FWIW, Const () = Proxy
06:02:41 <phadej> and you can use `{-# RULES "comparePointFProxy" compare = comparePointFProxy #-}` (check manual on how to rewrite polymorphic functions when the types are applied, i don't remember if it's as simple as I wrote)
06:03:45 <phadej> and comparePointFProxy = \_ _ -> EQ (I guess, as there is nothing to compare)
06:05:24 <jchia_1> I haven't written any RULES before. I'm going to read up on that topic.
06:08:23 <Marisa_> Hi, I am reading http://conal.net/papers/icfp97/icfp97.pdf, and I have a question
06:08:42 <Marisa_> on page 3, it said Time = R + R (with R including 2 infinity)
06:09:33 <Marisa_> and then it define the bottom of Time! I dont get it, doesnt bottom already exists in R + R (as a bottom), and >= -inf is a non bottom Time value?
06:20:08 <geekosaur> Marisa_, this is not a "physical" bottom (nontermination) but a logical least defined value. the difference is that the latter is an actual value.
06:21:09 <geekosaur> well, not least defined. lowest
06:21:34 <geekosaur> least defined leads to physcal bottom. this wants the lowest value in an ordered value
06:21:36 <geekosaur> set
06:21:43 <Marisa_> Does Time have a physical bottom, but conal just play fast and lose reasoning?
06:22:16 <geekosaur> Conal is just not using the "bottom" you are thinking of
06:22:22 <geekosaur> lots of terms have multiple meanoings
06:23:08 <geekosaur> you can't define operations on time with least-defined "bottom". you can define operations on time with a least (as distinct from least defined) "bottom"
06:23:20 <ggVGc> multiple moanings
06:23:31 <Marisa_> Yep, I get that (since scott continuous?)
06:24:04 * Marisa_ wonder if laughing hard at midnight is good for health
06:24:22 <Marisa_> Anyway Thx... Reading on :)
06:24:28 <geekosaur> this is basically the bottom element of a (partially) ordered set, not the least defined
06:35:59 <Marisa_> wow... totally sold at frp... so beautiful
07:09:06 * hackage one-liner 0.9.2 - Constraint-based generics  https://hackage.haskell.org/package/one-liner-0.9.2 (SjoerdVisscher)
07:34:58 <jpcooper> Hello. I'm looking at creating a bot to play an online betting game. This will involve processing a stream of messages about the state of the game, simultaneously sending betting messages which may or may not be processed. What kind of frameworks exist in Haskell to do this kind of thing? I would like to avoid mutable state and actor ideas as much as possible
07:40:30 <nyberg> jpcooper: FRP
07:41:08 <jpcooper> Thanks. Looking into it
08:09:27 * hackage yesod-test 1.5.9.1 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.9.1 (MichaelSnoyman)
08:12:55 * hackage mono-traversable 1.0.7.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.7.0 (MichaelSnoyman)
08:23:26 <heebo> hello i have a problem with intero mode and stack lts 10.1, im getting
08:23:27 <heebo>         ```AesonException "Error in
08:23:27 <heebo>         $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid
08:23:27 <heebo>         flag name: \"bytestring--lt-0_10_4\""```  when i try and open in emacs
08:25:18 <cocreature> upgrade stack
08:25:18 <benzrf> hey, is anyone online who knows about STG and/or ghc's output?
08:25:39 <benzrf> i wanna know how thunk update works for thunks of functions
08:25:57 * hackage juicy-gcode 0.1.0.4 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.4 (dlacko)
08:26:26 <heebo> cocreature: thanks
08:27:17 <benzrf> i read the "i know kung fu" trac page and it was very helpful, but it only talked about thunk update for ADTs, where it adds a stack item so that when the force returns it gets sent to a procedure that will update the thunk
08:27:56 <benzrf> but - for functions, unless i misunderstand, the function itself doesnt get returned - it just gets tail recursed into, and the eventual return value is the result of the function... right?
08:30:09 <__monty__> I want to put some strings in a Vector Word8 conceptually I'm stuck after vector = fromList . concat . map <Char-to-list-of-utf8-bytes> $ "string". How do I write the Char conversion function?
08:33:19 <geekosaur> encodeUtf8 produces a ByteString. you can unpack that to [Word8]
08:34:40 <geekosaur> although you might do better to access the ByteString directly if you are using an unboxed Word8 vector (if not, you don't get any shortcuts)
08:35:54 <__monty__> Access directly? Can I assign a BysteString to a variable with an unboxed vector type?
08:40:43 <geekosaur> not directly. you can get at the memory with http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Unsafe.html#v:unsafeUseAsCString which gets you something that should have the same in-memory format as an unboxed Vector Word8
08:41:04 <geekosaur> although Storable Vector might be safer
08:41:56 <__monty__> The encodeUtf8 you're referring too, is that the one in haddock-library?
08:43:45 <geekosaur> actually I was thinking of the one for Text but you seem to be working with String? (I would recommend Text)
08:45:28 <__monty__> I'm only working with String to avoid the unnecessary extra conversion. String > Text > ByteString > Vector Word8 seems silly when all I want to do is initialize a predetermined vector.
08:45:32 <geekosaur> you probably want the utf8-string library otherwise, which will give you [Word8] that you can fromList directly: http://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-String-UTF8.html#v:fromString
08:50:00 * hackage parser-combinators 0.4.0 - Lightweight package providing commonly useful parser combinators  https://hackage.haskell.org/package/parser-combinators-0.4.0 (mrkkrp)
08:51:58 <lseactuary> question - if you have a list and a cartesian product with a sequence how does the data structure look?
08:52:58 <nullie> It could be [Sequence]
08:53:09 <nullie> or you could use another datatype
08:53:24 <nullie> more suited for whatever you want to do with that product
08:54:00 * hackage ats-format 0.1.0.10 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.10 (vmchale)
08:55:35 <lseactuary> nullie i have multiple constructor functions and a constant so unsure how this would look in data. RouteList ::= empty | join <<RouteList x seq_ID>>
08:55:50 <lseactuary> if you could show me a few tuples i will understand how to write the recursive function
08:56:05 <lseactuary> i read in the book that <1,<1,2>> is nonsense as the types are not the same therefore stuck
08:58:44 <lseactuary> or i can show you what i thought and you can correct?
09:01:24 <lseactuary> RouteList(⟨R1,R2⟩) = ⟨⟨⟨R1, ⟨S2,S3,S4⟩⟩, ⟨R1, ⟨S5⟩⟩⟩, ⟨⟨R2, ⟨S1,S2⟩⟩, ⟨R2, ⟨S5⟩⟩⟩⟩ where R1 = ⟨⟨S2,S3,S4⟩,⟨S5⟩⟩ and R2 = ⟨R2, ⟨S5⟩⟩
09:02:21 <lseactuary> is RouteList defined correctly using the defintion above? in the book i read its FreeType ::= constant | constructor <<source>>
09:02:31 <glguy> lseactuary: That still doesn't look like Haskell
09:03:28 <mniip> yeah that's Z notation
09:03:42 <lseactuary> ye
09:04:06 <lseactuary> trying to understand the data structure so i can write the recursion in math then haskell
09:05:18 <glguy> OK, once you have some Haskell questions we can help with that here
09:05:42 <lseactuary> but i cant get to the haskell q if i am clueless how the data structure is :)
09:05:46 <glguy> sorry
09:05:55 * hackage bittrex 0.5.0.0 - API bindings to bittrex.com  https://hackage.haskell.org/package/bittrex-0.5.0.0 (DavidJohnson)
09:06:13 <glguy> This is becoming a recurring thing
09:11:55 * hackage fast-combinatorics 0.1.0.0 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.0 (vmchale)
09:12:58 <__monty__> lseactuary: I missed your problem description MSG me the problem if you're still stuck.
09:13:33 <lseactuary> thanks! and sorry @glguy its my last question about math. will ask haskell stuff in the future.
09:37:00 * hackage propellor 5.2.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-5.2.0 (JoeyHess)
09:49:32 <fr33domlover> The real world version of the Force is the Haskell programming language
09:50:10 <fr33domlover> lastjedi ^_^
09:51:08 <monochrom> The Force decides which thunks to force and which ones not to.
09:51:25 * hackage test-framework 0.8.2.0 - Framework for running and organising tests, with HUnit and QuickCheck support  https://hackage.haskell.org/package/test-framework-0.8.2.0 (HerbertValerioRiedel)
09:52:04 <hpc> do or do not, there is no (>>=)
09:53:47 <liste> :t try --this is though
09:53:48 <lambdabot> Exception e => IO a -> IO (Either e a)
11:02:27 * hackage fast-combinatorics 0.1.0.1 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.1 (vmchale)
11:09:30 * hackage fast-combinatorics 0.1.0.2 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.2 (vmchale)
11:36:30 * hackage type-of-html 1.3.2.0 - High performance type driven html generation.  https://hackage.haskell.org/package/type-of-html-1.3.2.0 (knupfer)
11:42:59 <anon136> I have this function that someone showed me the other day for determining whether or not an int argument is prime. http://ix.io/Dy1 I'm trying to understand how it works. One thing I don't get is how on line 5 mod is taking 1 argument. If I try to call mod with 1 argument in CHCi it always returns an error as I would expect it to.
11:44:11 <__monty__> anon136: That's partial application.
11:44:28 <geekosaur> anon136, you are mapping a partially applied function, (mod a), over a list
11:44:49 <geekosaur> :t mod 1
11:44:50 <lambdabot> Integral a => a -> a
11:44:57 <geekosaur> :t mod
11:44:58 <lambdabot> Integral a => a -> a -> a
11:45:05 <anon136> right so its taking mod a l1 then mod a l2 ect...
11:45:18 <geekosaur> and building a new list of the result,s yes
11:46:47 <anon136> how come it doesn't work like this then? else not (elem 0 (map (mod a [2..(a-1)])))
11:47:16 <geekosaur> because mod takes a number, not a list of numbers.
11:47:22 <geekosaur> it is map that applies it to the list
11:47:23 <anon136> OH!
11:47:46 <geekosaur> map :: (a -> b) -> ([a] -> [b])
11:48:01 <geekosaur> we don't normally write the second set of parens, but it may be easier to understand maop that way
11:48:06 <anon136> is there any way it could be written more explicitly?
11:48:13 <geekosaur> turns a function (a -> b) into a function ([a] -> [b])
11:49:00 <geekosaur> not really, for an arbitrarily sized list
11:49:35 <anon136> well those were useful insights anyway. I appreciate the help.
11:50:28 <geekosaur> well, you could switch to a procedural language where you;d have to write the loop over the list elements explicitly
11:50:37 <geekosaur> Haskell makes that approach hard; it prefers the functional one
12:12:11 <waterdrop> What does it mean that every Applicative implies a monoid? I kind of vaguely see what it means, but I'm not completely clear on what the default way to extract a Monoid would be
12:13:47 <nullie> :i Applicative
12:14:02 <geekosaur> no :i in lambdabot
12:14:12 <Tuplanolla> % :i Applicative
12:14:13 <yahb> Tuplanolla: class Functor f => Applicative (f :: * -> *) where; pure :: a -> f a; (<*>) :: f (a -> b) -> f a -> f b; liftA2 :: (a -> b -> c) -> f a -> f b -> f c; (*>) :: f a -> f b -> f b; (<*) :: f a -> f b -> f a; {-# MINIMAL pure, ((<*>) | liftA2) #-}; -- Defined in `GHC.Base'; instance [safe] (Monoid w, Applicative m) => Applicative (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; ins
12:14:36 <nullie> % :i Functor
12:14:36 <yahb> nullie: class Functor (f :: * -> *) where; fmap :: (a -> b) -> f a -> f b; (<$) :: a -> f b -> f a; {-# MINIMAL fmap #-}; -- Defined in `GHC.Base'; instance [safe] Functor m => Functor (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] Functor m => Functor (StateT s m) -- Defined in `Control.Monad.Trans.State.Lazy'; instance [safe] Functor m => Functor (ReaderT r m) -- Define
12:14:50 <nullie> so no monoid?
12:15:02 <waterdrop> Oh
12:15:13 <waterdrop> Well I guess not
12:15:22 <geekosaur> it's truncated
12:15:35 <geekosaur> the output's kinda huge. which is why lambdabot doesn't even try to handle it
12:16:20 <waterdrop> :i Applicative does have a line instance Monoid a => Applicative ((,) a)
12:16:32 <Tuplanolla> The more interesting one is `instance Monoid m => Applicative (Const m)`.
12:16:52 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.1.0/Data-Monoid.html#t:Alt
12:17:18 <mniip> hmmm
12:17:41 <waterdrop> But that means that if a type m has a Monoid, then Const m has an Applicative, right? But that's different from every Applicative naturally implying a Monoid
12:17:55 <waterdrop> The latter would be like instance Applicative a => Monoid a
12:18:07 <geekosaur> waterdrop, please see the link I pasted
12:18:14 <mniip> %% :i Applicative
12:18:14 <yahb> mniip: http://qp.mniip.com/y/36
12:18:17 <mniip> nullie, ^
12:18:31 <geekosaur> actually wrong one
12:18:32 <geekosaur> hm
12:18:58 <nullie> well, no implied monoid
12:19:03 <mniip> no
12:19:03 <__monty__> Is there an easy way to map a function over the first element of a tuple? Currently just using a lambda.
12:19:06 <mniip> you can't really
12:19:09 <geekosaur> there's one for Alternative
12:19:16 <crucify_me> dang, sorry for my diatribe ignoramus yesterday, I am understanding newtype/data better.
12:19:21 <mniip> __monty__, first
12:19:24 <mniip> :t first
12:19:25 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
12:20:21 <__monty__> Hmm, found that but didn't understand the type.
12:20:22 <nullie> doesn't look right
12:20:34 <nullie> oh, arrow
12:20:40 <kadoban> > first (+5) (5, "hi)
12:20:42 <lambdabot>  <hint>:1:20: error:
12:20:42 <lambdabot>      lexical error in string/character literal at end of input
12:20:46 <kadoban> > first (+5) (5, "hi")
12:20:47 <lambdabot>  (10,"hi")
12:20:59 <kadoban> You should usually use the one from Bifunctor though
12:21:12 <mniip> :t Data.Bifunctor.first
12:21:13 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
12:21:26 <kadoban> Which ... acts exactly the same in this case. It just generalizes a different thing than Arrow does
12:22:32 <__monty__> Still don't get the arrow type. How does (+5) (5, "hi") :: a b c work?
12:22:45 <mniip> % :t first @(->)
12:22:46 <yahb> mniip: first @(->) :: (b -> c) -> (b, d) -> (c, d)
12:22:48 <kadoban> __monty__: The instance of Arrow there is  (->)
12:22:49 <mniip> better?
12:23:46 <geekosaur> waterdrop, ok, got it. Alternative is the monoidal version of Applicative, and there's a Monoid instance for (wrapped) Alternatives. see https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.1.0/Control-Applicative.html#t:Alternative
12:23:48 <__monty__> Wow, thanks. Eye opener.
12:24:25 <waterdrop> geekosaur: Ok thanks
12:24:45 <anelson> hey all, does anyone know if there's a good way to forM over the *pairs* of a HashMap (from Data.HashMap.Strict) without converting to/from a list? It seems pretty inefficient to add toList/fromList calls, although in practice it might be ok
12:25:34 <anelson> I can forM over just they values using the Traversable instance, but it doesn't give me access to the keys
12:27:01 <anelson> also there's a traverseWithKey but it doesn't let me alter the value of the key
12:27:13 <nullie> I guess toList is lazy
12:27:23 <nullie> so shouldn't be much overhead
12:27:34 <williamyager> I have a stack package with some local dependencies (stack packages in other directories). I haven't built this project in a while, and I've upgraded stack in the meantime. Now when I try to build the project, I get "Didn't see MyPackage-0.1.0.0 in your package indices", despite the fact that I have "- ../MyPackage" under "packages" and "- MyPackage-0.1.0.0" under "extra-deps" in my stack.yaml. ANy
12:27:40 <williamyager> suggestions?
12:29:12 <fraktor> I'm working my way through 99 Haskell problems, and a couple of my solutions seem like they should work, but don't.
12:29:36 <MarcelineVQ> remove it from extra-deps for a start
12:29:47 <fraktor> I've got a function that goes recursively through the list. I've got patterns that match [] and (_:xs), but it says that I have non-exhaustive patterns. What patterns am I missing?
12:29:56 <geekosaur> anelson, sequence . mapWithKey ?
12:29:56 <kadoban> williamyager: Is it set extra-dep: true in the packages part?
12:30:11 <waterdrop> So :t ($ 2) shows Num a => a -> a -> a
12:30:15 <waterdrop> er
12:30:16 <nullie> fraktor: what's the full type
12:30:16 <monochrom> fraktor: You will have to show actual code.
12:30:21 <anelson> geekosaur: doesn't let me change the key type I believe
12:30:23 <waterdrop> I mean it shows Num a => (a -> b) -> a
12:30:27 <kadoban> But yeah it shouldn't be *like that* in extra-deps. That form of extra-dep means "hey get this thing from hackage, with this version"
12:30:32 <lavalike> fraktor: it might be because of the patterns of other arguments or the value of guards
12:30:40 <MarcelineVQ> if your package is local and an extra-dep the way to specify that is what kadoban is suggesting, which is  - location: ../MyPackage\n  extra-dep: true
12:30:50 <williamyager> kadoban: No, it is not. What is the correct form? I have been using this form for a long time and not had any issues until now
12:30:57 <waterdrop> So this just means that ($ 2) is a function whose argument should have type a -> b where a is some type that has an instance of the Num typeclass, right?
12:30:59 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #4
12:31:28 <waterdrop> What I'm confused about is what if I pass a function a -> b where the a is more specific (for example the a is a Fractional or something)
12:31:38 <anelson> basically I'm looking for a signature HashMap k1 v1 -> (k1 -> v1 -> (k2, v2)) -> m (HashMap k2 v2)
12:31:45 <waterdrop> Is the 2 in ($ 2) guaranteed to be able to cast to the more specific type?
12:31:54 <anelson> with the appropriate type class constraints of course
12:31:54 <kadoban> williamyager: Behavior changed a little bit. That was never *quite* correct, but it used to work fine anyway. So yeah what MarcelineVQ suggests will work. The *new* way to do it is actually just do  extra-deps: - ../MyPackage     and that's it, nothing in "packages", but that'll only work with stack like, 1.6.1 or so and newer.
12:32:03 <geekosaur> waterdrop, in this case it accepts any type with a Num instance. anything with a Feractional instance is guiaranteed to have a Num instance
12:32:22 <fraktor> monochrom: I added a type declaration, and now it's working. I was letting ghci determine it for me before.
12:32:24 <kadoban> I'm in the process of making a bug report for the behavior change, it wasn't intentional as far as I know. The old way is supposed to still work, it just doesn't quite.
12:32:28 <MarcelineVQ> kadoban: that's good to know, hard to keep up to date
12:32:49 <kadoban> MarcelineVQ: Yeah, the new way is quite a lot less funky honestly, but having to learn it is unfortunate.
12:32:54 <waterdrop> geekosaur: Right. So I'm wondering why it's ok for it to only require a Num instance. What if I pass a function with type a -> b where the a is something more specific? couldn't it be possible that my function does something to the value of type a that's not valid for the 2 in ($ 2)?
12:33:07 <williamyager> kadoban: MarcelineVQ: Thanks y'all, just copying all the paths under extra-deps seems to be working. Will let you know if it fails
12:33:33 <geekosaur> waterdrop, no, because if it has a Num instance then it is guaranteed to be able to make any type that has a Num instance
12:33:48 <kadoban> williamyager: Cool
12:34:30 * hackage opn 0.1.3 - Open files or URLs using associated programs.  https://hackage.haskell.org/package/opn-0.1.3 (AndersClaesson)
12:34:45 <geekosaur> if it had specified Fractional a => , then you would not be able to do anything requiring a type without a Fractional instance. (but 2 would still work because it can be made any type with a Num instance, and any type with a Fracitonal instance must also have a Num instance)
12:34:59 <geekosaur> :t 2
12:34:59 <lambdabot> Num p => p
12:35:17 <geekosaur> the compiler handles numeric literals specially
12:35:17 <waterdrop> geekosaur: I see. Where is that implemented in Haskell? Is that just something specific to things that have a Num instance? Because in general, if I have a type A that has an instance X and a type B that has an instance X, it could be possible that we can't necessarily make a value of type A into a value of type B, right?
12:35:53 <monochrom> But 2 doesn't have a fixed type
12:36:26 <monochrom> See the Haskell 2010 Report for more details.
12:36:49 <geekosaur> waterdrop, it is not general, it is specific to Num (and numeric literals) per https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1360006.4.1
12:36:57 <waterdrop> I see thanks
12:37:11 <__monty__> Hmm, I just found liftFst in ghc Util can I use that without an import? Instead of first from bifunctor?
12:37:14 <geekosaur> there is a ghc extension extending special handling to String literals, and another extending it to lists; both have to be explicitly enabled
12:38:45 <geekosaur> __monty__, no.
12:39:17 <geekosaur> the Util module is part of the source to ghc itself, not part of the base library or exported from Prelude
12:39:25 <Durbley> what's an example of a type which is applicative but not alternative?
12:39:59 <__monty__> geekosaur: Ok, thanks.
12:40:17 <williamyager> Durbley: IO, probably?
12:40:17 <mniip> Durbley, maybe ZipList
12:40:22 <mniip> IO is alternative
12:40:39 <mniip> % empty
12:40:39 <yahb> mniip: *** Exception: user error (mzero)
12:40:48 <williamyager> Oh cool
12:40:55 <mniip> % empty <|> return "foo"
12:40:55 <yahb> mniip: "foo"
12:41:07 <glguy> Durbley: You can just look at the list of instances side-by-side in the documentation
12:41:21 <monochrom> State is Applicative but not Alternative
12:42:09 <glguy> In my config-schema package, ValueSpecs is an Alt, but not an Applicative (Alt is Alternative without empty)
12:42:44 <glguy> and SectionsSpecs is an Applicative and not an Alternative
12:43:06 <unyu> Are those pointless classes (Apply, Alt, Bind, etc.) ever going to be added to the standard library?
12:43:11 <glguy> and neither is Monad
12:43:21 <glguy> unyu: Probably not in much of a hurry
12:43:48 <williamyager> Is there any apply to fix the heirarchy of Monoid/Semigroup/etc?
12:43:55 <williamyager> s/apply/plan
12:44:07 <glguy> That's coming in 8.4 afaik
12:44:08 <geekosaur> it's in progress
12:44:15 <unyu> If you are going to add pointless classes, add all of them.
12:44:17 <williamyager> Cool
12:44:23 <geekosaur> and yes, I think the completion is in 8.4
12:44:23 <kadoban> Yeah, it's well underway thankfully.
12:44:39 <lavalike> wonder why there is Alternative IO but not Alternative ST
12:44:51 <geekosaur> you can't combine STs
12:45:04 <geekosaur> because of the phantom "state" type
12:45:38 <unyu> Wait, why is IO an Alternative?
12:45:51 <glguy> geekosaur: the instance would be: Alternative (ST s)
12:45:53 <geekosaur> (phantom existential, so there's no way to create one or cause one to be equal to another)
12:45:59 <kadoban> Ya, what's the behavior of IO's Alternative intstance anyway, hmm
12:46:36 <geekosaur> I might be too tired at this point, sigh
12:46:55 <MarcelineVQ> kadoban: something less useful than I expected
12:47:36 <unyu> I'm guessing it works by trying the next alternative if the previous one throws an exception?
12:47:45 <unyu> If so, that's truly horrible.
12:47:47 <lavalike> mplusIO m n = m `catchException` \ (_ :: IOError) -> n
12:48:02 <kadoban> Is that it, it works with exceptions? Kind of interesting. So yeah, I mean ST couldn't do that, it doesn't have exceptions (like that)
12:48:13 --- mode: glguy set +o-o glbot glguy
12:48:22 <kadoban> Is that horrible? I'm not sure I see why.
12:49:13 <unyu> Because, why does IO have to be hardwired to exceptions?
12:49:30 <monochrom> What would ST's <|> do?
12:49:54 <mniip> daily reminder to not catch exceptions outside of IO
12:49:56 <unyu> Don't we have a perfectly serviceable ExceptT transformer already?
12:50:46 <monochrom> Exceptions interact with concurrency. You can't refactor to separate them.
12:51:10 <monochrom> Err, no, that's not right either.
12:51:24 <kadoban> unyu: Ah, that. Yeah I don't really have strong opinions on that. I figure it's been like that too long to actually change it.
12:51:50 <unyu> monochrom: What makes exceptions, but not, say, backtracking, so special that they interact with concurrency?
12:52:02 <lavalike> monochrom: looks like Control.Monad.Trans.State.Lazy has an Alternative instance
12:52:24 <monochrom> Exceptions include async exceptions. A catch construct that masks async exceptions cannot be user-definable like ExceptT is.
12:52:42 <monochrom> Therefore both async exceptions and catch have to be hardwired.
12:53:14 * hackage hoppy-generator 0.3.4 - C++ FFI generator - Code generator  https://hackage.haskell.org/package/hoppy-generator-0.3.4 (khumba)
12:53:55 * hackage hoppy-runtime 0.3.2 - C++ FFI generator - Runtime support  https://hackage.haskell.org/package/hoppy-runtime-0.3.2 (khumba)
12:54:34 <monochrom> There is also the dilemma between "getChar :: IO Char" and "getChar :: Exception e => IO (Either e Char)"
12:55:21 <glguy> Why would getChar let me pick the type of exceptions that getChar catches?
12:55:45 <monochrom> culminating in my http://www.vex.net/~trebla/haskell/exception.xhtml
12:56:25 * hackage explicit-constraint-lens 0.1.0.0 - Fully-flexible polymorphic lenses, without any bizarre profunctors  https://hackage.haskell.org/package/explicit-constraint-lens-0.1.0.0 (leftaroundabout)
13:00:48 <monochrom> lavalike: That's (Functor m, MonadPlus m) => Alternative (StateT s m)  which is inapplicable to State which has m = Identity.
13:01:43 <monochrom> > empty :: State () ()
13:01:45 <lambdabot>  error:
13:01:45 <lambdabot>      • No instance for (MonadPlus Identity)
13:01:45 <lambdabot>          arising from a use of ‘empty’
13:01:58 <monochrom> wontfix
13:07:41 <lavalike> I suspected there was a catch
13:17:02 <Guest18> Profpatsch ping?
13:17:54 <Guest18> I'm looking at this comment for ghcjs in nixpkgs: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/compilers/ghcjs/base.nix#L157
13:18:04 <Guest18> what's the way to add cabal to the boot packages?
13:18:34 <Guest18> by default the ghcjsHEAD comes without Cabal installed, which can be a problem for tools that expect the library to be present in the global DB
13:18:55 * hackage log-warper 1.8.4 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.8.4 (shersh)
13:19:27 <n_blownapart> << no longer crucify_me. thanks for all the help.
13:26:50 <pierrot> Hello. How can I use the `string` function from Text.Parsec.Char ? I've done `import Text.Parsec.Char` in ghci and `let p = string "foo"` but it gives me an error
13:27:36 <glguy> pierrot: If you want help with an error message you'll have to share the eror message
13:27:47 <pierrot> "Non type-variable argument in the constraint: Text.Parsec.Prim.Stream s m Char"
13:28:29 <mniip> pierrot, :set -XFlexibleContexts
13:28:35 <glguy> pierrot: You can specify the type you wanted p to have if it's more specific than the inferred one, or you can turn on the extension
13:28:47 <glguy> The error message explains which extension
13:29:20 <glguy> Parsec does that do you because it using FlexibleContexts liberally: string :: Stream s m Char => String -> ParsecT s u m String
13:29:37 <pierrot> Can your provide me an example of what concrete type could have `p`?
13:29:57 <pierrot> the type signatures in `Parsec` are quite confusing ...
13:30:15 <mniip> ParsecT String () Identity String
13:30:17 <mniip> I think
13:30:37 <glguy> let p = string "foo" :: Parsec String () String
13:30:45 <mniip> yeah essentialy the same
13:30:49 <geekosaur> which should also be Parser String
13:31:20 <glguy> Yeah, which is defined in : Text.Parsec.String
13:31:35 <pierrot> Cool. Thanks glguy and mniip
13:33:43 <__monty__> Do imports have to be at the top of the file?
13:34:03 <mniip> yes
13:34:11 <glguy> They have to follow the 'module' declaration if you have one, otherwise yes
13:34:12 <mniip> before any bindings
13:34:56 <__monty__> Assumed that was the problem but couldn't find this anywhere.
13:35:47 <glguy> __monty__: See Haskell Report 2010: 5.1 Module Structure
13:37:09 <__monty__> glguy: Ah, yes. Thanks.
13:48:01 * hackage text-replace 0.0.0.1 - Simple text replacements from a list of search/replace pairs  https://hackage.haskell.org/package/text-replace-0.0.0.1 (chris_martin)
14:05:30 <mniip> of all things I didn't to use
14:05:34 <mniip> Typeable...
14:19:31 <mniip> I didn't plan to*
14:32:31 * locusff melps
14:58:18 <locusff> mniip: melp
14:59:02 * hackage composition-prelude 0.1.1.3 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-0.1.1.3 (vmchale)
15:02:07 --- mode: ChanServ set +o glguy
15:02:07 --- mode: glguy set +b *!*@gateway/web/irccloud.com/x-mwpzuijkqhkodjqg
15:02:38 --- mode: glguy set +b *!uid271105@gateway/web/*
15:03:57 <kadoban> Anyone know offhand which stackage lts stopped working with stack version 1.5.1 because of that AesonException thing? Trying to make a testcase for something but I can't remember where that happened.
15:07:32 --- mode: glguy set -bbbb *!*@gateway/web/cgi-irc/kiwiirc.com/ip.80.246.137.210 *!*322f530e@*.50.47.83.14 *!*@82.131.38.122.cable.starman.ee _1_alexfootball!*@125.14.31.96.cable.dyn.premieronline.net
15:07:33 --- mode: glguy set -b *!*@gateway/web/irccloud.com/x-mwpzuijkqhkodjqg
15:13:35 --- mode: glguy set -o glguy
15:13:42 <sqooq> how do I make a function with type a -> (a -> a)
15:13:45 <sqooq> with lambdas
15:13:51 <sqooq> \t -> (\f -> 2*(t/(1/f) - fromIntegral $ floor (1/2 + t/(1/f))))
15:13:51 <amf> anyone have examples of describing versioned apis? this has a simple example, but wondering if anything better exists http://hackage.haskell.org/package/daemons-0.2.1/src/examples/Name.hs
15:13:52 <sqooq> doesn't work
15:14:03 <sqooq> idk what I'm missing mentally
15:14:28 <glguy> :t \x y -> x
15:14:29 <lambdabot> p1 -> p2 -> p1
15:14:43 <mniip> the problem is in $ i believe
15:14:52 <mniip> x - y $ z
15:14:56 <mniip> parses as (x - y) z
15:15:00 <dmwit> sqooq: You are using numbers and stuff, but your type doesn't mention `Num` or stuff.
15:15:00 <glguy> :t \t -> (\f -> 2*(t/(1/f) - fromIntegral (floor (1/2 + t/(1/f)))))
15:15:01 <lambdabot> RealFrac a => a -> a -> a
15:15:16 <glguy> Got bit by a little $ addiction
15:15:35 <monochrom> $ is the root of all evil
15:15:47 <dmwit> therefore all evil is $^2
15:15:51 <glguy> :t \t f -> 2*(t/(1/f) - fromIntegral (floor (1/2 + t/(1/f)))) -- drop the extra \
15:15:52 <lambdabot> RealFrac a => a -> a -> a
15:15:54 <monochrom> haha
15:16:10 <glguy> and time = $
15:16:27 <sqooq> huh you were right
15:16:37 <monochrom> So the Time Square is evil...
15:16:49 <sqooq> $ was the mistake
15:16:56 <sqooq> but why does it require RealFrac?
15:17:02 <dmwit> :t floor
15:17:03 <sqooq> Or rather
15:17:03 <lambdabot> (Integral b, RealFrac a) => a -> b
15:17:23 <sqooq> Ok sorry my real question is, is Floating not a subset of RealFrac?
15:17:35 <sqooq> I did floating but it still complained
15:17:41 <dmwit> ?check \t (NonZero f) -> t/(1/f) == t*f
15:17:42 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 2 shrinks):
15:17:43 <lambdabot>  6.054211585282937 NonZero {getNonZero = -10.8508027961001}
15:18:32 <dmwit> > (6.054211585282937/(1/(-10.8508027961001)), 6.054211585282937*(-10.8508027961001))
15:18:33 <lambdabot>  (-65.69305599776972,-65.6930559977697)
15:18:54 <dmwit> IEEE754 =(
15:18:57 <monochrom> That's a bit strange
15:19:17 <sqooq> what's going on there
15:19:27 <dmwit> Rounding in the reciprocal, I would guess.
15:20:00 <klntsky> RealFrac and Floating are both subsets  of Fractional
15:20:02 <monochrom> Floating and RealFrac are siblings.
15:20:43 <monochrom> But they have a child RealFloat, if you will fancy that.
15:21:34 <dmwit> :t mod'
15:21:34 <lambdabot> Real a => a -> a -> a
15:23:53 <dmwit> > ((\v -> v - fromIntegral (floor (1/2 + v))) 0.8, (\v -> mod' v 1 - 1) 0.8)
15:23:55 <lambdabot>  (-0.19999999999999996,-0.19999999999999996)
15:24:01 <sqooq> wait so should I be using RealFrac instead of Floating in most/all cases
15:24:34 <monochrom> Is "it depends" an acceptable answer?
15:24:41 <dmwit> Oh, huh!
15:24:43 <dmwit> :t isIEEE
15:24:44 <int-e> monochrom: it depends
15:24:44 <lambdabot> RealFloat a => a -> Bool
15:25:07 <dmwit> ?tell kakashiAL You might like `isIEEE :: RealFloat a => a -> Bool`.
15:25:07 <lambdabot> Consider it noted.
15:25:30 <mniip> @check \x y z -> x + (y + z) == (x + y) + (z :: Double)
15:25:32 <lambdabot>  *** Failed! Falsifiable (after 4 tests):
15:25:32 <lambdabot>  -13.605256119026599 2.714823605393354 -59.22360513264076
15:25:37 <mniip> fun
15:25:55 <monochrom> That one is well-known.
15:27:21 <monochrom> Every numerical algorithm textbook reminds you to add up the small-magnitude numbers before adding on the large-magnitude numbers.
15:31:07 <monochrom> It's just that people don't want to read books systematically. They just want to exchange ad-hoc hearsay and speculation with each other to keep things mystical, like Medieval illiterate villagers.
15:33:56 <int-e> > (0.3 + 0.2) + 0.4 == 0.3 + (0.2 + 0.4 :: Double)
15:33:57 <lambdabot>  False
15:34:41 <int-e> @check \a b c -> let f = abs . (/10) . fromIntegral; x = f a; y = f b; z = f c in (x + y) + z == x + (y + z)
15:34:43 <lambdabot>  *** Failed! Falsifiable (after 12 tests and 3 shrinks):
15:34:43 <lambdabot>  2 10 4
15:34:47 <sqooq> hmm I figured Floating wouldn't be able to interact with RealFrac, but I was wrong
15:34:53 <sqooq> I guess I don't understand num instances well at all
15:35:55 <mniip> monochrom, ad-hoc hearsay about what textbooks remind you to do?
15:36:28 <mniip> can you devise a function that passes
15:36:34 <mniip> \xs -> ?sum (map fromRational xs :: [Double]) == minimumBy (comparing $ \s -> abs (toRational s - sum xs)) (map sum $ permutations $ map fromRational xs)
15:36:57 <dmwit> ?check \(Positive a) (Positive b) (Positive c) -> let f = (/3) . fromInteger; [x,y,z] = map f [a,b,c] in (x+y)+z == x+(y+z)
15:36:58 <lambdabot>  *** Failed! Falsifiable (after 6 tests and 2 shrinks):
15:36:59 <lambdabot>  Positive {getPositive = 5} Positive {getPositive = 3} Positive {getPositive ...
15:37:09 <dmwit> heh
15:37:16 <dmwit> We will never know what counterexample it came up with.
15:37:20 <mniip> my best attempt was
15:37:21 <int-e> oh I forgot about Positive
15:37:23 <mniip> sortSum = go . sort where go [] = 0; go [x] = x; go (x:y:xs) = go (insert (x + y) xs)
15:37:32 <mniip> but that didn't quite work
15:37:38 <mniip> actually hold on
15:37:52 <mniip> should sort by magnitude
15:38:10 <int-e> dmwit: but there was a reason for /10 instead of /3
15:38:42 <mniip> sortSum = go . sortBy (comparing abs) where go [] = 0; go [x] = x; go (x:y:xs) = go (insertBy (comparing abs) (x + y) xs)
15:38:45 <mniip> still doesn't quite cut it
15:38:49 <dmwit> int-e: Yes, we use base 10 for human communication. But there was a reason for /3 instead of /10: to point out that the only property that matters is that it be relatively prime with 2.
15:39:36 <dmwit> uh
15:39:40 <dmwit> base 9+1 =)
15:39:46 <dmwit> Everything uses base 10.
15:39:49 <int-e> > [(a,b,c) | s <- [0..], a <- [0..s], b <- [0..s-a], c <- [0..s-a-b], let f = (/10) . fromIntegral, (f a + f b) + f c /= f a + (f b + f c)]
15:39:51 <lambdabot>  [(1,1,4),(1,2,3),(1,3,2),(2,3,1),(3,2,1),(4,1,1),(1,1,4),(1,2,3),(1,3,2),(1,...
15:40:28 * hackage haskell-dap 0.0.1.0 - haskell-dap is a GHCi having DAP interface.  https://hackage.haskell.org/package/haskell-dap-0.0.1.0 (phoityne_hs)
15:41:59 <int-e> dmwit: Well, not a power of 2. For powers of 2, examples will be big.
15:44:03 <nshepperd> mniip: that sounds maybe impossible, since your function does not know what the original xs was
15:44:58 <nshepperd> whose sum may be a Rational not representable in Double \xs -> ?sum (map fromRational xs :: [Double]) == minimumBy (comparing $ \s -> abs (toRational s - sum xs)) (map sum
15:45:04 <nshepperd> uh
15:45:07 <nshepperd> dangit
15:47:20 <mniip> hmm ok
15:47:47 <mniip> how about
15:47:58 <mniip> \xs -> ?sum (xs :: [Double]) == minimumBy (comparing $ \s -> abs (toRational s - sum (map toRational xs))) (map sum $ permutations xs)
15:48:22 <mniip> well alright, evidently, fromRational . sum . map toRational
15:48:23 <mniip> but
15:50:21 <mniip> ugh
15:53:14 <nshepperd> @check \xs -> (kahan $ reverse $ sortOn abs $ xs :: Double) == minimumBy (comparing $ \s -> abs (toRational s - sum (map
15:53:14 <lambdabot>  <unknown>.hs:1:114:Parse error: EOF
15:53:36 <nshepperd> @check \xs -> (kahan $ reverse $ sortOn abs $ xs :: Double) == minimumBy (comparing $ \s -> abs (toRational s - sum (map toRational xs))) (map sum $ permutations xs)
15:53:42 <lambdabot>  mueval-core: Time limit exceeded
15:54:10 <nshepperd> I suppose that means that it works
16:00:58 * hackage fast-combinatorics 0.1.0.3 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.3 (vmchale)
16:07:45 <ryantrinkle> phadej: i'm working on adding support for "Get archive link" to your github package
16:07:46 <ryantrinkle> https://developer.github.com/v3/repos/contents/#get-archive-link
16:08:18 <ryantrinkle> i think i'm nearly there, but it's not quite clear to me what would be the best way to add support for a request type whose result is returned via a 302 with Location response header set to the result
16:08:43 <ryantrinkle> if you have any thoughts on that, they'd be appreciated!
16:08:52 <mniip> :t kahan
16:08:53 <lambdabot> Num p => [p] -> p
16:09:57 <mniip> > kahan [x, y]
16:09:58 <mniip> sorry what
16:09:59 <lambdabot>  0 + (x - 0) + (y - (0 + (x - 0) - 0 - (x - 0)))
16:11:12 <emmanuel_erc> :i kahan
16:11:31 <emmanuel_erc> nvm I guess
16:12:27 <mniip> free theorem tells us that we can recover the behavior of kahan from its output on all [], [x], [x,y], ...
16:12:35 <nshepperd> i wrote it, it implements https://en.wikipedia.org/wiki/Kahan_summation_algorithm
16:12:48 <mniip> killjoy
16:12:59 <nshepperd> :D
16:13:12 <nshepperd> > kahan [x, y, z]
16:13:14 <lambdabot>  0 + (x - 0) + (y - (0 + (x - 0) - 0 - (x - 0))) + (z - (0 + (x - 0) + (y - (...
16:14:58 <mniip> kahan (x:xs) = kahan xs + (x - kahan xs) - kahan xs
16:15:00 <mniip> innit
16:15:58 <mniip> no that's not right
16:16:32 * hackage composition-prelude 0.1.1.4 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-0.1.1.4 (vmchale)
16:17:41 <mniip> I'm not awake enough for this
16:17:57 <mniip> I'll just do more brainfuck compilation
16:19:15 <mniip> say, what's wrong with this code
16:19:17 <mniip> >>>[>>]>[-]>[-]<<<<[<<]<<[>>>>[>>]>>+<<<<[<<]<<-]>>>>[>>]>>[<<<<[<<]<<+>>>>[>>]>+>-]<[<<<[<<]<+>>>[>>]>-]<<<[<<]<[>>+<<-]>>[[->>+<<]+>>--]+<
16:19:43 <johnw> you're missing a <, clearly
16:20:06 <ryantrinkle> mniip: the language, i'd say
16:20:32 <ryantrinkle> phadej: here's the WIP for that API https://github.com/ryantrinkle/github/tree/get-archive-link
16:22:45 <mniip> that last +< triggers at the wrong place
16:27:26 <mniip> found the issue
16:35:31 <ggVGc> haskell is trading cryptocurrencies for me!
16:36:50 <mniip> fascinating, it's almost working
16:37:33 <robwebbjr_> While I'm awaiting a response on the #agda channel, I figured I'd cast a line here as well. Here is my post from that channel: Hello. Would you please help me with trivial issue? I'm just learning Agda along with discrete math and I simply need to prove that adding two even integers results in an even integer. I'm ok with the proof but I am having a difficult time trying to get Agda to recognize evens from odds. Simple in most a
16:37:56 <mniip> arrays are working if you don't read the last 2 elements...
16:39:06 <robwebbjr_> Sorry. The details are here: http://lpaste.net/360556
16:40:40 <sam__> is it possible to interleave some sort of calls to Debug.Trace functions between let bindings?
16:41:18 <sam__> something like `let a = f x; _ = Debug.Trace.trace a; in g a`
16:42:23 <mniip> :D
16:42:55 <Shiddums> I have a general question, I am new to Haskell and am trying to learn more about the standard convention of guard usage. When are guards more appropriate to use than pattern matching?
16:44:07 <sam__> Shiddums: you use pattern matching usually when matching on value constructors and guards when matching by logical predicates
16:44:38 <kadoban> Shiddums: You use guards when you can't use pattern matching.
16:47:34 <Shiddums> So if I have to check my parameters in some way that results in a Bool I should use guards. But otherwise I should default to using pattern matching?
16:47:49 <n_blownapart> hi how does this last program work? What do the arguments look like? thanks http://lpaste.net/361212
16:47:56 <not_a_robot> I need a CSV.Parser X but have a CSV.Parser (Maybe X). Is anyone familiar with cassava or can suggest a generic strategy for this situation?
16:48:05 <geekosaur> Pattern matching is about structure, not value
16:48:16 <Shiddums> 🤔
16:48:26 <geekosaur> if you need to check value, use a guard.
16:48:29 <ggVGc> but is there any value in pattern matchin?
16:49:18 <mniip> :D !
16:49:20 <mniip> http://tcpst.net/s1ea.png
16:49:27 <n_blownapart> I understand how the adder' function works, finally, but I'm not sure what the lengthy function parameters look like ^
16:49:37 <geekosaur> so Pattern matching lets you tell (Just something) from Nothing, but not (say) that it's (Just someValueIKnow). for the latter, you use the pattern for Just and then a guard to test against someValueIKnow
16:50:37 <geekosaur> (you could also compare that with ==, presumably, but there's more complex structures than Maybe. like picking a list apart element by element --- or every 2 elements, etc.)
16:51:43 <Shiddums> Ah ok, that makes more sense to me now
16:51:55 <Shiddums> Thanks for the help. I'm going to get back to reading.
16:52:57 <n_blownapart> is this a pattern match ? : lengthy (Cons _ xs) = 1 + lengthy xs
16:53:12 <n_blownapart> (Cons _ xs)
16:53:25 <n_blownapart> re: http://lpaste.net/361212
16:54:47 <sam__> nobody has a way to deal with laziness and Debug.Trace and let bindings? ie. `_ = traceShowId someExpression` wont be printed because it's value is not used.
16:55:14 <nullie> sam__: that's the point of trace
16:55:33 <nullie> sam__: use it on actual value
16:55:46 <sam__> nullie: and what if i never need that value?
16:56:03 <nullie> sam__: you don't need a trace then
16:56:05 <sam__> i just want to print a value at a site of multiple let bindings
16:56:19 <sam__> but i want to know what a value that is based on local bindings is without using it
16:56:28 <sam__> just to check my assumptions
16:57:03 <nullie> if you use thoes values in trace, they will be evaluated together with that function
16:57:16 <geekosaur> see, in a languagew with laziness, knowing whether *and/or* when something is actually evaluated is important
16:58:58 <spludge> hello.
16:59:38 <sam__> nullie: geekosaur yeah i know why it works this way. but i am asking for a way to work around it for this special case.
17:00:01 <spludge> I am looking to make a bot for the Solitaire minigame in Shenzhen IO. Pretty much it takes in a game state as an input and outputs a list of moves as the solution.
17:00:03 <geekosaur> there isn't one. if it isn't evaluated, it isn't evaluated
17:00:28 <geekosaur> this is not a procedurally evaluated program pretending to be lazy, if evaluation does not reach there then *it doesn't reach there* and there is no value
17:00:46 * ReinH .oO( seq )
17:00:56 <geekosaur> you took the right fork in the road, no point asking what bird is somewhere on the left, you can't know
17:01:16 <spludge> So far, I've got this: Get a list of all possible moves. Then apply the same function for the game state after the first move, as well as for the game state with the first move removed.
17:01:29 <spludge> That probably made no sense.
17:01:55 <not_a_robot> https://pastebin.com/AJAuSm3t Any advice for the last definition, where I need to produce a CSV.Parser Transaction but I have a CSV.Parser (Maybe Transaction)? (Or any other advice, I'm a haskell noob trying to learn)
17:02:22 <spludge> Sets of moves = sets using the first move + sets without using the first move
17:02:45 <spludge> I dunno I'm very new with programming, only played around in scratch before this.
17:03:02 <ReinH> spludge: The usual way is to build a game tree and search it for the best sequence of moves.
17:04:23 <spludge> Thanks ReinH. Just wondering if my method of making a game tree is typical. I modeled it after the counting coins example in SICP.
17:04:47 --- mode: glbot set -b *!uid271105@gateway/web/*
17:04:59 <sam__> geekosaur: i dont see why i shouldnt be allowed to check the bird on the left if i want to
17:05:07 <ReinH> It's the usual way to find a solution for a game.
17:05:36 <ReinH> At each state of the game, you build the tree by taking all possible moves.
17:05:43 <geekosaur> you can't do it with something that exists only on the left. you would have to have something at the fork which "follows both paths". (this is what ReinH meant about "seq")
17:05:48 <sam__> we already have things that circumvent the type system like debug.trace itself allowing you to perform IO from a pure function
17:06:06 <spludge> Ohhh right. That would probably work better, thanks.
17:06:12 <geekosaur> you can''t backtrack from your place on the right to get to the left, nor is something that is waiting for you to trigger it on the left going to go off by itself
17:06:32 <sam__> i dont see why there couldnt be some similar "trick" that made you able to "pretend" that a value is used
17:06:42 <ReinH> That "trick" is seq.
17:07:07 <ReinH> let a = traceShowId someExpression in seq a (your real computation)
17:07:18 <geekosaur> sam__, you should probably learn how Haskell evaluation works. as implemented, the only trick is to do something at the fork.
17:07:31 <ReinH> But needing to do this is a sign that something is wrong
17:07:41 <ReinH> So you should try not wanting to do this instead.
17:07:45 <geekosaur> or to lift the subcomputation out / put it at or before the fork
17:09:28 <sam__> well i have a function that contains a bunch of let bindings. one of the bindings is based on a fold so it "goes too far". thats why i wanna be able to insert just a single function application in the mix of let bindings without restructuring the expression too much.
17:09:57 <sam__> maybe that explanation came out a bit messier than expected
17:10:03 <glguy> sam__: What's the actual code you're trying to understand?
17:10:04 <ReinH> Can you show us some code?
17:13:56 <sam__> http://lpaste.net/5059637067152097280
17:14:09 <sam__> maybe an example is more illustrative
17:16:46 <sqooq> this is so dense
17:16:51 <sam__> as you can see `permutedState` is based on `iterate applyPermutation initialState` and to be able to check whether that part works OK, I just wanted to trace the value of `applyPermutation initialState`, ie a single application to check that I get the expected firstIterationState
17:17:24 <sam__> sqooq: ok, but can we focus on the actual question, this is not production code
17:17:31 <ReinH> Then why not `traceShow (applyPermutation initialState) (foldl' performMove ...)`
17:17:41 <sam__> ReinH: at the end?
17:17:42 <ReinH> or whatever the combinator is that takes a value to show and then the computation to perform
17:17:43 <ReinH> Yes
17:18:03 <ReinH> or let a = traceShow ... in a `seq` foldl' ...
17:19:22 <sam__> yeah i was doing that actually, but it would be nice to be able to have the trace calls as separate lines so they can be easily commented out or deleted when i dont need them any more without having to go back and remove something on the `in` line.
17:20:27 <glguy> Could use a bang pattern and have:   let !_ = traceShowId (the expression) in foldl' performMove ...
17:22:45 <sam__> glguy: beautiful! that is what i was looking for
17:22:58 <sam__> I think I considered bang patterns at some point, but didnt get round to trying it
17:23:28 * hackage ats-format 0.1.0.11 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.11 (vmchale)
17:26:54 <sqooq> sweet
17:27:09 <sqooq> conal, I'm trying to implement the switcher function but it seems nonsensical, it's "meta"
17:27:28 <sqooq> It requires knowing the current applied time before the applied time is actually applied
17:27:33 <sqooq> or am I missing something?
17:29:33 <conal> sqooq: unsure what you mean, but i suspect that you are missing something.
17:34:22 <not_a_robot> here's another attempt at propagating the Maybe-ness into the CSV.Parser, though this ends with an even more confusing error message https://pastebin.com/e5W1n5i8
17:35:26 <glguy> There doesn't appear to be any error message in that paste, also lpaste.net is better for Haskell code than pastebin.com and doesn't have ads
17:35:49 <not_a_robot> glguy, ok, just a moment
17:37:16 <not_a_robot> http://lpaste.net/8562664921219727360
17:38:01 <glguy> When you paste the error message it helps when you paste the whole thing and not the part you thought was most useful, too
17:40:11 <not_a_robot> glguy http://lpaste.net/5296549473244151808
17:41:23 <not_a_robot> If I remove the bind at the very end, I get that the type is Maybe (Int -> USD -> etc -> Transaction) which is what I expect. When I throw the bind in, I no longer understand how that type (etc -> etc -> Maybe Transaction) is being deduced
17:42:32 <glguy> What was the version of this that worked?
17:44:33 <not_a_robot> Well this http://lpaste.net/4807508296304951296 at least gives me the error message that I expect
17:44:43 <spludge> Should "data Newint = 1 | 2" work?
17:45:40 <not_a_robot> But as far as what actually worked, it was using fromJust after each maybeRead* instead of lifting the non-Maybe values with Just
17:46:05 <glguy> not_a_robot: I'm not sure what you're trying to do with these uses of just and the mix of extra . and <*>
17:46:38 <glguy> but you'll need to delete most of it
17:47:17 <spludge> scratch my earlier question
17:47:50 <not_a_robot> glguy Its just the best I could come up with at the time, but basically that .: operator is giving back a CSV.Parser, and I am mapping over that with various read functions, some of which may fail
17:48:13 <glguy> It'll be more like: Transaction <$> (read <$> (m .: "Reference Number")) <*> ....
17:48:17 <glguy> ust won't feature
17:48:25 <glguy> even better would be to use do notation here:
17:48:50 <glguy> do refNum <- m .: "Reference Number"; ...; return (Transaction (read refNum) ... )
17:49:12 <not_a_robot> And each field, I am collecting into a curried Transaction constructor... but because some of those fields are Maybes, I wrapped the non-Maybes into Just and used <*> again to combine them. n00b attempt
17:50:08 <glguy> If you want to move the read failure into the Parser logic you'll want to make something like:  readParser :: Read a => String -> Parser a;  readParser str = maybe (fail "bad read") return (readMaybe str)
17:51:49 <glguy> <*> won't feature when it comes to having fields with Maybe types
17:52:01 <glguy> You'll just treat those like any other field
17:52:13 <glguy> whether that field is supposed to be an Int or whatever
17:52:48 <glguy> also you shouldn't be using read directly, as I look at this documentation
17:52:58 <not_a_robot> what should I use?
17:53:01 <glguy> The (.:) operator works on an arbitrary instance of FromField
17:53:18 <glguy> so if you use that to extract an Int, it will
17:54:18 <not_a_robot> ok, that's convenient. So how should I deal with maybeReadUSD and maybeReadDate defined in my own source?
17:55:38 <glguy> by making an instance FromField USD
17:57:14 <not_a_robot> ah, I think I see... and instead of failing with Nothing, I can fail with CSV.Parser.mzero in my FromField instance, if I'm following you correctly?
17:57:22 <glguy> yeah
17:57:29 <not_a_robot> ok, that is much cleaner. Thank you
17:58:16 <kakashiAL> I want to calculate 1/3, but I would like to see 50 numbers after the points, I mean 0.333....<---I want to see 50 threes
17:58:41 <kakashiAL> BUT Float and Double is to small
17:59:04 <ReinH> Rational? CReal?
17:59:06 <kakashiAL> is there a way to tell that haskell?
17:59:09 <not_a_robot> kakashiAL have you looked at Scientific?
17:59:21 <glguy> > 1/3 :: CReal
17:59:22 <lambdabot>  0.3333333333333333333333333333333333333333
17:59:38 <ReinH> You can have as many as you want with CReal.
17:59:49 <ReinH> Or you can have the exact value 1/3 with Rational.
18:00:35 <ReinH> Float and Double have limitations as 32- and 64-bit floating point numbers in other languages.
18:00:44 <ReinH> s/have/have the same
18:01:06 <ReinH> At least, in the vast majority that implement IEEE-754.
18:01:56 <glguy> > 1/3 :: Data.Fixed.Fixed E50
18:01:58 <lambdabot>  0.33333333333333333333333333333333333333333333333333
18:03:08 * hackage EdisonCore 1.3.2 - A library of efficient, purely-functional data structures (Core Implementations)  https://hackage.haskell.org/package/EdisonCore-1.3.2 (RobertDockins)
18:04:03 <kakashiAL> glguy: as you can see, CREAL does not returns 50 numbers after the point, but the Fixed Type, is it also using IEEE ?
18:04:17 <glguy> kakashiAL: That's just how it printed
18:04:30 <glguy> the precision is there and there are more functions for you to play with the the corresponding module
18:05:46 <ReinH> CReal gives arbitrary precision.
18:05:56 <ReinH> > showCReal 50 (1/3)
18:05:58 <lambdabot>  "0.33333333333333333333333333333333333333333333333333"
18:06:42 <ReinH> Welp.
18:07:27 <kakashiAL> ReinH: could you say that Integer is a subset of shwoCReal?
18:07:42 <ReinH> What?
18:08:09 <ReinH> That question doesn't make sense to me.
18:08:22 <ReinH> Integer is a type. showCReal is a value, specifically a function.
18:08:30 <ReinH> How would Integer be a subset of showCReal?
18:09:18 <kakashiAL> ReinH: let me ask it this way, you know that a floating point number has the structure a.bcde........
18:09:52 <ReinH> I'm not sure if I agree with that.
18:09:58 <monochrom> I don't it is clear that you have the right structure in mind.
18:10:23 <monochrom> I mean, if you wrote "3.14e45" that would be closer.
18:11:10 <monochrom> At this point it is entirely possible you only have the layperson-on-the-street level of misconception rather than the correct technical concept.
18:11:16 <kakashiAL> ReinH, monochrom: I mean: numbers.numbers  (number a point  number)
18:11:45 <verement> kakashiAL: there is also https://hackage.haskell.org/package/decimal-arithmetic
18:11:46 <glguy> kakashiAL: No, that's only a textual view of floating-point numbers, that's not what they are
18:11:58 <ReinH> That is not the structure of floating point numbers. That's their decimal representation.
18:11:58 <kakashiAL> glguy: a totaly agree!
18:12:12 <kakashiAL> ReinH: yes, I know
18:12:23 <ReinH> Ok
18:13:09 <kakashiAL> glguy, ReinH: so the laterger the "front" part, the less bits I have for the numbers at the right side of the point"
18:13:20 <monochrom> It is also not clear why you bring up floating point when you're asking about Integer and CReal.
18:13:27 <kakashiAL> laterger = larger
18:15:21 <kakashiAL> xxx.yyy <--- this has more precision because we only have 3 numbers at the front, and more bits for the "y" parts THEN this: xxxxx.yy
18:15:24 <kakashiAL> got what I mean?
18:16:22 <spludge> Is there a better way of achieving this: https://pastebin.com/aXVs9arQ
18:16:22 <ReinH> That's not really accurate.
18:16:41 <kakashiAL> ReinH: but you know what I mean, right
18:16:47 <spludge> I was thinking of using record syntax with multiple constructors, but that seems to be frowned upon.
18:16:52 <ReinH> Yes, but it's not accurate.
18:16:54 <ReinH> A floating point number is not composed of "the stuff before the dot" and "the stuff after the dot".
18:16:57 <dmwit> When you say, "the more I have in front of the point, the less I have after", is that a statement about how you believe one of the types in {CReal, Fixed E50, Double} works? Or is it a statement of your desire about what you want to be true? Or what?
18:17:50 <ReinH> Recommend you read https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#10061
18:18:04 <kakashiAL> dmwit: I have an idea, because as I know all of them are IEEE 754 based, right?
18:18:06 <dmwit> It is not an accurate description of CReal or Fixed E50. It is sort of related to how Double works. If it is a description of your desire, then I don't know of a standard type with that behavior and a configurable size, but it shouldn't be too hard to implement yourself.
18:18:12 <ReinH> kakashiAL: No, they are not.
18:18:17 <dmwit> kakashiAL: No. Double is IEEE754. The others are not.
18:18:18 <ReinH> Maybe you should stop assuming things.
18:18:37 <kakashiAL> ReinH: not assuming, just asking
18:18:45 <ReinH> You said "as I know".
18:18:49 <spludge> Floats are something times a power of two right?
18:18:50 <ReinH> But you do not know.
18:19:32 <kakashiAL> ReinH: okay, I totaly do not know, sorry for not beeing clear enough
18:20:15 <kakashiAL> ReinH: could you tell me what datatypes uses IEEE754
18:20:32 <dmwit> Float and Double.
18:20:38 <dmwit> CFloat and CDouble.
18:20:39 <ReinH> Float and Double.
18:20:40 <kakashiAL> dmwit: thats all?
18:20:40 <dmwit> That is all.
18:20:51 <kakashiAL> ReinH, dmwit: thanks a lot
18:20:57 <kakashiAL> next step
18:21:54 <verement> kakashiAL: decimal-arithmetic is also based on IEEE 754
18:22:15 <kakashiAL> what other datatype do I have to represent decimals in haskell, and what do they use instead of IEEE 754?
18:23:31 <ggVGc> Rational?
18:23:36 <dmwit> Rational, Fixed, and CReal are all relatively standard. Rational is a pair of Integer's for numerator and denominator. Fixed is an Integer numerator with a type-directed choice of denominator. CReal is the computable reals.
18:23:39 <ggVGc> eh, ratio
18:23:41 <spludge> You could store it as a string, then convert each char into an int.
18:23:42 <ggVGc> Ratio*
18:24:02 <dmwit> cyclotomic is an interesting choice, too. It is more difficult to summarize in a single sentence how they are represented, but the wikipedia page on cyclotomic numbers is good.
18:24:44 <dmwit> ("the computable reals" in this case are represented by a function which takes a desired precision and produces the digits up to that precision, roughly)
18:27:17 <kakashiAL> dmwit: thanks, but what standard do they use?
18:27:17 <kakashiAL> and what decimal datatypes in haskell gives you arbitary precesin, only CReal?
18:27:40 <dmwit> Rational, CReal, and Cyclotomic are all arbitrary precision.
18:27:54 <dmwit> I don't know of a standard which covers any of these types.
18:27:58 <kakashiAL> dmwit: ("the computable reals" in .......<--- is that the answer to "what standard are they using" if yes I dont understand it
18:28:10 <dmwit> (Other than the Haskell Report, I guess, for Rational and possibly Fixed?)
18:28:53 <kakashiAL> dmwit: thanks
18:28:54 <verement> kakashiAL: decimal-arithmetic gives you arbitrary precision
18:29:31 <dmwit> Yes, and decimal-arithmetic looks neat. I hadn't seen it before. But I don't think it gives you arbitrary precision -- rather, you choose whatever precision you want and then you get that level of precision.
18:29:41 <kakashiAL> dmwit: stupid question, but do you also use cents, devide it by 10 and return dollar?
18:29:59 <dmwit> I don't understand that question.
18:30:05 <kakashiAL> or what type would you use, that is "currency" secure, because as I know the currency cases are the most critical
18:30:26 <dmwit> I think Fixed is a good choice for currency.
18:30:33 <dmwit> But then I don't work with currency much.
18:30:52 <ReinH> That depends on requirements but you provide more guarantees than that, e.g., https://hackage.haskell.org/package/safe-money
18:31:35 <ezyang> god bless "does not have required strict field" error; worth the price of admission
18:31:50 <ReinH> You can, e.g., make it a type error to add values of different currencies.
18:31:56 <ReinH> ezyang: o/
18:32:08 <verement> dmwit: does "infinite" precision count as arbitrary?
18:32:57 <dmwit> Yeah. Does d-a offer that?
18:33:01 <dmwit> Maybe I read the docs too fast!
18:33:17 <ezyang> ReinH: oh hai!
18:33:37 <verement> yeah, it's an option, albeit with fewer typeclass instances
18:33:46 <dmwit> neat!
18:35:44 <kakashiAL> verement: do you know the other standards that are used beside IEEE 754?
18:36:21 <verement> kakashiAL: do you have a particular standard in mind?
18:36:28 <kakashiAL> for decimals
18:37:43 <verement> I'm not sure I understand. Could you rephrase the question?
18:37:49 <kakashiAL> verement: no, I mean I know the IEEE 754, and I know that only Float and Double are using them, but whats with the rest?
18:38:02 <verement> rest of what?
18:38:31 <verement> as I said before, the decimal-arithmetic package is also based on IEEE 754
18:39:29 <kakashiAL> verement: what are the other standards that are used in haskell for decimals (other than IEEE 754)
18:41:10 <verement> I think that's already been covered. I don't know if the other types discussed here are based on any standard.
18:42:10 <kakashiAL> verement: thanks, if they dont follow a standard this is what I wanted to know :)
18:43:56 <monochrom> Applesoft BASIC had its floating-point format too. But it is not different in concepts. It's just different in details.
18:44:32 <kakashiAL> monochrom: got you, I guess they use other basis
18:44:38 <Zemyla> > realToFrac (1.7 :: Double) :: F.Fixed F.E1 -- dmwit, I would not recommend using Fixed at the moment.
18:44:39 <lambdabot>  1.6
18:44:57 <monochrom> Base is not the only detail.
18:45:16 <kakashiAL> so what type would you use for currency?
18:45:34 <Zemyla> Probably a type like Fixed, but that isn't broken rounding-wise?
18:45:39 <kakashiAL> in javascript I use Integeers and tranform them to dollars
18:46:03 <ReinH> You don't use Integers in javascript because there are no integers in javascript.
18:46:25 <monochrom> I would not false-dichotomize on "is it currency or not" in the first place.
18:47:06 <monochrom> I would base my decision on who I am conveying my numbers to and what their purposes are.
18:47:19 <kakashiAL> ReinH: I used the term to let other "non js guys" know what I mean
18:47:33 <monochrom> Many banks swear by BCD. If my program is to talk to them, I would do that.
18:47:41 <ReinH> You can use ints in Haskell if you want. You can also use other types, like I mentioned in my previous answer to this question.
18:48:03 <monochrom> But banks are not the only people I input/output money amounts from/to.
18:48:28 <monochrom> If my program is to talk to geeks, and if the geeks prefer IEEE 754, I would do that.
18:49:39 <monochrom> Knuth has a paper proving that base 2 causes much less rounding error than base 10 (and other bases).
18:49:47 <kakashiAL> ReinH: so the save-money package....okay
18:49:48 <kakashiAL> well, I have to study the pther types, the only thing that I know from JavaScript that I can translate to Haskell is FLoat and Double
18:50:00 <kakashiAL> the rest is tooooo abstract and when to use
18:50:10 <monochrom> Banks religionizing on base 10 is a manager layperson-on-the-street decision not a technical merit decision.
18:50:23 <Zemyla> monochrom: The problem is that all the operations round down, rather than rounding to even.
18:50:53 <verement> monochrom: do you have a link for Knuth's paper?
18:51:29 <monochrom> No.
18:51:42 <ReinH> Int is too abstract?
18:51:48 <kakashiAL> does anybody know some good sources that explain all decimal types in details?
18:51:58 <monochrom> But I think maybe Goldberg's "what every computer scientist should know about floating point" cites it.
18:52:01 <ReinH> They have documentation.
18:52:18 <ReinH> monochrom: which I linked above
18:52:21 <monochrom> Oh Int is both abstract and well-documented.
18:54:04 <ReinH> kakashiAL: If you want to use integers, you can use Int (for machine ints) or Integer (for arbitrary size ints).
18:54:22 <ReinH> For representing money as cents, Int would be appropriate.
18:54:50 <ReinH> I don't see how Int is tooooo abstract.
18:55:39 <monochrom> Actually abstracness is irrelevant here.
18:56:02 <ReinH> I don't think that's what kakashiAL means by abstract.
18:56:24 <monochrom> IO is also abstract. Hasn't stopped anyone from inputting lines, outputting logs, or catching exceptions.
18:56:32 <ReinH> But yes, whether they're algebraic or abstract is irrelevant.
18:57:00 <kakashiAL> ReinH: I just asked if using Int is okay for currency and common in haskell :)
18:57:07 <monochrom> Int enjoys a rich API, and the rich API supports everything everyone wants to do with Int values. That's enought.
18:57:24 <ReinH> kakashiAL: And three times now I've told you that you can use Int for money in Haskell.
18:57:30 <monochrom> And it is not even the academic theoretical kind of "can do everything in principle".
18:57:57 <kakashiAL> ReinH: what I find too abstract are the many many deciamal types of haskell
18:57:57 <kakashiAL> they are so many and I dont know what to use when and what is good for something
18:58:04 <monochrom> False dichotomies like this are simply not common in Haskell.
18:58:19 <ReinH> Again, they have documentation.
18:58:41 <ReinH> And, strictly speaking, they are not part of the Haskell standard library. They are in packages.
18:59:19 <monochrom> I don't understand why "it depends on the other factors you haven't mentioned" is not enough.
18:59:38 <monochrom> Because it always depends on the other factors you haven't mentioned.
18:59:56 <ReinH> npm has lots of numeric packages too
19:00:05 <kakashiAL> ReinH: sure, thanks for that again, I would just like to study the other decimal types of haskell and I would like to know if you know some good sources for them
19:00:14 <ReinH> Yes. Their documentation.
19:00:19 <kakashiAL> maybe a good paper or what ever :)
19:00:27 <ReinH> Maybe their documentation might link to a paper.
19:01:06 <kakashiAL> hmm...I am loking for something more "vivid" but okay, thanks for that :)
19:02:30 <ReinH> I mean, I don't think anyone has written a survey of numeric types in Haskell packages, but maybe you can find one.
19:03:53 <redrapscallion> so i'm putting a lot of unnecessary parentheses around stuff (bad habit from other languages)
19:04:25 <redrapscallion> are there any tools that can tell me where i have unnecessary parens?
19:04:45 <Rembane> redrapscallion: hlint is quite good at this.
19:04:45 <verement> hlint
19:05:18 <ryantrinkle> phadej: figured it out; pr up: https://github.com/phadej/github/pull/307
19:06:53 <waterdrop> I have a question about the associativity law in the Monad typeclass. My book states it as,  (m >>=  f) >>=  g =  m >>=  (\ x ->  f x >>=  g)
19:07:12 <waterdrop> On the right side, how is \x -> f x a legal first argument to >>=? I thought the first argument to >>= must have type m a
19:07:21 <waterdrop> But \x -> f x is not wrapped in the monadic structure m, is it?
19:07:24 <unyu> waterdrop: you're parsing it wrong
19:07:39 <unyu> waterdrop: It is \x -> (f x >>= g).
19:07:47 <waterdrop> unyu: Ah I see, thanks
19:08:06 <unyu> np
19:08:38 <waterdrop> unyu: Are precedence and fixities (ie, left assoc or right assoc) for operations for a typeclass also defined in that typeclass?
19:08:57 <unyu> waterdrop: The right-hand side of an anonymous function extends as far right as possible.
19:09:13 <waterdrop> I see
19:09:28 <waterdrop> unyu: But that's just because of it's precedence, right?
19:09:36 <ReinH> waterdrop: it's the *second* argument to >>=
19:09:45 <ReinH> Oh, sorry
19:10:16 <ReinH> That's because of the grammar rules for lambdas.
19:10:31 <waterdrop> ah right, it doesn't make sense to think of -> as an operation
19:10:39 <unyu> waterdrop: Fixities for user-defined functions are defined separately. But the "\ ... -> ..." is not a user-defined function.
19:10:43 <ReinH> waterdrop: Also, if you use >=> instead then the associativity law is that (f >=> g) >=> h = f >=> (g >=> h)
19:10:51 <ReinH> i.e., it's an associativity law
19:11:03 <monochrom> precedence and fixity are defined outside classes. They use the vanilla fixity declaration.
19:11:24 <unyu> s/But the/But/
19:11:24 <waterdrop> cool, thanks
19:11:31 <ReinH> and the unit laws are that return >=> f = f = f >=> return
19:27:55 * hackage star 0.0.1.0 - *-semirings  https://hackage.haskell.org/package/star-0.0.1.0 (chessai)
19:45:27 * hackage extensible-effects 2.3.0.0 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.3.0.0 (shergill)
19:47:10 <stillinbeta> hey all. Having a little problem with types: https://bpaste.net/show/01c54768fad6
19:47:29 <stillinbeta> I feel like I'm missing something basic here
19:49:59 <ReinH> stillinbeta: You can't use the same comparison function to compare numbers, characters, strings, and bools.
19:50:45 <stillinbeta> ReinH: huh. They're all in the Ord class, though?
19:51:04 <sqooq> is it possible to pattern match against functions
19:51:11 <sqooq> like if I wanted to make an integration function
19:53:04 <ReinH> sqooq: It is not.
19:57:17 <geekosaur> stillinbeta, the problem is that it's going to pick *one* "a" and stic =m with it
19:57:20 <geekosaur> *stick with it
19:57:48 <stillinbeta> geekosaur: can I talk it out of doing that?
19:58:01 <stillinbeta> or is there a simpler way to do this
19:58:17 <stillinbeta> my work around rn is returning an Ordering but that's a huge pain
19:58:28 <verement> RankNTypes?
19:59:01 <geekosaur> there is a way that gets past this issue but may cause others. RankNTypes and move the forall and (Ord a) constraint inside the parentheses for the type of cmp
19:59:16 <geekosaur> but, again, this can cause other problems
20:00:01 <ReinH> If you do that, you're restricting the caller to basically (==) or (/=)
20:00:24 <ReinH> Or some other weird function built from compare
20:01:07 <ReinH> I'm not sure what the point of passing in the comparison function is, but if you use RankNTypes then you probably won't be able to do it.
20:02:02 <geekosaur> in general, things like this work better when everything is done with a single type with multiple data constructors. in this case, one way to proceed might be for m Bool to become m ValueBox, with presumably a BooleanBox data constructor for the value. you'd need extra wrapping/unwrapping, and the comparison function would cause another problem because it's basically compareBox.
20:02:14 <geekosaur> so you'd need to rethink things a bit.
20:02:51 <ReinH> er, to one of the a -> a -> Bool member functions of Ord, or some other thing constructed by pattern matching on compare.
20:03:53 <stillinbeta> http://lpaste.net/361225
20:03:56 <stillinbeta> I ended up with this
20:04:18 <stillinbeta> which is not the cleanest code I've ever written, but lets me avoid including strange language features
20:06:13 <ReinH> Why are you doing that at all?
20:06:20 <monochrom> :)
20:06:32 <stillinbeta> ReinH: I'm writing an interpreter
20:06:47 <ReinH> Why not let the user pass a function Ordering -> Bool?
20:07:05 <ReinH> This is just a rube goldberg device for compare
20:07:58 <stillinbeta> ReinH: oh, that'd work
20:08:26 <ReinH> And also note that you can derive all of the other comparisons from (<=)
20:08:47 <ReinH> which is why the minimal definition for Ord is compare or (<=)
20:09:57 <ReinH> You can also turn all of those values into a function Ordering -> Bood
20:10:03 <ReinH> If you really must.
20:10:52 <stillinbeta> I feel like this a problem most interpreters of dynamic languages will encounter at some point
20:11:02 <stillinbeta> but admittedly I've never taken a compilers course
20:11:53 <ReinH> I mean, this particular problem is of your own invention.
20:12:03 <ReinH> You could do something else instead that wouldn't have this problem.
20:13:17 <geekosaur> I'm inclined to agree: you've chosen an odd way to represent this, and it's biting you. There are better ways to do it.
20:13:28 <stillinbeta> I'm certainly open to suggestions
20:13:48 <geekosaur> but, this is something that experience helps a lot with (and, this is how you get experience)
20:14:18 <stillinbeta> maybe after I'm done with this little project I'll read the dragon book or smth
20:52:25 * hackage dbus 0.10.14 - A client library for the D-Bus IPC system.  https://hackage.haskell.org/package/dbus-0.10.14 (blaze)
21:25:06 <Average-user> how can I make [a,b,c,d,e] -> ([a,c,e], [b,d]) ?
21:26:24 <monochrom> f [a,b,c,d,e] = ([a,c,e], [b,d])
21:26:59 <monochrom> Add one more equation for what to do if you receive a list of the wrong length.
21:27:31 <mniip> I think they mean
21:27:58 <mniip> f (x:xs) = first (x:) $ swap $ f xs
21:28:03 <mniip> f [] = ([], [])
21:28:36 <Average-user> what should be in the place of the smile?
21:28:46 <mniip> smile?
21:28:48 <monochrom> What smile?
21:28:55 <geekosaur> "(x:):
21:28:56 <geekosaur> er
21:28:59 <geekosaur> "(x:)"
21:29:01 <Average-user> fucking pidgin
21:29:05 <mniip> haha
21:29:06 <geekosaur> I think we have a misparse here
21:29:08 <geekosaur> oh
21:29:15 <geekosaur> yeh, kill the emoticons
21:29:17 <mniip> f (x:xs) = first (x : ) $ swap $ f xs
21:29:54 <Average-user> This is why I should always open irc on emacs
21:30:08 <geekosaur> you can tell pidgin not to do emoticons
21:30:30 <monochrom> Yeah, you should RTFM instead.
21:30:33 <geekosaur> sadly I don't think you can do so per window, so you can't have emoticons in non-IRC
21:30:40 <monochrom> Even emacs will not spare you from RTFM.
21:30:56 <geekosaur> (or per tab)
21:31:09 <noob41> I'm struggling with a basic parse error but am not sure of the solution:https://pastebin.com/pVxV4jWQ .  It doesn't appear to be related to spaces vs. tabs...but maybe it is? "parse error on input ‘=’     Perhaps you need a 'let' in a 'do' block?     e.g. 'let x = 5' instead of 'x = 5'"
21:31:21 <noob41> I'd be grateful for any help that could be provided
21:31:51 <monochrom> God all that green redaction.
21:32:01 <Average-user> geekosaur: I only use IRC on pidgin
21:32:11 <monochrom> Which line number?
21:32:52 <noob41> 35
21:33:16 <noob41> I saw the green too but it's not clear what the syntax highlighter is highlighting...
21:33:19 <monochrom> Where is "where"?
21:33:47 <noob41> nowhere... that would probably do it...
21:34:46 <geekosaur> be"where" of typos?
21:35:30 <noob41> A free dad joke along with help. I'm not sure what other channel offers that
21:35:35 <noob41> Thank you
21:35:43 <monochrom> Who's Who in American Art and Where's Where in Haskell Syntax
21:36:14 <noob41> had to add flexible instances too. Pulled the code from a blog and I guess I missed a chunk. I wish the compiler or hlint would have called it out
21:38:51 <sqooq> ugh I'm having woes
21:41:54 <sqooq> my program isn't outputting the right sound
21:41:59 <sqooq> but when checking the signal
21:42:05 <sqooq> everything seems to be in order
21:42:08 <sqooq> I can't figure out
21:42:09 <sqooq> what's going on
21:42:26 <sqooq> If I do simple tests to tease it out, they pass perfectly
21:48:51 <sqooq> this is making me pull my hair out
21:49:01 <sqooq> there's no evidence whatsoever this should be occuring
21:49:48 <amalloy> sqooq: perhaps someone will be able to help if you offer some more detail about your program
21:50:51 <sqooq> amalloy, it's an frp audio program
21:51:07 <sqooq> I'm trying to do fm synthesis which is where you modulate the frequency of a sine wave by another sine wave
21:51:48 <sqooq> but for some odd reason, the depth of the modulating wave is getting larger, almost as if it were being multiplied, but it's not, and it's output signal shows zero evidence that this is occuring
21:52:27 <sqooq> so I'd think maybe it's the fact that the actual sine being modulated, when it takes the signal as an argument, it's not working right
21:52:48 <sqooq> but I tested it with various signals, such as plain rising pitch, discrete pitch steps, decreasing pitch, etc.
21:52:54 <sqooq> and again, it seems to work perfectly
21:53:10 <sqooq> so like
21:53:22 <sqooq> there's zero evidence that what is occuring should be occuring
22:13:45 * hackage fast-combinatorics 0.1.0.4 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.4 (vmchale)
22:25:58 <sqooq> ok I think I'm misunderstanding how frequency modulation works usually. Because I'm just plugging frequency directly into the equation for sine wave. Other programs I think read a sine table, and so you're literally affecting how quickly that table is being read. I suspect this difference is the source of my problems, but Idk how to change it. Phase modulation (which accomplishes the same thing as frequency modulation) works fine.
22:28:28 * hackage fast-combinatorics 0.1.0.5 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.5 (vmchale)
22:31:06 <sqooq> Ok yes, I graphed it and it's definitely a mathematical misunderstanding I'm having. Neat.
22:39:45 <rlp10> Text.Pandoc.Generic's functions differ from Text.Pandoc.Walk because they are "generic". What does that mean here?
22:52:01 <c_wraith> rlp10: what package are those in?
22:52:49 <c_wraith> rlp10: in general, something named like that means it works with either Data.Data or GHC.Generics to handle introspection of data structures.
22:53:09 <c_wraith> rlp10: I was hoping to find the modules in question to confirm, but they don't seem to be in the pandoc package
22:53:40 <c_wraith> rlp10: ah, found them. pandoc-types package
22:54:23 <c_wraith> rlp10: yeah, those use Data.Data to inspect data structures, as opposed to needing the custom Walkable class in Text.Pandoc.Walk
22:59:21 <sqooq> what's wrong here? `\t f -> (f * t) - fromIntegral (floor f*t))`
22:59:37 <sqooq> ghc wants me to give them both RealFrac, and Integral constraints
22:59:49 <sqooq> but then there's no instance for Integral Double
22:59:59 <c_wraith> you're multiplying both floor f and f by t
22:59:59 <sqooq> when I try to actually use it
23:00:18 <sqooq> why is that a problem?
23:00:23 <c_wraith> that implies the type of t needs to be the same as the type of both f and floor f
23:00:25 <c_wraith> :t floor
23:00:27 <lambdabot> (Integral b, RealFrac a) => a -> b
23:00:40 <c_wraith> Which means it must have both Integral and RealFrac constraints
23:00:58 <sqooq> whaaat
23:01:03 <sqooq> let's say f and t are doubles
23:01:04 <c_wraith> And..  No types have that property
23:01:15 <sqooq> f*t = Double, Floor that makes an integral
23:01:19 <c_wraith> Double doesn't have an Integral instance
23:01:28 <sqooq> Why would it need to?
23:01:29 <c_wraith> so floor f can't be of type Double
23:01:44 <sqooq> floor takes a RealFrac and returns an Integral no?
23:01:54 <c_wraith> Those are both classes, not types
23:02:17 <c_wraith> floor's return value must be of a type that has an Integral instance
23:02:28 <c_wraith> and Double does not.
23:02:46 <sqooq> ok but when was it decided to be Double??
23:03:08 <c_wraith> when you said "let's say f and t are doubles"
23:03:34 <sqooq> :t floor (5.0::Double)
23:03:34 <sqooq> floor (5.0::Double) :: Integral b => b
23:03:34 <lambdabot> Integral b => b
23:03:59 <c_wraith> Did you mean floor (f * t) or something?
23:04:14 <sqooq> did I not write that???
23:04:16 <sqooq> omg
23:04:17 <sqooq> that's ti
23:04:18 <sqooq> lololol
23:04:47 * hackage extensible-effects 2.3.0.1 - An Alternative to Monad Transformers  https://hackage.haskell.org/package/extensible-effects-2.3.0.1 (shergill)
23:05:09 <rlp10> c_wraith: thanks for your help!
23:26:45 * hackage fast-combinatorics 0.1.0.6 - Fast combinatorics.  https://hackage.haskell.org/package/fast-combinatorics-0.1.0.6 (vmchale)
23:44:53 * hackage ats-format 0.1.0.12 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.12 (vmchale)
23:53:15 <haskell_luvr> hiya
23:53:38 <liste> hello haskell_luvr
23:54:19 <haskell_luvr> hi hi
23:54:26 <haskell_luvr> what resources do you recommend?
