00:05:33 <jchia> ertes: Where/how do I get the 'cartesian' that you mentioned?
00:13:47 <liuxin_> hi
00:17:16 <liuxin_> hello
00:19:13 <liuxin_> ?
00:19:30 <capisce> liuxin_: hello
00:32:37 <mniip> slightly impaired version of yahb available again
00:32:42 <mniip> running ghc 8.5
00:33:02 <mniip> fewer modules than normal while I am struggling to get lens to build on 8.5
00:35:48 <unclechu> hey guys, i'm still trying to build a c-compatible shared library but statically link all haskell packages, for that i must compile ghc with -fPIC
00:35:57 <unclechu> so i created this docker container: https://github.com/unclechu/haskell-experiment-shared-library-for-c-application/blob/master/docker/ghc-with-fpic/Dockerfile
00:37:58 <unclechu> and key change is https://github.com/unclechu/haskell-experiment-shared-library-for-c-application/blob/master/docker/ghc-with-fpic/my-build.mk
00:37:58 <unclechu> but when i try to build my library with flags `--make -static -shared -fPIC` i still get errors and advice to recompile ghc with `-fPIC`
00:38:03 <ertes> jchia: you write it
00:38:18 <ertes> jchia: either by hand or via Generic
00:38:24 <unclechu> how do i actually compile ghc with -fPIC? what would be the right way to do it so i could avoid any errors like this?
00:38:41 <ertes> jchia: using Generic starts making sense as soon as you have to write it for a lot of types
00:40:54 <mniip> how do I make sense of this cabal dependency error https://bpaste.net/raw/eed79cd06501
00:40:54 <s4ke> mniip coolio
00:42:29 <s4ke> That is cryptic
00:42:44 <mniip> like what even is distributive:setup
00:43:07 <mniip> is it from the custom-setup stanza?
00:43:11 <geekosaur> there's a separate set of dependencies for the Setup.hs when it's non trivial
00:43:11 <geekosaur> yes
00:44:56 <mniip> base >= 4 && <5,
00:45:02 <mniip> shouldn't conflict with 4.11.0.0
00:45:04 <geekosaur> so it looks like cabal-doctest requires base < 4.11
00:45:11 <mniip> ah
00:45:39 <geekosaur> you could try --allow-newer=base
00:46:30 <mniip> wait it's that simple?
00:46:45 <mniip> I don't have to manually edit packages' cabal files?
00:47:19 <saurabhnanda> jchia: yes, those are the libraries.
00:47:28 <geekosaur> if you don;t want to have to specify that every time,you would
00:47:28 <saurabhnanda> jchia: also, using newtypes when using tuples is a good idea.
00:48:00 <mniip> well, base-4.11.0.0 has a couple breaking changes though
00:48:07 <mniip> Typeable and Monoid
00:48:10 <geekosaur> that's why I said "try"
00:48:16 <mniip> right
00:48:27 <geekosaur> I wouldn't expect Typeable to affect this, Monoid might or might not
00:50:36 <geekosaur> unfortunately it looks like cabal-doctest was updated to 1.0.4 earlier this month, so it may be that there is a known incompatibility and you can't use it with ghc HEAD
00:50:56 <geekosaur> (8.2.2 supposedly has base 4.10.1.0)
00:51:38 <geekosaur> but since it's ghc HEAD that is base 4.11, more probably it just hasn't been tested
01:04:10 <mniip> it would be really cool if cabal didn't take 2 minutes to scan the package db every single time
01:22:25 * hackage conduit-extra 1.2.3.1 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.2.3.1 (MichaelSnoyman)
01:26:30 <saurabhnanda> heads-up... random spam about to come this way...
01:27:34 <geekosaur> saw :(
01:28:02 <Eduard_Munteanu> Usually people go from Haskell to Agda, but still.
01:38:55 --- mode: ChanServ set +o glguy_
02:17:06 <totom> Has anyone read this book https://www.amazon.com/Mathematical-Computer-Science-Mordechai-Ben-Ari/dp/1447141288
02:29:30 * hackage indents 0.4.0.1 - indentation sensitive parser-combinators for parsec  https://hackage.haskell.org/package/indents-0.4.0.1 (JasperVanDerJeugt)
03:06:06 <jw358> does anyone know how i might get the constructor generically from a record?
03:06:31 <jle`> jw358: it depends on what you mean by "get the constructor"
03:06:44 <jle`> but you can probably use something from Generic or Data, depending on what you want to do
03:07:07 <jw358> so the concrete case i have right now is that i have some simple records deriving generic
03:07:20 <jw358> e.g. data Section1 = Section1 { apple :: String }
03:07:44 <jw358> so i need to get the constructor Section1 generically
03:07:56 <jw358> and be able to use that with my typeclass that applies args to it to create the data type
03:08:40 <jw358> i have a really sad solution right now that takes in a record of constructors along side the things i'm actually using
03:09:09 <jw358> i.e. https://github.com/justinwoo/tortellini/blob/f710cc4ca0ebe5296e5604110f4b137074ee84ea/src/Tortellini.hs#L107
03:11:22 <ertes> that…  looks like some serious overengineering…  what are you trying to do?
03:12:05 <jw358> overall, parse an ini into a record of records of the fields
03:12:15 <jw358> the purescript version is much easier since row types make it easy
03:12:39 <jw358> i dont want to bother with existing hashmap solutions
03:12:40 <ertes> why don't you just parse it into a Map/HashMap?
03:12:46 <jw358> because i hate them and they lead to bugs
03:13:20 <jw358> that part is already done too
03:13:22 <ertes> good luck…  we have extensible record solutions, but none of them are particularly pretty
03:13:28 <jw358> haha
03:13:46 <ertes> i'd just parse into a Map/HashMap
03:13:48 <jw358> i mean, i've been able to solve most of my problems with haskell records by using a type family to convert hte generics to a list
03:14:03 <jw358> and writing classes to those lists
03:14:17 <jw358> without resorting to using extensible record libs
03:14:50 <ertes> i think a generic parser should be easy enough without any type-level magic
03:15:01 <ertes> at least if the ini fields match up with the record fields
03:16:41 <jw358> like just creating the rep and then converting it back to my type?
03:17:08 <ertes> yeah
03:17:26 <jw358> is there not something that uses that same mechanism to give me a concrete constructor though?
03:17:36 <jw358> like, already existing
03:17:41 <ertes> i don't understand the question
03:17:47 <jw358> this is what the manual thing looks like https://github.com/justinwoo/tortellini/blob/f710cc4ca0ebe5296e5604110f4b137074ee84ea/test/Spec.hs#L25-L44
03:18:06 <jw358> so i really only need one of those fields at a time
03:18:12 <ertes> you mean you don't want to create the type?
03:18:24 <jw358> for a given Generic a i want a function back for its args to a
03:18:31 <mniip> curious
03:18:51 <mniip> I didn't know you can implement reflection without unsafeCoercing through dictionary functions
03:18:54 <ertes> jw358: could you explain the problem on a higher level?  is the issue that you don't want to have to create those record types?
03:19:22 <jw358> no i'm fine with creating the types
03:19:27 <jw358> just not the constructors record
03:19:42 <ertes> what's that record good for?
03:19:49 <jw358> in the end i only want to define Config and Section1
03:20:21 <jw358> the constructors record is just what i use to get the concrete constructors
03:20:29 <jw358> but i want to get a generic one
03:20:33 <ertes> why do you need those?
03:20:43 <ertes> the point of Generic is that you shouldn't need them
03:20:52 <jw358> yeah
03:20:58 <jw358> i mean
03:21:02 <ertes> all you care about in a generic function is the shape of the type in terms of sums and products
03:21:11 <jw358> i want to get the n-ary function back from that
03:21:20 <ertes> why?
03:21:30 <jw358> data Section1 = Section1 {apple :: String} i want to get String -> Section1 back
03:21:52 <jw358> just because that would be nice
03:21:58 <ertes> for what?
03:22:15 <jw358> for building up this record of records
03:22:27 <dminuoso> Does haskell try to determine whether a lazy argument is eventually needed to evaluate it beforehand, and thus eliminate passing around thunks?
03:22:59 <ertes> jw358: Generic does all of that for you…  why would you then go back and do it manually?
03:23:07 <dminuoso> Or is it purely my job as a programmer to be strict whenever I know something to be needed eventually?
03:23:55 <ertes> dminuoso: GHC has some optimisations for that, but you shouldn't rely on them
03:24:54 <dminuoso> ertes: Mmm okay. This will be an interesting journey to gain an understanding of how to write efficient Haskell programs then. :)
03:25:18 <crk01> hi
03:26:41 <ertes> dminuoso: recently i've explain here in quite some detail how evaluation works and interacts with execution and strictness, but i don't really want to repeat it right now…  if someone has logs, they can probably share them with you =)
03:26:59 <ertes> can't be longer than three days ago
03:27:16 <dminuoso> ertes: Any phrases or keywords I can use to search in the logs?
03:29:30 <crk01> what's the best way to create a reader monad holding a connection to a database but without the need to recreate the connection everytime i want to unwrap the monad?
03:29:51 <ertes> dminuoso: the phrases "option A" and "option B" were used
03:30:01 <ertes> dminuoso: the other person had a very short nickname
03:30:57 <ertes> crk01: readers have nothing to do with the actual value other than passing it around…  the issue of creating them is orthogonal to readers
03:31:31 <crk01> ertes: it was more of an example to describe what i'm trying to achieve
03:31:41 <ertes> crk01: runReaderT (c >>= f) e = runReaderT c e >>= \x -> runReaderT (f x) e
03:31:44 <dminuoso> ertes: Ah I found it, it was on the 23rd. Thanks. :)
03:33:35 <crk01> ertes: let me rephrase it, what's the best way to manage a resource that has to be initialized only once?
03:34:07 <ertes> crk01: "manage"?
03:35:40 <crk01> ertes: where do i put it? MVar to simulate a global variable? how do i handle lifetime? are there best practice or i have to do it all manually?
03:35:53 <ertes> crk01: for creating and freeing resources the first function you should think of is 'bracket' from Control.Exception
03:36:16 <ertes> crk01: in particular doing this is wrong:  do res <- createRes; f res; closeRes res
03:36:31 <ertes> the correct way to do it is:  bracket createRes closeRes f
03:36:52 <ertes> crk01: as for *communicating* the resource, which is an orthogonal problem, personally i'd just use functions
03:37:15 <ertes> crk01: i maintain the position that ReaderT is an anti-pattern…  however, in my experience that's a minority position
03:37:26 <crk01> ertes: what would you suggest?
03:37:30 <ertes> crk01: functions
03:39:44 <crk01> ertes: ok, what if i have a module (X) that interacts with the resource, than i have another module (Y) that wants to use the first one, but Y doesn't want to know how to start the resource, how can design X? the only thing it comes to my mind is using the actor model and message passing
03:40:34 <ertes> crk01: i usually use the with* pattern
03:40:36 <dminuoso> <ertes> in other words: the way to keep laziness in control is to understand when the run-time evaluates the next action, and which IO actions evaluate something
03:40:48 <dminuoso> That sounds like the key of the whole thing.
03:41:00 <ertes> crk01: X exports a function (withResource :: (Resource -> IO r) -> IO r)
03:41:39 <crk01> ertes: but then Y has to know how to create the resource to pass it to X right?
03:41:49 <ertes> dminuoso: evaluation also causes a kind of avalanche effect
03:42:36 <ertes> dminuoso: evaluating x requires evaluating y first, etc.
03:42:49 <ertes> crk01: Y just uses withResource from X
03:43:03 <ertes> crk01: concrete example:  withFile from System.IO
03:43:22 <ertes> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
03:43:47 <ertes> you would use it like this:  withFile "blah.txt" ReadMode (\♥ -> …)
03:44:03 <ertes> now you can use ♥ inside …
03:44:54 <crk01> ertes: ah ok i see thanks, the only problem is how to keep the resource open and not reopening everytime
03:45:06 <ertes> crk01: just don't leave withFile
03:45:25 <ertes> main = withFile "blah.txt" ReadMode mainWith
03:45:29 <ertes> mainWith :: Handle -> IO ()
03:47:49 <crk01> ertes: that's not really an option for the program i'm developing, i have to exit the with
03:48:45 <ertes> crk01: why?
03:50:39 <Athas> So, what's the story if I want to write Monoid instances that will work in both older GHCs and the next GHC?
03:50:45 <Athas> They need to be an instance of Semigroup, I know.
03:50:58 <Athas> Do I just define a Monoid instance with mappend = (<>)?
03:54:06 <mniip> funny
03:54:15 <mniip> I'm battling with the same right now
03:54:21 <mniip> trying to install lens on ghc 8.5
03:54:31 <mniip> Monoid/Semigroup discrepancy all over the place
03:54:48 <Athas> I get into issues because Data.Monoid and Data.Semigroup define different <>s.
03:54:51 <kuribas> is there a version 8.5 already?
03:54:59 <mniip> it's the development branch of r8.4
03:55:06 <kuribas> ah :)
03:55:16 <mniip> odd numbers are development branches
03:55:44 <kuribas> shouldn't Data.Monoid.<> be defined as Data.Semigroup.<> ?
03:56:32 <mniip> % :i Data.Monoid.<>
03:56:32 <yahb> mniip: class Semigroup a where; (<>) :: a -> a -> a; ...; -- Defined in `GHC.Base'; infixr 6 <>
03:56:54 <mniip> % :i Data.Semigroup.<>
03:56:55 <yahb> mniip: class Semigroup a where; (<>) :: a -> a -> a; ...; -- Defined in `GHC.Base'; infixr 6 <>
03:56:58 <mniip> same Id
04:04:37 <mniip> also I just realized you can do this
04:04:42 <mniip> % :set -package ghc
04:04:43 <yahb> mniip: package flags have changed, resetting and loading new packages...
04:04:53 <mniip> % :i TcRnTypes.TcM
04:04:54 <yahb> mniip: type TcRnTypes.TcM = TcRnTypes.TcRn :: * -> * -- Defined in `TcRnTypes'
04:08:43 <maerwald> anyone using gRPC in haskell in production?
04:11:24 <Athas> mniip: they are different Ids in GHC 8.2.
04:25:59 <Athas> Apparently this is the way: https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Writingcompatiblecode
04:26:10 <Athas> CPP is a total no-go for me, though.
04:27:54 <phenoble> buffer +1
04:27:56 <phenoble> buffer +1
04:27:58 <phenoble> buffer +1
04:31:59 <mniip> hmm
04:32:06 <mniip> I've installed free-5 what more do you want...
04:35:12 <totom> Has anyone read Mathematical logic for computer science book?
04:49:46 <unclechu> if someone interested, - I just create an issue on stack overflow about compiling ghc with -fPIC https://stackoverflow.com/questions/47978884/how-do-i-recompile-ghc-with-fpic and linking library with static haskell dependencies
05:00:28 <mniip> it is done!
05:00:34 <mniip> % :t lens
05:00:35 <yahb> mniip: lens :: Functor f => (s1 -> a1) -> (s1 -> b1 -> t1) -> (a2 -> f b2) -> s2 -> f t2
05:01:45 <mniip> % :show linker
05:01:46 <yahb> mniip: ----- Linker state -----; Pkgs: [lens-4.16, vector-0.12.0.1, primitive-0.6.2.0, reflection-2.1.2, parallel-3.2.1.1, filepath-1.4.1.2, call-stack-0.1.0, kan-extensions-5.0.2, fail-4.9.0.0, adjunctions-4.3, free-5, exceptions-0.9.0, transformers-base-0.4.4, semigroupoids-5.2.1, unordered-containers-0.2.8.0, hashable-1.2.6.1, text-1.2.3.0, binary-0.8.5.1, bytestring-0.10.8.2, profunctors-5.2.1, mtl-2.
05:02:16 <mniip> some of these you won't even find on hackage!
05:05:30 <mniip> ooh
05:05:33 <mniip> interesting idea
05:06:14 <mniip> I could have like a virtual ro fs for pastebins
05:06:48 <Psybur> % :t prism
05:06:48 <yahb> Psybur: prism :: (Choice p, Applicative f) => (b1 -> t1) -> (s1 -> Either t1 a1) -> p a2 (f b2) -> p s2 (f t2)
05:08:20 <mniip> somethign about that lens type is off...
05:08:30 <mniip> % :set -fprint-explicit-foralls
05:08:30 <yahb> mniip:
05:08:32 <mniip> % :t lens
05:08:33 <yahb> mniip: lens :: forall {f :: * -> *} {s1} {a1} {b1} {t1} {a2} {b2} {s2} {t2}. Functor f => (s1 -> a1) -> (s1 -> b1 -> t1) -> (a2 -> f b2) -> s2 -> f t2
05:09:45 <Psybur> %! :(){ :|: & };:
05:09:45 <yahb> Psybur: bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash: fork: Operation not permitted; bash
05:11:32 <mniip> wait is the typechecker utterly broken
05:11:37 <mniip> % :t lens (\() -> ()) (\() () -> ())
05:11:37 <yahb> mniip: lens (\() -> ()) (\() () -> ()) :: Functor f => (() -> f ()) -> () -> f ()
05:11:41 <mniip> % lns = lens
05:11:42 <yahb> mniip:
05:11:44 <mniip> % :t lns (\() -> ()) (\() () -> ())
05:11:45 <yahb> mniip: lns (\() -> ()) (\() () -> ()) :: Functor f => (a2 -> f b2) -> s2 -> f t2
05:12:10 <yoho> Psybur: :D
05:13:24 <mniip> % unsCo = runIdentity . lns (\() -> ()) (\() () -> ()) Identity
05:13:25 <yahb> mniip:
05:13:40 <mniip> % runST (unsCo (putStrLn "Hello, World"))
05:13:41 <yahb> mniip: Hello, World
05:13:44 <mniip> okay what the
05:17:04 <hydraz> % :t 1
05:17:04 <yahb> hydraz: 1 :: Num p => p
05:17:10 <hydraz> oh, anyone can use it, fair enough
05:19:13 <yoho> % launchMissiles
05:19:13 <yahb> yoho: ; <interactive>:15:1: error: Variable not in scope: launchMissiles
05:19:20 <yoho> I think I've tried this before
05:32:06 <mniip> well so much for ghc 8.5
05:33:27 <yoho> is the issue there that a2/b2/s2/t2 aren't all () ?
05:34:18 <mniip> % type F x = forall a. a -> x
05:34:18 <yahb> mniip:
05:34:28 <mniip> % fun :: x -> F x; fun = const
05:34:28 <yahb> mniip:
05:34:37 <mniip> % :t fun
05:34:37 <yahb> mniip: fun :: x1 -> a -> x2
05:34:43 <mniip> evidently that is the wrong type
05:34:52 <mniip> should be x1 ~ x2
05:34:59 <ij> lyxia, Regarding http://lpaste.net/raw/360722, it's a tough example given that I'm encountering type families for the first time here, but I get it. Does @ have another meaning here or it's the same meaning?
05:35:57 <mniip> almost as if expansion of a qualified typesynonym overzealously generalizes type variables
05:37:20 <lyxia> ij: AFAIK @ has two meanings: as-patterns and type applications.
05:38:41 <ij> lyxia, Can you apply types with :: only sometimes then? (as with `show')
05:39:18 <lyxia> :: is just a type annotation.
05:39:30 <lyxia> f :: t   f HAS type t
05:39:41 <kuribas> Is haskell slower than scala?
05:39:58 <yoho> mniip: I'm getting the same result with that example in ghci 8.0.2
05:40:01 <lyxia> f @t   f is a function and its first argument is t
05:40:04 <yoho> not sure what yahb's running
05:40:25 <mniip> 8.5
05:40:28 <mniip> :t lens
05:40:30 <lambdabot> Functor f => (s1 -> a1) -> (s1 -> b1 -> t1) -> (a2 -> f b2) -> s2 -> f t2
05:40:31 <mniip> oh
05:40:38 <mniip> well that's not good!
05:41:40 <ij> lyxia, show :: Int -> String. Hasn't a type also been applied in this case? forall was given an Int and it gave us a Int -> String.
05:43:15 <lyxia> ij: the point of @ is the explicitness of what has been applied
05:46:39 <ij> lyxia, I'm refuting ":: is just a type annotation".
05:47:56 <mniip> welp, there's only much you can do with the IO combinators from Prelude...
05:49:18 <lyxia> ij: well, that's what it is...
05:52:09 <ski> in the expression `show :: Int -> String', the polymorphic `show' of type `forall a. Show a => a -> String' has implicitly been instantiated/specialized on the type `Int' (and then the evidence for the instance `Show Int' has also implicitly been provided)
05:52:37 <ski> one could say `show @Int :: Int -> String', if one wanted to explicitly instantiate `a' to `Int'
05:53:31 <ij> So there is some algo that checks that a polymorphic function can be reduced to the annotation that's been specified, so that is implicit instantiation?
05:53:38 <ski> (in `show (length "abc")', there's also an implicit specialization on `Int', without an explicit type ascription being needed)
05:54:27 <ski> type inference figures out what specialization of `show' is required, in each case, yes
05:56:54 <ij> Yeah, it seems you can't do without the "@Int" in the lpaste mentioned earlier.
05:57:14 <ij> I was really trying. It is very hairy.
05:58:10 <Boomerang> Hello! Is there any good documentation out there you would recommend for Haskell FFI to C? I have setup hsc2hs after having a quick look at the online version of Real World Haskell (chapter 17), but I am struggling to find out how to do the FFI for a C enum.
06:00:42 <ski> ij : your `f' is ambigous, as i suppose you're aware of
06:01:18 <ij> ski, Pastie's? I wasn't, what do you mean by that?
06:02:43 <ij> There is a forall in "forall a. F a -> Bool", but the a can't actually by anythign?
06:03:11 <ski> the type `F a -> Bool' doesn't determine `a', since your `F' isn't injective
06:03:27 <ski> `F a0' can be equal to `F a1', without `a0' being equal to `a1'
06:03:48 <ij> What do you mean, doesn't determine?
06:03:54 <ski> so, if we know the argument is `Int', so `F a = Int', that doesn't determine what type `a' is
06:04:23 <ski> so an application like `f (3 :: Int)' won't determine whether the `C Int' or the `C Bool' instance should be used
06:04:58 <ij> Ah, that's true.
06:05:25 <ski> the type checker has no way to infer/reconstruct the type `a', from looking at the type of the argument (and also, in general, the type of the result, though that doesn't matter in this case)
06:16:33 <ij> I would've expected @Int to work on implicit foralls. http://sprunge.us/ibJd
06:20:14 <ski> `\a -> ()' is probably not generalized in the middle expression
06:23:57 <ij> Since upon ambiguous application the compiler begins complaining, all of the time when AllowAmbiguousTypes is disabled, the applications are always injective?
06:24:11 <ij> If so, hadn't noticed/thought about it.
06:26:19 * hackage parser-combinators 0.3.0 - Lightweight package providing commonly useful parser combinators  https://hackage.haskell.org/package/parser-combinators-0.3.0 (mrkkrp)
06:33:20 <glguy> Boomerang: Which part do you not know how to do? hsc2hs has #enum for automating some of that. Building an enum manually with #type and #const and pattern synonyms is a a more flexible approach
06:33:31 <ph88> when i want to change something in the containers package should i recompile ghc ?
06:35:20 <Boomerang> glguy: Well the example that is given for #enum uses the preprocessor defined values: #define A 0; #define B 1; whereas the codebase I try to make an FFI for uses "typedef enum" (is that a C++ thing? I haven't done C/C++ in a while)
06:36:46 <glguy> Boomerang: #enum works with C's "enum" construct
06:38:35 <Boomerang> Oh ok cool, I'll look into that then. What documentation do you use when learning hcs2hs? The GitHub page gives a quick overview but I am not too sure how actually use some of these constructs.
06:38:48 <Taneb> Boomerang, typedef enum makes a type synonym for a possibly unnamed enum!
06:39:06 <Boomerang> Hey Taneb! :)
06:40:27 <yoho> > succ (1.0 :: Double) -- this kinda disappoints me
06:40:29 <lambdabot>  2.0
06:40:48 <Taneb> So in C when you define an enum you do "enum {X,Y,Z}" which is a type in its own right
06:40:59 <Taneb> So you can do "enum {X,Y,Z} foo = X;"
06:41:07 <muesli4> yoho Can you give a reasonable implementation? :D
06:41:16 <yoho> reasonable, absolutely not
06:41:26 <yoho> I can give you a more entertaining one though
06:41:38 <Taneb> You can also declare "enum foo {X,Y,Z};" then later "enum foo bar = X;"
06:41:50 <muesli4> yoho: Yes please.
06:42:14 <Taneb> Or "typedef enum {X,Y,Z} foo;" which makes foo a type synonym for enum {X,Y,Z}
06:42:26 <yoho> muesli4: one second while I figure out the bit pattern
06:42:39 <Taneb> I don't actually know how hcs2hs handles these, though
06:44:25 <Taneb> Boomerang, maybe https://github.com/haskell/hsc2hs#readme will be helpful?
06:44:34 <Taneb> Oh, you were looking at that already, sorr
06:44:35 <Boomerang> Right Taneb, so in my case it's that last version: "typedef enum {X, Y, Z} foo;". I made a "data Foo = X | Y | Z" for the Haskell version, I just need to make a Storable instance that actually matches the C version in order for the FFI to work properly
06:45:48 <yoho> @let unsSucc x = unsafeCoerce ((unsafeCoerce (2.0 :: Double) :: Int) + 1) :: Double
06:45:49 <lambdabot>  .L.hs:169:5: error:
06:45:49 <lambdabot>      Variable not in scope: unsafeCoerce :: Int -> Double
06:45:49 <lambdabot>      |
06:45:55 <yoho> lambdabot: boring
06:46:19 * hackage pandoc-emphasize-code 0.1.0 - A Pandoc filter for emphasizing code in fenced blocks  https://hackage.haskell.org/package/pandoc-emphasize-code-0.1.0 (owickstrom)
06:46:19 <yoho> muesli4: try that (note that it doesn't work generally, but it's correct for this example)
06:47:02 <yoho> % let unsSucc x = unsafeCoerce ((unsafeCoerce (2.0 :: Double) :: Int) + 1) :: Double
06:47:03 <yahb> yoho:
06:47:18 <yoho> % let unsSucc x = unsafeCoerce ((unsafeCoerce (x :: Double) :: Int) + 1) :: Double
06:47:19 <yahb> yoho:
06:47:29 <yoho> % unsSucc 2 -- here you go muesli4
06:47:30 <yahb> yoho: 2.0000000000000004
06:47:54 * hackage pandoc-emphasize-code 0.1.1 - A Pandoc filter for emphasizing code in fenced blocks  https://hackage.haskell.org/package/pandoc-emphasize-code-0.1.1 (owickstrom)
06:48:25 <glguy> Boomerang: Storable instances won't help you if you need to call a function that uses as enum type as an argument or result
06:49:06 <glguy> For that case what I described with using #type and pattern synonyms and const is more flexible
06:49:39 <muesli4> yoho: It's not so much worse than the original, considering it's bad already.
06:51:12 <yoho> nah, it's much worse than the original
06:52:29 <yoho> hm, it actually seems to work correctly for some definition of correct
06:52:39 <yoho> not normalised values though
06:53:24 <yoho> and an interesting way to illustrate the decrease in density of floating point numbers
06:54:19 <Boomerang> glguy: So something along the lines of "data Foo = #type foo; pattern X = 0; pattern Y = 1; pattern Z = 2;"?
06:55:14 <yoho> % let unsSucc x step = unsafeCoerce ((unsafeCoerce (x :: Double) :: Int) + round (2 ** step)) :: Double
06:55:15 <yahb> yoho:
06:55:17 <yoho> % [unsSucc 2 50, unsSucc 2 51, unsSucc 2 52, unsSucc 3 51, unsSucc 4 50]
06:55:18 <yahb> yoho: [2.5,3.0,4.0,4.0,5.0]
06:57:54 <glguy> Boomerang: Not data but type
06:58:11 <glguy> and then instead of hardcoding in numbers you use #const
07:02:37 <Boomerang> Oh yeah I did think hard coding the numbers wouldn't really scale properly. So "#const X" should work then?
07:02:55 <Boomerang> Thanks for your help! :)
07:09:29 * hackage hruby 0.3.5.1 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.5.1 (SimonMarechal)
07:18:22 <Athas> How come 'Either String' is not an instance of MonadFail?
07:18:47 <Athas> MonadFail seems to have no predefined instances that do not throw away the error message.
07:19:55 <glguy> IO's instance doesn't throw it away, at least
07:20:14 <jchia_1> This 19-line program gets a GHC warning (-Wmissing-methods) and hangs. What does it mean? Am I missing the true meaning of L13? Why does GHC generate a program that hangs instead of generating an compilation error? http://lpaste.net/361106
07:20:21 <Athas> Alright, that's true.  But it's not very useful to me.
07:20:45 <glguy> It's best to avoid flexible instances like MonadFail (Either String) would require
07:20:52 <Athas> Why?
07:21:02 <glguy> If you need such a thing you can already use transformers' ErrorT
07:21:50 <Athas> Ah, I see.  ExceptT does not have a useful instance, and that's what I generally use.
07:21:58 <jchia_1> I think maybe show ends up calling a function that doesn't exist, but why is there no compilation error? Also, how do I derive Show for Point (I know I can't derive it for PointF)?
07:22:28 <glguy> Athas: The purpose for ExceptT to exist is this difference in fail behavior
07:23:19 <osa1> what's wrong with `MonadFail (Either String)` ?
07:23:57 <glguy> It burdens your users to need to use FlexibleInstances, constraints get stuck when we don't know what specific type Either has been applied to
07:24:08 <glguy> the cleaner solution is the Error class that ErrorT relies on
07:25:11 <osa1> hmm, makes sense. thanks.
07:25:13 <glguy> For a more complicated class it typically means that logic has to be duplicated across instances
07:25:20 <ski> jchia_1 : did you mean to say `deriving instance (Show (f1 Int),Show (f1 Bool)) => Show (PointF f1)' ?
07:25:43 <glguy> the fail behavior of Either gets conflated with the behavior specific to String
07:25:55 <ski> jchia_1 : your `Show' instance fails to implement `showsPrec'
07:29:18 <jchia_1> ski: OK, I understand that I can use StandaloneDeriving. Why does GHC accept the "instance Show Point", though? Is it OK with having a nonsensical show function?
07:30:04 <jchia_1> I was under the impression that if I define an instance but don't define the minimum requirement, I will get a compiler error.
07:30:31 <jchia_1> "Minimal complete definition".
07:30:44 <Athas> It's more of a guideline.
07:31:53 <jchia_1> Athas: OK.
07:36:50 <tabaqui> lyxia: sorry, didn't see your message yesterday, I'll take a look, thanks
07:37:49 <inkbottle> If I do: newtype L a = L [a]; how can I access the data constructors?
07:38:52 <glguy_> By typing L
07:38:55 <nyberg> pattern matching
07:40:41 <jpcooper> Hello. Is there a nice function in QuickCheck which compares two lists element by element, showing the differing elements of the two lists if there are any? Scalacheck has something along the lines of this, and I was wondering whether this functionality already existed in QuickCheck
07:40:45 <inkbottle> :t L [3::Int] works
07:40:46 <lambdabot> error:
07:40:46 <lambdabot>     Data constructor not in scope: L :: [Int] -> t0 -> t
07:40:46 <lambdabot> error:
07:41:29 <inkbottle> but I can't figure out for L (:)
07:41:53 <nyberg> inkbottle: newtype L = L { get :: [Int] } or function (L xs) = ...
07:42:40 * ski fails to read inkbottle's mind about what they're trying to do
07:43:16 <jpcooper> They're called Matchers in Scalacheck
07:43:26 <inkbottle> nyberg: ok, that will probably do, I'll try that
07:44:31 <inkbottle> ski: instance Applicative L where... (for learning purpose)
07:45:11 <ski> is the problem matching on inputs of type `L a' ?
07:47:23 <inkbottle> ski: I think I'm getting to it, using the syntax from nyberg...
07:48:01 <nyberg> `get` is now a fucntion for extracting the list
07:48:29 * ski still doesn't follow ..
07:49:33 <inkbottle> nyberg: I'm presently trying to do the "thing" with the pattern matching syntax 'L (x : xs)'
07:49:42 <nyberg> `newtype` acts like `data`
07:50:39 <ski> inkbottle : if you have any code you'd like comments on, there's
07:50:40 <ski> @paste
07:50:40 <lambdabot> Haskell pastebin: http://lpaste.net/
07:53:01 <inkbottle> ski: http://lpaste.net/3865392453829787648
07:54:16 <ski> `(<*>) (L (x : xs)) (L ys)' can be written as `L (x : xs) <*> L ys'
07:54:46 <inkbottle> OK
07:54:57 <ski> `L [] <*> xs = xs' is a type error (wrt the expected type of `(<*>)')
07:55:16 <inkbottle> OK, that must be that
07:55:56 <ski> when you wrote `xs <*> ys', did you mean to say `L xs <*> L ys' ? (otherwise you're not making a recursive call there)
07:56:20 <ski> instead of `concat', did you mean `(++)' ?
07:56:29 <ski> `concat' takes a list of lists, `(++)' takes two lists
07:56:30 <inkbottle> Yesss
07:57:07 <hoon> I'm trying to appreciate strict functions/code/parameters to be cognizant of memory size. I assume foldM wouldn't be strict unless the function it called was strict. I think I've made an improvement to correct that here:
07:57:07 <hoon> http://lpaste.net/361114
07:57:10 <inkbottle> ski: I must try what you said... (I need a minute...)
07:57:12 <hoon> can someone double check me?
07:57:21 * hackage stylish-haskell 0.9.0.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.0.0 (JasperVanDerJeugt)
07:58:52 <ski> is `L [(2 +),(2 *)] <*> L [2,3]' supposed to answer `L [4,5,4,6]' (or maybe `L [4,4,5,6]') or `L [4,6]' ? or something else ?
08:12:53 * hackage digestive-functors 0.8.3.0 - A practical formlet library  https://hackage.haskell.org/package/digestive-functors-0.8.3.0 (JasperVanDerJeugt)
08:17:00 * hackage digestive-functors-blaze 0.6.2.0 - Blaze frontend for the digestive-functors library  https://hackage.haskell.org/package/digestive-functors-blaze-0.6.2.0 (JasperVanDerJeugt)
08:22:05 * hackage digestive-functors-happstack 0.6.1.2 - Happstack backend for the digestive-functors library  https://hackage.haskell.org/package/digestive-functors-happstack-0.6.1.2 (JasperVanDerJeugt)
08:27:49 * hackage digestive-functors-heist 0.8.8.0 - Heist frontend for the digestive-functors library  https://hackage.haskell.org/package/digestive-functors-heist-0.8.8.0 (JasperVanDerJeugt)
08:49:14 <ph88> when i want to change something in the containers package should i recompile ghc ?
08:51:40 <mniip> int-e, downgraded ghc?
08:51:58 <int-e> yes
08:52:33 <mniip> might wanna CC yourself to the ticket I guess
08:55:43 <hits1911> Is there a better way to replace last element of a string than init foo ++ bar which seems to require 2*n time to me. Or if this is an XY question, I need to get rid of \n from readFile
08:56:02 <int-e> @hoogle id
08:56:09 <lambdabot> Prelude id :: a -> a
08:56:15 <lambdabot> Data.Function id :: a -> a
08:57:35 <mniip> hits1911, you will need Omega(n) time for that in general
09:01:55 <hits1911> I agree we cannot go below that, but, isn't 1*n better than 2*n?
09:03:02 <mniip> it's hard to say what exactly is 1 and 2 here
09:03:24 <mniip> ++ and init will probably fuse
09:03:27 <mniip> into one function
09:03:37 <mniip> (see list fusion)
09:04:13 <hits1911> if that's so, then there's nothing to worry about.
09:04:19 <hits1911> thank you mniip
09:08:33 <troido> hits1911 if you do need to worry about performance in your code then the standard String type is probably not the best to use
09:09:55 <troido> it's very inefficient, when you need performance something like Data.Text is much better
09:11:20 <troido> (but try to avoid premature optimization and only use it when you need it)
09:11:59 <hoon> speaking of premature optimization...
09:12:22 <hoon> is the first version of the functions here any better than the second?
09:12:23 <hoon> http://lpaste.net/361114
09:12:35 <hoon> I'm just dipping my toe in trying to understand strictness
09:12:42 <yoho> well there's one way to find out really easily :D
09:12:48 <hoon> haha
09:12:56 <hoon> fair enough yoho(tchoc)
09:13:50 <hoon> (I assume you mean via profiling)
09:14:46 <yoho> yeah
09:15:08 <yoho> I'm sure someone here can give you a proper answer though
09:15:18 <hoon> :D
09:21:03 <mpickering> Why would the first be better than the second?
09:21:59 <hoon> better in the sense that the sums don't pile up
09:22:09 <inkbottle> [ski: sorry I've been interrupted]: L [(2 +),(2 *)] <*> L [2,3] gives actually L [4,5,4,6] (http://lpaste.net/5977874197131558912)
09:22:36 <hoon> (file1len + (file2len + (file3len + (file4len + (...))))
09:22:42 <hoon> into a big thunk
09:23:19 <hoon> it forces evaluation so that it doesn't consume as much memory
09:23:33 <hoon> by using foldl' and not foldl
09:24:11 <ski> inkbottle : well .. i didn't ask about what it gives, but what it's *supposed* to give as answer
09:24:17 <mpickering> Ok then just make the accumulator strict :)
09:24:19 <hoon> in #haskell-beginners -- glguy: recommended -- (+acc) <$!> writeFileBytes fname
09:24:30 <ski> inkbottle : also, did you consider writing `<*>' infix instead ?
09:24:44 <hoon> which does exactly that
09:24:59 <hoon> I didn't realize there was a <$!> function
09:25:05 <mpickering> glguy is definitely worth listening to
09:25:22 <hoon> haha
09:25:32 <hoon> I've only been around these parts a short while
09:25:40 <hoon> and I've already developed that impression :)
09:25:42 <inkbottle> ski: yes, yes, that could be done; The function is recursive now as you suggested (and it seems to give the same result as plain <*> on list)
09:27:13 <nullie> :t (<$!>)
09:27:15 <lambdabot> Monad m => (a -> b) -> m a -> m b
09:27:49 <yoho> nullie: presumably it's strict, hence the distinction
09:27:54 <Psybur> :t <$>
09:27:56 <lambdabot> error: parse error on input ‘<$>’
09:28:01 <Psybur> :t (<$>)
09:28:01 <nullie> oh
09:28:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:28:07 <ski> inkbottle : is that what you *intended* ?
09:28:28 * ski has no idea what behaviour inkbottle intended the `Applicative' instance on `L' to have
09:29:15 <hoon> right
09:35:00 <nyberg> :djinn Category a => a b c -> a b d -> a (b,d) (c,d)
09:35:05 <nyberg> hm
09:36:54 <inkbottle> ski: I'm just experimenting for learning purpose, but the intent was probably to mimic the behavior of plain <*> on lists
09:42:58 <dminuoso> ski: https://ro-che.info/ccc/8 =)
09:44:13 <mniip> hehe
09:44:18 <int-e> nyberg: : is not a lambdabot prefix... @ and ? are
09:45:07 <int-e> (does djinn know about Category though, I have no clue)
09:45:30 <mniip> in my formal systems course we had some tasks that asked to derive a formula in propositional calculus without using the deduction theorem
09:45:44 <mniip> no one could do these, and I'm like, pfft that's just SKI
09:47:15 <int-e> @. pl djinn (a -> b -> c) -> b -> a -> c
09:47:15 <lambdabot> f = flip
09:48:00 * hackage pandoc-emphasize-code 0.2.0 - A Pandoc filter for emphasizing code in fenced blocks  https://hackage.haskell.org/package/pandoc-emphasize-code-0.2.0 (owickstrom)
09:49:49 <nyberg> int-e: ah, first time using it
09:50:09 <nyberg> @. pl djinn Category a => a b c -> a b d -> a (b,d) (c,d)
09:50:10 <lambdabot> Error : Class not found : Category
09:50:16 <nyberg> @. pl djinn a b c -> a b d -> a (b,d) (c,d)
09:50:17 <lambdabot> (line 1, column 1):
09:50:17 <lambdabot> unexpected "-"
09:50:17 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
09:50:25 <nyberg> hm
09:51:42 <c_wraith> nyberg: that type can't exist, so you're probably getting parse errors from @pl as it tries to process the error message from @djinn
09:52:44 <nyberg> hm
09:53:14 <nyberg> ah, nvm
09:54:51 <ski> dminuoso : aye, i've seen it :)
09:55:06 <ski> inkbottle : ok
09:55:25 <dminuoso> ski: Yeah figured as much. Been going through some Haskell humor, that one was amusing and reminded me of the day when I figured out the meaning of your name.
09:55:35 <ski> inkbottle : you could try to make an alternative implementation, in which the answer to the expression before would involve the list `[4,6]'
09:57:19 <hoon> does haskell's openFile interpret "~/paths" correctly?
09:57:50 <hoon> (i'm in cygwin currently and it's not working)
09:57:59 <c_wraith> hoon: it won't expand paths like that.
09:58:05 <inkbottle> ski: That should be interesting; at the moment I'm trying QuickCheck on them (but what should be the answer for L [(2 +),(2 *)] <*> L [2,3,4]?)
09:58:06 <hoon> I don't know if it's some silly cygwin problem or not
09:58:08 <hoon> oh
09:58:11 <dminuoso> Isn't ~ a shell thing?
09:58:25 <hoon> I bet you're right
09:58:26 <mniip> int-e, I have a temporary workaround I guess
09:58:37 <hoon> thanks c_wraith
09:59:09 <mniip> % :set -dcore-lint
09:59:11 <yahb> mniip:
09:59:15 <mniip> % c = f' where f :: d -> forall c. d; f x = x; f' = f
09:59:16 <yahb> mniip: *** Core Lint errors : in result of Desugar (after optimization) ***; <interactive>:2:1: warning:; [RHS of c :: forall d d. d -> d]; The type of this binder doesn't match the type of its RHS: c; Binder's type: forall d d. d -> d; Rhs type: forall d d. d -> d; *** Offending Program ***; c :: forall d d. d -> d; [LclIdX]; c = \ (@ d_ajLW) (@ d_ajLX) ->; let {; f_ajLc :: forall k d
09:59:49 <dminuoso> Got a question. When I browse source code on hackage like this: https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.IO.html# I get errors like: Error: Parse error on line 1: {-# LANGUAGE Unsafe # -^ Expecting 'STRING', '}'
10:00:53 <mud> dminuoso: You get errors from what? Your browser? Confused.
10:01:38 <dminuoso> mud: https://i.imgur.com/GJ4hX2u.png
10:01:58 <c_wraith> dminuoso: do you have a JSON parsing browser extension installed?
10:02:09 <dminuoso> c_wraith: Ah yes I do indeed.
10:02:20 <dminuoso> c_wraith: Wow, how did you know.
10:02:26 <c_wraith> dminuoso: I think it's triggering on the first byte being {
10:02:31 <mud> Ah, okay. Wow, nice guess.
10:04:05 <dminuoso> c_wraith: Yeah indeed. Thanks :)
10:05:18 <amalloy> but the first byte isn't {. there's a bunch of html stuff in the <head> and even some more tags in the body
10:05:46 <amalloy> i mean, i agree the proximate cause seems to be this extension
10:05:46 <c_wraith> amalloy: a lot of those extensions search for things that "look like" JSON in the body.
10:06:03 <c_wraith> I think you're right that the beginning is not correct.
10:06:21 <amalloy> c_wraith: what surprises me is that hackage doesn't serve a Content-Type header at all, which i imagine would discourage the extension from parsing it as json
10:06:47 <c_wraith> I'll revise my guess to "it found '{...}' and decided it must be JSON inside the HTML"
10:07:36 <ski> inkbottle : either something with an error .. or truncate like `L [4,6]'
10:07:43 <amalloy> no, it does serve a Content-Type. i just missed it
10:07:51 <ski> > zipWith ($) [(2 +),(2 *)] [2,3,4]
10:07:53 <lambdabot>  [4,6]
10:08:47 <inkbottle> ski: Good idea (still struggling with my QuickCheck, but almost there)
10:09:20 <c_wraith> dminuoso: in any case, the error message in the screenshot just made me think "that looks like a JSON parser error", and I took a leap from there.
10:28:22 <sqooq> henlo good morning
10:28:57 <sqooq> I was told that recursion schemes, as in the category theory generalization of different kinds of recursions, was the way to go when doing recursion in haskell
10:29:03 <sqooq> what's the opinion on that in here?
10:30:01 <Rembane> sqooq: Recursion schemes is a powerful abstraction, but I don't know what it is that you want to do that needs them.
10:31:59 <sqooq> O don't worry I don't think I necessarily need them for my work
10:32:04 <sqooq> but just in the future
10:32:11 <sqooq> I've already spent a lot of time learning and working with a few
10:32:31 <sqooq> and to me it seems pretty great to be able to generalize it so much and make the recursion implicit
10:32:55 <sqooq> and making functor versions of your type is a walk in the park with DeriveFunctor
10:33:43 <sqooq> All that being said, someone else told me that I would never need to use them, they're a waste of time, I should just stick to folds and traverse and whatnot
10:35:56 <nyberg> They are general fold
10:35:57 <ertes> sqooq: that's kind of an odd statement
10:36:05 <nyberg> and unfild
10:36:10 <ertes> sqooq: you've probably used foldr before
10:36:18 <ertes> so you've already used recursion schemes
10:36:26 * hackage haskell-src-exts-simple 1.20.0.0 - A simplified view on the haskell-src-exts AST  https://hackage.haskell.org/package/haskell-src-exts-simple-1.20.0.0 (BertramFelgenhauer)
10:36:29 <dminuoso> ertes: so recursion schemes is just `folds` ?
10:36:33 <dminuoso> ;)
10:36:42 <Rembane> Strange folds with sugar on top?
10:36:47 <ertes> dminuoso: yes, folds, unfolds and related things
10:36:58 <dminuoso> ertes: Ah, so the family of things that act like that
10:37:44 <ertes> 'foldr', 'maybe' and 'either' are actually all instances of the same recursion scheme (even though in the latter case there isn't much actual *recursion* going on)
10:37:54 <ertes> called catamorphisms
10:38:23 <dminuoso> ertes: Ah, a new subject to explore once Im ready for F-algebras. :-)
10:38:37 <dminuoso> Soon I will need a bigger list.
10:38:51 <ertes> dminuoso: you've most likely already written F-algebras =)
10:38:58 <ertes> type Algebra f a = f a -> a
10:39:54 <nyberg> and coalgebra
10:40:47 <dminuoso> ertes: Okay Im not exactly sure about the intuition. I mean I have a somewhat remote idea what F-algebras are about when I read some articles about catamorphisms.
10:41:03 <dminuoso> But that type signature is not creating any "a-ha!" effect.
10:41:12 <ertes> dminuoso: it's really just that, there is nothing more to it
10:41:37 <ertes> dminuoso: the key idea is that given an F-algebra you can "fold" a (Fix F)
10:42:16 <johnw> https://en.wikipedia.org/wiki/F-algebra
10:42:36 <ertes> @let data ListF a x = Nil | Cons a x
10:42:37 <lambdabot>  Defined.
10:43:17 <ertes> @let foldr2 f [] = f Nil; foldr2 f (x:xs) = f (Cons x (foldr2 f xs))
10:43:18 <lambdabot>  Defined.
10:43:20 <ertes> :t foldr2
10:43:22 <lambdabot> (ListF a x -> x) -> [a] -> x
10:43:41 <ertes> 'foldr' and 'foldr2' are equivalent
10:44:06 <sqooq> ertes: so I take it you like recursion schemes lmao
10:44:11 <sqooq> you seem to know a lot about them
10:44:20 <sqooq> I like it, it feels like a clean organization of the different common types
10:44:26 <ertes> sqooq: yeah, they're useful – practically
10:44:28 <sqooq> and you rarely need to go past para/apo morphisms
10:44:48 <ertes> it's not just a matter of elegance
10:44:59 <nyberg> The only irritating things about recursion schemes is totality
10:45:05 <dminuoso> ertes: Mmm. Is that `f` in that original type signature necessarily a Functor?
10:45:49 <ertes> dminuoso: well, as you can see foldr2 doesn't insist on 'f' being a functor, but in categorical terms it only makes sense when it is
10:46:48 <dminuoso> ertes: Okay. Staring at this, this looks suspiciously similar to
10:46:49 <dminuoso> :t fix
10:46:50 <lambdabot> (a -> a) -> a
10:47:07 <ertes> lift it up a level
10:47:16 <ertes> [a] ≃ Fix (ListF a)
10:47:22 <sqooq> kek I actually learned basic category theory derivation of the morphisms, a -> f a, fmap from f a -> f b, f b -> b, is catamorphism if I'm not mistaken
10:47:39 <dminuoso> ertes: What does ≃ denote? Isomorphism?
10:47:44 <ertes> yeah
10:48:34 <ertes> Fix :: f (Fix f) -> Fix f  -- this is also an f-algebra, but it's a special one
10:49:34 <nullie> > fix (const 1)
10:49:37 <lambdabot>  1
10:49:53 <ertes> unFix :: Fix f -> f (Fix f)  -- likewise this is a special f-coalgebra
10:50:10 <ertes> but i'm not gonna spoil the ending…  you know…  what terminates the story =)
11:00:16 <sqooq> mfw structure is preserved
11:00:26 <sqooq> ertes: is your wires library actually complete/good?
11:00:56 <ertes> sqooq: it's complete…  not sure about good, because it's AFRP
11:01:05 <sqooq> o
11:01:07 <sqooq> lol
11:01:12 <sqooq> i thought you didn't like arrows
11:01:27 <ertes> exactly =)
11:01:42 <sqooq> :thinking:
11:01:52 <sqooq> why make a afrp library, if you don't like a
11:01:53 <ertes> unless you have a good reason to use AFRP use reactive-banana or reflex
11:02:06 <sqooq> ok, what about grapfruit
11:02:11 <sqooq> is that one any good?
11:02:15 <sqooq> grapefruit is my favorite fruit
11:02:21 <sqooq> so it's tempting me
11:02:47 <ertes> two reasons: wires is the replacement for the now deprecated netwire library, and because there are actually use cases for AFRP
11:04:11 <kakashiAL> what is the difference between foo = True and let foo = True ?
11:04:55 <monochrom> They are used in different contexts.
11:05:16 <ertes> sqooq: i'm not really familiar with grapefruit
11:06:13 <ertes> the API is kinda odd, and i'm not sure what to think of it
11:07:13 <sqooq> ok
11:07:19 <sqooq> i'm checking out reflex in detail rn
11:08:35 <kakashiAL> monochrom: could you give me more context?:)
11:14:22 <ski> `foo = True' is a definition. `let foo = True' could be a `do'-command, or a list comprehension item, or an interactor command (which one can think of as being a case of the first)
11:14:31 <ski> kakashiAL ^
11:15:50 <kakashiAL> ski: hmm... so what does let mean? I know let as from other languages but in haskell its something totaly different
11:16:33 <glguy_> ski: when you mix ` and ' like that, dumb clients like irccloud mangle your message (just FYI)
11:18:09 <ski> there are `let'-`in'-expressions, and there are `let'-commands in `do'-expressions, and there are `let' items in list comprehensions
11:18:13 <monochrom> "let" means it prefixes a bunch of definitions.
11:18:27 <ski> the common part is that you can make some local definitions
11:18:43 <ski> > let x = 1; f y = 3*y in f (f x)
11:18:46 <lambdabot>  9
11:19:05 <ski> in the expression after `in', the locally defined `x' and `f' are in scope
11:19:15 <monochrom> It is also always part of something bigger, it cannot stand alone, except when on the ghci prompt.
11:20:07 <ski> in a `do'-expression, which consists of a sequence of commands, followed by a final expression, a command `let ...' will make the bindings defined by the definitions `...' available to the remaining commands (and the final expression)
11:21:17 <ski> > do x <- [0 .. 3]; let {y = 3 - x}; z <- [0 .. y]; return (x,y,z)
11:21:19 <lambdabot>  [(0,3,0),(0,3,1),(0,3,2),(0,3,3),(1,2,0),(1,2,1),(1,2,2),(2,1,0),(2,1,1),(3,...
11:22:20 <ski> in a list comprehension, the bindings made by `let ...' are likewise available for use in the remaining items (all to the right of `|'), and also in the expression to the left of `|'
11:22:44 <ski> > [(x,y,z) | x <- [0 .. 3],let y = 3 - x,z <- [0 .. y]]
11:22:46 <lambdabot>  [(0,3,0),(0,3,1),(0,3,2),(0,3,3),(1,2,0),(1,2,1),(1,2,2),(2,1,0),(2,1,1),(3,...
11:23:25 <ski> in the interactor, the bindings made by the definitions after a `let' (without any corresponding `in') are made available for the remaining interactor commands
11:23:40 <ski> kakashiAL : does that help ?
11:24:15 <ski> in lambdabot, we can get the same effect by using `@let'
11:24:24 <kakashiAL> ski: too abstract, I will google more and come back later but thanks so far :)
11:24:28 <ski> @let smallPrimes = [2,3,5,7]
11:24:29 <lambdabot>  Defined.
11:27:39 <ski> > [(2^p - 1) * 2^(p - 1) | p <- smallPrimes]
11:27:41 <lambdabot>  [6,28,496,8128]
11:32:38 <Psybur> > "% putStrLn \"> \":D\"\""
11:32:40 <lambdabot>  "% putStrLn \"> \":D\"\""
11:33:14 <nullie> > putStrLn "% putStrLn \"> \":D\"\""
11:33:16 <lambdabot>  <IO ()>
11:33:50 <Psybur> % "> putStrLn \":D\""
11:33:51 <yahb> Psybur: "> putStrLn \":D\""
11:33:55 <Psybur> Blah
11:33:56 <Psybur> :D
11:34:06 <ski> > putStrLn "> ":D""
11:34:08 <lambdabot>  error:
11:34:08 <lambdabot>      Data constructor not in scope: D :: [Char] -> [IO ()]
11:34:13 <yoho> yeah I was going to try yahb before realising it always responds to you
11:34:19 <Psybur> % "\n> putStrLn \":D\""
11:34:19 <yahb> Psybur: "\n> putStrLn \":D\""
11:35:24 <ski> > sam "> putStrLn \":D\""
11:35:27 <lambdabot>  > putStrLn ":D"
11:35:39 <Psybur> That space is killin it!
11:35:54 <Psybur> @source sam
11:35:54 <lambdabot> Unknown command, try @list
11:36:00 <Psybur> @src sam
11:36:00 <lambdabot> Source not found. You speak an infinite deal of nothing.
11:36:16 <yoho> :t sam
11:36:17 <lambdabot> error:
11:36:17 <lambdabot>     • Variable not in scope: sam
11:36:17 <lambdabot>     • Perhaps you meant ‘sum’ (imported from Data.Foldable)
11:36:30 <yoho> ski: ?
11:37:47 <Psybur> > sam ":D"
11:37:49 <lambdabot>  error:
11:37:49 <lambdabot>      • Variable not in scope: sam :: [Char] -> t
11:37:49 <lambdabot>      • Perhaps you meant ‘sum’ (imported from Data.Foldable)
11:37:52 <int-e> > ap(++)show"ap(++)show"
11:37:54 <lambdabot>  "ap(++)show\"ap(++)show\""
11:38:06 <int-e> > text$ap(++)show"text$ap(++)show"
11:38:07 <lambdabot>  text$ap(++)show"text$ap(++)show"
11:48:02 <inkbottle> Not in scope, line 41 (and otherwise ambiguous type): http://lpaste.net/8600494718284988416
11:49:08 <glguy> pure is just pure, there's no module L
11:49:38 <glguy> When you want to specify a type you can annotate it like you did here: (id :: Int -> Int)
11:49:47 <mniip> lambdabot only reacts to @, doesn't it
11:49:51 <inkbottle> glguy: Sure, I try that
11:49:53 <glguy> ?bot
11:49:53 <lambdabot> :)
11:49:57 <mniip> nothing like 'lambdabot: command' like in supybot?
11:50:10 <int-e> lambdabot: @bot
11:50:10 <lambdabot> :)
11:50:22 <mniip> but that doesn't work in PM?
11:50:42 <int-e> I don't know
11:50:59 <mniip> doesn't seem to
11:51:25 <Welkin> supybot?
11:51:30 <ski> lambdabot: @type ()
11:51:31 <lambdabot> ()
11:52:11 <mniip> supybot is one of the most common bases for irc bot
11:52:23 <mniip> not sure if it ranks #1 or #2 against eggdrop
11:52:31 <Welkin> oh god, eggdrop
11:52:34 <Welkin> I had one of those
11:53:09 <Welkin> it talked, too
11:55:11 <int-e> I think reacting to the nick on channels is a concession to the fact that command prefixes clash. (for example, when two instances of lambdabot end up in the same channel)... it doesn't seem useful in private messages.
11:56:33 <mniip> % x = "++++++++++[>++++>+++>+++++++++++>++++++++++++>++++++++>++++++>++++++++++<<<<<<<-]>---.>++.>++.>---.-.>+++.<.<++.>>-------.<<----.<.<+++.>++.>>>>++++.>--.++++.<<<<<.--.<+++..>.>>++++.<<<--."
11:56:34 <yahb> mniip:
11:56:40 <mniip> @bf ++++++++++[>++++>+++>+++++++++++>++++++++++++>++++++++>++++++>++++++++++<<<<<<<-]>---.>++.>++.>---.-.>+++.<.<++.>>-------.<<----.<.<+++.>++.>>>>++++.>--.++++.<<<<<.--.<+++..>.>>++++.<<<--.
11:56:40 <lambdabot>   % putStrLn ("@bf" ++ x)
11:56:44 <mniip> dammit
11:57:12 <hydraz> haha
11:57:15 <mniip> oh!
11:57:21 <mniip> I might know just the thing
11:57:27 <hydraz> you're missing a space, too
11:57:35 <hydraz> ("@bf " ++ x)
11:59:54 <mniip> ah right
11:59:58 <mniip> int-e patched that
12:02:00 <mniip> @elite % z
12:02:00 <lambdabot> % Z
12:02:01 <yahb> lambdabot: ; <interactive>:2:1: error: Data constructor not in scope: Z
12:02:25 <yoho> @list
12:02:25 <lambdabot> What module?  Try @listmodules for some ideas.
12:02:35 <glguy> If the bots would respond via NOTICE like they were supposed to this wouldn't be so complicated
12:02:35 <mniip> @elite % z
12:02:35 <lambdabot> % Z
12:02:35 <yahb> lambdabot: @elite % z
12:02:36 <lambdabot> % s
12:02:36 <yahb> lambdabot: ; <interactive>:6:1: error: Variable not in scope: s
12:02:59 <mniip> I need to look up elite's exact lookup table...
12:03:10 <glguy> mniip: Just have yahb ignore messages from lambdabot altogether
12:03:22 <mniip> where's the fun in that
12:03:42 <glguy> You can make the test for lambdabot's nickname really complicated
12:03:50 <hydraz> haha
12:04:11 <yoho> if you try hard enough you can really spam the shit out of this channel
12:04:19 <mniip> daily reminder that the irc part of yahb is a lua script
12:04:48 <yoho> % Z
12:04:48 <yahb> yoho: @elite % z
12:05:14 <jle`> bot wars can be fun
12:06:54 <mniip> oh look
12:06:55 <mniip> there's no d
12:07:13 <yoho> % Z
12:07:14 <yahb> yoho: ; <interactive>:2:1: error: Data constructor not in scope: Z
12:07:27 <yoho> oh, is that scoped to users?
12:07:28 <mniip> @elite % d
12:07:28 <lambdabot> % D
12:07:28 <yahb> lambdabot: @elite % d
12:07:34 <mniip> :<
12:07:51 <yoho> huh?
12:08:09 <yoho> % :i D
12:08:10 <yahb> yoho: data D = D -- Defined at <interactive>:1:1; instance [safe] Show D -- Defined at <interactive>:3:10
12:08:21 <yoho> yeah, that's what I did too :D
12:09:23 <pavonia> What kind of bot is yahb?
12:09:23 <int-e> mniip: bot loops aren't fun, especially on big channels.
12:09:52 <mniip> bot loops are always fun
12:10:28 <hydraz> tired: checking for lambdabot and ignorning its messages / wired: checking for lambdabot and dropping the username prefix
12:10:52 <mniip> pavonia, yahb is a GHCI session
12:11:23 <hydraz> % :quit
12:11:24 <yahb> hydraz:
12:11:52 * hackage lambdabot-haskell-plugins 5.1.0.2 - Lambdabot Haskell plugins  https://hackage.haskell.org/package/lambdabot-haskell-plugins-5.1.0.2 (BertramFelgenhauer)
12:15:57 <mizu_no_oto> 'yet another haskell bot', I assume?
12:17:03 <mniip> yes
12:17:14 <Psybur> youre a hamster, barry!
12:22:00 <crooshfy> 'when =<< (return True :: IO Bool)' gives the type error "Couldn't match type ‘f0 () -> f0 ()’ with ‘IO b0’". Why does 'when =<< (return True)' not do the same?
12:23:12 <Psybur> :t when =<< (return True :: IO Bool)
12:23:13 <lambdabot> error:
12:23:13 <lambdabot>     • Couldn't match type ‘f0 () -> f0 ()’ with ‘IO b’
12:23:13 <lambdabot>       Expected type: Bool -> IO b
12:23:35 <Psybur> :t when =<< (return True)
12:23:37 <lambdabot> Applicative f => f () -> f ()
12:24:12 <glguy> In: (when =<< _) (print "hi"), the type of the _ is (IO () -> Bool)
12:24:36 <glguy> so the type of (return True) is also (IO () -> Bool), and is equivalent to (\_ -> True)
12:24:51 <glguy> Your code is using instance Monad ((->) r) -- Defined in ‘GHC.Base’
12:24:53 <hydraz> `Applicative ((->) r)' strikes again?
12:25:01 <monochrom> I think you completely misread how "when =<< foo" is parsed.
12:26:17 <jle`> crooshfy: you might be forgetting that 'when' takes two arguments
12:26:33 <crooshfy> jle`: no, didn't forget that
12:26:49 <jle`> ah, so the type error is expected by you
12:26:55 <jle`> but the fact that the second doesn't have a type error is not expected?
12:26:58 <geekosaur> or just having the usual confusion over the function arrow being an actual type just like any other instead of being a special form like pretty much every other language
12:27:08 <crooshfy> jle`: right
12:27:44 <glguy> :t return True :: a -> Bool
12:27:44 <jle`> crooshfy: ah yeah. in that case then, try matching up the types in (>>=) to get a sense of what's going on
12:27:45 <lambdabot> a -> Bool
12:27:47 <jle`> :t (>>=)
12:27:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:27:55 <monochrom> OK so "when =<< (return True)" is "do { x <- return True; when x }"
12:28:11 <jle`> 'return True' needs to match with 'm a', so a is Bool
12:28:26 <jle`> (>>=) :: Monad m => m Bool -> (Bool -> m b) -> m b
12:28:28 <jle`> so what is 'm' ?
12:28:37 <monochrom> Actually the do version is misleading too.
12:28:38 <jle`> we can look at the type of 'when'
12:28:41 <jle`> :t when
12:28:42 <lambdabot> Applicative f => Bool -> f () -> f ()
12:28:58 <jle`> when :: Bool -> f () -> f (), and we need to match *that* what (Bool -> m b)
12:29:17 <monochrom> I now go with glguy's analysis.
12:29:23 <jle`> we can do some re-prefixing to get when in the form of when :: Bool -> ((->) f ()) (f ())
12:29:52 <jle`> so if we want to match 'when' with (Bool -> m b), m has to be ((->) f ()), and b has to be f ()
12:30:12 <ski>   when :: Bool -> ((->) (f ())) (f ())
12:30:40 <jle`> so in the end we get the type of (>>=) specialized to ((->) f ()) Bool -> (Bool -> ((->) (f ())) (f ())) -> ((->) (f ())) (f ())
12:31:06 <jle`> (yeah, look at ski's correction of my typo)
12:31:15 <jle`> um that ugly type can be re-infix'd
12:31:32 <jle`> to be (>>=) :: (f () -> Bool) -> (Bool -> f () -> f ()) -> f () -> f ()
12:32:33 <jle`> so the first thing we see is `return True :: f () -> Bool`
12:32:42 <jle`> which is probably not the 'return Bool' that you expected
12:33:43 <jle`> but that (f () ->) is required by the type of 'when' when given one Bool argument
12:35:24 <jle`> crooshfy: oh yeah you should also know that 'return' is polymorphic in `m`, it is not always just return :: a -> IO a
12:43:32 <mekeor> why does `stack init` stop with error `AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""` for me?
12:44:15 <inkbottle> [u is not a function, I don't know how to finish that line]: appInterchange (Fun _ u ???) y = ((u :: [Int -> Int]) <*> pure (y :: Int)) == (pure ($ y) <*> u) \\ quickCheck appInterchange
12:44:42 <mekeor> mekeor: https://github.com/fpco/stackage/issues/2759
12:44:58 <glguy> mekeor: If you aren't using stack 1.6 , upgrade and try again
12:46:50 <ski> inkbottle> :t Fun
12:47:13 <dexterfoo> how do i remove the last character from a ByteString?
12:47:23 <mniip> :t BS.init
12:47:25 <lambdabot> BSC.ByteString -> BSC.ByteString
12:47:29 <glguy> Note that ByteStrings don't old characters
12:47:30 <glguy> hold*
12:47:43 <mniip> :t BS.unsnoc
12:47:44 <lambdabot> BSC.ByteString -> Maybe (BSC.ByteString, Word8)
12:48:03 <mniip> glguy's comment applies
12:48:34 <yoho> that's some BS man
12:49:32 <inkbottle> ski: Fun :: (a :-> b, b, Bool) -> (a -> b) -> Fun a b \\ It seems impossible to put sth like "[Int -> Int]" in that
12:49:39 <inkbottle> I should need sth else
12:50:37 <ski> inkbottle : perhaps define `getFun (Fun _ u) = u' and then use `map getFun u :: [Int -> Int]' ?
12:51:58 <inkbottle> ski: whaou, that seems interesting... (and pretty hard): I'll look into it
12:52:36 <ski> you could also just write `[f :: Int -> Int | Fun _ f <- u]'
12:53:15 * ski idly wonders what `Fun' is good for
12:53:22 <nyberg> was wondering where arrows would be better outside parsing and yampa style frp
12:54:58 <dexterfoo> nyberg: arrows are used in opaleye library
12:55:33 <monochrom> Arrow has fewer good applications than initially thought. Even parsing is better served by Applicative.
12:56:10 <monochrom> Modeling circuits is a good application, but it looks like that's equivalently to Yampa-style FRP.
12:56:38 <monochrom> It's a pity because I really like Arrow.
12:56:58 <monochrom> But perhaps that's just because I like cartesian-closed categories.
12:57:41 <monochrom> Perhaps that's exactly what we need to replace Arrow.
12:58:53 * hackage th-expand-syns 0.4.4.0 - Expands type synonyms in Template Haskell ASTs  https://hackage.haskell.org/package/th-expand-syns-0.4.4.0 (DanielSchuessler)
12:59:01 <mniip> :t lens
12:59:03 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
12:59:06 <mniip> cool and good
12:59:39 <monochrom> Oh it converts getter-setter pair to lens.
13:00:22 <mniip> monochrom, no like there was a bug
13:00:25 <mniip> % :t lens
13:00:27 <yahb> mniip: lens :: Functor f => (s1 -> a1) -> (s1 -> b1 -> t1) -> (a2 -> f b2) -> s2 -> f t2
13:00:33 <mniip> % :t \x -> lens x
13:00:34 <yahb> mniip: \x -> lens x :: Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
13:00:49 <mniip> a bug in GHC 8.1-8.5
13:00:59 <Gurkenglas> Ooh, can you make yahb uninline type aliases where applicable?
13:01:14 <mniip> % :i lens
13:01:14 <yahb> mniip: lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b -- Defined in `Control.Lens.Lens'
13:01:19 <mniip> type as it appears in the source
13:11:46 * hackage pandoc-emphasize-code 0.2.1 - A Pandoc filter for emphasizing code in fenced blocks  https://hackage.haskell.org/package/pandoc-emphasize-code-0.2.1 (owickstrom)
13:16:38 <hexagoxel> there are too many packages defining their own ad-hoc HList.
13:16:57 <hexagoxel> but the HList package still was not updated to work with ghc-8.*
13:18:00 <hexagoxel> and it is too big and too much typelevel magic for me to update it :/
13:21:05 <jle`> i've been using type-combinators as my 'standard' for a while
13:28:51 <jchia_1> With "data Foo f1 f2 f3 = Foo { x :: f1 Int, y :: f2 Char, z :: f3 Bool } deriving Generic", How can I derive a FromJSON instance where for each field if its type is (), parseJSON doesn't read it and just uses () for the value? E.g. parseJSON for "Foo Identity [] (Const ())" should read 'x' and 'y' from the JSON, but not z.
13:31:11 <jchia_1> If I can't derive a FromJSON instance like this, I would like a way to define it.
13:34:20 <hexagoxel> jle`: interesting. Only had to look into 10 modules to find the `Prod` type :D
13:48:10 <huss`> Hey everyone, the difference between a bifunctor/profunctor is only the contravariance part ?
13:50:06 <glguy> Yes, that's the difference
13:51:22 <huss`> In this case, contravariant function are often producers ?
13:51:59 * hackage units-parser 0.1.1.1 - A parser for units of measure  https://hackage.haskell.org/package/units-parser-0.1.1.1 (RichardEisenberg)
13:52:00 <glguy> I'm not sure what your question means exactly
13:53:10 <huss`> In lenses, the covariant part is the getter and the contra is setter ?
13:54:41 <glguy> I don't think so, but I'm still having trouble making sense of the question
13:55:27 <huss`> I'm bad at asking then ^^
13:55:47 <huss`> Maybe I want a sens for the contravariant part
13:56:45 <glguy> covariant functor has :: (a -> b) -> f a -> f b
13:56:55 <glguy> contravariant functor has :: (a -> b) -> f b -> f a
13:57:38 <glguy> In bifunctor both of the arguments use the covariant order: (a -> b) -> (c -> d) -> f a c -> f b d
13:58:01 <glguy> In profunctor the first type argument uses the contravariant order: (a -> b) -> (c -> d) -> f b c -> f a d
14:02:22 <huss`> Using the covariant functor, I can say that given a tool that transform a to b and a box that store b, i can create a new box that store a ?
14:03:01 <huss`> contravariant functor*
14:03:34 <glguy> The "box that store" part isn't such a good description, but yes other than that
14:04:05 <glguy> A value of a type 'f a' isn't necessarily a "box" nor does it necessarily store any "a"
14:04:50 <huss`> How would you rephrase that ?
14:06:31 <glguy> We could rewrite it to: given a function that produces a value of type (b) from an a value of type (a), we can compute a function that produces a value with type (f a) from a value with type (f b)
14:08:32 <huss`> Thanks :)
14:08:54 <glguy> under the additional constraints that if we start with the value (id) that we get something that behaves like (id) back
14:09:23 <glguy> and that if we were going to use that tool twice in a row that we'd get the same behavior composing the two functions together first and using the tool on that
14:20:41 <dmwit> If you like the "box that stores" analogy for covariant functors, then perhaps I can interest you in my "box that consumes" analogy for contravariant functors.
14:21:22 <inkbottle> is it possible to have "stack build" print the ghc command it did use to do the job?
14:21:36 <Tuplanolla> Did you try the verbose flag, inkbottle?
14:23:10 <ph88> hey guys, i build ghc from source now i have a bunch of binaries like ghc-stage1 and ghc-stage2 what am i suppose to do with those? i don't see just "ghc"
14:23:39 <inkbottle> Tuplanolla: OK, I'm reading the output...
14:24:09 <huss`> dmwit: tha's what i meant by storing :P but tell me me :)
14:30:46 <dmwit> There is not much more to tell. For covariant functors, you can think of boxes that are willing to divulge values of the appropriate type, while contravariant functors are boxes that are willing to receive values of the appropriate type.
14:31:12 <dmwit> This "consume"/"produce" difference explains the functorial mapping property.
14:31:28 <dmwit> If your box is willing to produce `a`s, and you give it an `a -> b`, now it is willing to produce `b`s.
14:31:58 <dmwit> If your box is willing to consume `a`s, and you give it an `a -> b`, it can't do anything with it. But if it's willing to consume `a`s and you give it a `b -> a`, now it is willing to consume `b`s.
14:33:46 <dmwit> A profunctor `f a b` is like a box that's willing to consume `a`s and produce `b`s.
14:35:27 <inkbottle> Tuplanolla: Yes, it's what I was looking for; Even though it doesn't provide me with a simple ghc command line as I expected
14:38:38 <inkbottle> ski: finally I used that: iiLToFL :: [(Int, Int)] -> [Int -> Int] (http://lpaste.net/1786022739421691904, QuickCheck all 4 applicative laws)
14:39:07 <inkbottle> seems OK, but not sure of course
14:42:08 <hexagoxel> inkbottle: you need to go deeper than just "stack build -v" :D
14:42:54 <inkbottle> hexagoxel: yes; where should I look?
14:43:09 <hexagoxel> one of the steps of the "stack build -v" output is the "build" invocation. you can copy that line and run it manually
14:43:17 <hexagoxel> and at another -v at the end
14:43:30 <hexagoxel> then you get the actual ghc invocation.
14:44:37 <hexagoxel> inkbottle: the relevant command is (of course) the last one before you can see the modules going through in the stack -v output.
14:45:05 <huss`> dmwit: very clear like that
14:45:29 <inkbottle> hexagoxel: OK, I try that
14:48:20 <ski> inkbottle : `iiLToFL' is a `map'
14:49:21 <ski> inkbottle : the `case' in it probably doesn't do what you think
14:49:49 <ski> > let x = 0 in case 1 of x -> "zero"; _ -> "nonzero"
14:49:51 <lambdabot>  "zero"
14:50:19 <inkbottle> ski: [map] like with key, values?
14:51:54 <ski> > foldr (\x ys -> (f :: Expr -> Expr) x : ys) [] [a,b,c]
14:51:56 <lambdabot>  [f a,f b,f c]
14:51:57 <ski> > map (f :: Expr -> Expr) [a,b,c]
14:51:59 <lambdabot>  [f a,f b,f c]
14:52:12 <ski> no, like that `map'
14:52:20 <inkbottle> ski: OK
14:52:53 <inkbottle> yes, yes, lists have same sizes...
14:53:32 <ski> not only that, each output element depends only on the corresponding input element
14:53:42 <ski> what is `iiLToFL' meant to do ?
14:53:57 <inkbottle> ski: I use the case to have a pattern matching failure for the unaccounted cases
14:54:21 <inkbottle> ski: to generate a function (partial)
14:54:26 <ski>   case x' of x -> y  -- this will never have a pattern matching failure
14:54:37 <inkbottle> from [(Int,Int)]
14:54:38 <ski> (see my "zero" example above)
14:55:11 <ski> the `x' in `x -> y' is a new variable, shadowing the outer `x'
14:55:14 <inkbottle> ski: yes, of course
14:55:28 <inkbottle> I correct that
14:55:36 <inkbottle> back in a minute
14:55:59 <ski>   case x' == x of True -> y  -- could be used, if you want pattern-match failure if they don't match
14:57:06 <ski>   case x' of ((x ==) -> True) -> y  -- another way to spell it
15:02:02 <ski> inkbottle : looks like, instead of matching on `Fun _ u', you can use the function `apply'
15:10:34 <inkbottle> ski: I did the modification 'map' and 'if then else error' (http://lpaste.net/7995250491028144128) with output showing there is room for improvement (http://lpaste.net/3091759597032046592)
15:12:20 <ph88> what's a hsc file ?
15:15:19 <ClaudiusMaximus> input for hsc2hs, which helps writing Storable instances and other FFI needs
15:15:23 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/utils.html#input-syntax
15:16:44 <inkbottle> ski: [a lot of room for improvement] What do you mean 'apply'?
15:16:47 <ski> inkbottle : looks like it's hitting that `error'
15:17:26 <ski> @type Test.QuickCheck.Function.apply
15:17:27 <lambdabot> Fun a b -> a -> b
15:17:38 <inkbottle> ski: it doesn't have to; the [(,)] idea was very bad
15:17:48 <inkbottle> ski: OK
15:18:32 <inkbottle> ski: what I ultimately need is that: [Int -> Int]
15:31:37 <ph88> how can i speed up compilation of ghc itself ?
15:36:06 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Newcomers#Fastrebuilding
15:39:05 <ph88> <3 geekosaur
15:45:22 <fendor> can someone help me out with stack projects on nix? dont wanna switch the entire build process to nix, but stack --nix build fails because of missing zlib library
15:45:22 <Costar> Hi all
15:46:21 <Rembane> fendor: Put this in your stack.yaml:
15:46:22 <Rembane> fendor: nix:
15:46:22 <Rembane>     enable: true
15:46:22 <Rembane>     packages: [zlib, gmp]
15:46:39 <fendor> Rembane, global project as well i suspect?
15:47:13 <Rembane> fendor: Global project? What does that mean?
15:47:39 <fendor> well, when you execute stack ghci without any prject, then you have the interpreter
15:48:00 <Rembane> Ah.
15:48:06 <Rembane> I always run local projects.
15:48:22 <fendor> well i am using haskell as my personal calculator
15:48:37 <fendor> dont want to create a project for simple arithemitc
15:49:10 <mud> The global project stuff is in ~/.stack/global-project/ , by the way. It mostly works like you just have a stack.yaml following you around when no other one is relevant.
15:49:44 <fendor> mud, yeah, does it make sense to add the mentioned changes to stack.yaml?
15:50:12 <monochrom> Personal calculator is best done by running ghci directly and quitting stack.
15:50:13 <mud> I think so? I honestly know almost nothing about the nix integration in stack :-/
15:50:33 <mud> monochrom: What's wrong with 'stack ghci' ?
15:51:12 <monochrom> The same wrongness as wearing a diving suit to a spa?
15:51:26 <monochrom> And all of the above?
15:51:34 <dxtr> Well I sure as hell won't go naked
15:51:48 <dxtr> :D
15:52:50 <fendor> monochrom, well isnt it rather going to a spa in a suit or something like that? still fitting but overkill?
15:53:11 <mud> monochrom: Pretty lame answer. I don't even know what that metaphor is supposed to mean.
15:53:31 <monochrom> It means a protective layer that defeats the point.
15:53:36 <Rembane> Going to spa in tails!
15:53:48 <monochrom> Next time I'll use astronaut suit, OK?
15:54:04 <mud> Is stack ghci a protective layer? It's more just an easy way to run ghci to me, which has more bells and whistles if I actually need them.
15:54:10 <geekosaur> and eating a burrito? :p
15:54:38 <mud> I should install ghci manually instead ... what benefit do I get? It doesn't run faster or do more, right?
15:54:40 <geekosaur> mud: not so much intended as protective, so much as wrapping it in your project
15:54:50 <geekosaur> which means you don't get much if you don't *have* a project
15:55:29 <monochrom> SImpler and zero management of stack settings.
15:55:39 <mud> You don't get much then, no. But I don't see then how it's any *worse*. At worst it's ... pretty much the same thing as running ghci itself, right?
15:57:13 <monochrom> No, at worst it chooses a GHC version you don't want.
15:57:30 <monochrom> And it downloads it behind your back.
15:57:30 <geekosaur> slower startup as stack is still computing everything
15:58:06 <monochrom> And you happen to be tethering your laptop to your cell phone so you lose 130MB from your data plan this month.
15:58:08 <geekosaur> uh, flip side of this is that if all your libraries were installed with stack, the only way to get access to them is stack ghci *and* a local stack project declaring your interest in them via cabal file
15:59:19 <mud> geekosaur: stack ghci --package something  works without a .cabal file. Also, if you do 'stack install whatever' in global context, 'stack ghci' happens to just let you access them anyway.
15:59:30 <monochrom> But you're on 4G LTE so it's superfast so you don't even notice until you see your phone bill.
15:59:53 <monochrom> I know because I once inadventedly downloaded a 30MB pdf (a restaurant menu) on my phone.
16:00:14 <monochrom> (And I'm cheap and I only bought 100MB per month)
16:00:19 <mud> monochrom: Those are indeed possibilities, though they seem remote. I'll certainly take changing a value in ~/.stack/global-project/stack.yaml if I have it set for the "wrong" GHC, over installing it myself.
16:00:24 <monochrom> (But oh boy was it sweetly fast.)
16:01:21 <glguy_> I was on the airplane, tried to build something with stack and it got stuck failing to do something with my non existent network connection; back to not stack
16:02:05 <Rembane> Are you using new-build or nix or sandboxes?
16:03:33 <glguy_> New-build and build
16:04:27 <fendor> i like that you can have a bang line with stack, that your file is executed on the fly without a project
16:04:56 <jetien> Hi! Could somebody please take a look at my code and tell my why it overflows the stack? I'm learning haskell by doing the AoC challenges, but I'm stuck here. The code is at https://github.com/smatting/advent2017/blob/master/src/Day25.hs .
16:05:28 <mud> fendor: Yeah, I quite enjoy that.
16:06:04 <geekosaur> #!/usr/bin/env runhaskell
16:06:31 <geekosaur> (or runghc in place of runhaskell)
16:06:38 <fendor> geekosaur, i suppose this can also install packages on the fly?
16:06:51 <mud> geekosaur: stack script can optimize, which is important for a lot of stuff I use it for, and it can use packages easily.
16:07:01 <geekosaur> if I need a quick script to install packages on the fly, I have done something wrong
16:07:31 <fendor> geekosaur, well, using turtle for example
16:07:40 <benzrf> jetien: does it overflow at parse or at run?
16:07:43 <mud> Really, never needed to be able to do aeson or use a parser or use turtle or lens in any quick script?
16:07:56 <monochrom> mud, I think you're a very valuable asset in that you know the ropes of stack.yaml and you can help people set the right settings when they have stack problems. In the same way on Apple product forums there are knowledgeable volunteers to help other users with little-known tricks.
16:08:17 <jetien> benzrf: it overflows on the run. parsing works fine
16:08:18 <monochrom> I for one never bothered to learn stack.yaml.
16:09:32 <benzrf> jetien: are you sure? how did you test that? (if you're a newb it might be possible that it didn't actually parse b/c of laziness, depending on how you tested)
16:09:49 <glguy_> jetien: the problem is iterN
16:09:54 <monochrom> geekosaur: And the point of #!/usr/bin/env stack is that the next thing the file does is to specify a resolver you have never used so now another download-another-GHC-behind-your-back begins but oh boy is it so reproducible-build.
16:09:58 * benzrf backs off
16:10:14 <fendor> ok, when i enable nix in stack.yaml, how can someone build the project without having nix installed?
16:10:18 <benzrf> aha, oh of course
16:10:26 <benzrf> i assumed it was library function or something, haha
16:10:30 <glguy_> jetien: you had the right idea when you used seq, but applied seq to the wrong argument
16:10:31 <benzrf> jetien: try being strict in n
16:10:41 <Rembane> fendor: It will just build.
16:10:49 <Rembane> fendor: nix is only used if it exists.
16:10:52 <fendor> Rembane, nope, dies
16:11:11 <glguy_> jetien: GHC doesn't typically do CSE. You need to name (f x)
16:11:13 <Rembane> fendor: Bah, then I've remembered some Github comments completely wrong, sorry.
16:11:28 <fendor> maybe i fucked up some settings
16:11:43 <inkbottle> ski: Do you believe that?: quickCheck (\fs y -> let u = fmap apply (fs :: [Fun Int Int]) in (u <*> (pure y :: [Int])) == (pure ($ y) <*> u)) ==>> +++ OK, passed 100 tests.
16:11:53 <inkbottle> seems too easy
16:12:03 <glguy_> That might accidentally work partially due to other dependencies, but that part of it is wrong
16:12:21 <mzabani> hi everyone! Has anyone ever set up ADTs (non-record) with Opaleye? I have a few sum types that I'd really enjoy having mapped!
16:12:26 <glguy_> Might be more, looking from phone :)
16:12:28 <ggVGc> does anyone have a vim errorformat for HUnit?
16:15:01 <glguy_> jetien: next; seq on TMstate as produced by your step function forces basically nothing
16:15:05 <ski> inkbottle : looks ok, i think
16:15:46 <fendor> Rembane, omitting enable: true does the trick, then you have to build it with stack --nix build on nixos but can execute stack build on any other system
16:15:53 <glguy_> The step function can produce the outer most constructor without evaluating any of that let bound stuff internally
16:16:10 <Rembane> fendor: Sounds like a really nice solution.
16:16:51 <fendor> Rembane, yeah, think so too
16:17:49 <jetien> glguy_: okay. i'm trying to understand what you said. btw i've updated my code (feel free to refresh). this version also overflows
16:18:40 <mud> monochrom: It requires no intricasies of stack.yaml to just get 'stack ghci' running. Even if you care what GHC it's using, it's not "little-known tricks". It's pretty clear you don't like stack, which sure that's fine. But I don't find telling people not to use it very helpful, unless they're asking for advice like that. Would you appreciate everyone else interjecting their personal tool choices on everyone who asks any question about any tool?
16:19:18 <hololeap> i'm trying to understand the yoneda embedding in terms of haskell. the 4 possible functions of type (Bool -> Bool) would be: b1 = id; b2 = not; b3 = const True; b4 = const False. according to the rules of the yoneda embedding, there should be 4 distinct ways of doing ((Bool -> a) -> (Bool -> a)), but i can't figure out how those would be implemented
16:19:52 <ezyang> Bool -> a is iso to (a, a)
16:19:52 <orzo> I'm writing something that mainly generates haskell code.  I intend to use a pretty-printer on a generated syntax tree. I'm not sure which syntax tree package is the best to use for this.
16:19:53 <jetien> benzrf: seq n' also overflows unfortunately
16:20:01 <ezyang> how many ways can you write (a, a) -> (a, a)
16:20:08 <glguy_> The next in iterN isn't a problem
16:20:15 <glguy_> The n*
16:20:55 <jetien> gleber_: could be caused by using Data.Sequence with a couple of million updates?
16:21:09 <glguy_> jetien: update you step function to seq the updated tape before returning the new machine stare
16:21:43 <jetien> glguy_: ok, ill try
16:22:09 <benzrf> oh bluh
16:22:12 <benzrf> >.<
16:22:30 <benzrf> shouldve like. actually tried it out before offering advice
16:23:46 <quchen> hololeap: \f -> f . {id, not, const True, const False}?
16:23:50 <glguy_> benzrf: I'm shooting from the hip,too
16:24:04 <benzrf> hehe
16:24:08 <glguy_> If someone has some advice based on running this code, do jump in
16:24:42 <jetien> glguy_: that worked! :) I think i understand what was happening. seq cannot evaluate all the way down, right? for that i need deepseq
16:24:51 <jetien> glguy_: thanks!
16:25:28 <benzrf> no, that's not the issue at all :o
16:25:43 <benzrf> seq vs deepseq is "all the way down" for the /value/
16:26:09 <hololeap> ezyang, quchen: ok, that makes sense. thanks
16:26:26 <benzrf> so for example, if i used seq on "repeat 1", it could legally result after forcing it to "1:repeat 1"
16:26:29 <benzrf> but deepseq would look
16:26:41 <benzrf> *loop
16:27:03 <quchen> seq: is one of the arguments bottom?
16:27:10 <benzrf> yup
16:27:18 <quchen> deepseq: are any of the arguments bottom, including all of their contents?
16:27:19 <glguy_> If iterN had used deepseq it would have gone slower, and also not had a stack overflow
16:27:55 <benzrf> the issue is accumulated thunks, and seq suffices to clear a layer of thunk at each step
16:28:02 <glguy_> Deepseq on an infinite list is a problem because the deepseq implementation can't observe the sharing
16:35:03 <glguy> jetien: Are you on the #haskell AoC leaderboard?
16:35:27 <glguy> Nice to see how far along the Haskellers are
16:35:37 <glguy> and nice if they link through to their github profiles with solutions :)
16:37:52 <monochrom> mud: You are right. But the part about "interjecting their personal tool choices on everyone who asks any question about any tool" has long been a trend. By stack users. Every time a cabal question appears, some stack user has to chime in with "have you tried stack?", 90% of the time without even understanding the cabal question.
16:37:55 <inkbottle> ski: The file with the corrections (http://lpaste.net/9052265929966092288); execution take more than 20s, most of it for the "composition" test
16:38:12 <mud> monochrom: So you found it annoying, so you decided to copy it?
16:38:18 <jetien> glguy: No, how do I do that? I really like this AoC - i learned so much haskell in the last days
16:38:36 <monochrom> Yes and no. I tried. But couldn't keep up with it consistently.
16:38:55 <monochrom> I guess it is just not in my blood to be an evangelist.
16:39:06 <glguy> jetien: Goto http://adventofcode.com/2017/leaderboard/private and enter 43100-84040706
16:39:12 <mud> monochrom: Wouldn't it make a lot more sense to politely ask people not to do that, instead of copying the behavior you found annoying?
16:39:53 <monochrom> In the specific case today, I was just thinking the task description "want to use ghci as a calculator" should worth considering using ghci directly.
16:40:50 <jetien> glguy_: joined :)
16:40:58 <monochrom> And then you asked "what's wrong with stack" so I answered.
16:41:06 <monochrom> If you didn't ask, I wouldn't even bother.
16:43:40 <inkbottle> nyberg, glguy, ski: Thanks a lot for all your help
16:47:01 <hololeap> how would one construct a value of the type (Fix Identity)
16:47:22 <ezyang> i,i undefined
16:47:51 <monochrom> I don't think it has any interesting/useful value other than x = Fix (Identity x)
16:48:12 <hololeap> monochrom: cool, that works
16:48:13 <MarcelineVQ> conal: Watching your denotational design talks and I noticed that there's confusion quite quickly between what's haskell code and math notation, you've mentioned using colors to differentiate but I'd like to suggest something easier, use : instead of ::
16:48:14 <glguy> fix (Fix . Identity) :: Fix Identity
16:48:18 <monochrom> You need to replace Identity by something richer for a more meaningful experience.
16:48:23 <inkbottle> hexagoxel, Tuplanolla: Thanks for the stack -v things, which I'll continue some other times
16:49:04 <glguy> hololeap: I have a couple of AoC solutions that made use of Fix if you want to see something
16:49:22 <hololeap> glguy: sure, but i don't know what AoC is :)
16:49:29 <MarcelineVQ> monochrom: for a quality experience the girls have to be real? :>
16:50:27 <hololeap> oh, adventofcode
16:50:55 <monochrom> Age of Conquerors i.e. Age of Empires 2 with expansion
16:51:13 <glguy> https://github.com/glguy/advent2017/blob/master/execs/Day07.hs https://github.com/glguy/advent2017/blob/master/execs/Day25.hs
16:51:17 <MarcelineVQ> Ark Of the Covenant
16:51:19 <hololeap> i was going to say, Age of Concurrency :)
16:51:39 <geekosaur> axiom of choice >.>
16:51:52 <hololeap> ew set theory
16:51:56 <hololeap> gross
16:52:33 <bhiliyam> kek
16:54:52 <ertes> promoting stack is not a case of "interjecting their personal tool choices on everyone who asks any question about any tool", because stack is not a tool, but a religion
16:55:32 <monochrom> :S
16:55:36 <MarcelineVQ> ertes: it's too early in the week for that convo
16:55:37 <erisco> hololeap, almost everything is a set and you know it
16:55:57 <ertes> MarcelineVQ: sorry, i couldn't resist =)
16:56:02 <monochrom> Even I only dare to say "I'm half-joking when I say 'stack is like God'"
16:56:11 <erisco> monochrom, and who's your favourite? MBL?
16:56:32 <monochrom> Err what's MBL?
16:56:42 <erisco> monochrom, pro aoe2 player
16:56:57 <monochrom> Oh, I don't know any of them.
16:57:10 <erisco> feels daut man
16:57:28 <monochrom> I only play against the computer, and once in a blue moon watch a recorded online game on youtube.
16:57:53 <erisco> happy holidays btw
16:58:08 <monochrom> happy holidays
16:58:21 <hololeap> people still play aoe2, competitively?
16:59:02 <monochrom> No I think as-pastime-and-against-humans rather than competitively
16:59:06 <ertes> people still play go competitively, and that game is thousands of years old =)
16:59:06 <MarcelineVQ> hololeap: I'll admit it's not as fun as Star Wars: Galactic Battlegrounds but it's a fine game
16:59:25 <jchia> I need trivial Binary instances "instance Binary a => Binary (Identity a)" and "instance Binary a => Binary (Const a) b". The binary package doesn't provide it. If I define them myself in my own module, I'll get orphaned instances. What should I do?
16:59:34 <hololeap> yeah, but go is timeless
16:59:34 <monochrom> But yeah apparently AoE2 still shadows AoE3
16:59:57 <erisco> hololeap, yup there are still tournaments
17:00:03 <hololeap> i used to play it back when a bush was still president
17:00:11 <erisco> AoE3 was a dud afaik
17:00:44 <hololeap> gwb, prez 2020
17:00:47 <monochrom> I like AoE3 more.
17:01:14 <erisco> back when our imports came from overseas?
17:02:08 <erisco> I am just judging based on how well it retained a base of players over the years
17:02:16 <monochrom> It may be just because I like guns and cannons, and the ability to breed more sheeps and cows.
17:02:32 <robwebbjr_> Hello. I am new to programming (having worked through a portion of the Haskellbook -- up to monads) and I am now working through the book Verified Functional Programming in Agda. I have a very simple newbie question regarding how to get agda to recognize an absurdity in the midst of a with construct. I have posted the details here: http://lpaste.net/360556  Would you please help me? Thank you.
17:02:35 <hololeap> and wololo
17:02:41 <MarcelineVQ> monochrom: consider stronghold, while we're off-topic
17:02:51 <hololeap> quite
17:02:51 <erisco> + crusader
17:02:52 <monochrom> Ah I'm going to continue in #haskell-offtopic. Please join me.
17:03:15 <glguy> robwebbjr_: There's a channel for #agda
17:03:16 <ertes> robwebbjr_: you should ask that in #agda
17:03:25 <robwebbjr_> P.S. I am assuming there are some agda users here...
17:03:44 <glguy> There might be, but the topic of this channel (contrary to the previous discussion) is Haskell
17:03:49 <robwebbjr_> hi. yes i am wating a response on #agda
17:04:01 <monochrom> The author name "Stump" is a bit unfortunate... :)
17:04:08 <ertes> robwebbjr_: this channel is rather noisy, so your question is more likely to be lost in the depths of the backlog before any agda user can see it =)
17:04:11 <robwebbjr_> yes.... lol!
17:04:50 <robwebbjr_> Ok, thanks all. you have helped me so much with haskellbook, I figured i would try...
17:04:54 <MarcelineVQ> jchia: orphans are only an issue if they're in a library you're planning to release for other people to have to deal with  https://wiki.haskell.org/Orphan_instance  if that's the case you might have to be using newtypes, perhaps someone else can comment
17:06:21 <jchia> MarcelineVQ: Not a public library, but the warnings are distracting. data PointF f1 f2 f3 ... = PointF { x :: f1 Text, y :: f2 Int, z :: f3 Bool, ...}. This is how I end up needing Identity: PointF Identity Identity Identity.
17:10:47 <monochrom> Yeah if your orphaned instances are confined to your one single exe it's fine.
17:10:57 <MarcelineVQ> jchia: If you'r enot sharing it you might just want to just turn of the warning
17:11:35 <monochrom> But these are famous last words. We know from history how often "one-shot will-throw-away code" becomes widespread world-wide infrastructure libraries.
17:11:51 <jchia> MarcelineVQ: OK, I'll try turning off that warning using {-# OPTIONS_GHC #-}
17:13:05 <MarcelineVQ> I think it's -Wno-orphans in this case
17:13:20 <MarcelineVQ> monochrom: :X
17:23:41 <jchia> Can StandaloneDeriving be used together with DerivingStrategies? This line doesn't parse: "deriving newtype instance Binary a => Binary (Identity a)". What's wrong?
17:25:45 <glguy> cccccchkfulvkvjdkkeriifrnuetedlbkviietduffrc
17:26:03 <jle`> jchia: orphna instances make sense in applications, if that's what you are doing
17:26:28 <jchia> jle`: Yeah, I'm trying that but having problems with StandaloneDeriving+DerivingStrategies
17:26:36 <jle`> oh sorry, was replying to a previous thing
17:27:03 <jchia> I decided to make an orphaned Binary instance for Identity.
17:28:16 <jle`> Identity doesn't already have one? :o
17:28:39 <jchia> jle`: No, unfortunately not. I need Binary instances for Identity and Const a
17:34:01 <jchia> Well, never mind my last question. For the first time, my IDE reported a parse error that didn't show up when I actually tried to build.
18:12:37 <conal> MarcelineVQ: Thanks for the comment. Do you have examples of where you'd suggest using ":" in place of "::"?
18:23:01 <ph88> how can i see what ghc has inlined ?
18:31:09 <sqooq> conal: are you conal as in frp conal
18:31:19 <conal> sqooq: yes.
18:31:41 <sqooq> conal: I'm trying to write/use an frp library for audio synthesis work
18:32:08 <sqooq> but I also just don't know enough. I just finished reading your push-pull paper
18:32:18 <sqooq> but I got lost at some point
18:32:54 <sqooq> Idk, I figured I had a question, but I guess I don't
18:32:57 <sqooq> lol
18:33:24 <conal> sqooq: okay. if you come up with one, i'm often on irc. and good luck!
18:33:33 <sqooq> ok thanks
18:34:15 <sqooq> Really all my issues stems from a onePole filter implementation
18:34:47 <sqooq> it's `y(n)=b*x(n)-a*x(n-1)`
18:35:01 <sqooq> so it relies on the previously calculated value, frp apparently is supposd to help with things like this
18:35:06 <sqooq> but idk how
18:36:37 <conal> sqooq: FRP is about continuous time
18:36:56 <conal> sqooq: so maybe it's not what you're looking for.
18:37:12 <conal> sqooq: do you mean n to increase with time?
18:37:59 <sqooq> yes
18:38:07 <sqooq> n increases with time
18:38:14 <sqooq> and both are technically continuous functions
18:38:28 <sqooq> I guess, but this is the discretized version
18:38:35 <sqooq> so maybe I'm just thinking about it wrong
18:38:38 <conal> sqooq: or it might be natural to use events here, in which case you can use an event accumulation operator, such as accumE.
18:39:41 <conal> sqooq: i don't know about one pole filters. are they integrals?
18:39:48 <sqooq> no
18:39:56 <sqooq> they're literally ``y(n)=b*x(n)-a*x(n-1)``
18:40:04 <sqooq> where x(n) is an audio signal
18:40:05 <conal> so there's no continuous version?
18:40:11 <sqooq> hmm
18:41:20 <conal> i ask because programmers often go right for discrete approximations of continuous ideals, losing simplicity and precision/correctness.
18:41:25 <sqooq> haha this is pretty funny. Since I want to implement dsp, which is "digital", everything is in digital form
18:41:40 <sqooq> I mean real onePole filters are done with analog synths
18:41:47 <sqooq> so there must be some sort of continuous understanding
18:41:51 <sqooq> I just don't know what it is
18:43:15 <conal> sqooq: perhaps your implementation mechanism is interfering with your formulation. i try never to let that happen, since approximation doesn't compose.
18:43:37 <sqooq> you're right
18:44:02 <sqooq> Will this actually work though? If I model continuous audio signals, and then discretize at the last step, will it actually play out correctly?
18:44:35 <conal> i.e., combining enough almost-corrects and you get a not-nearly-correct. so i advocate composing exact descriptions and approximating only at the end.
18:44:58 <conal> we do the same for infinite data structures, only approximating them to finite subsets/samplings after composition.
18:45:14 <sqooq> damn, this might be pretty unique in the online world then
18:45:18 <sqooq> If it works correctly
18:45:29 <sqooq> Audio is almost always done with digital in mind, and a specific sample rate
18:45:40 <sqooq> but if you save the sampling to be last
18:46:05 <sqooq> then you can combine the raw continuous signals from anywhere together, and sample them finally
18:46:25 <sqooq> whereas now, if one thing is sampled at a rate of 44100 and another at 48000, you either have to downsmaple one, or upsample the other
18:46:53 <sqooq> I just wonder if filters and the like can actually be implemented continuously
18:47:22 <sqooq> so I'll do some research
18:47:28 <sqooq> I might have to learn circuitry
18:47:32 <conal> sqooq: probably yes ("will this actually work"). you'll have to do some thinking, but you'll have an precise specification as a basis for that thinking. FRP and Pan (http://conal.net/Pan) are examples of this principle, which I also discuss explicitly in some talks: https://github.com/conal/talk-2015-essence-and-origins-of-frp and the links there.
18:48:22 <sqooq> Ok thanks
18:48:36 <conal> sqooq: exactly. continuous time eliminates the issue of rate mismatch. same with continuous space.
18:48:51 <sqooq> I'll start learning about continuous-time signal processing then, see how it goes, whether I can implement
18:48:57 <sqooq> I'll check out your links
18:49:21 <conal> "infinite resolution" and "resolution independent" are other names some people relate to more easily.
18:49:37 <conal> but i think you got the point right away!
19:18:07 <MarcelineVQ> conal: Pretty much any time you mention mu it's, as I understand, not haskell code but really about establishing the relationships between things. So something like  μ :: Region -> (Loc -> Bool)  may be more obviously not haskell as  μ : Region -> (Loc -> Bool)    Even before mu, one of the first things you get into is establishing an interface: over, transform, crop, monochrome. Which have signatures like  over :: Image -> Imag
19:18:07 <MarcelineVQ> e -> Image  Using : instead of :: when speaking to a haskell crowd would invite questions, and create an oppertunity to establish we're not thinking about code yet.
19:20:27 <conal> MarcelineVQ: Thanks! I like that the change is so lightweight. A just-noticeable notational clue.
19:20:46 <MarcelineVQ> Basically anything not intended to be checked by ghc should probably be using : is my idea for the subject
19:22:02 <conal> Funny. I'd *like* to get automatic type-checking. It's not important that the mu definitions be computable, though.
19:22:08 <MarcelineVQ> This won't help anymore if you decide to move onto Idris some day, but you may also be able to prove your laws using the compiler there :> Can't say for sure since I'm new to that
19:25:42 <ph88> is there any way i can use $ together with operators that are usually infix ?
19:26:00 <MarcelineVQ> ph88: parenthesis are never out of style
19:26:03 <sqooq> ph88: if I understand what you mean
19:26:11 <sqooq> you can put the infix operator in parenthesis
19:26:22 <sqooq> so that it acts like a normal function
19:26:32 <sqooq> `(+) 1 2 = 3`
19:26:52 <sqooq> so then `(+) 1 $ (2+3) = 6`
19:27:18 <sqooq> or wait
19:27:36 <sqooq> I should have done `(+) 1 $ 2+3 = 6`
19:27:38 <sqooq> to prove the point
19:28:15 <sqooq> or better yet `(*) 2 $ 2 + 3 = 10`
19:29:08 <ph88> ah ok that's nice
19:32:06 <MarcelineVQ> ph88: but why prefer $ there over 2 * (2 + 3)
19:32:19 <MarcelineVQ> what are you actually writing :>
19:33:04 <ph88> just playing around with code a bit
19:33:11 <ph88> not amounting to much atm ^^
19:33:24 * hackage units-parser 0.1.1.2 - A parser for units of measure  https://hackage.haskell.org/package/units-parser-0.1.1.2 (RichardEisenberg)
19:39:24 * hackage savage 1.0.3 - re-export of the random generators from Hedgehog  https://hackage.haskell.org/package/savage-1.0.3 (chessai)
19:56:33 * hackage units 2.4.1 - A domain-specific type system for dimensional analysis  https://hackage.haskell.org/package/units-2.4.1 (RichardEisenberg)
20:44:53 * hackage forest-fire 0.3 - Recursively delete CloudFormation stacks and their dependants  https://hackage.haskell.org/package/forest-fire-0.3 (toothbrush)
20:53:25 <pikajude> okay, huh
20:53:35 <pikajude> there's nothing in haddock-library's package.conf.d directory when built with ghc 8.2 using nix
20:53:42 <pikajude> which is causing a build failure elsewhere
20:53:52 <pikajude> what determines if package.conf.d is empty?
21:28:03 * hackage bizzlelude 1.0.4 - A lousy Prelude replacement by a lousy dude  https://hackage.haskell.org/package/bizzlelude-1.0.4 (TheBizzle)
21:54:49 * hackage bittrex 0.4.0.0 - API bindings to bittrex.com  https://hackage.haskell.org/package/bittrex-0.4.0.0 (DavidJohnson)
21:56:58 <jle`> what's the way people normally seperate sections in haskell source code
21:57:15 <jle`> -- * Some Section doesn't really have the visual weight i'm going for
21:57:50 <Average-user> hi guys
21:58:20 <Average-user> is there someone who did AoC to talk with?
21:58:50 <dmj`> jle` and glguy did
21:58:51 <MarcelineVQ> jle`: let the comments do the heavy lifting for you  https://github.com/ghc/ghc/blob/master/compiler/coreSyn/CoreSyn.hs  and use extra *** when they don't!
21:59:14 <jle`> Average-user: if you have a question/topic, just ask it :)  also there is #haskell-spoilers which became the sort of de facto haskell aoc channel
21:59:41 <jle`> MarcelineVQ: neat, thanks for teh reference :)
22:00:59 <Average-user> its a quite simple question really: what was your favorite puzzle of AoC? and why?
22:01:17 <jle`> i liked 16 and 23!
22:01:28 <jle`> questions where you couldn't just directly implement the step-by-step algorithm
22:01:33 <jle`> and had to think around the box
22:02:01 <jle`> i also like how they weren't as inaccessible (even on their hardest days) as even intermediate project euler question
22:02:10 <jle`> didn't require you to be good at math, just ask for some creative thinking
22:02:43 <jle`> most of the other ones could probably be solved by brute force, but in those cases it was still fun finding creative ways to brute force i suppose
22:03:33 <Average-user> jle`: in day 16, even knowing that permutations of 16 are more than 1 billion, It was kind of obvious that there had to be cycle, but was fun
22:03:52 <jle`> it's only 'obvious' on hindsight :o
22:04:22 * hackage numhask 0.1.4.0 - A numeric prelude  https://hackage.haskell.org/package/numhask-0.1.4.0 (tonyday567)
22:05:10 <Average-user> well, it would be hard to make a set of rules that construct permutations without being obvious, thats what I meant
22:08:35 <Average-user> jle`: id you find day 25 a little bit disappointing?
22:08:39 <Average-user> did*
22:09:12 <jle`> it's a little simple, but not a bad way to wrap everything up :)
22:09:23 <jle`> kind of like a send-off
22:10:12 * hackage silvi 0.0.4 - A generator for different kinds of logs.  https://hackage.haskell.org/package/silvi-0.0.4 (chessai)
22:10:32 <jle`> it would have been nice if the problems ramped up in difficulty though
22:11:24 <jle`> in a sense they did
22:11:25 <jle`> https://i.redd.it/zqbtsv9x70601.png
22:11:47 <jle`> looking back on it now actually it's kind of cool that they seemed to alternate
22:15:30 <mud> Especially if you liked the ones that required a bit of thinking and not just directly implementing what it tells you, you might have fun with some "competitive programming" problems here and there.
22:16:19 <jle`> i've dabbed in come competitive programming, but i my favorite part of AoC was really more of the communal/everyone doing the same thing at the same time kind of atmosphere of it
22:17:04 <jle`> or is that what you mean
22:17:14 <mud> You can get that as well if you make friends that also do competitive programming, either in competitions or just practice :)
22:17:25 <jle`> thanks for the tip :)
22:18:04 <mud> But yeah, lots of people seem to just like it once a year apparently. AoC seems to have a certain draw that other types of competitive programming don't.
22:18:06 <Redrield> Is it possible to find the usages of a function with intero + spacemacs?
22:36:53 <Redrield> Hello?
22:37:04 <Average-user> I use prelude emacs
22:37:09 <Average-user> not space emacs
22:37:48 <Redrield> Spacemacs is really just emacs but less lisp hackery
22:37:56 <Redrield> So if you have a way to do it it might work
22:41:40 <dmj`> M-x ag
22:41:58 <dmj`> Redrield: all uses of a function in your project?
22:42:07 <Redrield> Yeah
22:42:11 <Redrield> I'm hacking on aura
22:42:18 <Redrield> And I want to find all usages of the function hotEdit
22:42:25 <Redrield> I've found a workaround, but it's pretty hacky
22:42:48 <Redrield> I've been jumping between files for quite a while now looking for usages so that I could fix it up
22:43:20 <mud> Redrield: use grep? :)
22:43:29 <dmj`> ^
22:43:40 <dmj`> ag is a little faster
22:44:29 <mud> If your identifiers are anything near sane, that should really work well. I don't know 'ag', but it certainly sounds right ... and cool, will have to look at that.
22:46:56 <dmj`> the silver searcher
22:46:57 <dmj`> https://github.com/ggreer/the_silver_searcher
22:47:54 <mud> Thanks, ya
22:53:06 <sqooq> if I have several functions in a list
22:53:19 <sqooq> and they're all gonna take one argument
22:53:22 <sqooq> that I want to map
22:53:26 <sqooq> this is like a reverse map
22:53:27 <johnw> map ($ x) xs
22:53:28 <sqooq> how do I do this
22:53:36 <sqooq> ah thanks
22:57:53 <POGtastic> > map ($ 4) [(+1), (*2)]
22:57:55 <lambdabot>  [5,8]
22:58:01 <POGtastic> nifty
22:59:42 <JazzyEagle> POGtastic: I'm kind of curious what you would use that for...
23:00:27 <JazzyEagle> Effectively mapping a value over a list of functions...
23:00:45 <sqooq> I mean I just used it
23:00:48 <JazzyEagle> I guess I could see some value in that, now that I think about it.
23:01:01 <sqooq> I had a function that took an argument
23:01:02 <JazzyEagle> lol  I didn't read far up enough.
23:01:12 <sqooq> but I wanted to basically replicate that function many times
23:01:14 <JazzyEagle> Sorry, sqooq.  I'm blaming it on the time here (1am)
23:01:18 <sqooq> and then apply the same argument to all
23:01:37 <sqooq> and then actuall zipWith a kind of + operator
23:01:51 <sqooq> a multiply actually
23:02:04 <sqooq> and then foldr (a kind of +)
23:02:49 <mud> One use-case I can imagine would be like if you have several ways to calculate a certain thing from a starting value, maybe with different tradeoffs (maybe like efficiency/reliability tradeoffs), that could work.
23:06:02 <JazzyEagle> I could potentially see value in it from an analytical standpoint, e.g. a list of values, and you want to find the min, the max, the average, the mean, etc. from the same list.  You can do it all in one shot that way.
23:06:30 <JazzyEagle> I'd say without the use of a monad, but lists *are* monads.  Not sure which way would be quicker (monadic notation vs. map)
23:07:10 <JazzyEagle> Too tired to try and figure that out, though.
23:10:46 <johnw> JazzyEagle: that's a problem that "beautiful folds" solves nicely
23:11:10 <johnw> makes the idea of producing a value from a list more compositional
23:12:14 <MarcelineVQ> johnw: are you referring to the foldl package?
23:13:06 <johnw> that, or folds
23:20:11 <JazzyEagle> johnw: Would folds be any better than a map function in that case?  Either way, it'd be returning a list of results.  Not really adding anything together.
23:20:44 <johnw> how would you find the min of a list just by mapping a function?
23:21:02 <johnw> I'm not sure I understand what you mean yet
23:29:42 <JazzyEagle> johnw: map [5, 4, 10, 9, 7, 6, 3] [min, max, average, mean]  ..  min and max are part of Ord, average is in its own package, and mean is part of a statistical package.
23:30:16 <geekosaur> remember that map cannot see anything  but the current list item
23:30:35 <JazzyEagle> Actually, I think those would all have to be floats to work properly, but the point is that the end result would be a list of the returned values of each function, not one final value amongst all the functions.
23:30:54 <johnw> JazzyEagle: I'd recommend you try to code this idea :)
23:31:45 <JazzyEagle> Not tonight.  As evidenced by my poor logic and coding up to this point, my brain is mush.  It's 1:30am here, and I'm not articulating well.
23:32:22 <johnw> well, what you've described is not possible, but facing the impossibility in code will be much more informative than I could be here
23:33:03 <JazzyEagle> geekosaur: It should have been ($ [5, 4..])...  map would only be feeding the array into each function.
23:33:20 <POGtastic> ^
23:33:26 <geekosaur> now *that* makes a little more sense
23:33:38 <geekosaur> but was unclear from what you had been saying
23:33:40 <johnw> yes, but it will traverse the list N times, for the number of functions you have
23:33:40 <JazzyEagle> Like I said, my_brain <- mush
23:34:48 <JazzyEagle> johnw: Right.  Considering each function is looking for something different out of the array, wouldn't it have to traverse the list N times no matter which way you implement it?
23:34:59 <johnw> not with beautiful folds
23:35:24 <johnw> and sometimes, traversing a structure (other than lists) can be more expensive than performing the action of each function stepwise at every element
23:35:28 <POGtastic> > map ($ [5, 4, 10, 9, 7, 6, 3]) [foldl1 min, foldl1 max]
23:35:31 <lambdabot>  [3,10]
23:35:32 <JazzyEagle> You keep adding the word beautiful in there.  Is that a special type of fold I don't know about?
23:35:40 <johnw> it's a googling term
23:35:50 <johnw> it's folds-made-into-data-structures
23:35:56 <johnw> which are then applicatively composable
23:36:37 <JazzyEagle> I think I need to review this in the morning when my mind is fresh.  This isn't making much sense tonight.
23:37:12 <johnw> it lets you say something like: (,,) <$> min <*> max <*> avg $ xs
23:37:15 <geekosaur> "beautiful folds" with the quotes sounds like a paper title
23:37:22 <johnw> to produce a tuple of three folding results from a single traversa
23:38:01 <johnw> my syntax is wrong, but the paper clarifies
23:39:34 <JazzyEagle> I think I fouond the paper...  https://www.schoolofhaskell.com/user/edwardk/cellular-automata/part-2 ?
23:40:07 <johnw> https://hackage.haskell.org/package/foldl
23:40:14 <johnw> http://squing.blogspot.com/2008/11/beautiful-folding.html
23:40:23 <johnw> http://www.haskellforall.com/2013/08/composable-streaming-folds.html
23:40:25 <johnw> etc.
23:40:44 <johnw> i think you can find maybe 8 resources on it by now
23:41:01 <JazzyEagle> Ok.  I'll read those in the morning.
23:41:13 <JazzyEagle> For now, Im headin' into lurking status.  G'nite, everyone.
23:41:39 <johnw> good night!
23:43:45 <jchia> I'm trying to do binary search on a immutable Vector, but Data.Vector.Algorithms.Search.binarySearch et al take a mutable vector as input. What's the best way to do the binary search? Should I thaw the immutable vector to a mutable one? But won't that create a copy? unsafeThaw does not make a copy and the documentation says the immutable vector should not be used later but I don't want to damage it.
23:46:07 <lyxia> I would just use slice for immutable vectors
23:47:00 <jchia> lyxia: You mean using slice to implement my basic binary search algorithm?
23:56:40 <lyxia> yes
