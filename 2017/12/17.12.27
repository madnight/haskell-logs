00:01:25 <jchia> lyxia: If I'm looking for the index, not just the presence of the searched, how does slice make it easier than just maintaining left and right indexes on my own?
00:01:55 <jchia> It doesn't, does it?
00:04:04 <lyxia> right
00:04:23 <mud> jchia: Well, the recursive definition is pretty easy then, but then again so it the other, but you probably end up having to write an auxilury function.
00:09:01 <kyagrd> I recently tried to install IHaskell (jupyter plugin) again and installation went quite smooth just following. A while before (more than two years ago) it was a bit tricky to figure out the right dependency but this time the instructions on github page had all the scripts for those kind of things and once stack is properly installed things just works.
00:09:19 <jle`> kyagrd: nice :)
00:09:29 <kyagrd> Hope we can push it into official docker haskell image (maybe IHaskell developer is already trying that)
00:22:57 <raduom> Hi. Is there a good tutorial or track for understanding comonads and how / where to apply them?
01:33:24 <vaibhavsagar> kyagrd: no plans to make it 'official', but I'm curious how you think that would work
01:36:28 <kyagrd> vaibhavsagar: oh I just thought that it is such a nice environment not only for demo/documentation but also for people who want to try out Haskell (including some classroom setting) without going to command line, which can be made easily possible if there is a docker image including jupyter Haskell plugin.
01:37:37 <vaibhavsagar> haha I think so too!
01:37:39 <vaibhavsagar> we have https://github.com/gibiansky/IHaskell/blob/master/Dockerfile
01:38:02 <vaibhavsagar> but beyond that there are no plans to make it more official
01:38:17 <vaibhavsagar> (I'm not the original developer but I'm currently helping to maintain it)
01:48:41 <dredozubov> I have a closed type family with overlapping patterns in LHS in kind *. It fails to reduce during type checking. Any gotchas?
01:53:56 <dredozubov> it seems it's polykinded rather than in *
01:55:53 * hackage th-dict-discovery 0.1.0.0 - Automatically discover available dictionaries at compile time.  https://hackage.haskell.org/package/th-dict-discovery-0.1.0.0 (isovector)
01:57:35 <Wizek> hello
01:57:56 <Wizek> Anyone knows which pkg-config ghc+stack uses on macos?
02:00:50 <Wizek> I get `Missing dependency on a foreign library: * Missing C library: lmdb`, even though `pkg-config --modversion lmdb` returns without error
02:14:21 * hackage ecstasy 0.1.0.0 - A GHC.Generics based entity component system.  https://hackage.haskell.org/package/ecstasy-0.1.0.0 (isovector)
02:26:51 <geekosaur> Wizek, it will depend on where you installed ghc and possibly stack from
02:27:56 <geekosaur> when I had a Mac I kept the pkg-config from MacPorts early in $PATH and set $PKG_CONFIG_PATH explicitly in my environment (and including the XQuartz pkgconfig dirs since I installed that from xquartz.org)
02:28:43 <geekosaur> also some very old versions of mono (and some other packages) installed a pkg-config that came with their gtk2 frameworks that can't find anything useful by default
02:40:09 <kakashiAL> stupid question, but I know if/then/else, case/of, guards and partial functional definitions but what do they mean with "pattern matching" ?
02:41:43 <ski> @src foldr
02:41:43 <lambdabot> foldr f z []     = z
02:41:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:42:12 <ski> `foldr' is defined by pattern-matching on its third argument
02:43:18 <ski> (strictly speaking, it is also pattern-matching on the two other arguments, although the patterns there are very simple : only variable names `f' and `z', which match any and all arguments which can be passed in that position)
02:44:55 <kakashiAL> ski: so "pattern machting" means "define a function, with the same name, but with different argument types, and haskell will pick the right one depending how you use/what you pass the function", correct?
02:45:33 <ski> this (non-trivial) pattern-matching to the left of `=' in defining equations can be desugared into using `case' instead, which can be regarded as the primitive construction for pattern-matching
02:46:03 <[Leary]> A pattern is basically structure given to a value by the data constructors it's built out of. Pattern matching occurs when mapping from that value depends upon the structure.
02:46:11 <ski> well, if you make a definition
02:46:18 <kakashiAL> foo x = "foo"   foo [ ] = "bar"   <---pattern machting, because haskell with pick the function/pattern that matches with your use
02:46:25 <ski>   (front,back) = splitAt 3 "foobar"
02:46:51 <ski> then that is also pattern-matching, even though this isn't a function definition
02:46:55 <ski> kakashiAL ^
02:46:55 <kakashiAL> ski: right ?:)
02:47:35 <ski> also, i think you mean "different argument patterns", not "different argument types" ?
02:47:58 <trijim> What would be a good way to implement a transaction of IO actions with rollback? For example, a program needs to call 3 APIs (IO actions) in the background, in order, and if one fails it has to undo all previously done actions.
02:48:17 <kakashiAL> ski: both, but we couls also say "if the function is overloaded its patern matching"
02:48:54 <ski> in a function binding with multiple defining equations, Haskell will pick the first defining equation whose patterns match the actual arguments (and also whose guard is satisfied, if any)
02:49:20 <kakashiAL> ski: in that case its correct what I said :)
02:49:31 <kakashiAL> ski: unless you disagree
02:50:37 <ski> well, we don't say "overloaded" here
02:51:18 <ski> overloading is really resolution of an appropriate function to use, amongst several that is named the same
02:51:33 <ski> which isn't quite the same as what's happening here
02:53:24 <ski> overloading is usually construed as something which can happen at compile-time. and is disambiguated by the types (and number of) of arguments (and possibly results)
02:53:42 <ski> pattern-matching definitely happens at run-time
02:55:54 <ski> (but i can see why one would think of overloading .. note that in Haskell, we don't consider `[]' to be of a different type than `x:xs', but only having different "tags" (or data constructors). in a "dynamically typed" language, people aren't always making such a distinction)
02:56:23 <ski> btw, pattern-matching can be seen as somehow the reverse of evaluating an expression
02:57:43 <ski> to evaluate an expression like `min n (length xs)', you have to start with knowing which values the variables in the expression have been associated with (bound to), and evaluation of the expression will then end up with a resulting value
02:58:50 <ski> otoh, when you have a pattern like `(xs,y:ys)' you start with a value to match against this pattern, and you end up with values (bindings) for the variables in the pattern (unless there is a pattern mismatch, so that you end up with match failure instead)
03:01:45 <ski> however, matching a value to a pattern can't "do" as much computation as evaluating an expression. in an expression, you can call an arbitrary computable function (that you have defined), not just data constructors. but in a pattern, you can (basically) only match on data constructors, and use plain variables to "match everything"
03:01:55 <ski> you can't write e.g.
03:02:03 <ski>   square (sqrt x) = x
03:03:08 <ski> and expect `square 3.0' to evaluate by matching the value `3.0' with the (invalid) pattern `sqrt x' by somehow "calling `sqrt' in reverse", binding `x' to `9.0'
03:03:16 <ski> kakashiAL : making any sense ?
03:05:14 <ski> (actually, there's something called "view patterns" and "pattern synonyms", by which you actually can have a pattern expression less trivial computation. computation whose complexity isn't bounded by the syntactic complexity of the pattern)
03:06:30 <kakashiAL> ski: I try to understand and find why my explaination/description is bad and why it does not mean "pattern matching"
03:08:03 <ski> well, i think what you said was ok, except that i don't like the "with different argument types" and the "overloaded" bits
03:08:31 <ski> in the definition of `foldr' above, `[]' and `x:xs' has the same type, but are built using different data constructors
03:08:51 <ski> the type is "list of `a'" (written `[a]')
03:11:24 <ski> if you have a log file, where each line is either a warning, an error, or an information message, then you could make a message type, having these three different kinds of messages, modelled by three different data constructors
03:11:47 <ski> so, when you have parsed the file, you can get as result a list of messages
03:11:52 <kakashiAL> ski: okay, so the arguments (in pattern matching) have the same type for the input, but what you can do with "pattern matching" is to say "take a Num as an argument" but create many functions "patterns" where you specify the inputs, which means foo with int, foo with float and depending what you pass haskell weill pick the right one
03:11:59 <ski> remember that in a Haskell list, all elements have the same type
03:12:50 <ski> if you have any type of log file, and another type of message for such log file, then that's a different type
03:13:21 <ski> say `FooMessage' and `BarMessage' can be the two message types
03:13:35 <ski> you can't pass a `FooMessage', where a `BarMessage' is expected
03:14:11 <ski> but you can pass an informational `FooMessage', or an error one, or a warning one, to the same places, in most cases
03:15:25 <ski> what i'm attempting to get at here is the difference between *type* and "*kind*" (or variant/alternative) of value
03:16:13 <ski> kakashiAL : unfortunately no
03:16:16 <ski> you can't define
03:16:21 <ski>   foo (x :: Int) = ..x..
03:16:28 <ski>   foo (x :: Float) = ..x..
03:16:52 <ski> trying to do one thing if an `Int' is passed, and another thing if a `Float' is passed
03:17:36 <ski> you mentioned `Num', which is a type class. type classes is the sole way to achieve (actual) overloading, in Haskell
03:18:45 <ski> before i was talking about pattern-matching, which assumes *fixed* argument types, however the actual values (arguments) of those types can be of different "shapes", which is what the patterns distinguish
03:23:39 <ski> kakashiAL : have you seen `data' declarations yet ?
03:23:40 <kakashiAL> ski: just to keep the cognitive overload a bit lower, you agree that this is pattern matching, right:  foo 'a' = "AAA"   foo 'b' = "BBB" foo _ = "SOMETHING"
03:23:47 <ski> yes
03:24:01 <ski> the type of the argument is `Char'
03:24:34 <ski> the different patterns describe different "shapes" (not types) that a value of that type can take
03:24:48 <kakashiAL> ski: okay, this is good at the moment, I have to learn more about the haskell basics/fundamentals to digest and understand what you wrote, but I will :)
03:25:50 <ski> i do understand that it may not be that clear at the start to grasp the distinction between different types (of values), and different "shapes" of values
03:27:28 <ski> i *could* try to explain a bit more about how Haskell overloading (with type classes, like `Num') works .. but i think it's probably better if one has a basic familiarity with how to use pattern-matching first
03:28:08 <ski> (but if you want to, i could try)
03:32:16 <ski> very roughly, one could say that values that could sensibly be passed to the same place in the program, also have the same type
03:33:08 <ski> but there's some qualifications on this (partial operations, polymorphism), that makes this a little bit more subtle than it might appear to be
03:34:44 <ski> i can pass characters to your `foo' function above. i can't pass integers. characters belong to the type `Char'. integers belong to the type `Integer'
03:35:02 <ski> however, consider
03:35:06 <ski> @type intToDigit
03:35:08 <lambdabot> Int -> Char
03:35:12 <ski> > intToDigit 4
03:35:14 <lambdabot>  '4'
03:35:22 <ski> > intToDigit 23
03:35:25 <lambdabot>  *Exception: Char.intToDigit: not a digit 23
03:36:15 <ski> in this case, one might initially say that, since we can't sensibly pass `23' to `intToDigit', then it seems that `23' is of a different type than `4' ?
03:37:08 <ski> however, we can pass `23' to it. the failure here happens at run-time, not compile-time. it's just that `intToDigit' is a partial operation, it's not defined for all applicable inputs (iow inputs of the appropriate type, here `Int')
03:37:57 <ski> similarly, with division, we can pass any two numbers, except that if the denominator is zero, we'll get a division by zero error. partiality again
03:38:15 <ski> > 21 `div` 7
03:38:17 <lambdabot>  3
03:38:21 <ski> > 21 `div` 0
03:38:24 <lambdabot>  *Exception: divide by zero
03:38:28 <ski> > 24 `div` 7
03:38:30 <lambdabot>  3
03:38:47 <ski> (`div' is truncating, or integral, division)
03:39:23 <ski> kakashiAL : does this make sense ?
03:40:11 <int-e> . o O ( partially )
03:41:09 <kakashiAL> ski: yep, but I want to think about it more in depth, study it more, write some example and document it :)
03:41:42 <ski> ok. do you have any more questions at this point ?
03:44:09 <kakashiAL> ski: not now, but stay near :)
04:34:50 <totom> Does someone have a pdf of Introduction to functional programming using haskell Richard bird' book
04:36:02 <totom> It is not available in my country so i cannot buy it, and the available one is equal to 550USD in my currency which is costly as hell
04:37:23 <totom> if someone has or can arrange please ping me
04:50:19 <ph88> hey guys, my program spends most of it's time (42.8 %) in the lookup function on line 28 https://bpaste.net/show/1d971ff978ec is there any way i can make it faster ?
04:51:49 <ph88> how can i check if it's inlined or not ?
05:12:23 <osa1> ph88: add {-# INLINE lu #-} the next line and you'll know
05:14:13 <osa1> profiling with cost centers is tricky, cost centers can get in the way of some optimizations so you end up profiling a different program.
05:15:10 <jchia_1> Anyone familiar with generic-lens? I'm getting compiler errors that I can't explain and here's the test case: http://lpaste.net/361139
05:16:36 <ph88> with profiling on it takes 5 minutes, with profiling off it takes 8 seconds
05:18:14 <ph88> osa1, i still get the same speed when i add that inline pragma
05:18:25 <osa1> ph88: then it's probably already inlined
05:19:28 <ph88> well how can i know if adding inline or specialize is making sense without trial and error on every function ?
05:21:07 <osa1> I don't think you can without benchmarking and/or taking a peek at generated Core/STG/Cmm/x86 unless you have enough experience to just tell
05:31:53 <saurabhnanda> types like `data Foo = Bar | Baz | FooBar` are called sum types. However, `data Foo = Bar Int Int String` and `data Foo = {field1 :: Int, field2 :: Int}` are BOTH called product types. Is there a way to differentiate between the two product types? The second ones have another name -- records. Is there another name for the first one?
05:34:08 <osa1> ph88: two tips (1) try to move your definitions to top-level and see if that makes any difference (pass captured values as parameters etc.) (2) if you have intermediate Int, Float etc. values bound to names add a bang to those names (e.g. `!a = ...` instead of `a = ...`) and see if it makes any difference
05:41:24 * hackage cache 0.1.0.1 - An in-memory key/value store with expiration support  https://hackage.haskell.org/package/cache-0.1.0.1 (hverr)
05:52:19 * hackage hedgehog-gen-json 0.0.0 - JSON generators for Hedgehog  https://hackage.haskell.org/package/hedgehog-gen-json-0.0.0 (amrhassan)
06:00:58 * hackage opench-meteo 0.2.0.0 - A Haskell implementation of the Swiss Meteo Net data API  https://hackage.haskell.org/package/opench-meteo-0.2.0.0 (RolandSenn)
06:28:57 * hackage inline-java 0.7.2 - Java interop via inline Java code in Haskell modules.  https://hackage.haskell.org/package/inline-java-0.7.2 (FacundoDominguez)
06:29:54 <saurabhnanda> types like `data Foo = Bar | Baz | FooBar` are called sum types. However, `data Foo = Bar Int Int String` and `data Foo = {field1 :: Int, field2 :: Int}` are BOTH called product types. Is there a way to differentiate between the two product types? The second ones have another name -- records. Is there another name for the first one?
06:31:18 <mud> saurabhnanda: Not really. By the way they're obviously very related, the second one is kind of the same as the first except with same linguistic sugar, so I don't think they really get as much important naming about the difference.
06:31:41 <saurabhnanda> hmm... makes referring to them very hard.
06:31:46 <hyperisco> saurabhnanda, discriminated union, tagged union, and others
06:32:07 <saurabhnanda> which one is a discriminated union? which one is a tagged union?
06:32:09 <hyperisco> you do not typically have projectors on sum type fields, because such projectors would be partial
06:32:26 <hyperisco> you only gave one example of a sum type
06:41:09 <[Leary]> saurabhnanda——I would just refer to the product types as records and non-records.
06:42:07 <saurabhnanda> what's a good word to coin for non-records? Records and unnamed-products?
06:46:35 <[Leary]> 'Anonymous' sounds better than 'unnamed' if you want to go that route. Could also go with something like vanilla or plain products.
06:47:19 <[Leary]> I don't really see why there's a need to find a better name though, since the distinction should hardly need to be made—they're more or less the same thing.
06:47:29 * hackage crypto-enigma 0.0.2.10 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.2.10 (Orome)
06:53:12 <hyperisco> I just thought… it is interesting that we discriminate sums by tag but products by order
06:58:49 <ski> saurabhnanda : the proper term is "algebraic data type". this can be used to *encode* sum types and product types
06:59:45 <saurabhnanda> ski: ADT is not the problem. In a discussion, what names do you call the two product types?
07:00:15 <ski> i suppose i'd say product and record type
07:00:27 <saurabhnanda> for example if you are reviewing code and someone has used the anonymous pattern matching for a record, how do you write the following -- "for records prefer a record pattern match over ____"
07:00:28 <hyperisco> I haven't come across the need to distinguish those
07:00:35 <ski> (a record type is a product type where the components are referred to by name, rather than by position)
07:01:00 <saurabhnanda> so, positional product types and named/record product types?
07:01:01 <hyperisco> if I want to talk about projectors then I just talk about… projectors :)
07:01:13 <saurabhnanda> hyperisco: you mean field accessors?
07:01:25 <ski> "for records prefer a record pattern match over a plain/unadorned data constructor match" ?
07:01:34 <hyperisco> that is what a projector is, yes
07:02:19 <ski> projection, accessor, selector
07:03:56 <ski> if someone was talking about product types in Haskell, i'd first and foremost think of the tuple types, though. then in a more general sense the product types that can be encoded using ADTs
07:05:10 <ski> (anyway, "positional" and "named" are ok, i think)
07:05:39 <saurabhnanda> great.
07:05:42 * ski . o O ( positional sum types )
07:06:15 <hyperisco> it would be awkward for pattern matching I think, if you were trying to match more than one constructor
07:06:55 <ski> if there's more than one data constructor, then it's obviously not just an encoding of a product type
07:06:58 <hyperisco> well you wouldn't have constructors per se… not sure what the syntax would be then
07:08:10 <hyperisco> if it was positional, then an order for  Maybe (Maybe a)  might be  Nothing, Just Nothing, Just (Just x)  but I am saying it is more awkward
07:08:34 <hyperisco> and that isn't accounting for what the syntax would actually be, since there would be no constructor names
07:09:29 <ski> in SML one can define `fun distance {x = x0,y = y0} {x = x1,y = y1} = sqrt ((x0 - x1)**2 + (y0 - y1)**2)'. SML actually has record/product types, unlike Haskell
07:10:48 <ski> hyperisco : well, imagine if we had types like `( String | Int | IO () )'. and patterns like `( s | | )', `( | n | )', `( | | act )'
07:10:54 <ski> that would be positional, i'd say
07:11:22 <hyperisco> that is a good notation idea
07:12:01 <ski> (actually i'd prefer writing an overscore instead of just nothing, for the "non-present alternatives" .. but then it'd not be ascii)
07:12:33 <hyperisco> data Maybe a = () | a    case m of () | -> …; | x -> …
07:12:38 <hyperisco> would have to redo guard syntax
07:12:49 <ski> OCaml has lightweight, named, variant/sum types
07:14:00 <ski> the good thing about that is that if you want to make a function that can return one of two (or more) possible kinds of results, you don't have to bother giving the type a name, if you're not going to use it anywhere else
07:14:12 <hyperisco> not sure what happens with  data X a = Maybe a | Int  for example
07:14:38 <hyperisco> perhaps it uses parens?
07:15:09 <ski> the syntax i suggested would require wrapping brackets, just like for tuples, yes
07:15:35 <hyperisco> you might consider a type like that ad-hoc, and programming tends to appreciate ad-hoc things
07:15:39 <ski> if you're omitting the wrapping brackets, then yout `Maybe a | Int' would correspond to `Either (Maybe a) Int' in current Haskell
07:15:54 <ski> (and so that'd be a `type' synonym, not a new `data' type)
07:17:14 <ski> (in OCaml, tuples have no mandatory wrapping brackets)
07:18:17 <ski> (for a `data' declaration, you'd still have data constructors, even if light-weight variant types were added)
07:18:47 <ski> (and by "light-weight", i mean that you don't have to declare&name the type, to use it. just like tuple types are light-weight)
07:24:33 <royal_screwup21> I'm trying to run a my "yesno" function defined under a class like so: https://thepasteb.in/p/wjh0xr4zGgEtv Upon typing yesno 0, I get the following error: https://thepasteb.in/p/oYhlYW1L77KhZ how do I fix this?
07:25:04 <hyperisco> royal_screwup21, yesno (0 :: Int)
07:25:13 <hydraz> :t 0
07:25:14 <lambdabot> Num p => p
07:25:31 <royal_screwup21> does that...typecast O to an int?
07:25:36 <glguy_> No
07:25:38 <hyperisco> no, it says 0 is an Int
07:25:39 <hydraz> not a cast, a signature
07:25:40 <royal_screwup21> O*
07:25:40 <royal_screwup21> 0**
07:26:20 <mud> Num p => p   is strictly more polymorphic than Int, but includes Int. So you're allowed to say "actually ... it's just Int, screw the rest of the possibilities" essentially.
07:26:47 <ski> it's a type ascription, that says that the type of the expression `0' there is `Int'
07:27:06 <hydraz> i keep forgetting the word 'ascription' exists
07:27:14 <hyperisco> 0 can be any type, and yesno's argument can be any type, so GHC has no idea what type you actually want, and it matters for finding the correct instance of YesNo
07:27:20 <ski> it can't be used to change the type to something else. it can be used to pinpoint the type, avoiding ambiguity
07:27:38 <glguy_> The distinction is that this would not be accepted: (0:: Double)::Int
07:28:11 <royal_screwup21> I changed the instance to this but the comiler's throwing another error: https://thepasteb.in/p/AnhrOqP9OkoHv
07:28:25 <royal_screwup21> the new instance https://thepasteb.in/p/zmh8qVyR9nZTZ
07:28:32 <hydraz> you changed the instance, but you had to change the use site
07:29:01 <hydraz> royal_screwup21: the type of 0 in the pattern was already Int, since that's what you specified in the instance header
07:29:17 <royal_screwup21> oh okay
07:29:45 <hydraz> er, head. I think that's what it's called, at least.
07:29:52 <ski> you have to give it enough information, so that it can tell which instance it should use
07:29:57 <hyperisco> instances have nothing to do with determining the types of things
07:30:13 <hyperisco> first you figure out the type, then you figure out the instance
07:30:22 <royal_screwup21> yup thanks folks
07:30:26 * ski nods
07:31:16 <hydraz> instance heads have everything to do with figuring out types in the instance bodies
07:31:35 <hyperisco> yup
07:33:38 <royal_screwup21> now I'm trying to change type of the input to a string like so: https://thepasteb.in/p/r0hwZJz23L0IK The compiler throws this error: https://thepasteb.in/p/xGhmvNgxERXSM What am I doing wrong?
07:34:25 <hyperisco> royal_screwup21, did you read the error?
07:36:13 <royal_screwup21> hyperisco: I did but I'm not sure I understand any of it. Should I use FlexibleInstances as it suggests?
07:36:29 <hyperisco> probably worth trying
07:37:10 <royal_screwup21> I mean what is the error really saying?
07:38:07 <hyperisco> it is saying the Haskell Report is a silly thing and you should enable this extension to fix it
07:38:36 <royal_screwup21> "all instances must be of the type form (T a1 ... an) where a1 ... an are distinct type variables"
07:39:05 * hackage mulang 3.5.2 - An intermediate language designed to perform advanced code analysis  https://hackage.haskell.org/package/mulang-3.5.2 (flbulgarelli)
07:39:14 <royal_screwup21> hmm okay
07:39:14 <hyperisco> T is some type constructor, and then all arguments to this constructor must be variables
07:39:27 <hyperisco> you wrote  [Char]  which is  [] Char  which does not follow that pattern because Char is not a variable
07:41:58 <royal_screwup21> oh
07:43:35 <royal_screwup21> well if Char isn't a variable, then how is this working? https://thepasteb.in/p/Mjhx3mLGPnJhV
07:44:41 <hyperisco> because T is Char, so it follows the pattern
07:45:13 <royal_screwup21> oh  I get it now
07:46:32 <glguy> Char is a type constructor applied to 0 type variables
07:47:08 <glguy> It's generally a good idea to avoid turning on FlexibleInstances and to simply structure your program without them in simple cases like this
07:47:27 <fdnick> how can i apply a pure function to an IO(something)?
07:47:35 <hyperisco> try fmap
07:47:51 <Average-user> <$>
07:48:05 <hyperisco> liftA
07:48:11 <Average-user> :t (<$>)
07:48:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:48:23 <Average-user> :t liftA
07:48:24 <lambdabot> Applicative f => (a -> b) -> f a -> f b
07:48:31 <hyperisco> liftM
07:48:36 <Average-user> :t liftM
07:48:37 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
07:49:04 <hyperisco> fmapDefault
07:49:30 <Average-user> :t fmapDefault
07:49:31 <lambdabot> Traversable t => (a -> b) -> t a -> t b
07:49:41 <fdnick> thx a lot
07:50:21 <Average-user> but unless you have a reason to don't, you should use fmap or <$> I belive
07:52:41 <ggVGc> is there a better way to do this without Lens? https://gist.github.com/85a93b65e64eb28009efeeea43139df4
07:55:26 <hyperisco> ggVGc, probably by changing fillsForIDs… see the *By functions for reference
07:55:26 <royal_screwup21> can a class define multiple functions? like this: https://thepasteb.in/p/mwh1l479P2Yf5 ?
07:55:55 <hyperisco> royal_screwup21, yes
07:55:58 <ggVGc> hyperisco: which *By functiond?
07:56:00 <ggVGc> functions*
07:56:19 <hyperisco> like minimumBy, maximumBy, groupBy, and so on
07:56:35 <hyperisco> :t groupBy
07:56:36 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
07:56:38 <royal_screwup21> hyperisco: hmm okay. It's weird because "another_function" didn't get highlighted like yesno did when I defined it
07:56:43 <hyperisco> :t minimumBy
07:56:44 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
07:57:06 <Gurkenglas> ggVGc, with lens >:D : fillPairsForIDs = over template . fillsForIDs
07:57:24 <POGtastic> hi guys, got a quick silly question. i made a lex/parse/evaluator for boolean logic, and i'm wondering if there's a more elegant way to do `lexExpr`. lines 9-18 of the following: https://repl.it/@pogtastic/IdioticElectricLoggerheadturtle
07:57:59 <hyperisco> so instead of doing something with the values, it applies your map to the value first
07:58:26 <hyperisco> it is clumsy API design though
08:03:39 <hyperisco> do view patterns accept parameters? if so then you might use that so you can write something like  (prefix "True" -> xs)  or w/e
08:05:06 <hyperisco> as far as the explicit recursion goes… I don't think you can do much better
08:05:13 <JazzyEagle> I'm wondering if someone can help me understand Backpack a little more.  I
08:05:24 <ski> a view pattern can contain an arbitrary (function typed) expression
08:05:37 <JazzyEagle> 'm working on creating a little demo thing just to ensure I understand how to use it.  I pushed what I have so far to https://notabug.org/jazzyeagle/haskell-backpack-demo
08:05:38 <hyperisco> you could use a Mealy machine or something but that isn't making the syntax better
08:05:52 <JazzyEagle> But I'm getting an error... http://lpaste.net/983416784864411648
08:06:06 <JazzyEagle> It appears the necessary is building properly, but it's not able to link, and I'm not sure what I'm doing wrong.
08:06:14 <ski> > let f (stripPrefix "foo" -> Just s) = s; f _ = "" in f "foobar"
08:06:15 <lambdabot>  "bar"
08:06:28 <ski> @type stripPrefix
08:06:29 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
08:06:47 <hyperisco> TTrue <$> str "True" <|> TFalse <$> str "False" … with parser combinators
08:07:16 <ski> @type (<$)
08:07:17 <lambdabot> Functor f => a -> f b -> f a
08:07:27 <hyperisco> or yeah, that
08:08:12 <JazzyEagle> Knowing my luck, my issue may not have to do with Backpack; I may doing something wrong with the .cabal file and just not realizing it.
08:09:37 <POGtastic> some nutball on reddit was talking about parser combinators and implemented one in Javascript for a really easy problem. i didn't understand it very well
08:10:03 <POGtastic> it's probably easier to grasp in haskell
08:11:09 <mud> They're fairly badass in haskell
08:12:16 <shapr> yeah, true that
08:22:04 <ezyang> JazzyEagle: Stack doesn't support Backpack, so you're going to have to use cabal new-build
08:22:06 <tinytusk> Is there a function that directly converts from Int to Text without passing through String?
08:22:25 <tinytusk> A search on Stackage didn’t return any results.
08:22:37 <ezyang> (that's not entirely true; Stack can handle uses of Backpack when a public library is not indefinite, but I see you are using str-indef which doesn't uphold this)
08:27:15 <hyperisco> POGtastic, implementing parser combinators is essentially a hello world
08:27:56 <hyperisco> POGtastic, using them is more painful in languages which do not support custom or at least overridable infix operators
08:28:59 * hackage profiteur 0.4.4.0 - Treemap visualiser for GHC prof files  https://hackage.haskell.org/package/profiteur-0.4.4.0 (JasperVanDerJeugt)
08:38:24 <auto_complete_> :q
08:38:34 <POGtastic> i've done that a few times
08:39:33 <bartavelle> tinytusk: there should be builders if I am not mistaken
08:39:54 <bartavelle> hum it is all internal for some reason
08:40:43 <bartavelle> so there is this thing, but it is internal :/   http://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Lazy-Builder-Int.html
08:44:51 <hyperisco> try Data.Text.Lazy.Builder
08:45:12 <bartavelle> ah well, it is not internal after all :/
08:45:15 * bartavelle can't read
08:47:02 <nyberg> cabal seems to fail to build with nix, hm
08:53:55 <grandpascorpion> Hello, I had a question about Tuplet Sections and map.  Thanks for your help:  http://lpaste.net/5246433024580517888
08:54:42 <hydraz> :t zipWith
08:54:43 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
08:54:54 <hyperisco> grandpascorpion, what is the input and output you want?
08:54:58 <hydraz> :t zipWith3 -- etc, up to zipWith7
08:54:59 <lambdabot> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:55:05 <lyxia> > zipWith (13,,14,) [1,2] [3,4,5]
08:55:06 <lambdabot>  [(13,1,14,3),(13,2,14,4)]
08:55:21 <bartavelle> grandpascorpion: try uncurry?
08:55:36 <bartavelle> map (uncurry (1,,2,,3)) [(1,2),(4,5)]
08:55:37 <bartavelle> map (uncurry (1,,2,,3)) [(1,2),(4,5)]>
08:55:41 <bartavelle> > map (uncurry (1,,2,,3)) [(1,2),(4,5)]
08:55:43 <lambdabot>  [(1,1,2,2,3),(1,4,2,5,3)]
08:56:05 <bartavelle> (TIL you can have multi-holes tuple sections)
08:57:48 <nullie> > (1,,2) 3
08:57:49 <lambdabot>  (1,3,2)
08:58:37 <grandpascorpion> Thanks bartavelle and lambdadot
09:02:18 <hexagoxel> @botsnack
09:02:18 <lambdabot> :)
09:03:54 * yoho pats lambdabot on the head
09:03:57 <grandpascorpion> ... and lyxia
09:04:00 * hackage servant-github-webhook 0.3.2.1 - Servant combinators to facilitate writing GitHub webhooks.  https://hackage.haskell.org/package/servant-github-webhook-0.3.2.1 (tsani)
09:09:58 <ski> > case (# 0 ,, 2 #) 1 of (# _ , n , _ #) -> n
09:10:00 <lambdabot>  1
09:10:51 <mizu_no_oto> > (,,,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9] <*> ZipList [10, 11, 12] <*> ZipList [13,14,15]
09:10:52 <lambdabot>  ZipList {getZipList = [(1,4,7,10,13),(2,5,8,11,14),(3,6,9,12,15)]}
09:11:43 <mizu_no_oto> ^ grandpascorpion: you can also use the ZipList newtype wrapper + Applicative.
09:14:14 <mizu_no_oto> Control.Newtype might allow you to omit most of the ZipList calls, there.
09:16:50 <grandpascorpion> Thanks, mizu!
09:17:41 <grandpascorpion> Could I ask you folks other question?  If you needed to count how many "holes" were in a tuple, how would you do it?
09:18:00 <bartavelle> grandpascorpion: you can get ghci to tell you with :t
09:18:13 <bartavelle> :t (,5,,6)
09:18:14 <lambdabot> (Num t2, Num t1) => t3 -> t4 -> (t3, t1, t4, t2)
09:21:11 <grandpascorpion> Thanks, bartavelle/lambdadot ... is there a way to do it in code?
09:23:11 <bartavelle> (lambdabot is a bot, you do not need to thank it, I don't think it is sentient)
09:23:20 <bartavelle> why would you do this?
09:23:33 <bartavelle> I mean, you can't accept a tuple as user input
09:23:40 <bartavelle> so it is code you wrote
09:23:49 <bartavelle> so you should know how many holes there are?
09:24:48 * lambdabot blinks
09:25:14 <grandpascorpion> D'oh.  Thanks, bartavelle.  I was just wondering.  No specific application
09:25:41 <clawtros> is there a way to make gloss not clear the frame each redraw?
09:25:45 <bartavelle> (if I was a sentient AI, I would not attract attention on myself, just saying)
09:26:41 <mud> bartavelle: That sounds like something a sentient AI would say
09:32:54 <grandpascorpion> Interesting that a hole has a polymorphic type though.
09:42:33 <dmwit> > countHoles (,5,,6)
09:42:35 <lambdabot>  2
09:42:38 <dmwit> > countHoles (,,,)
09:42:40 <lambdabot>  4
09:43:59 <hyperisco> lol
09:44:48 <hyperisco> > countHoles Just
09:44:50 <lambdabot>  error:
09:44:50 <lambdabot>      • No instance for (CountHoles (Maybe a0))
09:44:50 <lambdabot>          arising from a use of ‘countHoles’
09:45:04 <dmwit> ?let instance CountHoles (Maybe a) where countHoles _ = 0
09:45:05 <lambdabot>  Defined.
09:45:08 <dmwit> > countHoles Just
09:45:09 <lambdabot>  1
09:45:10 <dmwit> ;-)
09:46:50 <Psybur> @src countHoles
09:46:50 <lambdabot> Source not found. Abort, Retry, Panic?
09:46:59 <hydraz> panic.
09:47:08 <Psybur> > panic
09:47:09 <lambdabot>  error: Variable not in scope: panic
09:47:19 * hackage hackernews 1.4.0.0 - API for Hacker News  https://hackage.haskell.org/package/hackernews-1.4.0.0 (DavidJohnson)
09:49:49 * hackage text 1.2.3.0 - An efficient packed Unicode text type.  https://hackage.haskell.org/package/text-1.2.3.0 (HerbertValerioRiedel)
10:01:02 <henk> hi, anyone know who to contact using which means about issues regarding http://haskellbook.com/
10:01:04 <henk> ?
10:02:00 <hyperisco> henk, do they not have contact info on the site?
10:02:05 <monochrom> That question is very scrambled. But an author is here as bitemyapp
10:02:09 <henk> I did already write an email about a month ago to the contact address support@haskellprogramming.zendesk.com that is given on the website, but never received anything back.
10:02:46 <henk> hyperisco: sorry for not mentioning right away that I already tried that.
10:02:50 <henk> monochrom: thanks
10:03:19 <henk> bitemyapp: Hey, may I query you?
10:04:23 <padre_angolano> bitemyapp shown as idle for 20 hours
10:05:19 <padre_angolano> and last said something on the channel on Dec 12
10:05:53 * hackage brick 0.31 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.31 (JonathanDaugherty)
10:06:00 <glguy_> henk: if you just have a question about Haskell you could ask that here. It's not a channel for issues with that book though
10:08:41 <bitemyapp> henk: there's a contact page on the website
10:08:53 <bitemyapp> henk: if you just need a question answered you should ask it, there's tons of people here who can help you.
10:12:37 <hyperisco> welcome back
10:17:44 <henk> bitemyapp: It’s not about haskell itself, but about the book. And I did send an email almost exactly a month ago … I’m trying a different communications channel now (;
10:21:08 <bitemyapp> henk: gotcha, been preoccupied with some day job stuff and also things necessary to getting the book wrapped up.
10:21:22 <bitemyapp> henk: /query me your email address and I'll take a look at it in our ticketing system.
10:21:33 <henk> bitemyapp: thanks!
10:21:44 <bitemyapp> We get a lot of emails and I usually only have time to deal with immediately, quickly addressable needs like people needing a discount on the book.
10:22:22 <bitemyapp> stuff that's about digging deep into pedagogical revisions or editing, that phase is basically done and I didn't plan to digest all of that until I was ready to think about a follow-up beginner book.
10:22:26 <amalloy> heh, bitemyapp sent so many pings in the last few minutes that it woke him up from his weeks-long slumber
10:22:47 <bitemyapp> but that time is not in any way wasted as I will still go through it for my own edification and for thinking about future material.
10:27:13 <bitemyapp> amalloy: I'm always here, I just work a lot.
10:29:14 <amalloy> i just had fun imagining the scenario in your office: "oh, one ping, that's probably just someone mentioning my book, no big deal". two more pings within a couple minutes: "okay, jeez, i guess someone actually wants to talk to me"
10:30:03 <lseactuary> i am stuck on one proof can someone help me? i managed to do the empty case but stuck on the non empty sequence one: https://pastebin.com/seQahiTY
10:42:08 <lseactuary> anyone can help with line 25?
10:42:34 <POGtastic> lseactuary: doesn't look like haskell to me, but just to be clear - you're trying to find the length of a possibly nested list?
10:51:52 <lseactuary> POGtastic i am trying to prove the statement. i made the definitions and want to now show LengthS(S) = #(FlattenR(S)) where S is a sequence
10:52:06 <lseactuary> i have shown it for a non-empty one but can't seem to finish the proof for a non-empty sequence
10:53:56 <lseactuary> POGtastic # in my link is the same as LengthB
10:54:20 <lseactuary> and S = <x>^s basically <x> is the first element and s is the rest
10:54:23 <POGtastic> oh, gotcha. that was tripping me up
10:54:31 <lseactuary> there is more detail here: https://math.stackexchange.com/questions/2570883/recursion-and-first-order-logic
10:54:44 <lseactuary> i just have slightly different notation :)
10:56:31 <ski> lseactuary : is ⌜#(⋯)⌝ short for ⌜LengthB(⋯)⌝ ?
10:56:35 <lseactuary> yup
10:56:47 <POGtastic> let's look at the result of flattenR(S), where S is a non-empty sequence. let x be the first element of S, and the remaining elements are S' (in haskell, we'd use `xs`). S' has a length of one less than S.
10:56:52 <ski> is ⌜LengthB⌝ the same as ⌜lengthB⌝ and ⌜LengthS⌝ the same as ⌜lengthS⌝ ?
10:57:09 <lseactuary> sorry i should have wrote it i was just trying to figure out the math so just changed it to see the calculations better
10:57:11 <POGtastic> er. o
10:57:20 <POGtastic> er, i'm misinterpreting this. i'll leave it someone smarter
10:57:40 <lseactuary> ski - yes
10:58:56 <ski> i don't see how you go from ⌜#(concat(x, FlattenR(s)))⌝ to ⌜#(⟨c⌢concat(x,s)⟩)⌝
10:59:16 <lseactuary> line 9 i was trying to try something
10:59:27 <lseactuary> as i couldnt figure out what to do :/
10:59:45 <ski> in any case, you'll probably need an inductive hypothesis
10:59:59 <hyperisco> is this proof related to Haskell?
11:00:33 <ski> from line `22', i think you either need to use a lemma, or to do a new case/induction
11:00:53 <ski> hyperisco : tangentially, i suppose it could be construed as
11:00:54 <lseactuary> i have a lemma given let me upload it
11:01:22 <lseactuary> #(r^s) = #r + #s
11:01:30 <lseactuary> is something given to assume
11:01:37 <lseactuary> so i was trying to get something of this form
11:01:38 <hyperisco> I am going to guess it is equivalent to proving  sum (fmap length xs) = sum (concat xs)
11:01:41 <ski> yea
11:01:45 <ski> try using that ?
11:01:56 <lseactuary> on this part: ⌜#(⟨c⌢concat(x,s)⟩)⌝?
11:02:15 <lseactuary> that gives line 24 :)
11:02:26 <ski> no, on the line before, line `22'
11:02:33 <hyperisco> pretending length was not bounded…
11:02:45 <lseactuary> but there you still have a function
11:02:47 <hyperisco> or am I mistaken?
11:02:56 <lseactuary> #(FlattenR(⟨x⟩⌢s))
11:03:09 <ski> (presumably ⌜r^s⌝ is yet another notation for ⌜concat(r,s)⌝, yes ?)
11:03:11 <lseactuary> i dont think we can use the lemme on this
11:03:18 <lseactuary> nope
11:03:27 <lseactuary> hmm wait
11:03:29 <lseactuary> you are right :P
11:03:55 <ski> otherwise you may need to prove another lemma
11:04:53 <lseactuary> x ^ s is basically the first element is x and the rest is the remaining sequence
11:04:57 <lseactuary> so in this link: https://math.stackexchange.com/questions/2570883/recursion-and-first-order-logic
11:05:06 <lseactuary> <C|Concat(B,S)> means C ^ B ^ S ?
11:05:06 <ski> hm, that's not how you used it in your paste
11:05:50 <lseactuary> ski - where abouts?
11:06:04 <ski> (doesn't look like how `^' is used at that SE page, either)
11:06:14 <ski> like line 2 ?
11:06:39 <lseactuary> lengthB ⟨x⟩⌢s = 1 + lengthB s
11:06:50 <lseactuary> this is correct no?
11:07:04 <ski> it's your notation, not mine :)
11:07:18 <lseactuary> S = <a,b,c> then we take 1 + length <b,c> = 1 + 1 + length <c> = 1+1+1 = 3
11:07:32 <ski> presumably ⌜x⌝ there is the first element, and ⌜s⌝ is the sequence of remaining elements
11:07:37 <lseactuary> yup
11:07:41 <lseactuary> exactly
11:08:00 <ski> so ⌜⟨a⟩⌢⟨b,c⟩⌝ is ⌜⟨a,b,c⟩⌝
11:08:18 <lseactuary> yup
11:08:30 <ski> and matching ⌜⟨a,b,c⟩⌝ with the pattern ⌜⟨x⟩⌢s⌝ thus yields ⌜x = a⌝ and ⌜s = ⟨b,c⟩⌝
11:08:41 <lseactuary> yup
11:08:43 <ski> hence "x ^ s is basically the first element is x and the rest is the remaining sequence" is wrong
11:09:00 <ski> (assuming ⌜⌢⌝ is meant to be the same as `^'
11:09:01 <ski> )
11:09:17 <lseactuary> it is as i cant type ⌜⌢⌝ here so am using ^
11:09:22 * ski nods
11:09:25 <lseactuary> sorry i should have said this
11:10:17 <ski> anyway, can you use the lemma ?
11:10:40 <lseactuary> im changing concat to ^ first
11:10:42 <lseactuary> then will try :)
11:10:56 <lseactuary> i misunderstood the concat vs ^ which may be why i got stuck
11:10:57 <lseactuary> 2 min
11:11:29 <ski> (your definition of `concat' is a suitable definition of ⌜⌢⌝)
11:12:11 <ski> (oh, actually .. you have a small bug in `concat')
11:12:32 <ski> (or two, depending on how you count)
11:13:00 <lseactuary> which definition please?
11:14:05 <shapr> I think irccloud is having issues
11:14:37 <ski> lseactuary : your `concat' one ?
11:14:45 <lseactuary> ski which line please?
11:15:02 <ski> lseactuary : `concat' is defined on line `9'
11:15:08 <platz> why is hackage download count so erratic? one month my pkg is 30 dl/month, now it's 1964 dl/month
11:15:40 <shapr> platz: what's the package?
11:15:50 * ski clouds IRCs judgement
11:15:54 <platz> just an api wrapper lib, pinboard
11:16:16 <platz> but the dl count seems correlated across all packages, they all seem to rise and fall together
11:16:35 <shapr> sounds like weirdness in reporting
11:17:17 <lseactuary> ski - 2 mins please im going to re-upload as what i uploaded is a mess
11:17:24 <hyperisco> somewhere in Nevada there is a forgotten server in someone's closest…
11:17:59 <hyperisco> closet…
11:18:15 * ski closes the closest closet
11:18:30 * shapr closets the closest clothes
11:19:08 <hyperisco> lseactuary, was my Haskell restatement of the problem accurate?
11:19:36 * ski didn't realize the closet was a Haskell restatement
11:19:44 <ski> (related to closures, perhaps ?)
11:21:19 <hyperisco> sum (fmap length xs) = sum (concat xs)
11:21:34 <hyperisco> sorry
11:21:41 <hyperisco> sum (fmap length xs) = length (concat xs)
11:22:27 <dexterfoo> @botsnack
11:22:27 <lambdabot> :)
11:22:27 <ski> it's reasonably close
11:22:36 <lseactuary> ski - this should be better now: https://pastebin.com/2fHYE3RL
11:23:11 <ski> line `14' still has bugs
11:23:35 <lseactuary> the spaces?
11:23:41 <ski> no
11:24:04 <ski> try concatenating a couple of sample sequences using it ?
11:24:35 <ski>   ⟨a,b,c⟩ ⌢ ⟨e,f⟩
11:24:54 <lseactuary> ah i should have maintained the order
11:25:01 <ski> yes .. and ?
11:25:21 <lseactuary> checking
11:25:36 <lseactuary> no () ?
11:25:45 <hyperisco> ≡ sum (length y ++ fmap length ys) = length (y ++ concat ys) ≡ length y + sum (fmap length ys) = length y + length (concat ys) ≡ sum (fmap length ys) = length (concat ys)  which is the inductive hypothesis
11:25:52 <ski> lseactuary : doesn't matter
11:26:25 <lseactuary> hmm
11:26:37 <lseactuary> empty set and c is <c>
11:26:40 <lseactuary> not just c ?
11:27:40 <hyperisco> will formalise in Coq easily
11:28:12 <ski> well, i assume by order you mean rotate ⌜c⌝, ⌜x⌝ and ⌜s⌝, to the left, yes ?
11:28:41 <grandpascorpion> Is bottom the value of a hole in a tuplet?
11:28:50 <lseactuary> so the line would read: ...and (<x>^s^c) = <x^s^c>
11:28:59 <hyperisco> grandpascorpion, no, it is just notation for a lambda
11:29:20 <grandpascorpion> Thanks, make sense
11:29:21 <ski> lseactuary : ok, let's from there
11:29:22 <grandpascorpion> +s
11:29:23 <hyperisco> grandpascorpion,  (1,,2)  is  (\y -> (1,y,2))  for example
11:29:48 <ski>      ⟨a,b,c⟩ ⌢ ⟨e,f⟩
11:29:54 <ski>   =  (⟨a⟩ ⌢ ⟨b,c⟩) ⌢ ⟨e,f⟩
11:30:08 <ski>   =  ⟨a ⌢ ⟨b,c⟩ ⌢ ⟨e,f⟩⟩
11:30:18 <dmwit> grandpascorpion: Last time you left before I could unveil this masterpiece:
11:30:19 <lseactuary> this is line 14 still? or we are looking at the proof?
11:30:25 <dmwit> > countHoles (,5,,6)
11:30:27 <lambdabot>  2
11:30:33 <dmwit> > countHoles (,,,,,)
11:30:35 <lambdabot>  6
11:30:39 <ski> now i need to know whether ⌜⌢⌝ is left- or right- associative, to be able to continue
11:30:51 <lseactuary> idk which line we are talking about
11:30:55 <lseactuary> can you clarify?
11:31:01 <hyperisco> > countHoles (Just,)
11:31:03 <lambdabot>  1
11:31:05 <hoon> is there a simple way to parse a >0 option using optparse-applicative that I'm not seeing?
11:31:19 <ski> > countHoles ((,) . Just)
11:31:21 <lambdabot>  2
11:31:49 <hoon> I thought of making the parser return a "Numeric.Natural" but that doesn't seem to work because 0 is part of the Naturals
11:31:52 <hyperisco> > countHoles (const Nothing)
11:31:53 <ski> lseactuary : i'm talking about the three lines i stated above
11:31:54 <lambdabot>  1
11:32:06 <lseactuary> ski and what do they relate to in the pastebin please?
11:32:32 <ski> lseactuary : that reduction sequence is using the definition of ⌜⌢⌝ you provided in the paste
11:32:39 <dmwit> hoon: I think `ReadM` is a `Monad`, hence offers `fail`.
11:32:45 <ski> lseactuary : can you now answer my query ?
11:32:47 <lseactuary> i dont see a/b/c/d/e/f though....
11:33:05 <lseactuary> ski <> is an ordered sequence so im guessing right associative since order matters
11:33:08 <ski> those are just arbitrary variables (or constants, if you prefer)
11:33:11 <lseactuary> ok
11:33:25 <ski> ok, let's go with right-associative
11:33:27 <lseactuary> ok
11:33:33 <ski>      ⟨a,b,c⟩ ⌢ ⟨e,f⟩
11:33:36 <ski>   =  (⟨a⟩ ⌢ ⟨b,c⟩) ⌢ ⟨e,f⟩
11:33:44 <ski>   =  ⟨a ⌢ (⟨b,c⟩ ⌢ ⟨e,f⟩)⟩
11:34:03 <ski>   =  ⟨a ⌢ ((⟨b⟩ ⌢ ⟨c⟩) ⌢ ⟨e,f⟩)⟩
11:34:08 <hyperisco> it is alternating associativity, starting with right
11:34:09 <dmwit> hoon: Oh, and there's the nicer `readerAbort :: ParseError -> ReadM a`.
11:34:23 <ski>   =  ⟨a ⌢ ⟨b ⌢ (⟨c⟩ ⌢ ⟨e,f⟩)⟩⟩
11:34:29 <hoon> So I have to roll my own ReadM check the result for negative, opt for "fail" if it is, and convert that whole thing to a ReadP via ...
11:34:37 <ski>   =  ⟨a ⌢ ⟨b ⌢ ((⟨c⟩ ⌢ ⟨⟩) ⌢ ⟨e,f⟩)⟩⟩
11:34:43 <hoon> opt for "readerAbort" ...
11:34:58 <ski>   =  ⟨a ⌢ ⟨b ⌢ ⟨c ⌢ (⟨⟩ ⌢ ⟨e,f⟩)⟩⟩⟩
11:35:04 <ski>   =  ⟨a ⌢ ⟨b ⌢ ⟨c ⌢ ⟨e,f⟩⟩⟩⟩
11:35:09 <ski> lseactuary : ok ?
11:35:13 <dmwit> hoon: option :: ReadM a -> Mod OptionFields a -> Parser a
11:35:34 <lseactuary> ski - reading and trying to understand 2 min
11:36:18 <hoon> oh
11:36:25 <hoon> I see
11:37:02 <hoon> I think I've got it. Let me poke around a minute
11:37:20 <dmwit> hoon++ for always helping himself
11:37:41 <hoon> haha
11:37:56 <lseactuary> ski i think i got it
11:37:58 <lseactuary> trying
11:37:58 <hoon> I always just need a kick/shove/heave in the right direction
11:38:12 <dmwit> yeah!
11:38:13 <ski> lseactuary : i'm also using the "cons decomposition" that ⌜⟨x,⋯⟩⌝ is equal to ⌜⟨x⟩ ⌢ ⟨⋯⟩⌝, to be able to apply your definition of ⌜⌢⌝
11:38:27 <lseactuary> ye
11:38:58 <lseactuary> what is your S here? <a,b,c,e,f> and your <x> is <a,b,c>?
11:39:01 <ski> (or, this can be viewed as a desugaring step, not a real computation step)
11:39:27 <ski> no ⌜S⌝
11:39:45 <lseactuary> ?
11:39:49 <ski> i haven't reached line `16' yet. this is still a reflection only on line `14'
11:40:19 <lseactuary> ok
11:40:27 <ski> could you follow my reduction sequence, above ?
11:41:55 <lseactuary> yup
11:42:03 <ski> does it sound reasonable ?
11:42:06 <lseactuary> i am confused on one thing
11:42:06 <ski> (or look)
11:42:28 <lseactuary> <x>^s is an element and a sequence
11:42:32 <lseactuary> ah
11:42:36 <lseactuary> ignore it just clicked :
11:42:38 <lseactuary> :)
11:43:03 <ski> so the reduction sequence sounds just dandy, then ?
11:43:39 <lseactuary> so (<x>^s^c) = <x^<s^<c>>>
11:43:40 <lseactuary> right?
11:43:49 <ski> hm, no ?
11:43:53 <ski> why ?
11:44:07 <lseactuary> line 14 is wrong no?
11:44:24 <ski> we can do a reduction sequence, using that adaptation of the definition, if you want to
11:44:35 <lseactuary> im not sure i follow anymore
11:44:53 <ski> let's do that, and see where it gets us
11:44:56 <ski> before, i was using
11:45:35 <ski>   ⟨⟩ ^ c = c
11:46:03 <ski>   (⟨x⟩ ^ s) ^ c = ⟨x ^ (s ^ c)⟩
11:46:21 <ski> now, you suggested changing the latter to
11:46:25 <lseactuary> isnt line 14 supposed to be <>^c=<c> and (<x>^s^c) = <x^<s^<c>>> based on what you just did with the a/b/c/d/e/f stuff?
11:46:43 <ski>   (<x> ^ s) ^ c = <x ^ <s ^ <c>>>
11:48:23 <ski> using this new definition of ⌜⌢⌝ (together with ⌜⟨x,⋯⟩⌝ being equal to ⌜⟨x⟩ ⌢ ⟨⋯⟩⌝), we get
11:48:29 <ski>      ⟨a,b,c⟩ ⌢ ⟨e,f⟩
11:48:33 <ski>    =  (⟨a⟩ ⌢ ⟨b,c⟩) ⌢ ⟨e,f⟩
11:49:09 <ski>    =  ⟨a ⌢ ⟨⟨b,c⟩ ⌢ ⟨⟨e,f⟩⟩⟩⟩
11:49:09 <lseactuary> i am still confused
11:49:23 <lseactuary> https://math.stackexchange.com/questions/2570883/recursion-and-first-order-logic
11:49:29 <lseactuary> in this link he uses B|S
11:49:32 <ski>    =  ⟨a ⌢ ⟨(⟨b⟩ ⌢ ⟨c⟩) ⌢ ⟨⟨e,f⟩⟩⟩⟩
11:49:38 <lseactuary> where B is the first element and S is a sequence
11:49:44 <lseactuary> in here I am using <x> and S
11:49:48 <lseactuary> sorry s
11:49:54 <lseactuary> where S = <x> ^ s
11:50:04 <lseactuary> so in the flatten definition we have
11:50:10 <ski>    =  ⟨a ⌢ ⟨⟨b ⌢ ⟨⟨c⟩ ⌢ ⟨⟨⟨e,f⟩⟩⟩⟩⟩⟩⟩
11:50:11 <lseactuary> <>^c = c
11:50:16 <lseactuary> which should be <c> no?
11:50:24 <lseactuary> and according to your example above
11:50:24 <ski>    =  ⟨a ⌢ ⟨⟨b ⌢ ⟨(⟨c⟩ ⌢ ⟨⟩) ⌢ ⟨⟨⟨e,f⟩⟩⟩⟩⟩⟩⟩
11:50:43 <lseactuary> <x>^s^c should be <x^<s^<c>>>
11:50:56 <lseactuary> or am i mistaken?
11:51:00 <ski>    =  ⟨a ⌢ ⟨⟨b ⌢ ⟨⟨c ⌢ ⟨⟨⟩ ⌢ ⟨⟨⟨⟨e,f⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩
11:51:07 <ski>    =  ⟨a ⌢ ⟨⟨b ⌢ ⟨⟨c ⌢ ⟨⟨⟨⟨⟨e,f⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩
11:51:26 <ski> so, that's the answer you get, with your new suggested definition change above
11:51:49 <lseactuary> huh?
11:52:01 <lseactuary> ok im totally lost now tbh
11:52:07 <hoon> dmwit: got it!
11:52:08 <ski> `<>^c' is not `<c>', no
11:52:12 <hoon> thank for your nudge
11:52:14 <lseactuary> why?
11:52:23 <hyperisco>  /nudge
11:52:23 <ski> lseactuary : well, you ought to be .. because it's nonsense !
11:52:28 <hyperisco> wasn't that fun in the day
11:52:33 <hoon> dmwit++ :)
11:52:44 <lseactuary> ski it is just c?
11:52:58 <ski> yes, as you said right above :
11:53:01 <ski> <lseactuary> <>^c = c
11:53:12 <lseactuary> ok
11:53:22 <ski> ⌜c⌝ is already a sequence
11:53:23 <lseactuary> and <x>^s^c is?
11:53:32 <lseactuary> ah
11:53:50 <lseactuary> but then <x>^s^c is just <x^s^c>
11:53:51 <lseactuary> no?
11:53:57 <ski> well, given that you interpret `^' right-associatively, `<x>^s^c' will then mean `<x>^(s^c)'
11:54:10 <ski> but presumably you meant to say `(<x>^s)^c' ?
11:54:36 <ski> at least that's how i interpreted the left-hand-side (aka definiendum) of your second defining equation for `^'
11:54:42 <lseactuary> Concat(<>,S)=S
11:54:48 <lseactuary> Concat(<C|B>,S)=<C|Concat(B,S)>
11:54:53 <lseactuary> Flatten(<B|S>)=Concat(B,Flatten(S))
11:54:59 <lseactuary> Concat = ^ right?
11:55:16 <ski> that looks right
11:55:21 <lseactuary> so Flatten(<x>^s) = x ^ Flatten(s)
11:55:40 <ski> now recall that `<C|B>' in your other syntax (not using `|') would be .. what ?
11:55:47 <lseactuary> ye converting to understand :)
11:56:00 <lseactuary> so Concat(<>,S)=S --> <>^c = c
11:56:14 <ski> ok
11:56:20 <ski> and the other equation ?
11:56:33 <lseactuary> and Concat(<C|B>,S)=<C|Concat(B,S)> --> <c^x>^s = <c^(x^s)>
11:56:35 <lseactuary> like this?
11:56:46 <ski> nope, try again ?
11:57:00 <ski> perhaps first answer my question
11:57:03 <ski> <ski> now recall that `<C|B>' in your other syntax (not using `|') would be .. what ?
11:57:15 <lseactuary> C|B is c^x no?
11:57:32 <ski> `C|B' on its own is a syntax error. it means nothing, in isolation
11:57:41 <lseactuary> yeah
11:59:27 <lseactuary> hmm
11:59:56 <lseactuary> i am not sure tbh
12:00:08 <lseactuary> how to convert this Concat(<C|B>,S)=<C|Concat(B,S)>
12:00:15 <ski> hint : `<C|B>' doesn't translate to `<c^x>'
12:00:17 <lseactuary> its basically <C|B>^S
12:00:32 <lseactuary> = <C|B^S>
12:00:39 <lseactuary> but im unsure what the | is
12:00:44 <ski> nowhere
12:00:53 <ski> there is no `|' in isolation
12:01:03 <ski> there is a syntactic construction `<...|...>'
12:01:19 <lseactuary> its new notation?
12:01:26 <ski> yes
12:01:28 <lseactuary> ah
12:01:39 <ski> (Prolog (and also Erlang) has something similar)
12:02:01 <lseactuary> so its just <c|x>^s = <c|b^s>
12:02:57 <ski> yes, though that isn't translated to the notation without `<...|...>'
12:03:05 <ski> (also ityb `b' should be `x' ?)
12:03:13 <lseactuary> but idk what is |
12:03:27 <ski> it is nothing, meaningless
12:03:33 <lseactuary> sorry yes Concat(<C|B>,S)=<C|Concat(B,S)> --> <c|x>^s = <c|x^s>
12:03:56 <lseactuary> ski ok so we are doing the proof now?
12:04:02 <ski> it's like asking what `|' means in a Haskell list comprehension `[ x^2 | x <- [0 .. 9] ]'
12:04:10 <ski> it simply means nothing, in isolation
12:04:14 <lseactuary> ok
12:04:21 <lseactuary> so <c|x>^s = <c|x^s> is the correct translation?
12:04:38 <ski> you didn't translate away the `<...|...>' notation
12:05:02 <ski> (and your paste didn't use that notation, so i was figuring you wanted to translate away it .. ?)
12:05:09 <lseactuary> that is the part idk how to translate
12:05:19 <lseactuary> yes i dont use that notation as i dont know what it means
12:05:24 <ski> "(in here, $<B|S>$ means a sequence whose first entry is $B$, and where the rest of the sequence is sequence $S$. So, for example, if $S = <1,2,3,4>$, then $S= <1|<2,3,4>>$ (this is standard notation in LISP or PROLOG))"
12:05:32 <lseactuary> yes
12:05:37 <ski> read that quote from the SE link, again ?
12:05:40 <lseactuary> yes
12:05:47 <lseactuary> which i denote as <x>^s
12:05:52 <lseactuary> instead of B|S
12:06:04 <lseactuary> oh
12:06:23 <lseactuary> <c|x>^s --> <<c>^x>^s
12:06:25 <ski> if `S' is `<1,2,3,4>', which is `<1|<2,3,4>>', then what does that become, in the `<...|...>'-less notation ?
12:06:49 <ski> it's better, but still not quite
12:06:49 <lseactuary> and <c|x^s> --> <<c>^x>^s
12:07:03 <lseactuary> (<c>^x)^s
12:07:05 <lseactuary> ?
12:07:41 <ski> `<c|x>^s --> <<c>^x>^s' seems to suggest that you think `<c|x>' is translated as `<<c>^x>'
12:07:56 <lseactuary> the outer brackets shouldnt be <> right?
12:07:59 <lseactuary> just normal ( )
12:08:03 <hyperisco> I am thinking of "Notation" the board game
12:08:03 <ski> correct :)
12:08:35 <lseactuary> Concat(<C|B>,S)=<C|Concat(B,S)> --> (<c>^x)^s = (<c>^x^s)
12:08:36 <ski> i'm sorry for having to be a bit anal with notation here .. but you were confusing yourself with it, so it's important that you understand what went wrong
12:08:48 <lseactuary> ski no i really appreciate it i have to learn
12:09:20 <ski> my reduction sequences above were really attempts to make you realize that something must be wrong, and then try to figure out what
12:09:25 <lseactuary> yeah
12:09:43 <lseactuary> is it correct now?
12:09:46 <ski> (because the end results in them were obviously confused/incorrect answers)
12:10:05 <ski> yes, assuming you use right-associative `^'
12:10:10 <lseactuary> yup
12:10:18 <ski> i might write just
12:10:53 <ski>   (⟨x⟩ ⌢ s) ⌢ c = ⟨c⟩ ⌢ (x ⌢ s)
12:11:06 <ski> to avoid having to specify / rely on an associativity
12:11:21 <ski> but if you decide to use right-associativity consistently, that's also fine
12:11:37 <ski> er, sorry i got your variables rotated around, that should be :)
12:11:42 <ski>   (⟨x⟩ ⌢ s) ⌢ c = ⟨x⟩ ⌢ (s ⌢ c)
12:11:46 <lseactuary> yup yup
12:11:48 <lseactuary> makes sense now
12:12:04 <ski> now we can perhaps return to the proof :)
12:12:08 <lseactuary> yup :D
12:12:29 <ReinH> lseactuary: what language is this?
12:13:01 <lseactuary> ReinH - i have to write in math then in haskell. trying to understand the math first.
12:13:19 <ski> (i'd also add extra brackets to the definitions of ⌜lengthB⌝,⌜lengthS⌝,⌜flattenR⌝, at least if you have Haskell-like precedence where application binds tighter than infix operators)
12:13:30 <ReinH> lseactuary: what notation system are you using?
12:13:33 * hyperisco grumbles about Haskell being math
12:13:42 <lseactuary> lengthB s --> lengthB(s) like this?
12:13:46 * ski grumbles about math being Haskell
12:13:55 <ski> e.g., yes
12:13:56 <ski> or
12:13:57 <lseactuary> ReinH first order logic
12:14:00 <ReinH> Also why not just write it in Agda and kill both birds with one stone?
12:14:02 <ski>   lengthB ⟨⟩ = 0
12:14:10 <ski>   lengthB (⟨x⟩^s) = 1 + lengthB s
12:14:13 <lseactuary> ReinH - didnt learn this yet :(
12:14:24 <lseactuary> ski ok will add
12:14:38 <ski> .. in any case, you ought to disambiguate `⟨x⟩^s ^c'
12:14:49 <ski> (line `14')
12:15:03 <lseactuary> yup doing it now
12:15:25 <ReinH> lseactuary: I guess my question actually is what is the ⌢?
12:15:27 <ski> lseactuary : what you had before (except that line `14' issue i just mentioned) is also ok, as long as you're consistent in your syntactic conventions (which line `14' wasn't)
12:15:43 <ski> ReinH : it's `(++)'
12:15:50 <ReinH> Ok
12:16:04 <ski> and `<x>^s' is `x:s'
12:16:12 <lseactuary> yeah
12:16:26 <ReinH> Sure, <> is a sequence, etc
12:16:40 * ReinH whispers 'you can just use + if you want'
12:17:37 * ski . o O ( ⌜⧺⌝ ungood ? )
12:18:42 <sinelaw> Hey, anyone familiar with Leijen's HMF?
12:19:56 <ReinH> ski: I thought we were sticking with ASCII
12:21:17 <ski> not in the original paste
12:21:37 <lseactuary> ski for the proof you think i should use 2 sequences e.g. S and T
12:21:41 <hyperisco> that was a short visit by sinelaw oO
12:23:11 <ReinH> lseactuary: where did the pastebin go?
12:23:20 <lseactuary> maybe timed out
12:23:22 <lseactuary> lemme upload
12:23:27 <ski> hyperisco, they're still in #haskell-beginners
12:24:18 <ski> hm, looks like both pastes expired, yes
12:24:32 <ReinH> gists don't time out fwiw
12:25:55 * ski . o O ( gits don't let gists time out )
12:27:04 <lseactuary> https://pastebin.com/W0H6AHRE
12:30:07 <ski> lseactuary : as i said before
12:30:28 <ski> <ski> from line `22', i think you either need to use a lemma, or to do a new case/induction
12:30:39 <ski> (now line `19')
12:31:41 <lseactuary> ski im trying to use the lemma but am stuck
12:32:00 <lseactuary> in the base case its fine
12:32:08 <lseactuary> im trying to now apply it to a non-empty sequence
12:32:12 <lseactuary> can you give me a pointer please
12:32:18 <ski> can you recall which lemma it is you're thinking of using ?
12:32:30 <lseactuary> yup i put on pastebin also
12:32:42 <lseactuary> lengthB(r^s) = lengthB(r) + lengthB(s)
12:34:26 <lseactuary> after line 19 i cant use the lemme yet as there is still a function
12:34:42 <ski> which function ?
12:34:58 <lseactuary> or can i write lengthB(x^flattenR(s))) = lengthB(x) + lengthB(flattenR(s))
12:35:11 <ski> sure
12:35:19 <lseactuary> ski flattenR right? lengthB(r^s) can only be applied to sequences no?
12:35:24 <ski> that's what the lemma gives you, since it works for all `r' and `s'
12:35:24 <lseactuary> so what i wrote above is crap?
12:35:29 <lseactuary> oh
12:35:34 <ski> so, in particular it works for `x' and `flattenR(s)'
12:35:38 <lseactuary> ah
12:36:12 <ski> now, you'll need an inductive hypothesis
12:36:23 <hyperisco> this keyboard sometimes double types an s… =\
12:37:10 <ski> what is the inductive hypothesis that your induction here allows you to assume ?
12:37:24 <lseactuary> assume #(flattenR(s)) is true
12:37:25 <ski> (also, you should state explicitly where you assume it, and why)
12:37:44 <ski> nope. that's not a logical formulae, it doesn't have a truth-value as value
12:37:48 <lseactuary> hmm
12:37:51 <ski> that is a natural number
12:38:06 <ski> "#(flattenR(s)) is true" is nonsense
12:38:17 <hyperisco> 1 is true
12:38:19 <sinelaw> question about implementation of RankNTypes: how does GHC handle explicit foralls internally? i.e. how does it avoid 'floating' the foralls to a more external type? does it mark forall's that originate from explicit user code as special ones that can't be moved?
12:38:20 <lseactuary> proof by induction is base case then assume true for n=k then prove for n=k+1
12:38:24 <hyperisco> not 0 is true
12:38:26 <lseactuary> so base case i did
12:38:38 <hyperisco> I mean, why not, C did i
12:38:57 * ski has seen C code in which `0' means true/success
12:39:05 <lseactuary> lengthB(x^flattenR(s)) = lengthB(x) + lengthB(flattenR(s))
12:39:17 <hyperisco> yeah that's a return code for success, ofc
12:39:42 <hyperisco> so, 0 is false, but also success, and 1 is true, but also the number 1… -1 is also true, but also an error code
12:39:44 <lseactuary> now i am stuck
12:39:50 <ski> (also for plain booleans. iirc `-1' was false)
12:39:55 <hyperisco> it is also "greater than"
12:40:41 <hyperisco> I mean "less than"… well it is one of them
12:40:44 <ski> sinelaw : perhaps #ghc could give a better answer, if you don't get one here ..
12:41:10 <sinelaw> trying there now
12:41:16 <hyperisco> sinelaw, if it matters to you, I found the handling of foralls and RankNTypes a bit off
12:41:28 <hyperisco> :t id :: forall a. a -> a
12:41:28 <lambdabot> a -> a
12:41:31 <ski> lseactuary : "proof by induction is base case then assume true for n=k then prove for n=k+1" -- almost, except this isn't "mathematical induction" (meaning "structural induction on natural numbers"), but "structural induction over sequences"
12:41:38 <hyperisco> :t id ::  (forall a. a -> a) -> (forall a. a -> a)
12:41:39 <lambdabot> (forall a1. a1 -> a1) -> a -> a
12:41:57 <hyperisco> :t id :: ((forall a. a -> a) -> (forall a. a -> a)) -> ((forall a. a -> a) -> (forall a. a -> a))
12:41:58 <lambdabot> error:
12:41:58 <lambdabot>     • Cannot instantiate unification variable ‘a1’
12:41:58 <lambdabot>       with a type involving foralls: (forall a. a -> a) -> a0 -> a0
12:42:09 <ski> (well, you could do induction on the length of the sequences ..)
12:42:43 <hyperisco> so  id (id id)  isn't well-typed in that way…
12:43:23 <ski> itym `id id id' ?
12:43:51 <hyperisco> yeah I guess so
12:43:57 <lseactuary> ski ah ok
12:44:18 <lseactuary> i will have to read up on this and try
12:44:21 <lseactuary> one quick question
12:44:31 <ski> @type id id id
12:44:32 <lambdabot> a -> a
12:45:13 <lseactuary> RouteList ::= empty | join <<RouteList x (seq_1 Section_Id)>>
12:45:34 <lseactuary> what form is this data and how do i make a recursive function, similar to the lengthB and lengthS one please?
12:46:40 <ski> that looks like some kind of recursive data type / syntax
12:47:25 <ski> i'm not sure which, if any, functions in your paste would have types involving this `RouteList'
12:48:02 <Yotam> Anyone has a working setup of wx with nix I can copy?
12:48:11 <lseactuary> ye its a new data type. i am wondering how it looks in order to model it
12:48:37 <ski> it's not clear to me what `x', `seq_1',`Section_Id' means
12:48:39 <kakashiAL> I feel very weak and not confident enough with the haskell type system. could you give me some good resources for it?
12:48:51 <ski> nor the round brackets, nor the double angle brackets
12:49:15 <lseactuary> oki
12:49:24 <lseactuary> i will have a read up on structural induction and try it
12:49:30 <lseactuary> thanks for all the help! :)
12:50:07 <ski> lseactuary : you could try to prove by structural induction on natural numbers, that zero is a (left and right) neutral element of addition, that addition is commutative and associative
12:50:27 <ski> lseactuary : and then similarly, but for lists, empty list, list concatenation
12:50:37 <ski> (or s/lists/sequences/, if you prefer)
12:52:40 <hyperisco> I'd be tempted to find something to relate to Peano numbers
12:53:15 <hyperisco> since a list where we don't care about elements is just a Peano nat, and ++ is addition
12:54:03 <hyperisco> so in other words you work towards length being id
12:55:18 <hyperisco> sum (fmap length xs) = length (concat xs) ≡ sum (fmap id xs) = concat xs ≡ sum xs = concat xs
12:55:41 <hyperisco> and then we can also see that sum = concat
12:56:23 <hyperisco> how one would tie this up in a bow I am not sure…  would be interested to watch
12:56:39 <hyperisco> and how do I fix this keyboard from typing random extra characters… grr… extra s's, r's, spaces…
12:56:46 <ski> hyperisco : now let `sum' be a monad action ..
12:57:23 <hyperisco> cost me about $120 so seems pretty lame that it isn't working…
12:58:18 <ski> kakashiAL : hm, not exactly Haskell, but perhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> could still help ?
12:59:07 <hyperisco> will have to take it to pieces and inspect the electronics
13:00:35 <kakashiAL> ski: link is not working
13:03:35 <ski> kakashiAL : hm, i think it worked not that long ago. try <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
13:06:09 <hyperisco> ugh, a mushy cap keyboard
13:07:30 <ski>   sum (| singleton (| |) , n |)  =  n
13:07:30 <ski>   sum (| concat (| l0 , l1 |) , n |)  =  sum (| l0 , sum (| l1 , n |) |)
13:07:57 <kakashiAL> ski: dont you have something easy to grasp?
13:08:20 <ski> how about an introduction textbook for Haskell ?
13:08:39 <ski> (e.g. "Haskell: The Craft of Functional Programming" by Simon Thompson)
13:10:10 <lseactuary> ski - ok will try :)
13:11:28 <bitemyapp> kakashiAL: everything takes work, but selfishly suggesting my own book: http://haskellbook.com/
13:11:43 <bitemyapp> kakashiAL: if you can't afford it, LMK in /query
13:17:40 <yoho> ngl, I saw those messages and my first thought was "look at this guy self-promoting, how annoying"
13:17:59 <yoho> every single tweet I'm seeing after searching @haskellbook is resoundingly positive - impressive
13:18:06 <Welkin> if you don't promote yourself, no one will
13:18:30 <yoho> I'm seeing a lot of people promoting it actually, which is a pretty good sign :P
13:18:42 <Welkin> it's down to personal taste
13:18:50 <Welkin> there arel ots of different resources for different people
13:18:57 <Welkin> there is no single best resource for everyone
13:19:02 <Welkin> you may like it, you may not
13:19:28 <c_wraith> it's a lot of work to get through, which is really good if you're doing exercises to learn. a bit less good if you're just trying to read it to see what it covers. :)
13:19:48 <yoho> absolutely yeah, I tend to piece together my stuff from random sites/blogs/papers rather than more structured texts
13:19:52 <c_wraith> (it should be optimized for learners anyway)
13:19:53 <Welkin> I personally think it is way too long
13:20:06 <Welkin> but then I prefer concise books
13:20:09 <yoho> agreed c_wraith
13:20:35 <yoho> there's a differnce between a guided tour and a reference document (and I'll tend towards the second)
13:21:17 <hyperisco> there is something appealing about the idea of having a brutally concise explanation of Haskell
13:21:33 <Welkin> hyperisco: did you evolve?
13:21:55 <hyperisco> only while I am at work
13:22:03 <Welkin> press B!
13:22:17 <hyperisco> it unsticks after 5…
13:24:39 <hyperisco> I use keychains and I don't have the password for my other account while I am here :P
13:24:52 <Welkin> working on raspberry pis?
13:25:10 <hyperisco> doing some QA today
13:25:20 <Welkin> did you try running haskell on them?
13:25:39 <hyperisco> ordered a starter kit and a ESP8266 chip for home… plus AoE
13:25:49 <Welkin> area of effect?
13:25:54 <hyperisco> Art of Electronics
13:26:42 <hoon> AoE is amazing
13:26:50 <platz> someone commented once that haskellers prefer brutally concise and correct explanations of things
13:27:04 <hyperisco> I am not optimistic about having the Haskell runtime on those tiny chips but definitely an eDSL or something
13:27:32 <platz> as opposed other cultures which prefer verbose explanations from a variety of perspectives
13:28:09 <Welkin> other cultures?
13:28:10 <Welkin> haha
13:28:14 <platz> lol
13:28:28 <Welkin> like those barbaric java programmers living out in the wilderness?
13:29:25 <systemfault> Don't you all miss having a UserAdapterStrategySingletonFacadeDecorator?
13:29:35 <hoon> hyperisco: planning to run something on the ESP8266 written in haskell?
13:29:36 <hyperisco> the verbose explanations help you learn what to be thinking about, whereas the concise explanations make no effort to lead you
13:31:00 <hyperisco> hoon, probably not Haskell itself but it is a great language for writing compilers, and there are a few interesting languages written in Haskell already
13:32:23 <hoon> I see
13:32:35 <Welkin> you were blind, and now you see
14:01:30 <hits1911> Can I make putStrLn $ showHex (f c1) $ showHex (f c2) ... $ showHex (f c5) "" shorter?
14:02:16 <pavonia> Are c1 .. c5 of the same type?
14:02:30 <royal_screwup21> this is for y'all http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
14:02:45 <kadoban> Depending on the types, putStrLn $ map (showHex . f) [c1, c2, c5] -- might work
14:03:04 <hits1911> yes and f is of type (Int, Int) -> Int
14:03:09 <glguy> close, need to handle the ShowS part
14:03:40 <glguy> :t \f xs -> foldr (.) id (map (showHex . f) xs) ""
14:03:41 <lambdabot> (Show a1, Integral a1) => (a2 -> a1) -> [a2] -> String
14:03:44 <kadoban> Oh, right that's not correct
14:04:11 <glguy> \f xs -> foldr ($) "" (map (showHex . f) xs)
14:07:35 <ski> @type \f -> foldr ((.) . showHex . f) id
14:07:36 <lambdabot> (Show a1, Integral a1, Foldable t) => (a2 -> a1) -> t a2 -> String -> String
14:07:36 <hits1911> thanks.
14:09:36 <glguy> You won't need to obfuscate it into a single foldr, list fusion takes care of that
14:11:51 <hits1911> do you think my initial code would be preferred over foldr?
14:13:19 <glguy> putStrLn (foldr id "" (showHex . f <$> [c1,c2,c3,c4,c5])) -- would seem fine to me
14:13:35 <hyperisco> whether it is better to unroll fixed recursion (or loops) is debatable
14:14:26 <glguy> You could name concatShowS = foldr (.) id :: [ShowS] -> ShowS -- if you wanted to bbe more explicit
14:14:48 <hyperisco> I think the saying goes "if more than three then use a for"
14:15:14 <johnw> how about: appEndo (foldMap (Endo . showHex . f) [c1...]) ""
14:15:29 * ski . o O ( `compose' )
14:15:47 <johnw> i mean, this is just a DList in disguise
14:16:27 <glguy> I don't think explicit newtype wrapper use like that belongs mixed in with other logic, but should be isolated to the thing it's implementing
14:16:50 <glguy> so in this case you could use Endo to build something named compose, but I wouldn't mix that in with f or showHex directly
14:17:59 <glguy> > let compose = ala Endo foldMap in compose (map showHex [0..15]) ""
14:18:00 <lambdabot>  "0123456789abcdef"
14:18:48 <johnw> glguy: nice
14:20:34 * ski . o O ( `composeMap' )
14:21:25 <hydraz> :t ala
14:21:26 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
14:21:37 * hydraz blinks
14:21:48 <johnw> it uses a typeclass to automate the wrapping and unwrapping
14:22:03 <glguy> % :i ala
14:22:04 <johnw> since we need Endo on the inside, and appEndo on the outside
14:22:04 <yahb> glguy: ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s) -- Defined in `Control.Lens.Wrapped'
14:22:12 <hyperisco> and amazingly it becomes nothing at all when code is generated
14:22:14 * yoho . o O ( I like this thought bubble thing )
14:22:19 <johnw> right
14:22:44 <glguy> http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Wrapped.html#v:ala
14:23:08 <glguy> ala = au . _Wrapping
14:23:12 <glguy> % :i au
14:23:12 <yahb> glguy: au :: Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a -- Defined in `Control.Lens.Iso'
14:23:18 <johnw> hah
14:23:24 <johnw> this isn't getting better, glguy :)
14:23:47 * ski quietly stabs an iso in the lens
14:23:51 <glguy> It's good for one-liners on IRC, at least
14:25:49 <johnw> lens is the anti-onion: peel back the layers, and there are even more layers
14:26:10 <glguy> It dries your tears?
14:26:41 <geekosaur> coonion
14:26:41 <hyperisco> lens is a coinductive onion
14:26:50 <johnw> glguy: it forces water into your eyes
14:29:22 <MarcelineVQ> > (1,2) & ogre _1 (+1)
14:29:24 <lambdabot>  (2,2)
14:33:28 <Gurkenglas> > ogle _1 (1,2)
14:33:30 <lambdabot>  1
14:42:27 <Welkin> what
14:42:39 <Welkin> :t ogle
14:42:40 <lambdabot> MonadReader s m => Getting a s a -> m a
14:42:45 <dmwit> :t view
14:42:46 <lambdabot> MonadReader s m => Getting a s a -> m a
14:42:47 <dmwit> ;-)
14:42:51 <Welkin> did you define that?
14:42:53 <Welkin> @undefine
14:42:53 <lambdabot> Undefined.
14:42:54 <Welkin> :t ogle
14:42:55 <lambdabot> error: Variable not in scope: ogle
14:42:58 <Welkin> okay
14:43:04 <hyperisco> RIP
14:45:30 <MarcelineVQ> :>
14:46:52 <dmwit> > foldMap showHex [0..15] "" -- totally defeat the purpose of ShowS, but what the heck
14:46:54 <lambdabot>  "0123456789abcdef"
14:47:09 <dmwit> no need to peel back the layers of lens, at least ;-)
14:48:29 <dmwit> > foldMap showHex [0..15] "lol" -- a hint about exactly how I cheated
14:48:31 <lambdabot>  "0lol1lol2lol3lol4lol5lol6lol7lol8lol9lolalolblolcloldlolelolflol"
15:07:54 <yoho> > foldMap id (replicate 5 "o") "lol" -- how I feel about this
15:07:56 <lambdabot>  error:
15:07:56 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
15:07:56 <lambdabot>                    with actual type ‘[Char]’
15:08:00 <yoho> goddammit
15:10:36 <nullie> :t foldMap
15:10:37 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
15:11:23 <nullie> how does "lol" fit there
15:11:28 <MuNuFix> Hi all , trying to wrap my head around Fix ( recursive schemes) library with some example code.
15:11:49 <MuNuFix> I am lost at the part where `Mu` is introduced.
15:12:02 <yoho> nullie: type ShowS = String -> String
15:12:06 <yoho> :t showHex
15:12:07 <lambdabot> (Show a, Integral a) => a -> ShowS
15:12:10 <nullie> oh
15:13:09 <MuNuFix> Wondering if I could get some help understand how to get an intuition about Mu.
15:13:32 <yoho> you'll just have to stick around for a bit and wait
15:13:58 <ski>   newtype Mu f = In {out :: f (Mu f)}  -- ?
15:15:39 <MuNuFix> Yes
15:16:08 <ski> and what definition of `Nu' ?
15:16:10 <MuNuFix> newtype Mu f = Mu ( forall a . (f a -> a) -> a)
15:16:19 <ski> oh, that one
15:16:21 <gesindel> ravacauliculus
15:16:24 <MuNuFix> I havent gone to Nu yet
15:16:40 <ski> (for some reason, `newtype Mu f = In {out :: f (Mu f)}' is in lambdabot)
15:18:04 <ski> and i assume the `Fix' you're seeing is basically `newtype Fix f = MkFix (f (Fix f))', then ?
15:18:56 * ski looks at MuNuFix
15:19:56 <MuNuFix> Yes
15:19:58 <MuNuFix> http://lpaste.net/361150
15:20:36 <ski> have you seen the function `fix' ?
15:20:53 <ski> @type fix
15:20:54 <lambdabot> (a -> a) -> a
15:20:59 <ski> > fix (1 :)
15:21:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:21:08 <ski> > let ones = 1 : ones in ones
15:21:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:21:29 <dmwit> > fold (replicate 5 (++"o")) "lol" -- yoho
15:21:30 <lambdabot>  "lolololololololololo"
15:21:50 <dmwit> yoho: (`foldMap id` = `fold`)
15:22:14 <yoho> that does make sense doesn't it
15:22:58 <MuNuFix> I have been following a case where an Expr is created and I evaluate the expression recursively
15:23:03 <ski> > fix (\fib n -> case n of 0 -> 0; 1 -> 1; _ -> fib (n - 1) + fib (n - 2)) 12
15:23:04 <lambdabot>  144
15:23:13 <ski> > let fib n = case n of 0 -> 0; 1 -> 1; _ -> fib (n - 1) + fib (n - 2) in fib 12
15:23:15 <lambdabot>  144
15:23:19 <MuNuFix> I really got the Fix part of it
15:23:38 <MuNuFix> Did you by any chance look a the code I pasted ?
15:23:47 <ski> ok. `Fix f' is conceptually `f (f (f (f (...))))', "without thinking much more about it"
15:24:09 <MuNuFix> Yes , <ski>
15:24:38 <ski> yes, a little
15:24:46 <MuNuFix> Wonder how to address you directly :D
15:25:06 <MuNuFix> So my question is what is the difference between Mu and Fix
15:25:19 <MuNuFix> How does Mu make it Better
15:25:56 <ski> (on IRC, custom is just to mention the nickname. usually, but not always, at the start of the message)
15:26:35 <MuNuFix> I am following the example listed here : https://github.com/sellout/recursion-scheme-talk/blob/master/recursion-bottom.org#so-whats-an-algebra
15:26:46 <ski> to a first approximation, `Mu f' is `Fix f', but where we're emphasizing that we only want a "finite number of `f' levels", in any value
15:27:22 <MuNuFix> The definitions of Mu and Fix are different
15:27:25 <ski> while `Nu f' is `Fix f', but where we're emphasizing that we want (potentially) an "infinite number of `f' levels", in values
15:27:31 <ski> yes, i'll come to that
15:27:50 <ski> for now, let's pretend we have
15:27:52 <ski>   newtype Mu f = In {out :: f (Mu f)}
15:27:55 <ski> @type In
15:27:56 <lambdabot> f (Mu f) -> Mu f
15:28:02 <ski> @type out
15:28:03 <lambdabot> Mu f -> f (Mu f)
15:28:08 <ski> (which is what's in lambdabot, as you can see)
15:28:17 <MuNuFix> Isnt that similar Fix ?
15:28:29 <dmwit> ?let newtype Mu f = Mu (forall a. (f a -> a) -> a)
15:28:30 <lambdabot>  .L.hs:157:36: error:
15:28:30 <lambdabot>      Ambiguous occurrence ‘Mu’
15:28:30 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.Mu’,
15:28:31 <ski> yes. the type definition is the same
15:28:39 <dmwit> ?let newtype NewMu f = NewMu (forall a. (f a -> a) -> a)
15:28:39 <lambdabot>  Defined.
15:28:52 <ski> so, the question is what we mean by "finite number of `f' levels"
15:28:58 <dmwit> ?let newtype ListF a b = NilF | ConsF a b
15:28:58 <lambdabot>  Parse failed: newtype declaration must have exactly one constructor.
15:29:07 <dmwit> ?let data ListF a b = NilF | ConsF a b
15:29:08 <lambdabot>  Defined.
15:29:09 <MuNuFix> Not with ListF please
15:29:12 <ski> consider the type `Mu Maybe', which we think of as `Maybe (Maybe (Maybe (...)))'
15:29:19 <MuNuFix> Lets use an Expression language
15:29:27 <ski> what are the possible values of this type ?
15:29:38 <ski> (with or without the `In' data constructors, as you please)
15:29:45 <MuNuFix> ?let data Expr a = Mul a a | Add a a | Num Int
15:29:46 <lambdabot>  Defined.
15:30:53 <ski> can you figure out any value, of this type ?
15:31:03 <MuNuFix> Which type
15:31:10 <ski> <ski> consider the type `Mu Maybe', which we think of as `Maybe (Maybe (Maybe (...)))'
15:31:23 <MuNuFix> Ok
15:32:03 <MuNuFix> We need to fold that expression to arrive at a end point
15:32:21 <ski> we need to "shortcut end" it somehow, yes
15:32:37 <MuNuFix> None could provide a shortcut
15:32:50 <int-e> :t Nothing
15:32:51 <lambdabot> Maybe a
15:32:52 <MuNuFix> I mean if you have a None somewhere , we are done right ?
15:32:55 <ski> it's `Nothing' in Haskell, but yes
15:33:06 <MuNuFix> Yeah , sorry.
15:33:17 <ski> `Nothing' can be thought of as having type `Maybe (Maybe (Maybe (...)))'
15:33:20 <MuNuFix> :t Mul 10 10
15:33:21 <lambdabot> Num a => L.Expr a
15:33:34 <ski> strictly speaking, `Nothing' has type `Maybe (Mu Maybe)', and so `In Nothing' has type `Mu Maybe'
15:34:04 <ski> and then, `Just (In Nothing)' has again type `Maybe (Mu Maybe)', and so `In (Just (In Nothing))' has type `Mu Maybe'
15:34:14 <MuNuFix> It is interesting to see the new definition
15:34:20 <ski> and then, `Just (In (Just (In Nothing)))' has again type `Maybe (Mu Maybe)', and so `In (Just (In (Just (In Nothing))))' has type `Mu Maybe'
15:34:22 <MuNuFix> :t Mu
15:34:23 <lambdabot> error:
15:34:23 <lambdabot>     • Data constructor not in scope: Mu
15:34:23 <lambdabot>     • Perhaps you meant one of these:
15:34:23 <ski> &c.
15:34:35 <ski> @kind Mu
15:34:36 <lambdabot> (* -> *) -> *
15:34:41 <MuNuFix> :t NewMu
15:34:42 <lambdabot> (forall a. (f a -> a) -> a) -> NewMu f
15:34:49 <ski> conceptually, `Nothing', `Just Nothing',`Just (Just Nothing)', &c. are the values of type `Maybe (Maybe (Maybe (...)))'
15:35:00 <MuNuFix> Yes , thats true
15:35:15 <ski> but, we can actually construct one more value, that's not partial
15:35:34 <ski> namely `let n = In (Just n) in n', aka `fix (In . Just)'
15:35:52 <ski> this corresponds conceptually to `Just (Just (Just (...)))', iow `fix Just'
15:35:56 <MuNuFix> We can wrap it inside a fix
15:36:02 <ski> that's an infinite number of `Just' levels
15:36:10 <MuNuFix> And that's where the recursion comes into picture
15:36:22 <MuNuFix> :t Fix
15:36:23 <lambdabot> error:
15:36:23 <lambdabot>     • Data constructor not in scope: Fix
15:36:23 <lambdabot>     • Perhaps you meant one of these:
15:36:40 <ski> however, when we want to think of `Fix f' as `Mu f', we explicitly want to not consider such "infinite level" values
15:37:02 <MuNuFix> Ok.
15:37:19 <MuNuFix> How ? Do we not consider that ?
15:37:44 <MuNuFix> For example in the case where data Expr a = Mul a a | Add a a | Num Int
15:38:16 <MuNuFix> You can certainly formulate an infinite level to it ( just like the case of a Maybe)
15:38:51 <ski> yes. if we're only going to consider expression trees of finite depth (or rather all paths to leaves are finite, which amounts to the same thing, here), then we think of `Mu f'. this is also sometimes written as `mu r. f r' in pseudo-code
15:39:30 <MuNuFix> :t NewMu
15:39:31 <lambdabot> (forall a. (f a -> a) -> a) -> NewMu f
15:39:38 <ski> however, if we're definitely wanting to allow the infinite-level values, then we think of `Nu f', aka `nu r. f r'
15:40:04 <ski> e.g. `mu r. Maybe (a,r)' is the type of finite lists of elements of type `a'
15:40:25 <ski> while `nu s. Maybe (a,s)' is the type of potentially finite streams of elements of type `a'
15:40:38 <MuNuFix> Maybe ?
15:40:57 <MuNuFix> How is Maybe ( a , r) a type for finite lists ?
15:41:03 <ski> `Nothing' represents it ending. `Just' means that there's an element, and another level
15:41:17 <MuNuFix> Ah.
15:41:46 <ski> not `Maybe (a,r)', but `mu r. Maybe (a,r)' (which is a formal way to write `Maybe (a,Maybe (a,Maybe (a,...)))', when we intend the `Mu' interpretation)
15:42:08 <ski> while `nu s. (a,s)' (aka `Nu (a,)') is the type of (always) infinite streams of elements of type `a'
15:42:20 <MuNuFix> Yes.
15:42:26 <MuNuFix> One point : https://github.com/sellout/recursion-scheme-talk/blob/master/recursion-bottom.org#corecursion
15:42:39 <ski> and `mu s. (a,s)' is simply the empty type (since there's no way to start/end this. no `Nothing' here to avoid having another deeper level)
15:43:03 <dmwit> :t let newRepeat x = NewMu (\g -> g (ConsF x (case newRepeat x of NewMu f -> f g))) in newRepeat
15:43:04 <lambdabot> p -> NewMu (ListF p)
15:43:14 <MuNuFix> Yes.
15:43:23 <dmwit> Okay, this does not seem like it actually prevents infinite data.
15:43:30 * ski nods
15:43:41 <ski> it's just a conceptual mnemonic
15:43:59 <MuNuFix> We dont know the end without the traversing
15:44:07 <MuNuFix> I believe hence the use of Stream vs List
15:44:27 <MuNuFix> While representing what the intent is. ( that's what I thought)
15:44:37 <ski> now, let's consider catamorphisms
15:44:44 <ski> or do you already know about them ?
15:44:57 <MuNuFix> ski , I have read about them
15:45:11 <ski> ok, should i recap a bit anyway ?
15:45:15 <MuNuFix> Now that I have done that , practically everything looks like a cata / fold
15:45:28 <ski> ok, so you know about
15:45:47 <ski>   cata :: Functor f => (f r -> r) -> (Fix f -> r)
15:45:48 <ski> ?
15:46:14 <ski>   cata phi = phi . fmap (cata phi) . unFix
15:46:18 <MuNuFix> It takes an Algebra and applies it to Fix
15:46:31 <MuNuFix> Thereby producing a value
15:47:04 <MuNuFix> The algebra doesnt know about the recursion
15:47:13 <ski>   Fix f  >-{ unFix }->  f (Fix f)  >-{ fmap (cata phi) }->  f r  >-{ phi }->  r
15:47:21 <dmwit> (When I first saw this, I thought: "Where is the base case?". Answer: it is hidden in `fmap`, which will sometimes ignore its function argument.)
15:47:29 <ski> if we want to write it as a composition of "arrows" (morphisms)
15:48:09 <ski> anyway, this `cata' is really about the `Mu' interpretation
15:48:38 <ski> (in Haskell, it also happens to work on infinite-level values, when `phi' is non-strict)
15:48:40 <MuNuFix> How can we apply cata to My
15:48:52 <MuNuFix> ski `Mu`
15:49:01 <johnw> haha, MuNuFix, nice name
15:49:10 <ski> iow, if i just rename `Fix' to `Mu', for emphasis, we have
15:49:12 <johnw> MuNuFix: have you proven in Haskell the correspondence of your three forms yet?
15:49:22 <ski>   cata :: Functor f => (f r -> r) -> (Mu f -> r)
15:49:23 <MuNuFix> johnw say it ten times aloud and you will be in my current state
15:49:29 <ski>   cata phi = phi . fmap (cata phi) . out
15:50:02 <ski> MuNuFix : hm, i should also ask whether you know about `forall'
15:50:17 <MuNuFix> For all types
15:50:57 <MuNuFix> I dont know how you made the jump on the cata
15:51:00 <MuNuFix> from Fix to Mu
15:51:01 <ski> do you know how to interpret e.g. `(forall a. [[a]] -> [a]) -> [[[b]]] -> [b]' ?
15:51:31 <ski> or `(forall a. [a] -> [a]) -> ([Integer],String)', for a simpler example
15:52:26 <MuNuFix> That's a function that takes a function from list to list for any type of a and produces a tuple
15:52:50 <MuNuFix> Atleast that's what I tell myself , let me know if I lost it :D
15:53:19 <ski> yes
15:53:29 <ski> the important part is that this function is not polymorphic
15:53:48 <ski> rather, it requires that the argument function (/callback) that you pass to it is polymorphic
15:54:11 <ski> this is called a rank-2 function, a function which requires an argument to be polymorphic
15:54:25 <MuNuFix> So it takes a function from [Int] -> [int] or [string] -> [string] correcct
15:54:54 <ski> an example definition is `foo f = (f [0,1,2],f "abcdef")' -- this requires `f' to be a polymorphic function
15:54:54 * dmwit . o O ( We have `cata :: Mu f -> (f r -> r) -> r`. What if we just made that be its constructor, of type `Mu :: ((f r -> r) -> r) -> Mu f`?)
15:55:05 <ski> dmwit : going there :)
15:55:19 <dmwit> Oops, sorry. Not meaning to get ahead of you.
15:55:38 <MuNuFix> ski the example makes sense
15:55:43 <ski> ok
15:55:48 <ski> "I dont know how you made the jump on the cata","from Fix to Mu" -- i just wanted to emphasize that `cata' is, conceptually, for the `Mu' interpretation of `Fix'. we're not considering `newtype Mu f = MkMu (forall a. (f a -> a) -> a)' yet
15:56:00 <ski> now, consider
15:56:19 <ski>   cata :: forall f r. Functor f => (f r -> r) -> (Mu f -> r)  -- explicit `forall's
15:56:22 <MuNuFix> What is the definition of Mu we are looking at ?
15:56:32 <ski> currently, just the `Fix' one
15:56:44 <ski>   newtype Mu f = In {out :: f (Mu f)}
15:56:48 <MuNuFix> Why do we call it Mu then
15:56:50 <MuNuFix> :(
15:57:11 <MuNuFix> Any case , I am with you
15:57:15 <ski> because we emphasize that we intend it as an *inductive* data type (rather than as a coinductive one, which would be `Nu')
15:57:54 <MuNuFix> Ok
15:58:04 <ski> (because Haskell has pervasive non-strictness, there's semantically no difference between these two. but we can still have one of these two in mind. in a language without general recursion, there could be a difference)
15:58:28 <ski> anyway
15:58:36 <ski>   flip cata :: forall f r. Functor f => Mu f -> (f r -> r) -> r
15:58:42 <ski>   flip cata :: forall f. forall r. Functor f => Mu f -> (f r -> r) -> r
15:58:49 <ski>   flip cata :: forall f. Functor f => forall r. Mu f -> (f r -> r) -> r
15:58:58 <ski>   flip cata :: forall f. Functor f => Mu f -> (forall r. (f r -> r) -> r)
15:59:01 <MuNuFix> Ok flipped the arguments
15:59:07 <johnw> MuNuFix: my code notes: https://github.com/jwiegley/notes/blob/master/haskell/IsoMu.hs
15:59:10 <ski> and moved the `forall r.' a bit
15:59:50 <MuNuFix> :johnw - Thank you dear sir !
15:59:54 <ski> so, for any functor `f', `flip cata' will take us from `Mu f' to `forall r. (f r -> r) -> r'
16:00:18 <ski> it so happens that we can actually also go in the opposite direction .. and these two directions are *inverses* of each other !
16:00:37 <ski> (can you figure out the type, and the implementation, of the inverse, the opposite direction ?)
16:00:41 <MuNuFix> Interesting
16:01:03 <ski> (the placement of `forall r.' inside the overall result type here is crucial, btw. that's why i moved it)
16:01:05 <MuNuFix> Is this the ana ?
16:01:09 <ski> nope
16:01:21 <ski> (we'll come to `ana' in a little bit)
16:02:33 <MuNuFix> flipping the cata function takes us from Mu to the algebra
16:02:43 <ski> right
16:02:49 <ski> and the other direction ?
16:03:08 <ski> can you answer my question about it ?
16:03:14 <MuNuFix> Other direction
16:03:28 <ski> the inverse of `flip cata' above
16:03:50 <MuNuFix> Hmm , we require a Algebra and a Mu to get to the folded value
16:03:58 <MuNuFix> We start with the algebra
16:04:24 <ski> can you formulate the type signature of `invFlipCata' ?
16:04:45 <MuNuFix> Ok .
16:05:44 <MuNuFix> flipCata :: forall f. Functor f => for all r . Mu f -> (f r -> r) -> r
16:06:04 <MuNuFix> One second , owrking it in my head
16:06:23 <MuNuFix> Inv of Inv dont we get cata itself ?
16:06:24 <ski> (the `forall r.' here isn't where i placed it)
16:06:46 <ski> if `f' is the inverse of `g', then `g' is the inverse of `f', yes
16:07:00 <MuNuFix> So you get to cata once again
16:07:12 <MuNuFix> Correct me please
16:07:18 <MuNuFix> We started with cata
16:07:32 <MuNuFix> We flipped it to arrive at the definition above
16:07:35 <ski> the inverse of `invFlipCata' should be `flip cata' (or `flipCata' if you want to give it a name), yes
16:07:50 * ski is still waiting for a signature of `invFlipCata'
16:08:17 <MuNuFix> Working it out ski
16:08:24 <ski> take your time
16:08:31 <MuNuFix> Thank you.
16:08:36 <MuNuFix> I need a notepad :)
16:09:20 <benana> x
16:09:53 <MuNuFix> Ok
16:10:26 <MuNuFix> invflipcata :: forall f. Functor f => (forall r. (f r -> r) -> r) -> Mu f
16:11:03 <MuNuFix> ski
16:11:43 <MuNuFix> * ski I still dont know how to attempt to address you , so please pardon my incantations of your name
16:12:22 <kakashiAL> I read in some articles that haskell is a strictly typed language, but is that true? I would say no because java for example is strictly typed because there YOU have to tell the compiler what type your data is, in haskell if I define f a a = a + a  <---it can assume its type if I use +
16:12:28 <ski> MuNuFix : how about like this ?
16:12:38 <MuNuFix> And BTW, the above inverse flip cata looks very much like the NewMu definition
16:12:44 <kakashiAL> with other words its not strictly typed because I dont tell it anything
16:13:10 <MuNuFix> ski : invflipcata :: forall f. Functor f => (forall r. (f r -> r) -> r) -> Mu f
16:13:11 <boj> kakashiAL: you still have to eventually tell it what the types are
16:13:27 <taktoa> kakashiAL: the preferred nomenclature is "strongly typed", since "strict" means something very different in Haskell
16:13:42 <ski> kakashiAL : it is strictly typed, but not explicitly typed. (usually) you can get away with the implementation inferring types (not including (data) type definitions)
16:14:41 <ski> kakashiAL : it's also strongly typed (meaning roughly that you can't "invoke undefined behaviour" .. at least not with normal programming)
16:15:10 <kakashiAL> boj, taktoa, ski: for me strictly typed is something that I "emphersize" if I tell you "jump" you do nothing because I didnt tell you exactly/strictly how high
16:15:41 <glguy_> If you make up new terminology it might not match what you read online
16:15:49 <ski> that's probably since the languages which you have seen before, that have been strictly typed, has also been explicitly typed, not inferred
16:16:04 <Welkin> glguy_: tell us about warm fuzzy things
16:16:05 <kakashiAL> glguy_: I dont not make, I just say how I understand it and would like to know if its right or wrong
16:16:28 <glguy_> Ah, then it's wrong
16:16:31 <taktoa> kakashiAL: if you want, you can write Haskell as if it was explicitly typed. just add type signatures to all your definitions
16:16:58 <taktoa> kakashiAL: in fact by default there's a warning for not putting type signatures on top-level definitions
16:17:06 <kakashiAL> ski: could you (in baby steps) explain what strict and strongly means, dont get the point :/
16:17:09 <oak-> kakashiAL: consider this example, if you have haskell function with type signature f :: a -> a -> a and definition f a b = a + b, it is roughly equivalent to what could be expressed in C++ as: template <typename T> T f (T a, T b) { return a + b; }
16:17:26 <ski> kakashiAL : section 1.2 of "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> might be interesting, on this topic
16:18:13 <ski> (i was using "strictly typed" as a synonym of "statically typed", i suppose)
16:18:32 <Welkin> the only typing is static typing
16:18:40 <Welkin> so, just "typed"
16:18:42 <ski> MuNuFix : ok, can you figure out how to implement `invFlipCata' ?
16:19:12 <ski> (perhaps a more useful term might be "nontrivially typed" ?)
16:19:56 <ski> MuNuFix : "anyway, the type signature looks good" -- sorry, forgot to say this before
16:21:35 <kakashiAL> ski: would you say that strongly typed means this: "if I tell you or the compiler figures out that the input must be an Int and you pass someting else, I crash, otherwise run"
16:22:21 <taktoa> kakashiAL: yes, though that property doesn't make much sense in a statically-typed setting
16:23:00 <hololeap> kakashiAL: out of curiousity, which programming language(s) are you most familiar with?
16:23:18 <kakashiAL> hololeap: java and javascript
16:24:54 <hololeap> kakashiAL: well, haskell is similar to java in that the type system catches errors during the compilation phase, as opposed to javascript or other interpreted languages that just run until they don't
16:25:01 <kakashiAL> taktoa: staticly typed and strongly typed are synonyms
16:25:27 <Welkin> you heard it here from hololeap: haskell is similar to java
16:26:11 <kakashiAL> static, strong, strict  <---just want to understand these words with some vivid and simple examples :)
16:26:44 <kadoban> "strongly typed" is a bit of a fuzzy term as far as I know
16:27:00 <[Leary]> kakashiAL: You'll have some trouble getting a runtime type error in Haskell. I think the thing to empasise is that being strongly typed is separate to the matter of how those types are arrived at.
16:27:04 <hololeap> "strict" is sort of reserved in haskell to mean "not lazy", since haskell is a lazy language
16:27:05 <ski> Scheme is stronly typed. but not statically typed, except in the trivial sense
16:27:13 <kadoban> It's supposed to mean something about not being able to work yourself around the type system.
16:27:15 <ski> C is statically typed, but not strongly typed
16:27:20 <glguy> sometimes strong vs weak typing talks about the willingness to do implicit conversions
16:28:06 <ski> (you can e.g. cast `double *' to `void(*)(void)', and invoke UB)
16:29:58 <Welkin> haha
16:30:23 <Welkin> reminds me of some lua bindings I wrote (using c) where I did all kinds of ridiculous casting and dereferencing
16:30:40 <Welkin> *(sometype**)value was everywhere
16:30:57 <kakashiAL> strictly typed   <--- tell the programm what x is if you use x ( x :: Int  <---strictly typed)
16:31:00 <kakashiAL> do you agree?
16:31:06 <Welkin> who cares what you call it
16:31:16 <Welkin> the whole weak vs strong typing thing is stupid
16:31:35 <Welkin> either it has types or it doesn't
16:31:55 <kakashiAL> javascript, python and php has types
16:32:45 <hololeap> kakashiAL: just to warn you, you will see Strict all over the place in Haskell libraries, but it has nothing to do with the typing system. it has to do with how expressions are evaluated (strict vs. lazy)
16:33:31 <kakashiAL> hololeap: strict (I tell it) vs lazy (I let the compiler figure it out)
16:33:40 <hololeap> no
16:34:10 <hololeap> https://wiki.haskell.org/Lazy_evaluation
16:34:19 <hololeap> haskell uses lazy evaluation by default
16:34:54 <kakashiAL> hololeap: ahh okay, lazy evaluation (do as much as you need, after that stop it)
16:34:56 <pikajude> why doesn't haskell.compiler.${compiler}.overrideScope (...) do anything?
16:35:01 <pikajude> i thought overrideScope worked on all haskell packages
16:35:05 <pikajude> are the compiler derivations different somehow
16:35:17 <hololeap> right, that's why people are saying to use "strongly typed" rather than "strictly typed" to avoid confusion
16:35:21 <yushyin> hololeap: I would prefer the term 'eager' it is less overused than 'strict'
16:35:58 <hololeap> yushyin: yeah, but most "eager" libraries are named Something.Strict
16:37:02 <EvanR> strong types an weak types are ill defined loaded weasel words
16:37:16 <EvanR> i havent heard strictly typed
16:37:33 <EvanR> haskell is statically typed
16:37:45 <Welkin> statically typed is just "typed"
16:37:51 <Welkin> non-statically typed is "untyped"
16:38:09 <EvanR> im not sure thats a solid opinion
16:38:18 <kakashiAL> Welkin: I agree: if you tell the input is an Int it will crash if you pass something else
16:38:30 <kakashiAL> Welkin: I guess I get you
16:38:49 <EvanR> dynamic typing is surely talking about a different kind of "typing"
16:38:51 <kakashiAL> Welkin: but understand me, I only have google and wikipedia
16:39:00 <EvanR> but its not untyped
16:39:38 <Welkin> there is no difference between a type system with one and only one type, and a non-existent type system
16:39:42 <Welkin> they are equivalent
16:40:08 <EvanR> consider the difference between assembly language and python
16:40:35 <EvanR> assembly language will do whatever you say, python will crash on a failed implicit runtime check
16:40:57 <Chadtech> Hey Im kind of a haskell scrub, and I am trying to figure out stack. I need to install the package "Flow", but I cant figure out how. I keep doing "stack install flow" and it completes with no error, but after that "stack build" still leads to the error "Could not find module Flow".
16:41:08 <Chadtech> Can anyone help me out with my problem?
16:41:10 <EvanR> you cant throw everyone elses terminology out the window from across the terminology divide
16:41:19 <kadoban> Chadtech: Do you have a .cabal file or a package.yaml for this project?
16:41:28 <Chadtech> Yes, both.
16:41:59 <hololeap> cabal install flow ?
16:42:00 <kadoban> Chadtech: Modify the package.yaml file and add the package you want to the dependencies. Is Flow the name of the package though, or of the module? They're usually different.
16:42:20 <kadoban> cabal install is not going to help you with stack, ignore that one.
16:42:26 <Chadtech> Im trying to install this one: https://hackage.haskell.org/package/flow
16:42:57 <kadoban> Ah okay, yeah 'flow' is the name of the package then. That's the one that goes in the package.yaml in dependencies. Note that it's case sensitive, Flow is different
16:43:22 <Chadtech> Oh cool! Adding "- flow" to the dependencies just worked.
16:43:24 <Chadtech> Awesome.
16:43:31 <kadoban> Nice
16:43:45 <Chadtech> Thank you! So I dont need the cabal file at all then?
16:44:44 <kadoban> 'welcome. The .cabal file is generated from the package.yaml, so you should edit the package.yaml and just ignore the other. (If you really want to you can do the .cabal file instead manually, but then you should delete the package.yaml file)
16:44:57 <glguy_> There cabal file is what defines your project structure, the package.yaml is an extra optional layer for generating the cabal file
16:45:08 <ski> (EvanR : "python will crash on a failed implicit runtime check" -- which is what the "strongly typed" term is meant to capture, i believe)
16:45:09 <kadoban> Most people like the syntax of package.yaml better, it's really not hugely different though.
16:45:23 <glguy_> No, not most, the stack authors
16:45:37 * ski agrees about "different [notion] of \"typing\""
16:46:01 <kadoban> glguy_: Sorry I didn't poll everyone. I know like 5 people who use haskell and 4 of them use hpack *shrug*
16:46:31 <glguy_> I work with a lot more than that and it goes the other way
16:46:36 <EvanR> ski: but... C wont crash, so its strongly typed? it makes no sense
16:46:36 <Chadtech> Re .cabal and package.yaml: ah okay. That makes sense. Thanks again.
16:47:18 <ski> EvanR : surely the static checking in C will let programs slip through which invoke UB
16:47:34 <EvanR> it doesnt do the implicit checks
16:47:39 <ski> exactly
16:47:54 <ski> so, not "strongly typed"
16:47:56 <EvanR> so which of haskell python C and asm are strongly typed
16:48:19 <ski> Haskell,Python
16:48:26 <EvanR> ?_?
16:48:33 <EvanR> well i clearly dont understand the terminology
16:48:52 <Rembane> Isn't that about type coercion rather than anything else?
16:49:07 <EvanR> this elephant feels like a hippopotamus
16:49:11 <Rembane> And implicity type coercions.
16:49:14 <yoho> runtime checks are still part of typing
16:49:24 <yoho> python is dynamic and duck typed, but it's still strongly typed
16:49:26 <Rembane> The glorios hippophant!
16:49:36 <Rembane> yoho: What makes it strongly typed?
16:49:57 <yoho> it can fail at runtime if you try to treat something as the wrong type
16:50:05 <EvanR> strongly typed is a failure for having a variety of meanings or only a vague emotional meaning depending on the circumstances
16:50:15 <yoho> I'm not familiar enough with python to give you a specific example though I'm afraid
16:50:36 <EvanR> strong = somthing good, weak = something bad
16:50:40 <hololeap> (and yet, a hippogryph is not a mix of a hippo and a gryphon?)
16:50:54 <yoho> not at all, some people much prefer weak typing
16:50:56 <ski> in Python, the implementation determines when the program goes "wrong" (in the operational semantical sense)
16:50:59 <Rembane> I want a derply typed programming language!
16:51:08 <yoho> gives you more liberty to do funky stuff even if it gives you less safety
16:51:11 <Rembane> ski: As in throws an exception?
16:51:11 <EvanR> what about weak type (whatever this is) would be preferable?
16:51:28 <Rembane> EvanR: Duck typing makes prototyping a breeze.
16:51:35 <Rembane> EvanR: And then things go boom thre months later.
16:51:36 <ski> in Haskell, the type system prevents situation which would have caused the implementation to approach "wrong" situations
16:51:38 <yoho> duck typing /= weak typing
16:51:46 <EvanR> Rembane: we were just discovering how that is considered strong after all
16:52:02 <Rembane> EvanR: Oh. Ach.
16:52:03 <yoho> weak typing makes heterogeneous data structures trivial to implement
16:52:08 <EvanR> so python is string, and haskell is superstrong ?
16:52:10 <EvanR> strong*
16:52:28 <yoho> there are extremely general structures in C based around void pointers that you just couldn't do in many other languages
16:52:31 <ski> Rembane : as in what would never be attempted in Haskell, because the program would be caught already in a type error
16:52:43 <yoho> not without some real fuckery anyway, you can do the same in Java with some effort
16:53:01 <yoho> EvanR: I don't think anyone would complain if you said Haskell was more strongly typed than python
16:53:01 <EvanR> or haskell with some effort
16:53:01 <Rembane> EvanR: I think I will get back to this conversation in 10 years or so and hope that people have got a good terminology for it then.
16:53:10 <Rembane> ski: Okay.
16:53:21 <ski> afaiu, "duck typing" means roughly that we intend structural typing of objects ?
16:53:21 <yoho> but the real distinction there though is that Haskell's statically typed and does a lot at compile time
16:53:24 <EvanR> yoho: so we go from ill defined vague, to a hierarchy of ill defined vague things
16:53:35 <ski> (like OCaml does)
16:53:49 <yoho> if you're looking for a strict definition of strong vs weak typing you're not going to get it
16:54:05 <EvanR> any definition that people expected
16:54:11 <EvanR> otherwise wtf
16:54:32 <yoho> https://en.wikipedia.org/wiki/Strong_and_weak_typing
16:54:36 <yoho> it's plenty defined there
16:54:36 <ski> yoho : do you mean structures in C, which in a more modern language would be expressed in terms of existential and universal quantification ?
16:54:39 <EvanR> just now i got two contradicting implications from it
16:55:00 <yoho> ski: I mean the general ability to do whatever you want with void*
16:55:04 * Rembane hands out bottom.
16:55:06 <ski> yoho : at least that seems to be a pretty common use of `void *' in C
16:55:14 <yoho> a nice big gaping hole in the type system
16:55:21 <ski> yoho : yes, but what, in *practice*, do one actually tend to do, with it ?
16:55:36 <EvanR> applications of void* seem to always utilize tag fields, like sum types
16:55:56 <EvanR> or the existential "userdata" thing
16:55:57 <yoho> they can, but don't have to
16:56:12 <yoho> that information can be implicit
16:56:36 <EvanR> if theres a probability less than 100% that the thing on the other end of void* is something else, its broken
16:56:43 <yoho> but lets me provide you with an API for a dynamically resizing array that can hold whatever you like (so long as you either give me a pointer to it or it can fit into the space of a pointer)
16:56:44 <EvanR> without more info
16:57:09 * ski . o O ( `data a -> b = forall x. Clos# (# x , (# x , a #) #-> b #)' )
16:57:56 <yoho> EvanR: I missed the part where I specified that this was safe
16:58:22 <yoho> ski: not sure what that is
16:58:46 <EvanR> i assumed youd be doing things not allowed by haskell but that actually make sense
16:58:59 <EvanR> rather than be logically incorrect
16:59:31 <EvanR> difference between unsafe and known wrong
16:59:53 <yoho> I'm also not sure what point either of you are arguing at this point
17:00:14 <yoho> you seem to have diverged from your confusion about what constitutes weak/strong typing into a debate of the merits of one or the other
17:01:07 <EvanR> strong/weak is bad untechnical terminology. how is weak typing good
17:01:13 <EvanR> assuming it is even anything
17:01:44 <yoho> I hate weak typing so really you're asking the wrong person here
17:01:44 <EvanR> though given my first point, continuing would be silly
17:02:05 <EvanR> i was asking you because you implied there was a benefit, so nevermind
17:02:55 <yoho> as for the first point, no it's not formalised but if you look at the wikipedia page I linked you'll see the "Variation across programming languages" section has some pretty clearly distinguished ones with justifications
17:03:15 <yoho> and at the end of that section specify that it's obviously not an unambiguous term
17:04:15 <yoho> and the benefit I'm pointing to in the case of C is that it's much easier to write extremely general (but unsafe, so you have to be careful) things with weak type systems
17:04:57 <EvanR> whats an example of something that isnt borked that you can do with that that is not allowed by haskell
17:05:10 <yoho> "that isn't borked"
17:05:18 <yoho> I think you're missing the point
17:05:32 <EvanR> youre trying to make something that is borked?
17:05:39 <yoho> these things aren't broken as long as you're careful with them, which is the whole point of that tradeoff
17:05:44 <EvanR> thats allowed do
17:05:50 <EvanR> thats what im asking
17:05:54 <yoho> they're easy to make, riskier to use, but fine if you're careful with them
17:05:58 <EvanR> like what
17:06:14 <yoho> jesus man how many times do I have to repeat myself
17:06:19 <EvanR> o_O
17:06:57 <EvanR> array of "something"
17:07:06 <EvanR> ?
17:07:37 <EvanR> i must have missed the actual answer
17:07:42 <yoho> array of "something", or the entire pthreads model
17:07:56 <EvanR> haskell has array of something
17:08:00 <yoho> yes
17:08:08 <yoho> with a stronger type system and much more complex compiler
17:08:29 <yoho> s/stronger/much more complicated/
17:12:07 <ski> yoho : it's just supposed to hint that we can think of the type `a -> b' as being implemented by the type `exists x. (# x , (# x , a #) #-> b #)'. `(# .. , .. #)' is unboxed pair (typically stored in separate registers, or separate memory locations, e.g. stack). and `a #-> b' is the "top-level function type", what in C would be `b_t (*)(a_t)', iow corresponding to just a function pointer (a memory address), without a closure environment (or record containin
17:12:21 <ski> (er, cut off near ".., iow corresponding to just a function pointer (a memory address), without a closure environment (or record containing instance variables, in OO)")
17:19:04 <yoho> I'm not following this enough to understand the relevance...
17:19:17 <ski> (logically, `a #-> b' is similar to ⌜a ⥽ b⌝, Lewis' strict implication <https://en.wikipedia.org/wiki/Strict_conditional>, which modally can be understood as ⌜◻ (a → b)⌝, the "necessary" modal operator ⌜◻⌝ expressing that the function doesn't depend on anything, except "necessary" (global scope) things. iow it doesn't depend on local assumptions/arguments, but may depend on global identifiers, e.g. in libraries)
17:19:18 <yoho> Also, what's the significance of the x there?
17:19:40 <ski> `x' is the type of the environment, captured by the closure
17:20:39 <ski> in C, `exists x. (# x , (# x , a #) #-> b #)' would be `struct { void *env; b_t (*fun)(void *end,a_t arg); }'
17:21:11 <erisco> didn't you look at your calendar? unboxing the presents is over… everything got boxed again on boxing day. At least I think that is what that day is for…
17:21:35 <yoho> erisco: It's called St Stephen's day where I'm from, so I guess we're going high performance forever
17:21:45 <dukedave> Anyone familiar with this? https://docs.haskellstack.org/en/stable/docker_integration/#derivative-image
17:22:53 <ski> in a variant of C with existential quantification (see BitC, Cyclone, and compare with ATS), it might look like `struct { typename T; T *env; b_t (*fun)(T *end,a_t arg); }', expressing exactly that the type of the `struct' component `env' must match the first argument of `*fun'
17:22:58 <ski> (s/end/env/)
17:24:13 <yoho> right
17:24:39 <yoho> you can certainly improve upon the implementation of these things at the cost of some more complexity (or a lot more, see: C++)
17:24:53 <ski> (the `T' component of course would take up zero bits at run-time, only serving to be able to declare that there is some local/hidden/abstract/opaque/forgotten type `T', and to be able to declare which other type parts of the other components is this type `T')
17:25:28 <yoho> you say it'd take up zero bits, but Java would beg to differ :P
17:25:38 <yoho> (no erasure for you!)
17:25:57 <ski> yea, i'm talking about a "parametric" existential here, that would behave uniformly (as opposed to how C++'s templates (which can encode universal quantification) can behave, wrt type parameters)
17:26:24 <ski> well, this wouldn't be Java :)
17:28:03 <yoho> but yeah, as I stated earlier I'm personally very much against weak typing in all forms - there are better ways to do the same things
17:28:28 <yoho> but as I also said it tends to raise the complexity of your system as a whole, which is the main tradeoff
17:28:28 * ski . o O ( <https://en.wikipedia.org/wiki/Typed_assembly_language> )
17:28:41 <yoho> (this complexity doesn't have to be exposed to the user)
17:30:42 <yoho> that's pretty neat
17:31:30 <MuNuFix> ski: Thank you for your time today and I am going back to re-reading the definition you have provided on Mu.
17:31:39 <MuNuFix> ski: Thank you for your time today and I am going back to re-reading the definition you have provided on Mu.
17:32:04 <ski> there's also the logical interpretation of the function type (iow implication) ⌜a → b⌝ as ⌜¬ (a ∧ ¬b)⌝
17:32:32 <ski> (⌜a ∧ b⌝ is the product/tuple ("struct") type)
17:32:50 <ski> (logically, conjunction)
17:34:03 <ski> ⌜¬ a⌝ (logically, negation) being the type of *continuations* which accept an input of type ⌜a⌝. if we ignore the closure aspect, this is just a memory address to which we can jump, after having placed an argument of type ⌜a⌝ in a designated location (according to some calling^Wjumpting convention)
17:34:12 <yoho> any reason you're preferring the de morgan version of the usual !a || b ? (you'll have to excuse my lack of fancy symbols)
17:34:19 <ski> (and this isn't a subroutine call (in general), there is no "return")
17:35:48 <ski> yes, because it's not clear how to cmoputationally encode ⌜¬ a ∨ b⌝ here. the disjunction here would probably have to be something like the multiplicative disjunction ("both .. *or* ..") of linear logic, which has flavours of concurrency
17:36:41 <ski> however, a value of type ⌜¬ (a ∧ ¬b)⌝ is an address which we can jump to, after having placed a value of type ⌜a⌝, and a (return) address which accepts a value of type ⌜b⌝, in designated places
17:36:43 <yoho> that makes sense yeah
17:36:59 <ski> which is what a `jsr' instruction would tend to do
17:38:06 <yoho> ski++
17:38:20 <yoho> dunno if that bot's still around but I appreciate the lengthy explanations nonetheless
17:40:01 <ski> (fwiw, in SML/NJ, you can register a timer interrupt, whose handler will be passed an argument of type ⌜¬ ⊤⌝ (`unit cont' in SML syntax, could be something like `Label ()' in Haskell syntax), and which is supposed to return a result of the same type (and during the handler evaluation, timer interrupts are disabled)
17:41:21 <ski> .. the continuation that it gets as argument is the point in the program where evaluation was interrupted. the continuation that is returned by the handler is the point at which evaluation will resume. it's not that hard to store a queue of several such, to implement time-sharing)
17:42:37 <yoho> SML/NJ?
17:42:48 <robertkennedy> Should I ever worry about the difference between <> and, say, +, given that the function using them is monomorphic and I compile with O2? It seems like much of the lore mentions Dict unpacking as the root of all evil.
17:43:04 <yoho> also this is giving me flashbacks to exams where I had to implemenent pre-emptive threading in ARM ASM
17:43:10 <yoho> damn you ski
17:43:29 <ski> "Standard ML of New Jersey", <http://www.smlnj.org/>
17:44:30 <erisco> robertkennedy, well, both <> and + involve dicts, so the poison is the same :)
17:45:17 <EvanR> when used at a known type the implementation can be inlined
17:45:21 <erisco> if you care about the performance, look at the Core, and if you don't then don't bother yourself over it
17:45:38 <hydraz> ski: aren't continuations generally typed as ’¬¬A’, or am I missing something here?
17:46:06 <erisco> the worst of both worlds is to have more rules than thumbs, never being sure if it is working like you need or not
17:46:55 <ski> (see <http://www.smlnj.org/doc/SMLofNJ/pages/signals.html>,<http://www.smlnj.org/doc/SMLofNJ/pages/interval-timer.html>,<http://www.smlnj.org/doc/SMLofNJ/pages/cont.html> .. also i think MLton <http://www.mlton.org/> has support for continuations)
17:47:02 <ski> hydraz : nope
17:47:30 <erisco> I was particularly interested in GHC eliding list constructors, so I looked at Core to figure out if it was actually happening
17:47:36 <ski> hydraz : `Cont Void a' corresponds to ⌜¬ ¬ a⌝
17:47:41 <erisco> turns out it wasn't! and so I used Church lists instead, and then all was well
17:47:53 <robertkennedy> I guess + was a bad example; `mappend ~ Map.unionWith f` is the better approximation
17:48:07 <erisco> that uses Ord
17:48:54 <ski> hydraz : it's not the value of type `Cont Void a' (or `Cont o a', in general) that is the continuation
17:48:57 <ski> @type callCC
17:48:58 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
17:49:05 <robertkennedy> Not if the key is monomorphic (he says, hopefully)
17:49:30 <ski> it's the callback argument of type `a -> m b' which is the continuation
17:49:45 <EvanR> hmm, but the code for Map was already compiled
17:50:11 <erisco> :t M.unionWith
17:50:12 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
17:50:20 <erisco> I see Ord, do you?
17:50:33 <ski> hydraz : in the `Cont o a' case, the continuation has type `a -> Cont o a', or really just `a -> o' would suffice (`a -> Void', with `o = Void')
17:50:40 <hydraz> hmm, this paper says "But CPS translation converts source (terms and) values into computations of type (A → ⊥) → ⊥"
17:50:46 <hydraz> (https://www.williamjbowman.com/resources/cps-sigma.pdf)
17:51:04 <ski> @djinn ((a -> Void) -> Void) -> (a -> (b -> Void) -> Void) -> ((b -> Void) -> Void)
17:51:04 <lambdabot> f a b c = void (a (\ d -> void (b d c)))
17:51:24 <ski> @djinn-add type NotNot a = Not (Not a)  -- note that `type Not a = a -> Void'
17:51:24 <lambdabot> Cannot parse command
17:51:31 <ski> @djinn-add type NotNot a = Not (Not a)
17:51:45 <ski> @djinn NotNot a -> (a -> NotNot b) -> NotNot b
17:51:46 <lambdabot> f a b c = void (a (\ d -> void (b d c)))
17:51:49 <erisco> Djinn needs to say "Your wish is my command!" followed by the answer…
17:51:50 <ski> `NotNot' is a monad
17:52:21 <robertkennedy> Right... But you see that if ie you have `newtype C a = C (Map Char a)` that I might hope an implemention of `Monoid (C a)` would inline Ord for mappend.
17:53:23 <ski> replacing `Void' by a parameter `o' corresponds to changing the logic from intuitionistic logic, to so-called "minimal logic". the difference is that while we have `Void -> a' for every `a', we don't have `o -> a'. no "collapse". and hence `o' can be an informational type, like `Bool' or `IO ()'
17:54:19 <ski> (above, `void' has type `forall a. Void -> a')
17:54:28 <erisco> Not not! Who's there? Not not not not. Not not not not who? Not not not not not not.
17:54:44 <ski> (though in fact, Djinn doesn't need to use `void' there at all)
17:56:00 <ski> "The contradiction of a contradiction of a contradiction is equivalent to the plain contradiction." -- ~Brouwer
17:56:20 <ski> @djinn Not (Not (Not a)) -> Not a
17:56:20 <lambdabot> f a b = void (a (\ c -> c b))
17:56:24 <EvanR> contradiction oriented programming
17:56:26 <ski> @djinn Not a -> Not (Not (Not a))
17:56:26 <lambdabot> f a b = void (b a)
17:56:38 <ski> @where Io
17:56:38 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
17:56:38 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
17:56:48 <ski> is a language based on continuations
17:59:54 <JazzyEagle> Hey, all.  I have some time now to look into an issue.  I posted this earlier, then I had wifi issues and have no clue if any one responded, so I'm going to repost...
17:59:59 <JazzyEagle> 'm working on creating a little demo thing just to ensure I understand how to use it.  I pushed what I have so far to https://notabug.org/jazzyeagle/haskell-backpack-demo
18:00:04 <JazzyEagle> But I'm getting an error... http://lpaste.net/983416784864411648
18:00:19 <JazzyEagle> It appears the necessary lib is building properly, but it's not able to link, and I'm not sure what I'm doing wrong.
18:00:27 <JazzyEagle> Knowing my luck, my issue may not have to do with Backpack; I may doing something wrong with the .cabal file and just not realizing it.
18:02:32 <ski> chapter 2, section 3 of "Advanced Programming Language Design" by Raphael Finkel in 1996 at <https://web.archive.org/web/20150522052725/http://www.nondot.org:80/sabre/Mirrored/AdvProgLangDesign/> has some explanations of Io
18:02:42 <ski> (section 4 is also a bit interesting)
18:03:35 <Koterpillar> I'd like to get a snapshot like the picture from https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/profiling.html#profiling-memory-usage from a running program, over the network. Is there a tool even remotely like that? Any pointers would be very much appreciated.
18:05:26 <geekosaur> Koterpillar, that's just using hp2ps, then ps2pdf
18:05:45 <geekosaur> hm, or similar. ghostscript can also render ps (or pdf) to a graphics image
18:06:12 <geekosaur> it's not capturing an image generated live
18:06:47 <geekosaur> (you can capture images like that, sort of; scrot is one way to do it with X11)
18:07:33 <Koterpillar> geekosaur: I want the _data_ for that picture
18:07:42 <Koterpillar> the actual heap profile
18:07:58 <geekosaur> afaik you can't capture live snapshots of the data
18:08:44 <geekosaur> heap profile is saved on program exit, and is missing pieces before then even if something was logged. event log/viewer might have something but I think that's mostly the stuff threadscope displays
18:08:57 <geekosaur> snapshot profiling is a known shortcoming of ghc
18:09:49 <Koterpillar> thank you
18:10:13 <Koterpillar> was a long shot, we've ran into what I think is a Warp bug and wanted to future-proof against this kind of thing
18:17:22 <JazzyEagle> No one has an idea?  :(
18:20:10 <geekosaur> JazzyEagle, you need a custom-setup stanza declaring the dependency, or stack wont expose it
18:20:35 <geekosaur> only thing I can think of
18:21:09 <geekosaur> and if you stack is old enough then it won't understand or use custom-setup
18:22:39 <JazzyEagle> stack is 1.6.1.1
18:23:21 <JazzyEagle> I'm not familiar with custom-setup.  I'll look into it.  Thanks.
18:24:16 <geekosaur> there's a problem with building a custom Setup.hs; it can;t use the package dependencies, because running Setup.hs is needed to complete those dependencies (it can output possibly essential extra dependencies form 'Setup configure')
18:24:38 <geekosaur> (the gi bindings to gtk depend on this, for example)
18:25:10 <geekosaur> so recent cabal and stack support a custom-setup mechanism to specify the dependencies that Setup itself needs
18:25:24 <geekosaur> without that, it asumes a simpel default Setup,hs that depends only on base and Cabal
18:25:54 <geekosaur> which means things like your custom package can't be used, and stack in particular hides the package that it had just built
18:27:10 <JazzyEagle> geekosaur: Do you think if I just add in a Setup.hs file, it'll work?  I didn't intend to omit the Setup.hs file, but I've done a bunch of reorganization and apparently forgot to add it to that particular directory.
18:27:34 <geekosaur> now I am trying to understand how you understood what I said
18:27:40 <geekosaur> or what the error message said, for that matter
18:27:50 <geekosaur> it *has* a Setup.hs (or Setup.lhs)
18:28:10 <geekosaur> it recognizes it as a 'custom' one (that is, something more complex than a default invocation of the Cabal library)
18:28:43 <geekosaur> and it depends on the str-indef library
18:29:01 <geekosaur> but stack is *hiding* str-indef, so building/running that Setup.hs fails
18:29:28 <geekosaur> because there is no custom-setup stanza in the cabal file telling it that Setup.hs requires that library, so the only libraries exposed are base and Cabal
18:30:53 <monochrom> "str-indef" looks like using Backpack. But I be damned if mere Setup.hs already uses that much abstraction!
18:31:59 <JazzyEagle> monochrom: Keep in mind that I'm merely trying to figure out how to use it.  This is disposable code just to understand how to put the pieces together.
18:32:23 <JazzyEagle> geekosaur: The only Setup.hs I find is labeled Setup.hs.old, and it's not under the executable directory, it's under one of the libs.
18:32:51 <geekosaur> well, it is building a Setup.hs so it apparently got one from somewhere
18:32:53 <JazzyEagle> There is no actual Setup.hs file in the entirety of the project (currently).  Not sure why stack is hiding str-indef.  custom-setup is the only way to expose it?
18:33:04 <geekosaur> to a Setup.hs, yes
18:33:35 <geekosaur> and, regardless of whether one is thereor not, one *is* needed and may be being generated by Backpack or something. but iut still needs to tell the build tool that it needs to expose that library
18:33:54 <geekosaur> the whole point of stack is it hides anything not explicitly required
18:34:15 <MarcelineVQ> JazzyEagle: https://notabug.org/jazzyeagle/haskell-backpack-demo doesn't look like a public repo
18:34:31 <geekosaur> and in particular when building Setup it only exposes base and Cabal unless told by a custom-setup to expose more
18:34:34 <monochrom> Yeah it's a 404
18:35:01 <JazzyEagle> Ahhh, let me make it public.
18:35:38 <JazzyEagle> Ok, go ahead and try again.
18:36:09 <JazzyEagle> Sorry, I thought that setting just meant that the repo wouldn't be listed in the project lists on notabug.  I didn't realize it prevented anyone to access it, even if they had a link.
18:37:50 <monochrom> Does stack actually know Backpack?
18:38:07 <MarcelineVQ> I'm on stack 1.7.0 and your project builds for me as-is
18:38:11 <JazzyEagle> lts-10.0 has Cabal 2.0, so sort of yes.  :)
18:38:26 <JazzyEagle> stack 1.7.0?  Maybe I should try to upgrade, then.
18:38:30 <monochrom> Because don't give me "stack just calls up cabal no?" because even if you call up cabal directly cabal default doesn't know Backpack either.
18:39:14 <monochrom> Even with cabal you have to explicitly manually emphatically say "cabal new-build" in order to get it into Backpack-knowing mode.
18:39:23 <JazzyEagle> monochrom: I am by no means anywhere near close to a Haskell guru.  I learn by fumbling, coming up with issues, and then asking questions.  :)
18:41:15 <MarcelineVQ> oop, actually it is failing, but with quite a different error so it looked okay at first hoho
18:41:36 <geekosaur> and stack doesn;t use cabal(-install) anyway, except in "stack solver". it uses the Cabal library --- as does cabal-install, and ghc itself, and ghc-pkg, etc.
18:41:50 <JazzyEagle> Hrmm...  1.7.0 didn't seem to be available to me, either by distro upgrade (Parabola) nor by stack upgrade (1.6.3)
18:42:01 <MarcelineVQ> 1.7.0 is stack upgrade --git
18:42:10 <JazzyEagle> Ahhh...
18:42:32 <MarcelineVQ> but it didn't actually work, it just had a unforunately easy to miss error
18:43:29 <monochrom> I actually have a good reason to bet that stack is not going to support Backpack any time soon.
18:43:54 <monochrom> Because the way stack wants to own your package is in conflict with the way cabal new-build wants to own Backpack packages.
18:43:55 <JazzyEagle> Ok, stack upgrade --git seems to be bringing me back to lts-9.14 and ghc-8.0.2...
18:44:01 <JazzyEagle> I don't know if Backpack can work on that.
18:44:53 <monochrom> And yes you have a trialectic class struggle between your linux distro, stack, and cabal. They all want monopoly on you.
18:44:59 <Koterpillar> geekosaur: according to https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#viewing-the-heap-profile-of-a-running-program, the heap profile is generated incrementally...
18:45:09 <JazzyEagle> It is possible.  I may need to try to use cabal new-build directly.  I thought I tried that before, but I'm not very familiar with cabal directly.  I started with Haskell not long before the project I was learning for switched to stack.
18:45:20 <kadoban> JazzyEagle: The lts and GHC that stack builds itself with doesn't affect anything else
18:45:23 <MarcelineVQ> It's using those to build stack, it won't have a bearing on your project.
18:45:35 <JazzyEagle> Ahhh, ok.
18:45:41 <JazzyEagle> Good to know.
18:48:04 * JazzyEagle is waiting for the new stack version to install, and will see what's going on.
18:48:16 <JazzyEagle> If that doesn't work, I'll try working w/ cabal new-build
18:48:23 <JazzyEagle> Thanks, everyone.
18:51:54 <linux_girl> hello all
18:53:30 <lambdabot> Hello.
18:54:05 <Welkin> lambdabot: hello
18:56:49 <Average-user> hi
18:56:53 <Forty-Bot> where can I find a function like [a->b] -> m a -> [m b] ?
18:57:05 <Forty-Bot> I tried searching with hoogle, but I didn't find anything
18:57:15 <MarcelineVQ> JazzyEagle: https://github.com/commercialhaskell/stack/issues/2540
18:57:29 <Forty-Bot> actually, just [a->b] -> [a] -> [[b]] will work
18:57:33 * lambdabot waves
18:58:19 <ski> @type \fs ma -> map (<$> ma) fs
18:58:20 <lambdabot> Functor f => [a -> b] -> f a -> [f b]
18:58:36 <Forty-Bot> thanks
18:58:59 <ski> linux_girl : if you have a (Haskell-related) question, ask
18:59:32 <linux_girl> I want to learn haskell
18:59:36 <linux_girl> but very hard
18:59:50 <linux_girl> so I was just hanging out to see if I can get some ideas
18:59:59 <ski> perhaps you should get a textbook, or at least look as some tutorial
18:59:59 <Welkin> is this some kind of fetish?
19:00:00 <linux_girl> I know python and runy
19:00:13 <linux_girl> ruby
19:00:17 <ski> @where CIS194
19:00:18 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
19:00:24 <ski> you could look at that ^
19:00:36 <vaibhavsagar> linux_girl: which aspect of learning Haskell are you having trouble with?
19:00:56 <Welkin> the whole thing
19:00:58 <Welkin> all of it
19:01:17 <ski> some people think
19:01:20 <ski> @where LYAH
19:01:20 <lambdabot> http://www.learnyouahaskell.com/
19:01:20 <linux_girl> just the functional thing
19:01:22 <linux_girl> i guess
19:01:34 <linux_girl> I mean its so weird to me I tried
19:01:35 <vaibhavsagar> which aspect of the functional thing?
19:01:40 <linux_girl> 10 videos from a tutorial
19:01:45 <linux_girl> also Im horrible in maths
19:01:53 <vaibhavsagar> Python has first-class functions
19:01:56 <ski> looks fun and shiny. perhaps you could give it a glance. however, people here tend to be of the opinion that LYAH doesn't give much in the way of deeper understanding
19:02:26 <vaibhavsagar> linux_girl: you don't need to learn maths before learning Haskell
19:02:52 <monochrom> If you have difficulty with functional thinking, then you need a book that really goes over functional thinking. And so far all such books cost money.
19:03:03 <ski> linux_girl : you should be aware of the fact that learning a new programming paradigm will be a little bit like learning to program from scratch again. so it's more demanding than learning yet another programming language that is similar to one you already know -- but it's also more rewarding
19:03:06 <MarcelineVQ> knowing highschool algebra will get you most of where you'll want to go
19:03:17 <Welkin> the only reason people get caught up on the "functional" aspect of haskell or any functional language is *only* because they have ingrained in their mind that "programming" is about mutating state and using loops and conditionals
19:03:31 <monochrom> They are: "Thinking Functionally with/in Haskell" by Bird, and "Programming in Haskell" by Hutton.
19:03:33 <Welkin> for someone with zero programming background, there should be no issue
19:03:59 <linux_girl> got it
19:04:14 <linux_girl> so what is Haskell mostly used for?
19:04:14 <Welkin> they try to write c/java/python/whatever in haskell instead of writing haskell in haskell
19:04:17 <Welkin> too bad
19:04:20 <Welkin> anything
19:04:28 <Welkin> web development, compilers, AI, games
19:04:40 <vaibhavsagar> linux_girl: do you have an example of something you want to accomplish that would be easy in Python/Ruby but you're finding difficult in Haskell
19:04:42 <linux_girl> is it compiled or interpreted?
19:04:47 <vaibhavsagar> both
19:04:49 <Welkin> both
19:05:13 <linux_girl> for now I am just learning data wrangling in python
19:05:22 <linux_girl> with libraries like pandas, seaborn
19:05:34 <linux_girl> also script some basic stuff with ruby and python
19:05:42 <linux_girl> for things like chef and puppet
19:05:44 <linux_girl> and ansible
19:05:56 <vaibhavsagar> devops and data science, very nice
19:06:18 <linux_girl> trying in both
19:06:25 <linux_girl> nothing concrete
19:07:23 <vaibhavsagar> so you want to do data science and devops in Haskell?
19:07:33 <Welkin> well, those are the fads today
19:07:33 <vaibhavsagar> just to see how things work?
19:07:54 <vaibhavsagar> can confirm, am currently slacking at work instead of doing all the devops
19:07:58 <Welkin> data science is not a specialty of haskell
19:08:10 <vaibhavsagar> yes, the library support is not there yet
19:08:13 <Welkin> haskell has some nice devops tools though
19:08:17 <Welkin> then there is nix, of course
19:08:28 <vaibhavsagar> sure, but that has nothing to do with Haskell
19:08:33 <Welkin> but it is ideal for web servers
19:08:52 <linux_girl> I want to learn what I can in haskell
19:08:58 <Welkin> keter is awesome for deploying apps
19:09:11 <linux_girl> everyone suggests learning haskell to broaden the mind
19:09:16 <vaibhavsagar> linux_girl: do you have a Python/Ruby project you could try to rewrite in Haskell
19:09:29 <vaibhavsagar> I definitely feel like my mind has been broadened by learning Haskell
19:09:36 <vaibhavsagar> I also come from a Python background
19:09:45 <linux_girl> i just wanted to learn some functional programming before I turn 18 next March
19:09:54 <linux_girl> so I have ~4 months
19:10:15 <vaibhavsagar> that seems like a somewhat arbitrary deadline, but okay
19:10:23 <Welkin> I use haskell mainly for web development and some games
19:11:12 <linux_girl> thats pretty awesome
19:11:32 <vaibhavsagar> linux_girl: if you can afford it, I've heard good things about http://haskellbook.com/
19:11:34 <Welkin> you can also compile it to javascript
19:11:37 <Welkin> to run it in the browser
19:11:47 <loli> haskellbook was rather good, it was how I learned
19:12:09 <MuNuFix> A +1 for haskellbook.
19:12:14 <Welkin> loli: are you aware of the meaning of your name?
19:12:22 <loli> what do you mean?
19:12:28 <linux_girl> i don't have any monies but I might ask my parents for some money to buy book
19:12:29 <loli> there are many meanings to any name
19:12:32 <Welkin> loli -> lolita
19:12:39 <loli> yes what about lolita
19:12:58 <monochrom> MuNuFix owns both mu and nu :)
19:13:32 <MuNuFix> monochrom I was reading through recursive schemes library and it got stuck in my head
19:13:50 <MuNuFix> Now I am like Mu..Nu ..Mu.. :D
19:14:21 <MuNuFix> Was bothering :ski sometime ago here.
19:15:35 * ski . o O ( "Everbody says, lambda, lambda, lambda. So I did it. So I did it." -- from "Lambda Lambda Lambda" (1990) by Simon Peyton Jones )
19:15:38 <linux_girl> Any ways thank you guys I will take a look at these books and report back. Hope to see yall soon!
19:15:47 <linux_girl> Thank you!
19:15:51 <ski> you're welcome
19:16:32 <MuNuFix> ski I think I dropped off when you asked me for the inverse of flipcata.
19:16:47 <MuNuFix> I dont think I got that correct.
19:18:57 * ski . o O ( <http://rationalfiction.io/story/the-unix-koans-of-master-foo> )
19:19:14 <ski> MuNuFix : what have you got ?
19:20:14 <MuNuFix> invFlipCata :: forall f. Functor f => (forall r . (f r -> r) -> r) -> Mu f
19:20:33 <MuNuFix> :t Mu
19:20:34 <lambdabot> error:
19:20:34 <lambdabot>     • Data constructor not in scope: Mu
19:20:34 <lambdabot>     • Perhaps you meant one of these:
19:23:24 * ski . o O ( <http://translatedby.com/you/functional-programming-koans-in-ocaml/original/> )
19:23:36 <ski> @kind Mu
19:23:37 <lambdabot> (* -> *) -> *
19:23:38 <ski> @type In
19:23:38 <Welkin> ski: why always with the thought bubbles?
19:23:38 <lambdabot> f (Mu f) -> Mu f
19:23:51 <ski> why not ?
19:24:09 <ski> MuNuFix : what can you do with the argument ?
19:24:29 <MuNuFix> Which one ?
19:24:49 <ski> (if i'm thinking of something, is the thought bubble inappropriate ?)
19:25:05 <ski> the one of type `forall r . (f r -> r) -> r', the sole argument of `invFlipCata'
19:25:39 <MuNuFix> ski if say type Algebra f a = f a -> a
19:25:54 <MuNuFix> That turns to be Algebra f a -> a
19:25:56 <ski> then `forall r. Algebra f r -> r'
19:26:15 <MuNuFix> It indicates we are evaluating the algebra
19:26:20 <ski> so .. what can you do with this argument ?
19:26:39 <MuNuFix> It is a function , so pass the algebra to it
19:26:50 <MuNuFix> ski So that the function returns an a ?
19:26:54 <ski> it's a function, so you can apply it to some argument
19:27:02 <ski> which is basically the only thing you can do with a function
19:27:26 <ski> the callback function will return a value of a type `r' of your choosing
19:27:32 <ski> which type `r' will you choose ?
19:28:14 <ski> what is the type of the result that you'd like to generate in `invFlipCata' ?
19:28:35 <MuNuFix> `Mu f`
19:28:38 <ski> yes
19:28:49 <ski> could the type `r' be selected to be `Mu f' ?
19:29:04 <ski> or would something else, or something more involved be required ?
19:29:26 <MuNuFix> I cant confidently answer that :(
19:29:56 <ski> well, what if you boldly make a leap of faith, and try the first option, and see whether it appears to lead somewhere
19:29:59 <ski> ?
19:30:11 <ski> what would be the type of the expected argument of the callback, then ?
19:30:17 <MuNuFix> Is there a type `r` in Mu f
19:30:24 <ski> no
19:30:38 <ski> the type that you'd then need to provide a value of, to pass as argument to the callback
19:30:49 <ski> to be concrete, we're talking about this situation :
19:31:08 <ski>   invFlipCata callback = callback ?0
19:31:46 <MuNuFix> ?0 is the algebra
19:31:47 <lambdabot> Maybe you meant: v @ ? .
19:31:53 <ski> where `?0' is a hole that stands for the expression that you'd then need to fill in, passing it to `callback', whose result of type `r', which you have selected as `Mu f', is then returned from `invFlipCata'
19:32:02 <ski> so .. what would the type of `?0' be, here ?
19:32:17 <MuNuFix> Algebra f a
19:32:34 <ski> no, there's no `a' here
19:33:25 <MuNuFix> It would be an Algebra would it not , since the call back expects an Algebra to be provided to it.
19:33:37 <ski> yes .. but more precisely ?
19:33:45 <ski> we know
19:33:57 <ski>   callback :: forall r. (f r -> r) -> r
19:34:01 <ski> which you can also write as
19:34:08 <ski>   callback :: forall r. Algebra f r -> r
19:34:15 <MuNuFix> Yes
19:34:47 <ski> however, if we're calling `callback' in this position in `invFlipCata', that means that we're selecting the type `r' to be .. what again ?
19:36:14 <MuNuFix> I am missing something simple here :(
19:36:52 <ski> what is the type of `invFlipCata callback' ?
19:37:02 <MuNuFix> `Mu f`
19:37:07 <ski> yes
19:37:09 <ski> given
19:37:11 <ski>   invFlipCata callback = callback ?0
19:37:18 <ski> what is the type of `callback ?0' ?
19:37:22 <MuNuFix> Mu f
19:37:25 <ski> yes
19:37:43 <ski> so, what then would be the type of this occurance of `callback' in the body ?
19:39:50 <ski> (the question is similar to : what is the type of (this occurance of) `filter', if the type of `filter ?0 ?1' is `[Integer]', given that we know the general signature to be `filter :: forall a. (a -> Bool) -> [a] -> [a]' ? and furthermore, what is then the type of `?0' and `?1')
19:40:28 <MuNuFix> Integer
19:40:28 <metahumor> the latest ghc-mod package is in the lts-8.24 -- how does using a later lts work with ghc-mod?
19:40:56 <MuNuFix> The type of a is whatever the leaf node of the Mu
19:40:57 <ski> i'm asking you to "reason backwards" here, and also to figure out the instantiated/specialized type of a particular occurance of a polymorphic operation, in some given context
19:41:30 <ski> (the type of that occurance of `filter' is not `Integer', no. nor is the type of `?0' nor `?1' there `Integer')
19:42:10 <ski> the general typing rule of function application says that if
19:42:13 <ski>   f :: A -> B
19:42:14 <ski> and
19:42:16 <MuNuFix> Num a
19:42:16 <ski>   x :: A
19:42:18 <ski> then
19:42:23 <ski>   f x :: B
19:42:34 <MuNuFix> yes
19:42:42 <ski> `f' and `x' can be arbitrary (value) expressions. `A' and `B' can be arbitrary type expressions
19:42:58 <ski> in your case, `f' is `callback', and `x' is `?0'
19:43:13 <ski> we know the type of `f x', iow we know which type `B' is
19:43:23 <ski> we're trying to figure out what type `A' must be
19:43:38 <ski> (that's what i meant by "reason backwards")
19:44:06 <MuNuFix> We are trying to figure out what type is A
19:44:33 <MuNuFix> I know that the entire expression has type Mu f
19:44:34 <ski> what complicates your case slightly is that you don't have a plain `f :: A -> B', but rather a polymorphic `f :: forall r. F a -> G a' (where `F a' and `G a' are arbitrary type expressions that may mention `a' (freely))
19:44:55 <ski> (er, s/a/r/)
19:45:38 <ski> so, you're trying to figure out which concrete type to replace `r' by, so that `G r' becomes equal to `B'. and then figure out what type `F r' then becomes, under that substitution for `f'
19:45:43 <ski> er, for `r'
19:45:59 <ski> that's the situation, abstractly stated
19:46:12 <ski> in terms of your concrete case, we have the polymorphic
19:46:22 <ski>   callback :: forall r. Algebra f r -> r
19:46:23 <ski> or
19:46:28 <ski>    callback :: forall r. (f r -> r) -> r
19:46:42 <ski> and we have
19:46:49 <ski>   callback ?0 :: Mu f
19:47:10 <MuNuFix> And what is the definition of Mu f ?
19:47:11 <ski> so, the result type of the specialized version of `callback' that we're looking for, must be `Mu f'
19:47:16 <ski> so `r' must be `Mu f'
19:47:21 <ski> you already determined this
19:47:37 <ski> (what `Mu f' is exactly doesn't matter at the moment. it's some data type)
19:47:45 <MuNuFix> Oh ok.
19:48:17 <ski> so, i'm asking you to take the general type signature for `callback', and plug in the particular concrete type that we found that `r' must be, in this occurance of `callback'
19:48:39 <ski> what is the resulting (monomorphic) signature, of this occurance of `callback' ?
19:49:09 <MuNuFix> Ok.
19:49:30 <MuNuFix> So the callback :: forall r . ( f r -> r) -> r
19:49:38 <MuNuFix> And we are using r to be Mu f
19:49:50 <ski> aye, so ..
19:50:34 <MuNuFix> (f (Mu f) -> Mu f ) -> Mu f
19:50:51 <ski> right :)
19:51:10 <ski>   callback :: (f (Mu f) -> Mu f) -> Mu f
19:51:10 <MuNuFix> Wait wait
19:51:24 <ski> so, what is then the type of `?0' in this `callback ?0' ?
19:51:50 <ski> also, we can now recall the definition of the current `Mu' we're talking about here
19:52:07 <ski>   newtype Mu f = In {out :: f (Mu f)}  -- which is usually called `Fix f'
19:52:31 <MuNuFix> Mu f
19:52:47 <MuNuFix> If we have a Mu f
19:52:50 <ski> are you saying that's the type of `?0' ?
19:52:53 <MuNuFix> Yes
19:52:58 <ski> sorry, nope
19:53:15 <ski> if we have `f :: A -> B' and `f x :: B', then the type of `x' is `A'
19:53:36 <MuNuFix> f ( Mu f)
19:53:47 <ski> still not there
19:54:10 <ski> which part corresponds to `A', and which part corresponds to `B', if `f' here is our `callback' ?
19:54:44 <MuNuFix> (f (Mu f) -> Mu f) is A
19:54:52 <ski> yes ! :)
19:54:56 <MuNuFix> Mu f is B
19:55:04 * ski nods
19:55:07 <ski> so, the type of `?0' is then ?
19:55:22 <MuNuFix> (f ( Mu f) -> Mu f)
19:55:26 <ski> aye
19:56:07 <ski> can you figure out an expression of this type, that we could pass to `callback', plugging the `?0' hole in the code schema/template ?
19:56:41 <MuNuFix> expression of the type ?
19:56:55 <ski> yes
19:56:57 <ski>   invFlipCata callback = callback ?0
19:56:59 <ski> is pseudo-code
19:57:14 <ski> `?0' is not Haskell, we need to write a concrete Haskell expression in place of `?0'
19:57:25 <MuNuFix> Oh I get it
19:57:37 <ski> we've figured out the type of the expression. now it remains to look for an expression of this type
19:58:29 <ski> (hint : look at the definition of the data type `Mu' above)
19:58:45 <MuNuFix> I have to pattern match on the Mu type
19:58:52 <dfeuer> Ping hvr
19:59:11 <ski> (further hint : what are the types of `In' and `out' ?)
19:59:22 <hphuoc25> Hello. I'm using mwc-random and async to generate random numbers in parallel http://lpaste.net/361152. However this is slower than generating all random numbers in one thread. Can anybody help me explain why?
19:59:41 <MuNuFix> out is the input type for the funtion
19:59:54 <MuNuFix> since it has the structure f (Mu f)
20:00:01 <ski> if i ask `:t out' in the interactor, what would it reply ?
20:00:15 <ski> and ditto for `In'
20:00:27 <MuNuFix> Give an Mu f ,  out (Mu f) will give me f (Mu f)
20:00:53 <MuNuFix> In is just Mu f
20:00:56 <ski> a single type, please (e.g. in the form of a signature)
20:01:13 <ski> `In' does not have type `Mu f', that's not what `:t' would reply for it
20:01:32 <ski> (and ditto for `out', `:t' would not reply `f (Mu f)')
20:02:39 <ski> in general, if you have `newtype Abstract = Construct { destruct :: Representation }', what are the types of `Construct' and `destruct' ?
20:02:39 <MuNuFix> Well , out takes an input Mu F
20:02:51 <MuNuFix> And it returns f (Mu f)
20:03:05 <ski> yes .. which gives, taken together ?
20:03:37 <MuNuFix> Mu f
20:03:50 <MuNuFix> In takes in f ( Mu f) -> Mu f
20:04:04 <MuNuFix> In :: f (Mu f) -> Mu f
20:04:17 <MuNuFix> out :: Mu f -> f (Mu f)
20:04:22 <ski> thank you
20:04:41 <MuNuFix> No, thank you for the time and the effort you took.
20:04:59 <ski> so, return again to `?0' (what was its type again ?)
20:05:16 <MuNuFix> In
20:05:33 <ski> yes, `?0' has the same type as `In'
20:05:42 <ski> so you can select `?0' to be `In', giving
20:05:59 <ski>   invFlipCata :: forall f. Functor f => (forall r. (f r -> r) -> r) -> Mu f
20:06:11 <ski>   invFlipCata callback = callback In
20:06:57 <ski> now, you can figure out what `invFlipCata . flip cata' is (that's composition one way, which ought to be `id', if this is to be an inverse)
20:07:22 <ski> (we also need `flip cata . invFlipCata', the other composition, to be `id', for this to be a proper two-sided inverse)
20:07:34 <ski> @src (.)
20:07:34 <lambdabot> (f . g) x = f (g x)
20:07:41 <MuNuFix> Yes
20:08:09 <ski> `invFlipCata . flip cata' is (by eta expansion) `\m -> (invFlipCata . flip cata) m', which is ...
20:09:41 * ski waits for MuNuFix to complete this line of thought, if they care to try
20:10:03 <MuNuFix> Yes , I do care to try
20:10:11 <MuNuFix> :'(
20:10:53 <MuNuFix> Mu f
20:11:38 <hphuoc25> can anyone help?
20:11:44 <Welkin> nope
20:11:46 <hphuoc25> my question posted above
20:11:50 <jle`> hphuoc25: try using a different generator for each thread
20:12:03 <metahumor> that's what i was going to suggest
20:12:12 <metahumor> it might be expensive to share the generator state across threads
20:12:41 <hphuoc25> I see
20:12:48 <MuNuFix> :t cata
20:12:49 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
20:12:57 <MuNuFix> :t (flip cata)
20:12:58 <lambdabot> Functor f => Mu f -> (f c -> c) -> c
20:13:01 <monochrom> Does this MWC package even have more than one state?
20:13:41 <MuNuFix> composing \m -> (invFlipcata . flip cata) m
20:13:48 <MuNuFix> m has to be Mu f
20:14:08 <ski> `m' is of type `Mu f', yes
20:14:18 <ski> (which is why i called it `m')
20:14:20 <MuNuFix> Which when applied to flip cata (Mu f) gives ( f c -> c ) -> c
20:14:38 <ski> well, `forall c.' !
20:14:49 <MuNuFix> yes.
20:14:58 <MuNuFix> That when applied to invFlipcata
20:15:05 <mnoonan_> I’m collecting examples of simple but nontrivial use-cases for dependent types and refinement types (for a paper in progress). any suggestions?
20:15:06 <MuNuFix> give `Mu f`
20:15:18 <ski> (and `forall c. (f c -> c) -> c' is the same (by alpha conversion / renaming of bound variable) as `forall r. (f r -> r) -> r')
20:15:26 <ski> yes
20:15:34 <MuNuFix> Yes , so that can be applied to invFlipcata
20:15:36 <ski> so the whole maps from `Mu f' to `Mu f'
20:15:37 <metahumor> what's the idiomatic way of getting the "max" of two Maybe Ints? based on the Ord a => Ord (Maybe a), I can see that `max (Just a) Nothing = Just a; max Nothing (Just a) = Just a`. This is what I want. But why wouldn't a `max (Just a) Nothing = Nothing` be a valid definition too?
20:15:46 <MuNuFix> :D It looks like it
20:15:50 <ski> so it has the type of `id :: Mu f -> Mu f', at least
20:16:05 <MuNuFix> Yes.
20:16:15 <ski> the question is whether it is actually equal to `id'
20:16:59 <MuNuFix> Is Maybe (Maybe (Nothing)) same as Nothing
20:17:08 <ski> metahumor : `Nothing < Just x' for all `x'
20:17:21 <jle`> MuNuFix: Maybe (Maybe Nothing) isn't really a thing in Haskell
20:17:21 <MuNuFix> Both of them are `Mu Maybe`
20:17:41 <ski> i don't know what you mean by `Maybe (Maybe (Nothing))'
20:18:03 <MuNuFix> When you asked it is actually equal to `id`
20:18:10 <ski> (if you really mean `Just (Just (Nothing))', then i hope you can then answer your own question ?)
20:18:14 <metahumor> ski: that's unfortunate, because then `max` is privileged over `min` in terms of being able to retain the Just values
20:18:40 <MuNuFix> Sorry , I meant Just.
20:18:42 <ski> metahumor : `(maximum . catMaybes) [m0,m1]'
20:19:12 <ski> or, i suppose that doesn't work when both are `Nothing'
20:19:14 <metahumor> unsafe, if both are Nothing
20:19:35 <ski> @hoogle (a -> Bool) -> a -> Maybe a
20:19:35 <lambdabot> Control.Monad.Plus partial :: (a -> Bool) -> a -> Maybe a
20:19:35 <lambdabot> Agda.Utils.Maybe filterMaybe :: (a -> Bool) -> a -> Maybe a
20:19:35 <lambdabot> Agda.Utils.Maybe.Strict filterMaybe :: (a -> Bool) -> a -> Maybe a
20:19:38 <metahumor> there's the Max and Min Semigroups
20:20:53 <ski> hm, using that, it'd be `(maybe maximum . partial (not . null) . catMaybes) [m0,m1]'
20:21:31 <ski> MuNuFix : so, is `Just (Just (Nothing))' the same as `Nothing' ?
20:21:47 <MuNuFix> ski , the types line up
20:22:00 <ski> > Just (Just (Nothing)) == Nothing
20:22:01 <lambdabot>  False
20:22:05 <MuNuFix> But they arent the same
20:22:08 <ski> right
20:22:29 <MuNuFix> Which is why I was thinking the id :: Mu f -> Mu f
20:22:32 <ski> (`False' is the same type as `True', but these two also happen to not be equal)
20:22:35 <metahumor> :t fmap getMax . mconcat . fmap (fmap Max)
20:22:36 <lambdabot> error: Variable not in scope: getMax :: a0 -> b
20:22:36 <lambdabot> error:
20:22:36 <lambdabot>     • Data constructor not in scope: Max :: a -> a0
20:22:49 * ski isn't sure why MuNuFix is asking about this, though
20:23:30 <ski> MuNuFix : can you perhaps continue the chain of equalities :   invFlipCata . flip cata  =  \m -> (invFlipCata . flip cata) m  =  ...
20:24:11 <MuNuFix> Can you please elaborate and I will surely do it
20:24:32 <ski> ok
20:24:33 <ski> well, how do you simplify `(invFlipCata . flip cata) m' ?
20:24:39 <jle`> MuNuFix: you can fmap Down
20:24:44 <jle`> sorry, metahumor ^
20:25:11 <MuNuFix> ski isnt that same as invFlipCata (flip cata m)
20:25:15 <hphuoc25> I tried using different generator for each thread http://lpaste.net/361154. It's still slower than generating all in one thread.
20:25:16 <jle`> > min (Down <$> Just 3) (Down <$> Just 2)
20:25:17 * ski suspects MuNuFix is a bit tired atm
20:25:18 <lambdabot>  Just (Down 3)
20:25:20 * ski surely is
20:25:26 <jle`> > min (Down <$> Just 3) (Down <$> Nothing)
20:25:27 <ski> MuNuFix : yes, good :)
20:25:28 <lambdabot>  Nothing
20:25:43 <MuNuFix> I am not tired , I am thankful I have got someone to help me out.
20:25:49 <ski> MuNuFix : so `\m -> (invFlipCata . flip cata) m' is thus equal to `\m -> invFlipCata (flip cata m)' -- can you further simplify that ?
20:26:20 <ski> (ok, then all the blame must be on me, for not explaining well enough)
20:26:43 <MuNuFix> I might have tired you out ( you got a dumb pupil)
20:27:05 <ski> (nah, i'm up late, is all)
20:27:40 <metahumor> jle`: I was hoping that the min (Down <$> Just a) (Down <$> Nothing) would not equal Nothing
20:27:41 <MuNuFix> reducing the expression (flip cata m) gets us to ( forall r. (f r -> r) -> r)
20:27:44 <ski> the relevant definitions here are
20:27:47 <ski> @src flip
20:27:47 <lambdabot> flip f x y = f y x
20:27:54 <MuNuFix> :t cata
20:27:55 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
20:27:57 <ski>   cata phi = phi . fmap (phi cata) . out
20:28:00 <jle`> metahumor: that gives 'max' behavior
20:28:04 <MuNuFix> :t flip cata
20:28:05 <lambdabot> Functor f => Mu f -> (f c -> c) -> c
20:28:05 <ski>   invFlipCata callback = callback In
20:28:14 <jle`> metahumor: min-of-down is 'max', with Nothing being the maximum
20:28:22 <jle`> metahumor: max-of-down is 'min', with Just being the minimum
20:28:35 <jle`> metahumor: so it's the opposite bheavior of normal min/max
20:28:37 <metahumor> oh I see
20:28:42 <metahumor> tricksy
20:28:43 <jle`> see my first example
20:28:46 <jle`> > min (Down <$> Just 3) (Down <$> Just 2)
20:28:47 <lambdabot>  Just (Down 3)
20:28:50 <jle`> it's "max"
20:28:51 <ski> MuNuFix : is it possible to apply any of those defining equations to the current expression, to simplify it further ?
20:29:05 <jle`> so if you want min-with-nothing-as-maximum:
20:29:07 <MuNuFix> Yes
20:29:15 <jle`> > max (Down <$> Just 3) (Down <$> Nothing)
20:29:17 <lambdabot>  Just (Down 3)
20:29:17 <metahumor> jle`: then i'd use `max ... Down`
20:29:18 <jle`> > max (Down <$> Just 3) (Down <$> Just 2)
20:29:20 <lambdabot>  Just (Down 2)
20:29:24 <MuNuFix> we have to apply flip to cata first
20:29:25 <jle`> mhm
20:29:40 <MuNuFix> Thereby switching the order of application
20:29:42 <metahumor> its a little cryptic, more than going through the Max or Min semigroup, imo
20:30:00 <ski> MuNuFix : do we ?
20:30:01 <jle`> yeah, but at least you use 'max'/'min' :)
20:30:06 <metahumor> to remember that max is just max, and min is max ... Down
20:30:17 <MuNuFix> ski looking back to see what phi is
20:30:20 <MuNuFix> :t cata
20:30:21 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
20:30:36 <ski> (MuNuFix : if we do, we'd need to eta-expand again)
20:30:55 <MuNuFix> since m is Mu f
20:31:29 <MuNuFix> And cata expects an argument ( f a -> a)
20:31:41 * ski nods
20:31:54 <MuNuFix> We need to flip cata first
20:32:13 <MuNuFix> so that Mu f can be passed as an argument
20:32:16 <ski> well, but `flip' is defined to expect three arguments
20:32:26 <ski> but `flip' here is only applied to two
20:32:38 <ski> so, in order to get a third in place, we'd need to do an eta expansion
20:32:38 <MuNuFix> :t flip
20:32:39 <lambdabot> (a -> b -> c) -> b -> a -> c
20:32:45 <ski> @src flip
20:32:45 <lambdabot> flip f x y = f y x
20:33:41 <ski> (eta expansion says that `...' (having a function type) is equivalent to `\x -> (...) x', where `x' is a free variable name that doesn't occur (freely) in `...')
20:34:21 <MuNuFix> ski One small thought
20:34:41 <ski> (eta reduction is the opposite direction. if we don't focus on the direction, we can call it eta conversion. a related thing is function extensionality, that says that (for any expressions `f' and `g') if `f x = g x' for all `x', then `f = g')
20:35:03 <isovector> i want to write a test that says "this snippet of code doesn't compile"
20:35:08 <isovector> possible?
20:35:43 <MuNuFix> when applying m to cata
20:35:57 <MuNuFix> Can I do something like cata (out m)
20:35:59 <jle`> isovector: can't you just write it as a string
20:36:11 <ski> (iow, if `f' and `g' behave the same, when applied to an input argument `x', for all possible values of such inputs `x', then `f' and `g' are the same function)
20:36:14 <jle`> echo "this snippet of code doesn't compile" >> mytest.txt
20:36:42 <MuNuFix> :t cata
20:36:43 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
20:36:53 <ski> MuNuFix : no. but you can do a case analysis, or an induction, on `m', and realize that `m' must be of the form `In fm'
20:37:21 <ski> (in the induction case, you also get an induction hypothesis for free, to play with)
20:37:30 <isovector> jle`: conceptually, yeah, but getting it to play nicely seems hard. the use case is for developing a ghc plugin and keeping track of where it fails
20:37:59 <jle`> isovector: oh do you want to write like a unit test and test if some code should or should not compile
20:38:10 <MuNuFix> Ok , then going back to the thread of flip cata
20:38:12 <isovector> jle`: yeah, exactly. ideally it would integrate nicely into hspec :)
20:38:37 <isovector> by like, attempting to compile each splice, and then replacing itself with `shouldBe True True` iff the splice didn't compile
20:38:50 <jle`> isovector: there are some libraries that offer that
20:38:58 <mnoonan_> isovector: not sure if this will work for your case, but do you know about should-not-typecheck?
20:38:59 <jle`> i think they leverage defer-type-errors
20:39:09 <isovector> i saw one that works for type errors, but i suspect that won't work for compiler panics :)
20:39:16 * ski now recalls it was lseactuary before who was doing equational reasoning, with case analysis and induction, not MuNuFix
20:39:55 <MuNuFix> I dont know what the bubble really mean ( may be you are reminded of something ski ?)
20:39:58 <ski> MuNuFix : so, we're currently at `\m -> invFlipCata (flip cata m)', i think
20:40:05 <MuNuFix> Yes
20:40:06 <isovector> i've got a big transpacific flight in a few hours so i don't mind throwing some engineering at this problem, i just don't have a good mental model of what to build
20:40:23 <ski> MuNuFix : did you have an idea of what to try next, here ?
20:40:36 <MuNuFix> and flip needs a function in this case ( cata) and two other argument
20:40:39 <ski> MuNuFix : you said that you wanted to "do" the `flip'
20:40:46 <ski> yes
20:40:58 <ski> but `flip' is only applied to two arguments here, `cata' and `m'
20:41:04 <MuNuFix> One point ski
20:41:07 <MuNuFix> :t flip
20:41:08 <lambdabot> (a -> b -> c) -> b -> a -> c
20:41:25 <MuNuFix> f -> cata
20:41:32 <MuNuFix> m -> Mu f
20:41:52 <MuNuFix> can the rest be the output of that function
20:42:01 <MuNuFix> :t flip cata
20:42:02 <lambdabot> Functor f => Mu f -> (f c -> c) -> c
20:42:04 <ski> `f' in `flip f x y = f y x' will surely become `cata' here, yes
20:42:11 <ski> and the type of `m' here is `Mu f'
20:42:14 <MuNuFix> x becomes Mu f
20:42:30 <MuNuFix> y becaomes ( forall c . (f c -> c) -> c)
20:42:45 <ski> (i'm expanding what you meant, since you meant different things by the two `->' you wrote above)
20:42:58 <MuNuFix> Sorry , I just realized that
20:43:14 <MuNuFix> y will be Mu f
20:43:25 <ski> will be of that type, yes
20:43:40 <MuNuFix> x will be of type ( forall c . (f c -> c) -> c)
20:43:45 <ski> hm, wait
20:44:02 <Forty-Bot> how do I do a logical or in a pattern match?
20:44:11 <MuNuFix> TO get to c , we need ( f c -> c) function
20:44:20 <ski> actually no, `y' is not of type `forall c . (f c -> c) -> c)'
20:44:27 <MuNuFix> x is
20:44:43 <ski> nor is `x' of that type, nor is `y' of type `Mu f'
20:45:08 <nyberg> Forty-Bot: guards? Not sure what you're going for?
20:45:32 <mnoonan_> Forty-Bot: can you show an example of what you want?
20:45:37 <Forty-Bot> sure
20:45:52 <ski>   flip cata :: Mu f -> (f c -> c) -> c
20:45:55 <ski>                ^^^^    ^^^^^^^^^^
20:45:57 <ski>                x ::    y ::
20:46:05 <MuNuFix> Yes
20:46:17 <MuNuFix> But cant we include the parenthesis around
20:46:22 <ski> (and `x' is our `m')
20:46:41 <ski> so, `flip cata m y' will have type `c'
20:46:42 <MuNuFix> flip cata :: Mu f -> (( fc -> c) -> c )
20:46:46 <Forty-Bot> I have something like contest :: (Result, Int) -> (Result, Int) -> (Result, Int)
20:46:50 <MuNuFix> call x as Mu f
20:47:04 <MuNuFix> and y :: ( (f c -> c) -> c)
20:47:05 <ski> yes, you can
20:47:24 <Forty-Bot> where contest (Succ, x) (Succ, y) = something
20:47:44 <MuNuFix> So the application of flip cata m will result in an function ( ( forall c. f c -> c) -> c)
20:47:50 <Forty-Bot> and contest (CSucc, x) (CSucc, y) = the same thing
20:48:09 <Forty-Bot> and so on for all four combinations of successes on either side
20:48:11 <mnoonan_> Forty-Bot: ok, what you are after is called “or-patterns”, and Haskell unfortunately doesn’t have them
20:48:28 <mnoonan_> there is a template Haskell thing that can help though
20:48:36 <mnoonan_> see this answer: https://stackoverflow.com/questions/24700762/or-patterns-in-haskell
20:49:40 <MuNuFix> I think that would work ski -> So the application of flip cata m will result in an function ( ( forall c. f c -> c) -> c)
20:50:40 <ski>   flip :: ((f r -> r) -> Mu f -> r) -> Mu f -> (f r -> r) -> r
20:50:50 <ski>   cata ::  (f r -> r) -> Mu f -> r
20:50:55 <ski>   flip cata ::                              Mu f -> (f r -> r) -> r
20:51:01 <ski>   m ::                                      Mu f
20:51:09 <ski>   flip cata m ::                                    (f r -> r) -> r
20:51:13 <ski>   y ::                                               f r -> r
20:51:16 <ski>   flip cata m y ::                                                r
20:51:32 <MuNuFix> We dont have the y ( yet)
20:51:38 <ski> "So the application of flip cata m will result in an function ( ( forall c. f c -> c) -> c)" -- yes
20:51:48 <ski> yes, but assuming we had such an `y'
20:52:18 <MuNuFix> My thought was around the argument to invFlipCata
20:52:26 <ski> ok ?
20:52:31 <MuNuFix> which is ( forall r . ( f r -> r) -> r)
20:52:34 <tabemann> I'm looking for a simple way of concatenating sequences, as in S.Seq S.Seq -> S.Seq
20:52:46 * ski recalls the expression `\m -> invFlipCata (flip cata m)' again
20:52:52 <Forty-Bot> mnoonan_: so in my case I should look at ||
20:53:08 <ski> @hoogle Seq a -> Seq a -> Seq a
20:53:08 <lambdabot> Data.Sequence (><) :: Seq a -> Seq a -> Seq a
20:53:08 <lambdabot> Data.Sequence.Internal (><) :: Seq a -> Seq a -> Seq a
20:53:08 <lambdabot> Data.Edison.Seq.BankersQueue append :: Seq a -> Seq a -> Seq a
20:53:11 <ski> tabemann ^
20:53:38 <tabemann> no, not Seq a -> Seq a -> Seq a, but Seq (Seq a) -> Seq a
20:53:46 <ski> oh, nested
20:53:56 <ski> @hoogle Seq (Seq a) -> Seq a
20:53:57 <lambdabot> Data.Sequence tails :: Seq a -> Seq (Seq a)
20:53:57 <lambdabot> Data.Sequence inits :: Seq a -> Seq (Seq a)
20:53:57 <lambdabot> Data.Sequence.Internal tails :: Seq a -> Seq (Seq a)
20:54:00 <MuNuFix> \m -> invFlipCata (\y -> flip cata m y)
20:54:26 <ski> @hoogle (a -> r -> r) -> r -> Seq a -> r
20:54:26 <lambdabot> Data.Edison.Seq.BankersQueue fold :: (a -> b -> b) -> b -> Seq a -> b
20:54:26 <lambdabot> Data.Edison.Seq.BankersQueue fold' :: (a -> b -> b) -> b -> Seq a -> b
20:54:26 <lambdabot> Data.Edison.Seq.BankersQueue foldr :: (a -> b -> b) -> b -> Seq a -> b
20:54:41 <tabemann> I think I'm going to have to use a fold to do what I want to do, but I really wish there were a premade function that did it
20:55:34 <mnoonan_> Forty-Bot: you might also consider “view patterns”
20:55:37 <tabemann> I don't know what Data.Sequence does not have this
20:55:54 <ski> if you had a `foldr' for `Seq', then you could use `foldr (><) Seq.empty'
20:56:12 <ski> MuNuFix : *nod*
20:56:15 <tabemann> foldr from Data.Foldable can be used on Seqs
20:56:30 <ertes> tabemann: i think Data.Sequence is a monad
20:56:56 <ertes> @let import qualified Data.Sequence as Seq
20:56:56 <lambdabot>  Defined.
20:56:59 <ertes> :t join :: Seq.Seq (Seq.Seq a) -> Seq.Seq a
20:57:00 <lambdabot> Seq.Seq (Seq.Seq a) -> Seq.Seq a
20:57:23 <tabemann> thank you
20:57:48 <MuNuFix> Isnt this similar to `flatten` ertes ?
20:58:02 <ertes> MuNuFix: i'm not familiar with 'flatten'
20:58:02 <jle`> tabemann: can't you just use `fold`
20:58:36 <tabemann> jle`: I'm actually not familiar with just `fold`
20:58:42 <ski> tabemann : do you use `fmap' to get the `Seq (Seq a)' ?
20:58:46 <ertes> tabemann: BTW, you should use a left fold with Seq
20:58:48 <jle`> :t fold :: Seq.Seq (Seq.Seq a) -> Seq.Seq a
20:58:49 <lambdabot> Seq.Seq (Seq.Seq a) -> Seq.Seq a
20:58:54 <tabemann> ertes: that's what I was thinking
20:59:01 <jle`> tabemann: fold is mconcat
20:59:03 <tabemann> ski: yes
20:59:25 <jle`> > fold (Seq.fromList [Seq.fromList [1,2,3], Seq.fromList [4,5,6], Seq.fromList [7,8,9]])
20:59:27 <lambdabot>  fromList [1,2,3,4,5,6,7,8,9]
20:59:36 <ski> tabemann : note that `join (fmap f s)' is the same as `f =<< s', or `s >>= f', or `do x <- s; f x'
20:59:39 <ertes> tabemann: note that since Seq is a monad, you can just use (>>=)
21:00:15 <ertes> > Seq.fromList [10,20,30] >>= \x -> Seq.fromList [x - 1, x + 1]
21:00:16 <lambdabot>  fromList [9,11,19,21,29,31]
21:00:17 <jle`> tabemann: 'fold' <>'s all of the items in a Foldable together
21:00:19 <dmj`> Seq.Seq.Seq.Seq
21:00:34 <jle`> so it turns a sequence of [xs,ys,zs] to be xs <> ys <> zs
21:00:48 <ski> MuNuFix : .. so, you should be able to unfold that `flip' call now, right ?
21:01:17 <jle`> fold (Seq.fromList [xs,ys,zs]) = xs <> ys <> zs
21:01:34 <tabemann> what is better style - fmap and then fold, or f =<< s?
21:01:46 <ertes> tabemann: i'd say (>>=) or (=<<)
21:01:51 <jle`> fmap then fold?
21:01:52 <MuNuFix> unfold the flip call ?
21:01:53 <jle`> that's just foldMap
21:02:10 <ski> `(=<<)' or one of the two other alternate forms might be more efficient that a `join' following an `fmap'
21:02:44 <ertes> tabemann: foldMap and (>>=) are more direct communication of intent, and it's not too indirect; i'd expect every experienced haskell programmer to be familiar with them
21:02:50 <jle`> i'd probably pick fold for flattening seq's
21:02:57 <tabemann> I'll go with foldMap because it will be clearer as to what I'm doing, whereas I might forget what =<< does with Seqs
21:03:14 <Wizek> geekosaur: in case you are still around; sorry I had to leave early yesterday and didn't get a chance to get back to you till now. I have time again to look at the issue. And I have an idea on how I could try to narrow it down, so my next question is directed at you or others.
21:03:17 <ski> (unless we get fusion or something like that, the `join'&`fmap' looks likely to construct an intermediate data structure, which is then traversed again)
21:03:26 <ertes> tabemann: well, (>>=) doesn't have many options with Seq =)
21:03:27 <Wizek> Could someone on MacOS try the following for me? `stack unpack lmdb && cd lmdb-0.2.5 && stack init && stack build` and see if it complains for them as well about a missing C dependency?
21:03:37 <jle`> ski: i believe join+fmap for lists does fuse
21:03:47 <ski> jle` : yes, but how about `Seq's ?
21:04:01 <Wizek> And if it does, try running `brew install lmdb` (and possibly `brew install pkg-config` too if it's missing) and retrying `stack build`. Then please tell me the results.
21:04:04 <jle`> i'm certain not
21:04:51 <tabemann> thanks guys
21:05:16 <jle`> hm actually there might be
21:05:59 <ski> MuNuFix : sorry. yes by "unfold" i just mean : replace the function call with the body of the definition of the function, with formal parameters of the definition replaced by the actual parameter expressions in the call (and also using pattern-matching to select which defining equation to use, if appopriate. that isn't needed here, though)
21:06:40 <mnoonan_> (retrying before I fall asleep for the night): I want to gather some interesting examples of simple-ish use-cases for dependent types and refinement types. does anybody have some favorites to share?
21:07:05 <jle`> there are some rewrite rules in https://github.com/haskell/containers/blob/master/Data/Sequence/Internal.hs but i'm not sure if any of them cause the proper fusion
21:07:08 <ski> (and by "fold", in this context, i mean the opposite direction of replacing an (instance of a) function body with a call to that function that would expand to that instance)
21:08:12 <MuNuFix> \m -> invFlipCata (\y -> flip cata m y)
21:08:24 <MuNuFix> Is there anything else to unfold here.
21:08:56 <MuNuFix> Or maybe \m -> invFlipCata (\y -> cata y m)
21:09:40 <ski> MuNuFix : e.g. we can "unfold" the `(.)' call in `(invFlipCata . flip cata) m', by substituting `invFlipCata' for `f', `flip cata' for `g', and `m' for `x', in the body of the defining equation `(f . g) x = f (g x)' for `(.)', getting `invFlipCata (flip cata m)' as the result of that "unfolding". "folding" this final expression using `(.)' would get as back to the `(invFlipCata . flip cata) m' expression
21:09:57 <ski> MuNuFix : yes :)
21:10:18 <ski> MuNuFix : now you have unfolded the `flip' call. but there's still one simplification you can make
21:10:43 <ski> the remaining relevant definitions are
21:10:50 <MuNuFix> \m -> invFlipCata (\y -> y . fmap (y cata) . out m)
21:10:51 <ski>   cata phi = phi . fmap (cata phi) . out
21:11:00 <ski>   invFlipCata callback = callback In
21:11:05 <MuNuFix> Yes it is about replacing phi with y
21:11:27 <MuNuFix> and then unfolding the composition
21:11:42 <ski> well, you'd need an extra pair of brackets there
21:12:19 <MuNuFix> I write as if I write on paper , so excuse me for now
21:12:29 <ski> (remember that `f . g x' is parsed as `f . (g x)', not as `(f . g) x')
21:13:13 <ski> (it's quite easy to confuse oneself, if one has managed to let a mistake like this slip into the derivation)
21:14:38 <Forty-Bot> well, I came up with https://ptpb.pw/wido/haskell
21:14:41 <ski> .. however, i claim that you can actually do another simplification, before / instead of unfolding the `cata' call above
21:14:43 <Forty-Bot> which appears to work
21:15:14 <MuNuFix> Interesting ski
21:15:31 <MuNuFix> I was trying to replace . operator with parenthesis
21:15:43 <MuNuFix> and apply m to out first
21:16:17 <ski> do you see which simplification/reduction i refer to ?
21:16:26 <MuNuFix> No , still thinking
21:17:21 <ski> (actually, you could do it even before the `flip' unfolding, even before the eta expansion just preceding it)
21:17:54 <ski> (it's not a bit matter. it'll work as you started doing it here, as well)
21:17:58 <MuNuFix> Is it the expansion of invFlipCata ?
21:18:04 <ski> try it ?
21:18:20 <ski> (s/bit/big/)
21:18:40 <jle`> Cale: are you one of the maintainers of MonadPrompt?  do you know if there is an issue tracker or git repo available anywhere?
21:19:22 <totom> Someone please hook me up with a pdf of Intrduction to functional programming using haskell Richard Brid's book
21:19:30 <MuNuFix> I could probably replace invFlipCata with its function equivalent
21:20:22 <ski>   invFlipCata callback = callback In
21:20:34 <ski> you have a call of `invFlipCata', with one argument
21:20:35 <MuNuFix> invFlipCata callback = callback In
21:20:54 <ski> so, you could take the body, and replace the formal `callback' in there with the actual
21:21:36 <MuNuFix> \m -> invFlipCata (flip cata m)
21:21:42 <MuNuFix> That will become
21:22:33 <MuNuFix> \m -> (flip cata m) In
21:22:38 <ski> right :)
21:22:48 <ski> that way, you don't need to do an eta-expansion step
21:23:26 <ski> because `(flip cata m) In' is the same as `flip cata m In', where now `flip' is applied to three actual parameter expressions
21:23:41 <MuNuFix> Ahh.
21:23:44 <MuNuFix> Got it
21:23:54 <ski> so, it's slightly simpler, this way
21:24:02 <MuNuFix> One question
21:24:10 <ski> otherwise you'd have to at some point replace `(\y -> ..y..) In' with `..y..'
21:24:18 <MuNuFix> \m -> cata In m
21:24:32 <ski> yes ?
21:24:35 <MuNuFix> If we go on expanding cata
21:24:45 <MuNuFix> Wouldnt we recursively get to the same place ?
21:25:02 <ski> yes .. that's why we need induction
21:25:24 <MuNuFix> cata phi = phi . fmap (cata phi) . out
21:25:28 <MuNuFix> which means
21:25:56 <MuNuFix> \m -> (In . fmap (cata In) .out ) m
21:27:59 <ski> (you could do a couple of more reductions here)
21:28:03 <MuNuFix> out m :: f m
21:28:36 <MuNuFix> \m -> In . fmap ( cata In) f m
21:29:14 <ski> itym `\m -> In (fmap (cata In) (... :: f m))'
21:29:16 <totom> you get all these just by haskell or you learn some other things too in Computer science
21:29:28 <ski> all these what ?
21:30:09 <MuNuFix> \m -> In. fmap (cata In f m)
21:30:13 <totom> things you talked about abvove
21:30:13 <ezyang> JazzyEagle: Are you still there?
21:30:30 <dfeuer> Is the MonadFix (Free f) instance lawful?
21:30:32 <totom> induction, reduction
21:30:44 <ski> well, we're doing equational reasoning. which is pretty similar to highschool algebra, i suppose
21:30:50 <MuNuFix> and In :: f (Mu f) -> Mu f ( in ou case here Mu f == m)
21:31:05 <dfeuer> ezyang: do hsig files still not support pattern synonyms? Simon was asking me about the interaction with constructor function signatures, and I don't think it applies yet....
21:31:14 <ski> induction is slightly more advanced, i supposed, but not much
21:31:24 <MuNuFix> \m -> In. fmap (cata m)
21:31:31 <dfeuer> ezyang: also, do you know how pattern synonyms interact with hs-boot files? There doesn't seem to be any documentation!
21:31:42 <ski> by "reduction" i just mean an equality step, that we interpret as having a preferred direction (the evaluation/reduction direction)
21:32:15 <ski> (well, a *smallest* equality step, in some sense. one that can't be subdivided into smaller, nontrivial, steps)
21:32:26 <MuNuFix> ski , I took it forward by reducing out m -> f m
21:32:35 <MuNuFix> and applying In f m -> m
21:32:54 <ski> "in ou case here Mu f == m" -- in our case, `m :: Mu f'
21:33:12 <MuNuFix> Yes , I will get into this habit
21:33:30 <ezyang> dfeuer: We have a plan but it's not implemented yet
21:33:50 <ski> `\m -> In (fmap (cata In) (... :: f m))' is not equal to `\m -> In . fmap (cata In (... :: f m))'
21:34:15 <dfeuer> ezyang: do you think you could comment on https://github.com/ghc-proposals/ghc-proposals/pull/101 as appropriate?
21:34:27 <ezyang> the plan is here: https://ghc.haskell.org/trac/ghc/ticket/14478
21:34:55 <ski> (also, i'd prefer if you used another name for the type variable `m' there, how about `r', which you used before ? that way it's easier to not confuse it with the *value* variable `m' (of type `f r', then))
21:35:14 <dfeuer> Oh boy, complications!
21:35:15 <ski> you can't move `out m' inside the bracket around the `cata' call here
21:35:27 <MuNuFix> We are doing an fmap of the function (cata In) over f m
21:35:37 <MuNuFix> I think I missed that
21:35:48 <MuNuFix> Retracing back my steps
21:36:01 <ski> (also, you have an `.' there after `In', which shouldn't be there)
21:36:33 <ski> one step at a time
21:36:51 <MuNuFix> \m -> In ( fmap (cata In) (... :: f m))
21:36:54 <dfeuer> ezyang: ah, I see.
21:37:09 <ski> (i'll explain how to handle the recursion in `cata', as soon as we reach the step where we need to consider that)
21:37:17 <ski> yes
21:37:19 <ski> or just
21:37:30 <ski>   \m -> In (fmap (cata In) (out m))
21:37:39 <ski> if we fill in `out m' explicitly, again
21:37:42 <MuNuFix> Isnt this that step where we fmap the function ( cata In)
21:37:44 <ski> agreed ?
21:37:51 <MuNuFix> Yes
21:38:25 <ski> well, the second argument of `fmap' here has type `f r'
21:39:12 <MuNuFix> out m has a type f r
21:39:25 <ski> and we don't know what type `f' is (the "caller" of us will determine it. otherwise stated, `f' is universally quantified, we have to make an an equational reasoning that works for any type `f', as long as its a functor)
21:39:27 <MuNuFix> out :: Mu f -> f (Mu f)
21:39:46 <ski> so, we don't know how to actually do the `fmap' here
21:39:56 <ski> however, we could start with looking at the `out'
21:39:58 <MuNuFix> Yes
21:40:24 <ski> the definition of `out' (which is implicitly derived from `newtype Mu f = In {out :: f (Mu f)}') is
21:40:25 <MuNuFix> Isnt this the recursive case
21:40:39 <ski>   out :: Mu f -> f (Mu f)
21:40:45 <ski>   out (In fm) = fm
21:41:21 <ski> so, in order to be able to apply this defining equation, we must have an actual argument expression in the call that looks like `In (...)', for some expression `...'
21:41:32 <ski> but we only have `out m', currently
21:41:57 <ski> you have `invFlipCata . flip cata  ={omitted steps, see above}=  \m -> cata In m  =  \m -> (In . fmap (cata phi) . out) m  =  \m -> In ((fmap (cata phi) . out) m)  =  \m -> In (fmap (cata phi) (out m))'
21:42:06 <ezyang> oh hey, NF gets a shoutout
21:42:24 <ski> so, we *could* do a case analysis on `m' here
21:42:47 <ski> the only possible form of `m' is `In fm' (where we can of course choose the (fresh) variable name `fm')
21:42:51 <ezyang> dfeuer: OK, blah, your proposal makes sense but it does make the abstract pattern synonym story more hairy
21:43:16 <ski> so, this step would take us from `\m -> In (fmap (cata phi) (out m))' to `\(In fm) -> In (fmap (cata phi) (out (In fm)))'
21:43:22 <ski> MuNuFix : do you follow ?
21:43:28 <MuNuFix> yes
21:43:40 <ezyang> because to write an abstract bidirectional synonym, you'd have to write something like
21:43:40 <dfeuer> ezyang: I'm punching up a modification based on #14478 right now.
21:43:43 <MuNuFix> You need the inner fm
21:43:44 <dfeuer> Givem me a minute.
21:43:51 <ski> and then we could unfold `out', getting what ?
21:44:17 <MuNuFix> fm
21:44:41 <ezyang> pattern F :: PatCt => tau pattern F = ..  (where to put the CtorCt?)
21:44:54 <dfeuer> ezyang: pushed.
21:45:03 <dfeuer> ezyang: I have no idea what that means.
21:45:06 <ski> (if there had been multiple possible alternative forms of `m', then we'd have to consider each form separately, and try to reach the desired (common) end point of our overall equality chain, in each of these (alternative) parallel equality sub-chains)
21:45:18 <dfeuer> Sorry, I'm not familiar with those details.
21:45:30 <ski>      \m -> In (fmap (cata phi) (out m))
21:45:33 <ski>   =  \(In fm) -> In (fmap (cata phi) (out (In fm)))
21:45:42 <ski>   =  \(In fm) -> In (fmap (cata phi) fm)  -- yes
21:45:52 <ski> but now we seem to be stuck again
21:46:07 <ski> we *could* eta-expand the `cata' call, so that we can unfold it
21:46:17 <MuNuFix> But it will keep going on and on
21:46:19 <ski> but .. this would then lead to a new `cata' call again
21:46:20 <ski> right
21:46:29 <dfeuer> ezyang: I don't think a totally abstract bidirectional synonym makes much sense when the signatures are different. Different signatures always imply explicit bidirectionality.
21:46:34 <MuNuFix> Isnt this expression similar to our first expression
21:46:36 <ezyang> dfeuer: Uh, there's a missing newline
21:46:39 <MuNuFix> In structure
21:46:41 <dfeuer> Dammit.
21:46:43 <ski> yes, but slightly more complex
21:46:48 <dfeuer> ezyang: where?
21:46:52 <MuNuFix> And I am hoping this is where we should get into induction
21:46:56 <ezyang> pattern F :: PatCt => tau \n pattern F = ..
21:47:01 <ski> right
21:47:09 <ski> MuNuFix : have you seen induction on natural numbers ?
21:47:16 <dfeuer> ezyang: so what?
21:47:24 <ezyang> where did you push?
21:47:26 <MuNuFix> ski seen induction
21:47:41 <ski> ok, so i'll restate it, in this context of equality chain proofs
21:47:52 <dfeuer> ezyang: https://github.com/ghc-proposals/ghc-proposals/pull/101
21:47:54 <ski> so, say we want to prove `f n = g n', for all natural numbers `n'
21:48:08 <MuNuFix> We prove it for 1
21:48:12 <ski> and by `f n' and `g n' here, i really mean any expressions, which may mention `n' (freely)
21:48:18 <MuNuFix> And assume it is true for n
21:48:25 <MuNuFix> and prove it for n+1
21:48:30 <ski> well, some people prefer to start counting at zero, but yes :)
21:48:51 <MuNuFix> Like you said , high school math ( I think I do remember )
21:49:26 <MuNuFix> Please go ahead , will follow your train of thought ski
21:49:28 <ski> so, to prove `f n = g n' for all `n', we need (a) to prove `f 0 = g 0'; and also (b) to prove `f (m+1) = g (m+1)', under the assumption / (induction) hypothesis `f m = g m', for all `m'
21:49:34 <ezyang> dfeuer: OK, this seems reasonable to me
21:49:42 <ski> now, i'll repeat the same thing, but for lists
21:49:47 <ski> @src []
21:49:47 <lambdabot> data [] a = [] | a : [a]
21:50:34 <ezyang> (I was previously hung up on using '=' for bidirectional pattern synonyms, but you're right, there isn't really any reason to force it)
21:50:37 <ski> to prove `f xs = g xs', for all (finite) lists `xs', we need to show (a) `f [] = g []'; and also (b) `f (x:xs) = g (x:xs)' under the assumption / (induction) hypothesis `f xs = g xs', for all `x' and `xs'
21:50:58 <ezyang> This new syntax has really got me thinking if we didn't actually introduce overloading based on expression/pattern context
21:51:37 <ski> so, in the `(x :: a) : (xs :: [a])' case of lists, we assume "the same thing we're trying to show", but for the "sublist" `xs'
21:51:59 <dfeuer> ezyang: cool.
21:52:03 <ski> if we had a tree which can have two subtrees, then we'd assume one induction hypothesis for the left subtree, and one for the right
21:52:04 <MuNuFix> Ok ski
21:52:17 <dfeuer> ezyang: whot do you mean about overloading?
21:52:25 <ezyang> what I mean is
21:52:41 <ezyang> suppose we had designed explicitly bidirectional pattern synonyms differently
21:53:15 <ezyang> by (1) allowing unidirectional pattern synoyms, but (2) letting you define values with capital letter and (3) letting these names be the same
21:53:52 <ski> MuNuFix : in our case, we want to prove `foo m = bar m' for all `m :: Mu f'. the only case we have to consider is (a) where `m' is of the shape `In fm' (with `fm :: f (Mu f)') .. so we want to show `foo (In mf) = bar (In mf)' .. but under which induction hypothesis ?
21:54:33 <MuNuFix> There isnt any empty case
21:54:35 <ski> if we have `fm :: f (Mu f)', then that means that we have an "`f'-collection" of `Mu f's. each of which we'd like to assume an induction hypothesis for
21:54:40 * ski nods
21:55:06 <dfeuer> ezyang: I actually proposed that option as well; it was rejected. :-(
21:55:35 <dfeuer> I thought that had better orthogonality as a language feature; others couldn't stand the thought of a constructor synonym without a pattern to go with it.
21:56:14 <MuNuFix> So , IMO we have to prove that
21:56:51 <MuNuFix> foo ( In (In mf')) = bar (In (In mf'))
21:57:14 <MuNuFix> provided we can assume that foo (In mf) = bar (In mf)
21:57:23 <ski> hm, i think there's too many `In's there
21:57:46 <MuNuFix> The In (In mf') is the x:xs case
21:59:02 <MuNuFix> Do you think I am missing something
21:59:19 <Wizek> https://stackoverflow.com/questions/48002193/how-can-the-haskell-lmdb-package-on-macos-be-built <- I've posted my previous question here as well. Hopefully the least I get is some "me-too"s that building fails for others too.
22:00:46 <ski> MuNuFix : hm, i'm pondering how to proceed
22:01:48 <ski>   \m -> In (fmap (cata Inphi) (out m))  =  ...  =  \m -> In ()  =  \m -> id (In (out m))  =  \m -> In (out m)  =  \(In fm) -> In (out (In fm))  =  \(In fm) -> In fm  =  \m -> m  =  id
22:01:52 <ski> er, sorry
22:02:13 <ski> i just realized that we've forgot to replace `phi' by `In' in `cata phi'
22:02:34 <MuNuFix> I always read it as In
22:02:56 <MuNuFix> So the meaning is conveyed correctly
22:03:08 <MuNuFix> Or your intent is conveyed correctly
22:03:17 <ski> oh, so you did
22:03:20 <ski> mea culpa
22:03:24 <ski> s/we/I/
22:04:26 <MuNuFix> I think if I understood the idea correctly
22:04:54 <MuNuFix> When we reduced the first Mu , we arrive at the similar structure after the reduction
22:05:25 <ski> let's retrace to
22:05:28 <ski>   invFlipCata . flip cata  ={omitted steps, see above}=  \m -> cata In m  =  ...  =  \m -> m  =  id
22:05:47 <ski> i added two expressions at the end of the chain, that we'd like to have there
22:06:07 <ski> so, the part we're struggling with is `\m -> cata In m  =  ...  =  \m -> m'
22:06:25 <MuNuFix> \m -> In (fmap (cata In) (out m))
22:06:37 <ski> i was pondering how to *formulate* the induction hupothesis (even in general), for `Mu'
22:06:55 <MuNuFix> \In fm -> In (fmap (cata In) (out (In fm)))
22:07:02 <ski> i don't at the moment see a nice fully formal way to do it
22:07:22 <Clockwise> hi, is this channel also for newbies or is there one for us?
22:07:36 <ski> Clockwise : it is also for newbies and beginners
22:07:37 <MuNuFix> \In fm -> In (fmap (cata In) fm)
22:07:59 <MarcelineVQ> Clockwise: newbie questions are quite welcome here
22:08:19 <ski> however, if we want to prove that `cata In m = m', for all `m', then we should be able to assume `cata In m1 = m1', for all `m1' which are strictly "children" of `m'
22:08:23 <ski> MuNuFix : agree ?
22:09:04 <MuNuFix> Yes
22:09:05 <ski> (we could restrict it to *direct* children, if we want to. doesn't matter that much)
22:09:10 <Clockwise> thanks, im about to start learning haskell, i already do some python for fun and java at work. is "learn you a haskell" the right place to start?
22:10:01 <ski> so, as before, we replace `m' by `In fm', and we now want to complete `cata In (In fm) = ... = In fm', under this induction hypothesis
22:10:21 <MarcelineVQ> Clockwise: it's a good overview of some things but it's hard to actually learn from because there's no exercises to work through
22:10:33 <MuNuFix> I have got it until here
22:10:43 <MuNuFix> \In fm -> In (fmap (cata In) fm)
22:10:58 <ski> and, as before, we go `cata In (In fm) = (In . fmap (cata In) . out) (In fm) = In (fmap (cata In) (out (In fm))) = In (fmap (cata In) fm = ... = In fm'
22:11:03 <MarcelineVQ> @where learnhaskell -- Clockwise this is often what's reccomended for new people to have a look at
22:11:03 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:11:25 <ski> so, if we can complete `fmap (cata In) fm = ... = fm', we should be done
22:11:32 <MuNuFix> yes
22:11:48 <ski> now, eta-expand the inner `cata' (as we considered before
22:12:00 <MuNuFix> We have to fmap (cata In) on one more peel of the fm
22:12:20 <ski> `fmap (cata In) fm  =  fmap (\m1 -> cata In m1)  =  ...  =  fm'
22:12:21 <Clockwise> okay, thank you very much, i'll come here if i get seriously stuck
22:12:22 <MuNuFix> And if we get back to where we are now, then we should be fine
22:12:28 <ski> and now ? can you see what we do next ?
22:12:30 <nyberg> Clockwise: There's also Real World Haskell and OCharles' blog which is a life saver
22:12:33 <MarcelineVQ> Clockwise: everyone does :>
22:12:47 <MarcelineVQ> get stuck I mean, so be sure to come back when you do
22:12:58 <jle`> why isn't there an execWriterT
22:13:38 <jle`> oh wait there is one
22:13:40 <ski> (er, i forgot to pass `fm' as second argument to the second `fmap' there)
22:13:54 <MuNuFix> Yes , which is what I was wondering
22:13:58 <ski> `fmap (cata In) fm  =  fmap (\m1 -> cata In m1) fm  =  ...  =  fm'
22:14:08 <MuNuFix> we are trying to fmap the function (cata In) over fm
22:14:08 <ski> now, we apply the induction hypothesis !
22:14:11 <MuNuFix> correct
22:14:12 <Clockwise> i'll check those ones out too, thanks people! :)
22:14:52 <ski> the justification here is that all the `m1' that `fmap' will pass, from `fm', will be strict parts of `fm'
22:15:03 <ski> and so we know that `cata In m1  =  m1' !
22:15:06 <ski> so, we can continue
22:15:22 <ski> `fmap (cata In) fm  =  fmap (\m1 -> cata In m1) fm  =  fmap (\m1 -> m1) fm  =  ...  =  fm'
22:15:47 <MuNuFix> Interesting
22:15:56 <MuNuFix> I have to pen this down some place
22:16:06 <ski> now, this isn't fully formal. but since i don't seem to figure out how to formulate the IH more formally, i say we'd better be satisfied with this, for the while
22:16:14 <MuNuFix> :D
22:16:24 <ski> now, can you see where to continue, from here ?
22:16:53 <MuNuFix> Let me jot all this down ski
22:17:39 <MuNuFix> That will help me if I have some questions
22:18:05 <MuNuFix> And BTW , thank you for taking the time and effort in going through this with me today.
22:18:37 <ski> well, i don't recall having done this proof before, so it's fun to attempt to do it
22:18:39 <MuNuFix> What started as a "I didnt understand Mu , you brought me down to this path"
22:19:04 <ski> this is perhaps a bit of a side path to the original question about understanding the library `Mu' definition
22:19:25 <ski> however, hopefully the equational reasoning practice is useful
22:19:32 <MuNuFix> It brought up some very nice areas for me to work on
22:19:57 <MuNuFix> I will have to go back to haskellbook and redo some exercises on eta-conversion and lambda calculus once again
22:20:28 <MuNuFix> My original question was based on this : https://github.com/sellout/recursion-scheme-talk/blob/master/recursion-bottom.org#corecursion
22:20:35 <MuNuFix> If you have time to look
22:20:54 <MuNuFix> I didnt completely understand the problem with Fix.
22:20:57 <ski> (i looked very briefly, before)
22:21:13 <MuNuFix> And this is the videos by sellout : https://www.youtube.com/watch?v=24UoRaoKLjM
22:21:52 <MuNuFix> Thank you for your time ski and I hope to see you tomorrow here !
22:21:58 <ski> ty
22:22:14 <ski> ok. you're leaving for today ?
22:22:28 <MuNuFix> Yes. I need to put my kids to bed
22:22:44 <ski> i believe the hardest part of the proof above is done
22:23:05 <MuNuFix> I will rewrite it so that I completely understand it and ask questions
22:23:20 <ski> the point of all this is to show that `Mu f' (what you called `Fix f', but with the "inductive data type" interpretation) is isomorphic to `forall r. (f r -> r) -> r'
22:23:35 <ski> we're currently attempting to show that one composition order is `id'
22:24:03 <ski> to show that the other order is `id' is harder. it requires knowing that `forall' in Haskell yields "parametricity"
22:24:23 <MuNuFix> Good more to learn.
22:24:24 <ski> e.g. that if you have a function of type `forall a. a -> a', then there's no way this can inspect its argument
22:24:45 <MuNuFix> Is there a need to
22:24:58 <MuNuFix> We are just returning the a that is sent to the function
22:25:21 <ski> in C++', if you have `template<typename T> T *foo(T*);', then you could have instantiations for particular types replacing `T', where `foo' inspects its argument
22:25:33 <MuNuFix> And that takes me to a different question , is there something like Reflection in haskell
22:25:53 <ski> so, genericity with templates in C++ does *not* enjoy parametricity. likewise for Java
22:26:36 <ski> well, there's type classes `Generic' and `Data' ..
22:27:19 <ski> anyway, with the above isomorphism under the belt, it's a small matter to change the implementation of`Mu f' to use this alternative representation
22:27:33 <MuNuFix> Ok. Let me try working on it
22:27:33 <ski> now, as for *why* one'd want to do that, that's another question
22:27:50 * ski 'd probably need to look closer at that link
22:28:01 <ski> (though i have one or a couple of hunches)
22:28:16 <MuNuFix> Please do look at that link ( if your time permits)
22:28:38 <ski> i should also mention that we can do basically the same thing, with `Nu' and `ana'
22:28:54 <MuNuFix> My thought was to start writing an API with Mu and Nu
22:28:56 <ski> `Nu f', aka `nu s. f s', is isomorphic to `exists s. (s,s -> f s)'
22:29:06 <ski> the type of `unfoldr' is relevant to consider here
22:29:20 <MuNuFix> Ha ! Do you have any examples ?
22:29:22 <ski> (the naming of `s' suggests that it's an (internal) state of some kind)
22:30:14 <MuNuFix> I was thinking about writing an API which received JSON input and stores it in the DB using Cofree
22:30:30 <ski> and the definition of `Nu' they give in that page is one possible way to *encode* the type `exists s. (s,s -> f s)' (which is pseudo-code, GHC doesn't support `exists' syntax)
22:30:41 <ski> (examples of what ?)
22:30:48 <MuNuFix> The additional elements ( like the id's ,createdDate) etc I wanted to map as the tags of the Cofree algebra
22:30:56 <hphuoc25> metahumor: I tried using different generator for each thread http://lpaste.net/361154. It's still slower than generating all in one thread.
22:31:16 <MuNuFix> Sorry misread your statement ski
22:31:22 <ski> (but to show that the composition here is `id', you also need to know a few logical equivalences, relating `forall' and `exists')
22:32:12 <ski> .. and this is already getting too long. i shouldn't keep you here
22:32:31 <MuNuFix> :) I am out
22:32:33 <ski> maybe i'll be here tomorrow, or later. have fun !
22:32:39 <MuNuFix> Thank you ski !
22:32:44 * ski bows
22:33:04 <MuNuFix> MuNuFix bows too !
22:33:34 <ski> @where CIS194
22:33:34 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
22:33:48 <ski> Clockwise : that ^ has exercises, which you could try if you want
22:35:27 <Clockwise> thanks ski, i'll bookmark it for later when i get the basics down
22:39:11 <ski> > unfoldr (\g0 -> let (n,g1) = randomR (0,10) g0 in guard (n < 10) >> Just (n,g1)) (mkStdGen 1234)
22:39:13 <lambdabot>  [6,3,9,3,1,6,9,1,3,9,0,2,4,8,2,6,8,4,6,2,1,9,4,3,3,5]
22:39:49 <ski> (that's an `unfoldr' example, with a `StdGen' (pseudo-)random number generator *state*)
23:12:44 <sqooq> anyone know of a continuous-time convolution approximation
23:35:55 <fraktor> I'm trying to learn haskell, and I'm working through project euler right now. I'm working on problem number 9, which involves pythagorean triples.
23:36:09 <fraktor> I've got some code, but for some reason it's not loading in GHCi.
23:36:30 <fraktor> https://paste.ubuntu.com/26270012/
23:37:18 <fraktor> I keep getting the error message "Parse error in pattern: pythag" on line 10.
23:38:09 <LiaoTao> fraktor: Parentheses around the (a:b:xs)
23:38:14 <fraktor> Oh.
23:38:16 <fraktor> wow.
23:38:18 <fraktor> Thank you so much.
23:38:31 <LiaoTao> np
23:40:36 <geekosaur> just remember that patterns parse the same way as expressions. foo a:b:xs is (foo a) : b : xs
23:53:22 <olligobber> > let b+1 = 2
23:53:24 <lambdabot>  <no location info>: error: not an expression: ‘let b+1 = 2’
23:53:33 <olligobber> > let b+1 = 2 in print b
23:53:35 <lambdabot>  <IO ()>
23:53:59 <olligobber> > let b+1 = 2 in b
23:54:01 <lambdabot>  b
23:54:16 <osa1> wat
23:54:26 <olligobber> worth a try
23:55:03 <osa1> > case 2 of n+1 -> n
23:55:05 <lambdabot>  <hint>:1:11: error: Parse error in pattern: n + 1
23:55:29 <amalloy> >let b+1 = 2 in 5+1
23:55:37 <olligobber> > case 2 of succ n -> n
23:55:38 <osa1> need -XNPlusKPatterns
23:55:39 <lambdabot>  <hint>:1:11: error: Parse error in pattern: succ
23:55:42 <amalloy> > let b+1 = 2 in 5+1
23:55:43 <MarcelineVQ> you're actually defining + there not a binding for b.   let (+) b 1 = 2 in b  but this latter b wasn't really bound
23:55:43 <lambdabot>  2
23:55:59 <olligobber> MarcelineVQ, oh... wow
23:56:53 <osa1> olligobber: but see also -XNPlusKPatterns
23:56:56 <olligobber> > let b+1 = 2 in 5+5
23:56:57 <MarcelineVQ> > let b+1 = 2 in 5+1
23:56:58 <lambdabot>  *Exception: <interactive>:3:5-11: Non-exhaustive patterns in function +
23:56:59 <lambdabot>  2
23:57:01 <MarcelineVQ> :>
23:57:22 <MarcelineVQ> agree that n+k are also interesting
23:57:24 <olligobber> oh, it's defining (+1) b as 2
23:57:46 <olligobber> then applying it to 5
23:57:54 <olligobber> nice
23:58:08 <amalloy> well, it's defining the function (+) using a non-exhaustive pattern, which matches only if the second argument is 1
23:58:20 <amalloy> in which case, it ignores the first argument and returns 2
23:58:43 <kadoban> That's not actually an n+k pattern, right?
23:58:51 <amalloy> indeed
