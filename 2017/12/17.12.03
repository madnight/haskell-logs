00:05:10 <jle`> yeah i just ended up imperatively building up the grid and checking all 8 neighbors
00:06:21 <jle`> slowly climbing up the #haskell leaderboard
00:09:07 <jle`> also why is there an stimes but no mtimes
00:16:42 <cocreature> jle`: there is an mtimesDefault
00:17:57 <jle`> why isn't it just called mtimes? :'(
00:20:20 <cocreature> yeah it’s weird
00:24:14 <Unhammer> say I've got `getThing :: IO (Maybe Int)` which returns Nothing when there are no more things to get, and `getAllTheThings = unfoldM getThing`, but now I'd like to let `getThing` also fail with a message, in which case getAllTheThings should give e.g. Left String instead of Right [Int]. What's 
00:24:26 <Unhammer> the most idiomatic way of doing this?
00:24:30 <Unhammer> SomeException?
00:24:48 <Unhammer> or something like `data Got a = Got a | Begotten| Illgotten String`
00:24:57 <Unhammer> or something completely different?
00:25:12 <cocreature> Unhammer: which "unfoldM" are you using here?
00:25:22 <Unhammer> https://hackage.haskell.org/package/monad-loops-0.4.3/docs/src/Control-Monad-Loops.html#unfoldM
00:25:29 <Unhammer> oh, that's not a standard thing …
00:25:44 <cocreature> there are various unfoldM functions, so I’m just making sure we are talking about the same thing :)
00:25:55 <Unhammer> (working on stuff someone else wrote, so not always sure where things are from)
00:26:03 <Unhammer> ok :)
00:26:21 <cocreature> Unhammer: so you want getThing to have two different kind of “failures” one that signifies that there are no more elements and one that there has been an error?
00:26:42 <Unhammer> yeah, and on the "no more elts", I'd like to return the elts so far, but on error just the error
00:27:15 <jle`> getThing :: IO (Either (Maybe String) a) ?
00:28:04 <cocreature> if you use "getThing :: ExceptT String (Maybe a)" "unfoldM" should “do the right thing”
00:28:22 <cocreature> eh that’s missing an IO
00:28:22 <Unhammer> jle` and writing my own version of unfoldM? (In that case, I think I'd use a `data Got` just to make it more explicit what's going on)
00:29:06 <cocreature> I’d probably use ExceptT and then convert the result I get from unfoldM in a more explicit type
00:29:17 <jle`> Unhammer: do you mean getThing :: IO (Either String a) ?
00:29:22 <Unhammer> hm
00:29:35 <jle`> as in, is there a way to "succesfully" end
00:29:37 <Unhammer> jle` the reason for the Maybe is because I have to signify when to stop
00:29:43 <jle`> or are all endings signify failure
00:29:46 <Unhammer> yeah, the Nothing is success
00:30:31 <jle`> so getAllThings :: IO (Either ([a], String) [a]), or getAllThings :: IO ([a], Maybe a)
00:30:38 <jle`> are both sensible ways of doing this, i think
00:31:17 <jle`> sorry, IO ([a], Maybe String)
00:31:27 <jle`> they're actually equivalent because of algebra
00:31:32 * hackage jni 0.5.0 - Complete JNI raw bindings.  https://hackage.haskell.org/package/jni-0.5.0 (MathieuBoespflug)
00:32:20 <jle`> (x*y)+x  ==   x*(y+1)
00:33:30 <Unhammer> jle` in which case I'd write my own version of unfoldM?
00:33:35 <jle`> yes
00:33:41 <jle`> it's not like unfoldM is a popular function anyway
00:34:30 <jle`> some of this also depends on what you actually want to do with the result
00:34:52 <jle`> you could even make your own version of list, if how you're using the result is suitable
00:34:59 <cocreature> I’m not sure why that’s preferrable over ExceptT and reusing unfoldM
00:35:31 <jle`> ExceptT would throw away the list if there's an error i think?
00:35:39 <jle`> so you can't get the partial list
00:35:42 <cocreature> right but Unhammer said that’s what they want
00:35:47 <cocreature> at least that was my understanding
00:35:52 <Unhammer> yeah, I don't care about results on exceptions
00:36:04 <Unhammer> or failures or whatever we call it
00:36:05 <jle`> oh, yes i missed that message
00:36:19 <jle`> yeah ExceptT + unfoldM would probably be nicer in that case
00:38:22 <Unhammer> does that use Control.Exception under the hood?
00:38:26 <cocreature> no
00:39:09 <cocreature> "ExceptT e m a" is a newtype wrapper around "m (Either e a)" with a Monad instance that combines the shortcircuiting of Either with whatever m does
00:40:40 <Unhammer> ok … and Control.Exception you'd typically use where it really is exceptional and it doesn't make sense to expect the outer layer to deal with all such cases?
00:41:09 <jle`> Control.Exception is usually for runtime exceptions
00:41:12 <jle`> er
00:41:20 <jle`> Control.Exception is for using ghc's runtime mechanisms
00:41:23 <jle`> and is usually for IO exceptions
00:41:57 <Unhammer> ok, makes sense
00:42:25 <cocreature> I would use Control.Exception if a) crashing is an acceptable way to handle that failure and b) I don’t want to handle the error immediately
00:42:55 <cocreature> and yeah, don’t use Control.Exception outside of IO
00:44:11 <Unhammer> this was really helpful, thanks jle` & cocreature :)
00:44:17 <jle`> np!
00:49:54 <jcarpenter2> yw
01:02:25 <jcarpenter2> ah yes, the haskell elevator
01:02:38 <jcarpenter2> "lift $ lift $ lift $ makeCaptcha" - Server.hs
01:21:17 <xacktm> did you guys solve AoC 3p1 analytically or with code?  I couldn't find a way to represent coords in code...
01:21:52 * hackage linear-socket 0.3.3.0 - Initial project template from stack  https://hackage.haskell.org/package/linear-socket-0.3.3.0 (alleledev)
01:24:53 * hackage linear-socket 0.3.3.1 - TYped sockets  https://hackage.haskell.org/package/linear-socket-0.3.3.1 (alleledev)
01:25:43 <xacktm> although now I can see how to turn the analytical solution into an algorithm, d'oh
01:26:54 * hackage linear-socket 0.3.3.2 - Typed sockets  https://hackage.haskell.org/package/linear-socket-0.3.3.2 (alleledev)
01:27:20 <jle`> xacktm: i brute forced it
01:27:37 <MarcelineVQ> if analytical means staring at the example until a consistent pattern between the numbers grid position and it's order appears, then both
01:28:15 <jle`> a simple way to represent a coordinate in Haskell is with a tuple, like (Int, Int)
01:28:27 <jle`> xacktm ^
01:28:48 <jle`> i used (Sum Int, Sum Int) so i could have `x <> y` be coordinate addition hehe
01:30:17 <xacktm> oh yeah I know how to represent it, but I couldn't see a clear way to get from the number to the coordinate parts
01:31:20 <jle`> yeah i just brute forced it ._.
01:31:21 <xacktm> not sure how much spoilers I can reveal now, but I ended up "turtling" my way from the nearest square, on paper 
01:31:48 <jle`> if you don't care about spoilers, here's how i did it https://github.com/mstksg/advent-of-code-2017/blob/master/src/AOC2017/Day03.hs
01:31:55 <MarcelineVQ> turtle is also how I would describe the method I ended up with
01:32:30 <jle`> relevant lines are 33-41
01:32:46 <xacktm> think I'm going to hold off on clicking :P   p2 looks like I need to represetn the grid
01:33:11 <jle`> i would really have rather thought of a nice mathematical/analytial way to figure out p1, but i couldn't think of one v.v
01:33:34 <jle`> i built the grid for p2 but it wasn't necessary for p1 for me
01:35:36 <xacktm> aye, gonna sleep on p2 though.  Haskell sure is fun :)
01:35:58 <jle`> but i built something for P1 that made the grid really easy to build for p2
01:36:06 <jle`> xacktm: definitely :)
01:47:35 <cocreature> for p1 I have what I would call an analytical solution
01:47:47 <cocreature> but I couldn’t come up with one for p2
03:49:13 <vaibhavsagar> is anyone doing a haskell advent series this year?
04:02:24 <aku> How do I bind the type information while pattern matching?
04:02:42 <aku> `converseFromList :: MyList a -> [a] converseFromList (Cons x xs) = x::converseFromList(xs) converseFromList Nil = []`
04:03:42 <aku> converseFromList (Cons x xs) = x :: converseFromList(xs)
04:03:51 <aku> This gives a type error!
04:04:13 <liste> aku: use : instead of ::
04:04:28 <liste> :: means type annotation
04:04:35 <liste> it's Haskell, not ML :)
04:07:11 <aku> liste: ohh...srry, I just didn't notice, I am used to Scala
04:23:01 <ben_____> hi hi
04:23:42 <ben_____> this place friendly to haskell newbies?
04:24:04 <sbrg> yes
04:24:08 <ben_____> ^_^
04:25:02 <ben_____> starting a haskell course next semester. was recommended that I get in here.
04:25:48 <ben_____> ...so here I am :)
04:25:52 <cocreature> welcome :)
04:26:18 <sbrg> ben_____: prepare to get your mind blown, bruv. 
04:26:27 <ben_____> hehe
04:28:08 <ben_____> sbrg: i've heard rumours :P 
04:28:39 <vaibhavsagar> ben_____: has #haskell-beginners also been recommended to you?
04:28:49 <ben_____> "the functional side of programming is a pathway to many abilities, some considered unnatural"
04:30:22 <ben_____> vaibhavsagar: not until just now. I'll let the lecturer know, she might add it to the list :)
04:30:41 <cocreature> beginner questions are perfectly fine here, no need to go to a separate channel for that
04:32:16 <ben_____> cocreature: thanks for the support (though i read that as "if here doesn't help like you hoped, hope is not lost, for there is another place to go")
04:34:46 <tdammers> #haskell is one of the friendliest and most helpful places on the internet I've ever seen
04:34:54 <[Leary]> Sometimes this place is aflood with amazing discussions about traversablecolenspremonadsheaves and the like, so I'm sure it's good to have a more beginner focused place to go too.
04:35:20 <ben_____> so my first question is this: I'm doing calc, dealing with chain rule, integrating powers of sin and cos, etc... I've been getting value out of mentally transcribing *that* into something that (i think) looks like func prog
04:35:57 <sbrg> That is certainly a problem that you can represent and solve pretty elegantly in Haskell
04:36:06 <ben_____> tdammers: friendlier than /r/wholesomememes? (helpfullness doesn't apply in that comparison)
04:36:22 <tdammers> ben_____: different kind of friendly
04:38:16 <ben_____> another question - "f(x) = sin(x) find f'(x)" in my mind i map that to deriv(f(x)) then define f(x) as returning sin(x) normally, BUT IF it was called because it's an argument of deriv, it returns deriv(x) * cos(x)
04:39:19 <ben_____> so... in speaking with someone that has only heard of func prog, have i got the right idea?
04:39:26 <liste> ben_____: it's deriv(f), not deriv(f(x))
04:39:44 <ben_____> tdammers: true
04:39:44 <tdammers> ben_____: well, the "best" solution is just f' =  cos, but that is probably not what is asked
04:40:31 <tdammers> I think the teaching goal here is to develop a function deriv that is a good enough approximation of the real thing
04:40:54 <tdammers> that is, you want a function deriv :: (Double -> Double) -> (Double -> Double)
04:41:05 <wz1000> hmm. does stack not support cabal 2.0 yet?
04:41:05 <[Leary]> The behaviour of f never changes, otherwise it isn't a function. It's not allowed to know what's calling it.
04:41:06 <tdammers> such that deriv f == f'
04:41:59 <ben_____> liste: that raises a few questions in my mind. pertinent one being "how does the syntax deriv(f) give that function the information it needs to derive the argument of f, as you do with the chain rule" but i don't think im ready for that. 
04:42:29 <tdammers> oh wait, so you want the chain rule
04:42:37 <liste> ben_____: the key thought is that we have functions that operate on functions
04:42:51 <liste> ben_____: so 'deriv' is a function that has a function as a parameter
04:43:22 <ben_____> [Leary]: okay. That tells me that I will need to update my thinking. liste seems to be helping me with that.
04:44:05 <tdammers> so you're not actually asking for deriv f, but deriv (f . g)
04:44:05 <ben_____> liste: so how do we model the behaviour of the chain rule on sin(x)
04:44:56 <tdammers> ben_____: you can either implement the "good enough approximation" approach, in which case you just feed the composed function to deriv and ignore the chain rule entierly
04:45:01 <liste> ben_____: well if all we know about functions is how to evaluate them, we can't - we need to do numerical differentiation
04:45:19 <ben_____> f(x) = sin(g(x)), f'(x) = g'(x)*cos(g(x))... is expressed in haskell closer to "deriv(f . g)"?
04:45:30 <liste> ben_____: IF OTOH we also know what the functions are, then we can apply rules based on the functions
04:45:43 <tdammers> ben_____: or you implement data structures that *represent* the functions you want to model and possible combinations, and then express derivation and chain rules as functions of those abstract representations
04:45:51 <tdammers> and also you implement an "interpreter"
04:46:33 <ben_____> mkay. I'm not taking all this in, but I *am* taking notes
04:47:02 <liste> ben_____: eg. deriv(Constant _) = 0, deriv(LinearTerm x) = 1 etc
04:47:17 <tdammers> exactly
04:47:34 <tdammers> and then the chain rule would be deriv(Composed f g) = ?
04:48:14 <ben_____> tdammers: "exactly" in response to my "is expressed in haskell..."?
04:48:29 <sbrg> ben_____: the problem is essentially that you can't inspect functions in Haskell. they're just black boxes. so you need to go one level up in terms of abstraction and represent the functions as some datastructures as in liste's example. 
04:48:30 <tdammers> ben_____: no, to liste's eg.
04:48:43 <ben_____> tdammers: cheers
04:49:17 <ben_____> mkay.
04:50:11 <ben_____> what about this. make a function like "poly_deriv" that takes a tuple to express a polynomial, and returns its derivative?
04:51:16 <liste> ben_____: that sounds sensible (though in Haskell you'd use a list)
04:51:31 <ben_____> cool :)
04:52:28 <ben_____> i have an interesting question now: what excites/interests you about functional programming?
04:53:19 <sbrg> ben_____: yeah, you can represent a polynomial using a list where indices are exponents and values are coefficients. with such a representation, implementing the derivative is very simple.
04:54:13 <ben_____> mapping C to haskell, array maps to list?
04:54:51 <liste> ben_____: not quite
04:54:51 <tdammers> no, Haskell lists are singly-linked lists; if you want those in C, you have to implement them yourself
04:54:57 <ben_____> nvm, that's a question I should be able to look up myself :P
04:55:17 <liste> ben_____: you'd typically NOT use linked lists in C, but in Haskell they're quite useful
04:55:24 <tdammers> something like struct list_node { some_type *value, list_node *next }
04:55:29 <ben_____> (but thanks)
04:55:48 <ben_____> oh yeah, more than familiar with linked lists (assignment 2 flashbacks)
04:55:55 <liste> OTOH in Haskell arrays are only useful in some specific circumstances
04:56:11 <tdammers> linked lists are more popular in FP because they are particularly useful with pure values and pure functions
04:56:33 <sbrg> > let polyDeriv poly = tail $ zipWith (*) [0..] poly in polyDeriv in polyDeriv [6, 5, 4, 3] -- d 3x³ + 4x² + 5x + 6 = 9x² + 8x + 5
04:56:35 <lambdabot>  <hint>:1:65: error: parse error on input ‘in’
04:56:44 <sbrg> > let polyDeriv poly = tail $ zipWith (*) [0..] poly in polyDeriv [6, 5, 4, 3] -- d 3x³ + 4x² + 5x + 6 = 9x² + 8x + 5
04:56:46 <lambdabot>  [5,8,9]
04:56:54 <tdammers> in Haskell, the combination of non-strict evaluation and GC is especially useful, because it means that traversing a singly-linked list once often amounts to running in constant memory
05:00:04 <ben_____> I'm interested in what interests you with functional programming.
05:00:16 <ben_____> why draws *you* into it?
05:00:49 <sbrg> ben_____: the reason I like functional programming is that it is elegant and robust and lets me reason about problems on a much higher level than most imperative languages
05:01:16 <sbrg> I don't think have to think in terms of loops and updates to mutable datastructures. I can think in terms of high level transformations on the data
05:01:48 <sbrg> combined with referential transparency can in some cases make it pretty trivial to take a function and prove that its correct via equational reasoning
05:02:50 <Tuplanolla> My short answer, ben_____: it allows me to think the way I want to think.
05:03:16 <ben_____> that's something that I'm keen on. How it might give me a perspective of correctness proof
05:03:59 <ben_____> Tuplanolla: i like that! I'm keen to hear the long answer also :)
05:04:01 <sbrg> not that it's probably not simple for most complicated code, and once things like IO come into the mix a lot of guarantees go out the window. 
05:04:06 <sbrg> note* 
05:05:21 <ben_____> I first got *really* interested in functional when I heard SEL4 (proven-secure OS) uses haskell as a tool to prove their system
05:05:38 <ben_____> interested -> curios
05:06:00 <Tuplanolla> I thought seL4 is in Isabelle.
05:06:22 <erisco> how do you use Haskell to prove things?
05:07:07 <ben_____> they use that for the math proof, but haskell is used as part of the process to eventually get the proven logic into C source code
05:07:31 <Tuplanolla> Oh, proof extraction.
05:07:38 <erisco> mm… Haskell as duct tape… how dignified
05:07:49 <Tuplanolla> There's a book about this.
05:07:52 <Tuplanolla> @where sf
05:07:52 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
05:07:52 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
05:08:20 <ben_____> I also think they reverse the binary into haskell, and use the result of that reverse to prove the binary is correct
05:08:49 <erisco> really? that seems frivolous because you have to prove the compiler
05:08:56 <erisco> or the decompiler, as some would call it
05:10:43 <ben_____> erisco: I should probably qualify, at this point, that I'm first year - I probably have some key details wrong.
05:11:05 <erisco> well I don't know, you could be right
05:11:18 <erisco> I am just thinking that if they authored the code generation that they'd just prove the code generator correct
05:11:39 <ben_____> but what I CAN say, is that thay have formally varified the binary. My understanding is they reversed it into haskell as part of that process.
05:12:00 <erisco> or maybe it is gcc that is a blackbox to them, so they are verifying its output
05:12:55 <WinterFox[m]> I'm trying to write a function that removes all whitespace from a string but I can't find a way to remove a whitespace at the end of the string. This is what I have so far https://bpaste.net/show/7ab6d3bfaded
05:13:25 <erisco> WinterFox[m], make the end the start
05:13:48 <ben_____> They did mention that they are working on developing a software engineering system that takes their lessons in writing a proven OS, so that writing proven-secure software is relatively trivial compared to current practice
05:14:11 <WinterFox[m]> Ah nvm I think I worked it out
05:14:21 <erisco> you can also do this with foldr but that will take more thinking
05:14:30 <Tuplanolla> That's a great use of "relatively trivial".
05:14:39 <erisco> haha
05:15:31 <erisco> I wonder what their qualities of security are
05:16:00 <ben_____> erisco: re gcc - They did mention "in a reduced C set", which hints to me that they only use functions which comply with their process to maintain formal proof. 
05:16:24 * hackage rocksdb-haskell 1.0.1 - Haskell bindings to RocksDB  https://hackage.haskell.org/package/rocksdb-haskell-1.0.1 (gromak)
05:16:25 <erisco> on top of mistakes like buffer overflows, dangling pointers, etc, is security problems which are domain specific
05:16:41 <erisco> you know, the things like user A shouldn't be able to read the files owned by user B
05:17:03 <fakenullie> Such as dumb mistake apple did recently
05:17:27 <ben_____> they gave the source code to US 3-letter agencies, the root password to the linux kernal on top of SEL4... couldn't do anything to the SEL4 managed stuff
05:17:53 <erisco> or that your cache server should not serve cached authenticated pages to the wrong users…
05:17:59 * erisco glares at Steam
05:19:07 <ben_____> The boeng UAV chopper that the navy uses runs on it (memory serving me correctly) - the level of pen-testing ive heard it withstand... I raised an eyebrow.
05:20:35 <[Leary]> WinterFox[m]—you may want to look into filter.
05:21:04 <WinterFox[m]> [Leary]: Yep, I just submitted my solution and saw someone did it with filter which is so much better.
05:21:20 <WinterFox[m]> Just didn't occur to me at the time :P
05:21:34 <erisco> how does filter solve the problem?
05:21:53 * hackage texbuilder 0.1.1.3 - View your latex output while editing  https://hackage.haskell.org/package/texbuilder-0.1.1.3 (xaverdh)
05:21:53 <WinterFox[m]> noSpace = filter (/=' ')
05:22:03 <erisco> > filter (/= ' ') "hello world"
05:22:05 <lambdabot>  "helloworld"
05:22:06 <erisco> doesn't look right to me
05:22:26 <WinterFox[m]> it's meant to remove all spaces
05:22:32 <erisco> you didn't say that
05:23:00 <WinterFox[m]> I said whitespace but really its just spaces
05:23:06 <erisco> or maybe you said both and I remembered just one, okay ;)
05:23:15 <ben_____> anyway. getting late. you guys have been amazing. Look forward to getting into it!
05:24:28 <erisco> WinterFox[m], noSpace [] = []; noSpace (' ':xs) = noSpace xs; noSpace (x:xs) = x : noSpace xs
05:27:29 <erisco> > (snd . foldr (\x ba@(b, a) -> if b && x == ' ' then ba else (False, x:a)) (True, "")) "hello world  "
05:27:32 <lambdabot>  "hello world"
05:30:51 <erisco> > (maximumBy length . filter (\p -> nil p || last p /= ' ') . inits) "hello world  "
05:30:53 <lambdabot>  error:
05:30:53 <lambdabot>      • Couldn't match type ‘Int’ with ‘[Char] -> Ordering’
05:30:53 <lambdabot>        Expected type: [Char] -> [Char] -> Ordering
05:31:08 <erisco> > (maximumBy (comparing length) . filter (\p -> nil p || last p /= ' ') . inits) "hello world  "
05:31:10 <lambdabot>  error:
05:31:10 <lambdabot>      Variable not in scope: nil :: [Char] -> Bool
05:31:20 <erisco> > (maximumBy (comparing length) . filter (\p -> null p || last p /= ' ') . inits) "hello world  "
05:31:21 <lambdabot>  "hello world"
05:31:42 <erisco> that's the logic programming version :P
05:38:42 <Tuplanolla> > liftA2 (.) dropWhileEnd dropWhile isSpace " hello world "
05:38:45 <lambdabot>  "hello world"
05:39:31 <erisco> > "hello world" :: Text
05:39:34 <lambdabot>  error:
05:39:34 <lambdabot>      Not in scope: type constructor or class ‘Text’
06:06:00 <drdo> Are there any tools to help figure out what versions of dependencies you need?
06:15:57 <aku>  data Tree a = Node a (Tree a) (Tree a) | Leaf a deriving (Show)
06:16:02 <aku> height (Leaf _) = 1
06:16:06 <aku> height (Node _ left right) = 1 + max(height left, height right)
06:16:15 <aku> I am getting a type error!
06:17:02 <octarin> :t max
06:17:03 <lambdabot> Ord a => a -> a -> a
06:17:28 <octarin> you gave it (int,int)
06:17:35 <octarin> Int*
06:18:27 <aku> That's C++ syntax
06:18:29 <aku> Srry
06:18:30 <ggVGc> :t sum
06:18:32 <lambdabot> (Num a, Foldable t) => t a -> a
06:18:47 <aku> Got it
06:19:06 <aku> It doesn't click so early
06:21:09 <sbrg> drdo: Maybe `stack solver` can help you? 
06:21:30 <sbrg> drdo: but otherwise just using the snapshots from stackage is an easy way to avoid that problem altogether
06:21:37 <aku> :quit
06:21:39 <aku> :q
06:21:49 <drdo> sbrg: I mean when writing a cabal file for your project
06:22:06 <drdo> I suppose I want the broadest range of versions that will work
06:22:32 <drdo> And digging through hackage versions for every package manually is a drag
06:22:34 <sbrg> drdo: well, if you intend for people to use stack to build your project, there is no need for version bounds since you have specified a snapshot in your stack.yaml.
06:22:46 <sbrg> naturally, it's still useful to have version bounds for people who'd like to build your code using cabal
06:22:50 <drdo> That sounds quite restrictive
06:22:52 <Reisen> Is it possible to build statically linked, position independent code with GHC? I.E, a piece of code capable of being bitwise copied to any memory address and work without linker fixups?
06:23:35 <ggVGc> why isn't List.sum changed to use foldl'?
06:23:38 <ggVGc> would it break any code?
06:23:41 <ggVGc> I guess it would
06:23:44 <ggVGc> in some cases
06:24:27 <Wizek> Anyone here used the Chart package? 
06:24:58 <Wizek> I'm getting a `No instance for (PlotValue UTCTime) arising from a use of ‘toFile’`
06:25:37 <Wizek> When AFACT I am only trying to use time for the axis, not the value
06:27:05 <sbrg> Wizek: googling "haskell chart plotvalue" incidentally brought me to exactly the same issue you are experiencing: https://github.com/timbod7/haskell-chart/issues/48
06:29:09 <Wizek> sbrg: than's for that lead, I'm following it atmn
06:29:11 <Wizek> -n
06:36:16 <Wizek> sbrg: whoop-whoop, it worked! If I put in a little `utcToLocalTime utc` in there. Thanks again.
06:36:23 <sbrg> yw!
07:15:25 <daey> I am trying to write a function that creates a list with X members. i now know that 'replicate' does that exact thing. but i would like to know how to fix my version.
07:15:30 <daey> http://lpaste.net/360472
07:30:59 <Cale> daey: (:) :: a -> [a] -> [a]
07:31:20 <Cale> daey: You must apply it to a single element on the left, and the remainder of the list, on the right
07:31:55 <Cale> daey: It looks like in the case at hand, you're applying (:) to two Strings
07:32:02 <Cale> which can never be right
07:32:15 <daey> Cale: i can see the problem, and i can not see it
07:32:19 <Cale> It would either have to be a Char and a String, or a String and a list of Strings
07:32:27 <daey> i mean, if this were evaluated at runtime it would pass right?
07:32:31 <Cale> no
07:32:43 <daey> but im doing a : a : a : []
07:32:43 <Cale> This doesn't make sense at runtime either
07:32:56 <Cale> Are you?
07:33:00 <Cale> You have  tst'
07:33:01 <Cale> oops
07:33:07 <Cale> You have  tst' a (b-1) : a
07:33:29 <daey> yeah but im calling it from tst which brings the []
07:33:35 <Cale> huh?
07:33:36 <fakenullie> how can I split string by substring, i.e. f "bc" "abcb"  = ["a", "b"]
07:34:12 <Cale> fakenullie: Look at https://hackage.haskell.org/package/split-0.2.3.2/docs/Data-List-Split.html
07:34:22 <Cale> fakenullie: splitOn is what you want
07:34:40 <mniip> jinxd
07:35:09 <Cale> daey: So, let's look at an example
07:35:30 <Cale> daey: Suppose a = "xyz", and we have b = 1
07:35:32 <mnoonan> daey: maybe put parens in. you’re doing ((a : a) : a) : [], when you want to be doing a : (a : (a : []))
07:35:49 <mnoonan> (er, parens in to your thoughts, not the code :)
07:35:56 <fakenullie> Cale: thanks
07:36:32 <Cale> Then tst' "xyz" 1 = tst' "xyz" 0 : "xyz"
07:36:46 <Cale> = "" : "xyz"
07:37:10 <Cale> But "" is not a Char, so it has no business being on the left side of a (:) which has "xyz" on its right
07:38:47 <simendsjo> Has someone written a list of haskell "design patterns"? I'm thinking about common ways to solve everyday needs like Control.Exception.bracket. Once you know what you're looking for, searching for bracket directly yields lots of results, but I would like to see a lit which just says "- Aquire, use, release resource: Control.Exception.bracket" and so on. Does anything like this exist? Another example could be "- Read and modify nested
07:38:47 <simendsjo> structures: Lens"
07:39:27 <daey> forgot the 'a b' in line 2 in my inital paste http://lpaste.net/360473 *doesnt change the problem obviously*
07:41:04 <Cale> simendsjo: In the limit, this just reduces to all the libraries in the world
07:41:06 <mniip> daey, in the |b>0 case
07:41:17 <mniip> daey, you have a::String
07:41:24 <mniip> so (_:a)
07:41:28 <mniip> would expect _::Char
07:41:36 <mniip> yet evidently the lhs is not a Char
07:41:49 <Cale> simendsjo: I guess the design pattern behind bracket is that bracket is taking the continuation which handles the resource as an argument
07:42:01 <mniip> oh I see Cale basically explained the same
07:42:04 <Cale> (so, continuation passing style)
07:42:08 <simendsjo> Cale: Maybe, but there's an abundance of libraries on Hackage, many which solves the same problem, and many with less than optimal introduction material.
07:43:12 <Tuplanolla> Aren't design patterns supposed to be general solutions that cannot be extracted into packages, simendsjo?
07:43:39 <Cale> Yeah, I would hesitate to call anything which can be codified within the language as a design pattern.
07:43:40 <Tuplanolla> Like the existential type class pattern.
07:45:22 <simendsjo> Ok, maybe design pattern is not the best description. But trying to get comfortable with a new ecosystem in a foreign language is quite difficult. It's easy to just fall down the rabbit-hole of haskell without ever being able to focus on the practical parts.
07:45:38 <Cale> Design patterns are repetition which the language is incapable of abstracting over -- i.e. they're indications of language deficiencies. Haskell has a few of those depending on what you count.
07:45:43 <ertes> why do we have to adopt the OO sense of "design pattern"?  to me 'withFile' does use a pattern
07:45:47 <simendsjo> Choosing which sql library to use is alone a very difficult task.
07:45:55 <ertes> and that pattern can very well be codified in haskell (ContT, Codensity)
07:46:09 <ertes> does withFile stop being a pattern, as soon as you know about ContT?
07:46:22 <Cale> ertes: withFile doesn't actually use ContT though
07:47:14 <ertes> Cale: but (forall r. (Handle -> IO r) -> IO r) ≃ Codensity IO Handle
07:47:34 <Cale> It's isomorphic to, but not equal to. :)
07:48:15 <ertes> yeah, that's why in my mind withFile is an instance of the "codensity pattern", if you will
07:48:51 <Tuplanolla> Sure.
07:49:23 <Cale> Yeah, there's maybe a little bit of a pattern there, in the continuation passing style in general. It's such a small thing and such an immediate consequence of functions being first class, but nevertheless.
07:49:49 <cocreature> it’s a small thing once you’ve written Haskell for several years :)
07:50:03 <Cale> simendsjo: Picking a SQL library doesn't stop being difficult when you're good at Haskell.
07:50:11 <mniip> idk, I only learned about ContT last week :P
07:50:26 <Cale> simendsjo: They're all awkward compromises to some extent.
07:50:31 <mniip> No, I mean, I knew it for a long while but only intentionally decided to figure out how it works
07:50:34 <ertes> Cale: your haskell experience may be blinding you to how huge such a pattern looks once you program in a different language =)
07:50:48 <Tuplanolla> Now the mutable variable pattern...
07:51:02 <ertes> traverse (Codensity . withFile ReadMode) fps  -- imagine doing something like this in C# =)
07:51:30 <ertes> or even in haskell without Codensity
07:51:56 <Cale> ertes: Well, I generally wouldn't use Codensity simply because it doesn't really buy you very much in most circumstances.
07:51:59 <Cale> yeah
07:52:15 <simendsjo> Cale: Ok, maybe I should have used a smaller example :) I've just used .NET for many years, and they give me batteries included. In Haskell, I have to choose what libraries to learn to "build" my own "standard" library. I've thought about sorting Hackage by number of downloads and start from the most used libraries, but that might not be the best learning experience..
07:52:34 <Cale> in C#, it turns into a whole bunch of repetitive noise which is worth pointing out because the language doesn't abstract over it very well.
07:52:55 <Cale> Well, maybe C# has enough features now that it's not so bad?
07:53:08 <Cale> But at least, back when I looked at C# ;)
07:53:12 <ertes> i wouldn't even know how to do it in C#…  perhaps using recursion
07:53:27 <ertes> "using" recursion =)
07:53:31 <cocreature> iirc there is a website of curated libraries
07:53:37 <simendsjo> C# is a pretty decent language, but it's still severly lacking in terms of abstraction even though they have managed to fix a lot of the smaller day-to-day issues.
07:53:57 <Cale> ertes: Oh, sorry, I didn't properly read the line of code you had there. :)
07:54:33 <simendsjo> .. generic programming is a real pain and is pretty much impossible to hide from the library user once you start with anything a little more than basic collection-style generics.
07:54:53 <Cale> ertes: Yeah, that kind of trickery would be pretty interesting :)
07:55:02 <simendsjo> cocreature: What site?
07:55:25 <cocreature> simendsjo: I’m searching for it, give me a minute :)
07:55:27 <Cale> ertes: You should be able to do it with recursion though, yeah.
07:56:02 <ertes> Cale: and of course C# doesn't do TCO =)
07:56:09 <Cale> https://ocharles.org.uk/blog/
07:56:21 <ertes> Codensity is also useful just to pile up a bunch of "run later" actions
07:56:30 <Cale> ^^ this guy has a lot of little package intros on his blog you might be interested in simendsjo 
07:56:46 <ertes> @let import Control.Monad.Codensity
07:56:48 <lambdabot>  Defined.
07:56:51 <cocreature> simendsjo: https://haskell-lang.org/libraries has a very basic overview. https://haskelliseasy.readthedocs.io/en/latest/ covers a lot more
07:57:03 <ertes> @let later c = Codensity (\k -> k () <* c)
07:57:05 <simendsjo> Clae: Nice. I've stumbled across some posts on that site before. I'll look some more into it.
07:57:05 <lambdabot>  Defined.
07:57:07 * hackage bindings-linux-videodev2 0.1.0.1 - bindings to Video For Linux Two (v4l2) kernel interfaces  https://hackage.haskell.org/package/bindings-linux-videodev2-0.1.0.1 (ClaudeHeilandAllen)
07:57:52 <markus1189> Is there some way to 'lift' the 'local' from Reader to ParsecT?  I'm looking for this: parsecLocal :: (e -> e) -> ParsecT String () (Reader e) a -> ParsecT String () (Reader e) a
07:57:54 <simendsjo> cocreature: Thanks. Those look very nice.
07:58:22 <Cale> Most of the ones he covers are things that are worth knowing about, even if there are better options out there.
08:00:37 <cocreature> markus1189: in general this is covered by "hoist" from the mmorph library https://hackage.haskell.org/package/mmorph-1.1.0/docs/Control-Monad-Morph.html#v:hoist but sadly ParsecT doesn’t provide an instance of MFunctor
08:00:43 <lyxia> markus1189: ParsecT has an instance of MonadReader, which has local.
08:00:50 <simendsjo> Cale: Anything in particular you're disagreeing with?
08:00:53 <cocreature> oh yeah that’s even better
08:01:10 <markus1189> lyxia: ah wow, that means it should just work TM ?
08:01:38 <lyxia> If you use the right 'local' yes
08:02:20 <markus1189> lyxia: thanks
08:02:30 * hackage microsoft-translator 0.1.0.0 - Bindings to the Microsoft Translator API  https://hackage.haskell.org/package/microsoft-translator-0.1.0.0 (Cliff_Harvey)
08:02:37 <markus1189> did not think to look at it that way, but it's really cool
08:03:32 <markus1189> lyxia: jup works \o/
08:04:47 <Cale> simendsjo: Well, mostly it's a matter of personal choices. Like, I probably wouldn't find the occasion to use heist or blaze-html or threepenny-gui off that list just because I really like reflex-dom so much :)
08:07:21 <simendsjo> Cale: reflex isn't exactly beginner friendly :) I looked a bit at miso the other day, which seems more opinionated and beginner friendly, but perhaps a bit strict if you really know what you're doing.
08:07:58 <ggVGc> name one haskell thing that's beginner friendly
08:07:59 <Cale> Yeah, it's something we really need to do more about -- getting beginner materials produced
08:08:27 <Cale> Specifically for reflex, but perhaps for Haskell generally :)
08:09:47 <Cale> There's a lot of stuff in the reflex and reflex-dom libraries which you're not going to use every day, so it's hard when you're starting out and looking through the documentation trying to find the bits you need, if you don't have a more experienced user looking over your shoulder.
08:10:09 <ggVGc> you know what's pretty beginner friendly? Lens
08:10:14 <Cale> haha
08:10:22 <simendsjo> Cale: I would say for Haskell in general. It's so different from what most people are used to that the only ones learning it are those which are ok with spending hundreds of hours of free time just to get going. I failed to learn it back in 2011, and I've been learning the basics again for 1.5 years with good help from the HPFFP book.
08:11:00 <Cale> ggVGc: The sad part is that it really *is* a simple idea, it's just that the lens package carries it to an almost absurd extreme.
08:11:16 <simendsjo> ggVGc: Yeah.. I looked at lens a couple of weeks ago. And just typing Lens here summoned Kmett, which helpfully explained a lot of things way over my head ;)
08:11:52 <Cale> (and then introduces a whole whack of notation on top of that, just to really make the experience bizarre :)
08:12:19 <ggVGc> Cale: yeah I think when I first looked at lens it would have helped if I didn't even know about the operators
08:12:29 <ggVGc> things make a lot more sense if you just look at the basic functions
08:12:30 <Cale> yeah
08:12:31 <ggVGc> like view
08:13:01 <ggVGc> also, I didn't know much about Traversals when I looked at lens
08:13:20 <ggVGc> honestly I still don't have a good grasp of Traversal, and I've been out of haskell for over a year so I'm still brushing up again
08:13:37 <ggVGc> but not being comfortable with Traversal, and going into Lens, is a bit much
08:13:40 <ggVGc> and I think many people do that
08:15:31 <Cale> It would be nice if we had some sort of pedagogical journey through the history of lens, because really all the stuff with Traversals is like the third or fourth variation on the theme
08:16:15 <Cale> and you don't need to understand it at all to use lenses in a basic way, except that now you kind of do because everything's abstracted.
08:16:29 <ggVGc> yeah, but you get into it fairly quickly
08:16:31 <ggVGc> but I agree
08:16:50 <royal_screwup21> I wrote a simple class which takes an Int and returns a Bool like so: https://thepasteb.in/p/DRhjAvML3L8Iy The compiler throws an error though when I try something like yesno 0 - here's the error: https://thepasteb.in/p/Z4hPg4xq1ZNUG how do I fix this?
08:17:32 <Cale> royal_screwup21: It doesn't know which type of number 0 is supposed to be, so it doesn't know which instance of the class it's looking for
08:17:32 <simendsjo> I hope The Joy Of Haskell book might give a continuation coming from the HPFFP book.
08:17:43 <Cale> royal_screwup21: If you write  yesno (0 :: Int)  it should work
08:18:00 <Gurkenglas> ggVGc: A lens is a witness of a record field. A prism is a witness of a constructor. An iso is something that's a lens and a prism. An affine traversal is something that's a lens or a prism. An affine traversal "targets 0 or 1 slots", and then a "traversal targets any nonnegative whole number of slots"
08:18:06 <Cale> royal_screwup21: Or otherwise unambiguously apply yesno to something of type Int, as opposed to a polymorphic thing.
08:18:13 <Cale> :t 0
08:18:14 <lambdabot> Num p => p
08:18:26 <Cale> ... interesting choice of type variable
08:19:22 * hackage haskell-gi-base 0.20.6 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.20.6 (inaki)
08:19:27 <Gurkenglas> -'a "traversal targets' +'a traversal "targets'
08:19:32 <ggVGc> Cale: but, I mean, I personally didn't even have a decent grasp of Applicative when I first got in touch with Lens, and it wasn't apparent to me at first what it was all about
08:20:05 <Cale> ggVGc: For sure. I don't think I really understood what was going on there until I talked to Ed about it.
08:20:46 <Cale> The generalisation to traversals is something that makes you look back at van-Laarhoven style lenses in a new way.
08:20:47 <dminuoso> By Ed do you mean the author of Control.Lens?
08:20:51 <Cale> yes
08:20:59 * hackage firefly 0.2.0.0 - A simple HTTP server framework  https://hackage.haskell.org/package/firefly-0.2.0.0 (ChrisPenner)
08:21:01 <Cale> Ed Kmett
08:21:09 <dminuoso> gotcha
08:21:45 <Cale> ggVGc: And I *did* understand Applicative ;)
08:22:03 <ggVGc> Gurkenglas: thanks :) I am more comfortable with this now though than when I first started about 2 years ago
08:23:55 <ggVGc> In practice I've had some things happen that make me a bit hesitant about using lenses too much. There have been some cases where I've had code act incorrectly, because of using lenses, that typechecked, and that I'm pretty sure I wouldn't have written without lenses
08:23:59 <ggVGc> I canti
08:24:20 <ggVGc> I can't think of the exact instances now, but I think in cases where I've used indexed stuff, and then changed some data type
08:24:31 <ggVGc> and ended up with type checking code that missed some logic
08:24:51 <ggVGc> because it was basically too general
08:26:17 <ggVGc> Cale: fwiw I think this is a fairly okay writeup, https://artyom.me/lens-over-tea-1
08:28:43 <speps> hi
08:29:03 <Gurkenglas> singular casts traversals to traversal1s, unsafeSingular casts traversals to lenses. What other optic casts are possible?
08:30:23 <speps> anyone doing advent of code with haskell this year? my day 3 part 2 solution is quite slow, i got the right answer but would like to improve the speed of it, i used a Data.Map to keep the state of the grid, i suspect that's slow
08:31:21 <royal_screwup21> Cale hmm I'm not sure I understand. I'm looking at this http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102 and I've done exactly as they mentioned. You said to  "unambiguously apply yesno to something of type Int, as opposed to a polymorphic thing" - am I not already doing that with "Instance Yesno Int"?
08:33:26 <royal_screwup21> here's the code https://thepasteb.in/p/DRhjAvML3L8Iy and it returns this error https://thepasteb.in/p/Z4hPg4xq1ZNUG when I type in yesno 0
08:39:28 <EvanR> "the tail function decapitates its argument"
08:42:36 * hackage gi-webkit2webextension 4.0.15 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.15 (inaki)
08:43:54 <kuekerino> ?src show
08:43:54 <lambdabot> show x = shows x ""
08:44:16 <kuekerino> ?src shows
08:44:17 <lambdabot> Source not found.
08:47:54 <Cale> royal_screwup21: The instance Yesno Int just means that if you apply yesno :: (Yesno a) => a -> Int to something of type Int, it will be valid.
08:48:41 <Cale> royal_screwup21: The information about what instances exist doesn't (at least in this case) flow in the other direction, to determine what type of thing yesno was applied to.
08:48:58 <Cale> royal_screwup21: You might, in some future module yet to be compiled, have an instance Yesno String
08:50:26 <Cale> royal_screwup21: The compiler will never assume that it knows all the available instances when determining which instance applies in any given situation, because this makes it a great deal easier to reason about which instance applies. It will just complain in the end, if it really needs an instance and none exists.
09:06:16 <tannmay> hi there
09:06:50 <erisco> hello
09:07:26 <erisco> EvanR, the literary arts documentation of Haskell functions
09:13:27 <erisco> The find function excises the first agreeable item from the rest.
09:13:52 <erisco> I expect an acme prelude with this sort of interesting Haddock docs :)
09:14:31 <kuekerino> ?src showsPrec
09:14:31 <lambdabot> showsPrec _ x s = show x ++ s
09:14:44 <kuekerino> ?src showList
09:14:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:14:59 <erisco> The sort function brings that which is lesser to the van and sends that which is greater to the rear.
09:16:57 <mniip> erisco, "places the inferior ahead of the superior"
09:17:13 <L0g4nAd4ms> i want to write a method that "returns the nth item in a list" ** recurisvely ** . For my idea to solve this i need to find out the index of an element in a list.
09:17:50 <mniip> L0g4nAd4ms, that made no sense to me...
09:18:28 <erisco> do you mean you want to write a recursive function which returns the nth item of a list?
09:18:33 <L0g4nAd4ms> well my signature is :: `nth :: Int -> [a] -> Maybe a`
09:18:40 <L0g4nAd4ms> correct
09:18:41 <mniip> right
09:18:45 <mniip> that much is clear
09:18:54 <mniip> your proposed solution though, can't make sense of it
09:19:08 * erisco defers to mniip
09:19:10 <L0g4nAd4ms> well since i have to solve it by recursion it seems i can not simply use !!
09:19:20 <erisco> stop shouting
09:19:28 <L0g4nAd4ms> i meant `!!` 
09:19:36 * erisco snickers
09:20:39 <mniip> L0g4nAd4ms, yes
09:20:44 <erisco> I think mniip wants to know why you need to know the index of an element in the list
09:20:48 <L0g4nAd4ms> well its kind of confusing how can get the nth item in a list without using the indexing operator
09:20:57 <erisco> that seems backwards from what the problem is
09:21:08 <mniip> are you familiar with pattern matching
09:21:44 <mniip> !! is not a built-in operator. It's a function with a definition like any other
09:22:04 <mniip> your task is to write one yourself (a tiny bit different but still)
09:22:05 <L0g4nAd4ms> yes, i am familar with that and guards.
09:22:14 <mniip> that's the intent
09:22:26 <mniip> use pattern matching and recursion to implement nth
09:22:47 <L0g4nAd4ms> well i just used pattern matching for checking for the empty list and guards for error handling but i still have to come up with the real logic
09:23:07 <erisco> paste your code to lpaste.net and we'll go from there
09:23:39 <mniip> L0g4nAd4ms, pattern matching is pretty much mathematical case analysis
09:23:49 <mniip> haskell lists have two "cases"
09:23:52 <mniip> do you know what those are?
09:24:24 <L0g4nAd4ms> you mean the recursion over lists with x : xs 
09:24:35 <mniip> I mean what I asked
09:25:08 <L0g4nAd4ms> yes the two cases are the empty list and (x : xs)
09:25:12 <mniip> yes
09:25:22 <mniip> let's begin with that
09:25:29 <mniip> your function needs to have two cases
09:25:42 <mniip> nth i [] =
09:25:45 <mniip> nth i (x:xs) =
09:26:24 <mniip> do you know what to write in the [] case?
09:27:49 <L0g4nAd4ms> well as i said, i already have specified those two cases, in the first one i just returned nothing and in the second one i returned nothing if i > length xs or i is negative
09:28:13 <mniip> nononono
09:28:38 <mniip> those checks don't really have a place in the second case
09:28:43 <mniip> they're redundant in fact
09:29:36 <mniip> L0g4nAd4ms, what does 'nth 0' do?
09:30:27 <kuekerino> ?src shows
09:30:27 <lambdabot> Source not found. I feel much better now.
09:30:53 <L0g4nAd4ms> well if n == 0 i could simply return the 0th element 
09:30:59 <mniip> right
09:31:10 <mniip> so if you have matched on (x:xs)
09:31:15 <mniip> and i==0
09:32:45 <L0g4nAd4ms> well its just simply return x
09:34:07 <L0g4nAd4ms> because x is the head followed by xs and base case 0 just wants to have the head
09:34:56 <mniip> yes
09:35:01 <mniip> and if it's not 0
09:35:23 <mniip> let's for a moment ignore the fact that it can be negative and assume it's positive
09:35:40 <mniip> or rather, let's phrase it like this
09:35:53 <mniip> if i is not 0, then the element you're looking for is not x,
09:36:02 <mniip> and if it's not in xs then it's not anywhere else
09:36:42 <L0g4nAd4ms> well i just call nth with i+1 ?
09:37:36 <mniip> i-1
09:41:04 <L0g4nAd4ms> okay is this because of zero indexing or did i just made a logical error
09:42:02 <kuekerino> Hey for homework I have to write my own algebraic datatype as an instance of the Show Class. So far I have:
09:42:03 <kuekerino> data Roo3Num = Root3Num Int Int — the datatype
09:42:03 <kuekerino> instance Show Root3Num where
09:42:03 <kuekerino>     show x = shows x ""
09:42:03 <kuekerino> But if I now want to print one of the objects I get a stack overflow. Can anyone give me some pointers on what I am missing?
09:42:27 <mniip> L0g4nAd4ms, consider what happens with 'nth 1'
09:42:51 <mniip> kuekerino, because you didn't really "implement" show
09:43:10 <L0g4nAd4ms> oh yeah right if i have the base case at 0 it makes sense to define the recursive step with -1 because i want the recursion to end 
09:43:25 <glguy> kuekerino: The default implementation of shows uses show itself. You should be deriving the Show instance
09:43:38 <glguy> data Roo3Num = Root3Num Int Int deriving Show
09:43:51 <mniip> glguy, considering this is homework perhaps you should walk them through writing an instance for real?
09:44:04 <kuekerino> glguy that is not an option since I am supposed to write that exact part
09:44:10 <glguy> Oh, yeah for homework it would be different :)
09:45:10 <kuekerino> what parts are missing in order to "really implement" it? I am pretty new to Haskell and functional progrmming in general
09:46:31 <glguy> kuekerino: Your job is to write a function :: Roo3Num -> String
09:46:37 <glguy> You have to build the whole string
09:46:43 <ggVGc> when is *> really useful?
09:46:48 <ggVGc> I've only really seen it used in parsing?
09:47:06 <mniip> *> is the same as >>
09:47:10 <mniip> except Applicative
09:47:22 <glguy> ggVGc: print "Type your name:" *> getLine
09:47:35 <ggVGc> glguy: and outside of IO?
09:47:57 <glguy> ggVGc: Pick any applicative instance and then you can use it
09:48:05 <ggVGc> mniip: yeah, I'm trying to find use cases of *> where I'm not in a monad
09:48:26 <mniip> how often have you used applicatives that aren't monad
09:48:30 <ggVGc> glguy: sure, but I can't think of many cases where throwing away the result is useful
09:49:10 <glguy> ggVGc: It's especially useful to "throw away the result" when the result type is ()
09:49:28 <glguy> but otherwise there are still plenty of reasons to only need the "effect" and not the result
09:49:40 <ggVGc> mniip: yeah, fair. But there are obviously cases where we don't have a monad, hence why we have Applicative at all. And if there are no good use cases for non-monad applicatives where we want to throw away results, then why is *> in Applicative at all
09:49:45 <Gratin[m]> is anyone able to help me with this error? i'm on arch linux trying to setup my dev environment
09:49:46 <Gratin[m]> https://gist.github.com/abueide/e2cdd8fea9625a281bf5200f8d70258a
09:50:07 <L0g4nAd4ms> mniip, anyway, thanks for your help. still thinking in loops and not recursion ^^
09:50:17 <mniip> ggVGc, sometimes it can be more efficient than liftA2 const
09:50:28 <mniip> L0g4nAd4ms, did you figure it out?
09:50:50 <L0g4nAd4ms> yes it works
09:50:58 <mniip> can I see
09:51:15 <Gratin[m]> i thought it was because my tmp was mounted with noexec, but I removed the automounting from systemd so now its just in root on my ssd instead of ram, but still didn't work
09:51:45 <L0g4nAd4ms> mniip, why ? in the recursive case i just call nth with (n-1) xs (cause xs is the rest of the list)
09:51:55 <mniip> alright
09:52:51 <L0g4nAd4ms> well but if you want to mniip: http://lpaste.net/360477
09:54:08 <mniip> there's no need for the 'n > length xs' clause
09:54:12 <mniip> in fact it's bad
09:54:27 <mniip> consider for example
09:54:30 <mniip> nth 10 [0..]
09:55:11 <L0g4nAd4ms> yes thats an infinite loop
09:56:42 <kuekerino> ?src showsprec
09:56:42 <lambdabot> Source not found. Take a stress pill and think things over.
09:56:54 <mniip> L0g4nAd4ms, you can remove the length check and it'll work
09:56:56 <kuekerino> ?src showsPrec
09:56:56 <lambdabot> showsPrec _ x s = show x ++ s
09:57:16 <kuekerino> ?src showList
09:57:16 <lambdabot> Source not found. Where did you learn to type?
09:57:34 <mniip> kuekerino, you're perhaps not understanding the part where you have to actually write your own code in the instance
09:58:04 <L0g4nAd4ms> mniip, yeah just tried it without it. but why
09:58:53 <mniip> length [0..] never terminates
09:58:58 <mniip> and
09:59:07 <mniip> why do you need to check
09:59:12 <kuekerino> mniip are those lambdabot commands also visible to everyone?
09:59:21 <mniip> if the list is too short you will just eventually recurse to 'nth i []
09:59:22 <mniip> '
09:59:25 <mniip> kuekerino, yes
09:59:45 <L0g4nAd4ms> mniip, okay thats seems clear but does it work when n is negative
10:00:13 <L0g4nAd4ms> then the n - 1 should decrease the n 
10:00:14 <kuekerino> mniip any way to do that locally or private? I do not want to spam this all the time
10:00:25 <mniip> /query lambdabot 
10:00:40 <mniip> L0g4nAd4ms, well if n is negative it will recurse until the end of the list
10:01:04 <mniip> you can leave that clause in if you're concerned about indexing infinite lists with negative indices
10:01:23 * hackage hsshellscript 3.4.3 - Haskell for Unix shell scripting tasks  https://hackage.haskell.org/package/hsshellscript-3.4.3 (VolkerWysk)
10:01:54 <L0g4nAd4ms> mniip, okay but the runtime performance would be better if i leave the clause in right ? 
10:01:55 <kuekerino> thanks for the tip and yes im not understanding where I am stuck and where to go to next
10:04:42 <ph88> trying to implement sum   https://bpaste.net/show/9cdfac727e34
10:05:09 <ph88> foldl1 works
10:06:08 <cocreature> addition on floating points is not associative
10:07:28 <cocreature> also 1) there is no reason to use foldr1 or foldl1, the sum of an empty list should be 0 and 2) your foldr implementation will use O(n) memory
10:07:56 <cocreature> the foldl1 will too without optimizations, with optimizations GHC is probably smart enough but you should just use foldl1'
10:08:12 <EvanR> theres various ways to sum a bunch of floats... all giving different results. is there no one "true" answer?
10:09:26 <EvanR> i guess the one where the accumulator has enough precision and then in the end the result is rounded
10:09:44 <EvanR> which i dont think we usually do
10:10:59 <EvanR> fromRational . sum . map toRational
10:11:22 <cocreature> fromSlow . sum . map toSlow ;)
10:11:56 <EvanR> get there faster, for some value of "there"
10:12:25 <mniip> EvanR, there's a widely known idea that you should add the small numbers first
10:12:36 <mniip> so you put all the numbers into a priority queue
10:12:46 <mniip> and while there's more than one you take two least, add, and push back in
10:13:04 <EvanR> oh interesting
10:15:01 <EvanR> does that get you the same answer as to/fromSlow above
10:16:42 <mniip> not really no
10:16:51 <EvanR> heh
10:16:57 <mniip> but it's better than many things
10:17:02 <mniip> hmmm
10:17:11 <EvanR> i heard kahan is the be-all-end-all of summing
10:17:36 <dutchie> I'm struggling to get intero/terminfo to install properly on arch: http://lpaste.net/360412. afaict the `config.log` file (and the whole tmpdir) where it's being built is being wiped out before I can get a look at what precisely the problem is
10:17:51 <cocreature> mniip: do you happen to know if it’s the optimal order for adding the numbers or is it just one that happens to be reasonably good in most cases?
10:18:02 <mniip> @let newtype Lax f a = Lax { getLax :: f a } deriving (Show, Functor, Applicative)
10:18:03 <lambdabot>  .L.hs:177:42: error:
10:18:03 <lambdabot>      • Can't make a derived instance of ‘Applicative (Lax f)’:
10:18:03 <lambdabot>          ‘Applicative’ is not a stock derivable class (Eq, Show, etc.)
10:18:08 <mniip> dammit
10:18:21 <dutchie> (been asking here and #haskell-stack over the last couple of days, anywhere else people can suggest?)
10:18:49 <mniip> cocreature, it looks reasonably good to me in terms of adding floating point numbers of different magnitude and precision loss due to that
10:18:50 <sbrg> dutchie: what version of stack?
10:18:56 <sbrg> I think you probably need to upgrade stack.
10:18:57 <mniip> can't say about optimal
10:18:59 <sbrg> stack upgrade; stack install intero
10:19:12 <dutchie> 1.6.0.20171022
10:19:24 <mniip> @let newtype Lax f a = Lax { getLax :: f a } deriving (Show, Functor)
10:19:25 <lambdabot>  Defined.
10:19:36 <dutchie> upgrade said I already had the latest version
10:19:38 <sbrg> huh, that's newer than mine. I also run arch and have no problems with intero
10:19:48 <kuekerino> mniip so as a followup, do I need to implement both show and showsPrec for a complete implementation of the Show Class? I now got a working version of the show function :)
10:19:53 * hackage haskell-gi-base 0.20.7 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.20.7 (inaki)
10:20:03 <mniip> @let instance (Applicative f, Monoid m) => Monoid (Lax f m) where mempty = Lax (pure mempty); mappend (Lax x) (Lax y) = Lax (mappend <$> x <*> y)
10:20:05 <lambdabot>  Defined.
10:20:17 <mniip> kuekerino, you need just one of the two
10:20:18 <dutchie> there was some other package with a similar issue I saw when I tried to install hlint
10:21:14 <sbrg> i also think I have seen that issue on my own machine at some point.. i'm not entirely sure though.
10:21:49 <cocreature> hm http://www.phys.uconn.edu/~rozman/Courses/P2200_11F/downloads/sum-howto.pdf claims increasing order is optimal if the values are non-negative
10:22:32 <sbrg> dutchie: what is the contents of config.log?
10:22:48 <sbrg> dutchie: also, how did you install stack?
10:22:56 <EvanR> does optimal = give best possible answer, or just for doing them in order
10:23:13 <EvanR> best if you do them with float arithmetic in order
10:24:02 <EvanR> waittt
10:24:04 <sbrg> dutchie: looks to me like you're using stack HEAD?
10:24:11 <EvanR> float addition is commutative
10:24:17 <cocreature> EvanR: what do you mean by “in order”? if you do it in an increasing order you are already changing the order, no?
10:24:23 <dutchie> it's from the arch package
10:24:27 <kuekerino> thanks for the help and have a goodnight
10:24:34 <dutchie> maybe the AUR one
10:24:40 <sbrg> yeah, it's HEAD
10:24:54 <EvanR> by in order i mean... doing them sequentially rather than in parallel or converting to rational first
10:25:15 <sbrg> pretty sure we can fix your issue as follows: Uninstall the stack package. go to https://docs.haskellstack.org/en/stable/README/ and follow the instructions for downloading the binary 
10:25:23 <cocreature> ah ok
10:25:24 <sbrg> put that binary in ~/.local/bin and add that path to your $PATH
10:25:52 <sbrg> then in the future, use stack to upgrade itself via `stack upgrade`. it will simply put the new binary in the same place and there will be zero hassle.
10:27:35 <sbrg> of course, it would be preferable if it were possible to manage this via the package manager, but in this case there's a very small footprint(only the stack binary) so it's not a hassle to remove it.
10:27:46 <sbrg> you just remove the binary and things like ~/.stack
10:27:47 <dutchie> right
10:29:07 <dutchie> same problem still :/
10:29:15 <sbrg> really? 
10:29:16 <glguy> Doing Advent of Code this year? Join the #haskell group: http://adventofcode.com/2017/leaderboard/private 43100-84040706
10:29:20 <dutchie> yeah
10:29:32 <sbrg> are you sure you're using the correct stack etc? what does stack --version say?
10:29:38 <sbrg> might want to try removing ~/.stack
10:29:53 <dutchie> `which stack` gives me the one I just downloaded
10:30:09 <sbrg> try removing ~/.stack to ensure the build env is clean
10:31:24 <dminuoso> How does one describe a sort of "branch" where you get an Either and want to handle the Left path and Right path at the same time (but using different semantics)? Is Bifunctor a good way?
10:32:16 <dminuoso> i.e. just lifting both computation paths with bimap, and then applying it to the either 
10:32:43 <sbrg> dutchie: unfortunately, i gotta run in a couple of minutes. but it shouldn't be a huge issue to get stack to work on arch. i didn't have any issues.
10:32:44 <dutchie> ok, that works now, thanks sbrg 
10:32:55 <dutchie> wait no it doesn't
10:32:55 <sbrg> sweet :)
10:32:57 <sbrg> oh
10:33:06 <sbrg> still the same shit?
10:33:08 <dutchie> yeah
10:33:18 <sbrg> hmm
10:33:20 <dutchie> I'm sure it used to work
10:35:22 * hackage xmlbf 0.1 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  https://hackage.haskell.org/package/xmlbf-0.1 (RenzoCarbonara)
10:38:23 * hackage xmlbf-xeno 0.1, xmlbf-xmlhtml 0.1 (RenzoCarbonara): https://qbin.io/ek7i7xa2k
10:55:51 <ggVGc> > [1,2,3] <|> [4]
10:55:54 <lambdabot>  [1,2,3,4]
10:56:02 <ggVGc> why is that not just [1,2,3]?
10:56:17 <ggVGc> > Just 2 <|> Just 7
10:56:19 <lambdabot>  Just 2
10:56:30 <ggVGc> why are the lists concated with alternative?
10:56:33 <ggVGc> seems weird to me
10:56:34 <mniip> what's empty
10:56:52 <mniip> what's empty <|> xs
10:57:04 <ggVGc> xs
10:57:12 <mniip> do you see now
10:57:48 <ggVGc> no, my intuition says it should short-circuit on the first non-empty list, and that should be the result
10:58:13 <lyxia> (<|>) returning the left-most non-empty list seems also valid as an Alternative implementation...
10:58:18 <mniip> it is
10:58:46 <mniip> but Alternative has a kind of a meaning as a natural family of monoids
10:58:53 <mniip> and the usual list monoid we know is concatenative
10:59:05 <ggVGc> hm, alright
10:59:28 <ggVGc> for practical use I think returning the first non-empty would be more useful
10:59:29 <ggVGc> for me
11:00:44 <lyxia> Returning all results seems a pretty natural way of representing a non-deterministic computation to me
11:01:13 <ggVGc> I'm probably thinking about Alternative in the wrong way
11:01:43 <mniip> more like you're thinking about [] the wrong way
11:01:48 <mniip> and by that I mean the monad
11:01:52 <ggVGc> my gut feeling says I want to use it for getting the results of any of the computations, but not a mix of the results from them
11:02:06 <ggVGc> yeah, probably
11:02:25 <mniip> @let x <||> y = if null x then y else x
11:02:27 <lambdabot>  Defined.
11:02:28 <mniip> :t (<||>)
11:02:30 <lambdabot> Foldable t => t a -> t a -> t a
11:02:53 <erisco> I have thought for a while now that there should be an ad hoc function  isEmpty :: DecidablyEmpty m => m -> Bool
11:02:54 <mniip> there's your boring semigroup
11:03:27 <erisco> and similar for * -> * kinds… then you can have a general instance like this
11:05:32 <erisco> instance DecidablyEmpty m => Monoid (First m) where mempty = First mempty; mappend a@(First x) b | isEmpty x = b | otherwise = a
11:06:28 <EvanR> is this like observably empty
11:06:49 <EvanR> which sounds a little ironic
11:06:54 <erisco> I dunno, is that a thing?
11:07:02 <EvanR> dunno
11:07:20 <EvanR> how to you observe the absense of something
11:07:22 <erisco> get Morissette in here
11:08:42 <erisco> one law is  isEmpty mempty = True
11:10:28 <erisco> I am not sure how you'd specify the False part sensibly
11:11:26 <erisco> isEmpty (x <> y) = isEmpty x && isEmpty y
11:11:31 <erisco> there we go :)
11:11:53 <erisco> monoid homomorphism
11:12:12 <EvanR> lol
11:12:28 <EvanR> that cant be right...
11:12:39 <erisco> why not?
11:12:57 <EvanR> in the monoid N mod 4, 2 + 2 = 0
11:13:15 * erisco *sighs*
11:13:29 <erisco> too strong…
11:13:32 <Cale> It's the monoid (Bool, &&, False)
11:13:40 <Cale> er, True rather
11:14:10 <erisco> I guess a law for False doesn't exist, and that is okay
11:14:16 <Cale> Also known as All
11:14:18 <Cale> :t All
11:14:19 <lambdabot> Bool -> All
11:14:23 <EvanR> well this shows isEmpty is not a monoid homomorphism from whatever to (Bool,&&,True)
11:14:45 <erisco> and monoids where that homomorphism works have some different quality… not sure what
11:15:03 <Cale> why?
11:15:17 <erisco> but practically speaking there are several Monoids which are decidably empty
11:15:32 <Cale> Wait, what are we trying to say?
11:15:49 <Cale> I was thinking isEmpty :: Set a -> Bool or something
11:16:02 <erisco> you have to read my introduction of isEmpty
11:16:19 <EvanR> is there a paywall?
11:16:37 <ggVGc> is EvanR empty?
11:17:08 <erisco> I probably should start charging for these great ideas
11:17:33 <ggVGc> yeah, the world sure is lacking ideas
11:18:36 <erisco> EvanR, I guess you could say such monoids do not have inverses
11:18:48 <EvanR> which monoids
11:19:00 <erisco> ones that satisfy that homomorphism
11:19:08 <EvanR> why...
11:19:17 <dminuoso> :t (<||>)
11:19:18 <lambdabot> Foldable t => t a -> t a -> t a
11:19:25 <dminuoso> How long does lambdabot store definitions? 
11:19:28 <dminuoso> Indefinitely?
11:20:17 <erisco> EvanR, do you have another counter example?
11:20:25 <erisco> dminuoso, until someone does this
11:20:28 <erisco> @undefine
11:20:28 <lambdabot> Undefined.
11:20:31 <EvanR> of a monoid which not e <> not e = e ?
11:20:37 <ggVGc> obviously lambdabot doesn't store any definitions. When someone asks for one, it reads the backlog and presents it
11:20:37 <dminuoso> erisco: Ah, thank you.
11:20:48 <dminuoso> ggVGc: Oh?
11:20:54 <EvanR> ggVGc: such stateless
11:21:05 <ggVGc> actually, sorry. it PMs the author and asks for the definition
11:21:12 <dminuoso> Heh.
11:21:30 <erisco> EvanR, I am saying such a monoid has no inverses
11:21:31 <ggVGc> actually. I was just wondering too
11:21:34 <ggVGc> there has to be some timeout I guess
11:21:47 <EvanR> erisco: which monoid... 
11:22:01 <EvanR> the one i mentioned does NOT satisfy your law
11:22:02 <erisco> never mind… not worth explaining -.-
11:22:12 <EvanR> i cant tell if youre typoing or what
11:26:31 <erisco> are you pointing out that e is its own inverse?
11:26:42 <EvanR> no?
11:26:57 <erisco> alright then we're on different planes
11:27:07 <EvanR> sometimes two not-e values monoid together to get e
11:27:40 <EvanR> so the theory that if xy is e implies x is e and y is e is wrong
11:29:36 <erisco> okay… not sure how that is relevant
11:29:49 <EvanR> i was pointing out how your equation is wrong
11:30:05 * hackage xmlbf 0.2 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  https://hackage.haskell.org/package/xmlbf-0.2 (RenzoCarbonara)
11:30:35 <EvanR> namely isEmpty (x <> y) = isEmpty x && isEmpty y
11:31:02 <erisco> you already pointed that out with the modulus example
11:31:24 <EvanR> interesting
11:33:27 <erisco> I am saying that a monoid which satisfies that property must be one without inverses
11:34:23 <erisco> with exception of e
11:36:23 <ggVGc> do you guys use Integer over Int mostly?
11:36:37 <ph88> @pl (\f (a, b) -> f a b)
11:36:38 <lambdabot> (`ap` snd) . (. fst)
11:36:39 <ggVGc> I usually lazily use Int, but actually I think I'd like the default to be Integers
11:36:44 <martinmch> Coming from c, I usually use Int.
11:36:59 <ph88> is there a function to apply a function to the first and second element of a tuple ?
11:37:11 <erisco> join (&&&)
11:37:27 <erisco> I guess that is not in lambdabot's vocabulary
11:37:29 <mniip> ummm
11:37:37 <mniip> it's uh
11:37:38 <ggVGc> martinmch: I just write Int because it's quicker to type than Integer.. But technically it's just introducing unnecessary risk to the program
11:37:39 <mniip> uncuryy
11:37:41 <mniip> uncurry
11:37:47 <mniip> there's a function specifically for this
11:37:54 <mniip> pretty much
11:38:11 <ph88> erisco, join from Control.Monad ?
11:38:20 <mniip> :t uncurry
11:38:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:38:25 <erisco> I think my brain miscomputed
11:39:06 <erisco> I read your words more than I read the example
11:39:56 <erisco> @pl \f (a, b) -> (f a, f b)
11:39:56 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
11:40:10 <erisco> "apply a function to the first and second element of a tuple"
11:40:27 <erisco> that is pretty horrifying
11:40:37 <mniip> over each
11:40:41 <mniip> :t over each
11:40:42 <lambdabot> Each s t a b => (a -> b) -> s -> t
11:40:43 <ph88> hhmm it's a nice function mniip  .. i was looking for a short way to write   number = foldl' (\acc (a, b) -> acc + a - b) 0   
11:41:11 <mniip> uncurry (-) . (+)
11:41:21 <ph88> ^^
11:41:23 <mniip> err no
11:41:26 <mniip> sec
11:41:34 <mniip> (. uncurry (-)) . (+)
11:41:34 <andromeda-galaxy> use Control.Arrow?
11:41:39 <erisco> gotta go step by step
11:42:06 <andromeda-galaxy> @ty \f -> (f &&& f)
11:42:07 <lambdabot> Arrow a => a b c' -> a b (c', c')
11:42:17 <andromeda-galaxy> @ty \f -> (f *** f)
11:42:18 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
11:42:33 <erisco> \acc (a, b) -> acc + a - b ≡ \acc (a, b) -> (+) acc ((-) a b) ≡ \acc (a, b) -> ((+) acc . (-) a) b ≡ …
11:43:05 <martinmch> ggVGc: Does the compiler not automatically expand Int to Integer?
11:43:54 <ggVGc> martinmch: no, Int is an actual machine integer, which can overflow
11:44:00 <ggVGc> Integer is an unbounded number
11:44:03 <mniip> > maxBound + 1 :: Int
11:44:05 <lambdabot>  -9223372036854775808
11:44:08 <ggVGc> ^
11:44:44 <martinmch> 8 years of Haskell, and I never thought about that. 
11:45:01 <Welkin> martinmch: not even Int32 or Int64?
11:45:01 * hackage hsshellscript 3.4.4 - Haskell for Unix shell scripting tasks  https://hackage.haskell.org/package/hsshellscript-3.4.4 (VolkerWysk)
11:45:12 <martinmch> Yea, but those made sense.
11:45:25 <Welkin> well of course Int would be either Int32 or Int64
11:46:04 <erisco> ≡ \acc (a, b) -> ((.) ((+) acc) ((-) a)) b ≡ \acc (a, b) -> ((.) ((+) acc) . (-)) a b ≡ \acc (a, b) -> uncurry (((.) ((+) acc) . (-))) (a, b) ≡ \acc -> uncurry (((.) ((+) acc) . (-))) ≡ …
11:49:28 <woodson> anyone have a link of the list of kinds in haskell?
11:49:38 <royal_screwup21> I'm trying to define a simple Monad intance for Maybe like so: https://thepasteb.in/p/xGhmvMK4rz7FM I'm running into this error: https://thepasteb.in/p/O7h5xRo9DZ8hq How do I fix this?
11:49:41 <woodson> I am trying to decipher [*] this kind
11:50:21 <c_wraith> woodson: the list would be infinite.
11:50:21 <hpc> [*] is the kind of lists of types
11:50:22 <erisco> ≡ \acc -> uncurry ((.) ((.) ((+) acc)) (-)) ≡ \acc -> uncurry (flip (.) (-) ((.) ((+) acc))) ≡ \acc -> uncurry (flip (.) (-) (((.) . (+)) acc)) ≡ \acc -> uncurry ((flip (.) (-) . ((.) . (+))) acc) ≡ \acc -> (uncurry . (flip (.) (-) . ((.) . (+)))) acc ≡ uncurry . (flip (.) (-) . ((.) . (+)))
11:50:33 <c_wraith> woodson: but that one is the result of the DataKinds extension
11:50:48 <Welkin> hpc: not '[*] ?
11:51:06 <hpc> :k '[Int]
11:51:07 <c_wraith> Welkin: the leading ' can be elided in contexts where it's unambiguous
11:51:07 <lambdabot> [*]
11:51:22 <c_wraith> :t [Int]
11:51:24 <lambdabot> error:
11:51:24 <lambdabot>     • Data constructor not in scope: Int
11:51:24 <lambdabot>     • Perhaps you meant one of these:
11:51:27 <c_wraith> :k [Int]
11:51:28 <lambdabot> *
11:51:37 <c_wraith> oh, hah.  that case is ambiguous, right
11:51:38 <woodson> thats what i thought 
11:51:44 <woodson> but it is not a list type
11:51:51 <c_wraith> woodson: it's a type-level list
11:52:07 <c_wraith> :k [Int, String]
11:52:08 <lambdabot> [*]
11:52:31 <erisco> ≡ uncurry . (. (-)) . (.) . (+)    we got to different answers but this is the sort of thing you can practice and be comfortable doing
11:52:43 <woodson> I am using servant and this is how i am defining one endpoint "login"  :> ReqBody '[JSON] User :> Post ByeString 
11:52:59 <woodson> however I am getting this error Expected kind ‘[*]’, but ‘String’ has kind ‘*’
11:53:08 <ph88> is there a function like (.) so that i can do  (*) . (*)  if i want to multiple 3 arguments?  or is there any other good way to do this ?
11:53:32 <erisco> ph88, how about (*) … (*) ?
11:53:52 <erisco> ph88, behold control-dotdotdot
11:55:18 <royal_screwup21> I stumbled upon a tutorial where they used the following code: https://thepasteb.in/p/lOhOEnDOmoZtB when I try running it, I get an error: https://thepasteb.in/p/AnhrO6MrKXrIv How do I fix this?
11:56:00 <glguy> royal_screwup21: Remove line 1, Maybe, Nothing, and Just are already defined by the Prelude and are implicitly imported
11:56:03 <cocreature> royal_screwup21: import Prelude hiding (Maybe)
11:56:12 <glguy> Err, then you won't be able to make the instance either
11:56:13 <ph88> erisco, oh that's your creation isn't it
11:56:20 <erisco> mhm
11:56:25 <glguy> so, go with cocreature :)
11:56:40 <cocreature> and add Just and Nothing to the hiding list :)
11:57:21 <glguy> royal_screwup21: even better will be to not use the same names, but make up your own
11:57:25 <erisco> ph88, there is also control-foldapp I think I called it, where you can just write  product
11:57:31 <glguy> data MyMaybe a = MyNothing | MyJust a
11:57:37 <erisco> ph88, and it takes the n-ary product of its arguments
11:57:48 <b1956> ciao !list
11:58:10 <erisco> ph88, it is actually potentially useful for some applications such as applicative parsing
11:58:21 <royal_screwup21> so I added Maybe Nothing and Just to the list and I hit another error: https://thepasteb.in/p/oYhlYqJvArQhZ Not sure how to fix this?
11:58:49 <cocreature> royal_screwup21: you need to define an Applicative instance
11:59:00 <glguy> https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10#GHCsaysNoinstanceforApplicative...
11:59:11 <cocreature> if you already have a Monad instance you can do so by setting "pure = return" and "(<*>) = ap"
12:01:37 <erisco> @djinn (((a1 -> b) -> a1 -> c1) -> c2) -> (a2 -> b -> c1) -> a2 -> c2
12:01:37 <lambdabot> f a b c = a (\ d e -> b c (d e))
12:02:05 <royal_screwup21> this is incredibly frustrating. I mean, I've looked at a dozen tutorials - like this http://www.idryman.org/blog/2014/01/23/yet-another-monad-tutorial/ - and not one of them mention using the hiding list or the Applicative instance, which happens to be critical to actually running the code in said tutorial
12:02:50 <Welkin> royal_screwup21: what is a hiding list?
12:02:56 <Welkin> you mean when you import form a module?
12:03:19 <Welkin> there is only one monad tutorial you will ever need: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
12:04:45 <martinmch> Welkin: I like the ascii figures, but wouldn't images be more readable?
12:04:46 <erisco> ph88, I built foldApp as a generalisation of printf and then never got around to implementing printf with it
12:05:07 <erisco> some things are better left as ideas…
12:05:23 <mniip> royal_screwup21, some of these tutorials might be too old
12:05:24 <Welkin> martinmch: it works.
12:05:31 <mniip> for the Applicative instance to "be"
12:06:00 <mniip> if you're getting errors because of a missing Applicative instance when defining a Monad instance, you can just
12:06:09 <dminuoso> What's the consensus on language extensions? I've been itching to turn on LambdaCase right now because it would make a couple functions more readable. Is it fine for a beginner to start plugging in language extensions?
12:06:13 <mniip> instance Applicative T where pure = return; (<*>) = ap
12:06:22 <erisco> dminuoso, go for it
12:06:24 <mniip> (under the premise that Monad T is defined in the same file)
12:06:37 <Welkin> dminuoso: yes, considering the ghc is the only compiler you will realistically use
12:06:38 <mniip> and ap is from Control.Monad
12:06:42 <erisco> I don't know what Haskell doesn't start with a dozen language extensions anymore
12:07:05 <EvanR> can you send me a haskell
12:07:20 <dminuoso> erisco: Yeah. Was watching that video of Stephanie Weinrich about dependently typed Haskell, and the first line.. well lines.. was like 20 extensions or so.
12:07:26 <dminuoso> It was scary. :|
12:07:31 <EvanR> "extensions" may carry negative connotations for whatever reason, but it shouldnt in haskell
12:07:40 <mniip> erisco, yeah let's plop TypeInType RankNTypes PolyKinds UndecidableInstances on the table from the start
12:07:40 <erisco> would you like it in a carton or a bag?
12:07:48 <EvanR> because you can turn them on and be independent of other modules
12:07:49 <Welkin> dminuoso: there are more experimental extensions than you will ever use
12:07:55 <EvanR> and there are no other compilers to worry about
12:08:26 <erisco> well two of those are quite reasonable
12:08:51 <EvanR> i wish RankNTypes was on by default
12:09:02 <b1956> http://www.idryman.org/blog/2014/01/23/yet-another-monad-tutorial/
12:09:07 <erisco> FlexibleInstances, FlexibleContexts, MultiParamTypeClasses, SuperClassSomethingSomething
12:09:10 <hpc> dminuoso: the "difficulty" of extensions varies quite a bit
12:09:14 <mniip> UndecidableSuperClasses
12:09:24 <erisco> FunctionalDependencies
12:09:25 <mniip> FunctionalDep
12:09:47 <erisco> TypeFamilies, GADTs, ConstraintKinds … just thinking of a few… then there is syntax extensions
12:09:59 <EvanR> some of the type class extensions are good for understanding how type classes work without extensions... which you might think is important
12:10:00 <mniip> syntax extensions are boring
12:10:17 <mniip> I mean who needs ScopedTypeVariables
12:10:21 <dminuoso> EvanR: Yeah. Most of my reservation is from C++ where extensions means writing non-conforming code. It feels like breaking the law, which is exciting but frowned upon by the society.
12:10:26 <EvanR> boring as in... just have them on by default and now we dont have to talk about them anymore :)
12:10:41 <mniip> EvanR, see problem 1 with haskell prime
12:10:45 <Welkin> dminuoso: the haskell langugae standard is very conservative
12:11:12 <mniip> if all of the extensions are incorporated into the report, or worse, core language, then implementing another compiler becomes nearly impossible
12:11:28 <mniip> and uh
12:11:44 <EvanR> yes that is an issue with RankN
12:11:57 <mniip> I mean de-facto haskell is already a single-compiler language, but is that a good thing
12:12:00 <hpc> dminuoso: extensions in haskell are less about compilers wanting to do their own thing and more like candidate language features
12:12:05 <EvanR> but SPJ says there is unlikely to ever be another haskell compiler
12:12:17 <tdammers> mniip: de-facto production haskell is
12:12:28 <Welkin> isn't the same true with C and C++?
12:12:30 <mniip> especially considering how big and clumsy and hungry the GHC is
12:12:35 <Welkin> I mean, microsoft has their own version
12:12:39 <hpc> Welkin: gcc/clang is still pretty even
12:12:41 <mniip> Welkin, what no. there are tons of compilers
12:12:42 <Welkin> but then there is gcc and clang
12:12:47 <Welkin> that's it
12:13:01 <Welkin> no one uses other c compilers
12:13:05 <EvanR> so at this point the whole standards thing might just be lip service
12:13:16 <tdammers> Welkin: there's also IBM's compiler, which apparently some people still use
12:13:20 <EvanR> impress the natives, get them to join
12:13:21 <mniip> icc?
12:13:24 <tdammers> ya
12:13:40 <mniip> I mean intel's cc
12:14:34 <mniip> anyway
12:14:44 <mniip> you can port gcc to another architecture and not die
12:14:53 <dminuoso> hpc: Ah, that actually feels right, it matches with what my perception of the language extension is that I have looked at. 
12:15:04 <Welkin> mniip: you can't with ghc?
12:15:13 <mniip> freestanding gcc output is fairly versatile
12:15:15 <lambdamu_> There are a lot of differrent c compilers for embedded systems
12:15:15 <mniip> if you try that with ghc...
12:15:34 <tdammers> you can cheat and compile via llvm
12:15:34 <lambdamu_> in commercial toolchains and such
12:15:37 <mniip> the GHC RTS is HUGE
12:15:41 <mniip> and I hate that tbh
12:15:48 <mniip> I mean sure otherwise it wouldn't be fast
12:16:16 <EvanR> haskell for embedded..
12:16:23 <mniip> but a functional programming language's runtime environment need not be the monstrosity that is the GHC RTS
12:16:31 <EvanR> needs some extra constraints
12:16:59 <mniip> hmm
12:17:12 <mniip> me and a friend had an idea of a lisp cpu...
12:17:18 <mniip> wonder if haskell could be easily compiled to that
12:17:30 <EvanR> anything like the actual lisp cpus?
12:17:36 <mniip> h a r d w a r e  g a r b a g e  c o l l e c t o r
12:17:42 <ph88> i wrote this code to reverse a list recursively https://bpaste.net/show/7e46568b4982 i expected that i should do (acc ++ [x]) instead of (x : acc)  why does this code work ?
12:17:44 <erisco> do they ship in a dozen layers of bubble wrap?
12:18:07 <erisco> ph88, write it out and see how it evaluates
12:18:26 <hpc> step through it with [1, 2]
12:18:31 <erisco> or, make some pancakes, and move them from one plate to another
12:18:41 <hpc> go [] [1,2]
12:18:44 <hpc> go [1] [2]
12:18:47 <tdammers> I don't think we know enough about Haskell's GC requirements to bake it into hardware yet
12:18:49 <Welkin> erisco: or use the pancakes to kill the final boss in nethack
12:18:49 <hpc> go [2,1] []
12:18:52 <hpc> [2,1]
12:18:58 <mniip> hpc, Okay! First I enter the AP closure!
12:19:10 <ph88> oh ye i see now hpc 
12:19:31 <mniip> tdammers, no like my GC idea was that you can allocate and free doubleword cons cells in constant time in hardware
12:19:46 <erisco> now what can you do with three stacks?
12:19:54 <Welkin> erisco: towers of hanoi
12:19:57 <erisco> hehe
12:21:15 <ekr> so, in my quest to become better at programming in haskell, i've been doing competitive programming challenges. Why does the memory usage on an online judge like spoj report 16G for simply parsing an input file with numbers, reading with getContents, which should be lazy? (I know, I should use the +RTS option, but maybe someone could give me a quick pointer).
12:21:16 <erisco> now implement a sort using three stacks
12:21:24 <tdammers> mniip: oh, ok, so not actually all of the GHC RTS garbage collection logic
12:21:46 <ekr> shouldn't getContents chunk the input?
12:21:53 <Welkin> ekr: no
12:22:12 <royal_screwup21> what does ∧mean in Haskell?
12:22:12 <Welkin> if you want streaming input, use lazy IO (not recommended) or use pipes or conduit
12:22:29 <mniip> here's a quick pointer: 0x7f4361181648
12:22:55 <erisco> royal_screwup21, probably && but we don't usually use unicode names. Where did you see that?
12:22:55 <ekr> Welkin: thanks
12:23:20 <ekr> mniip: you know what's an even quicker pointer? an x32 one. 
12:23:24 <Welkin> you can read it line by line if you want
12:23:33 <Welkin> if you open a file handle yourself
12:23:35 <royal_screwup21> erisco: a (outdated) tutorial, sigh
12:24:01 <mniip> ekr, the quickest pointers are n(%esp) for a small n
12:24:13 <mniip> intel's x86 has a thing for those
12:24:14 <erisco> sometimes authors use unicode characters such as λ in place of \ for more aesthetic reading
12:24:21 <int-e> ekr: Huh, getContents does lazy IO. maybe the memory is going somewhere else?
12:24:31 <hpc> that character looks more like logical or set intersection
12:24:47 <Welkin> ekr: if you use `getContents` for Lazy ByteString, then it will use lazy IO
12:24:56 <ekr> inp <- ((<$>) read) <$> (lines <$> getContents) :: IO [Int] 
12:25:05 <hpc> i wouldn't expect to see it in haskell except in needlessly fancy unicode stuff
12:25:09 <alp> woodson, did you solve your servant issue? btw there's #servant, you're more likely to get help about servant there I think =)
12:25:11 <hpc> but it's in math notation all the time
12:25:35 <Welkin> hm, okay, `getContents` for String is also lazy
12:25:53 <ekr> that's what i was expecting, yes. I will check then with +RTS. 
12:26:35 <Welkin> ekr: is this cumulative memory allocation for the whole program?
12:26:41 <Welkin> If so, that sounds right
12:26:48 <Welkin> if that is peak memory usage, then no
12:27:04 <Welkin> GHC generates a lot of garbage (1 GB per second at least from what I have seen)
12:27:10 <Welkin> but cleans it up very efficiently
12:27:12 <ph88> is there a read for a single character ?
12:27:37 <Welkin> ph88: getChar
12:27:38 <hpc> ph88: as in Read a => Char -> a?
12:28:05 <ph88> ye
12:30:34 <rightfold> fromIntegral . ord
12:35:05 <int-e> ekr: `read` is surprisingly lazy though; just forcing the spine of that list I'm seeing 200 bytes per list element residency (using numbers 1..10000000 as input). Forcing the elements of the list brings that down to 40 bytes per entry, which is expected (2 words for each Int, and 3 for each cons in the list.)
12:38:33 <int-e> (`read :: String -> Int` is a monstrosity if you look at it from a performance point of view.)
12:39:04 <int-e> ekr: oh and depending on how you use the numbers, storing them in an unboxed bytearray may be worthwhile, just to save memory.
12:39:22 <int-e> s/byte//
12:39:51 <ekr> i was thinking about that, also considered the vector type. thanks for all the help.
12:40:54 <ekr> but do you mean that read is so slow that it shouldn't be used? would you use something hand-written instead?
12:41:27 <ekr> or is it because of the list?
12:43:07 <int-e> ekr: you could do worse than https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Lazy-Char8.html#v:readInt 
12:43:14 <drdo> How do I escape a single quote in haddock?
12:44:34 <erisco> a stack sort! http://lpaste.net/360481
12:48:23 <ezrios> @pl (\x -> x)
12:48:23 <lambdabot> id
12:48:40 <ezrios> @pl (\x -> f (g x) (h x))
12:48:41 <lambdabot> liftM2 f g h
12:49:19 <erisco> but use liftA2 because liftM2 is old
12:51:33 <ph88> lol  https://www.codewars.com/kata/reviews/5516821177dd9eae530004c2/groups/558c67bd6ad71014d700010f
12:51:46 <erisco> password protected
13:04:35 <erisco> drdo, backslash I think
13:06:03 <rafl> how come `Complex Integer` isn't an instance of Num? is that only because `abs` of a Complex Integer couldn't also be a Complex Integer unless the imaginary component is zero?
13:06:48 <hpc> instance RealFloat a => Num (Complex a)
13:06:52 <hpc> Integer isn't RealFloat
13:07:05 <rafl> hpc: i'm asking why it can't be
13:07:11 <hpc> ah
13:08:24 <hpc> i think your theory is pretty good
13:12:22 <rafl> ok, thank you. i just realised it'd also be possible to write that abs function in one other case where the real component is zero and the imaginary one potentially isn't, but it'd still not make it total. that makes sense
13:12:50 <hpc> yeah
13:13:05 <hpc> in some sense, Complex Integer is a 2d grid
13:13:43 <hpc> but the distance to each point on that grid is not expressable as another point on that grid (if you take abs to be like the scalar of a vector)
13:14:04 <hpc> abs could just be id, or it could push everything into one quadrant too
13:14:24 <rafl> right - that makes sense
13:16:21 <dminuoso> Is there some monoid instance on [] that picks the first non-empty list?
13:16:33 <dminuoso> Or rather some [] wrapping that does this for me?
13:16:41 <hpc> > [] <|> "test"
13:16:43 <lambdabot>  "test"
13:16:47 <hpc> > "a" <|> "b"
13:16:49 <lambdabot>  "ab"
13:16:54 <hpc> hmm
13:16:58 <dminuoso> hpc: ;)
13:17:17 <hpc> > ZipList "a" <|> ZipList "b"
13:17:19 <lambdabot>  error:
13:17:19 <lambdabot>      • No instance for (Alternative ZipList) arising from a use of ‘<|>’
13:17:19 <lambdabot>      • In the expression: ZipList "a" <|> ZipList "b"
13:17:22 <erisco> time to implement DecidablyEmpty
13:17:23 <hpc> dang
13:17:42 <ph88> what function can i use to round a Double to a specific amount of decimals ?
13:17:44 <hpc> perhaps Maybe?
13:18:08 <dminuoso> hpc: not not really, Just [] comes in the way :-)
13:18:19 <rafl> so if i had a computation that wasn't really worried about the `abs` portion of the `Num` type class, would there be a way for me to get an instance of Num for Complex Integer that wasn't total, or does that potentially involve also making use of other things like overlapping instances or some such which i might regret later? i think that'd simplify my code a bit if i didn't have to sprinkle in fromIntegral and such in everywhere
13:18:20 <hpc> ph88: i think typically you would multiply, do an integer round, then divide
13:18:46 <erisco> that can overflow
13:18:47 <rafl> i guess the other option is to use Complex Double, but i don't really want to be bothered with the floating point errors
13:19:48 <hpc> hmm
13:19:49 <fakenullie> > 1 :: Complex Rational
13:19:51 <lambdabot>  error:
13:19:51 <lambdabot>      • No instance for (RealFloat (Ratio Integer))
13:19:51 <lambdabot>          arising from the literal ‘1’
13:20:09 <fakenullie> > 1 :: Complex Ratio Integer
13:20:11 <lambdabot>  error:
13:20:11 <lambdabot>      • Expecting one fewer arguments to ‘Complex Ratio’
13:20:11 <lambdabot>        Expected kind ‘* -> *’, but ‘Complex Ratio’ has kind ‘*’
13:20:22 <dminuoso> hpc: Guess Im just trying to find a way to avoid this: https://gist.github.com/dminuoso/072af1a8240334e80d44d61ce629f538
13:20:24 <hpc> fakenullie: nothing rational will work, distances can be square roots
13:20:43 <fakenullie> right
13:20:50 <hpc> dminuoso: ah, i think that definition is fine
13:20:53 <dminuoso> `parse p s <|> parse q s` would have been much cooler. :(
13:21:26 <ph88> is there really no round to decimal function in any library for Double ?
13:21:34 <ph88> i have to do this often
13:21:46 <fakenullie> maybe Scientific?
13:23:02 <erisco> first you're going to have to check the exponent to see where the point is
13:23:27 <erisco> then, after determining that, you can mask off the appropriate fraction digits
13:23:51 <erisco> though when you say "two decimal places" you're going to have to account for base 10, whereas the format is stored in base 2
13:25:22 <ph88> o_O
13:26:24 <erisco> or you can do what hpc said and suffer quirks when numbers get big
13:26:54 <hpc> ph88: are you rounding to perform logic, or to display?
13:27:15 <ph88> https://www.codewars.com/kata/localize-the-barycenter-of-a-triangle
13:27:27 <ph88> barTriang :: (Double, Double) -> (Double, Double) -> (Double, Double) -> (Double, Double)
13:28:29 <erisco> it is inefficient but you can use a format string to print the double at two decimal place precision, then read it back
13:29:27 <rafl> for some more context, what i was trying to do is take https://gist.github.com/rafl/544d30c9497fd705fecf45e7db178710 and turn it into `Integer -> (Integer, Integer)`, which i think would also allow me to get rid of various fromIntegral calls
13:29:31 <erisco> no guarantees on how well that works
13:32:35 <monochrom> If you must do rounding, base 2 is better than base 10, Knuth has a paper proving it.
13:33:19 <hpc> i question most cases of "must do rounding" in the first place
13:34:17 <hpc> ph88: maybe convert to a fixed point data type?
13:47:53 * hackage firefly 0.2.1.0 - A simple HTTP server framework  https://hackage.haskell.org/package/firefly-0.2.1.0 (ChrisPenner)
13:49:26 <erisco> hm… if there are more reals than computer programs, I suppose you can't even approximate all reals
13:49:35 <ph88> https://github.com/php/php-src/blob/master/ext/standard/math.c#L124-L209
13:53:22 <Aelara> erisco: There are more reals than possible computer programs, but computer programs can still approximate all reals to aribtrary precision, so I'm not sure what you mean
13:53:36 <erisco> Aelara, how so?
13:53:45 <monochrom> I don't think erisco really means "approximate".
13:53:55 <Aelara> erisco: Just use an arbitrary precision library
13:54:08 <erisco> I don't think that is a sufficient answer
13:54:20 <erisco> so, each program is going to be tasked to approximating one real
13:54:23 <monochrom> I think the precise wording is along the line of "compute to n decimal/binary places upon request"
13:54:25 <Aelara> erisco: https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic
13:54:26 <hpc> most reals have no closed form
13:54:43 <erisco> therefore, for each real you require one program
13:54:49 <erisco> and that is impossible
13:55:05 <fakenullie> Aelara: not all reals
13:55:06 <Aelara> hpc: But one programs can approximate infinitely many reals
13:55:16 <monochrom> Or rather, "approximate" means too many different things to people to be a useful word at all.
13:55:42 <fakenullie> try to approximate any of Chaitin's constant
13:55:43 <mniip> Aelara, a countably infinite number of
13:56:02 <hpc> Aelara: this is a case where conceptualizing programs as a series of bits helps
13:56:48 <mniip> erisco, you can approximate all reals you can describe
13:56:52 <fakenullie> so you can approximate only computable numbers
13:56:52 <hpc> imagine you can express every real as a finite program
13:57:00 <hpc> that program can be expressed as bits
13:57:00 <mniip> but for some there is no description of finite length
13:57:08 <hpc> the sequence of bits maps to a natural number
13:57:12 <mniip> no matter how your descriptions work
13:57:16 <hpc> therefore the reals map onto the naturals
13:57:22 <hpc> which is false
13:57:35 <erisco> yes mniip
13:58:00 <hpc> Aelara: even something like CReal only expresses the computable reals
13:58:01 <monochrom> At a meta level, all this navel gazing about "floating point is imperfect so let's go crazy on how to do perfection" is unhealthy.
13:58:03 <Aelara> hpc: I never said you can express every real as a finite program, merely that you can approximate every real with a finite program
13:58:04 <fakenullie> description of chaitin's constant is finite
13:58:29 <hpc> how approximate?
13:58:47 <hpc> to arbitrary precision? then you need a formula that can uniquely identify that real to any number of digits
13:58:58 <hpc> making the program a representation of that real
13:59:13 <Aelara> hpc: When I say a program's output u approximates a real r, I mean |u - r| < epsilon, and I'm saying a program's output can approximate any real r for any epsilon > 0
13:59:16 <hpc> or you can lump reals together and say that 1.2865 is an approximation of lots of reals
13:59:36 <hpc> that only holds for the computable reals
13:59:44 <mniip> Aelara, program being a parameter of epsilon?
13:59:52 <erisco> 0 is a good approximation of all reals for a sufficiently lax sense of "good"
13:59:52 <mniip> er
13:59:58 <mniip> program being a function of epsilon?
14:00:20 <mniip> that sounds bad as well
14:00:24 <hpc> Aelara: or it's the same as counting the naturals up to some limit
14:00:36 <Aelara> mniip: I don't think it really matters
14:00:46 <mniip> basically, if I ask you to fix the set of programs first and vary epsilon later, your statement is going to be false
14:01:13 <Aelara> mniip: Oh, I see what you mean. You're right
14:01:20 <hpc> Aelara: for all finite epsilon, the set of reals in that range maps onto naturals by the obvious mechanism of moving the decimal point
14:01:41 <hpc> but then you're only enumerating rational numbers
14:02:10 <Aelara> hpc: I'm not sure what ranger you are refering to
14:02:25 <hpc> say epsilon is 0.1
14:02:38 <hpc> you enumerate approximations of all the reals by going 0.0, 0.1, 0.2, 0.3, ...
14:02:50 <Aelara> Yes
14:02:51 <hpc> so just move the decimal point over
14:02:54 <hpc> 01, 02, 03, ...
14:02:59 <hpc> now you have the integers
14:03:19 <Aelara> Okay
14:03:38 <hpc> since the reals are /very much/ not the same size as the integers, your formulation of "approximating the reals" doesn't correspond at all to the problem of expressing every real number
14:04:01 <hpc> you can perform that transformation for all finite epsilon
14:04:28 <Aelara> hpc: If you mean expressing every real number to infinite precision, then you're right
14:04:41 <mniip> hmm
14:04:42 <hpc> my point is that the reals don't ever come into it
14:04:46 <mniip> this is where I get confused,
14:04:57 <Aelara> Reals don't every come into what?
14:04:57 <mniip> if we enumerate all the fractions in the stern-brocot tree,
14:05:01 <hpc> you're not getting converging on expressing all the reals or anything like that, it's rational the whole way down
14:05:15 <mniip> then for any positive real r and epsilon e there's going to be a number in the e-vicinity of r
14:05:22 <hpc> otherwise the approximation you're looking for is Rational and that's all there is to it
14:06:46 <erisco> it is only the irrationality of reals that makes them worth talking about
14:06:52 <hpc> ^
14:06:54 <mniip> oh, probably the pitfall is that the index of the fraction for given r,e is not computable
14:07:06 <hpc> erisco: that's a good way of putting it
14:07:57 <Aelara> erisco: (Though to be nit-picky not all reals are irrational; merely almost all are irrational)
14:08:28 <hpc> this reminds me of trying to beat cantor's diagonal argument by somehow creating a binary encoding of the reals
14:08:35 <hpc> the whole point is what happens /at/ the limit
14:09:03 <hpc> it's an easy trap to fall into
14:13:02 <Aelara> hpc: I think we've been operating on different notions of "approximate" here
14:13:14 <dminuoso> Im trying to wrap my head around `some` and `many`. They don't seem particularly useful on [] or Maybe.. the definition is kind of hard to grasp, what are these things about?
14:13:45 <jle`> dminuoso: they mostly are used with stateful applicatives/alternatives
14:13:50 <monochrom> They make more sense for parsers and STM and maybe even IO.
14:13:51 <jle`> dminuoso: their motivation comes from parser combinators
14:14:22 <jle`> so if (x :: Parser Int), a parser of Int's
14:14:23 <erisco> though parser combinator libraries advise you not to use them because they have more efficient equivalents
14:14:36 <jle`> then (many x :: Parser [Int]), a parser of many Int's, usually in a row
14:14:36 <monochrom> More precisely, in order for "many xxx" to make sense, you want xxx to succeed the first few times you call it, and then it fails the next time.
14:15:19 <monochrom> And so of course this cannot happen to [] and Maybe. But it totally happens all the time with parsers for example.
14:15:28 <monochrom> In fact they came from parsec.
14:15:33 <jle`> so it only really makes sense for Alternatives with some notion of state, where effect of an action depends on some changing state
14:17:09 <mnoonan_> erisco: re: your more reals than computer programs comment.. did you know there are models of ZFC that contain only countably-many sets?
14:17:44 <erisco> no, but that doesn't sound like a good foundation for reals
14:17:53 <monochrom> There are more reals than models of ZFC. :D
14:18:09 <mnoonan_> well, just model the reals inside of the countable ZFC model in the usual way and there you go :)
14:19:00 <hpc> Aelara: look up the computable reals
14:19:23 <monochrom> The problem is you can't use such a model directly. You can only go through the axioms, and the axioms are too weak to help you even discover that your target set is backed by a countable model.
14:19:43 <Profpatsch> I just can’t seem to be happy with the Shake library
14:19:51 <wedify> can i get suggestions for this error? http://lpaste.net/360483. it's a linker error i get from 'stack install sdl2'
14:19:58 <monochrom> In fact the axioms are going to give you the uncountable illusion.
14:19:58 <Profpatsch> It seems to break any amount of abstraction I try to throw at it.
14:20:30 <pgiarrusso> monochrom: indeed, inside the theory your set of real looks uncountable (because the theory can’t prove the biijection exists) — it’s only when you go to the metalevel that you see that “set of reals” is backed by a countable one
14:20:39 <Profpatsch> I can only get output paths in Actions, so any reference to input paths is lost.
14:21:02 <monochrom> Think of it as the TCP API gives you the illusion of well-sequenced nothing-fails communication but it's really backed by the reality of real networks always trying to mess up your packets.
14:21:15 <Profpatsch> If I want to build everything inside a build directory, I have to always strip inputs from their build directory.
14:21:19 <pgiarrusso> mnoonan: see my and monochrom comments ^^
14:21:19 <Profpatsch> Just doesn’t compose.
14:22:05 <mnoonan_> pgiarrusso: yes, I understand it
14:22:31 <pgiarrusso> :-)
14:22:48 <Profpatsch> DOesn’t help that you can’t depend on directories, only files.
14:23:26 <dminuoso> jle`: Mmm. This has suddenly turned from "parser combinators look rather cool and simple" into "magical unicorn land" with just two functions that Stephen Diel just barely mentioned.
14:24:23 <monochrom> Magical unicorn land looks rather cool and simple, too.
14:24:42 <monochrom> Especially since having one horn is certainly simpler than having 10 horns.
14:25:26 <monochrom> But I guess magical horse land is even simpler than magical unicorn land. The horn really does nothing.
14:26:07 <jle`> dminuoso: i mean if you're familiar with StateT, you can see how many/some would be useful for it
14:27:21 <jle`> @let decrement :: StateT Int Maybe Int; decrement = StateT $ \x -> if x >= 0 then Just (x, x-1) else Nothing
14:27:23 <lambdabot>  Defined.
14:27:32 <jle`> > runStateT (many decrement) 5
14:27:34 <lambdabot>  Just ([5,4,3,2,1,0],-1)
14:27:40 <jle`> > runStateT (many decrement) 0
14:27:42 <lambdabot>  Just ([0],-1)
14:27:54 <jle`> > runStateT (many decrement) (-1)
14:27:56 <lambdabot>  Just ([],-1)
14:27:58 <jle`> > runStateT (some decrement) (-1)
14:28:00 <lambdabot>  Nothing
14:29:00 <jle`> many repeats the action until there's a failure (Nothing, here), and returns all of the results.  'some' does the same, but returns Nothing (failure) if there were no successes at all
14:31:08 <jle`> some should really be :: Alternative f => f a -> f (NonEmpty a)
14:31:45 <monochrom> That will be fixed in the next Ten Year Plan. :)
14:37:01 <dminuoso> jle`: Alright thanks, that gives me something to work on. Ill plug this into the definition of more/some and see how this works.
14:37:26 <dminuoso> Just seeing `some x = pure (:) <*> x <*> many x` turned my head slightly :-)
14:37:53 <jle`> it might help to read it in ado form
14:37:56 <jle`> some x = do
14:38:00 <jle`>     y <- x
14:38:04 <jle`>     ys <- many x
14:38:09 <jle`>     pure (y:ys)
14:39:00 * hackage loc 0.1.3.2 - Types representing line and column positions and ranges in text files.  https://hackage.haskell.org/package/loc-0.1.3.2 (chris_martin)
14:39:05 <Cale> Or just simplify  pure f <*> x  to  f <$> x
14:39:24 * hackage loc-test 0.1.3.2 - Test-related utilities related to the /loc/ package.  https://hackage.haskell.org/package/loc-test-0.1.3.2 (chris_martin)
15:15:22 <dminuoso> Sigh.. [1]    66983 segmentation fault  stack ghci
15:17:09 <dminuoso> Okay so apparently today is not the day to step into this damn function `some`. :-)
15:19:10 <tabemann> when using gi-gtk I can get Haskell code to segfault easily
15:19:22 <tabemann> without having to use any unsafe functions
15:20:15 <crucify_me> if this makes sense, any suggestions for composed basic prelude functions that would be good practice for unifying the types ? I now understand how ' foldr (.) id ' is unified pretty well.
15:20:17 <dminuoso> tabemann: Well I did nothing but step into a harmless beginner function. But it appears that in todays nightly build the bug is gone.
15:20:35 <dminuoso> But its slightly frustrating to have 2 panics and 1 seg fault within a week doing only beginner stuff, no extensions or funky things. :(
15:20:59 <dminuoso> crucify_me: (.) . (.)
15:21:00 <tabemann> you got haskell to make your kernel panic?
15:21:21 <dminuoso> tabemann: nah, ghc panics
15:21:23 <crucify_me> trippy seriously dminuoso 
15:21:26 <crucify_me> ?
15:21:27 <tabemann> ah
15:21:44 <dminuoso> crucify_me: Yes. It's a freaking awesome combinator. You can also do (.) . (.) . (.) if you want
15:21:57 <dminuoso> I tried it, and failed. It's kind of confusing.
15:22:22 <crucify_me> confusing? you are writing to me regarding the second one?
15:22:56 <ph88> doubleChar :: [Char] -> [Char]    doubleChar = (>>= replicate 2)    how come  bind does the same as concatMap here ?
15:22:58 <dminuoso> crucify_me: I tried doing type unification on the first, after maybe 30 minutes of starring at as and bs I kind of gave up.
15:23:38 <dminuoso> ph88: For [] that's what bind does.
15:24:09 <ph88> oh ok
15:24:20 <crucify_me> how is it awesome dminuoso I cant comprehend it at the moment
15:24:39 <crucify_me> the 1st one
15:24:47 <crucify_me> let alone the 2nd one
15:25:43 <dminuoso> ph88: a >>= b is the same as `join $ b <$> a`, and for lists join folds using concat
15:26:02 <dminuoso> crucify_me: well the type makes it very obvious what it does.
15:26:10 <crucify_me> really
15:26:25 <dminuoso> :t (.)
15:26:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:26:27 <dminuoso> :t (.) . (.)
15:26:28 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
15:26:40 <dminuoso> :t (.) . (.) . (.)
15:26:41 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
15:27:07 <glguy> Doing Advent of Code this year? Join the #haskell group: http://adventofcode.com/2017/leaderboard/private 43100-84040706 (yes, I've sent this out already but every time I do a couple more people join)
15:27:10 <crucify_me> cannot follow what it does
15:27:28 <crucify_me> but would like to learn
15:27:30 <dminuoso> crucify_me: maybe aligning helps: https://gist.github.com/dminuoso/3d0b15ef96b149d35ddee3d8d2935ea7
15:28:05 <dminuoso> crucify_me: note that you can think of a as a1
15:28:11 <dminuoso> if that helps.
15:28:16 <Junior> Hi, I'm learning Haskell and I'd like to know any learning resources people have found useful.  Any recommendations?
15:28:25 <crucify_me> but in English what does the 1st one do?
15:28:37 <dminuoso> crucify_me: the first one is just (.) function composition.
15:28:46 <Junior> I'm reading Haskell Programming From First Principles book
15:28:51 <dminuoso> crucify_me: they are all function composition in fact.
15:29:12 <Junior> Also referring to Learn You A Haskell book.
15:29:27 <crucify_me> yeah, so what does it do and what would the inputs look like?
15:31:00 <dminuoso> crucify_me: f . g = \x -> f(g(x))
15:31:19 <dminuoso> crucify_me: the type signature tells you what the inputs look like.
15:32:50 <crucify_me> Junior, I started Graham Hutton's book. he's a professor with a very clear style. I found the other book to be overwhelming (from 1st principles) but I am not a programmer and self-teaching at later age.
15:34:09 <crucify_me> dminuoso, but functions f and g are not (.) 
15:34:31 <dminuoso> crucify_me: (.) is a function itself.
15:34:33 <Junior> crucify_me, that is his "Haskell Programming" book?
15:34:47 <dminuoso> crucify_me: so why not compose (.) after (.) ;-)
15:35:02 <Junior> I meant "Programming Haskell" book?
15:35:03 <glguy> Junior: http://www.cs.nott.ac.uk/~pszgmh/pih.html
15:35:08 <crucify_me> 2nd edition Junior . I can at least move through it with help here on the irc
15:35:16 <dminuoso> :t (.)
15:35:17 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:35:38 <dminuoso> Obviously since that has the characterstics of a' -> b' you can compose that with.. well (.) ;-)
15:36:14 <crucify_me> hmm I'm baffled, its not obvious to me
15:36:51 <Junior> Thanks, crucify_me.  I'll check that out.  Any other learning material you would recommend besides that book?  Blogs, Courses, videos?
15:37:30 <dminuoso> crucify_me: But fair enough, it's a bit heavy. Have you done `flip id` ?
15:37:31 <hpc> crucify_me: a' = (b -> c), b' = ((a -> b) -> a -> c)
15:37:52 <crucify_me> that and 1st principles book are well-regarded on this chatroom
15:38:01 <crucify_me> Junior, ^
15:38:27 <crucify_me> hpc sorry what's that there?
15:38:47 <hpc> that's how the type of (.) unifies with the type (a' -> b')
15:39:04 <crucify_me> thanks
15:39:39 <ahf> 290
15:39:41 <dminuoso> crucify_me: The last document on showing how type unification works out on (.) . (.) was about 130 lines long.
15:39:55 <Junior> I see, crucify_me.  Have you tried building an app with Haskell?
15:40:14 <dminuoso> crucify_me: The mental model that helped was rewriting into (.) (.) (.), and then starting off with (.) (.)
15:40:21 <crucify_me> ok thanks Im going to skip it. appreciate it. flip id I could probably do. dminuoso 
15:40:29 <dminuoso> crucify_me: flip id is a neat one. 
15:40:33 <dminuoso> :t id
15:40:34 <lambdabot> a -> a
15:40:36 <dminuoso> :t flip id
15:40:37 <lambdabot> b -> (b -> c) -> c
15:41:02 <erisco> :t const id
15:41:03 <lambdabot> b -> a -> a
15:41:15 <hpc> :t const const
15:41:16 <lambdabot> b1 -> a -> b2 -> a
15:41:37 <erisco> :t const . const
15:41:38 <lambdabot> a -> b1 -> b2 -> a
15:41:49 <takitus> Junior: If you can find it, Bird & Wadler's Introduction to Functional Programming Using Haskell is excellent. Not a Haskell tutorial, mind you.
15:42:12 <crucify_me> yeah I did flip id  and const id and found it interesting. let me paste something...
15:42:30 <crucify_me> not the unification per se but .. let me look at it again
15:42:58 <Cale> dminuoso, crucify_me: I find it helps to think of (.) . (.) as being a special case of fmap . fmap
15:43:21 <dminuoso> Cale: Yeah I learned about that trick from Edward Kmett when he talked about semantic editor combinators.
15:44:32 <crucify_me> Cale hmm, I haven't done fmap yet.
15:44:39 <Cale> So, fmap :: (a -> b) -> (f a -> f b), and so fmap . fmap :: (a -> b) -> (g (f a) -> g (f b)) (for some functors f and g)
15:44:42 <dminuoso> Cale: Or wait.. (.) is a kind of fmap?
15:44:49 <Cale> yeah
15:44:57 <Cale> with f t = e -> t
15:45:05 <Junior> takitus, thanks I'll check that out as well.  Any recommendations on a first app to build?  I was thinking of doing a toDo app.
15:45:49 <Cale> So if f t = e -> t, and g t = e' -> t, then we get  fmap . fmap :: (a -> b) -> (e' -> e -> a) -> (e' -> e -> b)
15:45:49 <crucify_me> sorry that is over my head. haven't met functor yet
15:46:08 <Cale> class Functor f where
15:46:14 <Cale>   fmap :: (a -> b) -> f a -> f b
15:46:38 <Cale> It just generalises the sorts of data structures that you can have "map"-like functions on
15:46:56 <Cale> If we pick f = (->) e
15:47:02 <takitus> Junior: As in a things-to-do-reminder? Sure, go for it.
15:47:10 <Cale> that is, the function type constructor partially applied to one argument
15:47:21 <Cale> (->) e a = e -> a
15:47:46 <Cale> then we get the specialised type:  fmap :: (a -> b) -> (e -> a) -> (e -> b)
15:47:50 <Junior> takitus, how is Haskell as far as web development goes?
15:47:51 <dminuoso> Cale: what is e in this case?
15:47:53 <Cale> which is exactly the type of function composition
15:48:00 <Cale> any fixed type
15:48:11 <Cale> (it's a type variable)
15:48:14 <EvanR> e for environment
15:48:26 <dminuoso> Cale: Mmm. Is this Functor instance made explicit somewhere?
15:48:34 <Cale> It's in the Prelude
15:49:08 <Cale> All there is to it is
15:49:15 <Cale> instance Functor ((->) e) where
15:49:19 <Cale>   fmap = (.)
15:49:45 <takitus> Junior: I can't comment, I haven't used it for anything Web-oriented yet.
15:50:10 <Junior> Okay, what kind of things have you used it for?
15:50:33 <EvanR> unpacking... fmap f myFunction x = f (myFunction x)
15:50:45 <Cale> Junior: My full time job is developing web applications entirely in Haskell, and I think it's pretty great overall
15:50:52 <EvanR> er, x would be better named e 
15:50:57 <dminuoso> Cale: Mmm curious, I did not spot it on https://hackage.haskell.org/package/base-4.10.0.0/docs/Data-Functor.html#t:Functor 
15:52:07 <Cale> Junior: We use Reflex-DOM with GHCJS to build the Web frontends, and Reflex-DOM with GHC's cross compilation to build Android and iOS application frontends from the same Reflex-DOM code.
15:52:14 <Junior> Cale, what web application framework do you use for your day to day job for this?  I was thinking of trying Yesod.
15:52:15 <dminuoso> Or maybe that LiftedRep threw me off. Not sure what that's about
15:52:52 <Cale> dminuoso: hmm, I don't know what instances are in scope there
15:53:17 <Cale> dminuoso: Apparently the instance is defined in GHC.Base though
15:53:29 <dminuoso> Well there is a `Functor ((->) LiftedRep LiftedRep r)` is that actually it?
15:54:16 <dminuoso> Ah yeah I see it in the source for it.
15:54:45 <Cale> Junior: For the backend stuff, we use Snap, even though we don't really use most of its features, since all our applications are single page applications which consist of a blob of Javascript compiled from Haskell that controls the contents of the DOM, and communicate with the backend via websocket.
15:55:24 <dminuoso> Cale: Well from that perspective (.) . (.) is quite obvious.
15:55:25 <Cale> Junior: So most of the complexity of the backend is dealing with all the websocket communication, which Snap doesn't really do a whole lot for (though it has some websockets integration that we do use)
15:55:37 <Cale> dminuoso: ahh, yeah, that would be it
15:55:54 <Cale> dminuoso: Haddock has some weird prettyprinting bugs when it comes to hidden arguments
15:56:09 <Cale> dminuoso: Since it works off of GHC's internal representations
15:56:20 <dminuoso> Ah fair enough
15:56:23 * hackage prometheus-client 0.3.0, prometheus-metrics-ghc 0.3.0, wai-middleware-prometheus 0.3.0 (fimad): https://qbin.io/wq7u9k2
15:57:42 <crucify_me> back to unifying, so now that I know how to do foldr (.) id  , and could probably do const id and flip id from earlier study, should one keep practicing how to unify higher order functions. how to master it?
15:57:59 <dminuoso> crucify_me: I've been told to just implement HM :|
15:58:13 <crucify_me> what's that?
15:58:34 <Junior> Cale: I see, so you work with straight pure Javascript?  No PureScript or something else for the front end coding?
15:58:54 <Cale> Junior: We write the frontend in Haskell. It gets compiled to Javascript by GHCJS
15:59:19 <Cale> The same frontend also gets compiled to ARM code to run on mobile devices
15:59:41 <dminuoso> crucify_me: The Hindley Milner typesystem. A system that formally describes what you have implicitly been doing to infer types from things like `foldr (.) id`
16:00:01 <crucify_me> Cale is a math whiz I think fwiw , Junior
16:00:01 <kritz> does anyone know / familiar with brick gui that can help me debug? 
16:00:03 <Cale> Somewhat ironically, our applications run a good bit faster on mobile devices with native ARM code controlling the contents of the DOM than on fast desktop machines running Javascript
16:00:39 <Junior> Cale,I see not to familiar with ghcjs.  I guess I have something else to research.
16:01:00 <Cale> Junior: You might want to check it out via reflex-platform
16:01:04 <kritz> im trying to port my 2048 console game to brick but im having trouble fixing my ui errors
16:01:10 <dminuoso> Cale: I find that very unsurprising. Been doing web development for a year now, and it's mindboggingly how slow browsers are - they make you forget the advances in chip design for the past 15 years.
16:01:10 <crucify_me> thanks dminuoso you go through that like a formal study?
16:01:13 <Cale> https://github.com/reflex-frp/reflex-platform
16:01:45 <Cale> Even if I didn't want to use reflex, if I had to install ghcjs, I would use reflex-platform to do it, just because it saves all the headaches involved in getting the right dependencies set up.
16:02:39 <Cale> If you scroll down to the readme section, there's a little tutorial there.
16:02:42 <dminuoso> crucify_me: Nah. I just learned the meaning of the symbols, then I just looked at each rule in the type system. Its actually not that hard.
16:02:54 <Junior> Cale, thanks.  I'll check that out.  Any recommendations on finding a Haskell development job without experience.  I have background in OO programming with the Microsoft .NET Framework.
16:03:05 <Cale> We still don't have nearly enough beginner documentation for reflex and reflex-dom, but dalaing has been writing a bunch of good blog posts.
16:04:40 <dminuoso> crucify_me: Havent done that because Im busy learning how parser combinators work, but I intend on trying out HM after I've started doing some parsers. It seems like the right order to do things.
16:05:06 <crucify_me> as long as Cale is here, if a beginner goes through those Bartosz lectures on category theory, can the math-weak beginner keep up ? I watched the 1st two videos and they were fairly easy.
16:05:13 <Cale> Junior: I'm really not sure. The reason I can find jobs is that I hung around on IRC and taught everyone Haskell for several years until some of them started companies :)
16:05:36 <Cale> crucify_me: I haven't watched his lectures.
16:06:04 <Cale> crucify_me: You shouldn't need to know any category theory in order to use Haskell effectively though.
16:06:06 <dminuoso> crucify_me: I have no math background, and I got through them fairly easy. Some I had to watch twice, and redraw my own diagrams.
16:06:36 <Cale> But if you are interested in it, just keep at it, and I'm sure you'll get somewhere :)
16:06:42 <kritz> can someone help me debug my 2048 game? I'm using brick GUI
16:06:45 <crucify_me> cool! I like math. right now I'm learning basic binary arithmetic
16:07:03 <crucify_me> binary long division is weird
16:07:39 <crucify_me> thanks for the input
16:08:47 <Wizek> kritz: Are you the person who also asked about Hs GUIs on /r/Haskell?
16:09:34 <kritz> yea lol, 
16:09:59 <kritz> i gave up on threepenny after it couldn't find my css paths, and now im having more trouble debugging brick
16:10:00 <woodson> I have question. If I want to impletement a jwt on my server when i send my token over to my elm client do i also need a jwt library in elm?
16:10:00 <woodson> [7:07] 
16:10:00 <woodson> im still confuse about the jwt do both parties need a jwt library to work with the token?
16:10:13 <Wizek> kritz: I might be able to help you. Can you give a bit of context about your problem?
16:11:00 <dminuoso> Cale: Ah ha. So (->) is a Functor between types?
16:11:09 <kritz> Wizek: so i tried to port my game to brick (it already runs on terminal but without keyboard input - instead it uses letters), following this tutorial: https://samtay.github.io/articles/brick.html
16:12:00 <dminuoso> Cale: This might be a silly question but, if (-> e) is a Functor, what exactly are the underlying categories
16:12:28 <kritz> But I'm having a bunch of debug errors, ranging from incorrect return types to (^.) not working 
16:12:42 <kritz> i mean compilation errors
16:12:46 <Junior> Cale and crucify_me thanks for the info guys.  I'm going to get going will be back. :)
16:13:28 <Wizek> kritz: can you post the type errors somewhere? E.g. as a gist?
16:14:28 <kritz> sure 1 sec
16:17:41 <Gurkenglas> singular casts traversals to traversal1s, unsafeSingular casts traversals to lenses. What other optic casts are possible?
16:20:36 <kritz> Wizek: https://codeshare.io/5wPNm9 Here it is, sry for the length
16:21:29 <Wizek> kritz: thanks, taking a look
16:22:02 <Cale> dminuoso: Hask and Hask
16:22:13 <Cale> dminuoso: (->) e is basically the covariant Hom functor
16:22:40 <Cale> (internal)
16:22:42 <Cale> Category theorists would write something like hom(E,-)
16:23:48 <Cale> It could also be regarded as -^E
16:24:23 * hackage classyplate 0.3.0.2 - Fuseable type-class based generics  https://hackage.haskell.org/package/classyplate-0.3.0.2 (lazac)
16:25:52 <dminuoso> Cale: Ah hom(E, -) made this blatantly obvious now, thanks.
16:28:15 <Wizek> kritz: You seem to have quite a few `Variable not in scope` errors. Are you missing some imports perhaps?
16:31:12 <kritz> Wizek: Yea, gotta correct those, thanks. The ones I don't understand are the ^., I assumed they are like getters in classes, and I followed it like the tutorial but I'm getting lenses errors
16:32:41 <ekr> for some reason i find the following unusually funny: https://en.wikipedia.org/wiki/John_Launchbury#Career_and_research 
16:32:50 <ekr> perhaps the most understating description of Haskell yet. (one among many other sources of inspiration for Swift).
16:33:08 <Wizek> kritz: They are like getters for ADTs indeed. It's part of `lens`. Let's start with fixing the missing imports first, and maybe some other errors will vanish too as a result, okay?
16:33:54 <kritz> Wizek: Sure, I'll update the code now
16:35:52 <mniip> haha
16:36:09 <mniip> I think I just had a taste of what edwardk called too many parameters
16:38:18 <kritz> Wizek: Just making sure, are my changes visable in real time? 
16:39:11 <mniip> comp_assoc : forall (X Y Z W : ob_carrier), forall (pX : ob X), forall (pY : ob Y), forall (pZ : ob Z), forall (pW : ob W), forall (f : hom_carrier X Y pX pY), forall (g : hom_carrier Y Z pY pZ), forall (h : hom_carrier Z W pZ pW), forall (pf : hom X Y pX pY f), forall (pg : hom Y Z pY pZ g), forall (ph : hom Z W pZ pW h), comp X Z W pX pZ pW (comp X Y Z pX pY pZ f g pf pg) h (comp_hom X Y Z pX pY pZ f g pf pg) ph = comp X Y W pX pY pW f (comp Y Z W 
16:39:11 <mniip> pY pZ pW g h pg ph) pf (comp_hom Y Z W pY pZ pW g h pg ph);
16:39:42 <Wizek> kritz: they seem to be. Ping me when to take a look when you are done, okay?
16:40:58 <kritz> Wizek: Now I've corrected the import errors, but I'm having trouble with the lenses. In the tutorial I was following, variables are names with _, which I was assuming are private variables. But they're accessed as ^. without the underscore. When i do the same I get a lenses error
16:41:34 <Wizek> kritz: taking a look
16:42:51 <Wizek> kritz: Did you also update the type errors in your paste? I still see some missing variables
16:44:31 <kritz> Wizek: I thought I did, which line are you referring to?
16:44:49 <Wizek> kritz: 12, for example
16:45:01 <Wizek> here: https://codeshare.io/5wPNm9
16:45:17 <kritz> Wizek: Yea I see your highlight, that's what I'm confused about
16:46:03 <Wizek> Oh, right, 1 sec
16:47:19 <Wizek> kritz: So, I see _grid is a field in your Game ADT. 
16:47:38 <Wizek> kritz: and indeed, it is "private", meaning if you use lenses, you won't have to touch it by hand
16:47:39 <kritz> Wizek: Yea, I thought if I access it using ^. I dont need the underscore
16:48:57 <Wizek> kritz: but first you have to define grid based on _grid. With the `lens` package you can do, IIRC, `makeLenses ''Grid` to have TemplateHaskell automatically define them for you
16:49:19 <Wizek> but wait a sec, checking if that's the same with the lens library you are using
16:50:44 <Wizek> kritz: looking here: https://hackage.haskell.org/package/microlens-0.4.8.1/docs/Lens-Micro.html it seems you'll need to include the `microlens-th` package
16:51:26 <Wizek> or you may also choose to just use the regular `lens` package if you will
16:51:30 <Wizek> which has this included
16:51:57 <kritz> you mean just import Lens?
16:53:12 <Wizek> kritz: read this page first: http://hackage.haskell.org/package/microlens-th-0.4.1.1/docs/Lens-Micro-TH.html the section titled `Dealing with “not in scope” errors` 
16:53:26 <kritz> Wizek: Thanks!
16:56:47 <Wizek> kritz: Ping me if it works. Oh and you'll have to write `makeLenses ''Game` not `makeLenses ''Grid`
16:57:27 <kritz> Wizek: Yup will do!
17:13:57 <dminuoso> jle`: Are you still around?
17:14:24 <jle`> potentially :)
17:16:02 <dminuoso> jle`: So I have been staring at `some` for the better part of an hour. Tried stepping through it, but kept seg faulting ghci so that option went out. https://gist.github.com/dminuoso/3357a594fb524c975a34dd0dd0c45094
17:17:02 <dminuoso> jle`: The thing that just confuses me is how this would advance the state. I just see circular recursion, but I dont get how this would work out.
17:26:40 <Cale> dminuoso: Which instance do you care about? Parser?
17:27:00 <Cale> dminuoso: Parser is the canonical thing to be considering here
17:27:14 <dminuoso> Cale: Sure. Let me paste what code I have.
17:27:20 <Cale> So, you parse one occurrence of x, and then zero or more occurrences of x
17:27:52 <Cale> (in the definition of some)
17:28:23 <Cale> and then for many, it's that you parse one or more occurrences of x, or you succeed without consuming any input
17:29:22 <dminuoso> Code updated.
17:29:35 <kritz> Wizek: Thanks for all the help! My last error seems correct according to line 137 in this example: https://github.com/samtay/snake/blob/master/src/UI.hs
17:30:17 <Cale> dminuoso: Okay
17:30:47 <monochrom> <|> and mplus should be identical. But a difference still wouldn't cause a segfault.
17:31:13 <monochrom> If you are segfaulting, you have a system-level problem.
17:34:37 <Wizek> kritz: You're welcome. Does that mean that you know how to deal with the last error, or would you still like some assistance with it?
17:35:12 <kritz> Wizek: I got it: had to add {-# LANGUAGE OverloadedStrings #-} 
17:35:20 <kritz> Wizek: Thank you so much!
17:35:32 <Wizek> kritz: Great! Glad to hear it compiles :)
17:56:26 <Gurkenglas> singular casts traversals to traversal1s, unsafeSingular casts traversals to lenses. What other optic casts are possible?
18:00:15 <glguy> A similar thing could exist to promote a prism to an iso
18:05:54 <Gurkenglas> oh wait singular doesn't cast a traversal l to a traversal1. Is it partsOf l . unsafeSingular _head?)
18:09:43 <Gurkenglas> You could cast a lens to an iso by assuming that the s is unused in the setter, right? (so you'd supply undefined to the setter's s argument)
18:11:10 <Gurkenglas> curious that you can't seem to go from traversal1s to prisms in the same way
18:26:22 <koz_> What's the Haskell equivalent of Beautiful Soup?
18:26:37 <woodson> anyone here familiar with jwt?
18:28:10 <Gurkenglas> koz_, try tagsoup
18:28:59 <koz_> Gurkenglas: OK, thanks!
18:41:11 <koz_> Gurkenglas: How would I use that to pull out the first thing on the page wrapped in <table> </table>?
18:45:37 <mbeidler> woodson: I may be able to help.
18:45:49 <mbeidler> woodson: What's your question?
18:54:12 <Gurkenglas> :t renderTags . takeWhile (~/= TagClose "title") . head . sections (~== TagOpen "title" []) . parseTags -- koz_ 
18:54:13 <lambdabot> Text.StringLike.StringLike c => c -> c
18:54:45 <koz_> Gurkenglas: Ah, OK, that makes sense. THanks!
18:58:08 <Gurkenglas> :t \s -> head [Text.HTML.TagSoup.Tree.renderTree within | Text.HTML.TagSoup.Tree.TagBranch "title" [] within <- Text.HTML.TagSoup.Tree.universeTree $ Text.HTML.TagSoup.Tree.parseTree s] -- koz_, or this if you like this more
18:58:09 <lambdabot> [Char] -> [Char]
18:58:59 <foo_> hello, how do i set change haskellPacakges to use haskell.packages.ghc822
18:59:15 <foo_> on nix 
19:46:23 * hackage colour 2.3.4 - A model for human colour/color perception  https://hackage.haskell.org/package/colour-2.3.4 (RussellOConnor)
19:55:00 <crucify_me> if you have flip (/) 3 4 , you get (/) 4 3 = 1.333 , so you can read the function as prefix notation. If you do flip id 3 (/) 4 , flip takes the two arguments of id , 3 (/) , flips them , so you can then read that as prefix notation, (/) 3 4 = 0.75  . Is that essentially correct ?
19:56:01 <Welkin> :t flip
19:56:02 <lambdabot> (a -> b -> c) -> b -> a -> c
19:57:10 <Welkin> :t flip id
19:57:11 <lambdabot> b -> (b -> c) -> c
19:57:43 <crucify_me> thanks I see how the unification works, so flip id allows id to accept 2 args, so 3 and (/) are flipped, right Welkin ?
19:58:12 <Welkin> (((flip id) 3) (/)) 4)
19:58:16 <crucify_me> which changes the output from flip (/) 3 4
19:58:24 <Welkin> er
19:58:27 <Axman6> .<(LISP)>.
19:58:37 <Welkin> yes, that is how the application works
19:58:42 <Welkin> it is always left to right
19:58:47 <Welkin> you can't arbitrarily group them
19:59:37 <Welkin> is this case, `id` is the same as ($) in terms of the type
19:59:44 <crucify_me> so once flip id is applied it is like you can read it in prefix notation, with the order of the two numeric arguments, 3 and 4, unchanged
19:59:44 <Welkin> which is (&)
19:59:47 <Welkin> :t (&)
19:59:49 <lambdabot> a -> (a -> b) -> b
19:59:50 <crucify_me> Welkin, 
19:59:51 <Welkin> reverse function application
20:00:47 <Welkin> `flip id (/) 3 4` is `4 / 3`
20:00:47 <crucify_me> is my last comment correct? to be redundant for pig-headedness sake? Welkin
20:00:54 <Welkin> > flip id (/) 3 4
20:00:56 <lambdabot>  error:
20:00:56 <lambdabot>      • Could not deduce (Fractional a0)
20:00:56 <lambdabot>        from the context: (Num ((a -> a -> a) -> t -> t1), Num t,
20:01:03 <Welkin> > flip id (/) 3.0 4.0
20:01:05 <lambdabot>  error:
20:01:05 <lambdabot>      • Could not deduce (Fractional t0)
20:01:05 <lambdabot>        from the context: (Fractional ((a -> a -> a) -> t -> t1),
20:01:14 <Welkin> > flip id (/) 3.0 4.0 :: Float
20:01:15 <lambdabot>  error:
20:01:15 <lambdabot>      • No instance for (Fractional
20:01:15 <lambdabot>                           ((Double -> Double -> Double) -> Double -> Float))
20:01:21 <Welkin> > flip id (/) 3.0 4.0 :: Double
20:01:22 <Welkin> o.o!
20:01:22 <lambdabot>  error:
20:01:23 <lambdabot>      • No instance for (Fractional
20:01:23 <lambdabot>                           ((Double -> Double -> Double) -> Double -> Double))
20:01:23 <MarcelineVQ> alright now :>
20:01:27 <Welkin> lol
20:01:29 <MarcelineVQ> :t flip id
20:01:29 <crucify_me> > flip id 3 (/) 4
20:01:30 <lambdabot> b -> (b -> c) -> c
20:01:32 <lambdabot>  0.75
20:01:33 <MarcelineVQ> note the function is argument 2
20:02:17 <crucify_me> yes right, its like id 3 is read as one argument, the 1st one MarcelineVQ 
20:02:19 <MarcelineVQ> you forgot your own advise about function application possibly :X
20:02:49 <crucify_me> I did?
20:02:49 <MarcelineVQ> in that flip id (/) 3.0 4.0  isn't flip id ((/) 3.0 4.0)
20:03:03 <MarcelineVQ> crucify_me: nnno Welkin
20:03:38 <MarcelineVQ> Welkin: unless you were tring to make a wall of errors :D
20:03:39 <crucify_me> but essentially to keep it straight I think of it from going from infix to prefix notation. to conceptualize
20:03:47 <crucify_me> as* going 
20:04:11 <crucify_me> with the numeric args unchanged. is that correct?
20:04:28 <MarcelineVQ> think of what as going from infix to prefix?
20:04:57 <crucify_me> yeah with flip id, since we have flip id 3 (/) 4
20:05:22 <crucify_me> so now we have (/) 3 4 after applying flip id
20:05:28 <Welkin> yes, the example confused me even after I explained flip id
20:06:04 <Welkin> are you doing this as a type exercise crucify_me ?
20:06:12 <Welkin> I like `const id`
20:06:15 <Welkin> :t const id
20:06:16 <lambdabot> b -> a -> a
20:06:33 <Welkin> :t flip const
20:06:34 <lambdabot> b -> c -> c
20:06:38 <Welkin> :D
20:06:46 <crucify_me> I am Welkin , but first I had to go back to make sure I understood flip id. 
20:09:14 <crucify_me> Welkin, id goes from being a unary to a binary function after the unification, is that correct? 
20:09:21 <crucify_me> > :t flip id
20:09:23 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:09:38 <crucify_me> :t flip id
20:09:39 <lambdabot> b -> (b -> c) -> c
20:10:02 <Welkin> :t flip
20:10:03 <lambdabot> (a -> b -> c) -> b -> a -> c
20:10:15 <Welkin> you unify the first parameter
20:10:45 <Welkin> id :: a -> a, and you want to unify with `a -> b -> c`, which is the same as `a -> (b -> c)`
20:10:54 <Welkin> so you get a ~ b -> c
20:10:57 <Welkin> then just substitute
20:11:50 <MarcelineVQ> I've described this in #haskell-beginners about 10 mins ago when you asked about it there if you'd like another take on it as well
20:12:10 <Welkin> write it out on paper
20:12:26 <Welkin> grab a blank sheet and just do some of these exercises of unifying and deriving types of functions on your own
20:12:31 <Welkin> it can be very fun and rewarding
20:12:37 <crucify_me> but simply put, flip permits id to accept two arguments. thanks MarcelineVQ kindly. 
20:12:54 <crucify_me> whereas normally it accepts one
20:12:55 <Welkin> no, id is gone after you apply flip to it
20:13:08 <Welkin> you get a new function
20:13:55 <MarcelineVQ> id can accept two arguments anyway, flip isn't doing something special
20:14:20 <MarcelineVQ> > id (+1) 1
20:14:20 <[Leary]> I never would have guessed flip id = flip ($). That's pretty cool.
20:14:22 <lambdabot>  2
20:14:41 <Welkin> [Leary]: that is because `id` can unify with ($)
20:14:49 <Welkin> but they don't have the same precedence
20:15:06 <Welkin> ($) has the lowest precendence
20:15:09 <MarcelineVQ> crucify_me: p.s. the first chapter of haskell first prinicipals is all about unification
20:15:51 <crucify_me> right ($) just makes id disappear so to speak and the flip is with the first numeric and (/) here : flip id 3 (/) 4
20:16:21 <crucify_me> flip applied => (/) 3 4
20:17:05 <crucify_me> is that kosher ^  ?
20:18:07 <crucify_me> that's what I meant by saying it is like prefix notation
20:23:58 <MarcelineVQ> ehhh kosher probably not, understanding it as flip id as causing a flip of the text itself is odd to me but if that's how you need to see it then go with that idea. people tend to want to understand it in terms of how function application changes the types though, which is an understanding that will help you with other functions instead of a specific understanding of one case of what a function is doing
20:27:19 <crucify_me> yes I see, also here and elsewhere I read that id can be substituted with ($) which does make to me now   MarcelineVQ 
20:29:39 <[Leary]> Looks like we also have (<*>) = liftA2 id. Nice. I've been underestimating id.
20:29:50 <MarcelineVQ> other way around ($) can be substituted with id
20:30:52 <crucify_me> ok I meant in terms of conceptualizing, again
20:31:12 <Welkin> [Leary]: you can also write anything with just `const` and (<*>) because they form the K and S combinators
20:31:44 <Welkin> I wonder if anyone did that yet
20:33:50 <jared-w> oh interesting, I never made that connection
20:35:07 <Average-user> I have a question about how lazy is Haskell, if I do:  head $ filter isPrime [a..b] That will filter all primes and then take the first, or as soon as it filters one will stop calculating?
20:35:22 <Welkin> is anyone doing a "24 Days of Hackage/GHC/Haskell" this year?
20:35:52 <Welkin> Average-user: it will only take the head
20:36:03 <Welkin> since it doesn't need the rest for any of the calculation, it will stop
20:36:19 <Welkin> well, the first result from your filter
20:36:56 <tabemann> note that if it were written as head $ getPrimes [a..b] it might force all of the primes in [a..b] to be calculated
20:37:26 <tabemann> e.g. if getPrimes were written as a tail recursive function with an accumulator that it reverses at the end
20:37:46 <Welkin> just use foldr :P
20:38:12 <Average-user> there are recursive functions that cant be done with folds right?
20:38:34 <Welkin> a fold is a recursive function
20:38:47 <koz_> Average-user: foldr can represent anything you can write with recursion.
20:38:59 <Axman6> I'm not sure how you'd ackermann with a fold...
20:39:06 <Axman6> do*
20:39:06 <koz_> s/represent/be used to write/
20:39:22 <Welkin> it can be difficult to write certain recursive functions using a fold though
20:39:35 <koz_> Axman6: Neither am, but then again, I wasn't sure how to write 'lazy nub using a HashSet auxilliary' until mniip showed me the way.
20:39:35 <Welkin> when it gets too complicated I just write an explicit recursive function
20:39:40 <koz_> (with something ungodly)
20:39:42 <Welkin> if it is ismple I'll use a fold
20:39:47 <koz_> And Welkin gives good advice.
20:40:13 <tabemann> am I right that there are computations that you can get better performance out of by not using a fold?
20:40:30 <tabemann> e.g. ones where you want to short-circuit at some point rather than iterating over the entire list
20:41:22 <mnoonan_> tabemann: that’s more about the laziness / strictness of the function being folded
20:41:47 <Average-user> someone doing AoC tonight?
20:41:55 <Welkin> AoC?
20:42:11 <Average-user> adventofcode
20:42:15 <Welkin> what is that?
20:42:24 <Average-user> http://adventofcode.com/
20:42:35 <Average-user> a puzzle gets released every day of dicember
20:42:41 <MarcelineVQ> ye, there's a leaderboard code in the topic
20:42:49 <Average-user> I know
20:42:52 <Average-user> I'm on it
20:43:12 <Welkin> haha
20:43:12 <MarcelineVQ> you asked a question you had an answer to, you're professor material :O
20:43:19 <Welkin> there are lots of fun events for the holidays
20:43:27 <MarcelineVQ> Average-user: enjoying it so far?
20:43:30 <tabemann> I mean functions like foldr (\x y -> x && y) True xs
20:43:32 <Welkin> I asked about "24 Days of Hackage/GHC/Haskell" earlier
20:43:34 <koz_> Rhetorical questions are best questions.
20:43:39 <Welkin> someone should be doing it
20:43:40 <MarcelineVQ> I'm a little worried about tonights task given yesterdays
20:43:57 <Average-user> MarcelineVQ: I was, until I decided to do the Day3 Part2 on Prolog...
20:45:12 <Average-user> previous years from day1 to 10 puzzles were arguably easier
20:46:03 <mnoonan_> > foldr (&&) True [True, False, error “boom”]
20:46:06 <lambdabot>  <hint>:1:37: error: lexical error at character 'b'
20:46:36 <mnoonan_> argh, stupid quote replacement
20:46:38 <Welkin> curly quotes
20:46:46 <Welkin> you need double prime marks
20:47:02 <mnoonan_> > foldr (&&) True [True, False, undefined]
20:47:04 <lambdabot>  False
20:47:18 <mnoonan_> ^ tabemann 
20:47:58 <[Leary]> > foldr (flip (&&)) True [True, False, undefined]
20:48:00 <lambdabot>  *Exception: Prelude.undefined
20:48:04 <Average-user> MarcelineVQ: How are you called on AoC?
20:48:05 <Welkin> > any id [False, True, undefined]
20:48:07 <lambdabot>  True
20:48:08 <Welkin> :D
20:48:10 <MarcelineVQ> the same
20:48:23 <Welkin> yet another cool use for `id`
20:49:02 <[Leary]> (&&) not /quite/ commutative. Heh.
20:49:05 <Welkin> > length $ filter id [False, True, False, True]
20:49:07 <lambdabot>  2
20:49:15 <tabemann> what I mean is that if you have a strict function you have to still traverse the entire list, even when you know that you don't really have to need to do so
20:49:36 <tabemann> so (&&) isn't the best example because it's not fully strict
20:49:54 <Average-user> MarcelineVQ: Ohh, I found u
20:50:09 <Welkin> > foldr (+) 0 [1, 2, undefined]
20:50:10 <Welkin> :D
20:50:11 <lambdabot>  *Exception: Prelude.undefined
20:52:02 <tabemann> but let's say we have (== 0) $ foldr (*) 1 [1, 0, 2] as a contrived example; we know the result will be 0 when we reach 0, but we have to traverse the rest of the list anyways
20:53:31 <Average-user> In a recursive definition you could pattern the 0 , so you don't have to go on with the list
20:54:27 <tabemann> that's what I mean
20:55:19 <Average-user> I know
20:56:10 <Average-user> MarcelineVQ:  Im curious about whats the ASCII picture of this year
20:57:27 <MarcelineVQ> it changes if you refresh too
20:57:33 <MarcelineVQ> dunno if that's normal
20:58:37 <Average-user> Don't remember if that happened previous years
20:58:49 <Average-user> weird 
21:02:25 <glguy> (Advent of Code) First language used to get both stars tonight? Haskell!
21:05:10 <jared-w> Average-user: a fold correlates to a catamorphism from recursion-schemes. There's a "catamorphism with the ability to short circuit" in recursion-schemes as well; that's what you would want in order to implement your efficient (== 0) $ <function> (*) 1 [1,0,2]
21:09:18 <glguy> Doing Advent of Code this year? Join the #haskell group http://adventofcode.com/2017/leaderboard/private 43100-84040706
21:09:32 <Welkin> glguy: do you need to submit every day?
21:09:36 <Welkin> or can you catch up?
21:09:41 <glguy> You can catch up
21:10:19 <glguy> If you want to be on the top of the leaderboard globally, you need to do it at midnight eastern time about every night
21:10:31 <glguy> but if you're just having fun you can always do them afterward
21:12:08 <Welkin> what is the number after your link?
21:12:44 <glguy> That's the code you put into the textbox on the link if you want to be listed on the private #haskell userlist
21:13:08 <glguy> It's #haskell by convention, but I only advertise it here :)
21:13:49 <jared-w> oooh nice. It's finals week this week so I should be able to have some time after...
21:13:55 <jared-w> Also, good to see you again, glguy :)
21:13:59 <glguy> o/
21:14:44 <Average-user> ENded
21:14:49 <Average-user> the Aoc
21:15:11 <Average-user> I got stuck on formating ...
21:16:51 <jared-w> glguy: It's #haskell by convention, but you only advertise it on #haskell? :p
21:17:16 <glguy> I just mean that as far as AoC is concerned its anonymous
21:17:24 <jle`> new AoC makes me happy i use haskell
21:17:30 <jared-w> ahhh gotcha
21:18:04 <jared-w> jle`: I liked your recent article that I saw on the sub :)
21:18:12 * jared-w will be back after the episode of Zumbo's Just Desserts ends
21:18:18 <Welkin> jle`: I've been looking at your hakyll code trying to figure out how to add nice previous/next links to my blog
21:18:30 <Average-user> " I just mean that as far as AoC is concerned its anonymous" what do you mean?
21:18:46 <Welkin> jle`: do you remember what you did conceptually to help make it more clear to me?
21:18:47 <glguy> If you open that link in AoC it doesn't say #haskell
21:18:56 <glguy> but *you'll know it is* because I told you, that's what i mean
21:19:16 <Welkin> It looks like you stored all of your posts in snapshots, then you pull them out later to grab the previous and next, at a high level
21:20:14 <Average-user> This last one I didn't do it on Haskell :(
21:20:33 <glguy> What'd you use?
21:20:40 <Welkin> Average-user: blasphemous
21:20:49 <Welkin> don't say java
21:21:23 <Average-user> Prolog
21:22:00 <infinisil> Oh my god kill me, currently writing really nasty Haskell, I hate it, but I don't have time to make it better (and learn how to do it even)
21:22:07 <Average-user> I decided to use Prolog, cause in my country puzzles get releases at 2am, so I wont be able to catch up every day
21:22:42 <Average-user> This way at least I learn about other stuff
21:22:45 <exio4> am I the only that kinda gets bored when solving AoC in Haskell? :p
21:22:59 <Average-user> Try with PROLOG!
21:23:20 <Average-user> its fun
21:23:23 * tabemann should learn Prolog
21:23:35 * hackage bearriver 0.10.4.1 - A replacement of Yampa based on Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.10.4.1 (keera_studios_ci)
21:23:56 <Average-user> https://github.com/Average-user/adventofcode-pl-2017 if someone it is interested
21:28:22 <vaibhavsagar> is there a simpler way to say 'filter id' in Haskell
21:29:44 <c_wraith> No.  Seems pretty simple to me anyway.  Like, almost to the point of being useful only in very limited cases
21:29:57 <MarcelineVQ> what are you doing after filter id?
21:30:00 <Average-user> ^
21:30:34 <c_wraith> I mean, the result of "filter id" is semantically equivalent to a natural number...
21:30:37 <Welkin> counting the number of True's?
21:31:51 <vaibhavsagar> yup
21:32:20 <vaibhavsagar> is there a simpler way to express that?
21:32:53 <vaibhavsagar> `length . filter id` is quite good, just curious if I'm leaving golfing opportunities on the table
21:33:03 <Welkin> to be more explicit: `length . filter (== True)`
21:33:20 <Welkin> I personally don't like `filter id` because it is hard to see what it is doing unless you really think about it
21:33:34 <Welkin> it's better to be clear rather than clever
21:33:38 <MarcelineVQ> dunno about simpler, could convert to 1/0 instead of True/False and sum
21:33:46 <tabemann> length . filter (== True) seems wasteful because you're constructing a whole new list which you will have to force the whole backbone of
21:34:20 <Axman6> looks pretty efficient to me, ghc's prety smart
21:34:26 <Axman6> pretty*
21:34:31 <jle`> tabemann: you probably don't construct a whole new list
21:34:48 <vaibhavsagar> this is for today's AoC challenge
21:34:54 <tabemann> Axman6: that assumes that fusion will do what one wants it to do
21:35:02 <vaibhavsagar> so I'm not hugely concerned with performance
21:35:20 <tabemann> but without fusion you are constructing a list containing all the Trues in the original list, and then forcing that entire list again
21:35:26 <Axman6> tabemann: that's a very safe assumption to make with those functions
21:36:43 <tabemann> sorry, I don't have a good sense for this kinda thing - I shouldn't've spent so many years coding in OCaml
21:37:15 <Axman6> length is a good consumer, and filter is a good producer, so it'll be fine
21:37:16 <tabemann> length . filter (== True) doesn't do what I said it would because length is consuming the list as filter constructs it
21:37:25 <Axman6> yes
21:37:53 <tabemann> I'm so used to using fold_left for everything and then reversing it when I am done
21:38:10 <tabemann> which has left me with some bad habits
21:38:57 <tabemann> like I don't like foldr because I'm so used to OCaml's fold_right not being used because in OCaml it'll explode the stack due to everything being strict
21:54:14 <Welkin> tabemann: haskell is not ocaml
22:02:53 <exio4> Welkin: I see nothing bad with filter id
22:03:12 <exio4> Welkin: (== True) feels redundant, too :)
22:03:22 <glguy> The main issue I see with needing filter id is that I'd generally prefer to not make the [Bool] in the first place
22:05:26 <exio4> foldl' (flip (bool id (+1))) 0 ? :P
22:05:30 <exio4> @type foldl' (flip (bool id (+1))) 0 
22:05:32 <lambdabot> (Num b, Foldable t) => t Bool -> b
22:07:03 <Axman6> > scanl (flip (bool (subtract 1) (+1))
22:07:04 <Axman6> 0
22:07:05 <lambdabot>  <hint>:1:37: error:
22:07:05 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:07:28 <Axman6> > scanl (flip (bool (subtract 1) (+1)) 0 [True,True,False,True,False,False,False,True]
22:07:30 <lambdabot>  <hint>:1:85: error:
22:07:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:07:44 <Axman6> > scanl (flip (bool (subtract 1) (+1))) 0 [True,True,False,True,False,False,False,True]
22:07:46 <lambdabot>  [0,1,2,1,2,1,0,-1,0]
22:21:12 * hackage pandoc 2.0.4 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.0.4 (JohnMacFarlane)
22:24:07 <danno131313> test
22:51:21 <jcarpenter2> Going up! *ding*
22:51:29 <jcarpenter2> M-x replace-string "lift $" "lift $ lift $"
22:55:01 <jcarpenter2> C-s run <ret> Reader run
22:55:19 <jcarpenter2> s/Reader run/Reader, run/
22:59:29 <rightfold> I want lifts to be rendered in smaller font and dimmer color
23:00:43 <rightfold> Maybe I should have functions l, ll, lll
23:01:09 <rightfold> But especially left and right with functor coproducts
23:15:19 <Gurkenglas-> Requesting "a -> Prism' (a, b) b".
23:21:32 <rightfold> lens snd . (,)
23:21:47 <rightfold> No wait :D
23:23:23 <glguy> Gurkenglas-: could that be more generally an Iso?
23:24:00 <glguy> or rather only if you made some promises
23:24:21 <glguy> to do the proper Prism you probably need an Eq constraint
23:25:16 <Gurkenglas-> Yes, will need the Eq constraint. Iso would only work if I'm promising that a is () with the argument pointing at its inhabitant.
23:25:25 <Gurkenglas-> :t only -- related
23:25:27 <lambdabot> (Applicative f, Choice p, Eq a1) => a2 -> p () (f ()) -> p a1 (f a1)
23:27:05 <Gurkenglas-> Right, lambdabot still bricks its tank treads with positive-position type aliases. "only :: Eq a => a -> Prism' a ()"
23:30:02 <drdo> http://lpaste.net/2282954767716057088
23:30:11 <drdo> What's up with this when doing "stack setup" ?
23:37:27 <[exa]> @pl \a b -> (:) <$> a <*> b
23:37:27 <lambdabot> (((:) <$>) .) . (<*>)
23:37:48 <[exa]> meh.
23:38:22 <MarcelineVQ> liftA2 (:)
23:38:35 <[exa]> oh thanks
23:39:05 <[exa]> also, I've decided to name it as operator <:>, is it a reasonable name? (I recall I've seen <:> used for something, but not sure where or what for)
23:39:06 <MarcelineVQ> you're getting into hot water when you're off in liftA2 (liftA2 (:)) id (map pure) land though
23:41:16 <jle`> liftA2 (liftA2 (:)) is maybe easier read as (liftA2 . liftA2) (:)
23:41:25 <jle`> 'just lift up two layers'
23:42:05 <[exa]> thankfully not going that direction :]
23:48:29 * hackage privileged-concurrency 0.6.2 - Provides privilege separated versions of the concurrency primitives.  https://hackage.haskell.org/package/privileged-concurrency-0.6.2 (OmerAgacan)
