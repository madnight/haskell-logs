00:00:19 <jle`> a Functor might "contain" many items.  but fmap doesn't map over all of the items that it contains
00:00:19 <mniip> basically I have a boolean function of N ternary variables and I need to emit some sort of optimal expression for the function
00:00:25 <jle`> this is why i don't like the idea of calling a Functor a container
00:00:28 <jle`> well, that's one of the many reasons
00:00:40 <mniip> N-dimensional arrays?
00:01:22 <jle`> kakashiAL: i mean, for a more common example, just look at the tuple
00:01:26 <jle`> > fmap (*2) (3,4)
00:01:28 <lambdabot>  (3,8)
00:01:50 <jle`> tuple contains two Ints, but fmap only maps over the second int?
00:02:00 <mniip> classic
00:02:03 <mniip> > length (3, 5)
00:02:05 <lambdabot>  1
00:02:06 <mniip> :D
00:02:10 <jle`> "mapping a function over the items in a container" is a bad bad bad intuition for functors
00:02:21 <jle`> > cycle "bad "
00:02:23 <lambdabot>  "bad bad bad bad bad bad bad bad bad bad bad bad bad bad bad bad bad bad bad...
00:02:45 <kakashiAL> jle`: so it always depends what you use for your mapping, if you have a set/list/tuple/whatEver, you decide HOW to map over it, the functor definitions/rules does not tell you that you have to map on all elements
00:03:27 <mniip> kakashiAL, you're still thinking about elements
00:03:31 <kakashiAL> jle`: with HOW to map over it, I mean HOW to apply the function
00:03:48 <mniip> here's one thing about functors you're forgetting
00:04:10 <mniip> functors are an object (in this case type) function too
00:04:13 <kakashiAL> mniip: not anymore, just want to get some confidence :)
00:04:18 <mniip> the Maybe functor maps type X to type Maybe X
00:04:36 <mniip> the ((,) e) functor maps type X to type (e, X)
00:04:49 <mniip> the "e" part of the tuple is not an "element" of your "container"
00:05:00 <mniip> hence you cannot "apply" your function to it
00:05:41 <mniip> it's a part of how you defined the (parameterised) type
00:05:45 <mniip> not just a whim of how you defined fmap
00:06:07 <kakashiAL> mniip: okay, so my assumptions are correct
00:06:20 <mniip> which ones
00:06:48 <jle`> kakashiAL: it's tricky to see this in javascript because javascript's type system doesn't have the ability to actually express the idea of a Functor
00:06:56 <isd> So, think of a data structure like an AVL tree. It also has all of this extra bookkeeping information in the nodes to help with balancing. But those aren't conceptually the "contents" of the tree.
00:07:06 <isd> "javascript's type system"
00:07:11 <jle`> kakashiAL: but we can invent a sort of meta-type system to reason with javascript and Box
00:07:12 <isd> are we talking about typescript?
00:07:25 <jle`> isd: javascript has a type system :)
00:07:35 <jle`> just not a particularly useful one
00:08:03 <isd> jle`: No, it doesn't. Type systems are a static thing.
00:08:10 <mniip> what no
00:08:36 <mniip> isd, of course it does
00:08:49 <mniip> dynamic typing is a type system too
00:08:56 <isd> No, it isn't.
00:09:06 <mniip> okay, answer this, what is a type system
00:09:07 <isd> Not anymore than dynamic bounds checking is a type system
00:09:19 <kakashiAL> mniip, jle: a functor is a datastructure. You can use fmap on it, which describes HOW you want to apply the function on that data that the functors holds
00:09:39 <mniip> no
00:09:58 <mniip> that is bad intuition
00:10:11 <jle`> isd: i don't think it's contervsial to say that dynamic type systems are a type system.  if you say that they aren't, then you are definitely using a non-standard definition of type system
00:10:33 <mniip> yeah right, when I say type system I mean a formal system with axioms and production rules
00:11:11 <kakashiAL> mniip: hmm...
00:11:16 <mniip> an example of a production rule in javascript could be
00:11:40 <mniip> (x : Double, y : Double) |- ((x + y) : Double)
00:11:44 <jle`> kakashiAL: remember, all functors contain two things -- you might be focused on the second thing
00:11:52 <jle`> kakashiAL: the mapping part
00:12:04 <jle`> kakashiAL: but you're forgetting the first "thing" that all functors must have
00:12:04 <isd> jle`: Eh, not really. The idea that "dynamic" types are a "type system" is really only accepted in the same circles where people regularly confuse static types and lack of type inference, or assume basically java.
00:12:19 <kakashiAL> jle`: you saw what I wrote? 5 minutes ago you agreed :/
00:12:21 <mniip> isd, see my comment
00:12:31 * hackage cabal-toolkit 0.0.4 - Helper functions for writing custom Setup.hs scripts.  https://hackage.haskell.org/package/cabal-toolkit-0.0.4 (terrorjack)
00:12:40 <jle`> kakashiAL: what did i agree with?
00:13:06 <mniip> say we took the formal system of untyped lambda calculus
00:13:11 <mniip> and added primitive atoms to it
00:13:19 <isd> mniip: You could certainly *add* a type system to javascript. typescript does this. That doesn't mean standard javascript already has one.
00:13:21 <mniip> and a judgement of whether a term is an atom or a lambda
00:13:22 <mniip> ban
00:13:24 <mniip> bam*
00:13:26 <mniip> type system
00:13:51 <kakashiAL> jle`: that a functor contains data and that you are able to apply a function on it, and that you dont have to apply that function to all elements (if it has elements) of that data that the functor holds
00:13:59 <mniip> isd, you seem to be misunderstanding the level of formality that is put into the words "type system"
00:14:49 <jle`> kakashiAL: that's not quite what i agreed to, and i didn't really mean to say that's what a functor "is"
00:14:52 <jle`> just what a functor is not, heh
00:15:21 <mniip> kakashiAL, none of that is true
00:15:33 <jle`> the rebellion is reborn today
00:15:38 <mniip> well besides the incredibly vague "you are able to apply a function on it"
00:15:39 <kakashiAL> jle`: I know that a functor must obay two laws
00:15:55 <jle`> kakashiAL: there are two parts to a functor. the laws apply to the second part
00:16:25 <kakashiAL> jle`: at least I learn that a functor does not have to apply the function to each element, if you have an array or a list
00:16:26 <mniip> did I upset him
00:16:53 <mniip> "array" is too vague
00:16:59 <mniip> too vague to say it's a functor
00:16:59 <kakashiAL> jle`: this means that your functor can have an array and transforms it to a string, boolean or int, right?
00:17:23 <jle`> kakashiAL: a Functor has to contain something that can take a *type* and return a *new type*.  this is easily definable in Haskell, but it's a bit trickier in Javascript
00:18:02 <kakashiAL> jle`: I see that as a yes to my assumption :)
00:18:32 <jle`> what assumption was that?
00:18:49 <kakashiAL> jle`: do you read what I write to you?:)
00:18:57 <jle`> er, transforming an array into a string is not a function on types
00:18:59 <jle`> it's a function on values
00:19:00 <mniip> do you read what we write to you
00:19:15 <jle`> if you can transform a string into a boolean, that's not taking a type and returning a new type
00:19:21 <jle`> that's taking a value and returning a new value
00:19:26 <kakashiAL> kakashiAL | jle`: this means that your functor can have an array and transforms it to a string, boolean or int, right?
00:19:40 <jle`> yes that's completely different than what i am talking about :)
00:19:45 <jle`> i am talking about functions that take types and return types
00:19:52 <jle`> what you are describing is functions that take values and return values of different types
00:19:54 <kakashiAL> jle`: but this is also what a functor can do, right?
00:20:04 <mniip> the tricky part is that those functions don't exist in javascript
00:20:25 <jle`> kakashiAL: some functors can do that
00:20:28 <jle`> but the interesting ones don't
00:20:48 <jle`> it's not essential to the characteristic of a functor
00:20:59 <kakashiAL> mniip: they do:   lengthOfAnArray(array)    lengthOfAnArray([1, 2, 3])  // returns 3
00:21:08 <jle`> that's different
00:21:12 <jle`> that's taking a value and returning a new value
00:21:18 <jle`> i'm talking about taking a *type* and returning a new *type*
00:21:31 <jle`> do you see the difference
00:21:32 <kakashiAL> jle`: sure it not the essential characteristic of a functor, but it is possible and its not against the functor laws
00:21:53 <jle`> i am sure it is not the essential characteristic of a functor
00:21:54 <mniip> kakashiAL, that's not an example of what I said
00:22:28 <kakashiAL>  jle` | kakashiAL: some functors can do that   <----thanks for that :)
00:22:38 <jle`> i think you might be missing the point
00:23:01 <jle`> talking about what 'some functors can do' doesn't help you reason about functors
00:23:05 <kakashiAL> jle`: no no, I just wanted clerification because of the many threads/blogs/articles I read
00:23:13 <jle`> for example, some functors have a Nothing constructor
00:23:20 <jle`> by 'some', i mean exactly 1
00:23:26 <jle`> data Maybe a = Just a | Nothing
00:23:41 <jle`> but that doesn't mean "functors are things with a Nothing constructor"
00:24:28 <kakashiAL> jle`: the reason why I am asking is because those references said "if a functor is not able to apply a function to all its elements, it not a functor" which is false, which limits the functor that why I wanted clearification that I have now ;)
00:24:54 <kakashiAL> jle`: now I can go a step further
00:25:05 <jle`> ah yeah.  that statement falls somewhere in between 'wrong' and 'not even wrong'
00:25:44 <kakashiAL> jle`: I am a student and I have to go and work now :( (in a ware house)
00:25:45 <jle`> but yea,h trivial counter-example is the haskell tuple
00:25:47 <kakashiAL> I be right back
00:25:58 <kakashiAL> (after work)
00:26:05 <kakashiAL> thanks all of you guys!
00:26:07 <jle`> have fun at work :)
00:26:49 <kakashiAL> jle`: no fun, but I can think more about functors where I need your help
00:26:54 <kakashiAL> so thanks again
00:26:55 <kakashiAL> laters!
00:34:24 <nek0> hi folks. I'm trying to compile a project on windows and am pretty much stuck with trying to tell pkg-config where to find the library information. It seems that it is ignoring the environment variable PKG_CONFIG_PATH.
00:34:40 <nek0> Has anyone here have some advice for me?
00:50:32 * hackage data-diverse 2.0.1.0 - Extensible records and polymorphic variants.  https://hackage.haskell.org/package/data-diverse-2.0.1.0 (louispan)
00:57:30 * hackage data-diverse-lens 2.0.0.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  https://hackage.haskell.org/package/data-diverse-lens-2.0.0.0 (louispan)
01:05:40 <kamyar> Hello fellows
01:06:01 <kamyar> I using strinConversions package discouraged?
01:06:13 <kamyar> string-conversions
01:23:24 <jchia_> Is there an idiomatic way for dealing with impossible cases? http://lpaste.net/361060
01:23:45 <jchia_> I could change the last case to "Right (Just _, x)", but that seems to obscure the intent.
01:24:24 <jchia_> The "omitted case", to be clear, is "Right (Just _, x)" after the last two cases.
01:24:34 <jchia_> So I get a ghc warning about exhaustive cases.
01:34:51 <metahumor> morning / good evening everyone
01:35:00 <metahumor> are people still working on AOCode?
01:38:49 * hackage slate 0.2.0.0 - A note taking CLI tool.  https://hackage.haskell.org/package/slate-0.2.0.0 (evuez)
01:40:05 <metahumor> just wanted to share a lens-based sol'n for dec23 aoc with y'all. was trying to see if StateT based computation would help me figure out the loops in today's problem
01:40:07 <metahumor> http://lpaste.net/361061
02:06:48 <kamyar> Someone please help me
02:07:12 <kamyar> I wanna know if using packages like string-conversions are discouraged?
02:07:24 <kamyar> is discouraged
02:22:19 * hackage data-diverse-lens 2.0.0.1 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  https://hackage.haskell.org/package/data-diverse-lens-2.0.0.1 (louispan)
02:50:07 * hackage importify 1.0.1 - Tool for haskell imports refactoring  https://hackage.haskell.org/package/importify-1.0.1 (shersh)
02:51:43 <nshepperd> jchia_: error "impossible"
03:00:41 <f-a> i am building a project with `cabal new-build`. Is there a way to trigger a build of the dependencies haddock docs? I would like to check them offline
03:04:27 * hackage data-diverse-lens 2.1.0.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  https://hackage.haskell.org/package/data-diverse-lens-2.1.0.0 (louispan)
03:21:10 <Adluc> Hello, does anyone know about how to get rid of "deriving (Show, Eq)" for each data type? For that deriving clause be automagically generated? I dont feel yet for TH myself
03:21:30 <Adluc> or quasiquote
03:24:15 <f-a> Adluc: as you said, th
03:24:21 <ertes> Adluc: TH is the only way, and it doesn't really pay off
03:24:46 <ertes> unless you do something crazy like "derive Eq and Show for all types in this module"
03:25:27 <Adluc> ertes: thats what I do in parser, but I will probably make it .lhs and just < all deriving lines
03:33:37 <ondrejs> Hello, anyone here working with/on llvm-hs for a chat about function return types with llvm-hs-5.1? /cc cocreature
03:34:26 <jchia_1> nshepperd: OK. I'm wondering whether I should be concerned about performance implication of allowing dead code to be generated by the compiler.
03:35:43 <cocreature> ondrejs: I don’t have time right now but I’ll try reading the backlog
03:40:18 <kuribas> Hi, I am allowed to give a talk to our local functional programming group.  Especially about how expression type systems can give you the flexibility that a dynamic language gives you, but being also typesafe.
03:41:22 <kuribas> I could present my own library, but I thought it would be nice to give counterweight to the clojure idea that static types are hard to extend.
03:41:53 <kuribas> Any ideas on topics that might be interesting?
03:42:25 <ertes> perhaps an explanation what flexibility is exactly missing from static languages, because that's the first thing i would ask
03:42:43 <ertes> s/is exactly/exactly is/
03:44:14 <kuribas> ertes: well, they claim that static types are closed, and dynamic types open, whatever that may mean..
03:45:01 <ertes> so there are types that Data.Dynamic can't wrap?
03:45:11 <ondrejs> cocreature: as nobody else is responding I'll try to ask later
03:45:38 <kuribas> ertes: well, Data.Dynamic would count as dynamic typing?
03:45:46 <ertes> kuribas: of course
03:46:04 <ertes> kuribas: one thing people don't get is that static typing and dynamic typing are orthogonal
03:46:20 <ertes> there aren't "dynamically typed languages", there are only "languages that lack static typing"
03:46:27 <kuribas> ertes: do people actually use Data.Dynamic?
03:46:35 <kuribas> ertes: right
03:46:39 <kuribas> :)
03:47:07 <ertes> kuribas: i don't use Data.Dynamic, but i do use Control.Exception
03:47:11 <ertes> SomeException is also dynamic typing
03:47:27 <kuribas> hm true
03:47:28 <ertes> it's pretty much just Dynamic with extra constraints
03:48:19 <kuribas> I was thinking how type variables can replace subtyping.
03:48:46 <kuribas> like "data Person a = ..."  then "type Employee = Person EmployeeData"
03:50:02 <kuribas> because that example comes up sometimes in discussions about dynamic types.
03:50:17 <ertes> kuribas: i think the first point to get across is that you don't *lose* anything by going static, and the second point would be that for the most part you *shouldn't* extend types
03:50:31 <kuribas> ertes: right
03:51:33 <kuribas> ertes: you mean that closed types imply correctness, and extending them will make the type checker help you maintain correctness.
03:52:58 <ertes> kuribas: programmers who use dynamic typing and especially OO programmers tend to insist on building one-to-one relationships between types and "things in memory"…  that's why they like to represent both "Vehicle" and "Car" as types
03:53:20 <ertes> in haskell 'car' would more likely be a value of type Vehicle
03:53:44 <ertes> types are models, and that's why they should be closed
03:54:21 <ertes> there is still a way to "extend"…  you just have to switch from the "extension" mindset to the "translation" mindset
03:54:53 <ertes> types are not only models, but also languages, and an "extension" is really just a more expressive language that you can translate the original language to
03:54:57 <ertes> or vice versa
03:55:36 <kuribas> right, thanks
03:55:39 <ertes> if you were to represent both vehicles and cars as types, there would be a function (Car -> Vehicle)
03:55:51 <ertes> or even a (Lens Car Vehicle)
03:56:04 <ertes> *Lens'
03:56:48 <maerwald> how is haskell for gRPC
04:00:46 <Adluc> parseRegionBoundary = (pure StartRegion <$> "G36") <|> (pure EndRegion <$> "G37")
04:00:52 <Adluc> how can I factorize the pure out?
04:01:47 <ertes> Adluc: EndRegion <$ "G37"
04:02:06 <ertes> :t (<$)
04:02:07 <lambdabot> Functor f => a -> f b -> f a
04:02:35 <Adluc> ertes: thanks! :D
04:02:43 <jle`> Adluc: by the way, i suspect that pure might not be doing what you think it's doing there
04:03:16 <kuribas> Adluc: the first argument of <$> is a function.
04:03:38 <Adluc> EngRegion <$ string "G37"
04:03:48 <Adluc> there is some magic hiding the string
04:03:53 <Adluc> (attoparsec)
04:04:09 <jle`> Adluc: i mean, 'pure' there is used in a way that people would normally use 'const' for
04:04:22 <jle`> const StartRegion <$> string "G36"
04:04:55 <jle`> instead of, say, `pure StartRegion <* string "G36"`
04:05:01 <jle`> which is actual pure for Parser
04:05:29 <jle`> the pure in your original code was not pure for Parser, but rather 'const', pure for functions
04:05:42 <jle`> but that might have been intentional :)
04:05:53 <Adluc> const StartRegion :: b -> RegionBoundary
04:05:54 <Adluc> pure StartRegion :: Applicative f => f RegionBoundary
04:06:06 <kuribas> if that's intentional, then it's obfuscation
04:06:10 <ertes> > pure 1 2
04:06:12 <lambdabot>  1
04:06:15 <Adluc> no its not, but it worked ^_^
04:07:03 <Adluc> will take that const in mind
04:07:27 <kuribas> I've yet to see a use of the monad instance ((->) r) that was readable (without type signatures).
04:07:28 <jle`> yeah, you might have originally meant to write pure StartRegion <* "G36"
04:07:55 <ertes> liftA2 (+) f g x
04:08:07 <ertes> can be useful from time to time
04:08:10 <jle`> kuribas: i use join sometimes when i'm lazy
04:08:19 <jle`> > join (,) 1 'a'
04:08:21 <lambdabot>  error:
04:08:22 <lambdabot>      • Couldn't match type ‘(Integer, Integer)’ with ‘Char -> t’
04:08:22 <lambdabot>        Expected type: Integer -> Char -> t
04:08:23 <jle`> oops
04:08:29 <jle`> > join (,) 1
04:08:31 <lambdabot>  (1,1)
04:11:30 <kuribas> jle`: neat, but still obfuscated
04:11:45 <kuribas> join (*) 3
04:11:47 <kuribas> > join (*) 3
04:11:49 <lambdabot>  9
04:11:58 <jle`> yeah last tiem i had the occasion to use it i factored it out into a named function when i was cleaning it up
04:12:00 <ertes> totally, better do it this way:
04:12:04 <ertes> > liftA2 (,) id id 1
04:12:06 <lambdabot>  (1,1)
04:12:48 <ertes> or to confuse everybody…
04:12:52 <ertes> > liftA2 (,) get get 1
04:12:54 <lambdabot>  error:
04:12:54 <lambdabot>      • Could not deduce (Num t0)
04:12:54 <lambdabot>        from the context: (Num t, MonadState b ((->) t))
04:12:59 <ertes> err
04:13:02 <ertes> > liftA2 (,) ask ask 1
04:13:05 <lambdabot>  (1,1)
04:14:23 <kuribas> ertes: that's a lot more readable, because the meaning of ask is clear.
04:14:37 <kuribas> And you can see directly that you use the reader monad.
04:14:52 <ertes> let's combine both for full effect
04:14:54 <ertes> > join (liftA2 (,)) ask 1
04:14:57 <lambdabot>  (1,1)
04:15:58 <nshepperd> > liftA2 (liftA2 (,)) ask ask ask 1
04:16:00 <lambdabot>  (1,1)
04:16:52 <maerwald> I guess no one uses haskell for gRPC really
04:16:58 <jle`> > ask ask ask ask ask ask ask ask 1
04:17:01 <lambdabot>  1
04:17:09 <ertes> > fix ask
04:17:12 <lambdabot>  *Exception: <<loop>>
04:18:21 <jle`> > iterate ask ask <*> [1]
04:18:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:19:33 <int-e> @check \x -> ask x == id (x :: Int)
04:19:35 <lambdabot>  +++ OK, passed 100 tests.
04:20:10 <jle`> yes but what about the 101st test
04:21:01 <int-e> @src (->) ask
04:21:01 <lambdabot> ask = id
04:21:13 <int-e> That fiction supports the hypothesis as well. :)
04:21:29 <ertes> > foldr (\x -> liftA2 (<|>) ((x:) <$>) ask) [[]] "abc"
04:21:31 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
04:22:08 <jle`> > ask "ask"
04:22:11 <lambdabot>  "ask"
04:24:09 <nshepperd> > liftA2 (liftA2 (liftA2 (liftA2 (,)))) ask ask ask ask ask 1
04:24:11 <lambdabot>  (1,1)
04:26:20 <kuribas> maerwald: I don't know what that is
04:27:02 <kuribas> maerwald: something about remote procedures?
04:27:13 <kuribas> maerwald: there's cloud haskell...
04:34:15 <maerwald> no, I was specifically asking about gRPC
04:49:37 <fakenullie> Am i overcomplicating this queue benchmark?
04:49:39 <fakenullie> http://lpaste.net/361065
04:57:13 <lyxia> I would write (toListList . pushPop pushList popList) []
04:58:01 <lyxia> this avoids the unrealistic overhead of matching on the tuple
04:58:06 <Gurkenglas> fakenullie, the derived type signature for pushPop would be more general
04:58:45 <fakenullie> I get ambiguous type, but now I solved by specifying type for Queue [] []
04:59:08 <fakenullie> I'm mostly concerned about pushPop function
05:00:38 <lyxia> [1..100] and [101..150] should really be in the second argument of nf
05:00:45 <Gurkenglas> It can't derive that? Huh, I expected pushPop :: (b, Integer -> b -> b, b -> Maybe (Integer, b)) -> b
05:01:42 <fakenullie> hm I didn't think about that
05:03:14 <Gurkenglas> I would inline some or all of 27-29
05:04:08 <lyxia> nf (toListList . pushPop [] pushList popList) ([1..100], [101..150])   -- the data should be the second argument, so that the function being benchmarked cannot make any assumption about it.
05:23:13 <huss`> Hey guys can anyone tell me if I can use a basic function where an Arrow is expected
05:23:44 <huss`> Withouth having to explicitly wrap it with arr ?
05:23:51 <ski> no
05:24:31 <ski> (unless the arrow expected is a function, i.e.)
05:24:37 <huss`> okay thanks :)
05:25:00 <ski> (saying "where an `Arrow' is expected" is misleading at best, and a misunderstanding at worst)
05:25:48 <huss`> where an instance of arrow is expected I should say ?
05:26:13 <ski> that's not really that good either, since "instance" has a technical meaning in Haskell
05:26:47 <Gurkenglas> Note that if you assume that you can, the worst that happens is that you get a compiler error and drop the assumption
05:26:58 <huss`> I have a type data type that is an instance of control.arrow
05:28:00 <Gurkenglas> (Though I suppose that when you start treating the railing as the floor, you cease to have a railing)
05:28:06 <ski> if you have `foo :: Arrow ar => ar X Y -> ...', then, when calling `foo', you control what kind of arrow you want to pass, and so you could pass a function to `foo'
05:29:32 <ski> if you are defining `bar :: Arrow ar => (ar X Y -> ...) -> ...' by `bar foo = ...', then in that body of `bar', if you want to call `foo', you *don't* control what kind of arrow to pass to `foo', and so you can't pass a function (without using `arr')
05:29:44 <huss`> I see
05:30:05 <huss`> thanks
05:30:29 <Gurkenglas> ski, I'd rather say "bar :: Arrow ar => ar X Y" there
05:30:50 <ski> in both cases, one could say that `foo' expects to be passed "an arrow" (and not of a specific type, but there being some polymorphism/genericity involved), but the crucial bit is *who* decides what type of arrow to pass
05:31:32 <ski> Gurkenglas : also works, to some degree, but i wanted a `foo' to "pass an arrow to", in both cases
05:34:02 <huss`> do you have an example where its useful to have your own arrow type ?
05:34:13 <Gurkenglas> Good question!
05:34:30 <ski> `Arrow' doesn't tend to be used that much
05:34:57 <huss`> i use it for the operators
05:35:00 <huss`> like (***)
05:35:08 <Rembane> +1
05:35:29 <ski> (btw, the above reasoning also applies to "where a monadic action is expected", &c.)
05:36:43 <Gurkenglas> Is there a proposal to deprecate Arrow and move the actually used operators to Data.Tuple?
05:37:14 <huss`> i feel like its tedious to map tuple
05:42:59 <fiatjaf> http://entulho.fiatjaf.alhur.es/notes/my-stupid-introduction-to-haskell/
05:45:26 <lyxia> I prefer bimap to (***) and liftA2 (,) to (&&&).
05:48:47 <lyxia> I think Arrows is going to remain for a while, it has users, both accidental and intentional.
05:49:00 <Gurkenglas> Could we allow Data.Tuple to reexport a specialized-to-functions version of Control.Arrow that is subsumed by Control.Arrow when that is imported?
05:51:40 <lyxia> I think Bifunctor subsumes most of it already
05:53:33 <ski> being able to reexport an operation with a more restricted type signature would be interesting
05:53:43 <Gurkenglas> Without context, "(***)" and "(&&&)" seem prettier than "bimap" and "bimap after liftA2 (,)"
05:54:25 <Gurkenglas> Ooh we could have a reexport of Control.Lens with saner type signatures!
05:54:54 <ertes> we could deprecate Arrow in favour of Applicative
05:55:21 <Gurkenglas> Control.Lens.Sane
05:56:32 <ertes> if a type class has 52651 laws that nobody bothers checking, you know something is wrong
05:56:58 <huss`> lyxia: Ohh didn't tought about bifunctor ^^
06:00:12 <Gurkenglas> Or an ivory tower of modules that starts at just enough to make record update syntax pretty and unlocks more generalizations at each step.
06:02:05 <huss`> Are lenses profunctor composition ?
06:03:08 <huss`> how would you name them
06:03:29 <royal_screwup21> would it be right to say that the type definition ofo concat is [[a]] -> [a]? Because it takes in a list of lists and breaks down the sublists merge all their elements into one lsit. ghci says it's Foldable t => t [a] -> [a] but I'm not sure what that means (I'm a total noob).
06:04:00 <huss`> i think that [] is foldable
06:04:21 <huss`> so replacing t with [] -> [[a]] ?
06:04:43 <ertes> royal_screwup21: for types the syntax "[a]" is the same as "[] a"
06:04:47 * hackage concurrency 1.3.0.0, hunit-dejafu 1.0.0.0, dejafu 1.0.0.0, tasty-dejafu 1.0.0.0 (barrucadu): https://qbin.io/u4mcglx
06:04:52 <ertes> royal_screwup21: now set t = []
06:05:20 <royal_screwup21> ah okau
06:05:22 <royal_screwup21> okay*
06:06:00 <Gurkenglas> Have any of you ever had a LensLike f that was not also one of the named aliases for LensLike f?
06:06:11 <Gurkenglas> (Disregard ')
06:10:54 <ertes> value :: (MonadIO m) => LensLike' m (IORef a) a
06:11:13 <ertes> contents :: (MonadIO m) => LensLike' m FilePath ByteString
06:12:14 <ertes> though it's kinda difficult to come up with meaningful laws for those
06:16:41 <nshepperd> how do you use those? the usual getter/setter functions won't work
06:17:25 <ertes> you write ones that do
06:26:26 * hackage stack 1.6.3 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.6.3 (borsboom)
06:28:06 <ertes> and i thought i write terrible synopses =)
06:36:48 * hackage movie-monad 0.0.3.0 - Plays videos using GStreamer and GTK+.  https://hackage.haskell.org/package/movie-monad-0.0.3.0 (lettier)
06:39:49 <Gurkenglas> ertes, shouldn't t be () in value and contents?
06:57:40 <lyxia> huss`: lenses were originally introduced as composable getters/setters. The observation that they can be neatly represented as profunctor-polymorphic functions (p a b -> p s t) came independently from naming it "lens".
06:58:54 <huss`> lyxia: so they were discovered separately ?
07:03:02 <namosca> Hi all... I installed haskell-stack on my ubuntu, but when I run stack install (or stack anything), I get the error:
07:03:02 <namosca> Downloading lts-10.0 build plan ...FailedConnectionException2 "raw.githubusercontent.com" 443 True getAddrInfo: does not exist (Temporary failure in name resolution)
07:03:10 <namosca> How can I fix it? Thanks
07:05:29 <Gurkenglas> namosca, if you do not get answers here you can try to submit on https://github.com/commercialhaskell/stack/issues
07:06:49 * hackage slate 0.3.0.0 - A note taking CLI tool.  https://hackage.haskell.org/package/slate-0.3.0.0 (evuez)
07:08:01 <shiona> sounds like a network problem
07:11:18 <jchia_1> namosca: If "nslookup raw.githubusercontent.com" fails, the problem is a network problem.
07:12:04 <namosca> it doesnt fail the nslookup... and sometimes stack gives other error:
07:12:20 <namosca> Downloaded lts-10.0 build plan.
07:12:20 <namosca> AesonException "Error in $.packages.cassava.constraints.flags: failed to parse field packages: failed to parse field constraints: failed to parse field flags: Invalid flag name: \"bytestring--lt-0_10_4\"
07:14:25 <lyxia> huss`: Van Laarhoven lenses and profunctor lenses appeared explicitly as improvements to lenses.
07:16:03 <lyxia> namosca: Have you upgraded stack? https://github.com/haskell-hvr/cassava/pull/155
07:17:10 <namosca> lyxia: thisis a fresh install from 3 or 4 days ago, after which I indeed did stack upgrade
07:18:58 <namosca> i am trying stack upgrade again to see if it helps
07:23:57 <elvishjerricco> Whaat is the difference between `seq x y` and `let !_ = x in y`?
07:24:51 <ski> no difference
07:25:44 <elvishjerricco> Do they both have the same lack of guarantees about order of evaluation?
07:25:57 <ski> yes
07:26:06 <int-e> well, the latter requires a language extension
07:26:09 <elvishjerricco> And the same implementation details in that respect?
07:26:45 <ski> `x' could even be forced after `y' has been forced, and its value returned to the context
07:27:33 <ski> (as long as it's eventually forced, so that the behaviour is the same if `x' is bottom, as if `y' was bottom)
07:27:48 <ski> i'd expect so
07:27:50 <saurabhnanda> is there any text that explain the concept of polymorphism really well?
07:28:14 <mniip> wadler's theorems for free?
07:29:00 <ski> tried "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> ?
07:29:31 <elvishjerricco> Theorems for free is more of an academic thing and covers quite a bit more than I'd guess saurabhnanda is asking about
07:29:48 <ski> @help free
07:29:48 <lambdabot> free <ident>. Generate theorems for free
07:30:16 <elvishjerricco> That said I use intuition gleamed from theorems for free all the time :P
07:30:19 <ski> @free splitAt
07:30:20 <lambdabot> $map_Pair ($map f) ($map f) . splitAt x = splitAt x . $map f
07:32:01 <saurabhnanda> ski:  that paper is good, but is there something that helps build the "intuition" for polymorphism before jumping into definitions?
07:32:18 <exio4> ski: that paper is so nice
07:32:48 <saurabhnanda> ski: i correct myself. that paper won't work... page 10 is where it all falls apart!
07:33:42 <saurabhnanda> btw, figure 1 on that paper... Haskell is what kind of polymorphism? parametric?
07:33:47 <ski> perhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> could also be helpful
07:33:54 <ski> parametric, yes
07:33:59 <saurabhnanda> java and c++ are overloading, right?
07:34:08 <saurabhnanda> what are java generics?
07:34:14 <saurabhnanda> parametric?
07:34:18 <lyxia> java generics are parametric
07:34:20 <ski> yes
07:34:33 <lyxia> you can have multiple kinds of polymorphism in one language
07:34:37 <saurabhnanda> most dynamic languages would be ad-hoc polymorphism, right?
07:34:48 <exio4> dynamic languages have no polymorphism
07:34:59 <saurabhnanda> "Ad-hoc polymorphism is obtained when a function works, or appears to work, on several different types (which may not exhibit a common structure) and may behave in unrelated ways for each type."
07:35:07 <ski> there's also inclusion polymorphism (subtyping) in Java. as well as ad-hoc polymorphism (overloading and coercion)
07:35:33 <saurabhnanda> what's an example of coercion polymorphism?
07:36:10 <ski>   1.0 + 2
07:36:36 <saurabhnanda> section 1.3 of that paper is very well written... but I'm still unsure if a newbie will understand it.
07:37:35 <ski> with (single parameter) type classes in Haskell, we get a kind of bounded (parametric) polymorphism. a not-quite-so ad-hoc polymorphism
07:38:56 <saurabhnanda> type-classes can be used to implement ad-hoc (overloading), right?
07:39:00 <ski> (otherwise bounded polymorphism is usually a combination with subtyping, like `forall a :< T. ..a..')
07:39:19 <saurabhnanda> is that why some people go on & on about lawless type-classes/
07:39:22 <ski> well. not quite so nicely
07:40:12 <ski> you can't easily use the same method name for operations with different arity, e.g.
07:41:32 <saurabhnanda> unless you're Lucid.
07:41:51 <saurabhnanda> (the error messages are incomprehensible!)
07:42:07 <ski> well, i was talking about Haskell type classes :)
07:43:32 <saurabhnanda> Lucid = Haskell library.
07:49:58 <ski> oh. for some reason i was supposing you were referring to <https://en.wikipedia.org/wiki/Lucid_(programming_language)>
07:59:00 <saurabhnanda> hmmm... what's the best way to really explain parametric polymorphism in functions and ADTs to a newbie?
07:59:09 <saurabhnanda> LYAH just skims over it
08:00:25 <namosca> saurabhnanda: If I was a student I would like that somebody teaches me by showing practical examples
08:00:51 <namosca> saurabhnanda: with everyday life applications
08:01:21 <saurabhnanda> namosca: like WHY one needs polymorphism in the first place?
08:02:36 <namosca> saurabhnanda: Yes... try to make a program without polimorphism and see how it hurts in the ass... than present a way of easing the situation, and then say then label it polymorphism
08:03:07 <namosca> *nd then label it polymorphism
08:03:44 <namosca> saurabhnanda: With no academic mumbo-jumbo
08:05:57 <ski> imagine if we had `reverseIntList :: [Int] -> [Int]',`reverseStringList :: [String] -> [String]', &c. .. all with identical implementations
08:06:37 <ski> imagine if we could define a single `reverse' function, using that implementation, and it'd "just work" in place of `reverseIntList',`reverseStringList',&c.
08:07:22 <ski> what is the common part of the type signatures ? how can we express this common pattern in a type signature ?
08:11:06 <ski> (for some while, PDC (formerly Turbo, now Visual) Prolog didn't have parametric polymorphism. then they got tired of adding the umpteenth overloading of the append/3 predicate)
08:12:19 <ski> .. fwiw, data types like `Maybe' aren't polymorphic
08:13:13 <ski> (one can say they are parametric. parametric types enable polymorphic operations)
08:18:34 <srhb> How does nix-store -qd work? Where does the information of the derivation for a given out path come from?
08:18:42 <srhb> Er... Wrong channel.
08:57:53 <mbwgh> Is there an idiomatic way to use conduits with lens, instead of mono-traversable?
09:20:03 <dexterfoo> @botsnack
09:20:03 <lambdabot> :)
09:24:14 <yohotchoc> @botsnack
09:24:14 <lambdabot> :)
09:24:19 <yohotchoc> not like the gremlins then
09:25:05 <ski> @protontorpedo
09:25:05 <lambdabot> please expalin pure and lazy a little (im igonorant i know)?
09:25:34 <yohotchoc> wut
09:25:59 <ski> @keal
09:25:59 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
09:26:07 <yohotchoc> @ski
09:26:07 <lambdabot> Maybe you meant: wiki src ask
09:26:22 <yohotchoc> I see you haven't said anything sufficiently controversial :D
09:26:34 <ski> @quote ski
09:26:34 <lambdabot> ski says: <ski> classicallity is a bit like side-effects .. it sometimes makes things more concise .. but it is  also dangerous
09:26:43 <mniip> @quote mniip
09:26:43 <lambdabot> mniip says: <mniip> I am an idiot
09:26:47 <mniip> :(
09:26:50 <yohotchoc> :D
09:26:54 <sonOfRa> @quote sonOfRa
09:26:54 <lambdabot> No quotes match. Wrong!  You cheating scum!
09:26:56 <sonOfRa> hah
09:26:57 <hpc> @quote hpc
09:26:57 <lambdabot> hpc says: and when you want to get really ridiculous, agda has universe polymorphism, which is when you don't know how high up the tower of turtles you have managed to climb
09:26:59 <sonOfRa> I don't exist!
09:27:28 <ski> @remember sonOfRa <sonOfRa> I don't exist!
09:27:28 <lambdabot> Good to know.
09:27:36 <sonOfRa> of course.
09:27:38 <ski> @quote
09:27:38 <lambdabot> bluetaslem says: (on #haskell) A multiple headed monster, that shares thoughts..
09:27:41 <mniip> I remember someone failed at quoting me once
09:27:46 <sonOfRa> Should have seen that coming from a mile away
09:28:27 <hpc> @remember mniip I remember someone failed at quoting me once
09:28:27 <lambdabot> It is forever etched in my memory.
09:28:34 <mniip> @quote <
09:28:34 <lambdabot> < says: mniip> who hasn't implemented a haskell compiler in lisp, and a lisp compiler in haskell is not a real programmer
09:28:39 <mniip> there it is
09:28:46 <mniip> ski, do you think you can fix that?
09:28:53 <mniip> er
09:29:00 <ski> @forget < mniip> who hasn't implemented a haskell compiler in lisp, and a lisp compiler in haskell is not a real programmer
09:29:00 <lambdabot> Done.
09:29:04 <mniip> I somehow confused ski and int-e for a sec
09:29:09 <mniip> :s
09:29:09 <ski> @remember mniip <mniip> who hasn't implemented a haskell compiler in lisp, and a lisp compiler in haskell is not a real programmer
09:29:09 <lambdabot> Done.
09:29:21 <mniip> well
09:29:23 <mniip> that works!
09:30:26 * ski . o O ( skint-e )
09:30:55 <ski> @quote stark
09:30:55 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
09:30:59 <yohotchoc> @remember ski <ski> I never said this!
09:30:59 <lambdabot> Okay.
09:31:08 <yohotchoc> hm
09:31:47 <ski> @v
09:31:47 <lambdabot> Exception: <<loop>>
09:31:52 <ski> @v
09:31:52 <lambdabot> "\""
09:32:34 <ski> @help v
09:32:34 <lambdabot> let v = show v in v
09:33:46 <totom> Does anyone know about this book https://www.amazon.com/Introduction-Functional-Programming-using-Haskell/dp/0134843460
09:34:03 <yohotchoc> @v
09:34:03 <lambdabot> Just 'J'
09:34:11 <yohotchoc> :thinking:
09:34:59 <ski> totom : iirc, monochrom has read it ?
09:35:10 <dexterfoo> @quote lambdabot
09:35:10 <lambdabot> lambdabot says: I know nothing about wadler.
09:35:28 <ski> @quote wadler
09:35:28 <lambdabot> wadler says: Curried food and curried functions are both acquired tastes
09:35:34 <ski> liar !
09:35:52 <totom> monochrom: You there?
09:36:12 <totom> ski: Do you know if this book is beginner friendly?
09:36:47 <ski> i don't recall it much, only having browsed it briefly, years ago
09:37:13 <totom> ok
09:37:52 <ski> however, i think Bird is well-respected
09:38:35 <ski> (if i saw the book at an antiquarian bookshop or flea market, i'd probably buy it)
09:38:59 <totom> But i am not good in maths so i wanted to know if i can start learning from that book
09:39:41 <ski> i'm not sure to what extent it presupposes some formal reasoning maturity
09:40:14 <totom> ok
09:42:59 <ski> (by which i mostly mean things like : knowing how to use (mathematical) variables; how to substitute equals for equals; being able to solve simple equations (first and maybe second degree); and perhaps being able to make *simple* equational/equality reasoning (aka proofs))
09:44:51 <ski> (having seen "big sigma" summation notation, and maybe integrals can help a little, in that that can help with understanding the concept of a "bound variable". the actual remaining practice of computing integrals and sums aren't relevant)
09:45:34 <totom> ski: I have read haslf of Learn you a haskell for greater good and I was able to do it. I don't know if that can tell you that I will be able to tackle Bird's book
09:46:09 <ski> well, LYAH has been likened with a four-hour long trailer of Haskell
09:47:19 <ski> in that it doesn't give that much good explanation, nor exercises to practice with
09:48:01 <totom> Yes the exercises were lacking that was the main point which wanted me to get aother good book
09:48:22 <ski> @where CIS194
09:48:22 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
09:48:26 <ski> has exercises
09:48:41 <ski> nowadays, people often seem to recommend the book
09:48:42 <ski> @where HPFFP
09:48:43 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
09:48:47 * ski hasn't read it
09:49:14 * ski learned from "Haskell: The Craft of Functional Programming" by Simon Thompson
09:49:50 <ski> i've heard people like "The Haskell School of Expression"
09:51:52 <ski> s/like/expressing liking/
09:52:04 <totom> ty i will check it out
09:52:36 <ski> (btw, note that beginner questions are also welcome in this channel)
09:55:47 <totom> ski: Thank you so much for all the help
10:01:14 <monochrom> Oh hi
10:01:41 <ski> did i remember incorrectly ?
10:01:49 <monochrom> @quote monochrom Bird
10:01:49 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
10:01:49 <lambdabot> entire human race would have to be rewritten!
10:01:53 <monochrom> That one!
10:02:40 <ski> would you recommend, or suggest, it to totom ?
10:03:57 <monochrom> I don't know totom's inclination. Formalist -> Bird. Interactive -> Hudak.
10:04:38 <monochrom> I'm a formalist. I don't care that user interaction doesn't happen until chapter 20 or something.
10:04:48 <monochrom> But most people are the opposite.
10:05:13 <ski> perhaps "i am not good in maths" indicates they're that formalistically inclined (or perhaps they just don't know it yet)
10:05:21 <monochrom> Just two days ago we had someone whining about "why is simple [sic] input command so hard in Haskell"
10:05:45 <ski> er, s/that/not that/
10:07:33 <monochrom> I haven't looked at Hutton's, but it should be worth considering too.
10:07:52 <Gurkenglas> Hm? What's hard about input command? turn "main = " into "main = getArgs >>= " and your IO () is [String] -> IO ().
10:09:21 <phyro_> how can i do something like this: map (read . fst) [('3', '1'), ('4', '2')]
10:09:40 <ski> phyro_ : what is the desired result ?
10:10:01 <Gurkenglas> > map (read . fst) [("3", "1"), ("4", "2")] :: [Int]
10:10:02 <ski> i guess either `34' or `[3,4]' ?
10:10:03 <lambdabot>  [3,4]
10:10:08 <phyro_> i want to cast
10:10:16 <ski> no you don't
10:10:46 <phyro_> [3,4] would be the result
10:10:49 <Gurkenglas> There, you have to cast the Show a => [a] to [Int] or it'll default-cast it to [()]
10:10:51 <ski> presumably you want to parse, iow convert a string representation (numeric literals, aka numerals), to actual numbers
10:11:10 * ski calls that an ascription, not a cast
10:11:20 <Gurkenglas> A specialization! :D
10:11:43 <ski> > False :: Bool  -- a specialization ? :)
10:11:44 <Gurkenglas> Or in this special case, even a monomorphization
10:11:45 <lambdabot>  False
10:11:57 <Gurkenglas> No, False is already Bool, you didn't specialize it
10:12:06 <ski> phyro_ : where do you get these characters from ?
10:12:08 <Gurkenglas> Unless you want to distinguish proper specialization
10:12:20 <ski> right. so what to call it in this case ?
10:12:23 <phyro_> ah i see my problem, i'm dealing with Chars
10:12:27 <ski> (which was my point)
10:13:01 <ski> phyro_ : if you want to be able to handle parse failure gracefully, you don't want to use plain `read'. consider `reads' or `readMaybe'
10:13:21 <ski> also, there's
10:13:26 <ski> @type digitToInt
10:13:27 <lambdabot> Char -> Int
10:13:39 <ski> if you just want to convert single digits
10:14:07 <phyro_> thanks!
10:14:22 <ski> > digitToInt '-'
10:14:25 <lambdabot>  *Exception: Char.digitToInt: not a digit '-'
10:14:49 <totom> Sorry what does formalist means?
10:14:51 <totom> monochrom:
10:15:36 <totom> :( i missed monochrom
10:15:55 <yohotchoc> > digitToInt 'V'
10:15:57 <lambdabot>  *Exception: Char.digitToInt: not a digit 'V'
10:16:08 <yohotchoc> the romans disagree
10:17:06 <totom> ski: Can you help me with formalist meaning here
10:17:23 <ski> > map digitToInt (['0' .. '9'] ++ ['a' .. 'f'] ++ ['A' .. 'F'])
10:17:26 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,10,11,12,13,14,15]
10:18:18 <jle`> @let safeDigitToInt c = digitToInt c <$ guard (isDigit c)
10:18:20 <lambdabot>  Defined.
10:18:35 <ski> > map isDigit (['0' .. '9'] ++ ['a' .. 'f'] ++ ['A' .. 'F'])
10:18:37 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,False,False,False,False,F...
10:18:48 <fakenullie> eh
10:19:09 <jle`> > map (id &&& digitToInt) . filter isDigit $ ['\0'..]
10:19:12 <lambdabot>  [('0',0),('1',1),('2',2),('3',3),('4',4),('5',5),('6',6),('7',7),('8',8),('9...
10:19:30 <jle`> > filter isDigit ['\0'..]
10:19:33 <lambdabot>  "0123456789"
10:19:34 <yohotchoc> > safeDigitToInt 'V'
10:19:36 <lambdabot>  error:
10:19:37 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M788755561280...
10:19:37 <lambdabot>        prevents the constraint ‘(Show (f0 Int))’ from being solved.
10:19:51 <yohotchoc> :t safeDigitToInt
10:19:52 <lambdabot> Alternative f => Char -> f Int
10:20:02 <jle`> hm i always thought isDigit counted the hex digits too
10:20:11 <ski> apparently not
10:20:20 <jle`> i guess that's why we have 'isHexDigit'
10:20:30 <jle`> > filter isHexDigit ['\0'..]
10:20:33 <lambdabot>  "0123456789ABCDEFabcdef"
10:20:35 <ski> > filter isDigit ['\0' ..]
10:20:38 <lambdabot>  "0123456789"
10:22:05 <ski>   formal  adj  3. Relating to the form or structure of something.; "Formal linguistics ignores the vocabulary of languages and focuses solely on their grammar."
10:22:05 <um1b0zu> is there a way in ghci to see the module the module a function comes from?
10:22:11 <ski> totom ^
10:22:31 <ski> um1b0zu : try `:info' (`:i' for short) ?
10:24:34 <um1b0zu> perfect thanks!
10:25:39 <ski> totom : formalism in concerned with the form/structure. it tends to be strict with appropriate/proper form of expression, and to want to express (previously) implicit assumptions and presuppositions *explicitly* (iow making them apparent/plain in the *form*)
10:27:37 <ski> totom : it also tends to stress clear definitions and reasoning, over (feelings and) elucidating examples, analogies, and intuition
10:28:01 <totom> so dealing with pure language structure, and not concerned about developing real world programs
10:28:12 <ski> (the latter can be considered to be important as well, but wouldn't usually be considered related to formalism)
10:29:13 <totom> sorry if i misunderstood, english is not my native language
10:31:50 <ski> i suppose you could say formalism is more about the foundations, about not having inconsistencies and misunderstandings in your conceptual models, which might hamper your practice of building and managing programs, than about the practical (and relating to economy, psychology, sociology, &c.) aspects of programming
10:31:50 <monochrom> Gurkenglas: People from other languages, even *ML and F#, would expect "main = putStrLn ("hello " ++ getLine)" to be the simple way.
10:32:29 <Gurkenglas> Ah yes I wonder why we can't have Idris notation like that.
10:32:48 * ski . o O ( reflective syntax )
10:32:59 <totom> ski: Yes then I am a formalist.
10:33:23 <totom> I really don't care about practical approaches with haskell. I just want to be a good haskell programmer
10:34:10 <monochrom> I am a formalist but I am not in it for foundation. I am in it because symbol game is more reliable and has more predictive power than word game (what most people do).
10:34:26 <Gurkenglas> Perhaps using it in a term of type m (n ()) would be confusing?
10:35:12 <ski> totom : formalism also tends to be preoccupied with syntax, notation, way of expression, which could be contrasted to a more "language-less" (if possible) understanding of concepts
10:35:25 <totom> Well i am for foundation
10:36:18 <totom> ski: Then i guess I'll go with Bird's Introduction to functional programming
10:37:06 <monochrom> In that case I'm wondering if his new one, Thinking Functionally, is even better for you.
10:37:17 <monochrom> But I haven't looked at it.
10:37:52 <ski>   ⌜putStrLn ("hello " ++ ⌞getLine⌟)⌝  -- how i'd write it
10:37:54 <totom> monochrom: I'll take a look at it too. Thank you for the suggestion
10:38:01 <ski> Gurkenglas ^
10:38:16 <monochrom> \∩/ choice paralysis
10:39:53 <monochrom> Anyway, word game is when people mistake the empty list for the empty set because "they are both empty".
10:41:14 <monochrom> And when people look at a type like "(X -> Y) -> F X -> F Y" and think like "OK I pass a function to this function to get a function. Wait, what?"
10:41:24 * ski . o O ( "I am not a lawlike function, I am a free choice sequence." )
10:42:11 <monochrom> A formalist, on the other hand, will work with the list axioms and set axioms and easily find out that the empty list is not the empty set.
10:42:37 <monochrom> And will do unification on the types and be able to use fmap's type effectively.
10:43:28 * ski . o O ( Peter Woit )
10:43:56 <totom> you people are so knowledgeable. I'll become like you guys someday
10:44:27 <ski>   D(D f)(x)  -- The value of the second derivative of the function `f', in the point `x' .. Ok, I pass a function (`f') to my function (`D'), and get a function (which is then passed again to `D', and the resulting function is then passed `x')
10:48:40 <ongy> What's the best way to implement callbacks I can attach to/detach from (in IO)? IORef [a -> IO ()] ?
10:49:36 <monochrom> Like that. But IORef (Map Key (X -> IO ())) so you can actually find and delete.
10:49:56 <ongy> I guess at least [(Int, a -> IO ()))] or I won't be able to detach in any decent way
10:49:59 <monochrom> And a capital letter X because clearly you are not being polymorphic.
10:50:19 <ski> (perhaps they're being parametric, though)
10:50:25 <ongy> I will probably need more than one version, but in any given instance it won't be polymorphic
10:51:02 <monochrom> But don't use a list.
10:51:40 <ongy> Map makes more sense
10:52:46 <monochrom> Once upon a time someone came along and looked at our Data.List and asked "why don't you guys have more utitlity functions for associative lists like Lisp does?" (Or was it SML?)
10:52:54 <monochrom> Answer: because we use Data.Map
10:54:14 <fakenullie> what functions
10:54:46 <fakenullie> all I know from lisp is cons and nil
10:54:55 <monochrom> There are also IntMap and HashMap if you think that binary search tree is too slow.
10:55:37 <glguy_> I think those are too fast, mistakes are sure to happen at those speeds
10:55:55 <fakenullie> monochrom: lisp constructs tree from lists?
10:56:52 <fakenullie> for associative lists there is lookup
10:57:47 <monochrom> fakenullie, I think you need to re-read what I said.
10:58:01 <fakenullie> oh, ok
10:58:22 <monochrom> Also it is none of my business but you sound like you just woke up from a hangover.
10:58:47 * shapr sews cheerfulness
10:59:10 <fakenullie> It's my permanent condition
10:59:27 <ongy> ye, using IntMap, I have some fun with abusing Ints either way in this project
11:00:31 <monochrom> I'm still wondering whether there is any difference at all between IntMap and HashMap Int.
11:01:16 <monochrom> Their docs' wording of what approach they use are, well, they're worded differently but you never know whether they mean the same thing.
11:01:28 <shiona> glguy_: how did you handle part 2 day 23?
11:01:35 <ski> @quote superheroes
11:01:35 <lambdabot> bos says: we need monad superheroes.  State s a helps little old programmer ladies cross the functional street!  List can't decide what she wants to do, so she does everything!  Identity has the
11:01:35 <lambdabot> power of disguise!  Cont can travel through time!
11:02:18 <monochrom> Cont can travel through space too.
11:02:25 <fakenullie> every module has a paper
11:02:25 <shiona> Because I ended up translating the assembly to higher level assembly, to C, compiling to make sure it worked, then optimizing and thinking I found out what the code does.
11:09:17 <reygoch> hey, does anyone know any library that can convert html to text?
11:09:37 <reygoch> like you can do when you copy from web page into a text editor
11:09:55 <reygoch> I just need the text and newlines preserved
11:11:09 <hpc> pandoc?
11:11:26 <reygoch> hmm... pandoc is a bit too much
11:12:44 <hpc> ah, tagsoup
11:12:49 <hpc> it's what pandoc uses internally
11:13:22 <reygoch> aha, will check it out
11:13:25 <reygoch> thanks
11:13:35 <hpc> you'll have to write your own traversal of the parsed stuff, but shouldn't be too hard
11:14:45 <reygoch> I kind of want to avoid any traversals, I just want to feed it html and let it convert it to text for me. If I have to add newlines on every div, br etc... than it's not really what I'm looking for
11:15:06 <reygoch> If I understand you correctly
11:15:14 <hpc> hmm
11:15:15 <glguy_> shiona: translated to C by hand,  transformed it by hand until it made sense and then wrote a haskell one liner to compute the solution. Modified the translated c to run in smaller values to check my understanding along the way
11:15:34 <Gurkenglas> Doesn't look like you'd have to write your own traversals https://github.com/alpmestan/tagsoup-lens/blob/master/src/Text/HTML/TagSoup/Lens.hs
11:16:31 <hpc> yeah, not sure what would do what you need then, without being explicitly a full document converter
11:17:15 <reygoch> same effect you get by selecting text from website and pasting it in plain text editor
11:17:20 <reygoch> that is what I need
11:18:12 <reygoch> I was about to experiment a little but I was hoping someone can recommend me something that is known to work that way out of the box
11:19:08 <shiona> glguy_: ok, so pretty much the same, with the difference that I guess I haven't completely understood the C-translation since I can't seem to translate it into haskell that produces correct answer
11:20:08 <jle`> my c trainslation ended up being three nested for loops
11:20:31 <jle`> if you can get it to that form, the 'efficient haskell' is probably clear
11:22:27 <shiona> I've optimized the C further
11:26:44 <jle`> what does it look like?
11:27:53 <shiona> jle`: the innermost for loop is dropped and replaced by a `mod` (or well, %, as it's C)
11:29:07 <jle`> paste it, we  might be able to provide some hints :)
11:40:21 <shiona> I guess it was just a off-by-one caused by little less used loop construct
11:43:03 <Athas> Hi.  How come when I do 'stack build -j 4', it still only computes one module at a time?
11:43:16 <Athas> Isn't -j supposed to compile in parallel?
11:44:46 <fakenullie> maybe they depend on each other
11:45:17 <Athas> They do not.
11:45:49 * hackage haskell-updater 1.3.1 - Rebuild Haskell dependencies in Gentoo  https://hackage.haskell.org/package/haskell-updater-1.3.1 (SergeiTrofimovich)
11:50:26 <tinytusk> Hi. If a customer asked me to write a library for them and I wanted to deliver a closed-source binary, should I deliver a shared object or an archive, and how would they integrate it in to their build process?
11:51:56 <Tuplanolla> Friends don't help friends develop proprietary software.
11:52:31 <fakenullie> do even licenses for modules allow this
11:52:37 <fakenullie> for libraries
11:53:23 <hpc> iirc, you can't static-link to gpl code but you can dynamic-link to it
11:53:29 <hpc> and you can static-link BSD code
11:53:36 <fakenullie> only LGPL
11:53:49 <hpc> ah
11:54:11 <hpc> so regular gpl is contagious across .so boundaries?
11:55:01 <fakenullie> I think so
11:55:24 <monochrom> tinytusk: By default GHC produces exes that are statically linked for Haskell libraries and still dynamically linked for libc etc. so usually you can just send the exe and it's done.
11:55:45 <tinytusk> They asked for a library, not an executable.
11:56:07 <monochrom> Oh, then that's tougher.
11:56:33 <monochrom> Then basically you have to ship all of GHC.
11:57:18 <monochrom> It can be just most of GHC but the small "saving" is not worth your effort identifying the very few files you can skip.
11:57:19 <fakenullie> make it into executable with some form ipc
11:57:33 <tinytusk> Presumably they already have GHC installed and are using it (in conjunction with my library) to build some executable.
11:57:47 <monochrom> Oh then just ship your library files
11:58:29 <monochrom> But make sure their GHC matches up with yours, not just version, but even down to --prefix
11:58:36 <hpc> looks like gpl spreads to "derivative works", which are defined in the US as
11:58:38 <hpc> A work consisting of editorial revisions, annotations, elaborations, or other modifications which, as a whole, represent an original work of authorship, is a “derivative work”.
11:58:38 <monochrom> Because those things are hardcoded.
11:58:57 <Athas> tinytusk: note that, by default, GHC uses the GMP library for the Integer type, and GMP is licensed under the LGPL.
11:58:57 <tinytusk> monochrom: Ok, but how would the customer integrate that binrary in to their build process?
11:59:19 <tinytusk> Athas: Not a problem, I can switch to integer-simple.
11:59:22 <hpc> it's pretty easy to argue that a thing that's different in purpose but happens to link to gpl code doesn't count
11:59:25 <hpc> imo
11:59:30 <monochrom> Like they use any other Haskell libs I guess?
11:59:50 <tinytusk> monochrom: Any other haskell library they’re going to get from git or stackage.
11:59:55 <tinytusk> hackage
12:00:00 <monochrom> Because basically every Linux distro does what you're doing already.
12:00:06 <hpc> so as long as you aren't doing something like dynamically linking to gdb in order to make a runtime debugger, you're good
12:01:41 <tinytusk> monochrom: Every other library they use they have the source code for. So I’m not sure how I would tell cabal “I don’t have the source but I have libFoo.a so you should just use that instead."
12:01:52 <monochrom> For example if you do an "apt install libghc-aeson" for example, it's a binary-only pack of files, and since all the assumptions of "user's GHC is a duplicate of builder's GHC" it just works. And then afterward you do whatever workflow you like.
12:04:05 <monochrom> cabal doesn't always demand source code.
12:05:06 <phadej> in Cabal-2.0 you can produce foreign-library's if you want ot write lib in haskell to be consumed in C code. http://cabal.readthedocs.io/en/latest/developing-packages.html#foreign-libraries
12:05:33 <monochrom> With "depends: ..., xxx, ...", if xxx is already "installed" then it will be used, no source code.
12:05:57 <monochrom> In fact from this perspective, when cabal downloads source code, it is doing an XY problem.
12:06:01 <phadej> distributing "binary-only" ordinary Haskell libs is OTOH bad idea. For example the .hi files can, and probably will contain a lot of source code, in more or less readable way
12:06:09 <phadej> try to -ddump-iface  on ghc
12:07:02 <monochrom> Hell, base's source code has never appeared on your system, and your "depends: base" has always worked, no?
12:07:35 <phadej> monochrom: there's a lot of unfoldings in .hi -files of base though
12:07:45 <monochrom> Yes yes I'm not denying that.
12:08:44 <phadej> I mean, if the idea is to use binary-only distribution to obfuscate the original code, it won't work that well
12:09:12 <monochrom> I think I need all of you to redraw the boundary so that *.hi count as binary files. Because they're needed when you compile code that uses that library.
12:09:34 <monochrom> Err, more precisely: when you compile code that imports such a module.
12:10:20 <monochrom> To a large extent our *.hi files are like most C++ compiler's "pre-compiled header" files.
12:10:41 <phadej> not really, you cannot use the lib without them
12:11:03 <phadej> but without pch:s, you can use c++ lib
12:11:11 <monochrom> Oh, but in the case of C++ libs, you need either text-mode *.h files or pre-compiled header files, too.
12:11:34 <monochrom> The reason they don't ship pch is because they ship *.h
12:11:50 <monochrom> which means they are a little bit closer to "ship with source".
12:13:06 <monochrom> I really thought it through before I drew that analogy.
12:14:04 <phadej> I guess pch:s are also very fragile, i.e. you must have quite the same environment
12:16:03 <wdanilo> hi guys! I only want to ask if anyone from you is working on any port of GHC to target WebAssembly? I was searching the web and have read all the threads, but I dont think ive found anything actual regarding this topic
12:16:23 <unclechu> hey guys, i'm trying to build c-compatible shared library written in haskell, but i want to statically link all haskell dependencies
12:16:44 <unclechu> when i try to link i get a lot of errors like: `requires unsupported dynamic reloc 11; recompile with -fPIC`
12:17:19 <unclechu> i'm trying to link by running ghc with `--make -static -shared -fPIC`
12:17:45 <unclechu> how could I recompile all dependecies with `-fPIC`?
12:18:25 <yohotchoc> are you on arch?
12:20:09 <monochrom> unclechu: GHC on Linux will simply not do it. GHC on Windows will do it.
12:20:42 <unclechu> yohotchoc: x86_64
12:20:50 <yohotchoc> arch linux
12:20:57 <unclechu> monochrom: do you mean it's impossible to do it in linux?
12:20:59 <monochrom> Unless, I guess, you build GHC yourself and turn on the right option at that time.
12:21:09 <yohotchoc> not what arch
12:21:14 <monochrom> OK look, you have to dig deeper.
12:21:15 <unclechu> yohotchoc: oh, sry, no, i'm on fedora
12:21:39 <monochrom> You will link against some libs that come with GHC and are on heavy lock-down, such as base, right?
12:22:09 <unclechu> yes, that's correct
12:22:28 <monochrom> Well normally base is built when GHC-for-linux is built, and at that time it did not have -fPIC.
12:22:59 <unclechu> monochrom: so, i could do it if i build ghc by myself?
12:23:01 <monochrom> And my "heavy lock-down" means you can't just say "let me build my own copy of base but keep GHC unchanged".
12:23:11 <monochrom> Yes, in principle. I haven't tried.
12:24:00 <unclechu> i'll probably should make a docker container for that if i get some success in it
12:27:36 <dminuoso> The wiki article about existentially qualified types suggests something like this to exist
12:27:42 <dminuoso> > a :: [∀a. a]
12:27:44 <lambdabot>  error:
12:27:44 <lambdabot>      • Illegal polymorphic type: forall a. a
12:27:44 <lambdabot>        GHC doesn't yet support impredicative polymorphism
12:27:59 <dminuoso> Am I missing something?
12:28:31 <jle`> dminuoso: it exists informally but it is not allowed in current ghc
12:28:50 <jle`> [forall a. a] is a list whose items, if any, must be bottom
12:28:56 <jle`> it's not expressible in ghc haskell
12:29:24 <jle`> dminuoso: the closest you can get is with a newtype wrapper
12:29:42 <jle`> @let newtype ForallAA = ForallAA (forall a. a)
12:29:44 <lambdabot>  Defined.
12:29:50 <jle`> :t [ForallAA]
12:29:52 <lambdabot> error:
12:29:52 <lambdabot>     • Couldn't match expected type ‘a’
12:29:52 <lambdabot>                   with actual type ‘(forall a1. a1) -> ForallAA’
12:29:54 <monochrom> I think that that wiki article is pretty unclear what's conceptual model what's real code.
12:30:23 <jle`> dminuoso: in any case, (forall a. a) is isomorphic ot Void, so you could always just do [Void]
12:30:58 <ski> > [] :: [ForallAA]
12:31:01 <lambdabot>  error:
12:31:01 <lambdabot>      • No instance for (Show ForallAA)
12:31:01 <lambdabot>          arising from a use of ‘show_M913977722812347835430405’
12:31:24 <ski> @type [] :: [ForallAA]
12:31:25 <lambdabot> [ForallAA]
12:31:45 <jle`> dminuoso: but yeah, ghc can't handle universally quantified types inside type constructors (besides (->))
12:31:50 <monochrom> And I wonder if you mean [∃a. a]
12:32:43 <ski> a value of type `[forall a. a]' is a list whose elements have type `a', for every type `a'
12:32:46 <hoon> I'm curious if there might be a "better" way to do this: https://hastebin.com/kihawojuhe
12:32:56 <ski> a value of type `[exists a. a]' is a list whose elements have type `a', for some type `a'
12:33:14 <ski> (possibly a different type for each element)
12:33:53 <EvanR> in what language does [forall a . a] make sense
12:34:35 <dminuoso> monochrom: Im actually just trying to make sense of that particular paragraph. Since it looked like real code, I just figured "put it into GHCi and see what I can do with it"
12:34:37 <EvanR> translating the symbols directly into english doesnt produce a statement that makes sense to me
12:34:42 <pja> Is it common knowledge that put in the State Monad needs to be strict (ie paired with $!) in order to avoid space leaks?
12:34:44 <ski> EvanR : System F ?
12:35:06 <ski> dminuoso : which wiki article ?
12:35:11 <EvanR> how can a value be of every type
12:35:19 <ski> @type undefined
12:35:20 <lambdabot> a
12:35:24 <ski> @type error "foo !"
12:35:26 <lambdabot> a
12:35:27 <dminuoso> ski: https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
12:35:37 <EvanR> is there any other?
12:35:54 <ski> EvanR : if you only consider total values, then the only value of type `[forall a. a]' is the empty list `[]'
12:36:01 <dminuoso> EvanR: Well, the key that Im trying to understand is how [forall a. Show a => a] would still only contain bottom
12:36:06 <ski> @type fix id
12:36:07 <lambdabot> a
12:36:22 <EvanR> so basically, an element of that list wouldnt make sense
12:36:27 <EvanR> let x = x in x
12:36:38 <metahumor> hey yall, just wanted to share my soln for Dec23 that abuses lenses: http://lpaste.net/361061
12:36:41 <ski> dminuoso : can you define a `foo :: forall a. Show a => a', that you could put as an element in such a list ?
12:37:08 <dminuoso> ski: Oh! it would have to be a value that is inhabited by every type that has an instance of Show?
12:37:13 <ski> EvanR : right, `forall a. a' is iso to `Void'
12:37:24 <ski> dminuoso : correct
12:37:43 <dminuoso> ski: Ah great thanks. So bottom again. I see what the article is getting at. :)
12:37:45 <ski> dminuoso : this is very different from `[exists a. Show a *> a]' (note the `*>', rather than `=>')
12:38:09 <EvanR> i dont know system F, is this really allowed?
12:38:24 <EvanR> [exists a . a] [forall a . a]
12:38:33 <dminuoso> ski: What does *> denote?
12:39:13 <jle`> dminuoso: try writing a single value of type forall a. Show a => a
12:39:26 <jle`> and you'll that the only values you can write are bottom
12:39:47 <ski> dminuoso : value coupled with constraint evidence, as opposed to value requiring constraint evidence
12:39:56 <pja> :t (*>)
12:39:57 <lambdabot> Applicative f => f a -> f b -> f b
12:40:04 <ski> nah, not that one
12:40:16 <ski> dminuoso : a value of type `Cxt => T' will, if the *user/consumer* of it provides evidence for `Cxt', give you access to a value of type `T'
12:40:19 <EvanR> does putting a show constraint there help you in any way to get an a
12:40:34 <EvanR> seems useless
12:40:46 <ski> dminuoso : a value of type `Cxt *> T' will *itself* provide evidence of `Cxt', together with a value of type `T'
12:41:43 <ski> with `Cxt => T', the user/consumer has to provide the evidence for `Cxt'. with `Cxt *> T', the implementor/producer has to provide evidence for `Cxt'
12:41:53 <ski> `=>' is usually coupled with `forall'
12:41:59 <ski> `*>' is usually coupled with `exists'
12:42:15 <ski> `=>' is to `->' as `*>' is to `(,)'
12:43:02 <ski> a value of type `Cxt => T' can, conceptually, be thought as a sort of "function", that if you (implicitly in Haskell) give it evidence for `Cxt', will give back a value of type `T'
12:43:31 <ski> a value of type `Cxt *> T' can, conceptually, be thought as a sort of "pair", that both contains (implicitly in Haskell) evidence for `Cxt', as well as (explicitly) a value of type `T'
12:44:16 <ski> however, `exists a. Show a *> a' isn't that useful. roughly, it amounts to a `String'
12:45:08 <ski> because if you get a value of type `exists a. Show a *> a', what you get is a value of an *unknown/opaque/abstract/forgotten/skolem* type `a', together with evidence that this (unknown) type is an instance of `Show'
12:45:33 <EvanR> *> is like dependent pair
12:45:36 <ski> so, you know that you can apply `show' (and also `shows', and `showsPrec', but let's ignore those for simplicity) to it, but that's it
12:45:56 <ertes> (to be fair it amounts more to something like Int -> ShowS)
12:45:58 <dminuoso> ski: So iow the mere presence of some `C a *> a` means that the the type itself fulfills the constraint?
12:46:08 <dminuoso> Or can be seen as "evidence of C" ?
12:46:17 <ski> so, you might as well be given a `String' directly, since (ignoring those other methods of `Show'), the only thing you can do with the value is pass it to `show', which gives you a `String'
12:46:53 <ski> (ertes is outlining more precisely what we say if we don't ignore those other methods)
12:47:03 <ski> dminuoso : yes
12:47:21 <EvanR> it helps modularity if you dont have to go so far to "do the work yourself" and prove a String
12:47:26 <EvanR> provide*
12:47:42 <ski> dminuoso : if you have a value of type `exists a. Eq a => [a]', then you have a list of values, all of the same (unknown/forgotten) type `a', but you know that you can compare the elements in the list for equality
12:47:58 <ski> er, sorry, that should be `exists a. Eq a *> [a]'
12:48:20 <monochrom> @quote monochrom river
12:48:20 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they
12:48:20 <lambdabot> must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How many trips do you need? Solution: one trip, [
12:48:20 <lambdabot> show the_boolean, show the_character, show the_integer]
12:48:21 <EvanR> and sometimes its impossible
12:48:39 <ski> dminuoso : while, if you had `[exists a. Eq a *> a]', then you have no guarantee that the elements in the list have the *same* (unknown/forgotten) type `a', and so you can't compare those elements for equality
12:49:19 <dminuoso> ski: This symbol `*>`, where is this from? Some Haskell extension? Type theory?
12:49:40 <ski> it's just a symbol i made up, to be able to talk about this, at a more conceptual level
12:50:14 <ski> to actually encode it in Haskell, you have to be a bit more roundabout (actually, there's two encodings, suitable in different cases)
12:50:15 <monochrom> But there is a long reason behind choosing to call it *> rather than some other symbol.
12:50:25 <ski> (similarly, there's two encodings of `exists')
12:50:36 <monochrom> And it is not just ski. A few others of us like it too.
12:50:42 * ski nods
12:50:49 <monochrom> Even independently chose this symbol.
12:51:02 <ertes> the idea behind the (*>) symbol is to confuse people familiar with the (*>) function
12:51:05 <monochrom> An indication that the long reason is actually pretty robust.
12:51:14 <monochrom> Oh no, hahaha
12:51:18 <dminuoso> ertes: Judging from the previous evidence, I'd say that goal was successful.
12:51:52 <ski> dminuoso : recall how jle` had to define `ForallAA', to actually encode `[forall a. a]' in current Haskell ? but when thinking conceptually, we prefer thinking in terms of `[forall a. a]' rather than the more roundabout encoding
12:51:59 <dminuoso> ski: But still, Im not exactly sure what domain we are in right now. Are we strictly talking about type theory now?
12:52:04 <ski> dminuoso : the same holds for `exists' (and `*>')
12:52:10 <dminuoso> Or about Haskell?
12:52:22 * hackage bittrex 0.1.0.0 - API bindings to bittrex.com  https://hackage.haskell.org/package/bittrex-0.1.0.0 (DavidJohnson)
12:52:40 <ertes> dminuoso: in type theory (*>) amounts to the constructor of a dependent sum type
12:52:43 <ski> hm, i think the `(*>)' function wasn't defined at the time ?
12:52:46 * ski isn't sure
12:53:23 <ertes> well, not quite, no
12:53:24 <ski> dminuoso : some kind of type theory that's rather close to Haskell
12:53:25 <EvanR> dependent pair or sigma
12:53:35 <ski> (e.g. you can look up System F)
12:53:46 <ertes> even in type theory (*>) is basically syntactic sugar
12:53:51 <ertes> for a lambda
12:54:07 * EvanR acuses ertes of reductionism
12:54:35 * ski accuses EvanR of evaluationism
12:54:49 <monochrom> The opposite of redex is spandex. :)
12:55:26 <EvanR> evaluation does tend to expand things
12:55:53 <EvanR> where did the word reduction come from
12:56:00 <EvanR> wrt evaluation
12:56:14 <Xal> from the latin 'reductio'
12:56:25 <dminuoso> Maybe it's time I should ask this question. Im beginning to gain a fragmented view of Haskell, category theory, first order logic - but unlike some of you I don't have a mathematics heavy background.
12:56:44 <dminuoso> If I wanted to study this more narrowly, is this doable with books on my own?
12:56:46 <monochrom> Reduction does not decrease size. That's not what it goes for.
12:57:21 <EvanR> then what is being reduced, i remember reading in a book somewhere observing something but forgot
12:57:43 <monochrom> Going lower level and/or peeling off abstraction layers
12:58:00 <EvanR> hmm
12:58:16 <monochrom> For example reductionism: Speaking of quarks is lower level than speaking of temperature.
12:59:12 <monochrom> For example beta reduction: "(\x -> x whee) y" is more abstract than "y whee" because the lambda is an abstraction.
13:00:17 <jle`> dminuoso: what do you mean by 'this'?
13:00:20 <jle`> haskell?
13:00:35 <ertes> reduce tonight! trim the size of types! baby, factor it right! we will reduce tonight!
13:01:14 <Xal> (\x -> x x) (\x -> x x) doesn't become smaller when you reduce it
13:01:28 <ski> dminuoso : btw, note that `T -> (forall a. F a)' amounts to the same thing as `forall a. (T -> F a)'. and `T -> (Cxt => U)' amounts to the same thing as `Cxt => (T -> U)'. combined, `T -> (forall a. C a => F a)' amounts to the same thing as `forall a. C a => (T -> F a)' -- in some abstract sense, one can think of all these as "changing argument order"
13:02:51 <ski> dminuoso : also, note that `(exists a. F a) -> T' amounts to the same thing as `forall a. (F a -> T)'. and `(Cxt *> T) -> U' amounts to the same thing as `Cxt => (T -> U)'. combined, `(exists a. C a *> F a) -> T' amounts to the same thing as `forall a. C a => (F a -> T)' -- in some abstract sense, one can think of all these as "currying"
13:03:05 <EvanR> lambdas are also called abstractions, ok. but which sense of abstraction is this, or is it just a word
13:03:44 <hoon> I'll ask a possibly more pointed question than dminuoso; any recommendations in books or online resources for studying category theory from the ground up
13:03:46 <hoon> ?
13:03:55 <monochrom> Abstraction from 1+1, 2+2, 3+3, 4+4... to (\x -> x+x)
13:04:38 <EvanR> an abbreviation? a distillation of a pattern
13:05:42 <huss`> hey guys I would like to compose differents functions a -> a and then applying it to my initial object
13:05:46 <EvanR> the common skeleton of many different things
13:05:48 <jle`> hoon: how about "category theory for programmers"?
13:06:04 <ertes> Xal: that…  doesn't really become anything in type theory =)
13:06:13 <monochrom> Abstraction from 100 letters of "we regret to tell you that our job opening has been filled" that only differ by candidate names to one Word template that takes a candidate parameter
13:06:18 <ski> hoon : "Conceptual Mathematics" by William Lawvere,Steve Schanuel might be interesting. it's pretty slow going, doesn't assume much mathematical knowledge in various math fields, like many other books do
13:06:19 <huss`> if haskell procuding thunks for functions ?
13:06:30 <jle`> huss`: can you give us an example of functions and initial values
13:06:30 <ertes> unless…
13:06:42 <hoon> thank you for both suggestions
13:06:43 <jle`> huss`: it's not exactly clear what you mean
13:07:01 <EvanR> your examples are all about templates
13:07:03 <huss`> f x = x + 1, g x = x * 2, g . g . g . f $ x
13:07:04 <ski> @type foldr (.) id  -- huss`
13:07:05 <lambdabot> Foldable t => t (b -> b) -> b -> b
13:07:11 <ertes> … let this spoof get you to prove, it's alright, alright…  aaaaalright!  let this proof be fast and loose, it's alright, …
13:07:13 <huss`> ski: will that be efficient ?
13:07:23 <jle`> foldr (.) id [g,g,g,f] x
13:07:23 <hoon> I see these big conversations going on about category theory, and it's interesting, if not very disorienting
13:07:30 <monochrom> lambdas are functions are templates.
13:07:44 <huss`> ski: the resulting function will be a big thunk if i compose my function 1000 times ?
13:07:49 <EvanR> so who let the word abstraction in
13:07:53 <ski> > foldr (.) id [h,g,f] x
13:07:54 <jle`> huss`: `foldr (.) id [f,g,h] x`  just expands to f (g (h (id x)))
13:07:56 <lambdabot>  h (g (f x))
13:07:56 <ski> > foldr ($) x [h,g,f]
13:07:59 <lambdabot>  h (g (f x))
13:08:06 <ski> > (h . g . f) x
13:08:08 <lambdabot>  error:
13:08:08 <lambdabot>      • Could not deduce (Show b0) arising from a use of ‘h’
13:08:08 <lambdabot>        from the context: FromExpr c
13:08:24 <jle`> huss`: 1000 is a very small number
13:08:32 <huss`> okay thanks
13:08:46 <huss`> there is any benefit in doing that ?
13:08:51 <jle`> doing what?
13:09:11 <ski> > ((h :: Expr -> Expr) . (g :: Expr -> Expr) . f) x  -- there
13:09:11 * EvanR goes into an etymological safari
13:09:12 <dminuoso> jle`: Mm. Type theory and category theory.
13:09:13 <lambdabot>  h (g (f x))
13:09:14 <huss`> composing the functions and then applying the composed one to my initial object
13:09:20 <jle`> i mean
13:09:21 <huss`> vs applying step by stephe
13:09:24 <jle`> the benefit is that you get the answer you want?
13:09:24 <huss`> step
13:09:33 <jle`> ah
13:09:39 <jle`> what do you mean by 'step by step'
13:09:46 <jle`> isn't that what function composition is ...?
13:10:01 <jle`> f (g (h x)) is applying h, then g, then
13:10:05 <jle`> *f
13:10:17 <huss`> yes
13:10:18 <jle`> so the composition of functions is the same as applying them one after the other
13:10:32 <jle`> so that's like asking "is there any benefit of X, vs. (the same thing as X)?"
13:10:37 <ski> dminuoso : an example of the former is that `take :: forall a. (Int -> [a] -> [a])' amounts to the same as `take :: Int -> (forall a. [a] -> [a])'
13:10:46 <huss`> yes but its differents to keep the full transformation vs keeping the transformed object
13:10:47 <jle`> "is there any benefit to driving to my destination, as opposed to driving to my destination?"
13:11:01 <jle`> huss`: i'm not sure what difference you are talking about
13:11:04 <jle`> can you illustrate with code?
13:11:08 <ski> dminuoso : an example of the latter is that `length :: forall a. ([a] -> Int)' amounts to the same as `length :: (exists a. [a]) -> Int'
13:11:20 <huss`> okay one sec
13:12:07 <ertes> huss`: there are two aspects to this:  firstly function composition is associative, so it's basically a "list of steps" that you can easily edit; secondly category theory views functions as mathematical objects in their own right with a compositional language to combine them
13:14:12 <ski> dminuoso : does those two examples make any sense to you ?
13:15:49 <jle`> so there's this gist going around on twitter, i don't even know if i want to read it in its entirety
13:17:19 <dminuoso> ski: Not exactly. But I think I've lost track a while ago, but as the discussion with Loeb's paradox might have indicated I'm willing to chew off more than I can bite.
13:18:04 <dminuoso> ski: A lot of this strongy suggests I should stop and start understanding the basics better, so that what you wrote makes instant sense.
13:19:20 <ski> dminuoso : it might help to start with trying to better understand what `forall' means
13:19:44 <dminuoso> ski: Well rather the position of that quantifier.
13:19:53 <dminuoso> Or context even.
13:20:15 <ski> if we write a type signature `reverse :: [a] -> [a]', it's not the presence of the type variable `a' in the signature which indicates that `reverse' is a polymorphic operation
13:20:29 <dminuoso> Right, its the implied ∀
13:20:34 <huss`> ski: https://pastebin.com/raw/n989iXbk
13:20:37 <dminuoso> i.e. reverse :: ∀a. [a] -> [a]
13:20:56 <huss`> ski: maybe i'm stupid but its seems like its different even if the output is the same
13:21:00 <ski> really, writing that is just a shorthand notation for the full `reverse :: forall a. [a] -> [a]', and it's this `forall' in the type that indicates that `reverse' is polymorphic
13:21:24 <huss`> ski: fail in first function it should be a '*'
13:21:33 <ski> a value of type `forall a. ..a..' is a polymorphic value (and all such values have types of that form)
13:23:03 <ski> it being a polymorphic value means that for all concrete types `T', that value *can* be treated as having value `..T..' (with all (free) occurances of the type variable ("tyvar") `a' replaced by the (same) type `T' .. a *consistent* (capture-avoiding) substitution)
13:23:14 <ski> so
13:23:16 <ski>   reverse :: forall a. [a] -> [a]
13:23:18 <ski> amounts to
13:23:27 <ski>   reverse :: [Integer] -> [Integer]
13:23:35 <ski>   reverse :: [[Char]] -> [[Char]]
13:23:44 <huss`> jle`: https://pastebin.com/raw/n989iXbk
13:23:45 <dminuoso> ski: Right, this much is clear.
13:23:50 <ski>   reverse :: [Double -> IO Bool] -> [Double -> IO Bool]
13:23:53 <ski> &c.
13:24:02 <ski> but not, e.g.
13:24:07 <huss`> jle`: should be '*' in g my bad but it illustrate
13:24:08 <ski>   reverse :: [[Char]] -> [Integer]
13:24:33 <dminuoso> ski: Right, because the universal qualifier `a` is the same
13:25:04 <jle`> huss`: in haskell,evaluation is done by substitution
13:25:15 <jle`> in both cases, the two formulations essentially evaluate to the same thing
13:25:20 <dminuoso> ski: so "forall" kind of means "for every type, replace `a` with that type"
13:25:24 <dminuoso> ski: thats the notion I learned
13:25:28 <ski> this means that the producer/implementor/constructor/definer/callee of a polymorphic value needs to treat the type variable `a' as "abstract/opaque", since it's the user/consumer/caller that will decide in the end which actual type `a' will correspond to
13:25:29 <jle`> huss`: so they are identical, to haskell
13:25:43 <jle`> huss`: ghc will even sometimes inline definitions
13:25:53 <dminuoso> ski: right.
13:25:55 <huss`> jle`: for you what's the best ?
13:25:58 <jle`> huss`: so if you inline the definitions of foldl, (.), ($), map, etc.
13:26:05 <jle`> huss`: you'll find that both compile to the same code
13:26:14 <jle`> *both compile to the same bytecode
13:26:20 <huss`> jle`: okay
13:26:23 <ski> so, the caller can freely (but consistenly) replace `a' by any `T' they like. while the callee must treat it as abstract, can assume nothing about the type (can't, in general, detect what type it is, at run-time)
13:26:27 <metahumor> jle`: what about foldr (.) id [(add 2), (subtract 2)] ?
13:26:38 <ski> dminuoso : now, the situation with `exists' is the opposite
13:26:52 <jle`> huss`: i'd prefer A (sum events)
13:26:55 <metahumor> is there any way to force fusion of the list of functions to a simpler function before evaluation?
13:27:08 <ski> dminuoso : a value of type `exists a. ..a..' is a value of type `..T..', for *some* (unknown/forgotten/abstract/hidden) type `T'
13:27:12 <jle`> metahumor: what 'simpuler function' are you imagining
13:27:27 <dminuoso> ski: what do those .. dots denote?
13:27:34 <huss`> jle`: in a more complex situation the full transformation is better ? more elegent ?
13:27:40 <huss`> elegant*
13:27:46 <metahumor> (foldr (.) [(add 2), (subtract 2)] id) ~= id
13:27:49 <ski> by `..a..' i mean any type expression, which is allowed to refer to the type variable `a'
13:28:06 <dminuoso> ski: so say `exists a. Maybe a` perhaps?
13:28:08 <jle`> metahumor: that's not necessarily true depending on the Num instnace, unfortunately
13:28:16 <ski> by `..T..' i mean the same type expression, but with all (free) occurances of that `a' replaced by `T'
13:28:26 <ski> dminuoso : yes
13:28:34 <dminuoso> ski: Alright understood.
13:28:41 <ski> dminuoso : or `exists a. (a,a -> a,a -> String)'
13:28:56 <dmwit> ?tell frerich Okay, today I spent a bit of time debugging. Turns out the reason it didn't work was because I was swapping the acceleration and position arguments in one of my calls. Whoops! Complete code for solving parts 1 and 2 without simulation is here: http://lpaste.net/2409493021176365056
13:28:56 <lambdabot> Consider it noted.
13:28:57 <metahumor> lets say i had a Group with (foldr (*) [m, inverse m] mzero)
13:29:16 <ski> dminuoso : in this case (`exists'), it's the *producer* who gets to pick which type `a' correponds to. and it's the *consumer* who have to treat `a' as unknown/abstract/opaque
13:29:19 <jle`> huss`: to make the comparison better, you could write g = A (foldl next 1 (map (*) events))
13:29:28 <jle`> huss`: and if you tried to write 'next'
13:29:29 <ski> dminuoso : this is exactly the opposite, to the case with `forall'
13:29:31 <jle`> what do you think the definition would be?
13:29:52 <jle`> huss`: what i gave is a more accurate comparison between the two things you showed
13:29:56 <dminuoso> ski: Sounds abstract but clear.
13:30:04 <jle`> er, gives a more fair comparison
13:30:10 <dminuoso> ski: How does a consumer not know what type something is though?
13:30:12 <ski> dminuoso : if i give you a value `(x,f,s)' of type `exists a. (a,a -> a,a -> String)', what can you do with it, to extract any useful information ?
13:30:21 <jle`> * foldl next ?? (map (*) events)
13:30:28 <jle`> what do you think next would be? or ??
13:30:48 <dminuoso> ski: Give me a moment to process this.
13:30:55 <huss`> (.) ?
13:30:56 <jle`> huss`: spoilers -- if you write out 'next', it will be something like next f g x = f (g x)
13:31:00 <jle`> huss`: yes
13:31:04 <ski> dminuoso : i won't tell you what type `a' is. but you're ensured that it's the *same* type `a', in `x :: a', `f :: a -> a', and `s :: a -> String'
13:31:16 <jle`> huss`: so really the difference is that in one situation you are re-using a function that everyone already knows the name of
13:31:25 <jle`> huss`: and in the other, you are re-implementing that common function with a new name
13:31:53 <jle`> huss`: the two are identical -- it's just that in one situation, you are re-implementing the other from scratch instead of using a library function
13:31:55 <huss`> jle`: okay thanks for clearing that
13:32:05 <jle`> huss`: note that there is no difference in evaluation strategy
13:32:14 <jle`> huss`: the two evaluate the same way, so there is no performance difference
13:32:26 <jle`> huss`: the only difference is that in one case you use a pre-named function and the other you use the same function but re-implemented from scratch
13:32:40 <huss`> jle`: ^^
13:32:41 <ski> dminuoso : compare this with the following situation : a module, which (abstractly) exports a type `A', and three operations : `x :: A',`f :: A -> A',`s :: A -> String' -- this is very similar to the `exists' case
13:32:46 <huss`> jle`: stupid from me right
13:32:53 <jle`> huss`: not stupid :)
13:33:03 <jle`> it's definitely hard to recognize things like this when you're just starting
13:33:10 <metahumor> so is there a way to force a difference in the evaluation strategy if i want to fuse a list of functions together?
13:33:12 <jle`> you'll definitely end up re-implementing library functions a lot by accident
13:33:49 <jle`> huss`: hlint is a nice took that can sometimes identify when you re-implement library funtions by accident
13:34:01 <huss`> jle`: will look at it
13:34:10 <jle`> metahumor: you mean reduce foldr (.) id [f, g] x to f (g x) ...?
13:34:11 <ski> dminuoso : the only difference is that you can get passed many different `exists a. (a,a -> a,a -> String)' values, at run-time (possibly depending on run-time input, and each such triple using a different type for `a'). while otoh you can't construct new modules at run-time, passing them around as run-time values
13:34:21 <jle`> metahumor: those are already the same thing, and ghc might actually compile them to the same bytecode perhaps
13:34:56 <metahumor> reduce the following: foldr (.) id [rot90, rot90, rot90, rot90] to id
13:35:36 <metahumor> what do i have to define to help ghc compile them down to the same bytecode?
13:36:15 <ski> dminuoso : one example of a value of type `exists a. (a,a -> a,a -> String)' could be `(0 :: Integer,succ,show)'. another could be `("abc",reverse,id)'
13:36:41 <dminuoso> ski: I mean the way to extract information from it seems to be by simply doing `(s . f) x`, but the thing that confuses me is how the producer gets to pick the type.
13:37:04 <dminuoso> ski: Does this mean the caller has to pass something polymorphic in its type?
13:37:15 <dminuoso> Say... a number?
13:37:57 <jle`> metahumor: that's basically the same thing as asking to reduce rot90 (rot90 (rot90 (rot90 x))) to id
13:38:08 <ski> dminuoso : but as a user/consumer/"caller" of such a value, you can't detect that `a' in the first case is `Integer', and `String' in the second case. i keep repeating words like "forgotten","hidden","opaque","abstract", to emphasize this restriction (which is the same restriction that the implementor/*producer* of a polymorphic value has wrt the universally quantified tyvar)
13:38:16 <jle`> metahumor: the list doesn't play any part in the story
13:38:26 <jle`> metahumor: the 'hard part' is not the list expansion
13:38:55 <ski> dminuoso : by caller, do you mean the user/receiver of that "existential triple" ?
13:39:27 <ski> dminuoso : in my first example, i had a triple of an `Integer', a function from `Integer' to `Integer', and a function from `Integer' to `String'
13:39:46 <ski> dminuoso : in my second example, i had a triple of a `String', a function from `String' to `String', and a function from `String' to `String'
13:40:33 <ski> `exists a. (a,a -> a,a -> String)' is a common abstracted version of the two types `(Integer,Integer -> Integer,Integer -> String)' and `(String,String -> String,String -> String)'
13:41:03 <ski> if we have a polymorphic value of type `forall a. ..a..', then we can treat it as having type `..T..'
13:41:25 <metahumor> alright, so its the same as reducing the rot90 (rot90 (rot90 (rot90 x))) to id -- maybe i'm not understanding how laziness affects evaluation here. if rot90 was an expensive pure computation, but i also knew that 4 x rot 90 was cheap, and i called rot90 (rot90 (rot90 (rot90 x))), how could i speed up the evaluation?
13:41:32 <ski> if we have a value of type `..T..', then we can treat it as having the "abstracted" type `exists a. ..a..'
13:42:03 <ski> dminuoso : note how these two similar-looking processes, one for `forall', and one for `exists', go in opposite direction
13:42:11 <jle`> metahumor: yes, you are right, laziness does not play any real role
13:42:28 <ski> we can go from the general `forall a. ..a..' to the specialized/instantiated `..T..'
13:42:49 <jle`> metahumor: well one thing you can do is create a representation of your rotation action that is optimizable
13:42:53 <ski> we can go from the specific example `..T..' to the abstracted `exists a. ..a..'
13:43:14 <jle`> metahumor: and instead of using functino composition, use some sort of monoidal operator
13:43:25 <jle`> you could even make it a Monoid directly
13:43:38 <jle`> newtype Rotation = Rot { runRot :: Double }
13:44:10 <jle`> instance Monoid Rotation where mempty = Rot 0; mappend rot1 rot2 = Rot (runRot1 + runRot 2)
13:44:32 <ski> dminuoso : so, if i have a triple `(0,succ,show)' of type `(Integer,Integer -> Integer,Integer -> String)', i can treat it has having type `exists a. (a,a -> a,a -> String)', by abstracting (in this case all) away ocurrances of `Integer', "hiding" them "behind" the type variable `a', forgetting the concrete type `Integer' in the example sample
13:44:44 <jle`> and then mappend [rot90, rot90, rot90, rot90] would be something that you can now manipulate and optimize
13:45:12 <jle`> perhaps you can choose to reduce a rotation of 360 degres to a rotation of 0 degrees, like optimize (Rot x) = Rot (x `mod` 360)
13:45:21 <jle`> (you can even 'mod' it in your definition of mappend too)
13:45:33 <jle`> and so then mappend [rot90, rot90, rot90, rot90] would be the same as rot0
13:45:41 <jle`> (or mempty)
13:46:07 <ski> dminuoso : so the answer to "Does this mean the caller has to pass something polymorphic in its type?","Say... a number?" is no. `(Integer,Integer -> Integer,Integer -> String)' is not the type of a polymorphic value. `0' in `(0,succ,show)' is the monomorphic `Integer' literal for zero. we're not relying on polymorphism here, when going to the `exists'-type
13:46:15 <jle`> metahumor: in this case though you could build up your final Rot using rotation composition, and then at the end, create a function from it to apply to 'x'
13:46:36 <dminuoso> jle`: When I said number I meant it in the polymorphic sense `∀a. Num a => a`
13:46:55 <jle`> metahumor: if you create your Rot type correctly and its mappend correctly (maybe `mod` 360 on every mappend) then you can get the actualr eduction mappend [rot90, rot90, rot90, rot90] = mempty
13:47:00 <dminuoso> err ski ^-
13:47:28 <ski> dminuoso : similarly, if i have a triple `("abc",reverse,show)' of type `(String,String -> String,String -> String)', i can treat it as having the more abstracted type `exists a. (a,a -> a,a -> String)' (abstracting away *some*, but in this case not *all*, instances of `String' under the tyvar `a')
13:47:56 <metahumor> jle`: so to get the optimization above, i should define Monoid instances for a specialization of my function, and in the mappend, explicitly write out how to optimize the mappend
13:47:57 <dminuoso> ski: Please stop rushing, you've already exceeded my mental stack capacity. :o
13:48:13 <EvanR> ah, forall a . Num a => a does make sense, unlike Show
13:48:27 <ski> dminuoso : ok
13:48:31 <EvanR> since Num gives you facilities to build a's
13:49:03 <ski> dminuoso : "When I said number I meant it in the polymorphic sense `∀a. Num a => a`" -- yes, i understood that. and that's what i'm saying is not required/relevant here
13:49:19 <metahumor> so the fold I have before becomes (mappend [rot90, rot90, rot90, rot90]) `runRot` x
13:50:54 <dminuoso> @let x :: exists a. (a,a -> a,a -> String)
13:50:54 <lambdabot>  Parse failed: Parse error: .
13:51:10 <merijn> dminuoso: There's no such thing as 'exists'
13:51:47 <EvanR> would be cool though
13:51:50 <ski> it's a conceptual tool
13:52:13 <ski> UHC and LHC has syntactic support for `exists', but only in trivial cases
13:53:08 <metahumor> jle`: to continue the optimization discussion, would there be a way to define a "compilation" monoid for the AoC problem today?
13:53:12 <ski>   foo :: Bool -> (exists a. (a,a -> a,a -> String))
13:53:21 <ski>   foo False = (0,succ,show)
13:53:33 <ski>   foo True  = ("abc",reverse,id)
13:53:44 <metahumor> somehow, identify the inner loop and compile it down to a single call instead of the iterated prime searcher?
13:53:57 <ski> that's a slightly less trivial example of an operation using `exists'
13:54:04 <metahumor> basically, "how do compilers and '-O3' work"?
13:54:17 <ski> note that the actual type selected for `a' depends on the run-time value that `foo' gets as argument
13:55:13 <ski> if you get that `Bool'ean from user input, then the caller of `foo' can't predict what type `a' will be
13:55:46 <merijn> A completely unrelated naming question: What's a good name for a record that contains "min, lower quantile, mean, median, upper quantile, max, and std deviation" of a bunch of data?
13:56:22 <Xal> ... don't use record syntax?
13:56:29 <metahumor> Quantiles?
13:56:34 <ski> (i suppose, for concreteness, i should replace `0' above with `0 :: Integer', as i did first. that way it's clear in that case what type `a' is, and it's clear that `0' isn't used polymorphically)
13:56:51 <merijn> metahumor: In the end compilers are just algorithms for detecting certain patterns of code and generating more specialised/better performing code for it
13:57:01 <huss`> Existential quantification is a good thingN
13:57:02 <huss`> ?
13:57:10 <ski> sometimes
13:57:16 <Xal> metahumor: yeah, 0th (min) percentile, 25th (lower), 50th (mean), 75th (upper), and 100th (max)
13:57:19 <merijn> Xal: How is that a solution? That still doesn't give me a name for the type
13:57:19 <dminuoso> ski: I think Im getting the idea. Essentially its stating "Given a boolean there exists exaxctly one type, such that"
13:57:28 <ski> @where existential-antipattern
13:57:28 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
13:57:31 <ski> huss` ^
13:57:41 <merijn> dminuoso: The key part being "you don't know what that type is"
13:57:43 <Xal> merijn: it isn't really.  Haskell record syntax is unfortunately pretty painful
13:57:52 <dminuoso> merijn: Right. I just know that one exists.
13:57:54 <merijn> Xal: How is this related to record syntax at all?
13:57:54 <metahumor> Xal: I mean, name it Quantiles {zero, quarter, half, thricequarter, one, std}
13:58:08 <merijn> Xal: I'm talking about the type, not the fields
13:58:13 <Xal> oh, haha
13:58:41 <metahumor> careful, not all data can have an std
13:58:45 <huss`> ski: thanks
13:58:50 <Xal> call it SummaryStatistics
13:58:54 <dmwit> merijn: "SummaryStatistics"
13:59:03 <huss`> ski: find myself doing ugly things and wondering if it was a good way haha
13:59:15 <dminuoso> ski: I tried to mentally stick to Haskell too much.
13:59:19 <merijn> Initially I was gonna use "FiveDigitSummary", but then I realised I have six, since I include both median and mean >.<
13:59:23 <dminuoso> 22:41         ski | dminuoso : note how these two similar-looking processes, one for `forall', and one for `exists', go in opposite direction
13:59:27 <dminuoso> I can sew what you're on now.
14:00:24 <dminuoso> so `Bool -> (forall a. (a,a -> a,a -> String))` would imply that it returns a lot of types (any of which the consumer could pick)
14:00:38 <dmwit> merijn: Also, a coworker infected me and now any time I see those properties, I can't help but think of the Datasaurus. https://www.autodeskresearch.com/publications/samestats
14:00:47 <ski> merijn : perhaps something based off "box plot/diagram" ?
14:00:53 <dminuoso> ski: Am I seeing this right?
14:01:00 <merijn> ski: Naah, I'm not really rendering them ever
14:01:15 <dminuoso> Whereas `Bool -> (exists a. (a,a -> a,a -> String))` would return one.. opaque/hidden type to the consumer.
14:01:22 <EvanR> you dont return a lot of types
14:01:34 <EvanR> you return a tuple in both cases
14:02:04 <EvanR> in the forall case the first component has to be bottom, the second component has to be `id'
14:02:44 <ski> conceptually, it returns a type, together with the triple. but that type isn't something that you can inspect at run-time. it's just information that there is some unknown type here, which may be involved in the type of the value (here triple)
14:03:07 <ski> dminuoso : possibly
14:04:24 <EvanR> sigmas seem cleaner to me than this idea of returning a type along with the data
14:04:33 <ski> a value of type `exists a. ..a..' can be thought of, conceptually, as a pair of a type `a', and a value of type `..a..'
14:04:34 <EvanR> that you cant use
14:04:35 <EvanR> or see
14:04:43 <ski> but in Haskell, the type part is implicit
14:05:06 <ski> a value of type `forall a. ..a..' can be thought of, conceptually, as a function that when given a type `a', will return a value of type `..a..'
14:05:40 <ski> (but in Haskell, the type part is implicit. you don't explicit pass, and receive, types, when writing Haskell expressions)
14:06:56 <ski> (in System F, you'd not write `id False', but rather something like `id @Bool False', where we first apply `id :: forall a. a -> a' to the type `Bool', getting a result of type `Bool -> Bool', and then we apply that to `False :: Bool', getting a `Bool' back)
14:07:17 * ski nods to EvanR
14:13:25 <ski> (similarly, instead of the implicit (pseudo) Haskell `("abc",reverse,id)', you can in System F imagine a more explicit "type-and-value pair" `(@ a = String , ("abc",reverse @Char,id @String) :: (a,a -> a,a -> String))'. here we give a name `a' to the first component (the type), to be able to specify which `String' occurances in the type of the second part (the triple), should be abstracted away as the tyvar `a')
14:15:16 <dminuoso> ski: Okay brushing up on a few things. It seems like encoding existential types in Haskell would commonly be done with a wrapper like: `data T = forall a. T (a, a -> a, a -> String)` which allows me to do exactly that.
14:15:29 <ski> yes
14:15:31 <dminuoso> I can freely return that `T` to a producer, who is none-the-wiser about what I just placed in there.
14:15:39 <ski> that's one of the two encodings
14:16:36 <ski> me previous `take' and `length' examples were related to explaining how this encoding works (and why it uses `forall', when we call it an "existentially quantified data type")
14:17:05 <ski> should i go back to that now ?
14:17:20 <EvanR> dminuoso: yeah, then you can put "different things" in a list, of type [T]
14:18:50 <EvanR> and it would not be possible to get the same effect by apply the functions to the a first and putting the results in a list instead
14:19:03 <EvanR> in this case
14:19:19 <EvanR> as was done earlier with Show and String
14:19:56 <ski> (well, you can do something similar, in this case :)
14:20:28 <EvanR> if you provide someone the [T], they can use the a -> a however many times they like
14:20:48 <EvanR> before using the a -> String
14:21:19 <EvanR> so you could make a list of [Integer -> String]
14:21:37 <EvanR> but this kind of puzzle solving would not be necessary if you used the existential type
14:25:29 <dminuoso> ski: Had to go all the way back to realize what you were talking about.
14:27:31 <ski> yes or no ?
14:27:36 <dminuoso> ski: Oh yeah go ahead.
14:27:46 <ski> <ski> dminuoso : btw, note that `T -> (forall a. F a)' amounts to the same thing as `forall a. (T -> F a)'. and `T -> (Cxt => U)' amounts to the same thing as `Cxt => (T -> U)'. combined, `T -> (forall a. C a => F a)' amounts to the same thing as `forall a. C a => (T -> F a)' -- in some abstract sense, one can think of all these as "changing argument order"
14:27:56 <ski> <ski> dminuoso : also, note that `(exists a. F a) -> T' amounts to the same thing as `forall a. (F a -> T)'. and `(Cxt *> T) -> U' amounts to the same thing as `Cxt => (T -> U)'. combined, `(exists a. C a *> F a) -> T' amounts to the same thing as `forall a. C a => (F a -> T)' -- in some abstract sense, one can think of all these as "currying"
14:28:09 <ski> <ski> dminuoso : an example of the former is that `take :: forall a. (Int -> [a] -> [a])' amounts to the same as `take :: Int -> (forall a. [a] -> [a])'
14:28:13 <ski> <ski> dminuoso : an example of the latter is that `length :: forall a. ([a] -> Int)' amounts to the same as `length :: (exists a. [a]) -> Int'
14:28:27 <ski> <ski> dminuoso : does those two examples make any sense to you ?
14:29:26 <dminuoso> ski: Yes.
14:29:54 <dminuoso> ski: Even *> makes perfect sense now. =)
14:29:54 <ski> for every type `a', if you call `length' with an argument of type `[a]', you will get a result of type `Int' back
14:30:31 <ski> when applying `length', you'll get an `Int' result back, as long as there exists some type `a' such that the argument you supply has type `[a]'
14:30:57 <ski> do you see how those two descriptions of the type behaviour of `length' corresponds to those two given alternative type signatures for `length' ?
14:32:41 <dminuoso> ski: is one of those "length" supposed to read "take" ?
14:32:49 <ski> no, i'm talking about
14:32:53 <ski>   length :: forall a. ([a] -> Int)
14:32:54 <ski> vs.
14:32:57 <ski>   length :: (exists a. [a]) -> Int
14:34:34 <dminuoso> ski: Yeah pretty much.
14:34:36 <ski> (i'm focusing more on the `exists' case here, hoping that the `forall' case (like `take' above) makes more obvious sense, given more experience with universal polymorphism, than with "existential abstraction")
14:34:42 <ski> good
14:35:58 <EvanR> its funny though, in a different language in a different universe users may have started with more experience in the exists
14:36:16 <EvanR> given this equivalence
14:36:41 <EvanR> a pair seems more concrete than a function
14:37:42 <ski> (also, existential quantification is more related (than universal quantification) to object-orientation (and to abstract data types, but in a slightly different way))
14:37:47 <ski> now, regarding these two equivalences ..
14:38:34 <ski> on the one hand the one between `... -> (forall a. ..a..)' and `forall a. (... -> ..a..)' (`a' not occuring (freely) in `...') in some sense says that a `forall' in a *result* type is "trivial", since it can be rewritten into (supposed simpler to understand) `forall' wrapping the whole function type
14:39:22 <ski> and on the other hand between `(exists a. ..a..) -> ...)' and `forall a. (..a.. -> ...)' (`a' not occuring (freely) in `...') in some sense says that an `exists' in an *argument* type is "trivial", since it can be rewritten into (supposed simpler to understand) `forall' wrapping the whole function type
14:39:33 <ski> dminuoso : do you follow what i mean there ?
14:42:00 <dminuoso> ski: Yup. Im guessing given some `Int -> (exists a. [a]) -> Int` that can also be rewritten into `Int -> forall a. [a] -> Int` ?
14:42:49 <ski> yep, the equivalences can be applied to any type subexpression, not just to the "whole type expression"
14:43:05 <ski> so, in that case, you can further rewrite into `forall a. Int -> [a] -> Int'
14:45:44 <dminuoso> ski: Oh right because semantically it appears in the "result" of the first function, right?
14:45:48 <ski> (and then, if that occurs *directly* after the `::' in a type signature, you can, with *Haskell* syntactic sugar, omit the `forall a.', leaving it implicit (except if the type variable `a' was already in scope outside the signature, e.g. in a `class' declaration, or with `ScopedTypeVariables' or `InstanceSigs'))
14:45:57 <ski> dminuoso : right
14:46:20 <ski> `A -> B -> C' is short for `A -> (B -> C)'. the operator `->' is "right associative"
14:46:35 <dminuoso> Right. Then I do follow.
14:46:38 <ski> good
14:46:42 <ski> so
14:46:51 <ski> what would not be "trivial" in this sense, but rather "interesting", is when an `exists' occurs in a *result* type, or when a `forall' occurs in an *argument* type
14:48:04 <dminuoso> So by forall in an argument type you mean like Int -> (forall a. [a]) -> Int?
14:48:10 <ski> an `exists' in a *result* type (or even at the "top-level" in a type signature) means that that operation will select the hidden type, possible at run-time, depending on argument values (or I/O input, if we're using `IO')
14:48:35 <ski> while a `forall' in an *argument* type is what is known as a rank-2 operation
14:48:51 <jjohnsson> Does anyone know why I get "Parse error: module header, import declaration or top-level declaration expected." when building file containing makeLenses’’ SomeDataType with newest stack? I have the TemplateHaskell pragma set in the file, import Control.Lens.TH and lens i installed. Trying to revive an old project; the code has worked before.
14:49:02 <ski> consider
14:49:16 <ski>   foo :: (forall a. [a] -> [a]) -> (String,[Integer])
14:50:17 <ski>   foo f = (take 3 (f "abcd"),drop 1 (f [2,3,5,7]))
14:50:36 <ski> `foo' here is *not* polymorphic, despite `forall' appearing in its type-signature
14:50:57 <dminuoso> Right it just takes a polymoprhic function as an argument.
14:50:58 <ski> otoh, `f' is polymorphic. `foo' *requires* its argument to be a polymorphic function
14:51:13 <dminuoso> Neat, came to the same conclusion before you said it. :)
14:51:17 <ski> you can't say `foo ("xyz" ++)'
14:51:37 <dminuoso> but foo (reverse) ...
14:51:38 <ski> but you can say `foo id' and `foo reverse' and `foo (take 3)'
14:51:50 <dminuoso> Oh goodie. Before you again!
14:51:55 * ski grins
14:52:16 <dminuoso> _This_ feels completely natural and intuitive.
14:52:58 <ski> if we have `bar :: ((forall a. ..a..) -> ...) -> ...', then that would be a rank-3 operation, since we have to pass "inside to the left" of two `->'s, to reach the `forall'
14:53:33 <ski> the `n' in "rank-`n'" measures how deeply left-nested inside `->' a `forall' occurs
14:53:44 <ski> an ordinary polymorphic operation is rank-1
14:54:37 <ski> recall that as we "move into an argument type", the interpretation of `forall' and `exists', in terms of the caller and the callee, get swapped around
14:55:14 <ski> if you have a value of type `exists a. (a,a -> a,a -> String)', then the producer of that value decides what type to pick for `a'
14:55:49 <ski> if you have a value of type `(forall a. [a] -> [a]) -> (String,[Integer])', then *again* the producer of that value decides what type (possibly many), to pick for `a'
14:56:22 <totom> ski:  Do you have a mathematical background?
14:56:23 <ski> in the `foo :: (forall a. [a] -> [a]) -> (String,[Integer])' case above, `foo' once uses `f', picking `a' as `Char', and once uses `f' while picking `a' as `Integer'
14:56:33 <ski> totom : some
14:56:44 <totom> cool
14:57:34 <dminuoso> ski: Wow interesting.. so rank-2 types are another way of doing existential types.
14:57:50 <dminuoso> ski: And it seems with a different goal.
14:58:56 <EvanR> exactly when do you run into ImpredicativeTypes
14:59:01 <ski> dminuoso : so, in both the earlier `foo :: Bool -> exists a. (a,a -> a,a -> String)' example, and the current `foo :: (forall a. [a] -> [a]) -> (String,[Integer])' example, the *caller* of `foo' has to treat `a' abstractly/opaquely, while the callee itself gets to pick `a' (in the latter `foo', two times, with different concrete types in place of `a'. in the former `foo', two "alternate" times, one of which is selected, depending on which `Bool' is sent, wh
14:59:16 <EvanR> (forall a . a) -> X, works, (forall a . a -> a) -> X, works without it
14:59:26 <ski> (er, cut off near ".. in the former `foo', two \"alternate\" times, one of which is selected, depending on which `Bool' is sent, which then determines which concrete type to use for `a')")
15:00:03 <dminuoso> ski: Right. With the difference that in one case the "consumer picked type" disppears (because the existential type is in argument position), whereas returning some newtype wrapped existential type would leave it in return position?
15:00:32 <ski> dminuoso : "so rank-2 types are another way of doing existential types." -- coming to that in a bit, if you want to hear it :)
15:01:12 <dminuoso> ski: I absolutely do, though I think not today. It's getting late, and I think it's best to just process and perhaps play around with it. :)
15:01:33 <ski> the main difference between these two `foo' cases are : (a) `forall' is used in one, `exists' in the other; (b) the quantifier in question occurs in the result type in one case, in the argument type in the other
15:02:07 <ski> both (a) and (b) amounts to reversals of the caller vs. callee roles of who gets to pick the concrete type, and who must treat `a' abstractly
15:02:40 <ski> so, here, those two reversals annihilate each other, giving the similarity that in both cases the implementor of `foo' picks `a'
15:03:26 <ski> dminuoso : well, i think i could explain the "existential data type" encoding now .. it's not that hard, once you've understood key concepts mentioned above
15:03:34 <ski> or another time ?
15:03:50 <ski> (i don't think it'll take that long)
15:04:24 <dminuoso> ski: Oh absolutely go for it.
15:04:46 <ski> ok, so we want to encode the type `exists a. (a,a -> a,a -> String)'
15:04:57 <ski> we start by making a new data type for it, `T' :
15:05:08 <ski>   data T = MkT (exists a. (a,a -> a,a -> String))
15:05:15 <ski> this is still pseudo-Haskell
15:05:16 <dminuoso> such that `T ~ exists a. (a,a -> a,a -> String)` ?
15:05:25 <ski> yep
15:05:35 <dminuoso> k
15:05:37 <dminuoso> sec
15:06:24 <dminuoso> Given that: (exists a. F a) -> T' amounts to the same thing as `forall a. (F a -> T)'. and `(Cxt *> T) -> U' amounts to the same thing as `Cxt => (T -> U)'. combined, `(exists a. C a *> F a) -> T
15:07:03 <ski> .. combined, `(exists a. C a *> F a) -> T' amounts to the same thing as `forall a. C a => (F a -> T)' -- in some abstract sense, one can think of all these as "currying"
15:07:16 <dminuoso> Yes that! :D
15:07:29 <dminuoso> weechat is a bit annoying wrt to linebreaks in its default setting
15:07:29 <ski> shall i continue, or did you want to say/ask something more ?
15:08:33 <dminuoso> No go ahead.
15:08:37 <ski> ok
15:08:45 <ski> this data type definition gives the following data constructor signature
15:08:50 <ski>   MkT :: (exists a. (a,a -> a,a -> String)) -> T
15:08:56 <ski>   which, by the previous equivalence we went through, amounts to the same as
15:09:02 <ski>   MkT :: forall a. (a,a -> a,a -> String) -> T
15:09:12 <dminuoso> Which is actually possible in haskell. :)
15:09:16 <ski> if we want to, we could further reformulate this, using currying, as
15:09:28 <ski>   MkT :: forall a. a -> (a -> a) -> (a -> String) -> T
15:09:58 <ski> so, these two latter signatures, which are not (only) pseudo Haskell, gives the following two corresponding data type declarations
15:10:11 <ski>   data T = forall a. MkT (a,a -> a,a -> String)
15:10:14 <ski> respectively
15:10:22 <ski>   data T = forall a. MkT a (a -> a) (a -> String)
15:10:46 <ski> so, the `forall' here should not be `exists'. it says that the data constructor `MkT' is *polymorphic* (in `a')
15:11:14 <ski> however, the crucial aspect here is that the return type of `MkT' does not mention this tyvar `a'
15:12:23 <ski> so, that means that both `MkT (0 :: Integer) succ show' (using `a = Integer') and `MkT "abc" reverse id' (using `a = String') has the same type `T', where the type variable `a' (or the concrete type it has been replaced by) does *not* occur !
15:13:08 <ski> so, the evidence of what actual type `a' was used has *disappeared* from the type of the whole expression. it's *forgotten*
15:13:14 <dminuoso> ski: Which makes sense, since the implementor picked it. If it produced `a` then the consumer could.
15:13:42 <ski> this means that when we match a value of type `T' with a pattern `MkT x z s', we have no way (in general) of recovering the actual type used for `a'
15:14:51 <ski> compare with `Just False', which has type `Maybe Bool', which hasn't forgotten `Bool'. that way, when we match that value with the pattern `Just x', we know that `x' must have type `Bool'
15:15:22 <ski> e.g. if we call `catMaybes [Just False,Nothing,Just True]', we know we get something of type `[Bool]' back
15:15:25 <ski> @type catMaybes
15:15:27 <lambdabot> [Maybe a] -> [a]
15:15:31 <ski> > catMaybes [Just False,Nothing,Just True]
15:15:34 <lambdabot>  [False,True]
15:15:45 <ski> @src catMaybes
15:15:45 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:15:56 <ski> in the signature
15:16:03 <ski>   Just :: forall a. a -> Maybe a
15:16:23 <dminuoso> Ah, `a` appearing in the return type.
15:16:24 <ski> the tyvar `a' *does* occur in the result type `Maybe a', and so it's not forgotten, when `Just' is used
15:17:00 <ski> btw, with the `GADTs' extension, you can define `T' above directly as
15:17:05 <ski>   data T
15:17:07 <ski>     where
15:17:13 <ski>     MkT :: forall a. a -> (a -> a) -> (a -> String) -> T
15:17:27 <ski> listing the signature(s) for the data constructor(s)
15:17:39 <dminuoso> ski: Even without ExistentialQuantification?
15:17:46 <ski> (and, in fact, you're also allowed to elide this `forall a.' here)
15:17:55 <ski> `GADTs' implies `ExistentialQuantification'
15:17:59 <dminuoso> Ah. :)
15:18:30 <ski> also, imho `ExistentialQuantification' is a bit of a misnomer. an extension named `ExistentialQuantification' ought to, imnsho, enable `exists' syntax
15:18:34 <dminuoso> ski: Out of curiosity, was there a point to currying that?
15:19:03 <ski> well, with the tuple, you get an extra bottom in the type. you might want to avoid that boxing
15:19:35 <dminuoso> a bottom in the type?
15:19:39 <ski> (but the main point was just to show that you *can* (and often do) curry the existential data constructor)
15:19:51 <dminuoso> ah right
15:20:03 <ski> with the tuple, `MkT _|_' is different from `MkT (_|_,_|_,_|_)'
15:20:15 <ski> with `MkT' curried, you can't express the former
15:20:34 <ski> the tuple is an extra box, an extra indirection
15:20:59 <ski> also, there's nothing that hinders you from saying
15:21:54 <ski>   data Expr a = Lit a | If (Expr Bool) (Expr a) (Expr a) | forall b. App (Expr (b -> a)) (Expr b)
15:22:21 <ski> so that you have one "existentially quantified data constructor", while the other two are ordinary data constructors
15:22:41 <ski> so, it's not the data type, really, but the data constructor, which is associated with the existential quantification here
15:22:53 <ski> with that definition, you can define
15:22:59 <ski>   eval :: forall a. Expr a -> a
15:23:05 <ski>   eval (Lit x) = x
15:23:17 <dminuoso> Without knowing about the choice of b :o
15:23:22 <ski>   eval (if eb et ee) = if eval eb then eval et else eval ee
15:23:34 <ski>   eval (App ef ex) = eval ef (eval ex)
15:23:38 <ski> right
15:24:38 <ski> with proper GADTs, you can make this even more interesting, adding a data constructor with signature `LitInt :: Int -> Expr Int', and one with signature `LessThan :: Expr Int -> Expr Int -> Expr Bool'
15:24:42 <ski> together with
15:24:47 <ski>   eval (LitInt n) = n
15:25:00 <ski>   eval (LessThan en0 en1) = eval en0 < eval en1
15:25:13 <ski> (and you can imagine adding `Add',&c. as well)
15:26:08 <ski> the interesting thing here is that we can use `(<)' in the `LessThan' case (and `(+)' in the `Add' case), despite the signature `eval :: forall a. Expr a -> a' claiming `eval' works for *all* types `a', not just ones in `Ord' or `Num' or something like that
15:26:26 <ski> .. but that's a story for another day. this is just a teaser :)
15:26:42 <ski> i should shortly talk about `*>' as well
15:26:51 <ski> consider `exists a. Show a *> a' from before
15:26:53 <ski> we get
15:27:04 <dminuoso> ski: Yeah.. you have shown me why my simple expression calculator felt.. so shallow and crude. It seems it just needs a sprinkle of GADTs. )
15:27:11 <ski>   data Showable = Wrap (exists a. Show a *> a)
15:27:23 <ski>   Wrap :: (exists a. Show a *> a) -> Showable
15:27:29 <ski>   Wrap :: forall a. (Show a *> a) -> Showable
15:27:34 <ski>   Wrap :: forall a. Show a => a -> Showable
15:27:44 <ski>   data Showable = forall a. Show a => Wrap a
15:27:57 <ski> that should explain how to encode `*>', using this encoding
15:28:22 <ski> i also emphasize that this is *one* encoding of existentials (and `*>')
15:28:39 <ski> there's also another one, which is sometimes to be preferred .. but another day :)
15:28:53 <ski> i end with a slightly more complex example of an existential
15:29:30 <ski>   data QueueOps a = forall q. MkQO q (a -> q -> q) (q -> Maybe (q,a))
15:29:51 <ski> `QueueOps a' encodes `exists q. (q,a -> q -> q,q -> Maybe (q,a))'
15:29:56 <ski> the signature in this case is
15:30:17 <ski>   MkQO :: forall a q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
15:30:25 <ski> note how `a' is mentioned in the result type, but not `q'
15:30:36 <dminuoso> Yup. I had the exact same thought before you said it.
15:30:43 <dminuoso> Seems pretty straight forward.
15:30:51 <ski> a value of type `QueueOps a' represents an implementation of queues with elements of type `a'
15:30:57 <dminuoso> (The only complex thing about is just random noise)
15:31:23 <ski> `q' is the hidden representation type. the first triple component is the empty queue. next follows the `enqueue' and `dequeue' operations
15:31:37 <ski> so, we can define
15:31:50 <ski>   folkloreQueue :: forall a. QueueOps a
15:32:08 <ski>   folkloreQueue = MkQO empty enqueue dequeue
15:32:10 <ski>     where
15:32:16 <ski>     empty = ([],[])
15:32:41 <ski>     enqueue a (front,revBack) = (a:front,revBack)
15:35:48 <ski>     dequeue (front,a:back) = Just ((front,back),a)
15:35:48 <ski>     dequeue (front,[    ]) = dequeue ([],reverse front)
15:36:34 <ski> but one could also consider a special-case implementation of type `QueueOps Int8', that used a more compact representation, say
15:37:21 <ski> er, `dequeue' there is not quite right, it should sometimes give `Nothing' of course. if you haven't seen it before, i leave it as an exercise to fix it
15:38:50 <ski> the idea is that a queue, if considered as a list `front ++ reverse revBack' (for an arbitrary such splitting), is represented as the pair `(front,revBack)' so that the queue containing `2',`3',`5',`7' could e.g. be represented with `([2],[7,5,3])', or with `([2,3],[7,5])'
15:39:01 <Gurkenglas> Feels to me like http://oleg.fi/gists/posts/2017-12-23-functor-optics.html should be used to implement lens, then be generalized to the full version once the user makes some additional import statement
15:39:14 <Gurkenglas> That way, error messages would be saner for beginners.
15:39:57 <ski> dminuoso : so .. i stop here. we can continue the discussion some later time, if you want
15:40:47 <dminuoso> ski: Id love to. My silence is mostly due to looking at your code and starting to wonder about things. Most has been very clear, a few edges are left but Ill be going through the logs tomorrow and get through that.
15:40:56 <dminuoso> Thanks a bunch for your input and help, it's very appreciated. :)
15:41:04 * ski bows
15:43:08 <phadej> Gurkenglas: error messages will still be horrible with that
15:43:40 <Gurkenglas> slightly less horrible? ._.
15:44:02 <EvanR> this is haskell. we do things slightly less horrible
15:46:06 <phadej> Gurkenglas: I haven't tried, but the same problem will persist, i.e. it won't say `Lens` but what the type-alias was
15:46:15 <phadej> ... in the error
15:46:52 <Gurkenglas> I suppose if that problem were fixed my idea would be superfluous
15:47:28 <Gurkenglas> Okay, how do we figure out what portion of ghc needs to be hacked upon to fix this?
15:49:54 <EvanR> you want error messages to always show the full expansion of a type synonym?
15:50:19 <Gurkenglas> No, to not unpack type synonyms unless necessary
15:50:22 <kakashiAL> Gurkenglas: da?
15:50:34 <ski> type error slicing would be interesting to experiment with
15:51:05 <Gurkenglas> Whichever place unpacks type aliases might be a good starting point? ski, why is this necessary?
15:52:03 <ski> why is what necessary ?
15:52:26 <phadej> it's not that GHC unpacks, it's more that in doesn't pack
15:52:41 <ski> a type error slicer would be interesting to use, to see how much it improves finding the source of type errors
15:52:54 <phadej> e.g. you try to match Lens with Prism, then it have to unpack poth to see whether they match, they don't, and GHC reports where they don't match
15:52:57 <ski> i'm talking about something along the lines of Skalpel, <http://www.macs.hw.ac.uk/ultra/skalpel/index.html>, but for Haskell
15:53:02 <phadej> a bit like hmm
15:53:02 <Gurkenglas> Irrespective of the lens situation? Agreed. The timing made me think you wanted to apply that to that
15:53:10 <phadej> > sum "foobar"
15:53:12 <lambdabot>  error:
15:53:12 <lambdabot>      • No instance for (Num Char) arising from a use of ‘sum’
15:53:12 <lambdabot>      • In the expression: sum "foobar"
15:53:26 <phadej> the String is gone ^
15:53:38 <phadej> but with lens it's much worse
15:54:20 <geekosaur> this is also a warning that "not unpack type synonyms unless necessary" trips over "it;'s necessary more often than you expect"
15:54:27 <ski> a type error slicer reports *all* locations that contribute to the type error (given the information available to the slicer, it still can't read your mind), and only those. as opposed to reporting the location where the inconsistency was *detected*
15:54:49 <geekosaur> also that ghc's typechecker tries really hard and will unpack any time there's a possibilityt hat will allow types to unify
15:55:16 <ski> at least one of these locations must be changed, to fix the type error
15:55:21 <geekosaur> which means almost always because it's exploring all possibilities
15:55:28 <Gurkenglas> :t lens -- that doesn't explain it unpacking this
15:55:30 <lambdabot> Functor f => (s1 -> a1) -> (s1 -> b1 -> t1) -> (a2 -> f b2) -> s2 -> f t2
15:55:56 <ski> (that Skalpel site has an online demo)
15:57:44 <ski> geekosaur : perhaps it could keep the unpacked version as well, and revert back to reporting using that, in case the unpacking didn't contribute to the type error
15:58:06 <geekosaur> what happens in that Num Char case?
15:58:32 <ski> that's a case where the unpacking *does* contribute to the error
15:59:25 <geekosaur> also it's keeping a lot of stuff along as it is, and keeping both a packed error *and* enough context to recognize when it's relevant will iirc complicate things more (ghc devs *have* discussed this, and periodically adjust things to try to improve the situation, but there's always some case that gets worse)
15:59:46 * ski nods
16:00:04 <geekosaur> do consider that people already complain about compile times... and most of that is already in the typechecker
16:00:17 <ski> aye
16:00:39 <ski> we can still imagine :)
16:00:45 <Welkin> compile times are never an issue for me
16:01:07 <EvanR> waiting for a proof that good error messages are equivalent to fixing the error for you, as a problem
16:01:11 <Welkin> only the initial setup of a project can take a while (to compile a yesod, or hakyll project)
16:01:26 <Welkin> but you only do that once
16:02:09 <Welkin> this is on an ultra-low voltage dual-core cpu
16:02:53 <EvanR> compiling lens on rpi takes a long time for me
16:03:05 <EvanR> an infinite time to be exact, since it runs out of memory first
16:03:07 <Welkin> anything will take a long time on a rpi
16:03:17 <EvanR> thats not true
16:03:25 <geekosaur> as I've mentuoned before, I'm actually a bit amused at complaints about slowness... because even the slow cases for ghc are far faster than compiling relatively simple C code 15 years ago (much less 35)
16:04:37 <geekosaur> it's all about context, my personal context includes memory of compiling things on 1MHz CPUs :)
16:04:39 <Welkin> there is always something people will complain about
16:04:47 <Welkin> whether it makes much of a difference or not
16:05:02 <phadej> Gurkenglas: that post had little motivation behind it, more like "you can do it this way too"
16:05:03 <EvanR> the curtains in here are awful
16:05:57 <Welkin> EvanR:  do they match the drapes?
16:06:05 <Welkin> what are drapes, anyway?
16:06:11 <Welkin> aren't they just curtains?
16:06:12 <EvanR> curtains
16:06:30 <Welkin> oh, yeah
16:06:41 <Welkin> I seem to have gotten that cliche wrong
16:06:54 <geekosaur> technically there's a slight difference, practically nobody cares unless they're in the business of designing them
16:06:54 <Welkin> it's "does the carpet match the drapes?"
16:21:08 <Gurkenglas> ski, how much effort would it be to implement type-error slicing? I am imagining a script that keeps adding the expected and actual types as signatures to the code and sees whether new errors pop up
16:21:45 <Gurkenglas> Will this find all errors or might it go in a loop before that?
16:21:58 <ski> i don't know
16:22:25 <ski> i think the algorithm in the paper was different
16:40:31 <ggVGc> how can I write this? https://gist.github.com/b84d1b708eccb204478fd397cf63128f
16:41:35 <grokkingStuff> Hi ggVGc
16:41:41 <grokkingStuff> what are you trying to do?
16:42:01 <grokkingStuff> data Foo = Foo {bar :: Foldable f => f Int -> String}
16:42:49 <Gurkenglas> ggVGc, see https://hackage.haskell.org/package/lens-4.15.4/docs/src/Control.Lens.Internal.Context.html#Pretext
16:44:49 <ggVGc> Gurkenglas: hm, yeah I wrote that at first, but figured there was a way that didn't require explicit forall and RankNTypes
16:44:55 <ggVGc> but I guess that's what I needed?
16:45:48 <ggVGc> well, Rank2Types
16:45:59 <ski> ggVGc : do you want a value of type `Foo' to contain a polymorphic function, polymorphic over any `Foldable' instance `f' ?
16:46:40 <ggVGc> yes
16:47:15 <ski> (if so, there's `PolymorphicComponent' for that. but i hear nowadays that enables the same extensions as `Rank2Types', rather than a more restricted on)
16:47:26 <Cale> ggVGc: Then the type of the data constructor will be rank 2 polymorphic, so yeah.
16:48:02 * ski would add an explicit `forall f. ' after the `::'
16:48:42 * ski would prefer a better term than "rank 2 polymorphic"
16:49:04 <ski> (hint : `Foo' is not polymorphic)
16:52:05 <Cale> Yeah, that's fair :)
16:52:06 <Gurkenglas> ggVGc, well if you find a better way make a PR to lens :P
17:43:46 <vaibhavsagar> is there a way I can make infix type constructors right-associative?
17:49:13 <vaibhavsagar> nvm, infixr works the same as it would for any other infix operator
18:01:54 <benzrf> haha
18:02:09 <benzrf> you can even use it on `backticked` functions
18:02:51 <benzrf> @let times = (*); plus = (*); infix 7 `times`; infix 6 `plus`
18:02:53 <lambdabot>  Defined.
18:03:01 <benzrf> > 3 `plus` 4 `times` 5 `plus` 6
18:03:04 <lambdabot>  error:
18:03:04 <lambdabot>      Precedence parsing error
18:03:04 <lambdabot>          cannot mix ‘plus’ [infix 6] and ‘plus’ [infix 6] in the same infix e...
18:03:10 <benzrf> ...woops >.>
18:03:27 <benzrf> odd
18:10:49 * hackage hasmin 1.0.1 - CSS Minifier  https://hackage.haskell.org/package/hasmin-1.0.1 (contivero)
18:13:20 <phadej> benzrf: infix vs infixr
18:13:43 <phadej> e.g. == is infix, so you cannot write a == b == c
18:13:55 <benzrf> woops
18:14:13 <ski> benzrf : it can't further disambiguate  3 `plus` (4 `times` 5) `plus` 6  because `plus' is neither `infixr' nor `infixl'
18:14:32 <benzrf> right :)
18:14:34 <benzrf> makes sense
18:16:30 <EvanR> lisp wins again (== a b c)
18:19:00 <ski> > 3 `plus` 4 `times` 5
18:19:04 <lambdabot>  60
18:20:00 <ski> oh, i suppose you defined them both as `(*)'
18:21:56 <ski> (perhaps `==' ought to be able to take a simply connected graph with nodes containing subexpressions ?)
19:28:32 <iqubic> What are we talking about?
19:29:42 <iqubic> I never bother with fixity, because I am rarely defining operators that are meant to be used infix.
20:11:19 <Gurkenglas> Anyone remember that alternative to lambda calculus which has strings going all over a 2D space and reduction happens via local rules?
20:13:17 <hoon> i'm still new to "laziness" and I don't really have a great feel for how it might help memory use. I have 2 versions of a function and I'm curious if one is better, particularly for very large files: http://lpaste.net/raw/361074
20:13:17 <ertes> conway's game of life?
20:16:13 <ertes> hoon: right away option A is terrible
20:16:28 <hoon> haha
20:16:32 <hoon> awesome
20:16:33 <hoon> ok
20:16:36 <ertes> hoon: even disregarding the problem of lazy input
20:17:03 <ertes> the problem there is sharing: if you have two traversals on a list that don't happen simultaneously, the list will actually be shared
20:17:15 <ertes> in other words 'contents' is going to end up in memory – in full
20:17:27 <hoon> that's what I figured
20:18:05 <ertes> hoon: the correct way to do this is to output and compute the length at the same time, which you tried to do in option B
20:18:20 <hoon> I think I succeeded in option b
20:18:28 <hoon> did I not?
20:18:47 <ertes> the idea of B is very good, but it fails regardless due to a misunderstanding in how Writer and laziness interact
20:19:01 <ertes> *WriterT
20:19:25 <hoon> I see
20:19:37 <hoon> well, I don't see, but I'm willing to see :)
20:20:00 <ertes> the problem is that you will be building up an expression
20:20:07 <ertes> 16 + 16 + 16 + 16 + …
20:20:25 <ertes> the correct way to do this is to use StateT or recursion
20:21:00 <ertes> with StateT you get the opportunity to evaluate the sum after every block
20:21:03 <mniip> umm wouldn't strict WriterT work
20:21:08 <ertes> nope
20:21:21 <mniip> (lazy StateT is susceptible to the same issues as lazy WriterT)
20:21:22 <ertes> strict WriterT is only strict in the tuple, not in the actual log value
20:21:28 <mniip> oh
20:21:32 <ertes> lazy StateT would work here
20:21:50 <hoon> before we go on to discuss StateT
20:22:01 <hoon> the 16 + 16 + 16 + 16 ... problem
20:22:50 <hoon> am I only carrying around the memory for the Sum? or would I be carrying around the 16 byte arrays of the contents of the file, too?
20:23:29 <ertes> hoon: i think the blocks are fine (and they are lists, not arrays – arrays are something different in haskell)
20:23:46 <hoon> oops -- sorry
20:23:50 <hoon> yeah lists
20:24:36 <ertes> hoon: there are a bunch of interactions going on here, and if you're a beginner it can be daunting at first, but fortunely they are all fairly easy to explain
20:24:53 <ertes> hoon: first of all do you know how to use IO without do-notation?
20:25:10 <hoon> I'm new to Haskell, though I dabbled briefly years ago
20:25:34 <hoon> I'm understanding better, but it always seems like there's something new to learn
20:25:57 <hoon> so discussions of "strictness in tuples" ...etc is a bit daunting, yes :)
20:26:23 <hoon> ertes: you mean IO via (>>=) and (>>) ?
20:26:35 <ertes> yeah
20:26:49 <hoon> yes
20:26:55 <ertes> hoon: the first thing to understand is how the run-time is strict in IO actions, because only IO can cause evaluation
20:26:56 <hoon> I think I can manage that
20:27:47 <ertes> example:  main = x `seq` pure ()  -- do you see why 'x' will be evaluated here?
20:29:07 <hoon> one sec
20:33:21 <hoon> so, yes
20:33:33 <hoon> x has to be evaluated -- based on the description of seq
20:33:51 <hoon> if x is not bottom implies that it has to check that first
20:33:56 <hoon> and thus evaluate x
20:34:05 <ski>   main = evaluate x >> pure ()
20:34:26 <ertes> hoon: (x `seq` y) is really y, but whenever y is evaluated, x is evaluated first
20:34:26 <ski> @type evaluate
20:34:27 <lambdabot> a -> IO a
20:34:47 <ski> (s/first/also/)
20:34:49 <ertes> hoon: so far you have established that 'x' will be evaluated, *if* (pure ()) is evaluated
20:36:14 <hoon> and you're implying that x must be evaluated even if (pure ()) is not?
20:36:21 <ertes> hoon: the question is: is 'x' evaluated?  i gave the answer away, so a related question is: *why* is 'x' evaluated?  which boils down to: why is (pure ()) evaluated?
20:36:40 <hoon> ha
20:36:59 <ertes> hoon: can you think of a reason?
20:37:46 <ertes> hoon: imagine that IO is a language, and running a program really amounts to running an IO interpreter on 'main' that performs all the effects of 'main'
20:38:30 <hoon> I guess my assumption would be that because main's type is IO ()
20:38:49 <hoon> that must mean that pure () has to be evaluated
20:39:09 <ertes> hoon: nah, way simpler:  running the program means performing the 'main' action, right?  so the run-time first needs to figure out what the 'main' action actually is
20:39:17 <ertes> it needs to look at (pure ())
20:39:18 <ski>   nonMain = z `seq` pure ()  -- is `z' evaluated ?
20:39:58 <ertes> it needs to evaluate (pure ()) in order to know what it has to run
20:40:45 <ski> (conceptually, first comes evaluation of the I/O action, then execution. in practice, these two processes are interleaved, starting with evaluation)
20:41:19 <hoon> i don't think it has really clicked for me, I'm sorry to say
20:41:52 <hoon> evaluation doesn't imply execution in this case?
20:42:35 <ertes> hoon: it's as ski says:  the run-time first looks at an opaque 'main' value
20:42:55 <ertes> but in order to execute the action that 'main' describes it has to evaluate that value
20:42:58 <ski> with the `main' given before, `nonMain' is not made a part of `main', so evaluating and executing `main' will not imply evaluating and executing `nonMain' (and so `z' is not evaluated)
20:43:06 <ertes> but we have this:  main = x `seq` pure ()
20:43:12 <ski> (unless evaluating `x' causes evaluation of `z', of course)
20:43:18 <ertes> which means: evaluating 'main' causes evaluation of 'x' as a side effect
20:43:39 <EvanR> wwwwhat
20:43:57 <EvanR> haskell abhors side effects
20:44:14 <hoon> interesting ok
20:44:25 <ertes> hoon: did that make sense?
20:44:35 <hoon> certainly more than before
20:44:38 <ski> (the `main' I/O action is a "recipe" for interaction with the operating system (and through it, the outside world). to be able to follow the recipe, it must first determine *what* the recipe says (so, evaluation), then execution can follow)
20:44:55 <hoon> I definitely follow the "nonMain" approach ski mentioned
20:45:23 <hoon> ok, I think that follow-up from ski helps
20:47:04 <hoon> somehow I feel like we're a long way away from addressing the problems with option B ;)
20:47:07 <hoon> i'm ok with that
20:47:14 <ertes> hoon: good, now look at this:  main = putStrLn "A" >> (x `seq` putStrLn "B")
20:47:16 <ski> "evaluation doesn't imply execution in this case?" -- evaluation never causes execution. it's the other way around : to be able to execute, evaluation is first triggered
20:47:58 <ski> (to be able to *do*, we must first determine *what* to do)
20:48:18 <ertes> hoon: at any instant haskell's run-time is only strict in the *next* action
20:48:46 <ertes> A will be printed, then x will be evaluated, then B will be printed
20:48:53 <hoon> I see
20:48:53 <hoon> ok
20:48:59 <hoon> interesting
20:49:07 <ertes> that's also why something like this works:  main = putStrLn "Hello" >> main
20:49:31 <ertes> haskell needs to evaluate 'main' lazily while performing the effects
20:49:56 <ertes> evaluate → execute → evaluate → execute → …
20:49:57 <ski> > let ones = 1 : ones in ones -- something similar
20:49:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:51:44 <ski> (that `main' is an "infinite recipe", similar to that infinite list. we can also have branches in our "recipe", giving us a tree. e.g. `getChar >>= \c -> ..c..' conceptually has one branch for every possible value of `c' that `getChar' could deliver. remember that `..c..' can determine different actions to continue with, depending on what `Char'acter `c' is)
20:51:44 <hoon> quetion:
20:52:03 <hoon> so in the case main = putStrLn "HELLO" >> main
20:52:24 <ski> (only one of these branches will be taken here, though. we're not exploring the whole potential "recipe tree")
20:52:32 <hoon> that obviously is an infinite loop of "HELLO"...
20:52:49 <hoon> but I don't see why the evaluate -> execute process makes that possible
20:52:55 <ertes> hoon: so at first the action is totally opaque, right?  so the run-time sees this:  main = _
20:53:10 <ertes> it asks for the value, and gets to see this:  main = _c >> _d
20:53:10 <hoon> right
20:53:18 <ertes> but at this point the run-time is only interested in _c
20:53:31 <ertes> so it evaluates further and sees this:  main = putStrLn "Hello" >> _d
20:53:35 <hoon> still with you
20:53:43 <ertes> now it knows what effect to execute, and it does so
20:54:00 <ertes> after that it's no longer interested in the first action, so it sees this:  _d
20:54:12 <ertes> then this:  _d1 >> _d2
20:54:19 <ertes> then this:  putStrLn "Hello" >> _d2
20:54:21 <ertes> etc.
20:54:30 <hoon> ok
20:54:45 <hoon> ok that seems intuitive enough to me
20:55:55 <ertes> some effects cause evaluation by themselves…  for example if you have (putStrLn str), then when that action is executed, it will have to evaluate 'str' as a side effect
20:56:33 <hoon> got it
20:56:40 <ertes> just like the run-time itself needs to know what action to execute next, (putStrLn str) needs to know what string to print
20:57:05 <ski> so, to execute an I/O action `_c >> _d', first evaluate `_c', then execute the resulting "recipe" (ignoring the delivered result). then continue by behaving as when executing `_d' (which first requires evaluating it, to determine the "general primitive shape" of it)
20:57:11 <ertes> now imagine you have a loop:
20:57:21 <ertes> f x = putStrLn "Hello" >> f (x + 1)
20:58:35 <ertes> if you execute f 0 the run-time sees (putStrLn "Hello" >> _next), and after printing it finds out that _next = f (0 + 1)
20:58:48 <ertes> now it can evaluate (f (0 + 1)) without actually asking for the result of (0 + 1)
20:59:01 <ertes> and this continues recursively
21:00:23 <ertes> however, if you do this:  f' x = x `seq` putStrLn "Hello" >> f' (x + 1)
21:01:03 * ski . o O ( `($!)' )
21:01:30 <ertes> now the run-time looks at (f' 0) and first sees this completely opaque _
21:01:56 <hoon> I see
21:01:58 <ertes> as soon as it evaluates _ it causes 0 to be evaluated and gets:  putStrLn "Hello" >> _next
21:02:27 <ertes> after execution it looks at (_next = f (0 + 1))
21:03:02 <ertes> as soon as it evaluates that it causes 0 + 1 to be evaluated, after which it sees:  putStrLn "Hello" >> f (1 + 1)
21:03:07 <hoon> right
21:03:20 <hoon> I follow
21:04:09 <ertes> in other words: the way to keep laziness in control is to understand when the run-time evaluates the next action, and which IO actions evaluate something
21:04:35 <ertes> digging through the WriterT layer to understand why it doesn't quite work would be the next step
21:04:52 <ertes> but a high-level explanation is: because nothing ever asks for the running sum
21:05:11 <ertes> by "nothing" i mean: neither the run-time, nor any individual action
21:05:26 <hoon> rght
21:05:56 <hoon> and since there's no way to really "ask" a writer, that's why you suggested the StateT
21:05:57 <hoon> ?
21:06:05 <ertes> correct
21:06:10 <hoon> because by "get" ting it
21:06:14 <hoon> I'm evaluating it
21:06:23 <ertes> no, that's not enough
21:07:01 <ertes> but there is an actual "current value" (WriterT doesn't really have that notion), and you can force its evaluation by introducing a data dependency like above
21:07:04 <hoon> I guess getting alone wouldn't work
21:07:18 <ertes> do x <- get; x `seq` pure ()  -- simple example
21:07:28 <hoon> right
21:07:43 <hoon> but probably more like: do x <- get; put (x + 16)
21:07:57 <ertes> that doesn't force
21:08:01 <hoon> ahah
21:08:09 <hoon> yeah
21:08:27 <hoon> I started to have that doubt after I said it
21:08:46 <ertes> if you use strict StateT you can just use modify'
21:08:53 <ertes> modify' (+ 16)
21:09:34 <ertes> if you use lazy StateT you need to introduce a IO-level dependency:  x <- gets (+ 16); put $! x
21:09:35 <hoon> and under the cover's that's effectively do x <- get; x `seq` put (x + 16)
21:09:43 <ertes> where (f $! x) = x `seq` f x
21:09:59 <hoon> ok, I was going to ask about $!
21:10:04 <hoon> I saw ski mention it
21:10:13 <ertes> it's just a handy short-cut
21:10:28 <waterdrop> https://wiki.haskell.org/Lifting - Why does fmap here have type Functor f => (a -> b) -> (f a -> f b)?
21:10:41 <ertes> basically you need to give the run-time a reason to evaluate it:  'seq' on the next action is a reason
21:10:53 <ski> waterdrop : as opposed to ?
21:10:58 <waterdrop> Shouldn't it have type (a -> b) -> Pair a a -> Pair b b
21:11:26 <hoon> ok
21:11:27 <ertes> waterdrop: fmap :: (a -> b) -> Pair c a -> Pair c b
21:11:49 <ertes> waterdrop: f = Pair c
21:12:08 <hoon> I certainly have a better feel for evaluation or lack there of
21:12:33 <hoon> but I'm sure that it's entirely not entirely sunk in
21:12:37 <ski> waterdrop : that's the general type of `fmap'. in the case where `f = Pair c' (the instance written there), you get the specialized signature that ertes mentioned
21:12:44 <waterdrop> ertes: But their definition of Pair has a constructor that requires both args to have the same type?
21:12:51 <waterdrop> So how can it be Pair c a?
21:13:05 <hoon> case in point: just assuming that get followed by put would cause the evaluation
21:13:21 <ski> oh, sorry. then it becomes `fmap :: (a -> b) -> Pair a -> Pair b'
21:13:21 <ertes> waterdrop: that's just me not actually opening the page =)
21:13:22 <hoon> I think I just have to really slow down and break things dow
21:13:31 <ertes> waterdrop: in that case yeah, what ski said
21:13:36 <ertes> f = Pair
21:13:57 <ski> (you said `Pair a a' and `Pair b b', but that's kind errors. (the *type* constructor) `Pair' only takes one type argument, not two)
21:14:21 <waterdrop> Okay, what ski said makes sense to me.
21:14:25 <waterdrop> ertes, what do you mean f = Pair?
21:14:34 <ski> waterdrop : it might be easier to understand, if you rename the *data* constructor `Pair' to `MkPair', as in `data Pair a = MkPair a a'
21:14:54 <ertes> hoon: it always boils down to this, and yes, transformer layers can make this more obscure, but you can always just undo the transform and look at what you really get
21:15:00 <waterdrop> ski: I understand why the type sig for the instance of fmap there is (a -> b) -> Pair a -> Pair b
21:15:07 <waterdrop> I just don't understand the next line
21:15:14 <ski> the type constructor lives in the type world. the data constructor lives in the value world. these are separate worlds. do not confuse them
21:15:26 <waterdrop> "If you look at the type of fmap (Functor f => (a -> b) -> (f a -> f b)), you will notice that fmap already is a lifting operation: It transforms a function between simple types a and b into a function between pairs of these types."
21:15:27 <ski> the next line being ?
21:15:38 <waterdrop> Are they talking about some different instance of fmap?
21:15:46 <hoon> and by undo the transform, you mean look at the source for the transformer?
21:15:48 <waterdrop> ertes: What do you mean by f = pair?
21:15:55 <hoon> or something more obvious?
21:16:43 <ertes> waterdrop: ((Functor f) => (a -> b) -> f a -> f b) is the type of 'fmap' – if you use 'fmap' you can choose any 'f' you wish, as long as it has a Functor instance, e.g. f = Pair
21:17:13 <ertes> if you use 'fmap' with f = Pair, you use it as if its type were this:  fmap :: (a -> b) -> Pair a -> Pair b
21:17:23 <ski> waterdrop : the general type of `fmap' (given in `class Functor f where ...', except the `Functor f =>' isn't explicitly written there) is `Functor f => (a -> b) -> f a -> f b'. in the `instance Functor Pair where ...' part, the type of the `fmap' that we define there is the one we get by setting `f' equal to `Pair'
21:17:27 <ertes> hoon: exactly that
21:17:29 <ski> @src Functor
21:17:29 <lambdabot> class Functor f where
21:17:29 <lambdabot>     fmap :: (a -> b) -> f a -> f b
21:18:13 <hoon> ok
21:18:38 <hoon> any recommendations on where to read up on the evaluation process for Haskell?
21:18:55 <hoon> in case I feel like this conversation hasn't/won't stick
21:19:02 <ski> @where lazy
21:19:02 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
21:19:11 <ski> for *evaluation*, perhaps
21:19:17 <ski> (not execution)
21:19:29 <waterdrop> ertes: I understand that. How is that an example of lifting though? It seems like that's just saying that Pair implements the functor typeclass?
21:19:39 <hoon> thank you ski
21:20:02 <ertes> waterdrop: the type signature of 'fmap' can be read like this:  fmap :: (Functor f) => (a -> b) -> (f a -> f b)
21:20:08 <ertes> it's the same type
21:20:11 <ski> (that's written by monochrom)
21:20:45 <ertes> waterdrop: but it expresses a different idea:  'fmap' is not a function of two arguments that maps the function over its second argument, but it takes a function and 'lifts' it
21:20:50 <waterdrop> ertes: ohh
21:20:57 <waterdrop> okay, now that makes sense.
21:21:11 <waterdrop> I didn't see that that was what they were saying. thanks
21:22:17 <ertes> waterdrop: note that "lifting" is a somewhat vague concept, and there are a number of instances of it…  but they all have to do with "changing the context"
21:22:27 <ertes> in this case going from (a -> b) to (F a -> F b)
21:22:35 <waterdrop> right
21:22:56 <ski> > fmap (fmap (fmap (^2)) [Just [0,1,2],Nothing,Just [3,4]]
21:22:58 <lambdabot>  <hint>:1:57: error:
21:22:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:23:09 <ski> > fmap (fmap (fmap (^2))) [Just [0,1,2],Nothing,Just [3,4]]
21:23:11 <lambdabot>  [Just [0,1,4],Nothing,Just [9,16]]
21:23:20 <ski> > (fmap . fmap . fmap) (^2) [Just [0,1,2],Nothing,Just [3,4]]
21:23:21 <lambdabot>  [Just [0,1,4],Nothing,Just [9,16]]
21:24:11 <hoon> thank you all very much for the help
21:24:20 <ski> we transform ("lift") the `(^2)' function, operating on `Integer's, three times, getting a function that operates on `[Maybe [Integer]]'s
21:24:32 <ski> @type fmap . fmap
21:24:34 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
21:25:28 <ski> > zipWith (zipWith (+)) [[1,2,3],[4,5],[6]] [[600,500,400],[300,200],[100]]
21:25:33 <lambdabot>  [[601,502,403],[304,205],[106]]
21:25:43 <ski> > (zipWith . zipWith) (+) [[1,2,3],[4,5],[6]] [[600,500,400],[300,200],[100]]
21:25:46 <lambdabot>  [[601,502,403],[304,205],[106]]
21:25:51 <ski> @type zipWith . zipWith
21:25:51 <hoon> thank you all very much for the help
21:25:53 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
21:26:10 <hoon> geez, I'm repeating myself!
21:26:14 <ski> that ^ is doing something similar, but for a function accepting two inputs
21:27:01 <ski>   zipWith :: ( a  ->  b  ->  c )
21:27:01 <ski>           -> ([a] -> [b] -> [c])
21:27:09 <ertes> i think the closest we have to a theoretical framework for "lifting" is natural transformations
21:27:19 * hackage ethereum-analyzer 3.3.1, ethereum-analyzer-deps 3.3.1 (zchn): https://qbin.io/1htaw12io
21:28:27 <ertes> there is probably a family of categories where 'fmap' is a natural transformation, too
21:28:45 <Gurkenglas> hoon :: (forall f a b. Functor f => (a -> b) -> f a -> f b) -> "thank you all very much for the help"
21:29:40 * ski . o O ( `forall a b. f (Either a b) -> Either (f a) (f b)' )
21:30:05 <mniip> that exists
21:30:20 <mniip> I'm pretty sure it does
21:30:32 * ski nods
21:31:25 <ertes> f (a + b) -> f a + f b
21:31:44 <ski>   (a -> b + c) -> (f a -> f b + f c)
21:32:23 <mniip> [exa], challenge idea: implement liftA3 with liftA2
21:34:22 <Gurkenglas> aah Distributive goes the wrong way but Traversable is obviously wrong what do i do
21:35:23 <Gurkenglas> I can do you t (a, b) -> (t a, t b) though? :(
21:35:29 <ski>   (forall c. (a -> c) -> (b -> c) -> f c) -> f a + f b
21:35:41 <mniip> Gurkenglas, that's costrength
21:35:44 <mniip> any haskell functor can do
21:35:49 <waterdrop> ski: When you lifted fmap three times earlier, how did it get lifted with the right "f" each time?
21:36:13 <mniip> waterdrop, "right f"?
21:36:44 <ski> waterdrop : type inference. the argument `[Just [0,1,2],Nothing,Just [3,4]]' had type `[Maybe [Integer]]', or with less syntactic sugar, `[] (Maybe ([] Integer))'. the three functors are `[]',`Maybe',`[]'
21:37:26 <mniip> > _ [Just [0,1,2],Nothing,Just [3,4]]
21:37:28 <ski> each `fmap' got told the appropriate type `f' that it should use
21:37:28 <lambdabot>  error:
21:37:28 <lambdabot>      • Found hole: _ :: [Maybe [Integer]] -> t
21:37:28 <lambdabot>        Where: ‘t’ is a rigid type variable bound by
21:37:37 <mniip> > fmap _ [Just [0,1,2],Nothing,Just [3,4]]
21:37:40 <lambdabot>  error:
21:37:40 <lambdabot>      • Found hole: _ :: Maybe [Integer] -> b
21:37:40 <lambdabot>        Where: ‘b’ is a rigid type variable bound by
21:37:41 <mniip> and so on
21:38:26 <waterdrop> ski: Ah I see
21:39:29 <ski> @type fmap . fmap . fmap
21:39:30 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
21:39:49 <Gurkenglas> mniip, *googles costrength* ekmett says no http://comonad.com/reader/2008/deriving-strength-from-laziness/ to "costrength ::"
21:39:54 <ski> the type `[Maybe [Integer]]' got matched with the argument type `f1 (f2 (f3 a))' here
21:40:50 <ski> if you prefer the `fmap (fmap (fmap (^ 2)))', then you can to explain it more step by step, peeling "functor layers" off the argument type, one by one
21:41:52 <Gurkenglas> Do we have a single f with "forall a b. f (Either a b) -> Either (f a) (f b)"? …
21:42:38 <ski>   f = (w,)  -- ?
21:42:41 <Gurkenglas> f=Const Void, I suppose.
21:43:03 <Gurkenglas> Ahyesthanks.
21:43:28 <ski> probably one can do something with lenses as well
21:43:47 <jle`> Gurkenglas: Bidistributive
21:44:23 <jle`> (suggested in jest)
21:44:50 <Gurkenglas> Ya, goes even further the wrong way
21:45:34 <mniip> Gurkenglas, Identity of course
21:45:37 <ski> perhaps one could find other interesting examples, if the category was changed
21:45:42 <ski> (to a kleisli one, e.g.)
21:45:44 <nshepperd> :t Left . contramap Left
21:45:45 <lambdabot> Contravariant f => f (Either a b1) -> Either (f a) b2
21:45:59 <Gurkenglas> mniip, subsumed by ((),) but yes ._.
21:46:17 <ski> (ditto for `(Void,)', fwiw, modulo bottoms)
21:46:58 <jle`> Gurkenglas: IO
21:47:14 <mniip> well any traversable could be upgraded to a biased bidistributive
21:47:15 <Gurkenglas> No.
21:47:21 <Gurkenglas> @jle`,
21:47:21 <lambdabot> Unknown command, try @list
21:47:37 <jle`> Gurkenglas: that's because IO has non-bottom inhabitants forall a. IO a
21:47:52 <jle`> same for Maybe/Proxy too then I suppose
21:47:55 <Gurkenglas> IO (Either a b) -> Either (IO a) (IO b)!?
21:47:55 <jle`> and list
21:48:01 <jle`> yeah
21:48:08 <jle`> i guess any type with non-bottom `forall a. f a`
21:48:15 <jle`> so Maybe, Proxy, [], IO
21:48:17 <Gurkenglas> Whence do you conjure the Left/Right bit?
21:48:28 <jle`> well the answer would have to ignore the input :)
21:48:40 <Gurkenglas> Which gets your case dismissed
21:49:04 <jle`> what sort of constraints are we applying here?
21:49:19 <jle`> this is the same situation as Const Void
21:49:42 <Gurkenglas> No, for Const Void we just say absurd and have no conjure no bits.
21:49:49 <Gurkenglas> *to conjure
21:50:22 <Gurkenglas> Or morally id, 0 = 0 + 0
21:51:05 <jle`> so the Left/Right choice if any has to depend on the input somehow?
21:51:21 <ski> perhaps `cozip . fmap Left = Left' ?
21:51:22 <Gurkenglas> On the Either, I'd gues
21:52:04 <jle`> so this rules out, say, const Nothing
21:52:05 <waterdrop> ski: Great, thanks for all the help!
21:52:13 <jle`> er, const (Left Nothing)
21:52:17 <Gurkenglas> yes
21:52:41 <ski> waterdrop : np
21:53:36 <mniip> :t \x -> either (const $ Left $ x >>= either (const mzero) return) Right $ sequenceA x
21:53:37 <lambdabot> (Traversable t, MonadPlus t) => t (Either b a) -> Either (t a) (t a)
21:53:43 <Gurkenglas> (I'm tempted to say that has type "forall a b. a -> Either (Maybe b) c" instead, but then Const Void is on thin ice... maybe it should be.
21:53:44 <mniip> oops
21:53:54 <mniip> :t \x -> either (const $ Left $ x >>= either  return (const empty)) Right $ sequenceA x
21:53:55 <lambdabot> (Traversable t, Alternative t, Monad t) => t (Either b a) -> Either (t b) (t a)
21:54:46 <mniip> that satisfies ski's law
21:55:21 <Gurkenglas> I don't like it, because intermediate cases all go to the left
21:55:32 <mniip> like I said
21:55:34 <mniip> biased
21:56:33 <Gurkenglas> Ah missed that comment, though I'll claim to have seen that even earlier when I said traversable is wrong :P
21:56:35 <Gurkenglas> *obviously
21:56:48 <Gurkenglas> *is obviously wrong <.<
21:57:25 <nshepperd> :t Left . contramap Left :: Const r (Either a b) -> Either (Const r a) (Const r b)
21:57:27 <lambdabot> Const r (Either a b) -> Either (Const r a) (Const r b)
21:58:06 <Gurkenglas> If we want there to be exactly one Either a b from the left to provide a bit for the right side, that locks us down to (w,)
21:58:31 <Gurkenglas> :t Left . contramap Left
21:58:32 <lambdabot> Contravariant f => f (Either a b1) -> Either (f a) b2
21:59:27 <Gurkenglas> With (Void,) providing Const Void and ((),) providing Identity, that's all the neat cases?
21:59:44 <ski> (obviously the symmetric law should also hold :)
22:00:13 <ski> @djinn ((Either a b -> Cont o a) -> (f (Either a b) -> Cont o (f a)),(Either a b -> Cont o b) -> (f (Either a b) -> Cont o (f b))) -> f (Either a b) -> Cont o (Either (f a) (f b))
22:00:14 <lambdabot> f (a, b) c d =
22:00:15 <lambdabot>     b (\ e f ->
22:00:15 <lambdabot>        case e of
22:00:15 <lambdabot>        Left g -> b (\ _ _ ->
22:00:15 <lambdabot>                     a (\ h i ->
22:00:17 <lambdabot> [4 @more lines]
22:00:45 <mniip> @let cozipTraverse = \x -> either (const $ Left $ x >>= either return (const mzero)) Right $ sequenceA x
22:00:46 <lambdabot>  Defined.
22:01:30 <mniip> hmm
22:01:37 <mniip> what's a good candidate for a free monadplus
22:02:07 <mniip> Free [] ?
22:03:19 <jle`> it's difficult to talk about a free monadplus
22:03:25 <jle`> since the laws aren't even well-defined
22:03:27 <mniip> not it isn't
22:03:37 <jle`> there's a nice Free Alternative though in 'free'
22:03:41 <mniip> ah right, the laws relating the monoid to the monad
22:03:59 <pie__> hey guys, is there a recommended call-haskell-from-python library?
22:04:07 <jle`> even though i had some issues with it that made it unusable for me for a recent applications
22:04:18 <mniip> what's wrong with
22:04:43 <jle`> hm here's my SO question
22:04:44 <pie__> ah wait ok i found this, is this up to date? https://wiki.haskell.org/FFI_complete_examples#When_main_is_in_Python
22:04:46 <mniip> mzero >>= x = mzero = x >>= \_ -> mzero
22:04:47 <jle`> https://stackoverflow.com/questions/45647253/structurally-enforced-free-alternative-without-left-distributivity
22:05:05 <mniip> (a `mplus` b) >>= x = (a >>= x) `mplus` (b >>= x)
22:05:14 <jle`> mniip: the free alternative in Free has an extra law that isn't a part of the standard Alternative laws
22:05:22 <jle`> it's a *left-distributive* free alternative
22:05:27 <mniip> a >>= liftA2 mplus x y = (a >>= x) `mplus` (a >>= y)
22:06:54 <jle`> mniip: `mzero = x >>= \_ -> mzero` is not obeyed by most useful monadplus's
22:07:09 <mniip> there are useful monadpluses?
22:07:23 <jle`> ;)
22:07:29 <jle`> that's true, i mostly only use Alternative functionality
22:07:30 <mniip> oh hmm, is it the fact that x can induce an effect?
22:07:34 <jle`> yeah
22:07:43 <mniip> do you have an example?
22:08:10 <mniip> honestly I've never used MonadPlus for anything other than a nondeterminism monad
22:08:12 <jle`> MaybeT IO
22:08:26 <jle`> or MaybeT m with any noncommutative/effectful m
22:08:46 <jle`> yeah i usually actually don't use MonadPlus for anything other than search purposes
22:08:57 <jle`> i use a lot of Alternative though, so those laws don't really matter
22:09:19 <jle`> hm, actually I might have lied, I do rely on MaybeT m's MonadPlus instance pretty often
22:10:41 <jle`> hm i also rely on MonadPlus a bit for a few of my AoC's this year
22:11:05 <jle`> although i'm not sure if i'd characterize it more as MonadPlus or as Alternative
22:11:13 <nshepperd> Gurkenglas: also (a -> r, a)
22:11:17 <Gurkenglas> I use it lots with StateT s Maybe
22:11:28 <nshepperd> \case { Store (Left a) f -> Left (Store a (f . Left)); Store (Right b) f -> Right (Store b (f . Right)) }
22:11:36 <mniip> StateT s [] :D
22:12:14 <mniip> hmm
22:14:37 <Gurkenglas> nshepperd, neat
22:15:12 <jle`> hm, any other comonads, then?
22:19:46 <Gurkenglas> Contravariant c => (c a, a)?
22:21:19 <metahumor> StateT ([a],[a]) [] a is taking a long time for day24a
22:21:38 <jle`> try StateT [a] [] a
22:23:17 <metahumor> running it all in ghci probably doesnt help either
22:24:31 <Gurkenglas> ghci should be able to take your query and pay the overhead to compile and optimize it, run that, then come back and put the result into ghci
22:25:24 <vaibhavsagar> Gurkenglas: that would be pretty sweet
22:25:51 <metahumor> jle`: your version takes about 104 s on my machine for day24a
22:26:03 <vaibhavsagar> IHaskell has this nifty feature where you can define a module inline, and it writes it to a file and compiles it for you
22:26:34 <vaibhavsagar> so if you want to optimise a certain code path, it works pretty well
22:28:22 <mniip> idk I solved it in ghci in maybe 20 seconds
22:28:33 <mniip> I still have ghci open
22:30:29 <mniip> my session was pretty much http://lpaste.net/5211662751763529728
22:30:49 <mniip> (spoilers)
22:31:07 <metahumor> something is weird about my soln for day24a, i'm getting an almost right answer for actual input (its 7 less than what it should be)
22:31:08 <metahumor> http://lpaste.net/361075
22:32:30 <metahumor> but it's right for the test input
22:35:39 <vaibhavsagar> metahumor: it looks like you're not swapping (x,y) if that would make the connections work
22:36:25 <vaibhavsagar> e.g. 0/1 -> 10/1 -> 2/10 is valid, even though the ports are on different sides
22:36:38 <vaibhavsagar> because each port is used only once
22:38:33 <glguy_> I see swapping logic for the non zero case, but the initial case looks like it forgets to potentially swap. I'm guessing that's not the issue though
22:39:18 <aku> What is the difference between writing f = (++ "foo") and f = (++) "foo" ?
22:39:31 <aku> One appends and other prepends strings
22:39:44 <ski> `(++ "foo")' is `\s -> s ++ "foo"'
22:40:09 <ski> `(++) "foo"' is `("foo" ++)' is `\s -> "foo" ++ s'
22:40:38 <ski> `(++) "foo" s' is `"foo" ++ s'
22:41:55 <aku> The second one is clear to me, but for (++ "foo"), is that we have provided the second arguement?
22:43:28 <aku> I can write ((++) "foo" . (++) "bar") but not (++ "foo" . ++ "bar)
22:44:52 <vaibhavsagar> aku: it's the difference between ("foo" ++) and (++ "foo")
22:45:23 <vaibhavsagar> the former is equivalent to ((++) "foo")
22:45:37 <vaibhavsagar> and the latter to (flip (++) "foo")
22:45:42 <ski> you can write `(++ "foo") . (++ "bar")'
22:45:45 <aku> So for composition I should write (++ "foo") . (++ "bar")
22:45:48 <aku> Yes
22:45:51 <ski> > ((++ "foo") . (++ "bar")) " "
22:45:54 <lambdabot>  " barfoo"
22:46:01 <ski> > (("foo" ++) . ("bar" ++)) " "
22:46:03 <lambdabot>  "foobar "
22:46:06 <ski> > (("foo" ++) . (++ "bar")) " "
22:46:08 <lambdabot>  "foo bar"
22:46:13 <ski> > ((++ "foo") . ("bar" ++)) " "
22:46:15 <lambdabot>  "bar foo"
22:46:51 <metahumor> glguy_: thanks, that's what i was missing
22:47:00 <aku> I see
22:47:10 <ski> compare with how `(5 /)' means to divide `5' by something, while `(/ 5)' is dividing by `5'
22:47:41 <aku> But in terms of type signature what does it mean?
22:47:55 <ski> in the former, the first/left (numerator/dividend) argument is suppled. in the latter, the second/right (denominator/divisor) argument is supplied
22:48:14 <aku> Both types look the same
22:48:22 <ski> in terms of type signature, what does what mean ?
22:48:30 <ski> if yuo have an operator with signature
22:48:44 <ski>   (+/) :: A -> B -> C
22:48:48 <ski> and arguments
22:48:50 <ski>   x :: A
22:48:53 <ski>   y :: B
22:48:54 <ski> then
22:48:58 <ski>   x +/ y :: C
22:49:05 <ski>   (+/) x y :: C
22:49:14 <ski>   (+/) x :: B -> C
22:49:19 <ski>   (x +/) :: B -> C
22:49:24 <ski>   (+/ y) :: A -> C
22:49:50 <aku> Ohh.. yes the last one
22:49:58 <ski> also
22:50:17 <ski>   (\b -> x +/ b) :: B -> C
22:50:25 <ski>   (\a -> a +/ y) :: A -> C
22:50:52 <aku> Yep got
22:51:27 <mniip> :t (() `?f`)
22:51:28 <lambdabot> error: parse error on input ‘?f’
22:51:38 * ski :/
22:51:40 <mniip> :t let f = ?f in (() `f`)
22:51:41 <lambdabot> (?f::() -> t) => t
22:51:55 <mniip> that's an extension isn't it
22:52:03 <ski> i think so
22:52:29 <mniip> haskell98/2010 says it should be (?f :: () -> a -> b) => a -> b
22:52:31 <ski> (just like `do x' not requiring `x' having a type of shape `m a')
22:55:49 * hackage yesod-auth-hmac-keccak 0.0.0.4 - An account authentication plugin for yesod with encryptedtoken transfer.  https://hackage.haskell.org/package/yesod-auth-hmac-keccak-0.0.0.4 (nek0)
23:09:18 <POGtastic> i really, really need to learn functors. "concatMap a lambda that maps a recursive call" is making my brain overheat. https://pastebin.com/KhWkip2R
23:15:26 <ski> POGtastic : that doesn't seem to use any functor concept, just `map' and `concatMap' on lists, and a recursive call inside a callback
23:16:01 <POGtastic> i thought that a functor would somehow diminish the amount of nested weirdness that occurs there
23:19:36 <ski> hm, not much really, i think
23:20:05 <POGtastic> to be fair to haskell, i don't think that problem would have been fun to do in *any* language
23:21:08 <ski> i suppose one could generalize one of the `[]'s, using `MonadPlus' or `Alternative'
23:21:29 <ski> that might make it look a bit less confusing, with less `[]' levels to confuse
23:21:58 <ski> `([ys] ++)' can of course be simplified
23:24:04 <POGtastic> yeah, that felt ugly when writing it. what's an elegant way to prepend every list with a list?
23:26:04 <ski> what is `group [1,1] "abc"' supposed to give ?
23:26:17 <ski> @src (++)
23:26:17 <lambdabot> []     ++ ys = ys
23:26:17 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
23:26:17 <lambdabot> -- OR
23:26:17 <lambdabot> xs ++ ys = foldr (:) ys xs
23:26:33 <ski>      [x] ++ ys
23:26:43 <ski>   =  (x:[]) ++ ys
23:26:57 <ski>   =  x:([] ++ ys)
23:27:03 <ski>   =  x:ys
23:27:21 <ski> so, `([x] ++)' is `(x :)'
23:27:29 <POGtastic> the problem doesn't say what happens when you give it a list of numbers that don't add up to the length of the list of members
23:27:41 <POGtastic> good point
23:28:15 <POGtastic> i'd originally done (ys:) on a previous function, got a bunch of compilation errors, changed that, still got errors, fixed the *actual* problem, and didn't change it back.
23:29:02 <ski> i think it should give the empty list (meaning : no solutions), when the sum of the numbers doesn't equal the list length
23:30:26 <ski> because for each solution (each element of the result list), the lengths of the element lists in that solution ought to match the given list of lengths
23:31:12 <ski> and if it doesn't add up, then there's no possible way of partitioning up the original element list. so no solutions, empty result list
23:31:53 <ski> (no possible way of partitioning up, according to the class cardinalities (the lengths) given)
23:34:41 <ski> the  combinations' k as  are counted by  binomial (length as) k  (in math syntax, given `n = length as', this is written `P(n,k)' or `n P k')
23:35:13 <POGtastic> so like this? https://pastebin.com/8xfX6iiL
23:35:43 <POGtastic> `group [] _` is "Hey, I'm out of groups to put people into, but I still have people."
23:35:45 <ski> (`P(n,k)' is `n ! / (k ! * (n-k) !)')
23:36:04 <metahumor> combinations will freak out if the Int is < 0
23:36:41 <POGtastic> i would have to error it out anyway, it's kinda weird to have a negative number of elements :)
23:36:51 <ski> the  group ks as  are counted by  multinomial (length as) ks  (in mathy syntax, `n ! / Product_{k <- ks} k!', here we should have `n = Sum_{k <- ks} k')
23:37:17 * ski reconsiders whether it makes sense to give zero solutions (rather than an error)
23:38:11 <metahumor> it depends how the groups would be consumed later on, imo
23:38:41 <metahumor> perhaps wrap solutions in a Maybe?
23:38:42 <POGtastic> scratch that, we also need `group _ [] = []' to return 0 solutions when we have too few persons to fill the lists
23:38:58 <POGtastic> so https://pastebin.com/SFNsAsX7
23:40:21 <POGtastic> so with Maybe, we'd return Just [[[a]]] if we got valid input or Nothing if we got invalid input?
23:41:27 <POGtastic> i'd probably want to turn that wonderful-looking lambda into another function if i did that
23:42:14 <ski> are all the lengths positive ?
23:42:48 <POGtastic> i'd hope so, as getting negative lengths of a list would be bad
23:42:56 <POGtastic> this function definitely won't handle it
23:43:00 <POGtastic> as metahumor pointed out
23:44:21 <ski> hm, i think it still makes sense to give an empty list
23:46:09 <POGtastic> i could use guards or a case statement to check for negative numbers, like so: https://pastebin.com/8wK3fGh1
23:46:27 <ski> `group ks as' is basically constructing a list of all functions from `as' to `length ks', such that the number of elements in `as' that the function maps to `i' (with `0 =< i < length ks') is `ks !! i'
23:47:02 <ski> (i consider the natural number `length ks' here as the set of all natural numbers less than it)
23:47:35 <ski> and in case `sum ks' doesn't equal `length as', there's simply zero such functions. so getting an empty list then is reasonable
23:47:58 <ski> POGtastic : well, the question was whether any of the lengths/sizes could be zero
23:48:45 <ski> because then `guard [0] []' should be `[[[]]]', not `[[]]' or `[]'
23:49:46 <POGtastic> good point. after all, you can fit 0 people into a group of 0
23:50:14 <POGtastic> and right now, group [2, 3, 4, 0] on a group that contains 9 people will return []
23:50:38 <ski> but perhaps you could arrange for  group  to defer this case to  combinations'  which seems to be handling it right
23:51:50 <ski> (in case you don't allow group sizes to be zero, then we're talking about surjections, and not just any functions. and surjections correspond to equivalence relations, which are nice)
23:56:49 * hackage bittrex 0.2.0.0 - API bindings to bittrex.com  https://hackage.haskell.org/package/bittrex-0.2.0.0 (DavidJohnson)
23:59:49 <dmj`> jle`: chuckled when I read “The Phantom Menace” title in your singletons blog post. Very timely given the new Star Wars.
23:59:56 <POGtastic> alright, i'm happy with this. https://pastebin.com/FfAqnMEe
