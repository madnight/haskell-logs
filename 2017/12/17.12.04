00:08:56 <Gurkenglas-> :t (\a -> swapped . aside (only a) . iso fst (,())) :: Eq a => a -> Prism' (a, b) b -- meh
00:08:57 <lambdabot> (Applicative f, Choice p, Eq a1) => a2 -> p b (f b) -> p (a1, b) (f (a1, b))
00:11:22 * hackage g4ip-prover 0.1.0.1 - Theorem prover for intuitionistic propositional logic using G4ip  https://hackage.haskell.org/package/g4ip-prover-0.1.0.1 (klntsky)
00:13:35 <raynold> ahh it's a wonderful day
00:39:37 <ertes-w> hllo
00:47:20 <jle`> hwdy
00:53:37 <cocreature> is there any pretty-printing library that can handle side-by-side placement of multi-row content?
00:57:56 <daey> how does haskell abstract pure functions from impure actions? From my understanding every IO action should return a "maybe" type. but that doesn't seem to be the case?
00:58:17 <ertes-w> cocreature: there is the 'boxes' library, but it's not a fully fledged pretty-printing library…  you can combine it with something like wl-pprint*
00:58:21 <jle`> daey: what do you mean by abstract pure functions from impure actions
00:58:38 <jle`> daey: and what do you mean when you say that very IO action should return a "maybe" type
00:59:06 <ertes-w> daey: functions and IO actions are completely unrelated
00:59:38 <jle`> an 'IO a' describes an IO computation that could produce an 'a', but not necessarily
00:59:50 <jle`> the "maybeness" is baked into the semantics of IO
00:59:54 <daey> ah ok
01:00:06 <ertes-w> daey: an IO action is just a value…  picture it being a piece of text that describes a real-world effect
01:03:36 <peter90> How do I apply sortOn on the type [(Word, Int)] to sort the list using the second value in the tuple?
01:03:55 <koz_> :t sortOn
01:03:56 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
01:04:15 <koz_> peter90: 'sortOn' snd seems like what you want.
01:04:39 <koz_> peter90: 'sortOn snd' rather.
01:05:42 <cocreature> ertes-w: perfect, thanks!
01:09:24 <peter90> koz_: I don't know how to properly apply it, wordSort xs = sortOn (snd xs) xs does not work
01:10:02 <peter90> koz_: nevermind I'm stupid, I got it
01:10:05 <koz_> peter90: Look at the type carefully. 'sortOn' expects a function that turns a into b.
01:10:05 <peter90> thanks
01:10:08 <koz_> Lol, no problem.
01:11:42 <koz_> > sortOn snd [("foo", 10), ("bar", 1)]
01:11:44 <lambdabot>  [("bar",1),("foo",10)]
01:13:52 <koz_> :t iso
01:13:53 <lambdabot> (Functor f, Profunctor p) => (s1 -> a1) -> (b1 -> t1) -> p a2 (f b2) -> p s2 (f t2)
01:14:15 <koz_> No, wait, what's the s t a b -> b a t s thing from Data.Lens.Iso?
01:15:42 <koz_> :t from
01:15:43 <lambdabot> (Functor f, Profunctor p) => AnIso s1 t1 a1 b1 -> p t2 (f s2) -> p b2 (f a2)
01:16:04 <koz_> Darn, it unrolls the type.
01:46:04 * hackage Cabal 2.0.1.1 - A framework for packaging Haskell software  https://hackage.haskell.org/package/Cabal-2.0.1.1 (MikhailGlushenkov)
02:57:36 <saurabhnanda> can `stack` be used as a library? For example, if I need to find out the build directory and location of .hi files via stack, can I do that programmatically?
03:02:42 <saurabhnanda> am I missing something or is `stack` itself not on `stackage`? 
03:04:29 <osa1> saurabhnanda: https://www.stackage.org/lts-9.14/package/stack-1.5.1
03:04:45 <saurabhnanda> so, not in LTS-9 it seems
03:06:54 <cocreature> osa1 just showed you a link to the version that’s in lts-9 …
03:12:22 <saurabhnanda> cocreature: lts-9.0 vs lts-9.14
03:20:30 <pgiarrusso> saurabhnanda: Stack is not designed for use as a library.
03:21:16 <pgiarrusso> saurabhnanda: Any chance you want to use the Cabal library, maybe inside the environment provided by Stack exec?
03:22:07 <pgiarrusso> If not, you could file an issue, I’m sure other devs could mention ideas
03:23:25 <saurabhnanda> I'm trying to find a list of all HI files in a particular project. Can cabal help me with that?
03:25:31 <osa1> why not `find <project_dir> -name "*.hi"`
03:27:10 <pgiarrusso> saurabhnanda: OK, related requests: https://github.com/commercialhaskell/stack/issues/3522#issuecomment-339989263, but “stack as a library” seems rather unpopular
03:28:23 <pgiarrusso> saurabhnanda: wait, can you say more about your final goal? I’m sure cabal can help you somehow, but the best approach depends on your goal
03:28:49 <pgiarrusso> Also, why not just osa1’s idea, indeed
03:29:15 <rmg> hi
03:30:18 <brynedwards> hello
03:32:40 <rmg> So I have this piece of Haskell code that used to work but for some reason doesn't anymore
03:33:05 * hackage proxy-mapping 0.1.0.0 - Mapping of Proxy Types  https://hackage.haskell.org/package/proxy-mapping-0.1.0.0 (DanielVanDenEijkel)
03:34:30 <rmg> http://lpaste.net/360492 These 2 lines used to work like a long time ago, when I revisited Haskell it just gives me an error
03:34:31 <siwica> Can functions also be polymorphic in the sense that they return only return a literal together with a typeclass?
03:34:49 <siwica> e.g. can I have a function returning (Num a) => a
03:34:57 <siwica> Instead of Int
03:35:16 <fakenullie> add :: (Num a) -> a -> a -> a
03:35:50 <siwica> I am asking this, because I was wondering why length does return Int
03:36:04 <fakenullie> because Int is appropriate for length of things on computer
03:36:06 <opqdonut> :t genericLength
03:36:08 <lambdabot> Num i => [a] -> i
03:36:11 <opqdonut> there ya go
03:36:26 <rmg> ?
03:36:26 <opqdonut> length returning Int is a combination of historical reasons and ease of use
03:36:44 <fakenullie> why not Integral  i?
03:37:08 <opqdonut> because it only needs Num?
03:37:31 <fakenullie> well, makes sense if you to divide by length
03:37:51 <dibblego> length = map (const ())
03:37:52 <liste> siwica: note that "myVal :: Num a => a" means that myVal must be *any* `Num', not just *some* `Num'
03:38:13 <fakenullie> > genericLength [1, 2, 3] :: Ration Integer
03:38:14 <liste> so it must work whatever type (that satisfies Num) you pick for `a'
03:38:15 <lambdabot>  error:
03:38:15 <lambdabot>      Not in scope: type constructor or class ‘Ration’
03:38:15 <lambdabot>      Perhaps you meant one of these:
03:38:20 <fakenullie> > genericLength [1, 2, 3] :: Ratio Integer
03:38:22 <lambdabot>  3 % 1
03:38:39 <rmg> hmm
03:39:13 <rmg> Has there been any significant changes in GHC these past few months?
03:39:30 <fakenullie> > (map (const ())) [1, 2, 3]
03:39:32 <lambdabot>  [(),(),()]
03:41:22 <siwica> Ok, thanks. That's interesting!
03:41:36 <siwica> So why is length not defined as genericLength?
03:42:05 <siwica> only historical reasons?
03:49:52 * hackage hslua 0.9.3 - A Lua language interpreter embedding in Haskell  https://hackage.haskell.org/package/hslua-0.9.3 (tarleb)
03:50:39 <liste> siwica: the type errors are easier to read
03:50:56 <liste> siwica: a similar situation with map and fmap
03:51:03 <liste> > map (+1) (1,2,3,4,5)
03:51:06 <lambdabot>  error:
03:51:06 <lambdabot>      • Couldn't match expected type ‘[b]’
03:51:06 <lambdabot>                    with actual type ‘(Integer, Integer, Integer, Integer, Int...
03:51:09 <liste> > fmap (+1) (1,2,3,4,5)
03:51:12 <lambdabot>  error:
03:51:12 <lambdabot>      • No instance for (Functor
03:51:12 <lambdabot>                           ((,,,,) Integer Integer Integer Integer))
03:53:14 <liste> siwica: also there's a performance difference
04:03:22 <siwica> liste: Why does fmap (+1) (1,2) does not work? Isn't the tuple an instance of Functor?
04:05:08 <siwica> instance Functor ((,) a) -- Defined in ‘GHC.Base’
04:05:08 <siwica>  
04:05:26 <fakenullie> > fmap (+1) (1, 2)
04:05:29 <lambdabot>  (1,3)
04:05:34 <fakenullie> not all tuples are
04:05:50 <fakenullie> and well, it doesn't work as you expect
04:06:40 <fakenullie> as you see (,) a is part of a structure, so fmap only acts on second element
04:08:54 <ertes-w> > length (1,2,3)
04:08:55 <lambdabot>  error:
04:08:56 <lambdabot>      • No instance for (Foldable ((,,) Integer Integer))
04:08:56 <lambdabot>          arising from a use of ‘length’
04:09:00 <ertes-w> oh, really?
04:09:02 <ertes-w> > length (1,2)
04:09:04 <lambdabot>  1
04:09:52 <fakenullie> > genericLength (1, 2, 3)
04:09:54 <lambdabot>  error:
04:09:54 <lambdabot>      • Couldn't match expected type ‘[a0]’
04:09:54 <lambdabot>                    with actual type ‘(Integer, Integer, Integer)’
04:10:19 <ertes-w> @let deriving instance Foldable ((,,) a b)
04:10:20 <lambdabot>  Defined.
04:10:24 <ertes-w> > length (1,2,3)
04:10:26 <lambdabot>  1
04:10:43 <marvin2> useful. :)
04:11:53 <ertes-w> this is one of those features of haskell where from an outsider's perspective you go "WAT?!", but actually it makes perfect sense =)
04:11:55 <lynn> every time I use fmap to modify the 2nd half of a tuple I feel dirty >_>
04:12:19 <marvin2> ertes yeah, fmap can only work on last element
04:12:35 <ertes-w> lynn: Data.Bifunctor is part of base now, but i don't think using fmap is dirty
04:13:00 * hackage posix-timer 0.3.0.1 - Bindings to POSIX clock and timer functions.  https://hackage.haskell.org/package/posix-timer-0.3.0.1 (MikhailVorozhtsov)
04:13:02 <fakenullie> it makes wtf for less experienced readers
04:14:01 <saurabhnanda> pgiarrusso: sorry, had to take a phone call
04:14:15 <saurabhnanda> pgiarrusso: final goal = discover instances of certain typeclass and auto-gen QC tests
04:15:33 <boxscape> is there some (key, value) data structure that I can make infinitely large (lazily) that is faster than an association list? I tried Data.Map and Data.IntMap.Lazy, but neither of them appear to allow this
04:16:38 <fakenullie> I don't see how you would make balanced binary tree from infinite list
04:16:45 <boxscape> hm, okay
04:16:51 <fakenullie> I could be wrong
04:16:59 <lyxia> boxscape: there are generalized infinite tries
04:17:22 <saurabhnanda> osa1: using `find` is the backup plan :)
04:17:39 <lyxia> You can't get balanced trees but that's fine, it's not a necessary condition to have fast access.
04:17:43 <boxscape> lyxia: is there a haskell library for them?
04:17:49 <fakenullie> is it possible to replace it with check without building inifinite list?
04:18:03 <boxscape> I guess TrieMap?
04:18:09 <lyxia> boxscape: https://hackage.haskell.org/package/MemoTrie-0.6.8/docs/Data-MemoTrie.html
04:18:13 <pgiarrusso> saurabhnanda: I’d use the backup plan first. Cabal can help you parse the files and give you a list of modules
04:18:15 <boxscape> ah, thank you
04:18:44 <lyxia> TrieMap might be it but it looks quite old
04:18:52 <boxscape> true
04:18:58 <ertes-w> boxscape: if you know the dimensionality of 'key', you can also create a "chunked" map, where the root structure is infinite, but contains Map as a substructure
04:19:15 <pgiarrusso> saurabhnanda: but even that is quite intricate: you need to load the saved result of `cabal configure` to load configuration flags and resolve conditional directives in the cabal file
04:19:48 <ertes-w> boxscape: for example an infinite list of maps would be a one-dimensional non-negative infinite map…  two infinite lists would allow infinity in both directions
04:20:27 <boxscape> interesting
04:20:32 <pgiarrusso> saurabhnanda: but to find the result of the configure step you need to find the `dist` folder, and that’s not easy—I’m not sure you can in general
04:20:39 <boxscape> that might work
04:21:00 <pgiarrusso> though probably, from the path of the dist folder, the rest would be feasible
04:21:42 <pgiarrusso> the rest *must* be done through cabal-the-library
04:22:05 <pgiarrusso> finding the path to `dist` in a stack build might need stack’s help
04:22:28 <pgiarrusso> but probably we can add some subcommand to invoke for that (if it’s not already there)
04:23:02 <saurabhnanda> pgiarrusso: is there a command-line flag which returns stack's dist/build dir?
04:23:15 <boxscape> ertes-w: by the way why did you say "non-negative" infinite map? what would a negative map be?
04:25:15 <ertes-w> boxscape: say you want to map a line (as opposed to a plane or a space)…  you need one list that goes in the positive direction and one in the negative direction from some arbitrary starting point
04:25:31 <boxscape> ah, I see
04:25:54 <ertes-w> boxscape: but why do you need it to be infinite in the first place?
04:26:00 <pgiarrusso> saurabhnanda: if it’s not there yet, I think it could be added
04:26:09 <pgiarrusso> as in, the devs would actually accept the request
04:26:26 <pgiarrusso> while “making Stack a library” would be less likely to fly
04:26:50 <boxscape> ertes-w: just to make things easier, I don't know which values I need to look up beforehand, but initializing it infinitely at the beginning means I don't have to pass the map around everywhere due to updating
04:27:10 <boxscape> ertes-w: so I can just make a top level constant containing it
04:27:44 <lyxia> Do you mean that you're not updating the map?
04:27:52 <saurabhn_> pgiarrusso: are you one of the stack maintainers? Can I refer to this discussion if I raise a ticket on Github?
04:28:06 <boxscape> no, once the keys have a value, they won't be updated lyxia 
04:28:10 <ertes-w> boxscape: how about a top-level memoised function instead of a map?
04:28:34 <pgiarrusso> saurabhn_: I’m a contributor — feel free to tag me (I’m @blaisorblade on GitHub)
04:28:40 <boxscape> ertes-w: maybe? I'll have to look up what exactly a memoised function is to answer that
04:28:42 <ertes-w> boxscape: the MemoTrie package should make this easy
04:28:48 <saurabhn_> pgiarrusso: brilliant :thumbs-up:
04:28:57 <ertes-w> boxscape: a function that remembers its results
04:29:03 <boxscape> ertes-w: okay, that makes sense
04:29:19 <lyxia> memoTrie turns your function into a Trie and back to a function.
04:29:33 <pgiarrusso> saurabhn_: please make sure to state your overall goal first, or people might think you’re solving the wrong problem — but yeah, you’re free to quote me
04:29:42 <pgiarrusso> I can’t promise to implement this myself though
04:29:56 <pgiarrusso> also, I’m not sure the feature is not there yet
04:30:27 <saurabhn_> pgiarrusso: hang on, let me check that first. I think it should already be there..
04:30:29 <pgiarrusso> saurabhn_: anyway, happy to help as far as I can! Going now, real life calls, but let me know!
04:30:37 <boxscape> I'll try out MemoTrie, thanks guys
04:31:43 <saurabhn_> pgiarrusso: thanks for you help. The answer is `stack path` btw
04:32:52 <pgiarrusso> saurabhn_: great!
04:33:29 <saurabhn_> `stack path --dist-dir` to be precise. Thanks for the help!
04:49:05 <boxscape> hm, just writing "memo" in front of the related (including recursive) function calls doesn't seem to make it run faster in ghci, the first or the second time. Is it normal that I have to do something else?
04:51:03 <Psybur> boxscape, code?
04:51:44 <mniip> you do need to consider carefully what's going on
04:51:57 <mniip> so yeah, show us the code
04:51:59 <boxscape> hold on, actually it is faster if I put it twice in main and then run main multiple times. I'll see if I can figure out if this out, otherwise I'll put together a minimal complete example
04:53:02 * hackage dunai 0.4.0.0 - Generalised reactive framework supporting classic, arrowized and monadic FRP.  https://hackage.haskell.org/package/dunai-0.4.0.0 (keera_studios_ci)
04:54:32 <boxscape> eh, nevermind, main apparently does the same thing if I don't even import MemoTrie. I'll post code after I've eaten something.
04:58:47 <lyxia> boxscape: If you want to memoize f, you let memof = memo f and use memof instead
04:59:43 <lyxia> if instead you rewrite every f x into memo f x, the memoized instances of f are not shared, so that just amounts to recomputing f x from scratch
05:00:15 <saurabhn_> any known gotchas of using System.Process.Pipe -- https://hackage.haskell.org/package/Pipe-2.1.2/docs/System-Process-Pipe.html ?
05:00:53 <Psybur> boxscape, see https://github.com/conal/MemoTrie/blob/master/examples/Generic.hs
05:01:21 <Psybur> If you havent already :D
05:01:22 <saurabhn_> use-case for System.Process.Pipe -- loop over a list of 1,000+ files, doing something potentially expensive with each filename (hopefully in multi-threaded batches)
05:01:57 <boxscape> lyxia: thank you, that works wonderfully
05:02:14 <saurabhn_> hang on... is this even using the conduits/pipes in the first place?
05:02:24 <boxscape> and thanks Psybur, I'd seen that already, but haden't realized putting it into a separate function was mandatory
05:03:13 * hackage bearriver 0.10.4.2 - A replacement of Yampa based on Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.10.4.2 (keera_studios_ci)
05:03:28 <Psybur> Actually boxscape, I think Im running into the same problem as you :D
05:07:01 <le_jonge> hi there. i have strings for IP and netmask like "192.168.123.123" and "255.255.255.0", and i need to transform them to some IP data structure to do range checks. i can see that there are multiple IP libraries for haskell, but i have 2 questions here: 1.) which one is the most "standard" library for that? 2.) none of the lib i've seen seem to support reading netmask strings. is that right?
05:07:49 <Psybur> Ok. I think I got it to work, is it working for you boxscape?
05:08:08 <boxscape> yup, works great
05:08:27 <Psybur> Mine wasnt working because my function was using just a plain Num instead of Integer
05:08:37 <saurabhn_> any canonical answer to pipes vs conduit vs streaming?
05:08:56 <boxscape> good to know that that won't work
05:10:08 <Psybur> Yeah Im surprised it compiled
05:10:56 <boxscape> did you have hastrie in the type signature?
05:11:24 <Psybur> Actually, Im not surprised it compiled, Im surprised it was made in such a way that it would compile if my stuff wasnt memoizable? :D
05:11:29 <Psybur> Ill make a paste
05:11:46 <liste> saurabhn_: use the one your dependencies use
05:12:12 <saurabhn_> liste: any quick way to check list of all transitive dependencies in a stack project?
05:12:47 <saurabhn_> `stack list-dependencies`
05:13:21 <saurabhn_> one of my dependencies is `conduit`
05:15:42 <Psybur> boxscape, https://pastebin.com/WcYUW8tX
05:16:21 <Psybur> The second call to badMemo isnt memoized but the second call to goodMemo is :D
05:17:42 <Psybur> I guess maybe the tree cant support just Num?
05:17:47 <Psybur> *Trie
05:17:50 <boxscape> interesting. I guess you could even make a fast doubly recursive fib function with memoisation. Still not anymore useful than the regular one though, I suppose
05:17:51 <Psybur> As a value
05:18:32 <boxscape> if you look at the instances of HasTrie, Num is not in there
05:18:55 <Psybur> So, the instance here is HasTrie Int
05:19:22 <Psybur> But I wonder if theres something wrong internally that makes Int -> Num not actually memoizable heh
05:20:14 <boxscape> I would guess that haskell uses Integer anyway when it has to actually execute code that just has "Num" as constraint (I don't know though), so it's interesting that that's not memoized
05:20:53 * hackage hnormalise 0.5.1.0 - Log message normalisation tool producing structured JSON messages  https://hackage.haskell.org/package/hnormalise-0.5.1.0 (AndyGeorges)
05:22:04 <lyxia> "Num" isn't a type, it doesn't make sense to "memoize it"
05:23:08 <boxscape> I meant that the function isn't memoized. I mean, haskell has to actually choose some type that fulfills the constraint HasTrie that it could use to memoize the function, right?
05:23:18 <marvin2> specific instances of Num can be memoized though
05:23:39 <Psybur> boxscape, the constraint is satisfied by Int. The type of bad memo is Int -> Num
05:23:48 <Psybur> Good fib is Int -> Integer
05:23:52 <lyxia> Num a => Int -> a
05:23:58 <Psybur> Yeah
05:24:11 <boxscape> wait, why is it Int
05:24:21 <Psybur> Because of take
05:24:26 <boxscape> ohh
05:25:42 <lyxia> Constraints are just additional implicit arguments
05:25:47 <Psybur> Trying to figure out whats going on here that would make a Num value not actually memoizable https://hackage.haskell.org/package/MemoTrie-0.6.8/docs/src/Data-MemoTrie.html#line-489
05:26:47 <lyxia> so it's really badMemo = \dictNum -> memo (badFib dictNum), and you see that memoization is done from scratch at every specialization.
05:27:19 <boxscape> that makes sense
05:28:15 <Psybur> lyxia, interesting. Do you happen to have a link to an article that goes more indepth on this topic?
05:28:39 <boxscape> http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=47DBA8455F0CCC235DCB7F917247C8E1?doi=10.1.1.43.3272&rep=rep1&type=pdf
05:29:02 <boxscape> (what memotrie is based on)
05:30:02 <lyxia> Then perhaps one would try   Int -> (forall a. Num a => a)   but besides impredicativity issues, the memoized values are functions, which hide all the computation until they are actually applied, defeating the point of memoization.
05:30:41 <holla_> Can I ask here for help?
05:30:57 <boxscape> sure
05:31:08 <Psybur> lyxia, and by topic I mean this additional implicit arguments business
05:31:59 <lyxia> Psybur: I can't think of a good reference offhand, sorry
05:32:57 <holla_> So I decided to get back to learning Haskell after some months of stopping
05:33:09 <holla_> But when I ran my old code they don't work anymore
05:34:26 <holla_> http://lpaste.net/360498
05:34:29 <ongy> do they not compile anymore, or do they do different things?
05:50:22 <saurabhn_> is there any way to force GHCi to show something even if it doesn't have a Show instance?
05:58:09 <holla_> hmm
05:59:43 <opqdonut> saurabhn_: try :print
06:00:02 <opqdonut> that might tell you something
06:00:21 <[Leary]> holla_, it compiles for me. The output of `combinations n r` is something like `max (n-r) 0`, though presumably that's not what you want.
06:01:55 <holla_> [Leary]: weird, it doesn't work in repl.it it just gives an error https://repl.it/repls/MistyLightsalmonZander
06:02:04 * hackage jukebox 0.3.1 - A first-order reasoning toolbox  https://hackage.haskell.org/package/jukebox-0.3.1 (NickSmallbone)
06:03:18 <boxscape> holla_: try ":l main" in repl.it
06:03:29 <boxscape> then you should be able to run your functions
06:03:52 <boxscape> or ":load main"
06:04:21 <boxscape> (this loads the file main.hs, which this file is apparently called)
06:04:48 <chaoxu> anyone using intellij-haskell? whenever I typed space, it will got removed by the editor, how to fix this?
06:07:12 <holla_> boxscape: you can do that in repl.it?
06:07:41 <boxscape> holla_: just type ":load main" in the terminal window on the right side of the webpage
06:08:53 <holla_> <no location info>: error: module ‘Main’ is a package module
06:09:18 <boxscape> spell "main" with a small m
06:09:21 <boxscape> not a capital M
06:09:49 <holla_> boxscape: same thing with small m
06:10:05 <boxscape> hm, that's strange, typing that works for me
06:10:22 <holla_> that is odd
06:11:06 <boxscape> what happens when you type ":load foo" with a small f?
06:12:33 <holla_> target ‘foo’ is not a module name or a source file
06:12:53 <boxscape> holla_: actually, after reloading I'm getting the same thing for main. hold on
06:13:38 <[Leary]> I haven't used this site before so I don't know how it's supposed to work, but I cleared the repl box, recompiled, loaded main and it worked.
06:13:52 <boxscape> holla_: first, click the Run button. You should get an error telling you that "main" is not in scope. After this, ":load main" should work
06:14:34 <saurabhn_> opqdonut: :print gives some extremely nested ADT of sorts...
06:15:05 <holla_>   The IO action ‘main’ is not defined in module ‘Main’
06:15:10 <lyxia> It looks like repl.it expects the module to have a main action
06:15:23 <lyxia> holla_: after that error appears, try :l main
06:15:34 <lyxia> don't refresh
06:15:52 <holla_> i did after the error appears, that is another error
06:15:57 <boxscape> huh
06:16:18 <boxscape> maybe just write a function "main = return ()" and see if it works then
06:16:29 <holla_> The code works in stack ghci but not in repl.it :/
06:16:31 <billstclair> "Haskell, the programming language maintained by Scots, in Glasgow. We Scots do nuthin’ until we have t’, but then we do a fookin’ good job.” — Bill St. Clair
06:17:07 <holla_> boxscape: okay that fixed it, thank you!
06:17:14 <boxscape> you're welcome
06:18:32 <boxscape> holla_: Ideally also give it the type signature "main :: IO ()", I'm getting an error if I don't do that
06:26:41 <billstclair> Sorry for the drive-by. I was LOL’ing at the time. I like my own jokes.
06:57:12 <slim_> kyfkh
07:03:26 <siwica> Is it possible to specify a constraint on a type variable other than by specifying a type class? 
07:03:47 <siwica> E.g. I want a function that can either return Int or Integer
07:03:58 <siwica> But don't want to generalize to Num
07:04:59 <[Leary]> Integral?
07:05:05 <erisco> siwica, Either Int Integer  perhaps?
07:05:07 <siwica> Something like add' :: {Integer a, Int a} => a -> a -> a
07:05:23 <siwica> Does a similar syntax exist?
07:05:41 <erisco> it wouldn't much help you if it did
07:06:04 <erisco> so, you have a value which is possibly an Int or possibly an Integer… what can you do with it?
07:06:45 <erisco> in languages with union types there is some operator to determine the type of a term
07:07:03 <erisco> if (x is Int) { … } else if (x is Integer) { … }  sort of thing, but we don't have that in Haskell
07:07:06 <siwica> Maybe for some reason I don't want it to be anything else
07:07:27 <erisco> no the point is there is nothing you can do with such a value until you determine if it is an Int or an Integer
07:07:38 <siwica> It's more a theoretical question since I am currently reading a chapter about type contraints
07:08:00 <erisco> there are no disjunctive constraints, no
07:08:00 <Clint> so make up your own typeclass and only derive two instances
07:08:10 <[Leary]> ^
07:08:34 <mnoonan> you couldn't stop other people from adding more instances since typeclasses are open, but maybe that isn't a problem for what you are thinking of.
07:09:12 <boxscape> you could also do "data myIntegral = MIInt Int | MIInteger Integer", I suppose
07:09:18 <siwica> I don't have a situation in mind where this is necessary, just curious if it was possible
07:09:51 <boxscape> but of course that's basically the same as using Either
07:10:05 <erisco> possibly using a closed type family…
07:10:14 <boxscape> (Also myIntegral should be capitalized)
07:10:26 <erisco> this may be different than you were imagining, but I'll demonstrate
07:14:39 <erisco> I know for sure there is a type for giving type errors… bookmarked it and can't find it
07:16:37 <erisco> grr
07:17:31 <siwica> :D
07:17:35 <erisco> anyways here is the example http://lpaste.net/360499
07:17:51 <erisco> there is a better way to induce a type error, i.e. so there is a custom error message, but I have to dig up the definition
07:20:09 <anonymous-n00b> hello
07:20:12 <erisco> hi
07:20:41 <mnoonan> erisco: that's pretty cool, I didn't realize you could close a type family like that.
07:21:27 <erisco> hasn't been around too long… maybe a year or two
07:21:38 <siwica> erisco: Thank you! I guess I will have to try to understand the language extensions first to understand this
07:21:46 <siwica> I'll have a look at it later
07:22:37 <erisco> the utility of it is just about zero, but it does restrict the types of foo to only Int or Integer
07:23:13 <erisco> it does not let foo return a value which is either an Int or an Integer, though, it must be one or the other
07:23:39 <anonymous-n00b> so I've started learning category theory through Bartosz Milewski's excellent course and wanted to use Haskell to help reinforce/internalize those concepts, but I'm having somewhat of a hard time with Haskell (I come from a mostly object oriented background)
07:24:27 <[exa]> Hm. What are the best possibilities of solving ambiguities when using Parsec? E.g. Void vs empty parentheses, or :: vs other operators
07:24:27 <erisco> dive into kmett's modules then, but you'll need to know Haskell well
07:24:36 <anonymous-n00b> I'm curious if anyone has thoughts on this - is it better that I learn category theory first and use a language I'm more comfortable with like js or C# or would you recommend I learn Haskell first via http://learnyouahaskell.com/ and then continue with my original plan
07:24:57 <[exa]> anonymous-n00b: haskell as soon as possible
07:25:16 <erisco> if you want a theory more pertinent to Haskell then learn lambda calculus
07:25:42 <erisco> [exa], what are some examples of ambiguities?
07:25:47 <[exa]> anonymous-n00b: btw: 1] I'm kindof productive in haskell and I don't know anything about CT 2] LYAH is pretty good if haskell is not your first language
07:26:14 <anonymous-n00b> okay so I should be okay learning haskell first without the math and theory background?
07:27:20 <anonymous-n00b> any alternative recommendations to LYAH? haskell is my first functional language beyond using ramda in js for the past two years, but I have solid programming experience
07:27:23 <dminuoso> anonymous-n00b: Absolutely yes.
07:27:51 <dminuoso> anonymous-n00b: Math background is not needed to understand any concepts, although I think it's incredibly educating. There's some good resources to dive into some related math topics should you be interested.
07:27:55 <foldr> anonymous-n00b: I have heard good things about "Haskell Programming from first principles"
07:28:01 <[exa]> erisco: for example with the :: -- how do I write a parser for "operator"  (which is manyOf ".,!#$%^...:") and also parser for quadDot (lexeme$string "::") so that, when parsing longer expressions, ":::" does not parse as QuadDot followed by operator ":" ?
07:28:22 <foldr> > 
07:28:24 <[exa]> or more like, "best way to match any operator that is certainly not ::"
07:28:24 <lambdabot>  <no location info>: error: not an expression: ‘’
07:29:04 <foldr> 16:28 > /quit
07:30:07 <[exa]> erisco: I especially want to avoid manually generating something like negative regexes (which I did with flex before)
07:30:46 <ertes-w> anonymous-n00b: it's less that you *need* a math background to understand haskell (except that you're going to learn some terms that come from math)…  however, haskell will make you *want* to learn those concepts, because they are useful
07:31:00 <ertes-w> not "useful to learn haskell", but "useful for software engineering"
07:31:11 <erisco> siwica, I added a second version which uses the type level error reporting feature from base http://lpaste.net/360499
07:32:03 <anonymous-n00b> foldr: thanks
07:32:08 <erisco> lets just admit that programming *is* math
07:32:20 <fr33domlover> anonymous-n00b, I don't have any math theory background related to Haskell, I just learned some FP basics and a little Scheme that's all, the rest I learn as I go and as needed
07:32:23 <anonymous-n00b> erisco: I thought lambda calculus was a subset of category theory
07:32:36 <erisco> anonymous-n00b, it isn't
07:33:58 <erisco> [exa], <|> is left-biased in Parsec, iirc, so you will put the keywords/syntax first
07:35:03 * hackage rhine 0.4.0.0 - Functional Reactive Programming with type-level clocks  https://hackage.haskell.org/package/rhine-0.4.0.0 (turion)
07:35:05 <ertes-w> anonymous-n00b: about learning material: what's your preferred learning mode?  tutorial-style or book-style?  slow-paced or fast-paced?  interactive or non-interactive?
07:35:14 <anonymous-n00b> I've found the material on lambda calculus incredibly outdated…. so far I've found bartosz's course on category theory to be much more helpful in at least understanding higher level concepts like monoids, functors, algebraic data types, etc..
07:35:31 <erisco> how is it outdated? oO
07:35:41 <ertes-w> anonymous-n00b: lambda calculus and category theory are almost completely orthogonal
07:35:56 <erisco> it isn't like lambda calculus is an evolving whizbang
07:36:25 <erisco> it'd be like saying Euclidean geometry is too passé
07:36:38 <ertes-w> anonymous-n00b: it's like saying "semirings haven't changed in decades!"…  of course they haven't…  it would be rather bad if they did =)
07:36:42 <anonymous-n00b> let me rephrase - I haven't found lambda calculus to be accessible to working programmers without a heavy math background 
07:36:53 * hackage rhine-gloss 0.4.0.0 - Wrapper to run reactive programs written in Rhinewith Gloss as backend  https://hackage.haskell.org/package/rhine-gloss-0.4.0.0 (turion)
07:36:54 <dminuoso> anonymous-n00b: Then you probably read the wrong introductions. :)
07:37:16 <anonymous-n00b> I tried Greg Michaelson's functional programming through lambda calculus and quickly became suicidal
07:37:29 <ertes-w> anonymous-n00b: lambda calculus is really the base for many things from a very minimal programming language to a fully fledged foundation for mathematics
07:37:30 <erisco> well, try again, because lambda calculus is probably the easiest to understand for functional programmers
07:37:46 <erisco> but then maybe you want to dig into Haskell a bit first to get an air for what functional programming is about
07:37:49 <dminuoso> anonymous-n00b: lambda calculus is related to studying how programming languages work, very much like the turing machine does. its just an abstract model useful for proofs.
07:38:01 <ertes-w> anonymous-n00b: in the context of FP it's more or less just syntax and reduction semantics
07:38:45 <ertes-w> (λx.x), or in haskell's syntax (\x -> x) is the identity function:  an anonymous function that takes an argument x and returns it
07:39:05 <mnoonan> anonymous-n00b: CT is kind of like a source of design patterns that is popular with Haskellers.
07:39:27 <ertes-w> and ((λx.x)y), or in haskell syntax ((\x -> x) y), reduces to y
07:39:31 <mnoonan> otoh, lambda calculus is essential to Haskell, in the sense that GHC compiles to a variant of System F
07:39:55 <mnoonan> (a variant of the simply typed lambda calculus)
07:40:03 <anonymous-n00b> yes to be fair it was easier to understand than category theory, but I would prefer to learn in a better language than pascal
07:40:12 <ertes-w> anonymous-n00b: honestly i think you should just pick up a tutorial and learn haskell
07:40:16 <dminuoso> anonymous-n00b: You do not need any experience in lambda calculus or category theory to learn haskell.
07:40:19 <erisco> anonymous-n00b, don't set your sights too high now
07:40:20 <ertes-w> anonymous-n00b: don't focus too much on the theory stuff for now
07:40:33 <dminuoso> anonymous-n00b: They are probably really helpful if you *do* know it, but you can learn it fine without it.
07:40:36 <erisco> we were taught in a language called Turing
07:40:46 <erisco> which I think was inspired by Pascal… not sure
07:41:18 <ertes-w> as SPJ put it, haskell is the way god intended programs to be written…  or at least church
07:41:40 <anonymous-n00b> lol
07:42:45 <anonymous-n00b> I'm kind of surprised… all the time I hear that in order to understand functional programming you need to understand category theory, but you guys are saying lambda calculus is more important
07:42:52 <dminuoso> Perhaps it may even be that learning category theory or lambda calculus might be easier once you learned Haskell because it gives a good framework to play with it in.
07:42:55 <erisco> who told you that anonymous-n00b?
07:43:05 <erisco> it is the exact opposite thing that is said in this channel on a regular basis ^.^
07:43:21 <mud> anonymous-n00b: Whoever told you that is not a good source of advice.
07:43:34 <ertes-w> anonymous-n00b: that's quite surprising, as there have been functional language before haskell, and CT only found its way into programming through haskell
07:44:19 <anonymous-n00b> so most of the higher level constructs in haskell aren't based on category theory?
07:44:20 <dminuoso> anonymous-n00b: Lisp, one of the first programming languages, can be viewed as a practical implementation of untyped lambda calculus, the forefather of all functional programming languages.
07:44:36 <dminuoso> anonymous-n00b: They derive their meaning and laws from category theory, but to you they are just patterns.
07:44:55 <dminuoso> You dont need to understand the mathematical reason why a pattern is good, you just need to understand how its applied.
07:45:09 <mud> anonymous-n00b: They're at best inspired by category theory. They can be understood completely on their own.
07:45:11 <mnoonan> anonymous-n00b: even if they were (which I'm not really ready to grant), it's like saying you can't learn to drive a car without understanding all aspects of internal combustion engines
07:45:23 <ertes-w> anonymous-n00b: this is where not knowing haskell becomes problematic…  haskell uses category theory a lot, but doesn't force you to learn it yourself
07:45:48 <ertes-w> anonymous-n00b: again, i suggest that you just learn haskell
07:46:05 <ertes-w> ignore the theory stuff for now…  don't worry, you will learn it eventually (if you want to)
07:46:25 <mnoonan> I think the perception may come from Haskell importing names from CT (like Functor).. some learners want to then google "functor" or "monad" or whatever, and end up down a CT rabbit hole
07:46:27 <anonymous-n00b> yeah I'm just saying it sounds like maybe learning haskell then learning category theory THEN learning the lambda calculus might be more practical
07:46:41 <bitemyapp> anonymous-n00b: not really
07:46:47 <anonymous-n00b> yes perhaps you're right mnoonan
07:46:51 <bitemyapp> LC is pretty small and can help with understanding how Haskell code evaluates
07:46:54 <ertes-w> anonymous-n00b: the only thing haskell forces you to learn is some categorical terminology…  you will learn what functors and monads are *in the context of haskell*
07:46:55 <bitemyapp> category theory is strictly optional
07:47:03 <ertes-w> anonymous-n00b: and there they are little more than patterns
07:47:57 <ertes-w> anonymous-n00b: don't put a strict order on your learning topics…  just learn haskell, and everything else will just fall into place
07:48:20 <ertes-w> you're going to learn basic lambda calculus without even realising it, until you want a more firm grasp on it
07:48:35 <anonymous-n00b> fair enough .. yeah I'll get started learning haskell I guess then go from there
07:49:29 <dminuoso> anonymous-n00b: It's like when you implement a sort algorithm. You just need to know how it works to implement it, not the complete mathematical theory proving why it works in the complexity that its advertised with.
07:49:41 <anonymous-n00b> I've been an OO programmer for 10 years, but once I read this and started to see the light: https://drboolean.gitbooks.io/mostly-adequate-guide
07:50:29 <erisco> "We'll use the world's most popular functional programming language: JavaScript."
07:50:40 <ertes-w> heh
07:50:43 <anonymous-n00b> so yes I get what you're all saying about learning haskell first, but I'm shaking up my understanding of what I know as programming so it helps for me to really understand what's going on beneath the hood
07:50:56 <erisco> well, gotta make appeals
07:51:02 <dminuoso> erisco: JavaScript is what led me here in all fairness. A year ago I started with React.. and then there was this mention about "immutable data". After some 9 difficult months I ended up in here.
07:51:20 <ertes-w> anonymous-n00b: haskell itself is going to be a ride, if you've only been doing imperative OO until now
07:51:37 <anonymous-n00b> yep same here - started about 2 years ago and now I've decided to dig in further
07:51:40 <boxscape> anonymous-n00b: by the way, as I understand it, learn you a haskell isn't recommended as much anymore. this is the go to list I believe https://github.com/bitemyapp/learnhaskell
07:51:59 <bts-> anonymous-n00b: yeah i wouldn't use LYAH
07:52:03 <dminuoso> anonymous-n00b: Here's my piece of advice that helped me with my OO background. Forget everything, there's not much that will help you in your background. You're learning from anew.
07:52:12 <erisco> dminuoso, the author is just saying that to entice readers
07:52:18 <dminuoso> erisco: Ah heh.
07:52:28 <ertes-w> the CIS194 course mentioned on that page is great
07:52:30 <erisco> if JavaScript counts as functional programming then so should many other languages which clearly aren't
07:52:48 <dminuoso> erisco: You can do functional programming with it just fine.. it just requires a careful discipline and picking of correct libraries...
07:52:49 <dminuoso> :P
07:53:00 <erisco> right, and you can do that in many languages
07:53:03 <dminuoso> ramda left, fantasy-land right and partial.lenses right in between.
07:53:14 <mud> JS is a bit odd. You can write in an FP style quite heavily, but it's also easy to avoid it completely. So it rather depends who's writing and what style they choose.
07:53:33 <dminuoso> Well the second you try and do that, flow and typescript refuse to be your friend really quickly.
07:53:34 <tdammers> depends on your definition of Functional
07:53:52 <ertes-w> JS works as a very poor functional language…  the thought of composing functions in non-associative ways in JS makes my stomach turn
07:54:06 * hackage proxy-mapping 0.1.0.1 - Mapping of Proxy Types  https://hackage.haskell.org/package/proxy-mapping-0.1.0.1 (DanielVanDenEijkel)
07:54:09 <anonymous-n00b> oh yeah I recognize js isn't a functional language.. that's why I'm not using js to learn category theory
07:54:21 <tdammers> it's also kind of problematic that you get zero tooling support for telling the difference between a function and a procedure
07:54:42 <ertes-w> yes, JS would be a terrible choice to learn CT…  it's really important to have types for CT
07:54:50 <tdammers> that too
07:54:54 <tdammers> but also actual functions
07:54:59 <tdammers> JS doesn't really have those
07:55:03 <dminuoso> It does?
07:55:06 <tdammers> no
07:55:06 <brynedwards> JS has plenty of types: null, undefined, number...
07:55:09 <tdammers> it has procedures
07:55:12 <boxscape> typescript helps a bit
07:55:18 <ertes-w> JS has only a single type: Stuff
07:55:23 <dminuoso> tdammers: Thats what I meant with discipline.
07:55:26 <brynedwards> :D
07:55:31 <ertes-w> in haskell we know it as Dynamic
07:55:35 <ertes-w> sort :: Dynamic
07:55:39 <ertes-w> 42 :: Dynamic
07:55:43 <ertes-w> putStrLn :: Dynamic
07:55:49 <tdammers> dminuoso: discipline alone won't cut it though, because the problem is that whether a procedure has any side effects also depends on its inputs
07:55:51 <dminuoso> ertes-w: Oh, that's the argument "there are no dynamically typed languages, they are statically typed single type languages" ?
07:55:53 <boxscape> which library is that from? ertes-w 
07:56:06 <ertes-w> dminuoso: yeah
07:56:07 <anonymous-n00b> ertes-w: yes that's why I decided not to reinforce my CT learning with JS (dynamically typed)
07:56:23 <ertes-w> boxscape: i made it up =)
07:56:27 <boxscape> oh, neat
07:56:31 <boxscape> I see
07:56:34 <ertes-w> i think there is acme-php on hackage
07:56:37 <boxscape> I thought you said you wrote it
07:56:41 <ertes-w> but i think it doesn't do the dynamic typing thing =)
07:56:44 <mnoonan> speaking of js.. i'm slightly crushing on purescript right now
07:56:50 <boxscape> then I realized you didn't write "> 42 :: Dynamic"
07:57:27 <tdammers> ertes-w: acme-php does the dynamic typing thing similar to early PHP did it - just implement all the typeclasses for String
07:57:32 <tdammers> instance Num String where .... :(
07:57:36 <ertes-w> heh
07:57:54 <ertes-w> so it should be acme-tcl
07:57:59 <anonymous-n00b> mnoonan: have you tried reason or elm? 
07:58:43 <mnoonan> anonymous-n00b: I followed elm from a distance, but I didn't like it's lack of abstraction capabilities (e.g. no typeclasses)
07:59:00 <mnoonan> I haven't tried reason, though the idea seems interesting.
07:59:38 <ertes-w> elm also dropped its main selling point at some point
07:59:42 <ertes-w> being reactive
08:01:15 <dminuoso> mnoonan: Or lack of higher kinded types, which Ive taken for granted in haskell without even knowing what they are.
08:01:25 * mnoonan nods
08:01:34 <anonymous-n00b> I'm curious about reason's plans for supporting algebraic effects
08:03:08 <erisco> what's an algebraic effect?
08:07:45 <anonymous-n00b> my understanding is that it's basically a way of treating effects as first-class citizens through composable handlers
08:07:55 <anonymous-n00b> it's supposed to be functionally sound
08:08:01 <ertes-w> erisco: stuff like freer
08:08:07 <anonymous-n00b> OCaml has support for it as well as Eff
08:09:07 <ertes-w> it's an alternative to effect classes with a different take on the expression problem
08:09:09 <anonymous-n00b> but at the end of the day I felt like I would be better off learning Haskell and then branching out into languages like OCaml from there
08:10:03 <anonymous-n00b> good idea or not I'm not sure.. but I'm partial to the idea perhaps because of my OO bias
08:10:23 <ocramz> hullo!
08:10:56 <ertes-w> anonymous-n00b: i take it that OCaml could as well be called Caml, because nobody uses the O part
08:11:28 <ertes-w> there have also been proposals and even dialects to add OO features to haskell, but none of them were taken seriously (thank god!)
08:12:02 <ocramz> what's the purpose of `toException :: Exception e => e -> SomeException` and `fromException :: Exception e => SomeException -> Maybe e` ?
08:12:24 <ertes-w> ocramz: SomeException is a wrapper type that can hold any exception type
08:12:30 <Cale> ocramz: For deciding if a given exception ought to be caught
08:12:45 <ertes-w> ocramz: if you catch SomeException, you catch *all* exceptions, and you can use fromException to distinguish
08:13:28 <Cale> ocramz: fromException will take an arbitrary SomeException and then potentially give a value of your custom exception type, and it can make use of the Typeable runtime type machinery to decide what to produce
08:13:31 <anonymous-n00b> haha yeah … also new features in traditionally OO languages that I love are all functional based like LINQ in C#, Streams in Java, lambda functions in C# (basis of LINQ), Java and JavaScript
08:14:17 <Cale> toException is used when throwing an exception of your custom type, and can be used to translate it and throw some other exception instead, if you want
08:14:26 <anonymous-n00b> at the end of the day though OO languages pay the bills for me
08:14:32 <Cale> (but usually you won't override the default, which is just to apply the SomeException data constructor)
08:14:49 <Cale> It's perfectly valid to give a blank Exception instance, like
08:14:54 <Cale> instance Exception MyType
08:15:12 <Cale> since the default methods are usually all you need, if you're defining some new sort of exceptions
08:15:31 <Cale> But these let you basically form refinements and unions of other exception types, however you like.
08:15:32 <ertes-w> ocramz: in short: SomeException is Data.Dynamic.Dynamic for exceptions
08:15:40 <cocreature> ocramz: you might want to take a look at https://pdfs.semanticscholar.org/c0a3/eb80020e2e162116901b5ae83dd4b060cbcd.pdf. it’s very readable
08:15:48 <Cale> I have an example somewhere...
08:15:58 <ocramz> Cale ertes-w cocreature thanks all
08:17:18 <anonymous-n00b> alright guys I gotta run thanks for the advice! I'll take a look at https://github.com/bitemyapp/learnhaskell and http://haskellbook.com/ then hit the ground running with the book or the courses
08:17:35 <ocramz> also, say we have a transformer defined on top of IO, let's say `ReaderT env IO a`; I guess that even if we define a MonadCatch instance for this, if IO throws an exception it can only be caught in IO
08:18:00 <Cale> ocramz: Yeah, the handler needs to be an IO action.
08:18:20 <ocramz> yep
08:18:39 <Cale> ocramz: So if you want the handler to be in ReaderT, you'll have to obtain the environment beforehand, and runReaderT, and so the MonadCatch instance just specifies how to do that.
08:19:02 <Cale> ocramz: With other monad transformers, it's not as straightforward what ought to happen
08:19:29 <Cale> For example, what happens if there's a StateT, and the exception handler affects the state?
08:20:14 <Cale> (usually that's not too bad either, but it involves at least a small decision)
08:20:26 <ocramz> yep I often refer to snoyberg's blogs for this
08:20:55 <ocramz> `ReaderT env IO a` , with potentially some mutable references in `env`, are the way to do this
08:20:59 <michalrus> Hey, what’s the name for `liftA2 (<|>)` that doesn’t run the second alternative action?
08:21:14 <Cale> There's that MonadBaseControl stuff which is an attempt to systematically deal with this, but in my experience, it confuses the issue more than it actually helps.
08:21:36 <lyxia> michalrus: const
08:21:37 <bitemyapp> MBC also means you need to excise any uses of MonadState out of your app.
08:21:46 <Cale> You're usually better off just writing instances by hand for the higher order operations that you need to lift.
08:21:55 <bitemyapp> we had to move everything to Reader / Reader+IO when we started using MBC for lifted-async.
08:21:57 <michalrus> lyxia: well, I want to run it if… the first one is a failed alternative.
08:22:05 <Cale> Because not all operations are even likely to be handled uniformly
08:22:30 <Cale> and MonadBaseControl will usually get you something which typechecks, but half the time is surpising or confusing in some way
08:23:19 <lyxia> michalrus: Alternative doesn't specify whether (<|>) should "backtrack" or not 
08:23:23 <Cale> surprising*
08:23:34 <michalrus> lyxia: i.e. if I have two `IO (Maybe a)` I want to run the second one only if the first is Nothing.
08:23:44 <michalrus> Should I write this using `case`?
08:24:00 <michalrus> I thought that maybe there was something…
08:24:33 <lyxia> there's (<|>) for MaybeT IO, but the (un)wrapping may be too costly...
08:24:52 <lyxia> (costly in numbers of characters)
08:24:57 <michalrus> :P
08:24:58 <michalrus> OK.
08:25:00 <michalrus> Thanks!
08:25:05 <ocramz> Cale yes I sort of got the rationale for monadbasecontrol but never had the need for it yet (no IO callbacks)
08:25:49 <Cale> Those things are subtle enough that I think it's worthwhile defining your own type class and thinking through each instance yourself.
08:26:28 <Cale> In fact, I recommend doing that even if you're not dealing with higher order operations
08:26:42 <Cale> I don't like the mtl classes, (MonadReader, MonadState, etc.)
08:26:49 <Cale> and would prefer to see something more meaningful
08:28:57 <Cale> That is, define your own type class with operations that manipulate the state of your application in more meaningful ways, and then implement a transformer (or just a monad), and write the instances of your classes in terms of the MonadReader/MonadState operations. Your final monad probably shouldn't even be an instance of MonadReader or MonadState.
08:29:02 <erisco> seeing a type class per type feels like a disease
08:29:10 <bitemyapp> I meant MonadState more generically than the mtl-class
08:29:11 <erisco> what's wrong with the language that that is occurring
08:29:25 <bitemyapp> the mtl-class isn't exclusively broken, it's any state
08:30:09 <Cale> erisco: It shouldn't be a type class per type. It might be a type class per transformer, but you'll likely have a number of instances to write.
08:31:00 <Cale> (At minimum, the one for the transformer itself, and then one for each of the transformers which will be applied to the monad after that one)
08:31:43 <erisco> if I am reading this right, for MonadState, it is to pull state out arbitrarily deep in the stack
08:32:08 <Cale> If you have to think of the monad you're using as a stack of monads, then something has gone horribly wrong.
08:32:40 <erisco> well, that seems like the purpose of their instances
08:32:53 <Cale> In the end, you should end up with a monad whose implementation you don't care about (you shouldn't be able to tell transformers are involved at all), and which supports all the operations you need.
08:33:18 <Cale> The operations might or might not be organised into type classes depending on how modular you want to make things
08:33:35 <erisco> I don't have a list of examples to drum up right now but I have seen numerous times in modules that there is one principle type and then a corresponding type class
08:33:51 <erisco> where the idea is that other implementations can be given
08:33:59 <Cale> It can be advantageous to have those type classes, in case you ever want a different monad with some of the same operations, and they also allow you to be precise about which operations each part of the code needs.
08:34:34 <erisco> well of course it is advantageous else people wouldn't be doing it, but it doesn't look right to me
08:34:57 <mnoonan> erisco: I'd be curious to see an example, I don't feel like I've come across that before.
08:34:58 <Cale> This is particularly the case if you're implementing each collection of operations as a monad transformer, which is going to result in many different monads, all of which will support these same operations.
08:34:59 <erisco> at least when I am doing OO I am concerned if I have an X class and a IX interface
08:35:18 <erisco> and I'll explain why
08:35:21 <Cale> Well, in OO, things aren't as parametric
08:35:40 <Cale> It makes sense here, because you're going to be *creating* monads which support this interface
08:35:46 <Cale> Every time that you apply the transformer.
08:36:03 <erisco> if there was a good abstraction, it is strange that it is blatantly the same as the implementation, so much so that one can't think of a better name
08:36:16 <Cale> and then you're going to potentially transform a monad which supports your interface in some way, and want the resulting monad to also support it
08:36:20 <erisco> versus abstractions such as "Functor" and "Monad"
08:37:17 <erisco> so it reeks of saying you know there should be an abstracted interface but you don't know what it is
08:37:36 <erisco> so you cut the definitions out, leave the type signatures, and call it done
08:39:26 <Cale> Well, there's still a lot of design taste to account for in what you make the operations of the classes that you're defining
08:39:33 <erisco> MTL may have better reasons but superficially it rings that alarm bell
08:41:42 <Cale> But for example, I'm much happier with a monad transformer implemented in terms of ReaderT that has a type class of operations for querying the database, rather than a MonadReader instance that lets us 'ask' for the connection pool.
08:42:08 <Cale> Provide the meaningful operations that the state/environment you're carrying around let you perform
08:42:26 <Cale> so that the lifting instances can be implemented in a way which is sensible for each particular application
08:58:05 <dminuoso> jle`: After some heavy thoughts I just realized that the best way to understand the computation, is to just beta reduce `parse (some' (satisfy isDigit)) "1"` manually. So the trick lies in what the applicative effect does, which is where the stream is slowly consumed!
08:58:49 <feuerbach> In pipes, is there a way to supply a single value to a Consumer and get a Consumer back? That would be a dual of 'next', I think.
08:59:34 <erisco> the effects is where it is all at with Applicative or Monad
09:00:48 <dminuoso> erisco: Yeah. And also I finally understood how `pure` does not.. "run" the effect.
09:01:09 <erisco> right, pure/return is the "do nothing" effect
09:01:53 <Cale> dminuoso: pure is the same thing as return if that helps :)
09:02:15 <dminuoso> Cale: In my applicative it literally is. :-)
09:03:08 <Cale> dminuoso: It pretty much always ought to be
09:04:06 <callmecabman> Good evening, my fellow kindred. I have a small project design where the workhorse function has type Pandoc -> Algebra MyDSL (Reader Env Pandoc). Any pros/cons?
09:05:10 <dminuoso> Cale: It almost seems like Applicatives are harder to grasp than Monads.
09:06:29 <Cale> dminuoso: I agree.
09:06:46 <Cale> dminuoso: Though if you get Monad, you can understand Applicative 90% of the way through that
09:08:41 <Cale> dminuoso: Specifically, for any monad, we'll have pure = return, and (<*>) = ap
09:09:03 <Cale> ap mf mx = do f <- mf; x <- mx; return (f x)
09:09:53 <Cale> dminuoso: and then the other main thing to be aware of is that (<$>) (that is, fmap) and (<*>) work together to get you a sort of generalisation of liftM2/liftM3/etc.
09:09:55 <callmecabman> Cale: I think there's a proposal about getting rid of return and forming a proper Functor<Applicative<Monad typeclass hierarchy
09:10:07 <Cale> callmecabman: I think that's a little silly, but yeah
09:10:51 <Cale> There's already a proper hierarchy
09:10:59 <dminuoso> Cale: Huh. so ap really is <*> in the straightest sense.. so what makes the Monad special? Is it "just" being equipped with `join` and respective laws?
09:11:17 <Cale> dminuoso: Yeah, you can't do join with the Applicative operations
09:11:18 <callmecabman> dminuoso: yep, join is the salt of Monad
09:11:31 <Cale> or (>>=)
09:11:48 <dminuoso> Well >>= can be thought of as join $ fmap .. :P
09:11:52 <Cale> which means that you can't determine the continuation of a computation from the result of some part of it, using only Applicative
09:12:19 <Cale> If you only have the Applicative operations, the effects of the computation will be the same regardless of what happens once it begins running.
09:13:25 <Cale> Another way to think about Applicative is through an operation like
09:13:38 <Cale> ... what should we call it...
09:13:45 <Cale> well, anyway,  liftA2 (,)'
09:14:02 <callmecabman> idiom brackets ala Conor McBride
09:14:02 <Cale> ignore that spurious ' 
09:14:30 <Cale> liftA2 (,) :: f a -> f b -> f (a,b)
09:14:39 <ertes-w> dminuoso: you can't write (>>=) in terms of Applicative either
09:14:49 <Cale> this operation together with pure and fmap are enough to define Applicative
09:15:27 <Cale> and if you uncurry that, you get  (f a, f b) -> f (a, b)
09:16:03 <Cale> So this is the sort of functor which "interacts nicely with pairing somehow"
09:16:52 <ertes-w> (<$>) :: (Functor f)     =>   (a -> b) -> f a -> f b
09:16:52 <ertes-w> (<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
09:16:53 <ertes-w> (=<<) :: (Monad f)       => (a -> f b) -> f a -> f b
09:16:53 <callmecabman> Cale: it just respects the monoidal structure of () and (,), if I'm not mistaken?
09:16:54 <Cale> and that perhaps gives you a sense of the limitation on how expressive you can be: basically you can only pair up a bunch of effects to be performed, and transform the results at the end somehow
09:16:58 <Cale> yeah
09:17:08 <ertes-w> dminuoso: ^ you might find this diagram useful
09:17:13 <Cale> Applicative is pretty much the notion of a monoidal functor
09:17:30 <Cale> (specifically for the (), (,) monoidal structure on Hask)
09:17:47 <ertes-w> and for the sake of completeness:
09:17:48 <ertes-w> (<<=) :: (Comonad f)     => (f a -> b) -> f a -> f b
09:17:51 <Cale> It's just disguised somewhat
09:19:11 <tabaqui> ertes-w: I'm reading your manual for Rank N Types right now
09:19:18 <ertes-w> Functor lets you map over the "point" of exactly one f-value, Applicative lets you map over the "points" of arbitrarily many f-values, and Monad lets you "embed" f-values in other f-values by mapping "points" to f-values
09:19:27 <tabaqui> I'm not understand it completly
09:19:30 <Cale> But yeah, from the computational perspective, the thing that Monad gives you is very nicely expressed in terms of (>>=), in that it lets you determine the future of a computation in terms of the result of some initial action, and that's exactly what's missing in Applicative.
09:19:43 <tabaqui> but is it true that we can impelement forall
09:19:48 <Cale> With Functor alone, you have no ability to combine separate computations, only transform their results.
09:20:01 <ertes-w> tabaqui: feel free to ask a question…  highlight ertes though, because i'm almost out the door…  if nobody else answers, i'll answer when i get home
09:20:19 <Cale> and with Applicative, you can only pair them up in a way where there's no interesting control flow
09:20:21 <tabaqui> ertes-w: as new class with one method - our function?
09:20:25 <tabaqui> okay, ertes-w 
09:20:47 <tabaqui> err, full question, again:
09:21:12 <tabaqui> ertes-w:  is it true that we can impelement forall as new class with one method - our function?
09:21:50 <tabaqui> I'm looking at your example with genR and trying to compare with, f.e., read function
09:22:01 <callmecabman> Suppose we have an AST formed by an expression functor. Is my intuition right that Applicative constraint on this functor lets me evaluate the AST in parallel?
09:22:11 <tabaqui> it actions just like your generic genR
09:27:12 <tabaqui> *acts
09:33:21 <callmecabman> Rant time. Five years ago I was a happy student studying programming and CS in a weak university. Now I barely want to write code in anything other than Haskell, and all the people that can understand my mumbling about free monads or catamorphisms are thousands of miles away. I mean you, #haskell, math/stackoverflow and nlab. What have I done with my life.
09:34:25 <erisco> callmecabman, what is an expression functor?
09:34:40 <[exa]> callmecabman: common think about the poor people from the other areas of CS
09:36:16 <[exa]> anyway, is there a reasonable way to tell Parsec to fail if it has parsed out some exact string? E.g. Parse out any sequence of characters, but not "abcd"
09:36:36 <[exa]> (without manually writing a negative regex for that, ofc.)
09:36:59 <tabaqui> callmecabman: "A closure is a poor man's object", you shall to learn something else, not just haskell
09:37:04 <callmecabman> erisco: any functor which represents the algebraic structure of your expressions.
09:37:15 <c_wraith> [exa], your problem description is basically exactly the answer.
09:37:58 <callmecabman> I have something like ExprF a = Constant Text | Concat a a | Branch Var a a | Substitute Var Text
09:38:07 <erisco> callmecabman, I don't know what the connection to parallelism would be
09:38:32 <Gurkenglas> Why does ghci unroll type aliases when that lets it pull foralls to the front?
09:38:37 <c_wraith> [exa], parse the sequence of characters, check for the bad sequence, fail if it was found
09:39:25 <[exa]> c_wraith: so something like (try parseBad >> fail) <|> parseGood ?
09:40:19 <c_wraith> I don't think that works, because of the try.
09:40:48 <c_wraith> I meant using the fact that it's monadic. actually inspect the return value.
09:40:52 <Gurkenglas> How would one go about figuring out what line of source code is responsible for that?
09:40:52 <[exa]> I've also kindof failed to understand the exact semantics of "try" so far, but I guess looking at the docs will do
09:41:26 <callmecabman> [exa]: try x is parse x or pretend you didn't consume anything in the stream
09:41:48 <[exa]> callmecabman: oh, that's the explanation I needed :] thanks
09:43:29 <[exa]> c_wraith: ok I guess that then it's something like this: parseGood >>= \a -> if isBad then fail else return a
09:43:40 <[exa]> (+ guard syntax for the if)
09:43:48 <c_wraith> [exa], that's what I had in mind, yeah
09:43:56 <[exa]> ok, thanks
09:44:17 <Gurkenglas> mfilter (/= "abcd") $ parseGood
09:45:15 <[exa]> wow
09:46:17 <[exa]> yeah, I guess I can use the exactly same function just with the reverse condition to correctly parse out the other case, without consuming half inputs etc.
09:47:30 <woodson> anyone familiar with servant ?
09:49:27 <glguy> woodson: yes, someone is
09:49:35 * [exa] votes for standardized definition of mele=flip elem
09:50:19 <woodson> glguy: I am having issue understanding the endpoints 
09:50:45 <woodson> are you supposed to return a handler when defining your end?points
09:55:26 <[exa]> c_wraith, callmecabman: it works perfectly, thanks!
09:58:52 * hackage posix-socket 0.1 - Bindings to the POSIX socket API  https://hackage.haskell.org/package/posix-socket-0.1 (MikhailVorozhtsov)
10:26:12 <eacameron> I noticed that the linear types proposal PR was closed. What's going on with that discussion? Anyone know?
10:35:07 <Junior_> Anyone familiar with Blockchain technology with Haskell?
10:35:23 <Junior_> Or Machine Learning in Haskell?
10:36:46 <[exa]> Junior_: why?
10:38:10 <Junior_> exa: In the process of learning Haskell, and am trying to figure out a specific niche with Haskell.
10:39:38 <[exa]> there are certainly people aware of both, if you have a specific question you should ask it
10:40:12 <rightfold> I know a guy doing blockchain stuff with Idris
10:40:27 <Junior_> exa: I see that there is so much to learn.  I just want to set a specific focus with Haskell.  Any suggestions?  I still need to build my core foundation with Haskell.
10:41:19 <[exa]> Junior_: there's no such thing as core foundation
10:42:16 <Junior_> exa: What would you focus on then with learning it?
10:42:33 <[exa]> Junior_: but otherwise no, no suggestions. :] Do you have some software that you'd want to see working and it's still missing?
10:44:49 <Junior_> rightfold: Blockchain is foreign territory for me, and looking at the writings online seems quite technical.  Just want an idea if this is something a Haskell newbie can figure out.  Or something more advanced.
10:45:13 <crucify_me> I think this is a quick question: when we have the type for flip id, the (b -> c) takes a single argument, and the first b in the type sign. is the other argument of the binary function, correct? ie both arguments are accounted for and can be ascertained from a glance at the signature...  https://ptpb.pw/wu1y
10:45:28 <Junior_> exa: I've had some projects that I've had in mind to build.
10:45:29 * hackage integer-gmp 1.0.1.0 - Integer library based on GMP  https://hackage.haskell.org/package/integer-gmp-1.0.1.0 (HerbertValerioRiedel)
10:45:45 <[exa]> Junior_: please elaborate
10:45:59 <crucify_me> as in , say , flip id 4 (/) 2 
10:46:35 <erisco> crucify_me, I don't understand the question. reword it for me please
10:47:09 <Junior_> exa: I'm in a club and I've been tasked with creating daily schedules of roles to fill in meetings.  I'm thinking of doing this as a more automated process.
10:47:32 <[exa]> Junior_: great, what about writing a web app for that?
10:47:40 <[exa]> Junior_: or maybe just a commandline tool
10:47:48 <crucify_me> so b -> (b -> c) -> c   << (b -> c) is a binary function required by flip, so with b -> (b -> c) -> c  ,  the two b's there are the two arguments.
10:47:52 <[exa]> :t flip id
10:47:53 <lambdabot> b -> (b -> c) -> c
10:47:54 <crucify_me> erisco, ^
10:47:58 <Junior_> exa: I was thinking of doing it as a web app.
10:48:34 <erisco> crucify_me, what is the question?
10:48:48 <[exa]> Junior_: Did you try to code any webapp before?
10:49:05 <[exa]> crucify_me: are you asking where the actual type of `flip id` came from?
10:49:26 <crucify_me> ie in a type difinition, you can always see *all* the arguments required .  no [exa] 
10:49:53 <crucify_me> there are no implicit arguments in a type def
10:49:59 <Junior_> exa: Haven't coded a web app in a functional language before.  But have experience creating web apps in Microsoft .Net Technology stack.
10:50:45 <crucify_me> those are questions ^
10:51:30 <Junior_> exa: I'm thinking maybe the scheduling app wouldn't be a first project to tackle first.  Am planning to create a toDo list app first to get my feet wet.
10:51:32 <[exa]> crucify_me: seems I've failed to parse that as a question too :]
10:51:39 <fishythefish> crucify_me: are you trying to understand the type of `flip id`?
10:52:09 <crucify_me> both arguments of (/) in flip id 4 (/) 2   are accounted for in the signature, if I understand correctly
10:52:34 <crucify_me> in the type signature of flip id
10:52:40 <fishythefish> yes
10:52:45 <fishythefish> they must be
10:52:47 <fakenullie> :t flip id
10:52:48 <lambdabot> b -> (b -> c) -> c
10:52:54 <crucify_me> b and (b .. ) right?
10:53:02 <[exa]> crucify_me: unify (:t (/) ) with (b->c)
10:53:38 <crucify_me> fishythefish, thanks you understood! I was trying to be clear
10:53:56 <crucify_me> good call [exa] thanks
10:54:08 <mnoonan> that's kind of funny.. flip id === flip ($)
10:54:24 <fishythefish> crucify_me: not quite - the first `b` corresponds to 4; the `b` in `b -> c` just states that the function (/) can take 4 as its first argument
10:54:40 <fishythefish> mnoonan: not really, ($) is just `id` specialized
10:54:43 <crucify_me> hmm ok wait
10:55:05 <mnoonan> fishythefish: fair enough
10:55:05 <fishythefish> you can use `id` instead of $, but it'll have different precedence
10:55:17 <glguy> :t id :: (a -> b) -> a -> b
10:55:18 <lambdabot> (a -> b) -> a -> b
10:55:33 <erisco> and associativity
10:55:39 <glguy> :t id :: (a -> b -> c) -> a -> b -> c
10:55:40 <lambdabot> (a -> b -> c) -> a -> b -> c
10:55:41 <fishythefish> yes, fixity, associativity, etc
10:55:56 <crucify_me> so in fishythefish 's last post to me ^ ...
10:56:14 <crucify_me> this is what I'm trying to grep
10:56:17 <glguy> so if we use that second type signature then: flip id :: a -> (a -> b -> c) -> b -> c
10:56:25 <[exa]> crucify_me: the weird point is that 'c' in the type of `flip id` becomes a functional type (say, d->e) in your case
10:56:46 <crucify_me> [exa], don't get that notation
10:57:01 <crucify_me> wait please hold on
10:57:04 <fishythefish> crucify_me: in particular, `c` is the type of `(/) 4`
10:57:28 <crucify_me> hold on
10:57:57 <[exa]> :t flip id 4 (/)
10:57:58 <lambdabot> Fractional b => b -> b
10:58:08 <[exa]> :t flip id 4
10:58:09 <lambdabot> Num b => (b -> c) -> c
10:58:28 <[exa]> :t (/)
10:58:30 <lambdabot> Fractional a => a -> a -> a
10:58:34 <crucify_me> [exa] please wait
10:58:39 <fishythefish> crucify_me: IRC doesn't go anywhere :)
10:59:01 <crucify_me> I know but..
10:59:18 <[exa]> crucify_me: sorry, I just wanted to display to you all the stuff that's important for seeing it
10:59:30 <crucify_me> thanks one moment
10:59:52 * hackage ghc-boot-th 8.2.2 - Shared functionality between GHC and the @template-haskell@library  https://hackage.haskell.org/package/ghc-boot-th-8.2.2 (HerbertValerioRiedel)
11:00:51 <ph88> when i use   cabal install --only-dependencies  does it install stuff system wide ?
11:01:27 <crucify_me> so if c becomes d -> e , that means there are implicit arguments in a type signature
11:02:21 <fishythefish> crucify_me: depends on what you mean
11:02:26 <crucify_me> flip takes a binary func, so I thought b -> (*b* -> c) were the two arguments
11:02:36 <fishythefish> type variables are polymorphic, so it's unwise to assume that a type variable corresponds to a single non-function value
11:02:47 <crucify_me> the two b's
11:02:48 <[exa]> crucify_me: in the signature of `flip id`, there is some redundancy of what 'c' can become... the type system is required to always work with most general types possible
11:02:50 <crucify_me> I see
11:03:20 <fishythefish> crucify_me: one way to see that's not the case is to think about what `flip id` should do, and translate that into a type signature
11:03:42 <crucify_me> please illustrate
11:03:58 <jle`> dminuoso: ah yes, it's definitely based on how Parser's Applicative/Monad instances affect state :)
11:04:08 <fishythefish> well, you tell me - what should `flip id` do? specify how many arguments it should take and what it should do to them
11:05:23 * hackage ghc-boot 8.2.2 - Shared functionality between GHC and its boot libraries  https://hackage.haskell.org/package/ghc-boot-8.2.2 (HerbertValerioRiedel)
11:05:48 <[exa]> crucify_me: we can reconstruct the whole type signature manually if you want :]
11:06:44 <cocreature> ph88: if you’re not in a sandbox, it installs it “user-wide” which on a single-user system is pretty much system-wide
11:06:57 <crucify_me> well, apparently flip id is in the SKI calculus, so it must do something cool.
11:07:01 <ph88> oh oh .. that's not good
11:07:07 <ph88> where does it place files ?
11:07:32 <[exa]> crucify_me: you might want to read this --- https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system
11:07:33 <cocreature> ~/.ghc
11:07:45 <ph88> ok
11:07:47 <crucify_me> flip id changes the application order of an expression
11:07:48 <cocreature> just use a sandbox
11:07:53 <cocreature> or use new-build
11:07:56 <fishythefish> crucify_me: yes, and no. SKI is turing-complete, so you can do some cool stuff in it. you can also do boring stuff
11:08:12 <monochrom> and weird stuff
11:08:20 <fishythefish> crucify_me: okay, so let's be more specific. can `flip id` be applied to any arguments? if so, how many?
11:08:26 <monochrom> The S combinator is more weird than cool, for example.
11:08:34 <crucify_me> ok, forget that, but that's what it does, but I don't know why you would do that
11:09:42 <crucify_me> flip takes its function (id), and flips the two? arguments of (id), which in the prior example are 4 (/)
11:10:00 <fishythefish> yes, but what does `flip id` do?
11:10:55 <crucify_me> so we have flip id 4 (/) 2 end, as I was saying yesterday, we end up with a sort of situation where it becomes like prefix notation (/) 4 2
11:11:03 <crucify_me> and*
11:11:25 <fishythefish> crucify_me: but this is not convincing me that you understand the semantics of `flip id`, only that you've seen an example of its use
11:11:31 <crucify_me> id, I guess, just gets dropped, but I don't really know wtf is going on
11:12:12 <crucify_me> prefix notation, ie the arguments are not flipped
11:12:25 <crucify_me> to say (/) 2 4
11:12:26 * hackage ghci 8.2.2 - The library supporting GHC's interactive interpreter  https://hackage.haskell.org/package/ghci-8.2.2 (HerbertValerioRiedel)
11:12:55 <fishythefish> 2 is not an argument of flip, so let's ignore that
11:13:06 <crucify_me> ok
11:13:22 <fishythefish> in general, `flip id x y` does what?
11:13:33 <crucify_me> y x
11:13:51 <fishythefish> so what must the types of x and y be?
11:14:32 <crucify_me> flops ?
11:14:40 <fishythefish> (we can arrive at the conclusion via a type unification exercise, but it's useful to have intuition about the relation between the type signature and the semantics)
11:14:46 <fishythefish> crucify_me: is flops a type?
11:14:55 <crucify_me> :)
11:15:16 <crucify_me> idk
11:15:33 <jle`> hey so can
11:15:42 <jle`> State/Writer/Reader etc. become pattern synonyms already
11:16:00 <monochrom> Yes.
11:16:01 <jle`> now that we have the ability to specify pattern synonym coverage
11:16:06 <monochrom> Who will do it?
11:16:09 <fishythefish> crucify_me: just from the expression `y x`, you immediately know something about the type of y
11:16:11 <jle`> hmmm
11:17:05 <crucify_me> I don't follow .
11:17:36 <fishythefish> crucify_me: in the expression `y x`, can we have y = 5? y = id? y = const?
11:17:50 <monochrom> An Aesop fable: A community of mice has been taunted by a cat lately. So they convene to design-by-committee a countermeasure. They conclude that tying a bell around the cat's neck will give everyone early warning so everyone can flee in time.
11:18:02 <monochrom> But who will do the tying?
11:18:22 <crucify_me> yes all those because it is first
11:18:32 <fishythefish> crucify_me: really? what does `5 x` mean?
11:18:53 <monochrom> And to think that Aesop predates game theory by like 2000 years.
11:19:48 <crucify_me> ok so in an expression, only id or const would work, otherwise if it were 5 that would just be a list of args
11:20:04 <crucify_me> and not an expression
11:20:14 <fishythefish> crucify_me: so what distinguishes things that work from things that don't?
11:20:41 <crucify_me> order / precedence / 
11:20:59 <fishythefish> does `5` even have a precedence?
11:21:22 <crucify_me> what if I just said order
11:21:28 <fishythefish> what does "order" mean?
11:21:57 <erisco> :t \x y -> x `5` y
11:21:59 <lambdabot> error: parse error on input ‘5’
11:22:11 <erisco> hmm… I feel like that should technically work
11:22:29 <fishythefish> erisco: that's not a valid identifier
11:22:49 <erisco> :t \x y -> 5 x y
11:22:50 <lambdabot> Num (t1 -> t2 -> t3) => t1 -> t2 -> t3
11:22:50 <monochrom> erisco: I think the idea is that inside `` it wants a variable name
11:22:57 <crucify_me> in an expression, we can't have a num in the first place, we need a function, even it is say \_ that can take a Num
11:23:11 <jle`> yeah `` does not work on arbitrary expressions
11:23:11 <monochrom> But I should check Haskell 2010 to be sure
11:23:15 <fishythefish> crucify_me: precisely. `y x` is a function application: we're applying `y` to `x`
11:23:16 <[Leary]> > g x y = x 5 y
11:23:18 <lambdabot>  <hint>:1:7: error:
11:23:18 <lambdabot>      parse error on input ‘=’
11:23:18 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:23:23 <jle`> `` is specifically a part of expression syntax
11:23:34 <fishythefish> crucify_me: so now, what are the types of `x` and `y`?
11:23:35 <[Leary]> > let g x y = x 5 y in g (+) 2
11:23:37 <lambdabot>  7
11:23:56 <jle`> "`someidentifier`" is itself a syntax token or individible unit, i believe
11:24:08 <crucify_me> right, so in what sort of case would flip id become useful.. say if we had ....
11:24:37 <crucify_me> input where the numeral came first for whatever reason?
11:24:43 <fishythefish> :t flip id
11:24:44 <lambdabot> b -> (b -> c) -> c
11:24:46 <fishythefish> :t (&)
11:24:47 <lambdabot> a -> (a -> b) -> b
11:24:59 <fishythefish> > 5 & succ & show
11:25:01 <lambdabot>  "6"
11:25:25 <crucify_me> really trying to get that
11:25:40 <jle`> that's (5 & succ) & show
11:26:24 <fishythefish> crucify_me: we can use (&) as a shorter spelling of flip id
11:26:36 <fishythefish> (&) takes the left argument and feeds it into the function on the right
11:26:50 <monochrom> Inside `` the grammar wants qvarid (alphabetic variable name, optionally with module name) or qconid (alphabetic data constructor, optionally with module name)
11:27:17 <Psybur> That & reminds me of Java's dot
11:27:37 <crucify_me> fishythefish, last point understood
11:27:48 <fishythefish> Psybur: or more generally, F#'s |> or equivalent in other languages
11:27:52 * hackage servant-match 0.1.1 - Standalone implementation of servant’s dispatching mechanism  https://hackage.haskell.org/package/servant-match-0.1.1 (cocreature)
11:27:54 <monochrom> > 10    `       mod                 `  4
11:27:56 <lambdabot>  2
11:28:07 <monochrom> Not one single token :)
11:28:27 <monochrom> Hell, more extreme:
11:28:33 <monochrom> > 10`             mod              `4
11:28:35 <lambdabot>  2
11:28:43 * monochrom is evil
11:28:46 <[exa]> monochrom: will it go multiline?
11:29:01 <monochrom> Yes but I can't show it on lambdabot
11:29:16 <[exa]> :[
11:29:33 <Psybur> > :{
11:29:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:29:40 <fishythefish> crucify_me: that explanation kinda spoils the exercise, though.
11:30:10 <crucify_me> but I'm not crystal clear so not really :)
11:30:32 <crucify_me> in ghci things are different. we can use infix notation for (/)
11:30:56 <crucify_me> but in (/) that won't work? checking now...
11:31:06 <crucify_me> in (/) notation*
11:31:38 <fishythefish> crucify_me: not sure what you mean, but lambdabot/ghci/ghc shouldn't be behaving differently
11:32:17 <crucify_me> right so (/) the function only works in the first place as you illustrated, (/) is not interchangeable with `/`
11:32:47 <fishythefish>  / is the infix version of (/)
11:32:59 <crucify_me> in other words, (/) cannot be used like an infix operator
11:33:09 <fishythefish> sure it can, just remove the parens
11:33:51 <Tuplanolla> It would certainly be nice if you could undo backticks with parentheses and vice versa.
11:34:05 <crucify_me> ok, I see where this is going. the main point is that (/) must be in the first place of the expression, so flip id will do that for us
11:34:17 <Tuplanolla> > 42 `(`(/)`)` 13 -- Like this.
11:34:19 <lambdabot>  <hint>:1:5: error: parse error on input ‘(’
11:34:26 <fishythefish> crucify_me: you're conflating two orthogonal questions
11:34:33 <monochrom> For that to work, they may have to use a different puntuation than backtick.
11:34:35 <Tuplanolla> It's just that it makes looking up fixities impossible.
11:34:47 <crucify_me> ??
11:35:17 <fishythefish> crucify_me: `flip id` isn't about operators, fixity, or even binary functions
11:35:23 <fishythefish> > flip id 4 succ
11:35:26 <lambdabot>  5
11:35:43 <dolio> Why would that be nice?
11:36:01 <monochrom> Because "nice" is subjective? :)
11:36:07 <crucify_me> it just gets the function to the left . 
11:36:22 <monochrom> Because it's a tautology that every idea is "nice" in some sense? :)
11:36:23 <fishythefish> crucify_me: yes, that's what we said before with `flip id x y` = `y x`
11:36:28 <crucify_me> so in what case would we have (input?) where 4 was out of place
11:36:51 <fishythefish> crucify_me: I don't understand the question
11:37:33 <crucify_me> when would we ever write flip id 4 (/) instead of (/) 4
11:37:34 <crucify_me> ?
11:37:36 <[Leary]> The use cases are the same as anywhere else you use flip. flip id isn't special.
11:37:41 <fishythefish> you probably wouldn't
11:38:03 <fishythefish> rather than using flip id, i'd use &, and i'm unlikely to use & most of the time
11:38:03 * hackage base 4.10.1.0 - Basic libraries  https://hackage.haskell.org/package/base-4.10.1.0 (HerbertValerioRiedel)
11:38:38 <crucify_me> so flip id is a good learning tool mostly?
11:38:56 <monochrom> And there is section syntax like (4 /) and (4 `div`) which is more elemetary than even &
11:39:25 <crucify_me> ie good exercise for doing interesting unifications? seriously
11:39:29 <fishythefish> depends on what you're learning - it's another simple type unification exercise, i suppose
11:40:33 <mnoonan> I'd much rather see (&) or flip ($) in real code, or a section of $ if you were applying to to something
11:40:39 <crucify_me> ok , because I was thinking of a case where by a typo or a database or what have you, where for some reason the num came in before the function
11:40:53 <Tuplanolla> > 42 `lookup '/' ops` 13 -- I just like the idea of being able to say this, dolio.
11:40:55 <lambdabot>  <hint>:1:12: error: parse error on input ‘'’
11:41:06 <crucify_me> if that makes sense
11:41:36 <crucify_me> also for this business about SKI 
11:41:44 <fishythefish> crucify_me: it depends. just because you're given x and f in that order doesn't mean you can't still evaluate `f x`
11:41:45 <jle`> Tuplanolla: that's nice but i think it might be hard to unambiguously parse it
11:41:54 <jle`> Tuplanolla: remember that tokenization happens *before* any type checking
11:42:07 <jle`> so if you can have ``-s in ``s, it gets tricky
11:42:11 <crucify_me> right so its one way to evaluate that: x and f
11:42:23 <jle`> 42 `'/' `lookup` ops` 13   ...?
11:42:24 <dolio> That doesn't have any parentheses in it, so I'm not clear how it answers my question.
11:42:25 <bitemyapp> requiring type information to disambiguate a parse tree is one of the Original Sins of C that carried into C++
11:42:38 <Tuplanolla> Bourne shell has this problem, jle`.
11:43:19 <fishythefish> crucify_me: no, the expression `f x` does not have `flip id` or any equivalent in it
11:43:47 <crucify_me> sorry could you reword that?
11:43:49 <dolio> It looks way more complicated than () cancelling `` and vice versa.
11:44:42 <crucify_me> ok right f x is just f x. I was trying to read about how flip id in haskell is : S (K (S I)) K
11:44:53 <crucify_me> not that I know what S (K (S I)) K  is
11:45:32 <fishythefish> crucify_me: it's an expression in the SKI calculus
11:46:20 <crucify_me> ok I'll look at it later. I was under the impression that flip id was essential haskell since it kept coming up .. fishythefish 
11:46:22 <fishythefish> crucify_me: you can expand S, K, and I in the lambda calculus and reduce
11:46:29 <fishythefish> crucify_me: "kept coming up" in what context?
11:47:25 <crucify_me> there are stackOverflow questions about it, more than a few, and here on the channel people saying it was an interesting exercise, leading me to think it was important
11:47:30 <nshepperd> flip id is the same as the operator &, which is sometiems used for stylistic reasons
11:48:18 <crucify_me> right so (&) would allow for the argument to go first
11:48:19 <fishythefish> crucify_me: "interesting exercise" doesn't mean "used often"
11:48:26 <crucify_me> word
11:48:39 <crucify_me> thanks KINDLY ALL
11:49:44 <crucify_me> granted in stackOverflow they all pertained to unifying flip with id and how it is able to compile
11:50:10 <mnoonan> @let x <. f = (f, x)
11:50:12 <lambdabot>  Defined.
11:50:20 <mnoonan> @let (f,x) .> y = f x y
11:50:21 <lambdabot>  Defined.
11:50:40 <mnoonan> > 4 <.flip id.> (+1) -- Tuplanolla 
11:50:42 <lambdabot>  error:
11:50:42 <lambdabot>      Ambiguous occurrence ‘<.’
11:50:42 <lambdabot>      It could refer to either ‘Lens.<.’,
11:50:57 <mnoonan> :|
11:51:49 <Tuplanolla> > 42 <|-flip id-|> (+ 13)
11:51:52 <lambdabot>  55
11:55:32 <Tuplanolla> > 42 <|-(<|-flip id-|>)-|> (+ 13) -- Almost.
11:55:35 <lambdabot>  <hint>:1:21: error: parse error on input ‘)’
11:59:40 <callmecabman> somebody asked about machine learning in Haskell, take a look at HLearn
12:01:28 <callmecabman> I don't know if it's production-ready but the formalism is beautiful.
12:04:22 <cocreature> iirc hlearn is dead and the author recommends that nobody uses it
12:05:29 <cocreature> source: https://news.ycombinator.com/item?id=14409595
12:08:21 <callmecabman> Thanks. Anyway the algebraic structure of models can be exploited in any other language I suppose.
12:13:59 <woodson> I am getting this error using servant https://gist.github.com/Woody88/58f7d2251e222d8871521039ed99b7fc but I dont understand it
12:14:11 <ars23> Hi guys. I have a short question. Does anyone know a library that implements functions for polynomial curve fitting?
12:14:19 <woodson> anyone is able to help?
12:15:08 <Tuplanolla> @hackage levmar
12:15:08 <lambdabot> http://hackage.haskell.org/package/levmar
12:15:10 <cocreature> woodson: you’ll have to show us the code producing that error. in particular the definition of API and the handlers
12:15:11 <Tuplanolla> Try this one, ars23.
12:16:01 <ars23> thanks @Tuplanolla 
12:17:11 <woodson> cocreature: I updated the gist
12:17:20 <tom-lambda> Can you pass a Maybe Int as an argument to the Maybe type constructor? 
12:17:30 <woodson> didnt copy the import however all the other files compile properly
12:17:43 <woodson> I am just getting the error with Lib.hs
12:17:50 <lyxia> :t Just (Just (0 :: Int)) -- tom-lambda ?
12:17:51 <lambdabot> Maybe (Maybe Int)
12:18:43 <tom-lambda> Ah ok so it makes sense as a type a Maybe (Maybe Int)
12:19:43 <woodson> cocreature: My API should be the combination of my server endpoints but i dont know what I am missing..
12:20:13 <byorgey> tom-lambda: right.  exercise: what are all the possible values of type  Maybe (Maybe Bool) ?  (excluding undefined.)
12:20:19 <cocreature> woodson: I’d start by giving "protected" an explicit type signature
12:21:24 <tom-lambda> 16?
12:21:45 <byorgey> tom-lambda: what are they?
12:22:37 <tom-lambda> Not 16 :P
12:23:58 <cocreature> woodson: also the imports would be really helpful. I don’t want to have to guess where things are coming from …
12:25:07 <tom-lambda> 5 - Just True, Just False, Maybe Just True, Maybe Just False, Nothing  ?
12:25:59 <byorgey> tom-lambda: Just True and Just False do not have type  Maybe (Maybe Bool).
12:26:15 <woodson> cocreature: I'm udpdating the gist
12:26:20 <cocreature> woodson: if "Auth" is from servant-auth, you forgot to add the parameters
12:26:57 <tom-lambda> byorgey: Ah so is it just   Maybe Just True, Maybe Just False, Nothing ?
12:27:31 <woodson> cocreature: No its my type, I added the Auth.hs file
12:27:38 <woodson> im done updating the gist
12:29:14 <fishythefish> tom-lambda: you're missing a couple. also, "Maybe" wraps types; "Just" wraps values
12:29:31 <johnBoy> fishythefish, one thing if you have time: this is one thing I'm still unclear on that you wrote : not quite - the first `b` corresponds to 4; the `b` in `b -> c` just states that the function (/) can take 4 as its first argument "
12:29:35 <johnBoy> because ...
12:29:47 <johnBoy> what happened to my nick
12:30:06 <callmecabman> @djinn [a] -> a
12:30:06 <lambdabot> Error: Undefined type []
12:30:11 <crucify_me> << nick
12:30:15 <fishythefish> crucify_me: flip id x y = y x
12:30:38 <fishythefish> so y has type b -> c and x has type b (to reuse the type variables from before)
12:30:39 <crucify_me> right, but 4 is the first b in the signature
12:31:03 <crucify_me> so the function, which must be binary ...
12:31:07 <fishythefish> so here, x = 4 and y = (/)
12:31:31 <crucify_me> takes another b for a division calculation
12:31:48 <fishythefish> crucify_me: you're mixing up a lot of stuff
12:32:01 <crucify_me> really? 
12:32:23 <fishythefish> haskell does not have binary functions. you can argue that the first argument to flip should be considered a binary function, but that spot is already occupied by id
12:32:37 <fishythefish> there's nothing requiring that the spot occupied by (/) must be a binary function
12:32:38 <crucify_me> since flip requires a function that is binary, since id is unary..
12:32:45 <fakenullie> @pl map (\c -> bool toLower toUpper (isLower c) c)
12:32:45 <lambdabot> map (bool toLower toUpper =<< isLower)
12:32:54 <crucify_me> this is what I'm unclear on then
12:33:11 <fishythefish> :t id :: (a -> b) -> a -> b -- crucify_me 
12:33:12 <lambdabot> (a -> b) -> a -> b
12:33:19 <fishythefish> see, id can be a "binary" function
12:33:20 <[Leary]> id can take as many arguments as it wants to, provided you pick the first one well.
12:33:47 <fishythefish> :t id :: (a -> b -> c) -> a -> b -> c -- id can also be ternary, etc.
12:33:48 <lambdabot> (a -> b -> c) -> a -> b -> c
12:33:50 <[Leary]> since id f = f
12:34:09 <fakenullie> :t id id
12:34:10 <lambdabot> a -> a
12:34:32 <hexagoxel> > id foldr (:) [] [1,2,3]
12:34:34 <crucify_me> yes, so within the unified signature for flip id, flip is satisfied by id which is now binary (after the unification.)
12:34:34 <lambdabot>  [1,2,3]
12:34:35 <lyxia> tom-lambda: Maybe is a type constructor. Maybe (Just True) is ill-typed.
12:34:44 <tom-lambda> Ok so Just Maybe Bool is nonsensical because Maybe Bool is a type?
12:35:16 <fishythefish> tom-lambda: yes, and Maybe Just True is likewise nonsensical
12:35:46 <woodson> cocreature: am I missing something?
12:35:54 <fishythefish> it's also nonsensical because in the absence of parens, you're applying Just to Maybe and Bool. you're thinking of Just (Maybe Bool)
12:36:33 <callmecabman> In Haskell types and values are disjoint, that's a good intuition. And values "do live" in types, i.e. you can model them with sets quite successfully.
12:36:49 <callmecabman> (no DataKinds and other stuff)
12:38:32 <tom-lambda> So can you have Just Just True as a value of Maybe (Maybe Bool)?
12:38:47 <callmecabman> Sure. Just (Just True)
12:38:50 <crucify_me> I see, the second num argument for (/) has no place in the flip id signature; the application of flip to id requires two arguments. (/) and its arguments come later. so I was incorrect to think that there should be two arguments viewable in flip id that satisfied the function's (/) requirements.
12:38:52 <tom-lambda> ahhh
12:39:01 <crucify_me> please critique fishythefish ^
12:39:28 <crucify_me> in the flip id *signature
12:39:31 <fishythefish> crucify_me: the first two sentences are correct
12:39:32 <tom-lambda> Maybe type constructor takes one argument so Just Just True doesn't work I guess
12:39:46 <callmecabman> :t Just
12:39:47 <lambdabot> a -> Maybe a
12:39:58 <fishythefish> tom-lambda: not just that but, the Just value constructor also only takes one argument
12:39:59 <callmecabman> :t Just (Just True)
12:40:01 <lambdabot> Maybe (Maybe Bool)
12:40:04 <callmecabman> :t Just Just True
12:40:05 <lambdabot> error:
12:40:05 <lambdabot>     • Couldn't match expected type ‘Bool -> t’
12:40:05 <lambdabot>                   with actual type ‘Maybe (a0 -> Maybe a0)’
12:40:23 <tom-lambda> ahh thanks!
12:40:28 <tom-lambda> Ok Ill try again
12:41:08 <tom-lambda> Just (Just True), Just (Just False), Just Nothing
12:41:36 <callmecabman> almost
12:41:37 <fishythefish> tom-lambda: what else?
12:41:52 <fakenullie> > True == true
12:41:54 <lambdabot>  error:
12:41:54 <lambdabot>      • Variable not in scope: true :: Bool
12:41:54 <lambdabot>      • Perhaps you meant data constructor ‘True’ (imported from Data.Bool)
12:42:58 <cocreature> woodson: can’t spot anything, sry. if you upload your complete project somewhere, I might be able to take a look but this is beyond the size where one can spot bugs by just staring at it
12:43:18 <tom-lambda> Just (Just True), Just (Just False), Just Nothing .... and Nothing?
12:43:28 <crucify_me> right fishythefish 4 *is* an argument to (/). so the second Num arg to (/) is shown as partial application so to speak in b -> (b -> c)  ?
12:43:46 <callmecabman> tom-lambda: exactly
12:43:53 <tom-lambda> :D :D :D
12:44:16 <callmecabman> modulo bottoms (sshhh let's pretend they do not exist)
12:44:55 <fishythefish> crucify_me: no. `flip id` doesn't know that it's going to be dealing with (/), so its type signature is not specialized to match.
12:44:57 <Tuplanolla> Those would simply be `Just (Just undefined)`, `Just undefined` and `undefined`.
12:45:12 <[exa]> crucify_me: what about really going through the full type derivation?  (*wink*)
12:45:14 <tom-lambda> Thanks for exercise helped a ton! Wish there was a repository of exercises like that somewhere
12:45:19 <fishythefish> the types `b` and `b -> c` eventually correspond to the arguments `4` and `(/)`
12:45:31 <fishythefish> the result of that unification is
12:45:35 <fishythefish> :t flip id 4 (/)
12:45:37 <lambdabot> Fractional b => b -> b
12:45:44 <fishythefish> and now you can see where the other argument to (/) goes
12:50:36 <crucify_me> fishythefish, ok, I think I get this. when you do the unification, ghc gives us b -> (b -> c) -> c , which is the most generalized form of flip id, but ghc could read the unification as an id that is actually ternary, and accomodates more arguments.
12:51:01 <crucify_me> does that happen under the hood?
12:51:37 <crucify_me> not most generalized, but most simplified
12:51:47 <fishythefish> crucify_me: most general is correct
12:52:03 <crucify_me> excellent
12:52:21 <crucify_me> your reminder that id can be ternary is what made it click
12:52:22 <fishythefish> in the absence of an explicit type signature, ghc will infer the most general type possible for an expression
12:52:49 <fishythefish> (ignoring monomorphism restriction)
12:53:05 <crucify_me> so *implicit in the signature is the idea that (/) takes up to n arguments
12:53:15 <fishythefish> no
12:53:22 <crucify_me> not (/) but (#)
12:53:35 <fishythefish> what is (#) in your notation?
12:53:46 <crucify_me> any function
12:54:02 <fishythefish> again, this is a good time to remember that all functions are really unary
12:54:33 <crucify_me> right that's what I meant by (b -> c) being partial application
12:55:17 <fishythefish> b -> c is a type signature; it doesn't make sense to say a type signature is a partial application
12:56:20 <fishythefish> and in any case, the (b -> c) in the signature of `flip id` is not the result of partially applying a function (a -> b -> c)
12:58:11 <crucify_me> ok, but as you said re: id having the possibility of being ternary, that is the key to understanding how flip id allows for functions requiring various numbers of arguments.. fishythefish 
12:58:42 <fishythefish> no, polymorphism and currying is how it allows for that
12:58:59 <fishythefish> this is not peculiar to id or flip id
12:59:00 <[exa]> crucify_me: you can also look at what expectations are taken on id in the whole function:
12:59:07 <[exa]> crucify_me: > flip _ 1 div 1
12:59:21 <woodson> cocreature: the Server type from Server is it supposed to accept handlers?
12:59:30 <[exa]> > flip _ 1 div 1
12:59:32 <lambdabot>  error:
12:59:32 <lambdabot>      • Found hole:
12:59:32 <lambdabot>          _ :: (Integer -> Integer -> Integer) -> Integer -> Integer -> t
12:59:37 <[exa]> crucify_me: ^ this
13:00:14 <callmecabman> hey does anybody know how to represent some kind of a subtyping hierarchy? Trying to represent the Chomsky hierarchy for grammars has droven me nuts
13:01:08 <[exa]> callmecabman: how do you want to represent it
13:01:15 <callmecabman> I could've simulate it with typeclasses but I'm interested in data structures. The way it's done now is a number of castFromLowerToHigher functions
13:01:52 <fishythefish> :t ($) -- let's just consider this function for a minute, crucify_me
13:01:52 <[exa]> callmecabman: something like class RegularLang a => ContextFreeLang a ... ?
13:01:53 <lambdabot> (a -> b) -> a -> b
13:01:59 <fishythefish> this is just function application, of course
13:02:05 <crucify_me> ok
13:02:08 <callmecabman> [exa]: yeah
13:02:22 <fishythefish> if you say the first argument (the one of type a -> b) is unary, you are correct in the sense that all functions in haskell are unary
13:02:36 <[exa]> callmecabman: whew, that's easier with the actual automata
13:02:51 <fishythefish> however, that does not mean that the function can't be (+) or any other function which you might otherwise consider binary, ternary, etc.
13:03:16 <fishythefish> > let f = (+) $ 1 in f 2
13:03:18 <lambdabot>  3
13:04:10 <fishythefish> this is because we can specialize the signature when called for - when we apply ($) to (+), we specialize b to Num a => a -> a during unification
13:04:29 <[exa]> callmecabman: I'd go with Regex class having only a type constructor for right-recursive grammar rules, then type constructor for any recursion but only a single non-terminal on the left, etc.
13:05:04 <fishythefish> crucify_me: this is what's going on with flip id. the second argument, a priori, can be *any function*, so it has the most general type (b -> c)
13:05:09 <[exa]> callmecabman: coercions can be done by (recursive) lifting from the previous class
13:05:12 <callmecabman> [exa]: that's the current state of affairs, a bunch of smart constructors and cast functions
13:05:17 <fishythefish> this doesn't mean that c itself can't itself be specialized to a function type
13:05:43 <cocreature> woodson: yes, I have to go but I would recommend to debug this by removing parts of your API type and your handlers to narrow the issue down
13:05:46 <[exa]> callmecabman: how do you differentiate the context-sensitive vs. full turing grammars?
13:05:58 <[exa]> context size restrictions?
13:06:41 <callmecabman> [exa]: n for nonterminals, t for terminals. CFProductionRule t n = n -> [ [Either t n] ]
13:06:51 <crucify_me> right, the unification creates implicit behaviors and allows for more specificity later fishythefish 
13:06:54 <mniip> your datum better be strict or your classes are going to be off
13:07:00 <callmecabman> [exa]: GeneralProductionRule t n = [Either t n] -> [ [Either t n] ]
13:07:16 <callmecabman> any CFProductionRule can be trivially lifted to a general rule
13:07:46 <kritz> hi
13:08:05 <fishythefish> crucify_me: i urge you to be more precise with your language. unification is just about trying to substitute types. it doesn't create behavior.
13:08:05 <mniip> callmecabman, I'm thinking of a thing,
13:08:06 <[exa]> callmecabman: ...and I guess the lifting would be cooler if automated :]
13:08:10 <mniip> some kind of gadt
13:08:23 <crucify_me> it doesn't *create* implicit behaviors, but allows for behaviors that may come later right?
13:08:31 <mniip> that would produce a more general type
13:08:36 <mniip> if you don't use particular productions
13:08:45 <fishythefish> crucify_me: i would just say it sticks to the most general type
13:09:00 <[exa]> crucify_me: you should really, really try the hindley-milner-style type derivation by hand, to see that there's no magic in it
13:09:08 <fishythefish> types and behaviors are somewhat related in that a type constrains the sorts of behaviors you can implement
13:09:14 <typedrat> Is there some sort of pre-existing benchmark of GHC compilation performance?
13:09:17 <kritz> I've written 2048 as a terminal game using brick. My question might be unrelated to this thread, and sry if it sounds dumb, but would there be a way to load bots into my game in other languages. I was thinking that since the only things that need to be shared are my grid - which is a matrix, the score, and keyboard input from the bot, would this be possible?
13:09:18 <fishythefish> but behavior/semantics are more of a value-level thing
13:09:42 <callmecabman> mniip: more details please?
13:09:51 <mniip> I'm not sure I have any
13:09:52 <fishythefish> crucify_me: if you're still confused by the type, i recommend you do what [exa] is suggesting and derive the type of `flip id` by performing the unification yourself
13:09:55 <mniip> just thinking out loud
13:10:01 <fishythefish> we've done enough examples in this channel for you to do this, hopefully :)
13:10:03 <[exa]> kritz: depends on the language the bots are coded in, and on the interface you're planning
13:10:09 <sbrg> kritz: definitely. but what [exa] said.
13:10:10 <kritz> i'd go with python
13:10:14 <ph88> can https://github.com/valderman/selda be used instead of persistent-sqlite ? or do i need both ?
13:10:36 <typedrat> fritz: the way that I'd do it would either be some sort of tiny web server or `foreign export`ing a C API. 
13:10:50 <typedrat> The former would be easier to use from Python but harder to implement, and vice versa
13:10:51 <crucify_me> no the type makes sense, knowing what I now know regarding how (b -> c) for example is the most generalized form that resulted from id being unified.
13:10:59 <callmecabman> [exa]: btw I tried to represent automata like data Automaton i = forall s. (s -> i -> s) (s -> Bool)
13:11:08 <kritz> oh, i see
13:11:09 <[exa]> kritz: I'd in fact suggest having bots as unix executables for the prototype (you pass them gamestate and memory, they give you decision and new memory)
13:11:37 <mniip> callmecabman, that's too general imo
13:11:51 <mniip> you need a finite s
13:11:52 <callmecabman> the fun is that s may be potentially infinite so you get RE languages
13:11:54 <callmecabman> yes
13:12:21 <kritz> since i run my game as stack exec 2048, how would i get a bot in another script if its on the terminal? sry for my newbieness
13:12:32 <crucify_me> (b -> c) is just a function, but there could be n arguments to it, allowed by polymorphism in the ghc, right fishythefish ? thanks [exa] will work on that
13:12:33 <tabaqui1> ertes-w: ping, I've lost history older than an hour
13:12:42 <kritz> i'll look up unix executables, thanks
13:12:57 <fishythefish> tabaqui1: topic has link to logs ;)
13:13:06 <[exa]> kritz: oh you don't use unix. Unix is a great environment for cooperating programs! ;]
13:13:11 <callmecabman> but the idea clicked, because there's the same trick: you can promote any DFA or DFA with stack to such a general automaton
13:13:28 <kritz> oh im on macOS lol, but i know unix is great
13:13:44 <dmwit_> MacOS is pretty unix-y.
13:13:45 <fishythefish> crucify_me: basically, yes -- as long as you remember that, to haskell, all functions actually just take 1 argument
13:14:07 <fishythefish> (polymorphism is not unique to ghc, by the way)
13:14:16 <[exa]> kritz: it should work on MacOS. You just execute the python script, feed it the current game situation, gather the result, repeat
13:14:28 <[exa]> kritz: anyway there are packages for running the python "directly", e.g. https://hackage.haskell.org/package/pyfi
13:14:41 <kritz> damn, thats awesome. Thanks!
13:14:53 <callmecabman> mniip: looks like a natural hierarchy IMO
13:15:01 <mniip> one moment...
13:15:08 <dmwit> A simple text interface is probably going to be easier and more modular than using pyfi.
13:15:16 <kritz> oh
13:15:18 <crucify_me> got it thanks fishythefish [exa]   !!
13:15:18 <[exa]> kritz: the interactive upgrade would be 'execute the script, feed it first data, wait for answer, ....'.
13:15:24 <tabaqui1> fishythefish: rly?) Anyway, he is out, I hope that can find him tomorrow
13:15:36 <dmwit> (more modular: it will make it easy to write a bot in whatever language the bot author wants)
13:15:48 <[exa]> kritz: if it's not performance-critical I also suggest going with text interface (you can easily test that by hand)
13:15:59 <fishythefish> tabaqui1: sure, check /topic for the tunes.org link
13:16:17 <fishythefish> tabaqui1: i think he said to ping ertes since he's at home
13:16:33 <kritz> exa: I guess not. I'll try a text interface
13:16:35 <kritz> thanks!
13:16:38 <dmwit> kritz: http://hackage.haskell.org/package/process-1.6.2.0/docs/System-Process.html#v:readCreateProcess packages up most of what you need
13:17:10 <dmwit> kritz: Oh, `readProcess` is probably even better for starting out.
13:17:42 <kritz> dmwit: Hmm thanks, i'll look at that first then
13:17:47 <[exa]> kritz: as a side note, there's a glorious book called 'the art of unix programming' that will show you how not to overdesign it :]
13:17:59 <mniip> callmecabman, I have this in mind:
13:18:08 <mniip> @let data LHS n t (a :: ()) (l :: Bool) where Emp :: LHS n t a False; T :: t -> LHS n t a l -> LHS n t '() l; N :: n -> LHS n t a l -> LHS n t (If l '() a) True
13:18:09 <lambdabot>  Defined.
13:18:29 <mniip> :t T () (N () (T () Emp))
13:18:30 <lambdabot> LHS () () '() 'True
13:18:45 <mniip> that says '() which means it's a context sensitive lhs
13:18:52 <mniip> :t N () Emp
13:18:53 <lambdabot> LHS () t a 'True
13:19:01 <mniip> that says a which means it's context-free
13:19:17 <mniip> if you put multiple in a list any context-free lhses could be subtyped to the context-sensitive
13:19:24 <mniip> the 'True denotes the validity of the lhs at all
13:19:26 <mniip> e.g
13:19:28 <mniip> :t T () Emp
13:19:30 <lambdabot> LHS n () '() 'False
13:19:34 <tabaqui1> fishythefish: dunno, he has two accounts here, but freenode allows multiple logins
13:19:36 <tabaqui1> I'll contact him later, anyway
13:19:52 <fishythefish> the -w is for work
13:20:25 <mniip> then you go like
13:20:32 <mniip> hmm
13:21:43 <[exa]> mniip: I'm adding that to my list of anti-coercion weaponry
13:24:06 <callmecabman> mniip: black sorcery I feel
13:25:13 <mniip> prepping up a lpaste
13:25:34 <monochrom> [exa]: Do you mean GADT? Yeah it's very nice.
13:26:36 <[exa]> monochrom: esp. the datakinds vs. free type variables
13:28:16 <mniip> which ones are linear again?
13:28:29 <mniip> 'N -> epsilon' or 'N -> Mt' ?
13:30:14 <mniip> ah
13:30:20 <mniip> 'N -> t' or 'N -> Mt'
13:31:51 <dmj`> > [ "bar" | True, False ]
13:31:53 <lambdabot>  []
13:33:07 <callmecabman> can't we just declare a Grammar type with a phantom variable for a grammar label? So we have a label info at the type level but we don't even need it to generate the language because all the information is contained in the production function?
13:40:29 <mniip> @letlpaste 69555822832648192
13:40:30 <lambdabot>  Defined.
13:40:51 <mniip> :t Grammar () [(ALHS (LCN () (LCN () LNil)),ARHS (RCT () (RCN () RNil)))]
13:40:52 <lambdabot> Grammar '() '() ()
13:40:59 <mniip> :t Grammar () [(ALHS (LCN () LNil),ARHS (RCT () (RCN () RNil)))]
13:41:00 <lambdabot> Grammar '() context ()
13:41:06 <mniip> :t Grammar () [(ALHS (LCN () LNil),ARHS (RCT () RNil))]
13:41:07 <lambdabot> Grammar linear context ()
13:41:08 <callmecabman> Also I have a gut feeling that the fact of languages being _generated by grammars_ and _consumed by automata_ must involve some adjoint situation. But it's yet to be proven.
13:41:19 <mniip> here's a link http://lpaste.net/69555822832648192
13:41:32 <ggVGc> apm more lambdabot 
13:41:34 <ggVGc> spam*
13:42:07 <mniip> :t id :: CFG t -> CFG t
13:42:09 <lambdabot> error:
13:42:09 <lambdabot>     • Illegal polymorphic type: forall (a :: ()). Grammar '() a
13:42:09 <lambdabot>       GHC doesn't yet support impredicative polymorphism
13:42:13 <mniip> aw dammit
13:42:52 <mniip> well basically it does work
13:42:59 <callmecabman> mniip: do you think it could be rewritten more naturally in Idris?
13:43:12 <mniip> I don't know
13:43:22 <mniip> it's a messed up subtyping gadt
13:43:41 <mniip> dependent types probably give a cleaner way
13:45:48 <callmecabman> LNil?
13:47:34 <Zemyla> Why is there no view pattern for Ratios?
13:48:02 <Zemyla> There should be one, :%, defined as pattern n :% d <- n GHC.Real.:% d where n :% d = n % d
13:48:24 <monochrom> Yes.
13:48:29 <monochrom> Who will do it? :)
13:50:05 <Zemyla> Someone who can make a GHC Trac account, because for some reason I can't?
13:52:13 <monochrom> What good would a GHC Trac account do for this, apart from just pushing around the "who will do it" question?
13:52:39 <monochrom> And even then, it is libraries@haskell.org that's relevant.
13:55:18 <dminuoso> ertes-w: Yeah that diagram is already burned into my mind, it's not an issue. That mention on comonad is so noted, heard a bit about them I think soon enough it might make sense how (<<=) :: (Comonad f) fits into this.
13:56:34 <dminuoso> Cale: Had to drop out quickly, so Im reading the backlog now. That notion of (f a, f b) -> f (a, b) reminds me of a bifunctor (which I guess gives me that monoidal structure)
14:06:13 * hackage rfc 0.0.0.4 - Robert Fischer's Common library, for all Robert Fischer's common needs.  https://hackage.haskell.org/package/rfc-0.0.0.4 (RobertFischer)
14:07:58 <dminuoso> The one thing I dont quite get, is how () has a monoidal structure on Hask. What is the bifunctor comprised of?
14:08:12 <mniip> the bifunctor is (,)
14:08:24 <mniip> if you mean the Data.Monoid.Monoid monoids
14:08:36 <dminuoso> mniip: Oh no, it was about earlier. Let me just.. one sec.
14:10:23 <dminuoso> mniip: https://gist.github.com/dminuoso/69ba34935f59d612eadf977f070f6768
14:10:30 <dminuoso> This is the converation condensed .
14:12:20 <mniip> dminuoso, the monoidal structure consists of 3 components
14:12:30 <mniip> the category, the bifunctor, and the object
14:12:52 <mniip> in this case it's (Hask, (,), ())
14:13:44 <dminuoso> Ah. So for the sake of discussion (A, ()) is treated as A, so unit is the identity of that monoid.
14:14:00 <mniip> in general a monoidal structure on category C is a bifunctor (*) : C x C -> C, and object I : C,
14:14:33 <mniip> with natural isomorphisms   X * I ~~ X,  I * X ~~ X,  X * (Y * Z) ~~ (X * Y) * Z
14:15:40 <mniip> a lax monoidal functor between two categories with monodal structure, resp (C, *, I) and (D, +, J),
14:15:44 <byorgey> dminuoso: I'm not 100% sure I understood your most recent sentence.  Are you referring to how people often just say "the A monoid" and the identity is left implicit?
14:15:57 <byorgey> mniip: (and some coherence conditions =)
14:16:07 <dminuoso> byorgey: No need, mniip is clearing it up. :)
14:16:13 <byorgey> ok =)
14:16:27 <mniip> is a functor F plus a morphism J -> F I and a natural transformation
14:16:42 <wedify> i'm trying 'stack install sdl2'. it fails with a linker error and suggests i recompile with -fPIC. the error message -> http://lpaste.net/360506. other packages fail with similar messages, like the clock package for example
14:16:51 <mniip> F X + F Y -> F (X * Y)
14:17:12 <mniip> byorgey, corehence conditions?
14:17:24 <mniip> I thought I stated them all
14:17:50 <dminuoso> mniip: Okay the terminology is clear, except for a natural isomorphism. Is that when a natural transformation is isomorphic?
14:18:10 <mniip> in Hask in particular, both () -> f () and (f x, f y) -> f (x, y) are isomorphisms
14:18:36 <mniip> so it's a strong monoidal functor
14:18:43 <mniip> byorgey, oh yeah nevermind
14:18:50 <byorgey> mniip: in general a monoidal structure on a category C is a bifunctor, an object, those natural isomorphisms, AND some coherence conditions that say...
14:18:53 <byorgey> ok
14:19:07 <mniip> yeah
14:19:13 <mniip> the triangle and the pentagon diagrams
14:19:16 <byorgey> right.
14:19:39 <callmecabman> how can a monoidal functor be both strong and lax? do they refer to some different aspects?
14:19:56 <mniip> tensorial strength?
14:20:18 <mniip> X * F Y -> F (X * Y)
14:20:30 <mniip> all haskell functors are strong
14:20:43 <fishythefish> every strong monoidal functor is lax, but not every lax monoidal functor is strong
14:20:44 <mniip> oh I must correct myself
14:20:54 <mniip> in fact in Hask applicatives aren't always strong monoidal
14:21:18 <dminuoso> mniip: Somebody should probably fix this then: https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Applicative.html
14:21:29 <dminuoso> Because they are called `strong lax monoidal functors`
14:21:36 <mniip> no like
14:21:41 <mniip> it is a strong functor
14:21:46 <mniip> and a lax monoidal functor
14:22:04 <dminuoso> mniip: Oh so the coherence maps are just different in both cases?
14:22:17 <mniip> ?
14:22:25 <fishythefish> "strong lax" is not a contradiction. "strong" is a special case of "lax"
14:22:38 <dminuoso> So strong implies lax?
14:22:40 <fishythefish> yes
14:23:12 <dminuoso> Fair enough. thank you mniip I shall put this into diagrams and study this.
14:25:17 <callmecabman> can you give some examples of categories and functors with a "non-default" strength?
14:25:40 <callmecabman> generalising from Haskell to CT is usually an exercise in futility for me
14:26:00 <mniip> haha
14:28:20 <mniip> callmecabman, see if you can make the powerset functor on Set to be strong wrt set product or set disjoint union
14:28:40 <mniip> I can't guarantee it impossible but seems like a good guess
14:29:32 <bwi888888> who
14:31:30 <mniip> ok hmm
14:31:39 <mniip> it is strong wrt +
14:34:09 <callmecabman> X + 2^Y -> 2^(X + Y)
14:37:42 <callmecabman> wtf is this? an inclusion?
14:38:16 <mniip> sstrong wrt * too
14:38:28 <mniip> ok, it's harder than I thought
14:40:26 <mniip> anything fancy if we consider the monoidal category of some preorder with a terminal element wrt the least upper bound operation
14:41:36 <callmecabman> preorders are an order of magnitude simpler than Set, aren't they?
14:43:22 <callmecabman> and what functor?
14:44:51 <jle`> :t ap(==)nub
14:44:53 <lambdabot> Eq a => [a] -> Bool
14:45:49 <jle`> > ap(==)nub $ "hello"
14:45:51 <lambdabot>  False
14:45:55 <jle`> > ap(==)nub $ "helo"
14:45:57 <lambdabot>  True
14:46:05 <jle`> it's kind of weird how prefix operator syntax lets you drop spaces
14:47:20 <glguy> Doing Advent of Code this year? Join the #haskell group! http://adventofcode.com/2017/leaderboard/private 43100-84040706
14:47:33 <baboum> ghci says fromLeft is not defined in Data.Either but I see it in the documentation for base 4.10.1.0, does any-one know where it might be coming from?
14:47:47 <baboum> im using stack to launch ghci, everything was installed in the past week
14:47:47 <jle`> baboum: it is likely that you are not using base 4.10.1.0
14:47:56 <jle`> you might be using a different version of base
14:47:56 <mniip> callmecabman, ok here's the thing
14:48:06 <mniip> consider the preorder category on N
14:48:21 <mniip> terminal object 0, product bifunctor max
14:48:25 <glguy> baboum: Your GHC is out of date compared to that documentation
14:48:31 <jle`> baboum: what version of ghc does ghci say it is using when you start it?
14:48:33 <mniip> if F is a functor that sends n to n+1
14:48:37 <mniip> then it can't be strong
14:49:00 <mniip> because there's no morphism  max(2, F 0) -> F max(2, 0)
14:49:31 * hackage hapistrano 0.3.5.0 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.3.5.0 (juanpaucar)
14:49:36 <mniip> does that make sense
14:49:44 <baboum> GHC 8.0.2
14:49:54 <callmecabman> mniip: wait a minute, let me draw it
14:49:56 <jle`> baboum: ah yes 8.0.2 uses base 4.9 i believe
14:50:25 <boj> yup
14:50:43 <baboum> oh ok, thanks glguy and jle`, will upgrade everything then!
14:50:54 <jle`> baboum: if you're using stack, you can update your resolver
14:51:00 <jle`> to one of the more recently nightlies
14:51:09 <jle`> (all of the lts resolvers still use 8.0)
14:51:12 <glguy> baboum: the most recent stackage lts resolver is just on an older GHC
14:51:14 <jle`> (or lower)
14:51:43 <baboum> im very new to using stack, how does one proceed? im using stack to install things globally but im guessing that's not the way to go
14:52:08 <jle`> stack can be used to install global applications
14:52:16 <glguy> baboum: You can locally define fromLeft in your project and use the newer versions of things when stackage updates
14:52:21 <jle`> if you want to just use ghci outside of a project, you can edit your global stack.yaml
14:52:26 <mniip> jle`, haha you spoiled it for me :(
14:52:33 <mniip> with that ap(==)nub
14:52:42 <glguy> lts is an arbitrary snapshot of packages from the past that can all build at the same time
14:52:51 <glguy> it's updated periodically
14:53:07 <jle`> baboum: what OS are you on?  olinux it's in ~/.stack/global-project/stack.yaml
14:53:11 <jle`> mniip: im sorry ;_;
14:53:17 <jle`> i thought it was cryptic enough that nobody would make the connection
14:53:38 <MarcelineVQ> mniip: jle`: shush you two hehe :>>
14:53:51 <mniip> well I just decided to look at it and I'm like
14:53:58 <mniip> this is a good use for nub
14:53:59 <baboum> jle` i'm on archlinux 4.13.12-1
14:54:00 <mniip> oh wait
14:54:23 <baboum> jle`: thank you for the help
14:54:44 <jle`> baboum: no problem!  you can find the latest snapshots on stackage.com
14:54:50 <jle`> * stackage.org
14:55:04 <dminuoso> jle`: After staring, disecting I finally crunched my way through the monad definition of some/many. I apologize for any inconvenience, turned out my perspective of the Parser monadic interface was not completely done yet.
14:55:07 <jle`> if you clikc on the information for a snapshot, you can see which ghc you are using
14:55:17 <jle`> dminuoso: no problem!
14:55:29 <jle`> dminuoso: yes, the Applicative/Monad part is very important for understanding some/many :o
14:55:49 <mniip> well
14:55:51 <jle`> baboum: if you want to use ghc 8.2 and base-4.10, try using https://www.stackage.org/nightly-2017-12-01
14:55:51 <mniip> part 2 is boring
14:55:53 <ph88> does somebody know of any attempts to automatic translation of imperative to functional code ?
14:55:57 <mniip> just sort your filters!
14:56:03 <jle`> mniip: boo hiss
14:56:05 <jle`> spoilers
14:56:23 <callmecabman> ph88: sure, just use a State monad
14:56:40 <jle`> ph88: i don't think that really makes sense
14:56:50 <jle`> there isn't really a way to translate an imperative alrogirhm to a functional algorithm
14:56:57 <glguy> The first couple aoc problems are simple enough that I'm not sure if they can be spoiled :-)
14:56:58 <jle`> because the two are different algorithms
14:57:48 <mniip> callmecabman, see PM
14:58:18 <jle`> ph88: an imperative algorithm and a functional algorithm could probably both get you to the same place, but i don't know if it's meaningful to translate between the two
14:59:12 <jle`> that's like asking "google maps gave me a ferry/overseas, is there any way i can translate that into an automobile route?"
14:59:22 <dminuoso> jle`: I even took a selfie in that moment of complete revelation. This whole haskell trip is a constant train of "1. Woah what is this. 2. Well this is actually not so hard. 3. I now admit I didnt understand this. 4. After many diagrams I think I got it. 5. Wait.. how does this work. 6. I know accept that I dont know anything, but I can slowly make sense of this program"
14:59:27 <jle`> i mean you can use the two methods to get to the same place, but it's a stretch to say that one is a translation of the other
14:59:37 <jle`> *ferry/overseas route
14:59:48 <dminuoso> And that 6th step seems when learning starts.
14:59:59 <jle`> dminuoso: you're getting to the fun part :)
15:01:20 <mniip> dminuoso, wait till you talk with edward
15:01:24 <jle`> mniip: i actually originally built a frequency map, Map Char Int, heh
15:01:31 <mniip> you'd think you understand what you're asking about
15:01:35 <jle`> before i realized that i could just sort >_>
15:01:36 <mniip> but then a wall of text follows
15:01:36 <ph88> jle`, i found this which gave some insights https://stackoverflow.com/questions/6606240/translating-imperative-to-functional-code .. but i was looking for some actual code to run
15:01:54 <mniip> thoughts not expressible in the basic multilingual plane
15:02:28 <jle`> ph88: i don't think that really does what it claims to do
15:02:42 <jle`> it doesn't translate imperative algorithms into functional algorithms
15:02:52 <jle`> it just writes imperative algorithms using functions
15:04:05 <monochrom> imperative<->functional translations are only meaningful for the simplest and boringest cases, e.g., "my imperative version has only two state variables, and they're both just numbers" <-> "my functional version has only two paramters, and they're both just numbers"
15:04:38 <monochrom> As soon as you involve any aggregate data structure, imperative and functional diverge beyond recognition.
15:04:45 <ggVGc> who needs state anyway
15:05:07 <ph88> right ok, was just curious to see any attempts made
15:06:45 <monochrom> Unless you don't even care about asymptotic efficiency.
15:06:47 <jle`> :e state<CR>
15:06:50 <jle`> ggVGc
15:07:06 <ggVGc> yeeepp
15:07:41 <ggVGc> I found this today, https://hackage.haskell.org/package/auto
15:07:45 <ggVGc> looks pretty interesting
15:07:58 <ggVGc> I think I was trying to invent something similar 2 years ago
15:08:14 <jle`> me too :O
15:09:56 <monochrom> Oh I bookmarked it 1.5 years ago
15:10:32 <monochrom> My "notable Haskell libraries" bookmarks are becoming like my Kindle book collection.
15:10:42 <monochrom> which is becoming like my movie collection
15:10:52 <monochrom> which is becoming like my paper book collection
15:11:13 <monochrom> meaning I collect a lot but they just sit on the shelf and I don't actually read them
15:11:38 <monochrom> I'm growing old. I'm exhibiting hoarding symptoms.
15:13:12 <hpc> the trick is to use it as a queue rather than a hoard
15:13:25 <hpc> and just keep popping from it every so often
15:13:47 <jle`> i keep mine as a heap
15:14:02 <jle`> with priorities
15:14:13 <jle`> every once in a while i have to reshuffle the heap to maintain heap property so it helps me remember what i still have to read
15:14:43 <ph88> https://www.javaworld.com/article/2078610/java-concurrency/functional-programming--a-step-backward.html i guess not everyone is happy
15:17:15 <monochrom> I'm too lazy to RTFA. I'm just going to speculate from the URL.
15:17:42 <monochrom> Adding aspect oriented program to Java would be a step "forward".
15:18:09 <monochrom> And people did try. Where are they now? How many of you even heard of "aspect oriented programming"?
15:18:14 <glguy> I think it was probably smart of the author of that article not to include a comments section. It makes it easier to throw out some garbage and not be as accountable
15:18:28 <baboum> ok so changing the resolver of stack to the latest nightly gives me `Unable to parse cabal file for integer-gmp-1.0.1.0: NoParse "build-depends" 58`
15:18:42 <jle`> ah yeah you probably need to upgrade stack
15:19:04 <jle`> it's kind of unfrotunate that there was a backwards incompatible update to the cabal spec
15:19:14 <monochrom> The fact remains that if you made a wrong turn some time in the past, the correct thing to do now is to take a step back and unroll your mistake, not pressing "forward".
15:19:40 <monochrom> At the very least if you forgot to add lambda 10 years ago, it is a good time to add it back now.
15:19:48 <ph88> monochrom, i heard of aspect oriented programming :P
15:20:27 <baboum> jle`: yet stack tells me i'm already running the most recent version at 1.5.1, I did both upgrade & update
15:20:43 <dminuoso> mniip: Okay, regarding what you said earlier, it means that (,) takes the role of both + and * is that right?
15:20:49 <dmwit> monochrom: Sorry, but the article is even more stupid than you are assuming it is.
15:21:02 <mniip> no
15:21:46 <baboum> mm, ultimately using fromLeft is not critical to my single file snippet, though I do am insterested in seeing how one uses nightlies
15:24:19 <jle`> hm that's definitely a weird bug, i'd suggest asking #haskell-stack or submitting an issue maybe
15:24:45 <jle`> *weird error
15:25:04 * hackage gym-http-api 0.1.0.0 - REST client to the gym-http-api project  https://hackage.haskell.org/package/gym-http-api-0.1.0.0 (stites)
15:26:02 <baboum> jle`: ok! will look deeper into that
15:27:26 <jle`> baboum: after you changed the resolver, what did you do to get that error?
15:27:47 <baboum> stack setup
15:28:18 <baboum> well i also rolled back to lts, then did `stack config set resolver nightly ...` and got the same
15:29:29 <f-a> is there a quick way to map over the `e` of Either e a in base?
15:30:10 <baboum> using
15:30:21 <baboum> using first from Data.Bifunctor, f-a ?
15:30:35 <f-a> thanks
15:32:03 <monochrom> If you use Except e a, there is withExcept
15:32:17 <f-a> good to know
15:34:30 <blink2> hello
15:35:56 <f-a> hey blink2
15:36:01 <f-a> shoot your question
15:37:28 <jason87> How can I define a function that inserts an element in a list at any possible location, and returns a list of all possibilities?
15:37:30 <jason87> insert :: a -> [a] -> [[a]] insert x [] = [[x]] insert x (y:ys) = ... -- todo
15:38:04 <f-a> jason87: you might want to look at inits and tails
15:38:08 <f-a> :t inits
15:38:09 <lambdabot> [a] -> [[a]]
15:38:20 <f-a> > inits [1,2,3]
15:38:21 <lambdabot>  [[],[1],[1,2],[1,2,3]]
15:38:26 <f-a> > tails [1,2,3]
15:38:28 <lambdabot>  [[1,2,3],[2,3],[3],[]]
15:38:42 <jason87> f-a: I have to implement it myself using pattern matching
15:38:59 <f-a> jason87: college assignment?
15:39:05 <jason87> f-a: yea
15:39:52 <f-a> well, if you take the recursive approach
15:39:58 <dmwit> jason87: So implement inits and tails with pattern matching first. =)
15:40:13 <f-a> in every step you can insert your element
15:40:47 <f-a> you need to carry the sectioned list and the accumulated results around
15:40:50 <f-a> does this make sense?
15:41:00 <dmwit> jason87: However, a cute trick you might like in case you decide to go the direct route: `insert x = go [] where go ls [] = ...; go ls (r:rs) = ...`
15:41:38 <dmwit> jason87: This trick (start with an accumulator with some blank state, and modify it as you walk down a list) is super-frequently used.
15:41:54 <dminuoso> Is there a left associative equivalent of $ ?
15:42:08 <fishythefish> dminuoso: `id`
15:42:17 <fishythefish> or just omit it
15:42:26 <fishythefish> f x y = (f x) y
15:42:37 <dmwit> dminuoso: sad, isn't it?
15:42:40 <fishythefish> depending on your use
15:43:04 <dmwit> fishythefish: Now show how to omit it from the left-associative version of `f $ g x $ h y`. ;-)
15:43:20 <fishythefish> dmwit: heh, that's why i immediately had to qualify that statement
15:47:35 <dminuoso> fishythefish: Im not sure what you meant by $
15:47:37 <dminuoso> errr, id.
15:48:06 <MarcelineVQ> dminuoso: he meanns that left associateive $ is plain old normal function application
15:48:54 <hexagoxel> > (+) `id` 3 `id` 5
15:48:56 <lambdabot>  8
15:49:35 <dminuoso> Ahh.
15:50:16 <aplainzetakind> When I put {-# ANN module "HLint: ignore Use camelCase" #-} at the beginning of the file, it does quiet down the linter warnings but instead produces a full ghcmod check and build error, "Parse error on input 'module'". Anyone know why?
15:50:35 <glguy> > (f :: Expr -> Expr -> Expr) `id` g x `id` h y
15:50:38 <lambdabot>  f (g x) (h y)
15:50:55 <fishythefish> :t id :: (a -> b) -> a -> b -- dminuoso: essentially, this
15:50:56 <lambdabot> (a -> b) -> a -> b
15:51:05 <glguy> aplainzetakind: That annotation doesn't go on the beginning of the file
15:51:18 <aplainzetakind> glguy: Oh. Where should it go?
15:51:29 <glguy> after the imports
15:51:47 <dmwit> > (f :: Expr -> Expr -> Expr) `id` g x `id` h y
15:51:49 <lambdabot>  f (g x) (h y)
15:51:56 <dmwit> oh no
15:51:58 <aplainzetakind> Great, thanks.
15:51:59 <dmwit> I am so slow.
15:54:30 <MarcelineVQ> allthough I guess it's not true that application is only left associative $, as $ is lowest predecence and function application is highest
15:55:04 <dmwit> Function application is not the highest precedence, there is one thing higher.
15:55:15 <glguy> record update!
15:55:18 <dmwit> yah!
15:55:30 <MarcelineVQ> that's probably not relevant to the issue ehe :>
15:55:47 <dmwit> No. But nitpicking is too much fun to skip. =)
15:55:51 <monochrom> Although, neither are actually given a precedence.
15:55:52 <glguy> It seems right on for a sequence of nit picking
15:55:59 <MarcelineVQ> but I guess both of those highest precedenses are syntactic
15:56:03 <MarcelineVQ> monochrom: darn u!
15:57:22 <MarcelineVQ> There's papers being written on the good-natured pedantry of this channel I'm sure.
15:57:46 <monochrom> But qualifier is even higher. MyModule.mydefault{x = 4}
15:58:02 <dmwit> https://blog.plover.com/math/pettifoggery.html
15:58:28 <Gurkenglas> directly adjacent letters have even higher precedence
15:59:11 <monochrom> Oh and something I dicovered earlier today. The following is an extreme way to say 10 `mod` 4
15:59:19 <monochrom> > 10`                     mod                  `4
15:59:21 <lambdabot>  2
15:59:51 <MarcelineVQ> how awful :>
15:59:59 <dmwit> > 10 `{- hohum -}mod` 4
16:00:01 <lambdabot>  2
16:00:05 <MarcelineVQ> dmwit: this only confirms my hypothesis that there's a hierarchy of people who do and do not get spinal tap references and how this directly relates to how correct they are in any given situation
16:00:07 <jle`> > "extreme" ++ repeat '!'
16:00:09 <lambdabot>  "extreme!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
16:08:50 <mniip> why say the lengthy
16:08:59 <mniip> > repeat '!'
16:09:01 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
16:09:03 <mniip> if you can say
16:09:10 <mniip> > [0..]>>"!"
16:09:13 <lambdabot>  "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
16:09:20 <mniip> no wait that's the same length...
16:10:08 <monochrom> [0..]>>"!" may run out of memory in the long run
16:11:00 <mniip> I'm not really serious here :p
16:11:14 <monochrom> Not going to happen in one's lifetime but since we're being meticulous...
16:11:39 <monochrom> Oh, I just have nothing better to do at the moment
16:11:45 <mniip> likewisre
16:11:54 <mniip> well actually I do
16:12:04 <mniip> but I'm a weakly willed man
16:17:50 <fresheyeball> hamishmack: what happened to setLocationUnchecked?
16:18:05 <fresheyeball> Is there a new way to set the browser location in GHCJS.DOM?
16:25:59 <hamishmack> It’s just setLocation now
16:37:21 <hamishmack> Turns out the IDL files changed and you now need to do window >>= getLocation >>= (`assign` “some url”) 
16:38:00 <hamishmack> Where assign comes from GHCJS.DOM.Location
16:38:54 <kfish> rw
16:53:33 <yuuko> i just tried to cabal update to create a ~/.cabal on a tiny little vps
16:53:48 <yuuko> and i had to bring multiple swap files online to keep the system stable
16:54:12 <yuuko> turns out cabal-install keeps the full contents 00-index.tar.gz AND 00-index.tar in memory
16:54:15 <yuuko> lolwhat
16:57:51 <burp_> that won't be your biggest problem if you try to build haskell programs ^^
16:59:16 <yuuko> surprisingly to both of us, now that updating is out of the way, builds are going really rather fast
17:27:04 <jle`> > "extreme" ++ fix ('!':)
17:27:07 <lambdabot>  "extreme!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
17:31:05 * hackage easyrender 0.1.1.3 - User-friendly creation of EPS, PostScript, and PDF files  https://hackage.haskell.org/package/easyrender-0.1.1.3 (PeterSelinger)
17:31:54 <benzrf> hmm, i went to haskell.org and saw the code sample in the upper right and i normally dont put spaces around (:) when consing and i briefly thought to myself "wait, the thing on the right of the colon isn't a type"
17:31:57 <benzrf> :-)
17:45:02 <mniip> sad part is
17:45:17 <mniip> that "sieve" takes quadratic time
17:46:06 <mniip> jle`, hmm
17:46:25 <mniip> > fix(>>"!")
17:46:28 <lambdabot>  "*Exception: <<loop>>
17:46:39 <mniip> dammit
17:47:44 <pacak> > fix error
17:47:45 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
20:25:04 * hackage basic-prelude 0.7.0 - An enhanced core prelude; a common foundation for alternate preludes.  https://hackage.haskell.org/package/basic-prelude-0.7.0 (MichaelSnoyman)
20:38:52 * hackage GLUtil 0.9.3 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.9.3 (AnthonyCowley)
20:38:59 <Average-user> Ready to AoC?
20:39:25 <MarcelineVQ> muahaha
20:39:28 <Welkin> AoE!
20:44:22 * hackage hpp 0.5.0 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.5.0 (AnthonyCowley)
20:46:31 <Average-user> r u doing it in Haskell?
20:46:38 <mud> I made it through a whole day of AoC before the second task bored me to tears ... it appears it's not for me.
20:49:08 <boxscape> the third day was a lot more interesting
20:49:13 <MarcelineVQ> any task that is 1/3 solved just after writing  words . lines  is my kind of task
20:49:27 <MarcelineVQ> *map words
20:52:09 <Average-user> jajaja
20:53:47 <MarcelineVQ> kukuku
20:56:22 <Average-user> mud: It happens , I'll use it to learn new languages
20:57:31 * hackage typed-process 0.2.0.0 - Run external processes, with strong typing of streams  https://hackage.haskell.org/package/typed-process-0.2.0.0 (MichaelSnoyman)
21:11:52 * hackage monad-logger 0.3.26 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.26 (MichaelSnoyman)
21:13:23 * hackage http-conduit 2.2.4 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.2.4 (MichaelSnoyman)
21:25:24 * hackage mega-sdist 0.3.0.5 - Handles uploading to Hackage from mega repos  https://hackage.haskell.org/package/mega-sdist-0.3.0.5 (MichaelSnoyman)
21:28:58 * hackage hpp 0.5.0.1 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.5.0.1 (AnthonyCowley)
21:35:16 <siwica> What is the proper terminology: 1.) A type "has" an instance of a typeclass or 2.) a type "is" an instance of a typeclass?
21:35:50 <Welkin> 2
21:35:59 <Welkin> actually, none
21:36:06 <siwica> Because I think I have seen both
21:36:11 <Welkin> hm
21:36:27 <Welkin> I usually think/say "is an instance of"
21:36:36 <Welkin> when I read the types out in my head
21:36:56 <Welkin> for example `Num a => a`: `a` is an instance of Num
21:37:08 <Welkin> er
21:37:15 <Welkin> no, that isn't right
21:37:23 <jcarpenter2> definitely 2 over 1
21:37:27 <Welkin> I guess it could be either
21:37:44 <Welkin> it doens't really matter
21:37:47 <Welkin> call it whatever you want
21:37:58 <geekosaur> I will sometimes say "si an instance of" if I'm not going into detail. more commonly especially if I'm going to talk about spefific methods, "has an instance of [where/which has] ..."
21:38:57 <geekosaur> of late I prefer "has an instance" just to try to avoid invoking OOP
21:39:05 <geekosaur> (in the C++/Java/etc. sense)
21:39:18 <Welkin> geekosaur: you mean in C+=?
21:40:07 <siwica> Using "is" for types and "has" for specific method seems most natural to me as well.
21:41:20 <saurabhnanda> is there anything in hedgehog that will generate random data based on the shape/type of a value?
21:49:54 <Average-user> There was an offbyone error in todays AoC examples ¿Right? 
21:50:33 <Average-user> because, it is supposed to take 5 steps PartA example, but the same function that made me pass partA returns 4
21:54:59 <glguy> Average-user: My function returned the expected 5 for the sample input
21:55:30 <cocreature> Average-user: you probably forgot to count the final step that gets you outside
21:56:12 <cocreature> glguy: how private do you want your leaderboard to be? some people on /r/haskell seem to be doing aoc as well and it might be nice to include them https://www.reddit.com/r/haskell/comments/7hjwj6/24_days_of_syntactic_witchery_day_13/dqrkrn8/
21:58:51 <glguy> cocreature: The main limitation is that we get 150 slots, but it's only at 46 now. If there are Haskell people doing it they might as well get to join
21:59:01 <glguy> at least one of the people in those comments is already on my board :)
21:59:05 <joebetz> anyone know how to rename a sql table using persistent?
21:59:30 <cocreature> glguy: ah didn’t know there was a limit
22:03:18 <Welkin> joebetz: you specify the name at the end of the same line you declare the Type for the table
22:03:48 <Welkin> joebetz: all of the persistent information is in the yesod book on yesodweb.com and on the yesod github wiki
22:05:15 <Welkin> joebetz: https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md#changing-tablecollection-name
22:05:23 <boxscape> if I put a recursive call at the end of a do block, is that optimized into a loop thanks to tail recursion or do I still have to worry about stack overflows?
22:06:15 <Welkin> boxscape: there is no call stack
22:06:29 <boxscape> ok
22:09:42 <cocreature> boxscape: given that we only have recursion and no ordinary loops, it would be pretty bad if tail recursion caused stack overflows :)
22:09:56 <nshepperd> it depends what monad you are in
22:10:08 <boxscape> cocreature: I mostly wasn't sure if it's actually tail recursion if it's the last call in a do block
22:10:10 <boxscape> nshepperd: IO
22:10:21 <cocreature> for IO everything will work like you expect it to
22:10:23 <nshepperd> in IO, recursive call at the end of a do block is equivalent to a loop, yeah
22:10:24 <boxscape> the thing is, I'm getting a stack oveflow, so I'm making a minimal example and posting code
22:11:23 <boxscape> is there some way in which I can tell stack ghci how large the stack should be, to make testing faster?
22:14:15 <nshepperd> theres probably a +RTS option
22:14:24 <cocreature> -K
22:14:33 <boxscape> thanks
22:14:34 <cocreature> but I’ve never tried to use that with ghci
22:14:55 <boxscape> okay, so turns out it was ghci's fault
22:15:00 <boxscape> it apparently doesn't optimize that
22:15:04 <boxscape> compiling it works
22:15:15 <cocreature> also if you compile using -O0?
22:15:34 <boxscape> let me check
22:15:36 <boxscape> I used O3
22:15:57 <boxscape> still works with -O0
22:16:27 <cocreature> GHC only goes up to O2, O3 is the same as O2
22:16:31 <boxscape> (typing "stack ghc -- -O0 file.hs" does pass the flag to ghc, right?)
22:16:33 <boxscape> ah, good to know
22:16:55 <cocreature> it does pass the right flag to GHC but ghc does not recompile if you just change the optimization level iirc
22:17:11 <boxscape> oh, that makes sense, one second
22:17:12 <cocreature> so you probably want to use a "-fforce-recomp" in addition to that
22:17:34 <boxscape> still works
22:18:14 <joebetz> Welkin: thanks, that documentation is helpful. do you know if it's possible to name the table dynamically? I'm guessing it would require dropping TH.
22:18:16 <cocreature> then I wouldn’t worry about it, GHCi’s bytecode interpreter does weird things sometimes
22:18:25 <siwica> What happens under the hood, when I print an underconstrained numeric literal like "1 :: (Num a) => a". Since it's not a concrete type, how does the compiler/the REPL know which show method to call on it?
22:18:29 <cocreature> if you set -fobject-code in ghci it probably works as well
22:18:39 <cocreature> siwica: it defaults to Integer
22:18:44 <boxscape> it's just annoying because it cost me half in hour in advent of code :P
22:19:14 <Welkin> joebetz: I since it is already using TH, of course
22:19:17 <siwica> cocreature: So that's something "hard coded" in the language?
22:19:20 <Welkin> I've never done it myself though
22:19:37 <Welkin> your persistent schema is a TH quasiquote
22:19:55 <siwica> cocreature: Or can this behaviour be somehow generalized when dealing with my own types/typeclasses?
22:20:05 <glguy> boxscape: Are you on the local leaderboard under a different nick?
22:20:06 <joebetz> Welkin: right
22:20:23 <boxscape> glguy: no, didn't know there was a local leaderboard here
22:20:41 <boxscape> glguy: I looked at your code for day3 by the way, was impressed
22:20:42 <joebetz> I thought I could keep the TH and do a migration after each run of my program, renaming the table according to specific parameters of that run, but ... haven't found any function for doing so
22:20:51 <glguy> http://adventofcode.com/2017/leaderboard/private 43100-84040706
22:21:37 <glguy> boxscape: Oh cool :)
22:21:41 <boxscape> glguy: thanks, I'm rank 19
22:22:30 <cocreature> siwica: you can’t use it for your own classes but you can change how it defaults for Num https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 nobody ever does that though
22:35:52 <boxscape> cocreature: fyi, I did something else wrong earlier, it doesn't work with -O0, and also (which I suppose makes sense in that case) doesn't work in ghci with -fobject-code
22:37:07 <boxscape> or wait, I forgot that I switched it from mutable to immutable vectors in the meantime, I'll have to do some more testing
22:37:47 <cocreature> boxscape: assuming you are using boxed vectors, I would suspect that you have a spaceleak
22:38:28 <boxscape> that does seem likely, although I'm not entirely sure why the garbage collector can't get rid of the old vectors
22:41:16 <cocreature> it will be easier to explain that once you show us some code :)
22:42:18 <boxscape> working on it, I just want to make a minimal example which I can post first
22:46:33 <boxscape> okay, so, nevermind, I'm not getting a stack overflow with immutable vectors, it just takes forever
22:46:39 <boxscape> but does eventually finish
22:47:04 <boxscape> which I guess makes sense if the runtime copies the vector every time I update an element
22:47:34 <boxscape> (which is about 25 million times)
22:48:29 <mud> boxscape: I didn't read super close, but you likely want either ST/IO mutable arrays or maybe something like IntMap. Though you might already know that.
22:48:45 <mud> And the other question might be interesting/educational to work out anyway before that.
22:49:12 <boxscape> mud: yup, I already have two versions, one with IO mutable vectors and the other with immutable vectors, the question at this point was mostly just why the immutable version was orders of magnitude slower
22:49:50 <mud> Ah, yeah
22:49:57 <rightfold> Is monomorphization any more difficult in the precedence of HKTs?
22:50:02 <rightfold> presence*
22:58:52 <jle`> did not even make it to top 1000 today :'(
23:01:09 <boxscape> I kinda feel like today's problem was better suited to classical imperative languages, but whenever I think that, someone has usually an amazing functional solution
23:02:18 <jle`> i have a functional solution that i botched initially because we don't have strong enough types in haskell
23:06:43 <cocreature> boxscape: the great thing about Haskell is that you can also just write imperative code when you feel like it :)
23:06:47 <glguy> I used Data.Sequence for my initial submission, but mutable vectors are just so much faster for this
23:07:16 <cocreature> and you can use ST to make sure nobody notices that you’re just writing imperative code :)
23:07:27 <boxscape> cocreature: true, I tried doing that, but that got me into trouble with ghci not doing tail call optimization :/ not a big problem if I'd known that though, I suppose
23:09:08 <mud> I always forget that Sequence can be indexed. I'd think IntMap would be faster though ... right? I should check ...
23:09:37 <boxscape> IntMap is constant lookup time for a constant number of bits per Int, right?
23:10:22 <opqdonut> the thing about intmap isn't the asymptotics, it's the actual performance
23:10:28 <mud> Yes. Though IMO when you're down in the O(lg n), O(1) range, it's more about specifics than it is about generalities.
23:10:38 <opqdonut> Map Int is also constant-time for constant number of bits per Int
23:10:50 <boxscape> ah, ok
23:10:56 <opqdonut> so is Array Int, but you might not have enough RAM :)
23:18:20 <jle`> my zipper based implementation wasn't too slow
23:18:47 <jle`> i mean, there was a noticeable lag
23:19:11 <jle`> 446ms for part 1, 1.12s for part 2
23:19:29 <cocreature> I have 0.33s for part 2
23:20:00 <boxscape> not sure how well the times are comparable, given that the inputs can be quite different
23:20:11 <cocreature> oh yeah good point
23:20:43 <boxscape> but I guess you could calculate the time per step
23:20:59 <jle`> they are probably comparable within order of magnitude
23:22:15 <boxscape> I have 0.1s for part 1 and 0.7s for part 2, with IO mutable vectors
23:23:20 <jle`> so i guess persistent zippers isn't too bad compared to the mutable versions
23:24:44 <MarcelineVQ> It's frustrating to have a working solution, that overflows on the real input ;_;
23:25:02 <cocreature> jle`: yeah I’m actually surprised it’s that fast
23:25:38 <boxscape> same, I was gonna say I'll have to look once you upload it, but then I saw that you just did
23:25:44 <boxscape> at your code *
23:26:32 <jle`> cocreature: the only real difference i can see is that moving the focus is O(n) instead of O(1)
23:27:04 <jle`> but for n's as small as they are in my given input, it shouldn't make a huge difference
23:27:19 <boxscape> I tried a zipper based version at first, but abandoned it because of stack overflows
23:27:22 <jle`> *moving the focus is O(n) on n being the number of jumps
23:27:28 <jle`> *the distance of the jump
23:27:32 <cocreature> jle`: well that’? the only asymptotic difference, I would have expected cache effects to play a bigger role
23:27:36 <cocreature> *that’s
23:27:54 <mud> boxscape: That typically just means you need to be either lazier or stricter. Usually the latter.
23:28:01 <jle`> like branch predictions?
23:28:11 <cocreature> I guess the jumps might be too large for the vector to fit in cache
23:28:17 <boxscape> mud: in my case I'm pretty sure it meant I had to compile it instead of using ghc, I think it was the same problem I had later with vectors
23:28:26 <boxscape> intsead of using ghci
23:28:29 <boxscape> I meant
23:28:54 <jle`> and i haven't even tried adding strictness annotations yet
23:29:29 <mud> Yeah, ghci helps you out a lot less (or not at all?) with strictness fun.
23:30:30 <cocreature> hm my input only has 1090 elements, that should at least fit in my l3 cache
23:32:07 <jle`> yeah i can't seem to make things any faster with manual strictness annotaitons
23:32:31 <jle`> i'm happy i wasted time yesterday building a benchmark suite
23:34:16 <jle`> fsov happy
23:35:19 <jle`> fsvo fsov
23:35:38 <boxscape> well, I just got my zipper solution back from the vim undo buffer, and while it doesn't cause a stack overflow when I compile it, it is one heck of a lot slower with 23 seconds for part 1
23:36:41 <jle`>  -O2 ?
23:36:53 <boxscape> yeah
23:37:26 <jle`> feel free to paste it, i'm curious to where you could have gone wrong
23:37:43 <jle`> or maybe your turing tape is just much more intense than mine
23:37:56 <boxscape> interestingly only 10 seconds for part 2 by the way. but yeah, I'll post it
23:38:24 <jle`> maybe i should make a tumblr for these
23:39:36 <boxscape> a bit messy because I tried to go as fast as possible http://lpaste.net/360513
23:39:49 <boxscape> oh it's currently part 2 by the way, even thought it's in the function called "one"
23:40:11 <MarcelineVQ> faster for part 2? interesting how things work out, my part two was... two orders of magnitude more steps required
23:40:24 <boxscape> same here, I'm not sure why it would be faster
23:43:10 <jle`> perhaps maybe everyone is just too different to compare
23:43:21 <jle`> which makes sense based on how i imagine them generating the sample inputs
23:44:10 <boxscape> possible. regardless of how different the inputs are, though, requiring half the time for a hundred times as many steps is strange
23:45:39 <stevejb> Quick Esqueleto / Persistent question http://lpaste.net/360508
23:46:15 <stevejb> How do I filter by UserId in the esqueleto query
23:46:28 <stevejb> UserId :: EntityField User (Key User)
23:56:05 <stevejb> nevermind, go tit
23:56:06 <stevejb> got it
23:56:55 * liste goes tit
23:58:54 <Rembane> Gostu.
