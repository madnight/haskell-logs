00:42:45 <jobbeggar> Hi What is your opinion on bitcoin ?
00:43:59 <cocreature> that doesn’t seems like a Haskell question
00:44:53 <jobbeggar> How about this haskell can be used for bitcoin mining?
00:45:08 <MarcelineVQ> sure
00:48:48 <jobbeggar> MarcelineVQ:  any experience with that ? I heard we need huge GPU and CPu and lot of power
00:51:49 <MarcelineVQ> last I looked into it there's really not much of a future for someone mining it by themself, you're better off just trading. incidentally haskell is a good language to implement a trading platform in
00:54:03 <mniip> sigh
00:54:05 <jobbeggar> thanks MarcelineVQ  thats what I am planning 
00:54:19 <jobbeggar> hey mniip  you are here  
00:54:25 <mniip> yes
00:54:48 <mniip> you're really putting too little consideration into this
00:55:01 <mniip> it's not something you can just do on a whim
00:55:10 <jobbeggar> yesterday after you told about that online crypto currency trading I was googling and researching all day...Now came to know about bitcoin and like to start trading
00:55:22 <ggVGc> haskell can be used to calculate in which way you might optimally mine cryptocurrencies!
00:55:37 <ggVGc> and it can do it in a 100% typesafe manner 
00:56:22 <mniip> right
00:56:30 <mniip> jobbeggar, what's a scriptsig?
00:58:43 <jobbeggar> mniip:  I didnt create any account/wallet etc just came know to what is bitcoin and all
00:59:25 <ggVGc> you know, it's funny haskell's initial main purpuse was to explore lazy evaluation, and in my view laziness is probably one of haskells least appreciated features and even disliked by many
00:59:38 <ggVGc> while a lot of other things are very appreciated by many
00:59:51 <MarcelineVQ> disliked mostly by premature optimisers
01:00:02 <cocreature> and by people who haven’t understood it :)
01:00:19 <ggVGc> I dunno
01:00:33 <ggVGc> I don't think laziness-by-default is proven to be much better than strictness by default
01:00:47 <ggVGc> it has a whole bag of problems of its own
01:01:52 <jobbeggar> mniip: there ?
01:02:20 <cocreature> ggVGc: not sure how you would prove such a thing anyway but I don’t think the contrary has been proven either :)
01:02:55 <ggVGc> cocreature: right, but in the process of exploring laziness-by-default, haskell brought a lot of other stuff to the table that have proved themselves much more
01:03:05 <ggVGc> that was my point
01:22:27 * hackage typesafe-precure 0.5.0.0 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.5.0.0 (igrep)
01:58:36 <cocreature> how can I figure out the size of a Float? it’s not an instance of FiniteBits so finiteBitSize doesn’t do the trick
01:59:29 * hackage typesafe-precure 0.5.0.1 - Type-safe transformations and purifications of PreCures (Japanese Battle Heroine)  https://hackage.haskell.org/package/typesafe-precure-0.5.0.1 (igrep)
01:59:41 <cocreature> and it’s also not an instance of Bounded so I can’t even use maxBound to infer the size …
02:05:36 <saurabhnanda> is there any way to setup your test suite so that you can run only a subset of your tests (eg what you're currently working on) without worrying about the entire test-suite compiling?
02:06:57 <cocreature> -fdefer-type-errors?
02:07:38 <saurabhnanda> cocreature: that's for me?
02:07:38 <AndreasK> cocreature: Isn't float always 32bit in Haskell?
02:08:21 <cocreature> AndreasK: it probably is for GHC but the docs are explcitely vague on that so there ought to be a way to verify the actual size
02:08:33 <cocreature> saurabhnanda: yes
02:08:46 <AndreasK> https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html#g:7 explicitly says 32bit, but thats GHC specific
02:09:04 <cocreature> https://hackage.haskell.org/package/base-4.10.0.0/docs/Prelude.html#t:Float only says that it is desirable that it’s at least 32bits
02:09:13 <cocreature> which basically doesn’t guarantee anything
02:09:15 <AndreasK> Although I guess in some insane world Float might not be backed by Float#
02:09:25 <saurabhnanda> cocreature: it's not always about type-errors, right? You're changing your core lib logic which triggers a change in 8 test files. But you want to compile and run only one of the 8 files.
02:10:24 <cocreature> I don’t think there is anything for that
02:10:57 <cocreature> I guess you could structure your test suite such that it compiles the individual files at runtime but that seems way too much trouble for the dubious benefit of avoiding a bit of compilation
02:10:59 <saurabhnanda> is it possible via the repl
02:13:01 <AndreasK> cocreature: According to the report float is implementation dependent. I don't think there is a non-ghc specific way to check the bit size reliably
02:14:09 <cocreature> AndreasK: a GHC specific way is fine but I would expect that there is at least some primitive that I can call to figure out the size at runtime rather than having to dig through the source code
02:17:21 <rightfold> cocreature: sizeOf method of Storable does this
02:18:11 <AndreasK> cocreature: There is a storable instance you should be able to use
02:18:37 <cocreature> rightfold: well that’s the size the Storable instance uses. so now you’ve reduced the problem to checking that the Storable instance is a 1-to-1 representation :)
02:19:10 <AndreasK> I
02:19:22 <AndreasK> I'm curious where do you expect it to be non-32bit though
02:19:27 <ggVGc> I think this talk is a fairly well structured critizism of haskell, https://www.youtube.com/watch?v=rvRD_LRaiRs
02:19:30 <ggVGc> has anyone else seen it?
02:19:46 <cocreature> AndreasK: oh I don’t expect it. at this point I’m just curious if there is a non-hacky way to figure this out :)
02:20:10 <rightfold> cocreature: it includes https://github.com/ghc/ghc/blob/master/includes/MachDeps.h you could do that as well
02:20:42 <cocreature> rightfold: ah thanks, that looks right
02:21:46 <AndreasK> I would expect it to be at least as hacky as fiddling with Floats on a bit level
02:22:07 <cocreature> AndreasK: well if there was a FiniteBits instance it wouldn’t be particularly hacky
02:22:09 <cocreature> :)
02:22:16 <cocreature> I wonder why we don’t have that
02:22:57 <cocreature> or maybe we should just have a Float32 type
02:23:33 <AndreasK> There are the Word* types
02:28:06 <rightfold> Maybe we should also have {-# STRICTFP #-} :trollface:
02:31:23 <AndreasK> If I HAD to make a runtime check I would just use the storable instance. If not I would just go by the size mentioned in GHC.Prim.
02:37:34 <siwica> In the Haskell 2010 report a figure is given in which Eq seems to be a base class of Num. However :i Num suggest, that Num does not have any base classes. Why is that?
02:38:23 <cocreature> siwica: because GHC has changed since the Haskell report was written
02:39:21 <siwica> Ok. Do you know of an updated figure of the class hierarchy?
02:40:05 <siwica> I did not know GHC makes such changes without having them formally specified in a report first.
02:41:52 <geekosaur> it's the other way around, the report won't make changes without live testing
02:42:42 <geekosaur> meanwhile ghc is also a type theory playground, and there's no language committee or report specification for that
02:43:31 <siwica> Ok, I see!
02:44:16 <siwica> So the Haskell report is apparently not the proper place to go, to learn about the current state of Haskell...
02:44:31 <geekosaur> correct. in fact it's rather prone to lag
02:44:51 <siwica> That seems a bit different from the usual approach languages have
02:45:02 <geekosaur> the committee that put together H2010 disbanded after several years of failing to do anything. there is a new one now but I don't know an ETA for an updated Report
02:45:32 <geekosaur> but also, the Report was never truly a specification so much as a description of then-current baseline practice
02:45:35 <cocreature> it’s called Haskell2020 so we probably won’t see one before 2020
02:45:48 * liste wonders how many GNU features ended up in C99/C11
02:45:54 <cocreature> but they don’t have the goal of specfying everything GHC’s capable of
02:46:21 <geekosaur> haskell *started out* as a type theory playground, specifically an attempt at making a language that reflected H-M type system and typed lambda calculus, thus pure and lazy
02:46:29 <cocreature> siwica: if you want to learn about the current state of the standard library (which includes typeclasses such as Num and Eq) take a look at the haddock of the base package https://hackage.haskell.org/package/base
02:46:39 <liste> cocreature: do they plan to specify a subset of GHC Haskell?
02:47:20 <siwica> cocreature: Ok, thanks!
02:47:25 <liste> (ie something that doesn't directly conflict with GHC)
02:47:31 <geekosaur> there's a number of things that not only ghc but several past implementations (hugs, nhc98) had, notably multiparameter type classes and functional dependencies, that the committee really doesn't want to commit to
02:50:17 <cocreature> liste: I think so but I’m not sure
02:50:22 <siwica> Also, what is the difference of Hackage and Stackage?
02:50:38 <cocreature> tbh I’m not sure what the goal of Haskell2020 is
02:51:24 <liste> siwica: Stackage only has packages that are guaranteed to build together
02:51:38 <geekosaur> Hackage intends to have everything and is used by computing current dependencies. Stackage is a collection of curated package snapshots
02:54:01 <siwica>  Ok!
02:54:21 <siwica> So unless I know what I am doing Stackage is the better place to obtain packages from?
02:54:39 <geekosaur> provided it has them and you're willing to put up with possibly older versions of things
02:54:51 <siwica> Sure!
02:55:11 <geekosaur> (for example, only the nightly snapshots support ghc 8.2 and some packages are missing from it, because 8.2.1 had some nasty bugs and 8.2.2 was only released a couple days ago)
02:56:00 <liste> you can also mix stackage/LTS and hackage
02:56:28 <liste> with Stack it's simple, not sure how it works without Stack
02:56:39 <liste> (Stack is a build tool)
02:57:28 <siwica> Yeah, I am using stack
02:57:51 <siwica> Ok, that answers my questions for now. Thanks everybody!
02:58:04 <liste> stack uses stackage (or LTS, which is a "more stable" stackage) by default
02:59:39 <siwica> So there is always some kind of human intervention in order to move packages to stackage? Or is this a fully automated procedure?
02:59:59 <geekosaur> "curated"
03:00:18 <siwica> (newer versions of curated packages)
03:00:25 <geekosaur> which means a human is making the call as to whether a package gets added and what version
03:00:45 <cocreature> updating newer versions in nightly snapshots is automatic provided all package that depend on that package work with the new version
03:00:47 <siwica> ok!
03:01:26 <cocreature> lts snapshots only do non-breaking updates (where breakage is defined according to the pvp)
03:11:24 * hackage errors-ext 0.2.1 - Bracket-like functions for ExceptT over IO monad.  https://hackage.haskell.org/package/errors-ext-0.2.1 (warlock)
04:11:07 <kuribas> you can have constraint synonyms with the constraint kind extension.  Could you also have constraint newtypes?
04:12:04 <daey> good morning
04:12:54 <daey> why does 'args <- getArgs; print args;' print [] when i execute './script argument' ?
04:13:32 <daey> i have to pass two arguments to make it print one (the last one). hoogle says its supposed to return the arguments excluding the program name itself
04:13:36 <kuribas> :t getArgs
04:13:37 <lambdabot> error: Variable not in scope: getArgs
04:14:24 <fakenullie> Dae
04:14:32 <fakenullie> daey: script?
04:15:02 <cocreature> daey: how exactly are you testing this? are you executing the binary that ghc produces directly or some wrapper script?
04:16:06 <daey> http://lpaste.net/360446 im just running the ghc output './ghcoutput argument'
04:16:21 <int-e> :t System.Environment.getArgs
04:16:22 <lambdabot> IO [String]
04:16:37 <cocreature> daey: which OS are you on?
04:16:42 <daey> linux
04:16:50 <cocreature> huh weird
04:16:54 <cocreature> works for me™
04:17:01 <kuribas> daey: works for me (on linux)
04:18:35 <int-e> daey: which OS, and does getProgName return the first argument?
04:19:42 <daey> it also returns []
04:19:51 <daey> im on archlinux
04:31:27 * hackage aws 0.18 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.18 (AristidBreitkreuz)
04:35:58 <int-e> daey: http://lpaste.net/1410638577661902848 is on arch linux (x86_64)
04:38:22 * hackage haskeline 0.7.4.1 - A command-line interface for user input, written in Haskell.  https://hackage.haskell.org/package/haskeline-0.7.4.1 (JudahJacobson)
04:40:46 <daey> int-e: i was executing the wrong file~. i had a make file with an -o parameter, but somewhere start using ghc directly
04:58:22 <abhiroop> Can the (->) be an instance of Bifunctor?
04:59:59 <lyxia> Try writing the instance.
05:00:33 <abhiroop> I am not able to
05:01:53 <daey> response <- httpLBS "url" //// let url = "url"; response <- httpLBS url; those two work. what does not work is when the url is a commandline argument. In which case im getting a [Char] given Request type expected
05:02:05 <daey> is that because a commandline argument is not guaranteed to exist during runtime?
05:02:21 <lyxia> abhiroop: It's not a bifunctor.
05:02:28 <int-e> :t Data.Profunctor.dimap
05:02:29 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
05:02:56 <int-e> :t Data.Bifunctor.bimap
05:02:58 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
05:03:17 <int-e> abhiroop: it's an instance of Profunctor. (spot the difference)
05:03:51 <abhiroop> lyxia: inte: i can see the difference between profunctor and bifunctor
05:03:59 <int-e> @djinn (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
05:03:59 <lambdabot> f a b c d = b (c (a d))
05:04:04 <abhiroop> profunctor is contravaariant in its first argument
05:04:23 <abhiroop> not the case for bifunctor which is covariant in both of its arguments
05:04:29 <int-e> @djinn (a -> b) -> (c -> d) -> (a -> c) -> (b -> d)
05:04:30 <lambdabot> -- f cannot be realized.
05:04:50 <abhiroop> my actualy confusion arose from a typeclass called monoidal which I read in a paper
05:04:55 <abhiroop> Here it goes:
05:04:56 <abhiroop> http://lpaste.net/360447
05:05:29 <abhiroop> Looking at this typeclass I thought the `par` function looks exactly like a bifunctor
05:06:01 <abhiroop> so what is the difference between bifunctor and the monoidal typeclass
05:06:10 <danielzx> Hello! For help in regards to error messages, do I just paste the code into ipaste.net/new/haskell?
05:06:34 <abhiroop> when I asked the author of the paper he said (->) is an instance of Monidal while it is not so for Bifunctor
05:07:09 <int-e> abhiroop: it does, but it abstracts from the inner arrows in bimap :: (a -> b) -> (c -> d) -> (p a c -> p b d), not from p (p is instantiated by (,))
05:08:07 <int-e> abhiroop: what I'm trying to say, Monoidal for (->) corresponds to Bifunctor for (,).
05:08:36 <abhiroop> int-e: you are correct
05:08:57 <abhiroop> int-e: so what is monoidal capturing
05:09:03 <lyxia> danielzx: lpaste.net yes
05:09:13 <abhiroop> it has an additional identity function
05:09:51 <danielzx> And then?
05:10:01 <danielzx> paste the link here?
05:11:11 <lyxia> danielzx: yes. It's also recommended to paste the code with it, and better if it's such that we can just copy paste and compile it.
05:15:29 <wizek[m]> Hey, what is the name of that which is similar to the djinn tool and starts with "ex*"?
05:15:40 <MarcelineVQ> exference
05:15:49 <wizek[m]> that's the one, thanks MarcelineVQ 
05:16:41 <danielzx> I'll send the link the with the code in hand and the error message (it's two files and the second file shouldn't have to be messed with). I'm having a hard time comprehending these errors and so have no idea what to fix (first CompSci student doing Haskell as our first programming language, I don't know why). I would really appreciate it if someone could explain to me what the error messages mean but not give a clear answer to them
05:16:42 <danielzx> http://lpaste.net/7546558813847945216
05:16:44 <danielzx> thank you!
05:20:54 <royal_screwup21> is there an easy way to open a  file from ghci?
05:23:40 <danielzx> royal_screwup21: You can right-click on the file and there should an option to open in GHCi directly 
05:23:50 <MarcelineVQ> danielzx: your line 96 (pairsCount) doesn't reflect the error's version, in fact it should be a parse error as it is. is this the actual code that gave you these errors?
05:24:16 <MarcelineVQ> royal_screwup21: open as in read the contents?    filedata <- readFile "thefile.txt"
05:24:43 <royal_screwup21> ah no, I mean opening it on a text editor like sublime
05:25:29 <danielzx> MarcelineVQ: I made some changes to experiment and that was one of them. What was there was "pairsCount(pair:remainder) = pairsCheck listofTallies
05:27:04 <kahlil29> I usually use "restrict" (from Opaleye) to perform select queries with conditions where I want to restrict all entries with the value of a certain column having to match some value I provide (where clause in SQL). How do I do the same if I have a LIST of values that I want to match against, not just a single value.  
05:28:16 <MarcelineVQ> royal_screwup21: do you want to open the source file you're working on, or you want to launch a text editor editing some entirely different file?
05:29:02 <royal_screwup21> an entirely different file
05:29:05 <MarcelineVQ> actually I'm not sure it matters to ask that, I think the step is the same. make use of the :edit feature of ghci
05:29:17 <MarcelineVQ> you can learn about it with :?
05:29:31 <royal_screwup21> cool thanks MarcelineVQ
05:32:42 <lyxia> danielzx: pairChecks has  two arguments and returns a list of tallies, in pairsCount you use it with one argument and expect a single tally
05:33:17 <lyxia> danielzx: there is also no listOfTallies to speak of (second error)
05:35:00 <danielzx> In other words, it's not defined?
05:35:06 <lyxia> yes
05:35:31 <danielzx> alright
05:35:56 <danielzx> I'm guessing I need to define it as a list of PairsTallies for it to work then?
05:39:01 <lyxia> or you could replace it with something else.
05:39:34 <danielzx> okey
05:39:54 <danielzx> anything else?
05:40:15 <kuribas> Is there any use for type/data families outside class instances?
05:40:24 <lyxia> danielzx: to understand the third error you need to look at the whole expression
05:41:32 <lyxia> danielzx: (:) is the list constructor, so it expects one element on its left, and a list of elements of the same type on its right
05:42:06 <danielzx> oh, that's not what I want to do
05:42:50 <lyxia> danielzx: also, [(pair), 1] is a list of two elements, that doesn't look like what you want to do either.
05:43:28 <danielzx> I want it to be a tuple with the pair as the first element and 1 as the second element
05:43:34 <lyxia> By the way these parentheses around pair are redundant
05:43:44 <lyxia> (pair, 1)
05:43:49 <lyxia> brackets matter
05:45:09 <danielzx> oki, so [(pair, 1)] instead?
05:45:55 <lyxia> that's a list, not a tuple
05:46:25 <danielzx> But I want to create a list with a tuple inside it
05:46:41 <lyxia> ([(pair, 1)] : ...)  is a list of lists, not a list of tuples
05:48:15 <saurabhnanda> is there any package that trawls through your source-code discovering type-class instances for testing, eg. ToJSON/FromJSON round-tripping?
05:48:54 <danielzx> Oh, okey then. So I have to rewrite that part to become a list of tuples instead?
05:49:56 <danielzx> lydia: if I remove the brackets, does that make it a list of tuples?
05:50:05 <lyxia> it does
05:50:26 <danielzx> gotcha
05:50:28 <danielzx> thank you
05:50:30 <lyxia> ((pair, 1) : ...) is literally a list with the tuple (pair, 1) as its first element
05:50:51 <lyxia> danielzx: you could also write [(pair, 1)] ++ ..., perhaps that's what you were thinking?
05:50:51 <danielzx> understood
05:51:46 <danielzx> somewhere along those lines. I just thought I had to have those brackets in order to tell Haskell that's a list of pairs
05:51:51 <danielzx> of tuples*
05:51:52 <lyxia> (:) and (++) are two related but still different operations
05:52:52 <danielzx> for the third error, replacing (:) with (++) is the correct method, since I want to tell Haskell to perform pairsCount again after creating the tuple
05:53:08 <lyxia> Adding brackets doesn't only tell that it's a list of pairs, it *constructs* a list of pairs
05:53:24 <lyxia> danielzx: one is not more correct than the other.
05:53:51 <lyxia> they produce the same result
05:54:05 <danielzx> That was meant to be a question, sorry
05:54:51 <lyxia> Okay. I guess that counts as an answer then :)
05:54:56 <danielzx> Then I'm guessing I shouldn't be using that command at all for what I'm trying to achieve?
05:55:38 <lyxia> what command
05:56:36 <danielzx> (:) and (++)
06:00:23 <lyxia> From the name of the function gatheringWordTallies, I guess you're right.
06:00:39 <lyxia> BTW, (:) is a constructor, (++) is a function.
06:01:06 <lyxia> and constructors are also functions
06:01:22 * hackage servant-quickcheck 0.0.4 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.4 (AlpMestanogullari)
06:01:50 <lyxia> There are no things called "commands" in Haskell.
06:01:50 <danielzx> How many arguments do they take in?
06:02:14 <lyxia> two. argument1 : argument2, argument1 ++ argument2
06:02:24 <danielzx> Okay, that's good to know. Wasn't sure what they were called so I used just a general term
06:03:28 <lyxia> Okay that's fine.
06:04:55 <danielzx> lydia: So for calling the pairsCount function with the argument remainders, I can't use (++) to call on it after (pair, 1) has been generated?
06:07:22 <lyxia> uh, why are you trying to call pairsCount
06:11:33 <danielzx> So that's the list with hold the pairs inputted by the user
06:11:52 <danielzx> and I want to run a recursion through that whole list
06:12:35 <saurabhnanda> curious thing to find in haskell-src-exts docs: "a module consisting of a single XML document. The ModuleName never appears in the source but is needed for semantic purposes, it will be the same as the file name."
06:12:43 <saurabhnanda> does Haskell support embedding of XML documents?
06:13:09 <Athas> Only if you use quasiquotes/Template Haskell.
06:14:43 <lyxia> danielzx: perhaps you could compare what you're trying to do with theCounter/tallyCheck
06:15:06 <lyxia> danielzx: are you not trying to do the same, but for pairs instead of words?
06:15:17 <danielzx> exactly
06:17:49 <danielzx> wait, does that mean I can mostly reuse the code from tallycheck/theCounter for this program (granted that I adjust it for pairs instead of words etc)
06:18:02 <lyxia> danielzx: wordCount calls theCounter which calls tallyCheck,  by analogy  pairsCount calls gatheringWordTallies which calls pairsCheck
06:18:06 <lyxia> yes indeed
06:18:26 <danielzx> wow.... lol
06:18:39 <danielzx> Should have thought of that earlier 
06:18:53 <lyxia> It doesn't seem that the code for words uses the fact that they are words anywhere
06:19:23 <danielzx> Ok I'll try that then!
06:19:53 <lyxia> it's possible to write this function just once for both cases, but perhaps your class hasn't gotten to that point yet
06:20:35 <danielzx> We have just started learning higher-order functions
06:21:30 <lyxia> They're cool.
06:21:42 <danielzx> agreed.
06:23:39 <ggVGc> I don't use functions
06:23:49 <ggVGc> I only use type constructors
06:25:04 <danielzx> lydia: on line 47, could you explain to me why [(word,1)] is there in the end? (my group partner wrote that part)
06:25:46 <danielzx> lyxia: on line 47, could you explain to me why [(word,1)] is there in the end? (my group partner wrote that part)
06:29:14 <lyxia> danielzx: the second argument is the tally "so far". At line 47, the tally so far is empty (you have seen no words yet), after getting a word, the tally so far is that you've seen word once.
06:29:29 <lyxia> danielzx: that line needs fixing though.
06:29:57 <simendsjo> Running `stack exec` takes a lot of time on nixos. Running `stack exec doesnt-exist` takes 3.33 seconds. Does someone know what the cause of this is and how I can fix it?
06:30:07 <danielzx> It complies and works just fine, but there are places you optimize it, you mean?
06:30:14 <danielzx> could*
06:31:24 <lyxia> danielzx: I mean it won't run just fine.
06:31:26 <ggVGc> wait what, I just found out about view patterns
06:31:38 <ggVGc> I had no idea haskell had the equivalent of F#'s active patterns
06:31:57 <DigitalKiwi> HASKELL HAS EVERYTHING
06:32:22 <ggVGc> oh really
06:32:22 <lyxia> danielzx: I guess the tests they gave you are too weak
06:32:28 <ggVGc> where are fully dependant types
06:32:29 <danielzx> lol
06:32:39 <danielzx> We are first years, so kinda understandable
06:32:45 <DigitalKiwi> those aren't a thing!
06:33:00 <ggVGc> fair
06:34:00 <saurabhnanda> how does one start a "stack ghci" session in the test environment?
06:34:31 <lyxia> what about stack ghci --test
06:35:56 <saurabhnanda> is this not documented in `stack ghci --help`
06:36:46 <saurabhnanda> it works, thanks
06:36:53 <saurabhnanda> but it doesn't seem to be in the help message.
06:38:35 <lyxia> I can see  "--[no-]test"
06:42:23 <danielzx> lyxia: for the case of their being a reverse order of the pair compared to the pair which is being checked and I still want it to be correct, do I just do pair == reverse (the head of the list)?
06:43:36 <lyxia> reverse is for lists, not pairs
06:44:07 <Rembane> Good morning, I have two monoids which I want to combine so I can foldMap through a datastructure once. I have a feeling it should be simple, that I just have missed something, but I haven't found one yet. Do you have any directions?
06:44:59 <lyxia> danielzx: use pattern matching on the the head of the list, (x, y) : remaining, then you can write pair == (y, x) and pair == (x, y)
06:45:41 <lyxia> Rembane: the product of two monoids is a monoid
06:46:02 <Rembane> lyxia: That's very nice. So the Product Monoid is the way to go?
06:46:13 <lyxia> By product, I mean (,)
06:46:23 <Rembane> Ah, of course.
06:46:42 <lyxia> So that's the way to go
06:47:58 <Rembane> Thank you
06:50:01 <saurabhnanda> is there any library that can read .HI files?
06:50:21 <Rembane> Okay, this is how easy it was: foldMap (\a -> (Minimum a, Maximum a)) [1..100]
06:50:30 <Rembane> Or any monoids you like. 
06:50:40 <MarcelineVQ> Rembane: doing advent?
06:51:09 <Rembane> MarcelineVQ: Totally. :D
06:51:39 <Rembane> MarcelineVQ: And my friend accused me of coding Python in Haskell, so I upped my game.
06:52:33 <MarcelineVQ> :t (Min &&& Max) -- ehe, drop his jaw with fasncy symbols
06:52:34 <lambdabot> b -> (Min b, Max b)
06:52:48 <Rembane> Lovely. 
06:52:53 <Rembane> Looks like Control.Arrow.
06:52:58 <MarcelineVQ> yep
06:53:40 <Rembane> Nice stuff
06:54:58 <ongy> :t foldMap
06:54:59 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
06:55:23 <MarcelineVQ> I like that foldMap, mine's not so elegant
06:57:00 <MarcelineVQ> Rembane: join the board if you haven't  http://adventofcode.com/2017/leaderboard/private/view/43100  dunno if that link is the correct way to share that
06:57:29 <lyxia> The /topic has a code
06:57:34 <danielzx> lyxia: Are x and y the two elements within each pair? (cause I'm pattern matching pair with a list of pairs) 
06:58:21 <lyxia> ((x, y) : remaining) is a pattern for a list of pairs, where the first element is a pair with components x and y.
06:59:10 <inkbottle> Could not find module ‘System.Directory’: http://lpaste.net/5951713542741688320
06:59:43 <MarcelineVQ> simendsjo: that time is a result of stack having to set up an environment based on the project in scope and then search it entirely for a program that  doesn't exist, I'm not on nix and it takes 4s here. it's probably not something you can avoid unfortunately
07:00:51 <Rembane> MarcelineVQ, lyxia: Thank you!
07:02:03 <danielzx> okay, thank you!
07:03:20 <lyxia> inkbottle: are you inside a stack project?
07:03:29 <danielzx> lydia: So in my case, x = the tuple and y = the int ?
07:03:40 <inkbottle> lyxia: a dummy one but yes
07:04:19 <inkbottle> lyxia: stack list-dependencies, directory is in the list
07:04:47 <inkbottle> lyxia: but can't import it with ghci
07:05:00 <inkbottle> lyxia: in the very same directory
07:05:10 <lyxia> danielzx: oh yeah. you can keep pattern matching on the nested tuple with  ((x,y), n) : remaining
07:06:37 <danielzx> I assume I rename n for anything else?
07:06:41 <danielzx> can*
07:07:03 <lyxia> inkbottle: it seems list-dependencies contains all transitive dependencies too
07:07:20 <inkbottle> lyxia: OK
07:07:22 <lyxia> inkbottle: those that you can access are only those listed in the .cabal file
07:07:45 <inkbottle> lyxia: OK, makes sense
07:07:48 <lyxia> danielzx: yes, x, y, n, remaining, are any names you want
07:08:07 <danielzx> cool
07:10:29 <danielzx> lyxia: http://lpaste.net/6789284508228124672 Here's the new version of pairsCheck. Overall, will Haskell accept this or are there any big syntax errors? (lpaste gave me some errors but not sure if I should follow those)
07:11:51 <MarcelineVQ> it's advise about  snd (x,y)  is good advise
07:12:02 <inkbottle> lyxia: I added directory to the dependencies of Main.hs (though Main does nothing); and then importing directory did work; Thanks (I wouldn't have found all by myself)
07:12:41 <lyxia> danielzx: I don't know, you can just compile and see.
07:12:47 <danielzx> fair enough
07:12:56 <MarcelineVQ> inkbottle: I think if you need something you don't have you can also specify it (with stack) when you invoke ghci    stack ghci --package directory
07:13:02 <fakenullie> danielzx: second definition returns wrong type
07:13:38 <inkbottle> MarcelineVQ: Yes, good point
07:14:20 <danielzx> fakeunllie: you mean line 3
07:14:22 <danielzx> ?*
07:14:22 <lambdabot> Maybe you meant: v @ ? .
07:14:26 <fakenullie> Yes
07:14:34 <fakenullie> And first too
07:18:07 <danielzx> fakenullie: Should I put brackets there then to make sure it returns a list?
07:19:34 <fakenullie> I'm sorry, but you don't seem to understand Haskell fundamentals, you should work through some course (like the Haskell Book)
07:21:12 <danielzx> oh
07:22:16 <fakenullie> In short, in every case you needed to return the same type
07:22:54 <fakenullie> Could be like empty list, or list with items of exact type you've specified in the signature
07:23:25 <fakenullie> Empty tuple and tuple with some contents are different types
07:24:10 <MarcelineVQ> Rembane: man you're givin me all kinds of advent ideas with that fold
07:25:05 <Rembane> MarcelineVQ: ^____________^
07:25:09 <Rembane> MarcelineVQ: Use it responsibly.
07:25:50 <MarcelineVQ> most of them involve TypeApplications <_<
07:27:11 <Rembane> ^^
07:28:10 <danielzx> okay, thank you for explaining it. I thought as long as it's the same type it would be finie
07:28:13 <danielzx> fine*
07:29:00 <fakenullie> danielzx: it's not the same type
07:30:08 <sgronblo> Hello, trying to use listArray and ghc is complaining that it "Could not deduce (IArray a0 Int)"
07:30:57 <sgronblo> So I guess I need to tell ghc to just use Array
07:31:23 <sgronblo> But not sure exactly where to put it. I really wish Haskell had learned something from Elm's error messages already.
07:31:32 <danielzx> okay
07:31:48 <sgronblo> This message is telling me only what's wrong but gives only a vague indication of how to fix it.
07:32:16 <fakenullie> GHC messages are pretty good, if you consider that it's type system is much more complex than elm's
07:33:54 <sgronblo> Anyway, thats just my opinion. Now how can I tell Haskell what instance of IArray to use?
07:34:34 <fakenullie> I guess you can specify it in function signature, but I don't know anything about IArray
07:35:11 <sgronblo> The array type is not included in the signature
07:35:19 <sgronblo> It's completely internal to the function
07:36:31 <fakenullie> You can specify type for expressions inside function
07:36:40 <danielzx> lyxia: compiled the code and got a few errors. For the errors in regards to listofTallies, if I just declare its type, that would sole the (Variable not in scope) issue, correct? 
07:36:56 <fakenullie> (expr :: Type)
07:37:26 * hackage bisect-binary 0.1 - Determine relevant parts of binary data  https://hackage.haskell.org/package/bisect-binary-0.1 (JoachimBreitner)
07:38:48 <sgronblo> fakenullie: yeah thats what i tried. but then i needed to enable scopedtypevariables, and then the i type parameter i used is apparently different in the sub expression compared to the function signature so i tried to put a :: (i ~ i2) => Array i2 e, but then ghc told me i needed to either enable GADTs or TypeFamilies and then I started wondering if I was doing it wrong.
07:39:40 <fakenullie> That is beyond my knowledge
07:40:35 <sgronblo> fakenullie: yeah mine too
07:42:58 <erisco> sgronblo, state the problem again please. I wasn't here.
07:44:48 <sgronblo> erisco: Trying to use IArray but now I get to the point where Haskell can't deduce what data type to produce for my IArray
07:45:13 <erisco> okay… paste your code and error message please
07:47:09 <sgronblo> So I tried specifying it like this: let (nums :: Array i Int) = listArray (0, length s) $ map (\c -> read [c]) s
07:47:38 <sgronblo> Then getting "You cannot bind scoped type variable i"
07:47:55 <sgronblo> "in a pattern binding signature"
07:48:00 <erisco> it looks to me like s is a Char
07:48:20 <sgronblo> s is a string
07:48:35 <sgronblo> thats why i wrap each c in a [] to be able to call read on them
07:48:49 <erisco> okay
07:49:00 <sgronblo> I want "3465" -> Array of [3, 4, 6, 5]
07:50:33 <erisco> it should be  (0, length s - 1)  for the bounds
07:50:41 <danielzx> http://lpaste.net/4312447778534981632 could someone go through this list of errors with me? the last one in particular
07:51:52 <sgronblo> erisco: yeah apparently the examples use (1, length s)
07:52:04 <erisco> and   nums :: Array Int Int  because  length s :: Int
07:52:24 <sgronblo> aaah oh thats of course true
07:53:24 <erisco> danielglh, well usually you want to solve the first error, because later errors may be dependent on the first error
07:53:26 <barrucadu> danielzx: It's generally best to fix errors from the top down, as due to type inference earlier problems can cause later ones
07:54:00 <danielzx> I know, I just meant that I'm most lost on the last one
07:54:02 <danielzx> ^^
07:54:02 <erisco> though I might skip straight to this scope error for  listofTallies :: [Pairs]
07:54:04 <sgronblo> erisco: so basically my call to length s to determine the bounds ties the index type to Int
07:54:23 <erisco> the later errors may as well be nonsense if they are dependent on previous errors
07:55:09 <erisco> there isn't a lot of point to going down "this is wrong, but assume it isn't, and that is wrong, but assume it isn't … then here is what we can say about this final error"
07:55:40 <danielzx> erisco: What does it mean? that it can't find PairsTally and therefore can't define listofTallies?
07:55:58 <erisco> sgronblo, yes
07:56:35 <barrucadu> danielzx: There's just nothing called listofTallies.  What do you expect it to be?
07:57:06 <erisco> danielglh, uh, well reading your title I see you intend to define this later… I advise adding  listofTallies :: [Pairs]; listofTallies = undefined   to your file then
07:57:22 * hackage criterion 1.2.5.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.2.5.0 (ryanglscott)
07:57:26 <erisco> or  listofTallies = error "listofTallies undefined"  if you're cautious
07:57:44 <danielzx> A list of all my PairTallies after gatheringWordTallies has finished going through the inputted list
07:58:24 <erisco> sgronblo, there is genericLength in… Data.List I think… which gives you any Num
07:59:14 <erisco> though… well I am confused danielzx 
07:59:32 <erisco> you say you want to define  listofTallies with a type declaration and function, which I assume means it should be a TLD and a function
07:59:36 <erisco> (top level definition)
07:59:56 <erisco> so, then why is "listofTallies" also used as a variable name in gatheringWordTallies?
08:02:50 <danielzx> cause the list of tallies is the list that will contain the pairtallies and will be added in by the function gatheringWordTallies. 
08:02:56 <danielzx> erisco
08:03:41 <erisco> that doesn't make any sense to me… maybe start from the beginning. What is the problem your program is trying to solve?
08:05:23 <danielzx> This function pairsCount want to take a list of pairs (in the form of words) inputted by the user and return a list of the with tuples and include the pair and each time it's been repeated in the inputted list represented as an Int.
08:06:19 <erisco> a list of pairs in the form of words… can you give an example of that?
08:06:30 <danielzx> I can send the entire code if it makes it easier for you to understand?
08:07:04 <erisco> that is a good idea but also I'd like to see an example of what "a list of pairs in the form of words" is
08:08:40 <danielzx> like pairsCount [(("car", "snow"), ("snow", "car"), ("pen", "crack")] returns [("car, snow", 2), (("pen", "crack"), 1)]
08:10:02 <danielzx> erisco
08:11:02 <erisco> okay, why  (("car","snow"),2)  and not  (("snow","car"),2)  or  …,(("car","snow"),1),(("snow","car"),1),… ?
08:11:58 <danielzx> That is what was specified in our assignment. The order doesn't matter, just as long as the content is the same
08:12:42 <erisco> okay
08:13:02 <erisco> for reference, you've written too much code to solve this, but that is okay. If you post the rest of it I can help you finish it
08:13:32 <danielzx> okey. So I overcomplicated it?
08:14:19 <danielzx> http://lpaste.net/5107193204206206976
08:14:24 <danielzx> here's the full code
08:14:37 <erisco> you'll learn the shorter ways to do things over time, it is no problem
08:15:15 <royal_screwup21> danielzx: out of curiosity, do you go to school in the UK?
08:15:30 <danielzx> Nope
08:15:33 <danielzx> How come?
08:15:39 <erisco> okay, so is part of this code given to you by the professor?
08:16:23 <royal_screwup21> danielzx: lol it's okoay, I know you do because I attend the very same school ;)
08:17:09 <erisco> class material is not unique to the institution
08:17:16 <royal_screwup21> the assignment was the giveaway
08:17:21 <royal_screwup21> well
08:17:21 <erisco> teachers and professors share and take from banks of materials
08:17:36 <danielzx> our professor gave us the modules given at the top and their functions 
08:17:56 <danielzx> you have the exact same assignment?
08:18:15 <drw77> I'm using persistent to connect to a MS Sql database (to which I have no write/edit access).  There is an 'nvarchar(20)' sql field that I've modeled as 'Text' with 'Database.Persist.TH'.  Everything seems to be working as expected, except my unicode characters are all translated to "\65533" (the dreaded question mark).  How can I get persistent to understand the utf-8 characters that are stored in this sql field?
08:19:30 <erisco> danielzx, I need to know what spots you are allowed to fill in
08:19:48 <hpc> drw77: does the table support unicode characters?
08:20:25 <hpc> i don't know ms sql, but in mysql and postgres you need to set that in the database
08:21:06 <danielzx> For this problem in particular, everything from the first pairsCount to neighbours.
08:21:13 <danielzx> erisco
08:21:22 <erisco> the trouble with these sorts of assignments is the prof has probably set things up for you to solve the problem in a specific way
08:21:36 <drw77> hpc: yes, the characters are there.  I can see, for example, (U+00AE) "registered sign" when I query the table with SQL Management Studio.
08:21:39 <erisco> whereas, not being in your class, I just solve things in the way I like to ;)
08:22:00 <danielzx> That's true :/
08:22:11 <erisco> did the prof give you those function names and types?
08:22:58 <danielzx> yes, those are wordCount, adjacentpairs, pairsCount, neighbours and mostCommonNeighbour
08:23:15 <danielzx> the rest has been written within our group
08:23:35 <hpc> drw77: so the data looks right when you query it normally, but wrong when queried through persistent?
08:23:36 <erisco> what I mean is… a way an assignment may be given is the prof will say something like line 98 and 99
08:23:48 <erisco> so they tell you the function name, its type, and leave the definition undefined for you to fill in
08:24:02 <erisco> is that the case for pairsCount, listofTallies, gatheringWordTallies, and pairChecks?
08:24:34 <erisco> I have zero information right now on how you are supposed to answer the assignment
08:25:01 <drw77> hpc: yes.  I see the little 'r' circle in the MS stack, but I see "\65533" when I query with Persistent
08:25:37 <danielzx> yes, that's the case
08:25:40 <hpc> hmm
08:25:56 <erisco> and is there any specification of what these functions are supposed to do?
08:26:19 <drw77> hpc: I suspect there is a way to tell Persistent "look out, utf-8 is coming" but I'm new to this, and haven't been able to find it :)
08:28:30 <danielzx> yes there are. it says the function pairsCount computes a tally of all pairs. The order of the words in the pair are not of concern and therefore mirrored version of the same pair can't appear in the tally.
08:28:33 <danielzx> erisco
08:30:17 <erisco> question… what is a pointless way to order a 2-tuple?
08:31:04 <erisco> danielzx, is your only job to fill in pairsCount then?
08:31:34 <erisco> why does it not have a type declaration? was it originally defined as undefined?
08:31:54 <erisco> oh sorry I was looking on line 117… okay it is on 96
08:32:24 <erisco> so was it initially  pairsCount (pair:remainders) = pairChecks listofTallies  or was it initially   pairsCount = undefined  ?
08:32:40 <Tuplanolla> @pl \ t -> bool id swap (fst t < snd t) t
08:32:40 <lambdabot> bool id swap =<< uncurry (<)
08:32:53 <erisco> Tuplanolla, smart
08:33:14 <Tuplanolla> > (bool id swap =<< uncurry (<)) (42, 13)
08:33:16 <lambdabot>  (42,13)
08:33:23 <Tuplanolla> > (bool id swap =<< uncurry (<)) (13, 42)
08:33:25 <lambdabot>  (42,13)
08:33:26 <danielzx> yes, that's my current challenge. It was initially pairsCount = undefined. After under it I added myself recently
08:33:27 <fendor> :t bool
08:33:28 <lambdabot> a -> a -> Bool -> a
08:33:43 <Tuplanolla> It should actually be `bool swap id`.
08:33:54 <fendor> :t swap
08:33:55 <lambdabot> (a, b) -> (b, a)
08:34:08 <erisco> danielzx, okay… so what is gatheringWordTallies and pairChecks about? did you define those yourself or were they part of the assignment too?
08:34:20 <danielzx> Those I defined myself
08:34:23 <erisco> yeah the argument order of bool is the counterintuitive one
08:34:56 <erisco> danielzx, okay, I think I understand the assignment now
08:35:49 <danielzx> How's my code overall for the assignment? erisco
08:35:51 <nshepperd> I always remember the argument order of bool by thinking 'wait, I remember this being unintuitive, so it's probably the opposite of what I think'
08:36:09 <erisco> danielzx, lets figure that out. So explain pairChecks to me. What does that do?
08:36:13 <EvanR> that never works for me
08:36:33 <nshepperd> but it makes sense when you remember that Bool = False | True
08:36:42 <EvanR> but bools arguments have caused me embarassing bugs
08:37:03 <erisco> where's Peaker? need to get named arguments
08:37:08 <erisco> is that his name? probably have it wrong
08:37:37 <erisco> guy who works on a FPL similar to Haskell but is tied into a projectional editor
08:37:49 <lyxia> Bool = False | True    Maybe a = Nothing | Just a    Either b a = Left b | Right a ...
08:38:05 <erisco> yeah, just ignore the fact that | is commutative
08:38:16 <danielzx> It's there to check if the pair has identical elements to the a new list. If not, it will add it to the list. If it doesn't it will increase the Int by 1 and then do it again recursivly
08:38:20 <danielzx> erisco
08:39:02 <erisco> what does gatheringWordTallies do?
08:39:16 <lyxia> Ord certainly ignores the fact that | is commutative.
08:40:17 <danielzx> It takes the pairs from the inputted list and puts in a PairsTally where the first element is the pair and the second element is Int = 1
08:40:18 <erisco> mm… deriving Ord does, but that's a different beast
08:40:35 <nshepperd> the order of the constructors determines the derived instance of Ord
08:41:02 <nshepperd> so False < True; Nothing < Just x; Left x < Right y
08:41:22 <nshepperd> makes that constructor order more reasonable compared to the opposite
08:41:44 <erisco> danielzx, okay, and can you explain the overall algorithm to me? how do you use gatheringWordTallies and pairChecks together to solve the problem?
08:42:36 <erisco> not sure False < True is more reasonable… I can get behind the others though
08:42:36 <nshepperd> (if you wanted named arguments to bool maybe just use LambdaCase: \case{ True -> x; False -> y} b)
08:43:59 <danielzx> gatheringWordTallies collects all the word tallies in a list and then pairChecks takes the head of that list to confirm if it's in its own list or not. Depending if it's there or not, pairsChecks performs its task until there are no elements left in gatheringWordTallies. Then afterwards pairsCount will return that list.
08:44:12 <danielzx> the pairsCheck list
08:45:12 <erisco> > (\case{True->id;False->swap}=<<uncurry(<)) (1,2)
08:45:14 <lambdabot>  (1,2)
08:45:22 <erisco> > (\case{True->id;False->swap}=<<uncurry(<)) (2,1)
08:45:24 <lambdabot>  (1,2)
08:45:39 <erisco> forgive my spacing… for some reason golfing has been on the brain
08:45:52 <erisco> that is a good idea though nshepperd
08:47:19 <Tuplanolla> What's the goal here, erisco?
08:47:48 <erisco> it may have come up later… won't though because it is too obscure
08:48:15 <erisco> danielzx, okay. I can't quite follow you through on your plan
08:48:52 <erisco> danielzx, what I will do is help you through a way I would solve it, and you can compare that to your original plan after
08:49:44 <danielzx> Are you saying it doesn't work or that my explanation was just bad?
08:50:18 <erisco> I am saying it is confusing to me and I think you'd be better seeing a different solution
08:50:35 <erisco> first off is the irrelevance of order of the 2-tuples
08:51:51 <erisco> when we have a structure which has an imposed order, such as 2-tuples, the way we get around this is to canonicalise
08:52:19 <danielzx> We haven't gone through that yet
08:52:35 <erisco> well, this is just a general principle you'll see many times in programming
08:52:45 <danielzx> we are quite like midway thorough our Haskell course
08:52:58 <erisco> we have different values, (1,2) and (2,1), but we want to treat these as being the same
08:53:17 <erisco> the way we do this is to canonicalise, or in other words to find a normal form
08:53:57 <erisco> the obvious thing to do here is to compare the elements, i.e. use <
08:54:10 <erisco> i.e. we will place the smallest element first, and the larger element second
08:54:17 <erisco> so (1,2) becomes (1,2) and (2,1) becomes (1,2)
08:54:35 <erisco> if we do this, then (1,2) and (2,1) become the same thing after we canonicalise. make sense?
08:55:31 <erisco> this isn't specific to Haskell… you will use this technique in any programming language
08:56:21 <danielzx> Yeah, I think I do. So you redefine one of them to match the other by comparing them and then re positioning them?
08:57:05 <erisco> we don't redefine, that has a technical meaning, but we just swap the elements if necessary so the smaller is first and the larger is second
08:57:30 <erisco> order :: Ord a => (a, a) -> (a, a); order = undefined
08:57:33 <erisco> define that function
08:58:29 <danielzx> So it's a tuple of two elements which turns an other tuple of tuple, regardless of order?
08:59:11 <erisco> order (1,2) = (1,2)  and  order (2,1) = (1,2)
08:59:39 <erisco> implement the function so it satisfies those two examples
09:00:00 <danielzx> what part of the function reverses the order? order = undefined?
09:00:22 <erisco> okay, I will explain definitions to you
09:00:50 <danielzx> okay
09:01:02 <erisco> order :: Ord a => (a, a) -> (a, a)   declares (defines) the type of "order"
09:01:19 <danielzx> yes, I'm with you there
09:01:44 <erisco> order = undefined  defines  order  as  undefined
09:01:58 <danielzx> yes
09:02:16 <erisco> so, your job is to change the definition of  order  so that it satisfies those two examples
09:03:25 <danielzx> so that (1,2) returns (2,1)
09:03:27 <danielzx> ?
09:03:33 <erisco> no, read again
09:03:42 <erisco> order (1,2) = (1,2)  and  order (2,1) = (1,2)
09:04:03 <danielzx> oh I see
09:04:04 <erisco> and, going back to my explanation, we swap the elements of the tuple as necessary so that the smaller element is first and the larger element is second
09:04:09 <danielzx> yes
09:04:31 <danielzx> You want to be explain how the computer would do it
09:05:03 <erisco> I want you to implement the function
09:05:31 <erisco> do you know what I mean by that?
09:05:58 <danielzx> The method of solving it? 
09:06:09 <danielzx> so that it covers all the cases
09:06:25 <erisco> okay, let me go over a really simple example
09:06:40 <erisco> timesTwo :: Num a => a -> a; timesTwo = undefined
09:06:59 <erisco> if I ask you to implement timesTwo, and explain to you that timesTwo doubles a number, then I expect you to answer
09:07:09 <erisco> timesTwo x = x + x    for example
09:07:57 <erisco> the answer is the Haskell program which doubles a number
09:08:12 <erisco> that is what it means to implement something, it means to make the program for it
09:08:48 <centril> How do you tell if some operation is a dual of another?
09:08:50 <erisco> and, to be clear, by "program" I also mean single definitions, not just "program" in the sense of a compiled binary
09:09:23 <erisco> centril, you can tell if there is an excuse to call them dual ;)
09:09:40 <danielzx> alright okey. I was thinking that is what you meant but I didn't word it correctly, sorry. 
09:10:35 <joko> Hello, is it possible to have IO inside a fold?
09:10:44 <erisco> joko, consider foldlM or foldrM
09:11:27 <centril> for example:  op1 :: Maybe t -> (t -> Bool) -> Maybe t ;  op2 :: bool -> (() -> t) -> Maybe t
09:11:32 <erisco> danielzx, np. Terminology is often a bit too vague and takes some time to pick up on
09:12:00 <centril> erisco: I might sometimes say something "feels" like a dual - but I want to be more certain if it's an actual dual =)
09:12:38 <erisco> but there is nothing universal to qualify "dual", it is terminology specific to a theory
09:13:08 <erisco> like in category theory the duals are found by reversing the arrows
09:13:37 <erisco> if we're talking algebra then + and * are dual
09:13:48 <centril> erisco: are there other duals than those in category theory?
09:14:40 <centril> erisco: "reversing the arrows" helps =)
09:15:08 <erisco> the vague idea is that if x and y are dual then x does "the other thing" of what y does
09:15:17 <erisco> || and && are dual
09:16:05 <centril> erisco: right, that is vague ;) (but at the same time intuitive)
09:16:58 <danielzx> order (x, y) = 
09:17:10 <danielzx> oh, you can do only one row here
09:17:11 <danielzx> rip
09:18:11 <erisco> danielzx, just put it on lpaste
09:18:14 <joko> erisco: many thanks, it worked!
09:18:22 <erisco> joko, np, have fun
09:18:22 <danielzx> yeah doing it now
09:19:42 <danielzx> http://lpaste.net/8292290506528915456 erisco
09:20:02 <danielzx> Gonna get lunch, brb
09:22:11 <erisco> centril, a || b = not (not a && not b)  i.e. DeMorgan Laws, which is why you'd call them dual
09:22:48 <centril> erisco: makes sense
09:23:48 <erisco> danielzx, sure thing. Also try compiling your program (load it in ghci) and see if it works.
09:26:25 <drw77> hpc: got it! Persistent needs the type to be 'ByteString' instead of 'Text'.  This was immediately confusing to me, because it caused an error (ByteString doesn't have toJSON and fromJSON instances).  This makes sense because how would it know how to interpret that without some help?  So, I had to write instances that use 'Data.Text.Encoding' encodeUtf8 and decodeUtf8.
09:38:49 <centril> erisco: does this seem valid?  [ (bool, (() -> t)) -> Maybe t ]^op  ==  Maybe t -> (bool | (t -> ())  
09:40:21 <centril> == Maybe t -> Either bool (t -> ())
09:41:06 <erisco> well I see what you did, but I do not know how to determine if it is valid
09:41:13 <erisco> i.e. valid wrt what?
09:42:35 <centril> erisco: "reversing the arrows" i guess
09:43:22 <centril> and  (A x B)^op == A | B
09:44:01 <erisco> if you're asking if that makes sense wrt some categoric interpretation of Haskell, I have no idea
09:44:28 <EvanR> A and B are categories?
09:44:31 <centril> =) I think I need to read more about category theory
09:44:50 <erisco> me too, which is why I can't comment further on that ;)
09:45:01 <centril> EvanR: they are "sets" (types)
09:45:17 <joko> Could anyone help me with Monad transformers? http://lpaste.net/360449
09:45:18 <EvanR> ...
09:45:30 <erisco> "sets" is a trigger word for EvanR
09:45:32 <EvanR> well ^op is something you do to a category
09:46:00 <centril> EvanR: right, the category of sets, or Hask
09:46:17 <EvanR> so A and B are categories
09:46:24 <danielzx> erisco got it working
09:46:30 <danielzx> erisco: got it working
09:46:53 <erisco> joko, what is the question? I see your comment but I don't know in what sense you mean "what is the difference"
09:47:11 <joko> For starters, in lines 13-21 I have two maybes... If either or both of them are nothing, then I have to return the first one. If I do an if, then I'm losing the pattern matching
09:47:19 <centril> EvanR: well, the same category?  (A x B), A, B are all objects in the category of sets?
09:47:20 <erisco> danielzx, good. So, how do you apply a function to every element of a list?
09:47:36 <joko> erisco: sorry, that was a comment for me to investigate later... :D
09:47:49 <danielzx> "function name" (x:xs), right?
09:47:54 <danielzx> then your conditions
09:48:07 <erisco> danielzx, nope, it has a name, and it is called  map
09:48:21 <erisco> or you might see  fmap  but we won't get into that now
09:48:29 <erisco> :t map
09:48:30 <lambdabot> (a -> b) -> [a] -> [b]
09:48:34 <EvanR> centril: this is like, 9^op, "foo"^op
09:48:37 <danielzx> oh ok, not that well-versed in map
09:48:57 <EvanR> not used on the right type
09:48:59 <erisco> danielzx, it is an essential function to know, so this is a good opportunity to learn :)
09:49:10 <danielzx> okay ^^
09:49:21 <erisco> when you see fmap later, just know it is a more general version of map, so we aren't wasting time studying map
09:49:28 <EvanR> centril: you might be thinking of a dual construction
09:49:31 <danielzx> okay
09:49:31 <centril> EvanR: mm, so when you say co-product for a sum-type, what are you saying?
09:49:35 <erisco> > map (+1) [1,2,3]
09:49:37 <lambdabot>  [2,3,4]
09:49:40 <erisco> have you seen examples like that?
09:50:04 <danielzx> In the lecture we went through map, I've seen similar ones 
09:50:07 <EvanR> C^op is the opposite category of C, something else
09:50:14 <erisco> okay, here is the mental picture you need
09:50:16 <erisco> > map f [a,b,c]
09:50:18 <lambdabot>  error:
09:50:18 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M546428921639...
09:50:18 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
09:50:28 <erisco> erm…
09:50:37 <erisco> > map f [a,b,c] :: Expr
09:50:39 <lambdabot>  error:
09:50:39 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘[b0]’
09:50:39 <lambdabot>      • In the expression: map f [a, b, c] :: Expr
09:50:44 <erisco> why can I never use that thing right
09:50:55 <danielzx> Expr being?
09:50:58 <erisco> forget it
09:51:06 <EvanR> > map f [a,b,c] :: [Expr]
09:51:08 <danielzx> alright
09:51:08 <lambdabot>  [f a,f b,f c]
09:51:16 <erisco> thank-you
09:51:22 <erisco> so  map f [a,b,c] = [f a, f b, f c]
09:51:28 <danielzx> oh that's a bot?!
09:51:31 <erisco> i.e., it is the function applied to every element of the list
09:51:40 <erisco> lambdabot has a silicon brain, yes
09:51:50 <danielzx> okey lol
09:52:23 <erisco> Haskell is all about expressions, so if you remember the pattern of the expressions, you'll understand what you're doing
09:52:39 * hackage firefly 0.1.1.0 - A simple HTTP server framework  https://hackage.haskell.org/package/firefly-0.1.1.0 (ChrisPenner)
09:52:42 <danielzx> mhm, good to know
09:52:44 <joko> I think I get it, I could use "case (maybeCurrentWidestInfo, maybeCheckInfo) of"
09:52:45 <erisco> using map you can apply order to every element of a list
09:52:54 <erisco> map order [a, b, c] = [order a, order b, order c]
09:53:26 <danielzx> and a,b,c can be tuples of any kind?
09:53:29 <erisco> try doing that to your example list of pairs and see what you get
09:53:44 <erisco> they can be tuples of type (a, a) for any a
09:53:55 <erisco> which has an Ord instance
09:55:31 <EvanR> wat
09:55:55 <EvanR> if Ord a and Ord b then Ord (a,b)
09:55:57 <EvanR> but otherwise
09:56:24 <danielzx> erisco: got this error http://lpaste.net/1847383919272394752
09:56:27 <erisco> a, b, c :: forall t. Ord t => (t, t)
09:56:47 <erisco> danielzx, you have an extra opening paren at the beginning of the list
09:57:00 <EvanR> (a,a) for all a doesnt have an Ord instance
09:57:32 <erisco> you're right
09:57:55 <erisco> I see the misinterpretation
09:58:15 <erisco> see, I forgot to stipulate "which has an Ord instance" in my first message, so I added it after… it is associated to 'a' and not to '(a, a)'
09:58:27 <danielzx> oki, now it worked and also reversed the order of ("pen", "crack")
09:58:38 <erisco> if  a  has an Ord instance then  (a, a)  does
09:59:09 <erisco> danielzx, that's right, it will order lexicographically
09:59:18 <danielzx> I see
09:59:24 <erisco> so, now that you have ordered all the tuples, do you see how the problem is simpler now?
10:00:04 <erisco> initially we had lists such as [("a","b"),("b","a")] and we had to worry about identifying both those tuples as the same
10:00:15 <erisco> but now that we have canonicalised them, our list is [("a","b"),("a","b")]
10:00:22 <joko> Is it possible to write more elegantly getBarMonitor in http://lpaste.net/360449 ?? I have a staircase and I thought of MaybeT, but the second case depends on the first one
10:00:58 <erisco> and now we can just use the fact that ("a","b") and ("a","b") are equal, which == does
10:01:05 <danielzx> yes, so now we don't have to worry about the case if the order is reversed or not 
10:01:13 <erisco> that's right
10:01:23 <erisco> another name for "canonicalising" is "normalising" btw
10:01:41 <danielzx> which one is more commonly used in haskell community?
10:01:46 <danielzx> the*
10:02:02 <erisco> well what we're doing here isn't particular to Haskell
10:02:35 <erisco> if you talk about normalisation in context of Haskell you're probably talking about reductions i.e. evaluation
10:02:44 <erisco> such as "what is the normal form of  (\x -> f x) 5"
10:02:56 <danielzx> ah ok
10:03:13 <danielzx> so what's the normal form of a hidden function?
10:03:15 <erisco> which is the same sense of the word, but the surrounding theory is more particular
10:03:19 <monochrom> The choice is by topic rather than by community.
10:03:22 <erisco> what is a hidden function?
10:03:30 <danielzx> I'm using the wrong word
10:03:34 <lyxia> joko: that's still what MaybeT is for.
10:03:46 <danielzx> but I know you by 
10:03:47 <erisco> we call stuff that begins with \ "lambdas"
10:03:49 <danielzx> (\x -> f x) 5"
10:03:53 <danielzx> but I forget the name
10:03:56 <erisco> in fact, \ is just an ASCII character for λ
10:04:26 <erisco> so, it is "a lambda" or "a lambda function"
10:04:38 <danielzx> yeah, lambda function
10:04:44 <danielzx> that is what I was looking for
10:04:45 <danielzx> anyway
10:04:47 <erisco> or just "a function" if we don't care to be particular about the syntax
10:05:00 <danielzx> alright
10:05:19 <danielzx> I can use this function order in my original code to make it a bit easier to write, correct?
10:05:23 <erisco> okay, so now we want to count the occurrences of each element in the list
10:05:29 <danielzx> yes
10:05:45 <erisco> so, say we have a list like  [1,2,1,5,2,3]
10:05:53 <danielzx> uhuh
10:06:26 <erisco> there are a couple common ways we can do this, and I'll just cover one for now
10:06:47 <erisco> suppose all the equal elements were next to each other, such as [1,1,2,2,5,3]
10:06:58 <danielzx> uhuh
10:07:27 <rightfold> Is it possible to create a Traversal' a b from a pair (a -> Maybe b, a -> b -> a)?
10:07:27 <erisco> well then it would be easier to count, because we don't have to search over the whole list for matching elements, we just have to look at the next element
10:07:34 <erisco> either the next element in the list is the same or it isn't
10:07:35 <Hafydd> Map.fromListWith is an efficient way to do this.
10:07:52 <danielzx> exactly
10:08:04 <erisco> yeah but I am going to cover the group method first Hafydd, and then you can explain the Map version if you like
10:08:26 <erisco> so, what is a way we can put all the equal elements next to each other, danielzx?
10:09:16 <danielzx> Go through the list for every x in xs and put up a condtion that if even x, move it forward else move on in the list
10:10:10 <erisco> that might be on the way to a solution, but first lets think of functions that are already out there, rather than writing our own
10:10:19 <danielzx> ok
10:10:21 <rightfold> Nevermind, I'm doing it wrong.
10:10:35 <danielzx> What do you advise?
10:10:37 <erisco> a key to writing good Haskell, and writing good programs in any language, is to reuse what already exists
10:10:51 <erisco> well I can't advise much other than the answer, since it is just the name of a function :)
10:11:11 <erisco> what if we sort the list?
10:11:47 <rightfold> Oh I'm so confused.
10:11:55 <danielzx> we use sort
10:11:58 <danielzx> the function sort
10:12:13 <erisco> that's right, so now try sorting the list
10:12:26 <erisco> you should see that all the equal elements are now adjacent
10:12:48 <danielzx> yes
10:12:56 <erisco> they also happen to be in order, but this isn't a property we care about… sometimes we can exploit functions for other purposes :)
10:13:12 <erisco> okay, now that they are in order, have you heard of a function named "group"?
10:13:21 <danielzx> no
10:13:29 <erisco> okay, that is another basic function to know
10:13:39 <erisco> play around with group (you may need to import Data.List) and tell me what it does
10:14:07 <danielzx> I'm not allowed to import any data types for my assignment
10:14:15 <erisco> it is a function
10:14:18 <erisco> can you import functions?
10:14:28 <danielzx> not sure, but don't want to risk it
10:14:36 <erisco> okay, then we'll write it ourselves
10:14:54 <erisco> I'll describe what group does and you can implement it
10:15:36 <erisco> group :: Eq a => [a] -> [[a]]   group [1,1,2,2,3,4] = [[1,1],[2,2],[3],[4]]  group [] = []
10:15:56 <erisco> so, group takes a list and produces a list of lists
10:16:21 <rightfold> Given data X = A Int | B Int | C, how'd you write an optic for getting and setting any of the Ints if it's there?
10:16:27 <erisco> and what it does is put adjacent equal elements into their own list
10:16:27 <danielzx> ok
10:16:43 <erisco> do you understand the function?
10:16:55 <danielzx> so if x = x it it creates a list of those x's?
10:17:10 <erisco> I am not sure what you mean
10:17:19 <joko> lyxia: Could you post some guidance?
10:18:35 <danielzx> We do pattern matching with the head of the list and the rest of the list. If the head is equal to the head of the list, it creates a new list containing those two x's?
10:18:45 <danielzx> That's how I thought of it in my head
10:18:54 <erisco> well, the head of the list is always equal to the head of the list… that's a tautology
10:19:30 <danielzx> oh, I meant head of the list is equal to the second element in the list?
10:19:33 <danielzx> ,*
10:19:37 <danielzx> .**
10:19:46 <erisco> ah
10:20:01 <erisco> but a group may have more than two elements in it
10:20:09 <erisco> group [1,1,1,2] = [[1,1,1],[2]]  for example
10:20:39 <lyxia> joko: http://lpaste.net/360449
10:21:04 <danielzx> alright, it adds them to their own list as long as x equals to next element of the list
10:21:08 <erisco> this is one of the tougher questions we had when I took a midterm on Haskell (well actually it was Miranda)
10:21:28 <erisco> yeah, sounds about right, and so see if you can implement that
10:21:30 <lyxia> joko: (see the annotation below)
10:26:09 <danielzx> how do I call the element behind x in the conditional? :
10:26:20 <Younder> Miranda.. That is very 80's
10:26:53 <erisco> danielzx, paste a code example. I am not sure what you mean
10:27:55 <lyxia> rightfold: traverseX f x = case x of A n -> A <$> f n ; B n -> B <$> f n ; C -> pure C
10:28:03 <danielzx> http://lpaste.net/3615379328038076416 xs shouldn't be there in line 4
10:28:16 <rightfold> lyxia: thanks! I almost had that
10:28:20 <rightfold> makes sense now
10:29:13 <erisco> okay you've got the list cases right but let me steer you a little closer
10:29:33 <danielzx> ok
10:30:32 <joko> lyxia: many thanks! On L33 screenRes is a Maybe, but because of MaybeT, it's ok to use it?
10:31:11 <erisco> danielzx, work with something like this http://lpaste.net/360457
10:32:10 <lyxia> joko: screenRes is not a Maybe
10:32:25 <danielzx> wait, can't I work with x:y:xs as well? (thought of it just now and curious) erisco
10:32:50 <erisco> well, try it however you want :) that is my suggestion though
10:33:01 <lyxia> joko: the right hand side has type MaybeT IO ScreenRes   <- MaybeT hides the Maybe
10:33:03 <erisco> the idea I presented has the current group as yys
10:33:24 <erisco> so we can see if the next element should be added to the current group, or if not, then we can yield the current group and start a new one
10:34:11 <joko> lyxia: I see... And if primaryOutputInfo is Nothing? How the next line gets evaluated?
10:35:09 <danielzx> what do you mean by "go"?
10:35:10 <joko> Ah, it goes to false, right?
10:35:30 <lyxia> joko: if any step returns Nothing everything stops
10:35:40 <lyxia> joko: and getBarMonitor returns Nothing
10:35:58 <lyxia> joko: just like it did in the original version
10:36:04 <joko> lyxia: thanks once again for clearing this out :D
10:36:12 <danielzx> erisco
10:36:29 <erisco> this isn't how the official one is written but I am choosing something hopefully easier to understand
10:36:32 <lyxia> joko: yw
10:38:20 <erisco> actually, we have some functions in Prelude we can use that might make this simpler still (rather than this explicitly recursive version)
10:38:34 <danielzx> which ones?
10:38:36 <erisco> which is not using foldr either (which would take more explaining)
10:38:39 <erisco> well, check out span
10:39:07 <danielzx> span :: (a -> Bool) -> [a] -> ([a], [a])
10:39:34 <danielzx> what does it do exactly?
10:39:43 <erisco> try it out in ghci
10:41:09 <mniip> hmm I wonder what's the free theorem for span
10:42:15 <rightfold> span with linear type would be nicer
10:42:59 <danielzx> So it applies a condition to a list, and whatever element fufills that condition is put into a seperate list
10:43:35 <erisco> it gives you the largest prefix for which each element satisfies the predicate and the rest of the list
10:43:50 <erisco> > span (<3) [1..10]
10:43:53 <lambdabot>  ([1,2],[3,4,5,6,7,8,9,10])
10:44:07 <Tuplanolla> > partition (< 3) [1 .. 10]
10:44:09 <lambdabot>  ([1,2],[3,4,5,6,7,8,9,10])
10:44:09 <danielzx> what do you mean by largest prefix?
10:44:22 <erisco> do you know what a prefix is?
10:44:30 <danielzx> yes
10:44:55 <erisco> okay, then you know there are as many prefixes as a list is long
10:45:05 <danielzx> alright
10:45:10 <erisco> maybe +1 if you allow the empty prefix
10:45:17 <danielzx> how does that work though?
10:45:23 <danielzx> If you don't mind me asking
10:45:28 <erisco> so, which of those prefixes does it give you? the longest one for which each element satisfies the predicate
10:45:55 <erisco> > inits "hello world"
10:45:57 <lambdabot>  ["","h","he","hel","hell","hello","hello ","hello w","hello wo","hello wor",...
10:46:00 <erisco> that is a list of the prefixes
10:46:16 <danielzx> oh okay, I get it
10:46:43 <erisco> now, using span, implement group
10:46:45 <fakenullie> > inits [1..]
10:46:47 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
10:47:45 <burstXin> anyone here have experience with threepenny gui? How do you properly attach stylesheets? No matter what changes I make on my css file, it doesn't register. I'm using electron.io to convert it to a desktop application
10:48:08 <erisco> and this one will actually give you something which should be equivalent to the official implementation
10:48:20 <erisco> the other suggestion I gave has a difference in strictness
10:51:15 <danielzx> I see
10:51:50 <danielzx> So we use span in the conditional part?
10:52:03 <erisco> what is the conditional part?
10:52:04 <mniip> aha
10:52:09 <danielzx> if-else?
10:52:10 <mniip> this is kind of touched in wadler's paper
10:52:15 <erisco> you should begin like  group [] = []; group (x:xs) = …
10:52:19 <erisco> we do not need if/then/else
10:52:38 <danielzx> okay
10:53:07 <mniip> (map f *** map f) . span (p . f) = span p . map f
10:53:09 <mniip> for all span
10:53:26 <erisco> the definition for the (x:xs) clause should fit on one line, but feel free to use whitespace
10:53:58 <danielzx> http://lpaste.net/7519616754583076864 Am I on the right track?
10:54:16 <erisco> no because all the things left of = need to be patterns
10:54:25 <erisco> except the function name
10:54:34 <erisco> and the cases are [] and (x:xs)
10:55:03 <mniip> oooh
10:55:06 <erisco> so line 3 should begin  group (x:xs) =
10:55:07 <mniip> I think I see now
10:55:15 <mniip> wadler's theorems are pretty much...
10:55:29 <erisco> mniip, what is the paper title?
10:55:39 <mniip> decategorified statements about ends of profunctors in the cateogry of types
10:55:41 <danielzx> and the bool (==x ) doesn't work
10:55:43 <danielzx> +
10:55:44 <danielzx> ?*
10:55:45 <lambdabot> Maybe you meant: v @ ? .
10:55:59 <erisco> (== x)  is not a pattern
10:56:06 <mniip> erisco, "Theorems for free!" not sure if there was an earlier paper describing the same but this one is fairly accessible
10:57:01 <erisco> hm… I can pay a journal $10 for it or… I can get it for free! papers for free!
10:57:12 <danielzx> I'm unsure now what exactly defines a pattern
10:57:24 <erisco> do you know what pattern matching is?
10:57:28 <danielzx> yes
10:57:41 <erisco> okay, then explain what (== x) matches
10:58:02 <danielzx> nothing, cause there are no elements to match?
10:58:15 <erisco> well it isn't even a pattern
10:58:21 <danielzx> that too
10:58:33 <danielzx> [] is considered a pattern, correct?
10:58:42 <erisco> yes
10:58:51 <danielzx> ok, thought so but wasn't sure
10:58:52 <erisco> patterns consist of constructors, variables, and constants
10:59:09 <mniip> is it really worth separating constants from constructors
10:59:16 <erisco> == is a function, so that doesn't fit
10:59:24 <erisco> mniip, sort of, because they use ==
10:59:32 <mniip> you mean literal patterns
10:59:33 <erisco> like fac 0 = 1
10:59:38 <mniip> yeah right
10:59:43 <danielzx> I see
11:00:02 <erisco> but if you're willing to say 0 is a constructor of Int or whatever, then sure
11:00:05 <Tuplanolla> That just highlights that `0` should be considered a constructor for `Num a => a`.
11:00:23 * hackage wai-cors 0.2.6 - CORS for WAI  https://hackage.haskell.org/package/wai-cors-0.2.6 (larsk)
11:00:23 <mniip> erisco, also tbh nothing wrong with (==), it's the pair of adjacent nonconstructor identifiers that makes it wrong
11:00:31 <mniip> :t \(==) -> (==)
11:00:33 <lambdabot> p -> p
11:00:38 <danielzx> so for the next case is when I call the span function to look through the list erisco
11:00:54 <mniip> but oh well carry on
11:01:03 <mniip> I'll just read my paper
11:01:09 <erisco> mniip, you just named a parameter (==)
11:01:14 <mniip> yeah
11:01:19 <erisco> well… a tad misleading, lol
11:01:36 <mniip> depends
11:01:47 <mniip> you could justify binding operators to arguments in higher order functions
11:02:04 <erisco> danielzx, okay so we have  (x:xs)  where x is the head and xs is the tail
11:02:14 <danielzx> yes
11:02:26 <erisco> danielzx, we want to take the longest prefix of xs where all elements are equal to x
11:02:27 <Tuplanolla> Now, why do we limit user-defined types to a finite number of constructors?
11:02:38 <erisco> danielzx, how do you use span to do that?
11:03:11 <fishythefish> how would a user have time to supply an infinite number of constructors?
11:03:33 <Tuplanolla> Think reader macros of Lisp fame, fishythefish.
11:03:34 <danielzx> let the bool be (==x) with the list xs
11:03:34 <erisco> with a meta rule for generating constructors
11:03:49 <danielzx> if that makes sense
11:04:01 <erisco> I imagine the current code generation would really not appreciate infinite constructors, though
11:04:19 * EvanR looks up W types
11:04:24 <erisco> danielzx, just write the code out and paste it :)
11:04:42 <danielzx> only the span function?
11:05:26 <danielzx> span (== x) xs somewhere along these lines erisco
11:06:13 <EvanR> it seems like you could have a W type over any set of constructors
11:06:20 <EvanR> one for each real number!
11:06:32 <erisco> danielzx, that's right! now, what should you do with the result?
11:07:35 <mniip> 1512241320 [22:02:00] <Tuplanolla> Now, why do we limit user-defined types to a finite number of constructors?
11:07:49 <mniip> Hask⊥ is not closed under infinite products or coproducts
11:07:50 <danielzx> Send it back into group
11:08:35 <erisco> okay lets think of an example
11:08:40 <erisco> so  group [1,1,2]
11:09:03 <erisco> then   x = 1  and  xs = [1,2]  so what does  group (==x) xs  reduce to?
11:09:23 <Tuplanolla> When is this a problem, mniip?
11:09:34 <erisco> derp… I mean to ask:  what does   span (==x) xs  reduce to?
11:09:42 <danielzx> xs gets reduced to 2?
11:10:01 <fishythefish> when is the lack of infinite constructors a problem?
11:10:03 <erisco> no, let me explain what I mean by "reduce"
11:10:21 <erisco> for example,  (\x -> f x) 5  reduces to  f 5
11:10:33 <erisco> (*2) 5  reduces to  10
11:10:48 <Tuplanolla> It makes `Integer` special and special things aren't nice, fishythefish.
11:10:50 <erisco> reverse [1,2,3]  reduces to  [3,2,1]
11:11:06 <erisco> so what does  span (==x) xs  reduce to assuming  x = 1  and  xs = [1,2]  ?
11:11:09 <danielzx> So by reduce, you mean what is the returned value?
11:11:10 <EvanR> wait...
11:11:10 <dutchie>  I'm struggling to get intero/terminfo to install properly on arch: http://lpaste.net/360412. afaict the `config.log` file (and the whole tmpdir) where it's being built is being wiped out before I can get a look at what precisely the problem is
11:11:24 <EvanR> its not like Integer = 0 1 -1 2 -2 ... act like constructors
11:11:37 <erisco> danielzx, uh… I guess
11:12:01 <danielzx> This is the first time I hear the term reduce btw
11:12:39 <fishythefish> danielzx: think "simplify" when you hear it in algebra
11:12:57 <erisco> danielzx, another phrase would be "simplifies to" or "normalises to" … and remember earlier I said "canonicalise" can take on that same meaning … full circle :)
11:13:16 <danielzx> ah! oki I see
11:13:49 <danielzx> so span (==x) xs reduces a new list which contains a lists of elements which are the same? 
11:14:19 <erisco> no, not quite… and because I told you want x and xs are, you should be able to say exactly what the answer is, as code
11:14:32 <erisco> you can, in fact, just run it in ghci
11:14:46 <erisco> ghci is your automatic reducer/simplifier ;)
11:15:17 <erisco> though I guess it only works for stuff which has a Show instance… no problem here
11:15:22 <fishythefish> Tuplanolla: can you avoid the problem of having special types which are mapped more directly to hardware via the compiler?
11:15:47 <fishythefish> suppose there were a metalanguage that let you define constructors ConN for all Integers N - you're still using Integer as a special type to bootstrap this
11:16:41 <EvanR> its the integer in the metalanguage
11:17:10 <fishythefish> great, now does the metalanguage let me define my own metatype with an infinite number of metaconstructors?
11:17:16 <EvanR> no
11:17:29 * fishythefish shrugs
11:17:33 <EvanR> \o/
11:17:52 <EvanR> an infinite number of ctors does seem extravagant
11:17:55 <fishythefish> you have a special type somewhere, so why bother with a metalanguage unless it does something more useful than make people feel better about Integer?
11:18:25 <EvanR> like, you could encode every inductive element of the type as a separate ctor
11:18:37 <danielzx> http://lpaste.net/1914507828542832640 I try to compile the code but get this error
11:18:40 <danielzx> :(
11:19:00 <erisco> yes because line 3 should start as  group (x:xs) =
11:19:09 <erisco> I've said this two or three times now… ;)
11:19:09 <EvanR> also how do you do case analysis on a type with infinite ctors
11:19:42 <danielzx> I'm sorry, been on this assignment for a few days now and kinda frustrated 
11:19:43 <EvanR> this is like a theory with an infinite number of axioms, one for each theorem you would normally have to prove
11:19:55 <danielzx> Not your fault though ^^
11:19:56 <netsu> hello there! Trying build aged package. And there's errors, because ghc infer [] like IsList and "" like IsString. How can I disable such general behaviour? 
11:20:06 <crucify_me> well the hutton book is very good but the section on folds was skimpy. thanks for patient help yesterday all.
11:20:09 <Tuplanolla> You would have to replace pattern matching with elimination, EvanR.
11:20:09 <erisco> x = 1 and xs = [1,2] and we want to know what  span (==x) xs  reduces to
11:20:13 <danielzx> so thanks for being patient with me through all this
11:20:20 <erisco> > span (==1) [1,2]
11:20:22 <lambdabot>  ([1],[2])
11:20:33 <erisco> so  span (==1) [1,2]  reduces to  ([1],[2])
11:20:36 <fishythefish> Tuplanolla: does this gain anything over just adding an extra argument to a regular constructor?
11:20:49 <Tuplanolla> Peace of mind, fishythefish.
11:20:57 <danielzx> Wasn't that my explanation? 
11:20:58 <danielzx> :O
11:21:07 <erisco> I wanted you to tell me precisely, not give an explanation
11:21:07 <fishythefish> for some definition of "peace"
11:21:15 <danielzx> fair enough
11:21:19 <erisco> reductions are precise
11:21:38 <crucify_me> fishythefish, << awesome human
11:21:43 <EvanR> would you want a type which has a ctor for every point on a circle
11:21:46 <erisco> so, we can pattern match this result …  group (x:xs) = let (g, xs') = span (==x) xs in ?
11:21:56 <erisco> what is the final thing we need to do for '?' ?
11:22:27 <monochrom> Hi erisco, does the assignment require the student to write their own "group"?
11:22:43 <erisco> monochrom, we're yak shaving at the moment… not allowed to import things
11:22:58 <monochrom> Yikes
11:23:13 <monochrom> But erisco++ for Socratic method.
11:23:25 <EvanR> i hope not allowed to import things means, also NoImplicitPrelude :)
11:23:28 <erisco> this is the only complicated part of the overall answer, though… once we have group the rest will fall into place
11:23:45 <erisco> and since I was asked to implement group in my first functional programming course, I think it is reasonable :)
11:24:04 <danielzx> What's g in your statement?
11:24:26 <EvanR> what other principles can we corrupt by allowing infinite... can proofs be infinitely long
11:24:32 <erisco> for the sample where  x = 1  and  xs = [1,2]  then  g = [1]  because  span (==x) xs = ([1],[2])
11:24:38 <netsu> Oh, I found. Somewhy `:set -XOverloadedStrings` ghci.conf have higher priority than `Extensions: NoOverloadedStrings` in *.cabal
11:24:51 <danielzx> ok, so the first element=
11:24:53 <danielzx> ?*
11:24:53 <lambdabot> Maybe you meant: v @ ? .
11:24:59 <monochrom> Infinitely long proofs are equivalent to allowing fix :: (a->a)->a in programming.
11:25:10 <erisco> feel free to choose a longer name
11:25:32 <EvanR> can diagrams be infinitely big
11:25:52 <monochrom> There are infinite graphs so yeah.
11:25:54 <erisco> danielzx, the first element of the 2-tuple returned by  span (==x) xs  yes
11:25:58 <danielzx> So wouldn't ? = group as we are using span on the entire list?
11:26:13 <EvanR> can expressions be infinitely big
11:26:24 <monochrom> Quantum wave functions can also be thought of as infinitely big matrices.
11:26:35 <EvanR> skeptical...
11:26:38 <monochrom> or infinitely big vectors? I forgot which
11:26:43 <erisco> danielzx, what we have determined with span is one of the groups we need to yield
11:26:57 <Tuplanolla> It's functions being infinite-dimensional vectors, monochrom.
11:26:59 <danielzx> yes
11:27:01 <monochrom> (See Heisenberg's "matrix mechanics")
11:27:02 <EvanR> ok when you only have continuous functions you can encode all the info in a countable number of parameters
11:27:24 <erisco> danielzx, right? say our list is [1,1,1,2,3] then span will give us ([1,1],[2,3])
11:27:44 <danielzx> exactly
11:27:46 <erisco> danielzx, so the first part of the missing piece is  x : g
11:28:13 <erisco> because  x : g  in that example will be  [1,1,1]
11:28:31 <danielzx> can I say that g = xs?
11:28:40 <erisco> why would you like to say that?
11:28:43 <nshepperd_> I don't think infinitely long proofs would make any sense
11:28:53 <danielzx> cause I always use x:xs for all our courses when talking about pattern matching
11:28:59 <danielzx> or am I confusing them now?
11:29:10 <nshepperd_> You could prove anything by use of fix id :p
11:29:30 <erisco> okay, I am not exactly sure what you mean. We used (x:xs) when we said  group (x:xs) =
11:29:32 <monochrom> danielzx, there are obviously more patterns than x:xs
11:29:33 <EvanR> perhaps because proofs ought to be verifiable in finite time
11:29:42 <danielzx> yes
11:29:58 <EvanR> so maybe that is a principle to keep in mind when expanding something from finite to infinite
11:30:04 <danielzx> and when you used x:g I automatically associated it with x:xs and got confused
11:30:47 <erisco> ah, okay, so in the position of the question mark, that is not a pattern, it is an expression
11:31:10 <danielzx> oki, so we want an expression after in?
11:31:12 <erisco> if I say  f (x:xs) = x:xs  for example the x:xs on the left of = is a pattern, and the x:xs on the right of = is an expression
11:31:33 <erisco> the first means "match a list with a head and a tail" and the second means "create a list with this head and this tail"
11:32:02 <erisco> right the syntax is  let <bindings> in <expr>
11:32:10 <erisco> and as a whole that is an expression itself
11:32:14 <Tuplanolla> It's just that if you had a type with an infinite number of inhabitants, I don't see why you would pattern match on it in the first place, regardless of its number of constructors.
11:32:25 <danielzx> I see
11:32:30 <EvanR> in order to prove things about it inductively
11:32:37 <EvanR> without having to write an infinite number of cases
11:32:42 <Tuplanolla> You could match on a few and dispatch the rest some other way.
11:32:59 <erisco> another syntax is  <expr> where <bindings>  but the whole of that is not an expression
11:33:11 <erisco> we can use that syntax here, though, if you find it more comfortable
11:33:33 <Tuplanolla> It's not like we're trying to build a proof assistant out of this.
11:33:37 <hpc> it's more like <definition> where <bindings>
11:33:40 <EvanR> wouldnt a finite elimination rule belie an essentially finitistic construction of the type
11:34:02 <erisco> yeah that's probably more accurate
11:34:25 <danielzx> uh... I'm lost. I thought it was at first (xs), but unsure
11:35:05 <erisco> group (x:xs) = let (g, xs') = span (==x) xs in (x : g) …   we're here right now danielzx
11:35:18 <monochrom> EvanR: I think yes.
11:35:42 <danielzx> ok
11:35:54 <danielzx> So to explain that line in human language?
11:36:38 <monochrom> No, explain with examples.
11:36:57 <erisco> group [1,1,1,2,3]
11:37:26 <erisco> figure out what x and xs is, and substitute, then reduce as much as you can
11:38:10 <monochrom> [1,1,1,2,3] is syntax sugar for something that uses colon. You may like to start with that.
11:38:44 <danielzx> x would be 1, xs would be 1,1,2,3 and the reduction would be ([1,1,1], [2,3])?
11:39:11 <erisco> xs is 1:1:2:3:[] or [1,1,2,3]
11:39:25 <danielzx> right
11:39:31 <erisco> so we substitute that into the expression  let (g, xs') = span (==x) xs in x : g
11:40:01 <danielzx> okay
11:40:10 <erisco> what did you get?
11:40:48 <danielzx> span (==1) [1,1,2,3] in 1 : g?
11:41:01 <erisco> what happened to "let" ?
11:41:44 <erisco> when in doubt, copy the string into your text editor, then do a find/replace
11:41:58 <erisco> of course… mind the scopes… but it is one scope here :)
11:42:13 <danielzx> so it becomes let (g, xs') = span (==1) [1,1,2,3] in 1 : g?
11:42:22 <erisco> but we should be thinking real simple here. it is just find and replace. yes, that is right
11:42:33 <danielzx> ok
11:42:51 <erisco> now, you know how to reduce  span (==1) [1,1,2,3]  so what is that?
11:43:10 <danielzx> ([1,1], [2,3])
11:43:18 <erisco> right, and so substitute again
11:43:27 <Dra|n> hi
11:43:28 <Dra|n> :)
11:44:02 <danielzx> and now it is let (g, xs') = span (==2) [3] in 2 : g?
11:44:24 <erisco> substitute  span (==1) [1,1,2,3]  for  ([1,1],[2,3])
11:44:36 <danielzx> oh
11:45:07 <danielzx> so let (g, xs') = ([1,1],[2,3]) in 1 : g?
11:45:13 <erisco> yes
11:45:15 <danielzx> ahh
11:45:37 <erisco> now we can do some simplification of the pattern match
11:45:56 <erisco> let (a, b) = (c, d) in m  is the same as  let a = c; b = d in m
11:46:13 <erisco> but, no crime for seeing this intuitively
11:46:32 <danielzx> what is m defined as?
11:46:45 <erisco> could be any expression
11:46:50 <danielzx> ok
11:46:57 <erisco> so, in the example, what is g equal to and what is xs' equal to?
11:47:39 <danielzx> g = the prefix and xs' the final list containing elements which occur more than once
11:47:49 <erisco> yes, but answer precisely
11:47:56 <monochrom> "the prefix" is vague.
11:48:31 <erisco> and your description of the rest of the list seems off
11:48:40 <monochrom> If someone asked you "3+4 = ?" you would answer simply and pointedly "7" you would not write an essay on addition and its history and its place in civilization.
11:48:41 <danielzx> the longest prefix?
11:49:11 <erisco> every time I ask what something is equal to, or what it reduces to, or what it is equivalent to, etc, I am looking for a formal answer, not a story ;)
11:49:52 <danielzx> lol
11:50:12 <danielzx> so how is my description of the rest of the list of?
11:50:34 <erisco> because it is not necessarily containing elements which occur more than once
11:50:49 <erisco> in fact, in this case  xs' = [2,3]  which clearly doesn't satisfy that
11:51:26 <danielzx> if you say then that all the element which aren't equal to x?
11:51:50 <erisco> well, no, you might be conflating with the larger problem we are solving
11:52:00 <erisco> > group [1,2,1,2]
11:52:02 <lambdabot>  [[1],[2],[1],[2]]
11:52:09 <erisco> remember that group only looks at adjacent elements
11:52:33 <erisco> in the larger problem we sorted the list first, so all the equal elements are adjacent
11:52:42 <danielzx> yes
11:53:24 <erisco> so, the rest of the list may contain elements equal to x, we just know it isn't the head of that list
11:53:47 <erisco> if we know the list was sorted then we know no other elements are equal to x, but that is extra information outside the scope of group
11:54:22 <erisco> so, what does g equal and what does xs' equal?
11:54:40 <erisco> remember we're at  let (g, xs') = ([1,1],[2,3]) in 1 : g
11:55:41 <monochrom> Or, to zoom in a bit, (g, xs') = ([1,1],[2,3])
11:55:49 <erisco> if I asked what does x equal in  let x = 5 in 3 + x  what would you tell me
11:56:14 <danielzx> 5
11:56:38 <erisco> right, and what would you tell me for  let (x, y) = (5, 6) in 3 + x  ?
11:56:47 <danielzx> (5, 6)
11:56:53 <danielzx> or wait
11:56:56 <danielzx> 5
11:57:06 <erisco> right! remember on the left of = we are pattern matching
11:57:31 <danielzx> alright
11:57:36 <erisco> so, going back, what does g equal and what does xs' equal?
11:58:02 <danielzx> g = the longest prefix([1,1]) and xs' = the remaining elements which didn't match with the head so ([2,3])?
11:58:25 <erisco> yes
11:58:36 <erisco> though I see you're unwilling to let go of the wordy explanations :P
11:59:03 <danielzx> It's a old habit, makes it easier for me to understand :P
11:59:08 <erisco> so now substitute g and xs' into 1 : g
12:00:03 <danielzx> So it becomes 1 : [(1,1)]
12:00:06 <danielzx> ?
12:00:16 <erisco> try again
12:00:27 <erisco> that would be a type error, and that doesn't match what you said g was equal to
12:00:50 <danielzx> I said g is equal to [(1,1)]
12:01:07 <danielzx> the longest prefix
12:01:15 <TMA> danielzx: you did not say that before
12:01:34 <erisco> the brackets are playing tricks on you
12:01:49 <danielzx> "g = the longest prefix([1,1])" or?
12:01:51 <TMA> danielzx: you said something quite different
12:01:59 <danielzx> eh?
12:02:04 <erisco> ([1,1]) and [(1,1)] are not the same thing
12:02:15 <erisco> ([1,1]) is mundanely the same as [1,1]
12:02:30 <erisco> [(1,1)] is a list containing the 2-tuple (1,1)
12:02:55 <danielzx> oh wow now I see the mistake
12:02:57 <danielzx> sorry about that
12:03:23 <erisco> I thought you were using parens as an aside in speech, sorry
12:03:49 <danielzx> so it would be 1 : ([1,1])?
12:03:50 <erisco> perhaps a reason to be precise in the first place ;)
12:04:01 <danielzx> seems like it lol
12:04:14 <erisco> yes, and go ahead and make it all sugar
12:04:44 <danielzx> make it all sugar_
12:05:00 <erisco> haha, I just mean to choose the square bracket notation over :
12:05:32 <danielzx> Like so [1, ([1,1])]?
12:05:34 <danielzx> or?
12:05:45 <erisco> no, lets go the other way and remove all the sugar then
12:05:57 <danielzx> sorry haha¨
12:06:02 <erisco> rewrite ([1,1]) to use : and []
12:07:10 <danielzx> 1 : [(1)]?
12:07:30 <TMA> danielzx: good first step
12:07:31 <erisco> well that's getting closer, now rewrite [(1)] to use : and []
12:07:42 <danielzx> 1 : [()]
12:07:45 <erisco> remember that [] is a constructor
12:08:09 <erisco> when I say "use []" I mean to use the constructor, not to use the square bracket sugar (that is what we want to get rid of!)
12:08:26 <danielzx> oh
12:08:29 <erisco> this tends to be confusing so you have to pay really close attention
12:08:53 <danielzx> so something like 1 : (not sure what to put here)
12:09:03 <erisco> [] is a constructor, and square brackets with stuff between them is some sugar notation
12:09:07 <erisco> entirely different things
12:09:30 <erisco> okay, what is the empty list?
12:09:48 <danielzx> a pattern?
12:09:55 <danielzx> or what do you mean?
12:10:02 <erisco> I am looking for an expression, which is going to be a constructor, that makes the empty list
12:10:24 <danielzx> wouldn't that be [] = []
12:10:38 <erisco> okay, why do you have = in there?
12:11:11 <erisco> lets just explain lists then
12:11:14 <danielzx> I was thinking in the same sense as "function name" [] = []
12:11:14 <erisco> :t []
12:11:15 <lambdabot> [a]
12:11:20 <erisco> > []
12:11:22 <lambdabot>  []
12:11:31 <erisco> [] is the constructor which makes the empty list
12:11:35 <danielzx> oh
12:11:41 <erisco> now, what other constructor do lists have?
12:11:50 <danielzx> :
12:11:55 <danielzx> [a]
12:12:05 <danielzx> [a,a,...n]
12:12:07 <erisco> right, so, given the empty list, how do you add an element?
12:12:14 <danielzx> a : []
12:12:33 <erisco> [a] and [a,a,...n] are not constructors
12:12:43 <danielzx> ok
12:12:46 <erisco> right, and what is another way to write  a : []  ?
12:13:18 <erisco> this other way is the sugar notation, i.e. using square brackets with comma-separated elements between them
12:13:21 <danielzx> [a]
12:13:36 <erisco> right
12:13:52 <danielzx> Uhm, can I ask a question?
12:13:55 <erisco> go ahead
12:14:21 <danielzx> How much left do we have to go through so that I can attack my assignment again?
12:14:57 <danielzx> not wanting to be rude or anything, if it sounded like that
12:15:05 <erisco> after group we need to just do a simple map
12:15:18 <erisco> this is the only difficult part of it
12:15:22 <humanoyd> Is there a 24-days-of-hackage this year?
12:15:26 <TMA> it depends on whether it starts making sense to you -- if it does, you'll be able to proceed fast, if not ...
12:15:52 <erisco> I am leading you through about the lowest path of resistance as I can think of, given that we cannot import group
12:16:21 <erisco> and the overall solution, given group and order (which we defined earlier), is a one-liner, so it is hard to beat that
12:16:37 <TMA> danielzx: back to [(1)] ... do you see why it is not the same as 1 : [()] ?
12:16:58 <danielzx> we can't change the content of a tuple?
12:17:03 <erisco> we seem to be getting tripped up over redundant parentheses and how the square bracket notation works
12:17:28 <erisco> [(1)] is the same as [1]
12:17:47 <hpc> but () is not the same as nothing
12:17:48 <erisco> we do not have 1-tuples in Haskell
12:18:12 <erisco> () is a constructor for a type also called () or pronounced "unit", and we needn't bother with that for this problem
12:18:28 <danielzx> so it's a waste of space
12:18:43 <erisco> no, it is just not applicable to the problem we're solving at the moment
12:19:30 <erisco> lets just go through a couple examples of translating between :/[] and the sugar notation
12:20:05 <erisco> desugar these: [1,2,3]  1:[2,3]  1:2:[3]
12:20:36 <erisco> then sugar these:  3:2:1:[]  3:2:[1]  3:[2,1]
12:21:34 <danielzx> (1,2,3:[]) for the first one, correct?
12:21:49 <erisco> no, because you have made a 3-tuple
12:21:56 <erisco> the answer needs to be a list
12:22:15 <danielzx> so then just 1,2,3 : []
12:22:20 <byorgey> danielzx: be careful with , vs :
12:22:41 <ertes> danielzx: comma is a feature of tuples and list *sugar*, not of unsugared lists
12:22:45 <erisco> okay, we should just explain it in totality then
12:23:40 <danielzx> please do, still need to grasp the sugar notation concept
12:23:42 <erisco> [x,…] desugars to x:[…]
12:24:29 <erisco> for the other you'll have to follow me on some meta-notation, so I am going to call this meta-function "sugar" which operates on syntax
12:24:33 <erisco> hopefully we don't get too confused here
12:25:39 <erisco> actually no, that'll make a mess how I was thinking of it… better to just reverse the desugar rule
12:26:08 <erisco> [x,…] desugars to x:[…]  and so  what does  [1,2,3]  desugar to?
12:26:12 <ertes> danielzx: all lists are of the form (x : xs) for some x and xs, or of the form []…  if you're looking at anything else that is a list, you're looking at syntactic "sugar" that will "desugar" to one of those two forms
12:26:55 <danielzx> so [1,2,3] desugars into 1:[2,3]
12:27:01 <hexagoxel> has anyone bothered to write/publish a prelude that avoids some of the syntax-sugar stuff? re-define tuples and lists, essentially (and hide ($) for good measure)
12:27:07 <erisco> correct, and then if you keep going, what does [2,3] desugar to?
12:28:05 <danielzx> 2:[3]
12:28:10 <erisco> and keep going
12:29:06 <hexagoxel> (could even remove all symbols to reduce syntax further.. "plus" "bind" "fmap" etc.)
12:29:13 <Welkin> hexagoxel: there are tons of alternative preludes
12:29:16 <danielzx> 3:[]
12:29:26 <Welkin> I've only used one: classy-prelude
12:29:39 <hexagoxel> Welkin: i know
12:29:43 <erisco> correct, and so starting with  [1,2,3]  what is it desugared all the way? (which is what I will normally mean when I ask to desugar something)
12:29:47 <Welkin> I prefer using the basics from the standard prelude
12:30:05 <hexagoxel> Welkin: i asked a more specific question.
12:30:24 <danielzx> 1:[2,3] then 2:[3] and then 3:[]
12:30:58 <TMA> danielzx: you are losing elements, the first list has three, the last just one
12:31:04 <erisco> okay, those are the individual desugaring steps we took, but I want you to solve for x in  [1,2,3] = x  where x is desugared
12:31:23 <ertes> danielzx: [1,2,3] = 1 : [2,3] = 1 : (…)  -- keep desugaring, *without* dropping the rest of the expression
12:31:56 <erisco> I didn't realise I was introducing a misconception that desugaring meant losing elements
12:32:11 <ertes> danielzx: the "1 :" doesn't magically disappear, when you desugar a *subexpression*
12:34:13 <erisco> I don't know what it is called when you get distracted from yak shaving but we're definitely there now XD
12:34:15 <danielzx> so it be becomes for [1:2:3] desugared equals 1:[2,3] and then 1:2:[3] and then 1:2:3[]
12:34:21 <danielzx> is that correct?
12:34:30 <erisco> try again… almost but you have some mistakes
12:34:53 <erisco> pay close attention to where you are using : and where you are using ,
12:34:56 <erisco> they are not the same thing
12:35:19 <ertes> danielzx: [3] ≠ 3 []
12:35:33 <erisco> : is a constructor, and  ,  is nothing, it is just a fragment of syntax
12:35:52 <danielzx> how do I seperate them instead?
12:36:08 <ertes> danielzx: you said earlier that [3] = 3 : []
12:36:11 <ertes> that was correct
12:36:13 <danielzx> ertes does it become 1:2:3:[] instead?
12:36:19 <erisco> the only time you separate things is when using the sugar, in which case you use the comma
12:36:19 <ertes> danielzx: exactly
12:36:23 <danielzx> gotcha
12:36:32 <erisco> : is not a separator, it is a constructor
12:36:47 <erisco> it has the appearance of separating elements but that is not what it is doing
12:36:54 <erisco> you can see this just by looking at  3:[]
12:36:59 <erisco> clearly [] is not an element of the list
12:36:59 <Welkin> why not explain it using Cons?
12:37:08 <Oldcpv3> Oi!
12:37:10 <danielzx> infrrf
12:37:11 <ertes> danielzx: feel free to use some parentheses:  [1,2,3] = 1 : [2,3] = 1 : (2 : [3]) = 1 : (2 : (3 : []))
12:37:13 <danielzx> indeed*
12:37:14 <Welkin> data List a = Nil | Cons (List a)
12:37:15 <Oldcpv3> Ehrm....
12:37:22 <danielzx> okay
12:37:23 <Oldcpv3> Why not use Javascript instead?
12:37:23 <Oldcpv3> Eh?
12:37:31 <danielzx> though doesn't that take a lot more space?
12:37:34 <Welkin> er
12:37:39 <Welkin> data List a = Nil | Cons a (List a)
12:37:42 <ertes> danielzx: we leave off the parentheses, because it's more convenient, but it's important to be aware of that structure
12:38:03 <Welkin> and then (:) is just infix Cons, and [] is just Nil
12:38:15 <danielzx> okay then
12:38:16 <erisco> danielzx, okay, so popping the stack here, lets get back to  1 : ([1,1])
12:38:25 <danielzx> yes
12:38:28 <hexagoxel> danielzx: you don't mean space at runtime, do you?
12:38:33 <ertes> danielzx: also for now try not to reason about space…  remember that haskell works very differently from other languages in terms of space
12:38:33 <erisco> danielzx, I want you to sugar it
12:38:44 <Welkin> lol what?
12:38:54 <danielzx> okay
12:39:01 <Welkin> I feel you are trying to think about too many different things all at once
12:39:08 <Welkin> stay focused on one thing at a time
12:39:17 <erisco> first remember that  ([1,1])  is the same as  [1,1]  because the parentheses are redundant there
12:39:46 <ertes> Oldcpv3: i can't tell if your question is serious…  if it is, you should provide more input/context
12:39:53 <danielzx> 1 : ([1,1]) would equal ([1,1,1]) correct?
12:39:54 <Oldcpv3> Eh
12:40:00 <erisco> long-running Q&A tends to be like fly paper… soon everyone will be chiming in ;)
12:40:04 <Oldcpv3> Wait
12:40:05 <Oldcpv3> Wrong channel
12:40:06 <Welkin> haha
12:40:07 <Oldcpv3> lol
12:40:19 <Welkin> well, we have an instinct here in #haskell to help
12:40:20 <ertes> heh
12:40:22 <Welkin> when we see someone struggling
12:40:25 <erisco> danielzx, yes sir, though the parens are still redundant
12:40:34 <danielzx> [1,1,1]
12:40:39 <danielzx> there you go ^^
12:41:06 <erisco> danielzx, okay, so now we have  let (g, xs') = ([1,1],[2,3]) in [1,1,1]  right?
12:41:11 <ertes> excess parentheses are fine, i think
12:41:19 <ertes> (for now)
12:41:25 <danielzx> yes
12:41:26 <ertes> it can help people see structure
12:41:28 <erisco> danielzx, what is missing? we didn't do anything with xs'. what should we do with it?
12:41:30 <daey> is there an end to struggling with types in haskell or is that an endless battle? :")
12:41:35 <Welkin> the parentheses are like giving your code a hug
12:41:39 <Welkin> it's nice, but you don't need it
12:41:42 <Welkin> unless you really do need it
12:41:47 <danielzx> we should sugar it with g?
12:41:58 <erisco> no no, sugar talk is done now ;)
12:42:06 <danielzx> oh so rip the sugars
12:42:09 <ertes> daey: endless battle…  not because it's very difficult, but because each time you master something, it will give you two more things to master =)
12:42:33 <erisco> [1,1,1] is the first group but we also need all the rest of the groups found in [2,3]
12:42:44 <daey> it feels like 90% of the time im hoogling trying to find a function that transitions type a -> b
12:42:59 <erisco> coerce ?
12:43:01 <ertes> daey: literally?
12:43:02 <danielzx> ok
12:43:10 <Welkin> daey: hoogle has hardly anything. Use hayoo
12:43:20 <danielzx> do we still skip sugaring or are going into a new concept now?
12:43:50 <Welkin> daey: or do you mean local hoogle?
12:44:12 <erisco> danielzx, the talk about sugaring was so you could understand  x : g
12:44:15 <daey> nah i meant the webpage
12:44:20 <ertes> danielzx: out of curiosity, what's the assignment?
12:44:28 <erisco> danielzx, now we have to move on and finish the group function
12:44:54 <Welkin> the hoogle website is nearly useless compared to hayoo (which searches everything on hackage)
12:45:06 <Welkin> local hoogle is cool, but I haven't bothered installing it
12:45:09 <erisco> danielzx, we can do this with recursion. Once we know how to find the first group of a list, then given the remaining list, we can recurse on it to find the rest of the groups
12:45:11 <daey> hayoo.fh-wedel.de that one?
12:45:22 <Welkin> yes
12:45:34 <TMA> ertes: I thought that $ exists because haskellers hate parentheses
12:46:03 <ertes> TMA: i think parentheses are fine, if they expose actual structure
12:46:07 <danielzx> hold on guys, I gotta go to the store to get something for dinner. I'll be right back
12:46:16 <erisco> some Haskellers seem to hate parentheses… not me
12:46:26 <ertes> TMA: good parens:  print (sin x)
12:46:27 <daey> to top of the type nightmare i learned about "{-# LANGUAGE OverloadedStrings #-}"
12:46:32 <ertes> TMA: bad parens:  1 + (2 + 3)
12:46:41 <danielzx> also erisco, could you explain the assignment to ertes while I'm gone?
12:46:56 <ertes> "write the group function?"
12:47:14 <danielzx> I can't import data types for my assignment
12:47:18 <daey> why does haskell need so many types anyways? why not use the basic C types?
12:47:20 <danielzx> so I can't import Data.List
12:47:27 <erisco> danielzx, okay
12:47:37 <c_wraith> daey: because types aren't about machine representation.  They're about meaning.
12:47:47 <c_wraith> daey: you should have as many different types as you mean different things
12:48:00 <erisco> ertes, the meat of the problem is to implement group, yes, the rest is to count occurrences of elements in a list, with a little twist
12:48:31 <erisco> ertes, the twist being that we have to consider (x, y) and (y, x) as the same element. We've done that, and we've sorted the list, and now we're not allowed to import group, so we're implementing it
12:48:50 <ertes> erisco: ah
12:49:26 <TMA> daey: you'll come to appreciate types when you find yourself adding the week number to the width of your window in pixels
12:50:19 <ertes> daey: well, IO is not a basic C type…  how do you represent effects without IO?
12:50:37 <daey> TMA: i will hoogle a few mins. https://img.memecdn.com/amp-quot-adapters-amp-quot_o_3321233.jpg
12:51:10 <ertes> i wonder what haskell with a more C-like type system would look like
12:51:22 <ertes> sort :: (Any -> Any) -> [Any] -> [Any]
12:51:44 <erisco> you mean  sort :: (Ptr Void -> Ptr Void) -> …
12:51:49 <hpc> haha
12:51:59 <ertes> err
12:52:03 <ggVGc> man haskell-ide-engine is a huge step up in responsiveness for me, compared to anything else I've used
12:52:10 <mnoonan_> ertes: <implicitConversion> :: MostTypes -> MostOtherTypes
12:52:11 <ggVGc> granted, I only used ghc-mod and intero actively
12:52:13 <TMA> ertes: volatile qualifier
12:52:18 <hpc> imo haskell has the best model for polymorphic and higher-order definitions of any language i have seen
12:52:20 <ggVGc> but haskell-ide-engine is basically instant for everything
12:52:41 <hpc> er, s/model/syntax
12:52:50 <hpc> but model too
12:53:17 <ggVGc> mnoonan_: I think it's kind of a shame that scala went with having implicit conversions..
12:53:24 <ggVGc> and use them for quite a few things
12:54:12 <mnoonan_> ggVGc: I’m glad they tried it, because it is an interesting corner of the design space, but it certainly seems like the end result is another data point againt the idea..
12:55:06 <TMA> ertes: sort :: Ptr Any -> Unsigned -> Unsigned -> (Ptr Any -> Ptr Any -> Int) -> IO ()
12:55:16 <erisco> oh good, I am glad to see this… the other IDE plugins were a start but not enjoyable
12:55:34 <ertes> nah, not C-like semantics, just C-like types
12:55:47 <ertes> id :: Any -> Any
12:56:05 <ggVGc> TMA: I think you mean sort :: Unsigned -> Unsigned -> Unsigned -> (Unsigned -> Unsigned -> Int) -> IO ()
12:56:11 <ertes> basically haskell with a completely brain-damaged type system
12:56:26 <ertes> even more than C# or go
12:56:59 <ggVGc> ertes: so far I'm getting instant type hints and fast on the fly linting
12:57:04 <ggVGc> and it
12:57:08 <ggVGc> it's really pleasant
12:57:16 <ggVGc> and works perfectly with my stack projects
12:57:26 <TMA> ggVGc: you have <implicit-conversion> from Ptr a to Unsigned but not the other way in C. of course, speaking of the assembly...
12:57:35 <erisco> well if we want to keep the persistence of Haskell, then we're going to have to allocate new space for a list
12:57:44 <ertes> ggVGc: i said: "i wonder what haskell with a more C-like type system would look like" =)
12:58:07 <erisco> but we don't want to be assuming of how to allocate it… so I am thinking  sort :: Int -> Ptr Void -> …  so we receive a buffer to write to
12:58:37 <erisco> we also need the element size, so another Int for that
12:58:53 * ggVGc grumbles something about laziness
12:59:06 <erisco> oh dear
12:59:17 <erisco> okay, so thunks in C… that's fun
12:59:34 <erisco> so we want to start by defining some structs…
12:59:44 <TMA> we might use the allocator :: Unsigned -> Ptr Void -> Ptr Void
12:59:53 <Welkin> wow erisco, you sure love to use elipses
13:00:02 <Welkin> unicode, even
13:00:02 <ertes> actually having a type system like javascript's would be kinda nice
13:00:06 <ertes> sort :: Stuff
13:00:08 <ertes> id :: Stuff
13:00:12 <ertes> putStrLn :: Stuff
13:00:25 <ertes> look how simple everything gets
13:00:26 <erisco> Welkin, it is the way my mother writes…
13:00:53 <ggVGc> ertes: I prefer lua's anything :: table
13:00:59 <ggVGc> well, or number
13:01:00 <Welkin> I always feel that when someone uses an elipsis in their text messages they are being sarcastic, or they are just stupid, or both
13:01:03 <ggVGc> or string
13:01:05 <ggVGc> but mostly table
13:01:17 <erisco> an ellipsis is like a flow of thoughts, whereas a period is like a stopping of thoughts
13:01:22 <ertes> ggVGc: lua is statically typed?
13:01:29 <ggVGc> what are two periods?
13:01:35 <erisco> bad grammar
13:01:47 <ertes> > [1..9]
13:01:49 <lambdabot>  [1,2,3,4,5,6,7,8,9]
13:01:50 <MarcelineVQ> prefer commas, they're the best way to have your cake, and eat it
13:01:54 <ggVGc> ertes: well, as much as JS is
13:02:06 <TMA> and then the sort would be sort :: Ptr Void -> Unsigned -> Unsigned -> (Ptr Void -> Ptr Void -> Int) -> (Unsigned -> Ptr Void -> Ptr Void) -> Ptr Void -> Void
13:02:08 <Welkin> ertes: lua's type system is like javascript, except it is strong instead of weak
13:02:16 <Welkin> but all "type systems" are static anyway
13:02:17 <erisco> yeah I dunno… incorrect commas are pretty cringy
13:02:20 <MarcelineVQ> sometimes though they make long sentences; nobody's into that
13:02:47 <Welkin> I prefer to say that "dynamic type systems" are "no type system"
13:02:55 <ertes> Welkin: yes, that's the joke =)
13:02:56 <Welkin> rather than say they are "static type systems with one type"
13:03:04 <erisco> a semicolon is dangerous; it commits me to making a complete sentence in the second part
13:03:10 <ertes> "dynamically typed" = there is only Stuff =)
13:03:29 <ggVGc> ertes: so, where's your period in that correct sentence?
13:03:30 <danielzx> erisco I'm back
13:03:34 <MarcelineVQ> don't sweat the small stuff: you'll be dead one day
13:03:35 <Welkin> there is really no different between a static type system with a single type vs no type system at all
13:03:38 <danielzx> Shall we continue?
13:03:49 <erisco> danielzx, okay. What did you figure?
13:04:42 <mnoonan_> @let eriscoHelper s = s ++ “; “ ++ eriscoHelper s
13:04:43 <lambdabot>  Parse failed: Parse error in expression: s ++
13:04:43 <ggVGc> why is it called semicolon instead of commacolon
13:05:00 <danielzx> You said we were supposed to finish the group function, or what do you mean?
13:05:17 <erisco> yes, that's right, and so I am asking where you are on it now
13:05:43 <geekosaur> ggVGc, you sure you want to know?
13:06:09 <danielzx> I don't exactly follow ^^'
13:06:23 <ertes> imma make a soft-drink and get rich
13:06:27 <ertes> Semicola (tm)
13:06:28 * hackage madlang 3.2.0.0 - Randomized templating language DSL  https://hackage.haskell.org/package/madlang-3.2.0.0 (vmchale)
13:06:46 <erisco> we only have part of the implementation done. We need to do something with xs'. You need to figure that out.
13:06:52 <ertes> just add some mate and hackers will go crazy
13:07:18 <geekosaur> (more or less, it's that a period is a full stop and a comma is a 'half stop', and colon is a semantic sense a doubled stop vs. semicolon being a one-and-a-half. it's expressing conceptual distance between concepts)
13:07:19 <TMA> ggVGc: a semicolon was originally half of colon (only the upper dot)
13:07:36 <ertes> my logo is gonna look like this: ;;;
13:07:50 <TMA> ggVGc: and semi is latin for half
13:07:51 <geekosaur> and that, in terms of 'etymology' if you can use that term with symbols
13:08:04 <ggVGc> if that's really the case, that's pretty interestingf
13:08:08 <ggVGc> also, quite weird
13:08:25 <geekosaur> communication is weird, if you start looking closely at it >.>
13:08:43 <danielzx> shoud we subsititute xs'?
13:08:45 <danielzx> possibly
13:09:16 <erisco> you need to look back to what group needs to do, and compare that to what we've already done
13:09:24 <erisco> then it should become evident what needs to be done with xs'
13:09:37 <erisco> I've explained that it needs to be involved in recursion
13:10:03 <TMA> ggVGc: the sign is used in greek writing (the sign that looks like ; is used instead of ? in Greek) -- it's called ano teleia there (meaning up/raised dot/full-stop)
13:11:57 <danielzx> We should recall the function group using xs' as an argument?
13:12:11 <danielzx> then keep doing so until xs' becomes empty
13:12:13 <erisco> yes that sounds like a good idea
13:12:27 <daey> if its not too much work, what am i doing wrong here? i know that the regex stuff works when i feed it a byteString from a file. so its most likely the issue is in line 15.
13:12:32 <daey> http://lpaste.net/1310251276260343808
13:12:48 <daey> the error being: Ambiguous type variable ‘source0’ arising from the literal ‘"A:\"([^\"+])"’
13:13:38 <danielzx> so call the function group for the list xs' after it's been done for g?
13:13:41 <geekosaur> daey, the issue there is it's not sure which possible overloaded string type to use
13:14:19 <ggVGc> TMA: haha. man, I wasn't expecting a real answer to this. thanks :) I am actually reading about semicolons now...
13:14:21 <erisco> danielzx, something like that, but I don't know what you mean by "after it's been done for g"
13:14:28 <geekosaur> it's kinda similar to the warning you get with the (^) operator, except overloaded strings have a few added complications
13:14:31 <geekosaur> :t (^)
13:14:32 <lambdabot> (Num a, Integral b) => a -> b -> a
13:15:11 <geekosaur> if the 'b' there is a literal, it can be difficult to fix a type for it. (defaulting does so but with -Wall you get a defaulting warning)
13:15:31 <danielzx> after the function has returned a list using g as the argument I mean
13:15:34 <geekosaur> strings are a bit more complicated, and unless you have a fairly recent ghc (8.x) it can't default them at all
13:15:55 <daey> i have ghc 8.2.1
13:16:02 <erisco> danielzx, g as an argument to what?
13:16:06 <AndreasK> ghc 8 is over a year old
13:16:23 <erisco> danielzx, just write the code, test it, and if you get stuck we can look at it
13:16:24 <geekosaur> yes I figured; the error would be even hairier otherwise :)
13:16:31 <danielzx> group? or am I think about it wrong now again
13:16:43 <daey> this OverloadedStrings tag feels like a shotgun solution for 'too many string types' problem. should i even use it?
13:16:45 <danielzx> the code for the question or the group function
13:16:51 <basicbasilic> hello, i'm looking for the applicative instance for ((->) r), can't find it, can someone help me? btw is there an easy way to find all instances of a class? hoogle doesn't seem to help much
13:17:03 <erisco> we need group to solve the problem, so write the code for group
13:17:44 <erisco> basicbasilic, type classes are open, so instances can exist anywhere a type is defined
13:17:47 <danielzx> okay
13:17:55 <geekosaur> anyway the upshot is you likely need to give the regex string a concrete type ("A:\"([^\"+])" :: String)
13:17:56 <ertes> basicbasilic: it's predefined
13:18:10 <ertes> > liftA2 (+) sin cos 5
13:18:12 <lambdabot>  -0.6752620891999122
13:18:12 <basicbasilic> ertes: what do you mean?
13:18:25 <ertes> basicbasilic: it comes with Prelude
13:18:34 <danielzx> I'm guessing I should just the recursion to the function using xs as the argument?
13:18:36 <hexagoxel> basicbasilic: http://hackage.haskell.org/package/base-4.10.0.0/docs/src/GHC.Base.html#line-697
13:18:44 <erisco> danielzx, try it
13:19:08 <geekosaur> because while ghc8 will attempt to default it, it can fail especially if other typeclasses are in play in the same expression: it doesn;t know which path to take to default it, so it tosses it back to you and asks for help
13:19:24 <basicbasilic> >  (\a -> Just (a, 1)) <|> (\b -> Nothing) $ (4 :: Int)
13:19:27 <lambdabot>  error:
13:19:27 <lambdabot>      • Could not deduce (Alternative ((->) Int))
13:19:27 <lambdabot>          arising from a use of ‘<|>’
13:19:39 <ertes> basicbasilic: that's Alternative
13:19:43 <basicbasilic> what am i doing wrong here?
13:19:49 <basicbasilic> oh sorry i meant alternative
13:19:51 <jle`> basicbasilic: what do you expect it to do?
13:20:03 <danielzx> http://lpaste.net/3012847857959960576
13:20:26 <jle`> basicbasilic: there is no Alternative instance for (<|>)
13:20:26 <basicbasilic> and come to think of it i think i'm looking for an alternative for the type (a -> f b)... does that exist?
13:20:29 <geekosaur> Alternative is not Applicative, it's Applicative plus additional functionality. that additional functionality is not always possible (or in some cases, there are too many possible implementations)
13:20:35 <jle`> *for (->) r
13:20:35 <erisco> danielzx, where did the rest of the work go? we had let/in remember?
13:20:45 <jle`> basicbasilic: ReaderT ?
13:21:25 <basicbasilic> jle`: hm... with an alternative functor inside? or outside, i never know which way is up
13:21:28 <ertes> basicbasilic: a -> f b ≃ ReaderT a f b, but it's inconvenient, because you need the wrapper type
13:21:37 <ertes> basicbasilic: there is also Monoid
13:22:03 <basicbasilic> ertes: maybe is a monoid?
13:22:14 <jle`> well it makes no sense ot use it alone, it would only make sense if you're leveraging Alternative-polymorphic functions
13:22:23 <jle`> what do you actually want to do?
13:22:24 <ertes> > ((`replicate` 'a') <> (`replicate` 'h') <> (`replicate` '!')) 5
13:22:26 <lambdabot>  error:
13:22:26 <lambdabot>      Ambiguous occurrence ‘<>’
13:22:26 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
13:22:30 <jle`> are you trying to use Alternative-polymorphic functions, like asum?
13:22:32 <ertes> @undef
13:22:32 <lambdabot> Undefined.
13:22:33 <ertes> > ((`replicate` 'a') <> (`replicate` 'h') <> (`replicate` '!')) 5
13:22:35 <lambdabot>  "aaaaahhhhh!!!!!"
13:22:44 <jle`> then ReaderT would give you the right alternative behavior for what you have
13:22:45 <erisco> oO
13:23:00 <basicbasilic> jle`: got a bunch of (a -> Maybe b), want to test them all on the same input and get the first that works out
13:23:04 <ertes> basicbasilic: there is a Monoid instance for Maybe, but check if it does what you want
13:23:17 <geekosaur> sounds like the First newtype to me?
13:23:32 <ertes> basicbasilic: yeah, in that case you can use First instead of Maybe
13:23:34 <jle`> basicbasilic: you can just map then asum?
13:23:47 <basicbasilic> :t asum
13:23:48 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
13:23:50 <jle`> asum (map ($ x) fs)
13:23:50 <geekosaur> (Maybe isn;t just a monoid, it's a monoid in multiple ways. the newtypes let you focus one one way)
13:23:53 <jle`> asum is also 'choice'
13:24:01 <basicbasilic> hm i gess that would be the simplest
13:24:03 <geekosaur> *on one way
13:24:04 <jle`> asum [x,y,z] = x <|> y <|> z
13:24:32 <ertes> > (const (First Nothing) <> First . Just <> const (First (Just 6))) 5
13:24:34 <lambdabot>  First {getFirst = Just 5}
13:25:02 <basicbasilic> jle`: thanks! :) i forgot that asum tool :)
13:25:20 <jle`> asum is like...the only real Alternative-polymrophic function that people use
13:25:40 <jle`> besides guard
13:25:44 <basicbasilic> i guess First is a good idea too, though for my use case, a little too heavy :)
13:25:59 <jle`> basicbasilic: yes if you rewrite your functions as (a -> First a)'s, then you can just use mconcat
13:26:14 <jle`> mconcat [f,g,h] x
13:26:22 <ertes> s/mconcat/fold/
13:26:31 <jle`> or foldMap (First .)
13:26:50 <basicbasilic> isn't that (a -> First (Maybe b)), or somethig?
13:26:50 <jle`> :t getFirst . foldMap (First .)
13:26:51 <ertes> as part of my secret legacy termination conspiracy =)
13:26:51 <lambdabot> error:
13:26:52 <lambdabot>     • Couldn't match type ‘a -> First a1’ with ‘First a2’
13:26:52 <lambdabot>       Expected type: t (a -> Maybe a1) -> First a2
13:27:01 <jle`> :t foldMap (First .)
13:27:02 <lambdabot> Foldable t => t (a1 -> Maybe a2) -> a1 -> First a2
13:27:04 <jle`> basicbasilic: not quite
13:27:06 <jle`> :t First
13:27:07 <lambdabot> Maybe a -> First a
13:27:12 <jle`> First is a natural transformation
13:27:17 <jle`> it turns a Maybe into a First
13:27:37 <jle`> not a Maybe into a First Maybe
13:27:41 <basicbasilic> ooh it's defined like that: data First a = First (Maybe a) ?
13:28:01 <basicbasilic> or newtype or whatever
13:28:21 <geekosaur> pretty much. a newtype whose only purpose is to substitute a different implementation of Monoid
13:28:24 <basicbasilic> jle`: what's the def of a natural transformation?
13:28:47 <jle`> basicbasilic: a naturl transformation from 'f' to 'g' is a `f a -> g a` that works for all a's
13:28:56 <jle`> :t listToMaybe
13:28:57 <lambdabot> [a] -> Maybe a
13:29:05 <jle`> :t First
13:29:06 <lambdabot> Maybe a -> First a
13:29:10 <ertes> @let type NT f g = forall a. f a -> g a
13:29:11 <lambdabot>  Defined.
13:29:55 * hackage persistent-sqlite 2.6.4 - Backend for the persistent library using sqlite3.  https://hackage.haskell.org/package/persistent-sqlite-2.6.4 (MaxGabriel)
13:30:26 <ertes> however, not every value of type (NT f g) is a natural transformation
13:31:04 <basicbasilic> what are the restrictions?
13:31:28 <basicbasilic> works for all a's? you mean polymorphic?
13:32:00 <ertes> basicbasilic: f is a natural transformation, if:  ∀ g, f . fmap g = fmap g . f
13:34:58 <basicbasilic> the letters are a bit confusing in your formulae
13:35:27 <basicbasilic> but i think i get it: the natural transformation must not impact the workings of fmap?
13:35:59 <ertes> basicbasilic: it has to be fmap-preserving
13:36:17 <ertes> > (listToMaybe . fmap (^2)) [3,4,5]
13:36:19 <lambdabot>  Just 9
13:36:25 <ertes> > (fmap (^2) . listToMaybe) [3,4,5]
13:36:27 <lambdabot>  Just 9
13:36:40 <monochrom> You can say that. But I would stick to the formula or the commuting diagram and not mince words.
13:36:53 <ertes> works for (^2) and any other function…  that's why listToMaybe is an NT
13:38:08 <danielzx> erisco I didn't write all of it down... I'm sorry!
13:38:59 <int-index> bifunctors in Haskell are strong with respect to tuples https://gist.github.com/int-index/e9b018a5f7f1313416903a12065161e3
13:39:13 <int-index> I'm looking for this class (or equivalent) in a library
13:39:27 <int-index> where can I find it?
13:40:00 <basicbasilic> monochrom: well if you start with a functor and end with another functor... i don't see how that could ever fail to work?
13:40:15 <basicbasilic> do you have a counter example?
13:40:16 <jevdplas> Hey guys, I am having a bit of a trouble profiling a Haskell program. Every time I profile the same program, the memory consumption looks very different. Also, the graph is just a triangle or a straight line, but I don't know what could cause this. Does anyone know what could cause this?
13:40:29 <basicbasilic> (sorry it wasn't directly addressed to monochrom specifically)
13:41:38 <joel135> pgiarrusso: I don't know what to try.
13:41:58 <basicbasilic> *counterexample of a function (h :: Functor f, Functor g => f a -> g a), that would not be a natural transformation
13:42:27 <pgiarrusso> joel135: can you repeat your problem here in case somebody has a better clue?
13:42:41 <joel135> yes
13:42:48 <pgiarrusso> let me try: you upgraded GHC on Arch Linux using pacman
13:42:57 <pgiarrusso> and `cabal install` broke
13:43:21 <pgiarrusso> now you moved ~/.cabal out of the way
13:43:22 <joel135> yes but i'm not sure it was the update that broke it
13:43:34 <pgiarrusso> fair point
13:43:56 <pgiarrusso> (please post the log, I’d do but I’m on a tablet, here copy-paste is a pain)
13:44:03 <joel135> ok
13:44:04 <geekosaur> we've seen several case in #xmonad where arch upgrading its ghc managed to skip a step
13:44:15 <geekosaur> sudo ghc-pkg recache --global
13:44:26 <joel135> https://pastebin.com/J2pGYe6s
13:44:30 <geekosaur> otherwise it can;t find even base
13:44:39 <geekosaur> that's it
13:44:45 <pgiarrusso> geekosaur: thanks
13:45:07 <pgiarrusso> OK joel135, I’ll leave you into geekosaur’s hands :-)
13:45:13 <pgiarrusso> good we moved here
13:45:34 <joel135> :-)
13:46:09 <joel135> geekosaur: I tried 'sudo ghc-pkg recache --global' but I get the same error after that.
13:46:12 <monochrom> basicbasilic: I don't know what "start with a functor and end with another functor" means. Anyway it's so easy to craft up open-to-interpretation wordings like this, and of course these wordings won't fail, since you can make it mean whatever you feel like, i.e., moving goal post.
13:47:22 <geekosaur> huh. that would be something more serious then. I know one person ended up having to remove and reinstall arch's ghc and ghc-static packages
13:47:44 <joel135> i could do that
13:47:52 <geekosaur> I have no idea what arch thinks it's doing with ghc any more :(
13:48:06 <joel135> ghc-static is not a package
13:48:44 <Average-user> what arch do you currently have?
13:49:07 <joel135> what do you mean by arch?
13:49:23 * hackage midimory 0.0.1 - A Memory-like (Concentration, Pairs, ...) game for tones  https://hackage.haskell.org/package/midimory-0.0.1 (HenningThielemann)
13:49:28 <mnoonan_> basicbasilic: https://duplode.github.io/posts/what-does-fmap-preserve.html  — tl;dr is that *in Haskell*, parametric polymorphism means that you can’t write down a counterexample, see also https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/
13:49:51 <joel135> oh ghc-static exists but is not installed
13:50:08 <Average-user> what do you mean with arch?
13:50:11 <ertes> basicbasilic: i don't think it's possible to construct a counterexample, except perhaps with some ⊥ trickery
13:50:16 <basicbasilic> parametric polymorphism is just the non-ad-hoc polymorphism?
13:50:39 <basicbasilic> ertes: so there aren't any real counter examples (in haskell)?
13:50:43 <joel135> Average-user: Arch Linux.
13:50:51 <geekosaur> ghc-static is a good idea because a lot of non-arch builds break without it unless you know to force them dynamic
13:51:02 <geekosaur> and sometimes their build systems don't make it easy to do that
13:51:04 <mnoonan_> basicbasilic: yeah, the “you can’t inspect this type variable” polymorphism
13:51:17 <ertes> basicbasilic: i'm not sure, but it looks impossible to me
13:51:21 <lambdamu> Hackage docs do not list the RealFrac instances for Float and Double, that is pretty sad
13:52:11 <Average-user> joel135: same thing
13:52:19 <mnoonan_> basicbasilic: in languages with non-parametric polymorphism, you could get a counterexample by making f do “different” things at different types
13:52:19 <basicbasilic> mnoonan_: inspect?
13:52:37 <monochrom> instanceOf in Java for example
13:52:42 <joel135> Average-user: I am using the latest packages.
13:52:44 <ertes> basicbasilic: parametric polymorphism means abstracting over types
13:52:51 <basicbasilic> mnoonan_: ... you mean like type dependent behavior?
13:52:54 <ertes> basicbasilic: i think mnoonan_ is explaining parametricity
13:53:01 <ertes> which is a different thing
13:53:03 <mnoonan_> like, a counterexample could be listToMaybe, tweaked so that it returns Nothing for all lists of type [Int]
13:53:04 <ertes> (though related)
13:53:31 <geekosaur> lambdamu, yes, that's a haddock bug that is proving difficult to track down
13:53:37 <mnoonan_> that won’t be a natural transformation, but it also won’t be a function you can write down in Haskell  (afaik!)
13:53:43 <basicbasilic> mnoonan_: hm... does it really break the above rule actually?
13:53:48 <joel135> How do I remove ghc completely and reinstall it?
13:53:55 <ertes> basicbasilic: id :: a -> a  -- this is parametric polymorphism, which means that 'id' is really a family of functions, one for each 'a'
13:54:11 <Average-user> joel135 what version of Arch, not what version of the packages.
13:54:13 <basicbasilic> ertes: ok that's what i thought it meant
13:54:17 <mnoonan_> basicbasilic: yes, fmap a function g :: Int -> NotInt, or NotInt -> Int
13:54:17 <ertes> basicbasilic: haskell also has the parametricity property, meaning that any defined value of type (forall a. a -> a) is the identity function
13:54:29 <ertes> basicbasilic: that's what mnoonan_ is explaining
13:54:37 <basicbasilic> mnoonan_: ooh true
13:55:09 <basicbasilic> mnoonan_: so, i get it: a natural transfo (f a -> g a) it must not depend on the type of a.
13:55:25 <joel135> Average-user: Arch is a rolling release distribution.
13:55:41 <mnoonan_> basicbasilic: right (in Haskell, anyway)
13:55:55 <Average-user> I know, but there are still, tricks to keep things away from changing
13:57:01 <basicbasilic> mnoonan_: thanks for the counter example, it helped my intuition :)
13:57:29 <basicbasilic> @src asum
13:57:29 <lambdabot> Source not found. Wrong!  You cheating scum!
13:57:40 <ertes> basicbasilic: parametricity is the reason why i can't think of counterexamples =)
13:58:01 <basicbasilic> ertes: :)
13:58:20 <lambdamu> geekosaur: And GHC.Float doesn't have any docs generated so that path of discovery is also closed, I wonder how many people have concluded Haksell has no way to turn a Float into an Int, but maybe people do not read docs these days and just assume round exists
14:00:10 <kritz> im thinking of using elm as a frontend for a game i wrote in haskell, has anyone used elm as a frontend before? How would I go about doing that
14:01:08 <kritz> I have my logic written in haskell. For user events how would I get elm to communicate with haskell... sry for a newbie quesiton (i'm new to web dev)
14:02:02 <woodson> kritz: https://github.com/haskell-servant/example-servant-elm
14:02:02 <mnoonan_> kritz: I really don’t know much about this domain, but you might want to also check out purescript if you haven’t yet. It’s a bit more Haskell-like, but also compiles to JS.
14:02:23 <woodson> I used this as a reference to build my little project
14:02:36 <jevdplas> Hey guys, I am having a bit of a trouble profiling a Haskell program. Every time I profile the same program, the memory consumption looks very different. Also, the graph is just a triangle or a straight line, but I don't know what could cause this. Does anyone know what could cause this?
14:02:38 <kritz> thanks
14:02:39 <woodson> its really easy
14:02:57 <kritz> i never used servant, but its for servers?
14:03:23 <woodson> it doesnt matter you will be communication via http request
14:03:45 <joel135> ghc-pkg check gives me these warnings. https://pastebin.com/7xJM945x
14:04:14 <joel135> How do I resolve them?
14:04:30 <kritz> I'm new to web dev. I have all my logic already in haskell for 2048. I'm guessing that when I get a user event, I have elm send a request to the server, which is processed in haskell
14:04:57 <monochrom> jevdplas: If your program finishes quickly, there is a factor about the profiler not taking enough samples during that short time.
14:05:25 <monochrom> jevdplas: If your program finishes quickly, there is a factor about the profiler not taking enough samples during that short time.
14:06:05 <ahihi> kritz: if your client needs to receive events from the server, consider using websockets instead of plain http requests
14:06:08 <woodson> kritz: you have two options either you make the request to your server's url or you generate a html file with elm and get your server to serve that one html file
14:06:29 <ahihi> but if the game logic is entirely driven by client events, plain requests will do fine
14:06:39 <kritz> ok thanks, think ill generate the html file with elm and have the server serve it
14:07:11 <woodson> kritz: if you need more help let me know 
14:07:28 <kritz> woodson: sure, thanks
14:07:28 <jevdplas> monochrom, I don't think that's the issue. It is a game, so it takes some time. However, in the graph it is only showing second 0.0 . I cannot figure out what it could be.
14:07:59 <woodson> hey can anyone help me figure out how to implement jwt with servant? I have been looking at servant-auth-server jose and jose-jwt
14:08:05 <woodson> but I am so confused 
14:08:42 <woodson> I just want to generate a jwt with an symmetric secret key and I dont want to save it to my clients cookie
14:09:07 <woodson> but the libraries explain little or the api's are just confusing
14:09:21 <woodson> anyone familiar with any of those libraries?
14:09:50 <joel135> I tried reinstalling ghc and ghc-libs but I still can't install lens.
14:09:58 <woodson> kritz: no problem just ping me whenever
14:10:25 <joel135> https://pastebin.com/bWkhdG4t
14:12:31 <jle`> ertes: i thought fmap-preserving was a free theorem?
14:12:38 <jle`> unless we're talking about not-haskell
14:14:49 <ertes> jle`: yeah, i noticed…  see above
14:15:52 <jle`> oh sorry, didn't read far enough :)
14:19:16 <mnoonan_> jle`: I got you, fam
14:24:25 * hackage madlang 3.2.0.1 - Randomized templating language DSL  https://hackage.haskell.org/package/madlang-3.2.0.1 (vmchale)
14:25:10 <ertes> "for all functors f, g every function of type (forall a. f a -> g a) is a natural transformation"…  i don't know why, but somehow that statement resonates with me
14:26:16 <jle`> i do take it for granted
14:26:48 <jle`> kind of like how fmap id = id implies fmap f . fmap g = fmap (f . g)
14:27:04 <jle`> paraemtric polymorphism is too powerful
14:27:22 <ertes> sure, but that's not what i mean
14:27:33 <daey> when i 'import Data.ByteString' does that also import 'submodules' i.e. 'Data.ByteString.Lazy.Char8'?
14:27:55 <fr33domlover> daey, nope
14:28:03 <ertes> it triggers the constructivist in me
14:47:20 <kritz> woodson: Would my haskell backend only be serving files? Or should I be able to have all the logic there?
14:58:55 <daey> what is the purpose of Network.HTTP.Simple.httpLBS requiring a 'Response Data.ByteString.Lazy.Internal.ByteString'? when i use 'OverloadedString' it is accepts a simple [Char].
14:59:55 <ertes> daey: i think you're confusing request and response
15:01:12 <daey> ertes: Couldn't match expected type ‘Request’ with actual type ‘[Char]’
15:02:22 <Average-user> have someone tried Lux? https://luxlang.github.io/lux/
15:05:04 <daey> well even the official examples use the OverloadedStrings thing :/ somehow i feel dirty using it
15:09:25 <bigos_> hi
15:12:14 <kritz> has anyone here used elm as a gui with haskell?
15:13:18 <ertes> daey: try rephrasing your question
15:13:38 <ertes> daey: what has the response of httpLBS to do with OverloadedStrings?
15:14:31 <ertes> daey: OverloadedStrings only changes the type and semantics of string literals, nothing else
15:27:59 <fenedor> kritz, i did
15:28:36 <kritz> fenedor: what packages did u use? Or do u have an example 
15:28:58 <kritz> I have my logic written in haskell for 2048 for terminal and I want to port the gui to elm 
15:29:14 <daey> ertes: but doesnt overloadedStrings essentially reduce the type diversity?
15:29:17 <fenedor> what for exactly? we mainly used websockets for the communication
15:30:05 <daey> wouldnt it be better to transform the parameter into the correct type instead of simply declaring it to be correct?
15:30:08 <kritz> i actually dont need a server, I just wanted to use it for the front end, for handling user events
15:30:09 <daey> globally
15:30:28 <kritz> and keep my game logic in haskell
15:30:50 <geekosaur> daey, define 'transform'
15:31:12 <geekosaur> OverloadedStrings does exactly one thing: it causes the compiler to wrap all literal strings into a call to fromString
15:31:33 <geekosaur> the same way it wraps numeric literals in fromInteger or fromRational as appropriate
15:31:35 <ertes> daey: imagine a variant of haskell, where all integer literals were of type Integer
15:31:49 <ertes> daey: whenever you wrote 5, it would mean the Integer 5
15:31:55 <daey> well httpLBS wants a 'Request'. i have a [Char]. so i can either do the StringOVerload or find a function that does [Char] -> Request
15:32:10 <fenedor> kritz, well, you will need some communication layer, and did you look into threepenny-gui https://wiki.haskell.org/Threepenny-gui? that package uses the browser, too
15:32:27 <kritz> yea thats actually what I'm using
15:32:52 <fenedor> ok, yeah, so, do you wanna use websockets or the raw http protocol? 
15:32:54 <ertes> daey: now this would be an awkward language, right?  now there would be a haskell extension OverloadedIntegers that would change the meaning of integer literals
15:33:23 <kritz> which would be easier?
15:33:32 <ertes> daey: whenever you wrote 5 with that extension on, its semantics would be (fromInteger 5), and the type of integer literals would therefore be ((Num a) => a)
15:33:56 <ertes> daey: this is actually how integer literals in haskell work right now, without extensions
15:33:57 <ertes> :t 5
15:33:59 <lambdabot> Num p => p
15:34:10 <ertes> daey: OverloadedStrings does the same for string literals
15:34:32 <fenedor> i'd say, they are both a fair share of work. 
15:35:12 <daey> i though a 5 would always be interpreted as an int. e.g. let a = 5
15:35:18 <kritz> guess id do sockets
15:35:19 <fenedor> i haven't had the opportunity to communicate via raw http calls, and websockets seems to be easily integrated in elm apps
15:35:26 <ertes> > 5 :: Double  -- daey
15:35:28 <lambdabot>  5.0
15:35:42 <fenedor> you are probably interested in a tool like elm-bridge
15:35:48 <ertes> daey: because the type of 5 is (Num a => a), you can specialise it to Double
15:36:04 <ertes> daey: if the type of 5 were Integer, this would be a type error, because Integer ≠ Double
15:36:06 <fenedor> to convert your haskell datatypes to elm, and generating javascript decoder for elm
15:36:08 <kritz> fenedor: guess i'll check that out. thanks!
15:36:11 <daey> yeah but then its not a bare '5' anymore
15:36:27 <kritz> so that converts the data types to elm
15:36:54 <erisco> :t let x :: Double; x = 5 in x
15:36:55 <lambdabot> Double
15:36:55 <ertes> daey: (5 :: Double) is still bare 5, but with a type signature…  keep in mind that type signature aren't casts
15:37:07 <fenedor> well, it serializes it using aeson and provides methods to generate appropiate decoder for elm
15:37:20 <daey> let me rephrase the question. why is OverloadedStrings not always on? when it basically seems to be perma on for numbers
15:37:21 <fenedor> and encoder as well
15:37:26 <ertes> daey: all the type signature does is *restrict* its type
15:37:51 <Welkin> daey: because if it i on, you annot gaurantee the type of your string literals
15:37:54 <ertes> daey: well…  extra polymorphism comes at a cost, and not everybody seems to agree that the cost is worth it
15:37:56 <Welkin> sometims you want them to be String
15:38:16 <ertes> daey: you might find yourself writing ("abc" :: String), with OverloadedStrings on
15:38:19 <erisco> it is possibly because people don't like ambiguous type errors ;)
15:38:34 <daey> ah that restricts the overload?
15:38:44 <ertes> :t "abc"
15:38:45 <lambdabot> [Char]
15:38:50 <daey> then i can see the difference to casting
15:38:58 <ertes> :t fromString "abc"
15:38:59 <lambdabot> IsString a => a
15:39:21 <ertes> daey: with OverloadedStrings on ever string literal gets an implicit 'fromString'
15:39:27 <ertes> *every
15:39:56 <ertes> personally i like the idea of OverloadedStrings being default
15:39:58 <fenedor> kritz, if you have a lot of sets or Data.Map, you should consider using a fork of elm-bridge, since the original package does only support Data.Maps in a list like fashion, e.g. a map of Map Int String is translated to [(Int, String)], which might be quiet annoying
15:41:39 <kritz> oh ...
15:41:42 <kritz> ok thanks
15:44:58 <fenedor> kritz, if you have a lot of code organized in maps, checkout the pull request in the repository *shameless self advertising*
15:46:11 <Gurkenglas-> Why does Data.Set not export nubOrd :: Ord a => [a] -> [a]?
15:46:31 <daey> my god its working. http://lpaste.net/7878389026518990848 . By removing the OverloadedStrings and using Data.String.fromString instead i got it to work. now if i use the overloadedStrings instead, it doesnt work because the msk function chokes on the types, what i dont really get because they should be clear
15:47:06 <kritz> fenedor: Thanks haha. This doesn't include conversion for functions, right?
15:47:18 <exio4> Gurkenglas-: I believe you can implement it "when you need it" doing (S.toList . S.fromList)
15:47:34 <fenedor> haha, no, no clue how this would be supposed to be sent over the network 
15:47:57 <exio4> Gurkenglas-: no, no heavy need to implement
15:53:53 <kritz> think ill stick with threepenny. I have an issue where it isn't reading my css file
15:54:52 <kritz> UI.addStyleSheet window stringfilepath, for path I'm not sure what to write, because no matter where I seem to place my css file it isn't read unless i have the path incorrect
15:54:57 <fenedor> yeah, if you only want to show it, it seems smarter to stick to threepenny, but elm is cool anyways, i'm gonna continue experimenting with it
15:55:25 <fenedor> are you using stack?
15:57:13 <kritz> yea
15:57:40 <fenedor> then the path is relative to your project root 
15:58:50 <alp> woodson, servant-auth already provides a JWT impl for servant IIRC
15:59:01 <alp> the library has a readme
16:07:41 <z_jay_v> i saw here [https://news.ycombinator.com/item?id=7161236] that the haskell channel has a repl bot; if so, how to use?
16:07:55 <ertes> > 1 + 1
16:07:56 <lambdabot>  2
16:08:05 <z_jay_v> neat!
16:08:07 <ertes> :t putStrLn
16:08:08 <lambdabot> String -> IO ()
16:08:28 <ertes> z_jay_v: you can also /query lambdabot
16:09:03 <centril> Is there some sort of ritual for when you get  +++ OK, passed 100 tests.  on a part of your lab-submission after the test takes 0.5 minutes to compute? :P
16:12:33 <kritz> fendon: My css file is in my src folder, so I tried "/src/css", then "./src/css" but neither worked
16:13:53 <ertes> centril: yes…  raise your dominant hand to about the height of your face, then accelerate it toward your cheek…  if you do it properly, you will feel a biting sensation that reminds you to write more efficient tests =)
16:15:07 <centril> ertes: sure, I'll tell the course-responsible to write more efficient tests :P
16:15:46 <ertes> you could add a size limiter to the test
16:15:55 <ertes> using e.g. (==>) or some of the wrapper types
16:16:33 <centril> ertes: (specifically a test checking that substitution and substitution written in the language itself are semantically equivalent)
16:16:47 <centril> ertes: I'm satisfied with 0.5 minutes ;)
16:19:03 <daey> i thought there is one 'map' definition, but it seems like every module has one o.o
16:19:46 <ertes> daey: modules can reexport stuff from other modules
16:20:00 <ertes> the 'map' from Prelude is the same as the one from Data.List
16:20:04 <daey> so essentially i can only use the functions of a module that provided the data type that im working with?
16:20:22 <ertes> daey: it's not about modules directly
16:20:26 <daey> i see. not that i understand why they would do that but....
16:20:56 <ertes> daey: if two modules both define a type called X, then these are different types, despite having the same name
16:21:13 <ertes> daey: but module B can import X from module A and define a function for that X
16:21:44 <ertes> if you import module B, you don't import X itself, but given a value of type X, you can still use that value with functions from B
16:22:18 <daey> so when i work with a 'Data.ByteString.,ByteString' i should use msk' a = Data.ByteString.map $ (Data.ByteString.drop 1) $ getAllTextMatches $ msk a
16:23:40 <ertes> daey: yes (and note that ByteString is not a text type)
16:27:31 <daey> ertes: i take it's an 'array of bytes' that can be interpreted as a string?
16:31:02 <monochrom> It qualified for "string" 20 years ago when everyone assumed that the whole world needed nothing more than ASCII.
16:31:08 <monochrom> Today it's a Unicode world.
16:31:30 <monochrom> But I do expect old habits to last for 40 years.
16:32:10 <daey> considering that most of the world still runs on a language that doesnt even know strings :')
16:38:25 <davean> daey: its strung together bytes
16:40:07 <daey> ok thats what i thought.
16:41:21 <davean> daey: so why aren't you using Text say? 
16:41:57 <daey> because regex is only useable with byteString
16:42:18 <daey> or rather bearable :')
16:42:29 <kritz> anyone here know where to place css files when using threepenny? When i run my program it assumes css files are in a static folder which I don't have: "GET /static/css/2048.css"
16:42:35 <inkbottle> Doesn't "stack build" automatically install packages in the dependencies? 
16:42:37 <inkbottle> I have "pipes-files" in dummy dependencies, and am surprised "stack build" doesn't install it.
16:42:52 <inkbottle> But maybe I did sth wrong
16:43:14 <Cale> daey: Why aren't you using a parser combinator library? ;)
16:43:41 <geekosaur> inkbottle, it did install it. but the way stack works, only the dependency can see it
16:43:45 <ertes> daey: regexes are generally rarely used in haskell, because we have parser combinators
16:43:51 <daey> i rather stick to what i know while learning something new
16:44:08 <geekosaur> you don't automatically get your dependencies' dependencies directly usable in your own project, you have to declare that explicitly
16:44:23 <inkbottle> geekosaur: OK, I verify if it is installed...
16:44:54 <ertes> daey: if you must, there are regex libraries for Text
16:44:58 <ertes> like regex-tdfa-text
16:45:32 <daey> everything non byteString apears to be roughly 100+ times slower than pythons equivalent :P
16:45:35 <monochrom> and regex (http://hackage.haskell.org/package/regex)
16:45:59 <daey> the bytestring solution is only 3x slower ^^
16:46:31 <ertes> daey: that's probably not directly related to the string type
16:46:35 <daey> granted i havent used tdfa-text yet, first time i hear about it
16:47:03 <ertes> if you want speed, learn parser combinators
16:47:12 <daey> i just want to wrap my head around the haskell basics so the how isnt really important atm
16:48:23 <ertes> regex in haskell is the kind of thing that everybody seems to love to write libraries for, but nobody actually likes to use =)
16:48:37 <ertes> we have lots and lots of regex libraries
16:48:43 <daey> Data.ByteString has the following map implementation: map :: (Char -> Char) -> ByteString -> ByteString
16:49:05 <monochrom> regex jobs aren't representative of Haskell basics at all.
16:49:22 <daey> what im trying to do is map (drop 4) [ByteString]. which if i see correctly that implementation doesnt allow
16:49:28 <monochrom> For Haskell basics you would be better off with a binary search tree project.
16:49:35 <daey> monochrom: the regex already works thats two lines
16:50:26 <lyxia> there are map and drop for lists, which are in Prelude
16:51:04 <daey> yeah thats what i thought as well. so i can use functions from other libs. but the Prelude one throws the same error
16:51:27 <daey> Couldn't match expected type ‘Data.ByteString.ByteString’ with actual type ‘[Data.ByteString.ByteString]’
16:52:03 <daey> for the ByteString implementation i can understand that error but not for the Prelude.map one :/
16:52:09 <monochrom> ByteString has a drop but it name-clashes with Prelude's drop which is for list. You will need to learn detailed import clauses to resolve name clashes.
16:52:37 <Cale> daey: You should expect everything which operates on the type String to be horribly slow and probably space inefficient too.
16:52:42 <daey> im import qualified everything atm for that reason :D
16:53:07 <tdevries9> Hello
16:53:25 <Cale> tdevries9: Hello!
16:54:20 <tdevries9> So I have a brief technical question about Monads. 
16:54:35 <Cale> Sure
16:54:45 <tdevries9> They can be defined in terms of `bind` and `return` or `fmap` and `join`
16:55:03 <tdevries9> However couldn't they also be defined in terms of `fmap` and `bind`
16:55:04 <Cale> (and return)
16:55:10 <monochrom> If you're looking at "map (drop 4) (xxx :: [ByteString)" then the "drop" should be ByteString's "drop", but the "map" should be []'s map, obviously.
16:55:14 <Cale> fmap and join isn't enough
16:55:24 <Cale> you need return too
16:55:42 <Cale> and fmap and bind doesn't work for the same reason
16:56:03 <tdevries9> You just answered my question before I finished asking it LOL
16:56:30 <tdevries9> I was going to ask why you couldn't define them in terms of fmap and bind
16:57:05 <Cale> Well, you have no way to increase the number of m's then
16:57:29 <Cale> fmap basically leaves it the same (unless the function you provide increases it)
16:57:41 <Cale> join reduces the number of m's
16:58:42 <Cale> Basically, there's no way to put these puzzle pieces together to make something with return's type
17:00:43 <inkbottle> geekosaur: I verified the package hasn't been installed; I've put the errors and the ".cabal" file there: http://lpaste.net/7905902874779975680
17:01:18 <tdevries9> Wouldn't `bind foo  (\x-> return x+1)` be identical to `fmap foo (\x -> x+1)` 
17:02:49 <geekosaur> inkbottle, it is hidden. it's not in the resolver so it can only be accessed via a stack.yaml dependency
17:02:50 <daey> is there a chance that im still not using Prelude.map in line 14? http://lpaste.net/8161256156749103104
17:03:27 <daey> it's a piece of art, isn't it? :")
17:03:43 <inkbottle> geekosaur: OK, but why does it appear there? https://www.stackage.org/package/pipes-files
17:03:59 <Welkin> `map` is only found in Prelude and Data.List
17:04:06 <Welkin> the map in Prelude is from Data.List
17:04:08 <geekosaur> er? I just did a stackage search and it said nothing found. sigh
17:04:15 <Welkin> Prelude simplu re-exports from other modules
17:04:18 <daey> Welkin: also in ByteString
17:04:19 <geekosaur> gyess their search is fubar
17:04:20 <monochrom> Frankly I don't understand $
17:04:31 <daey> but they are all imported as qualified so they shouldnt be used
17:04:42 <geekosaur> oh, I searched latest lts
17:04:48 <geekosaur> also consider reading that page
17:04:57 <Welkin> you imported everything qualified daey 
17:04:57 <geekosaur> "This package is not currently in any snapshots"
17:05:01 <geekosaur> which means it will not show up
17:05:02 <Welkin> so it is from prelude
17:05:04 <MarcelineVQ> daey: you can write  Prelude.map  if you're really super not-sure
17:05:06 <monochrom> > (&&) $ True $ True
17:05:09 <lambdabot>  error:
17:05:09 <lambdabot>      • Couldn't match expected type ‘Bool -> Bool’
17:05:09 <lambdabot>                    with actual type ‘Bool’
17:05:18 <daey> MarcelineVQ: already tried that
17:05:18 <monochrom> OK, that's better.
17:05:24 <Welkin> you may as well just use fmap
17:05:27 <inkbottle> geekosaur: makes sense
17:05:30 <geekosaur> stackage knows about packages on hackage. that does not mean it exposes ever package on hackage it only exposes the current resolver
17:05:34 <daey> Welkin: tried that as well :')
17:05:35 <Welkin> you shouldn't care which map it is
17:05:38 <geekosaur> or anything extra-deps in stack.yaml
17:05:48 <geekosaur> so add it as an extra-dep
17:06:12 <monochrom> OK so you're looking at: map ( (Data.ByteString.drop 4 (getAllTextMatches (msk a) )))
17:06:16 <MarcelineVQ> daey: what was the question again? ehe also does this compile?
17:06:17 <geekosaur> the whole point of stack is to do this because ghc will do weird things if it can see more than just the packages you need
17:06:30 <daey> MarcelineVQ: no it doesnt due to line 14
17:06:32 <inkbottle> geekosaur: I will first try and change the resolver (for the pedagogical purpose)
17:06:39 <geekosaur> (we see this in xmonad all the time, if you have multiple versions of some things installed you can get some rather perplexing build errors)
17:06:42 <Welkin> daey: replace it with `fmap` and you should be good
17:06:48 <monochrom> which is obviously not the same as: (map (Data.ByteString.drop 4)) (getAllTextMatches (msk a))
17:06:49 <MarcelineVQ> in that case monochrom's advice will lead you to the oasis
17:06:52 <Welkin> unless it is another type error unrelated
17:07:02 <monochrom> So I guess you don't understand $ either.
17:07:10 <monochrom> So don't use $. Parentheses don't lie.
17:07:17 <geekosaur> because xmonad doesn;t rely on stack (or cabal) to build configs, only on ghc, and ghc is rather easy to confuse
17:07:19 <monochrom> $ is the root of all evil.
17:07:29 <Welkin> $ can be tricky at first
17:07:30 <monochrom> $ does not mean "do what I mean".
17:07:36 <Welkin> you will get a feeling for how to use it over time
17:07:41 <geekosaur> so stack walls everything off and the only packages that are exposed to it are the ones in a resolver (a known-compatible subset) and your declared extra-des
17:07:41 <monochrom> $ is cargo culting
17:07:44 <geekosaur> extra-deps
17:08:24 <Welkin> there are a few people who hate $ and put tons of parentheses in their code to make it look like lisp
17:08:27 <Welkin> I am not one of them
17:08:36 <monochrom> I am not one of them either.
17:08:37 <nshepperd> $ is infixr, what's the problem
17:08:44 <geekosaur> $ is fine if (a) you know how to use it (b) people reading your code know how to use it
17:08:58 <daey> monochrom: im pretty sure that the syntax is correct, as im using the same line in another script where it works (with String instead of ByteString though)
17:09:16 * tabemann loves $
17:09:31 <Cale> I just have a personal rule that I never make use of the fact that $ happens to be defined as infixr
17:09:34 <tabemann> (I also love .)
17:09:37 <daey> one of the few sane things ive encountered :D
17:09:44 <geekosaur> (b) isn't something you have a lot of control over, and people are good at looking at things and coming to unexpected conclusions ("cargo culting" or "the leopard print sofa problem:" depending on how you look at it :)
17:09:46 <tdevries9> Is there a version of $ that is reversed something like ML's |> operator? 
17:09:55 <tabemann> so my code ends up looking like foo . bar . baz $ quux x y
17:10:16 <monochrom> & is reversed $
17:10:18 <lyxia> @hoogle (&)
17:10:18 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
17:10:18 <lambdabot> Control.Lens.Lens (&) :: () => a -> (a -> b) -> b
17:10:18 <lambdabot> Control.Lens.Operators (&) :: () => a -> (a -> b) -> b
17:10:26 <Cale> tdevries9: There is, but generally don't...
17:10:45 <erisco> the left-associative one is `id`
17:10:56 <tdevries9> Cale: In the move from F# to haskell I very much miss it's piping operators. 
17:11:10 <mniip> erisco, hah
17:11:18 <Welkin> daey: you could write line 14 as `msk' = Data.ByteString.drop 4 <$> Text.Regex.PCRE.getAllTextMatches . msk` instead
17:11:22 <mniip> mixing infix $ and `id` sounds great
17:11:40 <Welkin> learning to use $ with composition and other infix functions is important
17:11:46 <Welkin> especially =<<, too
17:11:48 <erisco> yeah I did that a couple months ago to remove all parens from an expression
17:11:52 <tabemann> you just typically "pipe" from right to left in Haskell
17:11:54 <Cale> Things are easier to read if data is flowing in a consistent direction. Since we're not about to switch to writing the functions after their arguments, using & mostly just makes your code annoying to read.
17:12:18 <daey> Welkin: i dont know whats going on here... i tried monochrom's suggestions, which didnt work. then removed the -- infront of my intial ones and now it works....
17:12:35 <Cale> Use function composition (.) instead, as much as possible, and then ($) to apply your composed function to an argument
17:12:42 <geekosaur> next up, a haskell-forth hybrid? :p
17:12:53 <Welkin> daey: $ is function application and associates to the right
17:12:54 * tabemann hates the precedence of (<$>) though
17:13:19 <erisco> has to be higher than <*>
17:13:26 <tabemann> where I'd want to write foo <$> bar $ baz quux but end up having to write foo <$> (bar $ baz quux)
17:14:14 <Cale> Also, sometimes I like to grep our codebase for occurrences of >>= that are not followed by \case -- usually that's a good sign that someone has written some gibberish that I'll have to decipher and replace.
17:14:45 <Welkin> Cale: biapplicatives? bifunctors?
17:14:56 <Welkin> eithers wrapped in maybes
17:15:02 <tabemann> I practically never use (=<<) whereas I use (>>=) not infrequently
17:15:06 <tabemann> whoops
17:15:16 <MarcelineVQ> daey:  this is the important bit    "<monochrom> OK so you're looking at: map ( (Data.ByteString.drop 4 (getAllTextMatches (msk a) )))"  what monochrom is saying here is that's what your current line means. he's just changed $, which is right associative, to parens
17:15:16 <Cale> =<< works better with do-notation
17:15:18 <Welkin> I prefer =<< because it works well with (.)
17:15:21 <tabemann> I practically never use (>>=) whereas I use (=<<) not infrequently
17:15:23 <erisco> =<< is nice for (->)a
17:15:26 <Cale> and with composition and everything else
17:15:35 <tdevries9> @hoogle (=<<)
17:15:35 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:15:35 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:15:35 <lambdabot> Data.GI.Base.ShortPrelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
17:15:36 <MarcelineVQ> it's not a suggestion to try that line, it's showing the error in it
17:15:58 <Cale> (=<<) is just (>>=) with the arguments flipped
17:16:06 <Welkin> MarcelineVQ: show daey the error in their ways! Repent!
17:16:08 <daey> MarcelineVQ: yeah i got that. i think the reason mine works is because i have one set of () in it
17:16:16 * Welkin throws holy water on daey's face
17:16:26 <MarcelineVQ> Welkin you are full of beans.
17:16:47 * daey turns to ash
17:16:49 <Gurkenglas> How should I rewrite "\x -> if has l (f x) then h (traverseOf l g (f x)) else i x" to only inspect l once?
17:17:48 * tabemann has no idea of what l, f, g, or i even are
17:17:58 <erisco> tabemann, but that is precisely where you use `id`
17:17:59 <monochrom> @type traverseOf
17:18:00 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
17:18:09 <Cale> Step 1, remove any uses of lens from it, so it's obvious what's going on
17:18:09 <Welkin> lgbtbbq
17:18:12 <Cale> ;)
17:18:29 <erisco> tabemann, fmap foo $ bar `id` baz quux
17:19:03 <erisco> parens are so passé
17:19:10 <Welkin> just write your entire program using S and K combinators
17:19:20 <Welkin> what could go wrong?
17:19:40 <monochrom> Lacks fix.
17:19:41 <tdevries9> My brain hurt's trying to keep up with this channel. 
17:19:55 <Welkin> monochrom: you can construct it with S and K
17:20:05 <monochrom> oops, nevermind
17:20:11 <erisco> not in a typely manner
17:20:40 <Welkin> tdevries9: we are all making jokes at this point
17:20:42 <mniip> {-# LANGUAGE RankNTypes #-}
17:20:48 <tabemann> church numerals cannot be a space-efficient encoding of numbers
17:21:18 <tabemann> they've gotta make peano numbers look compact
17:21:43 <tdevries9> Welkin I know I'm just not used to haskell syntax so it takes me a while to understand any code posted. 
17:21:44 <Welkin> the original version of haskell was implemented using church numerals for integers, right?
17:21:50 <tabemann> lol
17:22:08 <mniip> the original version of haskell also had no IO
17:22:13 <Cale> Welkin: not as far as I'm aware, but the early versions of Haskell are rather fun to look at
17:22:33 <Cale> They had I/O, but not IO :)
17:22:41 <mniip> yes
17:23:04 <mniip> the main entrypoint was a pure event processor, I've read about it
17:23:17 <tabemann> didn't they do I/O through something like having one (lazy) list of inputs and one (lazy) list of outputs?
17:23:38 <Cale> Your main would be a function [Response] -> [Request]
17:23:42 <Cale> yeah
17:23:42 <mniip> hmm
17:23:50 <mniip> implementing IO on top of *this* sounds fun
17:24:05 <mniip> I mean the monadic interface
17:24:10 <Cale> Yeah, you totally could
17:24:11 <tdevries9> Although the IO monad could be implemented as an abstraction over that early system. 
17:24:24 <tabemann> you can't have Haskell's vaunted concurrency support implemented over that
17:24:34 <Cale> Though you would have trouble defining Monad
17:24:44 <Cale> because Haskell 1.0 didn't have constructor classes yet :)
17:24:47 <jle`> i don't think it's possible to get the capabilities of our current IO type just working over that
17:24:50 <mniip> concurrency? it was the 90s
17:24:57 <monochrom> Turned out to be very do-able. First you build a CPS layer on top of it. Then you're just one small step away from monad.
17:25:09 <Cale> jle`: You could get an IO monad that could do everything that Haskell 1.0 could do
17:25:19 <monochrom> And even the CPS layer is already provided by the standard library.
17:25:19 <jle`> fair
17:25:44 <Cale> Also, I think probably you could have threads
17:25:47 <mniip> for concurrency you could uh
17:25:52 <mniip> a Free monad?
17:25:56 <Gurkenglas> Ah, since the Traversal l is affine, I think I can do "\x -> case holesOf l (f x) of [Pretext hole] -> h (hole g); [] -> i x". I got there by thinking of l as "a -> Maybe (a -> b)" and wondering whether I can make it "a -> Maybe b", thanks Cale.
17:26:30 <Cale> Gurkenglas: haha :D
17:26:42 <monochrom> For concurrency you could add more data constructors to Response and Request
17:27:06 <mniip> oh yeah you totally could have a Request that spawns a thread
17:27:07 <Cale> Yeah, you'd have to add a request which took a Dialogue for the new thread
17:27:23 <mniip> imagine the awkward IPC
17:27:45 <tabemann> it'd be a pain to implement shared memory
17:27:48 <monochrom> For example "data Request = ... | ForkIO ([Response] -> [Request]) | ..." and "data Response = ... | ForkIOAnswers ThreadId | ..."
17:28:37 <tdevries9> Wouldn't that make your program non deterministic? 
17:28:46 <monochrom> Yes.
17:28:58 <monochrom> Concurrency adds nondeterminism.
17:28:59 <Cale> Forking threads usually does
17:29:01 <mniip> are threads intrinsicly deterministic?
17:29:02 <Cale> yeah
17:29:09 <tabemann> threads with preemption are
17:29:10 <inkbottle> geekosaur: Of course it didn't work (what did you say: read the page; I missed this one). So I tried to add it to extra-deps; but ultimately it didn't work, probably because the dependencies of the package are broken. And that's probably why "stack" is so useful.
17:29:16 <tabemann> "fibers" are not
17:29:20 <Cale> mniip: intrinsically nondeterministic
17:29:23 <mniip> tabemann, threads with preemption need not be IO
17:29:33 <mniip> check out ContT
17:29:44 <monochrom> Schedulers are modelled as nondeterministic because even after you know the details of the actual scheduler you use you're no wiser than looking at a PRNG.
17:29:44 <geekosaur> you do need to be careful. you might see if the thing you installed that was using it already has a stack.yaml, and crib from that
17:29:57 <tabemann> ContT supports preemption?
17:30:01 <monochrom> But I/O is already nondeterministic enough.
17:30:22 <monochrom> Next time you use getLine try statically guessing what you'll get.
17:30:31 <mniip> err
17:30:36 <tdevries9> Is there anyway to have deterministic explicit multithreading
17:30:42 <mniip> did I mix up preemptive and cooperative again
17:30:45 <geekosaur> mniip, I would not call that preemption. I'd call it green threads
17:31:09 <mniip> "oops"
17:31:14 <geekosaur> (in fact the freebsd KSE thread model is explicitly delimited continuations)
17:31:29 <tabemann> you don't need IO for cooperative threading aka "fibers"
17:31:34 <monochrom> Windows 3 is cooperative, Windows NT is preemptive.
17:32:12 <tabemann> and note that green threads and preemption are two separate concepts
17:32:23 <tabemann> e.g. Haskell has green threads, but its green threads are preemptive
17:32:39 <mniip> which threads are green
17:32:48 <monochrom> Oh wow they dedicate a name "fibre" for that.
17:32:55 <tabemann> forkIO theads are green
17:33:03 <tabemann> forkOS threads are kernel threads
17:33:12 <davean> uh, so, Haskell's threads are sorta cooperative
17:33:14 <Cale> no
17:33:18 <tabemann> no
17:33:22 <monochrom> What do you get when you use lens and ContT together? Answer: fibre optics.
17:33:42 <mniip> monochrom, hahaha *cries in 14.4kbps*
17:33:52 <tabemann> Haskell's threads are fully preemptive - they just are implemented as part of an N:M green threads on kernel threads scheme
17:33:58 <davean> Haskell threads have pre-emption pointed based on memory allocation
17:34:04 <davean> tight loops fail to yield
17:34:20 <davean> so, you can design your threads to not be cooperative, and they fail to preempt
17:34:43 <monochrom> forkIO threads are green or system depending on whether you have -threaded and your -N setting.
17:34:55 <davean> so extra preemption points have to be added ...
17:34:57 <monochrom> forkOS is simply illegal if you don't have -threaded
17:35:11 <tabemann> they're N:1 with -threaded and N:M with +RTS -N
17:35:18 <tabemann> whoops
17:35:19 <Cale> forkOS creates a Haskell thread which is guaranteed to only run on a given OS thread, but the thread you get does not correspond directly to an OS thread.
17:35:25 <tabemann> they're N:1 without -threaded and N:M with +RTS -N
17:36:14 <monochrom> You should read my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml for what forkIO and forkOS mean.
17:36:24 <monochrom> Or the sources I cite there.
17:36:28 <Cale> https://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Concurrent.html#g:8
17:36:38 <monochrom> Or https://github.com/takenobu-hs/haskell-ghc-illustrated
17:37:19 <monochrom> It is actually unsummarizable by 3-word sentences like "forkIO is green"
17:37:30 <monochrom> or "plain English".
17:39:25 <tabemann> "green" by itself implies N:1
17:39:38 <jcarpenter2> switching from IO (Either Error ()) to ExceptT Error IO () everywhere isn't quite as helpful as i expected :/
17:39:47 <davean> tabemann: Not to me - it implies N:M where M is some number greater then or equal to 1
17:39:49 <jcarpenter2> it IS helpful, definitely
17:39:59 <davean> tabemann: Most green thread models I know are M > 1
17:40:25 <davean> actually, the only N:1 I can think of off the top of my head is python?
17:40:47 <monochrom> What do you call it when it's 50:17 not 50:1? Navy blue?
17:40:51 <Cale> It's more of a turquoise.
17:42:51 <monochrom> Gotta love false dichotomies when Java taught us that the world was so simple and your only two choices were N green threads : 1 system thread and N green threads : N system threads.
17:43:10 <monochrom> And like I said these old habits take 40 years to die.
17:43:31 <monochrom> So expect 30 more years of people coming here with this false dichotomy.
17:43:55 <monochrom> Oh yes that means after you retire.
17:44:11 <monochrom> I guess s/after/until/
17:44:34 <davean> It didn't imply it before Java, and I didn't even come across it in Java - what era was this?
17:45:07 <monochrom> Pretty sure the Java people coined the "green" name.
17:45:09 <davean> Hell, the OS the JVM ran on could run an N:M mmodel
17:45:11 <davean> monochrom: they did
17:46:36 <erisco> is there any intuitive reason to think of that dichotomy? I don't know much about threads, but such a dichotomy is not intuitive to me
17:46:44 <tabemann> the wiki seems to imply that the normal pattern is either N:1 or N:N, and that it is unusual to have N:M due to it requiring more complexity to implement
17:47:01 <tabemann> which seems wrong to me
17:47:03 <inkbottle> geekosaur: can I do sth like that in stack.yaml: extra-deps: - acme-missiles  >=0.2 < 0.4? (instead of specifying a exact version number)
17:47:16 <monochrom> Complexity eh? That sounds right up the alley of GHC RTS.
17:47:53 <davean> monochrom: when java says N:N though that doesn't imply you get N:N though - the OS threading library could be N:M
17:47:59 <davean> monochrom: for example, libthr
17:48:06 <geekosaur> tabemann, that is true for C/C++
17:48:08 <monochrom> Oh, "more complexity" is technical right, in the sense that "4.5 is greater than 4" is right.
17:48:28 <MarcelineVQ> inkbottle: I don't think so, it would go against the design goal of stack which is to create reproducable builds. to that end it wants you to pin down version numbers, via choosing one specific pacakge version and/or resolver
17:48:35 <geekosaur> or languages without built0in thread support like perl (<6) or python
17:49:03 <monochrom> Oh I guess the "unusual" part is questionable.
17:49:12 <mniip> and so we're back to square one
17:49:21 <mniip> constructing a profunctor out of a quantified type
17:49:23 <geekosaur> for languages with built-in thread support, n:m is more common because (a) the complexity needs to be implemented only once, in the runtime (b) n:m is much more resource friendly for both the hardware and the runtime, for all that it requires more work to implement
17:49:28 <inkbottle> geekosaur: MarcelineVQ: [OK then] because there is some inconsistencies in the dependencies and I'm trying to fix it
17:49:28 <MarcelineVQ> if you have a version range, then somewhere down the road when johhnny futureman builds your pacakge that ambiguous hacakge version might cause his build to fail because people can't predice the future
17:51:04 <monochrom> But do feel free to edit Wikipedia and correct it.
17:51:36 <geekosaur> inkbottle, basically what MarcelineVQ said. stack's trying to keep ghc from doing strange things, the only way to do so is to be explicit. cabal files let you do it but stack "intercepts" that and figures out fixed versioning compatible with your resolver and extra-deps. (sometimes with a little help needed, which is where "stack solver" comes in; it's a more constrained version of cabal-install's sol
17:51:41 <monochrom> Instead of donating money, your response to its fundraising could be "FIFY" instead. :)
17:51:41 <geekosaur> ver)
17:51:59 <geekosaur> (and cabal-install, pre 'new-build', isn't constrained enough and can cause problems, which is why stack was developed in the first place)
17:52:53 <geekosaur> especially since thereve been a few instances of 'getting my deps right gets in my way, *you* do it' among haskell devs which have caused rather widespread breakage in the past
17:53:04 <monochrom> "If everyone donated 5 minutes to correct something on Wikipedia, this fundraising would be doomed^H^H^H^H^H^Hdone in an hour" :)
17:53:51 <geekosaur> and resolvers are kinda a direct answer to that, they constitute extra versioning to work around the developer not versioning stuff
17:55:06 <Gurkenglas> Should I factor a "Applicative f => Inline -> Maybe ([Inline] -> f [Inline]) -> f Inline" out of segment in https://codereview.stackexchange.com/a/181760/84131 so segment does not contain any lens jargon?
17:55:26 <Gurkenglas> "Applicative f => Inline -> Maybe (([Inline] -> f [Inline]) -> f Inline)" ._.
17:55:43 <inkbottle> MarcelineVQ: geekosaur: [OK, understood] I understand... This package https://github.com/jwiegley/pipes-files/blob/master/pipes-files.cabal doesn't build because of "pipes >=4.1  && <4.4" which contradict the same line here https://github.com/jwiegley/hierarchy/blob/master/hierarchy.cabal, so I have to choose myself a pipes-4.xxx myself; the one installed from constraints is pipes-4.3.6, which violate the 
17:55:44 <inkbottle> constraints in "hierarchy" (I will see the end of it)
17:56:00 <inkbottle> I might choose one randomly
17:57:44 <Gurkenglas> I suppose it's wise anyway in order to capture the assumption that children is affine
17:57:51 <MarcelineVQ> inkbottle: what did  stack solver  reccomend?
17:58:18 <inkbottle> MarcelineVQ: it is currently computing
17:58:40 <Gurkenglas> But how should it be called?
17:58:44 <inkbottle> MarcelineVQ: It failed
18:01:14 <nshepperd> data Proyoneda p a b = forall s t. Proyoneda (a -> s) (p s t) (t -> b)
18:02:02 <inkbottle> MarcelineVQ: rejecting: pipes-4.3.5, pipes-4.3.4, pipes-4.3.3, ..., pipes-1.0; 
18:02:04 <inkbottle> but just after it adds: constraint from main config /tmp/cabal-solver7583/cabal.config requires ==4.3.6)
18:02:40 <inkbottle> MarcelineVQ: I'm wondering what is that extra constraint in /tmp/cabal-solver7583/cabal.config requires ==4.3.6
18:02:53 <Cale> wtb optics pst
18:03:51 <inkbottle> MarcelineVQ: it was a temporary file deleted after the end of the solver process
18:04:30 <nshepperd> I suppose that one is actually the co- version. data Proyoneda p a b = Proyoneda (forall s t. (s -> a) -> (b -> t) -> p s t)
18:07:42 <geekosaur> inkbottle, you might eb able to use --allow-newer=pipes to get things to move on, but it might also fail to build as a result
18:08:01 <inkbottle> OK
18:08:05 <Gurkenglas> Why don't we have explicitly affine Traversals?
18:08:44 <mniip> nshepperd, why not rather define Yoneda in an arbitrary C
18:08:58 <mniip> then profunctor yoneda comes up as a special case where C=D^op x D
18:09:14 <Gurkenglas> Is there no class for LensLike's first argument that would exactly capture an affine Traversal's power?
18:10:20 <koz_> For the second answer (the one using mtl-style capability typeclasses), I'm a bit confused about the 'generalized 'run' class method' it claims doesn't exist for the intersection of ST and mtl. COuld someone please explain what exactly this means?
18:10:58 <geekosaur> Gurkenglas, you might see https://artyom.me/lens-over-tea-5 and look for "affine traversals"
18:11:30 <geekosaur> but the impression I;m getting from a general search is that lens is built on top of existing Haskell abstractions, and there's a few key ones missing
18:11:32 <mniip> nshepperd, type Yoneda c f a = NT c (->) (c a) f
18:11:50 <MarcelineVQ> inkbottle: just part of the solving process I suppose. if the solver failed you'll either need to try a different resolver, or you may have to unpack one of the packages having the issue and edit the dependency requirements yourself.  it looks to me like lts-7.24 might have an appropriate pipes version so I'd try that first.   stack solver --resolver=lts-7.24   and if that works you'd set your project's stack.yaml to that resolver.
18:12:04 <nshepperd> so... data Yoneda c f a = Yoneda (forall b. c a b -> f b)
18:12:10 <mniip> or I guess you could say
18:12:25 <mniip> type Yoneda f a = NT (Cod f) (->) (Cod f a) f
18:12:31 <inkbottle> MarcelineVQ: good idea
18:12:33 <geekosaur> and can't be retrofitted for the same reason that AMP required a flag day
18:12:44 <MarcelineVQ> inkbottle: the downside to that is that you'd have to use ghc 8.0.1 on that resolver, if it matters
18:12:58 <mniip> nshepperd, well technically you need Functor c (->) f
18:14:08 <mniip> in my Hask,
18:14:12 <mniip> data NT (k :: kk -> kk -> *) (l :: ll -> ll -> *) (f :: kk -> ll) (g :: kk -> ll) where
18:14:12 <mniip> 	NT :: (Functor k l f, Functor k l g) => { runNT :: forall a. Ob k a => l (f a) (g a) } -> NT k l f g
18:14:39 <nshepperd> right, liftYoneda :: Functor c (->) f => f a -> Yoneda c f a
18:14:51 <mniip> in edward's
18:14:52 <geekosaur> koz_, is there context for that question that I'm missing?
18:15:05 <mniip> data Nat (p :: i -> i -> *) (q :: j -> j -> *) (f :: i -> j) (g :: i -> j) where
18:15:05 <mniip>   Nat :: ( FunctorOf p q f , FunctorOf p q g ) => { runNat :: forall a. Ob p a => q (f a) (g a) } -> Nat p q f g
18:15:19 <mniip> oh well that's just alpha renaming
18:16:04 <mniip> nshepperd, yeah pretty much
18:16:46 <koz_> geekosaur: Oh, sorry, forgot to link: https://stackoverflow.com/questions/47481797/combining-monadrandom-with-st-computations-in-a-stack
18:16:52 <geekosaur> Gurkenglas, ... and that post I pointed to is in fact making the same point I was seeing
18:17:21 <Gurkenglas> Looks from that post like there'd be no problem implementing affine traversals using Pointed?
18:17:46 <geekosaur> correct. the problem is retrofitting Pointed into the class hierarchy will break the world
18:18:08 <geekosaur> and it's not clear that you gain enough from doing so. AMP at least had a fair amount of justification
18:18:25 <geekosaur> the Typeclassopedia also goes intot his to some extent
18:19:01 <Gurkenglas> You could have a version of holesOf that returns Maybe (Pretext p a a t) rather than [Pretext p a a t], when the affine traversal gurantees 0-or-1 :c
18:19:08 <geekosaur> (nd if you don;t retrofgit it into the class hierarchy, you can;t use it from the higher levels anyway so it won;t help you build affine traversal lenses)
18:19:13 <inkbottle> MarcelineVQ: actually it's mostly an exercise in using stack, plus the library itself was of interest; nothing critical anyway. I have to give up for today ;)
18:20:00 <Gurkenglas> Actually, shouldn't there already be a Maybe-version of holesOf for prisms?
18:20:43 <geekosaur> Gurkenglas, I think that gets back to the start of that section where artyom mentioned having initially described prisms in terms of affine traversals and then realized it wouldn't work
18:21:22 <Gurkenglas> Can that mindset improve on https://codereview.stackexchange.com/questions/181567/segementing-a-recursive-tree-in-haskell ?
18:21:25 <geekosaur> I think the plumbing is there but requires a twist in 4D to connect or something
18:22:50 <geekosaur> or invocation of the Old Ones (ob i m a s t a b u)
18:24:13 <koz_> geekosaur: What is that Lovecraftian type?
18:25:54 <geekosaur> Mar 22 17:03:50 <edwardk>	tgeeky: you get 'stab' 'pabst' and all sorts of fun combinations out of lens. i'm pretty sure i had it all but say 'i m a s t a b u'  and i walked away
18:26:27 <koz_> geekosaur: My favourite is one from Iso, which goes 's t a b -> b a t s'.
18:26:38 <geekosaur> (s, t, a, b are generic types referring to van Laarhoven lenses, p is usually a profunctor, etc.)
18:29:04 <Gurkenglas> What do you call something that might give you a hole full of children-in-line?
18:29:24 <koz_> Gurkenglas: What are 'children-in-line'?
18:29:44 <Gurkenglas> A list of Inline values within our Inline value
18:30:32 <geekosaur> koz_, re your question, basically there is no abstraction in mtl that generalizes runST, runState, runReader, runWriter (and the _T versions of those), etc.
18:30:50 <geekosaur> there are monad libraries that do abstract it to some extent, but it comes at a price
18:31:10 <koz_> geekosaur: Could you elaborate on what you mean by 'comes at a price' here?
18:32:27 <geekosaur> to the extent that you are abstracting over something, you can't access details of it without complicating the interface (replacing mtl with something that has more general 'handles' but will be slower especially for typechecking and sometimes for generated code)
18:32:36 <koz_> Ah, I see.
18:32:57 <koz_> Well, that makes sense.
18:33:06 <geekosaur> this is also we've had a generalized container 'edison' for a couple decades but nobody uses it; it's much more general, but *much* slower
18:33:13 <geekosaur> *ccontainer package
18:33:56 <koz_> Alrighty, thanks - I'll just follow the answer's advice then.
18:34:06 <koz_> But thanks to that, I actually get how to use stacks involving ST.
18:34:10 <koz_> (or at least I think I do)
18:34:13 <mniip> geekosaur, Coercible :D
18:35:24 <geekosaur> Coercible and a metric crapton of fragile RULES pragmas
18:35:55 <mniip> I mean re run.*T abstraction
18:36:02 <geekosaur> you're doing more metaprogramming than programming at that point >.>
18:36:24 <mniip> then what are we doing at this point
18:36:28 <mniip> metametaprogramming?
18:37:15 <geekosaur> well. I was still talking about edison and friends. Coercible doesn;t really answer the run* question because if you have things that general, uyou've stripped off the parts Coercible needs to work
18:37:16 <mniip> lest I ask whether it's meta all the way down, then it might become a limit cardinal
18:37:31 <Gurkenglas> Can I get children into queen's local scope while keeping the number of levels of indentation small? https://codereview.stackexchange.com/a/181760/84131
18:37:58 <geekosaur> or hidden them behind an existential, and at some point you have only the existential and no way to get at what's inside it other than the generalized run function itself
18:38:30 <mniip> there's something disturbing about holesOf children
18:38:38 <koz_> mniip: Yes.
18:38:56 <geekosaur> show us on the doll where the lens touched you
18:39:45 * mniip s t a b s the doll
18:40:40 <geekosaur> Gurkenglas, isn't that just a where clause? frankly the only indentation pain I see there is children itself, and I'd be considering an abstraction there
18:41:04 <geekosaur> (not enough information to see what kind of abstraction though. worst case its own binding for that addition...)
18:42:04 <Gurkenglas> How come you'd be considering an abstraction? Intuition? What do you mean by that addition's own binding?
18:44:23 <Gurkenglas> Usually I put the where clause on the one-liner at the top level, but in this case the top level has a case switch :/
18:44:45 <Gurkenglas> the where keyword, that is - the where'd definitions go in the indentation
18:45:15 <geekosaur> I mean that long chain of what looks to me like conceptually similar (flags?) ought to be collapsible somehow to something shorter
18:45:41 <geekosaur> unfortunately, if it's C-style flags, Enum+Bounded is enticing but a dead end, because they're consecutive *bits* not *values*
18:45:52 <Gurkenglas> It's the list of constructors that contains an [Inline] the way we want
18:46:30 <Gurkenglas> (Constructors of Inline.) Plated also targets those same constructors, but gives us Inline, not [Inline].
18:46:51 <Gurkenglas> template would target additional [Inline]s that have other meaning :/
18:47:16 <Gurkenglas> Can we restrict template to the paths the given Plated instance takes?
18:49:33 <Gurkenglas> Are the pandoc authors in here? They ought to provide this stuff.
18:51:42 <Gurkenglas> Is traversing _A `failing` _B `failing` _C slower than a case switch?
18:52:52 <Gurkenglas> What's the proper name for the affine Traversal' Inline [Inline] that ought to be provided by pandoc-lens (and could be used in the Plated instance)?
18:53:31 <Gurkenglas> (Because children's too name-clashing, right?)
18:56:19 <Gurkenglas> inlinePrePlate, perhaps?
19:03:12 <Gurkenglas> `` in commit messages shows the contained characters as Haskell code on github, right?
19:03:48 <mniip> how come
19:03:55 <mniip> ContT can lift StateT but not WriterT
19:08:46 <geekosaur> Gurkenglas, well, as a fixed width font
19:09:04 <mniip> is it because of  listen?
19:09:06 <geekosaur> it doesn't do code formatting or colorizing
19:09:36 <mniip> still doesn't quite make sense to me
19:14:28 <Gurkenglas> geekosaur, doesn't seem like it :/ https://gyazo.com/881b3e7aa4753228046e025586fc96e2
19:15:45 <geekosaur> oh, the one-line summaries, no, it's not that smart
19:15:55 <geekosaur> the full commit message should be
19:20:25 <mniip> ok that sounds possible...
19:23:47 <daey> how can i pass a part of the regex mask to this function? http://lpaste.net/360460
19:26:28 <mniip> hmm
19:26:32 <mniip> check this out
19:26:41 <mniip> :t execWriter . (`runContT` return) . traverse (\x -> callCC (\k -> lift (tell [fst . runWriter . (`runContT` return) . k]) >> return x))
19:26:43 <lambdabot> Traversable t => t b -> [b -> t b]
19:27:16 <mniip> now, I'm wondering if it's possible to inject the continuation back into t rather than writing it into a writer...
20:01:17 <koz_> TFW Haskell makes you realize you're dumb.
20:02:22 <mniip> ok this is where I'm stuck
20:04:18 <mniip> exists r z. (t (a, r) -> t (a, a -> t a), a -> ((a, r) -> Cont (t (a, a -> t a)) z) -> r)
20:04:37 <mniip> while z is the current-continuation return type and isn't interesting,
20:04:41 <mniip> I can't pick a good r
20:21:37 <koz_> Is it possible to rewrite this as a fold? http://lpaste.net/360461 If so, how would I do that?
20:22:07 <jared-w> It's always possible to rewrite recursion as a fold
20:22:25 <koz_> jared-w: I'm aware of the formal equivalence, but I'm not sure how I would go about doing it in this specific case.
20:22:38 <koz_> I guess I should have asked a different question.
20:22:53 <koz_> (although the link does ask correctly: 'How do I rewrite this as a fold?')
20:22:58 <jared-w> True, I was being a bit tongue in cheek there :p
20:23:24 <mniip> koz_, ah this looks like a left fold
20:23:43 <koz_> mniip: Specifically a lazy left fold, I guess?
20:23:46 <jared-w> Specifically, one with a tuple I think?
20:23:47 <mniip> you can't really then
20:24:05 <jared-w> koz_: all left folds must be finite, regardless of whether or not they are lazy or strict
20:24:13 <mniip> well ok
20:24:14 <koz_> Ah.
20:24:18 <mniip> lemme take a closer look
20:24:35 <koz_> It's been bugging me a while, because this kind of explicit recursion is inelegant.
20:24:48 <jared-w> right folds may be infinite and it works fine; it's the requirement of a left fold to traverse the entire list first that makes it have length requirements :p
20:25:02 <jared-w> That being said, all folds can be written as either a left fold or a right fold...
20:25:25 <mniip> aha
20:25:39 <jared-w> This is essentially the nub function as a fold 
20:25:45 <koz_> jared-w: Correct.
20:25:48 <koz_> (but more efficient)
20:26:53 <mniip> :t foldr (\f x h -> if ?hsmember x h then f h else x : f (?hsinsert x h)) (const []) (?hsempty)
20:26:54 <lambdabot> error:
20:26:54 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ b -> [a]
20:26:54 <lambdabot>       Expected type: b -> [a]
20:27:39 <mniip> :t ($ ?hsempty) . foldr (\f x h -> if ?hsmember x h then f h else x : f (?hsinsert x h)) (const [])
20:27:40 <lambdabot> error:
20:27:40 <lambdabot>     • Occurs check: cannot construct the infinite type: a1 ~ a -> [a1]
20:27:40 <lambdabot>       Expected type: a -> [a1]
20:27:49 <mniip> one moment then
20:28:07 <jared-w> :t ?hmm
20:28:08 <lambdabot> (?hmm::t) => t
20:28:19 <jared-w> oh nice, is this just a lambdabot thing?
20:28:20 <koz_> :t ?meaningOfLife
20:28:21 <lambdabot> (?meaningOfLife::t) => t
20:28:29 * koz_ is disappointed that it isn't an Int.
20:28:52 <mniip> oh
20:28:53 <mniip> mixed up
20:29:00 <mniip> :t ($ ?hsempty) . foldr (\x f h -> if ?hsmember x h then f h else x : f (?hsinsert x h)) (const [])
20:29:01 <lambdabot> (?hsmember::t2 -> a -> Bool, ?hsinsert::t2 -> a -> a, ?hsempty::a, Foldable t1) => t1 t2 -> [t2]
20:29:21 <mniip> in particular,
20:29:37 <mniip> :t ($ []) . foldr (\x f h -> if elem x h then f h else x : f ((:) x h)) (const [])
20:29:39 <lambdabot> (Eq a, Foldable t) => t a -> [a]
20:29:55 <jared-w> nice
20:29:58 <koz_> mniip: OK, I gotta read that carefully.
20:30:25 <mniip> I heard you like parametricity so I made your parametric function parameterized
20:30:38 <koz_> mniip: Are you generic Xzibit?
20:30:48 <koz_> If so, do you use Typeable or GHC generics?
20:30:51 <jared-w> :t take 5 . foldr (\x f h -> if HS.member x h then f h else x : f (x:h)) []
20:30:52 <lambdabot> error:
20:30:52 <lambdabot>     Not in scope: ‘HS.member’
20:30:52 <lambdabot>     Perhaps you meant one of these:
20:31:12 <jared-w> oh whoops. Anyway, that should be mostly unfancified, I think :p
20:31:17 <mniip> jared-w, you still need to ($ []) to complete the higher order fold
20:31:35 <koz_> mniip: I'm still trying to understand what this is doing.
20:31:41 <jared-w> oh right, silly me
20:31:43 <koz_> The 'const []' is especially throwing me.
20:31:49 <mniip> hmm, I haven't checked though
20:31:49 <jared-w> > const []
20:31:51 <lambdabot>  error:
20:31:51 <lambdabot>      • No instance for (Typeable b0)
20:31:51 <lambdabot>          arising from a use of ‘show_M29401203671371570854990’
20:31:56 <mniip> @let nub' =  ($ []) . foldr (\x f h -> if elem x h then f h else x : f ((:) x h)) (const [])
20:31:57 <lambdabot>  Defined.
20:32:00 <mniip> > nub' [1..]
20:32:02 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:32:06 <mniip> great
20:32:09 <mniip> it is lazy
20:32:21 <jared-w> oh const has two arguments, dur; I'm tired apparently
20:32:39 <koz_> So wait, IIRC, const x y just ignores y and always gives x?
20:32:49 <jared-w> > const 1 undefined -- yup
20:32:51 <lambdabot>  1
20:33:10 <koz_> So you're folding .. a function? Wat?
20:33:15 <mniip> yes
20:33:18 <mniip> you have to
20:33:24 <koz_> I don't understand, sorry.
20:33:33 <mniip> uhhuh
20:34:07 <jared-w> lol I barely follow it. I mean, I can see the types fine and follow it, I just cant' imagine what the hell broke your brain to make you come up with that, mniip; what did poor math ever do to you? :p
20:34:18 <mniip> I can explain
20:34:29 <koz_> I don't follow it. mniip: An explanation would be wonderful.
20:34:42 <mniip> in a generic fold, you have: foldr f z (x:xs) = f x (foldr d z xs)
20:35:03 <mniip> the "data" from the xs "case" is passed to f which "builds" the x:xs "case"
20:35:12 <koz_> Yeah, I get that part.
20:35:25 <mniip> the data flows in direction from end to beginning
20:35:36 <mniip> but in your case you have this hashmap which needs to flow in the other direction
20:36:16 <mniip> naturally, your "data" needs to be "contravariant" in this hashmap
20:36:26 <mniip> not sure if it's a valid use of the word "contravariant"
20:36:38 <mniip> but it needs to consume the hashmap,
20:37:48 <mniip> and in the x:xs "case" it can consume the hashmap, produce a new one, and pass to the xs "case"
20:38:38 <jared-w> I think it's a valid use of the word contravariant... ¯\_(ツ)_/¯
20:40:47 <mniip> hmm
20:41:45 <mniip> a -> Fix (Compose ((->) a) ((,) a))
20:41:50 <mniip> can that be implemented with callCC
20:42:25 <jared-w> Hmm... No idea, but for some reason it looks right to me
20:42:33 <mniip> well
20:42:42 <mniip> I'm looking at a larger idea:
20:42:55 <mniip> Traversable t => t a -> t (a, a -> t a)
20:43:34 <jared-w> That's an interesting function. What would you use that for?
20:43:36 <mniip> the idea is to traverse t with the Cont monad
20:43:51 <mniip> well I have a related function at hand:
20:44:03 <mniip> :t execWriter . (`runContT` return) . traverse (\x -> callCC (\k -> lift (tell [fst . runWriter . (`runContT` return) . k]) >> return x))
20:44:04 <lambdabot> Traversable t => t b -> [b -> t b]
20:44:05 <jared-w> ooh the Cont monad, gotcha
20:44:42 <mniip> @let holes = execWriter . (`runContT` return) . traverse (\x -> callCC (\k -> lift (tell [fst . runWriter . (`runContT` return) . k]) >> return x))
20:44:43 <lambdabot>  Defined.
20:44:58 <mniip> > map ($ 0) $ holes [1,2,3]
20:45:01 <lambdabot>  error:
20:45:01 <lambdabot>      Ambiguous occurrence ‘holes’
20:45:01 <lambdabot>      It could refer to either ‘Lens.holes’,
20:45:07 <mniip> > map ($ 0) $ L.holes [1,2,3]
20:45:08 <lambdabot>  [[0,2,3],[1,0,3],[1,2,0]]
20:45:22 <koz_> mniip: That looks like a zipper.
20:45:28 <koz_> (or rather, the states of a zipper)
20:45:29 <mniip> related
20:45:50 <jared-w> Holes should sound very related to a zipper :)
20:46:00 <koz_> jared-w: My brain.
20:46:18 <mniip> 1512268626 [05:37:06] <Gurkenglas> Can I get children into queen's local scope while keeping the number of levels of indentation small? https://codereview.stackexchange.com/a/181760/84131
20:46:19 <mniip> 1512268684 [05:38:04] <mniip> there's something disturbing about holesOf children
20:46:25 * jared-w twitches slightly at the fact that it's 'execWriter' and not 'runWriter'
20:46:50 <mniip> what would the purpose of runWriter be
20:46:59 <mniip> it returns the exact same structure on large
20:47:39 <jared-w> well, whatever execWriter is; every other monad seems to have runX as the name of their accessor function so it bugs me a bit that writer is 'execWriter' (unless I'm confusing execWriter with something else...?)
20:47:53 <mniip> :t execWriterT
20:47:54 <lambdabot> Monad m => WriterT w m a -> m w
20:47:56 <mniip> :t execStateT
20:47:57 <lambdabot> Monad m => StateT s m a -> s -> m s
20:48:29 <jared-w> oooh, I was confusing things, nvm
20:48:54 <mniip> anyway
20:48:55 <jared-w> Those are the functions, not the accessor function defined with the Writer newtype, now I gotcha :p
20:49:19 <mniip> I thought,
20:49:20 <koz_> Is there no mtl class equivalent of MaybeT?
20:49:33 <mniip> instead of zipping this list with the original traversable, why not just "return" the continuations into the traversable itself
20:49:40 <mniip> so in the end you get
20:49:46 <mniip> t a -> t (a, a -> t a)
20:49:58 <jared-w> Clever :p
20:50:00 <mniip> but there you run into a problem
20:50:13 <mniip> this is very much akin to implementing fix with callCC
20:50:51 <jared-w> right
20:51:43 <jared-w> sequences of nested continuations, but with a fix function, how do you terminate? :p
20:51:59 <jared-w> (If I'm understanding the issue right?)
20:52:11 <mniip> nah
20:52:27 <mniip> if you return the continuation from thing you callCC'd
20:52:35 <mniip> you run into recursive typing issues
20:52:55 <jared-w> oh okay, so problems on the other end of things, I gotcha
20:53:10 <mniip> which can be resolved either the dumb way (Mu) or by careful pre/postcomposition of the continuation with things
20:53:24 <mniip> I'm looking at this right now
20:53:33 <mniip> f :: Traversable t => t a -> t (a, a -> t a)
20:53:33 <mniip> f = (`runCont` _) . traverse (\x -> callCC (\k -> pure (x, _ x k)))
20:54:34 <mniip> now the two _ share an existential, which I can't seem to pick
20:55:04 <jared-w> Like, any existential you try to instantiate fails to typecheck?
20:55:41 <mniip> I don't even try
20:55:44 <mniip> I mean
20:56:02 <mniip> I can do the inference in my head but the search space is infinite
20:56:10 <mniip> that's the problem
20:56:36 <mniip> the first _ looks a *lot* like it should be just id
20:57:10 <mniip> but then the other one is: a -> ((a, a -> t a) -> Cont (t (a, a -> t a)) b) -> a -> t a
20:57:16 <mniip> and I don't think I can satisfy that
20:57:26 <jared-w> ahh, right. That sucks. Doesn't id cause problems with the second _?  Oh, I was too slow :p
20:58:48 <mniip> hmm
20:59:00 <mniip> or could I just
21:01:45 <mniip> gotcha
21:01:59 <mniip> \xs -> (`runCont` id) $ traverse (\x -> callCC (\k -> pure (x, \y -> fmap fst $ (`runCont` id) $ k (y, const xs)))) xs
21:02:03 <mniip> that xs reuse though
21:02:11 <jared-w> lol, but it compiles eh?
21:02:31 <mniip> I don't like it mathematically
21:02:48 <jared-w> yeah, I getcha
21:03:08 <jared-w> so many lambdas... 
21:03:14 <mniip> I suppose the outer runCont could pass the thing
21:05:37 <jared-w> Well if (a -> r) is the final continuation which produces the final result, is there a way to actually write out what that final continuation would be? Seems like it might help make the rest a bit simpler since you have runCont id twice and it almost looks like you've essentially written the same function twice
21:06:22 <mniip> nope
21:06:43 <mniip> well at least I don't think so
21:07:22 <mniip> fascinating
21:07:24 <mniip> (\xs -> fmap (second ($ fmap fst xs)) xs)
21:07:34 <mniip> that's like, what,
21:07:46 <mniip> fmap =<< second . flip id . fmap fst
21:08:00 <mniip> @pl (\xs -> fmap (second ($ fmap fst xs)) xs)
21:08:00 <lambdabot> fmap =<< second . flip id . fmap fst
21:08:07 <mniip> no better ideas...
21:10:04 <jared-w> hmm, fst and second almost sounds like a bifunctor
21:10:41 <mniip> unpacking t (_, _)
21:14:45 <jared-w> Well I gotta go, unfortunately; let me know if you ever find a satisfying definition :)
21:14:50 <mniip> @let puncture = (`runCont` \xs -> fmap (second ($ fmap fst xs)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs))))
21:14:51 <lambdabot>  Defined.
21:15:20 <mniip> > fmap (\(x, f) -> (x, f 0)) $ puncture [1,2,3]
21:15:22 <lambdabot>  [(1,[0,2,3]),(2,[1,0,3]),(3,[1,2,0])]
21:15:57 <koz_> mniip: Ah, so you basically 'pull out' the element of interest?
21:16:17 <mniip> and leave a hole
21:17:09 <mniip> oh yeah!
21:17:13 <mniip> the reason why this is good
21:17:17 <mniip> this function is not partial
21:17:25 <mniip> unlike the potential StateT zip
21:17:47 <mniip> it is also well-typed in STLC
21:17:54 <mniip> meaning it doesn't accidentally invoke a fixpoint
21:18:06 <mniip> (no recursive types used either)
21:20:38 <mniip> > fmap (second ($ 0)) $ puncture $ M.fromList [('a', 1), ('b', 2)]
21:20:39 <lambdabot>  fromList [('a',(1,fromList [('a',0),('b',2)])),('b',(2,fromList [('a',1),('b...
21:22:59 <mniip> now where's edwardk
21:23:36 <koz_> mniip: So I can be even more confused? :P
21:23:46 <mniip> so I can be :p
21:23:55 <koz_> Yeah, Edward has that ability.
21:24:01 <koz_> Mass Confusion (Ex).
21:24:39 <mniip> tbh I kind of understand
21:24:48 <koz_> mniip: Is that thing you just described suitable for implementing unique as a fold?
21:24:56 <koz_> Or is it overkill?
21:25:00 <mniip> I mean I too can get carried away when discussing some interesting topic with people not necessarily as experienced as me
21:25:25 <mniip> koz_, the function-fold? It's not overkill, it's the simplest solution in fact
21:25:39 <koz_> No, not the function fold, the puncture thing you were just talking about.
21:25:49 <mniip> oh uh that's unrelated
21:25:59 <koz_> I can believe the function fold is probably the simplest solution if you insist on a fold.
21:26:06 * koz_ is curious which would be more efficient.
21:26:13 <koz_> (explicit recursion versus function fold)
21:26:38 <mniip> I think they're identical
21:27:04 <mniip> if you inline your 'go' and the 'foldr'
21:33:00 <mniip> koz_, http://lpaste.net/5263934655534465024
21:34:38 <koz_> mniip: Oh, cool.
21:35:18 <mniip> still might see a performance difference though
21:35:31 <mniip> but it's not immediately obvious to me
21:35:55 <mniip> probably explicit recurstion should be better?
21:36:23 <mniip> because otherwise go has to apply foldr with itself
21:36:36 <mniip> rather, invoke the foldr closure
21:37:01 <koz_> Additionally, I think the explicit recursive form is more readable.
21:37:06 <koz_> (but that's subjective)
21:37:23 <koz_> It's a pity I can't do that with something like a State monad.
21:37:57 <mniip> sure can
21:38:12 <koz_> Wait, what?
21:43:23 <mniip> :t (`evalState` ?hsempty) . foldr (\x f -> do h <- get; if ?hsmember x h then f else do modify (?hsinsert x); (x:) <$> f) (return [])
21:43:24 <lambdabot> (?hsmember::a -> s -> Bool, ?hsinsert::a -> s -> s, ?hsempty::s, Foldable t) => t a -> [a]
21:43:28 <glguy> Doing Advent of Code this year? Join the #haskell group: http://adventofcode.com/2017/leaderboard/private 43100-84040706
21:43:52 <mniip> koz_, ^
21:44:17 <HaskellLord69> un
21:44:20 <HaskellLord69> fun*
21:44:24 <HaskellLord69> now I can actually get points lol
21:48:44 <koz_> mniip: Ah, I see.
21:48:57 <mniip> heh
21:49:13 <mniip> I like when these AoC type tasks can actually be solved with oneliners
21:49:42 <mniip> as opposed to something of relatively the same size in an average programming language but a huge mess of indices in haskell
21:52:36 <HaskellLord69> day 2's was pretty easy but then you have to actually run it against the data provided
21:53:13 <HaskellLord69> thats holding me up more
21:55:19 <mniip> replicateM 16 getLine
21:56:33 <koz_> Why I love Haskell: mkColourTable n = (ColourTable . IM.fromAscList . take n . zip [0 ..] . map pure . unique) <$> getRandomRs (0, n - 1)
21:56:36 <HaskellLord69> dang that looks way more simple than what I was about to do lol
21:56:53 <koz_> HaskellLord69: The art of Haskell is saying in 1 line what other languages say in 10.
21:57:01 <koz_> (as opposed to the art of, say, Java, which is the reverse)
21:57:10 <HaskellLord69> I know! I've witnessed it im just working on getting to that point
21:58:21 <mniip> hmm
21:58:25 <mniip> I have a cheeky solution for day 3
21:58:38 <koz_> Is there an efficient way to implement the (partial, I know) function 'choose :: MonadRandom m => IntSet -> m Int' efficiently?
21:58:50 <mniip> hint: it begins with 'minimum'
22:00:13 <mniip> hrm
22:00:25 <mniip> and now for something completely different apparently
22:01:15 <koz_> I guess I could repeatedly splitRoot until I hit a singleton, but I dunno if that's the sensible way.
22:01:58 <koz_> ... never mind, that doesn't work either.
22:02:47 <koz_> Although I guess it would depending on when it stops splitting.
22:02:58 <koz_> I can just cash it out then and use a uniform call.
22:08:57 <mniip> dammit why are spirals so mathematically indescribable
22:09:16 <koz_> mniip: In what sense?
22:10:06 <mniip> koz_, advent of code
22:11:08 <koz_> mniip: Ah.
22:11:11 <n1> I have a nice way to generate a list of how many (filled) neighbors each new element of the spiral has but not yet a great way to tell which elements the neighbors are
22:17:10 <koz_> Is there something like '(a -> Bool) -> (a -> a) -> a -> a' which repeatedly feeds a's to the second function until the first one yields true on the result?
22:18:04 <jle`> koz_: i usually use iterate
22:18:06 <jle`> and find
22:18:23 <jle`> > find (> 100) $ iterate succ 0
22:18:26 <lambdabot>  Just 101
22:18:34 <koz_> Oh, that works? Nice.
22:18:51 <jle`> yes just be aware that iterate as it is written does leak space
22:19:01 <jle`> the same way that foldl does
22:19:05 <koz_> So basically the answer is 'roll your own'?
22:19:20 <jle`> the answer is benchmark and consider if that's actually a bottleneck
22:19:32 <jle`> but also i wish there was an iterate' in base
22:20:18 <mniip> ok this is horrifying
22:21:24 <mniip> oh god
22:21:34 <HaskellLord69> thats how i felt about my day1 part 2
22:22:01 <HaskellLord69> it took like 10 whole seconds to run
22:22:20 <koz_> HaskellLord69: Did you use lists or something?
22:22:31 <HaskellLord69> yeah
22:22:41 <HaskellLord69> I think I just appended the list to itself and iterated with recursion
22:22:44 <koz_> I was like 'huh, this needs vectors, too much effort'.
22:22:57 <HaskellLord69> it worked thats all I really cared about at 5am
22:23:07 <HaskellLord69> i put a comment in there saying how bad it was for my own self esteem
22:23:24 <HaskellLord69> I can always look and see how other people did it and learn from them
22:25:49 <n1> on day 2 I used some disgusting liftA2 to divide everything by everything else in the list
22:26:23 <jle`> day 1 part 2 i used Seq
22:26:26 <jle`> to bisect a list
22:26:34 <jle`> so it was pretty fast
22:26:42 <koz_> jle`: I guess that works too.
22:26:53 <jle`> day 2 part 2 is pretty straight forward with list monad/constraint programming stuff
22:28:13 <jle`> um maybe straightforward isn't the best way to put it, heh
22:33:20 <mniip> ugh I did it again
22:33:25 <mniip> I was solving for the wrong thing
22:37:19 <mniip> n1, I used a list comp
22:37:23 * hackage vty 5.19 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.19 (JonathanDaugherty)
22:44:14 <mniip> day 1 part 2, all I did was zip xs with drop length/2 xs + xs
22:45:03 <HaskellLord69> oh man
22:45:14 <MarcelineVQ>  ugghhhh
22:45:15 <HaskellLord69> so much easier than what I did lol
22:45:38 <MarcelineVQ> manhatten distance is not euclidian distance :<
22:46:05 <n1> correct
22:46:19 <geekosaur> contest free that reads interestingly >.>
22:46:22 <geekosaur> *context
22:49:16 <mniip> geekosaur, just regular conversation
22:50:17 <mniip> jle`, have you seen
22:50:35 <mniip> the non-partial holing function
22:53:27 <mniip> hrmph
22:54:04 <mniip> @let data T a = T a | B (T a) (T a) deriving (Show, Functor, Foldable, Traversable)
22:54:06 <lambdabot>  Defined.
22:54:48 <mniip> > fmap (second ($ 0)) $ puncture $ B (B (T 1) (T 2)) (T 3)
22:54:50 <lambdabot>  B (B (T (1,B (B (T 0) (T 2)) (T 3))) (T (2,B (B (T 1) (T 0)) (T 3)))) (T (3,...
22:54:57 <geekosaur> mniip, aside from the suggestion that Manhattan is in the near vicinity of either a black hole or Rl'yeh?
22:55:29 <geekosaur> (I did say context free)
22:55:50 <mniip> manhattan distance is part of the grammar :p
22:56:00 <MarcelineVQ> ^^;
22:56:31 <mniip> hmm no
22:57:26 <geekosaur> this is what comes of doing a quick runthrough of all my channel tabs and only having something sink in once I'm 3 channels past it
22:58:22 <mniip> here's with a more apparent show instance
22:58:25 <mniip> > B (B (T 1) (T 2)) (T 3)
22:58:27 <lambdabot>  {{[1][2]}[3]}
22:58:31 <mniip> > fmap (second ($ 0)) $ puncture $ B (B (T 1) (T 2)) (T 3)
22:58:33 <lambdabot>  {{[(1,{{[0][2]}[3]})][(2,{{[1][0]}[3]})]}[(3,{{[1][2]}[0]})]}
23:00:40 <mniip> what interesting Traversable instances are there out there
23:01:32 <mniip> basically just the exponent-free functor right?
23:05:05 <jcarpenter2> i've got a question about class constraints in type aliases
23:05:42 <jcarpenter2> basically i'd like to do something like "MonadIO m => type DBResult m a = ExceptT DBError m a"
23:06:14 <jcarpenter2> otherwise i'd have to put the "MonadIO m" constraint on all of my database functions
23:06:20 <jcarpenter2> which would be kind of a pain
23:06:34 <jcarpenter2> just wondering if it's possible (or recommended) to put class constraints into type aliases
23:06:36 <mniip> you could say 'type DBResult m a = MonadIO m => ExceptT DBError m a'
23:06:42 <mniip> and hope the context floats out
23:06:46 <mniip> but it's not recommended
23:15:22 <jcarpenter2> okay, it looks like it will float out just fine
23:15:57 <jcarpenter2> seeing as the type can (in theory) only be constructed for types with the MonadIO constraint
23:15:57 <geekosaur> I think it actually doesn't, but in most cases it will behave as if it did
23:17:45 <geekosaur> since it can unify them and the individual types have it, the only lose case I can think of offhand is using them in a result monad that isn't a use of DBContext and expecting to have it in intermediates, but figuring out a way to make that happen such that it would typecheck at all is tricky at best
23:22:27 <jle`> mniip: yes drop length/2 would have been easier to write but i did not like traversing the list twice
23:22:36 <jle`> heh 
23:24:41 <jle`> i wonder if there's any way to avoid building the grid for day 3 pt 2
23:24:55 <mniip> I wish
23:24:59 <mniip> I had to do it
23:25:21 <mniip> you could probably figure out a cell's neighbors explicitly from its index
23:25:45 <jle`> and then do some dynamic programming maybe
23:25:59 <mniip> but that sounds like 16 cases
23:26:34 <jle`> the cell's contents can only depend on the three cells in the direction to the center
23:26:57 <jle`> maybe i can just do something with memocombinators
23:27:47 <jle`> oh wait nvm the cell's contents can depend on up to five other cells
23:27:59 <mniip> 3 actually
23:28:08 <mniip> or 4
23:28:15 <jle`> yeah, 4 heh
23:29:07 <mniip> you'd need to check what side of the square you're on, or whether you're on a corner,
23:29:25 <mniip> and if you're at a side you'd need to check if you're at the last or the first cell of the dege
23:29:35 <jle`> oh, but the problem isn't asking for the contents at a specific point, but rather the first in the spiral that matches some predicate
23:29:37 <Gratin[m]> can anyone help me with this error i've been wrestling with for a few hours? i'm on arch linux https://gist.github.com/abueide/e2cdd8fea9625a281bf5200f8d70258a
23:29:37 <mniip> in total 16 cases,
23:29:44 <jle`> yeah i guess finding the cells that matter is harder than i thought
23:30:33 <mniip> but if you analyze those 16 cases you can calculate indices of th target cells
23:30:35 <mniip> not coordinates
