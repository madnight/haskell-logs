00:36:21 <EvanR> cool... i am in transformer hell
00:36:27 <EvanR> 50% of the words on the screen are "lift"
00:37:30 <capisce> hoist = lift
00:37:35 <capisce> add some variety to spruce things up a bit
00:37:53 <EvanR> add some levity
00:37:57 <EvanR> polymorphism
00:38:28 <capisce> lift your spirits
01:09:53 <tsahyt> I'm trying to use stack with the latest nightly snapshot, but it throws an error: AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
01:10:11 <tsahyt> has anyone encountered this? and if yes, is it fixable?
01:10:43 <tsahyt> really any snapshot with containers >= 5.8 would do for my purposes
01:12:24 <tsahyt> hmm it seems that nightly-2017-07-31 could work. downloading GHC now, which is more than I managed to do on the most recent one.
01:19:20 * hackage telegram-api 0.7.1.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.7.1.0 (klappvisor)
01:23:22 <metaden> Haskell newbie here, excited to be here!
01:25:25 <Axman6> welcome!
01:25:34 <metaden> Thanks
01:25:48 <metaden> What do you use haskell for?
01:25:57 <Axman6> work
01:26:05 <metaden> that's awesome
01:26:14 <mniip> I use haskell for entertainment
01:26:22 <metaden> Network apps, software or data science?
01:26:40 <Axman6> web services
01:26:42 <Axman6> mainly
01:26:49 <Axman6> data munging too
01:26:53 <Athas> Work/research here.
01:26:55 <metaden> oh.. great
01:26:57 <Athas> And hobby coding.
01:27:17 <metaden> I work with Scala mainly for working in Spark.
01:27:29 <metaden> But I like Haskell > Python
01:27:50 <metaden> All pythonistas around me
01:28:21 <mniip> all around me are familiar faces
01:28:38 <Axman6> you might want to have a look at sparkle
01:28:43 <Athas> I work with a bunch of people who really like Standard ML.
01:28:47 <Axman6> worn our braces
01:28:50 <Athas> Fortunately, they are not grumpy about Haskell.
01:29:56 <s4ke> thank god i wrote a consolidating script for my benchmarks
01:30:07 <s4ke> rerunning them for the 20th time or so...
01:32:17 <metaden> I started with C, Python, R, Scala, Some python, Rust starting to show up.
01:33:05 <metaden> @axman6
01:33:05 <lambdabot> Unknown command, try @list
01:33:11 <metaden> @list
01:33:11 <lambdabot> What module?  Try @listmodules for some ideas.
01:33:16 <metaden> @listmodules
01:33:16 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
01:33:16 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
01:33:30 <metaden> @activity
01:33:30 <lambdabot> 4*total 4*#haskell
01:33:57 <Axman6> you can play with lambdabot in private chat too
01:34:06 <metaden> Just figured that out
01:34:08 <metaden> THanks
01:35:34 <metaden> Are there any cool haskell projects in data science side?
01:35:49 <metaden> Or blockchain?
01:35:52 <Athas> metaden: there is http://www.datahaskell.org/ as an umbrella project.
01:36:08 <Athas> But I don't think many people are doing applied data science with Haskell yet.
01:36:23 <metaden> Why not?
01:36:55 <Athas> It's very hard to compete with the library ecosystem of languages like Python (and Haskell's performance probably isn't good enough to implement the algorithms directly).
01:38:29 <Axman6> there's plenty of companies building blockchain based systems in Haskell though (Including mine, but I'm not working on it)
01:38:50 <metaden> I love functional programming. I mostly used R in my 4 years of data science career
01:38:58 <metaden> I want to use Haskell more than Python
01:39:06 <metaden> Python is very pervasive
01:39:59 <metaden> Athas, are you saying I'm better off learning a low level language like Rust etc. for performance boost.
01:40:16 <Athas> I think if you are working in a domain where there is no advantage to leveraging existing libraries, then Haskell may have an advantage, because of its greater power.
01:40:20 <Axman6> Haskell isn't slow
01:40:30 <Athas> metaden: depends on your algorithms.
01:40:59 <Athas> Haskell is pretty fast for things that "cannot be fast" anyway - things that involve pointer chasing, IO, etc, because Haskell will help you make improvements at a higher level of abstraction.
01:41:12 <metaden> Athas: Can I prototype? Matrix operations on GPU and optimization algorithsm
01:41:26 <Athas> But Haskell is reasonably slow for the kind of stuff that can potentially be *really* fast, like dense computation.
01:42:08 <Athas> Prototype what?  Matrix operations?  Sure.  You can prototype in any language.  Haskell is a great language for prototyping, due to its expressivity.
01:42:22 <metaden> Athas: Yes, indeed. 
01:42:25 <dmj`> Athas: you can ffi into c as well
01:42:29 <Athas> (But you may suffer from the absence of libraries, depending on your domain.)
01:42:31 <metaden> Yes.
01:42:33 <metaden> Or rust
01:43:14 <metaden> This project is exciting
01:43:15 <metaden> http://neanderthal.uncomplicate.org/
01:43:34 <metaden> But written entirely in Clojure
01:43:43 <Axman6> you might like to look at the Accelerate library for GPU computatons in Haskell
01:43:48 <Athas> dmj`: you can do that for most languages, but it's not always the fastest way of doing things.
01:44:12 <Athas> With the right libraries, C++ can be faster than C when writing modular code.
01:44:39 <Axman6> metaden: that's just a wrapper on top of linear algebra C libraries right? We have that too, in HMatrix
01:45:30 <Athas> Does hmatrix support MKL?
01:45:39 <metaden> Speed comparison HMatrix and Numpy
01:45:49 <Axman6> possibly the BLAS/LAPACK bits? I can't remember
01:46:07 <metaden> MKL support would be really nice
01:46:39 <metaden> I could achieve good speed with MKL + Clojure with neandrethal
01:47:00 <Athas> I don't know about Neanderthal specifically, but MKL is good.
01:47:05 <metaden> Yes.
01:47:21 <Athas> It is very hard to compete with primitives hand-written by experts.
01:47:33 <Athas> You can only do that by optimising the composition (e.g. fusion).
01:50:35 <theduke> hey, I'm using DuplicateRecordFields and have run into a problem: https://codepaste.net/7094ox
01:50:37 <Axman6> which is the sort of thing Accelerate gives you
01:51:03 <theduke> how can I disambiguate name in the combine function?
01:51:11 <metaden> Haskell + Numpy's C API
01:51:24 <metaden> or Haskell + Tensorflow's C API
01:51:36 <metaden> using ffi
01:52:12 <Athas> Axman6: yes, but it's not enough.  You need both good constant factors *and* fusion (and other things) to beat something like MKL.
01:52:26 <Athas> Accelerate does do e.g. block tiling, which is a critical optimisation.
02:01:24 <s4ke> Athas: you have experience with Accelerate?
02:01:40 <s4ke> i have been looking into it and am quite intrigued
02:02:39 <Athas> s4ke: some, yes.
02:02:43 <Athas> It is good.  Very convenient.
02:03:20 <Athas> You will not beat well-written GPU code, but it's quite easy to get a nontrivial speedup for some things.
02:03:50 <s4ke> Athas: yeah. i will want to take a look into instrumenting stuff like Accelerate over MPI
02:03:56 <s4ke> looks very very promising
02:03:59 <Athas> The Accelerate type system is a little baroque, due to the distinction between Haskell and Accelerate terms.  But a Haskell programmer has probably seen worse.
02:04:27 <s4ke> Athas: looking at their examples, i find it quite powerful and okay to read
02:04:34 <fakenullie> There was Haskell do
02:04:40 <fakenullie> DSL for gpus
02:04:42 <Athas> I have also tried their new-ish multicore CPU backend, which also performs well.
02:05:11 <Athas> s4ke: well, Accelerate is much easier to read than write.  I often find it a little difficult to figure out which small glue function to insert to get the types to work out.
02:05:22 <s4ke> okay, hmm
02:05:29 <Athas> But once you grok it, it's not too bad.
02:05:42 <Athas> And I guess easy-to-read is more important than easy-to-write.
02:06:05 <Athas> I think I would describe Accelerate as having a cost you don't want to pay unless you really need the performance, but if you *do* have that need, the cost is not all that great.
02:06:08 <s4ke> Athas: i guess the abstraction of the types was necessary
02:06:19 <Athas> Yes.  And it could be worse - Repa has more complicated types, IIRC.
02:06:57 <s4ke> For more trivial parallelization tasks (ones where you dont want to optimize for GPU), things like the Par Monad LVish or stuff like that are probably better
02:07:00 <s4ke> "trivial"
02:07:07 <s4ke> s/trivial/cpu optimized
02:07:15 <Athas> Here is an example of what I mean: https://github.com/AccelerateHS/accelerate-examples/blob/master/examples/mandelbrot/MandelLoop.hs#L59
02:07:15 <Athas> You need both the 'the' and the 'unlift' stuff to unpack what is semantically just a four-tuple.
02:07:42 <Athas> And if you miss them, the type error is not always helpful.
02:07:53 <s4ke> their examples are quite nice though?
02:08:04 <cocreature> I should learn accelerate one of these days â€¦
02:08:07 <Athas> Yes!  They have excellent taste and write really pretty code.
02:08:23 <Athas> For my own functional GPU stuff, I always try to steal the Accelerate examples.  They have nice visualisations and are well-written.
02:08:30 <s4ke> heh
02:08:43 <s4ke> i am looking forward to working with accelerate :)
02:08:58 <s4ke> are AMD gpus supported?
02:09:20 <s4ke> from the README i gues no?
02:09:26 <Athas> They are not.
02:09:51 <s4ke> huh. that's too bad. well good thing my old AMD gpu died on me
02:10:02 <s4ke> so i have a cheap GTX 660 which works with these things
02:13:53 * hackage haskell-gi-base 0.20.8 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.20.8 (inaki)
02:14:45 <nf7> Can anyone here vouch for the quality of Haskell book (http://haskellbook.com/)? I'm interested in buying it but it says that it's currently unfinished, and the sample provided doesn't give me any insight into the language that I wasn't familiar with already, and it's a bit steep of a price for me to buy on a whim.
02:21:12 <matsurago> nf7: I'd buy that instead: https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229/
02:23:29 <s4ke> nf7: i dont know about the book, but where are you in terms of experience?
02:24:40 <s4ke> i guess the sample is quite basic and talking mostly about the language itself?
02:24:54 <nf7> s4ke: I've made it through about half of Learn You a Haskell and am completely lost. Actual Haskell experience is extremely minimal. As far as other software development, I've worked professionally in full stack web dev before so I am not a beginner.
02:25:11 <nf7> matsurago: Thanks for the recommendation. This does look very good.
02:25:12 <s4ke> s4ke where are you lost with Learn you a Haskell?
02:25:30 <s4ke> i was going to link you to it, so i am interested
02:25:41 <solidus-river> has anyone started work on vulkan bindings for haskell?
02:26:14 <solidus-river> nvm, hackage saysss yes!
02:26:15 <s4ke> -.-
02:26:21 <s4ke> nf7: ^
02:26:24 <s4ke> i linked myself in the chat
02:30:33 <nf7> s4ke: I've gotten around chapter 7 over a couple weeks and I am still unable to write even the most basic complete program. I can't really keep shoving all the information in my head without something concrete to practice with the new knowledge on (that isn't just messing around in the REPL). I realize that IO is different in Haskell but I don't really get how I can learn something without applying in 
02:30:39 <nf7> practically, when IO is 9 chapters in.
02:31:45 <s4ke> nf7: then why don't you skip to the IO chapter?
02:32:10 <Lowl3v3l> nf7: to learn solving problems, IO is unnecessary and might be overrated^^
02:33:29 <s4ke> there are not many idioms you need to know in order to write some IO programs
02:34:08 <Lowl3v3l> nf7: in fact, one thing i like about LYAH is that it doesn't start with "io" and "hello world", but builds the whole haskell stuff from the ground up
02:34:48 <[Leary]> You don't need IO beyond `print` to do exercises, which is what LYAH lacks. Go through a freely available Haskell course like CIS194 '13 and do the assignments, nf7.
02:35:14 <Lowl3v3l> anothere great thing is projecteuler, if you look for assignments^^
02:35:21 <s4ke> +1
02:35:32 <s4ke> or steal stuff from existing repos
02:35:51 <Lowl3v3l> or codeingame ( which is nice too if you want to see stuff while doing assingments)
02:35:57 <nf7> Yes excersizes would be nice. I'll check out that free course.
02:36:05 <s4ke> i guess real world haskell is good as well
02:36:23 <s4ke> http://book.realworldhaskell.org/read/
02:36:58 <s4ke> it is focused on more "realworld" applications and you learn to write some neat stuff
02:37:06 <s4ke> for example a RPN calculator
02:37:23 <s4ke> or was that from lyah?
02:37:27 <s4ke> hmm
02:40:41 <matsurago> nf7: this free online course is very good, too: https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0
02:59:13 <solidus-river> nf7, its a lot to swallow early on, i wrote some derpy sample programs to see if it was practical that might help, tried to very verbose with documentation
03:00:53 <solidus-river> nf7, https://github.com/fuag15/yaskl , https://github.com/fuag15/functioninvaders
03:01:19 <solidus-river> nf7, those things are pretty old at this point though, stack has made setting up a reproducable dev env much easier
03:02:40 <solidus-river> nf7, both of them have the main bit of documentation in the top most .hs file where main is
03:20:47 <nf7> Thanks for the recommendations!
03:25:54 <yellowj> anyone here uses liquid haskell regularly?
03:26:23 <yellowj> i was just wondering how practical is it
03:26:36 <yellowj> and how it is different from dependent types
03:27:14 <yellowj> i'm a bit ignorant about this topic, so sorry if the question is dumb
03:32:35 <nf7> Is there a way to have two commands execute one after another on the same command-line in GHCI? I'd like to reload my source file and run the main function. Something like `:load "main.hs" && main`.
03:35:35 <lseactuary> anyone here good at first order logic? i am stuck with this: https://math.stackexchange.com/questions/2560154/first-order-logic-real-world-model
03:35:44 <lseactuary> just need some pointers please i feel like im almost there
03:40:22 <mniip> what
03:41:10 <mniip> of all things why do you typeset \in as \epsilon...
03:42:07 <lseactuary> oh because i was trying to get the formatting in math notation
03:42:15 <lseactuary> but you can ignore the formatting i can do this nicely in latex
03:42:22 <lseactuary> but i am not understanding if what i am typing is even correct
03:42:27 <lseactuary> or am i over complicating
03:48:07 <mniip> I'm not understanding what you typed there either
03:49:07 <lseactuary> from the beginning?
03:53:25 <^khelbe152> 06,05â–„11,06â–„08,09â–„06,04â–„12,08â–„05,02â–„11,13â–„04,09â–„04,07â–„04,05â–„09,02â–„09,07â–„07,13â–„13,05â–„03,13â–„02,09â–„12,13â–„05,13â–„09 HAPPY NIGGER DAY!! PLEASE SAY HI TO ALL THE DUMB NIGGERS IN #FREENODE...quicktalkeh676te.onion/6697fswoswewxm: chowie tim___ ziocroc2 johnw Jaxan PCChris1 banc nf7 yellowj Mst4m ashirase dezren39[m] renais zaquest thc202 metaden wonko7 sbjo
03:53:25 <^khelbe152> 06,12â–„10,12â–„02,08â–„03,09â–„08,02â–„08,02â–„12,05â–„06,09â–„09,03â–„09,12â–„05,02â–„03,10â–„10,03â–„07,13â–„05,11â–„12,11â–„08,07â–„04,02â–„13,10â–„09 HAPPY NIGGER DAY!! PLEASE SAY HI TO ALL THE DUMB NIGGERS IN #FREENODE...quicktalkeh676te.onion/6697ahxmdjm: raynold Mon_Ouie mekeor nf7 ddere heurist` beerdrop PCChris1 LiaoTao mzf t7 chaosmasttter Lowl3v3l ninedotnine daedera eli
03:53:25 <^khelbe152> 09,07â–„03,02â–„08,08â–„06,11â–„03,06â–„02,05â–„13,09â–„04,02â–„08,06â–„10,09â–„04,13â–„03,11â–„02,09â–„06,02â–„10,07â–„11,13â–„08,13â–„12,13â–„05,09â–„11,12â–„10 HAPPY NIGGER DAY!! PLEASE SAY HI TO ALL THE DUMB NIGGERS IN #FREENODE...quicktalkeh676te.onion/6697kotyjvw: Destol wonko7 rotaerk WhereIsMySpoon infinity0 hc_ chaosmasttter simukis iqubic lionaneesh admin01 peterhil meke
03:53:40 <lseactuary> happy to explain just need to know from where :)
03:54:22 <cute_hamp716> 09,02â–„08,12â–„07,03â–„02,13â–„07,06â–„10,10â–„02,09â–„02,09â–„09,11â–„11,10â–„02 HAPPY NIGGER DAY!! PLEASE SAY HI TO ALL THE DUMB NIGGERS IN #FREENODE...quicktalkeh676te.onion/6697ssvnvydm: olligobber antsanto minad LiaoTao eliaslfox jrabe glguy thc202 ninedotnine humanoyd nf7 raynold codesoup solidus-river yellowj ashirase mfrolov eliasr lseactuary flux Mst4m db8093246 dezren39[m] exferenceBot oish rotaerk kvda johnw PCChris1
03:54:22 <cute_hamp716> 12,02â–„07,11â–„13,10â–„08,04â–„04,10â–„08,08â–„11,04â–„06,10â–„08,03â–„10,08â–„06,13â–„06,10â–„05,07â–„06,09â–„11,11â–„07,13â–„03,07â–„03,13â–„11,12â–„12,10â–„10 HAPPY NIGGER DAY!! PLEASE SAY HI TO ALL THE DUMB NIGGERS IN #FREENODE...quicktalkeh676te.onion/6697qadxz: oish pacak1 thc202 XorSwap Mst4m WhereIsMySpoon chowie kvda lseactuary jchia_ Mon_Ouie takuan renais mfrolov hucksy johnw jedws simendsjo ashir
03:54:23 <cute_hamp716> 12,07â–„05,05â–„07,02â–„05,08â–„07,06â–„09,02â–„04,07â–„02,07â–„09,11â–„05,11â–„13 HAPPY NIGGER DAY!! PLEASE SAY HI TO ALL THE DUMB NIGGERS IN #FREENODE...quicktalkeh676te.onion/6697boaxmonpsr: matsurago cow-orker byorgey ziyourenxiang Igloo pavonia XorSwap foo123[m] ma27 cpape a_t T0pH4t sdothum albel727 Unhammer rossberg megaTherion minad ghostyy descender TipsyMe dibblego omilu AndreasK nakal_ FreeBirdLjj ertes M2tias steshaw
03:55:00 <AndreasK> lseactuary: If you fix the rendering of the formulas it makes it more likely for people to look at it in detail
03:55:32 <lseactuary> ok let me do this now
03:55:48 --- mode: ChanServ set +o dibblego
03:55:52 --- mode: dibblego set +r
03:56:50 --- mode: dibblego set -o dibblego
03:56:53 * hackage smallcheck 1.1.3 - A property-based testing library  https://hackage.haskell.org/package/smallcheck-1.1.3 (RomanCheplyaka)
03:58:57 <lseactuary> AndreasK in the docs it says to use one of two $ which I did but it still doesn't show in math :(
03:59:24 <AndreasK> Are you using the $$ within a code block?
04:00:09 <lseactuary> oh
04:00:11 <lseactuary> my mistake 
04:00:15 <lseactuary> now its working 2 mins please
04:06:15 <lseactuary> i made it nice now :)
04:07:53 <cocreature> next step: replace \epsilon by \in 
04:11:00 <lseactuary> epsilon is for set comprension only?
04:11:37 <AndreasK> lseactuary: Predicates are usually assumed to be boolean valued. So instead of defining a Function Vacant which returns yes or no you could just use a Predicate IsVacant
04:11:42 <cocreature> no epsilon is just a greek letter and is never used for set membership
04:11:51 <lseactuary> ok
04:12:02 <WinterFox[m]> Could someone help me understand what this error from Yesod.Test means? https://bpaste.net/show/d57e9ff8f0c7
04:12:41 <lseactuary> weird i have $\in$ and it still shows the epsilon symbol
04:12:58 <[Leary]> \epsilon is not used for set membership, but a specially rendered epsilon is, and \in is how you produce it.
04:13:07 <cocreature> they look somewhat similar but they are different
04:14:18 <lseactuary> ah
04:15:09 <AndreasK> lseactuary: Also "c : range(tours)" to me reads as programming code. While I think i know what you mean I don't think thats common notation in first order logic
04:17:01 <lseactuary> when i have seen axiomatic definitons, this is how they seem to write it e.g \forall y : dom recrods \bulllet #(records y) < 50. where records: Year -> Table
04:17:41 <lseactuary> could be wrong though
04:18:06 <lseactuary> as i guess i only need axiomatic at the last question here
04:18:56 <AndreasK> Notations vary (sadly) wildely. If you use range you should define it though
04:19:24 <dminuoso> Do you folks use explicit forall everywhere?
04:19:41 <dminuoso> Right now Im wondering whether I should start with that practice for making universal quantification explicit.
04:19:52 <cocreature> I donâ€™t
04:20:12 <AndreasK> I use it only when i need to for scoped type variables
04:20:24 <lseactuary> range may not even be needed here now that i think about it actually
04:20:28 <lseactuary> as there is no 'mapping'
04:20:31 <lseactuary> until the 3rd question
04:20:37 <lseactuary> that is what was throwing me off
04:21:24 <AndreasK> lseactuary: Yes you could just use (c \in tours) for example. While some profs might complain that \in is not strictly part of first order logic it's clear what it stands for
04:21:36 <dminuoso> AndreasK: Ah I see. 
04:22:04 <lseactuary> you are right
04:22:06 <lseactuary> lemme change
04:22:51 <lseactuary> btw this isnt for school
04:23:04 <lseactuary> i am self teaching some stuff for a project i am working on
04:25:29 <AndreasK> lseactuary: You could use c \in (tours\a) to make it even more distinct. A c which is an element of (tours without a)
04:25:52 <lseactuary> is my notation for removing a correct?
04:25:57 <lseactuary> or it is \{a}
04:26:45 <lseactuary> i had \{a} originally but got an error Extra close brace or missing open brace so then changed it
04:27:14 <lseactuary> or i can just wrote tours\a i guess
04:27:34 <AndreasK> lseactuary: If going with not I would use \forall c (c \in tours \and c \notequal a)
04:28:05 <lseactuary> interesting
04:29:03 <AndreasK> If you use a single \ it is treated as a escape sequence for the following character
04:29:20 * hackage tasty-golden 2.3.1.2 - Golden tests support for tasty  https://hackage.haskell.org/package/tasty-golden-2.3.1.2 (RomanCheplyaka)
04:29:58 <lseactuary> oki
04:31:39 <lseactuary> is the logic correct for the problem though i.e the way i am modelling it?
04:33:09 <lseactuary> i think i need such that not bullet, right?
04:36:11 <lseactuary> that is the main stuff i am stuck on
04:38:43 <lseactuary> problem with the current logic is it is saying there is one activity after c, but there could be 2 directly after..
04:43:25 <AndreasK> lseactuary: If you combine two quantors usually you don't seperate them by ",". It's just (all x (some y( ... ) )
04:43:45 <lseactuary> ah
04:45:14 <olligobber> ugh, I have to catch an exception :(
04:49:55 <metaden> https://medium.com/@jwvictor/why-data-scientists-might-want-to-get-some-rusty-skills-298664dfbc35
04:50:00 <metaden> What do you think about this?
04:58:11 <Ulrar> So how would I get the x and y from a Linear.V2 ?
04:58:23 <Ulrar> Looks like there are lenses for that, but is there another way ?
04:58:33 <Taneb> Ulrar, you can pattern match on it
04:58:48 <Taneb> > let V2 x y = V2 3 6 in (x, y)
04:58:50 <lambdabot>  error:
04:58:51 <lambdabot>      Not in scope: data constructor â€˜V2â€™
04:58:51 <lambdabot>      Perhaps you meant variable â€˜_2â€™ (imported from Control.Lens)
04:59:16 <Taneb> (pretend that that worked)
05:00:51 <Ulrar> Oh, of course
05:01:00 <Ulrar> How did I know think of that
05:01:03 <Ulrar> thanks
05:11:31 <Taneb> Ulrar, :)
05:26:12 <Gurkenglas> git clone haskell-ide-engine into open src/Haskell/Ide/Engine/Transport/LspStdio.hs with intero into http://lpaste.net/1426250994236260352 . Should I ask the stack folks or the intero folks or the haskell-ide-engine folks or the aeson folks or the bytestring folks?
05:26:36 <Gurkenglas> Oh, or the cassava folks
05:37:17 <Tuplanolla> I wonder what's the nicest way to convert `i < 3 && j < 4` into `_ (<) (i, j) (3, 4)`.
05:39:44 <olligobber> :exf (a -> a -> Bool) -> (a,a) -> (a,a) -> Bool
05:39:45 <exferenceBot> \ f1 b c ->
05:39:45 <exferenceBot>   let ((,) e f) = b
05:39:45 <exferenceBot>       ((,) g h) = c
05:39:45 <exferenceBot>     in f1 f e Data.Eq./= f1 h g
05:39:45 <exferenceBot> \ f1 b c ->
05:39:47 <exferenceBot>   let ((,) e f) = b
05:39:49 <exferenceBot>       ((,) g h) = c
05:39:51 <exferenceBot>     in f1 f e Data.Eq./= f1 g h
05:39:53 <exferenceBot> \ f1 b c ->
05:39:55 <exferenceBot>   let ((,) e f) = b
05:39:57 <exferenceBot>       ((,) g h) = c
05:39:59 <exferenceBot>     in f1 f h Data.Eq./= f1 e g
05:40:01 <exferenceBot> \ f1 b c ->
05:40:02 <Tuplanolla> It keeps happening.
05:40:03 <exferenceBot>   let ((,) e f) = b
05:40:05 <exferenceBot>       ((,) g h) = c
05:40:07 <exferenceBot>     in f1 f h Data.Eq./= f1 g e
05:40:09 <exferenceBot> \ f1 b c ->
05:40:11 <exferenceBot>   let ((,) e f) = b
05:40:13 <exferenceBot>       ((,) g h) = c
05:40:15 <exferenceBot>     in f1 f g Data.Eq./= f1 e h
05:40:17 <exferenceBot> \ f1 b c ->
05:40:19 <exferenceBot>   let ((,) e f) = b
05:40:21 <exferenceBot>       ((,) g h) = c
05:40:23 <exferenceBot>     in f1 f g Data.Eq./= f1 h e
05:40:25 <exferenceBot> \ f1 b c ->
05:40:27 <exferenceBot>   let ((,) e f) = b
05:40:28 <olligobber> oops
05:40:29 <exferenceBot>       ((,) g h) = c
05:40:31 <exferenceBot>     in f1 e f Data.Eq./= f1 h g
05:40:33 <exferenceBot> \ f1 b c ->
05:40:35 <exferenceBot>   let ((,) e f) = b
05:40:37 <exferenceBot>       ((,) g h) = c
05:40:39 <exferenceBot>     in f1 e f Data.Eq./= f1 g h
05:40:41 <exferenceBot> \ f1 b c ->
05:40:43 <exferenceBot>   let ((,) e f) = b
05:40:47 <exferenceBot> replying took too much time (60sec), aborting.
05:41:35 <olligobber> none of those were particularly nice...
05:42:31 <olligobber> > let andPair f (a,b) (c,d) = f a c && f b d
05:42:34 <lambdabot>  <no location info>: error:
05:42:34 <lambdabot>      not an expression: â€˜let andPair f (a,b) (c,d) = f a c && f b dâ€™
05:42:36 <cocreature> someone needs sto fix that bot
05:44:07 <Gurkenglas> http://www.cs.ox.ac.uk/jeremy.gibbons/publications/uitbaf.pdf -> "The second consequence settles an open question as to whether all possible lawful definitions of traverse for the same datatype coincide up to the order of effects: they do. In particular, computing the contents of an object using different lawful traverse functions will always result in a permutation of one and the same list." <- I got linked this 
05:44:07 <Gurkenglas> to prove that traversals must not visit an entry more than once. Doesn't it also prove that they must not visit an entry less than once?
05:49:13 <geekosaur> @tell hexagoxel exferenceBot needs an output throttle: http://tunes.org/~nef/logs/haskell/17.12.17 at 05:39:44
05:49:13 <lambdabot> Consider it noted.
05:50:27 <geekosaur> (channel logging in US PST? bleh.)
05:55:06 <angerman> what't he go-to sqlite library these days?
05:55:33 <cocreature> sqlite-simple is fairly popular
06:01:09 <angerman> cocreature: yea, seems to still be the most popular. 
06:01:11 <angerman> alright.
06:01:38 <asoltysik> Hi, is there a way to start benchmarking a function in Criterion only after the arguments have been evaluated?
06:03:16 <geekosaur> aside from evaluating them first? not sure how you think evaluation works that random stuff can hook into the middle of an evaluation
06:26:18 * hackage potoki 0.6.3 - Simple streaming in IO  https://hackage.haskell.org/package/potoki-0.6.3 (NikitaVolkov)
06:31:50 <hexagoxel> indeed, sorry about that.
06:49:05 <hexagoxel> olligobber: not your fault :)
06:57:12 <earendel> what do you think is faster? (and why?) .. A) array.map(f).map(g)  or B) array.map(compose(f,g)) ?
06:57:52 <cocreature> neither of those looks like haskell
06:58:21 <earendel> its pseudocode ..you get the idea?
06:58:57 <cocreature> reasoning about performance in terms of pseudocode doesnâ€™t really work. the language and the exact implementation matter
07:03:07 <wdanilo> Hi guys! I'm trying to setup a ghcjs side-project and after configuring stack and installing ghcjs I'm able to compile hello world (it produces the js code successfully). However when I add some dependency I get error 
07:03:12 <wdanilo> "In the dependencies for ghcjs-dom-jsffi-0.9.2.0: ghcjs-base must match >=0.2.0.0 && <0.3, but the stack configuration has no specified versio"
07:03:20 <earendel> i didn't expect a  general answer .. but i also don't think there is no way to reason upon it to make deductive assumptions maybe.. you can perfectly describe sort-algorithms in pseudo code and make conclusions about their efficiency ..
07:03:29 <wdanilo> does anyone know how to solve it? it seems that ghcjs-base is somewhat special, isnt it ?
07:04:56 <cocreature> earendel: you can make some statements about their efficiency, mostly in terms of asympotics but the two statements youâ€™ve given have the same asympotics (constant factors donâ€™t matter there).
07:05:13 <Gurkenglas> earendel, if the compiler is smart it knows those two do the same and translates the slower version into the faster
07:05:28 <cocreature> earendel: and when youâ€™re talking about the actual performance than the language really matters. e.g. ghc will turn the first into the second so there is no difference
07:05:34 <earendel> Gurkenglas: good answer :)
07:05:39 <cocreature> I think C compilers also do loop fusion
07:05:45 <cocreature> in some limited cases
07:05:52 <geekosaur> wdanilo, nothing to do with ghcjs-base. if it's not in stack's selected resolver then you need to add it to extra-deps in stack.yaml
07:06:10 <geekosaur> oh wait, missed the dep versioning
07:06:53 <wdanilo> geekosaur: err, I think ghcjs-base is nota available in hackage and it sohuld be "included" in ghcjs right? 
07:06:59 <geekosaur> base is *always* tied to the ghc version. you need to use a ghcjs-dom-jsffi compatible with your ghcjs-base; the only way tochange the ghcjs-base version is to use a different version of ghcjs
07:09:15 <earendel> Gurkenglas: i have indeed tried it with g being the reverse function of f.. but i wouldn't expect usual compilers to be that smart.. would you be interested in the results i got for f(x)=x^2 and g(x)=x^(0.5)?
07:09:48 <wdanilo> geekosaur: I still dont think its the problem. But I might be wrong. How can I know what is the right ghcjs-dom-jsffi for my resolver? the resolver is lts-8.11 and comppiler ghcjs-0.2.1.9008011_ghc-8.0.2
07:10:31 <wdanilo> geekosaur: There is even more interesting problem, when I try to include jsaddle instead of ghcjs-dom:
07:10:53 <earendel> Gurkenglas: well in js for a million elements the composed way was ~15-20% slower
07:11:23 <earendel> Gurkenglas: which seemed quite a lot.
07:11:39 <wdanilo> geekosaur:  ghcjs-base must match -any, but the stack configuration has no specified version
07:11:40 <MarcelineVQ> Gurkenglas: since you missed it "<earendel> Gurkenglas: well in js for a million elements the composed way was ~15-20% slower"
07:11:48 <wdanilo> geekosaur: so its seems that it doesnt provide ANY ghcjs-base
07:12:18 <geekosaur> wdanilo, that sounds like stack is somehow not configured properly for ghcjs
07:12:41 <wdanilo> geekosaur: it seems odd, but I just pasted the config and run stack setup for an hour 
07:12:47 <geekosaur> or you are trying to use a ghc resolver with ghcjs, or something
07:13:03 <wdanilo> whats more interesting, exaclty the same config works in another project (on another mahcine)
07:13:09 <MarcelineVQ> I'm surprised you got that far, my own forays into stack + ghcjs have been bad times
07:13:41 <wdanilo> MarcelineVQ: GHCJS is working, we've done big things in it
07:23:17 * exferenceBot was updated and should not spam again, unless in /query
07:23:27 <wdanilo> geekosaur: I got it!
07:23:31 <wdanilo> geekosaur: its pure magic
07:23:51 <wdanilo> geekosaur: namely, ghcjs uses a very special aeson with some hardcoded configs and patches
07:24:25 <wdanilo> geekosaur: so if you tell you want never aesomn version, like "aeson-1.2.3.0" stack doesnt know whats happening and reports problems on other packages (it does NOT report problems on aeson)
07:24:39 <wdanilo> geekosaur: so after removing the aeson dependency, ghcjs-dom started to compile
07:24:42 <wdanilo> geekosaur: -.-
07:25:05 <wdanilo> geekosaur: And i discovered it by calling a friend who is working with ghcjs day-to-day
07:25:27 <wdanilo> geekosaur: he told me that it is described somewhere in the docs, but still, ugh
07:27:39 <Tuplanolla> How could I define a function `maxSize :: c a -> Int`, where `c` can be either `Vector` or `Matrix`? There's this type family: https://hackage.haskell.org/package/hmatrix-0.18.1.0/docs/src/Internal-Numeric.html#IndexOf
07:37:46 <asheshambasta> earendel: imo, Haskell being lazy will only apply the function to each element in the list when the value is required 
07:48:04 <Tuplanolla> I guess I'll have to make a new type class for it.
07:51:40 <earendel> lets try it then.. how could i measure time? adhoc
07:52:22 <Tuplanolla> @hackage criterion
07:52:22 <lambdabot> http://hackage.haskell.org/package/criterion
07:52:34 <Tuplanolla> Use that, earendel.
08:21:40 <weel> hello
08:24:41 <iqubic> Are there any libraries that provide list zippers?
08:26:54 <earendel> > zip [1..3] [1..3]
08:26:56 <lambdabot>  [(1,1),(2,2),(3,3)]
08:27:16 <cocreature> thatâ€™s not what zippers are :)
08:27:18 <Tuplanolla> Not that kind of zippers, earendel.
08:27:55 <weel> Does anybody here have any experience with OpenAL and Haskell?
08:30:06 <earendel> great. my first steps in haskell. im not really out to learn it now, could you add some code to measure the time needed for testfg(1..e6) and testz(1..e6) ? ..  g x = x**0.5; f x = x**2;z x = g(f(x)); testfg n = map g(map f [1..n]); testz n = map z [1..n];
08:31:21 <earendel> pardon testfg(1e6) vs testz(1e6)
08:32:57 <earendel> would be amazing if lambdabot wouldn't provide any helper to measure elapsed time ..
08:34:00 <Tuplanolla> You could compile an executable and use `time` on it.
08:36:23 <earendel> can i make some function call to get a timestamp?
08:39:44 <barrucadu> earendel: See getCurrentTime
08:40:11 <barrucadu> But be careful, because of laziness it's easy to accidentally time the wrong thing
08:41:18 <earendel> wow.. i have expected u to show me 3 sophisticated ways to measure time with some fancy 1 liner
08:42:04 <dsal> criterion is useful if you use it correctly
08:44:09 <Tuplanolla> Measuring physical things is one of those things that seems easy, but there's a million ways to screw it up.
08:49:19 <earendel> do you understand what i'm trying to find out? i was suprised testfg(1e6) was 15% to 20% faster than testz(1e6) .. would have been nice to see if its similar with haskell. if sombody else would like to know and can test, please ping me. thank.
08:49:35 <mstruebing> When I try to compile a program via stack build I get this error: `configure: error: cannot run C compiled programs.` I just did `stack new <name>` and addede scotty to the build-depends, whats wrong?  
08:49:48 <mstruebing> Without scotty I didn't get this error
09:13:23 * hackage discrete-intervals 0.0.3 - Discrete Intervals  https://hackage.haskell.org/package/discrete-intervals-0.0.3 (chessai)
09:37:23 <geekosaur> mstruebing, are you on arch by any chance?
09:37:40 <mstruebing> yep
09:37:48 <mstruebing> I'm trying stack docker now
09:38:01 <geekosaur> try removing ~/.stack-work and then having stack upgrade itself
09:38:37 <geekosaur> (basically, stack prefers to install its own tooling, but the tooling it installs was intended for Debian and it installs the wrong one for Arch by default)
09:39:59 <geekosaur> ...so either it tries to link in the wrong terminfo lib (even when testing the C compiler, from what I've seen) or it tries to generate position-independent executables that Arch doesn't support, depending on which way it gets things wrong. most recent stack, released a few days ago, recognizes Arch and does the right thing
09:40:41 <cocreature> the new stack release has made things worse in some cases on archlinux
09:40:58 <glguy> ArchLinux makes things worse on ArchLinux
09:41:02 <geekosaur> ...actually the PIE bit also affects the C compiler because it passes gcc options that produce objects the linker can't process
09:41:09 <cocreature> Iâ€™ve had success with installing ncurses5-compat-libs and setting ghc-build: nopie in ~/.stack/config.yaml
09:41:21 <cocreature> glguy: in this case itâ€™s not really archlinuxâ€™s fault :)
09:48:29 <bblum> hello, i'm having trouble convincing ghc to do a tail call optimization on the following function (even with -O): https://pastebin.com/Vw1PvHkt i've tried writing it as a fold as well with no luck; can someone help me understand the.. optimization criteria, i guess?
09:48:42 <bblum> (spoilers for today's advent of code problem ;) )
09:49:38 <glguy> bblum: try prefixing the second clause with:   n `seq`
09:49:48 <glguy> foo i n val = n `seq` foo...
09:50:59 <bblum> aha, that worked, ty
09:51:46 <bblum> could you explain why? (i know what seq does at least)
09:51:57 <glguy> What does seq do?
09:53:38 <bblum> forces full evaluation of the first argument before the second
09:54:20 <glguy> It doesn't actually promise that order
09:54:38 <dsal> What is "full evaluation"?  Is it normal form?
09:55:08 <cocreature> no, weak head normal form
09:55:10 <glguy> seq a b  doesn't promise to evaluate a before b, but it does promise to evaluate a if b is evaluated.
09:55:31 <bblum> ok sure, under the assuming you'll need b
09:55:47 <glguy> the compiler knows that the result of this particular seq use is going to be used, and it knows that using the result means that n will be used
09:56:10 <glguy> so strictness analysis learns that the whole thing is strict in n (where it wasn't before)
09:56:44 <cocreature> Iâ€™m kind of surprised strictness analysis doesnâ€™t optimize this even without the seq
09:56:47 <glguy> where before you were building up a large thunk in that 'n' parameter only to be returned from foo at the end where it would have to be evaluated all at once, and having wasted lots of ram in the process
09:57:04 <glguy> cocreature: it's not strict in all the ns
09:57:07 <glguy> just the last one
09:57:17 <cocreature> oh good point, thx!
09:57:39 <bblum> i see, and when computing n lazily, the components for that thunk were stored in the stack frames?
09:57:48 <glguy> once GHC knows that this function is strict in this parameter it can then even optimize the way it passes it around to pass the unboxed int, too
09:58:24 <glguy> a cleaner way to express this is probably with a bang pattern using the BangPatterns extension
10:04:04 <bblum> i'm confused why it's actually resulting in a stack overflow rather than just allocating a bunch of heap memory for the thunk though?
10:04:17 <bblum> like even if i write it as a fold, with foo itself nonrecursive, it overflows
10:05:02 <glguy> The stack overflow comes from trying to evaluate the massive thunk
10:05:25 <bblum> ohh, foo itself was getting tail call optimized all along
10:05:32 <bblum> tyvm :)
10:06:04 <glguy> every outer function call in Haskell is a tail call
10:08:35 --- mode: cherryh.freenode.net set +o ChanServ
10:10:32 <glguy> bblum: Since you're working on day 17, check this out: https://github.com/glguy/advent2017/blob/master/execs/Day17.hs
10:18:59 * frerich glguy: Hm, is it really true that zero is always going to be at the start of the list? Is it never going to be the case that the next position is at the end of the sequence, so the position at which to insert is at the beginning of the list?
10:19:24 * frerich slaps himself for forgetting that Ctrl+Return in this IRC client does something else than he thinks it does...
10:19:37 <cocreature> frerich: if youâ€™re at the end of the list, you append a new item to the list
10:19:42 <glguy> frerich: Yes, it's the case that zero always leads, there's no cursor position that can insert before it
10:20:18 <bblum> it's a natural consequence of indexing the list rather than making it literally circular ;)
10:21:33 <frerich> My understanding was that the list _is_ circular, i.e. you compute the new position, then add one (and this may wrap) and then insert there. And inserting at position 0 means that it gets prepended.
10:21:41 * frerich re-reads the text...
10:21:41 <glguy> cocreature: I was pleased that thanks to list fusion this version is the same speed as the manual recursive one
10:22:56 <cocreature> glguy: yeah thatâ€™s pretty nice!
10:23:15 <cocreature> glguy: is there a reason to use scanl over scanl' here? does scanl' break list fusion for some reason?
10:23:47 <glguy> cocreature: I think it all works out the same in the end after GHC does strictness analysis
10:24:04 <glguy> and I think I had it in my head that scanl was lacking a ' version, which it's not
10:24:13 <glguy> scanl1 was the one
10:24:14 <frerich> The text mentions that the algorithm "steps forward through the circular buffer some number of steps (your puzzle input) before inserting the first new value, 1, after the value it stopped on." and my reading of 'after the value it stopped on' was that it could be at index 0, given that it's a circular buffer and it could have stopped on the last index.
10:24:28 <cocreature> glguy: sure, I just tend to opt for scanl' in most cases just like I opt for foldl' and I was wondering if there was some reason not to do this here
10:24:42 <glguy> cocreature: Oh, actually this makes it faster, I think
10:24:59 <glguy> no, tht was a mistake
10:25:00 <glguy> it's the same
10:25:38 <bblum> if i understand this right.. list fusion is an optimization where (e.g. in your implementation) scanl does not generate the full intermediate list but rather elemIndices somehow gets incorporated while producing the list?
10:26:06 <bblum> frerich: you could implement it either way but if you insert at the end, this convenient property arises
10:26:39 <glguy> bblum: Yeah, no list ever gets created here
10:28:22 <bblum> and your implementation is only lazy in like, the elements of the infinite list, which are non recursive thunks, so you don't need seq, right?
10:28:33 <bblum> you have BangPatterns turned on but you're not using em ;)
10:28:42 <glguy> I was in an old version with explicit recursion
10:30:30 <glguy> (Fixed)
10:31:48 <frerich> bblum: Indeed, I see that now! Thanks!
10:32:20 <bblum> np :)
11:33:19 <xenon-> how do I add my own local library to stackage project? I am looking at 'stack' output but I must be missing it
11:33:52 <xenon-> --extra-include-dirs did not work btw
11:33:56 <glguy> xenon-: You can add a filepath to packages:
11:34:07 <glguy> do you mean a local haskell library or local native library?
11:34:15 <xenon-> local haskell library
11:34:23 <xenon-> I just saw that --extra-include-dirs is for C
11:35:43 <xenon-> can it be done from command line, similar to cabal sandbox add-source
11:36:06 <glguy> Not that I'm aware of
11:38:20 <EvanR> i am running into an odd bit of referential opacity. if i write (lift . lift) (render x y) then it accepts. but if i put lift2 = lift . lift at the top level, then replace (lift . lift) with lift2, it fails to type check
11:39:46 <xenon-> glguy that did it thanks
11:39:51 <dmwit> :t lift
11:39:52 <glguy> monomorphism restriction, evanr?
11:39:52 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:40:01 <dmwit> EvanR: Have you given lift2 a type signature?
11:40:01 <EvanR> hmm
11:40:04 <EvanR> no
11:40:14 <glguy> paste so we can see, too :)
11:40:49 <dmwit> no fair, glguy is too fast to race against
11:40:53 <EvanR> with the type sig, it accepts
11:41:00 <dmwit> glguy++
11:41:10 <EvanR> well that explains that
11:41:28 <EvanR> i put the sig ghci says for :t lift . lift
11:42:04 <xenon-> how does it differ from ghc inferred type for lift2?
11:43:26 <glguy> It differs by being explicit
11:44:22 <dmwit> xenon-: For more details than you likely wanted, https://stackoverflow.com/q/32496864/791604
11:44:24 <xenon-> types are exactly the same, the only difference is that one is explicit and one isn't?
11:44:58 <dmwit> No. Without a type signature, GHC infers the exact same type, then goes behind your back and changes it so your code is more efficient.
11:46:17 <dmwit> I wonder if anybody has thought about "oughtta-be-palindromes" like "sheesh", where the letters aren't quite reversed but morally they are because it isn't really sensible to separate 's' and 'h'.
11:47:10 <hpc> dmwit: cut the word in half, reverse the tail, compute levenscht-however-it's-spelled distance?
11:48:10 <hpc> there's probably a branch of topology or whatever that's concerned with nearly-symmetric shapes too
11:48:27 <dmwit> hah, that sounds fun!
11:51:51 <xenon-> stack follow up: i used stack to compile my library (that has a lot of dependencies) 5 days ago. now i created another project that depends on my library, and it downloaded and recompiled almost all the libraries that it depends on.  how come?
11:52:20 <cocreature> xenon-: did you use the same resolver?
11:52:46 <xenon-> no, I did stack init. it seems unlikely, but I guess possible, that all those libraries were updated in the past 5 days
11:53:16 <xenon-> or would it download and recompile them regardless if they were updated?
11:53:28 <glguy> That you typed stack init doesn't answer the question
11:53:32 <dmwit> If you used a different resolver, it isn't really about whether they were recently updated.
11:53:47 <cocreature> just compare the resolvers in the respective stack.yaml files
11:54:39 <xenon-> yup it is different
11:54:55 <xenon-> but if library versions remained the same won't it reuse them?
11:55:47 <dmwit> The library versions didn't remained the same.
11:56:12 <glguy> But yes, stack will reuse library versions across resolvers when it makes sense
11:56:25 <cocreature> a library will also be rebuild if the version of one of its dependencies changes
11:56:29 <dmwit> Hm. Perhaps it is worth asking at this point: what makes you believe the library versions remained the same?
11:57:14 <xenon-> dmwit just a guess that 40+ libraries did not all change in the past 5 dyas
11:57:38 <glguy_> Stack init doesn't necessarily pick the most recent resolver
11:57:41 <cocreature> it really doesnâ€™t matter what happened in the past 5 days, what matters is what happened between the two versions of the resolvers
11:57:46 <dmwit> Okay. You have misunderstood the role of a resolver.
11:57:51 <glguy_> So the 5 day gap doesn't tell us anything much
11:58:14 <dmwit> A resolver is, roughly, a collection of library versions.
11:58:25 <dmwit> Using a different resolver is picking a different collection of library versions.
11:58:26 <[exa]> Is there a good short alternative of (!!) for Foldable?
11:58:27 <xenon-> so resolver could have used older library before for compatibility issues, and then user newer ones today
11:58:36 <cocreature> another possibility is that stack now picks a different GHC bindist for your system (e.g. because you upgraded stack or other parts of your system) which will cause it to rebuild everything
11:58:36 <xenon-> used*
11:58:55 <dmwit> Two different resolvers almost certainly have different versions for essentially every package they have versions for.
11:59:50 <cocreature> dmwit: thatâ€™s a bit too dramatic. if you switch to a newer lts snapshot in the same series, there are usually not that many changes
11:59:53 <xenon-> so how do you handle this in practice? should I have used the same resolver as I did 5 days ago, when compiling a library with a long list of depndencies?
12:00:24 <xenon-> when compiling a project that depends on a library with long list of dependencies, even (and that was compiled 5 days ag0
12:00:40 <dmwit> cocreature: Noted, thanks for the correction.
12:00:51 * hackage Yampa 0.10.7 - Library for programming hybrid systems.  https://hackage.haskell.org/package/Yampa-0.10.7 (IvanPerez)
12:00:55 <glguy_> In practice I don't have to worry about it because I don't use stack, but yes manually pick the same resolver to reuse compilation
12:01:33 <cocreature> I tend to pick the same resolver for all projects and bump them collectively to get the most out of caching
12:01:53 <monochrom> "Have you try plain vanilla cabal-install?" :)
12:02:01 <xenon-> how long do you tend to wait until you bump them
12:02:03 <monochrom> err, darn, s/try/tried/
12:02:41 <cocreature> until I feel like it :)
12:02:52 <xenon-> a month? 6 months? :)
12:03:18 <cocreature> I also donâ€™t follow this rigorously. itâ€™s only a vague guideline
12:04:31 <xenon-> good to know though. from what I've seen resolver changes pretty often
12:04:36 <dmwit> xenon-: when my room gets cold ;-)
12:04:44 <xenon-> I was blinding using stack init until now and  I didn't notice it
12:05:15 <cocreature> I donâ€™t create new projects all that often so usually the dependencies are already cached anyway from the last time I built the project
12:05:31 <xenon-> (perhaps there should be stack init-with-last-resolver option)
12:05:33 <monochrom> I don't use stack. But I'm an upgrade fiend. Whenever a new GHC comes out, I wait a bit until the corresponding new Haskell Platform comes out, then I'll upgrade.
12:06:11 <monochrom> So if I had an evil twin who were a stack fiend, he would upgrade to the most recent LTS resolver.
12:06:25 <xenon-> I was using ghc from 2014 until a month ago, so I'll probably keep the same resolver for half a year or longer :)
12:06:48 <glguy> what resolver are you using now?
12:07:39 --- mode: ChanServ set +o glguy
12:07:39 --- mode: glguy set -r
12:08:26 <xenon-> it used lts-9.18 for program depending on my library. and 9.12 for my library. lets see if it is smart enough to just reuse all the libraries it downloaded/compiled when I change my libraries resolver
12:08:33 <cocreature> GHC from 2014? is that 7.8?
12:09:02 <xenon-> yes
12:09:27 <cocreature> that sounds like you havenâ€™t updated your resolver in way longer than half a year :)
12:09:38 <xenon-> no, I was using that prior to switching to stack
12:10:07 <cocreature> ah ok
12:10:26 <xenon-> now I am on 8.0.2
12:12:08 <xenon-> so I updated resolver on my library, it didn't reload or redownload anything - nice
12:12:27 <xenon-> what about old versions though? do they remain forever, even if none of my projects are using them any longer?
12:12:44 <glguy> yeah, it just all ... stacks up
12:18:14 <frerich> Huh, indeed... my 'du' says: "8.2G	/Users/frerich/.stack"
12:18:33 <EvanR> 8.21 jiggabytes
12:20:11 <monochrom> bgamari: I am very disturbed by "OK, one module loaded", "OK, two modules loaded", "OK, three modules loaded"... generally "OK, <English numeral> modules loaded". I have only discovered up to "five". Where does it end?! :S
12:20:13 <xenon-> a "clean" option would be neat. . searching all the stack.yamls in directory tree, then removing anything that is no longer in use
12:21:02 <Tuplanolla> @hackage numerals
12:21:02 <lambdabot> http://hackage.haskell.org/package/numerals
12:21:05 <Tuplanolla> It never ends, monochrom.
12:21:21 <monochrom> Oh Holy God.
12:21:51 --- mode: ChanServ set +o dibblego
12:22:22 --- mode: ChanServ set -o dibblego
12:23:17 <xenon-> so what are you using if not stack? did something better come out now that I finally switched from cabal sandboxes
12:23:27 <xenon-> several people said they aren't using it
12:23:37 <liste> wow, https://hackage.haskell.org/package/numerals-0.4.1/docs/src/Text-Numeral-Language-FIN.html#cardinalRepr a thing of beauty
12:24:55 <dmwit> xenon-: I've been using cabal new-* for a while and am generally happy, though there's still a few rough edges on the UI.
12:25:50 <glguy> ^
12:33:47 <monochrom> I use all of "install globally", "install userly", sandbox, and new-build.
12:33:55 * hackage monad-finally 0.1 - Guard monadic computations with cleanup actions  https://hackage.haskell.org/package/monad-finally-0.1 (MikhailVorozhtsov)
12:34:19 <monochrom> It depends on what I judge to be persistent and what I judge to be in flux.
12:43:30 <jonreeve> I'm tearing my hair out here trying to build a project using stack. It keeps failing to build `network`. Says "cannot run C compiled programs." Any ideas? 
12:44:01 <glguy> jonreeve: on arch linux?
12:44:23 <jonreeve> glguy, Yep, how'd you guess? 
12:44:33 <glguy> Just another day of using Arch linux!
12:44:39 <cocreature> I should really get around to writing a bot that tells people how to fix their arch problems
12:44:41 <jonreeve> Haha 
12:45:06 <monochrom> I think glguy or geekosaur did. But it's a blog, not a bot.
12:45:56 <jonreeve> So far I've tried: removing all haskell packages installed through pacman, installing `stack-static` via the AUR, and trying again, but nothing seems to work yet. 
12:45:58 --- mode: glguy set -o glguy
12:48:19 <glguy> I gave us helping people limp arch along years ago
12:49:02 <glguy> so I'd guess geekosaur
12:49:59 * hackage monad-finally 0.1.0.1 - Guard monadic computations with cleanup actions  https://hackage.haskell.org/package/monad-finally-0.1.0.1 (MikhailVorozhtsov)
12:52:36 <jonreeve> Does `stack install network` work for anyone else?
12:52:46 <cocreature> jonreeve: what worked for me is: upgrade to the newest stack release, install ncurses5-compat-libs and set "ghc-build: nopie" in ~/.stack/config.yaml
12:52:56 <cocreature> and run a "stack setup --reinstall" after that to be sure
12:53:17 <yushyin> what also works ist setup stack with --ghc-build=ncurses6
12:53:26 <yushyin> is
12:53:42 <yushyin> stack setup --ghc-build=ncurses6 # for example
12:54:17 <monochrom> "Ok, 25 modules loaded."  It doesn't say "twenty five".
12:54:31 <glguy> file a bug!
12:55:54 <monochrom> OK, the line is between six and 7.
12:56:45 <jonreeve> cocreature: Awesome, trying that now
13:06:17 <jonreeve> cocreature: Awesome, it seems to be working. Thanks so much
13:11:26 * hackage hdevtools 0.1.6.1 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.6.1 (ch1bo)
13:12:59 <xenon-> "stack init or stack new will try to default to the current Haskell LTS present on  https://www.stackage.org/snapshots if no snapshot has been previously used locally, and to the latest LTS snapshot locally used for a build otherwise" <- am I reading this wrong? why did it use new resolver and not the one it used 5 days ago?
13:13:22 <xenon-> or does it mean snapshot for current project only?
13:31:54 <haskell277> any ideas on how to flatten arbitrarily nested tuples: eg ((Int,Char),(Double,Bool)) -> (Int,Char,Double,Bool) ??
13:33:01 <glguy> You'd need to use some kind of generics like GHC.Generics or the generics-sop package
13:33:43 <haskell277> i looked at generics-sop but it seems to only deal with one layer
13:34:41 <glguy> You'll have to build the function you want using the tools provided by generics-sop
13:36:18 * hackage bookkeeper 0.2.5 - Anonymous records and overloaded labels  https://hackage.haskell.org/package/bookkeeper-0.2.5 (aminb)
13:36:26 <haskell277> are you saying there is a way using generics-sop that will recursively handle nested types?
13:37:10 <glguy> This is generally not a sensible thing to want to build, but yes generics-sop will make it easier
13:40:08 <haskell277> what i really want to do is display a table of data given a list of types. if the types are nested tuples then i want to flatten them out. a little like Sql output where the columns and rows are aligned
13:40:40 <AndreasK> Sounds like something one could solve with lenses too.But I haven't used them much myself
13:41:46 <glguy> The lens package doesn't offer anything for this operation in particular
13:42:17 <okkk> Oh look! `bookkeeper-0.2.5` with support for GHC 8.2.2 is up on hackage :) 
13:45:10 <haskell277> from what i can see with generic-sop I would need a type class to handle the all the tuple instances as in http://hackage.haskell.org/package/pretty-sop-0.2.0.2/docs/Generics-SOP-PrettyVal.html
13:45:16 <haskell277> unless i am missing something
13:45:55 <haskell277> can you give me more info on how i can use bookkeeper to help
13:46:13 <glguy> haskell277: Yes, you'll need a new typeclass
13:46:28 <glguy> and then generics-sop would help you implement the instances of that typeclass generically
13:46:59 <`01010101964> 03,09â–„08,09â–„03,10â–„05,12â–„05,08â–„10,03â–„08,12â–„05,13â–„13,13â–„13,08â–„02,03â–„06,02â–„05,02â–„11,13â–„03,02â–„10,09â–„03,07â–„04,07â–„06,13â–„03,09â–„05 DID YOU GUYS KNOW TODAY WAS NIGGERS DAY?? SAY HI TO YOUR FAVORITY NIGGER IN #FREENODE!! quicktalkeh676te.onionwstszxwhrd: ben0112358 AndreasK MP2E hyp3rbor3a steshaw titikaka fr33domlover Kundry_Wag torgdor Unhammer Gurkenglas Big_G alexteves Senas
13:47:00 <`01010101964> 07,05â–„06,06â–„10,09â–„13,02â–„02,10â–„03,03â–„12,09â–„10,09â–„13,09â–„05,12â–„10,12â–„07,08â–„04,11â–„07,11â–„13 DID YOU GUYS KNOW TODAY WAS NIGGERS DAY?? SAY HI TO YOUR FAVORITY NIGGER IN #FREENODE!! quicktalkeh676te.onionajthgcsrje: ben0112358 bor0 path[l] oisdk raichoo m0rphism Jesin MP2E im0nde emilypi epsilonhalbe chaosmast Folkol cschnei__ tomphp soLucien jkup Gurkenglas Big_G haskell277 sssilver jb55 Jeanne-Kam
13:47:00 <`01010101964> 03,06â–„06,06â–„02,02â–„13,08â–„13,11â–„05,13â–„11,07â–„05,08â–„09,11â–„11,07â–„03,04â–„06,08â–„02,12â–„13,08â–„03,04â–„09,13â–„05,04â–„03,08â–„04 DID YOU GUYS KNOW TODAY WAS NIGGERS DAY?? SAY HI TO YOUR FAVORITY NIGGER IN #FREENODE!! quicktalkeh676te.oniondopphkxlkb: LiaoTao rotaerk SenasOzys_ agjacome Maqs1 torgdor frerich thc202 Mst4m mizu_no_oto Jeanne-Kamikaze descender mentos1386 emilypi tim___ Jaxan pacak
13:47:49 <rotaerk> of the 1700+ people in here, why was my name one of the ones they chose to address
13:47:57 <alexteves> ditto
13:48:10 <Gurkenglas> I am not surprised to see messages such as yours in response to that spam.
13:48:10 <Tuplanolla> It's probably random.
13:48:13 <whoman> my name  was missing in all three channels i see this in =(
13:48:16 <jb55> that was... creative
13:48:29 <rightfold> Woo Christmas colours
13:48:30 <glguy> :( I don't want to mark the channel +r
13:48:44 --- mode: ChanServ set +o glguy
13:48:44 --- mode: glguy set +c
13:48:51 <monochrom> \âˆ©/
13:49:08 <glguy> I guess I can turn off colors for the time being
13:50:38 <xenon-> stack init or stack init --resolver <someresolver> gives an error if cabal has my local haskell library in dependencies. how do I handle this? the only ways out that I see is to manually copy existing yaml, or to temporarily remove dependency to my local library. both ways seem pretty clunky
13:50:44 <haskell277> thanks for the info glguy
13:52:03 <xenon-> (I can't add my library to packages: because stack init can't even create stack.yaml file)
14:06:02 <codeshot> Does ghci have a wayt to get the type of a local function (let or where clause) - google isn't helping me but I can't believe there's no neato way after all these decades
14:07:02 <glguy> codeshot: There's :type-at, which is intended for integration with your editor as see with "dante" for Emacs
14:08:39 <codeshot> that might be good, I guess it's not practical for commandline usage, but if I can find a plugin for vim it'll do the thing
14:11:11 <[exa]> Is there some simple education-friendly applicative which is not a monad?
14:11:27 <glguy> My config-scheme package stuff showcases some of that
14:11:56 <glguy> https://glguy.net/config-demo/ and the linked repo
14:12:07 <glguy> ZipList is the simplest case that comes up off the top of my head
14:13:37 <[exa]> oh wow, cool
14:14:17 <barrucadu> The validation applicative (Either but combining Lefts in <*> with <>) isn't a monad
14:15:30 <barrucadu> Handy for representing potentially-failing complex computations where you're able to gather multiple errors before bailing out.  eg, you could have an evaluator for a little language with variables and gather all the "name not in scope" errors at once.
14:24:20 <alexteves> @[exa]:  http://blog.functorial.com/posts/2015-12-06-Counterexamples.html
14:24:20 <lambdabot> Unknown command, try @list
14:26:42 <codeshot> [exa], Identiy is quite simple and interesting, ((,) ()) is the next simplest, it adds little but extra associated values - in this case () the simplest extra associated value
14:27:10 <codeshot> ((,) []) is the next simplest, these values grow as you apply things with <*>
14:27:59 <codeshot> Maybe is the next simplest from Identity on a second dimension
14:28:39 <codeshot> > ((),id) <*> ((),1)
14:28:40 <lambdabot>  ((),1)
14:28:56 <codeshot> ([1,2],id) <*> ([3,4],1)
14:28:59 <codeshot> > ([1,2],id) <*> ([3,4],1)
14:29:01 <lambdabot>  ([1,2,3,4],1)
14:29:24 <codeshot> > Just id <*> Just 1
14:29:26 <lambdabot>  Just 1
14:29:32 <codeshot> > Nothing <*> Just 1
14:29:34 <lambdabot>  Nothing
14:30:45 <codeshot> Then "Compose Maybe ((,) [])" which combines the two behaviours in one way and "Compose ((,) []) Maybe" which combines in the other way
14:30:58 <Gurkenglas> Is there an Applicative with two possible Monad instances?
14:31:46 <codeshot> probably lots, data Faily a = FailyOneWay | FailyAnother | Pure a
14:32:36 <codeshot> I'm probably still at the edge of the understanding pool for that question though
14:37:01 <codeshot> > (Sum 1,id) <*> (Sum 1, 1) -- counting them all!
14:37:02 <lambdabot>  (Sum {getSum = 2},1)
14:44:46 <codeshot> > (Product 0.8, id) <*> (Product 0.4, 1) -- predicting them all!
14:44:48 <lambdabot>  (Product {getProduct = 0.32000000000000006},1)
14:45:56 <EvanR> interesting
14:56:06 <neekoso> Hi. Recently got a problem where I had an initial list and had to create list of lists from it, where each list corresponds to the initial list but just without one member. As example, for list [1, 2, 3] the result would be [[2, 3], [1, 3], [1, 2]]. All in all, I've produced a solution but it looks really bad to me.
14:56:20 <neekoso> So, my solution is: produceListsWithout lst = map (\y -> deleteOneElement lst y) lst
14:56:45 <neekoso> Maybe someone can give some sort of advice how to improve it?
14:56:52 <neekoso> Thanks in advance!
14:57:24 <glguy> > let f xs = [ x++y | (x,_:y) <- zip (inits xs) (tails xs) ] in f [1..3]
14:57:26 <lambdabot>  [[2,3],[1,3],[1,2]]
14:57:47 <aberrant> could someone please help me? http://lpaste.net/360868 isn't parsing.
14:57:57 <aberrant> I don't understand why.
14:58:11 <glguy> or perhaps write a dropListAt :: Int -> [a] -> [a] and then map that over [0 .. length xs - 1]
14:58:43 <neekoso> @glguy: Thanks, have to try it now!
14:58:43 <lambdabot> Unknown command, try @list
14:58:47 <Gurkenglas> aberrant, you aren't gonna be using the tab button much when doing haskell like the rest of us
14:58:51 <MarcelineVQ> aberrant: mixing tabs and spaces is going to cause you troubles most of the time, reccomend just using spaces for indentation in haskell
14:59:00 <glguy> aberrant: Looks like you got some tabs in your code, oops!
14:59:12 <aberrant> glguy: oh. Tabs are verboten?
14:59:23 <Gurkenglas> Should ghc warn people when it detects tabs?
14:59:24 <MarcelineVQ> they're just hard to use safely, as you're seeing
14:59:34 <glguy> aberrant: also what you pasted doesn't have a parse error
14:59:41 <Eduard_Munteanu> aberrant, not really but they always mean 8 space tabs
15:00:02 <aberrant> ok. I wonder if there's a haskero option.
15:00:22 <Gurkenglas> Why doesn't it try all the tab space lengths and pick one that parses x)
15:00:26 <aberrant> glguy: I'm seeing it in vscode. Let me work it out.
15:00:32 <aberrant> thank you.
15:00:50 <codeshot> neekoso, is this what you're looking for: let l = [1,2,3] in delete <$> [1..(length l)] <*> pure l
15:01:30 <codeshot> > let l = [1,2,3] in delete <$> [1..(length l)] <*> pure l
15:01:32 <lambdabot>  [[2,3],[1,3],[1,2]]
15:02:20 <neekoso> codeshot: Looks like. Now going to learn about <$> and <*>. Thanks!
15:03:13 <Gurkenglas> If you settingly reuse a holesOf hole into say, a list, many times, it traverses the part to the left of the whole each time anyway, right?
15:03:45 <aberrant>   "editor.insertSpaces": true,
15:03:47 <aberrant> damn
15:08:51 <codeshot> neekoso, probably ZipList should be used for this example:
15:08:55 <codeshot> > let l = [1,2,3] in getZipList $ delete <$> ZipList [1..(length l)] <*> pure l
15:08:57 <lambdabot>  [[2,3],[1,3],[1,2]]
15:09:21 <codeshot> just because it's applicative instance (the <*> bit) is the correct one for this job
15:09:50 <glguy> The Applicative instance isn't being used in any interesting way here
15:09:58 <glguy> It's the Functor instance that's doing all the work
15:10:06 <codeshot> true
15:10:46 <codeshot> > let l = [1,2,3] in flip delete l <$> [1..(length l)]
15:10:48 <lambdabot>  [[2,3],[1,3],[1,2]]
15:10:53 <codeshot> even better
15:11:37 <codeshot> neekoso, take note
15:11:59 <neekoso> codeshot: Yeah, I'm already taking. TIL, thank you!
15:21:35 <xenon-> does stack init always generate exactly the same stack.yaml file with the exception of resolver number?
15:25:50 * hackage log-warper 1.8.2 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.8.2 (shersh)
15:26:39 <aberrant> is there a way to read a file (I guess a do block is necessary here) outside of main?
15:27:01 <aberrant> I want a readthis :: String -> [String] where I give a filename and get back a list of lines.
15:27:17 <aberrant> but all the examples I see have this in main.
15:27:19 <codeshot> readthis :: String -> IO [String] is required
15:27:19 <xenon-> aberrant you have to change the type to String -> IO [String]
15:27:30 <aberrant> oh. hm.
15:27:44 <aberrant> is there no way to "purify" things within the function itself?
15:27:55 <codeshot> do {thelines <- readThis thename; use thelines}
15:28:00 <codeshot> aberrant, no
15:28:12 <codeshot> no way that is remotely a sensible thing to do
15:28:42 <xenon-> there is an escape hatch in cases where it is really needed, but this certainly isn't one of them. the right thing to do is to change the type to above
15:28:55 <aberrant> huh, ok
15:29:01 <aberrant> guess I have to go back to the book.
15:29:05 <codeshot> you have to shove your response to the list of lines into the IO object that you get back so that it gets a safe sandbox to play in where the action of readthis is promised to have been done
15:29:36 <codeshot> otherwise you could spontaneously react to lines from a file that hasn't even been made yet!
15:30:03 <codeshot> Haskell helpfully prevents you from writing such programs. They are reserved for timelords
15:30:27 <aberrant> ok. I think I sort of understand :)
15:31:25 <marvin3> String -> IO [String] type is useful, you can tell that the function may perform effects. just like you can tell that String -> String can't
15:31:35 <marvin3> (as you found out)
15:32:03 <glguy> and more specifically, the function doesn't perform any effects, but the action you get as a result will if it's sequenced into the main program
15:33:23 <aberrant> so is there no way to handle "impure" data outside of main?
15:34:02 <codeshot> yeah, you make your function return IO something instead of just something and you pop it into your do block that's in main
15:34:11 <codeshot> that's the only safe thing to do
15:34:13 <aberrant> but I don't have a do block in main
15:34:31 <aberrant> I have a main that is simply "print $ show prob22"
15:34:52 <glguy> The "do" part isn't important, it's just a convenient way to use the >>= operator
15:35:06 <marvin3> main = do x <- readthis; print x
15:35:07 <codeshot> you can put it into a do block: do {prob22 <- readthis thename; print $ shoe prob22}
15:35:21 <aberrant> I haven't gotten to >>= yet
15:35:22 <marvin3> I forgot argument to readthis, but hopefully you got the gist of it
15:35:31 <aberrant> I got it.
15:35:36 <aberrant> ok, thank you very much
15:35:42 <aberrant> sorry for all the basic issues.
15:35:56 <aberrant> I swear I have read this part in LYAH.
15:36:09 <codeshot> or (readthis >=> (print . show)) thename
15:41:35 <aleph_0> hi, I've got a problem concerning large inputs to a function. For a little programming puzzle I wrote this (http://lpaste.net/360869) to separate numbers in a textfile.
15:41:55 <aleph_0> This works fine on small strings but throws a no parse exception on large files
15:45:19 <MarcelineVQ> You're not doing anything there that can throw a no parse exception.  What do you do with getAllNumbers?
15:45:43 <aleph_0> a large string with numbers and spaces
15:46:47 <codeshot> when you have a large file do you, by any chance, add newlines?
15:46:48 <aleph_0> oh yes you're right. There's sole dashes in the output and the read :: int crashes it
15:46:54 <MarcelineVQ> What are you doing with the result of getAllNumbers? What's the rest of your code. This code can not cause "error: no parse" if that's what you mean by a no parse exception.
15:47:03 <MarcelineVQ> aha so it's read then
15:47:10 <aleph_0> yep, my bad
15:48:12 <codeshot> aleph_0, if you add important sample inputs to your example code it will be a useful unit test which will help you to deduce the cause of your problems more easily in future
15:49:20 <Profpatsch> Hrm, how do I test whether an executable is in PATH?
15:49:29 <codeshot> aleph_0, hspec is a handy module for such unit tests, and people like quickcheck for it's ability to generate huge numbers of tests from a few succinct patterns by combining them in all the ways
15:49:38 <Profpatsch> createProcess, but only the first CmdSpec lookup part.
15:49:45 <MarcelineVQ> there are a couple problems with getAllNumbers beyond your issue though. for example  getAllNumbers "" will fail because you don't handle the [] case, also getAllNumbers "123"  results in "12" because  [3], being (x:[]) matches null xs
15:50:32 <aleph_0> codeshot: thanks, I'm relatively new and not familiar yet with the libraries, I'll look into it. Also is there a way to get a groupby with this behaviour? grouping if the next element fulfills a condition?
15:50:41 <MarcelineVQ> I didn't work that last part well. [3] is  (3:[]) which fits the pattern of (x:xs)  where x is 3 and xs is []
15:56:04 <codeshot> I dunno, would it help you to parse by using http://hackage.haskell.org/package/base-4.10.1.0/docs/Text-ParserCombinators-ReadP.html
15:56:21 <codeshot> It's an API that's part of the base library which is designed for making parsers
16:01:51 <aleph_0> codeshot: that looks good thanks, but I got it working now
16:06:48 <codeshot> aleph_0, aha but only until you find the next bug!
16:07:21 * codeshot has been here many times in his career
16:08:35 <codeshot> aleph_0, also only until you try to explain the code and its featureset to someone, and they make changes to it
16:21:30 <alexknvl> what's the best parser combinator library if I care only about the clarity of the grammar description and ideally want to be able to introspect it (e.g. print it out as EBNF)
16:29:52 <glguy> If you only care about the performance of the parser and the clarity of the grammar, Happy's a good choice
16:32:40 --- mode: glguy set -o glguy
16:33:13 <aberrant> my code isn't terminating: http://lpaste.net/360873
16:33:17 <Axman6> "Beginner programmer: I have found the bug! Expert programmer: I have found a bug."
16:33:30 <aberrant> I have neither found THE bug nor A bug.
16:33:38 <aberrant> what's before "beginner"?
16:34:19 <Axman6> well, [1..] is an infinite list...
16:34:31 <Rembane> Before beginner programmer: "I haven't yet found the bug..."
16:34:42 <Axman6> are you trying to pair teh values in firstscores and [1..]?
16:34:44 <aberrant> Axman6: yeah, but I figured it would terminate when `x` ran outl
16:34:49 <Axman6> if so, youy want to use zip
16:34:50 <aberrant> axman6: yes.
16:34:52 <aberrant> ok
16:34:58 <aberrant> I thought that would do that.
16:35:04 <aberrant> thanks.
16:35:17 <Axman6> > [(x,y) | x <- [1..10],y<- [1..]]
16:35:19 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
16:35:43 <Axman6> > [(x,y) | (x,y )<- zip [1..10] [1..]]
16:35:44 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
16:36:15 <Axman6> list comprtehensions give you the cartesian product, all combinations of of the values in each list
16:39:16 <Axman6> aberrant: you should also pay attntion to the suggestions at the bottom of the page
16:40:51 <aberrant> oh, wow. OK
16:40:53 <aberrant> thank you.
16:41:00 <aberrant> my program works, so that's good :)
16:41:08 <aberrant> appreciate the pointers.
16:45:00 * hackage rank2classes 1.0 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.0 (MarioBlazevic)
16:45:05 <glguy> > init "example" -- aberrant
16:45:07 <lambdabot>  "exampl"
16:45:17 <aberrant> oooh.
16:45:28 <aberrant> that's better than all those reverses.
16:45:41 <aberrant> thank you
16:46:15 <alexteves> huh didn't there use to be a 'dup :: a -> (a,a)' function?
16:46:19 <alexteves> can't find it in hoogle
16:46:58 <jle`> alexteves: i remembered a moment where i thought there was too and was surprised
16:47:03 <jle`> there's 'swap' even
16:47:16 <Axman6> join (,)
16:47:22 <Axman6> > join (,) 1
16:47:24 <lambdabot>  (1,1)
16:47:29 <alexteves> oh nice
16:48:15 <aberrant> firstscores = calcNameScores $ map (tail . init) $ ll
16:48:26 <aberrant> I am overusing $
16:48:40 <alexteves> no such thing as too much $
16:48:46 <aberrant> oh, ok :)
16:48:49 <EvanR> more $ more problems
16:48:58 <glguy> aberrant: You'll get used to using less over time
16:49:09 <glguy> but for now you can always throw in some extra:
16:49:30 <glguy> > ($) ($) ($) ($) map succ $ [0..1]
16:49:31 <lambdabot>  [1,2]
16:49:41 * hackage grammatical-parsers 0.2.2 - parsers that can combine into grammars  https://hackage.haskell.org/package/grammatical-parsers-0.2.2 (MarioBlazevic)
16:50:12 <glguy> most everyone goes through an operator fascination phase
16:58:29 <Axman6> > show<$>(,,)<$>[1..3]<*>[4..6]<*>[7..9]
16:58:31 <lambdabot>  error:
16:58:31 <lambdabot>      â€¢ Couldn't match type â€˜[Char]â€™ with â€˜Integer -> Integer -> bâ€™
16:58:31 <lambdabot>        Expected type: Integer -> Integer -> Integer -> b
16:58:38 <Axman6> > (,,)<$>[1..3]<*>[4..6]<*>[7..9]
16:58:40 <lambdabot>  [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(2,...
16:58:45 <ggVGc> so many numbers
16:59:14 <EvanR> [0..] while supplies last
17:00:07 <ggVGc> if every atom in the world was a transistor, what's the biggest number you could represent
17:00:13 <ggVGc> and can you calculate it using haskell
17:06:15 <Forty-Bot> what's the best way to run external programs and control their stdin?
17:06:53 <geekosaur> depends on what you mean by 'control
17:06:57 <Forty-Bot> provide
17:07:23 <Forty-Bot> e.g. I have some list of bytes I want to use as stdin for some program
17:07:34 <geekosaur> System.Process.createProcess can do it (see UseHandle) and it has some convenience functions
17:08:17 <geekosaur> you can't simply specify a string as its stdin, something still has to actively write that string down a pipe to the subprocess on both posix and windows systems
17:08:28 <codeshot> Rembane, aberrant, before beginner: "I have no bugs, the compiler is broken"
17:09:53 <Gurkenglas> ggVGc, what does represent mean? If an algorithm that would produce a number if given arbitrary time counts as a representation, you cannot comprehend the vastnesses possible.
17:10:04 <Rembane> codeshot: Indeed. :)
17:10:14 <EvanR> is there a standardish "time limited eval" function like, a -> Int -> Maybe a
17:10:25 <ggVGc> no, you have to hold the bits of the number
17:10:34 <EvanR> returns Nothing if not evaluated in n microseconds
17:11:00 <Lokathor> EvanR, there's timeout
17:11:04 <Lokathor> for IO
17:11:22 <ggVGc> how could it not be in IO?
17:11:30 <codeshot> Rembane, Also: "The calculation is wrong at this line, I must add a line before or after it that adjusts the values"
17:12:11 <Lokathor> ggVGc, dunno, but they didn't put IO in their desired type sig so i thought i'd mention that it's an extra constraint
17:12:27 <Forty-Bot> geekosaur: sounds like I can just use hPutStr ?
17:12:36 <EvanR> ggVGc: true, it makes no sense
17:13:07 <geekosaur> Forty-Bot, yes
17:13:26 <Gurkenglas> ggVGc, world means earth? https://en.wikipedia.org/wiki/Single-atom_transistor and http://www.wolframalpha.com/input/?i=atoms+in+the+earth means that the decimal-base exponent of the number of bits should be within an order of magnitude of 50
17:14:01 <Gurkenglas> ggVGc, note also that quantum computers might cheat for another exponential in there depending on what counts as representation when you look in the cracks
17:14:01 <ggVGc> haha, nice :)
17:14:07 <ggVGc> that's a disappointingly small number
17:14:17 <EvanR> i use a single real-valued register
17:14:21 <EvanR> very efficient
17:15:22 <Forty-Bot> mildly relevent: https://www.reddit.com/r/math/comments/283298/how_to_compute_a_very_large_number/
17:15:34 <Gurkenglas> ggVGc, if you're asking because you are fascinated by big numbers, look into the busy beaver sequence.
17:16:49 <Gurkenglas> What's the purest way to add timeouts or ressource constraints to computations?
17:17:54 <codeshot> ggVGc, I think you could do it but it would finally destroy the last echos of the haskell runtime when setting the last bit to 1
17:18:03 <EvanR> Gurkenglas: theres the partiality monad...
17:18:24 <codeshot> not sure how to keep the heat out
17:18:24 <EvanR> each step toward the answer could be associated with a time or resource cost
17:19:29 <codeshot> it's quite easy otherwise. Set all the transistors to on and you have now represented the largest number that can be represented with them
17:20:31 <Gurkenglas> codeshot, the energy wasted on arranging all the bits being one would be better spent on one more transistor to the left holding a 1
17:20:58 <codeshot> Gurkenglas, agreed
17:21:03 <Forty-Bot> well, look
17:21:06 * codeshot goes to buy a transistor
17:21:21 <Forty-Bot> lets say that instead of considering some set of bits as a number
17:21:27 <glguy> How about just agreeing that when the atom *isn't* engerized it means the bit is set
17:21:32 <glguy> and now we don't have to do anything
17:21:37 <Forty-Bot> we instead interpret it as the number of a turing machine
17:21:47 <Gurkenglas> Forty-Bot, shush I already suggested that one
17:21:47 <Forty-Bot> and say that it represents the output of that machine
17:21:59 <geekosaur> Gurkenglas, pretty much by definition you can't do it purely
17:22:20 <codeshot> I wonder what would happen if we could say let ? = foo
17:22:31 <glguy> Gurkenglas: You can make the costs explicit in the pure value: data Computation a = Step (Computation a) | Done a
17:22:36 <glguy> and then only unfold as much as you're willing
17:22:42 <codeshot> Such that bog standard function application went through a free applicative
17:22:57 <Gurkenglas> Is there a way that would allow the user to specify the code without routing through a DSL?
17:22:57 * hackage potoki 0.6.4 - Simple streaming in IO  https://hackage.haskell.org/package/potoki-0.6.4 (NikitaVolkov)
17:22:58 <EvanR> ^ partiality monad
17:23:21 <glguy> Gurkenglas: The user would need to be explicit about what is considered a step
17:23:23 <geekosaur> codeshot, you could say that was what Arrows were reaching toward. but they didn;t use standard function application either
17:23:58 <glguy> "resumption monad"
17:24:02 <alexteves> is there a name for the special case of (***) when the two first args are the same?
17:24:57 <xenon-> ***)
17:25:04 <codeshot> geekosaur, somewhere down there they do, and haskell has this feature where you can define hidden parameters, what if function application itself was one of those hidden parameters. Then you could have functions which internally are referentially transparent, but to the caller they are completely described by a free applicative
17:25:05 <xenon-> :t (***)
17:25:06 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:25:12 <codeshot> and you can analyse and transform them
17:25:15 <Gurkenglas> My thought process that caused that question is a prisoner's dilemma tournament where each algorithm is passed their opponent as a black box - "newtype Bot = Bot { runBot :: Bot -> Bool }", except that you'd want some sort of timeout control so bots don't have to automatically, say, defect if something loops
17:25:28 <alexteves> I don't even need it to work for arrows, functions are enough
17:25:34 <codeshot> compute the costs, apply strictness analyses, etc
17:25:42 <alexteves> (a -> b) -> (a,a) -> (b,b)
17:27:25 <Gurkenglas> :t over both -- alexteves, the lens library is yÌ¶oÌ¶uÌ¶rÌ¶ Ì¶fÌ¶rÌ¶iÌ¶eÌ¶nÌ¶dÌ¶ a beginner-devouring fractal of ivory
17:27:26 <lambdabot> Data.Bitraversable.Bitraversable r => (a -> b) -> r a a -> r b b
17:28:08 <codeshot> glguy, you just let the universe reach thermal equilibrium? Do we know that happens at absolute zero?
17:28:11 <exio4> any #ghcjs ops?
17:28:29 <geekosaur> codeshot, I would not want to have to implement that within ghc. there's some pretty low level assumptions that normal function application compiles directly to STG applications
17:28:36 <geekosaur> and has a simple type
17:29:16 <geekosaur> suspect the typechecker would explode if the type of a function application could drag in e.g. Applicative
17:30:29 <EvanR> i am wondering how to make composable breadth first searches...
17:30:43 <codeshot> geekosaur, hopefully we only get explosions on esoteric hardware like the planetwide haskell implementation glguy is talking about
17:30:44 <EvanR> suddenly
17:31:03 <codeshot> waitaminute! Isn't the largest number we can represent just 42 ?
17:31:06 <geekosaur> codeshot, you are making a lot of incorrect assumtpions
17:31:14 <codeshot> We already know this of planetwide computers
17:31:23 <geekosaur> and appafrently also assuming ab=nyone who doesn;t agree is a priori wrong
17:32:05 <codeshot> I can't think of any time today where I thought someone was wrong, let alone a-priori
17:32:23 <codeshot> except this latest moment
17:32:34 <tabemann> is it me, or wouldn't a planet-wide erlang implementation work out better than a planet-wide haskell implementation?
17:33:24 <EvanR> > zip3 [0..] [0..] [0..]
17:33:26 <lambdabot>  [(0,0,0),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,...
17:34:35 <codeshot> I saw a simon peyton-jones talk mentioning the successful implementation of the erlang featureset in haskell
17:35:10 <tabemann> you mean distributed-process
17:35:26 <Forty-Bot> how do I globally disable tabs warnings?
17:35:36 <glguy> Remove all the tabs from your files
17:35:39 <tabemann> I still wonder how you do dynamic code loading with distributed-process though
17:35:44 <codeshot> specifically a library that does what erlang does, pretty-much 1:1
17:36:00 <codeshot> That's the gist of the description I watched
17:36:08 <Forty-Bot> yeah, besides that
17:36:20 <tabemann> you shouldn't be using tabs in haskell code
17:36:29 <glguy> says tab-emann
17:36:48 <Forty-Bot> tabemann: I am too lazy to reconfigure my vim
17:36:49 <codeshot> tabemann, with IO I guess, or prayers
17:36:56 <Forty-Bot> and I use tabs everywhere else
17:37:12 <EvanR> Forty-Bot youre committing crimes against humanity
17:37:19 <EvanR> fyi
17:37:27 <Forty-Bot> k
17:37:33 <codeshot> Forty-Bot, sed and vimdir
17:37:38 <tabemann> Forty-Bot: I assume there is a haskell-mode equivalent for vim
17:37:45 <tabemann> you should be using that
17:37:49 <Forty-Bot> well
17:37:57 <Forty-Bot> I can disable them on a .cabal-basis
17:38:09 <Forty-Bot> so I'd like to know how to make that global
17:38:28 <tabemann> you shouldn't be turning them off
17:38:43 <Forty-Bot> I want to
17:38:49 <Forty-Bot> they are whitespace like any other
17:39:00 <tabemann> the problem is who knows how big a tab is
17:39:07 <Forty-Bot> and it shouldn't be a compillation error
17:39:10 <tabemann> in one editor a tab may be a different size than in another editor
17:39:13 <Forty-Bot> so?
17:39:15 <glguy> tabs aren't a compilation error
17:39:23 <Forty-Bot> it is for cabal
17:39:25 <tabemann> and haskell is whitespace-sensitive
17:39:25 <glguy> no
17:39:26 <Forty-Bot> in config files
17:39:43 <Forty-Bot> "$ cabal repl
17:39:43 <Forty-Bot> ./gurps.cabal has been changed. Re-configuring with most recently used
17:39:43 <Forty-Bot> options. If this fails, please run configure manually.
17:39:43 <Forty-Bot> cabal: gurps.cabal:62: Do not use tabs for indentation (use spaces instead)
17:39:43 <Forty-Bot> Tabs were used at (line,column): [(62,0),(62,1),(62,2),(62,3),(62,4)]
17:39:44 <Forty-Bot> "
17:40:04 <glguy> Oh, you mean for .cabal files.
17:40:07 <glguy> I was only talking about .hs files
17:40:16 <tabemann> the key thing is that depending on your editor tabs can be any size
17:40:21 <Forty-Bot> tabemann: so?
17:40:21 --- mode: ChanServ set +o glguy
17:40:46 <Forty-Bot> use tabs for indentation, when you need to align something with the previous line use spaces
17:40:54 <EvanR> ;_;
17:40:59 <tabemann> Forty-Bot: because in a language that is whitespace-sensitive it needs to know how big a tab is
17:41:16 <tabemann> and what it thinks a tab should be may not agree with what your editor displays
17:41:19 <aberrant> is there any advantage to composing functions as opposed to chaining via $ ?
17:41:31 <tabemann> aberrant: lots of $s are ugly
17:41:50 <tabemann> I like to do: foo . bar $ baz x
17:42:16 <aberrant> but from a performance perspective, no difference?
17:42:27 <tabemann> performance-wise it shouldn't make a difference
17:42:44 <aberrant> thanks, tabemann :)
17:42:48 <codeshot> aberrant, point-free style, describing equivalency directly
17:44:44 <tabemann> but yeah, if I can I turn f x = h $ g x into f = h . g
17:45:07 <tabemann> but I tend to avoid more convoluted pointless style stuff
17:45:39 <Forty-Bot> lol "pointless"
17:46:27 <tabemann> e.g. I avoid using flip and stuff like (.) and like
17:54:27 <Gurkenglas> I usually try to go as pointless as maximizes my ability to see the larger opportunities to refactor.
17:55:15 <ReinH> I still think Richard Bird has the best take, which is that point-free is good for reasoning about composition, while point-full is good for reasoning about application.
17:55:16 <EvanR> Gurkenglas: also, you could include a function that takes the amount of effort to expend trying to compute the answer as an argument. then the result, which has a fixed amount of work (possibly infinite) will be a pure result
17:55:48 <EvanR> either complete or incomplete with some of the work done
17:56:10 <Gurkenglas> EvanR, how do you enforce that the computation that the user-submitted code does does not exceed the provided ressources?
17:56:36 <aberrant> my code is way too slow
17:56:43 <EvanR> the user-submitted code would need to have the proper type to go into this function
17:57:27 <EvanR> the agreement is we wrote total/productive code and the type contains the necessary bits for the effort to work right
17:58:11 <Gurkenglas> I don't follow, can you specify that type?
17:58:18 <Gurkenglas> *write a type signature, dangit enter key
17:58:20 <aberrant> http://lpaste.net/360877
17:58:30 <aberrant> it's very slow.
17:58:49 <EvanR> Computation a -> Int -> Either (Computation a) a
17:59:00 <EvanR> Int is steps
18:02:06 <Gurkenglas> EvanR, is Computation a a complete programming language?
18:02:49 <EvanR> depends on how much you trust the programmer
18:03:44 <EvanR> if they are turing certified, give them turing complete and have them sign an agreement to only write total code
18:03:51 <codeshot> Gurkenglas, I try to go as pointless as I can to discover the limits and then pull back, now being solid with the problem
18:04:00 <EvanR> otherwise give them the crippled total language
18:04:37 <bigos_> how do i get a string representation of the value and its type
18:04:52 <Gurkenglas> EvanR, you could have it be turing complete if the Int were infinite
18:05:04 <codeshot> I recently discovered the utility of join for the ((->) r) monad so I'm planning to recrazify my code for a while to see what pointless pleasures await
18:05:05 <EvanR> (its funny that we have it backwards, only experts use crippled total language, most people use the high voltage turing complete language)
18:05:36 <EvanR> Gurkenglas: uh Int doesnt have "infinity"
18:05:41 <Gurkenglas> yknow what i mean
18:06:04 <Gurkenglas> EvanR, so you do have to write your own language to make this work? As opposed to as canonical a specification as Bot ~ Bot -> Bool
18:06:42 <EvanR> well haskell itself lets you do anything
18:07:40 <EvanR> im not sure how you "purely" guard against them handing you an error "haha"
18:07:45 <codeshot> EvanR, high-voltage languages let you bluff and cheat before the other guys have their solutions ready. The point appears to be that you can lead people into a local minima where they pay you instead of others
18:10:16 <codeshot> Oftentimes they have a legitimate point I suppose because if the risk (probability * cost) of hitting a partial function the wrong way is low enough then your customer just beat the other guy's customer and they can use the money they saved to recompense their own customer
18:12:13 <EvanR> a locked up rails app due to while true: ... or something just feels bad
18:13:10 <EvanR> same as a js page freeze
18:13:48 <codeshot> watchdog can often cure that. The function is constantly an approximate solution and we can observe the size of the error and adjust the program accordingly
18:15:03 <codeshot> It's still maths but where people are part of the system, fascinating stuff
18:15:16 <codeshot> circular and all mind-blowy
18:15:35 <EvanR> i am right now trying to deal with exact what Gurkenglas is talking about... a thunk can be left alone or you can commit to however long it takes to get WHNF, and you dont know ahead of time how long that will be
18:15:56 <EvanR> thats annoying
18:16:33 <codeshot> Doesn't IO have a watchdog facility ?
18:16:41 <EvanR> you cant start the process, pause it, resume it later, etc
18:16:55 <codeshot> you can run IOs in parallel
18:17:31 <EvanR> thats something but
18:17:36 <aberrant> Prelude>  isSumOfAbundants 23 // False // (14.17 secs, 3,607,669,024 bytes)
18:17:46 <EvanR> its limited
18:17:49 <aberrant> this is horrible: 3.6 gigs and 14 seconds?
18:17:54 <Gurkenglas> You can give the user a number of milliseconds and kill them after that's done, and they might be able to science up some estimates on how much that lets them do on your computer
18:18:20 <codeshot> aberrant, what happens when compiled?
18:18:34 <aberrant> codeshot: dunno, but it's a problem with my algorithm
18:18:46 * aberrant sighs
18:18:53 <codeshot> I noticed ghci does this weird thing of keeping every intermediate value alive then slowly killing them later
18:19:13 <codeshot> or so it appeared
18:19:15 <Gurkenglas> Does some other language than Haskell solve this problem? Preferably one that's, um, Haskell.
18:19:21 <codeshot> lol
18:19:29 <aberrant> I'm doing a cartesian product of 6700+ values.
18:19:49 <aberrant> this is probably not the right way.
18:20:10 <geekosaur> Gurkenglas, any language that isn't pure
18:20:12 <codeshot> aberrant I'm interested, can you share the code?
18:20:12 <aberrant> I may have to cheat.
18:20:18 <geekosaur> you seem to have a fdundamental misunderstanding somewhere
18:20:20 <aberrant> codeshot: absolutely.
18:20:23 <aberrant> one sec.
18:20:48 <tabemann> this sounds like a problem that may be solved by adding more strictness
18:20:57 <Gurkenglas> aberrant, you could cut something in half by using [x + y | (x:ys) <- tails abundants, y <- ys]
18:20:59 <geekosaur> pure says nothing about memory use. pure says nothing about time spent. *both of those are outside the user code and therefore require impurity*
18:21:14 <Gurkenglas> (whoops, redundant brackets)
18:21:23 <tabemann> strictness won't make your code faster but it may make it take up less memory
18:21:33 <EvanR> strictness might make it faster
18:21:34 <aberrant> codeshot: http://lpaste.net/360878
18:21:44 <EvanR> if for no other reason that its taking less memory
18:21:47 <EvanR> than
18:23:06 <aberrant> Gurkenglas: yes, that's what I want. I was sort of hoping that the "x < y" would do some short-circuiting
18:23:19 <aberrant> Gurkenglas: but I realize that it has no way to tell that the lists are sorted.
18:23:28 <codeshot> < and <= for numbers will add some strictness
18:23:37 <codeshot> I noticed reverses in there
18:23:48 <aberrant> there are some reverses
18:24:28 <codeshot> These can often slow things down, and there's a chance this hits the same ghci problem that I found elsewhere with too many thunks being kept around - I assume just in case
18:24:48 <codeshot> Try compiling and running the compiled program, it might tell us something useful
18:24:58 <aberrant> ok. THanks.
18:25:03 <aberrant> Gurkenglas: where is "tails"?
18:25:45 <codeshot> somewhere near Sonic I guess ... or is this joke 2.5 decades out of date ?
18:25:49 <EvanR> geekosaur: i have another theory... if instead of concrete immutable values (with perhaps lazy pieces), you could be passing around mutable cells which contain logically 1 value, but "something" causes them to mutate toward their final answer, according to some domain
18:26:14 <EvanR> if something sees or remembers an old version, its still the same value, just with less precision
18:26:53 <aberrant> codeshot: will compile and report back
18:26:54 <codeshot> EvanR, sounds like an interesting Monad
18:27:20 <MarcelineVQ> EvanR: data Evo (a :: Universe) = Cell a
18:27:29 <kakashiAL> where does the term "point free" comes from?
18:27:33 <EvanR> one example of this could be Gurkenglas's thunk, but instead of all-or-nothing, the thing in the cell is a suspended computation
18:27:35 <kakashiAL> from category theory?
18:28:01 <kakashiAL> or does "point" means x in IINPUT-SET ?
18:28:04 <EvanR> MarcelineVQ: Evo ?
18:28:40 <codeshot> EvanR, can you combine 'fix' and the continuation monad ?
18:28:43 <MarcelineVQ> a march towards the final answer
18:29:17 <codeshot> I had some luck writing recursive steps for use with fix then doing fix (magic_sequencing_policy step)
18:29:19 <kakashiAL> anyone?:(
18:29:38 <vaibhavsagar> is there an RSS feed that updates when a new Stackage LTS comes out?
18:29:39 <Gurkenglas> aberrant, hoogle will tell you it's from Data.List
18:29:45 <codeshot> kakashiAL, no idea
18:29:51 <aberrant> codeshot: real	0m1.150s
18:30:01 <aberrant> codeshot: it's a ghci problem
18:30:18 <aberrant> compilation helped.
18:30:36 <MarcelineVQ> kakashiAL: https://www.google.com/search?q=where+does+the+term+pointfree+come+from   ->  https://wiki.haskell.org/Pointfree    ->  "The term originated in topology, a branch of mathematics which works with spaces composed of points, and functions between those spaces. So a 'points-free' definition of a function is one which does not explicitly mention the points (values) of the space on which the function acts."
18:30:51 <codeshot> you could tune your code, it might not be truly a ghci problem, the compiler does extra things that it doesn't have to in order to make your program fast
18:31:13 <codeshot> but I don't think the ghci behaviour is helpful - however I don't know enough to say for sure
18:31:58 <aberrant> I should tune my code, and then figure out the best way to do this by checking the eulerproject cheats :)
18:32:42 <EvanR> and maybe the evolution can be associated with time or space costs
18:33:17 <kakashiAL> MarcelineVQ: THANKS!!!
18:38:31 <kakashiAL> very stupid question, but you cant always do point-free programming, but if you cant do it all the time, is it something that you want to  strive for?
18:38:48 <kakashiAL> is pointfree that forces you to think in composition=
18:38:49 <kakashiAL> ?
18:39:11 <codeshot> kakashiAL, I find it's often very instructive. It'd helped my understanding of the maths that makes Haskell tick and so improved my code
18:39:58 <kakashiAL> codeshot: is that a yes ?:)
18:39:59 <codeshot> I found it makes me think in lattices and how composition adjusts the "shape" of the program
18:40:02 <geekosaur> yeh, it;s useful for coming to understand how combinators work and foit together
18:40:10 <EvanR> MarcelineVQ: is that cell supposed to be mutable or
18:40:20 <geekosaur> I would not worry overmuch about using pointfree form in actual code, although sometimes it is convenient
18:40:27 <Average-user> Point-free helped me to make use of curring, to understand that every function takes just one argument
18:40:47 <geekosaur> it used to be that ghc could optimize such code better, but these days it can rewrite stuff itself
18:41:26 <Average-user> geekosaur: Thats interesting, didn't know about it
18:41:47 <codeshot> kakashiAL, there are many kinds of strive, so if I may split it in two: try it out, really seriously over-use it then climb-down - yes .... push everything inexorably in that direction, not sure, it looks problematic but maybe there's a hidden eutopia there that I can't see
18:41:47 <kakashiAL> would you agree with me if I say:  "point-free programming forces you to think in composition and try to avoid point-wise functions to get readability"
18:43:47 <codeshot> kakashiAL, is this a homework question?
18:44:01 <kakashiAL> codeshot: no sir
18:44:18 <kakashiAL> codeshot: just for me to understand it and share my knowledge
18:44:30 <kakashiAL> codeshot: so is that a yes?
18:45:12 <codeshot> composition is so similar to mutation that I don't think it's important that it forces you to think like that
18:45:41 * hackage extensible 0.4.7 - Extensible, efficient, optics-friendly data types and effects  https://hackage.haskell.org/package/extensible-0.4.7 (FumiakiKinoshita)
18:45:44 <kakashiAL> codeshot: you say that compostion is like mutation O_O
18:45:56 <codeshot> it looks like a pipeline
18:46:35 <kakashiAL> codeshot: I dont agree, its more like pipe, its an easy way to reason about stuff, just imagine a validator or something that you want to parse
18:46:45 <codeshot> data goes in one end, and stage by stage you find different data when you look, if the compile deduces that the intermediates are not needed it could indeed compile your code to mutation of a memory object
18:47:25 <kakashiAL> compose( length, getSecondSentence ,trim)
18:47:42 <codeshot> kakashiAL, see my comment moments above - we are probably in agreement on that but using different similes
18:47:44 <kakashiAL> for me this is pure beauty
18:48:16 <kakashiAL> codeshot: maybe :)
18:51:13 <kakashiAL> I said it and repeat it "point free programming is a mindset to force composing functions to make them eaasy to read and reason about about AND to reuse :)
18:51:33 <kakashiAL> (nobody killed me for that, so it makese sense for me :)
18:55:26 * hackage importify 1.0 - Tool for haskell imports refactoring  https://hackage.haskell.org/package/importify-1.0 (shersh)
18:58:39 <rotaerk> kakashiAL, except not every function is most readably expressed in a point-free style
18:59:20 <Axman6> yeah do not aim for pointfree is a goal, only used it when it makes code clearer or at least not more unclear
18:59:34 <Axman6> understanding _how_ is more important than actually doing it'
18:59:37 <rotaerk> some functions require you to really bend over backwards to get it point free
19:00:50 <tabemann> I personally prefer only to use point-free style when things can be expressed like foo . bar . baz
19:01:02 <tabemann> once one needs things like flip and like, no
19:05:16 <Average-user> tabemann: flip is bautiful, it express the essence of information, a function needs his arguments to be in certain order, but is the same information after all
19:06:19 <geekosaur> tell us that after @pl flips out at you :p
19:06:27 <EvanR> @hoogle s -> (a,s) -> [a]
19:06:27 <lambdabot> Math.FFT.Base fzr :: b -> [a] -> [(a, b)]
19:06:27 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
19:06:27 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
19:06:41 <EvanR> @hoogle (s -> (a,s)) -> s -> [a]
19:06:41 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
19:06:41 <lambdabot> GHC.OldList unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
19:06:41 <lambdabot> Distribution.Compat.Prelude.Internal unfoldr :: () => (b -> Maybe (a, b)) -> b -> [a]
19:06:51 <EvanR> mmhmm
19:07:05 <Average-user> on is another great function for pont-free
19:07:08 * hackage rollbar 1.1.0 - error tracking through rollbar.com  https://hackage.haskell.org/package/rollbar-1.1.0 (azara)
19:11:13 <Average-user> who is doing AoC today?
19:11:54 <Average-user> I hope is not another problem that needs to be optimized in part B, or at least not just that
19:12:01 <glguy> AoC e'ery day
19:12:17 <glguy> I hope it's another problem that benefits from some thought
19:12:52 <Average-user> glguy: well, last ones haven't
19:14:05 <vaibhavsagar> Average-user: how do you mean? I haven't had to optimise the last two days
19:14:22 <vaibhavsagar> you *could* optimise, but you could also do it a different way
19:14:40 <Average-user> vaibhavsagar: I mean, that in first part you could just simulate what is asked, but part b clearly not
19:14:56 <Average-user> vaibhavsagar: the dancing programms for example
19:15:51 <vaibhavsagar> ah, you're right about that
19:16:01 <[Leary]> The most recent one I simulated the second part. I think it took about 90 seconds to run.
19:16:06 <glguy> Day 17 didn't require optimization, the naÃ¯ve version ran in 1.25 minutes
19:16:39 <vaibhavsagar> glguy: I tried it and it took forever, I think my bang-pattern-fu is weak
19:17:19 <Average-user> glguy: really? day17, the one that you had to make something 5e7 times?
19:17:25 <glguy> yeah
19:17:58 <Average-user> glguy: well, i guess if you have some mutable container like vectors you can, but in Prolog looks like impossible
19:18:08 <glguy> I didn't use a mutable container in Haskell
19:18:31 <glguy> I used Seq from Data.Sequence
19:18:34 <Average-user> glguy: but you did use something else than lists right?
19:18:42 <[Leary]> You don't even need bang patterns. I used data CursedSeq a = CS !Int !(Seq a).
19:18:43 <Average-user> glguy: ohh thats enoff
19:19:01 <EvanR> Average-user: vectors in haskell or clojure arent mutable
19:19:25 <Average-user> EvanR: not really, you are right
19:19:27 <EvanR> well here MVector
19:19:38 <EvanR> haskell has a mutable vector type in IO
19:19:50 <Average-user> EvanR: thats what I mean
19:20:31 <EvanR> but the basic one is immutable
19:21:04 <Average-user> EvanR: I know
19:30:13 <Average-user> glguy: But in your repo isn't that solution right?
19:36:11 <glguy> No, it computes part2 efficiently, but the code that computes part1 in that solution *will* compute part 1
19:36:15 <glguy> part 2*
19:39:03 <Average-user> shh ok
19:44:29 <vaibhavsagar> okay, here is my Day17 solution: http://lpaste.net/360881
19:45:09 <vaibhavsagar> it's been running for ~6 minutes and will probably complete in a few more
19:45:25 <vaibhavsagar> anyone know what I'm doing wrong that is making it so slow?
19:49:07 <Average-user> vaibhavsagar: It can be done with just numbers
19:49:36 <vaibhavsagar> you mean keeping track of the elements inserted at index 1?
19:49:43 <Average-user> vaibhavsagar: indeed
19:49:56 <vaibhavsagar> yeah, that was my solution because this was too slow
19:50:11 <vaibhavsagar> but I'm wondering how I can get the ~90s runtime that glguy gets
19:50:26 <Average-user> vaibhavsagar: no idea
19:50:29 <vaibhavsagar> because clearly I must be doing something wrong if this takes 10 minuts
19:50:42 <Average-user> vaibhavsagar: Are u using Sequences?
19:50:47 <vaibhavsagar> I am
19:50:49 <glguy_> Try running mine, maybe your computer is just show or had insufficient ram to pull it off
19:51:25 <vaibhavsagar> that is a good idea
19:51:37 <glguy_> The library provided insertAt is faster than the >< built one, I haven't looked closely yet though
19:52:31 <Average-user> My internet died
19:52:33 <Average-user> sorry
19:53:15 <Average-user> vaibhavsagar: are you doing it with sequences then?
19:53:56 <Average-user> vaibhavsagar: better yet, can you post the link again?
19:55:02 <vaibhavsagar> Average-user: http://lpaste.net/360881
19:56:33 <glguy_> If you're actually running it with Trace on every element that's a big source of slowness
19:56:56 <vaibhavsagar> ah, that was mostly so I could track progress
19:57:23 <vaibhavsagar> I will try without the traceShow now that I know mine takes ~10 minutes
19:57:48 <vaibhavsagar> it's looking like the insertAt is the source of some of the difference
19:58:35 <vaibhavsagar> I'm using GHC 8.0 because I didn't want to deal with any possible GHC 8.2+IHaskell incompatibilites in addition to everything else
19:59:24 <Average-user> vaibhavsagar: you better do day18 now
19:59:36 <vaibhavsagar> Average-user: I did
19:59:41 <Average-user> vaibhavsagar: starts in 1 min
19:59:58 <Average-user> vaibhavsagar: so I dont how is that possible
20:00:25 <vaibhavsagar> oh, oops
20:00:30 <vaibhavsagar> starts in 1 hour, no?
20:00:32 <Average-user> vaibhavsagar: xd
20:00:39 <dsal> Heh.  Just saw this on Quora: https://www.quora.com/Why-does-it-seem-like-many-haskellers-are-libertarian
20:01:02 <Average-user> vaibhavsagar: where you use lists you could use sequences as well I think
20:01:09 <tabemann> lol
20:01:17 * tabemann is not a libertarian haskeller
20:01:30 <tabemann> or shall I say, Libertarian with a big L
20:01:33 <Average-user> vaibhavsagar: My watch was crazy
20:01:41 <vaibhavsagar> Average-user: probably just a counter I think, I only used lists so I could express my solution in terms of foldl'
20:02:07 <tabemann> you can use anything Foldable with foldl'
20:02:21 <Average-user> vaibhavsagar: I havent seen your code, but where do you need insertAt, and why do you think is source of the slowness
20:02:29 * tabemann regularly uses Seq with foldl'
20:02:49 <vaibhavsagar> Average-user: I'm running glguy's solution and it takes ~5 minutes on my machine
20:02:49 <Average-user> tabemann: Im talking about insertAt
20:03:03 <Average-user> vaibhavsagar: how did you compile it?
20:03:47 <vaibhavsagar> ghc Day17-glguy.hs -o day17-glguy
20:04:00 <Average-user> vaibhavsagar: use -O (big o)
20:04:07 <vaibhavsagar> oops, I did
20:04:11 <vaibhavsagar> ghc Day17-glguy.hs -O -o day17-glguy
20:04:23 <Average-user> vaibhavsagar: without the otherone
20:04:32 <geekosaur> that - before glguy.hs seems wrong too, but I'd expect bigger problems than just slowness
20:04:46 <geekosaur> and -o is not something to skip there
20:05:02 <Average-user> geekosaur: why not?
20:05:13 <vaibhavsagar> 'Day17-glguy.hs' is the name of the file
20:05:41 <geekosaur> oh, sorry. right, no space there
20:05:42 <Average-user> vaibhavsagar: I just use: ghc -O file.hs
20:06:05 <Average-user> and then ./file
20:06:07 <geekosaur> Average-user, because if you do not also remove the name after, you get an error. if you do, you get a name differing in case, which may confuse you depending on the OS
20:06:26 <geekosaur> in any case, simply replacing -o with -O as you seem to be describing is not going to work
20:06:44 <glguy> vaibhavsagar: the process will need about 5.2 GB of RAM to finish without hitting swap
20:07:38 <Average-user> geekosaur: Like I said, I've almost ever used just: `ghc -O file.hs` and that have worked forme pretty well, I'm linux tough, don't know about other OS
20:08:15 <tabemann> Average-user: the matter is that the source file name and the executable name differ in case
20:08:22 <vaibhavsagar> glguy: I think I have enough RAM :)
20:08:33 <vaibhavsagar> I'm trying with GHC 8.2 now
20:09:25 <Average-user> tabemann: When you don't already have an executable it can't matter right?
20:10:33 <vaibhavsagar> glguy: with GHC 8.2 and the built-in Seq.insertAt it completes in less than 2 minutes
20:10:56 <glguy> Now we're talking :)
20:11:02 <tabemann> Seq is your friend
20:11:11 <glguy> I'd just make this: http://lpaste.net/7518497791048417280
20:12:01 * tabemann likes Seqs much better than lists himself
20:12:07 <vaibhavsagar> now I want to try my slow solution with GHC 8.2
20:12:15 <Average-user> the difference might be cause your inputs
20:12:29 <tabemann> sure lists can be infinite and are lazy and shit, but half the time laziness does not help things
20:13:02 <Average-user> tabemann: Yeah Seqs are really useful
20:13:24 <tabemann> you can add to the end of Seqs in constant time
20:13:46 <vaibhavsagar> I think I learned about Seqs from glguy's solutions last year
20:14:08 <glguy> I had a Seq based solution last year that saved to a TON of time on the leaderboard
20:14:21 <glguy> http://adventofcode.com/2016/leaderboard/day/19 I finished that one in 8:45, #2 was 15:04
20:14:29 <vaibhavsagar> they were very good for the grap traversals
20:15:17 <vaibhavsagar> pfft, my solution completes in the same time as glguy's with GHC 8.2
20:15:43 * vaibhavsagar shakes fist at GHC 8.0
20:16:03 <Average-user> I don't have GHC 8.2
20:16:11 <vaibhavsagar> Average-user: get Nix
20:16:19 <Average-user> vaibhavsagar: Whats that?
20:16:21 <tabemann> does cabal now work properly in the latest Haskell Platform?
20:16:21 <vaibhavsagar> then you have all the GHCs
20:16:25 <glguy> They snuck the 8.2 series out back in Jully
20:16:28 <glguy> July*
20:16:40 <glguy> I've been hoarding it all to myself
20:16:47 <vaibhavsagar> Average-user: https://nixos.org/nix/
20:16:56 <glguy> You don't need a special OS to install all the GHCs
20:16:58 <vaibhavsagar> glguy: I implemented IHaskell support for GHC 8.2
20:17:08 <vaibhavsagar> glguy: that's the package manager, not the OS
20:17:09 <tabemann> because I tried the Haskell Platform with GHC 8.2 months back and found cabal to be buggy as hell
20:17:09 <glguy> You just set the --prefix when you install one
20:17:14 <vaibhavsagar> although the OS is quite nice
20:17:22 <glguy> You don't need any of that complexity
20:18:13 <vaibhavsagar> it's super easy though, I can do `nix-shell -p 'haskellPackages.ghcWithPackages (p: [ p.containers ])'` to get a self-contained GHC 8.0 environment
20:18:51 <vaibhavsagar> for GHC 8.2 it's almost the same: `nix-shell -p 'haskell.packages.ghc822.ghcWithPackages (p: [p.containers])'`
20:19:35 <vaibhavsagar> and you can launch self-contained IHaskells with it, thanks to yours truly
20:19:36 <glguy> I'd rather have new-build manage which packages are available and when to compile them
20:19:53 <vaibhavsagar> glguy: I think you can use new-build in conjunction with Nix
20:20:04 <vaibhavsagar> in fact I think cabal has nix support baked in now
20:20:07 <glguy> It's working great without it already
20:20:07 <Average-user> glguy: how did you install ghc2?
20:20:19 <glguy> Average-user: Downloaded it from haskell.org, installed it into my user directory
20:22:14 <glguy> vaibhavsagar: The IHaskell files you put in your github repo looked neat
20:22:30 <glguy> Is that rendering just something that github knows how to do?
20:22:43 <vaibhavsagar> yes, GitHub renders IPython notebooks
20:23:22 <vaibhavsagar> it has for a while, I remember being super excited when they announced it: https://github.com/blog/1995-github-jupyter-notebooks-3
20:25:58 <Average-user> vaibhavsagar: whats your github name?
20:26:17 <Average-user> and, of what repo r u talking about?
20:53:00 <olligobber> does anyone here know if using forkIO compiles to use something like a thread pool?
20:56:15 <pacak> forkIO creates a new thread. Call it 100000 times - get 100000 threads.
20:59:32 <cocreature> it creates new Haskell threads, not new OS threads
20:59:59 <jle`> probably streaming tonight :)
21:11:41 <Axman6> olligobber: depends on what you mean - GHC has an m:n scheduler which schedules your m threads onto n OS threads (which can be specified at runtime), so in a sense there is a pool of evaluating OS threads, but the Haskell threads are interleaved. You can happily have 100,000 Haskell threads on a few cores without having to worry very much
21:12:06 <olligobber> Axman6, ty
21:12:48 <Axman6> also, Haskell threads are extremely cheap
21:12:56 <olligobber> the C programmer sitting next to me is very unhappy
21:23:46 <Axman6> they all are
21:28:04 <olligobber> hmm, is something like ` f = do {blah; f;} ` a bad idea?
21:28:41 <olligobber> I guess I want the equivalent of a while loop
21:29:00 <olligobber> do I?
21:29:12 <pacak> @src forever
21:29:12 <lambdabot> forever a = let a' = a >> a' in a'
21:30:16 <olligobber> I was going to have a condition in there, ` f = do { blah; when (thing) $ f; }
21:30:29 <pacak> For a while loop you can use fix
21:30:45 <olligobber> pacak, I'll take a look, thanks
21:31:47 <pacak> > fix (\self n -> if n > 4 then [] else n : self (n + 1)) 0
21:31:49 <lambdabot>  [0,1,2,3,4]
21:31:57 <pacak> @src fix
21:31:57 <lambdabot> fix f = let x = f x in x
21:35:28 <olligobber> I'm gonna go for just making lots of threads
21:59:07 <glguy> mniip: You programming?
22:00:53 <olligobber> exceptions are hard...
22:03:02 <olligobber> I guess I will use catchJust ...
22:05:05 <pacak> olligobber: Why do you need exceptions?
22:05:31 <olligobber> pacak, `main: Network.Socket.connect: <socket: 63>: does not exist (Connection refused)`
22:12:03 <glguy> Average-user: Doing AoC?
22:18:39 <Lokathor> 364 on part 2 at 1h:17m
22:18:48 <Lokathor> dag today is a tricky one
22:19:28 <glguy> I had #333/#83 ... had an off by one error in my jgz that wasted a bunch of time :-S
22:19:52 <Lokathor> i had uh
22:20:00 <Lokathor> a... "lack of continue" error
22:20:21 <Lokathor> burned up a lot of time
22:20:27 <glguy> What does that mean?
22:20:57 <Lokathor> i should have used `continue;` when a process was blocked from reading its mailbox, but i didn't
22:21:16 <Lokathor> so it ended up setting itself to blocked but still advancing its instruciton pointer by 1
22:21:42 <glguy> what language?
22:21:52 <Lokathor> rust
22:22:13 <Lokathor> i simulated the two threads existing
22:22:27 <Lokathor> so i ended up with a garbagely long function
22:24:08 <Lokathor> https://github.com/Lokathor/adventofcode2017/blob/master/src/lib.rs#L1585-L1874
22:26:15 <cocreature> glguy: nice solution! I love how you separated the interleaving from the individual execution
22:26:24 <glguy> Thanks ^_^
22:26:33 <Lokathor> nobody likes my solution
22:26:34 <Lokathor> not even me
22:27:15 <rightfold> Then itâ€™s probably bad
22:27:26 <glguy> cocreature: I'm curious to see how this type will pan out: FreeT Cmd (State (Map String Integer))
22:27:32 <Lokathor> rightfold, it's extremely bad
22:28:05 <rightfold> Oh my this code
22:28:07 <Lokathor> I'm very happy with my answer to the one with the guards though, that scanned back and forth
22:28:35 <rightfold> The goggles
22:28:38 <rightfold> They do nothing
22:28:54 <mniip> glguy, sorry I was distracted
22:29:17 <rightfold> Seems a lot of code is similar so you can write abstractions
22:29:49 <mniip> glguy, about to start
22:29:58 <glguy> OK, I'll start the clock!
22:30:09 <mniip> I wasn't thinking of doing it on time
22:30:18 <glguy> I'll stop the clock!
22:30:18 <Lokathor> rightfold, yes, if i wanted to fiddle with it i could extract the two huge branches into a single function that accepts some args
22:30:38 <Lokathor> but, i figured that wasn't going to save me time compared to copy and paste so
22:31:26 <rightfold> If I liked programming puzzles Iâ€™d probably use this one as an excuse to start working on my VM with JIT
22:31:35 <Lokathor> "whatever's fastest to write down" leads to some odd code, i'll tell ya
22:32:09 <rightfold> Copy paste is very fast ;)
22:34:34 <olligobber> this is how my error catching code ended up going, and I hate it: http://lpaste.net/360885
22:35:32 <Axman6> isEmptyChan is a bit of a code smell
22:36:33 <Axman6> you should just read from the chan, which is blocking until there is a value, and then do the connect with the value you've read - you currently have a race condition (though because of Chan's behaviour it doesn't matter much)
22:37:29 <Axman6> is that code supposed to loop for each message in the chan?
22:37:40 <Axman6> uh, yes... this is weird code
22:38:05 <olligobber> Axman6, yeah, the thing is if it can't connect, I don't want it to take anything out of the channel
22:38:26 <Axman6> olligobber: are yuo sure you dfon't want to open one connection and then keep sending messages? Or do you need to make a new connection for each message?
22:38:39 <olligobber> I need to make a new one for each
22:39:36 <Axman6> ok
22:39:54 <glguy> cocreature: Whatdo you think about this? http://lpaste.net/360886
22:40:43 <glguy> I guess this particular code is too simple, but it lets me use the fancy lens monadstate stuff
22:41:14 <olligobber> oh, that forkIO, I'm gonna get rid of that
22:41:24 <olligobber> Axman6, what's this about a race condition anyway?
22:41:59 <Axman6> isEmptyChan might return False and then when you call readChan that will block because the chann has become empty
22:42:30 <Axman6> so you will make a connection to the peer and then possibly wait for a message
22:42:33 <olligobber> you mean it might return true
22:42:41 <Axman6> uh,m yeah
22:42:56 <olligobber> nothing else will read from that chan, so it's not an issue
22:43:07 <olligobber> hopefully
22:44:31 <Axman6> glguy: needs moar Text D:
22:45:02 <Axman6> also, do the semantics of this ... machine code? allow for Integer and not IntN?
22:45:29 <Axman6> glguy: also, your mul is wrong
22:45:34 <Axman6> *= not +=
22:46:03 <cocreature> glguy: neat!
22:46:18 <Lokathor> glguy, where is reg?
22:46:36 <glguy> also I didn't need "Halt"
22:47:01 <glguy> reg r = at r . non 0
22:55:06 <mniip> @undo do t <- mt; s <- ms; t s
22:55:06 <lambdabot> mt >>= \ t -> ms >>= \ s -> t s
22:55:10 <mniip> @. pl undo do t <- mt; s <- ms; t s
22:55:10 <lambdabot> (ms >>=) =<< mt
22:55:14 <mniip> nah
22:55:37 <Axman6> isn't that just mt <*> ms?
22:55:41 <Axman6> no
22:55:49 <Axman6> join $ mt <*> ms
23:00:24 <glguy> Whoops, actually had the type the wrong way around: StateT (Map String Integer) (Free Cmd) Int
23:00:28 <Lokathor> glguy, i take it the funny <~ is doing the "lookup if it's a char and use directly if it's a number" stuff?
23:00:52 <glguy> (<~) :: MonadState s m => ASetter s s a b -> m b -> m ()
23:01:09 <glguy> it runs the 2nd argument and then store the result in the state using the lens provided in the first
23:01:40 <glguy> val r   either returns the number r if it parses as a number or the register r if it doesn't
23:01:58 <Lokathor> ah, val is the thing
23:02:08 <Lokathor> there's quite a few unknown layers here for me
23:02:45 <glguy> My actual solution doesn't use any of that, I'm just exploring what it would have looked like to try and use the free package
23:22:15 <mniip> glguy, let me get this straight,
23:22:24 <mniip> does rcv write the given register?
23:23:08 <mniip> oh
23:25:32 * hackage lapack-ffi-tools 0.0.0.1 - Generator for Haskell interface to Fortran LAPACK  https://hackage.haskell.org/package/lapack-ffi-tools-0.0.0.1 (HenningThielemann)
23:27:05 <mniip> okay wow
23:27:07 <mniip> what a twist
23:27:24 <mniip> glguy, I'm going to brb for a breakfast so stop your clocks
23:38:52 <Lokathor> mniip, with part 2, rcv takes a value from the inbox and puts it in the register and advances 1 instruction, if and only if there is a value in the mailbox (otherwise it blocks until then)
23:38:55 <dysfun> i was just reading a post that calls MultiParamTypeClasses "conversial". why is that? i think it should be the default
23:39:16 <dysfun> controversial*
23:39:32 <Lokathor> dysfun, if i had to guess, it might make error messages a whole lot worse in the common case
23:39:52 <dysfun> this post is written from the perspective of a beginner, so it's plausible
23:41:26 <[Leary]> Is there a recommended reading for Traversable?
23:41:29 <Lokathor> i've only wanted a multi param typeclass like 3 or 4 times in two years, and only actually used it once I think
23:41:53 <dysfun> i don't write that much haskell any more, but i do use them a lot
23:42:49 <Lokathor> [Leary], Haskell Programming From First Principles covers it quite well, if you've got that book
23:44:41 <shamrock> Is there a reason `++` is right associative?
23:45:39 <[Leary]> I don't, Lokathor---and I'm too cheap to rectify that.
23:46:26 <dysfun> probably you can learn something about traversable by playing with SYB or uniplate or similar
23:47:51 <olligobber> my haskell netcode let me bind to port 0...
23:48:03 <geekosaur> shamrock, possibly efficiency, it'd have to traverse the ever-growing left side
23:48:24 <dysfun> olligobber: that requests an unused port most likely
23:48:30 <geekosaur> olligobber, that's a convention to get the next ephemeral port. often used when random programs want to have a 'private' conversation
23:48:43 <geekosaur> (where they alone know the server port)
23:48:45 <cocreature> dysfun: not really, uniplate doesnâ€™t quite fit Traversable
23:48:54 <Profpatsch> I have a thing, where I want the user to do some setup of my library at some time.
23:48:55 <dysfun> cocreature: ah, pity
23:49:06 <olligobber> I should probably print the port that actually gets used then...
23:49:17 <dysfun> an excellent idea
23:49:18 <Profpatsch> And return some kind of token after the setup, which can be used afterwards to do the real thing.
23:49:47 <Profpatsch> So the user can put the initialization at the beginning of her program and use the initialized bit afterwards.
23:50:19 <dysfun> can't you just provide a function which constructs some datatype?
23:50:35 <Profpatsch> Thing is I have a bunch of different initializations where each is returning different tokens and it feels kind of dirty to write.
23:51:01 <Profpatsch> initializeFoo :: IO FooToken; initializeBar :: IO BarToken; â€¦
23:51:58 <Profpatsch> But I canâ€™t think of any simple abstraction over that which doesnâ€™t involve drifting into type-level magic.
23:52:29 <Profpatsch> e.g. something like
23:52:30 <dysfun> why can't you do that with an ordinary typeclass?
23:52:54 <Profpatsch> data Foo
23:52:56 <cocreature> what are you hoping to gain from an abstraction? as long as the only shared thing between this tokens is that they can be initialized, Iâ€™d say donâ€™t bother
23:53:06 <Profpatsch> Yeah, maybe.
23:53:21 <Profpatsch> Not really much to be gained anyway.
23:54:15 <glguy_> [Leary]: search for The Essence of the Iterator
23:54:44 <dysfun> glguy_: this? http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
23:55:12 <glguy_> Yes
