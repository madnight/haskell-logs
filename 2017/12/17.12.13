00:01:30 <quchen> raduom: https://github.com/raduom/ubb-map/compare/master...quchen:patch-1
00:05:43 <raduom> quchen: thanks a lot. very sensible comments. i'll update. about needing the flexibility, I was trying to learn how to make things flexible, but I am aware of the cost of complexity that is introduced by the Has.. classes. However the exercise was on how to use those and combine them with final encodings.
00:06:44 <quchen> raduom: Yup, for this example it probably makes sense.
00:06:45 <raduom> quchen: again, thanks a lot. i will switch to abusing do notation. writing with >>= is more useful for me since I am trying to learn how things work, but if i show it to someone they might not get it :)
00:07:21 <raduom> quchen: I will comment the >>= version and put a do notation version as well. that should keep everyone happy.
00:07:23 <quchen> raduom: GHC is fairly smart, so the super-tight >>= <$> chains will usually compile to the same code that verbose do-notation gives you
00:07:54 <quchen> Always go for clarity unless you have good reason not to :-)
00:07:59 <quchen> Good code in general btw.
00:08:12 <quchen> Oh, and remember that print = putStrLn . show.
00:08:21 <quchen> That’s why you have all the quotation marks in your output.
00:08:28 <Rembane> Doesn't do-notation desugar to >>= which means that they are the same?
00:08:30 <quchen> (…presumably, I didn’t run nor typecheck the code.)
00:08:48 <quchen> Rembane: To the compiler they are (almost) the same, to me as a reader not so much.
00:08:53 <raduom> quchen: yeah. it was not about performance, it was about getting used to the Haskell syntax and abstractions. I will make clarity a default and leave the >>= notation in case someone likes a puzzle or some exercise.
00:09:28 <quchen> raduom: Some code is easier to read with >>=.
00:09:45 <quchen> So yes, make clarity the default, but the default is not always do-notation.
00:09:53 <raduom> quchen: yes but leaving both version will help everyone.
00:10:08 <Rembane> quchen: Indeed, since people contrary to popular belief aren't compilers. 
00:10:22 <Rembane> quchen: I do agree with you to 100% about clarity.
00:20:50 <Axman6> Rembane: there's no reason for readGuess to be in the StateT monad, it doesn't use State at all - it should just be in IO and use liftIO in the call site
00:21:05 <Axman6> uh, raduom
00:21:48 <hs_newb> hello, how do you explore a new library? For e.g. in Ocaml i read the mli files 
00:21:56 <Axman6> also many of your liftIO calls can be merged - if you have liftIO $ ...; liftIO $ ... then it can also be liftIO $ do ...; ...
00:22:04 <koz_> hs_newb: Hackage docs.
00:22:09 <Axman6> hs_newb: look at the documentation on hackage
00:22:13 <hs_newb> is there a way i can geenrate them locally?
00:22:22 <raduom> Axman6: good points. thanks.
00:22:23 <Axman6> yes, using haddock
00:23:20 <Axman6> hackage has the advantage of being indexed by google though ;)
00:24:09 <hs_newb> Axman6: yeah true, but i need it for when i have no internet connection
00:24:22 <hs_newb> thanks i will use stack haddock for this :)
00:25:52 * hackage path-text-utf8 0.0.1.0 - Read and write UTF-8 text files  https://hackage.haskell.org/package/path-text-utf8-0.0.1.0 (chris_martin)
00:26:13 <Axman6> raduom: things like playGame can shortened by using maybe: playGame = nextPlayer >>= maybe selectWinner (\p -> makeNextGuess p >> playGame)
00:27:09 <Axman6> hackage: yeah stack haddock will do the trick - it'll probably tell you the location of a few different html files, I think you want the last one. also I think stack haddock --open will open the index in your browser
00:31:09 <Axman6> raduom: also I believe findM is already defined in Control.Monad
00:31:23 <Axman6> (possibly over any traversable or foldable)
00:31:26 <Axman6> :t findM
00:31:27 <lambdabot> error:
00:31:27 <lambdabot>     • Variable not in scope: findM
00:31:27 <lambdabot>     • Perhaps you meant one of these:
00:31:31 <Axman6> hmm
00:31:39 <Axman6> @hoogle findM
00:31:39 <lambdabot> Data.Vector.Fusion.Bundle.Monadic findM :: Monad m => (a -> m Bool) -> Bundle m v a -> m (Maybe a)
00:31:40 <lambdabot> Data.Vector.Fusion.Stream.Monadic findM :: Monad m => (a -> m Bool) -> Stream m a -> m (Maybe a)
00:31:40 <lambdabot> Control.Monad.Extra findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
00:31:40 <raduom> it's in control.extra or something.
00:31:58 <Axman6> hmmm, weird, there's definitely something
00:32:04 <raduom> i don't want to import that package just for the findM, and it felt like a good exercise to write it.
00:32:43 <Axman6> I could've sworn there was one in Control.Monad
00:33:04 <Axman6> but seems not - there's filterM, which gives you this...
00:33:20 <Axman6> > filterM (const [False,True]) [1..4]
00:33:22 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2...
00:34:19 <Axman6> > filterM (const [True,False]) [1..4]
00:34:21 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
00:34:56 <Axman6> aka, powerset
00:38:16 <ohdamnboi> hi, my notepad++ stopped working while editing my haskell script which was loaded in WinHugs. It overwrote the whole script with an empty file. Is there some way to extract it out of WinHugs?
00:39:52 * hackage network-voicetext 0.0.0.1 - VoiceText Web API wrapper  https://hackage.haskell.org/package/network-voicetext-0.0.0.1 (zaneli)
00:40:20 <quchen> ohdamnboi: If you’re not using version control, then this might be a good point to learn about it. :-)
00:40:52 <quchen> I don’t think Hugs can give you the source of the loaded program.
00:41:10 <ohdamnboi> do you know of any other way I could be able to recover the program?
00:41:18 <ggVGc> or a text editor with swap files, like vim
00:41:25 <ohdamnboi> ffs i worked 4 hrs on it
00:41:28 <ggVGc> ohdamnboi: I think you're out of luck tbh...
00:42:10 <quchen> 4 hours?? Version control, now.
00:42:33 <ohdamnboi> well idk man I always had to save the script when reloading in winhugs
00:42:37 <ohdamnboi> so i saved it
00:42:41 <quchen> Install Git, spend the next hour reading about its basic commands.
00:42:42 <ohdamnboi> then np++ crashed
00:42:45 <ggVGc> ohdamnboi: the only way I can think of is to see if notepad++ keeps swap or cache files(which I don't think it does). Or if you stop using your computer right now and see if you can do a full file recovery scan, but I doubt that would work since it was the same file that was overwritten, so it's highly likely it overwrote the same part of the dis
00:42:46 <ohdamnboi> I know git
00:42:50 <ggVGc> disk*
00:47:44 <hs_newb> ohdamnboi: time to use an editor that actually does its job :)
00:47:52 * hackage constraint 0.1.1.0 - Reified constraints  https://hackage.haskell.org/package/constraint-0.1.1.0 (MatthewFarkasDyck)
00:51:22 <max2> hi
01:05:41 <babsklr> hello everyone
01:06:23 * hackage repa-scalar 4.2.3.2 - Scalar data types and conversions.  https://hackage.haskell.org/package/repa-scalar-4.2.3.2 (BenLippmeier)
01:09:52 * hackage repa-convert 4.2.3.2 - Packing and unpacking flat tables.  https://hackage.haskell.org/package/repa-convert-4.2.3.2 (BenLippmeier)
01:13:42 <muzzle> b
01:37:20 <saurabhnanda> are there any good exercise problems that demonstrate the use of tuples and why the exist in the language?
01:38:39 <Logio> saurabhnanda: anything using zip, perhaps?
01:39:33 <martinmch> saurabhnanda: http://learnyouahaskell.com/starting-out#tuples
01:41:03 <quchen> Any program using more than a single value? :-s
01:41:26 <quchen> Return the index and the found value from a search function
01:41:43 <saurabhnanda> martinmch: thanks for that. I'm trying to come up with a problem which cannot be solved by any other data structure. To reinforce the the text that http://learnyouahaskell.com/starting-out#tuples explains. And to also give the reader a sense of when they should use tuples in while designing their own solutions.
01:41:48 <quchen> A function taking two arguments
01:42:25 <Logio> saurabhnanda: Any tuple could in principle be replaced by a specific product type
01:42:35 <quchen> This shouldn’t be hard to explain even to non-Haskell people, OOP classes are tuples of variables and functions so it’s not a new concept to most
01:42:40 <quchen> sum types on the other hand are
01:42:42 <saurabhnanda> Logio: true, but at this point they haven't been introduced to ADTs.
01:42:58 <quchen> A struct is also a tuple
01:43:08 <quchen> I don’t think I know a non-esoteric language without tuples to be honest
01:43:25 <saurabhnanda> quchen: think about people coming from Ruby and JS where lists are king.
01:43:47 <quchen> Well, in those languages lists are really something between arrays and tuples
01:43:49 <Logio> saurabhnanda: it might be good to make a point of the types then
01:43:57 <saurabhnanda> quchen: your double negation confused me :)
01:44:03 <martinmch> saurabhnanda: Alright, thought you just wanted to learn more about tuples :-)
01:44:07 * hackage language-docker 1.0.0 - Dockerfile parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-docker-1.0.0 (lorenzo)
01:44:09 <Logio> since in Haskell lists cannot have multiple types, you _must_ use tuples 
01:44:23 <quchen> saurabhnanda: »All languages have tuples« – better? :-)
01:44:39 <boj> python seems pretty tuple friendly
01:44:42 <saurabhnanda> Logio: Exactly! Searching for a real-world problem that is best solved with tuples. Non-mathematical problem.
01:44:45 <sepakorayl> hello guys, does anyone know how I can make Strings to work with the sigletons library ?
01:44:57 <Logio> saurabhnanda: returning multiple values is the easy one
01:45:21 <quchen> saurabhnanda: findWithIndex :: (a -> Bool) -> [a] -> Maybe (Int, a)
01:45:44 <quchen> enumerate :: [a] -> [(Int, a)]
01:46:08 <saurabhnanda> yes, using "maps" like this might be a good idea...
01:46:11 <quchen> (read, write) <- openConnection "foobar.baz"
01:46:34 <quchen> withSocket (\(addr, handle) -> …)
01:49:25 <quchen> saurabhnanda: Tuples are really the »plain collection of multiple things«, just like Bool is the »plain thing with two values«, where with »plain« I mean »doesn’t convey any meaning beyond its structure«.
01:49:42 <quchen> A tuple of two things doesn’t tell me anything about its contents, just that there are multiple things.
01:49:50 <quchen> True does not mean anything either.
01:50:02 <quchen> Either sometimes, but not necessarily, stands for success and failure.
01:50:59 <quchen> A game state is a collection of values, usually a tuple at the outermost level: whose turn it is, how many points player 1 has, …
01:52:09 <boj> overexplaining to a ruby programmer who adopted haskell and is now trying to write a book on haskell "without theory"
01:52:58 <boj> i know i am beng offensive, so i do apologize. saurabhnanda rubs me the wrong way
01:53:31 <saurabhnanda> boj: I don't take things too personally. you have the right to cause offense. btw have we ever gotten into a flamewar?
01:53:46 <quchen> Let’s not.
01:54:42 <boj> saurabhnanda: no, and for the record i do appreciate your persistence in understanding this ecosystem
01:55:16 <boj> my only complaint is your tone
01:55:41 <quchen> I didn’t think there was anything wrong with the tone.
01:56:08 <boj> sorry, i've been observing him for over a year and have formed a strong opinion. i'll back off
01:56:24 <s4ke> so. we have the monadic (>>=) :: m a -> (a -> m b) -> m b. Then we have the Kleisli type: Kleisli m a b = Kleisli { runKleisli :: a -> m b }. NOw we could rewrite (>>=) into something like this: (>>=') :: m a -> Kleisli m a b -> m b. Now I state that since we can not express (>>=') with generic Arrows, one can see that Arrows must be a generalisation of Monads. Is this correct, or should I say it's more of an intuition for
01:57:04 <merijn> s4ke: Arrows are not a generalisation of monad
01:57:14 <s4ke1> i don't know whether my stuff got sent
01:57:15 <s4ke1>  so. we have the monadic (>>=) :: m a -> (a -> m b) -> m b. Then we have the Kleisli type: Kleisli m a b = Kleisli { runKleisli :: a -> m b }. NOw we could rewrite (>>=) into something like this: (>>=') :: m a -> Kleisli m a b -> m b. Now I state that since we can not express (>>=') with generic Arrows, one can see that Arrows must be a generalisation of Monads. Is this correct, or should I say it's more of an intuition for the fact?
01:57:19 <s4ke1> spotty internet
01:58:03 <merijn> s4ke1: You are correct in observing that functions "a -> m b" where 'm' is a Monad are arrows, but that's not a result of Arrows being a generalisation of monads
01:58:19 <s4ke1> merijn: according to John Hughes they are
01:58:27 <merijn> s4ke1: That's more a result of Arrows being somewhat like a generalisation of functions
01:58:33 <merijn> s4ke1: Really? Where?
01:58:54 <s4ke1> in his paper http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf
01:59:09 <merijn> s4ke1: Arrow (the Haskell typeclass) is a generalisation of the monad typeclass, but arrows in a category theoretic sense are not
01:59:36 <s4ke1> Also: Any Arrow that has an ArrowApply instance is equal to a Monad in terms of expressive power
01:59:37 <merijn> s4ke1: And actually, the Arrow typeclass is widely considered rather flawed and has fallen mostly into disuse
02:00:00 <merijn> s4ke1: Yeah, but ArrowApply is rather limited compared to just Arrow.
02:00:35 <merijn> s4ke1: Although, pragmatically I would probably just not bother spending too much time thinking about Arrow (the typeclass) since it's mostly been obsoleted by more succesfull abstractions
02:01:41 <s4ke1> what alternatives are there? 
02:02:16 <merijn> s4ke1: Applicative, Category, and Profunctor take over various functions of Arrow
02:04:09 <merijn> s4ke1: Applicative and Profunctor were with both invented after Arrow, yet both are used a ton more than Arrow (in fact, I only know of 2-3 libraries using arrows, and those aren't even all that popular)
02:04:11 <osa1> interesting, `stack new` now generates a hpack file by default
02:04:34 <osa1> I guess it's time I finally switch over to hpack
02:04:38 <s4ke1> Hmm. merijn: okay. well for my abstraction i think arrows still are quite a sane thing to use as i am modelling parallel computations in the sense computation pipes
02:04:52 <merijn> s4ke1: Have you looked at Category?
02:04:53 <s4ke1> do you think that there is a better suited thing?
02:05:01 <s4ke1> merijn: i require ArrowChoice
02:05:05 <s4ke1> and ArrowLoop
02:05:17 <s4ke1> dunno whether that's a problem tbh
02:05:40 <s4ke1> i distinctively do not require ArrowApply
02:06:08 <merijn> I think you can probably implement those using other abstractions, but I don't really know the details of what you need and how best to tackle that
02:08:00 <s4ke1> merijn: looking at the profunctor documentation i can define my api with profunctors only as well
02:08:02 <s4ke1> welp
02:09:14 <merijn> s4ke1: I would say Profunctor definitely has a brighter future than Arrow, so that'd probably be a better choice
02:09:37 <merijn> s4ke1: Since all of lens is build on top of it and it's getting picked up elsewhere too
02:10:15 <merijn> So, assuming the API would be equally easy with both, I'd go with that
02:10:33 <s4ke1> merijn: okay. I guess I won't rewrite my Arrow library/paper, but add a section that talks about the future...
02:10:52 <s4ke1> merijn: looking at the API i think i could easily just add an abstraction layer on top
02:10:57 <s4ke1> (i dont want to do that)
02:12:27 <merijn> s4ke1: Ah, the academic trouble of not having time to update your code to have a saner API :)
02:12:44 <s4ke1> or maybe i could? i mean any profunctor that is also CoStrong and CoChoice should be able to be made an Arrow
02:13:26 <s4ke1> merijn: believe my, i have been down that rabbit hole since 2 weeks now
02:13:32 <s4ke1> i wanted to finish that paper for a long time now
02:17:22 * hackage docker-build-cacher 1.8.2 - Builds a services with docker and caches all of its intermediate stages  https://hackage.haskell.org/package/docker-build-cacher-1.8.2 (lorenzo)
02:18:57 <s4ke1> merijn: i guess that Profunctor tutorial i stumbled upon is wrong "make someone see Profunctors everywhere and he will hate you"
02:18:59 <s4ke1> or something
02:20:41 <merijn> s4ke1: Depends on whether their language is powerful enough to implement Profunctor ;)
02:21:13 <s4ke1> he/she
02:25:52 * hackage mmark 0.0.2.1 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.2.1 (mrkkrp)
02:32:29 <s4ke1> merijn: i think i can salvage my API though. I really need composition so I require for Category, Profunctor Choice and Costrong
02:33:32 <s4ke1> I think I can re-express things with these, but thinking about computations as Arrows is still a good idea though
02:33:48 <s4ke1> i will just have to reimplement some operators, but apart from that I think I can keep most of my code
02:34:27 <Average-user> Someone who did day 13?
02:35:01 <s4ke1> merijn: so i think i will create my own typeclass... i guess something along the lines of  class ParallelArrow where ... so i can define all the operations i require
02:35:41 <s4ke1> i can use that from the arrow side of things and from the Profunctor side of things
02:41:43 <s4ke1> merijn: i guess that's a follow up paper though :D
02:50:19 <merijn> s4ke1: Score ;)
02:50:49 <s4ke1> merijn: but I think i will mention that it's easily implemented, working on a draft for a class, sec
02:51:48 <s4ke1> nvm: Strong + Category = Arrow
02:52:00 <s4ke1> :D
02:52:10 <s4ke1> and now to make a sane interface for that :D
02:53:00 <s4ke1> merijn: i guess i have found the reason so many libraries define their own typeclasses
02:53:14 <s4ke1> if i would have done that, that would have been an easy fix...
02:53:39 <s4ke1> thanks for the tips though. back to my original question :D
02:53:44 <s4ke1> you still remember it?
02:54:24 <merijn> The only one I remember was whether arrow was a generalisation of monad :)
02:54:32 <s4ke1> yes that one
02:54:44 <s4ke1> did you take a look at the paper?
02:55:17 <merijn> s4ke1: No, but if it was Hughes it's probably the "Generalising Monads to Arrows" which I dead read a few years ago :p
02:55:56 <s4ke1> merijn: yes its the one
02:56:05 <sphinxo> why might I be getting this macro error? http://lpaste.net/2458703583927861248
02:56:24 <sphinxo> code: https://github.com/haskell-compat/mtl-compat/blob/master/src/Control/Monad/Except.hs#L73
02:56:36 <merijn> s4ke1: Like I said, I think it's true for Arrow the class, but definitely not for Arrow the mathematical abstraction
02:56:54 <sphinxo> I need to link against cabal macros?
02:56:56 <s4ke1> merijn: what's the difference ?
02:57:02 <sphinxo> cabal_macros.h file
02:57:14 <merijn> sphinxo: Yes
02:57:21 <merijn> sphinxo: Normally cabal passes in all the relevant macros
02:57:40 <merijn> sphinxo: If you're not compiling via cabal you'll have to do that manually
02:57:41 <yen> aish, is anyone online to help me with MVars quickly
02:57:44 <yen> ?
02:58:36 <yen> I need to know why my associate function (https://github.com/hvze/Refract/blob/master/src/Refract/Bus.hs) doesn't update the MVar, yet while testing MVars in GHCI, they update just fine.
02:58:39 <merijn> s4ke1: arrows in category are much more like values of type "Category cat => cat a b" (hell, that's why we have the Category class) :)
02:59:35 <s4ke1> merijn: hmm okay. then i think i will keep to the original Arrow definition from hughes in my paper, that's sane as well, if not 100% correct
02:59:41 <merijn> yen: Which code is supposed to update the MVar?
03:00:21 <yen> operate
03:00:27 <yen> and associate calls operate that modifies the inner bus
03:00:44 <yen> or is it because I'm doing some foolery with IO ?
03:01:39 <merijn> yen: Those are not called in the code you linked
03:02:00 <yen> huh?
03:02:05 <yen> oh oh
03:02:10 <yen> those are the sources
03:02:14 <yen> https://github.com/hvze/Refract/blob/master/test/SimpleEventTest.hs
03:02:16 <yen> they are called here
03:04:38 <merijn> hold on...
03:04:48 <yen> thank you so much.
03:04:54 <merijn> oh, I read the type wrong :)
03:05:04 <yen> ah, yeah its so complex !!
03:05:10 <merijn> yen: oh, duh...
03:05:22 <merijn> yen: You are passing in an "IO (MVar Bus)" to all functions
03:05:29 <merijn> yen: So you are making a new Bus everytime
03:05:33 <yen> oh shit.
03:05:37 <yen> wait really ??
03:05:38 <yen> omg
03:05:46 <merijn> yen: Yes
03:05:49 <yen> oH RIGHT BECAUSE
03:05:51 <yen> the io means action
03:05:52 <yen> ok
03:06:05 <merijn> yen: You wanna change associate, etc. to just take an "MVar Bus"
03:06:26 <yen> can I remove the a and f?
03:06:35 <yen> so just (MVar Bus) instead of (MVar Bus a f) ?
03:06:43 <merijn> "operate fn bus = bus >>= ..." <- here  bus creates a new mvar
03:06:48 <sphinxo> is it possible to get a list of all the haskell source files in a library with ghc-pkg?
03:06:55 <s4ke1> merijn: this looks better: http://lpaste.net/360748
03:07:01 <merijn> yen: No, I'm just too lazy to check and type the arguments for Bus :)
03:07:05 <yen> ah ok
03:07:05 <s4ke1> i still get to keep (>>>)
03:07:07 <yen> thank you sm
03:08:16 <ohdamnboi> idk if anyone remembers me but i rewrote the haskell script in 1,5h :^(
03:08:47 <yen> ?
03:09:20 <ohdamnboi> my notepad++ froze up and overwrote my haskell script with an empty file lol, yen 
03:09:28 <s4ke1> merijn: i guess that interface allows for even more reusability of my library which is nice
03:09:58 <yen> christ
03:13:33 <yen> does anyone know if there is any way to have multiple test cases for a suite?
03:20:22 * hackage extrapolate 0.3.0 - generalize counter-examples of test properties  https://hackage.haskell.org/package/extrapolate-0.3.0 (rudymatela)
03:22:47 <osa1> it'd be great to have a "+" symbol next to re-exported modules in haddock to expand to module contents
03:24:15 <yen> does anyone know if there is any way to have multiple test cases for a suite?
03:24:17 <yen> oops
03:34:22 * hackage d-bus 0.1.8 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.8 (PhilippBalzarek)
03:41:15 <merijn> osa1: It's in the works already
03:42:02 <merijn> osa1: I was talking to some of the guys working on Haddock, the problem was that in the past the exports were all determined textually. Future versions will go via GHC, which will allow more accurate re-exports listings, so it's coming
03:46:28 <osa1> merijn: awesome! is there a Github issue that I can subscribe to to get updates on this?
03:46:51 <merijn> osa1: Maybe?
03:48:40 <Athas> merijn: people are working actively on Haddock again?
03:49:06 <merijn> Athas: Since there've been a bunch of changes in the past year, probably?
03:49:13 <Athas> Great!
03:52:22 <Axman6> any plans to add markdown (and all the pandoc fun) to the syntax haddock understands for comments?
03:52:37 <merijn> Axman6: Markdown has been shot down a bunch of times
03:52:40 <geekosaur> it's been discussed. it has conflicts
03:52:41 <merijn> So, no
03:53:34 <Athas> I think RST would be a better fit, as it's more extensible.  It would allow you to distinguish the namespace of what you are referring.
03:53:43 <Athas> I.e. :module:`Foo` versus :type:`Foo`.
03:55:41 <Axman6> I remember seeing someone give it a go by annotating the comment with md: -- |md ...
03:58:48 <Athas> How does that solve namespace ambiguities?
03:59:14 <Axman6> it doesn't, it solves haddock's syntax being weird
03:59:19 <sgronblo> I thought I was clever by using guard in a monadic State computation, then I noticed that State is StateT with Identity which doesn't have a MonadPlus instance...
04:01:26 <Axman6> > pi^9/(exp 1)^8 :: CReal
04:01:28 <lambdabot>  9.9998387978048801818832774568126373759359
04:02:15 <Axman6> > 10 - pi^9/(exp 1)^8 :: CReal
04:02:17 <lambdabot>  0.0001612021951198181167225431873626240641
04:02:59 <sgronblo> I'm guessing guard needs MonadPlus so that it can get the value that would break the chain of computations in case you pass False to it...
04:04:20 <Axman6> :t guard
04:04:21 <lambdabot> Alternative f => Bool -> f ()
04:04:44 <merijn> sgronblo: Well, what's guard supposed to do when the condition is false?
04:05:08 <merijn> sgronblo: In other words, what would mzero/empty be for State?
04:05:13 <merijn> :t Control.Applicative.empty
04:05:15 <lambdabot> Alternative f => f a
04:06:49 <Taneb> sgronblo: maybe what you want is "when" (or "unless")
04:06:53 <Taneb> :t [when, unless]
04:06:55 <lambdabot> Applicative f => [Bool -> f () -> f ()]
04:12:04 <ph88> why do haskell web frameworks perform very poorly in https://www.techempower.com/benchmarks/#section=data-r14 ? is it inherit to haskell itself ?
04:14:52 * hackage hpack 0.21.2 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.21.2 (SimonHengel)
04:15:47 <boj> ph88: because we're busy writing production code instead of proving meaningless micro-benchmarks
04:16:31 <boj> or to be fair, learning haskell. there are a lot of academic oriented people here
04:16:42 <boj> (teaching haskell?!)
04:19:49 <liste> ph88: some benchmarks I saw had very naive haskell code
04:20:16 <oherrala> and really old versions
04:20:43 <oherrala> stackage lts-6.3
04:20:51 <ph88> liste, like what naive code ?
04:22:23 <liste> ph88: https://www.reddit.com/r/haskell/comments/6b3dlt/techempower_benchmarks_14_released_with_servant/dhl500h/
04:25:01 <boj> ph88: do you truly care about perforfmance and scale? meaning, are we talking about 500k DAU? because at that point your language choise starts to disappear very quickly and falls heavily on the shoulders of your devops/sre team
04:26:10 <tdammers> apart from that, the only useful benchmarks I'd consider would have to include programmer workload estimates
04:27:34 <tdammers> because the situation is never "can we get webscale performance out of this without doing any work" (because the answer is always "no"), nor "how fast can we make this framework if we spend infinite time and money on it, and correctness is not a concern"
04:28:04 <tdammers> you are always on a time budget, a money budget, and there is always a "good enough" performance level
04:28:30 <quchen> Likewise, there is always a »good enough« correctness level.
04:28:37 <tdammers> true
04:28:48 <tdammers> which is the main reason PHP is still a thing
04:29:24 <quchen> There is no »not good enough« level there.
04:29:26 <boj> servers will always scale faster and cheaper. it's better to focus on writing correct code
04:29:32 <quchen> It parses, ship it!
04:30:17 <tdammers> boj: you can't just handwaive performance by invoking Moore's Law though
04:30:22 * hackage pandoc-crossref 0.3.0.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.0.0 (lierdakil)
04:30:41 <drdo> tdammers: Watch me!
04:31:13 <tdammers> particularly because while hardware performance seems to keep scaling exponentially, the "how" has taken a few unexpected turns in the past decades, and they have changed the way we write software
04:31:27 <boj> tdammers: i am not. i have shipped incredibly terrible python code at scale (japanese social games) as a devops. i cringed every single day, but the sad truth is that 2
04:31:31 <ph88> boj, yes i care because i want to write haskell and i don't like it to be on ruby speed
04:31:40 <boj> "if it works for the players, good enough"
04:31:50 <tdammers> boj: oh, right, yes
04:32:08 <drdo> What kind of performance are you guys talking about anyway?
04:32:12 <drdo> latency?
04:32:56 <boj> i suppose ai am saying, "making optimal haskell code to beat a micro-benchmark for web services" really doesn't mean anything. let's focus on what we really get out of it, less bugs and better refactoring
04:33:01 <alp> liste, naive?
04:33:50 <liste> alp: well not naive in this case, the Haskell benchmark program just does a different thing than the other benchmarks - see my link
04:33:52 <tdammers> comparing performance does make sense
04:33:56 <tdammers> just not like this
04:34:08 <boj> and hey if someone wants to optimize a benchmark props to them, they make us look evey that much better
04:34:48 <tdammers> you have to compare solutions that solve the same problem (for a reasonably exact and functional definition of "same"), and require the same amount of programmer effort to write
04:35:13 <infinisil> @pl l x = fmap ($ l x) x
04:35:13 <lambdabot> l = fix (fmap . flip id =<<)
04:35:32 <alp> liste, yeah I remember this (I'm a servant dev and saw jkarni work on those benchmarks as it happened), and we'd have to break an RFC to look better, and for us it was a fine line to stop at. do you disagree? (I'm not suggesting anything here, it's a genuine question)
04:36:34 <tdammers> and obviously the solutions would all have to be bug free, because otherwise we would have to insist that they all have the same bugs, and that would have us end up comparing bug emulation performance (as is actually the case right now with servant trying to emulate content type bugs in other frameworks)
04:36:59 <liste> alp: I think the right thing to do would for the other benchmark programs to conform to the RFC
04:37:19 <alp> right, I agree with that more than you can imagine =)
04:37:36 <alp> but they don't care, because people just look at the numbers
04:37:52 <alp> even though on the reddit thread, many people seemed to be fine with us drawing the line where we drew it
04:38:15 <tdammers> realistically, you would have to spec a complete web application, and have a team of experienced professionals develop a solution on a realistic budget for each framework, and then benchmark those
04:38:37 <boj> tdammers: you are already past reality :)
04:38:51 <tdammers> or, alternatively, spec the minimum acceptable performance, and measure how much budget they blow through until they meet the correctness, performance, and quality requirements
04:39:52 <tdammers> alp: personally, I think drawing the line at "the others are violating RFC's, so this isn't a meaningful benchmark anymore" would have been acceptable already
04:40:12 <alp> and this is not to say that servant's performance is optimal by any metric, of course. it's not. but it can certainly handle serious workloads and in fact mostly relies on the performance of warp and the RTS.
04:40:43 <tdammers> statistically speaking, nobody needs optimal performance
04:40:52 <alp> besides routing, we don't do much really
04:40:53 <boj> not one bit
04:41:09 <tdammers> otherwise microkernel deployment would have become mainstream long ago
04:42:01 <boj> i say it with a sad heart, i've had more useless performance conversations that were truly down to heart and amazing technical and awesome to date, that had little basis in reality
04:42:49 <fakenullie> Isn't microkernel less efficient
04:42:59 <boj> "yes, optimizing this inner makes perfect sense... for your bleeding engineer heart."
04:43:14 <boj> inner loo*
04:43:58 <tdammers> fakenullie: as long as we're talking raw performance, microkernels are about as good as it gets
04:44:33 <alp> tdammers, right :) one somewhat useful thing Julian noticed though is that database libraries ended up being bottlenecks :)
04:44:43 <drdo> You should totally destroy your program's understandability to save that one byte in that one structure
04:45:06 <tdammers> the idea is that you compile the entire web application into one monolithic binary, and then, if you want to go crazy, you could even full-program-optimize the entire thing, down to device drivers and worker thread scheduling and all that
04:45:07 <boj> alp: a nice place to have a bottleneck!
04:45:27 <tdammers> you could basically inline your web app logic into syscalls :O
04:45:51 <fakenullie> There was web server implemented as a Linux kernel module
04:45:52 * hackage haskell-lsp-client 1.0.0.0 - A haskell package to build your own Language Server client.  https://hackage.haskell.org/package/haskell-lsp-client-1.0.0.0 (JaroReinders)
04:46:02 <alp> yeah, and do RDMA to transmit data while you're at it
04:46:37 <tdammers> fakenullie: there are web frameworks that produce deployable kernel images as build output, e.g. OCaml's MirageOS
04:47:11 * tdammers just realized he originally said "microkernel" not "unikernel"
04:48:24 <fakenullie> Interesting. Also ocsml
04:49:16 <boj> galois has been working hard on halvm (3?)
04:49:22 * hackage hruby 0.3.5 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.5 (SimonMarechal)
04:49:22 <fakenullie> Ocaml to js compiler claims to prodece compact, efficient and readable is
05:00:53 * hackage purescript-bridge 0.11.1.2, servant-purescript 0.9.0.2 (eskimo): https://qbin.io/qbarqg4w
05:15:36 <qmm> is there a way to ask ghc if a language extension is being used within a module?
05:19:10 <merijn> qmm: What are you trying to accomplish with that?
05:20:17 <phadej> if you want to remove unneeded pragmas, then, no in general
05:20:35 <phadej> some pragmas affect things in a way, that to be 100% sure, one need to type-check with pragma disabled
05:24:30 <tabaqui> it looks like we should never write "IO a" functions, but "(MonadIO m) => m a"
05:24:58 <tabaqui> I cannot see any flaws here
05:34:52 * hackage streaming-bytestring 0.1.5 - effectful byte steams, or: bytestring io done right.  https://hackage.haskell.org/package/streaming-bytestring-0.1.5 (andrewthad)
05:36:45 <cthulhu`> tabaqui: There's also not much benefit, as one can use `liftIO` in call site
05:37:02 <cthulhu`> tabaqui: That is, as long as your `IO a` is in positive position
05:40:03 <tabaqui> yeah, if function is called frequently in monad stack, you can write one liftIO instead of many plus you gain more general signature
05:40:16 <merijn> You can also lift entire blocks
05:40:38 <merijn> "liftIO $ do { bunch of IO actions here }"
05:41:58 <quchen> > let f = const False in let f !y = y in f True -- True iff BangPatterns is enabled, merijn qmm ;-)
05:41:59 <tabaqui> right, and redundant liftIO inside of the block doesn't interfere
05:42:00 <lambdabot>  True
05:59:22 * hackage language-puppet 1.3.13 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3.13 (SimonMarechal)
06:33:02 <benzrf> oh man that's sneaky
07:10:38 <tabaqui> I'm playing with optparse-applicative-0.14.0.0
07:10:51 <tabaqui> what's the difference between hidden and internal modifiers?
07:11:06 <tabaqui> both of them hide parameter from fullDesc and briefDesc
07:11:23 <tabaqui> *hides
07:22:52 * hackage cyclotomic 0.5.0.0 - A subfield of the complex numbers for exact calculation.  https://hackage.haskell.org/package/cyclotomic-0.5.0.0 (ScottWalck)
07:26:23 * hackage engine-io-wai 1.0.7 - An @engine-io@ @ServerAPI@ that is compatible with @Wai@  https://hackage.haskell.org/package/engine-io-wai-1.0.7 (codedmart)
07:28:28 <fakenullie> what's wai
07:28:39 <liste> fakenullie: the web app interface
07:29:01 <fakenullie> like wsgi in python?
07:29:02 <liste> it's one way for web apps and web server to interact
07:29:05 <liste> yes, pretty much
07:41:57 <michalrus> Is mempty ≠ empty at any time?
07:42:28 <michalrus> (From Monoid and Alternative.)
07:42:52 * hackage rattletrap 3.1.1 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-3.1.1 (fozworth)
07:43:05 <fakenullie> :i empty
07:44:17 <merijn> michalrus: Yes
07:45:48 <merijn> Actually, my counter-example isn't right, but there's still no requirement for them to line up
07:47:21 <michalrus> Yes, no requirement in types, but I was just wondering if maybe there should/could be. :P
07:47:43 <michalrus> I.e. when does it make sense for them to be different.
07:55:23 <tabaqui> michalrus: easy, just define some stupid Alternative instance for natural numbers
07:55:39 <tabaqui> like <|> = max
07:55:43 <tabaqui> empty = -inf
07:55:54 <michalrus> Oh! Wonderful. :] Thank you!
07:55:55 <tabaqui> and use (N, +) as monoid
07:56:32 <AndreasPK_> But then -inf + 1 should be -inf
07:56:41 <AndreasPK_> So not an identity of <|> ?
07:56:55 <tabaqui> nope
07:56:59 <tabaqui> -inf <|> 1 = 1
07:57:02 <alp> michalrus, for semirings in general, modulo the fact that it doesn't necessarily typecheck, you do have two different neutral elements
07:57:09 <alp> see e.g http://r6.ca/blog/20110808T035622Z.html
07:57:26 <tabaqui> actually, I didn't check some and many, dunno
07:57:31 <merijn> michalrus, tabaqui: That doesn't make sense
07:57:37 <michalrus> alp: thank you, too!
07:57:43 <merijn> You can't define an Alternative instance for numbers
07:57:49 <merijn> The kind is wrong
07:57:57 <tabaqui> because they are not applicative
07:57:59 <tabaqui> err
07:58:12 <alp> data Double' a = D Double -- can be arranged
07:58:30 <alp> but I believe the core of the question was about having two operations with two distinct neutral elements
07:58:34 <alp> that's how I interpreted it anyway =)
08:06:48 <thorsten`> is there a way to extract a range of keys from a Map (e.g. Data.Map.Strict)? I'm expecting this to have the complexity log n + keys + values_in_range
08:07:44 <ski> @hoogle Map k v -> [k]
08:07:44 <lambdabot> Data.Map.Internal elems :: Map k a -> [a]
08:07:44 <lambdabot> Data.Map.Lazy elems :: Map k a -> [a]
08:07:44 <lambdabot> Data.Map.Strict elems :: Map k a -> [a]
08:07:57 <ski> @hoogle+
08:07:57 <lambdabot> Data.Map.Strict.Internal elems :: Map k a -> [a]
08:07:57 <lambdabot> Data.HashMap elems :: Map k a -> [a]
08:07:57 <lambdabot> Data.Map.Internal keys :: Map k a -> [k]
08:08:12 <ski> @type Data.Map.Strict.keys
08:08:14 <lambdabot> M.Map k a -> [k]
08:08:29 <thorsten`> Sorry, I'm looking for something of type
08:08:45 <thorsten`> @hoogle Map k v -> k -> k -> [(k,v)]
08:08:46 <lambdabot> Safe lookupJustDef :: Eq a => b -> a -> [(a, b)] -> b
08:08:46 <lambdabot> Safe.Exact zipExactNote :: Partial => String -> [a] -> [b] -> [(a, b)]
08:08:46 <lambdabot> Util zipEqual :: String -> [a] -> [b] -> [(a, b)]
08:08:47 <cocreature> keys + a binary search to find the start and the end
08:10:05 <merijn> thorsten`: One of the filter/restrict functions?
08:10:29 <ClaudiusMaximus> mabye split or splitLookup
08:10:59 <ClaudiusMaximus> @type Data.Map.Strict.splitLookup
08:11:00 <lambdabot> Ord k => k -> M.Map k a -> (M.Map k a, Maybe a, M.Map k a)
08:11:17 <merijn> thorsten`: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Strict.html#g:21
08:11:38 <thorsten`> ah indeed, I just need to split twice and need to apply toList on the inner slice, thanks :-)
08:15:58 <thorsten`> It's roughly (\(from,to) -> toList . fst . split to . snd . split from) plus the value at 'from' and 'to'. :)
08:21:56 <RedNifre> Hi. What's your favorite scripting language?
08:22:20 <RedNifre> (Asking because Ruby isn't functional enough out of the box so I'm looking for something new)
08:22:39 <merijn> RedNifre: Haskell :p
08:23:12 <shapr> I do like Haskell for scripting.
08:23:18 <RedNifre> Hmmmm...
08:23:25 <RedNifre> There is no interpreted mode, right?
08:23:52 <shapr> there's runhaskell
08:24:02 <shapr> where you can execute a source file
08:24:06 <RedNifre> I'm looking for a language where I write about half a screen full of code, put it in a text file that is run by a cronjob on some machine and when it later turns out that it's not working I can just change the code in the txt file, no compiling required.
08:24:13 <RedNifre> shapr oh, neat!
08:24:52 <drewr> stack can do this well, you just need stack installed on the target machine
08:25:05 <ertes> runhaskell unfortunately has quite a noticable boot-up time, so i tend to just compile my haskell "scripts" anyway
08:25:18 <shapr> RedNifre: check out https://hackage.haskell.org/package/turtle-1.4.5/docs/Turtle-Tutorial.html
08:26:30 <RedNifre> Thanks, looks interesting.
08:26:35 <ertes> RedNifre: well, compilation isn't really as much of an issue as some people make it out to be…  it's one command that you can easily hook into your editor
08:26:53 <ertes> there is a massive speed difference in haskell between interpreted and compiled code
08:27:09 <ertes> runhaskell can take up to half a second to boot, depending on your machine
08:27:23 <ertes> and then the code runs at 1%-20% of the compiled speed
08:27:25 <RedNifre> Well, speed doesn't usually matter for the tiny scripts I write, when I write something bigger I do it in a serious language anyway.
08:27:39 <ertes> haskell is a serious language =)
08:27:43 <mnoonan_> :|
08:27:49 <RedNifre> yes, that's why I use it for large things.
08:28:01 <RedNifre> But for small things I currently use Ruby.
08:28:15 <MarianJancar> IIRC stack can compile a script transparently and cache the compiled binary for further runs
08:28:21 <ertes> RedNifre: just do what you do for large things…  the one thing that changes is that you may want to go without a cabal file
08:28:32 <ertes> you can still use cabal sandboxes or stack
08:28:42 <merijn> ertes: Better yet, new-build :p
08:28:53 <merijn> sandboxes are sooooooo last year ;)
08:28:58 <ertes> probably…  i haven't used it myself yet, and that's why i don't mention it =)
08:29:08 <ertes> can you use new-build without a cabal project?
08:29:10 <RedNifre> Okay, so I guess my choices are Haskell and maybe Clojure. What do you think about Clojure or other Lisps?
08:29:26 <merijn> ertes: There's an implicit "default" project
08:29:27 <ertes> merijn: ^
08:29:30 <ertes> ah, ok
08:29:32 <merijn> ertes: Assuming you have a cabal file
08:29:45 <merijn> ertes: So just "cabal new-build" in a folder with a cabal file should "Just Work (TM)"
08:29:48 <ertes> RedNifre: well, scratch stack from my list and replace it by cabal new-build =)
08:30:10 <ertes> or nix, if you're ready for an extra learning curve
08:30:10 <shapr> I really like cabal new-build, but I wan cabal new-install for dropping binaries in my ~/.bin/
08:30:26 <merijn> shapr: There was a PR in progress for that last I check
08:36:13 <s4ke1> I love Functional Dependencies
08:37:04 <ertes> RedNifre: not a big fan of clojure…  it doesn't seem to have any advantage over haskell, but lots of disadvantages
08:38:04 <ertes> first of all it has the same boot-up time as GHCi (runhaskell) that makes it very hard to recommend as a language for batch-style tasks
08:39:54 <ertes> but then it also lacks types, its concurrency is very basic and opinionated (it's more difficult to invent your own concurrency patterns, and haskell's STM is leaps and bounds ahead of clojure's), etc.
08:40:58 <ertes> in fact i'm not aware of any language that has haskell's STM
08:42:41 <ertes> imagine haskell's STM monad without the Alternative instance, and TVar is the only variable type
08:42:55 <ertes> that's what STM in other languages is like
08:47:19 <Average-user> Someone who did day 13 Part B: Is there a faster way then test all possible delays until one works? 
08:48:09 <Psybur> Average-user, link to problem?
08:48:31 <Average-user> It is advent of code: http://adventofcode.com/2017/day/13
08:49:13 <Average-user> basically they release a puzzle with two parts every day of December
08:49:38 <Average-user> You will have to complete part A so you can se part B (the one that I'm asking about)
08:49:41 <Average-user> see*
08:49:58 <mud> Average-user: It reminded me of chinese remainder theorem, but I don't think you can actually do it as one, since the modulii won't be pairwise coprime.
08:50:42 <mud> Also it's kind of opposite, since you want the first that *isn't* equal to some value mod a bunch of values.
08:50:46 <Average-user> mud: So you did actually test all smaller numbers than your solution?
08:51:31 <mud> I didn't do B, I wandered off. But that was my plan, yeah. I think it'll work out fine if you just uhm, test them quickly, without simulating the whole delay part and then moving each step.
08:51:44 <jle`> i tested all possible delays but it was less than 2ms in the end
08:51:56 <ertes> side note: CRT works even when the moduli aren't pairwise coprime
08:52:03 <byorgey> I did test all smaller numbers.  It took about 10 seconds, but I was doing the simulation in a stupid slow way.
08:52:05 <ertes> you just need to rewrite the problem
08:52:30 <Average-user> jle`: mhh, then mi function to move the guards on the layer must be too slow
08:52:44 <jle`> oh you don't really need to move any guards
08:52:49 <mud> ertes: Does it? Hmm.
08:52:59 <jle`> there's a pretty straightforward closed form
08:53:02 <byorgey> Average-user: you don't have to actually simulate the guards moving.  You can just use mod to find where the guard will be at a certain time step
08:53:04 <Average-user> jle` : metaphorically 
08:53:04 <jle`> for guard position at distance n
08:53:14 <jle`> ah yeah
08:53:36 <byorgey> d `mod` (2*(r-1))  IIRC
08:53:44 <Average-user> jle`: But maybe i'm doing that wrong
08:54:01 <Average-user> jle`: can I see your solution?
08:54:21 <Average-user> Well, byorgey is showing it here
08:54:41 <Average-user> D = depth, and r  = ?
08:54:51 <byorgey> Average-user: I think you could do something like maintain a set of possible times mod something, then do a fold where you use CRT at each step to update the modulus (lcm of old modulus and new range) and set of acceptable times
08:55:03 <byorgey> Average-user: r = "range" which is the height of the thingy at depth d
08:55:07 <jle`> https://github.com/mstksg/advent-of-code-2017/blob/master/src/AOC2017/Day13.hs
08:55:21 <jle`> my closed form isn't as nice as byorgey's, i just followed https://en.wikipedia.org/wiki/Triangle_wave
08:55:42 <ertes> x ≡ 4 (mod 12), x ≡ 10 (mod 15); gcd 12 15 = 3; 4 ≡ 1 (mod 3), 10 ≡ 1 (mod 3), so x ≡ 1 (mod 3), x ≡ 0 (mod 12/3), x ≡ 0 (mod 15/3)
08:55:53 <ertes> CRT: x ≡ 40 (mod 60)
08:56:28 <jle`> i guess i don't have to absolute value
08:56:39 <jle`> since negative and positive mods are all the same
08:57:18 <Average-user> this " d `mod` (2*(r-1))" should be 0 right?
08:57:50 <byorgey> if it is 0 that means the guard is at the top row
08:58:21 <mud> ertes: Oh, huh that certainly does seem to work, thanks. I'll have to look into that more.
08:59:27 <ertes> mud: the main difference is that if the moduli aren't coprime there may be no solution
08:59:29 <s4ke1> merjin: thanks about the help earlier btw 
08:59:32 <s4ke1> forgot to say that
09:00:36 <ertes> mud: example: x ≡ 4 (mod 12), x ≡ 11 (mod 15)…  but it's easy to figure out that there is none:  4 ≢ 11 (mod 3)
09:00:47 <mud> ertes: Right, that's interesting. I think that's where I got the idea you couldn't do it. But you should always get the solution via that if there actually is a consistent one it seems? Maybe? *ponders*
09:01:45 <ertes> mud: yes…  the underlying idea is that if there is a common divisor, then each equation is really in a product ring
09:01:52 * hackage retry 0.7.5.1 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.5.1 (MichaelXavier)
09:02:16 <ertes> (x ≡ 4 (mod 12)) is the same statement as (x ≡ 4 (mod 3), x ≡ 4 (mod 4))
09:04:08 <mud> Cool stuff.
09:14:52 * hackage protocol-buffers 2.4.6, hprotoc 2.4.6, protocol-buffers-descriptor 2.4.6 (k_bx): https://qbin.io/qx6g2g636
09:19:07 <Average-user> byoregey: But your solution will return 0 every time delay is even
09:21:38 <Average-user> byorgay: Or if d = depth, and not delay, how does delay affects the function?
09:22:52 * hackage friday-juicypixels 0.1.2.2 - Converts between the Friday and JuicyPixels image types  https://hackage.haskell.org/package/friday-juicypixels-0.1.2.2 (ThomasDuBuisson)
09:23:10 <geekosaur> keep trying, you might get byorgey's name right eventually :p
09:24:15 <Average-user> I know ..
09:24:49 <Average-user> Is kind of hard, mine is Average
09:25:19 <jle`> your irc client probably has tab completion :)
09:25:24 <glguy> Average-user: Most IRC clients have tab-completion for nicknames. You typically don't need to know how to spell it; you need to know it starts with by
09:25:49 <frerich> Gabemo_ is right
09:27:05 <Average-user> glguy: Using it right now, I didn't think of that possibility 
09:27:24 <Average-user> what client do you guys use?
09:27:45 <glguy> my own
09:28:02 <Taneb> I'm using irssi
09:28:41 <Average-user> glguy: Cool!
09:32:52 * hackage universum 0.9.1 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-0.9.1 (shersh)
09:33:44 <Average-user> I use Pidgin
09:34:36 <doyougnu> Average-user: I use ERC in spacemacs
09:34:46 <geekosaur> pidgin should tab complete
09:35:37 <byorgey> Average-user: I don't understand what you mean about returning 0 when delay is even
09:35:47 <byorgey> d = depth
09:35:54 <MP2E> i use glirc as well (which is glguy's client)
09:35:58 <MP2E> works pretty well :)
09:36:03 <byorgey> to take a delay into account you just evaluate (d + delay) `mod` (2*(r-1))
09:39:24 <Average-user> byorgey: Ohh, my bad
09:40:07 <Average-user> geekosaur: It  does have tab complete, I just didn't know about it
09:49:47 <koanta> @check email(bitcoin :: SPAM)
09:49:49 <lambdabot>  error:
09:49:49 <lambdabot>  Not in scope: type constructor or class ‘SPAM’
09:55:02 <tabaqui> @check
09:55:02 <lambdabot>  <unknown>.hs:1:1:Parse error: EOF
09:57:04 <mniip> Gurkenglas, I'll try to get a mic tonight...
09:57:18 <mniip> but there's this problem of finding a place where I don't annoy people and people don't annoy me
10:03:08 <EvanR> mniip: i bought a mic for podcasting too... 
10:03:29 <EvanR> and i found the only way to do it was go into the closet and under a blanket
10:03:52 * hackage ochintin-daicho 0.1.0.0 - A module to manage payroll books for Japanese companies.  https://hackage.haskell.org/package/ochintin-daicho-0.1.0.0 (arowM)
10:06:26 <mud> EvanR: xD
10:19:47 <tabaqui> does anybody know how to print optparse help message based on command line arguments?
10:19:57 <tabaqui> I want to use briefDesc of fullDesc based on them
10:20:16 <tabaqui> like -hh -> fullDesc and -h -> briefDesc
10:32:57 * hackage rattletrap 3.1.2 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-3.1.2 (fozworth)
10:55:52 * hackage grouped-list 0.2.1.4 - Grouped lists. Equal consecutive elements are grouped.  https://hackage.haskell.org/package/grouped-list-0.2.1.4 (DanielDiaz)
10:58:52 <johnw> I now love lens' (&~) operator
10:59:20 <johnw> make it so easy to shove a bunch of stuff into a map, plus some logic about what goes in
11:00:05 <ski> @type (&~)
11:00:06 <lambdabot> s -> State s a -> s
11:00:16 <ski> @type execState
11:00:17 <lambdabot> State s a -> s -> s
11:01:22 <Psybur> :t (&~)
11:01:23 <lambdabot> s -> State s a -> s
11:01:34 <Psybur> ski, why type out @type instead of using :t :D?
11:02:32 <martinmch> :t interact
11:02:33 <lambdabot> (String -> String) -> IO ()
11:02:43 <monochrom>  @type is self-documenting
11:02:56 <mniip> :kind! ()
11:03:10 <monochrom> @kind ()
11:03:11 <lambdabot> *
11:03:13 <monochrom> @kind! ()
11:03:15 <lambdabot> *
11:03:20 <mniip> % :kind! ()
11:03:20 <yahb> mniip: () :: *; = ()
11:03:31 <monochrom> However, it is possible that @kind! is auto-corrected to @kind
11:03:34 <mniip> this does expansion or something
11:04:19 <mniip> % :kind! ShowS ()
11:04:19 <yahb> mniip: ; <interactive>:1:1: error:; * Expecting one fewer arguments to `ShowS'; Expected kind `* -> k0', but `ShowS' has kind `*'; * In the type `ShowS ()'
11:04:22 <mniip> % :kind! ShowS
11:04:22 <yahb> mniip: ShowS :: *; = ShowS
11:04:25 <mniip> maybe not
11:04:44 <mniip> huh
11:04:54 <mniip> "If you specify the optional "!", GHC will in addition normalise the type by expanding out type synonyms and evaluating type-function applications, and display the normalised result."
11:04:56 <mniip> is this a bug then
11:05:27 <mniip> hmm
11:05:27 <mniip> ieda
11:05:31 <mniip> idea
11:05:42 <ski> Psybur : why not ? :)
11:06:05 <Psybur> ski, get your coquestions out of here :P
11:06:34 <ski> `@type' is ingrained
11:06:41 <ski> @help kind
11:06:41 <lambdabot> kind <type>. Return the kind of a type
11:06:44 <ski> @help kind!
11:06:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:07:46 <farnor> hi all - i'm having problems getting reactive-banana-wx to install on OSX - does anyone have any reliable instructions on how to get this working?
11:09:21 <mnoonan_> farnor: what kind of problems? I've build things with wxhaskell on OS X, though not reactive-banana-wx
11:09:52 * hackage log-warper 1.7.6 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.7.6 (shersh)
11:10:27 <farnor> Hi mnoonan_ - that sounds promising.  What version of ghc do you use?
11:11:43 <mnoonan_> farnor: 7.10 and 8.0.2 most likely, it has been a while since I've done anything with a gui so I don't remember for sure.
11:27:48 <Adluc> Hello, how to make cabal or stack do preprocessing (grammar file -> BNFC) for https://hackage.haskell.org/package/BNFC ?
11:28:35 <farnor> mnoonan_: thanks
11:31:02 <parsnip> haskellers say that if there's no type errors, there's a good chance that the code is correct. does this apply in java? less so because of things like state?
11:31:40 <cement> less so because everything's nullable
11:32:41 <geekosaur> also if you actually encounter someone making that claim, slap them
11:32:59 <mnoonan_> (1) people don't mean that totally seriously, (2) you need your type system to be sound, which Java's isn't, and (3) you need your type system to still be expressive enough that the types approximates your program well
11:33:06 <geekosaur> it's not difficult at all to make type-correct code that does the wrong thing. or nothing. or etc.
11:33:11 <mnoonan_> (also Haskell's type system isn't sound, so... :)
11:33:19 <geekosaur> it won't *crash* usually (unless it uses partial functions)
11:34:43 <cement> I sometimes use partial functions (usually with error) to handle exceptions from other people's networking libraries
11:34:57 <cement> but that's iff I'm actively developing
11:35:35 <parsnip> sometimes i google _after_ i ask the question https://softwareengineering.stackexchange.com/questions/279316/what-exactly-makes-the-haskell-type-system-so-revered-vs-say-java
11:50:53 * hackage brick 0.30 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.30 (JonathanDaugherty)
11:51:26 <akegalj> Hey. I would like to create a phantom type `newtype Phanton a = ....` where `a` would be one of two choices. For example `data Choice = ChoiceA | ChoiceB` . How can I bound a to be one of these two choices? Would something like `data ChoiceA; data ChoiceB; <some_type_family_trick>; data Phantom <type_family_trick> = ...` work ?
11:51:59 <acowley> newtype Phantom (a :: Choice) = ...
11:52:05 <acowley> -XDataKinds
11:52:28 <akegalj> acowley: let me read about data kinds. Looks to easy :/
11:52:33 <akegalj> sec
11:52:45 <acowley> akegalj: It really is just that easy!
11:53:33 <fakenullie> I thought you were talking to yourself
11:53:58 <martinmch> What's the difference between `get >>= return . output` and `output <$> get`?
11:54:10 <ertes> martinmch: nothing
11:54:12 <acowley> martinmch: Legally, none
11:55:29 <ertes> martinmch: … semantically…  operationally you could observe a difference in speed and memory, but the Monad laws don't allow semantic differences between the two
11:56:54 <um1b0zu> Hey Hey. Has anyone used a web framework called Spock before?
11:57:12 <cocreature> yes
11:57:16 <martinmch> ertes: <$> is preferable in speed an memory, am I correct?
11:57:21 <martinmch> s/an/and/
11:57:24 <akegalj> acowley: got it. Ty <3
11:58:24 <tsani> martinmch: I think it would depend on the specific monads you're using.
11:58:45 <jle`> martinmch: potentially
11:58:51 <jle`> martinmch: but the real benefit is probably just readability
11:59:02 <um1b0zu> cocreature do you have any comments or criticisms? I'm debating using Snap or Spock. Both seem good, but like many packages in Haskell that do the same thing, there's not much to try and differentiate between them.
12:01:25 <cocreature> um1b0zu: compared to the other choices, Spock is a relatively simple framework. these days I mostly use servant but especially if you’re just getting started, Spock is at least worth a closer look
12:02:14 <Average-user> is <$> the same that fmap right?
12:02:14 <ertes> martinmch: it's a safe assumption, yeah
12:02:42 <ertes> martinmch: usually there is no difference, but if there is, it's far more likely that (<$>) is better
12:03:20 <martinmch> Average-user: I'd said that <$> is the same as fmap.
12:04:57 <jle`> Average-user: (<$>) is the same as fmap because it's just an alias for fmap :)
12:05:49 <ertes> you know what would be a cool quickcheck feature?  if it could generate instances =)
12:05:56 <jle`> infixl 4 <$>
12:05:58 <jle`> (<$>) = fmap
12:06:42 <akegalj> acowley: I guess I have to enable KindSignatures as well
12:06:54 <acowley> akegalj: Ah, right!
12:23:22 <farnor> mnoonan_: this is the error I get when I do 'cabal install cabal-macosx' - this is where I get stuck!  /var/folders/f…xc-0.92.3.0/dist/setup/setup.hs:505:61: Not in scope: ‘versionBranch’ … wxcore-0.92.3.0 depends on wxc-0.92.3.0 which failed to install.
12:24:30 <s4ke1> farnor: any reason why you dont use stack?
12:24:31 <s4ke1> https://docs.haskellstack.org/en/stable/README/
12:25:01 <s4ke1> nvm sorry
12:25:07 <s4ke1> read that wrong
12:25:53 <farnor> np
12:28:46 <mniip> hmm
12:28:52 <mniip> I think I solved the yahb issue!
12:28:57 <mniip> with startup time
12:30:22 <mniip> % :q
12:30:22 <yahb> mniip: 
12:30:38 <mniip> % fix id
12:30:44 <geekosaur> stack would not help there anyway (and really, blindly suggesting something is not the best of ideas, and yes I know it is required that everyone worskip stack as their one true god)
12:30:54 <yahb> mniip: [Timed out]
12:30:56 <geekosaur> that's a Cabal library version issue
12:31:02 <s4ke1> geekosaur: i retracted my comment
12:31:06 <s4ke1> after i read it correctly
12:31:07 <s4ke1> ;)
12:31:17 <mniip> only 5 of those seconds were fix id, the rest was loading ghci from disk because I just flushed all caches
12:31:32 <s4ke1> % fix id
12:31:38 <yahb> s4ke1: [Timed out]
12:31:52 <mniip> % 1
12:31:54 <yahb> mniip: 1
12:31:56 <mniip> % fix id
12:31:56 <s4ke1> neat
12:32:01 <yahb> mniip: [Timed out]
12:32:04 <mniip> see 5 seconds as expected
12:32:23 <mniip> now I'm also thinking of a kill switch...
12:32:35 <s4ke1> (i am quite new to this irc channel, so i dont know all the chatbots here
12:32:43 <s4ke1> whats the difference?
12:32:51 <mniip> the difference between?
12:33:00 <s4ke1> lambdabot and yahp?
12:33:07 <s4ke1> yahb
12:33:10 <farnor> geekosaur: can you point me in the right direction to fix the lib version?
12:33:18 <s4ke1> yet another haskell bot
12:33:20 <mniip> lambdabot uses hint to run SafeHaskell-safe haskell code
12:33:28 <mniip> yahb is pretty much a raw ghci session
12:33:36 <mniip> sandboxing on a whole different level
12:34:12 <geekosaur> farnor, in theory you can install an older Cabal but mixing vwrsions between the build tool (both cabal-install and stack use it), ghc itself, and the Setup.hs is kinda sking for pain
12:34:23 <s4ke1> % let evalN = zipWith ($) 
12:34:24 <yahb> s4ke1: 
12:34:35 <s4ke1> infinite lists?
12:34:52 <s4ke1> evalN (map (+) [1..]) 
12:35:01 <s4ke1> % evalN (map (+) [1..]) 
12:35:01 <yahb> s4ke1: ; <interactive>:2:1: error:; * No instance for (Show ([Integer] -> [Integer])) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
12:35:14 <s4ke1> % evalN (map (+) [1..]) [1..3]
12:35:14 <yahb> s4ke1: [2,4,6]
12:35:33 <s4ke1> % evalN (map (+) [1..]) [1..]
12:35:39 <yahb> s4ke1: [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,
12:35:46 <mniip> dammit I though I fixed that
12:35:46 <s4ke1> hmm sorry
12:35:50 <s4ke1> i wanted to try that :D
12:35:58 <mniip> that should not happen
12:36:00 <Tuplanolla> % :t unsafePerformIO
12:36:01 <geekosaur> it would be far easier to install a version of cabal or stack that uses an older Cabal library, but I don't know what version you'd need off the top of my head
12:36:02 <yahb> Tuplanolla: unsafePerformIO :: IO a -> a
12:36:07 <geekosaur> (ghc version is less critical)
12:36:23 <farnor> right
12:36:31 <Tuplanolla> Do you have `base-prelude` installed, mniip?
12:36:38 <s4ke1> mniip sorry about that
12:36:39 <farnor> oh man, this is far from easy!
12:36:53 <mniip> Tuplanolla, no
12:36:55 <mniip> what's that
12:37:05 <MarcelineVQ> % import System.Process
12:37:05 <yahb> MarcelineVQ: 
12:37:13 <MarcelineVQ> % :t createProcess
12:37:13 <yahb> MarcelineVQ: createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
12:37:14 <s4ke1> % unsafePerformIO getLine
12:37:15 <geekosaur> wx has this tendency to get updated for a few versiojns and then go dormant for a year or so while everything else changes around it
12:37:17 <MarcelineVQ> hmm...
12:37:19 <yahb> s4ke1: "[Timed out]
12:37:32 <farnor> I do wonder if anybody actually uses reactive-banana-wx :)
12:37:35 <Tuplanolla> All the conflict-free parts of `base` with one import, mniip.
12:37:49 <s4ke1> % forkIO
12:37:50 <yahb> s4ke1: ; <interactive>:1:1: error:; * No instance for (Show (IO () -> IO ThreadId)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
12:37:52 <mniip> Tuplanolla, is this re: my advent of code stream
12:37:52 <geekosaur> also Setup procedures that are more complex than the default are somewhat discouraged, in part because it's hard to deal with version skew like this
12:38:04 <Tuplanolla> I don't know what that is.
12:38:10 <mniip> oh
12:38:20 <mniip> s4ke1, I did fix that but I forgot the restart *all* instances of the bot xD
12:38:24 <Tuplanolla> It's just that lambdabot's imports suck.
12:38:30 <geekosaur> Setup.hs is a fairly restricted environment and can't use any of the normal ways to determine or adapt to version changes
12:38:47 <s4ke1> mniip: okay if i test it for a while? :D
12:38:50 <mniip> sure
12:38:54 <mniip> you may wish to switch to PM
12:38:58 <mniip> to keep the channel spam-free
12:39:02 <s4ke1> good idea
12:39:06 <mniip> you might also be interested in %!
12:39:07 <mniip> and %c
12:39:10 <geekosaur> (because none of them will work until after Setup.hs has determined version information)
12:39:27 <farnor> ok :)
12:39:52 <iambrj>                                        
12:40:11 <farnor> what's the next best thing?  I want to experiment with the most abstract FRP gui framework I can find (and install!)
12:40:32 <monochrom> Wait a year for the next best thing.
12:40:40 <farnor> ha
12:40:41 <monochrom> It has always worked for me.
12:40:54 <s4ke1> % forkIO (sequenceA_ [print "test"])
12:40:55 <yahb> s4ke1: Th"rteeasdtI"d; 72
12:41:02 <s4ke1> does this keep running?
12:41:08 <MarcelineVQ> monochrom: that is also a great money saver
12:41:20 <s4ke1> woops
12:41:27 <mniip> looks like "test" interleaved with ThreadId 72
12:41:33 <s4ke1> % forkIO (sequenceA_ (repeat (print "test")))
12:41:34 <yahb> s4ke1: Thr"etaedsItd" ; 74"; tes
12:41:47 <mniip> well yes
12:42:01 <mniip> that inconveniences it for the next user
12:42:06 <geekosaur> "you have a problem and you decide to use threads. nonw owy ou  yoauv e hatwvo e ptrowbo plerombsle imns teinrtleearlveeda.ed."
12:42:15 <s4ke1> mniip: just wanted to know whether you killed such features
12:42:23 <mniip> % 123
12:42:24 <yahb> mniip: t"; "test1"2; 3; "
12:42:27 <s4ke1> :D
12:42:36 <mniip> why it's fun
12:42:54 <s4ke1> why is my code doing this :D?
12:42:54 <mniip> and it's not really possible to "fix" I suspect
12:43:13 <s4ke1> mniip: yeah. you would need to restrict a lot of the libraries 
12:43:13 <monochrom> "You have a problem and you decide to use a thread bomb...."
12:43:22 <mniip> yeah nah
12:43:29 <mniip> I'm not restricting anything at haskell level
12:43:33 <mniip> that defeats the purpose
12:43:40 <mniip> % :q
12:43:40 <yahb> mniip: tes
12:43:42 <s4ke1> mniip: maybe start a shell for each user?
12:43:49 <mniip> I don't have that much ram
12:43:52 <s4ke1> hmm
12:44:00 <monochrom> Tragedy of the common.
12:44:15 <s4ke1> maybe start it on demand?
12:44:26 <mniip> and let them hang around for how long?
12:44:34 <s4ke1> mniip: 5 min?
12:44:38 <s4ke1> 10 min?
12:44:39 <mniip> not enough
12:44:43 <mniip> anyway
12:44:47 <mniip> lambdabot session is shared so
12:44:49 <monochrom> And my mentioning of the tragedy of the common triggers a netsplit. How timely.
12:45:01 <mniip> 1513197795 [23:43:15] -tomaw/Wallops- I'm about to shut down kornbluth for routine maintenance. You may see around 1000 users quit and rejoin!
12:45:27 <s4ke1> maybe make it configurable so users can request time?
12:45:35 <mniip> oh yah I guess now I get to be one of those who bugs staff about global notices and wallops
12:46:03 <s4ke1> pidgin was going bonkers :D
12:46:10 <s4ke1> % 1
12:46:10 <yahb> s4ke1: 1
12:46:21 <s4ke1> > 1
12:46:23 <lambdabot>  1
12:46:36 <mniip> yeah basically, the idea is that lambdabot can't do this
12:46:41 <mniip> % unsafeCoerce () () :: ()
12:46:42 <yahb> mniip: ()
12:46:45 <mniip> hmm
12:46:49 <mniip> % unsafeCoerce () () :: String
12:46:49 <yahb> mniip: "[Segmentation fault]
12:47:16 <s4ke1> > unsafeCoerce () () :: ()
12:47:18 <lambdabot>  error:
12:47:18 <lambdabot>      Variable not in scope: unsafeCoerce :: () -> () -> ()
12:47:35 <monochrom> @quote monochrom isTrue
12:47:35 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
12:47:44 <s4ke1> > forkIO (sequenceA_ [print "test"])
12:47:46 <lambdabot>  error:
12:47:46 <lambdabot>      Variable not in scope: forkIO :: IO () -> t
12:48:09 <mniip> lambdabot has no IO
12:48:10 <monochrom> % (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c) $ True
12:48:11 <yahb> monochrom: True
12:48:14 <monochrom> \∩/
12:48:17 <mniip> and no unsafety
12:48:21 <s4ke1> yeah, just wanted to check
12:48:30 <mniip> yahb on the other hand...
12:48:46 <s4ke1> %  (unsafeCoerce :: Bool -> Maybe c) $ True
12:48:46 <yahb> s4ke1: Just [Segmentation fault]
12:49:08 <mniip> accurate
12:49:23 <Tuplanolla> Never have people rejoiced segmentation faults so.
12:49:46 <s4ke1> i kinda like that result i dont know why
12:49:49 <mniip> % import GHC.IO
12:49:51 <yahb> mniip: 
12:49:51 <s4ke1>  (unsafeCoerce :: Bool -> Maybe c) $ 1
12:49:57 <mniip> % import GHC.Prim
12:49:57 <yahb> mniip: 
12:50:04 <s4ke1> %  (unsafeCoerce :: Bool -> Maybe c) $ 1
12:50:04 <yahb> s4ke1: ; <interactive>:3:37: error:; * No instance for (Num Bool) arising from the literal `1'; * In the second argument of `($)', namely `1'; In the expression: (unsafeCoerce :: Bool -> Maybe c) $ 1; In an equation for `it': it = (unsafeCoerce :: Bool -> Maybe c) $ 1
12:50:08 <s4ke1> woops
12:50:27 <mniip> % case putStrLn "hello" of IO m -> case m realWorld# of (# s, a #) -> a
12:50:28 <yahb> mniip: hello; ()
12:50:28 <s4ke1> % (unsafeCoerce :: Int64 -> Int) $ 1
12:50:29 <yahb> s4ke1: 1
12:51:10 <int-e> % import Control.Monad.ST
12:51:11 <yahb> int-e: 
12:51:11 <s4ke1> % (unsafeCoerce :: Int64 -> Int) $ 123123123123123123123
12:51:11 <yahb> s4ke1: ; <interactive>:7:34: warning: [-Woverflowed-literals] Literal 123123123123123123123 is out of the Int64 range -9223372036854775808..9223372036854775807; -6004085392843738189
12:51:26 <int-e> % unsafeCoerce runST (print "hi!") :: ()
12:51:27 <yahb> int-e: ; <interactive>:8:14: error:; * Cannot instantiate unification variable `a0'; with a type involving foralls: (forall s. ST s a1) -> a1; GHC doesn't yet support impredicative polymorphism; * In the first argument of `unsafeCoerce', namely `runST'; In the expression: unsafeCoerce runST (print "hi!") :: (); In an equation for `it': it = unsafeCoerce runST (print "hi!") :: (
12:51:27 <Psybur> % unsafePerformIO $ return ()
12:51:27 <yahb> Psybur: ()
12:51:37 <int-e> ah.
12:52:02 <Psybur> % print 1
12:52:02 <yahb> Psybur: 1
12:52:11 <geekosaur> someone's hauling out unsafeIOtoST next, right?
12:52:37 <monochrom> No, why would they.
12:52:54 <monochrom> When reallyUnsafePtrEquality is much better.
12:52:58 <int-e> % runST (unsafeCoerce (print "hi!")) :: ()
12:52:59 <yahb> int-e: "hi!"; ()
12:53:04 <int-e> geekosaur: you mean this?
12:53:10 <mniip> % :t reallyUnsafePtrEquality#
12:53:10 <yahb> mniip: reallyUnsafePtrEquality# :: a -> a -> Int#
12:53:19 <Psybur> % import System.IO
12:53:19 <yahb> Psybur: 
12:53:42 <int-e> monochrom: I think it's "you may not believe it, but this operation really is unsafe".
12:53:48 <Psybur> % removeDirectoryRecursive "/"
12:53:49 <yahb> Psybur: *** Exception: /: removeDirectoryRecursive:getDirectoryType:getSymbolicLinkStatus: does not exist (No such file or directory)
12:53:50 <s4ke1> % :t evalN
12:53:50 <yahb> s4ke1: ; <interactive>:1:1: error: Variable not in scope: evalN
12:53:57 <Psybur> % removeDirectoryRecursive "."
12:53:57 <yahb> Psybur: *** Exception: .: removeDirectoryRecursive:removeContentsRecursive:removeDirectory: invalid argument (Invalid argument)
12:53:58 <geekosaur> unsafeInlineIO level?
12:54:06 <geekosaur> hehe
12:54:07 <monochrom> Hmm why don't they generalize to reallyUnsafePtrDiff#? Since they're returning Int# already... >:)
12:54:09 <s4ke1> psybur :D:D
12:54:13 <Psybur> % removeDirectoryRecursive "C:\\"
12:54:13 <yahb> Psybur: *** Exception: C:\: removeDirectoryRecursive:getDirectoryType:getSymbolicLinkStatus: does not exist (No such file or directory)
12:54:21 <Psybur> :D
12:54:38 <s4ke1> % removeDirectoryRecursive "../"
12:54:39 <yahb> s4ke1: *** Exception: ../bin/mv: removeDirectoryRecursive:removeContentsRecursive:removePathRecursive:removeContentsRecursive:removePathRecursive:removeLink: permission denied (Operation not permitted)
12:54:45 <int-e> monochrom: because then people would make an Ord instance out of that...
12:54:58 <s4ke1> i guess this is linux
12:54:58 <int-e> ...which would be...fun for a while, I guess.
12:55:20 <mniip> int-e, for about 0.01 seconds
12:55:27 <mniip> which is the default ghc tick
12:55:42 <int-e> mniip: better if you have a large nursery and lots of things to do :)
12:55:46 <s4ke1> mniip: i ask before i do dumb stuff, but this is sandboxed, right?
12:55:48 <mniip> yes
12:55:57 <mniip> many like you have come before
12:56:11 <s4ke1> bash over irc
12:56:18 <s4ke1> bash over irc over ghci
12:56:19 <mniip> %! echo $SHELL
12:56:19 <yahb> mniip: /var/lib/xsbot/sandbox/root/bin/sh
12:56:20 <s4ke1> or so
12:56:27 <s4ke1> oh
12:56:34 <geekosaur> % System.Info.os
12:56:35 <yahb> geekosaur: "linux"
12:56:48 <Psybur> % import System.Posix.Files
12:56:48 <yahb> Psybur: 
12:56:58 <Tuplanolla> % Data.Vector.fromList "The best part is still being able to do this."
12:56:59 <int-e> s4ke1: and no network access I'd hope
12:56:59 <yahb> Tuplanolla: "The best part is still being able to do this."
12:57:09 <s4ke1> % ping 8.8.8.8
12:57:10 <yahb> s4ke1: ; <interactive>:24:1: error: Variable not in scope: ping :: Double -> b0 -> c
12:57:11 <mniip> of course not
12:57:15 <s4ke1> %! ping 8.8.8.8
12:57:16 <yahb> s4ke1: bash: line 1: ping: command not found
12:57:33 <Psybur> % unsafePerformIO $ setFileMode "../" 777
12:57:34 <yahb> Psybur: *** Exception: ../: setFileMode: permission denied (Operation not permitted)
12:57:45 <s4ke1> import Network.HTTP
12:57:51 <s4ke1> % import Network.HTTP
12:57:52 <yahb> s4ke1: ; <no location info>: error:; Could not find module `Network.HTTP'; It is not a module in the current program, or in any known package.
12:58:28 <Psybur> % setFileMode "../" 777
12:58:29 <yahb> Psybur: *** Exception: ../: setFileMode: permission denied (Operation not permitted)
12:58:36 <Psybur> Ok dont need the unsafePerformIO :D
12:58:56 <mniip> I should get a channel for tests like these
12:59:49 <s4ke1> % import System.CPUTime
12:59:50 <yahb> s4ke1: 
12:59:57 <s4ke1> getCPUTime
13:00:03 <s4ke1> % getCPUTime
13:00:03 <yahb> s4ke1: 1661784330000
13:01:09 <mniip> hmm
13:01:33 <mniip> Tuplanolla, having a single import from an auxiliary module might have helped with the startup time issue
13:01:36 <mniip> but it's fine now
13:08:08 <s4ke1> mniip cool toy :D
13:08:20 <s4ke1> i played around with things in System.Posix, but i guess its safe
13:08:31 <mniip> I mean
13:08:37 <mniip> there's %c, that should tell you something
13:08:43 <s4ke1> %c
13:08:44 <yahb> s4ke1: tcc: error: main not defined
13:09:14 <mniip> something about the expected safety
13:09:19 <ggVGc> hah, who is using tcc?
13:09:26 <mniip> something about the possible atatck vectors you can discard immediately
13:09:29 <ggVGc> I used it once to get quick compile cycles
13:09:47 <mniip> ggVGc, it has a tiny runtime
13:10:01 <ggVGc> well it is named tiny..
13:10:03 <mniip> I can just drop it into the directory along with 5-7 shared libraries
13:11:21 <mniip> %%! find ../
13:11:22 <yahb> mniip: http://qp.mniip.com/y/4
13:11:26 <mniip> dammit
13:12:30 <s4ke1> mniip i like your captchas :D
13:12:35 <kmelva> does generics-sop use GHC.Generics somehow under the hood? or some other mechanism?
13:13:12 <mniip> %%! f() { echo "$1"; [ -d "$1" ] && (for x in "$1"/*; do f "$x"; done) }; f ..
13:13:13 <yahb> mniip: http://qp.mniip.com/y/5
13:13:16 <jle`> kmelva: it does, i believe
13:13:33 <lyxia> kmelva: Just for deriving their own flavor of GHC.Generics
13:13:54 <s4ke1> %! echo "test"
13:13:55 <yahb> s4ke1: test
13:14:18 <mniip> s4ke1, it's a miracle that after 4 years of non-maintenance they didn't break
13:14:20 <RedNifre> What's up with Purescript, Frege and Eta? Are those any good?
13:14:33 <lyxia> kmelva: that can be avoided by using TH
13:14:46 <mniip> tbqh I should probably switch yahb to tcpst.net and discontinue qp at all
13:14:47 <s4ke1> RedNifre: i tried Frege and Eta so far
13:14:56 <kmelva> lyxia: right, they wan't a different API, but they still have to use GHC.Generics under the hood? I guess what I'm asking, at the lowest levels for generic programming there's TemplateHaskell and GHC.Generics?
13:15:03 <s4ke1> both seem usable, but have their problems
13:15:28 <lyxia> kmelva: yes at some point you need some help from the compiler, and that comes in TH and GHC.Generics
13:15:29 <kmelva> lyxia: and generics-sop uses GHC.Generics to do it's magic, not some other mechanism
13:15:31 <RedNifre> I wonder if there is a sensible way to get Haskell on Android. I guess not.
13:15:38 <s4ke1> Frege compiles to Java code which is then compiled to JVM Code, Eta compiles via a GHC variant (i guess) to JVM Code
13:15:49 <s4ke1> RedNifre: nope. checked that
13:16:20 <RedNifre> s4ke1 Eta looks like the people behind it are serious about it.
13:16:51 <RedNifre> s4ke1 so I guess you use Kotlin for Android? (I heard Scala works kinda not too well for Android)
13:16:51 <s4ke1> RedNifre: yes, but if you want a _Compiler_ that runs on Android i dont think that will be a reality anytime soon
13:17:08 <s4ke1> if you want to use Eta for app development i think it's usable
13:17:23 <s4ke1> at least i read it
13:17:35 <s4ke1> RedNifre: i am a Java convert
13:17:43 <s4ke1> so i use Java on Android :D
13:17:56 <s4ke1> (because i am lazy)
13:18:07 <RedNifre> Oh, I strongly recommend Kotlin, it's a Java remake with lots of improvements.
13:18:28 <RedNifre> For Android, I mean. Don't use Kotlin if you can use Haskell ;)
13:19:09 <s4ke1> RedNifre: when i use Java, i already use boiler plate reducing stuff like lombok
13:19:29 <RedNifre> Sure, but Kotlin is lombok, but prettier and more.
13:19:30 <s4ke1> so i dont really mind the rest of added verbosity too much. my IDE can handle that
13:19:54 <s4ke1> hmm maybe i will try it when i have a chance to use it
13:20:08 <s4ke1> however i currently have too much on my plate :(
13:20:40 <RedNifre> ...but if you don't want to try it you could try my "as much FP as I could cram into java" library Ravr, if you want: https://github.com/rednifre/ravr
13:20:58 <RedNifre> meh, I'm getting offtopic.
13:21:17 <RedNifre> What I actually wonder about is if I should write my next hobby project in Haskell or Clojure.
13:21:27 <spikey> Can someone help me with the parsec method option? I am trying to make it so it will take a number of strings
13:21:52 <rightfold> RedNifre: try both and you will wonder no longer
13:22:17 <spikey> How would I go about implementing it?
13:22:22 <s4ke1> RedNifre: lenses in java look weird
13:22:40 <s4ke1> _weird_
13:23:05 <spikey> Would it be something like "option string "hello" string "hey""?
13:23:23 <s4ke1> i tend to write my java code more functional, but damn, functional programming in Java looks just wrong
13:23:26 <RedNifre> s4ke1 yes, that's why I declared them as "experimental"
13:23:33 <s4ke1> the syntax is just not made for that
13:23:55 <s4ke1> i tried implementing Arrows in Java. I gave up after fighting with Generics
13:24:10 <s4ke1> especially while writing ArrowApply
13:24:43 <RedNifre> I forgot what arrows are (it's  been nearly two years since I last wrote any haskell), what were they again?
13:24:48 <s4ke1> (which i didn't really need in the first place, maybe i will give it a try)
13:26:06 <s4ke1> https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Arrow.html
13:26:32 <s4ke1> while you could think of them as a generalized function arrow (->), they are a bit more
13:26:39 <monochrom> You won't be able to port type classes like Functor, Monad, Arrow to Java.
13:26:55 <s4ke1> monochrom: yes you can actually with some hacks
13:27:13 <s4ke1> Especially Monad
13:27:33 <monochrom> Reason is that Java Generic is just kind-* polymorphism but Functor requires kind * -> *
13:28:10 <monochrom> More concretely look at "Maybe Int" for example, Java is OK with generalizing to "Maybe a", but not to "f Int", which is what Functor needs.
13:28:10 <RedNifre> monochrom you can if you use recursive generics to declare a Self type.
13:28:18 <s4ke1> monochrom: wrong
13:28:24 <s4ke1> Java can do it
13:28:26 <s4ke1> even though its ugly
13:28:40 <monochrom> Arrow is only going to be worse because the kind is * -> * -> *
13:28:42 <s4ke1> <R> Functor<R> map(Function<T, R> f);
13:29:17 <rightfold> RedNifre: An arrow is a strong profunctor that is also a category. Learning these three concepts separately is easier IME IMO YMMV
13:29:17 <s4ke1> ah if you mean in the whole hierarchy, then it could get a clusterfuck yes
13:30:10 <c_wraith> s4ke1, that doesn't encode the same knowledge as (a -> b) -> f a -> f b
13:30:11 <RedNifre> I noticed that in practice I mostly map/bind lists and Maybes anyway, so I'm fine with my little FP java library.
13:30:28 <RedNifre> ... granted, I'm still a haskell beginner so I might not know what I'm missing exactly.
13:30:56 <s4ke1> c_wraith: i think so. if its hosted on a Functor<T> interface
13:31:10 <martinmch> How come I get `failed to load interface for 'Data.List.Zipper'`, when running ghcrun on my .hs?
13:31:19 <c_wraith> s4ke1, it doesn't tell you that the necessary relationship between the input and output types, nor does it require the implementation work with no knowledge of a or b
13:32:07 <s4ke1> c_wraith: huh am i missing something?
13:32:20 <monochrom> YES
13:32:39 <monochrom> In short I don't think you even grokked what I was talking about.
13:33:15 <monochrom> More concretely, Haskell code would (and does) go like "instance Functor [] where ...".
13:33:37 <monochrom> And it's "instance Functor []", not "instance Functor [a]".
13:33:47 <monochrom> There is no such thing in Java.
13:34:29 <s4ke1> monochrom: not List<?> ?
13:34:35 <s4ke1> sorry dumb questions
13:34:41 <s4ke1> well...
13:34:57 <monochrom> IIUC "List<?>" is just a shorthand for "List<a>"
13:35:05 <mniip> List<Object>
13:35:13 <RedNifre> What about Functor<Self extends Functor<Self>> ?
13:35:42 <RedNifre> never mind
13:36:26 <monochrom> I have only seen "Comparable<Self extends Comparable<Self>>", but it only models our Ord, so I don't think it is doing * -> * at all, Ord is just *
13:37:02 <mniip> java doesn't have type synonyms right?
13:37:21 <s4ke1> monochrom: but from a users perspective i cant really see the difference
13:37:55 <rightfold> mniip: indeed
13:37:58 <s4ke1> For Functor
13:39:08 <mniip> I recently came to realization that 'rebind' type synonyms in C++ are akin to higher kind polymorphism
13:39:11 <monochrom> Simple-minded users won't see a difference.
13:39:24 <mniip> but with C++'s ad-hocness as always
13:39:36 <martinmch> I get `failed to load interface for 'Data.List.Zipper'`, when running ghcrun on my .hs. I tried doing a cabal install of zipper, but that did no good.
13:42:53 <monochrom> "class Functor f where  fmap :: (a -> b) -> f a -> f b"
13:43:01 <dmwit> martinmch: The zipper package doesn't appear to offer Data.List.Zipper.
13:43:18 <dmwit> martinmch: Where do you see Data.List.Zipper?
13:43:32 <monochrom> If you want to work around Java's non-currying style, I'm fine with "class MeFunctor f where fmap :: (a -> b, f a) -> f b".
13:43:39 <Younder> Lisp the zipper
13:43:43 <martinmch> dmwit: https://hackage.haskell.org/package/ListZipper-1.2.0.2/docs/Data-List-Zipper.html
13:43:50 <mud> That appears to be from the ListZipper package.
13:44:03 <dmwit> martinmch: Okay. That's the ListZipper package, so you should `cabal install ListZipper`.
13:44:03 <s4ke1> monochrom: i guess i understand what you mean now
13:44:08 <monochrom> Now how do you port that to Java? The header "interface MeFunctor<T extends MeFunctor<T>>" is the easy part.
13:44:17 <dmwit> martinmch: Make sure you are either not in a sandbox or use the sandbox interface to use ghc.
13:44:27 <martinmch> dmwit: Ah, of course.
13:44:54 <monochrom> I don't even know how to translate "forall a, b. (a -> b) -> f b" and make sure it relates back to the T in the header.
13:45:46 <Younder> monochrom, There is no T there.. I don't get it
13:45:47 <monochrom> And it is not as simple as "replace f by T". Kind mismatch.
13:45:50 <s4ke1> monochrom: yes, if you put it that way, i think one has to do things like https://gist.github.com/s4ke/859cc016d51b8deb788e5f973d2afce0
13:46:29 <s4ke1> but that is not the same true
13:46:46 <Psybur> What exactly does tacking forall a, b. onto things give you?
13:47:09 <Psybur> Whats the difference between: forall a, b. (a -> b) -> f b and then just (a -> b) -> f b
13:47:28 <monochrom> Being explicit vs being smug.
13:47:29 <dmwit> Psybur: In Haskell, there is no difference.
13:47:53 <dmwit> Psybur: The spec says that unbound type variables are implicitly bound universally at the highest possible level.
13:48:06 <martinmch> dmwit: Much obliged.
13:48:11 <dmwit> Psybur: But Python teaches us that explicit is better than implicit.
13:49:19 <dmwit> Psybur: And note that if you want your variables bound elsewhere than at the top, then you have no choice but to be explicit. e.g. one cannot avoid forall completely in `forall b. (forall a. a -> a) -> b`.
13:49:58 <s4ke1> monochrom: i guess your argument came from the type system, right?
13:50:11 <monochrom> Yes.
13:50:18 <s4ke1> well that's 100% true
13:50:25 <s4ke1> i guess we were talking other things :D
13:50:31 <s4ke1> sorry
13:51:05 <monochrom> I think there are even 10-year-old articles making the same points I made.
13:51:17 <monochrom> err s/articles/blogs/
13:51:44 <p0a> Hello
13:51:47 <s4ke1> In Java i think you are better off if you do it like i posted in my gist and tell the users to please not fuck up
13:51:52 * dmwit waves at p0a
13:52:08 <monochrom> In Applicative you will have much trouble with "pure :: forall a. a -> f a"
13:52:16 <p0a> I'm trying to write a function that takes two lists and puts them into a single list that is ordered
13:52:43 <s4ke1> monochrom: yes, yes. If you want to use interface = class that will never work
13:52:46 <dmwit> ?hackage data-ordlist
13:52:46 <lambdabot> http://hackage.haskell.org/package/data-ordlist
13:52:53 <s4ke1> as i said
13:52:55 <p0a> This is kind of what I have: http://lpaste.net/360763
13:52:56 <s4ke1> ugly workarounds and hacks
13:53:02 <s4ke1> but "possible"
13:53:30 <dmwit> p0a: lookin' good!
13:54:38 <p0a> It says "parse error on input '|'"
13:55:03 <dmwit> p0a: Oh, yeah, you've got an extra `=` on line 4 there.
13:55:32 <p0a> Ok back to "found hole: _ :: [a]"
13:55:46 <p0a> Another error I was getting previously. I suspect it has to do with lines 2&3
13:56:14 <dmwit> Ah! You probably thought `myfold [] _ = ...` would bind the name `_` to the value of the second argument when evaluating `...`.
13:56:23 <dmwit> But it doesn't. `_` is a special pattern that matches everything and binds nothing.
13:56:27 <s4ke1> monochrom: thanks anyways, good input to think about
13:56:35 <dmwit> Easy to fix: just replace `_` with a real variable name everywhere it appears.
13:57:00 <p0a> dmwit: I see, thank you
13:58:13 <dmwit> Once you've got it working, you might enjoy comparing answers with http://hackage.haskell.org/package/data-ordlist-0.4.7.0/docs/src/Data-List-Ordered.html#merge .
13:58:52 <p0a> dmwit: basically isect from data-ordlist is what I need hehe
13:58:57 <p0a> dmwit: for project euler 1
13:59:03 <Psybur> Anybody recommend a good "forall" article?
13:59:09 <p0a> dmwit: thanks for that link
13:59:45 <monochrom> There is no "forall article".
13:59:54 <dmwit> p0a: Sure. For finite sets of the kind PE is usually about, the `containers` package's `Data.Set` is also quite nice.
14:00:15 <dmwit> Psybur: Pierce's "Types and Programming Languages" was pretty formative for me.
14:00:30 <mniip> learn about extranatural transformations and profunctor wedges
14:00:34 <p0a> dmwit: do you think it's a better idea to use Data.Set than write those things myself?
14:00:39 <p0a> being a haskell newbie
14:00:40 <monochrom> There are rank-n types articles. There are predicate logic articles. There are Curry-Howard correspondence and dependent typing articles.
14:00:42 <mniip> then be forever fascinated by 'forall'
14:00:45 <dmwit> p0a: That depends on your goals!
14:00:59 <dmwit> p0a: If your goal is "learn Haskell", reimplementing the standard libraries is a pretty effective way to achieve that goal.
14:01:13 <p0a> cool thanks
14:01:16 <dmwit> p0a: If your goal is "get stuff done", I cannot recommend a big dependency list enough.
14:01:32 <martinmch> Psybur: learnyouahaskellforgood
14:02:00 <dmwit> uh
14:02:21 <martinmch> Psybur: http://learnyouahaskell.com
14:02:33 <dmwit> Without having read LYAH, I can't know for sure, but my impression was that it didn't really do the advanced stuff. So I'd be mildly surprised to discover it did justice to forall.
14:02:52 <Psybur> Hmm, I went through lyah, must have skipped the forall
14:03:33 <dmwit> I don't see anything in the table of contents that calls out to me about this topic, either.
14:03:58 <martinmch> You're right.
14:04:08 <martinmch> I actually don't think it's in there after all, I'm sorry.
14:04:12 <monochrom> "map :: forall a b. (a->b) -> [a] -> [b]" means that the user of map gets to choose what to use for "a" and what to use for "b".
14:04:45 <monochrom> Generalizing, "forall" means your enemy makes a choice.
14:04:57 <monochrom> END OF ARTICLE
14:05:03 <dmwit> Yes, I like the "game" explanation for forall a lot. I think I have some writing on SO to this effect, let me see if I can find it.
14:05:15 <monochrom> Oh, so that's you.
14:05:48 <mniip> there is something else to say
14:05:48 <Tuplanolla> Try doing the opposite for a board game, like Chess.
14:05:53 <mniip> parametericity
14:06:02 <Psybur> I suppose maybe an example of a function (not just signature) that you can write with forall thats not possible without it?
14:06:07 <mniip> the requirement for the result type to be a profunctor wedge
14:06:07 <Psybur> Maybe that would help :D
14:06:07 <dmwit> Psybur: This is more about typeclasses than forall, but it does touch on a good interpretation for `forall`: https://stackoverflow.com/a/42821578/791604
14:06:20 <dmwit> Psybur: Sure, here's one.
14:06:20 <monochrom> But I don't simply site the SO answer because it begins with a distracting tangential meditational stream-of-consciousness essay writing before the author realizes that you just need one sentence "forall means your enemy chooses".
14:06:28 <monochrom> s/site/cite/
14:06:46 <dmwit> > let f :: (forall a. Num a => a -> a) -> (Int, Double); f g = (g 3, g 3) in f (+1)
14:06:48 <lambdabot>  (4,4.0)
14:07:01 <dmwit> Psybur: This function cannot be written without `forall`.
14:07:21 <merijn> dmwit: Dammit, you wrote it out before I found my link >.>
14:08:02 <dmwit> monochrom: When adding an answer to an already answered question, I like to make sure that I have differentiated myself. Part of that mental preparation is writing down what the differentiation is.
14:08:20 <dmwit> Sometimes I try to write that down and decide that it is not worth an additional answer. =)
14:08:24 <monochrom> You heard of "throw away the prototype"?
14:08:36 <dmwit> I think it is useful for other readers, too.
14:08:42 <mniip> > let fromPeano :: (forall a. (a -> a) -> a -> a) -> Int; fromPeano n = n (+1) 0  in  fromPeano (\f -> f . f . f)
14:08:44 <lambdabot>  3
14:08:54 <dmwit> When there are multiple answers, it is nice to have some hints about how to choose between them.
14:08:57 * dmwit shrugs
14:08:59 <dmwit> That's my thought, anyway.
14:09:00 <monochrom> I too start with stream-of-consciousness rambling, and I need that to organize my thought.
14:09:15 <monochrom> But it takes only one click to delete the rambling.
14:09:32 <dmwit> Anyway, I don't feel like two extra sentences is necessarily a big hurdle to cross when there's several pages of text.
14:09:51 <mniip> one thing thought
14:10:06 <mniip> yall seem to be underestimating the imporance of parametricity
14:10:18 <mniip> though* importance*
14:10:30 <monochrom> OTOH SO's award system certainly favours show-you-around-the-world essay writing.
14:10:36 <geekosaur> me too. linearizing my thoughts usually takes several attempts for anything longer than 1 line. but I at least try not to subject my readers to it
14:10:42 <dmwit> Anyway, "forall means your enemy chooses" isn't right. It depends on the polarity of the forall.
14:10:57 <mniip> without parametericity it'd be called 'pi'
14:10:59 <geekosaur> and yes, SO's got some decidedly perverse incentives
14:11:07 <monochrom> s/enemy/receiver/ and it's right.
14:11:17 <dmwit> monochrom: Hm. Will you briefly click on my link and make sure you are complaining about me? I'm finding it increasingly hard to connect your complaint with my writing, and just want to make sure.
14:11:21 <geekosaur> split the difference: target
14:11:48 <p0a> I'm having trouble remembering the evaluation order for the syntax brackets. any hints?
14:11:58 <p0a> Like a b c and a (b c) and (a b) c
14:12:06 <monochrom> Oh OK, you're right, this is not essay I was looking for!
14:12:29 <monochrom> This is at least well-formatted bullet points.
14:12:49 <geekosaur> heh\
14:12:54 <dmwit> yey
14:12:58 <monochrom> (Oh I realize that I'm Edward Tufte's enemy now.)
14:13:26 <p0a> for example what's the leanest way to write fib n = (fib (n-1)) + (fib (n-2))?
14:13:27 <geekosaur> I'd also say the background is necessary for most newcomers to be able to understand why and to be able to experiment --- and without the why, they won't get it. see LYAH for an example of that
14:13:39 <mniip> > fix $ (0:) . scanl (+) 1
14:13:40 <p0a> leanest in the sense of using the least parentheses
14:13:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:13:46 <mniip> ah
14:13:52 <mud> p0a: fib n = fib (n-1) + fib (n-2)
14:13:52 <p0a> In that particular expression
14:14:01 <geekosaur> (and now I'm thinking "Tufte's tufts of text". bad brain.)
14:14:09 <p0a> ah okay so infix operations are special
14:14:14 <mud> Function application binds stronger than any infix operator
14:14:15 <p0a> in terms of order evaluation
14:14:26 <monochrom> I did throw away my prototype when I wrote my thesis. I had a first version I threw out like 90% of.
14:14:28 <p0a> right. not special just "Slower"
14:15:07 <merijn> p0a: Infix operators have precedence 0-9, function applicatio has precedence 10 and record syntax has precedence 11
14:15:07 <p0a> mniip: that code's cool though!
14:15:10 <MarcelineVQ> geekosaur: there is a lot of good stuff in lyah, even zippers are in there, it's too bad about the exercise dearth really
14:15:10 <monochrom> The result: My supervisor say "this is one of the most well-written theses I've ever seen".
14:15:36 <p0a> monochrom: nice. totally agree with you on throwing away what you have and redoing it
14:15:57 <monochrom> 6 months later he emailed me to say "I'm re-read it again and I still can't get over the fact that it's so well-written"
14:15:59 <p0a> but not really throwing it away
14:16:10 <geekosaur> I'd argue lots of good stuff, but presented in too little detail. 14 countries in 14 days tours are not the way to actually learn anything about any of the countries
14:16:25 <merijn> monochrom: My supervisor is just desperate to stop me from scrapping things and reinventing them :p
14:16:42 <monochrom> Oh yeah there are some parts you will be able to reuse. Don't religiously throw it away.
14:16:42 <geekosaur> although there are parts where it;s better than that.
14:16:49 <mniip> > fmap getSum $ fix $ cons 0 . scanl mappend 1
14:16:49 <dmwit> monochrom: grats =)
14:16:50 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:16:51 <mniip> no parens
14:17:06 <monochrom> But do make a conscious choice of: what order to present, and do you really need to tell everything
14:17:10 <merijn> monochrom: I don't really throw away, I...aggressively refactor :p
14:17:25 <monochrom> Yes, refactor is very much more accurate.
14:17:32 <p0a> monochrom: any advice for talks?
14:17:45 <mniip> monoids we meet again
14:18:07 <merijn> p0a: Talks are very person dependent, everyone has their own style, and merely copying the style of someone succesful is not necessarily a recipe for success
14:18:12 <monochrom> Piaget's theory: Concrete before abstract, special before general.
14:18:24 <p0a> merijn: I have the bruce lee style! be like water my friend
14:18:38 <monochrom> In fact for most talks the time limit is such that you won't make it to the abstract and general.
14:18:48 <p0a> merijn: oh. I see your point though :)
14:19:01 <merijn> p0a: My talks are pretty ad hoc, I make up a lot of stuff on the spot, improvise and don't really practice. But I definitely would NOT recommend emulating that style
14:19:14 <p0a> monochrom: I'll keep Piaget in mind
14:19:34 <merijn> p0a: Because it relies on actually being able to improvise a story, and if you can't, that'll end up MUCH worse than just memorising something you wrote and practiced
14:19:35 <Tuplanolla> Make it so that the first quarter can be understood by anyone, the second quarter by the audience, the third quarter only by you and the last quarter by nobody, p0a.
14:19:54 <p0a> HAHAHA
14:19:59 <merijn> p0a: Actually, I do have 2 general rules
14:20:18 <merijn> p0a: 1) No tables of content!!! (unless your talk is MINIMUM 2 hours)
14:20:25 <p0a> Tuplanolla: I almost actually lol'd in a quiet environment
14:20:35 <merijn> p0a: 2) No last slide saying only "questions?", make sure it lists the take away from your talk
14:20:51 <s4ke1> merijn those are 2 good rules
14:20:55 <merijn> (having "Questions?" below the take away on the last slide is acceptable)
14:20:58 <monochrom> There is a religious war on whether you need a table of contents or not.
14:21:21 <merijn> monochrom: And much like in religious war, anyone on the opposing side is wrong and should be crushed with righteous wrath
14:21:21 <p0a> merijn: thanks that is good advice 
14:21:41 <monochrom> I'm agnostic. But I think any form of "roadmap" is nice.
14:21:47 <int-e> violating 1) helps with pacing, 2) is good advice.
14:21:58 <MarcelineVQ> merijn: tribal war is more accurate, or more broadly applicable at least
14:22:09 <Tuplanolla> If I'm going to be short on time, I put a list of questions you can ask at the end.
14:22:13 <merijn> int-e: The thing is, 20 minutes talks always have the same structure, so having a ToC is just annoying
14:22:42 <merijn> "oh, really? you're first going to introduce the problem, describe your approach, show the results, then clarify future directions? you don't say..."
14:22:56 <merijn> MarcelineVQ: Religious war is better, free casus belli!
14:23:04 <monochrom> Oh right if the TOC is generic bland like that, don't bother.
14:23:12 <MarcelineVQ> Odin wills it!
14:23:31 <merijn> monochrom: 90% of TOC I see are like that, hence "no TOC unless you're over 2 hours"
14:23:47 <merijn> monochrom: Any less bland TOC is just a hidden "introduction" section of your talk
14:24:26 <int-e> merijn: I think table of contents are a matter of style to a large extent (you shouldn't spend much time on them if you have them of course). But showing a basically empty slide for a good part of a Q&A session is wasteful.
14:25:18 <merijn> int-e: Clearly you're going to conferences with exceptionally better speakers than I do :p
14:25:25 <monochrom> I have a cunning plan! Don't put a "Questions?" slide at the end. Put an "Answers!" slide there instead!
14:25:34 <s4ke1> :D
14:25:38 <mniip> coquestions
14:25:53 <monochrom> (From the guy who brought you "don't answer to answer, just don't answer")
14:26:46 <s4ke1> i've been wondering, what are your dayjobs?
14:26:58 <s4ke1> i heard theses here and there, PhD?
14:27:07 <merijn> IRC junkie :p
14:27:07 <Tuplanolla> Soon, s4ke1.
14:27:14 <EvanR> withStateT :: (s -> s) -> StateT s m a -> StateT s m a is it just me or, should there be a way to do something with the state that involves side effects
14:27:33 <s4ke1> merijn: well you helped me today so i appreciate that
14:27:40 <s4ke1> :D
14:27:43 <mniip> EvanR, >>= StateT f
14:27:50 <s4ke1> at least giving me a pointer i mean
14:27:52 <merijn> I should create a Patreon for answering shit here... :p
14:28:05 <mniip> or rather >>
14:28:07 <merijn> Maybe that could fund an extension on my phd :p
14:28:24 <EvanR> :t (>> StateT f)
14:28:25 <lambdabot> (FromExpr (m (b, s)), Show s, Monad m) => StateT s m a -> StateT s m b
14:28:25 <merijn> EvanR: That'd just be a mix of get/put and >>=
14:28:28 <monochrom> Um, no, it will fund procratinating your PhD.
14:28:33 <mniip> haha I wish I could just graduate finally
14:28:54 <merijn> monochrom: Yes, but my procrastination is more scientifically interesting and useful anyway :p
14:28:55 <monochrom> I know because been there done that got the karma points
14:29:08 <EvanR> merijn: yeah... just a thing thats not in the libr
14:29:11 <s4ke1> i am working on finally finishing my Masters. I am wondering whether I should pursue a PhD though
14:29:22 <merijn> s4ke1: "Probably not"
14:29:23 * mniip <- undergrad
14:29:29 <merijn> s4ke1: It depends on your reasons for considering it
14:29:40 <merijn> s4ke1: Also, where you live
14:30:08 <monochrom> If you don't like or aren't able to look for a problem to solve, you are not suitable for PhD or what comes after.
14:30:17 <merijn> North/Western-Europe vs US is a rather big difficulty
14:30:30 <merijn> monochrom: "what comes after" <- you mean industry jobs? :p
14:30:43 <mniip> industry jobs? in haskell?
14:30:44 <s4ke1> merijn: Germany. I was asked by my Masters thesis supervisor to continue my current work
14:31:13 <p0a> what comes after a phd typically is trauma
14:31:17 <merijn> s4ke1: Germany you're at least paid and an employee, so that's already much more appealing than many places :)
14:31:22 <monochrom> And it is pretty counterintuitive. A lot of the top people are excellent at solving problems --- and they are super-hard problems --- but they need to be given such problems, they are petrified when asked to look for one by themselves.
14:31:22 <p0a> :P
14:31:58 <merijn> monochrom: I'm great at finding problems, I'm just not great at finding money to try and solve them :p
14:32:04 <s4ke1> :D
14:32:16 <Tuplanolla> Where do you have to look for problems, monochrom? Not a week goes by without coming across another hard problem.
14:32:22 <monochrom> So basically the usual metric we all use "oh you've got straight A+'s from undergrad or even master's, I encourage you to do a PhD" is actually pretty flawed.
14:32:29 <EvanR> a combination of get, something, put takes 3 lines, instead of 1
14:33:05 <s4ke1> monochrom: yeah. I am quite good at finding problems though. At least I think I am.
14:33:10 <monochrom> Because PhD is painful if you aren't sure what you want to do for your thesis.
14:33:10 <merijn> EvanR: Depends how you write it?
14:33:22 <merijn> EvanR: "get >>= (f >=> put)"
14:33:28 <s4ke1> monochrom: but thanks for the input
14:33:41 <monochrom> I was lucky because I found one and was very happy for it.
14:33:56 <merijn> monochrom: I spend 4 years hacking up code and accidentally have something that seems like it was planned from the start :p
14:34:18 <s4ke1> the stuff i am currently working on can produce at least some more papers and can probably used in a thesis
14:34:38 <monochrom> Basically I ran into Haskell and you guys, and you guys were always whining about "lazy timing is so hard", and one day it suddenly occurred to me "I have a cunning plan! I will prove you wrong!" and that settled my thesis topic.
14:35:01 <mniip> hah
14:35:05 <s4ke1> what are you writing about?
14:35:07 <merijn> monochrom: I still wanna prove people wrong about "you need to catch exceptions in IO and they have to be unchecked"
14:35:08 <mud> monochrom: Hmm, have a link?
14:35:18 <monochrom> At the end, I couldn't prove you wrong, but I now see exactly where the trouble is, and I know how to manage it.
14:35:19 <mniip> one day ekmett said "you can't do this" and I had a cunning plan
14:35:29 <mud> mniip: Give up?
14:35:39 <monochrom> http://www.cs.utoronto.ca/~trebla/albert-thesis-ut.pdf
14:35:50 <MarcelineVQ> mniip: write a ghc extension?
14:35:51 <mniip> no, write functions that with type errors of exponential size
14:36:01 <mud> monochrom: Thanks
14:36:03 <merijn> Also, I wanna build a language with proper first-class concurrency. But it's hard to find PL positions, at least with my geographic constraints
14:36:08 <p0a> I appreciate the help everyone. bye
14:36:29 <mniip> I almost came up with an idea
14:36:39 <mniip> just one more challenge to overcome
14:37:25 <MarcelineVQ> merijn: can you say more about this?
14:37:35 <s4ke1> monochrom looks like a good read
14:37:36 <merijn> MarcelineVQ: Which one?
14:37:36 <monochrom> Tuplanolla: There are also implicit restrictions like "is it up my alley though?" and "how to draw a line around a suitable scope such that I have a PhD project of the right size" etc etc
14:37:43 <MarcelineVQ> first class concurrency
14:37:56 <merijn> monochrom: That sounds like something your supervisor is supposed to help you with, though
14:38:06 <MarcelineVQ> and what it means for a language to have it, though that's a bit of a vague line on my end
14:38:28 <MarcelineVQ> *I'm wording that a bit vaguely
14:39:09 <merijn> MarcelineVQ: I mean that things like "forkIO" is an ugly hack. The only "identity" concurrent "processes" have is their thread id. Absolutely no information about what/who they can communicate with, what happens with resource communicated between them, etc.
14:39:22 <monochrom> Like, take for example the computational complexity people, I'm sure every grad student in that community has "I'll tackle P=?NP, or at least help to". The real question is which subproblem to do for the next 5 years.
14:39:26 <merijn> MarcelineVQ: Consider the utter inability to have any influence on Haskell libraries spawning their own threads
14:40:18 <monochrom> merijn: If you run into a dictator supervisor, yeah he/she already has your problem cut of for you. But there is some chance you'll regret it.
14:40:21 <merijn> MarcelineVQ: The same way you have "IO a" as first class action I'd like first class values for concurrent operations. Are they supposed to run until finished, loop indefinitely, what resource can be shared, etc.
14:40:32 <mniip> sigh
14:40:44 <monochrom> And then there are also a lot of supervisors who grant you freedom, and that's when people are afraid of choices.
14:40:46 <mniip> just graph isomorphism is npi and be done with it
14:40:50 <mniip> just prove*
14:40:54 <merijn> monochrom: No, I mean, helping you figure out reasonable scope is pretty explicitly part of your supervisor's job description
14:41:28 <monochrom> The worst is when the supervisor gives you a menu of say 5 things. Now you'll take eternal navel gazing.
14:41:48 * hackage goggles 0.1.0.0 - Interface to Google Cloud APIs  https://hackage.haskell.org/package/goggles-0.1.0.0 (ocramz)
14:41:52 <MarcelineVQ> merijn: would the run until finished vs loop indefinetly distinction also give (or require) totality?
14:42:01 <monochrom> OK yeah if the supervisor is super-familiar with the direction you've decided on.
14:42:11 <monochrom> But often life isn't that ideal.
14:42:31 <merijn> monochrom: Those kinds of "choose what you want" phd positions don't exist here anymore anyway
14:42:33 <monochrom> For example even right at the beginning I knew more lazy evaluation then my supervisor did.
14:43:00 <merijn> There's not a single university that hires phds anymore here. All phd positions are project based
14:43:34 <monochrom> My supervisor's strength is simplification and the corollary of challenging me with "why is your thing so complicated? why can't it be as simple as the following...?"
14:43:52 <s4ke1> monochrom: i think that's the best kind of supervisor
14:44:37 <monochrom> Learned much cut-to-the-mustard from him.
14:44:49 <MarcelineVQ> "it's completely simple,  foo a = a" "you're not fooling me, I know that's just a singnal to the compiler to do a completely seperate actually complicaed thing"
14:44:59 <merijn> s4ke1: I dunno, mine is somehow making my incoherent idea storm seem coherent and useful, that's also pretty good
14:45:47 <merijn> MarcelineVQ: I don't have a completely worked out thing, just a huge list of ideas and things I wrote down that I have no time/energy to work on
14:45:50 <s4ke1> it might be a bit of a different example, but back then I came to my Bachelors Thesis supervisor with an idea and talked about it with him and he helped me focus on the important parts, but I was the sole expert in this relation
14:46:01 <s4ke1> sole (?) that seems wrong
14:46:45 <s4ke1> anyhow. I tend to work well in such scenarios and I have fun doing so. I could never work for someone who told me to do thing x in a particular way
14:47:00 <barrucadu> heh, my supervisor's approach to many things isn't "can this be simpler?" it's "can this be lazier?".  Definitely a big fan of lazy evaluation.
14:47:25 <s4ke1> i mean my Masters Thesis evolved out of a Masters Project which evolved from a Small Masters Project
14:47:26 <s4ke1> :D
14:47:54 <s4ke1> the result is no half baked shitty cookie cutter Thesis, but took _long_
14:48:05 <s4ke1> (and is not completely finished yet)
14:48:23 <merijn> s4ke1: Really theses' take suffering :p
14:49:15 <s4ke1> anyhow. i think i will go now. nice talking to you guys.
15:14:46 <Average-user> jle`: `Streaming day 14?
15:45:49 <cement> ok, does anyone know why Either a b has the Semigroup instance it does?
15:47:34 <Welkin> and what is it?
15:50:56 <cement> Left _ <> b = b
15:50:56 <cement> a <> _ = a
15:51:18 <jle`> Average-user: if i have the time :)
15:52:05 <jle`> i was planning to!
15:52:25 <Average-user1>  jle`: nice!
15:53:11 <jle`> cement: that's interesting
15:53:53 <jle`> i suppose it's kinda like <|> behavior
15:54:20 <cement> it's horrible. Maybe I'm slightly pissed because it made me have to find what should've been a compile-time error the stupid way
15:54:28 <jle`> except backwards
15:54:58 <jle`> what was horrible about it?  did you not expect Either to have a Semiogrup instance?
15:55:25 <jle`> er, i guess i mean to say, what different instance would have caused it to not be a compile-timeerror?
15:55:33 <jle`> i feel like whatever instance there is, it would not be a compile-time error
15:55:45 <jle`> if it's well-typed
15:56:13 <cement> intuitively I'd expect it to not have an instance
15:56:43 <hpc> it's a valid semigroup though
15:56:49 <jle`> cement: why not?
15:56:52 <hpc> and even a useful one
15:57:00 <jle`> i thought you were asking about why it has that instance, instead of the many other useful ones
15:57:34 <MarcelineVQ> hpc: why does it have that instance?
15:57:43 <cement> little of column a, little of column b
15:58:23 <hpc> do you mean why is it useful?
15:58:27 <cement> I don't know what uses that instance would have, and I somewhat expected a slightly different instance too
15:58:30 <hs_newb> hello, anyone using intero emacs with nix?
15:58:37 <MarcelineVQ> hpc: I mean that as well :>
15:58:41 <EvanR> window 23
15:58:42 <jle`> that's like saying that Int should not have a Num instance, because you meant to add Float's, so if Int had no instance it'd be a compiletime error
15:58:58 <jle`> cement: even if it's a different instance, it would still not be a compile-time error
15:59:13 <cement> yeah, as I said, I'm slightly pissed because of the bug hunting I just did
15:59:19 <cement> you are correct, of course
16:00:15 <hpc> MarcelineVQ: probably because it behaves like (<|>)
16:00:47 <hpc> although in this case i think i would rather have (Right a) <> (Right b) = Right (a <> b)
16:00:54 <hpc> with the added constraint
16:01:13 <cement> yeah, that's more like what I expected/ended up writing for my specific case
16:01:13 <hpc> it "feels" more monoidy than alternativey
16:01:23 <jle`> i wouldn't mind that too, since it matches Maybe
16:01:33 <hpc> i wouldn't expect it to have no instance at all
16:01:53 <cement> though for the Left a <> Right b case, I'm not 100% on what the behavior should be
16:02:08 <hpc> probably Left a
16:02:19 <hpc> i would define it as
16:02:22 <hpc> (Right a) <> (Right b) = Right (a <> b)
16:02:41 <hpc> (Right a) <> b = b
16:02:56 <hpc> a <> _ = a
16:02:58 <cement> ah, so thinking of it like Maybe, as you said
16:03:01 <hpc> more or less
16:03:15 <hpc> yeah
16:04:10 <cement> my case is somewhat strange, because I've got something like Monoid a,b => Either a b
16:04:13 <mniip> Gurkenglas, woah dude
16:04:18 <mniip> on sketchtoy
16:04:20 <mniip> you can rotate
16:04:38 <MarcelineVQ> mniip: you've gone mad with power
16:04:44 <cement> and I'm not using to indicate failure
16:04:49 <cement> using it*
16:04:52 <jle`> > S.sconcat (Left "a" NE.:| [Left "b", Right 9, Left "c"])
16:04:54 <lambdabot>  Right 9
16:05:13 <jle`> > S.sconcat (Left "a" NE.:| [Left "b", Left "c"])
16:05:16 <lambdabot>  Left "c"
16:06:09 <cement> anyways, heading out of work, thanks for calming me down
16:06:45 <jle`> have fun!
16:06:54 <MarcelineVQ> cement: look at https://hackage.haskell.org/package/either-5/docs/Data-Either-Validation.html just in case
16:09:01 <jle`> aka http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Applicative-Lift.html#t:Errors
16:10:30 <hs_newb> can somebody please explain how filterM works?
16:10:47 <jle`> what part are you having trouble understanding?
16:10:49 <dibblego> hs_newb: I have exercise for it, if that helps. Otherwise, do you have specific questions?
16:11:17 <hs_newb> >  Control.Monad.filterM (\x->[True,False]) [1,2,3]
16:11:19 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:12:03 <jle`> ah yeah, what's probably more important there is the Monad intsance for lists
16:12:13 <jle`> or the Applicative instance
16:12:51 <jle`> hs_newb: do you understand fiterM for monads like IO, Maybe, Writer, State ...?
16:12:54 <mniip> :t filterM
16:12:56 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
16:12:58 <dibblego> hs_newb: here is a thing to try. Write filter using filterM.
16:13:23 <mniip> hmm
16:13:43 <mniip> :t filter (
16:13:44 <lambdabot> error:
16:13:44 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:13:44 <mniip> oops
16:14:02 <hs_newb> filter is just (\x -> f x) ?
16:14:10 <dibblego> almost
16:14:21 <dibblego> notice the difference in the types between filter and filterM
16:14:21 <hs_newb> join
16:14:50 <hs_newb> right gotta flatten it concat or join
16:14:53 <dibblego> you need to "remove the (f)" to get filter, from filter
16:14:57 <dibblego> you need to "remove the (f)" to get filter, from filterM
16:15:09 <dibblego> no, you need a value for (f) that "does nothing"
16:15:13 <dibblego> here is a data type:
16:15:17 <dibblego> data Identity a = Identity a
16:15:27 <dibblego> if you turn (f) into Identity, it will do nothing
16:18:15 <hs_newb> > concat $ Control.Monad.filterM (\x -> [even x]) [1,2,3]
16:18:17 <lambdabot>  [2]
16:18:41 <hs_newb> dibblego: i don't understand what you just said tbh :(
16:18:47 <dibblego> ok
16:19:03 <Axman6> filterm (pure . f) should always be the same as pure . filter f
16:19:11 <cheater> what would happen if someone limited haskell to a primitive recursive language, and started shaving away parts of the GHC that were not necessary?
16:19:15 <Axman6> (I think?)
16:19:15 <dibblego> filter  ::                  (a ->   Bool) -> [a] ->   [a]
16:19:15 <dibblego> filterM :: Applicative f => (a -> f Bool) -> [a] -> f [a]
16:19:23 <dibblego> see these two types? what are their differences?
16:19:41 <Tuplanolla> A worse Idris, cheater?
16:20:01 <cheater> i'm more interested in what that would mean for GHC
16:20:20 <cheater> i wonder how much of GHC can be shed away by making the language somewhat less powerful
16:20:46 <johnw> cheater: so soon we'll just have GH?
16:20:58 <MarcelineVQ> If I may interject, then I suspect, a lot less than you'd expect, if that's at all correct
16:21:00 <jle`> start slower
16:21:01 <Axman6> GC
16:21:04 <jle`> GHC => CHC
16:21:11 <Welkin> MarcelineVQ: it's GNU+Linux, thank you very much
16:21:15 <Axman6> "THe Glasgow Compiler"
16:21:17 <jle`> => C||C
16:21:28 <hs_newb> dibblego filterM has function that returns applicative instance, and it's like sequence applied after
16:22:02 <dibblego> hs_newb: we don't know how it is implemented just yet. We only see the types. What differences exist?
16:22:04 <jle`> > filterM (\x -> Just x) [1,2,3]
16:22:06 <lambdabot>  error:
16:22:06 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘1’
16:22:06 <lambdabot>      • In the expression: 1
16:22:15 <mniip> looks like someone didn't learn their trigonometry https://sketchtoy.com/68445002
16:22:16 <jle`> > filterM (\x -> Just True) [1,2,3]
16:22:18 <lambdabot>  Just [1,2,3]
16:23:06 <jle`> > filterM (\x -> ([show x], even x)) [1,2,3,4,5]
16:23:08 <lambdabot>  (["1","2","3","4","5"],[2,4])
16:23:10 <Axman6> mniip: ?
16:23:17 <hs_newb> dibblego it just has the extra applicative obviously
16:23:48 <dibblego> hs_newb: it puts a value (f) in an argument position, and the return position, and we know that f is applicative
16:23:59 <mniip> Axman6, space-drag it around
16:24:03 <mniip> it's supposed to be a helix
16:24:09 <mniip> but it doesn't look sinusoidal
16:24:16 <dibblego> hs_newb: what is a concrete value for (f), with an Applicative instance that "does nothing"? It just wraps and unwraps?
16:24:26 <hs_newb> pure
16:24:44 <mniip> jle`, pff,
16:24:46 <mniip> :t (`evalState` Nothing) . filterM (liftA2 fmap (>) ((get <*) . put) . Just)
16:24:47 <lambdabot> Ord a => [a] -> [a]
16:25:20 <Axman6> mniip: huh, weird! it's like they've projected a cylinder onto a plane and used that for positions
16:25:31 <mniip> not cylinder
16:25:38 <mniip> it's like rotation in a manhattan topology
16:25:52 <jle`> hs_newb: if you had a function (fileExists :: Filepath -> IO Bool), and you wanted to filter a list of filepaths for only the ones that exist,  you could do filterM fileExists :: [FilePath] -> IO [FilePath]
16:26:04 <crobbins> is there something like the State monad, but allows for something like `State s1 (s2 => r)`
16:26:05 <crobbins> ?
16:26:14 <jle`> crobbins: what is => there?
16:26:16 <mniip> crobbins, what?
16:26:18 <crobbins> ->
16:26:26 <Axman6> I don't understand what that means
16:26:27 <mniip> StateT s1 (Reader s2)
16:26:29 <jle`> State s1 (s2 -> r) ?
16:26:44 <crobbins> hmm yeah Reader is probably what i need
16:26:46 <Axman6> @unmtl StateT s1 (Reader s2) a
16:26:47 <lambdabot> s1 -> s2 -> (a, s1)
16:27:09 <Axman6> you may also want to look at RWS(T)
16:27:24 <Axman6> @unmtl RWST r w s m a
16:27:24 <lambdabot> r -> s -> m (a, s, w)
16:27:31 * jle` . o ( StateT s (Reader r) a  ~  (r, s) -> (a, s) )
16:28:09 <jle`> a mealy machine :)
16:28:13 <mniip> ReaderT (r, s) (WriterT (Endo s))
16:29:16 <dibblego> hs_newb: pure wraps, but I also need it to unwrap, so I need to be more specialised. I need a specific Applicative instance.
16:30:05 <mniip> hmm
16:30:11 <mniip> :t filterM ZipList
16:30:12 <lambdabot> [[Bool]] -> ZipList [[Bool]]
16:31:12 <mniip> wait, filterM is applicative huh
16:31:22 <jle`> yup cause it executes all the effects no matter what
16:31:28 <mniip> :t filterM Const
16:31:29 <lambdabot> Monoid a => [a] -> Const a [a]
16:31:53 <mniip> this is my new most favorite way to write concat
16:32:00 <mniip> :t getConst . filterM Const
16:32:01 <lambdabot> Monoid c => [c] -> c
16:32:05 <johnw> haha
16:32:29 <mniip> traverse Const could have had the same effect tbqh
16:32:41 <glguy> :t ala Const filterM
16:32:42 <jle`> that's how lens does it
16:32:42 <lambdabot> Monoid a' => [a'] -> a'
16:33:01 <mniip> :t ala Const traverse
16:33:02 <lambdabot> (Monoid a', Traversable t) => t a' -> a'
16:33:12 <glguy> The monoid constraint on a' suggests this doesn't work correctly
16:33:23 <mniip> what no
16:33:26 <mniip> it is right
16:33:27 <jle`> :t fst . filterM (,())
16:33:28 <lambdabot> error:
16:33:28 <lambdabot>     • Couldn't match expected type ‘Bool’ with actual type ‘()’
16:33:28 <lambdabot>     • In the expression: ()
16:33:33 <jle`> :t fst . filterM (,True)
16:33:35 <lambdabot> Monoid c => [c] -> c
16:33:39 <mniip> :t foldMap id
16:33:40 <lambdabot> (Monoid m, Foldable t) => t m -> m
16:33:52 <jle`> my favorite way of writing const mempty
16:33:57 <jle`> :t fst . filterM (,False)
16:33:58 <lambdabot> Monoid c => [c] -> c
16:34:11 <glguy> Oh, right. the monoid constraint is on the inner list
16:34:16 <mniip> damn haskell
16:34:23 <mniip> in what other language could you envision,
16:34:35 <glguy> > ala Const filterM ["it's","all","good"]
16:34:37 <lambdabot>  "it'sallgood"
16:34:37 <mniip> "due to respective laws, we have  ala Const filterM = ala Const traverse"
16:35:06 <mniip> = foldMap id"
16:35:15 <MarcelineVQ> now get fancy and intersperse " " into it's all good while traversing
16:35:43 <kakashiAL> can anyone give me a simple example where FP has its limits / where its stupid to use FP?
16:36:19 <tabemann> where you have to operate in truly constant memory space
16:36:24 <Welkin> kakashiAL: programming on a bare metal microcontroller
16:36:31 <jle`> a boxing match
16:36:34 <Welkin> but then, no programming paradigm makes sense
16:36:37 <Welkin> it's all just assembly
16:36:38 <Axman6> tabemann: that's been done
16:36:42 <tabemann> everything in globals, no recursion, etc.
16:36:55 <mniip> > getConst $ traverse (Const . (:"f")) "it's all good"
16:36:57 <lambdabot>  "iftf'fsf faflflf fgfofofdf"
16:37:02 <Welkin> However!
16:37:12 <MarcelineVQ> mniip: lgtm
16:37:13 <Welkin> you can use haskell to generate the microcontroller code!
16:37:20 <Welkin> so, you can use it indirectly
16:37:21 <Axman6> http://hackage.haskell.org/package/copilot
16:37:33 <mniip> 1513211763 [03:36:03] <jle`> a boxing match
16:37:33 <Axman6> guaranteed constant time and space programs for embedded systems
16:37:39 <mniip> don't bring a knife to a haskell fight
16:37:44 <Welkin> there is a library for this
16:37:47 <Welkin> @hackage ivory
16:37:48 <lambdabot> http://hackage.haskell.org/package/ivory
16:38:10 <Welkin> there is another oen too
16:38:24 <Axman6> copilot, I already linked it
16:38:24 <jle`> mniip: what is that number next to the timestamp?
16:38:27 <Welkin> oh
16:38:41 <jle`> oh hey it's the epoch time
16:38:43 <mniip> um
16:38:43 <MarcelineVQ> Welkin: you may also be thinking of atom, which is probably out of date by now
16:38:44 <Welkin> Axman6: have you used either of these?
16:38:46 <mniip> that is the timestamp
16:38:49 <mniip> next to the timestamp
16:38:51 <jle`> heh
16:38:56 <kakashiAL> Welkin: do you maybe know a business case or something technical (working with network, database ...) where FP makes no sense?
16:38:59 <Welkin> I haven't had the chance to try any yet
16:39:06 <Welkin> kakashiAL: no
16:39:07 <Axman6> not really, played with them a bit but that's it
16:39:25 <tabemann> no kakashiAL
16:39:29 <Welkin> kakashiAL: I have to ask, FP compared to what exactly?
16:39:31 <Axman6> kakashiAL: those are both good places to use FP
16:39:34 <Welkin> what is the alternative here?
16:39:38 <MarcelineVQ> I can think of a case where FP doesn't make sense, when your boss won't pay for it. it's a bit of an edge case, but it does come up
16:39:57 <Axman6> let's also nto forget that Java was invented as an embedded systems language
16:39:57 <mniip> jle`, useful for figuring out the date and TZ when pasting conversations to other people
16:39:59 <hs_newb> dibblego: is that Identity instance?
16:40:06 <mniip> which I've done plenty of... in the past
16:40:51 <dibblego> hs_newb: Correct, the Identity instance allows wrapping  and unwrapping, with neutral behaviour. So you'd write filter using Identity in the position of (f) in filterM
16:41:16 <kakashiAL> Welkin: I did read some articles (cant find them) about multi paradigms, and it said that FP does not make everythere sense and that OOP also has its place
16:42:13 <hs_newb> > Control.Monad.filterM (\x -> Identity (f x)) [1,2,3]
16:42:15 <lambdabot>  error:
16:42:15 <lambdabot>      • Could not deduce (FromExpr Bool) arising from a use of ‘f’
16:42:15 <lambdabot>        from the context: (Num t, Show t)
16:42:30 <Welkin> anything oop can do fp can do better
16:42:50 <mniip> no
16:42:55 <mniip> well, I disagree
16:43:03 <Axman6> to quote dibblego, P = FP
16:43:20 <Welkin> "functional programming" to me is just programming
16:43:29 <dibblego> OOP = ⊥
16:43:30 <hs_newb> > Control.Monad.filterM (\x -> Identity (even x)) [1,2,3]
16:43:32 <lambdabot>  Identity [2]
16:43:33 <Welkin> oop is some strange contortion
16:43:47 <tabemann> the perfusion of OOP design patterns just goes to show how weak OOP really is
16:43:49 <hs_newb> :t Identity
16:43:50 <dibblego> hs_newb: right, but you need to unwrap the return value and you are done
16:43:50 <lambdabot> a -> Identity a
16:43:52 <Average-user1> The thing is between imperative and FP, not OOP and FP
16:44:02 <dibblego> hs_newb: there is a function called runIdentity :: Identity a -> a
16:44:05 <hs_newb> > runIdentity $ Control.Monad.filterM (\x -> Identity (even x)) [1,2,3]
16:44:06 <lambdabot>  [2]
16:44:11 <tabemann> because OOP design patterns exist because of the limitations of OOP
16:44:27 <mniip> hs_newb, now abstract it into a function
16:44:32 <dibblego> Scala likes to pretend that there is some relationship or merging of FP/OOP. And it is marketing material for suckers.
16:44:53 <tabemann> Scala is the language Java should be
16:45:02 <hs_newb> > let filter' f = runIdentity $ Control.Monad.filterM (\x -> Identity (f x))
16:45:04 <lambdabot>  <no location info>: error:
16:45:04 <lambdabot>      not an expression: ‘let filter' f = runIdentity $ Control.Monad.filterM ...
16:45:26 <monochrom> But there is! The denotational semantics of any OOP language (any language, really) is obtained by converting everything back to FP. :)
16:45:54 <dibblego> no, Scala is worse than Java. At least Java doesn't pretend.
16:46:00 <mniip> I find it hard to structure functional programs on large scale
16:46:07 <mniip> throwing everything into the same module feels kinda right
16:46:34 <monochrom> mniip: Is that because Haskell's module system is too simple?
16:46:42 <monochrom> Or rather s/simple/boring/
16:46:58 <Axman6> hs_newb: nice work
16:47:02 <hs_newb> dibblego: right but i don't understand the list applicative case 
16:47:07 <Average-user1> Maybe they don't need to be in a module
16:47:19 <dibblego> hs_newb: got it, so now that f=[], do you know what the Applicative instance for [] does?
16:47:24 <monochrom> So for example with SML's module system or with the new-fangled Backpack of Haskell would you find it easier to structure large programs?
16:47:56 <hs_newb> it applies all the f's on right side and flattens the list
16:48:06 <hs_newb> fmap f
16:48:16 <dibblego> well, it does a cross product
16:48:20 <dibblego> [a -> b] -> [a] -> [b]
16:48:28 <dibblego> it applies every function to every a
16:48:33 <ezyang> did someone say Backpack? :) 
16:48:46 <monochrom> Yeah!
16:48:54 <Axman6> edwardk showed me something cool the other day, you can use {-# UNPACK #-} in the definition of fields in data defined in backpack modules, so you can get Data.Set with unboxed keys (and values if you want to specialise on that I guess)
16:49:28 <EvanR> i just read the backpack paper again because i cant figure out how to use type classes or records to state my interface properly
16:49:38 <EvanR> when converting paper to haskell
16:49:51 <iqubic> Is there a way to create a lens into a sublist given two indexes of a sublist?
16:49:53 <edwardk> Axman6: https://github.com/ekmett/coda/tree/master/lib/coda-set <- implementation
16:50:04 <hs_newb> dibblego: that's a better way to put it 
16:50:05 <Welkin> ezyang: backpack, backpack! backpack, backpack! *dancing inanimate objects singing*
16:50:22 <hs_newb> ezyand backpack bot? :o
16:50:23 <ezyang> Axman6: Yes! It is a killer feature, IMO :) 
16:50:26 <dibblego> hs_newb: ok, have you looked at the source to filterM ?
16:50:27 <EvanR> backpack.gif
16:50:35 <Axman6> edwardk: thanks mate
16:50:58 <Axman6> exferenceBot: indeed, I've wanted that for so long,  but never realised backpack would bring that
16:50:59 <edwardk> i'm going to wind up with a few other of these. .... if we had multiple-external-library packages and the ability to push them to hackage there'd be an unpacked-containers package already ;)
16:51:33 <ezyang> edwardk: Btw, we're badmouthing your symantics package on #hackage :P (it doesn't compile on master haha) 
16:51:48 <edwardk> ezyang: i banged it out as a quick test
16:53:21 <crobbins> `StateT s1 (Reader s2) a` is really close, and i guess to allow Reader to fail via Either i could do something like `StateT s1 (ReaderT s2 (Either e)) a`
16:53:46 <Axman6> edwardk: how much of that package is just copied and pasted? are the only changes replcing a with Elem everywhere?
16:53:55 <edwardk> Axman6: 90%
16:53:58 <Tuplanolla> Do we have a package for symbolic Gauss--Jordan elimination?
16:54:11 <edwardk> Map, etc. will be the same
16:54:28 <edwardk> comes at a cost of instances and stuff, but for usecases like the stuff i have in coda its a good trade-off
16:55:19 <iqubic> So is it possible to write a lens into a sub list of the given list?
16:55:31 <Axman6> not sure what you mean by at the cost of instances
16:55:37 <hs_newb> foldr (\ x -> liftA2 (\ flg -> if flg then (x:) else id) (even x)) [[]] [1,2,3]
16:55:40 <hs_newb> > foldr (\ x -> liftA2 (\ flg -> if flg then (x:) else id) (even x)) [[]] [1,2,3]
16:55:42 <lambdabot>  error:
16:55:42 <lambdabot>      • Couldn't match expected type ‘[Bool]’ with actual type ‘Bool’
16:55:42 <lambdabot>      • In the second argument of ‘liftA2’, namely ‘(even x)’
16:57:02 <Axman6> >> [1,2,3,4] & upon (tail.tail) .~ [10,20] -- sure, in really crazy ways!
16:57:14 <Axman6> > [1,2,3,4] & upon (tail.tail) .~ [10,20]
16:57:16 <lambdabot>  [1,2,10,20]
16:57:36 <iqubic> What is that doing Axman6?
16:57:42 <Axman6> iqubic: what sort of sub list?
16:57:57 <Axman6> iqubic: ignore that, just demonstrating it's possible, don't use it :P
16:58:48 <iqubic> Like a list starting at a certain index x, and going to another index y.
16:59:08 <Axman6> someone had an example oif that yesterday...
16:59:20 <MarcelineVQ> a whole conversation in fact
16:59:32 <iqubic> And I was the one who asked about that.
16:59:42 <Axman6> > [1..10] & indices (\n -> x < n && n < 7) %~ (*10)
16:59:44 <lambdabot>  error:
16:59:44 <lambdabot>      • Couldn't match type ‘[i0]’
16:59:44 <lambdabot>                       with ‘(Integer -> Identity Integer) -> [Integer] -> Ide...
16:59:47 <iqubic> I don't remember what the result was.
16:59:52 <Axman6> :t indices
16:59:53 <lambdabot> Ix i => Array i e -> [i]
17:00:04 <Axman6> > [1..10] & Lens.indices (\n -> x < n && n < 7) %~ (*10)
17:00:06 <lambdabot>  error:
17:00:06 <lambdabot>      • Couldn't match type ‘Indexed Expr Integer (Identity Integer)’
17:00:06 <lambdabot>                       with ‘[Integer] -> Identity b’
17:00:13 <Axman6> :t Lens.indices
17:00:15 <lambdabot> (Applicative f, Indexable i p) => (i -> Bool) -> Optical' p (Indexed i) f a a
17:00:29 <Axman6> > [1..10] & Lens.indices (\n -> 3 < n && n < 7) %~ (*10)
17:00:31 <lambdabot>  error:
17:00:31 <lambdabot>      • Couldn't match type ‘Indexed Integer Integer (Identity Integer)’
17:00:31 <lambdabot>                       with ‘[Integer] -> Identity b’
17:01:38 <Axman6> > [1..10] & traversed . Lens.indices (\n -> 3 < n && n < 7) %~ (*10)
17:01:40 <lambdabot>  [1,2,3,4,50,60,70,8,9,10]
17:02:16 <iqubic> > [1..10] & (partsOf . Lens.indices (\n -> 3 < && n < 7) %~ (*10)
17:02:18 <lambdabot>  <hint>:1:46: error: parse error on input ‘&&’
17:03:05 <iqubic> > [1..10] & (partsOf . Lens.indices (\n -> 3 < n && n < 7) %~ (*10)
17:03:07 <lambdabot>  <hint>:1:66: error:
17:03:07 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:05:45 <hololeap> what's the "right" way to derive Show for something like `data Foo f a = Foo (f a) (f (f a))`
17:06:36 <hpc> just derive Show and it'll do the thing, iirc
17:06:38 <hs_newb> > liftA2 (\ flg -> if flg then (2:) else id) [True, False] [[1],[]]
17:06:40 <lambdabot>  [[2,1],[2],[1],[]]
17:07:22 <hs_newb> dibblego: yes now i see how it's implemented, very nice, i don't think i could have come up with that 
17:07:35 <hpc> oh hmm, it doesn't like the other field
17:08:40 <hololeap> i'm writing this in ghci 8.0.2 and i'm getting an error: data Foo f a = Foo (f a) (f (f a)) deriving (Show)
17:09:19 <hpc> eugh
17:09:33 <hpc> okay, you'll want StandaloneDeriving, FlexibleContexts, UndecidableInstances
17:09:40 <hpc> and then do the data definition
17:09:45 <hpc> and then deriving instance (Show (f a), Show (f (f a))) => Show (Foo f a)
17:10:10 <hpc> as for if it's worth UndecidableInstances to write that, i guess you decide
17:10:22 <hololeap> hmm... maybe it would be easier to just provide a boilerplate instance?
17:10:45 <hpc> oddly enough, i have never written an explicit Show instance myself
17:10:49 * hackage util 0.1.3.0 - Utilities  https://hackage.haskell.org/package/util-0.1.3.0 (MatthewFarkasDyck)
17:11:12 <hpc> and i don't know off the top of my head where on hackage a good reference instance might be
17:11:46 <hpc> someone else might though, if you stick around
17:11:57 <Welkin> for Show?
17:12:05 <hololeap> yes
17:12:06 <monochrom> free has an interesting Show instance for Free
17:12:21 <mniip> via Show1?
17:12:35 <mniip> this should easily be liftable via Show1
17:12:43 <monochrom> No, interesting as in it has non-trivial assumptions.
17:15:21 <mniip> @let data Foo f a = Foo (f a) (f (f a))
17:15:22 <lambdabot>  Defined.
17:15:35 <mniip> @let import Data.Functor.Classes
17:15:36 <lambdabot>  Defined.
17:15:40 <mniip> @let instance (Show1 f, Show a) => Show (Foo f a) where showsPrec d (Foo x y) = showParen (d > 9) $ showString "Foo " . liftShowsPrec showsPrec showList 10 x . showString " " . liftShowsPrec (liftShowsPrec showsPrec showList) (liftShowList showsPrec showList) 10 y
17:15:41 <lambdabot>  Defined.
17:16:22 <hololeap> wtf am i looking at
17:16:26 <mniip> @let instance Show1 f => Show1 (Foo f) where liftShowsPrec sp sl d (Foo x y) = showParen (d > 9) $ showString "Foo " . liftShowsPrec sp sl 10 x . showString " " . liftShowsPrec (liftShowsPrec sp sl) (liftShowList sp sl) 10 y
17:16:27 <lambdabot>  Defined.
17:21:19 * hackage util 0.1.4.0 - Utilities  https://hackage.haskell.org/package/util-0.1.4.0 (MatthewFarkasDyck)
17:21:30 <hololeap> heh, check this out
17:21:58 <hololeap> @let instance (Foldable f, Show (f a), Show a) => Show (Bar f a) where show (Bar f f') = "Bar " ++ show f ++ " " ++ (show . foldr (:) [] $ f')
17:21:59 <lambdabot>  .L.hs:181:52: error: Not in scope: type constructor or class ‘Bar’
17:21:59 <lambdabot>      |
17:21:59 <lambdabot>  181 | instance (Foldable f, Show (f a), Show a) => Show (Bar f a) where
17:22:21 <hololeap> @let data Bar f a = Bar (f a) (f (f a))
17:22:23 <lambdabot>  Defined.
17:22:24 <hololeap> @let instance (Foldable f, Show (f a), Show a) => Show (Bar f a) where show (Bar f f') = "Bar " ++ show f ++ " " ++ (show . foldr (:) [] $ f')
17:22:26 <lambdabot>  Defined.
17:22:48 <hololeap> > Bar [1,2,3] [[4,5],[6,7]]
17:22:50 <lambdabot>  Bar [1,2,3] [[4,5],[6,7]]
17:23:30 <hpc> mniip: ah, that's how you're supposed to do it
17:23:47 <mniip> yup
17:23:53 <mniip> I like writing show instances
17:24:01 <mniip> mechanical yes slightly puzzling work
17:25:54 <HaskYogi> Can someone explain this function to me? > baz mmx = do mx <- mmx >              x  <- mx >              return (x+1)
17:26:17 <HaskYogi> https://nikivazou.github.io/CMSC498V/lectures/Monads.html scroll down to baz
17:26:34 <HaskYogi> I'm confused about the type of mx
17:27:14 <HaskYogi> baz [[1, 2], [3, 4]] returns [2,3,4,5], which I'm trying to understand
17:29:43 <mniip> :t let baz mmx = do { mx <- mmx; x <- mx; let _ = mx `asTypeOf` ?mx; return (x + 1) } in baz
17:29:44 <lambdabot> error: parse error on input ‘}’
17:30:00 <mniip> :t let baz mmx = do { mx <- mmx; x <- mx; let { _ = mx `asTypeOf` ?mx }; return (x + 1) } in baz
17:30:01 <lambdabot> (Monad m, Num b) => m (m b) -> m b
17:30:12 <mniip> huh where's the implicit param
17:30:41 <HaskYogi> hmm ok
17:31:11 <koz_> I keep getting this error when doing 'stack install hlint': http://lpaste.net/360765 . I have tried the recommended workarounds for Arch (which I'm on), but it seems to have no effect.
17:31:16 <koz_> (I just had to update stack-static)
17:32:47 <mniip> looks like a bug to me
17:32:50 <mniip> :t do { let { z = ?x }; z }
17:32:51 <lambdabot> (?x::t) => t
17:32:54 <mniip> :t do { let { () = ?x }; z }
17:32:55 <lambdabot> Expr
17:33:03 <mniip> should still say (?x::())
17:33:16 <mniip> anyway
17:33:18 <mniip> :t let baz mmx = do { mx <- mmx; x <- mx `asTypeOf` ?mx; return (x + 1) } in baz
17:33:20 <lambdabot> (Monad m, ?mx::m b, Num b) => m (m b) -> m b
17:33:26 <mniip> HaskYogi, here's your mx type
17:33:46 <HaskYogi> miip: Thanks!
17:38:56 <hololeap> mniip: what is the 10 doing in that definition?
17:39:05 <mniip> application precedence
17:39:27 <hololeap> hmm, ok
17:39:42 <mniip> @let data Prec = Prec
17:39:44 <lambdabot>  Defined.
17:40:00 <mniip> @let instance Show Prec where showsPrec d Prec = showsPrec 10 d
17:40:02 <lambdabot>  Defined.
17:40:13 <mniip> > Just Prec
17:40:15 <lambdabot>  Just 11
17:40:45 <mniip> oh...
17:41:03 <hololeap> so is that limiting the depth?
17:41:06 <mniip> > (Prec, Prec)
17:41:08 <lambdabot>  (0,0)
17:41:09 <hololeap> when you put 10 in there?
17:41:18 <hololeap> 10 just seems arbitrary
17:41:33 <hololeap> that's why i want to know what it's for
17:41:47 <mniip> actually should be 11
17:41:54 <mniip> and showParen (d > 10)
17:42:11 <mniip> hololeap, showsPrec takes a precedence argument
17:42:25 <mniip> you're expected to check it and produce parentheses if necessary
17:44:05 <mniip> ooh, I wonder...
17:47:02 <mniip> @let x ### y = x + y
17:47:03 <lambdabot>  Defined.
17:47:41 <mniip> @let zz = 2 * 1 ### 1
17:47:42 <lambdabot>  Defined.
17:47:44 <mniip> > zz
17:47:46 <lambdabot>  4
17:47:51 <mniip> @let infixr 1 ###
17:47:52 <lambdabot>  Defined.
17:47:53 <mniip> > zz
17:47:55 <lambdabot>  3
17:48:07 <mniip> int-e, ^ not sure how I feel about this
17:48:52 <mniip> hrm I could make a previous definition compile differently
17:49:00 <mniip> or even change type
17:54:26 <mniip> :t zz
17:54:27 <lambdabot> Char
17:54:30 <mniip> @let infixl 9 ###
17:54:31 <lambdabot>  Defined.
17:54:32 <mniip> :t zz
17:54:34 <lambdabot> Char
17:54:36 <mniip> hrm
17:55:20 <mniip> let's try again
17:55:33 <iqubic> what are we doing.
17:55:46 <mniip> :t zz
17:55:47 <lambdabot> Char
17:55:49 <mniip> @let infixl 1 ###
17:55:50 <lambdabot>  Defined.
17:55:51 <mniip> :t zz
17:55:52 <lambdabot> Bool
17:56:27 <mniip> I don't think this gives any extra "powers" because it always compiles the whole module anyway?
17:57:09 <mniip> except the part where there's a pass of hint...
17:57:11 <iqubic> Why does the fixity of ### change anything?
17:57:47 <mniip> because that's how zz was defined
17:58:28 <iqubic> What is the definition of zz?
17:58:46 <mniip> 1513216428 [04:53:48] <mniip> @let zz = 'a' #### () ### True
17:59:49 <iqubic> What do #### and ### do?
18:00:01 <mniip> you can guess from their types
18:01:28 <iqubic> Are they version of const and flip const?
18:16:34 <unyu> The last topic my topology professor covered was a brief introduction to algebraic topology. He defined the notion of homotopy as well as the fundamental group. He also mentioned homology, saying that “it's harder to define but easier to compute”, but didn't provide an actual definition. What would be a good introduction to homology for someone who knows point-set topology reasonably well at an undergraduate level, but knows next to
18:16:34 <unyu> zero algebraic topology?
18:16:50 <unyu> Oops, wrong channel.
18:19:30 <longshi> unyu: What  is your intended channel for this question? Just curious :)
18:19:39 <unyu> ##math, obviously
18:19:42 <unyu> Apologies.
18:20:21 <unyu> I usually have ##math on this specific Emacs window. But this time I didn't.
18:23:09 <mnoonan> unyu: I don’t know what they are saying over in ##math, but.. get Hatcher’s book :)
18:34:58 --- mode: cherryh.freenode.net set +o ChanServ
18:50:19 * hackage Fin 0.1.0.0 - Finite totally-ordered sets  https://hackage.haskell.org/package/Fin-0.1.0.0 (MatthewFarkasDyck)
18:54:19 * hackage ansi-escape-codes 0.2.0.0 - Haskell package to generate ANSI escape codes for styling strings in the terminal.  https://hackage.haskell.org/package/ansi-escape-codes-0.2.0.0 (joegesualdo)
18:56:48 * hackage drifter-postgresql 0.2.0 - PostgreSQL support for the drifter schema migration tool  https://hackage.haskell.org/package/drifter-postgresql-0.2.0 (MichaelXavier)
19:03:26 <Average-user> Have someone done the Synacor challenge?
19:06:49 * hackage ansi-escape-codes 0.3.0.0 - Haskell package to generate ANSI escape codes for styling strings in the terminal.  https://hackage.haskell.org/package/ansi-escape-codes-0.3.0.0 (joegesualdo)
19:07:42 <glguy> Average-user: I have
19:08:56 <Average-user> glguy: How is it? Fun? Hard? Worth it?
19:09:46 * mniip just randomly decided to look back at projecteuler
19:12:49 * hackage natural-induction 0.1.0.0 - Induction over natural numbers  https://hackage.haskell.org/package/natural-induction-0.1.0.0 (MatthewFarkasDyck)
19:17:23 <mud> What kind of challenges are they? It's not real specific just from the intro page.
19:24:55 <lordcirth> mud, math/logic puzzles that require both some thinking about the problem, and a program, because you can't calculate it without a computer
19:25:38 <lordcirth> For example, one puzzle is "which is the first triangular number to have 500 divisors".  I managed to make that take 8 hours on my first try, lol.  The right way was 1s.
19:25:54 <mud> Ahh, thanks.
19:26:09 <mud> Sounds similar to a project euler one
19:26:15 <glguy> It starts like the 2006 ICFP contest where you have to make a VM to run the game
19:26:43 <mud> Nice
19:27:55 <glguy> I thought it was pretty well done. I think it would be considered a spoiler to describe too much about the puzzles
19:29:21 <mud> Yeah, that's fine. I'll add it to my todo-look-into list.
19:30:21 <Average-user> You are talking about synacor right?
19:30:41 <glguy> Yeah
19:32:41 <lordcirth> mud, sorry, I was referring to project euler :P
19:32:47 <mud> Oh xD
19:33:01 <mud> Ya I've done a decent amount of PE, but not a ton.
19:33:17 <mud> I've moved on to horrible competitive programming mostly xD
19:33:50 <mniip> you mean the kind where you have to find something between quadratic memory+linear time, and linear memory+quadratic time, or your program won't fit the limits?
19:34:32 <MarcelineVQ> mostly they just want you to come up with an answer within 60 seconds of wall-time computation, iirc. so if you're using a supercomputer you're in pretty good shape
19:34:35 <lordcirth> That sounds painful
19:34:39 <mud> Yep, pretty much. Like this was a recent contest problem http://codeforces.com/contest/903/problem/D which is pretty much just ... avoid quadratic time.
19:34:57 <mniip> that sounds super simple
19:35:13 <mniip> is this not analytical?
19:36:09 <mud> It's not a super hard problem. The time limits on the contest are short though, which raises the difficulty. I *almost* had it right, but I failed slightly for overflow reasons in C++.
19:36:31 <lordcirth> mud, time limit as in coding deadline?
19:36:45 <mniip> no, your program is run on their servers
19:36:51 <mniip> with time limits
19:37:10 <mud> lordcirth: Yeah, for this one we had 2 hours of wall clock to code and submit. Your solution has to complete in like ... 2 seconds or something like that.
19:37:14 <mniip> oh
19:37:23 <lordcirth> Yeah I saw the 2s time limit as well
19:37:54 <lordcirth> mud, so you got a slightly wrong answer due to overflow?
19:38:29 <mud> lordcirth: Yeah. I messed up my estimation of how big the answer could get, so I used the wrong type ... or I really should have just switched to haskell so I could use Integer.
19:38:43 <mniip> hahahha
19:38:52 <mniip> >ICPC-style competitive programming
19:38:53 <mniip> >haskell
19:38:55 <mud> Which, in the contest, "slightly wrong" is ... bzzt, you fail.
19:39:02 <MarcelineVQ> upcast, the silent-killer
19:39:45 <mud> I've actually done quite a bit of competitive programming in haskell, funnily enough. I used to use it for 100% of everything. But on this particular site it doesn't work great. They disabled the mutable arrays via bad compilation options (safe haskell), so it's hard to do some problems in haskell.
19:39:46 <lordcirth> I mean, "it ran fast but got the wrong answer" is not very useful IRL
19:40:19 <mud> lordcirth: Yeah, not usually :)
19:40:34 <mniip> you could uhh
19:40:39 <MarcelineVQ> like a sports scholar
19:40:45 <mniip> use a Data.Array.Array of IORef's
19:41:50 <mud> Hm, I wonder if that'd actually work. At some point I really need to just bug them to fix it, but it'll probably be annoying to convince them.
19:45:02 <Average-user> glguy: So, Do I try Synacor?
19:45:30 <glguy> do or do not
19:46:24 <glguy> I found it fun, myself
20:02:37 <mniip> hmm
20:02:42 <mniip> sorting an almost sorted list
20:04:33 <mud> mniip: How do you define almost sorted?
20:07:52 <mniip> I'm not sure
20:13:43 <mniip> hmm
20:14:55 <mniip> I have a poset
20:15:08 <mniip> and a monotonic function to a total order
20:15:20 <mniip> and I need to sort that poset By that function
20:15:42 <mniip> enumerating the poset in *some* poset-sorted order is fairly easy
20:28:14 <darthmaul212> I am having issues adding quickcheck to a brand new project I create using "stack new <project name>" . I added QuickCheck to the build-depends section of the test suite in the cabal file. When I try to run the tests I get this error: "Failed to load interface for `Test.QuickCheck'" After that QuickCheck is removed automatically from my cabal file. Any ideas on anything I might have missed?
20:28:50 <mud> Might not be possible to beat just normal sorting. In the worst case it seems obviously to be as hard as sorting, but I'm not sure if there's ... more interesting cases which can be defined where it's easier than sorting. Maybe. I remember some concept like, k-sorting, where each element is <= k indicies away from its position in sorted order.
20:29:35 <mud> darthmaul212: Edit package.yaml instead of blah.cabal. Also if you upgrade to stack 1.6.1 (the newest one) the behavior of that becomes a *lot* better and more clear.
20:29:56 <glguy> Once the cabal file is generated you can delete the package.yaml
20:30:15 <mud> Or if you don't want to use hpack (package.yaml is for that) ... yeah you can do that. Though hpack is nice, IMO.
20:31:19 <darthmaul212> ok I'll try upgrading my stack version.
20:39:13 <darthmaul212> The stack installer installs to my home directory now. When I first installed it it went to /usr/local/bin/stack. Did stack change its install directory? I can't recall how I first installed it. (I am currently on 1.5.1)
20:41:03 <MarcelineVQ> stack upgrade and stack install  place the new bins in ~/.local/bin
20:41:45 <mud> darthmaul212: I'm not sure if it's changed. As far as I recall it's gone in ~/.local/bin for quite a while.
20:44:05 <MarcelineVQ> idk where the sh script installs it to, and package managers all have their own way to dealing with things. Personally I'd uninstall stack from there after you have the new bin it placed in ~/.local/bin  and just use that new one by pointing your path there, since that's where stack is going to put things when you  stack install  anyway
20:44:43 <johnw> has anyone else had problem with Haddock documentation used within .hsc files?  It seems to be associated documentation with definitions in unpredictable ways
20:45:30 <darthmaul212> Ok, I'll try that. thanks
20:46:19 * hackage rgb-color-model 0.2.0.0 - Haskell types for working with RGB colors  https://hackage.haskell.org/package/rgb-color-model-0.2.0.0 (joegesualdo)
21:01:36 <dmj`> jle`: o/
21:02:49 * hackage tart 0.1.2 - Terminal Art  https://hackage.haskell.org/package/tart-0.1.2 (JonathanDaugherty)
21:06:45 <mniip> igh
21:06:49 <mniip> my hash is slow af
21:09:51 <mniip> my original was much faster
21:10:12 <mud> I think this AoC uses some term that was defined in a previous problem I skipped ...
21:12:26 <byorgey> mud: there is a link
21:13:32 <mud> Oh, there is. Ah, that's one I actually did.
21:14:33 <glguy> Is jle` broadcasting?
21:16:18 * hackage natural-induction 0.1.0.1 - Induction over natural numbers  https://hackage.haskell.org/package/natural-induction-0.1.0.1 (MatthewFarkasDyck)
21:16:21 <jle`> couldn't start on time, travel stuff v.v
21:16:25 <jle`> but working in solo now
21:23:05 <dminuoso> https://gist.github.com/dminuoso/371b2a4f246e5af7ea65302ab558e3da <- what exactly is the issue here? Is my instance not of the specified form?
21:23:13 <mniip> ugh this is taking a while
21:23:36 <mniip> at least it's not eating memory
21:24:15 <dminuoso> Although I guess `Int` is not a type variable, but why will this not work?
21:24:21 <Axman6> dminuoso: why have you restricted it to Int?
21:24:31 <dminuoso> Axman6: No particular reason.
21:24:58 <Axman6> it won't work becaus eyou can still write instance Functor (Either a) and then which instance to use for Right True becomes ambiguous
21:25:15 <mud> dminuoso: You just need that extension if you want it to work, probably. Though yeah, it's a bad idea.
21:25:30 <Axman6> you _can_ what you're asking for with FlexibleInstances like it says
21:30:46 <dminuoso> Axman6: Whats the use case to allow this then?
21:30:58 <dminuoso> I mean for a moment I was thinking about behavior akin to C++ partial specialization
21:31:49 <mniip> dfs is hard
21:31:50 <dminuoso> Axman6: And is it truly ambiguous? Even with NoOverlappingInstances?
21:32:11 <mniip> dammit
21:32:25 <mniip> 115th and 166th
21:32:29 <EvanR> whats NoOverlappingInstances
21:32:42 <Gurkenglas> ContT r appears not to be an MFunctor, but is there any particular Cont r a one could not have implemented as forall m. Monad m => ContT r m a?
21:32:51 <jle`> ooh this was my best score ever today
21:32:53 <jle`> too bad i started late
21:32:56 <mud> mniip: Not bad
21:33:03 <dminuoso> EvanR: Something I spotted in here: https://hackage.haskell.org/package/hint-0.7.0/docs/Language-Haskell-Interpreter-Extension.html :o
21:33:13 <mniip> mud, I have 234 points in the global leaderboard
21:33:21 <dminuoso> And on some older entries on the haskell-beginners mailing list.
21:33:23 <mniip> had a couple days where I was fast enough
21:33:26 <EvanR> oh
21:33:33 <Axman6> well, there's already an instance of Functor (Either a), so there will be overlaps
21:33:33 <EvanR> it has No versions of every extension
21:33:39 <mud> I would think NoOverlappingInstances is just the thing that turns off the OverlappingInstances extension. Except it's off by default ...
21:33:56 <EvanR> yeah its not an extension, its the usual situation
21:34:01 <dminuoso> Ah fair enough
21:34:20 <jle`> missed the global leaderboard by 7 minutes, started 5 minutes late
21:34:22 <jle`> feels bad
21:35:12 <mud> mniip: I think I have 81 + 62 or something.
21:35:22 <mud> I can't tell where it says for sure xD
21:35:37 <jle`> i'm happy i made a fancy monoid for Day 12
21:35:42 <jle`> cause i got to reuse it for part 2 today
21:35:57 <mud> I'm really not a fan of their scoring system myself ... I guess they wanted to keep it simple or something, but it ends up just seeming kind of useless to even bother once you take longer than 5 minutes to think.
21:35:58 <Gurkenglas> Is the problem that doing it as forall m. Monad m => ContT r m a imposes an order on the calls to the continuation which was not there in Cont r a, so there are in fact multiple possible forall m. ContT r m a for many Cont r a, but no canonical one?
21:36:56 <Gurkenglas> Could one build an unsafe cast Cont r a -> forall m. ContT r m a that chooses any order?
21:38:54 <Gurkenglas> Could one build "class Monad m => CommutativeMonad m where witnesscommutativity :: Cont r a -> ContT r m a"?
21:38:56 <jle`> and i know i'm going to miss the starting time of AoC tomorrow
21:38:58 <jle`> because i'll be on a plane
21:40:05 <cocreature> wow part1 took way too long because I was counting the free instead of the used squares …
21:40:37 <jle`> heh
21:41:05 <jle`> second part took me a while because i accidentally counted the diagonals
21:41:39 <EvanR> i have 7 functions whose types are going to be a biotch... so I just didnt write them. it type checks first time lol
21:41:49 <EvanR> type inference wins flawless victory
21:42:08 <mud> What was the second part, if it's easy to specify?
21:42:22 <mud> EvanR: Hah, nice.
21:42:33 <mniip> mud, so you get a 128x128 pattern of bits
21:42:40 <mniip> count connected components
21:42:56 <mud> Oh okay, thanks.
21:43:08 <EvanR> except the types dont make sense... 
21:43:22 <EvanR> o_O
21:43:26 <Gurkenglas> Identity and Reader easily implement witnesscommutativity, Maybe can do it with teaspoon. Are there other commutative monads?
21:44:35 <Gurkenglas> IdentityT and ReaderT lift commutativity and also witnesscommutativity, MaybeT... hmm
21:46:27 <jle`> mud: yeah you can probably re-use your code from day 10
21:48:16 <Gurkenglas> "In continuation-passing style function result is not returned," do Control.Monad.Cont docs even grammar
21:48:43 <Axman6> what's after the comma?
21:49:28 <EvanR> i can parse that effortlessly, maybe i am stupid or english is moving on
21:51:48 <mniip> is there a grammar error?
21:52:14 <mniip> I don't see it
21:52:47 <Gurkenglas> Maybe I'm the stupid one, but shouldn't there be a the
21:52:53 <Gurkenglas> Or some other article
21:53:15 <Gurkenglas> Or "no function result is returned"
21:53:28 <mniip> could be but it don't feel wrong to omit it
21:53:35 <mniip> doesn't*
21:54:56 <Lokathor> the quote absolutely has an error according to american english
21:55:04 <Lokathor> but that's not the only form of english
21:55:38 <Gurkenglas> Let's find out! To #English! https://www.youtube.com/watch?v=DKq4uoGdnFw
21:55:59 <Lokathor> nah, i'm gonna watch a guy talk about SIMD
21:56:40 <jle`> is there a Word4 ?
21:56:55 <mniip> no I had to make one
21:57:24 <Lokathor> why would you make one >_>
21:57:35 <jle`> for AoC today, heh
21:57:48 <Lokathor> i formatted it into a string as a hex value then iterated the string
21:58:00 <EvanR> i think broken english of a russianmen has leaked into my brain
21:58:02 <glguy> I kept the rows in Integers
21:58:23 <jle`> i mean my grid was a nested list of Bool
21:58:33 <jle`> but i wanted to be able to type [0..] to generate the rows
21:58:38 <jle`> instead of [0..127]
21:58:40 <jle`> hehe
21:58:45 <jle`> (that's the only reason)
21:58:58 <Lokathor> i think my data path was... String to [String] to [KnotHash] to [Bool] and then a flood fill thing
21:58:58 <EvanR> Word4 seems legit
21:59:16 <EvanR> Word 4 (dependent type) would be nicer
21:59:25 <jle`> yeah that's just `Finite 128`
21:59:42 <jle`> api-wise
21:59:45 <EvanR> but secretly backed by a machine word
22:00:02 <Lokathor> ugh
22:00:06 <jle`> hm that doesn't sound too hard to do actually
22:00:06 <Lokathor> 60 wasted bits
22:00:15 <EvanR> that you dont know about
22:00:32 <EvanR> because you also dont know saving 60 bits would slow everything else down
22:00:36 <jle`> meh the only reason i wanted Word4 was to abuse syntactic sugar
22:00:45 <jle`> isn't that the only reason any of us want anything
22:00:59 <EvanR> i want to abuse semantics
22:01:01 <EvanR> i mean use
22:01:24 <Lokathor> i like haskell's relative lack of syntax
22:02:18 * hackage natural-induction 0.1.1.0 - Induction over natural numbers  https://hackage.haskell.org/package/natural-induction-0.1.1.0 (MatthewFarkasDyck)
22:04:03 <mniip> I like the way 10-line loops in programming languages collapse into a few words in haskell
22:04:57 <Lokathor> today i talked to a person who was shocked at the idea that you could somehow make "map" generic over vector, maybe, and either
22:05:39 <cocreature> Lokathor: gopher? :)
22:06:09 <Lokathor> no, rustacean, but Rust doesn't have higher kinded types/traits yet
22:06:13 <mniip> hmm
22:06:15 <mniip> that reminds
22:06:19 <Lokathor> so you can't write Functor
22:06:29 <mniip> I wanted to make a package for induction over GHC TypeLits
22:06:53 <EvanR> Functor is the most undeniable abstraction
22:07:39 <mniip> ooh I almsot wrote it even
22:08:18 <Lokathor> 'undeniable' ?
22:08:56 <EvanR> if theres an a ~ b in the context, does that equate to anything being passed at runtime?
22:10:27 <jle`> i don't believe so
22:11:48 <Gurkenglas> It appears the exception system allows us to write callCC without actually needing Cont
22:15:12 <jle`> man, 1.0s for part 1, i didn't realize it was so bad
22:18:22 <glguy> 1s to do what?
22:19:05 <jle`> to compute the answer
22:19:29 <jle`> i'm a bit surprised
22:19:44 <jle`> it might be my hashing algorithm
22:19:47 <glguy> May day 14 runs in 0m0.171s (both parts)
22:19:52 <glguy> My*
22:20:23 <jle`> oh okay, my hashing algorithm itself is 27ms
22:20:32 <jle`> so it makes sense to have ~1s for 128 of them
22:20:43 <mniip> hmm with some minimal fixes I got it running
22:21:16 <mniip>  > natSingleton :: NatBaseComp NatUnary 10 123
22:21:17 <mniip> BaseCompxBp1p (UnarySucc (UnarySucc UnaryZero)) (BaseCompxBp1p (UnarySucc UnaryZero) (BaseCompxBp1p UnaryZero BaseCompZero))
22:21:19 <mniip>  > posSingleton :: PosBase NatUnary 10 123
22:21:19 <mniip> BaseDigit (UnarySucc (UnarySucc (UnarySucc UnaryZero))) (BaseDigit (UnarySucc (UnarySucc UnaryZero)) (BaseLead (UnarySucc UnaryZero)))
22:24:11 <nf7> What can I use as my packages manager for a project? I'm expecting there to be a file that dictates various build/run commands as well as package dependencies. For example, if I was creating a Clojure project I'd use `leiningen`, if I was creating a Node project I'd use `npm`, etc. I'm trying to install a JSON parser/encoder for Haskell, and it says to install the package globally on your system. I would 
22:24:17 <nf7> really rather not do this, as I'd like to keep the project as self contained as possible.
22:24:31 <jle`> nf7: who is "it"?
22:24:41 <jle`> i don't think i know anyone who would suggest installing packages globally in haskell
22:24:45 <jle`> at least not for the past decade or so
22:24:51 <mniip> jle`, mind taking a look? http://lpaste.net/360772
22:24:55 <cocreature> use cabal sandboxes/new-build or stack
22:25:05 <Gurkenglas> Lens.argument contramaps over the argument, what maps over the result?
22:25:21 <Gurkenglas> (traverse, I know, but I want the correspondent to argument)
22:25:27 <mud> nf7: You might be looking for 'stack': https://docs.haskellstack.org/en/stable/README/
22:25:42 <jle`> nf7: also check the date on whatever tutorial you are reading!
22:25:43 <Gurkenglas> Wait no ((->) r) is not Traversable wut am i talkin
22:25:59 <jle`> nf7: if it says to install something globally, it's probably written a long time ago, and much of it might not even be relevant anymore
22:26:26 <jle`> mniip: quite a doozy :)
22:26:29 <mniip> yeah
22:26:30 <nf7> Ok I will make sure I'm using an up to date tutorial. And I'll check out Stack. Thanks a lot! Also, what is Cabal? It seems like half of the people use Stack, and the other half use Cabal.
22:26:33 <mniip> the problem is
22:26:44 <mniip> there inevitably has to be a package spiced with unsafeCoerce
22:26:48 <mniip> somewhere down the line
22:26:55 <mniip> before you can write something like inducePeano
22:26:59 <mud> nf7: That's about right. They're mostly competing tools for the same basic-ish job.
22:27:01 <mniip> literally unimplementable without unsafeCoerce
22:27:02 <jle`> nf7: cabal-install and stack are two build tools with overlapping functionality
22:27:20 <jle`> nf7: Cabal is a library that both cabal-install and stack use, and it's the standard for describing haskell packages
22:27:27 <nf7> Ok, any particular recommendation for a beginner to learn between the two?
22:27:54 <mud> nf7: I'm sure you'll get recommendations for both depending on who you ask :)
22:28:00 <jle`> you've come at a bit of a contentious time.  from personal experience, stack has a nicer beginner story with more tutorials and readily available ifnormation
22:28:01 <nf7> Hahh ok.
22:28:24 * hackage natural-induction 0.2.0.0 - Induction over natural numbers  https://hackage.haskell.org/package/natural-induction-0.2.0.0 (MatthewFarkasDyck)
22:28:37 <jle`> i think they mostly are feature compatible at this point, but it was easier for me to find info on using stack at first.  but it's probably different for everyone
22:29:01 <nf7> Thanks for the information.
22:29:06 <jle`> oh, one important difference is that stack integrates with stackage, whcih provides self-consistent snapshots/freezes of the entire haskell ecosystem
22:29:17 <jle`> if that is important to you
22:29:39 <mniip> jle`, anyway, the problem is
22:29:45 <mniip> these recursion schemes are kind of awkward
22:29:51 <mniip> if nothing else
22:29:55 <jle`> mniip: most TypeLits stuff is unimplementable without unsafeCoerce, unless you build a typechecker plugin i think
22:30:06 <nf7> I'm interested in using Haskell as my "backend" language for creating single page applications. So basically my frontend will be a thick client (Vue.js single page app) that only needs to be served as static files from the server, and then supported through a REST API, which I would be implementing in Haskell.
22:30:16 <jle`> well i won't say most anymore, things have gotten a little better
22:30:38 <mniip> I feel like this isn't ready for pushing to hackage
22:31:32 <jle`> does it...work?
22:31:45 <mniip> it compiles
22:31:53 <mniip> when I wrote it I was sure it is bug-free
22:32:16 <cocreature> it typecheck, ship it!
22:32:29 <mniip> you missed the part where unsafeCoerce comes to play
22:32:30 <jle`> nf7: sounds like a fun job!
22:32:33 <mniip> the part is everywhere
22:32:58 <jle`> it's impossible to avoid it without using a typechecker plugin
22:33:06 <jle`> since Nat has...no structure at all
22:33:22 <jle`> and neither does <=? or anything
22:33:45 <nf7> jle`: :)
22:33:46 <jle`> the best you can do is factor out your unsafeCoerce's into small provable chunks
22:33:54 <jle`> with meaning
22:33:54 <mniip> I'll just push an undocumented 0.0.0.0 for yall to see
22:34:02 <jle`> and then write your program in terms of those
22:34:06 <mniip> hmm do package candidates compile docs?
22:34:12 <nf7> What are people here using Haskell for in particular? Any specific problem domain that you like it for?
22:34:15 <EvanR> provable, in the comments? :)
22:34:33 <EvanR> nf7: video games
22:34:36 <cocreature> mniip: I’m not sure they compile docs but you can definitely upload docs for candidates
22:34:37 <jle`> that's essetnailly what reflections does, once you get the basic primitives (in terms of unsafeCoerce), you can write a lot in terms of them
22:34:54 <jle`> nf7: some of my data analytics stuff :)
22:35:21 <rightfold> nf7: job scheduling, secret passing, bulk data processing, HTTP proxying, real-time notifications
22:36:10 <jle`> i used it this year with a class i was teaching, to write an auto-grader submission box
22:36:20 <jle`> really anything i write in haskell is really fun to maintain
22:36:29 <jle`> so anything that i plan on maintaining and improving over time has to be written in Haskell
22:36:41 <jle`> have you ever tried refactoring, improving, maintaining a project in ruby/python/java/etc.?
22:36:45 <jle`> it's a nightmare
22:37:03 <rightfold> Yep, PHP. was pretty easy
22:37:04 <nf7> Yes, it can be rediculous if you're working with people who don't like coding standards.
22:37:13 <jle`> with haskell you pretty much get compiler-verified refactors, so you don't have to spend a month re-learning exactly what you were thinking when you were writing the project
22:37:52 <mniip> huh
22:37:54 <rightfold> The trick is to write exclusively good code and using formal methods
22:38:23 <jle`> haskell's "killer app" for me is maintainability and refactorability
22:38:25 <rightfold> Don’t ever write bad code and you won’t have any bad code 🎉
22:38:37 <mniip> jle`, http://hackage.haskell.org/package/singleton-typelits-0.0.0.0/candidate/docs/GHC-TypeLits-Singletons.html
22:38:50 <rightfold> This one easy trick. Consultants hate me.
22:39:22 <mniip> induceBaseComp :: forall r b q p m. (KnownNat b, KnownNat m) => r b -> (forall m. KnownNat m => q m) -> (forall k n. (KnownNat b, (1 + k) <= b, KnownNat n) => q k -> p n -> p ((1 + k) + (b * n))) -> p 0 -> p m
22:39:25 <mniip> howdya like that
22:39:28 <EvanR> ok
22:39:42 <EvanR> good PHP code using formal methods 
22:39:53 <EvanR> i hear they will be using it for space probes
22:40:37 <jle`> mniip: pretty nifty
22:40:46 <mniip> yeah
22:40:48 <jle`> i wonder if it could fix problems i've been avoiding
22:40:56 <mniip> I've been missing a package like this myself a few times
22:41:13 <mniip> inducePeano :: KnownNat m => (forall n. KnownNat n => p n -> p (1 + n)) -> p 0 -> p m
22:41:18 <mniip> stuff like this could come handy
22:41:29 <mniip> arbitrary-base induction is just there for completeness really
22:43:37 <jle`> yeah that one jumped out at me
22:43:52 <jle`> induceIsZero is neat too
22:47:33 <EvanR> its funny how ease it is to get code to compile without type sigs... that is wrong
22:48:06 <EvanR> at least if the type is wrong thats a red flag
22:48:12 <EvanR> the inferred type
23:02:41 <koz_> What do I need to put in an executable section of a Cabal file to tell GHC to optimize the binary?
23:02:49 * hackage clist 0.2.0.0 - Counted list  https://hackage.haskell.org/package/clist-0.2.0.0 (MatthewFarkasDyck)
23:02:56 <cocreature> koz_: ghc-options: -O2
23:03:03 <koz_> cocreature: Just -O2?
23:03:11 <glguy> Cabal optimizes by default
23:03:28 <glguy> but you can add -O2 to turn additional passes on
23:03:28 <koz_> glguy: Oh, so I don't need to add anything, then?
23:03:31 <koz_> Ah.
23:03:48 <cocreature> generally, I also wouldn’t put it in the cabal file and instead pass it on the command line
23:05:20 <koz_> OK, I have a program which is drawing absurd boatloads of memory. How would I go about diagnosing why it allocates so much?
23:05:29 <rightfold> Almost all my let and where bindings have type signatures
23:05:41 <rightfold> I hate type inference
23:05:42 <cocreature> koz_: memory profiling?
23:05:49 <koz_> cocreature: How would I go about doing that?
23:05:49 <mud> First step would be profiling, yeah.
23:06:00 <cocreature> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling-memory-usage
23:06:33 <rightfold> I also like type inference for use sites
23:06:46 <glguy> Another step is to learn about evaluation in Haskell and to be able to be intentional about how much memory things should be using
23:08:54 <EvanR> you can control the amount of memory the code uses, good. you dont have to if you dont want to, good.
23:09:24 <EvanR> lucky we have both
23:12:10 <koz_> OK, I'll try the profiling method first.
23:12:23 <koz_> (once stack rebuilds all the deps)
23:22:20 * hackage Fin 0.1.1.0 - Finite totally-ordered sets  https://hackage.haskell.org/package/Fin-0.1.1.0 (MatthewFarkasDyck)
23:25:52 <EvanR> i went out of my way to write this code with no dependencies...
23:26:00 <EvanR> against some interface
23:26:02 <EvanR> http://lpaste.net/360773
23:26:21 <EvanR> but its pretty painful... do i want backpack
23:26:54 <mniip> what documentation should I write for induceXxx
23:26:56 <mniip> I'm stumped
23:29:01 <rightfold> -- | Induces xxx.
23:29:27 <EvanR> its like... need a monad with a couple extra "commands"... but a few pure functions in the interface. which dont jive with a typeclass
23:29:34 <mniip> inducePosBase :: forall r b q p m. (KnownNat b, KnownNat m) => r b -> (forall m. KnownNat m => q m) -> (forall k n. (KnownNat b, 1 + k <= b, KnownNat n) => q k -> p n -> p (k + b * n)) -> (forall k n. (KnownNat k, 1 + k <= b, k ~ (1 + n)) => q k -> p k) -> p (1 + m)
23:29:40 <mniip> rightfold, good luck formulating that
23:29:41 <koz_> mniip: Wat.
23:29:56 <jle`> -- | Induces PosBase
23:29:59 <koz_> Are you trying to state some kind of theorem in the type system?
23:30:00 <rightfold> -- | Obvious.
23:30:10 <koz_> -- | What is this I don't even.
23:30:20 <EvanR> it looks like an induction principle
23:30:21 <jle`> mniip: um maybe you can just give an example usage
23:31:08 <mniip> koz_, ok I'll just label them with a progression from Obvious. to What is this I don't even.
23:31:14 <EvanR> which transcend the notion of axiom and dont require proof
23:31:36 <koz_> mniip: Finish with -- | I have unleashed an Old One.
23:31:53 <koz_> Sorry, should be: --| Unleashes Nyarlalhotep.
23:32:04 <koz_> (maybe sp)
23:32:28 <EvanR> some of that syntax is a sad necessity of haskell type level shenanigans :(
23:33:31 <mniip> well an example is easy as pie
23:33:55 <mniip> imagine if you have a divide and conquer algorithm for a sized vector
23:33:55 <rightfold> confusing :: Applicative f => LensLike (Rift (Yoneda f) (Yoneda f)) s t a b -> LensLike f s t a b
23:34:05 <koz_> rightfold: Yeah, love that name.
23:34:18 <koz_> (despite what it does being rather simple to explain)
23:35:11 <RaptorJesus> oh hi mniip 
23:35:34 * RaptorJesus pats mniip on the head
23:35:57 <EvanR> rift yoneda yoneda
23:36:09 <rightfold> Oculus Rift
23:36:44 <EvanR> at some point we need "lens poetry" like haskell answer to perl poetry
23:37:16 <RaptorJesus> mniip, teach me how to haskell
23:37:42 <EvanR> not like my last paste
23:45:25 <koz_> I tried using hp2ps, but the graphic it outputs truncates the exact name of the function which allocs the most.
23:48:02 <koz_> Is there a way I can figure out what function that is?
23:48:21 <phadej> mniip: about inducePosBase: write the latex formulas, with "math", so you can at least unfold the haskell encoding of that
23:49:02 <koz_> (as in, its actual name)
23:49:19 <cocreature> koz_: iirc it’s not hp2ps that cuts off the name but GHC. there is an -L RTS option that allows you to set the maximum length of cost centre names
23:49:45 <koz_> cocreature: So I should pass -L some-big-number?
23:51:01 <koz_> Alrighty, running again, woo.
23:53:21 <phadej> mniip: e.g. induction : ∀ (p : ℕ → Type) → p 0 → (∀ m. p m → p (1 + m)) → ∀ (n : ℕ) → p n (that's agda though, but not having KnownNat everywhere helps ;)
