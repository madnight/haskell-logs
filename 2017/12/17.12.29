00:21:55 * hackage yaml 0.8.25.1 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.25.1 (MichaelSnoyman)
01:20:01 * hackage slate 0.4.0.0 - A note taking CLI tool.  https://hackage.haskell.org/package/slate-0.4.0.0 (evuez)
01:34:07 <Disavowed> Evening all. Any recommended web framework for a newbie?
01:34:33 <liste> Disavowed: scotty
01:34:44 <liste> @hackage scotty
01:34:44 <lambdabot> http://hackage.haskell.org/package/scotty
01:34:48 <Disavowed> Yesod and Happstack seem like the front-runners, but the latter's website isn't up to much at present
01:34:56 <Disavowed> liste: Oh wow really? Nice, thank you!
01:35:31 <liste> Disavowed: yes, it's simple, but sacrifices some terseness and type safety
01:36:11 <cocreature> Spock might also be worth a look
01:36:36 <liste> yes, Spock is scotty's "big brother", it brings back safety at the cost of some advanced type system features
01:40:56 <zomg> Scotty is definitely something that would be familiar to someone who's used web frameworks in other languages before Haskell at the very least :)
01:41:08 <zomg> well, look familiar
01:42:16 <nicknight> heyy all
01:44:34 <Disavowed> cocreature: liste: which do you think would be better for a Haskell newbie?
01:44:51 <liste> Disavowed: scotty
01:45:07 <liste> Spock once you learn type families
01:46:19 <Disavowed> liste: I really appreciate this, thank you
01:46:56 <cocreature> yeah scotty is definitely easier to get started with
01:47:11 <Disavowed> Nice, thank you both
01:47:39 <Disavowed> I'm actually stuck in a tent in New Zealand for most of the week - do any of you know any good offline resources?
01:48:01 <Disavowed> \No worries if not - I'll find a way around it
01:50:08 <liste> Disavowed: you can build offline haddocks for your dependencies. what build tool are you using? stack?
01:52:05 <Disavowed> liste: I am but I'm not wedded to it because I'm only about 30 minutes into using it, so if you think of one that'd be better for me, I'll cheerfully switch!
01:52:23 <Disavowed> (so far I really like it. It's better than leiningen!)
01:54:51 <liste> Disavowed: I think I missed a line, which one are you using now?
01:54:59 <Disavowed> Stack so far mate, sorry
01:57:48 <liste> then just "stack haddock" should be enough (no reason to switch)
02:00:00 <Disavowed> liste: annnnd I think you just taught me how to install libraries! Thank you again - you've been wonderful this evening.
02:00:21 <liste> stack haddock builds the documentation
02:00:57 <Disavowed> liste: I realised just too late. Looks like I add it to my cabal file and then run build
02:01:07 <Disavowed> Either way, thank you
02:10:32 * hackage tasty-silver 3.1.11 - A fancy test runner, including support for golden tests.  https://hackage.haskell.org/package/tasty-silver-3.1.11 (PhilippHausmann)
02:20:29 * hackage haskell-lsp-client 1.0.0.1 - A haskell package to build your own Language Server client.  https://hackage.haskell.org/package/haskell-lsp-client-1.0.0.1 (JaroReinders)
02:25:51 <[Leary]> > fmap undefined Nothing :: Maybe Int
02:25:53 <lambdabot>  Nothing
02:26:28 <[Leary]> Type coercion from laziness :D
02:33:25 * hackage HSlippyMap 2.6 - OpenStreetMap Slippy Map  https://hackage.haskell.org/package/HSlippyMap-2.6 (apeyroux)
02:41:30 <jonna> How can I import Graphics.HGL to a stack project? I can't figure out what to add to my .cabal and/or stack.yaml to get it to work...
02:48:30 <cocreature> jonna: you’ll have to add the HGL library to the build-depends section in your cabal file and probably also add it to the extra-deps section in your stack.yaml
03:00:23 <jonna> Adding just HGL to .cabal I get advised to add HGL-3.2.3.1 to extra-deps in .yaml. I have done that but get an error when I run this
03:12:30 * hackage ats-format 0.1.0.8 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.8 (vmchale)
03:29:55 * hackage HSlippyMap 3.0 - OpenStreetMap Slippy Map  https://hackage.haskell.org/package/HSlippyMap-3.0 (apeyroux)
03:43:08 <werner__> Hi, when I type "(V3 1 2 3) * 2.5" into ghci, I get "V3 2.5 5.0 7.5". I know that V3 has Num a => Num (V3 a), but how does the 2.5 fit into that? Why am I not required to type (V3 2.5 2.5 2.5)?
03:48:09 <liste> :t fromInteger
03:48:10 <lambdabot> Num a => Integer -> a
03:48:32 <liste> werner__: literals use that ↑
03:49:00 <liste> @let data Foo = Foo deriving (Show)
03:49:02 <lambdabot>  Defined.
03:49:11 <liste> @let instance Num Foo where fromInteger _ = Foo
03:49:13 <lambdabot>  .L.hs:180:10: warning: [-Wmissing-methods]
03:49:13 <lambdabot>      • No explicit implementation for
03:49:13 <lambdabot>          ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
03:49:19 <liste> > 5 :: Foo
03:49:20 <[exa]> werner__: the correct types can propagate "backwards"
03:49:21 <lambdabot>  error:
03:49:21 <lambdabot>      • No instance for (Num Foo) arising from the literal ‘5’
03:49:21 <lambdabot>      • In the expression: 5 :: Foo
03:49:21 <obelisk> Which book is the best to learn haskell?
03:49:41 <obelisk> I am looking for a book and I am prior programmign experience but little experience in function programming
03:49:45 <[exa]> obelisk: depends on whether you already have some programming experience
03:49:48 <obelisk> *I have
03:49:57 <obelisk> [exa]: yes I do
03:50:04 <werner__> I understand that, but why does it work with 2.5? That's not an Integer right?
03:50:19 <liste> oh, 2.5. now that's a more interesting question
03:50:36 <liste> sorry, I missed that it's a decimal number
03:50:39 <[exa]> obelisk: fast and nice way is 'learn you a haskell for great good', it goes to complicated stuff but it doesn't have many practical examples so you'll need invent some your own on the path
03:50:57 <[exa]> obelisk: the other possibility is 'real world haskell', that one is extremely good
03:51:25 <tabaqui> why does MonadBase use FunctionalDependencies?
03:51:27 <[exa]> obelisk: also, do you know prolog?
03:51:44 <obelisk> [exa]: nope
03:51:49 <tabaqui> base monad defines lifted monad
03:51:53 <obelisk> I come from a C, C++, Python etc. background
03:51:53 <liste> werner__: https://hackage.haskell.org/package/linear-1.20.7/docs/src/Linear-V3.html#line-179
03:51:58 <obelisk> nothing functional or lispy
03:52:09 <tabaqui> but, f.e. we can transparent lift Maybe and Either e into List
03:52:12 <[exa]> obelisk: if you want to understand how the type system works, having some prolog experience helps a lot
03:52:16 <liste> werner__: so apparently V3 is also Fractional
03:52:27 <tabaqui> like Nothing/Left _ -> []
03:52:35 <tabaqui> Just x/Right x -> [x]
03:52:35 <werner__> Aha, and fromRational is then implicitly applied to the 2.5?
03:52:43 <[exa]> obelisk: also, there's 'teach yourself scheme in fixnum days' book that will get you to the "functional" style probably easier than starting with haskell
03:53:38 <[exa]> werner__: if I understand your question correctly, is it "why doesn't it fail because V3 1 2 3 is 'V3 Integer' and not float?"
03:54:06 <liste> werner__: yes
03:54:40 <[exa]> ...I meant '..and not V3 Rational' ?
03:54:41 <werner__> No, just why I could simply multiply 2.5 with a V3.
03:55:21 <werner__> But I understand thanks,
03:55:45 <[exa]> oh so. :]
03:58:11 <obelisk> [exa]: thanks
03:58:19 <obelisk> [exa]: i like the look of learn you a haskell
03:58:29 <obelisk> [exa]: sort of reference like, but at the same time not really
04:01:01 <nyberg> werner__: There's also "What I wish I knew when learning haskell" to look through while learning
04:01:15 <nyberg> will make it much easier
04:06:53 <werner__> Thanks a lot.
04:13:00 <edwardk> werner__: there is a Num instance for V3 a given a Num instance for a
04:13:05 <edwardk> oh, they left
04:14:20 <liste> also a Fractional instance for V3 given a Fractional instance for a, which was the baffling part
04:14:51 <liste> because the scalar that was used for multiplication was not an integer
04:15:13 <lseactuary> question if i have bathrooms (basic type, [bathroom_id]) and a predicate isoccupied :== yes | no then is the sequence of bathroom ID's tuples i.e. <(bathroomId, occupied), (bathroomid2, free)>
04:15:31 <lseactuary> i.e. the sequence would be a function N -> seq(bathroomid x status) or is it just function N -> seq(bathroomid) but then how do i give the status
04:19:09 * hackage servant-auth-cookie 0.6.0.1 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.6.0.1 (zohl)
04:20:25 * hackage mmark 0.0.4.0 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.4.0 (mrkkrp)
04:35:29 <edwardk> liste: guess i spend enough time in glsl and the like to not be weirded out by pointwise lifting of otherwise undefined operations
04:38:54 * hackage dotenv 0.5.2.1 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.5.2.1 (camm)
04:40:15 <lseactuary> can someone please help me with this set theory question. i have made the solution but i am unsure if it is correct or not.
04:41:43 <Adluc> lseactuary: dont ask to ask
04:46:24 <lseactuary> Adluc - uploading 2 min please
04:55:08 <lseactuary> https://imgur.com/a/U4RLj i have put the question and my solution
04:55:11 <lseactuary> it is incomplete i think
04:55:15 <lseactuary> but im unsure how else to do this
04:59:59 * hackage ocaml-export 0.2.0.0 - Convert Haskell types in OCaml types  https://hackage.haskell.org/package/ocaml-export-0.2.0.0 (mchaver)
05:03:15 <Profpatsch> What’s the strategy of catching just one sum of an exception?
05:03:33 <Profpatsch> Rethrow the argument on other sums?
05:04:56 <edwardk> Profpatsch: you can use catching with lens to do it
05:05:19 <edwardk> as you can use arbitrary folds and prisms and stuff to filter it down
05:06:09 <edwardk> e.g. catching _Underflow     handles just the Underflow case of ArithException
05:08:59 <edwardk> i also managed to bend over backwards far enough using crazy bits of reflection to figure out how to build "Handler"s that work this way.
05:09:52 <Profpatsch> edwardk: Nice. I was skimming the lens module, but couldn’t make sense of the functions.
05:10:22 <edwardk> generally you'd use something like catching _Whatever where _Whatever is a prism or fold that matches on SomeException
05:10:42 <Profpatsch> Desperately need some kind of lens cookbook for frequent use cases.
05:10:42 <edwardk> it can handle an arbitrary fold so you can filter, etc. as you need
05:11:46 <edwardk> to be fair, http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Exception-Lens.html#v:catching has a worked example right underneath ;)
05:12:58 <edwardk> the prisms could stand to have some additional docs added to them though
05:13:41 <Profpatsch> Ah, right, my problem was that HttpException didn’t provide lenses.
05:14:03 <Profpatsch> But that should be easily solvable with the prism' combinator, right?
05:14:32 <edwardk> yeah
05:14:53 <edwardk> also you can use
05:15:05 <edwardk> _HttpException = exception  -- and then give it the right type signature
05:15:20 <edwardk> _HttpException :: Prism' SomeException HttpException
05:16:26 <edwardk> or you can get fancier and write an AsHttpException class like I do in Control.Exception.Lens so that the _HttpException prism can be an iso when applied directly to an HttpException
05:16:40 <edwardk> then you can add the smart prisms for the different constructors
05:16:46 <edwardk> it all depends on how much work you want to put in
05:16:55 * hackage servant-snap 0.8.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.8.1 (imalsogreg)
05:17:58 * hackage hlint-test 0.1.0.0 - Run hlint in test suite  https://hackage.haskell.org/package/hlint-test-0.1.0.0 (yrid)
05:19:20 <edwardk> if you don't want to bother writing a bunch of stuff by hand you can get away with just using `makePrisms ''HttpException` so you can use: catching (exception._InvalidUrlException) ...
05:19:39 <lseactuary> no one knows please?
05:19:55 <edwardk> if you want to go a little farther makeClassyPrisms ''HttpException   ; instance AsHttpException SomeException where _HttpException = exception
05:20:08 <edwardk> would allow catching _InvalidUrlException ...
05:20:14 <Profpatsch> edwardk: I can use makePrisms even for types I don’t define myself? Nice.
05:20:32 <Profpatsch> Since it just creates some functions that should have been clear.
05:20:36 <edwardk> makePrisms makes a bunch of methods. they just wind up in whatever module you run it in
05:20:56 <edwardk> makeClassyPrisms or whatever makes a class and an instance.
05:21:01 <edwardk> in the above case its pretty clean actually
05:32:32 * hackage unliftio 0.2.2.0 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  https://hackage.haskell.org/package/unliftio-0.2.2.0 (MichaelSnoyman)
05:39:02 <matsurago> is there a something in Prelude that is a version of foldr/foldl that takes the first (last) element of a list as the accumulator?
05:39:55 <nullie> foldr1 foldl1
05:40:36 <matsurago> nullie: thanks! that's exactly what I needed
05:51:03 <dmiles> [exa]: there is a problem with learning or knowing Prolog before Haskell
05:52:09 <dmiles> A person might stick with Prolog :)
05:53:28 <dmiles> Though studying Haskell has made me more resourcefull at Prolog
05:54:00 <loginoob> is n*(n-1)*(n-2)...(n-r+1) = Perm n r ?
05:55:13 <nullie> looks like factorial to me
05:55:45 <matsurago> dmiles: is Prolog still alive and kicking?
05:56:50 <glguy_> loginoob: looks right
05:57:56 <dmiles> matsurago: yes.. and new paradymns in it since mutability has been embrassed finally
05:58:48 <dmiles> matsurago: predicates like nb_setarg/3 that mutate state that are not subject to backtracking
05:59:38 <loginoob> glguy_: so if n=5 and r=2 then n*(n-1)*...(n-r+1) will not be equal to 5*4*4?
05:59:53 <dmiles> without such things, one would be be using up trail all the time
06:00:26 <glguy_> loginoob: no, it would be 5*4
06:00:48 <loginoob> that's what i don't get
06:01:05 <dmiles> (but it is hard to get people learn/teach all the non logical features)
06:02:14 <glguy_> loginoob: that syntax means to multiply the numbers starting at n, counting down one at a time, until and including n-r+1
06:02:57 <lseactuary> anyone who can help me out a little? i have the solution just not sure it is correct
06:03:09 <[Leary]> >[1,2..2]
06:03:14 <glguy_> lseactuary: is it a haskell question?
06:03:25 <[Leary]> > [1,2 .. 2]
06:03:27 <lambdabot>  [1,2]
06:05:54 <lseactuary> glguy_ requires haskell thinking as i will program it in haskell after understanding it yes
06:06:27 <glguy_> Cool, if you get to the Haskell part we can help!
06:08:12 <lseactuary> question for you. in haskell lets suppose we have bathroom ID's (B1, B2, B3....). we want to say that each bathroom id should be precededed and followed by at least one id (except the first / last id and not itself)
06:08:18 <lseactuary> how does one translate this into haskell code
06:08:49 <lseactuary> i would just use a sequence if we restricted the preceded/followed by to 1 but this isn't the case here
06:09:40 <infinisil> lseactuary: make bathrooms a list, the list index is the bathrooms ID
06:10:20 <lseactuary> thinking
06:10:47 <lseactuary> so bathrooms = [bathroomid1, bathroomid2, ....] basically?
06:11:00 * hackage publicsuffix 0.20171229 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20171229 (wereHamster)
06:11:19 <infinisil> More like bathrooms = [bathroomwithoutid, bathroomwithoutid, ...]
06:11:47 <infinisil> because the id is implicitly derived from the bathrooms index
06:12:16 <lseactuary> but how does this show that each bathroom id (except the first / last one) is followed by / preceded by at least 1 id
06:12:19 <lseactuary> in this case it is = 1
06:12:20 <lseactuary> no?
06:13:00 <lseactuary> i think you are saying bathrooms = [1 -> a, 2-> b, .....] right?
06:13:12 <lseactuary> where the 1/2 are 'hidden' kind of
06:13:19 <infinisil> yea
06:13:21 <lseactuary> yeah
06:13:23 <lseactuary> this is correct
06:13:31 <infinisil> I mean maybe this doesn't work for your problem
06:13:42 <lseactuary> except this imposes the fact that a is followed by b and only b
06:14:01 <lseactuary> we could have bathrooms = [1 -> a, 2-> b, 2 -> c, .....]
06:14:14 <lseactuary> where a is followed by 2 others
06:14:17 <lseactuary> you see?
06:14:38 <infinisil> lseactuary: Show me some examples that are valid and some that are invalid
06:14:57 <lseactuary> hmm the above is valid
06:14:59 <glguy> Then you can havea list of lists
06:15:10 <glguy> [[a],[b,c]]
06:15:23 <lseactuary> interesting
06:16:03 <lseactuary> and then selecting the first element of each of the lists of lists would ensure only 1 element follows/preceds the other elements
06:16:05 <lseactuary> right?
06:16:49 * infinisil is confused
06:17:23 <lseactuary> ok lets rewind
06:17:43 <lseactuary> a hotel is split into a number of bathrooms, each with an associated identifer (B1, B2 etc)
06:17:54 <lseactuary> a bathroom can either be occupied or free
06:18:18 <lseactuary> bathrooms are connected. each bathroom (other than the first one) is preceded by at least one other bathroom (not including itself).
06:18:25 * hackage nqe 0.1.0.0 - Concurrency library in the style of Erlang/OTP  https://hackage.haskell.org/package/nqe-0.1.0.0 (xenog)
06:18:27 <lseactuary> each bathroom (other than the last one) is followed by at least one other bathroom (not including itself).
06:18:36 <lseactuary> i want to basically write this first
06:19:02 <lseactuary> then later i will impose a condition that each bathroom is only followed by at most 1 other bathroom and preceded by at most 1 other bathroom.
06:20:13 <lseactuary> so i believe a list is correct like you said above (as a sequence would impose order which isnt required here)
06:21:25 <lseactuary> or like glguy said we could do [[a],[b,c]]
06:21:46 <infinisil> lseactuary: Soo, you want to have something like a function `valid :: [Int] -> Bool` which tells you whether the bathrooms with the list as Id's fulfil the predicate?
06:22:24 <lseactuary> the function will come later no?
06:22:36 <lseactuary> the predicate tells us if each bathroom is occupied or not
06:22:46 <lseactuary> so its a tuple (B1, occupied), (B2, free) etc
06:22:53 <lseactuary> no?
06:23:19 <infinisil> i don't see how a bathroom being occupied or not has anything to do with that
06:23:40 <[exa]> dmiles: the point about it is that prolog teaches you unification (and dangers thereof), so understanding most of the haskell's type system is then quite easy
06:23:57 <lseactuary> infinisil so i just ignore if the bathroom is occupied or not?
06:24:35 <lseactuary> if you want i can upload the original question and my attempted solution
06:24:49 <lseactuary> it is in math notation but im mainly after the logic then i can write in math then haskell
06:25:58 <[exa]> dmiles: also, the traditional way of parsing in prolog is basically parsec, just a bit more shallow
06:30:59 <lseactuary> infinisil would it help?
06:33:03 <infinisil> lseactuary: yeah sure
06:35:36 <lseactuary> i made 2 attempts actually i will upload just the earlier one which i think it not right
06:35:44 <lseactuary> just formatting the other attempt now will upload
06:35:48 <lseactuary> but meanwhile at least you can see
06:35:54 <lseactuary> https://imgur.com/a/U4RLj
06:37:03 <lseactuary> in a later question i define routes as seq(seq1 Section_ID) e.g R1 = <<S2,S3,S4>,<S5>> which is why it seems weird to do it for q5 also. i have solved that question and done the code for it and it seems right.
06:37:22 <glguy> lseactuary: This channel is for discussion of Haskell programming, not just figuring out arbitrary math textbook problems
06:38:29 * hackage opench-meteo 0.2.0.1 - A Haskell implementation of the Swiss Meteo Net data API  https://hackage.haskell.org/package/opench-meteo-0.2.0.1 (RolandSenn)
06:39:09 <lseactuary> glguy ye but you need to understand what you are coding
06:39:15 <lseactuary> if i can understand then i can code better
06:39:34 <glguy> That's fine, this just isn't the right channel for the portion you need help with
06:39:36 <infinisil> tbh this really doesn't seem like a haskell related question at all
06:40:14 <infinisil> How about ##math instead
06:41:38 <lseactuary> i tried in math no one is replying
06:41:44 <lseactuary> i think because the thinking is more haskell
06:41:48 <lseactuary> i can write the math and the code
06:41:54 <lseactuary> i am just trying to understand what is going on
06:41:56 <lseactuary> then i know what to do
06:42:04 <lseactuary> i am happy to show the solutions i have
06:44:55 <infinisil> lseactuary: the try https://math.stackexchange.com/
06:45:11 <glguy> lseactuary: Sorry, people not answering in ##math isn't a pass to bring off-topic questions here
06:46:15 <lseactuary> i understand
07:05:25 * hackage opench-meteo 0.2.0.2 - A Haskell implementation of the Swiss Meteo Net data API  https://hackage.haskell.org/package/opench-meteo-0.2.0.2 (RolandSenn)
07:08:42 <jpcooper> Hello. Is there any general method of efficiently solving dynamic programming problems of multiple dimensions, avoiding things like the ST Monad?
07:10:07 <jpcooper> (in Haskell)
07:11:29 --- mode: ChanServ set +o glguy
07:15:28 <phadej> jpcooper: you can relatively easily trade time for space using e.g. MemoTrie package
07:15:36 <int-e> jpcooper: https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html#v:constructN looks like a good match for many applications (increasing indices)
07:16:12 <butterthebuddha> "newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }"
07:16:12 <butterthebuddha> ^ Can someone explain that to me?
07:19:07 <int-e> jpcooper: There's a cute method that relies on laziness, i.e. create an Array whose elements are computed by a function of the array itself and the indices of the array elements. It has the right asymptotic complexities, but laziness isn't exactly free if you care about constant factors.
07:19:13 <jpcooper> Thanks phadej and int-e. The paper that MemoTrie is based on looks quite interesting
07:19:21 <liste> butterthebuddha: what's the most unclear thing about it ?
07:19:36 <butterthebuddha> liste: I don't get any of it
07:19:49 <int-e> (Memotrie is the same idea for less structured indices, and better in that it covers infinite ranges.)
07:19:57 <int-e> s/ranges/domains/
07:20:05 <liste> butterthebuddha: it defines a newtype Parser a, with a constructor named Parser and an accessor named runParser
07:20:20 <jpcooper> butterthebuddha, A parser is something which takes a String, and if a prefix of that String is in the language which the parser defines, the parser returns the value which that prefix parses to along with the remainder of that string
07:20:55 <butterthebuddha> I'm confused about the several different ways to define a type in Haskell
07:20:57 <jpcooper> int-e, I'm hoping for unboxed matrices, but I take it that the idea can be generalised
07:21:21 <butterthebuddha> Is there a comprehensive comparison that I can refer to?
07:21:35 <liste> butterthebuddha: newtype is similar to data, but it has different strictness
07:22:00 <liste> and a limitation of only single constructor with a single argument
07:23:48 <mniip> % :i Endo
07:23:48 <yahb> mniip: newtype Endo a = Endo {appEndo :: a -> a} -- Defined in `base-4.11.0.0:Data.Semigroup.Internal'; instance Monoid (Endo a) -- Defined in `base-4.11.0.0:Data.Semigroup.Internal'; instance Semigroup (Endo a) -- Defined in `base-4.11.0.0:Data.Semigroup.Internal'; instance (t ~ Endo b) => Rewrapped (Endo a) t -- Defined in `Control.Lens.Wrapped'; instance Wrapped (Endo a) -- Defined in `Control.Lens.Wrapp
07:24:17 <liste> does yahb do anything else?
07:24:35 <int-e> jpcooper: constructN exists for unboxed vectors as well.
07:25:15 <mniip> liste, it's a full-blown ghci
07:25:54 <liste> is it protected from nastiness?
07:25:58 <mniip> in a way
07:26:09 <int-e> (huh, the example in the documentation of that function is wrong, it has an extra application of f in the result)
07:34:17 <infinisil> % System.Process.readProcess "../bin/uname" ["-a"] ""
07:34:17 <yahb> infinisil: "Linux mniip.com 4.9.0-0.bpo.3-amd64 #1 SMP Debian 4.9.25-1~bpo8+1 (2017-05-19) x86_64 GNU/Linux\n"
07:52:09 <elfeck> Is there an easy way to concurrently append to a file? Without the hassle of locking/unlocking it?
07:52:59 <glguy> You can create a thread with forkIO that is reponsible for writing to it that listens on a Chan for things to write
07:54:53 <chaoticsun> Good morning. I'm trying to configure both Atom and Sublime Text as IDEs for Haskell. I have followed the excellent instructions from simonmichael on github and had excellent luck in the past with both Linux and Windows systems. Due to having to re-image my system at work, I have to rebuild from scratch. So far, I've managed to work out most of the issues and get it to install correctly on Windows 10. Using the exact same stack.yaml configuration,
07:54:53 <chaoticsun> I get this error on the Linux side... Please see the error here: http://lpaste.net/25838347159076864
07:55:54 <elfeck> glguy: Hm, not really easy, but I guess my task is not "easy". Could you provide me a link to such the package for listening on a "Chan"?
07:56:20 <glguy> That's part of the base library that comes with ghc: Control.Concurrent.Chan
07:57:13 <elfeck> glguy: ah thank you!
07:57:28 <chaoticsun> My stack.yaml: http://lpaste.net/2613906457711607808
07:57:33 <elfeck> I've never done much with concurrency in haskell
08:01:31 <int-e> jpcooper: http://lpaste.net/361187 -- this is how I'd use constructN
08:04:59 <dionisius> window bare
08:07:15 <glguy> chaoticsun: Which Linux?
08:08:15 <chaoticsun> glguy: Running Antergos in a VM. It's an Arch based distro. Pretty good.
08:08:18 <jpcooper> int-e, That's really cool. Thanks
08:08:18 <Phyx-> lol, so yahb allows i/o actions? is the way it's protected a container?
08:09:15 <glguy> chaoticsun: OK, Arch linux is a recurring problem for Haskell dev, your solution will be specific to that
08:10:15 <chaoticsun> glguy: Perfect. Thanks. I'll go hunting. :)
08:12:30 <oak-> The tinfo6-problem is something that other distros will likely have in future as well, it's just that the Arch adopted the newest version of ncurses and terminfo first
08:15:32 <butterthebuddha> "newtype Parser a = Parser { runParser :: String -> Maybe (a, String) }".     <<.    how does Haskell know what to do for runParser here?
08:16:58 <kadoban> butterthebuddha: Look at the type of 'runParser'. All it does is "unwrap" a Parser, it's of type :: Parser a -> (String -> Maybe (a, String)). So it knows because all it has to do is yank out the thing that was put in.
08:17:50 <mniip> runParser (Parser x) = x
08:17:55 <mniip> is the definition
08:18:10 <mniip> not very hard to "come up with" such a thing
08:21:29 * hackage pandoc-include-code 1.2.0.2 - A Pandoc filter for including code from source files  https://hackage.haskell.org/package/pandoc-include-code-1.2.0.2 (owickstrom)
08:23:19 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/extras/10-applicative/AParser.hs
08:23:37 <butterthebuddha> Can someone explain how the "runParser (satisfy isUpper) "ABC"" line works?
08:24:42 <metahumor> do you understand how `satisfy` takes a predicate?
08:25:05 <butterthebuddha> yep
08:25:16 <butterthebuddha> but when is f applied?
08:25:32 <butterthebuddha> the f inside the parser
08:26:10 <metahumor> expand out the "runParser ..." expr and you'll see when the f is applied
08:26:18 <glguy> runParser (Parser f) "ABC" ==> f "ABC"
08:26:36 * hackage pandoc-emphasize-code 0.2.2 - A Pandoc filter for emphasizing code in fenced blocks  https://hackage.haskell.org/package/pandoc-emphasize-code-0.2.2 (owickstrom)
08:27:20 <butterthebuddha> runParser (Parser f) "ABC" == Maybe (f, "ABC") right?
08:27:47 <glguy> No, Maybe lives at the type level, these are values
08:27:55 <butterthebuddha> I meant Just
08:28:04 <glguy> That's also incorrect
08:28:05 <fishythefish> That's still incorrect
08:28:11 <glguy> It's what I wrote
08:28:13 <butterthebuddha> I get that it's incorrect
08:28:18 <butterthebuddha> Obviously
08:28:22 <butterthebuddha> But I'm confused as to why
08:28:37 <glguy> runParser (satisfy isUpper) "ABC" ==> runParser (Parser f) "ABC" ==> f "ABC"
08:28:44 <butterthebuddha> I don't understand how the type declaration for Parser works
08:28:51 <fishythefish> let's ignore Parser and runParser -- these are just wrapping and unwrapping
08:28:56 <butterthebuddha> and what exactly runParser is doing
08:29:00 <glguy> but the f there is the one that closes over the parameter p in the definition of satisfy
08:29:06 <fishythefish> do you understand what the signature String -> Maybe (a, String) represents?
08:29:29 <butterthebuddha> Yep
08:29:50 <glguy> Explain it back to us
08:29:59 <fishythefish> If you understand that, there's really not much left to explain
08:31:09 <butterthebuddha> Why is Parser f an okay value for Parser Char when f is a function?
08:31:18 <butterthebuddha> I guess that's where I'm really tripping up
08:31:42 <fishythefish> f can't be just any function, it has to have type String -> Maybe (Char, String)
08:31:43 <glguy> butterthebuddha: There are two different constructors "Parser", one at the type level and one at the value level
08:31:52 <fishythefish> the a has been specialized to Char because you want a Parser Char
08:32:08 <glguy> It's easier to talk about if we rename one: newtype Parser a = MkParser { runParser :: String -> Maybe (a, String) }
08:32:25 <fishythefish> imagine we had newtype Parser a = MkParser { runParser :: String -> Maybe (a, String) }
08:32:33 <fishythefish> ...and I see glguy is beating me to it
08:32:43 <butterthebuddha> Okay, can someone rewrite the newtype declaration as a separate Parser and a function?
08:32:47 * glguy goes back to playing Hexcells
08:32:57 * hackage generic-lens 0.5.1.0 - Generic data-structure operations exposed as lenses.  https://hackage.haskell.org/package/generic-lens-0.5.1.0 (kcsongor)
08:33:24 <fishythefish> newtype Parser = Parser (String -> Maybe (a, String))
08:33:27 <fishythefish> runParser (Parser f) = f
08:33:49 <butterthebuddha> So Parser is really wrapping a function
08:33:55 <fishythefish> yes, that's all it is
08:34:08 <butterthebuddha> That clears up a lot
08:34:22 <fishythefish> a Parser is a function that takes a String you want to parse and produces a potential result + rest-of-the-string
08:34:34 <kadoban> 'runParser' is in a sense not a great name, because it sounds a lot more magical than it is. But it's a common way to phrase that type of thing.
08:34:39 <butterthebuddha> I don't understand Haskell's type declaration syntax
08:35:00 <fishythefish> you mean the "name :: type" bit, or something more specific?
08:35:07 <butterthebuddha> beyond the very basics
08:35:14 <butterthebuddha> Nah, the record syntax and newtype
08:35:30 <fishythefish> let's start with newtype
08:35:36 <fishythefish> are you comfortable with a data declaration?
08:36:06 <butterthebuddha> Yep
08:36:21 <fishythefish> so let's say you have "data Foo = Bar Int"
08:36:24 <mniip> I need something like a list zipper that can always tell its index
08:36:33 <mniip> is this just a zipper coupled with an int or is there a smarter solution
08:36:35 <fishythefish> this declares a brand new type Foo which wraps an Int with a constructor named Bar
08:36:50 <fishythefish> this introduces overhead - storing a Foo is more expensive than storing an Int
08:37:03 <glguy> mniip: An extra Int field sounds pretty good.
08:37:20 <dionisius> Do I need to add /home/USER/.local/bin/ to $PATH in order to use Stack?
08:37:25 <fishythefish> but Foo has only a single value constructor (Bar) wrapping a single value (of type Int), so we should be able to store a Foo just like an Int
08:37:39 <mniip> or I could abandon the zipper idea
08:37:46 <mniip> and use (Map Int a, Int)
08:37:54 <fishythefish> that's what newtype does: newtype Foo = Bar Int is just like using "data" to the typechecker, but it gets rid of extra overhead
08:38:04 <butterthebuddha> Ah, so a newtype is basically just a "using" from C++
08:38:13 <fishythefish> no, that's "type"
08:38:26 <fishythefish> a newtype is not an alias -- Foo and Int are distinct types
08:39:23 <fishythefish> if you have "type Foo = Int", then Foo and Int are synonyms. if you have "newtype Foo = Bar Int", Foo and Int are different types, and there's a constructor standing between them
08:39:38 <mnoonan> newtype is more like a class with one member variable, though the analogy is a bit sketchy
08:40:05 <metahumor> dionisius: yeah if that is where running the install script for stack put it
08:40:19 <butterthebuddha> Okay, I guess I get that bit now
08:41:13 <fishythefish> anytime you see "newtype", just think "data" if you want -- that's what the typechecker does
08:41:13 <dionisius> metahumor: thanks
08:41:55 <fishythefish> "newtype" just eliminates runtime overhead
08:43:14 <fishythefish> now for record syntax: suppose we have "data Person = Person String String" storing a first and last name
08:43:44 <fishythefish> we could write accessors "firstName (Person x _) = x" and "lastName (Person _ y) = y" but this pattern is so common, so boring, so tedious
08:44:02 <fishythefish> so if we write instead "data Person = Person { firstName :: String, lastName :: String }", they're defined for us
08:47:04 <butterthebuddha> I suppose I was confused
08:47:18 <butterthebuddha> Because I hadn't seen a function type in a record type before
08:48:19 <fishythefish> well, functions are just values to Haskell, so they can be used there just like non-functions
08:49:14 <butterthebuddha> I think I get it now
08:49:37 <butterthebuddha> Thanks for all the help
08:49:41 <yoho> just remember - everything's a function
08:49:48 <fishythefish> not everything
08:50:10 <butterthebuddha> "everyhing's a set, luke!"
08:52:33 <fishythefish> newtype + record syntax is a common pattern, and the intuition for it is pretty straightforward:
08:53:51 <fishythefish> say there's some existing type SomeType which you want to make use of, but you'd like to create a wrapper around it
08:54:00 <fishythefish> you start with "data Wrapper = Wrapper SomeType"
08:54:41 <fishythefish> well, like many wrappers, this has a single constructor with a single field, so we can actually use "newtype" instead of "data": newtype Wrapper = Wrapper SomeType
08:55:29 <fishythefish> well, the Wrapper constructor lets us turn a SomeType into a Wrapper, but we'd also like to unwrap. we could define such a function ourselves, but a record will do this for us: newtype Wrapper = Wrapper { unwrap :: SomeType }
08:56:27 <fraktor> Is there a way to fold on a long list until a base case is met?
08:56:55 <fishythefish> fraktor: recursion? (what problem are you trying to solve?)
08:58:41 <metahumor> fraktor: "f predicate list = go list where go (x:xs) = if predicate x then x else go xs"?
08:58:42 <fraktor> Base case isn't the right word. I meant condition.
08:59:21 <metahumor> or "head . dropWhile predicate"
08:59:32 <mnoonan> >:|
08:59:58 <lavalike> > foldl (\acc x -> if even acc then acc else x*acc) 1 [3,5,2,7,9,11]
09:00:00 <lambdabot>  30
09:00:37 <lavalike> stops at 1*3*5*2
09:00:51 <fraktor> I want to determine whether a number is "abundant," that is, that the sum of its divisors is greater than the number itself. I've been using "abundant n = n < sum (divisors n)", but that has to calculate all of the divisors first.
09:01:33 <metahumor> then lavalike's example is what you want, swap "even" to your predicate
09:01:46 <fraktor> I have a hunch that the sums I'll be working with will often reach the threshold long before all their divisors are calculated.
09:01:58 <mnoonan> maybe a case for a "find pred . scan" operation
09:02:03 <metahumor> or you can you a scan
09:03:18 <bbaren> If I `alloca` some bytes, when is that pointer guaranteed stable?
09:03:20 <fraktor> mnoonan: that seems to be exactly what I need.
09:03:54 <bbaren> Is it possible that the GC might relocate it during its lifetime?
09:05:10 <mnoonan> bbaren: you get back a pointer into a pinned byte array, so you're fine
09:05:17 <mnoonan> http://hackage.haskell.org/package/base-4.10.1.0/docs/src/Foreign.Marshal.Alloc.html#allocaBytesAligned
09:05:25 <mnoonan> (this is called by alloca)
09:05:43 <bbaren> Awesome, thanks.
09:09:51 <michalrus> I’m seeing a lot of stuff in Cabal’s incremental compilation being triggered by [TH]. How can I reduce this effect?
09:10:22 <michalrus> It happens even if I change some string literal high in the dependency tree.
09:11:02 <fraktor> Is Data.SortedList included in ghc?
09:34:59 <butterthebuddha> https://gist.github.com/anonymous/4471dd320d359b6f2dd6736137eebdc6
09:35:07 <butterthebuddha> ^ Does that definition of Functor look right for
09:35:19 <butterthebuddha> https://www.cis.upenn.edu/~cis194/spring13/extras/10-applicative/AParser.hs
09:35:23 <butterthebuddha> Parser as defined in that file
09:35:55 <elfeck> Question regarding TChan (STM): How can atomically I read everything from the channel (until it is empty)?
09:40:02 * hackage debug-pp 0.1.0.0 -   https://hackage.haskell.org/package/debug-pp-0.1.0.0 (PepeIborra)
09:40:40 <dionisius> I am having trouble creating a new stack project. http://lpaste.net/361190
09:41:04 <dionisius> Whenever I try to run stack new pname I get the error above. Any ideas on how to solve it?
09:41:39 <amf> dionisius: upgrade stack
09:41:41 <kadoban> dionisius: You need to upgrade stack. 'stack upgrade' will usually do it. Otherwise the only solution is to use an older resolver, I forget how old it needs to be.
09:42:02 <dionisius> I just ran stack upgrade, still not working. :(
09:42:24 <amf> dionisius: make sure youre calling the right binary (rehash in zsh)
09:42:33 <kadoban> dionisius: Did you get an error or a warning on upgrade? Check if ~/.local/bin/ is in your PATH
09:43:03 <dmwit> elfeck: Something like `getAll t = liftA2 (:) (readTChan t) (getAll t) <|> pure []`, I suppose.
09:43:13 <dionisius> kadoban: I added it to PATH on .profile and sourced the .profile
09:43:36 <kadoban> dionisius: Check that it's before wherever else 'stack' lives. See what 'which stack' says for instance
09:43:56 <dionisius> kadoban: good call, I'll check it.
09:44:37 <elfeck> dmwit: wow that is dense. I am not super experienced with haskell. So you recursively readTChan and use orElse to escape?
09:45:08 <dmwit> elfeck: exactly right
09:46:03 <elfeck> dmwit: If a TChan is empty and I call readTChan what happens exactly? There is no such thing as "waiting" right?
09:46:38 <dmwit> readTChan retries. That means waiting if there's no alternate path forward.
09:46:52 <dmwit> But `<|> pure []` in my definition means there's always a way forward that doesn't require waiting.
09:47:22 <elfeck> dmwit: okay, so instead of wainting it just stops trying to read?
09:47:32 <dmwit> right
09:47:36 <elfeck> dmwit: thanks a lot!
09:55:38 <dionisius> kadoban: problem solved. Thanks!
09:56:14 <kadoban> Cool, anytime
09:57:24 <dmwit> butterthebuddha: looks good to me
09:59:29 <dmwit> :t fmap . fmap . first :: (a -> b) -> (String -> Maybe (a, String)) -> (String -> Maybe (b, String))
09:59:30 <lambdabot> (a -> b) -> (String -> Maybe (a, String)) -> String -> Maybe (b, String)
10:00:31 <yoho> conal_: when you've got a moment - what exactly were you alluding to last night with the remark "even computers are continuous. discreteness is just an abstraction."?
10:02:19 <mniip> oh
10:02:29 <mniip> glguy, update: I need a tree zipper
10:02:38 <mniip> with a tree "index"
10:03:12 <dmwit> What's a tree index?
10:05:34 <mniip> a path
10:06:32 <dmwit> Like, the path to the root from the currently focused node?
10:06:40 <dmwit> I would think that would come standard with your favorite tree zipper.
10:07:50 <mniip> yeah but not efficiently
10:08:00 <mniip> like, I know a path to some other location
10:08:08 <mniip> and I need to emit a sequence of movememnts
10:10:23 <dmwit> Up to the root (easy to get efficiently by walking the spine of your zipper), then down to the other location (using the path you know to that other location). Cancel any movements in the middle that are "up then down to the same node".
10:10:40 <elfeck> dmwit: how can I (manually) "fail" the STM monad so that the "else" branch of orElse is used? Is it just "retry"?
10:10:49 <dmwit> elfeck: yejs
10:11:13 <elfeck> dmwit: thanks
10:11:34 <mniip> hmm
10:11:38 <dmwit> elfeck: There is also `guard` if you want to check a condition.
10:11:43 <mniip> suddenly, I forget how zippers work...
10:11:50 <mniip> they're derivatives, right
10:11:52 <fishythefish> by taking derivatives
10:13:20 <fishythefish> but less tongue-in-cheek, you augment your usual recursive data structure with a list containing the "decisions" you made to get there - the route itself as well as the substructures you discarded at each stage
10:18:34 <elfeck> dmwit: okay, I'll look into it
10:21:36 <glguy_> mniip: if it's a binary tree (or some other small finite number of children) you could store the path somewhat efficiently in an Integer with the left right choices being the bits
10:22:22 <bigeyes52> i'm trying to generate a simple random number and then outputting that random number as a Num, but i can't seem to make it work
10:22:34 <bigeyes52> code + error here : http://lpaste.net/361192
10:22:49 <fishythefish> bigeyes52: Num isn't a type
10:23:01 <hyperisco> you cannot output something as a Num, because a Num isn't a type
10:23:14 <fishythefish> you can use e.g. Int, Float, Double
10:23:41 <dmwit> % do { g <- randomIO :: IO Double; show $ ceiling (g*6.0 + 4.0) }
10:23:41 <yahb> dmwit: ; <interactive>:9:34: error:; * Couldn't match type `[]' with `IO'; Expected type: IO Char; Actual type: String; * In a stmt of a 'do' block: show $ ceiling (g * 6.0 + 4.0); In the expression:; do g <- randomIO :: IO Double; show $ ceiling (g * 6.0 + 4.0); In an equation for `it':; it; = do g <- randomIO :: IO Double;
10:23:52 <dmwit> % do { g <- randomIO :: IO Double; print $ ceiling (g*6.0 + 4.0) }
10:23:52 <yahb> dmwit: 7
10:24:04 <dmwit> Turns out there was more than one error. =)
10:24:30 <hyperisco> one of the great misconceptions in Haskell… not entirely sure why that happens. is it because JavaScript has a single number type?
10:24:52 <hyperisco> is it because OOPers think type classes are interfaces and thus types?
10:24:53 <fishythefish> might be because Num a => a shows up so often
10:24:58 <fishythefish> and lowercase stuff looks unimportant
10:25:22 <dmwit> % randomRIO (4, 10) :: IO Int
10:25:22 <yahb> dmwit: 7
10:25:24 <hyperisco> I remember someone seemed convinced that  Num a => a -> a -> a  and  Num -> Num -> Num  were the same thing
10:25:26 <fishythefish> or because Num is the only actual name in that mess and seems familiar
10:25:51 <dmwit> Oh, well, I guess the range is actually (5,10) except in very rare cases.
10:26:15 <bigeyes52> dmwit: why does show not work, but print does? how come it isn't possible for me to use show there, and what doess that error mean? (the whole couldn't match type [] with Io)
10:26:20 <fishythefish> :t show
10:26:21 <lambdabot> Show a => a -> String
10:26:22 <fishythefish> :t print
10:26:23 <lambdabot> Show a => a -> IO ()
10:26:56 <fishythefish> depends on what you want randomize to do, bigeyes52
10:26:57 <dmwit> bigeyes52: show converts something to a String, aka [Char]. But since the first line of your do block is an IO action, the second line must be, too.
10:27:15 <dmwit> bigeyes52: So the error says: Gosh, I was expecting an IO action, but I saw a list action instead, weird!
10:27:37 <fishythefish> if you want it to actually print the result to console, you use print to create an IO action that does that. "show" just makes something a string, so you could feed the result to "return" and make randomize an IO String, but that's not quite the same
10:28:25 <mniip> 1514571889 [21:24:49] <hyperisco> I remember someone seemed convinced that  Num a => a -> a -> a  and  Num -> Num -> Num  were the same thing
10:28:31 <mniip> a large majority of people do
10:28:37 <mniip> exactly that mistake
10:29:40 <dmwit> That seems like an exaggeration.
10:30:34 <hyperisco> nope… that was exactly what they kept saying
10:30:45 <fishythefish> "majority" is the exaggeration, I think
10:30:56 <hyperisco> ah ha
10:31:37 <fishythefish> (Num a, Num b) => a -> b -> b is also Num -> Num -> Num, so by transitivity...
10:37:20 <dionisius> Is the default directory structure of Stack (app, src, test...) really used for Haskell?  I can't find an example of a project that follows it...
10:37:52 <Athas> dionisius: src and test I have seen many times.  Not sure what 'app' is supposed to be.
10:38:08 <nullie> executable I guess
10:38:30 <hyperisco> dionisius, Haskell says nothing about how a project should be structured. That is up to package formats and build systems.
10:38:57 * hackage pusher-http-haskell 1.5.1.0 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.5.1.0 (willsewell)
10:39:07 <hyperisco> well, it says a bit about modules and files :)
10:41:47 <hyperisco> cabal doesn't really care how you organise things either, so long as you tell it where stuff is
10:45:15 <metahumor> what's the proper TH syntax for accessing a defined variable x using the String "x"?
10:45:35 <metahumor> not a newName defined within the Q do, but if the x was defined outside of the Q
10:49:08 <glguy_> You're looking for mkName?
10:50:29 <metahumor> I guess. what's the difference in how mkName "x" would work from lookupValueName "x"?
10:54:43 <glguy_> You can read about what both mean in the module documentation
10:55:03 <redrapscallion> so coming from an OOP background, i'm failing to understand how a stateful system would be implemented in Haskell, except without having state
10:55:23 <redrapscallion> like say i had a game where there was a battle system, kind of like Pokemon
10:55:42 <Athas> redrapscallion: you make the state explicit.  So functions take the current state as an argument, and return the new state.
10:55:47 <redrapscallion> implementing that in an OOP language seems fairly easy, but in Haskell, i can't even wrap my mind around how you would store stuff like hp and whatnot
10:55:57 <koz_> You can wrap this up in the state monad to make it less verbose.
10:57:46 <unesol> clear
10:58:06 <redrapscallion> so hypothetically, if i had a battle function that took in two fighters
10:58:18 <metahumor> gabriel gonzales has a very applicable example re "games" on his post about lenses
10:58:24 <redrapscallion> i would have to continuously call that battle function recursively, but modify the arguments each time it is called?
10:59:09 <ane> you could (or should) use a mutable variable to store the state, unless you want time travel (rewinding the game state)
10:59:31 <koz_> Or just use the state monad, which is intended for exactly this.
11:00:48 <ane> why would you want to do that?
11:01:44 <koz_> ane: Yeah, now that I think about it, you're right.
11:01:51 <redrapscallion> ane: i thought Haskell didn't have mutable variables?
11:01:57 <koz_> I think I jump too often to the state monad.
11:01:59 <ane> sure it does. it just makes mutation explicit
11:02:04 <koz_> redrapscallion: Nope - it just doesn't have them by default.
11:02:08 <mnoonan> it even has lots of *different kinds* of mutable variables
11:02:17 <koz_> Essentially, in other languages, everything is mutable and has every side effect by default.
11:02:34 <koz_> In Haskell, everything is immutable and has no side effects by default.
11:04:13 <ane> this is an excellent read on the subject https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
11:04:55 <metahumor> here is my TH problem, not compiling: http://lpaste.net/361195
11:05:38 <redrapscallion> wait, but from what others told me, haskell is supposed to be perfectly functional
11:06:06 <koz_> redrapscallion: What do you even mean by that statement?
11:06:13 <ane> that doesn't necessarily mean you cannot have mutable variables
11:06:19 <redrapscallion> as in haskell forces you to always use a functional approach
11:06:35 <redrapscallion> if you have mutable variables/side effects, doesn't that make it not functional?
11:07:21 <ane> no. and "functional" is a very broad an flexible term
11:07:24 <glguy_> Functions are still *pure*
11:07:45 <glguy_> Functions aren't the mechanism used to update stare
11:10:25 <hyperisco> redrapscallion, functional implies purity, if "functional" is to mean anything
11:10:47 <redrapscallion> glguy_: could you elaborate a bit? i'm still a bit confused. isn't mostly everything in Haskell a function?
11:11:17 <fishythefish> 0, True, "blah" are all not-functions
11:11:25 <hyperisco> redrapscallion, some languages let you choose whether to annotate a function as being pure (i.e. they are "multi-paradigm"). Haskell offers no such option.
11:12:04 <glguy_> A function applied to the same argument always returns the same result
11:12:28 * hackage universum 1.0.2 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.0.2 (shersh)
11:12:33 <glguy_> But that result might be an action that you chose to build your main action out of
11:12:41 <fishythefish> (and it doesn't produce side effects)
11:13:26 <maerwald> you are making a huge difference between evaluation and execution again without explaing that, which is confusing for pretty much most programmers
11:14:32 <hyperisco> redrapscallion, the strength of having an option is that you can better adapt to different situations. The weakness is that you cannot treat all things the same, so there becomes a division.
11:15:24 <hyperisco> Consider D, where GC is optional. It sounds good, but the problem is that GC'd code does not play well with non-GC'd code and vice versa. Same goes for purity.
11:16:36 <hyperisco> Languages that support both functional and non-functional have the problem that non-functional code does not play well with functional code, so the adaptability is less substantial than you may think.
11:16:40 <fishythefish> +1 to maerwald's point
11:18:04 <glguy> I don't find maerwald's point that helpful. Without knowing much about Haskell the best we can do is assure redrapscallion that there's a way for this to make sense and give some initial structure. Actually gaining some detailed understanding of things is going to come from the process of actually learning Haskell
11:18:06 <redrapscallion> fishythefish: err - what exactly is the difference between evaluation and execution?
11:18:18 <redrapscallion> i know haskell has lazy evaluation, but i don't see how that is relevant
11:19:36 <maerwald> glguy: the purity argument without explaining that it's really just about evaluation is annoying, especially when it comes to IO and haskellers insist in confusing newcomers about it by saying it's pure and throwing metaphors like "action" etc around
11:19:47 <hyperisco> redrapscallion, here is an analogy. When you write an Assembly program, does the Assembly code cause changes in the world?
11:19:52 <glguy> maerwald: OK, thanks
11:19:53 <fishythefish> redrapscallion: consider something like "print (1 + 2)" - simplifying this to "print 3" is evaluation, but actually printing 3 to the console is execution
11:20:12 <mnoonan> redrapscallion: it's a bit hard to grasp at first, but you can think of a Haskell program as a runtime that is executing code, and it can also evaluate pure expressions to figure out what to execute next.
11:20:40 <hyperisco> redrapscallion, if you say yes, then I'd ask you what the CPU does when it runs the program.
11:21:28 <hyperisco> redrapscallion, so in other words, there is a difference between saying what to do (which a program does) and doing it (which the computer does)
11:23:03 <glguy> redrapscallion: We can use functions to build up some actions and then we can link those actions together into one. Suppose we had: main = let sayHi = putStrLn "Hi"; sayWorld = putStrLn "World" in sayHi >> sayHi >> sayWorld
11:23:22 <glguy> we can name the actions sayHi and sayWorld to build up a main action that says hi twice and then world once
11:23:58 <maerwald> and calculating numbers is not an "action"?
11:24:30 <hyperisco> the difference in Haskell is how it treats execution (the doing) semantically, and in particular it is designed so it is agnostic as to what happens
11:25:02 <fishythefish> I think "action" is the de facto standard for describing an `IO _` without mentioning monads
11:26:18 <fishythefish> but fwiw, no, I wouldn't consider evaluating 1 + 2 to be an "action"
11:26:25 <maerwald> it's a metaphor like burrito, just say why it's there
11:26:36 * hackage universum 1.0.1 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.0.1 (shersh)
11:26:39 <hyperisco> and a way you can imagine that is it always describes all contingencies, rather than any particular happening
11:27:13 <redrapscallion> so reading through something like https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
11:27:35 <maerwald> you cannot do syscalls (or stuff that does syscalls) outside of IO, generally
11:27:38 <hyperisco> in this way, when you compose things, you are always composing all possibilities
11:27:45 <redrapscallion> when they say "IO action", those actions *are* impure, no?
11:27:57 <maerwald> when you execute the functions yes
11:28:04 <fishythefish> this is the key point
11:28:04 <maerwald> but then, everything is, right?
11:28:08 <glguy> redrapscallion: purity is a property of functions
11:28:13 <nullie> function which returns IO action is pure, execution of those actions is not
11:28:14 <fishythefish> the process of building up an "IO action" is pure
11:28:23 <fishythefish> executing an "IO action" is not
11:28:41 <fishythefish> we cannot execute anything merely by writing code; all the impurity is deferred to the runtime
11:28:49 <maerwald> purity is defined in terms of theory, not accounting for anything remotely like "execution". The haskell report doesn't even say how to execute something
11:28:51 <hyperisco> so in C, getChar() is a particular character, depending on what happens, whereas Haskell's version of getChar is a tree of all possibilities
11:28:52 <maerwald> afair
11:28:58 <fishythefish> (though that cop-out applies to other languages too :P)
11:29:19 <maerwald> so, kinda underspecified (maybe on purpose), you coul say
11:30:21 <hyperisco> this matters hugely for purity, because in C getChar() is different characters depending on the happening, and that violates purity
11:30:47 <maerwald> so when people talk about purity, they usually just tell half of the truth... as a programmer who actually *writes* stuff you care about the whole truth though, including the execution part
11:31:28 <hyperisco> in Haskell, if getChar was reduced to, say, 'a', then everywhere you could replace getChar with 'a', and the program would be the same. This is called referential transparency. If you try that in a C program, it won't be the same program afterwards.
11:31:44 <hyperisco> btw, another term for "reduce" is "evaluate" :)
11:31:57 <glguy> maerwald: You're welcome to try and help in explaining things to redrapscallion, but we can do without the standard contrary sequence
11:32:07 <maerwald> a function that includes IO is as annoying to reason about as any function in C, no matter if you consider it theoretically pure
11:32:16 <hyperisco> redrapscallion, does that make any sense to you?
11:32:25 <hyperisco> I am trying a new line of explaining
11:32:28 <maerwald> so, reasoning properties are orthogonal to purity
11:32:33 <hyperisco> I don't like analogies that much though…
11:34:09 <hyperisco> and glguy said he was going to work on a clear semantics that includes asynchronous exceptions
11:35:46 <maerwald> glguy: I don't know what you mean
11:38:58 <hyperisco> maybe something similar, the contingency tree, but with nondeterministic evaluation of it
11:39:11 <redrapscallion> hyperisco: so getChar is just a tree of possibilities that converges to a single possibility when executed? but i don't understand that point about "replace getchar with 'a'"
11:39:35 <yoho> redrapscallion: it's from the definition of referential transparency
11:39:45 <glguy> redrapscallion: You might find this useful, too https://www.vex.net/~trebla/haskell/IO.xhtml
11:40:30 <hyperisco> redrapscallion, say you write 5 * 10 in a program, you'd expect that 50 is an equivalent expression for the same value
11:40:59 <hyperisco> redrapscallion, so, if we find that 5 * 10 reduces to 50, which it does, then we ought to be able to replace 5 * 10 with 50 wherever we find it
11:41:39 <hyperisco> redrapscallion, note that if the expression contains variables, or overloaded terms, then the context matters
11:42:32 <hyperisco> well, most languages let you replace 5 * 10 with 50 and get the same program. Haskell goes the step further to let you do that with any expression.
11:43:27 <hyperisco> In C, getChar() == 'a' may be true in one happening and not true in another. That is impossible in Haskell.
11:44:16 <redrapscallion> hyperisco: so what about this example from Haskell's official docs https://wiki.haskell.org/Referential_transparency
11:44:29 <hyperisco> in Haskell, getChar would be an IO action, and so it doesn't even make sense to write getChar == 'a'
11:44:51 <redrapscallion> the whole "The reason is that print's side effect is realized when ha gets bound" is unclear to me
11:45:23 <yoho> note that that first example isn't Haskell
11:45:26 <hyperisco> well it is talking about ML, so unless you want to know ML I wouldn't worry about it
11:45:29 <redrapscallion> ohhhh
11:45:59 <yoho> it's giving you hyperisco's example, but in a language where it's even possible to write such a thing
11:54:05 <hyperisco> that ML example is good for demonstrating why we'd want purity, even for IO
11:54:31 <mniip> :t forM
11:54:32 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
11:55:20 <hyperisco> because pure is composable, and impure is not … go try reactive programming libraries … the ones which don't know how to handle side effects suffer profoundly!
11:55:28 * hyperisco *cough*Rx*cough*
11:57:29 <maerwald> good example
11:57:49 <maerwald> although, you could do function composition with side effects too
11:59:34 <maerwald> but then you tie evaluation and execution closely together again
12:03:26 <hyperisco> you can still suffer a similar effect in a pure setting, but this time the ailment is beta reduction
12:05:27 <hyperisco> I am still working on a comprehensive explanation of this, but the vague concept is that beta reduction usually loses information
12:06:18 <hyperisco> or in other words, makes decisions too early
12:07:00 <hyperisco> the later you make decisions (i.e. throw things away), the more opportunities you have for interpretation and composition
12:09:28 * hackage pipes-key-value-csv 0.4.0.3 - Streaming processing of CSV files preceded by key-value pairs.  https://hackage.haskell.org/package/pipes-key-value-csv-0.4.0.3 (mjmrotek)
12:09:49 <metahumor> if I have a file in my "src/" folder that I don't want stack to auto-put in my cabal, what's the stack flag to ignore that file?
12:11:01 <metahumor> i guess it's more of an hpack question
12:11:30 <hyperisco> the cost is that if you never beta reduce you tend to have a really hard time with types :P
12:12:27 <hyperisco> f :: a -> b, x :: a ---> f x :: b   is a really powerful feature for abstraction, in regard to types
12:12:43 <hyperisco> forgets there ever was an 'a'!
12:14:25 <maerwald> have you written a blog post about that particular issue?
12:16:42 <maerwald> wrt reactive programming
12:18:40 <hyperisco> maerwald, I don't have a blog. Maybe I should get one. But everyone thinks that and most don't succeed in maintaining it!
12:19:10 <hyperisco> it is a lot of work to write and revise something
12:19:26 <maerwald> should be easy with hakyll :P
12:19:37 <hyperisco> that's how I got stuck for hours designing a blog… lol…
12:19:42 <maerwald> haha
12:20:22 <mniip> style question: which looks better http://lpaste.net/9067894916524277760
12:21:28 <hyperisco> is that even a contest?
12:35:28 <ggVGc> how can I write this correctly? https://gist.github.com/422f6edb3b9abe74badad13cb8b17cda
12:35:38 <ggVGc> uhm, sorry
12:35:41 <ggVGc> that wasn't it
12:36:11 <ggVGc> this part, https://gist.github.com/22e14dfbc615de1619eb045d0c12bd02
12:36:48 <metahumor> you don't need the do after Left err
12:36:57 <ggVGc> yeah I know
12:36:58 <metahumor> i think
12:37:01 <ggVGc> I had some logging there before
12:37:04 <ggVGc> but that's not the issue
12:37:18 <ggVGc> the types don't work out
12:37:28 <hyperisco> why not   requestWithRetry action callback  ?
12:37:52 <ggVGc> I think I need an explicit forall
12:38:10 <metahumor> yeah, you're missing the callback arg on the recursive call
12:38:36 <ggVGc> ah, thanks
12:38:45 <ggVGc> but that still doesn't solve the main issue, which is the type variable a
12:39:06 <hyperisco> if you want an annotation then you need ScopedTypeVariables and an explicit forall
12:39:19 <ggVGc> ah, yeah, that's what I was looking for
12:39:20 <ggVGc> thanks
12:39:42 <ggVGc> yeah that works out!
12:39:43 <ggVGc> thanks
12:39:49 <hyperisco> and alternatively to the annotation you can try TypeApplications
12:40:00 <ggVGc> I need the annotation to make the 'try' work
12:40:11 <hyperisco> :t try
12:40:12 <lambdabot> Exception e => IO a -> IO (Either e a)
12:40:32 <hyperisco> try @SomeException  should work, and then you don't even need ScopedTypeVariables
12:43:54 <hyperisco> do you prefer curried type applications or uncurried? :3
12:57:19 <mniip> if I have a function like 'withFoo $ \foo -> ...'
12:57:30 <mniip> ContT can abstract that into 'foo <- withFoo', right?
12:58:18 <mniip> when exactly does the "scope" of foo end?
12:58:52 <mniip> at nearest resetT/runContT?
12:59:44 <nullie> afaik it will be there forever
12:59:56 <mniip> oh, that's not good
13:00:01 <nullie> you can shadow it
13:00:06 <nullie> I think
13:00:15 <mniip> well, no, my withFoo function does "deinitialization"
13:00:28 <mniip> question is, when
13:00:49 <nullie> does it doo deinitialization after \foo return?
13:01:26 <mniip> yes
13:01:58 <mniip> actually it's not even a real resource
13:02:00 <mniip> but the idea is similar
13:02:27 <aplainzetakind> Is there a safe succ, that is, something which can handle the maximal element of a bounded type?
13:02:55 <nullie> > succ maxBound :: Int
13:02:57 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
13:05:05 <yoho> huh
13:06:40 <hyperisco> > try (return (succ maxBound :: Int))
13:06:42 <lambdabot>  error:
13:06:42 <lambdabot>      • No instance for (Typeable e0)
13:06:42 <lambdabot>          arising from a use of ‘show_M223925905857378801320599’
13:07:10 <hyperisco> does it catch those?
13:10:09 <yoho> anyone know if the references to PTM here (https://ghc.haskell.org/trac/ghc/wiki/LightweightConcurrency) should be to STM?
13:10:15 <yoho> I'm guessing that's the old name
13:12:39 <aplainzetakind> > :t try
13:12:40 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
13:13:28 <yoho> :t try
13:13:29 <lambdabot> Exception e => IO a -> IO (Either e a)
13:14:38 <aplainzetakind> Hmm.
13:15:22 <aplainzetakind> Anyway. I wrote something which cyclically rolls back to minBound, which is kind of appropriate for my case.
13:19:25 <yoho> hope you called it sycclic
13:21:31 <dmwit> % try (evaluate (succ maxBound)) :: IO (Either ErrorCall Int)
13:21:31 <yahb> dmwit: Left Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
13:21:51 <dmwit> > maxBound + 1 :: Int32
13:21:53 <lambdabot>  -2147483648
13:22:20 <dmwit> aplainzetakind: Int{8,16,32,64} have the "roll back to minBound" behavior you want on (+1).
13:23:06 <yoho> but not in general
13:23:16 <dmwit> What does "not in general" mean?
13:23:26 <yoho> for arbitrary instances of Enum
13:23:33 <dmwit> Oh, yes.
13:24:51 <yoho> Also, is that behaviour guaranteed?
13:25:32 * hackage stylish-haskell 0.9.0.1 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.0.1 (JasperVanDerJeugt)
13:25:54 <dmwit> aplainzetakind: There is the `safe` package, which offers succ{May,Def,Note,Safe}.
13:26:18 <dmwit> yoho: Yes, Int* and Word* guarantee wrap-around behavior.
13:26:23 <dmwit> (Unlike Int itself.)
13:26:46 <hyperisco> succ x < x  doesn't sound like a good idea
13:27:39 <dmwit> Does 1+x < x sound like a good idea?
13:27:48 <dmwit> I dunno. It definitely has its place.
13:30:19 <metahumor> is there a way to define a new Enum instance that should match the Integer Enum instance?
13:30:48 <metahumor> like "fromEnum = fromEnum"?
13:31:30 <hyperisco> can you get an Integer from your type?
13:31:43 <metahumor> yeah
13:31:53 <dmwit> :t fromInteger . succ . toIntegral
13:31:55 <lambdabot> error:
13:31:55 <lambdabot>     • Variable not in scope: toIntegral :: a -> Integer
13:31:55 <lambdabot>     • Perhaps you meant one of these:
13:32:02 <dmwit> :t fromInteger . succ . fromIntegral
13:32:02 <lambdabot> (Num c, Integral a) => a -> c
13:32:12 <metahumor> i don't have the succ problem, just an isomorphism problem
13:32:14 <hyperisco> if your type is  newtype X = X Integer  then  deriving Enum  with GeneralizedNewtypeDeriving will do that
13:32:25 <dmwit> But then, if you have `Num c`, you might as well write `succ = (1+)`.
13:32:55 <dmwit> (Provided your type is unbounded.)
13:35:31 <metahumor> i got it, as long as I have a "a -> Int" and "Int -> a", i just give those for "fromEnum" and "toEnum"
13:36:58 <lseactuary> metahumor did you help me yesterday on the recursion question?
13:37:08 <lseactuary> about the cartesian product
13:37:14 <dmwit> metahumor: Are you sure `succ (fromEnum maxBound)` does what you want?
13:37:39 <metahumor> yeah
13:38:02 <metahumor> we're confusing who has what issues here, aplainzetakind has the succ problem
13:38:59 <dmwit> I am not confused. Just uninformed.
13:40:15 <lseactuary> metahumor - if we 'flatten' A = <<a,b,c>,<d>,<e,f>> for example we just get B = <a,b,c,d,e,f>. so the length of B = length of A (through a recursion directly on A)
13:40:35 <metahumor> no, your two "lengths" are different here
13:41:18 <dmwit> > (length [['a','b','c'],['d'],['e','f']], length ['a','b','c','d','e','f'])
13:41:19 <lambdabot>  (3,6)
13:41:27 <lseactuary> hmm the question before was to prove lengthS(s) = #flattenR(s) by induction
13:41:29 <metahumor> as in, if you want "weirdlength [[a,b,c],[d],[e,f]] == 6", then that's different that a regular "length"
13:41:48 <dmwit> lseactuary: What is lengthS?
13:41:54 <dmwit> What is #?
13:42:04 <lseactuary> where lengthS is a recursive function to return the number of sections in a route
13:42:10 <lseactuary> # = cardinality of a set
13:42:41 <lseactuary> maybe easier to see this: https://math.stackexchange.com/questions/2570883/recursion-and-first-order-logic
13:42:59 <lseactuary> i understand how to apply the recursions to the new data structure
13:43:29 <lseactuary> im just trying to see what the proof by induction would be here because flattening the new data structure would include the route name with the <> so you would have an extra value
13:43:41 <lseactuary> so lengthS(s) = #flattenR(s) wont work anymore
13:43:56 <lseactuary> as an inductive step ;)
13:44:04 <EvanR> yoho: no STM would be implemented with PTM according to that thread
13:44:42 <EvanR> PTM being lower level and having less bells and whistles
13:45:10 <EvanR> (sounds pretty cool)
13:45:57 <yoho> seems like it yeah
13:46:05 <yoho> interesting system
13:46:47 <lseactuary> for example what would lengthB((a,b)^s) = 1 + lengthB(s) return in the new data structure? New being <<R1, <S1,S2,S3>>, <R1, <S5>>, <R2, <S1, S3, S6>>> for example
13:47:09 <lseactuary> this would give 7 no?
13:47:16 <lseactuary> as we basically throw away R1 and R2
13:47:19 <ongy> can I set up cabal to track changes in the files included by .hsc files, so I rebuild my modules when the headers change? This makes for rather annoying bugs when I update the underlying library and my FFI uses wrong offsets :/
13:47:28 <dmwit> I still don't see anything named lengthS or lengthB in your link.
13:48:15 <lseactuary> dmwit - i changed the notation. my lengthB is there Length. my lengthS is there Length2.
13:48:42 <lseactuary> but that link is on the old data structure
13:48:45 <lseactuary> which i understand
13:49:00 <lseactuary> we now have this type of structure: <<R1, <S1,S2,S3>>, <R1, <S5>>, <R2, <S1, S3, S6>>>
13:49:30 <lseactuary> and i make a new recursion for Length (number of blocks) and Length2 (number of sections)
13:49:34 <lseactuary> which is also fine
13:49:47 <metahumor> yeah, but now your flatten needs a special defn
13:49:54 <lseactuary> right
13:50:08 <lseactuary> but instead of reqriting the definition
13:50:16 <lseactuary> im wondering if i can adapt the induction principle
13:50:18 <metahumor> in haskell syntax, it would be "concat . fmap snd"
13:50:45 <nullie> :t concatMap
13:50:47 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
13:51:09 <lseactuary> length2(s) = #flatten(s) is the inductive step I used before (using their notation)
13:51:14 <lseactuary> but now that is not true
13:51:31 <lseactuary> so im wondering can i not do something like length2(s) = #flatten(s) - length(s)
13:51:35 <lseactuary> or that is not allowed?
13:52:02 <metahumor> if you are working on a data structure that holds pairs, it might be informative to write out your function calls like we did yesterday
13:52:07 <metahumor> "length2((r,b))"
13:52:24 <metahumor> "length2(<r,b>)" or whatever syntax you prefer
13:52:51 <lseactuary> induction is done on x^s no? (in this case (r,b)^s)
13:52:59 <lseactuary> but the inductive step is to assume true for s
13:53:14 <lseactuary> i can do the induction :) i am just stuck how to adapt it to make a true statement
13:53:18 <lseactuary> then i can prove it no problem
13:54:26 <metahumor> length2(<r,b>) = length(flattenB(<r,b>)) where flattenB(<r,b>^s) = b^flattenB(s)
13:54:50 <metahumor> as you see, i pattern match on the item structure in the defn for flattenB
13:55:06 <lseactuary> writing it down to try to understand 2 min
13:55:25 <metahumor> and "length2(<r,b>^s) = length(b) + length2(s)"
13:56:07 <lseactuary> flattenB = flattenR? i.e. i could have called it flattenK the letter is irrelevant?
13:56:10 <metahumor> and then you can see how you've mapped "length" into the <r,b> structure, if you compare how in the flatten defn we use "^" and length2 we use "+"
13:56:31 <lseactuary> yeah i have the recursions :)
13:56:39 <lseactuary> good to see i did it correct
13:56:42 <lseactuary> thinking abotu that last bit
14:03:00 <lseactuary> oh its the same as before just the first element changed
14:06:02 <lseactuary> metahumor - as a side, do you have any suggestions on how one gets good at haskell
14:06:11 <metahumor> use it
14:06:22 <lseactuary> as in books, exercises etc
14:06:39 <metahumor> find a problem, try to solve it using haskell, fail, look at how other people did it, try to rewrite how they did it to understand it
14:07:02 <lseactuary> kk
14:13:34 <EvanR> write a lot of code
14:13:49 <EvanR> and specifically in haskell i got a lot of help by reading a lot of code
14:14:02 <EvanR> haskell is good at not being write-only
14:14:15 <kadoban> You haven't seen my haskell :(
14:14:22 <yoho> :D
14:14:44 <yoho> also, I wouldn't tend to agree with the "haskell is good at not being write-only"
14:15:05 <yoho> people like to code golf it and use single letter variable names
14:17:29 <Rembane> Type signatures makes it much easier to read code.
14:18:01 <yoho> I'm not saying it's on perl level
14:18:27 <yoho> but it's not amazing for readability, especially for a beginner
14:18:56 <Rembane> Isn't that mostly because there are a gazillion ways to write the same code and there are about as many concepts that are good to know?
14:18:59 <unyu> yoho: Single-letter variable names are okay in generic code.
14:21:42 <lseactuary> what does Z notation fall under - math?
14:22:18 <hyperisco> what's Z notation? and yes
14:23:18 <lseactuary> https://en.wikipedia.org/wiki/Z_notation
14:26:31 <hyperisco> computer science is a branch of mathematics
14:27:33 <lseactuary> i see
14:39:03 * hackage weeder 0.1.11 - Detect dead code  https://hackage.haskell.org/package/weeder-0.1.11 (NeilMitchell)
14:43:11 <mniip> hmm
14:43:19 <mniip> I see potential for abstraction
14:43:24 <mniip> but I can't quite formulate it
14:44:52 <mniip> I have a function (X -> X -> ... X -> M ())
14:45:07 <mniip> the function would like all X to be distinct (as per Eq)
14:45:21 <mniip> there also is disambiguate :: X -> (X -> M ()) -> M ()
14:45:32 <mniip> that makes up an X distinct from everything
14:45:57 <mniip> I feel like this could be wrapped into a pair of operators that could operate on functions incrementally, one argument after another
14:46:02 <mniip> much like pure/<*>
14:46:15 <mniip> as opposed to liftAN
14:46:34 <hyperisco> disambiguate x f  gives f an X that is distinct from x?
14:46:51 <mniip> that is distinct from everything at all
14:47:00 <hyperisco> what is the purpose of x?
14:47:03 <mniip> but I need to minimize the number of disambiguate invocations
14:47:22 <mniip> X is a reservation of a location on an abstract hypothetical tape
14:47:31 <hyperisco> why is it not just  new :: M X  for example?
14:47:44 <mniip> M () emits instructions for an abstract hypothetical machine
14:47:57 <mniip> some functions don't like when two of its arguments are the same location on the tape
14:48:09 <Tuplanolla> Are you doing something De Bruijn indices would solve better, mniip?
14:48:10 <hyperisco> I don't understand disambiguate
14:48:19 <mniip> disambiguate is just an allocation in this case
14:48:26 <mniip> Tuplanolla, no
14:49:27 * hackage hgettext 0.1.31.0 - Bindings to libintl.h (gettext, bindtextdomain)  https://hackage.haskell.org/package/hgettext-0.1.31.0 (HerbertValerioRiedel)
14:50:02 <mniip> hyperisco, disambiguate allocates a new position on the tape and copies the old location's value
14:50:14 <mniip> hence now the said function receives two distinct locations with the same value
14:52:19 <mniip> Tuplanolla, I'm actually writing an imperative DSL that translates to something between a turing machine and a minsky register machine
14:57:07 <hyperisco> okay… so X is the type of pointers? then  disambiguate x f  gives f a new position with the same value as x dereferenced?
14:57:22 <mniip> sort-of
14:57:41 <hyperisco> well maybe if you showed me an example of an expression you are trying to abstract
14:57:45 <mniip> if we remember that "pointers" aren't internal to the target language
14:58:32 <mniip> http://lpaste.net/361201
14:58:35 <mniip> alias = disambiguate
14:58:36 <hyperisco> your functions want n distinct pointers to the same value?
14:59:28 <mniip> see the u /= v && u /= w && v /= w business
14:59:50 <mniip> and how if some variable is aliased, it creates a copy and retries
15:00:08 <hyperisco> I feel like only you have all the details to solve this
15:00:35 <mniip> ohh
15:00:39 <mniip> ContT can do it
15:00:56 <mniip> ContT StateT
15:01:31 <mniip> or maybe even ContT WriterT with 'pass'
15:06:36 <mniip> I'm not awake enough to even think of the type correctly...
15:07:11 <hyperisco> Dynamic
15:32:10 <jle`> anyone have any code using the new SelectT in transformers?
15:32:16 <jle`> i found a few academic papers
15:32:23 <jle`> but none using code that i've found
15:42:48 <glguy_> I still need to go learn what it is, only saw that it existed
15:43:34 <jle`> i'm all on board with Accum/AccumT
15:43:51 <jle`> i used it for an AOC, and i like the idea of restricted state monads
15:44:23 <jle`> maybe i should start by seeing how select is different than cont
16:13:25 <fizbin> Hey, I don't know if this is really the best place to ask, but does anyone here know of a decent short question (answerable in 20-30 minutes) to use as a way to assess a job candidate's haskell coding ability?
16:13:42 <hyperisco> why not take your username as inspiration?
16:13:48 <fizbin> I've got one that I've used once so far, but I don't know how I feel about it.
16:14:31 <fizbin> hyperisco: So far as I know, not even Spock has calculated the odds around a royal fizbun.
16:15:16 <nshepperd_> Looks like SelectT has totally different instances to ContT
16:15:21 <nshepperd_> Interesting
16:17:51 <nshepperd_> newtype SelectT r m a = SelectT ((a -> m r) -> m a)
16:27:06 <bbaren> I’m `unsafePerformIO`ing a foreign function. I understand that if I don’t put a `NOINLINE` on my definition, I risk it being inlined and the IO being performed more than once. But if the IO is truly computing a pure value, does that actually matter? Why not just let it be inlined?
16:29:10 <Tuplanolla> It doesn't matter unless the foreign library is broken, bbaren.
16:30:00 <bbaren> Oh, I misread the docs. Great. Thank you.
16:35:35 <monochrom> Also you don't need to use unsafePerformIO by your own hand. You can give the imported function a non-IO type. E.g., foreign import ccall sin :: Double -> Double
16:36:34 <monochrom> The same consideration about "what if it's called twice" applies.
16:38:06 <fizbin> I remember seeing someone NOINLINE an unsafePerformIO surrounding a newIORef call because they needed the same IORef in several places.
16:39:03 <EvanR> how reliable is the NOINLINE hack for ensuring that
16:40:25 <fizbin> I wish I could remember what library I saw that in....
16:40:30 <monochrom> Yes newIORef is the one that actually needs NOINLINE
16:41:06 <monochrom> Many libraries do that. Including random. (Where do you think randomIO comes from?)
16:42:26 <EvanR> or stdin, stdout Handles
16:43:41 <crucify_me> 'No instance for (Num Nat) arising from the literal '4' '   error while running ' > add' 4 5 '      https://ptpb.pw/dCg7
16:44:06 <crucify_me> sorry for badly written post
16:44:17 <crucify_me> ie why won't this run?
16:44:35 <EvanR> because Nat has no Num instance?
16:44:54 <yoho> does it need one based on that code?
16:45:02 <EvanR> add 4 5 does
16:45:05 <xxxgarnetxxx> Hey guys :)
16:45:08 <yoho> add'*
16:45:34 <xxxgarnetxxx> I'm in irc again — last time i used it was like 10 years ago for runescape! Feeling so into this.
16:45:36 <EvanR> 4 is translated to "fromInteger 4" where 4 is an Integer
16:45:48 <EvanR> which requires Num
16:45:54 <yoho> oh duh
16:46:03 <xxxgarnetxxx> - hello world, lol.
16:46:23 <yoho> crucify_me: haskell doesn't know how to convert from 4 and 3 to your Nat type
16:46:24 <crucify_me> sorry don't follow . how to write that data declaration to include Num with the 2 constructors?
16:46:38 <EvanR> you wrote the data declaration
16:46:46 <EvanR> now write the Num instance
16:46:50 <EvanR> instance Num Nat where
16:46:52 <EvanR>   ...
16:47:15 <yoho> so the only way to write it with what you've currently got is add' (Succ(Succ(Succ(Succ(Zero))))) (Succ(Succ(Succ(Zero))))... or do it properly and do what EvanR is saying
16:48:15 <crucify_me> the book I'm using gives no indication on how to do that or that its needed.
16:48:41 <EvanR> literals 4 and 5 etc are translated into something that uses fromInteger
16:48:43 <EvanR> :t fromInteger
16:48:44 <lambdabot> Num a => Integer -> a
16:48:56 <EvanR> believe me
16:49:11 <yoho> crucify_me: look up type classes
16:49:21 <yoho> (in your book or otherwise)
16:49:35 <crucify_me> I believe you, I don't know how to write it. the data constructor stuff is never explained well, it seems
16:50:06 <EvanR> how to write what party
16:50:08 <monochrom> I am skeptical about even wanting "add 4 5" to work. Why is it necessary?
16:50:32 <EvanR> part
16:50:46 <yoho> if you want to treat your naturals as a number you need to tell haskell how that conversion works
16:51:04 <yoho> it can't just figure out the relationship between your data constructors and numbers itself
16:51:31 <crucify_me> so Zero and Succ are not part of prelude
16:51:41 <yoho> no, you just defined them
16:51:45 <EvanR> your code you pasted defines them...
16:51:56 <yoho> there is a succ in prelude
16:51:58 <yoho> :t succ
16:51:59 <lambdabot> Enum a => a -> a
16:52:43 <ReinH> The desired instance is incoherent, but we can't always have nice things.
16:53:22 <crucify_me> sorry, please tell me where 'instance Num Nat where' should be placed
16:53:39 <ReinH> I suppose we've all come to tolerate incoherent Num instances.
16:53:49 <yoho> crucify_me: look up type instances
16:53:50 <EvanR> please look up instances on a haskell guide
16:53:59 <EvanR> there will be examples
16:54:04 <ReinH> crucify_me: Anywhere at the top level of your file, typically after you define Num.
16:54:22 <yoho> sorry, I meant type classes there
16:54:28 <MarcelineVQ> Num isn't even relevant to this paste.  wanting to use add' on numbers like 3 or 4 is a type error, add' only accepts Nat not any Num
16:54:52 <ReinH> Num would allow add' 3 4 to work.
16:54:52 <yoho> nothing wrong with a good old infinite loop
16:55:05 <ReinH> (a Num instance for Nat)
16:55:07 <yoho> it'd also allow add' (-1) 1 to work
16:55:14 <ReinH> Yes, that's why I said that it's incoherent.
16:55:21 <ReinH> But most Num instances are incoherent.
16:55:35 <ReinH> Which is why I said that we've come to tolerate it.
16:55:39 <EvanR> the more times you so incoherent, the more technical it gets
16:55:44 <EvanR> say*
16:55:48 <yoho> incoherent
16:55:49 <ReinH> EvanR: your face is incoherent
16:56:15 <Rembane> Your incoherence is face.
16:56:20 <ReinH> Perhaps.
16:56:31 <EvanR> Num is an example of a class that is underlawed
16:56:37 <EvanR> or vaguely lawed
16:56:50 <crucify_me> ok I'm bowing out
16:56:56 <ReinH> The way you're supposed to use add' without a Num instance for Nat is, say, add' (Succ (Succ Zero)) Zero
16:57:04 <ReinH> That's add' 2 0
16:57:40 <crucify_me> this is a book , there must be a logic to the pedagogy, but I can't see it
16:58:03 <EvanR> from what you have claimed so far, the book is just incomplete in its pedagogy
16:58:13 <EvanR> but you could be missing something
16:58:38 <crucify_me> earlier Nat was defined as ...
16:58:45 <crucify_me> data Nat = N Int
16:59:00 <crucify_me> but the books says after that ....
16:59:01 <yoho> well that's just wrong
16:59:24 <ReinH> Well...
16:59:25 <Tuplanolla> What is this book, crucify_me?
16:59:31 <crucify_me> hutton
16:59:45 <EvanR> Int may be referring to Integers
16:59:54 <crucify_me> geez
16:59:55 <EvanR> and then that would be a smart ctor
17:00:39 <yoho> ?
17:00:54 <ReinH> What the book says is "it is then up to the programmer to ensure that this is always non-negative"
17:01:15 <ReinH> This is used to motivate the introduction of the peano nats.
17:01:17 <crucify_me> sorry I cannot follow this part of the chapter. I'm fairly well lost
17:01:43 <aplainzetakind> Is there an easy way to obtain a (a -> a -> Bool) from an (a -> a -> Ordering), working as (<). There's already an Ord instance of a and I'm hoping there's a quicker way than newtyping it and going back.
17:01:48 <crucify_me> btw this is chapter 8, 2nd ed.
17:03:02 <glguy_> :t \x y -> LT == compare x y
17:03:03 <lambdabot> Ord a => a -> a -> Bool
17:03:52 <ReinH> crucify_me: where are you lost?
17:04:42 <aplainzetakind> glguy_: right, thanks.
17:05:43 <crucify_me> ReinH: I did data Move and data Shape, then section 8.2 goes into newtypes and the example I pasted, that I tried to piece together from the text
17:05:44 <glguy_> crucify_me: you might have just forgotten what was in the previous chapters, it probably takes a day or two to get to chapter 8
17:06:07 <crucify_me> a day or two ? :)
17:06:17 <ReinH> crucify_me: What was the original issue?
17:06:28 <ReinH> Was it just that you tried to use decimals for values of Nat?
17:06:46 <crucify_me> no, I tried add' 4 5
17:06:51 <ReinH> That's what I mean.
17:06:57 <ReinH> You tried to use decimal numbers
17:07:09 <ReinH> 4 and 5 are not values of type Nat
17:07:22 <crucify_me> I originally asked how to run it.
17:07:31 <ReinH> Well, you can't run it, because it's a type error.
17:07:54 <ReinH> What you can run is add' (Succ (Succ (Succ (Succ Zero)))) (Succ (Succ (Succ (Succ (Succ Zero)))))
17:07:56 <EvanR> you tried to use arabic
17:08:17 <crucify_me> I'm feeling intimidated again
17:09:02 <ReinH> Once you define Nat like in 8.4, the only way to make Nat values is by using Succ and/or Zero.
17:09:13 <ReinH> You can no longer use numerals.
17:09:38 <crucify_me> one moment please
17:10:13 <ReinH> The way numerals like 4 works is a design decision that is legitimately confusing to newcomers.
17:10:30 <ReinH> Best to just use Succ and Zero once you get to 8.4
17:10:44 <crucify_me> please illustrate
17:10:52 <ReinH> Illustrate what?
17:11:02 <EvanR> Zero, Succ Zero, Succ (Succ Zero)
17:11:04 <monochrom> I thought ReinH already illustrated.
17:11:13 <monochrom> Twice.
17:11:15 <ReinH> The book also illustrates.
17:11:17 <yoho> @let data Nat = Zero | Succ (Nat) deriving Show
17:11:18 <lambdabot>  Defined.
17:11:30 <monochrom> First time: http://cabal.readthedocs.io/en/stable/
17:11:32 <monochrom> err
17:11:38 <yoho> @let add' Zero n = n; add' (Succ m) n = Succ (add' m n)
17:11:39 <monochrom> First time: <ReinH> The way you're supposed to use add' without a Num instance for Nat is, say, add' (Succ (Succ Zero)) Zero
17:11:39 <lambdabot>  Defined.
17:11:40 <EvanR> yoho also illustrated earlier
17:11:40 <ReinH> No I don't think I wrote that.
17:11:48 <ReinH> :D
17:11:52 <monochrom> Second time: <ReinH> What you can run is add' (Succ (Succ (Succ (Succ Zero)))) (Succ (Succ (Succ (Succ (Succ Zero)))))
17:11:54 <yoho> > add' (Succ Zero) (Succ (Succ Zero))
17:11:56 <lambdabot>  Succ (Succ (Succ Zero))
17:12:01 <yoho> illustrated
17:12:15 <EvanR> zeroth time, even prior, yoho
17:12:24 <crucify_me> bowing out thanks , enjoy yourselves
17:12:31 <monochrom> Oh, oops
17:12:39 <yoho> gotta be willing to try and help yourself here man
17:12:46 <mniip> I'm ready to call this a success http://tcpst.net/ngbq.png
17:13:40 <monochrom> It is a success. What is MonadBF?
17:14:35 <mniip>  Λm. (MonadState View m, MonadReader Env m, MonadWriter (Endo BFProgram) m)
17:14:56 <ReinH> Ok, I'll bite, what is BFProgram?
17:15:10 <mniip> data BFProgram = BLeft BFProgram | BRight BFProgram | BInc BFProgram | BDec BFProgram | BInput BFProgram | BOutput BFProgram | BLoop BFProgram BFProgram | BEnd deriving (Eq, Show)
17:15:19 <yoho> I'll also bite, why is 001 in the output?
17:15:28 <monochrom> heh
17:16:10 <monochrom> 007, 005, and 003 are all in the output, too.
17:16:29 <MarcelineVQ> you boys are full of beans tonight
17:16:35 <yoho> monochrom: ?
17:16:46 <mniip> I have a workable concept of dynamically sized arrays
17:16:48 <ReinH> monochrom: arent'... those... primes?
17:16:48 * Clint squints.
17:16:51 <monochrom> Oh, James Bond.
17:16:52 <mniip> and unidirectionally unbounded arrays
17:16:59 <mniip> however I haven't implemented some of that yet
17:17:16 <ReinH> Obviously 001 is in the list because this is a list of prime numbers and also 1
17:17:29 <yoho> an important set of numbers I must say
17:17:42 <mniip> duh
17:17:58 <ReinH> mniip: now do it in agda
17:18:03 <mniip> this is the list of numbers whose number of divisors between 2 and the number is a multiple of 256
17:18:28 <monochrom> 256 is important, I agree.
17:18:38 <yoho> wait, what
17:18:38 <mniip> "primes" is just some random name I assigned
17:19:03 <ReinH> Ok, I'll bite, n * 256 = 1 for what integer n?
17:19:16 <monochrom> My favourite electronic components store was at the address "255 College Street". I was fond of the 255 part.
17:19:19 <mniip> yoho, for every j that divides i, the program increments d
17:19:20 <yoho> between n and 2 1 has 0 divisors, right?
17:19:31 <yoho> I think is what this is getting at
17:19:49 <ReinH> monochrom: a nice round number
17:19:51 <aplainzetakind> 1 has 0 divisors between 2 and 1, 256 * 0 = 0
17:19:56 <ReinH> well, almost
17:20:09 <monochrom> Well, a nice all-8-bits-are-on number.
17:20:20 <yoho> well no
17:20:25 <yoho> 1 bit is on
17:20:27 <monochrom> But they had to move because the whole building had to be torn down.
17:20:37 <yoho> oh you mean 255, nevermind
17:20:38 <monochrom> I mean 255.
17:20:47 <ReinH> This is a list of numbers output by the program primes
17:21:00 <monochrom> Haha \∩/ tautology.
17:21:01 <yoho> now that's a useful set
17:21:19 <mniip> $ wc -c primes.bf -> 1296
17:21:21 <yoho> now prove it
17:21:23 <mniip> too bad I can't feed it to @bf
17:21:34 <ReinH> All of the numbers that primes outputs are in the list and none of the numbers that prime doesn't output are not in the list. QED.
17:21:47 <monochrom> I'm going to prove "every set is important"
17:21:49 <ReinH> Er, are in the list.
17:21:54 <yoho> can you prove that's generally the case though
17:22:15 <yoho> monochrom: trivial, if a set wasn't important it'd be important because it's the only one that's not important
17:22:19 <mniip> hmm
17:22:21 <ReinH> First, we define "is important" as the predicate P _ = true
17:22:24 <yoho> (yes I know that falls apart, hush)
17:22:30 <yoho> ReinH: :D
17:22:36 <waterdrop> how does one check if a given operator is left assoc or right assoc? for example, I'd like to check how the <*> operator in the Applicative typeclass associates
17:22:36 <ReinH> yoho: no yours is better
17:22:47 <mniip> @letlpaste 4573370177093107712
17:22:48 <lambdabot>  Defined.
17:22:50 <ReinH> :info (+)
17:22:52 <monochrom> You're missing out on "by well-ordering, there is a smallest unimportant set".
17:23:00 <mniip> @. bf run text primes
17:23:01 <lambdabot>  Done.
17:23:17 <ReinH> waterdrop: well, :info in ghci
17:23:35 <mniip> huuh
17:23:40 <waterdrop> ReinH: thanks
17:23:59 <ReinH> monochrom: The set of important sets is the smallest set such that...
17:23:59 <yoho> monochrom: that's the base case I was looking for
17:24:11 <monochrom> \∩/
17:24:41 <mniip> okay uh
17:24:43 <mniip> @. bf run text primes
17:24:43 <yoho> % :info (+) -- waterdrop
17:24:43 <yahb> yoho: ; <interactive>:1:3: error: parse error (possibly incorrect indentation or mismatched brackets)
17:24:44 <lambdabot>  Done.
17:24:48 <yoho> ugh
17:24:49 <mniip> ...
17:24:54 <ReinH> mniip: well it did it
17:25:04 <mniip> in PM it's telling me
17:25:05 <mniip> 1514597030 [04:23:50] <lambdabot>   bf: Ix{Int}.index: Index (551) out of range ((0,550))
17:25:15 <ReinH> oh no
17:25:22 <monochrom> oooohhhh off-by-1
17:25:36 <ReinH> No, off by 0.999...
17:25:43 <yoho> approximately
17:26:07 <monochrom> haha
17:30:59 <mniip> ugh
17:33:57 <waterdrop> How is something like the composition law for applicatives checked? (The law pure ( .)  <*> u  <*> v  <*> w  =
17:33:57 <waterdrop> u  <*> (v  <*> w))
17:34:03 <waterdrop> Do people usually just write a proof or something?
17:34:29 <waterdrop> Also my textbook describes that law as " stating that the result of composing our functions first and
17:34:29 <waterdrop> then applying them and the result of applying the functions
17:34:29 <waterdrop> first then composing them should be the same."
17:35:02 <waterdrop> That seems inaccurate…it seems to be more saying that composing our functions first and then applying them gets us the same result as applying one of the functions first, and then applying the second
17:37:32 <monochrom> People usually just write a proof.
17:46:26 <kakashiAL> which standard does haskell use for Float?
17:46:47 <kakashiAL> IEEE 754?
17:52:55 <yoho> probably
17:53:34 <Tuplanolla> No. Read the report.
17:57:43 <glguy> My hurried skimming of the report indicates that it's not specified what the floating point types are exactly
17:59:51 <waterdrop> uh sorry I got disconnected
18:00:01 <waterdrop> so I was asking about the composition law for Applicative and how my book describes it
18:00:11 <waterdrop> am I correct in thinking that that description seems inaccurate?
18:00:30 <waterdrop> it seems like the composition law is saying, "it seems to be more saying that composing our functions first and then applying them gets us the same result as applying one of the functions first, and then applying the second"
18:01:52 <waterdrop> my book instead describes it as saying, " the result of composing our functions first and
18:01:52 <waterdrop> then applying them and the result of applying the functions
18:01:52 <waterdrop> first then composing them should be the same."
18:01:55 <waterdrop> but that seems wrong
18:03:19 <yoho> yeah I should clarify - I say probably as in "in practice, probably"
18:04:27 <dmwit> kakashiAL: GHC uses IEEE754
18:11:44 <waterdrop> can anyone help with my questions?
18:13:04 <boj> waterdrop: can you provide an example which shows why you feel that statement is wrong?
18:14:11 <amalloy> waterdrop: by "then composing them", it's probably (confusingly) using "them" to refer to the applicative computations, not the functions (since, as you note, those have already been applied)
18:14:40 <kakashiAL> dmwit: if I say haskell I alway mean ghc and ghci :)
18:16:36 <waterdrop> amalloy: But on the right side of the composition law which is u <*> (v <*> w), we're just first applying the v (which has type f (a -> b) to w, which has type f a). And then applying u, which has type f (b ->c) to the result of that. Is that right?
18:20:00 * hackage text-show 3.7.1 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.7.1 (ryanglscott)
18:20:28 <gbd_628> hi all. I have a quick question about *.cabal files. I remember reading about a way to reuse and import sections of build info stuff and import into library and executable sections (e.g., specifying 'build-depends' or 'default extensions' in one place insetad of in every executable section). I can't find it in the docs now, though; does anyone know what I'm talking about and how to user it properly? thx
18:21:00 <glguy> gbd_628: No, .cabal files don't support that
18:21:47 <gbd_628> oh. Guess I'm misremembering or thinking of something else then. Thanks anyway!
18:21:52 <boj> gbd_628: maybe hpack does that?
18:22:42 <ReinH> waterdrop: If you look at the types involved, you might see why the docs refer to composition.
18:22:52 <ReinH> :t \u v w -> u <*> (v <*> w)
18:22:53 <lambdabot> Applicative f => f (a1 -> b) -> f (a2 -> a1) -> f a2 -> f b
18:23:05 <ReinH> :t \u v w -> pure (.) <$> u <*> v <*> w
18:23:06 <lambdabot> Applicative f => f a1 -> f (b -> c) -> f (a2 -> b) -> f (a2 -> c)
18:23:16 <ReinH> The law is that lifted composition is associative.
18:23:35 <ReinH> It is hard to see this because <*> is application, not composition.
18:25:04 <monochrom> That's interesting.
18:25:28 <ReinH> The applicative laws are category laws.
18:27:47 <ReinH> Oops,
18:27:53 <ReinH> :t \u v w -> pure (.) <*> u <*> v <*> w
18:27:54 <lambdabot> Applicative f => f (b1 -> b2) -> f (a -> b1) -> f a -> f b2
18:29:08 <WinterFox[m]> How do I find the hackage page that has all the functions of a module and their descriptions? I had it open for Yesod.Test but now I can't find it anywhere.
18:29:25 * hackage chart-unit 0.5.5.0 - Native haskell charts.  https://hackage.haskell.org/package/chart-unit-0.5.5.0 (tonyday567)
18:29:42 <ReinH> WinterFox[m]: By using hackage.org?
18:29:55 <ReinH> Or stackage.org, depending on which faction you prefer
18:31:21 <ReinH> Maybe I'm misunderstanding the question because the answer seems obvious: browse to the module in the package contents page and then open it.
18:31:54 <WinterFox[m]> ReinH: I can find a page that has a little description of the package but I can't find the one with the functions on either of those pages.
18:32:49 <ReinH> I'm not following.
18:32:53 <boj> @where hoogle
18:32:53 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
18:33:05 <MarcelineVQ> WinterFox[m]: here?  https://hackage.haskell.org/package/yesod-test  There's been a version update there so docs don't seem to be generated yet, click back a version in the version list
18:33:06 <boj> WinterFox[m]: maybe you want one of these?
18:33:36 <WinterFox[m]> MarcelineVQ: Ah, that must be it.
18:34:14 <ReinH> If the module names in the Modules tree aren't links, that means the docs haven't been generated (yet).
18:34:21 <WinterFox[m]> yep, I can see the page again if I look at an older version
18:34:44 <ReinH> You can try the stackage docs, but a new version may not exist there at all
18:37:45 <waterdrop> ReinH: Ah that is a good way to describe the law, thanks.
18:37:45 <ReinH> waterdrop: If you define fbc <.> fab :: f (b -> c) -> f (a -> b) -> f (a -> c) then the composition law is that (f <.> g) <.> h = f <.> (g <.> h) and the pure laws are that pure id <.> f = f = f <.> pure id.
18:38:26 <ReinH> These are exactly identity and composition in a particular category constructed from f.
18:38:32 <ReinH> or vice versa, rather
18:39:42 <ReinH> Bonus points for identifying the category.
18:39:55 <waterdrop> I don't know category theory unfortunately haha
18:40:39 <gbd_628> glguy: Oh wait, I found the feature I was talking about! They're called "common stanzas" and it looks like they'll be available in cabal version 2.2. I accidentally went to the most recently updated version of the docs instead of the most recently released:
18:40:52 <gbd_628> glguy: https://cabal.readthedocs.io/en/latest/developing-packages.html#common-stanzas
18:41:06 <glguy> ah, cool. good to know that that's coming
18:41:38 <ReinH> Nice. Also yay for better cabal docs.
18:42:06 <ReinH> I almost suspect that better cabal docs and a slightly earlier release of new-build could have forestalled stack entirely.
18:42:58 <ReinH> IIRC the category in question has something to do with day convolution.
18:43:08 <ReinH> I wonder if I can construct it in Agda, I should try.
18:43:50 <waterdrop> ReinH: Uh for the composition law, isn't the w on either side have to be of type f a where a is not a function type though? if that makes sense
18:43:58 <waterdrop> I don't follow how you rewrote the composition law above
18:44:21 <ReinH> :t \u v w -> u <*> (v <*> w)
18:44:22 <lambdabot> Applicative f => f (a1 -> b) -> f (a2 -> a1) -> f a2 -> f b
18:44:46 <ReinH> :t (<*>)
18:44:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:45:13 <ReinH> waterdrop: Yes, but we can construct the f a -> f c from the f (a -> c), that's what <*> is for.
18:45:27 <ReinH> The laws are not identical, but they are equivalent.
18:46:21 <ReinH> :t liftA2 (.)
18:46:22 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
18:46:32 <ReinH> @let (<.>) = liftA2 (.)
18:46:33 <lambdabot>  Defined.
18:46:37 <ReinH> Lifted composition
18:46:47 <ReinH> :t \f g h -> f <.> g <.> h
18:46:48 <lambdabot> error:
18:46:48 <lambdabot>     Ambiguous occurrence ‘<.>’
18:46:48 <lambdabot>     It could refer to either ‘Lens.<.>’,
18:46:52 <ReinH> Oh no.
18:46:58 <ReinH> @undef
18:46:58 <lambdabot> Undefined.
18:47:10 <ReinH> @let (<..>) = liftA2 (.)
18:47:11 <lambdabot>  Defined.
18:47:21 <ReinH> :t \f g h -> f <..> g <..> h
18:47:22 <lambdabot> Applicative f => f (b1 -> c) -> f (b2 -> b1) -> f (a -> b2) -> f (a -> c)
18:48:16 <ReinH> The f (a -> c) can be hit with (<*>) to give the f a -> f c of the original composition laws
18:49:11 <ReinH> I guess it would be f (a -> d) if we were labeling the types the usual way.
18:49:29 <waterdrop> ReinH: Uh, I'm understanding that to just mean that partially applying <*> to a value of type f (a -> c) gives me a function of type f a -> f c
18:49:36 <ReinH> Yep.
18:49:52 <waterdrop> okay sure, I see that's clearly true but I'm not sure what it has to do with the composition law
18:50:06 <ReinH> That's how you convert my form into the form given in the docs
18:50:14 <waterdrop> ah I see
18:51:04 <ReinH> The docs write the composition laws in terms of (<*>), which is lifted *application*, so you have to squint to see them as composition laws
18:52:25 <ReinH> If you write them in terms of lifted composition, you get an equivalent set of laws, but not the exact same laws.
19:53:43 <andrei> What's the lens way to create a prism that matches a predicate? Like [1,2,3] & ?? (== 2) .~ 5 (like ix but matches based on a function not a position)
19:54:40 <glguy> andrei: only :: Eq a => a -> Prism' a ()
19:55:42 <glguy> Your example doesn't need a prism, though. Maybe you don't need one?
19:55:49 <andrei> glguy: What if I want an arbitrary function, not necessiarly Eq
19:55:59 <andrei> Sure, it doesn't matter if it's a prism or not
19:56:20 <glguy> There's no lawful thing that does what you want as used in your example
19:57:00 <glguy> You can misuse filtered to accomplish it: http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Fold.html#v:filtered
19:57:44 <glguy> > [1..3] & mapped %~ \x -> if x == 2 then 5 else x
19:57:46 <lambdabot>  [1,5,3]
19:59:03 <andrei> Hmmm.. How would I use filtered as a setter?
20:00:27 <andrei> Ah I see
20:00:29 <andrei> [1,2,3] & partsOf (traversed.filtered (== 2))._head .~ 5
20:01:13 <glguy> [1..3] & mapped . filtered (2==) .~ 5
20:01:44 <glguy> but this breaks the ability to do future transformations based on traversal laws
20:04:05 <andrei> What do you mean?
20:07:31 <DigitalKiwi> look at glguy all scary with his hat
20:12:58 <glguy> Freenode's been spammy lately, I set some rules to try and ban the spam faster
20:20:09 <glguy> Of course as soon as I did that the spam subsided for the day, so... you're welcome?
20:20:33 <wollw> Thank you.
20:46:31 * hackage ats-format 0.1.0.9 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.9 (vmchale)
22:41:24 <jchia_1> When describing functions, especially when writing haddock documentation, do people do anything to clarify the distinction between the return value of a function and what a Monad returns (pure)? I'm thinking of using 'pure' as a verb and using 'return' to solely mean the value a function application evaluates to
22:43:02 <geekosaur> when it's some up, I tend to use "result type" rather than talking about "return (type|value)" of a function
22:43:08 <geekosaur> or result value
22:44:21 <geekosaur> that said, things are kinda tending in the direction you are talking about; in fact, a large part of putting Applicative behind Monad is that it's widely believed that the name "return" was a confusion-generatinging mistake
22:44:26 <geekosaur> er. generating
22:44:34 <geekosaur> (ingngngng...)
22:45:30 <geekosaur> and at some point (possibly as soon as ghc 8.6; but it was originally slated for 8.0!) "return" will be deprecated ("monad of no return" proposal)
22:48:15 <geekosaur> er. also "when it's come up" earlier.
22:48:24 <geekosaur> apparently it's derp night for me...
22:50:56 <jchia_1> "foo :: Int -> Int; foo x = x * x". "-- | Returns square of @x@"? "-- | Pures square of @x@"? Something else?
22:51:27 <jchia_1> "-- | The return value of foo is the square of @x@"
22:51:38 <geekosaur> I'd say "produces"
22:51:45 <geekosaur> in some contexts "results in"
22:52:05 <geekosaur> and :"the result of foo is..."
22:52:45 <geekosaur> basically I try to avoid the ambiguous "return" entirely unless talking specifically about Monad's "return"
22:53:12 <geekosaur> and even then, "pure" is a less confusing alternative
22:55:35 <jchia_1> 'Produce' is a good option.
22:58:25 <jchia_1> In some other languages, the variable names of function arguments are used in documentation and in the documentation you can refer to them. In haddock, it seems that you only get the type signature but not the argument names automatically, so if you write "-- | Produces the blah of @x@ given the blih @y@." to document some function, the reader of the haddock would not know what x and y refer to without reading the source.
23:00:10 <jchia_1> So, if we want to be clear about what value a function produces, we have include a piece of code in the documentation like this "-- | @foo x y@ produces the blah of @x@ given the blih @y@"
23:00:21 <jchia_1> Is this just how it's done or is there a better way?
23:00:42 <jchia_1> It's not very DRY.
23:01:00 <jchia_1> If you change function name or argument variable name, you have to change the documentation.
23:01:29 <MarcelineVQ> would you prefer something like _1 _2 referring to argument positions?
23:01:55 * geekosaur shrugs
23:02:27 <geekosaur> both GNU getopts_long conventions and emacs lisp documentation work that way (with parameter names uppercased by convention)
23:02:41 <geekosaur> it works, it's reasonably common and therefore widely understood
23:03:34 <geekosaur> less than idea from DRY, but on the other hand it's an incentive for programmers to actually keep their docs up to date --- and, really, we need more such incentives
23:04:33 <jchia_1> MarcelineVQ: I think it may be helpful if haddock were smarter and detects that you are refering to arguments in the documentation, in which case the generated documentation will also include the names of the variables referenced in the documentation, perhaps alongside the type signature of the function.
23:06:31 <jchia_1> But of course, if you define the function in a point-free style, you don't get the benefit.
23:06:32 <geekosaur> problem is programmer provided names often kinda suck as far as documentation is concerned. how meaningful is 'x'?
23:06:57 <geekosaur> there is already per-parameter markup possible for that (-- ^ iirc?)
23:07:04 <geekosaur> not widely used, but that's not haddock's fault
23:07:32 <geekosaur> getting programmers to write useful documentation is like pulling teeth
23:08:52 <geekosaur> making it easier to write doesn't help; you still get one-line useless "gems" that don't e.g. mention parameters at all
23:08:57 <geekosaur> much less document them
23:09:10 <jchia_1> geekosaur: I like descriptive argument names instead of one-letter ones when I can think of a reasonable name, but sometimes it's too abstract to think of a good name.
23:11:01 <geekosaur> (example, I'm currently working on a program which is essentially a basic physics engine but for a modified physics. the functions that have short parameter names mostly lift them from common physics usage. everything else is reasonably descriptive. but not documented because I don't expect anyone but me to care about Weird Physics.)
23:11:45 <geekosaur> (there are comments explaining what's going on, although they relate to a corpus which gave rise to the Weird Physics)
23:13:38 <jchia_1> geekosaur: Didn't know about (-- ^). I'm going to try it.
23:14:38 <geekosaur> you should probably doublecheck the haddock manual to make sure I didn't misremember
23:14:53 <jchia_1> It's there. https://www.haskell.org/haddock/doc/html/ch03s02.html
23:15:07 <geekosaur> there is *some* markup for it, but I write so little code for public consumption that I don't recall the haddock markup off the top of my head very well
23:15:41 <MarcelineVQ> jchia_1: http://haskell-haddock.readthedocs.io/en/latest/markup.html#documenting-parts-of-a-declaration is also an option if you find that format more readable
23:15:48 <MarcelineVQ> *webpage format
23:18:49 <jchia_1> MarcelineVQ: It's more readable.
23:22:47 <sqooq> why does audio filtering
23:22:51 <sqooq> have to involve integrals
23:24:38 <MarcelineVQ> something about bits probably, bits are the enemy
23:25:22 <geekosaur> slightly lower level than that, I think
23:25:44 * geekosaur had to deal with an integral too. cheated and went with a geometric mean between steps
23:26:02 <geekosaur> doens't work for audio unfortunately
23:26:33 <sqooq> hmm
23:26:40 <sqooq> I wonder how circuits are simulated
23:26:46 <sqooq> how is an RC circuit simulated
23:26:48 <sqooq> if I can figure that out
23:26:56 <sqooq> I can probably do what I want
23:29:22 <sqooq> or I just need to approximate inverse fourier
23:31:05 <sqooq> https://en.wikipedia.org/wiki/RC_circuit#Integrator
23:31:07 <sqooq> :thinking:
23:31:42 <sqooq> Output voltage is integrator/differentiator? If that's true it explains everything and it's probably how the circuits are simulated
23:32:02 <sqooq> because if I'm not mistaken, a property of resistors is that they respond less to higher frequencies, or something like that
23:32:05 <sqooq> it may be the inverse.
23:38:22 <sqooq> man I am not qualified for this shit
23:39:42 <geekosaur> sqooq, capacitors are high pass filters
23:39:54 <geekosaur> block DC entirely, pass more as frequency increases
23:40:10 <sqooq> that's what it is then
23:40:17 <sqooq> but then how are they simulated digitally?
23:40:29 <geekosaur> resistance in series with capacitance means you introduce a time delay and therefore a resonance.
23:41:10 <sqooq> capacitance is time delay?
23:42:48 <geekosaur> resistance is
23:43:04 <geekosaur> because it turns DC into a ramp current
23:44:24 <sqooq> yeah I don't know anything about circuitry
23:44:30 <geekosaur> then the capacitor passes the resulting current at some point depending on its capacitance, and the resistance and capacitance together determine the frequency of the resistive ramp current and the resulting resonant frequency of the circuit
23:44:49 <sqooq> interesting
23:44:54 * geekosaur studied basic EE, plus ham radio license somewhere in distant past
23:44:59 <sqooq> nice
23:45:02 <matsurago> can you guys tell what is a common build tool to organize a haskell project in production? is it Cabal? or there is something else? or people use Makefiles?
23:45:24 <geekosaur> matsurago, cabal-install ("cabal" command at shell) and stack are common
23:45:27 <sqooq> Do you think I can make a lowpass filter for arbitrary signal in continuous time just using math?
23:45:58 <geekosaur> just using math, yes. in a circuit you want an inductance (coil) instead of a capacitance
23:46:07 <matsurago> geekosaur: thanks. so there are no alternatives to that?
23:46:23 <geekosaur> matsurago, none widely used. ghc itself uses Makefiles, but it's a pain in the ***
23:47:15 <geekosaur> (and about to be supplemented by Hadrian as a future build system, but that's something of a test case --- Hadrian is still evolving and I wouldn't use it in production just yet)
23:47:20 <sqooq> voltage holds the signal right, not current or otherwise?
23:47:28 <geekosaur> github.com/snowleopard/hadrian
23:47:44 <geekosaur> sqooq, depends on what you consider the signal to be.
23:47:58 <sqooq> like if you input a sine wave
23:48:02 <sqooq> how
23:48:11 <sqooq> how do you input a sine wave, and what value represents it
23:48:12 <geekosaur> it's voltage for amplitude modulation, there's also frequency modulation and phase modulation
23:48:36 <geekosaur> AM is by far the simplest
23:49:57 <geekosaur> a sine wave is described by its frequency and its amplitude
23:52:17 <exio4> FM is quite simple too, isn't it?
23:54:18 <sqooq> apparently this is an rc lowpass equation
23:54:19 <sqooq> https://wikimedia.org/api/rest_v1/media/math/render/svg/945a2aa0727e1b509dd3a7821573ab30a11f74d1
23:54:27 <geekosaur> simpler than phase, certainly. you still need something to pull the audio (which is most easily represented as AM because it translates trivially to a pressure wave) out of the frequency changes. this is a discriminator in commercial FM radios, but an AM radio tuned off the center frequency can use "slope tuning" to get a somewhat dirty signal
23:54:27 <sqooq> which gets discretized to give the discrete form
23:55:14 <sqooq> so, 1, it's recursive
23:55:32 <sqooq> 2 it's the derivative of the output*rc (whatever rc is lol)
23:55:36 <sqooq> + vin
23:56:22 <sqooq> i think this at least brings me a step closer
23:56:28 <geekosaur> differential equation, actually
23:57:05 <geekosaur> if you thought integrals were bad, you're *really* in for fun now...
23:57:33 <sqooq> what this can't be implemented directly?
23:57:46 <sqooq> dv/dt is the derivative of voltage no?
23:59:22 <geekosaur> over time, yes. but, where simple derivatives are simpler than integrals, this is more or less an "inverse integral"
