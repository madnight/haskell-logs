00:03:18 <atodorov> hi folks, has anyone seen this problem when trying to install math-functions (Expecting a type of the form: cxts => typ -> rep, error message coming from vector-th-unbox), see https://github.com/bos/math-functions/issues/52? 
00:07:32 * hackage yu-auth 0.1.0.0 - Auth module for Yu.  https://hackage.haskell.org/package/yu-auth-0.1.0.0 (qinka)
00:08:25 * hackage yu-core 0.1.0.0 - The core of Yu.  https://hackage.haskell.org/package/yu-core-0.1.0.0 (qinka)
00:09:05 * hackage yu-launch 0.1.0.0 - The launcher for Yu.  https://hackage.haskell.org/package/yu-launch-0.1.0.0 (qinka)
00:10:20 * hackage yu-tool 0.1.0.0 - Tool for Yu  https://hackage.haskell.org/package/yu-tool-0.1.0.0 (qinka)
00:12:30 * hackage yu-utils 0.1.0.0 - Utils for Yu  https://hackage.haskell.org/package/yu-utils-0.1.0.0 (qinka)
00:13:07 <atondwal[m]> is there an easy way to be like "I haven't decided what type this field in my record is yet, don't bother e about it"? I tried `forall a.a`, but it gives me trouble with the predicativity restriction every time I use it
00:13:44 <mniip> Any seems like a good choice
00:14:37 <tdammers> atondwal[m]: () would be the canonical choice
00:14:41 <atondwal[m]> mniip:  Any?
00:14:56 <geekosaur> @index Any
00:14:56 <lambdabot> GHC.Exts, Data.Monoid, GHC.Prim
00:15:05 <mniip> GHC.Exts.Any
00:15:07 <geekosaur> youdon't want the Mon odi one, but the prim
00:15:18 <geekosaur> *Monoid one
00:16:08 <atondwal[m]> cool, thanks!
01:08:36 <kuribas> I'd like to propose a new idea: a weak thunk, like a weak ref.
01:08:58 <quchen> ..?
01:09:18 <kuribas> Basicly, when the thunk is not null, and the value it refers to isn't referred to anywhere else, it will be garbage collected.
01:09:19 <quchen> It’s like a thunk, but not tracked by the STG?
01:09:32 <kuribas> quchen: yeah
01:09:46 <quchen> What is a »not null« thunk?
01:09:55 <kuribas> quchen: evaluated thunk
01:10:04 <kuribas> quchen: not sure what's the right term
01:10:46 <quchen> The »T« in STG stands for »nobody keeps track of whether something is evaluated« :-þ
01:11:33 <kuribas> quchen: is my notion that a thunk is like a mutable maybe value wrong?
01:13:14 <kuribas> the idea is to prevent sharing when the value is big.
01:13:22 <quchen> That’s a good first-order approximation at best. In the STG, every value is a thunk; it’s just that some thunks require evaluation when you want to work with them, and some don’t
01:13:54 <quchen> Well, every value is a closure.
01:14:19 <quchen> Now I’ve confused myself, because all of these words mean multiple things.
01:14:47 <quchen> Anyway, bottom line is: a thunk is not an (Either <computation> <final value>).
01:15:51 <quchen> kuribas: Technically, a thunk is a function that takes no arguments and that is not a data constructor.
01:17:24 <quchen> kuribas: Maybe the readme here is helpful as a first intro to STG, https://github.com/quchen/stgi/
01:17:47 <kuribas> quchen: but it memoizes the value right?
01:18:38 <quchen> Thunks? Yes, they may be overwritten with the value they evaluate to (in-place).
01:18:40 <atondwal[m]> "evaluated" is a notion that makes sense for any type that's an instance of NFData
01:19:21 <quchen> kuribas: The standard lifecycle of a thunk is »computation -> blackhole -> constructor/function«.
01:19:46 <quchen> A black hole is a marker that says »this thunk is currently in evaluation«.
01:21:04 <quchen> A constructor is a closure whose body is a constructor application, such as »\(no args) -> Just foo«.
01:21:13 <quchen> A function is a closure that takes arguments.
01:21:42 <quchen> (Constructors/functions is what would be WHNF in STG)
01:43:10 <drdo> Is there an extension to allow identical names for constructors (in different data types) yet?
01:44:57 <merijn> drdo: You don't need an extension, but you have to define them in separate modules
01:45:13 <merijn> drdo: Also, there's fundamental problems with doing that sort of thing unqualified
01:46:31 * hackage req 1.0.0 - Easy-to-use, type-safe, expandable, high-level HTTP library  https://hackage.haskell.org/package/req-1.0.0 (mrkkrp)
01:52:02 <drdo> merijn: Interesting, what sort of issue are we talking about?
01:52:30 <mniip> hehe
01:52:37 <mniip> I'm not the slowest haskellperson
01:52:40 <merijn> drdo: Well, suppose I have type Foo and Bar both with the constructor Xyzzy. If I now write "x = Xyzzy" in my code, what's the type of 'x'?
01:52:43 <mniip> (AoC)
01:53:06 <drdo> merijn: Complain about a type error, naturally
01:53:17 <drdo> well, ambiguous
01:53:38 <merijn> drdo: Now people have had the idea of "type-directed name resolution", where you look at the type to decide which version of a name people used. The problem is that this makes it incredibly tricky to read code
01:53:40 <mniip> x :: HasConstructor "Xyzzy" '[] a => a
01:53:59 <drdo> mniip: Or that, like they did with record fields
01:54:10 <mniip> yeah but it's more tricky with constructors
01:54:17 <mniip> actually my type is wrong
01:54:20 <merijn> drdo: Because now I have "... Xyzzy ..." in the middle of some complex expression. Now I need to, in my head, infer all the types of the expression to decide which Xyzzy this is
01:54:38 <mniip> unless
01:54:41 <drdo> merijn: I'm not sure this last thing is a real issue in practice
01:54:53 <Cale> merijn: Worse than that, you have an exponential blowup in the size of the expression of different combinations to try
01:55:03 <merijn> drdo: ^^^ what Cale said
01:55:16 <mniip> HasConstructor c (r ': v) a => HasConstructor c v (r -> a)
01:55:31 <mniip> but that sounds like a nightmare to infer
01:55:45 <mniip> and the ambiguity checks
01:55:59 <merijn> drdo: In OO this works ok, since methods are always directly invoked on an instance of a class, so you always just know it's the one belonging to that specific instance
01:56:35 <merijn> drdo: In practice, the inability to have the same constructor name in the same module has never been that much of a problem for me
01:56:47 <drdo> It's not a super issue, just annoying sometimes
01:57:15 <drdo> For example right now I have Query and Response types, and I want to have the same constructor names for each
01:57:30 <drdo> Instead I'm going to have to suffix every construct with "Q" or "R" or something like that
01:57:34 <drdo> *constructor
01:58:52 <tdammers> this isn't even a real semantics problem, just a namespace one
01:59:06 <tdammers> unless you actually want the constructor to be polymorphic
01:59:09 <drdo> There's no semantic problem, it's purely aesthetic
02:00:19 <drdo> One place where there's a semantic issue is when you want to subtype by adding more constructors to an existing type, which you can't really do as far as I know
02:01:57 <drdo> So you either end up with two almost identical types and write silly embedding functions, or you just define the large type and don't use the type system to ensure you have the small type when you're supposed to
02:02:01 <merijn> drdo: I'm strongly against subtyping anyway
02:05:15 <drdo> Or you do some fancy type level stuff to ensure you can't construct what you aren't supposed to, but then you may or may not be able to easily prove that things work out
02:05:27 <phadej> drdo: newtype Bigger = Bugger ((Either More Smaller)
02:05:42 <drdo> phadej: Yes, but that's just ugly :P
02:05:58 <phadej> drdo: It's fair to want more convinent approach, but you have to make trade-offs at some point
02:06:22 <phadej> e.g. trees that grow is boilerplate heavy in other place
02:06:32 <merijn> Depending on the kind of subtyping you could also just use "Haskell OO"
02:06:57 <drdo> The last case where I wanted this was when writing code involving temporal logic
02:07:11 <tdammers> merijn: why the quotes?
02:07:16 <phadej> i.e data Foo x = Foo1 Int | Foo2 True | FooExt (FooExtFam x)
02:07:27 <drdo> I basically wanted to have pure present, pure past, pure future and full TL using the type system
02:07:46 <phadej> drdo: as an exercise, try to make that typed in C++
02:07:58 <drdo> I tried doing some fancy type level stuff, but it turned out to be hard to then prove that things worked out
02:08:23 <phadej> that will callibrate your expectation bar of what you can do with type-system ;)
02:08:38 <atondwal[m]> okay this is just me hoping, but does anyone have an SMT2LIB lisp interpreter laying around?
02:09:03 <merijn> drdo: Once you start trying that stuff, you may wanna consider Idris :p
02:09:17 <drdo> merijn: I did write a lot of it in agda at some point haha
02:10:48 <drdo> But I got really tired of proving trivial shit all the time
02:10:48 <drdo> I actually had a program to write and got a bit carried away xD
02:16:04 <ertes-w> i found a nice exception handling pattern
02:16:30 <ertes-w> @let catchWith c f = catchJust f c id
02:16:32 <lambdabot>  Defined.
02:16:35 <ertes-w> :t catchWith
02:16:37 <lambdabot> Exception e => IO a -> (e -> Maybe (IO a)) -> IO a
02:17:11 <ertes-w> this makes a lot more sense than catchJust, which disconnects the selector from the handler
02:22:09 <quchen> ertes-w: Hah, I didn’t even know about catchJust. Is it new?
02:22:17 <merijn> quchen: Pretty old, afaik
02:22:34 <ertes-w> quchen: it's been around for a long time
02:23:15 <quchen> And the semantics are »Nothing is success, Just is failure«, urgh
02:23:57 <merijn> quchen: It's entire type would make no sense otherwise
02:24:15 <quchen> merijn: Sure, but it’s confusing nevertheless
02:24:30 <quchen> Especially since when we’re in an exception context, Nothing is strongly associated with failure
02:24:37 <merijn> quchen: I don't think so. Just invert your logic. It returns "just" the exceptions we actually wanna handle
02:24:41 <ertes-w> quchen: does the type of catchWith make more sense to you?
02:25:00 <ertes-w> consider that it's just 'catch', where you choose to ignore some exceptions
02:25:10 <ertes-w> ("ignore" as in "propagate")
02:25:26 <ertes-w> Just = "i have a handler for this one!"
02:25:28 <merijn> ertes-w: I'd say, it's just "catch" where you choose to "just" handle some of them :p
02:25:29 <quchen> ertes-w: They both make sense, but I don’t think they’re intuitive. I like yours more though.
02:25:52 <ertes-w> haha
02:27:46 <ertes-w> quchen: well, it's a personal thing…  i remember that 'filter' used to confuse me, because i thought it would remove (you know, "filter") the elements that match the predicate =)
02:28:38 <merijn> ertes-w: I *still* have to look up which way filter works every time I use it
02:29:44 <liste> if only they named it "keep"
02:32:22 * hackage tasty-hunit 0.10 - HUnit support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-hunit-0.10 (RomanCheplyaka)
02:34:00 <ertes-w> at least there is an mnemonic with catchJust: the name itself
03:10:23 * hackage myanimelist-export 0.1.0.0 - Export from MyAnimeList  https://hackage.haskell.org/package/myanimelist-export-0.1.0.0 (mat8913)
03:11:42 <MarcelineVQ> ^ haskell was a mistake
03:12:52 * hackage req-conduit 1.0.0 - Conduit helpers for the req HTTP client library  https://hackage.haskell.org/package/req-conduit-1.0.0 (mrkkrp)
03:31:13 <Boomerang> I was wondering, is there any particular reason why we can't define data types in a where clauses? Is there a language extension to enabled this kind of scoped type definition?
03:32:01 <phadej> what would the type of foo = Foo where data Foo = Foo be?
03:32:04 <MarcelineVQ> there isn't, I've also wondered that, though haven't come up with compelling reasons to have them either
03:32:48 <Boomerang> phadej: The use case would be for the state of a state machine where the state doesn't need to be seen outside the function
03:32:57 <tdammers> phadej: Foo, but you wouldn't be able to do anything useful with it because the name Foo wouldn't be available outside the scope of that function
03:33:22 <phadej> what's if I have data Foo = Bar in outer scope?
03:33:25 <tdammers> Boomerang: you can currently do that by declaring a regular data type and hiding it behind a module export wall
03:33:47 <tdammers> personally though, I would love to have a more general notion of anonymous types
03:34:05 <Boomerang> tdammers: Yeah that's what I do :) But then I can't reuse my unimaginative constructor names in several state machine
03:34:22 <tdammers> Boomerang: sure you can, just import qualified
03:34:29 <Boomerang> (in the same module)
03:34:42 <tdammers> yeah, you need a separate module per state machine then
03:34:46 <MarcelineVQ> tdammers: there's anonymous sums now :D
03:35:05 <tdammers> MarcelineVQ: oh, that sounds like fun
03:35:11 <Boomerang> It's not really an issue, I was just wondering if there is anything at the language level that prevents such a feature
03:36:16 <MarcelineVQ> tdammers:  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-sums
03:36:31 <phadej> I think that the pain would be in inventing some syntax to reference these inner types in type-errof message etc.
03:36:43 <phadej> Making new module isn't *that* painful.
03:37:38 <tdammers> MarcelineVQ: that seems to be more a performance thing than anything though
03:48:04 <Gurkenglas> Why does Text.Pandoc.Lens provide "_Span :: Prism' Inline [Inline]" instead of "_Span :: Prism' Inline (Attr, [Inline])"?
03:55:52 <ertes-w> MarcelineVQ: huh?
03:56:48 <ertes-w> Boomerang: i would love to have that feature
03:57:02 <Boomerang> :)
03:57:08 <ertes-w> phadej: foo :: exists a. a
03:57:24 <ertes-w> foo is still well-typed, but the type is just not in scope
03:58:03 <ertes-w> Boomerang: however, you can do state machines using recursion instead
03:58:52 <ertes-w> Boomerang: data Stream m a = forall s. Stream s (s -> m (a, s))
03:59:11 <ertes-w> Boomerang: newtype Stream m a = Stream (m (a, Stream m a))
03:59:16 <ertes-w> these types are isomorphic
04:00:23 <Boomerang> ertes-w: The specifc example I had in mind was for implementing mealy machine in CLaSH (so recursion wouldn't work the same way). I just thought scoped type definition might be useful for more than just this.
04:01:11 <Boomerang> https://hackage.haskell.org/package/clash-prelude-0.11.2/docs/CLaSH-Prelude.html#v:mealy
04:02:27 <Boomerang> Your recursive data type is interesting, I will try to wrap my head around it
04:02:32 <ertes-w> Boomerang: https://hackage.haskell.org/package/machines-0.6.3/docs/Data-Machine-Mealy.html
04:02:47 <ertes-w> Boomerang: you can translate a Mealy to a 'mealy'
04:02:53 <phadej> ertes-w: there's no exists in Haskell, you have to fake it :)
04:04:11 <ertes-w> phadej: and that would probably look something like this:  foo :: __GHC_Invisible_Type_52358762
04:04:14 <ertes-w> =)
04:05:03 <Taneb> ertes-w: the issue there is CLaSH is compiled to VHDL and needs a concrete bit representation of its internal state
04:05:24 <Taneb> So clever existential tricks and recursive types aren't available
04:05:55 <ertes-w> Taneb: 'mealy' doesn't reflect that though…  it's fully polymorphic in 's'
04:06:34 <Taneb> ertes-w: it uses a different compiler, comparable to GHCJS, which doesn't allow that
04:07:06 <Boomerang> The 'mealy' function I pointed to, while it works in Haskell is meant to compile with clash for which recursion is a bit different
04:07:09 <ertes-w> ah, it's not compiled by GHC?
04:07:54 <Taneb> ertes-w: not too sure of the internals but I think it's a completely separate backend that's not feature-complete with GHC
04:08:15 <Boomerang> In clash recursion really means hardware feedback (you can't have feedback in the same clock cycle)
04:08:24 <ertes-w> this is why i prefer EDSLs
04:09:14 <Taneb> ertes-w: https://hackage.haskell.org/package/clash-prelude-0.11.2/docs/CLaSH-Tutorial.html#g:20 has a comparison between CLaSH and Lava (a DSL approach to the same problem)
04:10:31 <Taneb> Honestly I think it winds up six and two threes
04:11:15 <ertes-w> well, couldn't you implement Mealy in CLaSH?
04:12:16 <Taneb> Not currently, as its bitsize is hard to determine and may not be finite
04:12:19 <merijn> ertes-w: I'm not sure a recursive type like Mealy even makes all that much sense in FPGA terms?
04:13:11 <ertes-w> merijn: well, you can flatten the recursion in something like Mealy…  it's really equivalent to 'mealy'
04:14:35 <Boomerang> It's only equivalent to 'mealy' if you put one state change per clock cycle. It might be possible, not sure...
04:17:22 <ertes-w> well, there is an equivalent formulation of Mealy using an explicit state value, so at least you can get the API of Mealy
04:17:45 <ertes-w> data Mealy a b = forall s. Mealy s (s -> a -> (s, b))
04:18:11 <ertes-w> in haskell there is an explicit isomorphism between the two (in CLaSH probably not)
04:18:30 <Taneb> ertes-w: I think even then the existential may cause awkwardness
04:19:07 <ertes-w> Taneb: any kind of awkwardness 'mealy' doesn't cause?
04:19:41 <ertes-w> mealy's type can be interpreted as:  mealy :: (∃ s. (s, (s -> a -> (s, b)))) -> Signal a -> Signal b
04:19:58 <Taneb> ertes-w: in 'mealy' the state is external which might make the CLaSH compiler deal with it easier
04:20:24 <Taneb> Actually, I'm not sure if it would or not...
04:21:02 <ertes-w> does it even support existentials?
04:21:12 <merijn> Doubt it
04:21:30 <ertes-w> well, you can factor out the existential
04:21:49 <ertes-w> data MealyFor s a b = Mealy s (s -> a -> (s, b))
04:21:56 <ertes-w> mealy :: MealyFor s a b -> Signal a -> Signal b
04:22:00 <Taneb> Yeah, that would be fine
04:22:28 <ertes-w> but then of course MealyFor doesn't have nearly as nice an interface as Mealy
04:22:36 <Younder> let's preempt this wrong, wrong and wrong
04:22:45 <Taneb> Although I think at some point we've missed the point of this whole exercise, which was not to have an explicit state type
04:23:26 <Boomerang> I like the expliciteness of the state type, I just want it scoped ^^
04:23:32 <ertes-w> well, if you can't have recursion, i don't see how you could get rid of the explicit state
04:24:25 <Younder> Now the statement, (since Mathematicians seem compelled to make them) monads are just a elaborate way of doing C in Haskell
04:24:28 <ertes-w> even in the explicit-state case the way the state value becomes actual "state" in the sense of the word is by having recursion somewhere else
04:25:06 <ertes-w> in the case of CLaSH you could think of the chip itself doing the recursion
04:25:13 <Younder> I am sying this because many C programmers (like myself) feel this way
04:25:18 <Younder> saying
04:25:56 <ertes-w> Younder: that's not a true statement though…  IO is what lets us write C in haskell
04:26:04 <ertes-w> except that IO is not really like C at all
04:26:26 <Younder> I am led to understand that this is not the case. That Haskell's way is mathematically correct. But being a 'dumb' C programmer i don't see this.
04:26:52 <Taneb> Younder: in Haskell you can have a list [print 1, print 2, print 3]
04:27:14 <ertes-w> Younder: we can't write C in haskell…  or rather, if we tried, we would severely violate haskell's semantics
04:27:55 <ertes-w> Younder: that's why our approach is funadmentally different to C:  a value of type (IO A) is an action that, when executed, produces a value of type A
04:27:59 <Taneb> Younder: and then you can not run any of them, run one of them, run all of them after reversing them, run them in a loop, pass them to a function or whatever
04:28:16 <ertes-w> Younder: our approach is to compuse such IO values instead of building effect statements into our main language
04:28:22 <ertes-w> *compose
04:31:48 <ertes-w> Younder: that's also why our control structures are functions and not built-in statements
04:32:00 <ertes-w> Younder: for example 'catch' to catch exceptions is a function
04:33:34 <ertes-w> Younder: note that this has nothing to do with monads…  IO happens to be a monad, which means that it gives us a certain interface, but then many other things are monads as well
04:34:03 <ertes-w> > do x <- [1..3]; y <- [10,20,30]; pure (x, y, x + y)
04:34:06 <lambdabot>  [(1,10,11),(1,20,21),(1,30,31),(2,10,12),(2,20,22),(2,30,32),(3,10,13),(3,20...
04:34:07 <dminuoso> ertes-w: Wasn't it even that in the beginning of Haskell IO was not done with monads?
04:34:12 <merijn> dminuoso: Correct
04:35:07 <dminuoso> How was IO handled? Did you explicitly have to accept an IO argument and return it?
04:35:09 <merijn> dminuoso: Haskell didn't use monadic IO until Haskell 1.4 (1997), while the original committee started in 1989 and the first Report dates to 1990
04:35:26 <ertes-w> dminuoso: and monads came into programming for abstracting the idea of computation, not necessarily IO
04:35:39 <merijn> dminuoso: Main was a function "[IOInputAction] -> [IOOutputAction]"
04:35:53 <dminuoso> ertes-w: Yeah. Ive come to realize that monad is just programming pattern (with a profound mathematical background)
04:35:55 <merijn> dminuoso: Taking a lazy list of input IO events and turning them into a lazy list of output IO events
04:36:02 <Younder> ertes-w, Thx I will se what I can use
04:36:21 <ertes-w> Younder: you want to learn haskell?  or transfer haskell concepts to C?
04:36:47 <merijn> dminuoso: Hell, Applicative wasn't invented until 2004, 14 years after the first Haskell version
04:37:06 <Younder> ertes-w, I want to argue the use of Haskell in en environment used to C.
04:37:21 <dminuoso> merijn: Boy I cant seem to find anything about IOInputAction or IOOutputAction on the internet.
04:37:28 <merijn> dminuoso: Given how prevalent Applicative is now, it's hard for beginners to appreciate these things weren't around from the start, but just got massive adoption simply due to being MUCH better than what was around
04:37:32 <merijn> dminuoso: I made those typenames up
04:37:47 <ertes-w> Younder: haskell is really hard to sell to C programmers…  people use C because they want absolute control, whether it's good for them or not
04:37:52 <dminuoso> merijn: How did you work with that? I mean what would be the equivalent of some: putStrLine "bla"\n name <- getLine ?
04:37:57 <dminuoso> merijn: Oh.
04:38:02 <ertes-w> Younder: haskell takes a lot of that control away from the programmer
04:38:05 <Younder> ertes-w, I do feel a bit weak on my feet though. So I was looking for stronger arguments.
04:38:53 <ertes-w> Younder: the main point to get across to C programmers is that that sacrifice is worth it
04:39:30 <merijn> dminuoso: If you're curious, see page 69 of https://encrypted.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0ahUKEwjq_9eO6ujXAhVQzKQKHVtJAH8QFggoMAA&url=https%3A%2F%2Fwww.haskell.org%2Fdefinition%2Fhaskell-report-1.2.ps.gz&usg=AOvVaw1yOJxxkp8kO1RkjalO3R95
04:39:33 <ertes-w> Younder: C++ programmers are easier to convince, because they already buy into the idea of *abstraction*
04:39:50 <Younder> ertes-w, Yes the time it take something to compile is scary. To me and my programmers. Is there a edge where you are more productive or does it remain this slow grind?
04:39:52 <ertes-w> Younder: i've seen C programmers who flat-out reject any form of abstraction (save for C itself)
04:40:33 <ertes-w> Younder: consider the semantics/LoC factor
04:40:52 <Younder> Does it pay back when you try to maintain it. It needs to..
04:40:54 <ertes-w> Younder: GHC is much slower than GCC in terms of lines/time, but then a line of haskell is much richer than a line of C
04:41:07 <merijn> ertes-w: Depends what you're compiling with GCC :p
04:41:23 <merijn> I'm an expert in making GCC slow :p
04:41:28 <ertes-w> Younder: well, i do use haskell, and i think it pays back, but it's hard to quantify
04:41:35 <merijn> Hell, I managed to segfault clang yesterday! \o/
04:41:40 <ertes-w> heh
04:41:52 <merijn> So proud of myself :>
04:43:10 <dminuoso> merijn: Okay this is looking... *strange*
04:45:44 <ertes-w> Younder: consider something like 'foldr'…  this is a function that takes three lines of haskell, including the optional type signature…  it's a simple list traversal function, but it captures a very common iteration pattern you have seen in C, so you never have to write it out again
04:46:12 <ertes-w> Younder: but you can't write foldr in C, so you have to keep repeating yourself
04:46:43 <ertes-w> almost every time you write 'for' in C, you've missed an opportunity to just reuse foldr
04:46:54 <ertes-w> or one of its higher-level convenience functions
04:47:00 <ertes-w> > foldl' (+) 0 [1..9]
04:47:03 <lambdabot>  45
04:47:22 <Younder> ertes-w, agreed the code is more compact, but it takes me 3 times as long to come up with it
04:47:35 <ertes-w> Younder: the learning curve is indeed steep
04:47:42 <dminuoso> merijn: Oh so basically the program would continuously take one request object, produce a response, take another request object, produce another response.. 
04:47:48 <merijn> dminuoso: Yeah
04:48:07 <atondwal[m]> One of the benefits of shorter code is that it makes code review way easier
04:48:16 <merijn> dminuoso: Clearly the current monadic approach is FAR nicer
04:49:06 <atondwal[m]> well haskell in general: more concise + explicit state, means that you have to spend a lot less time puzzling out wtf is going on in someone else's code
04:49:18 <ertes-w> Younder: foldr not only facilitates DRY, but also completely rules out many common bugs, and because of parametricity it's actually difficult to get foldr itself wrong
04:50:12 <ertes-w> Younder: now apply that to every pattern you have ever seen…  unlike many other languages the fact that actions are first-class in haskell means that you can abstract *every* pattern
04:50:14 <dminuoso> Younder: Beginning to learn is always complicated. Just remember the first day you were introduced to pointers. Im guessing you added * and & left and right to expressions just to make it "compile" just to consectuveily ask "whats a segfault now?"
04:50:31 <dminuoso> Younder: I know I did.
04:50:55 <ertes-w> Younder: add to that the fact that abstraction in haskell only costs when it has to…  most abstractions are operationally free
04:51:15 <ertes-w> there are no in-memory "objects" or anything
04:51:23 * hackage yu-launch 0.1.0.6 - The launcher for Yu.  https://hackage.haskell.org/package/yu-launch-0.1.0.6 (qinka)
04:51:28 <ertes-w> that may be kinda appealing to C programmers
04:52:02 <dminuoso> merijn: I might want to see if I can find a pre 1.3 version and do some IO, just to really appreciate the monadic interface.
04:52:06 <Younder> Luckily 'slowness' is rarely a concern today. There is always excessive power. One of the reasons to switch to a higher abstraction language.
04:52:10 <dminuoso> But I have a feeling I wont find something that can run on macOS.
04:52:32 <ertes-w> Younder: oh, actually i disagree about that…  remember that CPUs aren't getting faster, and more and more of them run on batteries
04:52:38 <ertes-w> so efficiency is very important
04:52:41 <merijn> dminuoso: If you wanna go old school, try and contact Lennart whether he still has his first Haskell compiler :)
04:53:16 <ertes-w> Younder: haskell doesn't give you C levels of speed (for the most part), but it's reasonably fast
04:53:42 <fakenullie> does it give java level speed?
04:54:01 <dminuoso> fakenullie: If written correctly most benchmarks Ive seen put it around the same corner.
04:54:03 <merijn> ertes-w: Also depends on the kind of Haskell you write :p
04:54:06 <Younder> ertes-w, I am writing software now for a Jetson-TX1. I is a beautiful little machine the size of a credit card and using 11W.
04:55:13 <dminuoso> fakenullie: Though it highly depends. Sometimes there's code paths that the JVM can optimize fairly aggressively since HotSpot
04:55:22 <Younder> ertes-w, Still I am stuck with NVIDEA's choice of C++ libs like caffe. I can't see that changing anytime soon.
04:56:58 <Younder> So do I write a lot of 'GLUE' code or just go with the 'flow'. Am I wasting time or providing a strategic advantage. We all like error free code. And C has a bad record.
04:58:07 <Younder> Decisions decisions, why did I ever agree to this mess ;)
04:58:24 <cocreature> do we have a Float16 type somewhere?
04:58:35 <Younder> NOP
04:58:47 <cocreature> ah there’s a "half" package
04:59:03 <Younder> essential to getting 265 anemic CUDA cores to work.
04:59:10 <ertes-w> cocreature: you could also use Double arithmetic and encodeFloat/decodeFloat
04:59:13 <Younder> 256
04:59:25 <Younder> Worth atry
04:59:50 <cocreature> ertes-w: that seems like more work :)
05:00:01 <ertes-w> cocreature: definitely =)
05:01:28 <dutchie> hi folks, I'm struggling to get intero/terminfo to install properly on arch: http://lpaste.net/360412
05:01:38 <cocreature> ertes-w: Haskell tought me that being lazy is the right approach ;)
05:01:59 <dutchie> afaict the `config.log` file (and the whole tmpdir) where it's being built is being wiped out before I can get a look at what precisely the problem is
05:02:04 <ertes-w> Younder: it's probably not a good move to try to force haskell into existing projects, but nothing stops you from starting new projects
05:02:57 <ertes-w> Younder: that's how we got some rather popular haskell projects like pandoc and xmonad
05:02:59 <Younder> ROI is a kill-JOY
05:04:13 <Younder> Looks like it is C++, sorry
05:04:49 <ertes-w> (i'm a bit sad that darcs never really caught on)
05:05:17 <ertes-w> *up
05:05:24 <Younder> ertes-w, darcs lives on it that git which has more features.
05:05:42 <ertes-w> Younder: hmm?
05:05:51 <Younder> github sealed it
05:06:10 <fakenullie> did darcs resolve performance problems?
05:06:28 <ertes-w> fakenullie: not all of them…  a semi-successor project called pijul apparently did though
05:06:46 <Younder> let's face it Linux Pauing has more clout that Haskell
05:06:55 <ertes-w> i haven't tried it yet, because last time i checked there wasn't even an equivalent to git status/darcs whatsnew =)
05:07:18 <Younder> Darcs is still being developed. It is just not much used.. yet
05:07:30 <ertes-w> pijul, like darcs, is based on patch theory
05:08:55 <Younder> Quantum theory into a version control system Seriously that was inspired.
05:09:52 <ertes-w> it solves the remaining performance problems and also provides some of the UX features that are missing in darcs like in-directory patch sets ("branches")
05:10:22 <Younder> I don't get to say this often but I started out in theoretical physics. I love shit like that.
05:10:38 <ertes-w> also from what i've seen their equivalent to darcshub actually understands patch theory…  darcshub doesn't
05:10:53 <ertes-w> in fact the way darcshub tries to be github-for-darcs is rather stupid
05:14:15 <Younder> That C community is some 4 million strong. They have some pretty strong contenders.(We are not really really that dumb, at least not all of us)
05:15:42 <dminuoso> Younder: Just conflicted. For a new project there's frequently little reason to use C because we have a wealth of more suitable languages for most problems. C lacks almost any abstractions, while at the same time not being close enough to the hardware to take real control.
05:17:52 <Younder> I remember that Edi Weitz came up with a library for regexps that compile to assembly at runtime. Easy to so in CL, difficult in C. It didn't take long though before a similar lib was provided for C.
05:19:09 <Younder> dminuoso, I have been looking into RUST also. A wery hands on C lookalike that addresses some of the main fault areas of C.
05:19:19 <dminuoso> And C++.
05:19:31 <dminuoso> (I meant Rust addresses some of the main issues of C++)
05:19:49 <Younder> Of cource it lacks the beauty of Haskel.
05:20:00 <dminuoso> Well they have traits (typeclasses) at least, so there's that.
05:20:20 <hpc> they also got to linear types (of a sort) before haskell
05:20:30 <ertes-w> at the same time they still lack HKTs
05:20:33 <atondwal[m]> Younder: hey, me too! I used to do hep-th!
05:20:53 <ertes-w> and that compensates for all of those advantages
05:21:04 <ertes-w> C++ has them
05:21:34 <dminuoso> ertes-w: C++ templates make you want to claw your eyes out though.
05:21:49 <dminuoso> They have got to be the most unergonomic interface in programming languages since Malbolge.
05:21:52 <ertes-w> dminuoso: absolutely, but they support the kinds of abstractions i want to work with
05:21:52 <atondwal[m]> dminuoso: so does the rest of c++ though
05:21:55 <capisce> Younder: *Linus
05:22:48 <ertes-w> dminuoso: i'm really not interested in languages that lack HKT
05:23:28 <dminuoso> ertes-w: I have not explored HKTs in Haskell yet, but Ive heard them being considered so important when comparing Elm to PureScript in particular that I have a feeling that Im in for a ride.
05:24:04 <ertes-w> dminuoso: you're already using them
05:24:17 <dminuoso> Why did I see this coming..
05:24:49 <ertes-w> dminuoso: anything that abstracts over Foldable, Functor or Traversable uses HKTs
05:24:49 <mnoonan_> dminuoso: must be your abstraction powers at work ;)
05:25:18 <ertes-w> :t replicateM_
05:25:20 <lambdabot> Applicative m => Int -> m a -> m ()
05:25:21 <ertes-w> :t forever
05:25:24 <lambdabot> Applicative f => f a -> f b
05:25:27 <ertes-w> both of these need HKTs
05:25:41 <ertes-w> and yes, that does mean you can't implement them in rust =)
05:25:48 <mnoonan_> :k Applicative f => f a -> f b
05:25:50 <lambdabot> error: Not in scope: type variable ‘f’
05:25:50 <lambdabot> error: Not in scope: type variable ‘f’
05:25:50 <lambdabot> error: Not in scope: type variable ‘a’
05:25:55 <mnoonan_> aw
05:26:40 <ertes-w> :k forall a b f. Applicative f => f a -> f b
05:26:41 <lambdabot> *
05:29:14 <dminuoso> ertes-w: Noo. template <template <typename> class m> .. is a thing?
05:29:27 <ertes-w> dminuoso: yes
05:29:44 <merijn> dminuoso: Can do MUCH worse than that
05:30:46 <merijn> dminuoso: "Yo, dawg! We heard you like vararg templates, so we put vararg templates in your vararg templates so you can vararg while you vararg!" https://github.com/merijn/GPU-benchmarks/blob/master/TemplateConfig.hpp#L205-L214
05:31:02 <dminuoso> So.. a higher kinded type is just a type that has any other kind than * ?
05:31:13 <liste>  dminuoso yes
05:31:13 <dminuoso> like
05:31:15 <dminuoso> :k Maybe
05:31:17 <lambdabot> * -> *
05:31:20 <dminuoso> liste: Oh. That was easy then.
05:32:05 <dminuoso> merijn: Oh I know the feeling. About a year ago I tried writing a partial application helper in C++. Almost went mad.
05:32:19 <ertes-w> dminuoso: HKT usually stands for higher-kinded *polymorphism*…  obviously you can have something like Maybe in rust, but you can't *abstract over* something like Maybe
05:32:44 <Rembane> Hm...
05:32:46 <Rembane> :k Either
05:32:47 <lambdabot> * -> * -> *
05:32:49 <mud> Ya, in rust each one has a different interface (though they do reuse the same names over and over), but you still can't write (>>=)
05:36:04 <ertes-w> i just can't imagine why they wouldn't support that
05:37:12 <ertes-w> rust was never designed to be a go-like code monkey language, where they would intentionally omit features, so the dumbest people in the world could use it
05:37:49 <mud> I'd imagine it makes the type system a lot harder to do right? (not really sure)
05:38:25 <ertes-w> mud: not really, but you do need a kind system
05:39:06 <ertes-w> but honestly you could just do TypeInType and just reuse the same language and existing type checker
05:39:22 <mud> Hm. That was my only theory, then I dunno. It is a pretty visible lack, I mean you see the same method names come up like a thousand times, it's kind of obvious something is missing there.
05:39:34 <Xandaros> Wasn't there a package called "sized-containers" or similar? I can't find it... Contains things like a vector with length in the type
05:39:36 <mud> In practice it's not the worst, from the little rust I've written, but it is a tad annoying.
05:39:59 <cocreature> Xandaros: there is vector-sized
05:40:43 <merijn> ertes-w: HKT you mean?
05:40:51 <ertes-w> merijn: yeah
05:41:18 <merijn> ertes-w: There's (long-term) plans to support HKT in Rust, afaik?
05:41:31 <dminuoso> ertes-w: You mentioned "abstract over" twice now, Im still feeling a little lost
05:41:56 <Xandaros> cocreature: Not what I was thinking of, but I guess I'll just use that
05:42:10 <ertes-w> merijn: you mean like there is a long-term plan to add types to nix? =)
05:42:21 <ertes-w> dminuoso:
05:42:22 <ertes-w> :t fold
05:42:25 <lambdabot> (Monoid m, Foldable t) => t m -> m
05:42:32 <ertes-w> dminuoso: 't' is a type variable
05:42:37 <ertes-w> and it's of kind * -> *
05:42:45 <mud> I think rust has a slighly better track record of actually following through on their long-range plans, from what I recall.
05:42:49 <dminuoso> Ahh. 
05:43:04 <merijn> ertes-w: Hell, afaik there's plans to add HKT to Swift :p
05:43:10 <ertes-w> hahaha
05:43:11 <ertes-w> of course
05:43:31 <dminuoso> ertes-w: Now its clicking. I must have read "you can treat higher kinded types as first class citizens" so many times, it just became obvious.
05:43:35 <merijn> ertes-w: To be fair, some of the people working on Swift are pretty expert PLT people
05:43:57 <ertes-w> "yeah, come here, you bone-headed haskellers, we will eventually support those language features…  some day!"
05:44:25 <f-a> hi, is there any way to make ghci autocomplete case-unsensitive?
05:45:51 <dminuoso> ertes-w: This is so bizarre that I have been using these almost trivial looking things for weeks now.
05:45:55 <ertes-w> merijn: then why didn't swift come with HKTs from the start?
05:46:07 <ertes-w> it means that the fact that they have PLT experts doesn't mean anything
05:46:25 <ertes-w> it's still heavy-syntax, it's still OOP bullshit, the type system is still weak
05:46:31 <ertes-w> they reinvented the same language
06:45:24 <alejandro> ciaooo
06:45:57 <alejandro> !lista
06:46:04 <alejandro> !lista
06:46:11 <alejandro> !lista
06:48:52 <humanoyd> what exactly is the `instance head`? Everything between `instance` and `where`?
06:53:37 <Psybur> humanoyd, according to https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1 its instance [scontext =>] qtycls inst [where idecls] :D?
06:58:50 <humanoyd> Psybur: thx :>
07:04:48 <raynold> ahh it's a wonderful day
07:36:56 <orion_> I am trying to record all HTTP requests made using http-client. There is a `managerModifyRequest` setting with type Request -> IO Request which I've set to (\r -> print r >> return r).
07:37:25 <orion_> This doesn't seem to work though, because I get two Requests printed to the screen per actual Request made.
07:38:15 <orion> Is there a better way to go about this?
07:50:55 <ertes-w> orion: are you in control of the requests themselves?  i.e. are you the one issuing them?
07:51:05 <orion> ertes-w: Yes.
07:56:58 <ertes-w> orion: in that case just wrap your requests
07:58:12 <ertes-w> you could e.g. tell some separate thread about each request, or inject some extra action that modifies them
07:59:48 <orion> What if I'm not the one issuing them?
08:00:07 <orion> For example, what if I want to create a generic debugging library?
08:02:58 <daey> am i making a massive error in this regex count script? http://dpaste.com//0HSBHRR If there is one it is most likely in line 10
08:04:36 <daey> i am running it on this test file: http://dpaste.com//1W4VZS0 . On that specific file it is still faster than the python equivalent. but if i increase the matches to 500.000 haskell completely fails. python finishes in 0.2s while haskell requires more than a minute (thats when i stopped it wasnt finished)
08:13:19 <mnoonan> daey: according to https://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix.html Strings get converted to CString each time.. also, it looks like (=~) may be compiling the regex on each invocation?
08:14:55 <mnoonan> I don't really know that package, but I'd bet if you make a top-level Regex value instead of using =~ and switch to using Text, you'll see a bit difference
08:16:22 <daey> im only a level 1 haskell wizard
08:16:53 <daey> how can i switch to Text?
08:17:11 <daey> getAllTextMatches's output is fixed type, isnt it?
08:19:35 <mnoonan> no, this whole library appears to be very polymorphic. It looks like you can use any of the types with an Extract instance: https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:Extract
08:19:56 <mnoonan> but it seems that doesn't include Text, so I guess ByteStrings are the way to go
08:21:24 <mnoonan> the point seems to be that the type needs to have fast random-access indexing, and Strings don't because behind the curtain they are just linked lists. So the regex library is converting them to CStrings in order to get random access indexing.
08:22:15 <mnoonan> seems like they should have just not provided an instance for String if it would be so inefficient. :|
08:38:48 <daey> mnoonan: is that a simple matter of replacing my [String] to [ByteString] or do i need to redo more?
08:38:55 <daey> s/to/by
08:39:39 <dmwit> ?tell f-a If there is a way to make ghci's autocomplete case-insensitive, the details are hiding in the haskeline documentation.
08:39:39 <lambdabot> Consider it noted.
08:39:56 <mnoonan> you'll need to use ByteString versions of your file operations too: http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:readFile
08:44:09 <f-a> dmwit: thanks for replying. Indeed System.Console.Haskeline.Completion seems to be the place.
08:44:15 <daey> mnoonan: there are functions with identical names  but different in/out types? o0
08:45:15 <EvanR> yep, a lot of them
08:45:36 <daey> but shouldnt ghc be able to figure this out automatically?
08:46:01 <daey> if function b expects type A than the previous function needs to output type A
08:46:10 <mnoonan> daey: yes, a few ways: (1) multiple modules could just happen to have same-named functions, or (2) typeclasses giving different definitions.
08:46:30 <mnoonan> in (2), inference would come to the rescue. but this is just a case of (1).
08:46:31 <EvanR> you are talking about function inference, not type inference?
08:46:38 <EvanR> "type directed name disambiguation"
08:46:47 <Younder> Nobody but Simon P. Jones truly understand the implementation of the type system.
08:46:57 <EvanR> false
08:47:02 <EvanR> not even he does
08:47:05 <Younder> I wsh
08:47:13 <daey> :P
08:47:21 <daey> you make me hope guys...
08:48:20 <Younder> ghc has a implementation of the typesystem which politely leaves a bit to be desired.
08:48:26 <daey> so what do i need to do in ghci. to get the FIlePath -> IO ByteString function via. :info readFile?
08:48:34 <daey> load a different module?
08:48:38 <EvanR> yes
08:48:47 <EvanR> import Data.ByteString
08:49:03 <alsoStevenXL> Hi folks. I wrote down notes when at a conference talk about intermediate level books. I have Intermediate Haskell, Haskell Almenac, Joy of Haskell, and there was another called Haskell in Depth by someone named Vitali? I can't find references to that last one. Anyone know what I'm talking about?
08:50:03 * hackage hocker 1.0.1 - Interact with the docker registry and generate nix build instructions  https://hackage.haskell.org/package/hocker-1.0.1 (ParnellSpringmeyer)
08:51:35 <[exa]> Younder: what's the desired part of the typesystem? (btw it's not that hard, base+most significant extensions have been concentrated to something like 4 papers)
08:52:58 <Younder> Fine the typesystem is trivial and easily maintainable
08:59:55 <[exa]> Younder: oh, are you talking about ghc? :]
09:04:29 <daey> so for the getAllTextMatches the String vs ByteString is determined through the passed argument? i.e. inference
09:06:00 <EvanR> where is getAllTextMatches from, can't find it
09:06:11 <daey> Text.Regex.Posix
09:07:07 <EvanR> getAllTextMatches :: f b
09:07:09 <EvanR> getAllTextMatches :: f b
09:07:11 <EvanR> er
09:07:15 <EvanR> sorry lag
09:07:41 <EvanR> getAllTextMatches :: f b -> AllTextMatches f b
09:07:42 <daey> well i should first care about my regex mask function
09:10:36 <EvanR> so in isolation you can use getAllTextMatches for any b and any f :: * -> * you want
09:11:42 <EvanR> but when you want to use it with other stuff, f and b will be required to have certain support
09:13:08 <daey>  aka [it depends] -> [it depends] :P
09:13:51 <EvanR> in isolation, getAlltextMatches does NOT depend.. thats the beauty of it (tm)
09:15:22 <EvanR> as soon as you want to set up a regex query and pass it to the regex library, suddenly youll have to make sure its an actual regex query and not something like Just 9
09:16:03 <EvanR> which would have type AllTextMatches Maybe Int
09:17:10 <daey> http://lpaste.net/360419 thats where im at now. i can read the file as bytestring now. my fltr function gets called. but the msk function still has trouble (the error message is appended)
09:17:13 <EvanR> b will probably end up having to be String or ByteString, and f will have to be list or array
09:18:06 <mnoonan> daey: you want msk to have type ByteString -> AllTextMatches [] ByteString now
09:18:20 <mnoonan> and similar for fltr
09:20:44 <daey> it looks good so far :)
09:20:47 <EvanR> yes RegexContext instances all seem to have "source source" and "target source" the same type
09:21:00 <EvanR> even though =~ allows them to be different
09:21:18 <EvanR> so understanding this regex lib is a good exercise to typeclass shenanigans
09:21:24 <EvanR> exercise in*
09:21:26 <mnoonan> honestly this library seems a bit over-engineered for what it is doing
09:21:31 <EvanR> yeah
09:21:43 <daey> you need a frickn dr. to do regex in haskell :')
09:22:17 <EvanR> its a bit silly
09:22:37 <mnoonan> something like this seems more reasonable, if you don't literally need posix regexes: https://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU-Regex.html
09:22:37 <dminuoso> daey: They seemed rather simple when I saw Stephanie Weirich's talk!
09:22:41 <daey> im not even kiddng :D my Master foo is nowhere close enough
09:23:05 <mnoonan> (and also supports unicode :)
09:35:17 <aberrant> question: why is it called "point-free" style when there are function composition dots in it?
09:36:32 <fishythefish> "point" refers to an explicit argument
09:36:52 <aberrant> apparently "fn = ceiling . negate . tan . cos . max 50 " is point-free, but I don't get that.
09:37:06 <mlehmk> it isn't fn x = ceiling...
09:37:12 <mlehmk> the x is the point
09:37:12 <fishythefish> yes, because the argument to `fn` isn't actually written
09:37:13 <aberrant> oh.
09:37:28 <aberrant> ok. I thought "point = period" and got really confused.
09:37:48 <fishythefish> think of it like "evaluating a function at a point"
09:38:02 <aberrant> so a fully-curried composition is point-free?
09:38:59 <fishythefish> what do you mean by "fully-curried"?
09:39:31 <fishythefish> both curried and uncurried functions can be used in point-free syntax
09:39:45 <aberrant> meaning, you've curried away all arguments except for one
09:39:58 <fishythefish> currying doesn't get rid of (logical) arguments
09:40:05 <fishythefish> are you talking about partial application?
09:40:10 <aberrant> yes
09:40:41 <aberrant> sorry.
09:41:01 <fishythefish> so can you rephrase "fully-curried" in terms of partial application?
09:41:46 <aberrant> but wait. currying does get rid of logical arguments, doesn't it? addThree x y z = x + y + z ; then addThree 10 20 gives you a curried function.
09:41:56 <fishythefish> no, addThree 10 20 gives you a partially applied function
09:42:08 <aberrant> gah. need to get back to my dictionary then.
09:42:13 <aberrant> I thought that was currying.
09:42:24 <fishythefish> currying is the act of transforming a function taking multiple arguments to a function taking a single argument which returns another function
09:42:35 <fishythefish> :t curry
09:42:36 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:42:51 <aberrant> so that's an example of currying, isn't it?
09:43:03 <benzrf> it's probably worth noting that the description above doesn't /quite/ apply literally to haskell
09:43:11 <fishythefish> currying doesn't involve providing arguments
09:43:13 <aberrant> addTwo x y = x + y; myAdd = addTwo 10
09:43:19 <fishythefish> "currying" in haskell happens at two levels
09:43:31 <benzrf> haskell has no genuine multiple-argument functions - what you see above is the type of a function that takes 1 argument, and that argument is a pair
09:43:34 <fishythefish> functions in haskell are always curried, in that haskell has no concept of a function taking more than one argument
09:43:44 <fishythefish> we can pretend we do by making that argument a tuple
09:43:51 <aberrant> understood
09:43:52 <Psybur> :t curry (\(x,y) -> x y)
09:43:54 <lambdabot> (t -> c) -> t -> c
09:43:54 <fishythefish> then the `curry` function does what you expect
09:43:57 <aberrant> but how is that different than partial application?
09:44:15 <fishythefish> partial application is the process of supplying an argument to a function (but not all arguments) and getting another function back out
09:44:16 <benzrf> currying allows "partial application" by default
09:44:19 <aberrant> sorry to be so dense here.
09:44:26 <fishythefish> they're closely related
09:44:37 <aberrant> > currying allows "partial application" by default
09:44:38 <benzrf> or rather: when your function is curried, normal application functions as "partial application"
09:44:39 <lambdabot>  <hint>:1:42: error: parse error on input ‘default’
09:44:48 <aberrant> ok, so currying is what permits us to use partial application
09:44:52 <fishythefish> f (x, y) = x + y -- this is a "multiple-argument" function
09:44:54 <benzrf> that's one way to put it
09:44:56 <fishythefish> f x y = x + y -- this is the curried form
09:45:06 <aberrant> yes, ok, got it
09:45:08 <fishythefish> g y = f 1 -- this is partial application
09:45:17 <aberrant> I understand. Without currying, we'd have no partial application
09:45:57 <aberrant> it's gonna take me YEARS to understand this language :(
09:46:08 <benzrf> it becomes more intuitive as you use it more :)
09:46:12 <fishythefish> then you're in good company :)
09:46:15 <aberrant> hah.
09:46:23 <benzrf> most learning has a curve with increasing derivative
09:46:47 <fishythefish> if only that derivative were positive
09:46:50 <fishythefish> i seem to keep forgetting stuff
09:46:50 <aberrant> at the very least, it will give me insights into how to be a better scala programmer :)
09:47:24 <rightfold> Partial application and currying are orthogonal
09:47:42 <fishythefish> i don't think i can bring myself to learn scala after seeing haskell concepts translated into that syntax
09:48:00 <aberrant> erm, rightfold, now you've thrown me back into the pit of confusion.
09:48:09 <rightfold> fishythefish: you’re not missing out on anything
09:48:23 <aberrant> I want to like scala, but it doesn't like me back.
09:48:40 <daey> ok the endresult of my regex tinkering: haskell's regex sucks (or im still doing something wrong). it still is slow as f.
09:48:52 <aberrant> I fear I'm going to run into the same problems with haskell that I had with scala: namely, trying to reason about program performance in real-world applications.
09:49:04 <rightfold> Currying is taking a multi-argument function and returning a function that takes fewer arguments and returns a new function that takes the remainder of the arguments.
09:49:14 <aberrant> rightfold: ok
09:49:17 <fishythefish> that's partial application
09:49:24 <rightfold> Partial application is applying a function to a few arguments and getting a function back that takes the remainder of the arguments.
09:49:43 <Guest18476> hey guys, how come i can't write "if z == sum (x:y:[])"
09:49:44 <aberrant> they seem to be pretty similar: like partial application is the instantiation of currying.
09:50:17 <fishythefish> essentially, currying gives you a way to implement partial application
09:50:21 <mnoonan> daey: interesting.. what does the code look like now?
09:50:29 <monochrom> partial application : currying :: redeem a coupon : the coupon
09:50:39 <fishythefish> Guest18476: can you provide a paste?
09:50:51 <aberrant> monochrom: perfect. Thanks.
09:50:55 <aberrant> ok, back to LYAH.
09:51:12 <Guest18476> ffa (x:y:z)=                        if z == sum (x:y:[])                        then (x:y:z)                        else (x:y)
09:51:33 <fishythefish> Guest18476: I meant like an lpaste or something but
09:51:39 <fishythefish> first of all, you have a type error
09:51:50 <fishythefish> z must be a list, but you're checking that it's equal to a number
09:51:58 <Guest18476> ah
09:52:01 <Guest18476> ok
09:52:05 <fishythefish> second, depending on the signature, you may have forgotten an Eq constraint
09:52:06 <aberrant> x:y:z:[] ?
09:52:31 <daey> mnoonan: i just realized i didnt change the =~ yet :'). Kinda lost the focus in the ByteString madness
09:54:07 <daey> mnoonan: http://lpaste.net/360421 anyhow thats what i got currently
09:55:01 <dminuoso> aberrant: Regarding the earlier discussion: You could also say: Currying is a way of gaining partial application. But I think you lose some very intuition by thinking in terms of "partial application"
09:55:19 <daey> only needs 8.6s for 30.000 lines :')  compared to pythons 0.12s :D
09:55:24 <rightfold> In JS they’d look like curry = (f) => (x) => (y) => f(x, y); partiallyApply = (f, x) => (y) => f(x, y); it’s tricky to explain it with Haskell syntax though because Haskell has only unary functions, so everything that would otherwise have multiple arguments is always curried
09:55:38 <fishythefish> :t curry
09:55:40 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:55:42 <dminuoso> aberrant: For me understanding that `fmap (+)` is not partially applied, but rather that its fully applied and gave me a function back allowed me to see what happened: fmap takes a function, and transforms it.
09:55:43 <mnoonan> daey: I'm also curious about why you're using "group", but I don't think that would explain the issue
09:55:51 <fishythefish> tupled arguments are the closest we'll get
09:56:13 <dminuoso> aberrant: Just like something like (+5) would give me an adder function. So currying is more about thinking in terms of higher order functions.
09:56:34 <rightfold> Yep :3 and they correspond to the relevant morphisms in Cartesian closed categories that operate on morphisms from products
09:56:36 <daey> mnoonan: the group isnt even running its out commented. the original script groups similar matches into groups then counts the quantity of each group
09:57:22 <mnoonan> daey: group only groups adjacent elements though, so it seems unlikely to do what you want
09:57:36 <mnoonan> actually, maybe it would be good to see the python too for comparison
09:57:53 <daey> mnoonan: :/ the original script works exactly like it should. maybe im just not understanding it anymore as i wrote it a while ago
09:58:38 <daey> https://pastebin.com/5UNVZTtx
09:58:47 <daey> i tried to make them as similar as possible
09:59:31 <dminuoso> aberrant: Or likewise (==1) builds a predicate (:
09:59:45 <daey> but yeah the problem is probably the recompiling of the regex on each search as you suggested earlier
10:02:32 <fishythefish> dminuoso: i prefer taking a more flexible approach in my head. i consider (== 1) fully applied when the thing i need is a predicate, but it's only partially applied when i need a result
10:02:42 <fishythefish> being able to easily switch between those viewpoints is crucial
10:02:55 <alsoStevenXL> .usd
10:03:00 <alsoStevenXL> woops
10:03:31 <fishythefish> since haskell says all functions are unary, many of these distinctions are ones taking place only in the head of the programmer
10:04:35 <EvanR> and (==) is fully applied when you need a binary function? :)
10:04:40 <monochrom> And code optimizer too.
10:04:42 <fishythefish> indeed
10:04:48 <EvanR> 9 is fully applied...
10:04:50 <rightfold> Well, also in the types
10:05:05 <rightfold> A function that takes a predicate takes (a -> Bool)
10:05:21 <EvanR> i demand to know what fully applied is
10:05:23 <Psybur> @let head = succ . unzip
10:05:24 <lambdabot>  .L.hs:177:1: error:
10:05:24 <lambdabot>      Multiple declarations of ‘head’
10:05:24 <lambdabot>      Declared at: .L.hs:176:1
10:05:27 <fishythefish> yes, but it says nothing about how that function need arise
10:05:38 <dminuoso> EvanR: any time there's a space between two identifiers? :P
10:07:17 <dminuoso> EvanR: But I see what you meant.
10:07:37 <dminuoso> EvanR: So there's only application or not. Either way you get something back.
10:15:44 <daey> mnoonan: the reason why the group works is because i used to sort as well
10:15:58 <Hafydd> Haha.
10:16:39 <Hafydd> @remember Psybur @let head = succ . unzip
10:16:39 <lambdabot> Good to know.
10:17:16 <Psybur> I was worried that one was going to just slip by :D
10:17:37 <EvanR> ooohhh
10:22:06 <daey> seeing that google search nets practially zero results for "import Text.Regex.Posix.ByteString". im guessing not many dived into this madness before
10:22:51 <EvanR> erm, does that command not work ?
10:23:14 <shapr> hm, dante is okay, but it doesn't give me ghci. I've been using intero, but I'm trying to work outside of stack. What's the recomended emacs haskell mode these days?
10:24:27 <shapr> What're the options other than intero and dante?
10:24:50 <Unode> haskell ide engine. That's what I'm using and solved some memory related issues I was having with intero
10:25:01 <mnoonan> daey: you saw this? http://gabebw.com/blog/2015/10/11/regular-expressions-in-haskell
10:25:30 <shapr> Unode: got a link for getting started with ide engine inside emacs?
10:25:58 <monochrom> I don't know about recommended. I use haskell-mode. There is a table that compares haskell-mode with dante, and I decided that I don't need the tiny extra thing that dante does.
10:26:29 <monochrom> Or maybe it was a table of dante features only.
10:28:31 <Unode> shapr: vim here. but try https://github.com/emacs-lsp/lsp-mode
10:28:37 <daey> mnoonan: i think thats what im script was based on. let stringResult = "hello there" =~ "e" :: AllTextMatches [] String .. is what i used to do
10:28:38 <ekr> any suggestions where I could find a quick fix for a build error of the tar package (http://lpaste.net/360424)?
10:29:01 <mnoonan> ah, i see.
10:29:16 <cocreature> ekr: are you compiling with GHC HEAD?
10:29:20 <ekr> yes
10:29:42 <daey> mnoonan: ok just changing the lib to PCRE increased the speed more than 10x xD
10:29:51 <daey> its still 3x slower than python though 
10:30:20 <cocreature> ekr: take a look at https://github.com/hvr/head.hackage
10:30:46 <mnoonan> daey: maybe unicode vs non-unicode support?
10:30:52 <dminuoso> This might be a silly question but.. why do I have cabal files when Im using stack?
10:31:18 <EvanR> stack is a layer on top of cabal
10:31:19 <daey> mnoonan: the python one is unicode *afaik*
10:31:23 <shapr> Unode: thanks, I'll try that
10:31:48 <ekr> cocreature: thanks. i was fed up with distro-specific bundling, and decided to go for diy ghc+cabal builds, and now that i've spent an hour building GHC head, i wouldn't want to do that again to build an older branch.
10:32:31 <monochrom> Aw don't build GHC yourself. There is a third way.
10:32:32 <dminuoso> EvanR: Just to confirm, you're talking about `cabal-install` (because apparently there's multiple things named Cabal)
10:32:34 <dminuoso> Right?
10:32:38 <monochrom> In fact there is a fourth way too.
10:32:45 <monochrom> Actually fifth.
10:33:01 <EvanR> so i was not
10:33:03 <EvanR> no *
10:33:04 <cocreature> ekr: I wouldn’t recommend using GHC HEAD if you’re just trying to write Haskell, sticking to stable releases is going to be a lot more pleasant
10:33:08 <dminuoso> Mmm.
10:33:24 <EvanR> i thought you were asking about cabal
10:33:30 <EvanR> not cabal-install
10:33:39 <EvanR> which you dont use with stack
10:33:51 <mnoonan> daey: i'm not sure, the re docs suggest using the 'regex' library "for more thorough Unicode support", whatever that means
10:33:52 <dminuoso> Are cabal and cabal-install related?
10:34:17 <cocreature> there is Cabal the lib and cabal-install. cabal-install and stack both use Cabal the lib
10:36:31 <daey> is this '=~' a regex specific operator? never seen it before
10:36:40 <EvanR> yes
10:37:19 <EvanR> http://hackage.haskell.org/package/regex-posix-0.95.2/docs/Text-Regex-Posix-Wrap.html
10:37:59 <cocreature> I’m pretty sure the type signature of =~ is deliberately terrible
10:38:15 <daey> xD
10:38:15 <EvanR> and there is no documentation
10:38:28 <EvanR> but it executes a match somehow
10:38:33 <EvanR> if you can get the types to match up
10:38:43 <daey> im just confused why regex would require a new operator
10:38:54 <EvanR> it doesnt, but =~ is common in another langauges
10:39:15 <cocreature> daey: note that there is nothing special about operators in Haskell. they are just ordinary definitions
10:39:26 <cocreature> the only difference is that by default they are used in infix form
10:39:48 <mnoonan> oh, =~ is a perlism?
10:49:55 <rightfold> Perl uses =~ for regex marching and =~ s/// for regex substitution.
10:50:37 <rightfold> For Turing-complete, side-effecting definitions of “regex”.
10:51:07 <crucify_me> well lambdabot doesn't work just like ghci. ie. this gives an error  ' > let ff = foldr (.) id [(+ 5), (^ 3)] '  parse error on input '='  ..   whats the beef?
10:51:28 <cocreature> crucify_me: use "@let ff = …"
10:51:40 <crucify_me> thanks cocreature 
10:52:46 <crucify_me> @let ff = foldr . id [(+5), (^ 3)]
10:52:47 <lambdabot>  .L.hs:194:14: error:
10:52:47 <lambdabot>      • Couldn't match expected type ‘a -> a1 -> b -> b’
10:52:47 <lambdabot>                    with actual type ‘[Integer -> Integer]’
10:53:10 <crucify_me> different error
10:53:36 <EvanR> we need a name for the "completion" of something by adding the ability to do turing complete stuff and side effects
10:54:05 <crucify_me> cocreature, hey could you look at that? ^
10:54:23 <crucify_me> it works fine in ghci
10:54:43 <cocreature> you forgot parentheses around the dot
10:55:24 <crucify_me> dang. thanks. one more thing, prefix notation doesn't work ie ..
10:56:01 <crucify_me> @let fff = (.) foldr id [(+5), (^ 3)]
10:56:02 <lambdabot>  .L.hs:194:20: error:
10:56:03 <lambdabot>      • Couldn't match expected type ‘a -> b -> b’
10:56:03 <lambdabot>                    with actual type ‘[Integer -> Integer]’
10:56:16 <crucify_me> I thought haskell was fine with that
10:57:46 <ongy> if you want to pass an infix function (e.g. . or +) to something that expects a function, you have to pass it in parentheses. so (.) or (+)
10:58:16 <ongy> :t foldr (.) id [(+5), (^ 3)]
10:58:18 <lambdabot> Num b => b -> b
10:59:29 <EvanR> and you can use regular functions infix like `div`
10:59:47 <EvanR> > 15 `divMod` 7
10:59:48 <fishythefish> crucify_me: your definition of fff starts with (.) foldr id, which is foldr . id, which is foldr
10:59:50 <lambdabot>  (2,1)
10:59:50 <crucify_me> ongy I was wondering about prefix notation
10:59:59 <fishythefish> you're essentially trying to typecheck `foldr [(+5), (^3)]`
11:00:27 <fishythefish> remember that function application is left-associative
11:00:29 <crucify_me> oh yeah ok so I offset the composition so to speak
11:02:18 <crucify_me> hey, any more interesting examples for why foldr (.) id is so useful according to lore? also what about examples for flip foldr id. I'm confused about that.
11:02:26 <crucify_me> fishythefish, et al ^
11:03:10 <dminuoso> crucify_me: check the type signature
11:03:49 <fishythefish> I was under the impression that `foldr (.) id` is about as useful as it's definition makes it out to be: it builds up a function by composing a list of its parts
11:03:52 <Guest18476> https://gist.github.com/anonymous/1e9ce4250418cbc2fd851eff375991f8
11:03:57 <fishythefish> does lore make a bigger deal out of it than that?
11:04:03 <Guest18476> it is giving me non exhaust pattern
11:04:16 <jevdplas> Hey guys, I have a question about folds. I want to rewrite a function so it does not have a memory leak. I've been told to use fold', but the function that I use is non-strict in its second argument. Would a foldr combined with seq be a good option for this?
11:04:21 <cocreature> Guest18476: you are not handling lists with fewer than 3 arguments
11:04:28 <fishythefish> Guest18476: that's because the only case you handle is when you're argument can match x:y:z:xs
11:04:40 <fishythefish> zs*
11:04:48 <fishythefish> your*
11:04:54 * fishythefish is tired
11:04:58 <Guest18476> ok, so i need to add base case
11:05:00 <cocreature> jevdplas: can you show us the function? also are you sure you actually have a space leak?
11:05:14 <Guest18476> how do i do that in the if then else function?
11:05:21 <fishythefish> Guest18476: also, there's no real reason to use xs and all the heads and tails
11:05:24 <Guest18476> sorry, i'm very new to haskell
11:05:32 <fishythefish> you already have the names x, y, z, zs
11:05:38 <Guest18476> ah ok 
11:05:51 <Guest18476> let me rewrite real quick
11:05:54 <fishythefish> you don't need to add the other cases to the if/then/else
11:06:04 <fishythefish> you can add another line like fibonacciNumber [] = []
11:06:05 <fishythefish> etc.
11:06:11 <dminuoso> fishythefish: Mind my asking, "lore" ?
11:06:21 <fishythefish> dminuoso: ask crucify_me 
11:06:33 <dminuoso> Oh. crucify_me ^-
11:07:03 <Guest18476> ok thanks, let me rewrite
11:09:08 <dfeuer> edwardk: ping
11:11:15 <crucify_me> dminuoso, I just meant stuff I read online that its useful but I was looking for some example other than simple arithmetic 
11:11:48 <Guest18476> https://gist.github.com/anonymous/ecb6af918186c33a2a6b55a058d70f93
11:12:09 <Guest18476> sum (x:y) doesn't match the type for z
11:12:18 <fishythefish> x:y is already an issue
11:12:22 <fishythefish> y isn't a list
11:12:26 <fishythefish> why not just write x + y?
11:12:28 <Maticz> Hey guys, when profiling the heap and generating the graph, how can you identify a space leak with the graph?
11:12:48 <Guest18476> k
11:12:53 <fishythefish> Guest18476: also, if you're gonna use that base case for everything, you can instead put `fibonacciNumber _ = []` at the end
11:13:33 <jevdplas> cocreature, here is the function. I suppose the or would create a space leak, no? http://lpaste.net/7969301887763611648
11:13:36 <mnoonan> crucify_me: related to foldr (.) id, foldr (>=>) return is also handy sometimes (chain a pipeline of monadic actions together)
11:13:49 <fishythefish> you can also deduplicate your code by binding a name to the recursive call
11:14:31 <cocreature> jevdplas: change it to "tileType (getTile f row col) == typ || acc" and it should be fine
11:15:09 <fishythefish> Guest18476: you can pattern match as (x:t@(y:z:zs)) so you can use t instead of y:z:zs
11:15:41 <jevdplas> cocreature, thanks. Can you explain why this is the case?
11:15:43 <Guest18476> ah ok 
11:16:16 <cocreature> jevdplas: let’s start the other way around: why do you think it contains a space leak?
11:18:11 <crucify_me> mnoonan, thanks I don't know about monads yet or pipelines
11:18:21 <Guest18476> http://lpaste.net/360427
11:18:35 <Guest18476> i'm having redundant pattern..... 
11:18:49 <fishythefish> the catch-all pattern needs to be last
11:19:09 <fishythefish> haskell attempts to match patterns from the top-down, and everything will match _
11:19:26 <fishythefish> you can get rid of the parens around t
11:20:23 * hackage hocker 1.0.2 - Interact with the docker registry and generate nix build instructions  https://hackage.haskell.org/package/hocker-1.0.2 (ParnellSpringmeyer)
11:20:45 <jevdplas> cocreture, since I would expect the evaluation of the expression to be deferred.
11:21:51 <jevdplas> which would thus be a space leak
11:21:54 <cocreature> jevdplas: let’s change this slightly to make it easier to explain: do you also think that "foldr (\x acc -> x || acc) False" has a space leak
11:22:32 <Guest18476> http://lpaste.net/360428
11:22:43 <Guest18476> it is not working.... 
11:22:52 <Guest18476> it returned [1]
11:23:46 <fishythefish> on what input?
11:23:48 <erisco> what did you try
11:23:55 <Guest18476> i tried [1..10]
11:24:04 <fishythefish> this is what i would expect
11:24:07 <crucify_me> > :t foldr (.) id
11:24:09 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:24:25 <Guest18476> the return value should be [1,2,3,5,8]
11:24:31 <Guest18476> instead it gave me [1]
11:24:32 <fishythefish> this function doesn't compute fibonacci numbers, it grabs elements from the head of the list as long as x + y == z
11:25:03 <fishythefish> are you trying to filter a list for fibonacci numbers?
11:25:10 <Guest18476> yeah
11:25:14 <Guest18476> it's a practice problem 
11:25:23 <fishythefish> then you need to revisit the logic, not your implementation
11:25:30 <Guest18476> ok 
11:25:49 <fishythefish> try manually processing the input [1..10] just as your code says to
11:25:57 <fishythefish> that might give you a better idea of when/how/why this fails
11:26:03 <Guest18476> ok
11:26:06 <jevdplas> cocreature: I think so, but I'm really confused right now.
11:26:23 * hackage tasty-hunit 0.10.0.1 - HUnit support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-hunit-0.10.0.1 (RomanCheplyaka)
11:26:33 <cocreature> @source foldr
11:26:33 <lambdabot> Unknown command, try @list
11:26:38 <cocreature> @src foldr
11:26:38 <lambdabot> foldr f z []     = z
11:26:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:26:46 <cocreature> jevdplas: let’s walk through this for a small example
11:27:18 <crucify_me> :t foldr (.) id
11:27:19 <lambdabot> Foldable t => t (b -> b) -> b -> b
11:27:30 <cocreature> foldr (\x acc -> x || acc) False [True, False] = True || foldr (\x acc -> x || acc) False [False] = True
11:27:52 <cocreature> and it will behave similarly regardless of how long the tail of the list is
11:27:58 <cocreature> without leaking space
11:29:01 <BenceF> Hi, what was the command in GHCi to see which elements of a list are forced?
11:30:18 <fishythefish> you might be looking for :sprint
11:30:55 <jevdplas> cocreature, I see. But what's the difference when we turn the arguments of || around or we apply he foldr on [False, True]? 
11:31:08 <[exa]> Hm is there some good tutorial about parsing a C-like programming language in haskell, using any parsec variant?
11:31:23 <[exa]> ideally just example code with the least possible amount of magic
11:31:40 <BenceF> fishythefish: it gives me `as = _' even after `take 2 as' was evaluated
11:31:46 <cocreature> jevdplas: let’s try it out: "foldr (\x acc -> acc || x) False [True, False] = foldr (\x acc -> x || acc) False [False] || True"
11:32:04 <cocreature> jevdplas: but || is defined by pattern matching on the first argument. so now we actually need to evaluate the result of that foldr
11:32:10 <crucify_me> frankly I'm still having a tough time reading the signatures for foldr / foldl
11:32:14 <cocreature> so we don’t get the desirable shortcircuiting on the first True
11:32:38 <EvanR> crucify_me: try rewriting the signature so its about lists and not foldables
11:33:04 <fishythefish> BenceF: what type is as? you might be running into issues with polymorphism
11:33:13 <EvanR> foldr :: (a -> b -> b) -> b -> [a] -> b
11:33:43 <BenceF> fishythefish: it might be. it is (Num a, Enum a) => [a]
11:33:51 <fishythefish> BenceF: e.g. let as = "asdf" is fine; let as = [1..10] will be problematic, but let as = [1..10] :: [Int] is fine
11:33:53 <jevdplas> cocreture: I see now. Thanks for your  explanation.
11:34:07 <fishythefish> BenceF: yeah, then annotate with a concrete type
11:34:14 <crucify_me> thanks EvanR I'm very confused now
11:34:21 <BenceF> fishythefish: thank you for the tip
11:35:07 <fishythefish> crucify_me: foldr/foldl were originally defined for lists. when Foldable was introduced, the type signatures were generalized, so it's easier to start by studying the original list definitions
11:36:10 <crucify_me> makes sense, so the function part, (a -> b -> b) .. 
11:36:30 <Maticz> is there anyone with any experience in profiling the heap to find space leaks? I've generated a graph and need some help in identifying potentional space leaks
11:36:38 <fishythefish> b is the type of your accumulator, and a is the element type. that function says how to combine an element into your accumulator
11:37:10 <Profpatsch> data D a = A | B (D a) | Note a
11:37:16 <aberrant> why foldr vs foldl ?
11:37:30 <aberrant> (in general)
11:37:30 <fishythefish> aberrant: they do different things
11:37:37 <Profpatsch> Can I strip all Note’s from a value of D w/o enumerating all constructors?
11:37:48 <fishythefish> aberrant: https://wiki.haskell.org/Foldr_Foldl_Foldl%27 might be a useful read
11:37:55 <Profpatsch> Err
11:38:01 <Profpatsch> data D a = A | B (D a) | Note a (D a)
11:38:11 <aberrant> thanks, fishythefish
11:38:34 <Profpatsch> e.g. B (B ( Note "foo" (Note "bar" (B (B (Note "baz" (B A))))))
11:38:46 <Profpatsch> To B (B (B (B (B A))))
11:39:48 <EvanR> so you want to flatten it
11:39:52 <crucify_me> fishythefish, thanks for that while tired. :) 
11:40:12 <Profpatsch> f d = case d of { (Note d') -> f d'; d' -> d' }
11:40:31 <Profpatsch> will only strip down to B (B (B (B (Note "baz" (B A))))
11:41:12 <Profpatsch> I guess that only works correctly with enumerating every constructor that has a (D a) in the product and manually applying f
11:41:33 <Profpatsch> Or changing the orig type to a functor and use recursion schemes.
11:41:37 <daey> i often read in haskell libraries that 'this library is a wrapper around C-library X' is that a wanted state? or just due to the lack of a native haskell driver?
11:41:57 <Profpatsch> daey: Depends on what you want to achieve.
11:42:14 <Profpatsch> daey: Which libraries do you have in mind?
11:42:59 <daey> Profpatsch: right now im looking at the usb package which is a wrapper around 'bindings-libusb' which is a wrapper around 'libusb-1.*' :'D
11:43:15 <daey> https://hackage.haskell.org/package/usb this one to be specific
11:43:51 <Profpatsch> daey: I can imagine that there is a *lot* of man hours in libusb.
11:44:12 <Profpatsch> And reimplementing that in every language just isn’t a good way to spend developer time.
11:44:19 <Profpatsch> Same with e.g. bluetooth
11:44:24 <Profpatsch> Or other system-specific stuff.
11:44:29 <daey> so these wrapper constructs arent necessarily bad then?
11:44:35 <Profpatsch> No, of course not.
11:44:40 <Profpatsch> Depends on what you want to achieve.
11:44:41 <daey> i thought they were simply due to 'time  constrains'
11:44:48 <Profpatsch> If you want to compile to JS, then yeah.
11:45:04 <Profpatsch> daey: Well, Haskell doesn’t have an awesome C FFI for nothing.
11:45:20 <Profpatsch> There’s also a library for C++ FFI
11:46:49 <crucify_me> fishythefish, EvanR thanks so much its not a leap to read the generalized form .. now!
11:47:32 <crucify_me> what about foldr (.) id   ...
11:47:38 <crucify_me> :t foldr (.) id
11:47:40 <lambdabot> Foldable t => t (b -> b) -> b -> b
11:48:12 <crucify_me> I know how unification works pretty much, but what happened to our a type ?
11:49:17 <mnoonan> crucify_me: the type variable names are basically arbitrary
11:50:10 <dminuoso> mnoonan: I think he's referring to the fact that foldr had two type variables
11:50:20 <mnoonan> ah
11:51:15 <fishythefish> crucify_me: well, let's do some unification
11:51:16 <fishythefish> :t foldr
11:51:16 <geekosaur> I'm tempted to say you don't actually know how unification works.
11:51:18 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:51:23 <fishythefish> :t (.)
11:51:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:51:25 <fishythefish> :t id
11:51:27 <lambdabot> a -> a
11:51:46 <geekosaur> but, as a hint: foldr is described in terms of a (somewhat elaborated) (a -> b)
11:51:52 <geekosaur> but we gave it an (a -> a)
11:52:25 <crucify_me> I know that (a -> b -> b) is a ~ (b -> b)
11:52:33 <geekosaur> er
11:52:35 <fishythefish> who
11:52:36 <fishythefish> whoa
11:52:59 <crucify_me> in the case of id 
11:53:03 <fishythefish> okay, let's start by fixing shadowing
11:53:09 <crucify_me> did I say that wrong?
11:53:23 <fishythefish> i'll leave the foldr type variables as they are, but (.) ones I will tack on a ', and for id, i will tack on ''
11:53:41 <fishythefish> so we have a -> b -> b ~ (b' -> c') -> (a' -> b') -> a' -> c'
11:53:48 <fishythefish> and b ~ a'' -> a''
11:54:31 <crucify_me> please hold on
11:54:38 <fishythefish> so a ~ b' -> c', and b ~ a' -> b' ~ a' -> c' ~ a'' -> a''
11:54:41 <fishythefish> sure, take your time
11:54:51 <dminuoso> fishythefish: What does ~ denote?
11:54:56 <fishythefish> dminuoso: type equality
11:55:18 <dminuoso> fishythefish: Ah. Im guessing it has a low precedence?
11:55:32 <fishythefish> dminuoso: relative to ->, yes
11:55:50 <edwardk> Dfeuer: pong
11:55:56 <crucify_me> the function that takes an element and the acc value: (a -> b -> b) , in terms of identity, a -> a , that would give us a ~ (b->b), right ?
11:56:10 <fishythefish> crucify_me: rephrase?
11:56:11 <dfeuer> edwardk: was I right about how you can magic up Applicative from Distributive?
11:56:30 <dfeuer> By using Pair (Either (a -> b) a), where Pair a = Pair a a ?
11:56:40 <dfeuer> er...
11:56:44 <edwardk> Yep
11:56:46 <fishythefish> crucify_me: the function filling that role is (.) here, not id
11:56:48 <dfeuer> Well, something likee that.
11:57:23 <dminuoso> crucify_me: Remember that the composition is wrapped in () which means its passed as a first class function.
11:57:37 * hackage postgres-tmp 0.2.0 - Create a temporary database that is deleted after performing some operation  https://hackage.haskell.org/package/postgres-tmp-0.2.0 (cocreature)
11:57:40 <dminuoso> (.) itself is the argument :)
11:57:46 <dfeuer> edwardk: that's pretty gross. The big question is whether everyone will *want* something equivalent to that Applicative instance; there could be a different one that's better, or the user may not know yet....
11:58:02 <dfeuer> edwardk: also, I'm curious what you meant about Compose and monads in that comment.
11:58:33 <crucify_me> well, if we unify id with (a -> b -> b), since (b -> b) is identity, that would make (b -> b) ~ a   
11:58:58 <fishythefish> we're not trying to perform that unification
11:59:20 <fishythefish> also, type variables belonging to different function signatures should be named differently to avoid confusion here
11:59:22 <crucify_me> ok
11:59:52 <fishythefish> crucify_me: do you understand why that unification is not pertinent?
12:00:24 <crucify_me> I think so, because:
12:00:48 <crucify_me> the input is unchanged by id in the definition
12:00:57 <fishythefish> this has nothing to do with the semantics
12:01:13 <fishythefish> this is about the order of the arguments
12:01:34 <fishythefish> :t foldr
12:01:35 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:01:40 <dminuoso> crucify_me: compose = (.); foldr compose id
12:01:45 <dminuoso> crucify_me: bing?
12:01:52 <fishythefish> when you say `foldr (.) id`, (.) is the first argument, and id is the second
12:02:03 <fishythefish> so we're trying to unify the type of (.) with a -> b -> b
12:02:11 <fishythefish> the type of id is being unified with just b
12:02:47 <danielzx> Hello there! Are any questions fine here in regards to Haskell?
12:02:55 <crucify_me> ok yeah that changes things doesn't it
12:03:08 <fishythefish> danielzx: pretty much
12:03:28 <fishythefish> crucify_me: with that in mind, do my previous type equalities make sense?
12:05:00 <danielzx> Okey, I have a question in regards to an error message I can't grasp (I'm a beginner who's learning Haskell for their uni course)
12:05:12 <crucify_me> the notation you use '  and ''  I need to go through that. thanks kindly fishythefish et al 
12:05:14 <danielzx> Can I link a img via Imgur here?
12:05:24 <fishythefish> danielzx: sure, but if you have a paste, that's even better
12:05:25 <darveter> crucify_me: foldr is very simple: foldr g z [a,b,...,n] = g a (g b (... (g n z) ...))
12:05:25 <dminuoso> danielzx: absolutely
12:05:42 <fishythefish> crucify_me: the ' is just another letter in the identifier
12:06:18 <crucify_me> thanks I'll put it in my editor and try to sort it out
12:06:22 <dminuoso> crucify_me: Also this visualization might really be amazing. `foldr` basically just swaps out : for something else. https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
12:06:31 <dminuoso> crucify_me: if you imagine : being swapped out for (.) it should be utterly obvious
12:06:39 <darveter> crucify_me: so foldr (.) id [a,b,...,n] = a . b . ... . n . id
12:07:04 <dminuoso> crucify_me: and there id takes the role of `z`
12:07:06 <crucify_me> yeah dminuoso the book I'm using says don't think of foldr 's behavior as recursive even though the function is
12:07:56 <crucify_me> darveter, dminuoso fishythefish thanks again I gotta go to work
12:08:00 <danielzx> https://i.imgur.com/ajUlJaI.png I don't really understand what this error message entails
12:08:19 <darveter> crucify_me: (f . g) . h = f . (g . h) , so we can omit the parentheses. best.
12:08:32 <fishythefish> danielzx: can you supply that code in context? for a parse error, surrounding whitespace will matter
12:08:40 <Taneb> danielzx: that means it reached that point and the parser wasn't prepared to
12:08:59 <Taneb> So you've made a mistake somewhere earlier, like not closing a bracket
12:09:51 <danielzx> https://i.imgur.com/UgZRd1m.png Here's the code
12:10:19 <fishythefish> danielzx: you don't close the paren before theCounter
12:10:27 <fishythefish> last line of pairsCounting
12:10:46 <fishythefish> incidentally, there are a lot of redundant parens in that code
12:11:00 <EvanR> thats the great thing about syntax without parentheses, you cant mismatch them!
12:11:00 * hackage byline 0.3.0.0 - Library for creating command-line interfaces (colors, menus, etc.)  https://hackage.haskell.org/package/byline-0.3.0.0 (PeterJones)
12:12:22 <danielzx> You mean I shouldn't close the line the paren or I didn't do it?
12:12:41 <fishythefish> you didn't do it
12:12:47 <fishythefish> but that paren also didn't need to be there to begin with
12:13:09 <danielzx> Why not?
12:13:38 <fishythefish> parentheses are just used for grouping due to order of operations
12:13:45 <fishythefish> you don't need to surround every expression in them
12:14:27 <fishythefish> pairsCounting (pair:rest) pt = theCounter rest (confirmPair pt pair)
12:15:04 <danielzx> Alright that's good to know, thank you very much! Got bunch of errors which I gotta fix now on my own. Really appreciate it ^^
12:15:15 <fishythefish> also, that line will never execute
12:15:23 <EvanR> goodbye and thanks for all the errors
12:15:26 <fishythefish> the previous line performs exactly the same pattern match
12:15:37 <dminuoso> danielzx: also the next time please post code go the link in the topic, rather than making screenshots.
12:15:43 <dminuoso> (You can also include error messages there)
12:15:53 <fishythefish> @lpaste
12:15:54 <lambdabot> Haskell pastebin: http://lpaste.net/
12:16:12 <danielzx> ok sorry about that
12:28:06 <dminuoso> fishythefish: I think there's an error in your types
12:28:15 <dminuoso> fishythefish: you are missing the Foldable t
12:28:31 <dminuoso> Or am I looking at this wrong?
12:28:33 <fishythefish> dminuoso: hm?
12:28:34 <fishythefish> where?
12:29:36 <dminuoso> fishythefish: Ohh no nevermind, I went to far. It type checks mentally
12:30:12 <EvanR> next prove your mental checker correct
12:30:13 <fishythefish> if you're talking about the type unification with foldr, the Foldable/list never even appears in the first two arguments
12:32:48 <BenceF> where can I read about \case ?
12:33:01 <EvanR> the GHC manual
12:33:08 <cocreature> BenceF: search for LambdaCase
12:33:27 <BenceF> thanks. is it GHC-only?
12:34:14 <cocreature> it’s not in the Haskell standard but maybe one of the other compilers implements it as well
12:34:22 <kuribas> which other compiler?
12:34:23 <cocreature> but really GHC is the only relevant compiler
12:34:39 <BenceF> ok :) found the relevant section
12:34:57 <cocreature> kuribas: uhc maybe?
12:36:16 <kuribas> cocreature: doesn't seem very uptodate...
12:36:22 * hackage playlists 0.5.0.0 - Library and executable for working with playlist files.  https://hackage.haskell.org/package/playlists-0.5.0.0 (PeterJones)
12:36:33 <cocreature> kuribas: well there is a reason I said GHC is the only relevant compiler :)
12:37:16 <cocreature> and the git repo was last updated in february so that’s not that long ago
12:41:50 <EvanR> about 1 year ago
12:41:54 <EvanR> heh
12:47:07 <inkbottle> Every Functor (I've seen so far) "look" the same: like [a], or Maybe a, there is a type "inside" and a structure "outside".
12:47:08 <inkbottle>  Is there a mathematical result that states that under certain circumstances, it has to be like that?
12:47:29 <exio4> inkbottle: where does (a -> e) fit? 
12:47:41 <EvanR> its the definition of a functor
12:47:50 <exio4> @type fmap :: (a -> b) -> ((->) e) a -> ((->) e b 
12:47:51 <EvanR> F sends objects in one category to objects in another
12:47:51 <lambdabot> error:
12:47:51 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:47:57 <kuribas> is there ANY advantage to using another compiler?
12:48:05 <exio4> @type fmap :: (a -> b) -> ((->) e) a -> ((->) e) b 
12:48:07 <lambdabot> (a -> b) -> (e -> a) -> e -> b
12:48:12 <EvanR> so if a is some type in haskell, F a is another
12:48:24 <cocreature> kuribas: no
12:48:25 <inkbottle> ...reading
12:48:29 <EvanR> if a = Maybe Int, F a = F (Maybe a)
12:48:38 <EvanR> if a = Maybe Int, F a = F (Maybe Int)
12:49:00 <EvanR> [ ] and Maybe are particular examples of F
12:49:58 <EvanR> fmap is the other half of the functor, sending (a -> b) to F a -> F b
12:50:29 <fishythefish> exio4: (a -> e) as a functor (a ->) or as a contravariant functor (-> e)?
12:50:41 <exio4> fishythefish: (a ->) :)
12:50:53 <exio4> fishythefish: it was a .. typo :P
12:50:53 <fishythefish> exio4: you can view it as a container of e's indexed by a's
12:51:07 <inkbottle> EvanR: exio4: OK, I'll dig into that...
12:51:09 <EvanR> everything is a container (tm)
12:51:12 <EvanR> :(
12:51:42 <inkbottle> EvanR: That's exactly what I'm questioning, or wanting to read more about
12:51:54 <EvanR> you are?
12:52:01 <mniip> 1512161202 [23:46:42] <inkbottle>  Is there a mathematical result that states that under certain circumstances, it has to be like that?
12:52:02 <mniip> how about
12:52:14 <mniip> data Hyper a b = Hyper (Hyper b a -> b)
12:52:25 <EvanR> there is nothing precise about the idea of a container, its either fully applicable because i said so or it makes no sense, and i have no justification
12:52:26 <kuribas> the container analogy is confusing IMO
12:52:42 <EvanR> in any situation
12:52:55 <EvanR> the analog can be stretched arbitrarily far with no benefits
12:53:57 <EvanR> mniip: an alternating universe of lambda expressions of two colors...
12:54:11 <BenceF> how can I rewrite the following point-free: \xs -> map f $ filter g xs
12:54:12 <mniip> well it is a functor
12:54:21 <fishythefish> @pl \xs -> map f $ filter g xs
12:54:21 <lambdabot> map f . filter g
12:54:22 <mniip> BenceF, map f . filter g
12:54:25 <inkbottle> EvanR: I'll will use your "everything is a container" slogan to make more google search
12:54:31 <EvanR> :(
12:54:55 <inkbottle> EvanR: why the frown?
12:54:58 <EvanR> you should look into functors properly and see it has nothing to do with containers
12:55:02 <BenceF> I was starting out with way too many parens :) thanks
12:55:32 <fishythefish> i think "nothing to do" is too strong
12:55:52 <fishythefish> i agree that "all functors are containers" is too strong a statement
12:55:52 <EvanR> a functor is an embedding of one category in another
12:56:15 <inkbottle> EvanR: I do know what is a functor, and it has nothing to do with containers; but many occurences, look like "container". So I'm wondering why
12:56:18 <fishythefish> this is pedantry
12:56:23 <fishythefish> we're talking about Functors, not functors
12:56:34 <EvanR> do we know what were talking about
12:56:38 <BenceF> what about "context" instead "container"? it shares most of the letters
12:56:53 <exio4> what is a context? a category? :)
12:56:56 <fishythefish> i prefer to think of functors not as things that contain a value, but things that (may) produce a value
12:57:02 <EvanR> context might be even more broad and unspecific as container
12:57:13 <EvanR> a context is just the container we are having a discussion inside of
12:57:27 <BenceF> tought the problem was container being too specific
12:57:55 <EvanR> container sounds specific but through epic salesmanship we see it can go anywhere, like the starship enterprise
12:58:38 <fishythefish> and there's a reason it doesn't have a role in the type system
12:58:46 <fishythefish> but occasionally there's value in having intuition beyond "i have fmap"
12:58:51 <EvanR> an IO a is a container with a button on it, press the button and physics happens, and it may spit out an a
12:59:22 <monochrom> "container" is both too specific in one aspect and too broad in another.
13:00:12 <monochrom> But what's wrong with sticking to the original "functor", "applicative", and "monad"?
13:00:33 <fishythefish> that would make the original question a tautology :P
13:00:47 <EvanR> i find the idea of a functor pretty compelling already
13:00:53 <monochrom> Why do you need "the fittest" if all you do is "it means those who survive"? Why not just say "those who survive"?
13:01:35 <fishythefish> that's not what it means
13:01:46 <monochrom> And here is the issue. If you say "functor", you and your audience will recall that it needs to satisfy the functor laws, and rightfully so.
13:02:02 <EvanR> not the container laws
13:02:29 * fishythefish has never heard of an open functor law
13:02:41 <monochrom> But if you say "container" or "context" or "computation", you and your audience think you know what you're talking about, but you don't, it's deception.
13:02:43 <EvanR> i got it
13:03:40 <fishythefish> that's an argument for formalizing functors in terms of their laws, which i wholeheartedly agree with
13:03:48 <fishythefish> that's not an argument for avoiding containers as intuition
13:04:04 <EvanR> i would like to know what is implied by being a container
13:04:23 <EvanR> in general
13:05:01 <inkbottle> EvanR: I think that under some restrictive assumptions, like things bound to be computable (as opposed to general sets) and base type denumerable (ie. sufficiently large), then the functor has to be some sort of container or context.
13:05:02 <monochrom> But it is an argument for avoiding intution, period.
13:05:03 <fishythefish> EvanR: a container of A is anything from which you may be able to extract an A value
13:05:24 <fishythefish> monochrom: then hopefully that's not an argument you're making :P
13:05:29 <cocreature> fishythefish: that sounds more like Foldable’s toList than Functor
13:05:30 <monochrom> Or rather, s/intuition/pretending that you can convey intuition to others by words/
13:05:31 <EvanR> may ?
13:05:42 <monochrom> Intuition is learned from experience, not read from blog.
13:05:47 <fishythefish> EvanR: consider the Const functor
13:05:54 <monochrom> Or even s/learned/trained/
13:05:56 <fishythefish> monochrom: strongly disagree
13:05:59 <EvanR> i already was
13:06:07 <monochrom> Strongly re-assert.
13:06:27 <fishythefish> EvanR: Const () is a functor, but you can't get an a from a Const () a
13:06:33 <monochrom> Also s/by words/by mincing words/
13:06:42 <EvanR> fishythefish: well, so you dont mean to imply that i can put things into the container
13:07:01 <EvanR> or you do, and you can do it by saying "you may be able to put things into the container"
13:07:02 <fishythefish> EvanR: no, nor that the container even contains any value of that type
13:07:06 <EvanR> in which case, it cant be wrong
13:07:37 <EvanR> so a container is a thing which may not allow you to put things inside of it, or get anything out of it
13:08:02 <BenceF> stick with this one. clear as day
13:08:04 <EvanR> i feel like i didnt gain anything
13:08:40 <rightfold> A container is a structure preserving mapping between categories
13:08:45 <EvanR> :(
13:08:54 <EvanR> fine
13:10:11 <fishythefish> honestly this never turns out to be an argument worth pursuing in #haskell
13:10:28 <EvanR> where would it be ?
13:10:43 <fishythefish> when trying to give examples of Functors to beginners
13:11:01 <fishythefish> "a Functor is anything with fmap"
13:11:03 <fishythefish> "like what?"
13:11:05 <fishythefish> "any container"
13:11:08 <fishythefish> "oh, okay"
13:11:24 <EvanR> that wasnt even what we were originally asked this time
13:11:26 <BenceF> Can I derail the conversation? I understand, that Functors are not functors, but is there a way to get an intuition of what are the mapped categories for Functor instances?
13:11:43 <inkbottle> fishythefish: that's probably the point
13:11:51 <EvanR> :(
13:11:55 <fishythefish> BenceF: the category is always Hask to Hask in a context where your audience accepts the existence of Hask
13:12:04 <inkbottle> fishythefish: "for beginners"
13:12:13 <EvanR> inkbottle: if thats the case, then i invite a mathematical description of containers
13:12:23 <mniip> ooh
13:12:24 <mniip> what if
13:12:29 <BenceF> Ahh I see. same categories, different mappings. Makes sense I guess
13:12:31 <mniip> we accept a weaker version of equality
13:12:38 <Tuplanolla> Maybe you only reject the idea of containers that don't contain anything, because you haven't used programming languages that are absolute horse shit.
13:12:49 <mniip> oh then it wouldn't be transitive
13:13:04 <fishythefish> mniip: isomorphism? :P
13:13:10 <mniip> nah
13:13:26 <mniip> I was thinking something that would ignore bottom discrepancies appropriately
13:13:32 <EvanR> empty containers are one thing, but that doesnt explain why anyone would care
13:13:32 <fishythefish> Tuplanolla: who's rejecting the idea?
13:13:55 <EvanR> the answer being the containing aspect isnt even what we care about
13:14:32 <rightfold> fishythefish: EvanR: interfaces defined solely by types and laws is a mindset that will eventually be accepted
13:14:41 <rightfold> But it is difficult if you are not used to it yet
13:14:45 <mniip> after reading a lot of C++ template magic,
13:14:53 <mniip> I like to call them covariantly rebindable types
13:15:09 <fishythefish> rightfold: it's difficult even when you are used to it
13:15:21 <EvanR> is a ntainer a structure that lets you insert things but never get them out again
13:15:38 <rightfold> If your container is MongoDB then that’s certainly accurate
13:15:56 <mniip> EvanR, so a sink
13:16:15 <fishythefish> EvanR: it could be, but I don't know why you're so intent on focusing on that
13:16:16 <mniip> sounds like a contravariant functor
13:16:46 <EvanR> joking aside, i still want the intuition of containers which everybody seems to be born with
13:17:39 <inkbottle> EvanR: With [a] (lists), you can get things out of it
13:17:41 <EvanR> if you gotta ask youll never know
13:18:14 <inkbottle> EvanR: With IO, it might prove more difficult (or impossible)
13:18:29 <EvanR> you can equally fail to get things out of a list or IO
13:18:37 <fishythefish> :t unsafePerformIO -- :P
13:18:38 <lambdabot> error: Variable not in scope: unsafePerformIO
13:19:11 <EvanR> but isnt that only 1/2 of the things containers intuitively do
13:20:11 <EvanR> i think MVar and TMVar seem more like containers, and they arent even functors...
13:20:40 <mniip> EvanR, ever done C++?
13:21:08 <EvanR> at this point, i can comfortably answer no to that
13:21:13 <mniip> in common languages the word "container" is more often related to aggregation, and not modifyability
13:21:41 <EvanR> i wasnt really thinking of modifyability
13:22:00 <EvanR> just the ability to be empty, not empty, and converting between the two
13:22:02 <Younder> Been doing some deep math grooking lately. Lately mostly into wavelet theory (This years Abel price) and Quantum topology. I recommend Alice and Bob meet Banach from the AMS and Mallat 'a wawelet tour the sparse way (3 ed.)'
13:22:32 <erisco> grooking
13:23:50 <Younder> From stranger in a stage land. It means understanding by intuiting and beyond rationalizing.
13:23:58 <mniip> can't help but wonder if there's a Dirichlet prize as well
13:24:26 <fishythefish> and i've just been sitting here grokking
13:24:42 <EvanR> ive been suffering that aspect of physics for a while now, "think of it like this" and thats not only all you are told, it might be the best possible explanation available anywhere
13:25:01 <EvanR> and i dont like it
13:26:32 <Younder> Quantum computers are a big mysterious void to. I have never fully understood them. I have studied Quantum Field Theory. But this is something beyond that.
13:26:41 <erisco> do you think it is pronounced like book or room?
13:27:10 <fishythefish> i think it's a typo and we can move on :P
13:27:25 <erisco> it is just a definition away from being a word
13:27:38 <Younder> I think equinocuiral conandrum is best.
13:28:06 <Younder> Its about that nosensical
13:29:15 <Younder> In the process the more approachable knot theory has come my way
13:29:48 <Younder> quite like that
13:33:33 <Younder> https://www.amazon.com/gp/product/0821836781 is a book on knot theory that is quite approachable. and a good way to start the knarwlarous journey into quantum topology.
13:34:39 <Younder> If any of you want a part of that new thing, quantum computing, That D-Wave annealing Quantum Computer etc.
13:36:39 <Taneb> I'm trying to use the cabal new-build stuff
13:36:56 <Taneb> And "cabal new-run" just says "Up to date" and doesn't actually run the executable
13:37:08 <Younder> A general purpose QC is still just a prospect. 
13:37:44 <Taneb> Apparently that was fixed lately
13:37:47 <glguy> Taneb: Whether or not new-run is implemented might depend on how new your cabal-install is
13:38:13 <Taneb> glguy, I'm updating it now
13:42:58 <Younder> well at least cabal has endured where darcs has not. You seem to be relying on the git (Pauling whatever)
13:46:07 <dminuoso> fishythefish: Yeah my mind got shifted to the right. :)
13:53:31 <Younder> I'm in the mist of a arctic winter. Don't expect sentimentality here. We are a product of our environment.
13:54:34 <Rembane> Younder: You don't happen to be finnish?
13:55:19 <dminuoso> EvanR: That has been physics all my life. But I guess talking about the Hamiltonian in 5th grade when trying to explain energy might not be helpful either..
13:56:28 <Younder> This is the time to feel you steel. Get back to what makes you you. Your intelligence. Your love for math. These strength's endure.
13:56:56 <fishythefish> i'm now more concerned that Younder is a bot
13:57:36 <Younder> Worse, I feel I am developing a passion for philosophy.
13:57:59 <EvanR> this is a turing test
13:58:13 <Younder> no bot makes that many typo's
13:58:23 * hackage log-warper 1.7.2 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.7.2 (shersh)
14:02:44 <monochrom> @pl \xs -> return (xs [])
14:02:45 <lambdabot> return . ($ [])
14:02:53 <monochrom> Nevermind
14:03:30 <monochrom> Oh actually...
14:03:38 <monochrom> @pl xxx >>= \xs -> return (xs [])
14:03:39 <lambdabot> ($ []) `fmap` xxx
14:03:49 <monochrom> I am not sure whether I like that.
14:03:59 <c_wraith> why did it make that infix?
14:04:09 <monochrom> Heh.
14:04:39 <EvanR> style plugin
14:04:40 <erisco> it uses a list of rewrite rules? maybe that is how it was entered
14:06:08 <lifter> I thought that w/ GHC 8.2.1 I'd be able to use record fields with the same name without having to explicitly disambiguate them by supplying type signatures, but this doesn't seem to be the case.
14:06:20 <DigitalKiwi> erisco I just wanted to tell you that I appreciated your commentary on grooking :P
14:07:59 <erisco> I'm here mon-fri and also weekends
14:08:23 <DigitalKiwi> ditto
14:15:43 <lyxia> lifter: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-field-selector-polymorphism ?
14:16:13 <lyxia> lifter: it's the only reference to records in the release notes
14:17:17 <lifter> Yeah I've been reading that, and actually I am using that ver of GHC. Which is why I'm puzzled.
14:21:30 <lifter> I have DuplicateRecordFields turned on, of course, but I find I still have to explicitly specify the type signature of a record access function or the compiler says "Ambiguous occurrence".
14:24:38 <lyxia> How do you mean? Are you using getField or the actual record accessor?
14:25:04 <lifter> The actual record accessor.
14:25:39 <lyxia> the link I gave uses getField as the polymorphic record accessor
14:26:37 <lifter> Woah.
14:27:39 <Athas> Has anyone else noticed that GHC 8.2.2 is much slower at type checking/inference in some cases?
14:28:10 <erisco> worst case is exponential, right?
14:29:15 <Athas> Sure, but but particular program type-checks much faster on 8.2.1.
14:29:29 <Athas> It's a Happy-generated parser, so not exactly idiomatic Haskell.
14:30:40 <lifter> lyxia: So basically you have to use "getField" then, that's the trick?
14:31:52 <lyxia> lifter: getField @"myFieldName"
14:32:51 <lifter> Gosh, ok. It's compiling. Just wow.
14:33:04 <lifter> Thanks.
14:33:57 <Guest18476> http://lpaste.net/360431
14:34:19 <Guest18476> i'm trying to write fibonnacci numbers
14:34:41 <Guest18476> i got an error message saying y' is not in scope 
14:34:50 <lifter> So I wonder if further work will is planned on the duplicate record fields problem, or is this the final solution moving forward?
14:35:35 <Athas> I guess there is no chance of Haskell growing a proper record system?
14:36:41 <lifter> @Guest18476 The y' inside the list comp is not visible outside of the list comp.
14:36:41 <lambdabot> Unknown command, try @list
14:37:19 <Profpatsch> Uh, Trifecta.Parser instantiates TokenParsing
14:37:32 <EvanR> i know other languages have something better, but what is "proper", is the jury not out
14:37:39 <Profpatsch> With the defaults implemented by the TokenParsing class.
14:38:10 <Profpatsch> So it’s expected that one newtypes the trifecta parser to change those defaults?
14:38:19 <EvanR> ghc doing something geologically monumental to give something a little better, and then everyone is mad because its not as good as X
14:38:33 <lifter> Personally I'm quite surprised by the `getField @"name"` syntax, I assumed at some point I'd just be able to `name` without having to `name :: (X -> Y)`
14:39:21 <lifter> But the problem is probably a lot thornier than I think.
14:39:42 <lifter> I am curious if further work is being done.
14:39:51 <EvanR> field accessor naming is just a small piece of the whole shebang
14:40:21 <EvanR> i want at least vinyl without the gymnastics
14:40:52 <lifter> EvanR: By "small piece of the whole shebang", do you mean more changes are coming in future versions of GHC?
14:41:24 <lifter> Like we don't have the whole shebang yet?
14:41:37 <EvanR> no, just the universe of things known to me that haskell records dont have
14:41:54 <lifter> Ah I see.
14:42:05 <EvanR> i am drawing a distinction between field naming and "proper records"
14:43:01 <fishythefish> @Guest18476: can you clarify what exactly you're trying to do with fibonacci? your type signature seems to be at odds with your goal
14:43:01 <lambdabot> Unknown command, try @list
14:50:54 <woodson> Hi everyone, can anyone tell me what library is mostly used for implementing jwt?
14:51:56 <Welkin> woodson: search hackage
14:51:56 <Welkin> http://hackage.haskell.org/packages/search?terms=jwt
14:55:06 <lifter> I guess there's no way around having to tack on a type signature when using record update syntax such as `x { f = a } :: X`, where `f` is a duplicate record field.
14:55:57 <Welkin> duplicate record field?
14:56:06 <Welkin> you mean you have two fields with the same name?
14:56:11 <lifter> Yeah that's what I mean.
14:56:15 <Welkin> don't do that
14:56:20 <Welkin> make  them all unique
14:57:42 <Welkin> wait these two fields with the same name in the same record? Or two different record definitions that share the same field name?
14:58:14 <lifter> Different record data types each have a field of the same name.
14:58:23 <marvin2> i don't think one record can have two fields with the same name?
14:58:42 <erisco> > fix(([0,1]++).liftA2(zipWith(+)) tail id)
14:58:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:58:48 <Welkin> I didn't think so either marvin2, but I never tried
14:58:51 <Welkin> but yes
14:59:06 <Welkin> because records in haskell have some issues, you generally name them like this
14:59:26 <Welkin> data Person = Person { personName :: String, personAge :: Int }
14:59:33 <Welkin> or even prefix with underscores like so
14:59:41 <Welkin> data Person = Person { _personName :: String, _personAge :: Int }
14:59:52 <Welkin> and then you generate lenses that drop the prefixed underscore
14:59:57 <erisco> the pointed form is shorter still, but I am out of ideas right now
15:00:26 <lifter> Anyhow I know that "don't do that" is popular advice, but in this case I'm interested in what the most recent version(s) of GHC have to offer, such as DuplicateRecordFields and https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#record-field-selector-polymorphism
15:00:28 <erisco> > let x=0:1:zipWith(+)(tail x)x in x
15:00:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:00:35 <[Leary]> Guest18476—the scope error is because let used inside the list comprehension, and does not define the y' used in the recursive call fn (y:y'). Also you have type errors: y is being used both as an Int and an [Int].
15:00:53 <Welkin> lifter: there are options available, but I haven't bothered to try them. I have heard that most still have problems
15:01:02 <Welkin> lens is still the answer to all record woes
15:01:23 <Welkin> I am okay with using long field names like above
15:02:38 <erisco> pl is actually smart here… fix((0:).(1:).(zipWith(+)=<<tail))
15:04:04 <Welkin> erisco: wtf is that golfing monstrosity?
15:04:15 <erisco> actually each part is nice
15:04:20 <Welkin> use spaces!
15:04:21 <sternmull> lifter: I use the extensions DeriveGeneric, DuplicateRecordFields, FunctionalDependencies, MultiParamTypeClasses, TemplateHaskell, FlexibleInstances and then the TH function makeFieldsNoPrefix from lens. This allows me to have duplicate records fields. Not sure if this also works if the fields have different types.
15:04:24 <Welkin> barbarian!
15:04:41 <erisco> oh, well… that's for a projectional editor to fix :P
15:05:17 <n_blownapart> http://lpaste.net/360432  hey I thought the most generalized signature would work if I changed the function name for foldr. but the error is " couldn't match type 't' with [] , 't' is a rigid type variable ... "
15:06:19 <crucify_me> << sorry this is the real me
15:06:27 <erisco> crucify_me, if you pattern match on lists then the type must be a list
15:07:05 <fishythefish> crucify_me: i.e. the fully generalized signature allows you to *use* it on lists (and any other Foldable), but of course you can't define it only on lists anymore
15:07:42 <erisco> if only there were list sections and one could write [0,1,]
15:07:55 <int-e> erisco: itym fix((0:).scanl(+)1)
15:08:17 <erisco> dunno what itym means but that's nice :)
15:08:21 <fishythefish> i think you mean
15:08:29 <int-e> > fix((0:).scanl(+)1)
15:08:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:08:51 <int-e> (itym = I think you mean)
15:09:36 <erisco> someone was talking about pairing adjacent elements with the zip and drop method, which made me think of that recursive definition for the Fib sequence
15:10:07 <crucify_me> ok, but that is the prelude definition for foldr so its not written precisely for the generalized signature?
15:10:30 <erisco> I don't think that is the Prelude foldr… source?
15:10:46 <erisco> it used to be once upon a time
15:11:14 <crucify_me> erisco thanks, I was under the impression that the lambdabot had the prelude defs
15:11:29 <erisco> @src foldr
15:11:29 <lambdabot> foldr f z []     = z
15:11:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:11:40 <erisco> I dunno, I don't know how it builds that database
15:12:07 <crucify_me> thanks
15:12:08 <int-e> erisco: there's no automation for that at all, it's basically a text file
15:12:46 <erisco> in GHC 7 something, iirc, Prelude was updated to use Data.Foldable and some other modernisations
15:12:47 <int-e> see https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source
15:12:48 <dminuoso> erisco: Can I have ghci do this too? Show me the src for given function that is.
15:13:17 <erisco> I think not but I hope I'm wrong
15:13:20 <Welkin> no
15:13:26 <Welkin> the @src feature is a lie
15:13:31 <dminuoso> Ohhh.
15:13:37 <Welkin> it is just a chunk of text stored in a hash table
15:13:40 <crucify_me> I guess a beginner should specify the data type in signatures as needed?
15:13:47 <Welkin> it is a lambabot feature only
15:14:02 <erisco> afaik compiled Haskell modules do not include source code
15:14:51 <erisco> you can use :browse to get a list of exported definitions, though
15:15:05 <Chobbes> Uhhh. Hmmm. https://hackage.haskell.org/package/random-1.0.0.2/docs/System-Random.html#t:Random let's say I have a quantum random number generator sitting beside me, and I want to read bits off of that to generate random values using the Random interface. So, I essentially have an IO Int function, and I want to be able to genaerate any Random a from that... There's not actually a way to rig up the types for
15:15:06 <Chobbes> this to work is there?
15:15:56 <erisco> crucify_me, add verbosity to remove confusion, as needed. Eventually you'll learn and grow tired of being redundant!
15:16:28 <Welkin> crucify_me: all top-level definitions should always have type declarations
15:16:33 <koala_man> Chobbes: no. like the description says, this class is specifically for PRNGs and generating repeatable results
15:17:07 <crucify_me> erisco: Welkin  thanks 
15:17:11 <tabemann> top level type declarations keep the monomorphism restriction from biting
15:17:58 <EvanR> Chobbes: theres a few different RNG apis out there, dont worry if System.Random is working out
15:18:04 <EvanR> isnt8
15:18:06 <EvanR> *
15:18:11 <erisco> '
15:18:15 <crucify_me> tabemann: well, I don't quite understand b/c I thought the polymorphic signature would account for that definition   http://lpaste.net/360432
15:18:40 <Chobbes> koala_man: yeah, but I want something that's basically... Monad m, Random a => m Int -> m a
15:18:44 <barrucadu> :t \iox -> (fst . random . mkStdGen) <$> (iox :: IO Int) -- you could also do this, but it's kind of icky
15:18:46 <lambdabot> Random b => IO Int -> IO b
15:18:59 <fishythefish> crucify_me: yeah, but that's not the monomorphism restriction
15:20:01 <fishythefish> the monomorphism restriction is when you forget to supply a type signature and the compiler sometimes infers a less-polymorphic type than you expected
15:20:29 <fishythefish> in this case, you've supplied a polymorphic signature, but a definition that is less-polymorphic than what you promised
15:20:42 <Chobbes> barrucadu: that might work, but that would just seed the PRNG with the QRNG, no? Ideally I want to use the QRNG to generate each bit of input, and utilize the Random interface to generate values from a stream of Ints.
15:21:23 <barrucadu> Chobbes: It would, which is why I said it's kind of icky.  Every call to that function would generate a new PRNG seeded from the QRNG, generate one random value from it, and discard the PRNG
15:25:38 <crucify_me> fishythefish: thanks I get that
15:26:51 <orion> Is there an efficient data structure I can use to index a large value in two different ways?
15:28:09 <orion> (Without duplicating the values)
15:28:48 <Chobbes> barrucadu: yeah, hmmm. Seems a shame that the "standard" Random class doesn't just use a monad to keep track of the generator state. Every other random interface seems to either rely upon it, or just returns bytes in some form or another :\.
15:30:01 <Chobbes> barrucadu: thanks for the icky way forward, though! At least it's something :).
15:34:17 <aberrant> what's the proper way to create an equality function for a custom datatype?
15:34:37 <Chobbes> instance Eq MyCoolType where
15:34:48 <Chobbes>     a == b = ...
15:34:57 <aberrant> ah, ok. Thanks.
15:36:25 <gitBro> I'm looking for an easy gui for writing 2048, any ideas?
15:36:46 <gitBro> i went with threepenny but im a bit confused how i would translate my grid into a viewable tile
15:37:18 <aberrant> Chobbes: you don't do a "deriving (Eq)" when you override equality, do you?
15:37:51 <fishythefish> aberrant: not if you're specifying your own
15:38:08 <aberrant> ok, thanks.
15:38:23 <aberrant> I am - I'm trying out my new skills by reproducing rational numbers
15:38:41 <fishythefish> deriving always means that you're trusting the compiler to do it for you. in the case of Eq, it'll just perform a structural recursive Eq check
15:39:28 <aberrant> yup, not what I want :)
15:41:01 <aberrant> this isn't working right
15:41:46 <crucify_me> fishythefish: if you're not too tired, we could go through the unifying based on this? http://lpaste.net/360433
15:41:46 <fishythefish> aberrant: got a paste and a test case?
15:41:54 <fishythefish> crucify_me: sure
15:42:05 <crucify_me> excellent
15:42:24 <fishythefish> actually, i like the way you did it in steps; i'll follow that pattern
15:42:26 <aberrant> https://pastebin.com/CkDpkqKd
15:42:26 <fishythefish> :t foldr
15:42:28 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:42:36 <aberrant> the Eq has errors
15:42:39 <fishythefish> crucify_me: i take it that signature is clear?
15:42:45 <aberrant> • Couldn't match expected type ‘Rat’                   with actual type ‘Integer -> Integer -> Integer’
15:43:10 <fishythefish> aberrant: you need backticks around `div` for infix
15:43:18 <aberrant> oh, crap.
15:43:22 <aberrant> sorry.
15:43:43 <pastorin_> Hello guys, I have a quick question, I want to learn Haskell, but I dunno where to start. could you share with me a list of recommended books or resources? thanks in advance.
15:43:50 <aberrant> no, that's not all that's wrong, fishythefish
15:44:11 <aberrant> pastorin_ I'm currently going through Learn You A Haskell For Great Good
15:44:13 <crucify_me> so yes, a is unified with b, the acc, then the acc itself, then it takes a foldable type a ([a] for our purposes) then returns the acc with the  solution
15:44:33 <aberrant> pastorin_: check out https://www.haskell.org/documentation
15:44:40 <pastorin_> thanks!!!
15:44:48 <Chobbes> pastorin_: a lot of people like the Haskell Book. I've also found the wikibook to be quite good.
15:44:49 <fishythefish> aberrant: right, the next is to fix your "r1.den" notation
15:44:50 <crucify_me> meaning the second arg b is the acc itself
15:44:53 <gitBro> any easy gui recommendations? i'm making 2048
15:44:57 <fishythefish> you want "den r1"
15:45:02 <aberrant> fishythefish: yeah, that's the problem.
15:45:04 <aberrant> wait, why?
15:45:07 <aberrant> it's a field.
15:45:17 <fishythefish> fields in haskell are just functions
15:45:23 <aberrant> orly? wow, ok
15:45:25 <aberrant> thank you.
15:45:34 <fishythefish> check out the type of num and den with :t
15:45:44 <fishythefish> should be Rat -> Int
15:46:28 <fishythefish> crucify_me: er, hold on, there's no unification yet
15:46:34 <aberrant> that's so cool.
15:46:44 <erisco> really killing me that on 8.2.1 ctrl+c does not kill the ghc process
15:46:51 <erisco> ctrl+c in ghci
15:47:03 <fishythefish> crucify_me: unification is the process of solving for type equality, not the value-level combining the first argument to foldr is doing
15:47:07 <dminuoso> So if a type variable is rigid, why can it be replaced/unified at all? Or is "being rigid" just relative to the context?
15:47:09 <crucify_me> (a -> b -> b) this unifies the elements with the acc as per earlier chat?
15:47:23 <fishythefish> crucify_me: not in the sense of type unification
15:47:43 <aberrant> fishythefish: thank you very much for the help.
15:47:44 <erisco> it is still tied into my shell after ghci "quits"
15:47:52 <fishythefish> aberrant: my pleasure
15:47:54 <erisco> have to force kill
15:48:03 <dminuoso> I mean lets take: `x :: a; x = 'a'` for example
15:49:25 <crucify_me> ok in other words fishythefish foldr takes a binary operator, which returns a b and looks like this (a -> b -> b)
15:49:26 <fishythefish> dminuoso: a rigid type variable is just one fully specified by the programmer in a signature
15:49:43 <fishythefish> crucify_me: a binary function, yes
15:49:50 <crucify_me> ok check
15:50:26 <pie_> anyone here deal with graph grammars?
15:50:26 <fishythefish> :t foldr (.)
15:50:28 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
15:50:34 <fishythefish> now the goal is to get to that
15:50:43 <fishythefish> :t (.)
15:50:45 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:50:49 <erisco> in ghci, ctrl+c used to stop any long running execution
15:50:55 <Welkin> learn how to do type unification and reduction by hand, on paper
15:50:58 * hackage madlang 3.1.2.0 - Randomized templating language DSL  https://hackage.haskell.org/package/madlang-3.1.2.0 (vmchale)
15:51:10 <dminuoso> fishythefish: I guess Im just trying to understand the wording of the diagnostic
15:51:14 <fishythefish> in order to avoid clashing type variable names, i'm going to call that (b' -> c') -> (a' -> b') -> a' -> c'
15:51:45 <Welkin> erisco: real programmers use kill -9 !
15:51:49 <fishythefish> dminuoso: it's just telling you where that type variable came from
15:51:56 * hackage hoauth2 1.5.1 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.5.1 (HaishengWu)
15:52:00 <dminuoso> fishythefish: Being rigid implies something like: f x = x; f 1 should not work
15:52:08 <erisco> if I enter [1..] into ghci then ctrl+c I should get back the ghci prompt
15:52:15 <erisco> but instead I get back my shell prompt, but ghci is still running
15:52:19 <fishythefish> dminuoso: explain?
15:52:22 <hpc> Welkin: my kill goes up to 11
15:52:23 <crucify_me> so that takes the most general form of a func (a -> b) (the first element of a list of functions) since it is composition
15:52:35 <fishythefish> crucify_me: right, but through the process of unification, we'll specialize
15:52:39 <erisco> I don't know what changed in 8.2.1 but it has thrown off my groove
15:52:49 <crucify_me> specialize?
15:52:57 <fishythefish> crucify_me: yes, to a less-general type
15:53:05 <crucify_me> ok
15:53:23 <fishythefish> setting the function types equal, we get a ~ b' -> c', b ~ a' -> b', and b ~ a' -> c'
15:53:56 <dminuoso> fishythefish: Ohh wait. This does not change the fact that f still has a polymorphic type, so its rigid in the sense that it was specified by me?
15:54:12 <fishythefish> dminuoso: yes, read "rigid" as "programmer-given"
15:54:38 <dminuoso> fishythefish: Now this begins to make sense https://mail.haskell.org/pipermail/haskell-cafe/2013-November/111397.html
15:54:42 <dminuoso> Thank you
15:54:44 <erisco> I am pretty sure I have written up a verbose type inference at least
15:54:47 <crucify_me> which functions are we setting equal?
15:54:54 <monochrom> "programmer" is too broad. There is a line between "author" and "user".
15:55:05 <fishythefish> i'm not a fan of the vocabulary myself, but i believe the intent is that it's "rigid" in that the compiler doesn't have a choice how polymorphic it is -- the author said so (thanks monochrom)
15:55:42 <fishythefish> crucify_me: we're equating the types of the first argument of foldr and the function (.)
15:55:51 <Welkin> monochrom: a "user" is also what we call drug addicts
15:56:08 <crucify_me> one sec
15:56:17 <dminuoso> Welkin: Thats not mutually exclusive with the user of the software though.
15:56:18 <erisco> well there is this one for Welkin http://lpaste.net/357374
15:56:34 <dminuoso> Welkin: Software users can also be drug addicts, making it truly ambiguous
15:56:36 <erisco> I might have done it a second time in chat then
15:56:39 <Welkin> oh lol
15:56:44 <Welkin> erisco: I remember that one
15:56:45 <monochrom> Well I wonder why Welkin brings it up now after all these decades
15:56:49 <Welkin> it is cleaner to do it on paper though
15:57:25 <dminuoso> erisco: Oh wow! I was thinking about this yesterday, you wouldnt mind if I look at this right? :-)
15:57:38 <zachk> say I have a list of IO actions [IO ()], how would I compse them all together so I could run them?
15:57:56 <Welkin> :t sequence -- zachk 
15:57:57 <fishythefish> zachk: sequence
15:57:57 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
15:57:59 <erisco> that's a very private public paste, but I'll grant you viewing for the next 13 minutes
15:58:11 <dminuoso> zachk: Possibly also sequence_
15:58:21 <dminuoso> :-)
15:58:23 <zachk> :t sequence_
15:58:24 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
15:58:59 <aberrant> would someone please review my code (it works) and comment on its style, syntax, "haskell-ness", etc?
15:59:01 <aberrant> https://pastebin.com/SRp6MRA9
15:59:23 <erisco> I don't know if working up to triple primes was the best notation, but there it is :P
15:59:41 <erisco> what I'd like is a formal notation for such things
16:01:22 <erisco> that way when someone has a typing question they can follow an exact system which can be easily written
16:03:23 <Welkin> I use numbers (e.g. a becomes a1)
16:03:40 <erisco> so, you use base 10, and I used base 1 :P
16:03:43 <Welkin> I came up with my own "system"
16:04:03 <Welkin> I start by crossing out the parameter from the type signature that has just been applied
16:04:17 <Welkin> then I unify the type of the parameter and the value
16:04:21 <Welkin> then I substitute
16:04:28 <Welkin> rinse and repeat
16:04:33 <crucify_me> so on line 2 fishythefish , the first a is equated with b' -> c' . what is b' -> c'  ?   http://lpaste.net/360433
16:04:58 <fishythefish>  :t (.) -- crucify_me, just put a ' after each type variable
16:05:17 <fishythefish> :t (.)
16:05:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:06:09 <crucify_me> got it thanks give me a minute   :)
16:06:14 <fishythefish> crucify_me: i'm doing this because the type variables that :t (.) gave me are not necessarily the same ones as the ones from :t foldr
16:07:02 <Welkin> josevalim1: the elixir author?
16:09:06 <crucify_me> so all the variables in (a -> b -> b) are accounted for by (.) :: (b' -> c') -> (a' -> b') -> a' -> c'
16:09:09 <crucify_me> fishythefish: 
16:09:32 <fishythefish> yes, we set those two types equal and solve
16:09:46 <crucify_me> ok got that, excellent, please continue
16:10:02 <fishythefish> we now have a ~ b' -> c', b ~ a' -> b', and b ~ a' -> c'
16:10:21 <crucify_me> right
16:10:27 <fishythefish> the last two imply that b' ~ c'
16:11:08 <aberrant> anyone using Haskero?
16:12:06 <fishythefish> so we ultimately get a ~ b' -> b' and b ~ a' -> b', so foldr (.) :: (a' -> b') -> t (b' -> b') -> a' -> b'
16:12:19 <fishythefish> and if you get rid of the 's that should look familiar
16:12:42 <erisco> the main annoyance is generating variables… how can the system avoid this
16:13:50 <fishythefish> erisco: those variables all exist separately, though. unless i'm missing something, you can't avoid generating them; all you can do is name them better and eliminate redundant ones as early as possible
16:14:12 <aberrant> loving this.
16:14:17 <erisco> I am thinking at least of using binders
16:14:20 <erisco> i.e. forall
16:14:38 <fishythefish> explicit ones, you mean
16:14:46 <erisco> that's right
16:14:48 <aberrant> man, this is cool
16:14:53 <fishythefish> :set -XRankNTypes
16:14:53 <aberrant> my first haskell thing
16:14:54 <fishythefish> here we go
16:15:07 <erisco> for example, we begin  flip :: (a -> b -> c) -> b -> a -> c  and  id :: a -> a
16:15:53 <erisco> but if we write  (flip :: (a -> b -> c) -> b -> a -> c) (id :: a -> a)  then the scope is easily confused
16:15:54 <aberrant> I think I'm still using too many parentheses though
16:16:31 <erisco> but maybe by adding binders we can reuse the same names and not be confused
16:16:47 <erisco> well, if you're a bit practiced at LC, maybe it won't be too confusing
16:16:56 <fishythefish> all binders can do is introduce variables into a scope, though
16:17:08 <fishythefish> ultimately those variables have to be in the same scope in order to solve, so i think it comes down to naming
16:17:51 <erisco> why do they have to be in the same scope?
16:18:13 <fishythefish> er, "namespace", i guess, not "scope"
16:19:41 <erisco> no I am just not convinced it is necessary, but I haven't worked out the answer
16:19:56 <erisco> I am just saying if it is going to be convenient we can't get bogged down with all these variable names
16:20:56 <fishythefish> well, depending on the environment, you could color-code or something?
16:21:10 <erisco> think of using a pencil and paper
16:21:10 <fishythefish> font style, idk
16:21:20 <fishythefish> caps/lowercase
16:21:53 * hackage playlists-http 0.2.0.0 - Library to glue together playlists and http-client  https://hackage.haskell.org/package/playlists-http-0.2.0.0 (PeterJones)
16:22:09 <fishythefish> i guess i'm thinking of an equational reasoning approach, though. conceivably with something more diagrammatic naming wouldn't be such a concern
16:22:36 <daey> is there any reason why i should use the 2nd writing style? http://lpaste.net/360434
16:22:59 <daey> i mean lpaste even tells me to not do it, so i guess i should avoid it. just wondering why it even exists
16:23:26 <fishythefish> daey: they actually behave differently; lpaste is just doing a common lint
16:23:29 <erisco> for example, starting here   forall a b c. (a -> b -> c) -> b -> a -> c ~ forall a b. a -> b
16:24:02 <fishythefish> (did i lose crucify_me?)
16:24:05 <erisco> we might say something like  forall a b c. (forall a b c. (a -> b -> c) -> b -> a -> c) a b c ~ (forall a b. a -> b) (a -> b -> c) (b -> a -> c)
16:24:59 <erisco> I am not sure of each deduction yet but this is the sort of thing I am thinking of
16:25:17 <crucify_me> no thanks fishythefish a lot. ! I'm getting this all in notes
16:25:28 <daey> im mostly impressed by how quickly you typed those lines :^)
16:25:39 <crucify_me> so yes I've followed to :t foldr (.) pretty well
16:25:42 <fishythefish> crucify_me: i can continue whenever you want
16:25:57 <crucify_me> ok yes please
16:26:41 <fishythefish> we have foldr (.) :: (a' -> b') -> t (b' -> b') -> a' -> b' and id :: a'' -> a''
16:27:10 <fishythefish> to get the type of foldr (.) id, we unify a' -> b' ~ a'' -> a''
16:27:19 <fishythefish> so a' ~ a'' and b' ~ a''
16:27:37 <fishythefish> so foldr (.) id :: t (a'' -> a'') -> a'' -> a''
16:27:53 <fishythefish> and if we rename our variable a'' to b, this is the signature you gave
16:28:23 <crucify_me> one moment pls
16:28:32 <fishythefish> take your time, that's the whole thing :)
16:29:02 <zachk> man, seems control-c is broken in ghci on windows 10 for me :(
16:29:15 <erisco> zachk, yes I was just commenting on this… 8.2.1?
16:29:28 <erisco> it has been broken for months but I felt like complaining today about it :P
16:30:51 <erisco> I don't know exactly what is going on… but I am guessing ghci has two processes
16:30:59 * tabemann is happy that he can now abuse 02c03o04l05o06r07s in his IRC client now for some reason
16:31:19 <tabemann> (and, yes, I wrote it myself)
16:31:25 <erisco> ctrl+c is killing one, throwing you back to the shell, but the ghci REPL is still running
16:31:27 <zachk> yea I am on a command prompt and other threads from my program that "was running" are still running
16:31:30 <Welkin> can you taste the rainbow?
16:31:40 <tabemann> yes, I can taste the rainbow
16:31:45 <erisco> not sure how processes work on Windows either… such as orphans
16:31:51 <zachk> can you taste the rainbow in the unicorn squattie potty commercial?
16:32:01 <erisco> is it leaving an orphan and that is kept alive? dunno
16:32:05 <dminuoso> erisco: You have been asking about a formal notiation for type variable names in unification: Text colors like tabemann just displayed. :-D
16:32:06 <zachk> erisco is it broken on linux etc as well?
16:32:11 <tabemann> I haven't seen that commercial
16:32:22 <zachk> look it up on youtube, its a gas
16:32:40 <erisco> that commercial is really weird
16:33:35 <tabemann> I just love having an IRC client that's all my own, even if it is not quite as functional as the likes of HexChat (but it's getting there)
16:33:51 <erisco> colours are not a bad idea but they are not always usable, and also in this case I don't think the number of variables you need is bounded
16:33:54 <zachk> tabemann what did you code it in?
16:33:58 <tabemann> Haskell
16:34:09 <zachk> cool, I had a simple one a few times
16:34:13 <erisco> so you'll run out of colours… it doesn't actually address the problem of having too many variables
16:34:14 <tabemann> very un-idiomatic Haskell
16:34:16 <crucify_me> so the unification only takes place in the first arg of foldr (.) , which is (a' -> b') right? fishythefish
16:34:22 <tabemann> it's basically a big pile of concurrency and STM
16:34:31 <tabemann> very, very imperative in coding style
16:34:34 <fishythefish> crucify_me: yes, because we're only applying that argument at the moment
16:34:38 <erisco> in programming you aim to have as few variables in scope as you can, because it simplifies life
16:34:58 <erisco> the fact we need to generate dozens of variables is because we are trying to have them all in the same scope
16:35:06 <dminuoso> erisco: So what you are saying is we need a new RFC extending IRC colors to 16M colors?
16:35:23 * hackage myanimelist-export 0.1.0.1 - Export from MyAnimeList  https://hackage.haskell.org/package/myanimelist-export-0.1.0.1 (mat8913)
16:35:31 <erisco> no, I am saying a glyph in a different colour is no different than another variable… may as well be a1 rather than 'a' in red
16:35:31 <tabemann> it shouldn't be hard to extend IRC colors to support 24-bit color
16:35:42 <dminuoso> Ah
16:35:43 <monochrom> No, what we need is standardizing the palette for real.
16:35:54 <tabemann> just have the client check for # after the byte 0x03
16:36:07 <tabemann> and if # is present, treat the next six characters as forming a 24-bit color in hex
16:36:11 <zachk> I wonder if you could get a movie to play in irc with color using caca lib
16:36:35 <monochrom> Like, the current state is, the meaning of "colour #4" is oh-so-configurable so if you try to use colours for syntax highlighting you can't really assume anything at all.
16:36:37 <erisco> go ahead… I am sure shapr won't mind
16:37:13 * tabemann has yet to make the values of the colors configurable - that is something that he plans on doing in the near future
16:37:24 <monochrom> Unlike your trusty ANSI terminal.
16:37:43 <tabemann> yeah, this client uses GTK+ so the colors can be anything I want
16:38:29 <monochrom> Add the fact that you can't even assume about background colours.
16:38:42 <monochrom> I for one am using white background.
16:38:46 <koala_man> freak
16:39:19 <monochrom> I am also using variable-width font.
16:39:21 <erisco> actually I think we need to be using a different symbol than ~ for this
16:39:28 <tabemann> I'm currently using black on white, but a future change I have planned is to change it to green on black when I figure out how to make GTK+ do that for not just characters but whole widgets
16:40:09 <crucify_me> fishythefish: I have one issue ...
16:40:26 <erisco> it seems perverse to be saying something like  a -> b ~ f c  when we intend to deduce that
16:40:48 <monochrom> I prefer = when you want to convey "equal".
16:41:07 <fishythefish> crucify_me: go for it
16:41:12 <monochrom> But I'm a freak.
16:41:20 <erisco> the only axiom is  x ~ x
16:41:23 <koala_man> tabemann: with your 24bit color scheme, how would you know if it's in sRGB or P3? 
16:41:28 <monochrom> The majority use -> for "equal", = for "not equal".
16:41:39 <erisco> then the inference rules
16:41:56 <crucify_me> to get that type of foldr (.) id, we unify a' -> b' ~ a" -> a"    fishythefish    so a' ~ a'' and b' ~ a''
16:42:39 <crucify_me> but isnt that a' ~ a" -> a"    and    b' ~ a" -> a"  ?
16:42:43 <fishythefish> crucify_me: yup, to get a -> b ~ c -> d, we must have a ~ c and b ~ d
16:43:19 <fishythefish> crucify_me: no, we must equate the left sides of the ->s and the right sides of the ->s
16:43:29 <erisco> then again, starting with the conclusion and working backwards should be valid
16:43:59 <crucify_me> ok gotta go back .. give me a bit
16:44:28 <tabemann> koala_man: you'd go with whatever is the system default, just like web colors
16:45:05 <erisco> 2 * 2 = 4 ⇒ (1 + 1)*(1 + 1) = 1 + 1 + 1 + 1 ⇒ 1*1 + 1*1 + 1*1 + 1*1 = 1 + 1 + 1 + 1 ⇒ 1 + 1 + 1 + 1 = 1 + 1 + 1 + 1 ⇒ … 1 = 1
16:45:19 <erisco> that sort of thing, where you end at the axiom rather than start with it
16:45:28 <tabemann> making users write 0x03#00ff00foobar0x03#ffffff is enough (where 0x03 is that byte)
16:46:16 <erisco> really the arrows should go the other way, so ⇐
16:47:01 <erisco> I forget… I read an article once promoting that order and making fun of the conventional one… calling it "pompous order" or something like that XD
16:47:23 * hackage Octree 0.5.4.4, hPDB 1.2.0.10 (MichalGajda): https://qbin.io/bkbx33g
16:48:21 * hackage hPDB-examples 1.2.0.8 - Examples for hPDB library  https://hackage.haskell.org/package/hPDB-examples-1.2.0.8 (MichalGajda)
16:48:45 <koala_man> tabemann: you can specify rgb per gamut on the web these days
16:49:47 <koala_man> and surely we should allow for other future gamuts with more gamuts
16:49:53 <koala_man> err primaries
16:49:55 <crucify_me> so fishythefish  back to your post :   foldr (.) :: (a' -> b') -> t (b' -> b') -> a' -> b' and id :: a'' -> a''
16:50:15 <fishythefish> mhm
16:50:26 <tabemann> how much extensibility in a color formatting scheme is enough?
16:50:38 <tabemann> if we are talking about adding more primary colors beyond R G B...
16:51:03 <crucify_me> so here the last a' -> b'  (w/o parens) is also being substituted with a" -> a"  ?
16:51:14 <davean> Really you want to specify the frequency, amplitude, phase, and incident angle of the photons that you want to represent
16:51:15 <fishythefish> no
16:51:40 <davean> The display end should try to emulate that most closely for the optics of the current viewer given its output capabilityies
16:51:43 <fishythefish> crucify_me: when we say `foldr (.) id`, we're asserting/requesting that a' -> b' and a" 
16:51:53 <fishythefish> a" -> a" match up*
16:52:34 <erisco> nitpicking your wording… asserting and requesting are dual things
16:52:43 <fishythefish> erisco: heh, yeah, that's why i hedged
16:52:58 <fishythefish> it depends on how you want to look at it i guess
16:53:11 <crucify_me> so the final type unification, begins here (a' -> b') and both a' and b' are substituted with a" -> a"   ?
16:53:18 <fishythefish> you can assert that this is the case and the typechecker will attempt to comply, or you can request it and the typechecker will agree or yell at you
16:53:38 <fishythefish> crucify_me: no, (a' -> b') as a whole is matched up with (a" -> a") as a whole
16:53:57 <fishythefish> that's coming from the (a' -> b') at the beginning of the type of foldr (.), not the end
16:54:02 <erisco> you can't assert it
16:54:04 <crucify_me> :t foldr (.) id
16:54:05 <lambdabot> Foldable t => t (b -> b) -> b -> b
16:54:20 <erisco> asserting  a ~ b  is saying that  a ~ b is true
16:54:47 <fishythefish> erisco: eh, yeah, but i don't mean in a formal logical sense. more in the sense that static checking is checking of your assertions as a programmer
16:55:04 <fishythefish> i'm not really gonna defend the word choice, "request" is fine
16:55:46 <crucify_me> ok so then we have two separate b types but those are not read as right associative id like (b -> b). a bit confused
16:56:39 <erisco> I get what you're saying. Hopefully the conversation is clarifying to any readers :)
16:57:01 <zachk> is lambdabot broken on pm or something?
16:57:05 <zachk> > 2+2
16:57:07 <lambdabot>  4
16:57:09 <fishythefish> crucify_me: type variables are fresh each time you invoke :t. ghci/lambdabot will freely reuse type variables on each invocation
16:57:23 <erisco> zachk, not for me
16:57:27 <fishythefish> zachk: works for me, check whitespace
16:57:48 <fishythefish> crucify_me: that's why i'm using all the prime notation for now
16:58:06 <erisco> lambdabot chooses its private friends cautiously, though… give it time
16:58:16 <crucify_me> hold on I feel near to understanding . one sec
16:58:44 <zachk>  > (foldr (.) id [($),($),($)]) (+2) 2
16:58:51 <zachk> > (foldr (.) id [($),($),($)]) (+2) 2
16:58:52 <lambdabot>  4
16:59:07 <zachk> now find something other then ($) that fits in there 
16:59:14 <fishythefish> zachk: like id?
16:59:38 <zachk> > (foldr (.) id [id,id,id]) (+2) 2
16:59:41 <lambdabot>  4
16:59:47 <zachk> oh wow
16:59:50 <erisco> I would just say, as we understand them as constraints,  x :: c => t  is saying "if c, then x :: t"
16:59:58 <fishythefish> zachk: ($) is just a specialization of id
17:00:07 <erisco> I could be wrong on the precision of the type system here, but that is my learned understanding by using it
17:00:08 <zachk> never really thought of that
17:00:26 <zachk> :t (id,($))
17:00:26 <daey> writeFile requires a String. i managed to convert my Int -> Char. but how am i supposed to convert Char -> [Char]?
17:00:27 <lambdabot> (a1 -> a1, (a2 -> b) -> a2 -> b)
17:00:40 <erisco> what GHC will do for us, helpfully (and probably specified in the report) is determine if c is unsatisfiable
17:00:48 <dminuoso> Okay what is an infinite type?
17:00:59 <fishythefish> daey: the robot operator! (:[])
17:01:11 <fishythefish> dminuoso: a type that takes infinite ink to write out
17:01:23 <fishythefish> (hopefully hpc is proud of me)
17:01:31 <erisco> in which case it calls you a dummy before you even use x anywhere
17:01:41 <dminuoso> Well I just tried:
17:01:45 <dminuoso> :t foldr (.) id [(.)]
17:01:46 <lambdabot> error:
17:01:46 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ a0 -> b
17:01:46 <lambdabot>       Expected type: (b -> c) -> b -> c
17:02:15 <fishythefish> dminuoso: yeah, tl;dr is that if you try and perform the necessary unification, you'll run into the occurs check
17:02:37 <dminuoso> fishythefish: Okay let me some backup ink and work this out!
17:03:09 <fishythefish> dminuoso: and the occurs check says that you can't unify a ~ b where b contains a (and is not just a itself)
17:03:19 <zachk> dminuoso I tried to get that work "dynamically" in ghc, escaping skolem variables came up, then I tried to get it to work for another week in idris, still couldn't get it to work, work that is : foldr (.) id [(.),[(.),[(.)] 
17:03:33 <dminuoso> fishythefish: Ohh, so that's actually stating type "b" seems to equal "a0 -> b" ?
17:03:38 <fishythefish> because e.g. if a ~ [a], then a ~ [a] ~ [[a]] ~ [[[a]]] ~ ... and you can see where "infinite type" comes from
17:03:44 <fishythefish> dminuoso: exactly
17:03:51 <zachk> dminuoso if you can get that to work send it to me, I tried for a few weeks to no avail, even made custom list types using gadts etc.
17:05:15 <fishythefish> zachk: what would you expect that to do?
17:05:42 <fishythefish> what would you expect the result type to be?
17:06:03 <erisco> however, it would be fun to have a language with infinite types :3
17:06:59 <zachk> fishythefish never totally figured it out, I think you need some sort of dependent types
17:07:01 <zachk> things like
17:07:06 <zachk> :t (.).(.)
17:07:07 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
17:07:12 <zachk> :t (.).(.).(.)
17:07:13 <lambdabot> (b -> c) -> (a1 -> a2 -> a3 -> b) -> a1 -> a2 -> a3 -> c
17:07:49 <zachk> I had it kinda of working, but I wanted to be able to specify the length of the list of (.) at runtime, and couldn't figure out the types for it
17:07:55 <erisco> is [[..]] iso to a rose tree?
17:08:02 <crucify_me> fishythefish: maybe my notes are wrong at the end "W e ultimately .."    is that right?
17:08:09 <crucify_me> http://lpaste.net/360433
17:08:18 <erisco> oh I guess you're missing labels
17:08:25 <fishythefish> erisco: close, but there's no data at each node
17:08:37 <erisco> is to a rose tree of unit
17:08:41 <erisco> iso to*
17:09:10 <erisco> then, because they are equivalent, they are equal, amirite? :)
17:09:34 <fishythefish> erisco: ignoring evaluation strategy, i believe so
17:09:42 <fishythefish> crucify_me: notes seem a little off
17:10:01 <fishythefish> i'm not sure what you mean by "accounted for"
17:10:10 <fishythefish> and all that covers is the type of foldr (.), not foldr (.) id
17:10:41 <dminuoso> crucify_me: the original type information from fishythefish (it was basically 3-4 sentences) is what you need.
17:11:17 <crucify_me> dang it I got lost again
17:11:30 <fishythefish> added an annotation
17:12:02 <fishythefish> the annotation fills the gaps between lines 14 and 16
17:25:51 <crucify_me> fishythefish: so we unify (a -> b) in foldr (.) :: (a -> b)  with  (a" -> a")  then  that unification is replaced by id, so to speak, and t (b -> b) moves to the left and results the type is : t (b -> b) -> b -> b  , which itself is identity (b -> b) -> (b -> b) 
17:26:00 <aberrant> I am confused
17:26:02 <aberrant> • Couldn't match expected type ‘[(Rat, String)]’                   with actual type ‘(Rat, [Char])’
17:26:13 <Welkin> aberrant: String is a type alis for [Char]
17:26:17 <Welkin> alias*
17:26:18 <fishythefish> aberrant: the first type is a list, the second isn't
17:26:21 <aberrant> oh, it needs to be a list of tuples.
17:26:21 <Welkin> type String = [Char]
17:26:24 <aberrant> yeah, I got it.
17:26:28 <aberrant> thanks.
17:27:10 <fishythefish> crucify_me: foldr (.) doesn't have the type (a -> b), but if you're referring just to the first argument, then yes, we unify with a" -> a"
17:27:13 <fishythefish> beyond that, you lost me
17:27:31 <aberrant> when we override readsPrec, do we need to worry about more than one datatype in the string?
17:27:54 <fishythefish> crucify_me: it would help me if you define the word "unification" (or any conjugation thereof) so i can understand what you think it is
17:28:00 <aberrant> that is, why is it a list
17:28:24 <fishythefish> aberrant: there may be multiple possible parses
17:30:10 <aberrant> fishythefish: could you let me know whether this is right
17:30:35 <aberrant> (it works): https://pastebin.com/B2beC7n3
17:31:55 <aberrant> it takes a string like "a//b" and creates a rational datatype with a as the numerator and b as the denominator (a and b must parse as ints)
17:32:27 <crucify_me> once you unify the first arg and get a" -> a", that unification is "dropped" for id and we're left with  t (b -> b) 
17:32:29 <crucify_me> fishythefish: 
17:34:14 <fishythefish> aberrant: not too used to defining Read implementations (particularly with readsPrec rather than readPrec, but lines 4-5 seem iffy to me
17:34:33 <fishythefish> crucify_me: what do you think a unification is?
17:35:02 <fishythefish> crucify_me: i'm genuinely trying to understand this, because your language surrounding it is continually imprecise and this might be a sticking point i can help resolve
17:35:17 <crucify_me> thanks I mean this : 
17:35:53 <fishythefish> aberrant: maybe look into the Read implementation for Data.Ratio?
17:36:32 <Welkin> crucify_me: there are 3 steps. 1) Cross out the parameter that you just applied. 2) Unify that parameter with the type of the value you applied. 3) substitute the new variables in the remaining type signature
17:37:08 <Welkin> unifying the two types just means you make them fit together (like pattern matching)
17:37:45 <fishythefish> more precisely, unification is the process of finding substitutions for all variables that make two expressions equal. here, the expressions are types
17:38:07 <Welkin> you can unify `a -> b` with `c -> (d -> e)` by saying that `a ~ d` and `b ~ (d -> e)`
17:38:14 <crucify_me> to unify the final function id with (.) , we must unify (a -> b) with (a" -> a") . so as Welkin says that gets crossed out. the remaining types must agree with the full type of foldr (.) id to be fed into that composed function
17:38:26 <fishythefish> we are not unifying id with (.)
17:38:40 <Welkin> er
17:38:50 <Welkin> you can unify `a -> b` with `c -> (d -> e)` by saying that `a ~ c` and `b ~ (d -> e)`
17:39:22 <Welkin> the tilde ~ means that they are isomorphic, or that they are equivalent
17:39:33 <fishythefish> the tilde says they are equal, not isomorphic
17:40:00 <Welkin> I thought isomorphic things are equal
17:40:07 <fishythefish> isomorphism is weaker than equality
17:40:26 <crucify_me> let me try again:
17:40:42 <fishythefish> Welkin: newtype creates an isomorphic type, but not an equal one
17:41:10 <Welkin> okay, I think I see
17:42:20 <fishythefish> isomorphic types are types that encode the same data. equality is the thing the typechecker cares about
17:43:18 <fishythefish> we like to use isomorphism instead of equality when performing mathematical reasoning, since reasoning that applies to one type will apply to all types isomorphic to it
17:43:44 <fishythefish> we like to use equality in code, because we may want two types that can be reasoned about similarly to nevertheless be considered distinct data
17:44:24 <crucify_me> foldr (.) :: Foldable t => (a -> b) -> t (b -> b) -> a -> b      << after (a -> b) is unified with (a" -> a") (which is identity) its dropped so to speak, and the remainding types of t (b -> b) -> b -> b are what are left and are what make the function give a result, so they must agree with foldr (.) id
17:45:04 <fishythefish> crucify_me: to nitpick, a" -> a" isn't id, it's the type of id
17:45:11 <crucify_me> right ok
17:45:24 <Welkin> froall a. a -> a
17:45:25 <fishythefish> i'm not sure what you're saying is dropped, but the type t (b -> b) -> b -> b is the result of the unification
17:45:27 <Welkin> ;P
17:45:32 <Welkin> forall a. a -> a
17:45:33 <Welkin> haha
17:46:07 <fishythefish> Welkin: here in #haskell, i'm going to adopt the haskell convention that all type variables without an explicit quantifier are introduced by an implicit forall at the head :P
17:47:28 <crucify_me> right its the result, the unification of (a -> b) and ( a" -> a") affects the remainding elements in the type signature, so we end up with t (b -> b) -> b -> b  ,  right ?
17:48:07 <Welkin> `a` and `b` are both `a''`
17:48:13 <fishythefish> yes, or rather the unification generates a set of substitutions which we apply
17:48:21 <Welkin> but you can make a "new" `b`, sure
17:48:42 <Welkin> it makes it a bit more confusing though
17:48:46 <fishythefish> it's just alpha-equivalence to be consistent with the result of :t
17:48:48 <Welkin> especially with more complex types
17:49:00 <fishythefish> all the reasoning was done with the prime notation
17:49:01 <crucify_me> ok I get it then. one thing, the new "substitutions that we apply"  ...
17:49:25 <crucify_me> they look like identity itself if we use right association, right?
17:50:03 <fishythefish> huh? the substitutions are things like `a' ~ a''` and `b' ~ a''`
17:50:25 <fishythefish> there's no association, and id is just a function
17:50:39 <dminuoso> crucify_me: Dont take this the wrong way but.. so much for "I know how type unification works" :-P
17:51:06 <crucify_me> (b -> b) -> (b -> b)   << because this is what we have essentially
17:51:14 <fishythefish> crucify_me: where?
17:51:27 <fishythefish> that's very different from Foldable t => t (b -> b) -> b -> b
17:51:52 <fishythefish> (think of that as [b -> b] -> b -> b)
17:51:52 <crucify_me> ok
17:52:37 <crucify_me> dminuoso: there's only one way I can take it
17:53:37 <Welkin> crucify_me: suppository?
17:54:33 <crucify_me> :)
17:57:12 <crucify_me> fishythefish: actually that is very helpful  :   [b -> b] -> b -> b     I lost sight of the fact that its a list
17:57:31 <fishythefish> in the old version, yes. in the new version, it's generalized to any Foldable
17:58:07 <fishythefish> but Foldables can be made into lists
17:58:33 <crucify_me> fishythefish: thanks my friend, I pretty much get it. please critique this:
17:59:19 <crucify_me> the unification occurs in the first argument, of say in our case , (.)    correct?
17:59:56 <crucify_me> (a -> b)  >> (a" -> a")    ..  then ..
18:00:47 <fishythefish> hold on
18:00:51 <fishythefish> (.) isn't taking arguments here
18:01:03 <crucify_me> no I know
18:01:15 <fishythefish> to get the type of foldr (.), we unified the types of the first argument of foldr with the type of (.)
18:01:23 <fishythefish> we later unified the type of the first argument of foldr (.) with the type of id
18:02:00 <crucify_me> right, the first arg of foldr (.) is (a -> b)
18:02:26 <crucify_me> so once we do that then..
18:02:34 <Welkin> you should have started this exercise instead with (+)
18:03:36 <fishythefish> Welkin: we did that before, once
18:03:49 <Welkin> I thought that was with a different person
18:04:14 <crucify_me> :(
18:05:17 <Welkin> ChaiTRex: are you an indian dinosaur?
18:05:19 <fishythefish> crucify_me: again, nitpicking, the first arg of foldr (.) isn't (a -> b), but it has that type. it's a small thing, but building up the habit of keeping types and values separate is a good thing
18:05:24 <fishythefish> anyway, continue
18:05:38 <crucify_me> right understood thanks
18:05:54 <Welkin> this works better on paper or a chalkboard
18:06:14 <fishythefish> Welkin: it's all right, we'll print out the logs afterward ;)
18:07:51 <crucify_me> no, I do see how the final type was generated:  t ( b -> b) -> b -> b . that is the only type that foldr (.) id can utilize
18:08:27 <crucify_me> we just named the b's from all of the a" 's
18:08:32 <fishythefish> cool, hopefully this answers your original question from way back when
18:09:04 <crucify_me> the a" 's came from unifying with id 's type
18:09:24 <fishythefish> precisely
18:09:26 <crucify_me> really appreciate you fishythefish 
18:16:05 <Welkin> I imagine a cartoon fish teaching jesus about type unification while jesus is nailed to a cross
18:16:14 <Welkin> and the cartoon fish is wearing a top hat
18:24:53 * hackage morte 1.6.12 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.6.12 (GabrielGonzalez)
18:26:22 * hackage cabal-install 2.0.0.1 - The command-line interface for Cabal and Hackage.  https://hackage.haskell.org/package/cabal-install-2.0.0.1 (MikhailGlushenkov)
18:32:23 * hackage foldl 1.3.5 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.3.5 (GabrielGonzalez)
18:33:27 <GitBro> anyone here have experience with three-penny gui? I've written the logic of a game but I don't know how to transition to gui now
18:39:35 * hackage dhall 1.8.1 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.8.1 (GabrielGonzalez)
18:43:53 * hackage dhall-json 1.0.9 - Compile Dhall to JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.0.9 (GabrielGonzalez)
18:48:23 * hackage bench 1.0.7 - Command-line benchmark tool  https://hackage.haskell.org/package/bench-1.0.7 (GabrielGonzalez)
18:53:38 <Dra|n> nice host cobreadmonster heheehhe
18:54:45 <cobreadmonster> Dra|n: lol wut?
18:56:58 <Welkin> cobreadmonster: what happened to breadmonster? why the co?
18:57:10 <cobreadmonster> lol this is when I log in on irccloud
18:57:18 <cobreadmonster> as opposed to my PC.
18:57:38 <Welkin> and on your raspberry pi, you are piemonster?
18:59:06 <cobreadmonster> No.
19:00:14 <Dra|n> hehehe welkin
19:11:17 <koz_> I couldn't help but read Dra|n's name as 'Dee-arr-ey such that en'.
19:17:28 <aaa_> 诚念法轮大法好，洪福常伴百病消。
19:23:53 * hackage hspec-golden-aeson 0.3.1.0 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.3.1.0 (mchaver)
19:41:30 <Dra|n> ja0!
19:43:26 * JuanDaugherty saw it as like bra - ket; the chinese was falun gong something
19:44:33 <Dra|n> eeeeeeeeeeeeeeeeeeeeeeh?
19:53:11 <Guest43318> Hey guys, I am totally new here. Is anyone free to help me with a haskell homework assignment?
19:53:28 <Dra|n> go ask
19:53:31 <Dra|n> sure..
19:53:33 <boj> Guest43318: welcome. just ask your question
19:54:44 <Guest43318> Ok, I am trying to implement a fractional knapsack program for my class and just about got to the end when I get a supper confusing error when I load it.
19:55:18 <Guest43318> Is there a way to post code in here?
19:55:38 <burstXin> anyone here have experience with threepenny gui? I wrote the logic for a game but I'm trying to figure out how to print out my game board
19:55:50 <burstXin> Guest43318: Yea check out lpaste, and paste the link here
19:56:07 <erisco> burstXin, I have none. Care to post some code?
19:56:51 <burstXin> erisco: Sure gimme a sec
19:57:51 <alexknvl> Every type that implements `Eq` could have a `Hashable` instance, and arguably vice versa as well. In fact, types with `Eq a` or `Hashable a` are precisely those that have some `a -> [Word8]`...
19:59:25 <Guest43318> Ok this is the link to my code and the error I get when i go to load the file
19:59:28 <Guest43318> https://gist.github.com/anonymous/034b5dca2087d18e727874ca26d2d992
20:00:47 <burstXin> erisco: Here is part of my project: http://lpaste.net/5984173024369180672. I'm implementing 2048, but line 75 is where I'm trying to figure how to translate the whole board to a UI Element and attach css and html to it
20:00:53 <erisco> alexbiehl, how do you determine all types which implement Eq can implement Hashable?
20:01:07 <alexknvl> erisco: empirically
20:01:19 <alexknvl> erisco: are there any counterexamples?
20:01:22 <erisco> so… you mean "some types" ;)
20:01:45 <alexknvl> no, I mean "I think that all types ..."
20:01:55 <erisco> well that's even weaker
20:02:23 <erisco> I haven't looked at Hashable. not sure
20:02:36 <Guest43318> So what do you guys think?
20:03:12 <erisco> Guest43318, did you paste lab10.hs somewhere?
20:04:10 <erisco> burstXin, well what are you stuck on particularly when trying to do that?
20:04:29 <burstXin> printing the board out
20:04:30 <Guest43318> What do you mean?
20:04:56 <erisco> okay … I don't know what that means
20:05:24 <burstXin> I'm converting each maybe int / tile into a UI element , but I'm not getting output when I map it across the whole board
20:05:28 <erisco> you said you wanted to translate the board to a UI Element… is a board a Grid?
20:05:43 <burstXin> yea
20:05:48 <burstXin> its a list of Tiles
20:06:05 <erisco> okay how did you map it over the whole board? I don't see setupTile used anywhere
20:06:23 <burstXin> I'll paste the whole thing , one sec
20:06:35 * alexknvl erisco: all built-in instances compare bits to each other, hence every `==` is equivalent to mapping `a -> [Bool]` and then comparing those
20:06:39 <alexknvl> woops
20:06:43 <alexknvl> ctrl-enter
20:06:47 <erisco> Guest43318, the error follows you loading a file named "lab10.hs" … below you posted a file called "lab.hs" … are these the same?
20:07:06 <Guest43318> Yeah they are the same, I just short handed it
20:07:22 <erisco> alexbiehl, well that is probably untrue if hashing means what it should mean
20:07:38 <erisco> alexbiehl, hashes are not necessarily unique
20:07:48 <erisco> const 0  should be a valid hash for any type
20:08:15 <alexknvl> sure, not talking about hashes above though, just `[Bool]`
20:08:43 <erisco> with hashing, the necessary property is   x == y ⇒ hash x == hash y   but not the other way
20:09:12 <erisco> well… so where did Hashable go? I thought you were making a claim between Eq and Hashable
20:09:58 <alexknvl> more generically, `Eq a` is isomorphic (non-constructively) to some `a -> [Bool]`
20:10:00 <alexknvl> that's my claim
20:10:12 <alexknvl> being able to construct a `Hashable` instance trivially follows
20:11:47 <erisco> I don't know the name of the dual of vacuous truth
20:11:52 <alexknvl> so every `Eq a` has a unique `Hashable a` (assuming some default `[Bool] -> Int`)
20:12:09 <erisco> but saying a type which implements Eq can implement Hashable is just that, because all types can implement Hashable
20:12:41 <alexknvl> a `Hashable` that is uniquely determined by `Eq`
20:12:52 <erisco> what does that mean?
20:15:53 <alexknvl> okay, I stand corrected
20:16:19 <burstXin> erisco: So I'm trying to test my printing an initial grid http://lpaste.net/5984173024369180672 (line 72). But I'm getting an error: Couldn't match type ‘[]’ with ‘UI’       Expected type: UI [UI Element]         Actual type: [[UI Element]] 
20:17:02 <burstXin> My function call makes sense, I'm not sure why it expects everything inside setup to be UI input
20:19:17 <alexknvl> there is a bijection between instances of `Eq a` and `a -> [Bool]`, and given some `[Bool] -> Int` there is a lawful `Hashable a` instance
20:19:18 <erisco> Guest43318, you said inp has type [([Char],Double,Double)]. What type does inprev have?
20:20:37 <alexknvl> and, assuming some sort of "good" `[Bool] -> Int`, you automatically get a "good" `Hashable a`
20:20:38 <erisco> burstXin, does that compile? it looks like a type error on line 72 to me
20:21:01 <erisco> burstXin, sorry I am reading too fast. Yes, that is the error I expected
20:21:06 <burstXin> erisco: nope it doesn't. I don't understand the error, my function call seems correct to me.
20:21:16 <erisco> setupGrid :: [[UI Element]] but you need UI () according to the type of setup
20:22:06 <burstXin> erisco: lol... sorry for my cluelessness, I'm new to the language. Thanks!
20:22:45 <erisco> burstXin, I am not totally sure but I am guessing you want to apply  sequence . sequence
20:23:25 <erisco> or what you can do is say  setupRow :: [Tile] -> UI [Element]; setupRow r = mapM setupTile r  and similarly for setupGrid
20:23:42 <erisco> also  setupRow r = map setupTile r  eta reduces to  setupRow = map setupTile
20:25:29 <erisco> alexknvl, how do you construct the bijection? I am not sure how you get the function out of ==
20:25:58 <burstXin> erisco: Thanks! I'm trying that out
20:27:05 <erisco> in a procedural language you'd have two for-loops, and in the body of the innermost one you'd do some IO thingie like printDiv or whatever
20:28:28 <erisco> the way this works in Haskell, because we don't have such loops, is to transform the 2D list expression to a sequence of IO actions
20:28:44 <erisco> and a "sequence" here is delimited with bind, i.e. >>=
20:28:56 <erisco> which… you can vaguely think of like semicolons
20:29:41 <erisco> so it isn't good enough to have [[UI Element]] … this is just a list of lists of IO actions (essentially, because I imagine UI implements MonadIO, so it has IO capability)
20:30:07 <erisco> you need to turn the list of lists of IO actions into an IO action
20:30:21 <erisco> this is done by sequencing all the actions
20:30:31 <erisco> hence  sequence . sequence   (because we have two levels of lists)
20:30:50 <erisco> or we can use  mapM  in the first place which is a map and sequence in one
20:32:51 <burstXin> Yea that makes sense now. I know monad is a wrapper, kind of like a list right? 
20:33:01 <erisco> no
20:34:04 <erisco> the relation between Monad and [] is that [] has a Monad instance
20:34:32 <erisco> but we're not interested in that instance here
20:34:48 <erisco> we just care about UI
20:35:17 <burstXin> hmm ok
20:35:48 <erisco> Monad is a type class consisting of two functions and some laws … you can read on it in several books/tutorials
20:36:08 <burstXin> so Maybe a is a monad? Maybe is the box thing, a is the actual value inside
20:36:24 <erisco> 'Maybe' is a Monad, 'Maybe a' is not a Monad
20:36:34 <burstXin> oh ok
20:36:49 <erisco> all types which have a Monad instance have kind * -> *
20:37:27 <erisco> also, Nothing is no less a value than other values :)
20:37:57 <erisco> the purpose of Maybe, stated in a somewhat obtuse way, is to add one value to a type
20:38:09 <erisco> this extra value is often used to indicate failure of some sort
20:38:22 <erisco> so, in C you use -1, in Haskell you use Maybe
20:38:35 <alexknvl> erisco: order all values `x :: a`, obtaining a bijection `a -> Integer`
20:38:39 <alexknvl> `Eq a` bijectively maps to a table `(Integer, Integer) -> Bool`
20:38:43 <alexknvl> `(Integer, Integer) -> Bool` = `Integer -> Integer -> Bool` = `Integer -> [Bool]` = `a -> [Bool]`
20:38:49 <erisco> alexknvl, how did you order them?
20:40:12 <alexknvl> in some way. it's certainly possible for ADT
20:44:35 <alexknvl> it does not matter which way, let's just fix it, the whole thing is not very constructive anyway :) above I showed that cardinalities are the same (for countably infinite `a`; the case for `a -> Fin n` is similar)
20:46:41 <erisco> I agree with that. not sure what relevancy it has to Hashable though
20:47:42 <erisco> if you have some  f :: a -> Natural  this may aid you write a Hashable instance but there is still plenty of options as to how
20:47:44 <aberrant> hi all
20:47:58 <erisco> we have to go from an arbitrary precision number to a fixed width number
20:48:00 <alexknvl> well, intuitively, we can make a better `a -> [Bool]` by comparing `x :: a` to itself and collecting all calls to primitive `==` (defined on `Int`, `Word8`, etc) + all case expressions, then saving them to a bit list in any format... 
20:48:22 <aberrant> in ghci, is there a way to do a multiline paste? I'm trying to do both "infixl 5 :-:" and "a :-: b = a + b" but I keep getting "    The fixity signature for ‘:-:’ lacks an accompanying binding"
20:48:41 <erisco> in fact it may make a rather bad Hashable implementation for being slow
20:50:19 <erisco> aberrant, you can use semicolons in place of newlines, or you can use :{ to begin a multi-line entry and :} to end it
20:50:54 <erisco> ghci is sad when you begin multi-line mode and happy when you end it
20:50:54 <aberrant> erisco: thank you. I tried semicolons and got the same error
20:51:01 <aberrant> I will try :{
20:51:48 <burstXin> erisco: Just one last question, http://lpaste.net/5984173024369180672 , on my line 72 when trying to print my grid I get no output. I guess I'm missing something about making output in threepenny
20:52:11 <erisco> aberrant, interesting… I really thought that would have worked
20:54:52 <erisco> aberrant, oh I know… it is because operators beginning with : on the term level are constructors
20:55:07 <erisco> try something like  infixl 5 -:; a -: b = a + b
20:55:33 <aberrant> well, in any case, "(:-:) :: Int -> Int -> Int" doesn't seem to work
20:56:05 <aberrant> yours worked
20:56:14 <aberrant> I guess you don't need a signature.
20:56:35 <erisco> burstXin, that looks like a type error on line 71… it compiles?
20:57:00 <aberrant> so
20:57:08 <aberrant> "-:" works, but ":-:" doesn;t
20:57:10 <erisco> it should work fine if you don't use a constructor name
20:57:25 <aberrant> > infixl 5 :-:; a :-: b = a + b
20:57:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘infixl’
20:57:41 <erisco> lambdabot does not work in the same way
20:57:47 <aberrant> oh, right
20:57:51 <aberrant> but it doesn't work in any case
20:57:58 <erisco> no… reread what I said
20:57:58 <aberrant> compare that with infixl 5 -:; a -: b = a + b, which does work
20:58:43 <aberrant> oops! I missed your comment "aberrant, oh I know… it is because operators beginning with : on the term level are constructors"
20:58:53 <erisco> burstXin, also there is probably no worth to constructing [[Element]], so maybe use mapM_ instead which throws away the result
20:58:54 <aberrant> what's "term level"?
20:59:10 <burstXin> erisco: Yea it compiles, guess you're right. Thanks!
20:59:12 <erisco> term level is on the left of :: and type level is on the right
20:59:23 <aberrant> oh. LYAH uses this as an example
20:59:58 <aberrant> infixr 5 :-: ;   data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)  
21:00:04 <erisco> > return (Just 3) :: Maybe Int
21:00:07 <lambdabot>  error:
21:00:07 <lambdabot>      • Couldn't match type ‘Maybe Integer’ with ‘Int’
21:00:07 <lambdabot>        Expected type: Maybe Int
21:00:41 <erisco> yeah I don't get how that compiles burstXin… but if you say so… it should be complaining that () and UI [[Element]] do not match
21:01:06 <erisco> either way you definitely want to get rid of the return
21:01:28 <burstXin> i don't receive that error, otherwise my build would fail. yea i see
21:01:55 <erisco> ohh, I didn't see that you had  void $  stuck on the front… sneaky $…
21:03:06 <erisco> so, I know you do not know Monad yet, but something you can think of is Monad as an interface for effects
21:03:26 <erisco> return is an effect, and it is the do-nothing effect, for all Monads
21:03:47 <erisco> so, when you say  return $ setupGrid …  you're saying  "do nothing"
21:04:02 <erisco> but we want to be saying "output my elements"
21:04:09 <burstXin> oh 
21:05:08 <erisco> for  Monad m => m a   you can think of all the interesting stuff happening in 'm', and the 'a' is just along for the ride
21:05:30 <burstXin> m is like a box? ok
21:05:34 <aberrant> oh, I get this.
21:05:39 <aberrant> thanks, erisco
21:05:52 <erisco> so, when we have  UI [[Element]]  the [[Element]] is just along for the ride, it is not participating in any effects
21:06:08 <erisco> which is why I suggested using mapM_ instead which will discard this
21:06:27 <erisco> setupRow :: [Tile] -> UI (); setupRow = mapM_ setupTile  and similarly for setupGrid
21:06:55 <erisco> aberrant, np, have fun
21:09:53 <glguy> Tonight's adventofcode is up. Jump on the #haskell list if you're playing along at home: http://adventofcode.com/2017/leaderboard/private 43100-84040706
21:10:14 <erisco> glguy, can we place bets on the winners?
21:10:52 <erisco> site takes a rake… use it to fund more competitions… feeds itself into a massive gambling enterprise… probably illegal in most states!
21:12:25 <erisco> burstXin, "m is like a box" unfortunately has just about no explanatory power
21:12:26 <MarcelineVQ> glguy: do you have to have a login to see that link?
21:12:32 <glguy> MarcelineVQ: Possibly
21:12:45 <burstXin> erisco: Lol.. ok that just how I initially thought of it
21:13:02 <erisco> and what I have been telling you is not particularly strong either, but you need to read a detailed chapter on it to really understand
21:13:13 <burstXin> erisco: Thanks! yea
21:14:35 <burstXin> I'm still not getting output, but at least now I got the UI() returned instead of UI [Elements] with mapM_. 
21:14:46 <erisco> well, paste again and we'll look
21:15:07 <erisco> it is going to be tough to write monadic programs if you don't understand Monad
21:15:35 <erisco> glguy, I skimmed and read "spreadsheet" and so obviously comonads
21:15:39 <burstXin> http://lpaste.net/5984173024369180672
21:16:03 <erisco> do I win? is that the answer? :)
21:16:41 <erisco> how do you run the program, burstXin?
21:18:36 <burstXin> I'm using threepenny inside an electron window: https://github.com/barischrooneyj/threepenny-gui-electron-example. First I run: stack install --local-bin-path build, then to run the program: ./node_modules/.bin/electron electron.js 
21:19:31 <erisco> okay… haven't used that… but I am going to guess you need a main function somewhere
21:19:48 <burstXin> The examples work for me, yea i have it, main :: IO () main = do     hSetBuffering stdout LineBuffering     [port, otherArg1, otherArg2] <- getArgs     start (read port)
21:20:05 <burstXin> that's calling start on my lpaste
21:20:12 <erisco> okay but why do I not see main in the paste?
21:20:20 <burstXin> thats in a separate file
21:20:44 <burstXin> well it doesn't need to be but i'll add that in
21:21:29 <erisco> can you view the page source? is there no indication of output?
21:23:10 <erisco> burstXin, did you read the bit in the examples that says "To actually display the button, we have to attach it to the body of the HTML element. The #+ combinator allows you to nest elements quickly in the style of a HTML combinator library."?
21:24:03 <burstXin> erisco: Oh damn, didn't read that. Thanks!
21:26:42 <erisco> glguy, aw so you have to parse too? :P
21:35:15 <erisco> glguy, I think my program calculates the right answer but when I submit my program the site says it is wrong… am I supposed to read a file of a specific name? I am assuming stdin
21:35:42 <erisco> I've done a couple contests before and it has been a file of a particular name
21:36:23 <erisco> ohhh… I get it… lol
21:37:59 <erisco> I dunno lol… the answers are one line so I didn't think about it
21:38:08 <erisco> the programs are one line, I mean
21:57:04 * hackage thread-hierarchy 0.3.0.0 - Simple Haskel thread management in hierarchical manner  https://hackage.haskell.org/package/thread-hierarchy-0.3.0.0 (nshimaza)
22:23:23 * hackage myanimelist-export 0.2.0.0 - Export from MyAnimeList  https://hackage.haskell.org/package/myanimelist-export-0.2.0.0 (mat8913)
23:15:58 <jcarpenter2> does ghc have anything like gcc's -fmax-errors?
23:16:52 <cocreature> jcarpenter2: according to "ghc --show-options" -fmax-errors should work for ghc as well
23:17:43 <jcarpenter2> not on my ghc...
23:17:55 <cocreature> which version are you using?
23:18:02 <jcarpenter2> 8.0.2
23:18:08 <jcarpenter2> that is "stack ghc -- --version"
23:18:16 <cocreature> maybe it’s new in 8.2
23:18:33 <cocreature> yeah looks like it is
23:18:39 <jcarpenter2> i see
23:19:18 <jcarpenter2> how to upgrade my stack project...
23:19:28 <cocreature> change the resolver in your stack.yaml
23:19:48 <jcarpenter2> looks like 8.0.2 is the latest stable snapshot
23:20:12 <cocreature> right, you’ll have to use a nightly snapshot to get 8.2
23:20:43 <jcarpenter2> then "stack update" i guess
23:20:51 <jcarpenter2> just shotgan that command and it's doing something
23:21:18 <MarcelineVQ> stack update updates the hackage index
23:21:21 <jcarpenter2> nope, that's not it
23:21:51 <MarcelineVQ> you might have wanted  stack setup  if you're trying to get ghc changed
23:22:03 <jcarpenter2> yes, that appears to be it
23:22:12 <MarcelineVQ> usaully it's enough to just  stack build  or anothe project command after changing a resolver
23:22:41 <jcarpenter2> stack build just said "No compiler found blah blah"
23:23:35 <jcarpenter2> just improving my project
23:23:46 <jcarpenter2> utilizing ExceptT
23:24:15 <jcarpenter2> instead of IO (Either ErrorType a) all over the place
23:25:15 <jcarpenter2> what we need is a contest to get GHC to output the most errors for a program under 1KB
