00:05:22 <mniip> ah what a good day
00:05:23 <mniip> cabal install --reinstall semigroupoids free comonad tagged base-orphans unordered-containers hashable text --force-reinstalls contravariant StateVar stm mtl cabal-doctest transformers-compat prelude-extras
00:08:50 <mniip> Lokathor, weird
00:09:05 <mniip> apparently my solution suffers from the classical "eating too much RAM to even finish"
00:11:02 <mniip> if you're lazy you have to remember a lot of things...
00:15:35 <Lokathor> ha ha
00:15:41 <Lokathor> reality strikes again!
00:15:45 <Lokathor> :(
00:17:29 <kuribas> The title of a talk in our functional programming meetup: "How to constrain your function inputs without the overhead of types?"
00:19:13 <kuribas> Why "overhead"?
00:20:32 * Hafydd . o O (The type is written "overhead" the function implementation.)
00:20:43 <kuribas> lol
00:21:17 <kuribas> https://www.meetup.com/Leuven-Functional-Programming-Meetup/events/245436537/
00:21:36 <Hafydd> The author of the talk would best know, but it might be referring to the cognitive/organisational overhead of adding extra type machinery.
00:22:57 <kuribas> Perhaps I should make a talk "how a strong typesystem with type inference makes more robust programs, but gives the flexibility of dynamic languages".
00:23:45 <kuribas> Showing how type variables and type classes can stand for incomplete information.
00:23:55 <Hafydd> Or from the summary, it might be referring to the cognitive overhead of having types at all.
00:24:13 <Hafydd> Such as it is.
00:25:34 <geekosaur> could also mean use of singletons/proxies to pass around types as values
00:25:49 <geekosaur> to constrain other inputs or sth
00:27:54 <kuribas> geekosaur: yeah
00:28:06 <kuribas> perhaps I should go there, then present a haskell solution to their problem next time.
01:02:30 <d-fish> whoa what's going on?
01:03:18 <geekosaur> that's just the usual roughly-daily disconnect/reconnect of matrix.org
01:04:23 <d-fish> fancy
01:23:13 <wedify> ok i've update haskanoids to use recent sdl2 libraries. it compiles but i cannot figure out why the screen won't draw. on the off-chance someone wants to help you can find the source at github.com/drull95/haskanoids2. i'm going to go to bed soon and work on it tomorrow
01:32:22 * hackage LambdaHack 0.7.0.0 - A game engine library for roguelike dungeon crawlers  https://hackage.haskell.org/package/LambdaHack-0.7.0.0 (MikolajKonarski)
01:33:53 * hackage Allure 0.7.0.0 - Near-future Sci-Fi roguelike and tactical squad game  https://hackage.haskell.org/package/Allure-0.7.0.0 (MikolajKonarski)
01:39:58 <wedify> another problem i'm having is 'stack install sdl2-mixer' failing. i've tried building the git repo and it works. i installed in with 'cabal install' and then added it to my extra-deps field in stack.yaml. but i get 'Didn't see sdl2-mixer-1.0.0 in your package indices'
01:40:05 <wedify> am i going about this in the right way?
01:46:21 <fakenullie> wedify: have you added it to .cabal?
01:54:57 <cocreature> wedify: 1. "cabal install" is not the right way to install packages for stack; 2. the error message you are seeing is because sdl2-mixer-1.0.0 is not on hackage; 3. you can point stack directly to the git repo, see https://docs.haskellstack.org/en/stable/yaml_configuration/#git-and-mercurial-repos
01:59:25 <Qnetgurd> I learned some haskell, now can I apply for jobs in other programming languages? 
02:01:03 <cocreature> sure, whether you’ll get accepted is a different question :)
02:01:35 <fakenullie> I think you have to all haskell for start
02:01:55 <fakenullie> s/all/whole/
02:02:19 <kuribas> fakenullie: still doesn't make sense
02:02:37 <kuribas> Qnetgurd: unlikely
02:02:46 <fakenullie> well, you can apply for internship then
02:02:57 <Qnetgurd> cocreature:  I have seen a clojure job they mentioned haskell in keywords but  I am not sure if I can apply or not
02:03:14 <Qnetgurd> kuribas:  unlikely 
02:03:57 <cocreature> Qnetgurd: that seems like a question that can only be answered by the person who made the job ad
02:03:57 <kuribas> Qnetgurd: knowing haskell will help you in better structuring programs in other languages.  You still have to learn those languages though.
02:05:26 <cocreature> not everybody expects that you know the language that you’ll be using in the job
02:07:05 <fakenullie> well, that's true for perl
02:07:28 <fakenullie> but it's somewhat easier to learn
02:08:38 <Taneb> One of my coworkers (at a Haskell company) had never used Haskell when he applied (and got accepted) for his job
02:08:48 <Taneb> On the other hand, he had some transferable experience from F#
02:09:16 <kuribas> knowing some other functional language makes learning haskell easier.
02:09:39 <cocreature> yeah you are usually expected to have experience with something similar but knowing the exact language you’ll be using is often not a hard requirement
02:09:55 <kuribas> I wonder if I could get a C# job...
02:10:18 <kuribas> knowing haskell and C++ (among others)
02:10:53 <Taneb> kuribas, there's only one way to find out! (submit an application to a C# job)
02:10:59 <Qnetgurd> I was disconnected
02:11:44 <fakenullie> it's hard to know modern c++
02:12:06 <kuribas> fakenullie: yeah, I am far from an expert.
02:12:25 <kuribas> Qnetgurd: I would at least learn some other concepts like databases, low-level programming, GUIs, etc...
02:13:43 <Qnetgurd> i know databases/apis etc which low level programming you suggest 
02:16:19 <wedify> cocreature: thanks
02:16:47 <Qnetgurd> I think c++ is king of programming languages 
02:17:00 <kuribas> Qnetgurd: understanding how to optimse things, cache locality, etc...
02:17:09 <cocreature> king of madness
02:17:23 <fakenullie> kuribas: I doubt that's required for most jobs
02:17:37 <kuribas> fakenullie: your probably right
02:18:23 <kuribas> fakenullie: then you get people like my coworkers who have no understanding of performance, and spend a year to optimize a python app.
02:18:33 <fakenullie> kuribas: yeah, that's just sad
02:18:57 <Franciman> Hi. Is it possible to have a value depend from a configuration value provided during configuration phase with cabal?
02:18:59 <Qnetgurd> python vs c vs c++ which is better for jobs 
02:19:23 <Franciman> e.g. I have apiKey value and I want that its value be provided by the user who is going to compile the program
02:19:37 <fakenullie> sounds like it's better as runtime configuration
02:19:37 <kuribas> Qnetgurd: ask yourself a better question, which one would I like to program more.
02:19:51 <Qnetgurd> kuribas:  I dont know
02:19:57 <kuribas> Qnetgurd: if you like haskell, I advice against a python job.
02:19:58 <fakenullie> yeah, yourself liking the job is much more important
02:20:19 <Qnetgurd> kuribas:  why but I find many similar haskell concepts in python
02:20:38 <kuribas> Qnetgurd: sure, but that doesn't mean your team is open to it...
02:21:16 <kuribas> Qnetgurd: otherwise, check this out: https://github.com/lihaoyi/macropy
02:21:17 * JuanDaugherty just hates the idea of a) a third major lisp but above all the gross ugliness of a new dialect on the jvm
02:21:24 <Qnetgurd> kuribas:  I like haskell then what should I go with
02:22:26 <kuribas> Qnetgurd: if you like to get your hands dirty with low level programming, possibly embedded, then C/C++
02:23:01 <kuribas> Qnetgurd: C# and scala are more haskell like (than C/python)
02:23:13 <Qnetgurd> rust also if I heard
02:24:12 <kuribas> yes
02:24:35 <kuribas> Qnetgurd: try some language tutorials, and see which one you like best.
02:25:25 <Qnetgurd> kuribas:  Hmmmm but I never thought Python will be anti haskell
02:26:02 <fakenullie> for me for some reason python feels too low level after haskell
02:26:04 <Qnetgurd> kuribas:  but many python programmers easily adjust with haskell isnt it 
02:26:17 <kuribas> Qnetgurd: for example, control flow using exceptions is accepted practice in python (and only in python).
02:26:52 <kuribas> Qnetgurd: and they'll write this "if lst: ...", instead of "if len(lst)>0: ..."
02:27:15 <kuribas> also True + True == 2
02:27:30 <fakenullie> that's frowned upon
02:27:52 <kuribas> fakenullie: yes, but they still defend that True is a number
02:28:05 <kuribas> rather than a historical accident.
02:29:20 <Qnetgurd> kuribas:  but for learning its ok right because i see you know python alo
02:29:40 <kuribas> Qnetgurd: I have a python programming job, but I want to change
02:30:23 <Qnetgurd> kuribas:  change to ?
02:30:34 <kuribas> another job with another language
02:30:47 <Qnetgurd> which language ?
02:31:04 <kuribas> I dunno, but not python/perl/ruby
02:31:34 <Qnetgurd> ok so you are some devop/linux admin etc if I guess correct
02:32:05 <kuribas> nah, a full application
02:32:13 <kuribas> for sysadmin perl/python/ruby is fine
02:41:53 * hackage airship 0.9.2 - A Webmachine-inspired HTTP library  https://hackage.haskell.org/package/airship-0.9.2 (lambda_foo)
02:59:36 <dkov> I have a problem with stack haddock and quasiquoters: https://pastebin.com/nRDnKrRq
03:04:32 <cocreature> dkov: https://github.com/haskell/haddock/issues/158#issuecomment-300024004 seems relevant
03:12:08 <dkov> cocreature: thanks. enabling TemplateHaskell in the quasiquoter module helped
03:24:24 * hackage potoki-core 1.2 - Low-level components of "potoki"  https://hackage.haskell.org/package/potoki-core-1.2 (NikitaVolkov)
03:25:33 * hackage potoki 0.6.1 - Simple streaming in IO  https://hackage.haskell.org/package/potoki-0.6.1 (NikitaVolkov)
03:26:24 * hackage potoki-cereal 0.1 - Streaming serialization  https://hackage.haskell.org/package/potoki-cereal-0.1 (NikitaVolkov)
03:41:40 <mdupont> anyone from ghcjs?
04:12:28 <coodoo88> anyone feels like having a code review on my first haskell work here? https://gist.github.com/coodoo/446df9750a2dc9a7cea2bffa70671c67
04:12:51 <coodoo88> would appreciate any suggestions, correction, or even better ways to do it :)
04:12:56 <coodoo88> thanks!
04:21:46 <Taneb> coodoo88, why have you imported Control.Monad.State twice?
04:32:27 <ph88> how can i traverse tuple elements ?
04:33:41 <ph88> coodoo88, in ghci type   :set -Wall   and you can get some basic advice on your code
04:34:17 <dibblego> > (1,2) & both %~ (+30)
04:34:19 <lambdabot>  (31,32)
04:34:33 <ph88> is that lens ?
04:34:52 <ph88> > (1,2,3) & both %~ (+30)
04:34:54 <lambdabot>  (1,32,33)
04:35:00 <dibblego> Yes.
04:35:07 <ph88> it missed an element when i add one
04:35:20 <dibblego> both does both
04:35:44 <ph88> wait i'm gonna ask another question first
04:36:13 <ph88> can i make a list of things where the type have a different type level literal ?
04:39:53 * hackage rails-session 0.1.2.0 - Decrypt Ruby on Rails sessions in Haskell  https://hackage.haskell.org/package/rails-session-0.1.2.0 (filib)
04:43:43 <blasen> both does both of all 3 elements
04:56:49 <[exa]> ph88: https://wiki.haskell.org/Existential_type#A_short_example  <- heterogenous list that could work for your case (but IMHO it's not worth it :] )
04:57:21 <ph88> ye i don't think so either :|
04:57:43 <ph88> i have a stream of bits and i want to fill my generic type
04:58:52 <[exa]> sounds parser-ish
05:01:56 <ph88> yes it is :P
05:14:59 <mrkgnao> @unmtl ContT State
05:14:59 <lambdabot> Plugin `unmtl' failed with: `ContT State' is not applied to enough arguments, giving `/\A B. (B -> A State) -> A State'
05:19:24 <mrkgnao> @unmtl ContT (State s) a
05:19:24 <lambdabot> Plugin `unmtl' failed with: `ContT (State s) a' is not applied to enough arguments, giving `/\A. (A -> a (State s)) -> a (State s)'
05:19:38 <mrkgnao> @unmtl StateT IO a
05:19:38 <lambdabot> Plugin `unmtl' failed with: `StateT IO a' is not applied to enough arguments, giving `/\A. IO -> a (A, IO)'
05:20:43 <fakenullie> @unmtl StateT IO A
05:20:44 <lambdabot> Plugin `unmtl' failed with: `StateT IO A' is not applied to enough arguments, giving `/\A. IO -> A (A, IO)'
05:21:15 <mrkgnao> I was just testing out a new IRC client 
05:21:20 <mrkgnao> :)
05:49:45 <ph88> how do parsers like megaparsec handle data that is coming in in chunks? What if the parsing rule needs more data for it to complete? i don't understand how this is handled on the lower level
05:52:05 <geekosaur> they don't, mostly. that's more attoparsec's bailiwick
05:52:40 <geekosaur> to the extent that they do handle it, it's by relying on the input stream being lazy
05:53:23 <mrkgnao> geekosaur: how does pipes-parse fit into this, if at all?
05:55:47 <geekosaur> by 'translating' its implementation of a lazy stream into the kind that parsec/megaparsec can deal with (where the input stream itself is lazy, such as lazy Text being a lazy list of chunks)
05:56:49 <geekosaur> one form of that is using unsafeInterleaveIO to make a lazy String from a Handle; but pipes is a more principled way of doing that kind of thing
05:56:54 <mrkgnao> ah.
05:56:59 <mrkgnao> strict chunks?
05:57:02 <geekosaur> yes
05:57:59 <geekosaur> but since it uses a lazy stream type internally, it needs an adapter to allow parsec etc. to pull lazily from its stream. this adapter is what pipes-parse provides
05:58:47 <geekosaur> the low level stuff in parsec just abstracts the original lazy list to be a lazy whatever-the-caller-gives-it --- and requires the caller to provide the adapter. for lazy lists this adapter is basically id
06:00:30 <geekosaur> pipes-parse puts a Producer as the source and provides parsec with the mechanisms to get stuff from the Producer as it becomes available
06:01:16 <geekosaur> however, this has a shortcoming: from the standpoint of Parsec, it's still all-or-nothing. attoparsec, by putting the streaming abstraction inside the parser, allows for partial parses, restartable parses, etc.
06:04:39 <geekosaur> (however the streaming source needs to behave the way attoparsec expects it to. attoparsec used to only work with ByteString; these days it also handles Text. it may need to be modified to support other sources in the future)
06:06:06 <geekosaur> (I think it also needed work to support conduit and pipes, as those evolved?)
06:06:20 <ph88> how does it know if has buffered enough to complete the rule ?
06:06:30 <geekosaur> it doesn't
06:06:41 <geekosaur> again, it's relying on laziness.
06:06:44 <pja> My experience with using AttoParsec for AdventOfCode has been a bit painful to be honest. The Text and ByteString versions implement /different/ sets of utility parsers for a start.
06:06:52 <pja> Probably should have just used MegaParsec from the off.
06:07:23 <geekosaur> if the data's not available, it "suspends" until the input stream provides more data, because that's how laziness works in Haskell
06:07:45 <ph88> how does the suspend work ?
06:07:53 <geekosaur> "how does laziness work?"
06:08:10 <geekosaur> how does lines know to wait for more input?
06:08:47 <geekosaur> if the questuion you are trying to ask is "how do I get control of this", the answer is "you don't".
06:09:00 <geekosaur> that is part of what I meant by "all-or-nothing"
06:09:37 <geekosaur> this is the key difference between parsec/megaparsec and attoparsec
06:09:49 <geekosaur> if you need that control, use attoparsec
06:09:54 <ph88> i was looking into making a generic parser for hardware, i have all the control there, but i just didn't know if i can make it work with nice parser combinators
06:11:32 <ph88> i don't want to use a buffer, instead i want to write the chunks into the result memory and when completed i want to give a signal that everything is fine and the next part of the design can start using the result
06:12:40 <ph88> it's a different way of thinking so i don't know if it's possible with combinator parsers
06:13:47 <geekosaur> with parsec I think you want a separate parser for each stage and each parser is pass/fail. once you get pass from a parser, you know it is complete and can forward the reuslt on
06:14:13 <geekosaur> I *think* you end up doing this as well with attoparsec, because this isn't the way its streaming abstraction works
06:15:19 <geekosaur> attoparsec's abstraction is kinda designed for networks, and networks protocols where the data part may be interleaved with a control part (or data parts for other streams)
06:16:15 <ph88> ye i'm also using this for network protocols
06:16:30 <geekosaur> (think ssh, where you have one ssh connection that can have a terminal session stream plus forwarded connections with -L/-R, plus with ControlMaster you can also multiplex other terminal sessions or scp-s or) etc.
06:17:08 <ph88> i would to have nice interleaving of data and control as you described, but i only have hardware primitives and no concept of lazyness
06:17:17 <geekosaur> so when you get a chunk from the network you need to determine from its framing which stream it belongs to, and with attoparsec you can then call the parse continuation for the appropriate stream
06:18:04 <geekosaur> ..ior if it's a control frame you may invoke a new attoparsec parser to handle that frame. also the thing deciperhing the framing itself can be an attoparsec parser doing subparses
06:19:06 <geekosaur> also from your comments I think you are now thoroughly confused. so just go with ,my earlier answer of separate parsers that produce a result once they have parsed a complete chunk
06:19:15 <geekosaur> and parsec/megaparsec
06:19:50 <ph88> i'm doing hardware at the moment
06:21:02 <geekosaur> I have to think you mean that in some sense I am not aware of, or you have omitted context
06:21:21 <geekosaur> (also I would be asleep right now if I weren't haveing coughing fits...)
06:21:51 <geekosaur> are you writing something VHDL/SPICE/etc. ish?
06:22:07 <ph88> i'm trying clash
06:22:09 <geekosaur> because when I said network I did not mean what it means in those
06:22:10 <ph88> work in progress ..  https://bpaste.net/show/9546f860eb52
06:22:14 <geekosaur> I meant sockets
06:22:46 <geekosaur> ... sockets probably means something else in those also, doesn't it
06:23:19 <ph88> eh dunno, i just know sockets in the software way
06:23:41 <geekosaur> yet when I said network you apparently assumed I meant connections between hardware?
06:23:44 <ph88> i have a functional language, i have hardware, i need nice parser combinator abstractions over generic-sized bus size. Can i have the cake and eat it too ?
06:23:52 <geekosaur> as described in your language?
06:24:06 <geekosaur> sigh.
06:24:13 <ph88> i thought when you said network protocols you were talking about the protocols
06:24:26 <ph88> not the connections between hardware
06:24:39 <ph88> like ethernet frame, or tcp/ip headers
06:24:54 <geekosaur> I am not capable of climbing into your head and figuring out what you mean. great "you have hardware". you can 't stuff an actual ARM chip into a lazy list.
06:24:59 <geekosaur> one of us is on the wrong page
06:25:13 <ph88> no worries :x
06:25:47 <ph88> maybe try to get some sleep
06:25:51 <ph88> i'm going for a run
06:38:53 * hackage bbdb 0.6 - Ability to read, write, and modify BBDB files  https://hackage.haskell.org/package/bbdb-0.6 (HenryLaxen)
06:39:22 <gesindel> ravacauliculus
06:52:11 <geekosaur> so now I know a bit more about the question. not enough still, my entire experience with verilog was installing it and making sure it started up.
06:52:19 <geekosaur> I still don't speak its language
06:52:22 <guy> Hey all, does the placement of a recursive call affect performance?  (main function declaration vs a where block) --> http://lpaste.net/360629
06:53:31 <geekosaur> guy, more significant is how the call is made
06:53:42 <srk> ph88: I'm trying to figure this parsing on embedded hardware as well, wrote few basic utilities for ivory but it's nowhere near parsec - was able to put together driver with only line splitting and isPrefixOf https://github.com/distrap/ivory-tower-drivers/blob/master/src/Ivory/Tower/Drivers/Net/RN2483.hs#L97
06:54:25 <geekosaur> it's often beneficial to factor any parametrs that don't change between recursive calls out, by making an internal recursive function that can obtain the values from outer scope instead
06:54:48 <srk> think I need to go thru write your own parser from scratch exercise first
06:55:00 <geekosaur> "calls" do not work the same way in haskell as in other languages; most things you'd worry about (like tail calls) don't apply here
06:55:45 <fakenullie> geekosaur: is it really beneficial?
06:56:03 <fakenullie> I thought that compiler would somehow optimize those away
06:56:19 <fakenullie> unchanging parameters that is
06:58:02 <geekosaur> the only way it can optimize those away, if the compiler cannot determine that it is looking at all the uses that will ever exist, is to do the worker/wrapper transform (which is what I described)
06:58:24 <srk> http://dev.stephendiehl.com/fun/002_parsers.html lovely
06:58:27 <geekosaur> I don't think ghc does that one still, because there are complications
07:00:04 <geekosaur> ok, looks like it does in at least some cases. I must assume not enough as manual worker/wrapper still is often recommended
07:00:53 <guy> Cool.  Good to know, @geekosaur.  I'll look into that transform.  Thanks!
07:02:24 * hackage sparkle 0.7 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.7 (MathieuBoespflug)
07:22:32 <alanz> For anyone wanting to bikeshed, we have a HIE logo poll going at http://www.anonvote.com/poll/dr587990y
07:24:18 <Average-user> I can't win the one it is winning pls
07:40:59 <dminuoso> So, if I have some function `writer :: (Monoid w, Monad m) => (a, w) -> m a` that Im trying to implement, but no matter how long I stare at this, Im not sure what this does.
07:42:21 <dminuoso> This is the WriterT implementation that I have already: https://gist.github.com/dminuoso/8ad310b4b97abb73c80ffd879f20e650
07:43:51 <int-e> dminuoso: I don't think that type is correct; the m should be the WriterT you're defining...
07:44:07 * hackage rebase 1.2.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.2.2 (NikitaVolkov)
07:44:24 <dminuoso> int-e: blergh, the type came from mtl. Im guessing they do some really weird shenanigans?
07:44:31 <Yotam> How can I use the bot to simplfy an expression?
07:44:45 <int-e> dminuoso: and if you try to implement writer :: (Monoid w, Monad m) => (a,w) -> WriterT w m a, you shouldn't have any trouble; it's basically return.
07:44:56 <dminuoso> int-e: No spoiling! :-P
07:45:00 <int-e> dminuoso: no you're just confused about what m is.
07:45:26 <dminuoso> int-e: well it cant be just return, because there's also a `w` in there.
07:45:29 <int-e> dminuoso: because there are two monads of relevance here, namely m and WriterT w m.
07:45:48 <dminuoso> int-e: Ah okay, That signature makes a lot more sense.
07:46:23 * hackage rerebase 1.2.1 - Reexports from "base" with a bunch of other standard libraries  https://hackage.haskell.org/package/rerebase-1.2.1 (NikitaVolkov)
07:47:06 <dminuoso> Okay so its just writer (a, w) = WriterT $ pure (a, w)
07:47:22 <dminuoso> Ah wrong monad, I see.
07:51:12 <dminuoso> int-e: Im not sure I follow completely though: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html whats with those types? How do they make sense?
07:51:14 <infinisil> Are you serious, why do i get a segfault
08:13:07 <cocreature> infinisil: you are going to need to provide more information if you’d like help debugging that
08:33:31 <int-e> dminuoso: well, which type doesn't make sense to you?
08:34:34 <dminuoso> int-e: They all dont. Switched to `transformers` and they seem easily readable to me.
08:35:11 <dminuoso> `listens :: Monad m => (w -> b) -> WriterT w m a -> WriterT w m (a, b)` this I can make sense of
08:35:46 <dminuoso> `listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)` this not so much. I mean what is `MonadWriter` ? How does this fit into transformers?
08:41:58 <int-e> dminuoso: Well it's a typeclass, class (Monoid w, Monad m) => MonadWriter w m | m -> w [...]. One slightly unusual thing here is the functional dependency m -> w, meaning that it must be possible to infer w from m for all instances (for example, you can read off w from WriterT w m a). The class operations all have MonadWriter w m => as its context; because of the superclasses of MonadWriter, w...
08:42:04 <int-e> ...must be a monoid and m a monad. In any case, there's an instance  (Monoid w, Monad m') => MonadWriter (WriterT w m), for which `listens` has type (Monoid w, Monad m) => (w -> b) -> WriterT w m a -> WriterT w m (a, b)
08:42:10 <cocreature> dminuoso: MonadWriter is a typeclass that abstracts over the operations that WriterT provides. e.g. let’s say you are working in a monad transformer "ReaderT r (WriterT w m)". since WriterT is in your stack, wanting to use the operations that it provides is perfectly reasonable. but it’s “hidden” behind ReaderT so operations that work on WriterT won’t work on that directly. you could manually use
08:42:12 <cocreature> "lift" to fix that but it’s not hard to see how that can quickly get annoying. if the operations you want to use are written in terms of MonadWriter rather than on WriterT directly, it will just work
08:43:19 <d-fish> What does MonadWriter do if you have something ridiculous like WriterT w (ReaderT r (writerT wm))?
08:44:07 <int-e> d-fish: ot
08:44:14 <cocreature> d-fish: it will choose the outer-most layer
08:44:14 <ph88> hi srk , do you want to collaborate on making a generic parser for clash ?
08:44:17 <int-e> err, it'll work on the outermost WriterT
08:47:30 <ph88> how do parser combinators in strict languages wait for input ?
08:48:09 <int-e> d-fish: there's actually no mystery there at all; WriterT comes with a MonadWriter instance that does something useful; ReaderT has one that lifts an existing MonadWriter from the inner monad; there is no MonadWriter instance for WriterT that lifts an inner MonadWriter instance.
08:49:14 <osa1> ph88: return "NeedMoreInput" after updating the parser state; provide a feed() method for resuming parsing
08:49:59 <ph88> osa1, can you point to some code ?
08:50:08 <ph88> srk, what is "ivory tower" ?
08:50:20 <osa1> ph88: attoparsec does something similar IIRC
08:51:55 <ph88> ye geek osaur was saying something similar about attoparsec
08:52:25 <rightfold> Ivory tower is the place you want to be
08:52:28 <ph88> lol
08:53:58 <ph88> but for the embedded (fpga) space i want/need it the other way around .. instead of "i need more input" you just assume that there is always input and you want to signal "i had enough input" .. but i'm not sure if it's still possible to make nice parser combinators and mix it with control flow as well
08:54:30 <iqubic> Is it possible to have multiple files, all with their own main functions in a single stack project?
08:54:31 <glguy> Tower is a concurrency framework for the Ivory language.
08:55:31 <cocreature> iqubic: yes, you can have multiple executable-sections in your cabal file
08:55:54 <ph88> ah ok
08:56:00 <iqubic> I want to do Advent of Code in Haskell, but I dont want to make a seperate stack project for each day. I want to put all 25 days in the same stack project each with a main function.
08:56:21 <glguy> iqubic: https://github.com/glguy/advent2017/blob/master/advent2017.cabal
08:57:50 <iqubic> And if I use a set-up like that, will emacs Intero mode recognize it properly?
08:58:04 <pja> iqubic: mstksg on github (jle here on #haskell) has something like that.
08:58:13 <glguy> iqubic: If you're doing it in Haskell, you might join the #haskell group: http://adventofcode.com/2017/leaderboard/private 43100-84040706
08:58:24 <glguy> iqubic: I don't know; I don't use intero.
08:58:29 <pja> NB. Is Intero broken with ghc 8.2? I couldn't get it to work at all on my install.
08:58:49 <pja> Although possibly I should have let stack install it’s own ghc from scratch...
08:59:22 <cocreature> pja: it’s broken with 8.2.2, it works with 8.2.1 afaik
08:59:52 <cocreature> although “broken” only means that the upper-bound is unnecessarily restrictive and nobody has made a release with a relaxed upper bound
09:02:42 <iqubic> Is there a way to ask stack to use a version of GHC compatible with Intero?
09:06:11 <mud> iqubic: Doesn't it go the other way around, intero uses stack? So wouldn't you specify in the stack.yaml what resolver (and thus what GHC) will work?
09:06:30 <dminuoso> cocreature: Okay its not obvious how that would work, perhaps Ill look at this once Ive completed my journey to implement as many monad transformers as possible, and implement my own typeclasses.
09:07:13 <cocreature> dminuoso: just stick to manual "lift" for a while and once you’ll have felt the pain, you’ll understand why it’s nice to use the typeclasses provided by mtl :)
09:07:33 <dminuoso> cocreature: I think I understand the point, just not how it works out. :)
09:08:32 <cocreature> dminuoso: there is not much too it, you just let GHC insert the appropriate "lift"s based on how it resolves the instance. e.g. here’s the instance for ReaderT that would be used in the example I gave above https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control.Monad.Writer.Class.html#line-157
09:15:28 <dminuoso> cocreature: Ah. Well the typeclass definition looked strange to me `class (Monoid w, Monad m) => MonadWriter w m | m -> w where` with that | inside there. So I wasn't sure whether to keep reading
09:15:54 <cocreature> dminuoso: that’s a functional dependency. it means that w is uniquely determined by m
09:16:05 <cocreature> so given the monad you know what you can “write”
09:17:17 <fakenullie> why does it need monoid?
09:18:13 <dminuoso> fakenullie: The simplest notion of "writing" is just appending onto a list. So monoid gives you more freedom about what or "how" you "write" onto
09:18:40 <fakenullie> oh
09:19:31 <frerich> glguy: Was your parseGarbage definition ( https://github.com/glguy/advent2017/blob/master/execs/Day09.hs#L63 ) the first version, even before you read part 2 and knew that you need to know the length of the garbage? I'm currently comparing different solutions for the !-escaping issue.
09:20:16 <frerich> glguy: My version ( https://github.com/frerich/aoc2017/blob/master/9.hs#L6 ) uses a custom parser which yields a Maybe Char (Nothing for escaped characters) and passes that to manyTill. That was before I learned that I only need the length of the garbage (and it required using catMaybes). :-/
09:22:23 <glguy> frerich: My first version only computed the group scores
09:22:40 <glguy> frerich: My second version only computed the garbage length, and then afterward I merged the two to compute both
09:23:57 <frerich> glguy: Ok, but to compute the group score, you at least need to be able to skip the garbage parts, right? How did you handle escaped characters there (which you would need to do to figure out when the garbage ends)?
09:24:24 <glguy> frerich: The parser was the same, I just returned a () instead
09:24:40 <glguy> and then in parseGroup I returned a Just of the group score or a Nothing
09:24:46 <glguy> and used catMaybes on the outside before summing
09:25:15 <glguy> Just <$> parseGroup (n+1) <|> Nothing <$ parseGarbage
09:27:03 <Average-user> I just did a simple recursion to forget about '!' and chars in front of it.
09:28:12 <glguy> Yeah, that seemed like a good idea to me afterward. It means that you'l accept more inputs than you should, but that's fine for being able to solve the given input
09:29:23 * hackage diagrams-rubiks-cube 0.3.0.0 - Library for drawing the Rubik's Cube.  https://hackage.haskell.org/package/diagrams-rubiks-cube-0.3.0.0 (TimBaumann)
09:29:30 * frerich Average-user: I considered that, too - but I was hellbent on using "??? `manyTill` char '>'" :-)
09:30:09 <frerich> Average-user: 'between' would have been even nicer, but I couldn't seem to make that work.
09:30:21 <cocreature> I used between
09:30:32 <glguy> frerich: Did you remember to exclude '>' from the parser inside the between?
09:31:27 <frerich> glguy: Probably not, I cannot remember. I tried a couple of things and eventually resorted to something which a) is understood by me and b) works. :-]
09:31:29 <srk> ph88: https://wiki.base48.cz/EmbeddedHaskell
09:31:44 <cocreature> frerich: that was my solution with between http://lpaste.net/360621
09:31:51 <glguy> frerich: You can see the avoidance of > here: https://github.com/glguy/advent2017/blob/master/execs/Day09.hs#L67
09:32:15 <mud> http://adventofcode.com/2017/day/9 that's actually a half-way decent parsing question, nice.
09:33:06 <Average-user> frerich: I didn't feel like complicating myself that much, and part A and B together takes 0.058 seconds, so  it is not slow
09:33:24 <Average-user> 0.038seconds* (typo)
09:34:09 <frerich> Average-user: I see; I set myself the goal to do all parsing with parsec for the sake of getting to know it a bit better. :-)
09:34:52 <Average-user> ferich: I might want to learn parsec, but I was using prolog, maybe parsec is also a thing in it? I don't know
09:36:25 <glguy> you can start to worry about performance when they start giving us graph search problems
09:37:08 <frerich> cocreature: That's really nice IMHO, it's basically what I tried to do but failed to. I think using lefts and rights to 'filter out' the escaped stuff is interesting, that didn't occur to me at all!
09:37:09 <Average-user> graph searches are perfect for Prolog tough 
09:37:20 <mud> It seems like your performance would have to be quite impressively terrible for it to hurt your score on these types of problems. Speed of writing should be a lot more important.
09:37:29 <mud> That' assuming you're going for score I guess, but whatever.
09:37:36 <Average-user> I'm not
09:37:42 <Average-user> but glguy probably is
09:37:43 <cocreature> frerich: tbh I didn’t worry about making it pretty or anything. this was the first solution I came up with and I just left it at that :)
09:37:52 * hackage streaming 0.2.0.0 - an elementary streaming prelude and general stream type.  https://hackage.haskell.org/package/streaming-0.2.0.0 (andrewthad)
09:38:16 <glguy> I'm trying to do then fast at first but then cleaning then up to serve as good examples
09:38:29 <mud> That sounds like probably the most interesting way to go.
09:39:08 <cocreature> I was faster than glguy for one day so I’ve achieved more than I was planning to ;)
09:40:18 <frerich> I'm not really a competitive person, but I enjoy the 'discussing & comparing solutions' part and the resulting knowledge transfer. :-)
09:40:58 <cocreature> yeah, I probably wouldn’t have bothered doing any exercises if I didn’t see the discussions here
09:41:01 <glguy> yeah, I think these problems are great ways to teach people about new (to them) bits of haskell
09:41:22 <mud> I shall have to look at the next few problems coming up. This one was not bad at all. The ones before this I've found pretty dry.
09:41:28 <ph88> srk, oh i was talking about fpga actually ^^
09:41:54 <srk> ph88: yeah, realized that a bit later
09:42:55 <glguy> no one needs to feel pressured to race, I think the local leaderboard is most useful for keeping track of how caught up all the regulars are
09:45:55 <frerich> I noticed that many people (e.g. jle`, glguy, cocreature) use Text.MegaParsec instead of Text.Parsec; is there some good reason against using standard Parsec?
09:46:00 <glguy> and linking to their solutions in github
09:46:08 <cocreature> frerich: parsec development is basically dead
09:47:06 <cocreature> megaparsec improves performance, error messages, …. it is a bit harder to use initially imho but one gets used to it very quickly ime
09:47:20 <glguy> parsec is easier to use with custom token types , I find, but megaparsec integrates better with modern classes and operators
09:48:03 <ph88> can i check with GHC.Generics if a type is product only and no sum ?
09:48:24 <Guest96151> Hi guys, I'm new to haskell and got a question
09:48:30 <ph88> hi Guest96151 
09:49:00 <Guest96151> I received a .cabal file, installed it with stack install cabal-install en setup the yaml file with stack init --solver
09:49:17 <Guest96151> But now I have no idea what I need to do to start
09:49:30 <ph88> try   stack build
09:49:30 <Guest96151> I tried creating a Main.hs file
09:49:38 <Guest96151> But stack build failed
09:49:40 <ph88> oh you don't have a source file
09:49:54 <ph88> what's the error and the directory structure ?
09:50:02 <mud> Guest96151: You got *just* a .cabal file? That's not really enough to be a useful thing.
09:50:13 <ph88> if you don't have any sources you might as well just start a new project ... stack new myproject simple
09:50:38 <Guest96151> 2 seconds, uploading the error log of build -v
09:51:10 <Guest96151> http://lpaste.net/360635
09:51:49 <ph88> Guest96151, why even bother with a single cabal file? just start a new stack project 
09:52:16 <Guest96151> It was given to me like that, I am really new to haskell
09:52:29 <Guest96151> And they said to me to use stack init
09:52:34 <mud> Guest96151: It seems to be complaining that it can't find the Main.hs file, or similar. Which makes sense, it needs the actual sourcecode to be able to build.
09:53:13 <mud> Guest96151: What's the .cabal file for? What was the intent of them sharing it with you? Are you trying to build a specific project? Are you trying to start your own simple project or something?
09:53:32 <ph88> can't find source for Main in src
09:53:44 <Guest96151> I'm trying to build a specific project with Gloss and MBot, a library for using a robot
09:53:56 <Guest96151> https://www.stackage.org/package/MBot
09:54:39 <ph88> Guest96151, how do you want to name this project ?
09:54:45 <Guest96151> ProjectFLP
09:54:59 <Guest96151> So stack new ProjectFLP simple should do it, right?
09:55:10 <ph88> try to go into a new directory and run   stack new project-flp simple
09:55:25 <ph88> i'm not sure if stack accepts upper case in project name
09:55:27 <Guest96151> Then adding gloss and MBot to the extra deps and running stack build?
09:56:01 <ph88> you can then go into the generate    project-flp.cabal    file and add gloss and MBot underneath base
09:56:12 <mud> Guest96151: Usually you'd add them to the .cabal file, and then any that aren't in the stackage resolver, yes you'd have to add to stack.yaml extra-deps
09:57:35 <ph88> i always add them to the cabal file and then   stack build .. and then if it can't resolve i add them to stack.yaml extra-deps
09:58:56 <Guest96151> It worked, thanks a lot guys!
10:00:40 <mud> Yeah, what ph88 suggests is a good way to go.
10:01:23 <oizd> Hi folks. I'm trying to collect some data on people's favorite/most profound language features. I figure the Haskell community will have a lot to say. The 3-question Google Form: https://goo.gl/forms/UAO1QOAvbLLjmpto1
10:04:38 <ph88> can you make it multiple choice ?
10:04:59 <ph88> ^___^
10:09:57 <wz1000> anyone getting .rodata' can not be used when making a shared object; recompile with -fPIC when using stack 1.6.1 with archlinux
10:11:49 <cocreature> wz1000: install ncurses5-compat-libs and set ghc-build: nopie in ~/.stack/config.yaml
10:13:48 <wz1000> cocreature: thanks
10:14:23 <cocreature> wz1000: maybe also try a "stack setup --reinstall", I’m not entirely sure when stack does that itself
10:18:54 <utente001> sera
10:18:59 <utente001> !list
10:32:48 <dminuoso> A more beginner oriented question. So I've went through writing a couple monad transformers, and the do-notation has been a mind blockade because it never was obvious what kind of type of thing Im dealing with.
10:32:57 <dminuoso> So I've began to rewrite do notation with just >>= like this: https://gist.github.com/dminuoso/d2a94f177df2fb679b65d076a2177c3f
10:33:37 <dminuoso> Do the more experienced folks have opinions either way? Because looking through some libraries on hackage it seems like do-notation is really.. popular.
10:37:04 <cocreature> dminuoso: do notation is definitely popular and something you’ll have to become familiar with eventually. that said, for learning purposes I think it is really helpful to write things in terms of >>= first
10:40:00 <kuribas> dminuoso: I wouldn't use >>= with a lambda.  But pointfree yes
10:41:27 <glguy> Whether you're using do-notation or >>=, it doesn't help you to know what type you're dealing with
10:41:33 <glguy> they both provide no help in figuring that out
10:42:01 <mud> Yeah, with both you should really just know beforehand what Monad instance you're talking about. Otherwise it'll be very confusing.
10:42:08 <rightfold> I’d use >>= with LambdaCase
10:42:32 <dminuoso> LambdaCase is the first (and until now only) extension Ive started using :)
10:42:46 <kuribas> dminuoso: I use like tens
10:43:10 <kuribas> dminuoso: many I couldn't live without
10:43:12 <dminuoso> mud: Perhaps that might actually explain some of my difficulties. This `polymorphic in return type` is mindboggling. :|
10:43:40 <dminuoso> Though with >>= notation it's easier for me to think about it because seeing those kleisli arrows helps a lot
10:43:41 <kuribas> dminuoso: and awesomness like pattern synonyms and view patterns.
10:44:13 <kuribas> :t (>=>)
10:44:15 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
10:44:50 <dminuoso> kuribas: I actually found a spot to use that in when golfing for fun. But I ungolfed for readabilities sake :)
10:45:25 <dminuoso> It's the one thing I'm already accustomed to from JavaScript.
10:46:24 <kuribas> also called "the fish"
10:46:36 * kuribas is reading "cathegory theory for programmers"
10:50:26 <mud> dminuoso: I did find explicit (>>=) and etc. much easier to understand at first. Even with lambdas and etc. I still default to that once in a while really.
10:51:45 <Tuplanolla> Do you know if `nonlinear-optimization-ad` is in usable shape?
10:53:29 <glguy> I use >>= when mixing with functions that take continuations. For example https://github.com/GaloisInc/galua/blob/d014fefc42b92d581b5caf09012b2fe279c979bf/galua/src/Galua/OpcodeInterpreter.hs#L195-L207
10:57:46 <glguy> unless the whole thing is functions other than >>= that take continuations, then I'll use something like Codensity: https://github.com/glguy/irc-core/blob/v2/src/Client/CApi.hs#L200-L246
10:58:34 <geekosaur> hm whoops
10:58:36 --- mode: geekosaur set -o geekosaur
10:58:52 <geekosaur> missed the all-clear yesterday
11:01:50 <dminuoso> glguy: wow it took me a moment to realize that those were just inline comments..
11:02:25 <wedify> anyone familiar with yampa? in the reactimate call neither the input sensing action or the actuation action are being run
11:03:47 <wedify> the initialization happens but then the program just sits there
11:04:22 * hackage bbdb 0.6.1 - Ability to read, write, and modify BBDB files  https://hackage.haskell.org/package/bbdb-0.6.1 (HenryLaxen)
11:11:27 <glguy> dminuoso: Which comments?
11:12:00 <dminuoso> glguy: `{- ^ network -}`
11:12:18 <geekosaur> haddock markup, which is specially formatted comment
11:12:19 <geekosaur> s
11:12:22 <dminuoso> glguy: I stared at this with real confusion wondering what kind of operators {- or ^ might be there.. =P
11:12:25 <glguy> Ah. Yeah, if you do that then you get documentation on the function parameters in your haddock output
11:12:27 <dminuoso> geekosaur: Ah, figured as much.
11:14:13 <glguy> dminuoso: As seen here https://glguy.net/advent2017/Day09/Main.html
11:17:29 <Tuplanolla> What to do when Stack gives you `AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""`?
11:18:14 <mud> Tuplanolla: Upgrade stack
11:24:04 <Tuplanolla> Now it cannot find `nonlinear-optimization-ad` on Stackage.
11:24:19 <cocreature> Tuplanolla: add it to extra-deps
11:24:44 <crucify_me> hi lines 15,16 here are using pattern matching in the body of the definition. So the last line I get .. but what about line 15? my guess is that the case keyword has some sort of list constructor ?
11:24:48 <crucify_me> http://lpaste.net/360636
11:24:56 <Tuplanolla> I need to look that up first.
11:26:27 <geekosaur> [c] is (c:[]), just as it is in an expression
11:26:47 <Tuplanolla> I can't do that when there's no `stack.yaml` to begin with.
11:27:26 <cocreature> Tuplanolla: use "stack init --solver" or "stack init --omit-packages" to generate one
11:28:37 <cocreature> I really need to get around to adding a --force option to "stack init". --solver doesn’t work half of the time and --omit-packages is just annoying if you just want to manually enter extra-deps
11:30:00 <crucify_me> geekosaur, thanks, so the keyword case is what allows for that construction ?
11:30:45 <Tuplanolla> Now it fails with "Error parsing targets: The project contains no local packages".
11:31:02 <cocreature> Tuplanolla: I assume you used --omit-packages?
11:31:16 <crucify_me> because given (c:cs) on the next line it seems redundant 
11:31:20 <Tuplanolla> I used that to generate `stack.yaml`, yes.
11:31:36 <cocreature> you’ll have to manually edit the stack.yaml file and reenable the omitted packages
11:31:38 <monochrom> stack is like God. They do mysterious things to test your faith.
11:31:47 <Tuplanolla> I did that.
11:32:11 <glguy> Have you tried stack?
11:32:21 <monochrom> :)
11:32:27 <mud> Tuplanolla: What's in the stack.yaml now?
11:32:31 <wedify> finally figured it out. i accidentally introduced an infinite loop when i altered the definition of foldLoopM 
11:32:32 <cocreature> Tuplanolla: then you’ll have to show us your stack.yaml file and the full error
11:33:27 <Tuplanolla> http://lpaste.net/7806611722046799872
11:33:35 <crucify_me> geekosaur, thanks I'll move it to the beginners channel
11:34:05 <cocreature> Tuplanolla: you probably want "packages: - ."
11:36:17 <Tuplanolla> Okay, now we're going somewhere.
11:37:27 <Tuplanolla> Swap City.
11:40:39 <Tuplanolla> That worked somehow. Thank you for participating.
11:41:09 <dminuoso> glguy: Oh! So that is haddock output?
11:41:52 <glguy> dminuoso: Right
11:44:04 <Tuplanolla> I've been using Stack for a year now and it still makes no sense to me, monochrom.
11:45:14 <crucify_me> sorry one sec geekosaur .. so that is a base case ? It gives a 'non-exaustive' error without it.
11:46:21 <crucify_me> why would you write a base case like this ? " [c] -> c "
11:49:37 <dminuoso> crucify_me: rewrite as (c:()) -> c
11:49:45 <platz> if a primitive parser (e.g. `char` or `satisfy`) fails, then it does *not* consume any input?
11:49:51 <dminuoso> that might clue you in if you compare that with the other char
11:50:06 <cocreature> dminuoso: it should be (c:[]) not (c:())
11:50:15 <dminuoso> cocreature: Sorry! my bad
11:52:49 <Wizek> Does `-Wmissing-signatures` have a limit?
11:52:56 <crucify_me> dminuoso, the other dminuoso (thanks)
11:53:00 <crucify_me> ?
11:53:05 <platz> satisfy p = do c <- get; if p c then return c else pfail
11:53:06 <crucify_me> sorry typo
11:53:09 <Wizek> it only seems to show 9 warnings for me before it gives up
11:53:14 <crucify_me> the other char ? 
11:53:18 <platz> ^ why does that not consume input if the predicate fails?
11:53:20 <dminuoso> crucify_me: *the other case. :)
11:53:41 <dminuoso> crucify_me: https://gist.github.com/dminuoso/a06ec228541bf60332d61ccfba6d255f
11:53:42 <Wizek> I'd like to see more, or rather, for the exact inferred type for one specific binding further down the file.
11:54:44 <Wizek> -1 for
11:56:13 <Wizek> So, moving it to the top helps, that's nice. However, I also wonder, how come `tlb :: _` and `tlb :: ()` doesn't show the full inferred general type, including class constraints?
11:56:42 <Wizek> is -Wmissing-signatures the only way to get to that?
11:56:49 <crucify_me> thanks dminuoso so that is a base case used exclusively with the case keyword?
11:57:04 <dminuoso> crucify_me: what do you mean by `base case` ?
11:58:13 <crucify_me> if you remove that the program returns a 'non-exaustive pattern' eror
11:58:16 <crucify_me> error
11:59:27 <crucify_me> it reads "non-exaustive patterns"
11:59:35 <crucify_me> in case
11:59:39 <crucify_me> "
12:02:04 <platz> satisfy p = do c <- get; if p c then return c else pfail; -- how does the "get" get erased if the parse fails?
12:02:17 <dminuoso> crucify_me: So imagine the case had only the pattern (x:xs) -> ..., what do you expect to happen if you passed in an empty list?
12:03:12 <crucify_me> right , so its a base case. I've never seen it written that way dminuoso thanks
12:04:13 <crucify_me> but the rewrite is helpful (c:[]), but even then its a bit foreign 
12:04:40 <jle`> platz: it depends on the semantics of your parser
12:05:00 <jle`> platz: some parsers are automatically backtracking
12:05:06 <crucify_me> the book doesn't really explain it
12:05:34 <jle`> platz: so x <|> y would backtrack to where 'x' started parsing, if x failed
12:05:38 <dminuoso> crucify_me: The point of the error `non-exhaustive pattern` is to tell you that your case is not `total` in the sense that it couldn't match with any pattern.. so it doesn't know what to do.
12:05:45 <platz> jle`: i'm interested in attoparsec and Text.ParserCombinators.ReadP, the most basic
12:05:55 <jle`> ReadP is backtracking i believe
12:06:04 <monochrom> Yes.
12:06:27 <jle`> platz: backtracking vs. backtracking isn't really a basic vs. not basic thing
12:06:34 <jle`> it's just two different choices you can make for your Alternative instance
12:06:35 <crucify_me> dminuoso, thanks kindly , I'll just memorize the notation for now
12:07:08 <jle`> platz: attoparsec is also backtracking
12:07:08 <dminuoso> crucify_me: There's some really interesting goodies from seeing lists that way. Wait until you learn about folds :-)
12:07:32 <jle`> platz: are you asking about how they are implemented?
12:07:37 <platz> so the backtracking must be implemented in the definition for (>>=) then
12:07:38 <platz> ?
12:07:42 <crucify_me> er, I did learn about folds but not with that notation dminuoso 
12:07:50 <monochrom> No, in <|>
12:07:54 <jle`> platz: it's more critically in the implementaiton of <|>
12:08:00 <dminuoso> crucify_me: Then here you go: https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
12:08:03 <dminuoso> crucify_me: Let your mind be blown.
12:08:17 <jle`> ">>=" necessarily consumes the state if the first thing consumes anything
12:08:22 <jle`> since that's the "point" of >>=
12:08:23 <crucify_me> excellent. I may come crying to you later...
12:08:35 <jle`> platz: but implementing (<|>) :: Parser a -> Parser a -> Parser a
12:08:47 <jle`> you get to decide what happens when the first parser fails
12:08:52 <jle`> you can either reset the state and try the next parser
12:08:56 <jle`> or not reset the state and try the next parser
12:09:11 <jle`> at the simplest level it's just picking s0 vs. s1
12:09:54 <monochrom> No no, the divide is what happens when the first parser succeeds.
12:10:00 <fakenullie> isn't it always the second variant
12:10:07 <fakenullie> and to have first you have to use try
12:10:24 <s4ke> what are you talking about?
12:10:31 <jle`> fakenullie: no, it's up to the implementation of <|>
12:10:45 <fakenullie> anything is up to implementation
12:10:46 <monochrom> Actually not even that. When the first parser has consumed something as an intermediate success, but afterwards fails overall.
12:10:47 <platz> so this is the backtracking https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Text.ParserCombinators.ReadP.html#line-186 
12:10:50 <dminuoso> s4ke: Check the topic, it has a link for logs.
12:10:52 <jle`> fakenullie: common parser combinator libraries are sort of split 50/50
12:10:58 <jle`> on backtracking vs. non backtracking
12:11:03 <fakenullie> ok
12:11:18 <platz> R f1 +++ R f2 = R (\k -> f1 k <|> f2 k)
12:11:30 <platz> where k is used twice
12:11:37 <jle`> platz: yes, note that they both work on the same initial state
12:11:45 <s4ke> any of you guys tried eta-lang yet?
12:12:45 <crucify_me> dminuoso, are you playing me? you or someone sent me that the other day. I get that diagram. are you joking with me ? I don't see how that is related to the notation in question
12:13:05 <platz> ah nice, i was looking for the same thing in attoparsec but couldn't find it, but i think i got it now
12:13:11 <jle`> monochrom: thanks for the clarification
12:13:12 <platz> (in the source)
12:13:15 <platz> thanks
12:13:21 <jle`> np!
12:13:43 <crucify_me> sorry you lost me there
12:14:19 <dminuoso> crucify_me: No Im not. Do you see how `foldr` just "swaps out" : for f ?
12:15:40 <mud> > foldr (:) [] [1,2,3] -- swap (:) with (:) and [] with []
12:15:42 <lambdabot>  [1,2,3]
12:15:57 <mud> > foldr (:) [4,5,6] [1,2,3] -- swap (:) with (:) and [] with [4,5,6]
12:16:00 <lambdabot>  [1,2,3,4,5,6]
12:16:01 <mud>  etc.
12:16:14 <platz> if attoparsec always backtracks, and parsec (if i understand correctly) don't backtrack, why is it said that attoparsec is faster than parsec?
12:16:29 <platz> i would think always-on-backtracking would make it slower
12:16:53 <mud> platz: Because I think it's assumed that you're supposed to write parsers that will never have to, or something.
12:17:01 <glguy> attoparsec doesn't backtrack over a <|>
12:17:37 <glguy> so as long as you keep your alternatives short it works fast
12:19:09 <platz> ok, so ReadP does backtrack over <|> and attoparsec doesn't (even though in the documenatation it says "attoparsec parsers always backtrack on failure.")
12:19:52 <glguy> That comment is just to distinguish it from parsec which commits to an alternative in <|> if the parser consumes any input
12:20:05 <crucify_me> yeah dminuoso I understand that
12:20:09 <glguy> ReadP parses both alternatives in parallel
12:20:33 <platz> ah i see
12:20:37 <platz> thanks
12:20:49 <dminuoso> crucify_me: So lets for a moment ignore the name of the function. So what `foldr` does, it transforms one structure into another. But this only makes sense if you see a list as this recursive tree.
12:21:08 <dminuoso> It does so by just replacing (:) with something else.
12:21:58 <EvanR> overuse of "recursive" i think
12:22:20 <dminuoso> Heh. Yeah :(
12:22:24 <crucify_me> yes so seeing it as (c:[]) -> c   I see how it works
12:23:00 <crucify_me> it just threw me off to see [c] -> c  . the variable c just appeared out of the blue
12:23:23 <EvanR> variable patterns introduce variables
12:23:38 <EvanR> that is where they come from
12:24:08 <EvanR> like forall x . ..., introduces x
12:24:17 <dminuoso> crucify_me: At any rate, my point was just that viewing lists as cons cells seems to give a lot of intuition.
12:24:18 <crucify_me> good explanation.
12:24:55 <rightfold> Such forms are called binders in general
12:27:26 <crucify_me> here's the thing though, in a typical lhs pattern match, we see often [] . but now we're asked to see an empty set as (c:[])
12:27:44 <EvanR> wat no
12:28:07 <crucify_me> when the empty set is the base case
12:28:13 <dminuoso> crucify_me: It's just a match in the sense of "so I have something in my hand", and case tries to put it into every lhs, until it finds something that fits.
12:28:16 <EvanR> [] is empty, (c:[]) is not
12:28:28 <fakenullie> [c] is one element list
12:28:41 <dminuoso> crucify_me: the first shape that fits, that's when it creates a binding with the name to the value in its place.
12:28:44 <crucify_me> EvanR, so in other words, there is a winner and we are returning the winner
12:28:57 <dminuoso> crucify_me: so [c] is a shape of one element with the name c. if it fits, c is bound to the element in that position.
12:29:05 <EvanR> ok sure
12:29:12 <platz> i think this is what was confusing me.. for example in parsec "The rule is that once a branch accepts a token then alternative branches are pruned." so if the branch *doesn't* accept a token, it doesn't consume that input. essentially a branch that doesn't accept a token is "peeking", but once it accepts at least one token, it turns into a consumption
12:29:27 <crucify_me> ok I get it, thanks kindly everyone
12:33:16 <dminuoso> crucify_me: Also at this time (because you have gotten that error earlier), those patterns are called "refutable". That means they can fail to match.
12:33:46 <dminuoso> (a:[]) for example will refuse to match against (1:(2:[])), so the pattern match fails
12:35:52 <EvanR> really, it cant match a = 1:(2 ? :)
12:36:16 <crucify_me> hold on pls
12:36:53 <crucify_me> well, its a one element list, so it would be passed to the recursion on the final line
12:37:04 <crucify_me> no I mean
12:37:13 <crucify_me> its more than a one element list
12:37:49 <crucify_me> it works just like a regular pattern match on the lhs
12:38:23 <crucify_me> in any case it was just the notation, I see what role it plays.
12:39:06 <crucify_me> thanks!
12:39:13 <dminuoso> crucify_me: The reason that the name `refutable` pattern is interesting, is because there's also `irrefutable` patterns. One of which you likely have already seem
12:39:25 <dminuoso> Those will always match, against anything, without haskell complaining.
12:41:40 <crucify_me> but that is very subtle, since a pattern requires a criterion that is either provided or not.
12:42:08 <Wizek> oh, nevermind, it was GHCid playing tricks on me
12:42:18 <Wizek> only showing a screenful of errors and clipping the rest
12:42:22 <Wizek> *warnings
12:42:44 <Wizek> and it was less obvious since I used -W and -T too.
12:42:56 <dminuoso> crucify_me: One type is easy, a kind of wildcard pattern: _
12:43:23 <Wizek> I wonder if it would make sense to indicate with a line `(Warnings clipped)` or (43 lines hidden) or something
12:44:49 <crucify_me> you mean say f _ [] = ...
12:45:01 <dminuoso> crucify_me: Yes! _ is irrefutable. 
12:45:08 <EvanR> _ and x are irrefutable patterns in that they match anything
12:45:15 <EvanR> they cant fail
12:45:54 <EvanR> K and (K x) and (K x y) can fail, where K is a constructor
12:46:07 <dminuoso> crucify_me: and the difference between _ and x is just that x creates a binding, and _ does not.
12:46:32 <crucify_me> cool hmm
12:46:44 <crucify_me> sans cool
12:46:51 <crucify_me> hmm
12:46:56 <EvanR> sans
12:47:07 <crucify_me> I didn't mean to write cool
12:47:13 <dminuoso> Doesn't `sans` just mean without? :o
12:47:16 <EvanR> cool
12:47:28 <dminuoso> I mean Im not French so Im not sure..
12:47:41 <crucify_me> you must be French you got it..
12:47:48 <EvanR> its english
12:48:51 <crucify_me> mercy buckets
12:49:17 <crucify_me> == merci beaucoup 
12:50:48 <dminuoso> crucify_me: For the reason of those bindings, something like (x,x) is not allowed as a pattern.
12:51:20 <dminuoso> I think there's some languages around that allow such types of patterns when trying to express a tuple containing two identical values, but Haskell doesn ot.
12:56:22 <Tuplanolla> Which user interface package would you recommend if all I need is a lightweight canvas? Maybe `fltkhs`?
12:57:14 <kuribas`> > let [a] = [1, 2] in a
12:57:16 <lambdabot>  *Exception: <interactive>:3:5-16: Irrefutable pattern failed for pattern [a]
12:57:32 <kuribas`> > let [a, _] = [1] in a
12:57:34 <lambdabot>  *Exception: <interactive>:3:5-16: Irrefutable pattern failed for pattern [a, _]
12:58:41 <int-e> [a, _] is the same as (a : _ : [])
12:58:47 <rightfold> I don’t understand “irrefutable”
12:58:58 <rightfold> It was clearly refuted
12:59:18 <int-e> you can read "irrefutable" as "lazy"
12:59:20 <kuribas`> > let ~[a, _] = [1] in a
12:59:23 <lambdabot>  *Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern [a, _]
12:59:26 <int-e> > let ![a, _] = [1] in a
12:59:29 <lambdabot>  *Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern [a, _]
12:59:37 <int-e> meh
13:00:00 <int-e> > case [1] of [a, _] -> a
13:00:03 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
13:00:07 <EvanR> inscrutible error messages strikes again
13:00:40 <dminuoso> rightfold: the word `irrefutable` comes straight from the Haskell report.
13:01:36 <dminuoso> rightfold: I guess it is irrefutable in the sense that it was not refuted when the actual pattern match occured.
13:02:34 <kuribas`> Doesn't refute mean, go to the next pattern?
13:03:24 <kuribas`> so if it is irrefutable, it will give an error when the pattern doesn't match
13:03:46 <int-e> This seems to have changed between ghc 7.10.2 and ghc 8.0.2.
13:03:59 <dminuoso> The way I read the report, irrefutable really just means `non-strict`
13:04:07 <dminuoso> and refutable means `strict`
13:04:36 <dminuoso> Or rather that the matching with such a pattern is `non-strict` or `strict` respectively.
13:05:00 <int-e> (to wit, http://lpaste.net/7124616918836707328 )
13:07:08 <dminuoso> int-e: Am I reading this right? A bang pattern just adds the behavior that the match diverges when the value is _|_ ?
13:08:26 <fakenullie> > let [a, _] = undefined
13:08:29 <lambdabot>  <no location info>: error:
13:08:29 <lambdabot>      not an expression: ‘let [a, _] = undefined’
13:08:40 <fakenullie> > let [a, _] = undefined in a
13:08:40 <int-e> dminuoso: well it forces the pattern match to actually be performed. I'm a bit confused by the current error message since the pattern is not treated as irrefutable.
13:08:42 <lambdabot>  *Exception: Prelude.undefined
13:11:30 <dminuoso> int-e: Oh so it's kind of the opposite of ~, effectively turning irrefutable into refutable patterns?
13:12:28 <int-e> dminuoso: the normal scenario for irrefutable pattern match errors is the one in  let [a,_] = [1] in a; the pattern match succeeds without scrutinizing the list [1]; instead, a becomes something like  case [1] of [a,_] -> a; _ -> error "Irrefutable pattern failed for pattern [a, _]"; the idea is that it is a sort of assertion that the scrutinee has the expected shape (which would determine the...
13:12:34 <int-e> ...value of a), and that assertion fails.
13:13:58 <int-e> dminuoso: `let` bindings are irrefutable by default, but I /thought/ that ! makes patterns inside `let` refutable. Functionally, this is the case (let ![] = [1] in ...  produces bottom), but the error message from pattern match failures doesn't fit into that model.
13:14:30 <dminuoso> Ah I fully understand, thank you for the explanation.
13:29:58 <s4ke> hey. anyone experienced with sublime text?
13:30:12 <s4ke> i cant get the lint options to show
13:30:17 <s4ke> with haskell-ide-engine
13:46:58 <hexagoxel> s4ke: wait, does that mean other stuff is working? last i checked, the sublime lsp plugin didn't seem.. ready
13:47:04 <hexagoxel> which plugin are you using?
13:47:09 <s4ke> i am using lsp
13:47:27 <s4ke> in haske-engine-ide's README there are gifs of the features working
13:47:37 <mud> Hmm, haskell-ide-engine appears to support neovim. I wonder how decent it works.
13:47:37 <s4ke> for me i always get the error hoogle db missing
13:49:13 <s4ke> hexagoxel: welp. maybe i have found something
13:49:33 <s4ke> tbh i haven't managed to find any non-shitty GUI haskell editor
13:49:40 <s4ke> that's a BIG problem imo
13:51:10 <suzu> tbh the only first-class editors of haskell are emacs and vim :/
13:51:56 <systemfault> VSCode with Haskero isn't too bad
13:51:58 <s4ke> even though i like using vi via ssh, i don't think it's a good choice when compared to the features intellij offers
13:52:01 <mud> Does h-i-e require ghc-mod to be installed? I can't tell from the docs. It doesn't really mention installing ghc-mod, but ...
13:52:20 <hexagoxel> s4ke: i have set up sublime to "import" the ghcid output (compilation output including jump-to-next) and to format using brittany on keypress.
13:52:38 <s4ke> hexagoxel: can you somehow share me your settings?
13:52:49 <s4ke> i can see why sublime is good though
13:52:55 <hexagoxel> it is not much of an ide, but quite workable, and reliable and fast.
13:53:05 <s4ke> i don't care about ide features when it comes to ide
13:53:11 <s4ke> i mean haskell
13:53:19 <s4ke> i just want proper autocomplete and highlighting
13:53:27 <s4ke> everything else i do with type holes anyways
13:53:34 <hexagoxel> exactly
13:53:55 <s4ke> i am working on getting the autocomplete working atm :D
13:53:57 <EvanR> why the insistence on gui
13:54:11 <s4ke> EvanR: cause lazy and i also want something to recommend to people
13:54:19 <s4ke> normal people
13:54:26 <hexagoxel> i think i have only default autocomplete. or perhaps sublime-haskell's, but most of the features of that are disabled for me i think.
13:54:26 <s4ke> people who think Haskell is esoteric
13:54:32 <EvanR> it is
13:54:41 <EvanR> though vim is not that esoteric
13:55:40 <s4ke> EvanR: you think so?
13:55:56 <s4ke> https://stackoverflow.blog/2017/05/23/stack-overflow-helping-one-million-developers-exit-vim/
13:57:27 <EvanR> what is the alternative?
13:59:18 <mud> s4ke: That really just means that OSes have bad defaults, not really anything particularly about vim's popularity or lack there-of. That would happen regardless, as long as 100% of people don't know at least the basics of vim.
14:00:25 <EvanR> what kind of stuff does a haskell autocomplete complete
14:00:41 <mud> In my setup, it autocompletes things I've already typed.
14:00:52 <EvanR> so words
14:01:03 <mud> Yep
14:01:08 <EvanR> hmm
14:01:21 <dminuoso> EvanR: atom's autocomplete knows about imported modules as well
14:01:43 <fakenullie> vi was really useful as default editor on modem connections
14:01:45 <mud> You can do setups where it autocompletes, I dunno I guess Prelude might be a decent shot, any identifier from there, or more sensibly, yeah anything that's imported would make sense probably.
14:02:09 <s4ke> i have this project structure:
14:02:17 <s4ke> https://github.com/s4ke/parrows
14:02:19 <EvanR> there arent many long words in prelude... though fromIntegral is annoying for its commonality and length
14:02:23 <s4ke> i dont get it to work properly
14:02:35 <s4ke> EvanR: take a look here: https://github.com/haskell/haskell-ide-engine
14:02:48 <s4ke> as far as i can tell from the gifs it should be better than just word search
14:03:17 <mud> EvanR: They don't have to be ridiculously long for it to still help. Most of what I use it for is my own identifiers though, which is why I don't really care about setting up fancy stuff.
14:05:38 <EvanR> what are those screenshots of
14:05:51 <EvanR> some IDE that uses haskell-ide-engine through a plugin
14:06:27 <s4ke> yes. that's sublime afaik
14:07:23 <fakenullie> there's also intero
14:07:55 <fakenullie> looks like emacs only
14:08:11 <systemfault> Intero works with multiple editors.
14:08:44 <systemfault> But yes, the one that is known the most is intero-mode for emacs.
14:09:11 <dminuoso> Okay I'm unsure how to tackle this. Is it possible to write a Show instance for `newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }` ? I'm completely unsure what the constraints would have to look like.
14:09:27 <dminuoso> I tried instance (Show (m (a, w) ) ) => Show (WriterT w m a) where, but that seems to require UndecideableInstances (whatever that is, but googling suggested that its a dangerous extension)
14:10:16 <fakenullie> what happens if you write instance without constraints
14:10:41 <dminuoso> fakenullie: Well I can't because I need the Show constraint on the monad.
14:10:46 <fakenullie> shouldn't it be instance Show (WriterT w m)
14:11:40 <dminuoso> Huh. Well UndecideableInstances seems to make this work...
14:14:03 <hexagoxel> s4ke: https://gist.github.com/lspitzner/097c33177248a65e7657f0c6d0d12075
14:14:41 <mud> There does seem to be a lot more fancy stuff available in editor integration these days. I should look into it again, see if any of it is low-maintenance.
14:14:44 <s4ke> hexagoxel: thanks man :)
14:14:58 <s4ke> (or woman)
14:14:59 <s4ke> :D
14:15:08 <mud> stack is more mature than it used to be too, can't hurt. And there's the --compiler-specific stuff on install.
14:15:43 <s4ke> mud: without stack i would have abandoned haskell a year ago
14:16:05 <mud> Yeah, it's been a huge improvement in my workflow.
14:18:41 <hexagoxel> s4ke: np. the ghcid script there uses cabal new-build, but you can change that to stack without problems i think.
14:19:33 <s4ke> hexagoxel: i give this new ide thingy a try though. seems like i had the wrong version of hoogle installed
14:20:53 * hackage bindings-DSL 1.0.24 - FFI domain specific language, on top of hsc2hs.  https://hackage.haskell.org/package/bindings-DSL-1.0.24 (JohnWiegley)
14:21:24 <s4ke> stack is downloading the internet
14:23:00 <hexagoxel> s4ke: sure, i am sure i will too switch to HIE at some not-too-far time - it is simply the only proper approach to the whole situation.
14:28:41 <s4ke> hexagoxel: the good news is that _if_ it works well at some point, we will have no problems anymore
14:29:09 <s4ke> until i switch my focus in the project onto something like eta-lang
14:29:13 <s4ke> :D
14:42:21 <argent0> I ask about the `case`
14:42:24 * hackage c2hsc 0.7.1 - Convert C API header files to .hsc and .hsc.helper.c files  https://hackage.haskell.org/package/c2hsc-0.7.1 (JohnWiegley)
14:49:40 <Gurkenglas> How do you track down which dependency causes a segfault, so you can pass the hard work to them?
14:50:20 <fakenullie> I wonder if gdb traceback will show anything useful
14:51:17 <fakenullie> https://ghc.haskell.org/trac/ghc/wiki/Debugging/CompiledCode
14:53:52 <Gurkenglas> As long as you have not invoked an Unsafe module, it's always the fault of some dependency, yes?
14:55:13 <fakenullie> Gurkenglas: could be compiler bug
14:55:39 <fakenullie> theoretically
14:55:51 <Gurkenglas> As long as you have not invoked an Unsafe module, no segmentation fault is your fault, yes?
14:57:00 <fakenullie> Gurkenglas: if triggering a bug is not your fault, then yes
14:58:25 <Gurkenglas> in particular, that'd mean something like "allocating too much" would never be the reason
14:58:28 <Tuplanolla> How do you convert `Vector Double -> Double` to `Vector (Reverse s Double) -> Reverse s Double` as required by `ad`? There's no documentation on this.
14:59:18 <Donovan> Tuplanolla: I struggled with this as a beginner, I ended up using the types without the s
14:59:31 <Tuplanolla> I don't have a choice here.
14:59:54 <Donovan> you cant use the Rank1 types?
15:00:07 <Tuplanolla> I use another package.
15:00:31 <Donovan> hmm, im not sure then, I thought there was a function to do it in `ad` i don't remember the name though
15:02:21 <Gurkenglas> Got a link to where ad requires this?
15:02:32 <Tuplanolla> @hoogle Numeric.Optimization.Algorithms.HagerZhang05.AD
15:02:33 <lambdabot> No results found
15:02:46 <Tuplanolla> @hackage nonlinear-optimization-ad
15:02:46 <lambdabot> http://hackage.haskell.org/package/nonlinear-optimization-ad
15:04:39 <Tuplanolla> It's the first function in the module.
15:07:31 <Gurkenglas> Sorry for being Tier-1-tech at you, but have you seen https://hackage.haskell.org/package/nonlinear-optimization-ad-0.2.2/src/samples/LinearRegression.hs ?
15:09:36 <Tuplanolla> This sample code causes a panic.
15:09:51 <Tuplanolla> I get `initTc: unsolved constraints WC {wc_insol = [W] csv_an6l :: t_an6k[tau:1] (CHoleCan: csv)}`.
15:10:23 <Gurkenglas> That sounds like a certificate to go to the author for help :3
15:13:21 <Tuplanolla> I'm trying to accomplish the same thing as this Octave program: `@(z, rs, xs) fminunc (@(z) sum ((sum ((xs - z) .^ 2, 2) - rs .^ 2) .^ 2, 1), mean (xs, 1))`
15:13:30 <Tuplanolla> Fifty lines later, it's not looking good.
15:17:12 <Tuplanolla> It appears I was missing one application of `auto`.
15:23:13 <Tuplanolla> If I have the time to finish this thing, I might finally have something worth putting on Hackage.
15:23:57 <s4ke> f*ck it... i give up with sublime
15:25:54 <woodson> hi guys anyone knows how do use readerT with servant ? most of the tutorials such as this one https://kseo.github.io/posts/2017-01-18-natural-transformations-in-servant.html requires the use of 'enter'
15:26:08 <woodson> however the servant api got change and deprecated enter
15:26:25 <woodson> and not sure how to approach it 
15:28:59 <tomsen> hey guys, anyone a nice idea how to insert an item to a list before/after another item that is found by a predicate? my brain is melting and it seems to be so easy
15:32:16 <Tuplanolla> > (uncurry mappend . second ('-' :) . span (/= 's')) "tomsen"
15:32:18 <lambdabot>  "tom-sen"
15:32:25 <Average-user> tomsen: recursive function
15:32:42 <Average-user> or that ..
15:32:42 <s4ke> ? :D
15:33:37 <s4ke> now next editor to be tried out: VSCode
15:33:53 <s4ke> sublime support for haskell-engine-ide deemed total and utter garbage
15:34:25 <tomsen> holy :D ok ill need some time to understand. thanks!
15:36:07 <Average-user> s4ke: But sublime is proprietary 
15:37:05 <s4ke> Average-user: your point being?
15:37:41 <wzy8L-B2[m]> s4ke: Spacemacs works very well for me
15:37:44 <aplainzetakind> How should I structure and name the modules in my stack project, in terms of hackage namespace considerations? Say my project-foo.cabal specifies that module Bar is exposed, which I obviously import with 'import Bar' from within the project, then how would that module be named globally?
15:38:40 <s4ke> holy moly, VSCode is Open-Source?
15:38:43 <s4ke> has hell frozen over?
15:38:56 <s4ke> am i actually liking a microsoft product for once?
15:39:44 <jchia_> s4ke: I recommend the haskell-ide-engine plugin for vscode
15:40:12 <s4ke> jchia_: i am searching for a tool that actually supports haskell-ide-engine properly
15:40:23 <s4ke> seems like i started from the bottom of the barrel
15:40:29 <s4ke> Atom -> Sublime -> VSCode
15:40:55 <Tuplanolla> What's it actually called, aplainzetakind?
15:41:45 <s4ke> jchia_: i keep getting a warning that it could not find a hoogle db
15:41:47 <s4ke> fml
15:42:47 <jchia_> s4ke: vscode+hie works well for me except I can't get documentation and hoogle. I think the documentation part is broken somehow.
15:42:49 <alp> woodson, look at the changelog
15:43:03 <alp> woodson, https://hackage.haskell.org/package/servant-0.12/changelog
15:43:14 <s4ke> jchia_: so what does it offer to me then?
15:43:24 <alp> we show there how to tweak code using enter to use hoistServer
15:43:32 <jchia_> s4ke: you still can get other basics like code navigation, completion, type tooltip
15:43:53 <alp> woodson, https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers also shows an example, using Reader (not ReaderT)
15:44:23 <s4ke> jchia_: doesn't look like it tbh...
15:44:33 <alp> let me know if you have any question :)
15:44:37 <s4ke> it gets stuck loading auto complete
15:44:58 <jchia_> s4ke: It works for me. Maybe you need to set it up in a specific way. For one thing, the ghc version used to build hie must match that of your project.
15:45:27 <s4ke> jchia_: well that would explain things
15:45:31 <s4ke> but why?
15:45:32 <s4ke> -.-
15:47:10 <geppettodivacin> What do people use for FRP these days? It seems like all the things I looked at a year ago (Netwire, reactive-banana, reactive) aren't in active development anymore (unless I'm mistaken?)
15:47:25 <jchia_> s4ke: I don't know how hie works internally. I use recent stack nightly with GHC 8.2.2 for my projects and built the hie using the same setup.
15:48:00 <s4ke> jchia_: did you have to configure the stack yaml file of hie ?
15:48:06 <Average-user> s4ke: You can't know how stuff is done, or change them as you like
15:48:21 <Ariakenom> I wrote some nice code
15:48:25 <Ariakenom> >:t ( (\\) <$> map head <*> concat . map ( map (filter (/=',')) . drop 3 ) ) . map words . lines
15:48:32 <s4ke> Average-user: read my comment again
15:49:05 <s4ke> jchia_: thanks anyways
15:49:11 <s4ke> i guess i will continue tomorrow
15:49:12 <jchia_> s4ke: I tweaked it a bit, mainly for the resolver. Specifically, I copied the stack-8.2.2.yaml to stack.yaml and changed the resolver to be more recent.
15:49:32 <Average-user> s4ke which one?
15:49:48 <s4ke> Average-user: the comment in which i said i was ditching sublime :D?
15:50:31 <Average-user> s4ke; Whoops, I missed the part when you say is garbage sorry
15:50:41 <s4ke> note to self: burn Windows installation to the ground
15:51:07 <s4ke> Average-user: np
15:51:44 <jchia_> s4ke: BTW, I'm using linux. If you're using windows, ymmv.
15:52:19 <s4ke> jchia_: i know. i do 99.9% of my haskell dev in a VM, but i thought "maybe this will work on Windows"
15:52:21 <s4ke> boy was i wrong
15:53:29 <woodson> apl: whats the main difference between the two??
15:53:45 <woodson> alp: whats the main difference between the two??
15:54:54 <s4ke> jchia_: and as soon as i manage to install this stuff I guess I should write a tutorial...
15:55:46 <s4ke> a proper one...
15:55:59 <Average-user> for writing haskell I just use highlighting and command line
15:56:02 <alp> woodson, the way enter was implemented made it less easy for ghc to infer the types and often forced annotations etc 
15:56:57 <s4ke> Average-user: i basically do that as well, but I miss features like proper refactoring so much
15:57:35 <jchia_> s4ke: Would you like to see my stack.yaml for building hie?
15:57:44 <s4ke> can't hurt
15:58:09 <s4ke> i guess i have indexed hackage about 10 times now
15:58:22 <s4ke> gets boring after a while
15:58:28 <jchia_> http://lpaste.net/5367669377137115136
15:58:35 <alp> woodson, also, enter's impl had some terrible limitations
15:59:07 <s4ke> hmmm nightly head is a bit harsh for me though, thanks anyways :)
16:00:04 <jchia_> s4ke: recent HEAD of https://github.com/haskell/haskell-ide-engine
16:00:19 <jchia_> specifically, commit 34900cc4
16:08:58 <siwica> What is the purpose of the Real typeclass? It seems to me, it pretty much only combines Num and Ord?!
16:10:23 * hackage rate-limit 1.4.0 - A basic library for rate-limiting IO actions.  https://hackage.haskell.org/package/rate-limit-1.4.0 (AdamWick)
16:11:41 <geekosaur> siwica, that's one way to put it.
16:12:05 <geekosaur> Real as in real numbers. as distinct from imaginary/complex numbers (for which Ord cannot be defined)
16:12:09 <mud> siwica: toRational is the real meat of it. But ... ya it's not one that comes up a ton on its own.
16:13:16 <siwica> geekosaur: Yeah, I understand that. But why does that justify introducing a separate typeclass?
16:13:18 <geekosaur> (well.. imaginaty numbers can actually be Ord, but we rarely use them _as such_. we use them in complex numbers (or quaternions, if you like doing GR calculations), and these are not linear, they represent points on a plane or in 4-space respectively, so a linear concept like Ord can't be applied to them)
16:14:08 <geekosaur> mostly (a) for toRational (b) so we can inherit Ord in other typeclasses built on it
16:14:23 <geekosaur> you could say it's the Haskell equivalent of an abstract base class
16:14:30 <geekosaur> ...except we wedged toRational into it
16:15:12 <geekosaur> (werll, that's still abstract base class because it doesn't provide an implementation, only an interface)
16:16:29 <geekosaur> anyway it's not much use on its own, it's mostly useful for the things we can "subclass" from it
16:19:27 <geekosaur> and to force instances (which are actual types) to share common interfaces
16:22:44 <siwica> So it's basically a matter of convenience? I sometimes can write foo :: Real => a -> a instead of (Num a, Ord a) => a -> a?
16:23:04 <siwica> foo
16:23:04 <siwica> 	 :: Real a => a -> a
16:23:44 <EvanR> if it were "convenience" you could just delete the type signature
16:25:05 <mud> siwica: I wouldn't, personally. I don't think.
16:25:24 <geekosaur> siwica, again, no. the convenience is not at that level, it's at the level of linking Int, Float, Double, etc. into a consistent structure
16:25:39 <geekosaur> (to the extent that Num is consistent, which, well.)
16:26:19 <geekosaur> it's at the level of you the programmer not having to think about some things, because Real is there behind the scenes making sure things fit together
16:27:16 <geekosaur> (for example, helping ensure that when Int claims Ord and Float claim Ord, they're talking about roughly the same thing)
16:32:08 <siwica> geekosaur: Ok, thanks. I have to think about what you just said.
16:32:24 <dmwit> Huh. I was going to say that CReal is a canonical example of a type which is Ord and Num but not Real. But... it *does* have an instance. Just a really crappy one.
16:32:34 <dmwit> instance Real CReal where toRational _ = error "no"
16:32:38 <geekosaur> let's try it this way: conceptually at least, Real is the place where we link Num and Ord such that (3 < 5) == (3.0 < 5.0)
16:32:57 <EvanR> not to mention the Ord instance
16:33:02 <EvanR> and part of the Num instance also not working
16:33:04 <geekosaur> Ord itself does *not* do this; you culd define a MyFloat whise Ord instance is reversed. I tiwll be perfectly self-consistent --- but not consistent with how we expect Num to behave
16:33:26 <dmwit> I like CReal less and less the more I learn about it. =P
16:33:29 <geekosaur> Real is the level at which these get linked
16:34:32 <geekosaur> an (uinwritten) part of Real's interface contract is that any type which has a Real instance has an Ord instance that is consistent with other types that have Real instances
16:34:56 <EvanR> where are we getting all these unwritten rules?
16:35:23 <geekosaur> from the idea that we want Num to model how people think about numbers
16:35:43 <EvanR> kind of not questioning Num
16:35:47 <EvanR> but the rest of it
16:35:52 <geekosaur> beyond that ... well, I could build a philosophical argument, but you'd all be justified in tuning me out :)
16:35:57 <EvanR> are you making this up right now
16:36:50 <EvanR> i find Real and toRational as being quite odd
16:36:58 <EvanR> i dont know what that is trying to model
16:37:51 <siwica> geekosaur: Ok, I understand. I think the reason I was having trouble with understanding was, that I merly looked at :info Real
16:38:01 <mud> EvanR: Pretty much what it says on the tin, no? Things that have exact rational representations? Not that that comes up ridiculously often.
16:38:25 <EvanR> > toRational (3 :: Int)
16:38:27 <lambdabot>  3 % 1
16:38:39 <EvanR> k, but literally the Real types implement it too
16:39:08 <EvanR> ToRational would have made a better name
16:39:17 <geekosaur> EvanR, well, it's not entirely made up, it's basically the reasoning process behind it. Practically, you'd find that making toRational instances that behave the way we expect is kinda hard without that 'interface contract': people expect that on some level 3 ~~ 3.0
16:40:08 <geekosaur> a nd that reasoning process is pretty much *why* it's Real and not ToRational
16:40:26 <EvanR> huh
16:40:48 <geekosaur> (although you can also see it as just reusing the number theory name in the equivalent slot even though Num isn;'t actually doing number theory)
16:41:09 <geekosaur> but I;ll let NumericPrelude follow up that argument :)
16:42:43 <EvanR> escardo style reals and the generalization to higher order computations makes some embedding into the rationals make even less sense
16:43:06 <EvanR> because the structure of the computation is infinite
16:43:23 * hackage concrete-haskell 0.1.0.16 - Library for the Concrete data format.  https://hackage.haskell.org/package/concrete-haskell-0.1.0.16 (TomLippincott)
17:17:23 * hackage haskell-holes-th 1.0.0.0 - Infer haskell code by given type.  https://hackage.haskell.org/package/haskell-holes-th-1.0.0.0 (klntsky)
17:26:34 <dminuoso> Given a category C equipped with a monad M, and two objects a, b - is every `a -> M b` necessarily Kleisli arrow?
17:28:41 <lyxia> yes that's what a Kleisli arrow is
17:29:31 <dminuoso> lyxia: So the fact that a might be in F's image is irrelevant?
17:29:37 <dminuoso> *M's image that is.
17:29:45 <lyxia> right
17:30:29 <dminuoso> lyxia: alright great, so it doesn't just hold for Hask then. thanks :)
17:35:44 <johnw> dminuoso: I would put it this way: a Kleisli arrow is an arrow in a Kleisli category, in which every morphism a ~> b for some monad M is defined as the function arrow a -> M b.  It doesn't hold for Hask because Hask isn't a Kleisli category, but it should hold for many sub-categories of Hask.
17:48:45 <nate_> hello, is this chat for java too? its what came up when I googled "java freenode channel"
17:49:05 <lyxia> no
17:49:05 <geekosaur> o.O
17:49:18 <nate_> shoot
17:50:15 <mud> nate_: I would assume ##java
17:51:11 <nate_> thanks mud, unfortunitly "/join java", "/join #java" and /join ##java" aren't working for me
17:51:24 <nate_> I'm not sure if you need the #, like if its added implicitly 
17:51:49 <nate_> the one # works but is invite only :(
17:52:04 <nate_> guess I'm not cool enough
17:52:13 <glguy> nate_: You'll need to join ##java somehow. I was able to join so I know it's not restricted.
17:52:20 <mud> nate_: Fairly likely you have to register with freenode first. /msg NickServ HELP REGISTER
17:52:33 <glguy> Oh, yes, it's +r
17:53:18 <glguy> You can use: /msg nickserv REGISTER <password> <email-address>
17:55:53 <lmapper> hi everyone, I'm wondering if it's possible to read/parse into an arbitrary type.. here's a stripped down example: 
17:55:56 <lmapper> http://lpaste.net/360649
17:56:30 <lmapper> in e & f of function dosomething
17:57:20 <lmapper> I'm using the type as an identifier to choose which implementations of eval and check to run
17:58:49 <tomsen> does an 'a' exist for which '(a:[]) == []' ?
17:59:08 <tomsen> an item prepended to an empty list will result in emptylist?
18:00:56 <johnw> tomsen: no
18:01:10 <johnw> because the cons constructor is never the same as the nil constructor, no matter the arguments to cons
18:03:03 <tomsen> okay, thanks johnw
18:03:48 <dminuoso> johnw: When I said "hold for Hask" I meant that the definition as I phrased it is not limited to Hask.
18:04:02 <dminuoso> :t (>>=)
18:04:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:04:27 <dminuoso> johnw: This basically says what a kleisli arrow is, but I wasn't sure whether this would generally hold true for any category.
18:04:34 <dminuoso> But your way of phrasing is nice, I like it.
18:09:18 <rzhanka> I'm puzzled by how buffering is working in: http://lpaste.net/5844196999355695104  The desired behavior is that a hyphen should appear after each user keystroke. So far, flushing stdout has not done this. The only thing that has worked is deactivating buffering on stdin (!!). Also, the call to putStrFl will work as putStr if I use runhaskell, but not if I compile. However, using runhaskell only echoes the hyphens for 
18:09:18 <rzhanka> versions where the compiled code will also.  ghci echoes correctly without disabling the stdin buffering.
18:16:53 <hololeap> i think ghci sets buffering to NoBuffering on both stdin and stdout
18:16:55 <geekosaur> rzhanka, this is a combination of things
18:17:04 <geekosaur> ghci uses haskeline which disables buffering
18:17:22 <geekosaur> buffering controls terminal configuration because ghc's runtime deliberately conflates them
18:18:07 <geekosaur> (if you hSetBuffering a Handle on a terminal to NoBuffering, the runtime *also* makes termios calls to switch from "icanon"/line mode to "-icanon"/character mode)
18:18:16 <geekosaur> ...which can lead to surprises
18:18:31 <geekosaur> (in fact it led to a rather annoying bug in stack)
18:30:32 <rzhanka> geekosaur: ok, if I'm following termios docs, what you're saying is that unless buffering is disabled, the terminal buffers defeat the explicit flushes inside Haskell? However, I still don't understand why disabling buffering on (just) stdin solves the problem while disabling (just) stdout does not.
18:31:15 <geekosaur> because the pronblem is not where you think it is
18:31:26 <geekosaur> it's not output buffering. go look at "icanon"
18:31:50 <geekosaur> (tl;dr: the terminal only sends input when you hit enter, not on every key. unless you switch to -icanon)
18:32:28 <dminuoso> How can I create an `instance (Show (m (a,  w))) => Show (WriterT w m a) where` without UndecideableInstances?
18:32:30 <geekosaur> ghci is always in -icanon. turning off input buffering also turns off -icanon (this is a ghc runbtime-specific behavior; in a C program you'd need to make the termios calls yourself)
18:32:59 <hexfive> hi guys, i have a q: does the Either monad behave like the Maybe monad? ie, if i'm doing stuff in Maybe then any intermediate Nothing will evaluate the whole expression as Nothing, i'm trying to figure out if Either will do the same thing, where if any intermediate evalutes to `Left something` the whole expression evaluates to `Left something`
18:33:15 <hexfive> i have a paste of my current Maybe based code here: http://lpaste.net/360651
18:33:18 <dminuoso> hexfive: almost, except the left side can contain stuff.
18:34:36 <hexfive> awesome. so if i replace readMaybe with readEither and change up the types / constructors it should just work right?
18:35:53 <geekosaur> rzhanka, if you want to see this in action, try this: tuple each getChar with getCurrentTime. in icanon mode all the keystrokes will have the same time associated
18:36:02 <dminuoso> hexfive: Check out the definition of readMaybe :-)
18:36:02 <geekosaur> which will be the time at which you hit enter
18:36:13 <dminuoso> @src readMaybe
18:36:13 <lambdabot> readMaybe s = case readEither s of
18:36:13 <lambdabot>                 Left _  -> Nothing
18:36:13 <lambdabot>                 Right a -> Just a
18:36:32 <dminuoso> hexfive: Does that answer your question?
18:37:14 <nexus_> ss
18:37:21 <nexus_> hello everyone
18:37:27 <hexfive> dminuoso: i think so, trying it now. i've only been haskelling for a short while so trying to wrap my brain correctly. thanks :)
18:37:27 <dminuoso> hexfive: I think one way to see a Maybe, is as a specialized `Either ()`
18:37:58 <EvanR> Maybe a = 1 + a
18:38:09 <EvanR> Either a b = a + b
18:38:09 <nexus_> Is there any cool tricks with irssi? first time ever using it..
18:38:28 <newToHaskell> hello guys. I am new to haskell
18:38:31 <dminuoso> hexfive: we're in the same boat :)
18:38:37 <dsal> newToHaskell: I'm dsal
18:38:43 <newToHaskell>  I just have a quesion: Why lambda abstraction in haskell is using syntax such like \x -> x^2 instead of \x = x^2
18:39:06 <EvanR> = seems odd there
18:39:09 <dminuoso> newToHaskell: Im guessing because arrows have a deeper meaning in category theory.
18:39:27 <geekosaur> well, more that arrows are more like one of the common notations in math for that
18:39:29 <EvanR> x |-> x^2 is common in math
18:39:29 <rzhanka> geekosaur: ok, I see, nothing appears because Haskell isn't receiving it. But flushing stdout actually *is* working, which is why the prompt appears.
18:39:31 <geekosaur> = has a different sense
18:39:47 <geekosaur> rzhanka, exactly
18:39:48 <nexus_> join help
18:40:18 <dminuoso> newToHaskell: the real question you should have asked is: why \x -> x instead of \x. x
18:40:20 <dminuoso> :-P
18:40:37 <EvanR> . is overused already
18:40:57 <EvanR> ascii masterrace
18:41:32 <newToHaskell> This make me very confused. I think (->) symbal is called function construction, right?
18:41:39 <dminuoso> EvanR: On the other hand it would have made "point-free" code even more confusing for beginners to understand. :-P
18:41:40 <Average-user> Whats the relevance of the symbol in use?
18:42:09 <geekosaur> rzhanka, and yes, this is confusing --- and ghc's doing termios magic when you change buffering actually makes it harder to understand, as well as causing complications for programs that run other programs --- so I kinda hate that behavior.
18:42:09 <Average-user> dminuoso: Thats true
18:43:23 <geekosaur> it causes weird behavior and complicates explaining that behavior
18:44:09 <geekosaur> newToHaskell, if you think about it, that actually makes sense (what kinda doesn't then is the \ )
18:44:17 <rzhanka> geekosaur: and to be clear, due to the way Haskell handles termios, disabling input buffering is the only way to get the desired behavior? there isn't some mechanism I'm overlooking? I know little about the guts of terminals
18:44:18 <geekosaur> a lambda is constructing a function on the fly
18:44:54 <geekosaur> but the \ is needed so the compiler can tell ahead of time that you are constructing a function; things get more difficult if it has to wait until it sees the -> to realize you're making a function
18:45:18 <geekosaur> rzhanka, there's explicit termios stuff in System.Posix.Terminal
18:45:46 <geekosaur> but, that doesn;t do much on Windows. and the reason ghc went with the weird behavior is to try to paper over Windows/Unix behavior differences
18:46:05 <geekosaur> (unfortunately, it only does so in simple cases, and it's always harder to explain)
18:48:10 <edwardk> newToHaskell: the main confusion re lambda syntax is that it is \x -> y rather than \x.y   like in the usual lambda calculus, not \x=y. we like to reserve = for actual equality and x there doesnt "equal" the right hand side
18:48:50 <hexfive> dminuoso: sweet it works: http://lpaste.net/360652
18:49:18 <rzhanka> geekosaur: hm, ok, I was wondering what would happen on windows, figures it would be something like that
18:49:40 <edwardk> on the other hand, foo x = ...   is a thing you _can_ read like an equation, so we use = there
18:49:44 <geekosaur> windows is always in character mode. line editing is built into the win32 equivalent of getLine
18:49:45 <rzhanka> geekosaur: thanks very much
18:50:12 <geekosaur> on unix a simple line editor is built into the terminal driver; the "icanon" switch controls whether it is enabled or not
18:50:44 <geekosaur> (but people like more capable editors, so programs tend to turn the basic one off and use GNU readline / editline / haskeline / whatever to get a smarter one)
18:51:21 <dminuoso> hexfive: So the idea is, that Left would transport some error information, most commonly a String for an error message - basically an exception if you want.
18:51:27 <dminuoso> And shortcircuit computation.
18:51:47 <dminuoso> Just like you did. :)
18:52:23 <rzhanka> geekosaur: ok, makes sense
18:52:52 <geekosaur> if you do something like "cat | hexdump", you'll find things like tab completion don't work, but backspace does
18:53:47 <geekosaur> "stty -icanon; cat | hexdump" will show it's seeing the backspaces (note that you have to control-C to get out of this though and then manually "stty icanon" to put things back to normal)
18:54:23 <geekosaur> because the control-D thing is *also* part of the line editor
18:54:42 <newToHaskell> edwardk: thanks, I think I got it
18:55:59 <hexfive> dminuoso: nice, i was irritated with Either/Maybe before i could use the Monad instances right because anything i wrote ended up littered with `case somemaybe of`s :p. i see the light now
18:58:20 <edwardk> hexfive: if you ever feel nostalgic for the days before when you had to use that pattern you can always try go as this is how almost everything gets written there
18:58:43 <hexfive> i write go for my day job :\
18:59:14 <edwardk> then you already know :)
19:00:29 <rzhanka> geekosaur: thanks again, this has all been very helpful
19:01:37 <aplainzetakind> It seems impossible to subtract 1 with type-level natural numbers. Is it?
19:01:44 <parks37> Functions do not have to be defined before they are called correct?
19:02:42 <hexfive> edwardk: You get used to it, though. Your brain does the translating. I don't even see the `if err != nil`, i just see http.Get, db.Exec...
19:03:36 <geekosaur> parks37, as long as they are defined sometime before final link, yes
19:03:58 <geekosaur> aplainzetakind, subtraction is not total with naturals, so yes. (type level is not friendly to partial functions)
19:04:44 <edwardk> my brain read that like the guy explaining the matrix
19:05:41 <hexfive> that was the idea :p
19:15:13 <glguy> Prelude GHC.TypeNats> :kind! 2 - 1
19:15:14 <glguy> 2 - 1 :: Nat = 1
19:15:29 <glguy> aplainzetakind: ^
19:17:27 <geekosaur> once you turn on the necessary extensions, at least (maybe this differs in newer ghc, 7,10 made me turn oin DataKinds and TypeOperators)
19:17:45 <geekosaur> wait.
19:17:53 <geekosaur> no, I have messed up my config and got 8.2 :p
19:18:22 <glguy> Yes, if you're using type-level naturals, you'll need to have those two extensions on at a minimum
19:18:49 <geekosaur> ok, also 7.10. hm
19:27:14 <aplainzetakind> glguy: OK, the TypeNats package is beyond my comprehension. Too many extensions in play.
19:28:03 <aplainzetakind> But very roughly, it seems like the usual construction of integers as equivalence classes on pairs of natural numbers.
19:29:40 <glguy> aplainzetakind: It's not something you need to worry about in general while writing Haskell code
19:30:50 <aplainzetakind> I want to define a type where a parameter has to be positive integer, for practical purposes.
19:31:03 <seafood> edwardk: Just tried to read through your lazy demand-driven promises code. Looks interesting but still haven’t full understood all of it. Just wondering if you’ve written about it anywhere? 
19:31:38 <aplainzetakind> But I want to also be able to decrement that number unless it's 1, but I can't.
19:32:18 <edwardk> i use it in the discrimination package
19:32:32 <edwardk> look at the grouping module and associated code
19:33:12 <edwardk> think of it as having a single thread that gets pushed along until it writes into the promise you want then put back to bed
19:33:36 <aplainzetakind> I started out by defining data N = N; data S a = S a. Put them in a Card class, then used GATDs to define constructors accepting Card a's. But later on got stuck when I had to check if something's 1.
19:33:37 <edwardk> arguably it'd be better implemented directly using that sort of coroutine vocabulary
19:34:27 <edwardk> seafood: the talk on discrimination at zurihac mentions needing such a library, but was given a month or two before i solved the problem
19:35:43 <seafood> edwardk: I saw the end of that talk just now. First person who asked a question was Simon Meier :) 
19:36:29 <seafood> edwardk: I’m really not very familiar with coroutines. I don’t think I’ve ever used them as a programming language concept.
19:37:07 <edwardk> i'm still in sydney btw. over by darling harbour at the moment
19:37:13 <edwardk> i fly out tonight
19:37:33 <seafood> Oh nice, did you enjoy the conference? 
19:38:15 <hexfive> is there a way to shorthand constructors in pattern matches? the constructor would have a bunch of record fields, im looking for something like `f thing@(Constructor _) = []` instead of `f thing@(Constructor _ _ _ _ _ _ _ _ _ _) = []`
19:38:20 <edwardk> i had a blast. yow is a pretty great conference, even inits more general developer less-fp centric form
19:38:37 <edwardk> thing@Constructor{}
19:38:45 <hexfive> o, thanks v much
19:38:51 <edwardk> {} works there even if its not a record
19:39:03 <hexfive> cool
19:40:29 <edwardk> jed snuck me into the speaker dinner and i wound up explaining string diagrams to a guy wth a physics background by using feynman diagrams and used them to show him how monads work
19:42:45 <Gurkenglas> If someone wants to invest work in lens errors getting better, there's a low-hanging fruit. https://github.com/aelve/haskell-issues/issues/58
19:45:56 <aberrant> hi
19:48:10 <geekosaur> ...and I thought using QED to make a point about psychology was bad...
19:48:23 <edwardk> gurkenglas i'm still in favor of the general idea
19:53:02 <Gurkenglas> I'm guessing we would want some example files that Travis tries and fails to compile, displaying the messages?
20:05:10 <Gurkenglas> Does each error go in its own file because compilation will stop before it gets to some errors or is there a workaround for that?
20:35:08 <mniip> well good morning
20:35:46 <edwardk> gurkenglas not sure
20:36:01 <edwardk> a custom test suite would be nice but super-brittle
20:36:02 <mniip> edwardk, are there are monads in the category of feynman integrals?
20:36:33 <edwardk> identity will always exist, so yes :)
20:37:15 <mniip> I was hoping for a real world quantum mechanic monad
20:38:48 <edwardk> it is a monoidal category so you can have a moral version of writer, it should have an internal hom so reader adapts using any monoid...
20:40:44 <mniip> we are talking about the monoidal category of generic diagrams typed by their inputs and outputs, right?
20:41:03 <mniip> with composition the horizontal composition?
20:41:11 <mniip> but also vertical composition in the monoidal structure?
20:42:32 <mniip> do all of the familiar identities of such diagram categories make sense in quantum mechanics too?
20:42:46 <mniip> (cause I totally don't know how feynman diagrams work)
20:44:42 <mniip> ooh wait
20:44:44 <Average-user> jle`: Streaming this time?
20:44:45 <mniip> internal homs
20:44:54 <mniip> that means endo is an internal monoid?
20:45:05 <mniip> do we have state as composition of reader and writer?
20:45:48 <mniip> wait in what way is the hom internal
20:47:16 <mniip> never done any of this before,
20:48:17 <mniip> but do you just claim exponentials are products and your evaluation morphism X*Y*X->Y is this psi-shaped diagram thing
20:48:44 <mniip> ψ for reference
20:51:27 <edwardk> have you ever read the rosetta stone paper by baez and stay?
20:52:58 <edwardk> having trouble accessing it here on my phone usjng australian internets but start there
20:55:03 <johnw> http://math.ucr.edu/home/baez/rosetta.pdf
20:55:38 <mniip> skimming
20:56:49 <vaibhavsagar> edwardk: are you in Sydney?
20:57:02 <jle`> Average-user: yes i'll be streaming again :)
20:57:07 <edwardk> i am
20:57:14 <vaibhavsagar> how exciting!
20:57:27 <Average-user> jle`: Nice
20:57:28 <edwardk> i'm heading to the airport in an hour or two though
20:57:36 <Average-user> jle`: Send the link
20:57:40 <jle`> https://www.twitch.tv/mstksg
20:58:06 <edwardk> i'll definitely be back in May at least
20:58:36 <vaibhavsagar> I hope you had a good trip, I also happen to be in Australia right now but in Melbourne
20:59:12 <edwardk> i managed to burn the top of my head and ears badly enough that i understand the purpose of some kind of squashy hat down here now though
20:59:50 <vaibhavsagar> I don't know that you would have had that problem here, it's been alternating between miserably rainy and cloudless sky for the last few days
21:00:06 <edwardk> i had a wonderful trip. good time at the office. good news with our client. good time at yow standing around in the hallway talking to all the functional programmers, and way tok much time in the sun
21:02:05 <hexfive> can i pattern match the case where two args are the same? like `isEqual x x = True`
21:03:04 <edwardk> hexfive x ((==) x -> True) = ...
21:03:10 <edwardk> using view patterns
21:03:26 <hexfive> hmm
21:03:32 <edwardk> kinda heavy
21:03:42 <hexfive> yeah ima just use a guard for this one
21:03:47 <edwardk> also x y | x == y = ...
21:03:53 <edwardk> i'd usually use that
21:04:01 <hexfive> ^^ thanks
21:04:47 <edwardk> the viewpattern thing can be useful when making pattern synonyms, but i dont use it much otherwise
21:17:00 * hackage shelly 1.7.0 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.7.0 (GregWeber)
21:22:40 <cocreature> oh wow, I managed to get in the top 100 overall
21:23:07 <mniip> hmm I appear to be stuck
21:23:26 <mniip> I did get 29 points for the first part
21:24:02 <cocreature> I was really glad my solution just worked first try. I wouldn’t want to debug this especially part 2 :)
21:24:43 <mniip> anyone else get e48c587a76700250f2ce42201e64003a as the empty hash
21:24:48 <kadoban> I got ... 20 and 39
21:25:35 <mniip> oh god
21:25:45 <mniip> dammit C++
21:25:52 <mniip> You achieved rank 97 on this star's leaderboard and gained 4 points!
21:25:54 <mniip> har har
21:26:29 <mniip> could have saved me about 5 minutes if I did went to check what I was afraid of
21:28:59 <mniip> jle`, join traceShow? why not traceShowId
21:32:52 <cocreature> I had to read the instructions 5 times before I actually understood what I should be doing
21:33:06 <mniip> ditto
21:33:21 <mniip> ascii goes where?
21:33:25 <mniip> in the array?
21:33:30 <mniip> xor what
21:34:02 <mniip> I didn't understand a thing about flipping string segments around I just implemented the explanatory dumb algorithm
21:34:17 <mniip> flip piece advance skip increment skip
21:34:33 <cocreature> I somehow thought I should interpret each number in the original input string as a single ascii char rather than each character
21:35:36 <kadoban> I didn't understand where they were going with the second one, I thought it was going to end up being like an actual encryption procedure on a string.
21:35:41 <kadoban> That took a minute to figure out.
21:35:55 <glguy> I don't like how contrived this was
21:36:05 <glguy> Not that anyone likely does, but I don't either!
21:36:12 <cocreature> yeah the instructions were more complicated than the actual task
21:36:20 <kadoban> Aren't they all pretty contrived?
21:36:36 <cocreature> definitely not as contrived as the one today
21:38:45 <mniip> at 20 minutes I was like well no way I'm going anywhere
21:38:52 <mniip> apparently everyone else was slow too
21:39:37 <mniip> ohhhh
21:39:49 <mniip> I think I know a kinda elegant haskell solution for this
21:39:54 <mniip> Map Word8
21:41:14 <cocreature> that would at least be more haskelly than my unboxed mutable vector :)
21:41:43 <glguy> I used an IntMap, and just used `mod`256 on the lens I used to access it
21:41:59 <glguy> I plan to knock lens out of my final solution, but it was easy to reach for at the time
21:44:15 <dsal> I did that thing where I foldr across part of a list.  Feels so weird.
21:51:53 * hackage hspec-golden-aeson 0.4.0.0 - Use tests to monitor changes in Aeson serialization  https://hackage.haskell.org/package/hspec-golden-aeson-0.4.0.0 (mchaver)
21:52:54 <Lokathor> alright so how does one reverse part of a list efficiently in haskell i wonder
21:53:27 <Lokathor> bonus points if, when the end point of the reverse is beyond the edge of the list, it knows to grab off the beginning
21:53:50 <dsal> :t reverse
21:53:52 <lambdabot> [a] -> [a]
21:53:54 <MarcelineVQ> by not asking the lists what it looks like until you're done working with it, so put it vaguely
21:53:58 <MarcelineVQ> *to put
21:54:04 <Lokathor> dsal, that reversed the whole list :P
21:54:18 <dsal> What is part of a list?
21:54:25 <Lokathor> a sub-sequence of the whole list
21:54:39 <dsal> : reverse . take 5
21:55:02 <Lokathor> note that "list" isn't necessary here, any ordered sequence would do, Seq, Vector, if those would be better
21:55:19 <Lokathor> dsal, that's closer, i guess you just mix take and drop a bunch
21:55:24 <hexfive> reverseAtN n xs = take n xs : reverse $ drop n xs
21:56:11 <Lokathor> sadly i don't think that any of these are going to be very fast or have the looping reverse effect :/
21:56:22 <Lokathor> i guess you can do the loop on a cycle and then take the right number at the end of that
21:58:14 <Lokathor> do the reverse*
21:58:37 <MarcelineVQ> can you give a small example input/output
22:00:25 <MarcelineVQ> the hanging question is when you say part of a list, how are you specifying what part
22:00:58 <Lokathor> https://adventofcode.com/2017/day/10 :P
22:01:46 <kadoban> MarcelineVQ: index and length, it's also circular, so it has to wrap around if it straddles the end of the list.
22:01:49 <Lokathor> so you probably wouldn't specify low to high, you'd probably specify low to span
22:02:38 <kadoban> I'm pretty sure MarcelineVQ has the right idea if you really want to do it quickly, for long lists.
22:02:47 <kadoban> Of course for the problem at hand, it doesn't matter, the lists are tiny.
22:03:04 <Lokathor> yes, always 256 elements
22:04:12 <kadoban> I bet there's a way to do it in O(n + m) for an m-sized list with n reversals. Maybe ...
22:05:23 <Lokathor> i did it with the magic of ~destructive updates~
22:05:38 <Lokathor> in a highly corroded language
22:10:40 <hexfive> this works but is probs slow: 
22:10:51 <hexfive> let inf xs = xs ++ inf xs
22:11:03 <hexfive> let reverseNAtN i n xs = take i xs ++ (reverse $ take n $ drop i xs)
22:12:15 <dsal> Isn't 'inf' just 'cycle' ?
22:12:19 <hexfive> probably
22:12:26 <dsal> > cycle "abc"
22:12:28 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
22:12:31 <hexfive> ^^
22:12:58 <cocreature> hexfive: I don’t think that works if you need to wrap around. you’ll still take the first i elements in that case
22:13:36 <hexfive> right, the input xs should be cycled first
22:13:59 <hexfive> reverseNAtN 4 32 $ inf [1..12]
22:14:02 <cocreature> that doesn’t help. you’ll still end up with the first i elements not reversed
22:14:02 <hexfive> [1,2,3,4,12,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5,4,3,2,1,12,11,10,9,8,7,6,5]
22:14:10 <hexfive> is that not the point?
22:16:56 <mniip> glguy, so I came up with this [spoilers] http://lpaste.net/8488033460655489024
22:17:04 <cocreature> hexfive: reverseNAtN 4 4 [1..6] should be [6,5,3,4,2,1]
22:17:10 <mniip> but it has kinda poor performance characteristics
22:17:20 <mniip> probably due to lazy iterate
22:19:05 <mniip> hmm that's a cool idea -
22:19:10 <mniip> cycle-splice-uncycle
22:19:29 <mniip> just have to splice in the right place
22:20:37 <mniip> something about this reverse ordeal seems familiar
22:21:08 <MarcelineVQ> ye, where's ertes when you need him
22:21:27 <mniip> yeah no like
22:21:40 <mniip> I'm seeing if it's possible to do such reversals in sublinear time
22:22:24 <mniip> oh I think I know what the performance issue of my code is
22:22:30 <mniip> the map gets populated by huge thunks
22:29:27 <jle`> so most of my time on part 1 was debugging forgetting to add the current position when figuring out the new position v.v
22:29:49 <jle`> but my part 2 i am definitely puzzled on because i have all of the test cases correct, but the actual input is rejected, which makes things a bi hard to debug :'(
22:30:18 <MarcelineVQ> jle`: that's just the worst, I had to go line by line last time that happened to see when things didn't do what was expected
22:30:33 <mniip> jle`, I'm pretty sure I have the correct implementation so I could check for ya
22:30:43 <MarcelineVQ> this transforms to this, this transformes to this, this... what happened there..
22:31:24 <MarcelineVQ> it's hard to make unique puzzles with example inputs that cover all cases I guess :X
22:31:41 <mniip> jle`, what's the hash of ['\0'..'\255']
22:31:51 <jle`> mniip: if you don't mind! :) http://lpaste.net/401070939522990080
22:31:55 <jle`> hm let me check
22:32:45 <mniip> 2 correct implementations I have in fact
22:32:48 <Lokathor> jle`, you took the input string as bytes, then added the bytes it said, then did 64 rounds of hashing using those bytes as the lengths?
22:33:30 <Lokathor> and keeping the same position and skip between rounds?
22:34:04 <cocreature> jle`: I get 96de9657665675b51cd03f0b3528ba26 for your input
22:34:14 <mniip> well that's cheating
22:34:17 <kadoban> Same ^
22:34:21 <jle`> Lokathor: yeah, keeping the same, do you mean preserving it between each round?
22:34:22 <mniip> yeah can confirm
22:34:42 <jle`> i tricked you all
22:34:42 <Lokathor> jle`, yeah between rounds you preserve everything and just start the lengths over
22:34:45 <cocreature> oh crap, I didn’t even think that this was sufficient for solving it …
22:34:47 <cocreature> it’s too early
22:34:53 <jle`> Lokathor: yeah
22:34:55 <jle`> well spoilers, but
22:34:59 <jle`> i just replicated the input list 64 times
22:35:03 <Lokathor> also works
22:35:09 <jle`> or well, the list plus the salty bytes
22:35:12 <Lokathor> for _ in 0..64 { // do thing
22:35:24 <mniip> iterate f x !! 64
22:35:37 <jle`> theProcess . concat . replicate 64
22:35:43 <Lokathor> mniip, that looks like it won't work
22:35:52 <mniip> that's what I did
22:35:54 <jle`> it only works if your 'f' outputs the state too
22:36:03 <Lokathor> unless x is also holding the other vals, yeah
22:36:11 <mniip> my f is endo
22:36:20 <mniip> see [spoilers] http://lpaste.net/8488033460655489024
22:36:45 <Lokathor> ah ha
22:37:25 <Lokathor> i was expecing to see foldr1
22:37:28 <Lokathor> but it's not there 
22:37:38 <mniip> for what
22:38:02 <mniip> ooooh
22:38:05 <jle`> mniip: for ['\0'..'\255'] i get 40c1c725e0f8de8420142ee76e8e9fa3
22:38:21 <mniip> jle`, that took a while but it looks correct yes
22:38:38 <jle`> oh yeah i was trying other things heh
22:39:08 <mniip> so consider this
22:39:16 <mniip> this permutation cipher
22:39:18 <mniip> is monoidal
22:39:29 <mniip> I can kind of see some relation to the semidirect product
22:39:44 <mniip> what I mean is,
22:39:53 <mniip> given f = runRounds xs; g = runRounds ys
22:40:02 <mniip> you can construct  runRounds (xs ++ ys) out of f,g
22:40:23 <mniip> no
22:40:30 <mniip> out of f initState, g initState
22:43:08 <mniip> рьь
22:43:09 <jle`> i'm thinking i might accidentally have added a newline or something
22:43:10 <mniip> hmm*
22:43:26 <mniip> can you recover f out of f initState
22:43:58 <mniip> that skip length is messing things up a bit
22:44:30 <jle`> yup
22:44:33 <jle`> that was it
22:44:37 <jle`> i just added an extra newline
22:45:13 <LiaoTao> Hello! Could someone give me a few pointers on how to make this function more space efficient?
22:45:16 <LiaoTao> http://lpaste.net/360655
22:45:28 <jle`> yup, stripped for the extra newline and it works
22:45:29 <LiaoTao> Thanks!
22:45:46 <jle`> surprisingly i still got top 1k in the leaderboard even though it's been almost two hours
22:46:49 <jle`> so, today was just a series of silly errors :)
22:47:00 <MarcelineVQ> normal human day :>
22:48:17 <mniip> ok here's the deal
22:48:23 <mniip> if we zip the input with [0..]
23:13:49 <mniip> hmm
23:13:51 <mniip> didn't quite work
23:38:31 <jle`> mniip: i've been modding by vector lengths for indices so much for these
23:39:01 <jle`> mniip: can we add a normalize :: KnownNat n => Integer -> Finite n
23:39:34 <jle`> normalize n = finite (n `mod` natVal (Proxy @n))
23:39:46 <jle`> so i can just use it automatically with vector-sized
23:40:17 <jle`> also i wonder if there is a type for representing permutations
23:41:06 <jle`> @hackage permutation
23:41:06 <lambdabot> http://hackage.haskell.org/package/permutation
23:51:39 <mniip> jle`, isn't that what fromInteger does
23:51:59 <mniip> I vaguely remember that being the case
23:52:22 <jle`> mniip: i thought so too but fromInteger is _|_ when you are out of range
23:52:35 <mniip> ah yes
23:53:02 <jle`> i was wondering if this would be a more sensible behavior for fromInteger, but i think throwing a runtime exception would probably lead to more bugs being caught
23:53:25 <mniip> so yeah
23:53:27 <jle`> alternatively, you could just store any integer in a Finite, but be smart with Eq/Ord instances
23:53:31 <mniip> I'm trying to implement this cipher
23:53:34 <mniip> as a semidirect product
23:53:38 <jle`> and getFinite
23:53:38 <mniip> of two groups
23:53:43 <mniip> are you doing that too
23:55:27 <jle`> mostly trying to clean up code atm
23:57:13 <jle`> but that's an interesting path
