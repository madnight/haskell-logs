00:01:34 <ventonegro> So... Is the ZuriHac registration already open?
00:05:19 <mniip> :t fromInteger
00:05:21 <lambdabot> Num a => Integer -> a
00:05:53 <dminuoso> Mmm, so a Parser is just a kind of State monad :o
00:11:00 <jle`> @let hHead :: HList (a ': as) -> a; hHead (x `HCons` _) = x
00:11:01 <lambdabot>  Defined.
00:11:16 <jle`> @let hTail :: HList (a ': as) -> HList as; hTail (_ `HCons` xs) = xs
00:11:18 <lambdabot>  Defined.
00:11:24 <jle`> :t hHead . hTail . hTail . hTail
00:11:25 <lambdabot> HList (a1 : a2 : a3 : c : as) -> c
00:12:20 <mniip> dminuoso, what no
00:12:36 <mniip> I have a thing here that says otherwise
00:14:05 <kahlil29> I have a Value (Data.Aeson.Value) whose value is `String "someString" . How do I extract the actual String value out of the Value ? I tried using show but that just converts the entire thing to "String "someString" " in JSON format
00:14:21 <jle`> kahlil29: you can pattern match
00:14:50 <kahlil29> alright. didn't think of that. Will do, thanks ! any other way to do it? 
00:14:52 * hackage midimory 0.0.2 - A Memory-like (Concentration, Pairs, ...) game for tones  https://hackage.haskell.org/package/midimory-0.0.2 (HenningThielemann)
00:16:12 <jle`> that's the most direct way, but there might be other methods that are better depending on what you eventually want to do with the string
00:16:45 <kahlil29> jle`: cool, thanks
00:22:58 * hackage postgresql-schema 0.1.14 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.14 (markfine)
00:29:33 <pja> Advent of Code ✓
00:30:55 <jle`> pja: congrats :)
00:32:13 <pja> At least going from part 1 -> part 2 was trivial this time...
00:32:28 <dminuoso> Is it fine if a law of say associativity of a Monoid is satisfied up to isomorphism?
00:33:08 <jle`> it just depends on how you define equality
00:33:20 <jle`> when saying that x <> (y <> z) == (x <> y) == z
00:33:27 <jle`> * x <> (y <> z) = (x <> y) <> z
00:34:00 <jle`> there is more than one way to interpret that '=', as long as it defines valid equivalence classes
00:34:33 <jle`> reflexivity/reflection/transistivity
00:36:23 <jle`> dminuoso: unless you mean "capital M monoid", actually, as in the typeclass
00:36:37 <jle`> typeclass laws are usually written in the spirit of substitutability
00:37:01 <jle`> as in you can replace `x <> (y <> z)` with `(x <> y) <> z` in your code and the result/answer should be the same
00:37:11 <jle`> by some observable definition of 'the same'
00:37:55 <jle`> dminuoso: there's an example in this article here of a Monoid instance where associativity isn't *internally* true
00:38:06 <jle`> but the external API when you actually use the type preserves associativity
00:38:28 <jle`> that is, when you *use* x <> (y <> z), it's the same as if you used (x <> y) <> z
00:38:31 <jle`> http://comonad.com/reader/2015/free-monoids-in-haskell/
00:39:19 <dminuoso> jle`: I suppose both cases are interesting. Wrt to a discussion yesterday I learned that Bifunctors exist if some laws only hold up to isomorphism.
00:39:29 <dminuoso> In particular this was about the Bifunctor (Hask, (,), ())
00:39:50 <dminuoso> So I started to think how much of this "up to iso" worked in Haskell.
00:41:01 <mirari> Hello. Can someone explain to me the intuitive difference between class constraints, such as Eq a => Ord a ..., and instance constraints, such as (Eq a, Eq b) => Eq (a, b) ?
00:41:45 <jle`> do you find yourself mixing them up in code?
00:41:53 <jle`> or are you looking for some deep underlying meaning
00:42:04 <mirari> The latter. I am trying to grook.
00:42:25 <cocreature> mirari: an instance constraint means that you can make use of the constraint when defining the instance. a class constraint means that every a that is an instance of Ord must also be an instance of Eq
00:42:43 <dminuoso> mirari: It's just stating that whatever "a" is, it must satisfy the necessary interface to do something with it. "Eq" encapsulates the notion that two objects can be compared to test for equality.
00:42:55 <mirari> What is the benefit of a class constraint then?
00:43:00 <dminuoso> mirari: Constraining types.
00:43:10 <dminuoso> mirari: For example. Can you order colors?
00:43:22 <mirari> How does it help me, in my code, that Ord  requires Eq?
00:43:28 <jle`> mirari: on a pragmatic level, it helps that you don't have to write (Eq a, Ord a) => ... for your functions
00:43:34 <jle`> and that you can just write (Ord a) => ...
00:43:43 <jle`> since Ord implies Eq
00:43:44 <mirari> jle`: Excellent. I was thinking that was one motivation.
00:43:58 <dminuoso> Ohh.
00:43:59 <jle`> at a deeper level, it also means that your Ord laws can involve Eq operations
00:44:23 <jle`> if Eq wasn't a superclass, you can't really talk about Eq instances in your Ord laws
00:44:28 <mirari> The structure of the class constraints must be a directed acyclic graph?
00:44:30 <jle`> because not all Ords would be Eq necessarily
00:44:35 <mirari> Yes, I see.
00:44:55 <jle`> but class Eq a => Ord a means that any Ord instance is necessarily an Eq instance, so you can talk about (==) in Ord laws
00:45:02 <tdammers> it would also be super weird to have things for which you could do equality comparisons indirectly (a <= b && a >= b), but not directly (a == b)
00:45:27 <jle`> this is important if we imagine a split class Semigroup and Monoid
00:45:31 <dminuoso> So its just a consequence that a (pre)order for some >= forms a category right?
00:45:33 <mniip> 1512549842 [11:44:02] <mirari> The structure of the class constraints must be a directed acyclic graph?
00:45:35 <mniip> tricky question
00:45:36 <jle`> class Semigroup a where (<>) :: a -> a -> a
00:45:46 <jle`> class Semigroup a => Monoid a where mempty :: a
00:45:51 <mniip> this was not previously enforced until ekmett found a legit reason for them not to be
00:46:01 <mniip> this is when UndecidableSuperClasses extension appeared
00:46:42 <jle`> dminuoso: here we say that a Semigroup is <>-able things, and Monoids are <>-able things that also have an identity
00:46:47 <jle`> * mirari 
00:47:05 <jle`> mirari: Monoids are <> *and* mempty, together.  that's what the Semigroup a => says
00:47:08 <mirari> So its unclear where <> is from?
00:47:34 <jle`> any Monoid should be able to use Semigroup's (<>), and we can say that by giving a class constraint
00:47:49 <jle`> and also we want to talk about our Monoid laws, x <> mempty = mempty <> x = x, etc.
00:48:01 <jle`> and that's only possible if 'a' is a Semigroup, and defines (<>)
00:48:08 <pja> Small surprise yesterday: The Haskell version of my AdventOfCode solution was /faster/ than my C++ solution. (with GHC 8.2 + LLVM).
00:48:11 <Rembane> mniip: Do you have the correct number of negations in your line with ekmett? That line doesn't make sense to me.
00:48:37 <Rembane> pja: Nice! Which optimizations were enabled in the different compilers? :)
00:48:37 <mniip> Rembane, I remember in older versions of GHC you could define a cyclic superclass structure
00:48:39 <jle`> mirari: another example, class Num a => Fractional a
00:48:56 <Rembane> mniip: Oh. Did the compiler choke on that or just happily build something weird?
00:48:56 <jle`> mirari: all Fractional instances should be addable, multipliable, negatable, etc.
00:49:03 <mniip> Rembane, either
00:49:11 <mniip> Rembane, it doesn't have to be weird
00:49:13 <jle`> mirari: and the way we say that is by saying class Num a => Fractional a
00:49:17 <mniip> it can make perfect sense
00:49:24 <Rembane> mniip: Do you have an example?
00:49:27 <pja> Rembane: Both -O3, no machine specific optimisations. No vectorisation either. g++ 7.2
00:49:30 <mirari> jle`: okay, but what is the cycle?
00:49:35 <Rembane> pja: Sweet! 
00:49:47 <jle`> mirari: what cycle?
00:49:58 <TMA> tdammers: having a <= b and b <= a and not(a==b) is quite a natural structure
00:50:11 <jle`> mirari: by the way, one interesting way of reading instance (Eq a, Eq b) => Eq (a, b) is looking at (=>) like implication  (with some squinting)
00:50:16 <mirari> jle`: I thought we were talking about whether the class constraints form a dag. Or were you giving some more examples of why class constraints are useful? Maybe I misunderstood.
00:50:28 <jle`> mirari: oh yeah i was just talking about why class constraints are useful
00:50:33 <TMA> tdammers: it is the divisibility over whole numbers
00:50:53 <pja> Rembane: mutable vectors turn out to be very fast! ghc 8 was about half the speed of the C++ tight loop. I need to look at the asm that 8.2 spits out.
00:50:57 <jle`> mirari: but back on instance onstraints, you can read the above as "if i have Eq a, and I have Eq b, then I have Eq (a, b)"
00:50:57 <mirari> okay, got it! I see that it is useful for (a) laws in type classes, and (b) to make the constraints simpler, e.g. you dont need both Ord and Eq.
00:51:08 <jle`> "=>" kind of plays the role of logical implication, in a loose sense
00:51:12 <mirari> jle`: Yes, there is a logic-style language at the instance constraint language.
00:51:23 * hackage resourcet 1.1.10, conduit-extra 1.2.1 (MichaelSnoyman): https://qbin.io/pcfi0w1
00:51:26 <TMA> tdammers: -2 | 2 ; 2 | -2 ; yet 2 != -2
00:51:27 <mirari> I was just suprised to see that there is *another* logic language at the class constraint level.
00:51:54 <Rembane> pja: Nice! I'm getting curious, what does your implementation look like?
00:51:56 <mirari> But I had the crazy thought that the class constraints could be translated to instance constraints.
00:52:29 <mirari> For example, if you have Eq a => Ord a, then you could write an "instance constraint" like false :- Ord a, ! Eq a.
00:52:36 <pja> Rembane: Core of it is in this reddit comment: https://www.reddit.com/r/adventofcode/comments/7hngbn/2017_day_5_solutions/dqt9nwf/
00:52:46 <mirari> I know I am getting a bit out of scope, but I was just thinking aloud.
00:52:54 <pja> Rembane: Not complicated code!
00:53:06 <Rembane> pja: Indeed. But it looks like C code with nicer syntax. :D
00:54:15 <Rembane> pja: I did a similar solution that isn't very fast, but I guess it jumps between mutable and pure land too much to be fast: https://github.com/Rembane/adventofcode2017/blob/master/5/Main.hs
00:55:16 <mirari> One follw up question. When Haskell sees the constraint "Eq a, Ord a" how does it compute that they can be combined to just "Ord a"? 
00:55:44 <siwica> Why is the minimal complete definition of Ord not "compare | <" instead of "compare | <="? After all Ord is a subclass of Eq which already provides (==).
00:56:02 <pja> Rembane: I think V.modify ends up copying the vector, so it ends up really expensive for small updates because you have to pay the copy cost /plus/ the thaw / freeze cycle cost.
00:56:39 <Maxdamantus> mirari: what makes you think it does?
00:56:40 <pja> Rembane: Really, the docs for Data.Vector should point that out. If you’re doing a lot of small updates you’re better off going for full mutability within ST or IO.
00:56:55 <Maxdamantus> mirari: it knows how to infer the former from the latter.
00:57:08 <mirari> Maxdamantus: Someone wrote that higher up
00:57:37 <Rembane> pja: Oh. Meh. Lets create a pull request! :)
00:57:58 <jle`> mirari: it doesn't have to explicitly compute that you can combine them
00:57:58 <dminuoso> So here is a question. Why do I have to specify a Functor and Applicative instance for a Monad, when the Functor and Applicative can be mechanically derived (potentially efficiency reasons aside)
00:58:07 <pja> Rembane. Do it :)
00:58:14 <jle`> mirari: but if Eq was not a superclass, then what happens if you used (==) in your function?
00:58:32 <jle`> mirari: (Eq a, Ord a) would be fine, and (Ord a) would also be fine
00:59:11 <Rembane> pja: ^^
00:59:12 <pja> Rembane: V.modify is for bulk updates really. I went down that line myself & it took me ages to realise that the function you pass in had to use the Multable versions of all the functions. So docs quite unclear.
01:00:12 <mirari> I was thinking it would use the super classes to compute the "minimal" class constraint (e.g. when reporting on the type of a term), but I was wondering how "minimal" is defined.
01:00:38 <mirari> But anyway, thanks a lot. Your comments were very helpful. I have a better understanding of why you want both.
01:00:48 <mirari> That is, class and instance constraints.
01:00:49 <treg> Hi. Is there a channel for annoying beginner questions ? I've completed a first tutorial, only tryed a few elm before, and now trying a web service with snap.
01:01:03 <jle`> mirari: there isn't any "reason" to compute a minimal class constraint, strictly speaking
01:01:27 <Rembane> pja: Indeed. I had a hard time finding the mutable operations. They are hidden quite well.
01:02:13 <siwica> I just repeat: Why is the minimal complete definition of Ord not "compare | <" instead of "compare | <="? After all Ord is a subclass of Eq which already provides (==).
01:02:39 <siwica> Also why can't I specify only (>=), (>), ...?
01:02:39 <pja> Rembane: The link to MVector in the definition of V.modify goes to the wrong place in Hackage which doesn't help.
01:03:49 <Rembane> pja: INdeed. Only detective ninja rocket hackers are allowed to use the mutable vectors.
01:03:50 <pja> siwica. If you’ve got < and == then you can derive >=, <= and >. So the various options are all equivalent, no?
01:04:08 <Rembane> pja: https://github.com/haskell/vector/compare/master...Rembane:patch-1 <- can you make the PR even more awesome? :D
01:04:16 <dminuoso> siwica: Id say <= looks cleaner because it gives you a nice category
01:04:20 <pja> Rembane: Which is a shame, because sometimes you just want to make that tight loop sing.
01:04:21 <dminuoso> < does not
01:04:50 <siwica> pja: But specifying only (<) will need less code
01:04:59 <siwica> Since it gets rid of a few cases
01:05:01 <Rembane> pja: Yes, really fast Haskell is a joy.
01:05:19 <jle`> treg: this channel is for annoying beginner questions :)
01:05:43 <jle`> there's also #haskell-beginners too if you feel like this one is moving too quickly at a given point in time
01:06:02 <tdammers> haskell has an infinite learning curve, so we are all beginners
01:06:19 <siwica> Also, I see no reason why you don't have a choice to specify any of (<), (<=), (>), (>=), compare 
01:06:28 <Rembane> But some beginners have a bigger y.
01:06:51 <siwica> For some reason you are forced to either implement (<=) or compare
01:06:52 <pja> Rembane: Erk. Not used to the github interface at all.
01:07:06 <treg> thank you jle. For now my snap install is no longer blocked so I have no question. Is snap a good choice for a single page application (static elm file) which will access some haskell web services ? (ok, this is a question :) )
01:07:08 <pja> Rembane. (Also, need to make the same change to Vector.Unboxed)
01:07:37 <Rembane> pja: Me neither, it seems like I forgot to make it a pull request. Hm...
01:07:42 <Rembane> pja: Check. I fix!
01:08:36 <tdammers> treg: any of the major haskell web frameworks can serve static files, although if you run behind some sort of reverse proxy like apache or nginx in production, you will want that one to serve your static files directly
01:08:43 <pja> Rembane: make it an issue?
01:09:01 <Rembane> pja: Yeah, that's a better way.
01:09:29 <pja> Rembane: You can link to a pull request in your issue...
01:10:23 <merijn> siwica: It's because all the others have default implementations specified using compare and <= and those two have default implementations using each other
01:10:41 <merijn> siwica: So you have to implement one of the two, to make sure all the default implementations you work
01:10:54 <Rembane> pja: That's good. Well, I'll prepare this during the day and then post it tonight. Now I need to go back to Control Systems Theory.
01:11:04 <treg> tdammers: yes, the elm SPA will be hosted probably on a nginx. Is snap a good choice for just exposing an haskell API as an https/json port ?
01:11:17 <pja> Rembane: ✓
01:11:39 <merijn> siwica: As for "why?", probably because making it even more flexible was just a pain in the ass to make work/implement and it rarely seems like it'd be useful
01:12:03 <tdammers> treg: haven't used snap myself, but I don't see why not. It's not specifically designed for JSON APIs, but it should be fine regardless.
01:12:40 <tdammers> treg: might also want to look into Scotty, and maybe Servant, although the latter might be a bit too abusive on the type magic for a beginner
01:13:28 <treg> mmm, maybe scotty is a good choice in order too learn about FP then :) 
01:14:36 <siwica> merijn: Well, ok. That might have been the reason...
01:15:33 <siwica> Still think specifying (<) and deriving the (==) case from Eq would make more sense
01:16:12 <siwica> Since now you could have a type with "Foo <= Bar" and "Foo /= Bar"
01:23:46 <merijn> siwica: I mean, in the end you can implement all methods by hand and make a completely nonsensical implementation, so it's not that big an issue, I think
01:24:25 <merijn> siwica: Plus, if you want a guaranteed good one, you can just derive it :)
01:28:22 <ertes-w> hell
01:32:22 * hackage memory 0.14.10 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.14.10 (VincentHanquez)
01:42:33 <rzhanka> http://lpaste.net/2151993239106748416 is my solution for Advent Day 5, part 1. Note there are two different versions of the count in the output: "count via sums" which comes out correct, and "direct count" which turns out too high on all but the simplest input. I am very puzzled as to how these two different counting methods could come out differently, and unsure what I could (easily) do to test it. I don't see how it's 
01:42:33 <rzhanka> possible for the number of steps counted to be different from the number of modifications to the array. I am quite new to Haskell, and I'm afraid the code is rather stone knives and bearskins.
01:45:19 <merijn> rzhanka: Small style note, in try I would split it into two cases to explicitly handle the case of an empty list (which would make "head instrs" crash)
01:46:11 <merijn> rzhanka: Like so: http://lpaste.net/2151993239106748416#a360544
01:50:22 <rzhanka> yes, I would have done that if the inputs were going to be any less controlled
01:52:18 <merijn> rzhanka: Also, I think you can replace the "outside" bounds check by simply using the safe access on the Map and using pattern match on Maybe to handle the bounds check
01:54:07 <rzhanka> ok, I see
01:57:28 <merijn> rzhanka: Aren't you double counting the first element in your Map version?
02:00:03 <merijn> You increment index 1, but the new position is still 1 (old position of 1 + value of 0), so you rerun with position 1, but now the value of that position has been changed to 1 instead of 0
02:00:07 <merijn> Seems funky
02:05:36 <rzhanka> If I'm following you, that behavior is correct and explicitly noted in the problem statement.
02:06:38 <dminuoso> So atom just gave me the following recommendation from one of my editor plugins: https://gist.github.com/dminuoso/591d820a827eae37c27c989d85790d75
02:06:45 <dminuoso> This seems a little crazy to me.
02:06:57 <merijn> rzhanka: I don't know the problem, but that definitely seems different from the simple "sum" implementation you're comparing too?
02:07:15 <merijn> dminuoso: Probably HLint?
02:07:19 <dminuoso> Or is this something a proficient haskeller would do?
02:07:35 <merijn> dminuoso: tbh, I never use HLint since I consider most of the suggestions it triggers for me bad
02:09:05 <dminuoso> merijn: Mmm, not sure. hlint is not explicitly installed or listed under installed packages. Either way, this does seem a bit crazy no?
02:09:25 <rzhanka> merijn: the problem statement is here: http://adventofcode.com/2017/day/5 though it may require an account to see it
02:09:53 * hackage servant-generic 0.1.0.1 - Specify Servant APIs with records.  https://hackage.haskell.org/package/servant-generic-0.1.0.1 (PatrickChilton)
02:10:26 <dminuoso> merijn: Until now it has provided me with good hints though, though Im sure with some experience it will quickly outgrow its usefulness. But being hinted at extensionally equivalent but more concise writings I enjoy for now.
02:11:32 <merijn> dminuoso: I'm pretty sure you can disable individual hlint warnings, so I'd just toggle anything you don't like
02:16:56 <rzhanka> hm, I actually need to solve this in order to do part 2 of the problem as the sum method doesn't work for that
02:21:02 <sbrg> rzhanka: it's likely that you won't get very good performance for the 2nd part since it may required a quite a bit of crunching compared to the first
02:21:09 <sbrg> I ended up using a mutable vector for it
02:23:35 <pja> Yeah. Day5 part 2 takes forever if you copy the data every time.
02:23:56 <rzhanka> sbrg, hm, ok, I started off looking at MArrays then realized that Maps seemed more standard
02:24:55 <pja> Use a Mutable Unboxed Vector and it goes like stink...
02:25:07 <rzhanka> my understanding is that Map is implemented with a tree so it doesn't copy the data every time, but a static array would be a lot better
02:25:44 <muzzle> why does the Option type exist?
02:25:48 <rzhanka> ok, I'll take a look at that
02:26:11 <muzzle> the docs say it's because of a better monoid instance
02:26:16 <pja> rzhanka: There are some samples to look at on the adventofcode reddit day5 solutions if you get stuck.
02:26:22 <muzzle> but in what way is Option's instance better?
02:27:01 <merijn> muzzle: Which Option are you referring to?
02:27:19 <muzzle> merijn: the one in Data.Semigroup
02:27:59 <merijn> muzzle: ok, so that one is better because it is properly the free monoid on semigroups, which Maybe is not
02:28:15 <merijn> muzzle: i.e. "instance Semigroup m => Monoid (Option m)"
02:28:40 <muzzle> but isn't that already a necessity in the current class hierarchy?
02:28:40 <merijn> muzzle: Maybe has "instance Monoid m => Monoid (Maybe m)", which is overly strict
02:28:48 <Darwin226> Say I have lenses a, b and c, but the b lens focuses on a Maybe value. How can I compose them so that the ultimate result is a Maybe value?
02:29:01 <Darwin226> like x ^. a . b . c
02:29:03 <merijn> muzzle: Not all Semigroups are monoids, so you can't use Maybe for all semigroups
02:29:12 <Gurkenglas> x ^? a . b . _Just . c
02:29:33 <muzzle> merijn: But couldn't that easily be fixed? This shouldn't break any code, right?
02:29:52 <Darwin226> Gurkenglas: Well I've tried that and it says it can't match Maybe Something with First Something
02:30:01 <merijn> muzzle: Define easy ;)
02:30:47 <Gurkenglas> Darwin226, paste the full error pls?
02:30:56 <Darwin226> Gurkenglas: x ^. b and x ^? b . _Just should be the same thing, right?
02:31:42 <Darwin226> Couldn't match type `Maybe Day' with `First Day'     arising from a use of `ERP.datum' 
02:31:44 <Darwin226> in df ^? ERP.datum . _Just
02:32:38 <Gurkenglas> Just [1,2,3] ^? _Just . _head, for example, is Just 1
02:33:22 <Darwin226> What about something like [1,2,3] ^? _head . _Just=
02:33:25 <Darwin226> ?
02:33:25 <muzzle> merijn: maybe I'm missing something but couldn't Maybe's monoid instance just be replaced with Option's because it's constraint is more general?
02:33:44 <Gurkenglas> Darwin226, there is no Maybe to _Just into in that list
02:33:55 <merijn> muzzle: Maybe, but realise that Semigroup was only moved into base very recently
02:34:02 <Darwin226> Doesn't the _head lens return a maybe?
02:34:18 <Gurkenglas> No, the _head traversal goes over each first value in the list
02:34:26 <Gurkenglas> (0 or 1 of them, that is)
02:34:48 <Darwin226> Hmh... 
02:35:51 <Gurkenglas> Darwin226, what library is ERP.datum from?
02:36:28 <Darwin226> So let's say `data A = A { _a :: Maybe B }; data B = B { _b :: Int }`. How can I do something like `res = (x :: A) ^. a . b`?
02:36:50 <Darwin226> Gurkenglas: It's a part of my project
02:37:19 <Gurkenglas> x ^? a . _Just . b
02:38:07 <Gurkenglas> > (2, Just (3, 4)) ^? _2 . _Just . _1
02:38:10 <lambdabot>  Just 3
02:38:23 <Darwin226> I see
02:38:30 <Darwin226> So the problem is somewhere else
02:38:42 <Darwin226> Ok, thanks, I'll try to track it down
02:42:55 <rzhanka> merijn sbrg pja: thanks, I'll give it another try tomorrow when I'm more awake
02:48:52 * hackage mixed-types-num 0.3.1.4 - Alternative Prelude with numeric and logic expressions typed bottom-up  https://hackage.haskell.org/package/mixed-types-num-0.3.1.4 (MichalKonecny)
02:49:05 <bjgirl> hi
02:49:44 <bjgirl> are you all experts? i am not
02:50:10 <treg> bjgirl: I'm currently trying to learn how to install dependencies :)
02:50:30 <bjgirl> sorry
02:56:22 * hackage aern2-real 0.1.0.3 - Exact real numbers via Cauchy sequences and MPFR  https://hackage.haskell.org/package/aern2-real-0.1.0.3 (MichalKonecny)
03:03:39 * hackage aern2-real 0.1.1.0 - Exact real numbers via Cauchy sequences and MPFR  https://hackage.haskell.org/package/aern2-real-0.1.1.0 (MichalKonecny)
03:08:47 <seveg> !bot
03:11:46 <tomlukeywood> how would I define the Fibonacci sequence using list evaluation?
03:11:46 <tomlukeywood> could i do something like this?
03:11:46 <tomlukeywood> let fib = [ (a,b) | a <- [1..], b <- [1..] + a ]
03:11:56 <linduxed> someone asked me if, for functional programming, there's some equivalent set of books that compare to the various OOP books that often get recommended
03:12:06 <linduxed> the various design pattern books
03:12:56 <linduxed> which made me kind of answer "well, most of those patterns are either already inherent parts of the FP language you might be using, or you could reuse some of the design patterns you use in OOP"
03:13:36 <tdammers> design patterns in haskell tend to be either more obvious (the types don't leave you much choice other than the right one), or such that they can be baked into actual code (in the form of a library)
03:13:57 <linduxed> that's basically my perspective, yes
03:14:06 <tdammers> many of the patterns and abstractions we use fill the same or similar niche as some OOP design pattern, but the approach is often diffeent
03:14:09 <lionrouge> hi !
03:14:24 <linduxed> hmmm, i'm thinking i'll simply send the guy this link: http://alexott.net/en/fp/books/
03:14:25 <Ferdirand> tomlukeywood: you can do: fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
03:14:26 <lionrouge> could you help me? I fail at installing ghc-mod under Windows 10: https://dpaste.de/uFmR
03:14:32 <Lowl3v3l> linduxed: i think its the other way around. there are generally good design patterns that got adopted by oop folks so now everyone believes it belongs to oop^
03:14:42 <fakenullie> См
03:14:51 <linduxed> Lowl3v3l: yeah, dependency injection being one often thrown around
03:14:54 <fakenullie> Ferdirand: zipWith (+)
03:14:56 <tdammers> e.g., in OOP you have the Factory, but its purpose is just to get polymorphic implementations of some behavior from a central source and through a common interface
03:14:59 <Ferdirand> fakenullie: i know
03:15:01 <linduxed> Lowl3v3l: or the factory pattern
03:15:08 <Ferdirand> but they are unlikely to know about it at this stage
03:15:11 <linduxed> tdammers: yeah
03:15:18 <Ferdirand> "zip `ap` tail" too
03:15:30 <fakenullie> Ok
03:15:46 <tdammers> in OOP, that interface is an abstract class or an interface, the polymorphic behavior is wrapped in a class method, and the factory is a function of class that constructs compatible objects and returns them by interface
03:16:37 <tdammers> but in Haskell, the interface is just a plain old type, typically a function type, the polymorphic behavior is wrapped in a value of that type, and the factory is just a function that returns such a value
03:16:50 <tdammers> it's so simple that you wouldn't even call it a pattern
03:17:13 <tdammers> in fact, it's often so simple that there is barely any implementation to speak of
03:17:37 <tdammers> e.g., suppose you have a system that can load binary data from either a file, or a database, or an HTTP request body
03:17:53 <tdammers> so you want something like AppContext -> IO ByteString as your interface
03:18:08 <tdammers> and then your "factories" are just names that you bind suitable functions to
03:18:53 <tdammers> or maybe, just maybe, you have an ADT like data BackendType = FileBackend FilePath | RequestBodyBackend | DatabaseBackend DSN
03:18:56 <quchen> There’s a great post by Edward Yang where he goes through all the GoF patterns and talks about what they correspond to in Haskell.
03:19:08 <tomlukeywood> Ferdirand: that works but i dont quiet understand the syntax
03:19:08 <tomlukeywood> where should i look for information?
03:19:16 <tdammers> and then you have a function mkBackend :: BackendType -> (AppContext -> IO ByteString)
03:19:19 <brynedwards> lionrouge: Did you run `cabal update` before `cabal install ghc-mod`?
03:19:25 <tdammers> quchen: link?
03:19:36 <lionrouge> brynedwards, nope :)
03:19:54 <quchen> tdammers: http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
03:20:15 <linduxed> quchen: good link!
03:20:23 <lionrouge> i did it (cabal update) now and it doesn't help
03:20:47 <Ferdirand> tomlukeywood: zip is required unless you want to use the parallel list comprehension extension
03:20:49 <tdammers> quchen: nice, thanks
03:20:52 <Rembane> The interprer pattern is really nice in Haskell.
03:21:00 <Rembane> Create an EDSL and rock your socks off!
03:21:07 <quchen> …like IO, for example.
03:21:17 <Ferdirand> because if you do [ (a,b) | a <- [...], b <- [..] ], you get the cartesian product of a and b
03:21:21 <quchen> A DSL for effectful things. :-)
03:21:23 <brynedwards> lionrouge: i don't know then, sorry.
03:22:23 <Ferdirand> tomlukeywood: [ ... | (a,b) <- zip as bs ] lets you match the lists as and bs element by element
03:22:56 <tomlukeywood> Ferdirand: what is as and bs?
03:23:24 <quchen> You can also write [ a+b | a <- […] | b <- […] ] using -XParallelListComprehensions I think.
03:26:22 <tomlukeywood> ghci
03:26:32 * tomlukeywood typed by mistake
03:29:26 <Aleksejs> > let fib = 0:[x|x<-scanl (+) 1 fib] in take 10 fib -- :)
03:29:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
03:30:47 <Aleksejs> it's the same as let fib = 0 : scanl (+) 1 fib
03:43:52 * hackage tasty-rerun 1.1.8 - Run tests by filtering the test tree depending on the result of previous testruns  https://hackage.haskell.org/package/tasty-rerun-1.1.8 (OliverCharles)
03:47:52 <Younder> that would make it just like Lisp 
03:48:37 <Younder> With all the performance problem this cons'ing has
04:02:24 <quchen> > fix((0:).scanl(+)1) -- for clarity
04:02:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:03:16 <Taneb> "clarity"
04:03:34 <fakenullie> :t fix
04:03:35 <lambdabot> (a -> a) -> a
04:03:46 <Philonous> @src fix
04:03:46 <lambdabot> fix f = let x = f x in x
04:04:28 <quchen> Fix is the fixed point function, which is one primitive to introduce recursion.
04:04:46 <fakenullie> I know but details are still elusive to me
04:04:58 <quchen> fakenullie: Maybe this is helpful then, https://github.com/quchen/articles/blob/master/fix.md
04:10:04 <lionrouge> haskell-platform installs mingw but looks like it doesn't help with packages with .configure scripts
04:14:02 <fakenullie> I didn't realize that you can fix lazy list instead of function
04:14:13 <fakenullie> well, no it's still a function
04:17:05 <quchen> Well, fix takes a function as first parameter.
04:17:25 <fakenullie> right, it would be a type error
04:18:25 <quchen> > fix (1:) -- = 1 : fix (1:) = 1 : 1 : fix (1:) = …
04:18:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:19:17 <fakenullie> > fix (+1)
04:19:19 <lambdabot>  *Exception: <<loop>>
04:19:30 <quchen> That won’t work, because (+) is strict in both arguments for integers.
04:23:11 <Aleksejs> fakenullie: this might help https://www.vex.net/~trebla/haskell/fix.xhtml
04:24:16 <fakenullie> @pl let zeroes    = 0 : zeroes in zeroes
04:24:16 <lambdabot> fix (0 :)
04:52:25 <WinterFox[m]> Whats a good library for downloading things over HTTPS?
04:52:46 <WinterFox[m]> The hackage wiki thing didn't have a whole lot of info.
04:54:51 <sbrg> WinterFox[m]: req is nice iirc
04:54:54 <sbrg> https://hackage.haskell.org/package/req-1.0.0/docs/Network-HTTP-Req.html
04:57:53 <WinterFox[m]> sbrg: Oh nice that one actually has docs
04:59:00 <Unhammer> in an xml-conduit error like
04:59:01 <Unhammer> ParseError {errorContexts = [], errorMessage = "Failed reading: takeWhile1", errorPosition = 11525237:1}
04:59:04 <Unhammer> – is errorPosition the byte position in input?
04:59:51 <sbrg> that seems likely
05:00:17 <Unhammer> I see no xml error there :(
05:00:50 <Unhammer> in fact, it's in the middle of the name of a tag 
05:00:53 <Unhammer> arghs
05:12:00 <int-e> Unhammer: it's a line and column number
05:12:55 <int-e> Unhammer: (Provided I've tracked this down to the right parser: see https://hackage.haskell.org/package/conduit-extra-1.2.1/docs/src/Data-Conduit-Attoparsec.html#line-61 )
05:16:11 <Unhammer> oooh … thanks int-e
05:17:30 <sgronblo> Can I create an IO value that contains an infinite sequence and somehow do take n on that without having a stack overflow?
05:17:44 <Unhammer> hah:
05:17:45 <Unhammer> <Store name ="Foo "Bar"">
05:17:55 <sgronblo> Or do I need some sort of specific FRP stream type
05:21:15 <tdammers> define "contains"
05:22:59 <tdammers> do { r <- newIORef [1..]; take 10 <$> readIORef r } -- isn't going to stackoverflow
05:26:23 <quchen> sgronblo: Your code does just that.
05:27:07 <quchen> sgronblo: The stack grows when pattern matching, or more accurately while you’re evaluating the XXX in »case XXX of«.
05:27:43 <quchen> So the only way to get stack overflows is by nested case expressions, »case case case … of of of«.
05:28:09 <callmecabman> how about f x = case x of .. -> f (g x) ..?
05:28:13 <quchen> …and by using nested partially applied functions, but I think that happens much less in practice.
05:28:33 <quchen> callmecabman: That uses a single stack frame while evaluating the x.
05:28:50 <quchen> (Plus whatever f and g might do.)
05:29:18 <callmecabman> how do you call it? tail call optimisation?
05:30:03 <quchen> This isn’t related to tail calls. The stack Haskell/GHC uses is different from the stack in other languages like C, Python, Java.
05:30:50 <quchen> In C, the stack contains stack variables and return addresses. In Haskell, it contains pattern matches and partially applied functions.
05:31:13 <callmecabman> ik, but let's pretend I wear my roughness glasses and stupidity hat
05:32:15 <quchen> It doesn’t have a name in this context, just like »switching« does not have a name when talking about stacks in C. :-)
05:32:34 <merijn> callmecabman: Basically, GHC Haskell doesn't have a function call stack at all
05:32:37 <callmecabman> quchen: that was helpful
05:32:53 <merijn> callmecabman: So there's no point in having tail call optimisation (which tries to prevent call stack growth on recursive calls)
05:33:47 <quchen> Well, tail calls often lead to not having to recursively pattern match, so tail calls do have their uses. But it’s situational.
05:35:27 <quchen> For example, foldl will not cause a stack overflow, but it will build a thunk that when evaluated will cause the stack to overflow.
05:36:10 <quchen> But before that, it will try to overflow the heap ;-)
05:36:38 <fakenullie> should I go for tail call then?
05:36:45 <callmecabman> so you just foldl'?
05:36:47 <fakenullie> or it doesn't matter
05:37:09 <quchen> callmecabman: foldl' solves the typical »sum of numbers« problem, yes.
05:37:53 <callmecabman> is there something like {-# LANGUAGE StrictEvaluationByDefault #-} btw?
05:37:58 <quchen> fakenullie: Depends on your application. Forcing tail recursion makes your code harder to read, so it’s not a good idea to apply it mindlessly.
05:38:19 <callmecabman> besides Idris
05:38:39 <quchen> callmecabman: There’s a strict language extension. But then you lose the goodness that non-strictness provides you with.
05:38:46 <quchen> It’s like the space/time tradeoff.
05:38:59 <quchen> Laziness often saves you time, which people rarely mention online.
05:39:07 <quchen> (Often, the amount of time saved is infinite.)
05:39:38 <quchen> fakenullie: And just being tail recursive does not save you from leaks. foldl is tail recursive, but you can use it to create leaks.
05:39:48 <tdammers> laziness also allows for some very useful patterns that tend to make code vastly more readable
05:39:49 <callmecabman> quchen: the first thing that striked me was laziness+unfoldr obviates the need for dynamic programming for some algos
05:40:04 <merijn> Tail recursion provides you with a place to add strictness
05:40:12 <tdammers> evaluation order becomes a transparent implementation detail
05:40:13 <quchen> Well said.
05:41:02 <merijn> callmecabman: I prefer lazy over strict, because solving the issue of "too lazy" can be done with a single local strictness annotation. Whereas "fixing" too strict requires every input of your computation be made lazy, so no local fix is possible
05:41:06 <dminuoso> callmecabman: Im starting to appreciate infinite recursion because it feels mathematically more sound.
05:41:32 <dminuoso> Although Ive started getting my first cases of "mysteriously not returning..."
05:42:25 <callmecabman> dminuoso: just draw the line between data and codata and everything is transparent
05:43:16 <dminuoso> wait.. codata?
05:43:56 <bollu> all of this sucks when compiling to "real" hardware, though :( 
05:44:07 <bollu> has there been any efforts towards "hardware for lazy languages"?
05:44:33 <dminuoso> First article.. "[...] To write an OS we need open-ended loops that keep running until the user explicitly chooses to shut the OS down. [...]"
05:44:34 <Taneb> bollu: there was some work at York a while back (google "reduceron")
05:44:36 <dminuoso> This just made me cry./
05:44:40 <bollu> Taneb interesting
05:45:29 <bollu> Taneb aww, it looks l like it died out ~2010
05:45:38 <callmecabman> dminuoso: Jacobs, Rutten - A tutorial on coalgebras and coinduction
05:45:46 <Taneb> bollu: its funding ran out
05:46:05 <callmecabman> dminuoso: Kieburtz - Codata and comonads in Haskell
05:46:05 <Taneb> Not many people are willing to pay a research group for niche hardware for lazy languages
05:47:21 <bollu> Taneb that is sad
05:47:24 <bollu> mm
05:48:21 <bollu> quchen hello : 
05:48:22 <bollu> :)
05:48:38 <merijn> bollu: There's been work in Twente too
05:48:41 <merijn> Taneb: ^^
05:49:00 <bollu> merijn any idea what the project is called?
05:49:02 <merijn> I'll ask how that's going in January on the Dutch FP day
05:49:22 * hackage jvm-streaming 0.2.2 - Expose Java iterators as streams from the streaming package.  https://hackage.haskell.org/package/jvm-streaming-0.2.2 (MathieuBoespflug)
05:50:26 <Taneb> merijn: I'm aware of CLaSH, is that what you mean?
05:51:14 <merijn> Taneb: No, ClaSH is a DSL for hardware design. There was/is a phd student in the same group working on designing a CPU for lazy languages, he started like 1 or 2 years ago
05:51:29 <Taneb> merijn: ooh, that sounds interesting!
05:51:33 <callmecabman> cloud is the new hardware and we have the Galois, Inc
05:51:57 <callmecabman> they've got a funny halvm
05:52:04 <merijn> Taneb: I dunno what happened with his work, though. But January 5th is the anual Dutch FP day, so I'm bound to run into him/his colleagues then
05:52:54 <bollu> I want to intern at Galois at some point, they seem very cool. 
05:53:43 <Taneb> bollu: I think I know a couple of people there, from what I've heard it's all very cool
05:53:51 <bollu> Taneb neat :)
05:54:05 <bollu> Taneb I'll try and apply for 2019, let's see how it goes
05:54:31 <quchen> Hi bollu :-)
05:54:38 <Taneb> bollu: best of luck!
05:55:46 <bollu> Taneb heh, thanks!
06:24:35 <dminuoso> https://gist.github.com/dminuoso/e9f00a8ac4924c42b96a9e17cc076e8e is there a cleaner way to abstract this away? This feels quirky with all those `pop`s
06:25:46 <Taneb> dminuoso: I can't see an obvious way to neaten it up
06:25:54 <Taneb> You may be able to use the replicateM function here though
06:25:57 <Taneb> :t replicateM
06:25:58 <lambdabot> Applicative m => Int -> m a -> m [a]
06:26:46 <dminuoso> Taneb: I tried thinking about it, but that gave my head a twist with types. 
06:27:09 <Taneb> dminuoso: I'd just pattern match on the list, if the number is fixed the length of the lsit is fixed to that type
06:27:26 <Taneb> Something like "case replicateM 4 pop of [a,b,c,d] -> push $ op a b c d"
06:27:37 <Taneb> Whether this is neater or not is up to you ;)
06:29:18 <dminuoso> Taneb: yean no.. :P
06:34:17 <dminuoso> Though I guess its time to revisit monad transformers and figure out how to make this whole thing not crash if the stack is not maintained properly.
06:41:37 <tiao> Hey guys! If I do `dup f x = f x x :: (a -> a -> b) -> a -> b`, then I can do `dup (.) (/2) 42` but I can't `dup (.) (:[]) 42` or `dup (.) pure 42`..
06:42:02 <tiao> Can I redefine `dup` in a way that at least `pure` works?
06:46:21 <chpatrick> tiao: I don't think so, but what's the point?
06:46:25 <ertes-w> tiao: not directly
06:46:36 <Aleksejs> is there something like repeatM?
06:46:41 <ertes-w> tiao: RankNTypes would give you some options, but probably not many useful ones
06:46:47 <kahlil29> I have a list of integers and I want to use that to create a Set data type of unique elements from the list. What's the best way to do that? 
06:46:48 <tiao> Hm, not a practical one
06:47:03 <ertes-w> Aleksejs: sequence . repeat
06:47:12 <chpatrick> Aleksejs: forever?
06:47:30 <ertes-w> Aleksejs: but note that most monads can't handle this
06:47:53 <ertes-w> Aleksejs: only something like lazy writer or lazy state
06:49:23 <Unhammer> how would I enumerate lines with conduit (like `zip [1..] list`)?
06:49:25 <Unhammer> can't find anything like "zip" there
06:50:17 <Psybur> Unhammer, you can zip sources
06:51:52 <ertes-w> Unhammer: see ZipSource
06:52:15 <Psybur> Unhammer, https://hackage.haskell.org/package/conduit-1.2.12.1/docs/Data-Conduit.html#t:ZipSource
06:52:37 <Unhammer> oh, it's in Data.Conduit.Infernal
06:52:48 <ertes-w> Unhammer: getZipSource (liftA2 (,) (ZipSource xs) (ZipSource ys))
06:53:04 <ertes-w> it's in (or at least reexported from) Data.Conduit
06:55:17 <Unhammer> oh.. I saw that, but thought "no tuples there – that's not what I want" heh
06:55:19 <Unhammer> thanks ertes
06:55:21 <Unhammer> -w
06:56:41 <callmecabman> Unhammer: is it a well known practice to export all the highlevel stuff in PackageName and imprison the implementation in Package.Infernal?
06:57:31 <Unhammer> the best Package Masters do so, I believe
06:57:37 <callmecabman> Structuring packages for functional programs is still an elusive concept for me
06:58:33 <ertes-w> what works for me is to keep the dependency graph as flat as possible
06:58:44 <merijn> callmecabman: Why would it be any different than in other languages?
06:59:06 <ertes-w> have a .Core module, potentially a .Types and/or .Class module and have everything else depend on those, but as much as possible not on each other
06:59:43 <callmecabman> btw what if I have one dependency in my deplist that wants the infamous lens? Can I just inject microlens or my own solution into it?
07:00:12 <byorgey> callmecabman: no, not really.
07:00:36 <Taneb> callmecabman: lens isn't really that big of a dependency any more
07:00:52 <byorgey> callmecabman: I mean, you would have to go get the source code for that dependency, and manually change it to use microlens instead of lens, and then compile against the modified version
07:00:54 <callmecabman> ertes-w: that's confusing, I do almost always end up with something like .Types or .SharedStuff and a bunch of unrelated lego pieces
07:02:00 <ertes-w> callmecabman: sounds reasonable
07:04:13 <callmecabman> merijn: in other languages there's usually no need/way to abstract something heavy for free
07:04:42 <sgronblo> Is it not possible to specify extra-deps when using Stack in script interpreter mode?
07:06:17 <callmecabman> thanks byorgey, ertes-w
07:12:08 <bxc> raspberry pi gpio module wants access to /dev/mem
07:12:11 <bxc> that kinda scares me
07:14:48 <bxc> the python module that is
07:17:15 <orion> monad-time doesn't have a transformer such as "TimeT". What functionality do I lose by it not being there?
07:19:23 * hackage serokell-util 0.5.2 - General-purpose functions by Serokell  https://hackage.haskell.org/package/serokell-util-0.5.2 (gromak)
07:20:05 <ertes-w> orion: what would TimeT even do?
07:20:08 <c_wraith> orion: it doesn't have a non-transformer monad either.  All it has is a class, and the only instances are IO and things that transform IO
07:20:20 <Tritlo> If I'm in IO anyway for a toy project, is there any point in using STArray over IOArray?
07:20:25 <c_wraith> orion: so..  There's no IOT, either!
07:20:44 <c_wraith> Tritlo: it's nice to isolate mutability if you can.
07:21:11 <ertes-w> Tritlo: if part of it is pure, using ST makes it more flexible
07:22:12 <ertes-w> Tritlo: if you want to abstract IO/ST away completely you should switch to the more modern 'vector' library
07:22:26 <Tritlo> Alright, cool. Does stToIO do any magic to make STArrays into IOArrays
07:22:42 <c_wraith> Tritlo: but really, it depends on *how* toy it is.  if you're never going to touch the program again, whatever.  If you're writing a dumb example to share, it's worth putting some additional care into your choices.
07:22:52 <ertes-w> Tritlo: no
07:24:01 <Tritlo> ertes-w: yeah, but so far I've gotten away with using only things in base, so I'd rather not add any dependencies
07:24:11 <ertes-w> Tritlo: but stToIO is what is called a monad morphism:  ∀ c f, stToIO (c >>= f) = stToIO c >>= stToIO . f
07:24:23 <ertes-w> Tritlo: *Array aren't in base
07:24:36 <c_wraith> they are part of GHC though
07:24:51 <c_wraith> no need to use a package manager to get them
07:24:56 <Tritlo> ertes-w: I meant part of ghc :)
07:25:13 <Tritlo> i.e. stack exec -- ghci in a non project allows "import Data.Array", which is nice
07:25:23 <ertes-w> well, as far as a GHC user is concerned 'array' is for all intents an purposes a separate library you need to depend on
07:26:35 <c_wraith> ertes-w: if you're managing packages, yes.  If not, it's installed as an exposed package by ghc.  It's just there.
07:27:11 <ertes-w> Tritlo: technically IO and ST are the same thing and similarly ST*Array and IO*Array are the same as well…  the types are different, but you can freely go from ST to IO
07:27:28 <merijn> ertes-w: I disagree
07:27:29 <ertes-w> Tritlo: which means that you can use ST*Array all the way through and just wrap every array operation with stToIO
07:27:36 <merijn> They're not "technically the same"
07:27:46 <merijn> They are both implemented using the same underlying mechanism
07:27:55 <merijn> But that's not the same thing as being the same
07:27:56 <Tritlo> ertes-w: Alright, I've just seen some Stackoverflow answers about IO being more performant, having to avoid indirection in makeOff or something like that
07:28:01 <ertes-w> yeah, sorry…  operationally/internally the same
07:28:16 <merijn> Tritlo: It's doubtful IO would be faster than ST, imo
07:28:17 <Tritlo> ertes-w: but I was hoping that since ST is so baked in to GHC that stToIO was really clever about it
07:28:19 <ertes-w> Tritlo: no, internally IO and ST are literally the same type
07:28:49 <ertes-w> Tritlo: stToIO should really just vanish
07:28:56 <ertes-w> at least with -O
07:28:57 <merijn> Tritlo: I would expect any results showing IO to be faster than ST to be, most likely, coincidence
07:29:16 <Tritlo> hmm
07:29:18 <Tritlo> https://stackoverflow.com/questions/42956238/performance-difference-between-iouarray-and-stuarray-in-prime-sieve
07:30:18 <Tritlo> Apparently, IO is more inlineable in some cases?
07:30:25 <ertes-w> Tritlo: those aren't entirely the same
07:30:57 <ertes-w> not that it should make a major difference, but whether you use a lazy let-binding or an IO binding controls the order of effects
07:34:10 <Tritlo> Ah, I misunderstood the SO answer. Apparently the error isn't in ST vs IO per se., the user was just letting GHC infer a too general type for his functions, which caused less inlining
07:34:16 <ertes-w> Tritlo: if anything i would expect ST to have more potential to be faster, thanks to the way runST "delimits" ordering
07:41:22 * hackage lift-generics 0.1.2 - GHC.Generics-based Language.Haskell.TH.Syntax.lift implementation  https://hackage.haskell.org/package/lift-generics-0.1.2 (ryanglscott)
07:48:54 <Tritlo> Alright, nice. I'm wondering then, if stToIO isn't doing any magic, what is the difference then between using `(stToIO x)` instead of just `(return . runST) x`
07:50:54 <orion> ertes-w / c_wraith: Bah, you're right.
07:52:23 * hackage vinyl-gl 0.3.2 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  https://hackage.haskell.org/package/vinyl-gl-0.3.2 (AnthonyCowley)
07:55:20 <Tritlo> Whoops, I meant, diff between `stToIO x` vs. `return $ runST x`
07:56:12 <ertes-w> Tritlo: there is no difference, and i liked your first version much better ;)
07:57:24 <Tritlo> first version doesn't seem to typecheck though :(, at least GHCi complains about an escaping s
07:58:54 <ertes-w> Tritlo: oh, of course
07:59:10 <dminuoso> "Monad transformers are like onions. At first, they make you cry but then you learn to appreciate them. Like onions, they're also made of layers."
07:59:12 <dminuoso> :D
07:59:28 <dminuoso> The haskell wiki has quite a bit of humor at times.
07:59:31 <Tritlo> :t stToIO
07:59:33 <lambdabot> ST RealWorld a -> IO a
07:59:42 <Tritlo> :t (return . runST)
07:59:43 <lambdabot> error:
07:59:43 <lambdabot>     • Couldn't match type ‘a’ with ‘forall s. ST s a1’
07:59:43 <lambdabot>       ‘a’ is a rigid type variable bound by
08:00:26 <ertes-w> dminuoso: actually the progression is more like this: first you love them, then they make you cry for years, then finally you start to realise that the idea of "application monad stacks" was stupid to begin with and learn to appreciate monad transformers for what they really are =)
08:01:50 <ertes-w> Tritlo: the reason i didn't like your latter variant is because of the ($)
08:02:00 <ertes-w> and perhaps because of the 'return'
08:02:07 <ertes-w> pure (runST x)
08:03:10 <dminuoso> ertes-w: What are monad transformers really?
08:03:20 <daey> dminuoso: at least i can touch onions, whereas monads appear to be quite elusive vaporware :')
08:03:22 * dminuoso prepares for a battery of category theory terms thrown his way
08:03:44 <ertes-w> dminuoso: look at the kind of MaybeT
08:03:53 <ertes-w> MaybeT :: (* -> *) -> (* -> *)
08:03:59 <ertes-w> it takes a monad and returns a monad
08:04:35 <concaveirc> Hi all, I am using hmatrix and am wondering if there is a normalize vector function?
08:04:48 <ertes-w> dminuoso: there is slightly more to a monad transformer, but that's the gist
08:05:25 <dminuoso> ertes-w: Oh then you're not telling me anything new! :)
08:05:36 <Rembane> It makes monads even more powerful.
08:05:58 <dminuoso> ertes-w: The way I looked at them today, was to see of them as "monad enhancers"
08:06:13 <ertes-w> dminuoso: it's much more rewarding to use monad transformers in an ad-hoc way: "in this piece of code i seem to be sequencing multiple checks for Nothing…  i'm gonna use MaybeT here"
08:06:27 <sgronblo> I prefer to think of them as monad wrappers
08:06:50 <ertes-w> dminuoso: unfortunately a very popular way to use them is to create "application monads" or "framework monads"
08:07:04 <ertes-w> especially in web dev
08:07:26 <ekr_> dminouso: have a look at https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
08:07:53 * hackage posix-socket 0.2 - Bindings to the POSIX socket API  https://hackage.haskell.org/package/posix-socket-0.2 (MikhailVorozhtsov)
08:07:54 <ertes-w> those monads don't really mean anything special…  they are really just stacked monad transformers, so you have this huge mess of effects and need to tailor everything to it
08:08:25 <ertes-w> that's the reason why brain twisters like monad-control exist…  not that they are completely useless, but often they are used to solve artificial problems
08:10:08 <Tritlo> dminuoso: The key for me when I finally "understood" monads and monad transformers was to realize that there isn't really that much to understand. A monad transformer just wraps a monad, and then you write in the monad that it transforms to, and then you "unwrap" the monad, essentially running the transformers code, giving you the wrapped monad
08:11:39 <f-a> cereal problem: apparently I am not able to autoderive Serialize instances. How to do it? http://lpaste.net/360546 
08:11:48 <orion> ertes-w: If you were trying to build a large application from scratch, would you reach for Monad transformers?
08:11:53 <Tritlo> dminuoso: it's kind of like sets. There are a lot of things that hold for sets, and sets are really useful for a lot of things, but in the end, it's really just a collection of objects. 
08:13:49 <orion> Actually, I'll ask a similar question: Are there (in your opinion) better solutions to the problem transformers attempts to solve?
08:14:46 <Minske> Hello. How can I get a function, which can produce strings like "ab", "aabb", "aaabbb", etc.? I tried list comprehension, etc., but I don't know where to start.
08:15:07 <dminuoso> Tritlo: I suppose in a way it's a composition of two monads.
08:15:23 <f-a> Minske: well, ad infinitum?
08:15:31 <Minske> f-a: yes.
08:15:38 <dminuoso> The type `m (Maybe a)` is actually quite indicative of such a composition
08:15:59 <dminuoso> ertes-w: So I suppose the point being, that transformers compose rather than stack right?
08:16:06 <f-a> Minske: maybe you can use map and then some concats
08:16:28 <Tritlo> dminuoso: Yes, but with a condition that one is wrapping the other. A to be a monad transformer, you only have to define one function, lift :: Monad m => m a -> t m a. 
08:16:48 <f-a> > (\i -> replicate i 'a' ++ replicate i 'b') 2
08:16:50 <lambdabot>  "aabb"
08:17:01 <dminuoso> Tritlo: That condition would not seem to constrain what I said though.
08:17:05 <f-a> map f [1..] etc etc, Minske 
08:17:05 <Tritlo> dminuoso: the main problem is that it gets very slow when you have stacks within stacks within stacks
08:17:14 <Minske> Thanks f-a!
08:17:16 <dminuoso> Tritlo: So the composition is not commutative.
08:18:24 <Tritlo> dminuoso: I suppose that's the right way to say it, yes.
08:18:33 <f-a> np, Minske 
08:18:45 <ekr> anyone has any ideas how i could get over this cabal error when installing hxt (http://lpaste.net/360547)? This is with a freshly built cabal. The erro is "Data.Binary.getPrim: end of file"
08:18:53 <f-a> if you want a long string, use concat
08:19:40 <dminuoso> ertes-w: I wonder, can I not see a monad transformer theoretically as (* -> *) -> (* -> *) -> (* -> *) ?
08:19:55 <f-a> ekr: and freshly nuked ~/.cabal?
08:19:59 <dminuoso> (Except that first parameter is implicitly filled by the precursor monad)
08:20:20 <ekr> f-a: yeah, had other errors so I decided to start from scratch
08:20:28 <ekr> also, rebuilt cabal from source
08:21:07 <ekr> Bad interface file : how is that even possible, since I'm using one ghc to build everything
08:21:32 <f-a> ekr: weird error, maybe the guys on #hackage know more
08:21:46 <ekr> thanks for the suggestion
08:22:14 <mnoonan> dminuoso: a monad is a (* -> *), so I can see (* -> *) -> (* -> *) for a monad transformer.. but where is your additional * -> * coming from?
08:22:22 <Tritlo> dminuoso: if you're transforming a transformer, the kind becomes ((*-> *) -> * -> *) -> (*-> *) -> (* -> *)
08:24:31 <dminuoso> mnoonan: Just on an abstract level. So for MaybeT you have the precursor Maybe (* -> *), the kind of your base monad (* -> *), and the kind of the resulting monad MaybeT (* -> *)
08:25:23 <mnoonan> dminuoso: ah, you're trying to think of a way to abstract the idea of going from Foo -> FooT?
08:25:34 <dminuoso> Yeah.
08:26:02 <ertes-w> dminuoso: why would you take the precursor monad as an argument, given that there is even one to begin with?
08:26:19 <ertes-w> dminuoso: it's more like the "precursor" follows from the monad transformer, not the other way around
08:26:31 <ertes-w> Maybe ≃ MaybeT Identity
08:26:32 <mnoonan> to me, it's more like the other way around.. FooT -> Foo by applying FooT to Identity
08:27:14 <dminuoso> ertes-w: Oh, that's interesting.
08:28:30 <orion> In fact, that's how Reader works: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#t:Reader
08:31:17 <dminuoso> ertes-w: That does not seem contradictory. Under the assumption that a monad transformer is the composition of two monad types to produce a monad type, then Identity would be the identity under that composition.
08:31:54 <EvanR> no
08:31:57 <ertes-w> dminuoso: that's off
08:32:07 <EvanR> the monad transformer is the arrow from one monad to another
08:32:15 <ertes-w> dminuoso: you can compose monad transformers, and the result is a monad transformer
08:32:25 <ertes-w> dminuoso: and IdentityT would be the identity of that composition
08:32:34 <dminuoso> I think we're on different paths here
08:32:44 <ertes-w> dminuoso: you can't compose monads
08:32:51 <EvanR> like a function is not the composition of a source type and dest type
08:32:53 <johnw> you can't compose them *generally*
08:33:14 <johnw> you can compose certain specific things that are monads
08:33:25 <mnoonan> ertes-2: I think what he is proposing is toTrans :: (* -> *) -> ((* -> *) -> (* -> *)), and define a composition of monads m <.> n = (toTrans m) n
08:33:37 <EvanR> you can or cant compose monad transformers generally?
08:33:41 <johnw> you cannot
08:33:50 <johnw> oh, composing monad *transformers*, that's another question
08:33:55 <ertes-w> monad transformers you can
08:33:56 <johnw> sorry, I was talking about composing monads
08:34:04 <Wizek> How would you guys describe how forM_ is possible in a purely functional language, such as Haskell? 
08:34:06 <dminuoso> mnoonan: Ah that captures the notion what Im trying to convey, yes.
08:34:30 <Wizek> I have a friend who recently started to become interested in immutability and by extension, FP. He was very surprised to learn that "for loops" exist.
08:34:35 <erisco> Wizek, by construction... QED
08:34:39 <mnoonan> dminuoso: the only problem is there is no such toTrans, I think :)
08:34:43 <ertes-w> monad transformers compose rather naturally…  in fact they form a monoid
08:34:45 <EvanR> Wizek: forM_ is a regular function written in the language, maybe you should look at the code?
08:34:51 <EvanR> @src forM_
08:34:51 <lambdabot> forM_ = flip mapM_
08:34:57 <EvanR> @src mapM_
08:34:57 <lambdabot> mapM_ f as = sequence_ (map f as)
08:35:09 <EvanR> @src sequence_
08:35:09 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:35:11 <dminuoso> mnoonan: Hence "in an abstract sense".
08:35:25 <erisco> Wizek, in other words, if you write it in Haskell, and you aren't using stuff out of the unsafe library, then it just is
08:35:31 <dminuoso> EvanR | the monad transformer is the arrow from one monad to another
08:35:32 <ertes-w> mnoonan, dminuoso: i'm not even sure what such a toTrans function would do
08:35:35 <dminuoso> EvanR: You mean in the category of monads?
08:35:47 <EvanR> i dont know
08:35:51 <ertes-w> well, actually toTrans looks like a type, so let's call it ToTrans
08:35:52 <mnoonan> ertes-w: the only law I can think of is (toTrans m) Identity = Identity
08:36:33 <ertes-w> well, maybe there is a principled way to go from (T Identity) back to T for some T
08:36:33 <mnoonan> oh, and I guess (ToTrans Identity) m = m
08:36:38 <ertes-w> but honestly i don't see the point
08:36:49 <ertes-w> and an obvious counterexample is IO
08:37:34 <ertes-w> in any case it seems easy enough to define as a type family
08:37:34 <erisco> Wizek, also forM_ is not a for-loop as is in procedural programming, so the surprise could just be based on this false equivalence
08:38:03 <dminuoso> ertes-w: Apologies. I think this has derailed a bit due to my naive understanding and inability to express myself well enough.
08:38:17 <ertes-w> @let type family Trans (m :: * -> *) :: (* -> *) -> * -> *
08:38:18 <lambdabot>  Defined.
08:38:28 <ertes-w> @let type instance Trans Maybe = MaybeT
08:38:29 <lambdabot>  .L.hs:163:29: error:
08:38:29 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
08:38:29 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
08:38:41 <ertes-w> @let import Control.Monad.Trans.Maybe
08:38:43 <lambdabot>  Defined.
08:38:43 <ertes-w> @let type instance Trans Maybe = MaybeT
08:38:44 <Wizek> EvanR: Yes, I know about how forM_ it defined. And yet I'm still unsure how to explain it without overwhelming someone who is new to all this. I even managed to stay away from the oft-dreaded M-word in the last week or so since his interest started
08:38:44 <mnoonan> (ToTrans a) ((ToTrans b) c) ~ (ToTrans ((ToTrans a) b) c  -- probably this too
08:38:45 <lambdabot>  Defined.
08:38:45 <EvanR> also forM_ is not limited to sequencing IO actions
08:38:52 <Wizek> *is
08:39:07 <ertes-w> dminuoso: ^ you can do that, but it's rather pointless, because you couldn't usefully abstract over it
08:39:27 <ertes-w> dminuoso: from a Trans instance does not follow a MonadTrans instance or even a Monad instance
08:39:27 <dminuoso> ertes-w: My point was not meant to be something that made sense in Haskell directly.
08:39:28 <EvanR> Wizek: ah, now that is another question... how best to explain it... to someone that what, thinks its the way to execute a list of IO actions?
08:39:35 <erisco> Wizek, most generally speaking, loops are done by recursion, so you might just say that
08:39:38 <EvanR> maybe start by saying thats not what it does
08:39:55 <ertes-w> dminuoso: i think it's still important to understand what's wrong with that idea =)
08:40:36 <ertes-w> actually i do see one use case
08:40:53 * hackage wrecker 1.2.3.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-1.2.3.0 (lorenzo)
08:41:07 <ertes-w> @undef
08:41:07 <lambdabot> Undefined.
08:41:17 <EvanR> Wizek: forM_ takes a list, applies a function to get a list of actions, then replaces (:) in the list with (>>)
08:42:04 <Wizek> EvanR: okay, let me try to discuss from his pov: sure, that's nice, but in the end what happens is the list of mutable actions are executed (in IO) one after the other, no?
08:42:15 <ertes-w> @let class (Monad m) => MonadToTrans m where type Trans m; toTrans :: (Monad n) => m a -> Trans m n a
08:42:17 <lambdabot>  .L.hs:162:40: error:
08:42:17 <lambdabot>      • Expecting two fewer arguments to ‘Trans m’
08:42:17 <lambdabot>        Expected kind ‘(* -> *) -> * -> *’, but ‘Trans m’ has kind ‘*’
08:42:27 <ertes-w> seriously, you can't infer that, GHC?
08:42:29 <EvanR> Wizek: no, a single action is executed in the end
08:42:34 <EvanR> called main :: IO ()
08:43:18 <ertes-w> @let class (Monad m, MonadTrans (Trans m)) => MonadToTrans m where type Trans m :: (* -> *) -> * -> *; toTrans :: (Monad n) => m a -> Trans m n a
08:43:19 <EvanR> one way to make one is with forM_ :: [a] -> (a -> IO ()) -> IO ()
08:43:19 <lambdabot>  Defined.
08:43:23 <erisco> Wizek, if you want to explain IO then my suggestion is to say that Haskell lets you construct a sequence of instructions which are then executed by the runtime. In that sense, it is just the runtime causing effects.
08:43:38 <ertes-w> dminuoso: ^ this might be useful, if you require that toTrans is a monad morphism
08:43:41 <EvanR> but ultimately the only way to build them up is with >>=
08:43:52 <EvanR> forM_ is defined in terms of that
08:44:36 <EvanR> that you are making 1 IO action is an important difference from "executing a list of IO actions" i think
08:44:39 <dminuoso> ertes-w: So my attempt to convey some thought I had to derive intuition was failed by the fact that I used kinds. Despite my decoration of "in an abstract sense" you seem to have misunderstood this as some way of stating it should be possible.\
08:44:50 <Wizek> erisco: Yes, and I'm aware of that too, and how IO is neatly defined as `RealWorld -> RealWorld`, but I'm afraid that's a hard distinction for me to argue. Because in the end it will work quite the same as similarly written imperative code, now
08:44:59 <EvanR> like a sum is a number, not a bunch of numbers that you sum
08:45:23 <Wizek> erisco: s/now/no?/
08:45:25 <EvanR> but it was made of a bunch of numbers
08:45:44 <EvanR> IO is not defined as RealWorld -> RealWorld at all
08:46:07 <ertes-w> dminuoso: i do understand that you mean this conceptually, and i've turned this into a concrete haskell concept in the last @let
08:46:16 <dminuoso> Oh.
08:46:19 <erisco> that's the naive idea which doesn't account for asynchronous exceptions and concurrency
08:46:24 <EvanR> Wizek: are you confused? or are you still trying to argue from their perspective
08:46:50 <EvanR> erisco: its a new idea to me, literally RW -> RW. 
08:46:52 <ertes-w> dminuoso: MonadToTrans goes from M to T, where T Identity ≃ M
08:46:53 <erisco> but you can use that as an example of how you could explain changes in the real world in a functional setting
08:46:56 <dminuoso> ertes-w: Well I got lost a bit on the way when you started to use type families.
08:47:06 <EvanR> its wrong but we shouldnt treat it like ye olde misconception
08:47:18 <ertes-w> dminuoso: let me just write an example instance for MonadToTrans, then it should be rather obvious what it is
08:47:39 <ertes-w> @let import Control.Monad.Trans.Maybe
08:47:41 <lambdabot>  Defined.
08:47:53 <erisco> that's just if you want to be technical though… it isn't really your job to say the perfect thing so your friend understands
08:48:00 <ertes-w> @let instance MonadToTrans Maybe where type ToTrans Maybe = MaybeT; toTrans = MaybeT . pure
08:48:01 <lambdabot>  .L.hs:166:14: error:
08:48:01 <lambdabot>      ‘ToTrans’ is not a (visible) associated type of class ‘MonadToTrans’
08:48:01 <lambdabot>      |
08:48:05 <erisco> they have to take your word for it and investigate themselves
08:48:16 <ertes-w> @let instance MonadToTrans Maybe where type Trans Maybe = MaybeT; toTrans = MaybeT . pure
08:48:17 <lambdabot>  Defined.
08:48:21 <ertes-w> dminuoso: ^
08:48:33 <ertes-w> Trans M is the transformer version of M
08:48:52 <ertes-w> and toTrans is the corresponding monad morphism that lets you encode M-effects in (Trans M)
08:49:38 <erisco> Wizek, and the way it distinguishes from other languages is entirely in the semantics, which isn't something you necessarily want to get lost in the weeds with for this particular issue
08:49:49 <ertes-w> dminuoso: for example (toTrans Nothing) translates Nothing into MaybeT's version of it
08:49:57 <ertes-w> which is (MaybeT (pure Nothing))
08:50:05 <EvanR> Wizek: think of a value of IO X as being an unknown imperative program to run on some runtime system (not haskell) which does something and may eventually return a value of type X. that is the most honest model i think
08:50:19 <EvanR> haskell can munge these values functionally, but not execute them
08:50:26 <EvanR> luckily it doesnt have to execute them
08:50:28 <erisco> Wizek, unless your friend is already keen on what semantics are
08:50:43 <Wizek> erisco: I don't yet think so :)
08:51:00 <erisco> most programmers aren't, which I conjecture with no data
08:51:04 <EvanR> neither are munging values of type RealWorld
08:51:05 <ertes-w> @let instance MonadToTrans ((->) e) where type Trans ((->) e) = ReaderT e; toTrans f = ReaderT (pure . f)
08:51:07 <lambdabot>  Defined.
08:51:29 <ertes-w> dminuoso: ^ here is another example: going from ((->) e) a.k.a. (Reader e) to (ReaderT e)
08:51:32 <Wizek> EvanR: I like that last description, I might be able to give him that.
08:51:39 <erisco> if my friend asked me these sorts of things then I'd just go through some examples with them
08:51:41 <mnoonan> Wizek: you could even have them think of an IO X as some C *source code*, that will produce an X when compiled and run (with the caveat that this really is *not* what is happening!)
08:52:02 <erisco> and if they have questions they can point to specific parts and ask "how does that work?" and it drives the conversation
08:52:15 <EvanR> that might add confusion if they try to figure out literally what the C source code would look like to make that make sense
08:52:59 <mnoonan> yeah, it's a bit shaky. but that perspective does help explain why you can't freely "get the X" out of an IO X
08:53:22 <erisco> you can get some stuff out of IO… specify how that works… couldn't tell ya
08:53:45 <leshow> I'm talking to a friend who writes a lot of flow/ts. The language supports mixing value level and type level constructs, for isntance type Foo = "hello" | "world" is a valid type. Is there a reason haskell doesn't allow this kind of thing?
08:54:19 <leshow> As I understand it the way to do it in haskell would be to make a unary type constructor data Foo = Hello | World and write an Enum instance for it
08:54:31 <EvanR> i think that is saying something like data Foo = Hello | World
08:54:50 <EvanR> but they reuse strings instead
08:55:04 <erisco> leshow, what are the inhabitants of your proposed type?
08:55:20 <leshow> erisco: which one
08:55:24 <EvanR> Enum is tangential
08:55:30 <erisco> type Foo = "hello" | "world"
08:55:56 <leshow> Foo is either "hello" or "world"
08:56:21 <erisco> giving types to languages without sum types… adorable… okay
08:56:31 <EvanR> leshow: are you asking why should we have types other than strings? or are you asking why cant we restrict a string type to only two string values?
08:56:42 <ertes-w> Wizek: haskell can be thought of as a meta-language in that regard…  we are dealing with "actions" as first-class objects…  that's one reason why things like 'catch' are regular functions in haskell
08:57:09 <EvanR> the first one has a good answer
08:57:13 <c_wraith> Liquid Haskell lets you define the type of Strings that are either "Hello" or "World".  I hear it's advanced a lot in the last year, I should look at it again.
08:57:14 <Younder> erisco, You might like the approach in the language Idris. I did
08:57:15 <erisco> you're right on how you'd most likely do it in Haskell, but I don't know what the relevance of Enum is
08:57:35 <EvanR> the second one is not as good, just that haskell isnt up to snuff
08:57:35 <leshow> erisco: I think flow does have sum types
08:57:41 <erisco> Younder, I didn't see what that was
08:58:17 <ertes-w> Wizek: and that makes it really easy to construct cheap, powerful abstractions…  since actions are just values, we can layer higher-level languages on top of them, which is impossible in other languages…  think python decorators, but first class and on steroids
08:58:57 <EvanR> whats the opposite of "on steroids"
08:59:04 <glguy> off steroids
08:59:10 <leshow> EvanR: I'be always liked haskell's approach where there's a separation between value and type level, I guess I'm just asking if there's any reason allowing stuff like flow's value-as-type is a bad idea?
08:59:14 <leshow> ive*
08:59:15 <EvanR> like, on something to make it worse
08:59:19 <Wizek> EvanR: sober?
08:59:22 <EvanR> which haskell has some of
08:59:57 <Younder> erisco, A recursive number type. I is eliminated ar compile time. It allows reasoning about sequence inductively. Could be used for enumerations too.
09:00:23 <ertes-w> EvanR: on monoids
09:00:39 <dminuoso> ertes-w: what language extensions are necessary to run this?
09:00:51 <dminuoso> TypeFamilies seems not to be enough
09:00:53 <EvanR> leshow: well. haskell does actually let you use values as types (as silly as this may sound)
09:00:58 <ertes-w> dminuoso: GHC should tell you
09:01:05 <EvanR> (DataKinds extension)
09:01:27 <c_wraith> leshow: are you familiar with refinement types?
09:01:30 <erisco> Younder been a while since I used Idris but I'd guess omething like  data Str (s : [String]) where MkStr : (x : String) -> {auto p : Elem x s} -> Str s
09:01:37 <erisco> Younder, but I imagine they thought of something more clever
09:01:45 <Wizek> ertes-w: Yes, that makes sense. 
09:02:29 <c_wraith> leshow: a refinement type allows you to say "Type X, but only values that satisfy some predicate".  That's more or less what you're describing.  "String, but only values that are equal to 'hello' or 'world'"
09:02:31 <leshow> c_wraith: I've heard the term before... somewhere
09:02:36 <leshow> is that what liquid haskell is?
09:02:40 <c_wraith> leshow: yes
09:02:54 <Younder> erisco, could be, but that's basically what I had min mind
09:02:56 <erisco> refinement types backed up by SMT solvers
09:03:11 <EvanR> erisco: as a first step.. for literally 2 strings... data Foo : String -> Type where A :: Foo "foo" | Bar "bar"
09:03:43 <EvanR> yurg
09:04:14 <EvanR> data Foo : String -> Type where A : Foo "foo" \n B : Foo "bar"
09:04:29 <erisco> EvanR, these languages historically have used strings as configuration arguments, like integer enumerations
09:04:46 <EvanR> what languages
09:04:47 <erisco> EvanR, and they are now retrofitting them with type systems to account for these parameter types
09:04:54 <EvanR> oh dynamic
09:04:54 <erisco> JavaScript
09:05:22 <erisco> flow is a type checker for js and ts is a superset language
09:05:42 <c_wraith> so what flow is doing is essentially creating a refinement of String to describe those things
09:06:01 <leshow> they both have almost the exact same set of features, flow is a bit more strict with null checks out of the box
09:06:04 <erisco> but you'll find the use of those types may be very restrictive
09:06:21 <leshow> I thought they were subtyping
09:06:25 <EvanR> i think flow is trying to express a regular enum sum type there
09:06:28 <erisco> possibly such that it will only accept a string literal itself as an argument
09:06:32 <c_wraith> leshow: refinement types are subtypes
09:06:38 <leshow> oh
09:06:56 <c_wraith> leshow: you can use { String s | s == "hello" } anywhere you can use String
09:07:37 <c_wraith> Err.  Not quite true.  Any *positive* use
09:07:48 <c_wraith> Err.  signs flipped.  Negative.
09:07:59 <c_wraith> You can provide a subtype any place a supertype is called for
09:08:26 <erisco> I was toying with an idea where the whole type is a predicate
09:08:49 <erisco> where  x : t  means  t x is true
09:08:55 <c_wraith> I think that's basically refinements on a unityped system
09:10:08 <erisco> sure, but instead of that I was thinking of, in an extendable system, you can define constructors
09:10:36 <erisco> so you can define a constructor and that gives you projectors for the fields, and pattern matching
09:11:12 <erisco> so now if you encounter an expression like   \x -> height x > 2  then you know something about x
09:11:18 <EvanR> erm... extendible constructors = extensible variants... projectors = records...
09:11:47 <erisco> no not extensible constructors… I mean extensible in the same sense you can extend a type system with more types
09:12:32 <erisco> what you know about x there is that, because it is applied to the height projector, that it must be of the associated constructor
09:13:20 <EvanR> now it sounds like an odd version of haskells records
09:13:56 <leshow> I'm not sure I follow this: { String s | s == "hello" } is this using LH?
09:13:58 <erisco> well the type system is utterly different
09:14:34 <erisco> \x -> height x > 2   as a type is inhabited by y's such that height y > 2
09:15:05 <erisco> so it is similar to refinement types in that way but it doesn't have ADTs
09:15:44 <erisco> both the structure and the refinement of the structure is determined by the predicate
09:18:10 <rightfold> That reminds me of Shen
09:18:14 <dminuoso> ertes-w: Okay that's interesting.. so yeah. The kind of `Trans` is what my question was, whether that was one way to view it. :)
09:18:21 <erisco> leshow, I don't recall LH syntax but that is saying  s is a String and s == "hello" is true
09:18:56 <dminuoso> (And atom seems to have not displayed the GHC errors which extensions were missing for some reason, but after restarting it did)
09:19:13 <leshow> I gathered that, I was just wondering if it was written in some specific lang or just pseudo syntax
09:20:33 <erisco> the problems are at least those also faced by LH though, in that you have to be able to solve these predicates
09:20:52 * hackage Frames 0.3.0 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.3.0 (AnthonyCowley)
09:21:38 <erisco> and for that sort of thing I really hope to see work done to integrate solvers into human-driven solutions rather than it being automated or bust
09:22:00 <erisco> until the days where the human is just noise in the system…
09:28:05 <Younder> erisco, They still are having problems making a program as smart as a bug. So don't loose any sleep over it. (yet..)
09:29:26 <erisco> don't get the artificially intelligent bedbugs bite…
09:29:42 <erisco> don't let* dammit
09:30:37 <erisco> has anyone else developed a tendency for their fingers to type homophones, incorrect conjugations, and other unintended similarities?
09:31:11 <Younder> erisco, Oh yes, computers are great at logic, but not at things humans take for granted, lie distinguishing voices in a crowded room, or empathizing or reading human expression, or visualizing geometrically.
09:31:24 <Taneb> erisco: oh, definitely
09:32:11 <erisco> Taneb, thank you! then either I'm still normal or we're both going crazy
09:32:15 <cement> erisco all the damn time
09:32:41 <ITotallyExist> So I have a list of tensors (stored as 3 dimensional lists) in my program and i average them several times (output a new 3d list with the value at each index being the average of the values at those indexes of all of the input tensors)
09:32:52 <ITotallyExist> and it takes about 30% of my programs total runtime
09:33:10 <ITotallyExist> I would like to run it on my gpu
09:33:24 <ITotallyExist> but I do not know how, any libraries that could help with this?
09:33:39 <cement> have you read Parallelism and Concurrency in Haskell?
09:33:58 <cement> there's a chapter on GPU programming
09:34:11 <Younder> An AI today would use a evangelized spam generator. It would replicate patterns I trained it on. Common typos, prejudice and all that.
09:34:51 <ITotallyExist> :cement do you have a link?
09:34:58 <cement> ITotallyExist: http://chimera.labs.oreilly.com/books/1230000000929/ch06.html
09:35:03 <cement> relevant chapter and all
09:35:36 <cement> I do warn you, you might want to go back to chapter 2 and start from there
09:36:52 * hackage Frames 0.3.0.1 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.3.0.1 (AnthonyCowley)
10:11:02 * hackage network-dns 1.1 - Domain Name System data structures  https://hackage.haskell.org/package/network-dns-1.1 (MikhailVorozhtsov)
10:28:23 <glguy> Doing Advent of Code this year? Join the #haskell group! http://adventofcode.com/2017/leaderboard/private 43100-84040706
10:33:53 * hackage Frames 0.3.0.2 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.3.0.2 (AnthonyCowley)
10:35:35 <dmj`> ho’ ho’ ho’ 
10:38:07 <eHammarstrom> Hello, I am having some trouble installing intero via stack (on Arch linux), does anyone have experience with this? It is a dependency, terminfo, that is failing with ExitFailure 1
10:40:20 <geekosaur> that's been happening, a lot, yes
10:40:59 <geekosaur> 2017 Nov 24 21:06:29 <MarcelineVQ>	what's wrong is you need to add ghc-build: nopie in your  ~/.stack/config.yaml  and install ncurses5-compat-libs from the AUR
10:41:44 <geekosaur> long story, short version of which is it's downloading stuff that was built on debian. it runs on arch but the debian-based guesses it makes about which one to download are wrong
10:44:53 * hackage network-dns 1.1.0.1 - Domain Name System data structures  https://hackage.haskell.org/package/network-dns-1.1.0.1 (MikhailVorozhtsov)
10:46:53 <eHammarstrom> @geekosaur, ouch, I see. Thanks I will check if this works
10:46:53 <lambdabot> Unknown command, try @list
10:48:32 <eHammarstrom> Worked like a charm
10:51:05 <ggVGc> how do charms work?
10:58:05 <plakband> I'm working on some cg stuff; does anyone know of a library similar to Rust's genmesh? I need a way to e.g. get the vertices, normals and indices of a cube of some size, origin, rotation.
11:09:12 <ph88> does someone know a way or a library even that can help to find correlations (functions) between input and output states? Here is an example of some inputs and outputs and the correlations i want to find  https://bpaste.net/show/7ab055b19efc
11:17:46 <ph88> i'm thinking perhaps i should use some kind of solver library together with a computer algebra system .. but i don't know where to start
11:22:29 <byorgey> ph88: this generally falls under the name 'program synthesis'
11:23:10 <ph88> anything to get me started ?
11:23:11 <byorgey> ph88: e.g. see Microsoft 'prose'
11:23:19 <byorgey> relevant paper: https://www.cis.upenn.edu/~stevez/papers/OZ15.pdf
11:27:35 <ph88> is there something easier to get into ?
11:29:17 <byorgey> ph88: not that I know of, it's an active area of research and fairly tricky to do
11:31:23 <sternmull> I have a problem where i have a sequence of source items and derive multiple other sequences from it (higher abstractions, annotations). Derived items may be produced by consuming zero to N items from a lower layer sequence. I also want to maintain the relation between the items of different "layers". Is there a concept or a library that does implement such an idea well?
11:32:49 <ph88> byorgey, if it were only true/false i think it would be solvable with logic programming, no ?
11:35:41 <chasm> hi all - I frequently want to do this: maybe (pure ()) (myEffect >=> const myLoop) myMaybe, is there a more succinct expression?
11:36:41 <int-e> :t mapM_
11:36:43 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
11:36:46 <glguy> :t sequenceA_ :: Applicative m => Maybe (m a) -> m ()
11:36:47 <lambdabot> Applicative m => Maybe (m a) -> m ()
11:37:19 <johnw> anyone have a compact Parsec parser for parsing positive integers greater than 0?
11:37:37 <glguy> and mapM_ is traverse_ now
11:38:54 <int-e> @hoogle traverse_
11:38:54 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
11:38:54 <lambdabot> Distribution.Compat.Prelude.Internal traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
11:38:54 <lambdabot> Data.MonoTraversable.Unprefixed traverse_ :: (MonoFoldable mono, Applicative f) => (Element mono -> f b) -> mono -> f ()
11:38:54 <int-e> ah
11:38:54 <glguy> johnw: There's one in Text.Parsec.Language
11:39:31 <johnw> I don't see any parsers in that module
11:43:50 <chasm> ah, I see: traverse_ (myEffect >=> const myLoop) myMaybe, thanks
11:47:50 <Average-user> I need a function, that takes an infinite list, and it has to take elements from the beginning until it sees an element that has already be seen. How would you do it?
11:47:50 <Average-user> Something like (pseoudocode): takeWhile (not alreadySeen) xs
11:49:45 <glguy> Average-user: I'd keep track of the elements I'd seen so far
11:49:56 <glguy> as I considered the elements of the infinite list
11:50:25 <geekosaur> there's a function that already does this... but it doesn't let you change what it does in case of a repeat :)
11:52:25 <byorgey> ph88: probably so
11:52:41 <daey> a -> a -> a == a -> (a -> a) ?
11:52:55 <byorgey> daey: yes
11:53:00 <daey> ty
11:53:30 <byorgey> Average-user: depending on your level of comfort with Haskell, I would either try (1) writing an explicitly recursive function that passes along an extra Set parameter to keep track of which elements have been seen
11:54:31 <Average-user> byorgey: could do that, but I was thinking if maybe a fold can do it for me
11:54:32 <byorgey> or (2) do something like   scanl (flip S.insert) S.empty  (assuming 'import qualified Data.Set as S')  to get the sets of elements in each prefix of the list, and find the first pair of consecutive sets that are equal
11:55:56 <Average-user> geekosaur: What is called?
11:59:07 <glguy> Average-user: You can write that function using foldr, though it might not be obvious how. Just writing the recursive solution is the easiest way to start
11:59:16 --- mode: glguy set -o glguy
12:03:05 <Average-user> glguy: I know, but I've already done that. I want something more elegant, but I never got used to folds
12:03:16 <Average-user> And I want to now
12:14:58 <Average-user> glguy: All started because day 6 remembered me to this: http://lpaste.net/360551
12:15:18 <ph88> byorgey, i found this https://github.com/lagodiuk/genetic-programming
12:15:58 <ph88> and more generally https://github.com/topics/symbolic-regression
12:22:47 <xacktm> (spoilers AoC fyi) Why do these types not match, and can I coerce them?  Data.Set.Ordered has a findIndex that returns a Maybe Index (where type Index = Int), and I want to do some arithmetic as Int but I get: http://lpaste.net/7916631582826299392
12:23:45 <pierrot> Hi. To make an instance for `Monad`, do I need to create an instance for `Functor` and `Applicative` first?
12:24:33 <dminuoso> pierrot: Correct.
12:25:56 <mud> pierrot: Or at least you have to do all of them. If it's somehow easier for you to write Monad first, you can then write Functor and/or Applicative in terms of Monad.
12:26:28 <pierrot> dminuoso and mud: Thanks. That wasn't a restriction some years ago, right?
12:26:35 <fishythefish> xacktm: you have to provide findIndex with the ordered set
12:26:53 <xacktm> fishythefish: d'oh!  thanks!
12:26:56 <mud> No, it wasn't required by GHC years ago, I forget when it changed. I think GHC 7.10 time or so.
12:27:07 <pierrot> Thanks
12:27:10 <mud> (but users got annoyed at you even before that if you had Monad but not others)
12:27:36 <fishythefish> mud: IIRC, proposal was from 2014, ultimately implemented in GHC 7.10
12:27:50 <mud> Right, that sounds plausible
12:28:31 <dminuoso> Is there no language extension to derive them mechanically?
12:28:49 <dminuoso> I mean Im getting sick of writing boilerplate functor/applicative instances. :(
12:29:00 <HaskellLord69> there is a derivefunctor extension
12:29:03 <mud> I think there's DeriveFunctor
12:29:18 <mud> And I guess you could write some TH to make Functor/Applicative in terms of Monad if that helps.
12:29:29 <mud> That probably even exists in some package, though I have no idea.
12:30:55 <dminuoso> Well there's a proposal at least: https://ghc.haskell.org/trac/ghc/wiki/InstanceTemplates
12:33:19 <zenzike_> Why do we have duplicate functors in base: Sum and :+:, Product and :*:, Compose and :.: ?
12:34:57 <AnantJain> hey guys, i am new here and am trying to learn Haskell from scratch
12:35:11 <f-a> hell- wat
12:35:12 <lyxia> zenzike_: they came from different places (transformers and Generics)
12:35:36 <zenzike_> lyxia, I can see that ... but is it simply legacy then?
12:36:00 <zenzike_> We could unify with synonyms and patterns, right?
12:36:51 <mud> Oh, there's two things called Sum. I was very confused.
12:36:54 <lyxia> Yes we could
12:37:23 <f-a> hello, I read on Control.Concurrent that "To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the -threaded option when linking your program"
12:37:50 <fishythefish> AnantJain: welcome, feel free to ask any questions you have about Haskell
12:37:59 <zenzike_> lyxia: thanks! Glad I wasn't missing something subtle
12:38:26 <f-a> does it work in the other direction too? I mean: "without -threaded, we're sure an (imported as safe) C function will block haskell threads
12:39:52 <AnantJain> thank you fishythefish. I came here from the book "Learn You a Haskell for Great Good! Miran Lipova" and would be asking some doubts as i move forward.
12:41:10 <ph88> byorgey, now i also found this https://hackage.haskell.org/package/symengine i think after a formula has been found and it's fit is good enough that it can count as "correlation found" = True ... and then i can put everything in sbv or something ..
12:41:17 <crucify_me> hi this is a bit confusing. I can't see how the application order works here. http://lpaste.net/360553
12:41:55 <fishythefish> crucify_me: which part of it is confusing?
12:42:22 <mud> crucify_me: function application is always strongest, and then operators (they have order too, but there's only one operator there)
12:42:23 <dminuoso> crucify_me: function application has a higher precedence than any operator.
12:42:33 <byorgey> ph88: I don't see how an engine for symbolic mathematics is going to help you.
12:43:19 <fishythefish> f-a: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-chap.html#foreign-imports-and-multi-threading
12:43:44 <ph88> byorgey, for when i have input/output values of 60->30, 120->60  it can help to find the relation (which is input/2 = output)
12:45:02 <crucify_me> by looking at that, I would think take would only get every other list of 8 bits
12:45:29 <dminuoso> crucify_me: Have you a way of testing your hypothesis?
12:46:02 <dminuoso> You could either try out some code or better, just expand the code manually.
12:46:06 <fishythefish> crucify_me: try evaluating a small example by hand, and remember that `take` doesn't mutate `bits`
12:46:51 <dminuoso> crucify_me: The trick to evaluate code by hand is the best way to understand "how does this work" because ultimately that is exactly what Haskell does.. it just expands and evaluates (according to some rules)
12:47:06 <ph88> byorgey, oh yes seems it only does symbolic computation and not symbolic regression :(
12:47:20 <crucify_me> well for lack of a better way to say this, when drop is applied, those 8 bits don't just disappear, they are passed to take and put into the cons queue ?
12:48:19 <dminuoso> crucify_me: what does `drop` do?
12:48:26 <f-a> fishythefish: thanks, I wonder why mine doesn't block even when I am not using -threaded
12:49:54 <fishythefish> f-a: just checking, is your ffi call marked safe or unsafe?
12:50:11 <dminuoso> crucify_me: Also remember to look at the type
12:50:13 <dminuoso> :t drop
12:50:14 <lambdabot> Int -> [a] -> [a]
12:51:00 <f-a> fishythefish: it is marked safe
12:52:32 <crucify_me> what I'm asking is when that function uses drop, can the dropped elements be passed around?
12:52:43 <crucify_me> or whenever drop is used..
12:53:05 <EvanR> you seem to be thinking too operationally about what drop does
12:53:08 <fishythefish> crucify_me: no, because they're not in the return value
12:53:27 <crucify_me> so wait then..
12:53:28 <fishythefish> > drop 2 [1..10]
12:53:30 <lambdabot>  [3,4,5,6,7,8,9,10]
12:53:41 <EvanR> you can pass 1 and 2 around before during or after drop
12:54:06 <crucify_me> so it seems that would take 8, the first char in a string, then drop the next one, take another, etc
12:54:19 <fishythefish> crucify_me: take doesn't mutate bits before it's passed to drop
12:54:38 <EvanR> we went over this exact issues a couple weeks ago
12:54:41 <crucify_me> sorry fishythefish I don't follow that
12:54:52 <crucify_me> we did? 
12:54:54 <EvanR> yes
12:55:06 <EvanR> you thought that take and drop mutated a list
12:55:39 <crucify_me> right hold on please.
12:56:34 <fishythefish> > let x = [1..4]; y = take 2 x in (y, x)
12:56:36 <dminuoso> crucify_me: drop just "loses" (or skips)
12:56:36 <lambdabot>  ([1,2],[1,2,3,4])
12:56:46 <dminuoso> crucify_me: hence its called... "drop" because you "drop n items" 
12:56:51 <fishythefish> our definition of y does not affect the value of x
12:57:31 <EvanR> 2 + 2 = 4 doesnt affect the value of 2, in haskell this "obvious" thing extends to all data structures
12:58:17 <dminuoso> crucify_me: So data are immutable, you cant change them. `drop 8 l` calculates a new list using l, but without the first 8 elements.
12:58:33 <dminuoso> I think in that respect haskell is a pure language, in that you cant have side effects on anything, including data.
12:58:40 <dminuoso> Though I could be wrong on the details here.
12:59:21 <crucify_me> thanks hold on, I need to fit everything into my warped paradigm
12:59:38 <dminuoso> crucify_me: one way I like to think about it, is to see `drop 2` as creating a function [a] -> [a], which given some list will return a new list but without the first two. 
12:59:55 <ocharles> > let x = 1.5e-323 in x :: Double
12:59:57 <lambdabot>  1.5e-323
13:00:44 <fishythefish> crucify_me: strongly recommend adjusting your paradigm rather than warping haskell to fit
13:01:12 <crucify_me> thanks I was joking in that same vein
13:02:52 <crucify_me> so after take 8, a new list is passed to drop, with 8 new elements at the beginning
13:03:57 <dminuoso> Nope..
13:04:05 <dminuoso> crucify_me: Just evaluate it manually.
13:04:15 <mud> crucify_me: Nothing is ever modified by pure functions. You just get different values back.  2 + 5   doesn't change the value of 2
13:04:16 <kuwze> I am trying to create a simple program with system arguments and I am getting stuck. I have     env <- Data.Map.fromList `fmap` getEnvironment but I don't know how to print/inspect env. Is there an easy way to do that?
13:04:41 <kuwze> I am trying to follow this: https://wiki.haskell.org/Tutorials/Programming_Haskell/Argument_handling
13:04:51 <EvanR> print env ?
13:04:53 <EvanR> :t print
13:04:54 <lambdabot> Show a => a -> IO ()
13:05:59 <dminuoso> crucify_me: Do the following. Replace that number with 1, and then manually evaluate/expand.
13:06:32 <dminuoso> crucify_me: You call chop8 with "abcdefgh" (and assume the type of chop8 to be [Char] -> [[Char]] )
13:06:40 <dminuoso> Or "chop1" rather :-)
13:06:50 <crucify_me> so you used the word 'skip' earlier
13:07:12 <crucify_me> so after we have take 8 in the cons cell ...
13:07:19 <EvanR> :|
13:07:43 <crucify_me> :(
13:08:02 <dminuoso> crucify_me: evaluate it manually, do it on paper or in your text editor.
13:08:18 <fishythefish> perhaps nitpicking, but take 8 is not in a cons cell
13:08:34 <crucify_me> the next 8 elements are dropped, once the first 8 elements are skipped over, so to speak
13:08:53 <kuwze> EvanR: thank you!
13:08:57 <fishythefish> crucify_me: what does `take` do?
13:09:26 <Ariakenom> What's an diomatic way to block forever?
13:09:48 <crucify_me> idk
13:10:00 <fishythefish> crucify_me: figure that out first
13:10:06 <eHammarstrom> Is `prnt :: Show a => a -> a -> IO ()` a correct type declaration?
13:10:12 <dminuoso> crucify_me: And when you do, you take this: https://gist.github.com/dminuoso/a257a6f271cc353e7fdd1fce476e25fc
13:10:13 <dminuoso> and expand it.
13:10:16 <monochrom> The idiomatic way is to block on the actual thing you're waiting for.
13:10:42 <fishythefish> eHammarstrom: it's a valid type declaration, but it's hard to say whether it's correct without knowing what prnt should do
13:10:44 <kuwze> what's a good way to go about parsing arguments for their bindings? such as --author=nametoretrieve. https://gist.github.com/kuwze/77375d43bb317c10218e7bf619836e1c is where I am at
13:10:56 <Ariakenom> I'm not waiting for anything, I'm running async race and want to choose the other thing
13:10:56 <EvanR> for something that will never happen?
13:10:59 <ph88> how awesome is this https://www.youtube.com/watch?v=2kbCMWC_EgA
13:11:02 <dminuoso> crucify_me: Or you could use a list of integers instead, whatever you prefer really.
13:11:02 <ph88> best thing: it's GPL
13:11:33 <monochrom> I don't think there is a real case of "something that will never happen" apart from artificial XY problems.
13:11:40 <EvanR> Ariakenom: i always implement hang with a forever threaDelay million
13:11:57 <dminuoso> crucify_me: I cant stress enough how much evaluating by hand has solved so many "wait.. what. how?" questions. :-)
13:12:18 <EvanR> monochrom: its like a unit element of threads
13:12:24 <dminuoso> Tried to stare for about 10 hours at `some/many` until I just evaluated them, and after 1 minute it was clear.. :-P
13:12:28 <eHammarstrom> fishythefish, given a function, how may I get GHC to give me the type declaration 'generate it for me'? The function is pretty simple `prnt input output = putStrLn $ (show input) ++ " => " ++ (show output)`
13:13:20 <crucify_me> but to do something by hand, you have to know what you're doing
13:13:22 <fishythefish> eHammarstrom: just don't provide one and it'll be inferred
13:13:36 <dminuoso> eHammarstrom: Quick tip, you dont need those parens. Function application has a higher precedence than any operator.
13:13:37 <kuwze> eHammarstrom: I don't know if this helps, but loading it in ghci and running ':t blah' will tell you
13:13:40 <Ariakenom> Playing with FRP implementation á la Push-pull functional reactive programming
13:13:51 <eHammarstrom> kuwze: ah, yes!
13:13:56 <eHammarstrom> dminuoso: thanks
13:14:00 <Ariakenom> thanks EvanR
13:14:15 <monochrom> Even in the daemonic case of a worker thread looping indefinitely, you main thread can always block on waiting for the worker thread to die, if your main thread is not already looping indefinitely for other reasons.
13:14:23 <fishythefish> crucify_me: yes, so start by understanding what `take` does. far better than blindly using functions you don't know and failing to understand a larger program
13:14:26 <Ariakenom> I was surprised when I couldn't find something in stdlibs
13:15:12 <dminuoso> fishythefish: So start with take, and do the same thing
13:15:16 <dminuoso> @src take
13:15:16 <lambdabot> take n _      | n <= 0 = []
13:15:16 <lambdabot> take _ []              = []
13:15:16 <lambdabot> take n (x:xs)          = x : take (n-1) xs
13:15:21 <dminuoso> Err sorry I meant crucify_me.
13:15:37 <monochrom> "I'm running async race and want to choose the other thing"  So you are waiting for the other thing. This is no "waiting for nothing".
13:15:44 <monochrom> I'm sorry I'm such a logician.
13:15:53 <dminuoso> Give it a list (can be a string or any list you like), and expand manually. You will automatically see what it does, and how it works.
13:16:03 <EvanR> monochrom: you are waiting for two things in a race
13:16:17 <Ariakenom> Parent is waiting. I'm yielding.
13:16:41 <EvanR> never `race` never = never
13:16:42 <erisco> children are orphaned, I'm dead
13:16:46 <EvanR> x `race` never = x
13:16:51 <EvanR> never `race` x = x
13:17:41 <monochrom> So don't use race, just use x?
13:18:01 <crucify_me> not sure if this is right http://lpaste.net/360553
13:18:01 <EvanR> thats like dont ever use zero ?
13:18:10 <EvanR> replace your sum with a result already
13:18:40 <monochrom> You can email libraries@haskell.org to advocate adding "never" on algebraic merits.
13:18:53 * hackage weeder 0.1.8 - Detect dead code  https://hackage.haskell.org/package/weeder-0.1.8 (NeilMitchell)
13:19:00 <monochrom> Meanwhile as a work around I would just use x and get code that works today.
13:19:10 <EvanR> i have something like never or hang in about half of my projects
13:19:26 <EvanR> and its not just for testing, its for implementation of games 
13:19:32 <Ariakenom> It's also in FRP Events
13:19:51 <crucify_me> so drop 2 "cdefg" works on this new list.
13:20:00 <EvanR> i dont require it to be in prelude but it comes in handy
13:20:39 <crucify_me> dminuoso, is my paste correct friend ? ^
13:20:51 <monochrom> Here is why a very simple and easily implemented tool takes 20 years to appear in base.
13:21:07 <fishythefish> crucify_me: not quite
13:21:21 <fishythefish> drop 2 "abcdefg" does not reduce to drop 2 "cdefg"
13:21:22 <monochrom> First it takes 10 years for those who wish for it to actually send an email to libraries@haskell.org to talk about it.
13:21:33 <erisco> the language is only 27 years old though
13:21:39 <monochrom> Then it takes 10 more years for the committee there to design by committee.
13:22:04 <monochrom> Just look at Semigroup
13:22:05 <EvanR> are you for it suddenly?
13:22:14 <monochrom> No.
13:22:15 <fishythefish> erisco: there's a joke about lazy evaluation waiting to be made here, i'm sure
13:22:29 <dminuoso> crucify_me: https://gist.github.com/dminuoso/b29d528f59bb86bf427f3ce3ff00ae0a
13:22:39 <dminuoso> crucify_me: This is the kind of manual expansion Im talking about. Go through the whole process by hand.
13:22:51 <rightfold> And about broken strictness analyzers
13:23:19 <erisco> you can't just express what you want and expect it to get done! you have to force the evaluation too!
13:23:38 <monochrom> I am just explain why by 2057 "never" will still not be in base and why IRCers will still be navel-gazing it in #haskell.
13:23:49 <erisco> fishythefish, yeah I dunno about that
13:24:10 <EvanR> and monochrom will be explaining how useless it is!
13:24:20 <monochrom> No I won't.
13:24:21 <fishythefish> erisco: i'll take it
13:25:01 <monochrom> I am agnostic. I was just telling you how to work around the absence of it so you don't have to wait 40 years.
13:25:18 <dminuoso> crucify_me: If you're already looking at it, please reload (I had a mistake in there)
13:25:31 <EvanR> the original question was about whats idiomatic and i guess the real answer is there is no idiomatic way
13:25:35 <erisco> so, what is the dual of never?
13:25:50 <EvanR> pure something
13:25:52 <monochrom> You are free to propose adding it and I won't speak against it but I'm pretty sure at this rate you won't propose it for another 10 years. Consider it a challenge.
13:25:58 <crucify_me> dminuoso, thanks will do
13:26:00 <Ariakenom> What's the dual of 0?
13:26:16 <EvanR> INFINITY
13:26:25 <erisco> if you can't get "never" in, then maybe you can argue for the dual and a negation ;)
13:26:46 <monochrom> Aw unfortunately there is no thread negation.
13:26:46 <EvanR> i would call it hang
13:26:49 <EvanR> :: IO a
13:26:53 <erisco> or "involution"
13:27:51 <monochrom> I know this because in math channels I saw people empty-talking about wishing for a LaTeX rendering plugin for IRC.
13:27:57 <EvanR> the opposite of hang would be waiting for an event that happened at negative infinity
13:28:10 <monochrom> They talked for 10 years and finally someone did it. But it's for Pidgin.
13:28:34 <Ariakenom> precognition :: IO ()
13:28:54 <monochrom> So they continued to talk about it for another 10 years because they don't feel like switching to Pidgin. Half of them are religious about mIRC and the other half are religious about oh-so-text-mode clients.
13:29:15 * glguy reboots monochrom
13:29:33 <monochrom> At this rate they'll just die in another 50 years and then no one will remember that this history ever happened.
13:29:55 <erisco> where do they have mass? I need somewhere to rinse myself of the sins of Slack
13:31:08 <erisco> I had to buy pearls just to get through the experience
13:31:15 <dminuoso> crucify_me: And reloaded once more, this is what you should mentally process. :-)
13:32:16 <crucify_me> dminuoso, thanks so much , I didn't know take worked that way. gotta go thanks ALL for your patience .. I will study repasted gist.   
13:32:24 <crucify_me> fishythefish, ^
13:34:07 <erisco> > (zipWith (const id) . enumFromTo 1) 5 [1..10]
13:34:09 <lambdabot>  [1,2,3,4,5]
13:34:44 <aberrant> foo
13:34:53 <erisco> > (zipWith (const id) . flip replicate ()) 5 [1..10]
13:34:55 <lambdabot>  [1,2,3,4,5]
13:34:58 <Average-user> can someone define this with folds? f ac (x:xs) = if elem x ac then x:ac else f (x:ac) xs
13:35:09 <erisco> that's a little more in spirit with the Peano natural version
13:35:18 <dminuoso> erisco: Im guessing you're trying to find extensionally equivalent variants of writing drop?
13:35:24 <dminuoso> Err. take.
13:35:41 <Guest47064> Hi, I'm a bit confused by GHC.TypeLits Symbol and KnownSymbol. If I have a value of data type with a parameter of kind Symbol, how can I get the runtime String of the Symbol? Using `symbolVal :: KnownSymbol s => Proxy s -> String` doesn't work, as ghc complains that there is no `KnownSymbol` instance for `s :: Symbol`.
13:35:54 <erisco> dminuoso, I get an idea and I go for it, that's all ;)
13:36:32 <glguy> Average-user: You'll use a very similar technique to how you can write foldl using foldr : https://www.reddit.com/r/haskell/comments/2892a9/someone_asked_me_to_derive_foldl_from_foldr_is/ci8yp1b/
13:36:35 <dminuoso> :t enumFromTo
13:36:37 <lambdabot> Enum a => a -> a -> [a]
13:38:01 <Ariakenom> There we go. This might sorta work, didnt test. veryDefinedAnd: http://lpaste.net/5113492710048661504
13:38:56 <dminuoso> erisco: Ah so thats just a quirky way of writing zipWith (const id) (enumFromTo 1 5) [1..10] :o
13:39:41 <erisco> dminuoso, when I write something in that style I am either using SEC or I am intending it to be a named definition
13:40:08 <erisco> it is just a little less work than   let f = zipWith (const id) . enumFromTo 1 in f 5 [1..10]
13:41:17 <erisco> if a simple pointfree expression exists I capitalise
13:41:51 <erisco> const id  is also shorter than  flip const   ;)
13:42:05 <zenzike_> I want to define a monad instance for a datatype that uses unboxed arrays as its underlying container. Obviously I need to define `return :: a -> m a`, but I have the extra constraint so I can only manage `return :: Unboxed a => a -> m a`. Are there any tricks to get this to shoehorn in, or do I need to define my own UnboxedMonad class?
13:42:53 <erisco> zenzike_, you can't do that with the standard Monad class
13:43:08 <zenzike_> thought not :-( 
13:43:58 <erisco> with modern extensions it is feasible to parameterise restrictions like this, but that can't be retrofitted now
13:44:27 <zenzike_> oh, what do you have in mind? Constraints?
13:44:31 <Ariakenom> evanR: someone: can I have comment? http://lpaste.net/5113492710048661504
13:44:41 <Average-user> Is there a function like replicateM but where the order doesn't matter?
13:45:36 <erisco> zenzike_, ConstraintKinds would be one, yes, and also whatever enables associated types… not sure if that is just TypeFamilies
13:46:08 <erisco> Average-user, how would the order not matter? can you provide more context?
13:46:27 <zenzike_> erisco: ta, yes, I see where you're going with that
13:46:54 <dminuoso> Average-user: If the order does not matter, then still use replicateM. The fact that it sequences its actions should be irrelevant to you, no?
13:47:29 <aberrant> I can't wait to get home to continue working on the monad challenges
13:47:36 <aberrant> can't do it at work, unfortunately.
13:47:49 <Average-user> replicateM 2 [0,1] -> [0,0] [0,1] [1,0] [1, 1] I want replicateM 2 [0,0] [0,1] [1,1]
13:48:15 <daey> newtype Age =  Age Integer deriving (Eq, Show) what exactly does this do? i create a new type called 'Age' which is equal to Integer but also has 'Eq and Show' properties?
13:48:27 <erisco> > let take n = maybe [] . find (length == n . fst) . splitAt [0..] in take 5 [1..10]
13:48:29 <lambdabot>  error:
13:48:29 <lambdabot>      • Couldn't match type ‘Maybe [a2]’ with ‘a3 -> [a4]’
13:48:29 <lambdabot>        Expected type: [a2] -> a3 -> [a4]
13:48:41 <daey> doesnt every type have Show properties? and doesnt Integer already include Eq?
13:48:54 <erisco> > let take n = maybe [] . find ((==n) . length . fst) . splitAt [0..] in take 5 [1..10]
13:48:55 <lambdabot>  error:
13:48:55 <lambdabot>      • Couldn't match type ‘Maybe ([a0], b0)’ with ‘a3 -> [a4]’
13:48:55 <lambdabot>        Expected type: [a2] -> a3 -> [a4]
13:49:08 <glguy> daey: No, not every type supports Show nor Eq
13:49:15 <erisco> I see, I see… brain malfunction
13:49:21 <daey> glguy: ok. but Integer does, doesnt it?
13:49:26 <glguy> daey: When you make a newtype it starts with no instances at all. You have to then define the ones you want it to have
13:49:39 <glguy> daey: Yes, Integer has Eq and Show
13:49:55 <daey> so, 'newtype Age =  Age Integer ' thats equal then?
13:50:16 <glguy> I don't understand the question, could you rephrase it?
13:50:18 <Average-user> replicateM 2 [0,1] -> [0,0] [0,1] [1,0] [1, 1] I want replicateM 2 [0,1] -> [0,0] [0,1] [1,1] (I wrote it wrong)
13:50:41 <daey> does it make a difference if i write 'newtype Age =  Age Integer' as opposed to 'newtype Age =  Age Integer deriving (Eq, Show)'
13:50:57 <glguy> daey: Yes, one derives Eq and Show instances for Age and one does not
13:51:03 <lyxia> Average-user: what's the logic?
13:51:45 <daey> glguy: so Age does not inherit Eq just because Integer has it?
13:51:51 <glguy> daey: correct
13:51:54 <twanvl> Average-user: do you want   nub . map sort . replicateM 2  ? (but more efficiently)
13:52:01 <daey> how do i know what is inherited and what isnt o0
13:52:08 <glguy> daey: Nothing is inherited
13:52:30 <daey> glguy: then why is Eq, show written after a deriving while Integer isnt? why arent they equal
13:52:39 <erisco> > let take n = maybe [] id . find ((==n) . length) . fmap fst . splits; splits = flip fmap [0..] . flip splitAt in take 5 [1..10]
13:52:41 <lambdabot>  [1,2,3,4,5]
13:52:43 <daey> i.e. Age deriving (Integer, Eq, Show)
13:52:47 <glguy> daey: Eq and Show are typeclasses, Integer isn't
13:52:54 <daey> i see
13:53:09 <erisco> in this version we first generate the space in which the answer can be found, then we just search for it
13:53:46 <daey> glguy: so Age doesnt have the Num typeclass either?
13:53:52 <glguy> daey: Nothing is inherited
13:54:18 <daey> but isnt Num required to be able to do math operations?
13:54:21 <erisco> it is far less efficient because it doesn't keep the assumption of successive prefix lengths during the search
13:54:46 <twanvl> > let replicateOrdered 0 _ = [[]]; replicateOrdered n [] = []; replicateOrdered n xxs@(x:xs) = map (x:) (replicateOrdered (n-1) xxs) ++ replicateOrdered n xs in replicateOrdered 3 [0,1,2]
13:54:48 <lambdabot>  [[0,0,0],[0,0,1],[0,0,2],[0,1,1],[0,1,2],[0,2,2],[1,1,1],[1,1,2],[1,2,2],[2,...
13:54:48 <erisco> also  flip f . flip g  seems like it should be a thing
13:54:54 <glguy> daey: It wouldn't make sense to multiply two Ages and get an Age back
13:55:20 <glguy> daey: so it's a good thing that Age doesn't inherit the Num instance
13:55:40 <glguy> (which it doesn't inherit because no typeclasses are automatically inherited for a newtype)
13:55:52 <daey> well its just that the example does 'sumNumberish (Age 10) (Age 10) :')
13:56:06 <glguy> yeah, that's fine
13:56:30 <glguy> if you define sumNumberish you can make it do whatever you like
14:04:02 <michi7x7> If I want to build a Graph by querying info from the filesystem (IO), and need to detect loops and link them appropriately (A -> B -> A), how could I link to the correct node?
14:04:25 <bollu> michi7x7: I've used indirection to represent graphs before
14:04:37 <bollu> michi7x7: since you don't have references (discounting IORef)
14:05:23 <bollu> the you can find cycles using any standard algorithm: DFS and then check for backedges, for example
14:06:02 <michi7x7> bollu: what I do right now is just this: https://gist.github.com/michi7x7/19ae4cac0a1a79c1e0564635c02cda9a
14:06:29 <michi7x7> but without references, I think you're right
14:14:04 <erisco> you want to determine the strongly connected components with something such as Tarski's algorithm which topologically sorts them
14:14:24 <fishythefish> Tarjan* ?
14:14:32 <erisco> possibly… who is Tarski then?
14:14:46 <fishythefish> the dude from Banach-Tarski
14:15:00 <fishythefish> he did a lot of stuff, dunno where to start
14:15:00 <erisco> anyways, in English, that means find the function called "scc" or similar in the graph library and use that
14:15:14 <fishythefish> https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
14:16:11 <erisco> iirc Dijkstra had one too… but that kinda goes without saying :P
14:16:19 <mud> Tarjan is such a badass
14:17:22 <fishythefish> yeah I think Dijkstra's belongs to a family of path-based algorithms
14:17:30 <fishythefish> and I think there's a Kosaraju's algorithm as well
14:18:31 <michi7x7> well, I don't actually care about cycles, I just need to place a pointer to a not yet completed node
14:18:57 <michi7x7> I'll try System.IO.Memoize
14:19:09 <erisco> what does it mean to be not completed?
14:20:12 <michi7x7> If I have A -> B -> A, while parsing A, I'd like to B to be the next element
14:20:22 <michi7x7> a simple recursion wouldn't do in this case
14:20:43 <michi7x7> The problem (for me) is, that all this happens in the IO Monad
14:20:50 <erisco> okay, so we have reading a file system, parsing, graphs, cycles, but not cycles … I'm a bit lost here
14:21:21 <michi7x7> erisco: this is what I started with: https://gist.github.com/michi7x7/19ae4cac0a1a79c1e0564635c02cda9a
14:21:52 <michi7x7> this is perfectly fine for a binary tree, but not for any cycles
14:23:03 <erisco> I am not sure what that does… looks like it reads a file header and does some stuff with it
14:23:44 <erisco> so the problem for you is if there is a cycle in files referencing each other in their header
14:24:21 <michi7x7> yep, exactly
14:24:30 <erisco> but what you're doing here is exploring the graph, you don't have the complete thing
14:24:46 <erisco> if you knew something such as all the files were in a directory then you could read all files and construct the graph
14:24:55 <raynold> ahh it's a wonderful day
14:25:16 <erisco> but if you are relying on the files themselves to locate the other files then you have to explore the graph blindly, unsure of where the extents are
14:25:28 <michi7x7> erisco: yeah, that's true
14:25:58 <erisco> so for that you need to remember what files you have already right, and so  Set String  works fine for that (or a Map if you need associated data) and possibly StateT for managing it
14:26:47 <erisco> you have already read*
14:26:47 <michi7x7> erisco: yeah, figured as much. I'm currently playing around with System.IO.Memoize to see if I could use that to resolve loops
14:27:16 <michi7x7> but honestly, I don't think that's gonna work ^^'
14:27:30 <erisco> I am not sure… I haven't heard of memoise in the context of IO
14:27:51 <erisco> seems odd because IO is not pure… would be called caching instead…
14:28:20 <EvanR> if the IO had no side effects, it would be like memoizing
14:28:36 <EvanR> if it had side effects, then im not sure if "caching" helps point that out
14:29:19 <michi7x7> It doesn't have any side effects, and the file contents are static
14:29:47 <erisco> oh sure it does, you're just hoping for the ideal case
14:30:08 <michi7x7> erisco: sure, but it doesn't change anything for my program
14:30:23 <EvanR> we all live in a yellow submarine abstraction
14:30:46 <erisco> EvanR, is memory caching like that? I suppose not, since it is necessarily up to date, but I meant like network caching
14:31:07 <EvanR> i wish "caching" meants "correct" like in cpus
14:31:10 <EvanR> that would be awesome
14:32:18 <erisco> just flush it
14:37:12 <centril> notationally, how do you write "not (T <: S)" or "T is not a subtype of S" ?  T </: T  perhaps?
14:38:18 <erisco> make it up… they have no ground on which to say you're wrong
14:38:36 <centril> erisco: =)
14:39:14 <erisco> but you often see a forward slash drawn through the symbol, so that seems reasonable
14:39:31 <centril> erisco: yeah, that was my thinking also
14:40:47 <erisco> ∄ for example
14:41:05 <erisco> ⊄ ∉ ≠ ≢
14:41:59 <erisco> if you are constructing a proposition then you might use negation ~ or ¬ or ! or whatever
14:51:24 <monochrom> Host a debate on </: vs <\:  :)
14:51:46 <erisco> on which side do you tilt your party hat?
14:52:13 <monochrom> Add a third faction that advocates ≮:
14:54:14 <monochrom> The 3 factions of Command & Conquer 5 Tiberium Hair Splitting: GDI </: , Nod <\: , Scrin ≮:
14:54:31 <EvanR> the use vs mention ratio is getting pretty low
15:03:13 <centril> erisco: writing an RFC for Rust - and I need to say that  const fn(I) -> O  </:  fn(I) -> O
15:04:06 <erisco> sounds like a proposition
15:05:02 <centril> erisco: yeah should I go with   ¬(const fn(I) -> O  <:  fn(I) -> O) ?
15:05:43 <erisco> I don't know… it depends on what the surrounding theory is
15:06:30 <centril> erisco: a short paragraph on why sub-typing holding here would be unsound
15:08:26 <erisco> what I mean is what theory are you using to make this statement
15:10:28 <erisco> if you're just reasoning informally then you have to introduce the syntax either way
15:11:33 <centril> erisco: basically:  if they are subtypes, then   const fn(u32, const fn(u32 -> u32)) -> u32  would be a subtype of  fn(u32, fn(u32) -> u32) -> u32  allowing a user to pass in a non-const-fn function pointer to a const fn, which would allow the user to subvert the type system by calling an fn inside a const fn
15:11:50 <erisco> </: could be the name of a relation, the not-a-subtype-of relation
15:11:52 <centril> you can make a simple proof by example
15:12:09 <erisco> ¬(… </: …)  could be a proposition in some proof theory
15:12:26 <erisco> I mean  ¬(… <: …)
15:12:42 <erisco> and  … </: …  could be a prop too but is just sugar for  ¬(… <: …)
15:13:00 <fishythefish> centril: erisco isn't asking for an explanation of your statement; he's talking about the (formal) language in which the statement is expressed
15:13:05 <centril> erisco: oh right -   T </: S  is just sugar
15:13:15 <centril> fishythefish: yeah got that now =)
15:14:43 <erisco> if you want to demonstrate the unsoundness of that subtyping relation then you could do that and never bother stating anything with </:
15:16:13 <centril> erisco: =)
15:16:42 <ggVGc> what good is a sound type system when most programmers are unsound
15:16:53 <ggVGc> maybe that's actually precisely the point..
15:16:55 * ggVGc withdraws
15:17:25 <monochrom> It is good for identifying unsound programmers, at least some of them. It is also good for the sound few of us.
15:17:33 <erisco> if you say  T </: S  the question is what is the meaning? it sounds like "T </: S means that if T <: S then the type system is unsound"
15:18:01 <monochrom> Like what good is programming when most humans aren't programmers.
15:18:56 <centril> erisco: I will expand the stuff to a subsection instead of a paragraph and introduce everything
15:19:02 <centril> erisco: and use   ¬  instead
15:19:26 <erisco> I think that is an important question for you to answer though, i.e. what is the meaning
15:20:16 <centril> erisco: its an RFC; not a paper :P
15:21:20 <erisco> logically speaking though it sounds odd
15:22:48 <monochrom> An RFC deserves even more precision than a paper. Ideally anyway.
15:23:30 <centril> monochrom: im not changing the fact that it is not a subtype into that it is - im only explaining to wondering users that it would be if we changed it
15:24:26 <monochrom> Ah OK, motivation deserves to be whatever the audience actually understands.
15:26:39 <erisco> something being bad does not make its negation true
15:27:23 <chasm> I would like to read serialized data from a Handle... I can do: Data.Store.decodeEx <$> Data.ByteString.hGet n, but how do I know what n should be? I feel I am missing some standard idiom here...?
15:28:13 <erisco> I'm dissecting this though, and just because I wouldn't find merit in adding notations and technical statements which do not have good meaning
15:29:56 <erisco> speaking of which I could use a little help with Wadler's paper if anyone is interested :)
15:32:22 * hackage jvm 0.4.0.1 - Call JVM methods from Haskell.  https://hackage.haskell.org/package/jvm-0.4.0.1 (MathieuBoespflug)
15:32:39 <isaac__> Can `discrimination` be adapted to sets and maps to allow O(1) lookup?
15:36:25 <erisco> isaac__, what is discrimination?
15:36:41 <erisco> and does it make a good infix operator?
15:36:50 <isaac__> http://hackage.haskell.org/package/discrimination
15:36:59 <isaac__> There are some links to relevant papers there
15:37:14 <erisco> apparently I already had that bookmarked
15:38:30 <erisco> I do not know the answer to your question, but the data structure as they are are based on comparisons
15:38:43 <erisco> in the sense that lesser elements go there, bigger elements go here
15:39:15 <erisco> if you had more information than that then I suspect you could devise a data structure to make use of it
15:40:53 <isaac__> Yeah, many set implementations will use a binary comparison to do lookups
15:41:31 <isaac__> But I think discrimination is like... a k-ary comparison
15:41:43 <erisco> adding more buckets
15:41:48 <monochrom> Let k=2.
15:42:22 <isaac__> Because you can get linear time sorting of discriminatable things
15:43:39 <isaac__> Discriminable?
15:45:55 <bradparker> Hello all, I've got myself into an awkward situation and I'm not sure what I've done wrong (very much a newby). I've used a `type` alias for a monad transformer stack. The transformer at the top of the stack has an instance for MonadThrow/Catch but GHC says that my alias does not. If I copy the instance definitions (exactly) for that top transformer to instance definitions for my alias then it works as expected.
15:45:55 <bradparker> Does this sound familiar to anyone? I have links to all the code if anyone would like to see
15:46:31 <glguy> bradparker: Put that code on lpaste.net and we can see what happened
15:46:47 <glguy> type synonyms don't interfere with instances, so something else is probably going on
15:47:21 <erisco> or you are trying to give an instance for an alias
15:47:44 <erisco> and that is not allowed, but there is an extension that allows it iirc, but it doesn't let you give distinct instances for different aliases
15:48:45 <bradparker> Are GH links ok? 
15:48:45 <bradparker> https://github.com/bradparker/blotter/blob/master/source/Blotter/Web/ActionM.hs#L18
15:48:45 <bradparker> https://github.com/bradparker/blotter/blob/master/source/Blotter/Web/ActionM.hs#L25
15:49:25 <erisco> what is the error? iirc you should get an error telling you you can't use an alias there
15:49:26 <bradparker> https://github.com/scotty-web/scotty/blob/master/Web/Scotty/Internal/Types.hs#L178-L182
15:49:37 <bradparker> Ah I enabled FlexibleInstances
15:50:17 <isaac__> You should use `newtype` for this so that you avoid orphan instances
15:50:17 <bradparker> Thanks for having a look, appreciated muchly
15:50:48 <erisco> so it looks like instances already exist for  ActionT Error (BlotterT IO)
15:51:01 <erisco> an alias does not let you define different instances. see isaac__
15:51:41 <bradparker> I was curious about having to define them. I'd prefer not to because they're already defined for ActionT
15:52:05 <erisco> well if you just want to use those instances then… use them :)
15:52:33 <bradparker> haha yeah. If I remove those lines GHC says it can't find instances for MonadCatch etc
15:52:57 <bradparker> On ActionM that is
15:53:01 <erisco> you need to paste the actual error
15:53:21 <erisco> have you made an instance of MonadCatch and so on for BlotterT?
15:53:23 <monochrom> And paste enough code that causes the actual error.
15:53:27 <erisco> I don't know what that is but I am guessing that is your type
15:54:08 <bradparker> On BlotterT I'm using newtype and deriving
15:54:16 <erisco> GHC may use your aliases when reporting errors, but it doesn't see the alias as any different than the type it is aliasing
15:54:26 <bradparker> https://github.com/bradparker/blotter/blob/master/source/Blotter/Trans.hs#L20-L21
15:56:53 <erisco> also I thought it was TypeSynonymInstances which enabled aliases to be used in instance heads but, not FlexibleInstances, but could be wrong
15:56:57 <woodson> hi guys, question. How do you create partial function with a monad? for example if have function that is define like so
15:56:58 <woodson> Config -> Name -> IO (Maybe a)
15:57:27 <woodson> and my first argument "Config" is in a IO Config
15:57:46 <bradparker> Sorry all updating stack on this machine to run it. Thanks again for having a look
15:58:13 <woodson> how can I can create a partial function without binding first with this "<-" 
15:58:21 <Average-user> twanvl: indeed
15:58:28 <fishythefish> woodson: why do you want your function to be partial?
15:58:32 <erisco> woodson, what is a partial function to you? to me it is a function which is undefined on some argument
15:58:38 <augur> is there a good way to get Agda-mode-like interactions w/ haskell, in emacs, using stack?
15:58:47 <erisco> augur, hi
15:58:53 <augur> erisco: hello!
15:59:07 <erisco> I sensed your arrival
15:59:11 <EvanR> create a partial function... by that you may mean partially apply a function to get another function?
15:59:27 <fishythefish> erisco: was it from the join message? :P
15:59:45 <erisco> a seer has his tricks
15:59:56 <fishythefish> i thought the augur is supposed to sense you
15:59:58 <woodson> well the reason is because my Config variable is an IO Config
16:00:04 <erisco> augur, what have you been up to?
16:00:13 <woodson> I know that i use (>>=) to apply a function
16:00:20 <woodson> but if it requires more argument
16:00:44 <woodson> is there a way for me to pass the other argument without creating an anonymous func?
16:01:01 <woodson> so I thought that maybe if i created a partial function
16:01:08 <EvanR> your question is not the most clearly stated
16:01:09 <woodson> that would help me figure it out
16:01:21 <augur> erisco: work, play, the usual!
16:01:22 <erisco> okay, so partial function in the sense you seem to be talking about them do not exist in Haskell
16:01:31 <woodson> EvanR: if its partially apply cant we call it a partial function??
16:01:42 <EvanR> no
16:01:51 <EvanR> heres a partial function
16:01:53 <EvanR> :t head
16:01:54 <lambdabot> [a] -> a
16:01:58 <EvanR> > head []
16:02:00 <lambdabot>  *Exception: Prelude.head: empty list
16:02:18 <erisco> if you have  f :: Config -> Name -> IO (Maybe a)  and  x :: IO Config  and you want  y :: IO (Name -> IO (Maybe a))  then  fmap f x
16:02:24 <EvanR> as opposed to total function
16:03:14 <woodson> Sorry evanR you showed the partial function
16:03:23 <woodson> but can you show me the total function
16:03:34 <dminuoso> Im getting confused. If State is some `s -> (a, s)`, how comes StateT makes a s -> t -> ((a, s), t) out of that? Im simply not sure how to do what application to get at this result.
16:03:45 <erisco> if you have  a :: IO Config  and  b :: IO Name  and you want  c :: IO (Maybe a)  then  liftA2 f a b
16:03:48 <woodson> to be that seems like a total func, I think that I'm missing something
16:04:05 <EvanR> head isnt a total function because its undefined on []
16:04:28 <augur> woodson: length is a total function, for example
16:04:31 <EvanR> but it sounds like youre asking about ... partially applying functions with more than one variable
16:05:00 <augur> total = is defined for all inputs, partial = is only partially defined (ie is undefined for some inputs)
16:05:22 <erisco> augur, I am back to work on Monday… "usual" doesn't sound so bad right now :P
16:05:27 <woodson> evanR: Oh I see, yes I am asking about partially applying but I think that I should probably understanding the terms correctly while am at it
16:05:28 <woodson> thanks
16:05:29 <dgpratt> what's a good/simple way to get the first number in a list matching a certain condition (e.g. > 10) along with it's index?
16:05:39 <woodson> augur: thanks yea i see
16:05:51 <augur> woodson: partial application != partiality, indeed, this is an important distinction
16:06:08 <augur> fwiw all partial functions due to case coverage can be made total using Maybe
16:06:10 <erisco> dgpratt, zip with [0..] and then find
16:06:29 <augur> eg   safeHead :: [a] -> Maybe a  ;  safeHead [] = Nothing  ;  safeHead (x:_) = Just x
16:06:45 <dgpratt> ok, thanks erisco 
16:07:08 <erisco> or the classic safeFromJust
16:07:23 <EvanR> safe is a red herring here
16:07:40 <erisco> totalHead instead?
16:07:55 <EvanR> if the list is known to be non empty, safeHead is begging the question or something
16:08:08 <EvanR> or infecting your entire program with an extra Maybe
16:08:24 <fishythefish> dminuoso: which StateT are you talking about?
16:08:37 <woodson> I see!
16:08:39 <dminuoso> fishythefish: Control.Monad.Trans.State
16:09:07 <dminuoso> fishythefish: Basically I stumbled over this SO answer, and Im trying to make heads and tails of it: https://stackoverflow.com/a/13724465
16:09:12 <fishythefish> dminuoso: from the transformers package?
16:09:50 <dminuoso> fishythefish: Yeah
16:09:55 <fishythefish> runStateT :: StateT s m a -> s -> m (a, s)
16:10:49 <woodson> so a total function should not throw exception?
16:10:49 <fishythefish> when you give it a StateT, rather than giving you a "vanilla" s -> (a, s), it gives you a monadically-souped-up s -> m (a, s)
16:11:17 <woodson> thats the main difference that I see 
16:11:40 <dminuoso> fishythefish: Right. How do I mechanically insert an arbitrary monad into that signature to see what the resulting type would be?
16:11:49 <erisco> if "throws an exception" is evidence of undefinedness, then yes, it should not do that
16:11:56 <fishythefish> dminuoso: replace m with that type constructor
16:12:13 <woodson> erisco: Sorry U
16:12:19 <woodson> I read your messages
16:12:26 <woodson> but so much was going on at the same time
16:12:31 <woodson> thanks for your replies
16:12:41 <dminuoso> fishythefish: So. If I applied this to a list monad, I would get some s -> [(a, s)] right?
16:12:44 <fishythefish> dminuoso: I think you're misreading that answer, btw. it's saying that s -> t -> ((a, s), t) is what you get if you use StateT with State as the underlying monad
16:12:51 <fishythefish> the two state layers are clearly visible
16:13:02 <dminuoso> fishythefish: Yes, and I dont understand how that type (with that nested tuple) is produced.
16:13:09 <erisco> woodson, a total function must also terminate
16:13:21 <dminuoso> fishythefish: That's the basis of my question.
16:13:52 <fishythefish> dminuoso: State a = t -> (a, t), so let m = State. Then s -> m (a, s) = s -> t -> ((a, s), t)
16:14:01 <fishythefish> your example with list is correct
16:14:05 <woodson> erisco: Sorry what do you mean by terminate?
16:14:18 <woodson> completely run until the end?
16:14:23 <dminuoso> fishythefish: Fancy, so that looks an awful lot like the monadic parser that I made. :-)
16:14:31 <fishythefish> woodson: it must *have* an end
16:15:08 <dminuoso> fishythefish: Aha. so m = State, and (a, s) is the type passed to State?
16:15:24 <woodson> oh ok, with no interruption such as the exception.
16:15:24 <dminuoso> i.e. s -> State (a, s) ?
16:15:41 <fishythefish> dminuoso: yes, i.e. what you see in the signature of runStateT
16:17:01 <erisco> woodson, there are two different criteria: termination and productivity
16:17:18 <dminuoso> fishythefish: Aha. So equivalently ErrorT applied to an Either would give me some `Either (Either e a) b`
16:17:28 <erisco> woodson, termination is that, for all inputs, the computation ends in finite time
16:17:57 <dminuoso> fishythefish: Thank you, now I can finally go to bed. :-)
16:18:16 <erisco> woodson, productivity is that, for all inputs, the computation keeps producing something observable in finite time
16:19:22 <erisco> so in settings where you expect things to go on forever, like printing an infinite list, you would talk about whether that is productive or not
16:19:40 <erisco> a program like   let x = x in x   satisfies neither things, computing forever and giving nothing
16:19:53 <fishythefish> dminuoso: ErrorT e (Either f) a looks like Either f (Either e a)
16:20:15 <fishythefish> in general, ErrorT e m a is like m (Either e a)
16:22:07 <woodson> I understand
16:24:02 <dminuoso> fishythefish: So `m (Either e a)` applied to some `Either f b` would mean that f ~ (Either e a) no?
16:24:21 <Welkin> something smells fishy
16:24:33 <dminuoso> Err oh!
16:24:35 <dminuoso> Kinds!
16:24:38 <dminuoso> fishythefish: Nevermind! :)
16:25:07 <dminuoso> fishythefish: Yeah I see what you mean.
16:26:18 <Welkin> what does he mean>
16:26:19 <Welkin> ?
16:29:31 <erisco> what is a language that has partially applied functions, actually? I think it'd be some language with named arguments
16:30:04 <Welkin> what
16:30:22 <Welkin> any language with first class functions
16:30:23 * hackage simplemesh 0.1.0.0 - Generators for primitive meshes  https://hackage.haskell.org/package/simplemesh-0.1.0.0 (jonascarpay)
16:30:33 <Welkin> ideally it is curried by default
16:30:33 <dminuoso> erisco: You can do that in JavaScript with currying at least.
16:30:37 <Welkin> so, not javascript
16:30:38 <dminuoso> erisco: With stuff like Ramda.
16:30:44 <Welkin> you don't need ramda
16:30:46 <EvanR> i would have to be a language with multi-argument functions, so not haskell
16:30:53 <Welkin> you can do currying without any libraries
16:30:58 <Welkin> just manually curry
16:31:06 <Welkin> a => b => c => a + b + c
16:31:14 <ggVGc> currying in javascript is a lot more pain than it's worth
16:31:39 <erisco> the thing is, if you merely say  \y -> f x y  as a partial application of f to x, this isn't a partial function
16:31:41 <dysfigured> R.curry makes it a lot easier so you can avoid the ugly syntax of f(a)(b)(c)
16:31:44 <dminuoso> No the notion of partial application with R.curry in JavaScript is the only one that comes to mind.
16:31:59 <ggVGc> erisco: a partial function and a partial application is quite different, no?
16:32:00 <EvanR> currying and partially applying should be two different things
16:32:00 <erisco> this is a just a lambda or closure or whatever the language calls it
16:32:09 <Welkin> they are two different things
16:32:13 <dminuoso> EvanR: In Ramda its glued together into one thing.
16:32:20 <Welkin> currying is the process of creating a function that can be partially applied
16:32:22 <EvanR> well... that makes no sense
16:32:23 * hackage apecs 0.2.4.7 - A fast ECS for game engine programming  https://hackage.haskell.org/package/apecs-0.2.4.7 (jonascarpay)
16:32:24 <dminuoso> You can actually do things like g(_, 1)
16:32:33 <dminuoso> After Ramda.curry has produced your g.
16:32:37 <EvanR> when you curry a function, you make the need to partially apply unnecessary
16:32:38 <erisco> ggVGc, yeah I blame someone else for putting that in my head :P
16:32:42 <EvanR> in the process, you make it impossible
16:32:50 <ggVGc> I think scala has actually my least liked partial application/lambda syntax of any language I've used :(
16:32:52 <erisco> this isn't really a partial application*
16:32:55 <ggVGc> and I want to like scala
16:32:56 <EvanR> you cant partially apply a 1 arg function
16:33:00 <ggVGc> but I think I really don't
16:33:04 <Welkin> this just sounds like a semantics argument now
16:33:05 <fishythefish> just supply half an arg, duh
16:33:06 <dminuoso> EvanR: Well its mostly when you really want to apply the third argument, kind of as a "universal" exception to flip.
16:33:12 <dminuoso> *extension
16:33:28 <EvanR> Welkin: an attempt to establish or preserve technical jargon... maybe, semantics i wish
16:33:30 <Welkin> all functions are functions of one parameter
16:33:30 <Welkin> done
16:33:37 <ggVGc> I always considered returning a new function with some arguments filled in(from a closure) partial application
16:33:46 <EvanR> Welkin: not nec
16:33:46 <ggVGc> how is it now?
16:33:48 <ggVGc> not*
16:33:54 <erisco> or lets say  \y -> f(x, y)  to emphasise that f is binary
16:34:03 <dminuoso> ggVGc: That's the thing, in currying its not because its partially applied. The function is either applied or its not.
16:34:09 <erisco> nowhere do I see a partial application, unless we're willing to call that whole thing a partial application
16:34:11 <ggVGc> currying and partial application is different
16:34:12 <cheater> hi
16:34:16 <ggVGc> imo
16:34:18 <ggVGc> I mean, not imo
16:34:18 <erisco> so is partial application just a pattern of syntax?
16:34:20 <ggVGc> it IS different
16:34:26 <cheater> if Ethereum supported STM, would that have prevented the DAO hack?
16:34:30 <dminuoso> erisco: maybe a matter of perspective.
16:34:37 <EvanR> :t curry
16:34:38 <lambdabot> ((a, b) -> c) -> a -> b -> c
16:34:44 <EvanR> thx lambdabot
16:34:57 <glguy> While the function type is the type of values that can be applied to an argument, there's still a meaningful difference in a partially applied "function" in Haskell
16:35:10 <Welkin> erisco: no, it is the difference between producing a function vs producing a non-function value
16:35:11 <dminuoso> glguy: what is a partially applied function in haskell?
16:35:41 <glguy> If you have: f (A x) (B c) = ...  f whatever   is a partially applied function, it's not until you finish applying it again that the pattern matches will start
16:35:52 <glguy> or the strictness imposed by bangpatterns will fire
16:35:59 <glguy> similarly for data constructors with strict fields
16:36:39 <cheater> dminuoso: /win 22
16:36:43 <cheater> sorry mistyped
16:37:18 <Welkin> o.o
16:38:07 <woodson> where does System.Environment.setEnv sets the ones variable?
16:38:27 <erisco> glguy, analogous to saying  `f x` is a partial application of f iff `f x` is a function  if I am reading you right
16:38:33 <woodson> because if I execute printenv or set I cant seem to see the value that I setted
16:38:50 <glguy> erisco: We have to be careful, because it's not about the types
16:38:54 <erisco> glguy, which is somewhat awkward if  f x  is polymorphic
16:38:58 <glguy> so it's hard to use the word function
16:38:59 <fishythefish> woodson: can you supply a paste?
16:39:32 <Welkin> woodson: how are you running your code? It's likely running inside of it's own environment
16:39:53 <Welkin> so you won't be able to see it using printenv
16:40:08 <glguy> Consider this example: http://lpaste.net/1396460967927218176
16:40:09 <woodson> I am just running it with stack exec
16:40:33 <glguy> In http://lpaste.net/1396460967927218176 useit2 we have partial application, useit1 does not
16:40:50 <Welkin> woodson: try getting the environment variable back after you set it in your code and printing it out
16:41:19 <woodson> Welkin: I can get it back
16:41:28 <EvanR> i vaguely recall the f x y z to f = \x -> \y -> \z translation having some quirks like that
16:41:32 <woodson> It just that I want to create a config file now
16:41:40 <erisco> glguy, ehh I don't know about that… you'd have to desugar to case/of to say anything meaningful in my eyes
16:41:45 <Welkin> then what I said is likely the reason you cannot see it in another shell session using printenv
16:41:48 <woodson> I dont want to always execute an IO just to get my key
16:41:52 <Welkin> because it is using its own environment
16:42:00 <woodson> hmm... 
16:42:02 <glguy> erisco: In any case, it has to do with function arity, which isn't directly tied to the types
16:42:11 <Welkin> woodson: write it to a file?
16:42:28 <erisco> glguy, it has to do with how they desugar, or am I wrong?
16:42:29 <EvanR> thats wacky
16:42:30 <Welkin> woodson: wait, what are you actually trying to do?
16:42:37 <Welkin> it sounds suspicious
16:42:47 <woodson> Welkin: Its an RSA key
16:42:55 <Welkin> okay
16:42:56 <woodson> just playing with jose-jwt library
16:42:59 <Welkin> what are you trying to do?
16:43:07 <woodson> set my private key
16:43:11 <Welkin> are you reading from the environment when your application starts?
16:43:16 <woodson> as an environment var
16:43:24 <glguy> erisco: the arity affects the meaning of the definitions, sure
16:43:33 <glguy> maybe that's what you're saying?
16:43:41 <woodson> I generate the RSA when my app start and set it as en env var
16:43:43 <Welkin> woodson: you already said you set the value
16:43:53 <woodson> then retrieve it from my env var when i need it
16:43:58 <Welkin> yes
16:44:02 <erisco> glguy, well I just mean that this sense of arity would have to be based on syntax alone
16:44:06 <Welkin> I don't see a problem
16:44:48 <glguy> erisco: as opposed to the types?
16:44:58 <Welkin> if you need the key for the lifespan of your application, you can store it in memory using ReaderT (or if it changes throughout the lifespan of the application, use StateT)
16:44:58 <glguy> or were you intending a different distinction?
16:45:19 <woodson> Welkin: Because I am trying this library https://hackage.haskell.org/package/configurator-0.3.0.0/docs/Data-Configurator.html 
16:45:30 <Welkin> ReaderT is standard for storing configuration such as database access information
16:45:40 <woodson> I couldnt figure it out 
16:45:42 <Welkin> MATRIX!
16:45:45 <erisco> glguy, if you rewrote those definitions to case/of would you still be talking about arity and partial application?
16:45:54 <woodson> what the hell is happening
16:46:04 <Welkin> a piece of crap application called matrix
16:46:16 * EvanR closes that application
16:46:17 <erisco> is it netsplitting outside?
16:46:23 <Welkin> ...
16:46:25 <Welkin> god damn it
16:46:28 <Welkin> can we ban matrix?
16:46:28 <fishythefish> yeah, there's been a fair amount of netsplitting today
16:46:38 --- mode: ChanServ set +o glguy
16:46:38 --- mode: glguy set +b *!*@gateway/shell/matrix.org/*
16:46:46 <EvanR> \o/
16:46:59 <Xe> don't
16:47:07 <Xe> their javascript is having issues
16:47:16 <glguy> When they fix their JS we can undo that
16:47:18 <Xe> a logging library is causing the program to die
16:48:02 <woodson> Welkin: Could I maybe write the key to my config file
16:48:11 <Welkin> a javascript library is causing breaking errors? no way!
16:48:18 <woodson> then load the configs afterwards or would you suggest using ReaderT?
16:48:19 <erisco> glguy, if you rewrote those definitions to case/of would you still be talking about arity and partial application?
16:48:23 <Welkin> woodson: of course
16:48:32 <Welkin> woodson: just use the file writing functions
16:48:36 <glguy> erisco: Sure, the functions have arity, moving the patterns to case doesn't change that
16:49:08 <Welkin> woodson: I suggest using ReaderT to store configuration information, but it depends on how your application is set up
16:49:34 <Welkin> woodson: ReaderT is read-only. You set the data at the start of your program and can never change it. If it needs to change later on use StateT
16:49:44 <Welkin> unless restarting is fine when the config changes
16:50:21 <EvanR> configuration was meant to be changed!
16:51:00 <erisco> glguy, I can agree to that as being a notion of arity adapted to a higher order function language
16:51:33 <EvanR> arent we simply talking about arity = number of arguments?
16:51:57 <erisco> well, here we'd be talking about arity being the size of the tuple
16:52:09 <EvanR> theres no tuple so far 
16:52:19 <erisco> that is what glguy was demonstrating
16:52:26 <erisco> http://lpaste.net/1396460967927218176
16:52:36 <EvanR> i didnt see glguy use a tuple
16:52:46 <erisco> to see it you have to desugar
16:52:52 <EvanR> eh?
16:53:16 <erisco> you have to desugar the clauses to case/of
16:53:18 <crucify_me> http://lpaste.net/360561    I have a good understanding of this .. thanks for earlier help
16:53:28 <crucify_me> chop8 function
16:53:43 <EvanR> i did not know a desugaring process introduced tuples anywhere
16:55:00 <EvanR> dont patterns desugar to nested case
16:55:10 <woodson> Welking: Cool Thanks! I dont that I have anything that changes. I just putting server settings, private key and such
16:55:29 <woodson> I think that the ReaderT should be more than enough 
16:55:41 <woodson> do you have an example?
16:56:21 <ggVGc> freenode is obviously not written in haskell
16:56:26 <ggVGc> (or erlang)
16:56:36 <Xe> it's C
16:56:41 <EvanR> its also not obviously in haskell
16:56:44 <Xe> very schizophrenic C at that
16:57:01 <Xe> (i used to maintain a fork of its upstream, ircd-seven is worse)
16:58:11 <erisco> EvanR, each clause is a product of patterns, because it has to match all for the clause to apply
16:58:30 <erisco> then every clause becomes a separate case
16:58:48 <EvanR> that doesnt prove its not just nested cases on one variable
16:59:10 <erisco> I don't see why I'd have to prove that (though I don't know what you mean either)
16:59:19 <EvanR> ok
16:59:36 <EvanR> arity = number of arguments
16:59:58 <EvanR> (unless youre in another language where it also means the dynamic type of arguments too)
17:00:38 <boj> does arity mean anything in haskell considering every function has an arity of exactly one?
17:00:50 <EvanR> that is what we are talking about
17:00:57 <EvanR> http://lpaste.net/1396460967927218176
17:02:13 <erisco> you would have to acknowledge that  f = \x y -> case (x, y) of …  is a binary function
17:02:31 <Welkin> woodson: I don't have a good example on hand, but I like this tutorial on using persistent with servant that has an example of using ReaderT http://www.parsonsmatt.org/2015/06/07/servant-persistent.html
17:02:42 <EvanR> seems reasonable
17:02:54 <erisco> or you have to acknowledge that this measure of arity is a measure of the syntax only
17:03:40 <EvanR> seems reasonable
17:04:01 <erisco> what glguy suggested was a strictness test to determine arity… it is not a bad idea
17:04:21 <glguy> arity shows up in other places to in GHC specifically rather than in the language definition
17:04:37 <glguy> like in optimizations, but that might not count for this discussion
17:04:53 * hackage riak-protobuf 0.23.0.0 - Haskell types for the Riak protocol buffer API  https://hackage.haskell.org/package/riak-protobuf-0.23.0.0 (lambda_foo)
17:06:22 <erisco> so my particular syntax example  f = \x y -> case (x, y) of …  is not complete enough… it matters what the cases are
17:10:22 <Average-user> It is possible to make an instance of Show for [MyDataType]?
17:10:44 --- mode: glguy set +q *!uid201163@gateway/web/irccloud.com/*
17:10:47 <erisco> glguy, I think I misread your example slightly. It seems more nuanced about how seq works
17:11:01 <erisco> Average-user, no
17:12:33 <glguy> Average-user: You can define showList in your instance Show MyDataType
17:12:39 <cheater> is haskell, or a useful subset of it, context-free?
17:12:49 <glguy> keep in mind that Show is for emitting the Haskell source corresponding to your value, not pretty printing, so don't get too creative
17:12:53 * hackage riak-protobuf-lens 0.23.0.0 - Lenses for riak-protobuf  https://hackage.haskell.org/package/riak-protobuf-lens-0.23.0.0 (lambda_foo)
17:13:18 --- mode: glguy set -q *!*@gateway/shell/matrix.org/x-rjpolznvbygajodd
17:13:19 <erisco> cheater, I don't think you can model layout with a CFG
17:13:21 <woodson> Welkin: Thanks, I've seen before. This person has great tuts!
17:13:35 <fishythefish> Average-user: if you have a Show instance for MyDataType, then [MyDataType] will have automatically have one as well, but you only get to control what it does per-element
17:14:07 <Average-user> But I want to Show the list in a different way
17:14:17 <fishythefish> no, you don't
17:14:30 <fishythefish> the point of Show is not to pretty-print
17:14:47 <Average-user> glguy: "You can define showList in your instance Show MyDataType" I can? 
17:15:08 <monochrom> A context-free language has to be statically untyped.
17:15:23 <bradparker> erisco: sorry that took an age, just got stack updated and the app running on this machine. This is what I get when I remove those two "copies" of ActionT's instances http://lpaste.net/360566
17:15:44 <monochrom> It also cannot enforce "declare before use" or "declare somewhere at all if you use"
17:16:06 <monochrom> So for example it can't even have an import-export system
17:16:41 <monochrom> So maybe Tcl comes close to being context-free.
17:17:00 <erisco> glguy, oh never mind, shouldn't have second guessed it :) wrote it out to double check
17:20:03 <erisco> so we're saying f is at least binary iff f ⊥ ≠ ⊥ and f x is a function
17:20:29 <cheater> erisco: i don't really care about layout, i care about semantics a bit more than that
17:20:53 <cheater> if haskell had to use parens everywhere (like lisp or something) would that be context-free?
17:20:57 <erisco> cheater, what do the semantics have to do with context free? I thought you were talking about parsing
17:21:58 <erisco> there is also question of how you handle things like operator infixities
17:22:23 <erisco> if you're goal is to parse them as stated in the source file then you're in trouble with CFG, not doable
17:22:33 <erisco> if your*
17:23:01 <erisco> on the other hand you can choose a weaker grammar that is sufficient for you to construct the correct tree in later processing
17:23:14 <erisco> but that is a slope towards .* so you have to choose wisely
17:23:25 <cheater> semantics are as i understand used to define parsing
17:23:35 <erisco> that's syntax
17:23:55 <cheater> in denotational semantics, it seems syntax follows from semantics
17:24:06 <erisco> that is precisely backwards
17:24:12 <cheater> as in you have parser generators that take DS and give you a parser
17:24:39 <cheater> erisco you're confusing me :))
17:24:54 <erisco> you define a syntax, with a grammar of some sort, and then you say what that syntax means, and that is called the semantics
17:25:11 <cheater> i'm just reading up on DS, and trying to learn something about languages. i thought DS could only be used to define context-free languages. is that right?
17:25:23 <cheater> erisco ok yeah
17:25:52 <erisco> it doesn't make a lot of sense the other way around… it is like suggesting that the notations used in set theory are logically derived from the concept of sets
17:26:04 <cheater> OK
17:26:10 <cheater> are there any "day to day" programming languages that are CF that i might know?
17:27:19 <infinisil> Is there a function defined already that does cartesian multiplication of 2 lists?
17:28:40 <cheater> there was some funny code snippet i have
17:28:44 <mud> > liftA2 (*) [2,3,5] [7, 11] -- this ?
17:28:45 <erisco> I don't know… maybe C# or Java or something, but day-to-day PLs are not concerned about fitting into CF
17:28:46 <cheater> that someone showed me here
17:28:46 <lambdabot>  [14,22,21,33,35,55]
17:28:50 <cheater> right yeah liftA2
17:29:12 <infinisil> mud: Ah, not that kind of multiplication
17:29:13 <cheater> you could do liftA2 ( (,) ) possibly to get the pairs
17:29:26 <erisco> the concern technically is just to be efficiently parsed, and that may mean it ends up in CF because they want to use some specific parser generator which supports a CF subset or something
17:29:31 <infinisil> [1, 2, 3] `cp` ['a', 'b', 'c'] = [(1, 'a'), (1, 'b'), ..., (2, 'a'), (2, 'b')
17:29:40 <erisco> but many parsers are just recursive descent with regexp tossed in
17:29:40 <mud> > liftA2 (,) [2,3,5] [7, 11] -- this one then? Hehe
17:29:42 <lambdabot>  [(2,7),(2,11),(3,7),(3,11),(5,7),(5,11)]
17:29:55 <erisco> and then whatever other fiddly bits one wants to work in
17:30:05 <infinisil> > liftA2 (,) [1..3] [1..3]
17:30:07 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
17:30:14 <infinisil> neat!
17:30:23 <mud> That's the list instance of Applicative at work
17:30:53 <cheater> erisco: i'm trying to design a small language that'll make sense, so i am wondering what design principles i should go with
17:31:29 <mud> I don't think there's a lot of reason to worry about your language being context-free, except for maybe to make it easier for tools to parse it. But ... I would think that'd be limiting.
17:31:34 <erisco> oh, well don't worry about syntax then, that is least important
17:31:52 <erisco> semantics semantics semantics!
17:31:56 <infinisil> I actually want to implement such a function (that does (\xs -> liftA2 (,) xs xs)) in Nix, so I thought of having a look at a haskell implementation
17:32:36 <erisco> make syntax choices which are good enough for now and refine later once you sort the semantics out
17:32:38 <infinisil> Oh, duh, it's easy
17:33:12 <cheater> yeah
17:33:27 <cheater> so i want the language to have the minimum amount of power necessary to do useful things expected from it
17:33:37 <cheater> and basically what it'll be is a thing to write callbacks in
17:35:18 <cheater> so for example, i don't need full TC. primitive recursive is fine as well. assured termination and totality would be great, as well as laziness, and obviously memory safety.
17:35:31 <erisco> to refine what I objected to earlier wrt syntax following semantics… it is that for every valid syntax there is a meaning, but it not necessary that for every meaning there is a syntax
17:35:42 <cheater> the main theme here is that it should lead to as few surprising combinations of features as possible
17:36:17 <cheater> erisco can it be that you are thinking of operational semantics? in denotational semantics this seems to be different
17:36:40 <cheater> i don't know a lot about either, i'm just learning now
17:37:45 <cheater> i also wonder what other things i could do to make the language easier to reason about. (purity is another thing that's probably a good idea)
17:38:46 <erisco> I am trying to think about how this would apply to operational semantics… my experience with that is that it is much more inventive, so you're coming up with the semantics in pace with the syntax
17:39:10 <erisco> in which case it is reasonable to suspect you wouldn't have semantic expressions which did not also have a corresponding syntax
17:39:55 <erisco> but with denotational semantics you are choosing some mathematical theory or theories for your semantic domain
17:40:20 <ski> cheater : primitive recursion assures termination
17:40:29 <cheater> ski: indeed
17:40:31 <erisco> so you take on board the entire ecosystem of that, in which it seems likely you'd have things to say in that theory which did not have a syntax in your language
17:41:23 <erisco> but it would also be possible that you have a 1:1 with denotational as well, I just don't see it as necessary
17:43:26 <infinisil> Just reading through your conversation, little note: I think Nix is context-free
17:43:43 <erisco> the approach, as I listened to conal explain it, begins with understanding the domain of your problem and making smart denotational choices
17:44:18 <erisco> I suppose you could start with a theory and then ponder various syntaxes you could give it
17:45:01 <erisco> but really the syntax shouldn't be the important focus of what you're doing
17:47:15 <cheater> thanks infinisil 
17:47:28 <conal> erisco: agreed. start with the denotational model. syntax is secondary and can change easily, with each candidate syntactic construct explained in terms of the denotational model. a similar (and more useful) story for API design rather than language.
17:47:55 <cheater> erisco: i am operating from the introduction of this book. it's only 3 pages. do you think you'd like to read it and tell me if what i said above is based in the text? http://people.cs.ksu.edu/~schmidt/text/DenSem-full-book.pdf
17:49:26 <cheater> conal, erisco other than having the features i mention above (denotational semantics, primitive recursion only, assured termination, totality, purity, memory safety, type safety, laziness) what other things could i do to make a language 1. less powerful and 2. less surprising?
17:52:26 <erisco> if you truly have semantics then you could argue that that leaves no surprises
17:53:52 <cheater> so i'm trying to prevent things like, say, surprising turing completeness (or -ish), or aliasing, or other things that will just surprise a programmer if he hadn't had his tea yet.
17:54:04 <erisco> I would interpret "less powerful" as meaning more tailored to a niche
17:54:40 <erisco> and not necessarily to do with its computational power
17:55:41 <cheater> the niche is that it is used for defining callbacks. there are a few things this should explicitly not be able to do: 1) create daemons 2) define GUI applications 3) define interpreters for other languages
17:55:49 <erisco> I can't recall the last time I looked at a program and proclaimed "By Jove! This is Turing complete!"
17:56:09 <cheater> programs aren't turing complete - but they use languages that are
17:56:30 <erisco> well, that is kind of my point
17:56:31 <aplainzetakind> The final line of a 'stack build' output is 'Registering <packagename>'. Where does it register exactly, if stack is supposed to sandbox the projects?
17:56:38 <cheater> so for example, something like an ini file, if that had turing complete syntax, that would be a nonsensical ini format
17:56:45 <erisco> I haven't read a feature list of a language and was startled by "Turing complete" either
17:56:56 <cheater> would you like a config file format that's TC?
17:57:01 <mud> aplainzetakind: In the appropriate sandbox
17:57:05 <cheater> it would be startling to me
17:57:09 <erisco> it sounds like you're asking how to make a practical language, and the relevance of Turing completeness there is obscure
17:57:35 <cheater> yes, i am asking that
17:58:21 <cheater> the relevance here is that i estimate that the language does not need TC, so i do not want to include it, as it can lead to confusion, and i explicitly need assured termination, which is not possible with TC.
17:58:36 * fishythefish can't remember the last time he proclaimed "By Jove!" at all
17:58:50 <erisco> what's the analogy… it is like measuring the progress of assembling an airplane by its current weight
17:58:57 <aplainzetakind> mud: How is that determined? To be more precise, what is an example usage where something being built will be registered with a sandbox strictly higher up in an hierarchy?
17:59:38 <erisco> saying that Turing completeness leads to confusion is a gross misapplication of that quality
17:59:49 <aplainzetakind> In my limited experience, I enter a folder foo, stack build there, and it builds the package foo, and registers it with itself I suppose?
17:59:50 <Average-user> cheater: For what would this language be? Without being Turing Complete, you wont be able to do most stuff
18:00:08 <mud> aplainzetakind: I don't know the exact logic. It acts a lot like it's one sandbox per project, at least it's hard to tell the difference (except it compiles a lot less than naively doing that)
18:00:28 <aplainzetakind> Hmm.
18:00:33 <aplainzetakind> OK. Thanks.
18:00:41 <cheater> Average-user: agda isn't tc and nobody scoffs at it
18:01:00 <mud> Where "project" is something like, a stack.yaml file. Though it's not quite that simple because you don't always have a stack.yaml file.
18:01:29 <erisco> if you want a language programmers like using then you need to apply a science much more direct
18:01:33 <Average-user> cheater: Html, isn't TC too, but my point it is that depends on what do you want to do with the language
18:01:42 <erisco> make a version of the language, call it A, and have some programmers try it out
18:01:44 <cheater> erisco: can you explain?
18:01:53 <cheater> oh
18:02:02 <cheater> ok yeah, that's part of the plan
18:02:02 <erisco> then make another version called B, it is almost like A but slightly different, then have a different group of programmers try that one
18:02:16 <erisco> see which group performs better, or see which liked their experience the most
18:02:17 <cheater> yeah i know about such processes
18:02:43 <erisco> that's a way to figure out if the language is working pragmatically
18:02:43 <cheater> i'm not concerned with this. this is the obvious part. i'm just wondering what sort of properties i could try and give the language to make programs written in it less surprising.
18:03:23 * hackage hw-kafka-client 2.2.0 - Kafka bindings for Haskell  https://hackage.haskell.org/package/hw-kafka-client-2.2.0 (alexeyraga)
18:03:37 <cheater> no amount of iteration will make me spontaneously come up with computer science concepts i could implement, that's why i am here and asking opinion on possible directions.
18:04:13 <cheater> i know quite well the general algorithm for trying out concepts :)
18:04:21 <cheater> but thanks :)
18:05:24 <LydianSyrinx> Hi
18:06:03 <erisco> I don't know… I think of it from a scientific perspective and I don't have any data to suggest certain language features are better or worse
18:06:14 <cheater> i do
18:06:26 <erisco> though I read managed memory increased productivity
18:06:37 <cheater> for example, purity is to me very obviously better to have than not to have, and it's obvious to me that it leads to less confusion
18:06:48 <erisco> but that is a single data point, cheater
18:07:02 <erisco> and maybe 1759 others if you count the channel
18:07:06 <cheater> ok let's roll back this conversation a little
18:07:08 <aplainzetakind> mud: can you stack build without stack init'ing?
18:07:15 <cheater> here's why i came here:
18:07:33 <aplainzetakind> because the latter creates the stack.yaml, no?
18:07:43 <cheater> i am trying to design a computer language. i am thinking about what features could make it less easy to write errors in
18:07:43 <mud> aplainzetakind: Like if you have a project with a .cabal file and want to build that? No, you have to init first, or create a stack.yaml some other way if you prefer.
18:08:06 <cheater> the kind of things i am looking for are properties of computer languages that i could define my language to have.
18:08:27 <erisco> perhaps a language which is unpleasant to use, because that keeps people's minds working, and so they're less likely to become complacent
18:08:31 <cheater> i am not exactly looking for general advice on how to structure my work. that is appreciated, but it is not why i am here.
18:08:46 <cheater> erisco, that is an interesting point
18:08:49 <cheater> and very relevant
18:09:27 <cheater> i should think about this some more. does an alien syntax keep people on their toes? and will keeping people on their toes lead to less, or more, errors in their work?
18:09:36 <cheater> that's an important consideration.
18:09:51 <erisco> but to approach this from a perspective absent the human, because I think all the answers there will be complicated, then the knob you can turn up and down is static analysis
18:10:20 <Average-user> No, alien syntax does not prevent errors, don't think so
18:10:54 <Average-user> It just takes you more time to make one, but thats because it takes you more time to write
18:11:42 <erisco> as long as we acknowledge that no language can instill perfect programming capabilities into a human, then a language which decreases the surface area on which the human can make mistakes is a safer language to use
18:11:56 <cheater> i will have to read up on design language of interfaces in high-stress environments, but i believe the take away there is that emphasis on ease of understanding the function of design elements, as well as the ability to differentiate them, results in less errors
18:12:26 <Average-user> I still without understand why you don't want it to be Turing Complete?
18:12:26 <cheater> this would for example mean that i should explicitly make it impossible to have overloading
18:12:51 <cheater> Average-user: let's not focus on this. we can talk about it later if you'd like, but i think this would derail the discussion.
18:13:17 <Average-user> Ok, but I think that it is relevant to the language design 
18:13:39 <Average-user> It tells about the "Why?" of the language
18:14:30 <mud> Average-user: Turing-complete has some disadvantages. Most obviously, it means you can't always tell if a program will ever complete or not, which is pretty often something you'd want to do. Though usually you want to know more than that, like ... that it'll complete quickly or not.
18:14:34 <cheater> well, a callback, say like a render handler for a web server, needs to terminate eventually and return what the daemon running the callback requests of it
18:14:47 <cheater> so essentially by that virtue alone we know that the function MUST terminate
18:14:59 <cheater> therefore, it should not have turing completeness available to it
18:15:13 <cheater> because from TC can follow non-termination
18:15:30 <erisco> okay but that is a decision driven by the domain of the problem, not by notions of what makes the language easier to use
18:15:47 <cheater> i think it also adds easiness
18:15:55 <erisco> Agda is total because the logic wouldn't work otherwise, it'd be unsound
18:16:15 <cheater> i wonder if the language should be applicative. applicatives always have the same shape of computation.
18:16:42 <cheater> applicatives are sub-TC, right?
18:16:51 <cheater> (i believe so)
18:17:02 <erisco> the perspective I would have on easiness wrt totality is that the compiler can tell you when your program is not total, in a problem domain where totality is necessary
18:17:24 <erisco> this is about removing unnecessary opportunities for the human to make an error
18:17:44 <cheater> indeed what i want is to minimize the avenues for errors to transpire
18:18:02 <erisco> but to say that it is easier across the board of all measures is probably not true
18:18:17 <erisco> and that is because you may conceive of solutions to a problem which are total but the language cannot recognise as such
18:19:07 <erisco> so now, from the human's perspective in that instance, the language is impeding their work, not helping
18:19:08 <cheater> i'm not talking about easy as in "easy to quickly write a program in", i am talking about easy as in "when you read a program, it should be easy to come to right conclusions about it, and difficult to come to wrong conclusions"
18:19:28 <cheater> i don't think i mentioned easy at all, tbh
18:19:33 <cheater> i think you're the one who came up with this
18:19:34 <cheater> :))
18:19:54 <erisco> you just said "i think it also adds easiness"
18:20:24 <erisco> and you said "make it less easy to write errors in"
18:21:12 <cheater> i should have said "simplicity", as in "i think it also adds simplicity"
18:21:24 <Average-user> mud: Being not Turing complete doesn't ensure you will able to know if the program will end, not necessarily 
18:21:59 <cheater> Average-user: no, but being able to assure termination does mean sub-TC.
18:22:59 <monochrom> The question of "I give you two context-free grammars, you determine whether they generate the same language" is already undecidable, for example.
18:23:16 <mud> Average-user: Right. It's necessary, but not sufficient.
18:23:25 <cheater> i'm fine with that monochrom 
18:23:45 <cheater> my language does not need to be able to define context-free grammars :)
18:24:13 <monochrom> It was meant for mud.
18:24:29 <monochrom> It just so happens that everyone suddenly cares about context-free today out of the blue.
18:24:47 <erisco> everyone likes free stuff
18:25:07 <cheater> monochrom: what are some practical languages that are context-free?
18:25:20 <cheater> monochrom: and could a version / subset of haskell be context-free?
18:25:22 <monochrom> So that if I ever have the substring "context-free" everyone suddenly thinks I'm talking to them.
18:25:27 <mud> monochrom: I'm sure that's something I knew at one point, but that's still somewhat surprising. Will have to ponder that.
18:25:36 <monochrom> Whereas I am just commenting on termination not context-free.
18:27:41 <erisco> cheater, difficulty and misapprehension sound like subjective and complicated topics. If you find any solid data on these wrt PLs then let me know, but I have never seen it
18:29:10 <erisco> the only tool I have is the hammer of static analysis… if a programmer makes a mistake then all I can think to do is re-engineer such that it is no longer something the programmer has to think about
18:29:37 <erisco> as long as the programmer is allowed to make decisions, those decisions can be wrong, and there isn't a thing you can do other than take them away
18:30:29 <cheater> erisco: i'm not looking for solid data or objective conclusions. i'm looking for ideas. you're trying to do too much.
18:31:01 <cheater> :)
18:31:43 <monochrom> I agree. erisco should have just nodded along and not think independently.
18:32:23 * hackage intrinsic-superclasses 0.2.0.0 - A quasiquoter implementation of the Intrinsic Superclasses Proposal  https://hackage.haskell.org/package/intrinsic-superclasses-0.2.0.0 (dailectic)
18:32:27 <cheater> i've got no idea where that came from monochrom..
18:38:46 <erisco> try various type system features such as linear typing, effect typing coeffect typing, subtyping, row types … try different paradigms such as functional, procedural, object oriented, logic
18:41:43 <erisco> there are lots of ideas to be found running through the features of existing languages, no? I am not sure what pertains to the domain of callbacks to be more specific than that
18:42:21 <texasmynsted> ok, I am using cassava and am simply trying to convert one csv file to another...  I can decode by index the original file into a vector that I can then read 
18:42:30 <erisco> you suggested totality… okay, makes sense… is time relevant? maybe you want a semantics involving time
18:43:01 <erisco> what about distributed computing? maybe you want a semantics which accounts for that
18:43:50 <erisco> perhaps something about concurrency?
18:44:06 <texasmynsted> For some reason I seem to have a mental block on taking the newly altered vector and writing it out.  The Data.Bytestring.Lazy expects an array of bytestrings rather than vector
18:44:06 <mud> Depending on how important it is that things provably run quickly, you could think about looking at cryptocurrency scripting languages. Those have that requirement (and others). Though that's probably more restrictive than is useful.
18:46:38 <monochrom> When you said "array" you meant list. I think you are supposed to use vector's toList.
18:46:48 <monochrom> I certainly did that.
19:00:21 <erisco> cheater, some vague concepts I can throw at you are locality and zoom, and they have some part both in semantics and the presentation thereof
19:01:25 <erisco> cheater, things which are related should be in proximity to one another. I want to accidentally see the solution even if I am fixated on the problem
19:01:44 <texasmynsted> heh yeah list
19:02:26 <erisco> cheater, this becomes a problem of real estate though, so the other concept is zoom, where I can choose how much detail and what detail I want to see
19:02:53 <texasmynsted> thank you.
19:02:56 <erisco> this is mostly a presentational consideration
19:03:44 <erisco> programming has always been at one zoom level, and it is the most detailed one … to step back you have to make UML diagrams and suchlike
19:17:55 <d-fish> I'm having trouble evaluating https://github.com/jwiegley/gitlib/tree/master/gitlib. Can I use this library script git? What's the equivilant to "git status"
19:18:26 <gyroninja> Hi, I'm new to haskell and am trying to figure out how function composition is working. part2 is a function and input is a variable. When I try "print . part2 input" I get an error. On the other hand if I do "print(part2(input))" it works correctly. I've seen only that f . g(x) was equivalent to f(g(x)) so I am confused. Error: https://hastebin.com/jiniyejeju.hs
19:18:51 <glguy> f . g(x) isn't equivalent to f(g x)
19:18:51 <geekosaur> gyroninja, function application is highest precedence
19:18:57 <geekosaur> (print . part2)
19:18:57 <glguy> (f . g) x is
19:19:04 <ski> `f . g(x)' is parsed as `f . (g(x))'
19:20:06 <gyroninja> ok thanks
19:20:37 <monochrom> There was once I was in a math channel and an asker asked "how do I calculate 1+2/3+4" or something along that line.
19:20:52 <monochrom> So I asked "could you add more parentheses to show what you mean?"
19:21:10 <monochrom> They gladly answered "1+(2)/(3)+4"
19:21:11 <geekosaur> d-fish, that library looks incomplete. and I don't see anything equivalent to git status in it
19:21:19 <gyroninja> What would be the best / most common way to format it? "(print . part1) input", "print $ part1 input", or "print (part1 input)"
19:21:33 <Average-user> second
19:21:48 <gyroninja> thanks
19:21:55 <Average-user> depends on the context to be honest
19:22:00 <ski> monochrom, hehe
19:22:00 <glguy> print (part1 input)
19:22:12 <geekosaur> that's actually something of a religious question tbh
19:22:20 <Average-user> yeah
19:22:29 <ski> gyroninja, anything but the second option
19:22:35 <geekosaur> and you'll find stauch adherents of all three creeds
19:22:45 <Average-user> ski: why not the second?
19:22:48 <[Leary]> print . part1 $ input
19:22:53 <[Leary]> imo
19:22:54 <ski> useless use of `$'
19:22:57 <monochrom> I don't think printing and part2ing are so closely related as to warrant (print . part2).
19:23:23 <monochrom> Unlike for example (take 3 . map f . enumFrom 10)
19:23:28 <Average-user> ski: no that useless 
19:23:56 * ski almost only uses `$' right before `\'
19:24:14 <ski> (and `do' and other keywords like `if',`case')
19:27:29 <monochrom> Just a few days ago a $-user intended "h (map f) (g x)" and they wrote "h $ map $ f $ g $ x" and could not see what's wrong with it or why it meant anything but what they intended.
19:27:44 <monochrom> Basically there is too much cargo-culting.
19:28:22 <mud> ($) should totally be "guess what I mean"
19:28:51 <monochrom> TDDR = type-directed dollar resolution
19:31:00 <monochrom> The programming industry is blessed with the fact that anyone who doesn't resent algebra would make more money by becoming quants instead at the very least.
19:31:39 <monochrom> So we're basically left with practitioners who avoid parentheses (or anything that reminds them of algebra) at all costs.
19:32:24 <monochrom> A second example being: I once came across an OOP fan, right here in this channel, who insisted that "x.add(y)" was superior to "x+y".
19:33:46 <tabemann> the proper way to do it is "h . map f $ g x" obviously
19:34:00 <texasmynsted> wow cassava is a lifesaver
19:34:03 <texasmynsted> :-)
19:34:16 <tabemann> I find overuse of $ to be ugly, so I try to use . when I can
19:34:27 <tabemann> (but $ is preferable over parens)
19:34:46 <monochrom> Totally blows us back 60 years by discarding the main contribution of Fortran.
19:35:02 <lyxia> what main contribution
19:35:19 <monochrom> That you can write algebraic expressions like x+y+z*t
19:36:18 <tabemann> it's a *good* thing that in haskell you can define arbitrary operators with arbitrary precedence
19:36:43 * tabemann hates it when languages have only a fixed set of operators
19:36:55 <monochrom> Before Fortran, at best you had to write "tmp1 := x+y; tmp2 := z*t; answer := tmp1+tmp2". At worst you had to write like assembly code.
19:37:54 <lyxia> that's amazing
19:37:54 <monochrom> Take a look at COBOL's "MULTIPLY Z BY T INTO TMP2" for an example.
19:38:49 <tabemann> it's amazing that people tolerated that
19:39:03 <monochrom> And even today you can find on youtube a bunch of COBOL fans saying "it's easy to debug, it reads like English".
19:39:07 <tabemann> even assembly is better in being typically not so needlessly verbose
19:39:41 <monochrom> Programmers don't want algebra, they don't want Fortran's contribution, they want code to read like English. Just look at Larry Wall.
19:39:48 <tabemann> (aside from that back in the day a lot of archs didn't have proper mul or div instructions, so one'd have to use libraries or like or code them themselves)
19:39:50 <[Leary]> monochrom, I'm pretty sure most people just pick $ over () for aesthetic reasons. Since when do math-fearing types learn Haskell anyway?
19:40:11 <tabemann> Perl is how you don't design a language
19:40:16 <lyxia> COBOL-Stockholm syndrome
19:40:53 <monochrom> When math-fearing types don't pre-know that Haskell came from a substantially mathy background.
19:42:30 <monochrom> A similar thing happens to all of computer science and/or programming. A lot of algorithm-fearing types choose a computer science major or a programming major.
19:42:53 * hackage riak 1.1.2.2 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.1.2.2 (lambda_foo)
19:42:58 * ski picks brackets over `$', partly for aesthetic reasons
19:43:30 <lyxia> ski++
19:44:14 <HaskellLord69> I will usually type $ first because just hitting left paren automatically inserts a right paren in emacs and that's super annoying almost all of the time.
19:44:52 <HaskellLord69> if I think it looks cleaner or more organized with parens ill switch
19:45:02 <[Leary]> The whole point of using an editor like vim or emacs is having full control over it—disable that?
19:45:04 <monochrom> A CS department that welcomes all new students and then do the real screening after their first year, such as the department I'm in, can find that basically 80% of the new students are not up to it.
19:45:24 <HaskellLord69> theres probably a way... its emacs!
19:46:14 <HaskellLord69> where are you at monochrom
19:46:15 <monochrom> My emacs doesn't auto-insert the right paren.
19:46:24 <tabemann> neither has mine
19:46:28 <monochrom> University of Toronto at Scarborough
19:46:32 <c_wraith> sometimes the way is "write thousands of lines of elisp)
19:46:33 <HaskellLord69> confession time, im actually a filthy spacemacs peasant
19:46:33 <EvanR> does it insert the wrong paren
19:46:35 <c_wraith> "
19:46:42 <tabemann> I think you're mistakening emacs for eclipse
19:46:48 <monochrom> Heh. No it doesn't auto-insert any paren.
19:47:05 <ski> HaskellLord69 : turn of paredit, or learn to slurp ?
19:47:18 <HaskellLord69> *googles slurp*
19:47:22 <tabemann> just use normal emacs with haskell-mode
19:47:39 <EvanR> spherical linear interupulation
19:48:04 <HaskellLord69> spacemacs was and is my first emacs
19:48:08 <HaskellLord69> im not sure if im ready for that leap just yet
19:48:14 <HaskellLord69> its scary
19:49:05 <monochrom> I don't mean to talk you out of using your setup.
19:49:33 <ski> HaskellLord69 : <https://mumble.net/~campbell/emacs/paredit.html>
19:49:39 <HaskellLord69> I know, its all fun here.  Eventually i'll make that dive
19:49:58 <monochrom> Use a hex editor for a real dive. :)
19:50:58 <EvanR> when will they invent the editor editor
19:51:09 <monochrom> In ncurses-hexedit: <tab> {-# LANGUAGE BangPatterns-#} <tab> 0a <tab> module M where <tab> 0a 0a ...
19:52:07 <HaskellLord69> no plz
19:52:17 <monochrom> Just kidding!
19:55:09 <[Leary]> Re the brackets thing, I mostly just hate nested brackets, particularly where they're adjacent. Compare ((... . ...) (... ...)) with (... . ... $ ... ...)
19:55:59 <HaskellLord69> it was "smartparens" SPC-t-p toggles it off
19:56:19 <ski> ic
20:19:23 * hackage heyefi 2.0.0.1 - A server for Eye-Fi SD cards.  https://hackage.haskell.org/package/heyefi-2.0.0.1 (ryantm)
20:20:23 * hackage shelly 1.6.9 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.9 (GregWeber)
20:29:01 <jm_> Hi folks, I have a  (probably dumb) question. I'm using the Data.Set library (https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Set.html) with `containers >=0.5.10.2,` in my cabal file, and my code is failing to compile with `Module ‘Data.Set’ does not export ‘take’.`
20:29:37 <jm_> Which I don't understand, since the documentation page for Data.Set lists take as one of the exported functions
20:30:15 <jm_> Am I doing something wrong? Does it not actually export `take`?
20:30:32 <jm_> fwiw, I'm importing it with `import qualified Data.Set as Set`
20:30:57 <glguy> That version of containers does export take from Data.Set, so you're not using that version of containers
20:31:35 <glguy> If you want to put the cabal file you're using, commands you're using to build, command output, etc on the pastebin: lpaste.net we could take a look
20:34:21 <jm_> OK, my build command is just `cabal build`. The cabalfile is http://lpaste.net/8832104102486867968 The code with the issue is http://lpaste.net/360569
20:35:37 <jm_> Actually, what you said may have solved it. `cabal list --installed` shows that my containers version is just `0.5.7.1`
20:36:00 <jm_> so, next question: Why didn't it use the version I asked for in the cabalfile?
20:36:15 <glguy> jm_: what happens when you run cabal configure?
20:36:33 <jm_> `At least the following dependencies are missing: containers >=0.5.10.2`
20:39:07 <jm_> cabal install refuses to upgrade it (complains that a version is already installed)
20:39:22 <glguy> Is that in a sandbox?
20:39:35 <jm_> yes
20:39:42 <glguy> You can only have one version in a sandbox
20:39:51 <glguy> containers isn't something you typically upgrade, it comes with GHC
20:39:52 * hackage stack 1.6.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.6.1 (borsboom)
20:40:07 <glguy> You can use different versions via new-build or not using a sandbox, however
20:40:19 <glguy> (I'm not sure if you can work around this in a sandbox)
20:40:40 <jm_> oh, that's interesting. I had completely misunderstood sandboxes
20:43:30 <jm_> I'm going to see if I can get stack to build it. Thanks for the help, @glguy!
20:48:04 --- mode: glguy set -b *!*@gateway/shell/matrix.org/*
20:49:03 <suzu> yo glguy 
20:49:07 <suzu> why did you write glirc?
20:49:27 <glguy> I wanted a client that was good for being an op
20:49:30 <suzu> or phrased better: what inspired you to write glirc
20:49:38 --- mode: glguy set -o glguy
20:49:47 <suzu> good for being an op?
20:49:59 <suzu> are regular irc clients not good for being an op?
20:50:59 <glguy> I wanted it to be easier to search messages, be able to see joins and parts without it dominating the chat, be able to toggle ignores on and off without losing information
20:51:23 <suzu> ohh i see
20:51:30 <suzu> and so you just said AY ILL WRITE MA OWN IRC
20:51:36 <suzu> did that not seem like a lot of work from the outset?
20:51:47 <glguy> wanted commands that list bans not to flood fill the chat window and permanently scroll messages out of view
20:51:57 <suzu> or will be unpleasant or tedious to build
20:52:12 <glguy> I like programming, it was nice to have a project
20:52:29 <suzu> but you also program at work, im sure
20:52:41 <suzu> so, programming at work. then going home to program some more
20:52:43 <glguy> yeah, I do that too.
20:53:13 <suzu> i write haskell at work, and when i get home i want to not write stuff anymore
20:53:29 <suzu> though there used to be a time many moons ago where id just go write big projects and not think too much and everything was great
20:53:33 <suzu> :/
20:53:38 <HaskellLord69> you're lucky you get to write haskell at work
20:53:51 <suzu> it was not easy
20:53:53 <HaskellLord69> well, maybe lucky is the wrong word
20:53:56 <glguy> I go through phases, sometimes I want to program, sometimes i want to play games, sometimes I want to read
20:53:57 <HaskellLord69> fortunate*
20:54:00 <glguy> glirc was a programming phase :)
20:54:09 <suzu> i had to do a lot of selling to leadership to get them to let me do it
20:54:23 <Welkin> glguy: sometimes you want to dance the night away!
20:54:29 <HaskellLord69> I can imagine selling f# to the guys at work, but I think haskell is a stretch
20:54:30 <jle`> quick someone ask a really interesting haskell question to nerdsnipe glguy 
20:54:38 <jle`> so i have a shot at beating him at aoc
20:54:38 <glguy> You can't trick me, I have a  timer set!
20:54:50 <suzu> oh haha advent of code
20:54:55 <suzu> i've already fell behind on that
20:55:01 <jle`> i have been foiled
20:55:04 <suzu> seems intimidating to catch up and uhhhh ill just not bother anymore
20:55:07 <HaskellLord69> I write some monstrosity and then look at his afterwards
20:55:33 <suzu> i felt like the moon master when i saw my solution matched glguys :)
20:55:36 <Welkin> I haven't bothered with AoC
20:55:43 <jle`> doo ittt
20:55:44 <Welkin> I have too many other higher priority things
20:55:46 <jle`> peer pressure
20:55:53 <jle`> yes you do, but do you really? :)
20:56:00 <suzu> do it as procrastination on the things that matter
20:56:35 <HaskellLord69> I do it for the all sick ascii tree
20:56:42 <suzu> yee boi
20:56:46 <suzu> light it up
20:56:50 <HaskellLord69> ... that isn't even lighting up because I never finished day 3
20:56:56 <suzu> same
20:56:58 <suzu> lololo
20:57:06 <suzu> wait maybe i did. but not 4 onwards
20:57:13 <suzu> also re: writing haskell at work
20:57:42 <suzu> we write node and javascript here. i had to do a lot of politics-ing to get haskell in here
20:58:07 <HaskellLord69> good for you
20:58:08 <suzu> so now we have a contained haskell app that i maintain, and am training two non-hsers in hs
20:58:16 <HaskellLord69> all the JS people I know here locally absolutely hate types
20:58:28 <suzu> it has the highest reliability of anything we've got deployed
20:58:59 <Welkin> I think if I had to use haskell at work, I would start to hate it
20:59:00 <suzu> the downside is i need to continuously defend usage of it in some places, and continue to take "risk" with decisions underneath using hs
20:59:14 <Welkin> because I would have to write crappy code no matter what, to meet business needs
20:59:16 <HaskellLord69> yeah sounds like a lot of responsibility
20:59:20 <Welkin> and it's not a codebase I would care about
20:59:26 <suzu> i absolutely hated writing python
20:59:34 <Welkin> I have used it for clients, but that was a one-off
20:59:51 <suzu> it is stringly-typed dictsoup being thrown together into spaghetti and salad and its an unmaintanable pile of shit
21:00:07 <Welkin> yeah, python almost made me quit programming
21:00:08 <Welkin> rage quit
21:00:18 <HaskellLord69> python has types now doesnt it?
21:00:19 <suzu> it is funny because 5 years ago i thought python was 5/5
21:00:24 <Welkin> suzu: me too
21:00:28 <suzu> python has always had types. it just hides them you
21:00:33 <suzu> hides them from you
21:00:37 <Welkin> I used to love python... until I tried to build non-trivial software with it
21:00:40 <suzu> and somehow that's a benefit
21:00:47 <Welkin> then I discovered haskell and all was well
21:00:47 <suzu> yes exactly the same for me Welkin 
21:01:03 <suzu> 5 years from now ill probably think hs is shit and have moved onto.. i dunno. whatever is next
21:01:09 <suzu> whatever harder drugs there are. idris? /shru
21:01:10 <suzu> g
21:01:11 <Welkin> suzu: agda
21:01:12 <Welkin> lol
21:01:17 <suzu> hehe
21:01:33 <suzu> um but yeah. i enjoy the haskell at work now. id have quit if not for it
21:02:04 <suzu> and i have to play the stupid eng manager game and defending haskell and types and such but eh, i'd say the struggle is worth it
21:02:08 <suzu> i think of it as an investment
21:02:25 <suzu> 3 months from now the complexity of the code will be twice as much and i'll be able to reclaim profit
21:02:52 <suzu> that's my gamble i guess
21:02:56 <suzu> i think it will turn out well
21:03:25 <Welkin> in general I don't like building software for other people
21:03:29 <Welkin> I want to build it for myself
21:03:37 <Welkin> if other people find it useful, great
21:03:54 <suzu> we recently got some EDSLs into the hs code for scripting things in a safe manner. at first it got plenty of pushback, but now everybody is very happy about it and has forgotten all of the animosity there was before
21:03:55 <Welkin> or, build my own product, I mean
21:04:26 <suzu> so ive been pretty happy as of late
21:04:27 <mud> Does AoC get ... I dunno, more interesting towards the end? Is there a ramp-up?
21:04:29 <suzu> paid off
21:04:38 <Welkin> mud: a climax?
21:04:43 <suzu> mud: look at the past two years of problems and you can see the details
21:04:54 <mud> Ya, I suppose I could do that
21:04:58 <Welkin> all good things have a climax
21:05:00 <suzu> Welkin: i see what you mean. but are you employed writing software?
21:05:15 <Welkin> suzu: yes
21:05:31 <Welkin> mostly maintaining
21:05:31 <suzu> ah i see
21:05:44 <Welkin> some new feature development
21:05:51 <suzu> and so you find that.. okay, but you extract a lot more excitement from writing software for yourself
21:06:00 <suzu> would you say thats correct?
21:06:13 <Welkin> well, not necessarily for me to use, but where I decide what to build and how
21:06:30 <suzu> so what you value is actually autonomy. being able to lead and make decisions about the software
21:06:40 <Welkin> it's more fun than "this broke" and "we have business requirement A"
21:06:41 * ski . o O ( "What game designers should never do" in 2007-04-16 at <http://viridia.org/2007/04/16/game-designers-should-never-do/>,"There’s no constructive theory of fun" in 2008-10-13 at <http://viridia.org/2008/10/13/theres-no-constructive-theory-of-fun/>, by Talin (David Joiner) )
21:07:04 <suzu> hmm, i see
21:07:11 <suzu> yeah. uh, business does suck sometimes for sure
21:07:12 <suzu> :P
21:07:28 <suzu> im certainly lucky in that i get to make cool stuff and it solves business needs and makes us money
21:07:39 <suzu> i think thats rare and i definitely try not to take it for granted
21:08:00 <Welkin> I already have a lot of autonomy to do what I want. But if I do something like start writing it all in purescript, then I will have to do a lot more work to set that up and maintain it, and it won't reflect well on me if I leave the company in a poor position for someone to take over when I leave
21:08:13 <suzu> hire a replacement first
21:08:15 <suzu> before you quit
21:08:43 <Welkin> I can go wild within reason, like using crazy js libraries
21:09:31 <Welkin> but lately I have enjoyed a slower pace of work after I already rewrote huge portions of the codebase over many months
21:09:51 <Welkin> it's nice to take a break and focus on some of my own projects
21:11:22 <suzu> :)
21:11:27 <mud> Looks like there is just barely a ramp-up in AoC.
21:12:37 <suzu> mud: if you are looking for greater algorithmic challenges, you could try google code jam or other competitive coding competitions
21:13:09 <Welkin> solve fermat's last theorem
21:13:18 <Welkin> or other unsolved mysteries of math and science
21:13:26 <suzu> ye ez
21:13:41 <suzu> send us the solutions when you're done
21:13:45 <suzu> so we uh.. can review them yes yes
21:13:58 <mud> Ya, that's more what I'm used to ... which is probably why I don't find it very exciting I suppose.
21:14:16 <suzu> if you're familiar with coding contests then im sure you could place in the top of aoc
21:14:36 <suzu> i think the top of aoc is basically just contest veterans
21:14:40 <suzu> so yeah
21:27:17 * ski . o O ( "The Power of Negative Thinking" (Communications of the ACM.,Volume 40,Number 7) by Talin (David Joiner) in 1997-07 at <http://viridia.org/talin/negativethinking.html> )
21:28:33 <dmwit> ski: have you been infected by a spambot
21:28:54 <ski> not that i know of
21:30:51 <dmwit> Never mind, nobody else was on-topic either.
21:45:42 <dminuoso> ski: o/ have I thanked you for battery of equations the other day about monads and categories?
21:46:21 <ski> nay
21:46:35 <dminuoso> okay. thank you ;-)
21:46:50 <dminuoso> Took some time to put it on paper, but it was very helpful.
21:47:04 <dminuoso> IRC is just a horrid way of communicating commuting diagrams :P
21:47:47 <ski> i think it helps if you write `join_A' rather than just `join'
21:48:29 <ski> so you more clearly see the similarity between `join_(M A)' (`join') and `M join_A' (`fmap join')
21:49:22 <ski> then, you can go to pointless, writing something like `join . M' vs. `M . join'
21:50:16 <dminuoso> ski: Just to avoid confusion, what is join_A supposed to denote?
21:50:21 <ski> (you'll need both "vertical" and "horizontal" composition of natural transformations, for the full equations, pointless)
21:50:50 <ski>   join :: forall a. M (M a) -> M a
21:50:58 <ski>   join_A :: M (M A) -> M A
21:51:32 <ski> `join_A' being the monomorphic specialization, where we have removed the `forall', instantiating `a' with a "particular" type `A'
21:51:59 <dminuoso> Yeah. The notation of those natural transformations is not very clear yet, so to me ηT was easier to read than η_(M A) 
21:52:20 <ski> (the natural transformation `join : M . M >---> M' consists of "components", one `join_A : (M . M) A >---> M A', for each object `A')
21:53:19 <ski> (on paper, you'd use subscript rather than `_', of course)
21:57:10 <dminuoso> 06:48           ski | then, you can go to pointless, writing something like `join . M' vs. `M . join'
21:57:17 <dminuoso> This is horizontal composition right?
21:57:28 <dminuoso> Where M would denote the identity natural transformation I believe
21:58:11 * ski can never recall which is which of horizontal and vertical composition
21:59:39 <ski> (in my own notation, one of them is plain composition, while the other is "lifted" composition)
22:02:28 <johnw> vertical is what we're all used to: C ~> D and D ~> E => C ~> E. horizontal is when C ~> D and C' ~> D' => C.C' => D.D'.
22:02:53 <johnw> if you think of them as transformation arrows going from top to bottom, then this geometrical interpretation makes sense
22:03:15 <dminuoso> Given some functors F1,G1 : A -> B, F2,G2 :  B -> C with natural transformations α : F1 -> G1, β : F2 -> G2, then α * β would be a composition F2 * F1 -> G2 * G1
22:03:40 <dminuoso> johnw: Right, so horizontal composition is this weird one.
22:05:11 <dminuoso> For reasons beyond me horizontal composition allows for seemingly composing nat transformations with functors.
22:05:16 <johnw> well, imagine two arrows of shape ⇓
22:05:23 <johnw> vertical composition is:
22:05:24 <johnw> ⇓
22:05:24 <johnw> .
22:05:25 <johnw> ⇓
22:05:29 <johnw> horizontal composition is
22:05:31 <johnw> ⇓ . ⇓
22:06:34 <dminuoso> Except horizontal composition allows you to denote something like ⇓ * -> 
22:06:41 <johnw> each arrow of type F ⇓ G has functor arrows above and and below it F, G : C ⟶ D
22:06:46 <johnw> works out better with a picture ;)
22:06:55 <dminuoso> Woah font breakage.
22:07:14 <dminuoso> ⟶   really is not nice on mono space fonts :D
22:07:19 <johnw> heh
22:09:53 <jle`> my font doesn't even have a glyph for it :'(
22:11:28 <johnw> in Agda input modes it's \r--, that's all I know
22:11:58 <pierrot> Hello. I have this exercise https://i.imgur.com/lk4uHxd.png and this is what I've done https://glot.io/snippets/ew6j56tztl
22:12:49 <pierrot> I'm not sure about `Monad (ResT m)`
22:15:54 <rightfold> It’s the same as ExceptT (Maybe String)
22:16:45 <ski> how should i remember to view them as arrows going from top to bottom ?
22:16:59 <bob1955> morning guys
22:17:09 <Rembane> Morning bob1955 
22:17:16 <bob1955> anyone ever hear of iohk?
22:17:27 <ski> <dminuoso> For reasons beyond me horizontal composition allows for seemingly composing nat transformations with functors.
22:17:33 <bob1955> https://github.com/input-output-hk/
22:17:48 <bob1955> I've been thinking of applying and I noticed they have a lot of haskell developers
22:17:58 <ski> consider the bifunctor `(+) : C * C >---> C' (coproduct)
22:18:53 <ski> and objects `A0',`A1',`B0',`B1' of `C', and morphisms `f : A0 >---> A1',`g : B0 >---> B1'
22:19:12 <ski> then `f + g : A0 + B0 >---> A1 + B1'
22:19:36 <ski> now, let `A0' be the same object as `A1', call it just `A', and let `f' be `id_A'
22:19:53 <ski> then `id_A + g : A + B0 >---> A + B1'
22:20:26 <ski> it makes sense to think of this as the functor `(A +)' mapping the morphism `g'
22:20:47 <ski> suggesting that we could also write this as `A + g : A + B0 >---> A + B1'
22:21:14 <ski> so, either we think of the `(A +)' part here as the functor, and then `A' is just an object
22:21:25 <callmeca1man> bob1955: I know a little bit about them
22:21:41 <callmeca1man> bob1955: 1) artyom.me still works for them
22:21:51 <ski> or we think of `(+)' as the bifunctor, and then `A' here is implicitly being "promoted" from an object to the identity morphism on that object
22:21:55 <ski> dminuoso : makes sense ?
22:22:36 <bob1955> What's your opinion callmeca1man?
22:23:30 <callmeca1man> bob1955: 2) they've got good web presence and some haskell developers so the japanese investors readiliy pumped their bitcoins into the iohk pockets
22:23:56 <ski> dminuoso : now, in the case of `M . join', `M' is similarly implicitly promoted to an identity natural transformation on `M'. and `(.)' here is a bifunctor
22:24:02 <pierrot> rightfold: how do I define `fmap` for `(ResT m)`?
22:24:41 <ski> johnw : i suppose there's no nice mnemonic for how to remember that ?
22:24:52 <callmeca1man> bob1955: first thought was "oh a high-profile scam" but now I am not sure
22:24:56 <rightfold> pierrot: first define it for Res, then fmap f = ResT . fmap (fmap f) . runResT
22:25:03 <bob1955> scam?
22:25:13 * ski is, fwiw, not really fond of the terms "left adjoint","right adjoint"
22:25:24 <ski> (cf. "left inverse","right inverse")
22:25:40 <bob1955> Why would you say that?
22:25:45 <pierrot> rightfold: I already defined it for `Res` if you look at my code
22:26:14 <callmeca1man> bob1955: I mean when people exchange vouchers for something valuable it smells of scam for me (maybe because I'm russian...)
22:26:42 <bob1955> They have a lot of academic partnerships 
22:26:49 <rightfold> pierrot: then you can skip that step now! :)
22:26:52 <bob1955> Did you see the papers they publish as well?
22:26:58 <callmeca1man> I know and their ouroboros paper is good as well
22:27:03 <johnw> ski: think HOR∘IZ -> ON∘TAL? :)
22:27:13 <bob1955> There is also a formal spec being written for the paper
22:27:30 <bob1955> https://github.com/input-output-hk/ouroboros-spec
22:27:45 <callmeca1man> bob1955: yep that one
22:28:00 <rightfold> pierrot: if you have x :: F (G a) then you can always do fmap (fmap f) x if F and G are functors
22:28:02 <ski> no idea how to interpret that
22:28:15 <rightfold> Here, F is m and G is Res
22:28:16 <callmeca1man> bob1955: sorry you shouldn't listen to a stranger saying "X is scam", it's just his opinion
22:28:18 <johnw> hmm.. no mnemonic then, sorry
22:28:28 <pierrot> rightfold: oh, that's a nice pattern. thanks!
22:28:36 <bob1955> Well I appreciate the honest opinion
22:28:46 <rightfold> pierrot: see also the Functor instance of Compose
22:29:03 <ski> (or "memory trick/clue" (or even a sensible way to deduce it), if you don't like the word "mnemonic")
22:29:12 <johnw> horizontal takes a natural transformation for functors HOR ~> TAL, and one for IZ ~> ON, and gives you HOR∘IZ ~> ON∘TAL
22:29:22 <callmeca1man> bob1955: I see how the money flows and all the web presence they have is a cutting-edge marketing so it's alarming at least
22:29:51 <johnw> vertical takes a natural transformation F ~> G and one G ~> H and gives you F ~> H
22:30:18 <johnw> so horiz is "across objects", and vert is "across morphisms"
22:30:33 <johnw> (in the 2-cat)
22:30:39 <johnw> none of this is mnemonic, though
22:30:41 <callmeca1man> johnw: is there any fast and dirty CT like Catsters? 
22:30:44 <johnw> easily forgettable
22:30:50 <bob1955> Honestly, I've never seen a scam use formal methods. That sees to be well beyond anything a scammer would have patience for?
22:30:51 <johnw> callmeca1man: um, Catsters? :)
22:31:19 <callmeca1man> johnw: Eugenia Cheng and this guy I always forget
22:31:39 <johnw> maybe his name was Horizontal Composition
22:32:08 <johnw> i don't know of anything else fast and dirty, no
22:36:20 <callmeca1man> johnw: I mean MacLane is "I want to live in a cave for ten years and master the Force" and Catsters are "look mom, lightning from my fingers"
22:41:08 <KorablSputnik4> hi
22:42:40 <callmeca1man> hello, ShipSatellite4
22:43:08 <johnw> ski: http://ftp.newartisans.com/pub/IMG_1101.jpg
22:43:56 * hackage computational-algebra 0.5.1.0 - Well-kinded computational algebra library, currently supporting Groebner basis.  https://hackage.haskell.org/package/computational-algebra-0.5.1.0 (HiromiIshii)
22:44:16 * ski nods
22:45:23 <ski> (it's just that i have a hard time remembering whether one's "supposed" to draw that diagram one or the other way around ..)
22:45:30 <johnw> yeah
22:45:59 <ski>   ε ∘ η : F ⟵ H  ⊣  𝒞,𝒟 : Cat , F,G,H : 𝒞 ⟵ 𝒟 , ε : F ⟵ G , η : G ⟵ H
22:46:15 <ski>   ⌜⌞ε⌟ ∘ ⌞η⌟⌝ : F₀ ∘ G₀ ⟵ F₁ ∘ G₁  ⊣  𝒞,𝒟,ℰ : Cat , F₀,F₁ : 𝒞 ⟵ 𝒟 , G₀,G₁ : 𝒟 ⟵ ℰ , ε : F₀ ⟵ F₁ , η : G₀ ⟵ G₁
22:46:52 <ski> (one is "direct" composition, the other is "lifted")
22:47:54 <osa1> wow I'm surprised how good Haskell IDE engine works. it worked out of the box in my stack project.
22:48:45 <johnw> ski: vertical is direct, horizontal is lifted?  Well, "vertical" shares many letters with "direct"
22:49:15 <cocreature> osa1: which editor are you using it with?
22:50:01 <osa1> cocreature: neovim via LanguageClient-neovim
22:50:34 <cocreature> osa1: cool, I should really give it a shot one of these days
22:53:21 <ski> > let trisect x y = (x \\ y,x `intersect` y,y \\ x) in "vertical" `trisect` "direct"
22:53:21 <KorablSputnik4> > let trisect x y = (x \\ y,x `intersect` y,y \\ x) in "vertical" `trisect` "direct" :)
22:53:22 <lambdabot>  ("val","ertic","d")
22:53:23 <lambdabot>  <hint>:1:85: error: parse error on input ‘)’
22:53:23 <KorablSputnik4> ("val","ertic","d") :)
22:53:23 <KorablSputnik4> <hint>:1:85: error: parse error on input ‘)’ :)
22:53:35 --- mode: ChanServ set +q *!*@31.187.77.12
22:58:40 --- mode: ChanServ set -q *!*@31.187.77.12
23:07:11 <ekr> so, how often should the ST monad be used? is it to be avoided? 
23:08:40 <boj> depends on your use case i suppose
23:08:58 <woodson> anyone knows how to use ReaderT with servant?
23:09:02 <cocreature> I don’t think it’s something that should be actively avoided
23:09:07 <mud> As often as needed. Not really to be avoided particularly.
23:10:28 <dminuoso> If `push :: a -> StateT [a] Maybe ()` how could I change `liftM2 op pop pop >>= push` to push *and* return the value in a point-free manner?
23:10:34 <boj> woodson: http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#using-another-monad-for-your-handlers
23:10:36 <liste> ekr: use ST whenever an imperative approach is the most performant/elegant one
23:10:43 <liste> and you don't need IO
23:10:51 <dminuoso> The only idea I had was to provide an alternative `push' :: a -> StateT [a] Maybe a`
23:13:57 <osa1> wow it drained my laptop battery @_@
23:14:43 <dminuoso> But that is not the elegance I was looking for.
23:14:52 <osa1> ekr: as a data point I've never used it for something other than exercises in my 5 years writing Haskell (professionally for the last couple of years)
23:16:08 <mud> It's mostly for imperative algorithms in my experience. Which ... ya it depends how much that actually comes up.
23:23:02 <boxscape> hm, hoogle can't find sequence for [Either a b] -> Either a [b]...
23:25:56 <ski> dminuoso : hm .. perhaps with something like `graph :: Arrow ar => ar a b -> ar a (a,b); graph m = arr id &&& m' or `after :: Arrow ar => ar a () -> ar a a; after m = graph m >>> arr fst'
23:26:32 <liste> boxscape: would it result in Left a if one Left value is found, and Right [b] if no Left values are found?
23:26:34 <ski> (you could rewrite those in terms of kleisli arrows, instead, replacing the `Arrow' constraint with a `Functor' one)
23:26:47 <liste> at least one*
23:26:57 <boxscape> liste: I believe so
23:27:18 <boxscape> > sequence [Right 3, Right 2, Right 1]
23:27:20 <lambdabot>  Right [3,2,1]
23:27:25 <boxscape> > sequence [Right 3, Left 1, Right 2, Right 1, Left 3]
23:27:26 <lambdabot>  Left 1
23:27:36 <ski> > sequence [] :: Either Integer String
23:27:37 <lambdabot>  Right ""
23:28:06 <liste> boxscape: so is the problem that you can't find the function monomorphized for [Either a b] ?
23:28:13 <liste> :t sequence
23:28:14 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
23:28:30 <boxscape> liste: yeah, usually hoogle finds polymorphic functions for monomorphic queries
23:28:31 <liste> boxscape: or you can't find its implementation for [Either a b] ?
23:28:37 <liste> oh, I see
23:28:41 <boxscape> there's no real problem, I just find it strange
23:29:13 <liste> I guess Hoogle isn't smart enough to figure nested * -> * types ?
23:29:28 <MarcelineVQ> no it's type search is just broken :X
23:29:47 <liste> hoogle4 or hoogle5?
23:29:54 <liste> (is 4 still around?)
23:30:11 <boxscape> version version 4.2.26 apparently
23:30:19 <boxscape> @where hoogle
23:30:19 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
23:30:23 <boxscape> from the first link
23:31:52 * liste would've suggested hoogle5 at http://hoogle.haskell.org/, but apparently it has no type search atm :D
23:32:14 <boxscape> good to know that that link exists, anyway
23:32:26 <cocreature> it does have a type search but it’s not as smart as the one in hoogle4
23:38:44 <yuuko> writing a little dsl for templating, with two distinct phases, compilation and execution, where each can be done in an arbitrary monad; compilation for retrieval of additional sources via includes, and execution against data that may evaluate with monadic effects
23:38:53 <yuuko> but somehow i feel dirty writing two monad transformers into a library
23:38:56 <yuuko> is that at all justified
23:47:48 <boxscape> hm, sortOn exists but groupOn doesn't :/
23:48:42 <boxscape> wait I'm actually not finding sortOn in hoogle
23:48:55 <boxscape> am I misremembering?
23:49:03 <osa1> it's in base
23:49:06 <osa1> Data.List.sortOn
23:49:29 <boxscape> hm, I guess hoogle is just weird then?
23:50:29 <cocreature> http://hoogle.haskell.org/?hoogle=sorton
23:50:44 <cocreature> if you don’t use the typesearch, you really want to use hoogle5
23:51:00 <boxscape> okay, I'll keep that in mind
23:51:17 <cocreature> it is regularly updated and it indexes all of stackage while hoogle4 is stuck at some old packages and only indexes a very small number of packages
23:51:23 <boxscape> ah, I see
23:52:11 <cocreature> and the typesearch in the new hoogle is also not too bad, e.g. http://hoogle.haskell.org/?hoogle=Ord%20a%20%3D%3E%20(a%20-%3E%20b)%20-%3E%20%5Ba%5D%20-%3E%20%5Bb%5D brings up sortOn as the first hit
23:52:19 <cocreature> I can’t recall the last time I’ve used hoogle4
23:52:40 <boxscape> I just use it because I have a bookmark for it :D
23:52:57 <cocreature> that should be easy to change :)
23:53:07 <boxscape> true
