00:11:18 <saurabhnanda> is there any practical problem that can be solved by `divMod` that a newbie can relate to?
00:11:31 <saurabhnanda> non-mathematical, preferred
00:11:36 * frerich is incredibly satisfied after having written the solution for part 1 in a single go, ran it exactly once (on the real input), entered the answer - and it was correct. :-)
00:12:54 * frerich First time I managed to do this.
00:13:48 <xacktm> saurabhnanda: sometimes you do want both the quotient and remainder?  you have x seconds, divMod x 60 gives you the minutes and remainder seconds at once
00:13:56 <osa1> I've used that for something practical in the past although I can't remember the details
00:14:03 <saurabhnanda> ah brilliant... time processing.
00:17:17 <jle`> saurabhnanda: you can do it to split a numbe rinto its digits maybe
00:17:25 <jle`> > 9234 `divMod` 1000
00:17:27 <lambdabot>  (9,234)
00:17:39 <jle`> the first digit is 9, and you can repeat with the rest
00:17:45 <jle`> > 234 `divMod` 100
00:17:46 <lambdabot>  (2,34)
00:17:48 <jle`> the second digit is 2, etc.
00:17:54 <saurabhnanda> jle`: thanks.
00:18:39 <jle`> saurabhnanda: oh in advent of code day 2 i used divMod to check if a number was a perfect factor of another
00:18:53 <saurabhnanda> perfect factor?
00:18:56 <jle`> and, if so, used the result of the division
00:19:06 <jle`> saurabhnanda: if a number divides into another number evenly
00:19:12 <jle`> like 4 and 12
00:19:17 <jle`> but not 5 and 12
00:19:24 <saurabhnanda> that can be found with `mod`
00:19:32 <saurabhnanda> n`divMod` is not necessary, right?
00:19:35 <jle`> yes but i also needed to use the result of the division
00:19:43 <jle`> i guess it's a bit of a contrived problem
00:19:54 <saurabhnanda> yep... time arithmetic seems more relatable.
00:20:10 <saurabhnanda> lots of places that you might need to do that in a real app (although a library already exists
00:38:58 * frerich feels he reached the next level of Haskell-Zen: got a stack overflow error and immediately enabled bang patterns and added '!' to the arguments of a recursive 'go' helper. And it helped!
01:00:04 <dminuoso> saurabhnanda: It's not about solving specific problems, its rather when a problem wants you to use both the quotient and the remainder..
01:00:18 <dminuoso> So instead of calculating each separately, divMod is just for elegantly doing two things at the same time.
01:00:38 <vaibhavsagar> saurabhnanda: converting a number to a string
01:00:52 <vaibhavsagar> > 54 `divMod` 10
01:00:54 <lambdabot>  (5,4)
01:03:13 * cvigil
01:03:15 <mniip> > unfoldr (liftA3 bool (Just . swap . (`divMod` 10)) (const Nothing) (== 0)) 123
01:03:17 <lambdabot>  [3,2,1]
01:03:55 <mniip> > ()
01:03:57 <lambdabot>  ()
01:03:59 <mniip> huh okay
01:15:23 <michalrus> replicateConcurrently_ :: Int -> IO a -> IO ()
01:15:24 <michalrus> :(
01:15:29 <michalrus> Why are such types useful?
01:15:42 <michalrus> Why is it `a` and not `()`?
01:16:39 <EvanR> thats technically more convenient
01:16:49 <liste> michalrus: so that you can use an action with a result without using "void"
01:16:57 <liste> just for convenience
01:17:03 <michalrus> But if the user doesn‚Äôt care about the result, shouldn‚Äôt they state that explicitly, using `void`?
01:17:05 <EvanR> or putting return () at the end
01:17:17 <vaibhavsagar> michalrus: that's what the `_` at the end is for
01:17:42 <vaibhavsagar> :t replicateConcurrently
01:17:43 <lambdabot> error:
01:17:43 <lambdabot>     Variable not in scope: replicateConcurrently
01:17:58 <vaibhavsagar> @import Async
01:17:58 <lambdabot> Unknown command, try @list
01:18:01 <liste> not sure if lambdabot has async
01:18:01 <vaibhavsagar> @list
01:18:01 <lambdabot> What module?  Try @listmodules for some ideas.
01:18:07 <vaibhavsagar> @listmodules
01:18:07 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
01:18:07 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
01:18:13 <liste> I don't think async is safe
01:18:17 <vaibhavsagar> that's fair
01:18:20 <michalrus> I know the convention with `*_`, yes, but‚Ä¶
01:18:39 <EvanR> from the type you know the `a' result is not used
01:18:45 <vaibhavsagar> michalrus, how does the `a` instead of `()` create problems for you?
01:18:49 <EvanR> if you require (), that adds bureaucracy
01:19:07 <michalrus> I‚Äôd ask the same question for traverse_.
01:19:24 <michalrus> I might miss someone swallowing a value in a CR, that they shouldn‚Äôt have swallowed.
01:20:06 <michalrus> While void is clearer. ‚ÄòI know I‚Äôm doing that‚Äô.
01:20:19 <testolaunz_> hi all
01:20:35 <testolaunz_> please help me with
01:20:35 <testolaunz_> http://yoitect.com/42LT
01:20:49 <EvanR> i dont see how that adds any value
01:24:08 <frerich> glguy: I just checked your solution to today's AoC and compared it to mine. I was delighted to see that we made the same decisions in a couple of places. However, I noticed that you, too, use manual recursion in the 'run simulation for a couple of iterations' functions. So did I - simply because 'iterate f !! n' was much slower for some reason. Did you consider alternatives to manual recursion maybe?
01:25:08 <frerich> glguy: My version is at https://github.com/frerich/aoc2017/blob/master/22.hs and I'm trying to steal your style a bit (I noticed you use more whitespace and brief comments, which looks pretty IMHO0. :-)
01:25:34 <liste> testolaunz_: your link (1) shows ads before redirecting (2) doesn't work with ad blockers, so no thanks
01:26:31 <liste> @paste -- testolaunz_ use this if you need to show code
01:26:31 <lambdabot> Haskell pastebin: http://lpaste.net/
01:28:44 <frerich> glguy: What I also like is how you always seem to get away with < 60 columns without making things look ugly. :-)
02:05:57 * hackage OpenGLRaw 3.2.7.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.2.7.0 (SvenPanne)
02:51:57 * hackage hledger-iadd 1.3.0 - A terminal UI as drop-in replacement for hledger add  https://hackage.haskell.org/package/hledger-iadd-1.3.0 (hpdeifel)
03:00:51 <bollu> Why do we still recommend newbies to install haskell-platform?
03:02:52 <merijn> bollu: Who is the "we" doing that?
03:03:05 <bollu> merijnhttps://www.haskell.org/ghc/download_ghc_7_6_1.html
03:03:14 <bollu> ah wow, that is a super old page
03:03:19 <bollu> why does that show up on google? o_O
03:03:20 <merijn> 7.6 is super old
03:03:31 <bollu> yeah, I noticed
03:03:32 <bollu> hmm
03:03:35 <merijn> bollu: The SEO of Haskell.org leaves a bit to be desired
03:03:45 <bollu> merijn yeah :)
03:04:38 <merijn> Same issue with google returning super old hackage links for docs
03:09:50 <vidbina> yeah... I have loads of Haskell bookmarks because Google also fails me often enough
03:15:12 <merijn> vidbina: If you're using Chrome (there might be a Firefox version too) Hackage-Fu is a nice plugin
03:15:52 <merijn> It adds warnings if you're browsing old versions and links to the new version of docs
03:16:44 <vidbina> merijn: thanks. I use ff, but I have chromium installed as well so I'll give both a shot.
03:18:14 <bollu> Could someone please explain what extensible effects is about? I read the paper, and I still don't have a concrete sense for it
03:18:29 <bollu> from what I can tell, it's a different way to "phrase" / "encode" effects
03:18:41 <bollu> with some niceness (eg. obviously corrrect ListT, IIRC)
03:18:43 <bollu> and things like that
03:18:46 <bollu> but, is that it?
03:18:48 <bollu> What am I missing?
03:23:00 <merijn> bollu: What makes you think you're missing something?
03:23:21 <bollu> merijn: The amount of discussion this has gathered? Free v/s Extensible Effects v/s MTL
03:23:26 <bollu> I can see why free is distinct
03:23:41 <bollu> it feels like a different style of encoding, and it has nice interactions with cofree, etc
03:23:51 <bollu> but with effects, I don't see the sell
03:24:19 <merijn> bollu: mtl requires N^2 instances to be defined to make everything work
03:24:36 <bollu> merijn so, what is the upshot of MTL?
03:25:44 <merijn> bollu: afaik mtl style monad stacks are still more performant than extensible effects
03:25:56 <merijn> also, historical library support
03:26:04 <bollu> merijn I see
03:26:28 <bollu> merijn effects is worse in terms of perf because..? In theory, a whole-program optimiser should be able to optimise them both equally well, correct?
03:28:02 <merijn> In theory a magical compiler can produce optimal performance for any correct code
03:28:10 <merijn> We don't have magical compilers, though
03:55:21 <lyxia> bollu: Extensible effects are built on free monads.
03:57:36 <bollu> lyxia hm? I did not see it being presented that way
03:57:40 <bollu> lyxia am I missing something?
03:58:17 <merijn> lyxia: I don't think that's a requirement, though? That seems more an implementation detail of the haskell extensible effects library?
03:58:52 <merijn> lyxia: Some other languages have extensible effects built into the compiler
04:07:22 <lseactuary> anyone good at first order logic? stuck on a modelling problem. i have attempted a solution also. https://pastebin.com/8CLAqgZn
04:07:26 <lyxia> merijn: Oh, I see.
04:08:04 <lyxia> I was thinking of that implementation in particular indeed.
04:20:56 <lseactuary> it is mainly q3 i need help with
04:21:05 <lseactuary> if i can get this then i can work backwards on the other
04:44:53 * hackage dotenv 0.5.2.0 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.5.2.0 (camm)
04:46:57 <vivekramaswamy> Hello All I am really having issues comprehending this code http://lpaste.net/361040 where foldr is used to calculate the length of a list. Any help appreciated
04:48:23 <dminuoso> vivekramaswamy: https://wiki.haskell.org/File:Right-fold-transformation.png
04:48:27 <merijn> vivekramaswamy: Can you explain which part confuses you?
04:48:46 <dminuoso> vivekramaswamy: Now add the fact that the function ignores its first (left) argument.
04:48:48 <Broli> Morning!!!
04:48:55 <Broli> https://pastebin.com/d1y1HxXA. THanks!!!
04:50:41 <Broli> i mean this https://pastebin.com/7wAtZeN0
04:50:58 <Broli> THanks!!! :)
04:54:34 <lyxia> Broli: depthFirst takes a graph as its second argument
04:54:39 <lyxia> you gave it as its first
04:54:56 <lyxia> (in, it = depthFirst graph)
04:55:45 <dminuoso> lyxia: What does trigger that particular diagnostic though? Why is it trying to find an instance of Eq?
04:55:56 <Broli> lyxia: BRfun a is a function that return the direct follower of a as a list
04:56:04 <dminuoso> Shouldn't this produce a type matching error?
04:56:24 <merijn> dminuoso: Why? depthFirst works for any 'a' that's an Eq instance
04:56:51 <dminuoso> Ah.
04:56:57 <Broli> e.g : https://pastebin.com/jJ1hZWFC
04:57:15 <merijn> dminuoso: "depthFirst :: Eq a => a -> Graph a -> [a]" passing "Graph Int" as first argument just results in "depthFirst :: Graph Int -> Graph (Graph Int) -> [Graph Int]"
04:57:34 <merijn> dminuoso: Which is a perfectly sensible type IFF "Graph Int" has an Eq instance
04:57:37 <dminuoso> merijn: Right, and then it has to proove the constraint matches
04:58:27 <Broli> type BRfun a = a -> [a]
04:58:34 <dminuoso> merijn: Thanks.
05:01:58 <Broli> can someone help me please
05:02:15 <Broli> how can i fix this? thanks!!! :)
05:06:00 <lyxia> Broli: The error says you wrote "depthFirst graph1"
05:06:33 <lyxia> but depthFirst :: Eq a => a -> Graph a -> [a]   -- the graph should be the second argument
05:07:24 <lyxia> unless you have a graph of graphs and you wanted to do a depth-first search from the vertex that is graph1...
05:15:49 <Broli> lyxia: okay you was right. thanks!!! :)
05:18:53 <test> @pl \b x -> if b then x else Nothing
05:18:53 <lambdabot> flip flip Nothing . if'
05:21:05 <Barry_> Hallo I got an issue with "kinds" in haskell and would like some pointers on where I am missing information
05:21:27 <Barry_> Assignment: class C f where comp :: f b c -> f a b -> f a c
05:21:44 <Barry_> What is the kind of f
05:22:58 <Barry_> shouldnt it be:  * -> *->*
05:23:00 <Barry_> ?
05:29:54 <lyxia> a, b and c could have a different kind than *
05:32:00 <rightfold> By default it‚Äôll infer * -> * -> *
05:32:17 <rightfold> But with -XKindSignatures you can override it
05:33:23 <lyxia> @let class C f where comp :: f b c -> f a b -> f a c
05:33:24 <lambdabot>  Defined.
05:33:25 <lyxia> @kind C
05:33:26 <lambdabot> (k -> k -> *) -> Constraint
05:36:32 <lyxia> tabaqui: (about your question on #ghc) have you seen this https://github.com/haskell-hvr/cassava/pull/155
05:37:53 <mniip> % :set -XNoPolyKinds
05:37:54 <yahb> mniip:
05:37:59 <mniip> % class C f where comp :: f b c -> f a b -> f a c
05:37:59 <yahb> mniip:
05:38:02 <mniip> % :k C
05:38:02 <yahb> mniip: C :: (* -> * -> *) -> Constraint
05:38:07 <Barry_> yes
05:38:14 <Barry_>  (* -> * -> *) -> Constraint
05:38:18 <Barry_> is what i see for C
05:38:23 <Barry_> but i need f
05:38:31 <mniip> well
05:38:37 <mniip> as f is the first argument of C
05:38:43 <mniip> evidently, f :: * -> * -> *
05:39:06 <tabaqui> lyxia: not yet, I've thought that lts-10.0 was released on this week, so google doesn't know about the issue :)
05:39:14 <Barry_> I see
05:39:17 <mniip> hmm
05:39:19 <Barry_> so
05:39:22 <mniip> % :t comp
05:39:22 <yahb> mniip: comp :: C f => f b c -> f a b -> f a c
05:39:33 <mniip> % :set -fprint-explcit-foralls -fprint-explicit-kinds
05:39:34 <yahb> mniip: Some flags have not been recognized: -fprint-explcit-foralls
05:39:40 <mniip> % :set -fprint-explicit-foralls -fprint-explicit-kinds
05:39:40 <yahb> mniip:
05:39:42 <mniip> % :t comp
05:39:43 <yahb> mniip: comp :: forall {f :: * -> * -> *} {b} {c} {a}. C f => f b c -> f a b -> f a c
05:40:43 <Barry_> okay could you please let me do the following by myself and just tell me if iam wrong?
05:41:11 <lyxia> mniip: what do the braces mean
05:41:13 <tabaqui> okaay, cannot update stack on-the-air
05:41:37 <mniip> nothing, just ghc shenanigans
05:41:47 <mniip> % :set -dppr-debug
05:41:47 <yahb> mniip:
05:41:50 <mniip> % :t comp
05:41:50 <yahb> mniip: comp :: forall {f :: * -> * -> *} {b} {c} {a}. interactive:Ghci4.C{tc riJW} f => f b c -> f a b -> f a c
05:42:00 <lyxia> ew
05:42:04 <Barry_> data T f g = T (f String Int) (g Bool)
05:42:12 <Barry_> need to tell the Kind of T
05:42:16 <Barry_> which would be
05:42:20 <Barry_> T::(*->*->*)->(*->*)->*
05:42:25 <mniip> lgtm
05:42:38 <Psybur> % :quit
05:42:39 <yahb> Psybur:
05:42:49 <Psybur> % 1
05:42:51 <yahb> Psybur: 1
05:43:30 <mniip> Barry_, now what is the kind of Mu in: data Mu f = Mu (f (Mu f))
05:44:39 <Barry_> oh god. Sth infinite
05:44:41 <Barry_> gimme a sec
05:45:16 <Barry_> ((*->*)->*)->*
05:45:19 <mniip> wrong
05:45:51 <Barry_> (*->*)->*
05:45:55 <Barry_> but not sure why
05:46:08 * [exa] .oO( type lightbulb goes on: Mu is Œº )
05:46:10 <mniip> well, there's an algorithmical way to explain it
05:46:52 <mniip> suppose Mu :: a
05:47:04 <mniip> Mu is applied to one argument, f, so
05:47:14 <mniip> a ~ b -> c, f :: b
05:47:23 <Barry_> yes
05:47:32 <mniip> Mu f :: c is a data type,
05:47:34 <mniip> c ~ *
05:47:47 <mniip> f is seen applied to one argument: f (Mu f)
05:47:58 <mniip> therefore b ~ d -> e
05:48:12 <mniip> with Mu f :: d
05:48:18 <mniip> but Mu f :: *, so d ~ *
05:48:34 <mniip> f (Mu f) :: e is a field in a constructor
05:48:37 <mniip> so necessarily e ~ *
05:49:10 <[exa]> mniip: btw, if you remember that I started 'exercise yourself a haskell'. We've begun to put it together with one friend here, currently filling in stuff we use for the courses, not entirely LYAH-related yet but it formats itself to TeX and makes a nice book.
05:49:24 <mniip> a ~ (b -> c) ~ ((d -> e) -> c) ~ ((* -> *) -> *)
05:49:30 <mniip> Mu :: (* -> *) -> *
05:49:45 <mniip> [exa], yeah I subsscribed to it and it constantly bugs me on my github feed
05:49:55 <[exa]> mniip: so send exercises if you have something interesting :]
05:50:06 <Barry_> it makes sense
05:50:12 <mniip> of course it does
05:50:14 <Barry_> Let me write the steps down to make sure
05:50:15 <mniip> that's how ghc does it
05:50:20 <Barry_> that I understand it
05:50:21 <mniip> well, approximately
05:50:42 <Barry_> Thank u!
05:56:34 * hackage smallcheck 1.1.3.1 - A property-based testing library  https://hackage.haskell.org/package/smallcheck-1.1.3.1 (RomanCheplyaka)
06:00:50 <Barry_> So it was correct
06:00:58 * hackage text-ldap 0.1.1.9 - Parser and Printer for LDAP text data stream  https://hackage.haskell.org/package/text-ldap-0.1.1.9 (KeiHibino)
06:02:47 <Barry_> yeah it was correct. I just entered it into the ghci
06:02:55 <Barry_> and got the type
06:03:00 <Barry_> thanks a lot. I think I got it
06:39:19 * hackage text-ldap 0.1.1.10 - Parser and Printer for LDAP text data stream  https://hackage.haskell.org/package/text-ldap-0.1.1.10 (KeiHibino)
06:44:04 <mniip> damn
06:44:19 <mniip> fooled myself over a trick I thought I learned
06:45:29 <mniip> % execState (traceM "a" >> traceM "b") ()
06:45:29 <yahb> mniip: b; a; ()
06:48:26 <mniip> hmm
06:48:51 <mniip> %% :show imports
06:48:51 <yahb> mniip: http://qp.mniip.com/y/25
06:48:56 <mniip> suggestions on expanding the list?
06:49:32 <[exa]> does yahb have docs like lambdabot had?
06:49:56 <infandum`> If I have a newtype from one library and a newtype of another library, defined exactly the same way (but separated by library), can I use them interchangeable or do they need to be used qualitatively (S.ThatType and T.ThatType)?
06:50:03 <mniip> "had"
06:50:06 <mniip> docs?
06:50:41 <[exa]> infandum`: all newtypes are distinct and not interchangeable (but type aliases would work better in this case)
06:51:04 <[exa]> mniip: well there was at least a wiki page with a list of kindof functions :]
06:51:24 <mniip> uhhuh
06:51:29 <mniip> maybe once yahb is rewritten
06:51:35 <mniip> it something more...
06:51:46 <mniip> ..substantial
06:51:50 <mniip> see the frontent is a mess
06:51:57 <mniip> frontend
06:52:22 <mniip> in fact I would welcome help with such a rewrite assuming you know what goes on in the backend
06:54:53 <mniip> something along the lines of
06:54:57 <mniip> bash -c "jail/sandbox hs /var/lib/xsbot/sandbox/root/usr/runghci/runghci <sandbox 2>&1"
06:56:10 <fakenullie> what's function that apply function to argument n times
06:57:03 <frerich> fakenullie: iterate and (!!) ?
07:01:57 <vivekramaswamy> Thanks @dminuoso and @merijn. I has left my desk and gone hence the delayed response, what confused me was the accumlator part.
07:04:56 <Average-user> for day 22 there isn't a faster way than just simulating?
07:05:23 <yohotchoc> there was a good bit of discussion here about analytical solutions but it seems pretty much everyone's simulated
07:05:39 <yohotchoc> (assuming that's the particle one or whatever, I haven't been keeping up because of study...)
07:07:25 <fakenullie> frerich: damn laziness
07:17:20 <frerich> > iterate (+3) 0 !! 5
07:17:22 <lambdabot>  15
07:40:00 <infandum`> [exa]: OK, thanks.
07:42:36 <infandum`> I have a project that uses lts-9.6. I installed with stack 1.5 a month ago and it was fine. I upgraded stack to 1.6 and now it wants me to keep adding more and more packages to extra-deps. The more I add, the more it requires, even base! What is happening?
07:43:18 <infandum`> Nevermind.
07:47:13 <hoon> haha!
07:47:20 <hoon> that was a quick turn around!
07:48:25 <yohotchoc> https://xkcd.com/979/
07:53:31 <hoon> yohotchoc: I thought the same thing
07:53:54 <hoon> I also just put together that your name is "yo, hot choc(olate)"
07:54:38 <hoon> yoho tee chock? no...wait a minute...
07:58:38 <yohotchoc> my normal nick is yoho (previously yoho139), this is my christmas nick
07:58:49 <yohotchoc> because sitting by the fire with hot chocolate is the best part of christmas
07:59:18 <yohotchoc> (also I wanted to maintain tab complete of yo<tab> for other people's sake and I'm too lazy to come up with a good nick :D )
07:59:41 <aioewr> Haskell book ch19 URI shortner shawty code doesn't work
08:00:12 <aioewr> It says "Setting phasers to stun... (port 3000)
08:00:20 <aioewr> Then just hangs
08:00:32 <aioewr> Am I doing something wrong?
08:00:52 <yohotchoc> open localhost:3000 in a browser
08:01:52 <aioewr> 500 Internal Server Error
08:01:59 <aioewr> Param: uri not found!
08:02:44 <yohotchoc> try localhost:3000/?uri=http://google.com
08:07:59 <infandum`> hoon, yohotchoc: The answer was to upgrade cabal as well.
08:09:08 <infandum`> No it wasn't, nevermind, still stuck.
08:09:13 <yohotchoc> :|
08:12:50 <infandum`> It all seems to be a diagrams issue
08:13:10 <infandum`> But I would assume if it worked for an lts, it should still work a month later or so
08:13:12 <tabaqui> 'network' functions raise IOException instead of some NetworkException
08:13:18 <tabaqui> how do you manage them?
08:14:04 <tabaqui> I mean 'getAddrInfo >>= print' looks absolutely disgustful on windows
08:14:25 <tabaqui> *catch getAddrInfo print
08:16:40 <infandum`> OK, the problem was my git version was in packages not extra-deps. The weird thing is, why would it work before? Oh well.
08:19:17 <savask> Hello. Alex allows tokenizing the input - but does it allow checking it against a certain regex first?
08:41:22 <wz1000> Is there an easy way to bundle up a typeclass with Dynamic? or will I have to roll my own as in data JsonDynamic = forall a. (ToJSON a, Typeable a) => JD (TypeRep a) a
08:52:53 <hexagoxel> @hackage constrained-dynamic
08:52:53 <lambdabot> http://hackage.haskell.org/package/constrained-dynamic
08:52:56 <hexagoxel> wz1000: ^
08:53:55 <wz1000> hexagoxel: nice, thanks!
08:54:49 <infandum`> Can Doubles be used as labels?
08:55:04 <infandum`> Is it reliable that if in theory x == y, that x WILL equal y?
08:55:27 <merijn> infandum`: What do you mean?
08:56:09 <wz1000> hexagoxel: do you know if that works with the changes to dynamic/typeable in 8.2?
08:56:30 <infandum`> merijn: If I have a list of natural numbers encoded as doubles in one list, and the a list of natural numbers encoded as doubles in another list, can I match those numbers?
08:56:39 <huss`> Hey guys
08:56:40 <hexagoxel> wz1000: i don't know.
08:56:55 <huss`> I have a question about Control.Arrow
08:57:03 <huss`> Anyone can help me ?
08:57:08 <infandum`> I'm worried about error. Like, it may say 2.999999999999999999 while the other might say 3, yet they won't be equal. HOWEVER, I'm assigning the numbers with no operations on them at all.
08:57:17 <infandum`> So they would be assigned with zip [1..] for instance.
08:59:35 <huss`> So ?
09:00:03 <hoon> huss` just ask
09:01:19 <huss`> Is there any way to implicitly use a function as an Arrow or I have to wrap it with `arr` everytime ?
09:04:03 <hoon> (sorry, I don't know)
09:08:40 <wz1000> is there a nice way to match a Dynamic against a bunch of types?
09:09:55 <wz1000> as in I have a bunch of function A -> Z, B -> Z, C -> Z.. and I want a Dynamic -> Maybe Z
09:12:03 <wz1000> infandum`: haskell is pure, so intToDouble 3 will always evaluate to the same value
09:15:14 <yohotchoc> infandum`: what are you trying to do?
09:15:22 <yohotchoc> and how are you actually generating these lists?
09:30:04 <infandum`> yohotchoc: They are labels from clustering.
09:30:36 <infandum`> I just want to make sure that if I assign an item to cluster 3 and another item to cluster 3, they would belong to the same cluster if that cluster label is a double
09:30:47 <Johulk> Heyo!
09:30:52 <Johulk> Can someone help me out with this? http://lpaste.net/1810973488639377408
09:32:13 <yohotchoc> infandum`: if you know for sure that the labels are always integers you could just map round over the list of doubles
09:32:25 <yohotchoc> the real question is why that divergence exists
09:33:01 <yohotchoc> Johulk: you're using ( instead of [ in that last pattern
09:33:23 <yohotchoc> should start with [(, not ((
09:33:30 <Johulk> Ah
09:33:59 <Johulk> I thought using [ ] locked into it having the arguments
09:34:09 <Johulk> for example [1,2,3] needs to have 3 arguments
09:34:09 <mnoonan_> infandum`: I think if you are not calculating anything and just putting the same value in two places, you‚Äôll be fine. are you computing the value twice?
09:34:21 <Johulk> but (1,2,3) has 1,2 and many more
09:34:22 <Johulk> like
09:34:30 <Johulk> 1 and 2 are the heads
09:34:33 <Johulk> and 3 is the tail
09:34:48 <yohotchoc> no, you're looking for something like (x:y:xs)
09:34:59 <yohotchoc> you're mixing different types of syntactic sugar
09:35:35 <Johulk> OH
09:35:36 <Johulk> LOL
09:35:38 <Johulk> I'm dumb
09:35:39 <yohotchoc> your first two patterns will work as you expect, but the third one is trying to pattern match a tuple with three elements
09:35:42 <yohotchoc> :D
09:35:48 <Johulk> I hate it
09:35:52 <Johulk> when I forget the :
09:35:56 <Johulk> Urgh
09:36:19 <yohotchoc> you can also simplify this a bit
09:36:44 <yohotchoc> assuming your sum function makes sense when you give it an empty list, which it might not
09:37:00 <Johulk> It doesnt
09:37:11 <Johulk> It should only accept atleast one triplet as an imput
09:37:44 <yohotchoc> then you're on the right path once you fix that pattern match I think
09:37:52 <Johulk> yea
09:38:01 <infandum`> mnoonan_: No calculation, just [[a]] and each sublist is a cluster, so they are assigned by zip [1..]
09:38:07 <Johulk> Just need to find a way to sum two triplets
09:38:40 <Johulk> uh<
09:38:40 <yohotchoc> aren't you already doing that in your second pattern match?
09:38:42 <Johulk> mm..
09:38:48 <mnoonan_> infandum`: hmm, why do you want the cluster numbers to be floating point anyhow?
09:39:27 <mnoonan_> > x == x + 100 - 100 where x = 2 ^ 53 - 1 :: Double
09:39:28 <Johulk> Well
09:39:29 <lambdabot>  <hint>:1:20: error: parse error on input ‚Äòwhere‚Äô
09:39:29 <Johulk> I am
09:39:42 <mnoonan_> @let bigX = 2^53 - 1 :: Double
09:39:42 <infandum`> mnoonan_: I've had bad experiences with large Int resulting in NaN
09:39:43 <lambdabot>  Defined.
09:39:51 <mnoonan_> > bigX == bigX + 100 - 100
09:39:53 <lambdabot>  False
09:40:01 <yohotchoc> mnoonan_: Integer
09:40:11 <Johulk> Thanks
09:40:13 <Johulk> That helped
09:40:33 <mnoonan_> yohotchoc: sure, but he‚Äôs specifically asking about Double.
09:42:18 <yohotchoc> which he's using to avoid issue with large numbers resulting in NaN
09:42:22 <mnoonan_> > (maxBound :: Int) > 2^53 - 1 ‚Äî infandum` even with Int, you‚Äôre better off than Double
09:42:24 <lambdabot>  <hint>:1:47: error: parse error on input ‚Äòwith‚Äô
09:42:31 <yohotchoc> which can be more correctly avoided with Integer
09:42:50 <mnoonan_> ergh, stupid irc client substitutions :(
09:42:59 <infandum`> But integer is super slow apparently
09:43:42 <yohotchoc> Double can't store any more values than Int - they reside in the same size of machine word
09:44:07 <yohotchoc> with the added issue that mnoonan_ is alluding to that x + 1 == x in certain cases
09:44:08 <infandum`> > 1000000000000000000000000000 :: Int
09:44:11 <lambdabot>  -6930898827444486144
09:44:19 <infandum`> > 1000000000000000000000000000 :: Double
09:44:21 <lambdabot>  1.0e27
09:44:24 <infandum`> That's why :/
09:44:29 <yohotchoc> > 1000000000000000000000000001 :: Double
09:44:31 <lambdabot>  1.0e27
09:44:36 <yohotchoc> you see the issue?
09:44:39 <infandum`> So I always tend to avoid Int
09:44:43 <mnoonan_> infandum`: I‚Äôm going to guess that you have fewer than 2^63 different clusters
09:44:59 <infandum`> yohotchoc: No, because one is way more accurate
09:45:09 <yohotchoc> it's *less* accurate
09:45:27 <infandum`> > 10000000000000000000000000000 :: Double
09:45:30 <lambdabot>  1.0e28
09:45:32 <yohotchoc> a lot of the values Double can represent are between 0 and 1
09:45:37 <yohotchoc> you're not using those
09:45:45 <infandum`> 10000000000000000000000000000 :: Int
09:45:48 <yohotchoc> Double isn't a magic wand
09:45:55 <infandum`> To me, the Double representation is much better
09:46:00 <mnoonan_> Double and Int both can only store a finite number of different integers, so in either case you‚Äôre going to get duplicated cluster labels eventually.
09:46:10 <mnoonan_> but for Int, you get more
09:46:14 <yohotchoc> ^
09:46:22 <mnoonan_> (er, more *distinct* labels)
09:47:39 <infandum`> That may be true in this case, but in terms of big numbers, I trust double more than int
09:47:45 <koala_man> > (10000000000000000000000000000 :: Double) == 10000000000000000099999999999
09:47:46 <lambdabot>  True
09:48:15 <infandum`> Still more accurate than -6930898827444486144
09:48:27 <yohotchoc> > zipWith (+) [-1, 0..2] $ repeat (2 ^ 53) :: [Double]
09:48:29 <lambdabot>  [9.007199254740991e15,9.007199254740992e15,9.007199254740992e15,9.0071992547...
09:48:44 <yohotchoc> note how the middle too are the same
09:49:01 <yohotchoc> Double is more *precise*, it's less *accurate*, and can store fewer distinct values
09:49:25 <infandum`> Then how come I run into NaNs with large Int but not large Double?
09:49:29 <yohotchoc> (strictly speaking they can store exactly the same number of values since they have as many bits as each other, but since Double can represent +0 and -0...)
09:49:35 <infandum`> I'd rather return an approximation than a complete error
09:49:50 <yohotchoc> because you're not having distinct values
09:49:50 <mnoonan_> NaN is a floating point value, how are you getting it from an Int?
09:50:05 <yohotchoc> at some point you'll be returning the same value over and over again, which is just a more subtle complete error
09:51:12 <infandum`> It was from division
09:51:25 <infandum`> when I needed to eventually convert from int to double
09:51:43 <yohotchoc> division?
09:51:48 <yohotchoc> why?
09:53:17 <infandum`> So the issue I had (this was years ago in haskell) was with calculating binomial coefficients with input integers. I forgot the details, but with large enough numbers, that calculation would fail yet would succeed (with appropriate accuracy) with double inputs.
09:54:41 <yohotchoc> yup, that's the sort of thing doubles are great for
09:55:20 <infandum`> Ever since then I avoided int unless I knew they were going to be very small
09:55:52 <mnoonan_> you took the wrong lesson from that experience, I‚Äôm afraid
09:56:06 <yohotchoc> > maxBound :: Int
09:56:08 <lambdabot>  9223372036854775807
09:56:17 <yohotchoc> unless you're labelling more things than that, you're good with Int
09:56:44 <infandum`> True
09:56:53 <yohotchoc> combinatorics (like the binomial coefficients) get very big but don't need extremely high precision, so double is a good fit
09:57:07 <yohotchoc> labelling things doesn't go very high but needs absolute precision, so int is a good fit
09:59:03 <yohotchoc> also, since labels just need to be unique, you actually get twice that number, since negative numbers are perfectly valid
10:01:46 <infandum`> I'm convinced. I'm still ever wary though.
10:05:09 <yohotchoc> if you're doing maths, double is a decent call most of the time
10:05:24 <mnoonan_> well‚Ä¶ https://pastebin.com/RLD9eiBv
10:05:30 <yohotchoc> if you're looking for unique values with strict equality, int most of the time
10:05:47 <yohotchoc> if you're dealing with non-integral things that you need lossless maths on, rationals
10:09:11 <saml_> > let l = [0, 1, ..]; f = head l  in (f, f, f)
10:09:13 <lambdabot>  <hint>:1:16: error: parse error on input ‚Äò..‚Äô
10:09:32 <saml_> how do I define f so that f = 0;  and f = 1 on subsequent call to f?
10:10:01 <saml_> i need some sort of recursive magic that threads l
10:11:22 <mnoonan_> you can‚Äôt make f return different things at different times, since that breaks referential transparency. what are you trying to do, exactly?
10:18:14 <yohotchoc> try looking at the state monad saml_, that's probably the sort of thing you're looking for
10:18:44 <saml_> not even with fix?
10:28:52 <huss`> Hey guys I want to create a type that seems to be a tree
10:29:09 <huss`> I have an entity that can have a position, a rotation, a velocity ...
10:29:16 <huss`> Ive done that https://pastebin.com/raw/ivpS4C1q
10:29:38 <huss`> Do you think thats the good way to go in haskell ?
10:30:24 <huss`> If you see the data type 'WithVelocity', it has to have an origin of type 'WithPosition', but I don't know how to be able to constraint that
10:31:05 <mnoonan_> huss`: generally using records inside a sum type is a bad idea, because the record accessor functions are partial
10:31:26 <mnoonan_> e.g. imagine applying ‚Äòchildren‚Äô to a term of the form ‚ÄúWithVelocity etc etc‚Äù
10:31:40 <AndreasK> saml_: Fix doesn't change what a function returns. The standard solution would be to "hide" the required state in a monad.
10:32:27 <saml_> yup
10:32:52 <huss`> mnoonan: calling children would be done by doing a getChildren (Origin i c)  = c
10:33:48 <huss`> mnoonan: How can I make it possible ?
10:33:56 <mnoonan_> the way you‚Äôve written it, and entity either *is* an Origin, or *is* a ‚ÄúWithVelocity‚Äù, etc
10:34:53 <huss`> In the end the 'origin' have to be an 'Origin'
10:35:22 <AndreasK> huss`: The easiest way would probably be wrap your optional information in maybe. So Object { id, children, position :: Maybe PositionData, rotation :: Maybe RotationData} but that is not a free abstraction
10:36:23 <huss`> AndreasK: Not really great because I won't be able to wrap it twice like I can now
10:36:39 <huss`> e.g WithFriction friction (WithFriction friction ...
10:38:49 <mnoonan_> you could still make a function withFriction that sets the friction if it was Nothing, or updates the friction if it was a Just.
10:41:06 <huss`> I think what I try to achieve is in relation with that ticket https://ghc.haskell.org/trac/ghc/ticket/11962
10:41:22 <huss`> I don't get why it's not allowed
10:42:48 <AndreasK> Not sure I follow why you couldn't double wrap it then
10:42:54 <huss`> It works, but I would like to be constrained by the type systemfault
10:45:25 * hackage ethereum-analyzer 3.3.0, ethereum-analyzer-deps 3.3.0, ethereum-analyzer-cli 3.3.0, ethereum-analyzer-webui 3.3.0 (zchn): https://qbin.io/xre2i9ibx
10:46:48 <huss`> Its a feature that currently work in Agda
10:46:59 <huss`> We'll have to wait a bit I guess :P
10:47:49 <mnoonan_> I don‚Äôt see what that has to do with what your code showed.
10:48:14 <huss`> Its an induction
10:48:56 <huss`> The code I gave you is working
10:49:15 <huss`> But I wanted the WithVelocity to have an origin of type 'WithPosition'
10:49:24 <mnoonan_> ah
10:49:46 <mnoonan_> GADTs, maybe?
10:49:51 <huss`> Not working aswell
10:49:56 * hackage cabal-lenses 0.5.0 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.5.0 (DanielTrstenjak)
10:50:02 <huss`> And thats exactly what the guy try to do in the ticket ...
10:50:15 <huss`> Induction recursion
10:50:43 <huss`> Neither GADTS, TypesInType nor DataKinds is helping
10:51:26 <huss`> Thanks anyway :)
10:52:45 <absimas> Hello. Stupid question. Can I simplify (\a b -> pure (a+b))? Can I perhaps apply function composition here?
10:53:45 <AndreasK> pure . (+) I guesS?
10:54:44 <huss`> +1 for AndreasK
10:55:01 <[Leary]> pure ... (+) where (...) = (.).(.)
10:55:23 <absimas> :D
10:55:28 <huss`> pure pick your value and wrap it, (+) takes two value and add them together
10:55:39 <[Leary]> Otherwise you'll get pure (a+) $ b
10:55:40 <yohotchoc> lol
10:55:58 <huss`> by composing them you end with a function that takes two value, add them together and wrap the result
10:56:08 <AndreasK> So that's Pointless style then xD
10:56:48 <huss`> pure . (+) :: Int -> Int -> M Int
10:57:14 <AndreasK>  > :t pure . (+)
10:57:28 <AndreasK> pure . (+) :: (Num a, Applicative f) => a -> f (a -> a)
10:57:34 <dmwit> ?pl \a b -> pure (a+b)
10:57:34 <lambdabot> (pure .) . (+)
10:57:36 <AndreasK> Not exactly the same thing
10:57:51 <huss`> Yep not very accurate by hands :D
10:58:00 <yohotchoc> [Leary]: could've saved yourself some .s
10:58:03 <huss`> I want him to understand
10:58:22 <dmwit> absimas: I don't think you can simplify it, really, for any sane human-readable meaning of "simplify".
10:58:27 <AndreasK> Personally I think the lambda might be clearer anyway
10:58:37 <[Leary]> Imo a ... b is much better style than (a .) . b
10:58:45 <reactormonk> Any specific editor which supports browsing sources of dependencies?
10:59:04 <huss`> I feel the composition much more readable
10:59:12 <huss`> When they are pretty basic
10:59:14 <dmwit> reactormonk: I always just use the hyperlinked haddocks. =P
10:59:50 <absimas> This channel is really enthusiastic :D
11:00:11 * shapr hops cheerfully
11:00:11 <AndreasK> Well bikeshedding is always fun :D
11:00:56 <huss`> Haha
11:04:37 <tsahyt> what'd be the way to handle large graphs. I mean really large, several gigabytes of data. there's edwardk's graphs library that mentions very large graphs, but there doesn't seem to be anything in the library to handle the offloading onto disk etc
11:05:15 <edwardk> you'd have to write your own instance to get the loading from disk behaviors
11:06:33 <tsahyt> edwardk: I see. so it's mostly that the imperative-ish API is just better suited for this?
11:06:56 <edwardk> yeah. you can make a monad that is capable of pulling stuff off disk
11:07:14 <edwardk> the original version of this before the library was comonadic
11:07:33 <edwardk> but i switched to allow a usecase where i needed a pretty massive graph
11:08:37 <tsahyt> okay. well then I'll take a look at this. I really wanted to take algebraic-graphs for a spin but I doubt it lends itself for this usecase.
11:08:55 <MarcelineVQ> ertes: was it you who uses Codensity for resource management? any pointers for where to learn more about that beyond the Codensity hackage docs
11:09:09 <shapr> fgl never seemed friendly to me, algebraic-graphs looks nicer at first read.
11:09:09 <POGtastic> hi guys, i'm trying to do Problem 23 from 99 Haskell Problems, which is throwing me for a loop. i've been good at most of these problems, but i'm baffled at how to actually get a random number into my function. as far as i can tell, i need a random number seed, which involves some kind of monad. current code is here: https://pastebin.com/CgVCeBPK
11:10:27 <dmwit> POGtastic: Looks like the intended solution is to use `IO`.
11:10:30 <tsahyt> shapr: I mostly found myself annoyed by fgl being rather inflexible by how you refer to nodes and edges. I don't like how the underlying IntMap implementation shows through the API that way. most of the time I want to reference them by something that isn't an Int
11:10:33 <dmwit> :t randomRIO
11:10:34 <lambdabot> Random a => (a, a) -> IO a
11:10:37 <dmwit> POGtastic: ^^
11:11:31 <dmwit> % let xs = "abcdefghij" in do { i <- randomRIO (0, 9); print (take i xs ++ drop (i+1) xs) }
11:11:31 <yahb> dmwit: "abcdefhij"
11:12:02 <POGtastic> lemme check something real quick
11:12:22 <dmwit> tsahyt: samesies
11:13:50 <tsahyt> it does look like graphs is polymorphic enough that I can write things against the normal types now and then just add a stream-from-disk solution later
11:14:26 <POGtastic> well, it didn't like that. lots of messages of "expecting Int, got actual type IO Int." so i think i need to change up both my removeAt function and my rnd_select function to take IO Int?
11:14:42 <dmwit> tsahyt: I've gotten some mileage out of this kind of pattern before: http://lpaste.net/179178
11:14:52 <dmwit> tsahyt: But it's fgl, so in-memory only, really.
11:15:57 <dmwit> POGtastic: removeAt should not need to change. Nothing should need to take an IO action as an argument. rnd_select probably will need to change to return an IO action.
11:15:58 <tsahyt> hm yeah in-memory not really feasible here. I mean for the toy I'm really building it is, but since this is essentially a distributed database, it'd be nice to know that it scales to hundreds of GBs without requiring you to sell a kidney for RAM.
11:16:21 <dexterfoo> @botsnack
11:16:21 <lambdabot> :)
11:16:51 <dmwit> POGtastic: If you haven't done IO before, I recommend sigfpe's IO Monad for People Who Just Don't Care or something like that.
11:17:00 <dmwit> ?google io monad people who just don't care
11:17:01 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
11:17:01 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
11:17:33 <dmwit> POGtastic: Or, if you have a bit of a theoretical bent, his "You Could Have Invented Monads" is a more comprehensive intro to monads and also excellent.
11:17:38 <tsahyt> dmwit: hm so you're maintaining a second map to find the nodes again from what I can see. that's roughly what I did too with fgl. eventually it ended up driving me to representing graphs implicitly instead and write general search procedures taking successor functions etc.
11:17:51 <POGtastic> ok, i've got some reading to do lol
11:17:53 <tsahyt> since the search was really everything I needed from fgl most of the time
11:18:02 <POGtastic> i did group theory but never took a category theory class unfortunately
11:18:47 <dmwit> You do not need a deep (or any) understanding of category theory to write IO code.
11:32:33 <AndreasK> I can imagine knowledge of category theory might be useful. But lack of that knowledge seems to matter not all that much for "getting things done" so far
11:35:50 <POGtastic> let's simplify our IO monad shenanigans for better understanding. say that I want a function that gets me n random numbers. i'm having difficulty writing a recursive function to do that. here's my current code: https://pastebin.com/PmxtBxrL
11:36:42 <POGtastic> i guess i'm confused as to why I can't cons an (IO Int) with an empty to list to make an [IO Int].
11:36:48 <POGtastic> empty list*
11:37:35 <tsahyt> AndreasK: FWIW I've been using Haskell for almost all projects I've done for a few years now, and all I know about Category Theory is stuff I've just picked up along the way. I'm sure there's some deeper knowledge that remains hidden, but it's really not a necessity at all
11:38:00 <tsahyt> that said, I'd still like to study it.
11:39:03 <dmwit> POGtastic: You can. But `return []` is not an `[IO Int]`.
11:39:12 <dmwit> POGtastic: You want `[]` for that, presumably.
11:39:52 <tsahyt> :t return []
11:39:53 <lambdabot> Monad m => m [a]
11:40:14 <dmwit> :t let getRandoms :: Int -> [IO Int]; getRandoms 0 = []; getRandoms n = randomRIO (1,10) : getRandoms (n-1) in ()
11:40:15 <lambdabot> ()
11:40:24 <tsahyt> POGtastic: as you can see there, return [] would have type IO [Int] in your case, not [IO Int]
11:40:31 <dmwit> POGtastic: That said, I bet you will eventually want `IO [Int]` instead of `[IO Int]`.
11:40:42 <POGtastic> gotcha
11:41:25 <dmwit> POGtastic: At which point you will probably want to use `do` syntax or one of the many `IO` combinators to combine your `IO Int` and `IO [Int]` actions (which cannot be combined with pure `:`).
11:41:29 <huss`> I think that tryharding the theory first then the code is better
11:42:07 <tsahyt> huss`: I think that's somewhat individual. some people need to see results quickly, others can delve into theory for ages and not lose interest
11:42:11 <AndreasK> There is more theory about computing than most people are willing to tryhard in a lifetime. So I limit myself there
11:42:47 <huss`> I meant understanding the core concepts
11:43:10 <huss`> tsahyt: ur probably right
11:43:46 <dmwit> Ah, see? Now we get to redirect the argument to "what qualifies as a core concept?". As a devil's advocate, I define it vacuously to be "nothing is a core concept" so that I can get straight to coding.
11:44:12 <huss`> Haha you caught me here
11:44:21 <POGtastic> my errors are multiplying. lol https://pastebin.com/39mpvdEu
11:44:39 <tsahyt> dmwit: why, zygohistomorphic prepromorphisms of course
11:44:41 <dmwit> POGtastic: Yes, `[]` is not an `IO [Int]`. =)
11:45:03 <huss`> POGs
11:45:11 <tsahyt> that reminds me, I need to finally learn recursion schemes
11:45:14 <dmwit> POGtastic: Did you read "IO for Those Who Simply Don't Care"? (Can I use the terminology of that article?)
11:45:16 <huss`> POGtastic: getRandoms 0 = pure []
11:45:32 <AndreasK> POGtastic: If you want to take the result based approach, you can generate random number generator in main and then pass that along in your pure code
11:45:33 <POGtastic> yes, but it didn't have anything for functions :(
11:46:00 <tsahyt> every now and then I come across code that's sprinkled with anas and catas and prepros, and I don't understand a thing anymore
11:46:07 <dmwit> POGtastic: Okay. In the terminology of that article, `getRandoms (n-1)` is a command.
11:46:17 <POGtastic> ahhh
11:46:22 <dmwit> POGtastic: So the rules for commands apply: if you want to use their results, you need a `<-`.
11:46:43 <dmwit> POGtastic: And then you just have a small syntax error at the end: `return a : b` is `(return a) : b`, but you probably meant `return (a : b)`.
11:47:08 * shapr learns recursion Haskells
11:47:15 <mnoonan_> tsahyt: it‚Äôs easy, just replace ‚Äúana‚Äù with ‚Äúunfold‚Äù, ‚Äúcata‚Äù with ‚Äúfold‚Äù, and ‚Äúprepro‚Äù with a large amount of whiskey
11:47:35 <POGtastic> success!! https://pastebin.com/2qHBdiEG
11:47:55 <tsahyt> mnoonan_: but then why not just use unfold/fold?
11:48:01 <tsahyt> or a large amount of whiskey for that matter
11:48:03 <POGtastic> thanks a lot. i think i can get the original problem from here
11:48:13 <dmwit> ?remember mnoonan it's easy, just replace "ana" with "unfold", "cata" with "fold", and "prepro" with a large amount of whiskey
11:48:13 <lambdabot> Nice!
11:48:31 <dmwit> POGtastic: Great!
11:48:34 <dmwit> POGtastic: And now...
11:48:40 <dmwit> % replicateM 5 (randomRIO (1,10))
11:48:41 <yahb> dmwit: [7,3,4,3,9]
11:48:46 <dmwit> POGtastic: ^_^
11:48:48 <POGtastic> :t replicateM
11:48:50 <lambdabot> Applicative m => Int -> m a -> m [a]
11:49:20 <dmwit> `m ~ IO` there
11:50:03 <POGtastic> and randomRIO returns IO Int, so we get replicateM Int -> IO Int -> IO [Int]
11:50:13 <POGtastic> learning is occuring
11:50:15 <dmwit> right
11:50:20 <huss`> Well done
11:54:29 * hackage texmath 0.10.1 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.10.1 (JohnMacFarlane)
12:08:14 <POGtastic> i am so close. i'm getting a stack overflow here, which is confusing me: https://pastebin.com/STx2Grvv
12:08:41 <POGtastic> it works on empty lists. it works when i select 0 random elements. it works when i select 1 random element. but make it more than 1, and it gets mad :(
12:12:25 <dmwit> POGtastic: Well, you are wrong: it also sometimes gets mad if you select 1 random element.
12:12:29 <dmwit> Dunno if that hint helps.
12:13:07 <POGtastic> ooo
12:13:25 <dmwit> POGtastic: Anyway, it's tricky to decide how much help to give you in tracking down this bug. How many spoilers do you want?
12:13:36 <POGtastic> i figured it out, it's in my removeAtRandom
12:13:38 <POGtastic> :)
12:13:40 <dmwit> yes =)
12:14:03 <POGtastic> lemme check the documentation on randomRIO, but it might be inclusive rather than exclusive
12:14:56 <POGtastic> yep, it's inclusive. lol
12:15:06 <dmwit> Now that you've implemented `removeAt` by hand, you might enjoy trying to implement it in terms of `splitAt`. Beware that `splitAt` is 0
12:15:12 <ski> is there a reason you start counting at one rather than at zero (like `splitAt',`(!!)',&c. does) ?
12:15:13 <dmwit> ...is 0-indexed, not 1-indexed.
12:15:27 <dmwit> > splitAt 5 "abcdefghij"
12:15:29 <lambdabot>  ("abcde","fghij")
12:15:39 <POGtastic> a previous problem in 99 haskell problems demands counting from 1
12:15:41 <POGtastic> for that function
12:15:50 <ski> i see
12:16:07 <POGtastic> i am used to counting from 0, hence the constant off-by-one errors :/
12:16:30 <dmwit> Don't worry. I make constant off-by-one errors whether I am using 0- or 1-indexing.
12:16:39 <POGtastic> lol
12:16:46 <dmwit> It is a grand tradition of computer programming, I think.
12:17:02 <POGtastic> YES it works! thanks a ton for your help, especially dmwit
12:17:12 <ski> should `rnd_select xs n' always produce a list of `n' elements (if successful), or is it supposed to sometimes produce one with less elements ?
12:17:35 <POGtastic> should be n elements
12:17:40 <POGtastic> unless the list is smaller than n
12:17:49 <POGtastic> in which case it just produces however many is in the list
12:17:52 <ski> so it shouldn't give an error in that case ?
12:18:03 <POGtastic> correct
12:18:06 <ski> ok
12:18:26 <ski> instead of using `fst' and `snd', you should use pattern-matching
12:18:34 <dmwit> ski: The spec is, let us charitably say, incomplete.
12:18:48 <ski> (you also have a few redundant pairs of brackets)
12:19:15 <POGtastic> oh yeah i am terrible about the redundant brackets. thanks, scheme
12:19:32 <POGtastic> "does this need 5 parens around it? meh, it can't hurt"
12:19:42 <ski> well, in Scheme you won't get away with redundant brackets :)
12:20:12 <ski> (or rather, there's no such thing there. you can't wily-nilly insert extraneous brackets, because that changes the meaning)
12:21:38 <dmwit> POGtastic: A possible thought experiment: what goes wrong if you remove the call to `reverse`?
12:21:39 <ski> POGtastic : one thing which you could try, if you like, is implementing `removeAt' without using an accumulator
12:22:11 <ski> (so, using so-called "direct style", rather than "accumulator style")
12:22:30 <dmwit> Oh, I like that exercise suggestion a lot.
12:22:55 <POGtastic> lemme try that real quick
12:23:05 <ski> perhaps you'd also want to give an error indication in case the index number is zero or negative
12:23:16 <ski> (what currently happens in this case ?)
12:23:27 <POGtastic> call stack overflow :)
12:23:56 <ski> well, you do traverse the list, until you reach the end of it
12:24:19 <ski> and then you get an error. maybe you'd like to give a different error message, though
12:26:08 <POGtastic> i'm confused as to how to get the previous elements into the list that we return without an accumulator
12:26:55 <POGtastic> in my current implementation, i add the elements before we hit the removed element to an accumulator, and then at the end i concatenate the reverse (since we're stacking them on) of the accumulator to the remaining list
12:28:40 <POGtastic> i just had an idea.
12:30:31 <POGtastic> nope, it sucked. lol
12:30:55 <POGtastic> lemme try a foldl and see if that works
12:31:35 <ski> have you seen the implementation of `(++)' ?
12:32:16 <POGtastic> but isn't concatenation slow? i'm going off of scheme here, but i was under the impression that append was slower than consing with the reverse of a list
12:32:54 <ski> i'm not talking about using (or not using) `(++)' for `removeAt'
12:33:26 <ski> (btw, you're already using `(++)' in yout current accumulating version)
12:33:38 <POGtastic> i just saw that after i typed it lol
12:34:36 <ski> appending isn't slower than could be expected. however, *repeatedly* appending to the end of a list ends up being slower than could be expected
12:34:59 <ski> the canonical example of this is
12:35:05 <ski>   reverse [    ] = []
12:35:12 <ski>     reverse (a:as) = reverse as ++ [a]
12:36:15 <ski> the point is that `reverse [0,1,2,3]' ends up as `((([] ++ [3]) ++ [2]) ++ [1]) ++ [0]', a *left*-associated nesting of `(++)' calls, this is an inefficient way to build the desired result list
12:37:25 <dmwit> POGtastic: A hint: instead of prepending the non-deleted elements once you finally do the deletion, prepend each non-deleted element as you see it.
12:37:41 <ski> in `((as ++ bs) ++ cs) ++ ds', we first have to copy the spine of `as', replacing the end (the empty list) with `bs'. then we copy the spine of that (iow essentially copy both `bs', and *again* `as'). then we copy `as' again, and `bs' again, and `cs'
12:38:08 <ski> however, if we implement `reverse' using an accumulator, e.g. like
12:38:28 <ski>   reverse as = reverseAppend as []
12:38:39 <ski>   reverseAppend [    ] acc = acc
12:38:45 <Gurkenglas> Why is transformers "experimental"?
12:38:58 <ski>   reverseAppend (a:as) acc = reverseAppend as ([a] ++ acc)
12:39:51 <hexagoxel> Gurkenglas: because it is part of this big "haskell" experiment :D
12:39:53 <ski> then `reverse [0,1,2,3]' will amount to `[3] ++ ([2] ++ ([1] ++ ([0] ++ [])))', a *right*-associated nesting of `(++)' calls, which only copies the lists (all but the last one), *once*
12:40:12 <Gurkenglas> hexagoxel, then why are there packages that are not experimental
12:40:46 <ski> (btw, here `reverseAppend xs ys' is supposed to be equal to `reverse xs ++ ys', hence the name. `reverseAppend' has also been termed `shunt', in "Haskell: The Craft of Functional Programming" by Simon Thompson)
12:40:55 <dmwit> Gurkenglas: I would bet that it started out as experimental, and then as it stabilized the author forgot that field existed. =P
12:42:04 <ski> (of course in practice `reverseAppend' here would use `a : acc' rather than the equivalent `[a] ++ acc'. i just showed with the latter, to emphasize the similarity, and difference, to the na√Øve `reverse' version)
12:43:01 <ski> POGtastic : anyway, you could imagine `(++)' being implemented with an accumulator, right ?
12:44:19 <hexagoxel> Gurkenglas: the "stability" values have no clearly defined meaning anyways, so its not surprising people don't bother updating it.
12:44:52 <POGtastic> lemme write it real quick to make sure i'm following
12:48:29 <POGtastic> ski: something like this? https://pastebin.com/sTBWvR7j
12:48:50 <Gurkenglas> http://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control-Monad-Trans-Maybe.html#line-139 why isn't the return outside the case?
12:49:50 <ski> POGtastic : yea, that works
12:50:05 <dmwit> POGtastic: Why `reverse` at the end?
12:50:17 <POGtastic> because you're building up the elements in reverse order dmwit
12:50:25 <dmwit> POGtastic: (Also, you'd have your arguments in the opposite order to standard `(++)`, it looks like. Though that's not super important.)
12:50:42 <dmwit> Oh. Yes, you're right, of course. =)
12:51:07 <ski> now, the actual implementation of `(++)' doesn't put the elements into an accumulator. it simply returns the elements, as soon as it sees them
12:51:10 <ski> @src (++)
12:51:10 <lambdabot> []     ++ ys = ys
12:51:10 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:51:10 <lambdabot> -- OR
12:51:10 <lambdabot> xs ++ ys = foldr (:) ys xs
12:51:26 <POGtastic> ooooo
12:51:34 <ski> note the `x : ...' in the body of the second defining equation
12:51:43 <POGtastic> yep
12:51:59 <POGtastic> haskell writers are smarter than i am lol
12:52:04 <ski> you should be able to do something similar, albeit perhaps slightly more roundabout, with `removeAt'
12:53:04 <ski> (i'm suggesting the same as dmwit was before, btw)
12:57:07 <shapr> POGtastic: it gets easier/better with practice
12:58:08 <POGtastic> i don't like this because we're iterating through the list twice, but it works. https://pastebin.com/auASZqNa
12:58:17 <POGtastic> (obviously need some error checking in there)
12:58:46 <shapr> POGtastic: what got you started with Haskell?
12:59:10 <POGtastic> programming languages professor wrote hugs, he's... very charismatic.
12:59:22 <POGtastic> "okay, i'll check it out"
12:59:40 <shapr> oh!
13:00:14 <shapr> I've never met Mark Jones
13:00:26 <POGtastic> by far the smartest guy i've ever talked to.
13:01:04 <POGtastic> my wife keeps calling him Rick James because the names have the same cadence, so he's Rick James in my house lol
13:01:14 <shapr> Yeah, several of those people in the Haskell community, where they're sufficiently smarter than me that I am not able to rank them.
13:01:44 <ski> POGtastic : well, how about iterating through the list once, then ?
13:03:13 <POGtastic> ski: the return type of removeAt is (a, [a]). i'm having difficulty building up the list inside the tuple...
13:03:40 <ski> well, take apart the tuple resulting from the recursive call then ?
13:04:29 <dmwit> POGtastic: `case removeAt n xs of (x, xs') -> ...` will get you both the value removed and the remainder of the list available in `...`.
13:04:39 <dmwit> POGtastic: (or `let`, or `where`)
13:04:57 <POGtastic> oh, i knew i was going to have to get better at those constructions...
13:06:37 <ski> (you could also use `fst' and `snd' .. but it's nicer to use direct pattern-matching)
13:07:48 <Gurkenglas> Gah I was trying to generalize MaybeT and arrived at ContT ._.
13:10:57 <ertes> MarcelineVQ: sorry, i don't have any, but it's really simple:  look at the type of Codensity and observe how it fits the pattern of functions like 'withFile' and 'bracket' perfectly
13:11:02 <ertes> @let import Control.Monad.Codensity
13:11:04 <POGtastic> i'm stuck. I can't figure out how to cons the previous results into my base case. https://gist.github.com/mbottini/da014f08872c950f3782444e7eb863b5
13:11:04 <lambdabot>  Defined.
13:11:07 <ertes> :t Codensity
13:11:08 <lambdabot> (forall b. (a -> m b) -> m b) -> Codensity m a
13:11:11 <ertes> MarcelineVQ: ^
13:11:28 <ertes> :t Codensity (withFile "blah.txt" ReadMode)
13:11:29 <lambdabot> error:
13:11:29 <lambdabot>     ‚Ä¢ Variable not in scope:
13:11:29 <lambdabot>         withFile :: [Char] -> t0 -> (a -> m b) -> m b
13:11:35 <ertes> :t Codensity (System.IO.withFile "blah.txt" ReadMode)
13:11:36 <lambdabot> error:
13:11:36 <lambdabot>     Data constructor not in scope: ReadMode :: GHC.IO.IOMode.IOMode
13:11:47 <ertes> :t Codensity (System.IO.withFile "blah.txt" System.IO.ReadMode)
13:11:48 <lambdabot> Codensity IO GHC.IO.Handle.Types.Handle
13:12:38 <amalloy> POGtastic: let (removed, more) = removeAt ... in ...
13:12:40 <ertes> MarcelineVQ: it looks like it's just "returning" the handle, but in reality it's passing the handle to the continuation and doing something *after* the Codensity action ends
13:13:06 <ertes> :t \open close -> Codensity (bracket open close)
13:13:07 <lambdabot> IO a -> (a -> IO b) -> Codensity IO a
13:13:22 <ertes> MarcelineVQ: ^ again it looks like it's "returning" the resource
13:13:45 <ski> POGtastic : that `1' is misplaced. you can't assume that the recursive call will give back a pair containing a number
13:13:57 <ertes> MarcelineVQ: that way you can easily do things like 'withFile' a whole list of paths
13:14:00 <ski> POGtastic : you still need to decrement the index, as before
13:14:04 <glguy_> amalloy: have you joined our #haskell AoC group?
13:14:26 <ertes> @let cOpenFile fp m = Codensity (System.IO.withFile fp m)
13:14:27 <lambdabot>  .L.hs:164:29: error:
13:14:27 <lambdabot>      Not in scope: ‚ÄòSystem.IO.withFile‚Äô
13:14:27 <lambdabot>      No module named ‚ÄòSystem.IO‚Äô is imported.
13:14:41 <amalloy> glguy_: i haven't. i don't compete for the leaderboard, and also haven't really done any exercises since like the 14th
13:14:55 <POGtastic> ski: the pair in that case statement isn't a result of the recursive call. it only contains the arguments
13:15:04 <POGtastic> which are Int and [a]
13:15:19 <ertes> :t traverse (\fp -> Codensity (System.IO.withFile fp System.IO.ReadMode))
13:15:20 <lambdabot> Traversable t => t FilePath -> Codensity IO (t GHC.IO.Handle.Types.Handle)
13:15:27 <ertes> MarcelineVQ: ^ like this
13:15:40 <ski> oh, right
13:16:41 <POGtastic> amalloy just suggested a let statement, which i don't think i follow.
13:16:51 <glguy_> amalloy: ok, competition isn't so much the point rather than seeing how far along everyone is, but if you don't want to be included that's fine:)
13:17:19 <ski> POGtastic : sorry. still, there's no need to change the previous pattern-matching on the left-hand-sides (the definienda) into an explicit `case'-expression
13:17:57 <amalloy> there's no need to, but there's nothing mechanically wrong with doing it, ski
13:18:45 <amalloy> POGtastic: the idea is, the recursive call will return two things, not just one. so you know you need to perform the recursive call, but you want to store the results somewhere in order to modify just one of them. so, let helps you break it apart
13:19:25 <amalloy> the fancier, more elegant solution would be to make use of the Functor instance for ((,) t), but i'm guessing you want something smipler
13:19:51 <POGtastic> just learning one thing at a time for now. :)
13:20:40 <glguy_> bhrlc
13:21:50 <ski> amalloy : well, it may needlessly complicate the gist of the matter, here
13:22:07 <ertes> MarcelineVQ: even if there are no data structures involved, Codensity makes the code more readable if you're allocating a whole bunch of resources, for example an SDL window + renderer + texture + sprites + ‚Ä¶
13:22:59 <amalloy> ski: yes, i don't think it is good style personally. but POGtastic is struggling with the mechanics, so i don't think it's great to worry about style
13:23:54 <POGtastic> got it: https://gist.github.com/mbottini/da014f08872c950f3782444e7eb863b5
13:24:01 <ski> well .. if the style may hinder seeing the essentials
13:24:15 * ski goes off into the corner and sulks
13:24:27 <POGtastic> i'm learning, i'm learning! just kinda slow sometimes :/
13:24:28 <amalloy> POGtastic: sure, where is equivalent here to the let i suggested. well done!
13:24:29 <POGtastic> lol
13:25:21 <ski> amalloy : nice, that `where'-clause is the point here
13:26:37 <amalloy> the "elegant" solution using Functor, by the way: (x, y:ys) -> (y:) <$> removeAt (x - 1) ys
13:26:52 <ski> instead of putting the recursive call directly inside the expression body following `=' (or `->' in your case, since you use `case'), you put it in a `where' (or `let', or even another `case') to take it apart, and then you piece it back together (adapted a bit) after the `=' (or `->')
13:27:02 <ski> er, sorry
13:27:11 <ski> POGtastic : the last two comments were meant for you
13:27:46 <POGtastic> gotcha
13:28:48 <POGtastic> :t <$>
13:28:49 <lambdabot> error: parse error on input ‚Äò<$>‚Äô
13:28:59 <frerich> glguy: I was looking at your 'go' function in today's AoC solution earlier today and wondered - could you maybe simplify that by using unfoldr (and it never stops unfolding) and then 'take 10000' or so?
13:29:09 <amalloy> :t (<$>)
13:29:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:30:35 <ski> @type fmap
13:30:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:31:14 <POGtastic> i know fmap is the general case of map
13:31:32 <glguy_> frerich: Yes you could
13:31:59 * hackage qq-literals 0.1.0.0 - Compile-time checked literal values via QuasiQuoters.  https://hackage.haskell.org/package/qq-literals-0.1.0.0 (hdgarrood)
13:32:05 <amalloy> POGtastic: right. and for tuples, fmap maps over the second element
13:32:13 <shapr> that qq-literals is weird and interesting
13:32:19 <POGtastic> ooo
13:32:19 <frerich> glguy_: Would that also alleviate the need for the bang patterns? I don't know actually how unfoldr does its work...
13:32:43 <POGtastic> now, the function we're doing here is `(y:)`
13:32:52 <amalloy> yep
13:32:55 <glguy_> frerich: No, it wouldn't help with strictness
13:33:01 <glguy_> You'd still need to handle that
13:34:02 <shapr> oh hey, I suddenly realize I could use qq-literals to good effect in that SIP stack
13:34:05 <POGtastic> and `<$>` ... i'm not sure. but it looks like we are doing a recursive call on the second argument of the tuple generated by removeAt.
13:34:15 <POGtastic> which is cons
13:34:29 <amalloy> POGtastic: <$> is just fmap
13:34:36 <POGtastic> oh gotcha
13:36:01 <POGtastic> ok. so we're applying the `(y:)` function (cons y with the argument) on the second argument of `removeAt`.
13:36:18 <amalloy> yes, but s/argument/element/
13:36:26 <POGtastic> er, yeah
13:38:22 <POGtastic> i'm intrigued by the types that it's playing with. we're applying a function (y:) :: a -> [a] on (a, [a]) and returning (a, [a])
13:39:01 <ski> no, `(y:)' has type `[a] -> [a]', if `y' has type `a'
13:39:07 <POGtastic> oop, you're right
13:39:32 <ski> also, the type `(a,[a])' can be written as `(,) a [a]', or `((,) a) [a]'
13:40:15 * POGtastic starts reading the functor chapter of LYAH
13:40:15 <ski>   fmap :: (b0 -> b1) -> (,) a b0 -> (,) a b1
13:40:27 <ski> the functor there is `(,) a'
13:40:53 <POGtastic> :t (,)
13:40:55 <lambdabot> a -> b -> (a, b)
13:41:09 <ski> to `fmap' amounts to using a function on the second component of a pair, because the pair type is curried
13:41:28 <frerich> ski: Aaah... I was just awondering why on earth it's the _second_ element it's affecting. :-)
13:41:32 <ski> well, you asked for the type of the value (constructor) `(,)'
13:41:42 <POGtastic> i realized that after i typed it in haha
13:41:49 <ski> while i was talking about the *type* constructor `(,)' (unfortunately spelled the same)
13:42:20 <POGtastic> wait, now i'm confused
13:42:53 <ski> frerich : to match `(T0,T1)', iow `(,) T0 T1' with `f a', we set `f' equal to `(,) T0' and `a' equal to `T1'
13:43:07 <ski> @type fmap
13:43:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:43:41 <frerich> ski: Yep, it makes perfect sense when writing the type (a,b) as (,) a b
13:43:42 <ski> (note that application (even type application) is left-associative, so that `(,) T0 T1' means `((,) T0) T1')
13:44:38 <ski> POGtastic : still confused ?
13:45:08 <POGtastic> i figured it out once you specified that we were talking about a function type versus actually applying that to values
13:45:38 <POGtastic> (,) 1 2 = (1, 2), but that's different from doing a function declaration.
13:46:00 <ski> that's just syntactic sugar
13:46:27 * ski doesn't remember talking about a function type, though
13:46:40 <ski> (otoh, i did talk about a type function)
13:47:22 <POGtastic> my haskell vocabulary is crap
13:47:41 <ski> it's ok. it'll get better
13:48:46 <ski> i tend to be a bit strict with terminology, at least with beginners, in the hopes that it can help avoid (or help clear up) conceptual misunderstandings
13:50:10 <ski> (it's not meant to be personal criticism, just an attempt to better align terminology with that used in the community, and to point at important distinctions and similarities)
13:51:16 <POGtastic> yeah, i understand. correctness is important, especially when you're talking about the basics.
13:53:23 <ski> ftr, a function type is the type of a function, iow a type of the shape `... -> ...'. (ditto with pair/tuple type)
13:54:05 <ski> while a type function is a function on the type level. e.g. `Maybe',`Either',`Either String',`(,)',`(,) String',`(->)',`(->) String',`IO'
13:54:55 <ski> iow an "incomplete type", like how the type `[]' (not the empty list value) is like saying "list of". a list of *what* ? it needs a type argument to describe the element type that we're interested in
13:55:10 <ski> (and the type `[...]' is syntactic sugar for `[] (...)')
13:55:21 <yohotchoc> "iow"?
13:55:26 <ski> "in other words"
13:55:30 <yohotchoc> ah
13:55:35 <ski> there is a notion of "type of a type", called a "kind"
13:55:41 <ski> @kind Maybe String
13:55:42 <lambdabot> *
13:55:42 <dminuoso> ski: Is something like ListT in `newtype ListT m a = ListT { runListT :: m [a] }` also considered a type function strictly speaking?
13:55:44 <ski> @kind Maybe
13:55:45 <lambdabot> * -> *
13:55:53 <ski> @kind (->)
13:55:53 <Gurkenglas> Why doesn't Control.Monad.Trans.Cont provide this combinator? end :: m r -> ContT r m a; end = ContT . const
13:55:54 <lambdabot> TYPE q -> TYPE r -> *
13:56:09 <amalloy> dminuoso: the ListT on the right is a type function
13:56:10 <ski> hrm :) pretend that answered `* -> * -> *' :)
13:56:19 <amalloy> er
13:56:20 <amalloy> the left
13:56:34 <ski> `*' is the kind of "concrete types", the types that are capable of having values/inhabitants
13:56:41 <dminuoso> amalloy: Right, so type families just extend them allowing me to "pick" the produced type?
13:57:21 <amalloy> i am not an expert on type families. how do they relate to this?
13:57:22 <ski> in the interactor, you can use `:kind' (or `:k') to ask for the kind of a type expression, like you can use `:type' (or `:t') to ask for the type of a (value) expression
13:57:35 <ski> dminuoso : sure
13:58:19 <ski> dminuoso : just like data constructors (partially applied or not) like `Just',`Left',`Right',`Node 3' are functions
13:58:22 <ski> @type Node
13:58:23 <lambdabot> a -> Forest a -> Tree a
13:59:13 <dminuoso> ski: Why are they called data constructors them? Is that because the functions are unable to do anything but wrap the data in a type?
13:59:15 <ski> type families allow the definition of non-parametric type functions
13:59:44 <ski> with ordinary `data' and `newtype' (and `type'), we can only declare parametric type functions, type functions that treat their arguments uniformly
13:59:49 <dminuoso> ski: But are type families not also parametric?
14:00:18 <ski> a data constructor that takes (at least) one argument is a function, but it's more than that (since you can match on it)
14:00:37 <ski> (and `True',`False',`Nothing' are data constructors, but not functions)
14:00:59 <ski> (similarly, `Int' is a type constructor, but is not a type function)
14:01:13 <dminuoso> ski: is `2` itself a data constructor too? Or does Haskell also have the concept of "immediate values" ?
14:01:36 <ski> you could think of `2' (of type `Int', say), as a data constructor, yes
14:02:01 <dminuoso> Though I think `2` is a tricky example because of the polymorphic nature
14:02:09 <ski> (numeric literals are a bit more involved, but that's not a bad first impression)
14:02:49 <ski> a type family can *match* on its type arguments
14:03:22 <ski> so it can avoid being parametric, in the sense meant here
14:03:53 <ski> it doesn't (necessarily) "behave uniformly in the parameter"
14:03:59 <dminuoso> ski: Can you do ADT type of arithmetic with type families? Or can you just overload and pick a concrete type?
14:04:08 <dminuoso> Right
14:04:42 <ski> i'm not sure what you mean by the question(s)
14:05:31 <MarcelineVQ> ertes: thank you very much for those examples, I'e tried playing with this a bit in ghci but I'm struggling with what providing the  (forall b. a -> m b) -> m b  at a later time actually affords you. How is this making code more terser/readable? Especially that last comment, I've not had to load a lot of files of various types so I'm unable to envision this
14:06:31 <dminuoso> ski: Mmm. Nevermind. I think Ill put it into my queue. Type families do sound intriguing though its unclear what fancy things you can do with them. :)
14:07:24 <MarcelineVQ> *files/resources
14:08:14 <dminuoso> GADTs are my next major topic. :)
14:08:48 <ski> GADTs are fun
14:10:02 <huss`> https://pbs.twimg.com/media/DRmPlrBVoAAJ1Th.jpg
14:10:30 <erikd> GADTs are cool and all but I have been coding Haskell professionally for 5 years and never used one in anger.
14:11:53 <ski> (unfortunately TH feels pretty ugly to use)
14:14:16 <kuribas> GADTs are nice when you create a language
14:16:06 <Taneb> erikd, we use them quite heavily where I work
14:17:06 <Taneb> I guess it depends what exactly you're doing :)
14:17:12 <erikd> Taneb: where is that if you don't mind me asking?
14:18:32 <Taneb> erikd, Myrtle Software! We're a small company in Cambridge, making a compiler for going from descriptions of neural networks to hardware description and onto FPGAs
14:19:16 <POGtastic> (our fair city)
14:19:22 <POGtastic> i miss cartalk :(
14:20:57 <erikd> Taneb: ok, you're definitely in the deep end of the pool. where i work (ambiata) we have an amphasis on reliable code that is clear, easy to read and easy to understand.
14:22:29 <monochrom> I'm pretty sure everyone emphasizes "easy to read, easy to understand".
14:23:07 <monochrom> Truth is it's a slogan that can stand for anything the speaker wants it to mean.
14:23:41 <erikd> monochrom: sure, but everyone that does haskell understands ADTs well, but fewer understand GADTs well
14:24:20 <monochrom> Then you have a trade off that sucks either way.
14:24:48 <monochrom> Limiting yourself to ADT will make cause some other parts to be a clutch.
14:25:05 <monochrom> s/make//
14:26:03 <monochrom> Basically everyone means "according to my level of education"
14:27:22 <huss`> Don't be so rude monochrom ...
14:28:18 <monochrom> That was not rude. I demand you to apologize for your wrong accusation.
14:28:55 <Gurkenglas> You'll have to go a few levels more ludicrous before my level of education sees the sarcasm
14:30:09 <huss`> Prove me that wasn't sarcasm
14:30:35 <huss`> Otherwise apalogize for accusing me of accusing you
14:30:42 <hpc> a more realistic interpretation of "easy to understand" is that the code is written so any individual logical leap on the way to total understanding is relatively small
14:30:59 <hexagoxel> -XOverloadedNaturalLanguage
14:31:02 <hpc> which works at much lower levels of initial understanding
14:35:21 <ertes> MarcelineVQ: without Codensity: withX (\x -> withY (\y -> withZ (\z -> ‚Ä¶)))
14:35:49 <ertes> MarcelineVQ: with Codensity:  do x <- Codensity withX; y <- Codensity withY; z <- Codensity withZ; ‚Ä¶
14:36:56 <ertes> MarcelineVQ: Codensity can hide layering like that
14:37:30 <huss`> >>= is better
14:38:33 <ertes> MarcelineVQ: and that gives you the option to write something like this:  xs <- traverse [Codensity withX, Codensity withY, Codensity withZ]
14:38:40 <ertes> err
14:38:48 <ertes> s/traverse/sequenceA/
14:40:15 <ertes> MarcelineVQ: another example: Codensity lets you "register" clean-up actions:
14:40:34 <ertes> @let cFinally c = Codensity (\k -> k () `finally` c)
14:40:35 <lambdabot>  Defined.
14:40:37 <ertes> :t cFinally
14:40:39 <lambdabot> IO b -> Codensity IO ()
14:41:30 <Gurkenglas> "data Rat'sTail i j a = Rat'sTail { runRat'sTail :: (a -> j) -> i }; codensity :: (forall b. (a -> m b) -> m b) -> Rat'sTail (m b) (m b) a; codensity = Rat'sTail" with indexed monads gets rid of that and all the other situations of tail-diverging indentation level
14:41:53 <Gurkenglas> "-> forall b. Rat'sTail (m b) (m b) a", I mean
14:42:06 <Gurkenglas> Though I suppose it's identical to the typechecker
14:42:50 <ertes> MarcelineVQ: BTW, you can do all these things with ContT as well‚Ä¶  Codensity is just "cleaner"
14:43:11 <Gurkenglas> Rat'sTail is even more powerful than ContT >:D
14:49:38 <Gurkenglas> Oh, I think I'm looking for http://hackage.haskell.org/package/indexed-extras-0.2/docs/Control-Monad-Indexed-Cont.html#t:IxContT
14:49:47 * ski was about to say
14:50:38 <Gurkenglas> *have insight* *find ekmett library that implemented it 9 years ago* I suppose if I keep doing this eventually I'll catch up? Or is he building the ivory tower faster than I'm climbing it
14:52:24 <Gurkenglas> But why's that m in there? Just for the sake of IxMonadTrans?
14:54:53 * hackage here 1.2.12 - Here docs & interpolated strings via quasiquotation  https://hackage.haskell.org/package/here-1.2.12 (TaylorHedberg)
14:54:58 <MarcelineVQ> This is a little embarassing, I'm not really getting how it fits together at all. What would runCodensity look like for  do x <- Codensity withX; y <- Codensity withY; z <- Codensity withZ; ‚Ä¶
14:57:19 <ski>   withX (\x -> withY (\y -> withZ (\z -> ‚Ä¶)))  -- ?
14:58:47 <Gurkenglas> In what monads is there an f such that "b c >>= d" equals "f b d >>= c"?
15:00:07 <Gurkenglas> :t [?b ?c >>= ?d, ?f ?b ?d >>= ?c]
15:00:08 <lambdabot> (?f::((a1 -> m b) -> m a2) -> (a2 -> m b) -> m a1, ?d::a2 -> m b, ?c::a1 -> m b, ?b::(a1 -> m b) -> m a2, Monad m) => [m b]
15:00:24 <ph88> hey geekosaur i'm able to send that sigINT now but i still don't get .prof file bigger than 0 bytes. This is my code https://bpaste.net/show/25b29cbe3036 this is part of the output https://bpaste.net/show/a31162c0281a
15:00:40 <geekosaur> *send*?
15:01:23 <geekosaur> enh. does the "got sigINT" show up?
15:02:33 <ph88> geekosaur, it's there on line 14 in my second paste
15:02:37 <geekosaur> hm, that framework doesn't handle keyboard signals properly itself. I don;t think tjhat should affect profiling though
15:02:43 <MarcelineVQ> ski, ertes: then I feel like I'm missing something super obvious here, how do you use this thing in an actual program, what's the abstraction gaining you if you need to provide  withX (\x -> withY (\y -> withZ (\z -> ‚Ä¶)))
15:04:24 <Gurkenglas> Can I have lambdabot let me partially specify a type signature? ":t [?b ?c >>= ?d, ?f ?b ?d >>= ?c] :: _ => [Cont r a]"
15:05:21 <monochrom> Oh, these runIn[Un]boundedThread are pretty nifty.
15:05:23 <geekosaur> is this program actually built for profiling?
15:05:59 <ph88> geekosaur, this is how i modified the benchmark script https://bpaste.net/show/b135a6cf1f23
15:06:05 <Gurkenglas> :t [?b ?c >>= ?d, ?f ?b ?d >>= ?c, cont $ const undefined] -- Oh, right.
15:06:06 <lambdabot> (?f::((a1 -> ContT r Identity b) -> ContT r Identity a2) -> (a2 -> ContT r Identity b) -> ContT r Identity a1, ?d::a2 -> ContT r Identity b, ?c::a1 -> ContT r Identity b, ?b::(a1 -> ContT r Identity
15:06:06 <lambdabot> b) -> ContT r Identity a2) => [ContT r Identity b]
15:06:44 <Gurkenglas> @unmtl ((a1 -> ContT r Identity b) -> ContT r Identity a2) -> (a2 -> ContT r Identity b) -> ContT r Identity a1 -- Can lambdabot do something like this?
15:06:44 <lambdabot> ((a1 -> ContT r Identity b) -> ContT r Identity a2) -> (a2 -> ContT r Identity b) -> ContT r Identity a1
15:06:48 <ph88> geekosaur, i see things like "Setup wai: CPU count: 2" in the output of the script and also when i change the source code i see ghc recompile it ..
15:06:49 <geekosaur> also wondering if vagrant can interfere with this somehow
15:07:26 <ph88> geekosaur, i assumed that if i stack clean and build with --profile that stack will make sure to build the source file and all it's dependencies in the right way
15:08:42 <geekosaur> can't tell enough from here. also don't know if stack might be altering things (e.g. injecting +RTS -V0 will prevent much of profiling from working)
15:09:04 <ph88> :(
15:09:14 <ph88> i can try to run the code outside of vagrant
15:09:23 <geekosaur> or -i which is the profiling (sub)timer
15:09:38 <geekosaur> you have too many moving oarts here and no good way to untangle them
15:09:41 <geekosaur> *parts
15:10:00 <ph88> i will try to place that one source file in a new stack project with the same resolver
15:12:14 <nschoe> Hi everyone, I'm having some issues and questions about something I thought was trivial: I need to send Doubles from Haskell to a Javascript browser client, over WebSockets.
15:12:47 <ph88> nice nschoe
15:13:34 <ski> MarcelineVQ : `runCodensity' on that `do'-expression would *amount* to the nested `withX' thing. you'd use `Codensity' to avoid writing that explicitly. also more indirect cases of nesting, such as the `sequenceA' example by ertes
15:13:41 <nschoe> To get my application PoC I used the good ol'd dirty method of caling `map (Text.pack . show)` on my list, then using `Text.intercalate` to intercalate an arbitraty character ('#') in my case, and sendi nthe whole as a big string.
15:15:01 <nschoe> This works, but obbvioulsy is ugly, so now I'm trying to optimise a bit. As a basic test-bench, I used this data: `take 361 [0..] :: [Double]` to send. Withthe string method, it creates 2055 characters.
15:15:38 <nschoe> I'm not sure (and don't know how to actually check) but I supposed a character was being sent as one-byte, so that makes 2055 bytes sent.
15:15:50 <Gurkenglas> @djinn ((a1 -> ((b -> r) -> r)) -> ((a2 -> r) -> r)) -> (a2 -> ((b -> r) -> r)) -> ((a1 -> r) -> r) -- Huh. Is this definitive, or might there be problems with the nesting?
15:15:50 <lambdabot> Cannot parse command
15:15:58 <Gurkenglas> @djinn ((a1 -> ((b -> r) -> r)) -> ((a2 -> r) -> r)) -> (a2 -> ((b -> r) -> r)) -> ((a1 -> r) -> r)
15:16:02 <lambdabot> -- f cannot be realized.
15:16:36 <Eduard_Munteanu> nschoe, so it's something like "3.1415#42#100"?
15:16:43 <nschoe> Now I tried both `serialise` and `binary` with methods `serialise` and `encode`. I could never make it work with `binary` (`encode`): it was impossible for me to get back a number from Javascript.
15:16:46 <nschoe> Eduard_Munteanu, indeed.
15:17:22 <Eduard_Munteanu> nschoe, try an actual serialization format, like MessagePack (or just JSON)?
15:17:58 <nschoe> I only could manage with `serialise`, and even there, it's thanks to a weird tricky that I could manage to extract the data back in Javascipt. But then with `serialise`, the `byteLength` was 3251. Which is much more that the stirngbased method :/
15:18:43 <nschoe> Eduard_Munteanu, yes that's what I tried: encoding the Double with either `serialise` or `binary`. But as I said: I can extract anything useful with `binary`.
15:18:43 <monochrom> "binary" uses its own format which is basically undocumented and the only promise is "the other side using the same library can decode it".
15:18:57 <nschoe> monochrom, ah! So I'm not crazy then
15:19:02 <nschoe> monochrom, where did you get this?
15:19:10 <monochrom> And I encourage you to dig deep into "binary"'s source code to see what I mean and be very, very horrified.
15:19:26 <nschoe> monochrom, that much? ^6
15:19:27 <monochrom> Its doc and source code.
15:19:37 <Xal> monochrom: are you talking about the binary's automatic binary instance generator?
15:19:43 <monochrom> For example you won't believe how it does even "simple" Int.
15:19:47 <Eduard_Munteanu> I guess anything that can serialize arbitrary data types is going to use a specific format
15:19:50 <geekosaur> you don;t have license to be horrified until you've done the same with an ASN.1 library :p
15:20:06 <nschoe> xD
15:20:23 <nschoe> So `binary` is out of question, which was consistent with what I (painfully) experimented
15:20:29 <geekosaur> but anyway, yes, any binary serialization format is going to use some specific format.
15:20:44 <monochrom> Basically even for Int it begins with some kind of tagging so it is neither 4 bytes nor 8 bytes.
15:20:55 <nschoe> So the next question is: how / why is `serialise`'s implementation much more greedy?
15:21:02 <geekosaur> ASN.1, protocol buffers, and BSON are attempts to make general reusable binary serialization formats; each has its weaknesses and strengths
15:21:18 <nschoe> It transmitted 3251 bytes for my 361 Double. With a string, it's 2055 characters.
15:21:44 <geekosaur> Doubles are a pathological case.
15:21:50 <nschoe> I assumed the bytelength is 1 * 2055 (or does anyone here know if WS.sendTextData sends characters as 2 (or more) bytes?)
15:22:11 <nschoe> I heard of CBOR too
15:22:15 <geekosaur> you're one of those people who thinks encodings sort themselves out automagically?
15:22:42 <geekosaur> wouldn't surprise me if it's using UTF16
15:22:57 <nschoe> Not really I'm aware of the issues, but I am one of those people that think transmitting floating point values over network is something that is "solved" in 2017 :/
15:23:03 <geekosaur> ahahahh
15:23:40 <monochrom> Expect prime-numbered bytes to be big-endian and composite-numbered bytes to be little-endian and the 0th and the 1st bytes are randomly-chosen-endian.
15:23:42 <geekosaur> floating point is not standardized at that level. about the only mostly reliable way to do it is text
15:24:00 <nschoe> Are you serious?
15:24:08 <geekosaur> and you will still run into idiosyncrasies involving the low order bits
15:24:11 <geekosaur> yes, I am serious
15:24:12 <Xal> please don't lynch me, but in 2017 we can spare the extra bytes to transmit your float as ascii
15:24:14 <nschoe> What about IEEE754 float representations or CBOR?
15:24:32 <geekosaur> even in the all-Intel-x86 universe people think is the only thing that ever exists or matters
15:24:37 <monochrom> nschoe: It was solved in 1945. Then it was solved again but a different solution in 1947. Then... By 2017 it has been solved 49 times, and that's exactly the issue.
15:24:46 <nschoe> yeah well if all it comes down to is chosing between big or little endian, that's oen test-case and I'm done :(
15:24:49 <Eduard_Munteanu> Well, you'll have to pick a specific representation and endianness.
15:24:56 <Xal> even tar just says "screw it" and serializes everything in ascii
15:25:06 <nschoe> Xal, wtF?
15:25:13 <geekosaur> you still run up against things like how if at all it handles the extended resolution format that used to only exist deep inside the Intel FP registers until people started demanding it be exposed
15:25:20 <Hafydd> Xal: do you realise that each time you do that you could slightly change the value?
15:25:27 <Rembane> Xal: It does?
15:25:29 <monochrom> Do not expect the meta-level, real problem of "can humanity come to a consensus already?!" to be solved in the next 50 years though.
15:25:43 <nschoe> Okay well I don't want to start a hot debate ^^
15:25:47 <geekosaur> Rembane, yes, the tar header format is mostly ASCII. so is cpio's
15:25:55 <Rembane> Is the endianness fixed for floating point numbers?
15:25:57 <geekosaur> (although cpio also has a binary format)
15:26:03 <Eduard_Munteanu> No.
15:26:04 <nschoe> I just want to know how I can stream by list of Doubles to my browsed-base, javascript app :/
15:26:14 <geekosaur> IEE754 does not specify endianness. or actual bit representation
15:26:17 <Rembane> geekosaur: Cool! I didn't know this. Hey... mostly ascii? What parts aren't? And in what format are they?
15:26:17 <Xal> example tar header: est0000644000175000017500000000001413217312135010131 0ustar
15:26:21 <Eduard_Munteanu> IEEE and the likes only specify the numeric properties.
15:26:29 <geekosaur> it's not about serialization, it's about computational compatibiility
15:26:36 <monochrom> You could use JSON
15:26:44 <Xal> Rembane: the contents of the files themselves are kept in the same
15:26:51 <nschoe> monochrom, doesn't really help me: how do I send this JSON?
15:26:51 <Xal> everything else is ascii
15:26:52 <yohotchoc> +1 for JSON
15:26:52 <Rembane> Xal: Sweet! Thank you.
15:26:56 <nschoe> As a string too ? o_O
15:26:59 <Eduard_Munteanu> Or MessagePack, that's pretty much JSON with a saner representation.
15:27:06 <Rembane> nschoe: Data.Aeson is your friend.
15:27:12 <geekosaur> Rembane, pathnames are bytestrings and can theoretically contain anything except NUL
15:27:15 <yohotchoc> JSON integrates real nice with JS though
15:27:22 <monochrom> Look for a library called "aeson" which is our favourite Haskell library for JSON work.
15:27:41 <geekosaur> that's also why the pathname is the last thing in the header record
15:27:46 <monochrom> Send an "array of numbers" in JSON format.
15:28:04 <Eduard_Munteanu> Caveat: you probably won't be able to handle the numbers in a streaming fashion with JSON et al.
15:28:16 <monochrom> Now, of course, the app side needs to parse JSON now. And I hope you do something more careful than "just use eval".
15:28:20 <nschoe> okay I see
15:28:27 <Rembane> geekosaur: That's interesting.
15:28:33 <monochrom> which means more work but also less vulnerable.
15:28:35 <Eduard_Munteanu> Ew, eval.
15:28:36 <nschoe> so aeson can produce a bytestring that WebSockets can send.
15:28:40 <nschoe> I'll try that, then.
15:29:30 <huss`> monochrom: "just use eval" is fine in much of the cases
15:29:30 <Eduard_Munteanu> eval is basically the design document for JSON, which is goddamn stupid.
15:29:31 <nschoe> Well I'll try that, thanks :)
15:29:50 <monochrom> Actually you may even not need the aeson library. You can easily build "[1.3, 3.14, 4.999999999]" yourself
15:30:26 <nschoe> monochrom, yes but I need to make it into a bytestring to send
15:30:27 <yohotchoc> yeah, but doing it properly to start with will make you not hate yourself if you try to extend it
15:30:37 <nschoe> with websockets
15:30:59 <monochrom> Well aeson is worth learning, I guess.
15:31:39 <Eduard_Munteanu> See Data.Text.Encoding
15:32:37 <Eduard_Munteanu> :t encodeUtf8
15:32:38 <lambdabot> error: Variable not in scope: encodeUtf8
15:32:48 <Eduard_Munteanu> @hoogle encodeUtf8
15:32:49 <lambdabot> Data.Text.Encoding encodeUtf8 :: Text -> ByteString
15:32:49 <lambdabot> Data.Text.Lazy.Encoding encodeUtf8 :: Text -> ByteString
15:32:49 <lambdabot> Data.Conduit.Text encodeUtf8 :: Monad m => Conduit Text m ByteString
15:33:01 <nschoe> Eduard_Munteanu, I see, but... isn't this basically what I have been doing? o_o
15:33:26 <Eduard_Munteanu> nschoe, well, you've sent the Text directly, who knows what encoding it picked
15:33:53 <nschoe> Eduard_Munteanu, okay but apparently Javascript `ws.onmessage()` was happy with it.
15:34:41 <Eduard_Munteanu> WebSockets do not really care about the encoding, they just transfer bytes.
15:35:26 <Eduard_Munteanu> Text contains codepoints which must be converted to bytes.
15:37:19 <Eduard_Munteanu> > Data.Text.Encoding.encodeUtf16LE "[0]"
15:37:21 <lambdabot>  error:
15:37:21 <lambdabot>      Not in scope: ‚ÄòData.Text.Encoding.encodeUtf16LE‚Äô
15:37:21 <lambdabot>      No module named ‚ÄòData.Text.Encoding‚Äô is imported.
15:39:18 <geekosaur> nschoe, you did ask why it was using 2 bytes, and I suggested UTF16. no bets here and you *must* determine what both sides expect.
15:40:17 <geekosaur> UTF16 tends to be common for this because Java defaults to it
15:40:47 <geekosaur> as do a number of modern Windows protocols/formats
15:41:32 <nschoe> geekosaur, actually I'm not sure whether it uses one or two bytes.
15:41:40 <Xal> why did anyone ever think utf16 was a good idea
15:42:01 <geekosaur> Microsoft, basically
15:42:07 <monochrom> Because there was a time Unicode was basically just the basic multilingual plane.
15:42:10 <geekosaur> Java used UTF16 because Windows did
15:42:10 <drewbarbs> i think people thought UCS-2 was a good idea
15:42:18 <nschoe> But I have just tried using WS.sendTextData conn (Data.Aeson.Text.encodeToLazyText numbers) where numbers = take 361 [0..] :: [Double] and it worked.
15:42:28 <drewbarbs> then UTF-16 was just "eh, close enough"
15:42:42 <huss`> utf-16 rocks
15:42:52 <geekosaur> sorta backwards. UCS-2 had problems, UTF-16 fixed many of them
15:42:56 <Xal> utf16, as well as being a variable length encoding, incurs the whole byte-order mess too
15:42:58 <geekosaur> while being mostly compatioble'
15:43:02 <Xal> it really is the worst of both worlds
15:43:12 <nschoe> I'm not very "happy" with this because this amounts to sending the floats as string, separated by commads instead of my '#'. But that works easily. And will generalise when I upgrade my data from a simple list of Double to something else.
15:43:25 <geekosaur> and Microsoft didnt care about byte ordering because 24/7 Intel x86
15:43:39 <huss`> microsoft rocks aswell
15:43:40 <Rembane> I thought utf16 was fixed byte length. You are making my world fall apart.
15:44:11 <drewbarbs> utf-32 is fixed length, if you dont mind a little bloat
15:44:13 <drewbarbs> :)
15:44:18 <Xal> Rembane: no, every codepoint is encoded using one or two 16-bit units
15:44:20 <geekosaur> and didn't care about variable length because at the time anything that they cared about that went outside the BMP used custom 16 bit encodings, so UCS2/UTF16 actually let them simplify things a bit
15:44:32 <nschoe> Thanks guys for the elp and suggesting `aeson`. It seems to work okay for my use-case.
15:45:42 <Rembane> Xal: Okay, that sounds like a slightly worse UTF-8.
15:46:26 <geekosaur> this is just another example of people oversimplifying things for the moment and not considering either the future or anyone not sufficiently like them
15:46:30 <Xal> Rembane: not just slightly! because everything is 16 bit, there are different byte-orders
15:46:41 <Xal> that's why we have the byte-order-mark
15:47:33 <Rembane> Xal: Oh. It sounds like a royal mess.
15:47:35 <geekosaur> more specifically, this is the tragedy of the commons playing out in text encodings
15:47:59 <Rembane> I always bring popcorn to those kinds of tragedies.
15:48:36 <monochrom> Heh yeah, take it easy and watch the comedy of the commons. :)
15:59:21 <Rembane> And hope that it will end well.
16:01:20 <ph88_> geekosaur, this is what i get when run this file in it's own stack project outside of vagrant https://bpaste.net/show/b5f6978b36a5
16:02:07 <ph88_> also no prof file shows up at all .. which is different than the 0 bytes file i got before
16:05:35 <ph88_> what i don't get is that i got a 0-byte prof file and not this notice when i run it inside the benchmark suite
16:10:19 * hackage affection 0.0.0.7 - A simple Game Engine using SDL  https://hackage.haskell.org/package/affection-0.0.0.7 (nek0)
16:12:50 <ph88_> another thing is that i would think stack is smart enough to enable -rtsopts when --profile has been given to stack without specifying --ghc-options (it can assume that profile flags are given with program execution)
16:15:18 <ph88_> maybe this behaviour changed between lts-6.3 and lts-10.0
16:20:19 <ph88_> can anyone confirm that just building with --profile does not allow you to set +RTS -p on stack exec ?
16:21:23 <Gurkenglas> Has profiling ever worked for you, ph88?
16:22:13 <geekosaur> ph88_, if something like that changed between LTS releases then it's generally ghc that changed
16:22:22 <geekosaur> a resolver specifies a ghc version
16:24:07 <Gurkenglas> Trying to profile a hello world program using a new and old resolver might clear up some of this
16:24:55 <Gurkenglas> You could also fire up a vm and retry there
16:25:06 <WinterFox[m]> Does anyone know where I can find a basic description of what a lens is?
16:25:23 <ph88_> yes i'm compiling with lts-6.3 now .. but i use lts-10.0 in the benchmark suite as well .. so that doesn't really explain the difference between the prof file showing up or not
16:25:38 <ph88_> i can imagine stderr being surpressed but i doubt that is the case
16:25:55 <Gurkenglas> WinterFox[m], a "Lens' s a" is a witness that the type s is the product of the type a and something else, such as is the case when a is a record field of s
16:26:09 <Gurkenglas> *"when a record field of s has type a"
16:26:18 <ph88_> Gurkenglas, yes profiling worked on my own programs no problems .. i'm just trying to recreate a situation i have inside a vagrant box in my own os
16:27:07 <WinterFox[m]> Gurkenglas: Maybe a situation you would use it in would make more sense.
16:28:13 <Gurkenglas> WinterFox[m], if you have a deeply nested record, you can use lenses to manipulate deeply entrenched values with oneliners
16:28:47 <c_wraith> WinterFox[m], in a different direction - lenses and related structures (referred to as "optics" in general) are part of a toolkit for uniform manipulation of all kinds of data structures.
16:29:00 <ph88_> that's basically all i know lens is good for .. so ye .. i don't know much ^^
16:29:14 <Gurkenglas> WinterFox[m], lenses, like other optics, turn small actions into big actions, where what action means depends on the kind of optic. For a lens, the actions are defined so that you have just enough power to get and to set. Through this perspective, one sees why lenses can be composed.
16:29:58 <c_wraith> WinterFox[m], if you have a value and want to modify it or extract a portion  of it, optics give you tools to do so that all share the same patterns. learn once and you can apply the same tools to any data.
16:30:07 <ph88_> getting into lenses seems daunting
16:30:17 <WinterFox[m]> ph88_: It does.
16:31:42 <ph88_> shit ran into that stack bug :/
16:31:49 <ph88_> can't downgrade to lts-6.3
16:32:20 <ph88_> oh restarting the build seems to go okay so far ^^
16:35:51 <Gurkenglas> @let firstpairelement :: Lens' (a, b) a; firstpairelement = lens (\(a, b) -> a) (\(_, b) a -> (a, b)) -- Here's an archetypal lens.
16:35:52 <lambdabot>  Defined.
16:36:34 <Gurkenglas> > view firstpairelement (1, 2) -- You can get using a lens.
16:36:36 <lambdabot>  1
16:36:57 <Gurkenglas> > set firstpairelement 3 (1, 2) -- You can set using a lens.
16:36:59 <lambdabot>  (3,2)
16:37:02 <geekosaur> consider that you can start with only a small subset of lens, then expand later --- and realize that it all builds ont he same base and behaves in sumular ways
16:38:35 <Gurkenglas> :t firstpairelement -- The lens turns things depending on a into things depending on (a, b).
16:38:36 <lambdabot> Functor f => (a -> f a) -> (a, b) -> f (a, b)
16:39:15 <Gurkenglas> :t firstpairelement . firstpairelement -- Therefore, the composition of two lenses is a lens.
16:39:16 <lambdabot> Functor f => (a -> f a) -> ((a, b1), b2) -> f ((a, b1), b2)
16:39:39 <ph88_> what do you mean by this     The lens turns things depending on a into things depending on (a, b).
16:39:43 <Gurkenglas> > view (firstpairelement . firstpairelement) ((1, 2), 3)
16:39:45 <lambdabot>  1
16:40:36 <geekosaur> ph88_, exactly what firstpairelement is doing. if you apply a function operating on a via firstpairelement, you get a function operating on (a,b)
16:40:59 <geekosaur> same way fmap turns a function on a into a function on f a for some Functor f
16:41:02 <ph88_> > (fst . fst) ((1, 2), 3)
16:41:04 <lambdabot>  1
16:41:06 <ph88_> it's the same, no ?
16:41:18 <geekosaur> except you have hardcoded fst, and tuple knowledge
16:41:34 <geekosaur> lens lets you do that for *any* type like that, not just tuples
16:41:53 <yohotchoc> :t firstpairelement . firstpairelement
16:41:54 <lambdabot> Functor f => (a -> f a) -> ((a, b1), b2) -> f ((a, b1), b2)
16:41:57 <yohotchoc> :t fst . fst
16:41:58 <lambdabot> ((c, b1), b2) -> c
16:42:03 <Gurkenglas> geekosaur, you could write a getter such as fst for *any* type like that, not just tuples
16:42:07 <geekosaur> but here Gurkenglas is starting with an example using a tuple so you can follow that
16:42:09 <wagle> woo hoo!  haskell-platform uninstall-hs uninstalls itself but nothing else if you arent root
16:42:38 <yohotchoc> :t view . firstpairelement . firstpairelement -- I suppose this is what we're actually comparing here
16:42:39 <lambdabot> error:
16:42:39 <lambdabot>     ‚Ä¢ Couldn't match type ‚Äò((a, b0), b1)‚Äô with ‚Äòa1 -> Const a1 a1‚Äô
16:42:39 <lambdabot>       Expected type: (a -> s -> a) -> Getting a1 s a1
16:42:44 <yohotchoc> or not :(
16:43:06 <yohotchoc> :t view . firstpairelement . firstpairelement)
16:43:07 <lambdabot> error: parse error on input ‚Äò)‚Äô
16:43:11 <yohotchoc> dangit, sorry
16:43:15 <ski> @type view (firstpairelement . firstpairelement)
16:43:16 <lambdabot> MonadReader ((a, b1), b2) m => m a
16:43:22 <yohotchoc> thanks ski
16:43:35 <Gurkenglas> ski, check with lambdabot first whether the internal type is insane :P
16:44:21 <ski> hm, which internal type ?
16:45:37 <Gurkenglas> I'm calling "MonadReader ((a, b1), b2) m => m a" internal from the perspective of the current discussion because it is closer to the implementation than I was planning to go ^^
16:46:42 <ski> sorry, i just thought yohotchoc looked like wanting that expression
16:46:54 * ski hasn't followed along
16:47:10 <yohotchoc> that is indeed what I was looking for
16:47:19 <Rembane> If you ignore MonadRader and m, it looks really nice.
16:48:03 <Gurkenglas> Trying to hide Functor behind an alias. Can I do something like "Lens' s a = LensAction act => act a -> act s"?
16:48:37 <ski> it looks like in Gurkenglas's case, `MonadReader ((a,b1),b2) m => m a' was specialized to `((a,b1),b2) -> a'
16:49:01 <ph88_> geekosaur, i'm a bit further in my quest .. turns out in the benchmark there were some ghc-options set in the cabal file
16:49:53 <ph88_> geekosaur, but my sigINT doesn't terminate the program  https://bpaste.net/show/4b6b79bdefd7
16:50:37 <ph88_> this is the source code https://bpaste.net/show/25b29cbe3036
16:50:54 <huss`> Guys I have a problem
16:50:59 <huss`> https://pastebin.com/raw/UXKcgdkC
16:51:14 <huss`> I'm trying to constraint
16:51:14 <huss`>             | WithVelocity { velocity :: Velocity, origin :: Entity }
16:51:22 <huss`> With :
16:51:25 <Gurkenglas> One reason to look at tuples when explaining lens is that every "Lens' s a" makes s look like (a, b) for some b
16:51:36 <huss`> WithVelocity { velocity :: Velocity, origin :: WithPosition }
16:51:42 <geekosaur> ph88_, that isn't your program's fault since stack si reporting the ExitSuccess. sounds like possibly a stack bug of some kind
16:51:55 <ph88_> aw
16:51:58 <Gurkenglas> For example, in firstpairelement . firstpairelemen, ((a, b), c) is made to look like (a, (b, c)).
16:52:17 <geekosaur> or you have something else acting as a wrapper and restarting it for some reason
16:52:18 <huss`> "Cannot be used here defined is same recursion group"
16:52:36 <huss`> No recursive induction ?
16:52:38 <ph88_> geekosaur, i will try to access the compiled binary directly from .stack-work
16:53:43 <ph88_> geekosaur, i get the same when i run     .stack-work/install/x86_64-linux/lts-10.0/8.2.2/bin/wai-test 2 127.0.0.1 +RTS -p -A32m -N2
16:53:47 <huss`> Even with GADTs its impossible
16:53:54 <geekosaur> huss`, the real problem there is that WithPosition is not a type
16:54:34 <huss`> It would tell me
16:54:35 <geekosaur> but since ghc has added type promotion, type errors of this sort have been a bit confusing because ghc can't tell if you are using a data constructor as a type or if you mean a promoted type constructir
16:55:08 <huss`> Well looking at net give me https://ghc.haskell.org/trac/ghc/ticket/11962
16:55:10 <Gurkenglas> In fact, one could define "Lens' s a = exists b. (s -> (a, b), (a, b) -> s)", except that b need not have a representation.
16:55:19 <geekosaur> (kinda wish it had a pedantic mode that required you to explicitly indicate promotion. I think that might even be in sufficiently recent ghc)
16:55:29 <huss`> I think its not yet implemented
16:56:21 <geekosaur> an any case this is nto about recursive induction
16:56:40 <geekosaur> this is about WithPositionbeing a data constructor, not a type
16:57:05 <huss`> It doesnt telle me that
16:57:17 <huss`> I don't get why you would'nt be able to do that
16:57:20 <geekosaur> but the error message is confused because it tries it first as a promoted type, in which case it runs into the recursive binding group issue
16:57:41 <wagle> is haskell-platform 8.2.2 stable?
16:57:44 <huss`> And it's pretty similar to the ticket I linked
16:57:47 <geekosaur> never mind, since I just explained what is going oin and you have clearly rejected it, there is no point in continuing
16:58:09 <wagle> .. trying to figure out why homebrew is styill on 8.2.1
16:58:39 <dmwit> huss`: What are you hoping `origin :: WithPosition` would mean?
16:59:11 <huss`> It would constraint me
16:59:21 <dmwit> Constrain you in what way?
16:59:58 <huss`> In the construction of my WithVelocity
17:00:15 <huss`> Since applying a velocity to my origin object implies that it has a position
17:00:29 <geekosaur> still believes it is a type and that the compiler's error message cannot possibly be about type vs. promoted kind confusion
17:01:14 <dmwit> huss`: Let me state what I think you want: you want `WithVelocity` to only be allowed to apply to a value whose constructor is `WithPosition`. Is that right?
17:01:25 <ski> huss` : looks like you maybe want refinement types ?
17:01:40 <dmwit> huss`: If so, then you need `WithPosition` to have a *different return type* than your other constructors, so that the type system can tell the difference between them.
17:01:50 * ski isn't sure `WithPosition p0 (WithPosition p1 o)' makes much sense
17:02:29 <huss`> I would like to compose my object
17:02:54 <huss`> Like WithVelocity v (WithPosition p (Origin 0 []))
17:05:17 <ski> how about making separate types `Origin',`OriginWithPosition',`OriginWithRotation',`OriginWithFriction',`OriginWithVelocity' ?
17:06:07 <huss`> How will you be able to wrap an OriginWithRotation with an OriginWithFriction then ?
17:06:28 <dmwit> huss`: http://lpaste.net/361055 ?
17:07:48 <huss`> https://pastebin.com/raw/MCPzAfNi
17:07:51 <huss`> Tried that
17:07:55 <huss`> Same error
17:07:57 <ski> dmwit : i suspect a `WithFriction' is only supposed to contain a `WithVelocity'
17:08:17 <huss`> ski: yes
17:08:27 <dmwit> huss`: Okay. Instead of trying that, why don't you try what I suggested?
17:08:45 <huss`> The link you gave ?
17:08:52 <dmwit> Yes.
17:09:04 <ski> i'm not sure whether a `WithRotation' can contain something else than an `Origin'
17:09:14 <dmwit> ski: That's fine and doable. It's not hard to extend the idea I proposed to do that.
17:09:15 <huss`> Where does it constraint the Entity given to the WithFriction constructor ?
17:09:35 <dmwit> huss`: It doesn't. It constrains the `WithVelocity` constructor, like you asked.
17:09:41 <dmwit> 16:51 < huss`> WithVelocity { velocity :: Velocity, origin :: WithPosition }
17:10:07 <ski> dmwit is suggesting adding a tag/flag to the type to describe its "state"
17:10:12 <dmwit> But the idea can be extended to have other constraints, if necessary.
17:10:20 <huss`> Okay I see
17:10:38 <ski> i was suggesting refactoring the type into several types
17:11:27 <huss`> ski: I want any object accepting an entity to wrap any entity
17:11:35 <dmwit> You can `data Tag = TagOrigin | TagPosition | TagRotation | TagVelocity | TagFriction`. Then every constructor can say in its type exactly which constructor was used, and can demand any constructor it likes in recursive positions.
17:11:57 <huss`> dmwit: Will try that thanks
17:12:53 <ski> huss` : it looked liked you didn't want a `WithVelocity' to wrap anything else than a `WithPosition'
17:12:56 <ski> you could do that like
17:13:19 <ski>   data OriginWithVelocity = WithVelocity { velocity :: Velocity, origin :: OriginWithPosition }
17:13:22 <ski> &c.
17:13:40 <dmwit> huss`: http://lpaste.net/361055
17:13:41 <huss`> ski: Some of my constructors would like to compose anything
17:13:48 <WinterFox[m]> Is it usually ok to open an issue on a repo to ask for more documentation for a function?
17:13:52 <ski> but i'm not sure what the exact constraints of what can and can not wrap what are
17:14:11 <ski> huss` : then make a general `Entity' that can be any of these variants ?
17:14:34 <ski> (that adds syntactic salt, with extra wrapping data constructors, though)
17:14:48 <dmwit> WinterFox[m]: eh. Maybe if it's accompanied by the additional documentation you want added...
17:15:25 <WinterFox[m]> Well thats the issue. I can't work out how to use something and there is no info anywhere other than a 1 line desc.
17:15:29 <ski> huss` : so `WithPosition' and `WithRotation' can wrap anything, including other such constructors, yes ?
17:15:54 <huss`> Yep
17:16:01 <dmwit> WinterFox[m]: Okay. That's not really an issue with the package, though, so I would look for a mailing list, IRC channel, or direct author email address (in that order).
17:16:48 <WinterFox[m]> IRC channel is dead but there is a mailing list I could try.
17:17:00 <ski> huss` : why is `WithRotation a0 (WithRotation a1 o)' allowed, while `WithVelocity v0 (WithVelocity v1 o)' isn't ?
17:17:08 <dmwit> WinterFox[m]: That said, I wouldn't hold your breath on any of those options. Read the source. =P
17:17:27 <huss`> ski: Well I could constraint theses aswell
17:17:41 <huss`> ski: The example was more revelant with the velocity/position or velocity/friction
17:17:51 <ski> just wondering, since it smells inconsistent to me
17:18:28 <huss`> ski: You're right
17:18:31 <ski> (also, as i said, i'm not sure what `WithPosition p0 (WithPosition p1 o)' is supposed to mean)
17:18:54 <dmwit> huss`: Follow-up question: are you sure you don't just want something like `data Entity = Entity { origin :: Position, pos :: Position, rotation :: Rotation, vel :: Velocity, friction :: Friction }`?
17:19:25 <ski> it also seems a bit fishy to me that you're throwing in both entities with, and entities without, positions, into the same data type `Entity'
17:19:32 <huss`> dmwit: All theses components will be optionnal
17:19:46 <dmwit> huss`: Sure. So make them `Maybe` if you want, or have a default value that "does nothing".
17:19:58 <dmwit> e.g. 0 friction is the same as not having friction, 0 rotation is the same as not being rotated, etc.
17:20:05 <ski> are you ever going to have a list (or other collection) of entities, some of which have positions, and some of which haven't ?
17:20:14 <huss`> ski: yes
17:21:20 <dmwit> In fact, the more I stare at this code, the more convinced I am that `Entity` is Wrong.
17:21:22 <ski> i'd like to hear more about how this could make any sense
17:21:38 <huss`> Lol
17:21:42 <huss`> I may be wrong
17:21:48 <huss`> Let me explain in detail and tell me
17:22:26 <huss`> First I agree with you ski on having a constraint on each type so that I can't double wrap with the same
17:23:26 <huss`> As you see I update the entity by giving a dt
17:24:04 <huss`> And I actually can apply my update function before of after having updated my origin
17:24:55 <huss`> Plus I don't have to handle any maybe since at the construction I know which components my entity will be composed of
17:25:34 * ski doesn't really follow .. but do go on
17:25:39 <huss`> So this structure is like a tree with each node wrapped to extend its functionalities
17:25:55 <dmwit> What is the difference between `WithFriction 0 v` and `v`?
17:26:15 <huss`> 0 v ?
17:26:24 * ski . o O ( "What is the difference between `0 + x' and `x' ?" )
17:27:10 <dmwit> huss`: No, not `0 v`, `WithFriction 0 v`.
17:27:21 <huss`> Where do you see that
17:27:31 <ski> they don't
17:27:32 <dmwit> In the message I sent to you here on IRC.
17:27:38 <ski> it's an example they invented
17:27:54 <huss`> ski: Its different to have a velocity of 0 and no velocity
17:27:56 <dmwit> Or: does where I see it change your answer?
17:28:24 <ski> huss` : what's the difference ?
17:28:29 <huss`> ski: I mean saying my entity has a velocity of 0 mean that it has the velocity component
17:28:47 <ski> when does this difference matter ?
17:29:09 <ski> (or, if you will, "Is it a difference that makes a difference ?")
17:29:15 <huss`> ski: Plus you can"t take that to argue since I will have more complex components that just that
17:29:26 <huss`> than
17:30:00 <dmwit> Let us first get this simple case right. Then we can worry about how to make it more complex.
17:30:14 <dmwit> So, I ask again: what is the difference between `WithFriction 0 v` and `v`?
17:30:16 <huss`> Its working well like that...
17:30:27 <dmwit> Oh. Okay. Then you don't need our help!
17:30:31 <dmwit> Great!
17:30:56 <huss`> Give something different that achieve the same then
17:31:20 <huss`> I'm okay with building it in a wrong way but give an example
17:31:52 <ski> <dmwit> huss`: Follow-up question: are you sure you don't just want something like `data Entity = Entity { origin :: Position, pos :: Position, rotation :: Rotation, vel :: Velocity, friction :: Friction }`?
17:31:56 <ski> <huss`> dmwit: All theses components will be optionnal
17:31:58 <ski> <dmwit> huss`: Sure. So make them `Maybe` if you want, or have a default value that "does nothing".
17:32:02 <ski> <dmwit> e.g. 0 friction is the same as not having friction, 0 rotation is the same as not being rotated, etc.
17:32:27 <ski> is that code snippet (plus suggestion for default) ok as an example ?
17:33:00 <dmwit> Well. That's going after many fixes at once. I was going to argue for one field at a time so that we couldn't get distracted. =P
17:33:04 <dmwit> But yes.
17:34:33 <huss`> How will I build the pattern matching with 15 optionals components
17:34:46 <ski> it's ok if that `Entity' version isn't quite what you want. but we need to understand how it's not sufficient, then. you need to better explain what you're trying to do, probably
17:35:13 <dmwit> Presumably exactly the way you would have done it given that you already have 15 optional components: one piece at a time.
17:35:49 <dmwit> Except now you have the option to only worry about the optional components you care about, whereas with your design you *must* deal with all components.
17:36:21 <dmwit> Anyway there aren't 15 optional components. There are just two: origin and position. And I'm not even sure they're both optional.
17:36:56 <dmwit> (Indeed, I'm not even sure why both origin and position are needed.)
17:37:15 <dmwit> (Because you have explained really very little about what it is you are doing.)
17:37:56 <huss`> All you're saying here is that I should flatten the Tree to process it
17:38:13 <dmwit> Yes.
17:38:44 <huss`> I prefer the recursive way
17:40:25 <dmwit> Okay. It is my expert opinion that the way you are doing it now will lead to headaches in several ways: inconsistent data, extraneous annotation, forgotten patterns, maintenance troubles. Some of these can be fixed with sufficient blunt force at the type level, and then you will have ten miles of code when six inches would do.
17:42:48 <dmwit> But you know what they say. You get good judgment from experience, and you get experience from bad judgment. So maybe this can be a learning experience for you if you continue in this way. Just don't expect a lot of sympathetic help from folks in here when things go sideways...
17:45:57 <huss`> I asked for a graph solution to my problem
17:46:44 <huss`> You told me to flatten the entity and put 10 maybe in it
17:47:38 <dmwit> No. I expect with careful design you should need 0 maybes.
17:48:25 <dmwit> Also your claim is factually inaccurate. According to my logs, this is the first mention you have made of the term "graph".
17:48:45 <huss`> Tree if you prefer
17:48:55 <huss`> I wrote it while back
17:48:59 <huss`> But anyway
17:49:30 <huss`> Thanks
18:15:57 <dmwit> Okay, a couple oddities about that conversation stuck in my head while I was out for a walk, and some of them clicked, so I would like to clarify:
18:16:26 <dmwit> I do not argue against tree structure. Many carefully-designed libraries that deal with positions and rotations and the like use tree structure; e.g. diagrams.
18:16:37 <dmwit> I argue against the straight-line non-structure inherent in the With* family of constructors.
18:18:40 <ski> (unfortunately they're gone by now)
18:19:34 <dmwit> That's fine. The clarifications are mostly for my peace of mind anyway.
18:39:32 <ertes> MarcelineVQ: normally you use lowerCodensity instead of runCodensity
18:39:37 <ertes> :t lowerCodensity
18:39:38 <lambdabot> error: Variable not in scope: lowerCodensity
18:39:47 <ertes> @let import Control.Monad.Codensity
18:39:48 <lambdabot>  Defined.
18:39:49 <ertes> :t lowerCodensity
18:39:51 <lambdabot> Applicative f => Codensity f a -> f a
18:50:50 <Axman6> :t Codensity
18:50:51 <lambdabot> (forall b. (a -> m b) -> m b) -> Codensity m a
18:51:44 <MarcelineVQ> etrepum: Thank you, I see here that is   \c -> runCodensity c pure   I really don't think I ever would have figured out to use pure to use runCodensity
18:51:56 <MarcelineVQ> er, tab, you betrayed me
18:52:07 <MarcelineVQ> *ertes
18:56:59 <ertes> MarcelineVQ: compare these:
18:57:26 <ertes> main = withX (\x -> withY (\y -> withZ (\z -> f x y z)))
18:57:53 <ertes> main = lowerCodensity $ do x <- Codensity withX; y <- Codensity withY; z <- Codensity withZ; lift (f x y z)
18:58:31 <ertes> Codensity turns layering into sequencing
18:58:41 <ertes> (or rather the other way around)
19:03:07 <MarcelineVQ> thank you, I could see the advantage but couldn't figure out how to use the thing which made it seem like a lot less of an advantage :X
19:08:54 <siwica> I defined a type `data RomanLiteral = I | V | X | L | C | D | M deriving (Eq, Ord, Enum, Show, Read)` and a `newtype Roman = Roman [RomanLiteral]`. How can I make functions that return `[RomanLiteral]` at the moment, return `Roman` instead`?
19:09:41 <dmwit> Roman . f
19:09:41 <ertes> siwica: Roman :: [RomanLiteral] -> Roman
19:11:18 * geekosaur wondering if you intended type instead of newtype
19:11:53 <siwica> I want to define typeclass instances for it (espeacially Num)
19:12:44 <geekosaur> you only need newtype if the original type has conflicting instances
19:13:34 <dmwit> Despite that, I wholeheartedly endorse this newtype.
19:13:36 <geekosaur> hm, come to think of it, that does make some sense since it'd conflict with list
19:13:39 <siwica> Part of it is also, that I want to practice the use of newtype
19:13:54 <ertes> siwica: is this an exercise?  because normally you would just compute with Integer and use roman numerals only at parsing/printing
19:14:02 <geekosaur> (there are ways around that, notably the showList hack)
19:14:18 <geekosaur> also yeh, computing with roman numerals sounds like an exercise in frustration
19:14:44 <siwica> ertes: Yeah, I made this exercise up
19:16:20 <Guest78> siwica: are you looking for small app ideas to practice with?
19:17:23 <siwica> Guest78: Ideas are always welcome, but at the moment I want to define a newtype Roman and make it instance of a couple typeclasses :D
19:17:35 <dmwit> Yeah!
19:17:39 <dmwit> siwica++
19:18:18 <ertes> i wouldn't even know how to compute with them other than converting to Integer and back =)
19:19:17 <siwica> ertes: Well that's probably what the typeclass instances are gonna do behind the scenes :)
19:19:35 <siwica> But it would be interesting to find out, how the Romans used to do arithmetics
19:19:56 <ertes> counting probably
19:20:29 <siwica> Maybe they had their tricks...
19:20:40 <ertes> a bunch of short-cuts yeah
19:21:06 <greg`> does anyone here use haskell-ide-engine? is it any good? does it work with emacs , or should i consider something evil like atom or vscode?
19:21:13 <geekosaur> thoght they mostly got the Greeks to do it for them
19:22:07 <ertes> greg`: are you trying to learn about HIE, or do you just want a good dev experience with emacs?
19:22:45 <siwica> Have a look at Intero in the latter case
19:22:51 <greg`> ertes: I want the best IDE experience for haskell and i dont really want to let emacs go unless the haskell experience is worth it
19:23:16 <ertes> greg`: i use haskell-mode with emacs
19:23:38 <greg`> ertes: not tried haskell-ide-engine then?
19:23:44 <Guest78> siwica: did you try some type like data Roman = I | V | X | L | C | D | M
19:23:45 <ertes> it has all the usual IDE stuff like GHCi integration, jumping to errors, asking for types, inline evaluation, etc.
19:24:05 <greg`> i use intero at the moment
19:24:12 <ertes> greg`: well, i'd be open to trying it, but so far i haven't, mostly because haskell-mode has everything i need
19:26:05 <siwica> Guest78: Yeah, I defined `data RomanLiteral = I | V | X | L | C | D | M`
19:26:23 <greg`> vscode is quite sexy to be fair (just looking at it now)
19:26:43 * geekosaur wonders if a better solution is a record of Ints in each group
19:27:06 <Guest78> siwica: Hmm yes, but then I thought, if you want to try and do math with it (for fun) then maybe it would be nice to have a data RomanNumber = [RomanLiteral]
19:27:12 <geekosaur> hm, doesn't handle the decrement forms though
19:27:32 <siwica> Guest78: Have you read my initial question?!
19:27:38 <geekosaur> but RomanNumber is arguably partial
19:27:44 <Guest78> I missed it, I'll get it from the logs...
19:28:23 <geekosaur> (ex: [I, I, I, V])
19:28:39 <siwica> Yeah, I wrote the functions to do math with them already
19:28:59 <siwica> e.g. converting back and forth
19:30:02 <ertes> greg`: forgive me for being sceptical, but something like vscode probably won't make an emacs user happy =)
19:30:10 <Guest78> siwica is that what you wanted? I re-read your question and I'm still not sure what you're looking for
19:30:40 <greg`> ertes: pray tell why?
19:31:22 <siwica> Guest78: It's answered already. But thanks!
19:31:27 <ertes> well, let me think‚Ä¶  why would migranesoft vscode not make an emacs user happy?
19:31:41 <greg`> lol
19:32:37 <Guest78> siwica ok :)
19:33:21 <geekosaur> depends on why they're an emacs user
19:33:40 <ertes> obviously because they enjoy the menu and all the lovely mouse controls
19:33:53 <geekosaur> I mean, some people are just going to choose one thing and stick to it.
19:34:13 <geekosaur> and others use tools as opposed to marrying them
19:34:28 <greg`> ok i get it.... i like something thats fast without too much ui noise that i can configure
19:35:05 <greg`> but yeah i like fingers on keys.....im prepared to experiment too
19:35:56 <geekosaur> like, I played with Atom for a bit and gave up not because it's not emacs, but because it liked to get into friendly competitions with my browser to see which one would eat all my RAM
19:36:12 <ertes> well, i am pretty much married to emacs at this point: accounting, coding, email, IRC, project management, ‚Ä¶
19:36:40 <greg`> i havent gone as far as email yet
19:36:57 <greg`> but i org, code and irc in emacs
19:39:48 <greg`> getting weird stack errors "AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
19:41:27 <geekosaur> think that means you need to upgrade stack
19:41:35 <MarcelineVQ> it does
19:41:38 <greg`> thanks
19:42:36 <greg`> geekosaur: as in ```stack upgrade```?
19:43:36 <geekosaur> yes
19:43:37 <greg`> got it
19:43:46 <MarcelineVQ> sure, note that the new executable is placed in ~/.local/bin so you need that at the start of your $PATH, which you'd want to do anyway if using stack
19:44:13 <greg`> MarcelineVQ: thanks i'd only just figured it out
20:01:04 <siwica> What is the easiest way to define a Read instance of a type when I already have a f :: String -> MyType function?
20:01:48 <siwica> Can I circumvent defining readsPrec myself?
20:02:44 <greg`> instance Read MyType where read  = f
20:04:11 <siwica> greg`: That's what I naivly thought, too. This, however, yields: "‚Äòread‚Äô is not a (visible) method of class ‚ÄòRead‚Äô"
20:05:26 <ski> `f :: String -> MyType' is not composable
20:06:24 <ski> how will the `(Read a,Read b) => Read (a,b)' instance be able to read a `(MyType,MyType)', or a `[MyType]', or a `Maybe MyType', using only `f' for reading an actual `MyType' ?
20:06:57 <ski> you should define `readsPrec'
20:07:21 <glguy_> siwica: You can derive the correct implementation of Read that will match Show
20:07:22 <ski> why isn't deriving `Read' suitable in your case ?
20:09:08 <siwica> I thought there might be an automatism for simple MyTypes (e.g. when the show method is only yields result of the form [^()\]\[,]* )
20:09:29 <siwica> *the show method only yields results of the form [^()\]\[,]* )
20:10:05 <isd> Is anyone familair with the serialise package? I'm using it and wanting to build a conduit producer of values, read from a file. but as far as I can tell there's no way to decode values in a streaming fashion; it looks like you have to just give it the whole input. Which means I'd have to find the boundaries between values myself.
20:10:34 <mniip> hmm
20:10:35 <ski> siwica : that sounds like a broken `show', to me
20:10:43 <mniip> do I have enough time to grab a snack before AoC
20:11:19 <glguy> Can you afford to be hungry during AoC?
20:11:27 <mniip> damn you're right
20:11:27 <ski> (not quite sure how to parse that result form, but it doesn't look like Haskell syntax, which is what `show' should produce)
20:11:41 <greg`> is it possible to have a streaming parser?
20:12:34 <geekosaur> there is also that one should probably not use Show/Read for a display format intended for humans, as opposed to for programs
20:12:40 <siwica> ski: I meant `show (x :: MyType)` does not include anything fancy (like brackets, parentheses, commas, ...)
20:13:11 <geekosaur> let Show and Read be the debuggable internal format and use different functions for presentation formats
20:13:47 <siwica> geekosaur:
20:14:06 <siwica> geekosaur: Is that the best practice?
20:14:11 <geekosaur> yes
20:14:28 <ski> `Show' and `Read' are meant to operate on strings representing Haskell expressions, which, evaluated (in an appropriate environment), will yield the corresponding value in question (or one that behaves the same)
20:14:43 <ski> they are not meant for pretty-printing
20:14:52 <geekosaur> in part because you may find yourself tracking an apparent bug in a computation thagt turns out to actually be an edhge case in parsing
20:15:47 <geekosaur> this is more obvious if the debugging format from Show/Read (thus convenient to e.g. ghci) shows the internal format, which would reveal immediately your parser/formatter got/produced garbage, not the calculation
20:15:48 <ski> `instance Show a => Show (Maybe a)' generates Haskell syntax (`Nothing' vs. `Just'), and expects that the `Show a' instance generates a valid Haskell expression
20:16:20 <siwica> Ok, I thought I could use them for standard parsing, too
20:16:41 <siwica> I defined something like this as an exercise: http://lpaste.net/361058
20:16:44 <ski> so, parametric instances like `Maybe', lists, &c. are meant to be composable. if you make a `Show' instance that doesn't generate a Haskell expression, you break this composability
20:16:56 <ski> and ditto for `Read'
20:17:10 <geekosaur> greg`, yes, it is possible. attoparsec supports streaming parsers. parsec/megaparsec support limited streaming but are still pretty much pass/fail (i.e. parse an entire thing or die)
20:18:43 <geekosaur> ReadP parsers are simplistic and are not capable of streaming
20:20:27 <ski> there are valid cases when you don't want to derive `Show' and `Read', but rather make your own custom instances
20:21:09 <ski> if you have an abstract data type, you don't want to expose the implementation, but rather translate the value to an expression in terms of the exported operations, which will reconstruct an equal value
20:21:32 <ski> > listArray (0,3) [2,3,5,7]  -- is an example
20:21:34 <lambdabot>  array (0,3) [(0,2),(1,3),(2,5),(3,7)]
20:22:19 <mniip> > M.fromList [(3, 'a'), (2, 'c')]
20:22:21 <lambdabot>  fromList [(2,'c'),(3,'a')]
20:22:46 <ski> but in these cases, you should normally define `showsPrec' and `readsPrec'
20:23:01 <glguy> > read "( ( 1)) " :: Int -- and keep in mind Read instances are expected to handle certain things
20:23:03 <lambdabot>  1
20:23:37 <glguy> (like whitespace and parentheses)
20:24:08 <glguy> :t readParen
20:24:09 <lambdabot> Bool -> ReadS a -> ReadS a
20:24:10 <glguy> :t lex
20:24:11 <lambdabot> ReadS String
20:24:14 <mniip> I thought they are only expected to parse what show produces
20:50:56 <mniip> oooh
20:51:13 <mniip> so the naive recursive implementation of fib
20:51:45 <mniip> has a pessimal simplexity
20:51:58 <mniip> the most pessimal simplexity
20:52:55 <mniip> a multiply and surrender algorithm
20:53:48 <ski> simplexity ?
21:26:00 <POGtastic> hello again. i'm trying problem 26 of 99 Haskell Problems: "Generate the combinations of K distinct objects chosen from the N elements of a list." i thought had an entertaining, if silly, solution, but it's always returning the empty list when I run it. :( code is here: https://pastebin.com/0URyAj8a
21:30:25 <mnoonan_> POGtastic: your recursive case in combinations is not adding anything to the list generated by the recursive call, so you are just working your way down to one of the [] base cases
21:31:44 <POGtastic> ohhhh
21:31:46 <POGtastic> crap
21:31:55 <POGtastic> > map (1:) []
21:31:57 <lambdabot>  []
21:32:03 <mnoonan_> right
21:36:42 <POGtastic> got it. https://pastebin.com/NXVcgGTD
21:36:44 <POGtastic> thanks
21:37:04 <POGtastic> i'm sure that there are far more elegant ways to do it lol
21:38:21 <mnoonan_> I think you‚Äôre over-counting, too: I‚Äôd expect combinations 2 ‚Äúabc‚Äù to give [‚Äúab‚Äù, ‚Äúac‚Äù, ‚Äúbc‚Äù], but Iyou‚Äôll also produce ‚Äúba‚Äù etc
21:38:36 <POGtastic> permutations rather than combinations
21:38:51 <POGtastic> hmmm
21:42:16 <POGtastic> that makes things harder.
21:45:03 <mniip> ayy
21:46:22 <mniip> in retrospect rewriting it in assembly and expecting it to work was a waste of time
21:46:59 <POGtastic> well that was interesting. i guess it works -> https://gist.github.com/mbottini/a7035220ad85f839ec5df415bfab4e20
21:49:27 <mniip> > let combi 0 [] = return []; combi n [] = empty; combi n (x:xs) = ((x:) <$> combi (n - 1) xs) <|> combi n xs in combi 3 "abcd"
21:49:29 <lambdabot>  error:
21:49:29 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòm0‚Äô arising from a use of ‚Äòshow_M574235590877...
21:49:29 <lambdabot>        prevents the constraint ‚Äò(Show (m0 [Char]))‚Äô from being solved.
21:49:41 <mniip> > let combi 0 [] = [[]]; combi n [] = empty; combi n (x:xs) = ((x:) <$> combi (n - 1) xs) <|> combi n xs in combi 3 "abcd"
21:49:42 <lambdabot>  ["abc","abd","acd","bcd"]
21:49:52 <mniip> the most straightforward
21:49:57 <POGtastic> :t <|>
21:49:58 <lambdabot> error: parse error on input ‚Äò<|>‚Äô
21:50:04 <mniip> oh that's just ++
21:50:07 <POGtastic> oh
21:50:14 <mniip> in this context
21:50:28 <mniip> return = (:[]), empty = [], <|> = ++
21:50:34 <mniip> <$> = map
21:50:50 <mnoonan_> POGtastic: instead of using head and tail, you might want to pattern-match on lst, so you last case would start like ‚Äúcombinations n (x:xs) = ‚Ä¶‚Äù
21:51:51 <POGtastic>  gotcha. -> https://gist.github.com/mbottini/a7035220ad85f839ec5df415bfab4e20
21:52:07 <POGtastic> looks slightly nicer, albeit not as nice as mniip's functors.
21:52:27 <mniip> combinations 0 _ = []
21:52:29 <mniip> that is wrong
21:52:41 <mniip> you have a misplaced base case
21:52:43 <POGtastic> only one way to get 0 of something, right?
21:52:47 <mniip> which is why you had to specialcase 1 I guess
21:52:54 <mniip> exactly
21:52:57 <mniip> and you're returning 0 ways
21:53:54 <mniip> I rather intentionally used Alternative up there so as not to confuse the meanings of the two instances of the [] functor
21:54:19 <suzu> > replicateM 2 "hey"
21:54:21 <lambdabot>  ["hh","he","hy","eh","ee","ey","yh","ye","yy"]
21:54:31 <mniip> not exactly what was asked
21:54:55 <suzu> yeah thats not the same
21:55:00 <mniip> hmm, monoid transformers on my mind again
21:55:03 <mniip> combi could be a fold
21:55:13 <suzu> y'all abstraction astronauts up in here
21:55:20 <mniip> welcome to #haskell
21:55:23 <suzu> ;)
21:55:40 <suzu> i built a complete EDSL for scripting some things at work
21:55:53 <suzu> we recently threw the whole thing away and moved to running embedded javascript inside haskell
21:56:18 <suzu> sounds backwards but i think it's actually a win for my team
21:56:46 <suzu> they can write all their scripts in any js-language they're comfortable with, that can compile down to pure ES5 (no browser dom, no network api, etc)
21:57:12 <suzu> having an EDSL was cool but making mistakes led to GHC errors that weren't helpful at all for them
21:57:15 <wagle> i *think* I've ripped cabal/ghc/haskell-platform completely off my system, but when I reinstall, cabal seems to remember the (bogus) previous installed packages..  where's it keeping this info?
21:57:48 <POGtastic> map (1:) [[]]
21:57:57 <POGtastic> > map (1:) [[]]
21:57:59 <lambdabot>  [[1]]
21:58:35 <POGtastic> gotcha, thanks mniip.
21:58:58 <POGtastic> so we can get rid of the combinations 1 lst = map (\x -> [x]) nastiness
22:13:22 <mniip> curious little expr
22:13:22 <jle`> i found my new favorite way to Maybe a -> MaybeT m a
22:13:23 <mniip> > zip [0..] <$> reverse <$> inits [0..]
22:13:25 <lambdabot>  [[],[(0,0)],[(0,1),(1,0)],[(0,2),(1,1),(2,0)],[(0,3),(1,2),(2,1),(3,0)],[(0,...
22:13:31 <jle`> Just x <- return maybVal
22:20:45 <mniip> @let newtype Share m = Share { getShare :: [[m]] } deriving Show
22:20:46 <lambdabot>  Defined.
22:20:53 <mniip> @let instance Monoid m => Monoid (Share m) where mempty = Share $ [mempty]:repeat []; mappend (Share x) (Share y) = Share $ join <$> zipWith (liftA2 mappend) x <$> reverse <$> tail (inits y)
22:20:54 <lambdabot>  Defined.
22:21:32 <mniip> @let combis = getShare . foldMap (\x -> Share $ [empty]:[pure x]:repeat [])
22:21:33 <lambdabot>  Defined.
22:22:04 <mniip> > combis "abc" !! 2 :: [String]
22:22:06 <lambdabot>  ["bc","ac","ab"]
22:22:15 <POGtastic> :O
22:22:36 <mniip> > combis [2, 5, 4] !! 2 :: [Sum Int]
22:22:37 <lambdabot>  error:
22:22:37 <lambdabot>      ‚Ä¢ No instance for (Alternative Sum) arising from a use of ‚Äòcombis‚Äô
22:22:37 <lambdabot>      ‚Ä¢ In the first argument of ‚Äò(!!)‚Äô, namely ‚Äòcombis [2, 5, 4]‚Äô
22:22:44 <mniip> dammit
22:22:49 <mniip> hmm
22:23:22 <mniip> @let combis = getShare . foldMap (\x -> Share $ [empty]:[pure x]:repeat [])
22:23:23 <lambdabot>  .L.hs:170:1: error:
22:23:23 <lambdabot>      Multiple declarations of ‚Äòcombis‚Äô
22:23:23 <lambdabot>      Declared at: .L.hs:167:1
22:23:24 <mniip> oops
22:23:42 <mniip> @let combis' f = getShare . foldMap (\x -> Share $ [mempty]:[f x]:repeat [])
22:23:44 <lambdabot>  Defined.
22:23:46 <mniip> :t combis'
22:23:48 <lambdabot> (Foldable t1, Monoid m) => (t2 -> m) -> t1 t2 -> [[m]]
22:24:02 <mniip> > combis' Sum [2, 5, 4] !! 2
22:24:04 <lambdabot>  [Sum {getSum = 9},Sum {getSum = 6},Sum {getSum = 7}]
22:24:30 <mniip> > combis' (:[]) "abcd" !! 3
22:24:32 <lambdabot>  ["bcd","acd","abd","abc"]
22:24:45 <mniip> monoid transformers I'm telling ya
22:25:09 <POGtastic> i feel like a programming noob all over again
22:25:36 <mniip> welcome to #haskell
22:25:39 <POGtastic> lol
22:26:02 <mniip> the mistake is beleiving you know enough, in first place
22:26:10 <POGtastic> true
22:33:22 <ongy> can I have the body of a case of match be a guard pattern?
22:36:20 <mniip> ongy, yes
22:36:29 <mniip> > case () of () | False -> ()
22:36:31 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
22:45:05 <mylene18> hello
22:55:00 * hackage ats-format 0.1.0.5 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.5 (vmchale)
22:56:09 <mniip> glguy, so uh
22:56:14 <mniip> what should even be the source for part 2
23:21:43 <kakashiAL> I try to implement and learn FP ideas of haskell in javascript
23:22:05 <kakashiAL> now I found an implementation of a functor in javascript:
23:22:14 <kakashiAL> https://paste.xinu.at/kxn7c/js
23:22:31 <kakashiAL> but in my opinion it is NOT a functor
23:23:24 <kakashiAL> the reason why I think so is because a functor has container of 0, 1 or many items
23:24:02 <kakashiAL> the map (fmap) function applies a function to each element of that container
23:25:15 <kakashiAL> with other words, if you have an array, object or some other datastructure that is able to contain more than one value, and use fmap in it, it sould be able to apply the function for each element
23:25:47 <kakashiAL> my question is why is Box() https://paste.xinu.at/kxn7c/js still a functor?
23:26:12 <kakashiAL> I mean Brian Lonsdorf (a very smart guy) said that and I dont know why its true in this case
23:32:12 <geekosaur> "functor" gets used in a lot of ways (ML's functors are completely different, for example). That smells more like what Haskell calls Foldable and Traversable.
23:37:23 <kakashiAL> geekosaur: so with other words there are many definitions of functors?
23:38:00 <kakashiAL> geekosaur: and there is a definition that says that Box is a functor?
23:38:09 <zaquest> kakashiAL, i think you're taking the mataphor `functor is a container` too far. like in `Maybe (Map String Int)` `Maybe` is still a `Functor`. in your example your just need to substitute a function that takes `{a: 42, b: 'ABC', c: 'x'}` and returns something.
23:38:30 <geekosaur> we use the mathematical one. C++ uses one that is iirc more like that JS snippet
23:38:55 <geekosaur> SML uses it to mean a parameterized module
23:39:12 <kakashiAL> geekosaur: the one that I show you in the snippet is not a mathematical functor, correct?
23:39:32 <geekosaur> looked a bit odd for one given that it has map, fold, etc. in it
23:39:43 <geekosaur> which is why I said Foldable/Traversable
23:40:01 <geekosaur> Functor wants a map function of some kind, but the rest seems out of place
23:40:12 <geekosaur> (Haskell style Functor, that is)
23:40:26 <kakashiAL> geekosaur: neglect these methods, if you like see it as a functor with extra stuff :)
23:40:50 <kakashiAL> geekosaur: but again, do you agree that this is NOT a functor in mathemical terms?
23:40:54 <ski> @where on-functors
23:40:54 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
23:42:45 <kakashiAL> geekosaur: so?:)
23:43:06 <isd> The derivation of the name "Functor" for the haskell concept works fine in the context of a category-theoretic formalization of Haskell's type system, but you have to go pretty far off in the weeds to see what's going on there.
23:43:38 <geekosaur> sigh,. right, let me pull it up again
23:44:52 <geekosaur> also ":)" does not make "do my bidding, mortal" ok
23:45:17 <isd> Haskell "Functors" are category theoretic (endo)functors on the category Hask.
23:45:42 <isd> But you have to go pretty far off into the weeds to understand all that; I really wish we would just pick names like "Mappable"
23:47:49 <jle`> but 'Mappable' is not a good name for Functors
23:48:11 <geekosaur> this really is just "mappable". Functor has afdditional constraints, and those constraints are fairly important
23:48:21 <isd> It's a good name for something with a "map" operator.
23:48:26 <zaquest> kakashiAL, i think you can call it a functor. functor requires `map` and 2 laws `map id = id` & `map (g . f) = map g . map f`. they're both satisfied as far as i can tell. given that you actually pass functions (no effects) to `map`, and not random js procedures.
23:48:28 <jle`> since it already has connotations/baggage from natural language and other CS usages that would cause more harm than good
23:48:41 <jle`> the word 'Mappable', that is
23:49:14 <geekosaur> because Mappable is not sufficient to make Applicative. there are constraints on what a Functor is allowed to do, and those constraints make it possible to build more complex mechanisms (like Applicative and Monad... and lens, for that matter)
23:49:16 <kakashiAL> geekosaur: still wait for your opinion about Box
23:49:27 <geekosaur> yes, I noted
23:49:34 <geekosaur> how long am I to remain leashed?
23:49:41 <mniip> clearly Box is a Traversable
23:52:26 <jle`> kakashiAL: are you saying that 'map' should apply to all items in  the array that Box is given?
23:52:38 <isd> As far as functors are concerned, box is just: http://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Functor-Identity.html
23:53:02 <jle`> > fmap (++ [4,5,6]) (Idenity [1,2,3])
23:53:04 <Wizek> hello
23:53:04 <lambdabot>  error:
23:53:05 <lambdabot>      ‚Ä¢ Data constructor not in scope: Idenity :: [Integer] -> f [a]
23:53:05 <lambdabot>      ‚Ä¢ Perhaps you meant ‚ÄòIdentity‚Äô (imported from Control.Monad.Identity)
23:53:10 <jle`> > fmap (++ [4,5,6]) (Identity [1,2,3])
23:53:12 <lambdabot>  Identity [1,2,3,4,5,6]
23:53:16 <kakashiAL> jle`: yes sir, this is how I understand functors
23:53:24 <jle`> kakashiAL: do you see up there, with Identity?
23:53:35 <jle`> do you think fmap should map over every item in that list?
23:53:47 <jle`> > fmap (++ [4,5,6]) (Just [1,2,3])
23:53:50 <lambdabot>  Just [1,2,3,4,5,6]
23:53:56 <jle`> kakashiAL: if i did fmap (*2) (Just [1,2,3]), what do you think should happen?
23:54:24 <Wizek> I'm getting some HTTP errors while trying to build a stack project: https://gist.github.com/Wizek/443417f33a2bdab36c4b4f6f692dd18d
23:54:36 <Wizek> is there an issue with stackage perhaps?
23:55:32 <jle`> kakashiAL: *if* some type 'Maybe a' contained any 'a's, then fmap would resonably have to mape the function over all the a's
23:55:56 <jle`> kakashiAL: so if you have Maybe [Int], fmap would take an [Int] -> ..., not an Int -> ...
23:56:00 <kakashiAL> jle`: give me a moment to digest
23:56:29 <jle`> a 'Maybe [Int]' might contain a bunch of Int's, but fmap maps an ([Int] -> ...) function over that, not an (Int -> ...)
23:56:43 <isd> Wizek: I'm able to fetch some of those files it's complaining about. But that definitely looks like a networking problem.
23:58:04 <kakashiAL> jle`: let me just repat that to hold it: if you have a functor, where you map a function on it, it does not mean that this function have to apply to each elements of the value that the functor holds, correct?
23:58:50 <jle`> yeah, consider something like the Const functor
23:58:53 <jle`> > map (*2) (Const 10)
23:58:55 <lambdabot>  error:
23:58:55 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[b]‚Äô
23:58:55 <lambdabot>                    with actual type ‚ÄòConst Integer b0‚Äô
23:59:01 <jle`> > fmap (*2) (Const 10)
23:59:03 <lambdabot>  Const 10
23:59:16 <jle`> one of my favorite functors
23:59:29 <kakashiAL> jle`: thanks for clearyfication, because I did read that in some blogs
23:59:33 <jle`> Const contains an Int, and fmap maps a function on Int's
23:59:35 <isd> kakashiAL: that's correct.
23:59:37 <jle`> but it doesn't map over the Int
23:59:40 <kakashiAL> and articles and a lot of threads
23:59:48 <mniip> hmm
23:59:56 <mniip> I wonder how to elegantly do this in haskell
