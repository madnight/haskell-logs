00:19:16 <jle`> glguy: https://www.reddit.com/r/adventofcode/comments/7icnff/2017_day_8_solutions/dqxtsqy/
00:19:32 <jle`> glguy: someone just sed'd their file and it was interpretable as ruby code
00:29:54 <olligobber> showing a ByteString adds quotes around it
00:30:00 <olligobber> I spent ages debugging to discover this
00:31:39 <jle`> hi all
00:31:45 <jle`> can we get a paramorphism into Data.Tree
00:31:48 <jle`> thank you
00:31:50 <jle`> :)
00:31:56 <jle`> (thank you for listening, that is)
00:32:11 <jle`> now to figure out how to contribute to the standard libraries
01:09:56 <ertes-w> jle`: para :: (F (Fix F, a) -> a) -> Fix F -> a
01:10:14 <ertes-w> jle`: you can get a paramorphism for every ADT
01:11:43 <ertes-w> for a binary tree, where the values are at the leaves:
01:11:57 <ertes-w> btreePara :: (Tree a -> r -> r -> r) -> (a -> r) -> Tree a -> r
01:13:51 <jle`> ertes-w: i mean, can we get it into the Data.Tree module of 'containers'
01:14:24 <ertes-w> ah
01:14:30 <jle`> we could re-write it ourselves every time we need it
01:16:02 <ertes-w> jle`: i suppose you could contribute one
01:16:27 <jle`> i wonder what the process would be
01:16:43 <jle`> i think it'd fit into the module because they already have ana- and catamorphisms
01:16:46 <ertes-w> just a github PR
01:17:07 <ertes-w> contributing to containers is easy
01:17:20 <jle`> oh huh, i didn't realize it was just a normal github repo
01:20:35 <ertes-w> what else would it be?  all developer interaction is supposed to go through github, slack and stackoverflow, isn't it?
01:20:52 * hackage mmark-ext 0.0.1.1 - Commonly useful extensions for MMark markdown processor  https://hackage.haskell.org/package/mmark-ext-0.0.1.1 (mrkkrp)
01:40:09 <jle`> ertes-w: :p
02:10:14 <frerich> jle`: Hiya, are you mstksg on reddit? Your AoC solutions are awesome, much prettier than mine (https://github.com/frerich/aoc2017)! I like how you don't code golf things but yet the programs are very concise.
02:10:34 <jle`> frerich: yes that is me!  and thanks! :)
02:11:07 <frerich> jle`: Even when I'm kinda proud of my stuff, your programs make me go "Oh, yeah, right, I could have done that..." :-}
02:11:13 <jle`> feel free to add your repo to the https://github.com/topics/advent-of-code-2017 topic!
02:11:18 <jle`> so we can get some haskell representation :3
02:11:32 <pja> oo. Do you have a nice day7 solution? Mine is /godawful/ & it would be nice to see a better one :)
02:12:05 <jle`> frerich: i feel the same way reading a lot of other solutions too -- it's nice how knowledge gets shared around the community this way
02:12:16 * frerich nods
02:12:49 <pja> Today’s problem really demonstrated that I need to get off my backside and learn to use the State Monad without fear.
02:13:12 <merijn> pja: Best way to understand the State monad is implement it yourself
02:13:19 <jle`> pja: fsvo nice :) https://github.com/mstksg/advent-of-code-2017/blob/master/reflections.md#day-7
02:13:31 <merijn> pja: https://gist.github.com/merijn/098106abd45c940dab09
02:13:51 <frerich> jle`: Euhm, I must admit - it's not clear to me how to add anything to that 'topic' (this is the first time I hear about GitHub topics though). :-]
02:13:53 <jle`> pja: today's didn't really require State, although i can see how i might have been used if you tried
02:13:56 <merijn> pja: Because I recommend reimplementing State/StateT from scratch so often, I already wrote out the assignment for you ;)
02:13:59 <pja> I'm usually lazy and end up threading one piece of state through the functions and end up decorating every function I’ve written with new bits of state because each incremental change doesn’t seem worth transforming the whole thing
02:13:59 <cocreature> pja: you really don’t need State for today’s problem. foldl' is all you need
02:14:10 <jle`> frerich: topics are basically github's tags
02:14:39 <jle`> on your repo's home page you can find a link near the repo description saying "manage topics"
02:14:51 <frerich> cocreature: Today is day 8 though :-)
02:15:00 <cocreature> frerich: oh :)
02:15:02 <pja> For today’s I shoved all the names in a map.
02:15:19 <frerich> cocreature: Oh, sorry - I think I mixed things up. pja first asked about day 7, and then mentioned the State monad for today's problems. Nevermind...
02:15:36 <pja> merjin: nice :)
02:16:05 <jle`> State is probably slightly linked to part 2 because 'traverse' for State is scanl
02:16:18 <jle`> or mapAccumL
02:16:22 <frerich> jle`: A-ha! Got it, thanks. :-)
02:16:24 <pja> I failed to come up with the right representation for day 7 that would let me use a simple fold. Should have thought more before coding...
02:16:47 <jle`> so if you used scanl/mapAccumL, you probably "could" have done it with traverse+State
02:16:56 <jle`> but directly using scanl can be simpler
02:17:29 <pja> jle`: thanks for the link. Always something to learn...
02:17:57 <merijn> So, suppose I have a set (list, some traversable, whatever) of Int and I wanna update them so that they're all in the domain 0-N where N is the number of unique values. What's the fastest way to go? Fold an IntMap mapping old indices to new ones over the entire thing?
02:18:37 <[exa]> merijn: what is the size of original domain?
02:19:02 <merijn> [exa]: Number of unique keys is rather small, several tens at most, but I need to update several 10s or 100s of thousands of them
02:19:35 <[exa]> the question is whether it's better to store the resulting counts in array or in map
02:20:04 <[exa]> if the values are like "all lower than 1000", go with an array, otherwise folding into standard Map is just right
02:20:46 <merijn> hmmm, that's probably a better idea
02:21:02 <merijn> ah, no, I realise the problem with that
02:21:25 <merijn> [exa]: Using an array would require me to precompute the mapping
02:21:55 <merijn> [exa]: With a Map I can just insert a new mapping when I encounter a missing key
02:22:14 <pja> Use an unboxed mutable vector and compute the mapping as you go? If your ints are all small that’s probably the fastest way to go.
02:22:24 <[exa]> maybe I've read your question wrong, I supposed you wanted something like sum(distinct i), you want to compress the domain
02:22:30 <merijn> pja: How would you detect which keys are missing in the vector?
02:22:33 <[exa]> s/compress/renumber/
02:22:50 <cocreature> merijn: just set it to -1 or whatever
02:23:02 <[exa]> merijn: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-IntSet.html
02:23:05 <pja> merjin: you’d need a sentinel value in that case.
02:23:20 <merijn> [exa]: Yes, I have an original domain 0-M of which some cases might not occur and want to remap it to the domain 0-N, so that the entire domain is used
02:23:36 <merijn> Such that N <= M
02:24:00 <[exa]> ok, then a set is sufficient
02:24:09 <merijn> [exa]: Is it? How so?
02:24:25 <merijn> How would you know what to change each value to?
02:25:03 <[exa]> oh you want to do that on the fly?
02:25:26 <merijn> [exa]: Well, why traverse the entire thing twice if you don't have to?
02:26:07 <[exa]> no idea, sorry. :] it's a little bit too much morning here
02:29:36 <ertes-w> there is no default.nix anymore in nixpkgs/pkgs
02:29:40 <ertes-w> is there a new convention?
02:29:48 <pja> For day 7, I spent far too much time building an attoparsec parser. That turned out to be no fun at all.
02:30:38 <merijn> pja: How come?
02:31:36 <pja> merijn: I had a lot of trouble with the parser going _|_ on me because of skipSpace’s in the wrong places. Probably not helped by trying to parse the whole file instead of doing it a line at a time.
02:32:11 <cocreature> pja: the trick is to first write the parser for a single line and then just wrap it using many, space and eof
02:32:12 <merijn> pja: First rule of parsing is: Write the grammar down first. Second rule of parsing is, start building the leaf parsers and build up ;)
02:33:57 <pja> Did that :) I was learning everything from scratch, so it was probably harder than it would otherwise have been. 
02:34:13 <ertes-w> merijn: at 100s of values just 'traverse' with a (State (Map k Int)) =)
02:34:27 <pja> Also, I started using Attoparsec.ByteString & then discovered that all the useful utility functions were only defined if you were using Attoparsec.Text
02:34:34 <pja> this was /not/ helpful.
02:34:55 <ertes-w> merijn: alternatively construct the mapping at the same time you construct the original data structure
02:35:14 <ertes-w> merijn: then all you need at the end is fmap
02:35:28 <ertes-w> if at all
02:35:38 <merijn> ertes-w: I can't, the original data structure is coming from Python code
02:36:05 <ertes-w> whoops…  my question from earlier was in the wrong channel =)
02:36:51 <ertes-w> merijn: so you're parsing it?
02:37:10 <merijn> ertes-w: This was all I could do to eliminate a whole bunch of other shitty python code, but I don't have time to implement a machine learning library from scratch in Haskell :)
02:37:26 <merijn> ertes-w: For appropriately minimalist implementations of parsing...
02:37:46 <ertes-w> merijn: you could do it while parsing
02:37:52 <merijn> ertes-w: I'm getting a ByteString that I'm converting into a Storable Vector based on my knowledge of the byte layout
02:38:06 <merijn> ertes-w: So, no, there's no real parsing step
02:43:31 <ertes-w> ah
02:44:04 <merijn> Completely unrelatedly...I wish that Vector had indexing function that worked with types other than Int...
02:44:13 <merijn> Converting everything to/from Int all the time is painful :\
02:44:38 * hackage strelka 2.0.2 - A simple, flexible and composable web-router  https://hackage.haskell.org/package/strelka-2.0.2 (NikitaVolkov)
02:44:41 <cocreature> merijn: I’ve just defined by own wrappers and imported the ones from Vector qualified the few times I’ve needed that
02:45:53 <merijn> cocreature: You mean wrappers that do the conversion for you?
02:46:00 <cocreature> yeah
02:46:07 <merijn> cocreature: Then you still pay the price
02:46:28 <cocreature> right but usually the number of indexing functions that I use is quite small so it’s not too bad
02:46:43 <merijn> cocreature: Yeah...I'm indexing in a tight loop
02:46:53 * hackage haskell-holes-th 0.0.0.1 - Infer haskell code by given type.  https://hackage.haskell.org/package/haskell-holes-th-0.0.0.1 (klntsky)
02:47:04 <merijn> cocreature: And my input data is Int32
02:47:05 <cocreature> merijn: ah you mean the costs of the conversion not the costs of having to write the code?
02:47:10 <merijn> cocreature: Yes
02:47:16 <cocreature> ah ok, don’t have a solution for that :/
02:48:00 <ertes-w> merijn: https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Ix.html
02:48:25 <merijn> ertes-w: How does that help?
02:51:20 <ertes-w> merijn: i don't know what functionality exactly you're missing, but Ix can convert ranges as well as compute multi-dimensional positions
02:51:42 <cocreature> that doesn’t help with converting from Int32 to Int
02:52:12 <merijn> ertes-w: The issue is "Vector only allows indexing with Int, so I eat the conversion cost from Int32 to Int at every index in my inner loop"
02:52:38 <merijn> ertes-w: Vector doesn't allow indexing with Ix, afaict and Ix would anyway only add more code/conversion stuff
03:01:45 <ertes-w> merijn: i see…  well, one option is to avoid the Int32 in the first place
03:02:08 <ertes-w> merijn: however, the conversion should be anywhere from hardly noticable to free
03:02:11 <ertes-w> at least on x86
03:02:14 <merijn> ertes-w: Probably not an option either way
03:02:30 <merijn> Int being 64bit consumes too much cache
03:03:02 <ertes-w> merijn: yeah…  i'd say don't worry about it…  the conversion is probably free anyway, either optimised away by GHC or by your CPU
03:03:48 <merijn> ertes-w: I find it hard to reason about to what extend GHC manages to optimise these conversions away
03:04:58 <ertes-w> merijn: you could check out the generated assembly code and perhaps rewrite it to use Int32 indexing into the array and see if it makes a difference
03:05:15 <merijn> ertes-w: Yeah, but isolating a small piece of ASM is also hard with GHC :)
03:05:21 <merijn> We need a GHC godbolt :p
03:05:40 <ertes-w> add a call to something you can grep for
03:06:47 <cocreature> merijn: i.e. https://haskell.godbolt.org/
03:07:06 <merijn> cocreature: Wow...how'd I miss that? :o
03:07:08 <ertes-w> merijn: for example add a small C file with an empty function and foreign-call it…  the name will be preserved, so you can grep for it
03:07:28 <cocreature> merijn: it’s relatively new (I’d guess two months or so but I’m too lazy to look it up)
03:11:22 * hackage privileged-concurrency 0.7.0 - Provides privilege separated versions of the concurrency primitives.  https://hackage.haskell.org/package/privileged-concurrency-0.7.0 (OmerAgacan)
03:21:41 <mniip> people who have nothing to do with their lives of #haskell,
03:21:50 <mniip> what's the most golfed brainfuck interpreter you've seen/written
03:22:20 <mniip> mine's 385 chars
03:24:03 <liste> mniip: https://codegolf.stackexchange.com/a/933/7216
03:24:16 <liste> unless you want Haskell specifically
03:24:17 <mniip> in haskell, duh
03:27:45 <mniip> ooohhmmm
03:28:40 <liste> there's a 413 char Haskell implementation there ↑
03:28:47 <mniip> mine's 372 now
03:28:59 <mniip> 371 (terminating nl)
03:41:23 * hackage relational-record-examples 0.5.0.0 - Examples of Haskell Relationa Record  https://hackage.haskell.org/package/relational-record-examples-0.5.0.0 (KeiHibino)
03:43:51 <Gurkenglas> When I see an operator I don't know in a source file on hackage, how do I find its definition?
03:45:22 <Gurkenglas> The index link on the library's main page doesn't list the operator under its first letter, is there an index that also indexes all dependencies, or even all of hackage?
03:47:05 <fakenullie> use hoogle?
03:48:07 <pja>  Search google for "operator name haskell"
03:48:31 <fakenullie> @hoogle (>=>)
03:48:31 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
03:48:31 <lambdabot> Text.XML.Cursor (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:48:31 <lambdabot> Text.XML.Cursor.Generic (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
03:48:32 <pja> Find the type with ghci?
03:59:59 <frerich> liste: That may be cool, but not https://github.com/canoon/bfbf/blob/master/bf.bf cool.
04:01:14 <Psybur> Hey liste, youre from java. >:D
04:01:40 <liste> someone in #java-talk said I was from #haskell
04:01:52 <Psybur> Yes thats what I am referencing ;p
04:06:10 <mniip> what package generates these shiny docs? https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Control.Monad.html
04:06:31 <Gurkenglas> Google doesn't index special characters, but hayoo does :)
04:06:41 <liste> mniip: you mean the source listings?
04:06:44 <mniip> yes
04:06:55 <mniip> looks like the one before the yellowish background was hscolor
04:07:01 <mniip> but they use something different now?
04:09:21 <mniip> oh it's haddock itself
04:09:31 <mniip> --haddock-options=--hyperlinked-source
04:12:21 <mniip> looks like it has a few bugs
04:13:57 <ertes-w> apropos golf…
04:14:32 <ertes-w> :t []!!0:[1<0,..]
04:14:33 <lambdabot> error: parse error on input ‘..’
04:14:37 <ertes-w> :t []!!0:[1<0..]
04:14:38 <lambdabot> [Bool]
04:14:47 <ertes-w> a list of all three Bools =)
04:15:28 <ertes-w> > (length ([]!!0:[1<0..]), reverse ([]!!0:[1<0..]))
04:15:30 <lambdabot>  (3,[True,False,*Exception: Prelude.!!: index too large
04:15:39 <wz1000> what are the performance characteristics of pure State vs IORef?
04:15:50 <pja> yeah. ghci doesn’t like that either.
04:16:09 <quchen> Anyone got the size of a GHC thread handy?
04:16:12 <ertes-w> wz1000: pure, strict State can be faster then IORef, because IORef is non-strict in the current value
04:16:18 <ertes-w> *than
04:16:19 <quchen> Anything more specific than »couple of hundred bytes« :-)
04:16:36 <ertes-w> wz1000: the fastest option is explicit recursion right now
04:17:22 <hs_newb> Hello, can i get some help in eliminating the duplication between part1 and part2 ? https://gist.github.com/anonymous/9f3fb972f8b0bc80123bdd5c9b4d1242
04:18:10 <ertes-w> wz1000: that's for small state…  if you can encode your solution as an array algorithm, then a mutable array will likely be the fastest option
04:18:32 <pja> according to stackoverflow, threadDelay is lazy & accumulates thunks so watch out for that...
04:19:16 <mniip> ertes-w, I came up with ($1>0)<$>[id,not,succ]
04:19:19 <mniip> not shorter though
04:20:04 <wz1000> and what about TVar vs MVar vs IORef when it comes to performance?
04:21:00 <Gurkenglas> If someone wants to invest work in lens errors getting better, there's a low-hanging fruit. https://github.com/aelve/haskell-issues/issues/58
04:21:24 <mniip> without reading: is this about readability of typechecker errors?
04:21:30 <Gurkenglas> yes
04:22:31 <quchen> > iterate succ$0>1 -- ertes-w mniip 
04:22:33 <lambdabot>  [False,True,*Exception: Prelude.Enum.Bool.succ: bad argument
04:22:50 <mniip> quchen, your list is too long
04:23:16 <quchen> :-C
04:23:38 <quchen> But it *is* a list of all three Bools.
04:23:40 <mniip> > null . drop 3 $ iterate succ$0>1
04:23:42 <lambdabot>  False
04:23:51 <mniip> well, maybe if you could nub it oh wait
04:24:48 <merijn> wz1000: "It Depends" there is no simple comparison between those two
04:25:13 <quchen> > [1<0,0>1,fix id] -- mniip :-þ
04:25:16 <lambdabot>  [False,False,*Exception: <<loop>>
04:25:36 <mniip> ertes-w's shorter
04:25:46 <mniip> []!!0 is shorter than fix id
04:25:54 <quchen> Oh.
04:25:59 <mniip> and .. is shorter than
04:26:43 <merijn> > [(1<0)..]
04:26:44 <testing123> @pl \g -> f g g
04:26:44 <lambdabot> join f
04:26:45 <lambdabot>  [False,True]
04:26:49 <merijn> hmm
04:27:20 <quchen> What’s ertes’ solution?
04:27:26 <mniip> []!!0:[1<0..]
04:27:57 <testing123> @pl \g -> f g >> h g
04:27:57 <lambdabot> liftM2 (>>) f h
04:27:59 <quchen> Hard to print ;-)
04:28:42 <mniip> hmm
04:28:52 <ertes-w> xs is a solution, iff length xs = 3 and it contains exactly one False and one True
04:29:24 <mniip> iterate f x
04:29:24 <mniip> fix$(x:).map f
04:29:27 <mniip> nope
04:30:59 <quchen> loeb[const$1<0,not.head,(!!2)]
04:31:04 <quchen> Loeb version of it ;-)
04:31:48 <quchen> ?let loeb x = go where go = fmap ($ go) x
04:31:50 <lambdabot>  Defined.
04:31:54 <quchen> > loeb[const$1<0,not.head,(!!2)]
04:31:57 <lambdabot>  [False,True,*Exception: <<loop>>
04:40:01 <merijn> I forgot again...is there an efficient Double -> Text and Int -> Text method?
04:41:18 <quchen> T.pack . show -- O(1) to type in
04:41:27 <ertes-w> merijn: Text.Show should be efficient enough, if you go directly to Text
04:41:48 <cocreature> merijn: https://hackage.haskell.org/package/double-conversion-2.0.2.0/docs/Data-Double-Conversion-Text.html at least claims to be efficient
04:41:53 * hackage hpqtypes-extras 1.5.0.0 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.5.0.0 (MikhailGlushenkov)
04:42:35 <ertes-w> merijn: otherwise: https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text-Lazy-Builder-RealFloat.html
04:42:39 <merijn> ertes-w: Where's that defined?
04:42:58 <ertes-w> err, not Text.Show
04:43:00 <ertes-w> Numeric
04:43:09 <ertes-w> merijn: anyway, see above…  text comes with renderers
04:43:36 <ertes-w> Data.Text.Lazy.Builder.RealFloat has formatRealFloat
04:43:55 <ertes-w> and there is also .Int for integers
04:44:00 <merijn> ertes-w: I'm immediately writing to a file, so not sure whether it's best to do builder for lazy Text or just try to immediately write them to file
04:44:28 <ertes-w> merijn: shouldn't make much of a difference
04:44:50 <ertes-w> merijn: but honestly Numeric might be both your fastest and most convenient option
04:45:02 <mniip> > loeb[head,\_->1<0,\_->1>0]
04:45:05 <lambdabot>  [*Exception: <<loop>>
04:45:11 <ertes-w> :t loeb
04:45:13 <lambdabot> Functor f => f (f b -> b) -> f b
04:45:39 <merijn> ertes-w: What makes you say that?
04:46:33 <quchen> ertes-w: https://github.com/quchen/articles/blob/master/loeb-moeb.md
04:46:52 <ertes-w> merijn: String is fine, if you never force it into memory
04:46:57 <Athas> Is there a good library for algebraic simplification?
04:47:11 <Athas> (On machine integers and floats, not mathematical numbers.)
04:47:36 <ertes-w> quchen: thanks
04:47:59 <fakenullie> Athas: like Ratio?
04:48:24 <Athas> fakenullie: is that a library?
04:48:34 <fakenullie> Athas: that's a type
04:48:52 <fakenullie> I don't know what you mean by simplification though
04:49:18 <Athas> Algebraic simplification, like recognising that the expression 'x>0 || x <= 0' is always true.
04:49:23 <Athas> (For a symbolic 'x'.)
04:49:40 <fakenullie> this looks like mathematical numbers
04:50:00 <Athas> No, because for example 'x + 1 > x' is not necessarily true, due to overflow.
04:50:16 <Athas> I suppose I need an SMT solver.
04:50:39 <fakenullie> oh
04:50:51 <cocreature> Athas: it’s also wrong for floats :)
04:51:19 <Younder> The library is the GNU Muli-Precision Library. It handles arbitrary precision integer and floating point. And practically all Math related software uses it (mathlab, maple, mathematica)
04:51:41 <Athas> Younder: they don't do symbolic computation, do they?
04:51:55 <Younder> Athas, No 
04:52:28 <Athas> I already have a hacked-together algebraic simplifier of my own (1400 LOC), but it's fairly slow and limited.  I only need it so I can optimise away bounds checks in my compiler.
04:52:41 <Athas> Would be nice if someone already had a nice solution for this.
04:52:45 <Athas> Maybe I'll have to write one.
04:54:11 <merijn> ertes-w: THis code is interspersed with a bunch of code using Text, though so I find mixing those two undesirable
04:55:26 <Younder> Athas, I use Mathematica  no, but there are opensouce algebra parsers which are ok, I used to use macsyma. You might get some ideas from the Lisp code.
04:56:28 <Younder> s/parsers/solvers
04:56:41 <ertes-w> merijn: then go with the builders
04:56:56 <ertes-w> merijn: ideally you use a builder for the whole content
04:57:55 <ertes-w> merijn: note that there is nothing wrong with interleaving hPutStr and T.hPutStr
04:58:53 <merijn> ertes-w: I just realised that just going via a lazy Text might be the nicest/simplest implementation
04:59:18 <ertes-w> merijn: yes…  Builder is basically a version of lazy Text that has O(1) append
04:59:42 <ertes-w> if your appends are right-associated anyway, you can just as well use lazy Text
04:59:50 <ertes-w> however, one thing Builder does for you is chunking
05:00:53 <ertes-w> merijn: BTW, we're talking about speed differences that are hardly measurable…  just do what is most convenient
05:01:04 <Franciman> Hi, I'm using wreq to make a post request and I don't want to follow redirects. How can I do this?
05:01:17 <Franciman> I just want the response
05:01:45 <ertes-w> Franciman: if you don't have any sessions to keep track of, just use http-conduit directly and tell it not to follow redirects
05:02:02 <Franciman> I need the session, alas
05:02:09 <Franciman> I'm making various requests
05:04:10 <ertes-w> Franciman: it's only a session, if you need cookie tracking
05:04:27 <francesco_> ertes-w, sorry I think I missed some messages
05:06:53 <Franciman> ertes-w, so you're suggesting to use http-conduit?
05:07:41 <ertes-w> Franciman: it's only a session, if you need cookie tracking
05:08:06 <Franciman> yes only one session
05:09:08 <Franciman> thank you
05:10:10 <ertes-w> Franciman: well, first specify what you mean by not following redirects
05:10:22 <ertes-w> should redirects be an error, or do you want to get the actual 3xx response?
05:10:39 <Franciman> I want to get the actual 3xx response
05:10:47 <Franciman> I just need the cookies
05:10:51 <ertes-w> wreq doesn't seem to support that
05:11:52 <ertes-w> i think you'll need http-conduit and write the cookie management yourself
05:12:05 <ertes-w> alternatively patch wreq to support it
05:12:39 <Franciman> perfect. Thank you for the help
05:14:25 <merijn> Is hackage slow for anyone else?
05:14:52 * hackage monad-var 0.1.2.0 - Generic operations over variables  https://hackage.haskell.org/package/monad-var-0.1.2.0 (effectfully)
05:15:33 <ertes-w> merijn: it's fast here
05:17:40 <ertes-w> merijn: i think hackage is on a CDN these days…  perhaps just clear your DNS cache and see if that takes you to a faster server
05:18:31 <lseactuary> anyone here good at proof trees? ive made one but stuck on one step.
05:18:51 <merijn> ertes-w: CDN is disabled, has been for a while since people where having caching issue
05:19:38 <ertes-w> merijn: i'm still seeing multiple IP addresses for hackage.haskell.org though
05:19:56 <merijn> maybe they re-enabled it when I wasn't paying attention
05:20:16 <dminuoso> ertes-w: So you said to think about monad transformers as creating new monads, rather than layering them. Is there some way I can gain intuition about this?
05:20:33 <merijn> dminuoso: Did you implement StateT yourself yet?
05:20:37 <ertes-w> dminuoso: the kind signature of a monad transformer didn't help?
05:20:47 <ertes-w> dminuoso: think of monad transformers as functions from monads to monads
05:22:26 <ertes-w> dminuoso: the layer intuition is not that wrong…  MTs are usually very wrapper-like
05:22:51 <ertes-w> but if you think of them as layers/stacks, you might miss the very compositional structure of MTs
05:23:12 <dminuoso> Alright, time to implement as many monad transformers as I can think then.
05:23:26 <ertes-w> dminuoso: start with StateT as merijn suggested
05:23:32 <merijn> dminuoso: https://gist.github.com/merijn/098106abd45c940dab09
05:24:42 <ertes-w> oddly enough dependent typing might make MTs easier to understand conceptually =)
05:24:47 <ertes-w> because then MTs are actual functions
05:24:49 <merijn> WTB @since annotations on containers >.<
05:28:36 <ertes-w> does lambdabot have TypeInType enabled?
05:28:52 <merijn> One way to find out? ;)
05:28:54 <ertes-w> @let type MonadType = * -> *
05:28:54 <lambdabot>  Parse failed: Parse error: *
05:29:00 <ertes-w> that's a no =)
05:31:06 <merijn> Time to make friends by running "cabal -j32" :p
05:34:39 <lseactuary> anyone here good with mathematics / set notation. i am stuck on a problem
05:35:56 <lyxia> /join ##math
05:36:25 <lseactuary> ok
05:40:27 <dminuoso> merijn: In this assignment, am I allowed to make small changes such as changing MyState to newtype MyState s a = MyState { runState :: s -> (a, s) } for convenience?
05:41:19 <merijn> dminuoso: Sure, I mostly did it like this to avoid beginners getting confused by syntax
05:50:08 <dminuoso> merijn: Alright. What about the Functor and Monad instances. Do you want me to build them from hand, or is relying on liftM/ap/return acceptable?
05:50:48 <dminuoso> Actually.. Ill just build them from hand for the excercise.
05:57:44 <merijn> I don't suppose anyone already built code to make persistent return vectors instead of lists?
06:16:15 <ertes-w> merijn: what do you mean?
06:17:08 <ertes-w> dminuoso: also write a MonadTrans instance (from Control.Monad.Trans.Class)
06:17:13 <merijn> ertes-w: It gives back [PersistValue] for each row, and I want a Vector. I have some ugly code to convert the list to Vector, but was secretely hoping for something more principled :)
06:17:25 <ertes-w> ah, you mean persistent, the library =)
06:17:31 <merijn> Yeah
06:18:22 <ertes-w> i read that as "to make (persistent (return vectors))" rather than "(to make persistent) (return vectors)"
06:18:35 <ertes-w> and wondered what a persistent return vector is =)
06:34:11 <dminuoso> merijn: Well now that was surprising.
06:34:32 <dminuoso> Still got to do ertes-w's instance, but I can immediately see how State is just StateT on Identity..
06:34:48 <merijn> dminuoso: :)
06:41:15 <ertes-w> dminuoso: and hopefully you can also see how transformers have both a "wrapping" and a "mapping" aspect to them =)
06:41:39 <dminuoso> ertes-w: Yeah... :)
06:42:01 <dminuoso> merijn: for visual effects I interleaved their definitions: https://gist.github.com/dminuoso/a4ae20cc8adc5953ae5035915c47fc63
06:42:15 <ertes-w> dminuoso: BTW, MonadTrans is probably the easiest one to write
06:42:26 <ertes-w> except perhaps Functor
06:43:29 <dminuoso> I really do need to figure out how to indent properly with `let` :|
06:43:46 <dminuoso> ertes-w: Alright. Let me just do this.
06:47:11 <ertes-w> dminuoso: it's a matter of style…  i usually have let either just after an opening paren/bracket, or at the beginning of the line
06:47:20 <ertes-w> and i line up like this:
06:47:23 <ertes-w> let x = 3
06:47:25 <ertes-w>     y = 4
06:47:30 <ertes-w> in …
06:47:58 <dminuoso> ertes-w: would there be a newline directly after the in?
06:48:10 <ertes-w> nope
06:48:43 <ertes-w> the fact that the definitions are 4 spaces indented and the expression after 'in' is 3 spaces indented is usually enough to distinguish them easily
06:48:45 <dminuoso> Fair enough. I suppose by accident doing it almost like do-notation helped me spot the similarities between State and StateT :)
06:48:56 <ertes-w> heh, yeah
06:49:40 <ertes-w> i think your style is fine, except for the indented 'in'
06:49:54 <ertes-w> i'd indent it *out* rather than in
06:51:27 <dminuoso> Yeah that'd work nicely, thanks for the tip
06:51:53 <ertes-w> dminuoso: exercise:  change your Functor instance:  instance (Functor m) => Functor (MyStateT s m)
06:52:57 <ertes-w> all other instances are fine, as far as i can tell
06:53:51 <dminuoso> ertes-w: And losen the constraint on the Applicative instance to Applicative.. this is exactly what we talked about yesterday. :)
06:54:05 <ertes-w> dminuoso: you can't
06:54:37 <ertes-w> your Applicative instance is fine, you need the (Monad m) constraint there
06:54:52 <dminuoso> Ah I can see why.
06:55:19 <dminuoso> Yeah actually I tried using the Functor interface of the monad but failed somehow. Let me revisit this.
06:57:00 <byorgey> my style when writing let ... in ...  is to avoid using it as much as possible =P
06:57:15 <byorgey> just because indenting it annoys me.  I have never found an indentation style for let ... in that I like
06:58:12 <dminuoso> ertes-w: Okay.. I knew what I wanted and needed to make it elegant, but I couldnt find it. I now just punched in the naive implementation using fmap (\(a, s1) -> (f a, s1)) m
06:58:23 <dminuoso> Turns out what I was looking for is Control.Arrow.first
06:59:18 <dminuoso> https://gist.github.com/dminuoso/388e333e763a37528c85a1633a65e3f1
06:59:32 <dminuoso> And I can probably get rid of that let block too now
06:59:55 <dminuoso> And then I get more linter suggestions..
07:00:04 <byorgey> and then you can eta-reduce...
07:00:08 <ertes-w> byorgey: https://github.com/esoeylemez/wires/blob/master/Control/Wire/Varying.hs#L83-L84
07:00:12 <ertes-w> byorgey: you don't like this style?
07:01:07 <ertes-w> dminuoso: it's exactly what you need…  honestly i would just write it out
07:01:25 <ertes-w> dminuoso: (\(x, s) -> (f x, s))
07:01:45 <byorgey> ertes-w: It is a perfectly sensible style, but for whatever reason it just bothers me that the stuff after 'let' is one column off from the stuff after 'in'.
07:02:08 <ertes-w> byorgey: i use that to my advantage: it helps distinguishing the two parts
07:02:30 <[Leary]> I always put an extra space after the in, personally.
07:02:43 <dminuoso> ertes-w: `fmap f o = MyStateT $ \s -> first f <$> runStateT o s` to me this is readable :)
07:02:55 <byorgey> ertes-w: as I said, it is very sensible =)
07:03:38 <dminuoso> Though my linter suggests to turn this into `MyStateT (fmap (first f) . runStateT o)` .. but that has become magical.
07:03:38 <byorgey> it just bothers some primitive part of my brain that likes to have things in straight lines
07:03:53 * hackage dejafu 0.9.1.1 - Systematic testing for Haskell concurrency.  https://hackage.haskell.org/package/dejafu-0.9.1.1 (barrucadu)
07:04:06 <Franciman> ertes-w, hey, fwiw found a way to do what I needed with wreq. (Not following redirects)
07:05:38 <ertes-w> dminuoso: it's a reasonable implementation, although for me it loses a point for using Control.Arrow =)
07:05:44 <ertes-w> dminuoso: if anything you should use Data.Bifunctor
07:05:45 <byorgey> dminuoso: \s -> first f <$> runStateT o s  =  \s -> fmap (first f) (runStateT o s)  =  \s -> (fmap (first f) . runStateT o) s  =  fmap (first f) . runStateT o
07:05:55 <ertes-w> @let import qualified Data.Bifunctor as Bi
07:05:56 <lambdabot>  Defined.
07:06:01 <ertes-w> > Bi.first succ (10, 20)
07:06:04 <lambdabot>  (11,20)
07:06:08 <byorgey> dminuoso: I agree  \s -> first f <$> runStateT o s  is quite readable though.
07:06:30 <ertes-w> dminuoso: BTW, you can make this slightly nicer by flipping the tuple
07:06:43 <ertes-w> dminuoso: newtype StateT s m a = StateT { runStateT :: s -> m (s, a) }
07:07:04 <ertes-w> fmap f (StateT g) = StateT (fmap (fmap f) . g)
07:07:46 <ertes-w> unfortunately in transformers it's (a, s) for historical reasons
07:08:11 <dminuoso> ertes-w: Mmm. fmap (fmap f) is just (fmap . fmap) f
07:08:21 <ertes-w> yep
07:08:32 <Taneb> ertes-w: do you know where I can read about those historical reasons?
07:08:34 <dminuoso> Okay that makes it more obvious :)
07:08:45 <Taneb> Or is it just "we started this way so we're stuck now"
07:09:13 <ertes-w> Taneb: i guess it's because Functor is newer than Monad
07:09:50 <Taneb> ertes-w: what does that have to do with the tuple being (a,s)?
07:09:57 <Psybur> ertes-w, how does netwire stack up against reactive-banana and the big names in FRP? :D
07:10:13 <ertes-w> Taneb: you need (instance Functor ((,) a)) to use fmap there
07:10:17 <dminuoso> Taneb: you cant use fmap to tap into a with that tuple order.
07:10:26 <Taneb> Aaaah, I see!
07:10:34 <Taneb> So back in the day there wasn't much point
07:10:43 <ertes-w> Psybur: oh, apparently i forgot to deprecate it on hackage =)
07:10:59 <ertes-w> Psybur: if anything use the 'wires' library, but if you can, avoid AFRP like a plague
07:11:21 <ertes-w> Psybur: my personal recommendation is to use reflex
07:11:29 <Psybur> Why are arrows bad for frp
07:11:48 <dminuoso> ertes-w: Curious, why do you consider Bifunctor the cleaner approach? I didn't really care about Control.Arrow in the slightest, I just looked for things that would give me the ability to map over the first part of a tuple. Control.Arrow was the first thing I found :)
07:11:51 <tabaqui> oh, frp talk, what I've missed?
07:12:07 <tabaqui> about arrows - Yampa works very well with arrowized frp
07:12:21 <ertes-w> Psybur: the interface is horrible, all the tuple handling can have a performance impact, and most importantly behaviours and events aren't first class in AFRP
07:12:50 <Psybur> If its so terrible then why did you make it :D?
07:12:59 <Taneb> Psybur: someone's got to try to see
07:13:25 <Taneb> The only thing more stupid than always using bad things is never even trying to use things that might be bad
07:13:37 <ertes-w> dminuoso: because Arrow is just bad on many levels, and the less often we import it the better =)
07:14:31 <ertes-w> Psybur: for two reasons: netwire is actually a non-trivial extension of AFRP (Wires is a family of signal "choice" monoids), and because at the time better approaches were still in their infancy
07:15:12 <ertes-w> Psybur: AFRP is particularly good at handling applications that are time-framed and real-time, e.g. a game running at 60 FPS, and it's very easy to reason about performance
07:15:16 <tabaqui> ah, what I shame
07:15:25 * tabaqui will brb
07:16:35 <dminuoso> ertes-w: Okay after realizing what Im doing I golfed it into: fmap f (MyStateT o) = MyStateT $ fmap (first f) . o
07:16:39 <ertes-w> Psybur: i still recommand not to use netwire…  wires is simple and practical, and i'm working on a new framework that removes the A part while keeping some of netwire's advantages as well as the speed
07:17:15 <ertes-w> dminuoso: yeah, that's pretty much how i would have written it, except for 'first' and ($) =)
07:17:30 <dminuoso> ertes-w: can you explain?
07:17:52 <cocreature> first is fine, just use the one from Data.Bifunctor instead of the one from Control.Arrow :)
07:18:05 <ertes-w> dminuoso: fmap f (MyStateT g) = MyStateT (fmap (Bi.first f) . g)
07:18:17 <ertes-w> where Bi.first is from Data.Bifunctor
07:18:36 <Psybur> ertes-w, not a fan of $?
07:19:03 <dminuoso> ertes-w: Oh my `first` is from Bifunctor now. :)
07:19:09 <cocreature> ertes-w has written too much elisp, they can’t stop using parenthesis now :)
07:19:10 <ertes-w> Psybur: i wouldn't say that, but i use it only when the structure is visible from layout
07:19:33 <ertes-w> blah = f $ do …  -- continuation on the next line
07:20:22 <ertes-w> dminuoso: ok, now write MonadTrans =)
07:20:39 <cocreature> ertes-w: and soon that won’t need a $ anymore since BlockArguments was accepted :)
07:20:49 <ertes-w> cocreature: oh, cool!
07:21:07 <ertes-w> about time, too =)
07:21:10 <merijn> cocreature: Did the more flexible numeric literals thing go in yet?
07:21:27 <ertes-w> > 1e3 :: Integer
07:21:29 <lambdabot>  error:
07:21:29 <lambdabot>      • No instance for (Fractional Integer)
07:21:29 <lambdabot>          arising from the literal ‘1e3’
07:21:36 <ertes-w> merijn: ^ you mean that?
07:21:41 <merijn> ertes-w: That's NumDecimals, but not what I was referring too
07:21:45 <ertes-w> ah
07:21:52 <merijn> ertes-w: No, basically allowing separators in numeric literals
07:21:59 <ertes-w> ah, ok
07:22:00 <merijn> So you can write 1_000_000 :: Int
07:22:23 <merijn> (I suppose for that specific case NumDecimals works, but in general)
07:22:38 <merijn> But yes, NumDecimals should also definitely go in
07:22:47 <ertes-w> read (filter isDigit "1 000 000")
07:22:48 <ertes-w> =P
07:22:55 <cocreature> merijn: yep it got accepted but it’s not in ghc yet afaik
07:23:25 <cocreature> ah but apparently there is already a phab revision or whatever that’s called for it https://phabricator.haskell.org/D4235
07:24:27 <Psybur> QuickCheck or HUnit?
07:24:37 <cocreature> Psybur: both :)
07:24:37 <merijn> Psybur: Those...are for very different things
07:25:15 <Psybur> Guess I misread something :D
07:25:41 <Psybur> "The main testing mechanisms in Haskell are traditional unit testing (via the HUnit library), and its more powerful descendant: type-based “property” testing, with QuickCheck, an open source testing framework for Haskell." http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
07:25:44 <merijn> Psybur: HUnit is for unit tests, quickcheck for property testing
07:25:53 <byorgey> dminuoso: you could also define   withStateT f = MyStateT . f . runStateT,  then   fmap = withStateT . fmap . fmap . first
07:26:06 <Psybur> Wondering what this more powerful descendant business is all about then
07:26:25 <merijn> Psybur: A lot of the sort of unit tests people often write are obsoleted by property-based testing
07:26:45 <merijn> Psybur: But not all tests can be done using property-based testing
07:26:48 <byorgey> dminuoso: "semantic editor combinator" style
07:27:12 <merijn> Psybur: You may also want to look at something like tasty which lets you tie both HUnit and QuickCheck tests into a single testing hierarchy
07:27:57 <sm> but not doctests, alas
07:28:15 <merijn> sm: Well, start implementing a doc-tests ingredient for it, then? ;)
07:28:20 <Psybur> merijn, interdasting. So if Im making tests for a forex backtesting framework, and my tests will look like creating a series of prices and running them against a strategy, Id probably be better off with HUnit?
07:28:40 <saurabhnanda> any haskell newbies around?
07:28:43 <sm> I'll drop everything and get right on it! :)
07:28:57 <saurabhnanda> any haskell newbies around? need some end-user testing for a newbie tutorial.
07:29:08 <merijn> Psybur: If your tests consist of "generate random data and check if some condition is true after processing it", then quickcheck is what you want
07:29:08 <ertes-w> aren't we all newbies? =)
07:29:18 <dminuoso> ertes-w: In a moment, I just found extreme pleasure into golfing my MyState >>= instance into: (MyState m) >>= f = MyState $ \s -> uncurry runState $ first f $ m s
07:29:36 <saurabhnanda> ertes-w: definitely not you. you're the complete opposite of a newbie :)
07:29:49 <Psybur> It wouldnt be random since I have to know beforehand if I should be longing/shorting and for how much
07:30:22 <ertes-w> saurabhnanda: i'm still learning though…  for example quchen's loeb was new to me =)
07:30:41 <ertes-w> quchen: BTW, thanks for that article =)
07:31:04 <mniip> hmm, I wonder how long it would take to iterate through all brainfuck programs to find the shortest/fastest one with a particular behavior if we use diagonal emulation
07:31:34 <ertes-w> quchen: i can't really think of use cases that aren't better covered by 'fix' or a recursive 'let' though
07:32:00 <mniip> probably eons
07:32:24 <ertes-w> @let data V3 a = V3 a a a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
07:32:26 <lambdabot>  Defined.
07:33:08 <dminuoso> And that can be improved even further into:
07:33:09 <dminuoso> (MyState m) >>= f = MyState $ uncurry runState . first f . m
07:33:30 <ertes-w> > loeb (V3 (const 1) (\(V3 x _ _) -> x + 1) (\(V3 x y _) -> x + y))
07:33:32 <lambdabot>  V3 1 2 3
07:33:33 <dminuoso> uncurry is lovely :)
07:33:50 <mniip> :t puncture (V3 1 2 3)
07:33:51 <lambdabot> Num b => V3 (b, b -> V3 b)
07:33:55 <mniip> :D
07:34:11 <ertes-w> > fix (\ ~(V3 x y _) -> V3 1 (x + 1) (x + y))
07:34:14 <lambdabot>  V3 1 2 3
07:34:19 <ertes-w> quchen: ^
07:34:31 <quchen> ertes-w: You can write fix in terms of loeb so they’re somewhat equivalent
07:34:42 <quchen> Actually, they *are* equivalent. Up to efficiency.
07:34:45 <mniip> :t loeb
07:34:46 <lambdabot> Functor f => f (f b -> b) -> f b
07:35:01 <ertes-w> quchen: i was hoping for something crazier =P
07:35:12 <dminuoso> quchen: What does "up to efficiency" mean? Is that some wordplay on "up to isomorphism" ?
07:35:13 <ertes-w> another rabbit hole to drop myself into =)
07:35:13 <cocreature> at some point I actually remembered how loeb works
07:35:20 <mniip> :t runIdentity . loeb . Identity . (. runIdentity)
07:35:22 <lambdabot> (c -> c) -> c
07:35:39 <mniip> should be about as efficient as fix
07:35:47 <quchen> dminuoso: Bubblesort is equivalent to Quicksort in terms of their ability to sort lists, but they have dramatically different runtimes.
07:35:47 <mniip> given all of these are coerces
07:35:50 <mniip> and fmap is coerce too
07:36:04 <ertes-w> yeah, bubblesort is much faster than quicksort
07:36:23 <ertes-w> … if the array fits into the cache =P
07:36:23 <quchen> …for sufficiently sized lists, yes
07:36:31 <quchen> And asymptotically they’re the same even!
07:36:36 <mniip> hmmm
07:36:41 <quchen> And Bubblesort is easier to implement. I think we should use Bubblesort.
07:36:47 <mniip> I implemented quicksort with median of medians in haskell once
07:36:52 <mniip> I wonder where that is
07:37:08 <merijn> quicksort is an awful sort, I don't know why it ever became so famous >.<
07:37:19 <merijn> Probably because of the name
07:37:20 <mniip> merijn, no like it was semi decent looking even
07:37:39 <quchen> merijn: Why? Rant away
07:37:44 <mniip> no hard indices
07:37:58 <merijn> quchen: It's extremely tricky to implement and there's almost no upside to it
07:38:14 <mniip> found it
07:38:16 <mniip> http://lpaste.net/354328
07:38:22 <merijn> quchen: Like, name one positive property about quicksort that's not obtainable via an easier sort
07:38:40 <merijn> Mergesort is best sort.
07:38:54 <quchen> Is it?
07:38:56 <ertes-w> merijn: is there a way to do mergesort in-place?
07:39:01 <merijn> ertes-w: Yes!
07:39:01 <mniip> yes
07:39:02 <mniip> there is
07:39:04 <quchen> I like Mergesort too, for what it’s worth.
07:39:18 <quchen> It’s obviously correct, and hard to get wrong.
07:39:19 <mniip> it aint trivial but it's possible
07:39:26 <merijn> quchen: Mergesort has better asymptotics, perfect cache behaviour, trivially parallelisable, and possible to implement in place
07:39:27 <ertes-w> oh, of course there is
07:39:28 <wz1000> I don't think in place merge sort is nlogn
07:39:28 <mniip> it's easy to get in-place mergesort wrong
07:39:30 <quchen> Quicksort is obviously correct, but impossible to not get wrong.
07:39:37 <mniip> wz1000, sure is
07:39:48 <wz1000> how?
07:39:50 <ertes-w> mergesort also appears to have far better memory locality
07:39:52 <merijn> ertes-w: The in-place version is not as easy to implement as the other one, but still fine
07:39:58 <quchen> merijn: I don’t care about asymptotics, my universe is finite so there is no »sufficiently large N«. I want my sorting to be fast.
07:40:01 <merijn> wz1000: Why wouldn't it be?
07:40:16 <wz1000> you don't have any extra working area
07:40:21 <ertes-w> merijn: yeah, i can see why, except for arrays that are (2^n) in length
07:40:22 <merijn> quchen: Yeah, but for that I refer back to "trivially parallelisable" and "best cache behaviour"
07:40:36 <quchen> merijn: Slowsort is also trivially parallelizable! :-D
07:40:42 <quchen> That’s my favourite sorting algorithm.
07:40:55 <merijn> quchen: Anyway, when I say better asymptotics I mean that mergesort is n log n worst case
07:40:56 <quchen> Easy to do inplace, easy to understand, easy to parallelize
07:41:01 <merijn> quchen: quicksort is n^2 worst case
07:41:11 <mniip> merijn, wrong!
07:41:16 <mniip> see lpaste
07:41:31 <wz1000> merijn: http://penguin.ewu.edu/cscd300/Topic/AdvSorting/MergeSorts/InPlace.html
07:41:32 <merijn> mniip: Wrong what?
07:41:41 <mniip> quicksort can be nlogn worst case
07:41:50 <hrnz> it can be n^2
07:41:51 <mniip> if you pick the pivot with median of medians/quickselect
07:42:01 <quchen> mniip: O(n²) is a superset of O(n log n), so Mergesort is also O(n²) worst case.
07:42:08 <merijn> wz1000: That's a dumb implementation
07:42:09 <mniip> sigh
07:42:12 <ertes-w> so how would you implement in-place mergesort for odd array lengths?  divide-and-conquer?  i.e. split the array into two chunks, where one is 2^n-sized, then do the same with the remaining part recursively, then merge?
07:42:20 <merijn> ertes-w: I have a paper
07:42:25 <mniip> quicksort is can be not Omega(n^2)
07:42:29 <mniip> s/is//
07:42:33 <ertes-w> merijn: i'd prefer a short summary
07:42:38 <ertes-w> not too interested in details
07:42:40 <wz1000> merijn: can you link something? I'm interested
07:42:47 <merijn> ertes-w: I forgot the summary :p
07:42:51 <ertes-w> heh, ok
07:42:54 <merijn> ertes-w, wz1000: http://akira.ruc.dk/~keld/teaching/algoritmedesign_f04/Artikler/04/Huang88.pdf
07:43:21 <mniip> that better not be in danish
07:43:57 <merijn> quchen: That's just pedantic for no practical purpose other than making communication verbose
07:44:15 <ertes-w> actually i can think of a way to do it fairly easily
07:44:20 <mniip> I can get pedantic too
07:44:27 <mniip> my quicksort is O(nlogn) and Omega(n)
07:44:41 <merijn> mniip: That's just the first free PDF link I found on google scholar for the paper
07:44:58 <merijn> Lots of Danish, Russian, etc. sites hosting non-paywalled copies
07:45:07 <mniip> merijn, I wasn't being serious
07:45:24 <mniip> anyway this discussion is a mess
07:45:29 <quchen> merijn: I think it’s silly to talk about asymptotics and timing in the same sentence.
07:45:39 <merijn> quchen: Why?
07:45:40 <quchen> Without a »not« in between.
07:45:51 <ertes-w> anyway, not right now =)
07:47:03 <wz1000> I really like the merge sort implemented in ghc/base
07:47:12 <quchen> Agreed!
07:47:23 <wz1000> IIRC it comes from hugs or something
07:47:26 <quchen> The DList business makes it a bit less elegant, but other than that it’s amazing.
07:48:05 <mniip> oh
07:48:27 <mniip> is that the one that makes everything into a list of singles and then iterates merging
07:48:36 <wz1000> almost
07:48:49 <mniip> looks like this doesn't actually do singles
07:48:54 <mniip> but rather asc/desc subsequences
07:49:00 <mniip> as a micro-optimization
07:49:04 <wz1000> yes, the idea is the same
07:49:48 <mniip> I'm not super convinced the list business doesn't make this slightly worse than nlogn
07:50:29 <wz1000> there was a really fun question about space complexity on my algo exam
07:51:20 <wz1000> you have a non deterministic TM which uses at most S(n) = O(n^2) spaces on the tape
07:51:58 <mniip> that alone sounds "fun"
07:52:10 <quchen> DF Fun™ 
07:52:15 <wz1000> If that TM accepts a language L, is it possible for there to be a deterministic TM that accpets the complement of the language
07:52:25 <wz1000> and is polyspace itself
07:52:41 <mniip> yes
07:53:04 <mniip> if you take a super silly TM that accepts an actually simple language...
07:53:04 <wz1000> Sorry, S(n) = O(n^c)
07:53:07 <hodapp> possible but not guaranteed, I believe
07:53:15 <mniip> yes
07:53:23 <mniip> definitely possible
07:53:25 <wz1000> hodapp: I think it is guaranteed
07:53:26 <dminuoso> ertes-w: Huh. is that just lift m = MyStateT (\s -> m >>= (\a -> (a, s))) ?
07:53:44 <ertes-w> dminuoso: yeah
07:53:52 <ertes-w> dminuoso: i told you it's easy =)
07:54:03 <ertes-w> s/easy/simple/
07:54:09 <mniip> ertes-w, my gut feeling tells me going nondet to det implies an exponential explosion
07:54:14 <wz1000> Atleast, my solution involved consturcting a deterministic TM of exactly the same space complexity
07:54:31 <ertes-w> dminuoso: up for a more challenging monad transformer?
07:54:41 <wz1000> mniip: but you can do a depth first traversal of the computation tree
07:54:49 <ertes-w> mniip: context?
07:54:50 <mniip> hmm
07:54:51 <dminuoso> ertes-w: Considering that this was pretty mechanical so far, yeah I think so.
07:54:53 <mniip> oops
07:54:58 <mniip> ertes-w, that was to wz1000
07:55:13 <ertes-w> dminuoso: newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
07:55:20 <ertes-w> ah
07:55:22 <mniip> ertes-w, hahahha no
07:55:28 <mniip> ContT is really just Cont
07:55:36 <ertes-w> mniip: i know
07:55:38 <mniip> snot even a monad transformer
07:55:51 <mniip> I wish someone had told me that :p
07:55:55 <ertes-w> mniip: the point of the exercise is to practice transformers =)
07:56:11 <ertes-w> and just reusing Cont would be against that point =)
07:56:57 <mniip> hmm
07:57:05 <mniip> I need to recheck the proof that my quicksort is nlogn
07:57:13 <mniip> something feels off
08:00:52 <ertes-w> dminuoso: i'll give you the correct instance heads for this one:  instance Functor (ContT r m); instance Applicative (ContT r m); instance Monad (ContT r m)
08:01:10 <ertes-w> dminuoso: there is no typo there, and nothing is missing =)
08:01:55 <mniip> hmm
08:02:04 <mniip> I need a modification of the akra-bazzi theorem...
08:03:09 <mniip> I have an h_i that is too large for x/log^2 x
08:06:38 <simendsjo> Anyone using ob-haskell? I'm having problems with results showing "Prelude> Prelude>" etc. Some more information here: https://gist.github.com/simendsjo/88d09e7ed3b6d453faac9501998e0acd
08:12:26 <mniip> hrm
08:12:55 <mniip> okay so this was what was off
08:13:37 <barcabuona> hey guys. is there any movement in the community towards a more unified library, better performance and math operations?
08:13:38 <mniip> akra-bazzi will work for any specific b_1 \in [0.2, 0.8], b_2=1-b_1
08:13:41 <mniip> but not when it depends on n
08:14:35 <ertes-w> barcabuona: "unified"?
08:16:46 <barcabuona> ertes-w: stuff like strings, better standard libs, etc
08:16:53 <barcabuona> less lang extensions
08:17:22 <ertes-w> barcabuona: there are movements for all of those, at various paces
08:17:53 <ertes-w> but of course it depends on your definition of "better"
08:23:15 <barcabuona> better is "it actually gets implemented into the language"
08:23:20 <barcabuona> or ghc whatever
08:23:29 <barcabuona> like rust & python
08:24:17 <barcabuona> i'm just wondering because i like haskell as a language, what i don't like is the state of the libraries and performance. so i'm trying to see if it's gonna improve in the future or if i need to maybe stick to something like f# 
08:24:36 <barcabuona> just as a curiosity, no hate at all intended. i really love the language
08:26:41 <barcabuona> also i heard that haskell may move in the future towards strict by default. is this true? i actually think it's a better idea, just coming from a background where when you need laziness you use it
08:27:01 <glguy> No, there aren't plans to move to strict by default, fortunately.
08:32:11 <barcabuona> alright makes sense. what about the rest? any language designers or ghc developers working on that or is it gonna take maybe a few more years?
08:32:12 <c_wraith> so little of what's good about haskell would survive that...
08:32:58 <JuanDaugherty> where you need laziness to use it
08:33:29 <c_wraith> I've never really felt like library support has been an issue in Haskell.
08:33:56 <phadej> barcabuona: ghc /= libraries, i think it's great that the libraries are separate
08:34:01 <c_wraith> but that's mostly because of how bad I think library ecosystems are in every language.
08:34:04 <mnoonan> barcabuona: purescript feels very much like haskell with tweaks (certain extensions by default, strict rather than lazy). It's worth checking out, if you haven't.
08:34:50 <c_wraith> not having a library for something tends to be less bad than having a bad library. and 99% of "good ecosystems" are bad libraries
08:35:17 <ertes-w> barcabuona: consider that python follows a very different philosophy when it comes to…  everything
08:35:31 <ertes-w> barcabuona: you won't see stuff like JSON in the base library
08:35:38 <ertes-w> or even in any of the libraries that come with GHC
08:35:45 <c_wraith> I just wrote a saml server from scratch because of how bad the library options were in my day job language.
08:37:27 <c_wraith> they would have been just as much total code to force into working with everything else, and it would have been harder to understand.
08:37:30 <metalrain_> Saml seems to be quite important but not well enough ”funded”
08:37:30 <ertes-w> barcabuona: improving performance is always good of course, and GHC gets better with every release
08:39:28 <ertes-w> barcabuona: there are some things i would like to have in the base library, and some extensions that i would like to be standard, but those are things that might very well happen, because they are in line with the haskell philosophy
08:39:40 <barcabuona> mnoonan: thanks i will check out purescript. is it compiled as well?
08:39:50 <ertes-w> in fact some of them are already on their way into base/haskell
08:40:14 <mnoonan> barcabuona: transpiled to javascript by default, but iirc there are other backends too
08:40:20 <ertes-w> barcabuona: i'd say purescript is great *compared to javascript*
08:40:43 <ertes-w> it's not a language i'd want to code in
08:41:10 <kuribas> ertes-w: why?
08:41:19 <mnoonan> ertes-w: I don't really care about JS, so to me it's more like an experiment "what if we made Haskell in 2017, and tried making it strict by default"
08:41:24 <barcabuona> ertes-w: really? do you have a link of such improvements?
08:41:27 <ertes-w> kuribas: strictness
08:41:40 <kuribas> ertes-w: idris is strict as well...
08:41:50 <ertes-w> kuribas: and i wouldn't want to code in idris either
08:42:30 <barcabuona> idris seemed to move a bit faster last time i checked, but it's even less mature than haskell
08:42:46 <ertes-w> barcabuona: no, and the list is long, but here are a few:  Flexible*, GADTs, RankNTypes, TupleSections
08:42:48 <metalrain_> How is f# compared to haskell? It seems to be going in places, but is it enough?
08:43:27 <mnoonan> ^ LambdaCase all day long
08:43:43 <ertes-w> metalrain_: from the perspective of haskell F# is barely any different from C#
08:43:47 <kuribas> metalrain_: it's not very popular
08:44:04 <kuribas> metalrain_: and haskell is a better not very popular language :)
08:44:06 <ertes-w> metalrain_: the only advantage over C# i can point out is syntax
08:44:38 <barcabuona> advantage is standard library
08:44:44 <barcabuona> and nice syntax
08:44:57 <marvin3> F# has a lot better type inference than C# too does it not?
08:48:38 <metalrain_> So probably OCaml and Idris seem to be closest languages to Haskell.
08:50:51 <kuribas> no, ocaml is object oriented, and idris has dependend types (and is strict).
08:50:57 <kuribas> they're not like haskell
08:51:04 <kuribas> ocaml is also strict
08:51:20 <Taneb> kuribas: they're both more like Haskell than C++ is, in terms of culture and style
08:51:44 <kuribas> Taneb: that for sure.  Though C++ is getting more features from functional programming :)
08:51:50 <kuribas> like closures
08:54:50 <Taneb> kuribas: C++ is also object-oriented and strict, like OCaml
08:55:03 <Taneb> But I'd say OCaml is a lot more like Haskell than it is like C++
08:55:40 <kuribas> Taneb: yes
08:55:49 <Guest99761> How is it you're comparing C++ and functional languages :)
08:58:39 <marvin3> is ocaml functional? .o( puts on troll hat )
08:59:11 <Taneb> marvin3: they come to ICFP, and hence...
08:59:12 <Taneb> ;)
09:00:44 <Guest99761> Does C++ go to ICFP?
09:00:55 <Guest99761> hehe
09:01:30 * rightfold only cares about imperative vs declarative and says Haskell is the former
09:02:11 <byorgey> Guest99761: yes, sometimes the people who win the ICFP programming contest use C++, and they attend ICFP =)
09:02:27 <Guest99761> rightfold: Good call
09:02:48 <byorgey> Haskell is imperative?
09:03:10 <Taneb> byorgey: when I look for jobs, it's imperative they let me use Haskell
09:03:11 <rightfold> In Haskell you tell the computer what to do and it will do something observably equal to that
09:03:14 <Psybur> So in the type ExceptT String (StateT Int m) (), ExceptT is the innermost monad? Then StateT? Then m ?
09:03:17 <byorgey> Taneb: haha
09:03:23 * hackage midimory 0.0.2.1 - A Memory-like (Concentration, Pairs, ...) game for tones  https://hackage.haskell.org/package/midimory-0.0.2.1 (HenningThielemann)
09:03:25 <rightfold> That you do it without side effects is irrelevant
09:03:30 <Taneb> byorgey: I'm not very functional otherwise
09:03:43 <byorgey> Psybur: no, I would say m is innermost
09:03:57 <Psybur> byorgey, then how come I have to lift my State operations?
09:04:03 <Psybur> Oh
09:04:07 <Psybur> Nvm
09:04:21 <Psybur> :D
09:04:30 <byorgey> the only operations you don't have to lift are the ones for the outermost layer =)
09:08:03 <kuribas> byorgey: haskell is the best imperative language :)
09:13:25 * hackage retry 0.7.5.0 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.7.5.0 (MichaelXavier)
09:15:58 <kuribas> is there any work on parsing random access structures, like bytestrings?
09:22:23 <dminuoso> ertes: Had to wrap my head around CPS, but I think it's clear. (Not why they are useful or what they are for, but at least how they are implemented).
09:22:26 <dminuoso> So Im starting now. :-)
09:31:50 <hexagoxel> any windows/msys2/pkg-config users around? i am a bit confused why i have to specify an additional include-dir with latest msys2.
09:33:19 <hexagoxel> (i.e. i have to specify the "global" C:/msys64/mingw64/include)
09:50:29 <dminuoso> ertes: https://gist.github.com/dminuoso/2b72dc344cf69ddef1bd41bdca7f2846
09:51:21 <dminuoso> ertes: That implementation is identical to my previous Cont implementation, and I suppose it makes sense in the way that there's no constraint on m.
09:52:03 <lseactuary> anyone here know about set notation? im trying to write that a section (other than the first one) is preceded by at least one other section (not including itself) and every section (other than the final one) is followed by at least one section (other than itself).
09:52:09 <dminuoso> Because there's no constraint on m, it's monadic interface cannot be used.
09:54:59 <cocreature> lseactuary: what kind of set notation are you talking about?
09:55:10 <lseactuary> math set notation like { } 
09:55:28 <cocreature> then I don’t understand what a section is supposed to be in this context
09:55:30 <lseactuary> or i can write it in set notation but i cant even think how to convert this into non-technical language :/
09:55:37 <lseactuary> ah let me explain
09:55:59 <lseactuary> so we have a railway track. it is split into a number of track sections, each which has an identifier.
09:56:08 <lseactuary> so im guessing the basic type here is [railway]
09:56:19 <lseactuary> and we have sections in [railway]
09:57:17 <lseactuary> cocreature does it make sense?
09:57:35 <mud> lseactuary: This is sounding a lot like a graph.
09:57:43 <lseactuary> ye lattice i think 
09:57:49 <lseactuary> but im unsure how to write it 
09:57:54 <cocreature> somewhat, what exactly is the meaning of the symbol [railway]. does it denote the set of all railways?
09:58:25 <lseactuary> [railway] is a basic type. like [people]. where customer E people, man E people etc
09:58:44 <lseactuary> but ye you can think of it as a set of all railways
09:58:53 <lseactuary> but i guess here all railways is just 1 railway
09:59:24 <cocreature> okay, so what’s your actual question? :)
09:59:55 <lseactuary> i need to define types and appropriately constrained objects for the scenario
09:59:58 <lseactuary> and i have no clue how
10:00:19 <lseactuary> i was thinking [sections] could be a basic type and then you have for all s in sections blah 
10:00:23 <lseactuary> but that doesnt make sense
10:00:30 <cocreature> types as in Haskell types?
10:00:56 <lseactuary> well i need to write in math notation
10:01:03 <lseactuary> but if we can write in haskell i can convert into math
10:01:21 <lseactuary> at the moment im unsure of how to turn this logic to even code
10:02:58 <cocreature> ∀section. ¬first(section) → ∃preceeding_section. follows(preceeding_section, section)
10:04:45 <lseactuary> hmm
10:05:22 <lseactuary> so section is the basic type? S1,S2,S3 etc?
10:05:56 <lseactuary> also what is . 
10:07:21 <cocreature> I’m not sure what the exact meaning of a "basic type" is supposed to be. I think you’re using some terminology that I’m not familiar with
10:07:32 <cocreature> . is just syntax for separating the quantifier from whatever follows
10:08:18 <lseactuary> basic type is just the big set. so for example if we wanted all even integers we would say something like x in Z where x div 2 = non decimal or something.
10:08:25 <lseactuary> so here the Z is the basic type 
10:09:13 <lseactuary> section are S1, S2, S3 etc so its okay to basically define a set called 'sections' and then we use for all s in sections, blah?
10:09:14 <cocreature> ok, yeah so you have a basic type of sections
10:09:19 <lseactuary> righgt
10:09:37 <lseactuary> ok so now i look at your code
10:10:06 <lseactuary> for all x in sections except the first section there exists a preceeding section for the section
10:10:15 <lseactuary> but do we not need to define first, preceeding etc
10:10:31 <cocreature> sure
10:10:45 <cocreature> it really depends on how you want to formalize this
10:10:58 <cocreature> you can just use first-order-logic and define these as predicates
10:10:59 <lseactuary> can you explain what you mean please?
10:11:05 <lseactuary> yeah 
10:11:08 <lseactuary> that is the goal
10:11:15 <lseactuary> it will make sense when i explain the next bit i think
10:11:31 <lseactuary> but for now trying to understand this
10:11:58 <lseactuary> ∀section. ¬first(section) → ∃preceeding_section. follows(preceeding_section, section)
10:12:03 <lseactuary> we need to remove first and last section no?
10:12:24 <cocreature> why do you need to remove the last section? that should have a predecessor, no?
10:12:32 <cocreature> or can it happen that you have only one section?
10:12:50 <lseactuary> indeed
10:12:55 <lseactuary> also, it says at least one 
10:12:59 <lseactuary> so one section could have 2 
10:13:06 <cocreature> I’m just guessing at what you could possibly mean, it’s really up to you to figure out what exactly you mean :)
10:13:10 <dminuoso> Wow.. so (m >>=) can be seen as creating a continuation :o
10:13:19 <lseactuary> :P
10:13:52 <lseactuary> ill type the exact words. 'a railway track is split up into a number of physical track sections, each of which is associated with an identifier' 
10:14:02 <lseactuary> so this means the basic type is [sections] so i get this.
10:14:13 <lseactuary> then it says 'a track section can be free or occupied'
10:14:23 <lseactuary> so i was thinking: status = free U occupied
10:14:38 <lseactuary> where U is 'or'
10:14:50 <lseactuary> or maybe bettter to say free and not free
10:15:47 <lseactuary> what do you think?
10:17:01 <lseactuary> as later they ask for a set comprehension so we can use free as a function or something like free(x) 
10:17:04 <lseactuary> maybe i am wrong :/
10:17:33 <poppu> !ciao
10:17:37 <poppu> !list
10:19:06 <lseactuary> then the last part says: track sections are connected. each track section (other than the initial one) is preceded by at least one other section (not including itself); each track section (other than the final one) is followed by at least one other one (not including itself). 
10:20:20 <lseactuary> so i basically want to write this in the notation similar to what did above, and define everything
10:20:27 <lseactuary> then i will write it in code later but i can do that part
10:21:58 <lseactuary> cocreature does it make sense/
10:22:17 <lseactuary> if you want i can show you the set comprehensions im trying to make, and we work backwards :P
10:24:00 <cocreature> seems to make sense but I would recommend to just start writing things down
10:24:07 <dminuoso> The transformers documentation says `For these monad transformers, lift is a natural transformation in the category of monads, i.e. for any monad transformation t :: M a -> N a,`
10:24:08 <cocreature> also this is getting a bit too much offtopic for #haskell
10:24:10 <lseactuary> ye hence im taking it piece by piece 
10:24:18 <dminuoso> If lift is a natural transformation, what functors does it operate on?
10:24:21 <lseactuary> sorry... just cant find help anywhere else :(
10:24:32 <lseactuary> we can take it to PM if you prefer
10:24:54 <kuwze> I currently have an issue trying to import CmdArgs. the repo is here: https://github.com/kuwze/gc2 and the error I am getting is here: https://gist.github.com/kuwze/e698facc844c47c91b55f60f9e697b90
10:24:55 <dminuoso> Or is `lift` a natural transformation between state transformers?
10:24:59 <lseactuary> i have made many attempts on this just cant seem to join the dots :/
10:25:03 <dminuoso> *monad transformers
10:33:41 <njay> Hey, Haskellers!
10:34:27 <njay> I asked a friend how I could start contributing to the Haskell compiler, and he pointed me here.
10:35:06 <njay> I'm quite new to all this, though. 
10:35:22 <pja> There's a #ghc irc channel. Don’t know how active it is though - anyone?
10:35:43 <cocreature> njay: what do you want to contribute?
10:37:19 <njay> cocreature: I'm not really sure at this point. I'm interested in programming languages, and I figured a fun way to learn a bit about functional compilers would be to work on one.
10:38:01 <cocreature> njay: take a look at https://ghc.haskell.org/trac/ghc/wiki/Newcomers
10:38:12 <cocreature> also pja is right in recommending #ghc
10:38:18 <njay> cocreature: Thanks, will do!
10:38:36 <cocreature> that said if you are just interested in learning about programming languages implementing a small compiler from scratch might be more helpful than trying to contribute to ghc
10:39:04 <cocreature> GHC is quite a big project and not particularly well suited for learning purposes imho
10:40:20 <thoughtpolice> Hey, GHC was the first compiler I ever worked on for a functional language.
10:40:27 <thoughtpolice> And I ended up being its main maintainer for 3 years, so
10:41:06 <njay> I'm particularly interested in Haskell, and I'd like to contribute to open source as well. This felt like a good way to kill two birds with one stone.
10:41:10 <thoughtpolice> But yes, #ghc is fairly active and you can get lots of help there :)
10:48:29 <alvinsj> Hi I'm learning to some ml code recently. Do you any recommendation on what I can use? E.g. matrix calculation, numpy like
10:49:09 <Taneb> alvinsj, hmatrix is a good matrix calculation library
10:50:31 <alvinsj> taneb: cool, thanks. How about gpu code, should I learn to use some lib? 
10:50:59 <kuwze> okay, so how do I fix this error: Failed to load interface for ‘CmdArgs’
10:51:09 <Taneb> alvinsj, accelerate is the one to look for there! It's really cool
10:51:14 <kuwze> It seems to have downloaded the library
10:51:18 <kuwze> stack I mean
10:52:40 <cocreature> kuwze: the module is called "System.Console.CmdArgs" not just "CmdArgs"
10:54:27 <humanoyd> why does stack put `extra-deps` in `.stack-work` and not the global `.stack` folder?
10:54:36 <kuwze> cocreature: thank you so much!
10:55:10 <alvinsj> taneb: nice, I was looking at it too, but haven't tried. are you doing ml on Haskell?
10:55:37 <cocreature> kuwze: yw!
10:59:26 * hackage stratosphere 0.14.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.14.0 (jdreaver)
11:02:50 <Taneb> alvinsj, yeah, actually! I work for a company that designs FPGA circuits for neural networks using Haskell
11:03:15 <cocreature> Taneb: oh you’re working for myrtle?
11:04:25 <Taneb> cocreature, yeah! Got it in one :)
11:04:31 <ttoe> hi! quick question: when i have a list and access an element n with (!!), is every element in the list computed up to & including n, which is then returned?
11:04:46 <cocreature> Taneb: nice! I was thinking about applying there once I’ve finished my masters :)
11:04:49 <tommd> No, but the spine of the list is forced.
11:04:49 <dminuoso> ttoe: Check out the definition and see for yourself :)
11:05:06 <tommd> > [undefined, undefined, 1] !! 2
11:05:08 <lambdabot>  1
11:05:17 <Taneb> cocreature, definitely do! We've also had good experiences with summer internships in the past if you've got a few years to go
11:05:34 <alvinsj> taneb: cool, good to know that Haskell is used. My lessons are in mostly python, but I'm trying to do it in haskell. found this ihaskell too is very useful
11:05:38 <tommd> ttoe: Notice if the first and second elements (index 0, 1) were evaluated we would have gotten an exception.
11:06:01 <Taneb> alvinsj, :)
11:06:05 <cocreature> Taneb: I should have finished my masters in october next year so not much time for internships ;)
11:06:18 <ttoe> dminuoso: i will, good idea
11:06:19 <Taneb> alvinsj, also check out http://www.datahaskell.org/
11:06:27 <ttoe> tommd: didnt even think of that quick test
11:06:35 <Taneb> cocreature, ha, hope to see you then :D
11:07:19 <cocreature> Taneb: hope so too :) will you be at zurihac?
11:07:21 <ttoe> and i though ghc was otherworldly fast haha
11:08:17 <dminuoso> ttoe: Remember that (:) 1 is considered to be in WHNF
11:08:52 <Taneb> cocreature, I hadn't thought about it, being honest
11:09:14 <cocreature> Taneb: registration opened two days ago, so there are probably still some places left ;)
11:10:39 <dminuoso> Taneb: Even the accessed element is not evaluated, because there's no reason to.
11:11:01 <dminuoso> Sorry I meant ttoe.
11:11:23 <ttoe> dminuoso: sorry, i dont get why that is important (i had to google 'whnf' just now though, never heard of it before)
11:11:31 <alvinsj> taneb: yes, please feel free to point me with links anytime. on my phone now, later. Thanks!
11:11:40 <Taneb> :D
11:12:17 <ttoe> dminuoso: ah, ok, but it is... i can see it ;) probably it is because i am printing it
11:12:53 <dminuoso> ttoe: Right. When you print it, you force it to be evaluated somehow. If you tried `a = undefined` in GHCi however that would work just fine.
11:14:41 <ttoe> dminuoso: actually i want ghc to compute all elements though. need to see how long it takes but without printing
11:16:21 <JessicaW> hello
11:16:58 <nicknight> hello
11:17:31 <JessicaW> I have a question regarding the use of the composition operator. how come we don't need it for filter? i.e. f x = sum . filter even x, instead of f x = sum . filter. even x
11:18:21 <mud> :t sum . filter even x
11:18:23 <lambdabot> error:
11:18:23 <lambdabot>     • Couldn't match expected type ‘a -> [c]’
11:18:23 <lambdabot>                   with actual type ‘[Integer]’
11:19:20 <geekosaur> I am guessing "sub . filter even: was intended
11:19:21 <geekosaur> er
11:19:28 <geekosaur> "sum . filter even"
11:19:32 <geekosaur> :t filter even
11:19:33 <lambdabot> Integral a => [a] -> [a]
11:19:58 <geekosaur> (.) composes functions. filter takes a function and produces a function
11:20:45 <geekosaur> that is, "filter even x" is "(filter even)" applied to "x"
11:20:58 <mboratko> Hello everyone, I have a question about using stack.
11:21:50 <mboratko> I am trying to follow the  user guide (https://docs.haskellstack.org/en/stable/GUIDE/) and it mentions that to correctly compile with dependencies I have to add the package to the .cabal file
11:22:17 <mboratko> however, when I do that and then run "stack build", as in the example, it removes the package I just added!
11:23:37 <jessicaW> I have a question regarding the use of the composition operator. how come we don't need it for filter? i.e. f x = sum . filter even x, instead of f x = sum . filter. even x
11:23:57 <geekosaur> so I guess you were lost when I tried to answer it
11:24:10 <geekosaur> first off, your example is wrong
11:24:10 <mud> mboratko: Is there a warning/error of any kind? Is there a uhm, package.yaml file? What version of stack are you using, out of curiosity?
11:24:37 <geekosaur> f = sum . filter even -- this would be correct
11:24:50 <geekosaur> and the reason it works is that filter takes a function and produces a function
11:25:03 <geekosaur> "filter even x" means apply the function produced by "filter even" to "x"
11:25:07 <geekosaur> :t filter even
11:25:09 <lambdabot> Integral a => [a] -> [a]
11:25:49 <mboratko> mud: Version 1.5.1, hpack-0.17.1
11:26:20 <mboratko> No warning or error, it simply reverts the helloworld.cabal file back to what it was prior to my edit
11:26:37 <mboratko> and then fails as before, saying "Failed to load interface for `Data.Text.IO`"
11:26:55 <mboratko> There is a package.yaml file, should I be making changes there?
11:26:58 <mud> mboratko: You might want to upgrade to the newest version, I *think* they added a new warning about what I suspect is happening here. Which is, if there's a package.yaml file, it uses hpack to convert that into the appropriate .cabal file, overwriting whatever you have in there. So you're actually supposed to edit the package.yaml file (or you can delete it if you don't want to use hpack I guess)
11:27:13 <jessicaW> thanks geekosaur
11:27:24 <mboratko> got it, thanks
11:27:33 <mud> Unless I'm mistaken, they improved the behavior quite a bit in the most recent version of stack and hpack. But ya, that is confusing.
11:31:14 <Psybur> Does HUnit have intellij integration like junit?
11:31:20 <mboratko> mud: no new error message in the new version, but making the change in package.yaml sorted it out. Thanks so much!
11:31:39 <mud> mboratko: Hmm, odd, I thought there was. Anytime
11:35:32 <mud> mboratko: Out of curiosity, what does --version say now after upgrade? Mine does seem to give a nice warning and a fancy behavior change (it uses the .cabal file instead if I modify it later than the package.yaml file). With version 1.6.1
11:35:55 <mboratko> 1.6.1 as well, let me try again
11:36:17 <mboratko> ah - yes that time it definitely did
11:36:18 <jessicaW> i'm trying to understand this function that suppose to define the composition of a list of functions. compose = foldr (.) id
11:36:36 <mud> mboratko: Oh okay, cool thanks. Just wanted to check :)
11:36:37 <jessicaW> i understand that id takes a argument and returns the argument unchanged
11:36:39 <mboratko> mud: it may be something about the order I did the upgrade or something
11:36:56 <mud> Yeah, pretty easy for the order you change the files in to matter.
11:39:19 <ralu> jessicaW: fold puts function as operator inbetween elements so  foldr (.) id [fa,fb,fc] == fa . fb . fc . id 
11:39:23 <geekosaur> jessicaW, "foldr (.)" means you are folding composition against a list (well, Foldable) of functions. the next parameter would be a base/initial value; since it must be a function, it's using "id". (which is an identity for composition, in the same way 0 is an identity for (+))
11:40:38 <gehn> anyone have some suggestions for practice problems?
11:40:57 <gehn> specifically tailored for haskell that is, I know about things like project euler etc
11:41:02 <dsal> exercism?
11:41:11 <dmj`> @google 99 haskell problems
11:41:11 <lambdabot> https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
11:41:31 <ralu> http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
11:41:33 <geekosaur> :t foldr f z [a,b,c]
11:41:34 <lambdabot> Expr
11:41:37 <dmj`> "but a Haskell ain’t one" - Lay-Z 
11:41:37 <geekosaur> whoops
11:41:42 <geekosaur> > foldr f z [a,b,c]
11:41:44 <lambdabot>  f a (f b (f c z))
11:41:59 <Psybur> > foldr1 d [a,b,c]
11:42:01 <geekosaur> (this magic courtesy of the simple-reflect package, which is where that "Expr" came from)
11:42:01 <lambdabot>  error:
11:42:01 <lambdabot>      • Couldn't match expected type ‘Expr -> Expr -> Expr’
11:42:01 <lambdabot>                    with actual type ‘Expr’
11:42:05 <Psybur> > foldr1 f [a,b,c]
11:42:07 <lambdabot>  f a (f b c)
11:42:16 <Psybur> Ops.
11:42:23 <Psybur> > foldr1 (.) [a,b,c]
11:42:25 <lambdabot>  error:
11:42:25 <lambdabot>      • Couldn't match expected type ‘a -> a’ with actual type ‘Expr’
11:42:25 <lambdabot>      • In the expression: a
11:42:54 <dsal> Lay-Z -- that's awesome
11:42:58 <geekosaur> > foldr1 (.) [f,g,h]
11:43:00 <lambdabot>  error:
11:43:00 <lambdabot>      • No instance for (Typeable a0)
11:43:00 <lambdabot>          arising from a use of ‘show_M827481539361158288431372’
11:43:04 <dmj`> dsal: glad someone picked up on that ;)
11:43:10 <geekosaur> oh, right, can't show the function
11:43:22 <geekosaur> simple-reflect has its limitations :(
11:43:30 <Psybur> :t foldr1 (.) [f,g,h]
11:43:32 <lambdabot> (FromExpr a, Show a) => a -> a
11:43:34 --- mode: ChanServ set +o geekosaur
11:43:44 <fishythefish> > foldr1 (.) [f, g, h] x
11:43:46 <lambdabot>  f (g (h x))
11:44:19 <Psybur> @karma fishythefish ++
11:44:19 <lambdabot> fishythefish has a karma of 0
11:44:20 <Psybur> :D
11:44:22 <Wizek> Could this be a bug in ghc-8.2.1's -XViewPatterns implementation? https://github.com/Wizek/aoc-2017/commit/bec7c38
11:44:24 <geekosaur> Psybur, and the reason that works is f,g,h (I think only those but check simple-reflect docs) are bound to functions on Exp
11:44:26 <geekosaur> :t a
11:44:27 <lambdabot> Expr
11:44:30 <geekosaur> :t f
11:44:31 <lambdabot> FromExpr a => a
11:44:57 <geekosaur> (and the magic is in FromExpr because simple-0reflect is an utter hack :) useful hack but nonetheless a hack\
11:45:07 <Wizek> `• Variable not in scope: r :: t -> t1 \n • Perhaps you meant ‘r’ (line 159)`
11:45:49 <geekosaur> Wizek, which ghc version is that?
11:46:07 <geekosaur> oh, you said. 
11:46:11 <Wizek> yup
11:46:25 <geekosaur> try it in 8.2.2, I think there was a bug (not in ViewPatterns, a bit deeper)
11:46:50 <Wizek> let me see if I can try it quickly
11:48:35 <dmj`> > maximum $ M.singleton “hey” 1000
11:48:37 <lambdabot>  <hint>:1:23: error: lexical error at character 'h'
11:48:53 <Wizek> fortunately nix has lots of binaries cached, hope all deps are compatible
11:48:56 <geekosaur> your client "smart"quoted you
11:49:41 <dmj`> ah :)
11:49:42 <dmj`> > maximum $ M.singleton "hey" 1000
11:49:44 <lambdabot>  1000
11:50:43 <dsal> What is M?
11:51:11 <Wizek> geekosaur: done, same error
11:51:14 <monochrom> probably Data.Map
11:51:21 <dsal> Oh, that makes sense, yeah.
11:52:13 <aberrant> ok, back to monad challenges today :)
11:52:23 <geekosaur> Wizek, :( can you put the code (or similar code that reproduces it) somewhere? (not that I would be able to do much as my network is being wonky)
11:55:44 <Wizek> geekosaur: sure, one sec
11:58:21 <Wizek> geekosaur: here is the repo witn ghc822: https://github.com/Wizek/aoc-2017/compare/bec7c38%5E...a3cf88e if you check out a3cf88e, hav nix installed, all you need to do is ./run.sh and watch as it repros.
11:59:22 * hackage groundhog-th 0.8.0.2 - Type-safe datatype-database mapping library.  https://hackage.haskell.org/package/groundhog-th-0.8.0.2 (BorisLykah)
11:59:54 <gehn> would it be safe to assume that https://wiki.haskell.org/Web/Frameworks is in order of general popularity and quality? i.e. robust, good docs, etc
12:00:02 <gehn> with outdated or less relevant items towards the end?
12:00:23 <geekosaur> as the parenthetical said, I'm not actually going to be able to do much :( irc is over a cellmodem but everything else is on wired which ... well, have been trying to load my inbox for the past 5 minutes.
12:00:51 <mniip> ouch
12:01:04 <Wizek> geekosaur: oh, how come you ended up like that?
12:01:14 <geekosaur> I'm at a cheap motel
12:01:18 <geekosaur> and cellmodems are kinda pricey
12:01:40 <dmj`> gehn: yea
12:02:13 <mniip> a cellmodem probably wouldn't bear *my* irc traffic
12:02:25 <dmj`> gehn: no order of being more current or outdated though
12:02:47 <dmj`> gehn: happstack might be oldest and its first
12:02:47 <geekosaur> (and redirecting something to cellmodem means playing with routes. easy enough to reroute the irc bouncer but webmail is a rat's nest of addresses
12:02:50 <dmj`> it’s*
12:03:06 <geekosaur> gehn, note tat that wiki page is probably a bit out of date
12:03:38 <mniip> hehe
12:03:47 <mniip> I recently wrote a script so that I could steal internet easier
12:03:55 <ph88> can i create a class KnownPos for a type-level positive number ? [1..inf] similar to https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html#t:KnownNat
12:04:08 <mniip> it comes up with a subnet and then edits the route table so that all my internet goes through an ssh tunnel
12:04:24 <ph88> can ghc then also infer that all functions that use KnownPos are also compatible with KnownNat (but not the other way around)  ?
12:05:27 <geekosaur> ph88, I think you can't easily do that just with standard facilities. but there are ghc plugins that can make it easier (check the plugins category on hackage)
12:05:45 <gehn> geekosaur, do you have any recommendations?
12:05:53 <gehn> either for frameworks or a page that's less out of date?
12:06:06 <geekosaur> this runs into ghc's dialect of haskell trying to pretend it has dependent types when it doesn't
12:06:32 <geekosaur> and distinguishing KnownPos from KnownNat really wants dependent types
12:06:43 <ph88> geekosaur, you mean DataKinds ?
12:07:40 <gehn> happstack.com appears to be down?
12:07:43 <geekosaur> gehn, no, sorry. that was more a genereral "wiki is not well maintained"" thing
12:07:52 <gehn> ok
12:08:02 <Psybur> Does the concept of "src/test/resources" translate over to stack in any way?
12:08:25 <aberrant> wow, I'm lost here.
12:08:40 <geekosaur> ph88, no I didn't. if what I said didn't make sense then ... you may be in deeper than you are prepared for
12:09:03 <mud> Psybur: stack really just uses the same concepts as cabal-install for that stuff, whatever you're specifying in the .cabal file should work fine in stack as well.
12:09:08 <dminuoso> Is there some way to write this more elegant? (MaybeT mf) <*> (MaybeT mv) = MaybeT $ (<*>) <$> mf <*> mv
12:09:41 <Psybur> So cabal has something similar like gradle/maven do? Ok Ill refine my google searches
12:10:03 <dminuoso> Im trying to look very hard for some case to use (<*>) . (<*>) but I cant see it.
12:10:17 <mud> Err, I thought you were talking about something that you were copying over from cabal already. If not, then ... ignore that, I don't know what you're referring to.
12:11:16 <Psybur> mud, Im using hspec and Im wondering where I should be putting my test files. I know pretty much nothing about proper testing practices in haskell/cabal/stack
12:11:30 <Psybur> Test files as in input to the things running in my tests
12:11:58 <ph88> geekosaur, yes i'm not prepared for anything :P
12:12:04 <ph88> what are promoted functions ?
12:12:59 <geekosaur> in what context?
12:13:31 <mud> Psybur: Maybe something like the data-files config in the .cabal file, though I'm not sure that sounds exactly right.
12:14:23 <geekosaur> mud, Psybur: stack has problems with data-files because data files kinda don't obey any useful rules. cabal handles them but with a hack, and stack gets confused easily by the hack.
12:14:58 <mud> Hm
12:15:32 <geekosaur> specifically, cabal uses a generated Paths_* module... but it has to be different for uninstalled vs installed. this is nasty to get right, and while an all-cabal thing usually manages it, stack can't see the trickery that cabal is using to do it and becomes confused.
12:16:08 <geekosaur> (this isn't really a stack problem as such, it's just that it's really hard to get right)
12:16:12 <Psybur> geekosaur, do you have an idea where test resources should go?
12:16:12 <mud> Oh, that's what those weird Paths things are. I never did quite understand those.
12:17:56 <geekosaur> it also means cabal knows it needs to rebuild the program to install it with the installed path instead of the dev path, which is part of the trickery that stack can't see going on
12:19:44 <geekosaur> also I should be clearer, this trickery is mostluy in Cabal-the-library not cabal-install --- although cabal-install knows about it to some extent.
12:19:46 <haskellLearned> Hello, can anyone help me install and use Haskell using Atom?
12:20:05 <haskellLearned> I have looked at the documentation but it always seems to fail. :(
12:20:46 <gehn> hmm, stack doesn't appear to want to install snap
12:21:04 <gehn> it appears stack and cabal are similar or the same?
12:21:09 <gehn> should I just use cabal instead?
12:21:17 <haskellLearned> I cna't install Cabal independently.
12:21:22 <haskellLearned> Do you know how?
12:21:30 <geekosaur> they solve the same problem in different ways. each way has some advantages and some disadvantages
12:21:33 <gehn> the snap site instructions are for cabal
12:21:36 <haskellLearned> I can simply install Stack from Terminal.
12:21:45 <haskellLearned> But Cabal, I cannot seem to.
12:22:36 <geekosaur> haskellLearned, that may be a bit of confusion. 'Cabal' is a library; the *program* "cabal" is cabal-install. (because the library predates the program by close to a decade)
12:22:44 <gehn> haskell-platform for Ubuntu LTS only appears to be 7.x
12:22:56 <gehn> is that a problem? should I attempt to start new projects on 8.x?
12:23:13 <haskellLearned> geekosaur, Is there a way I can install cabal-install through my terminal?
12:23:19 <haskellLearned> I think Atom may not like Stack.
12:24:24 --- mode: cherryh.freenode.net set +o ChanServ
12:26:19 <geekosaur> haskellLearned, you should be able to but it depends on how you were trying to do it. if you need to do it without using your OS's package manager (if any...) and without anything else but plain ghc, you need to use the cabal-install bootstrap build or a prebuilt executable that you should be able to download from haskell.org/cabal
12:26:35 <geekosaur> or install the latest binary haskell platform which gives you both cabal and stack
12:26:43 <ph88> richard eisenberg on irc ?
12:26:49 <ph88> There are whispers afoot of going in the direction of strapping an SMT solver into GHC, though much work remains to be done before this happens. My sense is that an SMT solver will be necessary before TypeLits really becomes fluently useful. I'm confident this will happen eventually, but it may be over a year out, still. It's even possible that I will be the one to do it, but it's not on my short-to-do-list.
12:27:44 <geekosaur> ph88, sometimes but rarely in here and I don;t see him in #ghc at the moment
12:28:11 <cocreature> ph88: you’re too late https://github.com/yav/type-nat-solver
12:28:13 <geekosaur> one of the ghc plugins I mentioned does hook an smt solver in, iirc, but only in simple-ish ways
12:28:30 <ph88> cocreature, i was quoting
12:28:38 <ph88> from 2014
12:28:39 <geekosaur> whereas eisenberg was I think talking about a closer integration there
12:28:53 * hackage brittany 0.9.0.0 - Haskell source code formatter  https://hackage.haskell.org/package/brittany-0.9.0.0 (lspitzner)
12:42:52 <ph88> so what's the latest news actually about getting a solver into ghc ? since i'm reading stuff from 2014
12:48:34 <ph88> i found at least 3 different packages/plugins that address this situation o_O
12:53:11 <aberrant> is there an online / feedback forum for haskell newbies? I hate to bother this group with my basic questions.
12:54:48 <koala_man> aberrant: it's fine, but there's also #haskell-beginners
12:55:16 <mizu_no_oto> aberrant: there's also /r/haskellquestions on reddit, but honestly, this is a great place to bother with beginner questions
12:55:52 <mizu_no_oto> People are usually happy to help
13:00:23 * hackage tidal 0.9.5 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-0.9.5 (AlexMcLean)
13:01:53 * hackage q4c12-twofinger 0 - Efficient alternating finger trees  https://hackage.haskell.org/package/q4c12-twofinger-0 (quasicomputational)
13:02:59 <daey> when writting 'data DayOfWeek = Mon' then im creating Mon which is of the type DayOfWeek?
13:03:08 <dminuoso> Hi. Im getting a diagnostic that I cant make sense of. I would appreciate any input: https://gist.github.com/dminuoso/0a3f680c831b5af6e808e4dd93082ae8
13:03:46 <dminuoso> I'd prefer not being spoonfed the exact mistake Im doing, but Im trying to understand what the exact issue is. What is that `f0` and where does it come from?
13:04:27 <fishythefish> daey: yes, you're declaring DayOfWeek to be a type and Mon to be a value constructor for it
13:05:24 <ph88> if i type  KnownNat (n + 1)   does that mean 1 or bigger natural number ?
13:05:59 <fishythefish> dminuoso: f0 is the name being assigned to whatever Applicative you're getting from `pure`
13:06:26 <dminuoso> Oh!
13:06:48 <fishythefish> Hopefully that was both vague enough and specific enough :)
13:08:09 <dminuoso> fishythefish: Absolutely, thank you.
13:09:48 <dminuoso> fishythefish: How am I not getting a Kind error?
13:09:59 <fishythefish> dminuoso: where's the kind mismatch?
13:10:21 <dminuoso> Let me ponder on this and get back to you.
13:11:05 <fishythefish> type errors come from values going where they shouldn't; kind errors come from types (or type constructors, etc.) going where they shouldn't
13:12:32 <ph88> one hour later realizing the thing i wanted was already right in front of me -____-
13:12:48 <byorgey> dminuoso: the only way you can get a kind error is if you write an explicit type signature and it contains an error.
13:13:40 <dminuoso> byorgey: I was doing that and I messed up :-)
13:13:58 <dminuoso> fishythefish: mistake found.. turns out I was thinking too far ahead..
13:14:06 <dminuoso> Im writing Reader not ReaderT :-)
13:15:57 <dminuoso> (Reader rf) <*> (Reader rv) = Reader $ \e -> rf e (rv e) -- looks much better =)
13:17:22 * hackage tidal-midi 0.9.5.2 - MIDI support for tidal  https://hackage.haskell.org/package/tidal-midi-0.9.5.2 (AlexMcLean)
13:20:56 <aberrant> fishythefish: do you have 5 mins for some hand-holding?
13:21:02 <fishythefish> aberrant: sure
13:21:13 <aberrant> thanks. Mind a privmsg?
13:21:13 <fraktor> I'm just getting started in haskell, and I'm having a little trouble doing something that should be very simple. I want to take a string that is of the format "YYYY-MM-DDTHH:MM:SS <double>" and parse it into a tuple of type (String, Double). I can't for the life of me figure out how to do that.
13:21:16 <fishythefish> go for it
13:23:37 <mnoonan> fraktor: what do you want to have happen when the input is malformed in various ways?
13:24:50 <fraktor> I'm fine with the string just being the first "word" and the double being completely invalid. I'm running this in a controlled environment, so if there are any malformed expressions, I want it to fail hard.
13:24:53 * hackage q4c12-twofinger 0.0.0.1 - Efficient alternating finger trees  https://hackage.haskell.org/package/q4c12-twofinger-0.0.0.1 (quasicomputational)
13:25:04 <dsal> Is '\190167' even a valid character?   This is messing with me.
13:25:24 <mnoonan> fraktor: in that case...
13:25:27 <drdo> fraktor: then just do something like: break isSpace
13:25:38 <drdo> I'm sure you can figure out the rest
13:25:46 <barrucadu> See also, the `words` function
13:25:52 <verement> > case (words "YYYY-MM-DDTHH:MM:SS 3.14") of [s,d] -> (s, read d :: Double)
13:25:53 <mnoonan> @let fraktor x = let [s,d] = words s in (s, read d :: Double)
13:25:54 <lambdabot>  ("YYYY-MM-DDTHH:MM:SS",3.14)
13:25:54 <lambdabot>  Defined.
13:25:58 <drdo> oh yeah words is better
13:26:03 <mnoonan> verement: get out of my head!
13:26:49 * verement grins.
13:26:51 <mnoonan> @let fraktor x = let [s,d] = words x in (s, read d :: Double) -- typo :|
13:26:52 <lambdabot>  .L.hs:175:1: warning: [-Woverlapping-patterns]
13:26:52 <lambdabot>      Pattern match is redundant
13:26:52 <lambdabot>      In an equation for ‘fraktor’: fraktor x = ...
13:27:44 <fraktor> mnoonan: Do you have a little bit of time to explain that syntax to me? It's not clear.
13:28:14 <fraktor> Or at least point me to somewhere online where I can read about it? I'm looking at Learn You a Haskell right now.
13:28:32 <mnoonan> fraktor: the "let [s,d] = ..." is pattern-matching on the result of "words x", and will blow up if "words x" evaluates to anything other than a 2-element list
13:28:58 <mnoonan> verement's one-pattern case expression does the same thing, and is probably clearer anyway
13:29:21 <fraktor> What does case mean?
13:30:12 <drdo> I'm trying to write some java after a long stretch of writing basicaly only haskell. This is brutal
13:30:26 <mnoonan> fraktor: http://learnyouahaskell.com/syntax-in-functions#case-expressions
13:31:38 <fraktor> So when (words str) matches [s, d], then return (s, read d :: Double)?
13:31:54 <mnoonan> right
13:34:56 <fraktor> That's much clearer. Thanks!
13:44:15 <ph88> when i have a    KnownNat n => BitVector (n + 1)    how can i  SNat n  using type application ?  https://hackage.haskell.org/package/clash-prelude-0.11.2/docs/CLaSH-Sized-BitVector.html   https://hackage.haskell.org/package/clash-prelude-0.11.2/docs/CLaSH-Promoted-Nat.html    https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
13:53:22 <fraktor> I'm having another problem. I want a function to read lines from a file, parse those lines, and then return the list of parsed lines. How do I do that?
13:56:27 <dminuoso> drdo: https://ro-che.info/ccc/29
13:56:34 <drdo> fraktor: At this point you're basically using the channel as free labour :P
13:56:42 <drdo> fraktor: Go read the book, come on
13:56:53 <drdo> dminuoso: hahaha
13:57:03 <fraktor> drdo: You've got a point.
13:58:10 <dminuoso> drdo: Honestly the opposite (I dont come from Java though) seems to hold true.
13:58:23 <dminuoso> Basically 0 experience and knowledge can be transported from imperative into pure functional.
13:58:49 <dminuoso> Just some minor language features I recognize like typeclasses
13:59:26 <drdo> dminuoso: I've been doing functional programming for too long to remember what the difficulty is
14:00:19 <drdo> My issue with java is that it's just so hard and verbose to do *anything*
14:01:05 <dsal> Can't find forests in java class trees.
14:01:21 <dminuoso> The difficulty is just in accepting an alien mindset, while staring at your toolbox of paradigms and patterns - but none of them fit.
14:01:46 <drdo> dminuoso: What is alien about it?
14:01:49 <platz> right, anything with practice can become familiar
14:02:11 <drdo> I'm not even sure what we mean with "functional programming" to be quite honest
14:02:20 <drdo> We have functions, and we compose and apply them
14:02:30 <dminuoso> drdo: Well one thing that has been annoying is the inability to just quickly sneak in a debugging print.
14:02:53 <drdo> dminuoso: yes, that annoys me too. But that's not really about functional programming, it's really about lazyness
14:03:03 <dminuoso> drdo: And purity.
14:03:18 <platz> dminuoso: Debug.Trace.traceShow, Debug.Trace.traceShowId
14:03:21 <dminuoso> Mmm.
14:03:21 <drdo> we have unsafePerformIO, so that's not really an issue
14:03:29 <exio4> dminuoso: that comic is so freaking true :p 
14:05:59 <platz> https://hackage.haskell.org/package/base-4.10.1.0/docs/Debug-Trace.html#v:traceShowId
14:08:35 <dsal> I don't use Debug.Trace as much as I did when starting out, but it's helpful when I get lost.  :)
14:09:55 <mud> I use Debug.Trace like, almost anytime I have to debug anything. So pretty much anything that doesn't run correctly the first time it compiles.
14:17:43 <srpx_> silly suggestion: `fn (Foo a a) = ...` as a syntax sugar for `fn (Foo a a_) | a == a_ = ...`
14:18:30 <mniip> yay more hidden contexts in patterns
14:18:52 <SrPx> mniip what does that mean?
14:18:53 * hackage q4c12-twofinger 0.0.0.2 - Efficient alternating finger trees  https://hackage.haskell.org/package/q4c12-twofinger-0.0.0.2 (quasicomputational)
14:20:42 <mniip> (Foo a a) is a pattern
14:20:47 <mniip> (Eq t) is a context
14:21:06 <mniip> there's already a bit of context with literal matching
14:21:11 <mniip> :t \1 -> undefined
14:21:12 <lambdabot> (Num a1, Eq a1) => a1 -> a2
14:21:55 <mniip> but also here's this,
14:22:02 <mniip> should 'f a a = ...' abide to the same rules?
14:22:04 <SrPx> ah, I see
14:22:32 <SrPx> Why not? Glad you share my excitement for more hidden contexts!
14:22:34 <mniip> what about 'let a = ... in let f a = ...'
14:22:51 <SrPx> nah not that
14:22:58 <mniip> yeah right can't have that
14:23:11 <mniip> hmm
14:23:15 <mniip> :t \a a -> ()
14:23:17 <lambdabot> error:
14:23:17 <lambdabot>     • Conflicting definitions for ‘a’
14:23:17 <lambdabot>       Bound at: <interactive>:1:2
14:23:27 <mniip> I guess it's always invalid syntax
14:23:35 <mniip> so I don't see why it can't be an extension
14:23:37 <fraktor> I'm trying to write a program that scans through two files looking for descrepancies. I've gotten file IO working (I think), but I'm having trouble writing the function that actually processes the entries.
14:24:03 <mniip> fraktor, is this an exercise (whether external or internal) or a practical issue?
14:24:32 <fraktor> mniip: It's an exercise. I've already completed the actual assignment though; I'm trying to use this to learn Haskell, rather than learn how to solve the problem.
14:24:55 <mniip> I mean I could give you a package and a module name that solves this problem
14:25:03 <mniip> if this is an exercise I would do otherwise
14:36:47 <dminuoso> Why is it.. that every deeply categorical looking library I look at on hackage seems to have ekmett as maintainr?
14:37:11 <dminuoso> Just had the idea that surely a Biapplicative must exist - and no surprise it was there.
14:37:26 * hackage nonce 1.0.5 - Generate cryptographic nonces.  https://hackage.haskell.org/package/nonce-1.0.5 (ErikDeCastroLopo)
14:42:16 <boj> dminuoso: edwardk is a mathematician/programmer who has written ~250 libraries on hackage, a good chunk related to CT :)
14:42:37 <dminuoso> That's a mighty lot.
14:42:43 <mud> He is a beast
14:43:28 <mniip> I aspire to be like him :o
14:43:54 <boj> is there anything left to write? :s
14:43:58 <mniip> but I don't know if I've enough years on this planet to achieve that level
14:44:06 <mniip> boj, sure
14:44:09 <mniip> all kinds of things
14:44:24 <mniip> it's just that you're looking at things that are written
14:44:29 <mniip> of course everything that is written is written
14:44:37 <boj> ok, so edwardk didn't hog it all
14:47:15 <hololeap> is there a legible way to write ((a -> b) -> (a -> c) -> (b -> c -> d) -> (a -> d)), other than \f g h x -> h (f x) (g x)
14:47:51 <c_wraith> that depends on your definition of legible. :)
14:48:03 <dminuoso> boj: Just find a field edward has no deep experience in. Like topology or differential geometry and just fill hackage!
14:48:14 * hackage vault-tool 0.0.0.3, vault-tool-server 0.0.0.3 (BitConnor): https://qbin.io/aaf9zcu6
14:48:26 <c_wraith> you could write it as liftA2 h f g
14:48:35 <c_wraith> but... that's not really better.
14:48:41 <boj> dminuoso: indeed :)
14:48:52 <hololeap> right... that's using the Reader functor, right?
14:49:06 <c_wraith> well, Applicative in this case. but yes.
14:49:46 <geekosaur> :exf "(a -> b) -> (a -> c) -> (b -> c -> d) -> (a -> d)"
14:49:47 <exferenceBot> \ f1 f2 f3 d -> f3 (f1 d) (f2 d)
14:50:19 <geekosaur> that would suggest "no" although exferencebot isn't all-knowing :)
14:50:34 <geekosaur> (liftA2 being an example thereof)
14:51:44 <hololeap> i thought of (\f g h -> curry h . (f &&& g)), although that's not very legible either. ok, just checking
14:52:40 <sh4pe[m]> Hi guys! Could anyone be so kind as to assist me in reading [this](https://kseo.github.io/posts/2017-01-15-data-proxy.html) article about Data.Proxy?
14:53:31 <sh4pe[m]> You can find this type signature: `f :: forall proxy a. (Read a, Show a) => proxy a -> String -> String`. What does the lowercase `proxy a` mean there? I know `Proxy`, but `proxy`?
14:53:58 <dminuoso> geekosaur: Is `liftA2 h f g` preferrable to `h <$> f <*> g` ?
14:54:15 <geekosaur> depends on context and on personal preferences
14:54:37 <fishythefish> sh4pe[m]: think for forall b a. but now rename b to proxy
14:54:38 <MarcelineVQ> sh4pe[m]: idk about Proxy but in that examply proxy is like   a   but longer, lower case things in signatures are type variables regardless of length
14:54:55 <geekosaur> sh4pe[m], normally one would write that as Proxy, but that turns out to be unnecessarily limiting
14:55:23 <geekosaur> if you have a Maybe a and want a Proxy a to use in a situation like that, it's kinda silly to make you jump through hoops to get a Proxy when it's all the same thing to the typechecker
14:55:40 <geekosaur> so proxy instead of Proxy and let the typechecker sort it out :)
14:56:15 <c_wraith> it's worth noting that it still achieves the goal of a type that you provable can't use at the value level.
14:56:17 <sh4pe[m]> Ah - so `proxy` is just a type variable... thank you]
14:56:52 * hexagoxel never added ((->) a) instances to exferenceBot's dictionary. Those are rarely useful and mostly good for code-golfing imo.
14:56:54 <sh4pe[m]> Now I see that my question was not very clever :D
14:57:15 <c_wraith> because proxy is an unknown type, you can't do anything to get a value of type a out of a value of type proxy a, just like Proxy a
14:57:16 <geekosaur> ...but to make it more clever you'd probably have needed to know the answer before asking
14:57:17 <mud> hexagoxel: But code golfing is funnnn.
14:57:38 <c_wraith> sh4pe[m], nothing wrong with that question. there's something interesting going on there
15:00:53 <hololeap> @pl (\f g h x -> h (f x) (g x))
15:00:53 <lambdabot> flip . (ap .) . flip (.)
15:00:59 <hololeap> ah, much better
15:01:09 <hololeap> btw, what does :exf do?
15:01:28 <c_wraith> yes, @pl output is always the most readable.
15:01:34 <mniip> agreed
15:01:36 <mud> It's a type-driven automatic function finder thingie
15:01:50 <mniip> @pl \x y z w -> w z y x
15:01:50 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
15:02:01 <mniip> @pl \x y z w u v -> v u w z y x
15:02:02 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
15:02:05 <mniip> ahh beautiful
15:02:10 <mniip> music to my ears
15:02:12 <geekosaur> hololeap, https://github.com/lspitzner/exference
15:02:40 <geekosaur> if you've played with @djinn, it's that on steroids (or possibly meth)
15:03:10 <Tuplanolla> Stop giving drugs to computers.
15:03:23 <hololeap> i've heard of djinn, never tried it though. i've used hlint though.
15:03:50 <c_wraith> speaking of, is ghci on acid maintained?
15:06:55 <mniip> did you mean: is ghci maintained on acid
15:07:08 <fraktor> I've profiled my program, and I'm finding that there is a bottleneck where I'm converting my string to a double. Is there a faster way than using read?
15:07:23 <mniip> yeah, use show
15:07:52 <fraktor> I'm sorry? I thought that converted doubles to strings.
15:08:00 <mniip> oops
15:08:07 <mniip> I misread
15:08:16 <mniip> how many doubles are we talking?
15:08:22 <c_wraith> that read instance is notoriously slow.
15:08:32 <fraktor> Up to a million.
15:08:44 <c_wraith> that really isn't that many.
15:08:47 <fraktor> My program is currently running in about 20 seconds, which isn't *terrible,* but the C equivalent runs in 1.
15:09:10 <hololeap> would attoparsec work? i've never used it :(
15:09:14 <c_wraith> but yeah, the Read instance for Double is slow.
15:09:18 <geekosaur> the C equivalent is heavily optimized, the Haskell one isn't
15:09:40 <geekosaur> mostly because there's a feeling that if you're doing that, you should rethink your approach
15:10:00 <geekosaur> (not always justified, but often true)
15:10:12 <mniip> I disagree
15:10:16 <fraktor> geekosaur: I'm reading files that have a million lines of the form [date] [temperature].
15:10:16 <geekosaur> well.
15:10:24 <mniip> there's no bad in optimizing the simple tools
15:10:25 <fraktor> I need to parse that temperature.
15:10:40 <mniip> I mean look at grep
15:10:50 <geekosaur> on the one hand, serializing Doubles as strings is a fairly lousy and lossy way to pass them around. on the other, it's pretty much the only *portable* way
15:11:56 <geekosaur> not to mention the only way you're going to pass them between computers and humans, at least if you're expecting the human to understand it
15:12:23 <mniip> I can kinda understand iee754 binary formats
15:12:41 <fraktor> I'm writing a program based on someone else's file specification. I agree with you, but I can't change it.
15:13:09 <glguy> jle`: We got lucky on Day 7, Eric make the input easy
15:13:17 <mniip> 7F800000 is 1
15:13:42 <mniip> no wait
15:13:46 <mniip> 3F800000
15:15:03 <mniip> 7F800000 is positive infty
15:16:01 <hololeap> fraktor: there are number/float parsers in attoparsec, which is supposed to be very fast. i've never used it though
15:17:12 <fraktor> I can't seem to include the attoparsec library. Does it come with the default ghc installation?
15:17:53 <hololeap> fraktor, i believe it's part of the haskell "platform"
15:18:12 <hololeap> which is a bunch of packages that are sometimes bundled with ghc
15:18:45 <hololeap> but you can always cabal install it
15:21:08 <lyxia> What laws does MonadCont have?
15:21:54 <hololeap> fraktor, look at Data.Attoparsec.Text.double
15:48:34 <Franciman> How can I decompress a .zip file in Haskell?
15:49:49 <a_nix_beginner> hello, i am using nix and hello how do i set haskellPackages to point to haskell.packages.ghc822 instead? it's using ghc802 by default
15:51:08 <alp> Franciman, https://hackage.haskell.org/package/zip-archive-0.3.1.1/docs/Codec-Archive-Zip.html#v:extractFilesFromArchive would work
15:51:17 <Franciman> thanks
15:51:25 <alp> the library offers a bunch of functions for dealing with zip archives and inspecting them
15:52:03 <alp> a_nix_beginner, you can do that in your ~/.config/nixpkgs/config.nix
15:53:21 <alp> a_nix_beginner, with something like: { packageOverrides = ps: rec { haskellPackages = haskell.packages.ghc822; }; } I think
15:53:33 <alp> err, no need for 'rec' there
15:54:14 <a_nix_beginner> alp thank you i am looking into nix documentation for configuration :)
15:54:27 <alp> err, and it should be ps.haskell.packages.ghc822 
15:54:47 <a_nix_beginner> what does this ps stand for?
15:56:02 <alp> a_nix_beginner, so 'packageOverrides' must be a function that takes the "non-overriden" (original) nixpkgs package set and provides some overrides, for some parts of the huge package set.
15:56:19 <alp> 'ps' is the name I gave to the function's argument, with "packages" in mind.
15:56:50 <a_nix_beginner> ah does the rec stand for recursive function ?
15:57:13 <alp> and yeah you just have to stick that little bit of code under ~/.config/nixpkgs/config.nix and after that haskellPackages should be the package set for ghc 8.2.2
15:57:26 <a_nix_beginner> nvm i go read the documentation sorry for the bother 
15:57:53 <a_nix_beginner> thanks for the help
15:57:54 <alp> not recursive function, recursive attribute set (or record, if you will), which means that fields can refer to each other in their definitions.
15:58:23 * hackage jose-jwt 0.7.8 - JSON Object Signing and Encryption Library  https://hackage.haskell.org/package/jose-jwt-0.7.8 (LukeTaylor)
16:54:02 <dminuoso> How do I golf this into point free? pure a = Cont $ \c -> c a
16:54:18 <mniip> Cont ($ a)
16:54:23 <mniip> Cont . flip id
16:54:57 <dminuoso> Ah! That's what I was looking for. Finally I get to see `flip id` in action, thanks mniip 
16:55:06 <mniip> flip ($) is more readable
16:55:14 <Welkin> dminuoso: some advice, Don't
16:55:16 <mniip> but really this doesn't need to be point free
16:55:22 <mniip> pure a = Cont ($ a)
16:55:24 <mniip> is best
16:55:28 <hpc> i would write... yeah that
16:55:34 <mniip> though with cont...
16:55:40 <mniip> maybe explicit lambdas are even better
16:55:43 <Welkin> yes
16:55:48 <mniip> considering you're about to write ap
16:56:30 <mniip> writing <*> without explicit continuation passing you can accidentally miss the whole point
16:56:38 <mniip> I did the first time around
16:56:38 <dminuoso> mniip: Not happy about my: (ContT cf) <*> (ContT cv) = ContT $ \c -> cf $ \f -> cv (c . f)
16:57:39 <mniip> mine looked like
16:57:40 <mniip>     Cont fc <*> Cont xc = Cont $ \k -> fc (\f -> xc (\x -> k (f x)))
16:58:14 <mniip> the imporant part being k (f x)
16:58:24 <mniip> and taking f from fc, x from xc, etc
16:58:25 <hpc> there's not a whole lot you can do with that, without sacrificing readability even more imo
16:59:30 <hpc> except maybe cheat and define it as (<*>) = ap, then move straight onto (>>=) or join
17:00:16 <dminuoso> hpc: ertes has suggested to not do that, but instead to just define it raw from an applicative perspective
17:00:27 <dminuoso> (as a general thing I mean)
17:00:29 <hpc> yeah, hence "cheat" ;)
17:00:39 <dminuoso> ah :)
17:01:54 <hpc> (<*>) doesn't really translate well onto my mental model of what Cont expresses
17:02:18 <hpc> i think the best insight you can get out of that definition is that in terms of functions it's just a particularly tangled way of composing them
17:02:53 <hpc> unless there's a better way to write it
17:06:48 <dminuoso> mniip: Yeah I had that exactly originally but figured "why not golf it further" - and you are right, the code lost the exact expressivity about k (f x)
17:07:04 <dminuoso> So I guess there's such a thing as `overgolfing`
17:07:34 <mniip> import System.Environment;t=1>0;z=pure;q=0:q;d=(`mod`256);k@('[':w)#m|(_,0:_)<-m=s w#m|t=w#m>>=(k#);(x:w)#m|']'<-x=z m|t=m&x>>=(w#);_#m=z m;s(p:w)|']'<-p=w|'['<-p=s$s w|t=s w;m@(l@(f:g),c:r)&p|'+'<-p=z(l,d(c+1):r)|'-'<-p=z(l,d(c-1):r)|','<-p=(,)l.(:r).toEnum.fromEnum<$>getChar|'>'<-p=z(c:l,r)|'.'<-p=putChar(toEnum.fromEnum$c)>>z m|'<'<-p=z(g,f:c:r)|t=z m;main=getArgs>>=(#(q,q)).head
17:07:39 <mniip> tell me more about it
17:07:51 <mniip> no actually one sec lemme get the updated version
17:08:00 <mniip> import System.Environment;t=1>0;z=pure;q=0:q;d=(`mod`256);k@('[':w)#m|(_,0:_)<-m=s w#m|t=w#m>>=(k#);(x:w)#m|']'<-x=z m|t=m&x>>=(w#);_#m=z m;s(p:w)|']'<-p=w|'['<-p=s$s w|t=s w;m@(l@(f:g),c:r)&p|'+'<-p=z(l,d(c+1):r)|'-'<-p=z(l,d(c-1):r)|','<-p=(,)l.(:r).d.fromEnum<$>getChar|'>'<-p=z(c:l,r)|'.'<-p=putChar(toEnum c)>>z m|'<'<-p=z(g,f:c:r)|t=z m;main=getArgs>>=(#(q,q)).head
17:09:14 <barrucadu> I thought this was #haskell, not #perl
17:09:29 <mniip> that's haskell code there
17:09:36 <barrucadu> Sadly
17:09:57 <mniip> I like it :P
17:10:21 <mniip> especially this part:  s(p:w)|']'<-p=w|'['<-p=s$s w|t=s w
17:32:23 * hackage random-class 0.1.0.0 - Class of random value generation  https://hackage.haskell.org/package/random-class-0.1.0.0 (MatthewFarkasDyck)
17:44:48 <mniip> hmm
17:44:59 <mniip> is there a "canonical" type for
17:45:06 <mniip> either a failure, or success, or needs more consideration
17:45:11 <Welkin> Ubuntu?
17:45:20 <geekosaur> heh
17:45:22 <Welkin> mniip: are you Mark Shuttleworth?
17:45:30 <Welkin> it's been you the whole time!
17:45:46 <mniip> no but I can mark worthy shuttles
17:46:05 <geekosaur> I don't thinbk there's a standard one as such although you could probably interpret one of the stream types that way
17:46:32 <mniip> Either (Maybe String) (String, [Cell], Program, ([Cell], Cell, [Cell]))
17:46:33 <geekosaur> problem being 'needs more consideration' is kinda hard to generalize in a way that's actually reusable
17:46:34 <mniip> I feel horrible
17:46:42 <Welkin> mniip: quantum bit?
17:47:43 <geekosaur> (except the trivial one which is barely worth considering since you can wrap something else in ExceptT to get it)
17:49:11 <mniip> I'm guessing this is combination of iteration in the sense of []
17:49:14 <mniip> where you can mfilter
17:49:22 <mniip> and output of successes in the sense of Writer
17:52:27 * hackage random-class 0.1.1.0 - Class of random value generation  https://hackage.haskell.org/package/random-class-0.1.1.0 (MatthewFarkasDyck)
18:10:20 <Cale> mniip: Maybe (Either ...) ?
18:11:00 <Wizek> mniip: `Either (Either a b) c`?
18:11:43 <Cale> i.e. Nothing -> needs more consideration, Just (Left e) -> failure (with some information), Just (Right x) -> success
18:11:52 <Wizek> mniip: Right: success, Left Left: definitely failure, Left Right: Somewhere inbetween
18:12:19 <mniip> nope
18:12:20 <Cale> But yeah, what "needs more consideration" means varies
18:12:29 <mniip> needs more consideration is the case where I have a continuation
18:12:42 <mniip> and success has a value to it
18:13:05 <Cale> Right, I was just going to say, perhaps the "needs more consideration" case wants to provide a continuation for more input
18:15:11 <mniip> ugh
18:15:16 <mniip> I don't think I can write this in haskell
18:16:05 <mniip> while all the possible abstractions are nice, the multiple-word-per-cons-cell thing is killing it
18:16:45 <mniip> why am I writing this at all...
18:17:03 <mniip> it's a stupid idea
18:19:17 <Wizek> mniip: what are you golfing?
18:19:23 <mniip> not golfing
18:19:26 <mniip> or hmm
18:19:29 <mniip> I guess I am meta-golfing
18:19:38 <mniip> I was thinking
18:19:55 <mniip> of diagonally simulating an infinite sequence of brainfuck programs
18:20:05 <mniip> to find the shortest/fastest one that has a particular behavior
18:20:30 <Wizek> how do you mean diagonally in this context?
18:22:04 <mniip> ugh, I was thinking it is a classic algorithm until I tried to explain it to a friend
18:22:14 <mniip> basically you have a list of machines currently in simulation,
18:22:27 <mniip> while (1) { step each machine by one; add one new machine to the list }
18:23:53 * hackage util 0.1.1.0 - Utilities  https://hackage.haskell.org/package/util-0.1.1.0 (MatthewFarkasDyck)
18:27:47 <Wizek> mniip: makes sense. But can't you only hope to find some local minima this way?
18:28:07 <mniip> sure
18:28:53 * hackage util 0.1.2.0 - Utilities  https://hackage.haskell.org/package/util-0.1.2.0 (MatthewFarkasDyck)
18:29:55 <Wizek> mniip: Wouldn't make more sense to train a neural network to golf brainfuck for you instead? :D 
18:30:43 <mniip> ehh
18:31:49 <crucify_me> http://lpaste.net/360618      hi I'm getting a parse error line 33 :  'possibly incorrect indentation or mismatched brackets '  --  I'm copying a textbook example .. possible typo ?
18:32:09 <crucify_me> typo in textbook
18:32:13 <mud> crucify_me: Missing ) on 31
18:32:27 <crucify_me> dang you're good 
18:32:32 <crucify_me> thanks
18:32:39 <mud> :) anytime
18:32:47 <mniip> I can see it with ease too
18:33:06 <mniip> mud is mediocre at best
18:33:11 <mniip> :p
18:33:14 <mud> Oh snap xD
18:34:02 * hackage util 0.1.2.1 - Utilities  https://hackage.haskell.org/package/util-0.1.2.1 (MatthewFarkasDyck)
18:37:20 <crucify_me> http://lpaste.net/360618   the case expression in the last function winner' is completely new and with precious little commentary in the book .
18:40:04 <crucify_me> is that notation "drawn from" like in a list comprehension?
18:40:32 <mniip> no
18:40:49 <mniip> "draws" are always <-
18:41:12 <crucify_me> yeah ..
18:41:20 <mniip> this is closer to function definition by equations
18:41:24 <mniip> I'm assuming you're familiar with that
18:41:40 <mniip> winner bs' = foo (rank (rmEmpty bs)) where
18:41:43 <mniip>  foo [c] = ...
18:41:48 <mniip>  foo (c:cs) = ...
18:42:44 <crucify_me> not familiar with this. sorry, foo is throwing me off a bit..
18:43:40 <crucify_me> this uses of  and not where
18:44:08 <mniip> case-of is a single construct
18:44:28 <crucify_me> sorry not following
18:44:30 <mniip> it evaluates an expression and then matches it against one of the provided patterns
18:47:00 <crucify_me> dammit I feel like the book just trails off here
19:03:53 * hackage random-class 0.1.2.0 - Class of random value generation  https://hackage.haskell.org/package/random-class-0.1.2.0 (MatthewFarkasDyck)
19:04:11 <dsal> Does anyone know why <> is called 'mappend' ?
19:05:00 <mniip> monoidal append
19:05:01 <dsal> Actually, it seems even more confusing with semigroup
19:05:09 <dsal> I mean, I know what it stands for, but why not just (<>) ?
19:05:16 <mniip> mappend is an older name
19:05:21 <mniip> than both <> and Semigroup
19:05:38 <mniip> we're talking 15 years older
19:05:53 <dsal> I assumed so.  Probably took a while to be considered valuable enough to burn a two character operator.
19:06:38 <dsal> Is there a way to get ghci to consider bare numbers as Int?
19:08:40 <systemfault> Like x = 10:Int  ?
19:08:46 <systemfault> Sorry
19:08:50 <systemfault> x = 10::Int
19:09:02 <dsal> Right.  I want that, but without the ::Int everywhere.  Is that possible?
19:09:07 <mniip> I suspect, but it's not going to be pleasant
19:09:20 <byorgey> dsal: out of curiosity, why do you want that?
19:09:23 <dsal> Eh, I'll work around it.
19:09:29 * byorgey suspects an XYZ problem
19:09:33 <mniip> :set -XRebindableSyntax
19:09:33 <dsal> Heh, yes.
19:09:44 <mniip> fromInteger i = Prelude.fromInteger i :: Int
19:09:49 <qmm> "mkSeed 1" produces Seed {unSeed = 1}. why can't I get the value of unSeed with the following:  unseed $ mkSeed 1 
19:10:04 <dsal> I wanted to explain a monoid related thing to someone who doesn't know haskell, and it was really easy for me to an instance of monoid for int in a session to describe it.
19:10:14 <dsal> But then I get this:
19:10:16 <dsal> λ> 1 <> 2
19:10:16 <dsal> 1 <> 2 :: (Num m, Monoid m) => m
19:10:29 <mniip> dsal, see above
19:10:53 <dsal> neat.  That's perfect.  Thanks.
19:11:55 <mniip> had to test it before insisting that it would work
19:12:07 <mniip> I don't think I've ever seen rebindable syntax used in this way
19:12:13 <byorgey> mniip: neat.
19:12:27 <mniip> people mostly use it for >>=/>> right?
19:13:13 <mniip> I guess you can also use it for fromInteger, fromString, fromList, == (in literal patterns),
19:13:35 <dsal> It's fine *in* the session, but not in a file.  That should be fine.
19:13:35 <mniip> Arrow syntax? whatever that desugars to...
19:13:40 <byorgey> yeah, my impression is that it's most often used for >>= / >>.
19:13:49 <byorgey> mniip: also I think  ifThenElse ?
19:13:52 <mniip> ah yes
19:13:54 <mniip> that
19:14:40 <mniip> hmm
19:15:01 <mniip> any other known cases of syntax desugaring to library names?
19:15:59 <mniip> MonadComprehensions
19:16:04 <mniip> but that's >>=/>> again
19:16:08 <mniip> and, well, return
19:16:37 <mniip> I do wonder,
19:16:37 <dsal> Actually, this gets much easier if I just use Integer.  heh
19:16:44 <mniip> why if I start ghci with -XRebindableSyntax
19:16:48 <mniip> it doesn't load Prelude
19:17:47 <lyxia> It implies NoImplicitPrelude
19:17:49 <mniip> oh and fromRational
19:17:57 <mniip> lyxia, I see
19:18:31 <mniip> oh do{} can also desugar into fail
19:18:37 <geekosaur> mniip, Prelude breaks kinda badly if you rebind some things
19:18:57 <mniip> geekosaur, does it
19:19:02 <geekosaur> (well, not Prelude specifically but some of the things it reexports from ghc's guts
19:19:04 <mniip> I mean it doesn't rebind *back into* prelude
19:19:26 <geekosaur> you get weird mismatches if the precompiled stuff using base's version mix with replacements
19:19:39 <mniip> again, it doesn't override anything in the interface
19:20:44 <geekosaur> well, there's user expectations
19:21:11 <geekosaur> there's also (although I'm not sure if this is better handled by disabling optimization, or if that just leads to even more obscure bugs) ...
19:21:23 <geekosaur> consider that many monads' (>>=) is exposed for inlining. that code really needs to match the compiled version or optimization decisions can cause different and weird behavior
19:21:30 <geekosaur> so bow you RebindableSyntax (>>=)
19:21:33 <geekosaur> *now you
19:21:45 <mniip> I expect the RULES pragma to internally store all identifiers qualified
19:22:22 <mniip> "Each variable mentioned in a rule must either be in scope (e.g. map), or bound by the forall (e.g. f, g, xs)."
19:22:34 <geekosaur> this isn't RULES, this is .hi exposures. and the real point here is that code exposed that way should behave the same way as the original
19:23:13 <geekosaur> rebind (>>=) and it probably takes place at a low enough level that ensuring the right one is used *when compiling code inlined from the .hi file* is nearly impossible
19:23:51 <geekosaur> although I may be thinking about this wrong (in which case (:) might be a btter example of that perhaps)
19:24:27 <geekosaur> real point is RebindableSyntax isn't as straightforward as you might think, especially since ghc "precaches" some definitions
19:25:21 <geekosaur> and can use those in places and then you RebindableSyntax and it's too late for it to update the precached names
19:25:38 <geekosaur> lemme find that stuff in the Commentary
19:25:57 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/WiredIn
19:27:09 <mniip> that I know
19:27:19 <mniip> but it goes extra lengths to make sure everything is qualified
19:27:26 <mniip> I mean
19:27:32 <eacameron> Does anyone know how to write a file server in servant that does *not* just rely on serving up static directories? I want to do database logic in the handler and then serve up arbitrary files with unknown content type (a-prior, that is)
19:27:35 <geekosaur> and that page doesn't discuss the interaction with RebindableSyntax but iirc the dpcs of that extension hint at ot
19:27:37 <mniip> you can always define your own operator named >>= regardless of anything
19:27:39 <geekosaur> *docs *hint at
19:27:51 <mniip> it's just that do{} won't use it
19:27:59 <mniip> if ghc can deal with it,
19:28:10 <mniip> I really don't see an implementational reason RebindableSyntax can change that
19:28:45 <geekosaur> I am not recalling the exact issue but there's specifically some screw cases there (and even more so with ApplicativeDo which is already a rat's nest in implementation)
19:29:14 <mniip> ah
19:29:28 <mniip> you mean how ApplicativeDo assumes some equations regarding <*> and pure to hold?
19:29:32 <mniip> and probably fmap
19:29:46 <mniip> and that might not be true for general rebound <*>/pure/fmap
19:29:54 <geekosaur> yes, and do notation makes similar assumptions about (>>=) (and especially how (>>) and (>>=) relate)
19:29:55 <mniip> even possibly breaking types?
19:30:08 <qmm> given: Seed { unSeed :: Integer };  mkSeed n = Seed n  :you should be able to access the value of unSeed with this, right? unSeed $ mkSeed 1
19:30:10 <mniip> I assumed do-notation was a straightforward rewrite
19:30:49 <mniip> qmm, if the function unSeed is in scope
19:31:29 <geekosaur> mniip, the times I have examined compiler dump output I was always surprised to see how late ghc deferred do desugaring
19:31:49 <qmm> let a = Seed { unSeed = 1 }; unSeed a -- should return 1 if i'm in ghci, correct?
19:32:08 <qmm> the mkSeed function is in Scope and it returns Seed { unSeed = 1 }
19:32:32 <mniip> qmm, but is unSeed in scope
19:32:52 <mniip> that is the grand question
19:33:24 <geekosaur> also remember that ghci will sometimes decide to use a compiled version on :load, in which case only exported things are in scope
19:33:38 <geekosaur> whereas if it interprets it then everything in the module is in scope
19:33:47 <geekosaur> (try prefixing the module name with * in this case)
19:34:40 <spoonm> would you guys rate this while not trying to throw up? it's how I did AoC's day 3 part 1: http://sprunge.us/NMZT?haskell
19:35:13 <spoonm> I wanna know how I can improve my haskell with deeper feedback than "learn to solve problems functionally"
19:35:30 <qmm> mniip: Seed returns { unSeed = 1 } so i figure unSeed is in scope. if i run :m *MCPrelude, i am told module 'MCPrelude' is from another package;
19:35:44 <mniip> no
19:35:45 <qmm> maybe i don't know how to work with records after all
19:35:56 <mniip> just because the Show instance outputs what it does,
19:36:01 <mniip> does not tell anything about what is currently in scope
19:36:02 <geekosaur> qmm, I said :load
19:36:11 <geekosaur> :m *always* uses a precompiled module
19:36:16 <geekosaur> you don't get to control
19:37:27 <geekosaur> qmm, if you can build a minimal example that reproduces whatever problem you are having and put it on gist or lpaste
19:37:36 <qmm> :cd src
19:37:52 <qmm> :load *MCPrelude ; unSeed $ mkSeed 1 -- this did work after all
19:38:57 <qmm>  import MCPrelude wasn't giving me all the exports
19:39:19 <geekosaur> mniip, also the "straightforward rewrite" is iirc not quite so straightforward if a failable pattern match is involved
19:39:33 <geekosaur> (it *ought* to be perhaps but I seem to recall some optimization or something)
19:47:04 <eacameron> I found it: OctetStream
19:52:24 <glguy> spoonm: I got a 500 error from that URL
19:55:15 <spoonm> glguy, oops, try this one: http://ix.io/CVE
19:58:14 <Average-user> Doing AoC?
19:58:34 <mniip> oh shi
19:58:37 <mniip> I forgot about aoc
19:58:57 <mniip> for 2 days straight...
19:59:03 <spoonm> Average-user, yup
19:59:11 <suzu> i've forgotton for four
19:59:19 <suzu> so i decided that i dont care
19:59:54 <suzu> :)
20:00:20 <Average-user> suzu: smart choice
20:01:06 <Average-user> I'm doing it to learn after all
20:01:12 <Average-user> but I've done all days
20:01:46 <spoonm> I saw it as an opportunity to revisit the very few languages I think I know a bit of, and haskell is among them
20:02:00 <spoonm> only done 2.5 days so far
20:02:10 <Average-user> But I wont be able to complete day 10 11 12 at time, I have to travel
20:02:48 <Average-user> I don't know if I will have internet
20:02:54 <Average-user> I hope I will
20:03:30 <glguy> You can miss days and still do OK
20:03:50 <glguy> I missed 9 days in 2015
20:04:31 <suzu> you could also just pretend the leaderboard isn't a thing
20:04:34 <suzu> and then aoc is just fun
20:04:37 <Average-user> I don't care about how I do, I'm still not getting in the leaderbord, But I like to be updated, so I can talk about the puzzles 
20:05:09 <glguy> The people worrying about being a couple days behind sound more like they're doing it to race than to have fun though
20:05:13 <Average-user> suzu: Thats what I'm doing, Yesterday's challenge took me an hour to complete
20:06:25 <Average-user> I had some troubles formating the input
20:06:38 <Average-user> But I ended up getting a nice solution, I think
20:07:23 <glguy> I vary between wanting to figure out a small solution or efficient one or clever one. It's nice to have small, self-contained problem to fuss over
20:07:37 <suzu> i imagine glguy just loses it when it hits 00:00
20:07:47 <suzu> WHATSTHEFASTESTWAYTOCODETHISOMGOMG
20:08:00 <Average-user> Jaja
20:08:16 <glguy> It's true, I try and just do the first version quickly
20:08:46 <Average-user> Too bad that in my country puzzles get released at 2:00am
20:09:04 <Average-user> I have been sleeping 5 hours this all week
20:09:19 <Average-user> all week*
20:09:59 <Average-user> glguy: Whats your best time for both stars?
20:10:04 <glguy> 1:10
20:10:16 <Average-user> what day
20:10:23 <glguy> 4, the day that everyone did it fast
20:11:16 <glguy> https://glguy.net/stats.txt
20:11:45 <Average-user> But you were the fastest
20:12:21 <glguy> Yeah, but it was just a really fast day, the leaderboard filled up in 3 minutes
20:12:24 <vaibhavsagar> is there a warm-up routine
20:12:35 <Average-user> coffee 
20:12:41 <Average-user> a bunch of it
20:12:43 <glguy> Playing Dead Cells or Thumper, I guess
20:12:59 <vaibhavsagar> do you e.g. amend the cabal file, touch exec/Day<n>.hs, put in some imports
20:13:20 <Average-user> I play Go, but not to warm up, to be able stay awake along with coffee obviously
20:13:33 <vaibhavsagar> ahh, I forgot about the timezone difference
20:13:39 <glguy> vaibhavsagar: I start with some imports in an open .hs file
20:14:24 <vaibhavsagar> sounds reasonable
20:14:36 <Average-user> The challenges that I did in Haskell I started with plain plain.hs file
20:15:16 <Average-user> glguy: How can I get my link of stats? Or it is not for every one?
20:15:45 <glguy> there's a [Stats] menu at the top of the game
20:16:00 <mniip> hmm
20:16:27 <Average-user> I founded my times, but not the link to share them
20:16:52 <glguy> *oh*, I don't think they have a built-in way to share them
20:17:14 <mniip> hmm what would be a nice way to solve d7p2...
20:17:44 <mniip> I don't want to topsort or build the whole tree out in some structure...
20:18:29 <Average-user> The description tells you that you just need to fix one node
20:18:31 <mniip> let's do it the slow way!
20:18:59 <Average-user> so you have to follow the path were there is a sum different from the other ones and keep doing it untill is balanced
20:20:28 <glguy> You don't have to actually topsort anything since you know ahead of time that it's a tree
20:21:01 <glguy> then you can do a bottom-up fold of the tree to find the correction. Which part are you trying to avoid doing?
20:21:16 <mniip> ehh
20:21:30 <mniip> the part where I split the code into mulitple liens
20:21:47 <Average-user> How much time takes your solutions to find the solution of 7.B?
20:22:42 <glguy> real	0m0.018s
20:23:35 <jle`> 12.3 ms for me
20:23:52 <Average-user> 2.3 for me
20:24:03 <jle`> nice
20:24:06 <Average-user> but it is in prolog, I imagine that in haskell would be faster
20:24:06 <glguy> jle`: Did you fix your day 7 yet?
20:24:24 <jle`> fix what part of it?
20:24:35 <glguy> I filled an issue with a testcase it didn't seem to handle
20:24:47 <jle`> i was going to rewrite findBad using a paramorphism instead but i decided to move on
20:24:54 <jle`> ooh, an issue
20:25:00 <Welkin> paramorphism?
20:25:09 <jle`> yeah right now Part B i write using explicit recursion
20:25:10 <Average-user> send the repo
20:25:13 <suzu> zymorphic prepromorphisms!
20:25:14 <jle`> which i do not appreciate
20:25:16 <Welkin> is that in the family of cata/ana/hylo morphisms?
20:25:26 <jle`> if i use a paramorphism i wouldn't have to explicit recursion
20:25:37 <glguy> My solution used "cataM" to avoid the explicit recursion
20:25:38 <mniip> okee
20:26:08 <suzu> :: (F a -> a) -> F a -> a?
20:26:16 <jle`> are you using cataM to implement a paramorphism
20:26:23 <suzu> wait we got an M in there
20:26:24 <jle`> Average-user: https://github.com/mstksg/advent-of-code-2017
20:26:33 <glguy> jle`: no, at least not that I know of
20:27:10 <mniip> I'll leave you this to ponder
20:27:15 <glguy> https://github.com/glguy/advent2017/blob/master/execs/Day07.hs#L66-L81
20:27:15 <jle`> Welkin: a paramorphism is a catamorphism but it also gives you the un-modified structure to use
20:27:19 <mniip> and to know how to not do it
20:27:32 <mniip> (\as -> let mp = foldr (\(h, ts) m -> foldr (`M.insert` h) m ts) M.empty $ map fst as; ws = M.fromList $ map (first fst) as; rw x = (ws M.! x) + sum [rw y | (y, p) <- M.toList mp, p == x] in map (second $ map ((,) <*> rw)) $ filter ((\xs -> length (nub $ map rw xs) > 1) . snd) $ map fst as) . map ((\(h:w:ts) -> ((h, map (filter (/= ',')) $ drop 1 ts), read w :: Int)) . words)
20:27:44 <jle`> i wanted to use container's Data.Tree
20:27:51 <jle`> it already has a catamorphism and a anamorphism
20:28:46 <glguy> mniip: Could you load that into lambdabot via ?let for me ?
20:29:00 <jle`> glguy: thanks for the heads up
20:29:10 <jle`> yeah the way i checked "which" thing to fix is a bit hacky, heh
20:29:16 <Average-user> glguy: With your input in the issue, I got the same result that you said it was, so yeah, I think theres an error
20:29:18 <mniip> @let (\as -> let mp = foldr (\(h, ts) m -> foldr (`M.insert` h) m ts) M.empty $ map fst as; ws = M.fromList $ map (first fst) as; rw x = (ws M.! x) + sum [rw y | (y, p) <- M.toList mp, p == x] in map (second $ map ((,) <*> rw)) $ filter ((\xs -> length (nub $ map rw xs) > 1) . snd) $ map fst as) . map ((\(h:w:ts) -> ((h, map (filter (/= ',')) $ drop 1 ts), read w :: Int)) . words)
20:29:18 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
20:29:35 <jle`> i'm going to try to livecast my AoC leaderboard attempt today
20:29:40 <jle`> does anyone know the best way to do it?
20:29:47 <jle`> i used to do livecoding.tv but it is now completely different
20:29:53 * mniip looks for a loose $
20:30:03 <mniip> weird
20:30:04 <mniip> oh er
20:30:07 <glguy> mniip: Did you need to do: ?let name = ?
20:30:11 <mniip> yes
20:30:18 <vaibhavsagar> jle`: Twitch?
20:30:21 <mniip> @let messedupnodes = (\as -> let mp = foldr (\(h, ts) m -> foldr (`M.insert` h) m ts) M.empty $ map fst as; ws = M.fromList $ map (first fst) as; rw x = (ws M.! x) + sum [rw y | (y, p) <- M.toList mp, p == x] in map (second $ map ((,) <*> rw)) $ filter ((\xs -> length (nub $ map rw xs) > 1) . snd) $ map fst as) . map ((\(h:w:ts) -> ((h, map (filter (/= ',')) $ drop 1 ts), read w :: Int)) . words)
20:30:23 <lambdabot>  Defined.
20:30:27 <mniip> :t messedupnodes
20:30:29 <lambdabot> [String] -> [([Char], [([Char], Int)])]
20:30:29 <jle`> vaibhavsagar: hm twitch does programming?
20:30:34 <jle`> i guess i have heard that it does everything now
20:30:38 <Average-user> Jle`: Are you in the leaderboard?
20:30:39 <vaibhavsagar> definitely
20:30:39 <mniip> might need additional preprocessing
20:30:48 <vaibhavsagar> lots of people do livecoding on twitch
20:30:54 <mniip> which I mean
20:30:56 <mniip> postprocessing
20:30:59 <exio4> how stable/bug-free is threepenny? 
20:31:15 <exio4> it sounds amazing as a concept and exactly what I want
20:31:31 <Welkin> exio4: I imagine as stable and bug-free as any haskell library, so probably pretty good
20:31:31 <cocreature> exio4: it’s been around for quite some time so I would assume it’s reasonably stable by now :)
20:31:37 <glguy> > messedupnodes ["a (1) -> b, c","b (2) -> d1, e1","c (10)","d1 (1) -> d","e1 (1) -> e","e (3)","d (2)"]
20:31:39 <lambdabot>  [("a",[("b",9),("c",10)]),("b",[("d1",3),("e1",4)])]
20:31:59 <mniip> so yeah I'm lookin at this output and I see that b is a subtree of a
20:31:59 <jle`> Average-user: i am not
20:32:05 <mniip> so the culprit is b
20:32:06 <jle`> hence, "leaderboard attempt" ;_;
20:32:24 <glguy> mniip: so you would change b's weight?
20:32:29 <mniip> no
20:32:33 <exio4> Welkin, cocreature, ah! cool :)
20:32:36 <mniip> in this case it's not well-defined
20:32:42 <mniip> either d1 or e1's
20:32:45 <Average-user> I just did day7.B recursively.
20:32:54 <mniip> I did solve the task, mind :p
20:32:56 <glguy> mniip: Only one of the two, though
20:33:02 <mniip> yes
20:33:26 <glguy> mniip: I'm trying to understand what the output means to you, it doesn't mean anything to me, so I'm just asking
20:33:41 <mniip> it lists all nodes that have children of varying weights
20:33:50 <mniip> along with their children and weights
20:34:49 <isiah> Quick question: what would be an example of an ArrowChoice that's not an ArrowApply? (I'm not so much a Haskeller, so please try to bear with me here.)
20:36:11 <isiah> And also, what would be an example of an Arrow that's not an ArrowChoice?
20:37:09 <aku> Can someone help me write a small parser for regular expressions? I want to convert them to my own data type.
20:38:20 <aku> I haven't used parsec before and I am not very skilled with monads too.
20:38:30 <JuanDaugherty> prolly if you can specify the data succinctly
20:39:23 <dmwit> isiah: http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf (the paper that introduced arrows) gives a parser arrow which is neither ArrowChoice nor ArrowApply.
20:39:35 <aku> Yes
20:40:31 <wedify> how do i submit a package to stackage to become part of the latest resolver? i would like to see sdl2-ttf-2.0.2 and sdl-mixer-1.0.0
20:41:06 <wedify> oh never mind the link is right in front of my face
20:42:12 <aku> I want to represent them as -> http://lpaste.net/360620
20:42:19 <aku> After parsing
20:43:00 <aku> Just these, not the full set of regular expressions
20:43:22 <mniip> hmm
20:43:26 <mniip> I can't be wrong now can I
20:43:32 <vaibhavsagar> jle`: https://twitter.com/LtHummus/status/939350297024933891
20:43:35 <dmwit> stupid hobby horse time: regexen should omit epsilon, but include the empty regex and conjunction
20:44:00 <vaibhavsagar> wedify: what is it? I've had this question before
20:44:12 <aku> Yes
20:44:15 <isiah> dmwit: What about something that's ArrowChoice, but not ArrowApply?
20:44:31 <dmwit> isiah: Don't know one off the top of my head.
20:44:48 <mniip> oooh
20:44:50 <dmwit> isiah: I'm pretty sure ArrowApply implies Monad. I doubt ArrowChoice does, so there should be one.
20:44:51 <mniip> this should be a foldl
20:44:53 <mniip> of course
20:44:58 <mniip> instructions go from top to bottom
20:44:59 <isiah> Oh okay.
20:45:19 <isiah> I was also thinking of things like reactive streams, which can branch, but can't always be called.
20:45:32 <vaibhavsagar> wedify: is this the one you meant: https://github.com/fpco/stackage/blob/master/MAINTAINERS.md?
20:45:43 <isiah> dmwit: Thank you!
20:46:27 <dmwit> aku: You might like https://github.com/GaloisInc/regex-fsm/blob/master/src/Regex/Parse.hs
20:46:30 <mniip> haha jokes on you challenge,
20:46:44 <mniip> a->b only needed a switch from foldl to scanl and M.toList to concatMap M.toList
20:47:03 <dmwit> aku: https://github.com/GaloisInc/regex-fsm/blob/master/src/Regex/Types.hs#L97-L109 has the type it parses into
20:49:08 <mniip> glguy, ok I am ready for today's challenge
20:49:14 <aku> I don't understand them much
20:49:39 <mniip> glguy, remarkably yesterday's challenge was much... uh, better
20:50:01 <platz> so.. parsing, recursion, whats next
20:50:23 <glguy> mniip: from last night: 21:29   cocreature: jle`: I love how part 2 involved basically just changing foldl to scanl
20:50:32 <mniip> hehe
20:50:38 <mniip> I'll just leave this here
20:50:42 <mniip> maximum . map snd . concatMap M.toList . scanl (\m (r,v,cr,cv) -> if cv (M.findWithDefault 0 cr m) then M.alter (Just . v . fromMaybe 0) r m else m) M.empty . map ((\(r:o:v:_:cr:co:cv:_) -> (r, [("inc", (+)), ("dec", subtract)] M.! o $ read v, cr, flip ([(">", (>)), (">=", (>=)), ("<", (<)), ("<=", (<=)), ("==", (==)), ("!=", (/=))] M.! co) $ read cv)) . words)
20:51:41 <platz> I used an AST like a sucker
20:51:42 <cocreature> so far the only annoying challenge was the spiral one
20:51:57 <mniip> glguy, you know what bothers me
20:52:00 <mniip> the perl solution
20:52:03 <glguy> I bet you'll
20:52:05 <glguy> tell me
20:52:54 <jle`> alright, i'll be streaming today, i got things working! :D https://www.twitch.tv/mstksg
20:52:56 <mniip> s/inc/+=/g;s/dec/-=/g;s/\w+/$\&/g;s/\$if /if /g;
20:52:57 <mniip> eval
20:53:22 <mniip> ah needs more semicolon
20:53:24 <mniip> but you get the idea
20:53:27 <glguy> Yeah, my comment last night was that someone probably did that and turned it into Ruby, and the someone else found thatsolution on reddit
20:53:31 <cocreature> jle`: you’re just trying to distract us so you can finish first :P
20:53:46 <mniip> cocreature, that's what she said
20:54:14 <dmwit> Man, I really gotta upgrade my computer. Can't even watch twitch.
20:54:27 <Average-user> jle`: I dont think streaming is a good idea since programmers that know about AoC will be doing the challenge
20:54:29 <platz> it seems like the key to be faster is to fuse everything into big loop, instead of decomposing into parts
20:54:44 <aku> I don't know about much about applicatives and monads, hence I don't understand the code
20:55:13 <glguy> jle`: Do you have the ability to record it while streaming?
20:55:23 <jle`> i think so? i haven't used this before :)
20:55:32 <jle`> cocreature: you got me
20:55:34 <glguy> Maybe spend a few minutes and go figure that out ;-)
20:55:58 <mniip> ooh
20:56:02 <mniip> there's a channel for aoc
20:56:15 <glguy> on Freenode? what is it?
20:56:17 <mandiblegrip> If anyone is going to stream themselves doing AoC in Haskell I would love to watch
20:56:25 <mniip> ah that wasn't even on freenode
20:56:31 <mniip> I just peeked at jle's screen
20:56:43 <dmwit> mandiblegrip: You should look no farther than about 3 minutes ago.
20:59:39 <HaskellLord69> he's keepin his apm high as preparation
20:59:47 <mniip> boo
21:00:04 <mniip> I'd share my screen but
21:00:15 <mniip> there's private information all over it
21:01:23 * hackage ShellCheck 0.4.7 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.4.7 (vidarhol)
21:01:52 <koala_man> \o/
21:03:27 <koala_man> I've tested on centos, ubuntu and freebsd already. if anyone would be willing to cabal update and install shellcheck-v0.4.7 to make sure it works, I'd appreciate it
21:11:40 --- mode: cherryh.freenode.net set +o ChanServ
21:16:43 <wedify> vaibhavsagar: yeah that is what i meant
21:18:41 <mniip> dammit
21:18:45 <mniip> looks like I finished last
21:19:15 <mniip> too me too long to debug
21:19:22 <mniip> 12:44 and 17:55 resp
21:19:30 <cocreature> mniip: the third still gets a medal :)
21:19:40 <mniip> does 214th?
21:20:02 <cocreature> I think you’re the third that finished today on glguy’s leaderboard
21:20:27 <mniip> on his leaderboard sure
21:20:53 <cocreature> that’s a lot more fun than the global leaderboard :)
21:21:12 * mniip peeks at jle's screen again
21:22:03 <mniip> haha
21:22:04 <avctrh> are there techniques to make foreign pointer finalizers more predictable?
21:22:44 <mniip> cocreature, code sharing time?
21:22:58 <mniip> I've got some decently idiomatic code
21:23:10 <cocreature> mine is really boring http://lpaste.net/360621
21:23:11 <mniip> if you don't count the placeholder variables
21:23:32 <avctrh> am running some stress tests allocating/deallocating in CI and running out of memory even though finalizers are used.
21:23:44 <mniip> spoiler alert http://lpaste.net/5874870444602949632
21:23:59 <cocreature> oh yeah, mine obviously contains spoilers too
21:24:55 <mniip> I was trying to hack garbage counting into the other functions but shortly realized it's simpler to count it separatel
21:24:56 <mniip> y
21:26:16 <mniip> answers to the exact AoC tasks being respectively, sc 0 . grp, cg
21:28:39 <mniip> where'd glguy do
21:28:49 <mniip> ah we're split..
21:32:50 <jle`> the stress of streaming probably threw me off v.v
21:32:50 <cocreature> there he is
21:32:58 <glguy> I was on the other side of a netsplit it turned out
21:33:14 <glguy> good job, cocreature
21:33:20 <cocreature> jle`: heh, it’s fun to watch :)
21:33:41 <cocreature> glguy: thanks!
21:34:02 <glguy> It turned out that I don't know megaparsec as well as I know parsec.
21:34:37 <cocreature> I’ve used it yesterday already and I had the boilerplate factored out to a common module
21:36:05 <mniip> glguy, which other? :p
21:36:13 <jle`> yeah i don't know megaparsec at all
21:36:15 <jle`> :'(
21:37:29 <glguy> mniip: Dunno, there were 82 people there with me in #haskell
21:39:06 <mniip> glguy, ah it looks like you were using a server not in the main rotation
21:40:46 <mniip> glguy, anyway, code sharing time?
21:41:06 <glguy> I put mine on github
21:42:00 <mniip> my unprettified code is http://lpaste.net/5874870444602949632
21:43:09 <cocreature> oh jle` even has a fancy test suite, that’s nice
21:44:53 <mniip> nice but
21:44:54 <mniip> sloooow
21:48:09 <glguy> I guess it would simplify things to just pre-process away all the !s
21:48:54 <glguy> maybe not that much
21:49:21 <mniip> my workflow was looking more like http://tcpst.net/z7k1.png
21:52:31 <Average-user> how long have to run your programs to get A and B?
21:52:34 <mniip> you can see I had a cpp file ready just in case
21:52:58 <mniip> Average-user, sub-80ms in both cases
21:53:11 <mniip> (didn't even record as a delay)
21:53:51 <mniip> jle`, you need to pick a quickier environment next time :p
21:53:55 <mniip> quieter*
21:54:35 <glguy> 0m0.015s
21:54:46 <mniip> "are you done yet" twss
21:54:53 <glguy> (this wasn't really a performance focused problem)
21:54:55 <HaskellLord69> I need to learn megaparsec
21:54:58 <mniip> yeah
21:55:02 <HaskellLord69> I haven't done any parsers yet
21:55:29 <glguy> HaskellLord69: Well, you can use this problem to learn how :)
21:56:01 <HaskellLord69> I plan on it
21:56:56 <Average-user> I found this problem a little to burring
21:57:17 <glguy> well, grab a sweater and warm up
21:57:42 <mniip> heh
21:57:47 <mniip> I wrote a bf interpreter the other day
21:57:53 <mniip> I guess it left an imprint
21:58:01 <mniip> on writing dyck language parsers
21:58:28 <glguy> I've you're lurking but still doing AoC problems, don't forget to join the #haskell group: http://adventofcode.com/2017/leaderboard/private 43100-84040706
21:58:43 <jle`> i got it 2 minutes before the place i was in closed, heh
21:58:55 <HaskellLord69> YOLO!
21:59:00 <jle`> i guess as soon as all my friends left i was able to start thinking straight lol
21:59:06 <Average-user> You made it!
21:59:25 <cocreature> jle`: congrats!
21:59:31 <jle`> yes, i decided not to test my outputs with the examples
21:59:38 <jle`> i thought eating the 60 seconds would be more worth it :)
22:00:08 <cocreature> jle`: streaming & having your friends around makes this significantly more challenging :)
22:00:15 <HaskellLord69> nice job mang, was fun to watch
22:00:23 <jle`> thanks!
22:00:32 <Average-user> I saw you too
22:00:33 <mniip> there's some joke here about having female friends around and thinking straight
22:00:41 <jle`> i'll try to find a quieter environment with better commentary next time :)
22:01:25 <Average-user> I think you write too large functions, I would do it in smaller steps
22:01:33 <Average-user> easier to debug
22:01:43 <jle`> alright, time to drive home!
22:01:50 <jle`> Average-user: haha that might definitely help :)
22:03:04 <mniip> hmm
22:03:25 <mniip> streaming sounds fun :D
22:04:01 <mniip> but ugh mic means finding a place where you can talk uninterruptedly and webcam means finding a decent background
22:05:03 <Average-user> I'm at 3:00am so I better go to sleep
22:05:12 <Average-user> Have fun, bye
22:05:23 * hackage random-class 0.2.0.0 - Class of random value generation  https://hackage.haskell.org/package/random-class-0.2.0.0 (MatthewFarkasDyck)
22:15:59 <vaibhavsagar> glguy: I like how much of the processing you pushed onto the parser, I didn't think to do that
22:27:26 * hackage random-class 0.2.0.1 - Class of random value generation  https://hackage.haskell.org/package/random-class-0.2.0.1 (MatthewFarkasDyck)
22:27:49 <texasmynsted> hmm. This is a long shot. . .  I had found this great library for making a REST client in Haskell and now can't find it.  Can't find it in hackage, or searching.
22:28:09 <cocreature> texasmynsted: req, wreq, servant-client, …
22:28:52 <texasmynsted> yep wreq
22:28:58 <texasmynsted> Thats the one!  Thank you
22:31:29 <texasmynsted> req looks interesting.  I had not seen that one.
22:32:44 <texasmynsted> thank you cocreature 
22:33:23 * hackage random-class 0.2.0.2 - Class of random value generation  https://hackage.haskell.org/package/random-class-0.2.0.2 (MatthewFarkasDyck)
22:38:50 <texasmynsted> subjective I know, but req vs. servant-client?
22:40:12 <johnw> i like servant-client, but that's because I use servant for everything RESTy lately lately
22:41:06 <texasmynsted> I am tempted to go that way simply because I am excited about trying servant
22:42:14 <texasmynsted> thank you
22:46:33 <johnw> I think it's a worthwhile investment, personally
22:46:42 <LiaoTao> Hello! I'm trying to implement a numerical integrator for celestial mechanics and need a hint or two about how to go about it.
22:50:11 <LiaoTao> The algorithm solves for two quantities x_{i+1} and v_{i+1}. x_{i+1} depends only on the starting values x_i and v_i, but v_{i+1} depends on x_{x+1}, so the calculations need to be performed in a single step
22:51:06 <johnw> isn't that a bit more of a math question than a Haskell one?
22:51:11 <LiaoTao> How would you organize this all while keeping all results for display?
22:51:33 <LiaoTao> Well the problem is rather that I don't know how to organize this with f.ex. a State monad
22:59:27 <glguy> vaibhavsagar: Yeah, for quick stuff like this it can be nice to return the computed value directly rather than making an intermediate data type
23:01:08 <mniip> glguy, I had to split it up into an ana and a cata
23:01:13 <mniip> ...of sorts
23:04:24 <jle`> 919.4 μs for part 1
23:06:06 <glguy> mniip: Which day?
23:06:10 <mniip> 9
23:06:16 <jle`> at least i know how to use megaparsec now
23:06:29 <glguy> mniip: a different version that your original paste?
23:06:31 <mniip> jle`, wait till you see my "elegant" "solution"
23:06:35 <mniip> glguy, no the same
23:06:51 <mniip> see there's a grp "anamorphism" and sc "catamorphism"
23:07:44 <jle`> why is there no cataM/anaM in recursion-schemes?
23:07:47 <jle`> just in data-fix?
23:08:09 <glguy> dunno, asked that to myself, too
23:08:16 <glguy> mniip: i see T now
23:08:50 <jle`> since recursion schemes is the edwardk-ified version of data-fix i always assumed that cataM/anaM are "bad things"
23:08:59 <jle`> otherwise they'd be in it
23:11:56 <jle`> it'd be nice if head :: Foldable f => f a -> a
23:12:38 <mniip> or would it
23:12:39 <jle`> so it'd basically be ^?! from lens
23:12:48 <mniip> mixing abstractions with partial functions...
23:12:53 <Lokathor> data Group = Group [Group]
23:12:53 <Lokathor> i provide the best types at all times
23:13:09 <mniip> Lokathor, http://lpaste.net/5874870444602949632#line30
23:13:13 <jle`> Lokathor: i ended up with somehting similar, data Tree = Garbage | Group [Tree]
23:13:33 <mniip> we have good types
23:13:38 <mniip> the BEST!
23:13:40 <Lokathor> excellent
23:13:44 <Lokathor> handshakes all around
23:13:49 <jle`> mniip: neat, you did what i originally tried to do but failed at
23:13:59 <Lokathor> i'm doing today in haskell becuase i couldn't figure it in rust :(
23:14:08 <jle`> i mean, the reason i use haskell is so that i don't have to keep track of state in my head
23:14:33 <mniip> damn
23:14:35 <mniip> I realize now
23:14:43 <mniip> I could have pulled out yoctoparsec
23:14:49 <mniip> in maybe 15 seconds
23:15:00 <mniip> I hesitated to use a parser library because that would take time
23:15:17 <jle`> glguy: did you notice that i read your idea about preprocessing '!' and decided to not use the spoiler
23:15:30 <jle`> mniip: yeah, the parser actually is not that bad
23:15:46 <jle`> https://github.com/mstksg/advent-of-code-2017/blob/master/src/AOC2017/Day09.hs#L20-L40
23:16:09 <mniip> let's check it out
23:16:21 <mniip> @let import Control.Monad.Trans.Free
23:16:24 <lambdabot>  Defined.
23:16:31 <mniip> @let token = FreeT . pure . Free $ FreeT . pure . Pure
23:16:33 <lambdabot>  Defined.
23:16:57 <mniip> @let parseString = runStateT . iterTM (StateT (maybe empty pure . uncons) >>=)
23:16:59 <lambdabot>  Defined.
23:18:06 <mniip> @let char x = mfilter (== x) token
23:18:08 <lambdabot>  Defined.
23:19:12 <mniip> @let garbage = char '<' >> many (char '!' >> token <|> (token >> tell (Sum 1))) >> char '>'
23:19:13 <lambdabot>  .L.hs:194:5: error:
23:19:13 <lambdabot>      Ambiguous occurrence ‘char’
23:19:13 <lambdabot>      It could refer to either ‘Text.PrettyPrint.HughesPJ.char’,
23:19:18 <mniip> dammit
23:19:27 <mniip> @let garbage = L.char '<' >> many (L.char '!' >> token <|> (token >> tell (Sum 1))) >> L.char '>'
23:19:29 <lambdabot>  .L.hs:195:27: error:
23:19:29 <lambdabot>      • Couldn't match type ‘()’ with ‘Char’
23:19:29 <lambdabot>        Expected type: FreeT ((->) Char) m ()
23:19:37 <glguy> jle`: I'll be more careful next time. it didn't occur to me people would be looking at chat when they should have been either done or staring at their editors :)
23:19:52 <jle`> i got pinged >____>
23:19:56 <mniip> @let garbage = L.char '<' >> many ((L.char '!' >> token >> return ()) <|> (token >> tell (Sum 1))) >> L.char '>'
23:19:58 <lambdabot>  Defined.
23:20:02 <mniip> :t garbage
23:20:03 <lambdabot> (MonadPlus m, MonadWriter (Sum a) m, Num a) => FreeT ((->) Char) m Char
23:20:06 <glguy> maybe get it working and then letpaste it?
23:20:07 <jle`> glguy: definitely not blaming you for anything! :)
23:20:33 <jle`> also why does megaparsec's 'char' not return ()
23:20:53 <glguy> too useful to have it return the character
23:21:16 <glguy> char 'a' <|> char 'b'
23:21:34 <glguy> now you know which it was, a or b
23:21:46 <jle`> that's just asking for stringly typed code
23:21:54 <jle`> (A <$ char 'a') <|> (B <$ char 'b')
23:22:19 <glguy> you can still write that
23:22:30 <glguy> and it's useful for what I said
23:22:37 <jle`> mostly complaining about -Wall
23:22:43 <jle`> :)
23:22:49 <mniip> @let groups i = sum <$> many (((i +) <$> (L.char '{' *> groups (i + 1) <* L.char '}')) <|> ((garbage <|> token) >> pure 0))
23:22:51 <lambdabot>  Defined.
23:23:05 <glguy> -Wall is pretty easy to turn off :-p
23:24:03 <jle`> blasphemy :O
23:25:01 <mniip> @let day9 = find (null . snd . fst) . runWriterT . parseString groups
23:25:03 <lambdabot>  .L.hs:198:59: error:
23:25:03 <lambdabot>      • Couldn't match expected type ‘FreeT ((->) a) (WriterT b t0) a1’
23:25:03 <lambdabot>                    with actual type ‘Integer -> FreeT ((->) Char) m0 Integer’
23:25:10 <mniip> @let day9 = find (null . snd . fst) . runWriterT . parseString (groups 0)
23:25:11 <lambdabot>  .L.hs:199:5: error:
23:25:11 <lambdabot>      • Could not deduce (Foldable t0) arising from a use of ‘find’
23:25:11 <lambdabot>        from the context: (Num a1, Num a)
23:25:16 <mniip> ah right
23:25:21 <mniip> also hmm
23:25:32 <mniip> it has to begin from 1 right
23:26:28 <mniip> @let day9 = find ((null :: String -> Bool) . snd . fst) . runWriterT . parseString (groups 1)
23:26:29 <lambdabot>  .L.hs:199:5: error:
23:26:29 <lambdabot>      • Could not deduce (Foldable t0) arising from a use of ‘find’
23:26:29 <lambdabot>        from the context: (Num a1, Num a)
23:28:08 <jle`> also, does anyone know why evalWriter doesn't exist?
23:28:15 <mniip> sigh
23:28:17 <mniip> @let day9 = find (null . snd . fst) . (++[]) . runWriterT . parseString (groups 1)
23:28:19 <lambdabot>  Defined.
23:28:26 <mniip> :t day9
23:28:28 <lambdabot> (Num a1, Num a2) => [Char] -> Maybe ((a2, [Char]), Sum a1)
23:28:40 <mniip> fascinating!
23:29:30 <mniip> > day9 "{{<!>foo>{}}}"
23:29:33 <lambdabot>  Just ((6,""),Sum {getSum = 3})
23:29:43 <mniip> works even
23:29:55 <glguy> jle`: maybe because if you're doing that it's better to use Identity? otherwise I don't know
23:30:24 <mniip> I suspect this could be written with 2 writers
23:30:32 <jle`> that's fair
23:31:17 <mniip> or not
23:31:31 <mniip> yeah no
23:32:01 <mniip> > runWriter $ censor (+1) $ tell (Sum 1) >> tell (Sum 1)
23:32:04 <lambdabot>  ((),Sum {getSum = 3})
23:32:34 <Wizek> Anyone knows in what situations, if any, is it useful to have a Foldable instance for (a,)? Can someone give me a small and concrete example?
23:32:36 <mniip> maybe if each function returned the number of groups inside
23:32:52 <mniip> Wizek, for (a,) to be traversable
23:32:54 <Wizek> I've been reading this: https://stackoverflow.com/questions/36460833/why-does-length-return-1-for-a-tuple-with-2-elements-and-gives-an-error-for-a-t
23:32:58 <saurabhnanda> any haskell newbies around? Need some end-users to test out some newbie tutorials.
23:33:05 <Wizek> mniip: sure, and when is that useful?
23:33:31 <mniip> not exactly "useful" but traversable is derivable for some of the generics,
23:33:47 <mniip> and it would be nice if the types behind those generics could be traversable too
23:33:49 <jle`> also just found out that there is no MonadWriter instance for tuples ????
23:33:58 <mniip> that includes (a,) and (Either a)
23:34:05 <jle`> oh wait, yeah, that makes sense
23:34:26 <mniip> jle`, it does?
23:34:50 <jle`> oh actually hm, yeah, it doesn't.  i don't see why anymore
23:35:11 <jle`> mniip: yeah, just realized about the Foldable instance for Either e, i can write sum :: Either e a -> a
23:35:54 <cocreature> > sum (Left 1)
23:35:57 <lambdabot>  0
23:36:14 <cocreature> ah at least it behaves like you expect it to, I was worried for a minute :)
23:36:53 <jle`> i wonder if it's more readable than fromRight 0
23:37:09 <mniip> @let instance MonadWriter w ((,) w) where writer = swap; tell = flip (,) (); listen (w, a) = (w, (a, w)); pass (w, (a, f)) = (f w, a) 
23:37:11 <lambdabot>  .L.hs:202:10: error:
23:37:11 <lambdabot>      • No instance for (Monoid w)
23:37:11 <lambdabot>          arising from the superclasses of an instance declaration
23:37:12 <Wizek> mniip: And how is the derivability of some generics relevant to how Foldable/Traversable instances for (a,) are useful? Or if, by your apparent admission that is not quite useful, can you give a different small and concrete example where it is?
23:37:21 <mniip> @let instance Monoid w => MonadWriter w ((,) w) where writer = swap; tell = flip (,) (); listen (w, a) = (w, (a, w)); pass (w, (a, f)) = (f w, a) 
23:37:23 <lambdabot>  Defined.
23:37:31 <mniip> jle`, see no hard reason
23:37:43 <jle`> yeah, i'm convinced now too
23:38:02 <Lokathor> folks
23:38:04 <Lokathor> i figured it out
23:38:07 <Lokathor> i figured out my problem
23:38:17 <Lokathor> ...it was an off by 1 error
23:38:33 <Lokathor> over 10 years of programming, still making day 1 mistakes
23:38:37 <Lokathor> i'm so proud of myself
23:39:00 <mniip> Wizek, well it's *nice* if given that you can derive Traversable for :+: and :*:,
23:39:13 <mniip> then you could also use Traversable in the "stock" "canonical" coproduct and product
23:39:20 <mniip> same for Foldable
23:40:35 <mniip> likewise it's *nice* to have Monad/Comonad instances for ((->)a)/((,)a)
23:40:39 <mniip> even if some might not be useful
23:40:53 <jle`> Lokathor: they never escape you :)
23:41:10 <jle`> mniip: (,) w  has a Monad instance now
23:41:18 <jle`> oh, sorry, misread your message
23:41:29 <mniip> yeah but does Reader have comonad?
23:41:39 <mniip> for a monoidal environment?
23:41:53 <mniip> yeah it does
23:41:58 <edwardk> yes
23:42:55 <mniip> o no
23:43:00 <mniip> we have awoken the ed
23:43:16 <Lokathor> jle`, http://lpaste.net/360623 let's play "spot the subtle bug"
23:43:19 <jle`> by the way we were just wondering why recursion-schemes doesn't have cataM/anaM
23:43:43 <mniip> Lokathor, is the bug "you're not using haskell"
23:44:14 <Lokathor> mniip, actually... somewhat
23:44:16 <mniip> Lokathor, what is this *corroded* language
23:44:34 <Lokathor> oh something to do with Calcium and Lime i think
23:44:51 <jle`> i just like how using parser combinators i could completely ditch explicitly dealing with state
23:44:55 <Lokathor> mniip, i did it 99% in rust, then started a haskell version in frustration, but then i was _so close_ with the rust version that i had to go back and stare at it until i finished that
23:45:09 <jle`> next time my parsing has any type of state, i'm going to jump straight to parser combinators
23:45:10 <mniip> Lokathor, look up for a neat haskell version
23:45:23 <jle`> instead of spending 10 minutes fumbling around with explicit state stream processing
23:45:28 <mniip> actually I'll summarize
23:46:01 <Lokathor> i've forgotten how to use any of the haskell parsing libs :/
23:46:23 <jle`> Lokathor: me too
23:46:48 <jle`> i'm going to blame that for why my AoC rank is so low today ;_;
23:46:56 <mniip> :t day9
23:46:58 <lambdabot> (Num a1, Num a2) => [Char] -> Maybe ((a2, [Char]), Sum a1)
23:47:24 <mniip> :t (fst . fst) &&& (getSum . snd) <$> day9
23:47:25 <lambdabot> error:
23:47:25 <lambdabot>     • Couldn't match type ‘Maybe ((Integer, [Char]), Sum Integer)’
23:47:25 <lambdabot>                      with ‘(a0, Sum c')’
23:47:34 <mniip> :t ((fst . fst) &&& (getSum . snd) <$>) . day9
23:47:35 <lambdabot> error:
23:47:35 <lambdabot>     The operator ‘<$>’ [infixl 4] of a section
23:47:35 <lambdabot>         must have lower precedence than that of the operand,
23:47:45 <mniip> :t (((fst . fst) &&& (getSum . snd)) <$>) . day9
23:47:46 <lambdabot> (Num a1, Num a2) => [Char] -> Maybe (a2, a1)
23:48:26 <Lokathor> aoc is sadly also my excuse to not do any other coding
23:48:36 <jle`> > (((fst . fst) &&& (getSum . snd)) <$>) . day9 $ "{{{}}}"
23:48:38 <lambdabot>  Just (6,0)
23:48:39 <Lokathor> i get my feet wet and then watch netflix
23:48:51 <mniip> Lokathor, http://lpaste.net/9083608312074731520
23:49:08 <jle`> mniip: i see what you mean by "elegant"
23:49:15 <Lokathor> mniip, unreadable
23:49:27 <jle`> or i should say
23:49:28 <cocreature> mniip has clearly written too much perl
23:49:32 <jle`> mniip: i see what you mean by "\"elegant\""
23:49:53 <mniip> jle`, I see what you mean by "\"\\\"elegant\\\"\""
23:49:54 <jle`> (i'm quoting your scare quotes)
23:50:24 <mniip> jle`, what part of this isn't elegant
23:50:37 <mniip> 4 lines to bootstrap a monadic parser library
23:50:43 <mniip> 2 lines to define our language
23:50:53 <mniip> that returns the score and writert's the garbage size
23:51:01 <mniip> one line to collect the results
23:51:02 <Lokathor> mniip, question: how does this run _speedwise_ compared to other haskell answerse?
23:51:17 <mniip> given the simplistic language it's probably linear
23:52:26 <Lokathor> i mean overall it's a linear problem sure, but i care about actual timings of particular solutions
23:52:39 <mniip> ok, gimme a minute
23:52:47 <mniip> my package db decided to break all of a sudden
23:52:54 <Lokathor> yikes
23:53:03 <jle`> there might potentially be weird asymptotics, but for the typical input sizes, it probably doesn't make too much difference
23:53:06 <cocreature> comparing actual timings is kind of tricky since the inputs are different
23:53:32 <Lokathor> on the rust discord there's one person that's been benchmarking every different answer and variant he can come up with for each different day
23:53:40 <mniip> cocreature, we usually exchanged inputs for that
23:53:53 <Lokathor> cocreature, we only need the timings on the "full" input
23:54:07 <mniip> Lokathor, everyone's input is different
23:54:09 <cocreature> Lokathor: what’s the “full” input?
23:54:10 <mniip> if you don't realize
23:54:20 <Lokathor> I absolutely didn't realize :P
23:54:24 <mniip> mine sha256sums to 52e9e81d7cfb10ee5f55a79c8334560631a75b8ea22c5c2bdf50be1abd4f4eef
23:56:41 <Lokathor> though come to think of it
23:56:44 <Lokathor> that doesn't matter
23:56:53 * hackage wai-session-postgresql 0.2.1.2 - PostgreSQL backed Wai session store  https://hackage.haskell.org/package/wai-session-postgresql-0.2.1.2 (hc)
23:57:07 <Lokathor> since all benchmarks have to run on the same machine to be meaningful anyway, so one person has to do it all, so they can set the same input for each run
