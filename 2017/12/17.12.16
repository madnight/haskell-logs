00:00:03 <sssilver> hey guys, so I hate my life :(((( I'm trying to implement this super trivial algorithm in Haskell, and it's working incorrectly, and I'm clueless as to how to debug my code....
00:00:13 <sssilver> I spent a few hours on this trivial task, and my head is starting to explode
00:00:47 <glguy_> Break it up into small functions,. Test those individually to get them right incrementally
00:00:48 <sssilver> I tried setting up breakpoints in GHCI, and doing :trace and stuff, but I still don't understand _anything_ about it
00:00:53 <cocreature> sssilver: if you show us your code and explain your problem, we might be able to help :)
00:00:55 <glguy_> Use ghci to explore then
00:00:57 <sssilver> honestly, my function is tiny
00:01:11 <sssilver> what I *don't* want to happen is -- I don't wanna show you my function and you to go "this is the problem"
00:01:25 <sssilver> I needto learn how exactly to debug my own problems
00:01:38 <cocreature> right but I can’t tell you how I would debug a function without seeing the function :)
00:01:46 <cocreature> usually Debug.Trace works quite well for me
00:01:48 <sssilver> so with that in mind, please don't spoil the solution for me
00:02:09 <sssilver> OK so the problem I'm trying to solve is this one -- http://adventofcode.com/2017/day/1
00:02:59 <glguy_> Part 1?
00:03:10 <sssilver> yeah
00:03:13 <sssilver> here's my code -- https://bpaste.net/show/922b23c4759b
00:03:19 <sssilver> and it calculates most things wrong
00:03:33 <sssilver> like, for 101 it should be 2, instead it gives 0
00:03:44 <sssilver> now without telling me what exactly I did wrong
00:03:55 <sssilver> please help me understand how I should go about debugging this? if you have time/desire
00:04:00 <glguy_> Why is 101 supposed to be 2?
00:04:26 <sssilver> because 1 and 1 are adjacent (the number is supposed to be treated as circular)
00:04:39 <glguy_> That's incorrect, shouldn't be 2
00:04:51 <sssilver> sorry you're right should be 1
00:05:24 <sssilver> and please forgive me if my code is atrocious and way off the correct solution
00:05:40 <cocreature> so step 1: I would separate parsing the input into a list of integers from actually calculating the solution and check that the input is parsed correctly
00:06:09 <cocreature> (afaict that’s not the problem in your case but in general that’s a useful step)
00:07:24 <sssilver> cocreature do you mean my list comprehension?
00:07:45 <cocreature> sssilver: no, I mean the "read" 
00:08:09 <cocreature> captcha should have a type signature of type "[Int] -> Int -> Int" and the input should be parsed before it is passed to captcha
00:09:07 <sssilver> cocreature but it makes more sense to me for it to be a string -- if it's an int, I'm gonna have to do some math to shift the number, and I don't know how to do that math
00:09:22 <sssilver> otherwise I have to cast the int back to a string inside the function, and that seems hairy
00:09:37 <cocreature> why do you need to convert it back to a string?
00:09:53 <sssilver> to shift its digits around
00:10:06 <cocreature> each Int in the list would be one digit
00:10:14 <sssilver> ahhh :thinking_face:
00:10:29 <sssilver> yeah that makes sense
00:10:29 <cocreature> basically just pull out the read [x] :: Int part
00:10:55 <sssilver> alright let me go spend the next 20 mins on that (maybe I'll be faster)
00:10:59 <sssilver> thanks a lot
00:11:29 <cocreature> now once you’re done with that, I would probably throw in some traceShow and test it on small inputs to see if the right cases are hit
00:16:52 <sssilver> cocreature how do you like my change? https://bpaste.net/show/3b057e4855aa
00:18:33 <sssilver> this is so hard :( I would have finished this looong ago in any imperative language almost
00:18:51 <sssilver> not blaming the language, clearly my brain is inferior
00:21:23 <sssilver> yeah so I tried the traceShow thing and it complains that `Variable not in scope: traceShow :: (Int, [Int], Int) -> Int -> Int`
00:21:42 <sssilver> and google doesn't seem to know why
00:22:35 <sssilver> guess need to import Debug.Trace
00:24:52 <sssilver> omg found the bug
00:25:01 <sssilver> alright diving into this, thanks guys!!!!
00:28:22 <cocreature> sssilver: yeah that’s what I had in mind
00:28:42 <cocreature> sssilver: hoogle can be useful for figuring out which module you need to import, e.g., http://hoogle.haskell.org/?hoogle=traceshow
00:29:07 <cocreature> sssilver: also note that "head" is often a bad idea since it will just crash on empty lists
00:34:19 <sssilver> so I don't understand
00:34:24 <sssilver> my shift function works correctly
00:35:40 <sssilver> https://bpaste.net/show/4f00686d772d -- how come I always get the same sequence in trace??
00:35:55 <sssilver> does this have smth to do with lazy evaluation?
00:36:39 <sssilver> when I first call captcha with 1 and 01, shifted should evaluate to 0,1,1
00:36:47 <sssilver> but all my output always shows 1, 0, 1
00:38:06 <cocreature> you are only shifting the singleelement list [x]
00:38:19 <cocreature> shift [x] ++ xs is parsed as (shift [x]) ++ xs
00:38:35 <sssilver> omgg
00:39:38 <cocreature> function application has higher precedence than anything else
00:40:36 <sssilver> you're the best cocreature, thank you so much!!!
00:40:44 <sssilver> I'd spend the whole night and never figure this out
00:41:01 <cocreature> it’ll get easier once you’ve written a bit more Haskell :)
00:42:10 <sssilver> alright check this out -- http://lpaste.net/360825
00:42:14 <sssilver> it works correctly!
00:42:21 <sssilver> now re head -- what should I prefer instead?
00:42:45 <sssilver> btw I find it pretty weird that for all the pride in its type system, it's fairly easy to get a runtime error in Haskell
00:43:28 <sssilver> I feel like perhaps `head` should return a Maybe or something
00:43:36 <sssilver> but I Maybe clueless
00:43:38 <sssilver> (pun intended)
00:47:30 <shiona> once again I'm working on advent of code in haskell. Up until this point I've managed, but todays part 2 just wrecks my memory usage.
00:47:42 <sgronblo> I'm writing a simple Haskell program in form of a stack script. I'm using VSCode with the haskell-ide-engine/hie plugin. It's complaining about "Failing to load interface for Text.Parsec" for example. Can I install Text.Parsec and other required modules somewhere that hie would be able to find them?
00:48:45 <shiona> any pointers on where to look. I'm iterating a function over a list, dropping the first billion elements and then taking the one that's left. My understanding has been that the runtime is smart enough to see that the dropped elemets can be freed immediately/reused or something
00:50:29 <glguy_> shiona: you'll probably need to be more clever than iterating one billion times
00:51:33 <glguy_> For the runtime to free that memory when iterating you'll need to make sure nothing depends on those values (like the 1 billion dropped entries)
00:52:01 <jle`> shiona: part 2 is the first AoC i think that requires more than just the naive implementation following the instructions
00:52:30 <shiona> and that's where my haskell-fu starts failing me
00:53:07 <jle`> it's actually more of a math-fu at that point :O
00:53:17 <jle`> or reasoning about algorithms
00:53:31 <jle`> once you figure out your algorithm, haskell is what you can use to code it
00:53:50 <shiona> ah, actually as you wrote that I had some sort of an heureka moment.. possibly
00:54:21 <glguy_> That's when a heuristic comes to mind?
00:57:18 <shiona> ok, now the memory use is in check. let's see if this finishes any time soon
00:57:51 <glguy_> How long does your program take to compute one dance?
00:58:04 <glguy_> Or 100 to avoid some noise
01:04:07 <shiona> glguy_: eh.. 100 takes almost 8 secods. so there's no way this could ever work for part 2
01:05:02 <glguy_> About 2.5 years to go
01:05:20 <shiona> see you at Aoc 2020? :D
01:09:37 <sssilver> I'm curious -- is there a more idiomatic way to accomplish this -- `input = [read [c] :: Int | c <- input]` ?
01:09:54 <sssilver> I feel like I should be using `map` instead
01:11:25 <shiona> :t map (read . (:[]))
01:11:26 <lambdabot> Read b => [Char] -> [b]
01:11:44 <shiona> not sure about idiomatic
01:11:52 <shiona> but I think I've used that
01:12:24 <shiona> or is that input thing some kind of recursive definition?
01:12:36 <rightfold> traverse readMaybe input
01:13:03 <Wizek> shiona: not recursive
01:13:22 <glguy_> :t digitToInt
01:13:24 <lambdabot> Char -> Int
01:13:35 <rightfold> traverse (readMaybe . pure) input
01:13:35 <Wizek> sssilver: input = map (\c -> read [c] :: Int) input2
01:13:45 <MarcelineVQ> glguy_: you're up late :>
01:13:50 <rightfold> traverse (readMaybe . pure) . Text.unpack $ input
01:14:06 <rightfold> Most “idiomatic” :)
01:15:17 <glguy_> MarcelineVQ: it's true
01:29:05 * hackage Win32 2.6.2.0 - A binding to Windows Win32 API.  https://hackage.haskell.org/package/Win32-2.6.2.0 (TamarChristina)
02:03:14 <jle`> i don't really like pure for (:[])
02:03:39 <jle`> unless you're using it in relationship with other applicative combinators
02:05:21 <MarcelineVQ> too hard to discern at a glance?
02:06:09 <MarcelineVQ> how about  pure @[]  hoho
02:17:45 <rightfold> List.singleton is too long
02:18:06 <rightfold> I pretty much always use the more generic combinators. I don't want to remember the less generic ones. E.g. fmap instead of map
02:20:22 <jle`> is that really true
02:20:27 <jle`> do you use fmap instead of (.) ?
02:20:38 <rightfold> (.) is just as generic as fmap, if you import Control.Category ;P
02:21:03 <jle`> using the less generic version can often improve readability :O
02:21:16 <jle`> it helps convey to the reader the intent of the writer
02:21:21 <rightfold> I have used fmap recently for function composition though!
02:21:28 * hackage lapack-ffi-tools 0.0 - Generator for Haskell interface to Fortran LAPACK  https://hackage.haskell.org/package/lapack-ffi-tools-0.0 (HenningThielemann)
02:21:34 <jle`> but it depends on how well known the less generic version is
02:21:46 <rightfold> I had a [(Foo, Bar -> Maybe Baz)] and wanted to turn the Baz into something else. Used fmap (fmap (fmap (fmap f)))
02:22:22 <jle`> nice :)
02:22:30 <cocreature> I hope I don’t have to read your code :)
02:22:43 <rightfold> I write type signatures for all let/where bindings.
02:22:48 <rightfold> So I don't have trouble with code like this.
02:23:11 <jle`> that works as long as you're the only person reading your code
02:23:21 <rightfold> My colleagues disagree.
02:24:09 <cocreature> at least use second from Data.Bifunctor instead of fmap
02:24:48 <jle`> (map . second . (.) . fmap) f
02:24:56 <jle`> the rainbow of composition ;)
02:25:10 <jle`> :t map . second . (.) . fmap
02:25:11 <lambdabot> Functor f => (a1 -> b) -> [(d, a2 -> f a1)] -> [(d, a2 -> f b)]
02:26:05 <rightfold> "Modify the value in covariant position four levels deep."
02:36:04 * hackage lapack-ffi 0.0 - Auto-generated interface to Fortran LAPACK  https://hackage.haskell.org/package/lapack-ffi-0.0 (HenningThielemann)
02:37:48 * hackage lapack-carray 0.0 - Auto-generated interface to Fortran LAPACK via CArrays  https://hackage.haskell.org/package/lapack-carray-0.0 (HenningThielemann)
02:39:50 * hackage netlib-carray 0.0, netlib-ffi 0.0 (HenningThielemann): https://qbin.io/jr42yyx
02:41:25 * hackage blas-carray 0.0, blas-ffi 0.0 (HenningThielemann): https://qbin.io/dc9wihn
03:34:19 <kahlil29> is there a way to match multiple cases with the same block of code in a case matching? 
03:34:48 * hackage combinatorial 0.0 - Count, enumerate, rank and unrank combinatorial objects  https://hackage.haskell.org/package/combinatorial-0.0 (HenningThielemann)
03:42:46 <kuribas`> kahlil29: what do you mean?
03:44:16 <kahlil29> I have 7 cases in my case matching that would be handled by the same logic. So i wanted to match all of them to the same piece of code.
03:44:24 <kahlil29> like say
03:44:56 <kahlil29> x1 -> do something, x2 -> do something , x3, x4, x5, x6 -> do something for all 4, 
03:45:01 <kahlil29> commas for new line 
03:45:05 <kahlil29> kuribas:
03:46:34 <kuribas`> kahlil29: if it's an enum: if fromEnum myCase < 4 then do_something else do_something_else
03:47:08 <kuribas`> kahlil29: or if it's Eq: if myCase `elem [Case1, Case2, Case3]
03:47:45 <kuribas`> if myCase `elem` [Case1, Case2, Case3] then do_something else do_something_else
03:49:19 <kuribas`> kahlil29: many possibilities
03:51:59 <MarcelineVQ> I think they're after    case blah of UniqueThing -> uniquestuff; _ -> allthestuffthatsthesame
03:53:46 <MarcelineVQ> oh hmm maybe not hehe
03:53:47 <kahlil29> MarcelineVQ: Not really, I've use the underscore before. I don't want all the remaining handling to go to that 
03:54:37 <MarcelineVQ> for what x does  case x of   result in x3 x4 x5 and x6 at the same time?
03:56:13 <MarcelineVQ> That is to say, what data type are you needing this syntax for?
03:57:55 <kuribas`> kahlil29: so a direct answer is, no, you cannot do that.
03:58:31 <kahlil29> kuribas`, MarcelineVQ : I think I managed to handle it by using an argument 
03:59:07 <kuribas`> kahlil29: an example would useful
03:59:09 <MarcelineVQ> I'm still pretty curious about what your cases look like :>
03:59:22 <dminuoso> Following some example, I just implemented a variant of intersperse: intersperse'' :: a -> [[a]] -> [a] that looks like this: intersperse'' s (x:xs) = join $ x : i' s xs where i' s (x:xs) = [s] : x : i' s xs; i' s o = o
03:59:32 <dminuoso> Is there some way to golf this into something a little neater?
04:02:21 <kahlil29> I'm pretty much a beginner so I was probably going about it  wrong. But I'll explain. I needed to read a Bool for each day of the week and I had only one Data type called DOW in my Custom Data Type which I had made. I was matching based on the different things in my Custom Data Type. So while writing it I was able to write using that single DOW value but when reading the data, each Bool value was coming in seprately. So I now changed my Custom Data Type i
04:02:21 <kahlil29> nternal value to `DOW Int` And I pass a number (from 1-7) and accordingly handle the case
04:04:09 <kuribas`> dminuoso: that's not total
04:04:47 <lyxia> dminuoso: intercalate?
04:05:30 <dminuoso> kuribas`: I left the base case away. :P
04:05:47 <dminuoso> lyxia: Oh.. well! I guess Real World Haskell does have me reinvent the wheel.
04:06:04 <kuribas`> RWH is really old
04:06:12 <dminuoso> Does that make it bad?
04:06:25 <MarcelineVQ> No, just occasionally confusing
04:06:30 <kuribas`> dminuoso: it's great, but misses a lot of information
04:06:34 <MarcelineVQ> One should know how a wheel works if they intend to drive
04:06:36 <kuribas`> That came after.
04:07:37 <dminuoso> kuribas`: Im open for different suggestions if there's something more complete.
04:07:52 <lyxia> > let intersperse'' s (x : xs) = x ++ (xs >>= (s :)) in intersperse'' 1 [[2,3], [4..6], [7..9]]
04:07:54 <lambdabot>  [2,3,1,4,5,6,1,7,8,9]
04:08:39 <lyxia> > let intersperse'' s xs = tail (xs >>= (s :)) in intersperse'' 1 [[2,3], [4..6], [7..9]]
04:08:41 <lambdabot>  [2,3,1,4,5,6,1,7,8,9]
04:09:25 <kuribas`> dminuoso: http://www.cis.upenn.edu/~cis194/spring13/
04:09:30 <dminuoso> lyxia: Oh wow! I didn't realize (s :) would give me a kleisli arrow. :o
04:10:35 <kuribas`> dminuoso: you can read the book, then keep yourself up to date from other sources.
04:10:42 <dminuoso> kuribas`: Alright great. :)
04:13:19 <Tuplanolla> I can probably do worse.
04:15:55 <Tuplanolla> > let it be = list [] ((. (>>= (be :))) . (++)) in it ' ' ["this", "should", "work"]
04:15:57 <lambdabot>  "this should work"
04:17:18 <fiatjaf> I have a function that returns IO Int64
04:17:25 <fiatjaf> how can I make it return just IO
04:17:42 <fiatjaf> I don't know if that is possible, but I don't want any value from it
04:17:50 * hackage universum 1.0.0 - Custom prelude used in Serokell  https://hackage.haskell.org/package/universum-1.0.0 (shersh)
04:18:13 <Tuplanolla> :t void -- Use this, fiatjaf.
04:18:14 <lambdabot> Functor f => f a -> f ()
04:26:07 <kuribas`> Tuplanolla: not poinless enough :)
04:36:14 <EvilMachine> Hi. Is there a way to execute a few Haskell commands in a string? Something like $( ghci '[[ x | x <- [1..100], odd x ]]' ) for example.
04:36:48 <Tuplanolla> That would be `ghc -e`, EvilMachine.
04:37:24 <EvilMachine> Tuplanolla: This should be the first thing mentioned in ghci --help.
04:37:33 <EvilMachine> Tuplanolla: Also, thank you. :)
04:40:11 <ggVGc> :/ why can you only have one library definition in a cabal file
04:41:05 <EvilMachine> Tuplanolla: But this does not work: ghci -e 'gesamt <- lines <$> readFile "gesamt.txt"; erledigt <- lines <$> readFile "erledigt.txt"; writeFile "reste.txt" $ unlines $ filter (`notElem` erledigt) gesamt'
04:41:34 <EvilMachine> Tuplanolla: It says the <- should be in a do block. But doing this on the ghci prompt, does work.
04:41:47 <Tuplanolla> It's supposed to be the definition for `main`, EvilMachine.
04:42:11 <Tuplanolla> Sans printing the final result.
04:42:32 <EvilMachine> Tuplanolla: ah, wrapping it in do { … } helped. Strange. Thank you again.
04:42:41 <Tuplanolla> The `-e` is for expression.
04:49:39 <fiatjaf> that works, Tuplanolla, thanks.
04:52:50 <grokkingStuff> any resources on working with circular lists in haskell?
04:55:13 <liste> grokkingStuff: it's like working with any other list
04:55:29 <liste> > let l = 1 : 2 : 3 : l in take 10 l
04:55:31 <lambdabot>  [1,2,3,1,2,3,1,2,3,1]
04:56:29 <liste> grokkingStuff: is there something you want to do with *specifically* circular lists, like detect their cirularity?
04:56:42 <grokkingStuff> you're probably right on that.
04:56:50 <grokkingStuff> need to learn how to use circular lists
04:56:58 <grokkingStuff> in general i guess. I just know the basics
04:57:37 <liste> :t (cycle, repeat) -- grokkingStuff
04:57:38 <lambdabot> ([a1] -> [a1], a2 -> [a2])
04:57:50 <liste> these 2 are useful for defining circular lists
04:57:57 <liste> > repeant 42
04:58:00 <lambdabot>  error:
04:58:00 <lambdabot>      • Variable not in scope: repeant :: Integer -> t
04:58:00 <lambdabot>      • Perhaps you meant one of these:
04:58:04 <liste> > repeat 42
04:58:06 <lambdabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
04:58:13 <grokkingStuff> > cycle [1,2]
04:58:15 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
04:58:20 <grokkingStuff> right
04:58:35 <grokkingStuff> quick question, how do i skip the first few elements in a list?
04:58:46 <liste> :t drop -- grokkingStuff 
04:58:48 <lambdabot> Int -> [a] -> [a]
04:59:01 <liste> > drop 1 (repeat [1,2,3,4])
04:59:03 <lambdabot>  [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,...
04:59:11 <liste> > drop 1 (cycle [1,2,3,4])
04:59:13 <grokkingStuff> > drop 2 (cycle [1,2,3,4])
04:59:14 <lambdabot>  [2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3...
04:59:16 <lambdabot>  [3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4...
04:59:23 <grokkingStuff> right, that's awesome
05:09:38 <fiatjaf> thanks, Tuplanolla 
05:10:11 <fiatjaf> how can do apply a value to a function like `v |> function`?
05:10:26 <fiatjaf> (that's how I would do it in Elm)
05:12:02 <hexagoxel> > 15.0 & sqrt
05:12:04 <lambdabot>  3.872983346207417
05:16:44 <cocreature> fiatjaf: you might also be interested in https://hackage.haskell.org/package/flow-1.0.9/docs/Flow.html
05:24:30 <Hafydd> People who don't know Haskell can't understand Haskell? Shocker.
05:24:36 <fiatjaf> hexagoxel, I've tried that, but (&) is not in the scope
05:24:46 <fiatjaf> I can't find it on hoogle or on the base/Prelude docs
05:26:08 <hexagoxel> fiatjaf: https://hayoo.fh-wedel.de/?query=(%26)
05:26:18 <cocreature> or http://hoogle.haskell.org/?hoogle=(%26)
05:30:48 <fiatjaf> thank you.
05:31:10 <fiatjaf> sorry for the stupid questions.
05:31:20 <cocreature> asking questions is what this channel is for :)
05:32:09 <fiatjaf> I have one more: if I have a UserResponse { user :: User } type and User { id :: Text, name :: Text }, how do I access id and name in a function that takes UserResponse?
05:32:39 <fiatjaf> I've tried doing user.id, user.name, but "name" and "id" are not in scope. I don't want them to be in scope or they'll conflict.
05:35:14 <fakenullie> flebron: id user
05:35:45 <fakenullie> > data User { id :: Text, name :: Text }
05:35:47 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
05:35:53 <fakenullie> @let data User { id :: Text, name :: Text }
05:35:53 <lambdabot>  Parse failed: Parse error: {
05:37:07 <cocreature> fiatjaf: unfortunately, record names have to be in scope if you want to use them. if you just want to get the values and are fine to access them by position you could just pattern match, e.g., "f (UserResponse (User userId userName))"
05:37:14 <hpc> fiatjaf: name . user $ someResponseValue
05:37:32 <cocreature> fiatjaf: one (ugly but common) solution to avoid conflicts is to prefix record names, e.g., call the fields userId and userName
05:37:37 <hpc> fiatjaf: record accessors are ordinary functions, so you need to compose them in the right order
05:38:12 <fakenullie> time to move to purescript
05:38:13 <hpc> and you'll need to do what cocreature suggests just to get the data types to compile
05:41:46 <grokkingStuff> hey there!
05:41:59 <grokkingStuff> what's the difference between Text.CSV and cassava?
05:42:08 <grokkingStuff> how do you guys deal with CSV files?
05:42:44 <cocreature> I use cassava
05:42:50 <cocreature> Text.CSV hasn’t been updated in 7 years
05:45:52 <iqubic> Programming in Emacs' fundemental mode is no fun.
05:46:58 <iqubic> What emacs packages do people recommend for doing haskell programming in?
05:47:05 <fakenullie> haskell-mode
05:47:13 <ctrouill> Intero
05:47:37 <iqubic> fakenullie: Why do you use haskell-mode?
05:47:54 <fakenullie> well, actually I use intero
05:48:08 <fakenullie> but afaik it uses haskell mode for formatting and syntax highlighting
05:48:16 <cocreature> even if you use intero, haskell-mode does syntax highlighting
05:48:44 <iqubic> I think I want to use intero.
05:48:57 <iqubic> But I want to first solve AoC day 1.
05:49:09 <iqubic> I am so far behind in Advent of Code.
05:49:11 <cocreature> you’ve been saying that for several days by now :)
05:49:16 <iqubic> I know.
05:49:27 <cocreature> you don’t need fancy tooling for aoc, just start :)
05:49:51 <iqubic> What's the best way to read the input for any given AoC day?
05:50:08 <iqubic> Do you think that interact will be good enough?
05:50:37 <cocreature> interact is for interactive programs, just use readFile
05:50:48 <iqubic> :t readFile
05:50:50 <lambdabot> FilePath -> IO String
05:50:53 <vaibhavsagar> iqubic: read it to a file and use `init <$> readFile`
05:51:06 <iqubic> What is init?
05:51:07 <vaibhavsagar> init because the last character is '\n'
05:51:18 <iqubic> :t init
05:51:19 <lambdabot> [a] -> [a]
05:51:21 <vaibhavsagar> init takes all but the last character of a list
05:51:32 <fakenullie> > unwords "123 456\n"
05:51:35 <lambdabot>  error:
05:51:35 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
05:51:35 <lambdabot>        Expected type: [String]
05:51:43 <fakenullie> > words "123 456\n"
05:51:45 <lambdabot>  ["123","456"]
05:52:10 <vaibhavsagar> > (init [1..5], last [1..5])
05:52:12 <lambdabot>  ([1,2,3,4],5)
05:52:27 <iqubic> Yes, that works. But day1 is literally just a string of numbers.
05:52:49 <vaibhavsagar> if you open the input in your browser and 'Save File'
05:53:16 <vaibhavsagar> and then read the input from that file using `readLine`, tell me what the last character is
05:53:29 <iqubic> I don't really want to do that right now.
05:53:47 <vaibhavsagar> sure, whatever works for you
05:53:47 <iqubic> So readLine takes a file, right?
05:53:56 <vaibhavsagar> a file name, yes
05:54:06 <iqubic> Is that FilePath relative?
05:54:12 <vaibhavsagar> yes
05:54:15 <iqubic> And if so, relative to where?
05:54:21 <cocreature> no it doesn’t, readFile takes a file name. readLine is not even in base
05:54:22 <yushyin> cwd
05:55:07 <iqubic> cocreature: If readFile takes a relative path, then what is it relative to?
05:55:11 <elomatreb> Small question: I need a list of integers starting from zero up to a certain value, and then decreasing to zero again. My current solution is [0..n] ++ [n-1,n-2..0], but I can
05:55:20 <cocreature> the current working directory
05:55:22 <elomatreb> *can't help but think that there must be a more elegant solution
05:55:29 <dminuoso> elomatreb!
05:55:37 <elomatreb> :)
05:56:39 <vaibhavsagar> elomatreb: let range = [0..n] in range ++ (tail (reverse range))
05:58:15 <elomatreb> Yeah, I had something like that initially. I guess it is a fairly obscure/weird need
05:58:44 <iqubic> My list comprehension skills are not that great.
05:59:32 <MarcelineVQ> more elegant, hmm
05:59:50 <MarcelineVQ> what meaning of elegant did you want? :>
05:59:51 * hackage llvm-hs-pure 5.1.1 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-hs-pure-5.1.1 (cocreature)
06:00:33 <elomatreb> MarcelineVQ: I don't really know, I was thinking maybe something that doesn't stitch the list together from two separate lists?
06:00:59 <MarcelineVQ> I dunno if you're gonna get that form hehe
06:01:12 <MarcelineVQ> > (++) <*> tail . reverse $ [1,2,3,4,5]
06:01:14 <lambdabot>  [1,2,3,4,5,4,3,2,1]
06:01:17 <cocreature> great hackage is giving me an internal server error
06:01:34 <iqubic> I need a function of [(Int, Int)] -> [Int] where it looks through the list, and takes the values that are the same in both fst and snd of a given tuple and adds them to the list.
06:01:48 * hackage llvm-hs 5.1.1 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-hs-5.1.1 (cocreature)
06:01:53 <iqubic> I have no idea how to do that simply.
06:02:06 <elomatreb> MarcelineVQ: That certainly looks cool!
06:02:48 <iqubic> [(1,1),(1,2),(2,2),(3,2),(4,4)] -> [1,2,4] is what I need.
06:02:57 <iqubic> is there a way to do that simply.
06:03:36 <MarcelineVQ> yep, what would you try first?
06:04:52 <iqubic> [fst x | x <- pairs, fst x = snd x]
06:05:17 <iqubic> 'I think that will work. Given that pairs :: [(Int,Int)]
06:05:37 <fakenullie> looks like it must remove consecutive duplicates
06:06:15 <MarcelineVQ> equality testing via Eq is ==, but otherwise that looks like it'll do what you described
06:06:30 <iqubic> [(1,1),(1,1),(1,1)] -> [1,1,1]
06:06:37 <elomatreb> [x | (a, b) <- pairs, a == b] seems a little cleaner than having fst and snd everywhere
06:06:51 <elomatreb> Eh, a or b instead of x
06:07:11 <iqubic> You can pattern match inside a list comprehension?
06:07:44 <MarcelineVQ> Correct, it's really useful
06:08:09 <dminuoso> MarcelineVQ: How will this code for elomatreb behave though? Doesn't that reverse force walking through the entire list?
06:08:56 <MarcelineVQ> > [x | Just x <- [Nothing, Just 3, Nothing, Just 9]] -- mostly because of how it deals with patterns that don't match
06:08:58 <lambdabot>  [3,9]
06:09:13 <elomatreb> Doesn't my solution with ++ force walking the list as well?
06:09:42 <dminuoso> elomatreb: *shrugs* https://gist.github.com/dminuoso/d4f8eaa56c1c0782e078f8ad58f31672 is what I came up with ¯\_(ツ)_/¯
06:11:17 <MarcelineVQ> dminuoso: sure, though you're going to walk it anyway to find out when you're at the end. there's also the side benefit that this will work on any list, not just Num a of a particular ordering.
06:11:38 <elomatreb> Mh, that looks like a nice solution as well, at least from an aesthetic perspective. I was probably overthinking this anyway since the number involved are small
06:12:31 <iqubic> :t readFile
06:12:33 <lambdabot> FilePath -> IO String
06:14:18 <iqubic> How do I compile and execute a file in a stack project?
06:14:32 <iqubic> I want to see if my Day 1 Part 1 solution works.
06:14:52 <dminuoso> iqubic: `stack build` and `stack exec` respectively.
06:15:42 <iqubic> Looks like I have to let stack install ghc first.
06:17:55 <MarcelineVQ> You're not using ghci to write your solutions?
06:18:53 <MarcelineVQ> You should, it's pretty great since you get immediate feedback
06:19:46 <iqubic> MarcelineVQ: Are you serious?
06:20:02 <iqubic> like write the whole thing in GHCI?
06:20:04 <dminuoso> MarcelineVQ: I like to use both! Write in atom, and :reload in GHCi :-)
06:20:24 <MarcelineVQ> If you can, but I​ meant try out different things like your list comprehension in ghci
06:21:24 <iqubic> You see how that might be helpful for Day 1, right?
06:23:46 <hpc> dminuoso speaks the big true-true ;)
06:23:51 <MarcelineVQ> iqubic: sure
06:24:03 <hpc> :r is probably the single greatest feature of ghci
06:24:05 <MarcelineVQ> dminuoso: some day when I get back to coding I need to write that hook for atom to use ghci's ide mode as a backend. this ghc-mod business is old hat
06:25:02 <fakenullie> with intero you can use C-c C-l
06:25:09 <MarcelineVQ> I think nikolay was working on it, should see how far he got
06:38:06 <dminuoso> Is there some function f :: Integer -> [a] -> [[a]] which would work: f 2 [1,2,3,4,5] = [[1,2], [2,3], [3, 4], [4, 5]], or something equivalent hidden in Prelude somewhere?
06:38:36 <dminuoso> I could also live with something like (a -> a -> b) -> [a] -> [b]
06:38:44 <dminuoso> Hoogle has revealed nothing. :(
06:39:32 <fakenullie> there's no such function, but I there was solution here yesterday
06:39:52 <fakenullie> https://stackoverflow.com/questions/27726739/implementing-an-efficient-sliding-window-algorithm-in-haskell
06:40:31 <fakenullie> dminuoso: ^
06:44:02 <dminuoso> fakenullie: Fair enough, thanks. 
06:44:08 <dminuoso> windows m = foldr (zipWith (:)) (repeat []) . take m . tails
06:44:11 <dminuoso> It's so obvious.
06:50:54 <marvin2> if you don't need the flexibility of supplying n just this will work:
06:51:08 <marvin2> > let f x = zip x (tail x) in f [1..5]
06:51:09 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
06:54:02 <dminuoso> marvin2: Oh! That's precisely what Im looking for. Neat.
06:55:39 <dminuoso> > let f x = zip3 x (drop 1 x) (drop 2 x) in f [1..5]
06:55:42 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5)]
06:55:47 <dminuoso> marvin2: Yes. That's the abstraction I wanted. :)
07:00:22 * hackage byteunits 0.4.0 - Human friendly conversion between byte units (KB, MB, GB...)  https://hackage.haskell.org/package/byteunits-0.4.0 (chrissound)
07:18:26 <iqubic> https://paste.pound-python.org/show/vurgRaAOPOEhLQKtM5gQ/ Why is stack setup being a pain?
07:21:45 <MarcelineVQ> are you using NixOS?
07:22:26 <iqubic> Yes.
07:22:28 <iqubic> I am.
07:22:58 <MarcelineVQ> info about that in this thread then https://github.com/commercialhaskell/stack/issues/826
07:23:15 <MarcelineVQ> Dunno if it's helpful info, but it's a start
07:24:11 <MarcelineVQ> has useful looking comments like  https://github.com/commercialhaskell/stack/issues/826#issuecomment-250892636
07:24:30 <iqubic> I am using ZSH too.
07:24:42 <frerich> cocreature: You don't happen to have your AoC 2017 solutions available online somewhere, do you? I briefly skimmed your GitHub account but couldn't find anything.
07:25:05 <MarcelineVQ> it may be as simple as using stack's nix options  check out  stack --nix-help for info
07:26:13 <cocreature> frerich: I’m too lazy to clean them up and I don’t want to make my ugly solutions public :)
07:27:33 <barrucadu> iqubic: If you build with `stack --nix build`, that'll fetch GHC for you from nixpkgs
07:27:37 <iqubic> I'm just going to try this: https://docs.haskellstack.org/en/stable/nix_integration/
07:28:11 <frerich> cocreature: You could put them on lpaste and have the link posted here, and nobody will know who wrote the code! :-)
07:28:38 <iqubic> barrucadu: that flag isn't valid for me for some reason.
07:29:27 <MarcelineVQ> what's your stack version?
07:30:16 <iqubic> 1.5.1
07:30:52 <cocreature> frerich: I’m not really worried about people thinking I’m too stupid to write nice code. I just prefer that people who want to learn from other people’s solution take a look at the solutions published by people who actually bother to clean up their code
07:30:54 <MarcelineVQ> not exactly old then, what does stack say when you type  stack --nix build
07:31:25 <iqubic> Oh, I thought it was --nix-build with a hyphen. Issues have been resolved
07:32:06 <frerich> cocreature: Sure, a tidy solution would be even nicer. Even quick hacks are interesting to novices like me though, mostly because I typically learn about new library functions I didn't know yet (or didn't consider for this kind of problem).
07:32:19 <frerich> cocreature: Anyway, don't mean to be pushy. I was just curious. :-)
07:32:35 <cocreature> frerich: take a look at glguy’s and jle`’s solutions
07:32:41 <iqubic> How does data.map work?
07:32:59 <MarcelineVQ> mniip tries many solutions, you should ask him about them if you want to see new things
07:34:38 <asheshambasta> hey, Haskell noob here. I'm using intellij-haskell to work on a stack project and I'm seeing something funky — adding `bytestring` to the build-depends section in my cabal file (after adding it as extra-deps in my stack.yaml) doesn't really help — it gets automatically removed from the file. Has anyone else seen this issue, or something similar?
07:35:19 <barrucadu> Are you by any chance using hpack (you have a package.yaml)?
07:35:54 <barrucadu> If there's a package.yaml, stack will use it to generate the cabal file, which would explain why additions vanish
07:35:56 <asheshambasta> barrucadu: yes 
07:36:03 <asheshambasta> I see!
07:36:47 <asheshambasta> so basically that means I cannot really edit the build-depends in the cabal file when using stack
07:36:54 <dminuoso> barrucadu: That cost me some real good headaches as well. This must be a new thing for stack to generate that file right?
07:37:07 <asheshambasta> maybe I should RTFM
07:37:12 <Adluc> barrucadu: had surprise with that vashising cabal stuff few days ago :D
07:37:32 <Adluc> on freshly initialized project
07:37:34 <cocreature> you might want to try upgrading stack. iirc 1.6 warns about this
07:37:40 <asheshambasta> Adluc: and its quite frustrating when it happens.
07:37:49 <asheshambasta> cocreature: thanks, will do
07:37:58 <barrucadu> Ah, possibly.  I've still got `cabal init; stack init` ingrained in my muscle memory, so I've never had it generate a package.yaml for me
07:39:45 <iqubic> What does stack exec do?
07:40:22 <barrucadu> Sets up your PATH to include the build directory and runs a command
07:40:38 <dminuoso> iqubic: Note the name of the executable in your cabal file.
07:40:55 <iqubic> I have done that.
07:41:13 <dminuoso> iqubic: When I said `stack exec` earlier I meant that you should of course run the executable with it. :)
07:41:47 <asheshambasta> barrucadu: thanks for the prompt reply though, that seems to have solved the problem. I'll update Stack and see if I get warnings for that the next time on. 
07:41:48 <iqubic> Well, that's not working for me.
07:42:29 <iqubic> Stack exec AoC2017-exe is not working, because that executable isn't in stack's path.
07:42:43 <barrucadu> Ah, you'll want `stack --nix exec`
07:42:45 <MarcelineVQ> stack --nix exec my
07:43:06 <iqubic> Right. I see.
07:43:30 <iqubic> Is there a way to tell stack to add --nix to all relevent stack calls?
07:44:32 <MarcelineVQ> yes, that link you yourself posted earlier says how  https://docs.haskellstack.org/en/stable/nix_integration/ I think anyway
07:44:45 <frerich> glguy: I just compared my solution to today's AoC solution ( https://github.com/frerich/aoc2017/blob/master/16.hs ) to what jle` and you did. I understand jle` 's version just fine (he did basically the exact same thing as I did) but yours is too clever for me to understand. How does your version avoid actually doing 1000000000 iterations?
07:44:48 <MarcelineVQ> with the   nix:\n  enable: true  addition to the stack.yaml
07:44:59 <MarcelineVQ> you can also add this to ~/.stack/config.yaml I believe
07:44:59 <iqubic> I have that set alread.
07:45:22 <iqubic> Well, I don't think this is working.
07:46:20 <iqubic> http://termbin.com/v0kh A
07:46:48 <iqubic> What is the name of my executable? Is it 'AoC2017-exe'?
07:47:05 <MarcelineVQ> yes
07:47:39 <iqubic> Well, something weird is happening
07:48:27 <cocreature> note that you need to "stack build" the executable before
07:48:48 <iqubic> I know that.
07:49:10 <MarcelineVQ> in fact you can be sure it's there by using  stack build --exec AoC2017-exe  to build and run it with one command
07:50:00 <MarcelineVQ> which would be   stack --nix build --exec AoC2017-exe   I'm guessing, if your config isn't setting nix enabled properly
07:50:10 <iqubic> What is happening is that looking at my .cabal file in emacs is giving me a different result than "cat AoC2017.cabal" being run in a terminal.
07:50:52 <iqubic> And for some reason I can't get my terminal, and stack by extension, to see the some .cabal file that emacs is looking at.
07:51:00 <MarcelineVQ> do you happen to have a project.yaml file?
07:51:03 <barrucadu> I guess the cabal file has been modified externally and hasn't been reloaded inside emacs?
07:51:15 <iqubic> I do have a project.yaml file.
07:51:28 <MarcelineVQ> k then use that instead of your cabal file or remove project.yaml
07:52:01 <MarcelineVQ> it's rebuilding your cabal file when stack is run, so your changes are removed
07:52:06 <dminuoso> cocreature: 1.6.1 did not warn me about overwriting changes to my cabal file
07:52:15 <MarcelineVQ> it being the project.yaml
07:52:25 <iqubic> can I remove my project.yaml file?
07:52:32 <MarcelineVQ> come on now :>
07:52:35 <iqubic> Is that a safe thing to do?
07:52:53 <iqubic> How do I stop project.yaml from changing my .cabal file?
07:52:58 <MarcelineVQ> read my words please, they're intended to help you
07:53:15 <iqubic> Sorry.
07:54:07 <cocreature> dminuoso: huh it definitely did warn me. maybeit only works in some circumstances
07:54:52 <MarcelineVQ> cocreature: it'll warn you if there isn't a stack.yaml or package.yaml in scope when you run stack
07:55:01 <inkbottle> "parse error on input" with where in do: http://lpaste.net/4684511367934246912
07:55:52 <cocreature> MarcelineVQ: that’s not what I mean. I’m referring to https://github.com/commercialhaskell/stack/issues/3383
07:56:56 <iqubic> Well this is an issue. My code don't compile
07:57:25 <iqubic> As in I have errors in the code that I need to fix.
07:58:32 <iqubic> parse :: String -> [Int] 
07:58:39 <iqubic> parse = map read
07:59:21 <iqubic> GHC is telling me that it can't match type [Char] with type [String]
07:59:24 <iqubic> What the hell?
07:59:33 <iqubic> I think that parse function should just work.
07:59:45 <Clint> why do you think that?
08:00:04 <MarcelineVQ> inkbottle: where scopes over defintions, it doesn't live inside them as you've done there, see annotation http://lpaste.net/4684511367934246912  Note the indentation here, the where here belongs to main, but not inside main
08:00:18 <MarcelineVQ> inkbottle: https://wiki.haskell.org/Let_vs._Where
08:00:37 <inkbottle> MarcelineVQ: Reading you...
08:00:38 <MarcelineVQ> erm, that's not as useful a link as I had planned for it to be, sec
08:00:52 <[exa]> iqubic: you might want to look at the type of read and map, to see what ghc thinks you're telling it
08:00:59 <inkbottle> MarcelineVQ: reading that too: https://stackoverflow.com/questions/14092801/haskell-where-clause-syntax-inside-a-do-block
08:01:30 <MarcelineVQ> alrighty that's a good looking link
08:01:33 <iqubic> Right. Duh
08:01:38 <iqubic> How do I fix my thing.
08:01:47 <Clint> what do you want your thing to do?
08:01:51 <[exa]> iqubic: what is the code supposed to do?
08:02:22 <[exa]> iqubic: also, try a type hole, compile it with 'parse :: _'
08:02:37 <iqubic> I want to take a String of digits like "138492" and turn it into a list of Ints with each element being the result of reading a single char.
08:02:52 <cocreature> iqubic: you know you could take a few minutes to think about your problems yourself instead of letting us spoon-feed every step to you
08:02:59 <iqubic> I should do that.
08:03:05 <[exa]> iqubic: do you know the difference between 'a' and "a"?
08:03:17 <iqubic> Yes I do.
08:03:36 <[exa]> iqubic: does read '1' work?
08:04:11 <MarcelineVQ> "<cocreature> MarcelineVQ: that’s not what I mean. I’m referring to https://github.com/commercialhaskell/stack/issues/3383" thank you for the link
08:04:33 <cocreature> MarcelineVQ: if you figure out why it’s not working for dminuoso let me know, I’m too lazy to look into the details :)
08:05:15 <MarcelineVQ> cocreature: do you run on git release?
08:05:25 <iqubic> Hoogle just gave me an answer
08:05:29 <cocreature> MarcelineVQ: nope, the changelog also mentions that this has made it in 1.6
08:05:34 <MarcelineVQ> alrighty
08:05:35 <iqubic> :t map digitToInt
08:05:37 <lambdabot> [Char] -> [Int]
08:07:29 <dminuoso> cocreature: Oh I know why.
08:07:31 <iqubic> Well, I think I finally at long last have a solution to part 1 of day 1
08:08:17 <iqubic> Execpt readFile is spitting out an error.
08:08:22 <dminuoso> cocreature: I upgraded stack, modified the cabal file and then ran `stack build`. It would be utterly amazing if the upgraded stack had the diagnostics to emit a warning _there_ ;-)
08:08:36 <dminuoso> I mean before building it with once with the upgraded stack.
08:08:38 <cocreature> dminuoso: ah that makes sense :)
08:08:46 <iqubic> day1: input1: openFile: does not exist (No such file or directory)
08:09:22 <iqubic> input1 and day1.hs are in the same directory. What the heck???
08:11:09 <MarcelineVQ> it's not about where your hs is. an hs file isn't an executable
08:12:02 <iqubic> Here's what I have so far. https://github.com/IQubic/AoC2017
08:12:18 <iqubic> But I have no idea where stack puts my executable.
08:12:53 <iqubic> Can I use an absolute path instead?
08:13:08 <MarcelineVQ> in .stack-work/ somewhere, but I think the working directory is the project root. so you may be able to specify from there. e.g.   openFile "day1/input1"
08:13:15 <MarcelineVQ> yes you can
08:13:30 <MarcelineVQ> *yes you can use an absolute path
08:14:09 <iqubic> can't use day1/input1
08:14:17 <iqubic> let's use an absolute path instead.
08:16:53 <MarcelineVQ> your git doesn't have your cabal file in it hehe
08:19:27 <iqubic> Should I add that?
08:19:28 <iqubic>  
08:19:49 <inkbottle> MarcelineVQ: Thanks. I will have to take more time about it but for the present it works. {where clauses are for equations\\ There are a couple of things that are possible at top level and that are not possible elsewhere (like type definition)}
08:20:15 <Franciman> Hi
08:20:36 <Franciman> I have f :: Either String Int. How can I use f inside g :: ExceptT String IO Int
08:20:49 <Franciman> to make g return what f returns?
08:22:23 <kuribas`> g = return f ?
08:22:33 <iqubic> > let f x = (+1) . (*2) in f 3
08:22:34 <lambdabot>  <Integer -> Integer>
08:22:44 <iqubic> huh?
08:22:56 <iqubic> Shouldn't that give me a single number?
08:23:04 <MarcelineVQ> not with x there
08:23:19 <MarcelineVQ> you're writing pointfree on the right but you've put a point (x) on the left
08:23:43 <iqubic> > let f = (+1) . (*2) in f 3
08:23:45 <lambdabot>  7
08:24:06 <kuribas`> Franciman: g = return f?
08:24:11 <kaol> Franciman: ExceptT . return
08:24:21 <Franciman> thank you
08:24:29 <Franciman> yes I need also ExceptT around. THanks
08:25:13 <iqubic> My answer to day 1 part 1 is bigger than the part 2 answer. Is that normal?
08:25:23 <kuribas`> Franciman: if you use IO, you can also use exceptions.
08:27:05 <Franciman> kuribas`, I'm doing this computation: make http request and parse output
08:27:14 <Franciman> so I thought IO (Either String a)
08:27:18 <Franciman> would make sense
08:27:22 <Franciman> for parsers
08:27:29 <Franciman> do you think exceptions would make life easier?
08:28:21 <kaol> I'd say it's a matter of style.
08:28:22 <kuribas`> Franciman: I wouldn't do parsing inside IO.  But throwing an IO exception on parse error would be fine by me.
08:28:50 <Franciman> here's my use case
08:28:55 <Franciman> request <$> parser
08:28:57 <Franciman> ehm
08:29:02 <Franciman> parser <$> request
08:29:18 <Franciman> and I want to compose 
08:29:27 <Franciman> so if I did a request and got a Right JSONData
08:29:33 <Franciman> I want to use JSONData to make another request
08:29:33 <iqubic> Now, how do I add a second executable section to my cabal file? Just copy the current section, and make changes where needed?
08:29:41 <Franciman> if I got Left stop there, I get the error
08:29:54 <Franciman> that's why I thought doing the parsing inside the monad transformer
08:30:03 <Franciman> to make composing a bit easier
08:30:40 <kuribas`> Franciman: that's also fine
08:32:45 <Tuplanolla> If you have a pure parser returning `Either` or `ExceptT` inside `IO`, you might want to get rid of the extra layer by handling the error conditions or throwing them as exceptions, Franciman.
08:33:07 <Tuplanolla> It's varying degrees of unpleasant to mix two exception mechanisms.
08:36:03 <Franciman> Tuplanolla, you mean having a case parser of ...
08:36:07 <Franciman> where I throw the exception?
08:36:32 <Tuplanolla> Yes.
08:37:07 <iqubic> @pl \x -> map read (lines x)
08:37:07 <lambdabot> map read . lines
08:37:31 <Franciman> thanks
08:39:42 <kuribas`> :t \e -> either (throw . e) id -- Franciman
08:39:43 <lambdabot> Exception e => (a -> e) -> Either a c -> c
08:40:05 <Franciman> perfect
08:40:21 <ertes> is there a paper on how 'ad' works?  i got the basic idea by skimming daniel brice's talk, but it seems like 'ad' is using a few tricks, and the reverse mode is still pretty much black magic to me
08:40:39 <ertes> background: i want to implement a variant that works with unboxed vectors
08:40:48 <Franciman> thanks kuribas` 
08:40:55 <kuribas`> Franciman: np!
08:40:55 <Franciman> speaking of which, what does this constraint mean: instance e ~ SomeException => MonadThrow (Either e) where
08:40:57 <Franciman> ?
08:41:17 <Tuplanolla> Write a pure nonlinear optimization package while you're at it, ertes.
08:41:56 <glguy> Franciman: e ~ SomeException is an "equality constraint"
08:42:09 <glguy> that instance is written this way so that the instance matches as early as possible
08:42:10 <ertes> Tuplanolla: i'd just bind to one of the many C/C++ libraries in that case…  nonlinear optimisation is a numeric method
08:42:22 <ertes> *numerical
08:42:36 <Franciman> ah ok, thanks
08:43:04 <glguy> Franciman: The instance is written this way so that GHC will commit to this instance as soon as it sees Either, not waiting to see SomeException
08:43:41 <iqubic> There has to be something better than this:
08:43:50 <iqubic> map (map read) . (map words) . lines
08:44:49 <iqubic> It takes a string, like day 2's input and turns it into [[Int]] repersenting the data.
08:44:52 <Tuplanolla> All of the existing bindings are horrible, ertes.
08:45:02 <fakenullie> map (map read words) . lines
08:45:07 <Franciman> glguy, clear. THanks
08:45:12 <fakenullie> map (map read . words) . lines
08:45:16 <dminuoso> glguy: What is the reason for this? Is such behavior used in the scenario of UndecideableInstances?
08:45:45 <iqubic> fakenullie: How does that work?
08:45:57 <iqubic> Oh, I see.
08:46:25 <iqubic> (f x) . (g x) is the same as (f . g) x
08:46:46 <fakenullie> not really
08:46:47 <dminuoso> what
08:47:16 <iqubic> Sorry I meant (f x) . (f y) is the same as f (x . y)
08:47:29 <Tuplanolla> Not really.
08:47:49 <dminuoso> iqubic: What do you think (.) is?
08:47:58 <iqubic> Function composition.
08:48:06 <fakenullie> @pl (f x) . (g x)
08:48:06 <lambdabot> f x . g x
08:48:29 <fakenullie> @pl h x = (f x) . (g x)
08:48:29 <lambdabot> h = liftM2 (.) f g
08:48:46 <iqubic> f x . g x is the same as (f . g) x right?
08:48:51 <fakenullie> no
08:49:01 <dminuoso> iqubic: Can you name the definition of (.) from the top off your head?
08:49:21 <dminuoso> (And by "the" I mean any extensionally equivalent definition)
08:49:36 <Logio> iqubic: the identity you're looking for is map f . map g = map (f . g)
08:49:41 <iqubic> (f . g) x = f (g x)
08:49:55 <iqubic> logio, that's a functor law.
08:50:14 <dminuoso> iqubic: (.) is a special case of fmap.
08:50:17 <iqubic> But it doesn't hold true if you stick a different function in instead of map?
08:50:55 <dminuoso> iqubic: Why should it?
08:51:07 <dminuoso> iqubic: Ignore map, and consider fmap it in general.
08:51:15 <iqubic> So (f x) . (f y) == f (x . y) only works if f is fmap?
08:51:33 <dminuoso> iqubic: not only.
08:51:39 <geekosaur> remember that a typeclass is a way to jam together different functions that behave in some 'same way'
08:51:43 <iqubic> I know.
08:51:50 <dminuoso> iqubic: There's probably some bizarre exotic solutions that also fit that bill.
08:52:10 <iqubic> I'm going back to Advent of Code.
08:52:21 <dminuoso> 17:50        iqubic | So (f x) . (f y) == f (x . y) only works if f is fmap?
08:52:36 <dminuoso> iqubic: this is just a way of expressing that a functor is structure preserving (it's it a homomorphism)
08:52:45 <dminuoso> And the structure that fmap preserves, is that of function composition.
08:53:22 <Tuplanolla> There's an easy counterexample.
08:53:38 <ertes> Tuplanolla: well, sorry…  i don't have any use for nonlinear optimisation right now =)
08:54:05 <Tuplanolla> If you limit the domain of the points, you don't have sufficient parametricity for a functor, but the thing may still be structure-preserving.
08:54:14 <dminuoso> iqubic: So basically a Functor says: If two functions compose, then the transformed functions (through the functor) also compose.
08:54:28 <iqubic> I get it now.
08:54:29 <ertes> a few years ago i was mildly interested in SVMs, but that interest quickly dropped after i learned more about modern neural networks
08:55:17 <Tuplanolla> It's just a shame, because nonlinear optimization is the perfect use case for `ad`, ertes.
08:55:39 <siwica> What are stack targets and how do I use them to run tests from within emacs (+ intero)?
08:56:00 <ertes> Tuplanolla: why?  the point of 'ad' is to be exact by construction and not involve any computation
08:56:51 <Tuplanolla> You can improve the process by providing more derivatives.
08:57:38 <ertes> Tuplanolla: i don't understand
08:57:45 <dminuoso> iqubic: That being said...  (x .) . (y .) == (.) (x . y)
08:57:50 * hackage load-env 0.1.2 - Load environment variables from a file.  https://hackage.haskell.org/package/load-env-0.1.2 (PatrickBrisbin)
08:57:54 <ertes> but that may be due to my inexperience with AD techniques
08:58:05 <Tuplanolla> The optimizers usually work better when given a function with its derivatives.
08:58:17 <Tuplanolla> Otherwise they need to be approximated by finite differences or such.
08:58:33 <ertes> Tuplanolla: i think you're still having numerical differentiation in mind
08:58:41 <ertes> that's not what AD does
08:59:51 <Tuplanolla> Numerical differentiation makes the optimizers slow and unstable.
09:00:04 <ertes> there are no taylor series involved, if that's what you mean…  it does kind-of-symbolic differentiation
09:01:27 <ertes> @let import Numeric.AD
09:01:28 <lambdabot>  .L.hs:138:1: error:
09:01:28 <lambdabot>      Could not find module ‘Numeric.AD’
09:01:28 <lambdabot>      Perhaps you meant
09:03:09 <iqubic> @pl \x -> maximum x - minimum x
09:03:09 <lambdabot> liftM2 (-) maximum minimum
09:03:18 <iqubic> Which looks better?
09:05:55 <glguy> If I want ">>> :set -XDataKinds" in my doctest, do I have to specify that as a part of every haddock comment that has doctests? Is there a way to do it once and for all in the -- $setup or something like that?
09:06:02 <fakenullie> > liftA2 (-) maximum minimum [1, 2, 3]
09:06:05 <lambdabot>  2
09:06:50 <dminuoso> Aha.. so `(a -> b)` is an `Arrow (->) a b` ?
09:06:59 <iqubic> Yes.
09:10:21 <dminuoso> Or.. actually that doesn't work kind-wise.
09:10:23 <dminuoso> I see.
09:11:55 <iqubic> [a `div` b | a <- lineVal | b <- lineVal, a /= b, a `mod` b == 0]
09:12:37 <iqubic> And I get the result "Unxepected parallel statement in list comprehension"
09:12:40 <iqubic> Why is that?
09:13:08 <hexagoxel> iqubic: [ | | , ] instead of [ | , , ]
09:13:36 <iqubic> Hexagoxel, I have two generators, and two tests there.
09:13:55 <[exa]> how do I read this syntax?   f ::  (?x::Int) => a -> Int
09:14:03 <[exa]> (taken from https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XConstrainedClassMethods )
09:14:32 <liste> [exa]: you mean the ?x
09:14:41 <[exa]> yes
09:14:48 <[exa]> and also ::Int after that
09:15:05 <liste> [exa]: it's a implicit parameter
09:15:09 <hexagoxel> iqubic: | is no requirement for generator.
09:15:17 <liste> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters
09:15:24 <hexagoxel> > [ (x, y) | x <- [1,2], y <- [3,4] ]
09:15:28 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
09:15:38 <iqubic> I think my issue is that a and b are pulling from the same list.
09:15:59 <[exa]> liste: oh, thanks
09:16:25 <iqubic> > let x = [1,2,3] in [(a,b) | a <- x, y <- x]
09:16:27 <lambdabot>  [(1,b),(1,b),(1,b),(2,b),(2,b),(2,b),(3,b),(3,b),(3,b)]
09:16:47 <iqubic> > let x = [1,2,3] in [(a,b) | a <- x, b <- x]
09:16:50 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
09:17:08 <iqubic> Oh, wait that works? Even with a and b pulling from the same list?
09:17:28 <hexagoxel> > [1,2] >>= \x -> [3,4] >>= \y -> [(x,y)]
09:17:31 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
09:17:46 <fakenullie> functions don't alter their arguments
09:17:46 <iqubic> Well I'm a lot bit confused now.
09:19:37 <iqubic> This compilation message confuses me. http://dpaste.com/34V7PPH
09:19:49 <liste> > let {func :: (?x :: Int) Int -> -> Int; f y = ?x + y} in (let {?x = 5} in func 5)
09:19:51 <lambdabot>  <hint>:1:33: error: parse error on input ‘->’
09:20:00 <liste> > let {func :: (?x :: Int) => Int -> -> Int; f y = ?x + y} in (let {?x = 5} in func 5)
09:20:02 <lambdabot>  <hint>:1:36: error: parse error on input ‘->’
09:20:06 <iqubic> Two arrows in a row there.
09:20:14 <liste> yeah
09:20:47 <hexagoxel> iqubic: you might want to use the `line` binding there.
09:21:24 <iqubic> hexagoxel: I need to replace lineVal on the RHS with line.
09:21:29 <liste> > let {func :: (?x :: Int) => Int -> Int; func y = ?x + y} in (let {?x = 5} in func 5)
09:21:31 <lambdabot>  10
09:21:35 <[exa]> liste: is it really useful for anything?
09:21:35 <liste> got it :)
09:22:05 <liste> [exa]: not very, people use it as a placeholder with lambdabot sometimes
09:22:24 <[exa]> :] ok
09:22:46 <geekosaur> [exa], haven't seen a lot of use in practice (but note that CallStack is implemented that way!)
09:22:47 <hexagoxel> iqubic: and the general advice is: if the type error does not make sense, add more type signatures. in this case for lineVal.
09:23:07 <geekosaur> but in lambdabot it can be a way to get type inference for something buried deep inside a larger expression
09:23:21 <geekosaur> although holes are a better way to do it these days, arguably
09:23:42 <[exa]> interesting, I'll look at callstack
09:23:43 <[exa]> thanks
09:23:44 <iqubic> http://dpaste.com/3HCTJ8N
09:24:30 <iqubic> In that latest paste my issue is that lineVal is [Int] instead of Int
09:25:08 <iqubic> If I know that lineVal will only ever have a single element, because the Advent of Code day 2 part 2 tells me so, how can I flatten the list?
09:26:17 <iqubic> I need something that will take a list with single element, and extract that element for me.
09:27:11 <iqubic> Screw this, I'm using head.
09:27:11 <iqubic>  
09:29:45 <iqubic> How does Data.Map work?
09:30:35 <frerich> iqubic: Picture yourself in a big auditorium in front of a microphone, and 1754 people are listening to what you say.
09:31:16 <dminuoso> frerich: That's one mighty attentive audience.
09:31:37 <iqubic> frerich: Then one of them will be able to teach me about Data.Map.
09:32:17 <frerich> dminuoso: Granted, it's an ideal. In reality, about three people will be sneezing at any given moment, six will be laughing, three pens get dropped etc. ;-)
09:34:02 <glguy> iqubic: You'll get more answers when you ask more specific questions. Maybe started reading the documentation for Data.Map, or even peeking at its source will help you form such questions
09:43:15 <dminuoso> glguy: It's mindbogging how many Haskell library functions follow the "do one thing, and do it well" principle do the point that you can just look at 3 lines of code, and immediately reason about what it probably does. :-)
09:43:32 <dminuoso> So far it's been hard to find some function that is longer than say 5 LoC.
09:43:52 <iqubic> Yeah, I have noticed that.
09:43:55 <dminuoso> (And Im not talking about something that has been flipped lifted and composed into a golf world record.)
09:45:43 <glguy> Is there a foldl1'-like operation for Data.List.NonEmpty.NonEmpty in base somewhere?
09:46:16 <AndreasK> glguy: Isn't nonempty foldable?
09:46:54 <glguy> Yeah, I could use Foldable's toList first
09:47:09 <AndreasK> Oh there is only a list version for that.
09:47:18 <fakenullie> nonEmptyToList
09:47:58 <glguy> I guess this works:   sconcat (x :| xs) = foldl' (<>) x xs
09:48:16 <fakenullie> or foldl` f (neHead l) neTail l
09:48:23 <iqubic> Do I have to do all the days of AoC, or can I skip to the current days?
09:48:41 <iqubic> Do I have to do them in chronological order?
09:48:46 <fakenullie> glguy: that should work efficiently
09:49:11 <lordcirth> iqubic, it unlocks in order
09:49:23 <fakenullie> I think it's all unlocked
09:49:35 <fakenullie> up to curren tone
09:49:52 <lordcirth> Oh, right, they unlock by day, not by completion. nvrm
09:49:53 <glguy> As soon as midnight in New York, that day's puzzle is open to everyone
09:50:07 <glguy> iqubic: You can learn this by clicking on the website you're looking at
09:50:26 <iqubic> Should I do the puzzle all in order>
09:50:48 <glguy> sure
09:51:18 <iqubic> But that will take a while.
09:51:41 <fakenullie> they are getting harder
09:52:07 <glguy> iqubic: Asking us these questions is making it take longer, too!
09:53:01 <iqubic> I have no idea what to do about the spiral puzzle.
09:53:21 <EvanR> good
09:53:33 <EvanR> your brain is upgrading, please wait
09:53:50 <iqubic> why do you say that?
09:54:38 <EvanR> if you knew what to do instantly and effortlessly it wouldnt be much of a puzzle
09:54:46 <EvanR> and you wouldnt get anything out of it
09:55:57 <lordcirth> Although, I prefer project euler style questions to the puzzles that AoC likes to make
09:57:18 <iqubic> If I knew how to use Data.Map I could perhaps make a map of all the squares in the grid and their values, and brute force the solution.
09:57:56 <glguy> Yes, using a Map for that would be a good idea
09:58:38 <iqubic> But I don't know how to use map.
10:02:47 <cocreature> Data.Map has fairly good documentation so start by reading that
10:05:50 <monochrom> There was a time I didn't know how to use Data.Map, too.
10:23:18 <frerich> glguy: I just saw your posting at https://www.reddit.com/r/adventofcode/comments/7k572l/2017_day_16_solutions/drbsden/ but I'm not sure I grok it; what do you mean by a 'renaming' when you say that the dance can be decomposed 'into a renaming and a permutation, (and the renaming is just another permutation) '?
10:25:14 <frerich> glguy: My impression was that any single move yields a new permutation - I think I don't understand which of those permutations can be considered 'renamings'.
10:25:27 <fiatjaf> thank you, hpc and cocreature 
10:25:34 <fiatjaf> I'm try positional matching.
10:25:38 <iqubic> See, if I make a declaration like: "type spiral = Data.Map (Int, Int) Int" then I lose out on many of the Map functions.
10:26:02 <iqubic> Because (Int, Int) for X Y positions can't be ordered.
10:26:35 <fiatjaf> one more question: in Elm, if I have a type like Animal = Human { arms :: Int } | Dog { tails :: Int }, then it's possible to have functions that take an Animal as a parameter, these functions must account for both Human and Dog cases. how is that in Haskell? I've only seen types that are themselves, like data Human = Human {}
10:26:54 <glguy> iqubic: No, that's not the case
10:28:17 <iqubic> What do you mean glguy?
10:28:31 <glguy> Your previous message was wrong
10:28:54 <frerich> fiatjaf: What you posted is actually almost valid Haskell code, i.e. 'data Animal = Human { arms :: Int } | Dog { tails :: Int }'.
10:29:32 <iqubic> It was? How? How was it wrong?
10:29:46 <frerich> fiatjaf: That declaration has the effect you describe, i.e. a type 'Animal' is defined and functions accepting values of that type need (well, should) account for both Human and Dog cases.
10:31:01 <fakenullie> how will arms (Dog 1) work?
10:31:38 <liste> fakenullie: it'll throw an error
10:31:50 <liste> so it's usually not a good ideda
10:31:52 <frerich> fakenullie: That's up to the 'arms' function; maybe it yields zero. Or four. Or it raises an error?
10:32:04 <iqubic> Glguy: How was my statement wrong?
10:32:11 <fakenullie> frerich: it's defined here
10:32:25 <sssilver_> just finished day 2 of AoC -- all code review is welcome!! https://github.com/sssilver/adventofcode2017/blob/master/02.hs
10:32:33 <sssilver_> I feel like a GOD
10:32:36 <iqubic> frerich: the arm function is not written by you.
10:32:40 <sssilver_> I never thought I could actually code stuff in Haskell
10:32:47 <frerich> fakenullie: Oh, it is? Sorry, I must have missed that.
10:33:05 <fakenullie> frerich: it's defined in the type as record accessor
10:33:07 <iqubic> It was created when you define the animal data.
10:34:52 <frerich> Oh, sorry, I did not notice that the field was called 'arms', I tought that was just something fakenullie made up.
10:43:09 <AndreasK> sssilver_: Is there a reason why you used Real and not int?
10:43:19 <sssilver_> AndreasK yeah Real is Ord
10:43:20 <Average-user> glguy: can you tell me what gives as a result of Day16 part2 with my input? 
10:43:34 <sssilver_> why should I need Int?
10:43:40 <sssilver_> my code ought to work with all numbers
10:43:45 <sssilver_> where it makes sense
10:43:46 <glguy> Average-user: You can check your answer just by submitting it to the website
10:43:50 <glguy> If you're wrong it just makes you wait a minute
10:44:05 <Average-user> glguy: I know, I'm in day16 ...
10:44:17 <sssilver_> damn, I just realized every person on this channel is doing an advent of code in haskell :(
10:44:23 <Average-user> glguy: But I need to check them faster
10:44:24 <sssilver_> I guess I'm not a unique special snowflak :(
10:44:30 <sssilver_> *snowflake
10:44:37 <Average-user> sssilver_: No, Im doing it in Prolog
10:44:49 <sssilver_> :x
10:45:16 <Average-user> glguy: I think I'm having a off-by-(a little more than one) error
10:45:17 <glguy> Average-user: If your algorithm is too slow, you'll need to implement a different algorithm
10:45:45 <Average-user> glguy: My algorithm is not slow, the time that I have to wait to check my results is to long
10:47:14 <Average-user> glguy: or give me your input and your result, that way I cant cheat, if thats the problem herwe
10:47:53 <glguy> Average-user: My solution is on github, you can run it on any inputs you might want
10:48:09 <glguy> it might be useful to run it on smaller values to see if your solution is keeping up after 2 or 3 iterations
10:48:28 <glguy> when you run it you can give your input file as a command-line argument
10:49:48 <Average-user> glguy: with file, you mean the actual content or the path?
10:49:56 <AndreasK> sssilver_: Checksums usually deal with integers hence I wondered.
10:50:03 <glguy> path, if you give it the filename -, then it reads the file from stdin
10:50:08 <sssilver_> AndreasK that's a fair observation
10:55:36 * hackage pg-harness-server 0.5.0 - REST service for creating temporary PostgreSQL databases  https://hackage.haskell.org/package/pg-harness-server-0.5.0 (BardurArantsson)
10:57:10 <AndreasK> sssilver_: Also if you don't specify the number type it will default to Integer. Which while correct is a lot slower than using Int and if performance matters usually not what you want.
10:57:40 <sssilver_> AndreasK you refer to where I pass the input?
10:58:20 <kakashiAL> in javascript you have promises, there you have methods called then() which is map and flat map at the same time, depending on the input but what I want to know is why haskell does not the do same? I mean depending what we have we have to use map or flat map
10:58:23 * hackage pg-harness-client 0.5.0 - Client library for pg-harness-server  https://hackage.haskell.org/package/pg-harness-client-0.5.0 (BardurArantsson)
10:58:47 <kakashiAL> what is the wisdome to not have a function that does both?
10:59:31 <AndreasK> sssilver_: Yes, but it applies to polymorphic number literals in general
10:59:39 <sssilver_> AndreasK yeah that makes sense
10:59:43 <sssilver_> thanks!
11:01:25 * hackage queryparser 0.1.0.0 - Analysis and parsing library for SQL queries.  https://hackage.haskell.org/package/queryparser-0.1.0.0 (HeliWang)
11:02:11 <fiatjaf> frerich: I get it, then the difference is just that in Elm they MUST, in haskell they SHOULD.
11:02:26 <fiatjaf> shouldn't it be a compile error if a function doesn't account for all possible cases? why not?
11:04:33 <frerich> fiatjaf: I agree that functions which are not well-defined for all inputs ("partial" functions) should be enjoyed very carefully. :-) However, sometimes you can make assumptions about values which are not enforced by types.
11:05:35 <frerich> fiatjaf: For instance, the 'group' function promises that it won't yield groups of size zero -- but it doesn't bother to express this using a 'non-empty list' type. It justs uses a regular list value. You can safely call the partial function 'head' on those (which unconditionally yields the first element of a list and bails out if you give it an empty list).
11:07:03 <fiatjaf> but then we're in the Javascript-land again ("again" for me, who just came from there) :P
11:07:06 <Tuplanolla> Should every operation on integers return a `Maybe` result in case there's an overflow?
11:07:09 <frerich> fiatjaf: To me (I'm just an amateur though), partial functions are a bit like a mental speed bump when reading; I always slow down and squint to spot kids running after a ball. 
11:07:45 <fiatjaf> is there a way to tell the compiler we don't want a function to be partial?
11:07:54 <frerich> fiatjaf: GHC can be made to warn you in case you forgot to pattern-match on some value, yes.
11:08:39 <fiatjaf> Tuplanolla: well, no, as there shouldn't be a Maybe in case your computer explodes or something like that, it looks to me
11:09:36 <fiatjaf> but I'm just trying to understand.
11:09:38 <Tuplanolla> How about a division by zero? How about inverting a singular matrix? How about trying to index an empty list?
11:09:48 <fiatjaf> ok, ok.
11:09:58 <Average-user> Tuplanolla: how about 0^0?
11:10:06 <fiatjaf> I get it.
11:10:19 <fiatjaf> you're right.
11:10:20 <Tuplanolla> You don't have to draw the line, but then programming will be suffering.
11:10:58 <Tuplanolla> (Although I don't oppose that as much as some people.)
11:11:41 <Average-user> why does haskell return Infinity when division by zero? That it's true only if you talk just about Natural numbers
11:12:05 <cocreature> Average-user: because that’s how ieee754 specifies division by zero
11:12:07 <Tuplanolla> Blame IEEE 754, Average-user.
11:12:36 <Average-user> what the hell is that , a paper?
11:12:37 <cocreature> note that this is only true for floating points
11:12:44 <cocreature> 1 `div` 0 throws an exception
11:12:58 <cocreature> Average-user: the standard for floating point numbers that’s implemented by pretty much all languages & cpus
11:13:10 <Average-user> ahh
11:13:35 <fiatjaf> ok, next question (I hope it is the last for today): I have a type UserResponse { user :: User } and User { id :: Text, email :: Text }. when I try to pattern match this in a function with `f (UserResponse (User id email)) =` I get the error: "Not in scope: data constructor ‘User’"`. what am I missing? it is in scope!
11:14:18 <cocreature> fiatjaf: are you sure the data constructor is in scope and not just the type?
11:14:22 <Average-user> cocreature: Does IEEE 754 say that 0^0 should be 1?
11:14:44 <fiatjaf> cocreature: no, just the type.
11:14:55 <cocreature> fiatjaf: well then that’s your problem :)
11:15:02 <fiatjaf> ahahah, yeah
11:15:05 <fiatjaf> cocreature, how do I expose the data constructor if it has the same name?
11:15:23 <fiatjaf> good catch, by the way. thanks.
11:15:29 <cocreature> you can use "import Module (User(..))" to import all constructors of the type User
11:15:37 <fiatjaf> oh, pure magic.
11:16:12 <cocreature> or "import Module (User(User))" to import only the User constructor
11:17:42 <glguy_> > 0**0
11:17:44 <lambdabot>  1.0
11:18:07 <f-a> I am trying to automatically derive Serialize, but failing http://lpaste.net/360837
11:18:11 <cocreature> Average-user: ieee754 doesn’t specify ^ at all afaik, it specifies (**)
11:19:18 <glguy_> f-a: you need to derive an instance of Generic
11:20:35 <f-a> thanks glguy_ 
11:20:42 <Lokathor> what's the one that turns an thing with type `x (y z)` into a `y (x z)`
11:21:04 <liste> :t sequence
11:21:05 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:21:12 <Lokathor> ah ha that's the one
11:21:29 <f-a> @hoogle x (y z) -> y (x z)
11:21:29 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoerceP :: a wX wY -> a wB wC
11:21:29 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoercePStart :: a wX1 wY -> a wX2 wY
11:21:29 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoercePEnd :: a wX wY1 -> a wX wY2
11:21:38 <f-a> mhhh
11:21:42 <cocreature> how that’s impressively bad
11:21:45 <cocreature> *wow
11:21:45 <f-a> yup
11:22:13 <f-a> to be fair Lokathor question was "broader" than sequence
11:22:31 <f-a> I don't think a function like that exists (without constraints)
11:22:47 <cocreature> @hoogle (Applicative f, Traversable t) => t (f a) -> f (t a)
11:22:48 <lambdabot> Prelude sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:22:48 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:22:48 <lambdabot> BasicPrelude sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:24:28 <Lokathor> I was asking because a friend wanted to turn a Vec<Result<_,_>> into a Result<Vec<_>>, and I wanted to jibe them a bit
11:24:32 * hackage queryparser-hive 0.1.0.0, queryparser-vertica 0.1.0.0, queryparser-presto 0.1.0.0 (HeliWang): https://qbin.io/31unbae
11:24:39 <f-a> glguy_: in my Real Life® occourrence, the type is defined in a library I don't own.
11:24:42 <Lokathor> but at first i was thinking it was traverse
11:24:53 <f-a> is there a way to automagically write instance Generic A?
11:25:10 <Franciman> f-a, DerivingGeneric or something like that extension?
11:25:16 <cocreature> Lokathor: it almost is: sequenceA = traverse id
11:25:35 <Franciman> f-a, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GenericDeriving
11:25:37 <f-a> Franciman: data A = A deriving (Generic) -- this works
11:26:02 <cocreature> "deriving instance Generic A"
11:26:03 <f-a> data A = A ; instance Generic A -- this does not with • No instance for (GSerializePut (Rep A)) [...]
11:26:13 <cocreature> but that introduces an orphan instance which can be problematic
11:26:27 <f-a> cocreature: it's an executable
11:26:35 <f-a> so there should be no probs
11:26:39 <cocreature> yeah
11:26:40 <glguy> f-a: That's now hot to derive the Generic instance
11:26:49 <glguy> f-a: You need: data A = A deriving (Generic)
11:27:18 <glguy> What you wrote doesn't derive a Generic instance, it create a new empty one
11:27:51 <glguy> One of the side effects of deriving a Generic instance is that type family instances of Rep are derived for your type
11:28:07 <f-a> glguy: what if A is defined in a library that I am importing via build-depends? no dice?
11:28:11 <glguy> but since you didn't do that step you got these new type errors involving Rep A
11:28:22 <glguy> which should have evaluated to some other type but can't
11:28:41 <glguy> f-a: The correct solution there is to derive the Generic instance in the module that defines the type
11:29:12 <glguy> There's a way to derive an orphan instance using the StandaloneDeriving extension, but it should generally be avoided
11:29:38 <cocreature> that’s the solution I hinted at above
11:29:45 <f-a> yup
11:30:05 * glguy doesn't have time to "read the backlog"
11:30:07 <glguy> :-p
11:30:59 <cocreature> glguy: finding the question requires going back further in the backlog than finding my answer :)
11:31:16 <cocreature> ah no this started before, nvm :)
11:31:31 <glguy> cocreature: what, read things linearly??
11:32:25 <cocreature> glguy: sorry, I know I’m oldschool :)
11:36:54 <ReinH> glguy is not bound by your parochial notion of spacetime.
11:37:24 <ReinH> He's perfectly capable of having read one thing in the backlog but not another, nearer thing in the backlog.
11:37:31 * glguy adds a mode to his client to present chat messages in a randomized order
11:40:13 <Average-user> > :t on
11:40:16 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:40:22 <glguy> :t on
11:40:23 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:40:35 <Average-user> :t on
11:40:36 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
11:40:38 <Average-user> ahh
11:40:41 <glguy> neat, still the same
11:40:47 <Tuplanolla> :t off
11:40:49 <lambdabot> (a -> b) -> (b -> b -> c) -> a -> a -> c
11:41:12 <Average-user> what libraries this has this bot? 
11:43:01 <Average-user> what libraries has this bot? ****
11:43:04 <liste> Average-user: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/Pristine.hs.default has the default imports
11:43:26 * hackage static-tensor 0.2.1.0 - Tensors of statically known size  https://hackage.haskell.org/package/static-tensor-0.2.1.0 (vagarenko)
11:43:42 <Average-user> :m System.Environment
11:44:10 <Average-user> It is possible to load more?
11:44:16 <jle`> there is apparently a blockchain written in Haskell trading at 30c/coin apparently 
11:44:58 <cocreature> jle`: cardano/ada?
11:45:05 <jle`> yeah
11:45:09 <Average-user> >Data.Sequence.fromList [1,2,3]
11:45:09 <cocreature> that’s the one from iohk
11:45:16 <jle`> i haven't heard anything about it from the haskell community
11:45:26 <cocreature> they’ve hired a ton of Haskellers
11:45:27 <jle`> i only saw it from one of my cryptocurrency nut friends
11:45:38 <cocreature> I think even phil wadler works for them?
11:45:46 <jle`> hm definitely interesting :O
11:45:52 <cocreature> https://iohk.io/team/philip-wadler/
11:46:03 <jle`> oh hey neat
11:46:19 <jle`> has there been any buzz about this in the haskell community?  have i just missed it?
11:47:10 <cocreature> I’ve seen a bit
11:47:22 <cocreature> mostly on twitter
11:47:39 <cocreature> https://iohk.io/team/ has more familiar names
11:51:08 <jle`> hm i recognize the names, which is why i'm surprised i hadn't heard of it sooner
11:56:29 <pja> Wow. That is a /lot/ of people. Some of them are clearly consultants (Well Typed people etc) though.
11:59:26 <pja> Their web page does horrible things to FF. Wonder what it’s doing? (Mining monero maybe ? :)  )
12:00:08 <AcquaCow> hmm
12:08:33 <int-e> I miss static websites.
12:08:57 <EvanR> arent they making a comeback of sorts
12:27:20 * hackage servant-exceptions 0.1.0 - Extensible exceptions for servant APIs  https://hackage.haskell.org/package/servant-exceptions-0.1.0 (ch1bo)
12:31:44 <iqubic> Is it just me, or is Day 3 with the spiral super hard.
12:32:26 <xacktm> not just you, I couldn't find a mathematical representation to coords
12:32:59 <iqubic> All I found is that you go straight for a while, and whenever (abs x == abs y) you turn.
12:33:34 <iqubic> I have no idea how to put that into haskell code though.
12:34:28 <silverdust> Hi everyone!
12:34:41 <silverdust> My first day trying out haskell
12:35:27 <c_wraith> silverdust: hi!  any questions?
12:35:52 <silverdust> what's your preferred method of installation (on mac os)
12:36:25 <silverdust> I'm about to try a `brew install haskell` but my guess is there might be a preference from regular users over that
12:37:15 <c_wraith> depends on your goals..
12:37:49 <glguy> The Haskell Platform minimal installer gets you the standard project building tools and compiler
12:37:57 <c_wraith> Since you're a complete beginner, I might install the "Haskell For Mac" IDE, if you have disposable income.
12:38:06 <c_wraith> I've heard that it's completely fantastic for beginners
12:38:20 <glguy> Yeah, Haskell for Mac is a nice workbook environment
12:38:23 <iqubic> I am trying to do Day 3, but I am starting to hate spirals quite a bit.
12:38:58 <glguy> The solution to hating spirals is to finish day 3 and not look at it again
12:39:24 <silverdust> Oh wow an IDE. I'll look into it. I'm a vim user so I was hoping for something more like gcc
12:39:41 <iqubic> glguy: I'm trying to do that as fast as possible.
12:39:51 <c_wraith> silverdust: you don't need the IDE, I just hear a lot of good things about it.  :)
12:39:58 <iqubic> I just can't seem to do this. Not even part 1
12:40:36 <MarcelineVQ> iqubic: done day 2 already? good job!
12:40:45 <silverdust> Okay. Of the 3 install methods, minimal, stack, and haskell platform, I guess I'd want to go with the haskell platform
12:40:46 <c_wraith> silverdust: If you just want a command-line toolchain, I'd look into an install of the haskell platform, as glguy suggested
12:41:11 <glguy> the minimal platform comes with stack, too, so you'll be all set if you find yourself needing that later
12:42:12 <silverdust> Okay thanks a lot y'all
12:42:36 <iqubic> MarcelineVQ: Day 2 is on my github page, if you want a link to that.
12:43:37 <iqubic> https://github.com/IQubic/AoC2017
12:43:43 <iqubic> Not that great of a thing.
12:43:52 <MarcelineVQ> iqubic: how come you use init on your input?
12:45:36 <iqubic> To get rid of new lines at the end of the file.
12:45:49 <glguy> newlines are line terminators, you don't need to get rid of the last one
12:45:57 <iqubic> Each file ends in a.
12:46:01 <glguy> They aren't line separators
12:46:15 <iqubic> I never lines the stuff for the first day.
12:46:43 <glguy> > lines "12\n34\n"
12:46:46 <lambdabot>  ["12","34"]
12:46:46 <byorgey> in this particular case I agree the init is unnecessary, because 'lines' is called, but as a template it's probably good idea. I have definitely gotten the wrong answer because of forgetting about the trailing newline, in case the task is to just process a single string
12:47:18 <glguy> I've been using   head . lines   to protect against invalid text files
12:47:25 <iqubic> Yeah. I know.
12:47:43 <byorgey> yeah, head . lines is probably an even better idea.
12:47:55 <byorgey> works whether there is a trailing newline or not.
12:49:14 <dmwit> I submitted an incorrect bug report to coreutils one time because I misunderstood "newlines are not line separators".
12:49:31 <dmwit> A file containing "abc\ndef" has one line according to wc.
12:49:37 <MarcelineVQ> iqubic: It's hard to tell what your lineVal function is doing in part2, but I think you'd say the same about my answer so that's not a critique hehe
12:49:47 <dmwit> (And this is not a bug.)
12:49:56 <glguy> dmwit: Do they have an FAQ about that?
12:50:34 <dmwit> I don't think so. Their answer to me was to point somewhere inside the POSIX spec, and I guess if they had an FAQ they would have pointed me there instead.
12:51:12 <MarcelineVQ> iqubic: I like this day 2, good work
12:58:13 <ggVGc> hi
12:58:18 <ggVGc> is it a haskell day today
12:58:25 <MarcelineVQ> 2/3 haskell
12:58:37 <MarcelineVQ> 1/3 winter
12:58:41 <iqubic> Well, my spiral thing is being a pain in the effing ass.
12:58:41 <iqubic> Well, my spiral thing is being a pain in the effing ass.
12:58:41 <iqubic> Well, my spiral thing is being a pain in the effing ass.
12:58:42 <iqubic> Well, my spiral thing is being a pain in the effing ass.
12:58:44 <iqubic> Well, my spiral thing is being a pain in the effing ass.
12:58:48 <iqubic> Well, my spiral thing is being a pain in the effing ass.
12:58:48 --- mode: ChanServ set +o glguy
12:58:48 <ggVGc> okay
12:58:48 --- kick: iqubic was kicked by glguy (iqubic)
12:59:06 <glguy> No
12:59:09 <EvanR> ggVGc: yes
12:59:23 <ggVGc> EvanR: what are you working on nowadays
12:59:24 <EvanR> youre going to love this
12:59:28 <iqubic> Alright that was me screwing up ERC and Emacs
12:59:36 <EvanR> ggVGc: a haskell arcade game
12:59:40 <ggVGc> sick
12:59:48 <EvanR> ikr
12:59:49 <ggVGc> how good is haskell for that?
13:00:05 <EvanR> as we all know, it is amazing at such things
13:00:06 <MarcelineVQ> you misunderstand, it's an arcade game about haskell, you shoot arrows you see
13:00:10 <iqubic> I accidentally told ERC to send the same message 8 times.
13:02:18 <iqubic> I need some help with this spiral thing.
13:02:52 <iqubic> Is there a way to recursively and lazily generate the spiral element by element.
13:02:52 <iqubic> I need some help with this spiral thing.
13:02:52 <iqubic> Is there a way to recursively and lazily generate the spiral element by element.
13:02:52 <iqubic> I need some help with this spiral thing.
13:02:56 <iqubic> Is there a way to recursively and lazily generate the spiral element by element.
13:02:59 --- kick: iqubic was kicked by glguy (iqubic)
13:03:02 <ggVGc> uhm
13:03:04 <MarcelineVQ> :>
13:03:12 <ggVGc> maybe that guy should not run his irc in his emacs
13:04:03 <dmwit> I, too, like to run my IRC outside of my OS.
13:04:23 <glguy> Run glirc with halvm on xen?
13:04:36 <ggVGc> is emacs PID 1 yet
13:04:41 <hpc> i just tell grub to boot right into irssi
13:04:49 <ggVGc> ahhh
13:04:58 * ggVGc writes a :terminal patch for irssi
13:05:04 <ggVGc> so I can run my vim in my emacs in my irssi
13:05:12 <ggVGc> and my haskell repl in my vim
13:07:59 <iqubic> I have now disabled the keybinding that tell ERC to freak out.
13:12:46 <iqubic> Well, I no idea how to tackle this spiral
13:13:55 <MarcelineVQ> iqubic: try taking it one step at a time quite literally, start in the middle, take a step, and change direction, take a step and if it's the right number of steps change direction again. then the trick is just to figure what the right numbe of steps is each time
13:14:46 <iqubic> MarcelineVQ: the right number of steps is to go until (abs x == abs y)
13:15:16 <iqubic> Because that just works.
13:17:29 <EvanR> ggVGc: the ultimate main loop ever! http://lpaste.net/360846
13:17:49 <EvanR> its so self contained it hurts
13:17:58 <EvanR> lots of code without answering very much 
13:20:28 * hackage safe-money 0.4.1 - Type-safe and lossless encoding and manipulation of money, fiat currencies,crypto currencies and precious metals.  https://hackage.haskell.org/package/safe-money-0.4.1 (RenzoCarbonara)
13:21:33 <EvanR> the algorithm is essentially, ζ = ε, α, ε, α, ε, α, ...
13:21:42 <EvanR> side effects for the win
13:22:05 <EvanR> now if i could just prove it correct
13:24:12 <EvanR> the driver is parameterized over any monad... so you could run the game in a list or cont or whatever hehe
13:24:33 <EvanR> for any game
13:27:53 <mw> hi, has anyone here successfully built stack with cabal on openBSD? I'm running out of memory (on a 16gb machine) in the stack compilation step... :S
13:29:09 <EvanR> this is not normal code, i swear
13:29:14 <MarcelineVQ> that sounds like something is way wrong
13:29:38 <MarcelineVQ> but try -j1 just in case it helps
13:30:15 <MarcelineVQ> though I doubt it'll do anything, 16g is something being wrong
13:30:26 <mw> MarcelineVQ: thanks, I'm trying that now
13:30:33 <EvanR> oops
13:33:46 <mw> didn't work unfortunately
13:34:37 <mw> yeah, I'm gonna guess somethings really wrong here, haha, I'll do some more digging :)
13:43:19 * hackage phoityne-vscode 0.0.19.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.19.0 (phoityne_hs)
14:19:23 <fiatjaf> is there a language purer than haskell?
14:20:15 <rightfold> fiatjaf: in Agda all functions return a value for every possible input, which may be regarded as closer to mathematical functions, and hence “more pure”
14:21:17 <Tuplanolla> In Coq there are no side effects and all computations terminate, fiatjaf.
14:22:00 <EvanR> brings into question what pure means, again
14:22:09 <fiatjaf> no side-effects at all?
14:22:24 <fiatjaf> how can you even see the result of the computations, then?
14:22:29 <rightfold> Just like in Haskell there are no side effects at all in Coq and Agda
14:22:37 <fiatjaf> my question is stupid, I know, I just wanted to know the alternatives
14:22:41 <EvanR> how do you see the results of 2 + 2... when you do it on paper or in your head
14:22:56 <EvanR> you just do
14:23:29 <rightfold> The only difference evaluation wise is that in Agda and Coq you never get exceptions or infinite loops
14:23:56 <EvanR> simplifying an expression is something were not considering a side effect
14:24:08 <fiatjaf> from what I could read in the last 30 seconds I can't write useful programs in coq or agda, just prove theorems, right?
14:24:50 <rightfold> You can write many useful programs in them, but the tools for doing that aren’t great
14:25:03 <hpc> it's technically possible, but when i tried to use IO in agda it was awful
14:25:14 <hpc> idris is closer to a programming language
14:25:15 <TMA> fiatjaf: the same is true of haskell in a sense
14:27:01 <TMA> fiatjaf: a program is a mathematical formula that has an interpretation that looks like a running a program. :)
14:27:36 <fiatjaf> TMA: but haskell has lots of runtime errors!
14:28:15 <Cale> fiatjaf: There's a C compiler written in Coq. It's possible to write meaningful programs, but it does take a bit more heroic effort than in something like Haskell.
14:28:34 <Cale> (see CompCert)
14:28:48 <rightfold> Good Haskell functions and I/O actions signal runtime errors by returning them instead of throwing them
14:28:49 <TMA> fiatjaf: it indeed looks like a running program then :)
14:28:54 <Cale> It's pretty insane -- pretty much a full end-to-end C compiler with proofs of correctness all the way
14:29:07 <rightfold> head and tail are examples of very bad “functions”
14:29:34 <Cale> (i.e. it has a semantics for the C code and a semantics for the assembly instructions it produces and there's a proof that the result of compilation has the same meaning as the input)
14:34:25 <Logio> Cale: I would argue that that is, in fact, sane.
14:39:52 <Cale> Logio: haha, it's a huge amount of effort though
14:41:14 <bgamari> edwardk, are your unpacked containers experiments public by any chance?
14:41:46 <bgamari> this is a backpack application that I am quite intrigued by
14:43:12 <Logio> Cale: that's the case with most solid engineering though, programmers have just been lazy so far
14:54:20 <fiatjaf> these mathematicians are crazy. I respect their love for proofs, but I don't want that.
14:54:45 <EvanR> you can't handle the proof!
14:55:37 <fiatjaf> ok, I don't know anything about this, and of course a proof can be valuable, but how can a proof have so much value in the context of a program if you have to interpret the proof?
14:55:40 <fiatjaf> ahahah
14:56:31 <fiatjaf> I mean, if you can interpret the proof you may as well be able to interpret the entire program in your head and be sure it will output the correct stuff. reading a proof of that is just doing the computation backwards in some sense.
14:56:39 <fiatjaf> ok, idris seems very nice and sane.
14:56:45 <EvanR> one redeeming feature of computer check proofs is that the computer can check them
14:56:54 <EvanR> computer checked proofs*
15:02:59 <AndreasK> Can cabal user config options be set via command line?
15:03:32 <Cale> fiatjaf: proofs and programs are fundamentally the same thing, if you set things up the right way :)
15:04:36 <Cale> fiatjaf: Just as in logic, if you know that A implies B, and you know A, then you can obtain B, in lambda calculus, if you have a term f of type A -> B, and you have a term x of type A, then you obtain the function application f x of type B.
15:05:16 <geekosaur> AndreasK, most of them but not all. in general you just stick a '--' in front.
15:06:46 <Cale> In logic, if you want to prove A implies B, you start by assuming A, and try to somehow find a proof of B, and if successful, then natural deduction (as a rule or theorem) tells you that A implies B follows. In lambda calculus, if you want to construct a term of type A -> B, then you introduce a variable x of type A, and construct a term t of type B potentially using x, and then the lambda abstraction (λx. t) will have type A -> B
15:06:57 <AndreasK> geekosaur: I meant as in update the user config without editing the file (Similar to cabal configure)
15:07:07 <geekosaur> not so far as I know
15:08:17 <geekosaur> technically possible but someone would still have to write it (and figure out how to deal with several years' worth of customized configs. and project/sandbox configs. etc.)
15:08:39 <fiatjaf> Cale: is that the standard explanation/analogy people use to introduce lambda calculus? because that was very clear to me.
15:09:36 <fiatjaf> so basically you write a function in haskell (not any function, I imagine, as haskell has so many holes in it) and that's a proof in lambda calculus and so on?
15:09:53 <AndreasK> Just having cabal user-config set --x=y should be doable in my mind. But I probably miss something
15:12:58 <geekosaur> the first thing you miss is what to do when the option is already in there wit a user comment before it :)
15:13:19 <geekosaur> I also don't know offhand if the user config can use conditionals
15:13:32 <geekosaur> (so you can e.g. share it, or parts of it, between unix and windows)
15:15:23 <monochrom> That is just half of lambda calculus.
15:15:23 <AndreasK> As far as I can tell it's about as smart as a .ini file 
15:17:06 <jle`> wow refactoring Day 16 as a monoid and using stimes makes it blazingly fast
15:17:10 <jle`> log time
15:17:20 <glguy> jle`: Does yours look like mine now?
15:17:41 <jle`> it is probably similar
15:17:58 <jle`> i didn't realize that 'stimes' was log time by default
15:18:22 <AndreasK> geekosaur: With user comment do you mean a comment + a setting, or a setting thats commented out?
15:20:01 <jle`> glguy: you added fancy comments, nice
15:21:03 <jle`> glguy: i used a Map instead of a Vector
15:21:07 <geekosaur> the former, although handling the latter at least tot he extent of either putting the setting after it or relocating the comment would also be nice
15:21:28 <geekosaur> but either complicates the implementation, and you're on the way to a headache :)
15:21:38 <geekosaur> (or second system syndrome)
15:21:54 <glguy> jle`: It probably doesn't even matter given how little computation this actually turns into
15:22:05 <glguy> Mine's running in 0.028s on my hardware
15:22:53 <jle`> 0.091 with the Map on my hardware, so it is probably comparable
15:23:15 <jle`> i just used Map because swap/invert were simple
15:23:41 <glguy> That'll certainly scale better when use use those operations at sizes > 16
15:23:45 <jle`> actually last night i played around with using permutation matrices and doing efficient matrix exponentiation using hmatrix
15:24:14 <jle`> but then i realized that hmatrix doesn't have an efficient matrix exponentiation operation
15:24:17 <askGui> glguy: are you into OpenGL stuff?
15:24:21 <glguy> nope
15:24:34 <jle`> and also defining the permutation matrices was kind of ugly
15:25:30 <askGui> I see
15:25:33 <askGui> Thanks away
15:25:37 <askGui> anyway
15:25:42 <jle`> i wonder actually if tis would be a nice thing to solve in matlab/octave
15:25:57 <glguy> askGui: I'm into Haskell if you wanted to talk about those in general, however )
15:25:58 <glguy> :)
15:26:15 --- mode: glguy set -o glguy
15:26:25 <mniip> I've always wondered what does gl stand for
15:26:37 <jle`> i did not even make that connection
15:26:43 <jle`> "graphics library guy" of course
15:26:51 <glguy> In my name? It used to stand for "gamma lambda"
15:27:06 <glguy> But like KFC, now it doesn't stand for anything
15:27:17 <glguy> no principles
15:27:26 <dualerium> glguy, I'm having a problem with https://imgoat.com/uploads/3f390d88e4/67115.png
15:27:29 <dualerium> can you help?
15:27:33 <jle`> like LG too apparently
15:27:49 <jle`> glguy: was that your fraternity at uni
15:28:06 <glguy> Yeah, that was the particular chapter of the fraternity
15:29:23 <mniip> huh
15:29:29 <glguy> dualerium: Probably not; I don't know any QT beyond the general concepts
15:29:36 <mniip> this appears to be some common concept, can someone explain?
15:29:39 <butterthebuddha> How would you implement memoization in haskell
15:30:01 <jle`> butterthebuddha: there are a few ways, but the typical way is to take advantage of ghc's laziness mechanics
15:30:08 <glguy> butterthebuddha: You could use a boxed array, or an infinite, but lazy map (like in the MemoTrie package)
15:30:32 <jle`> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
15:30:33 <lambdabot>  Defined.
15:30:36 <jle`> > fibs !! 10
15:30:37 <butterthebuddha> I'm trying to implement the fibonacci sequence
15:30:38 <lambdabot>  55
15:30:41 <jle`> > fibs !! 100
15:30:42 <butterthebuddha> Oh sweet
15:30:43 <lambdabot>  354224848179261915075
15:30:48 <jle`> ^ the typical memoizing fib
15:31:03 <butterthebuddha> How does that work?
15:31:09 <jle`> this version is a bit of an atypical example since it involves infinite lists, but you could do the same with finite arrays
15:31:12 <butterthebuddha> @:t zipWith
15:31:12 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
15:31:27 <jle`> zipWith (+) [x,y,z] [a,b,c] = [x+a, y+b, z+c]
15:31:37 <glguy> @wn v rc pl let id do bf
15:31:37 <lambdabot> Sorry, look up one word at a time please.
15:31:43 <glguy> pfft
15:31:56 <jle`> butterthebuddha: basically the sapce of fibs is a list of unevaluated thunks
15:32:09 <silverdust> Hi, so I installed haskell and I can't figure what binaries are available to run (on macos)
15:32:15 <jle`> butterthebuddha: and calculating a new fib involves evaluating one of those thunks, which involves evaluating some of the other thunks in that list
15:32:31 <aberrant> silverdust: how did you install it?
15:32:33 <jle`> butterthebuddha: so the way GHC handles laziness/thunks is that once it's forced, it stays in memory until GC'd
15:32:45 <aberrant> silverdust: I have had good results with "brew install haskell-stack"
15:32:51 <silverdust> `brew cask install haskell-platform`
15:32:55 <jle`> butterthebuddha: so essentially you have a cascade of forcing, except cells in the list that are already evaluated won't be re-computed
15:33:05 <aberrant> ah, ok. Sorry. Don't know about platform.
15:33:12 <ertes> silverdust: you probably have 'ghc', 'ghci' and 'cabal'
15:33:16 <silverdust> aberrant: what binary do you use? `haskell`?
15:33:27 <aberrant> silverdust: I type `stack ghci`
15:33:27 <silverdust> yes I have cabal. I'll try gch
15:33:29 <aberrant> for the repl
15:33:30 <jle`> butterthebuddha: so again this example is a bit "fancy" because of the infinite list, but you can do the same using finite vectors or arrays, as long as the cells are thunkable
15:33:30 <glguy> silverdust: ghci is a good starting point
15:33:51 <silverdust> yes I have that
15:34:06 <jle`> i would show an example here using lambdabot but apparently the 'vector' library modules are marked unsafe
15:34:07 <silverdust> Oh ghci is the repl and ghc is the compiler
15:34:08 <ertes> silverdust: the haskell compiler/interpreter of the platform is GHC, and it's your main tool for development, while 'cabal' is the tool for packaging and dependencies
15:34:13 <butterthebuddha> Yeah, I'm really confused rn :(
15:34:39 <ertes> silverdust: if you're a haskell beginner, 'ghci' is all you need for now
15:34:45 <jle`> @undefine
15:34:45 <lambdabot> Undefined.
15:34:46 <silverdust> Thanks for the enlightenment
15:35:26 <ertes> silverdust: if you write a source file experiment.hs, start 'ghci' in its directory and type: :l experiment.hs
15:35:31 <silverdust> Yes I am. I think it'll do. But out of curiosity, what file extension is used for its source files
15:35:35 <ertes> silverdust: then you have access to everything you have defined in that file
15:35:37 <silverdust> oh answered
15:35:59 <ertes> silverdust: each time you change the file just type :r(eload)
15:36:07 <jle`> @let fibs = fibFunc <$> [0..] where fibFunc 0 = 0; fibFunc 1 = 1; fibFunc i = (fibs !! (i - 1)) + (fibs !! (i - 2))
15:36:08 <lambdabot>  Defined.
15:36:12 <jle`> > fibs !! 5
15:36:13 <lambdabot>  5
15:36:19 <jle`> > fibs !! 10
15:36:21 <lambdabot>  55
15:36:22 <silverdust> Thanks ertes 
15:36:30 <jle`> butterthebuddha: that example is a bit more typical
15:36:42 <ertes> silverdust: have fun…  that's all you need for now…  you'll know when you need more =)
15:36:45 <jle`> butterthebuddha: fibs the list is [fibFunc 0, fibFunc 1, fibFunc 2, fibFunc 3...], etc.
15:36:54 <jle`> butterthebuddha: and the fibFunc function *refers* to fibs items
15:37:47 <jle`> butterthebuddha: so if you try to calculate 'fibFunc 10', that'll try to get the 8th and 9th items in 'fibs'
15:37:56 <jle`> butterthebuddha: which will evaluate fibFunc 8 and fibFunc 9
15:38:35 <jle`> butterthebuddha: and when you try to evaluate 'fibFunc 9', it has to evaluate 'fibs !! 7' and 'fibs !! 8'
15:38:52 <jle`> butterthebuddha: but, if fibs !! 8 was already forced, it can be re-used
15:39:06 <Logio> the main thing to note is that everything is, in a sense, memoized by default
15:39:28 <Logio> you just need to define your functions using the memoized structure
15:39:58 <ertes> everything that has a name is "memoised" (shared) by default
15:40:12 <ertes> let y = x*x in y + y  -- shared
15:40:18 <ertes> x*x + x*x  -- potentially not shared
15:41:50 <butterthebuddha> jle`: that's actually really cever
15:42:07 <jle`> it's a bit easier to see if there wer epictures :)
15:42:10 <butterthebuddha> You could just use map instead of <$> though right?
15:42:22 <jle`> yes, they are the same
15:42:29 <jle`> but the nice thing about the second way i wrote it is that it's very mechanical
15:42:44 <jle`> you can just replace fibFunc with any arbitrary function on elements of fibs
15:42:50 <AndreasK> geekosaur: Since it seems to be limited to a setting per line, just going through it line by line, replacing the setting if found and putting it at the end if not seems like a reasonable approach.
15:43:07 <butterthebuddha> How do you reach the level of expertise in Haskell where you can come up with something like the zipWith solution?
15:43:18 <glguy> practice!
15:43:19 <AndreasK> geekosaur: It doesn't allow mixing settings and comments on the same line either so thats also not an issue
15:43:20 <geekosaur> by playing around with it a lot
15:43:50 <jle`> butterthebuddha: this method as i wrote it works only in Int -> XXX's (things that can be used as indices of lists), but you can be a little more creative to apply this to functions with different input types
15:43:58 <ertes> butterthebuddha: the same way you learn to come up with loop-based solutions in imperative languages: use the language =)
15:44:44 <Logio> butterthebuddha: that kind of a zipWith trick is actually pretty useful in a lot of places, you might learn it in the first course you take
15:44:47 <AndreasK> But then it probably just never was a prioroty for anyone. Maybe if I get too bored/frustrated about it i will take a stab at that
15:44:52 <Logio> though not in relation to memoization though
15:45:28 <jle`> i don't do things like the zipWith on a regular basis
15:46:05 <ertes> kinda ironic that the fix-based solution may be easier to understand =)
15:46:15 <ertes> > fix (\go x y -> x : go y (x + y)) 0 1
15:46:16 <Logio> knowing the zipwith trick actually helped me on a puzzle in TIS-100
15:46:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:46:55 <Logio> I guess in general that's a way to think of things when you are doing signal processing
15:50:03 <infinisil> Whoa, that's a nice fibonacci
15:54:01 * monochrom creates a rumour: Alonzo Church was in a fratenity called "alpha beta eta". :)
15:54:26 <MarcelineVQ> arf arf alpha
15:54:55 <ertes> alonzo "abe" church
15:58:15 <sssilver> guys, is it possible to restrict my function to only arrays of length 2 and more?
15:58:25 <sssilver> or is runtime error my only choice?
15:58:45 <EvanR> ertes: eta is not like e, but more like "ee" .. i
15:58:51 <ReinH> No, and also no.
16:00:24 <EvanR> certainly not like silent e
16:00:52 <EvanR> so... alonzo "abi" church  
16:00:54 <ertes> alonzo "abby" church
16:00:57 <EvanR> yeah
16:04:18 <monochrom> Make it Abbey and it is complete. :)
16:07:40 <jle`> glguy: do you know why you have to compose the renamings in opposite order of the permutings
16:11:22 <jle`> i thought it was a mistake in my implementation until i saw that you did it too
16:11:46 <mniip> renamings compose backwards
16:12:51 <jle`> ah hm
16:12:56 <mniip> sx/y;sz/w acts on the set in the same way as pz/w;px/y
16:13:16 <jle`> ah i see
16:18:19 <jle`> @tell sssilver you can use a type that only contains arrays of length 2 or more, or you can use a refinement system like liquid haskell for static analysis
16:18:19 <lambdabot> Consider it noted.
16:24:14 <jle`> glguy: your Dance type could just be a type synonym
16:24:21 <jle`> since tuples have a monoid instance
16:24:37 <jle`> you just lose strictness but
16:27:06 <iqubic> So I have a Map (Int, Int) Int 
16:27:41 <iqubic> And now I need to find all the keys with a certain value n of my choosing.
16:28:55 <iqubic> Is that even possible?
16:29:30 <jle`> you can use keys :: Map k v -> [k]
16:29:34 <jle`> and then filter the resulting list
16:30:13 <iqubic> I think I might try that.
16:30:32 <iqubic> Also, how does haskell deal with infinite recursion?
16:31:22 <jle`> what do you mean by 'deal with'
16:31:33 <iqubic> I'm not sure.
16:31:56 <iqubic> This spiral is all I've thought about for the last while and it's driving me crazy.
16:31:57 <jle`> @let ones = 1 : ones
16:31:58 <lambdabot>  Defined.
16:32:03 <jle`> > take 10 ones
16:32:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
16:32:48 <lordcirth> Infinite things are very useful in Haskell, due to lazy evaluation.
16:32:59 <iqubic> I can't seem to solve this spiral puzzle from Advent of Code.
16:33:27 <jle`> what issue are you having?
16:34:37 <iqubic> Well, I have a recursive loop that creates the spiral, but I don't know when to stop that loop.
16:34:43 <iqubic> Still on part 1 here.
16:35:16 <iqubic> What I have currently is a way to generate the spiral, and keep generating it and keep generating it.
16:36:16 <iqubic> Also, I'm storing my Spiral as "Type Spiral = M.Map Point Int"
16:36:29 <iqubic> With "Data Point = Int Int deriving ..."
16:36:56 <iqubic> And I don't know how to extract a relevent point from that.
16:37:32 <glguy> jle`: It would have to be: type Dance = (Dual (Permutation n), Permutation n); and then I agree
16:38:32 <jle`> yeah :) https://github.com/mstksg/advent-of-code-2017/blob/master/src/AOC2017/Day16.hs
16:38:42 <jle`> Dual is one of my favorite typeclass-bending newtype wrappers
16:39:01 <mniip> what would be a good way to say
16:39:06 <iqubic> Partner and Exchange do the same thing. Right?
16:39:09 <mniip> 2 ^ b > n
16:39:24 <mniip> to account for enormous b and small n
16:39:27 <lordcirth> iqubic, well, when *should* the loop end?
16:39:41 <lordcirth> Or do you only need, say, the first X results?
16:39:45 <jle`> iqubic: Exchange swaps fixed indices, and Partner swaps letters, whose positions may vary
16:39:51 <lordcirth> Or until a result satifies X?
16:40:19 <iqubic> lordcirth: The loop should end when I find the number I'm looking for.
16:41:06 <lordcirth> iqubic, so, can you construct a predicate function :: Thing -> Bool that tells you whether it's the one you're looking for?
16:42:31 <iqubic> lordcirth: I'm doing that.
16:43:32 <glguy> jle`: nice and compact
16:44:00 <jle`> i realized that my idea to use Map to save space doesn't really pan out as soon as a single Spin is introduced
16:44:37 <glguy> jle`: One thing you could do (not sure if it would ever help) is remove entries from the map when they point to themselves eventually
16:45:32 <jle`> yeah, just tried that out.  M.filterWithKey (/=), has a nice ring to it :)
16:46:01 <jle`> but it doesn't help, and i wondered why, and saw that my challenge input had no entries that pointed to themselves
16:46:58 * hackage data-diverse 2.0.0.0 - Extensible records and polymorphic variants.  https://hackage.haskell.org/package/data-diverse-2.0.0.0 (louispan)
16:47:12 <jle`> but i really want to write a matlab version now
16:47:26 <iqubic> Alright well, I now need to figure out of to get the last thing added to the map of my spiral.
16:48:27 <jle`> oh man just realized that i'm watching star wars today for a second time, during AoC release time again
16:48:58 <jle`> i guess since it's a rewatch  i could just walk out to do to do it and come back in
16:49:13 <glguy> or program from your seat
16:49:35 <iqubic> I need a way to get the last thing inserted into a Map.
16:49:36 <jle`> considered it, but i have a feeling the other people in the theatre might nto be happy :)
16:49:58 <glguy> AoC is open to the public, le tthem bring their own laptops
16:50:18 <jle`> another downside is that if i stream, i might accidentally spoil the movie for people watching
16:50:28 <jle`> since you can probably hear the dialog
16:50:29 <Psybur> Where can I find a parallel foldMap?
16:52:14 <jle`> dialogue?
16:54:08 <iqubic> Anyone have a way to get the last thing added to a Data.Map Map?
16:54:46 <Rembane> iqubic: Give it a name. 
16:54:52 <Rembane> iqubic: And then add it to the map.
16:55:06 <iqubic> Rembane: I don't think that will work.
16:55:13 <Rembane> iqubic: let lastThing = ... in M.insert ... lastThing
16:55:20 <Rembane> iqubic: Why not?
16:55:27 <rightfold> iqubic: Map doesn’t remember insertion order
16:55:45 <Psybur> I suppose I could test this one out, but it seems like it might not be optimal. Calling length and all that https://mail.haskell.org/pipermail/haskell-cafe/2011-April/090671.html
16:56:19 <glguy> Trying to imagine what else I might need later:
16:56:20 <glguy> *Advent Advent.Permutation> cycles (mconcat [swap 0 1, swap 2 3, swap 3 5 :: Permutation 6])
16:56:21 <glguy> [[0,1],[2,3,5],[4]]
16:57:22 <iqubic> rightfold: that's a pain.
16:59:16 <mniip> glguy, ooh is that using Data.Finite :o
16:59:20 <iqubic> Well, what I have is a "Map Position Int" where "Data Position = Position Int Int"
16:59:34 <glguy> *Main> let Dance r p = d in (Advent.Permutation.cycles r, Advent.Permutation.cycles p)
16:59:35 <glguy> ([[0,7],[1,12,6],[2,15,14,5,10,9],[3,8,13,4],[11]],[[0,14],[1,8,4,13,9],[2,11,7,12,10],[3,15,6],[5]])
16:59:47 <glguy> Those are my inputs renaming and permutation cycles
17:01:05 <jle`> Psybur: honestly if the thing you are mapping has any non-trivial cost at all, computing the length is going to be the least of your worries :)
17:01:56 <glguy> mniip: No, it's just GHC.TypeLits. I'll have to check out that module
17:02:01 <mniip> ok
17:02:19 <iqubic> So if I have my Map like above: How do I get the position of the last spot? As in, get all the keys who values are 347991?
17:02:35 <Psybur> So Im reading large files and creating a sliding window, and then running kmeans in each window
17:03:09 <Psybur> So the problem with calculating the length is I have to have everything loaded into memory right
17:08:51 <iqubic> Can anyone help me with my conundrum?
17:11:35 <glguy> mniip: Having a data Perm n = P (Vector (Finite n)) would be safer, but would be slower as I'd have to give up on unboxed vectors
17:11:47 <glguy> (not necessarily much slower, but that's the trade-off)
17:15:44 <iqubic> well, I am so close to solving part 1.
17:16:18 <iqubic> I just need to extract the right value from my spiral. I have no clue how do that.
17:31:25 <Average-user> iqubic: What are you doing?
17:35:11 <iqubic> Advent of Code day 3 part 1
17:36:44 <Psybur> iqubic, im stuck on pt 2 of that day heh
17:36:47 <glguy> Average-user: did you figure out your #16 problem?
17:37:00 <Psybur> Well not necessarily stuck, i just havent looked at it in a bit, doing other things
17:41:34 <iqubic> Well, I am trying to get my solution to part 1 to compile at this moment in time.
17:42:28 <Average-user> glguy: Yes, was something like off-by-one, but I couldn't run your repository, stack init failed, but I ended up figuring out the problem anyway
17:42:41 <glguy> ah, yeah you don't need stack at all
17:42:53 <iqubic> Can I give type signatures to functions defined in where clauses?
17:42:59 <iqubic> How would that work?
17:43:09 <Average-user> iqubic: why so behind? 
17:43:19 <Average-user> iqubic: did you forgot about it?
17:43:19 <iqubic> I got started late.
17:43:20 <bigos_> Hi, where is the right place to discuss gi-gtk, windows and learning to use Haskell and Gtk?
17:43:27 <Average-user> forget*
17:43:33 <Average-user> glguy: how is that?
17:43:33 <iqubic> Yeah, I just forgot.
17:44:40 <iqubic> I think my last compilation error is arising because Haskell is picking the wrong type for a function defined in where clause.
17:44:59 <Average-user> iqubic: so write the signature
17:45:08 <iqubic> Where do I put that?
17:45:17 <Average-user> iqubic: like any other function
17:45:27 <glguy> Average-user: It's just: cabal new-build
17:45:28 <Average-user> iqubic: inside the clause
17:45:43 <Average-user> glguy: Why do u don't use stack?
17:45:54 <glguy> Average-user: stack init --resolver=nightly will work if that's all you have, too
17:46:21 <iqubic> And I get the same error as before.
17:46:43 <Average-user> iqubic: Post the message
17:47:49 <iqubic> See my issue is that M.lookup, from Data.Map is not the same as lookup from prelude
17:48:14 <Average-user> iqubic: How is that an issue?
17:48:54 <iqubic> Because they have different uses and type signatures.
17:49:37 <Average-user> iqubic: I mean: If you want to use one, just use the correspondent type signature.
17:51:09 <iqubic> I have fixed my issues.
17:52:19 <Average-user> iqubic: thats good to "hear"
17:54:40 <Average-user> glguy: can I try your IRC client?
17:54:49 <glguy> Are you on mac or linux?
17:54:57 <iqubic> Well, I created an infinite loop.
17:54:59 <Average-user> glguy: linux debian
17:55:06 <glguy> Then yes :)
17:55:28 <Average-user> glguy: nice, what distro are u currently in?
17:55:38 <glguy_> Mac
17:56:03 <Average-user> glguy: How do u use your own IRC client if you are in mac?
17:56:50 <glguy_> It works on Mac and Linux
17:57:21 <Average-user> glguy: so your question was indirectly asking if I'm in windows?
17:57:42 <iqubic> Well, I have a thing that just fails on all accounts.
17:58:29 <iqubic> I don't think I can do Day 3 simply.
17:59:44 <iqubic> @pl \x -> x == input
17:59:44 <lambdabot> (input ==)
18:00:12 <iqubic> @pl \x -> input == x
18:00:13 <lambdabot> (input ==)
18:00:41 <iqubic> Can't I also do ((==) input) ?
18:01:09 <iqubic> :t (\x -> (==) x)
18:01:10 <lambdabot> Eq a => a -> a -> Bool
18:01:18 <iqubic> :t (\x -> x ==)
18:01:19 <lambdabot> error: parse error on input ‘)’
18:02:50 <Average-user> :t (\x -> (==X))
18:02:51 <lambdabot> error: Data constructor not in scope: X
18:02:54 <verement> :t \x -> (x ==)
18:02:55 <lambdabot> Eq a => a -> a -> Bool
18:03:05 <Average-user> :t (==)
18:03:07 <lambdabot> Eq a => a -> a -> Bool
18:04:03 <iqubic> I give up on day 3 for now.
18:04:14 <iqubic> I can't find a clean way to do it.
18:04:33 <iqubic> And what I had was not working.
18:05:09 <iqubic> I'll come back to that tomorrow.
18:09:01 <glguy> Average-user: There are slightly older that latest versions available for some versions of debian; https://packages.debian.org/search?keywords=glirc
18:10:07 <glguy> and others are up to date, depending on what version you get you can check for what you're missing with http://hackage.haskell.org/package/glirc-2.24/changelog
18:12:12 <glguy> see also: https://github.com/glguy/irc-core/wiki
18:14:57 <bblum> hello, i'm wondering if there's a more concise way to find the length of the cycle in a repeating infinite list than the following? period l = 1 + (length $ takeWhile (/= head l) $ tail l)
18:16:15 <glguy> for advent of code?
18:16:31 <bblum> glguy: correct :) just golfing my solutions for fun
18:20:28 <ertes> bblum: https://en.wikipedia.org/wiki/Cycle_detection#Algorithms
18:22:24 <bblum> not sure how tortoise hare could be written more concisely; it's actually ok in this case to assume the head is part of the cycle though
18:25:52 <ertes> @let import qualified Data.Stream.Infinite as Str
18:25:52 <lambdabot>  .L.hs:123:1: error:
18:25:52 <lambdabot>      Could not find module ‘Data.Stream.Infinite’
18:25:52 <lambdabot>      Use -v to see a list of the files searched for.
18:25:57 <ertes> @let import qualified Data.Stream as Str
18:25:58 <lambdabot>  Defined.
18:26:30 <ertes> :t \(Cons x xs) -> length (Str.takeWhile (/= x) xs) + 1
18:26:31 <lambdabot> error:
18:26:31 <lambdabot>     Not in scope: data constructor ‘Cons’
18:26:31 <lambdabot>     Perhaps you meant one of these:
18:26:36 <ertes> :t \(Str.Cons x xs) -> length (Str.takeWhile (/= x) xs) + 1
18:26:37 <lambdabot> Eq a => Str.Stream a -> Int
18:32:08 <bblum> hrm, i'll give partial credit for the pattern match but the +1 approach still feels really clumsy
18:32:11 <bblum> ty though :)
18:33:05 <ertes> bblum: the main message that i wanted to get across is: this function shouldn't take a list
18:33:25 <bblum> ah, why not?
18:33:58 <ertes> > head []
18:34:00 <lambdabot>  *Exception: Prelude.head: empty list
18:34:02 <ertes> bblum: that's why
18:35:06 <ertes> bblum: here is a longer version: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
18:38:02 <mniip> :t fix $ \f -> succ . liftA3 bool (pure 0) f (uncurry $ on (==) head) . (drop 1 *** drop 2)
18:38:03 <lambdabot> (Eq a, Num c, Enum c) => ([a], [a]) -> c
18:38:25 <mniip> :t join $ fix $ \f -> succ . liftA3 bool (pure 0) f (uncurry $ on (==) head) . (drop 1 *** drop 2)
18:38:26 <lambdabot> (Eq a1, Num (([a1], [a1]) -> a2), Enum (([a1], [a1]) -> a2)) => ([a1], [a1]) -> a2
18:38:28 <mniip> oops
18:38:34 <mniip> :t join $ curry $ fix $ \f -> succ . liftA3 bool (pure 0) f (uncurry $ on (==) head) . (drop 1 *** drop 2)
18:38:35 <lambdabot> (Eq a2, Num a1, Enum a1) => [a2] -> a1
18:39:36 <mniip> that bool needs a flip
18:39:45 <mniip> :t join $ curry $ fix $ \f -> succ . liftA3 bool f (pure 0) (uncurry $ on (==) head) . (drop 1 *** drop 2)
18:39:46 <lambdabot> (Eq a2, Num a1, Enum a1) => [a2] -> a1
18:39:52 <mniip> :t (join $ curry $ fix $ \f -> succ . liftA3 bool f (pure 0) (uncurry $ on (==) head) . (drop 1 *** drop 2)) $ cycle [1,2,3]
18:39:53 <lambdabot> (Num t, Enum t) => t
18:39:58 <mniip> > (join $ curry $ fix $ \f -> succ . liftA3 bool f (pure 0) (uncurry $ on (==) head) . (drop 1 *** drop 2)) $ cycle [1,2,3]
18:40:00 <lambdabot>  3
18:45:47 <ertes> :t \xs -> foldr (\x go n f -> f (go 1 (const ($ x))) (bool (go (succ n) f) n . (x ==))) undefined xs 0 const
18:45:49 <lambdabot> (Eq a, Enum b, Num b, Foldable t) => t a -> b
18:46:05 <ertes> > (\xs -> foldr (\x go n f -> f (go 1 (const ($ x))) (bool (go (succ n) f) n . (x ==))) undefined xs 0 const) (cycle [1..3])
18:46:07 <lambdabot>  3
19:13:24 * hackage data-diverse-lens 1.0.0.0 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  https://hackage.haskell.org/package/data-diverse-lens-1.0.0.0 (louispan)
19:15:20 <sirf0x> Hi there! How are you people? :)
19:15:42 <sirf0x> I was wondering, i'm working on a small project to practice haskell more
19:15:53 <sirf0x> and I'd like to add some unit tests
19:16:25 <sirf0x> problem : I don't expose all my functions and I'm not satisfied by the .Internal solution or exposing everything
19:16:35 <sirf0x> do you guys know any other way to proceed?
19:16:49 <glguy> The .Internal solution is the best way to go
19:17:15 <sirf0x> is that what you do even if it's not a library?
19:17:39 <glguy> Typically you put basically all of your code into the library
19:17:54 <glguy> the executable is just a small module to launch the logic out of the library
19:18:29 <sirf0x> ok, so you put everything in the lib folder and expose everything? would make sense
19:19:02 <glguy> Your other choice is to include the executable's source directory in your test-suite section and then recompile all those modules again as part of your test suite
19:20:01 <ertes> sirf0x: many haskell "programs" are really libraries, and "configuring" them really means importing the library and writing an actual program
19:20:46 <ertes> sirf0x: examples include hakyll, shake, taffybar and xmonad
19:21:52 <glguy> glirc*
19:22:03 <ertes> sirf0x: cabal works best, if each stanza (benchmark/executable/library/test-suite) in your cabal file has its own source root directory
19:22:28 <sirf0x> Ok, i'm going to check these projects
19:22:35 <sirf0x> I guess it's the same for stack?
19:22:46 <glguy> stack's just an extra layer on top of cabal, so yes
19:22:53 <sirf0x> I didn't know that
19:23:02 <sirf0x> thank you for all these infos I'm going to dig in :)
19:23:12 <ertes> sirf0x: i mean cabal, the library, not cabal-install, the command line interface
19:24:51 <sirf0x> with what you told me about haskell programs being libraries, does that mean stack cabal's library to build on top of it?
19:25:05 <sirf0x> use cabal's*
19:26:05 <ertes> you could consider cabal to be like that, too…  haskell packages usually come with a Setup.hs that imports cabal to configure/install the package
19:26:26 <sirf0x> ok ok
19:26:46 <ertes> while most people use some higher-level tool (cabal-install, nix, stack) you could very well just work with those programs
19:27:26 <geekosaur> that's what we used to do before cabal-install
19:27:43 <geekosaur> not so different from (and I think even copied from) python's setup.py stuff
19:27:44 <ertes> sometimes those higher-level tools will even have to invoke those package-specific setup programs, but that's an advanced topic
19:31:05 <ertes> sirf0x: BTW, the five programs mentioned have a lot of potential to replace something you're currently using =)
19:50:51 * hackage parameterized 0.5.0.0 - Parameterized/indexed monoids and monads using only a single parameter type variable.  https://hackage.haskell.org/package/parameterized-0.5.0.0 (louispan)
20:08:32 <guest5081> I tried to learn the lens library today
20:08:39 <glguy> Did it work?
20:09:00 <guest5081> I made some partial progress, but it feels like it was a bigger project than I anticipated
20:09:09 <mniip> glguy, optimize
20:09:16 <mniip> guest5081, at what point did you fail?
20:11:28 <guest5081> the type signatures
20:12:11 <byorgey> guest5081: learning the lens library is a big project indeed.  Fortunately you don't have to learn all of it to be able to use it.
20:12:39 <byorgey> guest5081: how did you try to learn?  I recommend reading some of the many good videos or blog posts about it rather than literally reading the documentation.
20:12:56 <byorgey> er, watching/reading
20:18:26 <Average-`> Average-user: ready for todays AoC?
20:19:55 <m1n> would it be easy to make an irc bot in haskell if, say, the creator of said bot has yet to work with haskell?
20:24:35 <glguy> m1n: That's a reasonable early project goal
20:25:07 <glguy> it's something that can start out very simple and eventually grow to something more complex
20:25:17 * m1n looks around for signs of the illuminati. but … you … join … um.
20:25:36 <glguy> It's true, I'm always watching
20:26:04 <m1n> d'you want to wish me gl, guy? or what? True I guess the base is really simple … connect and respond to pings
20:27:02 <m1n> and respond to !make me a sandwich  (obviously the only response is "error: you cannot perform this action unless you are root"
20:27:06 <fr33domlover> m1n, you writing an irc bot? :)
20:27:26 <mniip> idunno
20:27:40 <mniip> I wouldn't jump straight into an IO-loaded program as the first haskell project
20:28:15 <glguy> m1n: I'm talking to you from my IRC Haskell project :-) so I'm predisposed to liking that idea: https://glguy.net/irc.png
20:28:21 <m1n> well, I have written some ok python irc bots with modules that you can create yourself. Unfortunately, I never really finished, and only completed like 87% of everything I wished to do. But it parsed the useful information when you first connect and handled a lot of crazy stuff .. most of which I have actually forgotten
20:28:41 <mniip> glguy, is that website served over GPRS
20:28:46 <m1n> just want to try haskell. no ideas on what to do
20:29:11 <glguy> mniip: ground penetrating radar system? No
20:29:31 <m1n> no, gerbel rescue promotion squad
20:30:00 <fr33domlover> m1n, my first haskell program just did simple text i/o, like, took a number on the terminal and was able to print it back to the terminal when asked, really plain useless program
20:30:02 <mniip> Glasgow Peer Review System
20:30:12 <fr33domlover> (and I did have priot coding knowledge)
20:30:28 <fr33domlover> so I'd say, start with super simple stuff
20:30:35 <fr33domlover> and build your way up gradually
20:30:50 <fr33domlover> especially because Haskell has so many tools and abstractions and concepts
20:30:54 <glguy> mniip: I don't know what you're asking. What's GPRS?
20:31:13 <mniip> General Packet Radio Service
20:31:23 <mniip> Youth these days....
20:31:33 <m1n> mniip: I'm 78 years old thank you very much, fam
20:31:36 <Average-user> mniip: Glasgow Peer Review System what a coincidence
20:31:54 <Average-user> mniip: you said that before, same initials
20:31:59 <mniip> what
20:32:15 <m1n> I'm 78 years old than you very much, fam
20:32:27 <ReinH> glguy: what font is that?
20:32:43 <glguy> Cartograph Mono CF Regular
20:32:50 <ReinH> It's nice.
20:33:45 <glguy> The designer is pretty responsive, too. He updated it with a version that was better for coding for me! Now the symbols like *->< etc line up on a common midline
20:33:45 <mniip> Average-user, to my best knowledge I've never said that before so this meme is in fact original content
20:34:15 <mniip> not sure how I feel about * being all the way down at the - level
20:34:50 <glguy> It's nice for * used to dereference in C-family or many of the silly operators that come up with other people's Haskell code :)
20:35:27 <mniip> what
20:35:29 <mniip> no
20:36:02 <mniip> the * needs to stick out upwards
20:36:08 <glguy> or having the <*> line up nicely, also better
20:36:38 <glguy> <$> <*> int *x = *p
20:36:58 <mniip> http://tcpst.net/9xp2.png
20:37:04 <mniip> I don't want it any other way
20:37:15 <Average-user> mniip: (01:29:40 AM) mniip: Glasgow Peer Review System
20:37:18 <glguy> gross, we shouldn't use the same fonts :)
20:37:34 <glguy> https://glguy.net/star.png
20:38:06 <mniip> Average-user, uh yes
20:38:09 <mniip> that was today
20:38:31 <monochrom> Oh haha GPRS I remember that cell phone technology from last century.
20:38:36 <mniip> finally!
20:39:43 <monochrom> I saw a new model of flip phones just two days ago at a phone shop. Apparently they can finally do LTE now, so you would be no longer stuck with GPRS.
20:52:25 <dmwit> int *char = ++star / /* a * */ search;
20:59:01 <nshepperd_> I think <*> looks fine with the star sticking out
20:59:18 <Average-user> mniip: But, did you realize that where the same initials of what glguy was asking?
20:59:21 <nshepperd_> - not lining up with <
20:59:32 <nshepperd_> Is a bit weird though
20:59:35 <mniip> I um
20:59:36 <mniip> that was
20:59:37 <mniip> the joke
21:00:09 * EvanR laugh track
21:01:09 <Average-user> mniip: It was a joke? really ...
21:07:40 <mniip> oh no
21:07:43 <mniip> 50 million
21:12:40 <glguy> mniip: less chat more program!!
21:13:18 <Gurkenglas> Isn't every traversal zippy? "partsOf t %~ zipWith f xs"
21:15:25 <Gurkenglas> Oh, http://oleg.fi/gists/posts/2017-04-18-glassery.html#v:zipWithOf already notes this.
21:16:50 <iqubic> I got a working solution to Day 4 Part 1.
21:17:07 <cq1> I've got a list zs. What's a good idiom to form the list of splits (xs, ys) such that xs ++ ys == zs?
21:17:53 <glguy> cq1: You could zip the inits and tails
21:18:01 <mniip> liftA2 zip inits tails
21:18:16 <iqubic> Part 2 is being a pain. I have a thing that I think should work, only it doesn't work.
21:18:29 <cq1> glguy: That's perfect, thanks.
21:19:56 <cq1> glguy: Wait, actually, I assumed there was some [a] -> [[a]] called "inits" and "tails" that gave all prefixes (resp. suffixes). Can you spell out what you're saying in more detail?
21:20:08 <glguy> That's the case. They are in Data.List
21:20:16 <geekosaur> there is but you probably need to import them
21:20:51 <cq1> glguy: geekosaur: Okay, got it, thanks, it's working now.
21:21:17 <iqubic> Yeah, tails is like, [drop 1, drop 2, drop 3]
21:21:32 <iqubic> inits is like [take 1, take 2, take 3]
21:22:02 <Gurkenglas> (both start with 0)
21:22:06 <iqubic> I know.
21:22:32 <iqubic> Wait, that will give you the entire list as the head of the list.
21:22:47 <iqubic> head x = take 1 $ inits x
21:22:57 <iqubic> head x = take 1 $ tails x
21:23:17 <Gurkenglas> take 1 $ inits x is [[]].
21:25:05 <mniip> dammit
21:25:15 <mniip> I am an idiot
21:25:20 <Gurkenglas> take 1 $ tails x is [x]
21:29:59 <Welkin> @remember mniip <mniip> I am an idiot
21:30:00 <lambdabot> Done.
21:30:06 <Welkin> @quote mniip
21:30:06 <lambdabot> mniip says: I wonder what does this button do
21:30:11 <Welkin> @quote mniip
21:30:11 <lambdabot> mniip says: I wonder what does this button do
21:30:14 <Welkin> @quote mniip 1
21:30:14 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
21:30:16 <Welkin> o.o
21:31:17 <EvanR> what am i missing here... diff :: a -> a -> D a, add :: a -> D a -> a, D a is a group, laws... add x 0 = x, add (x + y) = add x . add y
21:31:43 <EvanR> is this relationship called something
21:31:53 <Welkin> EvanR: marriage
21:32:33 <EvanR> i got the order of args to add wrong
21:34:06 <cq1> I have a f :: a -> [t] and g :: b -> [t], and I want the most idiomatic possible "double bind" that takes [(a, b)] -> [t] by giving the cartesian product of (f x) and (g x) for each element x in the input list. What's a good idiom?
21:34:13 <iqubic> Anyone want to help me with Day 4 part 2 of Advent of Code?
21:34:26 <iqubic> https://github.com/IQubic/AoC2017/tree/master/day4
21:34:41 <iqubic> I got part 1 correct.
21:34:51 <Average-user> doing 17 now
21:35:15 <iqubic> My code gives me 7 for part 2, which isn't correct according to the AoC website.
21:35:29 <iqubic> Can I get some help with what I'm doing wrong?
21:35:48 <mniip> cq1, that makes no sense
21:35:56 <cq1> Whoops, I meant that what I want has type [(a, b)] -> [(t, t)] (sorry)
21:36:46 <mniip> :t liftA2 (liftA2 (,)) (?f . fst) (?g . snd)
21:36:48 <lambdabot> (?g::b2 -> f b3, ?f::b1 -> f a, Applicative f) => (b1, b2) -> f (a, b3)
21:37:09 <mniip> :t (>>= liftA2 (liftA2 (,)) (?f . fst) (?g . snd))
21:37:10 <lambdabot> (?g::b2 -> m b3, ?f::b1 -> m a, Monad m) => m (b1, b2) -> m (a, b3)
21:37:42 <mniip> really just use a list comp
21:38:24 <mniip> :t \ps -> [(a, b) | (x, y) <- ps, a <- ?f x, b <- ?g y]
21:38:25 <lambdabot> (?g::t2 -> [b], ?f::t1 -> [a]) => [(t1, t2)] -> [(a, b)]
21:38:29 <mniip> much more readable
21:38:34 <iqubic> I really don't get why my code fails on part 2
21:38:45 <iqubic> Can I get some help with that?
21:39:44 <iqubic> The part 2 list comprhension should be converting each password to a list of words that is all the permutations of all the words in that password.
21:39:58 <cq1> mniip: Okay, thanks for the sampling of idioms. The list comp seems good.
21:40:07 <iqubic> And then it should be checking if that is list with no duplicates.
21:40:27 <Gurkenglas> iqubic, concatMap also concatenates all the permutations of that password into one huge password
21:40:36 <iqubic> Gurkenglas: I know that.
21:40:43 <iqubic> That's kinda what I want.
21:41:08 <iqubic> After I get that I check if it is a valid password according to the rules of part 1
21:42:16 <iqubic> It takes ["ab", "ba"] and turns it into ["ab", "ba", "ba", "ab"] or something roughly equivalent, and then checks if that contains any duplicates.
21:42:41 <iqubic> Can you run day4 with my input, and see if you get the same answer as me?
21:42:52 <iqubic> Just see if you get 7.
21:43:10 <iqubic> Because I think I did this correctly. I can't see where I would have failed.
21:43:55 <glguy> iqubic: If AoC says you're wrong, then you're wrong and your program is either wrong or you misunderstood the problem itself
21:44:26 <iqubic> Clearly 7 is not the right answer for my code.
21:44:56 <iqubic> For day 4 part 2 "ab ba cd" is invalid, right?
21:45:30 * hackage turtle 1.5.0 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.0 (GabrielGonzalez)
21:47:06 <Profpatsch> How to picture a dependency tree for my ghc-pkg deps?
21:47:38 <Profpatsch> Oh, wait, I can pipe to do.
21:47:42 <Profpatsch> *dot
21:48:04 <Profpatsch> Should look at --help before I ask.
21:49:01 <iqubic> Well I found a flaw in my code.
21:49:58 <iqubic> for some reason my part2 thinks that "iiii iiio iioo iooo oooo" is invalid
21:50:46 <EvanR> should have proved your code correct
21:51:13 <iqubic> No.
21:51:23 <iqubic> That password is correct.
21:51:39 <iqubic> No word is an anagram of another word.
21:51:53 <iqubic> my issue is this:
21:51:59 <iqubic> > permutations "iiii"
21:52:01 <lambdabot>  ["iiii","iiii","iiii","iiii","iiii","iiii","iiii","iiii","iiii","iiii","iiii...
21:52:07 <iqubic> That's not what I want.
21:52:20 <iqubic> I want a function that returns the unique permutations.
21:52:33 <iqubic> > (nub permuations) "iiii"
21:52:35 <lambdabot>  error:
21:52:35 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
21:52:35 <lambdabot>                    with actual type ‘[()]’
21:52:49 <iqubic> > nub $ permutations "iiii"
21:52:51 <lambdabot>  ["iiii"]
21:52:55 <iqubic> that'll work
21:53:16 <c_wraith> you might get much better performance from a different algorithm, if performance matters
21:53:34 <c_wraith> (ie, if you have more than 10 or so elements)
21:53:48 <iqubic> I know.
21:54:00 <iqubic> But this is Advent of Code. It's fine to be slow.
21:54:14 <iqubic> Except this is being really really slow.
21:54:25 <c_wraith> It is factorial
21:54:31 <EvanR> because permutations is n! and nub is n^2
21:54:48 <EvanR> (n!)^2
21:55:00 <c_wraith> if you can prune branches early, the wins can be huge.
21:55:22 <iqubic> And I'm running (nub . permutations) on every single word of my input, because I can't think of a better way to do it.
21:55:57 <iqubic> I need a way to get a list of the unique permutations of a string
21:56:35 <c_wraith> are you familiar with the somewhat slower select-based permutation algorithm?  It can be trivially modified to not return duplicates
21:57:03 <c_wraith> and if it's removing a lot, that is a big win
21:57:10 <glguy> I really like the NumDecimals extension. It's so much easier to read 5e7 than 50000000
21:57:10 <iqubic> permutations [] = []
21:57:27 <c_wraith> iqubic: that's already fishy.  usually permutations [] = [[]]
21:58:12 <iqubic> permutations (x:ys) = x:(permtations ys) ++ []:(permutations ys)
21:58:18 <iqubic> Yeah, I know the thing.
21:58:32 <iqubic> Well, my Advent of Code thing finished.
21:59:12 <iqubic> but I may go back later an make it faster.
21:59:45 <iqubic> How do you modify my permutations function to not return duplicates?
22:00:56 <ongy> how badly do I break things when I abuse IORef and unsafePerformIO to build loops in my data structures?
22:02:07 <mniip> > let perm [] = [[]]; perm xs = nub xs >>= ((fmap . (:)) <*> (perm . (`delete` xs))) in perm [1,1,2]
22:02:09 <lambdabot>  [[1,1,2],[1,2,1],[2,1,1]]
22:03:32 <iqubic> Well, I want to just jump day 17, but I have no idea what day 17 wants from me
22:03:42 <glguy> obviously what we should do is map each letter to a prime number and then take the product of them and then compare that
22:04:19 * hackage typed-spreadsheet 1.1.1 - Typed and composable spreadsheets  https://hackage.haskell.org/package/typed-spreadsheet-1.1.1 (GabrielGonzalez)
22:04:20 <iqubic> Not actually a bad idea. I'd like to see you write that.
22:05:16 <iqubic> But really, what does day 17 want from me?
22:06:00 <Average-user> glguy: how long it takes your part 2?
22:06:09 <glguy> 1.5s
22:06:31 <Average-user> glguy: nice
22:06:51 <cocreature> I have 0.72s
22:06:52 <iqubic> Mine takes an upwards of a minute, because I am running (nub . permutations) once per word.
22:07:53 <iqubic> What does day 17 want?
22:08:03 <Average-user> your soul
22:08:05 <glguy> YOu're going to actually have to open the webpage and read the words
22:08:38 <Average-user> glguy: Yeah, I had a hard time finding where did it matters the input
22:08:59 <iqubic> I did read the words. I have no clue what it wants.
22:09:16 <cocreature> read it again and take a look at the example
22:10:54 <glguy> cocreature: I compiled with llvm and it goes 0.5s now
22:11:17 <glguy> do you get a similar speedup?
22:12:37 <EvanR> iqubic: you seem to be being very unconstructive
22:14:16 <cocreature> glguy: nope, seems to stay at 0.72
22:17:11 <Average-user> I'm sad, my solution takes 50s
22:17:25 <Average-user> Bu it is the same algorithm that you have glguy
22:17:54 <LiaoTao> What are you guys solving?
22:17:55 <EvanR> optimization flags, ghc version, power saving mode
22:18:06 <glguy> LiaoTao: https://adventofcode.com
22:18:09 <cocreature> Average-user: are you missing a bang pattern or something like that?
22:18:12 <EvanR> amount of cache memory
22:18:14 <LiaoTao> Today's problem?
22:18:22 <glguy> yeah
22:18:29 <LiaoTao> I'm still on day 8
22:18:33 <LiaoTao> Started late
22:19:22 <glguy> have you joined our group? 43100-84040706 http://adventofcode.com/2017/leaderboard/private
22:19:52 <LiaoTao> There's a group?
22:20:17 <glguy> I stopped advertising a couple days ago because I figured it was getting annoying, but yes!
22:20:25 <Average-user> cocreature: No, it is just because arithmetics is not exactly Prolog's strength 
22:21:19 <cocreature> Average-user: ah ok
22:21:31 <LiaoTao> So it's a multi-year thing?
22:21:39 <glguy> Yes, this is year 3
22:21:45 <LiaoTao> Ah
22:21:49 <Average-user> well, bye. Is 3:21am here
22:22:00 <LiaoTao> Day 7 was slightly annoying this year
22:22:04 <LiaoTao> Parsing and tree manipulation
22:22:25 <Average-user> was nice
22:23:49 <LiaoTao> That being said, though, learning how to use attoparsec was nice
22:23:53 <LiaoTao> :)
22:23:55 <cocreature> the only one that really annoyed me was the spiral
22:24:01 <cocreature> or rather part 2 of the spiral
22:24:07 <LiaoTao> Mmm
22:24:19 <LiaoTao> That took a good afternoon
22:25:03 <LiaoTao> Day 8 seems like it was made for Haskell, though
22:26:14 <Average-user> day 8 was made for Clojure
22:26:16 <Average-user> or Lisp
22:27:02 <EvanR> do we have acme-clojure yet
22:28:05 <Lowl3v3l> i always thought lisp was created on day zero, so god could hack the universe in it :P
22:29:25 <LiaoTao> Is there a mutable hashmap for ST or IO?
22:29:41 <cocreature> there is a "hashtables" package
22:30:19 <LiaoTao> cocreature: Thanks
22:30:39 * EvanR wonders about mutable anything in clojure
22:31:01 <admin01> I'm super new and I'm confused why [10,9..1] seems to have such different functionality from [2,4..10]. Shouldnt it "count by 10's"?
22:31:19 <dmwit> > 9-10
22:31:21 <lambdabot>  -1
22:31:22 <dmwit> > 4-2
22:31:24 <lambdabot>  2
22:31:38 <dmwit> They count by -1's and 2's, respectively.
22:31:56 <admin01> so why does telling it 10 cause it to count by -1?
22:32:01 <LiaoTao> admin01: The stepping of the range is determined by the two first elements
22:32:13 <dmwit> admin01: It counts by the difference between the two numbers separated by a comma.
22:32:15 <admin01> oooh! i get it
22:32:20 <admin01> tx fam
22:34:51 <Lokathor> glguy, i'm pretty well ranked in the group, but i think that's because a limited number of people are up at the right time
22:34:51 <Lokathor>  :P
22:35:05 <sssilver_> guys, if your function only makes sense for arrays of size 2 and above, what's the most idiomatic way to implement that?
22:35:21 <dmwit> Actual arrays, or lists?
22:35:26 <sssilver_> lists
22:35:39 <dmwit> foo :: a -> a -> [a] -> b
22:36:18 <sssilver_> dmwit pls elaborate... that looks like something that takes 3 arguments, third one of which is array, the other 2 are scalar
22:36:26 <dmwit> or `data TwoOrMore a = TwoOrMore a a [a]`
22:36:35 <LiaoTao> sssilver_: You might want to return a Maybe answer, if the function fails for shorter arrays
22:36:37 <glguy> Lokathor: I think it's just fun to see how many people are keeping up with it
22:36:40 <EvanR> (a,a,[a]) 
22:36:45 <EvanR> cant be denied
22:36:49 <sssilver_> LiaoTao yes Maybe is one of the things I've been considering
22:37:08 <dmwit> sssilver_: Yes, that's correct. A list of size 2 or above is just like two elements plus a list of size 0 or above.
22:37:10 <sssilver_> but Maybe then inherently becomes a runtime check
22:37:12 <glguy> Lokathor: and oh yeah, getting started right at the opening bell is key for leaderboard position
22:37:26 <Lokathor> i was about 40 min late today :P
22:37:26 <EvanR> and if Nothing has no recourse, its pointless
22:37:38 <Lokathor> and then i wasted time because i read it as 5 millionth not 50 millionth
22:37:43 <EvanR> sssilver_: the extra 2 items trick is a way to statically guarantee you have to provide them
22:37:51 <EvanR> but it does fly in the face of all the array functions
22:37:58 <glguy> Lokathor: I copy/paste numbers like that
22:38:16 <EvanR> something else you can do is prove that at least 2 items are in there, and hope you remember the proof when you refactor
22:38:18 <Lokathor> that i will do in the future
22:38:50 <dmwit> sssilver_: (You can still provide most of the fun typeclasses bare lists have, so that using a type like `TwoOrMore` is not so painful as you might first assume. See also `NonEmpty` in the `base` package, which is for lists of size 1 or above.)
22:38:53 <glguy> Lokathor: The other thing I do is using NumDecimals, so I can write 5e7 and be confident that it's 50 million
22:38:54 <EvanR> or use a smart ctor for arrays that somehow are guaranteed to be longer than 2
22:39:08 <ongy> NumDecimals is quite the nice extension
22:39:25 <sssilver_> so seems like using a Maybe may be the most idiomatic thing to do in a general sense
22:39:37 <dmwit> NumDecimals and BinaryLiterals should be included in Haskell 202x by default.
22:39:38 <EvanR> not necessarily :(
22:40:01 <EvanR> sssilver_: Maybe only makes sense if failure is to be expected sometimes, like failing would not be a bug in your code
22:40:29 <dmwit> sssilver_: Maybe is quite idiomatic. Making it statically guarantee your size constraint can also be idiomatic. Depends what you want/need.
22:40:37 <Lokathor> well at first i read 5mil and was like "oh i can store that in RAM, that's like 40mb, i'll just start that computing while i try to think of a faster way too"
22:40:39 <EvanR> you seem to be confident theres at least 2 elements
22:41:03 <Lokathor> then later "oh no, fifty mil... nope, not gonna compute even close to fast enough... not at the rate this thing is using the ram"
22:41:06 <glguy> Lokathor: I did my first pass storing the 50m elements in ram while I worked on the second
22:41:15 <glguy> it finished in 1m15s
22:41:23 <Lokathor> that never finished for me at all
22:41:30 <sssilver_> EvanR I'm improving this function -- http://lpaste.net/360856 -- imo it doesn't make sense for arrays smaller than 2
22:41:39 <Lokathor> it crept up to ~11mb stored before i answered a faster way and killed that process
22:41:50 <sssilver_> actually, for an array of size 1 I could return the one element for both min and max
22:41:58 <sssilver_> perhaps that makes sense
22:42:04 <EvanR> it doesnt make sense for empty array
22:42:10 <EvanR> similar to minimum and maximum
22:42:14 <EvanR> > minimum []
22:42:16 <lambdabot>  *Exception: Prelude.minimum: empty list
22:42:26 <EvanR> only use on non empty list
22:42:43 <dmwit> sssilver_: Yes, I would make this function accept one-element lists. And then you should use `NonEmpty` from `base`.
22:42:49 <dmwit> (instead of `[a]`)
22:42:55 <EvanR> you need a reason to believe the list is non empty, or attempt to use that other data type
22:43:05 <sssilver_> many thanks dmwit and EvanR -- you guys are wonderful
22:43:06 <WinterFox[m]> Has anyone here used yesod?
22:43:07 <sssilver_> this makes sense
22:43:25 <EvanR> at least 2 did seem a bit oddball
22:44:58 <WinterFox[m]> I'm trying to build an API using yesod but the docs and community seems fairly sparse.
22:45:10 <dmwit> ?where justask
22:45:10 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
22:45:33 <cocreature> huh? yesod has a whole book full of documentation
22:45:45 <sssilver_> yesod is pretty well-documented imo
22:45:57 <sssilver_> but then one man's prize is another's folly
22:46:39 <WinterFox[m]> So I'm trying to set up tests right now but the tests have to run in the correct order to work because I do stuff like create a post and then get the post and see if it's correct but I can't see a way to set the order tests run in if there are multiple files,
22:47:01 <WinterFox[m]> By the looks of it every file in test/handler is run in alphabetical order I think.
22:48:29 <dmwit> Perhaps you should make a minimal example that you can share with us, showing how you've set up your tests and how you run them.
22:49:01 <dmwit> A priori I don't see why this question should have anything to do with yesod.
22:49:24 <WinterFox[m]> Well currently it's just the default setup that came from the blank yesod project.
22:50:42 <WinterFox[m]> I'm not sure if it even makes sense to do things this way. How I would do it in rails would be adding data to the fixtures which gets loaded in to the db before the tests start and then no test depends on the ones before it.
22:57:53 * hackage protocol-radius 0.0.1.0 - parser and printer for radius protocol packet  https://hackage.haskell.org/package/protocol-radius-0.0.1.0 (KeiHibino)
22:59:50 * hackage protocol-radius-test 0.0.1.0 - testsuit of protocol-radius haskell package  https://hackage.haskell.org/package/protocol-radius-test-0.0.1.0 (KeiHibino)
23:09:32 <sssilver_> what am I doing wrong here? http://lpaste.net/360858
23:09:39 <sssilver_> trying to use NonEmpty instead, but now can't match on [a, b]
23:10:08 <cocreature> pattern match on (a :| [b])
23:10:44 <sssilver_> 💀
23:12:53 <tavi> 💀
23:14:21 <EvanR> :|
23:14:35 <EvanR> (:[])
23:14:49 <EvanR> haskell, emoji oriented programming 
23:17:53 <mniip> % :?
23:17:53 <yahb> mniip:  Commands available from the prompt:; <statement> evaluate/run <statement>; : repeat last command; :{\n ..lines.. \n:}\n multiline command; :add [*]<module> ... add module(s) to the current target set; :browse[!] [[*]<mod>] display the names defined by module <mod>; (!: more details; *: all top-le
23:21:57 <sssilver_> perhaps I shouldn't have started refactoring this into using NonEmpty without better haskell knowledge
23:22:03 <sssilver_> note to self
23:23:31 <EvanR> i am suspicious of something like NonEmpty
23:23:44 <EvanR> its kind of like a type dedicated to positive Nat
23:24:26 <EvanR> it requires a replacement for the entire library but it acts exactly the same
23:24:35 <EvanR> except for a couple things
23:36:53 <mniip> I should rewrite the yahb frontend
23:36:57 <mniip> in haskle
23:37:30 <mniip> or maybe not haskle...
23:39:54 * hackage data-diverse-lens 1.0.0.1 - Isos & Lens for Data.Diverse.Many and Prisms for Data.Diverse.Which  https://hackage.haskell.org/package/data-diverse-lens-1.0.0.1 (louispan)
