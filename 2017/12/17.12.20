00:32:20 <vaibhavsagar> what's the easiest way to turn a list of 3 items into a 3-tuple
00:32:44 <vaibhavsagar> :t (\[a,b,c] -> (a,b,c))
00:32:46 <lambdabot> [c] -> (c, c, c)
00:33:41 <liste> vaibhavsagar: that'd be it, note that it's partial
00:33:57 <vaibhavsagar> yeah, I just need this for today's AoC
00:34:17 <liste> @pl (\[a,b,c] -> (a,b,c))
00:34:17 <lambdabot> (line 1, column 3):
00:34:17 <lambdabot> unexpected "["
00:34:17 <lambdabot> expecting pattern
00:34:24 <vaibhavsagar> because I was not smart and didn't use Linear.V3
00:34:28 <liste> @pl (\a:b:c:_ -> (a,b,c))
00:34:28 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . (const .)) .) . (,,) . head) tail
00:34:37 <liste> definetely not that ↑
00:34:41 <vaibhavsagar> hahaha
00:34:56 <supercynic> ello
00:34:56 <vaibhavsagar> TupleSections might help
00:35:11 <vaibhavsagar> hi there
00:35:17 * liste thinks (\[a,b,c] -> (a,b,c)) is best
00:35:49 <supercynic> (\(a:b:c:_) -> (a,b,c)) is slightly better
00:36:13 <supercynic> (or slightly worse depending on whether you want your program to crash)
00:36:33 <liste> supercynic: that might hide an error condition if you want them to be explicitly 3-.ists
00:36:36 <supercynic> oh, and i'm no longer…
00:37:32 <vaibhavsagar> how good are applicative parser combinators
00:45:08 * frerich vaibhavsagar: I think that's difficult to answer; maybe you could write a parser in both monadic and applicative style and then compare (often, but not always, applicative-style parsers look quite neat IMHO).
00:45:30 <vaibhavsagar> frerich: it was a rhetorical question
00:45:39 <vaibhavsagar> I <3 applicative parser combinators
00:57:05 <ertes-w> vaibhavsagar: you mean a proper non-monad applicative?
00:57:34 <vaibhavsagar> ertes-w: I'm most familiar with Attoparse, which is also monadic
00:57:35 <jle`> vaibhavsagar: they are pretty good
00:57:37 <vaibhavsagar> *attoparsec
00:57:55 <vaibhavsagar> but I like the applicative API when I get to use it
00:58:00 <ertes-w> vaibhavsagar: there aren't many proper applicative parser libraries out there, but yeah, they do have distinct advantages
00:58:17 <liste> @hoogle regex-applicative
00:58:17 <lambdabot> package regex-applicative
00:58:17 <lambdabot> package regex-applicative-text
00:58:25 <liste> @hackage regex-applicative
00:58:26 <lambdabot> http://hackage.haskell.org/package/regex-applicative
00:58:28 <ertes-w> for example they can deal with (<|>) very efficiently even in deep cases
00:58:34 <vaibhavsagar> oh, like optparse-applicative?
00:58:59 <ertes-w> optparse-applicative is another example, yeah…  it can extract full help information without examining all possible outcomes
01:00:48 <ertes-w> the original idea for arrows (back when we didn't have Applicative) was also designed for parsers…  applicative and arrow parsers can utilise deep knowledge about the grammar before even running the parser, so it can drop impossible alternatives as soon as it has enough context
01:01:39 <vaibhavsagar> I've never really gotten into arrows
01:01:58 <vaibhavsagar> the extent of my knowledge is that they're related to profunctors, which I also never really got into
01:02:42 <ertes-w> good for you…  arrows suck =)
01:02:53 <vaibhavsagar> why so?
01:04:22 <ertes-w> they are difficult to work with, and the API is something you wouldn't want to work with directly, so you would use arrow notation (proc/do), but then you get unnecessarily inefficient code
01:06:00 <ertes-w> the main difference between arrows and monads is that things that are first-class in the latter aren't first-class in the former
01:06:28 <ertes-w> proc x -> y <- c -< x + 1; id -< (x, y)
01:06:53 <ertes-w> you see those x and y?  proc/do notation makes them seem like first-class values, but that's an illusion
01:10:27 <cocreature> I just pretend Control.Arrow is a module containing combinators for working with functions operating on tuples and ignore the rest :)
01:12:18 <frerich> Yes, to me, Control.Arrow is 'first', 'second', '&&&' and then a lot of crazy magical stuff.
01:12:56 <vaibhavsagar> cocreature: I have a tweet to that effect :)
01:13:14 <vaibhavsagar> just can't seem to find it, does anyone know how to search twitter?
01:13:25 * frerich notices part 1 of today's AoC challenge is a good use case for the Monoid instance of Ordering. :-)
01:14:16 <shiona> how so?
01:14:32 <vaibhavsagar> https://twitter.com/vbhvsgr/status/841553876767592448
01:15:22 <ertes-w> > fold (zipWith compare "hello" "hero")
01:15:26 <lambdabot>  LT
01:15:33 <ertes-w> > fold (zipWith compare "hello" "hi")
01:15:36 <lambdabot>  LT
01:15:42 <ertes-w> > fold (zipWith compare "hello" "hallo")
01:15:44 <lambdabot>  GT
01:22:05 <frerich> shiona: I think you could solve part 1 by first ordering the particles by acceleration (ascending) and then order items with equal acceleration by velocity (ascending) and then order items with equal acceleration by position (ascending). And the minimum of that will be the particle which will be the closest to the origin.
01:41:18 <yeoman> Hello, im trying to learn haskell
01:41:21 <yeoman> https://stackoverflow.com/questions/22620294/minimal-warp-webserver-example
01:41:34 <yeoman> in this example, where does import Network.Wai (responseLBS, Application) Application come from
01:41:40 <yeoman> i can't seem to find it in yesods repository
01:41:50 <yeoman> am i misunderstanding something about the module system?
01:42:32 <merijn> yeoman: The module system allows re-exporting names from other libraries, but the docs are currently a bit bad about showing where the original is from
01:42:57 <yeoman> at what point in which file would i see that?
01:43:07 <yeoman> Network/Wai ?
01:43:28 <yeoman> module Network.Wai(Application,..) this one?
01:43:29 <merijn> yeoman: The cabal file of a project lists all the package dependencies, but usually I just search Hoogle/Hayoo for the module name
01:43:39 <merijn> yeoman: https://www.haskell.org/hoogle/?hoogle=Network.Wai
01:43:46 <merijn> So, seems to be the way package
01:44:30 <yeoman> i don't follow :(
01:44:52 <AndreasK> yeoman: You can search for functions on hoogle: http://hoogle.haskell.org/
01:45:08 <yeoman> but isn't this a type :o?
01:45:26 <yeoman> https://hackage.haskell.org/package/wai-3.2.1.1/docs/Network-Wai.html#t:Application
01:45:30 <yeoman> yay, this is it, isn't it?
01:45:34 <merijn> yeoman: You can searh Hoogle for types, values, modules
01:45:45 <merijn> yeoman: It doesn't index everything available, but a lot of major stuff is there
01:45:48 <yeoman> but i want to know WHAT it is..
01:46:01 <ertes-w> yeoman: in haskell there are packages, which contain modules, which contain definitions
01:46:19 <yeoman> yeah i want to find the definition of Application
01:46:23 <merijn> yeoman: Right, so that link is what it is
01:46:25 <yeoman> maybe without hoogle
01:47:05 <yeoman> so application is just a function that maps the request to a response, amazing!
01:47:31 <fakenullie> doesn't it also produce side effect
01:47:41 <merijn> yeoman: It's not a function, it's the TYPE of a function that does that
01:47:54 <yeoman> yeah i understand that difference
01:48:03 <yeoman> still. wherew would i find that in the wai sources?
01:48:18 <AndreasK> click source on hoogle for parts of it
01:48:27 <yeoman> OH there it is.
01:48:35 <yeoman> i expected it to be longer, that's why i didn't find it, lol
01:49:10 <AndreasK> hackage often also has links to the repo of a package (or you can download the source of a package as well from it)
01:55:20 <ertes-w> yeoman: the way i search for stuff is by browsing modules on hackage
01:55:34 <ertes-w> yeoman: because usually you have a starting point, and then you just follow links
01:57:53 <yeoman> i like to work with less tools as possible
01:57:57 <yeoman> so you don't depend on them
01:58:38 <ertes-w> yeoman: if you use firefox or friends you can create a bookmark to <https://hackage.haskell.org/package/%s>, then open the bookmark properties and add a keyword "p"
01:58:50 <ertes-w> then you can just type "p wai" into the address bar to get to wai's hackage page
01:59:28 <ertes-w> typing ' will open a quick search bar that only searches for links, so you can quickly go to the module you need
01:59:43 <ertes-w> '.wai
02:00:14 <yeoman> as i said :D less tools
02:00:26 <shiona> frerich: huh, didn't even think about that. I had one particle with accelleration 0 and that was it
02:00:45 <shiona> also what do you think, is the question for part 1 clear?
02:00:46 <ertes-w> yeoman: well, the browser is just something i take for granted =)
02:01:01 <yeoman> don't forget the internet connection :)
02:01:03 <frerich> shiona: Alas, a colleague just pointed out that this doesn't always work (it did work for the example and my input to problem 1, but my colleague constructed a case where it does not work).
02:02:31 <ertes-w> yeoman: i also have a bookmark to <file:///home/USER/.cabal/share/doc/x86_64-linux-ghc-VERSION/index.html> with the keyword 'hstd' =)
02:02:32 <AndreasK> yeoman: I get the sentiment but hoogle is too valuable to not use it imo
02:03:24 <ertes-w> yeoman: but that's not project-specific, so it would require me to install everything globally, and that's why (when i'm online) i tend to prefer hackage
02:04:36 <ertes-w> i guess you could make this work per-sandbox or whatever the new-build equivalent is
02:40:18 <ventonegro> Hmmm... pandoc-citeproc of LTS 10 doesn't build
02:40:30 <ventonegro> How did it make to LTS?
02:46:25 <mniip> you know what mtl needs
02:46:35 <mniip> ah, no, I don't think it can even have that
02:47:59 <mniip> well, basically, for some effect E, the class MonadE should have an extra parameter. MonadE ... m i | m -> i,
02:48:10 <mniip> with an extra method: liftThroughE :: i a -> m a
02:48:43 <merijn> ertes-w: new-build has no "per-sandbox", since it uses a Nix inspired approach of naming every package via a hash of it's dependencies, which allows multiple installed versions of the same package to Just Work
02:48:44 <mniip> with instance MonadE ... (E i) i
02:49:00 <merijn> ertes-w: Basically, everything *always* builds as if it had a private sandbox in new-build
02:49:02 <mniip> and MonaeE m i => MonadE (Other m) i
02:59:31 <ertes-w> merijn: ah, i see
03:00:08 <merijn> ertes-w: It also builds docs per-version (if told to build docs), although there isn't yet away to conveniently browse those that I'm aware off
03:10:36 <mniip> perversion hehe
03:15:24 <mniip> kind of like
03:15:40 <mniip> @letlpaste 360963
03:15:40 <lambdabot>  That paste is too long! (maximum length: 4096)
03:17:27 <yeoman> haskell does not compile to webassembly very well, because it requires garbage collection, right?
03:40:36 <merijn> yeoman: That's not really the (or even a) reason
03:40:52 <merijn> yeoman: It's mostly that, afaict, people have only been working on web assembly for less than a year
03:41:11 <merijn> yeoman: Keep in mind GHC compiles to machine code on x86/x64 just fine and it's still GCed
04:01:30 <kamyar> Guys please help me with Scotty, a WAI compatible http server in Haskell
04:01:42 <kamyar> I just want to response a file with 'file' function in Scotty
04:01:53 <kamyar> and I want to read the file from silesystem
04:01:56 <kamyar> filesystem
04:01:59 <kamyar> how can I do that?
04:02:08 <kamyar> Do I need to use womething like COnduit or pipes?
04:02:28 <merijn> kamyar: AFAIK Wai application just return a lazy ByteString, no?
04:02:50 <merijn> The absolute simplest thing would be to just use bytestring's lazy file IO
04:03:04 <lseactuary> anyone here good at first order logic please? i am trying to solve one problem, i think i've got the solution, but stuck now on the recursion. wanted to run it past someone.
04:04:18 <kamyar> merijn: I can use file function but is it good in performance? Do I need to use stream function with conduit or so?
04:06:00 <merijn> kamyar: The lazy ByteString functions should perform well. Biggest potential problem is the fact that if you don't force the entire BS you might leak the file descriptor
04:06:27 * hackage hledger-diff 0.2.0.12 - Compares the transactions in two ledger files.  https://hackage.haskell.org/package/hledger-diff-0.2.0.12 (gebner)
04:06:40 <ertes-w> kamyar: the way you read the file is completely unrelated to wai/scotty
04:06:59 <ertes-w> kamyar: how you should read the file depends on what you want to do with it
04:08:50 <ertes-w> kamyar: wait, you want to *respond* a file
04:09:22 <ertes-w> kamyar: in that case you should just use 'file'
04:09:56 <ertes-w> wai will generally use some OS-specific mechanism to send files efficiently, e.g. sendfile
04:26:40 <kamyar> ertes-w: Thanks! I was thinking if using some package like conduit help
05:00:19 * hackage lxd-client 0.1.0.5 - LXD client written in Haskell.  https://hackage.haskell.org/package/lxd-client-0.1.0.5 (hverr)
05:04:15 <yeoman> merijn: well i know, but ghc compiles to llvm and therefore it compiles to webassembly? doesn't it?
05:04:28 <merijn> yeoman: GHC does not (by default) compile to llvm
05:04:30 <yeoman> the fact that webassembly is really young doesn't matter at all, i mean it works
05:05:19 <yeoman> just wondering, haskell inside a browser would be cool
05:05:25 <yeoman> and ghcjs seems to be the wrong approach if you ask me
05:05:35 <merijn> yeoman: By default GHC uses the native code-gen which is GHC specific. There is an LLVM backend, but it's not enabled by default since it's 1) kinda brittle (works only with a specific LLVM version, although there's work to improve this) and 2) on average the LLVM codegen is only better for numeric code, for non-numeric code the native codegen produces better performance on average
05:05:58 <yeoman> merijn: interesting
05:06:37 <merijn> Better LLVM support is something a bunch of people are working on (including things like supporting multiple LLVM versions via bitcode, iirc)
05:06:56 <hpc> the RTS would have to be ported to webassembly too
05:07:17 <tdammers> yeoman: also, the big hurdle with getting GHC to compile to webassembly is not so much generating webassembly code, but rather porting the runtime and base libraries, because much of that depends on libc, which isn't automatically available in webassembly
05:07:19 <merijn> yeoman: The other thing is, there's a lot of stuff in the RTS (threading, timing, scheduling, etc.) which uses a lot of syscalls
05:07:20 <yeoman> and nones working on that? what does the RTS use for garbage collection?
05:07:21 <hpc> so it's not just a transparent "llvm gives it for free" thing
05:07:40 <yeoman> hpc: it would be, if there was no RTS
05:07:44 <merijn> yeoman: Last I saw on reddit there was an effort to implement those syscall in webasm to make porting the RTS easier
05:07:45 <yeoman> i get that.
05:07:57 <merijn> yeoman: The RTS is what does the garbage collection
05:08:10 <yeoman> i get that.. what does it use for it? special library? own?
05:08:30 <tdammers> GHC's GC is written from scratch, specifically for running GHC Haskell
05:08:43 <yeoman> thats gr.. crazy
05:08:58 <merijn> yeoman: How so? What else would it use?
05:09:13 <merijn> yeoman: Most existing GC implementations are designed for very different constraints
05:09:14 <yeoman> that wasn't critism, it's just hard to port this way i guess.
05:09:14 <tdammers> maybe so, but it allows us to exploit some useful properties of Haskell and of the intermediate minilanguages used in the various stages of the GHC compiler
05:09:16 <hpc> i am not aware of a "standard" garbage collection algorithm that exists anywhere
05:09:34 <yeoman> hpc: i don't remember it. but #crystal-lang
05:09:37 <tdammers> but more importantly, Haskell's GC requirements are radically different from those of a strict impure language
05:09:38 <yeoman> uses a existing one
05:09:48 <yeoman> or was it just #crystal
05:09:52 <tdammers> we need to support crazy amounts of tiny, short lived objects
05:10:27 <merijn> yeoman: Crystal seems a very thin wrapper around C, tbh?
05:10:29 <yeoman> do all haskell implementations work with something like a RTS
05:10:41 <merijn> Probably they use something like Boehm
05:10:53 <yeoman> yeoman: does it? i thought it uses llvm
05:11:01 <yeoman> i think boehm sounds about right
05:11:12 <merijn> yeoman: Well, there's really only like 3 implementations, only 2 of which are public and only one is widely used
05:11:12 <yeoman>      Beschreibung:           The Boehm-Demers-Weiser conservative garbage collector
05:11:39 <merijn> Using Boehm would really not make sense for Haskell, though
05:11:55 <yeoman> okay, do all haskell implementation go this RTS approach?
05:12:02 <yeoman> or is that ghc specific
05:12:11 <WinterFox[m]> I'm getting an error from GHC on a line that doesn't exist. What could cause this?
05:12:16 <hpc> for all practical purposes, ghc is all haskell implementations
05:12:21 <yeoman> WinterFox[m]: zero space whitespace
05:12:26 <merijn> yeoman: I mean, most languages use an RTS of some description. The biggest difference is how big said RTS is
05:12:46 <hpc> even C has an RTS
05:12:47 <ventonegro> Even C has a runtime library (libc)
05:12:49 <merijn> yeoman: Hell, even C (at least, hosted C which most people use)
05:12:57 <yeoman> well.. that doesn't count i's optional
05:12:57 <ventonegro> jynx
05:12:58 <merijn> hpc: *hosted* C has a RTS
05:13:03 <WinterFox[m]> There is nothing but a language extension in this file but I'm getting an error on line 9
05:13:04 <hpc> ah yeah
05:13:16 <merijn> ventonegro: libc is not the C RTS
05:13:27 <hpc> hosted C has just enough RTS above main in the stack frame for you to implement exit and a couple of other tiny things like that
05:13:28 <merijn> And C only uses an RTS in hosted implementations
05:13:30 <yeoman> libc is optional, i excluded it in programs several times
05:13:49 <yeoman> don't think that'd be true for haskell, right?
05:13:50 <ventonegro> merijn: Where is malloc/free then?
05:14:02 <merijn> ventonegro: libc, but malloc and free are hardly required for C
05:14:22 <merijn> yeoman: Hosted C (i.e. not running baremetal) has an RTS. What do you think calls main? :)
05:14:36 <yeoman> the fuck is hosted c, never heard that one
05:14:38 <merijn> yeoman: True, it's a very minimal one that does barely anything, but it's there
05:14:43 <hpc> hosted c is "normal" c
05:14:45 <merijn> yeoman: The C standard defines two flavours of C
05:14:52 <Rembane> merijn: Like malloc and free?
05:15:04 <ventonegro> merijn: Not "hardly", they are taken for granted 99% of the time, the special situations you have in mind notwithstading
05:15:05 <merijn> yeoman: "hosted" and "standalone", hosted implies "running on an existing operating system"
05:15:07 <[exa]> yeoman: the one where you can return from main and it doesn't segfault
05:15:17 <yeoman> so kernel => not hosted
05:15:20 <yeoman> user_land => hosted?
05:15:21 <merijn> ventonegro: non-hosted C is used in embedded devices where you can't malloc anyway
05:15:25 <merijn> yeoman: Roughly, yes
05:15:49 <yeoman> i get it
05:15:57 <hpc> grub is probably a better example, i think
05:16:07 <merijn> Rembane: malloc and free are part of libc and you can perfectly write valid and legal C code without using libc
05:16:09 <[exa]> yeoman: the important distinction is also the fact that hosted C can be reasonably linked
05:16:22 <ventonegro> I'm therefore resigning from this semantic battleground
05:16:22 <hpc> you dump some code at a specific hard drive address and hardware/firmware starts the program
05:16:40 <Rembane> merijn: Okay, then I misunderstood what parts belong to the RTS
05:16:50 <yeoman> well back to topic: are there haskell implementations without RTS?
05:16:55 <merijn> Rembane: Really the only thing the C "RTS" does is call main()
05:17:10 <merijn> yeoman: Not that I'm aware off, but there's no theoretical restriction preventing one from being made
05:17:10 <ertes-w> yeoman: no
05:17:30 <Rembane> merijn: Okay, when I grow up I want to work as the C RTS, seems like a chill job.
05:17:35 <merijn> yeoman: iow, there's an RTS because it's convenient/easy to implement, not because it's required
05:17:37 <ertes-w> merijn: i think there is
05:17:43 <ertes-w> even unlambda has GC
05:17:49 <jcjf> What does it even mean to not have a runtime system?
05:18:05 <yeoman> jcjf: .. some crazy guy could've written a haskell to ruby compiler
05:18:10 <yeoman> it could just use the gc of ruby then
05:18:15 <yeoman> something like that
05:18:15 <jcjf> Unless you're writing an operating system
05:18:19 <merijn> ertes-w: I don't think so, you just have to teach the compiler to know about syscalls and inline the GC code inside the machine code
05:18:34 <merijn> jcjf: An external library that you have to link against at runtime
05:18:35 <ertes-w> i suppose you could do that
05:18:56 <jcjf> merijn: Ah, thanks!
05:19:11 <merijn> jcjf: I would define an RTS as "an external library containing *mandatory* functionality for a program to work that is therefore required for ALL programs to be able to run"
05:19:18 <ertes-w> but then what's an RTS?  we don't call it an RTS, because it's separate code, because that's a meaningless distinction
05:19:20 <maerwald> aaand... if you statically link? :>
05:19:32 <merijn> maerwald: Then things get murky :)
05:19:40 <maerwald> I also think the linking part is irrelevant to the definition of an RTS
05:20:02 <maerwald> almost wrote linking park there
05:20:03 <merijn> At some point you enter a gray area
05:20:13 <ertes-w> to me what makes haskell's RTS an "RTS" is the fact that it does GC for me, and that it translates my blocking calls from multiple threads into epoll/whatever
05:20:15 <merijn> Like, is C's notion of stack and heap a "RTS"?
05:20:31 <hpc> merijn: the code that implements that notion is, i would say
05:20:34 <ertes-w> is the libc an RTS?
05:20:45 <maerwald> ertes-w: I think a lot of people would say that
05:20:51 <merijn> hpc: In C that code is inlined directly in the machine code
05:21:09 <hpc> merijn: there's also some setup code that happens before main is called
05:21:17 <ertes-w> i suppose haskell's RTS is slightly different in that it integrates with the language
05:21:23 <merijn> yeoman: You could certainly write an RTS for that is A LOT more minimal than GHC RTS
05:21:25 <hpc> and an RTS can interleave code into a program imo
05:21:29 <maerwald> ertes-w: it's not in the haskell report at all
05:21:39 <merijn> hpc: We already explicitly called that an RTS earlier, you're late :p
05:21:51 <hpc> heh
05:22:08 <yeoman> but in the end, people are working on getting haskell inside the browser?
05:22:11 <merijn> hpc: We even got into a whole hosted vs self-hosted C sidebar :p
05:22:20 <ertes-w> yeoman: already happened
05:22:22 <merijn> yeoman: Lots of people are working on that sorta thing
05:22:28 <yeoman> ertes-w: without js
05:22:33 * hackage eventsource-geteventstore-store 1.0.6 - GetEventStore store implementation.  https://hackage.haskell.org/package/eventsource-geteventstore-store-1.0.6 (YorickLaupa)
05:22:35 <angerman> If anyone has questions regarding the cross compilers, I'd be happy to answer them.
05:22:45 <ertes-w> yeoman: good luck with that =)
05:22:47 <merijn> yeoman: If you're familiar with web asm and llvm your help would probably be more than welcome :)
05:23:02 <yeoman> ertes-w: well, i already done it, just not with haskell
05:23:14 <yeoman> merijn: i don't even know haskell, i'd love to
05:23:19 <yeoman> this is the approach i've chosen to learn haskell though
05:23:20 <merijn> yeoman: GHC is surprisingly hackable even for beginners (if you avoid the scary things)
05:23:22 <ertes-w> microsoft has tried (and thank god they failed!), macromedia/adobe have tried (and thank god they became irrelevant!)
05:23:31 <merijn> yeoman: Hell, you can help if you know web asm and not haskell! :)
05:23:34 <yeoman> i want to build a one-language web framework
05:23:52 <yeoman> which frees me of my shackles
05:23:53 <merijn> yeoman: https://www.reddit.com/r/haskell/comments/7fu2vr/webassembly_call_to_action_syscalls_needed/
05:23:55 <yeoman> of doing shitty things
05:24:06 <yeoman> merijn: thanks man, that's a good end result
05:24:35 <merijn> yeoman: They need help implementing syscalls in web assembly, so even if you don't know Haskell you can help get those sycalls working for the people working on web asm support
05:24:39 <ertes-w> yeoman: it's easier to just compile haskell to something the browser already understands
05:24:56 <yeoman> ertes-w: i don't want easy, i want good
05:25:07 <yeoman> if you want to get to the moon you have to shoot for the moon
05:25:13 <tdammers> right now, the quickest road to success with that would be GHC on the server, GHCJS on the client, but that's still kind of a rough ride
05:25:14 <yeoman> if i want already shitty things, i write javascript
05:25:30 <ertes-w> yeoman: it's also good…  GHCJS gives you haskell, not some awkward subset, including full concurrency support
05:25:39 <yeoman> ertes-w: yeah and 1mb of preload
05:25:45 <yeoman> and no template haskell
05:25:48 <yeoman> because. buggy, and without yz
05:25:51 <yeoman> and bugs here and there
05:26:07 <tdammers> next best alternative would be purescript, which is close enough to haskell to be pleasant, and, compiling to JS, can also run on the server via nodejs
05:26:33 <yeoman> tdammers: atleast i want no compromises, done that enough
05:26:39 <ertes-w> yeoman: honestly i'd just use closure-compiler to get that size down, then zlib compression to shrink it further for transmission and wait for the GHCJS devs to fix that
05:26:57 <tdammers> yeoman: purescript compromises surprisingly little
05:27:04 <yeoman> ertes-w: i am talking about that static stuff ghcjs comes with.. a.e. the RTS
05:27:13 <ertes-w> yeoman: me too
05:27:25 <yeoman> tdammers: but i will write my model in haskell(or whatever), and i write it in purescript, again
05:27:29 <yeoman> that's already a compromise
05:27:40 <tdammers> yeoman: no, the idea would be that you write everything in purescript, client and server
05:28:02 <yeoman> yeah, right, and i love single threaded applications
05:28:07 <ertes-w> yeoman: it comes down to whether you want to give up haskell or live with larger outputs, until the GHCJS devs improve it
05:28:10 <yeoman> which i want to load balance with nginx
05:28:29 <ertes-w> yeoman: i don't want to give up haskell, because every other language i have tried ruined my day
05:28:42 <yeoman> ertes-w: that's exactly what drives me, and i do not even know haskell
05:28:48 <yeoman> but i understand what it would give me
05:28:58 <yeoman> and i really really hate the haskell syntax
05:29:36 <yeoman> i tried to write this one-language for everything with ruby and since then i am amazed by that
05:29:50 <yeoman> but ruby is slow, and stupid, it would be great to have it in haskell
05:30:01 <tdammers> btw there's another approach to reduce redundancy between client and server
05:30:02 <ertes-w> haskell's syntax is perfect for EDSLs, and EDSLs are what i want to work with – something virtually every other language sucks horribly at
05:30:26 <tdammers> instead of compiling haskell to JS, make an EDSL that generates JS from within Haskell
05:30:26 <yeoman> ertes-w: rubys DSL stuff is fun, but not really DSL
05:30:42 <yeoman> tdammers: i've thought of this, too, but then you will have types.. and js does not have types
05:30:45 <yeoman> etc..
05:30:48 <raichoo> huh, I always thought that haskell has very little syntax to hate on *shrug*
05:30:48 <tdammers> so?
05:30:53 <yeoman> well it won't be the same
05:31:05 <yeoman> you will have, once again, 2 different models
05:31:13 <tdammers> you can model a typeless language in Haskell's type system, that's absolutely not a problem at all
05:31:17 <yeoman> and that dsl adds complexcty
05:31:25 <tdammers> well ofc, you can't avoid that
05:31:39 <yeoman> by using one language for everything? sure
05:31:39 <tdammers> the only way to avoid having two different models here is to use JS for everything
05:31:47 <yeoman> or.. a better language
05:31:50 <yeoman> for everything
05:32:11 <yeoman> i've heard a talk from people who did that.. they seemed rather happy with it
05:32:20 <yeoman> i don't like the product.. but the way they did it, it's great
05:32:40 <tdammers> anyway, I think obsessing too much about "same language on client and server" isn't healthy
05:32:40 <ertes-w> yeoman: if you are the kind of person who dislikes haskell's syntax, the proper approach is to become the kind of person who likes it =)
05:32:46 <yeoman> https://www.herculus.io/ that is 100% haskell
05:33:04 <yeoman> they used ghjcs and wrote react bindings
05:33:17 <tdammers> instead, look at the actual problems you're facing
05:33:19 <yeoman> i want that in GOOD without hax.
05:33:27 <tdammers> *why* do you want the same language for both
05:33:35 <yeoman> DRY
05:33:37 <yeoman> and working.
05:33:39 <tdammers> exactly
05:33:43 <tdammers> DRY
05:33:47 <tdammers> single source of truth
05:33:57 <ertes-w> why would you use GHCJS and then bind to react?
05:33:59 <tdammers> but literally copying code around is just one way of doing that
05:34:03 <toppler> raichoo: Can't say I've ever got worked up over syntax, but there's that long article about the history of Haskell where they reckon the original mapping out of the spec was dominated by discussion about syntax, with comparatively little care given to semantics.
05:34:05 <ertes-w> we have proper FRP libraries like reflex
05:34:06 <tdammers> you can also achieve it with metaprogramming techniques
05:34:08 <yeoman> ertes-w: so you have good performance with vdom, etc?
05:34:26 <tdammers> auto-deriving 90% of your client-side code using a common metalanguage
05:34:47 <ertes-w> yeoman: what does that have to do with performance?
05:34:49 <yeoman> tdammers: yeah that is an acceptable approach, i think so too
05:34:52 <tdammers> similar to how you auto-derive most of your SQL rather than write the entire application in SQL just because SQL is inevitable on the DB server
05:35:07 <yeoman> ertes-w: i don't know, i imagine react could be faster than any vdom stuff you could implement in ghcjs haskell
05:35:23 <yeoman> also you might not want to do that ^^
05:35:34 <yeoman> but i don't know how crazy the average haskell hacker is
05:35:36 <ertes-w> it's done
05:35:39 <ertes-w> → reflex-dom
05:36:12 <tdammers> yeoman: there's no fundamental reason why Haskell code couldn't compile to JS that can perform at least on par with hand-written JS
05:36:56 <tdammers> yeoman: and further, in practice we need to make abstractions in order to keep code manageable, and Haskell is really good at making those abstractions zero-cost or low-cost, while moving them from runtime to compile time is pretty tricky in JS
05:37:40 <tdammers> yeoman: the advantage that react has is sheer community momentum
05:37:46 <tdammers> more eyeballs, more hands
05:37:54 <tdammers> more exposure, too
05:38:00 <ertes-w> yeoman: i think you're underestimating the energy the haskell community is willing to invest in not having to deal with JS, and that includes JS libraries =)
05:38:18 <yeoman> yeah i see, i will see if i can help adding syscalls
05:38:22 <yeoman> to webghc
05:38:30 <merijn> I think in general, newcomers tend to dramatically overestimate how much the average Haskell programmers cares about web-stuff
05:38:48 <yeoman> i don't, but i do care about web-stuff
05:38:50 <merijn> Because *many* newcomers to programming think only about web-things
05:38:53 <yeoman> because i think web will replace apps
05:38:57 * raichoo implemented to first javascript backend for Idris in Haskell just to counteract his company from moving to nodejs :P
05:39:13 <raichoo> So much about going through great lengths to avoid JS :D
05:39:35 <yeoman> raichoo: do your colleagues still like you?
05:39:52 <yeoman> oh it's YOUR company, okay.
05:39:56 <raichoo> yeoman: Yes, as a matter of fact I'm now teaching 1/3 of the company :D
05:40:01 <merijn> yeoman: That assumes "apps" are the only thing that exists
05:40:09 <raichoo> yeoman: No, not mine, but the one I'm working for ^^
05:40:13 <merijn> yeoman: The fast majority of code is not an app (web or other)
05:40:17 <yeoman> merijn: never said that.. they're just pretty important (not for me, for many people)
05:40:26 <raichoo> yeoman: Teaching Haskell that is.
05:40:31 <yeoman> raichoo: i got that
05:42:22 <effa> Hi, I have troubles installing hmatrix on a Windows 7 machine. Is this a good place to ask for help?
05:42:37 <ertes-w> one more note about syntax: i have a lot of issues with haskell's syntax, from things that are slightly annoying (like TupleSections) to things that are outright horrible (like records)…  but these are fairly high-level complaints…  other languages i have seen are way worse
05:43:06 <merijn> effa: Honestly, the mailing lists are probably a better place, because you'll have a bigger chance your question will be seen by windows users
05:43:11 <raichoo> ertes-w: +1
05:43:17 <merijn> effa: Since this channel tends to skew pretty hard towards *nix users
05:43:22 <yeoman> ertes-w: i hate everything about it, but i can't hide the benefits haskell has
05:43:40 <yeoman> stm, green threads built in without draw backs, pure, etc
05:43:48 <effa> Ok, I see, thanks.
05:43:50 <yeoman> that's so fukin awesome, i should really realy learn it, but i have no time
05:44:09 <sun777> is it easy to write a haskell library, turn it into a .so and call it from within C?
05:44:18 <merijn> sun777: Fairly, yes
05:44:30 <sun777> what are some keywords to be googled?
05:44:32 <raichoo> yeoman: I didn't like it at first asa well but most of that came from lack of familiarity. I'm over it now, these days I really like Haskell syntax.
05:44:33 <yeoman> does that .so then include the RTS?
05:44:46 <merijn> sun777: Assuming you have a decent understanding of C and linking I'd start with chapter 8 of the Haskell Report (which describes the FFI)
05:44:53 <sun777> i honestly dont know what is a RTS
05:44:54 <merijn> sun777: The FFI is fairly straightforward, tbh
05:45:05 <yeoman> sun777: sorry, this wasn't meant for you
05:45:11 <ertes-w> yeoman: the syntax is designed around a specific goal: currying and EDSLs…  as a newcomer it takes a while to see why, but there is a reason for everything (except the few annoyances that i mentioned)
05:45:11 <merijn> yeoman: You have to link the RTS as an so yourself
05:45:40 <sun777> will checkout chpater 8 now
05:45:42 <merijn> @where report
05:45:42 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
05:45:45 <merijn> sun777: That one
05:45:54 <merijn> sun777: In addition you might wanna have a look at: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
05:45:55 <sun777> nice
05:45:56 <ertes-w> yeoman: if you start using it, you might change your mind
05:46:07 <sun777> ty!
05:46:13 <merijn> sun777: And https://www.vex.net/~trebla/haskell/so.xhtml
05:46:32 <sun777> nice, thanks again!
05:47:09 <merijn> sun777: Basically, as long as you don't want to pass/return structs by value or mutate structs from within Haskell the FFI is trivial to work with if you're comfortable with C
05:47:23 <ertes-w> > "abc" >>= replicate 4  -- yeoman: here is an example…  haskell's syntax is designed to make this as nice as it is
05:47:24 <yeoman> ertes-w: i started several times already, i don't think it's familiarity
05:47:25 <lambdabot>  "aaaabbbbcccc"
05:47:37 <yeoman> for example, i'd love prefix calling for everything like in lisp
05:47:43 <yeoman> i've never done it, but i love it
05:47:52 <raichoo> yeoman: I also started several times ;)
05:48:06 <ertes-w> yeoman: you have the choice to use prefix notation for everything
05:48:14 <ertes-w> > (>>=) "abc" (replicate 4)
05:48:16 <lambdabot>  "aaaabbbbcccc"
05:48:20 <yeoman> yeah with ugly symbols in front
05:48:24 <yeoman> and after
05:48:46 <yeoman> (+) 3 5 is not more readable than x(3,5)
05:48:50 <yeoman> (+) 3 5 is not more readable than +(3,5)
05:49:03 <yeoman> + 3 5 would be fine i guess.
05:49:29 <ertes-w> but (1 + 2 + 3 + 4) is more readable than (+ (+ (+ 1 2) 3) 4)
05:49:41 <yeoman> well, not for me
05:49:43 <azahi> How to "convert" (I know the conversion is not possible as is) IO String to [Char]? I'm trying to take getEnv from System.Environment and use it as an input to other function that uses [Char].
05:49:47 <yeoman> i think THAT is faimilarity
05:49:56 <yeoman> infix brings only problems.. but that is opinion.. i think
05:50:03 <yeoman> i just don't see the benefit
05:50:08 <ertes-w> yeoman: the point is that the latter exposes structure that isn't really there, because (+) is associative
05:50:23 <BernhardPosselt> regarding monoids: in languages that have null, is it even possible to have meaningful implementations?
05:50:27 <ertes-w> it's syntactic redundancy that haskell protects you from
05:50:33 <tdammers> ertes-w: (+ 1 2 3 4)
05:50:41 <ertes-w> tdammers: what's the type of that +?
05:50:42 <yeoman> i don't think infix has no real reason..
05:50:52 <samvher> azahi: does the other function return an IO value?
05:50:54 <yeoman> just like base 10 has no reason but count of our fingers
05:50:54 <BernhardPosselt> e.g. take a monoid that returns the first non empty list
05:51:01 <tdammers> ertes-w: + is variadic in most lisps
05:51:03 <BernhardPosselt> or an empty list
05:51:09 <samvher> if so, you can use >>=
05:51:14 <samvher> if not, you will have to lift the other function
05:51:22 <BernhardPosselt> how do you deal with arguments that are null?
05:51:30 <samvher> String is the same as [Char] so that conversion requires no effort
05:51:31 <ertes-w> tdammers: then that's irrelevant…  if haskell were prefix-only, + would have to have a really awkward type
05:51:41 <ertes-w> if you want to allow it to be variadic
05:51:48 <merijn> azahi: You're asking the wrong question. The real question is not "how do I turn "IO String" into "String", but "how do I use a function that expects a "String" with "IO String"?"
05:52:10 <tdammers> ertes-w: agree. "prefix vs. infix" is not a discussion to be had in a vacuum
05:52:19 <tdammers> prefix-only makes sense for lisp, but less so for Haskell
05:52:25 <azahi> samvher: it's MonadIO m => String -> m ()
05:52:26 <ertes-w> yeoman: infix has a very good reason: associativity
05:52:29 <BernhardPosselt> similar to https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:First
05:52:32 <merijn> azahi: Note that IO is a Functor, so if you have "foo :: String -> Int" and "action :: IO String" you can just do "fmap foo action" to get "IO Int"
05:52:32 <azahi> merijn: yes, you could say that
05:52:42 <merijn> azahi: Right, so then you want >>=
05:52:56 <merijn> :t (>>=) `asAppliedTo` (undefined:: IO String)
05:52:57 <lambdabot> IO String -> (String -> IO b) -> IO b
05:53:11 <ertes-w> yeoman: prefix notation can only hide association by abusing dynamic typing:  (+ 1 2 3 4)
05:53:16 <yeoman> ertes-w: well, explicitly stating this wouldn't hurt if you ask me :/
05:53:19 <merijn> azahi: (IO, obviously, being an instance of MonadIO :))
05:53:29 <jcjf> :t asAppliedTo
05:53:31 <lambdabot> (a -> b) -> a -> a -> b
05:53:33 <yeoman> it confused the hell out of me as a kid
05:53:41 <ertes-w> yeoman: it does hurt, much like "private static function blah blah blah f()" hurts
05:53:41 <merijn> jcjf: asAppliedTo is just "const" with a funky type signature :)
05:54:01 <ertes-w> yeoman: it's the same kind of pointless line noise
05:54:07 <yeoman> well, i guess it's opinion
05:54:08 <jcjf> What's the (a -> b) bit for?
05:54:16 <jcjf> Oh of course
05:54:18 <merijn> jcjf: You abuse the second (thrown away) argument of const to specialise the type of the input function
05:54:22 <jcjf> Sorry, slow brain :)
05:54:37 <merijn> jcjf: It's a nice thingy to define in your .ghci :)
05:58:20 <ertes-w> yeoman: the two main problems with syntactic redundancy are 1. it requires brain power to reduce the information to its essence, 2. it's EDSL-unfriendly
05:58:29 <ertes-w> id :: a -> a  -- compare this
05:58:41 <ertes-w> template <typename A> A id(A);  -- to this
05:59:21 <ertes-w> id x = x  -- or indeed this
05:59:32 <ertes-w> function id(x) { return x; }  // to this
06:00:03 <tdammers> /** @param A a; @returns A; @note A can be any type you want */ function id(x) { returrn x }
06:00:19 <ertes-w> no, don't pretend that JS has a type system
06:00:27 <tdammers> I don't
06:00:29 <ertes-w> =)
06:00:30 <tdammers> because it doesn't
06:00:34 <dminuoso> merijn: Interesting, so the functor instance of IO is for transforming IO's result without causing any side effect?
06:00:40 <tdammers> that's why I have to document the argument and return value
06:00:47 <merijn> dminuoso: That's....not what I'd say
06:00:49 <ertes-w> people like to think that those doc-comments are good enough
06:00:56 <ertes-w> and they're wrong
06:01:05 <tdammers> very
06:01:07 <dminuoso> merijn: Okay, what would you say?
06:01:12 <tdammers> exhibit A: clojure documentation
06:01:29 <merijn> dminuoso: There is not String until after the side-effects run
06:01:46 <merijn> dminuoso: The functor instance just changes what the value returned after the side-effects is
06:02:01 <dminuoso> merijn: I thought that's what I just said. :-P
06:02:13 <dminuoso> Or how does this differ from where you stand?
06:02:40 <merijn> dminuoso: Your formulation implies (to me) that you can transform the String without running the side-effects, which doesn't make sense, since there's no String until the side-effects have happened
06:03:08 <dminuoso> merijn: Well emphasis on "result [of a side effect]"
06:03:19 <dminuoso> But anyway. We're on the same page, even if my formulation might not have been ideal.
06:03:20 <dminuoso> Thanks :)
06:04:38 <yeoman> ertes-w: i don't know, it might be just me, but i need brain activity from the infix prefix switch
06:04:48 <yeoman> imho it needs to be one, not both at the same time
06:05:52 <ertes-w> yeoman: there are times to use prefix, and there are times to use infix…  it's a matter of associativity
06:05:53 <Psybur> Been tinkering a bit more with that parMapReduce function. https://pastebin.com/GMfU4MsG
06:06:11 <ertes-w> yeoman: i can make a very good case for using (>>=) infix: multi-line actions
06:06:20 <yeoman> ertes-w: what are good examples for infix other than +,*
06:06:25 <Psybur> So parMapReduce was the fastest. Regular reduce on a parMap was the slowest, and then no parallelization at all was in the middle heh
06:06:34 <ertes-w> yeoman: in other words: imagine in C the semicolon were prefix
06:06:48 <ertes-w> (; (; a b) c)
06:06:50 <ertes-w> vs.
06:06:51 <ertes-w> a; b; c
06:07:01 <yeoman> well, ; is not a function
06:07:07 <ertes-w> yeoman: that's irrelevant
06:07:55 <ertes-w> yeoman: (>>=) has a lot of the same responsibility that ; has in C
06:09:02 <tdammers> ertes-w: I've always considered the >>= / ; metaphor misleading
06:09:28 <dminuoso> My mental model of >>= is to think of it as a kind of (.), so a >>= b is just pipe fitting.
06:09:34 <ertes-w> tdammers: it is, but i'm not using it as a metaphor…  there are cases in haskell where you use (>>=) much like you would use ; in C
06:09:44 <Psybur> Wonder if theres ever a time when using (>>=) m f would be clearer heh
06:09:48 <tdammers> ertes-w: yes, but they are fundamentally different beasts
06:09:49 <ertes-w> remember: this is not a discussion about monads, but about syntax
06:10:03 <ertes-w> tdammers: that's tangential…  this isn't about monads *at all*
06:10:08 <tdammers> *especially* when discussing syntax
06:10:36 <tdammers> >>= is more closely related to a function call in C than a semicolon
06:11:48 <dminuoso> tdammers: How is that? >>= doesn't do anything, just like function composition it denotes a kind of sequencing.
06:11:53 <dminuoso> Which ; is
06:11:58 <ertes-w> tdammers: the point was: there are good reasons to prefer (>>=) infix, especially in multi-line cases…  do you disagree?
06:12:53 <tdammers> ertes-w: no, I agree with this much
06:13:13 <ertes-w> good, case closed =)
06:13:27 <tdammers> dminuoso: ; just ends a statement. It's not even binary in any sense, nor does it bind anything in any way
06:13:30 <Psybur> Are there ever cases to prefer it prefix?
06:13:43 <tdammers> Psybur: partial application would be one
06:13:51 <Psybur> true
06:14:04 <tdammers> but operator sections are almost as convenient
06:14:08 <dminuoso> tdammers: and what does "ending a statement" mean? It's a means of sequencing statements.
06:14:18 <ertes-w> :t map (>>=) [getLine, unwords <$> getArgs]
06:14:20 <lambdabot> error:
06:14:20 <lambdabot>     Variable not in scope: getArgs :: IO [String]
06:14:31 <ertes-w> :t map (>>=) [getLine, unwords <$> System.Environment.getArgs]
06:14:32 <lambdabot> [(String -> IO b) -> IO b]
06:14:37 <ertes-w> Psybur: ^
06:14:42 <raduom> Hi everyone. I want to implement a pattern matching algorithm and I do not know how to specify a pattern to match against because it is quite dynamic. I am thinking of existentially quantifying the data parameter, but I know that this may be too much. Can someone help me understand what would be the best representation?
06:14:49 <tdammers> dminuoso: it's just a syntactic token to signal the end of a statement. Whether more statements follow or not is absolutely irrelevant.
06:14:50 <ertes-w> well…  that's not really "prefix"
06:15:00 * hackage formatting 6.3.0 - Combinator-based type-safe formatting (like printf() or FORMAT)  https://hackage.haskell.org/package/formatting-6.3.0 (ChrisDone)
06:15:00 <Psybur> ertes-w, I was about to say heh
06:15:12 <Psybur> Is it just... fix? :D
06:15:16 <tdammers> int main(int argc, const char **argv) { printf("Hello!\n") } // syntax error
06:15:16 <Psybur> nofix? :D
06:15:27 <ertes-w> it's just name calling =P
06:15:34 <raduom> how could i write in Haskell the pattern (Maybe _) ?
06:15:39 <tdammers> also
06:15:55 <dminuoso> raduom: What would that do?
06:15:59 <ertes-w> :t map ((>>=) getLine) [putStrLn, writeFile "blah.txt"]
06:16:01 <lambdabot> [IO ()]
06:16:11 <ertes-w> Psybur: ^ but honestly i prefer infix even there
06:16:15 <tdammers> int main(int argc, const char **argv) { { int i = 1; printf("One %d\n", i); } printf("Hello!\n"); } // no syntax error
06:16:22 <ertes-w> :t map (getLine >>=) [putStrLn, writeFile "blah.txt"]
06:16:24 <lambdabot> [IO ()]
06:16:31 <Psybur> Yeah infix is better
06:16:32 <tdammers> despite no semicolon between the inner { } block and the last printf
06:16:38 <raduom> i want to write a function that takes a list of patterns to match, and i do not know how to represent those patterns using haskell data types.
06:17:07 <dminuoso> raduom: How about predicate functions?
06:17:33 <raduom> dminuoso can you give me an example of how i could match Maybe _ using a predicate function?
06:17:45 <dminuoso> raduom: again, what would (Maybe _) exactly do?
06:17:59 <dminuoso> I dont understand what semantics you are asking for.
06:18:39 <raduom> match :: Pattern -> a -> Bool
06:18:48 <Psybur> In ghci is there a way to force evaluation of a var?
06:18:56 <Psybur> Or would I call it a definition
06:18:57 <raduom> Would return true when a has the shape of (Maybe _)
06:19:09 <raduom> Now. How do I write Pattern?
06:19:15 <ertes-w> raduom: patterns aren't first-class in haskell
06:19:24 <merijn> Sadly
06:19:33 <ertes-w> raduom: you can only represent patterns as functions
06:19:39 <ertes-w> :t bool
06:19:41 <lambdabot> a -> a -> Bool -> a
06:19:42 <ertes-w> raduom: like this
06:20:03 <ertes-w> raduom: the technical term for that is scott encoding
06:20:34 <raduom> ertes-w thanks. i'll look into that.
06:20:36 <mnoonan_> but if you’re just matching the shape and not binding any parts of the pattern, then plain old predicate functions (a -> Bool) should be just fine
06:20:51 <ertes-w> raduom: newtype ScottList a = ScottList { fromScottList :: forall r. (a -> ScottList a -> r) -> r -> r }
06:21:54 <raduom> mnoonan_: I am just trying to understand the territory, will learn about scott encoding see where that leaves me.
06:23:25 <ertes-w> raduom: it's literally just representing a value in terms of a function that takes all the cases and applies one of them
06:23:32 <kamyar> PLease help me resolve Cabl Hell!
06:23:37 <kamyar> Cabal
06:23:48 <barrucadu> kamyar: Use a sandbox, or new-build, or stack
06:23:55 <kamyar> I have installed GHC8 after using GHC7 on some ubuntu machine
06:24:19 <kamyar> barrucadu: How?
06:25:05 <Psybur> What would a value thats in the shape of (Maybe _) look like?
06:25:25 <kamyar> http://lpaste.net/360968
06:25:26 <ertes-w> (i think they meant (Just _))
06:25:28 <Psybur> Just or Nothing?
06:25:33 <kamyar> Here is the errors
06:25:38 <Psybur> Ok that makes more sense
06:25:45 <raduom> ertes-w I am trying to implement something along the lines of https://github.com/clojure/core.match/wiki/Understanding-the-algorithm in Haskell. I am not sure how scott encoding fits, it looks like I will need to read a bit more.
06:26:08 <kamyar> http://lpaste.net/360968
06:26:23 <kamyar> Error when trying to build cabal
06:26:38 <ertes-w> raduom: err…  are you familiar with 'case'?
06:26:52 <kamyar> plz someone help me
06:28:59 <maerwald> type Bytes struct { Bytes [] byte; Valid bool } -- jesus, I want to use a language with ADTs again
06:29:18 <raduom> ertes-w does 'case' implement the exact syntacs and semantics described in that paper?
06:29:25 <raduom> syntax*
06:29:48 <ertes-w> raduom: i don't know, but it's haskell's pattern-matcher
06:30:16 <dminuoso> raduom: Except something like Maybe _ doesn't make sense, because Maybe is a type constructor not a data constructor.
06:30:25 <raduom> ertes-w that is very good for haskell, not so good for what i need to do.
06:30:34 <raduom> dminuoso my bad. Just _.
06:30:46 <maerwald> why would people design a language without ADTs these days?
06:30:58 <[exa]> raduom: IIRC haskell patternmatching is a bit simpler than that. What exactly are you trying to do?
06:31:44 <raduom> [exa] given a pattern i want to compute a decision tree and compile the decision tree to LLVM, using haskell.
06:31:46 <dminuoso> maerwald: Ask the designers of Go why people would design a language without sensible facilities, they are the experts.
06:31:54 <Psybur> @src isJust
06:31:54 <lambdabot> isJust Nothing = False
06:31:54 <lambdabot> isJust _       = True
06:32:25 <Psybur> :t isJust
06:32:27 <lambdabot> Maybe a -> Bool
06:32:42 <Psybur> raduom, does the above help?
06:32:49 <raduom> [exa] the LLVM part is not so complicated. i am stuck at finding a way to represent generic patterns. but maybe scott is the answer.
06:33:14 <Psybur> You have a function with the signature Maybe a -> Bool, and then two patterns, Nothing and _
06:33:25 <quchen> ADTs contradict OOP, since ADTs are about making data identity the subject, whereas an object is never determined by its identity, but by its behavior. That would be my guess.
06:33:36 <quchen> The next question would be why people still make OOP languages.
06:33:39 <maerwald> quchen: wut? ADTs are fine in rust
06:33:51 <ertes-w> raduom: so you're implementing a language?
06:33:56 <[exa]> raduom: I understand the clojure stuff is processing the patterns "uncurried"?
06:34:02 <quchen> maerwald: Yes, and whether Rust is object-oriented is a guaranteed flamewar.
06:34:07 <ertes-w> raduom: because the closest you can get to first-class patterns is scott encoding
06:34:11 <maerwald> quchen: rust is as much OOP as go is.
06:34:20 <quchen> I don’t talk about Go.
06:34:23 <maerwald> we do
06:34:28 <quchen> Nobody should. :->
06:34:29 <raduom> Psybur I don't think so.
06:34:30 <maerwald> lol
06:34:39 <raduom> I am reading now on Scott encoding.
06:35:15 <Psybur> raduom, so you want a list of patterns supplied that might be more than Just _?
06:35:16 <ertes-w> raduom: note that scott encoding is problematic, because even that doesn't give you the kind of dynamic first-class patterns that clojure gives you
06:35:18 <[exa]> raduom: anyway, what exact property of the decision tree are you optimizing?
06:35:26 <ertes-w> raduom: the "problem" here is that haskell is statically typed
06:35:32 <Psybur> That are unknown at compile time
06:35:34 <maerwald> quchen: I like go for the ecosystem and the concurrency primitives. People don't build weird DSLs like in haskell. But the language is so repetitive, zero-abstraction and just ugh... powerless
06:35:37 <quchen> Scott encoding unfortunately won’t give you deep pattern matching or fallthrough patterns.
06:35:51 <raduom> [exa] the paper optimises both, but for now I just want to be able to represent it.
06:35:56 <quchen> (To be fair, deep pattern matching is also just surface level Haskell.)
06:36:09 <raduom> [exa] both meaning memory consumption and time.
06:36:33 <ertes-w> raduom: if you really want that, you will have to design a pattern language and translate the types to be matched into that language
06:36:48 <ertes-w> raduom: in other words you will need an ADT that represents patterns
06:36:50 <raduom> Psybur if you were to write a generic pattern maching algorithm in haskell, without using haskell's pattern matching how would you do it?
06:37:55 <raduom> ertes-w yes. that is what i was thinking as well. go full dynamic and have some translation between some Haskell data structures and my representation.
06:38:01 <ertes-w> raduom: the type of 'match' in that case would be:  match :: Pattern a b -> a -> b
06:38:10 <ertes-w> raduom: actually with that type you don't need to translate
06:38:58 <[exa]> raduom: the article you've linked is kindof confusing inlining and construction of decision trees
06:39:06 <fizzgig> hey #haskell; if I have an existential type conditioned on typeclass membership, can I generate the class instance for it automatically somehow? or do I have to type out the f (SomeThing thing) = f thing manually
06:39:55 <ertes-w> fizzgig: "automatically"?  do you mean dynamically?
06:39:59 <[exa]> raduom: if you have LLVM below your code, did you try just generating a "plain old" matching sequence and running it through LLVM optimizer?
06:40:06 <fizzgig> ie if I have a data SomeThing = forall a. (Thing a) => SomeThing a
06:40:16 <Psybur> Yeah I think ertes-w is going the direction I was thinking. Turning these patterns into their own grammar (in this case with an ADT)
06:40:17 <fizzgig> not dynamically no
06:40:25 <raduom> ertes-w problem here is that Pattern may have sub-patterns (ADT style), which may test a different value then a.
06:40:36 <ertes-w> raduom: Pattern can account for that
06:41:20 <totom> Does immutability has it's place in Web development? If yes why
06:41:28 <totom> its*
06:41:33 <ertes-w> raduom: remember that Pattern is an ADT…  you can encode cases like lists of patterns with a fall-back, etc.
06:42:00 <ertes-w> totom: immutability has its place in *programming*, web or not
06:42:40 <ertes-w> totom: immutable data structures are safer, more composable, support parallelism, etc.
06:43:21 <[exa]> totom: it prevents you from totally messing up the DOM (like people are used to with jQuery :] )
06:43:28 <ertes-w> they facilitate equational reasoning, sharing, etc.
06:44:03 <totom> so immutability is better in web development compared to mutability
06:44:19 <totom> I want to know a case where mutability is better
06:44:20 <dminuoso> totom: Its not about web development.
06:44:23 <maerwald> ertes-w: mutability is not the problem, the lack of rules wrt mutability is
06:44:35 <dminuoso> totom: mutability has its benefits in achieving maximum performance.
06:46:02 * hackage flow 1.0.10 - Write more understandable Haskell.  https://hackage.haskell.org/package/flow-1.0.10 (fozworth)
06:46:03 <totom> dminuoso: I am asking specifically for web development
06:46:16 <Psybur> totom, web development has many layers
06:46:46 <metalrain_> I guess question is which algorithms have abysmal performance using immutable instead of mutable data structures
06:46:55 <dminuoso> totom: The facets of immutability/mutability have little to do with factors that are related to web development.
06:47:00 <dminuoso> totom: You are asking the wrong question.
06:47:19 <xenon-> hi. how can I export 1) module I imported 2) everything I defined in the module that is exporting #1
06:47:48 <totom> dminuoso: I was asking because Redux is marketed as immutable and thus better. So i thought about asking
06:47:56 <ertes-w> maerwald: mutability is a problem for equational reasoning
06:48:26 <maerwald> *shrug*
06:48:33 <ertes-w> now you need temporal logic, and things get very complicated very quickly
06:48:47 <MarcelineVQ> xenon-: examine the export list here for examples https://hackage.haskell.org/package/megaparsec-6.3.0/docs/src/Text-Megaparsec.html
06:49:24 <xenon-> MarcelineVQ they are specifying identifiers they are exporting from their own module. I was hoping I can avoid that and export everything plus the imported module
06:49:30 <ertes-w> totom: i'd put it this way: in web dev immutability will probably be least of your performance worries
06:49:33 <hexagoxel> xenon-: module A (module A, module B) where import qualified module B
06:49:41 <xenon-> ah
06:49:43 <xenon-> nice thanks
06:49:53 <hexagoxel> oh, probably not qualified
06:50:01 <hexagoxel> but you get the idea
06:50:18 <xenon-> yes. I knew about module B, I didn't know it also applies to current module
06:50:20 <maerwald> ertes-w: temporal logic for what?
06:50:20 <ertes-w> totom: but it's a massive win when it comes to concurrency, and web applications are usually very concurrent
06:50:38 <ertes-w> maerwald: if you want to do equational reasoning
06:50:44 <maerwald> *shrug*
06:52:05 <mnoonan> metalrain_: if you have some mutation-based algorithm, you can always simulate memory with a map. That adds an O(log n) factor to the complexity at worst.
06:52:30 <ertes-w> maerwald: for example this is equational reasoning: "(Map k a) is a monoid"
06:53:01 <maerwald> I wasn't arguing about equational reasoning
06:53:24 <Psybur> (fromList [(1,1),(2,2)]) `mappend` (fromList [(1,2),(3,3)])
06:53:27 <ertes-w> maerwald: couldn't tell…  your statement was too general =)
06:53:30 <Psybur> > (fromList [(1,1),(2,2)]) `mappend` (fromList [(1,2),(3,3)])
06:53:32 <maerwald> I was arguing that mutability is not a problem if it's constraint with rules
06:53:33 <lambdabot>  error:
06:53:33 <lambdabot>      • Couldn't match expected type ‘(Integer, Integer)’
06:53:33 <lambdabot>                    with actual type ‘Item a0’
06:53:33 <maerwald> see rust
06:53:55 <xenon-> you can also write mutation-based algorithm in haskell that does the actual mutation. it is usually not needed though
06:53:57 <Psybur> :t fromList
06:53:57 <maerwald> immutability is not the only solution to the problem
06:53:58 <lambdabot> IsList l => [Item l] -> l
06:54:04 <maerwald> but people tend to believe it
06:54:16 <Psybur> > (Data.Map.fromList [(1,1),(2,2)]) `mappend` (Data.Map.fromList [(1,2),(3,3)])
06:54:19 <lambdabot>  fromList [(1,1),(2,2),(3,3)]
06:54:19 <ertes-w> maerwald: as soon as there is mutability the statement "(Map k a) is a monoid" becomes very dubious at best
06:54:32 <maerwald> I don't care about the monoid :>
06:55:07 <ertes-w> replace "monoid" by any other structure that is defined in terms of functions and equations
06:55:27 <maerwald> again: I wasn't talking about equational reasoning
06:56:24 <ertes-w> well, if you see no value in equational reasoning, then i suppose you could be more accepting toward mutability
06:56:55 <maerwald> also, Go development is so boring that I have to IRC in parallel, otherwise my brain switches off
06:57:36 * hackage autoexporter 1.1.3 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-1.1.3 (fozworth)
06:57:43 <xenon-> after using cabal sandboxes for a long time stack is like a breath of fresh air. having to recompile large libraries like gtk or lens each time you start a new project was extremely annoying
06:57:58 <merijn> xenon-: new-build gets rid off that, though
06:58:07 <merijn> xenon-: I'd say sandboxes are pretty much dead at this point
06:58:33 <xenon-> merijn huh, really? I just switched like a month ago
06:58:48 <maerwald> xenon-: because stack people don't tell you about new-build :P
06:58:59 <merijn> xenon-: new-build is nice, if a bit rough at the edges
06:59:13 <fakenullie> http://lpaste.net/360969 profile shows that v takes 960kb. Why so much?
06:59:13 <maerwald> cabal still doesn't handle GHC versions though
06:59:32 <xenon-> wait, I read that wrong. I know sandboxes are dead, for some reason I thought stack was (and that new-build superseeded it)
07:00:18 <merijn> xenon-: Basically, new-build is the intended future replacement of "cabal build", it's inspired by Nix, so each package is tagged by the hash of all it's dependencies. Which allows multiple conflicting versions of the same package to be installed without issue (and reusing previously compiled versions)
07:00:42 <merijn> xenon-: So, it's like every package is always build in a sandbox, except the sandbox is actually shared between everything
07:00:45 <ertes-w> fakenullie: my guess is that because 'l' is a CAF
07:00:50 <xenon-> merijn stack does the same does it not? what are the pros and cons of new-build vs stack?
07:00:58 <maerwald> stack handles ghc versions
07:00:59 <ertes-w> fakenullie: write 'l' as a local definition of 'v' (or just write it inline)
07:01:10 <maerwald> but then again, it's stack :>
07:01:41 <merijn> xenon-: Stack basically says "there's only one version allowed of each package" and publishes snapshots that are just large lists of specific version that work together
07:02:04 <merijn> xenon-: I don't really know the pros/cons of stack too well, since it's workflow just rubs me the wrong way
07:02:09 <fakenullie> ertes-w: http://lpaste.net/360970 l is 160 kb, I tried inline, it was same size
07:02:09 <ertes-w> xenon-: new-build is more comparable to nix, while stack is more comparable to fancy sandboxes
07:02:13 <merijn> xenon-: So I haven't really used stack
07:02:26 <xenon-> what does new-build do? it allows different versions of each package to be used at once?
07:02:33 <xenon-> at the same time
07:02:52 <xenon-> i can't imagine how that would work
07:03:05 <merijn> xenon-: new-build makes sure that multiple versions of the same package can be installed without conflicting. It only allows a single version per project, though
07:03:09 <fakenullie> ertes-w: with l inline it's 2560 kb
07:03:25 <ertes-w> xenon-: new-build is not a sandbox system…  if you want to understand how new-build works, learn how nix works
07:03:31 <merijn> xenon-: It just means if you build package foo with version X.Y of a package and build bar with version Z.A, then it doesn't complain about the package already exists
07:03:39 <xenon-> I have a vague idea how nix works
07:04:01 <xenon-> merijn I see
07:04:04 <ertes-w> fakenullie: that's weird…  perhaps the problem lies in how you interpret the numbers, but honestly i've never used profiling
07:04:41 <merijn> xenon-: Basically, IF cabal-install can find a dependency set that doesn't conflict for a project, the project will built and will NOT be affected by packages installed for other projects
07:04:41 <ertes-w> fakenullie: but there is no doubt in my mind that the code is actually fine in terms of memory use, as long as 'l' is not a CAF
07:05:21 <fakenullie> ertes-w: well, it was exercise to find out how unboxed vector is more efficient in memory usage
07:05:42 <fakenullie> or maybe boxed vector is optimized
07:05:53 <ertes-w> fakenullie: unboxed vector of Int8/Word8 does what you would assume it does:  one byte per element
07:05:56 <xenon-> merijn I think I got it
07:06:30 <merijn> xenon-: new-build also allows easily specifying local depencies (like add-source in sandboxes)
07:06:45 <ertes-w> fakenullie: the only (that is to say: stupid) odd Unbox instance is Bool
07:06:52 <ertes-w> fakenullie: the only odd (that is to say: stupid) Unbox instance is Bool
07:07:06 <ertes-w> Bool uses one byte per element
07:07:23 <xenon-> merijn the lack of add-source equivalent in stack was annoying. I had to write my own script that generates stack.yaml to avoid having to edit it manually for each project
07:07:32 * hackage json-feed 0.0.3 - JSON Feed  https://hackage.haskell.org/package/json-feed-0.0.3 (fozworth)
07:07:59 <merijn> xenon-: new-build introduces a cabal.project file that lets you specify dependencies like that, which makes working with repos that have multiple packages a breeze
07:08:11 <merijn> xenon-: https://github.com/merijn/broadcast-chan/blob/master/cabal.project
07:09:11 <merijn> xenon-: That basically selects the cabal file in each subdirectory and adds them as local dependencies, so it's like an "automatic" add-source for those packages, so that my repo check-out always uses the versions from the repo, rather than hackage
07:09:48 <xenon-> from what I understand stack guarantees that my code will be compilable in the future, since it controls both version of the ghc and version of each package. how does new-build compare in that regard?
07:10:08 <merijn> xenon-: new-build (like cabal) will just use whatever GHC is first in your path
07:10:40 <merijn> xenon-: GHC's package DB has always been per-version, so switching GHC version is just a matter of changing which is first on your path
07:12:19 * hackage datadog 0.2.0.0 - Datadog client for Haskell. Supports both the HTTP API and StatsD.  https://hackage.haskell.org/package/datadog-0.2.0.0 (dfithian)
07:14:19 * hackage derulo 0.0.4 - Parse and render JSON simply.  https://hackage.haskell.org/package/derulo-0.0.4 (fozworth)
07:14:25 <hexagoxel> atm reproducible builds are worse with new-build than with sandboxes even, as current new-freeze is not feature-complete yet.
07:15:07 <hoon> code critique? http://lpaste.net/360949 -- it's not done, just working out parsing of some command line args
07:17:15 <merijn> hoon: I would probably use optparse-applicative for command line arg parsing
07:17:30 <merijn> GetOpt is...very basic
07:17:41 <hoon> haha...damnit!
07:17:43 <hoon> :D
07:18:17 <hoon> well, let's just say for the sake of discussion I'm stuck with getOpt
07:19:55 * hackage github-release 1.1.1 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.1.1 (fozworth)
07:20:24 * hackage ekg-elasticsearch 0.4.0.0 - Push metrics to elasticsearch  https://hackage.haskell.org/package/ekg-elasticsearch-0.4.0.0 (boothead)
07:21:44 <merijn> hoon: tbh, I'm too busy debugging the optparsing of my C++ to have a deeper look than that, sorry :)
07:22:21 <hexagoxel> hoon: you could write `parseVarOpt` like `parseVarOpt flags = case [ s | Var s <- flags ] of ..`
07:22:56 <hexagoxel> same for parseFileOpt
07:24:29 <marvin3> can someone please recommend me a PDF reading library? something that just extract text from PDF would be good enough, I could do the rest with text parsing library
07:28:05 <[exa]> marvin3: reading stuff out from PDFs is brutal tbh
07:28:19 <[exa]> marvin3: I'd suggest something from ghostscript
07:28:50 <marvin3> do you mean convert PDF to ghostscript, then read ghostscript? becaues I can't control the format of the input file
07:29:00 <hoon> merijn: no worries!
07:29:07 <[exa]> no, ghostscript is the program (postscript is the format)
07:29:35 <hoon> hexagoxel: interesting approach
07:29:54 <marvin3> uh right
07:30:12 <xenon-> what is the state of qt bindings for haskell?
07:30:38 <xenon-> did it catch up to gtk bindings, or should I just stick to gtk for now?
07:34:40 <Eduard_Munteanu> marvin3, see pdftotext or pdftohtml
07:34:52 <Eduard_Munteanu> I think they're in Ghostscript.
07:36:38 <ertes-w> merijn: honestly i prefer getopt over optparse-applicative most of the time
07:36:48 <merijn> ertes-w: Why's that?
07:37:08 <ertes-w> merijn: it's simpler and covers 90% of my use cases
07:37:18 <ertes-w> less code, less dependencies, less initial investment
07:38:42 <fommil> where can I find the Order instance for xht's XNode? Since the ADT models XmlTrees in a rose tree, I assume there must be one around? But I can't see it in the source file linked from the docs
07:40:04 <ertes-w> fommil: assuming that you mean Ord as far as i see there is no Ord instance
07:40:24 <ertes-w> neither is there an Order instance, just in case
07:40:36 <ertes-w> fommil: oh, and assuming that you mean hxt
07:40:55 <fommil> ah, yes Ord. Is Order a different thing?
07:41:41 <fommil> ertes-w: then how can NTree accept it?
07:42:11 <ertes-w> fommil: i'm not familiar with Order
07:42:48 <ertes-w> fommil: i see no reason why NTree couldn't accept it
07:43:06 <steveGUIs> Quick questions
07:43:08 <steveGUIs> What GUIs of Haskell programs or libs would you like to see so that you are convinced that its a good approach to GUIs?
07:43:38 <steveGUIs> People seemed interested in my GUI papers but entirely unconvinced that it scales to real-world requirements
07:43:47 <steveGUIs> Thanks for any ideas
07:44:27 <fommil> ertes-w: doesn't NTree require an Ord? Or does it use insertion order?
07:44:50 <ertes-w> steveGUIs: an sqlite frontend =)
07:45:19 <[exa]> steveGUIs: can you link the papers? :]
07:45:41 <ertes-w> (one that doesn't suck, which means that i can interact with it using my keyboard)
07:46:13 <ertes-w> fommil: i'm not familiar enough with hxt, but i see no inherent reason why XNode would require Ord
07:46:37 <fommil> ertes-w: it's described as an "ordered tree" http://hackage.haskell.org/package/hxt-9.3.1.16/docs/Data-Tree-NTree-TypeDefs.html#t:NTrees
07:46:47 <fommil> I don't see how it could support unordered elements
07:47:16 <fommil> it's just a rose tree
07:47:19 <ertes-w> fommil: the "ordered" part probably refers to it being a rose tree
07:48:08 <ertes-w> fommil: if the elements were supposed to be ordered in some way, then there would be no Functor and Traversable instances
07:48:10 <fommil> ertes-w: ok, so "hierarchical" is maybe a better word here
07:48:27 <fommil> ertes-w: ok, cool. I can work with that.
07:48:56 <fommil> ertes-w: I'm porting this ADT to scala and scalaz has a rose tree so we should be good there with a straight drop-in.
07:51:34 <ertes-w> fommil: XmlTree feels like a really weird type to represent XML
07:52:31 <fommil> ertes-w: yeah, think more about it I might just use a list... I'm not porting the full ADT just a subset that's relevant to me
07:52:40 <ertes-w> NTree (XCmt "blah") []  -- what does this represent?
07:53:00 <fommil> I think they went with NTree because comments can show up anywhere
07:53:25 <fommil> bit of a weird choice that attribute values are children of the parent tree
07:53:30 <girlbeach> I just post some hot pictures on www.triphile.com ,I am an IT girl from Asia
07:55:24 <ertes-w> fommil: better use these types: https://hackage.haskell.org/package/xml-conduit-1.7.0/docs/Text-XML.html
07:55:42 * hackage github-release 1.1.2 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.1.2 (fozworth)
07:55:53 <ertes-w> fommil: they model XML more closely and also support namespaces
07:56:04 <fommil> ertes-w: :looking:
07:56:35 <ertes-w> (i'd go as far as to say: avoid hxt altogether)
07:56:56 <ertes-w> (at least until they get rid of that arrow non-sense)
07:57:16 <joebetz> how do I use `catch` inside ReaderT m IO?
07:59:16 <fommil> ertes-w: sweet, that is much closer to what I ended up carving out of the hxt adt.
08:08:30 * hackage json-feed 0.0.6 - JSON Feed  https://hackage.haskell.org/package/json-feed-0.0.6 (fozworth)
08:10:02 * hackage lackey 0.4.7 - Generate Ruby clients from Servant APIs.  https://hackage.haskell.org/package/lackey-0.4.7 (fozworth)
08:12:26 * hackage friday-juicypixels 0.1.2.3 - Converts between the Friday and JuicyPixels image types  https://hackage.haskell.org/package/friday-juicypixels-0.1.2.3 (k_bx)
08:13:58 <ertes-w> joebetz: three options in decreasing order of difficulty: 1. switch to (m -> IO a) and just use 'catch', 2. use Control.Monad.Catch from 'exceptions', 3. use Control.Exception.Lifted from 'monad-control'
08:14:10 <ertes-w> err
08:14:15 <ertes-w> s/decreasing/increasing/
08:18:34 <gypsydave5> OK - funny question - is there a name for the function that would take an Either, a predicate on the Left type, and a Right type to return if the predicate failed? So it conditionally turns a Left to a Right?
08:20:21 <ertes-w> :t \p -> either (\x -> maybe (Left x) Right (p x)) Right
08:20:22 <lambdabot> (t -> Maybe b) -> Either t b -> Either t b
08:20:28 <ertes-w> gypsydave5: like this?
08:20:29 <harpoforsh> Anyone else having problems running stack build on a fresh (stack new) project? I get "didn't see Yampa ... in your package indices"
08:21:36 <gypsydave5> more like (and I'm scratching around here)
08:22:12 <kadoban> harpoforsh: Doesn't sound familiar. Can you lpaste the whole output? And you haven't changed from the template code at all?
08:24:02 <gypsydave5> Actually, having reread that ertes-w, it looks perfect
08:24:07 <joebetz> ertes-w: which is considered best practice? option 2 seemed the straightforward to me, so I went with that. and it works, so yay. and I didn't like option 1 because it reifies what Reader is and degrades the information in the type signature.
08:24:21 <mnoonan> harpoforsh: recently stack switched to using hpack, so you'll edit your package.yaml instead of myproject.cabal
08:24:42 <mnoonan> not sure if that would explain what you are seeing, but it is something to keep in mind
08:24:45 <harpoforsh> mnoonan, kadoban: it seems upstream just fixed the problem.
08:24:54 <harpoforsh> thx
08:24:54 <gypsydave5> (given that we're switching on the Maybe b)
08:25:34 <kadoban> Alright, cool.
08:26:18 <ertes-w> joebetz: i'd go with option 1
08:27:04 <ertes-w> joebetz: in my opinion ReaderT is an anti-pattern
08:29:54 <dmwit> :t flip either Right
08:29:56 <lambdabot> (a1 -> Either a2 b) -> Either a1 b -> Either a2 b
08:30:40 <joebetz> joebetz: funny, because it's one of the first haskell "design patterns" I learned :]
08:30:44 <joebetz> https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
08:31:04 * hackage ratel 0.3.8 - Notify Honeybadger about exceptions.  https://hackage.haskell.org/package/ratel-0.3.8 (fozworth)
08:31:48 <MarcelineVQ> joebetz: https://pbs.twimg.com/media/C8QejJ1VoAAQgDE.jpg:large :>
08:32:09 <joebetz> lmao
08:32:26 <fakenullie> @pl \p -> either (\x -> maybe (Left x) Right (p x)) Right
08:32:26 <lambdabot> flip either Right . ap (flip maybe Right . Left)
08:32:28 <yohotchoc> I think you meant to reply to ertes-w there, joebetz
08:32:29 <joebetz> hmmm
08:32:30 <MarcelineVQ> funny and useful
08:32:36 <ertes-w> joebetz: that picture explains perfectly what i think of ReaderT =)
08:32:38 <yohotchoc> or maybe you're arguing with yourself :D
08:32:46 <joebetz> yohotchoc: haha, yeah
08:33:08 <ertes-w> joebetz: the usual justification for using it is that it helps passing information implicitly, but the disadvantages far outweigh this minor advantage, and the advantage actually turns into a disadvantage in many cases
08:33:24 <merijn> ertes-w: I like ReaderT for infrequently accessed things, since it lets you avoid writing out the extra parameter everywhere for nothing
08:34:03 <dmwit> Instead you get to write `liftIO` everywhere for nothing!
08:34:19 <ertes-w> merijn: i think that's not a valid argument…  if a top-level definition needs the argument, it has to refer to it anyway, and if it doesn't need it, it shouldn't be a function in the first place
08:34:30 <merijn> dmwit: Not if you isolate the IO to small sections and lift it there
08:34:40 <ertes-w> merijn: and in local definitions you can just refer to the top-level argument
08:35:16 <joebetz> ertes-w: aren't you doing the same thing in the case of Config -> IO a? it's just a different representation of the implicit information, right?
08:35:36 <ertes-w> joebetz: exactly
08:35:46 <ertes-w> joebetz: but i can just use 'catch' directly
08:35:59 <ertes-w> moreover i can write functions that actually only take stuff they need
08:36:22 <joebetz> I see
08:36:25 <ertes-w> "Config" is usually a rather large value, and most functions only need a small part of it…  giving them the whole Config is counterproductive
08:37:20 <gypsydave5> dmwit: I like that version
08:37:44 <joebetz> dmwit: yeah, I got annoyed with that pretty quickly. but then, isn't this a general problem with monad stacks, and not particular to ReaderT?
08:38:03 <hexagoxel> no. the counterproductive thing is optimizing for the minimal set of values to pass, when you could just pass Config. So much unnecessary refactoring when one of your bottom functions turns out to need some unexpected value.
08:38:34 <ertes-w> joebetz: it's a problem of how people use monad transformers…  "application monads" are popular
08:39:14 <Psybur> ertes-w, happen to blog about this?
08:39:14 <ezyang> I think the point is, like anything, reader monads let you setup an abstraction barrier (what Config is available at a point), so you need to actually think about it, if you want to setup the barrier
08:39:15 <ertes-w> hexagoxel: i don't *optimise* for that…  i write it like that from the beginning
08:39:24 <ertes-w> Psybur: no(t yet) =)
08:39:54 <merijn> ertes-w: That assumes you never change your mind/alter your design
08:40:45 <hexagoxel> ertes-w: do it is not premature optimization because you do it from the start?
08:40:48 <ertes-w> merijn: no, it assumes that changing my mind can involve refactoring
08:40:52 <hexagoxel> so*
08:40:57 * hackage salve 0.0.10 - Semantic version numbers and constraints.  https://hackage.haskell.org/package/salve-0.0.10 (fozworth)
08:41:04 <merijn> ertes-w: Then you clearly change your mind a lot less often than me
08:41:45 <ertes-w> hexagoxel: i take the bottom-up approach to application development, so it's not an optimisation…  at the time when i write (f :: PartOfConfig -> IO a), Config may not yet exist
08:41:49 <merijn> ertes-w: I've changed the design like 10+ times in a single day before. I'd rather not refactor each
08:42:04 <merijn> ertes-w: That only works if you know what the bottom will/should look like
08:42:16 <mnoonan> dmwit: speaking of anti-patterns, iirc some of Galois' code on github makes extensive use of implicit parameters. what's up with that?
08:42:37 <ertes-w> merijn: indeed, i rarely need to do that in practice
08:42:53 <joebetz> I think I prefer having access to the configuration space by default, since that means everything is trivially configurable
08:43:00 <ertes-w> in any case, it's not overly bad to pass full Config around
08:43:15 <merijn> ertes-w: So why dictate "your way" is right and others are wrong, just because you happen to work on problems where you have the luxury to know most/all of your design in advance
08:43:31 <ertes-w> my point from earlier was mainly against ReaderT, not against passing full Config around
08:43:33 <merijn> ertes-w: This kinda dogma is what gets us in these stupid "methodology" cults in programming...
08:44:30 <ertes-w> merijn: let me rephrase then
08:44:38 <dmwit> mnoonan: Dunno! I didn't write it or know about it, so I hadn't discussed it with the authors.
08:44:56 <dmwit> mnoonan: I'm not sure I would class implicit parameters as an anti-pattern, though.
08:45:15 <ertes-w> there are some disadvantages to giving functions the whole Config value, when they only need a fraction of it, especially in cases where you *know* they will never need the full Config
08:45:18 <joebetz> how to do top-down vs bottom-up in haskell would be an interesting blog post. I never thought haskell had the ergnomics for the later ...
08:45:30 <joebetz> *latter
08:45:47 <mnoonan> dmwit: I wish I could remember what project I was looking at. It just suprised me because (1) I'd never seen it in the wild before, and (2) dynamic variables are the bane of my existence in Common Lisp
08:45:48 <mnoonan>  (even though I kind of enjoy the weird tricks you can do with them)
08:46:00 * hackage ratel-wai 0.3.2 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-0.3.2 (fozworth)
08:46:01 <ertes-w> i don't think passing full Config everywhere is necessarily bad design…  my point from earlier was mainly about ReaderT
08:46:39 <dmwit> mnoonan: I mean, they're not really dynamic variables. They're just another argument. It just so happens that if your dependencies need the same argument they can get it automatically.
08:46:55 * hackage strive 4.0.2 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-4.0.2 (fozworth)
08:47:15 <hexagoxel> well, and in my opinion, ReaderT is generally not an antipattern. it is not the same as implicit params, because the type signature properly documents these parameters. and passing explicitly is just redundancy.
08:47:21 <joebetz> although arguably, with the REPL still being the most useful development tool, and it being better suited for bottom-up, I'm not surprised that people do it that way
08:47:24 <merijn> ertes-w: ReaderT means being able to dump something use the config arbitrarily deep in the hierarchy without worrying about modifying each function between the top and the call site to pass the parameter
08:47:30 <mnoonan> dmwit: hmm. maybe without mutability the difference isn't so big, I guess.
08:47:34 <hexagoxel> of course ReaderT can be misused and overused, but that does not make it an antipattern.
08:48:09 <merijn> ertes-w: You say, "well, you shouldn't do that". I say, "I've got shit to do besides refactoring my function parameters 15 times a day"
08:48:39 <ertes-w> merijn: again, i consider that argument invalid, because you only ever need to refer to the argument from the top level
08:49:08 <ertes-w> it's "f x = … x …" vs. "c = … x <- get …"
08:49:42 <dmwit> This is why I always just write `config = unsafePerformIO (newIORef def)` and call it a day.
08:49:51 <ezyang> if your code is monadic already, a reader monad makes sense
08:49:59 <ertes-w> ezyang: why?
08:49:59 <hexagoxel> ertes-w: and i find the arguments against ReaderT unconvincing, because you seem to focus on some case where you have only one top-level function.
08:50:37 <merijn> ertes-w: My code is 90% do blocks since I'm doing IO/database/networking
08:50:59 <merijn> ertes-w: So I never use "get"
08:51:20 <merijn> I have compound actions taking the config for logging/output/sql and I wanna dump those in at random points
08:51:32 <ezyang> ertes-w: It seems like a reasonably robust abstraction that works pretty well (at least in GHC)
08:51:45 <ezyang> and in Cabal we don't have a reader monad and we regret it every day
08:52:03 <ezyang> tbf, I never actually use ReaderT to implement my monads, but...
08:52:11 <merijn> ertes-w: So it's not "f x = ... x ..." vs "c = ... x <- get ..." it's "foo = do ... myAction ..." (which maybe several calls deep)
08:52:31 <merijn> ertes-w: So now I suddenly have to change every one of the intermediate calls to work
08:52:43 <ezyang> and if you ever want to embed your app, unsafePerformIO (newIORef) is really bad juju
08:52:54 <ezyang> (once again, speaking from GHC experience)
08:53:11 <ertes-w> alright, i'm outnumbered, and this discussion is really not that interesting…  let's leave it at that: i abandoned ReaderT at some point when i got really tired of writing liftIO and using MonadCatch/MonadBaseControl, and my code got simpler since =)
08:53:29 <merijn> anyhoo, gym time!
08:53:33 <ertes-w> if your experience is different, good for you, keep using it =)
08:53:51 <sm> I'm with you ertes-w !
08:55:31 <Guest66849> hey, anybody got a suggestion which command line argument library to use? I find the basic System.Environment variant too basic and am looking for a good alternative and I stumbled upon https://wiki.haskell.org/Command_line_option_parsers but as pretty often the case I can't really tell which one to choose / which is recommended / which is dead
08:55:44 <michalrus> Hey! Can I somehow putStrLn in a Tasty test and have it output in an appropriate place?
08:56:01 <michalrus> Guest66849: optparse-applicative ♥
08:56:10 <michalrus> Definitely this one.
08:56:14 <Guest66849> thanks :-)
08:56:51 <ertes-w> Guest66849: in simple cases i tend to use System.Console.GetOpt, which comes with the base library
08:57:03 <ertes-w> Guest66849: in more complex cases optparse-applicative
08:57:43 <Guest66849> I'll look into both but I guess it's rather a more complex case
09:03:55 * hackage wuss 1.1.6 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.6 (fozworth)
09:05:49 * hackage strive 4.0.3 - A client for the Strava V3 API.  https://hackage.haskell.org/package/strive-4.0.3 (fozworth)
09:09:50 <hexagoxel> (.oO there would be no out-numbering and us vs. them if this was more than opinions and personal experience reports.)
09:10:21 <hexagoxel> (and the discussion was not too interesting for the same reason.)
09:48:21 * hackage judy 0.4.0 - Fast, scalable, mutable dynamic arrays, maps and hashes  https://hackage.haskell.org/package/judy-0.4.0 (MarkWotton)
09:49:34 <Philonous> Is there a library/tool that generates Haskell code from a swagger file?
09:49:51 <Philonous> (Possibly some TH)
09:49:53 <JazzyEagle> Hello, all.  I'm having issues with -fPIC errors when compiling on Arch.  I've been doing tons of searching and found a workable manual workaround (changing the ghc settings file within ~/.stack/...).  I was wondering if anyone has a way to configure the flag within stack.yaml of the project, so others who use my same project do not need to do the same manual workaround on Arch?
09:50:01 <JazzyEagle> Or perhaps in the .cabal file?
09:50:38 <Philonous> JazzyEagle, Try ghc-build: ncurses6 in ~/.stack/config.yaml
09:51:06 <Philonous> And then run stack build --install-ghc
09:51:13 <monochrom> Other users may be not on Arch and may actually need the negation of -fPIC.
09:52:03 <JazzyEagle> Philonous: That still would be a manual fix, though, as that's at a global level, not a project level.
09:52:07 <Philonous> JazzyEagle, Sorry, I misunderstood the question. I don't know of a way to make it per-package
09:52:10 <JazzyEagle> monochrom: I take it there are no conditionals in either file?
09:52:20 <monochrom> I don't know stack.
09:52:28 <yohotchoc> not afaik JazzyEagle
09:52:32 <monochrom> And this is progressing towards an XY problem.
09:52:45 <JazzyEagle> XY problem?
09:53:01 <monochrom> A special form in which an author tries to make user-end choices.
09:53:53 <dmwit> Is there even a good way to know whether -fPIC is right or not?
09:53:58 <geekosaur> nope
09:54:06 <geekosaur> which is why this does not belong in the project
09:54:09 <dmwit> If there is no good way to know, it is not important whether stack offers conditionals.
09:54:12 <JazzyEagle> Got it.  I'm not thrilled on the fact, either, but we've had an issue logged and we're trying to figure out how to mitigate it.
09:54:42 <geekosaur> you will in fact break either debian 6 or debian 7 builds depending on which choice you make (because the Arch failure is related to that)
09:54:46 <JazzyEagle> dmwit: The only way I know is when I get an error when attempting to compile.  I don't know enough about PIE to know when it is and is not needed.
09:54:52 <yohotchoc> generally, assume your users aren't on arch (speaking as an arch user)
09:55:06 <yohotchoc> PIE is a security feature that happens not to play well with stack on arch
09:55:09 <monochrom> Outside Arch: turn off -fPIC if you're doing static linking, turn on -fPIC if you're doing dynamic linking. Inside Arch: Well they're hostile to static linking anyway.
09:55:32 <yohotchoc> yeah, stack just generally hasn't been playing well with arch
09:55:38 <geekosaur> it doesn't play on Arch at all, it's something debian 7 does and has an updated/patched binutils to support. arch doesn't have the patches
09:55:55 <JazzyEagle> Soemone else recommended uninstalling EVERYTHING haskell related on Arch and only installing Stack and using Stack exclusively.  I could try, but not sure how I would access xmonad that way...
09:56:07 <Philonous> yohotchoc, Besides having to change this one line in my global stack config I haven't had any problems
09:56:10 <yohotchoc> that's what I ended up doing JazzyEagle, but I don't have that xmonad issue
09:56:19 <yohotchoc> Philonous: yeah, that's the issue
09:56:27 <yohotchoc> it just took me a long time to figure out the issue and fix
09:56:36 <cocreature> geekosaur: are you sure about that? I thought these problems started because arch has changed the default flags to include pic/pie?
09:56:37 <geekosaur> meanwhile debian 7 both enabled PIe by default and upgraded ot ncurses 6, which is why stack gets confused on Arch which updated to ncurses 6 but not PIE support. but its available ghcs are from Debian and combine the two
09:56:43 <geekosaur> cocreature, backwards
09:56:46 <Philonous> JazzyEagle, You can install xmonad via stack without problems
09:56:48 <geekosaur> debian 7 went default PIE
09:56:53 <JazzyEagle> Maybe we'll just need to document that, as making a change to a setting within a settings file in ~/.stack is easier than telling them to navigate down to the ghc's instance of settings file.
09:56:54 <geekosaur> debian 7 also upgraded to ncurses 6
09:57:06 <monochrom> I recommend uninstalling both arch packages and stack. Use www.haskell.org/ghc's GHC and use cabal-install, exclusively.
09:57:17 <yohotchoc> that sounds dreadful
09:57:18 <geekosaur> when stack sees ncurses 6 it picks the ghc that supports ncurses 6... ,which also defaults to PIE, but Arch doesn;t have the patched binutils that supports PIE
09:57:36 <JazzyEagle> Philonous: Yeah, no doubt on that. I just didn't realize (until about 15 seconds ago) how to access xmonad in the x call.  I don't know why I didn't realize how much of a dummy I've been before.
09:57:46 <Philonous> JazzyEagle, The point is, which ghc build you want is a property of you system, not the project, so it shouldn't be part of the project
09:57:51 <JazzyEagle> Still, I can't expect others to do the same thing, so I think the settings file is the way to go.
09:57:57 <yohotchoc> geekosaur: is there some technical reasoning for that do you know, or does it just not support PIE because it doesn't?
09:58:26 <Philonous> JazzyEagle, People running arch will have to fix it anyway
09:58:32 <geekosaur> patches aren't upstream yet. but also, PIE is a *distribution* level choice and changes a lot of things, not just binutils
09:58:48 <geekosaur> you cannot simply start using PIE executables on a system that does not have support for them
09:59:14 <geekosaur> requires specific kernel config options, specifc glibc config options, specific bintuls version and probably config options, ...
09:59:23 <Philonous> JazzyEagle, And I mean, tbf it's Arch. If you're running Arch you should expect to get your hands dirty every now and then .
09:59:24 <JazzyEagle> Philonous: That's what I'm coming to terms with, so it now comes down to us documenting the solution within the project's build documentation.
09:59:25 <yohotchoc> makes sense yeah, not the simplest change
09:59:55 <JazzyEagle> Philonous: Yeah, true.
10:00:00 <monochrom> I thought hands-dirty meant Slackware or Gentoo.
10:00:19 * JazzyEagle just remembers when he started with Arch and felt in over his head for a few months...
10:00:48 <cocreature> geekosaur: interesting, so what exactly does https://git.archlinux.org/svntogit/packages.git/commit/trunk?h=packages/gcc&id=5936710c764016ce306f9cb975056e5b7605a65b do? I thought that enable pie by default on arch
10:01:07 <monochrom> Oh yeah why haven't we got "Hi I'm on Slackware how do I install Haskell?" for years? :)
10:01:26 <geekosaur> (still loading it, sorry slow net) it might be the last step of it
10:01:41 <geekosaur> you might go look at debian's PIE migration document for an overview of everything involved
10:01:52 <geekosaur> and I do mean *involved*
10:03:21 <geekosaur> right, that just sets a system build flag that enables a bunch of support everywhere else
10:03:42 <monochrom> geekosaur: Didn't you wrote a note on Arch's dynamic linking on the web?
10:03:45 <geekosaur> random programs do not come with arch's '--enable-system-build-pie' automatically built in
10:04:33 <geekosaur> monochrom, yes. it's not talking abotu this, it's talking about their removing all the static libs
10:04:35 <cocreature> sure but I thought it affected at least everything built on arch (unless you explicitely opt out) which includes all packages in the official repos
10:04:45 <monochrom> Yes, I have that in mind.
10:05:33 <geekosaur> cocreature, ... you are sitll assuming everything knows specifically about that automatically, and that the things in question do not include (a) kernel (b) glibc (c) binutils (d) all the packages cited in the Debian migration document that needed patches to support PIE ...
10:05:34 <cocreature> it’s embarrassing how little I know about linkers :/
10:05:49 <JazzyEagle> Philonous: I think I did something wrong with your recommendation on ~/.stack/config.yaml.  I got the following error:  "No information found for ghc-8.2.2" ...
10:06:05 <JazzyEagle> It appears ghc 8.0.2 works with ncurses6, but not 8.2.2?
10:06:06 <geekosaur> also, when you are building a *distribution*, you have control over all of this. you do *not* have control over what e.g. stack does.
10:06:11 <JazzyEagle> Any ideas?
10:06:14 <geekosaur> unless you want to rewrite it
10:06:40 <Philonous> JazzyEagle, Sorry, haven't tried LTS 10 yet
10:06:55 <geekosaur> annd force users to only use your distribution's version of stack and just outright break if someone selfupgrades stack or installs it not from the arch repo
10:07:09 <JazzyEagle> Ok, let me dial it back to lts-9.x and see what happens.
10:07:12 <cocreature> geekosaur: ah I think I got it (at least somewhat), thanks!
10:07:46 <cocreature> JazzyEagle: what worked for me is install ncurses5-compat-libs from the AUR and set "ghc-build: nopie" in ~/.stack/config.yaml
10:07:57 <geekosaur> (or likewise for stack installing ghc)
10:08:11 <Philonous> cocreature, Does that work with lts 10?
10:08:29 <JazzyEagle> I'll try that option as well using lts-10.0, after this test with lts-9.20
10:08:34 <cocreature> Philonous: I’m fairly sure I tested that earlier today so I’ll claim it does :)
10:08:35 <JazzyEagle> Thanks!
10:09:17 <geekosaur> lts version should not impact this unless ghc-8.2.2 has a bug
10:09:28 <Philonous> cocreature, OK, nice, thanks. Although I'm loath to depend on AUR for my build system to work.
10:10:00 <geekosaur> convince ghc hq to provide ghc builds specifically for arch instead of debian
10:10:05 <fiatjaf> I'm very happy. I have a super simple webapp working in haskell. gone from no-nothing to this in a week.
10:10:09 <fiatjaf> now how do I deploy it?
10:10:15 <geekosaur> or arch to pull ncurses5 compat libs into the main repo
10:10:18 <cocreature> geekosaur: the lts version affects the ghc release and there is no bindist for 8.2.2 which corresponds to "ghc-build: ncurses6"
10:10:21 <fiatjaf> is there a super simple automatic way?
10:10:51 <cocreature> Philonous: make a bindist for 8.2.2 and contribute it, iirc I contributed the existing bindists that you are using if you set "ghc-build: ncurses6"
10:11:27 <monochrom> Wait, I though GHC has -no-pie
10:11:51 <monochrom> Oh, ncurses version. Nevermind.
10:11:56 <Philonous> cocreature, I might at that when I find some time.
10:12:01 <JazzyEagle> fiatjaf: The guy who administers the website I'm helping with likes keter atm.  You may want to look at that.
10:12:35 <fiatjaf> Welcome to Keter, a market leader in quality plastic home and outdoor storage solutions.
10:12:44 <cocreature> fiatjaf: I usually build a docker image using either stack’s docker support or nix and then deploy that
10:13:07 <fiatjaf> my stack.yaml is just like it was at the beggining
10:13:22 <fiatjaf> I've added dependencies to the .cabal file
10:13:27 <fiatjaf> is that a problem?
10:13:42 <fiatjaf> stack didn't complain about that, it has actually liked it
10:13:59 <JazzyEagle> fiatjaf: https://hackage.haskell.org/package/keter
10:15:06 <JazzyEagle> The second half of the page gets into what it is and how you use it.
10:15:58 <JazzyEagle> Ok, I forgot 9.18 required a lot of additional extra-deps in stack.yaml, so before I go adding all those back in, I'm going to try cocreature's recommendation w/ lts-10.0
10:16:57 <sm> fiatjaf: the super simple way is build it on your web server, and start it running
10:20:14 <JazzyEagle> It appears cocreature's recommendation of ncurses5-compat-libs and ghc-build: nopie is working.  Packages that were causing errors before are building.
10:20:39 <JazzyEagle> I want to wait for the project to finish compiling completely, though, before declaring that solution a total win.  :)
10:20:51 <fakenullie> arch?
10:21:53 <JazzyEagle> fakenullie: Yep.
10:22:42 <JazzyEagle> Well, Parabola, *technically*, but it's easier for me to just to tell everyone Arch.  The solutions are almost always the exac same.
10:22:51 <JazzyEagle> As was in this case.  :)
10:23:11 <fakenullie> blasphemer
10:25:36 <JazzyEagle> lmao  Yep.  :)
10:40:21 <jle`> is there a nic way to write foldMap toList
10:40:24 <jle`> :t foldMap toList
10:40:26 <lambdabot> error:
10:40:26 <lambdabot>     Ambiguous occurrence ‘toList’
10:40:26 <lambdabot>     It could refer to either ‘F.toList’,
10:40:34 <jle`> :t foldMap F.toList
10:40:36 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [a]
10:40:46 <jle`> hm
10:40:55 <jle`> :t F.toList . F.toList
10:40:57 <lambdabot> Foldable t => t a -> [a]
10:41:12 <jle`> i'm stumped
10:41:28 <Psybur> Whats wrong with what you did?
10:41:38 <jle`> foldMap f.toList is fine
10:41:44 <Gurkenglas> :t toListOf (folded . folded) -- jle`
10:41:45 <lambdabot> (Foldable f2, Foldable f1) => f1 (f2 a) -> [a]
10:41:59 <jle`> hmmm
10:42:01 <geekosaur> guessing the wrong toList
10:42:14 <Psybur> :t L.toList
10:42:16 <lambdabot> error:
10:42:16 <lambdabot>     Not in scope: ‘L.toList’
10:42:16 <lambdabot>     Perhaps you meant one of these:
10:42:35 <jle`> :t (^.. folded . folded)
10:42:37 <lambdabot> (Foldable f2, Foldable f1) => f1 (f2 a) -> [a]
10:43:03 <jle`> catepiller operator
10:43:25 <Psybur> :t mconcat . map
10:43:26 <lambdabot> error:
10:43:26 <lambdabot>     • Couldn't match type ‘[a] -> [b]’ with ‘[c]’
10:43:26 <lambdabot>       Expected type: (a -> b) -> [c]
10:43:48 <jle`> :t (foldMap . foldMap) (:[])
10:43:50 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [a]
10:44:08 <jle`> i'm probably going to just stick with foldMap toList
10:44:15 <Psybur> Why isnt that 'nice'
10:44:30 <jle`> maybe i should have said "another nice way" :)
10:44:38 <jle`> i don't know, it's not obvious at first what it's doing
10:45:14 <Psybur> :t mconcat . map (:[])
10:45:15 <jle`> (foldMap . foldMap) (:[]) conveys the meaning well i think, but it's a bit verbose
10:45:16 <lambdabot> [a] -> [a]
10:46:11 <jle`> (foldMap . foldMap) (:[]) is clearly like, get all of the items in nested foldables as a list
10:46:26 <jle`> and you can extend it to more levels easily too
10:46:43 <Psybur> I dunno foldMap toList is pretty clear to me
10:47:09 <jle`> maybe it's clearer if i use type applications
10:47:15 <jle`> foldMap @Vector (toList @Maybe)
10:47:20 <Psybur> Ive been haskellin since september so relatively new. If you want to use me as a readability linter Im fine with that :D?
10:47:57 <jle`> :D
10:50:10 <Average-user> jle`: How did you find day 20?
10:50:25 <jle`> i spent 80% of the time writing a parser
10:50:29 <jle`> :'(
10:50:36 <jle`> then i eralized how i could have done it much simpler
10:50:46 <Psybur> I gave up on day 3 pt 2 :D
10:51:17 <Average-user> jle`: and what about day19?
10:51:36 <Psybur> I couldnt think of anything better than checking corners in the layer beneath the current layer, etc D:
10:51:42 <jle`> Average-user: my parser went from a 25-line megaparsec work of art to a few lines of words/read/split
10:52:03 <Average-user> jle`: Hhahaha
10:52:20 <Average-user> Psybur: In part A or B?
10:52:24 <Psybur> pt 2
10:52:35 <jle`> the actual programming part of day 20 was simple because numeric simulation is a part of my background
10:53:00 <jle`> Psybur: Day 3 is disproportionately hard compared to the ones around it
10:53:02 <fiatjaf> that looks much better than I initially thought. thanks JazzyEagle.
10:53:14 <Psybur> Part A was interesting generating the spiral structure and then tedious to track which layer youre in, how far from the middle of the side your on etc
10:53:16 <JazzyEagle> yw
10:53:45 <Psybur> Part B i can immediately see a way to modify part 1 but it just seems so tedious heh
10:53:48 <Average-user> Psybur: In fact, I did part A with numbers, and part B generating the spiral
10:54:06 <Mins> Hello. I don't know what's wrong: http://lpaste.net/8094040219214413824  ...I need to make a subclass "EQ" of "Num". But it don't work.
10:54:42 <jle`> Psybur: day 3 was pretty hard compared to the ones around it https://i.redd.it/ix00lva8nw401.png
10:55:03 <jle`> Psybur: day 4 is like a Haskell Hello World in comparison :)
10:56:07 <Average-user> jle`: I thought that too, but I realized that with manage of directions and recursion it wasn't that hard
10:56:24 <Average-user> Psybur: yhea
10:56:30 <Gurkenglas> Mins, you'll need to define myMult in the instances too. btw "x === y = floor x == floor y"
10:56:44 <jle`> Average-user: Day 19 was also pretty fun
10:56:51 <Gurkenglas> Actually I'm not sure you have to define those too, hm. What's the error?
10:56:53 <dmwit> :t (==) `on` floor
10:56:55 <lambdabot> RealFrac a => a -> a -> Bool
10:57:03 <jle`> Average-user: i got to utilize esoteric techniques from a 2 year old blog post i wrote
10:57:05 <Psybur> Average-user, did you determine where corners were in the lower layer?
10:57:14 <dmwit> :t floor -- what
10:57:16 <lambdabot> (Integral b, RealFrac a) => a -> b
10:57:19 <Average-user> jle`: I liked it too, mainly because was good for prolog
10:57:24 <dmwit> Oh, defaulting.
10:57:28 <jle`> Psybur: i just manually moved it one step at a time
10:57:33 <Psybur> heh
10:57:42 <jle`> Psybur: tried caluclating corners at first but then i just moved through the spiral step by step
10:57:48 <Average-user> Psybur: In part B I did the same that jle`
10:58:01 <Mins> Gurkenglas: My teacher wants Infix.
10:58:02 <jle`> Average-user: yeah my solution is kinda prolog-esque, i can see how it'd be fun
10:58:05 <Gurkenglas> Mins, try a minimal pragma as seen in http://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.Foldable.html#Foldable ?
10:58:18 <Gurkenglas> Mins, infix means x === y, prefix means (===) x y
10:58:25 <jle`> it was basically a graph search
10:58:30 <jle`> with constraints
10:58:36 <Mins> Oops.
10:58:50 <Mins> Makes sense Gurkenglas.
10:59:22 <Average-user> part B of day19 was free
10:59:35 <jle`> Mins: by the way, `if b then True else False` is just `b`
10:59:42 <jle`> Average-user: yeah i was kind of disappointed
10:59:54 <jle`> Average-user: but it took me a bit because i was scared of an off-by-one error
10:59:58 <jle`> and i did have one at first
11:00:11 <Mins> jle & Gurkenglas: Yes, but in Double I need to give out x == y -> False, else True
11:00:14 <jle`> so i overreacted instead of just waiting a minute to try again
11:00:19 <Mins> So... "not b"!
11:00:23 <jle`> Mins: :D
11:00:29 <Average-user> jle`: I was kind of disappointed too, but I also had sleep
11:00:31 <dmwit> Mins: Yes, or use `(/=)` instead of `(==)`.
11:00:51 <jle`> Average-user: you can sleep after christmas
11:01:11 <jle`> 18 was definitely a fun one though
11:01:39 <Average-user> jle`: light me
11:01:42 <Mins> jle`, Gurkenglas, dmwit: I get a "Haskell 98 does not support tag classes". So... Haskell can't do it?
11:01:48 <Average-user> jle`: I don't remeber it hahah
11:02:00 <jle`> i mean at first i was frustrated that it was yet another problem simulating a virtual machine, heh
11:02:11 <dmwit> Mins: "tag classes"? What's the code look like now?
11:02:12 <Average-user> jle`: Ohh that one
11:02:15 <jle`> which isn't my favorite type of problems
11:02:30 <fiatjaf> can I make stack generate a stack.yaml file from a .cabal file?
11:02:37 <jle`> fiatjaf: stack init
11:02:46 <Mins> http://lpaste.net/8094040219214413824
11:02:48 <Mins> @dmwit
11:02:48 <lambdabot> Unknown command, try @list
11:02:55 <Average-user> jle`: I didn't like it, but part B was challenging for me, I had a bug for like 1 hour, that I was reading the queue list backwards
11:02:57 <Mins> ...dmwit
11:03:11 <jle`> Average-user: my bug was that i was returning the number of things that the first program sent
11:03:13 <jle`> instead of "Program 1"
11:03:24 <fiatjaf> whoa. thanks, jle.
11:03:24 <dmwit> Mins: Could not reproduce. That code loads fine here.
11:03:46 <jle`> Average-user: it was fun because i got to apply some free monadish code to read a program into an AST that could then be interpreted in two different ways
11:03:54 <Average-user> jle`: Yhe, I almost do that
11:03:59 <Mins> Do I need the "a" after "Num" in "class Num a => EQ a where"
11:04:01 <Mins> ?
11:04:04 <dmwit> yes
11:04:34 <Average-user> jle`: waht is AST?
11:04:47 <jle`> Average-user: abstract syntax tree, but i'm not sure that's the right word
11:05:23 <jle`> Average-user: are you familiar with the free monad interpreter pattern
11:05:47 <Mins> dmwit: So... you say it works? We need to use Hugs, but I still get the error "ERROR file:.\Aufgabe_6.hs:1 - Haskell 98 does not support tag classes"
11:05:56 <Average-user> jle` no
11:06:08 <dmwit> Mins: Are you sure you are trying to load exactly the same code as you pasted at http://lpaste.net/8094040219214413824 ?
11:06:28 <Mins> Yes, wait... I'll copy it again
11:06:44 <jle`> Average-user: ah yeah, the interpreter pattern is something like this http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
11:07:01 <dmwit> Mins: This is going to sound stupid, but: have you definitely saved? Are you definitely loading the same file you are editing?
11:07:13 <jle`> Average-user: where you represent a program using an ADT that encodes actions and continuations
11:07:21 <Mins> Yes, I saved
11:07:24 <Average-user> jle`: I know little about monads to be honest.
11:07:40 <jle`> Average-user: and so you basically defer the actual execution of those actions and how to interpret them
11:07:47 <jle`> Average-user: you just build an ADT encoding them
11:07:51 <Mins> And I see I deleted the first "a" after the Num, because in the example of the teacher there is no variable befor "=>"
11:08:02 <Mins> It compiles now.
11:08:15 <jle`> Average-user: and then once you have that, you can feed the same ADT value to two different interpreters
11:08:31 <jle`> Average-user: each will pattern match on the constructors and interpret them differently
11:08:40 <Average-user> jle`: Like a finger tree?
11:09:06 <dmwit> Mins: The teacher's example probably just has a typo, then.
11:09:21 <jle`> Average-user: you can sort of think of it like a tree, where each layer's constructor encodes a different action.  so interpretation is just drilling down that tree
11:09:28 <Mins> Three examples with the same typo? I'll ask her tomorrow. btw: ERROR - Unresolved overloading *** Type       : EQ a => Bool *** Expression : 3 === 4
11:09:48 <jle`> Average-user: in the case of Day 18, the actual "program" has two actions: Snd and Rcv
11:09:59 <dmwit> Mins: You need to say whether `3` (or `4`) is a `Double` or a `Float`, so it knows whether to use `(==)` or `(/=)`. ;-)
11:10:14 <dmwit> Mins: e.g. `3 === (4 :: Double)`
11:10:17 <Mins> Ah.
11:10:20 <jle`> and so if you interpret your input as a program that can Snd and Rcv, and have Snd and Rcv as just two constructors of a data type
11:10:29 <jle`> Average-user: you can use the same Snd/Rcv program in two different ways
11:10:33 <Average-user> jle`: and set?
11:11:08 <jle`> Set/Jmp/etc. are a part of the internal logic of the program, not actual external actions
11:11:23 <jle`> those are "pure" actions, so to speak
11:11:28 <Mins> It works, thanks dmwit, Gurkenglas and jle`!
11:11:38 <Average-user> jle`: got it
11:11:51 <dmwit> Gurkenglas++ jle`++
11:11:59 <jle`> if you consider an analogy like an (a -> IO b)... the set/jmp/etc are a part of the (a -> b) pure logic
11:12:08 <jle`> and the Snd/Rcv is the external "IO" analogy
11:12:15 <Average-user> jle`: I'll have a look on your solution
11:12:28 <Average-user> jle`: Is already on github?
11:12:57 <jle`> yeah, but no formal writeup yet
11:13:10 <jle`> some short comments on the functions though :)
11:13:29 <Average-user> jle`: you commit "prep for day 20" on day21.hs :)
11:14:11 <jle`> oh yeah i just added in Day 21 because i had a few seconds to spare heh
11:14:26 <Average-user> jle`: hehe
11:16:00 <Average-user> jle`: I haven't done almost any commentaries on my repo, I should add them befora I foreget how my solutions work.
11:16:18 <jle`> it can help :)
11:17:18 <Average-user> jle`: indeed, and knowing that some of my solutions are quite cryptic, I have more reasons to do it
11:18:48 <Average-user> jle`: the other day, watching your streaming, I saw that you were visiting AoCs website inseide your editor
11:19:03 <Average-user> jle`: How do you do that?
11:21:13 <jle`> oh i use ssh + tmux to do everything
11:21:19 <jle`> so i just use a terminal app on a separate tmux window
11:21:58 <Average-user> jle`: and vi right?
11:22:51 <yohotchoc> it makes me happy that AoC's site looks very similar in a text based browser :D
11:23:57 <fiatjaf> where do I specify "cabal-version"?
11:23:58 <jle`> Average-user: mhm, vim + tmux panes for letting you have a console in the same window too
11:26:54 <fiatjaf> jle`, `stack init` just created an empty stack.yaml, not taking in account any of the packages specified in the cabal file
11:27:07 <cocreature> fiatjaf: you can add a cabal-version field to your *.cabal file but I’m not sure if that’s what you mean
11:27:08 <jle`> fiatjaf: stack.yaml only lists packages if they are not in the resolver
11:28:06 <jle`> fiatjaf: stack.yaml isn't meant to replace your cabal file, it just specifies the resolver and where to find any packages that aren't a part of the resolver
11:29:05 <cocreature> I like to think of it as stack.yaml specifying which packages are available and where they come from while the *.cabal file specifies which packages your package depends on and other metadata
11:32:09 <Psybur> If I were to make an IRC client with a GUI using haskell, would FRP be beneficial?
11:33:50 <geekosaur> depends
11:33:52 <[exa]> Psybur: depends on the interface complexity
11:34:03 <geekosaur> there are a few FRP frameworks for that, but also non-FRP frameworks
11:34:18 <fiatjaf> cocreature: that solved it
11:34:34 <Psybur> How complex can an irc client get? heh
11:34:47 <Mins> New question... I need to transponate matrix... It works, but I don't get the first line. http://lpaste.net/8094040219214413824
11:35:07 <Psybur> :t transpose
11:35:08 <lambdabot> [[a]] -> [[a]]
11:35:26 <fiatjaf> jle`, hmm, thanks. I got an error from the stack heroku buildpack and thought it was because of that, but apparently it was something else.
11:35:27 <Psybur> Mins, you dont understand the signature?
11:35:40 <Psybur> tans takes a list of lists and returns a list of lists
11:35:40 <Mins> Yes.
11:35:46 <Average-user> Mins: you use 'x' twice
11:35:48 <geekosaur> Mins, first off it's not a real matrix, since Haskell lists are singly linked lists not vectors
11:36:08 <Mins> I know geekosaur
11:36:35 <jle`> Psybur: it might help but it'll take a fair deal of upfront work to get it to the point wher eit'll be beneficial, i think
11:36:54 <geekosaur> [[a]] -> [[a]] means it takes list of list of some item type a, and produces the same. you need to specify both lists in the type to operate on both of them, which transpose needs to do
11:37:13 <geekosaur> if you only said [a] -> [a] then you couldn't do anything with the next level
11:37:22 <Average-user> why not: trans xs = [reverse x | x<-xs]
11:37:22 <Average-user>  
11:37:30 <geekosaur> because you can;t see inside "a", you just know it's a thing of some kind
11:37:53 <Mins> geekosaur: I know. I've handled it the same way.
11:38:04 <Mins> http://lpaste.net/8094040219214413824
11:38:04 <geekosaur> so what is confusing here?
11:38:16 <Mins> I need to write the function. Homework.
11:38:22 <Psybur> > trans (x:xs) = [reverse x | x<-xs]
11:38:22 <Psybur> ; trans [[1,2,3],[4,5,6]]
11:38:25 <lambdabot>  <hint>:1:14: error:
11:38:25 <lambdabot>      parse error on input ‘=’
11:38:25 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:38:26 <geekosaur> yes, I have that up. you said the first line confused you and ther are only 2 lines...
11:38:30 <Mins> trans [[1,2,3],[4,5,6],[7,8,9]] ~> [[6,5,4],[9,8,7]]
11:38:32 <Psybur> > trans (x:xs) = [reverse x | x<-xs]; trans [[1,2,3],[4,5,6]]
11:38:34 <lambdabot>  <hint>:1:14: error:
11:38:34 <lambdabot>      parse error on input ‘=’
11:38:34 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:38:44 <Psybur> > let trans (x:xs) = [reverse x | x<-xs]; trans [[1,2,3],[4,5,6]]
11:38:46 <lambdabot>  <hint>:1:64: error:
11:38:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:38:49 <Psybur> Blargh
11:38:51 <geekosaur> the ; needs to be in
11:39:01 <geekosaur> > let trans (x:xs) = [reverse x | x<-xs] in trans [[1,2,3],[4,5,6]]
11:39:03 <lambdabot>  [[6,5,4]]
11:39:07 <Average-user> let trans (_:xs) = [reverse x | x <- xs]
11:39:14 <geekosaur> "> " takes expressions not definitions
11:39:22 <Mins> Thank you Average-user. Got the "you use the x twice"
11:39:28 <Psybur> > let trans xs = [reverse x | x<-xs] in trans [[1,2,3],[4,5,6]]
11:39:28 <Mins> It works now.
11:39:30 <lambdabot>  [[3,2,1],[6,5,4]]
11:40:12 <Psybur> > transpose [[1,2,3],[4,5,6]
11:40:15 <lambdabot>  <hint>:1:27: error:
11:40:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:40:18 <Psybur> > transpose [[1,2,3],[4,5,6]]
11:40:21 <lambdabot>  [[1,4],[2,5],[3,6]]
11:40:30 <Psybur> Mins, your transpose function is wrong still :D?
11:40:35 <Mins> No Psybur
11:40:35 <[exa]> Mins: why would you reverse the thing?
11:40:52 <jbeep> Can anyone point me to a simple (but correct) explanation of parser combinators?
11:40:59 <Average-user> > let trans = map reverse  in trans [[1,2,3], [4,5,6]]
11:41:02 <lambdabot>  [[3,2,1],[6,5,4]]
11:41:41 <[exa]> Mins: anyway, try to define it recursively using `heads=map head` `tails = map tail`
11:41:48 <Mins> Oh. [exa] you're right. It's not how to transpose a matrix.
11:42:06 <Average-user> Mins: why not use 'map reverse'?
11:42:13 <Psybur> @source transpose
11:42:13 <lambdabot> Unknown command, try @list
11:42:18 <Psybur> @src transpose
11:42:18 <lambdabot> transpose []             = []
11:42:18 <lambdabot> transpose ([]   : xss)   = transpose xss
11:42:18 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
11:43:00 <Psybur> gnarly
11:43:03 <[exa]> yep
11:43:16 <Average-user> > (transpose . transpose) [[1,2,3], [4,5,6]]
11:43:18 <lambdabot>  [[1,2,3],[4,5,6]]
11:43:25 <Average-user> great fot identity
11:43:35 <Average-user> for*
11:43:46 <[exa]> Mins: you might also need `all null` for checking if you should stop recursing :]
11:43:50 <fakenullie> > (transpose . transpose) [[1,2,3], [4,5,6,7]]
11:43:50 <Mins> Average-user: Because transposing isn't just reversing.
11:43:52 <lambdabot>  [[1,2,3,7],[4,5,6]]
11:44:08 <Average-user> Mins: I know, but your function was
11:44:14 <Mins> [exa]: Thank you. Got that. I didn't look up the transposing of a matrix.
11:44:14 <Mins> http://lpaste.net/8094040219214413824
11:45:01 <[exa]> Mins: great
11:45:11 <Mins> What was my function Average-user?
11:46:22 <Average-user> Mins: forget it, isn't important
11:46:42 <[exa]> Mins: you might want to try to implement that as unfold
11:47:13 <Mins> [exa] Why?
11:47:30 <[exa]> Mins: so that you don't recurse manually
11:48:11 <Mins> We need to learn the basic concepts of a programming language. I think it's okay to recurse manually.
11:48:18 <[exa]> OK :]
11:48:39 <Mins> If I have enough time after the other tasks I'll try to do it with folding.
11:48:50 <fakenullie> first implement manual recursion, then refactor into fold/unfold
11:48:59 <fakenullie> or scan
11:49:07 <Mins> scan?
11:49:20 <Average-user> fakenullie: or leave it as plain recursion
11:49:40 <Average-user> > @source scan
11:49:42 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
11:50:14 <Average-user> >@src scan
11:50:28 <Average-user> > @src scan
11:50:30 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
11:50:30 <fakenullie> it should be without >
11:50:36 <Average-user> haha
11:50:39 <Average-user> @src scan
11:50:39 <lambdabot> Source not found.
11:50:49 <fakenullie> @src scanl
11:50:49 <lambdabot> scanl f q ls = q : case ls of
11:50:49 <lambdabot>     []   -> []
11:50:49 <lambdabot>     x:xs -> scanl f (f q x) xs
11:51:22 <Average-user> :t scanl
11:51:24 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
11:52:41 <Average-user> :t scanl1
11:52:42 <lambdabot> (a -> a -> a) -> [a] -> [a]
11:53:25 <newbie> ciaooo
11:53:30 <newbie> !list
11:55:49 <[exa]> Mins: anyway -- transpose = unfoldr (\m -> (heads m, tails m) `nothingIf` any null m)
11:56:48 <Psybur> > let transpose = unfoldr (\m -> (heads m, tails m) `nothingIf` any null m) in transpose [[1,2,3],[4,5,6]]
11:56:51 <lambdabot>  error:
11:56:51 <lambdabot>      • Variable not in scope: heads :: [t a1] -> a0
11:56:51 <lambdabot>      • Perhaps you meant one of these:
11:56:54 <Average-user> fakenullie: I dont use scanl almost never, most of the time it can be replaced with just map
11:57:20 <fakenullie> Average-user: yeah
11:58:17 <[exa]> Psybur: head/tails = map head/tail; nothingIf a b = if b then Nothing else a
11:59:09 <Psybur> :t tails
11:59:11 <lambdabot> [a] -> [[a]]
11:59:16 <Psybur> :t map head
11:59:18 <lambdabot> [[b]] -> [b]
11:59:27 <Psybur> :t map tail
11:59:29 <lambdabot> [[a]] -> [[a]]
11:59:38 <[exa]> oh, there is different meaning of tails in standard lib
11:59:50 * [exa] punishes self
12:00:50 <yohotchoc> nothing like a bit of auto-flagellation to get the day going
12:01:54 <Psybur> prefer a bit of auto-fellatio
12:02:03 <kakashiAL> haskell is able to interprete code and to compile it, what would you choose in which case?
12:02:12 <jle`> [exa]: nothingIf = guard b *> a     ... ?
12:02:27 <jle`> *nothingIf a b
12:02:42 <jle`> hm i guess guard (no b)
12:02:50 <yohotchoc> kakashiAL: interpret when you're actively developing (you don't need to wait for compilation), compile otherwise (performance benefit)
12:02:54 <yohotchoc> as a very broad rule
12:03:09 <jle`> kakashiAL: ghc's "interpreted mode" these days is actually just compilation to a temporary directory
12:03:18 <jle`> there is no actual interpreted mode for ghc anymore
12:03:45 <kakashiAL> jle, yohotchoc: what sould I belive now ?:)
12:04:00 <iqubic> is there a way to run haskell, or some similar FP language, on an android tablet.
12:04:06 <yohotchoc> I was speaking in general, I'll defer to jle` on the specifics
12:04:58 <jle`> kakashiAL: some situations compilation is the only actual way to move forward, but in others it doesn't matter much either way, just convenience
12:05:11 <Mins> Undefined variable "nothingIf". Hugs doesn't have nothingIf?
12:05:12 <jle`> if it's just a one-off script then runghc is useful
12:05:20 <jle`> Mins: nothingIf doesn't exist in any standard library i think
12:05:24 <fakenullie> iqubic: there's eta-lang and ghc for android
12:05:30 <Mins> Okay
12:05:33 <geekosaur> jle`, not actually true, although you have that option with -fobject-code. the default is still to use bytecode compiled directly into memory, like TH
12:06:00 <geekosaur> but it's a different compiler and has missing features (like unboxed tuple support which will crash the runtime if you find a way to create one)
12:06:00 <jle`> geekosaur: huh i didn't realize that
12:06:10 <iqubic> fakenullie: I want to write android apps in a functional programming language.
12:07:10 <kakashiAL> jle`: okay, like a web app, if you add constantly changes in it interpreting is the way to go
12:07:36 <jle`> kakashiAL: a web app you'd probably compile
12:07:44 <jle`> anything that isn't a one-off script i'd compile
12:07:48 <kakashiAL> jle`: okay
12:08:24 <geekosaur> Mins, Hugs hasn't been updated in over a decade aside from minimal changes to keep it compiling
12:08:58 <Mins> geekosaur: I know. Because of "it's clean coded", "we want to learn the basics", etc.... I must stay at Hugs.
12:09:11 <geekosaur> then ou are stuck with a lot of older stuff
12:09:32 <Mins> geekosaur: My teacher prefers to teach Sather instead of Java, because it's "cleaner" and "more basic".
12:09:46 <cocreature> *looks up sather*
12:09:49 <geekosaur> not sure that's a bad thing tbh :)
12:09:51 <iqubic> geekosaur: why is hugs even being patched? Just drop the support and slowly people will migrate to GHC
12:10:28 <kakashiAL> jle`: where do you know what "situation" you have to compile?
12:10:37 <geekosaur> iqubic, partly for the reason Mins is using it. still a lot of college / university courses that require it. and no, profs will NOT retool their courses just because someone decided to let hugs die
12:10:44 <jle`> kakashiAL: if you're writing an application or something
12:10:48 <geekosaur> universities don't work that way
12:10:49 <jle`> kakashiAL: or a library (of course)
12:11:02 <geekosaur> open source dweebs can follow the wind. nobody else is usually in a position to do so
12:11:03 <yohotchoc> Mins: one of my lecturers used to teach Eiffel and was forced onto Java... For a short while he'd write all the Eiffel init code in comments at the start of every Java file :D
12:11:04 <jle`> kakashiAL: things that span multiple files
12:11:14 <iqubic> geekosaur: Why is it so hard to port tools from one compiler to another?
12:11:28 <geekosaur> if you have to ask that...
12:11:47 <marko> In Data.Map I read "It is only written in such a way that every node is pattern-matched only once." Why is this important?
12:11:56 <geekosaur> well. you can learn the answer by trying to do it. and then trying to keep up.
12:12:20 <Mins> :D
12:12:26 <kakashiAL> jle`: sounds like you use the interpreter just to test you units/files
12:12:29 <iqubic> geekosar: I have no idea how to begin with that.
12:12:42 <jle`> kakashiAL: it makes sense to use an interpreter to run scripts
12:13:02 <kakashiAL> jle`: is that true what I said?
12:13:17 <jle`> kakashiAL: i'd use it for more than just testing
12:13:32 <jle`> i have a haskell script that fetches some daa from the internet and updates a file i have
12:13:33 <cocreature> I never use runghc, I only use the ghci interpreter during development and compile as soon as I want to actually run programs
12:13:39 <jle`> i wouldn't compile that script
12:13:47 <kakashiAL> jle`: so where do you draw the line between a programm and a script (which also can have many files)
12:13:49 <jle`> i just leave it in my PATH and chmodd u+x it
12:14:19 <jle`> a script is a program
12:14:24 <jle`> but i'd probably draw the line between script and application
12:14:59 <jle`> if it's a multiple-file script then it's probably not feasible to runghc it
12:15:52 <kakashiAL> jle`: I guess a script in your eyes is just something that can do one thing and thats all and an application that can do more stuff and is more compplex
12:16:29 <geekosaur> the line between script and application is *really* blurry these days. but you have a number of tradeoffs: (1) performance (2) Haskell scripts force some decisions on you compilation doesn't (for example they're always using the threaded runtime; and they don't support unboxed tuples which is important in some contexts)
12:17:03 <geekosaur> but scripts are often more convenient. so, pick your tradeoffs
12:17:25 <geekosaur> (the usual "three things. pick two" bit)
12:17:50 <jle`> if it's basically a sequence of statements/actions (do this, then that) cobbled together for utility purposes then i'd all it a script, but that line is indeed blurry.
12:18:21 <iqubic> So, is there any way to write android apps in an FP lang?
12:18:27 <iqubic> testing
12:18:55 <geekosaur> there used to be a haskell on android thing. no idea what state it's currently in
12:18:58 <jle`> kakashiAL: if you cafre about performance at all then you'd probably compile
12:19:12 <geekosaur> there's (probably out of date) info on the haskell wiki
12:19:22 <jle`> but if you're just like...moving a couple of files around on your filesystem, there's no point really
12:19:27 <iqubic> Lol. I'll o look that up
12:19:29 <Psybur> iqubic, theres Eta lang
12:19:36 <jle`> i have a bunch of haskell scripts in ~/bin/
12:19:49 <iqubic> Psybur: can that be used for whole apps?
12:19:52 <Psybur> But the runtime is 18 mb without using proguard and its a bit slow
12:19:56 <jle`> that i run as interpreted scripts
12:20:06 <kakashiAL> jle`: could you name some script that you dont compile, what they do
12:20:12 <Psybur> iqubic, yes it can read in java libraries
12:20:47 <Mins> Another question... Here's my code: http://lpaste.net/8094040219214413824 ...if it's a Int, it's multiplication. If it's a vector (own class), it's doing a dot product. But... How can I test it?
12:20:55 <jle`> kakashiAL: you can use a shebang with runghc
12:21:06 <jle`> just like bash/python/perl/etc.
12:21:28 <iqubic> I don't want use an OO stuff. I just want to use FP only to write android apps.
12:21:32 <jle`> kakashiAL: you can also shebang with stack
12:21:53 <jle`> kakashiAL: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
12:22:45 <Psybur> iqubic, yeah so use Eta and import the necessary android libraries. Currently the foreign import stuff is a bit unwieldy but theyre working on an auto generator
12:22:47 <iqubic> Although if eta can read other people
12:23:04 <kakashiAL> jle`: sure but traditionaly you dont compile python/bash/perl :)
12:23:07 <iqubic> Cool. This is uncharted territory.
12:23:26 <iqubic> is Eta a different language from Haskell? Or is it like a compiler?
12:23:42 <Psybur> Eta is haskell that compiles to byte code
12:24:11 <iqubic> So I write my code in Haskell?
12:24:14 <Psybur> Yes
12:24:46 <Psybur> You can also import stuff from hackage I think (there are some compatibility issues still I believe)
12:25:12 <kakashiAL> jle`: if you agree that I dont make something wrong when I always compile I am good
12:25:19 <Psybur> iqubic, http://eta-lang.org/
12:27:33 <jle`> kakashiAL: you can never go wrong with compiling, just be sure that if you share your scripts with other people, you send the uncompiled verisons
12:27:44 <jle`> or share between your own machines
12:27:55 <jle`> i keep my utility scripts folder synced on my machines
12:29:00 <iqubic> Here is a thing I found.
12:29:06 <iqubic> https://brianmckenna.org/blog/eta_android
12:29:21 <Mins> Another question... Here's my code: http://lpaste.net/8094040219214413824 ...if it's a Int, it's multiplication. If it's a vector (own class), it's doing a dot product. But... How can I test it? I tried faktor [1,2] [2,3]::Vektor, but it gives me a error
12:31:15 <jle`> Mins: you need to give it two Vektors
12:31:19 <jle`> but [1,2] and [2,3] are liss
12:31:20 <jle`> *lists
12:31:28 <jle`> you can use your VEKTOR constructor
12:31:37 <jle`> VEKTOR :: [Int] -> Vektor
12:31:42 <jle`> this converts a list of ints into a Vektor
12:32:53 <Mins> jle`: where do I use the constructor? Right after the "data" or in the second instance? (I assume the instance?)
12:33:09 <jle`> you'd use it to construct a Vektor
12:33:18 <jle`> you want to give faktor a Vektor, right?
12:33:28 <jle`> (VEKTOR [1,2] :: Vektor)
12:33:32 <jle`> so that's something you can give to faktor
12:33:37 <jle`> since it has type Vektor
12:34:21 <jle`> there are multiple ways to create a value of type VEKTOR
12:34:25 <jle`> * a value of type Vektor
12:34:30 <jle`> the VEKTOR constructor is one way
12:34:41 <jle`> it's a handy function, [Int] -> Vektor
12:34:55 <jle`> in the end, you want to give 'faktor' a Vektor, so you need to make a Vektor somehow
12:35:13 <jle`> and VEKTOR :: [Int] -> Vektor is one way to do it.  give VEKTOR an [Int], and it'll return a Vektor
12:37:08 <Mins> I've tried, but it didn't work. I don't know where to dec. VEKTOR.
12:37:30 <jle`> Mins: here we aren't declaring it...we're just using it
12:37:51 <jle`> Mins: here's an analogy -- let's say you have a function f which requires a value of type SomeType
12:38:04 <jle`> Mins: and you have a function blah :: [Int] -> SomeType
12:38:14 <jle`> how could you call x?
12:38:20 <jle`> *f
12:38:28 <jle`> you can just do f (blah [1,2,3]), and the types line up
12:38:48 <Mins> Yes.
12:38:48 <jle`> because f :: SomeTime -> ..., and blah :: [Int] -> SomeType
12:38:57 <jle`> so blah is a function that gives youa  SomeType that you can give to f
12:39:07 <jle`> here, 'faktor' takes a Vektor.
12:39:17 <jle`> and you have a nice function, VEKTOR :: [Int] -> Vektor, that you can use
12:39:49 <Mins> But if I write "VEKTOR::[Int]->Vektor" I get "Syntax error in declaration (unexpected `::')" every I want to compile.
12:40:01 <jle`> i'm just giving you the type of VEKTOR
12:40:04 <jle`> but VEKTOR is alreayd defined
12:40:17 <jle`> you define it in line 1
12:40:25 <jle`> so it's already available for you to use
12:40:45 <Mins> Okay
12:41:14 <jle`> your line, data Vektor = VEKTOR [Int], defines a function VEKTOR :: [Int] -> Vektor
12:41:22 <Mins> Okay
12:41:25 <jle`> that's what that syntax means :)
12:41:34 <Mins> Okay...
12:41:51 <Mins> But I still don't know how I can call my function. That instance with Vektor.
12:42:18 <jle`> Mins: so, 'faktor :: Vektor -> Vektor -> Vektor', so you need to give it two Vektor's
12:42:25 <iqubic> And once you declare that, then you can use (VEKTOR [1,2,3]) to create a vektor
12:42:53 <jle`> Mins: this is analogous to the case of f :: ..., you need to give it a SomeType.
12:43:00 <Mins> Thanks!
12:43:07 <jle`> so, you can *make* a SomeType by applying the function 'blah' to a list of Int's
12:43:14 <jle`> since blah :: [Int] -> SomeType
12:43:14 <iqubic> faktor (VEKTOR [1,2,3,4]) (VEKTOR [5,6,7,8])
12:43:27 <jle`> and here, you can *make* a Vektor by applying the function VEKTOR to a list of Int's, since VEKTOR :: [Int] -> Vektor
12:43:32 <Mins> Now I got it. I misunderstood how to "make" a vector.
12:43:48 <jle`> there is more than one way to make a Vektor, the VEKTOR function is just one convenient way :)
12:43:55 <Mins> I tried it by "[1,2]::VEKTOR".
12:44:05 <jle`> yes VEKTOR is a function
12:44:10 <Mins> Okay, thanks! :)
12:44:14 <jle`> doing that would be like saying `[1,2,3] :: blah`
12:44:27 <jle`> but really, you would do `blah [1,2,3]`
12:44:38 <jle`> applying a function to a value is 'f x', not `x :: f` :)
12:47:19 * hackage ogmarkup 4.0 - A lightweight markup language for story writers  https://hackage.haskell.org/package/ogmarkup-4.0 (lethom)
12:48:33 <Mins> Yep jle`. I took my first line as a declaration.
12:56:03 <Average-user> iqubic: For android apps with FP you could use Clojure
12:59:48 <JazzyEagle> cocreature: FYI:  Your solution for the -fPIC dilemma on Arch was exactly what I needed, and I can confirm that it does in fact work with lts-10.0.  Thanks again for your help!
13:08:20 <GoorMoon`> #
13:09:56 <frerich> I don't want anyone to spoil the fun, but today's AoC puzzles are really hard for me (I just found the solution for part 1 by accident, even though my program does not work for all cases...). I wonder; is it helpful to have a function 'posAt p t' which gives the position of a particle 'p' at time 't'? I think I have that now and was hoping I could use the first derivative to figure out which particles moves the slowest, but I wonder
13:09:57 <frerich> whether this is getting me anywhere.
13:11:05 * frerich stays away from reddit etc. for now since he's afraid that he'll see a complete answer :-]
13:12:15 <jle`> frerich: yo can just have a data structure that contains the state of the system
13:12:19 <jle`> and write a function to update it
13:12:40 <jle`> once you get that it's not too bad to get the answers
13:12:56 <frerich> jle`: Yes, I hoped I could simulate it -- but then how would I know when to stop?
13:13:15 <jle`> a lot of peple are just printing out results until they stop changing
13:13:19 <frerich> jle`: I gave up on the simualtion idea because I couldn't think of a way to decide when to stop ( both fo part 1 and part 2)
13:13:30 <jle`> frerich: yeah that gave me a bit of pause too at first
13:13:52 <jle`> but if you monitor the output metrics then it isn't too hard to convince yourself that it's "obvious" when things stop changing
13:14:34 <Average-user1> jle`: My soultion is like that, make enough iterations to be sure there are no changes
13:14:53 <jle`> my first solution i just ran a "huge" number of steps and took the result as the answer, heh
13:15:05 <jle`> er, sorry if that spoils ><
13:15:07 <frerich> Tsk! ;-)
13:15:41 <jle`> i added a slightly smarter stopping condition later
13:15:53 <jle`> but it's just as arbitrary
13:16:02 <frerich> I first though it was gonna be a great problem since I like using parsec for this kind of stuff, and it sounded like an 'takeWhile blah . iterate step' kind of problem.
13:16:09 <frerich> And then I noticed I didn't know what 'blah' would be :-]
13:16:49 <jle`> yup my first solution was literally just (!! 1000) . iterate step
13:17:04 <jle`> um
13:17:16 <jle`> i feel like you were already there anyway so i hope that's not a spoiler >_>
13:17:40 <frerich> No, that's okay, I considered that hours ago but I felt that this would be a bit lame. Even if it worked, it wouldn't be a 'general' solution ;-)
13:17:46 <Average-user1> jle`: mine was 500
13:18:29 <jle`> my actual stopping condition considers the asymptotic trajectory of the particles
13:18:33 <frerich> FWIW I got the answer to part 1 by luck: my first (flawed) idea was that the particle closest to the origin would be the one which accelerates the slowest (and for slowest acceleration, sort by velocity, and for equal velocity sort by position). A nice use case for the 'Ordering' monoid. It even worked for my input.
13:18:47 <jle`> haha
13:18:49 <jle`> that worked out :)
13:19:03 <frerich> Yeah. Until a colleague gave an example where it would not work. :-}
13:19:15 <jle`> actually it is true that the particle closest to the origin in the long run is the one with the slowest magnitude of acceleration, though
13:19:29 <jle`> if you consider the asymptotic behavior
13:19:49 <jle`> as t -> infinity
13:19:50 <frerich> Yeah, but you could have two particles with the same origin and same acceleration, and yet there will be one closer than the other:
13:19:55 <frerich> p=<0,0,0>, v=<0,0,0>, a=<1,0,0>
13:19:56 <frerich> p=<0,0,0>, v=<-1,0,0>, a=<1,0,0>
13:20:16 <jle`> yeah, the first order asymptotic behavior only helps if you have no ties heh
13:20:23 <frerich> I did not consider that the velocity and acceleration is not 'in the same direction' (no idea what the proper term is)
13:20:27 <jle`> after that it's a bit more complicated i think
13:21:03 <jle`> i was lucky enough to have no ties in my data set, but some people seem to have ties apparently
13:26:25 <jle`> frerich: by the way, `head . dropWhile p . iterate step` is basically `find notP . iterate step`
13:27:03 <frerich> jle`: Ah, 'find', right! I forgot about that, thanks!
13:27:18 <jle`> no problem :) i forget about it too sometimes
13:27:32 <jle`> laziness is awesome
13:29:23 <theobromine> does anybody here have experience using haskell to program fpgas?
13:30:37 <dxtr> I should update more often. Turns out I was running stack 1.2.1
13:39:40 <frerich> So, since others here also said that they just ran the bloody particle simulation for a while and then checked which particles is the closest (or how many are left after collisions), I did the same, and got the right answer. Still, it feels a bit like cheating. :-/
13:40:08 <dmwit> frerich: For part 1 or part 2?
13:40:47 <frerich> dmwit: For both *blush*. I just couldn't figure out a 'mathy' way to just calculate the answers, or a good termination criterium (instead of hardcoding a large number of iterations).
13:41:06 <theobromine> frerich: what are you simulating?
13:41:08 <dmwit> Okay. I believe I have a "mathy" way for part 1. I am coding it up now to see if AoC agrees.
13:41:37 <Average-user1> dmwit: If it works, you should share it here
13:42:10 <theobromine> frerich: a simple rule of thumb is to compare the results you get with N iterations against the results from 2*N, and if they are within your error tolerance. otherwise, double N and try again
13:42:57 <bgamari> dolio, do you suppose we could put out a primitive release with SMP compatibility?
13:43:02 <bgamari> it would make testing 8.4 much easier
13:48:50 <dxtr> "No information found for ghc-8.2.2" hmm
13:52:36 <dxtr> https://github.com/fpco/stackage-content/pull/26 dammit
13:59:26 * hackage tasty-discover 4.1.2 - Test discovery for the tasty framework.  https://hackage.haskell.org/package/tasty-discover-4.1.2 (lwm)
14:02:17 <frerich> After submitting my solution, I'm somewhat disappointed (and sobered) to see that most people seem to have done the 'run simulation for a few hundred steps, then inspect result' idea. :-/ And those who calculated part 1 or part 2 always had some corner cases ("same acceleration for two particles" etc.) where things wouldn't work out.
14:08:13 <dmwit> frerich: Okay, I have a solution to part 1 which is "mathy" -- doesn't simulate at all, let alone for "the right number of steps", just computes the answer directly.
14:08:44 <dmwit> now reading part 2
14:08:45 <frerich> dmwit: Sounds great, I'd love to see it!
14:09:08 <kadoban> frerich: What'd they change on part 2?
14:09:11 * monochrom nominates dmwit for the Nobel physics prize for "a closed-form solution to the theory of everything" :)
14:09:58 <frerich> kadoban: In part two, particles move around and collide (and when they collide, all particles involved in the collision disappear, i.e. they don't bounce or anything). The question is how many particles will be left by the time no further collisions are possible.
14:10:08 <hoon> anyone want to take a look at my first semifunctional haskell program? http://lpaste.net/360949
14:10:26 <hoon> I feel like I'm going to wear out my welcome coming and asking for input all the time
14:10:29 <kadoban> For part 1 can't you just ... pick those with the smallest acceleration, then from those pick the ones with the smallest velocity, and then from those, pick the ones with the best position?
14:10:38 <kadoban> frerich: Oh. So they really just wanted you to simulate I guess then.
14:10:48 <dmwit> frerich: In English, whfg ebgngr nyy nppryrengvbaf gb gur svefg dhnqenag. gura fbeg va beqre bs znaunggna qvfgnapr bs nppryrengvba, gura znaunggna qvfgnapr bs irybpvgl, gura znaunggna qvfgnapr bs cbfvgvba. qbar
14:10:54 <dmwit> frerich: In code, http://lpaste.net/7189309391286304768
14:10:58 <frerich> kadoban: That won't work for e.g.
14:11:00 <frerich> p=<0,0,0>, v=<0,0,0>, a=<1,0,0>
14:11:01 <frerich> p=<0,0,0>, v=<-1,0,0>, a=<1,0,0>
14:11:10 <frerich> (where 'p' is the initial position, 'v' is the velocity and 'a' is the acceleration)
14:11:12 <k> hmm
14:11:14 <kadoban> frerich: Sorry, magnitude of velocity I guess
14:11:35 <kadoban> Hmm, I guess it matters if the velocity is the same direction of the accel or something.
14:12:04 <frerich> kadoban: What you propose was actually my first solution to part one (and it gave the right answer!) but then a colleague gave me this example, showing that it won't work in the general case. :-}
14:12:41 <kadoban> So ... the ones with the least magnitude of accel. Then from those uhm ... the ones with the minimum velocity in the direction of the accel, and then from those ... something about position.
14:12:43 <dmwit> oh err
14:12:54 <dmwit> frerich: Perhaps I also get this wrong!
14:12:55 <dmwit> ouch
14:12:57 <dmwit> yeesh
14:13:52 <kadoban> Whatever, really I'd just simulate honestly. For competitive coding that's got to be the best way at these constraints they give you.
14:13:53 <dmwit> Okay, but it is not so hard to fix.
14:14:32 <frerich> kadoban: Us guys in the office don't really do the 'competitive' part, we just use it as a fun event to try some language we like but don't really know (Haskell in my case, another guy is using Swift, another one is C++17 etc.). :-)
14:14:44 <frerich> kadoban: For simulating, I unfortunately did not figure out how to decide when to stop simulating.
14:14:59 <kadoban> Ya, understood.
14:15:28 <kadoban> I think something like ... the current best one isn't getting any worse compared to any others? Something like that. Though that's not quite enough.
14:15:30 * hackage stack 1.6.1.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.6.1.1 (borsboom)
14:16:12 <kadoban> Informally I'd just do ... the current best one hasn't changed in a while.
14:16:38 <monochrom> Oh w00t stack 1.6
14:17:05 <kadoban> There should be closed-form formulae for the positions given the rest, right? So you don't even really have to simulate, just ... get the position of all of them at various times.
14:18:14 <dmwit> kadoban: Sure, p_x(t) = p_x(0) + tv_x(0) + t(t+1)a_x
14:18:23 <dmwit> t(t+1)a_x/2, I mean
14:18:39 <kadoban> Right
14:19:59 <kadoban> So what if you ... "simulate" until none of them have any magnitude of acceleration towards the origin, no magnitude of velocity towards the origin, and then just see which one is the best? You can do the "simulation" via exponential search by time then.
14:22:58 <dmwit> oh!
14:23:10 <dmwit> I just didn't expand t(t+1) to t^2+t.
14:23:13 <dmwit> That was silly and wrong.
14:23:55 <monochrom> Um, why should that make a difference?
14:24:24 <dmwit> Because there is another t term from the velocity!
14:24:35 <dmwit> This gives the interaction between acceleration and velocity that frerich is looking for.
14:25:05 <monochrom> Hmm, I don't get it, but don't worry about me, I didn't even read the AoC question.
14:26:26 <Gurkenglas> monochrom++
14:26:48 <monochrom> Thanks. What is it for though? :)
14:27:23 <Gurkenglas> I was reading through the last ~dozen lines and thinking the things you said ^^
14:27:54 <monochrom> Heh
14:28:49 <Gurkenglas> I wonder whether the total productivity on open-source projects everywhere is going down during December 1-24
14:29:03 <dmwit> Okay, I was not clear. But it is not worth explaining, because I would be explaining the way in which I was wrong to begin with, which why would you want to know a wrong fact?
14:30:33 <Boarders> trying to learn how to use stack and was wondering if it matters what i use to locally install a pakcage
14:30:41 <Boarders> i.e. should i do stack install or cabal install
14:31:02 <Boarders> also if I want to update my package list should I do that with cabal, I couldn't find an option with stack
14:31:09 <Boarders> (sorry if these questions are dumb)
14:31:36 <kadoban> Boarders: You should essentially never have to run "cabal" anything with stack. And having to update a package list isn't usually very important in stack, though 'stack update' does exist.
14:31:44 <JazzyEagle> Boarders: My guess is that there are multiple answers.  My personal preference is to use stack for everything.
14:32:01 <JazzyEagle> I know others prefer to avoid stack and use cabal exclusively.
14:32:11 <kadoban> Boarders: Also, you don't manually install things very often in stack. You should avoid doing 'stack install somelib', it's really just for if you want it to install an *executable* that a package has.
14:32:53 <Boarders> what if I want to use some specific library?
14:33:05 <kadoban> For libraries, you either put them in you package.yaml file (blah.cabal if that doesn't exist), or for things without either you use the --package command line options
14:33:29 <kadoban> That last is mostly for like, stack ghci outside of the context of a project
14:33:37 <monochrom> Boarders: Basically every tool wants monopoly. Your linux distro wants monopoly. stack wants monopoly. cabal too (but least of the three). So if you use stack you have to drink the stack koolaid wholesale, no deviation.
14:33:55 <Boarders> ok thanks
14:35:15 <dmwit> Okay. A correction is now available at http://lpaste.net/7189309391286304768
14:35:24 <monochrom> Or at least s/have to/are much better off/
14:36:05 <monochrom> There are very advanced ways you can deviate from stack's monopoly but it's unlikely to worth your time learning.
14:36:17 <[Leary]> I haven't coded it, but I'm pretty sure I have an analytical solution. You can transform the particles to simplify the problem, then you can write d(t)^2 as a relatively simple degree 4 polynomial on the coefficients of which you can compare.
14:39:51 <Snake727> Hello?
14:40:25 <Snake727> Anyone?
14:40:42 <monochrom> How may I help you?
14:40:53 <kadoban> Snake727: There's a ton of people here. "Hello" just doesn't tend to get too many responses usually.
14:40:58 <Snake727> I'm new to irc, im looking for something
14:40:58 <Snake727> Sorry
14:41:04 <kadoban> No worries
14:41:28 <Snake727> I've heard of irc but never actually used it
14:41:47 <Snake727> Im looking for someone who might be able to help me with linux
14:42:02 <Snake727> Specifically advanced linux, hacking
14:42:12 <Snake727> Know where to look?
14:42:48 <koala_man> software exploitation and reverse engineering?
14:42:57 <monochrom> No. But there are ways you can list all channels.
14:43:44 <Snake727> Alright, im using mIRC on w10 currently, how do i list channels?
14:43:55 <Snake727> Yes Koala
14:44:14 <monochrom> I don't know mIRC but you can easily go through all menus.
14:44:24 <Snake727> I've done alot of research and come a bit, but im sti a script kiddie
14:44:30 <Snake727> How do i do it?
14:44:40 <monochrom> Click on all menu buttons?
14:44:52 <Snake727> And filter for "Hacking"?
14:45:01 <Snake727> All menus is kinda how i got here
14:49:03 <michalrus> Hmm, how to import non-alphanumeric data constructors?
14:49:24 <michalrus> import Servant.API ((:<|>))
14:49:31 <michalrus> This one doesn’t work. :]
14:49:40 <michalrus> `import Servant.API` does.
14:49:58 * hackage frisby 0.2.2 - Linear time composable parser for PEG grammars  https://hackage.haskell.org/package/frisby-0.2.2 (BenGamari)
14:50:37 <michalrus> Oh, what, import Servant.API ((:<|>)(..))
14:50:37 <fakenullie> shouldn't it be import Type(:<|>)
14:50:52 <fakenullie> oh
14:51:21 <michalrus>     Module ‘Servant.API’ does not export ‘Type(type (:<|>))’
14:51:22 <michalrus> :p
14:51:47 <Boarders> on the stack user guide it gives an example of adding a library dependency by adding it to your .cabal file, what do I add if I want to use the .yaml file
14:52:13 <Boarders> e.g. say i wanted to add the gloss package
14:53:25 <kadoban> Boarders: Pretty similar thing. The user guide is being updated at the moment to mention hpack more :)
14:54:56 <kadoban> Boarders: You add it to one (or more) of the dependencies sections in the package.yaml
15:04:52 * hackage diagrams-lib 1.4.2 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.4.2 (BrentYorgey)
15:06:47 <Boarders> kadoban: in the package part of the yaml file it gives either a directory or website in the generated text
15:07:04 <Boarders> if it were just a package do I just use the package name or?
15:08:07 <kadoban> Boarders: So, stack.yaml is distinct from the package.yaml file. They are completely different. package.yaml is a replacement for .cabal files, using a tool called hpack. If you find that confusing, you can just delete the package.yaml file and use the whatever.cabal file that should exist too.
15:08:48 <kadoban> I personally find the syntax of package.yaml a lot easier to deal with and less redundant, but it's not that big of a difference really.
15:08:52 <Boarders> ah ok, i was just being dumb
15:08:58 <Boarders> makes sense
15:09:29 <dxtr> So is there a good logging framework you guys would recommend?
15:12:18 * hackage nakadi-client 0.4.0.0 - Client library for the Nakadi Event Broker  https://hackage.haskell.org/package/nakadi-client-0.4.0.0 (mtesseract)
15:16:35 <NoCode> Hi, I'm trying to build Leksah in Ubuntu. I'm not sure where default source paths for packages. Where would they be?
15:19:23 <ph88^> NoCode, perhaps use the recommended nix option
15:27:30 * hackage zifter-cabal 0.0.0.3 - zifter-cabal  https://hackage.haskell.org/package/zifter-cabal-0.0.0.3 (Norfair)
15:29:08 * hackage zifter-google-java-format 0.0.0.1, zifter-git 0.0.0.1, zifter-hlint 0.0.0.1, zifter-hindent 0.0.0.2 (Norfair): https://qbin.io/upbev5nr
15:31:57 <artagnon> When I pass a Map to a function, under what circumstance can I expect a copy?
15:32:30 * hackage zifter-stack 0.0.0.7 - zifter-stack  https://hackage.haskell.org/package/zifter-stack-0.0.0.7 (Norfair)
15:33:23 <boj> artagnon: are you asking whether you will always get an immutable copy back?
15:33:36 <artagnon> boj: Yes.
15:34:31 <boj> yes, it will be an immutable copy. however, afaik under the hood it's not actually a full copy
15:35:04 <artagnon> Is there any literature on how it works under the hood?
15:35:58 <boj> probably on the GHC project page somewhere. not sure off the top of my head
15:41:24 <kadoban> Wouldn't it be completely batcrap insane for it to copy a Map when it doesn't change? I can't think of any reason, no matter how remote, that it would do that.
15:41:38 <boj> indeed
15:43:25 <alp> artagnon, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution is a good starting point, along with the paper linked there and http://research.microsoft.com/en-us/um/people/simonpj/papers/spineless-tagless-gmachine.ps.gz
15:44:18 <artagnon> alp: Thanks, that's what I needed.
15:50:06 <monochrom> If you do a "delete" but it ends up not deleting anything (because key not present), the current code still constructs a new path. But it is still not the whole tree; it is just one lg-n path through the tree that the attempt to delete happens to walk.
15:52:26 <monochrom> Speaking of which, you can be assured that any O(lg n) algorithm cannot possibly make an Ω(n) copy. Logically.
15:53:57 <monochrom> And oh God, GHC 8.4.1 is in alpha now.
15:54:36 <monochrom> (When Haskell Platform has just recently caught up to 8.2.2, and stack is still lagging behind even on nightly.)
15:55:43 <kadoban> monochrom: ? There's a LTS for 8.2.2 even
15:56:00 <monochrom> Oh then sorry, I'm behind the news.
15:56:04 <MarcelineVQ> dogs and cats living together
15:56:16 <monochrom> They didn't do an LTS for 8.2.1 did they?
15:56:33 <kadoban> I don't think so, I think they skipped from 8.0.2 to 8.2.2
15:56:36 <MP2E> I know the feeling, but hopefully this is just an odd spot while GHC migrates to 6 month major releases
15:56:39 <MP2E> and yep they skipped 8.2.1
15:57:08 <kadoban> There were nightlies for 8.2.1 it appears
15:57:13 <MP2E> GHC 8.2.1 was kinda buggy anyway... :v
15:57:31 <MP2E> (I really like 8.2.2 though)
16:08:13 <Profpatsch> What’s the best way to run an Alternative operation over a HashMap and filter everything out that is empty?
16:09:36 <Profpatsch> In my case Alternative a => (HashMap Text Value) -> (Value -> a b) -> a (HashMap Text b)
16:10:17 <Profpatsch> And the action is e.g. parseJSON
16:11:05 <Profpatsch> Aka I want to leave out every element of an aeson object that is not parsable, and log a warning (there’s a WriterT around it, but that inherits the Alternative from the aeson Parser)
16:23:05 <dmwit> :t \f -> asum . fmap f
16:23:07 <lambdabot> (Functor t, Alternative f, Foldable t) => (a1 -> f a2) -> t a1 -> f a2
16:23:17 <dmwit> Profpatsch: ?
16:23:43 <dmwit> Oh, not quite.
16:23:48 <dmwit> :t Alt
16:23:50 <lambdabot> forall k (f :: k -> *) (a :: k). f a -> Alt f a
16:24:22 <dmwit> :t \f -> traverse (Alt . f)
16:24:23 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> Alt f (t b)
16:25:41 <dmwit> not that =)
16:30:18 <dmwit> :t asum
16:30:20 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
16:35:52 <Profpatsch> dmwit: Yes, I suspect using the monoidal structure of HashMap is the way to go, but I’m afraid constructing singletons and mappending them is not optimized away.
16:36:50 <Profpatsch> Not sure how to build the functionality out of functions in the HashMap module.
16:37:10 <dmwit> There is `filter`.
16:38:20 <Profpatsch> dmwit: Yeah, but it’s pure.
16:38:36 <Profpatsch> Maybe I’m missing out a trivial way to make it Alternative.
16:39:30 <dmwit> :t \f -> fmap fromJust . HM.filter isJust . fmap f
16:39:31 <lambdabot> (a -> Maybe b) -> HM.HashMap k a -> HM.HashMap k b
16:40:10 <Profpatsch> dmwit: Ah, right. Just annotate that stuff.
16:40:11 <Profpatsch> Thanks.
16:40:24 <Profpatsch> Will that be optimized away?
16:42:03 <Profpatsch> dmwit: Oh, mapMaybe exists, and it has RULES converting it to the base library builder pattern over lists!
16:42:59 <Profpatsch> Of course that’s only for going through lists. Hrm.
16:43:20 <Gurkenglas> Profpatsch, http://hackage.haskell.org/package/unordered-containers-0.2.8.0/docs/Data-HashMap-Lazy.html#v:mapMaybe also for HashMaps
16:43:53 * hackage fltkhs 0.5.4.2 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.4.2 (deech)
16:44:38 <Profpatsch> Gurkenglas: Ah, but no effects possible.
16:45:39 <Gurkenglas> Profpatsch, general Alternatives do not allow checking for whether the result is empty
16:46:19 <Gurkenglas> Perhaps http://hackage.haskell.org/package/witherable-0.2/docs/Data-Witherable.html#v:wither is enough for you?
16:46:56 * hackage uri-bytestring 0.3.0.2 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.3.0.2 (MichaelXavier)
16:47:24 <Profpatsch> Gurkenglas: You mean they support <|>, but that doesn’t mean it’s possible to check whether the Alternative is empty?
16:47:41 <Profpatsch> That’s interesting, but makes sense, yeah.
16:47:58 <Profpatsch> Because e.g. parsers are often just continuations and can’t compare that.
16:48:47 <Gurkenglas> StateT s Maybe is an Alternative and you could never check whether the s -> Maybe (a, s) is const Nothing
16:48:57 <Profpatsch> whitherable looks cool.
16:49:33 <monochrom> A monadic parser is not checkable for emptiness. But there are non-monadic alternative parsers that support it.
16:50:18 <Profpatsch> I guess in my case I could just annotate with Either and then convert to real effects on the outside.
16:50:19 <monochrom> (Basically by being defined to be a record that has an "am I empty?" field, and code up <|> and <*> to set that field right.)
16:50:58 <Profpatsch> I also have the feeling that would be trivial with lens-aeson.
16:51:08 <monochrom> (Ironically this was a motivating example for Arrow!)
16:51:34 <Profpatsch> Uh, I missed the whole arrow phase and I’m glad I did.
16:51:44 <monochrom> Heh.
16:51:51 <mniip> monochrom, but
16:52:00 <mniip> that can only ever work if the type is nonrecursive
16:52:01 <mniip> er
16:52:04 <mniip> s/type/parser/
16:52:13 <MP2E> Arrow phase? :p I suppose I haven't seen them mentioned much lately...
16:52:18 <monochrom> You would be right. Everyone who reads that part of the Arrow paper concludes "this is an Applicative!"
16:52:20 <mniip> and then it's for a finite language
16:53:36 <monochrom> But the next example in the paper, modeling digital circuits and doing [Bool] -> [Bool] on them, is not an Applicative, it has to be Arrow.
16:54:06 <MarcelineVQ> or more recently a closed cartesian category
16:54:37 <mniip> cartesian closed?
16:54:40 <MarcelineVQ> or even cartesian closed category if you're into things being correct
16:54:52 <mniip> I think here a category with products is enough
16:55:26 <MarcelineVQ> circuits are in the examples of conal's recent works is what I'm getting at :> http://conal.net/papers/compiling-to-categories/
16:55:55 <monochrom> Oh just be French and say categorie closiane cartesiane
16:56:38 <Gurkenglas> Profpatsch, show your code?
16:58:51 <Profpatsch> Gurkenglas: That’s what I got so far http://lpaste.net/360992
16:59:37 <Profpatsch> Gurkenglas: Here’s the whole thing from before my change: https://github.com/Profpatsch/yarn2nix/blob/master/src/Distribution/Nodejs/Package.hs#L74
17:00:12 <Profpatsch> There’s some pretty complicated “business” logic, because the npm people don’t know how to implement a specification they themselves wrote.
17:00:42 <Profpatsch> And I have to parse all kinds of npm package.json files.
17:00:46 <monochrom> Heh that happens all the time.
17:01:21 <monochrom> I can write a perfect specification of an automatic programming robot. I have no idea how to implement it.
17:01:22 <Profpatsch> So I’m bit-by-bit achieving some kind of bug compatibility (i.e. I change the code once yet another package fails the parse).
17:02:54 <Profpatsch> monochrom: It’s not that the specification is not trivial to implement. It’s 1. the specification is shit, 2. JSON is unityped, 3. nobody cares if something doesn’t parse with npm.
17:03:52 <monochrom> Oh shitty specification. I don't do that. :)
17:03:55 <Profpatsch> Instead of just rejecting badly typed package.jsons on package upload.
17:04:52 <Profpatsch> It’s in fact the *only* thing that must exist in an npm “package”, everything else can be whatever precompiled binaries you want to distribute.
17:05:20 <Profpatsch> And not even that trivial metadata file is in any way fixed or checked according to specification.
17:05:45 <Profpatsch> It says a lot about the JS people that a piece of shit like npm is the best package manager they could come up with.
17:06:08 <kadoban> Profpatsch: Wouldn't throw too many stones. Haskell isn't exactly famous for having great stories in package management.
17:06:49 <monochrom> I the Profpatsch would throw many stones. 1000 to the JS people and 800 to the Haskell people. :)
17:07:03 <monochrom> s/I the/I think/
17:07:24 <Profpatsch> kadoban: Haskell has a frigging GREAT package management system.
17:07:31 <Profpatsch> The best I’ve seen so far.
17:07:51 <mniip> what
17:07:55 <mniip> cabal is terrible
17:07:55 <Profpatsch> I mean, people are fighting about whether or not to set /upper bounds/
17:07:58 <tabemann> people normally complain about Haskell's package system
17:08:07 <kadoban> It's now at an acceptable level, IMO. Historically it was awful though until pretty recently, relatively.
17:08:18 <Profpatsch> If that’s the biggest problem you have, then you haven’t seen *anything* yet.
17:08:37 <mniip> that's not the biggest
17:08:45 <monochrom> We have coexistence issues.
17:08:53 <tabemann> e.g. you can't delete packages, and you can't have multiple copies of the same version of the same package compiled against different things
17:09:02 <monochrom> We also have an issue interpreters don't have to worry about.
17:09:30 <mniip> there's also this thing regarding different versions of the RTS
17:09:34 <Profpatsch> Have you seen pip.
17:09:35 <monochrom> But I'm ready to believe you about the other pasture is even worse.
17:09:39 <Profpatsch> Have you seen npm.
17:10:11 <Profpatsch> npm doesn’t even try to do any kind of version resolving.
17:10:49 <monochrom> Mainly because if they don't have coexistence or inlining issues, why do they have issues at all?
17:11:19 <Profpatsch> Python packages basically are imperative, turing complete setup scripts without a story for declarative setup.
17:11:46 <MP2E> nix is my favorite package manager :p
17:11:49 <Profpatsch> OCaml doesn’t even *have* a build system. It has three and most packages use Makefiles.
17:13:06 <Profpatsch> For haskell, it is possible to convert *all of hackage* in one single conversion to nix files.
17:13:27 <Profpatsch> And that’s *because* haskell Packaging is so great.
17:14:10 <Profpatsch> The only other system that I know of with sane packaging is Rust, and they are the new kids on the block.
17:14:42 <Profpatsch> That being new doesn’t mean you get it right can be seen with golang (lol) or npm (we’r all gonna die).
17:16:46 <tabemann> when I worked in OCaml I just used apt as my package manager, and didn't bother with any language-specific packaging
17:24:14 <Wizek> Has anyone seen a stack error like this? Progress: 5/218C:\Users\Wizek\AppData\Roaming\stack\precompiled\x86_64-windows\ghc-8.0.2\1.24.2.0\Ynl0ZXN0cmluZy1idWlsZGVyLTAuMTAuOC4xLjBAc2hhMjU2OjY5ZDQ0ZWNmY2YyNDMzOTBmNTgyYTUxNTkwNWQ2MTRiMGRjNWMzMThlYWQ2MjFjYTU2NDFjZmJkMGFhNTZkZmYsMzc0Ng==\go8qIDyB7F-hE8pJXTPUBVp7a8ZpuPYLgWdMnb5Filo=: openBinaryFile: does not exist (No such file or directory)
17:24:25 <Wizek> stack 1.6.1
17:24:37 <MP2E> huh. that's one hell of a binary name
17:25:16 <monochrom> It is possible that the filename is simply too bloody long for Windows.
17:25:40 <yohotchoc> it is indeed
17:25:53 <yohotchoc> 272 chars and windows caps out at 256 for that style of path IIRC
17:26:48 <Wizek> btw, it base64-decodes to: bytestring-builder-0.10.8.1.0@sha256:69d44ecfcf243390f582a515905d614b0dc5c318ead621ca5641cfbd0aa56dff,3746(ńO)%tPi.2v)h
17:27:35 <tabemann> that looks sane until it degenerated into a bunch of boxes
17:28:09 <yohotchoc> there's a backslash in the middle that's not part of the base64
17:28:20 <yohotchoc> path separator, and the last bit doesn't seem to be valid anyway
17:29:01 <Wizek> yohotchoc: any ideas how I could work around?
17:29:18 <yohotchoc> move it up a few directories if you can
17:29:43 <yohotchoc> I think there's some way in windows to use the longer paths up to like 4k but I think that has to be supported in the program itself
17:30:49 <yohotchoc> yeah if you can move that stack folder all the way back up to C:\ the path's short enough
17:31:17 <Wizek> yohotchoc: hmm, would you know how I could ask stack to use the new path?
17:31:27 <yohotchoc> no idea, sorry
17:31:44 <yohotchoc> I'm also unsure how windows handles symlinks, but that might work?
17:34:05 <Wizek> sec, attempting this atm: https://superuser.com/questions/1119883/windows-10-enable-ntfs-long-paths-policy-option-missing
17:34:10 <Profpatsch> Gurkenglas: I think I have a solution. M.mapMaybe id <$> traverse (\e -> lift (Just <$> parseJson e) <|> W.writer (Nothing, "warningmsg")) hashMap
17:34:45 <Profpatsch> Could also use filter isJust
17:34:58 <Profpatsch> No idea if that’s fast or note.
17:35:01 <Profpatsch> *not
17:36:50 <Profpatsch> Another idea would be to accumulate a new map in a fold, (singleton <$> parseJson e <|> writer (mempty, "warning)) and foldMap over the resulting list
17:37:45 <Profpatsch> I could imagine GHC might be able to optimize that better, because foldMap over a list.
17:37:51 <yohotchoc> Wizek: that's the long path thing I was thinking of! That's the real solution here if you can get it to work
17:41:40 <erisco> sup
17:49:12 <c_wraith> list is about the worst case for foldMap
17:51:51 <mniip> are GHC RULES pragmas sophisticated enough to detect linear usage of objects?
17:52:30 <mniip> like to be able to replace a lot of sequential modify-copying with a single temporary mutable object
17:52:52 <monochrom> It does term rewriting, and probably fairly simplistic at that.
17:54:23 <mniip> right
17:54:48 <mniip> but term rewriting is enough to make up a list producer-consumer hierarchy and optimize a ton of creation/destruction away
17:54:48 <monochrom> You will be the one detecting terms that are semantically linear usage. And you will be the one telling GHC to spot these terms, syntactically, and what to rewrite to.
17:55:00 <monochrom> Yes.
17:55:02 <mniip> yeah question is, is it doable
17:55:10 <mniip> I mean I don't immediately see how to do it
17:55:23 <monochrom> I think yes. You need to identify a small set of primitives involved.
17:55:36 <mniip> I can't just have a rule that only fires when a certain identifier is not used anywhere else
17:55:44 <monochrom> You may like to study how they use RULES to achieve list fusion.
17:56:38 <mniip> I know the general idea of build/foldr
17:56:43 <monochrom> which sounds more and more relevant because list fusion is detecting a special case of linear usage.
17:56:51 <mniip> hmm
17:57:05 <mniip> well,
17:57:08 <mniip> to be clear,
17:57:28 <mniip> ah right I already said what I'm doing
17:57:48 <monochrom> Because to fuse "f . g" there is the fact that the intermediate list between f and g is unknown outside.
17:58:21 <mniip> right but like
18:20:32 <EvanR> hmm, TVar
18:21:21 <EvanR> i mean, is there a way to try an STM action with a timeout, if it doesnt succeed in so much time, return Nothing and that tells you the action did not succeed
18:22:12 <Axman6> have you had a look at Async?
18:22:30 <Axman6> That sounds familiar, I'm sure there's something like that
18:23:39 <yohotchoc> that doesn't sound to gel with how STM's supposed to work, conceptually
18:24:03 <yohotchoc> AIUI it was more about discrete stages in the values of variables as opposed to timing
18:24:24 <yohotchoc> there might be some way to fiddle with retry to prevent it from continuing past some number of retries?
18:26:04 <Axman6> you could easily do something like awaitTMVar var `orElse` do the thing` orElse` retry, which would exit if a second thread wrote to the TMVar (that's a thing right?) otherwise it would try to complete the other action, or retry if it can't. each time it retries it will be checking the timeout var first
18:26:22 <monochrom> Do you mind: race (atomically (your STM operation)) (threadDelay 10seconds) ?
18:26:32 <Axman6> also, I'm pretty sure you can just throw an exception to the thread executing the action (and async probably lets you do this)
18:27:24 <monochrom> Although, it has is only race condition, too.
18:27:33 <monochrom> s/ is / its /
18:27:42 <Axman6> yeah, the operation might still complete
18:28:12 <Axman6> you could have the last thing that happens in the operation be to check a variable for if the timeout has expired, and if it has, fail, if not return the result
18:28:50 <EvanR> yes... i know about timeout and async
18:29:14 <EvanR> and i suspect that if you just throw an exception to a thread doing an atomically, you have no idea if it completed the action or not
18:29:17 <Axman6> hmm, it'd be nice to see some more of the STM interenals of async get exposed
18:29:51 <EvanR> you have no idea if the thread was even no already dead
18:29:59 <EvanR> because it finished
18:31:26 <EvanR> timeout supposedly tells you if it was timed out or completed
18:31:41 <Axman6> how about: do timedOut <- newTVarIO False; forkIO (threadDelay n >> writeTVarIO timedOut True); atomically (do a <- operation; to <- readTVar timedOut; pure $ if to then Nothing else Just a
18:31:42 <EvanR> but i am skeptical that timed out = atomically failed
18:32:20 <EvanR> oh
18:32:28 <Axman6> but... that doesn't actually limit the runtime of the operation
18:33:23 <Axman6> but, you can I guess it should probably throwSTM or something, since you want the transaction to fail...
18:33:56 <Axman6> alwaysSucceeds might also be useful
18:35:53 <EvanR> that doesnt limit it but something else can limit it
18:36:36 * EvanR attempts to hack that into a primitive
18:39:05 <monochrom> Oh interesting there is throwSTM
18:40:32 <monochrom> But I am now fairly convinced of Axman6's plan of: (your operation) `orElse` (receive something in a fresh TVar/TMVar)
18:41:15 <monochrom> and arrange a separate thread to wait 10 seconds then send the seomthing to the fresh TVar/TMVar. This should have no race condition of significance.
18:42:13 <EvanR> i am attempting to grok that answer
18:43:19 <monochrom> Because supposedly the two branches of orElse are mutually exclusive. Only one of them is committed.
18:43:38 <EvanR> so that would work if (your operation) was not "extended in time"
18:43:50 <EvanR> because if it were, the timeout wouldnt actually work
18:44:36 <hoon> I'm stuck
18:44:51 <hoon> trying to integrate a WriterT
18:44:54 <EvanR> it would work for me but wouldnt work like timeout, which can interrupt an action
18:45:06 <hoon> I'd appreciate if someone could take a look http://lpaste.net/360949
18:45:25 <monochrom> Huh? It totally interrupts.
18:45:43 <hoon> ghci complains about writeFileBytes' type
18:47:07 <EvanR> how does it interrupt (your operation)
18:47:26 <lyxia> hoon: what is the error message
18:47:27 <EvanR> it looks like its polling the MVar every time (your operation) fails
18:47:38 <monochrom> when (receive something in a fresh TVar/TMVar) succeeds.
18:47:58 <EvanR> that doesnt run until (your operation) fails
18:48:01 <hoon> b2c.hs:97:58:
18:48:01 <hoon>     Couldn't match expected type `IO b0'
18:48:01 <hoon>                 with actual type `WriterT [Int] m0 ()'
18:48:01 <hoon>     In the expression: writeFileBytes outh inh
18:48:01 <hoon>     In the second argument of `($)', namely
18:48:02 <hoon>       `\ inh -> writeFileBytes outh inh'
18:48:04 <hoon> Failed, modules loaded: none.
18:48:15 <monochrom> No, it runs as soon as (your operation) retries.
18:48:21 <EvanR> thats what i meant
18:48:23 <lyxia> hoon: in lpaste.net next time
18:48:34 <hoon> sorry! will do
18:48:35 <EvanR> so its cooperatively being cancelled,
18:48:40 <EvanR> not preemptive
18:49:07 <EvanR> in an ideal world (?) STM actions take zero time to complete or retry but
18:49:35 <monochrom> OK then I don't know how to do it.
18:49:43 <lyxia> hoon: Do you understand the error message? What are you trying to do here?
18:50:27 <lyxia> hoon: writeFileBytes is a WriterT, what do you want to do with the list it writes?
18:50:33 <EvanR> and the other answer from Axman6 is the same. ok fine. luckily i dont need it to actually interrupt since i will be using short actions
18:50:58 <hoon> well, I think the problem is that the withFile function expects a function parameter of type (Handle -> IO r)
18:51:21 <hoon> and currently I'm giving it a function of type Handle -> WriterT blah blah blah
18:51:49 <hoon> I'm trying to keep track of the number of bytes written using the WriterT
18:51:49 <lyxia> Right.
18:52:21 <hoon> I think I could use a Sum Monoid rather than a [Int], but I'm sticking with this until it works
18:52:32 <lyxia> Sure
18:52:54 * hackage preamble 0.0.58 - Yet another prelude.  https://hackage.haskell.org/package/preamble-0.0.58 (markfine)
18:53:04 <lyxia> hoon: you can use runWriterT to convert WriterT blah IO blah to IO blahblah
18:53:07 <hoon> so... anyway, I need the function to be (Handle -> IO r) so presumably I just need to do a runWriterT as part of that
18:53:09 <hoon> ok
18:53:14 <hoon> I'm on the write page then
18:55:25 <hoon> let me poke around a bit longer
18:56:39 * lyxia gives a lambda-stick to hoon.
18:56:52 <hoon> :D
18:59:47 <EvanR> a raceSTM in async would be cool, assuming that makes any sense
19:00:10 <EvanR> attempt to atomically do two STMs in parallel, at most one succeeds
19:04:04 <lyxia> have them do their thing and then try to grab a TMVar, the one that doesn't get it cancels.
19:04:55 <EvanR> transactional reasoning rocks
19:05:18 <lyxia> I might be stuck on the "atomically" part of your assignment
19:05:41 <EvanR> like, race (atomically x) (atomically y), only working
19:07:06 <lyxia> Ah, I was thinking of atomically (race x y)
19:09:06 <Welkin> that's racist!
19:13:55 <hoon> lyxia: I got it working
19:14:06 <hoon> and it appears to do what I wanted :)
19:14:11 <hoon> thanks for the assist
19:15:36 <lyxia> yw
19:27:54 * hackage postgresql-simple-queue 1.0.1 - A PostgreSQL backed queue  https://hackage.haskell.org/package/postgresql-simple-queue-1.0.1 (JonathanFischoff)
19:44:08 <Axman6> EvanR: I like the idea of racing two threads and whichever one manages to take from a full TMvar succeeds (and possibly kills the other)
19:45:50 <hoon> lyxia: I did end up using Sum rather than [Int] for my Writer
19:45:54 <hoon> that seems to work ok
19:46:03 <hoon> seems a bit clearer to me
19:54:19 * hackage wolf 0.3.38 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.3.38 (markfine)
19:58:01 <iqubic> Can anyone see this?
19:58:21 <hoon> iqubic: yes
19:59:13 <iqubic> Cool. I'm testing a new irc set-up and its being a pain sometimes.
19:59:28 <iqubic> 80% of the time it works everytime.
20:00:46 <hoon> ha
20:16:01 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEpdxdaqe: durand ▄▄▄▄▄▄▄▄
20:16:06 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEvbtvzorc: durand ▄▄▄▄
20:16:12 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEpknmmugab: durand ▄▄▄▄▄▄▄▄
20:16:16 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEswprayv: durand ▄▄▄
20:16:21 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEpclev: durand ▄▄▄▄,
20:16:27 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEaqoqlfmcb: durand ▄▄▄▄▄▄▄▄▄▄
20:16:32 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEfkfbihavw: durand ▄▄
20:16:37 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEeouzh: durand ▄▄▄▄▄▄▄,
20:16:41 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEyheixfcdu: durand ▄▄▄▄▄
20:16:46 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEhqgtekt: durand ▄▄
20:16:52 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEswarpcnowt: durand ▄▄
20:16:56 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEdgfjor: durand ▄▄▄▄
20:17:01 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEzqiszo: durand ▄▄
20:17:07 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEjfdenele: durand ▄▄▄▄
20:17:12 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEactpegdhbu: durand ▄▄▄▄▄
20:17:17 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEblarnlwqvw: durand ▄▄▄▄
20:17:22 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEfelxi: durand ▄▄▄▄▄,
20:17:27 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEloybuvixy: durand ▄▄▄▄▄
20:17:32 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEmhbblttz: durand ▄▄▄▄▄▄▄▄▄
20:17:36 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEmarugtj: durand ▄▄▄▄▄▄▄
20:17:41 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODElqyviweb: durand ▄▄▄
20:17:46 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEtexmya: durand ▄▄▄▄▄▄
20:17:51 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEafsagifnvg: durand ▄▄▄▄▄▄▄
20:17:57 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODElwbdlujcl: durand ▄▄
20:18:01 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEthnomhjxik: durand ▄▄▄▄▄▄▄▄▄
20:18:04 <saurabhnanda> what's this spam about?
20:18:06 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEqulzovv: durand ▄▄▄▄▄▄▄
20:18:11 <saurabhnanda> can someone please ban this?
20:18:12 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODErwzvsvfbrc: durand ▄
20:18:14 <mniip> emerson:
20:18:16 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEqnano: durand ▄▄▄▄▄,
20:18:21 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEpancc: durand ▄,
20:18:25 <kadoban> dmwit: glguy: dolio: ^ !ops
20:18:27 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEdccmosv: durand
20:18:29 <jle`> @where ops
20:18:30 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
20:18:32 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEdhifgkdwbf: durand ▄▄▄▄▄▄▄▄
20:18:36 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEwghllrukm: durand ▄▄▄▄▄▄▄▄
20:18:42 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEvyeqln: durand ▄▄▄▄
20:18:47 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEktmzibem: durand ▄▄▄▄▄▄▄▄▄
20:18:51 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEuhfscn: durand ▄▄▄▄▄▄▄▄▄
20:18:56 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEvmkaoyznyn: durand ▄▄▄▄▄▄▄▄
20:19:01 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEafnlaxdgf: durand
20:19:07 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEiciful: durand ▄▄
20:19:11 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEzitmumjf: durand
20:19:17 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEwjxnpk: durand
20:19:17 <saurabhnanda> @dibblego would be up & about?
20:19:18 <lambdabot> Unknown command, try @list
20:19:22 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEskyybtny: durand ▄▄▄▄
20:19:22 <saurabhnanda> dibblego: would be up & about?
20:19:26 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEuhapclqtwm: durand ▄▄▄▄▄
20:19:32 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEtguqtnrgl: durand ▄▄▄▄▄▄▄
20:19:37 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEqyrzkps: durand ▄▄
20:19:42 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEiuwwjzgidv: durand ▄▄▄▄▄▄▄▄▄
20:19:44 <EvanR> ops
20:19:47 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEtjhfzosd: durand ▄▄▄▄▄▄
20:19:52 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEkyfgtr: durand ▄▄▄▄▄
20:19:53 <exio4> !ops
20:19:56 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEzmgjnyba: durand ▄▄▄▄▄▄▄▄
20:20:01 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEjqdtm: durand ▄,
20:20:02 <pacak> @ops ?
20:20:03 <lambdabot> Maybe you meant: pl oeis docs
20:20:07 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEmqqrrtteyn: durand ▄▄▄▄▄▄▄
20:20:11 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODElgexrw: durand ▄▄▄▄▄▄▄
20:20:12 <pacak> Hmm...
20:20:13 <exio4> hmm, which command was it?
20:20:16 <delfino_c461> ▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄ https://beta.companieshouse.gov.uk/company/10308021/filing-history christel sold freenode to Private Internet Access Andrew Lee WHO ALSO OWNS SNOONET AND IS MOVING FREENODE TO THAT SERVER (NEXT MONTH) AND CLOSING DOWN OPEN SOURCE ROOMS PLEASE COMPLAIN IN CHAN FREENODEtlkvndrub: durand ▄▄▄▄
20:20:22 <kadoban> Somebody already did it above
20:20:42 <exio4> ah, it was @whore, I confused channels
20:20:46 <Axman6> @where ops
20:20:46 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver shachaf shapr ski
20:20:57 <kadoban> exio4: xD
20:21:12 <exio4> holy crap, that typo
20:21:20 <PlasmaStar> lol
20:21:50 <exio4> ignore myself, I am going to sleep
20:22:30 <xacktm> mm freudian slips ;)
20:23:29 <kadoban> Funny part is, lambdabot would probably accept that command. IIRC it handles typos by just guessing the closest command.
21:07:13 <jle`> D_4 eh
21:17:28 <glguy> AoC, go go go
21:34:58 <jle`> my 5th iter is correct but my 18th isn't somehow
21:35:23 <glguy> Maybe you're mis-parsing a rules that isn't used in the first 5
21:47:22 <jle`> hm i don' think that's it
21:52:17 <mniip> tough
21:54:12 <mniip> I am officially too dumb to do it algebraically so I just plopped on -O3 that gave a tenfold speedup
21:54:34 <jle`> oh it's a bug in my grid splitting algorithm
21:55:29 <glguy> How fast does it go with -O3? Is that time for part 1 or both?
21:55:33 <mniip> part 2
21:56:15 <glguy> mniip: Have you submitted your part 2 yet?
21:56:19 <mniip> no
21:56:21 <mniip> it's computing
21:56:24 <glguy> ah
21:56:35 <mniip> last step
21:56:36 <mniip> I think
21:56:51 <jle`> i did everything with lists and it was all pretty fast
21:57:03 <glguy> My list version finishes both in just under 1 second
21:57:23 <jle`> ey yo got my first point today
21:57:27 <mniip> yay for vectors
21:57:36 <mniip> hm
21:57:46 <mniip> actually this isn't right
21:57:49 <jle`> it's weird that my 5th iteration the bug didn't come up
21:57:49 <mniip> how can they be so slow
21:57:51 <jle`> but my next one it did
21:58:43 <jle`> *in the 18 iteration it showed up
21:59:00 <jle`> i was splitting the grids but they ended up in the wrong order to be re-joined correctly
21:59:24 <jle`> i'm surprised it was ok during the first five iterations
21:59:25 <mniip> ah no there's more steps
21:59:55 <jle`> also when i saw the glider i was really hoping part 2 would be some game of life type thing
22:00:26 <kadoban> That's where I was guessing it was going to go after the first part too.
22:01:31 <jle`> today i am happy i know very basic group theory
22:01:42 <mniip> wait
22:01:46 <jle`> and knew how to generate all the elements of D4
22:01:55 <mniip> haha
22:02:05 <mniip> p[(1 - di) / 2 * (w - 1) + di * i][(1 - dj) / 2 * (w - 1) + dj * j]
22:02:06 <mniip> beat that
22:02:12 <EvanR> is D4 the triangle group
22:02:19 <mniip> dihedral
22:02:35 <EvanR> symmetries of what shape
22:02:41 <mniip> square
22:02:45 <mniip> 4-angle
22:02:45 <jle`> rotations = take 4 (iterate 4 rot90)
22:02:46 <EvanR> oh
22:03:02 <jle`> allItems = rotations ++ map mirror rotations
22:03:13 <Cale> Be careful, because there are two indexing schemes commonly in use for dihedral groups
22:03:16 <mniip> there's a simpler way
22:03:24 <Cale> some people like to use D_(2n) for what others would call D_n
22:03:26 <jle`> i did have to find the cayley table
22:04:06 <mniip> (.) <$> ((.) <$> [id, reverse] <*> [id, map reverse]) <*> [id, transpose]
22:04:30 <jle`> 'simpler'
22:04:54 <mniip> yeah care to show your rot90
22:04:56 <mniip> and rotations
22:05:00 <mniip> er
22:05:04 <mniip> and 'mirror'
22:05:28 <glguy> https://github.com/glguy/advent2017/blob/master/execs/Day21.hs#L37-L43
22:06:06 <mniip> shrug
22:06:08 <mniip> I like mine better
22:07:19 <mniip> ah damn
22:07:24 <mniip> my program's constantly allocating
22:07:37 <mniip> but like
22:07:41 <mniip> 15M virt
22:07:50 <mniip> it just keeps brking a few kb on and off...
22:08:23 <Average-user1> can someone tell me, from one rule, how many more there should be with the rotations and translations?
22:08:29 <mniip> woohooo, ranked 215
22:08:36 <mniip> Average-user1, 8
22:08:57 <Average-user1> (?
22:08:59 <Average-user1> 8?
22:09:03 <Average-user1> mhh
22:09:47 <shiona> well, 8 in total right? 7 more than the 1 given. And that's including possibly duplicates
22:09:48 <mniip> glguy, any idea what happened to Sigyn?
22:09:55 <Average-user1> there is the original 3 more rotations and 2 flipings, what am I missing?
22:10:04 <mniip> shiona, well if the pattern is symmetric then yes
22:10:18 <mniip> Average-user1, flipped rotations too
22:10:26 <Average-user1> really?
22:10:37 <glguy_> For serious?
22:10:39 <shiona> Average-user1: consider "##.\n...\n..."
22:11:22 <Average-user1> glguy_: you did the flipings of rotations too?
22:11:27 <jle`> Average-user1: https://en.wikipedia.org/wiki/Examples_of_groups#The_symmetry_group_of_a_square:_dihedral_group_of_order_8
22:11:42 <glguy_> mniip: I haven't thought about Sigyn in a while. Isn't that the spam detection bot?
22:11:51 <mniip> yes
22:11:59 <mniip> looks like she appears to have left. Any of you ops request that?
22:12:13 <glguy_> Not that I'm aware of
22:12:29 <mniip> then perhaps you'd like to ask staff to have it added back
22:13:56 <glguy_> Average-user1: you have to use all 8
22:15:28 <jle`> Average-user1: there are four rotations, and flipping each of those is a new symmetry, so 8 total
22:16:19 <mniip> > ($[[1,1,0],[0,0,0],[0,0,0]]) <$> ((.) <$> ((.) <$> [id, reverse] <*> [id, map reverse]) <*> [id, transpose])
22:16:22 <lambdabot>  [[[1,1,0],[0,0,0],[0,0,0]],[[1,0,0],[1,0,0],[0,0,0]],[[0,1,1],[0,0,0],[0,0,0...
22:35:07 <jle`> netsplit?
22:37:43 <jle`> any happy-ish that i was finally able to officially be on the leaderboard
22:37:59 <jle`> now i just have to do it while streaming
22:41:17 <LiaoTao> People actually live stream casual programming?
22:41:22 <LiaoTao> Or, rather, people watch that?
22:42:12 <glguy_> It's kind of a race, not necessarily casual
22:42:28 <LiaoTao> I see
22:42:47 <kadoban> Competitive programming is pretty fun to watch. Though probably not so much if you don't do it yourself.
22:42:47 <jle`> yeah it's pretty intense
22:42:56 <jle`> i want to see meta-streaming where people commentate
22:43:27 <jle`> in real-time, between people doing the same race
22:44:56 <LiaoTao> Sort of sucks if you're in the "wrong" timezone, of course
22:45:20 * hackage celtchar 0.1.3.0 - A tool to build a novel  https://hackage.haskell.org/package/celtchar-0.1.3.0 (lethom)
22:45:54 <jle`> writeNovel :: Theme -> IO Novel ?
22:47:56 <mniip> haha
22:53:45 <dminuoso> Hi. Can someone explain to me why this would not typecheck? https://gist.github.com/dminuoso/8295a87ab8b5c0d6b69a093a61b62c81
22:54:05 <dminuoso> I have a feeling I know why, but it's just barely out of the reach of my words.
22:55:09 <cocreature> dminuoso: the "a" in the type signature of "f" is not the same as the one in the type signature of "splitWith"
22:55:09 <dminuoso> (that `a` in the predicate seems to be different than the `a` in [a] and [[a]], but I dont know how to express this with a type declaration
22:55:35 <dminuoso> cocreature: Alright, so I was on the right direction. Can I somehow express this in a type declaration?
22:55:41 <cocreature> dminuoso: you can enable ScopedTypeVariables and change the type signature of splitWith to "forall a. …". then the "a" in the type signature of f will refer to the one in the other type signature
22:56:36 <glguy_> Or without extensions, pass p as an argument to f
22:58:40 <dminuoso> cocreature, glguy_: Ah great. Both seem to work, thank you.
22:59:17 <glguy_> It will be valuable to you too understand why both work and what the original problem is if that's not already the case
23:00:34 <dminuoso> glguy_: I think so. With the extension enabled it seems as if `a` is is no longer free (unless I specified `f :: forall a. ...`) acting as a scoped type variable.. (that extension name is so obvious :-)
23:01:42 <dminuoso> glguy_: And the problem must be because I claim f is valid for _all_ a, when in fact it isn;t.
23:03:41 <glguy_> Cool :)
23:14:07 <NoCode> hrm, didn't need that IDE. Interactive shell works well for now. :D
