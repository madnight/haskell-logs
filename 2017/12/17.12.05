00:05:32 * hackage unliftio 0.2.0.0 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  https://hackage.haskell.org/package/unliftio-0.2.0.0 (MichaelSnoyman)
00:07:35 <yuuko> How can I get cabal-install to generate particular URLs for index pages in local haddock? It's inserting "file://" in front of every link in the index
00:08:54 <yuuko> I have documentation = True, etc, but nothing to do with setting haddock-options or any of the settings under the haddock section of ~/.cabal/config seems to be changing anything
00:10:47 <yuuko> Worst part is, all system packages are just fine; the stuff in /usr/local/share/doc/ghc/html spits out relative paths for URLs, which is just fine by me; works with some simple HTTP server running out of a directory
00:12:45 <yuuko> But everything in ~/.cabal/share/doc, as well as inside any sandboxes, prepends file:// to all the links for no apparent reason
00:16:58 * hackage hsyslog-tcp 0.2.1.0 - syslog over TCP  https://hackage.haskell.org/package/hsyslog-tcp-0.2.1.0 (OmerAgacan)
00:17:10 <jle`> glguy: do you want to add your repo to the advent-of-code-2017 tag (https://github.com/topics/advent-of-code-2017), to help people find other haskell repos? :)
00:18:56 <boxscape> how can you add a repo to that?
00:19:17 <jle`> oh on your main repo page
00:19:20 <jle`> you can add a "topic"
00:19:25 <boxscape> ah, thanks
00:19:30 <jle`> "Manage Topics"
00:51:17 <yuuko> i have done my research, trawling through the changes that led to this
00:51:36 <yuuko> ...and there's no way to turn this off? seriously? https://kurofuku.me/i/1512463867.png
00:51:49 <yuuko> (https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Haddock.hs#L621)
00:56:51 <MarcelineVQ> I don't know anything about that, but you might need to give examples of what you're getting and what you'd prefer to have so poeple can follow along.  Are the --source-* flags here at all appropriate? https://www.haskell.org/haddock/doc/html/invoking.html
00:58:19 <yuuko> oh, i'll repost my issue since it's probably way back in scrollback by now
00:58:21 <MarcelineVQ> there's a few index related things there too
00:58:54 <yuuko> i'm trying to get cabal-install to stop producing file:// prefixes when i generate local haddock docs (documentation: True)
00:59:02 <yuuko> i've been through that reference page multiple times
00:59:15 <yuuko> and tried all manner of things under haddock-options in my ~/.cabal/config
00:59:18 <yuuko> to no avail
01:00:08 <merijn> yuuko: Why are you trying to do that?
01:00:09 <MarcelineVQ> I saw all that but you might want to be more specific about what output you're seeing and what you're actually wanting to see.
01:02:23 * hackage classy-prelude 1.3.1, classy-prelude-conduit 1.3.1, classy-prelude-yesod 1.3.1 (MichaelSnoyman): https://qbin.io/1u4v5jq
01:03:01 <yuuko> MarcelineVQ: example, cd /tmp; cabal sandbox init; cabal install (some package, let's say void) with documentation set to True in ~/.cabal/config, i load up the index page, and links in the index under that sandbox's docs all have file:// in front of them
01:03:20 <yuuko> what output i'm seeing: <a href="file:///whatever
01:03:22 * hackage conduit-combinators 1.1.2 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.1.2 (MichaelSnoyman)
01:03:41 <yuuko> what ouput i'm "actually wanting to see": <a href="/whatever
01:03:50 <merijn> yuuko: Why, though?
01:07:19 <yuuko> merijn: i'm working from within a headless vm running openbsd because i want to make sure some things i'm working on compile under that default setup (packaged ghc is considerably older, at 1.7.10, openbsd technically isn't a first-class citizen ghc support-wise in the first place)
01:07:46 <yuuko> even if i had this vm mounted at its root via sshfs or something the paths for system packages would still be broken
01:08:21 <merijn> yuuko: The paths will be broken anyway, since browser don't open local files without absolute paths
01:08:35 <yuuko> now, now, let me finish
01:08:37 <merijn> That'd only work if you were accessing the links via a webserver
01:08:39 <yuuko> long story short, i'm running that dumb python -m SimpleHTTPServer 
01:08:44 <yuuko> on root in that vm
01:09:31 <yuuko> and it pretty much Just Works (i can even tab between the various indices since those are always relative paths anyway)
01:09:45 <yuuko> but actual links to package docs in the index all have that infernal file://
01:10:33 <merijn> Then you probably want to use --source-base ?
01:11:05 <yuuko> tried that in haddock-options under ~/.cabal/config, and spinning up a fresh sandbox
01:11:12 <yuuko> doesn't work, for some mystifying reason
01:19:16 <ertes-w> ello
01:19:58 <Unhammer> anyone know how to get xref-find-references to stop showing hits from .stack-work/intero/intero28378zRe.hs etc?
01:20:23 <Unhammer> I've done (visit-tags-table "~/src/cheeseParser/TAGS" t)
01:20:44 <Unhammer> (and (setq haskell-tags-on-save t))
01:20:46 <Unhammer> in Emacs
01:24:28 * hackage nix-paths 1.0.1 - Knowledge of Nix's installation directories.  https://hackage.haskell.org/package/nix-paths-1.0.1 (PeterSimons)
01:31:27 * hackage hsyslog-udp 0.2.0 - Log to syslog over a network via UDP  https://hackage.haskell.org/package/hsyslog-udp-0.2.0 (k_bx)
01:34:10 <ertes-w> tabaqui1: no, forall is a type-system feature
01:34:23 <ertes-w> tabaqui1: you can't reinvent it within standard haskell
01:35:44 <piyush-kurur> saurabhnanda: I finally watched your talk. It was really funny and entertaining. good job.
01:37:18 <[Leary]> Link?
01:38:12 <piyush-kurur> Just that I do not agree to your claims about quick check. I think that is one of the most useful testing library for pure code
01:39:40 <ertes-w> quickcheck is also useful for IO
01:39:56 <piyush-kurur> ertes-w: yes but it is better for pure code
01:40:29 <ertes-w> not sure whether it's a common misconception that quickcheck can *only* be used for pure code
01:40:48 <ertes-w> but i often see people resorting to other frameworks for IO, like HUnit
01:41:14 <merijn> Depends on the kinds of tests
01:41:26 <cocreature> I used quickcheck the other day to test roundtrips to postgres
01:41:43 <merijn> I actually have a bunch of tests that I could implement with quickecheck, but hard-coding the input data works just as well
01:42:08 <piyush-kurur> I have been using it for things like (1) encode-vs-decode (2) store then load (IO stuff) etc in raaz
01:42:08 <merijn> (since the input data is never actually inspected anyway)
01:42:31 <piyush-kurur> and it has caught silly pointer update errors
01:42:48 <merijn> I never make silly pointer update errors
01:43:01 <merijn> I just make highly advanced and extremely subtle pointer update errors... >.>
01:43:12 <piyush-kurur> merijn: ;-)
01:44:14 <piyush-kurur> that said quickchecks interface is a bit misleading
01:44:17 <ertes-w> merijn: you can hard-code input data with quickcheck…  just don't take the input as an argument =)
01:44:30 <ertes-w> merijn: (or preapply the property function)
01:45:05 <ertes-w> piyush-kurur: do you hae a link to the talk?
01:45:07 <ertes-w> *have
01:45:33 <piyush-kurur> Let me see it was in FuncConf 2017 just give me a moment 
01:45:37 <merijn> ertes-w: Yeah, but at that point, why use quick-check at all? :p
01:46:12 <piyush-kurur> Here it is https://www.youtube.com/watch?v=7NB8tMa8sUk 
01:46:49 <piyush-kurur> that is not me though so direct all brick bats to saurabhnanda
01:46:59 <ertes-w> thanks
01:47:01 <piyush-kurur> ;-)
01:47:33 <ertes-w> merijn: because you're gonna use a test framework, and if quickcheck can handle all your test needs, then there is an element of uniformity to just using it for everything
01:48:15 <cocreature> ertes-w: well a lot of people use something like hspec or tasty which lets you use both hunit and quickcheck in the same test suite
01:48:15 <piyush-kurur> ertes-w: yeah makes sense but I have drank the hspec cool-aid so 
01:48:56 <merijn> Yeah, I'm using tasty, because that didn't have the obnoxious pseudo english DSL
01:48:57 <ertes-w> cocreature: i use tasty as well…  i just don't use its multi-framework support
01:49:19 * hackage gi-gtk 3.0.18 - Gtk bindings  https://hackage.haskell.org/package/gi-gtk-3.0.18 (inaki)
01:49:37 <ertes-w> piyush-kurur: if i'm not misinformed hspec lives on a different level
01:49:59 <piyush-kurur> ertes-w: what do you mean by different level ?
01:50:50 <ertes-w> piyush-kurur: much like comparing quickcheck and tasty
01:51:01 <piyush-kurur> I was using testframework before and found that it was not being maintained. Ported stuff to hspec and then tasty appeard (darn)
01:51:27 <tdammers> has anyone gotten hmatrix to compile on windows with stack recently? if so, what's the secret sauce?
01:51:37 <piyush-kurur> In fact If tasty had come a bit earlier (or may be if I had noticed it earlier) I might have stuck to tasty.
01:52:23 <piyush-kurur> hspec had the hspec-discover which makes organising the code easy. Tasty might also have something now I do not know
01:55:00 <piyush-kurur> ertes-w: okey yes in that sense hspec is more like tasty
02:03:59 <cocreature> I should probably take a closer look at tasty. I prefer hspec-expectations over raw HUnit but hspec-expectations is a standalone package so I could just as well use that with tasty
02:22:37 <tabaqui> ertes-w: "no, forall is a type-system feature, you can't reinvent it within standard haskell"
02:22:53 <tabaqui> ertes-w: because I need to implement class method for all types?
02:23:53 <ertes-w> tabaqui: forall has nothing to do with classes
02:24:09 <ertes-w> tabaqui: a value of type (forall a. a -> a) is a function that abstracts over the type 'a'
02:24:31 <ertes-w> that means that you can instantiate the function at any 'a' you want
02:24:47 <ertes-w> example:  id :: forall a. a -> a
02:25:19 <tabaqui> yeah, I'm trying to reduce this concept to more simple ones
02:25:35 <ertes-w> tabaqui: 'id' is a "polymorphic" function
02:25:41 <tabaqui> it works fine when I studied GADT
02:25:41 <ertes-w> RankNTypes gives you the power to treat such functions as first-class objects:  you can take a polymorphic function as an argument
02:26:11 <ertes-w> f :: (forall a. a -> a) -> Int
02:27:09 <ertes-w> tabaqui: does that make sense?
02:28:00 <tabaqui> ertes-w: more or less
02:28:29 <tabaqui> I need to finish the whole article
02:32:19 <ertes-w> tabaqui: that's the essence
02:32:41 <ertes-w> tabaqui: if a function takes a polymorphic function as an argument, it means that it can instantiate it at will
02:33:00 <ertes-w> f :: (forall a. a -> a) -> (Int, Char)
02:33:09 <ertes-w> f g = (g 5, g 'x')
02:33:28 <ertes-w> tabaqui: this isn't well-typed in standard haskell
02:33:42 <ertes-w> note how 'g' is used with two different choices for 'a'
02:34:40 <tabaqui> and here what I mean:
02:34:47 <tabaqui> we can also write
02:35:07 <tabaqui> f = (show 5, show 'x')
02:35:22 <tabaqui> and 'show' here acts different ways
02:36:56 <ertes-w> tabaqui: correct, but that's regular first-rank polymorphism
02:37:03 <ertes-w> you're not taking 'show' as an argument to 'f'
02:37:52 <merijn> tabaqui: It's a matter of "who gets to pick what 'a' is?"
02:38:15 <merijn> tabaqui: With 'show' it's the caller that decides. With 'f' it's 'f' that decides
02:38:32 <ertes-w> this would be second-rank:  f :: (forall a. (Show a) => a -> String) -> (String, String)
02:38:41 <merijn> tabaqui: The type o 'f' says you MUST give me a function that can work with ANY 'a'
02:38:42 <ertes-w> f show' = (show' 5, show' 'x')
02:39:20 <merijn> tabaqui: "g :: (a -> a) -> (Int, Char)" says, give me a function that takes SOME 'a' (that the caller of 'g' picks) and it will return (Char, String)
02:39:41 <merijn> tabaqui: i.e. I could pass "foo :: Int -> Int" to 'g' (since I get to pick any 'a' I want)
02:40:01 <merijn> tabaqui: But that clearly doesn't work for the implementation of 'f', since the function gets called with both Int and Char
02:40:44 <merijn> tabaqui: So, how do you tell the caller of 'f' that the function has to work for both? the forall syntax ertes-w wrote says that function has to work for all values of 'a' that might be picked
02:41:32 <ertes-w> tabaqui: note the subtle difference:  f1 :: forall a. (a -> a) -> Int;  f2 :: (forall a. a -> a) -> Int
02:42:10 <dminuoso> ertes-w: So in one case f1 is polymorphic, and in f2 takes a polymorphic function as an argument?
02:42:13 <ertes-w> f1 is polymorphic, which means that the user of f1 can pick any 'a' they want…  for example i could pick a = Int and apply f1 to (succ :: Int -> Int)
02:42:42 <merijn> dminuoso: Yes
02:43:02 <ertes-w> f2 is *not* polymorphic…  it wants a polymorphic function as its argument…  i can't apply f2 to (succ :: Int -> Int), because it's not polymorphic
02:43:14 <merijn> dminuoso: The forall/Rank2 in f2 is requiring the input function is polymorphic
02:43:40 <ertes-w> tabaqui: f1 is rank-1-polymorphic, f2 is rank-2-polymorphic
02:44:12 <ertes-w> (which is slightly misleading wording…  f2 is not really "polymorphic")
02:44:57 <merijn> dminuoso: You can even combine it with typeclass constraints to require typeclass polymorphic functions, like so: https://gist.github.com/merijn/77e3fa9757658e59b01d
02:45:30 <merijn> dminuoso: Which is slightly more useful, because otherwise you can't really do much with values :)
02:53:14 <dminuoso> merijn: My GHC is not emitting that diagnostic `Could not deduce (a ~ Int)`, is this possibly a version difference? (Im using 8.0.1)
02:54:15 <merijn> dminuoso: I'm assuming it's still emitting an error?
02:54:22 * hackage http-streams 0.8.5.5 - An HTTP client using io-streams  https://hackage.haskell.org/package/http-streams-0.8.5.5 (AndrewCowie)
02:54:46 <merijn> dminuoso: This paste is from, like, GHC 7.6 or 7.8 and the errors got a complete overhaul in 8.0 and 8.2
02:54:59 <dminuoso> Oh absolutely, it just looks a bit different.
02:55:03 <dminuoso> https://gist.github.com/dminuoso/841d0340be3372d4544c2cc8d564c355
02:55:55 <merijn> dminuoso: Yeah, that probably got overhauled in 8.0, the initial error was horrible anyway
02:57:27 <tabaqui1> ertes-w, merijn, ok, I get it, thanks
02:57:58 <tabaqui1> ertes-w, merijn, ok, I get it, thanks
02:58:10 <tabaqui1> Oops, laggy
02:59:46 <frerich> Hi all! Does anybody know whether there's a variant of 'iterate' which only keeps iterating until the given function returns Nothing, i.e. a function of type '(a -> Maybe a) -> a -> [a]' with a definition equivalent to "iterateMaybe f x = x : case f x of Nothing -> []; Just x' -> iterateMaybe f x'"? I thought I saw that in Control.Monad.Loops, but apparently I didn't remember that correctly.
03:02:22 <tabaqui1> dropUntil, or smth, look at the Data.List in base
03:03:04 <tabaqui1> but test function must return Bool, not Maybe
03:03:05 <ertes-w> frerich: unfoldr
03:03:44 <tabaqui1> Oh, rigth, didn't understand the question
03:03:55 <ertes-w> > unfoldr (\x -> if x >= 0 then Just (x, x - 1) else Nothing) 10
03:03:57 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
03:05:48 <frerich> ertes-w: Yeah, that would work, but I somehow seemed to recall that just like 'iterate' could be defined in terms of 'unfoldr', there was also something like 'iterateM' or so which would be defined in terms of 'unfoldM' (but my memories are all somewhat fuzzy).
03:06:09 <frerich> ...and usually, Control.Monad.Loops comes to the rescue when I have this kind of situation. :-)
03:06:14 <fakenullie> I want to stop upgrading all those haskell- on my arch
03:06:45 <ertes-w> frerich: if you need to unfold with effects you should probably use a stream processing abstraction instead
03:08:24 <saurabh__> piyush-kurur: thanks!
03:08:46 <saurabh__> piyush-kurur: I have only been able to test QC for round-tripping, nothing else.
03:08:54 <saurabh__> s/able to test/able to use/
03:13:28 <piyush-kurur> saurabh__: what are the other things that you want to test?
03:13:39 <piyush-kurur> that you found problematic
03:14:21 <piyush-kurur> and how are you testing currently?
03:15:57 <saurabh__> piyush-kurur: https://github.com/nick8325/quickcheck/issues/139
03:16:22 <saurabh__> > For example, how would one use Quick Check for testing a CRUD JSON API? Or, say a reservation system's domain API, which allows overbooking only if the admin is making the overbooking request?
03:16:25 <lambdabot>  <hint>:1:12: error: parse error on input ‘,’
03:19:24 * hackage fedora-haskell-tools 0.4 - Building and managing tools for Fedora Haskell  https://hackage.haskell.org/package/fedora-haskell-tools-0.4 (JensPetersen)
03:19:51 <saurabh__> > does this, confuse lambda bod
03:19:54 <lambdabot>  <hint>:1:10: error: parse error on input ‘,’
03:20:01 <piyush-kurur> saurabh__: while I do not know the answer, what do you use int the rails case?
03:20:48 <saurabh__> piyush-kurur: we don't use Quickcheck in Rails. Instead most tests follow the regular HSpec kind of testing patterns,
03:21:30 <piyush-kurur> No I mean whatever you use for rails like rspec for example how does that work
03:21:34 <piyush-kurur> ?
03:22:03 <saurabh__> setup a known scenario (i.e. push known data into the DB) => execute domain APIs => assert API responses and/or DB state.
03:22:29 <piyush-kurur> what is preventing that from working here?
03:24:37 <piyush-kurur> I am assuming that you can setup the scenario using an IO action I believe
03:24:37 <joebetz> saurabh__: what if QC generated lists of user actions / business transactions, and verified that running them doesn't lead to any invalid states? e.g., two hotels booked for the same night in different locations
03:25:44 <saurabh__> joebetz: that's exactly what we struggled with for 2 months :)
03:25:53 <saurabh__> joebetz: trying to get this to work, in practice
03:29:10 <piyush-kurur> saurabh__: You want controlled generation of data instead of random hotel * booking pairs ?
03:29:19 <piyush-kurur> then you the appropriate arbitrary instance
03:30:04 <piyush-kurur> you generate a random hotel and multiple bookings for the same hotel
03:30:16 <piyush-kurur> this can be done by the monadic interface for Arbitrary
03:31:18 <piyush-kurur> s/monadic interface for Arbitrary/monadic interface for Gen/
03:35:12 <joebetz> abstracting over the specific hotel doesn't sound terribly useful
03:36:32 <piyush-kurur> yeah as joebetz says for the example above it might be okey to just use a fixed hotel and generate multiple instances of bookings
03:50:22 * hackage parser-combinators 0.2.1 - Lightweight package providing commonly useful parser combinators  https://hackage.haskell.org/package/parser-combinators-0.2.1 (mrkkrp)
04:13:06 <EvilMachine> Hmm… I want to store executables (including #! shell scripts) in (byte)strings, and tell the kernel program loader to run them, not loading a file from disk. I can’t find how to do this. (under Linux etc)
04:13:23 <merijn> EvilMachine: Sadly, I don't think you can
04:13:26 <merijn> EvilMachine: I
04:13:31 <merijn> I've wanted to do the same
04:13:37 <merijn> I never got it to work
04:14:01 <EvilMachine> merijn: So the kernel itself probably loads the file from the VFS? 
04:14:20 <merijn> Dunno what the V stands for there?
04:14:26 <callmecabman> virtual
04:14:47 <merijn> I was guessing that, but I don't see how the filesystem being virtual or not is relevant?
04:14:56 <callmecabman> any fs driver realises abstract vfs functions
04:14:56 <EvilMachine> merijn: VFS is Linux’s file system abstraction layer.
04:15:25 <EvilMachine> merijn: I was using it as a generic term for the file systems.
04:15:38 <merijn> EvilMachine: Why not just say FS? Anyway, yes I don't think posix has a way to run an executable from anything other than the filesystem
04:15:46 <EvilMachine> merijn: Otherwise, the only other way I would know, would be to write a FUSE implementation that uses my stuff as a backend. ;)
04:16:12 <merijn> EvilMachine: Well, you could mark the entire memory of your executable as executable, then have it overwrite itself with the executable you want, but...yeah, that way lies madness
04:16:48 <callmecabman> man 2 mmap
04:17:16 <EvilMachine> merijn: Because “VFS” means a bit more than just the regular file system interface. :) Remember: In proper Unix, *everything* is a file. (And that’s kinda where I’m going too. :)
04:17:36 <sgronblo> Is it possible to create an Array from a List without having to get the length of the list for specifying the bounds of the Array?
04:18:00 <merijn> sgronblo: Not in an efficient way
04:18:12 <EvilMachine> merijn: Yes, that way lies madness indeed! ^^
04:19:20 <merijn> EvilMachine: What's the actual goal?
04:19:46 <EvilMachine> merijn: Why are you implying that I wouldn’t have told you my actual goal?
04:20:17 <merijn> EvilMachine: Sounds like an XY problem. "I want to store executables in bytestrings" <- presumably you have a reason for wanting that that you left unstated
04:20:17 <sgronblo> merijn: I see, thanks
04:20:23 <EvilMachine> merijn: Hmm, I could, of course, just use bash to make the string look like a file. ;) But that’s just /ugly/.
04:20:47 <merijn> EvilMachine: You could simply "make" executables on-demand
04:22:01 <EvilMachine> merijn: Yes, but that reason is just one case, and writing for just one case is bad non-generalized code. And I have a reason for that reason too, and so on, until we end up at the Münchhausen trilemma. So? ^^
04:22:37 <merijn> EvilMachine: If you don't mention what it is, no one can provide a better suggestion to avoid the issue
04:25:07 <EvilMachine> merijn: If I would tell you the reason, you would give me an answer that would only solve that one single case, and would be useless for any other cases. In other words: I asked for an implementation of a type that only uses type classes, and you want me to specify a specific set of types. An implementation for that set of types would not be usable as the generic function.
04:25:28 <ertes-w> EvilMachine: without questioning what you're doing, just write to a temporary file?
04:25:32 <EvilMachine> merijn: That is why the “XY problem” meme is so cancerous.
04:26:07 <EvilMachine> ertes-w: Yep, I thought of that … I’d create a load of temporary files though. ^^
04:26:14 <merijn> So?
04:26:28 <EvilMachine> merijn: “So?”?
04:26:43 <merijn> "I'd create a load of temporary files" <- who cares?
04:27:05 <ertes-w> EvilMachine: i see no issue with that
04:27:54 <ertes-w> EvilMachine: also unless you need to run all of them at the same time or are on windows, you can very quickly delete those files again
04:28:05 <callmecabman> you can store'em on a ramdisk
04:28:06 <EvilMachine> merijn: Ah. Yes, I guess the three problems are that 1. it would be slow, 2. it would be ugly and 3. I plan to get rid of the classical file system, and replace it with this, so we’d be in circular reasoning here. ^^
04:28:51 <ertes-w> EvilMachine: modern filesystems scale logarithmically at worst with the number of files, and also /tmp is often a tmpfs to begin with
04:28:56 <merijn> Replace the filesystem in/with what? You haven't described what you're doing at all
04:28:58 <ertes-w> don't bother and just write temp files
04:28:59 <EvilMachine> ertes-w: On Linux you can delete files that are still open. :)
04:29:09 <ertes-w> EvilMachine: exactly
04:29:10 <EvilMachine> ertes-w: (And even recover them.)
04:29:30 <callmecabman> the problem on unix is that you have the execve syscall which wants a filename, so you have to have a file or do some dirty hacks
04:29:32 <ertes-w> EvilMachine: "also unless you need to run all of them at the same time or are on windows, you can very quickly delete those files again"
04:29:49 <EvilMachine> ertes-w: Yes, that’s a good point. My /tmp is indeed a tmpfs. even my /var/tmp is a tmpfs, but gets compressed and restored on shutdown/boot.
04:30:23 <ertes-w> you only need the files for *initiating* the exec…  once e.g. createProcess returns you can immediately delete the files
04:30:35 <ertes-w> however, that's not portable…  windows won't allow that
04:31:11 <callmecabman> ertes-w: can't you exec the file, mmap it, replace with another and exec again?
04:34:46 <ertes-w> callmecabman: not sure
04:35:00 <ertes-w> also that seems pointless…  just delete the file and write a new one
04:35:20 <ertes-w> or at least pointlessly risky
04:35:27 <EvilMachine> ertes-w: Hmm, I wonder how bash implements the possibility to use program output as a file (as in: » vi <( echo "something" ) «). It uses file descriptors internally /dev/fd/$someNumber.
04:36:10 <EvilMachine> ertes-w: Good. Only a dead Windows is a good Windows. ^^
04:36:10 <callmecabman> EvilMachine: doesn't it just use the 0 and 1 fds?
04:36:36 <EvilMachine> ertes-w: Yes, pointless. I’d not do mmap.
04:36:53 <EvilMachine> callmecabman: try this: vi <( echo "something" )
04:36:53 <Axman6> I recently learnt this handy trick: diff -u <(curl http://foo/bar.txt) <(curl http://bar/baz.txt)
04:37:14 <EvilMachine> callmecabman: vim just showed me that the name of the open file is /dev/fd/63
04:37:37 <callmecabman> EvilMachine: you're right
04:37:46 <EvilMachine> Axman6: yeah, nice one. :) you can even leave out curl, and use /dev/tcp/… ;)
04:38:47 <ertes-w> shells use pipes by default and fall back to fifos
04:39:03 <ertes-w> in zsh you can explicitly choose between the two
04:39:06 <EvilMachine> ertes-w: Aren’t pipes just kinda fifos?
04:39:18 <ertes-w> EvilMachine: anonymous fifos…  pipes don't live on the filesystem
04:39:30 <ertes-w> fifos are actual inodes
04:39:32 <EvilMachine> ertes-w: I guess I should go to another channel (like #bash?) for this  ^^
04:40:33 <EvilMachine> ertes-w: Ah, yes, that’s where the difference is. Hence a fifo is needed when it has to be treated as a file. Sooo… If I just tell the system to execute this handy fifo that I created… ;)
04:41:29 <ertes-w> that reminds me of an interesting engineering challenge i haven't found a nice solution for so far
04:41:47 <ertes-w> except by aggressive uninterruptibleMasking
04:42:24 <EvilMachine> ertes-w: What challenge?
04:43:05 <Wizek> Is there a list somewhere for list-like (/array/sequence/vector/bytestring) datastructures?
04:43:44 <ertes-w> bracket (openBinaryTempFile tmpDir "blahXXX") (hClose . snd) (\(fp, _) -> _k)
04:43:57 <ertes-w> now technically in _k you would create the process and then return from the bracket
04:44:22 <ertes-w> however, the subprocess itself is also a resource you need to collect, but it lives longer than the bracket for the temporary file
04:44:30 <ertes-w> it's kind of like a cross-bracket
04:44:47 <ertes-w> i know ResourceT can deal with this, but i wonder if there is a more lightweight/ad-hoc way
04:45:01 <Wizek> Perhaps by looking for instances of isList somehow? Can I look for instances with hoogle/hayoo perhaps?
04:45:19 <bxc> is there a list of default imports for lambdabot? I'm running a pub quiz with a haskell expression round and need a decent set of default imports - lambdabot seemed like an easy way to get a set
04:45:55 <Wizek> bxc: perhaps here? https://hackage.haskell.org/package/lambdabot
04:46:17 <ertes-w> bxc: just fire up GHCi and load the modules you need?
04:46:53 * hackage texbuilder 0.1.2.0 - View your latex output while editing  https://hackage.haskell.org/package/texbuilder-0.1.2.0 (xaverdh)
04:47:57 <Wizek> bxc: more targetedly: https://github.com/lambdabot/lambdabot/search?utf8=%E2%9C%93&q=import&type=
04:49:33 <bxc> ertes-w: people get to supply an 80 character expression to be evaluated in the quiz: i don't want them submitting "big code" that I have to type in. http://www.hawaga.org.uk/ben/tech/london-hug-quiz/game-theory.hs.txt
04:51:07 <bxc> https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/Pristine.hs.default
04:51:20 <bxc> Wizek: https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/Pristine.hs.default
04:51:24 <bxc> Wizek: i think that's what i'm after
04:51:39 <ertes-w> bxc: is it a "pub" quiz in the traditional sense?  i.e. in person?
04:51:42 <bxc> ertes-w: yes
04:51:43 <bxc> in a pub
04:51:58 <bxc> ertes-w: https://www.meetup.com/London-Haskell/events/244406407/
04:52:22 <Wizek> bxc: looks like it at a glance
04:52:23 <ertes-w> then does it really matter where you dump those submissions into?  could be lambdabot, could be GHCi
04:52:27 <bxc> ertes-w: that one i just posted is one of the "table rounds" that you get the whole evening to work on
04:52:43 <bxc> ertes-w: what matters is what contestants can use.
04:52:54 <bxc> ertes-w: you can't use nub, for example, unless I've said I've imported it
04:53:14 <bxc> ertes-w: so it's not that i want people to use lambdabot - it's that I want to have a decent set of imports that participants can expect to be in scope
04:53:19 <bxc> and i know lambdabot has a decent list
04:53:25 <bxc> so i want to steal that list
04:53:31 <bxc> to make in scope for the quiz round.
04:53:39 <bxc> rather than spending a day making my own.
04:53:40 <ertes-w> bxc: ah, this isn't about using lambdabot itself
04:53:43 <bxc> right
04:54:02 <ertes-w> i see…  well, you could just tailor the import list to the task at hand
04:54:05 <bxc> yeah
04:54:12 <bxc> that list from Pristine.hs.default looks ok
04:54:21 <ertes-w> as for the lambdabot imports, i think you would have to ask int-e
04:54:25 <bxc> might as well reuse years of the Community deciding whats going to have in scope.
04:54:31 <bxc> for one-liners.
04:54:40 <ertes-w> but lambdabot's live import list is rather bloated
04:55:53 <ertes-w> bxc: as you're making those challenges there may be some merit in just looking at your personal ~/.ghci file
04:56:08 <Wizek> ertes-w: wrt bloated: why is that a problem?
04:56:15 <bxc> I'd rather have more than less
04:56:16 <ertes-w> it's not a problem
04:56:25 <bxc> becuase I'm interested in people doing "interesting stuff"
04:57:06 <ertes-w> bxc: how about giving the participants freedom in their imports, but restrict the *packages* they may use?
04:57:17 <bxc> because i want it to be small for me to type in to evaluate.
04:57:37 <bxc> as i will be slightly drunk
04:57:42 <bxc> and also trying to run the rest of a quiz.
05:00:21 <ertes-w> "import Contrrrl.Moanad…  err…  sorry guys…  imprrt Cotroll.Gonad…  arr…"
05:01:55 <ggVGc> most of my code isn't easily distinguishable from gonads
05:01:58 <ggVGc> so might be fair
05:02:06 <callmecabman> shouldn't you use psychostimulants for Haskell parties?
05:02:20 <callmecabman> like in Dune
05:02:40 <Logio> writing Haskell under the influence feels like it might introduce unintended side effects
05:03:26 <tdammers> unsafeIngestDrugs
05:03:53 <ggVGc> writing haskell non-sober is great, you don't have to worry so much
05:04:11 <ggVGc> multiple times I've given up because I couldn't get what I was doing to compile though
05:04:16 <ertes-w> "rrryeee-ave thish fuktion here thaaat hash shite effecktsss..."
05:04:48 <bxc> I actually wonder if anyone will do anything interesting, or just submit Double literals
05:05:10 <callmecabman> Logio: at least it removes some laziness
05:07:43 <Rembane> If it gives me shining, blue eyes I'm game.
05:08:14 <hpc> Rembane: but then you would have to leave the island
05:08:48 <Rembane> hpc: Yes. That's a sacrifice I'm willing to make, because the spice must flow.
05:09:25 <ggVGc> bxc: what is the point of the quiz? to make as crazy as possible haskell expression?
05:09:47 <Logio> bxc: how about asking for (Monad m) => m double?
05:11:13 <Psybur> > return 1.0 :: IO Double
05:11:15 <lambdabot>  <IO Double>
05:11:33 <Psybur> Do I pass the quiz? :D
05:11:50 <Logio> sure, but I think asking for an m Double prompts more interesting answers
05:16:52 <ski> Logio : how so ?
05:17:09 <Logio> just a gut feeling
05:17:34 <Logio> if you just ask for a double, people will think of funny maths to generate one
05:17:52 <Logio> if you ask for an m double, people will think of funny Haskell to generate one 
05:18:02 <ski> asking for a `forall m. Monad m => m Double', isn't that more interesting than asking for a `Double'
05:18:35 <ski> i suppose `fail s', for any `s :: String' is also of the former type. but apart from that, there's only bottoms
05:19:59 <ski> (or maybe you meant asking for an `m Double', for some `m' (perhaps an instance of `Monad' ?) chosen by the answerer)
05:21:08 <Psybur> > Just 1.0
05:21:10 <Logio> ski: that is what I meant
05:21:11 <lambdabot>  Just 1.0
05:21:37 <ski> ok
05:21:53 <Logio> though not "perhaps an instance", but specifically an instance of Monad :)
05:22:18 <Logio> just asking for an f Double might be interesting as well 
05:22:26 <ertes-w> challenge: implement a list of all possible values of Bool using at most 14 characters of source code
05:22:48 <ski> in my mind, asking for a `Monad m => m Double' is not the same thing as asking for a `m Double', where `Monad m'
05:23:27 <mniip> ski, forall vs exists?
05:23:36 <TMA> [False,True]
05:24:03 <ski> mniip, no. presupposition, vs. no presupposition
05:24:13 <mniip> what
05:24:16 <ertes-w> TMA: you're missing one value
05:24:31 <mniip> ertes-w, or some value of one
05:24:34 <mniip> for*
05:24:47 <ertes-w> Bool has three values in haskell =)
05:24:50 <Axman6> > fix error::[Bool]
05:24:52 <lambdabot>  error:
05:24:52 <lambdabot>      • Couldn't match type ‘Char’ with ‘Bool’
05:24:52 <lambdabot>        Expected type: [Bool]
05:25:02 <Psybur> I thought we were supposed to ignore bottom :D?
05:25:09 <ertes-w> nah, that would be easy =P
05:25:23 <Axman6> but it's morally correct!
05:25:54 <ski> a function that takes an input conforming to the former description will have a type like `(Monad m => m Double) -> ...'. a function that takes an input conforming to the latter description can have a type like `Monad m => m Double -> ...', or like `Maybe Double -> ...' (in this case `m = Double')
05:25:56 <osa1> how naive am I for expecting this to work http://lpaste.net/360521 ?
05:26:14 <ertes-w> if xs is a correct solution, then length xs = 3, and given any two distinct values x and y from that list, x == y ≠ True
05:26:22 <ski> mniip : you've seen the "Have you stopped beating your wife ?" sentence, right ?
05:27:09 <ski> mniip : that sentence has as a presupposition, as something that is presupposed, when asking it, that (a) you have a wife; and (b) you have beaten her earlier
05:27:44 <ertes-w> to be more precise the correct solution is an element of (permutations [False, True, undefined])
05:27:54 <ertes-w> s/the/a/
05:28:39 <mniip> ski, well this is still a variance issue, then?
05:28:43 <mniip> but with the dictionary
05:28:52 <ski> mniip : it seems that, often, when people e.g. talk about something of type `Num a => [a]', they really mean a value of type `[a]', where it is presupposed that `a' is an instance of `Num' (this is the presupposition)
05:29:00 <mniip> right
05:29:15 <mniip> or worse they say [Num a]
05:29:22 <ski> `Num a => [a]' is different from `Num a *> [a]' is different from `[a]' with a `Num a' presupposition
05:30:01 <TMA> ertes-w: maybe you are using a different prelude, but no.
05:30:01 <mniip> Num a *> [a] is pretty close thought
05:30:03 <mniip> though
05:30:16 <ski> in the former two cases, if you'd have a list of such lists, you'd have a value of type `[Num a => [a]]', respectively `[Num a *> [a]]'
05:30:29 <ski> in the latter case, you'd have a `[[a]]', with a `Num a' presupposition
05:30:39 <ertes-w> TMA: no, base Prelude from pretty much any version since i've been using haskell (~2007)
05:31:00 <ski> the presupposition is "freestanding", not part of the type of the value itself. it's something which is presupposed, prior to forming the type of the value
05:31:23 <TMA> ertes-w: an expression of type Bool has three possible values, the type has two
05:31:41 <ertes-w> > undefined :: Bool
05:31:43 <lambdabot>  *Exception: Prelude.undefined
05:31:43 <ertes-w> TMA: ^
05:31:44 <ski> similarly, a math expression `1 / x' has as a presupposition that `x' is not zero (otherwise the expression is not well-defined. strictly speaking, you've failed to form an expression, if `x' might be zero)
05:32:37 <ski> mniip : a function returning a `Num a *> [a]' is different from a function returning a `[a]', in a context where `Num a' (i.e. the presupposition) holds
05:32:50 <TMA> ertes-w: undefined :: Bool is an expression of type Bool
05:33:01 <mniip> ski, correcty
05:33:11 <mniip> a function can take Num a *> [a], and return a Num a => [a]
05:33:14 <bxc> ggVGc: what's the point of that round? it's to put a big red herring on the front of "each team chooses a number. whichever team picks the lowest unique number gets that number of points."
05:33:27 <ertes-w> TMA: and it's not equal to True or False
05:33:29 <bxc> ggVGc: There are 9 other rounds of more traditional pub quiz fun.
05:33:55 <ski> in both the `Num a => [a]' and the `Num a *> [a]' case, you "couple" `Num a' with `[a]'. in the former of those, you *require* `Num a' to be able to access the value of type `[a]'. in the latter, you yourself *provide* the evidence for `Num a' together with the value of type `[a]'
05:34:17 <bxc> ggVGc: using Double and a Haskell expression gives me a way of defining the accuracy/edge cases, for a Haskell literate audience
05:34:31 <TMA> ertes-w: it is undefined to which of the possible Bool values it is equal
05:35:06 <ertes-w> TMA: let me rephrase the challenge in order to avoid this discussion:  write a list that contains exactly the three elements False, True and undefined using at most 14 characters of source code
05:35:10 <TMA> ertes-w: which does not make it a distinct value (except in an operational sense)
05:35:29 <ertes-w> the order of the elements does not matter
05:35:30 <ski> but in the case with a value of type `[a]', with a presupposition `Num a', you're merely providing a value of type `[a]', in a context where you already know that `Num a', since before (e.g. you've written `foo :: forall a. Num a => ..' in your function signature, and so the caller provides the evidence for it. or perhaps you have a specific `a', like `Int', for which `Num Int' is already established)
05:35:39 <ertes-w> [True, undefined, False] is also a solution
05:35:46 <ski> mniip : yes, or vice versa
05:36:53 <Axman6> > map length ["undefined","error\"\""]
05:36:55 <lambdabot>  [9,7]
05:37:28 <mniip> callmecabman, regarding your question yesterday, I did find how to enrich a preorder category with itself...
05:39:51 <ski> (e.g., if you want to state mathematically that `1 / (1 / x) = x', with explicit quantifiers, you must exclude the case of `x' being zero, e.g. `forall x : |R.  x =/= 0  =>  1 / (1 / x) = x'. in general, an implication `A => B' is well-formed if : (a) `A' is well-formed; and (b) `B' is well-formed, under the condition (presupposition) that `A' is *true*)
05:42:07 <ski> (similarly, `A /\ B' is well-formed if : (a) `A' is well-formed; and (b) `B' is well-formed, under the condition (presupposition) that `A' is *true*. this is like short-circuiting `&&', so that one can state conditions like `d =/= 0  /\  abs (n / d) > 5'. the former conjunct provides the context (presupposition) that ensures the latter is well-formed)
05:42:40 <guillaum2> Hi there. I'm wondering, if I have a function `foo :: (Int -> Int) -> Int -> Int` which is used as `foo f 10`. Can I do something to inline `f` at the callside inside `foo`?
05:43:19 <boxscape> ski: that would make /\ noncommutative though, right? seems a bit ugly
05:43:20 <lyxia> guillaum2: make f inlineable
05:43:35 <ski> (one could also have a formation rule for disjunction `A \/ B' that it is well-formed if : (a) `A' is well-formed; and (b) `B' is well-formed, under the condition that `A' is *false*. compare with how `False || undefined' is equal to `False' in programming)
05:44:14 <mniip> if you fix 2 objects X and Y with X >= Y, and you send Hom(A, B) into (if A >= B then X else Y)
05:44:14 <mniip> and you send every pair of morphisms f :: A' -> A and g :: B -> B' into the unique morphism between X and Y
05:44:23 <jobor> For using Control.Monad.Reader in my stack project I had to add "mtl" to the build-depends in my cabal file. I found that out by googling... What is the canonical way to answer the question "What must I add to build-depends when using import FOO?"?
05:44:42 <ski> boxscape : well, to be able to even ask the question whether `A /\ B' is equivalent to `B /\ A', you must pick a `B' whose well-formedness doesn't depend on assuming the truth of `A'. and in that case, these two *are* equivalent, so commutativity does hold
05:44:54 <boxscape> oh, that's a good point
05:45:04 <merijn> jobor: Usually you'd figure out which package you want FIRST and figure out the import after
05:45:10 <guillaum2> lyxia: unfortunatly it does not. With `f` marked as INLINABLE, I`m still two times slower than with `f` manually inlined at call site. (everything is in the same file)
05:45:20 <ski> it's just that the formation rule *allows* the formation of conjunctions of a slightly more general form
05:45:31 <ertes-w> heh, can be done in 13 characters even =)
05:45:33 <merijn> guillaum2: What's the type of 'f'?
05:45:36 <boxscape> right, fair enough ski
05:45:52 <merijn> guillaum2: Is it a generic num function you're passing to foo?
05:45:59 <TMA> ertes-w: seems like an impossibility
05:46:04 <merijn> guillaum2: You might wanna specialise 'f' if it is?
05:46:18 <guillaum2> merijn: `Int -> Int`
05:46:22 <merijn> guillaum2: Also, INLINABLE doesn't actually make GHC inline things
05:46:23 <ski> instead of insisting on a strictly left-to-right interpretation, one could impose some (case-by-case) ordering on the parts, which directs which parts well-formedness can depend on which other parts (assumed) truth
05:46:28 <merijn> guillaum2: You want INLINE for that
05:46:47 <merijn> guillaum2: INLINABLE is for "this function looks to big to inline, but at least consider it" notes to GHC
05:46:50 <Eduard_Munteanu> jobor, GHC suggests the package you need if you have it installed when you try to compile
05:46:53 <merijn> guillaum2: INLINE is "inline this"
05:47:14 <merijn> jobor: For example, how did you find out about Control.Monad.Reader?
05:47:52 <jobor> merijn: I used it in a non-stack project before. :-}
05:48:18 <merijn> jobor: If you've looked up the documentation on Hackage, that also lists the package it's from
05:48:22 <Eduard_Munteanu> Oh, stack, not just cabal.
05:48:42 <jobor> Eduard_Munteanu: right, and the package wasn't installed.
05:49:19 <jobor> merijn: ouch, that was easy. Thanks! :)
05:49:27 <ertes-w> TMA: it's possible, but you have to be aware of one particular subtlety about one particular type class
05:49:34 <merijn> jobor: :)
05:50:23 <merijn> jobor: Otherwise I'd try Hoogle/Hayoo and fall back to google, but usually it doesn't reach that point since you usually select packages first before you even know which modules are in there
05:52:14 <jobor> merijn: I even searched for the string "package" on the hackage page. That the first string behind the logo would be the package name didn't occur to me.
05:52:22 <jobor> Well, now I know. 
05:52:39 <merijn> jobor: Also, the contents link in the top-right takes you to the front page of the package
05:53:09 <jobor> ah cool
05:54:24 <guillaum2> merijn: I tried many think on `f` (INLINE / INLINABLE) and nothing works. However I was able to get something working with a weird hack, creating a class for my `f` signature, then as many instance as need and I'm calling `foo` using `foo @"myVersionOfF"` and SPECIALIZE kicks in and I have my performances...
05:54:37 <Eduard_Munteanu> jobor, you can click the Contents link at the top to get to the package's main page, which lists versions and other things
05:55:36 <jobor> merijn: Eduard_Munteanu: thanks, guys!
05:56:36 <mniip> callmecabman, I haven't thoroughly checked this this seems like a fully faithful construction
05:56:48 <mniip> which is good right?
05:57:47 <xintron> Given string of hexadecimal characters, 0-9a-z, how can I convert them from String -> [Int]? "00AF" -> [0, 0, 10, 15]
05:57:55 <lyxia> guillaum2: is f recursive
05:58:03 <mniip> > digitToInt 'F'
05:58:05 <lambdabot>  15
05:58:27 <mniip> unless this is homework, in which case you're better off with writing your own
05:58:39 <xintron> mniip, Ah. So just map over the string.
05:59:04 <xintron> And I guess that if I want to limit the input to only 0-9 I would also run `isDigit` on the value
05:59:10 <lyxia> guillaum2: can you show some example code?
05:59:23 <guillaum2> lyxia: no, f is not recursive
05:59:41 <guillaum2> lyxia: merijn: I understood, i must INLINE `foo` and not `f`
06:00:21 <guillaum2> this way, at call site `foo f` will be inlined as `long body bla f bla bla` and then `f` can be inlined
06:03:57 <alsoStevenXL> Hi everyone. I have a project that uses hlibsass as a dependency. hlibsass comes with its own libsass, which it tries to build but fails on osx. How can I pass the flag "externalLibsass" to hlibsass, per the docs (https://github.com/jakubfijalkowski/hlibsass)
06:04:51 <merijn> alsoStevenXL: You can't pass flags to dependencies'
06:05:20 <merijn> You can install hlibsass directly with that flag and then hope cabal-install uses that install
06:06:01 <alsoStevenXL> merijn: OK - I will try that.
06:15:34 * hackage bisect-binary 0.1.0.1 - Determine relevant parts of binary data  https://hackage.haskell.org/package/bisect-binary-0.1.0.1 (JoachimBreitner)
06:24:33 <callmecabman> mniip: sorry, haven't being paying attention. Gonna read the logs
06:27:48 <ij> Are there lens-likes where setting twice isn't the same as setting once?
06:28:05 <Psybur> Lets say I have a list of operations I want to do, and I want to stop at the first success, if there is one. What monoid/monad is that
06:28:19 <merijn> Psybur: Maybe/MaybeT
06:28:54 <Psybur> I thought with Maybe, if I get a failure it will give me Nothing and if I get all successes it will give last one, not first
06:29:10 <merijn> Psybur: You want the Alternative instance of Maybe
06:29:29 <merijn> > asum [Nothing, Just True, Nothing, Just False]
06:29:31 <lambdabot>  Just True
06:29:38 <Psybur> Interdasting
06:30:03 <merijn> Psybur: The monad is short-circuit on failure. The Alternative is "try until success"
06:30:09 <ij> I would agree, very interdasting. (not kidding about the first part)
06:30:10 <ski> > msum [Nothing,Nothing,Just 2,Nothing,Just 3,Just 5,Nothing]
06:30:13 <lambdabot>  Just 2
06:30:16 <ski> > (getFirst . mconcat . map First) [Nothing,Nothing,Just 2,Nothing,Just 3,Just 5,Nothing]
06:30:18 <lambdabot>  Just 2
06:30:21 <ski> > (getLast . mconcat . map Last) [Nothing,Nothing,Just 2,Nothing,Just 3,Just 5,Nothing]
06:30:23 <lambdabot>  Just 5
06:30:43 <ski> @type mconcat
06:30:44 <lambdabot> Monoid a => [a] -> a
06:30:46 <ski> @type asum
06:30:47 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
06:30:48 <ski> @type msum
06:30:49 <lambdabot> (MonadPlus m, Foldable t) => t (m a) -> m a
06:36:39 <ertes-w> ij: technically a lens can do that
06:37:06 <ertes-w> ij: i think all optics can, it's just not lawful to do so
06:37:31 <ertes-w> ij: however, sometimes it's useful to interpret laws modulo an equivalence relation
06:39:34 <ertes-w> @let letter f c | isAsciiUpper c = (\x -> toEnum $ fromInteger (mod x 26) + fromEnum 'A') <$> f (toInteger (fromEnum c - fromEnum 'A')) | isAsciiLower c = (\x -> toEnum $ fromInteger (mod x 26) + fromEnum 'a') <$> f (toInteger (fromEnum c - fromEnum 'a')) | otherwise = pure c
06:39:35 <lambdabot>  Defined.
06:39:45 <ertes-w> :t letter
06:39:47 <lambdabot> Applicative f => (Integer -> f Integer) -> Char -> f Char
06:40:43 <ertes-w> ij: this interprets letters as integers and is a proper traversal up to equivalence of integers modulo 26
06:41:30 <ertes-w> > view (partsOf letter) 'c'
06:41:32 <lambdabot>  [2]
06:41:43 <ij> that is really cool
06:42:02 <ertes-w> > (view (partsOf letter) . set letter 28) 'c'
06:42:04 <lambdabot>  [2]
06:42:37 <ertes-w> ij: strictly speaking this is a violation
06:42:42 <jchia_> Do I need to understand profunctors or product-profunctors in order to use opaleye?
06:43:00 * hackage reprinter 0.2.0.0 - Scrap Your Reprinter  https://hackage.haskell.org/package/reprinter-0.2.0.0 (DominicOrchard)
06:43:03 <jchia_> For simple SELECT and INSERT queries.
06:43:06 <merijn> jchia_: Profunctors aren't that tricky, imo
06:44:05 <jchia_> merijn: OK, how long does it take to understand as a fraction of how long it takes to understand Functor, Applicative or Monad?
06:44:06 <ij> ertes-w, I get it.
06:44:30 <ij> ertes-w, I'm now wondering whether what I had in mind can be defended in similar manner.
06:44:31 <merijn> jchia_: The trick is the following: You can think of functors as "producers" i.e. "f a" is an 'f' that produces 'a'. Then fmap takes a producer of 'a' and turns it into a producer of 'b', since "fmap :: (a -> b) -> (f a -> f b)"
06:44:48 <Taneb> The Servant readthedocs mention "emptyServer" but I can't find this anywhere
06:44:49 <cocreature> you probably want to take a look at Contravariant before you tackle Profunctor
06:44:56 <merijn> jchia_: Then we have Contravariant functors, "contramap :: (a -> b) -> f b -> f a"
06:45:04 <Taneb> Anyone know where I might find what I'm looking for?
06:45:50 <cocreature> Taneb: you are probably using an old version, emptyServer definitely exists https://hackage.haskell.org/package/servant-server-0.12/docs/Servant-Server.html#v:emptyServer
06:45:51 <merijn> jchia_: A Contravariant functor is, essentially, a consumer. i.e. 'f a' is an 'f' that consumes 'a'. Contramap, then takes a consumer of 'a' and turns it into a consumer of 'b', since "contramap :: (a -> b) -> (f b -> f a)"
06:45:51 <jchia_> merijn: OK, I've read a bit on Contravariant before. How it applies to functions is straightforward enough.
06:46:19 <merijn> jchia_: Profunctor is basically a pipe! "Profunctor p => p a b" is something that consumes 'a' and produces 'b'
06:46:28 <Taneb> cocreature: ah, I'm stuck using the older version for now, do you know what it would correspond to?
06:46:57 <merijn> jchia_: So you can do "(r -> a) -> p a b -> p r b" to change what it consumes
06:47:24 <merijn> jchia_: Or you can do "(b -> r) -> p a b -> p a r" to change what it produces (this is just regular fmap)
06:48:51 <merijn> jchia_: So it's basically a contravariant functor in it's first argument and a regular functor in it's second argument
06:49:16 <cocreature> Taneb: afaik it simply doesn’t exist in servant < 0.11. you are going to have to write it yourself
06:49:31 <cocreature> Taneb: what’s stopping you from upgrading?
06:50:52 <ski> (aka a difunctor)
06:50:56 <jchia_> merijn: So, can you say "Profunctor p => Functor (p a)"? I don't see an instance in the doc, so probably not?
06:51:01 <Taneb> cocreature: at work we have a big nix expression we use for building everything and it's a pain to update which version of nixpkgs we want to use
06:51:50 <ski> jchia_ : that would overlap
06:52:11 <cocreature> Taneb: you don’t need to change everything. you can just override the servant version in your existing nix config
06:52:23 <ertes-w> ij: the alternative would be to realise the equivalence relation as a concrete type that encodes equivalence classes
06:52:32 <Taneb> cocreature: that's a good point
06:52:34 <MarcelineVQ> interesting that's not the response I expected, usually people don't want to change ghc versions because it's a pain some places, but nix should make that pretty straightforward, if you can read nix
06:52:43 <ertes-w> ij: for example 'letter' might be of this type:  Traversal' Char (Mod 26)
06:52:56 <ertes-w> ij: where (Mod 26) is the type of equivalence classes modulo 26
06:53:29 <MarcelineVQ> rather, people tend to get version restricted because it's a hassle to change ghc versions. or sometimes some bug exists in different versions
06:53:41 <callmecabman> mniip: in the original case we could've treat that preorder category as enriched over the categorical interval
06:53:48 <MarcelineVQ> thinking on it, it's probably more the latter :X
06:54:02 <ertes-w> ij: and that's what makes the original version of 'letter' morally ok:  you *could* rewrite it this way and promote the equivalence relation to equality
06:54:13 <cocreature> MarcelineVQ: depends on how deep the package is in your dependency chain. nix defaults to something like stackage lts so if you want to upgrade a package deep in the hierarchy you are probably going to have to change a lot of other packages as well
06:54:21 <cocreature> MarcelineVQ: e.g. upgrading QuickCheck is quite painful with nix
06:54:59 <callmecabman> mniip: don't you just state that your functor is an inclusion of the categorical interval into our category? I mean it doesn't introduce any new information
06:55:05 * ski finds the use of "morally" in math strange
06:55:27 <Taneb> MarcelineVQ: we're tied to a particular version of GHC due to other dependencies
06:55:32 <mniip> callmecabman, well representable functors have to go into the enriching category
06:55:33 <callmecabman> s/inclusion/whatever you call it/
06:55:36 <mniip> and F was an endofunctor
06:55:38 <cocreature> and iteratively figuring out which packages also need to be updated is also really slow since you only get the mismatches when the packages are actually being built. there is no dependency solving phase before that
06:55:51 <Taneb> That said, I've just found out we're specifying an old version of servant specifically, for reasons that don't hold any more
06:56:03 <ertes-w> ski: i can't think of a better word…  it's technically incorrect, but it's "still somewhat sound"
06:56:14 * ski nods
06:56:21 <mniip> but do mind that I don't actually have any idea what I'm talking about as I've never looked at preorder categories this way before
06:59:39 <callmecabman> mniip: I'm no expert in this area but what about the arbitrary choice of X and Y, does it affect representability of the F in question?
07:00:49 <MarcelineVQ> "<cocreature> MarcelineVQ: e.g. upgrading QuickCheck is quite painful with nix" this is an unhappy thing :(
07:03:03 <alp> Taneb, you might like 'callHackage' in nix, which will make overriding the servant versions soooo simple
07:03:53 <Taneb> alp: investigating it, we were specifying an old version of servant due to a dependency we're no longer using!
07:04:50 <alp> heh okay, well let me/us know if you need any help coming up with a simple change to override servant :)
07:06:14 <mniip> callmecabman, no idea actually not sure if that hom-functor is a functor after all
07:07:06 <callmecabman> mniip: consider A >= C >= B, does it preserve composition?
07:07:34 <callmecabman> speaking of Hom(A,B) Hom(B,C)
07:17:52 * hackage streamly 0.1.0 - Beautiful Streaming, Concurrent and Reactive Composition  https://hackage.haskell.org/package/streamly-0.1.0 (harendra)
07:19:00 <jchia_> In the code for Data.Profunctor.Unsafe, there is a Profunctor instance of (->), and no mention of LiftedRep, but in the haddock I can't find the Profunctor instance of (->) but instead find "Profunctor ((->) LiftedRep LiftedRep)". Is this a haddock bug or am I missing something? https://www.stackage.org/haddock/nightly-2017-12-05/profunctors-5.2.1/Data-Profunctor-Unsafe.html
07:19:43 <jchia_> Just looking at the haddock I wouldn't know there's a Profunctor instance for (->)
07:19:53 <lyxia> That is the Profunctor instance of ->
07:20:13 <centril> Is the following a valid definition of a functor typeclass?  class (Category s, Category c, Category d) => Functor c d e t where fmap :: e (c a b) (d (t a) (d t b))  ?
07:20:31 <lyxia> jchia_: it links to https://www.stackage.org/haddock/nightly-2017-12-05/profunctors-5.2.1/src/Data.Profunctor.Unsafe.html#line-191 which looks fine
07:20:47 <lyxia> jchia_: I guess it's a Haddock bug.
07:21:06 <lyxia> jchia_: it's exposing details irrelevant to 99% of the population.
07:22:33 <jchia_> lyxia: Yeah, the code has the (->) instance.
07:25:09 <ski> centril : did you mean s/d t b/t b/ ?
07:26:15 <centril> ski:  fixed:  e (c a b) (d (t a) (t b))
07:27:19 <centril> c a b -> d (t a) (t b)  feels like unnecessarily blessing (->)
07:27:21 <ski> hm, `s' is unused ?
07:27:35 <ski> perhaps the presupposed instances for `c' and `d' should be conditioned on `e' ?
07:27:39 <centril> ski: im a klutz :P
07:27:40 <centril> sec
07:27:52 * hackage quickcheck-classes 0.2 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.2 (andrewthad)
07:28:50 <centril> ski: class (Category e, Category c, Category d) => Functor e c d t where fmap :: e (c a b) (d (t a) (t b))
07:28:51 <lyxia> centril: A Functor is given by a *mapping* between morphisms, which (->) represents
07:29:16 <lyxia> How do you translate the law "fmap id = id"
07:30:02 * ski thinks centril is thinking about enriched categories
07:30:04 <lyxia> I guess there could be something more general but that wouldn't be a "Functor", would it?
07:30:44 * ski . o O ( categories enriched over preorders )
07:31:34 <centril> lyxia: good question =)
07:31:37 <lyxia> ski: oh that sounds good
07:32:25 * ski . o O ( Lawvere, metric spaces, mumble mumble )
07:32:46 <centril> ski: so I was thinking if we could take m0ar's functors ( (a -o b) -> (f a -o f b), (a -o b) -o (f a -o f b) ) and put them under one type-class
07:33:00 <centril> https://m0ar.github.io/safe-streaming/2017/07/20/homegrown-linear-monads.html
07:46:54 <orion> What libraries should I look at (besides Haxl) if I want to record and replay IO for unit testing purposes?
08:00:53 * hackage quantification 0.3 - Rage against the quantification  https://hackage.haskell.org/package/quantification-0.3 (andrewthad)
08:18:12 <tabaqui> I'm wondering about migration from vim to spacemacs
08:18:35 <tabaqui> are vim haskell plugins compatible with SM?
08:21:17 <siwica> Can the compiler check any properties of typeclass functions or do the basically only exist by convention? E.g. Would it be possible to have an instance of Eq that implements (==) in a non-symmetric way and have the code compiling?
08:21:34 <siwica> *they
08:21:36 <ertes-w> siwica: laws aren't checked
08:21:44 <ertes-w> siwica: they are a contract
08:21:57 <ertes-w> if you implement an Eq instance, you promise that you follow the laws
08:22:23 <siwica> Ok! 
08:22:39 <ertes-w> siwica: some limited form of checking would be possible, but then the laws wouldn't be comments, but actual code
08:23:22 <ertes-w> siwica: mostly in the form of type-level propositions that you need to prove as part of the instance
08:23:49 <ertes-w> siwica: haskell is not well suited for this sort of thing though
08:24:45 <siwica> Are there any efforts in this direction or is this a dead-end, since you can't prove most things for arbitrary types anyways?
08:25:29 <EvanR> you cant prove... anything for an arbitrary type
08:25:43 <ertes-w> siwica: there are actually many efforts in that direction, the most important of which is the move towards dependent typing
08:26:36 <ertes-w> siwica: haskell supports lightweight dependent typing right now, but it requires many type system tricks and explicit translation between types and values…  it's not fun to use
08:26:38 <marvin2> tabaqui no, emacs ones are.
08:26:51 <EvanR> "lighweight'
08:27:02 <EvanR> why is it called that
08:27:12 <ertes-w> no idea…  it's all but lightweight =)
08:27:34 <siwica> ertes-w: Ok, interesting! Do you have a good resource at hand to learn about dependent typing?
08:27:38 <lyxia> siwica: For lightweight use cases there are ghc-proofs and LiquidHaskell.
08:28:00 <lyxia> Sometimes testing is possible, see the checkers library.
08:28:18 <ertes-w> siwica: to really learn it you should probably use a proof assistant based on type theory
08:28:42 <lyxia> And now there's also hs-to-coq
08:28:47 <ertes-w> siwica: agda and coq come to mind…  while coq is a lot more practical, agda is much closer to what dependent typing would look like in haskell
08:29:15 <EvanR> except for literally the look
08:29:16 <tabaqui> marvin2: I know, but ghc-mod, lushtags and other don't work on emacs?
08:29:24 <ertes-w> siwica: and here is a taste of what lightweight dependent typing looks like in haskell, if you're serious about it: http://lpaste.net/109388
08:29:50 <ertes-w> siwica: note that the paste is from a couple of years ago…  some parts of it can be done more easily now thanks to the TypeInType extension, which didn't exist back then
08:30:12 <tabaqui> *do bla-bla not work on emacs?
08:30:30 <tabaqui> hm, we need to do something with word order
08:30:53 <siwica> ertes-w: Thank you. I will have a look nonetheless. All this is very new to me.
08:34:25 <ertes-w> siwica: if you've never seen dependent typing before, most of the paste will probably make little sense to you, except for the prose parts
08:35:10 <siwica> ertes-w: Yeah, I was actually hoping for a more general introduction
08:36:18 <ertes-w> siwica: first a word of warning: returning to haskell from a dependently typed language can be very depressing =)
08:36:45 <EvanR> i could only "get" DT after messing around with it. the docs i found are mostly rehashes of the Vect type...
08:37:42 <ertes-w> siwica: if you still want to enter the rabbit hole, you should probably just have a look at agda…  again, it's not very practical as a proof assistant, but it does support everything you need, and it's very similar to haskell
08:38:56 <EvanR> its not?
08:39:20 <siwica> Ok, I will have a look at some point
08:39:45 <siwica> Rabbit holes unfortunately tend to be huge time sinks :)
08:39:49 <ertes-w> EvanR: the lack of tactics shows
08:40:16 <EvanR> i thought people considered this a feature heh
08:44:04 <ertes-w> EvanR: that's not the only thing…  have you ever tried to do category theory in agda?
08:44:11 <ertes-w> Functor takes six level arguments
08:44:24 <EvanR> well yeah
08:44:41 <EvanR> its interesting how much context is hidden when doing things the "human" way
08:45:00 <ertes-w> just fixing the approach to universes would make it vastly more practical
08:45:05 <EvanR> i guess youre saying the implicits dont help very much
08:45:13 <ertes-w> correct
08:45:26 <EvanR> since you often have to explicitly pass them
08:45:53 <ertes-w> strictly hierarchial universes are just horrible to work with…  i much prefer the cumulative universes of…  well…  every other proof assistant out there =)
08:46:52 <ertes-w> and you practically never pass a single level argument around in those…  in fact i think in coq you *can't*, even if you wanted
08:48:13 <ertes-w> the lack of tactics is a major headache for equational reasoning…  have a complicated equivalence over a ring?  just say "ring", and the ring tactic will prove it completely, automatically
08:48:17 <ertes-w> "ring", done, proved
08:48:27 <ertes-w> agda: 50-100 lines of deep rewriting
08:48:35 <ertes-w> i'm not exaggerating…  i've done it before
08:48:54 <EvanR> how does it solve that
08:49:07 <ertes-w> you prove the ring structure, then the ring tactic uses the ring laws
08:49:19 <cheater> hi
08:49:34 <cheater> i am encountering a long standing bug in ghci and i was wondering if anyone knew any workarounds
08:49:51 <cheater> my prompt looks like this: :set prompt ";1m%s;1m>m "
08:50:20 <cheater> sorry... that's wrong
08:51:16 <cheater> it uses escape sequences for colour etc. basically it's :set prompt "^[[32;1m%s^[[34;1m>^[[0m " except the ^[ are literal (they're the ascii code for escape).
08:51:43 <cheater> when the edit line gets longer than one terminal line, the display gets messed up because it seems haskelline does not account for the escape sequences when figuring out where to position the caret.
08:51:55 <cheater> is there a workaround for this?
08:52:01 <cheater> i assume ghci uses haskelline
08:52:27 <cheater> hmm.. apparently not, it uses its own thing
08:53:39 <Unode> cheater: easiest solution, add \n at the end
08:54:24 <Unode> your input goes in a line of its own. Otherwise, I don't know.
08:55:15 <Unode> I struggled with this too but gave up and went with a minimalistic prompt.
08:55:41 <glguy> Playing Advent of Code this year? Join the #haskell group: http://adventofcode.com/2017/leaderboard/private 43100-84040706
08:56:24 <pja> I’m quietly doing Haskell Of Code in the #lobsters group as my Haskell is terrible :)
08:56:41 <cheater> adding \n does not fix that Unode
08:56:50 <sdhand> pja: do you have the join code for #lobsters?
08:56:53 <shapr> pja: w00, yay writing code!
08:56:54 <sdhand> I don't see it in the topic
08:57:11 <cheater> oh wait it does
08:57:16 <shapr> I've been distracted by trying to build a SIP stack
08:57:17 <cheater> thanks unode
08:57:20 <Unode> welcome
08:57:27 <cheater> anyways this bug has existed for 3 years https://ghc.haskell.org/trac/ghc/ticket/9364
08:57:34 <cheater> i hope someone can take a look at it and fix it
08:57:56 <Unode> cheater: will probably only go away when a more sophisticated readline is implemented.
08:58:06 <pja> sdhand: It’s in https://lobste.rs/s/hbusss/advent_code_2017 somewhere.
08:58:10 <sdhand> cheers
08:58:24 <[Leary]> @let f ^.^ g = \x y -> f (g x) (g y)
08:58:25 <lambdabot>  Defined.
08:58:39 <[Leary]> @let (^.^) :: (f2 a1 -> f2 a2 -> b) -> (forall a. f1 a -> f2 a) -> f1 a1 -> f1 a2 -> b
08:58:40 <lambdabot>  Defined.
08:58:50 <[Leary]> > ((<*>) ^.^ maybeToList) (Just (2*)) (Just 3)
08:58:53 <lambdabot>  [6]
08:58:56 <Unode> shapr: lobsters = rust?
08:59:06 <[Leary]> Does anyone know how to type this so it's more general?
08:59:17 <sdhand> I'm doing considerably better in the lobsters one than I am in the #haskell one heh
08:59:31 <shapr> Unode: oh, I thought it was lobste.rs ?
08:59:47 <Unode> sdhand: I can relate.
08:59:59 <lyxia> :t ((<*>) ^.^ maybeToList)
09:00:00 <lambdabot> Maybe (a -> b) -> Maybe a -> [b]
09:00:12 <pja> No, lobsters is programming people. A little rust maybe, but lots of other stuff too.
09:00:33 <Unode> pja: just wondered given .rs
09:00:48 <[Leary]> To clarify, I mean typing ^.^, not the example usage.
09:00:51 <sdhand> lobste.rs seems to contain a fair few people interested in rust and *bsd especially
09:00:52 <Unode> and the whole c'rust'aceans theme :)
09:00:56 <pja> Unode: It’s not an unreasonable assumption to make :)
09:01:13 <lyxia> [Leary]: you could apply maybeToList at the end
09:01:15 <sdhand> those are two topics I see come up a lot there at least
09:01:42 <lyxia> :t \x y -> f (g x) (g y)
09:01:43 <lambdabot> error:
09:01:43 <lambdabot>     • Could not deduce (Show t0) arising from a use of ‘f’
09:01:43 <lambdabot>       from the context: (FromExpr t3, Show t2, Show t)
09:01:51 <lyxia> :t \f g x y -> f (g x) (g y)
09:01:52 <lambdabot> (t1 -> t1 -> t2) -> (t3 -> t1) -> t3 -> t3 -> t2
09:01:59 <lyxia> [Leary]: ^ that looks pretty general
09:02:19 <lyxia> ah I forgot the forall, nvm.
09:02:27 <lyxia> :t \f g x y -> g (f x y)
09:02:28 <lambdabot> (t1 -> t2 -> t3) -> (t3 -> t4) -> t1 -> t2 -> t4
09:03:35 <lyxia> [Leary]: ^ does that suit your needs
09:04:39 <pja> I have joined the #haskell adventofcode leaderboard. Just sneaked into the top 20 :)
09:06:06 <[Leary]> Nah lyxia, in general the g may need to be preprocessing, like wrapping or unwrapping something /before/ f is can be applied.
09:10:22 * hackage hflags 0.4.3 - Command line flag parser, very similar to Google's gflags  https://hackage.haskell.org/package/hflags-0.4.3 (MihalyBarasz)
09:10:51 <lyxia> [Leary]: I see. That sounds tricky to generalize...
09:11:44 <lyxia> [Leary]: And I guess the goal would be like something that uses only rank1 types?
09:14:27 <[Leary]> I'm happy to use RankNTypes. I just can't see how they'll allow for the full generality it should be able to support.
09:15:52 <[Leary]> You can remove all the f1s (x)or all the f2s from that type declaration and get two more functions with exactly the same definition.
09:25:38 <lyxia> Unifying those two definitions will cause type inference issues.
09:27:45 <lyxia> In one case, ^.^ typechecks when g is monomorphic because it's applied to the same type twice
09:27:59 <lyxia> In the other, g is polymorphic and is applied to two compatible types
09:28:55 <lyxia> A straightforward way of generalizing that is to consider that in the first case g is polymorphic, but actually its type is constant.
09:29:06 <lyxia> But to typecheck you now need higher-order unification...
09:30:22 * hackage hpp 0.5.1 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.5.1 (AnthonyCowley)
09:46:59 <siwica> GHCI can apparently warn about non-exhaustive pattern matching with :set -Wall. Is this guaranteed to work for any type?
09:47:49 <daey> are all functions in haskell that take generics like [a] monads?
09:49:17 <Cale> daey: You mean type-level functions?
09:49:29 <Cale> (still no)
09:49:45 <daey> well i have no idea what i mean, im trying to grasp the concept of monads
09:49:58 <Cale> A monad is a type level function, something of kind * -> *
09:50:04 <daey> but it says monads are used to create generic types
09:50:08 <Cale> which supports a particular API
09:50:30 <daey> and imho a -> String would be something generic
09:50:48 <Cale> That's a polymorphic type, but it has kind *
09:50:50 <fishythefish> Monads can help with generic code, but not all generic code is implemented with Monads :)
09:51:05 <daey> yeah i figured that would be the case :/
09:51:07 <Cale> and even if we make a newtype, such as
09:51:25 <Cale> newtype ToString a = TS (a -> String)
09:51:34 <Cale> ToString won't be a Monad
09:51:44 <Cale> (it won't even be an instance of Functor)
09:59:16 <rickkpol> Hello
09:59:49 <rightfold> rickkpol: Hi there 🤩
10:00:53 <rickkpol> Rightfold: this is my first time on this and checking it out
10:01:07 <rightfold> daey: there are lots of functions that work on all monads
10:01:15 <Cale> rickkpol: Hello! Feel free to ask any questions you have about Haskell
10:01:17 <rightfold> So you could call those functions “generic”
10:01:36 <rightfold> Because they have few requirements
10:01:39 <Cale> daey: Are you familiar with kinds?
10:01:53 <daey> Cale: yeah i was about to ask. how much math theory do i require?
10:01:54 <Cale> :k Maybe
10:01:55 <lambdabot> * -> *
10:01:56 <rightfold> For example: mapM
10:02:09 <Cale> daey: None, but you should know some bits of Haskell :)
10:02:10 <daey> because i have close to...zero 
10:02:24 <Cale> Kinds are like types of types
10:02:30 <Cale> :k Integer
10:02:31 <lambdabot> *
10:02:42 <Cale> All the types which are inhabited with ordinary values have kind *
10:02:48 <Cale> :k [String]
10:02:49 <lambdabot> *
10:03:04 <daey> my math skills stop at university math 2/3. which never included any category theory or anything related to it
10:03:11 <Cale> Type level functions which accept an ordinary type and produce another type have kind * -> *
10:03:32 <Cale> :k [] -- this is not the empty list, but rather the prefix form of the list type constructor
10:03:33 <lambdabot> * -> *
10:03:38 <Cale> :k IO
10:03:39 <lambdabot> * -> *
10:03:41 <rickkpol> What type of programming is this near too ?
10:03:41 <Cale> :k Maybe
10:03:42 <lambdabot> * -> *
10:03:59 <Cale> rickkpol: Haskell? It's a functional programming language
10:04:20 <rickkpol> Oh okay
10:04:45 <rightfold> rickkpol: Haskell makes it easy to do functional programming, i.e. programming with functions, which are mappings from values to other values with no side effects
10:05:05 <rightfold> You can do this in many languages, but Haskell makes it particularly easy
10:05:05 <Cale> Similar to some extent to the languages in the ML family, but it has nonstrict semantics (it's lazily evaluated). It has a relatively powerful static type system.
10:05:56 <rickkpol> Cale thanks for clarifying that for me
10:08:16 <Cale> daey: So, in order to have a monad, you need a type M of kind * -> *, and then you need some particular functions. Specifically, the definition we use requires you to write  return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b
10:08:47 <Cale> daey: Typically, M t will be some type of "computations having results of type t"
10:09:21 <Cale> and then return will give you the computation which "does nothing" (whatever that means in context), and produces the given result
10:09:54 <Cale> and (>>=) will take some initial computation, and a function which given its result will compute what to do next, and combine them somehow
10:11:02 <rightfold> I like to contrast return with id and (=<<) with ($)
10:12:13 <Cale> daey: So for example, we might have a type of parsers, where a value of type Parser t is something that will try to eat some initial portion of a string before resulting in a value of type t (perhaps in many different ways, depending on what sort of parsers we're talking about)
10:12:36 <ania123> let us know please your arrival date and also hotel where will you stay.
10:12:49 <ania123> can one point me if there is some errors? 
10:12:59 <Cale> daey: return v  will be the parser which succeeds without eating any of the input, and produces v as its result
10:13:44 <mud> ania123: This is the #haskell programming language channel, perhaps you're looking for ##English ?
10:13:50 <Cale> daey: x >>= f  will be the parser which first runs the parser x on the initial part of the input, and then if it succeeds (for each way in which it succeeds) producing some result v, runs the parser f v on the remainder of the input
10:14:17 <Cale> daey: Most of the monads you'll run into will follow a pattern something like this
10:14:24 <ania123> us, sorry 
10:17:34 <Cale> daey: Does that make any kind of sense?
10:22:17 <daey> hmm
10:25:27 <daey> i think i will throw more books at the problem. my normal learning approach isnt working for this
10:26:23 <Cale> daey: You might want to read my tutorial...
10:26:36 <Cale> https://wiki.haskell.org/Monads_as_computation
10:27:20 <Cale> Well, it's not so much a tutorial as a little intro regarding what monads are about.
10:27:30 <daey> will check it out
10:27:49 <Cale> But basically the only way to really understand is to look at lots of actual examples of monads
10:28:11 <Cale> Just using a handful of different monads will give you a good sense of what they're about in general
10:28:19 <daey> yeah i thought i would just checkout a monad implemented in c. what can be so hard about it :D
10:28:34 <mniip> monads don't quite work in C
10:28:41 <mniip> it has no parameterized types
10:28:48 <mniip> nothing to even mimick endofunctors
10:29:02 <cocreature> learning Haskell by searching for corresponding examples in C is going to be … challenging
10:29:07 <mniip> even C++ will have a tiny bit of an issue with backwards type inference for the return operation
10:35:04 <cheater> hi
10:36:01 <dmwit> daey: There is no shortage of monad tutorials on the web. I especially liked "You Could Have Invented Monads (and Maybe You Already Have)".
10:36:14 <dmwit> I also liked "All About Monads" as a followup.
10:36:21 <cheater> i am reading up on denotational semantics and the book mentions the ability to write out your language's denotational semantics and use a tool that automatically generates the parser and compiler. i would like to define a small simple context-free total language. is there a tool like this that can be used with haskell?
10:37:07 <mniip> cheater, denotational semantics as in the grammar?
10:37:22 <cheater> yes
10:38:03 <mniip> well there's alex and happy
10:38:15 <cheater> those generate parsers, right?
10:38:29 <cheater> what about compilers?
10:38:29 <mniip> yes
10:39:10 <mniip> not sure if I've heard of a compiler generator
10:39:23 <mniip> maybe only via an intermediate language
10:39:53 <lyxia> you could have happy output your denotational semantics straight away
10:46:56 <dmwit> daey: (...one feature they have in common is exactly the one Cale mentioned: they just walk you through a lot of actual examples of monads.)
10:50:22 * hackage jvm 0.4.0 - Call JVM methods from Haskell.  https://hackage.haskell.org/package/jvm-0.4.0 (MathieuBoespflug)
10:51:03 <drdo> Is there some haskell library to visualise trees? In particular one that can handle very large trees
10:51:51 <dmwit> There is a graphviz package. But it chokes on very large trees. =(
10:52:04 <drdo> dmwit: Yeah, graphviz isn't very nice for this
10:52:09 <dmwit> (Not the Haskell's fault. The graphviz tools just weren't designed for modern-sized data.)
10:52:28 <drdo> I mean seriously large
10:52:41 <mud> "very large" is always relative. How big are we talking?
10:52:43 <drdo> Like tens of megabytes of textual representation
10:53:01 <cocreature> I have a Haskell implementation of the linear-time algorithm for drawing n-ary trees but I haven’t gotten around to packaging it up :/
10:53:35 <cocreature> and it only calculates coordinates, creating an image based on that is up to you
10:53:50 <Cale> daey: return is hard
10:54:05 <Cale> daey: It's polymorphic in its result type in a way that can't be determined from its argument
10:54:08 <Cale> :t return
10:54:10 <lambdabot> Monad m => a -> m a
10:55:02 <drdo> So there's nothing done for me in this area? :P
10:55:09 <Cale> daey: Well, and that would be tricky in something like Java even, let alone C.
10:55:23 <dmwit> drdo: I think that's basically right. Sorry...
10:55:35 <drdo> You guys know something else in some other language?
10:55:51 <drdo> Doesn't have to generate any particular format, just showing me a scrollable gui is fine
10:55:58 <cocreature> drdo: I could probably throw my code on github if you want to be the one that cleans it up :)
10:56:47 <cocreature> drdo: d3.js can draw trees
10:56:49 <drdo> cocreature: hmm, what's the fastest way to get something on the screen? :P
10:56:52 * hackage inline-java 0.7.1 - Java interop via inline Java code in Haskell modules.  https://hackage.haskell.org/package/inline-java-0.7.1 (MathieuBoespflug)
10:57:00 <drdo> cocreature: Yeah, I was using some other js lib now, but it's just too solw
10:57:02 <drdo> *slow
10:57:26 <cocreature> drdo: well d3 has at least implemented the “right” (i.e. the linear-time) algorithm
10:57:26 <crucify_me> I woke up confused about the last unification of foldr (.) id     ..     I have foldr (.) :: (a' -> b') -> t (b' -> b') -> a' -> b'       so when we unify id with that, how do I think of how id is substituted for the first parameter (a' -> b') 
10:57:27 <dmwit> drdo: Everything I know that is actually usable is of the form "first identify a smaller subgraph that you're interested in looking at right now. then I'll draw that".
10:57:28 <crucify_me> ?
10:57:37 <crucify_me> I had this the other day
10:57:41 <cocreature> so depending on what the lib you used before implemented, it might be worth a shot
10:57:58 <drdo> dmwit: Yeah, doesn't really work for my purposes :S
10:58:14 <dmwit> drdo: Usually you want the "identify a smaller subgraph" piece can be a little bit interactive, but as far as I know nothing is good for just displaying an entire big graph.
10:58:26 <daey> drdo: <3
10:58:28 <drdo> It's really a tree though, not a general graph
10:58:40 <dmwit> doesn't really matter, AFAIX
10:58:55 <dmwit> ...and I obviously don't xnow much. =P
10:59:07 <crucify_me> sorry to those helping me, I'm almost there but I lost the last unification
10:59:16 <cocreature> well the algorithms for drawings trees tend to be special
10:59:18 <cocreature> so it does matter
10:59:32 <drdo> Sounds a lot harder to properly draw a graph to be honest
10:59:42 <cocreature> it is
10:59:43 <drdo> Though I haven't investigated that
10:59:57 <dmwit> Theoretically there may be better algorithms for trees. Practically all the tools I know of that are usable for big trees can also handle big graphs (and were designed for big graphs).
11:00:15 <drdo> graphviz doesn't like big anything
11:00:50 <cocreature> diagrams also has a module for tree drawing but diagrams being slow was the whole reason why I implemented it myself in the first place :)
11:00:54 <dmwit> crucify_me: Write `id :: c -> c`. Then unify `c -> c` with `a' -> b'`.
11:00:54 <cocreature> so that’s not going to be helpful
11:01:23 <drdo> cocreature: What do I need to do to get that working? What would be the fastest way to get something on the screen? :P
11:01:39 <drdo> I'm actually trying to solve some other problem, not just draw trees for fun xD
11:01:56 <cocreature> drdo: well as I said that only generates coordinates, so it depends on how long it takes you to get from “here’s a tree annotated with coordinates” to an svg or whatever
11:02:06 <crucify_me> dmwit so the whole parameter (a' -> b') becomes (c -> c)  ?
11:02:30 <cocreature> drdo: I would probably give d3.js a shot before you do that
11:02:46 <dmwit> crucify_me: yes
11:04:01 <drdo> cocreature: You sure that supports trees?
11:04:06 <cocreature> drdo: yes
11:04:22 <dmwit> drdo: You might consider looking into Gtk's tree tools. They put some thought into making them lazy, so the typical interaction mode is to show just the roots, then the user clicks on a root and expands the children of that root, then expands the children of some child, etc.
11:04:32 <cocreature> drdo: https://github.com/d3/d3-hierarchy/blob/master/README.md#tree
11:04:51 <drdo> dmwit: Won't help, I'm likely to get trees with insane branching factor at the root
11:04:51 <dmwit> drdo: Since everything is user-driven, you typically only see a small sub-graph of the tree, one that's computationally feasible to completely dra.w
11:05:35 <crucify_me> so we have foldr (.) id :: Foldable t => t (c -> c) -> (c -> c)  , dropping the last set of parens     dmwit 
11:05:57 <dmwit> :t foldr (.) id -- let's check!
11:05:58 <lambdabot> Foldable t => t (b -> b) -> b -> b
11:06:09 <dmwit> crucify_me: looks good to me
11:06:29 <crucify_me> I went through this extensively with member here, then lost it !
11:06:32 <crucify_me> dmwit, 
11:12:03 <crucify_me> dmwit id seems unique, in the way in which it unified. It can only unify into a parameter of 2 elements, as in our case, right? 
11:12:18 <crucify_me> the way in which it *unifies
11:12:19 <fishythefish> crucify_me: what does "a parameter of 2 elements" mean?
11:12:39 <crucify_me> sorry friend! I just sort of lost hold of this fishythefish 
11:12:58 <fishythefish> id is generally pretty flexible due to its polymorphic type
11:13:14 <crucify_me> two elements meaning...
11:13:35 <crucify_me> a' and b' in the first param of the type foldr (.)
11:13:40 <fresheyeball> is there a flipped applicative operator?
11:13:43 <fresheyeball> like
11:13:45 <fishythefish> :t foldr (.)
11:13:46 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
11:14:12 <fishythefish> crucify_me: are you referring to the (a -> b) at the beginning?
11:14:15 <fresheyeball> f <$> x <*> y <*> z = x <?> y <?> z <&> f
11:14:25 <fresheyeball> where <?> is the operator I am looking for
11:14:33 <crucify_me> yes, that is where we do the substitution
11:15:02 <zachk> fresheyeball you could make those with flip and infixl I believe
11:15:02 <crucify_me> when the first unification we worked on is done, foldr (.) ...
11:15:08 <fishythefish> fresheyeball: lens defines <&> like that, I believe
11:15:18 <fresheyeball> fishythefish: yeah it does
11:15:24 <fishythefish> crucify_me: in what way is that a "parameter of 2 elements"?
11:15:25 <fresheyeball> but not applicative flip 
11:16:01 <fishythefish> fresheyeball: ah, gotcha.
11:16:06 <fishythefish> :t (<**>)
11:16:07 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
11:16:16 <crucify_me> each type in the first param is replaced by a separate function, right?    ok that is poor terminology fishythefish 
11:16:45 <fresheyeball> :i 
11:16:50 <fresheyeball> :i (<**>_
11:16:53 <fresheyeball> :i (<**>)
11:16:53 <fishythefish> crucify_me: no, the type (a -> b) is the type of a function with an input of type a and an output of type b
11:17:16 <zachk> :t <*>
11:17:17 <lambdabot> error: parse error on input ‘<*>’
11:17:25 <cocreature> fresheyeball: lambdabot doesn’t do :i
11:17:25 <fishythefish> :t (<*>) -- zachk 
11:17:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:17:26 <zachk> :t (<*>)
11:17:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:17:34 <fishythefish> fresheyeball: should be defined in Control.Applicative
11:18:30 <mniip> % :i <**>
11:18:35 <yahb> mniip: [Timed out]
11:18:37 <mniip> oh please
11:18:38 <mniip> % :i <**>
11:18:40 <crucify_me> what I mean is there are only two types (a' -> b') to be substituted, so we substitute in (c -> c) as dmwi*t suggested. a is replaced by c and b is replaced by c to get (c -> c)
11:18:44 <yahb> mniip: [Timed out]
11:18:48 <mniip> % 1
11:18:50 <yahb> mniip: 1
11:18:51 <mniip> % :i <**>
11:18:52 <yahb> mniip: (<**>) :: Applicative f => f a -> f (a -> b) -> f b -- Defined in `GHC.Base'; infixl 4 <**>
11:18:55 <mniip> :s
11:19:02 <fishythefish> crucify_me: yes
11:19:46 <fishythefish> crucify_me: that doesn't mean that c -> c only unifies with such a type though
11:22:24 <crucify_me> so ie fishythefish id can only be unified with a function that has a 2-type 1st parameter ie (y -> z)
11:22:33 <fishythefish> crucify_me: no
11:23:47 <crucify_me> yikes...
11:24:15 <crucify_me> the first unification of foldr (.) is a bit complicated, but I see how it works fine. 
11:24:50 <crucify_me> then that composed function has (a -> b) as the first parameter
11:25:42 <crucify_me> so in another case with 3 types in the 1st parameter, say (r -> s -> t), we can also unify id with that
11:25:53 <fishythefish> crucify_me: yes. as an exercise, perform that unification
11:26:14 <crucify_me> (r -> s -> t) -> (r -> s -> t)
11:26:17 <fishythefish> (by the way, the position of that parameter is not really relevant)
11:26:47 <crucify_me> is that wrong what I did ?
11:27:04 <fishythefish> crucify_me: not quite. let id have the type a -> a. then unification entails setting a -> a ~ r -> s -> t and proceeding from there
11:29:24 <crucify_me> the position of that parameter is not really relevant?
11:30:47 <crucify_me> so if we have a -> a ~ r -> s -> t    whatever is in the parameter is easily replaced with a -> a  ?
11:31:00 <MarcelineVQ> crucify_me: (r -> s -> t) is read as (r -> (s -> t))    which is also a hint
11:31:02 <fishythefish> crucify_me: unification is just about solving an equality of types. it doesn't matter whether this occurs in the first argument to a function or the hundredth
11:32:51 <crucify_me> ok I'm lost then sorry
11:32:53 <fishythefish> crucify_me: an equality of function types can be decomposed into two simpler type equalities. how do we do that?
11:34:17 <mnoonan_> maybe writing the types in prefix form would help?  (->) a a ~ (->) r ((->) s t)
11:34:51 <crucify_me> well, in the case where you do right association like MarcelineVQ suggested ^ 
11:35:08 <fishythefish> (we always do right association)
11:35:32 <crucify_me> let me paste my notes from the other day
11:37:03 <crucify_me> http://lpaste.net/360531
11:37:51 <crucify_me> after line 18 my notes became poor
11:38:49 <fishythefish> well, also, those notes are about a particular example, but it's not the one i'm asking about at the moment
11:40:28 <crucify_me> I can't generalize about the process because I thought the substitution is done in the first param
11:41:13 <crucify_me> the first param disappears and the changes are transferred to the remainder of the type signature
11:41:28 <crucify_me> as in the case of foldr (.)
11:42:12 <crucify_me> foldr (.) :: (a' -> b') -> t (b' -> b') -> a' -> b'
11:42:15 <fishythefish> crucify_me: well, if you take the view that all functions are unary, this is correct
11:42:55 <crucify_me> I'm just looking for a formula to work on the next one, say const id
11:43:09 <fishythefish> however, your wording made it sound like `foldr (.) id` would be invalid since id is not the first argument of foldr (adopting your normal view that functions can be n-ary), and this is incorrect
11:43:20 * Sb server istanbul.tr.undernet.com.tr
11:43:21 <daey> why does haskell have a 'negate' function? how does it differ from '-a'
11:43:27 <fishythefish> crucify_me: sure, that's a good exercise. work out the type of `const id`
11:44:02 <fishythefish> daey: because e.g. (- 1) is a function subtracting 1, not the negative of 1
11:44:15 <fishythefish> er
11:44:17 <ahihi> fishythefish: that's why subtract exists, not negate
11:44:17 <fishythefish> reverse that
11:44:25 <crucify_me> no I didn't mean that about id not being the 1st argument
11:44:28 <Sb> ??
11:45:03 <daey> fishythefish: ah (-) :: Num a => a -> a -> a
11:45:09 <ahihi> i think negate mainly exists because you can't pass unary minus as a function
11:45:21 <ahihi> > map negate [1,2,3]
11:45:23 <lambdabot>  [-1,-2,-3]
11:45:27 <fishythefish> yeah, the point i was trying to get across (badly) is that - is overloaded as a symbol
11:45:38 <fishythefish> i should have said (-) 1
11:45:55 <crucify_me> I was looking at it as "plugging in " and transforming the first argument of fold (.) which is (c -> c) being plugged into (a -> b) or as we had it (a' -> b')
11:46:25 <fishythefish> :t foldr (.) -- crucify_me 
11:46:26 <lambdabot> Foldable t => (a -> b) -> t (b -> b) -> a -> b
11:46:35 <fishythefish> the type of the first argument is not c -> c; that's the type of id
11:46:49 <crucify_me> I know but to do the unification
11:47:23 <fishythefish> to do the unification, we don't substitute that whole thing directly. we only substitute for individual type variables
11:47:23 <daey> shouldnt something like 'map (-) 5 [1,2,3] work?
11:47:27 <fishythefish> that's why we do the solving process
11:47:34 <daey> shouldnt something like 'map (-) 0 [1,2,3]' work? *
11:47:47 <ahihi> > map (0 -) [1,2,3]
11:47:50 <lambdabot>  [-1,-2,-3]
11:48:06 <daey> ah. that bracket setting i didnt come up with :D
11:48:20 <crucify_me> we plug in c -> c , that drops off, and the type is now Foldable t => t (c -> c) -> c -> c
11:48:29 <crucify_me> fully unified
11:48:43 <fishythefish> crucify_me: you're glossing over the actual unification process, but that is the result, yes
11:49:17 <ahihi> > map ((-) 0) [1,2,3] -- daey: another way to write the same thing
11:49:20 <lambdabot>  [-1,-2,-3]
11:49:42 <crucify_me> (a' -> b') is replaced by (c -> c), so wherever else we have a' -> b'   that is replaced by c -> c
11:50:27 <fishythefish> crucify_me: that's how it works out, but that's not how it happens
11:50:28 <crucify_me> how is my wording glossing over the process?
11:50:45 <crucify_me> hmm
11:50:46 <MarcelineVQ> fishythefish, ahihi, daey: negate is the unarry -
11:50:59 <fishythefish> crucify_me: what if the type signature wasn't made only out of bits that look like (a' -> b')? what if you had just a' and b' on their own somewhere?
11:51:05 <MarcelineVQ> afaik in the same way that 3 is   fromIntegral 3    -3  is negate 3
11:51:40 <crucify_me> a' and 'b would turn out to be a' -> a' and b' -> b'   right?
11:52:02 <fishythefish> right, but (-) is assumed to be the binary operator. if you want to pass around unary - as a first-class function, you can use negate
11:52:14 <fishythefish> crucify_me: no, certainly not
11:52:24 <fishythefish> crucify_me: such equalities would incur the occurs check and give you an infinite type error
11:52:44 <crucify_me> oh right I looked at that. 
11:53:00 <crucify_me> a ~ a -> a   => infinite type error
11:53:10 <fishythefish> right
11:53:13 <crucify_me> dang
11:53:24 <mniip> "occurs check" is the more correct name
11:54:38 <daey> when i see these in written work 'f $ a = f a' do these letters have specific meanings, or are they totally equal placeholders?
11:54:39 <crucify_me> when (.) is unified with foldr, the first param of foldr is (a -> b -> c) , so since (.) has its signature, there are 3 elements that are being replaced, and I can see how it works at least superficially
11:54:49 <daey> or are f == functors. m == monads etc.?
11:55:05 <mniip> no
11:55:18 <fishythefish> daey: f just means "function" and a just means "value" there
11:55:19 <mniip> there's a bit of convention but otherwise no hard meaning
11:55:19 <daey> so they are just random letters then?
11:55:29 <daey> ah ok so not random
11:55:29 <mniip> x, y, xs, ys,
11:55:31 <mniip> f g h,
11:55:32 <mniip> k
11:55:37 <mniip> i j, m n
11:55:42 <mniip> a b c
11:55:45 <daey> :P
11:55:51 <fishythefish> crucify_me: please, let's reserve the verb "unify" for something you do with types
11:56:00 <daey> xs is the tail of a list, that i got
11:56:10 <fishythefish> crucify_me: you don't unify (.) with foldr, but you can apply foldr to (.)
11:56:11 <daey> x the head
11:56:13 <mniip> not necessarily tail
11:56:24 <mniip> it's whenever you have an 'ex'
11:56:30 <mniip> and you have multiple other 'exes'
11:56:51 <daey> well ive only seen it in these [x:xs] scenarios so far
11:57:08 <mniip> could be xs@(x:_)
11:57:17 <fishythefish> also, [x:xs] is different from x:xs
11:57:23 <mniip> could be just plain 'xs'
11:57:32 <daey> nvm :D
11:57:36 <mud> mniip: I usually try to call that xxs@(x:xs), even if parts are left out.
11:57:38 <mniip> I often tack on the 's' when there's a list involved
11:57:52 <mniip> mud, I usually go with xw@(x:xs)
11:57:54 <mniip> w for whole
11:57:57 <MarcelineVQ> mud: not xss?
11:58:02 <mniip> xss is for
11:58:06 <mniip> ((x:xs):xss)
11:58:29 <mud> MarcelineVQ: Naw, since it's just x and xs squished together
11:58:56 <mniip> I often would denote monadically wrapped values with a prefix m
11:59:11 <MarcelineVQ> plethora@(onex:_unused)
11:59:52 <mniip> like
11:59:58 <mniip> foo mx = do x <- mx...
12:00:03 <crucify_me> I stand corrected , I realize we are talking strictly about the types. sorry for saving keystrokes fishythefish 
12:01:09 <mniip> this came to mind https://github.com/mniip/h6502/blob/master/src/H6502/OpcodeMap.hs#L526-L532
12:01:11 <fishythefish> crucify_me: saving keystrokes is fine, but not when it obfuscates or changes meaning :)
12:03:10 <mniip> ooh I just came up with a nice solution for AoC
12:03:11 <mniip> I think
12:03:14 <crucify_me> thanks well in my notes, I think I fully understand the equivalences on lines 14 and 15, and how the types unify there    http://lpaste.net/360531
12:04:06 <crucify_me> so why are the equivalences with id hard for me to grasp in the next unification?
12:04:47 <fishythefish> crucify_me: where do you get lost?
12:04:50 <crucify_me> one would start, by looking at the first parameter of foldr (.) 's type(a' -> b')
12:05:09 <mniip> nah probably not
12:05:10 <crucify_me> right?
12:05:38 <fishythefish> crucify_me: yes, continue
12:05:49 <crucify_me> I look at that , and say ...
12:06:18 <crucify_me> I want to substitute that with the type signature of id ...
12:06:26 <crucify_me> so that it agrees ...
12:06:27 <fishythefish> you want to *unify* it
12:06:35 <crucify_me> right
12:06:55 <fishythefish> okay, so what does the unification entail?
12:07:07 <crucify_me> so in that parameter, there are two types a' -> b'. those must be equivalent to eachother
12:07:14 <fishythefish> why?
12:07:34 <crucify_me> because we're trying to unify them with id
12:07:46 <fishythefish> yes, but why does that mean they must be equal types?
12:08:06 <fishythefish> i'm not doubting your conclusion, but let's try to be a little more formal here
12:08:15 <crucify_me> ok hold on
12:08:31 * hackage cabal-doctest 1.0.4 - A Setup.hs helper for doctests running  https://hackage.haskell.org/package/cabal-doctest-1.0.4 (phadej)
12:11:12 <crucify_me> because eventually we are trying to apply fold (.) to id , so the arguments must be of a form that can be accepted by id
12:12:34 <fishythefish> that's ultimately a valid rationale because of the way foldr works, but we can reason more generally
12:13:37 <fishythefish> foldr (.) accepts an argument of a particular type (a -> b). we want this argument to be id, so the type of id (as used here) must be equal to (a -> b)
12:14:11 <fishythefish> so we can set these types equal and solve to get a series of substitutions
12:14:33 <crucify_me> ok ..
12:14:36 <crucify_me> so ..
12:14:59 <crucify_me> (a -> b) must be ~ (c -> c)
12:15:13 <fishythefish> yes, now how do we decompose that type equality?
12:16:03 <crucify_me> we look over to the right of the "remainding" type signature of foldr (.)
12:16:29 <fishythefish> no
12:16:31 <crucify_me> where we have t (b -> b) -> a -> b
12:16:49 <crucify_me> a -> b must also be equiv to c -> c
12:16:54 <crucify_me> there
12:17:24 <fishythefish> again, this is correct, but glosses over what's happening
12:17:27 <fishythefish> whats*
12:17:43 <fishythefish> (what's* - i'm tired)
12:18:07 <crucify_me> ok so before I was cheating to get the result. I was just giving myself a false conception
12:18:29 <fishythefish> it's only "cheating" because your technique isn't sufficiently general
12:18:53 <fishythefish> it'll tell you what to substitute for the a -> b at the end of the signature, but how do you handle the t (b -> b), for example?
12:18:56 <crucify_me> ok well I like that sound if it, but I don't know exactly what that means :)
12:19:36 <crucify_me> I can handle it because it remains as it is because it is not (a -> b)
12:20:01 <crucify_me> it is not equiv to (c -> c)
12:20:03 <fishythefish> it certainly does not remain as it is - the type of foldr (.) id was said to be Foldable t => t (c -> c) -> c -> c, remember?
12:20:37 <crucify_me> right, but I understand the whole thing goes to c's in this latter case
12:20:43 <fishythefish> why?
12:20:44 <crucify_me> because ..
12:21:16 <crucify_me> one moment I know why
12:23:37 <crucify_me> because when we did the unification in the first param, instead of using b' as the ghc does, we chose to set id to (c -> c), so wherever theres a b' it becomes c
12:23:56 <crucify_me> instead of using * b   not b'
12:24:19 <fishythefish> yes, but we can be more formal
12:24:32 <crucify_me> I like formality
12:24:47 <crucify_me> but tend to be rough around the edges
12:24:49 <fishythefish> in general, we have an equality of types w -> x ~ y -> z if and only if w ~ y and x ~ z
12:25:26 <fishythefish> so our equality a' -> b' ~ c -> c can be broken down into the two simpler equalities a' ~ c and b' ~ c
12:26:01 <fishythefish> this justifies us performing the substitutions a' ==> c and b' ==> c throughout the rest of the signature
12:27:51 <crucify_me> right. so the way I see it.. 
12:28:01 <ph88> https://www.youtube.com/watch?v=7NB8tMa8sUk ^^
12:28:07 * hackage vinyl 0.7.0 - Extensible Records  https://hackage.haskell.org/package/vinyl-0.7.0 (AnthonyCowley)
12:29:37 <crucify_me> we must set equivalence in the first parameter with the incoming type signature. then the "rest of" / "remainder" must agree with the unification in the 1st parameter, or does that limit us ?
12:30:24 <crucify_me> by agreement I just mean knowing how the rest of the signature is affected
12:30:48 <fishythefish> this sounds about right. you equate the expected type of the parameter with the actual type of the argument. you extract a set of substitutions from this equality and perform those on the rest of the type signature
12:32:34 <fishythefish> crucify_me: try the exercise you mentioned: without running `:t const id`, work out what the type of `const id` should be
12:33:10 <crucify_me> ok. going back ..
12:33:32 <aplainzetakind> I get this when I attempt to stack build haskanoid: https://paste.pound-python.org/show/RmbfLajpSchgW1cNIH6w/
12:33:33 <Zemyla> I wish there were a semigroup equivalent of Endo. Something like
12:33:52 <Zemyla> @let newtype SEndo a = SEndo { appSEndo :: Maybe a -> a }
12:33:53 <lambdabot>  Defined.
12:33:53 <crucify_me> if there are 3 types expected by the parameter
12:34:14 <crucify_me> and we try to unify that with id
12:34:15 <Zemyla> @let instance Semigroup (SEndo a) where SEndo f <> SEndo g = SEndo $ \mx -> f $ Just $ g mx
12:34:16 <lambdabot>  .L.hs:161:10: error:
12:34:16 <lambdabot>      Not in scope: type constructor or class ‘Semigroup’
12:34:16 <lambdabot>      |
12:34:20 <Zemyla> Ugh.
12:34:29 <crucify_me> what does that look like?
12:35:43 <crucify_me> is it that they are all 3 equated to c, such as q ~ c , r ~ c , s ~ c   ?
12:35:59 <fishythefish> crucify_me: what types are you trying to unify?
12:36:29 <fishythefish> (also, unification can pretty much always be carried out the same way, regardless of the number of types involved)
12:36:42 <crucify_me> in the case where the 1st parameter has three : ( q -> r -> s)   unified with id
12:37:30 <fishythefish> crucify_me: you shouldn't need that for `const id`, but you would have q -> r -> s ~ a -> a, which gives you q ~ a and r -> s ~ a
12:37:49 <byorgey> aplainzetakind: do you have gcc installed?
12:37:50 <fishythefish> remember that all functions are unary: q -> r -> s is the same as q -> (r -> s)
12:38:09 <byorgey> aplainzetakind: did you look in config.log?
12:38:10 <crucify_me> not for const id 
12:38:11 <aplainzetakind> byorgey: yes, I can compile a hello world from the command line
12:38:23 <crucify_me> just generally with that scenario in the first param
12:38:28 <aplainzetakind> I couldn't find config.log actually.
12:39:06 <aplainzetakind> It's not in my /var/log, nor in the directory I run stack from.
12:39:16 <ggVGc> hrm, the more I write haskell the more I feel do notation obfuscates my code
12:39:24 <byorgey> aplainzetakind: maybe check in .stack-work/logs/
12:39:33 <ggVGc> every time I write I use do notationin IO it turns out prett ybad
12:39:42 <aplainzetakind> byorgey: Not there either.
12:39:45 <ggVGc> and usually my functions end up too long and non-specific
12:40:02 <ggVGc> also, apparently I can't type today
12:40:26 <aplainzetakind> Actually sudo find / -name config.log returns nothing.
12:40:29 <crucify_me> in other words, how do you unify (q -> (r -> s)) and (c -> c)
12:41:17 <fishythefish> crucify_me: you tell me. you know the general pattern for unifying function types
12:42:56 <byorgey> aplainzetakind: I'm out of ideas then.  This looks like it might possibly be relevant: https://github.com/commercialhaskell/stack/issues/1633
12:43:37 <crucify_me> it must be (c -> (c -> c)) fishythefish 
12:44:25 <fishythefish> crucify_me: the output of a unification should be a set of type equalities, not a single type
12:45:17 <MarcelineVQ> byorgey: the --with-compiler error makes me wonder if it's a cabal version issue, or by extension a stack version issue.  aplainzetakind: the first thing I'd try is a super fresh stack, like  stack upgrade --git
12:45:19 <aplainzetakind> byorgey: Yes, googling the error mostly produces cases of broken gccs. Mine seems perfectly fine though.
12:45:57 <crucify_me> right since that part is "disposed of" we have q ~ c , r ~ c , s ~ c     for whatever awaits in the remainder of the signature 
12:46:18 <fishythefish> crucify_me: that's incorrect. how did you arrive at those equalities?
12:46:32 <aplainzetakind> MarcelineVQ: My stack was installed through the gentoo overlay, is going behind the back of portage OK?
12:47:08 <MarcelineVQ> I encourage it, if I were you I'd upgrade stack and then uninstall the system version and just use the upgraded one. it'll be in ~/.local/bin
12:47:34 <MarcelineVQ> but if gentoo grabs from git then it won't be any different, idk about gentoo
12:47:38 <crucify_me> q ~ c , (r -> s) ~ (c -> c)    
12:47:52 <aplainzetakind> OK, I'll try that and report back.
12:47:53 <MarcelineVQ> I just encourage not using distro repo's when it comes to stack once you have a copy
12:47:57 <fishythefish> crucify_me: not quite
12:48:27 <crucify_me> hmm
12:51:35 <[Leary]> (a -> b) is like (a, b). Would this all look easier if you were seeing what you could conclude from setting (c, c) = (q, (r, s))?
12:52:16 <crucify_me> dyslexia sets in
12:52:50 <crucify_me> any hints fishythefish 
12:53:11 <crucify_me> [Leary], sorry just saw this....
12:53:13 <fishythefish> crucify_me: try what [Leary] said
12:55:17 <fishythefish> crucify_me: you have all the information you need. the resulting equalities don't all need to look like <single type variable> ~ <single type variable>
12:55:37 * lyxia rhymes with dyslexia.
12:55:55 <crucify_me> right but what I did at 12:47 is wrong ...
12:56:26 <crucify_me> ly*xia is nice
12:57:48 <ph88> what does   :set -fobject-code   do ?
12:58:23 <crucify_me>  ok  c ~ q , c ~ r -> s
12:58:54 <fishythefish> crucify_me: good!
12:59:20 <crucify_me> so looking at it as a set..
12:59:59 <crucify_me> thanks so much fishythefish . you realize you opened a can of worms
13:00:08 <crucify_me> and [Leary] 
13:00:11 <crucify_me> thanks
13:01:18 <[Leary]> yw
13:01:59 <crucify_me> really appreciate help without admonishment
13:03:16 <crucify_me> so I guess with some study of the Milner business I'll be rolling
13:03:35 <crucify_me> hinley milner
13:03:40 <crucify_me> hindley
13:04:24 <crucify_me> late for work thanks ALL again
13:08:21 <aberrant> hi all
13:08:36 <aberrant> so I've made it to chapter 11 in LYAH, and am struggling through Applicatives.
13:08:48 <aberrant> I'm failing to see how these are useful / important.
13:10:04 <aberrant> is there an "Applicatives for Dummies" reference anywhere? I just don't get why anyone needs these.
13:10:56 <MarcelineVQ> this is the for dummies one http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html though people here could probably come up with more compelling uses
13:12:19 <aberrant> thank you. I haven't gotten to monads yet but I'll read this now
13:12:45 <[Leary]> If you want to do anything with Haskell you need the IO Monad, and to have Monad you need Applicative.
13:13:05 <[Leary]> I don't like the chain of reasoning myself, but it might be compelling.
13:13:09 <fishythefish> aberrant: there are many ways to approach this, but suppose you just have a Functor f and a function g :: a -> b. fmap lets you lift g and apply it to an f a and get an f b out of it. But what if instead g :: a -> b -> c and you have not just an f a, but also an f b and you want an f c?
13:14:42 <aberrant> fishythefish: at my level of understanding what you wrote is too abstract.
13:15:03 <replay> does this help? https://livebook.manning.com/#!/book/get-programming-with-haskell/chapter-28
13:15:07 <fishythefish> aberrant: okay, I'll start simpler. Do you understand the Functor typeclass?
13:15:31 <aberrant> I think so.
13:16:12 <aberrant> a functor is anything that can be mapped over, according to LYAH.
13:16:32 <aberrant> so - lists, trees, maybes, ...
13:16:46 <fishythefish> Let's take Maybe as our example Functor. Suppose you have a function f of type Int -> Bool and you have a Maybe Int, which we'll call x. We can't evaluate f x directly (this is a type error), but Functor saves the day! We can do fmap f x and get a Maybe Bool.
13:16:52 <dsal> That's not necessarily a good way to think about functor
13:17:15 <mniip> well
13:17:16 <aberrant> fishythefish: right, I got that.
13:17:27 <mniip> in an object-free category, a functor is pretty much that
13:17:31 <[Leary]> BTW abberant LYAH needs exercises to go with it, or it'll be no wonder if you don't understand anything. IIRC the Applicative Pt 1 & 2 assignments in CIS194 did a really good job of leveraging the power of the concept.
13:17:43 <aberrant> in an imperative language you'd "extract" the value from the functor and then call the function on that, and put it back into the functor.
13:17:46 <mniip> a function (fmap) that sends morphisms to morphisms while preserving identities and composability and composition
13:17:55 <qqkami> hello! i tried importing Data.List and using permutations but I get an undefined variable permutations error 
13:18:23 <fishythefish> aberrant: Now suppose instead, our function f has type Int -> Bool -> Char. We have an x :: Maybe Int and a y :: Maybe Char. Once again, we can't evaluate f x y, but maybe we can do something similar with fmap?
13:18:30 <fishythefish> Sorry, y :: Maybe Bool
13:18:46 <aplainzetakind> MarcelineVQ: After removing the distro package, running stack (which is in ~/.local/bin and which bash even autocompletes) gives me 'bash: /usr/bin/stack: No such file or directory'
13:19:00 <aberrant> fishythefish: with you so far.
13:19:35 <aplainzetakind> And 'which stack' returns the .local/bin version.
13:19:54 <mniip> qqkami, what context are you talking about? a file or ghci?
13:19:54 <fishythefish> Well, we can start with f <$> x again, but now we're stuck. The result doesn't have type Bool -> Char, but rather Maybe (Bool -> Char). fmap isn't enough to apply this to y because it can't handle a wrapped function.
13:20:13 <Gurkenglas> Can you OR patterns? 'f [0, x] OR [x, 0] = "the list consists of " ++ show x ++ " and 0 in some order."'
13:20:15 <qqkami> i tried it in a fiel and with :load Data.List 
13:20:17 <qqkami> mniip: 
13:20:42 <fishythefish> Here's where Applicative comes in. Just like Functor gives us fmap :: Functor f => (a -> b) -> f a -> f b, Applicative gives us (<*>) :: Applicative t => t (a -> b) -> t a -> t b
13:20:43 <MarcelineVQ> aplainzetakind: seems like a shell issue, what happens if you use the absolute path /home/theuser/.local/bin/stack
13:20:46 <mniip> nope that's not
13:20:48 <mniip> how that works
13:20:56 <qqkami> mniip: how would that work then?
13:21:02 <fishythefish> So now we can do f <$> x <*> y and all is well again
13:21:04 <mniip> qqkami, in ghci, just type 'import Data.List'
13:21:06 <aberrant> fishythefish: I get it, but this seems unnecessarily complicated. Why isn't there an "extract" function that just pulls out the thing inside the "box" so you can use it?
13:21:08 <mniip> or ':m Data.List'
13:21:21 <qqkami> and in a file shouldn't it be the same
13:21:23 <qqkami> ?
13:21:31 <mniip> in a file you'd put import at the top
13:21:34 <dsal> aberrant: what would it pull out of Nothing?
13:21:58 <mniip> 1512508637 [00:17:17] <aberrant> in an imperative language you'd "extract" the value from the functor and then call the function on that, and put it back into the functor.
13:22:06 <mniip> I don't think that's quite how C++'s map works
13:22:06 <aberrant> dsal: it'd probably need to throw an error.
13:22:15 <fishythefish> aberrant: ew, errors
13:22:32 <aberrant> ok
13:22:35 <qqkami> mniip: i can't seem to get import Data.List to work in hugs (sry didnt mention that before we are required to use hugs at our university)
13:22:38 <mniip> which I mean, std::transform
13:22:39 <fishythefish> > Nothing <*> Nothing -- no errors
13:22:41 <aplainzetakind> I can go to the directory and run ./stack and it works then.
13:22:41 <lambdabot>  Nothing
13:22:44 <qqkami> mniip: and the import at the top doesnt seem to work either
13:22:46 <mniip> qqkami, oh dear
13:23:03 <qqkami> mniip: ikr
13:23:10 <aplainzetakind> And entering the full path also works.
13:23:42 <mniip> that's pretty unsettling
13:23:44 <fishythefish> aberrant: it's all about the API you want to expose. You could define another typeclass that lets you extract values (maybe you want Comonad?), but you don't need to be able to do this for what Applicative gives you.
13:23:48 <aberrant> so <*> gives you a generalized way of handling data that may "hold" different types?
13:23:53 <mniip> good luck finding anyone versed in hugs here
13:24:02 <qqkami> mniip: thanks haha 
13:24:08 <MarcelineVQ> aplainzetakind: sounds like something is caching where it used to be when you try ands run it, adding the full path to it to the beggining of your $PATH should make it find that one first, you might need to relog after
13:24:11 <mniip> sending virtual hugs your way
13:24:13 <mniip> or something
13:24:14 <aplainzetakind> Ah, in a new urxvt it works.
13:24:15 <fishythefish> Just as the implementation of fmap will behind the scenes often do an unwrap-apply-rewrap kind of thing, so too can (<*>)
13:24:18 <aberrant> that is, "Maybe a" holds either a value of type a or Nothing.
13:24:22 <MarcelineVQ> aplainzetakind: ah good
13:24:30 <aplainzetakind> Just had to source the $PATH afresh apparently.
13:24:46 <fishythefish> aberrant: that's an accurate description of Maybe, but you can read that directly from the type definition :P
13:25:18 <mniip> qqkami, does ':module Data.List' work?
13:25:19 <aberrant> fishythefish: right.
13:25:22 <MarcelineVQ> aplainzetakind: so yeah I'd just use that one from now on, and just  stack upgrade  it everyone once in awhile, in when there's problems you'd  stack upgrade --git  to see if it helps your issue
13:25:41 <aberrant> fishythefish: I guess I'm struggling to find a use case for this. Maybe it'd be clearer if I had to actually use it somewhere.
13:25:47 <aplainzetakind> OK, will do.
13:25:48 <fishythefish> aberrant: Applicative does, however, require you to be able to wrap a bare value.
13:25:50 <fishythefish> :t pure
13:25:51 <lambdabot> Applicative f => a -> f a
13:25:54 <aplainzetakind> However, the compiler issue remains.
13:26:09 <aberrant> I assume it's a common construct in Haskell. I can't say I've ever needed it in any other language before.
13:26:20 <dsal> > [(* 2), (* 3)] <*> [1..3]
13:26:22 <lambdabot>  [2,4,6,3,6,9]
13:26:38 <fishythefish> aberrant: maybe you'll enjoy http://mightybyte.github.io/monad-challenges/
13:26:53 <qqkami> mniip: cannot find module Data.List
13:27:01 <mniip> I wouldn't call it a "common" construct, I mean it's fairly recent, and there aren't many practical non-monad applicatives,
13:27:09 <mniip> couple examples that come to mind are lens and traversals
13:27:11 <aberrant> fishythefish: once I learn what a monad is, maybe :)
13:27:20 <qqkami> mniip: guess i could just copy the source code lol
13:27:25 <mniip> qqkami, ugh
13:27:28 <[Leary]> aberrant: I misspelled your name earlier so perhaps you missed my earlier comment: you should do the Applicative Pt 1 & 2 assignments from CIS194.
13:27:41 <aberrant> [Leary] - thanks. Got it.
13:27:41 <fishythefish> aberrant: nah, that link is all about discovering functors/applicatives/monads exactly how you're describing
13:27:50 <fishythefish> solve a bunch of different problems, then observe the common abstraction
13:27:56 <aberrant> fishythefish: ok. I will give that a try.
13:28:32 <aberrant> thank you all for the help, and sorry for the lame questions. I've used many languages but this is the first one that's introducing things I haven't ever seen before.
13:28:40 <mniip> aberrant, I mean, I wrote this recently,
13:28:50 <mniip> @let puncture = (`runCont` \xs -> fmap (second ($ fmap fst xs)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs))))
13:28:51 <lambdabot>  Defined.
13:28:51 <dsal> aberrant: yay, learning. :)
13:28:54 <mniip> :t puncture
13:28:55 <lambdabot> Traversable f => f b -> f (b, b -> f b)
13:29:02 <[Leary]> By the end of the second assignment you are combining super basic parts at a high level to solve a problem I would have figured you needed Monad for.
13:29:20 <mniip> > map (($ 0) . snd) $ puncture [1,2,3]
13:29:23 <lambdabot>  [[0,2,3],[1,0,3],[1,2,0]]
13:29:28 <mniip> wouldn't be possible without Applicative
13:29:29 <aberrant> ok, mniip, I can't even begin to understand that.
13:29:52 <mniip> hmm
13:29:56 <aberrant> oh, it's just iteratively replacing the kth element with 0.
13:30:29 <mniip> well
13:30:38 <dsal> :t callCC
13:30:40 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
13:30:53 <mniip> for your structure 'f b' it gives you a structure where at every cell is a function
13:31:03 <mniip> applying that function produces a modified structure with one cell replaced
13:31:31 <aberrant> hm.
13:31:36 <mniip> @let puncture' = fmap snd . puntcure
13:31:38 <lambdabot>  .L.hs:166:24: error:
13:31:38 <lambdabot>      • Variable not in scope: puntcure :: a -> f (a0, b)
13:31:38 <lambdabot>      • Perhaps you meant one of these:
13:31:45 <mniip> @let puncture' = fmap snd . puncture
13:31:46 <lambdabot>  Defined.
13:31:53 <mniip> :t puncture'
13:31:54 <lambdabot> Traversable f => f a -> f (a -> f a)
13:32:10 <aberrant> yeah, that's not making any sense to me. I need more basics.
13:32:13 <aberrant> But thank you :)
13:32:24 <aberrant> I'm off to read these docs and then try some exercises.
13:33:05 <mniip> dsal, basically Cont is magi
13:33:06 <mniip> c
13:33:20 <mniip> the beauty of this function is that it's not partial,
13:33:26 <mniip> and doesn't use type recursion or fixpoints
13:34:37 <mniip> hmm
13:34:44 <mniip> I recall someone making a sorting traversal
13:35:10 <mniip> so that you could sort a traversable container without having to then resort to partial functions to emplace the sorted values back
13:35:20 <mniip> I wonder if ContT could help there
13:36:46 <dsal> I think a combination of traverse and callcc is probably too much for my brain at the moment.  heh
13:38:29 <mniip> yeah but like
13:38:45 <mniip> this is a traversal that puts current-continuations inside the traversal
13:39:06 <mniip> so that at a later time you can invoke the continuation and "return" to the point back when you were inside traverse
13:39:32 <mniip> I am delighted that I've managed to come up with this myself
13:39:39 <mniip> it's amazing
13:39:59 <glguy> jle`: Thanks for the tip about tagging the repo
13:40:07 <mniip> theoretically you could do more,
13:40:46 <mniip> data Traversal f a = Traversal { read :: a, write :: a -> f (Traversal f a) }
13:41:02 <dsal> Yeah, the usage is neat.  I think I'd need to allocate brain power to get the mechanism.
13:41:34 <mniip> _ :: Traversable f => f a -> f (Traversal f a)
13:41:42 <mniip> haven't come up with a good name yet
13:52:00 <orion> The monad-time package looks like this: https://www.stackage.org/haddock/lts-9.17/monad-time-0.2/src/Control.Monad.Time.html#currentTime the monad-http package is more complicated in that it defines a HttpT Monad transformer.
13:52:36 <orion> monad-time doesn't have a transformer such as "TimeT". What functionality do I lose by it not being there?
13:53:10 <jle`> glguy: no problem!  happy to see more representation.  nice job grabbing the first slot the other day too
14:01:58 <hs_newb> hello, can i get a little help?
14:02:17 <tdammers> hs_newb: don't ask to ask, just ask
14:02:32 <hs_newb> could somebody explain to me why https://gist.github.com/anonymous/7eda44a4105aa08d9bb4f20b50e5cbc3 version is faster than https://gist.github.com/anonymous/98690d97a0b7d8cc423ddb036c368c16
14:02:54 <hs_newb> the first version is about 4s faster on my setup
14:06:47 <glguy> hs_newb: The two differences are that the one doesn't pass the mutable vector as a parameter to the looping function, and one uses the PrimMonad constraint?
14:07:28 <glguy> hs_newb: Also, have you joined our #haskell AoC group? 43100-84040706
14:07:30 <hs_newb> glguy: yes
14:08:32 <pta2002> I have a question
14:08:45 <pta2002> How'd I go about getting the pair of every element on a list?
14:08:48 <pta2002> e.g.
14:09:11 <hs_newb> glguy: no how do i join it
14:09:12 <pta2002> I have [a,b,c], I want to get [(a,b),(a,c),(b,a),(b,c),(c,a),(c,b)]
14:09:29 <mniip> pta2002, without (a, a)?
14:09:35 <pta2002> yes
14:10:10 <glguy> hs_newb: punch that code into: http://adventofcode.com/2017/leaderboard/private
14:10:21 <mniip> :t \xs -> [(x, y) | x <- xs, y <- delete x xs]
14:10:23 <lambdabot> Eq b => [b] -> [(b, b)]
14:10:42 <mniip> if you want one without the equality constraint then, uh,
14:10:47 <pta2002> hm I think I got it
14:11:03 <pta2002> [x/x', x <- x, x' <- x, x /= x]
14:11:18 <mniip> well that doesn't quite work when your list has duplicates
14:11:22 <pta2002> though I see yours would work
14:11:29 <pta2002> yeah i don'tmind the duplicates
14:11:33 <mniip> > (\xs -> [(x, y) | x <- xs, y <- delete x xs]) [1, 1]
14:11:35 <lambdabot>  [(1,1),(1,1)]
14:11:44 <glguy> > (\xs -> [(x,y) | (a,x:c) <- inits xs `zip` tails xs, y <- a++c]) [a,b,c]
14:11:45 <lambdabot>  [(a,b),(a,c),(b,a),(b,c),(c,a),(c,b)]
14:12:08 <hs_newb> glguy  but that doesn't help me figure out the reason :(
14:12:11 <mniip> oh dear
14:12:25 <mniip> hs_newb, dw he's just advertising his lame-o leaderboard :p
14:12:33 <mniip> full of lame people :p
14:12:56 <glguy> hs_newb: I don't know off the top of my head why adding the array as a parameter is adding 4 seconds
14:13:16 <glguy> The code I wrote that does the same sort of things as yours ran in 0.2 seconds or so, so an extra 4 seconds seems like a lot
14:13:41 <glguy> I don't think that the constraint is affecting performance in this case since performance got better
14:14:02 <mniip> glguy, how does your code compare to my, uh
14:14:03 <pta2002> well apparently it doesn't work
14:14:06 <mniip> Unboxed Mess
14:14:15 <glguy> mniip: which day?
14:14:16 <pta2002> I have [x/x' | x <- x, x' <- x, x /= x]
14:14:21 <pta2002> but it says
14:14:29 <mniip> glguy, today
14:14:33 <pta2002> "cannot construct the infinite type: t ~ [t]"
14:14:42 <mniip> you can't draw x from x
14:14:49 <glguy> mniip: https://github.com/glguy/advent2017/blob/master/execs/Day05.hs#L35-L41
14:14:52 * hackage data-serializer 0.3.2 - Common API for serialization libraries  https://hackage.haskell.org/package/data-serializer-0.3.2 (MikhailVorozhtsov)
14:15:12 <pta2002> found it
14:15:16 <pta2002> was saying x instead of xs
14:15:20 <pta2002> mniip: yep
14:16:03 <pta2002> well now it just makes an empty list...
14:16:05 <pta2002> huh
14:16:14 <mniip> x /= x
14:16:21 <mniip> always (likely) false
14:16:25 <pta2002> yep
14:16:29 <pta2002> why likely
14:16:34 <mniip> depends on the instance
14:16:42 <pta2002> how so
14:16:48 <mniip> you can define a malformed instance
14:17:00 <glguy> Because IEEE754 is dumb
14:17:07 <mniip> oh that too
14:17:20 <glguy> > let x = 0/0 in x /= 0
14:17:22 <lambdabot>  True
14:17:25 <glguy> > let x = 0/0 in x /= x
14:17:27 <lambdabot>  True
14:18:18 <hs_newb> glguy: i was compiling without optimization; with -O2 it's instant
14:18:36 <hs_newb> i didn't know -O2 makes that big of a different
14:18:40 <hs_newb> *ce
14:18:47 <hs_newb> it took 17s earlier
14:21:35 <mniip> glguy, on my machine on my input your code's part2 takes 0.27
14:21:59 <mniip> mine's 0.12
14:23:26 <mniip> yay!
14:24:14 <mniip> ooh I can get it to 0.1
14:24:22 * nshepperd_ used IntMap for day 5
14:24:35 <nshepperd_> No optimization allowed!
14:25:15 <mniip> nshepperd_, err you haven't seen my code have you
14:25:30 <hs_newb> mniip: show your code pls :)
14:25:56 <mniip> http://lpaste.net/360532
14:26:41 <mniip> all real worlds faithfully threaded
14:27:54 <Guest25447> Hello
14:28:04 <Guest25447> Top of the mornin
14:28:45 <hs_newb> mniip so lots of unboxing and using bytearray gives you fast code? (i am new to haskell)
14:29:39 <mniip> don't read this if you're new to haskell I guess
14:29:45 <mniip> unidiomatic code
14:31:49 <jle`> unbxing/bytearray can give you slow code, and fast code doesn't require unboxing/bytearray
14:32:16 <glguy> mniip: How fast does this run on your machine? http://lpaste.net/6057624017467080704
14:32:26 <glguy> (with optimizations)
14:33:16 <mniip> 0.07
14:33:41 <mniip> hold on one sec...
14:34:09 <ph88> has anyone tried hedgehog? how does it compare to quickcheck ?
14:34:25 <mniip> glguy, yeah right
14:34:28 <mniip> just had to doublecheck
14:34:46 <mniip> I remember unplugging my laptop having a nasty effect on benchmark results before
14:38:41 <Average-user> Day5 was a nightmare
14:38:51 <glguy> Were you doing it in prolog?
14:38:56 <Average-user> yes
14:39:09 <Average-user> but I couldn't find any container kind of mutable
14:39:15 <lyxia> ph88: somehow it looks more polished that QC
14:39:40 <ph88> ye it has a nice hedgehog graphic ^___^
14:39:49 <Average-user> Prolog lists are Head and Tail type, and there are no efficient when too large
14:39:58 <Average-user> PartA tooks 5 minutes
14:40:18 <Average-user> and part b , I had to do it in Clojure
14:41:12 <Average-user> I'm wondering if there is a property in day5 part2 seems arbitrary  if x > 2 then x-1 else x+1
14:42:35 <lyxia> ph88: the unified generator/shrinker is pretty nice
14:43:04 <ph88> i haven't looked into it yet, but the first glance of the readme that stood out immediately ye
14:43:21 <Average-user> I would be happy if todays challenge is more about the problem, and not about large inputs
14:44:13 <lyxia> ph88: That and the state machine stuff are the main distinguishing features
14:44:26 <ph88> didn't know what to do with emacs, got spacemacs now .. gonna give it another try
14:44:51 <ph88> lyxia, there is a quickcheck-statemachine library now with already 400 commits ... i think the hedgehog statemachine stuff was based on it
14:45:51 <ph88> lyxia, https://github.com/nick8325/quickcheck/issues/139#issuecomment-311327099
14:46:57 <lyxia> ph88: Well, some of these commits are mine :P
14:49:44 <glguy> Average-user: The Haskell zipper-based list solution ran in about 7 seconds for me
14:49:54 <glguy> Average-user: Maybe you just need to pick a different encoding of the problem in your prolog version
14:52:05 <Average-user> show me that
14:52:22 <Average-user> If you want
14:52:26 <daey> why is :t length 'foldable t => t a -> Int' and not simply [a] -> Int?
14:53:10 <daey> or rather, where would a [a] -> Int solution fail where the other would succeed?
14:53:44 <glguy> > length (M.singleton 1 2)
14:53:46 <lambdabot>  1
14:53:55 <glguy> (M is Data.Map)
14:56:27 <cheater> i am developing a programming language. how do i make sure that the features of the language do not mesh together in unexpected ways that destroy the way people can reason about the language? for example, some haskell extensions don't really mesh together really well.
14:56:43 <dmwit> E_TOOBROAD
14:56:59 <cheater> you think ..
14:57:12 <Average-user> glguy: Can you show me you zipper based solution, to see if I get inspired
14:58:40 <daey> why do i need to write (Eq a) => in this instance? isPalindrome :: (Eq a) => [a] -> Boo
14:58:54 <dmwit> daey: Do you call `(==)`?
14:59:01 <glguy> Average-user: This is a cleaned up version of someone else's code: http://lpaste.net/7664013001023815680
14:59:01 <daey> i get what it does. but i dont understand why this isnt necessary for other operations
14:59:05 <daey> dmwit: yes
14:59:10 <dmwit> daey: ...that's why.
14:59:35 <daey> but i cant multiple strings, so why does mulitplication not require me to exclude strings?
14:59:46 <dmwit> It does.
14:59:46 <daey> ah wait
14:59:52 <daey> yeah the [a] :)
15:00:02 <dmwit> what
15:00:10 <numberten> why is this well typed
15:00:11 <numberten> @type (List[Just(1), Just(2), Nothing, Just(4)] >>= id)
15:00:13 <lambdabot> (Item (m (m b)) ~ Maybe a, Num a, IsList (m (m b)), Monad m) => m b
15:00:39 <daey> dmwit: the a allows everything, while my multiplications usually specify a specific type already
15:00:40 <numberten> (a -> m b), so a is Maybe Int and so is m b, and the result would be m b
15:00:53 <numberten> > (List[Just(1), Just(2), Nothing, Just(4)] >>= id)
15:00:55 <lambdabot>  error:
15:00:55 <lambdabot>      • Couldn't match expected type ‘Maybe Integer’
15:00:55 <lambdabot>                    with actual type ‘Item (m0 (m0 b0))’
15:01:29 <dmwit> :t List
15:01:30 <lambdabot> IsList l => [Item l] -> l
15:01:47 <aberrant> ok
15:01:50 <daey> time to sleep. see you tomorrow :^)
15:02:00 <aberrant> I've been playing with http://mightybyte.github.io/monad-challenges
15:02:08 <aberrant> and I'm not sure I've done things the way they wanted.
15:02:09 <daey> and as always thanks for the support! you guys are the best :^)
15:02:17 <aberrant> could someone please take a look at my code and advise?
15:02:58 <aberrant> https://pastebin.com/0SXRxKuN
15:03:20 <aberrant> This is the middle of 1.3
15:03:22 <lyxia> aberrant: does it run?
15:03:26 <aberrant> lyxia: yes
15:03:42 <dmwit> numberten: I think a detailed explanation would be much easier with access to the source of `List`.
15:03:50 <mniip> huh
15:03:54 <dmwit> Possibly also `IsList`, if this is not the one defined in base.
15:03:55 <mniip> how does what work
15:04:00 <mniip> :t List
15:04:01 <lambdabot> IsList l => [Item l] -> l
15:04:05 <mniip> this is clearly a constructor...
15:04:09 <dmwit> mniip: Perhaps a pattern synonym.
15:04:51 <aberrant> I just have a feeling my syntax / approach is not at all what they were looking for.
15:06:14 <dmwit> numberten: Anyway the type practically says how it works. `Itm (m (m b)) ~ Maybe a` says you have some doubly-nested Monad instance that can contain `Maybe a`s. `IsList (m (m b))` says you can use `List` to construct that type. In `(>>= id)`, the contained type is `m b`, not `Maybe X` for some `X`.
15:06:21 <mniip> aberrant, link the exercise?
15:06:34 <aberrant> mniip: thanks. http://mightybyte.github.io/monad-challenges is the root
15:06:46 <aberrant> mniip: they're cumulative; I'm on set 1, exercise 3.
15:06:58 <dmwit> numberten: `(>>= id) :: Monad m => m (m a) -> m a`.
15:07:00 <lyxia> aberrant: that looks okay
15:07:33 <aberrant> lyxia: did they want me to write an infinite list generator? That just seemed to me to be the best way of doing it.
15:07:47 <aberrant> because 1.3 suggests that this may have been the wrong approach
15:09:02 <dmwit> numberten: (N.B. Just because something is well typed under a certain set of constraints does *not* mean that GHC knows of a solution to those constraints.)
15:09:51 <mniip> :t (() ~ Bool) => [(), True]
15:09:52 <lambdabot> error: parse error on input ‘=>’
15:09:58 <mniip> oops
15:10:09 <mniip> :t [(), True] :: (() ~ Bool) => [()]
15:10:10 <lambdabot> error:
15:10:10 <lambdabot>     Couldn't match type ‘()’ with ‘Bool’
15:10:11 <lambdabot>       arising from an expression type signature
15:10:19 <mniip> aw dammit
15:10:20 <lyxia> aberrant: another way would be to go through fiveRands' :: Gen [Integer] first, but yours doesn't seem out of place given the vagueness of the requirements.
15:10:32 <dmwit> Yeah, it's harder than you might think to write an unsatisfiable constraint. =)
15:10:34 <mniip> well there was some way to make this work
15:10:38 <dmwit> Pesky context reduction...
15:11:11 <aberrant> lyxia: yeah, I thought about that but it just seemed that making a function that just returned 5 random numbers was not generalizable enough. I dunno. Perhaps I'm overthinking it.
15:11:32 <lyxia> aberrant: Don't worry about it.
15:12:17 <dmwit> > let x :: (a ~ Bool, a ~ ()) => [a]; x = [] in ()
15:12:19 <lambdabot>  ()
15:12:53 <dmwit> > let x :: (a ~ Bool, a ~ ()) => [a]; x = [(), True] in () -- ?
15:12:55 <lambdabot>  error:
15:12:55 <lambdabot>      • Couldn't match type ‘()’ with ‘Bool’
15:12:55 <lambdabot>        Expected type: a
15:13:41 <dmwit> > let x :: (a ~ Bool, a ~ ()) => [a]; x = if True then [True] else [()] in () -- ?
15:13:43 <lambdabot>  error:
15:13:43 <lambdabot>      • Couldn't match type ‘()’ with ‘Bool’
15:13:43 <lambdabot>        Expected type: a
15:13:53 * hackage ble 0.4.2 - Bluetooth Low Energy (BLE) peripherals  https://hackage.haskell.org/package/ble-0.4.2 (jkarni)
15:13:55 <dmwit> yeah =)
15:14:02 <pcm77[m]> hello
15:14:19 <pcm77[m]> who wants to teach me haskell?
15:14:25 <dmwit> ?where tutorials
15:14:25 <lambdabot> http://haskell.org/haskellwiki/Tutorials
15:14:59 <pcm77[m]> but I want a mentor
15:15:06 <fishythefish> aberrant: I believe what's intended is for you to start with the ugly, naive implementation of fiveRands where you thread all the state yourself rather than implement randStream
15:15:06 <mniip> dmwit, I'm looking at this
15:15:12 <mniip> :t :t let f :: Dict (a ~ Bool) -> a; f Dict = True; in f
15:15:13 <lambdabot> error: parse error on input ‘:’
15:15:16 <fishythefish> (nothing is wrong with your approach, of course)
15:15:20 <mniip> :t let f :: Dict (a ~ Bool) -> a; f Dict = True; in f
15:15:21 <lambdabot> Dict (a ~ Bool) -> a
15:16:09 <fishythefish> aberrant: the later exercises should have you abstract out that state-management
15:16:21 <mniip> :t \x -> let f :: Dict (a ~ Bool) -> a; f Dict = True; in f x :: ()
15:16:22 <lambdabot> Dict (() ~ Bool) -> ()
15:16:22 <dmwit> pcm77[m]: Okay. I don't know, but I suspect you will not find anybody volunteering to do that here. If you come with concrete questions, we like to answer them.
15:16:47 <mniip> pcm77[m], mentoring is very hard, people usually won't do it for free
15:17:09 <dmwit> pcm77[m]: You may find somebody willing to consult for a while, though if I were you I would expect to "talk business". Have a budget in mind. You may get less time for that budget than you're hoping, though.
15:19:07 <Average-user> glguy: I tried to implement a zipper before but It didn't work, but I think I've founded an implementation in prolog that might
15:19:16 <pcm77[m]> sorry but have no money to offer
15:19:25 <pcm77[m]> I can cook for you
15:19:37 <mniip> haha
15:19:55 <mniip> that'd legit work if you were at my uni but that's unlikely
15:24:58 <aberrant> fishythefish: thanks. I will keep going then.
15:25:10 <mniip> I mean I've done that kind of thing for food before :p
15:25:43 <dmj`> pcm77[m]: I’d recommend just sticking around here, and asking questions. No individual probably has the time to dedicate to fulltime mentorship. You’ll be mentored in the collective. 
15:26:30 <mniip> yeah but don't ask zero-effort questions before doing your own research
15:26:36 <mniip> like that one guy
15:28:34 <mniip> glguy, I should rewrite this in assembly
15:28:48 <mniip> cue ccc comic
15:29:41 <EvanR> can a theorem prover be bolted onto any-old crap language to gain safety
15:30:21 <mniip> if the language has sufficient documentation
15:30:23 <EvanR> original source remains, proofs in another file
15:30:27 <mniip> to write up the axioms
15:32:21 <EvanR> i guess you could make a model of that language inside coq and do program extraction
15:32:37 <EvanR> but you lose the toolchain and user experience of the original language
15:33:12 <EvanR> what what i just pondered... you could misplace the safety framework and still have a product
15:35:20 <mniip> EvanR, you could implement the language parser in coq
15:35:33 <mniip> and prove the theorem that "this text compiles to a program that..."
15:40:23 * hackage LambdaDesigner 0.1.0.0 - A type-safe EDSL for TouchDesigner written in Haskell.  https://hackage.haskell.org/package/LambdaDesigner-0.1.0.0 (ulyssesp)
15:42:07 <pcm77[m]> okay thanks
15:43:15 <pcm77[m]> can you please pin my request, so that If somebody is interested in it he can come back to me?
15:43:34 <pcm77[m]> I am located in Germany,  next to Hamburg
15:43:50 <glguy> pcm77[m]: Sorry, IRC is different from a forum. We don't have pinned threads
15:47:27 <Average-user> pcm77[m]; you could try in https://www.reddit.com/r/haskellquestions/
15:47:45 <quinn_diggity> or stackoverflow!
15:48:17 <Average-user> or there yep
16:03:20 <jchia_> I'm trying to think of a non-contrived type that's a Functor but not Applicative.
16:03:46 <jchia_> Is there such a type that's commonly used?
16:05:50 <hpc> (,) a, i think
16:05:51 <mud> (,) e  ?
16:05:55 <mud> Haha
16:05:58 <hpc> since you can't write pure
16:06:22 <hpc> (i think the instance exists with a monoid constraint in base)
16:10:55 <hexagoxel> jchia_: FRP `Event`s. no idea if contrived..
16:11:46 <jchia_> hexogoxel: Which package? Could a reasonable Applicative instance be defined for Event?
16:11:54 <jchia_> ^hexagoxel
16:13:14 <hexagoxel> jchia_: reflex or reactive-banana. probably other FRP libs too.
16:14:09 <Harzilein> *sigh*... i'm sure you can answer my question but i'm unsure how to ask it... it doesn't help that my actual goal is to point out a weakness in another language's pattern matching when i don't even understand haskell's pattern matching that well
16:14:37 <Harzilein> it seems to be about polyvariadic whatever, where i want to match on the last element
16:16:34 <aberrant> I am beginning to think that I am not smart enough for Haskell.
16:16:53 <fishythefish> nonsense!
16:17:08 <aberrant> I am completely stuck on this monad challenge
16:17:16 <fishythefish> that's all right :)
16:17:23 <fishythefish> which challenge?
16:17:25 <aberrant> even after getting the hint
16:17:35 <aberrant> The bottom of http://mightybyte.github.io/monad-challenges/pages/ex1-3.html
16:17:42 <Harzilein> they have an example where they destructure a tuple with a list and an empty list and successively build a tuple with and empty list and the reversed list. which kind of looks like low hanging fruit to me, in the face of car/cadr style list access
16:17:46 <[Leary]> I've been working with Haskell on and off for years, the other day I got stuck writing (++) and reverse.
16:18:03 <Harzilein> an*
16:18:16 <fishythefish> aberrant: well, what are your implementations of randEven, randOdd, randTen?
16:18:35 <[Leary]> Getting stuck on one of your first interactions with a monad is something that would happen to anyone.
16:18:56 <aberrant> fishythefish: https://pastebin.com/XTbxqJMQ
16:19:15 <hexagoxel> jchia_: `pure` would require that the Event fires always, and that is at least conceptually nonsense. not sure if there is a lawful (if non-sensible) instance tbh.
16:19:27 <fishythefish> aberrant: okay, do you see the common structure between those?
16:19:47 <aberrant> yes
16:20:09 <aberrant> it takes two functions, though.
16:20:11 <fishythefish> they all have nearly identical code except for two places
16:20:17 <fishythefish> give those two places names and make them parameters
16:20:20 <aberrant> "rand" and the modification to "i"
16:20:28 <fishythefish> right
16:20:40 <aberrant> but that doesn't match the signature in the hint.
16:21:01 <aberrant> "generalA :: (a -> b) -> Gen a -> Gen b"
16:21:16 <fishythefish> doesn't it?
16:21:21 <Average-user> glguy: zipper-based turned out being slower. 
16:21:23 <aberrant> I only see one function there.
16:21:40 <fishythefish> what's the type of rand/randEven?
16:22:02 <aberrant> it's Gen a
16:22:07 <aberrant> well, Gen Integer
16:22:10 <fishythefish> do you see now?
16:22:20 <aberrant> OH.
16:22:26 <fishythefish> :)
16:22:29 <aberrant> "Gen a" in that signature is "rand"
16:22:40 <aberrant> and "a -> a" is "i * 2"
16:22:49 <fishythefish> there you go
16:22:52 <aberrant> (is that right?)
16:23:25 <fishythefish> Yup, right now, a and b are both Integer, but as the hint says, you can make generalA polymorphic with the type signature you pasted above
16:23:29 <aberrant> the type alias confuses me, honestly. I got it right but I don't know that I understand it.
16:23:46 <aberrant> but let me try to get through this before I review it for understanding.
16:26:00 <aberrant> @fishythefish: does the actual function start out "generalA f g x = " or do I have that wrong?
16:26:00 <lambdabot> Unknown command, try @list
16:26:06 <aberrant> gah, sorry.
16:26:26 <fishythefish> aberrant: it can
16:26:32 <aberrant> I can't figure out how to extract the seed, though.
16:26:39 <aberrant> type Gen a = Seed -> (a, Seed)
16:27:05 <fishythefish> well, let's expand the type signature - generalA :: (a -> b) -> (Seed -> (a, Seed)) -> Seed -> (b, Seed)
16:27:18 <fishythefish> so f :: a -> b, g :: Seed -> (a, Seed), and x :: Seed
16:27:21 <fishythefish> does that help?
16:27:54 <fishythefish> (if these are not what you intended those parameters to be, feel free to move around/rename)
16:28:05 <aberrant> yes. That helps. one sec. Thank you.
16:28:52 <zachk> so if patern matching "fails" in a do notation monad, it calls the monad's fail method?
16:28:55 <zachk> :t fail
16:28:56 <lambdabot> Monad m => String -> m a
16:30:08 <aberrant> fishythefish: generalA f g x =    let (i, newGen) = g x    in (f i, newGen)
16:30:49 <aberrant> then randEven' seed = generalA (*2) rand seed
16:31:02 <fishythefish> :)
16:31:10 <aberrant> thank you so much.
16:31:25 <aberrant> and because of partial application
16:31:27 <fishythefish> a bit of a spoiler, since you've already seen Functor: compare the signature of generalA with the signature of fmap
16:31:33 <aberrant> randEven' = generalA (*2) rand
16:32:07 <aberrant> yep, I noticed that
16:32:45 <numberten> dmwit: thanks
16:33:04 <aberrant> ok, cool. This makes sense in retrospect.
16:33:26 <koz_> Is there a way I can create my own Stack template?
16:34:32 <mud> koz_: Yes. They're just files you can edit fairly easily. Note you can also specify local files or remote URLs as templates, and you can set a default to be used when you don't specify.
16:34:45 <koz_> mud: Is there a link explaining this someplace?
16:35:38 * hackage hexchat 0.0.2.0 - Haskell scripting interface for HexChat  https://hackage.haskell.org/package/hexchat-0.0.2.0 (mniip)
16:36:02 <mud> koz_: Not really https://github.com/commercialhaskell/stack-templates is the files it uses by default, you can tell the format from those probably, or download and edit one. And then specifying one on the command line goes about as you'd expect
16:36:17 <koz_> mud: OK, thanks! Will investigate and shave yaks.
16:36:30 <mud> The setting for the default is buried somewhere, I think it's in the docs. It should just be called default-template though I'm fairly sure.
16:36:53 <mud> If you can't find it, let me know, I can probably dig it up.
16:37:09 <koz_> mud: Thanks, I will.
16:42:39 <koz_> Can I use {-# START_FILE #-} to define a special stack.yaml?
16:42:57 <mniip> aw did I miss an upload of my own package :(
16:43:22 <mniip> by 4 seconds evidently
16:43:41 <mud> koz_: You can't have stack.yaml in the template unfortunately. There's been talk about it before, but currently it doesn't make sense. 'stack new' wants to be able to create the stack.yaml from whatever else is in the template, it essentially runs 'stack init' after.
16:44:10 <koz_> mud: Ah, OK. Well, figured I'd ask anyway.
16:44:31 <koz_> It means I have to change like, one thing, as opposed to like, ten things, so I guess that's something.
16:51:44 <mud> Ya, it'd be a nice thing to have in a bunch of cases, it's just not been figured out what exactly those are and how to accomodate them.
16:58:03 <mniip> hmm
16:58:08 <mniip> is there a monadic sort...
16:58:26 <mniip> sortByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m [a]
17:00:02 <koz_> mud: OK, I have my new template here: https://notabug.org/koz.ross/stack-template/raw/master/koz.hsfiles . How do I tell Stack to use it?
17:01:15 <Harzilein> so i guess my variadic problem is this: how do i match nested tuples [x], [_, [x]], [_, [_, [x]]] ...?
17:07:16 * hackage brick 0.29.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.29.1 (JonathanDaugherty)
17:07:31 <Average-user> Harzilein: Lists or Tuples? Because, if that are lists, you can't have a List with different levels of nested lists
17:07:44 <fishythefish> > let [_, [_, [x]]] = [1, [2, [3]]] in x
17:08:19 <mud> koz_: Specify that URL on the command line, where the template name goes.
17:08:51 <fishythefish> so much for an error demonstration
17:09:07 <Harzilein> Average-user: well, i think for the lispy computer-sciency way they'd need to be pairs
17:09:35 <zachk> fishythefish I don't believe your lists are homoegenuous 
17:10:07 <fishythefish> zachk: yup, hence the expected error (which lambdabot never delivered)
17:10:08 <Harzilein> fishythefish: that matches a nested list with a given length, not with _any_ length
17:11:13 <fishythefish> Harzilein: actually, that code doesn't work because lists must be homogeneous
17:11:20 <koz_> mud: Oh, is that all? Nice!
17:11:22 <fishythefish> i'm trying to demonstrate what Average-user is pointing out
17:11:56 <fishythefish> you can, however, do something similar with tuples
17:12:15 <fishythefish> > let (_, (_, x)) = (1, (2, 3)) in x
17:12:24 <lambdabot>  3
17:12:54 <fishythefish> However, tuples have static size
17:13:00 <[Leary]> Similarly, if your function is supposed to be able to take (a, b), (a, (b, c)), (a, (b, (c, d))) etc as arguments, you'll run into another type error.
17:13:25 <Harzilein> i was looking at this: http://okmij.org/ftp/Haskell/polyvariadic.html
17:15:54 <fishythefish> Harzilein: yes, but you're asking about vanilla lists (or tuples, hard to tell)
17:17:11 <aberrant> rehi
17:17:37 <Welkin> not chocolate lists?
17:17:51 <Welkin> do they come in cheese falvor?
17:17:57 <Welkin> cheese flavor*
17:18:30 <Harzilein> i understand i'm not very clear here. my point is this: i'm looking at a system that does unification. it can use tuples and conses. it has an example where it steps through (please spare me the monads ;) a tuple with a cons in it (omitting the unification expression and using notation from them:) [{1,2,3},{}] -> [{1,2},{3}] -> [{1},{3,2}] -> [{},{3,2,3}] ... where i find they are cheating by giving the example that suits their algorithm ;)
17:18:55 <Harzilein> s/a cons in it/two conses in it/
17:19:07 <Harzilein> s/3,2,3/3,2,1/
17:19:53 * hackage haskell-tools-ast 1.0.0.1, haskell-tools-experimental-refactorings 1.0.0.1, haskell-tools-debug 1.0.0.1, haskell-tools-prettyprint 1.0.0.1 (lazac): https://qbin.io/aokjtwqu
17:20:20 <dmwit> jchia_: Const Void is a Functor but cannot be made an Applicative.
17:22:43 <fishythefish> Harzilein: sorry, this still isn't clear. you appear to be demonstrating an implementation of the reverse function
17:23:11 <fishythefish> on snoc lists
17:23:46 <fishythefish> where do polyvariadics come into it?
17:23:52 * hackage haskell-tools-refactor 1.0.0.1 - Refactoring Tool for Haskell  https://hackage.haskell.org/package/haskell-tools-refactor-1.0.0.1 (lazac)
17:27:14 <Harzilein> fishythefish: if i understood unification-fd, i'd maybe try to state it in terms of that, but because i don't i try it in terms of pattern matching...
17:27:56 <fishythefish> Harzilein: I still don't understand what you're looking for. Do you want an algorithm to reverse a snoc list?
17:29:28 <Harzilein> fishythefish: no, i also don't want an iterator. i want to match on a "snoc list" of variable 'depth'
17:30:18 <zachk> snoc list?
17:30:33 <fishythefish> zachk: like a normal list, but you cons at the end
17:31:16 <zachk> so your cons is flipped?
17:31:43 <adamCS> Stack question: I'm trying the new packages syntax in a custom snapshot and git repos don't seem to be working.  I'm on stack 1.7.0 (though I also tried 1.6.0).  The same git repo entry in extra-deps in the stack.yaml works fine.  But when I move it to "packages" in the custom snapshot it is somehow not seen and stack complains that the package is missing.
17:31:49 <fishythefish> yes, it appends an element to the list rather than prepending
17:31:54 <adamCS> Anyone seen anything like that?
17:32:17 <adamCS> I tried asking in haskell-stack but no one replied for a while so I thought I'd ask here.
17:32:30 <Harzilein> fishythefish: can you help me out how 'cons literals' vs. 'snoc literals' look like in haskell?
17:32:34 <fishythefish> Harzilein: you can pattern match at a finite, statically-known depth
17:33:23 <Harzilein> fishythefish: there's bound to be some syntactic sugar for them, right?
17:33:31 <Average-user> fishythefish: You mean because of Tuples?
17:33:32 <fishythefish> Harzilein: a cons list is the normal list type: approximately, `data [a] = [] | a : [a]`
17:34:02 <mniip> Harzilein, no haskell lists don't have a built-in way to pattern match on a snoc
17:34:06 <mniip> you could define a pattern though
17:34:18 <fishythefish> a snoc list isn't defined in the prelude, but you can easily define a type: `data SnocList a = Nil | (SnocList a) <: a` or something
17:34:24 <zachk> I think a snoc list is just isomorphic to a cons list, so you are still "prepending" to it
17:34:43 <Average-user> zachk; I'm with you
17:34:50 <fishythefish> granted, the choice of "front" and "back" of a list is dependent on how you implement the functions using it
17:34:55 <fishythefish> yes, what zachk said
17:37:00 <fishythefish> Average-user: what about tuples?
17:39:09 <Average-user> doesn't matter now
17:39:39 <Welkin> antimatter now!
17:40:12 <Average-user> ...
17:41:49 <Harzilein> let me show you the actual thing i try to compare to whatever implementations in haskell might offer me. http://harzilein.eu.org/users/harzi/png-tmp/reverse-eps-converted-to.png 
17:43:18 <Harzilein> so the place has a token in it, that happens to be a cons, or snoc, whatever. the edge has an inscription that matches/unifies it to be li. the transition causes the matched li to be embedded in a tuple, together with an empty cons
17:43:23 * hackage network-info 0.2.0.9 - Access the local computer's basic network configuration  https://hackage.haskell.org/package/network-info-0.2.0.9 (JacobStanley)
17:45:01 <Harzilein> then repeated application of unification causes the first cons to be snipped, while building the second cons. then when the first cons is empty, the inscription of the second to last edge succeeds in unifiying, then the bound li is used to extract it again
17:45:50 <Harzilein> this works nicely for their example, but the example seems to have been chosen just because it works nicely
17:46:45 <Harzilein> if i'd want to observe the second cons to be built in order, then the last transition to fire when the first cons is empty, i'd not be able to do that through unification
17:46:53 * hackage unix-compat 0.5.0.1 - Portable POSIX-compatibility layer.  https://hackage.haskell.org/package/unix-compat-0.5.0.1 (JacobStanley)
17:47:02 <Harzilein> so i wondered how people would expect to be able to specify that
18:11:28 <n_blownapart> hello earlier here it was suggested I think of sets when unifying types. ie  (c -> c) ~ (q -> r -> s)   is the same as (c, c) == (q, (r,s))    so far so good?
18:11:29 <woodson> anyone knows how to convert [GHC.Word.Word8] to Data.ByteString.Lazy.ByteString ? Data.Aeson.decode needs a Data.ByteString.Lazy.ByteString
18:11:52 <woodson> but I am pulling a string with lookupEnv
18:12:15 <woodson> from System.Environment
18:12:48 <n_blownapart> so the unity of const id would be (c, c) == (a, (b,a))
18:12:54 <n_blownapart> in terms of sets
18:13:27 <n_blownapart> is that correct
18:13:59 <crucify_me> << sorry the real me
18:14:33 <lyxia> what does that have to do with sets
18:15:07 <lyxia> The point was that (->) and (,) behave the same with respect to unification.
18:15:47 <lyxia> They are both type constructors with two arguments, and two types constructed with either of them are equal only if the corresponding arguments are equal
18:16:20 <lyxia> woodson: Data.ByteString.Lazy.pack ?
18:16:52 <crucify_me> I didn't know they were actual haskell, I thought it was for illustration
18:17:45 <crucify_me> still..
18:20:06 <crucify_me> lyxia I took it as being a more formal way of writing it, to make the process of unification more 'formal'
18:21:31 <crucify_me> but in the case of unifying const id  ,  I don't see how it makes it more formal
18:21:53 <crucify_me> or how the extra step has value for conceptualizing the unity
18:23:00 <lyxia> c -> c
18:23:04 <lyxia> ~
18:23:08 <lyxia> q -> (r -> s)
18:23:23 * hackage closed 0.1.0 - Integers bounded by a closed interval  https://hackage.haskell.org/package/closed-0.1.0 (cdparks)
18:23:28 <lyxia> The (->) on the left match. So now we match the arguments.
18:23:35 <lyxia> c ~ q,   c ~ (r -> s)
18:23:41 <crucify_me> c ~ q  and c ~ (r -> s)
18:24:16 <crucify_me> yes what about the case of const id. I know its b -> (c -> c)
18:24:33 <crucify_me> I know how its done
18:24:52 <fishythefish> const id is actually far simpler
18:25:03 <fishythefish> :t const
18:25:04 <lambdabot> a -> b -> a
18:25:09 <Welkin> it's all basic algebra
18:25:19 <fishythefish> you just need to unify a with the type of id, but you're done immediately
18:25:21 <crucify_me> (c->c) -> b -> (c -> c)   => b -> (c -> c)
18:25:30 <Welkin> al-jabr!
18:25:40 <Welkin> "Algebra (from Arabic "al-jabr" meaning "reunion of broken parts"[1])"
18:25:58 <crucify_me> but what about the bit with the (c, c) etc ?
18:27:11 <fishythefish> crucify_me: i think you're taking [Leary]'s analogy too literally
18:27:45 <fishythefish> the point was that if you don't see how a -> b ~ c -> d is equivalent to a ~ c and b ~ d, then think of tuples instead of function arrows:
18:27:52 <fishythefish> (a, b) ~ (c, d) gives you a ~ c and b ~ d
18:27:52 <Welkin> I don't understand what (c,c) has to do with anything here
18:27:53 <Welkin> o.o
18:28:04 <Welkin> that doesn't appear anywhere in the type
18:28:17 <fishythefish> Welkin: see the explanation i just gave
18:28:20 <crucify_me> it was from earlier.
18:28:29 <Welkin> oh, okay
18:28:49 <fishythefish> crucify_me: we're not actually turning functions into tuples
18:28:54 <Welkin> I like to think of type unification as being like pattern matching
18:29:03 <crucify_me> no its really easy. I thought that the tuple thing was a good step esp if things got more complicated
18:29:09 <Welkin> you make the shapes fit together
18:30:04 <crucify_me> I meant const id is really easy to unify
18:30:26 <Welkin> my favorite type unification so far is (.).(.)
18:30:47 <crucify_me> thats on my queue 
18:30:48 <Welkin> well, to derive the type of (.).(.) given we know the type of (.)
18:31:01 <Welkin> I worked on it for hours making the same dumb mistake over and over
18:31:19 <Welkin> then after I got home later in the day, I sat down with a fresh sheet of paper and wrote it all out in about 5 minutes
18:31:20 <crucify_me> b->c->a->b->a->c
18:31:22 <Welkin> it was great
18:31:25 <Welkin> and quite short
18:31:48 <fishythefish> crucify_me: what is that the type of?
18:31:59 <crucify_me> please stamp the envelope and send it to me Welkin
18:32:33 <fishythefish> no, no, don't read someone else's solution
18:32:43 <crucify_me> (b->c-)>(a->b)->(a->c)
18:32:49 <crucify_me> is that wrong?
18:33:00 <fishythefish> barring a typo, that's :t (.)
18:33:02 <crucify_me> for (.)
18:33:21 <crucify_me> (b->c)->(a->b)->(a->c)
18:33:55 <crucify_me> I have no context. like why would I use (.) . (.)
18:34:10 <Welkin> crucify_me: oh, that is a treat for another day
18:34:12 <Welkin> :P
18:34:13 <heath> that's the blackbird, right?
18:34:27 <Welkin> I have an excellent video from a talk at Strangeloop on it
18:34:28 <crucify_me> Welkin: word
18:34:38 <Welkin> it will change the way you think about point-free and composition
18:34:44 <heath> Welkin: i was watching that video last night :)
18:34:46 <crucify_me> I enjoy this stuff though I feel retarded
18:34:48 <fishythefish> heath: yeah, i believe so
18:34:54 <heath> amar shah, right?
18:35:02 <Welkin> yes, I think
18:35:04 <heath> https://www.youtube.com/watch?v=seVSlKazsNk
18:35:06 <Welkin> and yes it is the blackbird
18:35:26 <Welkin> crucify_me: haha, we all feel that way when we are learning something for the first time
18:35:33 <heath> here is the closing quote from that video..
18:35:35 <heath> "Point free style has a really long pedigree, a long history, and it comes from conversations in computer science about how we make programming and how we can make computing more composable, and how we can actually build abstractions that are concise, but still don't leak. And that's something we're still chasing today. I know a lot of people will look at syntax and point free is all about questions of 
18:35:41 <heath> syntax. A lot of people will look at syntax and say it's just not important, but I think nothing could be further from the truth. Syntax is where we communicate and how we choose to communicate will make programming what it is for the days and years to come."
18:35:48 <Welkin> I felt pretty stupid for the first few months of learning haskell. I just didn't get so many things that are obvious to me now
18:35:59 <koz_> Is there a monadic version of constructN for vectors?
18:36:12 <koz_> Welkin: I still feel pretty stupid when I Haskell.
18:36:28 <fishythefish> crucify_me: you can often glean info about how you would use something by reading its type
18:36:33 <fishythefish> :t (.) . (.)
18:36:35 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
18:36:35 <Welkin> koz_: me too, depending on what I am doing
18:36:46 <fishythefish> there's only one thing that function can really do - think about what that is
18:36:50 <Welkin> it took me 2 or 3 days just to figure out how to get pagination working how I wanted in hakyll
18:37:31 <Welkin> but the feeling that you get when you finally figure it out and you have this elegant program! That is better than anything
18:38:00 <koz_> (to be specific, the sig I'm hunting for is 'Unbox a, Monad m => Int -> (Vector a -> m a) -> m (Vector a)'
18:38:15 <koz_> s/)'/')
18:38:20 <crucify_me> I'm going to India to find a brilliant haskell person, pay them 8usd / hour for lessons, and eat masala dosa with coconut curry
18:39:05 <crucify_me> all vegan of course
18:39:21 <koz_> crucify_me: Haskell lessons can contain meat?
18:39:24 <heath> crucify_me: you can pay me. i accept usd and vegan food
18:39:37 <takitus> crucify_me: At some Haskell ashram?
18:39:37 <crucify_me> where do you live seriously
18:39:42 * heath missed his flight to delhi on the 4th though :\
18:39:44 <koz_> heath: Specifically both?
18:40:04 <crucify_me> takitus: yes!
18:40:06 <koz_> Like, you must be paid in the conjunction of USD and vegan food?
18:40:11 <koz_> Or will a disjunction do?
18:40:14 <[Leary]> I really wish (..) was as allowable function so we would have a nice infix name for (.).(.)
18:40:17 <heath> koz_: :)
18:40:18 <skaillet[m]> fishythefish: ashbreeze crucify_me crucify_me lambdabot aaronc
18:40:31 <crucify_me> ??
18:40:35 <koz_> [Leary]: I would just call it 'owl'.
18:40:40 <skaillet[m]> [Leary]:
18:40:44 <skaillet[m]> [Leary]: [Leary]
18:40:46 <skaillet[m]> heath:
18:41:22 <Welkin> @ops spam bot?
18:41:22 <lambdabot> Maybe you meant: pl oeis docs
18:41:33 <heath> thanks Welkin 
18:41:36 <skaillet[m]> fishythefish: fishythefish
18:41:44 <Welkin> I forgot the ops trigger :P
18:42:04 <koz_> [Leary]: It's not in any way a worse name, than, say 'confusing'.
18:42:15 <crucify_me> is there a technical failure in the chat?
18:43:09 <[Leary]> I've been "dropping the parentheses" as it were, using ... as a compromise between (.).(.) and ..
18:43:46 <crucify_me> :t (.) . (.)
18:43:47 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
18:43:57 <crucify_me> btw no clue how to read that
18:44:34 <Welkin> crucify_me: wait until you are ready for it and then watch the video heath linked
18:45:11 <crucify_me> ok I will prevail ! thanks Welkin
18:50:16 <koz_> In the type sig for 'fill' here: https://www.stackage.org/haddock/nightly-2017-12-05/vector-0.12.0.1/src/Data.Vector.Generic.html#constructN what does 'v' refer to?
18:50:28 <koz_> Isn't it meant to be 'Vector'? What am I missing?
18:51:11 <koz_> Oh, never mind, should have looked one line above.
18:53:35 <Welkin> what are you doing with vecotrs koz_ ?
18:53:57 <koz_> Welkin: I want 'constructNM :: (Monad m, Unbox a) => Int -> (Vector a -> m a) -> m (Vector a)
18:54:02 <koz_> '
18:54:08 <koz_> It doesn't seem to exist already, so I want to write it.
18:54:19 <koz_> And I was looking at the definition of constructN to see how it works.
18:54:32 <Welkin> why do you need Unbox in the type?
18:54:45 <Welkin> it could be more generic
18:54:53 <koz_> I'm working with unboxed vectors in my case, but yes, it could be.
18:54:57 <cheater> i am developing a programming language. how do i make sure that the features of the language do not mesh together in unexpected ways that destroy the way people can reason about the language? for example, some haskell extensions don't really mesh together really well.
18:55:16 <koz_> Welkin: Do you suggest I write it against Data.Vector.Generic?
18:55:30 <Welkin> do whatever works for you
18:55:57 <jessicaw> lengtH _:xs = 1 + (lengtH xs)
18:56:03 <jessicaw> how come this pattern doesn't work?
18:56:04 <koz_> Welkin: I'll try, but I do see your point wrt being generic.
18:56:16 <koz_> jessicaw: What do you mean by 'doesn't work'?
18:56:33 <jessicaw> it won't compile, error reads parse error in pattern
18:56:52 <mnoonan_> jessicaw: you need to put parens around the (_:xs) part, or else it looks like (lengtH _):xs
18:57:22 <jessicaw> ah.... i'm fairly new, excuse me for the stupid mistake!!
18:57:25 <jessicaw> let me try that
18:57:29 <alsoStevenXL> hi everyone; quick question, is it possible to import a module from the executable target in my test target? or do i need to put the module in the library target so i can use exposed-modules?
18:57:39 <Welkin> jessicaw: are you by any chance a crow?
18:57:40 <koz_> jessicaw: Don't worry about it - we were all new once. I still make daft mistakes. :P
18:57:56 <mnoonan_> jessicaw: I would say not your fault there, the compiler error is not helpful at all
18:58:03 <koz_> Welkin: That has to be one of the most left field questions I've heard in a while.
18:58:21 <Welkin> koz_: you don't see it? jessi"caw"
18:58:30 <koz_> Welkin: ... derp.
18:58:54 <koz_> When I read that I was like 'is Welkin a GoT Free Folk or something?'.
18:59:20 <koz_> Also, what flag do I pass GHCi to tell it to not load the Prelude?
18:59:22 <Welkin> free folk are the best
18:59:35 <Welkin> :set -XNoImplicitPrelude
18:59:49 <Welkin> you can also set that as a pragma in your source file
18:59:55 <koz_> Welkin: Is there something I can feed it on the command line? It's for neovim-ghci.
19:00:03 <koz_> It's set as a pragma in my source file.
19:00:04 <Welkin> not sure
19:00:10 <koz_> OK, I'll keep hunting.
19:00:12 <Welkin> there may be a way to pass these when you start it
19:05:27 <mnoonan_> koz_: isn’t -Xblah literally a valid command line option for ghci?
19:05:38 <koz_> mnoonan_: I guess? Let me try.
19:06:11 <koz_> mnoonan_: Yay! Thanks, that works.
19:09:24 <d-fish> I'm trying to use gitlib to write a git wrapper (should I just call shell commands?).  The documentation links to nonexistant pages
19:14:39 <alsoStevenXL> hi folks. there are a few things that i keep repeating in my *cabal file, default-extensions, ghc-options, etc. is it possible to set these somewhere so that they apply to all argets?
19:17:56 <koz_> alsoStevenXL: If you use Stack, just define a template that suits you - I did that today, and it was very simple.
19:21:28 <alsoStevenXL> koz_: thank you; yes i do use stack
19:21:32 <alsoStevenXL> i'll do that
19:21:33 <alsoStevenXL> ;)
19:21:52 <koz_> alsoStevenXL: The .hsfile template is really easy to write, and it'll save you a bunch of time.
19:21:55 <koz_> (in the future)
20:14:52 * hackage hedgehog 0.5.1 - Hedgehog will eat all your bugs.  https://hackage.haskell.org/package/hedgehog-0.5.1 (JacobStanley)
20:25:28 <Average-user> Preparing for todays AoC?
20:26:47 <koz_> If I 'traverse' an infinite list, will my program explode?
20:27:40 <glguy> depends on what you're doing
20:28:22 <glguy> > traverse (const Proxy) (repeat ())
20:28:24 <lambdabot>  Proxy
20:29:21 <koz_> glguy: Let me rephrase my question. I want to generate an infinite list of random Foos in a MonadRandom m (which gives me [m Foo]), but then I need to filter them for uniqueness and take the first k that come up.
20:29:38 <koz_> Can I write this the 'obvious' way, or will it blow up when I try to go from [m Foo] to m [Foo]?
20:30:20 <glguy> koz_: It might or might not work, MonadRandom doesn't tell you enough to know
20:30:34 <koz_> glguy: What would I need to know to know?
20:30:37 <glguy> If you picked a type like lazy State then it ought to work
20:30:38 <tabemann> what is your guys opinion of how distributed-process compares to Erlang/OTP
20:31:29 <koz_> glguy: If I use runRand from Control.Monad.Random.Lazy, is that the same as lazy State?
20:31:43 <koz_> (sorry, the same as runState on on a lazy State computation)
20:35:22 <mniip> if ~1000 solve per hour...
20:35:42 <mniip> then to get any sort of points on the global leaderboard you need to be in the first 5 mins?
20:36:00 <koz_> mniip: So basically, babysit and hope you're in the right timezone?
20:36:58 <glguy> mniip: You can look at the completion times per day to see how long everyone took
20:37:39 <mniip> damn
20:38:25 <glguy> I didn't get into it the first couple days last year but you didn't need to finish in 5 minutes after the first few days to get on the leaderboard: https://glguy.net/stats.txt
20:38:26 <koz_> Also, is there a function of the form 'Monad m => m a -> [m a]' that just does 'm a' endlessly and collects the results in an infinite list?
20:38:50 <mniip> koz_, uh you mean m [a]
20:39:10 <koz_> mniip: Yes, I do mean that.
20:39:18 <mniip> only for certain lazy m
20:39:27 <koz_> mniip: Yeah, I understand that.
20:39:38 <koz_> (I've been bitten by monad evaluation strictness in the past)
20:40:24 <mnoonan_> :t sequence . repeat — koz_
20:40:27 <lambdabot> error:
20:40:27 <lambdabot>     Variable not in scope: (—) :: (m0 a0 -> m0 [a0]) -> t0 -> t
20:40:27 <lambdabot> error: Variable not in scope: koz_
20:40:34 * koz_ is not in scope.
20:40:42 * mnoonan_ needs to fix his irc client
20:40:44 <koz_> I'm a free variable, yay!
20:40:44 * mniip aims at koz_
20:40:48 <mnoonan_> :t sequence . repeat
20:40:49 <lambdabot> Monad m => m a -> m [a]
20:41:06 <koz_> :t repeat
20:41:07 <lambdabot> a -> [a]
20:41:14 <koz_> :t sequence
20:41:16 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
20:41:34 <koz_> Oh, cool.
20:42:35 <mnoonan_> monad-loops also has various stuff
20:42:47 <koz_> mnoonan_: That was going to be my next place to look.
20:43:09 <koz_> As jle` says: monad-loops is Haskell's left-pad.
20:44:26 <mnoonan_> .. even more so than acme-left-pad ?!
20:44:40 <koz_> mnoonan_: acme-left-pad is parody. left-pad isn't.
20:44:48 <koz_> (at least insofar as JS isn't all parody all the time)
20:47:02 <Average-user> Have you seen WAT?
20:47:11 <koz_> Average-user: What is WAT?
20:47:32 <Average-user> https://www.youtube.com/watch?v=VTE3DM2Aygk
20:48:21 <Welkin> ruby and python have similar "wtf" examples
20:48:25 <Welkin> because they lack a type system
20:48:48 <Average-user> But JS's are other thing ...
20:49:09 <Welkin> not really
20:49:13 <Welkin> they are all just as bad
20:49:54 <Average-user> I dno't want to enter in the argument between Typed and not Tyeped languages
20:49:54 <koz_> Welkin: JS is arguably more absurd.
20:50:08 <koz_> Non-transitive equality is pretty amazing in its own right.
20:50:25 <Average-user> But JS's errors are more easy to notes at least
20:50:25 <koz_> Only PHP and JS have non-transitive equality on built-in types by default.
20:50:37 <koz_> Average-user: Ever been bitten by 'this'?
20:51:28 <Average-user> Don't sure what you mean
20:51:35 <Average-user> (koz_)
20:51:42 <koz_> Average-user: 'this' in JS is a barrel of confusion.
20:52:15 <Welkin> this is like arguing over whether mcdonalds or burger king is worse. They both suck. Go to a japanese sushi restaurant instead.
20:52:21 <Average-user> ohh
20:52:25 <koz_> Welkin: Lol.
20:52:30 <Average-user> I'm not a JS user
20:52:39 <glguy> Well, I mean in that situation obviously BK is better
20:52:53 <Average-user> glguy: BK?
20:53:15 <koz_> Yay! Laziness ftw.
20:53:24 <glguy> Burger King
20:53:32 <Average-user> ohh
20:53:53 <mud> Hey, be nice to JS. It's at least interestingly weird. In a world where every language seems to want to just be a copy of every other one out there, they chose wacky shit that's kind of fun to play with.
20:54:20 <koz_> mud: s/every other one/C/
20:54:34 <Average-user> mud: The guy that talks on the videos, it is actually a JS programmer
20:54:57 <Welkin> mud: I write javascript every day for work and have been for a year now
20:55:04 <mud> I didn't mean the wat video, that's just funny.
20:55:09 <mud> Welkin: Oh okay, then you can make fun of it.
20:55:17 <Average-user> mud: I just found that  video funny, I don't use JS.
20:55:20 <Welkin> it true that it's not so bad once you figure out how to work around its problems and mold it into your own version of scheme
20:55:30 <Welkin> but it's no haskell
20:55:37 <mud> Ya
20:55:38 <zomg> The only thing confusing about `this` in JS is that they called it `this` and because it doesn't work like `this` does in say Java it confuses people as they expect it to do something it doesn't do :P
20:57:46 <koz_> Is there a zipM :: Monad m => m [a] -> m [b] -> m [(a, b)]?
20:58:53 <Average-user> :t zipM
20:58:54 <lambdabot> error:
20:58:54 <lambdabot>     • Variable not in scope: zipM
20:58:54 <lambdabot>     • Perhaps you meant one of these:
20:59:28 <mniip> :t liftA2 zip
20:59:29 <lambdabot> Applicative f => f [a] -> f [b] -> f [(a, b)]
20:59:55 <skaillet[m]> lambdabot: Average-user
20:59:59 <skaillet[m]> lambdabot:
21:00:04 <Welkin> the spambot is back
21:00:19 <Welkin> !ops
21:06:54 <glguy> Welkin: which?
21:07:06 <mniip> yay
21:07:11 <koz_> skaillet[m] <-- spambot
21:08:00 --- mode: ChanServ set +o glguy
21:08:00 --- mode: glguy set +q *!*@gateway/shell/matrix.org/x-rjpolznvbygajodd
21:08:44 <mniip> well I did beat some people
21:08:54 <mniip> but not glguy apparently
21:08:58 <glguy> Sorry :)
21:09:28 <mniip> this is some of the sketchiest C++ I've ever written
21:09:53 <mniip> even has a goto
21:10:59 <mniip> now
21:27:13 <boxscape> @pl (\a b c -> a + b + c)
21:27:13 <lambdabot> ((+) .) . (+)
21:31:13 <koz_> Could someone point me to any resources on 'tying the knot' in Haskell? I'd like to use a knot-tying rep for DAGs, as it would make my work easy, but I have no clue what I'm doing.
21:32:40 <jle`> aw man
21:32:50 <jle`> i had the solution for the second one correct but it was my fancy test suite i spent all day building
21:32:59 <jle`> that seemed to keep on erroring
21:33:16 <jle`> i spent 10 minutes debugging the test suite i spent all day writing >_>
21:34:40 <mnoonan_> koz_: https://hackage.haskell.org/package/justified-containers-0.2.0.1/docs/Data-Map-Justified.html#v:tie  can do it, and iirc there is another package out there for tying knots
21:34:44 <shapr> koz_: https://wiki.haskell.org/Tying_the_Knot
21:36:24 <koz_> mnoonan_: tie confuses me.
21:39:54 <dminuoso> Is it necessary for <|> to be different than mplus?
21:42:39 <jle`> it is necessary for them to be the same
21:49:37 <glguy> Doing Advent of Code tonight but managed to miss all my advertisements?? Join the #haskell group: http://adventofcode.com/2017/leaderboard/private 43100-84040706
21:53:59 <dminuoso> jle`: Fair enough. Stephen Diehls book is misleading then, because he provides two alternative (no pun intended) implementations
21:54:13 <cocreature> I’m not sure why it should be necessary for them to be the same
21:54:22 <jle`> it's one of the laws isn't it?
21:54:34 <cocreature> if it is, I can’t find it :)
21:54:46 <jle`> oh, you're right
21:54:48 <jle`> hmmm
21:55:11 <dminuoso> I mean in a bizarre way I really do want to have two monoids on this monad.
21:55:34 <jle`> i mean it's safe to say that most people assume msum => <|> is an ok substitution
21:55:56 <cocreature> dminuoso: tbh, I’d probably use newtypes in that case instead of choosing a different behavior for MonadPlus and Alternative
21:55:57 <jle`> ...isn't it?
21:56:05 <jle`> or msum => asum
21:56:05 <glguy> jle`: mplus rather, yes
21:56:18 <cocreature> simply because I could never remember which instance does what if they behave differently
21:56:47 <dminuoso> cocreature: In the context of a parser, would you assume <|> and mplus to do the same thing?
21:56:58 <mnoonan_> koz_: http://lpaste.net/360537  <- not tested at all, but here is an example
21:57:00 <jle`> also MonadPlus's haddock documentation could be considered incomplete because it doesn't include a discussion about all of the other laws that it could potentially have
21:57:29 <dminuoso> jle`: Mmm, I do recall that the laws MonadPlus should follow have no common consensus.
21:57:38 <cocreature> dminuoso: in the context of a parser I would just always use <|> instead of mplus :)
21:57:48 <jle`> dminuoso: indeed it a controversial topic
21:57:48 <koz_> dminuoso: Yeah - the Typeclassopedia explains this quite well.
21:57:56 <cocreature> I don’t use MonadPlus very often
21:57:56 <koz_> (IO seems to be a cause of many of these issues)
21:58:15 <jle`> but "mplus => <|>" is a substituion that most people would make
21:59:02 <cocreature> heh, interestingly I never thought of making that substitution
22:00:44 <dminuoso> koz_: Oh interesting, the typeclassopedia makes the case that MonadPlus should be avoided since Applicative became a superclass of Monad.
22:01:54 <koz_> dminuoso: It also spends time discussing issues around Alternative laws.
22:02:21 <koz_> mnoonan_: What does the 't' type parameter in Cell meant to represent?
22:02:43 <dminuoso> koz_: Giving it a read. Thank you for that hint, didn't know about its existence.
22:03:25 <koz_> dminuoso: The Typeclassopedia is a great resource. Every time I re-read it, I learn something.
22:03:36 <mnoonan_> koz_: concretely, whatever type you want to use to represent a reference. But it has to be a type parameter because ‘tie’ kind of does a fold over the map, and will sub in some other type in the process
22:04:10 <koz_> mnoonan_: Ah, so it's basically a 'pointer'?
22:04:20 <koz_> (for a vague-enough definition of 'pointer')
22:04:30 <mnoonan_> right
22:05:07 <dminuoso> koz_: Oh wow. It also explains some/many, which have given me a sleepless night.. but I think I had to go through that process. Didn't understand the monadic interface of my parser. :-)
22:05:20 <koz_> dminuoso: Happens.
22:05:39 <koz_> Sometimes, that kind of painful process actually helps in the long term, as it forces you to figure something out on your own terms.
22:14:08 <koz_> What on earth is 'hash consing'? The wiki is remarkably silent on this topic.
22:16:34 <cocreature> koz_: basically you try to reuse existing elements instead of allocating new elements https://en.wikipedia.org/wiki/Hash_consing
22:17:24 <koz_> OK, that makes slightly more sense.
22:17:38 <koz_> Generally, knot-tying hurts my brain for some reason.
22:17:53 * hackage haskell-tools-backend-ghc 1.0.0.1, haskell-tools-builtin-refactorings 1.0.0.1, haskell-tools-cli 1.0.0.1, haskell-tools-daemon 1.0.0.1, haskell-tools-rewrite 1.0.0.1, haskell-tools-demo 1.0.0.1 (lazac): https://qbin.io/v5drlxy
22:26:39 <jle`> huh my AoC with IntMap got no faster when i switched to Vector
22:26:51 <jle`> i guess it's becasue the length is super short anyway
22:28:01 <boxscape> for today's problem?
22:29:13 <jle`> yeah
22:29:28 <boxscape> yeah, ok, 16 is indeed pretty short
22:38:40 <koz_> For the direct-indirect DFA example in https://wiki.haskell.org/Tying_the_Knot, what does 'array' and '!' do?
22:39:58 <cocreature> koz_: https://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array.html#v:array and https://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array.html#v:-33-
22:40:38 <koz_> cocreature: Ah, I see, it's like Vector.fromList (kinda) and Vector.!.
22:40:57 <cocreature> yeah
22:45:10 <koz_> Dunno if I understood correctly, but that example seems to rely on the fact that each 'lookup' into the array used for memoization will happen exactly once.
22:45:22 <koz_> It still messes with my head a bit though.
22:48:39 <geekosaur> I think you missed a level. the lookup happens but only the first causes computation, for the rest the already computed thunk is reused
22:49:34 <geekosaur> and when the thunk to compute the value of one cell relies on the thunks for other cells, this means each cell is computed only one and the computed value reused for subsequent computations of other cells' thunks
22:50:07 <geekosaur> s/already computed thunk/already computed value which replaces the original thunk/
22:50:34 <andrei> I'm using a package that generates some c++ code (opencv) and this seems to confuse stack. It constantly wants to rebuild "opencv-0.0.2.0: unregistering (local file changes: src/OpenCV/Calib3d.cpp ...". Is there a way to disasble this?
22:50:52 <geekosaur> which is basically how laziness can produce memoization 'for free' if you set things up right
22:51:06 <koz_> geekosaur: Yeah, my brain still isn't processing this correctly.
22:57:27 <jle`> kind of sad that there were two heavily imperative AoC's in a row
22:57:42 <jle`> i guess it's making up for the really functional one the other day
23:00:26 <cocreature> jle`: I kind of like it tbh, I rarely get the opportunity to practise my imperative Haskell otherwise :)
23:00:30 <glguy> Today was heavily imperative?
23:01:36 <jle`> yes the entire problem was analyzing an imperative algorithm
23:01:59 <jle`> and the operational semantics of a virtual machine
23:02:13 <jle`> not to be reductive
23:02:33 <jle`> cocreature: fair point though :)
23:03:08 <jle`> there might be functional solutions available but any denotative/analytic/functional solutions come down to how well you can understand a contrived imperative process
23:03:32 <jle`> not that that's a bad thing :O  just giving the reason to why i called it 'imperative'
23:05:22 <glguy> jle`: Just looking over github and our solutions have a lot in common :)
23:05:57 <jle`> i just noticed too, haha
23:06:06 <wawhal_> Hey guys .. how to serve static content using Haskell-spock .. I am using respondMiddleware .. it isn't working
23:06:06 <jle`> we both have a function called findLoop, that did the exact same thing >_>
23:06:21 <jle`> s/did/do
23:06:26 <cocreature> I always suspected that jle` and glguy are the same person
23:07:35 <jle`> ...we both also have step :: Vector Int -> Vector Int
23:07:46 <jle`> maybe it's like a collective unconscious kind of thing
23:09:17 <jle`> glguy: nice use of accum though :O  i originally accum'd one item at a time but i forgot that you can accum on the same index twice
23:09:31 <jle`> maybe i really should be writing more vector code
23:09:36 <jle`> to practice
23:10:00 <glguy> the nice thing about accum is that it mutates under the hood, so it's not a  bunch of vector copies along the way
23:10:14 <MarcelineVQ> nooo, don't do this aoc :( don't be right every step of the example and fail on the puzzle input
23:10:40 <jle`> :(
23:10:45 <jle`> off-by-one ?
23:11:22 <MarcelineVQ> shouldn't be, 5 steps like the example, exact same result stepper step. not much I can do but try a couple off-by-ones though
23:16:14 <wawhal_> Hey guys .. how to serve static content using Haskell-spock .. I am using respondMiddleware .. it isn't working
23:16:36 <Rembane> wawhal_: How is it not working?
23:17:10 <wawhal_> It is just unable to find the files 
23:17:28 <Rembane> wawhal_: Ah. Where does it search for files and where are your files?
23:17:39 <wawhal_> I am running respondMiddleware $ staticPolicy $ addBase "static"
23:18:03 <Rembane> Do you have your files in the static folder?
23:18:11 <wawhal_> I have placed them correctly; in the root directory .. it searches in the root directory
23:18:16 <wawhal_> of course :D
23:19:00 <cocreature> maybe try an absolute path prefix to make sure it’s not starting from the wrong directory?
23:20:20 <wawhal_> it is definitely not starting from the wrong directory because i tried serving a file using `file "myfile" "static/index.html"` 
23:20:22 <wawhal_> that works
23:24:58 <dminuoso> https://gist.github.com/dminuoso/2e83de5c8cea4135419a4690ea282d31 "dynamic languages have ruined me" :(
23:25:13 <dminuoso> I seriously expected this to work until I just.. looked at fmap.
23:26:28 <mniip> well
23:26:34 <mniip> in haskell the functor instance is unique
23:28:33 <rightfold> mniip: is it even possible for their to be multiple extensionally distinct lawful implementations of fmap?
23:28:39 <rightfold> there*
23:28:50 <mniip> no, that's what I said
23:29:22 <rightfold> I interpreted what you said as not being able to define multiple instances at the same time
23:29:35 <rightfold> Now it is all clear. 😃
23:29:37 <mniip> okay, no in absence of type families/gadts
23:31:13 <mniip> might be possible with gadts...
23:31:14 <mniip> not sure
23:32:31 <dminuoso> Are heterogenous lists even possible? Would that possibly require dependent types?
23:32:43 <mniip> Yes. No.
23:32:51 <dminuoso> Okay thanks!
23:34:24 <mniip> @let data HList (xs :: [k]) where HNil :: HList '[]; HCons :: x -> HList xs -> HList (x ': xs); infixr 5 `HCons`
23:34:24 <lambdabot>  Parse failed: Parse error: infixr
23:34:27 <mniip> aw
23:34:53 <mniip> bad habit of erasing words with ^W :s
23:35:00 <mniip> @let data HList (xs :: [k]) where HNil :: HList '[]; HCons :: x -> HList xs -> HList (x ': xs)
23:35:02 <lambdabot>  Defined.
23:35:16 <mniip> > 1 `HCons` () `HCons` 'x' `HCons` HNil
23:35:18 <lambdabot>  error:
23:35:19 <lambdabot>      • Couldn't match expected type ‘HList xs’ with actual type ‘()’
23:35:19 <lambdabot>      • In the second argument of ‘HCons’, namely ‘()’
23:35:27 <mniip> :t 1 `HCons` (() `HCons` ('x' `HCons` HNil))
23:35:28 <rightfold> Interesting!
23:35:29 <lambdabot> Num x => HList '[x, (), Char]
23:35:35 <dminuoso> :o
23:35:36 <dminuoso> mind blown
23:35:46 <dminuoso> What kind of dark magic is at work there.
23:35:47 <rightfold> I’m aware GADTs also inhibit various unsafeCoerce optimizations that would otherwise be possible.
23:36:03 <mniip> @let deriving instance Show (HList '[])
23:36:05 <lambdabot>  .L.hs:171:1: error:
23:36:05 <lambdabot>      • Couldn't match type ‘'[]’ with ‘x : xs’
23:36:05 <lambdabot>        Inaccessible code in
23:36:09 <mniip> aww
23:36:14 <mniip> I can't even derive
23:39:24 <jle`> @let deriving instance Show (HList as)
23:39:26 <lambdabot>  .L.hs:171:1: error:
23:39:26 <lambdabot>      • Could not deduce (Show x) arising from a use of ‘showsPrec’
23:39:26 <lambdabot>        from the context: (k ~ *, (as :: [k]) ~~ ((x : xs) :: [*]))
23:42:28 <mniip> yeah right
23:43:02 <mniip> @let instance Show (HList '[]) where showsPrec d HNil = showString "HNil"
23:43:03 <lambdabot>  Defined.
23:44:11 <mniip> @let instance (Show x, Show (HList xs)) => Show (HList (x ': xs)) where showsPrec d (HCons x xs) = showParen (d > 5) $ showsPrec 6 x . showString " `HCons` " . showsPrec 5 xs
23:44:12 <lambdabot>  Defined.
23:44:18 <mniip> > 1 `HCons` (() `HCons` ('x' `HCons` HNil))
23:44:20 <lambdabot>  1 `HCons` () `HCons` 'x' `HCons` HNil
23:44:36 <mniip> one slight issue becasue `HCons` isn't *really* defined infixr 5 up there but
23:44:54 <mniip> though hmmm
23:45:01 <mniip> @let infixr 5 `HCons`
23:45:03 <lambdabot>  Defined.
23:45:05 <mniip> !
23:45:42 <boxscape> > 1 `HCons` () `HCons` 'x' `HCons` HNil
23:45:44 <lambdabot>  1 `HCons` () `HCons` 'x' `HCons` HNil
23:45:46 <boxscape> nice
23:49:14 <jle`> mniip: haskell plays some tricks with fixity declarations being declarable anywhere in the file
23:49:22 <jle`> luckily tokenization is 'dumb' enough
23:49:30 <mniip> yeah
23:49:32 <jle`> but it does limit some of the syntax i think
23:49:32 <mniip> but not hint
23:49:35 <mniip> which lambdabot uses
23:50:15 <jle`> :t 1 `HCons` () `HCons` 'x' `HCons` HNil
23:50:16 <lambdabot> Num x => HList '[x, (), Char]
23:58:53 <boxscape> :t 1
23:58:54 <lambdabot> Num p => p
23:59:19 <boxscape> always interesting to see which letters are chosen as type variables
