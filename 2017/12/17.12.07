00:03:11 <osa1> I want to add a route to my warp + servant web server to publish some debug info that should be updated live, but I don't want to implement a html page with javascript to fetch updates off a websocket etc. is there a library for this kind of stuff?
00:03:52 <dminuoso> ski: Yeah not exactly elegant. Thanks though.
00:37:11 <ertes-w> hllo
00:41:43 <mazu> is there something like a `trustMe :: ((a ~ b) => c) -> c` in haskell? since haskell's type coercions are free of computation it should be possible to write it
00:43:16 <jle`> mazu: does Data.Type.Equality have anything like what you're looking for?
00:44:23 <mazu> jle`: not that i can see
00:44:41 <mazu> basically i want to conjure equality constraints out of thin air
00:44:52 <mazu> obviously not type-safe, but it should be possible
00:45:15 <mazu> (as oppose to, say, conjuring type class constraints, which would require inventing the method instances)
00:45:59 <jle`> unsafeCoerce Refl :: a :~: b     ..?
00:46:29 <mazu> jle`: ah yes, that might work! thank you
00:46:43 <jle`> it's definitely not an uncommon pattern :)
00:53:24 <mazu> jle`: ok, all good: <https://pastebin.com/vmapsruE>
00:55:57 <boxscape> I'm a bit confused. Why does this give me a parse error ? [ia, if] <- mapM readFile ["input.txt", "input2.txt"]
00:56:08 <boxscape> (in ghci)
00:56:19 <kahlil29> I have a Set Text(Data.Set) and a [(Text, String)]. The List may not have all values in the set. I need to add whichever values are present in the Set but not in the list (1st element of the tuple) to the List along with some default String Value to indicate that it wasn't present originally. What is the best way to do this and is there a way using folds? I can't seem to get it. 
00:57:42 <Rembane> kahlil29: What about turning the list into another set and comparing the two using difference?
00:58:48 <kahlil29> Rembane : But then I lose my values initially present in the List right? The inital list is sort of a map from Text to the String values. 
01:00:08 <boxscape> ohhh, because I named one of my variables if -.-
01:00:33 <[Leary]> You can refer to the list again when you're building the output using what you learned from the difference.
01:00:44 <Rembane> kahlil29: What [Leary] said. :)
01:03:12 <liste> boxscape: how is that even possible :D
01:03:35 <boxscape> liste: you mean how is it possible to accidentally name a variable if?
01:03:40 <liste> boxscape: yes
01:03:48 <kahlil29> Rembane, [Leary] : Thanks, I'll try to do that! 
01:03:57 <liste> boxscape: oh, that's the first place you use it
01:03:59 <liste> then it makes sense
01:04:11 <boxscape> liste: I have the real input "input.txt" and an altered input "input2.txt", so I was gonna call them ia for input actual and if for input false
01:04:16 <boxscape> right
01:07:45 <Hafydd> I think I've done that once or twice.
01:17:56 <cheater> @tell erisco the locality and zoom ideas are interesting. thank you very much! and yeah, other features are very interesting.
01:17:56 <lambdabot> Consider it noted.
01:25:11 <ertes-w> Guest10000: trustMe is just unsafeCoerce
01:25:22 <ertes-w> Guest10000: in disguise
01:25:42 <ertes-w> if you want the compiler to trust you that two types are equal, unsafeCoerce is exactly that
01:31:28 <Guest10000> ertes-w: it is, but just using `unsafeCoerce` won't work
01:32:00 <mazu_> ertes-w: you need to play some trickery to get GHC to conjure the constraint
01:32:16 <mazu_> (try to replace the body of `trustMe` with `unsafeCoerce x`)
01:33:43 <mazu_> (also, shorter version: <https://pastebin.com/4KM1FEuL>)
01:40:41 <daey> does the block (line 12-18) equal a "deriving" http://lpaste.net/360570 ?
01:40:55 <merijn> daey: Define "equal"
01:41:07 <ertes-w> :t Unsafe.Coerce.unsafeCoerce id :: ((a ~ b) => r) -> r
01:41:08 <lambdabot> error:
01:41:08 <lambdabot>     • Could not deduce: a ~ b
01:41:08 <lambdabot>       from the context: a0 ~ b0
01:41:24 <ertes-w> right
01:41:46 <daey> well is it a deriving? but Num being a more complex case it requires me to redefine the "Num" capabilities?
01:42:06 <merijn> daey: What does "is it a deriving" mean?
01:43:28 <daey> merijn: newtype Natural = Natural Integer deriving (Num)
01:44:09 <merijn> daey: There's still about 4 different ways to interpret what you mean and I don't know which one you're trying to refer to
01:44:54 <daey> ive seen: newtype asdf = asdf Integer deriving (Eq, Show) before
01:45:04 <ertes-w> daey: BTW, the universe really wants your natural numbers to start at 0 =)
01:45:57 <daey> i assume Eq, and Show can be "derived" like that because they dont do all that much. i.e. do not require redefinitions of (+) (-) (*)
01:46:03 <ertes-w> daey: if you derive Num for Natural, then Natural will be pretty much Integer with a different name
01:46:06 <merijn> daey: "deriving" is just syntax to tell GHC "I can't be arsed to write out this typeclass implementation, so just generate the obvious one for me", but you can only derive very limited things
01:46:33 <merijn> daey: You cannot derive Num without extensions and with those extensions it won't do what you, presumably, want
01:47:02 <daey> merijn: ok, so the "instance Num Natural where" block is the "long way" of "derived" then?
01:47:16 <ertes-w> daey: no, deriving means not writing by hand
01:47:27 <daey> yes?
01:47:42 <mniip> ertes-w, you can't unsafecoerce that
01:47:50 <mniip> it's a function
01:48:05 <ertes-w> mniip: i thought i can't unsafeCoerce that, because it's polymorphic
01:48:12 <mniip> that too but
01:48:42 <ertes-w> :t Unsafe.Coerce.unsafeCoerce (succ :: Int -> Int) :: Double -> Double
01:48:43 <lambdabot> Double -> Double
01:48:44 <merijn> daey: I would say you have things reversed "instance Foo Bar where" is the natural default, deriving is the "lazy alternative"
01:49:01 <ertes-w> mniip: you mean it will blow up?
01:49:33 <ertes-w> even though (~) doesn't need dictionaries?
01:50:33 <ertes-w> daey: there are three ways to define instance members:  deriving (completely leaving it up to the compiler), defaulting (leaving it to the type class), implementing
01:50:51 <mniip> ertes-w, if you'd unsafecoerce it would always crash
01:54:34 <ertes-w> mniip: really?  the equality constraint changes the operational behaviour/representation?
01:55:28 <mazu_> mniip: no, it won't
01:55:43 <mazu_> equality constraints have no computation in them
01:55:49 <mazu_> you never need them to run the program
01:56:05 <ertes-w> that's what i would assume, yeah
01:56:55 <mniip> hmm
01:57:18 <mniip> just had hell of a lag spike
01:57:33 <mazu_> i'm on a plane so maybe it's my fault
01:58:08 <osa1> any ekg users here? the API currently doesn't allow serving ekg app in a wai server, I'm wondering if there's a feature of it that prevents doing that kind of thing
01:58:29 <mniip> are you sure equational contexts are completely erased in core?
01:58:46 <mniip> and don't compile to closures that need to be applied to something
01:59:36 <mazu_> mniip: i'm not sure what you mean
01:59:50 <mazu_> what will happen is that you can use the bogus equalities coming from `trustMe` to implement `unsafeCoerce`
02:00:29 <mniip> look, here's my version
02:00:30 <mniip> :t let f :: Proxy a -> Proxy b -> ((a ~ b) => r) -> r; f _ = Unsafe.Coerce.unsafeCoerce ((\_ x -> x) :: Proxy b -> (b ~ b => r) -> r) in f
02:00:31 <lambdabot> forall k (a :: k) (b :: k) r. Proxy a -> Proxy b -> (a ~ b => r) -> r
02:00:47 <mniip> it applies the context appropriately
02:01:10 <mniip> % let foo :: Proxy a -> Proxy b -> ((a ~ b) => r) -> r; f _ = Unsafe.Coerce.unsafeCoerce ((\_ x -> x) :: Proxy b -> (b ~ b => r) -> r)
02:01:15 <yahb> mniip: [Timed out]
02:01:18 <mniip> % 1
02:01:23 <yahb> mniip: 1
02:01:24 <mniip> % let foo :: Proxy a -> Proxy b -> ((a ~ b) => r) -> r; f _ = Unsafe.Coerce.unsafeCoerce ((\_ x -> x) :: Proxy b -> (b ~ b => r) -> r)
02:01:24 <yahb> mniip: ; <interactive>:2:5: error: The type signature for `foo' lacks an accompanying binding
02:01:34 <mniip> % let { foo :: Proxy a -> Proxy b -> ((a ~ b) => r) -> r; f _ = Unsafe.Coerce.unsafeCoerce ((\_ x -> x) :: Proxy b -> (b ~ b => r) -> r) }
02:01:34 <yahb> mniip: ; <interactive>:3:7: error: The type signature for `foo' lacks an accompanying binding
02:01:39 <mniip> oh right
02:01:42 <mniip> % let foo :: Proxy a -> Proxy b -> ((a ~ b) => r) -> r; foo _ = Unsafe.Coerce.unsafeCoerce ((\_ x -> x) :: Proxy b -> (b ~ b => r) -> r)
02:01:42 <yahb> mniip: 
02:02:30 <mazu_> mniip: that's different
02:02:33 <mazu_> you're coercing the function
02:02:35 <mniip> now to find a function whose context doesn't reduce
02:02:38 <mazu_> (just read the first definition, reading the rest)
02:02:59 <mniip> mazu_, yeah but I don't know if ertes-w's definition is going to work
02:03:17 <mazu_> mniip: my definition does work (see latest pastebin)
02:03:49 <mniip> which one
02:04:01 <mazu_> mniip: <https://pastebin.com/4KM1FEuL>
02:04:14 <mniip> ah
02:04:15 <mniip> duh
02:04:20 <mniip> that's pretty much the same as mine
02:04:39 <ertes-w> hmm, it crashed indeed
02:04:51 <ertes-w> f :: (a ~ b) => proxy a -> proxy b -> ((a ~ b) => r) -> r; f _ _ x = x
02:04:58 <ertes-w> myId :: r -> r; myId = unsafeCoerce (f (Proxy :: Proxy ()) (Proxy :: Proxy ()))
02:05:07 <ertes-w> → segfault, if you use myId
02:05:11 <mazu_> mniip: i don't think it is, yours is recursive and is coercing the function rather than the equality proof
02:05:33 <ertes-w> that's weird…  why does the constraint change the run-time representation?
02:05:38 <mazu_> the only think i'm doing is pulling a proof out of thin air, and that is safe because all proofs look exactly the same at runtime -- they all look like unit
02:06:18 <mniip> recursive?
02:06:29 <mniip> mine is coercing a context-function
02:06:50 <mazu_> mniip: sorry, misread, scrap the "is recursive". but, it is coercing the function
02:07:02 <mniip> % type family F a
02:07:02 <yahb> mniip: 
02:07:57 <mniip> % :t let f :: (a ~ F a) => a -> F a; f x = x in foo (Proxy @()) (Proxy @(F ())) f
02:07:57 <yahb> mniip: ; <interactive>:1:76: error:; * Couldn't match expected type `r' with actual type `a0 -> F a0'; `r' is untouchable; inside the constraints: () ~ F (); bound by a type expected by the context:; () ~ F () => r; at <interactive>:1:44-76; `r' is a rigid type variable bound by the inferred type of it :: r at <interactive>:1:1; Possible fix: add a type signature for `it'; * In the third argument of `foo', namely `f'; In the expression: foo (Proxy @()) (Proxy @(F
02:08:16 <mniip> % :t let f :: (a ~ F a) => a -> F a; f x = x in foo (Proxy @()) (Proxy @(F ())) (f ())
02:08:16 <yahb> mniip: ; <interactive>:1:77: error:; * Couldn't match type `r' with `()'; `r' is untouchable; inside the constraints: () ~ F (); bound by a type expected by the context:; () ~ F () => r; at <interactive>:1:44-81; `r' is a rigid type variable bound by the inferred type of it :: r at <interactive>:1:1; Possible fix: add a type signature for `it'; Expected type: r; Actual type: F (); * In the third argument of `foo', namely `(f ())'; In the expression: foo (Proxy @(
02:08:42 <mniip> % :t let f :: (a ~ F a) => a -> F a; f x = x in foo (Proxy @()) (Proxy @(F ())) (f ()) :: F ()
02:08:42 <yahb> mniip: let f :: (a ~ F a) => a -> F a; f x = x in foo (Proxy @()) (Proxy @(F ())) (f ()) :: F () :: F ()
02:09:12 * mazu_ feels dizzy
02:09:39 <mniip> % :t let f :: (a ~ F a) => F a -> a; f x = x in foo (Proxy @()) (Proxy @(F ())) (f ()) :: ()
02:09:40 <yahb> mniip: let f :: (a ~ F a) => F a -> a; f x = x in foo (Proxy @()) (Proxy @(F ())) (f ()) :: () :: ()
02:09:44 <mniip> % let f :: (a ~ F a) => F a -> a; f x = x in foo (Proxy @()) (Proxy @(F ())) (f ()) :: ()
02:09:45 <yahb> mniip: ()
02:10:04 <mniip> % let f :: (a ~ F a) => F a -> a; f x = x in foo (Proxy @String) (Proxy @(F String)) (f "hello") :: String
02:10:04 <yahb> mniip: "hello"
02:10:46 <mniip> hmm
02:10:52 <mniip> one problem though: this is polykinded
02:11:42 <mniip> probably could be used to define a representation-polymorphic id
02:11:48 <mniip> which can be used to crash the runtime
02:12:32 <mazu_> mniip: as ertes-w points out `trustMe` can be used to implement `unsafeCoerce` so you can surely crash the runtime, even without poly kinds. but you can use it for well-behaved programs
02:12:59 <mazu_> my use-case is having having a datatype that looks like a GADTs but internally uses a more compact representation
02:14:17 <mniip> % :t let f :: forall (a :: TYPE k). (k ~ LiftedRep) => a -> a; f x = x in f
02:14:17 <yahb> mniip: ; <interactive>:1:23: error: Not in scope: type constructor or class `TYPE'; <interactive>:1:37: error: Not in scope: type constructor or class `LiftedRep'
02:14:27 <mniip> % import GHC.Types
02:14:27 <yahb> mniip: 
02:14:29 <mniip> % :t let f :: forall (a :: TYPE k). (k ~ LiftedRep) => a -> a; f x = x in f
02:14:29 <yahb> mniip: let f :: forall (a :: TYPE k). (k ~ LiftedRep) => a -> a; f x = x in f :: a -> a
02:14:33 <mniip> dammit
02:14:39 <mniip> context reduction
02:15:42 <mniip> % :t let f :: forall (a :: TYPE k). (k ~ F LiftedRep) => a -> a; f x = x in f
02:15:42 <yahb> mniip: ; <interactive>:1:37: error:; * Expected kind `RuntimeRep', but `F 'LiftedRep' has kind `*'; * In the second argument of `~', namely `F LiftedRep'; In the type signature: f :: forall (a :: TYPE k). (k ~ F LiftedRep) => a -> a; In the expression:; let; f :: forall (a :: TYPE k). (k ~ F LiftedRep) => a -> a; f x = x; in f; <interactive>:1:39: error:; * Expected a type, but 'LiftedRep has kind `RuntimeRep'; * In the first argument of `F', namely `LiftedRep'; 
02:16:11 <mniip> shrug
02:17:29 <ertes-w> mazu_: do you really need type equality?  wouldn't type isomorphism be enough?  i mean, if the representation is different and you want to use A as B, you need to convert anyway
02:17:45 <ertes-w> (A ~ B) is just wrong
02:18:03 <mazu_> ertes-w: then i cannot get the GADT-like interface
02:18:19 <mazu_> let me post a more concrete example
02:18:25 <ertes-w> mazu_: yeah, that would be helpful
02:19:09 <ertes-w> mazu_: note that you can use a scott/church-encoded variant that does work like a GADT, including type refinement, but gives you freedom over the underlying representation
02:19:43 <ertes-w> GADT version: data Some :: * -> * where SomeInt :: Int -> Some Int; SomeDouble :: Double -> Some Double
02:20:56 <ertes-w> scott version:  newtype Some a = Some { fromSome :: forall r. ((a ~ Int) => Int -> r) -> ((a ~ Double) => Double -> r) -> r }
02:21:28 <mazu_> ertes-w: the church encoded version still forces me to have a function there
02:25:47 <ertes-w> mazu_: but that function can index some compact structure
02:26:22 <ertes-w> mazu_: here is a type that can represent arrays of either Int or Double efficiently:
02:26:53 <ertes-w> newtype Array a = Array { indexArray :: forall r. Int -> ((a ~ Int) => Int -> r) -> ((a ~ Double) => Double -> r) -> r }
02:27:07 <ertes-w> it takes an index and a continuation for Int, and one for Double
02:27:09 <mazu_> ertes-w: it can, but the representation is still less direct
02:27:57 <mazu_> for example, if you have two church-encoded naturals, you cannot implement addition using an underlying primop (e.g. word addition) because you have to work with the church encoding
02:28:02 <mniip> that's hell of a continuation
02:28:53 * mazu_ is typing down a self-contained example
02:30:04 <ertes-w> mazu_: alternatively, if your compact representation is sufficiently compact, i think you can still go to a GADT and back
02:30:18 <ertes-w> i mean you have to, anyway
02:30:29 <dminuoso> Is there a nice way to not have this case here? https://gist.github.com/dminuoso/97c33a5c2e2f07af34ef4ce17cf88824
02:31:05 <mazu_> ertes-w: right, but to do so i need `trustMe`
02:31:15 <ertes-w> dminuoso: your code is boolean-blind anyway…  pattern-match on the list
02:31:24 <mazu_> although it's more convenient to just have a custom destructor
02:31:50 <ertes-w> mazu_: why would you need trustMe?
02:31:54 <dminuoso> ertes-w: Err.. okay. So before I look into that I realized I could just use pop = StateT $ \s -> (\x -> (x, tail s)) <$> safeHead s
02:32:19 <dminuoso> I think..
02:33:00 <dminuoso> Ohh I see what you mean heh.
02:33:12 <ertes-w> dminuoso: read this section: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
02:33:17 <ertes-w> it's more or less self-contained
02:34:42 <dminuoso> ertes-w: https://gist.github.com/dminuoso/97c33a5c2e2f07af34ef4ce17cf88824 :)
02:34:44 <dminuoso> Alright, giving it a read.
02:35:22 <ertes-w> s/return/pure/
02:36:00 <ertes-w> … on my quest to get rid of legacy again =)
02:36:30 <dminuoso> ertes-w: What is your reason behind that?
02:36:42 <ertes-w> dminuoso: behind what?
02:36:43 <dminuoso> Just to write code that possibly has less constraints?
02:36:48 <dminuoso> 11:34        ertes-w | s/return/pure/
02:36:50 <ertes-w> yes
02:37:06 <ertes-w> 'return' is just a bad version of 'pure'
02:37:43 <dminuoso> Just like liftM is a bad version of fmap?
02:37:48 <ertes-w> yes
02:38:25 <dminuoso> I see what you are getting at, thanks for those hints. Ill try to keep return out of my code then. :)
02:38:38 <ertes-w> great =)
02:38:56 <dminuoso> ertes-w: I just remembered how you had me derive lenses, how just transforming the type signature had me losen up the restriction from Applicative to Functor. :)
02:39:14 <ertes-w> =)
02:39:21 <ertes-w> we have a few relics of the past that should just die in peace
02:39:52 <[exa]> :]
02:40:14 <ertes-w> some might have a point (liftM and ap can be used to implement fmap and (<*>) resp.)
02:40:42 <ertes-w> but others (forM, forM_, mapM, mapM_, return, …) are completely pointless
02:40:56 <boxscape> but how are you going to do that if Functor and Applicative instances are prerequisites for Monad
02:41:31 <dminuoso> ertes-w: Ive been tempted to use liftM actually a few times (for example i have a combine/combine2/combine3/combine4 the latter of which are defined in terms of liftM2/liftM3/liftM4 - so using liftM gives better symmetry. Are you opposed to such uses as well?
02:41:54 <ertes-w> boxscape: instance Functor M where fmap = liftM; instance Applicative M where { pure = _; (<*>) = ap }; instance Monad M where (>>=) = _
02:42:12 <dminuoso> i.e. the code is: https://gist.github.com/dminuoso/afe34ffd59dba97438d3643979601565
02:42:17 <ertes-w> boxscape: in haskell you can use members from subclasses to implement superclasses
02:42:35 <boxscape> oh, ok. fair enough
02:42:45 <boxscape> I would've expected that code to not compile
02:43:22 <ertes-w> dminuoso: yes, use fmap, liftA2, liftA3, …
02:43:33 <ertes-w> dminuoso: or use raw applicative style
02:43:39 <ertes-w> f1 <$> c1
02:43:47 <ertes-w> f2 <$> c1 <*> c2
02:43:51 <ertes-w> f3 <$> c1 <*> c2 <*> c3
02:43:52 <ertes-w> etc.
02:43:55 <dminuoso> Ah right. Yeah.
02:44:09 <dminuoso> ertes-w: "applicative style" was enough to understood what you meant =)
02:44:13 <dminuoso> I think Im beginning to learn/
02:44:17 <boxscape> in any case, there's no real reason to use liftMx over liftAx, right?
02:44:37 <ertes-w> boxscape: right
02:44:46 <liste> boxscape: not anymore
02:44:47 <mniip> dammit
02:44:48 <mniip> what's with all the disconnections
02:45:11 <mniip> 1512643111 [13:38:31] <mniip> ertes-w, oh this blog post could've been useful for someone who didn't understand a function-foldr the other day
02:45:11 <mniip> 1512643128 [13:38:48] <mniip> whoever was struggling to implement nub with foldr
02:45:12 <mniip> 1512643149 [13:39:09] <mniip> I think it was koz_
02:45:13 <liste> Applicative used to be separate from Monad
02:45:15 <dminuoso> ertes-w: Oh yeah! That gives me precisely what I wanted. Applicative style it is :)
02:45:25 <ertes-w> boxscape: the only cases where more constrained functions make sense is when they're *not* part of a class or at least have defaults, because then you can use them to implement superclasses, like aboe
02:45:27 <ertes-w> above
02:45:28 <mazu_> ertes-w, mniip: ok, here is a not-so-contrived example where the tricks above can be useful: <https://pastebin.com/716UApse>
02:45:47 <boxscape> right, ok
02:45:57 <dminuoso> https://gist.github.com/dminuoso/58769fb0760f2af81c4f60960bd06b75 :)
02:46:01 <ertes-w> mniip: yeah, i saw that, but at the time i didn't think my article would have helped
02:46:22 <ertes-w> because doing it in terms of foldr wasn't the actual concern =)
02:46:42 <mazu_> ertes-w: you couldn't implement `flatDeltaAdd` using `+` if you used church-encoding
02:49:23 <ertes-w> mazu: i'm sure there are ways to do it, but i'll just have to believe you right now =)
02:50:27 <dminuoso> Cale: By the way, so I thought it would be nice see in practice how Applicative and Monads differ.. so I just took some simple kleisli arrows that did a simple if/else to return different monads.. and that seems to be exactly what Applicatives don't do. :)
02:50:34 <ertes-w> mazu: the idea is that you don't have to establish a 1-to-1 correspondence between the GADT and the church version…  the church version can support an API more suitable to algorithms
02:50:51 <dminuoso> Cale: Based on what you said. So yeah, Im beginning to get a feeling of how much more powerful monads are.
02:51:19 <ertes-w> dminuoso: try to implement this using Applicative:  getLine >>= putStrLn
02:51:36 <ertes-w> an action that reads a line and echos it back
02:51:52 <mazu> ertes-w: yes but you'd have to prescribe all possible operations on your thing from the beginning, which would be quite a pain both in terms of ergonomics and in terms of performance
02:52:14 <mazu> if i define it as a word i _know_ it's a word, on the other hand it's impossible to control how big a closure is
02:52:15 <ertes-w> mazu: nah, you can just use type classes
02:52:30 <ertes-w> mazu: but you could also just expose the Word directly
02:52:33 <mazu> ertes-w: that's just another way of threading some dictionaries around
02:52:42 <ertes-w> mazu: the church version doesn't have to be isomorphic
02:52:46 <dminuoso> ertes-w: Heh turns out that I just tried *exactly* that.. just on the code I showed you.
02:52:51 <dminuoso> Tried to get rid of that >>= :-)
02:52:54 <dminuoso> And realized I couldn't.
02:53:30 <mazu> ertes-w: i don't think you'd gain any safety if you did
02:53:31 <ertes-w> dminuoso: the problem is that putStrLn is a function that returns an IO action, but its argument has to come from another IO action
02:54:15 <ertes-w> mazu: the way i understand it you have a nice representation that you expose and an efficient representation that you keep opaque
02:54:30 <dminuoso> ertes-w: Yeah. It seems like the crucial part is that applicatives simply can't work with "the previous result". You can run effects while applying functions, but not much else
02:54:50 <mazu> ertes-w: i get the idea, but i'm not sure it'd work with the same performance guarantees
02:55:05 <mazu> (e.g. the certainty that any `FlatDelta` would be just a lifted `Word64`)
02:55:11 <mazu> (or unlifted even)
02:55:19 <ertes-w> dminuoso: yeah, or in other words: the structure of the action can't depend on "points" ("action results")
02:56:03 <dminuoso> ertes-w: By points, do you mean in the same sense of "point-free" code (i.e. function arguments) ?
02:56:50 <dminuoso> ertes-w: Mysteriously this is exactly what the type signature says.. you can create a new effect/computation based on the result of a previous effect/computation.
02:56:51 <ertes-w> dminuoso: no, i'm just trying to use an abstract term for what in IO you would call "results"
02:56:54 <dminuoso> (of >>=)
02:57:04 <ertes-w> dminuoso: [1,2,3]  -- the "points" are 1, 2, 3
02:57:08 <dminuoso> Ah
02:57:19 <ertes-w> dminuoso: getLine  -- the "point" is the resulting string
02:57:34 <dminuoso> Ahh alright.
02:58:15 <dminuoso> ertes-w: So yeah.. the type signature of <*> and >>= says it all basically.
02:58:22 <ertes-w> yep
02:58:23 <dminuoso> It's very self-descriptive.
02:58:38 <ertes-w> dminuoso: now you could also get a feeling for what comonads are about =)
02:59:17 <ertes-w> (>>=) :: (Monad f) =>   (a -> f b) -> f a -> f b
02:59:20 <ertes-w> err
02:59:26 <ertes-w> (=<<) :: (Monad f) =>   (a -> f b) -> f a -> f b
02:59:35 <ertes-w> (<<=) :: (Comonad f) => (f a -> b) -> f a -> f b
02:59:39 <fakenullie> What
03:00:14 <dminuoso> ertes-w: Well now I see why it's called a "Co"monad at least. Let me see what intuition I can derive from the signature.
03:00:54 <ertes-w> dminuoso: if you look at lists, the list monad allows you to create "neighbourhoods" from a function that looks at a single point and returns a neighbourhood
03:01:10 <ertes-w> > [10,20,30] >>= \x -> [x - 1, x + 1]
03:01:12 <lambdabot>  [9,11,19,21,29,31]
03:01:34 <ertes-w> you get the neighbourhoods [9, 11], [19, 21], [29, 31] slammed together
03:03:27 <ertes-w> a monad, given a function that looks at a "point" and returns a "neighbourhood", constructs a new "image" as a composition of those mapped neighbourhoods
03:03:55 <ski> dminuoso : did you see <http://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html> already ?
03:04:03 <ertes-w> a comonad, given a function that lokos at a "neighbourhood" and returns a "point", constructs a new "image" from those points
03:04:14 <ertes-w> *looks
03:04:54 <ski> (one might say that idioms (applicative functors) express "static sequencing", while monads express "dynamic sequencing")
03:05:36 <ertes-w> dminuoso: as a concrete example:  pictures with a current position form a comonad, and then 'extend' (a.k.a. (<<=)) can basically turn a single-point filter into a full picture filter
03:06:17 <ertes-w> blurPoint :: Picture Colour -> Colour  -- looks at the neighbourhood at the current position and returns a new color for that position
03:06:18 <dminuoso> ski: Ah that is nicely phrased, and seems to capture my failures to implement "dynamic sequencing" (i.e. chosing an effect based on the previous result) well.
03:06:45 <ertes-w> blurPicture = extend blurPoint :: Picture Colour -> Picture Colour  -- blurs an entire picture
03:06:57 <dminuoso> ertes-w: Ohh.. ohh...
03:08:09 <LiaoTao> ertes-w: Whoa
03:08:23 <LiaoTao> Suddenly understood comonads
03:08:32 <LiaoTao> Thanks!
03:08:40 <ertes-w> my pleasure =)
03:09:29 <ski> "Alternatively stated, a monad lets you chose future dependencies based on the results of previous dependencies."
03:09:49 <ertes-w> dminuoso, LiaoTao: data Picture a = Picture (V2 Int -> a) (V2 Int)  -- a picture and a current position
03:10:05 <ertes-w> but of course:  data Store s a = Store (s -> a) s
03:10:14 <ertes-w> so: Picture ≃ Store (V2 Int)
03:10:17 <dminuoso> ertes-w: So for example if the comonad was a tree, the "neighborhood" for a given point could be a subtree?
03:10:39 <ski> yes
03:12:39 <olligobber> so I have a function a -> IO b and some [a], I want to apply that function to everything and don't care about return values
03:13:16 <humanoyd> ertes-w: is every zipper a comonad?
03:15:20 <LiaoTao> ^
03:15:25 <LiaoTao> Also thought of that
03:17:44 <hydraz> :t mapM_
03:17:45 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
03:17:49 <hydraz> olligobber: ^
03:18:27 <olligobber> apparently traverse works... thanks exferenceBot 
03:18:55 <olligobber> mapM_ is probably more efficient
03:18:57 <olligobber> hydraz++
03:19:36 <dminuoso> ertes-w: so `a` would be some information about the point right? So this could be something like hue or color or any pixel information right?
03:19:52 * hackage errors-ext 0.4 - `bracket`-like functions for `ExceptT` over `IO` monad.  https://hackage.haskell.org/package/errors-ext-0.4 (warlock)
03:20:40 <dminuoso> ertes-w: It's slowly coming together. I remember Ed mentionin comonads frequently in his lens talk, and just `(V2 Int -> a)` kind of reminded me about lenses in that it represents a kind of accessor.
03:21:53 <hydraz> olligobber: they're the same thing nowadays, I just can never remember traverse
03:22:16 <olligobber> hydraz, traverse actually returns the values, I assume that would take longer
03:22:26 <olligobber> though the compiler probably optimises for that
03:22:31 <hydraz> there's a traverse_ in in Data.Foldable
03:22:34 <olligobber> mapM_ is slightly shorter than traverse
03:22:43 <olligobber> in character length
03:22:52 <olligobber> this line of code is still >80 chars :(
03:24:43 <olligobber> got rid of a let ... in block, now it's shorter than 80 chars again
03:24:54 <olligobber> turns out I wasn't using the thing in the let anyway
03:26:00 <LiaoTao> olligobber: What are you doing anyway, if one may ask?
03:26:48 <olligobber> LiaoTao, implementing this protocol in haskell, as a learning exercise on networking and threading: https://github.com/mokuki082/LANChat
03:27:24 <olligobber> I had a function that sent something to peers and needed to apply it to all peers in a list
03:28:53 * hackage errors-ext 0.4.1 - `bracket`-like functions for `ExceptT` over `IO` monad.  https://hackage.haskell.org/package/errors-ext-0.4.1 (warlock)
03:29:17 <LiaoTao> olligobber: Okay, so why the character limit?
03:29:31 <dminuoso> ertes-w: Interesting, so depending on what kind of comonad you pick, you could have different notions of "neighborhood" or "context".
03:29:43 <olligobber> LiaoTao, I limit myself to 80 characters per line so my code stays concise and readable
03:29:54 <LiaoTao> Aha, I thought you meant the entire thing
03:30:27 <olligobber> I'm at 180 lines and have only written enough to handle incoming messages, 80 characters total would be impossible
03:30:47 <LiaoTao> That sounds like a challenge to postdoc Haskellers out there
03:32:04 <dminuoso> olligobber: When I was last asked to stick within 80 characters, I asked my friend to give me his VT100 and buy a 24" screen. Or two.
03:34:19 <sbrg> olligobber: hard limits like that are hardly beneficial to readability IMO. I, too, try to refrain from overly long lines and too much staircasing, but that's my guideline, not a hard limit of 80 characters.
03:35:58 <olligobber> sbrg, I often go over 80 characters, but for editors with vertical panes or code readability on websites like github or pastebin, 80 characters seems good
03:37:44 <quchen> 80 characters are fine, after that think exponentially harder about each 20 additional characters.
03:40:56 <kahlil29> how to convert a "DecimalRaw Integer" (from Data.Decimal) to an Int? 
03:43:04 <AndreasK> kahlil29: fromIntegral . toInteger should work
03:44:13 <liste> kahlil29: truncate, round, ceiling, floor
03:44:37 <liste> > truncate (50.50 :: Decimal)
03:44:39 <lambdabot>  error:
03:44:39 <lambdabot>      Not in scope: type constructor or class ‘Decimal’
03:44:54 * hackage log-warper 1.7.3 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.7.3 (shersh)
03:46:07 <kahlil29> liste : it's a DecimalRaw Integer . truncate doesn't seem to be working 
03:46:11 <dminuoso> So I just used something `type M = Maybe` without even thinking twice, which in retrospect should have begged the question why this does not produce a type error about incorrect kinds.
03:46:27 <liste> hackage: DecimalRaw Integer ~ Decimal
03:46:37 <quchen> dminuoso: Why would it?
03:46:45 <quchen> dminuoso: Type synonyms can be of any kind
03:46:50 <olligobber> :exf Data.Decimal.DecimalRaw -> Int
03:46:56 <quchen> ?let type M = Maybe
03:46:57 <lambdabot>  Defined.
03:47:15 <exferenceBot> could not find expression
03:47:16 <quchen> :t fromMaybe :: a -> M a -> a
03:47:17 <lambdabot> a -> M a -> a
03:47:36 <olligobber> > fromMaybe 1 Nothing
03:47:38 <lambdabot>  1
03:47:45 <olligobber> > fromMaybe 1 (Just 2)
03:47:47 <lambdabot>  2
03:47:55 <olligobber> as expected
03:48:27 <quchen> ?undef
03:48:27 <lambdabot> Undefined.
03:48:44 <quchen> ?let type A = Applicative
03:48:45 <lambdabot>  Defined.
03:49:03 <quchen> :t pure :: A f => b -> f b
03:49:04 <lambdabot> Applicative f => b -> f b
03:50:00 <olligobber> that's different...
03:50:06 <ertes-w> dminuoso: yeah
03:50:20 <ertes-w> dminuoso: consider that (V2 Int -> a) is an abstraction of 2D arrays
03:50:32 <ertes-w> dminuoso: but of course pictures don't have to look like arrays
03:51:07 <olligobber> oh, Applicative is a constraint
03:51:53 <ertes-w> dminuoso: interpolate :: (Comonad w, Integral p, Fractional a) => StoreT (V2 p) w a -> StoreT (V2 Double) w a
03:52:19 <dminuoso> ertes-w: Right. At least in 3d graphics I have some experience with octrees, so Im a bit used to having such information stored in other ways.
03:52:34 <ertes-w> dminuoso: this function could do some interpolation to turn a discrete image into a "continuous" (as far as you can call Double a continuum) one
03:53:27 <ertes-w> dminuoso: rasterise :: … => StoreT (V2 p) w a -> StoreT (V2 Int) w a
03:54:01 <ertes-w> and then you could write some function that servers as a realisation boundary (i.e. turning pictures into actual arrays)
03:54:41 <ertes-w> realise :: (Vu.Unbox a) => V2 Int -> StoreT (V2 Int) w a -> StoreT (V2 Int) w a
03:55:04 <ertes-w> etc.
03:55:38 <dminuoso> ertes-w: Okay, on an abstract level comonads dont seem that complicated, albeit there do seem to be fewer use cases just thinking about what one can do with them.
03:55:39 <ertes-w> you could even abstract the dimensionality away, because in most cases you don't need V2 specifically, but just a traversable applicative functor
03:55:54 <ertes-w> yeah, the use cases are limited
03:57:26 <dminuoso> ertes-w: Would I be correct in assuming that Cokleisli Arrows also form a category, notably the opposite of the Kleisli category?
03:57:49 <ertes-w> is there such a thing?
03:57:58 <ertes-w> as cokleisli *arrows*?
03:58:07 <ggVGc> wow
03:58:12 <ggVGc> everytime I look into #haskell
03:58:16 <ggVGc> there's some weird shit going on
03:58:37 <ggVGc> one day I will understand half the terms thrown around
03:59:01 <merijn> ggVGc: coX is just math speak for "opposite world X"
03:59:17 <merijn> So comonads are just "opposite world monads" :)
03:59:23 <linduxed> well...
03:59:32 <linduxed> "you could even abstract the dimensionality away, because in most cases you don't need V2 specifically, but just a traversable applicative functor"
03:59:34 <dminuoso> ertes-w: Im sure there should be, I'd consider w a -> b a cokleisli arrow.. whatever that may be!
03:59:49 <olligobber> :exf NominalDiffTime -> Int
04:00:12 <ertes-w> "co-" is really nothing complicated…  it's just the rabbit hole in the opposite forest
04:00:13 <exferenceBot> could not find expression
04:00:16 <dminuoso> ertes-w: Ed's Comonad does have that. :)
04:00:32 <dminuoso> ertes-w: https://hackage.haskell.org/package/comonad-5.0.2/docs/src/Control-Comonad.html#Cokleisli
04:00:49 <dminuoso> And apparently they form a category too.
04:00:56 <ertes-w> indeed
04:01:10 <olligobber> fromEnum seems to be what I want...
04:01:32 <ertes-w> dminuoso: well, if it's an Arrow, it's also a Category =)
04:01:46 <ertes-w> class (Category arr) => Arrow arr
04:01:56 <dminuoso> ertes-w: CT wise, why does that necessary hold true?
04:02:13 <ertes-w> dminuoso: because arrows are stronger than categories
04:02:27 <ertes-w> much like groups are stronger than monoids
04:02:35 <olligobber> fromEnum seems to give me the value in picoseconds...great...
04:08:05 <[exa]> from theoretical point of view, is there any reason why Applicative must have 'pure'? AFAIK it's not directly needed to apply wrapped functions, so maybe (in an autistic world) the concept should be named differently
04:09:19 <olligobber> > (pure 2) 3
04:09:20 <lambdabot>  2
04:09:35 <dminuoso> [exa]: Does this not follow from the unitality requirement of a lax monoidal functor?
04:09:44 <ertes-w> [exa]: Applicative lets you combine arbitrarily many f-actions
04:09:58 <ertes-w> [exa]: without 'pure' you would need at least one
04:10:10 <ertes-w> pure :: a -> F a
04:10:19 <ertes-w> fmap :: (a -> b) -> F a -> F b
04:10:27 <ertes-w> liftA2 :: (a -> b -> c) -> F a -> F b -> F c
04:10:27 <ertes-w> etc.
04:11:11 <ertes-w> [exa]: there is a variant of Applicative without 'pure' in the semigroupoids library called Apply
04:11:43 <liste> [exa]: there used to be Pointed class, with pointed :: a -> F a
04:11:46 <liste> [exa]: but https://wiki.haskell.org/Why_not_Pointed%3F
04:12:01 <ski> [exa] : it's needed for the base case of `sequenceA' and `traverse' (on lists)
04:12:45 <[exa]> ertes-w: thanks the hierarchy is a good illustration
04:12:52 <ertes-w> [exa]: Apply relates to Applicative very much like Semigroup relates to Monoid
04:12:54 <[exa]> ski: yes, practical reason, thanks :]
04:13:07 <ertes-w> [exa]: sconcat needs non-empty lists to work, mconcat can deal with empty lists
04:13:57 <[exa]> ok, so it's a zero. Thanks everyone :D
04:14:01 <ski> [exa] : this is similar to moniods (and groups) having neutral elements. that way you can combine any (finite) list of elements, not just non-empty ones
04:14:25 <ertes-w> a family of zeroes, yeah =)
04:15:05 <[exa]> anyway
04:15:06 * ski . o O ( with a group, can you combine a negative-length list of elements ? )
04:15:50 <ertes-w> gconcat :: (Group a) => [(a, Integer)] -> a
04:16:44 <ertes-w> gconcat [(x1, 3), (x2, -2)] = x1 <> x1 <> x1 <> inverse (x2 <> x2)
04:17:50 <[exa]> about the (pure 2) 3  example... I guess that (pure 2) types as a function functor (which explains why it returns 2)
04:18:02 <[exa]> how does ghci print out 2 from just (pure 2) ?
04:18:26 <ertes-w> [exa]: it probably defaults to IO
04:18:29 <Taneb> ertes-w: hmm, I could add that to Data.Group (which is on Hackage in groups but because I never got round to it not on Github)
04:18:39 <Taneb> ski also
04:18:55 <ertes-w> Taneb: how did you define Group?
04:19:50 * ski . o O ( <https://en.wikipedia.org/wiki/Monoid_ring> )
04:20:04 <[exa]> ertes-w: yeat that would be reasonable, it needs to show it, which can result in multiple applicatives being selected...
04:20:13 <[exa]> I didn't know there'd be defaulting on that level. :D
04:21:47 <[exa]> > pure 2
04:21:49 <lambdabot>  error:
04:21:49 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M849623568113...
04:21:49 <lambdabot>        prevents the constraint ‘(Show (f0 Integer))’ from being solved.
04:22:01 <[exa]> ok this works in ghci. ghci is magic.
04:22:32 <ertes-w> [exa]: GHCi does some extra defaulting to facilitate convenience and confusion =)
04:23:48 <Psybur> > pure 2 :: Monad Int
04:23:51 <lambdabot>  error:
04:23:51 <lambdabot>      • Expected a type, but ‘Monad Int’ has kind ‘Constraint’
04:23:51 <lambdabot>      • In an expression type signature: Monad Int
04:23:53 <Psybur> LD
04:23:58 <Psybur> *:D
04:24:55 <[exa]> it seems like IO gets smuggled there in case of emergency, but I can't get the type information out of that :] (pure 2) :: _ fails ofc
04:25:03 <[exa]> interesting.
04:25:20 <Psybur> pure 2 :: IO Int
04:25:29 <Psybur> > pure 2 :: IO Int
04:25:32 <lambdabot>  <IO Int>
04:25:53 <[exa]> ghci shows '2'
04:25:59 <[exa]> solved, thanks. :]
04:26:03 <ertes-w> that's almost certainly IO
04:26:36 <fakenullie> > pure 2 :: Monad m -> m Int
04:26:38 <lambdabot>  error:
04:26:38 <lambdabot>      • Expected a type, but ‘Monad m’ has kind ‘Constraint’
04:26:38 <lambdabot>      • In an expression type signature: Monad m -> m Int
04:26:49 <fakenullie> > pure 2 :: Monad m => m Int
04:26:51 <lambdabot>  error:
04:26:51 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M247800838689...
04:26:51 <lambdabot>        prevents the constraint ‘(Show (m0 Int))’ from being solved.
04:27:12 <ertes-w> Taneb: ah, i just saw…  unfortunately i can't use your groups package
04:27:32 <[exa]> fakenullie: it seems that the IO fallback is done after actual defaulting
04:27:47 <[exa]> so it never gets to actual type inference
04:27:50 <Psybur> pure 2 :: (Num a, Applicative f) => f a
04:28:37 <ertes-w> Taneb: i need this:  class (Monoid a) => Inverses a where inverseMaybe :: a -> Maybe a; class (Semigroup a) => Commutative a; class (Inverses a) => Group a where inverse :: a -> a
04:28:51 <ertes-w> Taneb: your classes are too textbook =)
04:29:26 <[exa]> anyway, is there some standard place where (&) is defined?
04:29:42 <fakenullie> @hoogle (&)
04:29:42 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
04:29:43 <lambdabot> Control.Lens.Lens (&) :: () => a -> (a -> b) -> b
04:29:43 <lambdabot> Control.Lens.Operators (&) :: () => a -> (a -> b) -> b
04:29:51 <[exa]> oh thanks :]
04:30:22 * ski idly wonders why those have empty constraints
04:30:42 <ertes-w> side effect of RankNTypes probably
04:31:02 <fraise> wotcher! writing a function that returns Just a value in some case patterns, and Nothing in any other case pattern, feels very verbose with the amount of 'Just' needed... is there a way to avoid that redundancy?
04:31:16 <ski> fraise : show the code ?
04:31:21 <[exa]> anyway, why doesn't the web version of hoogle return this?
04:31:30 <fakenullie> it should
04:31:41 <ski> @paste
04:31:41 <lambdabot> Haskell pastebin: http://lpaste.net/
04:31:46 <ski> fraise ^
04:31:59 <fakenullie> but it doen't :-\
04:32:15 <[exa]> :(
04:32:44 <fraise> ski: http://lpaste.net/360579
04:32:56 <fakenullie> [exa]: alpha version does
04:33:05 <fakenullie> http://hoogle.haskell.org/?hoogle=%26
04:33:23 * hackage servant-aeson-specs 0.5.3.0 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.5.3.0 (mchaver)
04:33:27 <ertes-w> fraise: how would you imagine that being shorter?
04:33:37 <[exa]> fakenullie: oh great
04:33:38 <ski> fraise : in that code, not really. in other code which calls that .. possibly
04:33:49 <fraise> ski: what do you mean?
04:34:21 <ertes-w> fraise: Maybe has a lot of interfaces, so that you rarely need to pattern-match
04:34:21 <ski> just answering "is there a way to avoid that redundancy?"
04:34:40 <fraise> ertes-w: i'd imagine either a hack... or catching a "non exhaustive pattern" error with unsafePerformIO :P
04:34:44 <fraise> ertes-w: interfaces?
04:34:58 <ski> fraise : for a lot of use-patterns of `Maybe', there are helper functions that help avoid various kinds of boilerplate
04:35:03 <fakenullie> you can use associative array
04:35:19 <ertes-w> fraise: of course usually at some point the Maybe has to vanish, but before that you can probably just use things like (>>=) and (<|>) with Maybe
04:35:35 <fraise> ertes-w: oh you mean using maybe (the function) instead of case of?
04:35:39 <fraise> and so on
04:35:47 <ski> > sequence [Just 2,Just 3,Just 5,Just 7]
04:35:49 <lambdabot>  Just [2,3,5,7]
04:35:52 <ski> > sequence [Just 2,Just 3,Nothing,Just 7]
04:35:53 <lambdabot>  Nothing
04:36:03 <ertes-w> fraise: that's just pattern-matching in disguise…  i mean something like…
04:36:07 <ski> e.g. can be used to check whether every list element is of the `Just' form
04:37:04 <fraise> ski: i don't really need that... i'm more like parsing and have to return nothing if the character in input isn't part of the expected symbols
04:37:19 <fakenullie> > lookup 'a' [('a', 1)]
04:37:21 <lambdabot>  Just 1
04:37:30 <ertes-w> @let isqrt x = foldr (\(s, r) xs -> case compare s x of EQ -> Just r; GT -> Nothing; LT -> xs) Nothing . iterate (\(s, r) -> (s + 2*r + 1, r + 1)) $ (0, 0)
04:37:31 <lambdabot>  Defined.
04:37:41 <fraise> fakenullie: hm... not bad actually
04:37:42 <ertes-w> > map isqrt [0..6]
04:37:44 <lambdabot>  [Just 0,Just 1,Nothing,Nothing,Just 2,Nothing,Nothing]
04:37:45 <fraise> :t lookup
04:37:46 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
04:38:02 <ertes-w> fraise: isqrt is the exact integer square root
04:38:10 <ertes-w> then (isqrt >=> isqrt) is the exact integer fourth root
04:38:19 <ertes-w> > (isqrt >=> isqrt) 16
04:38:21 <lambdabot>  Just 2
04:38:37 <ertes-w> (>=>) :: (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
04:38:53 <fraise> ertes-w: it's very cool but i'm not sure i follow the connection
04:38:59 <ertes-w> fraise: and Maybe also happens to be a monad
04:39:08 <Psybur> > asum [Nothing, Just 1, Just 2, Nothing]
04:39:10 <lambdabot>  Just 1
04:39:13 <ertes-w> > do x <- isqrt 16; y <- isqrt 25; pure (x + y)
04:39:15 <lambdabot>  Just 9
04:39:20 <ertes-w> > do x <- isqrt 16; y <- isqrt 24; pure (x + y)
04:39:22 <lambdabot>  Nothing
04:39:31 <ertes-w> 24 doesn't have an exact integer square root
04:39:35 <ski> `asum' can be used when you want to get the first `Just' in a list
04:39:44 <ertes-w> so the whole thing evaluates to Nothing
04:40:16 <fraise> ertes-w: i'm well aware :) but when i have to write a kleisli arrow for Maybe, i end up Justifying a lot. that's both distracting and it feels redundant... it'd be cool if there was a way to wrap the result of a case and return Nothing if the case fails...
04:40:34 <Psybur> > asum [Right 1, Left 1, Left 2, Right 3]
04:40:36 <lambdabot>  error:
04:40:36 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M879808887457...
04:40:36 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
04:40:38 <ski> fraise : both the "check all are `Just's" interpretation and the "get the first `Just'" interpretation are useful, when parsing
04:40:52 <ertes-w> fraise: choice and failure are captured by Applicative and Alternative
04:41:21 <fraise> ski: true, but so far i have only two parsers :)
04:43:09 <fraise> ertes-w: i don't see the connection with having to manually wrap stuff with Just at every case ...
04:44:22 <merijn> fraise: What does "if the case fails" mean?
04:45:09 <fraise> merijn: i have n patterns, and if the input doesn't match any of it, i want to return Nothing.
04:45:29 <merijn> fraise: So just add a wildcard case?
04:45:43 <merijn> "_ -> Nothing" and done?
04:45:52 <fraise> merijn: yes that's not the issue: the issue is n times wrapping stuff with Just
04:46:42 <fraise> merijn: if there were a way to say "this function return Nothing when none of its patterns are matched, otherwise just wrap the result in a Just"...
04:47:39 <fraise> i'm aware it's probably impossible wrt haskell's syntax rules, but in some way it feels missing: that abstraction is impossible to extract, and it's a bit sad...
04:47:59 <ski> (*sigh*, why is the `Alternative' and `MonadPlus' instances of `Either' in lambdabot provided by `Control.Monad.Error', rather than `Data.Either' (which provides `Functor',`Applicative',`Monad') or maybe `Control.Monad.Except' ?)
04:49:26 <ertes-w> fraise: as we said, there is not much potential for simplifying the pattern-match you showed us
04:49:43 <ertes-w> there is some, but not much
04:49:46 <Psybur> ski, Data.Either doesnt have Alternative or MonadPlus instances does it?
04:49:57 <fraise> ertes-w: what's the "some"?
04:49:57 <Average-user> glguy: are you here?
04:50:37 <ski> Psybur : right. i'm lamenting that it doesn't
04:50:39 <ertes-w> fraise: f x = case x of …
04:50:58 <ertes-w> fraise: the only difference here is that you don't have to spell out 'f' for every case
04:51:00 <fakenullie> maybe if you have too many pattern matches, it is time to refactor
04:51:42 <fraise> ertes-w: oh right
04:51:49 <fraise> fakenullie: possibly...
04:52:42 <ertes-w> fraise: if you can factor the argument in such a way that you have a closed group of patterns that all return Just…
04:54:20 <fraise> ertes-w: you mean... filter the argument first, and choose whether to return Just or Nothing, then actually parse the argument to return in Just?
04:54:42 <fraise> feels like duplicating the tests... though it's not very important
04:54:51 <ertes-w> fraise: no duplicates
04:55:23 * hackage chatwork 0.1.2.0, rakuten 0.1.0.4 (matsubara0507): https://qbin.io/e3g877t
04:55:34 <ertes-w> fraise: the general pattern of what i mean is:  f x = g <$> p x
04:55:56 <ertes-w> fraise: where 'p' factors out everything that could fail, so g can return unwrapped results
04:56:19 <ertes-w> (<$>) :: (a -> b) -> Maybe a -> Maybe b
04:56:59 <fraise> ertes-w: yes that's what i thought. as i said, if say p tests that x has the right pattern to be Just itself, then i'll have to match x in g once more and with the same pattern...
04:57:15 <ertes-w> fraise: conceptually you have a type X that you're currently pattern-matching on directly, but X is too expressive…  it includes failure cases
04:57:28 <ertes-w> fraise: the idea is that you factor out those failures:  p :: X -> Maybe Y
04:57:31 <fraise> and i'm not entirely sure how to write p and avoid having just as many Just...
04:57:59 <ertes-w> where supposedly 'p' is a rather small function that just handles the failures and returns information of a reduced type Y that has no more failure cases
04:58:05 <ertes-w> g :: Y -> Z
04:58:11 <ertes-w> f :: X -> Maybe Z
04:58:56 <fraise> ertes-w: oh you mean when i can directly match the failures? but that's impossible here: the failure cases are defined just by not being success cases... writing them all would be even more heavy
04:59:23 <ertes-w> fraise: then i'm afraid you'll be Just-wrapping
04:59:25 <fraise> but i agree, if there are less failure cases, it's better to first check that out, and return Just (g x) in any other case
05:00:45 <ertes-w> you can use 'pure' and 'empty' (the latter from Control.Applicative) instead of Just and Nothing, if you want slightly quieter code
05:00:53 <fraise> i guess lookup can be a good solution, considering so far my patterns are "raw values"
05:01:33 <fraise> ertes-w: hm... but since it's not polymorphic code, it risks making things unnecessarily confusing... but true
05:02:00 <ertes-w> fraise: there is one downside to lookups:  pattern-matches against constructors and primitive types is O(1) in general, so if you want to pattern-match, be sure to use an efficient data structure like Map
05:02:03 <ertes-w> ess
05:02:04 <ertes-w> err
05:02:05 <fraise> at this stage i might as well use a local alias ^^
05:02:10 <ertes-w> s/pattern-match/lookup/
05:03:36 <fraise> ertes-w: that's truly better?
05:04:17 <fraise> ertes-w: ok good idea :)
05:04:37 <ertes-w> fraise: Map is still slower than flat pattern-matching
05:04:42 <ertes-w> well, not necessarily
05:04:59 <ertes-w> it may be faster for primitive types like Int or Char
05:05:14 <ertes-w> (or IntMap if applicable)
05:05:22 <fraise> ertes-w: hm well i'll test the overall visual result of either solution...
05:05:22 * hackage weeder 0.1.9 - Detect dead code  https://hackage.haskell.org/package/weeder-0.1.9 (NeilMitchell)
05:05:28 <ertes-w> also you should define the actual map on the top level
05:05:55 <fraise> btw couldn't i manage what i'm imagining with some metaprogramming stuff?
05:06:16 <Psybur> So with Except the Left is the exception and Right is the value?
05:06:20 <ertes-w> yes, but you wanted to *improve* your code =)
05:06:32 <ski> Psybur : yes
05:06:41 <fraise> ertes-w: if i define it inside the parser, it'd not be the same? sth like foo c = lookup c (fromList ...)
05:06:45 <ertes-w> Psybur: yeah, if everything went Right =)
05:07:05 <fraise> ertes-w: well, the overall readability :P
05:07:08 <ertes-w> fraise: that would almost certainly rebuild the map for every single application
05:07:21 <ertes-w> so you'd be worse than O(n)
05:07:35 <Psybur> So if I have a stateful computation that can throw an exception I have to do runExceptT $ runStateT ... ?
05:07:44 * ski . o O ( `data Vel e a = Sinister e | Dexter a' )
05:07:48 <fraise> ertes-w: seriously? that's weird, if everything is "statically" defined inside... same if it were in a where?
05:08:02 <fraise> *where clause
05:08:02 <Psybur> > runExceptT $ runStateT (state (\s -> (2*s,s))) 1
05:08:04 <lambdabot>  error:
05:08:04 <lambdabot>      • Ambiguous type variables ‘m0’, ‘e0’ arising from a use of ‘show_M65389...
05:08:04 <lambdabot>        prevents the constraint ‘(Show
05:08:14 <Psybur> > runExcept $ runState (state (\s -> (2*s,s))) 1
05:08:16 <lambdabot>  error:
05:08:16 <lambdabot>      • Couldn't match type ‘(Integer, Integer)’
05:08:16 <lambdabot>                       with ‘ExceptT e Identity a’
05:08:18 <ertes-w> fraise: GHC uses sharing and so-called constant applicative forms (CAFs), but only for things that have a name
05:08:21 <ski> @unmtl StateT s (ErrorT e m) a
05:08:21 <lambdabot> s -> m (Either e (a, s))
05:08:22 <ski> @unmtl ErrorT e (StateT s m) a
05:08:22 <lambdabot> s -> m (Either e a, s)
05:08:35 <fraise> ertes-w: so if i name it in a let/where, i'm potentially good?
05:08:50 <Psybur> > runExceptT $ runState (state (\s -> (2*s,s))) 1
05:08:52 <ertes-w> fraise: f x = x^2 + x^2  -- if CSE doesn't happen here, then this will actually square twice
05:08:53 <lambdabot>  error:
05:08:53 <lambdabot>      • Couldn't match expected type ‘ExceptT e m a’
05:08:53 <lambdabot>                    with actual type ‘(Integer, Integer)’
05:09:03 <fraise> ertes-w: though obviously at this rate might as well define it at top level
05:09:05 <ertes-w> fraise: f x = let y = x^2 in y + y  -- this will definitely square once
05:09:44 <Psybur> What black magic is ghci doing D;
05:09:54 <ertes-w> this is called sharing…  y has a name, so if anything computes it, it will keep its value computed, until it's GCed
05:10:11 <fraise> ertes-w: sure but here it's more a question of say having foo ix = [1,2,3] !! ix, and clearly [1,2,3] is a thoroughly independent, statically defined value that will never change
05:10:24 <ertes-w> fraise: but there is one more detail…  exactly that
05:10:42 <fraise> eh?
05:11:09 <michalrus> Hey, how can I splice declaration names in TemplateHaskell?
05:11:37 <fraise> ertes-w: i didn't get your last message...
05:12:23 <ertes-w> fraise: f x = n*x  where n = 3^5000  -- this would be shared, but there is only one user…  every application of 'f' will recompute n (unless an optimisation called let-floating kicks in)
05:12:39 <ski> > ((`runStateT` 1) . forever . StateT) (\s -> if s >= 1000 then Left s else Right (s,2*s))  -- Psybur
05:12:41 <lambdabot>  Left 1024
05:13:07 <Psybur> Thats no fun, I want ExceptT :D?
05:13:08 <ertes-w> fraise: if you raise n to the top leel, then it becomes a constant applicative form…  once computed, it will remain computed
05:13:25 <fraise> ertes-w: hm... ok
05:13:50 <ertes-w> fraise: the following might also work:
05:13:58 <ski> > (runIdentity . runExceptT . (`runStateT` 1) . forever . StateT) (\s -> (ExceptT . Identity) (if s >= 1000 then Left s else Right (s,2*s)))  -- like this ?
05:14:00 <lambdabot>  Left 1024
05:14:02 <ertes-w> fraise: f = (*x)  where n = 3^5000
05:14:05 <fraise> i sorta understand: otherwise we'd keep variables which wouldn't necessarily be ever used again...
05:14:49 <ertes-w> fraise: this function appears to be equivalent to the previous one, and semantically it is, but there is a subtle difference:  what's really going on here is this:
05:14:58 <ertes-w> f = (\x -> n*x)  where n = 3^5000
05:15:01 <fraise> ertes-w: didn't you mean f = (*n)?
05:15:06 <ertes-w> err, yes, sorry
05:15:31 <ertes-w> this time n is *effectively* a top-level value, and GHC will likely treat it as such
05:15:36 <fraise> ok... i'm not sure to follow why that would be a different case...
05:15:39 <Psybur> ski, is there anyway that I dont have to have the computation return left or right? Can I just use some method that throws the exception?
05:15:58 <fraise> ertes-w: why is it at top level?
05:16:10 <ertes-w> fraise: it's easier to understand with 'let':
05:16:23 <ertes-w> f1 = \x -> let n = 3^5000 in n*x
05:16:33 <ertes-w> f2 = let n = 3^5000 in \x -> n*x
05:16:53 <fraise> ertes-w: i think i get it: f is basically a partially applied function, and n is the stored value of the first parameter?
05:16:55 <Psybur> So I guess the greater than 1000 check would no longer be in the state monad
05:17:10 <ertes-w> fraise: n is an independent value
05:17:24 <ertes-w> and since it doesn't depend on x, we can define it *outside* of the function
05:17:27 <Taneb> ertes-w: my plan for groups was "Maybe if this exists people will find a way to use it, groups are very useful in maths, why not in Haskell"
05:17:32 <fraise> it's similar to f = g (3 ^ 1500); g = (n*) ?
05:17:35 <Taneb> It hasn't quite materialized like that
05:17:48 <fraise> oops g n = (n*)
05:18:18 <Psybur> Having that greater than 1000 check in the stateful computation seems like it violates the single responsibility principle :D?
05:18:29 <ski> > (runIdentity . runExceptT . (`runStateT` 1) . forever) (get >>= \s -> if s >= 1000 then throwError s else modify (2 *) >> return s)  -- or this ?
05:18:31 <lambdabot>  Left 1024
05:18:56 <ertes-w> fraise: remember sharing?  imagine you use f1 with 'map':  map f1  -- here n will only exist after you applied f1 to an argument…  there will be no sharing
05:18:58 <ski> Psybur : `throwErrir' ?
05:19:05 <ski> er, `throwError', i.e.
05:19:26 <fraise> ertes-w: i thought every foo x = x * n where n = 3^150 was desugared to foo = \x -> let n = 3^150 in x * n, and from there i think the optimizer can infer that n does not depend on x...
05:19:26 <ertes-w> fraise: but with (map f2) it's different:  map f2 = map (let n = 3^5000 in \x -> n*x)
05:19:57 <ertes-w> fraise: that's true, but firstly you're relying on an optimisation
05:19:59 <fraise> ertes-w: oh right i get it
05:20:24 <ertes-w> secondly it's more subtle than that, because 'n' might actually still be below an abstraction
05:20:33 <fraise> ertes-w: well yeah... don't we all? ^^
05:20:46 <ertes-w> if you write (f2 :: (Num a) => a -> a), then n will probably not float to the top
05:20:54 <ertes-w> if you write (f2 :: Integer -> Integer), then it likely will
05:21:24 <Psybur> ski, I get your point about throwError. But this still violates the single responsibility principle. But I also understand it is a trivial example. Lets see if I can make another trivial example. It would probably have to replace forever with something like iterate
05:22:00 <ski> elaborate on what you mean by "violates the single responsibility principle" here ?
05:22:00 <fraise> ertes-w: hm interesting, and i get it
05:22:03 <Psybur> So the exception handling happens in the layer above the state comp. In the last code it looks like they are both still combined
05:22:56 <ertes-w> fraise: to be safe you should just define it on the top level
05:23:05 <ertes-w> otherwise you will be relying on optimisations
05:23:23 <fraise> though for your map f1 example, i'm sort of skeptical... fmap f1 (x:xs) = (f1 x) : fmap f1 xs, so it looks like f1 is effectively unwrapped for each item of the list...
05:23:36 <fraise> ertes-w: sure, i'll do that of course :)
05:23:39 <ski> in the last version, the argument of `forever' has type `StateT Integer (ExceptT Integer Identity) Integer', just like in the version before that
05:24:18 <fraise> ertes-w: i think the big problem in "memoizing" local constants is: what if the function never gets called again? then the memory is filled with constants never to be used again...
05:25:13 <ertes-w> fraise: sharing only means that a value is reused
05:25:19 <ertes-w> if there is no more user, it will be GCed
05:25:29 <fraise> ertes-w: the ideal would be a way to *tell* ghci that a local value is to be stored with the function, as a sort of closure... top level bindings have their disadvantages... but then that's not too big of a dead...
05:25:50 <fraise> ertes-w: but if it's top level it's not the same right?
05:27:04 <fraise> :t lookup
05:27:06 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
05:27:30 <fraise> why was it defined with this order of arguments :/
05:28:24 <fakenullie> key -> value
05:28:47 <fakenullie> you can do map swap
05:29:10 <fraise> map swap?
05:29:27 <fakenullie> :t lookup a (map swap b)
05:29:29 <lambdabot> error:
05:29:29 <lambdabot>     • Couldn't match expected type ‘[(b, Expr)]’
05:29:29 <lambdabot>                   with actual type ‘Expr’
05:29:38 <mniip> fraise, you can always change the order of arguments
05:29:46 <mniip> :t flip lookup
05:29:48 <lambdabot> Eq a => [(a, b)] -> a -> Maybe b
05:29:51 <mniip> :t lookup . map swap
05:29:53 <lambdabot> (Eq a, Eq b1) => [(a, b1)] -> [([(b1, a)], b2)] -> Maybe b2
05:30:01 <mniip> er
05:30:07 <mniip> :t (lookup .) . map swap
05:30:09 <lambdabot> error:
05:30:09 <lambdabot>     • Couldn't match type ‘[(b, a)]’ with ‘a1 -> a2’
05:30:09 <lambdabot>       Expected type: [(a, b)] -> a1 -> a2
05:30:21 <mniip> :t (. map swap) . lookup
05:30:22 <lambdabot> Eq b => b -> [(a, b)] -> Maybe a
05:30:33 <mniip> :t flip lookup . map swap
05:30:35 <lambdabot> Eq a => [(b, a)] -> a -> Maybe b
05:30:49 <fraise> no i meant, if i want to define (lookInM1 :: a -> Maybe b) i'll have to define it as (lookup = flip lookup M1) with (M1 :: [(a,b)]), or the Map equivalent
05:32:06 <mniip> (`lookup` M1)
05:32:25 * ski would also have preferred to other argument order, fwiw ..
05:32:42 <fraise> mniip: i know, just, usually they choose a sane default... i don't see myself mapping (lookup element) in a list of Maps... but then that's just me...
05:33:01 <fraise> mniip: hm yeah... there's that solution too
05:33:29 <mniip> usually you place it in a sequence of compositions
05:33:33 <mniip> where a map arrives on the left
05:33:38 <mniip> the right *
05:33:42 <mniip> not the key
05:33:53 * hackage log-warper 1.7.4 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.7.4 (shersh)
05:33:58 <mniip> I mean, usually the key is "more static" than the map
05:34:30 <fraise> mniip: hm... i guess it's a tie
05:35:23 <fraise> mniip: i think both can be argued for... i'd love some special symbolic prefix to flip a function without verbosity...
05:37:42 <fraise> btw, is there an extension to allow more special characters in normal value labels? since it's good practice keeping whitespace around operators anyway, and it'd be great if i could add a question mark as postfix to indicate a Maybe as output, etc...
05:42:34 <wz1000> are there any disadvantages to using ReaderT (TVar a) IO over StateT a IO?
05:42:56 <infinisil> wz1000: they are different things
05:43:04 <merijn> wz1000: Those are very different things, tbh
05:43:14 <wz1000> because the former lets me share state across multiple threads
05:43:19 <Athas> If you don't care for the difference, then using 'StateT a IO' is much better.
05:43:34 <Athas> Don't use TVars unless you need to share state across threads.
05:43:53 <Athas> And think really hard about whether you *really need* to do that...
05:43:57 <wz1000> that is exactly what I need to do
05:44:13 <Athas> Well, then using StateT would not work for you anyway, so you have no choice.
05:44:20 <Athas> Except using one of the other shared variables, like MVar.
05:45:16 <wz1000> well, for my use case, some kind of synchronization mechanism that runs every loop could work with StateT 
05:45:22 * hackage invariant 0.5 - Haskell98 invariant functors  https://hackage.haskell.org/package/invariant-0.5 (ryanglscott)
05:46:18 <wz1000> because my state is essentially a Map
05:46:51 <dminuoso> ertes-w: Im so tempted to try out comonads now. :(
05:46:59 <dminuoso> But I wouldn't know what to do with them.
05:47:26 <wz1000> and no two threads should ever be accessing/working with the same key in the map at the same time
05:47:45 <dminuoso> ertes-w: I suppose I could create a game of life automaton.. this seems like a perfect fit for a comonad.
05:48:03 <Athas> You could do that with a shared MVar that contains a map, and have a thread claim work by removing the key from the map.
05:48:08 <Athas> No need for STM.
05:48:24 <ertes-w> dminuoso: it is
05:48:29 <Psybur> ski, would something like this be considered cleaner since the except and state logic are separate? https://glot.io/snippets/ew6vv79n5o
05:48:41 <ertes-w> dminuoso: i've used StoreT for image processing in the past
05:48:46 <merijn> Athas, wz1000: Hell why even have a Map? Why not just a Chan with every thread grabbing work from it?
05:49:19 <Athas> Right.  Actually, that's how I usually write simple work-queue programs in Haskell.
05:49:41 <Athas> Shared state is always a disease, and avoidance is the best cure.
05:49:45 <merijn> Athas: If I ever get to release my 1.0 version I have a much nicer library for that now :)
05:50:05 <infinisil> OH I didn't know StoreT, can this be used to do memoization and generic programming?
05:50:15 <merijn> Athas: Because my main problem with using Chan as a work queue is the lack of way to finalise it
05:50:44 <merijn> Athas: So I have a closable version of Chan with built in combinators for things like "run this IO process in parallel" taking care of all that nonsense
05:50:57 <merijn> But I'm still fiddling with the API, so I haven't released it yet
05:51:17 <infinisil> merijn: Doesn't pipes do something like that?
05:51:51 <merijn> infinisil: No, pipes is for streaming
05:52:04 <merijn> infinisil: Pipes doesn't have a "parallel workqueue"
05:52:15 <merijn> infinisil: Although I have pipes and conduit wrappers for my library too :p
05:52:45 <infinisil> Ah, I more thought of a finalizing signal which i think pipes does
05:53:01 <infinisil> and pipes-concurrency probably isn't it either
05:53:06 <merijn> infinisil: pipes tracks end of input yes, but doesn't do parallel
05:53:16 <infinisil> I see
05:53:26 <Athas> merijn: sounds useful.  Although for my use case, I know in advance how many elements are contained in the work queue, so I just count down.
05:53:28 <merijn> pipes-concurrency would work, but too much hassle for me
05:53:39 <merijn> Athas: Then you still need to track the count :)
05:54:41 <merijn> I forget, what's the URL for package candidates?
05:54:48 <infinisil> Isn't there some existing solution to what you're creating merijn ? Or is that insufficient for your usecase?
05:55:05 <infinisil> merijn: https://hackage.haskell.org/upload#candidates
05:55:28 <merijn> infinisil: That's for uploading them
05:55:36 <merijn> infinisil: I meant, the URL for a previously uploaded candidate
05:56:05 <infinisil> ah
05:56:24 <merijn> ah, found it
05:56:33 <merijn> Although I apparently didn't upload a candidate yet for this
05:57:12 <merijn> Anyway, back to everyone's favourite hobby...generating C(++) from Haskell :p
06:02:23 * hackage bifunctors 5.5 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.5 (ryanglscott)
06:05:03 <ski> Psybur : how about `let act = do replicateM_ 10 f; g =<< get in print =<< (runExceptT . (`execStateT` 1)) act', with `f :: MonadState Int m => m ()' and `g :: MonadError String m => Int -> m Int' ?
06:06:21 <Psybur> If you really must make it harder to read, sure ;p
06:07:01 <ski> the main point being the different signatures for `f' and `g'
06:07:31 <Psybur> Why use MonadState instead of StateT?
06:07:33 <ski> (and doing the `runExceptT' and `execStateT' in one go at the end, rather than interleaving those with other stuff)
06:08:39 <ski> that way, `f' and `g' will, in this use case, both be used with the monad `StateT Int (ExceptT String IO)'
06:09:42 <Psybur> Is there an advantage of keeping it all in one monad?
06:09:47 <ski> (you should be able to use `Identity' instead of `IO' there, if you prefer)
06:10:28 <ski> you don't need to fiddle with the running at the end, passing the result from `execStateT' to `g', and then to `runExceptT'
06:10:38 <ski> you do all the "runs" in one go, at the end
06:11:27 <Psybur> Is there any advantage to that vs splitting it up?
06:11:35 <ski> you will still have the guarantee that `f' can only do state effects, and `g' only exception effects, because of their polymorphic signatures
06:12:51 <ski> .. however, if you use both `MonadState' and `MonadError' constraints in the same signature, you won't get the guarantee that the caller will in fact use it with a monad where the state effect layer is wrapping the exception effect layer (and this can affect the semantics of your code)
06:13:34 <pierrot> hi. how can I define `<*>` for (ResT m) ? https://glot.io/snippets/ew6j56tztl I'm not sure about how to do pattern matching in that case
06:13:49 <Psybur> I thought it would be better to have the exception layer wrap the state layer?
06:14:01 <ski> @unmtl StateT s (ErrorT e m) a
06:14:01 <lambdabot> s -> m (Either e (a, s))
06:14:02 <ski> @unmtl ErrorT e (StateT s m) a
06:14:02 <lambdabot> s -> m (Either e a, s)
06:14:27 <ertes-w> pierrot: it displays the whole code in one line for me
06:14:29 <ski> in the former case (state wrapping exception), you only get a final state if there was no (uncaught) exception
06:14:43 <Psybur> I see
06:14:53 <pierrot> ertes-w: hmm weird. I set 90 lines
06:15:03 <ski> in the latter case (exception wrapping state), you get a final state (the last state before (uncaught) exception, if any), regardless
06:15:04 <Psybur> Is it standard to have the exception layer be at the bottom?
06:15:22 * hackage extra 1.6.2 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.2 (NeilMitchell)
06:15:23 <Psybur> Oh, I guess if you want the partial computation before the exception
06:15:41 <ski> Psybur : i think both can be useful, but perhaps discarding the state in case of exception is more common ?
06:15:52 <pierrot> ertes-w: try now https://glot.io/snippets/ew6j56tztl
06:16:07 <ertes-w> pierrot: same
06:16:49 <ski> my point is that a `(MonadState S m,MonadError E m)' constraint on `m' doesn't impose an ordering of the effect layering .. something which could be good to have
06:16:51 <pierrot> I'll use other paste site, but it works for me. Odd
06:17:12 <fr33domlover> For me often the StateT is part of the main monad I use in my program, and ExceptT comes on top in specific parts where I want to collect some error
06:17:44 <fr33domlover> (Or MaybeT, they usually come on top for me)
06:18:00 <pierrot> ertes-w: http://lpaste.net/1497451664989224960
06:18:43 <pierrot> hmm that version is outdated :/
06:19:11 <ertes-w> pierrot: Res is pretty much just (Either (Maybe String))
06:19:29 <ertes-w> pierrot: so ResT is ExceptT (Maybe String)
06:20:06 <Psybur> ski, so I guess its more common to mix together monadic concerns in order to ensure the correct ordering rather than splitting things up?
06:20:07 <pierrot> I haven't dealt with those types
06:20:44 <ski> @type mapStateT lift :: Monad m => StateT s m a -> StateT s (ExceptT e m) a
06:20:46 <lambdabot> Monad m => StateT s m a -> StateT s (ExceptT e m) a
06:21:43 <ski> Psybur : i think it's pretty common to define an abstract application monad, and hide the layering details inside it, yes
06:21:45 <fr33domlover> Psybur, personally I use 'transformers' alone for specific monads, and 'mtl' when I really need the generalization, which mostly I don't
06:22:03 <fr33domlover> Ah yes what ski said ^_^
06:22:08 <fr33domlover> Exactly what I do
06:23:05 <pierrot> ertes-w: http://lpaste.net/7888497914949926912 I was about to implement `<*>` for `(ResT m)`
06:23:44 <merijn> Does conduit's >> run any remaining actions after upstream is exhausted? i.e. if I wanna yield some more data after exhausting upstream, will that "just work"?
06:24:37 <Psybur> merijn, try it and see? :D
06:28:19 <Psybur> > runConduitPure $ yieldMany [11,2,3] .| sinkList >> yieldMany [1,2,3] .| sinkList
06:28:21 <lambdabot>  error:
06:28:22 <lambdabot>      Variable not in scope: runConduitPure :: t2 -> t1error:
06:28:22 <lambdabot>      Variable not in scope: yieldMany :: [Integer] -> t2error:
06:28:29 <Psybur> > runConduitPure $ yieldMany [1,2,3] .| sinkList >> yieldMany [1,2,3] .| sinkList
06:28:32 <lambdabot>  error:
06:28:32 <lambdabot>      Variable not in scope: runConduitPure :: t2 -> t1error:
06:28:32 <lambdabot>      Variable not in scope: yieldMany :: [Integer] -> t2error:
06:30:17 <vaibhavsagar> stack seems to run my tests in parallel but cabal new-test does not, is there an option I need to pass to make this so?
06:31:32 <vaibhavsagar> my project is at https://github.com/vaibhavsagar/duffer, cloning it and running `stack test duffer` runs hspec tests in parallel
06:32:07 <lyxia> I see a "disable-deterministic" flag
06:32:20 <vaibhavsagar> I'm trying to get the same behaviour by running `cabal new-configure --enable-tests; cabal new-build; cabal new-test`
06:32:28 <lyxia> that is "used by the test suite"
06:32:32 <vaibhavsagar> so I need to run `cabal new-test --disable-deterministic`?
06:33:00 <Sornaensis> is there a way to look at the generated core code from ghc?
06:33:09 <lyxia> I don't know really :)
06:33:20 <lyxia> Sornaensis: -ddump-simpl
06:33:30 <vaibhavsagar> no worries, I thought there might be something simple I was missing
06:33:41 <vaibhavsagar> --disable-deterministic doesn't seem to have any effec
06:34:00 <Sornaensis> thanks
06:34:14 <lyxia> Sornaensis: there are other -d options depending on the stage you want to look at and how you want it dumped
06:34:23 <MarioFlach> Hello everybody. I'm trying to understand the Git packfile format. More specifically how to parse a delta chain of (copy/insert commands).
06:34:45 <MarioFlach> I came across an Haskell implementation but I do not fully understand it...
06:35:05 <lyxia> Sornaensis: You probably also would like to use -dsuppress-all to reduce noise with coercions and types.
06:35:12 <fr33domlover> MarioFlach, git's git repo has docs about it and there's git's own C implementation, take a look
06:35:26 <fr33domlover> I once did stuff with the pack format
06:35:31 <MarioFlach> =)
06:35:45 <MarioFlach> I did read the docs. But the delta stuff is not really documented anywhere.
06:35:48 <Athas> Is there a time frame for when 'cabal new-build' will just become 'cabal build'?
06:35:54 <vaibhavsagar> MarioFlach: I have a haskell implementation at https://github.com/vaibhavsagar/duffer
06:36:00 <vaibhavsagar> any questions in particular?
06:36:27 <MarioFlach> yes. I am stuck at how the COPY command offset and size length (in bits) is stored.
06:36:47 <MarioFlach> I came across a great blog article with following implementation:
06:36:53 <MarioFlach> https://gist.github.com/redrabbit/eb4b462ba2e44100471bc26546b3f71c
06:37:03 <MarioFlach> Here the blog post: http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/#implementation_of_the_delta_encoding_algorithm
06:37:39 <MarioFlach> I don't understand how the first byte is packed. How do i know if offset and size are stored in 4 bits, 8 bits or 16 bits.
06:37:45 <pierrot> ertes-w: can I do pattern matching of the form `(ResT f) <*> (ResT x) = ...` ?
06:38:29 <vaibhavsagar> MarioFlach: have you seen https://github.com/vincenthz/hs-git/blob/a843685bf27e323626482276580eb83e73461cef/Data/Git/Delta.hs#L53
06:39:36 <MarioFlach> vaibhavsagar: Thanks for the code. Will try to decrypt that =)
06:39:55 <vaibhavsagar> sure, I'll try to summarise but it's quite an idiosyncratic format
06:40:05 <MarioFlach> ^^
06:40:53 <MarioFlach> The thing is, I'm far from beeing an Haskell expert. I want to implement the Pack parsing with Erlang wich provides pattern-matching on bitstrings.
06:40:53 <vaibhavsagar> there's also https://codewords.recurse.com/issues/three/unpacking-git-packfiles#applying-deltas
06:41:09 <vaibhavsagar> I see
06:41:28 <MarioFlach> vaibhavsagar: Thanks, I did came across this one.
06:42:07 <vaibhavsagar> so the offset is based on the next 4 bits, the length is based on the next 3
06:42:56 <vaibhavsagar> so it looks like 1lllooo IIRC
06:43:06 <vaibhavsagar> sorry, 1llloooo
06:43:36 <vaibhavsagar> where l is the bits determining length and o is the bits determining offset
06:43:48 <ertes-w> pierrot: yes
06:44:08 <pierrot> If I do `(ResT f) <*> (ResT x)` then it would be `f :: m (Res (a -> b))` and `x :: m (Res a)` but I still have a `Res (a -> b)` and a `Res a` both wrapped in `m`
06:44:14 <vaibhavsagar> and the way it works is reading from the end backwards
06:44:36 <ertes-w> pierrot: sure
06:44:46 <vaibhavsagar> so if bit 0 (the last one) is set, read the next byte
06:44:48 <MarioFlach> vaibhavsagar: Thanks a lot, will experiment with this
06:44:58 <MarioFlach> vaibhavsagar: hmmm
06:45:09 <vaibhavsagar> if bit 1 is set, read the byte after and lshift it by 8
06:45:23 <ertes-w> pierrot: ResT cf <*> ResT cx = ResT _r  -- _r :: m (Res b)
06:45:24 <vaibhavsagar> if bit 2 is set, read the byte after and lshift it by 16
06:45:37 <vaibhavsagar> if bit 3 is set, read the byte after and lshift it by 24
06:45:54 <pierrot> ertes-w: yeah, but I'm not sure about how to construct that `_r`
06:46:13 <vaibhavsagar> the offset is the values you read or-ed together
06:46:21 <ertes-w> pierrot: ResT cf <*> ResT cx = ResT (do mf <- cf; _r)
06:46:21 <MarioFlach> vaibhavsagar: Alright =). But why does size have 3 bits and offset 4 for telling their length?
06:46:27 <pierrot> I need to use `<*>` version of `Res`
06:46:46 <ertes-w> pierrot: you want short-circuiting, as far as i can tell
06:47:04 <ertes-w> pierrot: so you can't use (<*>) of Res, and you actually need m to be a Monad
06:47:40 <vaibhavsagar> because the high bit determines whether this is a copy or src instruction
06:47:49 <vaibhavsagar> so that only leaves 7 bits
06:49:02 <vaibhavsagar> if it's a src instruction it's a lot simpler, the other 7 bits are the length in bytes of the content you have to copy
06:49:02 <vaibhavsagar> and those bytes follow the instruction
06:49:04 <MarioFlach> vaibhavsagar: Yes, I got this one already.
06:49:25 <pierrot> ertes-w: in this code `ResT cf <*> ResT cx = ResT (do mf <- cf; _r)` `cx` is never used... 🤔
06:49:27 <MarioFlach> vaibhavsagar: The copy commands are a bit more difficult.
06:49:38 <vaibhavsagar> so in my implementation they're called copy and insert instruction
06:49:42 <MarioFlach> vaibhavsagar: Will give it a try. Thank you a lot.
06:49:48 <vaibhavsagar> sure
06:49:54 <pierrot> and what's that `_r`. isn't out of context?
06:50:07 <MarioFlach> In Erlang, I basically have one-liner pattern-match like this:
06:50:07 <vaibhavsagar> feel free to reach out on github or twitter or find my email on my website if you have more questions
06:50:12 <MarioFlach> <<0::1, size::7, data::binary-size(size), rest::binary>>
06:50:35 <vaibhavsagar> that looks really convenient
06:50:58 <MarioFlach> vaibhavsagar: Thanks. I've been asking around the past days. First time on #haskell and two persones have implemented their own Git packfile parsers =)
06:51:17 <vaibhavsagar> there's more, seem http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/#format_of_the_delta_representation
06:51:37 <vaibhavsagar> do let me know how you progress, I think bitfields are a good fit for this problem
06:51:44 <vaibhavsagar> one thing I should point out
06:51:46 <ertes-w> pierrot: _r is a placeholder
06:51:53 <ertes-w> pierrot: you have to write it
06:52:03 <pierrot> oh, I got it
06:52:19 <MarioFlach> The blog post from Stefan Saasen has been my reference in order to implement the whole Packfile parsing in Erlang.
06:52:28 <vaibhavsagar> the special length 0x10000 is represented as 0 in copy instructions
06:52:38 <MarioFlach> 256?
06:52:41 <vaibhavsagar> don't ask me why, I don't think it makes any sense
06:52:44 <pierrot> is it mandatory for `m` to be a monad?
06:52:59 <MarioFlach> hmm
06:53:03 <pierrot> or just an instance of `Applicative` is enough?
06:53:30 <vaibhavsagar> so if you look at all the haskell implementations they special case it
06:53:49 <vaibhavsagar> see https://github.com/vincenthz/hs-git/blob/master/Data/Git/Delta.hs#L63
06:53:50 <MarioFlach> ok
06:54:05 <ertes-w> MarioFlach: you can probably do something like that in haskell using pattern synonyms
06:54:44 <vaibhavsagar> it's possible you'll not run into this in testing so I thought I should point it out
06:54:58 <vaibhavsagar> ertes-w: like a Bitfield pattern synonym?
06:55:22 <vaibhavsagar> I was thinking maybe ViewPatterns would be nice
06:55:28 <ertes-w> yeah
06:55:45 <merijn> Athas: And new-build puts things in really hard to locate paths
06:55:55 <vaibhavsagar> that would be pretty great
06:56:04 <vaibhavsagar> I found bit manipulation in Haskell quite painful
06:56:25 <vaibhavsagar> but that might be because I was a beginner when I did it
06:56:25 <Athas> merijn: okay, I would definitely need that.
06:56:27 <MarioFlach> vaibhavsagar: And what happens if all bits are 0, then offset/size is also 0?
06:56:39 <Athas> It's really nice that 'stack install' puts stuff in a standard location instead of $HOME/.cabal/bin.
06:56:44 <vaibhavsagar> that byte makes no sense
06:57:01 <vaibhavsagar> but it would be an insert instruction I think
06:57:07 <vaibhavsagar> an insert of 0
06:57:35 <MarioFlach> vaibhavsagar: No, i mean the 3 bits for size and the 4 bits for offset
06:57:45 <MarioFlach> vaibhavsagar: If these are all 0
06:58:07 <MarioFlach> vaibhavsagar: in a COPY cmd
06:58:17 <ertes-w> i guess lenses are easier than pattern synonyms
06:58:21 <vaibhavsagar> I think that would be an offset of 0 and a size of 0x1000
06:58:40 <vaibhavsagar> https://github.com/vincenthz/hs-git/blob/master/Data/Git/Delta.hs#L63
06:59:09 <vaibhavsagar> ertes-w: are there widely-used bit twiddling lenses/prisms?
06:59:33 <vaibhavsagar> I still don't think I'd be able to use them yet but it would be comforting to know they're there :)
06:59:42 <ertes-w> vaibhavsagar: not sure about widely used, but the lens library comes with Data.Bits.Lens
07:00:04 <ertes-w> @let import Data.Bits.Lens
07:00:06 <lambdabot>  Defined.
07:00:28 <ertes-w> > (byteAt 1 +~ 3) (0 :: Word32)
07:00:30 <fr33domlover> I once started to write a git&darcs project hosting web app in Haskell and I tried to implement both the git and the darcs stuff in Haskell, most of which worked (but my git pull/push code remained unfinished, it took me a lot of time and was complicated)
07:00:31 <lambdabot>  768
07:00:31 <vaibhavsagar> cool! thanks for the pointer
07:00:59 <vaibhavsagar> fr33domlover: I stopped before I got to the push/pull stuff
07:01:02 <vaibhavsagar> and the diffing
07:01:07 <vaibhavsagar> I found those too hard
07:01:26 <fr33domlover> vaibhavsagar, yeah it really takes a lot of dedication haha
07:01:30 <vaibhavsagar> maybe I will go back and implement it someday, but maybe I won't :D
07:01:32 <ertes-w> > (bytewise +~ 1) (0 :: Word32)
07:01:34 <lambdabot>  16843009
07:01:34 <pierrot> ertes-w: do you suggest me something like `(ResT mf) <*> (ResT mx) = ResT (do rf <- mf; rx <- mx; return (rf <*> rx) )` ?
07:01:49 <vaibhavsagar> alright, it is sleepytime
07:01:49 <ertes-w> pierrot: no, because that's not short-circuiting
07:02:22 <vaibhavsagar> MarioFlach: please reach out if you have git questions, you can search my IRC handle and my website should come up
07:02:40 <vaibhavsagar> throw "haskell" and "git" in there if you need to narrow it down for some reason
07:02:57 <pierrot> ertes-w: how would it be short-circuiting?
07:03:17 <MarioFlach> vaibhavsagar: I wrote your nickname down. Thanks a lot, really! I've been wondering how this works for "some time" now =)
07:03:28 <vaibhavsagar> sure, my pleasure!
07:03:37 <vaibhavsagar> a blog post about this is on my giant list of things to do
07:03:47 <ertes-w> pierrot: you need to pattern-match on 'rf' after 'mf' and have 'mx' run only when it's Res
07:03:52 <vaibhavsagar> it would be nice to have code I could point people to
07:04:16 <ertes-w> pierrot: with your current version both mf and mx will always run
07:04:28 <pierrot> yeah, I see it
07:04:43 <ertes-w> you still get short-circuiting, but only on the level of Res
07:04:55 <MarioFlach> vaibhavsagar: These byte compresssions in the PACK format are interesting. For the PACK header, for the object headers, for the delta headers, etc.
07:05:10 <MarioFlach> vaibhavsagar: Each time I've been pulling hairs =)
07:05:16 <vaibhavsagar> yeah, they're all different
07:05:20 <MarioFlach> Yes
07:05:23 <pierrot> and also, `m` must be a Monad
07:05:31 <pierrot> to use `do`
07:05:40 <ertes-w> pierrot: it has to be, but for a different reason
07:06:06 <ertes-w> pierrot: an Applicative can't decide the future of the action based on an intermediate result (like rf)
07:06:32 <ertes-w> only a Monad lets you choose whether you want to run 'mx' based on 'rf'
07:07:03 <pierrot> I understand
07:07:03 <vaibhavsagar> MarioFlach: my least favourite is the encoding of the offset in an offset delta entry
07:07:44 <MarioFlach> vaibhavsagar: I've skipped encoding so fare. I'm using the libgit2 implementation and use the packbuilder functions for this.
07:08:04 <MarioFlach> vaibhavsagar: Maybe I will, at some time, need to do the encoding stuff too.
07:08:10 <pierrot> ertes-w: but without short-circuting (I mean, always running `rf` and `mf`), would it be possible with just an Applicative?
07:08:18 <vaibhavsagar> what I wanted to do was write parsers and serialisers for the pack format that could roundtrip effectively
07:08:28 <pierrot> `mf` and `mx` *
07:08:36 <ertes-w> pierrot: yes
07:08:38 <vaibhavsagar> so my test was `serialise (parse packfile) == packfile`
07:08:44 <MarioFlach> vaibhavsagar: I see.
07:08:56 <vaibhavsagar> and I tested on the git repo for my project
07:08:57 <ertes-w> pierrot: that's what you wrote above
07:09:05 <fr33domlover> MarioFlach, I used 'binary' for my git pack code
07:09:14 <fr33domlover> I guess 'cereal' works too
07:09:17 <pierrot> ertes-w: yes, but it wouldn't written in that way
07:09:22 <pierrot> because I used `do`
07:09:23 <vaibhavsagar> fr33domlover: he's writing it in Erlang
07:09:31 <pierrot> wouldn't work *
07:09:31 <fr33domlover> ah oops ^_^
07:09:45 <MarioFlach> fr33domlover: I'm using Erlang. Most available implementations i came across are Haskell.
07:09:45 <vaibhavsagar> only asking here because so many of us have written git implementations :)
07:09:57 <fr33domlover> MarioFlach, you traitor! use Haskell ;)
07:10:07 <ertes-w> pierrot: well, unfortunately do-notation came before Applicative was a thing…  what you wrote is applicative, but you need an extension for it to actually register as applicative:  ApplicativeDo
07:10:24 <vaibhavsagar> MarioFlach: have you seen https://github.com/dinosaure/sirodepac
07:10:35 <ertes-w> pierrot: standard do-notation desugars into Monad combinators
07:10:38 <vaibhavsagar> I hear it's much more extensive than what we have in Haskell
07:10:54 <vaibhavsagar> it's supposed to replicate the logic that turns loose objects into packfiles
07:11:05 <pierrot> ertes-w: yes, that's why I'm saying I can't weak the Monad requirement for `m` to just be Applicative
07:11:11 <vaibhavsagar> which is a can of worms I didn't want to open :)
07:11:20 <MarioFlach> Yes, when it was not haskell, it was OCaml.
07:11:25 <pierrot> unless I don't use `do`
07:11:31 <ertes-w> pierrot: yes, you can…  either enable ApplicativeDo, or stop using 'do'
07:11:47 <fr33domlover> Btw it seems to me like actually needing an Applicative instance is so rare these days
07:11:52 <MarioFlach> https://gist.github.com/sriranggd/1147827
07:11:57 <fr33domlover> Most of the time you just use transformers
07:11:57 <ertes-w> pierrot: if you write this at the top of your file, it will just work:  {-# LANGUAGE ApplicativeDo #-}
07:12:07 <fr33domlover> And they are already Applicative and Monad etc.
07:12:40 <merijn> fr33domlover: Define "most of the time"
07:12:43 <ertes-w> pierrot: BTW, if this is for production, you're reinventing ExceptT
07:12:58 <ertes-w> pierrot: just use ExceptT in that case (or even just IO)
07:13:04 <pierrot> ertes-w: No, it isn't my production
07:13:09 <pierrot> it's for an exercise
07:13:30 <pierrot> I need to write an instance of Monad for (ResT m)
07:13:41 <pierrot> that's why I'm writing Functor and Applicative first
07:13:58 <pierrot> it's rather tedious to write all these instances to just make a type a Monad
07:14:14 <ertes-w> pierrot: there are short-cuts
07:14:41 <fr33domlover> merijn, well I mean you probably write an Applicative for some new concept that isn't covered by existing stuff, which I guess happens, but idk my uneducated impression is that the math people do it mostly, while if you just write an application, most likely you use some existing stuff with existing instances you can reuse / wrap
07:14:45 <ertes-w> pierrot: newtype ResT m a = ResT { runResT :: m (Res a) } deriving (Functor)
07:15:12 <ertes-w> pierrot: instance (Monad m) => Applicative (ResT m) where pure = _; (<*>) = ap
07:15:25 <ertes-w> pierrot: instance (Monad m) => Monad (ResT m) where (>>=) = _
07:15:35 <ertes-w> pierrot: only the underscores need to be implemented
07:15:47 <ertes-w> everything else the compiler will fill in for you
07:15:57 <pierrot> ertes-w: wow, I didn't know that
07:16:12 <ertes-w> pierrot: but if it's an exercise check whether you're allowed to take those shortcuts
07:16:46 --- mode: cherryh.freenode.net set +o ChanServ
07:17:05 <pierrot> ertes-w: https://i.imgur.com/lk4uHxd.png
07:17:45 <ertes-w> pierrot: the exercise might be from before Monad was a subclass of Applicative
07:18:06 <pierrot> it just says "Implement instances of Monad for (ResT m) and MonadTrans ResT"
07:18:47 <ertes-w> Monad used to be a standalone class, but it became a subclass of Applicative as part of the Applicative-Monad-Proposal (AMP)
07:18:59 <ertes-w> IIRC it happened in GHC 7.10
07:18:59 <pierrot> ertes-w: Yes, I know that
07:19:54 <pierrot> `instance (Monad m) => Applicative (ResT m) where pure = _; (<*>) = ap`
07:20:10 <pierrot> what does the compiler do with the text in black?
07:20:27 <merijn> What text in black?
07:20:36 <pierrot> I think I meant bold
07:20:44 <Cale> pierrot: ap is defined in Control.Monad
07:20:51 <Cale> @src ap
07:20:51 <lambdabot> ap = liftM2 id
07:20:59 <Cale> Well, that's cute
07:21:13 <Cale> ap mf mx = do f <- mf; x <- mx; return (f x)
07:21:34 <pierrot> I see
07:21:47 <pierrot> and what's that underscore?
07:21:59 <pierrot> I've never seen an underscore on a right member
07:22:36 <pierrot> oh, it must be implemented
07:22:37 <Cale> That's a hole. The compiler will report an error telling you the type of thing which ought to go there.
07:22:39 <merijn> pierrot: Technically? Syntax error. But GHC treats underscores on the right hand side as "typed holes"
07:22:46 <pierrot> you said it earlier, sorry
07:25:11 <qmm> i've seen "instance Show Navigator where" before, but i haven't seen "instance showNavigator :: Show Navigator where" this is purescript code. what is "showNavigator"?
07:25:26 <lyxia> qmm: it's the name of the instance
07:26:08 <pierrot> since `(ResT mf) <*> (ResT mx) = ResT (do rf <- mf; rx <- mx; return (rf <*> rx) )` doesn't change the logic depending on the intermediate result `rf`, how can that be rewritten without `do`?
07:28:44 <lyxia> qmm: Imagine that classes are records,  class C a where f :: a -> b   =   data C a = C { f :: a -> b }        instance ct :: C T where f = ...   =   let ct :: C T ; ct = C { f = ... }
07:30:12 <qmm> lyxia: what is the point of naming a type class instance? is it referenced at some point later?
07:30:42 <merijn> qmm: Maybe PureScript is like Scala and doesn't require globally unique instances?
07:30:47 <lyxia> I'm not sure. This suggests it's only used in the output javascript: https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#named-instances
07:31:39 <qmm> thanks for the link lyxia.
07:31:42 <lyxia> Overlapping instances are still disallowed. IIRC orphans are actually strictly forbidden.
07:32:26 <lyxia> So that it's easier to ensure uniqueness.
07:33:44 <lyxia> It could be used as another way to disambiguate things but I don't know whather that's actually the case in purescript.
07:41:59 <cement> if I've got a choice between the IO and State monads for part of my program, and I'd need to use the StateT transformer eventually if I use State, what do I need to consider in making that decision?
07:43:14 <merijn> cement: Why would you need to use StateT eventually if you use State?
07:44:15 <cement> because the program does IO with the output of the functions I'm writing
07:44:52 <merijn> cement: You could just run the entire State computation before using IO?
07:45:11 <cement> yes
07:57:24 <MarioFlach> vaibhavsagar: Just wanted to tell you that everything works perfectly now =) Thank you very, very, very much =)
08:03:21 <Broli> Hey Guys! :)
08:04:03 <Broli> i  try to convert a Integer to a String, can you help me?
08:04:08 <Broli> so i explain
08:04:27 <Clint> > show 157
08:04:30 <lambdabot>  "157"
08:04:56 <Broli> Clint: perfect! 
08:14:17 <michalrus> If I have a value of some type T, how do I lift it to a `Q Exp`?
08:14:29 <michalrus> Just by `$(value)`?
08:16:30 <michalrus> So let’s say that I have a compile-time function `fun str = [d| someLength :: Int ; someLength = $(length str) |]`.
08:16:34 <lyxia> There's a lift function somewhere
08:16:40 <michalrus> How can I make `length str` happen in compile time?
08:17:25 <lyxia> https://hackage.haskell.org/package/template-haskell-2.12.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lift
08:17:46 <lyxia> To turn Haskell values into expressions
08:18:02 <michalrus> Mhmmm, but… I need to provide my own impl. Huh.
08:18:21 <lyxia> just derive it
08:18:42 <michalrus> Ohhh. ♥
08:18:45 <michalrus> Great.
08:20:27 <danza> this is an interesting tweet from the point of view of an haskeller https://twitter.com/levelsio/status/938707166508154880. it would surely be possible to write a single haskell file that is also a runnable webserver with a minimal template engine and database logic
08:20:47 <Broli> i try to rewrite the show function for a data
08:20:55 <Broli> please help
08:21:13 <Broli> data Nat = Zero | Succ Nat deriving (Show)
08:21:47 <capisce> so many golang jobs...
08:22:15 <Broli> instance Show Nat where       show :: a -> String       show Zero = 0 	  show (Succ xs) = show (1 + show xs)
08:22:31 <danza> Broli, please don't copy all of your code here
08:22:34 <capisce> I guess "worse is better" wins a lot of mindshare
08:23:09 <Broli> but I do not know yet how to handle the case of 0
08:24:25 <Broli> danza: how am i supposed to do it?
08:25:46 <danza> Broli, you should paste code, compiler errors and other lengthy contents in pages of a pastebin service, then write a single message with your question linking to them. people might be too busy or not interested nonetheless
08:29:11 <Broli> danza: yes i agree
08:29:14 <Broli> https://pastebin.com/F99tQzKs
08:32:01 <lyxia> We like lpaste.net here
08:32:15 <hexagoxel> what is the effective path length limit for the project directory on windows? i just moved a project to toplevel /c/ to stop compilation from failing.
08:32:24 <lyxia> Broli: you either derive Show or write an instance, can't have both.
08:32:44 <Psybur> Broli, you probably need a separate function to unroll your nat number. Also, show Zero should return "0" not 0
08:33:15 <lyxia> hexagoxel: around 100 or so?
08:33:44 <lyxia> https://stackoverflow.com/questions/1880321/why-does-the-260-character-path-length-limit-exist-in-windows ?
08:34:02 <Broli> Psybur: i know, please can you help me to fix this
08:35:16 <hexagoxel> lyxia: i suppose it depends on the build-tool. i had a project at a directory of length ~50 and it failed
08:35:39 <Broli> lyxia: you can remove deriving show, it was just to do tests
08:35:47 <hexagoxel> (using cabal new-build; stack is broken with 8.2.1 atm ..)
08:36:34 <cocreature> hexagoxel: the newly released stack 1.6 should work
08:37:12 <Psybur> Broli, how do you use Succ Nat besides Show?
08:37:23 <hexagoxel> ah, it is released. neat.
08:38:03 <Psybur> So zero is the terminator?
08:38:10 <Psybur> I thought natural numbers started at 0
08:39:46 <Broli> Psybur: please look for Nat declaration
08:41:15 <Psybur> Broli, https://glot.io/snippets/ew70mszs8m now go get an A on your homework :P
08:41:37 <Psybur> Actually that can be improved
08:41:56 <Psybur> https://glot.io/snippets/ew70nnnyne
08:42:20 <Psybur> You could probably also change unroll to be tail recursive but Ill leave that up to you
08:43:53 * hackage SDL 0.6.6.0 - Binding to libSDL  https://hackage.haskell.org/package/SDL-0.6.6.0 (fffaaa)
08:45:23 <Broli> Psybur: thanks but it is not my homework, i am a researcher :)
08:45:28 <Psybur> :D
08:45:42 <Psybur> Watcha researchin?
08:46:28 <natrys> trying to use stack nightly, I am being told: No information found for ghc-8.2.2. Supported versions for OS key 'linux64-ncurses6-nopie': GhcVersion 8.0.2, GhcVersion 8.2.1
08:49:49 <mniip> show = show . toEnum
08:50:20 <mniip> that would get the A if I were to check
08:54:50 <brynedwards> natrys: are you using the latest version of stack which was released today?
08:59:29 <thorsten`> whats the easiest way to run a reader function within a do-block for State?
09:00:44 <lyxia> runReader?
09:05:53 * hackage shakers 0.0.37 - Shake helpers.  https://hackage.haskell.org/package/shakers-0.0.37 (markfine)
09:07:15 <Psybur> RWS?
09:09:16 <Psybur> > runIdentity $ runRWST (do e <- ask; modify (*e)) 2 1
09:09:18 <lambdabot>  ((),2,())
09:09:23 * hackage shakers 0.0.38 - Shake helpers.  https://hackage.haskell.org/package/shakers-0.0.38 (markfine)
09:09:45 <kolinsol> Hello. I am trying to set up my vim to do haskell. Can anybody help me setting up ghcmod-vim to work with syntastic please?
09:15:59 <thorsten`> lyxia: ok :/ .. I was looking for something of type Monad m => ReaderT s m r -> StateT s m r  so I've written it on my own
09:16:14 <shreyansh_k> hi guys, newbie here. what tools are recommended to manage multiple projects with different and conflicting requirements?
09:16:56 <fakenullie> stack
09:17:33 <mud> kolinsol: I used to have that setup. Just as a random data point ... I found it too annoying to maintain and keep working. Also I think syntastic and ghcmod stopped working together some time back, unless that changed (or unless I remember wrong).
09:18:43 <kolinsol> so what is your current setup then?
09:18:48 <tommd> ghcmod varies between working and not working depending on developer time and version of ghc.
09:20:04 <mud> kolinsol: Just syntax highlighting and the usual completion stuff that completes things you've already typed. I also use snippets
09:20:33 <mud> I don't really have anything fancy specific for haskell at the moment. GHCi takes care of that when I need it really.
09:21:53 * hackage deriving-compat 0.4 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.4 (ryanglscott)
09:22:09 <mud> Oh I do use hlint in uhm neomake or whatever that's called (in neovim), I used to use syntastic for that, but then I switched to nvim recently.
09:22:14 <kolinsol> you mentioned ghci. i was thinking today about implementing some kind of a GHCIlike REPL for javascript
09:22:39 <kolinsol> basically for testing purposes.
09:23:12 <kolinsol> its main functionality would be to import toplevel functions from the file in order to play with them somehow
09:23:30 <kolinsol> has anybody heard of something like that existing for JS?
09:24:09 <fakenullie> npm probably has dozen implementations
09:24:18 <mud> I think mostly the browser-based tools are used? I'm not all that familiar with their capabilities though.
09:25:22 * hackage text-show 3.7 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.7 (ryanglscott)
09:26:18 <kolinsol> are you guys fulltime haskellers? just asking
09:26:35 <erisco> mostly not, but some are, talk to Cale
09:27:28 <kolinsol> is he/she some kind of a local legend?
09:28:03 <erisco> legend as in everyone knows him? yes, but legend as in he isn't real? well, we're not sure about that one
09:28:30 <mud> Cale is here all the time and very helpful, so ya pretty much.
09:29:04 <erisco> I just happen to know he uses Haskell at work to make mobile apps
09:29:18 <mazu> Cale is definitely real
09:29:36 <orion> I use Haskell almost every day at work.
09:29:52 * mazu also uses haskell every day at work
09:29:52 <orion> It's like pulling teeth to convince management that NodeJS is a bad idea.
09:29:59 <kolinsol> i remember trying to solve Conway's Game of Life problem in Haskell recently.
09:30:22 <kolinsol> i got stuck on randomly generating type instances
09:30:38 <kolinsol> and he is making mobile apps
09:31:14 <erisco> more broadly though, all Haskell programmers use their knowledge of functional programming to better the work they do
09:31:26 <kolinsol> true
09:31:58 <kolinsol> i wish one day i and up working on a haskell project
09:37:22 <natrys> brynedwards: I wasn't, but updated stack now. Still says the same thing though.
09:41:00 <geekosaur> that sounds like metadata, not stack itself
09:42:05 <jessicaw> hi guys, i'm trying to define a function that can combine two lists and sorted. the type signature needs to be merge :: Ord a => [a] -> [a]->[a]
09:42:09 <geekosaur> also curious as nightlies are definitely 8.2.2
09:42:28 <jessicaw> in the solution i can't use any other functions, i can only use recursion...
09:42:38 <geekosaur> so I'd suspect that this is just someone missing something as part of metadata for the new stack
09:48:40 <glguy> jessicaw: What's the question?
09:58:00 <jessicaw> I'm not sure why this code is not work... http://lpaste.net/360585
09:58:14 <jessicaw> not working*
09:59:08 <boxscape> jessicaw: you need to replace (xs:x) with (x:xs)
09:59:11 <erisco> jessicaw, explain what it should do, what input you tried, and what output you expected
09:59:31 <boxscape> jessicaw: well actually nevermind that wouldn't do what you want
09:59:49 <jessicaw> the lasT funciton suppose to return the last element from a list 
09:59:55 <jessicaw> input a list, output the last element of the list 
10:00:26 <erisco> and what output you got instead
10:01:03 <jessicaw> it didn't compile 
10:01:10 <erisco> paste the error message
10:01:23 * hackage preamble 0.0.57 - Yet another prelude.  https://hackage.haskell.org/package/preamble-0.0.57 (markfine)
10:04:43 <boxscape> jessicaw: when you write (x:xs) in the left side of the function, the first element of the list gets assigned to x, and the rest of the list gets assigned to xs. When you write (xs:x) you just change the names, so now you assign the first element to xs, you can't assign the last element to x like that
10:07:42 <jessicaw> boxscape thanks! 
10:07:54 <Psybur> > let last (x : []) = x; last (x : xs) = last xs; in last [1,2,3] -- jessicaw
10:07:56 <lambdabot>  3
10:10:20 <Psybur> jessicaw, also your code didnt compile because lasT [x] = x returns the type 'a' while lasT (xs:x) = x returns the type [x]
10:10:30 <Psybur> Sorry, the type [a]
10:11:38 <jessicaw> Psybur, yeah that's the error message that i got 
10:15:01 <jessicaw> boxscape how do I write a pattern that signifies the last item?
10:15:37 <Psybur> jessicaw, the last item in a list will be the pattern x : []
10:15:53 <jessicaw> thanks Psybur
10:16:00 <Psybur> See the code I posted earlier
10:16:01 <Psybur> > let last (x : []) = x; last (x : xs) = last xs; in last [1,2,3] -- jessicaw
10:16:04 <lambdabot>  3
10:16:08 <boxscape> jessicaw: you can't actually write such a pattern with the [a] type, because the list constructor : always takes the first element and a list and makes a new list - so if you want to deconstruct it you always have to take the first element off first
10:16:52 <Psybur> Since list is a recursive type you have to make a recursive function to get the last element :D
10:17:17 <boxscape> jessicaw: unless, as psybur wrote, in (x:[]), since then the list only has one element and so last element *is* the first element
10:17:43 <boxscape> (in case that's unclear, (x:[]) is the same as [x])
10:17:50 <rightfold> (☝︎ ՞ਊ ՞)☝︎ induction (☝︎ ՞ਊ ՞)☝︎
10:18:10 <jessicaw> thanks guys, let me try to fix the fucntion
10:27:21 <Broli> Hey!
10:27:32 <Broli> please help! https://pastebin.com/057AAzsu
10:27:55 <Broli> i don't understand the meaning of the error
10:28:18 <mud> Broli: instance Show (STree a) where    -- is likely a good start
10:28:48 <mud> You usually need a constraint on the 'a' as well, like instance Show a => Show (STree a) where
10:35:28 <cheater> hi
10:35:43 <cheater> erisco: thanks for the ideas earlier
10:35:58 <jessicaw> http://lpaste.net/360586 i understand the type for last xs is not a, is there a way to fix this?
10:36:04 <cheater> erisco: how would you ensure locality and let people change zoom level?
10:36:22 <jessicaw> XD
10:36:45 <boxscape> jessicaw: actually, I think the type for last xs should be a. The problem in that code is that you need parentheses, so that you have (x:[])
10:37:21 <boxscape> (or you can do it like you did earlier with [x])
10:37:50 <Broli> mud: Hammer! thanks
10:38:05 <jessicaw> IT WORKED!!!!
10:38:11 <boxscape> nice :)
10:38:14 <rightfold> :, despite being often written without surrounding white space, isn’t special. It’s a normal infix operator and has no special high precedence.
10:38:16 <jessicaw> Thanks so much!!!!
10:38:41 <Broli> jessicaw: you are welcome ;)
10:38:48 <jessicaw> :D
10:39:31 <boxscape> rightfold: well, it's special in that it can be used as a constructor. That's not possible with other non A-Z characters as far as I'm aware
10:40:26 <boxscape> maybe with uppercase cyrillic or greek characters?
10:41:26 <rightfold> You can write infix constructors
10:41:39 <boxscape> how would you do that?
10:42:05 <boxscape> oh I guess % exists as well
10:42:48 <rightfold> For example Cofree
10:43:18 <erisco> cheater, most languages are based on text files, and that is not flexible enough for those features. It is something you would build into an IDE
10:43:36 <cheater> can you describe some levels of zoom you would see useful?
10:43:47 <rightfold> boxscape: https://hackage.haskell.org/package/free-0.2.2/docs/src/Control-Comonad-Cofree.html
10:43:51 <cheater> i have been thinking about a similar approach too, i could tell you about it a little later
10:43:53 * hackage generic-deriving 1.12 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.12 (ryanglscott)
10:44:22 <boxscape> rightfold: okay, but that's using : as well as first character, at least
10:44:50 <boxscape> (also I got it wrong, % isn't a constructor)
10:45:11 <mniip> 1512671949 [21:39:09] <boxscape> rightfold: well, it's special in that it can be used as a constructor. That's not possible with other non A-Z characters as far as I'm aware
10:45:11 <boxscape> rightfold: but admittedly that means that the constructor : isn't special, that's true
10:45:11 <mniip> any unicode char from the category Lu will work
10:45:25 <boxscape> what is the category Lu?
10:45:36 <rightfold> Letters uppercase
10:45:38 <boxscape> ah, ok
10:46:10 <rightfold> A, Λ, Д, Æ, Å, etc
10:46:15 <boxscape> I see
10:46:38 <mniip> > text $ filter ((== UppercaseLetter) . generalCategory) [minBound .. maxBound]
10:46:40 <lambdabot>  ABCDEFGHIJKLMNOPQRSTUVWXYZÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦ...
10:46:53 <boxscape> I was attempting to try it out with greek letters, but windows cmd doesn't allow me to paste greek -.-
10:47:24 <rightfold> In Rust you get a linter warning if you use Δx as a variable name because it isn’t snake case 😂
10:51:57 * hackage gnss-converters 0.3.25 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.3.25 (markfine)
10:52:27 <cheater> erisco :)
10:52:33 <Psybur> ski, so going off of what we were doing earlier with combining state and except, does this seem like a standard way of doing things? Is it normal to have to use lift like this? https://glot.io/snippets/ew748nzlhf
10:53:12 <erisco> cheater, there have been several projects about treating programs as a database of definitions rather than directories of text files
10:53:24 <erisco> cheater, one of them is Code Bubbles. I haven't checked in on that stuff in years though
10:55:37 <cheater> oh, how did that stuff define different "levels"?
10:57:15 <runeks> Is there really no ready-made function that groups items in a list into a map if a certain property of the list equals another property?
10:57:18 <runeks> :: Eq show => (res -> show) -> [res] -> Map show [res]
10:58:01 <runeks> So, group [res] into a Map of show to [res] for each unique show
10:58:38 <rightfold> IxSet.fromList comes close but is potentially overkill
10:58:46 <erisco> runeks, this is easy to do without a specific definition for it
10:59:17 <runeks> I just thought something like this would exist already. Turns out I was wrong 
10:59:43 <erisco> Map.unionsWith (++) . fmap (\r -> Map.singleton (show r) r) -- I think
11:00:16 <erisco> liftA2 Map.singleton show id   if you want to get fancy
11:00:23 <Psybur> > Data.Map.fromSet $ Data.Set.fromList $ map (\x -> (show x, x)) [1,2,3] ?
11:00:26 <lambdabot>  <hint>:1:73: error:
11:00:26 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:03:56 <Psybur> > Data.Map.fromList $ Data.Set.toList $ Data.Set.fromList $ Prelude.map (\x -> (show x,x)) [1,1,2]
11:03:59 <lambdabot>  fromList [("1",1),("2",2)]
11:07:03 <erisco> > Data.Map.fromList $ Prelude.map (\x -> (show x,x)) [1,1,2]
11:07:06 <lambdabot>  fromList [("1",1),("2",2)]
11:07:13 <Psybur> Haha yeah thats right
11:07:16 <erisco> default behaviour is to overwrite
11:07:31 <erisco> Map.unionsWith lets you choose how to resolve conflicts
11:09:04 * hackage freer-simple 1.0.0.0 - Implementation of a friendly effect system for Haskell.  https://hackage.haskell.org/package/freer-simple-1.0.0.0 (lexi_lambda)
11:18:21 <Average-user> I did Day 7 part 1 in 20 seconds, I used the ctrl+f function of the browser. Is a shame that I didn't do it when it got released  :(
11:20:21 <boxscape> what did you search for with ctrl f?
11:23:45 <Ariakenom> I wrote a thing; undefined `unsafeMostDef` 1 = 1; 1 `unsafeMostDef` undefined = 1; [0..] `unsafeMostDef` 1 = 1
11:25:38 <cocreature> Ariakenom: that’s easy: "unsafeMostDef _ _ = 1" :)
11:25:46 <Ariakenom> :p
11:26:00 <cocreature> and it’s not even unsafe! :)
11:26:08 <Average-user> boxscape: the strings that appear just once, and had sub strings
11:26:27 <Zemyla> Ariakenom: Can't you use the "unamb" library?
11:26:36 <boxscape> not sure how you can do that quickly with ctrl f, but fair enough
11:26:58 <Average-user> boxscape: like I said
11:27:04 <erisco> lub lub lub
11:28:12 <cheater> "unamb" is too close to "unabomb"
11:30:34 <erisco> it is the only real way to define || and &&
11:31:05 <Ariakenom> Zemyla: indeed, just implementing for fun
11:32:12 <rightfold> don’t define anything without löb
11:32:47 <rightfold> hmm, can you do something like löb with Contravariant and how ridiculous would it be
11:34:32 <fishythefish> @ops here we go again
11:34:32 <lambdabot> Maybe you meant: pl oeis docs
11:38:04 <dgpratt> it's frustrating at times how much material I can find on language extension "X" that does not mention the declaration that one would need to use said extension
11:39:14 <dgpratt> speaking of, it seems that view patterns more or less need to be a function of one parameter, i.e. if I have a function over e.g. x and y coordinates, I'd need to pair them, is that right?
11:42:46 <Psybur> > (1,2,3,4,5,6,7,8,9,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
11:42:48 <lambdabot>  error:
11:42:48 <lambdabot>      • No instance for (Show
11:42:48 <lambdabot>                           (Integer, Integer, Integer, Integer, Integer, Integ...
11:42:50 <drninjabatman> hello, does anyone know if there have been any proposals or any other resarch about reverting evaluated thunks for garbage collection? 
11:43:20 <boxscape> hm, so they bothered to write the Tuple type but couldn't be bothered to write a Show instance
11:43:47 <fishythefish> dgpratt: which one are you matching on? you can supply the other to the view pattern explicitly
11:44:27 <fishythefish> boxscape: each length tuple is a separate (polymorphic) type and requires its own set of instances, so they only define instances up to a certain size for you
11:45:44 <boxscape> max size for tuples is 62 apparently
11:46:10 <Average-user> If I'm not mistaken there are Tuples for just a few sizes ¿Rigth?
11:46:11 <dgpratt> fishythefish: right, good point; in this situation, I need to match on both, which I now realize needs to be one pattern, of course -- just wasn't thinking clearly about it
11:47:00 <fishythefish> the haskell report doesn't restrict the size of tuples, but permits implementations to do so
11:47:15 <fishythefish> it mandates that every implementation must suppport tuples of at least size 15 along with appropriate instances
11:48:33 <crucify_me> hi a subtle point that I don't quite get here . do these 2 transmmit behave in precisely the same way? http://lpaste.net/360587 
11:48:38 <rightfold> GHC supports up to 63 elements. These are defined in some module with a comment that says that defining one with 64 or more elements causes GHC to segfault. It’s all incredibly silly.
11:48:46 <crucify_me> transmmit functions*
11:48:51 <boxscape> up to 62 actually :P
11:49:11 <fishythefish> crucify_me: yes
11:49:26 <crucify_me> thanks. so ..
11:49:32 <boxscape> > (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
11:49:34 <lambdabot>  error:
11:49:34 <lambdabot>      A 63-tuple is too large for GHC
11:49:34 <lambdabot>        (max size is 62)
11:50:28 <Average-user> > print "hi" 
11:50:29 <rightfold> long long long is too long for GCC
11:50:31 <lambdabot>  <IO ()>
11:50:34 <Psybur> Beats scala's 22 :D
11:50:41 <Average-user> how do I call lambdabot?
11:50:44 <Average-user> Like  I did?
11:50:44 <crucify_me> george harrison song?
11:50:47 <boxscape> beats Java's 0
11:50:52 <boxscape> or 1 I guess
11:50:57 <hodapp> wtf am I reading o_O
11:51:09 <Average-user> jaja
11:51:14 <boxscape> Average-user: that's how you call it, yeah
11:51:22 <boxscape> Average-user: but it won't execute IO actions
11:51:38 <Psybur> Lambdabot cant fire the missles? :{
11:51:42 <rightfold> Rust has no limit for the types themselves but at least they use macros to define all the instances up to 32 elements for arrays and tuples
11:51:44 <Average-user> >"Looks like" ++ " it wont"
11:51:59 <Psybur> > "Needs a space after the >"
11:52:02 <lambdabot>  "Needs a space after the >"
11:52:19 <Average-user> > "Looks like" ++ " it now going to work"
11:52:21 <lambdabot>  "Looks like it now going to work"
11:52:24 <boxscape> > usafePerformIO $ print "firing ze missiles" -- no :(
11:52:26 <lambdabot>  error:
11:52:26 <lambdabot>      Variable not in scope: usafePerformIO :: IO () -> t
11:53:04 <dgpratt> bummer, just like that my excuse to use those cool "view pattern" things just went away :(
11:53:12 <crucify_me> so fishythefish in channel there, that just illustrates how id is not polymorphic in this case. 
11:53:29 <fishythefish> crucify_me: how so?
11:53:50 <crucify_me> because it handles only [Bit]
11:54:01 <fishythefish> yes, because you gave it that type signature
11:54:11 <fishythefish> that's precisely the power of polymorphism - you can specialize it to many different types
11:54:16 <boxscape> it's nice that even lambdabot supports viewpatterns
11:54:18 <crucify_me> its a textbook illustration then.
11:54:31 <fishythefish> :t id :: Bool -> Bool
11:54:32 <lambdabot> Bool -> Bool
11:54:47 <boxscape> not lambdacase though :(
11:54:59 <Younder> Why 62 bits? Are the extra 2 bit's a tag?
11:55:00 * hackage monad-abort-fd 0.6 - A better error monad transformer  https://hackage.haskell.org/package/monad-abort-fd-0.6 (MikhailVorozhtsov)
11:55:04 <fishythefish> :t id :: Char -> Char
11:55:06 <lambdabot> Char -> Char
11:55:32 <fishythefish> crucify_me: a textbook illustration of what?
11:56:13 <Psybur> @slap lambdabot
11:56:14 * lambdabot will count to five...
11:56:22 <fishythefish> you can use id monomorphically, but that doesn't mean that id is not polymorphic
11:57:11 <Psybur> :t id :: (Num a) => Int -> a
11:57:11 <crucify_me> ok thanks. the reason I ask is from basic category theory. On those blackboard examples id just turns a "point" back on itself. so I was wondering if encode was used at all if I did ' decode . id . encode ' instead of using the channel func. 
11:57:13 <lambdabot> error:
11:57:13 <lambdabot>     • Couldn't match type ‘a1’ with ‘Int’
11:57:13 <lambdabot>       ‘a1’ is a rigid type variable bound by
11:57:37 <crucify_me> I know that crazy ..
11:57:41 <crucify_me> thats
11:58:09 <fishythefish> sounds like we need to review basic category theory
11:58:20 <crucify_me> not review, learn... :)
11:59:02 <fishythefish> one of the requirements of a category is that each object of the category has an identity morphism whose source and target are that object
11:59:25 <fishythefish> taking the objects of our category to be types and morphisms to be functions between them, id corresponds to the identity morphisms
11:59:45 <fishythefish> you can view id as being a family of monomorphic identity functions rather than a single polymorphic function
11:59:58 <fishythefish> each of these monomorphic instantiations is an identity morphism for a particular type
12:00:03 <crucify_me> that's why I tried it without the type [Bit] -> [Bit]
12:00:11 <Younder> id must be a monomorhism sureley. 
12:00:19 <crucify_me> (going back before a few of your posts)
12:00:26 <rightfold> id is an endomorphism
12:00:53 <crucify_me> endo? its something that sort of confuses / fascinates me.
12:00:54 <Younder> and a catamorphism is?
12:01:12 <fishythefish> Younder: yes, it's a categorical monomorphism, but "monomorphic" and "polymorphic" also refer to the range of types over which it can be applied
12:01:36 <platz_> had a moment of surprise when I realized I could eliminate the base case of a recursive function because typically functions that use an empty list tend to 'do the rigth thing' by using pure/applicative/mempty etc..
12:01:59 <fishythefish> a catamorphism is the unique F-algebra morphism from the initial F-algebra to another F-algebra
12:02:02 <fishythefish> crucify_me: endomorphism just means that the source and target of the morphism are the same
12:02:07 <rightfold> crucify_me: an endomorphism is a morphism from an object to that same object
12:02:15 <rightfold> For example, f :: Int -> Int
12:02:52 <rightfold> Also known as “decorator pattern” in the ivory tower
12:03:59 <Younder> rightfold, the ivory tower?
12:08:12 <crucify_me> ok I don't understand f-algebra (yet!). but I see how id shifts into polymorphism when the [Bit] type is not explicitly defined, fishythefish 
12:08:25 <crucify_me> not shifts into, but ...
12:08:31 <crucify_me> utilizes
12:08:49 <dminuoso> crucify_me: By the way. Have you expanded take/drop/chop8 by hand already?
12:11:21 <crucify_me> dminuoso, I can follow the take cons presentation . what confused me about that is that I think about two separate 'copies' of the list bits that a function operates on, ie whether there are copies
12:11:47 <dminuoso> crucify_me: Dont think in terms of copies, just think about it in a mathematical sense.
12:12:11 <crucify_me> please elaborate if you have time
12:12:22 <dminuoso> f(x) = 2*x + (x/2)  - if you stuff in a 1 for x, the fact that you evaluate (2*x) as (2*2) does not change "x" does it?
12:12:27 <dminuoso> err, *stuff in 2 for x
12:12:34 <dminuoso> Nothing changes.
12:13:07 <fishythefish> crucify_me: moreover, in math if you see f(x) = x, you don't worry about how many copies of x are involved, you just think about the value it has
12:13:19 <fishythefish> so like dminuoso said, don't think too operationally about this
12:13:58 <crucify_me> thats my biggest problem, I think, I think in terms of operational 'under the hood' stuff
12:14:40 <fishythefish> crucify_me: okay, then treat everything as const
12:15:01 <Younder> I don't see variables as holding values. I see them as references to objects which are the ones which have type. Lexically this mostly works. For performance reasons it is not really implemented that way.
12:15:07 <dminuoso> crucify_me: Do you know what a mathematical function is?
12:16:34 <crucify_me> but after drop returns a new un-mutated list, that is the essential part of the new pattern match. where you have chop9 (drop 8 bits). one moment dminuoso ..
12:16:46 <crucify_me> chop8
12:17:39 <fishythefish> Younder: I think that works in a language like Python or JS where you can bind a variable to objects of different types
12:17:41 <crucify_me> yes a math function has a set of inputs values that the function can handle, domain, range , etc ...
12:17:44 <fishythefish> but in other cases, you probably want typed variables
12:17:58 <dminuoso> crucify_me: Right. Can a mathematical function "change" things? 
12:18:05 <crucify_me> those domains and ranges can be viewed as sets or categories
12:18:12 <dminuoso> not categories, just sets.
12:18:18 <dminuoso> categories is something.. else =)
12:19:18 <crucify_me> can it change things? no the inputs are converted to outputs. the inputs are immutable
12:19:29 <crucify_me> not converted
12:19:42 <dminuoso> Right. Do you ever think about numbers being copied when you solve a mathematical equation?
12:20:23 <Younder> fishythefish, I guess I mean a variable in math a variable just stands in for a value or a expression. If it is unreferenced it can stand in for anything. 
12:21:01 <crucify_me> no, but as fishythef*ish said I do think in a operational fashion that I need to correct
12:21:06 <dminuoso> crucify_me: So a simple notion is that a function is just a big and possibly table with two columns mapping values to values with just one rule: the column on the left side must only contain unique values.
12:21:06 <fishythefish> Younder: you mentioned performance, so I assumed we were talking about a language which executes in some way
12:21:37 <dminuoso> *possibly infinite
12:22:04 <fishythefish> Younder: but even in math, we still ascribe "types" to variables. E.g. "Let G be an abelian group...". G hasn't been assigned a specific value yet, but we know there are things it cannot refer to
12:23:21 <dminuoso> crucify_me: https://gist.github.com/dminuoso/ffa7c5a0ebee21a3fd331675d5848b26 :)
12:23:37 <Younder> fishythefish, yes. But ideally performance issues are not a declarative issue. They should be handled by the compiler. And yes it is normal to restrict values to belong to a range or type.
12:23:40 <crucify_me> if I look at it operationally, my thinking is wrong because the list is not mutated, the function (or recursive step) returns a new list, so it is wrong seeing. I don't really know how to use the word semantic here
12:24:41 <dminuoso> crucify_me: Well, just do this with factorial. You wouldn't be thinking about things being "changed" or "copied" if you expanded that factorial 4 call, right?
12:24:55 <dminuoso> drop or take are no different than factorial in this respect.
12:25:01 <fishythefish> Younder: okay, since you're now mentioning a compiler, are you talking about variables in mathematics, or in a programming language (and if so, which?)
12:25:19 <crucify_me> I know how to do that. it is again a cons presentation using * instead of :
12:25:34 <dminuoso> crucify_me: Yeah pretty much. 
12:25:40 <dminuoso> Its absolutely not different =)
12:25:45 <cocreature> is there a way to get from Double to Word64 using only "base"?
12:26:09 <crucify_me> but another bad habit is doing away with thinking there are copies
12:26:25 <crucify_me> poor sentence formation ^
12:26:27 <dminuoso> crucify_me: The issue is just that it sets you into a mindset of "doing things"
12:26:34 <cocreature> I want to get the bit representation, not an integer value
12:26:42 <cocreature> and unsafeCoerce doesn’t work afaik
12:26:52 <crucify_me> that's interesting
12:27:22 <dminuoso> crucify_me: Just expand with a visual model. Like just expanding by hand representing lists with cons.
12:27:30 <crucify_me> yes I'm a bit older and grew up around automobiles, so its sacrilege to think of automobiles in this way !
12:27:58 <dminuoso> crucify_me: Here's one reason why thinking about copies is problematic.
12:28:09 <dminuoso> crucify_me: try and copy this [1..]
12:28:16 <cocreature> hm https://stackoverflow.com/questions/6976684/converting-ieee-754-floating-point-in-haskell-word32-64-to-and-from-haskell-floa seems to be describe the various solutions
12:28:21 <Younder> https://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504 is a good way to get to an understanding of how to efficiently implement fully functional data structures (no side effects)
12:28:22 <cocreature> none of which is particularly pretty :(
12:29:40 <crucify_me> right its purely symbolic and operations done on it are what limits it; the take function is really where the meaning lies: turning the thing off
12:29:46 <hololeap_> i just chrooted into a fresh install with the latest stage3-hardened-*.tar.bz2 ... running emerge --info, i get this error: http://lpaste.net/8757815470507163648
12:29:59 <dminuoso> crucify_me: turning the thing off?
12:30:26 <crucify_me> said half-jokingly to use language of an auto mechanic :)
12:30:45 <hololeap_> some of the config files are not "fresh", but i commented out nearly everything in bashrc and make.conf, and this is still happening
12:30:54 <dminuoso> crucify_me: expand `take 3 [1..]` - seriously. There's no way you can explain how this works by copying
12:31:05 <hololeap_> wrong channel...
12:31:13 <dminuoso> crucify_me: This might give you a better intuition.
12:31:45 <crucify_me> you get take (1 - 1) after 3 recursions, which returns the empty set
12:31:58 <crucify_me> thats the termination
12:33:00 <dminuoso> crucify_me: Okay great. And then? :-)
12:33:13 <dminuoso> Keep in mind that [1..] gives you an infinite list of incrementing numbers.
12:35:10 <Ariakenom> Hey, back tick fixity? x `f` y `f` x = x`` (y `` z)
12:35:22 <Ariakenom> Hey, back tick fixity? x `f` y `f` x = x `f` (y `f` z)
12:35:57 <dminuoso> Ariakenom: infixl 9
12:36:12 <dminuoso> Unless otherwise specified.
12:36:39 <Ariakenom> oh right, can be specified, thanks
12:36:55 <crucify_me> its not about the infinite list. its more about take. we wouldn't be limited to [1..] for take's 2nd argument
12:37:41 <crucify_me> [1..] is just providing a number bigger than 1000
12:37:55 <fishythefish> er, what
12:38:01 <fishythefish> [1..] is providing an infinite list
12:38:53 <crucify_me> I know, but I just mean take 3 is what we're interested in. 
12:39:03 <dminuoso> crucify_me: yes but on an infinite list.
12:39:18 <fishythefish> (where did 1000 come from?)
12:40:37 <crucify_me> I just meant large number, I should have said 100,000,000. but I don't know why the infinite list has meaning in haskell or programming.
12:41:19 <crucify_me> at this stage, I'm just slicing off 3 from a list of natural numbers or integers
12:42:05 <crucify_me> all it means to me at this stage is, "here's how recursion works"
12:42:36 <crucify_me> and "how the empty list terminates a program"
12:42:53 <dminuoso> crucify_me: The point of the excercise is to give you something that cannot be copied.
12:43:06 <dminuoso> Because its infinite, it cannot be copied in.. reasonable time. :-P
12:43:44 <crucify_me> right, were just returning a new list: [1,2,3]
12:44:46 <crucify_me> but generally the unification of types is very cool. I want to master that
12:45:07 <crucify_me> thanks for the help ALL
13:01:21 <daey> http://dpaste.com/225R36J why does this function causes more errors than i can count? I thought a ByteString would be parsed byte by byte. is that not so?
13:02:33 <mud> daey: A ByteString is not just [Word8] or anything, you'd have to unpack it for that. Or more likely you should use functions specialized to ByteString.
13:02:45 <mud> You can't really use pattern matches though like that, they're not lists.
13:05:04 <infinisil> Um, why does this give me a syntax error:
13:05:06 <infinisil> doPlacement game state player (MkPlacement { f_position = p, f_stats = s }) =
13:05:12 <daey> mud: ty
13:05:39 <infinisil> On the first "=" I get a parse error
13:07:15 <infinisil> Oh lol
13:07:43 <infinisil> The method above had a syntax error, i didn't finish writing it
13:09:04 <Cale> infinisil: Ah, good, I was about to say that looks all right
13:23:52 <larsvm> does someone here know how the library hmatrix is supposed to work?
13:25:34 <larsvm> and do i understand correctly, the haskell type system is supposed to prevent segfaults? or are there kinds of segfaults that the type system doesnt catch?
13:27:56 <erisco> you won't segfault unless you use unsafe functions incorrectly, typically having "unsafe" in the name
13:28:48 <larsvm> because running a = col [1,2,3]; b = col [1..]; a + b    ends up in a segfault
13:29:12 <erisco> what is col?
13:29:39 <larsvm> it makes a 1xn matrix of given list
13:29:50 <larsvm> https://hackage.haskell.org/package/hmatrix-0.18.1.0/docs/Numeric-LinearAlgebra-Data.html
13:31:04 <glguy> col [1..] is probably a pretty big vector
13:31:19 <jle`> larsvm: the Static module has extra types to try to catch some errors in matrix/vector size mismatches
13:31:43 <larsvm> so the size mismatches are not always caught?
13:31:48 <infinisil> Man, why is Data.Matrix 1-indexed :(
13:31:50 <jle`> they are caught only in the Static module
13:31:55 <jle`> at compile-time
13:32:09 <jle`> the not-unsafe functions in the normal API are caught at runtime though usually
13:32:10 <larsvm> infinisil: because mathematicians like 1-indexing :(
13:32:19 <jle`> your problem is that you made an infinitely log vector
13:32:28 <latro`a> I don't, hate that matlab uses it
13:32:29 <jle`> if it doesn't segfault, it would otherwise just destroy your memory
13:32:38 <larsvm> oh, i thought the excess would be discarded
13:32:41 <latro`a> very annoying to deal with things like periodic boundary conditions in 1-indexing
13:32:46 <larsvm> thank you
13:33:08 <jle`> larsvm: vectors need to be stored in contiguous parts in memory, so it must be allocated first
13:33:31 <latro`a> if it is to be evaluated at all, of course
13:33:50 <erisco> I wonder why it is a segfault and not out of memory exception
13:34:00 <erisco> or just your system dying
13:34:22 <latro`a> presumably the malloc refuses
13:34:22 <larsvm> jle`: what about the laziness? when evaluating the `+` why are the extra elements dropped when the first vector runs out?
13:34:22 <erisco> that sounds like a bug to me
13:34:29 <erisco> the malloc refuses what?
13:34:39 <latro`a> the malloc inside vector refuses to do what you ask for
13:34:41 <erisco> and segfault is not a way to refuse things
13:35:01 <erisco> what is the implementation trying to malloc?
13:35:04 <latro`a> if you ask malloc to allocate more than the OS will give it?
13:35:14 <mud> You could get a segfault if you don't check what malloc returns maybe, but it's not inherent.
13:35:23 <erisco> then malloc returns an error code
13:35:31 <glguy> I'd be surprised if the code finished computing the length of [1..]
13:35:37 <glguy> and ever got to the point of mallocing anything
13:35:40 <larsvm> so this might be a bug?
13:35:59 <latro`a> it's not a bug anyway, to use col [1..] you'd need to allocate the whole thing up front which you can't do
13:36:06 <latro`a> what's odd is that the way it breaks is by segfault
13:36:14 <glguy> larsvm: Yeah, it's a bug to write: col [1..]
13:36:23 <larsvm> :P
13:36:26 <erisco> no, segfault is really not a good thing
13:36:26 <erisco> that is not a way you indicate failure
13:36:26 <erisco> that is a way you introduce security bugs
13:36:34 <mud> Depends a bit what hmatrix thinks should happen in that case. It certainly can't complete, but how it should fail is a bit of an API question.
13:36:44 <mud> I'd argue it's at least bad API
13:36:50 <glguy> erisco: We don't know that it actually segfaulted or any other specifics about the failure mode
13:37:04 <erisco> we don't? we were told it segfaulted
13:37:21 <latro`a> it could say segmentation fault for any number of internal reasons, though that would be *really* bad error message design
13:37:31 <glguy> without seeing some actual copied error message I assume people use that the same way when they say "it crashed"
13:37:47 <erisco> oh… then pics or didn't happen
13:37:52 <larsvm> [1]    7797 segmentation fault (core dumped)  stack ghci
13:37:57 <larsvm> this is the output
13:38:46 <glguy> See, now I believe that that's the error message
13:39:06 <erisco> I really don't want to experiment reproducing this error… lol
13:39:24 <larsvm> yea it made my computer hang for about 2 minutes
13:39:28 <fishythefish> nit: that segfault is coming from the ghci process; you might want to also run it as a binary
13:40:18 <erisco> also try just really big numbers, not necessarily an infinite list, and see if that changes anything
13:40:46 <erisco> [1..maxBound :: Int] or w/e
13:41:27 <glguy> 2 minutes isn't enough to generate the list [1 :: Double ..]
13:41:31 <larsvm> i dont really want do :D
13:41:35 <glguy> so your GHCi just ran out of memory
13:42:09 <larsvm> is ghci supposed to fail like that?
13:42:19 <larsvm> i mean ending in a segfault
13:43:31 <glguy> > take 10 [1/0 ..]
13:43:33 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
13:45:08 <glguy> > take 10 [2^53-1 :: Double .. ]
13:45:10 <lambdabot>  [9.007199254740991e15,9.007199254740992e15,9.007199254740992e15,9.0071992547...
13:45:16 <glguy> Actually , it gets stuck sooner than infinity :)
13:45:46 <erisco> one epsilon, two epsilon, three epsilon…
13:52:36 <cheater> erisco: if you have 2-3 languages (a compiles down to b down to c) and you can edit either intermediate representation and go back up (eg from c back to a) without loss of metadata, would that be a good way to do the "zoom" part you were talking about earlier?
13:54:36 <erisco> that may be an idea for editing different projections of a program, but by zooming the goal is to increase or decrease the amount of information I am seeing
13:54:52 * hackage pretty-show 1.6.14 - Tools for working with derived `Show` instances and genericinspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.14 (IavorDiatchki)
13:55:13 <erisco> actually I should say "detail" and not "information", because that may remain the same
13:55:39 <erisco> but if your compilation is reversible then you've kept all the detail, and so that is not the same thing
13:56:11 <erisco> think of example how in IDEs you can explore a file by a list of definitions in that file
13:56:26 <Younder> erisco, if a compilation is reversible what is the point. It might as well be interpreted.
13:56:36 <erisco> this is less detail than the whole text of the file because you're just seeing the names and possibly type signature of definition
13:57:13 <erisco> you can edit this, by say deleting a definition, or adding a definition
13:57:39 <erisco> it is up to you what editing a less detailed perspective means for the higher detailed perspectives
13:59:13 <erisco> currently, the process of planning and specifying a program is outside of the language of implementation, and I might look how to bring it in
13:59:31 <erisco> I have seen some experiments in this area but it needs more work
14:00:07 <Younder> All of types go away during compilation. Not sure that is a good idea, but they do. You are left with lambda calculus.
14:00:09 <erisco> if you think about it, the planning and specifying you do before writing an application is the sort of less detailed perspective you want to maintain
14:02:23 <Younder> Seriously debugging Haskell is different. No single step, no in run view of data structures. So it is all up to printing and command loops.
14:03:12 <daey> no need for singlestep if you dont even know where to start :D
14:04:16 <dminuoso> Every time I tried to single step into programs, ghci seg faulted..
14:04:37 <dminuoso> Though in 8.2 that problem appears to be gone, but thats no good for the 8.0 lts :(
14:12:49 <daey> vim doesnt seem to like {- -} comments~
14:13:12 <lyxia> what about them
14:13:38 <daey> the highlighting doesnt work properly. sometimes it does, sometimes only the first line is differently colored :P
14:14:05 <Tuplanolla> Might want to increase your highlight context length, daey.
14:14:31 <Tuplanolla> Vim doesn't parse the whole file.
14:14:47 <daey> if that was the issue then i doubt rewriting the initial {- would fix the problem :p
14:15:05 <daey> its 5 lines~
14:15:06 <mud> daey: https://github.com/neovimhaskell/haskell-vim seemed to improve my syntax highlighting quite a bit, but I don't know if I noticed that problem.
14:15:18 <mud> (and the indenting)
14:15:53 <daey> always wanted to try neovim~
14:16:05 <mud> I think it works in normal vim too
14:16:21 <daey> possibly
14:16:36 <daey> btw. how do you do space indents? does your tab do X spaces?
14:17:08 <mud> Yeah
14:17:48 <daey> and deleting 4 spaces is 4 times backspace?
14:18:08 <daey> i mean theres 'dw' but im not sure thats always appropriate for that~
14:18:19 <mud> Naw, backspace takes care of a tabstop worth or something
14:22:24 <mud> daey: I don't even know what 1/2 of my vimrc does anymore, would a copy help though?
14:23:35 <daey> nah, i dont want to completely change mine
14:23:44 <dmwit> daey: If you want a dissenting opinion, http://dmwit.com/tabs details my vim settings for tabs and rationale.
14:24:18 <dmwit> daey: But usually (for projects where I'm working with other people) I just use :set ai pi et sts=4 sw=4 ts=4
14:25:44 <glguy> Tabs are nsfw
14:25:56 <mud> I find that kind of compelling, except then you have to trust everyone you work with to actually do that correctly ^. Also ... doesn't GHC just plain warn about tabs in general?
14:25:56 * Clint golfclaps
14:26:31 <dmwit> daey: ...oh, and I forgot :set ci
14:26:38 <dmwit> mud: -fno-warn-tabs
14:26:55 <mud> dmwit: Ew
14:27:00 <mud> ;)
14:27:07 <dmwit> I know. I get that a lot. =)
14:27:32 <dmwit> I have no answer for "I find tabs bad aesthetically" and I don't think there can be one.
14:27:45 <zachk> :t lift
14:27:46 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:28:10 <zachk> which module is "lift" located in the new mtl ordering?
14:28:50 <dmwit> ?index lift
14:28:50 <lambdabot> Text.ParserCombinators.ReadPrec, Text.Read, Language.Haskell.TH.Syntax, Control.Monad.Trans.Class
14:29:03 <dmwit> Those results are the worst.
14:29:09 <dmwit> ?hoogle lift
14:29:09 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
14:29:09 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
14:29:09 <lambdabot> Data.Vector.Fusion.Bundle lift :: Monad m => Bundle v a -> Bundle m v a
14:29:28 <dmwit> 2 out of 2 \bot plugins agree: Control.Monad.Trans.Class
14:29:28 <zachk> I am trying Control.Monad.Trans.Class but it doesn't seem to be in the new mtl for me at least
14:30:07 <dmwit> Perhaps you have forgotten to add transformers to your dependencies.
14:30:11 <dmwit> (C.M.T.Class is not in mtl.)
14:30:37 <zachk> yeap
14:30:50 <dmwit> We don't have a lambdabot plugin for the module -> package mapping, I don't think.
14:31:05 <dmwit> I think cabal has a tool for that, maybe?
14:33:17 <dmwit> well
14:33:21 <glguy> You can do module to package mapping for packages you already have installed with: ghc-pkg find-module
14:33:22 <dmwit> ?hoogle Control.Monad.Trans.Class
14:33:22 <lambdabot> module Control.Monad.Trans.Class
14:33:22 <lambdabot> module Rebase.Control.Monad.Trans.Class
14:33:22 <lambdabot> module Control.Monad.Trans.MultiReader.Class
14:33:40 <dmwit> The web UI also lists the package name for each module result.
14:54:04 <orion> ocharles: Hi. Do your original motivations for creating monad-effect still apply?
14:55:18 <orion> Specifically here: https://www.reddit.com/r/haskell/comments/41rgix/ann_loggingeffect_a_new_mtlstyle_monad/cz4k1ia
15:00:25 <numberten> is there a function like sequence but within the context of a tuple? i.e. [(a, m b)] -> m [(a, b)]
15:00:46 <numberten> hoogle doesn't have anything, but I'm thinking maybe that's just a simple composition that escapes me?
15:01:26 <erisco> implement  [(a, m b)] -> [m (a, b)]
15:01:30 <lyxia> > (sequence . sequence) ([(0, Just 1)] :: [(Int, Maybe Int)]) :: Maybe [(Int, Int)]
15:01:32 <lambdabot>  error:
15:01:32 <lambdabot>      • Couldn't match type ‘[]’ with ‘Maybe’
15:01:32 <lambdabot>        Expected type: Maybe [(Int, Int)]
15:01:36 <lyxia> darn
15:02:03 <lyxia> > traverse sequence ([(0, Just 1)] :: [(Int, Maybe Int)]) :: Maybe [(Int, Int)]
15:02:05 <lambdabot>  Just [(0,1)]
15:02:46 <lyxia> numberten: sequence works on tuples, for better and for worse
15:02:58 <numberten> ah
15:03:17 <numberten> alright thanks
16:41:35 <ttoe> hi. is there a way to reduce this, so i dont have to use a 'where'? ... kcu = kcu' basePars    where kcu' Par{..} = kmax - a*pu
16:42:00 <ttoe> kmax, a, pu are in basePars :: Par
16:42:43 <dmwit> kcu = kmax - a*pu where Par{..} = basePars
16:42:47 <ttoe> which is like data Par = Par { <all the parameters> }
16:42:48 <dmwit> Still has a where, but is a bit shorter.
16:43:05 <dmwit> You can also use let, but that seems about the same to me.
16:43:09 <ClaudiusMaximus> kcu = let Par{..} = basePars in kmax - a * pu  -- if you prefer let to where
16:44:29 <dmwit> Hm, `kcu | Par{..} <- basePars = kmax - a*pu` might work with enough extensions. =P
16:45:24 <ttoe> :D thanks, that's already nicer because it doesn't need this intermediate function
16:45:39 <hpc> dmwit: ViewPatterns, PatternGuards, RecordWildcards
16:45:41 <hpc> or something like that
16:45:59 <hpc> i forget what all the record-based extensions do
16:46:26 <johnw> the first two have nothing to do with records :)
16:46:46 <hpc> they give you the guard bits
16:46:54 <dmwit> hpc: Just the last two seem to be enough in my tests.
16:47:23 <hpc> dmwit: huh
16:47:31 <dmwit> But I think the `where` version is better (clearer) than the pattern guards version.
16:47:56 <dmwit> hpc: Also apparently the c of cards is capitalized.
16:48:01 <hpc> oh, i guess all pattern guards have to be shaped like view patterns
16:48:47 <dmwit> It was tough to spot what had gone wrong in the error message. "Dunno what RecordWildcards is, perhaps you meant RecordWildCards."
16:48:50 <dmwit> uh... yes?
16:49:11 <hpc> you actually meant IncoherentInstances
16:49:21 <hpc> the keys are right next to each other
16:53:05 <lyxia> How many forks/reimplemenntations of freer are there
16:54:05 <lyxia> I count 5 so far...
17:27:50 <johnw> lyxia: is free from being pinned down to one implementation
17:28:00 <johnw> i'm waiting for freest
17:43:08 <hs_newb> hello, what function would give (Eq a, Eq b) => (a->b) -> (a->a->Bool) -> (b->b->Bool)
17:44:05 <hs_newb> i.e. i want to apply a function f to both arguments of another function 
17:44:24 <erisco> that is not implementable
17:44:48 <c_wraith> eh? that type has a bunch of implementations
17:45:02 <erisco> (a -> b) -> (b -> b -> Bool) -> (a -> a -> Bool)  perhaps
17:45:33 <c_wraith> const (const (==)), for instance
17:45:44 <erisco> it is not implementable with that specification
17:46:15 <bor0> fun f a_cmp b_cmp x y = a_cmp x y == b_cmp (f x) (f y)?
17:46:53 <bor0> :t const (const (==))
17:46:55 <lambdabot> Eq a => b1 -> b2 -> a -> a -> Bool
17:47:00 <erisco> hs_newb, this function goes by the name of Data.Function.on
17:49:33 <hs_newb> :t (\x y f -> f x == f y)
17:49:34 <lambdabot> Eq a => t -> t -> (t -> a) -> Bool
17:50:04 <hs_newb> is there a nice way to write this with (==) and f for Eq t and Eq a
17:50:20 <c_wraith> yes, listen to erisco
17:51:18 <hs_newb> erisco: thanks 
17:51:30 <c_wraith> hs_newb, but why do you think Eq t is relevant?
17:51:54 <hs_newb> no it isn't :)
18:20:17 <wedify> so running 'stack install sdl2-mixer' fails with errors so i downloaded the git repo and built that. it builds fine with 'stack build' but running 'stack install' doesn't seem to install it
18:22:24 <geekosaur> "stack install" istalls programs
18:22:29 <geekosaur> sdl2-mixer is library only
18:23:08 <geekosaur> as for libraries, the point of stack is that it decides which projects can see what versions of what libraries; installing a library overrides that and prevents stack from preventing conflicts
18:23:56 <geekosaur> if you actually need that library to be installed in a way other than visibility explicitly managed by stack, then do not use stack to install it
18:26:26 <geekosaur> also, given that you installed it manually instead of from a resolver, if you want other stack projects to see it you must list it in extra-deps
18:26:32 <geekosaur> for those projects
18:27:37 <geekosaur> again, this is because stack hides anything not either in the specified resolver or listed in extra-deps, to avoid conflicts (because if ghc can see it directly, it can decide to use it without being told)
18:30:53 * hackage ListT 0.1.0.0 - List transformer  https://hackage.haskell.org/package/ListT-0.1.0.0 (MatthewFarkasDyck)
18:55:22 * hackage tls-session-manager 0.0.0.2 - In-memory TLS session manager  https://hackage.haskell.org/package/tls-session-manager-0.0.0.2 (KazuYamamoto)
19:08:09 <wedify> i'm getting a lot of 'there are files missing in the <x> package' errors. i've tried 'sudo ghc-pkg recache' and installing ghc-static but the errors persist.
19:11:10 <geekosaur> aside from trying to reinstall the ghc package, I don't know of any other way to fix it
19:11:17 <geekosaur> (arch--)
19:12:22 <wedify> yeah i reinstalled ghc too. didn't help
19:16:54 <geekosaur> unless this is latest stack (released today) in which case you might possibly have an issue there, since stack was changed to prefer installing its own
19:17:29 <geekosaur> (you might see if --system-ghc helps in that case)
19:24:15 <lyxia> wedify: try wiping out the packages installed by stack
19:49:06 <wedify> ok i've done 'pacman -Rs xmonad ghc-static stack'. i've also removed ~/.cabal ~/.stack ~/.ghc. then i reinstalled with 'pacman -S xmonad ghc-static stack'
19:58:43 <wedify> ok i've figured it out. i had to enable a bunch of dynamic linking options in my .cabal/config
20:03:45 <Welkin> wedify: what are you trying to do?
20:03:56 <Welkin> is this an arch problem?
20:05:59 <wedify> Welkin: i'm trying to update haskanoid to work with modern libraries. the sdl2-mixer in stack won't install without errors so i tried to build it from the git repo. 
20:06:14 <Welkin> haskanoid?
20:06:24 <wedify> it's a game using the yampa library
20:08:57 <geekosaur> wedify, sounds like you have arch libraries installed instead of cabal/stack. yes, you need to force every build dynamic *or* get rid of the system libs (anything not from ghc or ghc-static)
20:09:10 <geekosaur> and reinstall those via stack or cabal
20:15:32 <wedify> geekosaur: thanks for the help
20:42:52 * hackage mmark 0.0.2.0 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.2.0 (mrkkrp)
20:47:04 <dmj`> aoc time
20:59:44 <Average-user> glguy: Ready?
21:09:10 <glguy> Average-user: yeah, finished in 6:36
21:09:51 <HaskellLord69> lol
21:09:59 <HaskellLord69> how are you so fast
21:10:25 <glguy> Not fast enough, apparently. That put me in the middle of the leaderboard
21:10:30 <HaskellLord69> dang
21:16:03 <jle`> did worse than yesterday for me :'(
21:17:35 <jle`> is there no safe maximum
21:17:48 <glguy> :t maximumOf folded
21:17:49 <lambdabot> (Foldable f, Ord a) => f a -> Maybe a
21:18:45 <jle`> ty
21:24:16 <ongy> :t folded
21:24:18 <lambdabot> (Applicative f1, Foldable f2, Contravariant f1, Indexable Int p) => p a (f1 a) -> f2 a -> f1 (f2 a)
21:24:30 <glguy> folded :: Foldable f => IndexedFold Int (f a) a
21:26:31 <jle`> the magic is maximumBy
21:26:35 <jle`> *maximumOf
21:26:44 <jle`> folded could be anything that looks at all the items
21:26:51 <jle`> :t maximumOf traverse
21:26:52 <lambdabot> (Traversable t, Ord a) => t a -> Maybe a
21:27:04 <glguy> > maximumOf each (10,30,20)
21:27:06 <lambdabot>  Just 30
21:28:40 <jle`> today and yesterday were especialyl well-suited for haskell
21:30:16 <cocreature> jle`: I love how part 2 involved basically just changing foldl to scanl
21:30:41 <glguy> cocreature: i-know-right??
21:32:06 <glguy> I wonder if in a language like Ruby if you could just define about inc and dec and have the rest of the file be valid syntax 
21:32:12 <jle`> hahaha
21:32:45 <glguy> In Agda it might be doable thanks to mixfix
21:33:23 <glguy> or a quick regexp for inc -> += and dec to -=
21:34:48 <jle`> :t maximumOf (folded . folded)
21:34:49 <lambdabot> (Foldable f2, Foldable f1, Ord a) => f1 (f2 a) -> Maybe a
21:35:05 <jle`>  :: [Map String Int] -> Maybe Int
21:35:34 <Average-user> I know a haskeller that it doing it on Ruby
21:35:51 <Average-user> it is *
21:36:21 <nshepper1> foldMap (foldMap Max)
21:36:46 <glguy> :t Data.Monoid.Max
21:36:48 <lambdabot> error:
21:36:48 <lambdabot>     Not in scope: data constructor ‘Data.Monoid.Max’
21:36:48 <lambdabot>     Perhaps you meant one of these:
21:37:25 <nshepper1> apparently Max is in Data.Semigroup now
21:37:30 <glguy> :t Data.Semigroup.Max
21:37:31 <lambdabot> a -> Data.Semigroup.Max a
21:38:19 <glguy> So for lists you might then need: Option . Just . Max
21:38:27 <nshepper1> > foldMap Max [] :: Int
21:38:29 <lambdabot>  error:
21:38:29 <lambdabot>      • Data constructor not in scope: Max :: a0 -> Int
21:38:29 <lambdabot>      • Perhaps you meant variable ‘max’ (imported from Data.Ord)
21:38:42 <nshepper1> > foldMap Data.Semigroup.Max [] :: Data.Semigroup.Max Int
21:38:44 <lambdabot>  error:
21:38:44 <lambdabot>      Not in scope: data constructor ‘Data.Semigroup.Max’
21:38:44 <lambdabot>      No module named ‘Data.Semigroup’ is imported.error:
21:38:56 <nshepper1> >:(
21:39:23 <glguy> Oh, gross, it uses minBound
21:39:28 <glguy> Prelude Data.Semigroup> foldMap Max [] :: Max Int
21:39:28 <glguy> Max {getMax = -9223372036854775808}
21:39:46 <nshepper1> sure does
21:40:09 <jle`> yeah i actually just tried it and was surprised it worked
21:40:17 <jle`> then i realized there was a Monoid instance
21:40:25 <nshepper1> is Option the thing that makes Maybe have the correct Monoid instance?
21:40:52 <jle`> :t getMax . (foldMap . foldMap) Max
21:40:53 <lambdabot> error: Variable not in scope: getMax :: b0 -> c
21:40:53 <lambdabot> error:
21:40:53 <lambdabot>     • Data constructor not in scope: Max :: a -> b0
21:40:57 <glguy> nshepper1: Yeah
21:41:04 <jle`> nshepper1: it depends on who you are asking
21:41:22 <glguy> Depends on if the person you're asking knows
21:41:23 <jle`> Option is Maybe with a more generic Monoid instance
21:41:33 <jle`> so it works for all Semigroup a's, and not just Monoid a's
21:42:56 <jle`> i'm still surprised foldl is in prelude and foldl' isn't
21:43:32 <mud> jle`: I always thought that was a pretty bizarre choice.
21:44:01 <jle`> also i love ViewPatterns it seems, I've used them for every puzzle so far more or less
21:44:08 <mud> IIRC sort isn't in Prelude either, which just seems kind of wacky to me compared to some other stuff in there.
21:44:22 <jle`> oh yeah that threw me off a few days ago
21:46:02 <wedify> i have sdl2-ttf listed as a dependency in the haskanoid.cabal file but when i build it says it can't find the interface for SDL.Font. any ideas what might be happening?
21:47:25 <cocreature> wedify: can you show us your cabal file?
21:47:30 <mud> wedify: Maybe you're getting a different version than you expected, and the modules changed?
21:48:12 <cocreature> in particular sdl2-ttf < 2.0 doesn’t seem to have that module
21:49:23 <cocreature> ahrg how is there a sdl2-tff and a SDL2-ttf package
21:49:33 <cocreature> hackage should really prevent that
21:50:29 <mud> Oo, wow that's awful.
21:51:25 <jle`> well i know my strategy the next time i want to do a hostile fork
21:52:23 <wedify> cocreature: thank you. had to add sdl2-ttf-2.0.2 to my extra-deps field
21:52:25 <mud> I kind of want to make copies of all of the acme-* libraries now with just all caps in both the names and the docs.
21:54:43 <jle`> cocreature: can i quote your foldl/scanl statement
21:55:12 <jle`> :t maximum . foldMap toList      -- my final way i'm settling with, i think
21:55:14 <lambdabot> error:
21:55:14 <lambdabot>     Ambiguous occurrence ‘toList’
21:55:14 <lambdabot>     It could refer to either ‘F.toList’,
21:55:17 <cocreature> jle`: sure
22:00:12 <vaibhavsagar> jle`: nice ViewPatterns parsing :)
22:00:32 <vaibhavsagar> I always reach for attoparsec in these situations
22:01:23 * hackage mono-traversable 1.0.5.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.5.0 (MichaelSnoyman)
22:01:24 <jle`> vaibhavsagar: yes i've been using ViewPatterns for all of my parsing for these haha
22:01:35 <jle`> i discovered how much I love them these past few days
22:02:52 <vaibhavsagar> I wonder how much computation you can push on to the pattern-matching step with ViewPatterns+PatternSynonyms
22:03:26 <jle`> i could definitely go overboard
22:03:37 <jle`> i actually do go way overboard in my first drafts of these programs but scale it back after a while
22:04:01 <vaibhavsagar> I think I go the other way
22:04:04 <glguy> Yeah, the initial "race" versions of these can be quite a disaster
22:04:09 <jle`> for example on Day 7 i had:
22:05:14 <jle`> parseLine (words->p:read->w:(S.fromList . map (filter isAlpha) . drop 1->cs)) = (p, (w,cs)
22:05:33 <jle`> originally
22:07:35 <vaibhavsagar> I didn't even know multiple viewpatterns were possible
22:07:48 <cocreature> I just wrote a megaparsec parser
22:08:24 <jle`> yes nested view patterns is where the fun starts :)
22:09:29 <vaibhavsagar> also what's the IDE/text editor setup everyone is using?
22:09:45 <Xal> emacs with ghc-mod
22:10:02 <glguy> macvim with syntax highlighting
22:10:09 <vaibhavsagar> I've been using IHaskell notebooks because I'm very comfortable with them, even though I think there's a speed penalty associated with using it
22:10:10 <cocreature> emacs with intero
22:10:49 <vaibhavsagar> glguy, do you have ghcid or something like that running?
22:11:02 <glguy> I have ghci running
22:11:49 <vaibhavsagar> fair enough :)
22:12:39 <jle`> vaibhavsagar: vim with all the haskelly vim stuff
22:12:46 <jle`> and tmux with multiple panes
22:13:44 <glguy> oh, my vim is also special because I fixed up the syntax file beyond what you get from stock vim :)
22:15:13 <vaibhavsagar> what is the most significant difference?
22:15:18 * vaibhavsagar takes notes
22:16:00 <jle`> my AoC implementation is surprisingly slow, ~9ms for both parts
22:16:16 <jle`> s/both/each
22:16:46 <vaibhavsagar> that's interesting that there's basically no difference between using foldl and scanl
22:16:59 <glguy> https://glguy.net/haskell.vim There were some language changes since 98, some string literal stuff that changed, you can have spaaces in backticked identifiers: ` example ` , stuff like that
22:18:12 <jle`> vaibhavsagar: yeah, it's around 8.5ms vs. 9.5ms
22:18:28 <Average-user> Todays Puzzle was easy on Prolog, apart from formating the input.
22:18:29 <saurabhnanda> there was a library released in the recent past to write assertions/tests on generated core itself. Does anyone remember the name of the library?
22:18:54 <vaibhavsagar> cool, thanks glguy! I thought it might be too much to hope for that you have it online :)
22:19:13 <vaibhavsagar> saurabhnanda: something by joachim breitner?
22:19:14 <Average-user> glguy: I think in Haskell 98 it was possible to do. 'dec (x+1) = x'
22:19:30 <cocreature> saurabhnanda: inspection-testing?
22:19:48 <glguy> yeah, those are n plus k patterns
22:20:35 <Average-user> glguy: I would like to have them now, I think I'm still attach  to mathematics  
22:21:20 <vaibhavsagar> Average-user: I think you can emulate them with ViewPatterns
22:21:52 <jle`> Average-user: they were taken out because they were a bad idea :o
22:21:59 <saurabhnanda> cocreature: yes, that one. Thanks!
22:22:11 <Average-user> jle`: Yhea don't surprise me
22:22:22 <rightfold> Average-user: {-# LANGUAGE NPlusKPatterns #-}
22:22:26 <glguy> They're still in GHC
22:22:30 <glguy> You just need to turn them on
22:22:34 <rightfold> They’re kinda weird
22:22:36 <Average-user> Really?
22:22:38 <rightfold> They don’t go below zero
22:22:38 <Average-user> Cool
22:23:08 <rightfold> People find it confusing anyway
22:23:37 <rightfold> (5 + n), then n being the value minus 5, is very unintuitive
22:23:40 <Average-user> It worked !! Thanks guys
22:24:07 <Average-user> I supposed that they had been forgotten in the past
22:24:46 <rightfold> It’s a bit like list comprehensions. “What does this syntax mean? 🤔” *squints eyes* “Ooh, right! That exists!”
22:24:48 <Average-user> Fucking Internet
22:25:42 <srk> yeah, broken here as well
22:31:20 <nhan2> What's the * in this?
22:31:24 <nhan2> class Functor f => Applicative (f :: * -> *) where
22:31:24 <nhan2>   pure :: a -> f a
22:32:08 <glguy> * is the kind of types that can have values
22:32:39 <nhan2> where is * defined? 
22:32:46 <nhan2> thank you glguy
22:33:34 <cocreature> it’s not defined, it’s built into ghc
22:35:16 <xacktm> yay, I remembered to flip (-) for this AoC day
22:35:27 <glguy> subtract!
22:35:43 <nhan2> But when I do this is ghci, class F2 f => A2 (f :: * -> *) where pure :: a->f a
22:36:05 <xacktm> oh yeah sorry, I'll note in the future :)
22:36:14 <nhan2> <interactive>:104:24: error:
22:36:14 <nhan2>     Illegal kind signature: ‘* -> *’
22:36:14 <nhan2>       Perhaps you intended to use KindSignatures
22:36:14 <nhan2>     In the declaration for class ‘A2’
22:36:24 <rightfold> To use it in GHCi you need :set -XKindSignatures like the error message says
22:36:34 <nhan2> ahh,
22:36:38 <nhan2> thanks
22:36:44 <rightfold> It’s a language extension for some reason
22:37:18 <rightfold> A kind is the type of a type. Like 42 is of type Int, Int is of kind *. And like (+) is of type Int -> Int -> Int, Maybe is of kind * -> *
22:38:13 <jle`> nhan2: it's basically a way for us to say that instances of Applicative are things like Maybe, IO, Either String, etc.
22:38:20 <jle`> nhan2: and not Int, Either, (->), Bool
22:38:24 <rightfold> Likewise, a sort is the type of a kind. * has sort BOX.
22:38:31 <rightfold> It’s turtles all the way up.
22:39:36 <nhan2> I will read about it. Thank you. 
22:39:48 <cocreature> except if you enable TypeInType then * has sort * :)
22:39:59 <rightfold> Ew!
22:41:14 <rightfold> Hilbert would be proud.
22:54:14 <lyriclaw_> ／join algorithms
22:56:51 <nshepper1> TypeInType is so lovely
22:57:57 <rightfold> lyriclaw_: wrong slash!
23:05:53 * hackage yesod-auth 1.4.21 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.21 (MichaelSnoyman)
23:05:56 <xintron> What's a neat way of creating an infinite list resulting in [1,1,2,2,3..]?
23:06:30 <cocreature> > concatMap (\i -> [i,i]) [1..]
23:06:32 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:07:25 <jle`> > cycle [1,1,2,2,3]
23:07:26 <lambdabot>  [1,1,2,2,3,1,1,2,2,3,1,1,2,2,3,1,1,2,2,3,1,1,2,2,3,1,1,2,2,3,1,1,2,2,3,1,1,2...
23:07:36 <xintron> Ah, neat. I was looking at the following
23:07:42 <xintron> > replicate 2 =<< [1..]
23:07:44 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:08:12 <jle`> that's essentially what cocreature wrote 
23:08:23 <jle`> concatMap = (=<<)
23:08:32 <jle`> replicate 2 = (\i -> [i,i])
23:09:37 <rightfold> > let xs = 1 : 1 : map (+1) xs in xs
23:09:44 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:10:59 <rightfold> Explicit recursion, what could *possibly* go wrong!
23:11:44 <jle`> > fix ((1:) . (1:) . map (+1))
23:11:47 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:12:05 <jle`> > fix ([1,1] ++ map (+1))     -- i suppose
23:12:07 <lambdabot>  error:
23:12:07 <lambdabot>      • Couldn't match expected type ‘a -> a’
23:12:07 <lambdabot>                    with actual type ‘[Integer]’
23:12:20 <jle`> > fix (([1,1] ++) . map (+1))
23:12:23 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:15:40 <rightfold> > let löb xs = go where go = map ($ go) xs in löb $ [const 1, const 1] ++ map (\n xs -> (xs !! n) + div n 2) [0 ..]
23:15:42 <lambdabot>  [1,1,1,1,2,2,4,4,7,7,11,11,16,16,22,22,29,29,37,37,46,46,56,56,67,67,79,79,9...
23:15:45 <rightfold> Close enough
23:17:03 <rightfold> The distance between the numbers increases by one each time
23:17:36 <jle`> > floor <$> [1.0, 1.5 ..]
23:17:38 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:17:55 <jle`> it might diverge after a while
23:18:35 <rightfold> > drop 100000 $ floor <$> [1.0, 1.5 ..]
23:18:37 <lambdabot>  [50001,50001,50002,50002,50003,50003,50004,50004,50005,50005,50006,50006,500...
23:19:09 <jle`> > find (\(x,y) -> x /= y) (floor <$> [1.0,1.5..]) (replicate 2 =<< [1..])
23:19:11 <lambdabot>  error:
23:19:11 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
23:19:11 <lambdabot>                    with actual type ‘Maybe ((), ())’
23:19:18 <rightfold> > drop 1000000000 $ floor <$> [1.0, 1.5 ..]
23:19:23 <lambdabot>  mueval-core: Time limit exceeded
23:19:25 <jle`> > find (\(x,y) -> x /= y) $ zip (floor <$> [1.0,1.5..]) (replicate 2 =<< [1..])
23:19:31 <lambdabot>  mueval-core: Time limit exceeded
23:19:32 <rightfold> Slow ripoff
23:19:41 <jle`> time to -O2
23:20:16 <rightfold> lambdabot needs a catchphrase
23:20:25 <jle`> > find (\(x,y) -> x /= y) . drop 1000000 $ zip (floor <$> [1.0,1.5..]) (replicate 2 =<< [1..])
23:20:31 <lambdabot>  mueval-core: Time limit exceeded
23:20:55 <jle`> i guess Double is pretty stable
23:22:43 <cocreature> jle`: 2^53 turns out to be quite large :)
23:23:32 <fakenullie> it should diverge before
23:23:57 <cocreature> oh right, I’m stupid
23:24:12 <rightfold> Are there languages that reject inexact float literals?
23:24:15 <cocreature> 2^52? it’s too early for ieee754
23:24:23 <rightfold> So you couldn’t write 0.1.
23:24:29 <jle`> > floor . logBase 2 . sqrt <$> fix ((4:) . map (*2))
23:24:31 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:26:30 <fakenullie> > (1.5 :: Double) `approxRational` 0
23:26:34 <lambdabot>  3 % 2
23:26:50 <osa1> anyone know how do INLINE annotations work when added to typeclass methods? if I put INLINEs to typeclass methods would that apply to all implementations?
23:27:01 <fakenullie> maybe 1.5 is exact
23:27:23 <jle`> > (<$ [(),()]) =<< [1..]
23:27:25 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:27:25 <cocreature> fakenullie: all integers until 2^53 are exact so I think all multiples of 1/2 should be exact until 2^52
23:27:36 <jle`> submarine operator
23:28:49 <fakenullie> cocreature: it should be 3 / (2^1)
23:29:16 <fakenullie> but ritght, all multiples of 1/2 should be
23:31:23 <glguy> osa1: no, it wouldn't apply to all
23:32:55 <osa1> thanks
23:34:08 <platz> switching from 'read :: String -> Int' to 'ByteString.Char8.readInt' shaved off 10ms and a bunch of allocation on aoc day8
23:34:19 <jle`> nice
23:34:21 <rightfold> > toListOf (traverse . both) . join zip $ [1 ..]
23:34:23 <lambdabot>  [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,...
23:34:34 <platz> will be avoiding read from now on i gues
23:34:45 <jle`> platz: but also using ByteString.Char8 would leave anyone feeling gross
23:34:54 <platz> hah, true
23:35:30 <jle`> wait my version with read was < 10ms total
23:35:47 <jle`> oh
23:35:50 <jle`> we probably have different inputs
23:36:31 <jle`> also different computers
23:37:10 <jle`> and maybe different spacetime geodesics
23:38:45 <pimlu> does anyone else get a non working ip from dns for hackage.haskell.org? I get Name:	j.global-ssl.fastly.net Address: 151.101.200.68
23:39:00 <platz> yeah i was between 10ms and 20ms before, now around 3ms
23:39:09 <pimlu> I fixed it by manually changing it to 151.101.48.68 in hosts
23:39:24 <pimlu> it could just be my university dns, but they rarely break individual sites
23:39:32 <fakenullie> how does it not work?
23:39:47 <pimlu> dns lookup works, ip doesn't respond
23:39:53 <fakenullie> 151.101.200.68 seems to serve something
23:40:20 <fakenullie> need to use Host header to check
23:40:54 <jle`> oh interesting consequence of laziness for AoC8
23:40:56 <cocreature> while I don’t get the IP from "dig" it does work
23:41:26 <jle`> if your predicate tests as false, you don't have to 'read' the update amount or parse the update direction
23:41:34 <fakenullie> pimlu: this ip works
23:41:45 <jle`> so it's not parsed potentially
23:42:38 <jle`> i discovered this when i found that adding strictness annotations made things slower
23:42:52 <platz> oh i hadn't thought of that. interesting
23:43:55 <pimlu> fakenullie: hm. maybe I'll make a ticket with my uni
