00:02:32 <[Leary]> Cheers glguy, I'll look into it.
00:04:40 <solidus-river> hey all, what editor do you use while coding in haskell?
00:04:53 <dysfun> emacs
00:06:03 <keodedad> atom
00:07:00 <liste> solidus-river: vim
00:09:00 <boj> kakoune
00:11:50 <tdammers> solidus-river: I use vim, but the nice thing about Haskell IMO is that editor choice is relatively unimportant, because much of what you'd normally use IDE features for in a mainstream language is part of Haskell itself
00:12:16 <tdammers> or you can easily get the same results through type-driven or compiler-error-driven workflows
00:13:45 <asheshambasta> solidus-river: I'm using Intellij with the Intellij-Haskell plugin. So far, so good.
00:14:19 * hackage debug 0.0.1 - Simple trace-based debugger  https://hackage.haskell.org/package/debug-0.0.1 (NeilMitchell)
00:18:42 <solidus-river> yeah, i'd prefer vim but i'm trying to work on window
00:18:45 <solidus-river> *windows
00:19:38 <liste> solidus-river: vim's great on windows too
00:20:04 <silverdust> Is it right to say any function that composes is a curried function?
00:20:54 <glguy_> Probably not
00:21:07 <cocreature> what does it mean for a function “to compose”?
00:21:40 <silverdust> I'm sorry I'm more comfortable with JS so I hope my examples make sense to you
00:22:34 <silverdust> a compose function would be one that takes smaller functions to create a sort of order of operation e.g compose(add, multiply)
00:23:20 <cocreature> that doesn’t sound like currying. a curried function is one that instead of taking multiple arguments, takes a single argument and then returns a new function
00:24:12 <cocreature> e.g. if you define add such that it accepts a single argument and returns a function that accepts the second argument, then that would be a curried version of add
00:24:41 <silverdust> calling that as compose(add, multiply)(2, 4, 3), it would return a function that first adds the first and second argument then multiplies by the 3rd argument
00:25:08 <liste> silverdust: no
00:25:20 <silverdust> it's definition is more like this compose = (func1, func2) => arg => func1(func2(arg))
00:25:54 <liste> silverdust: that latter definition is correct
00:25:58 <quchen> Alright, that’s Haskell’s version of »f . g = \x -> f (g x)«, which is indeed function composition.
00:25:59 <liste> note that there's only 1 arg
00:26:19 <cocreature> compose is (partially) curried since it returns a new function after you pass in the two arguments but the result of applying compose to two functions is not (or at least not necessarily)
00:26:39 <Profpatsch> cocreature: dysfun I think this is a quite nice way to create the initialization token interface from before:
00:26:41 <Profpatsch> http://lpaste.net/360890
00:26:59 <quchen> compose(add, multiply)(2,3,4) = (arg => add(multiply(arg)))(2,3,4) = add(multiply(2,3,4)) – probably not what we want.
00:27:49 <mniip> hmm
00:27:55 <dysfun> Profpatsch: that's a lot of extra code
00:28:01 <Profpatsch> I wonder if it’s possible to not export GitToken.
00:28:04 <dysfun> Profpatsch: and it's significantly more complex
00:28:11 <Profpatsch> dysfun: three lines?
00:28:28 <mniip> invert :: StateT s (StateT r m) a -> StateT r (StateT s m) a
00:29:00 <dysfun> Profpatsch: i don't count complexity in lines, i count it in terms of concepts i have to reason about
00:30:56 <Profpatsch> dysfun: Dunno, still exploring what it means for usage of the library.
00:31:20 <cocreature> Profpatsch: I’d probably go for something like this instead http://lpaste.net/360891
00:31:40 <Profpatsch> cocreature: Ah, value level.
00:31:46 <Profpatsch> Yes, that sounds more like it.
00:32:03 <cocreature> if you need to pass the token around anyway, there is little value in abstracting using a typeclass imho
00:32:09 <silverdust> Creating an example of another case I have. The add, mutiply example wasn't great enough
00:32:20 <phadej> mniip: type looks more like `swap` or `commute` :)
00:32:32 <silverdust> Please look at this http://jsbin.com/zijujufeka/edit?js,console
00:32:39 <cocreature> phadej: or transpose :)
00:32:40 <Profpatsch> I don’t like to introduce type classes if they don’t have clear laws and abstraction value anyway.
00:33:28 <silverdust> quchen: looks like you're familiar with my JS syntax. That's a composition but not a curry right?
00:33:34 <Profpatsch> Akin to http://www.haskellforall.com/2012/05/scrap-your-type-classes.html :)
00:33:40 <silverdust> All currying functions must take a single argument?
00:34:29 <quchen> silverdust: »A composition«, sure, it involves the compose function. I don’t know what »a curry« is though.
00:35:03 <cocreature> quchen: it’s a dish and a pretty good one actually
00:35:10 <quchen> ba dum tsh
00:35:22 <cocreature> I’ll show myself out
00:36:03 <quchen> silverdust: I also don’t know what a »currying function« is. I can live with »a curried function«.
00:36:33 <quchen> A curried function, at least in Javascript, takes a single argument, and returns another function.
00:36:54 <quchen> A curried function in Haskell is so indistinguishable from a function taking multiple arguments in Haskell that we don’t really talk about currying all that much.
00:37:22 <silverdust> Thanks y'all. I was writing an article and I wasn't sure to say if that compose function is an example of curry because I was look for a way to bring in curry
00:37:26 <quchen> In fact, the curried version is how we model functions of multiple arguments in Haskell most of the time.
00:37:58 <silverdust> *looking
00:38:59 <silverdust> I'll enlighten myself more on it. Just started learning haskell yesterday so I hope to see things from a haskell pov in the future
00:40:16 <quchen> Going from Haskell to other lambda-supporting languages is usually easier than the other way round. :-)
00:40:48 <Profpatsch> quchen: But going to Haskell from non-lambda-supporting languages first is a lot harder, so there’s that. :)
00:41:23 * hackage html-entity-map 0.0.1.0 - A mechanically generated map from HTML5 entity names to the corresponding Unicode characters  https://hackage.haskell.org/package/html-entity-map-0.0.1.0 (mrkkrp)
00:41:36 <Profpatsch> If you can understand stuff like currying & higher order functions in Javascript, then learning Haskell basics should be a walk in the park actually.
00:42:29 <Profpatsch> I horribly failed to understand Clojure’s fold function until learned Haskell and saw the type.
00:45:35 <quchen> The main problem is that Javascript is very permissive in the number of arguments a function takes.
00:45:48 <quchen> That makes typing them hard, hence people tend not to think about types.
00:45:57 <quchen> But types are crucial in order to determine whether things compose.
00:46:54 <andrei> Are there any examples of how to use HMAC auth with servant using a haskell client?
00:49:25 <phadej> IMHO people often ignore that in JS (or clojure) it's /easy/ to write zipWithN or liftN, but OTOH it would be impossible to work with e.g. van Laarhoven encoding of lenses
00:49:42 <frerich> Writing parsers in applicative style is so nice (in comparison to what my colleagues produce in languages like C++, Swift or Python) that I'm at the point of _hoping_ that the next AoC challenge involves parsing something. :-)
00:49:48 <phadej> it's a trade-off
00:59:29 <cocreature> andrei: do you control the backend as well?
01:00:31 <andrei> cocreature: Nope
01:01:01 <andrei> cocreature: But I already have a description of it in servant
01:01:30 <cocreature> andrei: maybe take a look at the test suite of servant-auth-client https://github.com/haskell-servant/servant-auth/blob/master/servant-auth-client/test/Servant/Auth/ClientSpec.hs#L47. but I’m not sure how flexible it is if you don’t control both sides
01:02:35 <andrei> cocreature: That example assumes a specific auth mechanism they added special support for
01:05:01 <mniip> urge to invoke callCC intensifies
01:05:06 <cocreature> andrei: right, my point was that you can probably steal ideas from there
01:05:11 <andrei> cocreature: They wrote a mechanism to support generic authentication methods and specifically mentioned hmac, but I can't find any way to use it
01:05:26 <cocreature> andrei: the one in servant itself? afaik that’s supposed to be removed in the next release
01:06:23 <andrei> cocreature: The whole AuthServerData/AuthClientData mechanism?
01:06:40 <andrei> cocreature: That's unfortunate. Is there a discussion about what it's being replaced with?
01:06:56 <cocreature> it’s being replaced with the package I linked you to
01:07:35 <cocreature> see https://github.com/haskell-servant/servant/issues/805
01:09:46 <vaibhavsagar> frerich: any problem that lets me wield attoparsec makes me very happy
01:10:39 <tdammers> vaibhavsagar: that's easy then - just invent a new SDSL for each problem
01:11:16 <vaibhavsagar> not a bad idea
01:11:41 <vaibhavsagar> as soon as I figure out how to push all computation onto the parsing step this will be my modus operandi
01:11:52 <Profpatsch> vaibhavsagar: Ohai.
01:12:12 <vaibhavsagar> Hi Profpatsch!
01:12:56 <cocreature> andrei: if your problem is not solvable using servant-auth but solvable using the current API, you might want to comment on that issue
01:19:23 * hackage MBot 0.2.3.0 - Haskell interface for controlling the mBot educational robot  https://hackage.haskell.org/package/MBot-0.2.3.0 (cfscholl)
01:23:24 <andrei> cocreature: Thanks. I suspect it's possible to do the same in both. Unfortunately neither is well documented
01:26:48 <Younder> I have come up with a new acronym for design ISO. Isolate - Secure - Organize.
01:28:36 <Younder> Isolate means isolate dependencies, like a data base isolation layer, a OS isolation layer, and a human interface isolation layer (GUI, WEB)
01:29:54 <Younder> Secure is a laer to insulate you from error stratifying the protocol from The Problem Domain component.
01:32:06 <Younder> The delegation layer monitors and optionally logs transactions to and from  the Isolation layer to the Problem Domain component.
01:32:29 <quchen> Is there a Haskell part about this coming up?
01:33:47 <Younder> The point is this can be stratified better to a cluster architecture.
01:33:58 <Younder> quchen, nop, I will stop now
01:35:14 <Younder> I am going on vacation, and wanted somehow to record it for prosperity
01:36:07 <dminuoso> Given `data Point = Point { getX :: Integer , getY :: Integer }` and [Point], is there a combinator that can give me an ordering function that allows me to "sort by X"?
01:36:28 <muzzle> :t sortBy (comparing getX)
01:36:29 <lambdabot> error:
01:36:29 <lambdabot>     • Variable not in scope: getX :: b -> ()
01:36:29 <lambdabot>     • Perhaps you meant one of these:
01:36:44 <ahihi> :t sortOn
01:36:45 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
01:37:01 <muzzle> :t sortBy
01:37:02 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
01:37:37 <ahihi> sortOn f = sortBy (comparing f)
01:37:44 <dminuoso> muzzle, ahihi: Great thank you. `comparing` is the combinator I was looking for. :)
01:38:52 <muzzle> you could also use sortOn but it tends to be slower (in my experience)
01:41:25 <dminuoso> muzzle: my linter hinted me at minimumBy even, since I was doing `head $ sortBy (comparing getX) p` :)
01:42:48 <ahihi> sortOn tends to be slower? do you have an example?
01:47:24 <ertes-w> ello
01:48:00 <olligobber> oh, checking a Chan is empty throws compiler warnings...
01:49:03 <ertes-w> olligobber: you shouldn't check whether a Chan is empty
01:49:04 <osa1> olligobber: that function is deprecated, you should use TChan for that
01:49:25 <ertes-w> olligobber: by the time you check whether the result was true or false it may have already changed
01:51:13 <ertes-w> olligobber: in general just avoid Chan altogether…  use (in *my* order of preference) MVar, TMVar, TBQueue, TQueue, TChan
01:53:04 <ertes-w> muzzle, dminuoso: if you need sorting, in 9999 out of 10000 cases you shouldn't be using lists in the first place
01:54:51 <grokkingStuff> ^ that's something my prof likes to say
01:55:03 <grokkingStuff> it's better to use better data structures
01:55:28 <grokkingStuff> like binary trees
01:57:48 <ertes-w> you should always use the best data structure for the job…  first of all, if you don't, you contribute to the problem that software is getting slower more quickly than hardware is getting faster…  you're directly responsible for my phone's battery only lasting 1-2 days
01:58:25 <ertes-w> but you're also doing yourself a favour, because the right data structure for the job much more likely also has the right API for the job
02:00:16 <totom> I do not have any experience in data structure.Which is the best place for me to learn data structures for FP
02:00:30 <olligobber> ertes-w, ty
02:01:45 <ertes-w> totom: i don't know any resources, sorry for that, but the idea is that you think about the operations you need, and then you check at least the 'containers' library for the associated run-times and memory requirements for those operations
02:02:32 <[Leary]> The problems around list efficiency all come down to O(n) operations. I imagine more sophisticated data structures with O(1) and O(log n) operations will have enough overhead to end up being slower than sufficiently small lists.
02:02:34 <ertes-w> totom: for example if you need a finite sequence structure with quick appends and quick uncons at both ends, you should likely go with Data.Sequence
02:03:22 <ertes-w> totom: for the majority of tasks your choice comes down to [], Map, Seq and Set
02:04:59 <ertes-w> totom: other libraries you should keep in mind are (in no particular order):  fingertree, unordered-containers, vector
02:05:30 <ertes-w> and there are also a bunch of prioritiy queue packages: search hackage for *psqueue*
02:11:32 * hackage html-entity-map 0.1.0.0 - Map from HTML5 entity names to the corresponding Unicode text  https://hackage.haskell.org/package/html-entity-map-0.1.0.0 (mrkkrp)
02:12:45 <Saizan> ertes-w: did you have good experiences with Data.Seq?
02:30:39 <ertes-w> Saizan: (assuming you mean Data.Sequence) more or less…  i gravitate more toward vector where possible
02:31:53 <ertes-w> Saizan: the constant/log factor between them is rather large in terms of both speed and memory
02:31:56 <fakenullie> what about DList
02:32:25 <ertes-w> you mean (DList a ≃ [a] -> [a])?
02:35:44 <fakenullie> http://hackage.haskell.org/package/dlist
02:36:39 <ertes-w> fakenullie: yeah, that's just ([a] -> [a]), and i'd rather use it directly
02:36:51 <fakenullie> ok
02:37:04 <ertes-w> fakenullie: DList is to [] what Builder is to ByteString and Text
02:37:28 <ertes-w> if all your (++) are right-associated you don't need it, but it's quite handy when they aren't
02:38:33 <ertes-w> > (mappend "abc" . mappend "def" . mappend "ghi") ""
02:38:35 <lambdabot>  "abcdefghi"
02:38:47 <ertes-w> fakenullie: ^ this is what DList does
02:40:56 <dminuoso> ertes-w: Yeah I'm aware that lists perform quite horribly. What is a better alternative? Vector?
02:41:37 <dminuoso> Until now I intentionally used lists for their algebraic structure making things like pattern matching elegant.
02:41:43 <ertes-w> dminuoso: no, lists don't perform horribly – they do have their use cases…  the question can only be answered in the context of an application
02:41:46 <totom> ertes-w: thank you very much for your input
02:42:13 <dminuoso> ertes-w: I'm just implementing graham scan for a set of points based on an excercise from RWH.
02:42:20 <Athas> Haskell lists are poor lists, but decent streams.
02:45:37 <ertes-w> dminuoso: i'm not familiar enough with the algorithm, but lists may actually be the best *functional* data structure for that
02:46:00 <ertes-w> dminuoso: however, a mutable vector would most likely provide a factor 10-100 speedup
02:47:38 <dminuoso> ertes-w: You pick a minimum point based on a predicate, sort the rest, and then iterate over the points. If a point satisfies a condition, its pushed to a stack. If it doesn't, you remove elements from the stack until the condition is satified. You repeat that until you have went through all points.
02:48:24 <ertes-w> dminuoso: yeah, a mutable vector sounds perfect for that…  you get the stack for free, because you can just do a partial sort
02:50:15 <frerich> I always do a dance like 'import Data.Map (Map); import qualified Data.Map as Map' when using Map or Vector or Seq or so. Is there maybe a shorter way to get the same?
02:51:38 <frerich> None of the variants described on https://wiki.haskell.org/Import seem to match this. :-/
02:51:54 <dminuoso> ertes-w: What do you mean by partial sort?
02:52:05 <cocreature> frerich: sadly there isn’t. anthony cowley made a proposal for this once but it died due to too much bikeshedding
02:52:14 <ertes-w> frerich: not really, but if you can live with spelling out "M.Map", you could just use the qualified import
02:52:30 <cocreature> maybe someone should try to revive it now that we have the ghc-proposals process
02:52:38 <ertes-w> dminuoso: ah, there is only one sort
02:52:51 <ertes-w> dminuoso: so yeah, then it boils down to just swapping elements, as far as i see
02:53:29 <dminuoso> ertes-w: Not exactly swapping. Your stack basically maintains the solution. You look at a point, if a certain condition is not met, then you have to backtrace and remove the most recent points.
02:54:10 <dminuoso> So each time you push a point, you might later recognize that there's a better path around (which would remove it)
02:55:10 <ertes-w> dminuoso: [] is good enough, but a mutable vector will provide a considerable constant speedup
02:55:35 <ertes-w> dminuoso: especially when you're below inner cache thresholds
02:55:57 <ertes-w> dminuoso: i would expect no less than a factor 5 speedup over []
02:56:24 <dminuoso> ertes-w: Alright you got me interested now. Ill implement it with both a mutable vector and [], and just measure it. :)
02:57:33 <ertes-w> dminuoso: i found pseudocode on wikipedia…  you can more or less just copy/paste it
02:57:46 <ertes-w> dminuoso: for the sorting use the vector-algorithms library
02:59:12 <ertes-w> dminuoso: i found that .Intro works best for most things
04:19:14 <nf7> Is there a way to execute multiple commands on a single line in GHCI? I'd like to load a file and execute the main function in one go, something like `:load "main.hs" && main`.
04:20:51 <quchen> nf7: nope
04:21:44 <Cale> nf7: Why does it have to be on the same line?
04:22:00 <nf7> quchen: Damn. Is REPL based programming something that is common in the Haskell world (like it is with Clojure people for example)?
04:22:14 <nf7> Cale: It doesn't have to be, I'd just like to be able to up arrow to the last command and execute them both together.
04:22:33 <quchen> nf7: I don’t use the REPL all that much, but others use GHCi extensively during development.
04:22:33 <Cale> ah
04:23:03 <Cale> Usually I load my file by passing it to ghci on the commandline rather than with :l
04:23:10 <Cale> and just use :r to reload from there
04:23:19 <quchen> :r && main would be neat though
04:23:45 <nf7> Yeah that would be handy.
04:23:47 <quchen> Kind of like stack’s --file-watch --exec
04:23:50 <quchen> But inside GHCi
04:25:43 <nf7> There must be some kind of editor integration that communicates with a REPL that is listening on a port. Anyways, that's a bit beyond me at the moment. I should probably get familiar with naked ghci to begin with.
04:28:50 <codeshot> :cmd pure ":set -XFlexibleInstances\n:run print 1"
04:29:00 <codeshot> nf7 ^^^^
04:29:22 <nf7> codeshot: What does that do?
04:29:36 <codeshot> it runs two haskell repl commands in one go
04:29:49 <codeshot> there they are separated by \n
04:30:00 <codeshot> two ghci repl commands, sorry
04:30:06 <nf7> codeshot: Oh sweet! Thanks a lot.
04:30:17 <Psybur> Is it possible to do a dynamically parallel mappend?
04:30:40 <codeshot> specifically: :cmd pure ":r\nmain"
04:30:43 <codeshot> no problem
04:31:27 <nf7> codeshot: Just tried it, works perfectly!
04:31:32 <codeshot> Psybur, Doesn't mappend do exactly that in something like ghc?
04:31:50 <Psybur> Parallel as in using rpar
04:31:51 <codeshot> ghc uses multiple OS threads to do it's thing, I read
04:31:57 <codeshot> oh
04:32:21 <Psybur> And it will be on my own Monoid instance, dont know if thats still optimized?
04:33:46 <Cale> codeshot: GHC doesn't parallelise things automatically for you.
04:33:59 <codeshot> Cale, oh, okay, thanks. I was sure I read that
04:34:27 <Cale> Psybur: You can use rpar from inside a Monoid instance if you want to.
04:35:02 <codeshot> Psybur, you should be able to write a newtype with a monoid instance to add rpar
04:38:41 <nf7> This command `:cmd pure ":! clear \n :r \n main"` clears the screen, reloads the file and runs the main function if the load was successful. Exactly what I was looking for. My basic workflow is much faster now.
04:44:03 <codeshot> nf7, there's also :script filename
04:44:51 <codeshot> and :def
04:45:24 <nf7> codeshot: Thanks for the tips.
04:47:55 <codeshot> :def doit (const.pure) ":! clear \n :r \n main"
04:48:00 <codeshot> :doit
05:02:09 * hackage mmark 0.0.3.0 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.3.0 (mrkkrp)
05:02:44 <Psybur> So heres an implementation of parMapReduce I made, but its very slow for Sum. Wonder if I could expect a speedup if the function is expensive. https://glot.io/snippets/ewiz736366
05:03:06 <Psybur> Going to refining the test unless someone can see something obviously wrong here :D
05:05:18 <s4ke> Psybur: why are you using rpar for your parmap and not use parMap from Control.Parallel.Strategies?
05:05:22 <s4ke> have you compared the performance?
05:05:34 <Psybur> No, I havent learned enough about Strategies yet :D
05:05:52 <codeshot> rpar constructs a strategy
05:06:11 <s4ke> you probably just want something like parMap (rdeepseq)
05:06:52 <s4ke> rpar only sparks the argument which means that it may not be properly evaluated when it is requested
05:07:23 <ertes-w> nf7: integrate GHCi into your editor; for example haskell-mode with emacs
05:08:16 <ertes-w> nf7: that gives you a similar development experience to most lisps, in particular CL, elisp and scheme
05:08:57 <s4ke> or try using rparWith rdeepseq
05:10:22 <s4ke> Psybur: ^
05:10:50 <s4ke> also you probably want to use stuff like chunking
05:10:57 <s4ke> so you dont spark all evaluation into a separate thread
05:11:18 <Psybur> Maybe I should continue reading the parallel and concurrent programming in haskell book :D
05:11:25 <s4ke> Psybur: https://github.com/s4ke/Parrows/blob/master/Definition/src/main/Parrows/Skeletons/Map.hs#L62 this is how i did it
05:11:38 <s4ke> careful arrow syntax
05:11:47 <ertes-w> Psybur: there are quite a few caveats with using parMap…  parBuffer yields far better results for most applications
05:12:22 <Psybur> ertes-w, this is parMap', not parMap :D
05:12:27 <ertes-w> Psybur: if your monoid is commutative there are even better options, but i'm not aware of ready-made implementations
05:12:36 <Psybur> Its not commutative
05:13:08 <ertes-w> Psybur: hard to tell, because glot.io displays the whole code in a single line
05:13:36 <ertes-w> … for me
05:13:37 <Psybur> ertes-w, what browser you using? links? :D
05:14:43 <ertes-w> does it matter?  every paste site i know works with links (no, i'm not using it)
05:15:16 <Psybur> ertes-w, https://hastebin.com/tagihumica.hs
05:16:52 <Psybur> s4ke, my powerlevel is not quite as high as yours. Ill get there one day :D?
05:19:55 <s4ke1> stupid internet
05:21:10 <s4ke1> also the parBuffer that was talked about is probably the "chunking" i talked about
05:21:29 <s4ke1> uhm sorry, wrong info. it does chunking but differently
05:22:04 <ertes-w> hastebin doesn't show any code at all =)
05:22:18 <s4ke1> parBuffer evaluates the input list in chunks. so it evaluates the next n elements in parallel as soon as the head is consumed
05:22:38 <s4ke1> this however sparks quite a lot of threads. what you probably want to do is to create big packages of tasks to evaluate
05:22:38 <Psybur> >.>
05:22:52 <s4ke1> so you use chunksOf
05:23:01 <Psybur> s4ke1, yeah, probably like split the work up into however many cores/cpus I have right
05:23:02 <s4ke1> % chunksOf 4 [1..10]
05:23:03 <yahb> s4ke1: [[1,2,3,4],[5,6,7,8],[9,10]]
05:23:29 <s4ke1> Psybur: not necessarily, just into a manageable task size that isnt too small
05:24:01 <Psybur> "draw the rest of the fucking owl" :D What is "manageable"? :D
05:24:09 <ertes-w> note that lists are a *terrible* structure for this…  repa comes to mind
05:24:22 <s4ke1> something that is small enough so that slower threads dont hog all the tasks, but big enough that the overhead of spawning a thread is not bigger than the gain of parallelization
05:24:42 <s4ke1> ertes-w: why are lists terrible?
05:27:00 <ertes-w> because you can't do length-based planning (which you should do for non-commutative monoids), and because it's difficult to do this without introducing sharing
05:27:37 <s4ke1> ertes-w ah you are talking about his monoid example
05:27:38 <ertes-w> also you pay for every cons, because parallel evaluation can't be fused away
05:28:28 <ertes-w> lists are fine for commutative monoids, if you implement a suitable strategy for them
05:28:46 <ertes-w> more or less fine…  you still pay the cons
05:29:44 <s4ke1> ertes-w wdym with "fused away"
05:31:37 <f-a> hello, I am getting this quizzical module not found http://lpaste.net/360899 while building `hatex-guide`
05:32:49 <f-a> the offending import is from HaTeX and this seems to be correctly specified in hatex-guide.cabal
05:33:58 <f-a> Sally: log 18 hour
05:34:07 <f-a> (woops, wrong window)
05:38:57 <f-a> or alternatively, is there a way to (new-build) trigger full recompilation?
05:53:44 <hexagoxel> f-a: looks like a build-type custom package with an insufficiently specified custom-setup/setup-depends.
05:53:53 <hexagoxel> see https://www.haskell.org/cabal/users-guide/developing-packages.html#custom-setup-scripts
05:54:39 <hexagoxel> probably need several of the build-depends for the setup-depends, too.
05:55:26 <f-a> yup, that explains everything. thanks hexagoxel
06:02:07 <lavalike> :t ((join .) .) . liftM2
06:02:08 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
06:02:19 <lavalike> is there such a combinator already defined somewhere?
06:05:06 <s4ke1> ertes-w thanks for the idea of lists being non-optimal. my library will work on that in the future :)
06:05:26 <s4ke1> maybe i will work on Traversable, Monoid and stuff  instead of Lists only
06:27:17 <shiona> ran todays AoC solution for hours before giving up, looking at glguys code trying to figure out why it would have better performance. Started copying it over part by part not noticing any improvement. Until I saw my code comparing (==0) versus (>0). Changed that and my code solved the problem immediately
06:27:46 <codeshot> lavalike, I never imagined doing that combinator but it looks so useful
06:28:33 <codeshot> I can't intuit what it's doing, neither point free nor pointed, so it would be a good candidate for a standard name and some explanatory docs
06:28:47 <EvanR> that combinator is popular but not defined anywhere
06:29:30 <codeshot> lavalike, how does the join work? I can't see the joined monad
06:29:34 <codeshot> :t liftM2
06:29:35 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:29:43 <codeshot> :t ((join.).).liftM2
06:29:44 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
06:29:49 <EvanR> its more clear as \f act1 act2 -> do {x <- act1; y <- act2; f x y}
06:30:19 <codeshot> yeah, I guessed that's what the action was, but I'm trying to trace through the type transformation
06:31:05 <EvanR> my brain explodes trying to read the point free version
06:31:33 <codeshot> even \f act1 act2 -> join $ liftM2 f act1 act2 !
06:31:52 <EvanR> well that explains it
06:32:11 <codeshot> I think I got it, join forces r to be (m a), and joins the result at the end down to (m a)
06:32:22 <codeshot> EvanR, exactly
06:32:26 <EvanR> (((f .) .) .) . g is like, composition delaying more and more args
06:33:24 <codeshot> It's a shame (.) is infixr instead of infixl
06:33:39 <EvanR> no its not
06:33:52 <codeshot> how come?
06:34:31 <EvanR> > (f . g . h) x
06:34:33 <lambdabot>  error:
06:34:33 <lambdabot>      • Could not deduce (Show b0) arising from a use of ‘f’
06:34:33 <lambdabot>        from the context: FromExpr c
06:34:39 <codeshot> it means we have to have these nasty nested braces instead of being able to mix let (.:) = (.).(.) in among (.) composition
06:35:06 <EvanR> why would you do that
06:35:18 <EvanR> .: and .:: etc should be defined at the top level
06:35:31 <codeshot> I mixed english and code
06:35:33 <codeshot> it would be
06:35:55 <EvanR> its like ++ being right assoc, so a chain of ++ can be done lazily
06:36:28 <EvanR> f (g (h x))  allows f to short circuit
06:36:56 <codeshot> no, it's being right associative so arguments can be taken from the queue at any point in a composition without faff
06:37:39 <codeshot> would be nice to do this (f . g .: h . i) for_i for_h_2
06:37:47 <EvanR> highly skeptical
06:38:10 <codeshot> good, then you lack bias and can see the benefits
06:38:12 <codeshot> :)
06:38:17 <EvanR> i question even simple usage of .: and .::
06:38:39 <codeshot> I question all matters of style in order to find the best choices
06:38:54 <codeshot> Do you mean to assert definitely that they're a bad idea?
06:39:38 <EvanR> i question if anything more complex than f x . g y . h z is easy to understand
06:39:43 <EvanR> in pointless style
06:40:14 <codeshot> my example above is just equivalent to reduction at the top of a stack
06:40:26 * hackage trigger 1.0.1.0 - Trigger is a cross platform file system watcher for super fast build-and-restart workflows.  https://hackage.haskell.org/package/trigger-1.0.1.0 (rhyskeepence)
06:40:35 <codeshot> this is easy to understand - otherwise there wouldn't be many successful programs out there
06:40:38 <EvanR> yeah i have heard people explain haskell code as a stack
06:40:44 <EvanR> that sounds totally wrong and backwards
06:40:55 <EvanR> this is haskell not forth
06:41:01 <fakenullie> then you have .) . it is not easy to understand
06:41:07 <[Leary]> I use .: (though I denote it ...) pretty often, but it's almost always the last in the chain, and f . g . h ... i works just fine. Hence so does f . g ... (h . i).
06:41:46 <codeshot> EvanR, the expression is equivalent to other things which are stacks and which you will accept
06:42:26 <fakenullie> @pl f x y = g x y . f x y
06:42:26 <lambdabot> f = fix (ap (ap . ((.) .) . g))
06:42:51 <EvanR> @pl f x y = g x y . h x y
06:42:51 <lambdabot> f = ap (ap . ((.) .) . g) h
06:43:01 <EvanR> jeebus
06:44:26 <codeshot> with infixl (.) instead of infixr, (f . g .: h . i) = ((f . g) .) h . i), it takes an argument and sends it through i->h->g->f and takes a second parameter for h too but the syntax directly maps and in a way where each subexpression can be copied and pasted with predictable results
06:45:00 <fakenullie> :t (.:)
06:45:01 <lambdabot> error:
06:45:02 <lambdabot>     • Variable not in scope: .:
06:45:02 <lambdabot>     • Perhaps you meant one of these:
06:45:06 <codeshot> nonstandard
06:45:13 <EvanR> :t (.) . (.)
06:45:15 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
06:45:34 <EvanR> im good with variables
06:45:40 <feep> hi
06:45:49 <feep> fishing for names again
06:46:05 <feep> is there a name for a join function that takes as a parameter a lambda that takes both halves to be joined and returns a joining element?
06:46:35 <fakenullie> foldr?
06:46:52 <feep> checking
06:47:19 <feep> oyeah! thanks
06:48:10 <feep> hm, no, hang on, no
06:48:24 * hackage authenticate 1.3.4 - Authentication methods for Haskell web applications.  https://hackage.haskell.org/package/authenticate-1.3.4 (MichaelSnoyman)
06:48:40 <feep> hm no hang on, that still works
06:49:00 <feep> aa except no. hm. I want something like foldr1?
06:49:21 <Psybur> Maybe give us an example scenario you would use your algorithm
06:49:31 <feep> except also no because the type returned by the folding function should not be the same type as the list itself
06:49:36 <feep> Psybur: yeah, hang on
06:50:08 <codeshot> > (id `dot` id .: const `dot` id) 1 2
06:50:11 <lambdabot>  1
06:50:14 <codeshot> > (id `dot` id .: flip const `dot` id) 1 2
06:50:16 <lambdabot>  2
06:50:18 <feep> this is a bit hairy because I'm not writing this in haskell
06:51:10 <codeshot> here the arguments 1 and 2 form a queue or stack depending on how you look at it (there are certain equivalencies which means you will apply your own perspective to conclude different structures)
06:52:43 <codeshot> id -> const -> id -> id is a pipeline (for a queue perspective) or a reducer (for a stack perspective) where each step takes either one item from the stack and processes it and puts it back ready for the next step
06:52:47 <EvanR> which is a great basis for haskell obfuscation contest
06:53:15 <codeshot> no it's not, it's just a reader over arguments
06:53:20 <codeshot> instead of a list
06:53:23 <cocreature> it’s not that you can’t figure this out but ime in most cases other ways to write this are significantly easier to read
06:54:26 <codeshot> It's just an automata that runs along the arguments, taking one at the start and another one every time you see .:
06:54:41 <EvanR> have you heard of malbolge
06:54:44 <jollygood2> is there a way to get %.Nf to round half away from zero instead of toward even?
06:54:46 <jollygood2> in printf
06:55:11 <codeshot> just like the protein building proteins in your cells which nip along dna reading it and transforming and combining codons
06:55:51 <codeshot> You must never attempt to write a program that models such automata or your program will necessarily be obfuscated
06:56:04 <jollygood2> > printf "%.0f" 1.5 :: String
06:56:05 <LeuzSec> What is it? Malbolge?
06:56:07 <lambdabot>  "2"
06:56:08 <jollygood2> > printf "%.0f" 2.5 :: String
06:56:10 <lambdabot>  "2"
06:56:21 <EvanR> you could see biotechnology as the compiled form of code, rather than the basis of a human readable language
06:56:22 <codeshot> or sed
06:56:36 <EvanR> er, biomachinery
06:56:43 <codeshot> never ever use sed, or any stream processing
06:56:47 <codeshot> is this right?
06:56:58 <codeshot> because it's equivalent
06:57:06 <feep> I have, uh, data Move = Mv Vector Vector, data Sequence = Seq [Move]. I want a function join :: [Sequence] -> (Sequence -> Sequence -> Move) -> [Move]
06:57:13 <EvanR> this might be the same argument against regex
06:57:22 <feep> Psybur: not sure if I'm saying that right?
06:57:40 <codeshot> EvanR, I didn't cover regex featuresets so I'm not sure how that's relevant
06:57:44 <codeshot> sed is more than regex
06:57:45 <EvanR> "its just an automaton" doesnt really make a case for ease of understanding and maintenance by another human being, such as "me in 2 months"
06:57:56 <Psybur> So you want to turn a list of sequences into a list of moves?
06:58:07 <codeshot> Perhaps you are trained in mathematical functions
06:58:09 <feep> yes, using a function that returns a "joining move" for a pair of sequences
06:58:14 <feep> connecting the end of one with the start of the other
06:58:14 <codeshot> this is not the only human state
06:58:40 <Psybur> feep, so what happens if there is only sequence in your list
06:58:42 <Psybur> Or no sequences
06:58:55 <feep> Psybur: no sequences -> no moves, one sequence -> just its moves
06:59:24 <feep> data Sequence should strictly be Seq Move : [Move], since there's one at least
07:00:15 <Psybur> feep, take the initial sequence or two, turn that into a Move, then use that Move as the initial argument in foldr. That sound reasonable?
07:00:25 <Psybur> Wait
07:00:28 <feep> yes, I was wondering if that already had a name
07:00:37 <feep> or if there's a similar kind of function that does
07:00:49 <Psybur> Thatll need a function like Sequence -> Move -> Move
07:01:02 <feep> turn the initial sequence into a [Move], you mean
07:01:23 <Psybur> Can you combine a sequence and a move to make another move?
07:01:30 <feep> no
07:01:39 <cocreature> seems like a generalized version of "intercalate" but I don’t think there is a name for this generalization
07:01:54 <cocreature> tbh I also don’t think it’s used particularly often
07:02:04 <feep> that's fair
07:02:10 <Psybur> feep, so if I have a list of [s1,s2,s3,s4] you want [s1 + s2, s3 + s4] ?
07:02:17 <feep> nonono
07:02:37 <cocreature> Psybur: it’s a version of intercalate where the separator can depend on the neighbors
07:03:10 <feep> I want s1 + f(s1, s2) + s2 + f(s2, s3) + s3 + f(s3, s4) + s4
07:03:50 <feep> yeah I think it makes sense to break this into two verbs, "intersperse" and "join"
07:04:28 <feep> not sure if there's a type for "odd-numbered list of alternating types" :D
07:04:50 <Psybur> Seems like a sliding window
07:04:51 <feep> definitely not in the language I'm using, at least
07:05:11 <cocreature> which language are you using?
07:06:32 <feep> D
07:07:52 <Psybur> @let windowed s = foldr (zipWith (:)) (repeat []) . take s . tails
07:07:54 <lambdabot>  Defined.
07:08:04 <feep> yeah I can do that easily
07:08:45 <Psybur> > map (\[a,b] -> (a, a+b)) (windowed [1,2,3,4,5])
07:08:47 <lambdabot>  error:
07:08:47 <lambdabot>      • Couldn't match expected type ‘[[b]]’
07:08:47 <lambdabot>                    with actual type ‘[a0] -> [[a0]]’
07:09:32 <Psybur> > map (\[a,b] -> (a, a+b)) (windowed 2 [1,2,3,4,5])
07:09:34 <nf7> Which integral type should I default to when I don't care about range? Int or Integer?
07:09:34 <lambdabot>  [(1,3),(2,5),(3,7),(4,9)]
07:09:52 <EvanR> Int has more occurrences in the prelude
07:10:00 <EvanR> so there will be less conversion on average
07:10:10 <nf7> Ok
07:10:19 <nf7> That's a good reason to stick to it I guess.
07:10:21 <Psybur> @feep, are we getting closer :D?
07:10:21 <lambdabot> Unknown command, try @list
07:10:30 <feep> not sure, I don't speak haskell well enough
07:10:36 <feep> f :: a -> b -> a -> a, p :: a -> a -> b
07:11:06 <feep> sorry, make that joiner :: a -> b -> a -> a, intersperser :: a -> a -> b
07:11:34 <EvanR> Int is funny for being the type which doesnt let you care about the range, since the range is system dependent
07:11:49 <Psybur> :t \s xs -> map (\[a,b] -> (a, a `mappend` b)) (windowed s xs)
07:11:51 <lambdabot> Monoid b => Int -> [b] -> [(b, b)]
07:12:17 <Psybur> heh, ignore that :D
07:12:43 <feep> list :: a[], (joiner (joiner list_0 (list_0 `intersperser` list_1) list_1) (list_1 `intersperser` list_2) list_2) etc.
07:12:49 <Psybur> > map (\[a,b] -> (a, a++b)) (windowed 2 "abcdef")
07:12:52 <lambdabot>  error:
07:12:52 <lambdabot>      • Couldn't match type ‘Char’ with ‘[a]’
07:12:52 <lambdabot>        Expected type: [[[a]]]
07:13:35 <Psybur> > map (\[a,b] -> (a, [a,b])) (windowed 2 "abcdef")
07:13:37 <lambdabot>  [('a',"ab"),('b',"bc"),('c',"cd"),('d',"de"),('e',"ef")]
07:13:57 <Psybur> <feep> I want s1 + f(s1, s2) + s2 + f(s2, s3) + s3 + f(s3, s4) + s4
07:14:07 <feep> say intersperser ch1 ch2 = "-", joiner str1 marker str2 = str1 ++ marker ++ str2, ?function? intersperser joiner "abcdef" should be "a-b-c-d-e-f"
07:16:29 <feep> Psybur: so that should give, uh, ("a", ["ab"]), ("b", ["bc"]), etc., right? then I can just pass that back into windowed and that should give me something I can foldr1?
07:17:36 <feep> actually, I can just map (\[a,b] -> (a, [a,b], b). or. well, just wrap it directly
07:17:50 <feep> anyway, windowed does seem to be what I want~
07:18:48 <feep> or rather, simpler auto windowed2() { return range.zip(range.tail(1)); }
07:18:55 <feep> (Range)(Range range)*
07:19:19 <Psybur> It does suck that haskell doesnt have a builtin for sliding windows
07:20:31 <cocreature> feep: that won’t behave properly on empty lists (at least not in Haskell, dunno about D)
07:20:50 <feep> yeah, sorry, wrong function anyway
07:21:50 <feep> meant, range.zip(range.drop(1)), and it'll coincidentally do the right thing because D does not consider it an error if you drop(1) on an empty range. which I consider an error, but eh, this time it's useful~
07:22:40 <ertes-w> > map (take 3) . tails $ ['a'..'z']
07:22:40 <waterdrop> fmap for Either has type (a -> b) -> Either t a -> Either t b. Why do we have the t there? That's essentially requiring that we apply some higher kinded type to the value of type a before additionally wrapping it as a Either, right? But what's the idea behind that?
07:22:41 <lambdabot>  ["abc","bcd","cde","def","efg","fgh","ghi","hij","ijk","jkl","klm","lmn","mn...
07:22:49 <ertes-w> Psybur: like this?
07:23:05 <fakenullie> > drop 10 []
07:23:07 <lambdabot>  []
07:23:24 <Psybur> > head $ map (take 3) . tails $ ['a'..'z']
07:23:26 <lambdabot>  "abc"
07:23:34 <Psybur> Yeah thats a nice way of putting it
07:23:38 <mnoonan> waterdrop: it's just saying that fmap on Either applies to the second type parameter only (the Right values)
07:23:40 <feep> oh, is there a bot?
07:23:47 <feep> .. oh, is it lambdabot?
07:23:48 <feep> yep
07:23:54 <feep> I have that on ignore cause I use > a lot for quoting people
07:23:54 <Psybur> > head $ map (take 3) . tails $ "ab"
07:23:56 <lambdabot>  "ab"
07:23:59 <Psybur> > head $ map (take 3) . tails $ "abcd"
07:24:01 <lambdabot>  "abc"
07:24:04 <Psybur> > map (take 3) . tails $ "abcd"
07:24:06 <lambdabot>  ["abc","bcd","cd","d",""]
07:24:37 <Psybur> Depends if you want proper windows or not
07:25:20 <Psybur> > map (take 3) . filter ((==3) . length) . tails $ "abcd"
07:25:22 <lambdabot>  ["bcd"]
07:25:27 <waterdrop> mnoonan: Ah that makes sense. Thanks!
07:25:33 <Psybur> uh
07:25:38 <Psybur> ops
07:25:52 <Psybur> >  filter ((==3) . length) . map (take 3) . tails $ "abcd"
07:25:55 <lambdabot>  ["abc","bcd"]
07:27:24 <ertes-w> feep: Because Functor takes a type of kind * -> *, but Either :: * -> * -> *
07:27:43 <ertes-w> Either is not a functor, it's a family of functors
07:28:17 <ertes-w> instance Functor (Either e)  -- there is an instance (Functor (Either E)) for every E
07:28:35 <mnoonan> ^ waterdrop, ertes-w's answer is better :)
07:32:09 <waterdrop> ertes-w: Ah that makes sense. Is the declaration of the fmap instance for the Either family of functors in the Either type?
07:35:12 <MarcelineVQ> "<lambdabot> f = ap (ap . ((.) .) . g) h   <EvanR> jeebus" how do you feel about  (liftA2 . liftA2) (.)
07:36:05 <EvanR> :t (liftA2 . liftA2) (.)
07:36:06 <lambdabot> (Applicative f2, Applicative f1) => f1 (f2 (b -> c)) -> f1 (f2 (a -> b)) -> f1 (f2 (a -> c))
07:36:16 <EvanR> i feel great
07:36:16 <ertes-w> err
07:36:37 <ertes-w> feep: sorry, that was for waterdrop
07:37:00 <ertes-w> waterdrop: types and instances are separate
07:37:36 <waterdrop> ertes-w: Ah I see. Got it, thanks
07:37:39 <Psybur> > let f (x:xs) = x : (mconcat $ map (\x -> "-" ++ [x]) xs); f "abcdef" -- feep
07:37:41 <lambdabot>  <hint>:1:77: error:
07:37:42 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:37:54 <Psybur> > let f (x:xs) = x : (mconcat $ map (\x -> "-" ++ [x]) xs)); f "abcdef" -- feep
07:37:56 <lambdabot>  <hint>:1:57: error: parse error on input ‘)’
07:37:58 <Psybur> heh
07:37:59 <mnoonan> waterdrop: if you go here, you can see the source (look for Functor under Instances for Either) https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Either.html
07:38:13 <waterdrop> mnoonan: cool, thanks
07:38:38 <ertes-w> > intersperse '-' "abcdef"
07:38:40 <lambdabot>  "a-b-c-d-e-f"
07:38:57 <Psybur> word
07:42:15 <feep> aa hang on, need to chew on this for a bit, the types I'm trying are not working out.
07:42:57 <pja> Is there straightforward do notation-ese for "if condition then <stuff that ends up with return a> else <stuff that ends up with return b>" that doesn't end up with multiply nested if statements?
07:43:04 <pja> (In a non-monadplus monad)
07:43:40 <Taneb> pja: I think you need either an if or a case statement there
07:43:59 <pja> If your code ends up with return () in the leaves you can use when / unless etc. But if you want to return val, it seems to have to nest if .. then .. else statements. Have I missed some obvious piece of syntax?
07:44:21 <Taneb> There isn't a magic solution there, sadly
07:44:26 <pja> Yeah, I’m using a mix of case and/or if .. then .. else right now. But it looks ugly :)
07:45:45 <ezyang> SOP is to use where
07:46:19 <ezyang> also, if you truly want short circuiting, "there's a monad for that"
07:47:14 <pja> Not necessarily short circuiting. So, motivating example from today’s AoC...
07:47:27 <ertes-w> pja: just define it: whenElse x b c = if b then c else pure x
07:48:01 <pja> ezyang: where? hoogle denies everything.
07:48:27 <ezyang> pja: as in, the 'where' clause
07:48:43 <ezyang> foo x = if b then bar else baz where bar = ... baz = ...
07:49:39 <pja> Not sure that’s any easier to read frankly. But I suppose it exposes the structure more directly. the if .. then ..else .. formatting doesn't help.
07:50:53 <bollu> in haskell, are list computations expected to be as fast as array computations in C?
07:51:07 <bollu> assume the compiler has all the information it might ever want.
07:51:16 <Taneb> bollu: depends on the operation
07:51:18 <bollu> Is it a guarantee that this will be as fast as C + arrays?
07:51:21 <bollu> Taneb: a fold
07:51:32 <feep> yeah I went with a simpler approach and that worked fine :sigh:
07:51:35 <feep> Psybur: thanks for trying!
07:51:35 <Taneb> That should be pretty damn fast, but there's no official guarantee
07:51:40 <bollu> Taneb I see
07:51:52 <pja> So, I had a nice piece of clear monadic code that did "when <cond> do stuff .. return () ; do other stuff .. return ()
07:51:58 <Psybur> feep, you can make it up to use by telling us what this approach is :D?
07:52:02 <Psybur> to us*
07:52:14 <feep> Psybur: oh, I just turned around and mapped it to [Move] first, then fold1ed over it
07:52:14 <ezyang> bollu: Stream fusion can help
07:52:36 <pja> But the moment I change the function (inside State) to return a value, I can’t write when <cond> do stuff .. return Val ; do other studd .. return Val2
07:52:42 <pja> because when is only defined for ()
07:52:46 <bollu> Taneb I see that it is 3x slower
07:52:47 <bollu> https://gist.github.com/bollu/ad48466a86c6e299d5710751004258f2
07:52:54 <cocreature> if you’re using lists like C arrays it’s probably going to be slower
07:52:54 <pja> So I have to rewrite everything to use if .. then .. else.
07:53:01 <bollu> ezyang I am trying to understand the performance guarantees here
07:53:22 <pja> This seems .. unintuitive?
07:53:24 <Psybur> feep, so did you chunk the list into pairs, map those pairs to move, then fold?
07:53:51 <feep> no, the problem I wanted this elaborate construction in the first place is that I can't seed it with an empty list because constructing a joining move with an empty list is undefined
07:54:07 <feep> so upon relaxing for a bit I realized that this was a nonissue and I should just use join1
07:54:10 <feep> er, fold1*
07:54:14 <catern> is there any (theoretical backing for some kind of) notion of, exposing to a function, how its result is used, and what parts of its result are used? such that the function could substitute a more efficient implementation of that subset of functionality? for example, when querying from a database, only certain fields from the result might be used, so you only want to fetch those
07:54:37 <feep> and just specialcase empty lists
07:55:21 <pja> Why should I have to rewrite everything just because I’ve gone from State M () to State M Int ?  Is there an actual theoretical reason I’m missing?
07:55:56 <pja> (obv I’d have to return a value from the when, but there’s function that lets me do this? )
07:55:58 <ezyang> bollu: Haskell is not very good at perf guarantees
07:56:06 <pja> (monadic value that it.)
07:56:25 <ezyang> pja: Are you aware that 'return' is not short circuiting?
07:56:57 <pja> ezyang: yes, sadly.
07:57:03 <bollu> cocreature Is there any haskell data structure that guarantees C array liker perf
07:57:11 <bollu> ezyang I am aware :P
07:57:16 <bollu> ezyang that is why I am asking
07:57:17 <liste> pja: what if there was "when' :: Bool -> m a -> m a". what'd be the value of the invocation if the condition was false?
07:58:16 <pja> I want a short circuiting when then?
07:58:26 <cocreature> bollu: unboxed vectors would be the equivalent. they at least give you the right asympotics. although for your specific example that shouldn’t really matter
07:58:35 <bollu> cocreature I see
07:58:44 <ertes-w> pja: the way i understood it you want the whenElse function that i defined earlier
07:58:48 <bollu> cocreature are unboxed vectors a "base" thing? or a library written by someone else?
07:58:57 <ertes-w> @let whenElse x b c = if b then c else pure x
07:58:57 <cocreature> bollu: it’s part of the "vector" library
07:58:58 <lambdabot>  Defined.
07:59:01 <ertes-w> :t whenElse
07:59:02 <lambdabot> Applicative f => a -> Bool -> f a -> f a
07:59:08 <bollu> cocreature right
07:59:14 <bollu> cocreature but, I meant, something like
07:59:18 <bollu> cocreature cabal is part of "cabal"
07:59:24 <bollu> but it is supported by GHC, right?
07:59:30 <bollu> Is there something similar with "vector"?
07:59:30 <ertes-w> pja: this is not short-circuiting, it's just conditional branching
07:59:45 <shapr> GOOD MORNING!
07:59:45 <cocreature> bollu: but note that in your example, lists won’t even be used once GHC’s optimizer kicks in and I wouldn’t be surprised if the C version doesn’t use arrays either
07:59:56 <bollu> cocreature C version is vectorized
08:00:00 <cocreature> bollu: not sure what you mean by “is supported by ghc”
08:00:28 <bollu> cocreature Does "vector" use GHC intrinsics of some sort? Like, how are arrays actually implemented by "vector"
08:01:18 <cocreature> they use ByteArray under the hood
08:01:45 <pja> Perhaps my question is better phrased as: how to people handle conditional branching inside do notation in a way that maintains readability?
08:01:55 <aberrant> good morning
08:02:19 <aberrant> could someone please explain how "fibs = 0:1:(zipWith (+) fibs (tail fibs))" works?
08:02:22 <pja> ...because nested if then elses aren’t it.
08:02:24 <aberrant> I understand zipWith
08:02:51 <pja> aberrant: laziness.
08:04:03 <aberrant> pja: the first time around, it's 0:1 ++ (zipWith (+) [0,1] [1]), right?
08:04:44 <aberrant> but I guess I dont understand how it's recursive.
08:05:04 <pja> aberrant: 0:1:(zipWith (+) [0,1..rest of fibs] [1,..rest of fibs])
08:05:49 <pja> then 0:1:(0+1):(zipWith (+) [1,..rest of fibs] [1,..rest of fibs]) etc etc
08:06:31 <pja> the lists aren’t copied, they’re actual references to one single list that’s being generated on the fly whilst being consumed by the same function.
08:06:46 <aberrant> pja: this is what confuses me
08:06:48 <pja> It’s quite neat when you get your head round it.
08:09:02 <codeshot> it's recursive because it uses fibs
08:09:06 <pja> A list in Haskell can be a stream of values, with a thunk at the end to generate new ones. That thunk can be the function you’re currently inside...
08:09:18 <aberrant> yeah. this is very confusing to me still
08:09:27 <aberrant> there's NO WAY I would've been able to come up with that code on my own
08:09:43 <sun777> aberrant:  try reducing and applying the function by pen and paper. i think this makes stuff much, much clearer
08:09:50 <drdo> aberrant: try implementing a lazy list in a strict language, you'll get the idea
08:10:00 <codeshot> aberrant another way to write it is: fibs = let fibs_step recurse in fix 0:1:(zipWith (+) recurse (tail recurse))
08:10:18 <codeshot> this is explicit about where recursion happens
08:10:31 <codeshot> oops
08:10:45 <ertes-w> aberrant:
08:10:50 <[exa]> aberrant: the 'fibs' in the definition are in fact references, not lists
08:10:51 <codeshot> fibs = let fibs_step recurse = 0:1:(zipWith (+) recurse (tail recurse)) in fix fibs step
08:10:56 <codeshot> fibs = let fibs_step recurse = 0:1:(zipWith (+) recurse (tail recurse)) in fix fibs_step
08:10:58 <ertes-w> > zip [1..9] [2..9]
08:11:00 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)]
08:11:01 <codeshot> oh so many mistakes
08:11:05 <[Leary]> pja---maybe you want MultiWayIf.
08:11:10 <ertes-w> aberrant: does that make sense?
08:11:32 <ertes-w> aberrant: [2..9] = tail [1..9]
08:12:11 <ertes-w> aberrant: 'zip xs (tail xs)' is a way to pair neighbouring elements
08:12:20 <codeshot> aberrant was it you with the problem to produce variants of a list with one item removed?
08:12:23 <pja> [Leary]: oo. That’s quite nice.
08:14:34 <codeshot> aberrant, if it was you then here's another way to write that function from yesterday: (zipWith delete [1..] . join (<$)) [1,2,3]
08:14:46 <aberrant> codeshot: no
08:14:53 <ertes-w> aberrant: if this makes sense to you, the remainder is really just laziness…  as long as there are no cycles in your data dependencies, haskell will resolve them just fine
08:14:56 <codeshot> ok, nevermind then
08:15:44 <aberrant> ertes: thanks. I'm beginning to grasp it but it's still just a bit too far away
08:15:55 <Franciman> Hi
08:16:03 <ertes-w> aberrant: the way to get used to that way of thinking is to always ask: what happens when i pattern-match?
08:16:11 <Franciman> Do you have any example of usecases when one wants to use ParsecT transformer?
08:16:16 <aberrant> ertes-w: I'm gonna play around with zip xs (tail xs) until I understand it
08:17:20 <ertes-w> aberrant: zip (x:xs) (y:ys) = (x, y) : zip xs ys  -- here is the main clause of 'zip'
08:17:39 <aberrant> yup, I understand that.
08:18:42 <ertes-w> zip (x1 : x2 : xs) (tail (x1 : x2 : xs)) = zip (x1 : x2 : xs) (x2 : xs) = (x1, x2) : zip (x2 : xs) xs
08:20:05 <Guest70406> Can someone help with an Aeson question?  I am calling a REST API which returns some stuff.  The data I want is nested a few levels down - ie { response { listings : [I WANT THE OBJECTS IN HERE] } }.  I have written a FromJSON instance for my data types, but how do I decode the JSON string to give me what I want?
08:20:10 <aberrant> got that as well.
08:21:03 <Franciman> Guest70406, you could use Data.Aeson.Lens
08:21:04 <Franciman> and write
08:21:11 <ertes-w> aberrant: now pattern-match on 'fibs' by hand…  remember that haskell does not evaluate before it really has to
08:21:14 <Franciman> json ^. response . listings
08:21:20 <Franciman> the result of this is the A.Value you want
08:21:38 <Franciman> actually it works with `Maybe`s
08:21:57 <Franciman> so you could do like: decodeJSON ^. response .listings and get a Maybe A.Value
08:22:00 <ertes-w> Guest70406: use 'decode'
08:22:13 <Guest70406> Franciman: Ah OK, that sounds like what I'm looking for
08:23:02 <Guest70406> Franciman: what is the type of (response) and (listings) in that example?
08:23:21 <Franciman> ah sorry
08:23:22 <Franciman> it's
08:23:35 <Franciman> decodeJSON ^. key "response" . key "listings"
08:23:48 <ertes-w> Guest70406: note that Franciman's solution involves an additional package (lens-aeson, *not* aeson-lens), and you wouldn't use a FromJSON instance
08:23:58 <Franciman> yes
08:24:11 <ertes-w> you would just traverse the raw Value directly
08:24:28 <Guest70406> So decode the string to Value
08:24:55 <Guest70406> And then do what with that Value, given I have written a Parser MyType?
08:25:14 <ertes-w> you don't use it
08:25:22 <ertes-w> Guest70406: are you familiar with lenses?
08:25:54 <Guest70406> I have read through the lens tutorials, but not used them properly
08:26:11 <ertes-w> Franciman's solution gives you a traversal, so you can use toListOf, traverseOf, etc.
08:26:52 <Franciman> Guest70406, you get Maybe YourType
08:27:25 <ertes-w> no, you get a monoid
08:27:31 <Guest70406> OK, time to write some code to give it a try I think
08:27:33 <ertes-w> (^?) gives Maybe
08:28:18 <ertes-w> (^.) basically uses 'fold' on each point
08:28:44 <Franciman> ertes-w, (FromJSON v, ToJSON v) => Text -> IndexedLens' ValueIx (Maybe Value) (Maybe v)
08:28:52 <Franciman> this is the type. Doesn't this mean I get a Maybe
08:28:53 <Franciman> in the end?
08:29:10 <ertes-w> oh, it is…  i thought 'key' would return a traversal
08:29:37 <ertes-w> ah, you're in another library
08:29:40 <ertes-w> use lens-aeson
08:29:48 <Franciman> it's better?
08:29:58 <ertes-w> key :: AsValue t => Text -> Traversal' t Value
08:30:14 <ertes-w> better, and also maintained
08:30:22 <Franciman> thanks
08:30:49 <Franciman> so recapping for Guest70406
08:31:15 <Franciman> I think you can also do it without lens
08:32:04 <Franciman> I think you should do something like
08:32:33 <ertes-w> str ^? _Value . key "blah" . key "blubb" . _String :: Maybe Text
08:32:50 <aconz2> quick sanity check on this statement please: IO sequences effects in a total order for different file Handles (as to opposed to only being ordered wrt the same Handle)
08:33:14 <Franciman> withObject "Name" (\obj -> -- find the correct key and reuse withObject)
08:33:43 <ertes-w> or even: toListOf (_Value . key "blah" . key "blubb" . _Array . _String) :: [Text]
08:34:00 <ertes-w> that extracts a list of strings below "blah" below "blubb"
08:34:38 <Guest70406> Hmmm OK, thanks!
08:34:46 <ertes-w> aconz2: less convoluted, more general: IO sequences effects
08:34:50 <Guest70406> I'll try it both ways as a learning experience :)
08:35:08 <ertes-w> Guest70406: err, my last one is incorrect
08:35:21 <ertes-w> Guest70406: : toListOf (_Value . key "blah" . key "blubb" . _Array . _String) str :: [Text]
08:36:55 <aconz2> ertes-w: I'm specifically interested in whether that order is total or partial wrt something like a specific handle
08:39:57 <ertes-w> aconz2: as far as IO is concerned it's total
08:40:14 <ertes-w> aconz2: your OS can still make it partial due to buffering
08:42:26 <ertes-w> aconz2: one feature of monads is that the "interpreter" can only look at the "next command" (inner layer) once the "previous command" (outer layer) has yielded a result
08:42:59 <ertes-w> (c >> d)  -- the interpreter can only see 'd' once it has a result from 'c'
08:44:52 <ertes-w> aconz2: to learn more about why you can study free monads…  then think of IO as a massive free monad, which has all the different real-world effects encoded
08:47:19 <ongy> why does `cabal new-build` sometimes insist on dist dir to exist, but never put anything in there?
08:48:07 <glguy> ongy: Mine doesn't seem to exhibit that behavior
08:48:07 <ezyang> ongy: It's a bug
08:48:15 <ezyang> we haven't been able to figure out who is making the stupid 'dist' dir
08:48:39 <glguy> ezyang: Did it perhaps get fixed on the master branch?
08:48:45 <ezyang> maybe
08:48:57 <ezyang> but if so, probably by accident
08:50:18 <ongy> I have seen it both on (not 100% recent cabal-git) and just encountered it on debian stable, though there it could just be old
08:50:29 <ongy> it's not always that it insists on the dir, but sometimes it happens
08:50:58 <ongy> other question, any good way to get a better error than cabal just exiting when I it tries to compile a file? It may be inline-c that's messing it up here
08:51:59 <ezyang> you could crank up verbosity
08:52:22 <ezyang> post the log here and let us ogle it :)
08:54:49 <ongy> ahh, -v3 gives a bit more of log. I'll look into it myself and ask again if I can't see anything in there
08:57:39 <ongy> http://ix.io/D8X ok, I don't see it
09:17:44 <[Leary]> ongy: I googled ghc ExitFailure (-11), and it seems like it's a segmentation fault. Beyond that I have no idea.
09:18:40 <ongy> well, fun :)
09:19:06 <ongy> it happens as soon as I try to do the template haskell stuff :/
09:22:39 <edofic> Is there a way to get heap snapshots from a running program? I have a leak in a long running process and standard memory profiling to a file is very cumbersome
09:25:18 <ongy> ok, this makes no sense. ghc jumps into 0x0
09:25:49 <ongy> and of course if I simply try it on arch, everything works fine
09:27:19 <[exa]> oh the lowlevel trouble
09:27:29 * geekosaur wonders if that means some of the crash bugs in 8.2.1 were also in 8.0.1
09:27:36 <geekosaur> you might want to try 8.2.2 if possible
09:27:47 <[exa]> ongy: do you have the address of the jump instruction?
09:28:31 <ongy> no, I just threw valgrind on it to see if I see something funny
09:29:12 <[exa]> imho a delayed segfault. :]
09:30:10 <ongy> delayed?
09:31:15 <ertes-w> edofic: one option is https://hackage.haskell.org/package/ghc-datasize
09:31:55 <ertes-w> but it doesn't give you process-wide stats…  you have to be selective
09:32:36 <edofic> ertes-w: that will be hard. But it's a start. Thanks.
09:34:49 <[exa]> ongy: by waiting for the program to finish with valrind hooks :]
09:35:17 <[exa]> ongy: anyway, you'd probably want to run it in gdb to see where the exact failing instruction came from
09:35:20 <glguy> jle`: you around?
09:46:39 <ongy> works fine with ghc-8.2.2 bindist for debian 8 (on debian 9)
09:51:40 <int-e> :t (>>= sequence)
09:51:41 <lambdabot> (Traversable t, Monad m) => m (t (m a)) -> m (t a)
09:53:19 <int-e> (I actually just used ">>= sequence" in my code (with m = t = [])... and I don't recall doing that ever before.)
09:54:02 <fakenullie> > [[[1]]] >>= sequence
09:54:04 <lambdabot>  [[1]]
09:54:51 <fakenullie> :t sequence
09:54:52 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:55:08 <int-e> > [[[1,2],[3]],[[4],[5,6]]] >>= sequence
09:55:10 <lambdabot>  [[1,3],[2,3],[4,5],[4,6]]
09:55:23 * hackage trigger 1.0.2.0 - Trigger is a cross platform file system watcher for super fast build-and-restart workflows.  https://hackage.haskell.org/package/trigger-1.0.2.0 (rhyskeepence)
10:07:55 <Psybur> > sequence [[1,2],[3]],[[4],[5,6]]
10:07:57 <lambdabot>  <hint>:1:21: error: parse error on input ‘,’
10:08:13 <Psybur> Ops :D
10:09:19 <dminuoso> https://gist.github.com/anonymous/e44a753f729b3e99bcc929e9bca22f29 What the heck is happening here? Why is haskell seemingly inferring the type wrong?
10:09:53 <dminuoso> (I've reduced the implementation to just focus on types, so the behavior is silly and meaningless)
10:10:56 <lyxia> f y:stack ys = (f y):(stack ys)
10:11:24 <lyxia> "space" has higher precendence than any operator.
10:12:17 <lyxia> Note the last error: "In the second argument of ‘(:)’, namely ‘stack ys’"
10:12:30 <codeshot> dminuoso, should it be: f (y:stack) ys instead of f y:stack ys
10:15:04 <codeshot> yeah: haskell is parsing (f y):(stack ys) so it's decided that f takes one argument
10:15:09 <codeshot> that's my guess
10:15:16 <dminuoso> lyxia: Ahh! "The function ‘stack’ is applied to one argument" I can see this.
10:15:32 <dminuoso> lyxia: When you get such a wall of error, do you start at the top or the bottom (and what does the order of diagnostics mean?)
10:15:55 <codeshot> oh aha, lyxia also answered
10:16:07 <codeshot> You should add a type signature for f
10:16:38 <lyxia> dminuoso: usually the top one helps more
10:16:42 <dminuoso> codeshot: Yeah I realized this. Wasn't aware I could add type signatures inside that `where` block.
10:17:10 <codeshot> even in ghci: let {typsig; defn} and where {typesig; defn}
10:18:20 <dminuoso> Are all "blocks" introduced by where the same? i.e. if some `where` block inside a function definition equivalent to a `where` block in a module definition?
10:19:34 <dminuoso> lyxia: It's a bit confusing, because I thought by defining `f stack@(pt1:pt2:pts) r@(y:ys)` haskell would know this to be [t] -> [t] -> ??? at least
10:20:52 <mnoonan> dminuoso: according to 9.5 in the Haskell98 report, the module 'where' is distinct https://www.haskell.org/onlinereport/syntax-iso.html
10:20:58 <Psybur> Wouldnt that be [t0] -> [t1] ?
10:21:13 <dminuoso> Psybur: oh right.
10:22:02 <lyxia> dminuoso: yes that's quite surprising.
10:22:50 <lyxia> I guess that there is no guarantee on where the compiler takes the type from unless you provide an explicit signature
10:26:19 * hackage grakn 0.3.0 - A Haskell client for Grakn  https://hackage.haskell.org/package/grakn-0.3.0 (graknlabs)
10:31:18 <aberrant> how do I install Data.List.Ordered via stack?
10:31:51 <lyxia> stack install data-ordlist
10:31:57 <aberrant> ah.
10:32:03 <aberrant> how would I know that?
10:32:23 <dminuoso> aberrant: If you look on hackage you can see the package name
10:32:31 <aberrant> ok, thank you.
10:33:04 <lyxia> aberrant: If you don't know the package you can look on hayoo http://hayoo.fh-wedel.de/?query=Data.List.Ordered
10:33:14 <mnoonan> or put it in your build-depends in your cabal file (stack will install it automatically from there)
10:40:28 <Guest191> I'd like to write a function `howMany`, that takes a function `List a -> Bool`, that returns the length of the input to the function argument. I.e. `howMany :: ([a] -> Bool) -> Int`
10:41:11 <Guest191> e.g. howMany (\[1,2,3] -> False) ==> 3 , howMany (\[1] -> False) ==> 1, howMany (\[] -> False) 0
10:41:34 <Guest191> typo.. howMany (\[] -> False) == 0
10:41:37 <Guest191> typo.. howMany (\[] -> False) ==> 0
10:42:12 <mnoonan> Guest191: that doesn't really make sense.. the function doesn't contain a list in any sense, so what would the length be measuring?
10:42:16 <texasmynsted> if I want to install a global ghc and cabal, I can use haskell stack to simply install these executables into my home directory, right?
10:42:30 <texasmynsted> then use them w/o stack?
10:42:51 <Guest191> mnoonan: it would be measuring the length of the input list to the function argument.
10:43:27 <Guest191> howMany (\["o","m","n"] -> "hello") ==> 3
10:44:26 <mnoonan> Guest191: what you are writing isn't valid code, so I still don't know what you want exactly. what do you want "howMany (\_ -> False)" to do?
10:45:05 <Guest191> mnoonan: hmm yeah, true.
10:45:11 <Guest191> more thinking needed...
10:46:44 <Psybur> Guess you cant pattern match on function arguments :D?
10:46:57 <Psybur> case f of (\x -> _) -> 1 :D?
10:47:23 <Psybur> Thatd be pretty cool.
10:48:02 <marvin3> if that was valid it would catch all functions, so you might as well replace it with 1 :)
10:48:14 <Psybur> Heh youre right
10:49:02 <Psybur> Repeatedly try to uncurry the function until you get an exception? :D
10:52:08 <Psybur> Suppose you cant make a function that does that since the type changes each time :P
10:53:11 <Cale> You can't pattern match on stuff that you don't have
10:53:37 <acowley> Should dante be able to offer completions given a qualified module name?
10:53:40 <Cale> When you have a function A -> B, you don't have a value of type A, the function demands a value of type A in order to be applied
10:54:17 <Cale> (and any value of type A ought to do, even if the function might fail to operate correctly on some)
10:54:28 * hackage byteunits 0.4.0.1 - Human friendly conversion between byte units (KB, MB, GB...)  https://hackage.haskell.org/package/byteunits-0.4.0.1 (chrissound)
10:56:44 <Psybur> Is there anyway to use recursive data types to do something like howManyArgs f n = howManyArgs (uncurry f) (n+1) ?
10:57:49 <glguy> data IntFun = Done Int | Fun (Int -> IntFun)
10:58:18 <glguy> thought that version allows the "arity" to vary by the earlier function arguments
10:58:54 <s4ke> Psybur: more success with your parmap?
10:59:03 <Psybur> s4ke, no put it on hold for a sec
10:59:07 <glguy> data IntFun a = Done a | AddArg (IntFun (Int -> a))
10:59:11 <glguy> AddArg (AddArg (Done (+))) :: IntFun Int
10:59:25 <Psybur> Tried chunking and statet and untilM, got in over my head heh
10:59:38 <s4ke> Psybur: StateT for what reason :D?
11:00:03 <Psybur> At the end I was going to try to repeatedly create chunks of 100 until it was all mappended together
11:00:19 <s4ke> ignore the chunking for the first version
11:00:20 <Psybur> So after chunking by 100, and parMapping, I was going to then repeatedly rechunk and mappend
11:00:58 <monochrom> @type let h f n = h (uncurry f) (n+1) in h
11:00:59 <lambdabot> error:
11:00:59 <lambdabot>     • Occurs check: cannot construct the infinite type: a1 ~ (a1, b1)
11:00:59 <lambdabot>       Expected type: ((a1, b1) -> c1) -> t2 -> t3
11:01:26 <glguy> > let howManyArgs :: IntFun a -> Int; howManyArgs x = case x of Done{} -> 0; AddArg x -> 1+howManyArgs x in howManyArgs (AddArg (AddArg (Done (+))))
11:01:28 <lambdabot>  2
11:01:34 <fakenullie> :t uncurry
11:01:35 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:01:51 <fakenullie> :t uncurry const
11:01:53 <lambdabot> (c, b) -> c
11:02:19 <fakenullie> > uncurry const 1 2
11:02:21 <lambdabot>  error:
11:02:21 <lambdabot>      • Could not deduce (Num t0)
11:02:21 <lambdabot>        from the context: (Num (t -> t1, b), Num t)
11:02:23 <Psybur> glguy, if only functions also had data constructors
11:02:25 <fakenullie> > uncurry const (1, 2)
11:02:27 <lambdabot>  1
11:02:28 <Psybur> Thats be interesting
11:02:43 <s4ke> Psybur: take a look at what Eden does https://hackage.haskell.org/package/edenskel-2.1.0.0/docs/Control-Parallel-Eden-MapReduce.html
11:02:59 <fakenullie> :t const
11:03:00 <lambdabot> a -> b -> a
11:03:00 <s4ke> i guess that could help
11:03:38 <s4ke> huh funny. uncurry const = fst
11:03:45 <s4ke> didnt think of it that way :D
11:05:46 <fakenullie> > uncurry (flip const) (1, 2)
11:05:48 <lambdabot>  2
11:05:55 <fakenullie> @src fst
11:05:55 <lambdabot> fst (x,_) = x
11:06:17 <Psybur> @s4ke, looks like the reduce phase isnt parallel, https://hackage.haskell.org/package/edenskel-2.1.0.0/docs/src/Control-Parallel-Eden-MapReduce.html#parMapRedr
11:06:17 <lambdabot> Unknown command, try @list
11:06:43 <Psybur> Think thats the part thats getting me :D
11:06:45 <s4ke> you mean the final reduce phase
11:06:47 <s4ke> ?
11:07:03 <Psybur> Yes, looks like theyre just doing fold
11:07:28 <s4ke> Psybur: welp. in every node of the parmap one does fold
11:07:48 <s4ke> if you want to do parallel folding, lists are a bad choice
11:08:04 <Psybur> Whats a better alternative?
11:08:08 <s4ke> for that you probably want random access
11:08:11 <s4ke> Arrays
11:08:21 <fakenullie> reduce operation would have to be associative for parallelism
11:08:29 <s4ke> Psybur: https://hackage.haskell.org/package/array-0.5.2.0/docs/Data-Array.html
11:08:35 <Psybur> Yes, theyre associative. Its on a monoid
11:08:46 <Psybur> Just mappend
11:09:19 <s4ke> can i take alook at your code again
11:09:23 <s4ke> so i dont recommend wrong stuff
11:09:26 <s4ke> Psybur: ^
11:09:29 <fakenullie> Sequence is good for concatenation, but probably bad for everything else
11:09:36 <Psybur> Lets see if I still have the original heh
11:10:19 <Psybur> s4ke, https://hastebin.com/tagihumica.hs
11:10:20 <s4ke> Psybur: but really, the final fold phase should not matter
11:10:39 <Psybur> Even if mappend is computationally heavy?
11:10:44 <s4ke> yeah
11:10:46 <s4ke> ah wait
11:10:49 <s4ke> if you want chunking
11:10:54 <s4ke> second
11:10:57 <s4ke> you need magic
11:12:14 <s4ke> maybe at least
11:12:18 <s4ke> take a look at https://hackage.haskell.org/package/edenskel-2.1.0.0/docs/Control-Parallel-Eden-Auxiliary.html shuffle
11:13:32 <Myrl-saki> What do you call an algorithm that relies on an ordered list?
11:13:37 <Myrl-saki> Err
11:13:44 <Myrl-saki> What do you call a search algorithm*
11:13:59 <fakenullie> binary search
11:14:18 <mud> Myrl-saki: No specific name, AFAIK.
11:14:19 <Myrl-saki> fakenullie: Yeah, but I'm linearly reading from the start.
11:14:29 <mud> fakenullie: There are others
11:14:32 <Myrl-saki> I guess I'll just call it linear searching algorithm?
11:14:33 <fakenullie> then you have to read everything
11:14:36 <s4ke> Psybur: looking at your code you do not really do "reduce", you only transform a into a monoid m
11:14:47 <s4ke> and then you append them
11:14:48 <monochrom> linear search?
11:15:08 <Psybur> Well in this case reduce is mappend
11:15:09 <s4ke> or am i missing something?
11:15:10 <Myrl-saki> monochrom: Yeah, makes sense.
11:15:13 <s4ke> ah ok
11:15:17 <fakenullie> Myrl-saki: linear search does not depend on ordering
11:15:36 <Myrl-saki> fakenullie: It may.
11:15:42 <Psybur> maybe parFoldMap is better than parMapReduce ;p
11:15:55 <Psybur> Or is it concatMap
11:15:56 <reactormonk> Any libraries with haskell bindings I could use to make a screensaver for xorg?
11:16:03 <Psybur> :t concatMap
11:16:04 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
11:16:16 <Psybur> nope :D
11:16:18 <Psybur> :t foldMap
11:16:19 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:16:24 <mud> Some linear searches can. The common case would be if you know something about the thing you're searching for, so you can tell past a certain point that you can stop searching.
11:16:24 <s4ke> but parMappend will never be fast tbh in that state as you spawn the stuff yes, but in order to construct the things i guess you get mostly linear code
11:16:34 <mud> Which wouldn't really make sense if the input weren't ordered, usually.
11:16:35 <Myrl-saki> reactormonk: Check xmonad's deps and there's also xhb. They both require knowledge of Xlib/XCB..
11:17:18 <fakenullie> mud: well, right
11:17:28 <s4ke> and as i said take a look at rparWith
11:17:33 <s4ke> % :t rparWith
11:17:33 <yahb> s4ke: rparWith :: Strategy a -> Strategy a
11:17:47 <s4ke> % :t rparWith rdeepseq
11:17:47 <yahb> s4ke: rparWith rdeepseq :: NFData a => Strategy a
11:17:51 <s4ke> especially
11:27:10 <dminuoso> Is there some neat way to express this way of comparing shorter or more elegantly? https://gist.github.com/anonymous/136d9c871a5c13cc558c1f80ba44e87d
11:27:20 <dminuoso> In particular the pattern matching feels wrong.
11:27:33 <glguy> compare x1 x2 <> compare y1 y2
11:28:13 <fakenullie> > EQ <> GT
11:28:15 <lambdabot>  GT
11:28:30 <fakenullie> I guess it's not commutative
11:28:38 <fakenullie> > GT <> LT
11:28:39 <dminuoso> glguy: Great, thanks. :)
11:28:40 <lambdabot>  GT
11:28:48 <Squarism> My threading is getting a bit complicated. I wonder if theres some way of logging an overview of what threads AND/OR channels are currently running?
11:28:54 <dminuoso> glguy: I expected it to be more elegant, but not that elegant.
11:29:50 <fakenullie> > compare GT GT
11:29:52 <lambdabot>  EQ
11:30:43 <monochrom> Squarism: Does https://hackage.haskell.org/package/threadscope look like it?
11:31:11 <monochrom> Actually https://hackage.haskell.org/packages/search?terms=threadscope so you have more choices.
11:31:39 <dminuoso> Ordering -> Ordering -> Ordering should have made me think of monoid (hoogle didnt produce any results)
11:32:35 <Squarism> monochrom, looks like what im looking for! Thanks
11:33:05 <fakenullie> :t GT
11:33:06 <lambdabot> Ordering
11:33:56 <fakenullie> does hoogle find typeclasses methods?
11:39:34 <tesmarss> Hi all, I am going through the haskell book and have a question I posted here https://stackoverflow.com/questions/47849407/coarbitrary-in-haskell
11:39:56 <tesmarss> I think I am a little confused about Type/Data constructors here
11:46:52 <konstantin_tereh> Hello
11:52:24 <shapr> hi
12:03:59 * hackage LambdaHack 0.7.1.0 - A game engine library for roguelike dungeon crawlers  https://hackage.haskell.org/package/LambdaHack-0.7.1.0 (MikolajKonarski)
12:04:48 * hackage Allure 0.7.1.0 - Near-future Sci-Fi roguelike and tactical squad game  https://hackage.haskell.org/package/Allure-0.7.1.0 (MikolajKonarski)
12:14:35 <Sonarpulse> can persistent let me use SQL enums for enums?
12:14:37 <Sonarpulse> that would be nice
12:15:06 <dmwit> tesmarss: Why does it seem contradictory to you that a single type might have both an Arbitrary and a CoArbitrary instance?
12:15:29 <dmwit> tesmarss: (Does it also seem contradictory that a single type might have both a Num and an Eq instance, say?)
12:16:59 <dmwit> tesmarss: You seem to be so confused that you don't even know what you're confused about. =P
12:17:07 <monochrom> Perhaps some wrong intuition about "'co' means opposite" and further wrong intution about "'opposite' means negation".
12:17:12 <dmwit> tesmarss: Which I'm sorry to hear about, but it does make it hard to help you.
12:17:40 <monochrom> The opposite of North Pole is South Pole. This has never prevented Earth from possessing both.
12:19:26 <asheshambasta> I was going through "Real World Haskell" and found that one of the examples in the book getModificationTime (from System.Directory) now returns `Data.Time.Clock.UTC.UTCTime` whereas the examples in the book use System.Time (ClockTime).
12:19:32 <hoon> looking for some code criticism -- nothing fancy: http://lpaste.net/360909
12:19:33 <asheshambasta> Does anyone know the rationale behind this?
12:22:39 <mnoonan> hoon: maybe have evalArgs return a Maybe (a,a,a)? it's a bit of a smell that it gives a "Maybe something", but then there are further conditions on "something" that are expected to hold
12:25:32 <hoon> mnoonan: ok
12:25:36 <dmwit> hoon: There is now a `readMaybe` that you might like in place of `parseInt`.
12:25:38 <Wizek> Hello. Would anyone know why this fails? `nix-shell -p 'haskell.packages.ghc822.ghcWithPackages (p: with p; [(callHackage "debug" "0.0.1" {})])' --run 'ghci'
12:25:42 <dmwit> ?hoogle readMaybe
12:25:42 <lambdabot> Text.Read readMaybe :: Read a => String -> Maybe a
12:25:42 <lambdabot> Text.Read.Compat readMaybe :: Read a => String -> Maybe a
12:25:42 <lambdabot> Extra readMaybe :: Read a => String -> Maybe a
12:26:15 <tesmarss> dmwit: I understand a single type can have multiple typeclass instances
12:26:26 <hoon> dmwit: i'll check that out
12:26:46 <nf7> Is it conventional to leave off spaces after the commas in a list literal? For example: [1,2,3] instead of [1, 2, 3]?
12:26:58 <dmwit> I usually include spaces.
12:27:04 <Wizek> I get `tar: */debug/0.0.1/debug.cabal: Not found in archive \n builder for ‘/nix/store/csgyr48lcn8b10jih0d45l44nm7s4klw-all-cabal-hashes-component-debug-0.0.1.drv’ failed with exit code 2`
12:27:08 <tesmarss> what I don't understand is whether the *a* in *Comp a* is pointint to the *function itself* or the *type the function takes and returns*
12:27:23 <dmwit> The latter.
12:27:52 <grokkingStuff> hi there! anyone here have experience with multiple parsing libraries?
12:28:14 <grokkingStuff> which one would you recommend?
12:28:17 <dmwit> `Comp a` is roughly equal to `a -> a`. There's just some newtype wrapping/unwrapping nonsense visible in the Haskell code (but not in the machine code) to convert between the two.
12:28:21 <tesmarss> dmwit: ok, then why use coArbitrary? I thought that coArbitrary was used for generating the *function itself*
12:28:36 <dmwit> tesmarss: It is. And you are generating the function itself.
12:28:54 <nf7> grokkingStuff: Parsing what?
12:28:56 <dmwit> tesmarss: `f` is the function.
12:29:13 <dmwit> tesmarss: `f :: a -> a`, and `Comp f :: Comp a`.
12:29:25 <hoon> mnoonan: is there a better way to handle the eval than what I have now?
12:29:33 <grokkingStuff> nf7: Parsing "mini languages" that have data stored in a certain format.
12:29:57 <dmwit> hoon: Other than `readMaybe`, I think this code is clean, simple, and idiomatic.
12:30:25 <hoon> mnoonan -- maybe sequence, then exact via (!!)?
12:30:43 <mnoonan> !! is never the answer :)
12:30:47 <dmwit> hoon: If you want to return a triple, I would suggest doing it something like this:
12:30:48 <hoon> err: sorry, mapM
12:31:09 <dmwit> hoon: foo [a,b,c] = liftA3 (,,) (readInt a) (readInt b) (readInt c); foo _ = Nothing
12:31:19 <tesmarss> dmwit: ok then my confusion stems from why/how can there be *Comp a*, where a refers to the value the function takes, but then we put a constrain on *a* saying that it has to be something that we can generate function from. Unless CoArbitrary is saying (when applied to a type constraint) that I can generate a function that receives and returns this type
12:31:20 <dmwit> hoon: But in my opinion this is not so critical.
12:31:49 <tesmarss> dmwit: I guess I Was assuming that CoArbitrary had to refer to the function, not the type
12:31:55 <mnoonan> (,,) <$> readInt div1 <*> readInt div2 <*> readInt max -- hoon, or what dmwit said
12:32:21 <hoon> fair enough
12:33:01 <dmwit> tesmarss: The relevant instance is `instance (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)`.
12:33:12 <tesmarss> dmwit: so is all Coarbitrary saying is that "if you constrain a variable, I can generate a function that takes/returns that type"
12:33:30 <hoon> i think I prefer the liftA2, though probably because that's slightly easier for me to understand than the <$> and <*> syntax at my stage
12:33:32 <dmwit> tesmarss: No. You need *both* a `CoArbitrary` and an `Arbitrary` constraint to be able to generate a function type.
12:34:01 <tesmarss> dmwit: I see, Arbitrary on the return at minimum
12:34:12 <mnoonan> hoon: I think I'm more allergic to the liftA* than most people are
12:34:16 <dmwit> tesmarss: That is why your instance demands both `CoArbitrary a` and `Arbitrary a` -- the former so that we know we can generate functions that take `a` as an argument, and the latter so that we know we can generate functions that return `a`.
12:35:16 <tesmarss> dmwit: so putting CoArbitrary on a type says "I can generate functions that take this type"
12:35:43 <dmwit> tesmarss: Well, putting `CoArbitrary` on a type says "I can generate functions that take this type and return a type that is an instance of `Arbitrary`".
12:36:25 <tesmarss> dmwit: it's starting to make more sense
12:37:07 <dmwit> tesmarss: I encourage you to write a little bit about your new understanding and post it as an answer to your question (this is considered perfectly polite on SO).
12:38:03 * hackage svg-tree 0.6.2.1 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.6.2.1 (VincentBerthoux)
12:39:21 <aberrant> Is there a faster way to do this? http://lpaste.net/360912
12:39:31 <aberrant> that is, there is a faster way to do this, but I don't know what it is :)
12:41:02 <Average-user> since haskell is lazy, in the list comprehension you should check, what is easier to check first
12:41:34 <aberrant> probably the differences.
12:41:41 <tesmarss> dmwit: good to know; I guess I need to dive deeper into exactly *how* CoArbitrary works, but you've helped to clear up
12:41:49 <tesmarss> dmwit: some confusion
12:42:36 <nf7> I noticed this function parameter pattern matching: `f (x:[]) = ...`. Is `f [x] = ...` equivalent?
12:42:43 <monochrom> I wouldn't use laziness as a reason. Any short-circuiting scheme would benefit from checking easy checks first. This includes C's && and ||
12:42:49 <lyxia> aberrant:  x : xs <- tails fourDigitPrimes, y : ys <- tails xs, z <- ys
12:43:11 <lyxia> aberrant: you can also check isPermutationMember y x before looping on z.
12:43:19 * hackage hakyll 4.10.0.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.10.0.0 (JasperVanDerJeugt)
12:43:24 <aberrant> lyxia: tails again. cool. Thank you.
12:43:36 <lyxia>  ..., isPermutationMember y x, z <- ys, ...
12:43:47 <aberrant> I didn't know you could mix other things within the <- assignments
12:45:39 <aberrant> lyxia: where is tails defined? The only thing I see is
12:45:39 <aberrant> tails :: ByteString -> [ByteString] Source #
12:45:40 <aberrant> O(n) Return all final segments of the given ByteString, longest first.
12:45:51 <lyxia> aberrant: instead of checking whether y and z are permutations, you could just iterate on the permutations of x directly
12:46:00 <lyxia> Data.List
12:46:10 <lyxia> @hoogle tails
12:46:10 <lambdabot> Data.List tails :: [a] -> [[a]]
12:46:11 <lambdabot> Data.List.NonEmpty tails :: Foldable f => f a -> NonEmpty [a]
12:46:11 <lambdabot> GHC.OldList tails :: [a] -> [[a]]
12:46:15 <aberrant> ah, thanks
12:47:37 <hits1911> Why can't we use subtraction as a function like in (*2), (+3), (/4)? Is (flip (-) 2) the simplest solution for that?
12:48:10 <cocreature> hits1911: because prefix - is also used for negative numbers
12:48:12 <dminuoso> hits1911: How would you express a negative number?
12:48:23 <cocreature> hits1911: the easiest solution is to use "subtract 2"
12:49:42 <hits1911> cocreature: oh thank you.
12:50:02 <hits1911> dminuoso: you're right. there would be ambiguity then.
12:52:08 <EvanR> f (+1) (subtract 1) :(
12:52:23 <aberrant> lyxia: that was perfect. Thank you.
12:52:32 <EvanR> f (add 1) (sub 1)
12:53:06 <aberrant> lyxia: http://lpaste.net/360913 :)
12:54:13 <steve___> Quick question. Anyone has an idea on writing a parallel version of sortBy for mutable vectors?
12:54:25 <steve___> sortBy ::   (Control.Monad.Primitive.PrimMonad m,    Data.Vector.Generic.Mutable.Base.MVector v e) =>   VS.Comparison e   -> v (Control.Monad.Primitive.PrimState m) e -> m ()   	-- Defined in ‘Data.Vector.Algorithms.Intro’
12:54:34 <steve___> I am spending hours on google and found nothing
12:54:54 <EvanR> parallel and mutable sounds iffy as hell
12:55:10 <steve___> My Vectors have a length of 1000 elements (so maybe not speedup possible)
12:55:17 <steve___> *no
12:55:54 * hackage composition-prelude 0.1.1.1 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-0.1.1.1 (vmchale)
12:56:20 <monochrom> I would start by learning parallelized sorting algorithms in general (ie not restricting myself to any language --- even pseudocode is fine).
12:57:17 <lyxia> > (-2) 44
12:57:19 <lambdabot>  -46
12:57:23 <steve___> Maybe it is faster to transform the vector into a pure one, then sort it, then convert back to mutable one
12:57:26 <lyxia> ah almost...
12:57:38 <int-e> > (-2+) 44
12:57:39 <lambdabot>  42
12:58:13 <steve___> Rolling my own sorting function didn't seem so good after reading this:
12:58:13 <steve___> http://flyingfrogblog.blogspot.co.at/2010/08/parallel-generic-quicksort-in-haskell.html
12:58:16 <aberrant> why is (-2) 44 == -46?
12:58:36 <steve___> Is there really no library for sorting vectors in parallel on github??
12:58:47 <aberrant> I'm getting an error with that in ghci
12:59:00 <lyxia> aberrant: someone defined a Num instance for functions
12:59:13 <aberrant> oh.
12:59:51 <lyxia> > (-2) 44
12:59:53 <lambdabot>  46
12:59:57 <int-e> > subtract 2 44
12:59:59 <lambdabot>  42
13:00:09 <aberrant> > (-5) 44
13:00:11 <lambdabot>  49
13:00:14 <int-e> that's the official Haskell 98 way, I think.
13:00:24 <int-e> (the subtract one)
13:00:24 <dminuoso> lyxia: Im guessing lambdabot runs with a couple extensions? It seems at least FlexibleContexts and AllowAmbiguousTypes would need to be present for this.
13:00:44 <aberrant> wait. the earlier one showed -46, and now this one is showing 46
13:00:46 <aberrant> why?
13:01:04 <aberrant> > (2) 44
13:01:05 <lambdabot>  42
13:01:09 <aberrant> > (-2) 44
13:01:11 <lambdabot>  42
13:01:16 <lyxia> aberrant: I keep fixing it
13:01:21 <int-e> dminuoso: it doesn't have AllowAmbiguousTypes. FlexibleContexts is there.
13:01:25 <aberrant> oh, heh, you're changing the code out from under me.
13:01:34 --- mode: cherryh.freenode.net set +o ChanServ
13:01:34 <hits1911> (-2) 44 is an error for me. (-2+) 44 is fine, though.
13:01:47 <Tuplanolla> What's the final answer, lyxia?
13:01:59 <int-e> instance (Num a, a ~ b) => Num (a -> b) where fromInteger x y = y - fromInteger x ... oh well
13:03:10 <dminuoso> int-e: Is there a way to learn more about lambdabot? It's command, what it's configured with, what its Prelude is, etc?
13:03:23 <int-e> @where L.hs
13:03:23 <lambdabot> what lambdabot has in scope is at http://silicon.int-e.eu/lambdabot/State/Pristine.hs
13:04:30 <int-e> (the current version isn't publicly accessible, though I could make it so if people wish... it raises potential privacy concerns so I erred on the safe side.)
13:04:40 <eschnett> there should be a GUI for lambdabot
13:04:47 <int-e> Pristine.hs is what you get after @undef
13:05:08 <Tuplanolla> Rather someone should refactor lambdabot's plugins into standalone tools.
13:05:22 <Tuplanolla> Some already are.
13:07:24 <XpYunkr> Hello can someone also ask beginner questions here, or better to ask someone in private?
13:07:38 <glguy> here
13:08:55 <lyxia> > (2 40, (-2) 44)
13:08:57 <lambdabot>  (42,42)
13:09:12 <int-e> @undef
13:09:12 <lambdabot> Undefined.
13:09:16 <int-e> > (2 40, (-2) 44)
13:09:17 <lambdabot>  error:
13:09:18 <lambdabot>      • Could not deduce (Num t0)
13:09:18 <lambdabot>        from the context: (Num (t2 -> b), Num (t -> a), Num t2, Num t)
13:09:30 <int-e> there, back to normal, for now
13:09:36 <Tuplanolla> That should be `(80, 42)`.
13:09:51 <fakenullie> no, i
13:10:00 <fakenullie> it's 44 applied to -2
13:10:11 <glguy> No, f x   is f applied to x
13:10:20 <Tuplanolla> I'm going to put that into my default definitions.
13:10:20 <fakenullie> ok
13:10:48 <int-e> Tuplanolla: please let us know when you figure out that this is a terrible idea
13:11:10 <lyxia> http://lpaste.net/360915 My instance for the record
13:12:08 <lyxia> It looks like (-2) gets desugared to negate (fromInteger 2) instead of just fromInteger (-2)
13:12:23 <lyxia> ah, because - is negate
13:12:23 <glguy> Throw in -XNegativeLiterals
13:12:39 <lyxia> glguy: thanks
13:12:59 <aberrant> erm
13:13:02 <mniip> int-e, there's something peculiar about that safehaskell pragma
13:13:08 <mniip> safety before all...
13:13:23 <aberrant> does the ParallelListComp Language pragma imply multithreading?
13:13:31 <glguy> no
13:13:37 <aberrant> darn.
13:13:40 <int-e> mniip: it's THE IMPORTANT PRAGMA.
13:13:47 <mniip> nah
13:13:50 <mniip> :)
13:14:21 <mniip> % unsafeCoerce (putStrLn "hi") ()
13:14:21 <yahb> mniip: hi; [Segmentation fault]
13:14:39 <int-e> > [(x,y) | x <- [0..] | y <- "abcdefghi"] -- "parallel" list comprehension
13:14:41 <lambdabot>  [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h'),(8,'i')]
13:14:54 <int-e> it's just syntax for zipping lists.
13:16:45 <nf7> I'm trying to double the value of every second digit starting from the right of a list using pattern matching. So `dbl [1,1,1,1] == [2,1,2,1]`. I understand how to do this if it started from the left side, but I'm lost on what to do for starting on the right.
13:17:36 <nf7> I don't really want to be told the answer. Maybe there's something about pattern matching that I'm not thinking about.
13:18:30 <c_wraith> nf7, nah. pattern matching will start from the left. think about creating an auxiliary function that returns extra information in the recursive part.
13:21:04 <XpYunkr> Is there a way in ghci to find out the hierarchy of types?
13:21:16 <XpYunkr> Like even numbers is a subset of all numbers.
13:21:49 <EvanR> there isnt a hierarchy of types
13:21:52 <int-e> XpYunkr: that's pretty easy; there are no subtypes (now type classes...)
13:23:03 <Tuplanolla> @let instance (Ord a, Num a, a ~ b) => Num (a -> b) where fromInteger x y | y < 0 = y - fromInteger x | otherwise = y * fromInteger x; negate x y = y * 2 + x (negate y)
13:23:04 <lambdabot>  .L.hs:159:10: warning: [-Wmissing-methods]
13:23:04 <lambdabot>      • No explicit implementation for
13:23:04 <lambdabot>          ‘+’, ‘*’, ‘abs’, and ‘signum’
13:23:20 <nf7> c_wraith: I'm not totally sure I understand.
13:23:21 <Tuplanolla> > ((-42) 13, 42 13) -- This should do.
13:23:23 <lambdabot>  error:
13:23:23 <lambdabot>      • Could not deduce (Num t0)
13:23:23 <lambdabot>        from the context: (Num (t2 -> b), Num (t -> a), Num t2, Num t)
13:24:00 <fakenullie> what should it do
13:24:16 <Tuplanolla> Produce `(13 - 42, 42 * 13)`.
13:25:03 <fakenullie> @let (−) = subtract
13:25:04 <lambdabot>  Defined.
13:25:17 <fakenullie> ((−42) 13, 45 13)
13:25:27 <fakenullie> > ((−42) 13, 42 13)
13:25:30 <lambdabot>  error:
13:25:30 <lambdabot>      • Could not deduce (Num t0)
13:25:30 <lambdabot>        from the context: (Num (t -> b), Num t, Num a)
13:25:34 <fakenullie> > ((−42) 13, 42)
13:25:36 <lambdabot>  (29,42)
13:26:03 <fakenullie> @let (−) = flip subtract
13:26:04 <lambdabot>  .L.hs:159:1: error:
13:26:04 <lambdabot>      Multiple declarations of ‘−’
13:26:04 <lambdabot>      Declared at: .L.hs:158:1
13:26:07 <fakenullie> @undefined
13:26:07 <lambdabot> Undefined.
13:26:10 <fakenullie> @let (−) = flip subtract
13:26:12 <lambdabot>  Defined.
13:26:15 <fakenullie> > ((−42) 13, 42)
13:26:17 <lambdabot>  (-29,42)
13:27:07 <fakenullie> oh, instance
13:27:21 <glguy> You can play with lambdabot using /msg in private
13:27:26 <fakenullie> sorry
13:27:56 <c_wraith> nf7, the only way you can figure out if you should be multiplying by 2 or not is to have gone all the way to the end of the list, and then passing information back. you will need to write some additional helper function (or functions) to do that while keeping the same type at the entry point.
13:28:38 <nf7> c_wraith: This is the very first question on the very first assignment in a Haskell/Functional programming course I'm taking. Seems kind of insane.
13:28:41 <dmwit> nf7: I don't know if you got an answer, but yes, `f (x:[]) = ...` and `f [x] = ...` are equivalent.
13:28:53 <nf7> dmwit: Thanks.
13:30:32 <c_wraith> nf7, it depends on your experience with other programming, I guess. if you're already comfortable with recursion, it's a small modification to starting from the left.
13:30:34 <lyxia> Tuplanolla: add dummy implementations for the missing methods because lambdabot has -Werror
13:31:27 <nf7> c_wraith: Yeah I guess I'm familiar with recursion but I can't think of the answer to this.
13:31:49 <Tuplanolla> I'll have to refine this later. It's a good addition to GHCi.
13:32:07 <c_wraith> nf7, I think the important part is that you're right. you're not missing something about how pattern matching works. you're just trying to fit the solution into a framework too small to do the job.
13:32:37 <nf7> c_wraith: Ok. Let me write the answer iteratively in another language and see if it sparks my brain.
13:32:37 <c_wraith> nf7, you will need to expand the framework a bit, then do some adapting to keep the same interface
13:33:00 <dmwit> nf7: You might consider first writing a function that returns *both* lists: one where the odd indices from the right are doubled, and one where the even indices from the right are doubled.
13:34:25 <monochrom> I agree it is a pretty hard question. To elaborate, both "double every number in the list" and "double every other number in the list, starting from the beginning" are pretty fair first-time exercises.
13:34:52 <c_wraith> nf7, another idea: write a function that tells you if the length of a list is even or odd.
13:35:02 <monochrom> But "starting from the end" requires cunning plans, not the least because our lists are single-directional singly-linked lists.
13:35:13 <nf7> c_wraith: Yeah that's what I was just thinking.
13:35:17 <dmwit> yes, cunning =)
13:35:20 <c_wraith> (without using "length")
13:35:27 <monochrom> Then again if it's "due in two weeks" it is OK.
13:35:43 <nf7> c_wraith: Well I know how to write my own length with pattern matching.
13:35:46 <dmwit> (I don't see why one might avoid using length, unless that's a prescribed rule from the assignment.)
13:36:22 <c_wraith> dmwit, it makes it fit the structure of one possible solution to the larger problem.
13:36:50 <monochrom> I know the context. The context is also wrongly set up.
13:37:05 <monochrom> The whole context is an example of XYX problems.
13:37:11 <c_wraith> ccn validation?
13:37:16 <monochrom> Yes.
13:37:29 <c_wraith> that's a really ugly beginner problem
13:37:31 <dmwit> c_wraith: Cool, now that you said that aloud, I retract my earlier suggestion of returning two lists. Thanks for the hint. =)
13:37:35 <amalloy> what is the right way to write to a Handle which may be closed? i'd like my program to act like /usr/bin/yes, outputting lines forever until the consumer closes the pipe. i've written: forever $ putStrLn =<< foo, but then my program ends with the error message "Main.hs: <stdout>: hPutChar: resource vanished (Broken pipe)"
13:38:13 <mniip> > over (traversed . Control.Lens.indices even) (* 2) [1,2,3,4,5]
13:38:16 <lambdabot>  [2,2,6,4,10]
13:38:19 <mniip> :D
13:38:33 <dmwit> amalloy: Catch the exception, I guess.
13:38:45 <mud> mniip: Clearly the expected answer xD
13:39:05 <c_wraith> I'm not even sure that's right. indices starts at the left...
13:39:16 <dmwit> mniip: But it's supposed to count from the end...
13:40:02 <int-e> I'm sure there's a "reversed" lens to help
13:41:03 <c_wraith> monochrom, is your approach to ccn verification to just start by reversing the list, since addition is commutative anyway?
13:41:57 <monochrom> No, my complaint and alternative have to be understood at a more holistic level.
13:41:57 <mniip> well!
13:42:01 <mniip> that's easily fixed
13:42:07 <mniip> > over (reversed . traversed . Control.Lens.indices even) (* 2) [1,2,3,4,5]
13:42:09 <lambdabot>  [2,2,6,4,10]
13:42:13 <mniip> well
13:42:14 <mniip> > over (reversed . traversed . Control.Lens.indices even) (* 2) [1,2,3,4]
13:42:16 <lambdabot>  [1,4,3,8]
13:42:42 <monochrom> The original problems first wrong turn is to convert 123456789 (say) to [1,2,3,4,5,6,7,8,9] as opposed to [9,8,7,6,5,4,3,2,1].
13:43:29 * dmwit . o O ( data Tsil a = Snoc (Tsil a) a | Lin )
13:43:34 <c_wraith> ah, little-endian
13:44:14 <monochrom> And this begets the second oddity of having to do every-second-item things but the anchor point is at the ending 9.
13:44:38 <monochrom> Do you now see what I mean by XYX problem?
13:45:13 <monochrom> "Yo dawg I heard you love processing lists backwards so I make you produce a list backwards so you can consume it also backwards".
13:45:17 <int-e> monochrom: do you mean conjugation...
13:45:24 <monochrom> Yes.
13:45:30 <c_wraith> eh. I don't think of the problem that way. I don't see a ccn as a number, I see it as a sequence of digits.
13:45:44 <c_wraith> so parsing it as a single number is weird to me.
13:45:51 <monochrom> But the original problem begins with 123456789 :: Int.
13:46:36 <monochrom> The whole design of the problem optimizes "intermediate representations should be intuitive to end users". The worst objective ever.
13:47:02 <monochrom> Therefore it sacrifices other more important principles such as "intermediate algorithms should be simple and obvious".
13:47:05 <mniip> that's a good point
13:48:24 <tomsen> hey guys, i have a stateT monad with a big record as state. i use "bigRecord <- ask" to get it, but then have to extract the field i want to have. is there a more convenient way to get the field directly like "d <- get duration" or sth?
13:48:37 <dmj`> tomsen: gets
13:48:39 <dmj`> :t gets
13:48:41 <lambdabot> MonadState s m => (s -> a) -> m a
13:49:23 <mniip> :t asks -- relevant
13:49:24 <lambdabot> MonadReader r m => (r -> a) -> m a
13:49:54 <nf7> Ok well I did it in C (and am remembering why I am interested in functional programming in the first place...): https://repl.it/repls/RoundMediumorchidFlicker
13:50:06 <nf7> Hasn't really given me any ideas of how I would do it the Haskell way though.
13:50:15 <dmj`> > flip execState (0,0) $ do { r <- (+1) <$> gets fst; put (r,r) }
13:50:17 <lambdabot>  (1,1)
13:50:25 <dmj`> tomsen ^
13:50:26 <tomsen> awesome, thank you dmj` !
13:50:36 <mniip> so I've been thinking, if we want to maintain a mutable structure that avoids making unnecessary copies,
13:50:44 <dmj`> tomsen: np
13:50:46 <monochrom> In C you have random-access array and it makes things really easy for this artificially obfuscated assignment.
13:50:54 <mniip> we could just mutate in-place if we made sure the old version isn't used anywhere, which,
13:51:01 <mniip> this is basically reinventing linear types isn't it
13:51:06 <grokkingStuff> any good tutorials on parsing? I'm stuck with parsing and i need a little help.
13:51:07 <monochrom> In Haskell we have arrays too and if you were to use Haskell arrays it would be just as easy.
13:51:20 <dmwit> nf7: So, a slight variation on my previous hint: consider writing a function `doubleEveryOtherHelper :: Num a => [a] -> (Bool, [a])` which returns both the list with the requisite doubling, and a `Bool` telling whether the list so far was even or odd length.
13:51:34 <monochrom> But the artificially obfuscated assignment also artificially require you to use singly-linked lists, and in the wrong order too.
13:51:50 <dmwit> (Or you could think about alternate types to `Bool` that might store this information. There are some pretty fun variants.)
13:51:50 <dmj`> grokkingStuff: can you paste your code?
13:51:52 <nf7> dmwit: Ah ok I forgot about being able to return multiple results like that.
13:52:19 <nf7> monochrom: Yes I really dislike contrived problems.
13:52:22 <grokkingStuff> dmj`: just trying to learn. trying to solve today's advent of code challenge.
13:52:29 <monochrom> Very few people actually appreciate how much damage this assignment does to both students and the name of functional programming.
13:52:40 <mud> I really have to go with monochrom on this one. Just reverse the thing, it makes the problem so much saner. It's not even a cheat, I would write actual code with the thing reversed as well. You never actually need it going the way it is.
13:52:50 <nf7> monochrom: Why the f is this the first question... It's mind boggling.
13:52:54 <monochrom> Because most people are easily nerd-sniped.
13:53:12 <nf7> monochrom: It makes me think the teacher is an asshole or something.
13:53:37 <monochrom> I really don't know. And byorgey is otherwise a pretty reasonable and sane person, too.
13:53:45 <mud> nf7: I've always assumed that during the actual class they had more experience by that point, if nothing else just by going through a full lecture and asking questions instead of quickly going through the notes.
13:53:54 <dmwit> Never blame malice for something that mere indifference suffices to explain.
13:54:12 <nf7> mud: Yeah probably.
13:54:20 <nf7> dmwit: Hah, true.
13:54:40 <dmwit> Or: perhaps the teacher hadn't even considered the alternative! Or perhaps they did, and had some rationale for keeping it that way which we will never hear because they are not here to defend themselves.
13:54:44 <mud> A similar explanation takes care of some stuff later on in the class as well, that's a bit harsh in its current format but probably wasn't in the original.
13:55:03 <grokkingStuff> dmj` : any good links?
13:55:17 * dmj` reaches deeply into haskell knapsack 
13:55:32 <mud> Well, they are "here"ish in a sense, but I'm not sure they're interested in defending it anyway, heh. It's been a few years, and I know I'd personally get annoyed defending 5 year old work output.
13:57:02 <dmwit> mud: Great point, too!
13:58:03 <dmj`> grokkingStuff: the parsec README seems to have good links, including one from RWH. https://github.com/haskell/parsec/blob/master/README.md . I do remember enjoying https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
13:59:20 <mud> nf7: But ya, that kind of thing is why I personally avoid recommending cis194 as an intro to haskell anymore. I consider http://haskellbook.com/ just plain better.
14:00:14 <monochrom> And I might actually buy and read Hutton's book and then decide whether I recommend it.
14:00:36 <nf7> mud: Oh geez. I keep hitting brick walls with every Haskell resource and then jump ship to another one. I'm so fatigued.
14:00:46 <monochrom> Actually at present I'm considering talking my department into obtaining an evaluation copy so I don't have to pay so soon. :)
14:00:52 <nf7> mud: I think I need to give cis194 more of a fair chance.
14:01:10 <monochrom> (Oh if I like it I'll eventually buy it.)
14:01:30 <f-a> is there a way to pager the output in ghci? Suppose I have an IO () function that prints lots of stuff
14:01:50 <XpYunkr> Can somebody point me to the problem here ?https://pastebin.com/UAYKcFcs
14:02:07 <amalloy> sum takes one argument, and you have passed it many
14:02:29 <f-a> XpYunkr: inded amalloy is correct
14:02:34 <Psybur> Is CIS194 specifically haskell or is it this? http://www.seas.upenn.edu/~cis194/spring15/
14:02:43 <f-a> remeber that "space" (function application) takes precedence over everything
14:02:59 <Psybur> Like is it just that website or would any college have that course number and it would be haskell
14:03:03 <XpYunkr> ah thanks
14:03:07 <f-a> a b c /= a (b c)
14:03:10 <f-a> you can solve by
14:03:12 <monochrom> I think you should nerd-snipe yourself and try to solve cis194 assignments as curiosity trick puzzles. Despite all my complaints, it is still not bad enough to be abandoned.
14:03:15 <f-a> > sum $ [1..10]
14:03:17 <lambdabot>  55
14:03:20 <mud> nf7: That's fine. It's not bad by any measure, it's just a tad painful here and there due to the format change mostly.
14:03:42 <Psybur> Is this the question? "Double the value of every second digit beginning from the right.
14:03:42 <Psybur> That is, the last digit is unchanged; the second-to-last digit is doubled;
14:03:43 <Psybur> the third-to-last digit is unchanged; and so on. For example,
14:03:43 <Psybur> [5,5,9,4] becomes [10,5,18,4]."
14:03:47 <Psybur> Sorry
14:03:47 <amalloy> f-a: a more compelling example would be one where the $ is needed
14:03:58 <f-a> amalloy: :P yup
14:04:44 <nf7> Psybur: The one you linked is two years newer. I wonder if it's worth switching to. At first glance it looks very similar.
14:04:46 <mud> Psybur: I'm personally referring to upenn's cis194 spring '13 class, which is available free online (the lecture notes and homeworks). At one point it was a very commonly recommended course for beginners, so its name gets shortened quite a lot.
14:04:55 <amalloy> > sum $ map (+ 1) [0..9]
14:04:57 <lambdabot>  55
14:05:34 <amalloy> > sum (map (+ 1) [0..9]) -- if you'd rather use parentheses
14:05:36 <lambdabot>  55
14:05:48 <mud> nf7: IIRC that's a bad idea, to completely switch. You could look at the exercises though. What the course actually teaches changed somewhere in there, and it seemed less useful for learning haskell as a beginner (I think the prereqs changed and probably some material got moved to those or something)
14:06:18 <nf7> mud: Are you saying that the '13 one is better than the '15 one?
14:06:25 <mud> nf7: Yes
14:06:49 <nf7> mud: Looks like there's a '14 one too.
14:06:58 <mud> I'd have to go look to figure out why, but I recall for sure that there was some concrete reason we didn't recommend the newer versions of the class even after they existed.
14:07:43 <mud> You could probably look at all of them though, just for reasons of getting extra exercises.
14:08:04 * hackage servant 0.12.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.12.1 (phadej)
14:08:12 <jle`> glguy: what's up?
14:10:20 <dminuoso> I need some input.. so I've got some mathematical algorithms dealing with points, edges, hulls written down, some of them dont work. Now I looked at QuickCheck for a while but boy I was so confused after even the first introduction.. and simply rigging in some opengl for visualization does also seem non trivial..
14:11:28 <phadej> dminuoso: (ab)use http://hackage.haskell.org/package/svg-builder
14:12:15 <reygoch> hey, I have a question about ambiguity
14:12:20 <dminuoso> phadej: Huh. That's an interesting thought. I think I could work with that!
14:12:31 <reygoch> can't understand why this is happening :
14:12:31 <reygoch> https://stackoverflow.com/questions/47876673/why-does-haskell-says-this-is-ambiguous
14:13:46 <Psybur> > snd $ foldr (\x (b,v) -> if b then (False,x*2:v) else (True,x:v)) (False,[]) [1,2,3,4,5]
14:13:48 <lambdabot>  [1,4,3,8,5]
14:13:56 <phadej> reygoch: Relation seems to be a type-family, not a data-type
14:14:16 <reygoch> is there a way around that?
14:14:20 <Psybur> Theres probably a much easier solution to Problem #1 of intro to haskell huh
14:14:48 <byorgey> nf7: sorry you're having such trouble with the first assignment of CIS194.  (I'm the one who developed and taught the course.)
14:15:00 <byorgey> and monochrom, thanks for pointing out the problems with the assignment.
14:15:10 <dminuoso> Psybur: My problem #1 of Haskell was being scared about monads. :(
14:15:28 <byorgey> To be honest I got the exercise from someone else and hadn't ever thought too hard about it from a holistic pedagogical point of view.
14:15:47 <phadej> reygoch: class rel ~ Relation rel => Repo e ne rel | e -> rel where eTable :: Table rel
14:15:56 <phadej> s/Relation rel/Relation e/
14:15:59 <Psybur> > snd $ foldr (\x (b,v) -> if b then (False,x*2:v) else (True,x:v)) (False,[]) [1,2,3,4,5] -- byorgy would you expect someone to use this as a solution to problem #1 if they are new to haskell?
14:16:01 <lambdabot>  [1,4,3,8,5]
14:16:02 <byorgey> this is good timing since I'm going to be teaching an FP course again starting in a few weeks, so this is a good opportunity to think about developing something better.
14:16:43 <phadej> reygoch: but then you might get into other problems, if e -> rel isn't injective
14:16:57 <phadej> and it probable isn't
14:17:14 <phadej> reygoch: another way is to use eTable :: Proxy e -> Table (Relation e)
14:18:09 <reygoch> phadej, I'm actually trying to implement some sort of "repository" pattern for my database but I'm not sure how to go about that
14:18:19 <phadej> reygoch: or return GenTable e -- http://hackage.haskell.org/package/selda-0.1.11.2/docs/Database-Selda-Generic.html#t:GenTable
14:19:02 <phadej> reygoch: I'm not familiar with selda at all, those are general "tricks" to help GHC disamiguate types :)
14:19:26 <reygoch> phadej: aha, thanks I'll try that
14:20:13 <Psybur> > snd $ foldr (\x (b,v) -> if b then (False,x*2:v) else (True,x:v)) (False,[]) [1,2,3,4,5] -- byorgey would you expect someone to use this as a solution to problem #1 if they are new to haskell?
14:20:14 <lambdabot>  [1,4,3,8,5]
14:20:58 <byorgey> Psybur: no, definitely not.  I would not expect them to know or use foldr on problem #1.  I expect them to be writing manually recursive functions.
14:22:19 <nf7> Ok, here's what I did: https://repl.it/repls/DarkblueDistantBushbaby , I reversed the list, did it from the left, and reversed it again. I know it's ugly but probably acceptable for a first question.
14:22:36 <nf7> And I would love to have some naming convention pointers if you've got any.
14:24:53 <Welkin> dark blue distant bushbaby?
14:24:54 <Welkin> O.o
14:25:48 <byorgey> nf7: yes, that's a good way to do it.
14:26:42 <nf7> byorgey: What mark would you give me?
14:27:34 <byorgey> nf7: for this assignment, full credit.  There are ways the code could be simplified, but you'll learn about those later.
14:27:55 <nf7> byorgey: Thanks. Looking forward to the next chapter.
14:29:04 <byorgey> nf7: great, enjoy.  Feel free to ping me if you have questions.
14:29:45 <nf7> byorgey: Awesome! I'm sure I'll have some questions soon enough.
14:30:53 <aberrant> how come I can't import Data.Text (splitOn) ?
14:32:27 <monochrom> I don't know, because I can.
14:32:39 <aberrant> ah, stack install text
14:36:30 <alexandre1> quit
14:37:17 <dmj`> reygoch: selda is underrated imo
14:37:38 <reygoch> I agree
14:38:54 <fiatjaf> what does liftIO do?
14:38:54 <shapr> is the selda.link website purposefully punny? Legend of Selda?
14:39:07 <shapr> ohh, now I see the selda logo, duh.
14:44:45 <fiatjaf> I don't understand liftIO, I'm using it to turn scotty's ActionM () into IO ()
14:45:10 <glguy> fiatjaf: liftIO works the other way, it turns IO a into SometingElse a
14:45:46 <verement> :t liftIO
14:45:47 <lambdabot> MonadIO m => IO a -> m a
14:48:47 <fiatjaf> ok, I was using it wrong
14:48:53 <dmj`> reygoch: wish selda would have a type level DSL for joins
14:49:18 <dmj`> or basically, have the Query monad implemented at the type level somehow
14:49:30 <fiatjaf> I don't understand however how to deal with these ActionM values from scotty
15:13:40 <fresheyeball> hello out there
15:13:57 <fresheyeball> I seem to run into a problem debugging that I would like to kill forever with some kind of large hammer
15:14:05 <fresheyeball> the problem is the Maybe Monad
15:14:26 <fresheyeball> do blocks in Maybe, or Applicative statements, can be a pain to track down where the Nothing snuck in
15:14:47 <fresheyeball> to help resolve this I want to embed trace into a Functor instance
15:15:16 <fresheyeball> is there a way to convince the compiler that fmap actually has this type?
15:15:19 <monochrom> do blocks use >>= rather than fmap.
15:15:45 <fresheyeball> fmap :: (Show a, Show b) => (a -> b) -> MyNewType a -> MyNewType b
15:15:47 <fresheyeball> monochrom: I know
15:16:00 <fresheyeball> I would like to instrument, <$> <*> and >>=
15:16:32 <fresheyeball> I can existentialize the Show into the newtype
15:16:36 <f-a> instrument?
15:16:37 <monochrom> Oh, the Show gets into the way. No, I don't think it can be done.
15:16:47 <fresheyeball> monochrom: ok then
15:16:49 <geekosaur> I think it can but it's going to be evil and painful
15:17:00 <monochrom> existentialize is the wrong direction.
15:17:08 <fresheyeball> it works for one direction
15:17:27 <fresheyeball> data IT a = Show a => IT String (Maybe a)
15:17:28 <geekosaur> you can I think override (>>=) with RebindableSyntax, then dmwit's reified dictionary stuff to pull a Show instance out of the compiler's butt
15:17:57 <fresheyeball> geekosaur: can you point me at the reified dictionary stuff?
15:18:29 <fresheyeball> fmap f (IT s x) = IT s $ f <$> trace ("fmap" ++ show x) x
15:18:41 <fresheyeball> it works one way
15:18:44 <fresheyeball> but then it wants
15:18:55 <fresheyeball> fmap :: Show b => (a -> b) -> IT a -> IT b
15:18:58 <ubsan> hi!
15:19:01 <fresheyeball> show still in the way
15:19:02 <monochrom> It is also utterly unnecessary to use Show and be completely general and arbitrary about this.
15:19:18 <fresheyeball> monochrom: what would you suggest?
15:19:19 <ubsan> I have a question about the linear types extension to haskell
15:19:33 * geekosaur poking at logs, don't have it off the top of m head
15:19:33 <ubsan> does anybody know what would make this ill-formed?:
15:19:47 <monochrom> "fmap f Nothing = trace "Nothing #1" Nothing" is a perfect instrumentation without requiring generalized Show.
15:19:47 <mud> There's a linear types extension?
15:20:18 <ubsan> https://gist.github.com/ubsan/bf7a83c35d6b726ddfa3686da2b12be6
15:20:23 <ubsan> mud: yeah
15:20:27 <fresheyeball> monochrom: I think it's less than I am looking for
15:20:37 <fresheyeball> though it might be all I get
15:20:48 <ubsan> mud: https://github.com/tweag/ghc/tree/linear-types
15:21:00 <monochrom> You can also use ghci's debugger. It's omniscience.
15:21:07 <monochrom> err omniscient
15:21:10 <ubsan> mud: https://ghc.haskell.org/trac/ghc/wiki/LinearTypes
15:21:28 <mud> Thanks
15:21:39 <fresheyeball> monochrom: it's also unergonomic to the point of useless imho
15:23:25 <ubsan> oh, it's due to the second rule
15:23:32 <ubsan> I should probably have read more :P
15:25:19 * hackage debug 0.0.2 - Simple trace-based debugger  https://hackage.haskell.org/package/debug-0.0.2 (NeilMitchell)
15:25:39 <ubsan> ... nope, I don't understand again
15:26:42 <f-a> weee debug
15:33:54 <dmwit> ubsan: I guess `f ::1 Int -> Int`
15:34:11 <ubsan> dmwit: hmm, yeah
15:34:28 <ubsan> I'm gonna install the linear ghc prototype
15:34:44 <dmwit> The "semantics" documentation is surprisingly quiet on these weights.
15:34:58 <dmwit> Their colon doesn't mention them at all.
15:35:02 <dmwit> Which seems wrong.
15:37:16 <mniip> let's get down to business to build ghc head
15:44:41 <mniip> there goes stage 1
15:45:36 <monochrom> Building GHC is the second largest cause of global warming. The first largest is bitcoin mining. :)
15:46:03 <Rembane> Criterion is number three
15:46:30 <mniip> !
15:46:36 <mniip> bitcoin mining on lambdabot
15:47:56 <monochrom> Next April 1st, it will be revealed that GHC contains secret bitcoin mining code, triggered whenever you use it to build GHC or text or vector. :)
15:48:18 <Rembane> :D
15:49:06 <mniip> hmm
15:49:22 <hpc> someone should make lambdacoin
15:49:27 <mniip> in Prim, how am I supposed to allocate a MutableByteArray# of, say, Int#s?
15:49:30 <mniip> how do I know Int# width
15:49:34 <hpc> the proof of work is typechecking thousands of fmaps applied to each other
15:49:53 <monochrom> haha
15:50:31 <monochrom> Is this why quite a few profs ask students to infer the type of (.).(.) ?
15:51:34 <hpc> the total recall operator ;)
15:51:42 <monochrom> yikes
15:55:25 <mniip> and done
15:55:48 <mniip> ooh
15:55:51 <mniip> they fixed the bug
15:56:00 <mniip> bisect time?
15:56:21 * hackage persistent-postgresql 2.6.2.1 - Backend for the persistent library using postgresql.  https://hackage.haskell.org/package/persistent-postgresql-2.6.2.1 (MaxGabriel)
15:56:45 <mniip> hahahah     Blackholes can be large objects (#14497)
15:57:17 <pta2002> is there any strict version of iterate?
15:57:20 <pta2002> I can't find any
15:58:23 <geekosaur> strict iterate tends to be bottom
15:58:50 <pta2002> % :t bottom
15:58:51 <yahb> pta2002: ; <interactive>:1:1: error: Variable not in scope: bottom
15:58:55 <glguy> strict iterate would probably be something like: iterate f !x = x : iterate f (f x)
15:58:58 <pta2002> geekosaur, what is this
15:59:00 <geekosaur> "undefined" in Haskell terms
15:59:03 <geekosaur> nontermination
15:59:24 <glguy> and would be useful to have around
15:59:52 <verement> @src iterate
15:59:52 <lambdabot> iterate f x = x : iterate f (f x)
16:00:13 <mniip> yeah this iterate is visibly bad
16:00:57 <mniip> although...
16:01:18 <pta2002> glguy, doesn't seem to work
16:01:30 <glguy> pta2002: I can't read your screen
16:01:32 <mniip> tieSpine :: [a] -> [a]; tieSpine (x:xs) = x `seq` (x:tieSpine xs); tieSpine [] = []
16:01:43 <pta2002> parse error
16:01:49 <mniip> iterate' = (tieSpine .) . iterate
16:01:56 <glguy> pta2002: You have to enable BangPatterns to use them
16:02:02 <pta2002> glguy, I put iterate' f !x = x : iterate' f (f x)
16:02:02 <monochrom> \∩/ ELICSYS = explain like I can't see your screen
16:02:03 <pta2002> oh
16:02:50 <pta2002> well hopefulyl now I don't run out of RAM
16:02:55 <pta2002> that seems to work
16:03:01 <mniip> I guess it's time to update GHC on yahb
16:03:13 <mniip> which was... super not fun last time around
16:03:40 <mniip> should I just get a chroot...
16:11:08 <mniip> yay
16:11:10 <mniip> it doesn't build
16:11:14 <mniip> classic
16:13:02 <mniip> my process is too new to build stage 1 I gues?
16:19:20 <pta2002> so
16:19:24 <pta2002> how do I prevent a stack overflow
16:19:48 <pta2002> i have a function that works for smaller inputs but will crash with a stack overflow for larger ones
16:22:23 <mud> pta2002: AFAIK that usually means you built up a huge chain of thunks that need to be forced at the end. Also I didn't think it was that easy to get recent GHC to stack overflow for that reason (though memory consumption goes up pretty high). What GHC is that on out of curiosity? And can you show code?
16:22:38 <pta2002> I'm supposedly using strict
16:22:41 <pta2002> let me get the code
16:23:57 <pta2002> http://lpaste.net/7859820736142114816 if I call part2 with inputs 377 and 50000001 it crashes
16:24:04 <pta2002> (doing advent of code day17)
16:24:35 <glguy> [] is not a good type for part 2 of #17
16:25:05 <pta2002>  i'm not using iton part 2
16:25:16 <pta2002> on part 2 i'm only getting the first value
16:25:20 * hackage mios 1.5.4 - A Minisat-based CDCL SAT solver in Haskell  https://hackage.haskell.org/package/mios-1.5.4 (shnarazk)
16:25:26 <pta2002> because i don't need the rest ofthe list for it
16:25:36 <jollygood2> hi. how do I prevent ghci from displaying all the loaded modules in prompt?
16:25:40 <glguy> this code is failing when you try to generate the first 2017 inserts?
16:25:46 <pta2002> glguy, no
16:25:47 <pta2002> that works
16:25:51 <pta2002> it's failing on part2
16:26:07 <mud> pta2002: Probably throw some bang patterns on step, prev and p in the definition of part2's where, at a guess.
16:26:13 <glguy> Oh, I see. The other code isn't related to your question?
16:26:26 <pta2002> bo
16:26:29 <pta2002> no*
16:27:20 <glguy> yeah, this just builds up a tuple of 3 huge thunks
16:27:28 <glguy> > (undefined, undefined, undefined) `seq` ()
16:27:30 <lambdabot>  ()
16:27:42 <glguy> Note that forcing the outer constructor doesn't force the values of a tuple
16:28:30 <pta2002> mud, still crashes
16:29:16 <jollygood2> ok so :set prompt does it, but how do I set prompt from shell when launching ghci?
16:29:28 <glguy> pta2002: You're building a tower of f applications
16:29:36 <pta2002> glguy, am I?
16:29:39 <glguy> pta2002: You're building a tower of f applications
16:29:51 <pta2002> I thought the !x prevented it
16:29:58 <glguy> getAfter f !x n = f (getAfter f x (n - 1))
16:30:08 <glguy> all that's doing is repeatedly forcing the x
16:30:32 <glguy> you're building up: f (f (f (f (f (f (f x))))))
16:30:51 <glguy> you want:    getAfter f !x n = getAfter f (f x) (n-1)
16:30:57 <mud> getAfter f !x n = getAfter f (f x) (n-1)  -- would likely make the ! work as intended
16:31:22 <pta2002> hmm
16:31:27 <mud> If you think about it in yours, what is x every time? Exactly the same thing you passed in, right? So forcing it does nothing.
16:31:48 <mud> Well, one force might do something, but ... only one really.
16:35:24 * hackage debug-tracy 0.1.0.0 - More useful trace functions for investigating bugs  https://hackage.haskell.org/package/debug-tracy-0.1.0.0 (fresheyeball)
16:38:16 <pta2002> well that worked
16:39:36 <mud> pta2002: Do you know what GHC version you're using, out of curiosity? I thought it was pretty hard to stack overflow from this kind of stuff in recent ones.
16:40:16 <pta2002> whatever's default in fedora 26
16:40:21 <pta2002> 8.0.2
16:40:30 <pta2002> what's the latest?
16:40:48 <mud> Ah, interesting. I thought that was new enough to count in what I was talking about. Newest is like 8.2.something I believe
16:41:18 <geekosaur> 8.2.2
16:41:48 <geekosaur> 8.0.2 should make it harder to overflow the stack, but it can still happen
16:42:01 <pta2002> hmm
16:42:05 <pta2002> I'll look into upgrading this
16:42:07 <mud> Is the limit just bigger, or is it more complicated than that?
16:42:22 <pta2002> I need to get fedora 27, but I'm on a hotel so I'll see how that goes...
16:42:34 <mud> pta2002: I wouldn't just for this, it probably won't change anything. Though I do enjoy 8.2.x anyway for other reasons.
16:43:08 <monochrom> You don't have to use Fedora's GHC.
16:43:18 <mud> pta2002: Using the OS provided GHC is usually not worth the trouble anyway. I personally get my GHC through stack, or before that I used to install "manually"
16:45:06 <mniip> yay
16:45:19 <mniip> had to reinstall a package into the global store and hide the newer version
16:45:22 <mniip> classical ghc
16:45:43 <pta2002> well I guess it was convenient
16:45:54 <pta2002> but I'll look into stack
16:54:03 <codeshot> Does anyone know if there's a neato way to export all the definitions I've made at the ghci repl into a file?
16:54:13 <glguy> copy/paste
16:54:21 <glguy> and then stop doing that and make files
16:54:25 <codeshot> ick
16:55:51 <monochrom> There is a history file. It's how next time you run ghci it can still recall your stuff from last time. Read the GHC User's Guide for where it is.
16:56:04 <geekosaur> ^
16:56:30 <geekosaur> I've pulled stuff from that a few times myyself, although usually if I want something to be persistent I use a file to begin with
16:56:58 <Tuplanolla> Slap your code here to get it logged.
16:57:08 <geekosaur> heh
16:59:03 <Wizek> Is someone interested in having a bit of a conversation about this? https://stackoverflow.com/questions/47232769/what-does-a-haskell-type-error-mean-when-it-includes-is-as-general-as-its
17:00:12 <Wizek> I hope to understand if the type error GHC halts with is a reasonable thing for it to do, or if it is just an unintended limitation.
17:00:53 <monochrom> I think you're a victim of this: http://lpaste.net/352302
17:03:18 <fishythefish> roughly, the type of (a, b) is Monad m => (Char, m Char), not "(Char, Monad m => m Char)", so a has type Monad m => Char, not just Char. m is ambiguous, so GHC errors
17:03:31 <Wizek> monochrom: reading, thanks for the pointer
17:03:53 <Wizek> fishythefish: Yes, that far I do understand
17:05:41 <Wizek> fishythefish: My gripe/misunderstanding comes in when I think about why GHC would try to propagate `Monad m` constraint to `Monad m => Char`. Why can't it see that the `m` variable is nowhere to be seen on the RHS and not propagate the constraint?
17:06:13 <monochrom> Because Haskell 2010 makes it do this.
17:06:14 <Wizek> Because AFAIU, that would fix all this issue
17:06:57 <Wizek> monochrom: and so my question remains: is this a sensible thing to do? Is it ever useful? Or is it a senseless limitation to be fixed for Haskell 2020?
17:06:58 <monochrom> And there are examples (such as mine) in which you can't get rid of it either.
17:08:43 <hpc> somehow this reminds me of the ST rank-2 trick
17:09:27 <hpc> in some sense, ST forces you to "not use" the s type variable
17:09:30 <hpc> but this forces you to use it
17:10:42 <monochrom> Your very simplistic example of ('x', return 'y') is such that "clearly for very smart humans or AIs" 'x' does not depend on which Monad instance you use for return 'y'.
17:11:11 <mniip> % runST (unsafeCoerce $ putStrLn "hi")
17:11:11 <yahb> mniip: hi
17:11:13 <mniip> :D
17:11:16 <monochrom> But a simple type system such as Hindler-Milner-plus-classes cannot rely on this.
17:12:07 <Wizek> monochrom: also, do you know for a fact that Haskell 2010 Language Report mandates this behaviour? Or is that perhaps an assumption on your part?
17:12:46 <codeshot> Tuplanolla, I would but EvanR doesn't like it at all
17:12:48 <monochrom> The more general case is (x,y) = xxx, with xxx ::  MyClass m => (Char, m Char), and you have no idea whether different instances of MyClass will give the same of different answers for x.
17:13:20 <monochrom> In fact, in my System.Random-using example, the answer for g' does depend on which instance of RandomGen is used.
17:13:47 <monochrom> I thought I cited actual sections of Haskell 2010?
17:13:55 * geekosaur tries to find context for this discussion
17:14:15 <monochrom> geekosaur: https://stackoverflow.com/questions/47232769/what-does-a-haskell-type-error-mean-when-it-includes-is-as-general-as-its
17:14:38 <Wizek> monochrom: yes, you did in fact. Haven't parsed that far yet, I'm sorry.
17:14:41 <monochrom> Or more succintly, (a,b) = ('x', return 'y')
17:14:53 * hackage hledger-irr 0.1.1.12 - computes the internal rate of return of an investment  https://hackage.haskell.org/package/hledger-irr-0.1.1.12 (JoachimBreitner)
17:15:25 <monochrom> and the "counterintuitive" result that a's type is Monad m => Char
17:15:43 <Wizek> which is always a type error.
17:16:49 * hackage list-fusion-probe 0.1.0.7 - testing list fusion for success  https://hackage.haskell.org/package/list-fusion-probe-0.1.0.7 (JoachimBreitner)
17:17:27 <geekosaur> type inference, looks like? how a gets used could control the possible m-s for (a,b), and the "obvious" fix for that (decomposing it into separate bindings) is only applicable in a subset of cases?
17:17:38 <geekosaur> (and monochrom demonstrated one where it is not)
17:17:50 <monochrom> But if you are willing to contrive this other class: class MyClass p where xxx :: (Char, p Char)
17:18:13 <monochrom> instance MyClass Maybe where xxx = ('m', Just 'm')
17:18:18 <geekosaur> and in general you run into various ambiguous cases when you try to make this "work"
17:18:26 <monochrom> instance MyClass [] where xxx = ('s', Just 's')
17:18:44 <geekosaur> as monochrom said, H-M+typeclasses is not strong enough for this
17:18:57 <monochrom> now "(a,b) = xxx" you cannot get rid of b's MyClass dictionary when you ask what's a.
17:19:58 <monochrom> It is rightfully "MyClass p => Char" on one hand, and also "insufficient information for a meaningful answer" on the other hand. So they forbid it.
17:20:18 <fishythefish> er, is that instance MyClass [] right?
17:20:20 <benzrf> hey
17:20:32 <fishythefish> "s", not Just 's', right?
17:20:41 <monochrom> Oh haha should be ('s', ['s'])
17:20:57 <fishythefish> hey, benzrf
17:21:24 <benzrf> is there any nice pre-existing function for "reverse zoom"? i.e. instead of zooming in on some part of the state and running an action on it, i wanna extend the state to something bigger using a starting value, run an action over that, and then discard the leftover extra stuff
17:21:52 <ezyang> that sounds like a comonad
17:21:54 <johnw> modify?
17:22:09 <johnw> no, not modify...
17:22:56 <benzrf> i could probably do it fairly easily with some gets and sets buuut itd be nice if there's a simpler way :)
17:22:59 <johnw> it sounds like rezoom applied to a Prism
17:23:04 <benzrf> rezoom...
17:23:14 <benzrf> is that a thing?
17:23:15 <johnw> if there were such a thing :)
17:23:24 <johnw> but by analogy with view/review
17:23:26 <benzrf> yeah kinda
17:23:32 <johnw> it makes complete sense in that respect
17:23:45 <benzrf> but it doesnt _quite_ work because it might modify the extra stuff
17:23:54 <johnw> that gets thrown away
17:23:57 <benzrf> like going from Int to (String, Int) and back isnt a nice prism
17:24:20 <benzrf> i dont have a Prism' (String, Int) Int
17:25:03 <fresheyeball> is there a way I can tell hackage "hey this package doesn't work with 8.2.2, build with 8.0,2"?
17:25:22 <monochrom> No, but you can play with versions of base.
17:26:10 <monochrom> Oh actually yes you can play with "if" in *.cabal files, it can check GHC version, and you can try to do something that always fails.
17:26:10 <fresheyeball> monochrom: what do you mean? The version of base I have already is the version I mean :/
17:26:50 <monochrom> There is a bijection between base version and GHC version. People usually actually use this to ban GHC versions they don't want to worry about.
17:27:52 <monochrom> For example to ban GHC 8.2.* you can consider "base < 4.10"
17:29:30 <codeshot> Tuplanolla, I've defined them in lambdabot: >->, >+->, >++->, >+++->, >++++->, >+=>, >++=>, >+++=>, >++++=>
17:29:38 <mniip> thanks for all the fish
17:29:45 <monochrom> You can also use "if impl(ghc >= 8.2)" but I don't know what to fill in afterwards to say "not supported".
17:29:46 <codeshot> no worries
17:30:19 * hackage debug-tracy 0.1.0.1 - More useful trace functions for investigating bugs  https://hackage.haskell.org/package/debug-tracy-0.1.0.1 (fresheyeball)
17:30:42 <codeshot> These are right to left pure composition (>->) as a parallel to >=>, and variants that pull in more arguments at specific points in the pipeline where a function there requires more arguments
17:30:44 <monochrom> Perhaps you'll have to dig deep in cabal user's guide.
17:31:15 <mniip> codeshot, I'd rather there was an inductive way
17:31:15 <codeshot> a pipeline with these takes as many arguments as there are +'s and one more at the start of course
17:31:39 <codeshot> Bring me some inductive humans and I might work on it
17:32:09 <mniip> that reminds me of FlipT
17:32:52 <monochrom> Just two weeks ago someone pointed out the standard concurrency library's lack of an official "hang" thread. I replied along the line of "be an adult, live with it" but other people were right to point out that for a nice algebra of threads you need it.
17:33:38 <monochrom> (So that for example async's race operator is now a monoid operator not just a semigroup operator.)
17:33:51 <monochrom> (hang `race` x = x)
17:34:51 <monochrom> And now the same can be said about *.cabal's lack of something to say "fail/abort". You would really love to have it for "I can't do GHC 8.2.2".
17:35:34 <codeshot> mniip, hoogle knows nothing of FlipT
17:35:44 <codeshot> google's memory looks a bit hazy too
17:36:16 <codeshot> Although google's had Alzheimer's for years
17:37:06 <mniip> @letlpaste 5150490821056790528
17:37:07 <lambdabot>  Defined.
17:37:21 <mniip> :t natVal
17:37:22 <lambdabot> KnownNat n => proxy n -> Integer
17:37:31 <mniip> :t natVal . FlipT . Apply
17:37:32 <lambdabot> forall l (n :: Nat) (f :: Nat -> l -> *) (b :: l). KnownNat n => f n b -> Integer
17:37:33 <codeshot> ooh, nice lambdabot feature
17:37:37 <mniip> :t natVal . FlipT . FlipT . Apply
17:37:38 <lambdabot> forall l1 l2 (n :: Nat) (f :: Nat -> l1 -> l2 -> *) (b1 :: l1) (b2 :: l2). KnownNat n => f n b1 b2 -> Integer
17:39:15 <monochrom> Google is like brains. Great at associative thinking, poor at updates.
17:39:19 <mniip> there was more to it but it'd have to re-rememeber all the crazy types that went into it
17:40:13 <monochrom> Well, poor at updates when it has learned too much.
17:41:42 <codeshot> mnip, is this to allow a number to be given in a type instead of a series of + so we could do >-> (pop 1) f >-> (pop 2) g >-> (pop 1) h ?
17:41:47 <codeshot> mniip, ^^^^
17:42:13 <mniip> kinda but no
17:42:38 <mniip> consider how there is no fmap2 :: (a -> b) -> f (g a) -> f (g b)
17:42:42 <mniip> you just have
17:42:45 <mniip> :t fmap . fmap
17:42:46 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
17:42:47 <mniip> :t fmap . fmap . fmap
17:42:48 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
17:42:49 <mniip> etc
17:43:04 <codeshot> yeah
17:43:07 <mniip> even zipWithN generalizes
17:44:00 <codeshot> so f >-> grab >-> g >-> grab >-> grab >-> grab >-> h
17:44:17 <mniip> I wouldn't be so sure about the exact syntax
17:46:30 <codeshot> I'm seconds away from arrows aren't I?
17:46:47 <codeshot> funny that there's this neat little gap to learn into
17:46:51 <mniip> consider this
17:46:56 <marvin3> what pdf reading library is usually recommended? there are quite a few of them on hackage
17:47:05 <mniip> @let coflip r f x y = r (f y) x
17:47:06 <lambdabot>  Defined.
17:47:18 <mniip> :t coflip id
17:47:19 <lambdabot> (t4 -> t2 -> t3) -> t2 -> t4 -> t3
17:47:23 <mniip> :t coflip $ coflip id
17:47:24 <lambdabot> (t1 -> t2 -> t3 -> t5) -> t3 -> t1 -> t2 -> t5
17:47:32 <mniip> :t coflip $ coflip $ coflip id
17:47:33 <lambdabot> (t1 -> t2 -> t3 -> t5 -> t6) -> t5 -> t1 -> t2 -> t3 -> t6
17:48:48 <codeshot> very interesting
17:49:04 <codeshot> Is this stuff in a well-documented well-diagrammed library?
17:49:13 <codeshot> possibly well-animated too?
17:49:15 <mniip> not to my knowledge
17:49:18 <codeshot> shame
17:49:31 <codeshot> I've got too much to learn without that
17:49:34 <mniip> I'm very likely not the first one to have come up with it
17:49:41 <mniip> given I just made it up on the spot
17:49:44 <monochrom> Heh tall order you have there.
17:50:42 <monochrom> This is not Hogwarts, you can't just expect that even the most ordinary newspapers come with animated GIFs.
17:50:49 <codeshot> There are a lot of universities in the world, I'm suprised they haven't spoken to each other and pooled a small fraction of their resources on this stuff
17:51:12 <codeshot> I didn't come to Haskell for ordinary !
17:51:20 <codeshot> I came for quidditch
17:51:55 <mniip> I think I saw something
17:52:17 <mniip> someone offering a budget for developing a minor-friendly programming course for haskell or something
17:52:28 <mniip> I don't remember the exact details
17:52:48 <codeshot> Are you equating my learning needs with those of a child ?
17:53:14 <monochrom> I would love to have you equate my learning needs with a child.
17:53:23 <monochrom> It would make me feel young again.
17:53:35 <codeshot> monochrom, you seem so childish to me
17:53:36 <codeshot> how's that?
17:53:49 <monochrom> Because I want to feel young again?
17:54:01 <codeshot> ... yeah, yeah that's it
17:54:07 <codeshot> :P
17:54:43 <mniip> codeshot, what do you need a picture to understand  (`runCont` \xs -> fmap (second ($ fmap fst xs)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs))))
17:54:50 <mniip> childish
17:54:52 <Rembane> codeshot: That's a lie, monochrom has found the spring of youth but won't tell us where it is.
17:54:53 <codeshot> rofl
17:55:49 <monochrom> That's badass.
17:59:06 <codeshot> Rembane, the spring of youth is in your own footsteps
18:02:13 <codeshot> emilypi, your connection is flakey
18:02:30 <emilypi> yes, it is. I'm on a plane
18:02:54 <monochrom> Is it the B2 stealth bomber? :)
18:03:21 <Tuplanolla> Just an inclined plane.
18:03:47 <codeshot> You get wifi on planes now?
18:03:56 <codeshot> I have to stop flying budget
18:04:03 <emilypi> ;)
18:09:59 <ReinH> :t coflip
18:10:00 <lambdabot> (t1 -> t2 -> t3) -> (t4 -> t1) -> t2 -> t4 -> t3
18:10:59 <ReinH> :t (??) `asAppliedTo` (undefined :: a -> b -> c)
18:11:00 <lambdabot> (a1 -> a2 -> b) -> a2 -> a1 -> b
19:19:02 <piyush-kurur> does any one know of an example of a term in polymorphic (hindley-milner) lambda calculus for which we cannot infer type by local type inference.
19:19:11 <piyush-kurur> the simpler the term the better
19:20:53 <mniip> er, wasn't the theorem that it always works?
19:21:44 <byorgey> maybe piyush-kurur means something specific by "local type inference", i.e. not using unification?
19:21:45 <mniip> I mean there are various extensions to rank-1 polymorphic lc that break hm
19:22:02 <glguy> How about polymorphic recursion?
19:22:04 <mniip> such as polymorphic letrec
19:22:20 <glguy> data T a = A | B (T[a]); example :: T a -> Int; example A = 0; example (B x) = example x -- needs that type signature
19:22:36 <mniip> yeah well see that's not expressible in lambda calculus
19:22:47 <mniip> bindings are an extension of LC syntax per se
19:23:03 <piyush-kurur> byorgey: yeah that is what I mean. Reading pierce paper I got an impression that
19:23:04 <glguy> ah, I didn't read the question closely enough
19:23:31 <piyush-kurur> not all terms that can be typed in hindley-milner system can be infered using local type inference
19:23:40 --- mode: glguy set -o glguy
19:23:40 <piyush-kurur> I might be wrong
19:24:10 <mniip> can't say I know exactly what you mean by local there
19:24:37 <piyush-kurur> The problem is that Pierce-Turner talks about inference with subtyping.
19:25:08 <piyush-kurur> I am not able to see how that is applicable so I am not sure
19:25:09 <mniip> ah
19:27:26 <byorgey> piyush-kurur: if I understand what you mean correctly, it is not hard to come up with such terms.  For example,  (\x f -> f x + x).  Inferring this to have type  Nat -> (Nat -> Nat) -> Nat  requires inferring the type of f from the way it is used.
19:28:29 <piyush-kurur> yeas
19:28:41 <piyush-kurur> *yes
19:30:36 <piyush-kurur> byorgey: what is the intuition here ?
19:31:45 <byorgey> well, I don't know exactly what you mean by "local type inference", I am only guessing, so I can't say for sure.  But I am taking it to mean "as much type inference as you can do without using unification".
19:32:10 <piyush-kurur> Okey let me clarify
19:32:32 <byorgey> if you have a lambda which is applied to something, you can infer it:  (\x -> ...) y   if you can infer the type of y, then infer the body ... under the assumption that x has the inferred type of y.
19:32:55 <byorgey> but if you have a bare lambda  (\x -> ...)   the only way to infer its type is to make up a unification variable for the type of x and then see how x is used inside the ...
19:33:19 <piyush-kurur> byorgey: makes a lot of sense
19:34:29 <piyush-kurur> just to prob a bit more: When I say Local type inference I mean the Pierce-Turner kind of inference
19:35:09 <piyush-kurur> but that requires a notation of subtyping as I understand it (or is it that it can even handle some variants of subtyping)
19:35:35 <inkbottle> data DepBool a = DepTrue | DepFalse \\ instance Arbitrary (DepBool a) where arbitrary = choose (DepTrue, DepFalse) \\ Could not deduce (random-1.1:System.Random.Random (DepBool a)) arising from a use of ‘choose’
19:35:52 <piyush-kurur> For subtyping, If I just assume a type T1 is a subtype of T2 if it is less general type
19:35:56 <piyush-kurur> would that work
19:36:15 <inkbottle> Any idea on how to fix my "choose"?
19:40:36 <Gurkenglas> inkbottle, use arbitraryBoundedEnum
19:41:06 <inkbottle> Gurkenglas: OK
19:41:49 <Gurkenglas> (You haven't provided a way to generate a random DepBool from the range that starts at DepTrue and ends at DepFalse, but you don't need one, because arbitraryBoundedEnum does the equivalent. You'll need "data DepBool a = DepTrue | DepFalse deriving Enum".)
19:42:25 <inkbottle> OK
19:42:25 <byorgey> piyush-kurur: I don't know, I am not familiar with the Pierce-Turner work.  Perhaps I was once long ago.
19:46:21 <piyush-kurur> byorgey: thanks any way
19:46:45 <inkbottle> Gurkenglas: OK, I added "deriving (Bounded, Enum)", and did "arbitrary = arbitraryBoundedEnum" and this part doesn't seem to raise issues anymore
19:46:46 <Gurkenglas> coerce applies the isomorphism coerced whereever it can to implement a requested function. Could this be done with user-specified isomorphisms?
19:48:08 <mniip> huh
19:48:36 <mniip> Gurkenglas, coerced stems from coerce
19:48:42 <mniip> not the other way
19:48:51 <mniip> and coerce is pretty much a builtin
19:48:51 <Gurkenglas> I know, the question stands.
19:48:53 <inkbottle> Gurkenglas: however, why couldn't I use "choose" as it is the case for plain Bool: instance Arbitrary Bool where arbitrary = choose (False,True)
19:49:02 <mniip> write a typechecker plugin
19:49:28 <Gurkenglas> lens implements template, I don't know what's impossible anymore.
19:49:55 <mniip> ah right
19:50:24 <Gurkenglas> inkbottle, Bool has a Random instance
19:50:35 <inkbottle> OK
19:50:45 <inkbottle> Thanks
19:56:01 <Gurkenglas> Should one be allowed to provide orphan instance in a local scope? "arbitrary = let instance Random DepBool where ... in choose (DepTrue, DepFalse)"
19:56:36 <mniip> I've thought about how cool it would be to allow all top-level bindings in whers
19:56:44 <mniip> data, type families, classes, instances
19:57:03 <Gurkenglas> (Oh right, that's what constraints does)
19:57:31 <geekosaur> Gurkenglas, think about what effect that might have on, say, Data.Map
19:57:37 <Gurkenglas> mniip, don't forget modules
19:58:12 <mniip> LANGUAGE pragmas
19:58:15 <Gurkenglas> geekosaur, explain pls?
19:58:53 <geekosaur> let instance Ord Foo where ... in <expression with a Map Foo x>
19:59:20 <geekosaur> you can get an idea of what happens even with the Haskell as it is now, just try to insert a NaN key into a Map Double x
19:59:42 <geekosaur> well, for starters, insert two of them
19:59:57 <Gurkenglas> (Wait, can you construct an orphan Dict without writing an orphan instance?)
20:00:13 <geekosaur> (because instance Ord Double is not quite what Map expects to work with)
20:00:18 <mniip> > compare (0 / 0) (0 / 0 :: Double)
20:00:20 <lambdabot>  GT
20:01:58 <Gurkenglas> geekosaur, you mean there'd be a problem if the map escapes the scope of the instance?
20:02:04 <geekosaur> Gurkenglas, anyway, the poijt is if you can provide a different Ord instance for a type, you break Map's invariants. in particular, inverting a type's Ord lets you hide two Maps inside one
20:02:47 <nshepperd_> Gurkenglas: you can write an instance for a newtype wrapper, then unsafeCoerce its Dict
20:02:51 <Gurkenglas> Perhaps any value constructed with an instance in scope pollutes any scope it touches with that instance
20:04:29 <mniip> ooh ooh
20:04:38 <mniip> local type role annotations
20:04:47 <mniip> could let you break coercion
20:04:56 <geekosaur> similarly I'd expect being able to change Hashable instances on the fly would do strange things to HashMap/HashSet, and it'd be even weirder than Map's behavior
20:05:01 <geekosaur> yes
20:05:08 <Gurkenglas> ...I guess then you could never do anything with the value without making the instance global. Okay
20:05:23 <geekosaur> there's lots of things that would break unexpectedly, which si why instances are always global
20:05:37 <Gurkenglas> But the same is true for withDict from constraints, right?
20:06:14 <geekosaur> (arguably the fix for the examples I gave is to make the compare function part of the Map, instead of relying on the typeclass constraint to do so, but that's just one problem and not all are amenable to this)
20:07:13 <geekosaur> yes, constraints lets you do things like this, and it renders the type system unsound
20:07:30 <nshepperd_> :t withDict
20:07:31 <lambdabot> error: Variable not in scope: withDict
20:08:35 <geekosaur> it's convenient when you need it, but it's on you to prove that it's safe
20:08:43 <Average-user> does someone know a function with this type:`(a -> b -> c) -> (a -> b) -> a -> c` ?
20:09:22 <nshepperd_> Oh, withDict :: Dict c -> (c => x) -> x
20:09:38 <Gurkenglas> :t ap :: (a -> b -> c) -> (a -> b) -> a -> c -- Average-user
20:09:39 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
20:09:55 <Gurkenglas> (Or, as it's more commonly known, (<*>))
20:10:50 <nshepperd_> But constraints doesn't let you construct Dicts that are different from the global ones without using some unsafe* function
20:13:34 <inkbottle> Gurkenglas: I've found I can use that too: "arbitrary = frequency [(1, return DepTrue), (1, return DepFalse)]" (melding with random, like instance Random Bool where... seems difficult, Tx for the arbitraryBoundedEnum trick)
20:21:37 <inkbottle> Average-user: :t let f :: (a -> b -> c) -> (a -> b) -> a -> c; f g h x = g x (h x) in f
20:21:45 <inkbottle> :t let f :: (a -> b -> c) -> (a -> b) -> a -> c; f g h x = g x (h x) in f
20:21:46 <lambdabot> (a -> b -> c) -> (a -> b) -> a -> c
20:22:31 <Average-user> inkbottle: I know I can define one
20:23:55 <inkbottle> hoogle "(a -> b -> c) -> (a -> b) -> a -> c"
20:24:37 <inkbottle> Average-user: Anyway I don't think there is any other than the one I wrote
20:25:08 <inkbottle> not without constrained types
20:25:29 <Average-user> Gurkenglas pointed out at <*>
20:26:19 <Gurkenglas> inkbottle means that any implementation must be identical to his. Average-user is looking for aliases.
20:27:28 <Gurkenglas> For https://github.com/ekmett/lens/pull/778/files (which fails to typecheck because I fail to cloneTraversal), should I rather replace "ATraversal' s a" with the bloated type signature "Traversing' (->) (Control.Lens.Internal.Context.Pretext (->) [a] [a]) s a" or some shorter alias, or insert "cloneTraversal"s?
20:27:28 <Average-user> Gurkenglas: I just wanted to remeber the name of the function
20:42:23 <inkbottle> Gurkenglas: I still need a few seconds to see that S = <*>; But yes, of course. (https://kseo.github.io/posts/2016-12-24-reader-monad-and-ski-combinators.html)
20:44:14 <jle`> is there a NonEmpty 'some' out there
20:44:20 <dibblego> yep
20:44:42 <dibblego> @type some1
20:44:44 <lambdabot> error:
20:44:44 <lambdabot>     • Variable not in scope: some1
20:44:44 <lambdabot>     • Perhaps you meant ‘some’ (imported from Control.Applicative)
20:44:48 <dibblego> https://hackage.haskell.org/package/base-4.10.1.0/docs/src/Data.List.NonEmpty.html#some1
20:44:49 <jle`> oh wow :O
20:45:04 <jle`> some1 is listening
20:45:14 <dibblego> @type Data.List.NonEmpty.some1
20:45:15 <lambdabot> Alternative f => f a -> f (Data.List.NonEmpty.NonEmpty a)
20:49:45 <mniip> some1
20:49:47 <mniip> once told me
20:50:00 <Gurkenglas> https://hackage.haskell.org/package/pointedalternative-0.1.0.0/docs/Control-Alternative-Pointed.html I suppose. Anyone want to be maintainer?
20:51:16 <jle`> does 'many' always succeed?
20:52:32 <Gurkenglas> "<|> pure []" yes
20:53:14 <LiaoTao> many v = some v <|> pure []
20:53:18 <LiaoTao> Too slow :>
20:54:09 <glguy> > many [()]
20:54:11 <lambdabot>  *Exception: <<loop>>
20:54:20 <LiaoTao> :(
20:54:23 <glguy> "succeed" is relative
20:56:19 <glguy> Prelude Text.Megaparsec Text.Megaparsec.Char> parseMaybe (many (char 'a' >> char 'a')) "a"
20:56:19 <glguy> Nothing
20:56:26 <Gurkenglas> > manyLazy [()] -- glguy, just insufficient laziness
20:56:29 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
20:57:46 <pacak> @src manyLazy
20:57:46 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:57:58 <Gurkenglas> pacak, http://lpaste.net/156934
20:59:23 <glguy> the megaparsec is a better example of many failing, then
21:01:30 * hackage ocaml-export 0.1.0.0 - Convert Haskell types in OCaml types  https://hackage.haskell.org/package/ocaml-export-0.1.0.0 (mchaver)
21:05:50 <Gurkenglas> glguy, I admit I'm confused. https://hackage.haskell.org/package/megaparsec-6.3.0/docs/Text-Megaparsec.html#v:takeWhileP also seems to imply it should never fail.
21:08:09 <Gurkenglas> How do I tell ghci to evaluate an expression one definition at a time, showing me each intermittent complete expression?
21:12:03 <mniip> and done
21:12:12 <mniip> that's a lot of points
21:12:30 <mniip> beat glguy even
21:12:42 <mniip> 23/23
21:13:04 <LiaoTao> I envy your spare time :(
21:13:22 <mniip> 11 minutes isn't spare time :S
21:13:28 <mniip> I've got a final exam in an hour
21:13:48 <jchia> Is there a function 'f:: Int -> [a] -> [[a]]' that chunks an input list into chunks of some specified size and the last chunk can be smaller than specified chunk size?
21:14:04 <LiaoTao> mniip: Cumulatively
21:14:04 <mud> jchia: chunksOf from the 'split' package
21:14:05 <EvanR> you need to run a defrag on your spare time fragments
21:16:53 <inkbottle> newtype Mu f = InF { outF :: f (Mu f) } \\ :k Mu is (* -> *) -> * \\ It is almost the right kind for a Functor. Is there no way to make Haskell accept that for a Functor instance?
21:18:03 <mniip> inkbottle, but it's not
21:18:14 <mniip> well, it is a functor, but not a Prelude.Functor
21:18:31 <inkbottle> mniip: too bad
21:18:38 <mniip> the prelude class isn't capable of higher rank functors like these
21:18:43 <mniip> see Hask for example
21:18:53 <mniip> ekmett/hask
21:19:34 <inkbottle> mniip: got it, thanks
21:22:40 <jchia> mud: Thanks
21:33:01 <nilOps> Kinda new to Haskell and wondering if there is a more idiomatic way to write `fmap (fmap readInt . words) . lines :: String -> [[Int]]` ?
21:33:33 <mniip> I'd use map instead of fmap because monomorphic
21:33:43 <mniip> also read
21:35:08 <mniip> otherwise no
21:35:20 <EvanR> :t readInt
21:35:21 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
21:35:34 <EvanR> youd use map because monomorphic, but read because its polymorphic? :)
21:35:41 <mniip> yes!
21:35:48 <EvanR> ?_?
21:35:51 <mniip> makes perfect sense
21:36:02 <nilOps> Why map over fmap here?
21:36:15 <mniip> shorter, more aesthetically pleasing
21:36:41 <nilOps> Also, I have readInt defined as `readInt = read :: String -> Int`
21:37:11 <glguy> using map when it fits helps the future reader, saves on some mental type inference
21:37:27 <EvanR> that readInt is pretty unidiomatic
21:37:42 <EvanR> i dont think its going to get you anything read doesnt
21:38:10 <nilOps> You're probably right; it's a remnant from when I was trying to get the code to type check
21:38:14 <Lokathor> neat AoC
21:38:45 <mniip> you know what would be fun
21:38:47 <nilOps> Thought I'd try AoC in Haskell :)
21:38:51 <mniip> to make a tying-the-knot structure
21:38:56 <mniip> out of this pipe world
21:39:36 <mud> Huh, that is a pretty neat problem
21:40:01 <mud> I'm not sure why they made the diagrams so hard to read though, couldn't it just be tall instead of wide?
21:40:13 <mniip> you're not supposed to read it
21:40:16 <mniip> also ctrl-minus
21:40:22 <mniip> fits on my screen
21:40:23 <glguy_> Maybe to discourage manual tracing
21:40:25 <mud> I know, but still ... it'd be nice to see the thing.
21:40:41 <mniip> ah don't even need the minus
21:41:04 <mniip> yeah nah it's pretty tall
21:41:18 <mniip> a better question would be,
21:41:21 <mniip> is this an unknot
21:41:29 <Lokathor> my widescreen monitor can show it all without wrapping
21:41:36 <Lokathor> but it can't show all the rows of course
21:41:36 <mniip> Lokathor, vertically too?
21:41:47 <Lokathor> no not all the rows
21:42:04 <glguy_> The rows and columns all fit for me
21:42:21 <mniip> had to zoom out quite a bit http://tcpst.net/sjux.png
21:42:43 <glguy_> Oh I lied
21:45:41 <jle`> i really like 'many' now
21:49:01 * hackage ats-format 0.1.0.0 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.0 (vmchale)
22:09:48 * hackage skylighting 0.5.0.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.5.0.1 (JohnMacFarlane)
22:16:49 * hackage ats-format 0.1.0.1 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.1 (vmchale)
22:24:52 <jle`> mniip: that'd be fun :)
22:40:54 <Average-user> This day was fun.
22:41:36 <Average-user> And good for Prolog.
22:47:37 <glguy_> Which days were the most challenging to do in prolog?
23:01:23 <rightfold> All of them
23:30:54 * hackage unliftio 0.2.1.0 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  https://hackage.haskell.org/package/unliftio-0.2.1.0 (MichaelSnoyman)
23:31:45 <dmiles> Average-user: can you post your code someplace? (if not for todays but a differnt day?)
23:32:47 <dmiles> oh i have join/parts hidden.. nowonder autocomplete didnt work :)
23:36:15 <glguy_> https://github.com/Average-user/adventofcode-pl-2017
23:39:26 <glguy_> It's linked via the local leaderboard
23:39:56 * hackage ocaml-export 0.1.1.0 - Convert Haskell types in OCaml types  https://hackage.haskell.org/package/ocaml-export-0.1.1.0 (mchaver)
