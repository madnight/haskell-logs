00:50:22 * hackage netwire-input-glfw 0.0.7 - GLFW instance of netwire-input  https://hackage.haskell.org/package/netwire-input-glfw-0.0.7 (Mokosha)
00:57:40 <shiona> huh. I was sure todays AoC would require some sort of magic, either some math I could not see or some weird tree structures to keep memory/CPU time usage at bay
00:58:00 <shiona> but it was probably the simplest problem in a week
01:06:37 <vaibhavsagar> really? I'm still struggling
01:06:53 <vaibhavsagar> I even looked at glguy's solution and it didn't help
01:06:54 <bartavelle> all of these problems can be solved by naive implementations :(
01:07:18 <bartavelle> the day before I thought you would have to solve the quadratic equations but you can get away with simulating a few steps
01:07:50 <bartavelle> today I tried the larger size, thinking it should not complete in reasonnable time, while thinking of a better solution, but it finished in ~ 3s
01:08:10 <bartavelle> I *think* it was harder last year
01:08:26 <vaibhavsagar> I definitely gave up more times last year
01:09:53 <bartavelle> never give up! :p
01:10:01 <vaibhavsagar> nah, I disagree
01:10:50 <vaibhavsagar> after a couple of hours there's not much to learn from struggling with a problem
01:11:01 <vaibhavsagar> at least I don't think so
01:16:01 <ddk> Hello all...
01:17:17 <ddk> I have to build a web app....  I don't have experience with web programming while I have experience with Haskell and databases
01:17:55 <AWizzArd> Is „web app” the server side or the client or both?
01:18:09 <ddk> Can someone please suggest...  How should I proceed?  I will prefer Haskell over imperative languages
01:19:08 <shiona> https://wiki.haskell.org/Web/Frameworks When I tried I started with going through a few of these
01:19:32 <ddk> AWizzArd : both I guess as I also have to get data from users and show them pages
01:20:26 <AWizzArd> ddk: for the client side: you could decide to go with PureScript, which is extremly similar to Haskell (and implemented in Haskell). Plus React.
01:21:02 <ddk> Okay but I don't know about purescript
01:26:31 <vaibhavsagar> ddk: it'll look familiar if you're comfortable with Haskell
01:29:58 <quchen> What’s the deal with all the nicknames ending in [m]?
01:37:10 <Lokathor> welp
01:37:13 <Lokathor> day21 has me beat
01:38:24 <bartavelle> Lokathor: what is the trouble?
01:39:07 <Lokathor> my answer doesn't match the answer the site wants :P
01:39:31 <Lokathor> my demo case works, but the full case doesn't work
01:53:11 <kahlil29> can fmaps be unapplied? (curried?)  .. .I have a list of lists of lists like [[[Int]]] and I want to traverse right down to the innermost list and run some operations on each number. What is the best way to do that?
01:53:38 <vaibhavsagar> kahlil: fmap . fmap . fmap will work
01:54:16 <vaibhavsagar> > (fmap . fmap) (+1) [[1,2]]
01:54:18 <lambdabot>  [[2,3]]
01:54:27 <vaibhavsagar> > (fmap . fmap . fmap) (+1) [[[1,2]]]
01:54:29 <lambdabot>  [[[2,3]]]
01:54:53 <kahlil29> that's nice. thanks. this is called function composition?
01:54:59 <vaibhavsagar> > (fmap . fmap . fmap) (+1) [[[1,2]], [[3,4]]]
01:55:02 <lambdabot>  [[[2,3]],[[4,5]]]
01:55:11 <vaibhavsagar> yup, function composition
02:02:57 <quchen> kahlil29: Maybe you know ∘ from mathematics, (f ∘ g)(x) = f(g(x)).
02:03:04 <quchen> Haskell approximates ∘ with .
02:03:08 <quchen> ?src (.)
02:03:08 <lambdabot> (f . g) x = f (g x)
02:03:18 <kahlil29> quchen : yes I was trying to relate it to that
02:03:36 <quchen> It’s exactly the same. :-)
02:04:28 <quchen> And some functions compose just very nicely, maybe surprisingly so.
02:04:32 <quchen> :t fmap
02:04:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:04:34 <quchen> :t fmap . fmap
02:04:36 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
02:04:38 <quchen> :t fmap . fmap . fmap
02:04:40 <lambdabot> (Functor f3, Functor f2, Functor f1) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
02:04:50 <quchen> Each ». fmap« scopes one level deeper into a nesting of Functors.
02:05:56 <quchen> You could also write »\f x -> fmap (fmap (fmap f)) x« if you want, but I find the compositional way clearer.
02:08:13 <kahlil29> quechen yes it is :D thanks
02:18:49 * hackage taggy 0.2.1 - Efficient and simple HTML/XML parsing library  https://hackage.haskell.org/package/taggy-0.2.1 (AlpMestanogullari)
02:24:29 <lseactuary> anyone here good at first order logic?
02:24:53 <lseactuary> have a problem i am stuck on. well, i have the solution, stuck on if its right.
02:29:10 * hackage servant-auth-token-api 0.5.1.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.5.1.0 (NCrashed)
02:39:44 <lseactuary> https://pastebin.com/0AKChqfJ
02:39:51 <lseactuary> here is the questions and my attempted solutions
03:14:26 <kakashiAL> I am using the atom editor
03:14:38 <kakashiAL> would like to know if you can recommend some haskell packages
03:14:54 <kakashiAL> something where you can run code on the fly without the terminal
03:19:55 <Broli> Morning :)
03:20:35 <Broli> What does Fixpunkt mean for a function and  please can i have some examples of how to calculate it in haskell? THanks :)
03:21:09 <Broli> or what does mean step function?
03:21:44 <oherrala> does this help: https://en.wikipedia.org/wiki/Fixed-point_combinator ?
03:22:15 <Broli> Sorry with Fixpunkt, i mean fixed point :)
03:30:33 <AWizzArd> In Go or Clojure one can do CSP, i.e. work with channels. One difference from a queue is that you can call something like `select` on a list of channels. It blocks until data can be read from any of them, and select would return that value.
03:30:37 <AWizzArd> I was given this example which looks pretty equivalent:  atomically (readTChan chan1 <|> readTChan chan2)
03:30:40 <AWizzArd> I wonder though why `atomically` is called here.
03:33:46 <mniip> hmm
03:33:50 <frerich> Did anyone to today's AoC puzzle yet? I'm not sure I get it right - shouldn't any of the four possible rotations for the initial image ([".#./..#/###","#../#.#/##.","###/#../.#.",".##/#.#/..#"]) show up in the given input file, given that it's a 3x3 image which should map to a 4x4 image?
03:33:55 <mniip> does readTChan retry once it finds it empty?
03:34:20 <AWizzArd> mniip: as I understand it: it blocks until some thread writes into the channel.
03:34:28 <mniip> I know what it does
03:34:30 <mniip> but what does it do
03:35:00 <AWizzArd> Not sure that I understand.
03:35:32 <AWizzArd> As long the channel is empty it will wait and do nothing. As soon there is a value in the channel readTChan will return it. There seems to be no need for retrying?
03:36:54 <Broli> What does mean step function for a function and then please have some examples of how to calculate  or write it. thanks :)
03:37:03 <mniip> AWizzArd, what does blocking mean in STM
03:37:25 <mniip> is it not just retrying until you find what you desire
03:37:30 <mniip> with a smart retry of course
03:37:48 * hackage zifter 0.0.1.4 - zifter  https://hackage.haskell.org/package/zifter-0.0.1.4 (Norfair)
03:38:40 <AWizzArd> I don’t know. Never tried to use it but was looking for equivalents of Go’s/Clojure’s CSP channels.
03:41:08 <Broli_> What does mean Step function for a function and then please have some examples of how to calculate or write it. thanks :)
03:41:13 <lyxia> AWizzArd: what does CSP stand for?
03:41:35 <lseactuary> anyone knows?
03:41:48 <AWizzArd> lyxia: https://en.wikipedia.org/wiki/Communicating_sequential_processes
03:41:59 <lyxia> AWizzArd: thanks
03:44:27 <AWizzArd> A very short and easy-to-understand intro is this: https://gobyexample.com/channels
03:44:46 <iqubic> What is a channel?
03:44:47 <lyxia> AWizzArd: internally, STM operations don't block.
03:45:35 <AWizzArd> iqubic: the link basically shows it in very simple examples. You can think of it like a queue, a FIFO queue. You can write once, then further writes into the channel block, until something will have been read. Reading blocks until something has been written.
03:46:24 <AWizzArd> But one interesting operation is `select` which is reading. It takes a list of channels and returns the value that the first channel with data contains.
03:47:24 <lyxia> AWizzArd: my guess is if chan1 is empty readTChan chan1 fails and causes the second alternative to be executed, if that fails, then the whole computation wrapped in atomically is canceled, and waits until either channel is updated
03:48:29 <AWizzArd> lyxia: okay, so my assumption that readTChan blocks is probably wrong.
03:50:37 <lyxia> AWizzArd: 'atomically' does the blocking
03:52:17 <AWizzArd> lyxia: okay, I think I am closer now to understand this.
03:52:21 <AWizzArd> Thanks! :)
03:52:28 <lyxia> the STM computation executes optimistically but rolls back if its result is not consistent with the computation being atomic
03:52:29 <Gurkenglas> Is there a variant of Template Haskell that uses dependent types to ensure that constructed splices compile?
03:53:42 <mniip> that sounds tough
03:54:49 <Gurkenglas> Theoretically possible, or theoretically impossible?
03:55:03 <mniip> theoretically hard
03:55:17 <Gurkenglas> What is theoretically reducible to this?
03:56:25 <Gurkenglas> Or what makes it hard, when it seems to me that all you'd need to do is for a few elementary combinators like application and case switches to do unification
03:57:32 <mniip> a theoretically-intermediate problem
04:00:47 <AWizzArd> Gurkenglas: isn’t LiquidHaskell preferrable over dependent types?
04:02:09 <Gurkenglas> Which problem, exactly? mniip, how is this harder than compilation?
04:09:08 <Gurkenglas> or was mniip just throwing around buzzwords
04:09:28 <mniip> best of both worlds
04:12:14 <otulp> AWizzArd: I think you were spot on when thinking that "atomically (readTChan chan1 <|> readTChan chan2)" is doing basically the same as select. The combined expression "expr1 <|> expr2 :: STM a" does block until it can actually yield a value of type a, but that value may come from either expr1 or expr2, depending on which of those unblocks first.
04:12:38 <iqubic> haskell mutability confuses me so much
04:14:20 <mniip> "unblocks"
04:14:27 <mniip> that's not a thing in STM is it
04:14:39 <mniip> I thought the abstraction is retrying
04:22:06 <otulp> It is retrying, but not busily.
04:22:35 <mniip> sure
04:22:45 <mniip> abstraction on abstraction
04:24:24 <otulp> I'm not sure what you mean, but from the type of atomically :: STM a -> IO a it *must* yield an value of type a. The only wait it doesn't is if it throws an exception because it has found out that there is no way for the value to ever materialize.
04:24:32 * hackage safecopy-store 0.9.6 - Binary serialization with version control.  https://hackage.haskell.org/package/safecopy-store-0.9.6 (NCrashed)
04:28:44 <yohotchoc> I believe the discussion originated with someone wanting to interrupt the operation (and hence have it throw an exception rather than return a value) based on some other timeout
04:29:44 <otulp> Oh. Then the value should be an Either or Maybe or something, injected by the timeout process, perhaps?
04:33:56 <otulp> Or simply kill off the writers when they exceed their timeout? :)
04:34:10 <Qwertie> Hi
04:34:38 <Qwertie> Would any yesod users be able to help me out with this? https://stackoverflow.com/questions/47916409/how-is-ydescribe-from-yesod-test-used
04:36:41 <Owatch> Hello all!
04:37:18 <infinisil> mniip: otulp: I think it would be possible by just doing something like do { x <- readTVar foo; case x of Nothing -> return Nothing; Just y -> <do the thing>; } Then just set foo to Nothing atomically to 'abort' it
04:37:55 <haskell399> Hello all
04:38:02 <infinisil> aborting in STM doesn't really make any sense, the operations don't have a running time because they're atomic
04:40:08 <haskell399> I am very new to web development ... almost doesn't know anything but I have to make a web app ... I am familier with Haskell .... I see there are multiple paths ... please suggest me one which would be simpler to do the job in 10 days... I know how to handle databases ... Thanks in advance
04:41:09 <Owatch> I've got a beginning problem,  maybe someone can help me. I have an infinite list function, which I am trying to make executable I can't seem to figure how to get around the "Can't match Int with IO Int" problem in the line: "mapM print (take getIntArg identifiers)". I hope this is okay to ask.
04:41:43 <Owatch> I've not made it through the great monad barrier.
04:41:45 <Gurkenglas> I'm still thinking about how TemplateHaskell could just be using a GADT for "Exp a" for an expression of type a, where "App :: Expr (a -> b) -> Expr a -> Expr b". Where's the problem with this?
04:41:48 <mniip> what's  getIntArg?
04:41:59 <Owatch>  getIntArg :: IO Int     getIntArg = fmap (read . head) getArgs
04:42:03 <Owatch> That's getIntArg.
04:42:07 <mniip> wlel
04:42:09 <mniip> well
04:42:15 <mniip> there's your problem
04:42:19 <Owatch> Just reads the first element of the argument vector I guess.
04:42:19 <AWizzArd> otulp: thanks for clarifying.
04:42:27 <otulp> infinisil: Yes. I've done this with parallel processing pipelines. Just let the upstream process "hang up" when done by supplying a Nothing.
04:42:35 <mniip> you'll need to bind that
04:42:53 <mniip> getIntArg >>= \arg -> mapM print (take arg identifiers)
04:42:58 <yohotchoc> Owatch: take a look at do notation too
04:43:00 <mniip> more commonly denoted as:
04:43:03 <haskell399> hello guys please look at my problem also ...:)
04:43:09 <mniip> do arg <- getIntArg; mapM print (take arg identifiers)
04:44:47 <Owatch> It was in a 'do' block. Thanks a bunch mniip for that. But now it says it expected IO() and got [IO()] for this line.
04:44:57 <mniip> what's identifiers?
04:45:16 <Owatch> identifiers :: [String], infinite list.
04:45:22 <mniip> hmm then it should work
04:45:26 <infinisil> haskell399: I feel like you'll get much faster answers and more information if you just googled for that tbh
04:45:29 <mniip> can you post the full code on
04:45:32 <mniip> @where lpaste
04:45:32 <lambdabot> http://lpaste.net/
04:45:58 <otulp> You want mapM_, which does not create a list.
04:46:02 <Owatch> Oh, already put it on: https://pastebin.com/eAtA8xt0
04:46:19 <mniip> ah
04:46:25 <mniip> () vs [()]
04:46:27 * hackage servant-auth-token 0.5.1.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.5.1.0 (NCrashed)
04:46:29 <mniip> you misquoted the error
04:46:44 <mniip> you can add another ; return ()
04:46:47 <mniip> at the end of the do block
04:46:54 <mniip> or use mapM_ which does exactly that
04:46:54 <haskell399> infinisil: actually I googled but there are lot of views .... I am messed up with choosing one ... suggestion from a practical user is better in every sense than google
04:47:03 <Owatch> Let me try mapM_
04:47:18 * hackage servant-auth-token-persistent 0.6.1.0 - Persistent backend for servant-auth-token server  https://hackage.haskell.org/package/servant-auth-token-persistent-0.6.1.0 (NCrashed)
04:47:19 <Owatch> Yes, it now compiles.
04:47:25 <Owatch> well, loads.
04:47:53 <Owatch> This is fantastic.
04:48:06 <Owatch> Thanks mniip.
04:49:25 * hackage servant-auth-token-acid 0.5.1.0, servant-auth-token-leveldb 0.5.1.0 (NCrashed): https://qbin.io/4rbdoamb
04:49:25 <haskell399> please help me out this ....
04:50:12 <otulp> haskell399: Sorry, but I really can't help much with that. I suppose go with whichever does the most out-of-the-box if the site is very simple, and try to modify example code until it does what you want? I know Yesod has a whole "Yesod Book" and can do lots of scaffolding to get you going.
04:51:02 <mniip> > let ids = [] : concatMap (\xs -> (:xs) <$> "abc") ids in ids
04:51:04 <lambdabot>  ["","a","b","c","aa","ba","ca","ab","bb","cb","ac","bc","cc","aaa","baa","ca...
04:51:49 * hackage servant-auth-token-rocksdb 0.5.1.0 - RocksDB backend for servant-auth-token server  https://hackage.haskell.org/package/servant-auth-token-rocksdb-0.5.1.0 (NCrashed)
04:51:56 <yohotchoc> Owatch: to explain what's going on there - the last expression in a do is what's returned. mapM sequences (essentially, executes) everything in the list you give it and returns a list of the results. mapM_ does the same, but without giving you the results
04:51:58 <mniip> > concatMap (`replicateM` "abc") [0..]
04:52:01 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
04:52:17 <mniip> not as efficient though I suspect
04:52:22 <mniip> and no sharing
04:52:25 <yohotchoc> print doesn't give you any useful results, so it doesn't matter which one you use, but mapM_'s return type matches what's expected in your do
04:53:09 <int-e> mniip: I'd rather consume a million elements from the second version than from the first.
04:53:45 <mniip> hmm?
04:54:39 <mniip> are you suggesting the latter list would be more optimal wrt consuming a large init and throwing it all away??
04:55:07 <int-e> mniip: no I'm suggesting that sharing isn't always a virtue
04:55:12 <Owatch> @yohotchoc, then wouldn't I want mapM instead of mapM_? I know the latter works, but don't I want the results.
04:55:12 <lambdabot> Unknown command, try @list
04:55:33 <mniip> :t mapM -- Owatch
04:55:35 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
04:55:44 <mniip> it returns a 't b' in the monad
04:55:49 <mniip> in your case [()]
04:55:58 <mniip> which is kinda useless
04:56:40 <yohotchoc> Owatch: the type of print is IO (), that is an IO action that returns the unit type
04:56:51 <yohotchoc> the unit type doesn't tell you anything that the function completing doesn't tell you
04:56:54 <mniip> actually here's to make it less confusing
04:56:55 <Psybur> > mapM return [1,2,3] :: [[Int]]
04:56:57 <lambdabot>  [[1,2,3]]
04:56:59 <mniip> % :t mapM @[] @IO
04:56:59 <yahb> mniip: mapM @[] @IO :: (a -> IO b) -> [a] -> IO [b]
04:57:05 <mniip> % :t mapM_ @[] @IO
04:57:06 <yahb> mniip: mapM_ @[] @IO :: (a -> IO b) -> [a] -> IO ()
04:57:07 <Owatch> So, it takes a function mapping anything of type 'a' to monad? b, my traversable type (list of strings), and returns a equivalent traversable monad list?
04:57:27 <Psybur> map pure [1,2,3] :: [[Int]]
04:57:30 <Psybur> > map pure [1,2,3] :: [[Int]]
04:57:33 <lambdabot>  [[1],[2],[3]]
04:58:00 <Psybur> Huh whats that all about
04:58:04 <shiona> % :t mapM_ @IO @[] -- weird new bot abilities?
04:58:05 <yahb> shiona: ; <interactive>:1:1: error: No instance for (Foldable IO) arising from a use of `mapM_'
04:58:19 <Psybur> Why are return and pure different in this case
04:58:27 <mniip> Psybur, map vs mapM
04:58:32 <mniip> shiona, it's a different bot
04:58:46 <mniip> full-blown ghci so you get TypeApplications and the like
04:58:55 <Psybur> @src mapM
04:58:55 <lambdabot> mapM f as = sequence (map f as)
04:59:08 <shiona> mniip: ok. Never seen that notation anywhere
04:59:13 <Psybur> @src sequence
04:59:13 <lambdabot> sequence []     = return []
04:59:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:59:13 <lambdabot> --OR
04:59:13 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
04:59:17 <haskell399> I am very new to web development ... almost doesn't know anything but I have to make a web app ... I am familier with Haskell .... I see there are multiple paths ... please suggest me one which would be simpler to do the job in 10 days... I know how to handle databases ... Thanks in advance
05:00:01 <Psybur> map return [1,2,3] :: [[Int]]
05:00:08 <Psybur> > map return [1,2,3] :: [[Int]]
05:00:10 <lambdabot>  [[1],[2],[3]]
05:00:14 <Psybur> I see
05:00:22 <yohotchoc> Owatch: one way to think of it is that the function maps a to some result wrapped in a monad m, and mapM applies it to everything in your list and returns a list of the results wrapped in that monad
05:01:17 <yohotchoc> in the case of print, which has type (simplifying..) String -> IO (), you'd just get a big list of [(), (), (), ...]
05:01:43 <jchia_> hpack question: Why does hpack add a "other-modules: Paths_doc" to the generated .cabal file? What does the Paths_doc mean? (My project is called 'doc'.)
05:02:05 <yohotchoc> or more specifically you'd get IO [(), (), (), ...] which is bound in your do to what I said before
05:02:23 <mniip> that's a weird mix of types and terms
05:02:43 <Psybur> > () <$ pure 1 :: IO ()
05:02:45 <lambdabot>  <IO ()>
05:03:18 <quchen> Owatch: mapM_ f xs = mapM f xs >> pure ()
05:03:26 <haskell399> it seems that I will not get any answers here ..... but why is my question too general or too simple
05:03:28 <yohotchoc> mniip: :|
05:03:31 <Owatch> Ah, okay. So mapM_ folded it into one 'action'?
05:03:51 <Owatch> Not really an action.
05:03:57 <quchen> Owatch: It just discards whatever mapM returned and returns () instead.
05:03:57 <yohotchoc> it's still a bunch of actions, it's just discarded the results (which is fine because they're not useful)
05:04:03 <quchen> And as for how mapM works, see https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
05:04:30 <cocreature> haskell399: I’d say it’s to general. if you ask specific questions about libraries you’ll get better answers
05:04:33 <yohotchoc> if print were to return a number instead you'd still just get () from mapM_
05:04:45 <cocreature> haskell399: also just stick around for a bit. not everybody checks the channel constantly
05:05:23 <jchia_> Another stack with hpack question: If my project uses package.yaml instead of a cabal file, 'stack build' automatically generates the .cabal file from the the package.yaml. Should I think of the generated .cabal file as an intermediate file to be added to .gitignore?
05:05:26 <quchen> It’s like doing { result = map(f, xs); return void; } in imperative languages. (For suitable »void« values.)
05:05:50 <quchen> Note how result is simply discarded, and a meaningless result is returned instead.
05:06:22 <quchen> in do-notation,  mapM_ f xs = do { _result <- mapM f xs; return () }
05:07:01 <haskell399> hmm ... well I am just asking that I don't know a bit about web development ..... I am experienced Haskeller ... please someone help or guide me for starting to write web apps
05:07:04 <Psybur> % getLine >>= print
05:07:09 <yahb> Psybur: [Timed out]
05:07:20 <Owatch> Hm, okay. I like this alternative with the explicit return instruction.
05:07:22 <quchen> % getLine >>= putStrLn
05:07:25 <quchen> % test
05:07:28 <yahb> quchen: [Timed out]
05:07:29 <yahb> quchen: ; <interactive>:1:1: error:; * Variable not in scope: test; * Perhaps you meant one of these: `text' (imported from Text.PrettyPrint.HughesPJ), `nest' (imported from Text.PrettyPrint.HughesPJ)
05:07:38 <quchen> Arrr. Pity!
05:07:49 <Psybur> %! echo bruh
05:07:50 <capisce> Arrr. Matey
05:07:50 <yahb> Psybur: bruh
05:07:51 <cocreature> haskell399: “web development” is a huge field. you really need to be a bit more specific in what you’re looking for
05:08:05 <Psybur> %! echo bruh > /dev/stdin
05:08:06 <yahb> Psybur: bash: line 1: /dev/stdin: No such file or directory
05:08:58 <Owatch> It makes more sense to me. I guess what I'm still confused by is what exactly was returned as an action. I thought for some reason that I was creating some abstract list of actions that would print each string, and they would need to be run or something. But I guess printing the string to stdout is not the action itself, and the actions (for lack of a better definition) are void.
05:09:03 <haskell399> cocreature: I am looking to build a web-app simple one with database support
05:09:21 <cocreature> haskell399: pick a database lib, pick a webframework and start writing it?
05:09:30 <Owatch> (Within the result of mapM)
05:09:44 <cocreature> haskell399: Spock might be a reasonable choice for the web framework since it’s relatively simple
05:09:56 <Psybur> %! echo bruh > /dev/tty
05:09:56 <yahb> Psybur: bash: line 1: /dev/tty: No such file or directory
05:10:04 <Psybur> %! ls /dev
05:10:04 <yahb> Psybur: ls: cannot access /dev: No such file or directory
05:10:23 <Psybur> %! uname -a
05:10:24 <yahb> Psybur: Linux mniip.com 4.9.0-0.bpo.3-amd64 #1 SMP Debian 4.9.25-1~bpo8+1 (2017-05-19) x86_64 GNU/Linux
05:10:42 <haskell399> cocreature: I know databases, spock I will see ... anything else will I need ..
05:10:49 <shiona> %! id
05:10:49 <yahb> shiona: uid=996 gid=996 groups=996
05:10:57 <quchen> Owatch: »getLine :: IO String« is an action that returns a String, and in order to do that, it performs a side effect (reading from STDIN).
05:11:29 <cocreature> haskell399: that should be enough to get you started. whether you need anything else depends on your exact requirements and you haven’t told us those :)
05:11:52 <quchen> Owatch: »IO anything« is often called an action, meaning that it is meant to go to the right of a »<-« in do-notation.
05:12:24 <cocreature> haskell399: but you’ll probably notice relatively quickly if something is missing :)
05:17:21 <haskell399> cocreature: Thanks a lot ... I will stick to it for now ... just to be clear I will require to embedd payment services later
05:21:45 <Owatch> quchen: Well that makes some other stuff I found when searching for a solution make more sense. Thank you for explaining that.
05:30:12 <DarkUnicorn> Hello! I am parsing some JSON with Aeson, getting a field value with ".:" (FromJSON a => Object -> Text -> Parser a) inside of a do block. I want to parse this value further with a function which also can result in a parser error (String -> Either ParseError String). Is there a way to combine them so that I get the parsed value or a JSON parse error?
05:34:05 <DarkUnicorn> the other function is a megaparsec parser
05:34:59 <DarkUnicorn> I think I have to combine them using a transform function which converts the megaparsec error to a aeson error
06:01:32 <sgronblo> I don't get what this message is trying to tell me: "connectors must match -any, but the stack configuration has no specified version needed since aoc2017 is a build target"
06:04:01 <glguy_> What's your stack.yaml look like?
06:04:05 <sgronblo> oh it means the package doesnt exist...
06:04:06 <sgronblo> doh
06:17:20 <otulp> DarkUnicorn: if you have a value "x :: Either ParseError String", I think you should be able to convert with "either fail pure x :: Parser String".
06:19:04 <otulp> Oh, fail needs a string. So "either (fail . show) pure x" or something similar.
06:20:38 <DarkUnicorn> otulp: ah, it's "either" then, thanks!
06:20:44 <DarkUnicorn> have to go
06:39:38 <Psybur> @pl \a b c -> (a + b) / c * c + a
06:39:39 <lambdabot> flip =<< ((flip . ((+) .)) .) . flip flip id . ((ap . ((*) .) . (/)) .) . (+)
06:40:05 <barrucadu> That's quite something
06:40:21 * hackage ghc-srcspan-plugin 0.2.2.1 - Generic GHC Plugin for annotating Haskell code with sourcelocation data.  https://hackage.haskell.org/package/ghc-srcspan-plugin-0.2.2.1 (EricSeidel)
06:45:07 * hackage memory 0.14.11 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.14.11 (VincentHanquez)
06:54:51 <dxtr> So if I'm using persistent for my database stuff - will that reuse the same pool every time I do the `withPostgresqlPool connStr X $ \p -> liftIO $ do flip runSqlPersistMPool' thing?
06:55:14 <dxtr> Seems awfully inefficient to open up a new pool everytime - but that seems to be what people are doing
06:56:21 <_sras_> If I have a type `data Address = LocalAddress { Street :: Text, City :: Text, State :: Text} | RemoteAddress { Country :: Text, Zip:: Text}` how can I use lens/prism/traversals to access fields of this type? I would like to get a maybe in return, to handle where there the branch does not exist in value.
06:59:59 <orion> ocharles: Hi, you areound?
07:03:30 <kakashiAL> orion: just ask your question, never ask to ask, asky your question, if after an hour nobody response ask the question again :)
07:04:31 <orion> kakashiAL: I specifically want to speak with ocharles.
07:05:16 <yohotchoc> that's what pm is for
07:05:59 <kakashiAL> orion: sorry :)
07:06:29 <dminuoso> :t flip flip id
07:06:31 <lambdabot> (a1 -> (a2 -> a2) -> c) -> a1 -> c
07:06:32 <dminuoso> Crazyness.
07:06:35 <orion> yohotchoc: Please forgive me for completely derailing the channel.
07:07:14 <tsahyt> I'm having trouble getting stackage lts-10 to work. AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
07:07:30 <tsahyt> I had the problem with nightly before and only "fixed" it by going to an older snapshot. I thought it'd get resolved with lts :/
07:07:40 <glguy_> What version of stack?
07:07:49 <tsahyt> Version 1.4.0, Git revision e714f1dd3fade19496d91bd6a017e435a96a6bcd (4640 commits) x86_64 hpack-0.17.0
07:08:05 <glguy_> Time to update
07:08:29 <tsahyt> ah. I used to have it installed via the package manager but for some reason used the install script this time
07:09:12 <mnoonan> tsahyt, see https://github.com/fpco/stackage/issues/2759 (looks like 1.6.1 fixes it)
07:09:27 <tsahyt> hmm, that's odd. I ran stack upgrade, and stack --version still gives the same string
07:10:42 <mnoonan> is it possible that "stack upgrade" installs the new version into ~/.local but you're running stack from somewhere else or something?
07:10:48 <tsahyt> yep that's it
07:11:11 <tsahyt> it upgrades into ~/.local but runs from /usr/local/bin/
07:11:25 <mnoonan> I think I've had that problem before too :)
07:12:05 <tsahyt> mnoonan: do you remember how you fixed it?
07:12:45 <mnoonan> tsahyt, I just changed the path to put ~/.local/bin before /usr/*
07:15:26 <tsahyt> well I suppose that works too. running sudo stack upgrade just results in not finding stack at all for some reason, and running it from a root shell just upgrades in /root/.local/bin.. neither is very satisfactory
07:16:08 <tsahyt> in any case, the error went away, thanks!
07:29:54 * hackage cndict 0.10.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.10.0 (DavidHimmelstrup)
07:40:13 <_sras_> If I have a type `data Address = LocalAddress { Street :: Text, City :: Text, State :: Text} | RemoteAddress { Country :: Text, Zip:: Text}` how can I use a prism to safely access fields of either one of the constructors.
07:40:18 <frerich> glguy: I think your solution for today's AoC is really pretty, but I would love to see the version you hacked up to get into the leaderboard. :-)
07:43:16 <Psybur> _sras_, (LocalAddress "a" "b" "c") ^? _LocalAddress returns a Maybe (Text, Text, Text)
07:43:30 <Psybur> That good enough?
07:43:35 <Psybur> Thats using a prism
07:43:59 <Psybur> _sras_, (LocalAddress "a" "b" "c") ^? _RemoteAddress returns Nothing
07:44:53 <_sras_> Psybur:  any way to access inner fields directly ? for example, try to get `city` field?
07:45:13 <Psybur> _sras_, yeah I cant seem to find a way to compose lenses and prisms :{
07:47:14 <glguy> frerich: My solution for the leaderboard was basically that without the comments or type signatures
07:47:50 <glguy> The only difference was that makeRules was inlined into main when I submitted
07:48:38 <_sras_> Psybur: Is it possible?
07:48:46 <glguy> Oh, and I'd copy/pasted the logic of mapSubSquares rather than the current version that factors out 'n'
07:48:56 <Psybur> I dont know, Im looking
07:51:22 <shapr> when I'm teaching Haskell to newbies I often pick an AoC, once they've solved it, I show them my solution, and then glguy's solution.
07:54:12 <_sras_> Psybur: Oh. np. Thanks pal.  In my attempt,  `^? _LocalAddress._1`  gets me Street value. but trying to refer to it by name instead of _1.
07:54:51 <Psybur> Yes, Im curious too _sras_. Looking :D
07:55:40 <glguy> shapr: Are you going to work through the new 2017 exercises?
07:56:23 <shapr> glguy: yup, I've done a few.
07:56:45 <frerich> shapr: Yeah, I get a lot out of it if I already know what a program is doing (and I know how I fought with solving some parts of the problem) and then looking at somebody else's code and seeing more sophisticated ideas. :-)
07:56:54 <glguy> Oh, are you doing them under a different name? not submitting solutions to the website? Your stars aren't showing up
07:57:10 <shapr> yeah, I switched to my github login instead of twitter
07:57:18 <shapr> Is there room on the #haskell leaderboard?
07:57:50 <glguy> of course! and the code is in /topic
07:57:57 <shapr> oh good
08:01:09 <frerich> Sometimes I find glguy's code hard to follow because I don't know the fixities of everything so well. E.g. 'take 4 . iterate rotateCCW =<< [x, reverse x]' confused me quite a bit until I realised that (.) binds stronger than =<< (I incorrectly thought that it would be the same as 'take 4 ([x, reverse x] >>= iterate rotateCCW)'. A lot of stuff to learn :-)
08:02:28 <frerich> Now I need to revisit all my uses of concatMap to see whether maybe using >>= or =<< would be nicer...
08:02:59 <glguy> Yeah, that solution's mixing of . and =<< isn't the clearest. I was hoping that introducing the combination early in the file with rotateCCW would prepare people for seeing it in mapSubSquares later
08:03:09 <hyperisco> the way to make solutions more complicated is to add more detail to the problem
08:03:23 <hyperisco> so conversely, the way to make solutions simpler is to remove more detail from the problem
08:03:51 <hyperisco> hint: most problems confuse you into assuming more detail than necessary
08:04:41 <Guest32890> hi, I want to do a request to a xml rpc api via haskell. I found this package here: https://hackage.haskell.org/package/haxr-3000.11.2/docs/Network-XmlRpc-Client.html and the remote-function works fine in ghci in that it prints me the answer as xml. However, the answer is a Remote t => t and not a string an I don't know how to get the string from it in a normal program. I can't call show on it, what can I do to make it work? Eve
08:04:44 <Guest32890> the given example in the documentation does not work for me
08:05:21 <Guest32890> it does not compile with: Ambiguous type variable ‘t0’ arising from a use of ‘remote’
08:05:24 <Guest32890>       prevents the constraint ‘(Network.XmlRpc.Internals.XmlRpcType
08:05:26 <Guest32890>                                   t0)’ from being solved.
08:05:28 <Guest32890>       Probable fix: use a type annotation to specify what ‘t0’ should be.
08:06:16 <Guest32890> the strange thing is that I see the xml result in ghci when calling "remote url functionStr" there
08:06:32 <hyperisco> an easy way to practice this is to solve problems this way: first, what is the space in which the solution can be found?
08:06:51 <Guest32890> so ghci seems to do something magically that I should do manually in my code
08:07:13 <frerich> glguy: What I really really like though is the idea of not passing a 'Map Grid Grid' (as I did) for the rules around and use it where needed, but rather only passing around the lookup function. It not only simplifies actually doing the lookups, it also nice encapsulates how you do the lookup - it would be easy to change from a Map to something else without changing much.
08:07:21 <hyperisco> enumerate all outputs in that space, then filter to just the one(s) which corresponds to the input
08:07:48 <Tuplanolla> It's quite like a categorical view of things, hyperisco.
08:07:54 <hyperisco> i.e. unfold a list of outputs, then fold this list (or just use filter)
08:08:09 <iqubic> how hard is it to make an irc bot in haskell?
08:08:31 <Tuplanolla> Form a category where the objects are solutions and morphisms represent some order of goodness. The best solution is then the terminal object.
08:08:35 <hyperisco> it may be really inefficient… it certainly is a good way to find the brute force solution
08:08:47 <pja> Guest32890: ghci will sometimes force types in order to output them. Maybe a judicious ::String somewhere will help?
08:08:50 <hyperisco> but, it is also really simple and removes a lot of detail
08:09:48 <hyperisco> then, you can add detail by enumerating the outputs more intelligently so more likely ones (given the input) appear first
08:10:01 <hyperisco> that is a bird's eye view of what optimisation is
08:10:24 <fiatjaf> can I use the `do` notation with a Maybe?
08:10:38 <hyperisco> but to do this you have to incorporate potentially a lot more detail about the problem, exploiting various properties
08:11:20 <mnoonan> fiatjaf: sure, you can use it for anything with a Monad instance
08:11:51 <frerich> shapr: Are your solutions for this year available online somewhere? I found https://github.com/shapr/adventofcode2016 -- but nothing for this year.
08:12:40 <hyperisco> quick example… for parsing, a simple parser can enumerate 2-tuples of all sentences and their corresponding parse tree, then just lookup the parse tree given an input
08:12:55 <fiatjaf> mnoonan, can I have an example?
08:13:01 <hyperisco> if you want the parser to reject inputs then you can improve by enumerating by increasing length
08:13:12 <fiatjaf> mnoonan, this is too mind boggling to me, I can't imagine an example
08:13:23 <mnoonan> fiatjaf, ok, just a moment..
08:13:47 <hyperisco> then if you want to make the parser faster you can make the enumeration more intelligent by doing lookahead, so you usually don't waste much time enumerating possibilities that will never work
08:14:02 <iqubic> so I'm creating a new stack project, and I ran into this error:
08:14:06 <iqubic> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
08:14:13 <MarcelineVQ> iqubic: upgrade stack
08:14:46 <iqubic> It's actually more of a warning, because the project is created properly.
08:15:23 <iqubic> Still getting the same result.
08:15:49 <iqubic> But the stack project is built correctly so I'm going to ignore that.
08:16:06 <mnoonan> fiatjaf: http://lpaste.net/361012
08:16:27 <fiatjaf> https://repl.it/repls/ImportantWiltedFrenchbulldog my stupid example that didn't work (please don't laugh)
08:17:18 <mnoonan> fiatjaf: that would work if you change [first] to "return first", and "first <- head c" to "first <- head <$> c" or "first <- fmap head c"
08:17:32 <mnoonan> oops, sorry, "return [first]"
08:18:50 <fiatjaf> ooooh
08:18:55 <fiatjaf> thank you.
08:19:29 <fiatjaf> that's beautiful.
08:19:35 <fiatjaf> thank you again.
08:19:44 <mnoonan> sure, no problem!
08:20:06 <fiatjaf> but on pairMaybes
08:20:12 <fiatjaf> why don't you have to deal with Nothing cases?
08:20:26 <fiatjaf> in case one of the arguments is Nothing the execution automatically jumps to the end?
08:20:36 <fiatjaf> and just returns Nothing?
08:21:07 <mnoonan> fiatjaf: for the Monad instance of Maybe, if an intermediate step evaluates to Nothing, then the rest can be ignored
08:21:31 <mnoonan> so when you do "x <- mx", you're either getting the x inside a Just x and continuing or, if mx is Nothing, you're done.
08:22:14 <fiatjaf> ok,I get it
08:22:25 <fiatjaf> but I can't imagine how is that defined
08:22:44 <fiatjaf> is there something like that, for example, in the Either monad? (I don't know any other monads)
08:23:31 <fakenullie> It should be defined in >>=
08:23:48 <mnoonan> fiatjaf, you don't have to imagine, just go to the definintion of Maybe here (https://hackage.haskell.org/package/base-4.10.1.0/docs/Prelude.html) and click "# Source" next to the Monad Maybe instance listed
08:23:52 <fiatjaf> makes sense
08:24:38 <mnoonan> (you can also check out Either from the same haddock page)
08:24:45 <fiatjaf> ok.
08:24:47 <fiatjaf> I'll do that.
08:25:09 <Psybur> @source (>>=)
08:25:09 <lambdabot> Unknown command, try @list
08:25:14 <Psybur> @src (>>=)
08:25:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:25:38 <iqubic> Psybur: that's defined per instance
08:25:56 <iqubic> There is no one implementation for that.
08:26:27 <Psybur> Yeah supposed there wouldnt be a fun default for that :D
08:27:03 <fiatjaf> nah, I can't understand that yet.
08:27:05 <fiatjaf> maybe next week
08:27:28 <fiatjaf> thanks anyway. already too much things learned today.
08:27:57 <fakenullie> @src Maybe (>>=)
08:27:57 <lambdabot> (Just x) >>= k = k x
08:27:57 <lambdabot> Nothing  >>= _ = Nothing
08:28:10 <mnoonan> it's pretty straightforward once you understand how do notation is de-sugared into uses of (>>=) and (>>), but that de-sugaring can seem mysterious at first
08:28:58 <iqubic> So intero is failing because it can't find my stack project root.
08:29:00 <robwebbjr_> Hello. I am actually a beginner, but I am told I can ask questions here also. I am trying to load a module from the Haskell Book into the emacs repl. It doesn't load but the module works when I use stack ghci in a terminal. is there some way to get emacs to use the ghc that stack sandboxed? Here are more details: http://lpaste.net/360556 Thank you.
08:29:13 <iqubic> Anyone know what's up with that/
08:29:23 <mnoonan> robwebbjr_, you probably want to use intero-mode, which is stack-aware
08:29:34 <iqubic> is it related to my aeson exception?
08:29:51 <glguy_> robwebbjr_: This channel is fine for beginner questions. No need to worry
08:30:10 <Tuplanolla> I got rid of that error when I did `stack upgrade` recently, iqubic.
08:30:14 <runeks> Let's say I want to use foldl, and I expect to consume only a relatively small part of all the items in the list/Vector before having the final result (thus skipping the remaining items). Is there a reason to use a foldl that exits early, or will GHC optimize my code so it doesn't matter that much?
08:30:15 <Tuplanolla> That's all I know.
08:30:19 <robwebbjr_> Hi and thank you. Do i just install intero-mode in emacs?
08:30:51 <mnoonan> robwebbjr_: http://commercialhaskell.github.io/intero/
08:30:52 <bikini> Dunno if this is the place to ask this, but Functors move morphisms to other morphisms; that feels like a nice 2-morphism, but natural transformations seem to me to move only tips of functors. Is my intuition poor?
08:30:57 <glguy_> Runeks: foldl never exists early
08:31:02 <iqubic> tuplanolla: I'm on Nix, and stack upgrade didn't fix my issue.
08:31:14 <vivekramaswamy> I was going through a book where they have implemented the foldl function recursively see http://lpaste.net/361016 my question is when I try to apply this function to say my_foldl (+) 0 [1..3] I am imagining something like + 1 +2 + 3 + 0, which is wrong. however the function works fine. Why?
08:31:17 <robwebbjr_> Excellent! Thanks again!
08:32:18 <fiatjaf> @src Either (>>=)
08:32:18 <lambdabot> Left  l >>= _ = Left l
08:32:18 <lambdabot> Right r >>= k = k r
08:32:21 <glguy_> vivekramaswamy: that implementation of foldl is wrong, that's foldr
08:32:35 <vivekramaswamy> sorry my bad foldr
08:32:45 <runeks> glguy_: Right. Which is why I'm considering writing a version that does. But I would like to know if the performance penalty is negligible from never exiting early (i.e. can GHC optimize it away?).
08:32:50 <vivekramaswamy> right but the queston remanins
08:33:29 <glguy_> vivekramaswamy: I don't understand your question, maybe someone else does?
08:33:45 <glguy_> > foldr f z [a,b,c]
08:33:49 <lambdabot>  f a (f b (f c z))
08:34:00 <iqubic> Well, I don't understand why stack s throwing errors
08:34:01 <mnoonan> bikini: it sounds like you want to look at a category C, and make it into a 2-category where the 2-morphisms are endofunctors F : C -> C. is that accurate?
08:34:44 <bikini> my idea of a real 3-morphism would be something that takes a 2-moprhism (C => D) to a 2-morphism (E => F), but natural transformations seem to stick to morphisms between (C=>D)
08:35:33 <bikini> mnoonan: yeah, I think you modus tollens'd where I modus ponens'd :P
08:35:39 <mnoonan> bikini: the common definition of 2-morphisms has the source and target objects fixed though
08:35:47 <vivekramaswamy> like lambdabot just wrote if you translate f a (f b (f c z)) it gets translated to + a (+ b (+ c)) if I use the function (+)
08:35:50 <fiatjaf> > foldr f z [a,b,c,d,e]
08:35:52 <bikini> mnoonan: yeah, I'm asking for the motivation for that
08:35:53 <lambdabot>  f a (f b (f c (f d (f e z))))
08:36:12 <mnoonan> that's why you can't do the endofunctor thing; most endofunctors are not the identity on objects, so they take a "f : a -> b" to a "F f : F a -> F b" with F a /= a, etc
08:36:20 <vivekramaswamy> which on a command line gives an error
08:36:38 <glguy_> vivekramaswamy: to use + in prefix form like that, you use (+)
08:36:51 <vivekramaswamy> try evaluating +1 +2 +3
08:36:57 <mnoonan> bikini: ah, I don't know the motivation other than "it is useful". ncatlab has a few other options, but still not the one you want: https://ncatlab.org/nlab/show/2-morphism
08:37:19 <glguy_> > (+) 1 ((+) 2 3)
08:37:22 <lambdabot>  6
08:37:24 <iqubic> Is it normal for new stack projects using the simple template to be made without a stack.yaml?
08:37:33 <vivekramaswamy> oh ok, now I get it I think that is why we add 0 fr addintion
08:37:39 <iqubic> Or is this related to my error?
08:38:23 <vivekramaswamy> Thanks a lot I think I get it now
08:38:40 <MarcelineVQ> iqubic: no, probably
08:38:53 <kadoban> iqubic: Nope, not normal. What's the error?
08:39:33 <iqubic> Stack upgrade gives me the following:
08:39:35 <iqubic> WARNING: Installation path /home/avi/.local/bin not found on the PATH environment variable
08:39:50 <iqubic> New stack executable available at /home/avi/.local/bin/stack
08:40:01 <ph88_> do package versions ever change (even for the most minor minor minor releases) when a stack lts stays the same ?
08:40:44 <iqubic> And "stack new test simple" gives me:
08:40:49 <kadoban> Put that directory near the beginning of your PATH. Usually that's set in uhm ~/.profile or something I think? Maybe ~/.bashrc or something instead sometimes
08:40:50 <MarcelineVQ> iqubic: that warning reads "we made you a new executable, the place we put is isn't on your PATH, you should fix this"
08:41:07 <brynedwards> iqubic: what's the output of `which stack`?
08:41:50 <iqubic> I use NixOS, so the output is a bit funky.
08:41:55 <iqubic> /run/current-system/sw/bin/stack
08:42:29 <MarcelineVQ> idk much about nix, but you should probbaly upgrade stack via nix yeah?
08:42:35 <iqubic> NixOS is making this a pain in the arse.
08:42:59 <iqubic> MarcelineVQ: There is no new stack version in the nix repos.
08:43:51 <iqubic> Asking the folks in #nixos now
08:45:33 <brynedwards> iqubic: Do you need to use stack? As this page states, Nix and stack provide similar functions https://github.com/Gabriel439/haskell-nix#background
08:45:52 <iqubic> I want to use intero mode for haskell, so yes
08:46:34 <brynedwards> Well I don't use emacs anymore, but I've heard good things about dante which is similar and doesn't depend on stack
08:46:39 <brynedwards> It's here https://github.com/jyp/dante
08:46:41 <MarcelineVQ> have a look at dante if you like, it's intero without stack via ghci's ide hooks
08:46:44 <MarcelineVQ> boops :>
08:46:47 <brynedwards> :)
08:47:07 <ph88_> are package versions guaranteed not to change within a stack LTS release ?
08:47:22 <MarcelineVQ> ph88_: they're supposed to be
08:47:33 <MarcelineVQ> that's what the l of lts means anyway, so hopefully.
08:47:57 <kadoban> Within a single lts release, like x.yy ? I'm pretty sure they are allowed to change versions within a major lts version.
08:48:00 <ph88_> MarcelineVQ, ye ok .. i was hoping someone could just say "it's guaranteed"
08:48:22 <kadoban> I think it's something like they're allowed to change minor versions, or something like that.
08:49:14 <ph88_> so i use an LTS release, come back one year later and minor versions could have changed ?
08:49:48 <kadoban> I'd require clarification of what you mean by a LTS release to answer that.
08:49:57 <MarcelineVQ> No, kadoban is referring to how versions change between 8.17 and 8.18
08:50:08 <ph88_> LTS as it's used on stackage with a specific lts number attached to it
08:50:23 <kadoban> Like lts-8  or lts-8.0 ?
08:50:40 <kadoban> Because both can be used places, and I'm not sure which you mean.
08:50:45 <ph88_> for example if i use lts-10.0 are the packages in this release guaranteed not to change version number ?
08:51:02 <kadoban> Yeah, those don't change versions, they're all fixed.
08:51:21 <ph88_> is that written somewhere ?
08:51:29 <kadoban> Not sure
08:51:47 <ph88_> ok thank you
08:51:50 <brynedwards> ph88_: The second bullet point here implies they'll change the minor version number (the third number) https://github.com/fpco/stackage/#frequently-asked-questions
08:52:38 <kadoban> brynedwards: It's talking about the lts-8 case, not lts-8.0
08:53:59 <kadoban> The first bullet point there states right out that they won't change what's in a particular snapshot.
08:55:09 <brynedwards> kadoban: I thought he was asking about package versions changing when using an LTS release
08:55:44 <hoon> morning
08:57:16 <hoon> I think I've more or less finished a little "toy" utility I made. I'm looking for a code review if I can get it: http://lpaste.net/360949
09:03:20 <lyxia> That looks pretty clean
09:03:54 <yohotchoc> it's Haskell actually :^)
09:04:42 <lyxia> hoon: writeHFile could be made less noisy by putting the lines in a list and using unlines.
09:05:19 <hoon> lyxia: I was thinking something like -- mapM_ (hPutStrLn outh) lines
09:05:41 <mnoonan> that's the only thing that leaped out at me, too
09:05:44 <hyperisco> hoon, just reading the syntax here and it looks alright. I would cap the line length to half a 1080p monitor minus a toolbar, and then also don't be afraid to use extra newlines in where blocks, especially when you have type decls
09:06:52 <shapr> yohotchoc: punny, have you written any code in Clean?
09:07:50 <hexagoxel> every time i try to build stack using cabal, something is broken, due to lacking version bounds.
09:08:23 <hoon> hyperisco: can you give me an example of where extra newlines would help me out in my where blocks?
09:08:40 <hexagoxel> am i supposed to use a build-tool who's maintainers don't seem to be able to do basic haskell package maintenance?
09:08:53 <hyperisco> hoon, you put newlines between your TLDs. You can do the same in where blocks
09:09:59 <hoon> haha! forgive me: TLDs?
09:10:03 <kadoban> hexagoxel: That's unfortunate. And sure, why not. I'm sure you realize that none of the main stack devs are building stack that way, so it's pretty understandable why that's not caught.
09:10:08 <hyperisco> top-level definitions
09:10:37 <kadoban> If you have particular examples, bug reports are most welcome. Maybe it could be added to a CI script or something to make sure that keeps working.
09:11:14 <hoon> oh, so you're saying rather than "where blah = foo\nbaz = bar" do "where blah = foo\n\n\nba = bar"
09:11:58 <glguy> hexagoxel: Not doing a good job with version tracking is kind of the point, so it makes sense that would happen
09:12:10 <AWizzArd> What is a data definition without a corresponding `=` char?   I saw  data State = Unbound | Bound | Listening | …   which is clear, but then:    data Socket (s :: State)
09:12:20 <AWizzArd> What is this   (s :: State) thing?
09:12:30 <lyxia> AWizzArd: It's a type with no constructors
09:12:33 <glguy> AWizzArd: That's an "empty data declaration", it just has no data constructors
09:12:39 <glguy> the :: State is a "kind signature"
09:13:02 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=emptydatadecl#ghc-flag--XEmptyDataDecls
09:13:05 <yohotchoc> shapr: nope
09:13:30 <hoon> thanks everyone for the feedback
09:13:58 <glguy> AWizzArd: The other way that this happens is if you're looking at the haddock generated documentation for a datatype whose data constructors are simply not exported
09:14:09 <mnoonan> hoon: also, I know somebody mentioned this yesterday, but if you haven't checked out optparse-applicative yet.. do :)
09:14:50 <AWizzArd> Okay I see. Sounds a bit like Phantom types.
09:14:58 * hexagoxel discovers that the stack package issue tracker link is broken. well, two issues to report.
09:15:33 <hoon> mnoonan: yeah, I haven't touched it yet
09:15:40 <hoon> I do plan to look into it
09:15:58 <kadoban> That's weird. I thought github used to forward blah.git to blah
09:16:08 <hoon> I guess I should also consider exception handling
09:16:59 <hoon> but I don't know how crazy I want to go
09:18:17 <effa>  /bye
09:30:24 <fdnick> can anybody help me? i try to install intero with `stack install intero` and it fails with  http://lpaste.net/8998588691421069312
09:32:00 <kadoban> fdnick: Anything in the log it mentions?
09:32:13 <robwebbjr> Hello. I am working with inter-mode in emacs and got an error. Would you please help me find a solution? The details are here: http://lpaste.net/360556 Thank you.
09:32:41 <glguy> fdnick: Which Linux are you using?
09:33:23 <glguy> robwebbjr: ZipList and Sum alraedy have Arbitrary instances, so you can't make new ones
09:34:44 <fdnick> kadoban: it's the same error messages
09:34:57 <fdnick> glguy: arch
09:35:07 <kadoban> Hm, not sure what that is. Oh arch, ugh.
09:35:39 <glguy> You'll need an Arch user to help you work out arch's specialness if it's not on the wiki
09:35:57 <robwebbjr> OK, so this is just something I should ignore? just read this exercise instead of trying to enter it?
09:36:09 <kadoban> https://github.com/commercialhaskell/stack/issues?utf8=%E2%9C%93&q=is%3Aissue+arch you could peruse these if you're feeling lucky, there's various workarounds for arch funniness that I never understand.
09:36:55 <robwebbjr> <glguy> my response was directed thus...
09:37:04 <bigos_> given the IO example https://hastebin.com/bedokiluwe.hs how do i modify it so that promptAndEcho returns a string and maain prints the entered text
09:37:31 <fdnick> is there a linux-distro that you would recomment for haskell development?
09:37:38 <glguy> robwebbjr: You can define your own type and make an instance for that type if you want, you just can't redfine an existing instance
09:37:50 <fdnick> all but arch i assume
09:38:11 <kadoban> fdnick: Pretty much. linux mint or ubuntu or whatever seems to get good support as far as I've noticed.
09:38:30 <kadoban> Whatever is going on is probably fixable more easily than installing a different distro though. I just don't know how.
09:39:26 <fdnick> I have trouble with the arch-haskell combination quite often, so i am ok with having a second partition for haskell
09:40:23 <kadoban> Yeah, arch and haskell don't seem to be very good friends in general.
09:40:25 <Psybur> bigos_, https://hastebin.com/ovuqovijup.hs
09:40:25 <monochrom> bigos_: https://hastebin.com/ozenipateh.hs
09:40:32 <monochrom> Oh darn haha
09:40:37 <Psybur> heh
09:41:18 <monochrom> Seriously, again, read my http://www.vex.net/~trebla/haskell/IO.xhtml
09:41:37 <monochrom> Turn off your computer now and start reading now.
09:42:06 <monochrom> Do not think you can multitask IRCing and studying at the same time.
09:42:14 <Psybur> Man I botched mine, I forgot to echo what was printed in promptAndEcho
09:42:19 <Psybur> monochrom, your function also doesnt echo heh
09:42:32 <bigos_> monochrom: your example gives me type errors
09:42:55 <monochrom> Oh that's because I forgot to change the type sig.
09:43:05 <Psybur> bigos_, https://hastebin.com/enetufucod.hs
09:43:08 <monochrom> Do you mind changing it to "String -> IO String" yourself?
09:43:27 <glguy> Make sure you print IO.xhtml before you turn off the computer
09:43:39 <monochrom> Heh
09:44:00 <bigos_> i have removed the type sigature and haskell figured it out
09:44:05 <bigos_> thanks
09:55:04 <hoon> whoa
09:55:10 <hoon> hastebin is nice!
10:00:30 <yohotchoc> yeah, but it expires quite fast IIRC
10:00:45 <kadoban> hoon: Requires JS to view even raw text.
10:00:57 <kadoban> gist.github.com and lpaste.net are better IMO
10:01:11 <yohotchoc> is there some issue with pastebin?
10:01:49 <hoon> yohotchoc: the claim is 30 days from the last view, but that it can go away arbitrarily
10:01:49 <kadoban> pastebin.com? No issue other than it being the worst piece of crap on the internet
10:02:45 <hoon> kadoban: fair enough -- bulky maybe, but I like the "cat file | haste" option. That's handy
10:03:13 <kadoban> hoon: I would imagine you can set up similar things with other pastebins, though I don't know of premade tools for them.
10:04:24 <hoon> I'm sure
10:04:29 <hoon> better them than me
10:13:28 <glguy> yohotchoc: Yeah, pastebin is covered in ads, we prefer other hosts here
10:14:42 <hoon> also, kadoban, I don't think you need JS if you follow a raw path
10:14:48 <hoon> for example: https://hastebin.com/raw/uciwufahad
10:14:56 <yohotchoc> ah, been a long time since I haven't used an adblocker - I did wonder why everyone stopped using it
10:15:56 <kadoban> hoon: Yes, but then I have to remember what the change to the URL is. The buttons to click don't exist without JS, or they don't work at least.
10:16:01 <kadoban> Which I find fairly ridiculous.
10:18:47 <glguy> jle`: for your lens solution you might like: transposed = involuted transpose; and chunked n = iso (chunksOf n) concat
10:19:29 <fakenullie> !t chunksOf
10:19:34 <fakenullie> :t chunksOf
10:19:36 <lambdabot> Int -> [e] -> [[e]]
10:28:46 <glguy> jle`:   over (chunked n . mapped . mapping (chunked n) . transposed . mapped) rules xs
10:30:50 * hackage log-warper 1.8.3 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.8.3 (shersh)
10:41:57 <fakenullie> :t chunked
10:41:58 <lambdabot> error:
10:41:59 <lambdabot>     • Variable not in scope: chunked
10:41:59 <lambdabot>     • Perhaps you meant ‘chunk’ (imported from Data.List.Split)
10:45:20 <ph88> when profiling a program multiple times is there an option to get the average/minimum/maximum time ?
10:47:36 <barrucadu> Depends on the profiling tool you use I guess
10:47:43 <jle`> glguy: oh hey nice :) thanks!
10:47:55 <barrucadu> bench (which uses criterion internally) does give stats
10:49:40 <fakenullie> it's not quite a profiler
10:51:58 <ph88> barrucadu, i mean the ghc prof
10:52:26 <barrucadu> Ah, I don't know of anything for that
11:08:11 <Bemato> @help
11:08:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:08:28 <Bemato> @list
11:08:28 <lambdabot> What module?  Try @listmodules for some ideas.
11:08:44 <Bemato> @listmodules
11:08:44 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
11:08:44 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
11:09:14 <fakenullie> Bemato: you'd better do it in its private messages
11:10:27 <f-a> hello folks, I was reading http://www.tweag.io/posts/2017-12-21-reflection-tutorial.html , and the author, in writing `reflectOrd :: Proxy s -> a -> ReflectedOrd s a`, adds
11:10:37 <f-a> reflectOrd :: Proxy s -> a -> ReflectedOrd s a
11:10:43 <f-a> woops, I meant -- | Like `ReflectOrd` but takes a `Proxy` argument to help GHC with unification
11:11:04 <f-a> how is ghc affected by this apparently meaningless `Proxy s`?
11:12:27 <mnoonan> f-a: consider "read :: Read a => String -> a". You may not always have enough context to figure out what "a" should be, as in "show . read"
11:13:03 <mnoonan> but you could define "myRead :: Read a => Proxy a -> String -> a" by "myRead _ s = read s", and then you can pass a proxy of the appropriate type to determine the output type
11:13:14 <glguy> f-a: IT's the same was as (id ([] :: [Int]))'s type is affected by a list that doesn't use any ints
11:13:21 <glguy> :t id ([] :: [Int])
11:13:22 <lambdabot> [Int]
11:13:23 <glguy> :t id
11:13:25 <lambdabot> a -> a
11:13:47 <glguy> Information propagates through the type because the type variable is used in multiple positions
11:13:55 <f-a> ah, that's quite clever
11:13:59 <f-a> thanks mnoonan & glguy
11:15:44 <Average-user> glguy: How did you find day 21?
11:21:11 <EvanR> monoid instance for Maybe is kind of funny right
11:21:28 <EvanR> mappend (Just []) Nothing = Just []. mappend Nothing Nothing = Nothing
11:21:43 <glguy> I went looking in the same place as I'd found day 20 :-p
11:22:08 <glguy> I thought it was a little easier than some of the other recent ones, but it was nice to mix in a bit of list/array chunking into the mix
11:22:29 <mnoonan> EvanR: what's wrong with that?
11:22:38 <glguy> I had one of my better recent leaderboard finishes on it
11:22:50 <EvanR> so many levels of nothing
11:23:25 <EvanR> > mappend (Just (Just [])) (Just Nothing)
11:23:28 <lambdabot>  Just (Just [])
11:23:54 <EvanR> so the deepest nothing wins
11:24:01 <johnw> EvanR: very zen
11:24:21 <EvanR> ikr
11:24:44 <EvanR> how many levels of nothing are you on
11:26:44 <Average-user> glguy: I founded it hard, mainly because I had to write almost every function to work with matrices
11:27:17 <glguy> Haskell's pretty good for list manipulation, so I was spared that
11:28:43 <amalloy> i have a value of type [Maybe a], and a function (a -> Either err b), and i'd like to get a single result of type Either err b. i expect that the list contains exactly one Just value, and want to return some Left value if there are zero Justs, or if there are more than one. what function/type am i looking for?
11:29:23 <amalloy> it's easy to use <|> if i don't mind ignoring the more-than-one case, but i'm not sure how to adapt that to also include an error if there are too many
11:29:56 <glguy_> You can case on the result of catMatbes
11:30:33 <hoon> :t catMaybes
11:30:35 <lambdabot> [Maybe a] -> [a]
11:35:34 <hoon> case catMaybes ms of [] -> Left "NONE"; [a] -> Right a; _ -> Left "MANY"
11:36:15 <hoon> > let findJust ms = case catMaybes ms of [] -> Left "No Just Value"; [a] -> Right a; _ -> Left "Several Just Values"
11:36:18 <lambdabot>  <no location info>: error:
11:36:18 <lambdabot>      not an expression: ‘let findJust ms = case catMaybes ms of [] -> Left "N...
11:36:33 <mnoonan> EvanR: http://lpaste.net/361025
11:36:46 <amalloy> that makes sense, thanks
11:38:35 <EvanR> thats a lot of nothing
11:39:20 <mnoonan> but not a lot of Nothing!
11:39:43 <EvanR> it kind of looks like you implemented the Monoid instance for Fix in terms of itself
11:40:26 <EvanR> ah flexible contexts, interesting
11:49:00 <mnoonan> EvanR: ooh, I just realized something.. now with a mystery operation: http://lpaste.net/361025
11:49:56 <EvanR> lol
11:50:41 <EvanR> mysteryOp = max
11:50:46 <EvanR> which works for infinity
11:50:51 <mnoonan> indeed :)
11:51:27 <mnoonan> creatio ex nihilo
12:23:42 <lavalike> I'm a bit lost. Can I use this function with a mutable vector? https://www.stackage.org/haddock/lts-10.0/vector-0.12.0.1/Data-Vector-Unboxed.html#v:update_
12:25:04 <lavalike> this function lets me take a part of a mutable vector inside an ST action, am I then supposed to code up a loop that uses write to put that slice somewhere else? https://www.stackage.org/haddock/lts-10.0/vector-0.12.0.1/Data-Vector-Unboxed-Mutable.html#v:slice
12:26:53 <fakenullie> why do you use mutable vector if you're going to use update?
12:28:31 <lavalike> so the answer is no, update_ works only on immutable vectors?
12:29:26 <fakenullie> mutable is there so you could update it with loops efficiently
12:29:43 <fakenullie> if you're going to use update, it's more efficent to just use it on immutable one
12:29:59 <lavalike> am I wrong in saying that the only write operations available in mutable are for a single element or the whole array?
12:31:46 <lavalike> there is this baffling thing when you click on the Source link for update_ for example, the implementation consists of: "update_ = G.update_". So I thought maybe that could resolve to one for MVector too (:
12:33:26 <Guest71030> anyone have time to help with super noobish question on imports in stack?
12:33:43 <fakenullie> just ask
12:35:19 <Guest71030> Can't get import of "Maybe" to work, though I import Base...
12:35:37 <fakenullie> Maybe is in prelude, you don't need to import anything
12:36:10 <fakenullie> tf you mean Data.Maybe, it's just import Data.Maybe
12:37:00 <Guest71030> okay, but when I run "stack build", it complains about "Maybe". Can't figure out what dependency to add to .cabal to get it to work.
12:37:25 <fakenullie> you don't need to put into cabal
12:37:28 <mnoonan> can you paste your .cabal and .hs files in lpaste?
12:38:30 <Guest71030> probably, not sure what lspaste is though..
12:38:54 <mnoonan> http://lpaste.net/
12:40:48 <geekosaur> Guest71030, you may simply be trying to install/use an ancient package
12:41:10 <geekosaur> "Maybe" was the haskell 98 standard name of what haskell2010, and the revised haskell98 report, calls Data.Maybe
12:41:36 <geekosaur> if the package is old enough, it will only work with original Haskell98 and will need source changes to be compatible with anything else
12:42:21 <geekosaur> (ghc used to have backward compatibility, but these days has enough non-backward-compatible changes that it can't and therefore doesn't bother trying any more. most of those are targeting the upcoming Haskell2020 standard)
12:42:29 <Guest71030> hmm, thanks. Just changed .hs to "import Data.Maybe" - seems to work
12:42:53 <Guest71030> I'll run through the other issues I have and see if package is all wrong
12:42:57 <Guest71030> thanks!!!
12:43:17 <geekosaur> you will also see this with Monad (Control.Monad), Char (Data.Char), IO (System.IO), and a number of other modules
12:47:12 <ph88> hey guys, i'm trying to profile a program https://bpaste.net/show/cb1a439e6bdc  a bench.prof file is generated but it's 0 bytes .. what could be wrong ?
12:47:37 <dminuoso> Is span = ((.) . (.)) break ?
12:47:55 <dminuoso> ** span = ((.) . (.)) swap break
12:48:38 <geekosaur> ph88, are you interrupting the run (e.g. ^C to exit)?
12:48:51 <geekosaur> prof is only written on normal exit iirc
12:48:59 <ph88> geekosaur, that could be happening yes
12:49:05 <geekosaur> (with a long enough run you may get unusable partial output)
12:49:17 <ph88> it's a webserver
12:49:32 <ph88> is there even a signal that can be send to stop the webserver and write the prof file ?
12:49:55 <ph88> i mean this program is not suppose to stop by itself :P
12:50:01 <geekosaur> if you hanbdle the signal and normal exit, yes. or just provide a specific endpoint that triggers normal exit on connect
12:50:29 <ph88> you mean the signal that comes from ^C ?
12:50:33 <geekosaur> yes
12:50:57 <ph88> ok thank you
12:51:04 <dminuoso> Mmm. Im slowly beginning to wonder how my linter knows about all those extensionally equivalent ways to write code: Found: (takeWhile p l, dropWhile p l) Why not: span p l
12:51:10 <geekosaur> System.Posix.Signals module and you want sIGINT
12:51:26 <dminuoso> Are these likely just hard coded? Or are there algorithms to find such simplifications?
12:51:49 <geekosaur> dminuoso, most of them are hardcoded. hlint has extension mechanisms to add project-specific atterns
12:51:54 <geekosaur> *patterns
12:54:41 <mnoonan> @check \f xs -> span f xs == (((.) . (.)) swap break) f xs -- dminuoso
12:54:43 <dminuoso> geekosaur: Ahh, hlint thank you. https://github.com/ndmitchell/hlint/blob/master/data/hlint.yaml :)
12:54:43 <lambdabot>  <hint>:1:86: error:
12:54:43 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
12:58:20 <dminuoso> mnoonan: Oh that's neat. lambdabot is slowly becoming my best friend, thank you.
12:58:40 <dminuoso> I tried about 20 cases by hand before I asked, this would have been so much faster.
13:00:17 <mnoonan> dminuoso: I think it is just using a wrapper around QuickCheck, which you should check out if you haven't yet. It's nice!
13:00:42 <geekosaur> yes
13:01:00 <geekosaur> (I think there's also a SmallCheck wrapper)
13:01:11 <geekosaur> @help scheck
13:01:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:03:17 <dminuoso> mnoonan: Yeah I did actually check it out. But it very quickly felt so overwhelming that I stepped back.
13:03:43 <dminuoso> Which was a bit frustrating because I wanted to start with tests right from the beginning for each "excercise" and "plaything" I write.
13:04:18 <dminuoso> It seems to be covered in RWH though in a couple chapters, so :)
13:05:39 <mnoonan> dminuoso: hspec might be your friend: https://hspec.github.io/quickcheck.html
13:05:40 <hoon> is there a lambdabot cheatsheet somewhere?
13:06:18 <Broli> Hello!
13:06:26 <Broli> i have a question
13:06:48 <Broli> if i do type bino a = [(a, a)]
13:07:05 <Broli> can i call map on bino a?
13:07:13 <dminuoso> mnoonan: Oh boy that looks suspiciously similar to Ruby's rspec :-)
13:07:25 <mnoonan> yes indeed!
13:07:26 <Broli> i mean the map function on bino a?
13:08:37 <contiver> Hi! has anybody had any issues with "shadowed dependencies when building? I tried updating a package to use stack's LTS 10.0 with the latest GHC, and started getting that issue when running stack test or stack bench :\
13:09:24 <fakenullie> > let bino a = [(a, a)] in map bino ]"hello", "goodbye"]
13:09:27 <lambdabot>  <hint>:1:35: error: parse error on input ‘]’
13:09:41 <fakenullie> > let bino a = [(a, a)] in map bino ["hello", "goodbye"]
13:09:44 <lambdabot>  [[("hello","hello")],[("goodbye","goodbye")]]
13:12:12 <hoon> > type Bino a = [(a,a)]
13:12:14 <lambdabot>  <hint>:1:1: error: parse error on input ‘type’
13:14:03 <dmwit> ?let type Bino a = [(a,a)]
13:14:06 <lambdabot>  Defined.
13:14:21 <dmwit> > map (\(x,y) -> (x+3, y*10)) ([(5, 7)] :: Bino Int)
13:14:23 <lambdabot>  [(8,70)]
13:14:26 <dmwit> Broli: yes
13:14:40 <hoon> that's what I was trying to do
13:14:47 <hoon> :)
13:15:44 <dmwit> Broli: Type synonyms just make a more human-readable name for an existing type. In all ways except display, they are identical to the type they're defined to be.
13:15:52 <dminuoso> > ((+3) *** (*10)) <$> [(5, 7)
13:15:55 <lambdabot>  <hint>:1:29: error:
13:15:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:15:57 <dminuoso> > ((+3) *** (*10)) <$> [(5, 7)]
13:16:00 <lambdabot>  [(8,70)]
13:20:52 <hoon> ? let newtype BinNo a = BinNo [(a,a)] -- would cause problems, though. ...Right?
13:21:50 <fakenullie> you'd need functor instance
13:21:58 <hoon> right
13:22:36 <hoon> my point was if tried creating it with newtype you'd have more work to do
13:22:44 <hoon> if you used type you'd be fine
13:23:01 <fakenullie> your'd better explain what you're trying to achieve
13:23:31 <monochrom> Fame.
13:23:36 <hoon> fakenullie: you'll have to ask Broli
13:23:38 <hoon> :)
13:24:03 <fakenullie> you usually define newtype if you want special typeclass instances for it
13:24:38 <monochrom> I use newtype for better, more sincere abstraction.
13:25:00 <fakenullie> you can always unpack it and do map or whatever on its contents
13:26:38 <Broli> Thank you for all your answers. in fact I do not want to achieve anything, just to know more.
13:26:54 <hoon> sure sounds like something
13:26:58 <hoon> :D
13:33:57 <marcell_eMKa> Hello All :-)
13:35:48 <hoon> howdy
13:41:09 <ph88> geekosaur, how do i only handle a signal of a specific code ?
13:41:26 <geekosaur> er?
13:44:29 <ph88> geekosaur, codes like SIGKILL and SIGTERM
13:45:30 <geekosaur> you have to install a separate Handler for every signal type you want  to deal with. (and you can;t catch SIGKILL under any circumstances)
13:46:11 <geekosaur> there is no generic "catch all signals"
13:46:19 <ph88> oh ok
13:47:02 <geekosaur> there is awaitSignal but that's not quite the same thing, it doesn;'t catch signals, just pauses the OS thread until any signal occurs
13:47:14 <Math22232> https://puu.sh/yLlDR/ea8e92d6ea.png what kind has f?
13:47:47 <geekosaur> f :: * -> * -> *
13:47:59 <ph88> i'm looking here https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Signals.html#g:4
13:48:05 <dminuoso> Isn't KILL/TERM uncatcheable?
13:48:07 <geekosaur> because (a) two parameters (b) comp has to produce something with kind *
13:48:08 <Math22232> geekosaur, thanks
13:48:16 <geekosaur> dminuoso, TERM is catchable. KILL and STOP are not
13:48:33 <dminuoso> geekosaur: Ah right.
13:48:43 <dmwit> geekosaur: With appropriate extensions, I expect you might get `f :: k -> k -> *`
13:48:53 <geekosaur> dmwit, yes
13:48:58 <dmwit> oops
13:49:05 <ph88> where must i specify which signal i want to handle ?
13:49:07 <dmwit> Math22232: That was supposed to be aimed at you, not geekosaur. =P
13:49:10 <geekosaur> absent other information I decided not to confuse things too badly
13:49:27 <dminuoso> mnoonan: Thank you again. That tip was golden, my first tests are passing and failing, I'm so happy now. :)
13:49:42 <dmwit> ph88: `installHandler :: Signal -> ...`
13:49:42 <dminuoso> Seamlessly integrated into stack as well.
13:49:45 <geekosaur> ph88, installHandler is what you want
13:50:00 <ph88> oh it's the first argument -____-
13:50:07 <geekosaur> heh
13:50:20 <ph88> for some reason i was ignoring that thinking it's part of the type
13:50:35 <geekosaur> ...
13:50:46 <dmwit> ...
13:50:47 <geekosaur> now I am wondering how you understand fuy=nction types
13:50:58 <ph88> i do, i was just crosseyed or something
13:51:02 <geekosaur> (it *is* part of the type. not part of the *result* type, but a parameter type)
13:51:03 <ph88> dunno what happened lol
13:51:09 <dmwit> Personally, I am wondering what new understanding leads you tothinking it is *not* part of the type.
13:51:27 <geekosaur> actually I'd guess it's the multiline thing that is confusing
13:51:32 <ph88> should i put the installHandler just on the top level ? or should i do something special to activate it from the main function ?
13:51:49 <dmwit> Something special. Namely: include it in your main's do block.
13:51:55 <dmwit> (Also: main is not a function.)
13:52:03 <geekosaur> usually I install handlers in main, because installing/uninstalling on the fly in a multithreaded configuration just gets confusing
13:52:05 <ph88> it's not? o_O
13:52:22 <dmwit> Nope. `main :: IO X` for some choice of `X`. No arrows in that type.
13:52:23 <geekosaur> it's an IO action. no parameters, and the result is unused
13:52:39 <geekosaur> technically, it's a constant applicative form ("CAF")
13:52:48 <dmwit> frerich: Did you see my "mathy" solution to part 1? I have a "mathy" solution to part 2, too, but it's wrong somehow. =P
13:53:17 <ph88> why is it not designed in such a way that the result must be the programs exit code ?
13:53:30 <frerich> dmwit: The only solution I saw wouldn't work for some example I gave IIRC -- did you manage to fix that? That would be awesome! :-)
13:53:35 <dmwit> yes
13:53:43 <Math22232> dmwit, I don't get the difference between ("f::*->*->*) and (f::k->k->*)
13:53:43 <geekosaur> because a cheap and dirty looping program is main = <do somehting> >> main
13:54:04 <dmwit> frerich: http://lpaste.net/7189309391286304768 has a "correction to metric" annotation that accounts for the fact that accelerations change the velocity =P
13:54:28 <geekosaur> Math22232, this comes up with polymorphic kinds. * is the kind of a normal value type... but sometimes you want to use different kinds when doing type level programming
13:55:03 <geekosaur> you can use them in more places if kinds default to 'forall k. <something using k>' instead of defaulting * as the 'k'
13:55:18 <dmwit> Math22232: `f :: * -> * -> *` is the kind of something that must take two concrete types as arguments. `f :: k -> k -> *` is the kind of something that may take any two arguments, as long as they have the same kind; e.g. they could take `Nat`s or `* -> *`s or whatever.
13:55:33 <geekosaur> but the result of a function always has to be kind *, so you can't use k -> k -> k
13:55:44 <dmwit> frerich: (The only change in the annotation is in the definition of `metric`.)
13:56:10 <geekosaur> anyway if you're just learning Haskell, you can probably ignore PolyKinds stuff for now
13:56:22 <Math22232> geekosaur, dmwit thanks for the awesome explanation
13:56:39 <Math22232> It makes sense now
13:56:45 <geekosaur> unless you;re learning by delving into one of the web frameworks that uses kinds to constrain e.g. web requests, in which case you're starting out in the deep end of the pool >.>
13:57:20 <monochrom> The most favourite dive-in project.
13:58:08 <dmwit> frerich: Oh. Sorry. My explanation of what it corrects is incorrect; it doesn't account for the fact that acceleration changes velocity, it accounts for the fact that the linear term in the position calculation (wrt time) has both acceleration and velocity coefficients, not just velocity coefficients.
14:00:03 <kakashiAL> stupid question, but can someone please explain me why loggin in the console is side effect?
14:00:21 <geekosaur> all I/O is "side effect"
14:00:26 <geekosaur> this includes console I/O
14:00:30 <monochrom> I would delete the "side" part.
14:00:51 <monochrom> There are only intended effects and unintended effects. Which one would you call "side"?
14:01:25 <monochrom> Anyway if it is not idempotent it is an effect.
14:02:27 <kakashiAL> but I dont understand it, because look at javascripts console.log for example: console.log(x) returns unfedfined for every x and logs every x as x in the console
14:02:28 <kakashiAL> so its deterministic
14:02:53 <monochrom> Determinism does not rule out effect.
14:03:25 <monochrom> The real litmus test of effect is the Leibniz substitutability principle.
14:03:25 <amalloy> kakashiAL: should writing to a file be in IO?
14:03:29 <frerich> dmwit: Hmmm, I think I would need to play with that a bit to convince myself that it really does the Right Thing. What was your idea for part two though?
14:04:05 <monochrom> f is effectless iff for example "(\x -> x + x) (f 5)" and "f 5 + f 5" are the same.
14:04:17 <kakashiAL> so can you say that logging at the console is not pure because it talks to another API, because it talks to the outside world?
14:04:23 <geekosaur> kakashiAL, javascript makes no pretense of separating effects from pure computations.
14:04:30 <dmwit> frerich: position(t) = p + (v-a/2)*t + (a/2)*t^2; so a/2 determines the first-order behavior, v-a/2 determines the behavior for ties between values of a/2, and p determines the behavior when both of the first two are tied. Then there is only the wrinkle that the manhattan distance contribution of velocity should be negated if it is aligned with acceleration along that axis; I do that by normalizing so all accelerations are in the all-three-positi
14:04:39 <geekosaur> and yes, you're getting at it, "pure" is a behavior completely contained within your program
14:04:52 <ph88> geekosaur, i added the signal handler but i still get 0 bytes .prof file   https://bpaste.net/show/0a1b82157658
14:05:02 <monochrom> If f suddenly decides to give you a log message, though, then "(\x -> x+x) (f 5)" gives you one log message, "f 5 + f 5" gives you two. How could you question that it is effectful?
14:05:05 <dmwit> frerich: Sorry, I made the same category error again! The manhattan distance contribution of *the linear term* should be negated if...
14:05:25 <geekosaur> (although it's more than that, because you can still be impure if e.g. a random thread can mutate values in a different thread by means other than communicating with that thread)
14:05:25 <Tuplanolla> Do I sense inaccurate integration methods?
14:05:46 <dmwit> frerich: For part 2, there should be a simple quadratic equation to solve for each pair of particles to see if they collide. Then you can check if the solutions are integral and positive.
14:06:14 <geekosaur> ph88, do you remember my saying, twice, that you cannot catch SIGKILL??
14:06:15 <kakashiAL> geekosaur: so its not pure because it does something beSIDE of my application, it effect the outside world, it effects another API, it has an effection, it has a SIDE-EFFECT :)
14:06:17 <geekosaur> ^C is SIGINT
14:06:17 <dmwit> frerich: Namely position_1(t) = position_2(t) is the quadratic equation.
14:06:23 <ph88> ups sorry
14:06:35 <kadoban> dmwit: But you'd have to be careful there and make sure you don't eliminate something that collides with a particle that doesn't exist anymore, right?
14:06:39 <dmwit> frerich: arithmoi has the appropriate functions for taking integer square roots and so forth.
14:06:51 <geekosaur> SIGTERM is sent by the shell's "kill" command if you don't specify a signal, or by the system's init subsystem (init, systemd, launchd, whatever)
14:06:51 <dmwit> kadoban: Ah, I suppose so!
14:06:53 <kakashiAL> geekosaur: and as you said, its not limited in my application like add(3, 5)
14:06:57 <frerich> dmwit: Won't that yield too many solutions though, since two colliding particles will both be removed from the cloud?
14:07:05 <frerich> Yeah, what kadoban said.
14:07:15 <dmwit> frerich: Well, two colliding particles *should* both be removed.
14:07:36 <kadoban> I guess you could just ... find the pair(s) of particles that collide the earliest, nuke those, repeat.
14:07:38 <dmwit> frerich: Still, attending to kadoban's excellent point should be possible without guesswork: take the smallest-t collision, and iterate until there are none.
14:07:45 <dmwit> right
14:07:45 <ph88> geekosaur, i'm not sure how the process is terminated at the moment .. it's being run as part of a benchmark suite
14:08:10 <kadoban> You'll have to be a tad careful in case 3 particles collide in one spot, but that shouldn't be too hard, just a weird edge case.
14:08:17 <kadoban> 3+
14:08:27 <frerich> dmwit: I think you could pick _any_ pair that will collide, iterate until there (that may process multiple other collisions along the way).
14:08:27 <dmwit> right
14:08:41 <ph88> still 0 bytes :(
14:08:45 <dmwit> frerich: I don't mean iterate a simulation.
14:08:55 <kakashiAL> geekosaur: thanks!
14:08:55 <ph88> will have to reconsider the strategy i guess
14:08:56 <kadoban> Is it me or is part 2 easier than part 1?
14:08:56 <dmwit> frerich: I mean, iterate the process of, without simulation, eliminating the first colliding pair.
14:09:06 <frerich> dmwit: Ah.
14:09:25 <EvanR> is there such a thing as, STM action is killed due to detection that it will retry forever
14:09:31 <geekosaur> ph88, you might need to find out. I can think of several things that might be happening
14:09:32 <dmwit> EvanR: yes
14:09:35 <EvanR> oh...
14:09:39 <EvanR> when does that happen
14:09:42 <frerich> dmwit: That sounds straightforward - why didn't it work? :-)
14:09:43 <ph88> geekosaur, please share :p
14:09:57 <dmwit> EvanR: When it is waiting for an STVar to change that has no writers.
14:10:09 <dmwit> frerich: Dunno! I've got a bug somewhere, and not had time to track it down.
14:10:17 <EvanR> how do i avoid that
14:10:19 <dmwit> frerich: It didn't find any collisions. =P
14:11:08 <geekosaur> ph88, ... that's the wrong way to go about it. Find out how the test suite works. There are too many possibilities, and you could hypothetically (and nonportably) catch every relevant signal but it's a lot of crap boilerplate to work around not reading documentation
14:11:26 <ph88> ye ok
14:15:42 <Koterpillar> I keep getting Error_Packet "partial packet: expecting 16408 bytes, got: 7669". Where can I get a more detailed explanation of this error?
14:19:10 <geekosaur> you could start with whatever package you are using that is parsing packets, since none of us can guess
14:21:44 <Koterpillar> this seems to be a match but it's undocumented: https://github.com/vincenthz/hs-tls/blob/master/core/Network/TLS/IO.hs#L47
14:23:43 <Broli> why does it turn indefinitely?
14:24:01 <Broli>  [map (\a -> True) xs | xs <- [1, 2]]
14:24:20 <EvanR> > [map (\a -> True) xs | xs <- [1, 2]]
14:24:23 <lambdabot>  error:
14:24:23 <lambdabot>      • No instance for (Num [a0]) arising from the literal ‘1’
14:24:23 <lambdabot>      • In the expression: 1
14:25:06 <EvanR> you have a type error
14:25:29 <Broli> EvanR: i know, i get tha :)
14:25:41 <EvanR> you wrote the equivalent of [map (\a -> True) 1, map (\a -> True) 2]
14:25:52 <Broli> EvanR: yeah
14:26:29 <EvanR> what was the question?
14:28:13 <Broli> EvanR: it is okay, i have fixed this. thanks!!! :)
14:29:19 <geekosaur> TLS. good luck deciphering. (if it's openssl, give up now.) unless it's something trivial like this is establishing the TLS connection and the other side isn't encrypting
14:35:53 * hackage conduit-throttle 0.3.1.0 - Throttle Conduit Producers  https://hackage.haskell.org/package/conduit-throttle-0.3.1.0 (mtesseract)
14:36:36 <marcell_eMKa> hello . is somebody here who would like to test sending file photo changeging?
15:02:19 * hackage ghc-prim 0.5.1.1 - GHC primitives  https://hackage.haskell.org/package/ghc-prim-0.5.1.1 (HerbertValerioRiedel)
15:28:21 <fresheyeball> Hey out there
15:28:29 <fresheyeball> I have a tricky QuickCheck situation
15:29:02 <fresheyeball> QC makes me a random list. I filter that list to make sure it doesn't contain my magic value. Then I want to put one special value at a random location in the list
15:29:31 <fresheyeball> I could use `System.Random` but then I lose reproducibility, as that will be it's won seed
15:29:36 <fresheyeball> own* seed
15:30:04 <fresheyeball> is there a way I can get the current QC StdGen?
15:30:13 <fresheyeball> Or shuffle the list inside my function somehow?
15:30:15 <amalloy> the simplest change is to just use quickcheck to give you an Arbitrary location in the list, instead of using a random one
15:30:36 <fresheyeball> amalloy: so you mean, as QC for an Int and then split the list?
15:30:47 <amalloy> sure
15:30:59 <fresheyeball> I feel like that's non-ideal, as the Int could be out of bounds, lowering the value of my tests
15:31:07 <amalloy> an int in-bound
15:31:12 <fresheyeball> (IE making a ton of tests where my special value is just on the end of the list)
15:31:19 <amalloy> but imo it is better to, rather than generating a list and then shoving a thing into the middle of it somewhere, generate two lists, and then wrap them around your special value
15:31:32 <fresheyeball> amalloy: oh! That I like!
15:36:39 <kakashiAL> you always use pure functions and try to avoid side effects, but why would it be harmful to write in the console?
15:37:09 <kakashiAL> I mean I can log everything in the console and I would harm nobody, but we know that side effects are bad and you try to avoid them
15:37:31 <kakashiAL> but at the moment I dont understand why loggin at the console is also something bad
15:37:52 <EvanR> logging in the console is a broad topic and cant be definitely deemed good or bad
15:38:15 <EvanR> for instance we have Debug.Trace for printout stuff from pure code, for debugging purposes
15:38:18 <fresheyeball> Also Merry Christmas Haskell peoples!
15:38:40 <EvanR> s/printout/printing/
15:38:55 <fresheyeball> kakashiAL: writing to the console can fail. So is not pure.
15:39:25 <EvanR> multiple "pure" things writing to the console in parallel will also screw up
15:39:38 <geekosaur> also 'bad' is a judgment call, purity is not a judgment call.
15:39:40 <EvanR> nobody likes that
15:39:50 <fresheyeball> geekosaur: well said
15:39:51 <MarcelineVQ> :t \special -> shuffle =<< (special:) <$> listOf arbitrary
15:39:52 <lambdabot> Arbitrary a => a -> Gen [a]
15:40:06 <geekosaur> purity is about whether the compiler is allowed to optimize for a given case by only running something once and remembering the result, or alternately running it multiple times in some contexts
15:40:14 <fresheyeball> MarcelineVQ: I appricate it, but that doesn't help me
15:40:24 <geekosaur> with pure code this can be done safel; with effectful code you get 'unexpected' behavior
15:40:31 <MarcelineVQ> I see, then your task is quite unclear to me
15:41:16 <kakashiAL> fresheyeball, EvanR: so with other words its harmfull because you cant controll it, you cant be always 100% sure that it will give you the result that you want, it depends on the outside world, it depends on the outside system, correct?
15:41:25 <kakashiAL> its not deterministic
15:41:34 <EvanR> thats why its not pure
15:41:41 <EvanR> not why its bad
15:42:08 <EvanR> or harmful
15:42:14 <fresheyeball> kakashiAL: leave opinions like (what is harmful and what is not) out of it, it's not pure
15:42:51 <kakashiAL> EvanR, fresheyeball: okay, but would you agree with "it hard to reason about it" okay?
15:42:57 <EvanR> on the other hand, cool stuff happens when you can include stuff that you cant control, is non deterministic, or depends on the outside world in a way that is technically pure
15:42:59 * frerich supposes launching ICBMs is commonly called both harmful as well as bad. :-)
15:43:09 <EvanR> because then despite all the crazy stuff, you can still easily reason about it
15:43:13 <Rembane> frerich: We could call that an edge case. :)
15:43:45 <kakashiAL> EvanR: I see it as a yes :)
15:43:51 <geekosaur> are you launching them at another country, or the incoming Martian war fleet?
15:43:55 <fresheyeball> kakashiAL: while I agree, we don't need to go there. We can just know that it's not pure.
15:44:05 <Rembane> Both. There is some scatter and confusion.
15:44:33 <EvanR> kakashiAL: it takes a lot of examples, war wounds to appreciate purity
15:45:16 <kakashiAL> fresheyeball: sure, I just need a motivation with my console and why to also see it a little bit as something "negative" and also put it in the "not pure" class :)
15:45:32 <EvanR> its not necessarily negative
15:45:41 <EvanR> print out whatever you want with Debug.Trace
15:46:03 <EvanR> but if you leave it in production code, you might step on someones toes
15:46:03 <geekosaur> kakashiAL, if you want to play around with this, consider annotating varous things with Debug.Trace and watch for where you unexpectedly either don't get traces or get extra ones
15:46:36 <dmwit> I don't understand "pure", "not pure". I only understand "referentially transparent": does the program's meaning change if you replace a term with its definition, or vice versa?
15:46:43 <geekosaur> for extra fun, combine with things involving unsafePerformIO, especially with vs. without inlining pragmas
15:46:44 <kakashiAL> EvanR: name the toes please!
15:46:45 <fresheyeball> kakashiAL: if you want use the console, and are in a circumstance where you feel it's not harmful. Use Debug.Trace
15:47:07 <EvanR> kakashiAL: your own toes in three days when you are trying to see console output, but your own other console output is flooding
15:47:10 <fresheyeball> dmwit: one property of pure, is that the real world is not effected
15:47:19 <dmwit> fresheyeball: bullocks
15:47:34 <geekosaur> (it stops being "fun" if you also do things that confuse ghc with respect to what pure and what isn't. see accursedUnutterablePerformIO)
15:47:52 <dmwit> fresheyeball: A little number in a computer far away goes down because electrons lost more energy in my black box than they otherwise would have.
15:48:01 <kakashiAL> EvanR: with other words I cant controll the other console.log from other team mates, makes sense :)
15:48:04 <fresheyeball> dmwit: well I guess there is "pure disk IO" and such, so my statement doesn't work actually
15:48:11 <EvanR> i still believe in pure functions, despite haskell people
15:48:24 <EvanR> the terminology
15:48:37 <EvanR> kakashiAL: and youre your own team mate
15:49:06 <EvanR> for actually logging records for later as part of an application, now you have a non trivial problem to actually solve
15:49:13 <dmwit> Of course, to understand "referentially transparent" you have to say what you mean by "what a program means". And that's the part where you arbitrarily choose whether time usage/RAM usage/console output are part of the meaning or not.
15:49:20 <EvanR> haphazardly doing it during lazy evaluation will probably not get what you want
15:50:23 <kakashiAL> EvanR: thanks, its just "harder" to determin, harder or not possible to test, not 100% controllable, harder to reason about
15:50:25 <kakashiAL> what did I log? what did you log? what did joe log? what did the system log?
15:50:48 <EvanR> is logging really a special case here?
15:51:01 <EvanR> as opposed to other effects like sending email?
15:51:37 <kakashiAL> EvanR: for me console.log() in javascript was never something harmful but you triggered my and my past memories, it was hard to reason about the logs
15:51:39 <EvanR> i think there was some opinion years ago that yes its special
15:52:03 <kakashiAL> EvanR: so I am motivated and I defense my point, thanks for that :)
15:52:25 <EvanR> you seem to have successfully argued that logging is harmful
15:52:35 <EvanR> i will not take thanks for this
15:52:59 <kakashiAL> EvanR: just because of your help!
15:53:03 <EvanR> :|
15:53:06 <Rembane> Having a program that communicates with the real world is harmful.
15:53:25 <EvanR> real world considered harmful
15:53:27 <Rembane> SPJ said this some years ago...
15:53:42 <EvanR> and deeply magically
15:54:22 <EvanR> er magical
15:55:15 <Rembane> GOTO prison without passing GO.
15:55:55 <EvanR> the homotopy structure of monopoly
15:56:16 <geekosaur> come to think of it, accursedUnutterablePerformIO is might be the best example of why purity matters. iirc all three of the related ByteString bugs came down to ghc not seeing the abstraction barrier that's supposed to be around IO code, and let-floating IO things outside of IO.
15:56:45 <geekosaur> which can happen at Core level
16:05:09 <cawfee> hey guys any ideas on how to construct λ-terms M_0, M_1, ... such that for all n one has
16:05:24 <cawfee> M_0 = x ; M_{n+1} = M_{n+2} M_n ?
16:05:41 <cawfee> It sounds like a multiple fixedpoint exercise except the series of terms goes on infinitely
16:08:49 * hackage network-uri-json 0.1.1.0 - FromJSON and ToJSON Instances for Network.URI  https://hackage.haskell.org/package/network-uri-json-0.1.1.0 (alunduil)
16:14:08 <mniip> cawfee, not sure I understand the task
16:18:52 <steveo> Can I use unsafePerformIO on a pure function to make it write debug information to a temp file? Is this safe?
16:20:19 <kadoban> steveo: Sounds a little sketchy. Not too different from what Debug.Trace does I guess though. Can you just use something from Debug.Trace instead?
16:20:48 <nshepperd> cawfee: in haskell that would be M n = ⊥ for all n > 0
16:21:16 <steveo> Yes, I tought about using Debug.Trace.trace. But can I write to a file using this?
16:21:39 <kadoban> steveo: For debug usage you can pipe stderr to a file if you want. That wouldn't work for end-users though.
16:21:40 <steveo> I don't need anything from the program, just the debug information to analyze it externally.
16:22:31 <steveo> Piping trace to stderr is what I do already
16:23:26 <kadoban> Not following what you mean there necessarily.
16:24:24 <steveo> My program is slow regarding one aspect (sorting a ton of vectors in a very short time).
16:25:10 <steveo> My idea is to export the specific vectors to a file and then experiment with the vectors to find quicker ways to sort them
16:25:12 <nshepperd> sure, you can use unsafePerformIO
16:25:14 <Rembane> steveo: How much is a ton in this case? 10^5?
16:26:23 <steveo> perhaps about 1000 of length 4000 per 0.04166 seconds  (i.e., a framerate of 24 times per second).
16:26:50 <steveo> the vector are float values
16:27:10 <steveo> per 0.04166 seconds  (i.e., a framerate of 24 times per second).
16:27:40 <Rembane> Is a vector a Data.Vector vector?
16:27:55 <kadoban> Ballpark that seems pretty doable in that timeframe, but that's assuming you're doing nothing else.
16:28:15 <steveo> V.Vector (import qualified Data.Vector as V)
16:28:36 <Axman6> have you seen vector-algorithms?
16:28:43 <Axman6> @hackage vector-algorithms
16:28:43 <lambdabot> http://hackage.haskell.org/package/vector-algorithms
16:28:47 <steveo> 70% of my time is spent sorting and I guess I cannot sort 4000 values in parallel
16:29:07 <steveo> Yes, I am using https://hackage.haskell.org/package/vector-algorithms
16:29:24 <steveo> I guess there is no faster way to sort vectors, or?
16:29:43 <EvanR> 4000 vectors how big each
16:29:48 <steveo> I used the descriminate library but that was at least 2-3
16:30:24 <kadoban> You might be able to gain something from parallizing those sorts, but I'd probably guess you'll have better luck doing multiple sorts in parallel than trying to do a single one in a parallel way.
16:30:25 <steveo> 2000 values of 2D points. If the y-location is the same I also compare the x-location
16:31:23 <steveo> (at least 2-3 slower to use the discriminate lib that has O(n) list sorting)
16:32:24 <EvanR> big O strikes again
16:32:45 <EvanR> those constant factors
16:33:11 <mniip> O(n) list sorting?
16:34:03 <steveo> https://hackage.haskell.org/package/discrimination-0.3/docs/Data-Discrimination.html
16:34:20 <EvanR> right
16:34:23 <EvanR> alien tech
16:34:33 <Rembane> steveo: Do you have to sort all vectors at the same time or can you insert the items in a sorted way?
16:36:28 <steveo> I don't know. I am not yet an expert in Haskell.
16:36:30 <steveo> https://github.com/Twinside/Rasterific/blob/master/src/Graphics/Rasterific/Rasterize.hs#L76
16:37:28 <mniip> this can't be right
16:37:33 <mniip> mathematically
16:37:37 <mniip> where's the pitfall
16:37:48 <kadoban> Probably in computational model
16:39:00 <steveo> mniip: you refer to O(n)?
16:39:18 <EvanR> mniip: https://github.com/ekmett/discrimination/
16:39:36 <kadoban> It links to some papers that would presumably have the details, but ... really should give some idea of why it's sensical and what the caveats are.
16:39:51 <mniip> well
16:39:54 <EvanR> heh yeah
16:40:18 <mniip> if you can sort a list of integers in O(n) worst case then we've proved inconsistency of arithmetic
16:40:28 <EvanR> you need extra support
16:40:37 <ClaudiusMaximus> https://en.wikipedia.org/wiki/Counting_sort can do it for finite types i guess
16:40:39 <EvanR> there are extra assumptions
16:40:44 <koz_> mniip: I think the sorting is only for Ints.
16:40:53 <koz_> (since they have a fixed-width rep)
16:41:00 <mniip> so it's a generalization of radix sort?
16:41:06 <koz_> mniip: Correct.
16:41:33 <koz_> Edward's discrimination package is a bunch of infrastructure to make this automatic, but the concept is basically exactly a generalization of radix sort.
16:41:57 <Axman6> steveo: your compare is just comparing _sampleY <> comparing _sampleX btw
16:42:13 <koz_> I dunno how big the constant costs of this scheme are, though.
16:42:18 * koz_ has never used it.
16:42:35 <Axman6> > (comparing fst <> comparing snd) (1,2) (1,3)
16:42:38 <lambdabot>  LT
16:42:53 <kadoban> If you leave the comparison model, O(n) sorts aren't that ridiculous, but it still really should be talking about what it's measuring. And there's reasons radix sort isn't that commonly used, the places where it beats Θ(n lg n) sorts practically are a bit obscure AFAIK. And ... okay, 80 page paper, not reading that to figure out the basic idea.
16:43:14 <Axman6> the Monoid instance for ORdering is pretty handy (as is the Monoid m => Monoid (a -> m) one)
16:43:22 <koz_> kadoban: All the O(n) sorts come with serious constant costs.
16:43:48 <koz_> I'm sure this one does too.
16:43:52 <kadoban> koz_: counting sort is brilliant and the constants are low as hell (on the inputs it actually works on)
16:44:02 <koz_> kadoban: What inputs does counting sort work on?
16:44:19 <Axman6> The talk from LambdaJam by Ed about his discrimination package was pretty amazing, you can sort a lot of Haskell data in O(n) time
16:44:23 <kadoban> Ones with a small number of distinct values in the list
16:44:35 <exio4> or a small range of values
16:44:52 <exio4> same thing, I guess :P
16:44:55 <kadoban> Small range is the typical case, yeah.
16:45:19 <kadoban> It's annoying if the range is high but the number of distinct is low. But you can still probably do it. The constants likely get worse.
16:47:14 <kadoban> But ya, you'll have a real hard time beating counting sort on certain inputs. Especially if the counts fit in a cache, the thing blazes like hell.
16:47:51 <Axman6> steveo: another option is to avoid sorting at all, if you're making images, you could start with a mutable all black or white image, and then for each element in the undorted list, just write to the correct location directly
16:48:15 <EvanR> uhm wouldnt that give the wrong picture
16:48:32 <kadoban> I can't really tell what the goal of the thing is yet
16:48:40 <EvanR> if the layers are out of order
16:53:20 <steveo> The goal is to have a very well designed and reasonably performant vector graphics library in Haskell.
16:53:30 <Axman6> @check \x -> (x `mod` 2 == x `rem` 2)
16:53:32 <lambdabot>  *** Failed! Falsifiable (after 3 tests):
16:53:32 <lambdabot>  -1
16:53:52 <steveo> Someone wrote Rasterific and my job is to improve the performance. For this task I wrote the benchmark.
17:00:21 <Axman6> @check \x -> (abs (x `mod` 2) == abs (x `rem` 2))
17:00:24 <lambdabot>  +++ OK, passed 100 tests.
17:00:51 <erisco> steveo, you wrote a benchmark? smart! :)
17:02:50 <EvanR> code written, type checks, brick wall at full speed because
17:03:02 <EvanR> not allowed to use atomically inside unsafePerformIO
17:03:05 <EvanR> FML
17:03:30 <koz_> I'm trying to get GHC to build for Termux.
17:03:34 <koz_> It's not proving fun.
17:05:26 <mniip> EvanR, uhhh
17:05:36 <EvanR> well, you may sometimes be able to
17:05:41 <mniip> case f of (STM m) -> IO (\s# -> m s#)
17:05:54 <mniip> I aint saying this is a good idea but
17:06:02 <EvanR> but docs say you cant. and further more, accidentally nesting two transactions will throw an exception
17:07:30 <geekosaur> I'd expect that to lead to problems, yes
17:09:18 <mniip> you may be right
17:09:22 <steveo> Since there seem quite some experts online now
17:09:39 <steveo> Is there a sophisticated wavelets library in Haskell?
17:09:49 <mniip> % x <- newTVarIO 123
17:09:49 <yahb> mniip:
17:09:49 <tabemann> I presume "accidentally" nesting two transactions requires unsafePerformIO?
17:09:56 <EvanR> yeah
17:09:59 <mniip> % case readTVar x of (STM m) -> IO m
17:09:59 <yahb> mniip: [Segmentation fault]
17:10:26 <geekosaur> in the normal case they'd be forced to be sequential, yes, unsafePerformIO is the only way to get them to nest or overlap
17:10:59 <geekosaur> which means the STM machinery doesn't worry about the overlap case either
17:11:40 <geekosaur> (well, threads can do it and that' why STM exists, but there's at least *some* synchronization)
17:14:28 <steveo> I wanted to use Wavelets feature extraction for image to do hand writing recognition
17:15:01 <steveo> but I guess there are machine and staitics library missing so this would be a substantial work
17:15:47 <EvanR> ah threads...
17:15:53 <EvanR> maybe that will get around it
17:23:00 <steveo> Anyways, the tensor flow example on written number recognition seems neat
17:23:01 <steveo> https://nbviewer.jupyter.org/github/lgastako/public-notebooks/blob/master/TensorFlow%20MNIST%20Working.ipynb
17:29:30 <EvanR> it... worked
17:29:37 <EvanR> wacky
17:31:36 <EvanR> brain just exploded
17:33:19 <jchia> Are there libraries that can convert an .xsd into Haskell types and parse .xml documents conforming to the .xsd into values of those types?
18:05:19 * hackage ats-format 0.1.0.4 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.4 (vmchale)
18:15:34 <Broli> please what's wrong https://pastebin.com/Ury1L84J? THanks!!!
18:17:23 <MarcelineVQ> Best to include your error with your problem
18:18:07 <EvanR> that would sploit it
18:18:09 <MarcelineVQ> and to include what extensions you're using, so others can see the issue easier
18:18:12 <EvanR> spoil
18:19:13 <Broli> okay
18:19:14 <Broli> https://pastebin.com/vuTBMAgP
18:19:15 <MarcelineVQ> but, at a glance, you're binding two things to one name, x, in the last line
18:20:31 <MarcelineVQ> the two x here  (x, Colist x)  are different values, you can't name them both x due to that
18:20:35 <geekosaur> yeh, that's a pattern match and you're trying to reuse a binding
18:20:38 <geekosaur> this isn't permitted
18:21:03 <Broli> I want to transform Colist elements into a list
18:21:26 <geekosaur> (you can't use that to force something to match in two places. there's a discussion of why Haskell forces linear patterns somewhere in the haskell-cafe archives)
18:21:37 <Broli> MarcelineVQ: please look at the Declaration of Colist
18:21:41 <geekosaur> basically there's some impossible edge cases
18:21:52 <MarcelineVQ> perhaps you wanted to say   x@(_, Colist _)
18:22:05 <MarcelineVQ> or just x
18:22:07 <geekosaur> no, they're using it
18:22:23 <geekosaur> they want the same pattern to be in both places, I think. or if they don't, they should use different names
18:22:47 <geekosaur> ...or threy're just confused about what's going on, perhaps
18:23:47 <Broli> MarcelineVQ: i can do this because toListo is of type [Item Colist a] but when  i do Just x, x is of type (x, Colist x)
18:25:11 <Broli> can't *
18:25:42 <geekosaur> don't confuse types with values having those types
18:26:26 <Broli> geekosaur: can you explain me the syntax with type in class?
18:27:11 <geekosaur> Colist (Just ('x', CoList Nothing)) is a valid value. the same type a, but different values x (for a as used in data Colist, and x as used in toListo)
18:27:17 <ertes> geekosaur: out of curiosity, is there a brief summary of why that is?  regarding pattern linearity
18:27:23 <ertes> is it a performance thing?
18:28:59 <MarcelineVQ> Broli: I don't know much about this type stuff but were you after this perhaps   toListo (Colist  (Just (x, xs))) = [x] ++ toListo xs
18:29:35 <geekosaur> ertes, I found the thread I was thinking of; it's not a brief summary though
18:30:02 <MarcelineVQ> I have to go for now, good luck with the rest
18:30:09 <geekosaur> the end of https://mail.haskell.org/pipermail/haskell-cafe/2001-March/001763.html might be sufficient
18:30:41 <geekosaur> tl;dr: linear pattern matching is both simpler and faster than Prolog-style unification
18:31:01 <geekosaur> which is what is needed for non-linear patterns
18:31:37 <ertes> thanks
18:31:43 <geekosaur> Broli, basically the 'a's in data Colist a = ... are the same *type* but not necessarily the same *value*
18:32:23 <Broli> i have fixed this
18:32:33 <Broli> geekosaur: Thanks!!!
18:32:35 <ertes> from time to time i find myself wishing that i could just write something like (x, x), and GHC could automatically desugar it to (==)
18:32:50 <geekosaur> but in the definition of toListo, you want the different *values*, regardless of their type. so you don;t want to repeat the binding name there
18:32:51 <iqubic> How would that work in context?
18:33:12 <iqubic> ertes: Why would that be helpful at all?
18:33:31 <ertes> iqubic: f x x = y
18:33:44 <geekosaur> iqubic, think of writing a function equiv x x = True; equiv _ _ = False
18:33:44 <ertes> iqubic: vs.: f x1 x2 | x1 == x2 = y
18:33:57 <geekosaur> but linearity means you can;t write that first part
18:34:11 <iqubic> Why can't you write that first part?
18:34:29 <geekosaur> right, you did your I'll jump in *after* the discussion and demand it be repeated
18:34:36 <geekosaur> [22 02:29:47] <geekosaur> the end of https://mail.haskell.org/pipermail/haskell-cafe/2001-March/001763.html might be sufficient
18:34:56 <iqubic> I thought equive x x = True was possible, or is that a lie perpatrated by LYAH.
18:35:18 <ertes> i'm pretty sure that LYAH doesn't make that claim
18:35:26 <geekosaur> > let equiv x x = True; equiv _ _ = False in 0
18:35:29 <lambdabot>  error:
18:35:29 <lambdabot>      • Conflicting definitions for ‘x’
18:35:29 <lambdabot>        Bound at: <interactive>:1:11
18:35:39 <geekosaur> and likewise I am pretty sure LYAH doesn;t claim that
18:35:39 <iqubic> geekosaur: I just joined like 30 seconds ago.
18:35:58 <iqubic> I don't have any record of the conversation's beginning.
18:37:20 <geekosaur> sigh, I did check for a join
18:37:38 <geekosaur> you still have rather remarkable timing for jumping in at the very end of a discussion and then demanding it be repeated in your presence
18:37:46 <iqubic> I'll stop.
18:38:17 <iqubic> How about from now on I only ask questions about stuff that I can see, and not about things I can't
18:38:29 <iqubic> How does that sound?
18:38:39 <ertes> i think jumping into a discussion at the end is fine
18:38:55 <ertes> i do it all the time =)
18:39:47 <geekosaur> anyway, allowing a pattern to be repeated as a backreference is doable but much more expensive. regex engines do it, but that is a large part of what they're for so the overhead is already expected
18:40:09 <geekosaur> people kinda don;t expect parameter handing for arbitrary functions to be arbitrarily expensive due to potential backtracking
18:40:51 <ertes> i think a simple form of rewriting could be allowed: whenever a variable is repeated, a guard could be implicitly added
18:41:01 <ertes> it would make the code less transparent though
18:41:52 <geekosaur> it's been suggested a few times. I gather there's some complexity involved because of how ghc implements this
18:41:57 <ertes> guards can really change the way a pattern-match behaves in terms of performance, so i think i'm fine with them being explicit
18:42:19 <geekosaur> however by that argument stuff like foo 1 = ... should also be illegal
18:42:30 <geekosaur> (but the Report requires that desugar to a guard)
18:42:39 <ertes> "this match doesn't use guards, so i can count on it being O(n), where n is the number of levels"
18:42:53 <ertes> s/levels/layers/
18:43:06 <iqubic> but "foo 1" is just a pattern match on ints. That should be fine.
18:43:39 <ertes> oh yeah, i forgot you could match on numbers
18:43:46 <geekosaur> except it's not because, absent an explicit type, it's a value match on some value whose type has a Num instance
18:43:49 * hackage collection-json 1.1.1.0 - Collection+JSON—Hypermedia Type Tools  https://hackage.haskell.org/package/collection-json-1.1.1.0 (alunduil)
18:43:51 <ertes> iqubic: actually that's translated into (==)
18:44:15 <iqubic> I know.
18:44:15 <iqubic>  
18:44:23 <geekosaur> and Num instances don't necessarily let you do that as a pattern match
18:44:45 <ludat_> Is there a channel for stackage? I'd like to get snap into stackage and I'm not really sure how to do that
18:44:54 <ertes> :t (\x@0 -> x)
18:44:55 <lambdabot> (Num a, Eq a) => a -> a
18:45:06 <geekosaur> (and in any case you would need a polymorphic pattern match, which Haskell doesn't support at all)
18:46:15 <geekosaur> ludat_, https://github.com/fpco/stackage/blob/master/MAINTAINERS.md#adding-a-package
18:46:23 <iqubic> If you say "foo :: (Num a) => a -> a; foo 1 = 7; foo _ = 2" GHC will politely tell you to add an Eq constraint
18:47:03 <geekosaur> yes. (which actually required a code change iirc because Haskell98 and Haskell2010 require any type with a Num instance ot have an Eq instance. precisely because of this hack.)
18:47:03 <iqubic> Which is weird, because people assume that all numbers can be tested for equality.
18:47:49 <iqubic> But Num doesn't actually have Eq as a superclass, which is why you need to say (Num a, Eq a)...
18:47:56 <Eduard_Munteanu> Can't  number literals be handled with pattern matching machinery? I.e. maintaining the illusion all numbers are constructors.
18:48:03 <iqubic> Yes.
18:48:28 <Eduard_Munteanu> Although Int and the likes are really newtypes.
18:48:37 <geekosaur> Eduard_Munteanu, they desugar into guards. (and you'd do well to read backscroll because that is the topic...)
18:48:40 <ertes> iqubic: Num used to require Eq, but i'm glad it no longer does
18:48:41 <iqubic> foo 1 = 1; foo 2 = 2; foo x = x + 1; is valid
18:49:02 <geekosaur> and they must desugar into guards because there are possible Num instances for which you don't have pattern-able literals
18:49:25 <Eduard_Munteanu> @src Int
18:49:25 <lambdabot> data Int = I# Int#
18:49:29 <iqubic> ertes: why? What do you gain by removing the Eq dependency on Num?
18:49:42 <iqubic> geekosaur: there are?
18:49:52 <ertes> iqubic: somethings behave both like functions and like numbers
18:50:05 <geekosaur> lambdabot used to have a Num instance for functions
18:50:14 <ertes> iqubic: in fact you could define:  instance (Num b) => Num (a -> b)
18:50:16 <geekosaur> iirc fromIntegral = const
18:50:29 <geekosaur> er, fromInteger
18:50:34 <iqubic> @src fromInteger
18:50:34 <lambdabot> Source not found. Where did you learn to type?
18:50:43 <iqubic> @src fromIntergral
18:50:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:50:59 <geekosaur> fromInteger is a typeclass method, it does not have one implementation but one per ty[pe
18:51:06 <geekosaur> it's part of Num
18:51:23 <iqubic> I know.
18:51:54 <iqubic> I was just trying to see if the fromInteger = const thing was true.
18:52:08 <ertes> @src (a -> b) fromInteger
18:52:08 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:52:24 <ertes> anyway, fromInteger = const
18:52:37 <ertes> or more generally for this pattern:  fromInteger = pure
18:52:47 <ertes> you can define a Num instance for any Applicative
18:53:42 <iqubic> What does fromInteger even do?
18:53:46 <geekosaur> iqubic, only for that definition which is not currently in lambdabot
18:53:57 <geekosaur> as I already said
18:54:11 <geekosaur> it's been maybe 7 years since lambdabot had that Num instance installed by default
18:55:14 <iqubic> Wait, what instance of Num is that?
18:55:37 <ertes> @let mkAppNum f = "instance (Num a) => Num ((" ++ f ++ ") a) where (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; negate = fmap negate; signum = fmap signum; fromInteger = pure"
18:55:41 <lambdabot>  Defined.
18:55:43 <ertes> @mkAppNum "Maybe"
18:55:43 <lambdabot> Unknown command, try @list
18:55:46 <ertes> > mkAppNum "Maybe"
18:55:49 <lambdabot>  "instance (Num a) => Num ((Maybe) a) where (+) = liftA2 (+); (*) = liftA2 (*...
18:55:50 <geekosaur> ah, yes, Cale still installs it occasionally: @let instance Num b => Num (a -> b) where { (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signum; negate = fmap negate; fromInteger n x = fromInteger n }
18:56:21 <geekosaur> flip const, not const, sorry
18:56:47 <geekosaur> actually no, it's only conceptually const because it has to use fromIntegral from the other type
18:57:50 <ertes> what's the lambdabot command that ">" runs?
18:58:01 <Welkin> :t const const
18:58:03 <lambdabot> b1 -> a -> b2 -> a
18:58:41 <geekosaur> "@run"
18:59:20 <geekosaur> sigh, keep saying fromIn tegral when it has to be fromInteger to be Num. feh
19:01:25 <iqubic> What's the difference.
19:01:40 <iqubic> I've always assumed one was a type of the other.
19:05:32 <ertes> @let newtype Raw = Raw { fromRaw :: String } deriving (Eq, Monoid, Ord, Show); instance Show Raw where show = fromRaw
19:05:33 <lambdabot>  .L.hs:160:27: error:
19:05:33 <lambdabot>      • Can't make a derived instance of ‘Monoid Raw’:
19:05:33 <lambdabot>          ‘Monoid’ is not a stock derivable class (Eq, Show, etc.)
19:05:43 <ertes> oh, come on…
19:06:11 <ertes> @let newtype Raw = Raw { fromRaw :: String } deriving (Eq, Ord, Show); instance Show Raw where show = fromRaw; instance Monoid Raw where { mappend (Raw xs) (Raw ys) = Raw (xs ++ ys); mempty = Raw "" }
19:06:11 <lambdabot>  Parse failed: Parse error: instance
19:06:19 <ertes> @let newtype Raw = Raw { fromRaw :: String } deriving (Eq, Ord, Show); instance Show Raw where { show = fromRaw }; instance Monoid Raw where { mappend (Raw xs) (Raw ys) = Raw (xs ++ ys); mempty = Raw "" }
19:06:19 <lambdabot>  .L.hs:160:32: error:
19:06:19 <lambdabot>      Duplicate instance declarations:
19:06:19 <lambdabot>        instance [safe] Show Raw -- Defined at .L.hs:160:32
19:06:30 <ertes> d'oh, sorry!
19:06:35 <ertes> @let newtype Raw = Raw { fromRaw :: String } deriving (Eq, Ord); instance Show Raw where { show = fromRaw }; instance Monoid Raw where { mappend (Raw xs) (Raw ys) = Raw (xs ++ ys); mempty = Raw "" }
19:06:36 <lambdabot>  Defined.
19:06:40 <ertes> habits =)
19:07:18 <ertes> @let mkAppNum f = Raw $ "instance (Num a) => Num ((" ++ f ++ ") a) where { (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; negate = fmap negate; signum = fmap signum; fromInteger = pure }"
19:07:19 <lambdabot>  Defined.
19:07:31 <ertes> @. let run mkAppNum "Maybe"
19:07:33 <lambdabot>  Parse failed: Parse error: EOF
19:07:48 <ertes> @. id run mkAppNum "Maybe"
19:07:50 <lambdabot>   instance (Num a) => Num ((Maybe) a) where { (+) = liftA2 (+); (*) = liftA2 (...
19:08:07 <ertes> is that initial space actually part of the output?
19:10:44 <iqubic> What is going on here?
19:10:51 <geekosaur> I think it's inserted on output to prevent bot loops. but a leading space should not break @let
19:11:06 <iqubic> What things are we definning here?
19:11:17 <geekosaur> possibly @let doesn't use the proper mechanism to read its parameter
19:11:26 <geekosaur> so it won't compose properly
19:11:26 <ertes> i was trying to do lambdabot meta-programming
19:11:49 <ertes> geekosaur: it seems there is an extra extra space on the output of @run
19:12:06 <geekosaur> [22 03:10:29] <geekosaur> I think it's inserted on output to prevent bot loops. but a leading space should not break @let
19:12:58 <ertes> looking at that help message from lambdabot makes me wonder…
19:13:02 <ertes> @bf +[]
19:13:07 <lambdabot>  Done.
19:13:13 <ertes> oh, really?
19:13:17 <ertes> that was fast
19:14:19 <ertes> or is that a proof that undefined = "Done."?
19:14:54 <geekosaur> I thought bf didn't do undefined
19:15:14 <ertes> +[] is an infinite loop
19:17:37 <iqubic> @bf +[-]
19:17:37 <lambdabot>  Done.
19:17:49 <geekosaur> probably a modified interpreter that shortcircuits (obvious?) infinite loops
19:17:54 <iqubic> is that an infinite loop?
19:18:02 <ertes> iqubic: no
19:18:36 <geekosaur> "did I change anything in that step? no? then I must be done"
19:18:53 <iqubic> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
19:18:53 <lambdabot>   Hello World!
19:19:07 <iqubic> And why are there extra spaces there?
19:19:26 <ertes> ok, i hope @bf is memory-bounded for this next experiment
19:19:40 <ertes> @bf +[>+]
19:19:41 <lambdabot>  Done.
19:19:54 <ertes> that's…  interesting
19:19:55 <geekosaur> presumably I need to repeat myself a third time, because repeating is good
19:20:08 <geekosaur> until everyone in channel has had a chance to notice it, or something
19:20:54 <boj> always 3, never more, never less
19:21:27 <ertes> :t Nothing
19:21:28 <lambdabot> Maybe a
19:21:37 <geekosaur> iqubic, it is a convention that bots trigger on the first several characters of a message. it's also a convention that bot output starts with a space, so that the bot doesn't output something that a different bot thinks is a command
19:22:16 <geekosaur> although the technical standard says that bots should respond to channel messages with NOTIFYs and vice versa to accomplish the same thing, not many bots actually do this
19:22:28 <iqubic> ertes: What's the point of the intial + in that last program?
19:22:29 <geekosaur> (far too many bots have no idea what a NOTIFY is anyway. likewise most users.)
19:22:38 <dwainetrain> Just starting "Learn You a Haskell for Great Good!". Hello everyone.
19:22:41 <iqubic> @bf [>+]
19:22:41 <lambdabot>  Done.
19:22:53 <iqubic> Also an infinite loop.
19:22:54 <ertes> iqubic: in brainfuck [] acts like do-while
19:23:10 <ertes> and the tape starts with all zeroes, so the loop would never run
19:23:17 <ertes> that's not an infinite loop
19:23:19 <iqubic> Ah. I see.
19:23:22 <olligobber> @bf +[+]
19:23:22 <lambdabot>  Done.
19:23:30 <olligobber> why did that finish?
19:23:38 <iqubic> I did not know the minute of BF
19:23:49 <iqubic> olligobber: That's what we all want to know.
19:24:18 <olligobber> is it an overflow?
19:24:30 <ertes> olligobber: the tape is made out of bytes
19:24:36 <ertes> so all arithmetic is modulo 256
19:24:47 <olligobber> ok, so that one makes sense
19:25:20 <olligobber> what about +[>+] though, is that it reaching the end of the tape or something?
19:25:43 <ertes> there is no end of the tape
19:26:06 <ertes> i just wanted to make sure that the state changes, so @bf can't easily recognise that it's infinite
19:26:26 <olligobber> hmm
19:26:43 <olligobber> @bf +[>+<]
19:26:48 <lambdabot>  Done.
19:27:10 <olligobber> that would arrive back at the original state of 1,0 though
19:27:43 <olligobber> how about... @bf +[>[>]+<[<]>]
19:27:49 <olligobber> @bf +[>[>]+<[<]>]
19:27:54 <lambdabot>  Done.
19:28:03 <ertes> @bf +++[>+++++++++++<-]>.
19:28:03 <lambdabot>   !
19:28:31 <olligobber> there's that looks like 3 * 11
19:28:38 <iqubic> Brainf**k is f**king with my mind.
19:29:00 <iqubic> Is that not 3 * 11?
19:29:13 <ertes> it is
19:29:20 <olligobber> @bf +[[>]+[<]>]
19:29:25 <lambdabot>  Done.
19:29:31 <olligobber> why did that finish?
19:29:34 <iqubic> Stop screwing with my brain.
19:29:43 <olligobber> wtf
19:29:47 <iqubic> lambdabot is just weird.
19:30:31 <ertes> olligobber: i'm pretty sure lambdabot kills the program after a certain amount of time or number of steps
19:30:47 <olligobber> must be that
19:30:58 <olligobber> can we find out how many steps it takes I wonder...
19:31:02 <ertes> if you want to make sure that it's doing work, you have to output something
19:31:18 <iqubic> I read on the haskell wiki that it terminates Haskell interpetation ">" after 3 seconds
19:31:34 <iqubic> +[>+.]
19:31:48 <iqubic> @bf +[>+.]
19:31:54 <lambdabot>                                                                              ...
19:31:57 <ertes> @bf finite: +++++[>+++++<-]>+>[<.>]
19:31:57 <lambdabot>  Done.
19:32:05 <ertes> @bf infinite: +++++[>+++++<-]>+>+[<.>]
19:32:13 <lambdabot>  Done.
19:32:24 <ertes> ok, it looks like @bf only prints if it actually finishes
19:32:41 <olligobber> @bf +[>[>]+<[<]>].
19:32:46 <lambdabot>  Done.
19:33:06 <olligobber> should have a different message when it times out *grumbles*
19:33:41 <ertes> you know what's much more fun than @bf?  @unlambda!
19:33:53 <ertes> too bad there is no @lazyk
19:34:25 <iqubic> How does unlambda work?
19:34:49 <iqubic> @unlambda (\x y -> x + y)
19:34:49 <lambdabot>   unlambda: Unknown operator '('
19:34:49 <lambdabot>   CallStack (from HasCallStack):
19:34:49 <lambdabot>     error, called at Main.hs:45:38 in main:Main
19:34:58 <ertes> iqubic: http://www.madore.org/~david/programs/unlambda/
19:35:10 <iqubic> @unlambda \x y -> x + y
19:35:10 <lambdabot>   unlambda: Unknown operator '\\'
19:35:10 <lambdabot>   CallStack (from HasCallStack):
19:35:10 <lambdabot>     error, called at Main.hs:45:38 in main:Main
19:35:20 <iqubic> Well that's odd.
19:35:52 <ertes> i think this language is better than unlambda: https://esolangs.org/wiki/Lazy_K
19:36:06 <ertes> in a sense lazy k is to unlambda what haskell is to scheme
19:36:16 <jle`> woo hoo ghc 8.4 is just around the corner
19:37:01 <k> i'm not lazy, i just have motivation problems.
19:37:28 <MP2E> haha :p
19:38:01 <iqubic> Unlambda is really weird.
19:38:23 <iqubic> is it a programming language based on S K I combinators?
19:59:21 <_sras_> I can create a lens using the `lens` function in Control.Lens. Is there a similar function that let me create a lens with only  a getter?
20:00:09 <iqubic> :t to
20:00:10 <lambdabot> (Contravariant f, Profunctor p) => (s -> a) -> Optic' p f s a
20:00:22 <iqubic> Let's simplify that.
20:00:53 <iqubic> to :: (s -> a) -> Getter s a
20:01:19 <iqubic> Just use 'to' to get a Getter only.
20:03:23 <iqubic> It'll just work.
20:19:07 <jle`> > view (to fst) ('a', 'b')
20:19:09 <lambdabot>  'a'
20:19:24 <jle`> > ('a', 'b') ^. to fst
20:19:27 <lambdabot>  'a'
20:23:00 <iqubic> x ^. y == view y x
20:23:25 <iqubic> I rarely ever use lenses in my code.
20:23:35 <iqubic> Are lenses really all that useful?
20:23:54 <iqubic> I have hardly any idea how to use lenses at all.
20:24:58 <boj> iqubic: go write some nested data types with and without lenses. try to access or update the fields
20:25:03 <_sras_> iqubic: It worked. Thankyou.
20:25:12 <iqubic> Your welcome.
20:25:21 <glguy> iqubic: What kind of code do you write?
20:25:36 <iqubic> I rarely write haskell code.
20:26:15 <iqubic> the most major thing I did haskell was write days 1-4 of Advent of Code.
20:27:00 <iqubic> I want to make my own IRC bot, but I don't know where to start with that. I already registered a user name for it, so that's good.
20:27:01 <boj> iqubic: to be clear, my advice will give you a concrete idea of why lenses can be useful
20:27:07 <iqubic> I see.
20:27:33 <iqubic> I'm sure it's the kind of thing I'll run into after coding in Haskell for a wihle.
20:27:52 <boj> that tends to be the case, yes
20:28:35 <MarcelineVQ> iqubic: https://wiki.haskell.org/Roll_your_own_IRC_bot
20:29:38 <iqubic> I really should read that.
20:32:07 <iqubic> When I first read that, it was about a year ago, and I couldn't figure out how any of the code worked.
20:33:00 <iqubic> I should take another stab at that. But really the whole thing a glorified "Main = interact ..." in my mind.
20:33:34 <MarcelineVQ> the word interact isn't even on that page
20:33:40 <iqubic> As in, instead of getting the input from one user at one machine, you get strings from several users at several machines.
20:33:52 <geekosaur> lots of network daemons are little more than glorified interact. except that if you want robusness, your interact has to be really glorified :p
20:34:01 <iqubic> I know.
20:34:12 <iqubic> It's a crude analogy at best.
20:34:44 <glguy> It'll be more useful to try and build something than to think about building something. Go go go!
20:34:46 <geekosaur> you could say both pipes and conduit are that kind of glorified interact
20:34:47 <MP2E> It was a good resource for me when I wanted to write a quick markov chain bot to learn some stuff :)
20:35:16 <iqubic> What is a markov chain bot??
20:35:49 <cawfee> Markov chain is like a directed graph
20:35:56 <iqubic> What are pipes and conduits? They sound like data transfer things.
20:36:16 <cawfee> let's say you have a word w
20:36:30 <cawfee> what word to generate next is completely determined by w
20:51:38 <iqubic> I did not know amalloy_ was in here. I've been watching his advent of code videos this year. Good stuff sir.
21:02:19 * hackage siren-json 0.1.1.0 - Siren Tools for Haskell  https://hackage.haskell.org/package/siren-json-0.1.1.0 (alunduil)
21:08:36 <tikhon> I'm playing around with ListT. My current understanding is that I can get the moral equivalent of Either err [a] using ListT (Either err) a—it's a non-deterministic program where if any branch has an error, the entire result is the error.
21:09:12 <tikhon> Is there some nice equivalent for [Either err a]? I'm thinking of a non-deterministic program where a branch can result in an error without affecting the rest of the computation.
21:09:28 <tikhon> Intuitively it seems this makes sense, but I haven't figured out any way to implement this that isn't awkward.
21:14:15 <glguy> aoc done! who's doing it tonight?
21:18:43 <geekosaur> tikhon, have you seen EitherT?
21:19:05 <tikhon> you know, totally didn't think of that
21:19:35 <tikhon> now that you mention it, it's just that my mental model was backwards—I was thinking that ListT (Either err) was what EitherT err [] is
21:20:10 <tikhon> thanks!
21:23:50 <totom> I want to become a good haskell programmer but i just got my first job in React/redux developoment
21:23:56 <totom> :(
21:24:06 <tikhon> are the two mutually incompatible?
21:25:34 <tikhon> I did a bunch of non-Haskell work for years before finally getting a Haskell job.
21:26:02 <tikhon> You can definitely get enough experience on your own to be comfortable switching to Haskell professionally in the future.
21:26:58 <boj> as you gain more experience, maybe even have a chance to build a team with haskell as the primary tool
21:27:21 <tikhon> internal tools tend to be good candidates for that sort of thing
21:29:25 <totom> what can i do on my own to gain enough experience in haskell
21:29:34 <totom> projects to build?
21:29:38 <tikhon> pretty much any sort of programming in Haskell works
21:30:38 <tikhon> I worked on a bunch of programming language stuff, but that's just because that's what I'm interested in myself
21:30:42 <jle`> glguy: wasn't too bad :)
21:30:49 <boj> i taught myself by attempting to build a performant FPS game server in my spare time. big dreams :D
21:30:56 <tikhon> also, I found that writing _about_ Haskell really helped—blogging, Stack Overflow, Quora... etc
21:31:11 <tikhon> writing about an idea forces me to understand it more deeply than just using it
21:31:34 <tikhon> and hey, you improve your writing skills as a bonus
21:31:34 <totom> when i explain something to someone then i can see holes in my understanding
21:31:42 <tikhon> that'll pay off no matter what you end up doing
21:31:54 <totom> true, only to gain
21:34:08 <tikhon> on a similar note, if you live somewhere with a Haskell meetup it's worth going
21:34:22 <tikhon> and meetups are always looking for speakers
21:34:37 <tikhon> giving talks is pretty similar to writing: really forces you to understand a topic
21:34:53 <tikhon> public speaking is more of a niche skill than writing, but it's still incredibly useful
21:35:08 <tikhon> and most people are not very good, which means you only need to be an okay speaker to stand out :)
21:35:53 <totom> I'll find out if  haskell meetups are in my city
21:36:23 <totom> thank you all for the encouragement
21:36:27 <tikhon> meetup.com is probably the place to look
21:36:30 <boj> good luck :)
21:36:34 <totom> :)
21:36:44 <tikhon> if you're in the Bay Area, we have not one but three meetup groups :)
21:36:52 <totom> I am in India
21:36:56 <tikhon> oh
21:37:03 <tikhon> well, there's a meetup group in Bangalore that I know about
21:37:49 <totom> Hmm, i would have to see if it is there in my city
21:38:35 <tikhon> my company has a pretty big office in Bangalore, and we'll probably be looking for more Haskellers next year
21:38:47 <tikhon> although there aren't concrete plans in that regard
21:39:00 <totom> tikhon: Is there any meetup that you know of in pune
21:39:04 <tikhon> not off-hand
21:42:17 <totom> tikhon: Are you from Typelead?
21:42:56 <tikhon> no
21:42:57 <tikhon> Target
21:43:23 <totom> ok
21:43:28 <tikhon> Target India is a really big office in Bangalore and we have some number of people from my team there, but no Haskellers at the moment
21:45:00 <mnoonan_> vacationlabs is in Goa, I think
21:46:41 <totom> tikhon: when i will become good in haskell i'll try there. As of now i'm a beginner
21:47:07 <tikhon> if there's no meetup group in Pune, you could try starting a small study group on your own
21:47:25 <tikhon> I know a few people who've done that here—they get together every week or two and go through a chapter in a Haskell book
21:47:44 <tikhon> Haskell Programming from First Principles is a popular choice
21:52:14 <tikhon> talking about meetups, I'm currently looking for speakers in the Bay Area for 2018
21:53:10 <tikhon> if anyone's interested you can email me at tikhon@jelv.is
21:55:15 <vaibhavsagar> glguy: this one was pretty straightforward
21:55:42 <vaibhavsagar> glguy: if you have a spare couple of minutes, could you walk me through your mapSubSquares function from yesterday?
21:56:15 <vaibhavsagar> It clearly works but I can't figure out how
22:13:55 <glguy_> vaibhavsagar: still around?
22:14:25 <vaibhavsagar> yep :)
22:16:23 <glguy_> I'll be available in about 10 minutes, I'll explain if you're there then otherwise I'm around a lot :)
22:16:41 <vaibhavsagar> Thanks! I'll still be here
22:20:38 <jle`> vaibhavsagar: fwiw all i did was play around with map/concat/transpose in ghci until i got something that looked right
22:20:56 <vaibhavsagar> hahaha, I tried that too
22:21:04 <vaibhavsagar> for a while actually
22:21:20 <jle`> i could have just been lucky :)
22:21:26 <vaibhavsagar> even your solution looks pretty much the same
22:21:57 <vaibhavsagar> after 3 hours I basically gave up and copied the mapSubSquares function
22:22:04 <vaibhavsagar> because that is the only thing I was missing
22:22:19 <vaibhavsagar> and I can't see how I would have come up with it on my own
22:23:08 <jle`> well first you chunksOf, then you have to map something over all the chunks
22:23:20 <vaibhavsagar> yup, that's where my understanding ends
22:23:43 <jle`> actually my first implementation forgot th etranspose at the end because i tested it on lists of lists of Bool's
22:23:50 <jle`> so i just got the shapes right and moved on
22:24:06 <jle`> but for some reason my part 1 answer was right
22:24:25 <vaibhavsagar> hahaha, I got an answer that made the AoC site accuse me of cheating
22:24:28 <totom> may i also know the problem
22:24:32 <vaibhavsagar> I was a bit miffed
22:24:35 <totom> of which you are talking about
22:24:47 <vaibhavsagar> totom: https://adventofcode.com/2017/day/21
22:24:48 <jle`> totom: http://adventofcode.com/2017/day/21
22:24:52 <jle`> totom: join us :)
22:24:56 <jle`> it's not too late!
22:25:17 <ReinH> I've been trying to find a purely analytic solution to Day 3.
22:25:23 <ReinH> i.e. one that doesn't construct any of the grid
22:25:30 <ReinH> It seems like it should be possible.
22:25:38 <totom> I will start from day 1
22:25:56 <vaibhavsagar> ReinH: https://github.com/vaibhavsagar/advent-of-code/blob/master/2017/notebooks/Day3.ipynb
22:26:20 <vaibhavsagar> basically you can figure everything out based on the lower right diagonal
22:26:42 <ReinH> That's what I was thinking.
22:26:53 <ReinH> Since it's odd squares
22:27:26 <ReinH> Wait github loads ipython notebooks?
22:27:29 <totom> is it beginner level or intermediate
22:27:29 <ReinH> That's cool.
22:27:46 <vaibhavsagar> it does! https://github.com/blog/1995-github-jupyter-notebooks-3
22:27:58 <ReinH> Fancy!
22:28:16 <vaibhavsagar> totom: the difficulty increases as the days progress, but some are unexpectedly hard or easy
22:28:44 <totom> ok ty
22:32:28 <jle`> that's pretty neat
22:33:00 <vaibhavsagar> definitely factors into my decision to use Jupyter notebooks wherever possible
22:33:21 <vaibhavsagar> at other times I like to render them to Markdown, which is also quite convenient
22:33:27 <tikhon> You're the one who nixified IHaskell, right? Thanks for that!
22:33:37 <vaibhavsagar> You're very welcome!
22:34:03 <vaibhavsagar> I just copied the nixpkgs service and made lots of updates
22:34:27 <tikhon> I tried doing something like that a while ago, but had lots of trouble building IHaskell
22:34:31 <jle`> whoa just raelized that that's a haskell ipython notebook
22:34:45 <tikhon> things like zeromq kept breaking
22:34:53 <tikhon> then I just creatively gave up
22:35:13 <vaibhavsagar> tikhon: I think things changed after IHaskell got GHC 8.0 support early this year
22:35:26 <tikhon> that might have helped
22:35:50 <tikhon> also, I was trying this on darwin (blah work laptop), and nixpkgs has gotten noticeably better at darwin over the past year or so
22:36:03 <vaibhavsagar> that's probably it
22:36:15 <tikhon> I'm pretty impressed by that actually
22:36:26 <tikhon> running a package repo that works well across Linux and Macs is pretty intense
22:37:46 <vaibhavsagar> I definitely still feel like macOS is a second-class citizen with Nix though, do you find that to be the case?
22:38:05 <vaibhavsagar> (not that I would really know, I don't use macOS at all)
22:38:33 <tikhon> that was definitely what it felt like when I started using OS X for work about 18 months ago
22:38:38 <tikhon> now it's been more stable
22:38:45 <tikhon> I think that's partly thanks to copumkin and friends
22:38:55 <tikhon> and partly because I've been fiddling far less with Nix on my own end
22:39:28 <tikhon> still, at this point, I'm convinced it's totally usable and that I probably don't need brew at all
22:39:53 <vaibhavsagar> that's quite an endorsement :)
22:40:38 <tikhon> I might be understating how rough it is in practice
22:40:57 <vaibhavsagar> tbh it can be quite rough even on NixOS
22:41:10 <tikhon> I only have a handful of packages installed to my user environment
22:41:19 <glguy_> So transpose?
22:41:29 <tikhon> most of the complexity is in our work codebase, and other people have taken up the Nix mantle there
22:41:44 <vaibhavsagar> glguy_: more how everything fits together
22:41:45 <tikhon> and they've done all sorts of responsible things like pinning the version of Nixpkgs we're using
22:41:51 <vaibhavsagar> we do that too!
22:42:05 <tikhon> we sat on nixpkgs-unstable with pinning on our todo list for like a year
22:42:13 <tikhon> and it really was unstable :/
22:42:29 <tikhon> then we hired an experienced Nixer and he fixed that immediately
22:42:32 <tikhon> so that was nice
22:42:40 <glguy_> But do you know what transpose does first? Then we can do the relationship to chunking
22:42:50 <vaibhavsagar> swaps rows and columns?
22:43:19 <glguy_> Yeah.
22:43:45 <glguy_> > ["abc","def"]
22:43:47 <lambdabot>  ["abc","def"]
22:44:34 <glguy_> > transpose ["abc","def"]
22:44:36 <lambdabot>  ["ad","be","cf"]
22:45:01 <vaibhavsagar> glguy_: I think I'm having the most trouble trying to follow the shape of the list through the transformations
22:45:16 <vaibhavsagar> chunksOf and transpose make sense on their own
22:45:20 <EvanR> needs more naperian functors
22:45:33 <vaibhavsagar> I don't know what those are :(
22:45:40 <glguy_> So the whole thing needs to apply a function to a sub list of sub lists, I imagine you got how we chunk each row and process it one at a time
22:46:29 <vaibhavsagar> I think I understand the intention of converting it into 2x2 or 3x3 matrices that are each processed
22:46:51 <vaibhavsagar> because those are the rules we match against
22:48:29 <glguy> right, so the goal is to apply the rules update function to the sub lists of rows
22:48:35 <glguy> so here's a small example code:
22:48:59 <glguy> > [ [0..7], [8..15] ]
22:49:01 <lambdabot>  [[0,1,2,3,4,5,6,7],[8,9,10,11,12,13,14,15]]
22:49:11 <glguy> we'll want to break this up into 4 2x2 windows
22:49:21 <glguy> where that represents two rows of the image
22:49:34 <glguy> so we can map it into rows of chunks
22:49:46 <glguy> > > map (chunksOf 2) [ [0..7], [8..15] ]
22:49:48 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
22:49:53 <glguy> > map (chunksOf 2) [ [0..7], [8..15] ]
22:49:55 <lambdabot>  [[[0,1],[2,3],[4,5],[6,7]],[[8,9],[10,11],[12,13],[14,15]]]
22:50:09 <glguy> but we wanted the 2x2 squares, so we can transpose that into them
22:50:15 <glguy> > transpose (map (chunksOf 2) [ [0..7], [8..15] ])
22:50:17 <lambdabot>  [[[0,1],[8,9]],[[2,3],[10,11]],[[4,5],[12,13]],[[6,7],[14,15]]]
22:50:54 <glguy> so that gives us individual windows like: [[0,1],[8,9]]
22:50:57 <vaibhavsagar> yup, I can see that this gives us the 2x2 squares
22:51:12 <glguy> Now we replace those with the rewrite rule from the input file each
22:51:24 <glguy> which in this case would go to a 3x3 subtile from the original 2x2
22:51:37 <glguy> to do that we map the rule over that list of subtiles
22:52:05 <vaibhavsagar> yup, that makes sense
22:52:11 <glguy> now we've got a row of updated subtiles and it's time to reform the original layout of rows of columns
22:52:27 <vaibhavsagar> hmm, and this is achieved with a transpose somehow?
22:52:39 <glguy> ?let updatedRow = transpose (map (chunksOf 2) [ [0..7], [8..15] ])
22:52:40 <lambdabot>  Defined.
22:52:48 <glguy> so let's pretend like the update rule is 'id' for now and go backward
22:53:05 <glguy> > transpose updatedRow
22:53:07 <lambdabot>  [[[0,1],[2,3],[4,5],[6,7]],[[8,9],[10,11],[12,13],[14,15]]]
22:53:17 <glguy> > map concat (transpose updatedRow)
22:53:20 <lambdabot>  [[0,1,2,3,4,5,6,7],[8,9,10,11,12,13,14,15]]
22:53:42 <glguy> transpose is "involutive", it's its own inverse
22:53:52 <glguy> at least on rectangular grids like this
22:54:11 <vaibhavsagar> I see
22:54:17 <glguy> and then we can invert the original 'map (chunksOf 2)'
22:54:22 <glguy> with that final 'map concat'
22:55:11 <glguy> So convert the grid into rows of subtiles, transform all the subtiles, convert back to rows of columns
22:56:33 * hackage composition-prelude 0.1.1.2 - Higher-order function combinators  https://hackage.haskell.org/package/composition-prelude-0.1.1.2 (vmchale)
22:57:21 <vaibhavsagar> yup, I think I understand the (map concat . transpose . id . transpose . map (chunksOf n))
22:58:03 <vaibhavsagar> and you have a concatMap on the left and another (chunksOf n) on the right
22:59:21 <vaibhavsagar> so it looks like `concatMap (map concat . transpose . map id . transpose . map (chunksOf n)) . chunksOf n`
22:59:26 <glguy> yeah
22:59:54 <vaibhavsagar> I think I understand
23:00:01 <glguy> If you're familiar with lens package, it comes out like: over (chunked n . mapped . mapping (chunked n) . transposed . mapped)
23:00:10 <vaibhavsagar> probably still wouldn't be able to come up with myself
23:00:19 <vaibhavsagar> definitely not familiar with the lens package
23:00:38 <vaibhavsagar> I tried refactor Day 18 with lenses and it was illuminating
23:00:44 <glguy> Well, I think that the lens version does a better job of allowing the steps to shine through
23:00:53 <glguy> but then it adds the complexity of lens
23:01:07 <vaibhavsagar> mapped is fmap, right?
23:01:29 <glguy> yeah
23:01:34 <glguy> well, it's related
23:01:52 <vaibhavsagar> right, I see
23:03:06 <vaibhavsagar> thank you for the explanation :)
23:03:12 <glguy> "as chunks", "each chunk", "chunk each line in the chunk", "under transposition", "each subtile"
23:03:53 <glguy> You're welcome
23:04:05 <glguy> How'd you do yours?
23:04:07 <vaibhavsagar> but it's backwards, right? because function composition?
23:04:22 <vaibhavsagar> I didn't, I just took yours :(
23:04:40 <vaibhavsagar> I had everything except mapSubSquares
23:05:23 <glguy> It's only "backwards" if you're thinking of it as a viewing function
23:05:58 <glguy> as you get more familiar with lens you'll see it as modifying an "update" function, and then it starts being "forward"
23:09:39 <vaibhavsagar> glguy: where does that `transposed` function live?
23:10:04 <vaibhavsagar> or is it meant to be `transpose`?
23:10:21 <glguy_> You'd have to define it: transposed = involuted transpose
23:11:53 <jle`> @let transposed = involuted transpose
23:11:54 <lambdabot>  Defined.
23:12:07 <vaibhavsagar> similar thing for chunked?
23:12:24 <jle`> > [[1,2,3],[4,5,6],[7,8,9]] & transposed %~ reverse
23:12:26 <lambdabot>  [[3,2,1],[6,5,4],[9,8,7]]
23:12:26 <glguy_> I'm on phone so jle` defining stuff is a plus
23:12:50 <jle`> oh allow me to play my role in this then
23:12:58 <vaibhavsagar> @let lensSubSquares n = over (chunked n . mapped . mapping (chunked n) . transposed . mapped)
23:12:59 <lambdabot>  .L.hs:174:8: error:
23:12:59 <lambdabot>      • Variable not in scope:
23:12:59 <lambdabot>          chunked :: t -> (f0 [s0] -> Identity (f0 [t0])) -> s -> Identity t1
23:13:14 <vaibhavsagar> @let lensSubSquares n = over (chunksOf n . mapped . mapping (chunksOf n) . transposed . mapped)
23:13:16 <lambdabot>  .L.hs:174:8: error:
23:13:16 <lambdabot>      • Couldn't match type ‘[[e1]]’ with ‘s -> Identity t’
23:13:16 <lambdabot>        Expected type: ASetter s t [a] [a]
23:13:16 <jle`> @let chunked n = iso (chunksOf n) concat
23:13:17 <lambdabot>  Defined.
23:13:25 <vaibhavsagar> @let lensSubSquares n = over (chunked n . mapped . mapping (chunked n) . transposed . mapped)
23:13:26 <lambdabot>  Defined.
23:13:40 <vaibhavsagar> hmm, I see
23:14:04 <jle`> > [1,2,3,4,5,6,7,8,9] & chunked 3 %~ reverse
23:14:05 <lambdabot>  [7,8,9,4,5,6,1,2,3]
23:15:12 <jle`> > [1,2,3,4,5,6,7,8,9] & chunked 3 . ix 0 %~ reverse
23:15:14 <lambdabot>  [3,2,1,4,5,6,7,8,9]
23:15:19 <jle`> these are fun
23:24:56 <vaibhavsagar> these lens type signatures are from another planet
23:25:08 <EvanR> alien tech
23:25:08 <vaibhavsagar> :t mapping
23:25:10 <lambdabot> (Functor f2, Functor g, Functor f1, Profunctor p) => AnIso s1 t1 a1 b1 -> p (f1 a2) (f2 (g b2)) -> p (f1 s2) (f2 (g t2))
23:25:20 <EvanR> ok that one doesnt seem that bad
23:25:25 <vaibhavsagar> hmm, yes, I know some of these words
23:25:55 <EvanR> youre changing the two deepest types of the profunctor-of-functors
23:26:03 <EvanR> using the AnIso
23:26:36 <jle`> mapping :: Iso' s a -> Iso' (f s) (f a)
23:26:36 <glguy_> You should look at the lens types of definitions with :I or in haddocks
23:28:00 <vaibhavsagar> hmm, with :i it doesn't even mention profunctors
23:28:03 <vaibhavsagar> :i mapping
23:28:09 <jle`> vaibhavsagar: basically if you have an isomorphism between 's' and 'a', then you have an isomorphism between 'f s' and 'f a', for any Functor f
23:28:46 <jle`> vaibhavsagar: yeah, many of the type synonyms in lens is basically over universally quantified profunctors
23:29:34 <vaibhavsagar> I thought that was only true of Isos and Prisms though
23:30:10 <jle`> and Equality i guess >___>
23:30:31 <jle`> i guess not 'most' then :)
23:30:58 <vaibhavsagar> 100% of my knowledge of lenses comes from the first half of lens over tea #1 and spamming lets-lens with typed holes\
23:31:02 <jle`> but really lens could be reformulated using profunctor optics, which would make Lens/Traversal/etc. all universally quantifid prounctors
23:31:21 <vaibhavsagar> IIRC that's what Purescript does?
23:31:39 <jle`> it's appealing from a purist standpoint
23:32:26 <jle`> pun not intended?
23:32:46 <vaibhavsagar> very nice
23:35:19 <jle`> in profunctor optics, Lens s t a b = forall p. Strong p => p a b -> p s t, i believe?
23:35:39 <jle`> you basically just pick the features/capability of your optics by changing the constraint on p
23:35:41 <jle`> which is kinda neat
23:36:13 <jle`> Prism s t a b = forall p. Choice p => p a b -> p s t, so the symmetry is kinda nice
23:37:30 <Lokathor> lenses are so hard to read
23:38:00 <vaibhavsagar> I only started using them yesterday
23:38:11 <vaibhavsagar> I refactored my Day 18 solution and it was pretty cool
23:38:17 <Lokathor> i added them to my half-done roguelike tutorial once
23:38:18 <jle`> yesterday you said you'd call sears
23:40:32 <vaibhavsagar> Lokathor: before: https://github.com/vaibhavsagar/advent-of-code/blob/1f9ebbf613e0e880231b9eaa367dbdfb52bc6eca/2017/notebooks/Day18.ipynb, after: https://github.com/vaibhavsagar/advent-of-code/blob/9ce1b5c24b5759e060d44f69710af3fda5aa1a46/2017/notebooks/Day18.ipynb
23:40:55 <vaibhavsagar> I think AoC is good for pure refactoring exercises
23:41:20 <jle`> i refactored my day22 with lenses/zooming too and it was fun :)
23:41:59 <jle`> well just the main loop
23:42:00 <Lokathor> https://github.com/Lokathor/adventofcode2017/blob/master/src/lib.rs#L1488 i just write trash code that's easy to get on the page quickly. 95% of the time it works
23:42:05 <jle`> but i like any chance i get to use 'zoom'
23:42:19 <Lokathor> vaibhavsagar, what is this strange file format
23:42:49 <vaibhavsagar> does it not render as a Jupyter notebook for you?
23:43:19 <Lokathor> it renders with nice highlighting and stuff
23:43:21 <vaibhavsagar> I've been using them for AoC since the beginning
23:43:23 <Lokathor> but i've never seen this thing before
23:43:29 <Lokathor> In [1]: and such
23:43:52 <vaibhavsagar> Lokathor: http://jupyter.org/
23:44:11 <Lokathor> wild
23:44:16 <vaibhavsagar> it started as a Python project but there are kernels for many languages, including Haskell
23:44:54 <vaibhavsagar> through a series of hilarious coincidences, I am a maintainer for the Haskell kernel: https://github.com/gibiansky/IHaskell
23:45:34 <vaibhavsagar> but I've been using it pretty much since I started learning Haskell
23:46:32 <d-fish> Is there a way to make stack add bounds to my project deps automatically? I've got a lot of them and I haven't kept up
23:47:03 <vaibhavsagar> d-fish: https://github.com/erikd/jenga
23:51:30 <erikd> vaibhavsagar: err, thanks. current version in git is a work-in-progress. hope to get it fully working over the xmas break :)
23:53:10 <vaibhavsagar> :)
23:57:22 <jle`> erikd: thanks for the good work :)
23:57:41 <erikd> thanks jle`
