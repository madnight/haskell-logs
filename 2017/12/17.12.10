00:03:19 <fred_> how can i make stack install latest ghc?
00:05:32 <cocreature> Guest31989: choose a recent nightly resolver
00:06:31 <Guest31989> i ran stack update, then stack new my-project, then changed to a recent nightly resolver, then stack setup but i'm getting Unable to parse cabal file: NoParse "build-depends" 58
00:06:57 <Guest31989> i haven't touched the cabal file created by stack. i only changed the resolver in stack.yml to a recent one...
00:07:23 <cocreature> try upgrading to the newest stack release
00:07:27 <glguy> xor is best done with foldl1'
00:07:35 <glguy> Oh, and I was scrolled way up
00:07:37 <MarcelineVQ> yes you need to run  stack upgrade
00:07:51 <Guest31989> aaah i ran stack update
00:08:05 <cocreature> "stack update" updates the package index
00:08:10 <cocreature> "stack upgrade" upgrades stack
00:08:12 <Guest31989> yeah makes sense
00:13:53 * hackage wai-middleware-rollbar 0.6.0.1 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.6.0.1 (joneshf)
00:15:10 <jle`> glguy: why not xor with 0
00:24:54 <pja> AdventOfCode might have to wait today. It’s snowed!
00:41:46 <nshepperd_> > runRoundn 3 (0, 0, [0..4])
00:41:49 <lambdabot>  (3,1,[2,1,0,3,4])
00:43:43 <nshepperd_> Huh, that actually worked
00:43:52 <nshepperd_> I bet it has horrible bugs
00:44:20 * nshepperd_ has no computer access right now so solving aoc via lambdabot
00:47:20 <glguy> jle`: just in this particular case where we only process lists of 16 elements, or at a minimum non empty ones
01:04:53 * hackage aivika-gpss 0.5 - GPSS-like DSL for Aivika  https://hackage.haskell.org/package/aivika-gpss-0.5 (DavidSorokin)
01:10:42 <nshepperd_> http://lpaste.net/360656 spoilers if anyone would find my lambdabot-spam-golf based solution amusing
01:11:13 <nshepperd_> Got it done just in time for my flight to take off and take away my internet :)
01:15:42 <nshepperd_> I'm sure that the lens into list span can be golfed down somehow to avoid the conditional, but thinking about it was making my head hurt
01:17:11 <jle`> nshepperd_: congrats :)
01:21:46 <wz1000> anyone interested in writing an autocompletion engine for haskell?
01:23:47 <MarcelineVQ> how completey? ghci pressing tab completey?
01:24:34 <wz1000> MarcelineVQ: no, much better than that
01:25:14 <wz1000> I have some code I really want to delete
01:25:45 <wz1000> but no one has stepped up to write a replacement :(
01:26:37 <wz1000> https://github.com/haskell/haskell-ide-engine/blob/master/hie-hare/Haskell/Ide/HaRePlugin.hs#L417
01:26:56 <wz1000> I want someone to kill this monstrosity and write something better
01:44:26 <mniip> is it possible to sample an Arbitrary instance in lambdabot?
01:46:24 <jle`> @check const False
01:46:29 <lambdabot>  *** Failed! Falsifiable (after 1 test):
01:46:33 <lambdabot>  ()
01:46:44 <jle`> i guess it's not very useful because of shrinking
01:51:53 <koanta> so like, use_web(google:ebay), nop, deliver(package)?
01:52:27 <MarcelineVQ> fsv of sample
01:53:51 <MarcelineVQ> @check forAll (arbitrary :: Gen [Int]) ((<12) . length)
01:53:55 <lambdabot>  *** Failed! Falsifiable (after 20 tests):
01:53:55 <lambdabot>  [12,15,4,7,12,17,8,-17,-6,-15,13,19,-19,15,-19,-2]
01:54:09 <MarcelineVQ> in a form you can work with though, idk... sampling is IO
01:56:43 <MarcelineVQ> lambdabot's stuff uses Test.QuickCheck.Safe.SProperty whatever that is, so it won't let you do IO things even if you can see them I guess
01:56:48 <MarcelineVQ> @check ioProperty (return $ 1 === 1)
01:56:50 <lambdabot>  error:
01:56:50 <lambdabot>  • No instance for (STestable Test.QuickCheck.Property.Property) arising from...
02:00:36 <koanta> @check email(bitcoin :: SPAM) 
02:00:39 <lambdabot>  error:
02:00:39 <lambdabot>  Not in scope: type constructor or class ‘SPAM’
02:01:24 <ticktock_> @run let randomfunc f = f f x
02:01:26 <lambdabot>  <no location info>: error:
02:01:26 <lambdabot>      not an expression: ‘let randomfunc f = f f x’
02:02:53 <ticktock_> this gives me an ' Occurs check: cannot construct the infinite type' error in my console, why ? 
02:05:23 <mniip> ticktock_, the typechecker infers that f must have an infinite type
02:05:33 <MarcelineVQ> function application is left associative, so that reads as (f f) x  possibly you meant  f (f x)
02:05:38 <mniip> in particular, it sees that f is applied to an argument, so it must be a function
02:06:02 <mniip> in f :: a, and a ~ b -> c
02:06:10 <mniip> but then it sees that the argument it is applied to is if
02:06:12 <mniip> so a ~ b
02:06:23 <mniip> and so it infers a ~ a -> ...
02:06:27 <mniip> which trips the occurence check
02:19:59 <mniip> hmm this monoid is backwards
02:31:42 <pja> jle`: Using your own forks of Haskell libraries to solve today’s advent of code is definitely cheating :)
02:32:08 <pja> jle`: but they do look useful...
02:33:09 <mniip> ah ha!
02:40:53 <jle`> pja: i fork them for a reason ;)
02:41:12 <fred-fri> is it bad to have resolver: nightly-2017-12-01 (uses 8.2.2 in absence of specifying a different compiler version) and compiler: ghc-8.2.2 in the global-project stack.yml file?
02:41:54 <fred-fri> sorry typo: is it bad to have resolver: nightly-2017-12-01 (uses 8.2.2 in absence of specifying a different compiler version) and compiler: ghc-8.2.1 in the global-project stack.yml file?
02:42:20 <fred-fri> ie telling stack don't even though resolver would result in using 8.2.2, use 8.2.1
02:43:01 <pja> jle`: :)
02:52:41 <cocreature> fred-fri: it’s probably fine but stackage doesn’t test against that release so you might get packages that don’t work.
02:52:55 <mniip> hmm
02:52:56 <mniip> unexpected
02:53:18 <fred-fri> cocreature, basically i want to use 8.2.1 and everything to work with that.. should i switch to a lower resolver that defaults to 8.2.1
02:53:29 <mniip> it passes simple tests, but,
02:53:30 <mniip> @check \ts -> (0 `elem` ts) ==> (case runRounds ts of (_, _, m) -> case foldMap cipher (zip [(0 :: Word4)..] ts) of Semi _ (Perm m') -> m == m')
02:53:33 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 1 shrink):
02:53:33 <lambdabot>  [8,3,7,6,14,14,14,9,1,7,12,10,0,12,4,10,10,5]
02:53:40 <mniip> @check \ts -> case runRounds ts of (_, _, m) -> case foldMap cipher (zip [(0 :: Word4)..] ts) of Semi _ (Perm m') -> m == m'
02:53:43 <lambdabot>  *** Failed! Falsifiable (after 25 tests and 2 shrinks):
02:53:43 <lambdabot>  [7,3,15,12,1,9,12,13,8,5,5,10,8,3,9,13,5,3,10,10,3,15,11]
02:53:50 <cocreature> fred-fri: why do you want to use 8.2.1 in the first place? there is a reason 8.2.2 was released, it fixes bugs :)
02:54:20 <fred-fri> because when i do stack install intero its unable to install intero, says intero requires max 8.2.1 atm
02:54:29 <mniip> hmm
02:54:37 <mniip> @check \ts -> (length ts <= 15) ==> (case runRounds ts of (_, _, m) -> case foldMap cipher (zip [(0 :: Word4)..] ts) of Semi _ (Perm m') -> m == m')
02:54:40 <lambdabot>  +++ OK, passed 100 tests.
02:54:44 <mniip> ???
02:54:56 <mniip> oh
02:54:57 <mniip> of course
02:55:04 <mniip> [0..] is a finite list
02:55:17 <mniip> @check \ts -> case runRounds ts of (_, _, m) -> case foldMap cipher (zip (cycle [(0 :: Word4)..]) ts) of Semi _ (Perm m') -> m == m'
02:55:21 <lambdabot>  +++ OK, passed 100 tests.
02:55:22 <mniip> there we go
02:55:32 <mniip> jle`, basically
02:55:45 <mniip> cipher (skip, len) = Semi (skip + len) (reversal len)
02:55:59 <mniip> data Semi a = Semi a (Perm a)
02:56:08 <mniip> data Perm a = Perm (M.Map a a)
02:56:23 <mniip> instance (Monoid a, Universal a, Ord a) => Monoid (Semi a) where mempty = Semi mempty mempty; mappend (Semi a ap) (Semi b bp) = Semi (a <> b) (inv (roll a) <> bp <> roll a <> ap) 
02:56:24 <MarcelineVQ> fred-fri: you can install it from git if you like, and just bump up the version manually, it says that should work here  https://github.com/commercialhaskell/intero/issues/494
02:56:37 <mniip> and so
02:56:41 <mniip> we resolve ciphering to foldMap
02:56:49 <mniip> :t foldMap cipher
02:56:50 <lambdabot> (Num a, Ord a, Bounded a, Enum a, Monoid a, Foldable t) => t (a, a) -> Semi a
02:57:21 <mniip> I suppose I could make it worse
02:59:37 <jle`> a ~ Sum Int ?
03:00:01 <mniip> Sum Word8
03:00:04 <jle`> * Sum Word8
03:00:10 <jle`> oh hey
03:00:11 <mniip> yeah
03:00:17 <jle`> i could have been using Word8 instead of Finite 256
03:00:24 <mniip> I've defined a handy Word4 type so that quickcheck doesn't die
03:00:33 <cocreature> fred-fri: you’ll probably be fine either way
03:00:39 <mniip> @check \p -> (p :: Perm Word8) == p
03:00:45 <lambdabot>  mueval-core: Time limit exceeded
03:00:46 <mniip> @check \p -> (p :: Perm Word4) == p
03:00:49 <lambdabot>  +++ OK, passed 100 tests.
03:00:56 <jle`> and my modClass :: Integer -> Finite 256 is just fromIntegral :: Integer -> Word8
03:01:12 <jle`> er
03:01:26 <koanta> @check email(bitcoin :: SPAM)
03:01:29 <lambdabot>  error:
03:01:29 <lambdabot>  Not in scope: type constructor or class ‘SPAM’
03:02:02 <jle`> well, Word8 has modular addition, which is what i was abusing Finite 256 for, so that might have been a simpler way to go
03:02:31 <mniip> likewise
03:03:45 <mniip> hmm
03:03:47 <mniip> is this a monoid
03:04:01 <jle`> i was toying with the idea of using a permutations library instead of directly manipulating a permuted vector
03:04:18 <jle`> and so the permutations would compose
03:04:24 <jle`> i don't know if it's a monoid though
03:04:37 <mniip> permutations are definitely a monoid
03:04:42 <mniip> I'm thinking of something wrose
03:04:42 <jle`> i mean, your thing
03:04:55 <mniip> it is, I checked
03:05:17 <mniip> this is akin to the semidirect group product,
03:05:27 <mniip> but a product of monoid to a group that results in a monoid
03:05:43 <mniip> over the 'roll' monoid homomorphism
03:06:17 <jle`> what i think would definitely work is something like my EndoKleisli Writer that i used briefly for 3
03:07:35 <jle`> hm, no
03:07:35 <mniip> EndoKleisli?
03:07:48 <mniip> consider this
03:07:51 <jle`> yeah a monoid instance for (a -> m a), EndoKleisli is probably an ambiguous name
03:07:51 <mniip> data Sequenced a b = Sequenced { ssize :: a, sindex :: a -> b }
03:07:55 <mniip>     mappend (Sequenced a af) (Sequenced b bf) = Sequenced (a <> b) (\p -> af p <> bf (<> p))
03:08:03 <mniip> is this a monoid?
03:08:26 <mniip> correction
03:08:30 <mniip>     mappend (Sequenced a af) (Sequenced b bf) = Sequenced (a <> b) (\p -> af p <> bf (a <> p))
03:09:06 <mniip> looks positively monoidal to me
03:10:03 <jle`> what's the identity?
03:10:09 <mniip> evident
03:10:15 <mniip> Sequenced mempty (const mempty)
03:10:18 <jle`> ah
03:10:31 <ertes> MarcelineVQ: hmm?
03:13:45 <mniip> cipher :: (Ord a, Enum a, Bounded a, Monoid a) => a -> Sequenced a (Semidirect a)
03:13:45 <mniip> cipher len = Sequenced (succ mempty) $ \skip -> Semidirect (len <> skip) (reversal len)
03:29:51 <mniip> ok
03:32:11 <mniip> @tell glguy see my revised version http://lpaste.net/360659
03:32:11 <lambdabot> Consider it noted.
03:34:43 <mniip> I don't think I've ever invented 2 monoids in a day
03:34:45 <mniip> worse
03:34:48 <mniip> monoid transformers
03:35:01 <mniip> I think it's time to start a library
03:35:05 <mniip> monoid transformer library
03:35:27 <cocreature> and since hackage is case sensitive you can just call it "MTL"!
03:35:33 <cocreature> I’m sure that’s not going to lead to confusion
03:35:47 <mniip> I can supersede mtl though
03:35:52 <mniip> as monads are a specific case of monoid
03:49:21 <parks37> If I am changing the order of a list over multiple steps, how do I reference this new list I don't have a name for? 
03:52:01 <cocreature> parks37: how are you changing the order without having a reference to it?
03:52:24 <parks37> That's kind of what I'm asking, I think?
03:53:41 <parks37> I have an intial list. I want to take items off the front one at a time and do something for each item and eventually put them all back in the right order with parenthesis before and after some terms. 
03:57:59 <cocreature> parks37: I’m still not following what the problem is. do you have some example to demonstrate what you are trying to do and what is causing trouble?
04:13:11 <simendsjo> "MOnOid Transformer library" -> "moot" :)
05:27:11 <lseactuary> anyone here know about first-order-logic? i have a problem i am trying to model using this logic, i have typed a somewhat solution, and wanted to run a few things past someone please.
05:33:23 * hackage flay 0.2 - Work generically on your datatype without knowing its shape nor its contents.  https://hackage.haskell.org/package/flay-0.2 (RenzoCarbonara)
05:41:27 <AndreasK> Anyone familiar with how criterion colors it's bars? I've run into the issue of it producing barely visible bars ( https://github.com/bos/criterion/issues/170 ) but it's not obvious where it takes the colors from
05:42:17 <AndreasK> I would like to change/fix this but without knowledge of the js involved that seems like a pain
05:43:55 <koanta> do you go out drinking?
05:43:58 * hackage subzero 0.1.0.4 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.4 (codeshot)
05:47:51 <fakenullie> AndreasK: doesn't it say that this is already fixed?
05:48:52 <AndreasK> fakenullie: As of less than 5 Minutes ago :D Thanks for the hint
05:54:23 <cheater> hi
05:54:48 <cheater> does anyone know finally tagless representation and could sum up what it does in a few words?
05:55:10 <cheater> i'm trying to figure out if it's relevant to what i'm doing recently, but i'm not sure how to get into it.
06:01:35 <vaibhavsagar> silly part 2 AoC question: I'm getting the right hash for all the example values but it's telling me my answer is wrong, what should I do?
06:03:32 <barrucadu> Try manually stepping through something smaller than your full input and see if you spot a mistake
06:03:33 <Gurkenglas> How do I find where in the public libraries a name is used? (Just found out about mapAndUnzipM and wondering why it deserves a name.)
06:03:55 <ecly> sure you don't have a trailing or leading whitespace or something like that? perhaps a newline?
06:04:08 <MarcelineVQ> Gurkenglas: hoogle is your best bet these days if you know the name http://hoogle.haskell.org/?hoogle=mapAndUnzipM
06:04:19 <MarcelineVQ> oh wait that's not what you asked
06:04:20 <MarcelineVQ> drat!
06:05:52 * koanta sits quietly, thinks about not being here
06:06:09 * hodapp looks at koanta
06:06:16 <MarcelineVQ> @check email(bitcoin :: SPAM)
06:06:18 <lambdabot>  error:
06:06:18 <lambdabot>  Not in scope: type constructor or class ‘SPAM’
06:16:23 * hackage pg-store 0.5.0 - Simple storage interface to PostgreSQL  https://hackage.haskell.org/package/pg-store-0.5.0 (vapourismo)
06:20:30 <pzp> If I have many values that are of the same type, can I split the type signature for all of them over multiple lines?
06:20:44 <koanta> if they come back, dont just offer them a beer
06:21:00 <MarcelineVQ> koanta: your wires are showing
06:21:25 <koanta> ok ok, I'll b q
06:25:38 <lyxia> pzp: Do you have an example?
06:26:06 <pzp> lyxia: a, b, c, d, ..., x, y, z :: Alphabet
06:26:51 <pzp> My actual use case is more legitimate than that and the names of the values are much longer
06:29:22 <MarcelineVQ> pzp: sure  a, b, c, d,\n  e,f :: Int
06:29:57 <MarcelineVQ> iow normal indentation rules afaik
06:30:25 <pzp> MarcelineVQ: Bingo! I was forgetting the spaces at the start of each line
06:39:53 * hackage subzero 0.1.0.5 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.5 (codeshot)
06:54:50 <vaibhavsagar> I figured it out: my problem was that I wasn't padding hex digits less than 0x10 with a leading 0
06:59:53 <codeshot> Does anyone know why the Applicative instance of ((->) r) is being removed from base? Or have I misunderstood recent change to the contents of Hackage?
07:00:21 <MarcelineVQ> idk, what changes would you be referring to?
07:02:16 <codeshot> Any changes that might have led me to believe ((->) r) was being removed when really it's still there but just not listed
07:02:52 * hackage ansi-escape-codes 0.1.0.0 - Haskell package to generate ANSI escape codes for styling strings in the terminal.  https://hackage.haskell.org/package/ansi-escape-codes-0.1.0.0 (joegesualdo)
07:03:53 <codeshot> I could write a paper on my question but normally people don't need it
07:04:11 <[Leary]> From what I've heard in this channel, there are haddock bugs that make some stuff not show up in the documentation.
07:05:57 <ahihi> https://hackage.haskell.org/package/base-4.10.1.0/docs/Control-Applicative.html it's listed, though
07:08:21 <codeshot> I can't see it there but I can see it here: https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Applicative.html
07:08:29 <MarcelineVQ> codeshot: it's in there, I​ believe it's just being showing really really oddly as  Applicative ((->) LiftedRep LiftedRep a)
07:08:50 <mniip> codeshot, it's still there
07:08:50 <mniip> it just appears a little bit distorted due to the hidden kind arguments bug
07:09:11 <codeshot> ok, thanks
07:12:23 <ahihi> it's a bug?
07:12:55 <ahihi> i assumed it was just a consequence of the levity polymorphism stuff introduced in ghc 8
07:14:13 <mniip> the arguments aren't supposed to be visible
07:14:34 <mniip> especially not as (LiftedRep -> LiftedRep) a b
07:17:48 <dminuoso> mniip: Thank you for the assignment with the transformer by the way. I rolled a few more, and aside from having to plug in UndecideableInstances it all went like a breeze. :)
07:18:03 <mniip> hmmm?
07:19:54 <dminuoso> mniip: Oh I couldnt figure out how to make the Show instance work without the extension: https://gist.github.com/dminuoso/210708164da5e08e102420c03a2f059c
07:20:08 <dminuoso> Some googling suggested newtype wrappers would help, but it wasnt very obvious.
07:20:12 <mniip> I'm not sure if I gave you any assignment
07:20:19 <dminuoso> Oh..
07:20:43 <dminuoso> Oh it must have been merijn then, I just vaguely recall someone starting with `m`
07:20:50 <mniip> regarding the show instance,
07:20:54 <mniip> you could use Show1
07:22:52 <mniip> @let data W w m a = W (m (a, w))
07:22:53 <lambdabot>  Defined.
07:24:00 <mniip> @let instance (Show1 m, Show a, Show w) => Show (W w m a) where showsPrec d (W w) = showParen (d >= 10) $ showString "W " . liftShowsPrec showsPrec showList 10 w
07:24:01 <lambdabot>  .L.hs:255:11: error:
07:24:01 <lambdabot>      Not in scope: type constructor or class ‘Show1’
07:24:01 <lambdabot>      Perhaps you meant one of these:
07:24:09 <mniip> @let import Data.Functor.Classes
07:24:11 <lambdabot>  Defined.
07:24:13 <mniip> @let instance (Show1 m, Show a, Show w) => Show (W w m a) where showsPrec d (W w) = showParen (d >= 10) $ showString "W " . liftShowsPrec showsPrec showList 10 w
07:24:15 <lambdabot>  Defined.
07:24:23 <user6363636329> Hello, anyone could help me with Stack?
07:24:54 <barrucadu> user6363636329: Don't ask to ask, just ask
07:25:34 <mniip> @let instance (Show1 m, Show w) => Show1 (W w m) where liftShowsPrec showsprec showlist d (W w) = showParen (d >= 10) $ showString "W " . liftShowsPrec showsprec showlist 10 w
07:25:36 <lambdabot>  .L.hs:264:69: error:
07:25:36 <lambdabot>      • Couldn't match type ‘a’ with ‘(a, w)’
07:25:36 <lambdabot>        ‘a’ is a rigid type variable bound by
07:26:37 <mniip> @let instance (Show1 m, Show w) => Show1 (W w m) where liftShowsPrec showsprec showlist d (W w) = showParen (d >= 10) $ showString "W " . liftShowsPrec (liftShowsPrec2 showsprec showlist showsPrec showList) (liftShowList2 showsprec showlist showsPrec showList) 10 w
07:26:39 <lambdabot>  Defined.
07:28:07 <dminuoso> mniip: Whats that instance for?
07:28:12 <user6363636329> I'm using stack for the first time. Successfully create new project using stack new [name] and then wanted to install hoauth2 package. I'm bit confused where should I add this dependency (to build-depends in .cabal file or somewhere inside stack.yaml file) and how to install it.
07:28:13 <mniip> Show1
07:28:14 <dminuoso> Or rather, what exactly is Show1 for?
07:28:22 <mniip> :t liftShowsPrec
07:28:23 <lambdabot> Show1 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> f a -> ShowS
07:28:29 <mniip> for lifting showsPreci
07:33:15 <dminuoso> mniip: Okay that exceeded my mental stack completely. 
07:33:17 <dminuoso> :t liftShowsPrec2
07:33:18 <lambdabot> Show2 f => (Int -> a -> ShowS) -> ([a] -> ShowS) -> (Int -> b -> ShowS) -> ([b] -> ShowS) -> Int -> f a b -> ShowS
07:33:46 <dminuoso> The whole business of Show1 and Show2 is not really that obvious. :-)
07:38:28 <mniip> dminuoso, basically
07:38:36 <mniip> it's kind of like
07:38:47 <mniip> instead of the implicit Show a => Show (F a)
07:39:04 <mniip> you get an explicit liftShow :: Dict (Show a) -> Dict (Show (F a))
07:39:13 <mniip> for a very explicit meaning of Dict
07:39:29 <mniip> such liftShow is parameterized over the F
07:39:35 <mniip> Show1 F is the class
08:04:26 <codeshot> Is there already a fairly standard Map that has an applicative instance (eg, Either v (Map k v) ?)
08:04:33 <codeshot> I don't want to reinvent the wheel
08:04:49 <codeshot> with a newtype, of course
08:05:04 <Gurkenglas> http://hackage.haskell.org/package/transformers-0.5.5.0/docs/src/Control-Monad-Trans-Cont.html#callCC <- why is "ContT $ \ c -> runContT (...) c" not "..."?
08:05:43 <Gurkenglas> Oh, c appears within "...".
08:10:02 <mniip> Gurkenglas, hehe that function is magic
08:20:54 <__dbarbs> exit
08:23:17 <Gurkenglas> Hacking away at it, maybe I can explain it to the university workshop on exotic language features that offhandedly assigned Haskell's Cont to some newbie like the Dartmouth Conference in 1956 thinking to solve AI with 10 scientists and two months and now the professor thinks callCC is compiler magic.
08:32:27 <mniip> Gurkenglas, show them this
08:32:38 <mniip> @let puncture = (`runCont` \xs -> fmap (second ($ fmap fst xs)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs))))
08:32:41 <lambdabot>  Defined.
08:32:44 <mniip> :t puncture
08:32:46 <lambdabot> Traversable f => f b -> f (b, b -> f b)
08:33:00 <mniip> yeah that's a traverse callCC
08:35:50 <clipcomp> hllo
08:35:55 <clipcomp> hello
08:37:02 <clipcomp> this room is dead
08:39:07 <Gurkenglas> Browse http://irclogger.com/.haskell/2017-12-10 if you're bored
08:40:38 <cada> hi
08:40:42 <cada> need help with python please
08:41:09 <cocreature> cada: you’re in the wrong channel for that, this channel is about the Haskell programming language
08:41:31 <cada> which is right channel ?
08:41:42 <cocreature> #python?
08:41:53 <ecly> #lesswrong
08:51:43 <mniip> Gurkenglas, you'd have to be really bored to browse that
08:51:45 <mniip> as it's empty
08:52:26 <Gurkenglas> I noticed just in time, but it was too fitting to his preconception that the channel is dead
08:54:17 <cada> browse what ?
08:55:14 <Gurkenglas> the link to a site that lies that it logs this channel
08:57:19 <Gurkenglas> Anyone know scde_ well enough to ask him a question his kidnapper won't be able to answer?
08:59:07 <infinisil> Note for next haskell project: Put logging capability everywhere, it's a pain to not have that
08:59:40 <infinisil> Hopefully I'll be able to use fancy monad transformers more
09:00:23 * hackage bunz 0.0.1 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.1 (sendyhalim)
09:00:56 <Gurkenglas> infinisil, if it's temporarily for debugging traceM from Debug.Trace might help
09:01:15 <beaky> is there a name for the following technique of encoding constraints and invariants with the type system: e.g. only allowing rbtrees to be constructed via a set of functions in a way that guarantees every rbtree instance has the ordered/balanced invariant (and conversely impossible to ever instantiate e.g. an unbalanced rbtree, since the only existing possible constructors always maintain balance), or how an
09:01:17 <beaky> append between two Vectors must always monotincally increase the length of the result?
09:01:27 <Gurkenglas> How far are we away from an IDE debuger that steps through lines of do notation?
09:02:35 <beaky> (i guess my latter example is the classic dependent typing example, but what about the rbtree example?)
09:02:51 <parks37> Is there a way to pattern match to identify operators? Like similar to making an 'in ' call on a list? I want a guard to identify if the item being looked at is a operator or a letter.
09:03:21 <infinisil> Gurkenglas: Oh that looks handy
09:03:50 <cada> https://www.youtube.com/watch?v=X8qL6cAI0zQ
09:03:59 <infinisil> beaky: Just wanted to say that's what dependent types do, Idris \o/
09:04:01 <Gurkenglas> I wonder how traceM interacts with ContT
09:04:05 <Athas> infinisil: putting logging everywhere is really awkward in Haskell.  But Debug.Trace is a good way to cheat when debugging.
09:04:12 <beaky> nice i have to try idris then
09:04:58 <infinisil> beaky: It's really an amazing language, can recommend. It's like haskell on steroids
09:05:25 <Athas> What is Idris's performance like these days?
09:05:55 <Athas> I recall people talking about Idris being designed to address some of the performance issues with prior dependently typed languages.
09:06:07 <Athas> And by "people" I mean "Edwin Brady".
09:06:15 <infinisil> heh, no idea
09:06:56 <cocreature> Athas: given that for prior languages, it was already surprising if you could actually run the code instead of only proving theorems, the bar is not particularly high :)
09:07:53 * hackage bunz 0.0.2 - CLI tool to beautify JSON string.  https://hackage.haskell.org/package/bunz-0.0.2 (sendyhalim)
09:08:01 <Athas> cocreature: and for code involving large-ish numbers, it could often only be extrapolated that it would even type-check...
09:10:21 <infinisil> Evaluating `the Nat 5000` (5000 peano number) takes like 30 seconds xD
09:10:45 <Athas> Guess we're still some time away from the first high-performance dependently typed languages.
09:11:00 <Athas> Well, apart from ATS I guess, but I'm not really sure how it differs from the others.
09:11:20 <infinisil> However, Somebody in #idris showed this project which does binary numbers instead of unary (which what peano numbers are): https://github.com/sbp/idris-bi
09:11:39 <cocreature> oh I thought idris internally did some magic to turn peano-naturals into binary numbers in a lot of cases?
09:12:22 <infinisil> I think it does at runtime
09:12:37 <cocreature> ah ok
09:14:07 <beaky> can i emulate dependent types with GADTs and stuff
09:14:25 <infinisil> I mean proofs over Zero | Succ Nat can't just be converted to proofs over binary numbers (i think)
09:15:03 <cocreature> beaky: yeah with GADTs, DataKinds, type families and singletons you can emulate them. it’s just really annoying
09:15:10 <beaky> ah
09:15:30 <infinisil> there's a bunch of blogposts about this online, search for "haskell dependent types"
09:15:51 <pta2002> hello, I'm trying to learn how to use haskell
09:15:55 <beaky> nice thanks 
09:15:56 <pta2002> s/haskell/parsec
09:16:00 <cocreature> infinisil: even if you can’t do it in general, you could definitely find a reasonably large subset for which it is possible
09:16:07 <pta2002> I'm trying to do http://adventofcode.com/2017/day/9 this
09:16:29 <infinisil> cocreature: That might be true
09:16:32 * infinisil thinks about it
09:16:36 <glguy> pta2002: Have you joined the #haskell AoC group yet? 43100-84040706
09:16:51 <pta2002> AoC has groups?
09:16:58 <cocreature> private leaderboards
09:16:59 <glguy> http://adventofcode.com/2017/leaderboard/private
09:17:01 <pta2002> http://lpaste.net/970099839331205120 still, here's my code
09:17:05 <pta2002> oh neat
09:17:34 <pta2002> for some reason I can't get it to parse {<>,<>}
09:17:57 <Gurkenglas> note the hlint hints at the bottom of your paste
09:18:02 <infinisil> During my first haskell project ever in the last month, I really missed dependent types :/
09:18:17 <flyingfish> í¸í ½
09:18:26 <pta2002> ...why is it that every time I ask for help I end up fixing it. Removed lines 9 and 13 and it works now
09:18:27 <glguy> pta2002: i'll stare at it; at first read it seems like it would have parsed that :)
09:18:33 <pta2002> Gurkenglas: thanks for letting me know
09:19:05 <pta2002> also what's the difference between print and putStrLn?
09:19:07 <infinisil> pta2002: https://en.wikipedia.org/wiki/Rubber_duck_debugging
09:19:07 <flyingfish> hi all í¸í ½
09:19:08 <glguy> pta2002: Yeah, the spec doesn't allow garbage in those places, so line 9 probably ate the garbage that needed to be considered this list element of the group
09:19:22 <infinisil> :t print
09:19:23 <glguy> pta2002: print = putStrLn . show
09:19:24 <lambdabot> Show a => a -> IO ()
09:19:27 <infinisil> :t putStrLn
09:19:28 <pta2002> Ah
09:19:28 <lambdabot> String -> IO ()
09:19:32 <pta2002> thanks, didn't know
09:20:05 <pta2002> also redundant bracket on line 8?
09:20:10 <pta2002> there's no bracket there
09:20:30 <Gurkenglas> clicking on a hint down there expands it
09:21:09 <pta2002> ah
09:21:13 <glguy> pta2002: You don't want a "try" on line 19 of the paste
09:21:18 <pta2002> well it wasn't on line 8
09:21:27 <pta2002> glguy: hmm alright
09:22:02 <pta2002> well, this code works! Thanks :D
09:22:36 <Gurkenglas> pta2002, rubber duck debugging explains that, you could go to an empty channel talk to it as if it were #haskell and imagine responses you might get
09:22:54 <pta2002> haha, looks like I might need that
09:23:04 <beaky> by the way is dependent typing the same as homotopy type theory
09:25:17 <Gurkenglas> is there a word for library api changes being bundled with scripts that patch user code?
09:25:25 <parks37> Is there a way to pattern match to identify operators? Like similar to making an 'in ' call on a list? I want a guard to identify if the item being looked at is a operator or a letter.
09:25:40 <Gurkenglas> What's an "'in ' call"?
09:26:27 <parks37> Like in python or c. You'd make a list of values. And then have a boolean later saying if x in list1:
09:27:19 <parks37> I would like to impliment that in a guard, but am I having trouble implimenting it.
09:27:26 <AndreasK> parks37: Not a pattern but you can use guards (and the elem function)
09:27:54 <parks37> Would I just say   
09:28:31 <parks37> | x == char = docharacteroption ? 
09:30:24 <AndreasK> If you want to check for a specific char that works
09:31:02 <parks37> What if I want to check for any char?
09:31:12 <parks37> sorry, any letter?
09:31:41 <AndreasK>  | isAlpha x = ...
09:32:41 <parks37> You rock, thank you.
09:33:47 <kuribas> parks37: are you writing a parser?
09:34:22 * hackage subzero 0.1.0.6 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.6 (codeshot)
09:35:25 <parks37> kuribas: In a sense, I'm trying to write a prefix to infix notation translator.
09:40:03 <rightfold> The purescript package has one.
09:48:47 <codeshot> Does this look like a reasonably sensible data type and instances for an Applicative map? https://hackage.haskell.org/package/subzero-0.1.0.6/docs/Data-Map-IMap.html#t:IMap
09:55:42 <glguy> codeshot: This won't have the right "associativity" properties for <*>
09:56:32 <ecly> glguy: 'Day 9 poses a convoluted knot...' - you should hurry and make that a 10. Truly embarrassing
09:56:35 <lyxia> beaky: They're not at all the same thing. Dependent types: types depend on values. HoTT: types are topological spaces.
09:57:01 <glguy> ecly: fixed!!!
09:57:37 <ecly> glguy: damn. What a day. I contributed to glguy's aoc2017 repo.
09:58:03 <glguy> That wraps up Sunday; go ahead and head to bed :)
09:58:32 <ecly> Probably should. Can only be downhill from here! Clearly the peak.
09:59:45 <codeshot> glguy, blast
09:59:54 <codeshot> glguy, thanks
10:00:45 <glguy> ecly: Are you on our #haskell leaderboard under a different name than "ecly"? Does it link through to your solutions?
10:01:20 <codeshot> glguy, I can't imagine what the problem is
10:01:37 <cocreature> hm maybe I should make my solutions public as well
10:01:43 <cocreature> but they’re pretty boring anyway :)
10:01:45 <codeshot> I'm trying to think of an example for it failing
10:02:38 <infinisil> Whoa, I totally forgot about guards, haven't ever used them in my Haskell project :o
10:03:03 <glguy> codeshot: let f x = fromList [((),x)] in (f 1 *> f 2) *> f 3 == f 1 *> (f 2 *> f 3)
10:03:11 <codeshot> ta
10:04:31 <ecly> glguy: I didn't realize there was a #haskell leaderboard. I've only done 3 of them in Haskell. I went for the 'a bunch of different languages' approach
10:05:02 <codeshot> glguy, *Control.Applicative.SubZero Data.Map.IMap> let f x = fromList [((),x)] in ((f 1 *> f 2) *> f 3) == (f 1 *> (f 2 *> f 3))
10:05:02 <codeshot> True
10:05:08 <codeshot> isn't that correct?
10:05:27 <codeshot> oh, no
10:05:37 <glguy> Oh, I misunderstood what you were doing, my example is probably invalid
10:05:53 <codeshot> it's supposed to be equivalent to f 2 == f 3 
10:05:55 <glguy> let's try a diffreent one
10:06:12 <codeshot> so you're right
10:07:05 <glguy> OK, I think that we might be able to find a failure in how you implemented pure and its interactions, then
10:07:38 * glguy ponders...
10:07:59 <glguy> I need to think now. I originally interpreted what it was doing as removing conflicting keys (for some reason)
10:08:57 <frustrulo> COSmith123456789
10:09:01 <codeshot> I'm just treating existing keys as Identity wrt to each other, pure as a value that is present for any key that might show up, and missing keys always stay missing
10:09:16 <codeshot> I'm sure that it's pretty difficult to have got associativity wrong with that
10:09:24 <glguy> I see what it's doing now and I don't have any problems in mind
10:09:49 <glguy> pure x acts like a map where x is the value stored at all keys
10:13:32 <glguy> cocreature: Yes, easy access to solutions is one of the primary benefits to the leaderboard :)
10:13:46 <glguy> that and seeing how many people are keeping up with it each day
10:14:45 <ecly> I only just today found out that I could see how fast people on the leaderboard had submitted their solutions. Absurd speeds
10:14:49 <glguy> codeshot: I would restruture your typeclass instances not to need Flexible* , however
10:15:33 <ecly> glguy: Is your current day4 the same solution that you threw together in 1min~
10:15:56 <glguy> ecly: Yes, if you delete the comments and type signatures
10:16:15 <glguy> and I originally edited part 1 into part 2
10:16:23 <glguy> and then afterward went back and recreated part 1
10:16:36 <glguy> and then I changed the names to be more than a letter or two
10:16:43 <glguy> but other than that , yes :-p
10:16:58 <ecly> Would've liked to stand behind you (creepy) for that minute. Not a lot of room for typos :D
10:17:02 <codeshot> glguy, how come I should avoid Flexible* ?
10:17:40 <codeshot> I'd like to be general (I stopped short because the various Map types don't have a typeclass for intersectionWith but I wanted to get some feedback right away)
10:17:57 <glguy> codeshot: 1) it will allow you to better factor out the code so that the IMap Either logic doesn't get interleaved into every instance for each map type you add
10:18:15 <glguy> 2) you should avoid flexibleinstances whenever possible, they make class resolution messier
10:18:28 <glguy> and in this case it's easy to factor out, so worth doing
10:18:33 <codeshot> But it's decidable isn't it?
10:18:43 <codeshot> I'm avoiding UndecidableInstances
10:18:52 <glguy> That's fine, it's still worth avoiding
10:19:03 <glguy> You'd make your own Intersection class and your Applicative instance would use that
10:19:11 <codeshot> I still don't understand why, what's the complete tradeoff ?
10:19:23 <codeshot> Regarding avoiding FlexibleInstances
10:19:26 <glguy> otherwise any time someone wants to add a map instance they have to totally replicate the imap logic
10:19:37 <codeshot> Oh I see
10:19:53 <glguy> FlexibleInstances are just typically a sign you structured things wrong
10:19:58 <codeshot> yeah, I wanted to use m instead of Map but I stopped short due to the missing typeclass
10:20:08 <glguy> makes messier contexts, your users end up needing to pass that messiness through
10:20:15 <codeshot> do we sound like we're in agreement now?
10:20:38 <glguy> sure ;)
10:20:42 <codeshot> smashing
10:27:35 <glguy> codeshot: http://lpaste.net/360667
10:29:32 <glguy> Oh, and then: imapFromList :: IsMap m => [(Key m, v)] -> IMap m v; imapFromList = IMap . Right . fromList
10:38:55 <codeshot> I avoided pointfree style there deliberately
10:39:25 <glguy> OK, I don't care about that part, I just omitted the fromList function in my paste
10:39:43 <glguy> and then editted it back in
10:40:01 <codeshot> Seeing many function cases of the form "f (Ctor u) (Ctor v) = Ctor (u `x` v)" where going into the destructed form and coming back out look the same to the eye is really nice
10:40:43 <codeshot> then having a few like "g u = Ctor (x u)" keeps the mind in the functorial frame of mind
10:41:44 <codeshot> oh I see
10:41:45 <codeshot> cool
10:41:55 <codeshot> nice structure in that paste
10:42:55 <codeshot> I'll add your copyright to the relevant module source file
10:43:15 <slackman> is there a way to use variables as field names in "update record by field name" syntax?
10:43:20 <codeshot> It's GPLv2 until someday when people laud my name and worship my binaries
10:43:22 <slackman> I mean this <http://lpaste.net/360672>
10:43:29 <glguy> slackman: no
10:43:35 <slackman> :disappointed:
10:43:43 <codeshot> slackman, using Lens and template haskell
10:43:53 <theduke> hey there. I'm browsing https://wiki.haskell.org/Command_line_option_parsers, and there are quite a few choices. Any recommendations for a good pick that supports nested subcommands ?
10:44:01 <codeshot> I found that Lens sucked me into a black hole of confusion though, so I'd suggest keeping it light
10:44:37 <slackman> ya it looks pretty confusing
10:44:40 <glguy> slackman: field names don't exist at runtime
10:44:52 <codeshot> haha, British English can be funny ~~> light = optical momentum exchange or lesser weight :)
10:45:15 <codeshot> slackman, it seems to be a reimplementation of C structures
10:45:18 <codeshot> in haskell
10:46:12 <codeshot> with the haskell typesystem adding millions of tiny shards of optical glass to the air where your working code used to be
10:46:48 <slackman> if I use lenses can I still use the old way of accessing the fields? i.e. the same old accessor functions
10:46:53 <codeshot> slackman, I just realised I misread your question
10:47:04 <codeshot> lenses probably isn't it
10:47:16 <slackman> oh
10:47:29 <codeshot> slackman, you can use template haskell directly
10:47:53 * hackage generic-lens 0.5.0.0 - Generic data-structure operations exposed as lenses.  https://hackage.haskell.org/package/generic-lens-0.5.0.0 (kcsongor)
10:48:11 <codeshot> this will allow you to generate the necessary case statements mapping strings to fields with only a small amount of code
10:48:25 <codeshot> I think that's really what you're looking for
10:48:45 <fakenullie> can't you just use map
10:48:49 <codeshot> but you need to think about how you'll handle what happens when a user gives a field name that doesn't exist
10:48:51 <parsnip> "just <do this thing>" is starting to get on my nerves when i see it.
10:49:29 <parsnip> sort of reminds me of this missionary that was meeting someone at the next table over that said "actually" about every third word.
10:49:48 <parsnip> oops, coincidence that it appears two lines up
10:49:49 <codeshot> fakenullie, but Maps aren't typechecked so all code becomes loose
10:50:09 <fakenullie> codeshot: how are you going to typecheck acess by variable name?
10:51:04 <codeshot> fakenullie, you would use read - that's in the runtime shim
10:51:08 <parsnip> whoa, what channel am i on man
10:51:11 <codeshot> the core code gets to stay clean
10:51:42 <codeshot> I think slackman could be looking at some quite reasonable design choices depending on the application
11:06:37 <slackman> cool I will look into template haskell
11:07:47 <woodson> anyones knows how to set server certificate and key with servant https://hackage.haskell.org/package/warp-tls-3.2.4/docs/Network-Wai-Handler-WarpTLS.html#t:TLSSettings using tls
11:07:55 <woodson> i keep on getting key not found
11:08:29 <woodson> i putted my key as an env var
11:08:52 <woodson> but I keep on getting key not found using tlsSettingsMemory
11:10:43 <Gurkenglas> > (if 5 > 3 then _1 else _2) %~ (+20) $ (100, 200) -- slackman, lens fits your usecase exactly.
11:10:45 <lambdabot>  (120,200)
11:10:57 <clipcomp> you people should be shot and shot to death violently and tortured for refusing to accept somebody's hard work not business related at all and completely unrelated to anybody who works with anyone else like a group and is alone and not spamming
11:15:34 <Gurkenglas> slackman, for terminology: A record field can be witnessed by a lens (you can get it and set it). A constructor can be witnessed by a prism (you can construct with it and match on it). Something that's a lens and a prism is an iso (it can convert back and forth). Something that's a lens or a prism is an affine traversal (you can get a value if one is there, and you can put one in if there was already space for 
11:15:34 <Gurkenglas> one.). An affine traversal targets 0 or 1 slots, a traversal targets any nonnegative whole number of slots.
11:16:18 <MarcelineVQ> clipcomp is perhaps not doing well with AoC
11:19:22 <Gurkenglas> iso, lens, prism and traversal are some of the types of optics and are implemented as turning small actions into big actions, where "action" is exactly as general as the type of optic allows. This allows optics to be composed as functions, and to be generalized to less powerful optics implicitly.
11:28:33 --- mode: ChanServ set +o glguy
11:28:33 --- mode: glguy set +q clipcomp!*@*
11:50:26 <tsahyt> I've come across some code using vector that works with -O0 but segfaults with -O2 and does not use anything that is unsafe (afaik). https://gist.github.com/tsahyt/0403cfdba4fca8c0022b35a50e6d5ff1
11:50:41 <tsahyt> or rather, I've written it. but I can't figure out why this would segfault, it really shouldn't
11:50:57 <tsahyt> it's advent of code day 10, in case anyone needs a spoiler warning
11:53:31 <martinmch> tsahyt: Coming across code is not the same thing as writing that code yourself.
11:55:34 <tsahyt> point taken, but I still can't see why this would segfault, and I find this somewhat worrying
11:57:31 <Gurkenglas> What inputs segfault?
11:58:25 <glguy> tsahyt: There's a bug in vector: V.enumFromTo minBound maxBound
11:58:30 <glguy> you can't use enumFromTo with maxBound
11:58:44 <glguy> https://github.com/haskell/vector/issues/188
11:59:07 <tsahyt> Gurkenglas: any input
11:59:09 <glguy> tsahyt: in the meantime I can recommend using   generate
11:59:13 <tsahyt> glguy: ah I see, thank you!
11:59:21 <tsahyt> good to see that this is a known issue at least
11:59:54 <Guest7778> how do i say "where b <- a"?
12:00:50 <glguy> Guest7778: You don't, that is part of do-notation
12:02:37 <mniip> hey glguy
12:02:41 <mniip> have you seen the fancy monoids
12:03:18 <glguy> Yes, I did! Do you want to walk me through it?
12:03:34 <mniip> do you not understand it?
12:05:11 <Guest7778> ian_andrich: how do I "let x = IOaction()"?
12:05:47 <mniip> Guest7778, you can't obtain an IO action's output outside of IO
12:07:22 <glguy> I didn't study carefully enough to understand what you were doing with semidirect
12:07:35 <Guest7778> mniip: how do you obtain it outside of do?
12:08:04 <glguy> Guest7778: You can make a new action that uses the result of an IO action via the >>= operator
12:08:26 <mniip> glguy, well it's "kind of" a semidirect product of monoids
12:08:28 <glguy> getLine >>= \ theLine -> print (length theLine)
12:08:29 <mniip> or well, monoid to a group
12:09:47 <glguy> I don't know what a "semidirect product" is
12:10:07 <mniip> I thought you'd know group theory
12:10:36 * glguy admits that he doesn't
12:10:47 <EvanR> Guest7778: youre trying to build a new IO action from an old one, there is no "outside"
12:11:01 <EvanR> its like, adding two numbers outside of ... numbers
12:11:05 <EvanR> doesnt make sense
12:12:25 <Guest7778> glguy: okay instead lets say we have "filter f x" and f has a do statement -> how do we return a Bool from f?
12:13:35 <glguy> Guest7778: You don't
12:13:45 <EvanR> is f an IO action
12:13:58 <Guest7778> glguy: how do you filter do?
12:13:59 <EvanR> thats the key 
12:14:02 <glguy> If you need to use IO to decide which elements to filter out then you will get an IO action that returns a list out the other end
12:14:04 <Tuplanolla> :t filterM -- You need something different for that, like this, Guest7778.
12:14:06 <lambdabot> Applicative m => (a -> m Bool) -> [a] -> m [a]
12:17:27 <mniip> glguy, ok. If you have two groups G and H, and a homomorphism f : G -> H, canonically extended to φ : G -> Aut(H), φ(g) = \h -> f(g) h f(g)^-1
12:17:48 <mniip> then you can construct a group whose carrier set is G x H, but whose operation is different from the direct product:
12:18:17 <mniip> (a, b) * (c, d) = (a*c, b*φ(a)(d))
12:18:44 <mniip> in particular if f is the zero morphism we recover the regular direct product
12:19:13 <mniip> proofs of associativity, identity, and finding what the inverse function is, is left as an exercise to the reader
12:19:31 <mniip> this construction generalizes to when G is a monoid, and the resulting structure is a monoid
12:19:42 <mniip> although in my case both of them really were groups....
12:19:54 <EvanR> is this for parsing
12:20:10 <mniip> EvanR, hashing
12:20:58 <mniip> the thing with this hash
12:21:16 <mniip> is that a single input number maps to a single flip in the 'vector'
12:21:19 <glguy> OK, and you just happened to hardcode this to permutations because that's what you needed?
12:21:21 <mniip> which really is a permutation of Word8
12:21:26 <glguy> not that that's required for semidirect product?
12:21:34 --- mode: glguy set -o glguy
12:21:47 <mniip> there isn't really a way to parameterize an instance by a function in haskell
12:22:02 <mniip> unless you're ready to lift the whole object into type level
12:22:18 <mniip> which seemed like a stupid idea at the time
12:22:23 <glguy> right, you'd have to use the reflection package or something
12:22:34 <mniip> hmm
12:22:37 <mniip> that's cleaner
12:22:53 <mniip> I'll rethink the semidirect instance in context of reflection
12:23:15 <glguy> I'm not trying to change the code, just to understand what part of the code is specific to the problem and what is part of the general semidirect product construction
12:23:25 <mniip> yeah no
12:23:27 <mniip> this isn't general
12:23:54 <mniip> in this case f=roll
12:24:02 <mniip> roll is a monoid (group) homomorphism
12:25:04 <mniip> anyway,
12:25:15 <mniip> if you kind of squint,
12:25:22 <glguy> Perm and its operations were clear
12:25:42 <mniip> hmm what was it called
12:25:45 <Guest7778> Tuplanolla: okay what about "where line = getLine >>= \theLine -> theLine"?
12:25:53 <mniip> there were 2 numbers: one for the current position and one for how much you skip
12:26:03 <Tuplanolla> That doesn't type check, Guest7778.
12:26:26 <mniip> I think I called them at and skip but they might have been named something else in the challenge text
12:26:38 <Guest7778> Tuplanolla: how to make it type check?
12:26:50 <mniip> current position and skip size
12:27:08 <mniip> if you fix the skip sizes,
12:27:09 <Tuplanolla> > getLine >>= \ theLine -> pure theLine -- If you insist, Guest7778.
12:27:12 <lambdabot>  <IO [Char]>
12:27:22 <mniip> then to hash a single character you don't really need to know all the previous characters
12:27:56 <mniip> you can take the permutation obtained by the character's value (reversal), and if there are indeed any preceding characters, you "move" that permutation to the appropriate place in the map
12:28:01 <mniip> that movement is a conjugation by a roll
12:28:22 <EvanR> though... \x -> pure x is the same as pure by itself, and getLine >>= pure is the same as getLine by the laws of monads
12:28:55 <mniip> so you make a monoid
12:29:13 <mniip> that stores both the "relative" permutation, and the skip "offset"
12:29:14 <glguy> Where's monochrom's IO tutorial?
12:29:37 <Guest7778> Tuplanolla: is there a way to just ignore type checking?
12:29:41 <Tuplanolla> @where io
12:29:41 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
12:29:41 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
12:29:42 <MarcelineVQ> glguy: http://www.vex.net/~trebla/haskell/IO.xhtml
12:29:51 <glguy> Guest7778: You might try reading that ^
12:29:54 <mniip> mempty would evidently be the hash of the empty string (we're not including salting here), so
12:30:01 <glguy> Guest7778: If you ignore type checking then the program would just crash at runtime
12:30:21 <mniip> that, intuitively, should bring an understanding of how to "make sense" of this object
12:31:01 <mniip> you should do whatever with it such that if you did that same thing to mempty you would obtain the round state for having done no rounds
12:31:18 <Guest7778> glguy: what's the difference between m0 Bool and Bool? I don't think it should crash
12:31:45 <glguy> Guest7778: You have some reading to do. In general the two are unrelated
12:32:01 <EvanR> data Bool = True | False
12:32:10 <mniip> initially current position = 0, and permutation is the identity permutation
12:32:41 <EvanR> IO Bool is an IO action returning Bool
12:32:47 <mniip> a value like 'Semidirect n p' means that whatever rounds were executed, if they were the first to get executed, we'd obtain current position n, and vector p
12:32:49 <EvanR> which is not a Bool
12:32:53 * hackage atomic-primops 0.8.1.1 - A safe approach to CAS and other atomic ops in Haskell.  https://hackage.haskell.org/package/atomic-primops-0.8.1.1 (ryanglscott)
12:33:03 <mniip> now if they weren't the first to get executed...
12:33:38 <glguy> mniip: I'm getting pulled away to prepare lunch, but with this new understanding I plan on looking over the code again later today
12:34:33 <mniip> this is where mappend steps in
12:34:41 <mniip> hope you can see what Semidirect's mappend does now
12:45:07 <Guest7778> Tuplanolla: how to do "where line = getLine >>= \ theLine -> pure theLine" but for "where time = utcToLocalTime theZone theTime" where theZone and theTime are pure?
12:45:38 <Tuplanolla> You really need to read the recommended tutorial, Guest7778.
12:47:23 * hackage criterion 1.2.6.0 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.2.6.0 (ryanglscott)
12:53:44 <tsahyt> @hoogle Monad m => Int -> (a -> m a) -> a -> m a
12:53:45 <lambdabot> Control.Monad.HT nest :: (Monad m) => Int -> (a -> m a) -> a -> m a
12:53:45 <lambdabot> Statistics.Function for :: Monad m => Int -> Int -> (Int -> m ()) -> m ()
12:53:45 <lambdabot> Statistics.Function rfor :: Monad m => Int -> Int -> (Int -> m ()) -> m ()
12:54:35 <Guest7778> Tuplanolla: I'm having enough trouble with map and filter and fold :z
12:55:25 <Guest7778> Tuplanolla: I didn't know there was M variants
12:55:56 <mniip> tsahyt, \i f x -> iterate (>>= f) (return x) !! i
12:56:02 <mniip> terrible performance warning though
12:56:36 <tsahyt> why the terrible performance? because of the list index?
12:56:45 <tsahyt> I'd imagine this would fuse somewhat reasonably, no?
12:56:53 <mniip> iterate is lazy
12:57:05 <mniip> if i is large you will accumulate a large thunk first
12:57:10 <mniip> which will then be unraveled
12:57:13 <Guest7778> Tuplanolla: for example "filterM f x" caused problems for f and x 
12:57:16 <tsahyt> ah I see
12:57:32 <mniip> also the fact
12:57:48 <mniip> that the monad "interpreter" doesn't see the first f until iterate is done doing that
12:57:51 <tsahyt> mniip: I sometimes use something like head . dropWhile condition . iterate f, which I assume does not have that problem since it evaluates in every step to check the condition 
12:57:59 <mniip> yes
12:58:09 <Guest7778> Tuplanolla: I think f "Couldn't match type ‘Char’ with ‘[Char]’" and x "Couldn't match type ‘[Char]’ with ‘Char’"
12:58:16 <mniip> really just
12:58:33 <tsahyt> mniip: so here it'd likely be beneficial to add a bang to x? https://gist.github.com/tsahyt/17ea10213dfbb56349cd1a5b1a06135d#file-advent10-hs-L41
12:58:47 <mniip> loop 0 f x = return x; loop n f x = f x >>= loop (n - 1) f
12:58:57 <mniip> with most monads this will start executing fs right away
12:59:41 <mniip> ooh AOC
12:59:50 <mniip> wait till you see my monoid transformer solution :p
13:00:29 <mniip> ooh
13:00:35 <mniip> lazy state is different though
13:00:56 <mniip> lazy state and iterate click together even less
13:01:15 <tsahyt> there's no reason why I need lazy state here, it's just the default module for me to import
13:01:39 <mniip> did you know lazy state executes backwards
13:01:59 <tsahyt> backwards how?
13:02:00 <mniip> > runState (do undefined; put 3; return 5) undefined
13:02:02 <lambdabot>  (5,3)
13:02:27 <tsahyt> that does explain why I didn't get traces when I was debugging that vector problem
13:02:27 <mniip> this is just the direct result of the laziness of >>=
13:02:30 <mniip> this is the type of stuff that keeps me up at night
13:03:13 <tsahyt> this monoid transformer talk made me curious though. first, what is a monoid transformer?
13:03:31 <mniip> Monoid1
13:03:49 <mniip> an abstract datatype parameterized by a monoid which is itself a monoid
13:03:58 <tsahyt> I see
13:04:22 <mniip> simplest example including
13:04:38 <mniip> data Sequenced a b = Sequenced a (a -> b)
13:04:43 <mniip> mempty = Sequenced mempty (const mempty)
13:04:43 <mniip> mappend (Sequenced a af) (Sequenced b bf) = Sequenced (a <> b) (\p -> af p <> bf (a <> p))
13:05:21 <Guest7778> Tuplanolla: no wait I fixed it by removing the M because I removed the do so now I just need to make TimeZone and UTCTime into IO TimeZone and IO UTCTime so is there an IO() function?
13:05:38 <tsahyt> mniip: huh, I'll have to read into this
13:05:42 <Tuplanolla> Yes, `pure`, Guest7778.
13:05:49 <mniip> I'm afraid there's nothing to read
13:06:12 <mniip> if there's existing work on this topic I haven't seen any
13:06:57 <[exa]> there's a paper by Jaskelioff&Moggi from like 2010
13:07:01 <tsahyt> that might explain why I haven't heard of it so far
13:07:04 <mniip> dammit
13:07:09 <mniip> late by a single digit number of years again
13:07:30 <[exa]> "
13:07:51 <Guest7778> Tuplanolla: how do you do unpure like unwords and unlines?
13:08:04 <Tuplanolla> Generally that's impossible, Guest7778.
13:08:08 <[exa]> mniip: anyway, do you know about some common patterns where e.g. Sequenced helps?
13:08:23 <mniip> advent o code
13:08:28 <mniip> wouldn't call it common per se but
13:08:49 <tsahyt> mniip: is your monoid transformers solution online somewhere?
13:09:05 <mniip> [exa], my aoc solution today involved writing a char-to-monoid function
13:09:11 <mniip> so that hashing a string is just a foldMap
13:09:14 <mniip> http://lpaste.net/360659
13:10:29 <mniip> and now glguy suggested I rewrite it around a bit
13:10:35 <mniip> with a more general semidirect
13:10:46 <tsahyt> I think that'll do for reading on monoid transformers then
13:10:51 <tsahyt> the concept is simple enough I suppose
13:11:03 <tsahyt> seeing an application might help understand it
13:12:35 <[exa]> mniip: yeah that looks great
13:12:37 <[exa]> thanks :]
13:12:55 <mniip> basically I need a group class
13:13:07 <mniip> which there is none of in base
13:14:16 <[exa]> for getting the inv into semidirect I guess?
13:14:36 <mniip> yes
13:14:41 <mniip> and roll could be reflected
13:15:19 <Guest7778> Tuplanolla: this is all I want to do "(year,month,day) = ((getCurrentTimeZone,getCurrentTime) >>= \x y -> toGregorian $ localDay (utcToLocalTime x y))"
13:15:35 <mniip> :t reflect
13:15:37 <lambdabot> error: Variable not in scope: reflect
13:15:39 <mniip> I guess not
13:17:20 <MarcelineVQ> reflect as in Refl? or some other subject?
13:18:58 <mniip> data.reflection
13:20:08 <tsahyt> mniip: does mempty for Perm Word8 materialize the whole Map?
13:20:11 <MarcelineVQ> reflection vs reflexiv  how do you people keep track of everything :X
13:20:12 <Guest7778> Tuplanolla: how about this "(year,month,day) = toGregorian $ localDay (utcToLocalTime getCurrentTimeZone getCurrentTime)"?
13:20:16 <mniip> tsahyt, yes
13:20:50 <tsahyt> ah okay. for bigger types than Word8 it'd be nice to have a more sparse representation for permutations I suppose
13:23:07 <mniip> tsahyt, I'm not sure
13:23:17 <mniip> the permutations we get aren't "sparse"
13:23:37 <mniip> vector would be the best representation
13:23:38 <tsahyt> mniip: no I mean as a general purpose permutation type
13:23:44 <mniip> well that's Endo
13:23:45 <tsahyt> not just for AoC
13:23:53 <tsahyt> oh, true
13:24:49 <qmm> is there a way to get the src command from lambdabot within ghci without installing lambdabot or is there a way to install an older version of ghc with cabal? i haven't been able to install lambdabot for a long time: https://github.com/lambdabot/lambdabot/issues/160
13:26:13 <benzrf> well, src is based on a hardcoded table anyway
13:26:19 <MarcelineVQ> you can make a custom ghci command that would do that but you can also just open the src file if you want those particular definitions
13:26:23 <MarcelineVQ> @where src
13:26:23 <lambdabot> The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
13:26:41 <EvanR> Guest7778: that doesnt type check
13:26:42 <Guest7778> Tuplanolla: nevermind I did it by moving it into the main do and just funnelling it down through the pattern matching
13:27:05 <EvanR> you tried to apply the functions to IO actions which get the current time
13:27:21 <EvanR> but the functions dont take IO actions
13:27:31 <qmm> benzrf: that's surprising. i thought it would somehow look up the module on hackage
13:28:49 <benzrf> nope
13:28:53 <benzrf> dissapointingly!
13:29:23 * hackage subzero 0.1.0.8 - Helps when going "seed values" -> alternatives and optional -> answers  https://hackage.haskell.org/package/subzero-0.1.0.8 (codeshot)
13:29:28 <benzrf> @src (.=)
13:29:28 <lambdabot> Source not found. Do you think like you type?
13:29:31 <benzrf> :t (.=)
13:29:32 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
13:29:32 <Guest7778> EvanR: the guide I used had "do\nnow <- getCurrentTime\ntimezone <- getCurrentTimeZone\nlet zoneNow = utcToLocalTime timezone now\nlet (year,month,day) = toGregorian $ localDay zoneNow" but I was trying to filter it instead of doing it in main and passing it through the composition
13:29:48 <codeshot> That's enough for today I think. glguy, thanks for the help earlier
13:29:59 <benzrf> qmm: actually, lmk if you find something that can do that automatically... :)
13:30:36 <EvanR> you could also getZonedTime
13:31:01 <Guest7778> world: I don't think reading that tutorial would've helped
13:31:32 <Tuplanolla> @let signed2Area = sum . (zipWith det2 <*> drop 1 . cycle) where det2 (x, y) (z, w) = x * w - y * z -- What do you reckon would be the best way to adapt this for vectors?
13:31:35 <lambdabot>  Defined.
13:32:24 <EvanR> world: hello
13:35:56 <world> EvanR: hello
13:36:20 <codeshot> slackman, I just saw this: https://hackage.haskell.org/package/generic-lens
13:36:21 <EvanR> exhilirating
13:36:48 <codeshot> looks like ghc 8 added a feature that lens uses to do pretty much what it sounded like you were looking for, all on the nice edge of lenses
13:44:38 <Gurkenglas> codeshot, how's that closer to what he wants than just using lens directly?
13:52:00 <slackman> what does the '@' mean in their examples?
13:52:12 <slackman> it looks like using lenses is easier than using template haskell
13:55:13 <hexagoxel> under which circumstances is glibc required for compiling haskell packages (not ghc itself)?
13:56:19 <hexagoxel> maybe for primitive stuff?
13:58:26 <codeshot> Gurkenglas, it minimises the coding and maximises the regularity
14:11:14 <horatiohb> I find GHC to consume an inordinate amount of RAM. Others experienced the same problem more than a year ago and have complained again as recently as a month ago. Is a fix on the horizon?
14:12:53 * hackage wai-middleware-rollbar 0.7.0 - Middleware that communicates to Rollbar.  https://hackage.haskell.org/package/wai-middleware-rollbar-0.7.0 (joneshf)
14:15:12 <mniip> horatiohb, that's too general
14:15:24 <mniip> haskell is a memory-hungry language with no universal bandaid
14:15:39 <mniip> 1512944083 [01:14:43] <mniip> horatiohb, that's too general
14:15:39 <mniip> 1512944095 [01:14:55] <mniip> haskell is a memory-hungry language with no universal bandaid
14:16:28 <pta2002> is there any function that will split a list into a list of lists of a specific length
14:16:55 <pta2002> like, I have this list: [a,b,c,d] and I ask for lists of length 2 and get [[a,b],[c,d]]
14:17:11 <erisco> :t chunksOf
14:17:12 <lambdabot> Int -> [e] -> [[e]]
14:17:17 <pta2002> thanks
14:18:49 <pta2002> is there any version of that for a Vector?
14:19:26 <horatiohb> mniip: thanks. In that case I assume the memory consumption is proportional (not necessarily linearly) to the size of the program. But is there a general rule of thumb for how big a machine to provision for reasonably prompt compilation?
14:20:20 <horatiohb> (by "how big a machine" I obviously mean "how much memory")
14:21:34 <erisco> to the size of the program? not at all
14:22:02 <horatiohb> erisco: can you elaborate?
14:22:16 <erisco> the size of a program has nothing to do with how much memory it uses
14:22:56 <horatiohb> erisco: to be clear: are you saying the size of a program has nothing to do with how much memory ghc uses to compile it?
14:23:03 <erisco> only to the extent that we're talking about the static memory, not stack or heap
14:23:34 <erisco> sorry I thought you were talking about running Haskell programs
14:23:41 <horatiohb> np
14:24:28 <erisco> good chance you use more memory the more fancy type level programming you have going on
14:27:21 <pta2002> how do I xor?
14:27:38 <pta2002> I found https://hackage.haskell.org/package/AC-Boolean-1.1.0/docs/Data-Boolean.html this, but Data.Boolean doesn't seem to be available
14:35:09 <peutri> pta2002: are you looking for https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Bits.html#v:xor ?
14:35:19 <pta2002> yep, I've found it already, thanks
14:35:28 <aplainzetakind> In the output [(a,String)] of readsPred, what's the role of String? I suppose I'd be wrong to implement it to return [(result,"")] if the entire input makes sense and [] otherwise.
14:37:51 <codeshot> Does haddock have a way to generate and crosslink documentation elements via code embedded into comments?
14:38:25 <codeshot> I've seen https://hackage.haskell.org/package/diagrams-rubiks-cube-0.3.0.0/docs/Diagrams-RubiksCube-Draw.html which looks a bit like it might but I see that the svg files are pre-generated
14:38:57 <codeshot> I'd like to be able to do stuff like that but via pure code where haddock controls all file and URL creation
14:40:14 <jle`> aplainzetakind: i think it's supposed to be the leftovers?
14:40:23 <jle`> but i've never gotten any actual things from it
14:41:03 <jle`> aplainzetakind: i think it's used in the implementation, for ReadP
14:41:10 <jle`> but actual readsPrec's you see might not use it
14:41:34 <jle`> @tell pja I rewrote it using Word8 instead of custom forks!
14:41:34 <lambdabot> Consider it noted.
14:43:00 <byorgey> codeshot: diagrams-rubiks-cube is using http://hackage.haskell.org/package/diagrams%2Dhaddock
14:43:27 <byorgey> which lets you describe images using Haskell code embedded in comments
14:43:36 <byorgey> I don't know if that's specifically what you're looking for.
14:44:07 <slackman> if I try to use a list of lenses in the type signature, ghc gives me "GHC doesn't yet support impredicative polymorphism"
14:44:10 <slackman> what's up with that
14:44:28 <slackman> on the line "doit2 :: [Lens' Foo Int] -&gt; Foo -&gt; Foo"
14:44:41 <jle`> slackman: it's because Lens' is actually a type synony for a RankN type
14:44:45 <jle`> *type synonym
14:44:56 <jle`> which aren't allowed as type parameters to type constructors like lists
14:45:26 <pta2002> how do I pad showHex to always show 2 characters
14:45:29 <aplainzetakind> jle`: In ghci, `readsPred 0 "5foo" :: [(Int, String)]` does return [(5,"foo")], so I suppose it's good form to implement it that way.
14:45:45 <jle`> slackman: you should use ALens' instead of Lens'
14:46:19 <jle`> slackman: ALens' uses a specific instantiation for the rank-n type variable in the Lens' type synonym
14:46:39 <jle`> so it can be used as a type parameter
14:46:50 <aplainzetakind> I of course have no idea how the integer argument is supposed to be used, but that's probably not too critical.
14:47:42 <jle`> pta2002: left-pad
14:47:46 <jle`> just kidding
14:47:52 <jle`> pta2002: use printf "%02x" instead :)
14:47:57 <pta2002> jle`: i'm trying
14:48:05 <pta2002> but can't seem to get it to return a string?
14:48:12 <pta2002> just prints it and returns ()
14:48:15 <jle`> > map (printf "%02x") [0..]
14:48:18 <lambdabot>  error:
14:48:18 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M757743872908...
14:48:18 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
14:48:22 <jle`> > map (printf "%02x") [0..] :: [String]
14:48:25 <lambdabot>  ["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e",...
14:48:44 <jle`> pta2002: ah yeah printf is polymorphic so you have to specify the return type you want
14:48:52 <jle`> if you ask for a String, it'll return a String
14:49:01 <jle`> it's kind of some twisted polymorphism
14:49:37 <jle`> if you ask for the result as an IO (), it'll print it and return ()
14:49:54 <jle`> i think it's overloaded like that for convenience, so people can use the same function to print things and also to make strings
14:49:55 <pta2002> thanks
14:50:01 <jle`> but it can mess with the typechecker for sure
14:51:29 <jle`> > printf "%02x" =<< (randoms (mkStdGen 92345) :: [Word8])
14:51:31 <lambdabot>  error:
14:51:31 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M264302642534...
14:51:31 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
14:51:36 <jle`> > printf "%02x" =<< (randoms (mkStdGen 92345) :: [Word8]) :: String
14:51:38 <lambdabot>  "0c3071c664fd1ba193b38003ccc3079709bcad0077eb2a1092cb9eb346adb6af264b03663c5...
14:52:23 <slackman> thanks jle`
14:52:26 <jle`> np!
14:57:52 * hackage github-release 1.1.0 - Upload files to GitHub releases.  https://hackage.haskell.org/package/github-release-1.1.0 (fozworth)
14:58:13 <codeshot> byorgey, thanks
14:58:15 <codeshot> it's close
14:58:41 <codeshot> I'm gonna grab haddock and see if the architecture for this facility can be improved
15:25:52 * hackage riak 1.1.2.3 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.1.2.3 (lambda_foo)
15:27:44 <slackman> if I put a lens in a variable, I can use that variable as a getter or setter but not both at the same time, why's that?
15:27:46 <slackman> <http://lpaste.net/360677>
15:31:14 <geekosaur> slackman, because haskell doesn't like existentials in that situation and will monomorphize to either a Getter or a Setter but not both
15:31:39 <geekosaur> lens has a hack for this, you can wrap it into an ALens where the existential is hiddne inside, then use other things to pull it back out and use it as Getter or Setter
15:32:07 <geekosaur> so go take a look at ALens
15:33:19 <jle`> slackman: you can imagine it as the same situation as something like `f x = (x * 2 :: Int, x / 2 :: Double)`
15:33:32 <slackman> oh
15:33:45 <jle`> the type that getters and setters expect are actually different specializations of the Lens type
15:33:45 <slackman> I solved it by putting cloneLens everywhere
15:33:56 <geekosaur> yep, that's the ALens machinery
15:34:11 <jle`> so if you use something as sa getter, it specializes to the type of getters, which is different than the type of setters
15:34:17 <jle`> slackman: the analogy here would be using fromIntegral everywhere
15:34:36 <geekosaur> and you're kinda stuck with it because the typechecker can deal with polymorphism or it can deal with existentials, but things get weird when you have both at the same time
15:34:42 <jle`> f x = (fromInteger x * 2 :: Int, fromInteger x / 2 :: Double) does work
15:34:50 <jle`> but f x = (x * 2 :: Int, x / 2 :: Double) would not
15:35:02 <slackman> I see
15:35:30 <jle`> cloneLens's input is monomorphic, it picks a "canonical" instantiation of Lens that can be converted to both Getter's and Setter's
15:35:52 <jle`> like fromInteger :: Num a => Integer -> a
15:39:41 <slackman> this makes lenses less nice than I thought it would be
15:42:58 <seafood> What's the standard library that people use for regex`s these days? 
15:43:20 <sbrg> I hardly ever use them tbh
15:43:50 <kadoban> seafood: Most avoid regex, usually by using parser combinators. If you actually need regex, not sure which are good.
15:44:12 <sbrg> parser combinators are just so great.
15:44:16 <seafood> I genuinely just want regexes. Not trying to parse a language here
15:44:27 <sbrg> that doesn't really matter though.
15:45:10 <sbrg> regex: (.*) -- haskell: between (char '(') (char ')') anyChar
15:53:28 <glguy> sbrg: It would be trouble to put anyChar there, it will eat the )
15:53:49 <glguy> depending on the parser combinator library you're using
15:54:01 <Axman6> what's the type of between?
15:54:22 <hpc> glguy: it's an accurate translation of a regex that behaves like that though ;)
15:54:42 <glguy> hpc: I don't think so
15:54:56 <glguy> a regex will allow the final ) to match and finish the expression
15:55:20 <glguy> where the parsec implementation would just return a parse error
15:56:02 <hpc> depends on the parser combinator library i suppose
15:56:22 <glguy> ReadP would find all the possible ways to stop at a ) assuming no <++ was used
15:56:27 <glguy> attoparsec would fail
15:56:36 <hpc> iirc the parser type class admits implicit backtracking
16:06:16 <slackman> is there a way to express this in point free notation, without the lambda x?
16:06:17 <slackman> Just 4 &gt;&gt;= (\x -&gt; return $ (+) 1 x)
16:06:38 <erisco> nice HTML
16:06:50 <slackman> ack, sorry
16:06:52 <slackman> my client
16:07:09 <erisco> > fmap (+1) (Just 4)
16:07:11 <lambdabot>  Just 5
16:08:28 <erisco> m >>= \x -> return (f x) ≡ fmap f m
16:08:52 <slackman> I want to use bind because I want to chain multiple unary functions
16:09:12 <erisco> what is a unary function? all functions are unary in Haskell
16:09:15 <slackman> so m &gt;&gt;= doSomething &gt;&gt;= doAnotherThing
16:09:35 <slackman> except doSomething and doAnotherThing don't return monads
16:09:36 <erisco> okay but do they all use return? then the simplification to fmap applies
16:09:59 <geekosaur> or to Applicatives in general
16:10:06 <geekosaur> (dpeending on how they fit together()
16:10:19 <erisco> okay so watch this… using the simplification I provided you can simplify multiple binds
16:10:50 <erisco> (m >>= \x -> return (f x)) >>= \y -> return (g y)
16:11:03 <Tuplanolla> > Just 42 <&> doSomething <&> doAnotherThing
16:11:05 <lambdabot>  Just 86
16:11:10 <erisco> what is the first step?  fmap g (m >>= \x -> return (f x))
16:11:22 <erisco> what is the second step?  fmap g (fmap f m)
16:11:44 <erisco> now there is an equivalence on fmap that   fmap f . fmap g ≡ fmap (f . g)
16:12:01 <erisco> so therefore  fmap g (fmap f m) ≡ fmap (g . f) m
16:13:30 <erisco> bonus is that this code is more general to Functor
16:15:52 <slackman> oh I see
16:24:48 <Unode> Can someone explain why does this code construct an infinite type http://dpaste.com/2MBVP21 ?
16:25:05 <Unode> "cannot construct the infinite type: t ~ [t]"
16:25:40 <erisco> Unode, probably because you have two different return types, but I'll take a closer look
16:26:52 <Unode> erisco: I'm getting a little confused with this data structure. This "Node" implements a Tree as (Node Pos NodeType [Node])
16:26:59 <erisco> so,  fT :: [A] -> [A]  but I don't know what A is
16:27:12 <erisco> then  fmap (fT []) x :: [A] -> [[A]]
16:27:30 <erisco> acc ++ fmap (fT []) x  by the type of ++ says  acc :: [[A]]
16:27:46 <erisco> but by the type of  fT  acc :: [A]  so now we have  [A] ~ [[A]]
16:28:24 <Unode> hum..
16:28:26 <erisco> taking some guesses here… paste all the definitions and I can see for sure
16:28:50 <erisco> I guess A = Text
16:30:16 <Unode> Sorry a little confused here...
16:30:45 <erisco> Unode, maybe add a type declaration to fT to deconfuse yourself
16:30:51 <Unode> I don't have [A] in my code but [A] should be [Text] insdeed.
16:31:00 <Unode> *indeed
16:31:26 <Unode> erisco: may I ask how you got the breakdown of each function's signature?
16:31:41 <Unode> Did you deduce yourself?
16:31:58 <erisco> yes
16:32:01 <Unode> ah ok
16:33:08 <erisco> you probably want concatMap instead of fmap
16:33:12 <Unode> I think I see the issue. I though of using fmap but this adds an extra [] around which I wasn't picturing
16:33:17 <Unode> yes, exactly
16:33:21 <erisco> :t traverse
16:33:23 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:33:37 <erisco> :t foldMap
16:33:38 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
16:33:45 <erisco> yeah that one… the more general name
16:36:13 <Unode> erisco: thanks, probably terribly inefficient but one step closer
16:37:06 <erisco> nah you should be fine… would be bad if you commuted the ++
16:37:46 <Unode> commuted? don't know the meaning of that word
16:38:06 <erisco> swap the arguments
16:38:11 <Psybur> :t (<.>)
16:38:13 <lambdabot> Indexable (i, j) p => (Indexed i s t -> r) -> (Indexed j a b -> s -> t) -> p a b -> r
16:38:25 <Psybur> @src (<.>)
16:38:25 <lambdabot> Source not found. There are some things that I just don't know.
16:38:57 <Unode> erisco: wouldn't it be the same? [a] ++ [b] .. [b] ++ [a] ?
16:39:11 <Psybur> Ok, its in Control.Lens.Indexed
16:39:14 <erisco> well, it would be the reverse order, for one
16:39:27 <Unode> ah ok
16:39:28 <erisco> but also the cost of m ++ n is the length of m
16:39:42 <erisco> so  (a ++ b) ++ c  is the cost of length a plus the cost of length (a ++ b)
16:39:57 <erisco> a ++ (b ++ c)  is the cost of length a plus the cost of length b
16:40:19 <Unode> ok then indeed this may be suboptimal since 'acc' is always growing.
16:40:26 <Unode> but I'll worry with this later
16:40:59 <Unode> A general question about ghci, is there any way to reload the code (:r) without losing references created interactively?
16:41:00 <erisco> I am saying a left-associated ++ is quadratic whereas a right-associated ++ is linear
16:42:07 <woodson> Hi guys, how do I set my server to only accept https requests?
16:42:07 <erisco> actually I guess you have a mix of things with that tree traversal
16:42:08 <Unode> I'm creating a variable in ghci that contains some test values and every time I :r the variable is removed
16:42:29 <erisco> that's right, it does that
16:42:43 <Unode> any way to prevent that?
16:42:44 <erisco> so I add my test data to the file I am working on
16:42:50 <Unode> I see
16:43:03 <Unode> and you also export that test data I guess?
16:43:21 <glguy> You don't have to export things to interact with them from GHCi in a file you're interpreting
16:43:24 <Unode> or is there some magic to export all functions/variables regardless of being specified in the module?
16:44:01 <Tuplanolla> If you want to make them permanent, consider another module that contains the tests and imports your working set, Unode.
16:44:05 <Unode> glguy: I generally use 'stack ghci' which loads all project code.
16:44:30 <Unode> Tuplanolla: it's mostly for trial and error. But I see your point.
16:44:38 <glguy> Unode: that's fine
16:45:17 <Tuplanolla> This is how `Internal` modules are usually born.
16:45:21 <glguy> even if you have to use stack you can tell stack what component to load in the repl and it will be in interpreted mode
16:45:22 <Unode> glguy: then I guess I need to tell ghci the file I want to interpret?
16:45:35 <glguy> when you select modules, add the *
16:45:39 <glguy> :m * What.Ever
16:47:04 <Unode> ok that's useful
16:49:11 <Unode> I was going to ask if there was a way to do that by default for all project modules? Even if as a qualified import?
16:49:28 <Unode> that came out as a mixed of sentences...
16:49:30 <Unode> rephrasing
16:49:38 <Unode> *mix
16:50:49 <Unode> glguy: do you know if there's any way to configure ghci (stack?) to load all project code with :m * ? I guess it's not useful to load everything under the same namespace, but at least in a way that I can Module.<TAB> non-exported functions?
16:52:20 <Unode> While I think in the code having a protection for 'private' functions, I find that when working with ghci this behavior gets in the way.
16:53:29 <mpickering> how do I view a package candidate on hackage?
16:55:20 <geekosaur> Unode, not yet but I think there's something in the works. stack or cabal can't do it itself, it has to be done at the level of ghc/ghci
16:56:28 <Unode> geekosaur: I see. Thanks for the info.
16:59:52 * hackage haskell-src-exts 1.20.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.20.0 (mpickering)
17:09:23 <Unode> geekosaur: seems like it's possible to load more than one module in * mode. e.g. :m *Main *Lib .
17:09:53 <geekosaur> it is, yes, but you have to remember to do that both then and with anything else you load
17:10:05 <geekosaur> (also even that is iirc a recentish change, sometime around 7.10)
17:10:19 <Axman6> Is anyone familliar with Thyme? I'm trying to create a UTCTime from a count of microseconds from the MJD epoch but can't find a way to do this without going through Day and DiffTime
17:10:26 <geekosaur> so it'd be nice if you had a way to force all such loads to be source loads
17:10:41 <geekosaur> ...and in fact 8.2.x has a change that effectively does that, but *over*does it
17:10:45 <geekosaur> "oops"
17:11:04 <geekosaur> and, while sometimes you realy want the source form, sometimes you really want the binary form
17:11:19 <geekosaur> and to date getting full flexibility there has been difficult with ghci
17:11:31 <geekosaur> at least without simultaneously getting maximum annoyance
17:12:20 <Unode> geekosaur: so is there any way to trigger the * mode externally? I'm not familiar with how stack loads all project code, but I wonder if it would be possible to set all modules to be loaded with * like that.
17:12:31 <Unode> (that you are aware of)
17:13:05 <geekosaur> that was what I was getting at. currently, not really. except in 8.2 there is something that will do it but only at a much higher cost (it rebuilds everything constantly) --- because it wasn't intended to have either effect
17:13:22 <geekosaur> so, currently not really. but it's being worked on
17:13:43 <geekosaur> it turns out to be a bit tricky, for a reason related to how 8.2 can be made to always do source loads but also always recompile everything
17:14:48 <Unode> sounds messy
17:14:56 <geekosaur> (the trick? always build with optmization and ghci will always prefer source loads. but it also starts to think optimized builds need to be recompiled a lot)
17:15:00 <Unode> I'm still in 8.0 though
17:15:08 <geekosaur> but this is because of a change in 8.2
17:15:46 <geekosaur> and yeh, this stuff is *messy* inside.
17:16:02 <geekosaur> and full of unintended consequences
17:19:58 <Unode> sometimes I wonder if ipython/jupyter with a haskell kernel could help here. Haven't tried that road though.
17:20:23 <geekosaur> https://github.com/gibiansky/IHaskell
17:22:20 <Unode> checking it as we speak
17:24:48 <Unode> seems quote focused on the web interface (jupyter). Not much on the command-line version. Wonder how it behaves.
17:26:34 <geekosaur> couldn't say. I finally got it instaled locally but haven't tried to do much with it yet
17:28:09 <geekosaur> iirc a lot of the problem with the command line version is that the initial work was all done on ipython which was really focused on the web one. its command line abilities were really limited, which led to the guts being redesigned into jupyter --- but the corresponding rearrangments to ihaskell's guts are harder
17:28:57 <geekosaur> otoh things like ghc iserv should help there... although it's still evolving and a moving target
17:45:06 <Unode> I'll give it a spin sometime soon. If it works well, given the scripting abilities of 'jupyter console' it might just make for a nicer user experience.
19:08:09 <Average-user> Doing AoC Tonight?
19:08:21 <Average-user> Well, if you are at night
19:08:24 <Average-user> Don't know
19:16:19 <pierrot> Hello. In line 118 of this code: https://glot.io/snippets/ew6j56tztl I need a `DivZero` but I don't know how to return it in that context.
19:18:11 <lyxia> pierrot: InterM says interp returns an Int
19:18:34 <lyxia> so if you want to return something else, you should probably replace "Int" with something else
19:21:34 <pierrot> lyxia: Hmm I can't change the signature of that function
19:22:02 <pierrot> (it's for an exercise and I'm not able to modify the signature of functions)
19:22:04 <lyxia> Oh, I guess you can use ResT
19:22:27 <pierrot> I'm not allowed *
19:23:38 <pierrot> Just `return DivZero` as I tried first doesn't work because the types don't match
19:25:03 <lyxia> pierrot: return DivZero has type m (Res a), which is just the type wrapped by ResT.
19:25:16 <lyxia> pierrot: ResT (return DivZero) :: ResT m a
19:28:32 <pierrot> lyxia: Nice, that works.
19:29:27 <pierrot> Thanks. Is there any way to avoid using `ResT` ? (using `lift` maybe?)
19:31:23 * hackage telegram-api 0.7.0.0 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.7.0.0 (klappvisor)
19:34:21 <pierrot> lyxia: why `lift DivZero` doesn't work?
19:39:33 <pierrot> looking at my lecture slides https://eva.fing.edu.uy/pluginfile.php/144182/mod_resource/content/2/monad-transformers.pdf, to avoid using `StateT $ \s -> Nothing`, my teacher makes (StateT s) an instance of `MonadTrans` and then he uses `lift Nothing`
19:39:47 <pierrot> In this case, it's almost the same
19:39:59 <pierrot> but `lift DivZero` gives me an error
19:40:07 <pierrot> maybe my definition of `lift` is wrong...
19:47:53 * hackage hasql-optparse-applicative 0.3 - "optparse-applicative" parsers for "hasql"  https://hackage.haskell.org/package/hasql-optparse-applicative-0.3 (NikitaVolkov)
19:54:55 <lyxia> pierrot: that doesn't typecheck.
19:55:09 <lyxia> pierrot: Think of the ResT transformer as adding new capabilities to the base monad m.
19:55:32 <lyxia> pierrot: lift :: m a -> ResT m a   converts actions in m into actions in ResT
19:55:52 <lyxia> but actions in m do not have the capability of throwing an error
20:01:44 <pierrot> lyxia: I see. But in the slides that I shared it's said something like we mustn't exhibit the structure of the monad ResT in the eval/interp function (slides 7, 8 and 9)
20:02:00 <pierrot> in that case, he does `lift Nothing`
20:02:54 <pierrot> (to avoid writing `StateT $ \s -> Nothing`)
20:03:26 <pierrot> you suggest me to do `ResT $ return DivZero` and that indeed works
20:03:43 <pierrot> but I'm not sure if it's right to exhibit the internals of the monad
20:05:58 <lyxia> pierrot: lift Nothing is valid if the base monad is Maybe, which has the capability of failing
20:06:58 <lyxia> pierrot: usually you define a function or typeclass to hide away the use of ResT.
20:07:46 <lyxia> pierrot: but none of the typeclasses already in your code can be used to implement "throwing DivZero"
20:10:34 <pierrot> lyxia: following your recommendations I modified my function this way: http://lpaste.net/5174197794990194688
20:11:46 <pierrot> what I'm saying is that I have `ResT $ return DivZero` and `ResT $ return (Unbound x)` and I'd like to hide away the use of ResT in some way
20:12:05 <pierrot> I thought `lift` was for that, but it doesn't typecheck
20:12:08 <lyxia> pierrot: define divZero :: ResT m a and unbound :: ResT m a
20:12:20 <lyxia> lift is not for that.
20:13:12 <lyxia> unbound :: something -> ResT m a  actually
20:15:57 <pierrot> lyxia: hmm yeah, two separate functions for that
20:18:58 <pierrot> Apart from this, I'm seeing that I do `n <- interp e1; m <- interp e2` and then depending on whether m is zero or not, I return two different things. But I think I should do `interp e1` only if m is different from zero
20:55:00 <mrkgnao> > :t bifoldr
20:55:02 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:55:09 <mrkgnao> :t bifoldr
20:55:10 <lambdabot> error:
20:55:10 <lambdabot>     • Variable not in scope: bifoldr
20:55:10 <lambdabot>     • Perhaps you meant one of these:
20:59:55 <mrkgnao> pierrot: may I have a link to the slides you're talking about?
21:00:26 <pierrot> mrkgnao: https://eva.fing.edu.uy/pluginfile.php/144182/mod_resource/content/2/monad-transformers.pdf
21:05:03 <newbie3000> hello im a newbie and i'm looking for help to conceive a simple arithmetic parser "with Parsing Expression Grammar" :)
21:05:48 <benzrf> i wonder if i could come up with some sort of pun involving parsing expression grammar and all the simons in haskell and simon pegg
21:06:32 <newbie3000> I dont know where to start
21:08:34 <boj> newbie3000: you probably won't get much out of here without specific questions
21:10:23 * hackage skylighting 0.5 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.5 (JohnMacFarlane)
21:11:20 <newbie3000> I got a school assignement, we have to implement an simple arithmetic evaluater (1+2*3 etc) and they say we have to use PEG. As I understand I should code functions to consume string char by char and backtracking when needed but I dont understand how to prioritize operations :(
21:12:20 <newbie3000> I actually could get result with some splitAt elemIndex combo but I guess that not what they want
21:17:48 <boj> do you understand what they actually want?
21:21:07 <jle`> aw man my computer crashed as soon as the challenge started today
21:21:09 <newbie3000> not really :D I probably can do what I want anyway, I just must not use libs. What's the best "PEG-like" way you could think of ?
21:21:11 <jle`> and it took me two minutes to get back online
21:23:30 <boj> newbie3000: it might help if you reread what your assignment is, i'm sure there are hints
21:23:44 <Lokathor> jle`, the secret is to already know hex math :P
21:24:03 <jle`> i do not know hex math but i know how to use a simple library hehe
21:24:08 <jle`> but i suppose it would have been faster
21:24:11 <jle`> if i was already good at hexing
21:24:17 <Lokathor> i looked it up
21:24:23 <kadoban> The secret always seems to be to tilt your head.
21:24:24 <Lokathor> i happen to know that there's a mega site all about hex math
21:25:02 <Lokathor> https://www.redblobgames.com/grids/hexagons/
21:26:48 <newbie3000> boj: I actually difficulty understand PEG, I searched but couln't find simple example.
21:27:08 <jle`> Lokathor: neat post :)
21:27:37 <Lokathor> i just wrote the CubeCoordinate quickly and got 299th place
21:29:19 <newbie3000> boj: to be exact it's not PEG I don't understand, but how to implement it in Haskell (I come from C and have an hard time thinking functional)
21:29:24 <jle`> Lokathor: nice :)
21:29:49 <boj> newbie3000: how familiar are you with algebraic data types?
21:30:11 <control_z> boj: i'm new to the *field*
21:30:36 <newbie3000> boj: tuple and stuff ? i'm good with that
21:30:44 <boj> control_z: eh?
21:30:52 <control_z> boj: it's a pun
21:33:19 <boj> newbie3000: how would you define a data type which matches the grammar you are trying to capture?
21:35:16 <newbie3000> boj: what do you mean ? a data type for one operation ?
21:35:42 <boj> newbie3000: a sum type for all operations and their values
21:37:42 * hackage simple-sendfile 0.2.26 - Cross platform library for the sendfile system call  https://hackage.haskell.org/package/simple-sendfile-0.2.26 (KazuYamamoto)
21:37:53 <newbie3000> boj: data res = (res, op, res) | Integer  and  data op = (Char, Integer -> Integer -> Integer) ?
21:39:34 <boj> newbie3000: how about - data Exprs a = Add | Div | Value a -- or similar?
21:41:03 <newbie3000> boj: damn yeah
21:43:19 <newbie3000> boj: how to define Add tho ?
21:43:53 * hackage optparse-applicative-simple 1.0.2 - Simple command line interface arguments parser  https://hackage.haskell.org/package/optparse-applicative-simple-1.0.2 (NikitaVolkov)
21:44:15 <newbie3000> boj: wouldn't it be simpler to have and operation type with a Int -> Int -> Int and two Eprs ?
21:46:32 <boj> what would that look like concretely?
21:47:23 * hackage haskeline 0.7.4.2 - A command-line interface for user input, written in Haskell.  https://hackage.haskell.org/package/haskeline-0.7.4.2 (JudahJacobson)
21:50:35 <boj> a good reason to keep operations and values separate is because it makes executing them easier. if you track ops in one list, and values in the other, you can push/pop to actually run your calculations
21:51:00 * boj is starting to remember a few tidbits from CS courses 2 decades ago
21:51:18 <newbie3000> boj: hum how would you define Add with your example ?
21:51:33 <boj> simply Add
21:51:41 <boj> and two Values
21:52:08 <newbie3000> boj: data Add = (Int, Int) ?
21:52:42 <newbie3000> boj: and you know it's an addition because, well it's "Add" ?
21:52:56 <boj> given 2 + 3 - let values = [Value 2, Value 3]; let ops = [Add]
21:53:21 <kadoban> newbie3000: That's not actually correct syntax, you'd nee something like data Add = Add Int Int  -- would be typical
21:54:28 <newbie3000> kadoban: wut ?
21:55:34 <kadoban> newbie3000: data Add = (Int, Int) -- won't work, that's not correct syntax.
21:56:10 <newbie3000> boj: oooh you would do something like Reverse Polish notation ?
21:56:17 <boj> newbie3000: exactly!
21:57:01 <boj> as long as you have more "ops" left, then you keep pushing the result back to "values"
21:57:05 <newbie3000> kadoban: i confused with type, my bad :(
21:57:55 <newbie3000> boj: isn't this not really a "functional" way ?
21:58:09 <newbie3000> boj: or do you pass values and ops as args ?
21:59:33 <boj> newbie3000: you could aim for -- data Exprs = Add Int Int | Mul Int Int
21:59:41 <boj> i'm not sure if parsing will be made easier though
22:01:16 <newbie3000> boj: how would you implement rpn ?
22:01:52 <boj> indeed
22:02:07 <newbie3000> boj: going through the string and adding to some values/ops list you then return ?
22:03:22 <boj> yeah
22:04:11 <newbie3000> and if I just defines what operators are and what values are somewhere it's PEG ? x)
22:04:34 <boj> there's numerous ways to do things of course
22:04:42 <boj> but it sounds like you are achieving the goal either way
22:05:02 <boj> turning a math expression into haskell grammar
22:10:01 <angerman> If anyone goes ahead and gives the cross compilers at http://hackage.mobilehaskell.org/ a try, I'll be around to lend a hand or two ;-)
22:10:45 <newbie3000> boj: rpn actually uses only one list ?
22:11:04 <newbie3000> boj: [Expr] with Expr like you defined earlier ?
22:11:06 <jle`> angerman: ooh excitig :)
22:11:28 <angerman> jle`: ha ;-)
22:11:42 <boj> newbie3000: i honestly don't recall, but you may be right :)
22:13:22 <newbie3000> boj: well it makes sense now ! I have to do some more researchs but now I know where to look, thanks a lot !
22:14:23 <boj> newbie3000: great, glad i could help. good luck :)
22:25:42 <angerman> jle`: ohh, and they are *relocatable*. Unpack the archive, and run the `<triple>-ghc` right from within. 
22:27:05 <cocreature> angerman: let’s see how I can break them this time :)
22:27:28 <angerman> cocreature: well. I trust, you'll find a way ;-)
22:30:10 <cocreature> angerman: “could not execute: aarch64-linux-android-clang” am I supposed to make as symlink for that?
22:30:36 <angerman> you'll need the wrappers ;-)
22:30:37 <cocreature> given that clang is multitarget iirc I’m not sure why the architecture should be in the name
22:30:44 <cocreature> ah right I forgot about those
22:31:51 <angerman> cocreature: hmm. I wonder if that could be made easier. Package the wrappers, with the compiler?
22:31:54 <angerman> guess I could do that.
22:32:01 <cocreature> “fatal error: 'math.h' file not found” huh
22:32:29 <angerman> cocreature: is the android.toolchain in the wrappers folder, properly adapted to you android NDK install?
22:33:21 <angerman> `android-toolchain.config`. It's sources in the `wrapper` to set all the Android SDK/NDK paths.
22:33:31 <angerman> if you got a better idea how to do that, I'd love to hear :D
22:34:03 <angerman> Apple ships this `xcrun` command, which does the path injection. I haven't found one for android :-/
22:35:22 <cocreature> hm seems to be correct
22:37:13 <angerman> cocreature: you can uncomment the debug line at the end of the wrapper script, it will dump the actual tool invocation to stderr
22:39:41 <cocreature> hm I don’t have includes in the directory chosen by "isysroot"
22:39:51 <cocreature> there is only a usr/lib but no usr/include
22:40:46 <kuribas> What's a good example that a C++ template or generic is more verbose than a haskell function?
22:43:07 <angerman> cocreature: hmm... strange.
22:43:47 <cocreature> angerman: it looks like there’s a new android-ndk release (16b while I have 16). I’ll see if that helps
22:44:03 <angerman> I doubt it. I think I've still 15 on my linux box.
22:44:31 <cocreature> angerman: and I assume you have a usr/include directory in whatever isysyroot points to?
22:44:45 <angerman> let's see
22:46:17 <angerman> cocreature: right. there's `usr/{include,lib}`
22:46:38 <angerman> E.g. in `/Android/sdk/ndk-bundle/platforms/android-24/arch-arm64`
22:46:40 <cocreature> alright so that is probably my problem
22:49:12 <osa1> anyone know any examples of programs that can be written with mtl-tf but not with mtl?
23:08:23 <cocreature> angerman: interesting, the ndk 15 includes include files (no pun intended) while ndk 16 does not
23:08:37 <angerman> cocreature: O_O
23:08:53 * hackage potoki 0.6.2 - Simple streaming in IO  https://hackage.haskell.org/package/potoki-0.6.2 (NikitaVolkov)
23:10:44 <glguy> osa1: It would have to be some highly contrived example that exploited the bug in GHC where it doesn't know how to transfer equalities via functional dependencies that you'll never run into
23:11:53 <glguy> http://lpaste.net/360691
23:14:36 <glguy> or something related to the desire to want to use the StateType type family when writing new type family instances
23:14:45 <osa1> glguy: interesting, thanks for the example. what do you mean by "mtl-tf isn't a thing any more" ?
23:14:48 <cocreature> angerman: maybe one should set sysroot to the directory called "sysroot" included in the ndk?
23:15:57 <angerman> cocreature: hmm... that sounds like not such a bad idea.
23:16:14 <glguy> it's unmaintained, doesn't build on current ghc
23:16:19 <angerman> cocreature: I'd be happy to have this fixed "properly".
23:17:00 <cocreature> angerman: need to do other things now but I’ll try to take a look at it later today and see what happens if I do that
23:17:31 <angerman> sure. Any help is much appreciated :D
23:18:49 <dminuoso> How do I have our bot try and convert some code into pointfree?
23:19:50 <cocreature> @pl \x -> x
23:19:50 <lambdabot> id
23:19:53 <cocreature> ^ dminuoso 
23:20:25 <dminuoso> Ah great thanks
23:40:23 * hackage hsemail-ns 1.7.7 - Internet Message Parsers  https://hackage.haskell.org/package/hsemail-ns-1.7.7 (phlummox)
23:43:01 * hackage category 0.1.2.0 - Categorical types and classes  https://hackage.haskell.org/package/category-0.1.2.0 (MatthewFarkasDyck)
