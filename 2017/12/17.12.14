00:00:32 <cocreature> koz_: yeah that should work
00:07:19 * hackage clist 0.3.0.0 - Counted list  https://hackage.haskell.org/package/clist-0.3.0.0 (MatthewFarkasDyck)
00:09:01 <mniip> RaptorJesus, basically
00:09:13 <mniip> you know fibonacci numbers right?
00:10:13 <mniip> > fmap getSum $ fix $ cons 0 . scanl mappend 1
00:10:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
00:10:18 * hackage Fin 0.2.0.0 - Finite totally-ordered sets  https://hackage.haskell.org/package/Fin-0.2.0.0 (MatthewFarkasDyck)
00:10:20 <mniip> here's your average implementation
00:10:23 <mniip> stare at it until you get it
00:14:03 <mniip> how do I latex in haddock?
00:14:06 <mniip> $$ or \(\)?
00:17:48 <jle`> \(\) is what i've used
00:18:01 <jle`> funny-ish story i was checking the documentation for a module that i know used math
00:18:10 <jle`> and i wanted to see the module documentation where i use math in
00:18:15 <jle`> so i did head ModuleName.hs
00:18:18 <jle`> and i just got language pragmas
00:18:24 <jle`> and i did head -n 100
00:18:27 <jle`> and just got imports
00:18:31 <jle`> that's haskell i guess
00:18:58 <jle`> sorry for breaking up my story over many lines, but it was the best way to achieve the dramatic effect i was looking for
00:19:32 <opqdonut> *applause*
00:19:51 <jle`> thank you
00:19:51 <mniip> *curtains close*
00:20:03 <jle`> next time I'll just use less(1)
00:21:37 <jle`> https://github.com/mstksg/backprop/blob/master/src/Numeric/Backprop/Op.hs module i was looking at, if anyone was curious
00:21:51 <koz_> OK, figured out why I was allocing All The Memory.
00:22:06 <koz_> It turns out that I was accidentally an enormous list needlessly.
00:22:08 <jle`> but it doesn't actually have as many imports as most of my haskell modules
00:22:16 <EvanR> verb please
00:22:42 <mniip> why would you verb
00:22:49 <koz_> Exactly.
00:22:51 <EvanR> accidentally consuming? 
00:22:57 <EvanR> indexes
00:22:59 <EvanR> indexing
00:22:59 <koz_> EvanR: Accidentally materializing.
00:22:59 <EvanR> what
00:23:12 <EvanR> how
00:23:15 <jle`> mniip: \( \) for inline math, \[ \] for block math
00:23:23 <mniip> I'm used to $$ :(
00:23:51 <RaptorJesus> mniip, it's on a sticky note
00:24:03 <jle`> i mean, if it's haddock, it can't be easy :)
00:25:10 <DarkUnicorn> good to know that it's "normal" to have such a long header (imports...). I thought I was doing something wrong.
00:26:02 <mniip> DarkUnicorn, I was doing some competitive programming lately, and I've prepared a large list of imports so that I could get to writing the code quickly
00:26:09 <mniip> I only could get together 43 imports
00:26:45 <DarkUnicorn> "only" :)
00:26:50 <jle`> i mean, the ideal haskell source file is
00:26:56 <jle`> 25% language pragmas
00:26:58 <jle`> 50% imports
00:27:00 <jle`> 25% code
00:27:04 <jle`> (by line)
00:27:13 <EvanR> :(
00:27:16 <mniip> what
00:27:20 <mniip> I put my pragmas on two lines
00:27:35 <koz_> jle`: Lol, that sounds about right.
00:27:50 <jle`> mniip: harder to add and delete them that way, isn't it?
00:27:57 <mniip> why delete
00:28:00 <RaptorJesus> mniip, gn bb
00:28:02 <EvanR> {-# LANGUAGE JustAssumeDammit #-}
00:28:08 <EvanR> import Everything.I.Need
00:28:18 <jle`> sometimes i add something but i refactor out the need for it
00:28:37 <jle`> a lot of pragmas are somewhat situational
00:28:41 <koz_> {-# LANGUAGE ItWorksSrsly #-}
00:28:55 <EvanR> extension inference
00:29:03 <jle`> TupleSections, LambdaCase, MultiWayIf are ones that i often put in and out
00:29:46 <mniip> oh hmm
00:30:43 <jle`> sometimes ViewPatterns
00:30:46 <mniip> %% :show imports
00:30:47 <yahb> mniip: http://qp.mniip.com/y/11
00:30:49 <mniip> this has a longer import list
00:31:16 <mniip> mostly ripped off from lambdabot's pristine
00:32:50 <jle`> so far in AoC i've had an average of 9 imports per day, after cleaning up my code
00:33:43 <jle`> i'd tell you how many unique imports but i'm not very good at grep
00:35:52 <glguy_> Any chance that's easy to run/compute on my repo? (Stuck on phone, but curious)
00:36:41 <mniip> hmm
00:36:42 <jle`> um i just grep -Ri "^import" | wc -l and then divide by 14
00:36:48 <mniip> this code uses ScopedTypeVariables
00:36:58 <mniip> I guess I gave up on not using them then
00:37:12 <jle`> i know you tried very valiantly
00:37:24 <mniip> forall r b q p m. 
00:37:26 <mniip> yeah nah
00:37:30 <opqdonut> I haven't used any LANGUAGEs in AoC
00:37:39 <jle`> i use ViewPaterns a lot for parsing
00:37:51 <jle`> parse (words->a:b:c:d:e:_) = ...
00:38:09 <mniip> and that differs from words@(a:b:c:d:e:_) ?
00:38:11 <mniip> oh
00:38:14 <mniip> words as the function
00:38:16 <opqdonut> 2.4 imports per day on everage
00:38:34 <opqdonut> I just write "parse = p . words where p [a,b] = ..."
00:38:37 <jle`> i use ViewPatterns and LambdaCase a lot to avoid having to pick dummy variable names
00:38:47 <mniip> (\(a:b:_) -> ...) . words
00:39:11 <mniip> I wish there was a better way
00:39:12 <mniip> but alas
00:39:15 <jle`> ViewPatterns is superior obviously :)
00:39:22 <mniip> I can't bother to refactor this into a let
00:39:25 <jle`> just just superior, but superiest
00:39:31 <mniip> superiand
00:39:48 <koz_> This here program eats an awful lot of memory. I know that this is because of 'bottom' in 'avgDepLength', but I'm unsure how to avoid it. Help is appreciated. http://lpaste.net/360775
00:39:55 <mniip> hmm why does this trigger ambiguity checks...
00:40:31 <koz_> jle`: What is ViewPatterns and LamdaCase?
00:41:06 <koz_> s/is/are/
00:41:33 <opqdonut> koz_: you know you could just compute bottom, it's like n*k^2 or something
00:41:48 <koz_> opqdonut: Yeah, I could. Good call.
00:42:08 <jle`> @let vptest (words->x:_:z:_) = map toUpper x ++ "___" ++ z
00:42:09 <lambdabot>  Defined.
00:42:10 <koz_> (it's actually k^(2n), but close enough)
00:42:12 <opqdonut> koz_: but let's pretend it's not easy to just compute it. in that case you shouldn't give a name to `allPairVecs n k`
00:42:21 <jle`> > vpest "hello world and everyone else"
00:42:23 <lambdabot>  error:
00:42:23 <lambdabot>      • Variable not in scope: vpest :: [Char] -> t
00:42:23 <lambdabot>      • Perhaps you meant ‘vptest’ (line 167)
00:42:26 <opqdonut> koz_: but instead inline it twice. that way the vector isn't kept in memory
00:42:28 <jle`> > vptest "hello world and everyone else"
00:42:30 <lambdabot>  "HELLO___and"
00:42:41 <koz_> opqdonut: Ah, OK, that makes sense. Let me try that.
00:42:47 <jle`> > (\(succ->x) -> x * 2) 10
00:42:49 <lambdabot>  22
00:43:01 <opqdonut> koz_: consider something like "let xs = [0..n] in sum xs / length xs". When sum walks the list it stays in memory, because length still needs it
00:43:47 <mniip> huh
00:43:51 <opqdonut> koz_: however, "sum [0..n] / length [0..n]" lets laziness work properly, sum consumes the list and it is gc'd on the go. same for length
00:44:10 <koz_> OK, I did not know that. Thanks for the info - I will keep that in mind.
00:44:28 <jle`> koz_: "fun part" of ViewPatterns comes when you use nested view patterns
00:44:46 <opqdonut> koz_: a hack is to do: "let xs () = [0..n] in sum (xs ()) / length (xs ())"
00:45:03 <opqdonut> in case the definition of xs is very long
00:45:15 <jle`> > (\(words->read->x:_:map toUpper->y:concat->xs) -> concat (replicate x y) ++ xs) "hello world and everyone else"
00:45:16 <EvanR> what on earth
00:45:17 <lambdabot>  error:
00:45:17 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
00:45:17 <lambdabot>        Expected type: [String]
00:45:31 <koz_> jle` is demoing ViewPatterns.
00:45:42 <EvanR> that hack is hilarious
00:45:55 <EvanR> like wrapping everything in function(){ in another language
00:45:56 <opqdonut> no, it's dead serious when you need it
00:46:05 <mniip> ok huh, can someone explain this
00:46:34 <mniip> :t let fun :: forall q p. (forall m. (KnownNat m) => q m) -> p (); fun = fun in fun -- this works
00:46:35 <lambdabot> error:
00:46:35 <lambdabot>     Not in scope: type constructor or class ‘KnownNat’
00:46:39 <EvanR> i wish duping a thunk existed
00:46:40 <mniip> @let import GHC.TypeLits
00:46:42 <lambdabot>  Defined.
00:46:43 <mniip> :t let fun :: forall q p. (forall m. (KnownNat m) => q m) -> p (); fun = fun in fun -- this works
00:46:45 <lambdabot> (forall (m :: Nat). KnownNat m => q m) -> p ()
00:46:52 <mniip> :t let fun :: forall q p. (forall m. (KnownNat m, m ~ 0) => q m) -> p (); fun = fun in fun -- this still works
00:46:54 <lambdabot> (forall (m :: Nat). (KnownNat m, m ~ 0) => q m) -> p ()
00:47:00 <mniip> :t let fun :: forall q p. (forall m. (KnownNat m, m <= 0) => q m) -> p (); fun = fun in fun -- this doesn't
00:47:01 <lambdabot> error:
00:47:01 <lambdabot>     • Couldn't match type ‘q0’ with ‘q’
00:47:01 <lambdabot>         ‘q0’ is untouchable
00:47:19 <koz_> opqdonut: Well, my program is pulling down a lot less memory now, although I suspect just computing the bottom might be smarter.
00:47:21 <mniip> dammit sigyn
00:48:04 <koz_> mniip: You too?
00:48:12 <mniip> ?
00:48:31 <koz_> I got a message from Sigyn that I'm 'tripping anti-spam measures'.
00:48:45 <mniip> right but that's because I repeated a thing 4 times
00:48:47 <mniip> in a row
00:48:56 <koz_> Yeah, but I didn't, and I still got that message.
00:50:18 <mniip> apparently it learned /l/
00:52:04 <mniip> hmm
00:52:13 <mniip> I am struggling to make sense of a typechecker message for once
00:55:07 <mniip> is it just the type families?
00:57:06 <mniip> evidently not
00:58:14 <mniip> can someone explain how the behavior of the ambiguity checks differs in these 2 cases: http://lpaste.net/360776
01:05:30 <koz_> opqdonut: This is still eating memory like mad, despite your suggestions: http://lpaste.net/360777
01:16:01 <mniip> jle`, phadej does this look good? https://hackage.haskell.org/package/singleton-typelits-0.0.0.0/candidate/docs/GHC-TypeLits-Induction.html
01:19:45 <mniip> up it goes
01:20:30 * hackage singleton-typelits 0.0.0.0 - Singletons and induction over GHC TypeLits  https://hackage.haskell.org/package/singleton-typelits-0.0.0.0 (mniip)
01:23:46 <jle`> fancy :)
01:25:31 <mniip> the docs just built
01:32:50 <hoppfull> Hello, HUnit wants my types to derive Show and Eq, can I derive them automatically in a seperate file instead of my implementation files?
01:33:09 <hoppfull> I think it's called "standalone deriving instances" or something like that.
01:33:37 <merijn> hoppfull: Why do you now want them in your implementation?
01:34:02 <merijn> hoppfull: Deriving them (or otherwise implementing them in a separate module) creates orphan instances, which are best avoided
01:34:24 <cocreature> orphan instances in a test suite are not likely to cause problems
01:34:57 <merijn> cocreature: Sure, but there's very few cases where it'd make sense to have Eq defined for a test-suite but not in the main library, IMO
01:35:16 <hoppfull> merijn: I don't know if I'm being silly but instinctively I recoil at implementing an instance just because my unit testing framework wants it. I'd rather just add "MyType with deriving (Show, Eq)" or something in my unit testing file.
01:35:46 <cocreature> you can use standalone deriving https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#extension-StandaloneDeriving but I don’t really see a reason for doing that for Show and Eq
01:36:14 <merijn> hoppfull: I've used HUnit and I don't think you should ever need Eq for it?
01:36:25 <merijn> hoppfull: What are you trying to do that requires an Eq instance?
01:37:00 <akegalj> acowley: I have asked you yeserday about DataKinds. If I have type `newtype Phantom (a :: Option) = ...` where Option s sum type, can I for example create an arbitrary instance `instance Arbitrary (Phantom a) where ...` and somehow tell that a is constrained here to the Option type. I know that practically it is, but looks like type interference doesn't understand this constrain (it looks to me that type 
01:37:06 <hoppfull> haha, I think it might just be OOP scars. I remember recoiling at public variables and functions for a long time in F# even though they're pure and immutable. After a while I realised it doesn't matter.
01:37:06 <akegalj> class definition defines `forall a.` of this type variable)
01:37:28 <cocreature> a lot of HUnit assertions test for equality so they obviously need an Eq constraint
01:37:43 <merijn> cocreature: Yeah, but those are just convenience wrappers
01:39:04 <hoppfull> At this point I'm not too worried about it if there is no simple way to do this. Having a Show instance for a type that is never printed or whatever in my program may cause slight confusion in what it's purpose is. But again, it's not super important.
01:39:37 <merijn> cocreature: As, I just wrote a small wrapper around assertBool that used a custom comparison
01:39:40 <merijn> hoppfull: ^^
01:40:36 <cocreature> hoppfull: I derive Show for pretty much all types (where it’s derivable) since at some point you are going to want to print something for debugging purposes
01:40:49 <merijn> hoppfull: You can easily implement, like "assertCustom :: (a -> a -> Bool) -> String -> a -> a -> Assertion" as small wrapper around assertBool
01:41:20 <cocreature> then you’ll have to hand-write the Eq instance which doesn’t seem like an improvement
01:41:38 <merijn> hoppfull: You could even mimic the use of "Show" in assert equal via a custom "Foo -> String" function (you might wanna replace 'a' in assertCustom with Foo
01:41:43 <merijn> cocreature: Depends on the comparison
01:41:48 <merijn> cocreature: You could just use comparing
01:43:55 <hoppfull> cocreature: I don't find sprinkling print statements for debugging in haskell very convenient. I'm quite new to haskell. The workflow of writing small functions and some unit tests and then go back and forth is quite nice. Small annoyances in how stack works but I'm sure I'll figure it out.
01:44:19 <Rembane> hoppfull: traceShow is the best! 
01:44:59 <akegalj> defining `newtype Phantom (a :: Option); instance ToJSON (Phantom OptionA); instance ToJSON (Phantom OptionB); instance Show (Phantom a) where show = show @(Phantom a) . toJSON` will break with "No instance for (ToJSON (Phatnom a))". Can I somehow constrain a in type instance - to tell ie "instance Show (Phantom (a :: Option)) where ..." ?
01:46:42 <cocreature> akegalj: if you are already constraining it in the definition of Phantom I don’t see what you gain by constraining it in the instance as well
01:48:34 <hoppfull> Rembane: Is that the side effecty non-monad function? haha I hear it's excellent when trying to figure out execution order because of haskells laziness feature.
01:49:16 <akegalj> cocreature: because I am creating general instance for Show (Phantom a) . It is more general then two specific definition of ToJSON (Phantom OptionA)  and  ToJSON (Phantom OptionB) - thus toJSON @(Phantom a) doesn't know which instance of ToJSON to invoke.
01:49:56 <akegalj> cocreature: solution is quite simple, to define Show (Phantom OptionA) and Show (Phantom OptionB)   - but I wonder can I avoid this
01:49:57 <Rembane> hoppfull: Kinda yes? http://hackage.haskell.org/package/base-4.10.1.0/docs/Debug-Trace.html#v:traceShow
01:50:46 <Rembane> hoppfull: It's loads of dark magic. Don't use it in production.
01:50:59 <Rembane> hoppfull: And it's superuseful during development.
01:51:32 <cocreature> akegalj: the way you have defined Phantom, an instance for "Phantom a" will only fork for a of kind Option since Phantom a is otherwise not a valid type
01:52:01 <hoppfull> Rembane: Cool, thanks man!
01:52:28 <cocreature> akegalj: maybe I’m misunderstanding what you mean by “constrain a”
01:53:01 <hoppfull> Rembane: Wow, there are lots of useful functions in Debug.Trace!
01:53:29 <akegalj> cocreature: I am aware od that. But ghc doesn't know which instance of ToJSON to invoke in `instance Show (Phantom a) where show = show . toJSON` . he complains that there is no instance `ToJSON (Phantom a)` 
01:54:16 <Rembane> hoppfull: There are, suddenly you can keep hacking as you did in C. :)
01:54:27 <hololeap> if a type is an instance of Enum, is it possible to automatically derive an Ord instance?
01:55:08 <merijn> hololeap: Ord is always automatically derivable
01:55:17 <merijn> (So is Enum, btw)
01:59:54 <metafn> I'm writing a web server where my handlers have STM as a base monad. Sometimes I have to generate random data, and I'm doing it in a different thread and passing the data through a TBQueue. Is there a hidden problem with this approach? It seems like a reasonably neat way to remove MonadIO contraints
02:00:43 <merijn> metafn: Seems fine. You could also just use randoms to generate a lazy, infinite list of random values
02:01:35 <tdammers> that, or you could create a pure PRNG for each request based on entropy gathered outside the STM context
02:01:58 <merijn> tdammers: That's just what randoms does?
02:02:58 <metafn> merijn: thanks!
02:03:29 <tdammers> merijn: essentially yes, though I would argue that passing around a RandomGen would be more flexible
02:03:58 <merijn> metafn: Quick warning: "randoms" is fine for most normal uses, but thoroughly unsuitable for anything supposed to be secure/cryptographic
02:05:28 <metafn> merijn: this is for generating UUIDs, but is also used for cryptonite bcrypt salts, so I guess I should stick with the current method.
02:06:48 <tdammers> metafn: if you need to regularly reseed from system entropy, then what you have now seems to be the sanest option IMO
02:07:00 <tdammers> can't access system entropy without IO
02:09:50 <merijn> CPRNGs shouldn't require reseeding, tbh. But System.Random is not a CPRNG
02:19:01 <phadej> mniip: that looks very nice!
02:19:19 <phadej> It's very terse, but a lot more readable than Haskell type signature :)
02:20:41 <phadej> mniip: related, why you put initial cases last, I'm used to seen them first?
02:21:10 <cocreature> akegalj: I don’t know of a nice solution to this. the easiest solution is to just define "instance ToJSON a => Show (Phantom a)" and carry that constraint around
02:58:34 <seveg> 0
03:11:40 <akegalj> cocreature: this is what I was refering to http://lpaste.net/360780 
03:24:12 <kahlil29> is there a function that takes a list of Maybe data and returns a list of only those entries that are NOT Nothing (only valid entries) ? 
03:24:52 <Rembane> kahlil29: catMaybes
03:24:56 <Rembane> :t catMaybes
03:24:58 <lambdabot> [Maybe a] -> [a]
03:25:04 <Rembane> :i catMaybes
03:25:10 <Rembane> Meh
03:25:17 <Rembane> It resides in Data.Maybe
03:25:35 <kahlil29> Rembane : thanks :D 
03:26:24 <kahlil29> is there a way on hackage or stackage to search for a function by its signature? I've seen someone use it here with lambdabot once
03:26:47 <Hafydd> A catMaybe is the quantum superposition of a live cat and a dead cat.
03:27:35 <Rembane> kahlil29: http://hoogle.haskell.org/?hoogle=%5BMaybe%20a%5D%20-%3E%20%5Ba%5D
03:28:21 <kahlil29> oh directly. that's interesting
03:28:41 <kahlil29> Hafydd: Schroedinger says Hi :P 
03:31:41 <codeshot> I've seen that Traversable has Foldable as it's superclass, does this mean that Applicatives that represent continuous signals can't be Traversable? It looks like it should be possible except for the dependency to be foldable
03:33:35 <cocreature> codeshot: Traversable is sufficient to implement Foldable, e.g. you can implement toList using State and implement the rest in terms of that
03:33:54 <cocreature> so I doubt you could implement traverse without being able to implement Foldable
03:37:59 <codeshot> but the foldable implementation never terminates its folds for continuous signals
03:38:05 <codeshot> which makes it quite unhelpful
03:38:23 <codeshot> so yeah, I can say foldl _ _ = undefined
03:38:30 <codeshot> but it's not right
03:38:37 <codeshot> merely correct
03:39:22 <cocreature> foldr can still terminate if you produce the list lazily
03:39:31 <cocreature> foldl can’t but that’s also true for lists
03:40:06 <codeshot> A continuous signal isn't a list
03:40:39 <codeshot> eg, an applicative newtype around a list of integers that represents a spline
03:40:50 <codeshot> you can traverse it but you can't fold it
03:41:02 <cocreature> can you show us your definition of "traverse"?
03:41:08 <codeshot> I haven't got one yet
03:41:17 <cocreature> what happens if I do "traverse (\i -> print i)"
03:41:49 <Younder> merijn, Whai is a CPRNG
03:42:11 <Younder> merijn, What is a CPRNG?
03:42:12 <cocreature> my point is that the problem is not the Foldable superclass constraint, it’s Traversable itself
03:42:28 <codeshot> yes I see what you mean
03:42:53 <liste> Younder: cryptographically secure pseudo-random number generator
03:43:18 <codeshot> Actually there's a separate class for the part of traversable where the target applicative is defined for continuous signals
03:43:24 <codeshot> but we don't have it's definition
03:43:36 <codeshot> cocreature, have I understood ?
03:44:04 <cocreature> I’m not sure what that class would look like
03:44:27 <codeshot> me neither
03:44:39 <cocreature> do you have some underlying problem that you are trying to solve?
03:45:49 <codeshot> I'm trying to gain a full intuition of haskell by considering implementation options in full, especially by seeing where an implementation choice would lead me so I gain expertise in practical haskell even in the face of leading a team of inexperienced developers
03:46:08 <codeshot> and how to recover from what looks like a dead-end
03:46:31 <codeshot> critically important thinkgs I do routinely when working in C++ and python
03:46:57 <codeshot> (I lead less than I imply but I strive to be capable of it)
03:48:40 <Younder> liste, What does that mean exactly, A Mersienne Twister?
03:51:15 <liste> Younder: well basically it's a class of PRNGs that are highly unpredictable. vanilla mersenne twister is not cryptographically secure
03:51:43 <siddharthvipul> .nextmeeting
03:52:44 <codeshot> cocreature, we would need a definition of traverse where the type of value that print receives is one whose show instance is 0.0000000000000000000000000....... and it's only used once
03:53:27 <codeshot> so we would need a multi parameter ContinuousTraversable I guess
03:54:04 <merijn> Younder: PRNG are mostly concerned with having the right amount of variation between subsequent values in a sequence, they're not really designed to be hard to reverse engineer. (i.e. if I observe N values can I figure out what the seed/state of the PRNG is and what the next values will be?)
03:55:09 <merijn> Younder: For many cases where you want "random" that's fine, you don't really care if someone could theoretically work out the state and predict the sequence (because it'd be unpractical or uninteresting) for example, no one really cares if you reverse engineer the PRNG in your video game and predict it's results
03:55:10 <fakenullie> limited range of seed values makes it easier
03:55:34 <tdammers> hmm, actually "PRNG" doesn't necessarily imply "unsuitable for cryptographic purposes"
03:55:38 <merijn> Younder: CPRNGs are a subclass of PRNG that are designed to be "sufficiently" hard to predict based on observed results
03:55:49 <merijn> tdammers: Of course, CPRNGs are a subclass of PRNGs
03:55:51 * hackage log-warper 1.8.0 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.8.0 (shersh)
03:56:11 <merijn> PRNG is the only thing you can really do in code without hardware support anyway
03:56:18 * hackage passman-core 0.1.0.0 - Deterministic password generator core  https://hackage.haskell.org/package/passman-core-0.1.0.0 (mat8913)
03:56:25 <tdammers> yes
03:56:26 <merijn> Younder: So CPRNGs have different design goals and trade-offs than general PRNGs
03:56:35 <codeshot> cocreature, perhaps dependent types are required for that
03:56:43 <tdammers> but that doesn't mean they can be reverse engineered
03:56:51 <codeshot> I keep hitting "needs dependent types"
03:56:55 <tdammers> if that were the case, cryptographic hashes would be pointless
03:57:03 <merijn> Younder: For example, you might want a really fast PRNG for some application, whereas CPRNG consider trading off speed for security
03:57:56 <merijn> Younder: Similarly the hashing scheme you use for your hash-table might care about performance, but hashing for file/cryptographic integrity cares more about security than speed
03:59:39 <Younder> merijn, GOTCHA
04:00:38 <quchen> Younder: Since you mentioned Mersenne Twister, that one’s not cryptographically secure.
04:01:34 <fakenullie> isn't it optimized for speed
04:01:36 <mlehmk> especially cause mersenne twister is initialized with a relatively small seed
04:01:45 <fakenullie> iirc it doesn't even good random
04:02:09 <quchen> »Good« random depends on your application.
04:02:10 <fakenullie> but at the time was better than other
04:02:20 <mlehmk> although, once seeded, it generates a very long stream of random bits
04:02:26 <mlehmk> pseudo+
04:02:53 <quchen> As far as I remember MT is fairly good for numerics, typical mistakes are not initializing it correctly.
04:03:12 <quchen>  /dev/random helps with that though. :-)
04:03:22 <fakenullie> for numerics?
04:03:48 <tdammers> quchen: MT still has fairly short and predictable cycles for cryptographical standards
04:04:19 <tdammers> it scores well on uniformness and similar metrics, but it's too easy to reverse engineer or predict
04:04:41 <tdammers> so it works well for, say, generating random noise for procedural textures, or for synthesizing audio signals
04:04:53 <tdammers> but not for crypto
04:05:25 <quchen> fakenullie: Monte Carlo for example
04:06:19 <quchen> fakenullie: Classical example is measuring π with it: paint a circle inside a square, randomly select points within the square, check how many of them are inside the circle, then calculate π based on that.
04:06:36 <fakenullie> eight
04:06:37 <quchen> A more practical example is solving complicated integrals in high dimensions.
04:06:37 <fakenullie> eight
04:06:43 <fakenullie> right
04:07:04 <fakenullie> I thought it was more useful for physical processes simulation
04:07:35 <quchen> Integrals are everywhere, high dimensions as well, so I wouldn’t be surprised.
04:07:47 <quchen> I know it from quantum field theory.
04:20:08 <siwica> Is there some formal definition of what an "action" is?
04:21:49 <tdammers> siwica: "action" is usually considered a synonym of "monadic value"
04:22:07 <tdammers> i.e., a value of some type Monad m => m a
04:23:49 * hackage magicbane 0.1.4 - A web framework that integrates Servant, ClassyPrelude, EKG, fast-logger, wai-cli…  https://hackage.haskell.org/package/magicbane-0.1.4 (myfreeweb)
04:25:58 <siwica> tdammers: I heard someone say "an action changes state in the real world". So I suspect that is false?
04:26:35 <siwica> So [42] would be an action too?
04:27:08 <quchen> »real world« is a bit of a dangerous term anyway, I suggest avoiding it. It comes from an implementation detail of GHC’s IO type.
04:30:08 <LiaoTao> Hello! I naively translated my recursive function into a (recursive?) monad chain. The memory usage seemed to go up quite a lot - is this common, or does it depend on the specific implementation?
04:30:24 <merijn> LiaoTao: Depends on the implementation of the underlying monad
04:31:05 <LiaoTao> merijn, I see. Thanks!
04:31:15 <LiaoTao> I just found it really strange - I'd assumed the opposite
04:31:19 * hackage ListT 0.1.2.0 - List transformer  https://hackage.haskell.org/package/ListT-0.1.2.0 (MatthewFarkasDyck)
04:32:16 <totom> What do you people think about functional approach of redux?
04:34:40 <fakenullie> totom: functional approach is better with functional languages
04:34:48 <fakenullie> elm is interesting
04:35:31 <totom> fakenullie: what about javascript with react redux
04:35:56 <totom> is immutability and higher order functions enough to call a language functional?
04:36:07 <fakenullie> totom: I haven't tried it, but people seems succesful with pure functions
04:37:14 <fakenullie> lack of good type system worries my in javascript and python and java
04:37:40 <LiaoTao> Obligatory javascript is disgusting
04:40:32 <s4ke> hi guys
04:40:47 <totom> LiaoTao: What do you mean by obligatory javscript
04:40:49 <liste> hi s4ke 
04:41:09 <LiaoTao> totom, Obligatory "javascript is disgusting" [comment]
04:41:34 <s4ke> come on guys. entertain me :D. can't work properly, waiting for some buyers for our old car. ffs, let me tell you guys something. never sell something online...
04:43:00 <s4ke> scammers, spammers and idiots
04:43:01 <s4ke> ffs
04:43:16 <fakenullie> idiots could offer better price
04:44:22 <totom> I am still a novice in haskell but after starting haskell, I am not liking other languages
04:44:49 <yoneda> totom: +1
04:44:55 <LiaoTao> I think you have to use Haskell for a bit to get familiar with its weaknesses
04:45:07 <fakenullie> that can ruin your career
04:45:08 <totom> LiaoTao: true
04:45:45 <LiaoTao> Funnily enough, most of the problems I've come across has nothing to do with the language itself
04:45:58 <LiaoTao> Just with poorly maintained and/or documented libraries
04:46:32 <LiaoTao> s/has/have/
04:50:15 <s4ke> apparently the potential buyer wants to talk to my mother
04:50:21 <s4ke> thinking he could manipulate my parents
04:50:55 <LiaoTao> Tell him it's not possible because they're buried in the backyard
04:51:33 <LiaoTao> And tell him to not worry about any bloodstains in the car - you've cleaned it proper
04:51:36 <totom> Do most of you work with haskell in your profession?
04:52:50 <LiaoTao> totom, Sometimes, but rarely for real
04:54:07 <s4ke> LiaoTao: :D
04:54:12 <totom> Most of the people I have met says you have to be really smart to work with haskell
04:54:23 <s4ke> i dont think so
04:54:38 <s4ke> problem is that people dont want to challenge themselves to learn something new
04:54:59 <s4ke> and smarter people tend to challenge themselves more often
04:55:08 <quchen> I like Haskell because the compiler is smart so I don’t have to be.
04:55:21 <LiaoTao> GHC is magic
04:55:39 <totom> And to learn functional people have to unlearn some of their practices and start fresh. I think this seems tough to them
04:55:41 <Ferdirand> to be fair, the mental model for imperative languages might be slightly easier
04:55:42 <quchen> And like magic, there are perfectly sensible explanations for all steps.
04:55:45 <s4ke> that's what me being no pychology professor says
04:56:20 <Ferdirand> you have a bunch of boxes with names, and you follow a flowchart consisting of looking at boxes and filling them with stuff
04:56:57 <totom> mental model of oops does not seems easier to me
04:57:00 <LiaoTao> Recursion and the scary-looking type system are probably two major factors
04:57:17 <s4ke> Ferdirand: _basic_ haskell is easier i think
04:57:29 <infinisil> higher-kinded stuff :O
04:57:30 <s4ke> but most tutorials on things like Monads especially tend to overcomplicate things
04:57:46 <Ferdirand> i don't know
04:58:03 <Ferdirand> it's hard to test this theory on people who have an interest for it but no prior exposure to programming
04:58:17 <s4ke> okay maybe not easier in general, but not as hard as fully grown haskell
04:58:46 <quchen> Fully grown Haskell is basic Haskell.
04:58:48 <s4ke> with haskell you have libraries which introduce scary new concepts all over the place. with OOP everything is a object
04:58:52 <Ferdirand> i've met one undergrad physics student, once, who naturally wrote pseudocode that was valid haskell, but couldn't understand C assignment
04:58:53 <quchen> Intermediate Haskell is usually terrible.
04:59:13 <totom> I think if someone has a fair grasp of category theory then monads are not that tricky
04:59:29 <LiaoTao> quchen, :(
04:59:30 <s4ke> totom and which beginner has a grasp of category theory?
04:59:43 <quchen> I think a fair grasp of categorical monads doesn’t help you one bit in order to understand their use in Haskell.
04:59:59 <s4ke> +1
05:00:40 <quchen> »What’s the adjunction that leads to my ReaderT WriterT StateT again« – no one ever
05:01:02 <s4ke> Monad Transformers are a tough one as well
05:01:22 <s4ke> i have started doing haskell and FP about 1.5 years ago or so
05:01:23 <LiaoTao> quchen, On the other hand, I can write non-trivial programs in Haskell but still don't understand one word of your discussions
05:01:40 <quchen> My discussions? Which ones?
05:01:54 <LiaoTao> Plural
05:02:01 <s4ke> and i remember having so much trouble grasping monads and monadtransformers
05:02:11 <LiaoTao> The experienced habitants in here
05:02:32 <sun777> can i write function-names-like-this?
05:02:49 <s4ke> but once i wrote a program that _required_ monads to be somewhat un-cumbersome to write i got it
05:02:56 <quchen> LiaoTao: That’s not at all representative of my code though, it’s just for education and fun.
05:03:31 <quchen> sun777: No, »-« is not a valid character for names in Haskell
05:03:36 <quchen> sun777: Underscores work though
05:03:51 <quchen> foo_bar_baz -- like this, but it’s not common style
05:04:06 <sun777> quchen: thanks m8. too bad :(
05:04:17 <s4ke> underscores are hard to read and clutter imo
05:04:27 <quchen> sun777: You can use (-----) as a name though, but then you can’t use letters. :-)
05:04:37 <quchen> So it’s either mostly letters, or only symbols.
05:04:47 <s4ke> quchen: or encode your names in morsecode
05:04:55 <quchen> Excellent point.
05:04:59 <sun777> ill do the ------ thing and encode my names in base1, how about that 
05:05:01 <totom> I started learning category theory in order to grasp haskell better, so should I drop it? someone suggested me to learn it.
05:05:15 <LiaoTao> the (.:::.) operator was pretty scary-looking
05:05:30 <s4ke> i introduce stuff like |&&&| in my paper :D
05:05:36 <s4ke> or better (....)
05:05:43 <s4ke> the latter should be scrapped though
05:05:47 <s4ke> since its garbage
05:05:52 <quchen> totom: I don’t think it’s very helpful, no. You can of course do it if it’s interesting to you, but don’t expect any immediate or great payoff.
05:06:09 <s4ke> totom: which part of haskell do you want to understand better?
05:06:09 <quchen> totom: Some people use category theory to discover great new abstractions, but most of us don’t.
05:06:43 <totom> It does seems interesting to me so just for the sake of my interest i'll continue
05:06:57 <quchen> totom: Example: (Co)Yoneda are named after category theory, but they also solve practical engineering problems in Haskell, and could have been discovered from an entirely un-mathematical perspective as well.
05:06:58 <s4ke> my best tip to learn intermediate level haskell is to keep asking the compiler what it wants
05:07:00 <LiaoTao> s4ke, How about unicode names? a Å b
05:07:24 <quchen> s4ke: And hang out on IRC :-)
05:07:24 <s4ke> LiaoTao: i keep cringing when i see actual lambda symbols in code
05:07:43 <LiaoTao> a 入 b
05:07:49 <LiaoTao> a 人 b
05:08:05 <s4ke> once i discovered that type holes were a thing the bad ide support stopped bothering me so much
05:08:20 <s4ke> LiaoTao the first one looks like a coat hanger
05:09:48 <LiaoTao> Seriously, though, it should at least carry a fine or something
05:10:01 <LiaoTao> Some linear algebra library had inverted '?' 
05:10:09 <s4ke> :D
05:10:23 <quchen> Linear logic, maybe?
05:10:35 <quchen> They have an inverted ampersand
05:10:36 <s4ke> couldYouPleaseDoThisForMe 1 ?
05:11:11 <LiaoTao> quchen, I'm sure there is more than one offender out there
05:11:19 <LiaoTao> :(
05:11:23 <s4ke> now i want to start a "weird operator library" so your code looks like text 
05:11:23 <quchen> Such as acme-lookofdisapproval!
05:12:04 <codedmart> I am not sure if this is possible or not. https://gist.github.com/codedmart/1ca54bdf645ac7464d993ae3c09e4de5
05:12:55 <codedmart> Basically can I use aeson genericParseJSON when I want the nested data?
05:18:19 <lyxia> codedmart: do d <- o .: "data" ; genericParseJSON ... d
05:23:53 * hackage bbdb 0.8 - Ability to read, write, and modify BBDB files  https://hackage.haskell.org/package/bbdb-0.8 (HenryLaxen)
05:24:31 <codedmart> lyxia: Duh thanks!
05:24:52 <marcodpm> ciao
05:27:54 <feep[work]> hi, I'm a D programmer, I'm just here to fish for a good function name
05:28:05 <feep[work]> we have fold that takes a seed and successively combines it with a function
05:28:29 <feep[work]> what's a name for "something like fold but it uses the first element as a seed, and errors if there's no elements?"
05:28:39 <s4ke> fold?
05:28:47 <feep[work]> oh, it works like that anyways in haskell?
05:28:56 <s4ke> sec
05:28:56 <s4ke> fold1
05:29:04 <dminuoso> :t fold1
05:29:05 <lambdabot> error:
05:29:05 <lambdabot>     • Variable not in scope: fold1
05:29:05 <lambdabot>     • Perhaps you meant one of these:
05:29:09 <dminuoso> :t foldr1
05:29:10 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
05:29:11 <dminuoso> ;-)
05:29:13 <s4ke> % :t foldl1
05:29:13 <yahb> s4ke: foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
05:29:14 <marcodpm> !list
05:29:14 <feep[work]> oh, fold1, I read it as foldl :D
05:29:21 <s4ke> there is foldl
05:29:23 <s4ke> and foldl1
05:29:25 <saurabhnanda> there's a foldl1?~
05:29:27 <feep[work]> wonderful
05:29:27 <dminuoso> feep[work]: its foldl1 and foldr1 respectively
05:29:44 <dminuoso> saurabhnanda: there's even a foldl1' :P
05:29:53 <s4ke> ;)
05:29:57 <feep[work]> awesome~ thank you!
05:30:09 <dminuoso> feep[work]: By the way for future reference
05:30:10 <cocreature> and you should use foldl1' over foldl1
05:30:26 <s4ke> cocreature: if you are not working on infinite lists
05:30:27 <s4ke> that is
05:30:37 <cocreature> s4ke: if you are working on infinite lists, foldl1 doesn’t work either
05:30:53 <dminuoso> feep[work]: fold doesn't exactly "combine", more generally it just swaps (:) for something else :) https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
05:31:10 <s4ke> cocreature: oh? well i always mess up with folds.. :D
05:31:27 <cocreature> s4ke: foldr/foldr1 work for infinite lists
05:32:38 <dminuoso> cocreature: Mmm, what's the point of foldl1? Is this if the reducer is lazy?
05:33:04 <liste> the '1' variants don't need an initial element
05:33:09 * feep[work] auto fold1(alias Fun, T)(T range) if (isInputRange!T) { return range.dropOne.fold!Fun(range.front);  }
05:33:13 <feep[work]> anyway, thanks a lot for the name~
05:33:34 <liste> (or rather, they take the 1st list element as initial element)
05:35:40 <cocreature> dminuoso: if the reducer function is lazy in the first argument, then foldl and foldl1 might make sense (see https://kseo.github.io/posts/2016-12-21-foldl-vs-foldl%27.html) for an example but I can’t recall a single case in my code where the non-prime version would be preferable to the prime vresions
05:35:44 <s4ke> cocreature: checked again, yes you're obviously right
05:35:54 <cocreature> it’s mostly a historical accident, that the prime versions are not the default
05:38:45 <s4ke> dmiuoso: awesome way to think about a fold
05:40:10 <dminuoso> > foldr (:) [] [1,2,3,4,5]
05:40:12 <lambdabot>  [1,2,3,4,5]
05:40:48 <s4ke> > foldl (:) [] [1,2,3,4,5]
05:40:50 <lambdabot>  error:
05:40:50 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
05:40:50 <lambdabot>        Expected type: [a] -> [a] -> [a]
05:40:54 <s4ke> woops
05:41:36 <LiaoTao> > foldl (flip (:)) [] [1,2,3,4,5]
05:41:38 <lambdabot>  [5,4,3,2,1]
05:41:47 <s4ke> pidgin is weird
05:41:52 <cocreature> foldl (flip (:)) = reverse
05:41:53 <s4ke> it translates :) to a smiley
05:42:00 <s4ke> now i have smileys everywhere
05:42:09 <dminuoso> @src reverse
05:42:09 <lambdabot> reverse = foldl (flip (:)) []
05:42:27 <liste> why not foldl' ?
05:42:29 <s4ke> foldl (flip ( smileyface) []
05:42:49 <liste> > foldl' (flip (:)) [] [1,2,3,4,5]
05:42:51 <lambdabot>  [5,4,3,2,1]
05:43:01 <s4ke> liste: just toying around see discussion above
05:43:14 <liste> I'm just wondering why reverse doesn't use foldl'
05:43:23 <liste> or is it one of the @src lies again
05:44:02 <liste> apparently it is https://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.List.html#reverse
05:44:03 <dminuoso> liste: seems to be a lie
05:44:04 <dminuoso> liste: http://hackage.haskell.org/package/base-4.10.1.0/docs/src/GHC.List.html#reverse
05:44:19 <dminuoso> Ah you were faster.
05:44:42 <liste> though the report seems to define it as @src shows
05:44:46 <fakenullie> repr prelude version use foldl
05:44:49 <fakenullie> report
05:45:16 <fakenullie> so I guess recursion version is faster
05:45:20 <dminuoso> liste: Im guessing that would mean the definition is just a historical accident?
05:45:35 <dminuoso> (the report definition)
05:45:36 <liste> maybe
05:45:48 <ezyang> EvanR: If you're willing to be GHC 8.2 only! :) 
05:49:33 <fakenullie> ".map? .reduce? What is this black magic?"
05:50:19 <fakenullie> though I think reduce should've been called fold
05:52:14 <s4ke> fakenullie what are you talkinga bout?
05:52:31 <fakenullie> s4ke: article about functional programming in javascript
05:52:36 <s4ke> brrr
05:58:40 <dminuoso> fakenullie: Why should it have been called "inject" ?
05:59:17 <fakenullie> dminuoso: why "inject"?
05:59:38 <dminuoso> fakenullie: inject and reduce at least have historical context (smalltalk and common lisp) respectively
06:00:02 <fakenullie> hmm, okay
06:00:31 <dminuoso> I think the name `fold` comes from ML type of languages if Im not mistaken
06:00:41 <fakenullie> ruby has both
06:01:05 <dminuoso> fakenullie: Ruby is a big bag of mess.
06:01:10 <dminuoso> It also has methods like "upcase"
06:02:30 <fakenullie> it's good for code golf, like perl
06:03:09 <totom> fakenullie: Which javascript article? could you please provide me the link.
06:04:02 <s4ke> i was wondering... is there a common way to abstract backends in haskell?
06:04:23 <fakenullie> totom: https://hackernoon.com/javascript-and-functional-programming-an-introduction-286aa625e26d
06:04:31 <liste> s4ke: yes, depending on what kind of backend you need. pandoc's approach is quite flexible
06:04:38 <fakenullie> maybe it's ok for introduction
06:04:52 <s4ke> what i am currently doing is using typeclasses for that
06:05:35 <s4ke> meaning: i have a (class SomeClass a) somewhere in my code definition
06:05:44 <s4ke> then i have multiple modules that are the backends
06:05:55 <s4ke> and they usually implement something like
06:06:01 <s4ke> instance SomeClass a where
06:06:41 <liste> usually functions or records of functions are enough
06:06:52 <liste> https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers.hs pandoc's approach
06:06:55 <s4ke> then i can choose which backend i want to use depending on the import
06:07:40 <dminuoso> fakenullie: So far the best FP guide for JavaScript has been the series from Prof Frisby
06:07:47 <s4ke> liste: is that extensible for users?
06:07:59 <liste> s4ke: you mean dynamic code loading?
06:08:04 <dminuoso> fakenullie: https://www.youtube.com/watch?v=h_tkIpwbsxY
06:08:14 <s4ke> i guess. so users can implement their own backend
06:08:33 <liste> s4ke: it can be made so
06:08:33 <s4ke> which can be "registered" automatically
06:08:44 <s4ke> hmm ok
06:08:44 <liste> but dynamic code loading requires a bit of setup anyway
06:08:58 <s4ke> ah no then probably i dont mean that
06:09:00 <liste> would the users compile their backends themselves
06:09:26 <fakenullie> dminuoso: thanks
06:10:08 <fakenullie> would record with function would be valid approach for backend?
06:10:25 <fakenullie> instead of type classes
06:10:50 <s4ke> liste: i am abusing the hell out of orphan typeclasses
06:11:36 <fakenullie> oh, right, haven't seen liste's response
06:19:02 <tdammers> siwica: technically, yes, [42] would be an action in the list monad
06:20:08 <tdammers> siwica: however we would typically only use the term "action" when reasoning in terms of monadic combinators
06:21:11 <tdammers> siwica: so if you have, say, let f x = return (x + 1) in [42] >>= f, then we might consider [42] an action
06:22:29 <tdammers> siwica: but as far as lists are concerned, the monadic API to them is not how you'd typically use them, unlike, say, IO
06:22:42 <mlehmk> What is a Monad? - Computerphile https://youtu.be/t1e8gqXLbsU
06:23:02 <mlehmk> I find that a nice explanation
06:23:12 <s4ke> even though lists are monads, i tend to not think of them as monads usually
06:23:44 <mlehmk> lists are applicatives, traversables, foldables, .... hope I didn't say something wrong here
06:24:18 <tdammers> also functors and monoids and semigroups and a bunch of other useful typeclasses
06:24:42 <tdammers> functor especially is an extremely common use case
06:25:05 <mlehmk> what kind of class is like an Applicative f?
06:25:25 <mlehmk> something that could be like a Just function or Nothing
06:25:40 <fakenullie> Maybe a
06:26:08 <fakenullie> I think Maybe is instance of Applicative
06:26:23 <fakenullie> > Just (+1) <*> Just 2
06:26:26 <lambdabot>  Just 3
06:26:27 <mlehmk> I know that (Just (+)) <*> (Just 1) <*> (Just 2) would sum
06:26:56 <s4ke> which makes sense
06:27:57 <mlehmk> > (Just 1) <**> (Just (+)) <*> (Just 2)
06:28:00 <lambdabot>  Just 3
06:28:19 <fakenullie> <**> if flip (<*>) ?
06:28:30 <mlehmk> yes, <**> is <*> with arguments reversed
06:28:33 <Cale> s4ke: Particular lists are not monads, the type constructor for lists is a (single) monad
06:28:44 <s4ke> Cale: true
06:29:20 <fakenullie> > [1, 2] >>= \r -> [3, 4]
06:29:22 <lambdabot>  [3,4,3,4]
06:29:28 <mlehmk> list could work like a maybe monad, Just x ~ [x] and Nothing ~ []
06:30:16 <pierrot> Hi. Why `seq (repeat 10) 9` returns 9 while `seq (sum $ repeat 10) 9` goes into an infinite loop?
06:30:46 <Cale> pierrot: Because evaluating repeat 10 up to determining the top level data constructor in it is easy
06:30:48 <mlehmk> what's the sum of infinitely many 10?
06:31:00 <Cale> It just goes as far as finding out that the result is of the form _ : _
06:31:23 <Cale> But actually adding all the numbers in that list is a lot of work ;)
06:31:26 <fakenullie> bottom
06:31:49 <s4ke> Cale: in fakenullies example, [1, 2] >>= \r -> [3, 4] : isn't [1,2] still a monad?
06:31:53 <s4ke> (dumb questin)
06:31:55 <s4ke> question
06:31:57 <Cale> [1,2] is not a monad
06:32:03 <Cale> Just 5 is not a monad
06:32:05 <Cale> Maybe is a monad
06:32:11 <merijn> s4ke: Being a monad is a property of *types*, not values
06:32:21 <mlehmk> if Maybe is a monad, is Just 5 a ... what is it?
06:32:26 <Cale> [] (at the type level) is a monad, but [], the empty list, isn't
06:32:36 <s4ke> ok. makes sense
06:32:40 <merijn> mlehmk: Maybe is a type, "Just 5" is a value
06:32:49 <merijn> mlehmk: Being a monad is a property of a type, not of values
06:32:51 <Cale> IO is a monad, getLine isn't a monad
06:33:00 <raek> a value of the monadic type?
06:33:04 <mlehmk> merijn, okay, trying again, Type is to Value, as Monad is to ...?
06:33:16 <s4ke> as i said... dumb question :D
06:33:18 <s4ke> but thanks
06:33:19 <Psybur> :t foldr (\x (lc,s) -> if (lc == x) then (x,s+(read x)) else (x,s))
06:33:20 <merijn> mlehmk: "monadic value" is often (sloppily!) used as "value of types that happens to be a monad"
06:33:21 <lambdabot> (Read a, Num a, Foldable t) => ([Char], a) -> t [Char] -> ([Char], a)
06:33:24 <Cale> mlehmk: There's no analogy to be made there...
06:33:29 <Psybur> Where is it getting that [Char] from?
06:33:40 <merijn> Psybur: String = [Char]
06:33:51 <pierrot> Cale: thanks
06:33:52 <Psybur> Oh, its read isnt it
06:33:54 <Psybur> :t read
06:33:55 <lambdabot> Read a => String -> a
06:33:57 <merijn> Psybur: Correct
06:34:03 <Cale> Once you have a particular value, it's usually better to be more specific
06:34:11 <Psybur> Can I 'read' a Char?
06:34:21 <Cale> Just 5 is a value of type Maybe Integer (or perhaps (Num a) => Maybe a)
06:34:24 <frerich> Does anybody have a nice idea on how to implement a function 'f :: [[a]] -> [a]' such that 'f [[1,5],[2,4,6],[3,7]] == [1,2,3,4,5,6,7]', i.e. it works a bit like 'transpose' but differs in that it first picks from the first, then from the next, then from the next... and then bounces back when having picked from the last. I'm trying to come up with a nice definition which does not need '!!' but rather uses 'tails' or so, I suspect 
06:34:24 <frerich> there's something in there.
06:34:32 <merijn> Psybur: GHC *tries* to keep type aliases around when using ":t" but doesn't always succeed
06:34:35 <Cale> It doesn't necessarily matter that Maybe happens to be a monad.
06:34:55 <Cale> Lots of types happen to be instances of Monad, that doesn't always need emphasis.
06:34:56 <merijn> Psybur: What do you mean "read a Char"?
06:35:04 <Psybur> Turn it into an int in this case
06:35:08 <Psybur> Guess thats toEnum?
06:35:22 <s4ke> merijn: huh. i didn't get that wrong in my paper. nice :)
06:35:27 <Cale> Similarly, getLine is an IO action, specifically of type IO String. It doesn't necessarily matter here that IO is a monad.
06:35:33 <merijn> Psybur: digitToInt
06:35:40 <fakenullie> > fromEnum 'a' 
06:35:43 <lambdabot>  97
06:35:49 <Psybur> I see
06:35:51 <merijn> Psybur: That crashes when it's not a digit, though
06:35:59 <Psybur> > digitToInt '6'
06:36:01 <lambdabot>  6
06:36:11 <Psybur> > digitToInt ':D'
06:36:13 <lambdabot>  <hint>:1:13: error: parse error on input ‘:’
06:36:29 <fakenullie> :D is a char?
06:36:31 <merijn> Psybur: If you plan to read a lot of digits you probably wanna use something else
06:36:38 <fakenullie> > 'abc'
06:36:40 <lambdabot>  error:
06:36:40 <lambdabot>      • Syntax error on 'abc'
06:36:40 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
06:36:56 <s4ke> -.- i seriously have to disable smileys in pidgin
06:36:58 <s4ke> for this chatroom
06:38:49 <fakenullie> use a proper irc client
06:39:14 <s4ke> fakenullie: pidgin is good, i also still happen to have ICQ
06:40:51 <pierrot> another question: `head $ foldl (flip (:)) [] (repeat 10)` goes into an infinite loop and I understand it, but `head $ foldr (:) [] (repeat 10)` returns 10. Why is this? Because the recursion goes like foldr (:) ((:) 10 ((:) 10 (... []))) (repeat 10) and always "new" 10 values are put at the beginning. How does GHC infers that 10 is the first element at the top level data constructor of the result?
06:44:47 <Cale> pierrot: Let's look at the definition of foldr
06:44:49 <Cale> @src foldr
06:44:49 <lambdabot> foldr f z []     = z
06:44:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:44:59 <Cale> @src repeat
06:44:59 <lambdabot> repeat x = xs where xs = x : xs
06:45:08 <Cale> foldr (:) [] (repeat 10)
06:46:21 <Cale> Well, let's just for the sake of simplicity pretend that the definition of repeat is  repeat x = x : repeat x, even though that's less efficient
06:46:27 <Cale> foldr (:) [] (repeat 10)
06:46:35 <Cale> -> foldr (:) [] (10 : repeat 10)
06:46:51 <Cale> -> 10 : foldr (:) [] (repeat 10)
06:47:04 <Cale> So, if we were evaluating head of this
06:47:08 <Cale> @src head
06:47:08 <lambdabot> head (x:_) = x
06:47:08 <lambdabot> head []    = error "Prelude.head: empty list"
06:47:18 <Cale> we'd be able to pattern match at this point and get 10
06:47:37 <Cale> The remaining foldr would never happen
06:47:53 <Cale> Does that make sense?
06:48:11 <pierrot> Why not?
06:48:47 <Cale> Well, because 10 : foldr (:) (repeat 10) would be pattern matched against the pattern (x : _) in the definition of head
06:48:53 <Cale> and x would get bound to 10
06:49:20 <Cale> but the _ pattern doesn't bind a variable (and even if we did bind a variable, we're not about to make use of it in the result here)
06:49:21 <pierrot> Ohh yeah
06:49:41 <Cale> The result is simply x, and we're done
06:49:44 <pierrot> I got confused. Yeah, it was quite obvious.
06:49:47 <pierrot> Thanks, Cale 
06:49:51 <Cale> No problem :)
06:57:16 <pierrot> One last question: `let x = repeat 10 in fst $! (take 10 x, sum x)` returns `[10,10,10,10,10,10,10,10,10,10]`. I expected $! to force strict evaluation inside the tuple, and then an infnite loop. Why doesn't this happen?
06:58:03 <merijn> pierrot: $! forces to WHNF (Weak Head Normal Form), aka outermost constructor
06:58:14 <merijn> pierrot: So you're just forcing the tuple constructor, not the contents of the tuple
06:58:37 <pierrot> Oh, I see.
06:58:43 <Cale> Yeah, $! in that position doesn't accomplish anything interesting.
07:00:05 <pierrot> Thanks
07:01:15 <tdammers> > let x = repeat 10 in let s = sum x in s `seq` (take 10 x, s)
07:01:21 <lambdabot>  mueval-core: Time limit exceeded
07:01:31 <tdammers> > let x = repeat 10 in let s = sum x in s `seq` fst (take 10 x, s)
07:01:37 <lambdabot>  mueval-core: Time limit exceeded
07:01:44 <tdammers> > let x = repeat 10 in let s = sum x infst (take 10 x, s)
07:01:46 <lambdabot>  <hint>:1:56: error:
07:01:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:01:50 <tdammers> > let x = repeat 10 in let s = sum x in fst (take 10 x, s)
07:01:52 <lambdabot>  [10,10,10,10,10,10,10,10,10,10]
07:01:58 <tdammers> there you go
07:03:21 * hackage goggles 0.1.0.2 - Interface to Google Cloud APIs  https://hackage.haskell.org/package/goggles-0.1.0.2 (ocramz)
07:10:28 * hackage goggles 0.1.0.3 - Interface to Google Cloud APIs  https://hackage.haskell.org/package/goggles-0.1.0.3 (ocramz)
07:33:50 <s4ke> so, i sold the car. annd
07:33:55 <s4ke> the guy was actually nice
07:33:56 <s4ke> :)
07:34:15 <s4ke> and i wasnt given fake money
07:34:20 <s4ke> which is a +1 for me
07:34:28 <fakenullie> cool
07:34:42 <frerich> s4ke: Witness 1795 Haskell enthusiasts listening to you in awe!
07:34:45 <s4ke> :D
07:35:08 <fakenullie> s4ke: there is #haskell-offtopic
07:35:25 <s4ke> neat thx
07:44:57 <pta2002> is there any function to turn a hex string into a list of booleans
07:45:04 <pta2002> so 0 would be False and 1 would be True
07:45:08 <pta2002> could be ints too I guess
07:46:08 <s4ke> pta2002: why not use testBit
07:46:14 <pta2002> something like "ff" -> [True, True, True, True, True, True, True, True]
07:46:30 <s4ke> > testBit 1 1 
07:46:31 <pta2002> s4ke: because I don't know what that is! Please explain
07:46:32 <lambdabot>  False
07:46:43 <s4ke> testBit 1 0
07:46:47 <pta2002> > testBit 1 0
07:46:48 <s4ke> > testBit 1 0
07:46:50 <lambdabot>  True
07:46:51 <lambdabot>  True
07:46:53 <pta2002> wait what
07:47:08 <s4ke> > testbit 256 1
07:47:10 <lambdabot>  error:
07:47:10 <lambdabot>      • Variable not in scope: testbit :: Integer -> Integer -> t
07:47:10 <lambdabot>      • Perhaps you meant ‘testBit’ (imported from Data.Bits)
07:47:17 <s4ke> > testBit
07:47:19 <lambdabot>  error:
07:47:19 <lambdabot>      • No instance for (Typeable a0)
07:47:19 <lambdabot>          arising from a use of ‘show_M604967602995909561514687’
07:47:21 <s4ke> > :t testBit
07:47:23 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:47:30 <s4ke> % :t testBit
07:47:31 <yahb> s4ke: testBit :: Bits a => a -> Int -> Bool
07:47:32 <pta2002> oh not really what I want
07:47:36 <pta2002> but I guess it could work
07:47:39 <s4ke> you can just convert it easily
07:47:45 <pta2002> is there any hexstring type
07:47:50 <pta2002> because right now it's just a String
07:49:32 <s4ke> % :T readHex
07:49:32 <yahb> s4ke: unknown command ':T'; use :? for help.
07:49:37 <s4ke> % :t readHex
07:49:38 <yahb> s4ke: readHex :: (Num a, Eq a) => ReadS a
07:51:30 <pta2002> so I was messing around with that readHex function
07:51:51 <pta2002> why does it return a list of tuples=
07:51:54 <pta2002> ?*
07:51:54 <lambdabot> Maybe you meant: v @ ? .
07:52:17 <pta2002> I understand the values in the tuple, but why a list?
07:52:22 <geekosaur> because it's a parser that can handle multiple possible parses that be disambiguated later
07:52:30 <pta2002> oh
07:52:34 <pta2002> let me try something then
07:52:43 <pta2002> > readHex "ff" :: String
07:52:45 <lambdabot>  error:
07:52:45 <lambdabot>      • Couldn't match type ‘(Integer, String)’ with ‘Char’
07:52:45 <lambdabot>        Expected type: String
07:52:52 <pta2002> hm
07:53:04 <pta2002> > readHex "ff" :: Integer
07:53:06 <lambdabot>  error:
07:53:06 <lambdabot>      • Couldn't match expected type ‘Integer’
07:53:06 <lambdabot>                    with actual type ‘[(Integer, String)]’
07:53:10 <geekosaur> this kinda plays along with how the list monad works, so a later stage of the parse winnows the result list down to 1
07:53:33 <geekosaur> which handles some ambiguous cases that people expect to "do the right thing"
07:54:06 <pta2002> hm
07:54:12 <pta2002> but how'd I get only the integer out?
07:54:16 <s4ke> %  (readHex :: (ReadS Integer)) "a213"
07:54:17 <yahb> s4ke: [(41491,"")]
07:54:51 <cocreature> > "a123" ^? hex
07:54:53 <lambdabot>  Just 41251
07:54:56 <s4ke> or that
07:54:59 <pta2002> wait what
07:55:01 <s4ke> looks much nicer
07:55:02 <pta2002> what just hapenned there
07:55:22 <pta2002> > "this won't work" ^? hex 
07:55:24 <lambdabot>  Nothing
07:55:27 <cocreature> obviously depending on lens to parse hex numbers is completely reasonable
07:55:38 <pta2002> oh it's a library
07:55:51 <pta2002> how does it work though?
07:55:54 <pta2002> seems like what I want
07:56:07 <s4ke> or you could just extract from the list
07:56:08 <s4ke> ;)
07:56:14 <pta2002> s4ke: but i'm lazy
07:56:25 <s4ke> pta2002 that's not that hard to do ;)
07:56:28 <pta2002> granted i only would need to do it once and wouldn't be hard at all because pattern matching
07:56:37 <pta2002> but now i'm intrigued about this ?^ thing
07:56:43 <pta2002> ^?*
07:56:54 <cocreature> I’m sorry I dragged you into the "lens" rabbit hole
07:57:05 * hackage git-annex 6.20171214 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20171214 (JoeyHess)
07:57:06 <s4ke> % map fst ((readHex :: (ReadS Integer)) "a213")
07:57:06 <yahb> s4ke: [41491]
07:57:12 <s4ke> and now you just get the value out
07:57:21 <s4ke> and convert it to a Maybe
07:57:30 <s4ke> i dont know whether its easier to do, but this works
07:59:01 <s4ke> % let x = map fst ((readHex :: (ReadS Integer)) "a213") in if (length x) == 0 then Nothing else Just (head x)
07:59:02 <yahb> s4ke: Just 41491
07:59:12 <cocreature> > > fmap (map (=='1') . review binary) ("a123" ^? hex)
07:59:14 <cocreature> > fmap (map (=='1') . review binary) ("a123" ^? hex)
07:59:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
07:59:16 <lambdabot>  Just [True,False,True,False,False,False,False,True,False,False,True,False,Fa...
07:59:17 <eschnett> i want to calculate Chebyshev polynomials, passing the index n as type-level literal. i’m stuck implementing this. here is my current snapshot: http://lpaste.net/360784
07:59:35 <s4ke> or do what cocreature says
07:59:36 <s4ke> :D
07:59:37 <eschnett> any pointers e.g. to a tutorial or example would be cool.
07:59:38 <s4ke> your choice
07:59:42 <pta2002> cocreature: how does that work
07:59:46 <pta2002> that's exactly what I want!
08:00:37 <cocreature> pta2002: it uses a library called "lens" but since that library is known to be fairly complicated and mostly targeted at something completely different/more general I wouldn’t recommend it for this usecase
08:00:38 <s4ke> % let myFn str = let x = map fst ((readHex :: (ReadS Integer)) str) in if (length x) == 0 then Nothing else Just (head x)
08:00:39 <yahb> s4ke: 
08:01:04 <cocreature> s4ke: that’s just listToMaybe
08:01:14 <s4ke> cocreature: i am bad without hoogle
08:01:56 <s4ke> % let myFn str = let x = map fst ((readHex :: (ReadS Integer)) str) in listToMaybe x
08:01:56 <yahb> s4ke: 
08:02:03 <s4ke> % myFn "123123"
08:02:03 <yahb> s4ke: Just 1192227
08:02:49 <s4ke> % let myFn str = listToMaybe ( map fst ((readHex :: (ReadS Integer)) str))
08:02:49 <yahb> s4ke: 
08:04:05 <s4ke> pta2002: rest is quite easy to do with testBit
08:04:22 <s4ke> do you even require the list?
08:04:22 <liste> 3~3~
08:04:38 <pta2002> Need to count the 1 bits
08:05:07 <pta2002> Then I could just do length . filter (==True)
08:05:15 <cocreature> pta2002: you can do that a lot faster using https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Bits.html#v:popCount
08:05:18 <pta2002> Change that to id
08:05:56 <pta2002> Well I'll check it out later
08:06:00 <pta2002> Need to leave for now
08:06:02 <pta2002> Thanks!
08:06:05 <frerich> You could also use a list comprehension, like
08:06:14 <frerich> > [testBit (digitToInt n) i | n <- reverse "7f", i <- [3,2,1,0]]
08:06:16 <lambdabot>  [True,True,True,True,False,True,True,True]
08:06:24 <Psybur> > 1 / 2
08:06:27 <lambdabot>  0.5
08:06:51 <s4ke> %  fmap popCount (myFn "123123")
08:06:51 <yahb> s4ke: Just 8
08:07:05 <Psybur> :t isInt
08:07:07 <lambdabot> error: Variable not in scope: isInt
08:07:32 <Psybur> > round $ 1/2
08:07:35 <lambdabot>  0
08:07:43 <s4ke> and now just change myFn to accept all Eq a and you have yourself a good function
08:07:47 <s4ke> pta2002: ^
08:08:39 <Psybur> :t map(\x -> sum $ [i/j | i <- x, j <- x, isInt $ i / j])
08:08:40 <lambdabot> error:
08:08:40 <lambdabot>     Variable not in scope: isInt :: b -> Bool
08:09:03 <Psybur> @let isInt x = x == fromInteger (round x)
08:09:05 <lambdabot>  Defined.
08:09:10 <Psybur> :t map(\x -> sum $ [i/j | i <- x, j <- x, isInt $ i / j])
08:09:10 <frerich> Hm, I guess one would rather expect the bits in a different order, with the MSB at the left;
08:09:11 <lambdabot> RealFrac b => [[b]] -> [b]
08:09:12 <frerich> > [testBit (digitToInt n) i | n <- "c0", i <- [3,2,1,0]]
08:09:14 <lambdabot>  [True,True,False,False,False,False,False,False]
08:10:09 <s4ke> anyhow. cya
08:10:40 <Psybur> Any ideas on how to turn that RealFrac b into something else
08:10:44 <Psybur> Like Integral or something
08:10:53 <cocreature> :t floor
08:10:54 <lambdabot> (Integral b, RealFrac a) => a -> b
08:10:55 <cocreature> :t ceiling
08:10:56 <lambdabot> (Integral b, RealFrac a) => a -> b
08:11:01 <cocreature> :t roud
08:11:02 <lambdabot> error:
08:11:03 <lambdabot>     • Variable not in scope: roud
08:11:03 <lambdabot>     • Perhaps you meant ‘round’ (imported from Prelude)
08:11:04 <cocreature> :t round
08:11:06 <lambdabot> (Integral b, RealFrac a) => a -> b
08:11:14 <cocreature> those should be your 3 options
08:11:17 <Psybur> :t isInt
08:11:19 <lambdabot> RealFrac a => a -> Bool
08:12:09 <cocreature> there is also realToFrac but that doesn’t help if you want to convert to an Integral
08:12:32 <Psybur> So Im wondering how do I modify this: isInt $ i / j to make it so my signature isnt RealFrac b => [[b]]
08:12:41 <merijn> Note, round (properly) uses banker's rounding
08:13:02 <merijn> Which tends to confuse people used to primary school rounding
08:13:39 <Psybur> :t a b -> isInt $ (fromIntegral a) / (fromIntegral b)
08:13:40 <lambdabot> error: parse error on input ‘->’
08:13:45 <Psybur> :t \a b -> isInt $ (fromIntegral a) / (fromIntegral b)
08:13:46 <lambdabot> (Integral a2, Integral a1) => a1 -> a2 -> Bool
08:14:33 <Psybur> :t map(\x -> sum $ [i/j | i <- x, j <- x, isInt $ (fromIntegral i) / (fromIntegral j)])
08:14:34 <lambdabot> (Fractional b, Integral b) => [[b]] -> [b]
08:14:43 <frerich> Psybur: Maybe the 'isInt' thing is a bit of a smell already. Did you maybe mean to use 'i `div` j' and test for 'integers' by checking that 'i `mod` j == 0'?
08:14:55 <Psybur> Ah, forgot about div
08:15:14 <Psybur> And mod
08:15:25 <Psybur> >.>; thanks frerich
08:16:06 <Psybur> :t map(\x -> sum $ [i `div` j | i <- x, j <- x, i `mod` j == 0)])
08:16:08 <lambdabot> error: parse error on input ‘)’
08:16:13 <Psybur> :t map(\x -> sum $ [i `div` j | i <- x, j <- x, i `mod` j == 0])
08:16:15 <lambdabot> Integral b => [[b]] -> [b]
08:16:17 <Psybur> Woot
08:30:18 <fakenullie> > isInt $ 3.0
08:30:20 <lambdabot>  True
08:38:14 * geekosaur wonders what you thought the $ was supposed to be doing there
08:40:48 <monochrom> It is doing the same thing as waving a magic wand.
08:41:10 <Clint> entertaining everyone?
08:42:04 <geekosaur> or possibly scandalizing
08:42:25 * hackage yoga 0.0.0.2 - Bindings to Facebook's Yoga layout library  https://hackage.haskell.org/package/yoga-0.0.0.2 (Mokosha)
08:51:57 <fakenullie> can you make isInt fail?
08:52:50 <mniip> :t isInt
08:52:51 <lambdabot> RealFrac a => a -> Bool
08:53:22 <mniip> @check (\d -> d isInt `seq` True)
08:53:24 <lambdabot>  error:
08:53:24 <lambdabot>  • No instance for (Typeable t0) arising from a use of ‘myquickcheck’ • In th...
08:53:31 <mniip> @check (\d -> (d :: Double) isInt `seq` True)
08:53:32 <geekosaur> define 'fail'
08:53:33 <lambdabot>  error:
08:53:33 <lambdabot>  • Couldn't match expected type ‘(Double -> Bool) -> t0’ with actual type ‘Do...
08:54:36 <monochrom> mniip: Why is it "d isInt" not "isInt d"?
08:54:47 <mniip> I didn't wake up yet
08:54:53 <mniip> @check (\d -> isInt (d :: Double)  `seq` True)
08:54:55 <lambdabot>  +++ OK, passed 100 tests.
08:55:24 <monochrom> You are not alone. Group theorists put the parameter on the left, too.
08:57:25 <mniip> those filthy one-object-groupoid-studiers
09:00:02 <pta2002> So, I'm back
09:00:10 <pta2002> where did that hex function come from?
09:00:15 <pta2002> I looked a bit into lens
09:00:25 <pta2002> You did "abc" ^? hex
09:00:32 <pta2002> > :i hex
09:00:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
09:00:40 <pta2002> % :i hex
09:00:41 <yahb> pta2002: hex :: Integral a => Prism' String a -- Defined in `Numeric.Lens'
09:00:49 <pmade> I'm starting to use Opaleye.  Is it possible to call PostgreSQL functions such as CURRENT_TIMESTAMP in a restriction? (i.e. add a where clause comparing a column to the current time.)
09:00:57 <pta2002> ah there we go
09:24:19 <p0a> Hello where can I read more about memoization?
09:25:38 <monochrom> Here, https://wiki.haskell.org/Dynamic_programming_example
09:28:32 <p0a> monochrom: I think I get it. I have to do the memoization myself basically right?
09:29:00 <p0a> I just got the impression from the fib examples that in fact there was something in the language that made it easier for me
09:30:07 <p0a> This looks good http://jelv.is/blog/Lazy-Dynamic-Programming/
09:30:24 <monochrom> You have to do it yourself or use a library --- there are several on hackage.
09:30:59 <mniip> ayy monochrom have you seen my shiny new package
09:31:07 <monochrom> No.
09:31:11 <mniip> http://hackage.haskell.org/package/singleton-typelits
09:31:20 <geekosaur> p0a, there's some shortcuts you can sometimes use due to laziness. it is not a general feature, and misuse of it can lead to severe memory leaks
09:31:41 <geekosaur> (basically, lazy self-references. get it wrong and you keep a lot of stuff in memory that doesn't need to be kept)
09:31:53 <p0a> Ah that is good to know 
09:32:01 <p0a> well I'm all for misuse -- that's the way to learn
09:32:39 <p0a> so the reference count doesn't drop to 0 or something
09:32:47 <p0a> or maybe stays positive for too long
09:33:10 <geekosaur> so for fib, the trick is you are making a list where later values in the list can use earlier values, and laziness keeps the whole list around and avoids recalculating the earlier values when making the later ones
09:33:10 <p0a> It's good to know these are shortcuts. I think I get it more now
09:33:33 <p0a> Right, I see it now 
09:35:06 <p0a> so for factorial its useless
09:35:18 <p0a> since it's a linear structure, but fib produces a tree structure 
09:35:23 <p0a> with many references to the same value
09:35:49 <geekosaur> actually it's just as good for factorial. fib has two self-references per iteration, factorial has one
09:36:48 <pta2002> Anyone did http://adventofcode.com/2017/day/14 part 2?
09:36:53 <pta2002> I'm wondering how I'd go about doing it
09:37:13 <pta2002> I basically have a bunch of bits in a 2D grid, and I need to find groups of adjacent 1 bits
09:37:21 <glguy> pta2002: You already have the knot hash implemented?
09:37:28 <pta2002> glguy: yes
09:37:36 <pta2002> kinda slow but I do, I did it for day 10 already
09:38:02 <glguy> I kept the rows of the grid in an Integer and used testBit to check if a bit was set or not in the hash
09:38:14 <mniip> I did concatMap testBit
09:38:26 <pta2002> alright, but I have part 1
09:38:29 <pta2002> I want to know how to do part 2
09:38:39 <mniip> that needs some sort of search
09:38:41 <mniip> like a dfs
09:38:47 <glguy> Did you do Day12?
09:38:53 <pta2002> glguy: I think so
09:39:08 <pta2002> oh this was the one I didn't really know how to
09:51:42 <Psybur> Is there a builtin that turns [a,b,c,d] into [(a,b),(a,c),(a,d),(b,c),(b,d),(c,d)]
09:52:57 <Psybur> or similar
09:53:57 <m0rphism> how can I spawn a process and read its stdout *while* it is running?
09:54:09 <EvanR> System.Process
09:54:39 <m0rphism> if I repeatedly pull the stdout handle after running createProcess/createProcess_ it always waits until the process has exited
09:54:58 <m0rphism> do I need to run createProcess in a thread an create my own handles up front?
09:55:40 <aberrant> > [(x, y) | x <- [1,2,3,4], y <- [1,2,3,4], x < y]
09:55:42 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:55:49 <aberrant> (to Psybyr)
09:55:54 <aberrant> er, Psybur
09:56:05 <EvanR> m0rphism: "pull" ?
09:56:05 <Psybur> aberrant, not guaranteed to be sorted :D
09:56:14 <m0rphism> I pull on the processes out handle via hReady, hIsEOF and hGetLine
09:56:25 <m0rphism> EvanR: sorry, I meant reading from it
09:56:38 <m0rphism> where "it" is eg the processes out handle
09:56:43 <aberrant> Psybur: then instead of x < y, use something that gives you the index of the element in the list and compare that.
09:56:43 <EvanR> you might have buffering set to block
09:56:52 <cocreature> pta2002: I walked over all positions accumulating a list of sets of positions and for each position I checked if it was already in one of the sets. if so I just continue, otherwise I create a new set for that region and add it to the list
09:57:00 <EvanR> which will only output data once the amount goes past the buffer size or it exits
09:57:02 <Psybur> >  map (\(x:xs) -> map (\y -> x : y : []) xs) $ filter ((>1) . length) $ L.tails [1,2,3,4]
09:57:03 <cocreature> pta2002: for finding the reasons I used State (Set Position)
09:57:03 <lambdabot>  error:
09:57:04 <lambdabot>      Not in scope: ‘L.tails’
09:57:04 <lambdabot>      Perhaps you meant one of these:
09:57:07 <Psybur> >  map (\(x:xs) -> map (\y -> x : y : []) xs) $ filter ((>1) . length) $ tails [1,2,3,4]
09:57:09 <EvanR> set buffering to line mode
09:57:09 <lambdabot>  [[[1,2],[1,3],[1,4]],[[2,3],[2,4]],[[3,4]]]
09:57:32 <m0rphism> EvanR: I've tried `hSetBuffering outHandle NoBuffering`
09:57:37 <EvanR> in the child?
09:57:48 <pta2002> cocreature: care to send me the code?
09:57:51 <EvanR> and wouldnt it be inHandle
09:58:00 <EvanR> (in the parent)
09:58:04 <Psybur> > concat $ map (\(x:xs) -> map (\y -> x : y : []) xs) $ filter ((>1) . length) $ tails [1,2,3,4]
09:58:06 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
09:58:17 <m0rphism> EvanR: on the handle returned by createProcess for the processes output
09:58:18 <mnoonan_> @let psybur = concat . (zipWith (map . (,)) <*> (drop 1 . tails))
09:58:20 <lambdabot>  Defined.
09:58:20 <Psybur> Wonder if theres a cleaner way to do that
09:58:26 <mnoonan_> > psybur [1..4]
09:58:28 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
09:58:33 <EvanR> m0rphism: set buffering on stdout in the child process
09:58:39 <Psybur> teehee Im honored to have such a function named after me ;p
09:58:48 <cocreature> pta2002: sure although I’d recommend to try it yourself first https://gist.github.com/cocreature/0df44b7cbdb216d734a626dcaca8e559
09:59:08 <pta2002> yeah I just have no idea how I'd do it in haskell
09:59:38 <pta2002> what does concatMap do?
09:59:48 <Psybur> :t concatMap
09:59:50 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
10:00:02 <m0rphism> EvanR: I think I did that, but thanks
10:00:06 <cocreature> the docs should be pretty clear
10:00:07 <Psybur> Seems like a flat map
10:00:40 <Psybur> > concatMap (\x -> [x,x]) [1,2,3]
10:00:42 <lambdabot>  [1,1,2,2,3,3]
10:01:10 <m0rphism> EvanR: So as far as you there is no need to create a thread for this usage of createProcess, am I correct?
10:01:35 <Psybur> > concatMap (\(x:xs) -> map (\y -> x : y : []) xs) $ filter ((>1) . length) $ tails [1,2,3,4]
10:01:36 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
10:01:43 <EvanR> m0rphism: no, how would a thread help?
10:02:00 <pta2002> cocreature: how does this work?
10:02:01 <Psybur> > concatMap (\(x:xs) -> map (\y -> (x, y) xs) $ filter ((>1) . length) $ tails [1,2,3,4]
10:02:03 <lambdabot>  <hint>:1:87: error:
10:02:03 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:02:05 <EvanR> though, do make sure youre running with -threaded nonetheless
10:02:12 <Psybur> > concatMap (\(x:xs) -> map (\y -> (x, y)) xs) $ filter ((>1) . length) $ tails [1,2,3,4]
10:02:14 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
10:02:16 <cocreature> pta2002: what’s “this”?
10:02:23 <pta2002> part 2
10:02:32 <pta2002> how's that finding regions?
10:02:38 <pta2002> oh wait allRegions, I missed that
10:02:40 <cocreature> take a look at getRegion
10:02:48 <cocreature> that finds a single region starting at the given position
10:02:52 <glguy> There's always fgl
10:03:00 <pta2002> v is just a vector with all the hashes right?
10:03:16 <m0rphism> EvanR: I thought that maybe `createProcess` would wait for the process to finish before returning, so maybe I had to create handles beforehand and pass them to both the thread that runs createProcess and the main thread that repeatedly reads the childs stdout
10:03:36 <m0rphism> EvanR: I'll check for -threaded, thanks
10:03:36 <EvanR> i dont buy that theory
10:03:39 <monochrom> No, createProcess doesn't wait for the child process to finish.
10:03:51 <cocreature> pta2002: no v is the grid
10:03:58 <m0rphism> monochrom: thanks for the confirmation
10:04:07 <EvanR> there is a function in that lib that spawns a thread and waits for the child to finish
10:04:23 <pta2002> cocreature: so, a vector with all the hashes?
10:04:44 <monochrom> If you aren't reading anything from the child, it means the child has not written. Logically.
10:04:46 <cocreature> yes
10:04:59 <EvanR> or it is still buffering
10:05:03 <geekosaur> m0rphism, you probably want tolook at the ';stdbuf' command in coreutils
10:05:23 <geekosaur> the problem here is that most programs buffer output when writing to non-terminals
10:05:36 <geekosaur> *you* cannot control that; it's done in the other program
10:05:57 <geekosaur> not in your code that launches the program
10:05:59 <monochrom> The child can very well has its own big-buffering policy such that it doesn't write until either it has accumulated either 1TB to write or it has to quit. And this is something you, the parent, can do nothing about. Give up all hope now.
10:06:12 <m0rphism> geekosaur: for my pruposes it would suffice if it would arrive in the same chunks it would arrive in the interative terminal manually
10:06:32 <geekosaur> right, so you have to tell the program to set line buffering
10:06:56 <geekosaur> you can;t do that in the haskell code, that sets a haskell buffer for the current program, not the buffering that will be used by the program you run
10:07:06 <m0rphism> geekosaur: I've used `hSetBuffering childProcOutHandle NoBuffering` but that did not help
10:07:14 <m0rphism> geekosaur: oh i see
10:07:55 <geekosaur> gnu stdbuf uses a hack to tell glibc to force buffering on/off for some handle (as such this trick won't work for running a haskell program)
10:08:22 <EvanR> oh that sounds icky
10:08:25 <geekosaur> it is
10:08:41 <geekosaur> but it;s often the only way you have to trick a program into buffering the way you want it to
10:08:55 <m0rphism> geekosaur: so how do terminals like xterm handle this then? do they use something like this hack?
10:09:02 <geekosaur> unless you want to try to force createProcess to use a pty instead of a pipe, but that has other problems
10:09:23 <EvanR> i have run many programs on xterm which do not output until 1024 bytes were written
10:09:33 <EvanR> and so confused me
10:09:36 <geekosaur> they use a pty, a thing that behaves like a terminal in some ways but like a pipe in others ("pseudoterminal")
10:10:10 <m0rphism> EvanR: yeah, but that would be fine in my case, the problem is that I receive literally no output until the process has finished
10:10:14 <geekosaur> but, because it behaves like a terminal, if yoiu try to shove non-text through it then you can get surprises
10:10:52 <m0rphism> geekosaur: interesting, thanks for the info
10:10:58 <EvanR> m0rphism: ... have you tried to modify the child program
10:11:13 <geekosaur> in particular, if you write a \n through it the reader will get \r\n unless you tweak the tty modes
10:11:38 <m0rphism> EvanR: Modify it in what way?
10:12:02 <geekosaur> you'd have to tdo the equivalent of that hSetBuffering call in the code for the child
10:12:02 <EvanR> two people suggested to set buffering mode of stdout in the child to line buffering
10:12:05 <pta2002> cocreature: how does the getRegion function work?
10:12:15 <pta2002> It's using State right?
10:12:16 <geekosaur> for a C program, this is setvbuf()
10:12:43 <cocreature> pta2002: as I’ve said before, yes it uses State :)
10:12:56 <pta2002> sorry, I don't know much about how State works
10:12:58 <pta2002> care to explain it
10:13:09 <m0rphism> EvanR: Do you know how I can do this? I thought I did that via hSetBuffering
10:13:12 <pta2002> what'll execState do?
10:13:18 <pta2002> I'm assuming get gets the state?
10:13:31 <EvanR> what language is the child process written in
10:13:35 <pta2002> :t execState
10:13:36 <lambdabot> State s a -> s -> s
10:13:45 <cocreature> it takes an initial state and returns the final state
10:13:51 <EvanR> if its not haskell hSetBuffering probably wont work
10:14:07 <pta2002> cocreature: but you're not passing it anything?
10:14:17 <pta2002> it's just s <- get
10:14:17 <geekosaur> EvanR, I think m0rphism still does not quite get the difference between doing it in the Haskell code that connects to the program, vs. doing it in the program itself
10:14:21 <pta2002> shouldn't it take 2 parameters
10:14:26 <cocreature> I was talking about execState not get
10:14:29 <pta2002> ah
10:14:39 <cocreature> get simply returns the current state as you’ve already noticed
10:14:42 <geekosaur> and thta this can only work in the program itself
10:14:58 <EvanR> if you say something enough times it becomes true
10:15:11 <geekosaur> the C equivalent of that hSetBuffering call is: setvbuf(1, _IONBF, 0);
10:15:11 <m0rphism> EvanR: Oh, yes that is unfortunately the case
10:15:23 <pta2002> when is an if statement without the else part right?
10:15:24 <EvanR> so no you have not tried to modify the child program
10:15:37 <geekosaur> which you would jhave to add to the source of the child program and build it
10:15:39 <pta2002> ...expression I guess?
10:15:46 <geekosaur> *rebuild it
10:17:30 <EvanR> apparently the buffering thing is completely unknown to ruby...
10:17:39 <EvanR> cant find any reference to it
10:18:13 <Rembane> It just ignores buffers?
10:18:28 <EvanR> no idea
10:19:15 <m0rphism> geekosaur: EvanR: I see, thanks for the help you two! Sorry for the confusion, I should probably get some slepp... ;)
10:19:15 <pta2002> cocreature: modify will modify the state right?
10:20:43 <geekosaur> this kind of thing *is* fairly confusing. there's a difference between Handle stuff done by a language runtime (buffering) vs. that done by the OS (Unix ioctls and such)
10:21:09 <pta2002> I think I got it, thanks cocreature 
10:21:32 <geekosaur> you can do the latter before the child runs, but the former has to be done where the program's own runtime can see it, not where *your* program's runtime will see it
10:27:36 <mnoonan_> @let psybur = ((zip <*> drop 1 . tails) >=> (uncurry ((<$>).(,)))) -- hey look, I made your function worse! :)
10:27:38 <lambdabot>  .L.hs:167:1: error:
10:27:38 <lambdabot>      Multiple declarations of ‘psybur’
10:27:38 <lambdabot>      Declared at: .L.hs:166:1
10:29:46 <Psybur> mnoonan_, D:
10:36:41 <monochrom> Generally, many parents don't grok the fact that children have their own ideas.
10:56:15 <rightfold> Mine certainly didn’t, and I still suffer the consequences to this day.
11:01:14 <mnoonan_> Psybur: since my C++ project is still building, I made some more improvements and got rid of that ugly "uncurry" function..
11:01:32 <mnoonan_> @let psybur2 = zip <*> drop 1 . tails >=> (<*> snd) ((<$> fst) ((<$>) <$> (,)))
11:01:33 <lambdabot>  Parse failed: Ambiguous infix expression
11:01:38 <Psybur> :P
11:01:47 <mnoonan_> @let psybur2 = (zip <*> drop 1 . tails) >=> (<*> snd) ((<$> fst) ((<$>) <$> (,)))
11:01:49 <lambdabot>  Defined.
11:01:54 <mnoonan_> > psybur2 [1..4]
11:01:56 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
11:02:10 <Psybur> > psybur2 [1..5]
11:02:12 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
11:02:15 <Psybur> > psybur2 [1..]
11:02:17 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13)...
11:02:43 <Psybur> > psybur2 [[1..4],[5..6]]
11:02:45 <lambdabot>  [([1,2,3,4],[5,6])]
11:04:10 <mnoonan_> :t (<*> snd) . (<$> fst) -- <-- I'm unreasonably happy with this
11:04:12 <lambdabot> (a1 -> a2 -> b) -> (a1, a2) -> b
11:04:25 <mniip> eww
11:04:33 <Psybur> Unreasonably? xD
11:05:11 <mniip> :t \x -> liftA2 x snd fst
11:05:13 <Psybur> :t uncurry
11:05:13 <lambdabot> (a1 -> a2 -> c) -> (a2, a1) -> c
11:05:14 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:06:09 <Psybur> why not just use uncurry?
11:06:56 <mnoonan_> so pedestrian ;)
11:12:33 <boojinks> Hi all. Is there any particular reason that cabal would struggle when installing a package globally but will happily install it in a sandbox?
11:14:05 <glguy> If you already have some of the dependencies installed it will attempt to use those versions of them, if the package you're trying to build doesn't support that version but also doesn't exclude it with version bounds, that could cause a problem
11:14:05 <[exa]> boojinks: what do you mean by 'struggle'? (like, an error message, or a prolonged fight to do so)
11:15:13 <boojinks> [exa]: sorry, as an example I'm trying to install happy. If I do it in a sandbox, there are no issues at all. If I do it globally, it complains about being unable to find modules in Control.Monad (e.g. Writer, Except) saying there are files missing in the mtl-2.2.1 package.
11:15:58 <glguy> boojinks: If your globally installed mtl is broken then that will certainly be a problem for anything that uses it
11:16:06 <glguy> while in the sandbox it would have reinstalled a local copy
11:17:44 <[exa]> boojinks: np :] maybe the global mtl package comes from your distribution's package manager?
11:17:59 <glguy> boojinks: Are you using ArchLinux?
11:18:08 <boojinks> [exa]: yes. glguy: yes.
11:18:23 <glguy> As usual, ArchLinux is broken. There's probably a wiki page on what they did
11:18:36 <[exa]> boojinks: you might want to delete the mtl from arch and retry
11:18:38 <glguy> They don't install the static libraries, only the dynamic ones now, or something like that
11:19:11 <koz_> Yeah - you shouldn't use pacman-installed Haskell anything.
11:19:47 <boojinks> glguy: I have installed the static versions but I guess I could always try getting hold of things directly and bypass the arch packages. Maybe that'll fix my problem.
11:20:07 <koz_> Get stack-static from the AUR, and install everything that way. Also, watch out for https://github.com/commercialhaskell/stack/issues/3648
11:20:41 <koz_> (I got bitten by that just yesterday, wasting considerable amounts of my time, argh)
11:21:25 <glguy> On the upside, even though it doesn't work, arch is using less disk space. So it's a tradeoff
11:21:48 <[exa]> less work, more free space, yay. :]
11:21:51 <mud> Arch is seriously such a mess.
11:21:55 <shapr> is there a cabal new-install?
11:22:09 <koz_> mud: In my case, this is the first time in years of use I've had such issues with it.
11:22:30 <koz_> It is frustrating, but at least in my case, it's never been half as broken as many people claim.
11:22:31 <shapr> also, is there a graphql *client* in Haskell or are there only servers?
11:22:35 <koz_> Maybe just luck on my part.
11:24:20 <mud> koz_: All I know is I see more bugs from arch people than I do from every other single platform combined, including windows.
11:25:48 <[exa]> mud: that actually can be a good thing, if the bugs are valid
11:25:49 <MarcelineVQ> It's almost like there's a price for living on the edge of releases
11:26:08 <mud> [exa]: They're caused by arch's wacky choices, as far as I can tell.
11:26:22 <[exa]> mud: expected that. :D
11:26:50 <aberrant> Psybur: sorry for the delay: [(fst x, fst y) | x <- zip l [0..], y <- zip l [0..], snd x < snd y]
11:27:42 <aberrant> > [(fst x, fst y) | x <- zip ["a","b","c","d"] [0..], y <- zip ["a","b","c","d"] [0..], snd x < snd y]
11:27:44 <lambdabot>  [("a","b"),("a","c"),("a","d"),("b","c"),("b","d"),("c","d")]
11:28:41 <hexagoxel> mud: does this extend to non-haskell related arch stuff?
11:29:15 <maerwald> yes
11:29:35 <mud> hexagoxel: The only part I would know about is haskell related. My impression is that they broke haskell stuff worse than others, but I wouldn't really know either way honestly.
11:29:54 <maerwald> not doing extensive testing is part of the philosophy, not inability
11:30:05 <maerwald> although there is some of the latter too
11:30:39 <maerwald> but not significantly more than anywhere else
11:31:38 <Psybur> Actually used unfold for the first time :o
11:31:41 <Psybur> > L.unfoldr (\b -> Just(b+1,b+(b+8))) 8
11:31:43 <lambdabot>  error:
11:31:43 <lambdabot>      Not in scope: ‘L.unfoldr’
11:31:43 <lambdabot>      Perhaps you meant one of these:
11:31:46 <Psybur> > unfoldr (\b -> Just(b+1,b+(b+8))) 8
11:31:48 <lambdabot>  [9,25,57,121,249,505,1017,2041,4089,8185,16377,32761,65529,131065,262137,524...
11:32:06 <Psybur> I wonder if anybody realizes what Ive been doing
11:34:28 <Psybur> what a lovely bit of spam im getting >.>
11:36:35 <aberrant> Psybur: was my code not what you were looking for?
11:36:45 <aberrant> (I'm still learning.)
11:36:55 <Psybur> aberrant, oh gosh sorry
11:36:58 <Psybur> That wasnt meant for you
11:37:11 <Psybur> I was talking about the PM spam
11:37:12 <aberrant> oh, no worries, I didn't think it was
11:37:17 <aberrant> I'm just looking for feedback.
11:38:15 <Psybur> aberrant, I actually ended up using a version of your first code.
11:38:21 <aberrant> neat!
11:38:34 <Psybur> Turns out that the order wasnt important
11:38:38 <aberrant> but my second code handles the unsorted list.
11:39:16 <Psybur> So I just needed to find the two values in the list that had a `mod` of 0, and the greater value had to come first
11:42:05 <p0a> so is fibs = 0:1:zipWith (+) fibs (drop 1 fibs) a memoized version?
11:42:41 <Psybur> Wouldnt it be cool if we could do something like 262137 `flip (-)` 524281
11:43:15 <p0a> geekosaur: computing the factorial fac n = n * fac (n-1) I don't see why you'd need memoization. You don't gain anything right?
11:43:29 <p0a> Psybur: what does that do
11:43:34 <mud> p0a: Depends on your definition of memoization I guess. I would call it using dynamic programming. Or more importantly, it does O(n) addition operations to compute the first n elements of the list.
11:44:15 <p0a> I see 
11:44:27 <mud> p0a: If you compute a total of one factorial ever, you wouldn't gain any benefit from memoization, no.
11:44:31 <p0a> Okay, not interested in what it should be called, I'm just glad the technique is understandable now
11:44:48 <p0a> mud: oh okay so memoization actually remembers after the evaluation
11:44:56 <p0a> mud: because my version does not
11:45:00 <p0a> of fibs
11:45:01 <mud> If you implement it such that it does
11:45:32 <p0a> I see, in some way capturing the evaluations. How are memory leaks then avoided?
11:46:07 <mud> Usually they wouldn't be. Hence why blindly memoizing every function is not a good idea, or generally done.
11:46:12 <p0a> At some point fibs/fac will have to free the stored values and then computing fib n or fac n will again have to evaluate O(n) operations
11:46:17 <p0a> oh okay
11:46:31 <p0a> sigh that sounds like a malloc/free technique then
11:46:58 <p0a> you'd memoize but then "free" the memoization once you're done. perhaps just by writing multiple programs and letting the OS do the freeing
11:47:03 <mud> p0a: If you do "fib n" and then later do "fib n" again, it'll usually recompute. But if you do  blah = fac n  and then use 'blah' again many times, it won't be recomputed.
11:47:05 <vova> hi all
11:47:36 <p0a> mud: ? I never thought otherwise for blah
11:48:04 <p0a> mud: what are the memory leaks we're talking about then?
11:48:41 <p0a> mud: I thought I was talking about computing many 'fib n' expressions or with different n (using the previous ones to make it faster)
11:49:05 <mud> I was responding to "At some point fibs/fac will have to free the stored values and then computing fib n or fac n will again have to evaluate O(n) operations"
11:49:20 <mud> p0a: I'm not entirely clear what you're asking at the moment.
11:49:32 <crucify_me> hi curious as to why a textbook given to provide types for exercises, gives no type for this func and neither do various online solutions to it http://lpaste.net/360787
11:49:52 <p0a> I'm asking this: Suppose I have fac n. I want blah1 = fac n1 and blah2 = fac n2. Say n1 < n2, then it'd be nice if somehow fac decided to use it's knowledge of fac n1 to compute fac n2
11:49:55 <p0a> Is that not a thing?
11:52:12 <mud> p0a: It is if you write it such that it does, but you have to be a bit fancy to get it to work. For example if you wrote  allFacs = scanl' (*) 1 [1 ..]  and then  fac n = allFacs !! n   then it'll simply look up the answer in that list every time. You could do something similar using a different data structure such that it doesn't have to iterate through a list to answer either, but it gets more complicated.
11:53:00 <p0a> mud: okay so is the list free'd at any point?
11:53:09 <p0a> mud: is that something I don't have to worry about?
11:53:34 <mud> p0a: I don't think it'll ever be freed. It certainly won't be while it's still possible it could be used. I'm not sure how clever GHC is there.
11:54:08 <p0a> mud: so you're saying that anything that would free it would be specific to my compiler
11:54:56 <mud> I'm saying, haskell the language spec isn't real specific on that, as far as I know.
11:55:15 <p0a> mud: in C++ what I'd do is write the algorithm so that it receives an array of "computed" values and computes the rest, adding to the array. Maybe that array would be hidden from the interface
11:55:28 <p0a> okay well it was just a curiosity really. 
11:55:34 <mud> p0a: This ends up similar.
11:55:45 <p0a> The difference is the control over the array and when it is freed
11:56:02 <p0a> in spikes of activity I can retain the array, and free it when I judge that it'll be idle for a while
11:56:26 <p0a> activity = lots of computations
11:56:47 <mud> Yes, you end up with less detailed control doing this type of thing in haskell, this way. If you need the control, you could use something in IO and have more.
11:56:58 <p0a> right so mutable states
11:56:59 <p0a> I get you
11:57:01 <mud> But you're still at the whim of the garbage collector a bit past a certain point.
11:57:07 <mud> Gotta run
11:57:11 <p0a> thanks
11:58:52 <Average-user> HI, in day 14 to create the knot_hash of my key input, I should do what was necessary for part 2 of day 10 right?
11:59:25 <codeshot> Is there always at most one applicative transformation between an two applicatives, or do some pairs of applicatives have more than one applicative transformation from the first to the second?
11:59:37 <boojinks> [exa], glguy: surprise surprise with a binary copy of GHC directly from the Haskell site the installs work fine. Thanks for your help!
12:01:15 <codeshot> Intuitively I'm thinking there's at most one each time but I'm finding intuition can't always be trusted with this kind of thing
12:02:23 * hackage selda 0.1.11.2 - Type-safe, high-level EDSL for interacting with relational databases.  https://hackage.haskell.org/package/selda-0.1.11.2 (AntonEkblad)
12:10:07 <byorgey> codeshot: isn't  'reverse'  an applicative transformation from [] to itself?
12:10:50 <byorgey> well, I mean from the usual applicative structure on lists to the reverse one where you accumulate backwards
12:11:35 <byorgey> ok, I guess it depends whether by "applicative" you mean just the type, or the type + some particular applicative structure
12:12:20 <byorgey> Average-user: yes
12:15:25 <byorgey> codeshot: ah, here's a better example.  Consider the functions   t1, t2 :: [a] -> Maybe a  given by    t1 [] = Nothing; t1 (x:_) = Just x     t2 [x] = Just x; t2 _ = Nothing
12:15:37 <byorgey> I *think* these are two different applicative transformations  [] -> Maybe
12:18:53 <byorgey> the second one is a valid applicative transformation because if  f <*> x  in the [] Applicative  has more than 1 element, then either f or x must have more than 1 element
12:25:35 * hackage disjoint-containers 0.2.3 - Disjoint containers  https://hackage.haskell.org/package/disjoint-containers-0.2.3 (andrewthad)
12:33:56 <dsal> I was reading https://hackernoon.com/strong-typing-is-for-people-with-weak-memories-8d002436649e this morning and it reminded me of something I saw in passing about formal verification of haskell functions via coq or something like that.  Does anyone know what I'm talking about?  :)
12:36:29 <shapr> dsal: https://www.joachim-breitner.de/blog/734-Finding_bugs_in_Haskell_code_by_proving_it ?
12:37:06 <EvanR> "monads are types (actually type classes)" ...
12:37:15 <fiatjaf> I'm trying to define CUSTOM TYPES in haskell (I know this is not the correct name, but I'm new here)
12:37:29 <fiatjaf> so I do `data User { id :: Text }`
12:37:55 <fiatjaf> and the compiler complains `id` is already defined, or something like that
12:37:59 <fiatjaf> why?
12:38:27 <aberrant> because `id` is part of Prelude or something?
12:38:31 <aberrant> it's a function.
12:38:39 <mnoonan_> faitjaf: record field names live in the same namespace as top-level names. and that includes the identity function "id".
12:38:40 <fiatjaf> and if I have `data User { email :: Text }` and then `data Organization { email :: Text }` it will complain again
12:38:41 <zenspider> Prelude> :t id
12:38:42 <zenspider> id :: a -> a
12:38:50 <fiatjaf> how am I supposed to handle this?
12:39:56 <zenspider> ...do organizations have email addresses? 
12:40:02 <mnoonan_> fiatjaf: this is a big wart with records. you can (1) use more verbose, unique names for your fields, (2) use the HasFoo typeclass idiom, or (3) use lenses. (did I forget any options?)
12:40:03 <fiatjaf> I'm writing a simple REST API with scotty, and I need to fetch some records from postgres and return them as JSON in a format that's already specified, including multiple kinds of entities with "email" fields and one with an "id" field.
12:40:12 <zenspider> Obviously you can prefix... 
12:40:30 <fiatjaf> zenspider, not actually organizations here, it's a different kind of user actually.
12:40:37 <mnoonan_> fiatjaf: also, if your types are defined in different modules, they you can qualify the field names when you need to disambiguate
12:41:01 <fiatjaf> I'm following a tutorial that says I must use "generics" for JSON generation with Aeson. I don't know what are my other options.
12:41:10 <aberrant> I didn't know that record fields are top-level. That seems shortsighted.
12:41:17 <fiatjaf> mnoonan_, but I'll never be able to use `id`, right?
12:41:40 <mnoonan_> fiatjaf: you can do "import Prelude hiding (id)", I suppose
12:41:47 <fiatjaf> oh.
12:43:24 <mniip> what should I use for a priority queue type of thing
12:44:13 <mniip> Data.Map.Lazy.minView?
12:44:25 <mniip> that has logn inserts and logn minimum removals?
12:44:36 <mniip> actuallsy Data.Set
12:46:15 <mnoonan_> mniip: you don't get any O(1) operations that way, if it matters to you
12:46:41 <zenspider> does scotty provide any sort of external -> internal name mapping?
12:46:47 <mniip> well right now I have, uh,
12:46:55 <mniip> you would think O(N) insertions and O(1) removals,
12:47:01 <mniip> but really it's O(1) insertions and O(N) removals
12:47:04 <mniip> because lazy
12:47:14 <mniip> (using a list)
12:47:35 <[exa]> randomized heaps?
12:47:56 <mniip> now I just need a Set with a custom comparator
12:48:03 <mniip> I suppose I could newtype it away...
12:49:35 <mnoonan_> anyway, iirc it isn't known how to make purely functional heaps as asymptotically efficient as imperative ones. maybe byorgey might know?
12:52:10 <byorgey> mnoonan_: wait, what do you mean by "heaps"?  why can't you make a purely functional heap that's just as efficient as imperative ones?
12:53:20 <byorgey> e.g. http://hackage.haskell.org/package/pqueue
12:56:15 <dsal> shapr: Thanks.  That looks interesting.
12:56:39 <mnoonan_> byorgey, maybe I'm misremembering something, because that looks pretty efficient.
12:58:49 <mnoonan_> byorgey: just found the relevant okasaki paper, I was wrong :|
13:05:43 <codeshot> byorgey, I'm not sure that t2 is an applicative transformation
13:06:11 <codeshot> oh, maybe it is
13:06:15 <codeshot> must think hard
13:10:36 <codeshot> byorgey, t2 ( pure (id) <*> pure (+1)) <*> (t2 [1,2,3]) -> Nothing
13:10:41 <codeshot> I don't think that's right
13:11:34 <codeshot> But maybe that's because I understand too little to form a concrete enough opinion :/
13:11:50 <codeshot> and then I'm filling in with bullshit
13:13:02 <codeshot> hm, no it seems to be right
13:14:07 <codeshot> I feel like Haskell needs a functionclass concept in addition to typeclass
13:14:23 <amalloy> i've written a library that i would like to reuse for a number of small personal projects. i don't want to publish it to hackage or anything, just make it available to my other stack projects on the same machine. how do i do that with stack?
13:17:08 <humanoyd> amalloy: you can add it under `packages` in stack.yaml
13:18:07 <amalloy> oh, i see. one valid format for packages is just a directory. i hadn't read the template stack.yaml file very carefully, sticking mainly to trying to understand cabal files
13:19:09 <amalloy> thanks
13:25:00 <humanoyd> amalloy: sorry, apparently I gave you outdated information...put it under `extra-deps`
13:25:06 <humanoyd> https://www.fpcomplete.com/blog/2017/07/stacks-new-extensible-snapshots
13:26:57 <fiatjaf> `instance FromRow ChecklistItem where fromRow = ChecklistItem <$> field <*> field <*> field <*> field`
13:27:03 <fiatjaf> what does this mean?
13:27:30 <fiatjaf> in the context of postgresql-simple?
13:27:37 <fiatjaf> where are `fromRow` and `field` defined?
13:28:37 <dsal> @hoogle fromRow
13:28:37 <lambdabot> Database.PostgreSQL.Simple.FromRow fromRow :: FromRow a => RowParser a
13:28:37 <lambdabot> Database.PostgreSQL.Simple.FromRow fromRow :: (FromRow a, Generic a, GFromRow (Rep a)) => RowParser a
13:28:37 <lambdabot> Database.SQLite.Simple fromRow :: FromRow a => RowParser a
13:29:11 <dmj`> http://hackage.haskell.org/package/postgresql-simple-0.5.3.0/docs/Database-PostgreSQL-Simple-FromRow.html#v:field
13:30:23 <aberrant> wow, my project euler code has horrible performance.
13:30:35 <aberrant> it's probably O(n^2)
13:30:53 <infinisil> could be worse
13:31:04 <aberrant> this isn't gonna terminate anytime soon
13:31:09 <aberrant> there's gotta be a better way.
13:31:21 <aberrant> prob3 n = head . filter isprime $ (factors n)
13:31:46 <fiatjaf> ok, so fromRow is a function that takes a FromRow (something that implements FromRow?) and returns something that implements RowParser?
13:32:00 <aberrant> isprime n = (length $ factors n) == 0
13:32:06 <infinisil> aberrant: wait what, why you taking factors and then checking whether they're prime?
13:32:19 <fiatjaf> field is a function that takes a FromField and returns a RowParser
13:32:20 <fiatjaf> ?
13:32:35 <aberrant> infinisil: What is the largest prime factor of the number 600851475143 ?
13:32:43 <fiatjaf> but what does that mean in the context of the line I pasted before?
13:33:24 <dsal> fiatjaf: Are you asking about applicatives?
13:33:25 <aberrant> infinisil: seems to me there's an easier way to do this :)
13:33:32 <infinisil> aberrant: All factors of the prime number factorization are primes
13:33:33 <fiatjaf> i believe I'll be able to understand that automatically from the definitions in some days/weeks/years, but for now a human explanation would be quite helpful
13:33:47 <aberrant> infinisil: factors n = reverse . filter (\x -> n `mod` x == 0) $ [2..(n `div` 2)]
13:33:58 <aberrant> not in my case.
13:34:05 <aberrant> factors != prime factors.
13:34:29 <aberrant> oh, wait. I see.
13:35:05 <aberrant> I can do this recursively.
13:35:11 <dsal> For all of my euler code, I've got an infinite list of prime numbers, and a smaller factors function.
13:37:36 <aberrant> you made a primes generator?
13:38:21 <dsal> I ended up pulling out patterns from various problems.  Lots of them had things related to prime numbers.
13:38:27 <dsal> I just made a list of all the prime numbers.
13:38:52 <fiatjaf> dsal: I'm not asking about applicatives exactly, I'm trying to understand what does that code do
13:39:08 <mud> I used to have one of those based on that o'neill paper. It worked pretty decent. I've since moved on to imperative sieves though, they're more performant and flexible.
13:39:23 <dsal> fiatjaf: I don't understand what you don't understand.  If you understand applicatives, then that's not your question.
13:39:38 <fiatjaf> I know it has to do with applicatives, but I don't know what is an applicative
13:39:54 <mud> Even a pretty naive imperative sieve is faster than a pure one by quite a lot, and you can do cute things like sieve ranges not starting at 1, etc.
13:40:06 <fiatjaf> I imagine that if I can understand what does that line means I'll get a better understanding of what is an applicative in the future
13:40:17 <fiatjaf> i'm a total newbie
13:41:20 <aberrant> is there a way to reference the list itself within a filter predicate?
13:41:54 <aberrant> I guess that doesn't make much sense.
13:41:56 <fiatjaf> (I come from Javascript, but since I had a good time coding a webapp in Elm I thought I would try to write my next small HTTP backend in Haskell)
13:42:15 <mud> aberrant: It's possible, you can refer to it like anything else. If it makes sense or not is another question.
13:42:16 <dsal> fiatjaf: Ah, OK.  Understanding applicatives would be helpful.   I'd really recommend the haskellbook for this.  The applicative chapter will beat you over the head with it.  It basically simplifies the error handling of the code.
13:44:11 <fiatjaf> ok, I'll see if I can read it.
13:44:16 <aberrant> isprime n = all (\x -> n `mod` x != 0) [1..(n `div` 2)]
13:44:26 <aberrant> er, 2..
13:44:45 <dsal> fiatjaf: I was going to try to give you a simple example, but the context is helpful.
13:44:50 <dsal> aberrant: why n `div` 2?
13:44:58 <fiatjaf> oh
13:45:05 <fiatjaf> but it's an enourmous book
13:45:14 <aberrant> dsal: because you don't need to test anything past n/2, since it won't be divisible.
13:45:39 <mud> aberrant: You also don't need to test anything past sqrt(n), because if you haven't found a factor yet, you won't find one.
13:45:40 <dsal> fiatjaf: It is.  Totally worth it, though, since it walks you through why things are they way they are as it explains to you what you'd have to do without them.
13:45:40 <fiatjaf> I've tried reading LYAHFGG in the past, read a good part of it
13:46:17 <fiatjaf> dsal, but don't you think I should try to get my hands dirty and do some things wrong before I can appreciate the wisdom of the book?
13:46:22 <aberrant> mud: ah, good point.
13:47:37 <dsal> fiatjaf: Sure, I wrote a bunch of haskell and am still going through the book.  However, you're asking about something that can't be expressed in most languages and it's a bit hard to explain applicatives without an understanding of functors so you can see how an operation across an operation in a functor and another functor might work.
13:48:33 <dsal> The stuff is all really pretty simple and simplifies your code a lot and makes things more readable, but at the same time, is somewhat foreign.
13:48:42 <mud> But that's still not a very good prime tester, except for small values. Better ones include those based on sieves, and miller-rabin can be done decently as well and will be *hugely* more effective than that one. (it's probabalistic, but it can be made deterministic for fixed ranges, like up to 2^64 with very little work).
13:48:54 <fiatjaf> ok, I get it.
13:49:13 <fiatjaf> the problem is that I don't have a code to be simplified. perhaps I should learn how to do it without applicatives first.
13:49:33 <dsal> Yes, you could do that without an applicative.  It'd just be a lot of code.  :)
13:49:46 <fiatjaf> I've taken that line from a tutorial in a web page.
13:50:02 <fiatjaf> the tutorial should have written it without applicatives.
13:50:13 <dsal> Why?  That'd be awful.
13:50:21 <fiatjaf> because then I would be able to understand it.
13:50:25 <dsal> The nice thing about the above is it's pretty easy to use and simple.
13:50:38 <dsal> Heh.  I can understand it a lot more easily when it doesn't have tons of unnecessary boilerplate.  :)
13:50:49 <dsal> Just requires some familiarity with the language.
13:50:57 <fiatjaf> exactly.
13:51:10 <fiatjaf> I'm trying to get some familiarity here.
13:51:34 <fiatjaf> maybe I should find another tutorial.
13:52:05 <dsal> Grab the book and start going through it.  It's the fastest path to enlightenment.  You'll save *so* much time.
13:53:15 <fiatjaf> have you done that?
13:53:27 <dsal> I'd written a few useful apps in haskell before I started going through it from the very beginning.  There are things I knew how to do, but didn't fully understand *what* they did until I started slogging through it.  I still end up with tons of dumb questions, but it's been totally worth it.
13:53:49 <fiatjaf> I want to do that.
13:53:56 <fiatjaf> write a few useful apps.
13:54:18 <fiatjaf> I don't believe I'll be able to fully grasp the book before that.
13:54:18 <aberrant> I'm getting a weird error
13:54:20 <aberrant> isprime n = all (\x -> n `mod` x /= 0) [2..(ceiling (sqrt n))]
13:54:46 <aberrant> "No instance for RealFrac Int..."
13:54:49 <aberrant> what is that?
13:54:49 <dsal> fiatjaf: It reduces struggles.  It doesn't increase them.
13:54:54 <dsal> aberrant: you can't sqrt an int.
13:54:55 <ertes> "the book"?
13:54:59 <glguy> aberrant: isprime :: (Integral a, RealFrac a, Floating a) => a -> Bool
13:55:02 <aberrant> dsal: ergh.
13:55:35 <ertes> > takeWhile (\x -> x*x < 100) [2..]
13:55:37 <lambdabot>  [2,3,4,5,6,7,8,9]
13:55:42 <glguy> aberrant: there are no integral, floating types without hacking one in
13:55:50 <mud> What ertes shows in the best way.
13:55:59 <ertes> not the best way, just a quick-n-dirty way
13:56:06 <ertes> the best way is to use an integer square root algorithm
13:56:18 <mud> Well, this is already quick and dirty, it won't even matter how long you spend on the sqrt really.
13:56:31 <aberrant> I can't even multiply n by 1.0
13:56:50 <mud> aberrant: This isn't C. If you want to convert to a different type, you have to use a function that does so.
13:57:01 <mud> (like fromIntegral)
13:57:04 <glguy> aberrant: No, you can't assuming that n is an Integral type
13:57:05 <dsal> > (ceiling . sqrt . fromIntegral)  (128::Int)
13:57:07 <lambdabot>  12
13:57:10 <aberrant> fromInt? I guess
13:57:16 <pta2002> http://lpaste.net/979862617822593024 what's the problem here?
13:57:24 <pta2002> it gives me a parse erorr on line 4
13:57:28 <glguy> pta2002: Looks like you forgot to paste the error 
13:57:31 <pta2002> hlint says last line must be expression
13:57:43 <pta2002> "error: parse error on input ‘s’"
13:57:46 <pta2002> ^ the error
13:57:48 <glguy> pta2002: line 4 is not indented enough
13:57:48 <pta2002> that's all it says
13:57:55 <pta2002> is it not?
13:57:58 <glguy> pta2002: line 4 is not indented enough
13:58:02 <pta2002> how far
13:58:07 <pta2002> does it need to goo
13:58:10 <glguy> further than the g in go
13:58:24 <pta2002> ah there we go
13:58:30 <pta2002> now I get a type error instead!
13:58:51 <pta2002> that was something else though, it's fixed
13:58:52 <mud> Sounds like an improvement. At least it gets past parsing.
13:58:55 <pta2002> tghanks glguy 
13:59:07 --- mode: ChanServ set +o dibblego
13:59:18 --- mode: dibblego set -o dibblego
13:59:34 <pta2002> what was that
14:00:23 <Tuplanolla> Don't use floating-point numbers to do an integer's job, aberrant.
14:00:30 <Tuplanolla> > floor (64 ** (1 / 3))
14:00:32 <pta2002> there we go!
14:00:33 <lambdabot>  3
14:01:01 <mud> Tuplanolla: It won't matter for this use. The code isn't going to work for anything even vaguely large anyway.
14:03:07 <EvanR> dont use Int to do integers job ?
14:04:14 <waterdrop> what does instance Monoid b => Monoid (a -> b) mean? Where would such a statement show up? sorry, I'm a beginner and reading through Haskell Programming
14:04:47 <dsal> That means that a function that returns a monoid is monoidal.  Super handy.
14:04:50 <glguy> waterdrop: Doesn't it explain what it does right in the text where it's introduced?
14:05:27 <waterdrop> glguy: I'm not sure. Not on the page I see it on, but I might have missed it earlier.
14:06:33 <mud> waterdrop: It means that if b is a Monoid instance, then so is (a -> b), for any a. It is particularly useful when you're defining a "comparison" function that has fallbacks. But it's a bit to unravel why that's true.
14:07:24 <mud> > sortBy (comparing fst <> comparing snd) [('b', 0), ('b', -1), ('a', 3)]
14:07:26 <lambdabot>  [('a',3),('b',-1),('b',0)]
14:08:14 <mud> Not sure any other time I've ever used that instance. I bet there is at least some other reason it might be helpful though.
14:10:48 <waterdrop> Hmm, so it means that the set of functions of type (a -> b) for any a are a monoid when we use the binary operator that makes b a monoid to construct functions? Ie, if f, g, h are three functions of type (a -> b) for any a and X is the binary operator that makes b a monoid and f X' g is the function h(y) = f(y) X g(y), then the functions of type (a -> b) and X' form a monoid
14:12:06 <mud> Sounds right
14:13:41 <waterdrop> mud: Okay I see why that's true but how do I "use this" in Haskell? Sorry if that's vague, I'm not sure how else to phrase it.
14:14:15 <waterdrop> I understand what it says math wise but I don't know what it enables me to do
14:14:18 <mud> Well, the thing I showed above is one practical example, though it's a bit involved why that works.
14:14:44 <amalloy> waterdrop: perhaps an easier example: you have two functions f and g that each return [String]
14:15:03 <amalloy> then f <> g is a function taking the same input, and concatenating the results of f x and gx
14:15:37 <mud> > let h = show <> show in h 5
14:15:40 <lambdabot>  "55"
14:16:11 <mud> > let h = show <> (reverse . show) in h 12345
14:16:13 <lambdabot>  "1234554321"
14:17:05 <waterdrop> ah I see. that helps. so basically Haskell is somehow built so that the functions with type (a -> b) where b is a monoid automatically have a monoid instance such that the <> operator does function addition using the monoid operation for b?
14:17:44 <mud> Yes, haskell has that because of that instance definition you saw, the one for Monoid b => Monoid (a -> b)
14:17:57 <waterdrop> ah I see
14:18:09 <waterdrop> does this instance definition appear in the Monoid typeclass?
14:18:59 <geekosaur> yes
14:19:11 <geekosaur> well, along with; you don''t put instances in class definitions
14:19:33 <geekosaur> it is one of the standard typeclasses though
14:19:36 <mud> https://www.stackage.org/haddock/lts-9.18/base-4.9.1.0/src/GHC-Base.html#Monoid it's in here, I'm not sure how to link to a specific line number though.
14:19:57 <waterdrop> geekosaur: Ya I'm aware you generally don't but this doesn't really seem like the same kind of instance as the other instances I've encountered
14:20:00 <pta2002> is there any function to get the index of the maximum element of a vector
14:20:00 <mud> If you search for "Monoid (a -> b)" you should find it. It's pretty much what you guessed it was though.
14:20:01 <waterdrop> mud: cool, thanks
14:20:10 <geekosaur> waterdrop, a function is a type in Haskell just like any other type
14:20:16 <geekosaur> it's not that uncommon
14:20:41 <geekosaur> this is one of the reasons Haskell can do more than e.g. python though, since it has more of this kind of flexibility
14:21:12 <mud> Yeah, you'd have a hard time writing this kind of thing in ... just about any common language I can think of.
14:21:22 <waterdrop> geekosaur: hmm I guess I meant this doesn't really seem like an "instance" to me? it's different from the other instances I've seen
14:21:28 <amalloy> waterdrop: it's a parametric instance definition, in that it depends on the Monoid constraint of b
14:21:29 <pta2002> geekosaur: to be fair, that's how functions are in python
14:21:30 <geekosaur> it;'s not really different
14:21:47 <geekosaur> you're still thinking in terms of functions somehow being fundamentally different things, so this kind of instance looks strange
14:22:01 <amalloy> in much the same way that, say, (Ord a, Ord b) => Ord (a, b) does
14:22:04 <geekosaur> it does have one other difference from other instances int hat it is infix
14:22:12 <mud> It's an instance that works for many different concrete types, but that's not that unusual. And yeah, in haskell function types aren't really special at all.
14:22:43 <geekosaur> instance Monoid b => Monoid ((->) a b) -- written prefix style, and yes you can write function types that way, it's just a PITA
14:23:30 <waterdrop> I don't think I'm thinking of function types as special. It's just that other instances seem to define what an operation or symbol that appears in the typeclass means for that instance
14:23:36 <waterdrop> this is more like stating an algebraic law?
14:23:39 <geekosaur> oh, right, you mean tyope vars instead of concrete types? we do that a lot too, actually. you probably notice the ones with concrete types more just because you need one for each type involved instead of being able to write a whole bunch of instances at the same time using a type variable like that
14:23:49 <waterdrop> I understand the math, just having trouble wrapping my head around it programming language wise
14:24:22 --- mode: cherryh.freenode.net set +o ChanServ
14:24:37 <geekosaur> Java and C++ can do that by means of generics and templates, respectively
14:24:44 <geekosaur> but the syntax is a lot heavier
14:25:18 <geekosaur> (also they're a lot more limited in where you can stick the parameter types)
14:25:47 <dmwit> waterdrop: The instance for `Monoid (a -> b)` still must define what the operations in the `Monoid` class mean for that instance. It's not just the one line, there's also
14:26:06 <dmwit> waterdrop: `... where mempty = const mempty; mappend f g x = mappend (f x) (g x)`.
14:26:26 <dmwit> waterdrop: So, just like other instances, it defines what an operation or symbol that appears in the typeclass means for the instance.
14:28:11 <kakashiAL> how is erlang compared with haskell?
14:28:30 <kakashiAL> when I google it, I always read that haskell is a research language
14:28:31 <Rembane> Not typed. :)
14:28:42 <Rembane> Haskell is very useful
14:28:51 <Rembane> ...in real usecases.
14:28:57 <mud> kakashiAL: Really? What places even say that?
14:29:35 <kakashiAL> mud: just some threads (if you google erlang haskell)
14:30:20 <geekosaur> mud, very old references or some things that copy them blindly
14:30:39 <geekosaur> Haskkell originally was an open source alternative to the commercial research language Miranda
14:30:40 <ertes> kakashiAL: erlang is designed around concurrency and has some features that haskell lacks…  for example the run-time system can hot-replace running components
14:30:52 <ertes> kakashiAL: you can *kinda* get something like that in haskell, but it's more work
14:31:08 <ertes> kakashiAL: as for the concurrency itself, haskell is probably superior
14:31:46 --- mode: cherryh.freenode.net set +o ChanServ
14:31:59 <geekosaur> I should say closed source instead of commercial because, being a research language, it was not exactly something you'd see in normal use
14:32:14 <ertes> haskell is a fully compiled language and gives you a lot of freedom in designing your own concurrency frameworks…  erlang is a lot more opinionated/limited on concurrency patterns
14:32:37 <kakashiAL> ertes: I have to spend more time with haskells concurrency model (I only worked with javas and javascripts)
14:32:53 <ertes> kakashiAL: more time on what?
14:33:06 <geekosaur> erlang was designed to easily and efficiently handle the kind of concurrency situations you get when programming a software phone switch (as in the gear on the telco end of youtr landline)
14:33:11 <kakashiAL> concurrency in haskell
14:33:37 <waterdrop> Sorry just to double check that mental model for the instance Monoid b => Monoid (a -> b) statement in the Monoid typeclass. So pretty much all this is doing is stating that if I have a type b that has an instance of Monoid, then all functions of type (a -> b) for any type a automatically get a Monoid instance with mempty and mappend having the meanings stated in that instance definition
14:33:43 <ertes> kakashiAL: that's a very general statement, and at that level of generality it's false
14:33:45 <kakashiAL> geekosaur: yep, whatsapp is implemented with erlang AFAIK
14:33:52 <geekosaur> waterdrop, yes
14:34:03 <waterdrop> cool, that makes sense to me now :)
14:34:07 <waterdrop> thank you guys so much
14:34:30 <waterdrop> I've never seen this kind of stuff in any other language…it's like a concrete implementation of abstract algebra
14:34:31 <kakashiAL> are there big projects implemented with haskell, I mean webprojects
14:34:42 <Rembane> kakashiAL: Facebook's spam filter.
14:34:47 <geekosaur> waterdrop, that is actually what inspired Haskell's syntax, yes
14:34:51 <mud> waterdrop: Ya, it's pretty badass IMO :)
14:35:19 <Rembane> kakashiAL: This book is about concurrency and parallellism in Haskell: http://chimera.labs.oreilly.com/books/1230000000929/index.html
14:35:34 <kakashiAL> Rembane: I know, are there more webapis/projects that you know?
14:36:24 <amalloy> kakashiAL: how many would you have to be shown to conclude that haskell is a real language?
14:36:32 * hackage dhall 1.8.2, morte 1.6.13 (GabrielGonzalez): https://qbin.io/c8zmuaujw
14:36:49 <geekosaur> kakashiAL, I'd say Haskell's current "killer apps" are pandoc and to a lesser extent git-annex
14:37:08 <geekosaur> but pandoc is showing up in a lot of surprising places these days
14:37:10 <Rembane> kakashiAL: xmonad, git-annex, the compiler for Purescript.
14:37:30 <geekosaur> not sure *any* tiling wm counts as a major app. it's very much a niche
14:37:55 <waterdrop> kakashiAL: you can take a look at https://galois.com/about/haskell/
14:38:03 <fiatjaf> the Elm compiler
14:38:06 <mud> yesod I've seen a place or two in production, not sure that really counts though.
14:39:00 <waterdrop> one of the lead programmers at that Galois company also has a bunch of slides somewhere titled 10+ years with Haskell, talking about how they pretty much entirely use Haskell for a lot of problems where correctness is really important :) it's actually part of what inspired me to try learning the language
14:39:02 <Rembane> geekosaur: Fair enough. I'm living in a bubble. :)
14:39:55 <waterdrop> here are the slides actually https://www.scribd.com/doc/19502765/Engineering-Large-Projects-in-Haskell-A-Decade-of-FP-at-Galois
14:40:37 <kakashiAL> https://medium.com/@saurabhnanda/why-building-web-apps-in-haskell-is-harder-than-it-ought-to-be-c9b13de0be4f
14:42:17 <ertes> as for long-lived applications there are gitit (a web wiki) and xmonad
14:42:35 <ertes> pandoc is great, but it's a batch application
14:42:50 <kakashiAL> http://jekor.com/article/is-haskell-a-good-choice-for-web-applications
14:43:44 <kakashiAL> please have patience with me and see my statements or questions as an attack
14:44:30 <kakashiAL> while reading some articles of haskell fans, they always say the same: its hard to do webapps/webservices with haskell
14:45:27 <kakashiAL> haskell is good for data processing (thats facebook uses it for spam filtering) but I never read something positive abut webbapps or webservices
14:45:46 <Rembane> kakashiAL: Have you read anything about Yesod?
14:45:56 <kakashiAL> no sir
14:46:00 <mniip> I wonder what really are the performance characteristics of Data.Set operations
14:46:04 <mniip> considering the laziness
14:46:15 <mniip> mostly interested in insert and deleteFindMin
14:46:46 <ertes> kakashiAL: i think most of the difficulty of doing web stuff in haskell comes from the learning curve
14:47:23 <Broli> Hello Gentelmen, I try something since already 2hours but it does not work
14:47:44 <Rembane> mniip: Why would the laziness affect the performance characteristics?
14:47:51 <ertes> there is no inherent difficulty of doing web stuff in haskell; we even have a lot of web frameworks to choose from, each with different strengths and a different focus
14:48:14 <kakashiAL> Rembane, ertes: do you know big webservices and webapps written in haskell?
14:48:27 <Rembane> kakashiAL: No, I have no idea.
14:48:44 <mniip> Rembane, recall your average definition of the prime number list
14:48:49 <mniip> consider its performance characteristics
14:49:00 <mniip> now think again and realize why it's O(N^2)
14:49:27 <kakashiAL> Rembane: I talked with a guy who create a collaborative video editing tool that is 18 million dollars worth, they switch from ruby to elexir
14:49:34 <ertes> kakashiAL: obsidian systems have a few commercial web applications written entirely in haskell, including the frontend…  Cale could tell you more, but he's not online right now
14:50:04 <ertes> kakashiAL: they combine a few haskell-specific technologies, most notably FRP for the frontend
14:50:06 <paws_> kakashiAL this doesn't count as serious experience, but I'll write it anyway, I'm a beginner and i wrote a small JSON api using Servant - once I figured out how to print debug messages ( :P ) it was relatively straight forward. Well, at least more than what I was expecting it to be.
14:50:07 <mniip> I remember there was some theorem or something that implied that a lazy evaluation strategy is always no worse than a strict evaluation strategy in terms of steps taken
14:50:10 <Broli> https://pastebin.com/6fsR57QK So thank you Gentelmen :)
14:51:24 <jessicaW> hi guys, i typed in some code from some lecture slides and it doesn't compile, what's wrong with it?
14:51:30 <jessicaW> http://lpaste.net/360790
14:51:41 <Rembane> mniip: Ah, I see. My hunch, which isn't grounded in reality, is that if you need to do all your steps they will also be done when the program is lazily evaluated, but more thunks might be lying around and thus a bit slower in time but not in complexity.
14:54:41 <geekosaur> typed in code from lecture slides. first guess is botched indentation
14:55:03 <geekosaur> oh, no. you dropped a )
14:55:26 <geekosaur> ... & (c <= '9') = ...
14:55:35 <geekosaur> although in fact you need none of those parentheses
14:56:02 <kakashiAL> does anyone created a big webapp/webservice (restfull) with haskell?
14:56:26 <fiatjaf> this is annoying
14:56:29 <geekosaur> I would imagine most such are not open source
14:57:09 <Broli> have you seen my call for help? https://pastebin.com/6fsR57QK thanks! :) 
15:00:23 <paws_> kakashiAL maybe this helps, if you haven't seen it yet https://wiki.haskell.org/Haskell_in_industry
15:00:47 <kakashiAL> paws_: I am looking for a realistic webapi
15:01:13 <kakashiAL> paws_: at the moment I only find big webprojects written in erlang or elixir
15:02:19 <jessicaW>  Variable not in scope: ord :: Char -> Int     • Perhaps you meant one of these:         ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
15:02:24 <jessicaW> what is this error message mean?
15:02:31 <jessicaW> do i need to import something?
15:02:53 <paws_> kakashiAL there are some web things in the list, though I haven't read it in detail yet.
15:05:34 <Broli> jessicaW: import Data.Char :)
15:05:54 <jessicaW> thanks Broli
15:09:52 <Broli> jessicaW: if you use a function, make sure that you have made the appropriate import. Prelude is there by default. you can see the element to import into hoogle, for example, try ord in hoogle and below its result, you will see Data.Char
15:11:31 <nek0> dear people from #haskell. I just posted a question on stackoverflow and would really appreciate any help with it: https://stackoverflow.com/questions/47823512/type-variable-error
15:12:56 <iqubic> Can intero deal with multiple executable sections in my .cabal file?
15:13:47 <iqubic> In fact, how does stack deal with that?
15:16:10 <geekosaur> stack handles it fine, if you want to be precise about which one to build instead of all of them then you specify a target as exe:executablename
15:16:14 <geekosaur> not sure about intero though
15:17:20 <iqubic> Can you use stack runghc and stack ghci with only a single executable?
15:18:43 <iqubic> Or do you get all the deps for all the executables pulled into the repl?
15:18:43 <iqubic>  
15:18:56 <crobbins> iqubic: ghci is the same as ghc --interactive, fwiw
15:19:50 <iqubic> I didn't know that.
15:21:10 <iqubic> I don't think that helps me with my issue of multiple executable sections.
15:22:14 <crobbins> what are you trying to do?
15:22:37 <crobbins> cabal, and therefore stack, supports multiple executable stanzas
15:24:30 <geekosaur> loading multiple exeutables wouldn;t work in ghci regardless of what's controlling it, because they'd all define Main.main
15:25:03 <geekosaur> guessing it only loads the library and no executables
15:28:36 <iqubic> geekosaur: So I can't ask stack to only load the files for a single executable.
15:29:03 <iqubic> I'm trying to do Advent of Code in Haskell with only a single stack project.
15:29:11 <geekosaur> I have no idea if there is a specific way to do that
15:29:43 <iqubic> I just want to declare each day as a seperate executable, and be able to test them independently in GHCI
15:29:59 <iqubic> :t (&&&)
15:30:00 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
15:30:33 <schell> this is a funny place to ask this, but what does the '&' mean in this C function pointer? EVROverlayError (OPENVR_FNTABLE_CALLTYPE *SetOverlayDualAnalogTransform)(VROverlayHandle_t ulOverlay, EDualAnalogWhich eWhich, struct HmdVector2_t & vCenter, float fRadius);
15:30:38 <iqubic> (+ 1 &&& +2) 7
15:30:55 <iqubic> > (+ 1 &&& +2) 7
15:30:57 <lambdabot>  <hint>:1:10: error: parse error on input ‘+’
15:31:12 <MarcelineVQ> iqubic: you can try target sytax. stack ghci myprojectname:exe:somespecificexecutablename
15:31:21 <MarcelineVQ> detailed here: https://docs.haskellstack.org/en/stable/build_command/#target-syntax
15:31:26 <iqubic> > ((+) 1 &&& (+) 2) 7
15:31:28 <lambdabot>  (8,9)
15:31:29 <geekosaur> schell, that'd be C++ and it's a struct reference
15:31:32 <schell> i've never seen an & in a c function prototype, only in a function call to make a pointer
15:31:36 <MarcelineVQ> idk if that works because I've never needed it for executables
15:31:40 <siwica> Is there a haskell language extension that allows for something similar to python slice syntax for lists?
15:31:59 <siwica> It does bother me quite a bit, that this does not seem to exist
15:32:02 <schell> geekosaur: that's a bug then, this is supposed to be a c wrapper around a c++ api
15:32:09 <iqubic> Is there a show instance like this: Instance Show a, Show b => Show (a, b)?
15:32:10 <geekosaur> siwica, no and there won;t be; Haskell lists are linked lists, "slice" can't really be done without copying
15:32:26 <schell> geekosaur: so it should probably be a '*', no?
15:32:42 <geekosaur> schell, unless its an internal helper then yes
15:32:56 * schell shakes fist at valve
15:33:03 <geekosaur> or they;re relying on some GNU extension that exposes C++ references in C
15:33:05 <siwica> geekosaur: Why not? Can't it just desugar to a combination of both take and drop?
15:33:36 <hpc> siwica: take requires copying
15:33:39 <schell> geekosaur: thanks *bow*
15:33:54 <siwica> well, I wouldn't mind copying
15:33:58 <iqubic> > (tail &&&  head) [1..10]
15:34:00 <lambdabot>  ([2,3,4,5,6,7,8,9,10],1)
15:34:05 <iqubic> What is that doing?
15:34:15 <geekosaur> siwica, the last node has to be duplicated with its tail changed to [], then every node preceding has to be duplicated with its tail pointing to the previously created new node
15:34:22 <hpc> also, you would probably mind foo[100000..100001] taking enormous amounts of time to compute
15:34:25 <geekosaur> it's a linked list, not a vector/array
15:34:29 <iqubic> (f &&& g) x = (f x, g x)? correct?
15:34:39 <siwica> hpc: well, I just wouldn't use it in these cases
15:34:41 <hpc> @quote waiting.to
15:34:41 <lambdabot> jfoutz says: There are good abstractions out there waiting to be found. Just because the specification we have now is bad/good/whatever, that dosn't mean there aren't better abstractions just
15:34:41 <lambdabot> waiting to be found.
15:34:45 <hpc> @quote waiting.to
15:34:45 <lambdabot> Cale says: You should think of lists as being like loops which are waiting to happen.
15:34:48 <hpc> ^
15:35:27 <iqubic> Is there even a point to using &&&?
15:35:49 <hpc> generally when you're using lists as a "store data in here" data structure, you're better off looking for alternative data types or algorithms
15:35:56 <iqubic> Isn't it better to use (f x, g x) instead of &&&?
15:35:59 <geekosaur> and generally if you are doing things with lists that require slices, you will be doing a lot more copying and stuff than you intend and it will probably be slower than you want. Id switch to vectors if I needed that
15:36:03 <hpc> iqubic: pointless^H^H^H^Hfree code
15:36:46 <geekosaur> iqubic, there are differing opinions on that. I personally never use that kind of code because it obscures meaning, other people prefer it
15:37:13 <geekosaur> but then I write a lot of code over in #xmonad for other people who don't in general have a strong Haskell background, and being 'clever' is not being helpful
15:37:24 <hpc> i think if the ecosystem of definitions around arrow-like computation was better, (&&&) would have more of a use
15:37:33 <hpc> otherwise you're pretty much stuck with it, (***), and (>>>)
15:37:45 <hpc> so yeah, i would go with the more explicit form
15:37:50 <iqubic> What do (***) and (>>>) do?
15:38:00 <hpc> > (f *** g) (x, y)
15:38:01 <MarcelineVQ> iqubic: why don't you ask them?
15:38:02 <lambdabot>  error:
15:38:02 <lambdabot>      • Ambiguous type variable ‘c0’ arising from a use of ‘show_M107223391212...
15:38:02 <lambdabot>        prevents the constraint ‘(Show c0)’ from being solved.
15:38:09 <hpc> (f x, g y)
15:38:17 <hpc> and (>>>) is arrow composition
15:39:41 <iqubic> :t (***)
15:39:42 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:39:54 <iqubic> :t (>>>)
15:39:56 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
15:40:09 <iqubic> I don't understand those at all.
15:40:15 <hpc> it's easier to read those types with a = (->) or cat = (->)
15:41:36 <iqubic> Can you give me an example of (***) being used?
15:41:36 <iqubic>  
15:42:51 <hpc> const 5 (***) -- :P
15:42:55 <iqubic> Stupid erc keeps adding a new line to my messages
15:42:55 <siwica> geekosaur: Well ok, I will have a look at vectors
15:43:04 <hpc> > ((+1) *** (*2)) (5, 10)
15:43:06 <lambdabot>  (6,20)
15:43:06 <siwica> Does slicing exists for vectors?
15:43:34 <Welkin> yes
15:44:03 <kakashiAL> hey guys, does anyone of you implemented a big webapp service (REST API) in haskell (with crud, authentication, authorization. logger, security and so on)
15:44:35 <kakashiAL> at the moment I only find Elixir recommendation and that you should avoid haskell for these tasks
15:44:52 <kakashiAL> and only should use haskell for data analysis and processing
15:45:05 <MarcelineVQ> you do hear odd things from people :>
15:45:14 <kakashiAL> MarcelineVQ: teach me!
15:45:44 <MarcelineVQ> servant is an entire ecosystem about implementing REST api's  https://haskell-servant.github.io/
15:46:17 <MarcelineVQ> there's others too that people here could probably point you at, it's certainly not something you have to avoid with haskell
15:46:33 <kakashiAL> MarcelineVQ: is it used by big comapnies? is it well supported? how is the community?
15:47:04 <dsal> IME, nothing is well supported except the code I wrote to solve my problem.
15:47:35 <boj> kakashiAL: here is a slowly growing list of companies using it if you are interested https://github.com/erkmos/haskell-companies
15:47:39 <MarcelineVQ> I've no idea about those sort of questions
15:47:57 <Welkin> servant is well supported in that if you ever run into trouble you can get help in #servant
15:48:07 <Welkin> and talk directly to the authors of the library
15:48:15 <Welkin> I did not have this luxury when using yesod
15:48:21 <Welkin> I spent a lot of time reading source code
15:48:27 <dsal> It's a weird application of statistics to try to count the number of people who've solved problems similar to the one you're thinking of relative to the number of people who solve those problems with other tools.  Lots of people seem to use java for everything.
15:48:32 <kakashiAL> boj: I know that, but most of these projects are data processing/analysis apps
15:48:48 <Welkin> I use haskell for crud apps and games
15:48:51 <kakashiAL> boj: I am talking about web projects apps (something like whatsapp or simmilar)
15:48:56 <Clint> crud games
15:49:04 <kakashiAL> Welkin: you use servant?
15:49:06 <boj> kakashiAL: you mean "web scale"?
15:49:26 <dsal> whatsapp isn't just a beam process running on a machine somewhere in AWS.
15:49:35 <Welkin> kakashiAL, we spent far too long talking about this yesterday
15:49:40 <kakashiAL> boj: all kind of web apps like crud apps, scrapers etc.
15:49:42 <geekosaur> some people believe the only apps are web apps. the only anything is web anything. their OS doesn't even exist, and browsers are somehow written in themselves
15:49:50 <boj> it's usually less about the language and how well your ops team has built things to scale
15:49:53 <Welkin> kakashiAL: it feels like you are looking for someone to confirm your beliefs/emotions
15:49:58 <boj> haskell is definitely up for the job
15:50:05 <Welkin> if you want to use something, just use it
15:50:10 <Welkin> who cares what anyone else says?
15:50:10 <ertes> kakashiAL: i find it really difficult to discuss this with you…  when people provide anecdotal evidence, you seem to ignore it and keep asking about stuff that ultimately doesn't matter
15:50:33 <ertes> that's why i stopped responding
15:50:55 <kakashiAL> okay, I am sorry, this was not my intention
15:51:25 <dsal> What is your intention?  Are you having trouble with some part of an app you've written?
15:51:42 <ertes> kakashiAL: if your question is whether haskell is fit for your purpose, perhaps you should explain that one and stop asking these super-generic questions
15:55:08 <MarcelineVQ> kakashiAL: what app are you planning on making?
15:55:38 <dsal> whatsapp are you working on?
15:55:46 <Welkin> kakashiAL: if this is your first time working with haskell, just use scotty with persistent for the database. Keep it simple and learn the basics. then when you have a real project in mind, you can start adding more libraries
15:55:47 <kakashiAL> MarcelineVQ: just something to learn haskell with that I already implementend in java, node and pythong
15:55:55 * hackage fee-estimate 0.1.0.0 - Short description of your package  https://hackage.haskell.org/package/fee-estimate-0.1.0.0 (sahabi)
15:56:22 <ertes> kakashiAL: my suggestion is: just go ahead; pick one of your smaller applications and try to write it in haskell
15:56:25 <MarcelineVQ> you know what you're making pretty well then so go ahead and give it try :>
15:56:25 <dsal> "just something to learn haskell with" seems like a pretty great leap from "and have hundreds of millions of  DAU and a large revenue stream"
15:56:42 <kakashiAL> MarcelineVQ: so I want to create a CRUD app (TODO) with login, and a desktop app like the TODO app using postgres and sqlite
15:57:02 <kakashiAL> Welkin: would you recommend servant?
15:57:10 <Welkin> my suggestions stands: scotty with persistent
15:57:43 <kakashiAL> Welkin: in the mainstream, with what can you compare scotty?
15:57:44 <ertes> kakashiAL: haskell is one of the more difficult languages, so be prepared to spend more time on it than you might initially expect
15:57:44 <Welkin> if you use servant, you need a client-side application (which means using ghcjs, which is not something you want to get into as a beginner)
15:57:54 <ertes> i second the scotty suggestion, but not the persistent suggestion
15:57:59 <ertes> avoid template haskell at all costs
15:58:00 <Welkin> kakashiAL: scotty is like ruby's sinatra
15:58:31 <ertes> in fact i suggest using scotty and any of the *-simple libraries: sqlite-simple, postgresql-simple, etc.
15:58:35 <kakashiAL> Welkin: ahh, very modular, almost like node
15:58:52 <Welkin> sure, postgresql-simple is a good suggestion as well
15:58:56 <ertes> all of the haskell frameworks are modular, except yesod
15:59:09 <ertes> yesod is a highly integrated framework
15:59:09 <kakashiAL> Welkin: now you are talking my language :)
15:59:56 <kakashiAL> Welkin: what would you use for: scraping websites, parsing json, talking to sqlite3?
16:00:09 <Welkin> Aeson for json
16:00:15 <Welkin> no idea about scraping
16:00:34 <ertes> kakashiAL: http-conduit (or wreq: higher level, but less flexible), aeson, sqlite-simple
16:00:36 <kakashiAL> Welkin: I learned soooo much scraping websites :)
16:00:42 <Welkin> for any database connections, use one of the *-simple libraries, like postgresql-simple
16:00:49 <kakashiAL> Welkin: roger that
16:01:51 <kakashiAL> ertes: I used so many libs in my life, always go as lower level as possible (not to low, something that you can extend, like node, senatry, rails) something where you can plug stuff in
16:02:31 <ertes> kakashiAL: http-conduit is kinda low and high level at the same time…  you'll get the idea once you start using it
16:02:43 <ertes> many haskell libraries are like that
16:03:00 <dsal> http-conduit was a bit slower than I expected.
16:03:03 <kakashiAL> ertes: how is it compared with scotty?
16:03:25 <ertes> kakashiAL: scotty is a high-level library
16:04:16 <ertes> kakashiAL: haskell frameworks work a bit differently from other languages in that they don't have a very high integration level (except yesod, as i mentioned)
16:05:01 <kakashiAL> ertes: in scotty you can plug everything what you need
16:05:10 <ertes> kakashiAL: scotty provides the basics like routing, handling request parameters (GET/POST) and sending responses
16:05:25 <kakashiAL> ertes: yep, like express.js
16:05:35 <ertes> you can go with that alone, or you can use utility libraries like digestive-functors for creating/handling forms
16:06:31 <kakashiAL> ertes: stupid question, but if you would implement a big, a very big "million of users" rest api in haskell, would you use scotty?
16:06:54 <dsal> It's very rare that anyone implements a "very big 'millions of users' rest API" in general.
16:06:58 <ertes> kakashiAL: not sure…  probably one of scotty, servant or even just wai
16:07:27 <ertes> kakashiAL: the thing is: you can't really plan this in advance…  millions of users usually come as a surprise
16:07:32 <kakashiAL> dsal: I mean something that is used by millions of users
16:07:52 <kakashiAL> like a weather service or something like this
16:08:12 <dsal> kakashiAL: I understand that.  "millions of users" is almost never a thing that happens quickly, and when it does, your system typically breaks in a way you didn't anticipate (even if you did anticipate millions of users)
16:08:16 <ertes> kakashiAL: also a REST API is very different from a fully fledged web app…  i'd be more inclined to just use wai directly, a low-level HTTP library
16:08:35 <ertes> *HTTP server library
16:08:45 <kakashiAL> ertes: if wai is more modular, I buy wai :)
16:09:00 <glguy> kakashiAL: You just need to build anything at all at this point
16:09:28 <ertes> kakashiAL: it's "modular" in the same way as scotty: libraries are designed in a way that you can combine them with other libraries
16:09:32 <dsal> Most things I write have ones of users.
16:09:32 <glguy> you'll learn from that experience and you can make different choices next time based on that learning
16:09:47 <ertes> we don't have those tightly integrated frameworks that you find in other languages…  the only exception i know is yesod
16:10:12 <ertes> kakashiAL: but i agree with glguy…  at this point you should really just start building something
16:10:13 <dsal> I think I used yesod the first/last time I needed a web thing.  Scotty sounds closer to what I actually wanted.
16:10:25 <fiatjaf> how can I turn a Data.Text (Text) into a Data.Text.Lazy (Text) and vice-versa?
16:10:37 <ertes> fiatjaf: Data.Text.Lazy.fromStrict
16:10:44 <fiatjaf> thanks
16:11:15 <kakashiAL> I felt in love with scotty since I read its documentation
16:11:58 <kakashiAL> to bad there are only books for yesod
16:12:18 <dsal> heh.  Your last two messages seem conflicting.
16:12:19 <Axman6> we use Servant for everything, it's amazing
16:12:28 <ertes> kakashiAL: what's your experience level with haskell as a language?
16:12:54 <kakashiAL> ertes: the basics and ready to start something big
16:13:17 <kakashiAL> Axman6: nice, with we who do you mean? your company?
16:13:18 <ertes> servant may be nice, but i think the level of haskell experience it needs is too high for a beginner, given all the type-level stuff it uses
16:13:33 <dsal> kakashiAL: what are "the basics" ?
16:14:00 <ertes> kakashiAL: well, start with something simple:  write a REST app that can store named strings in an sqlite database
16:14:13 <ertes> you can create/update, fetch and delete
16:14:22 <Axman6> kakashiAL: yeah
16:14:35 <Broli> please help https://pastebin.com/6fsR57QK
16:14:39 <kakashiAL> ertes: I see that, I now understand why people using elixir to avoid the type-level
16:14:57 <ertes> kakashiAL: well, in elixir there is not much type level to speak of =)
16:15:26 <ertes> servant encodes basically the entire interface on the type level, and then you "derive" servers and clients from that
16:16:24 <Welkin> my first big haskell project used yesod
16:16:26 <dsal> I don't understand why people are so hip to avoid types.  Though I have enjoyed erlang's types in the past.
16:16:32 <Welkin> it was a mistake, but I still learned a lot
16:16:48 <Welkin> I should have started with wai to properly learn http
16:16:51 <Welkin> but that was more of a domain problem
16:16:56 <kakashiAL> ertes: the reason why my questions are so "stupid" is because I wanted to know if there is a big web project that proved itself (like whatsapp: +900 million users) and see what is used for that, but in haskell land :)
16:17:27 <Welkin> all of haskell's web libraries use the same server: warp
16:17:29 <dsal> kakashiAL: But you're not writing that app with those problems and that team.
16:17:33 <Welkin> so they can all scale equally well
16:17:33 <kakashiAL> Welkin: would you use yesod ever again? (it has good marketing) :)
16:17:44 <Welkin> yes, I would use yesod if I needed a big CMS/admin app
16:17:59 <dsal> relevant:  http://memcached.org/facebook
16:18:22 <ertes> Welkin: snap uses snap-server
16:18:46 <Welkin> I never used snap because it isn't nearly as good as the other libraries
16:18:49 <Welkin> and it doesn't use warp
16:19:20 <ertes> kakashiAL: well, the only such application i know of is facebook's abuse filter: every facebook message is checked by a large-scale haskell program
16:19:22 <Axman6> Broli: make the function argument to foldTree a lambda and name all the arguments
16:19:50 <ertes> Welkin: you like scotty, but you don't like snap?  they are virtually the same thing
16:20:04 <ertes> except that snap has a modularity feature called snaplets
16:20:09 <kakashiAL> ertes: I dont see that as a webapp, its an haskell app that gets data and does not know that this data comes from the web
16:20:20 <dsal> haha
16:20:55 <kakashiAL> ertes: I am sure there is something that deligates the web stuff to it
16:21:10 <ertes> kakashiAL: it's more complex than a web app…  see the haxl framework that facebook wrote, which is open source
16:21:44 <ertes> web apps aren't really that complicated:  they take requests, talk a bit to the database, then send a response
16:21:46 <dsal> kakashiAL: Nobody at scale uses things off the shelf that you'd use to write your first small app.  It doesn't even make sense.
16:22:08 <Broli> Axman6: it doesn't work! https://pastebin.com/Mg4gspVq
16:22:32 <ertes> kakashiAL: but again: just build something
16:23:28 <kakashiAL> ertes: it nothing about building, just wanted to know what good experience you made and what you can recommend, thats all :)
16:23:38 <dsal> "just build something" is the best recommendation.
16:23:58 <ertes> kakashiAL: your first challenge will be nothing like choosing the right framework or thinking about millions of users…  it will be something much more mundane: getting your editor and tools in order
16:24:13 <kakashiAL> its like the recommendation: "if you dont understand it, just read it again until you do" ;)
16:24:27 <kakashiAL> ertes: I know
16:24:37 <ertes> writing cabal files to express dependencies, integrating GHCi into your editor (optional, but highly useful), dealing with build tools like cabal-install/nix/stack
16:24:38 <ertes> etc.
16:24:54 <dsal> The http://memcached.org/facebook link above was regards to how Facebook ran memcached.  They kept wanting us to pull in facebook specific "optimizations" that were specific to facebook topologies, custom linux kernels, and the fact that they had enough traffic that they would cause firmware faults in switches from memcached request fanouts so they had to do all kinds of weird stuff that didn't apply to anyone else ever.
16:25:04 <ertes> or even integrating the 'rapid' library into your editor =)
16:25:04 <kakashiAL> ertes: what do you recommend for unit testing?
16:25:09 <kakashiAL> Hunit or Hspec?
16:25:17 <ertes> kakashiAL: i use tasty and quickcheck
16:25:30 <dsal> +1
16:25:48 <ertes> tasty is a test framework, and quickcheck is a test provider
16:26:29 <kakashiAL> ertes: a stupid question, but is haskell avoided because of its complexity?
16:26:36 <dsal> I wish someone would've pointed me to tasty sooner.
16:26:45 <ertes> kakashiAL: it's not really complex, but it's difficult
16:26:59 <dsal> I think you should ask people who avoid haskell why it's avoided.  :)
16:27:26 <dsal> One of the issues I've found is it requires people to learn, and some people really don't like being told they have to learn things in order to undrestand them.
16:27:28 <kakashiAL> dsal: I hear stuff like "I need stuff to get things done"
16:27:36 <ertes> i can't really answer your question, because i can't read people's minds, but i'd say it comes down to two things
16:27:47 <MarcelineVQ> dsal: where did you learn to use tasty?
16:28:00 <dsal> They love swinging from c to java and being like "I know multiple languages" without really learning anything.
16:28:10 <ertes> 1. the learning curve: people don't have the patience to learn haskell, or they didn't expect to learn it for weeks or months
16:28:16 <dsal> MarcelineVQ: http://dev.stephendiehl.com/hask/
16:28:26 <MarcelineVQ> dsal: thank you
16:28:38 <ertes> 2. misinformation/misconceptions: there is still this notion floating around that haskell is a great language for prototyping something, before you implement it in a "real" language
16:28:39 <kakashiAL> ertes: whats about haskell and the desktop? did you make some experience with it, if yes what would you recommend?
16:28:43 <dsal> I was using test-framework before.  tasty solved a bunch of problems for me.
16:29:12 <dsal> The first haskell program I used regularly was darcs.
16:29:26 <dsal> It had (and probably still has) the best interface of any distributed revision control system.
16:29:53 <ertes> kakashiAL: don't take this the wrong way, but i don't think it's useful to keep answering these questions…  just start a project
16:29:58 <kakashiAL> ertes: @haskell learning: I guess this will change, because the javascript community pushes haskell :)
16:30:26 <dsal> The javascript community makes me sad.
16:30:37 <ertes> they do?
16:30:48 <kakashiAL> ertes: sure, I would also do something with the desktop, if you think that this is stupid to answer I apologize
16:31:33 <ertes> kakashiAL: it's not a stupid question, but i think all of this is too theoretical and won't get you anywhere right now
16:31:36 <dsal> kakashiAL: Better questions are like, "I'm having this problem with this code I'm writing.  Can anyone help me find a better way to do it?"
16:31:59 <ertes> kakashiAL: in fact your question is perfectly valid…  in a different context i would have answered it right away =)
16:32:20 <kakashiAL> ertes: yep, there are implementations to use maybe, either and other funktors in javascript, just bad that you to create a context to use them and only can use them there :(
16:33:10 <kakashiAL> ertes: is there a desktop framework for haskell, that you can recommend? (hope that question is valid)
16:33:22 <dsal> You finished the web app already1?
16:33:23 <ertes> kakashiAL: yes
16:33:42 <kakashiAL> ertes: just some names, I will do the rest :)
16:34:03 <ertes> kakashiAL: with pleasure, as soon as you have written a REST app =)
16:34:37 <kakashiAL> ertes: :(
16:35:52 <ertes> kakashiAL: alternative: up for a coding challenge in haskell?
16:35:58 <paws_> hey super interesting conversation! now I'm considering replacing servant with scotty for my mini-api because scotty seems much easier to understand. Should have asked here first :P
16:36:41 <kakashiAL> ertes: not now, I just want to explore the haskell eco-system a bit, see its documentations and some examples
16:36:58 <dsal> paws_: Yeah, I'll probably grab it in lieu of whatever I was using before that was something yesod related, I think.
16:38:01 <dsal> kakashiAL: Questions will take you further from understanding at this point.  You have many answers, but little experience.  Get more XP.
16:38:15 <kakashiAL> dsal: yes sir!
16:38:37 <dsal> I'm curious what "the basics" are.  How much fundamental understanding do you have?
16:38:41 <paws_> dsal how do you mean that with yesod? Not sure how relates with what I said
16:38:54 <kakashiAL> dsal: is there a desktop framework that you can recommend? 
16:38:59 <dsal> paws_: I've got an app with a tiny web server.  I don't know what I'm using.  It's not scotty, though.
16:39:17 <paws_> ah, ok!
16:39:20 <dsal> kakashiAL: At this point, you've kind of proven you have no intention of ever writing code and just want to use up other people's time.
16:40:14 <ertes> kakashiAL: i agree with dsal, and i'll add one more point: better stop reading and start doing…  i don't know why, but haskell is particularly prone to procrastination
16:40:16 <kakashiAL> dsal: thats a very negative interpretation, we should stop here because everything else would end up with more hate and negative comments
16:40:54 <Tuplanolla> I can't get `hmatrix` to find `libblas` or `liblapack`. What files does it want?
16:41:14 <kakashiAL> ertes: sure, I am just interested in web and desktop apps, just wanted some names, I have enough for web, want to know some recommendations for the desktop, that stupid, I am sorry
16:42:25 <paws_> I googled a lot about developing web apps with Haskell before of starting (searched for examples, well known companies, etc.) seems like a normal thing to do? 
16:43:43 <ertes> kakashiAL: the reason i'm not giving you the names is that once you start building something, you will as a side effect figure out a way to get those names for yourself
16:43:52 <kakashiAL> ertes: thanks for your time :)
16:44:20 <ertes> kakashiAL: i hope it helped, and i hope that you return with a question about your code =)
16:44:30 <kakashiAL> ertes: you helped me more than you can imagine
16:44:36 <kakashiAL> thanks again!
16:47:50 <dsal> I was almost caught up in an argument on twitter yesterday about how go was created because people are too stupid for haskell.  Some users demand to know what contributions haskell brings to programming and stuff.  I quickly find myself in a blub discussion, as if I were trying to explain a foreach loop to someone who doesn't see the point of learning anything but asm.
16:48:56 <MarcelineVQ> jmp is awfully powerful
16:49:01 <dsal> Like that monoid thing from earlier...  I wrote a big explanation of how that sort thing worked to explain to someone who doesn't know haskell (but has definitely had that problem before).  So much to explain before you get to "... and that's all carefully abstracted into this neat little box, so you can just use <>"
16:49:01 <kakashiAL> dsal: why not ignoring that, why fighting a war that has no value? 
16:49:24 <dsal> kakashiAL: It's not a war, it's helping people understand things.
16:49:31 <kakashiAL> dsal: do you blog?
16:49:36 <dsal> I've not in a long time.  :(
16:50:13 <kakashiAL> dsal: just collect the stuff that you have to explain all the time and link it
16:50:16 <dsal> I could do yet-another-another monad tutorial or something.  The monoid thing I wrote benefitted me probably more than the recipient.
16:50:33 <dsal> The problem is that it's coupled with "if I have to read a bunch of stuff, it's too complicated"
16:50:53 <dsal> It took me a few pages of writing to explain:     sortBy (comparing age <> comparing height) people
16:51:24 <dsal> That's not because it's complicated, it's because a typical java programmer won't have any experience with the abstractions.
16:53:00 <dsal> blub kind of works here because there's simultaneously the assertion that they know everything they need to know about programming, so more complicated junk can't help and that they are superficially asking for what kinds of things haskell has that their language doesn't.  But you have to explain it in terms that fit.
16:53:28 <dsal> I thought about doing an applicative tutorial in go.  I think that'd be super helpful for people, though I'd have to make up some syntax.
16:55:00 <kakashiAL> dsal: there are poeple that are not as smart as you, you have to belive that, so you have to start in a very lower level and build it up, use not only text use also pictures. I had like some guys who didnt understand how I come up with a reduce definition, I showed them that and I ended up with showing them induction and explaining them what induction is...it take a lot of time but you have many options:
16:55:01 <kakashiAL> help (which is very hard and need a lot of energy), ignoring them or talking how stupid/bad they are
16:55:04 <dsal> (for the record, I'm super far away from a haskell expert -- there's more I don't know than I do know, but learning is awesome and I don't understand people who avoid it)
16:55:24 <Tuplanolla> I can't get Stack to recognize my foreign dependencies. Can I just tell it to go ahead and assume I have them?
16:57:32 <dsal> kakashiAL: Do you have a link to that?
16:58:06 <kakashiAL> dsal: I did that in a chat and via viber
16:59:01 <dsal> Though that's another point -- a lot of your intuition from... every other language is just wrong.  foldl was my default from ocaml a long time ago.  foldr is almost always right (heh) in haskell.  It took me a while to understand that.  Most of the time, it may not matter, but one time I needed to do a thing that needed to fold an (arbitrarily long, possibly infinite) list and it was just obvious.
16:59:28 <dsal> ertes has some good tutorials on this, but getting intuition about how that evaluation works requires unlearning, which is hard.
17:00:47 <mniip> 1513298907 [03:48:27] <MarcelineVQ> jmp is awfully powerful
17:00:49 <mniip> too powerful
17:01:06 <mniip> exploits levarage it pretty ofetn
17:01:09 <dsal> Meanwhile, someone in here was playing with call/cc in haskell.  I had to step away.
17:03:01 <mniip> ot was me
17:03:18 * dsal steps away before it happens again
17:04:08 <mniip> I drew these yesterday https://sketchtoy.com/68443629 https://sketchtoy.com/68443644 https://sketchtoy.com/68443657
17:04:33 <dsal> What were you using for input?
17:04:50 <mniip> tablet
17:05:06 <kakashiAL> HsQML looks great :)
17:05:13 <dsal> I hate it when a drawing thing comes up like that and wants me to use a mouse/touchpad.  I always think I can.  It never happens.
17:06:07 <mniip> I could probably do it with the touchscreen
17:06:17 <mniip> mouse maybe
17:06:19 <mniip> but not touchpad
17:06:31 <mniip> acceleration in those doesn't favor circular movements
17:11:25 <mniip> yeah nah
17:11:30 <mniip> can't do tiny movements with touchscreen
17:12:01 <dmwit> Tuplanolla: I've fought hmatrix installations before, too. I can't remember how I solved it, though; I think maybe --extra-lib-dirs and --extra-include-dirs.
17:12:10 <Tuplanolla> I have those set, dmwit.
17:12:14 <mniip> best I can do https://sketchtoy.com/68446567
17:12:17 <dmwit> Tuplanolla: --verbose is always good for finding out what tests it's doing right before it decides you don't have the things you do actually have.
17:12:52 <Tuplanolla> Verbosity gave me no new information.
17:13:14 <dsal> mniip: I tried one, and couldn't read what I wrote myself.
17:13:39 <dmwit> Tuplanolla: Well, there's always more powerful tools for finding out what tests it's doing right before it decides you don't have the things you do actually have...
17:13:45 <Tuplanolla> It just says it tries to run `/home/tuplanolla/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2` and fails.
17:13:45 <kakashiAL> dsal: have you ever wrote a gui app in haskell?
17:13:45 <dmwit> strace... =P
17:14:00 <mniip> gdb
17:14:07 <mniip> reverse debugging
17:14:24 <dsal> kakashiAL: I rarely use gui apps, much less write them.  Last gui apps I've written were in objective C years ago.  Pretty sure they all became obsolete at some point.
17:15:08 <mniip> I wrote like one. Used it a few dozen times
17:15:11 <mniip> pretty sure no one else did
17:16:10 <dmwit> I think the only serious GUI I've ever done was for a clone of a little puzzle game.
17:16:12 <dsal> I've written a couple I liked.  I had a nice desktop buildbot monitor I used for a while.  So I guess that would've been some combination of cocoa and twisted.
17:16:20 <kakashiAL> HsQML looks nice, but its a bridge and I think there are no pure haskell gui framework implementations, you only see bridges for gtk, qt and friends
17:16:37 <kakashiAL> dsal: in haskell?
17:17:13 <mniip> http://tcpst.net/7hov.png
17:17:25 <dsal> I just don't have much interest in using or writing GUIs most of the time.
17:17:36 <Tuplanolla> I cannot reach `Cabal` with `strace`.
17:17:41 <dsal> I have a web browser.
17:19:04 <mniip> sheesh, 2014
17:19:12 <mniip> I was 16
17:19:16 <dsal> Almost every mac app I've used that wasn't written in proper cocoa has been a pretty terrible user experience.
17:19:19 <Tuplanolla> Oh, I can, but it never searches for either library.
17:19:30 <mniip> ah early 2014, I was 15
17:19:52 * dsal beats mniip with cane
17:20:00 * mniip beats dsal with callCC
17:20:05 <dsal> ha
17:20:23 <dsal> last time I used calcc was *before* that.  In scheme.  On a Palm III.
17:21:23 <dsal> I don't know exactly when I wrote this, but I imported it into a git repo in 2006.
17:21:54 <mniip> I often get sad about possibly being born ~10 years too late
17:21:59 <mniip> but that's not something I could change anyway
17:22:34 <dsal> Yeah, it's easy to do that.  I was born simultaneously too late and too early, depending on which non-present thing I'm worried about.  I've gotten good at just not worrying about things, though.
17:23:16 <dsal> The biggest problem now is that there are too many things to learn, too many books to read, etc...  Maybe the FCC will make it harder to get to information and I can start actually slow down and read more.
17:25:43 <Axman6> Broli: you didn'rt do what I said - I said name all the arguments
17:26:10 <Axman6> (\a lval rval -> ...)
17:26:43 <mniip> dsal, well it's pursuing me. I would come up with a kick-ass idea for an article only to see something on that topic published in 2007 or 2013
17:27:05 <mniip> happened at least 2 times
17:27:28 <Axman6> Broli: also, this is a really terrible way of asking for help. "Help me, my code is broken" is unhelpful for us and pretty rude. "I have tried ..." or "I don't understand ..." and explaining the problem will get much more helpful answers
17:27:43 <dsal> Haha.  That happens so much I just take satisfaction in finding out how my ideas pan out by reading what others wrote.
17:31:49 <mniip> hmm
17:31:58 <mniip> I wonder if anyhting has been published on free monads and parsers
17:34:19 <Tuplanolla> Is there an alternative to `hmatrix`? I don't care if it's a thousand times slower.
17:39:24 <Broli> Axman6: I am trying to write the preorder function for a tree that is defined as in the code. I was given the function foldBtree but I do not know how to use it. thanks!
18:00:32 <dmj`> `accelerate` or `linear` maybe
18:01:27 <Tuplanolla> I just want Gauss--Jordan elimination.
18:07:45 <mniip> is that the gauss elimination modified to provide a jordan matrix in case of matrices whose eigenvectors don't span the entire space?
18:08:26 <Tuplanolla> It's to eliminate variables in an underdetermined system.
18:08:50 <mniip> row echelon form?
18:09:39 <Tuplanolla> Yes.
18:13:29 <codeshot> ha ha. I just discovered why there's no "dup a = (a,a)" function
18:13:58 <codeshot> "join (,)" for the ((->) a) monad is dup
18:13:59 <mniip> join (,)
18:14:02 <codeshot> yeah
18:14:09 <codeshot> lol
18:14:16 <codeshot> its so nice
18:14:19 <mniip> :t id &&& id
18:14:20 <lambdabot> b -> (b, b)
18:14:36 <dsal> What is this join?
18:14:44 <dsal> &&& just looks weird to me.
18:14:48 <mniip> :t join
18:14:49 <lambdabot> Monad m => m (m a) -> m a
18:14:51 <mniip> :t (&&&)
18:14:52 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:15:38 <dsal> I've seen &&&, but always to do the above.
18:16:03 <Tuplanolla> I don't see Gauss--Jordan or reduced row echelon functions in any of these matrix packages.
18:16:14 <codeshot> dsal: join [[1,2,3],[4,5,6]] = [1,2,3,4,5,6]
18:16:44 <codeshot> also join (Just $ Just 1) = Just 1
18:16:58 <dsal> heh.  stutter operator
18:16:58 <codeshot> and for the function application monad it does the same
18:17:41 <codeshot> a -> a -> (a,a) becomes a -> (a,a)
18:17:42 <dsal> It's confusing in the Maybe case.  It looks like it sort of unjoins.
18:17:50 <dsal> It's the unjust operator.
18:17:59 <dsal> What is function monad?
18:18:05 <codeshot> it removes a layer of monad
18:18:21 <dsal> You mean join in general?
18:19:10 <codeshot> the function monad is a bit of structure that's made by combining functions where a bit is left out of them all - that bit is then filled in later from a single source
18:21:30 <meteo> if one wanted to represent a list of instructions for a stck machine/vm - what order would one choose? [ PUSH, PUSH, ADD ] or [ ADD, PUSH, PUSH ] ?
18:21:47 <crucify_me> hi I have this unfold func. a member was helping me figure out the type. please see comments. they started with the func return type e (understood to return a list such as   [e]), then switched it to [f]. what was the reasoning behind that?  
18:21:49 <meteo> The first reads in-order for [] and ++/mappend notation. But for the second option, cons :: makes more sense in terms of cons'ing a new instruction onto head of the last instructions or nil.  
18:21:49 <crucify_me> http://lpaste.net/360798
18:22:02 <codeshot> join takes some structure where a bit is left out at two levels and makes it so the two missing bits come from the same source
18:22:11 <codeshot> (for the function monad)
18:22:23 <mniip> % case unsafeCoerce (123 :: Int) of () -> ()
18:22:24 <yahb> mniip: ()
18:22:25 <mniip> hmm
18:22:51 <dsal> codeshot: Thanks.  That sounds like something I'm going to understand well when I need ite.
18:23:21 <codeshot> dsal, oh no, you only understand it well very much after you need it
18:23:32 <dsal> haha
18:23:39 <codeshot> so you have to pretend you need it now so that you understand it on the night
18:23:57 <mniip> this is not looking good for lambdabot
18:27:47 <codeshot> dsal: ((+) <*> (*2)) 1 -> 3
18:27:58 <crucify_me> any takers ? 6
18:28:02 <crucify_me> ^*
18:28:27 <codeshot> the 1 is fed into the *2 to make 2, and into the (+) to make 1+, and the 1+ is applied to the 2, to get 3
18:28:56 <crucify_me> sorry disconnected..
18:29:11 <codeshot> for your benefit: the 1 is fed into the *2 to make 2, and into the (+) to make 1+, and the 1+ is applied to the 2, to get 3
18:29:31 <dsal> codeshot: wow.  Easy as 1, 2, 3 as they say
18:30:03 <codeshot> yeah, until you try to recreate it in different circumstances :D
18:30:48 <codeshot> dsal, without testing, what do you think this does: join (*)
18:31:14 <dsal> Square?
18:31:34 <Welkin> there is a monad instance for (*)?
18:31:48 <Welkin> oh, yeah
18:31:55 <codeshot> dsal, yup
18:32:00 <crucify_me> anyone help with this? http://lpaste.net/360798
18:32:03 * codeshot gives dsal some champagne
18:32:12 <dsal> Woo. Thanks
18:32:42 <Welkin> :t join (*)
18:32:43 <lambdabot> Num a => a -> a
18:32:53 <codeshot> > join (*) 2
18:32:55 <lambdabot>  4
18:32:58 <codeshot> > join (*) 3
18:33:00 <lambdabot>  9
18:33:10 <codeshot> @unpl join (*)
18:33:10 <lambdabot> ((*) >>= \ x -> x)
18:33:28 <codeshot> well that didn't help
18:33:38 <dsal> I understood it better before
18:33:39 <codeshot> although it might be instructive
18:34:24 <Welkin> `a -> a -> a` becomes `(-> a) ((-> a) a))` which unifies with m ~ (-> a) to give us `m (m a)`
18:34:30 <Welkin> I never looked at that before
18:34:33 <Welkin> that's cool
18:35:07 <codeshot> It's one of the coolest things I've seen in Haskell, and one of the most fundamental
18:35:14 <codeshot> it's very deep
18:35:16 <Welkin> I wouldn't say that :P
18:35:29 <Welkin> I still think (.) ~ fmap and (.).(.) is cooler
18:35:45 <codeshot> I found this which is even cooler:
18:35:51 <codeshot> @pl f (g x y)
18:35:51 <lambdabot> f (g x y)
18:35:55 <mniip> dammit ghc I thought it would work
18:35:56 <codeshot> @unpl f (g x y)
18:35:56 <lambdabot> f (g x y)
18:36:00 <codeshot> ok
18:36:02 <codeshot> ...
18:36:24 <geekosaur> need to tell it which points to remove
18:36:25 <codeshot> (f .) . g = \x y -> f (g x y)
18:36:35 <geekosaur> @unpl \f g x y -> f (g x y)
18:36:35 <lambdabot> \ f g x y -> f (g x y)
18:36:39 <geekosaur> er
18:36:43 <geekosaur> @pl \f g x y -> f (g x y)
18:36:43 <lambdabot> (.) . (.)
18:36:58 <codeshot> it's (.).(.) partially constructed and it turns out totally generic and mixes with . nicely
18:37:01 <mniip> @pl \(.) -> (.) . (.)
18:37:01 <lambdabot> (line 1, column 3):
18:37:01 <lambdabot> unexpected "."
18:37:01 <lambdabot> expecting pattern
18:37:01 <Welkin> point-free is pointless most of the time
18:37:05 <geekosaur> and unpl is other way but it didn't know what to do with single occurrences
18:37:11 <mniip> ah right that's a type error anyway
18:37:14 <Welkin> it's also known as "pointless form" rather than "point-free form)
18:37:15 <Welkin> "
18:37:41 <Welkin> unless you have a pipeline that makes sense using single composition (.) or blackbird (.).(.)
18:37:43 <codeshot> (f .) . g can be read as f applies to the result of g, allowing two values (two dots you see) to be taken
18:37:50 <codeshot> f . g is one value taken
18:38:04 <Welkin> yes
18:38:06 <codeshot> ((f .) .) . g lets g take 3 values
18:38:12 <Welkin> that is just a worse way of writing the blackbird
18:38:31 <Welkin> @let blackbird = (.).(.)
18:38:32 <lambdabot>  Defined.
18:38:42 <codeshot> no it's better, because now it describes values that a function applies to as a queue of data
18:39:06 <codeshot> we can read it as (g takes three then f applies on the result)
18:39:23 <codeshot> this is a nice step to compiled lambda calculus
18:39:32 <codeshot> it's very profound
18:40:48 <codeshot> btw, blackbird is a terrible name for a function
18:40:50 <crucify_me> @let furryOwl = (.).(.)
18:40:51 <lambdabot>  Defined.
18:41:16 <crucify_me> even more profound..
18:41:26 <codeshot> crucify_me, perfect
18:42:25 <crucify_me> I'll get it one day
18:42:42 <crucify_me> still looking for guidance : http://lpaste.net/360798
18:43:05 <Profpatsch> bennofs[m]: You here?
18:43:38 <Profpatsch> Need a bit of help designing a recursion, not sure what scheme to fit it in.
18:43:59 <crucify_me> re: line 20 in the comments. 
18:45:16 <Profpatsch> bennofs[m]: Basically I need to construct something, where I can access the original value of exactly one layer before the current one.
18:45:54 <crucify_me> that return type change to [f]. why did author do that in this illustration?
18:45:56 <Profpatsch> I was thinking paramorphism, could that work?
18:46:10 <crucify_me> changed*
18:46:20 <dmwit> crucify_me: Because `(:) :: a -> [a] -> [a]`.
18:47:19 <crucify_me> dmwit: sorry one moment not sure I follow
18:47:23 <Profpatsch> oh lol, and I hadn’t noticed that foldr is a renamed catamorphism.
18:48:07 <dmwit> crucify_me: `h x : unfold p h t (t x)` is `(:)` applied to arguments `h x` and `unfold p h t (t x)`.
18:48:43 <dmwit> crucify_me: Since `(:) :: a -> [a] -> [a]`, then we know that `foo : bar` is definitely a list.
18:49:07 <Tuplanolla> None of the matrix libraries I've tried work.
18:49:18 <Tuplanolla> At least I got to write this: https://github.com/Daniel-Diaz/matrix/issues/52
18:49:36 <crucify_me> right, thanks dmwit.. but see how on line 9 the author used e. what is the reasoning they used to change it to f in line 20? meaning [f]
18:50:16 <codeshot> Profpatsch, What about using (,)
18:51:08 <dmwit> crucify_me: It's just to avoid confusion. You wouldn't want to use `[e]` and risk confusing newcomers into worrying about what type satisfies the equation `e ~ [e]`.
18:51:13 <Profpatsch> codeshot: Yes, that’s the gist of it https://stackoverflow.com/a/13317563/1382925
18:51:38 <mniip> hmm
18:51:41 <codeshot> Profpatsch, perhaps Reader will help, each layer can save it's original value for the next to access
18:51:45 <mniip> I couldn't break lambdabot but I found another bug in GHC
18:51:46 <Profpatsch> para seems to be no more expressive, since you can implement it by tupling up your original value, as you suggested.
18:51:56 <codeshot> I think
18:52:28 <Profpatsch> codeshot: My problem is that I’m in a quite untyped setting (nix expressions) and want to make the code rigorous nonetheless.
18:52:38 <crucify_me> I see thanks dmwit   ..   also ...
18:53:02 <codeshot> is paramorphism another word for recursion while catamorphism for corecursion?
18:53:07 <Profpatsch> If I can break it down to a call to e.g. para, it’s a lot easier to deal with the structure.
18:53:29 <crucify_me> is the function name to imply that this is related to the inverse of what fold does? 
18:53:41 <Profpatsch> codeshot: Paramorphism is a catamorphism (say: foldr) that has access to one intermediate uncollapsed step from before.
18:53:48 <crucify_me> unfold
18:53:49 <dmwit> crucify_me: yes
18:54:02 <dmwit> `foldr` consumes a list. `unfold` produces a list.
18:54:03 <Profpatsch> So unfold should be anamorphism <- codeshot 
18:54:19 <dmwit> crucify_me: But I hate the type they are using for `unfold`. =)
18:54:43 <Profpatsch> catamorphism = collapsing at structure, anamorphism = building a structure.
18:54:48 <dmwit> crucify_me: `unfold :: (b -> Maybe (a, b)) -> b -> [a]` is much better. =P
18:54:49 <dmwit> :t unfoldr
18:54:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
18:55:01 <dmwit> oh yay, the base libraries agree with me =)
18:55:29 <crucify_me> dmwit: thanks .. hmm I don't know about Maybe yet. it always sets me back
18:55:31 <codeshot> well, that's super easy. You can write a higher order function that wraps a single step, and apply fix to it
18:55:57 <codeshot> this higher order function should be usable with any single step that takes two arguments
18:56:23 <mniip> am I right in understanding that  \x -> let ?x = x in f[x \\ ?x
18:56:36 <dmwit> NO CARRIER
18:56:37 <mniip> am I right in understanding that  (\x -> let ?x = x in f[x \ ?x]) = (\x -> f)
18:56:37 <codeshot> ((->) a) which we were just talking about could easily be a neato part of the solution too
18:56:49 <Profpatsch> It’s confusing, because the seemingly unrelated fold/unfold discussion kind of merged with my question about cata/ana. :D
18:57:15 <Profpatsch> But that’s a new insight! Awesome.
18:57:31 <mniip> > let ?x = undefined in let !() = ?x in ()
18:57:33 <lambdabot>  ()
18:57:37 <mniip> > let x = undefined in let !() = x in ()
18:57:39 <lambdabot>  *Exception: Prelude.undefined
18:59:36 <mniip> it seems that any sort of bang patterns where the rhs involves an implicit param are discarded?
19:00:13 <Average-user> jle`: How does it take 14 Part B to you?
19:01:33 <Broli> please Help https://pastebin.com/PbTtVUqy Thanks
19:02:25 <crucify_me> dmwit: I tried to use that type with Maybe as unfold:       unfold :: (b -> Maybe (a,b)) -> b -> [a] 
19:02:52 <crucify_me> plenty errors
19:03:34 <dmwit> Um. This is going to sound stupid, but... you did change the implementation to match the type, right?
19:04:35 <crucify_me> well, I'm a bit confused about this right now
19:04:41 <crucify_me> no
19:05:06 <crucify_me> esp since I don't know how to use Maybe
19:07:18 <Broli> dmwit: please help me too! :)
19:08:14 <mniip> Broli, that type doesn't look correct
19:09:16 <mniip> consider va = 0, f = \() -> 0
19:09:26 <dmwit> Broli: What do you think that type error says?
19:09:43 <mniip> foldPosNat 0 (\() -> 0) (Succ One)
19:10:17 <mniip> = (\() -> 0) $ foldPosNat 0 ((\() -> 0) One)
19:10:22 <mniip> that's a violation of f's type
19:10:24 <mniip> twice even
19:10:27 <dmwit> Broli: Alternate hint: what happens if you omit the type signature entirely?
19:11:09 <mniip> dmwit, hmm without peeking I think it's going to infer some crazy type or even occurs check
19:11:15 <mniip> because of how odd the definition is
19:11:39 <mniip> ah no
19:11:43 <mniip> regular type error
19:12:11 <dmwit> Oh, yeah, there's some extra parentheses. Okay. Hard to tell if that's just a typo or an honest programming mistake.
19:12:12 <mniip> Broli, you really have to rethink that type
19:12:35 <mniip> you seem to have neither a good understanding of what the type should be, nor what the definition should be
19:12:41 <mniip> and that's not a good way forward
19:13:18 <dmwit> wait
19:13:24 <dmwit> That error doesn't match the source code posted.
19:13:47 <dmwit> The error mentions `foldPosNat va f xs`, which does not appear in the source code above.
19:13:52 <Broli> mniip: which one? 
19:14:16 <mniip> dmwit, nice catch
19:14:37 <crucify_me> unfold :: (b -> Maybe (a, b)) -> b -> [a]    dmwit    hey quickly would you mind showing me the implementation to this type? 
19:14:41 <bigos_> Where is the right place to talk about installation instructions for Haskell and Gtk on Windows 10?
19:14:57 <Broli> dmwit: Sorry https://pastebin.com/PCkVf6rH
19:14:59 <mniip> "implementation" to this "type"?
19:15:00 <crucify_me> I assume that is a sort of logic branch
19:15:17 <dmwit> ?src unfoldr
19:15:17 <lambdabot> unfoldr f b = case f b of
19:15:17 <lambdabot>     Just (a, b') -> a : unfoldr f b'
19:15:18 <lambdabot>     Nothing      -> []
19:15:36 <crucify_me> @src unfoldr
19:15:36 <lambdabot> unfoldr f b = case f b of
19:15:36 <lambdabot>     Just (a, b') -> a : unfoldr f b'
19:15:36 <lambdabot>     Nothing      -> []
19:15:45 <mniip> Broli, yeah that infers a signature by itself
19:16:05 <Broli> mniip: do you mean PosNat?
19:16:21 <mniip> if you omit the signature for foldPosNat
19:16:27 <mniip> it infers the right one itself
19:16:37 <crucify_me> no clue thanks. I'll try while fresh tomm.
19:17:14 <Broli> mniip: here is the signature of FoldPostNat: foldPosNat :: Num val => val -> (a -> val) -> PosNat -> val
19:17:31 <mniip> that's wrong
19:17:47 <Broli> mniip: why?
19:18:23 <Broli> please help me to do it right, i am a newbie in haskell
19:18:32 <dmwit> Broli: I ask again: what do you think that type error says?
19:18:50 <dmwit> It is good exercise to practice reading these errors, because you will see them a lot.
19:19:09 <Broli> dmwit: i'am not sure but i think, he does not match something
19:20:09 <Broli> dmwit: i have looked for that and i find https://stackoverflow.com/questions/4629883/rigid-type-variable-error
19:20:55 <mniip> Broli, okay, consider this
19:21:03 <Broli> dmwit: but i did not help me to solve the problem
19:21:05 <mniip> foo :: a -> b -> a
19:21:07 <mniip> foo x y = y
19:21:18 <mniip> this will give the same type error but in a more constrained fashion
19:21:27 <Broli> mniip: it is wrong
19:21:40 <mniip> if you look at that type error,
19:21:44 <mniip>     • Couldn't match expected type ‘a’ with actual type ‘b’
19:21:50 <dmwit> Broli: What exactly didn't match?
19:22:01 <mniip> it's telling you that you tried to use something of type 'b' in a place that expects type 'a'
19:22:08 <mniip> where a and b are *rigid* type variables
19:22:24 <mniip> which means that you don't get to choose them, instead the opposite, your "enemy" chooses them
19:22:37 <dmwit> Broli: That SO question (and answer) are unrelated to your problem. You may waste no further energy on them.
19:22:41 <mniip> and you assumed they are equal, which is not a rightful assumption to make
19:22:51 <mniip> hence, error
19:23:55 <Profpatsch> But that’s a new insight! Awesome.
19:23:58 <Profpatsch> sr
19:23:59 <Profpatsch> y
19:24:04 <Profpatsch> Meh, what am I doing.
19:26:26 <codeshot> Profpatsch, so paramorphism = translating structure without adding or losing any?
19:26:56 <dmwit> Uh. I don't think you get to promise "without adding or losing any".
19:27:31 <dmwit> In fact, I'm not sure I'm on board with "translating structure", either.
19:27:56 <dmwit> A paramorphism is like a catamorphism that gets to see both the recursive result and the entire rest of the data structure at each folding step.
19:30:26 <Profpatsch> dmwit: Yeah, you get access to the Fix f, so you can unfold as many layers of the substructure as you like, right?
19:31:10 <dmwit> yes
19:31:39 <Profpatsch> e.g. Fix f where f is data TreeF f = Leaf | Split f Int f
19:32:04 * hackage siphon 0.8.0 - Encode and decode CSV files  https://hackage.haskell.org/package/siphon-0.8.0 (andrewthad)
19:33:22 <Profpatsch> So part of your step could be  step result (Fix (Split (Split Leaf iLeft Leaf) iParent Leaf)) = sometransformation
19:33:47 <dsal> dmwit: is that scanl?
19:34:13 <Profpatsch> e.g. if you want to change your results based on a certain structure of multiple depths.
19:34:28 <Profpatsch> histomorphisms get crazy.
19:34:51 <Profpatsch> Oh, and I forgot the Fix constructors after depth 0
19:35:21 <dmwit> dsal: no
19:35:32 <Profpatsch> So creating pattern aliases could be a good idea to reduce boilerplate.
19:35:38 <dmwit> :t foldr
19:35:39 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
19:37:08 <dmwit> :t \cons nil -> snd . foldr (\x (xs, b) -> (x:xs, cons x b)) nil
19:37:10 <lambdabot> Foldable t1 => (t2 -> c -> c) -> ([t2], c) -> t1 t2 -> c
19:37:12 <Profpatsch> I wonder: To allow recursive constructors, the type-checker has to be lazy as well, right?
19:37:28 <dmwit> :t \cons nil -> snd . foldr (\x (xs, b) -> (x:xs, cons x b)) ([], nil)
19:37:30 <lambdabot> Foldable t1 => (t2 -> c -> c) -> c -> t1 t2 -> c
19:37:45 <dmwit> ah, right
19:37:57 <dmwit> :t \cons nil -> snd . foldr (\x (xs, b) -> (x:xs, cons x xs b)) ([], nil)
19:37:58 <lambdabot> Foldable t1 => (t2 -> [t2] -> c -> c) -> c -> t1 t2 -> c
19:38:12 <dmwit> dsal: Something like that.
19:38:22 <Profpatsch> dmwit: That’s more overhead than the definition of para by a function and then foldr/cata in terms of the specialization, right?
19:38:49 <Profpatsch> Because of the tuple.
19:39:09 <Profpatsch> Well, I guess you could eliminate it by a smart rewrite rule.
19:39:12 <dmwit> ¯\_(ツ)_/¯
19:39:28 <Profpatsch> Oh, new thing: That’s how the builder pattern works, right?
19:40:29 <Profpatsch> I always <> ", right?", so people don’t get the feeling I know what I’m talking about. :P
20:12:52 <angerman> Anyone ever stacked multiple monad-log together?
20:13:09 <angerman> I'd like to have one stdout log and one file log, with different formats, and different log messages.
20:19:56 <Average-user> hey, have someone seen twin peaks?
20:37:21 <mniip> int-e, are you around?
20:38:35 <srpx> https://www.reddit.com/r/haskell/comments/7jxfr3/what_is_the_easiest_way_to_extend_morte_to_enable/
20:54:20 * hackage megaparsec 6.3.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-6.3.0 (mrkkrp)
20:56:14 <iqubic> Isn't that the same the thing that parsec does?
21:04:43 <geekosaur> it's more or less modernized parsec
21:05:02 <geekosaur> uses Applicative instead of the built-in stuff that predates Control.Applicative, has various bug fixes, etc.
21:05:58 <glguy> Don't forget your AoC!
21:06:43 <mniip> screw you
21:06:49 * hackage markdown-unlit 0.5.0 - Literate Haskell support for Markdown  https://hackage.haskell.org/package/markdown-unlit-0.5.0 (SimonHengel)
21:06:55 <glguy> o.O
21:07:01 <iqubic> glguy: I am so far behind in AoC. I still haven't started day 1.
21:07:11 <iqubic> I have done none of the days.
21:07:14 <mniip> I had to wait out a minute because I forgot to use my puzzle input :(
21:07:47 <iqubic> I really need to get off my lazy bum and set-up intero and magit and projectile.
21:08:00 <mniip> could have been finally faster than glguy
21:08:12 <iqubic> Where do you all live?
21:08:28 <mniip> earth, usually
21:09:07 <iqubic> I really need to spend some time and do all the first 13 days.
21:10:27 <iqubic> But I have to first 13 days first. How long will that take do you think?
21:11:27 <mniip> iqubic, about 4 hours
21:11:56 <iqubic> Cool. 
21:12:27 <mniip> also I am totally guilty of using C++ today
21:12:58 <glguy> iqubic: If you can knock that out in 4 hours I'll be impressed
21:14:13 <iqubic> Yeah, I was planning on doing it this weekend.
21:14:50 <MarcelineVQ> you could also start now
21:15:10 <MarcelineVQ> Then you wouldn't have to find time to get started on it later
21:15:45 <mniip> I gave a generous esimation of 15 minutes per task
21:15:51 <mniip> which would probably be correct for me
21:16:25 <cocreature> not everyone is as fast as you are :)
21:16:30 <glguy> adding up my times so far and rounding all of them up to the next minute it's taken about 145 minutes
21:17:18 <mniip> the instant I saw 40000000 I thought of anything but haskell
21:17:38 <mniip> cocreature, that's what she said
21:17:53 <glguy> Haskell did it fast enough
21:18:15 <mniip> what's your timing for part 2
21:18:22 <mniip> mine's 0.46
21:18:24 <glguy> Nothing clever list solution took 0m2.286s for botht parts
21:18:41 <iqubic> Do you guys use a different file for both days?
21:18:52 <cocreature> mniip: 0.46s for a Haskell solution?
21:18:53 <mniip> no
21:18:57 <iqubic> As in a different program for parts 1 and 2?
21:18:57 <mniip> like I said C++
21:19:09 <mniip> iqubic, usually I would just amend the day1 program
21:19:12 <iqubic> by days I mean parts.
21:19:14 <mniip> without even making a copy
21:19:18 <glguy> > hex # 2147483647
21:19:21 <lambdabot>  "7fffffff"
21:19:40 <mniip> I wonder how many people made the mistake of thinking they can just AND with that
21:19:53 <iqubic> Oh. I'm going to be putting this on github, so I need to get magit going first.
21:20:26 <iqubic> Does intero work well with multiple executable sections in my stack.cabal file?
21:20:43 <iqubic> glguy, you have all the days in one project, right?
21:20:52 <kebertx[m]> I've been away from Haskell for a long while now, so forgive me if this is a silly question: Do people still use `stack`?
21:20:55 <glguy> Yeah, one .cabal file
21:20:59 <MarcelineVQ> iqubic: btw did you try target syntax for ghci like I mentioned earlier?
21:21:03 <monochrom> Have you tried vanilla haskell-mode and vanilla cabal-install?
21:21:05 <glguy> kebertx[m]: some do
21:21:17 <iqubic> I didn't.
21:21:58 <iqubic> That answers both MarcelineVQ and monochrom. I haven't tried either of those things
21:21:59 <kebertx[m]> It was really nice last time I checked, but I'm getting some seriously strange behavior right now
21:22:08 <monochrom> kebertx[m]: I still don't use stack. :)
21:22:20 <iqubic> glguy: What do you uuse for AoC?
21:22:27 <glguy> iqubic: Haskell
21:22:37 <iqubic> monochrom: What do you use instead of haskell?
21:22:53 <monochrom> I use Haskell.
21:23:06 <MarcelineVQ> does anyone have a nix primer, especially nix + ghc? I'm going some work with old ghc's of multiple versions and my system is uhm, not really happy about all of that
21:23:08 <monochrom> I use cabal-install and emacs haskell-mode.
21:23:21 <monochrom> They togethr also work just fine with multiple exe sections.
21:23:21 <iqubic> glguy: I figured that. Do you use a single stack project, or a different project per day?
21:23:25 <glguy> Yeah, cabal-install, dante (if I use emacs)
21:23:28 <glguy> No, I don't use stack
21:23:33 <monochrom> Almost zero config from me.
21:23:43 <iqubic> What do use instead of stack glguy?
21:24:37 <kebertx[m]> I can use cabal to build things just fine, but how do you manage libraries and dependencies?
21:24:50 <glguy> Just normal cabal-install
21:25:05 <glguy> You specific the versions of packages you use in your .cabal file
21:25:08 <monochrom> I am not quite aware what's there to manage.
21:25:28 <iqubic> Is it the same format as Stack?
21:25:48 <iqubic> What program and packages do you use to edit the code?
21:25:59 <glguy> Vim's good at editing code
21:26:06 <monochrom> I even global-install some packages I judge to be universally useful for all my Haskell code.
21:26:24 <kebertx[m]> Stack uses cabal internally, but if I understand correctly it also manages a nix-os style database of package versions for you
21:26:31 <monochrom> For example when I need aeson I just install it as global.
21:26:48 <kebertx[m]> So you can have multiple conflicting versions of something, and switch between them on the fl
21:26:51 <kebertx[m]> *fly
21:27:01 <glguy> yeah, new-build handles that just fine
21:27:17 <kebertx[m]> new-build?
21:27:41 <iqubic> Is it fine if I want to use stack and Intero for AoC?
21:27:59 <glguy> iqubic: It doesn't matter to me in the slightest. Use whatever you're comfortable with!
21:28:34 <kahlil29> what is the best/easiest way to parse a String into a LocalTime? 
21:28:54 <glguy> kahlil29: With parseTimeM from Data.Time.Format
21:29:09 <iqubic> I have no experince with any of these tools. All I have is emacs experience.
21:30:22 <kebertx[m]> Anyways, I **think** I have a ridiculous bug with my version of stack --- is there any reason why it should *revert* my .cabal file when I run `stack ghci`?
21:30:28 <kebertx[m]> Because It's doing that
21:30:41 <glguy> kebertx[m]: You need to delete the package.yaml file to stop that
21:30:50 <glguy> or it will overwrite your .cabal file
21:30:58 <monochrom> stack is like God. They like to test your faith.
21:31:03 <kahlil29> why is the parseTime function deprecated? I would prefer a Maybe result so that I can handle it the way I want to. The newer function descriptions say that they "fail" if they can't parse the String. What does that mean?
21:31:23 <glguy> kahlil29: It means they use the Monad "fail" method, which for Maybe means it returns a Nothing
21:31:29 <iqubic> What workflow is the easiest to get rolling?
21:31:47 <iqubic> This is a new system that I have yet to get a working Haskell workflow on.
21:31:50 <vaibhavsagar> iqubic: in my experience, stack is the easiest to get up and running with
21:32:08 <iqubic> I have stack.
21:32:49 <kahlil29> glguy: sounds good. What do I pass as TimeLocale considering I want a LocalTime returned? 
21:32:54 <monochrom> Yeah parseTimeM is still compatible with Maybe. It just generalizes (in the wrong direction but meh).
21:33:07 <glguy> kahlil29: defaultTimeLocale is the most common
21:33:26 <kahlil29> which would give American LocalTime, am I right? 
21:33:28 <kebertx[m]> glguy: Wait, seriously?
21:38:05 <kebertx[m]> That's new-ish, I don't think I had to deal with that file in Obama's America
21:38:24 <geekosaur> kebertx[m], these days it autogenerates cabal files, yes. you need to delete the package.yaml file to make stack not autogenerate a cabal file from it. and yes, that's fairly new
21:39:07 <kahlil29> glguy: what if I want the LocalTime to be UTC +0530 ? i.e. IST 
21:40:00 <glguy> kahlil29: localtimes don't have a timezone
21:40:22 <glguy> kahlil29: But instead perhaps you wanted a ZonedTime, which is a LocalTime + a TimeZone
21:40:57 <kahlil29> no, I need a LocalTime only. but it would vary depending on what TimeLocale I pass to the parseTimeM fn right? 
21:41:04 <glguy> no
21:45:32 <HallaSurvivor> Hey, all! I'm writing a model checker, and I have a bunch of code for dealing with DFAs, most notably:
21:45:41 <HallaSurvivor> intersect :: DFA s -> DFA t -> DFA (s,t)
21:45:55 <HallaSurvivor> where s, t are the state types, and we output the usual product construction
21:46:31 <HallaSurvivor> but I'm currently writing the code which turns a logical sentence into a DFA, and I need to parametrizie over the DFA state type
21:46:33 <HallaSurvivor> i.e.
21:47:02 <HallaSurvivor> prop2Dfa getRelation (Atom c) = getRelation c
21:47:32 <HallaSurvivor> prop2Dfa getRelation (And p1 p2) = Dfa.intersect (prop2Dfa getRelation p1) (prop2Dfa getRelation p2)
21:48:06 <HallaSurvivor> and so in the first clause, we return a DFA s
21:48:22 <HallaSurvivor> but in the second clause, we return a DFA (s,t) for some (currently unknown) s and t
21:48:28 <HallaSurvivor> and the type system is understandably unhappy
21:48:44 <HallaSurvivor> what's the standard approach to solving this?
21:52:11 <Guest78_> If I import Data.Typeable and eval "show $ typeOf (+)" I get "Integer -> Integer -> Integer". How can I get that as an AST / s-exp / something more parsed?
21:58:56 <Lokathor> @pl \x -> x % 4 == 0
21:58:56 <lambdabot> (0 ==) . (% 4)
22:01:04 <geekosaur> Guest78_, https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.10.1.0/Data-Typeable.html#g:7 can be used to deconstruct a TypeRep to some extent
22:01:39 <geekosaur> the actual representation is something internal and looks like it's missing various things, probably because they're simply not available at runtime
22:03:04 <geekosaur> (types don;t normally exist at runtime. once the compiler finishes typechecking, the types are removed and typeclasses become records-of-functions dictionary parameters)
22:03:48 <Guest78_> hmm Ok I will play around with those functions. I'm also looking into possibly having to use the GHC API get the types through "typecheckModule" maybe
22:05:31 <kahlil29> glguy: you still there? parseTimeM has a Monad constraint that's confusing me
22:05:48 <glguy> kahlil29: Maybe has a Monad instance
22:07:09 <kahlil29> so how do I give that as a constraint? not experienced with Monads
22:07:14 <kahlil29> glguy 
22:07:23 <Guest78_> @geekosaur I got it - "splitTyConApp $ typeOf (+)" -> "((->),[Integer,Integer -> Integer])" - thanks a lot for the pointer
22:07:23 <lambdabot> Unknown command, try @list
22:08:04 <Guest78_> splitTyConApp is exactly what I wanted, unbelievable, I will be able to avoid the heavier GHC API 
22:08:21 <geekosaur> at least until you need kind information :)
22:11:17 <geekosaur> kahlil29, it;s using an old trick. if you use its result as a Maybe t (i.e. check for Just / Nothing) then you have specified m as Maybe
22:11:47 <geekosaur> if you check the result as Left errmsg / Right result, m will be Either
22:12:16 <cocreature> you can also just specify the type explicitely
22:12:47 <kahlil29> geekosaur: makes sense, thanks! 
22:13:00 <kahlil29> cocreature: by using a type annotation? 
22:13:01 <geekosaur> dunno if it supports full generality of a list but at least hypothetically you could check for an empty list = fail or otherwise it could be a list of possible results ()this might be significant for string timezones, which aren't always distinct)
22:13:36 <cocreature> kahlil29: yes, e.g. (parseTimeM … … …) :: Maybe LocalTime
22:14:03 <kahlil29> cocreature: worked perfectly. thanks a lot! 
22:14:32 <Guest78_> geekosaur why are some things not Typeable and how do you recommend I get the typeOf (<*>) ? -> "No instance for (Typeable f0)"
22:15:01 <geekosaur> the current Typeable will monomorphize those things that can be defaulted, if they are polymorphic then it simply fails
22:15:34 <geekosaur> there is an upcoming kind-indexed Typeable that will be able to handle polymorphic types, but I suspect it'll be more difficult to use as a result
22:16:04 <geekosaur> that is, thre actual type of (+) is Num a => a -> a -> a, but Haskell's defaulting can be used to get Integer as a concrete type
22:16:08 <cocreature> oh yet another change to Typeable? I vaguely recall that we did already get al relatively large change in 8.2
22:16:13 <Guest78_> so if I need the kind of information that splitTyConApp . typeOf is gives me, but for any given function, I'll need my "own ghci" i.e. the GHC API I guess is my only choice now?
22:16:50 <Guest78_> geekosaur haha you're so right, I never noticed it gave me Integer -> Integer -> Integer instead of the typeclassed signature!
22:16:51 <geekosaur> cocreature, if so then maybe we have the kind-indexed one but it's not exposed yet
22:16:52 <cocreature> https://hackage.haskell.org/package/base-4.10.1.0/docs/Type-Reflection.html was the one I had in mind
22:17:05 <geekosaur> ah, exposed but in a different place
22:17:17 <geekosaur> Guest78_, you might look at what cocreature pointed to in that case
22:17:36 <cocreature> I haven’t actually used it so no idea if it helps :)
22:18:09 <geekosaur> I know kind-indexed typeable was coming, and that it was intended for 8.2, but no other details
22:18:20 <Guest78_> hmm ok I'm reading that
22:18:22 <geekosaur> ...but that does indeed look like it
22:18:31 <geekosaur> so Data.Typeable is a compatibility interface
22:18:55 <Guest78_> all of those functions work on TypeRep which I cannot get from/for (<*>)
22:20:20 <geekosaur> yeh, noticed it still says monomorphic. no idea then
22:21:14 <cocreature> Guest78_: do you have some underlying problem that you are trying to solve? maybe there is a solution that doesn’t involve Typeable
22:21:24 <geekosaur> oh this is still type-indexed
22:21:49 * hackage servant-quickcheck 0.0.5.0 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.5.0 (jkarni)
22:21:50 <Guest78_> cocreature: thank you. yes, the underlying problem is eventually I want to draw those types as an AST.
22:24:28 * geekosaur digs deeper, finds self looking at a function whose documentation is "Exquisitely unsafe."
22:26:46 <Guest78_> https://downloads.haskell.org/~ghc/6.12.1/docs/html/libraries/ghc-6.12.1/HscTypes.html#t%3ATypeEnv
22:26:50 <Guest78_> sorry for the outdated link
22:26:53 <cocreature> Guest78_: but for which purpose? it sounds like maybe the GHC API is a better choice after all
22:26:55 <Guest78_> but I think that's it
22:27:12 <Guest78_> cocreature: the purpose is to visualize the types.
22:27:32 <Guest78_> try to find ways to draw them that may be helpful or inducing insight
22:28:12 <Guest78_> I can get that TypeEnv thing from running typecheckModule as explained here: https://wiki.haskell.org/GHC/As_a_library
22:28:46 <Guest78_> so let me try that and I'll come back if I can't ;) thanks again.
22:31:10 <Guest78_> geekosaur thanks for looking into this for me. I think I have no choice but to use the full GHC API since ultimately I want exactly the type of things as reported by ghci...
22:31:23 * hackage hup 0.3.0.0 - Upload packages or documentation to a hackage server  https://hackage.haskell.org/package/hup-0.3.0.0 (phlummox)
22:43:51 * hackage hmatrix-quadprogpp 0.4.0.0 - Bindings to the QuadProg++ quadratic programming library  https://hackage.haskell.org/package/hmatrix-quadprogpp-0.4.0.0 (AkioTakano)
23:37:04 <kahlil29> is there a function to extract out a subset of a list based on indices? like say take a subset list of 3 elements (index 3, 4  and 5)  from a bigger list of 10 or 20 elements? 
23:38:02 <opqdonut> wellll,
23:38:23 <opqdonut> > map (["foo","ding","dong","bar"]!!) [1,3]
23:38:25 <lambdabot>  ["ding","bar"]
23:38:31 <opqdonut> but that's not too efficient of course
23:38:38 <opqdonut> you'll have to write it yourself I guess
23:39:19 <mniip> I can only imagine an ST-esque efficient implementation
23:39:28 <mniip> that is, not a pure one
23:40:36 <kahlil29> would it be better to use takeWhile and in the condition argument, check for each index equality ? 
23:40:54 <opqdonut> I'd just type out the recursive function
23:41:55 <kahlil29> opqdonut: thanks 
23:43:16 <opqdonut> > let selectIndexes is xs = go 0 is xs where go j (i:is) (x:xs) | j==i = x:go (succ j) is xs | otherwise = go (succ j) (i:is) xs; go _ _ _ = [] in  selectIndexes [1,3] ["foo","ding","dong","bar"]
23:43:18 <lambdabot>  ["ding","bar"]
23:43:20 <opqdonut> there
23:43:35 <opqdonut> that's optimal, given that we're working with lists
23:43:43 <opqdonut> assumes indexes are sorted, though
23:45:42 <mniip> umm
23:45:50 <mniip> that's not an assumption I was planning to make
23:46:52 <mniip> oh also obviously there's this
23:46:54 <mniip> :t \xs is -> map (listArray (0, length xs - 1) xs !) is
23:46:55 <lambdabot> [b] -> [Int] -> [b]
23:47:25 <mniip> how did I not think of this in first place
23:47:30 <MarcelineVQ> > (\i j -> take j . drop i) 2 3 [1..20] -- what about something boring
23:47:33 <lambdabot>  [3,4,5]
23:48:21 <axesd9> :t 1
23:48:22 <lambdabot> Num p => p
23:50:12 <opqdonut> oh, a slice not a subsequence, my bad
23:50:49 <opqdonut> mniip: note how the listArray solution is linear just like mine but has worse memory use
23:51:05 <mniip> opqdonut, arbitrary index order
23:51:11 <opqdonut> true
23:51:44 <kahlil29> MarcelineVQ : how does that lambda work? what does the . operator do? 
23:51:52 <kahlil29> seems like the cleanest soln
23:51:58 <opqdonut> . is function composition
23:52:04 <opqdonut> (f . g) x === f (g x)
23:52:29 <opqdonut> but yeah if you want a contiguous slice, take&drop is nice
23:53:11 <kahlil29> yeah I am sure that it will always be a contiguous slice in my case 
23:53:21 <kahlil29> thanks everyone :) 
