00:23:52 <ertes-w> hllo
00:24:07 <joebetz> @let setFromSnds x = nubBy cmpSnd x where cmpSnd (_, y) (_, y') = y == y'
00:24:10 <lambdabot>  Defined.
00:24:55 <liste> :t (==) `on` snd
00:24:57 <lambdabot> Eq a1 => (a2, a1) -> (a2, a1) -> Bool
00:25:19 <joebetz> heh, nice
00:25:28 <joebetz> was about to ask if there was a better way to do that
00:25:44 <joebetz> my solution doesn't scale
00:28:24 <joebetz> it'd probably be better to use a product type instead of a tuple, with equality defined over the second value
00:28:49 <Kristjan> My name is Kristjan. I am in urgent need for money. Please send me money. For example 70$. Bank account nr: EE671010010225901016 (Estonia). Name: Kristjan Robam
00:29:20 <ventonegro> Does this actually work?
00:30:34 <joebetz> > setFromSnds [(1, 1), (2,1), (3,2)]
00:30:37 <lambdabot>  [(1,1),(3,2)]
00:31:48 <vaibhavsagar> > nubBy (compare `on` snd) [(1,1), (2,1), (3,2)]
00:31:50 <lambdabot>  error:
00:31:50 <lambdabot>      • Couldn't match type ‘Ordering’ with ‘Bool’
00:31:50 <lambdabot>        Expected type: (a, a1) -> (a, a1) -> Bool
00:32:10 <vaibhavsagar> > nubBy ((==) `on` snd) [(1,1), (2,1), (3,2)]
00:32:12 <lambdabot>  [(1,1),(3,2)]
00:32:19 <vaibhavsagar> :D
00:32:40 <vaibhavsagar> @let setFromSnds' = nubBy ((==) `on` snd)
00:32:42 <lambdabot>  Defined.
00:33:18 <joebetz> nice :)
00:33:42 <dminuoso> Good morning folks. I'd like some code critism. Aside from the inadequacy of using a linked list, are there any meaningful improvements I could do to this implementation of graham scan? https://gist.github.com/dminuoso/390d910c963fcdd5632a37f1e0d083fd
00:33:48 <ertes-w> joebetz: just use Map
00:34:41 <ertes-w> > M.fromList (map swap [(1,2), (3,4), (5,6)])
00:34:44 <lambdabot>  fromList [(2,1),(4,3),(6,5)]
00:34:52 <vaibhavsagar> dminuoso: you could simplify using V2 from the `linear` package
00:35:26 <vaibhavsagar> it would get rid of your `sub` and `dot` functions at least
00:35:45 <quchen> dminuoso: The »case signum of …« should be a »case compare x 0 of«. You’re relying on the Eq instance of numbers, you’re not matching lots of other integers that only you as a programmer knows can never happen.
00:36:21 <quchen> dminuoso: Why Floating? Why not Double directly? Unnecessary polymorphism.
00:36:37 <dminuoso> quchen: The use of sqrt/acos
00:36:38 <quchen> Same for the Num constraints.
00:37:06 <dminuoso> quchen: Oh you mean I should have restricted it to Double straight away? Ive been led to believe it might be good behavior to not constraint your types too much.
00:37:46 <dminuoso> quchen: Also is `compare x 0` a wise thing to do with floating numbers?
00:38:06 <quchen> Sure, why not. Other than NaN shenanigans it’s fine.
00:38:31 <quchen> (What’s the sign of NaN? What would the code do here?)
00:38:40 <quchen> What’s the sign of 0?
00:38:45 <quchen> What’s the sign of (-0)?
00:38:53 <dminuoso> Oh I see what you mean.
00:39:20 <quchen> Equality on Double is a perfectly fine operation
00:39:41 <quchen> Thinking Doubles are real numbers is the mistake that leads to equality being wonky, but that’s not equality’s fault
00:40:46 <ertes-w> dminuoso: well, you already know how i would do it =)
00:40:46 <dminuoso> quchen: Interesting, so compare restricts types even further.
00:40:59 <dminuoso> ertes-w: You mean the mutable vectors? :)
00:41:13 <ertes-w> but you mentioned you wanted to benchmark the list-based one against the vector-based one
00:41:28 <dminuoso> Yeah, just wanted to have this looked at before I rewrote for vector.
00:42:41 <joebetz> ertes-w: ah, much better. thanks.
00:43:00 <mniip> 1513672728 [11:38:48] <quchen> Equality on Double is a perfectly fine operation
00:43:05 <mniip> but it's not reflexive?
00:43:26 <quchen> Well, Double without NaN.
00:43:41 <quchen> Equality on Double without bottom or NaN is a perfectly fine operation. There you go.
00:44:46 <mniip> "perfectly fine"
00:44:53 <mniip> well let's see, it's an equivalence relation
00:45:02 <mniip> no other axioms whatsoever
00:45:04 <ertes-w> there are so many things wrong with (==) on Double…
00:45:57 <quchen> I’ve had one use case for it so far, and that was for timestamps that weren’t terribly important.
00:49:00 <dminuoso> ertes-w: Would have done the vector yesterday already, but I was busy exploring visualization options to find a bug in my implementation. But I have an svg builder now, so there's that. :-)
00:50:41 <liste> doesn't an equivalence relation need to be reflexive?
00:50:48 <liste> > let x = 0.0/0.0 in x == x
00:50:51 <lambdabot>  False
00:50:59 <dminuoso> It's kind of weird how mathematical problems become trivial to solve, but side effects like just drawing data are surprisingly tricky in Haskell.
00:51:31 <bollu> Isn't that because NaN /= NaN?
00:51:32 <vaibhavsagar> dminuoso: would you expect the opposite?
00:51:39 <liste> bollu: yes
00:51:40 <bollu> What does it have to do with side effects? :)
00:52:07 <tdammers> drawing isn't tricky in Haskell, given suitable libraries
00:52:17 <tdammers> not trickier than in any other language, anyway
00:52:43 <dminuoso> Well Im not going to show the silly svg hack I applied yesterday =P
00:53:20 <tdammers> svg is actually pretty easy and elegant to produce with pure code
00:53:54 <dminuoso> tdammers: Yeah. I basically ended up generating symbols for each point, some fmap and and some mconcat.
00:54:04 <tdammers> an SVG pipeline would be something like raw data -> drawing primitive AST -> XML AST -> XML bytestring
00:54:05 <dminuoso> And suddenly I had something Show'able. :o
01:02:32 <jle`> ugh Part B yesterday I spent the entire day today looking for my bug
01:02:47 <jle`> turns out it was just that "Program 1's output" meant the second program's output
01:02:58 <jle`> but i was giving the first program's output
01:03:08 <vaibhavsagar> jle`: I was wondering why you had a silver star
01:03:09 <cocreature> jle`: heh I fell into that trap as well
01:09:48 * hackage polyvariadic 0.3.0.2 - Creation and application of polyvariadic functions  https://hackage.haskell.org/package/polyvariadic-0.3.0.2 (fgaz)
01:15:58 * hackage mono-traversable 1.0.6.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.6.0 (MichaelSnoyman)
01:21:49 <mniip> does pattern matching on a data family constructor *require* or *introduce* a typing assumption?
01:22:38 <mniip> I guess it requires
01:22:43 <mniip> by the looks of it
01:26:21 <ertes-w> mniip: i think it introduces, the same way as GADT type refinement
01:26:26 <mniip> nope
01:26:29 <mniip> the opposite
01:35:25 <ertes-w> @let data family Test a; newtype instance Test Int = IntTest Int; newtype instance Test Bool = BoolTest Bool
01:35:27 <lambdabot>  Defined.
01:36:20 <ertes-w> @let tfTest :: Test a -> Maybe a; tfTest (IntTest x) = Just (x + 1); tfTest (BoolTest x) = Just (not x); tfTest _ = Nothing
01:36:21 <lambdabot>  .L.hs:368:9: error:
01:36:21 <lambdabot>      • Couldn't match type ‘a’ with ‘Int’
01:36:22 <lambdabot>        ‘a’ is a rigid type variable bound by
01:36:31 <ertes-w> mniip: looks like you're right
01:38:21 <ertes-w> kinda weird though…  refinement seems more natural to me
01:39:02 <mniip> how do you implement this
01:39:46 <mniip> I mean with gadts a constructor knows at declaration time what coercion witnesses it contains
01:39:49 <mniip> here it's uhh
01:39:51 <mniip> different
01:40:08 <mniip> a newtype instance doesn't even have any space to store a coercion
01:40:28 <mniip> (they have zero size representations but they still take up a slot)
01:46:49 <mniip> I'm having a fun idea
01:53:00 <ertes-w> well, i know nothing about how to implement this…  all i know is that i would have preferred refinement =)
01:56:18 <M-x[m]> Emacs user here. What packages should I install to get the best haskell experience? I used to slime\cider, so I'm looking for something similar (i.e. not just an inferior process buffer)
01:56:52 <Athas> M-x[m]: you will be disappointed.  Nothing is as good as SLIME.
01:57:12 <Athas> But if you install Intero, you'll have something that's pretty good, and which requires a minimum of configuration.
01:57:26 <infinisil> I'm using ghc-mod, but it's been a bit of a pain, had a few problems with it
01:57:31 <drdo> I use haskell-mode
01:57:52 <drdo> definitely not as good as slime, but it's quite useful nonetheless
01:57:55 <M-x[m]> Athas: intero, ok. I'll check that out, thanks.
01:57:55 <infinisil> There's also this, which looks very very promising, but I haven't tried it out: https://github.com/haskell/haskell-ide-engine
01:58:32 <Athas> For Haskell, I tend to prefer just a simple haskell-mode.  The more advanced tooling is just too brittle.
01:58:43 <Athas> SLIME is great because it's very reliable as well.
01:59:10 <Athas> (Or at least it was - I have not used it for many years.)
02:01:16 <M-x[m]> Is that correct that intero uses stack, and stack and cabal are two mutually exclusive build tools?
02:01:49 <Athas> Intero uses stack, which is mutually exclusive with cabal-install.  Both stack and cabal-install use a library called Cabal internally.
02:02:20 <liste> note that cabal-install contains the "cabal" executable
02:02:25 <Athas> Yeah, it's confusing.
02:02:56 <Athas> Typically, a Haskell program can be built with both stack and cabal-install.  It's not an invasive choice.
02:03:07 <Athas> (Since they both use Cabal-the-library internally.)
02:03:42 <Athas> I'd suggest you just use stack for now, and revisit it if something upsets you about it later on.
02:04:10 <M-x[m]> Ok, I see. Thanks.
02:04:19 <infinisil> A few weeks ago i recommended stack on NixOS here. Wanna take that back though, deployment is horrible
02:04:50 <infinisil> Just a NixOS thing though, won't be a problem on other distros
02:04:53 <Athas> Yeah, there are some cases where cabal-install has the edge.  NixOS is one, another is using custom versions of GHC.
02:06:34 <infinisil> I have yet to convert my stack project to something better
02:07:25 * hackage yesod-bin 1.5.3 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.5.3 (MichaelSnoyman)
02:08:50 <Athas> Well, stack *is* really good.
02:09:04 <infinisil> (except on NixOS where it's really bad)
02:10:44 <vaibhavsagar> infinisil: how does it break down on NixOS?
02:11:06 <mniip> are GHC RULES pragmas powerful enough to distinguish linear uses of objects?
02:11:16 <infinisil> Short explanation: Nix(OS) doesn't cache build artifacts, so everytime you build your stack project it needs to download the build plan, packaging and build everything. Upon a build failure you start again from the beginning. This is only if you want to deploy it though, you can use the regular (and fast) stack command for developing
02:11:44 <vaibhavsagar> infinisil: Nix definitely caches build artifacts
02:11:55 <vaibhavsagar> you mean Stack+Nix does not?
02:12:06 <infinisil> nix-build does not, you can't reuse previous build artifacts
02:12:19 <infinisil> stack build does, it just puts everything in the local directory
02:12:23 <vaibhavsagar> ahh, you mean of your project
02:12:50 <vaibhavsagar> Nix-build caches build artifacts too though
02:12:59 <vaibhavsagar> maybe this is a stack+nix thing
02:13:13 <infinisil> only if intermediate derivation are produced
02:13:33 <infinisil> building a stack project doesn't have those, it's just one huge derivation
02:13:54 <vaibhavsagar> yes, but isn't that final derivation cached like any other?
02:14:16 <vaibhavsagar> Stack's Nix support has always seemed bolted on to me anyway
02:14:19 <infinisil> yeah that one is, but all the packages built througout it aren't
02:14:34 <vaibhavsagar> doesn't stack itself cache those?
02:15:18 <infinisil> yeah, but only to the local directory, which is the output directory of the derivation, which will be empty at the start always (to prevent impurities)
02:15:38 <vaibhavsagar> hmm, interesting
02:16:27 <infinisil> If you were to use the normal way to build a haskell project, each dependency would be a derivation and can therefore be cached
02:16:33 <vaibhavsagar> I would expect that you can avoid impurities by excluding the `.stack-work` directory
02:16:51 <Athas> I must admit Cabal seems to be improving.  'new-build' is what 'build' should have been all along, and the common sections added in Cabal 2.2 will remove my only reason for using hpack.
02:17:04 <mniip> 2.2 is a thing now?
02:17:08 <Athas> Not yet.
02:17:11 <Athas> But it will be!
02:17:21 <vaibhavsagar> does anyone know how to run a test-suite in parallel with Cabal?
02:17:29 <vaibhavsagar> that's my current hangup
02:17:37 <vaibhavsagar> and something stack seems to do without any issues
02:17:52 <infinisil> vaibhavsagar: stack build works with the local .stack-work directory, and is fast. nix-build is the problem
02:18:15 <mniip> ghc compilation almost started making sense
02:18:37 <vaibhavsagar> infinisil: IIUC, the problem is mixing stack build and nix-build?
02:18:42 <infinisil> Oh, new-build sounds sweet (http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/)
02:19:02 <infinisil> vaibhavsagar: hmm yeah, nix-build'ing a stack project does stack build
02:20:01 <Athas> Stack may still have the edge in 'it-just-works' though.  For example, 'stack build --profile' will always give me a profiled build, rebuilding whatever is necessary, while I have bad memories of cabal neglecting to recompile dependencies to add profiling or some such.
02:20:53 <mniip> whenever something 'just-works', it usually means that when it doesn't you're screwed
02:20:55 <ertes-w> infinisil: that's non-sense
02:21:02 <infinisil> I know nix well, and if new-build does something similar, it should work great to rebuild whatever is necessary
02:21:03 <mniip> with no reasonable way to inspect let alone repair
02:21:13 <infinisil> ertes-w: Huh?
02:21:19 <ertes-w> infinisil: nix will never rebuild anything it has already built, unless you run a GC
02:22:08 <infinisil> ertes-w: It caches the build once it succeeded yes, but not the intermediate products if it failed
02:22:26 <vaibhavsagar> ertes-w: `stack --nix build` doesn't put dependencies in the Nix store
02:22:31 <Athas> mniip: that was also my original worry, but it has not really happened yet.
02:22:36 <ertes-w> ah, it's a stack thing
02:22:48 <ertes-w> then i'm out =)
02:22:55 <infinisil> ertes-w: :)
02:23:06 <Athas> I think the nastiest issue I have faced was cache corruption due to an interrupted build.
02:27:19 <mniip> yay
02:27:23 <mniip> /bin/sh: line 1: 31565 Aborted                 (core dumped) "/usr/bin/ghc"  ...
02:27:50 <mniip> ghc: internal error: RELEASE_LOCK: I do not own this lock: rts/posix/itimer/Pthread.c 187 (GHC version 8.2.2 for x86_64_unknown_linux)   Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
02:29:51 <mniip> not reproducible...
02:59:50 <LiaoTao> mniip, Had any problems with 8.2.2?
03:00:04 <LiaoTao> Hmph
03:02:26 <M-x[m]> Um, so... I've installed stack, created an empty project and ran stack build - only to find several minutes later that it consumed all 3 gb of free space I had on my home and aborted.
03:03:41 <M-x[m]> Well, then I've tried to run just a cabal repl, but it's eaten all 2 gb of ram I had and crashed.
03:03:57 <M-x[m]> (Don't judge me, it's a laptop)
03:04:32 <tdammers> M-x[m]: 3 GB isn't a lot, is it possible by any chance that stack installed a GHC toolchain for you?
03:04:44 <M-x[m]> So, um... I guess this machine isn't exactly what I'd use as a dev box, but, eh... still, that's just not robust
03:04:57 <tdammers> also, what OS?
03:05:52 <M-x[m]> tdammers: yes, it did. I've tried to make it use the system ghc, but seems like stack ignores it because it's outdated. opensuse
03:06:41 <cocreature> Haskell development requires a fair amount of disk space and RAM
03:07:50 <tdammers> M-x[m]: it will only use the system GHC if its version matches the GHC version that the chosen resolver wants
03:08:26 <tdammers> M-x[m]: a full GHC toolchain as installed by stack will eat a substantial chunk of that disk space, so yes, this isn't unheard of.
03:09:36 <LiaoTao> Most of my root partition is filled by GHC and Haskell libraries :)
03:10:10 <tdammers> I threw an extra 750 GB HDD into my laptop because of this
03:10:35 <M-x[m]> cocreature: I understand that. It's just a bit ironic that I can run full clojure\clojurescript or scala dev environment with no problem on the same machine, but it's not enough for a simple hello-world in haskell. Talk about java memory usage, lol
03:10:56 <M-x[m]> tdammers: ok, I see.
03:12:44 <cocreature> M-x[m]: I’m not saying that it’s great that it’s that way. but there is not much you can do about it
03:15:04 <LiaoTao> Upgrading system GHC to 8.2.2
03:15:07 <LiaoTao> Anything going to explode?
03:15:34 <M-x[m]> cocreature: sure. That's ok, I was just checking it out of curiosity, so no big deal.
03:16:42 <tdammers> on the bright side, this is constant overhead; it doesn't grow proportionally with program size
03:33:15 <Athas> LiaoTao: I have noticed that compiling Happy-generated parsers can be much slower.
03:34:37 <LiaoTao> Athas, I see
03:35:04 <Athas> Specifically, I suspect type-checking is slower, but I don't know how to check.
03:35:23 <Athas> But that's why I'm still on 8.2.1.
03:40:54 <xertrov> Does anyone know if there's something like `Cofree` but structured as a DAG instead of a a list?
03:41:07 <xertrov> s/a a list/a list/
03:45:48 * hackage ip 1.1.1 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-1.1.1 (andrewthad)
03:51:08 <LiaoTao> Yay, catch 22
03:51:26 <LiaoTao> cabal rebuild needs process, process needs cabal rebuild
04:02:17 <ania123> I need following paper, does one has access: https://scholar.google.com/scholar?cluster=6985787674905254963&hl=en&as_sdt=0,5
04:03:57 <cocreature> ania123: I’m sure scihub has access :)
04:04:38 <Athas> ania123: http://sigkill.dk/junk/paper.pdf
04:04:51 <Athas> Sci-hub didn't, actually.
04:04:55 <Athas> Must be an obscure paper.
04:04:58 <cocreature> it did, I checked :)
04:05:15 <Athas> Oh, it didn't for me.
04:05:23 <ania123> Athas: thanks
04:05:42 <cocreature> Athas: did you search by url? I searched by doi
04:05:59 <Athas> cocreature: title.
04:06:04 <liste> it does if you search by http://onlinelibrary.wiley.com/doi/10.1002/malq.19900360311/full
04:07:33 <liste> hmm, it's an article written in Bulgaria, in English in 1990, when the Soviet Union was just collapsing
04:07:51 <liste> or does the 1990 mean something else
04:08:00 <ania123> right
04:08:02 <ania123> :)
04:08:08 <ania123> it is very old article
04:08:30 <TMA> math never gets old. it gets applied
04:08:40 <fakenullie> what I'm doing wrong here: http://lpaste.net/360925 bench says it takes 1.8 ns for unionMap
04:08:49 <liste> I'm just surprised it's in English, was the research in English even in Soviet times, or was the switch sudden?
04:09:29 <fakenullie> internationally published works should've been in english
04:09:46 <fakenullie> Bulgaria was also not soviet union
04:09:53 <liste> but it was in the eastern bloc
04:10:08 <fakenullie> they wouldn't write it in russian either
04:10:59 <fakenullie> well, could be in russian, if it was for soviet union collaboration
04:11:29 <TMA> having a publication in english/french/german/... improved the scientist's chance to go to some conference in the west, thereby an opportunity to emigrate
04:11:43 <user____> Hi everyone
04:11:47 <Athas> Hi.
04:14:30 <user____> I'm starting out. I'm trying to use the hoauth2 library (particularly Google's test exmple). Does anybody have any experience with it? I've got the example working, but I'm getting confused with Google's 'Sign in button' implementation, the two seem to have different flows
04:14:54 <user____> but I'm a newb at web too, so I don't have enough info to discern what's going on at either end
04:16:28 <user____> For clarification, I'm implementing the sign in button in js, and the code there is to send the idToken to the app server. This is slightly different to clicking the link given by the example. Does anybody have any knowledge of this?
04:45:40 <user____> okay, I believe I have found the issue - I was going down the route of implementing data-onsuccess="onSignIn" and post the id token, whereas what I actually needed to do was specify data-redirecturi="https://techstack.me/oauth2google.html" in my sign in button. problem solved
05:04:48 * hackage mmark 0.0.3.1 - Strict markdown processor for writers  https://hackage.haskell.org/package/mmark-0.0.3.1 (mrkkrp)
05:37:47 <f-a> I am building an executable with cabal new-build. My executable needs an .ini file to function, I would like to provide one when the project is built
05:38:31 <f-a> is there a way to specify this in my .cabal file? I thought it was data-dir/data-files, but apparently they do different things
05:48:40 <dminuoso> ertes-w: Ill delay the task further. There's just too many steps I'd like to avoid for now. :|
05:49:08 <dminuoso> Never worked with unboxed types before, I'd also have to figure out how to bring Criterion in the game, and then there's that missing Read instance I'd like to have too..
05:52:05 <lyxia> f-a: extra-source-files?
05:53:39 <f-a> lyxia: the manual states "A list of additional files to be included in source distributions", but I would like them to be bundled in the binary distribution
05:54:22 <lyxia> f-a: what's wrong with data-files?
05:55:20 <ertes-w> dminuoso: you gotta be kidding me…  i was so looking forward to this…  how can i go on living now?
05:55:29 <dminuoso> :)
05:55:35 <ertes-w> do i have 50 fields?  i do have 50 fields!
05:55:40 * supercynic powers up
05:57:20 <dminuoso> Ill keep this repo to make fun of myself in 10 years. :-P
05:57:59 <f-a> lyxia: my compiled files lies in this folder ~/somefolder/dist-newstyle/build/i3[...]/build/exec-name/, but there is no data folder
06:03:28 <lyxia> I don't know off-hand how the build system handles it but if you need to make files accessible at runtime, data-file is the way to do it.
06:04:54 <lyxia> Another alternative is to use the file-embed library or do some similar TH hackery to put the file inside the binary.
06:06:29 <f-a> lyxia: th won't cut it. this is an .ini file, it needs to be there 'overtly'
06:14:28 <marvin3> what pdf reading library is usually recommended? quite a few of them on hackage. I just need to extract plain text from pdf, then do the actual parsing with parsec
06:18:24 <f-a> lyxia: https://downloads.haskell.org/~ghc/7.0.2/docs/html/Cabal/authors.html#paths-module so I just misunderstood what data-files: does :P
06:38:47 <hexagoxel> f-a: as far as i know, --datadir does not work too well with new-build currently (essentially because there is no new-install yet)
06:39:14 <hexagoxel> (i don't use HEAD though, so perhaps things have improved there?)
06:53:41 <f-a> thanks hexagoxel
07:31:23 <kamyar> Hello guys
07:31:36 <kamyar> I just need to use DeriveGeneric for a parameterized type
07:33:06 <kamyar> please give me the paste url to put the code
07:33:20 <kamyar> found it thnx
07:33:40 <kamyar> http://lpaste.net/360927
07:35:04 <kamyar> I need DeriveGeneric for EPSG
07:38:59 <AWizzArd> This blog post develops a backtracking monad. Isn't the author basically developing the list monad again?  http://www.randomhacks.net.s3-website-us-east-1.amazonaws.com/2007/03/12/monads-in-15-minutes/
07:40:03 <Taneb> AWizzArd: the author writes "type Choice a = [a]" so, I guess, yes
07:40:23 <Taneb> AWizzArd: I think they're pointing out that [] can be used as a backtracking monad
07:41:53 <AWizzArd> Agreed, thx.
07:42:01 <kamyar> Please reply my question I am in a hurry
07:43:44 <waterdrop> I have a question about associativity of applying higher kinded types. It's always left associative, right? So (g a b c) in a type signature means (((g a) b) c), and so g must have type * -> * -> * -> *
07:44:06 <mnoonan> right
07:44:59 <Eduard_Munteanu> kamyar, ok, what doesn't work? Did you add "deriving Generic" to it?
07:45:34 <kamyar> @Eduard_Munteanu Yes! This * does not work. I need to say I need a parameterized FormJSON
07:45:35 <lambdabot> Unknown command, try @list
07:45:59 <Eduard_Munteanu> kamyar, oh, you probably want Generic1
07:46:31 <kamyar> @Eduard_Munteanu How?
07:46:31 <lambdabot> Unknown command, try @list
07:46:44 <Eduard_Munteanu> kamyar, deriving Generic1
07:47:16 <kamyar> just EPSG?
07:47:39 <kamyar> http://lpaste.net/360927
07:47:40 <Eduard_Munteanu> kamyar, just on EPSG
07:47:56 <kamyar> @Eduard_Munteanu See my code I tried but failed
07:47:56 <lambdabot> Unknown command, try @list
07:47:59 <waterdrop> mnoonan: great thanks
07:48:42 <Eduard_Munteanu> kamyar, what's the error?
07:49:04 <kamyar> @Eduard_Munteanu Illegal operator ‘*’ in type ‘FromJSON EPSG *’
07:49:04 <lambdabot> Unknown command, try @list
07:50:02 <Eduard_Munteanu> kamyar, well, that instance is wrong, you want   instance FromJSON a => FromJSON (EPSG a)   probably
07:51:00 <kamyar> @Eduard_Munteanu No luck!
07:51:00 <lambdabot> Unknown command, try @list
07:51:12 <Eduard_Munteanu> kamyar, well, what happened now?
07:51:30 <kamyar> @Eduard_Munteanu Could not deduce (Generic (EPSG a))
07:51:30 <lambdabot> Unknown command, try @list
07:52:51 <Hafydd> kamyar: would you stop starting your lines with @?!
07:52:58 <Hafydd> This isn't Twitter.
07:53:24 <Eduard_Munteanu> kamyar, add Generic to deriving for EPSG
07:53:27 <kamyar> I just want to inform my other part
07:53:39 <kamyar> ok I dont need @
07:53:55 <Eduard_Munteanu> Do it like we do.
07:54:12 <kamyar> Eduard_Munteanu: How? can u please fix my line?
07:54:37 <kamyar> Eduard_Munteanu: u mean I must derive both?
07:54:41 <Eduard_Munteanu> kamyar, data EPSG a ...... deriving Generic             should be enough
07:55:10 <Eduard_Munteanu> The original problem was with your instance, not Generic1.
07:55:24 <kamyar> Eduard_Munteanu: Wow! Fixed! Thanks really!
07:55:27 <Eduard_Munteanu> Resolution might also need deriving Generic.
07:56:30 <kamyar> Eduard_Munteanu: I did it!
07:56:37 <Eduard_Munteanu> Cool.
08:53:03 * hackage intero 0.1.24 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.24 (ChrisDone)
08:54:30 * hackage persistent 2.7.3 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.7.3 (MaxGabriel)
08:55:21 <plakband> When e.g. parsing xml files, `show` can give a string hundreds of lines long. Does anyone know of a package that will automatically format this kind of output?
08:56:12 <kamyar> Please help me with this code: http://lpaste.net/360927
08:56:15 <cocreature> plakband: there is pretty-show
08:56:36 <kamyar> function getResolution must get one of epsgXXXX types
08:56:38 <cocreature> plakband: although you are usually better off writing some custom pretty printing especially if your output is that large
08:56:54 <kamyar> How can I do it? using type constraints?
08:57:09 <kamyar> Parameter scale
08:58:10 <Ulrar> Looks like stack init X simple doesn't work today, something about Invalid flag name: \"bytestring--lt-0_10_4\""
08:58:14 <Ulrar> Any tips on that ?
08:58:15 <plakband> cocreature: I'll give that a shot, thanks
09:03:12 <kamyar_> Please help me
09:03:24 <kamyar_> Please help me with this code: http://lpaste.net/360927
09:03:33 <kamyar_> function getResolution must get one of epsgXXXX types
09:03:40 <kamyar_> How can I do it? using type constraints?
09:04:23 <kamyar_> Anyone can help me?
09:05:06 <aminb> kamyar_: I don't have a haskell env set up right now. Did you try asking over at #haskell-beginners? they're usually quite friendly and helpful too
09:05:21 <Ulrar> Looks like lts-9.18 works, the problem seems to be 10
09:05:54 * hackage haquil 0.1.7.5 - A Haskell implementation of the Quil instruction set for quantum computing.  https://hackage.haskell.org/package/haquil-0.1.7.5 (BrianBush)
09:05:55 <kamyar_> aminb: I guess this question is not so beginner!
09:06:42 <aminb> kamyar_: maybe so, but did you try? Did they reject it saying it's not a beginner question?
09:06:42 <marvin3> kamyar_ you did not paste errors
09:08:00 <kamyar_> marvin3: I added error
09:08:54 <marvin3> I don't know anything about the library you are using, but from the error it is obvious that EPSG is not a typeclass, and you are using it as one
09:09:37 <kamyar_> marvin3: No it is not. It is a parameterized type
09:10:15 <marvin3> then try   getResolution :: Config -> (EPSG scale) -> [Double] -> Double
09:10:28 <marvin3> removing type signature all together to see if ghc can infer it might also be worth a try
09:10:53 <jcb__> what's with the redundant dos in handler?
09:12:07 <marvin3> (parens around EPSG scale are not needed btw)
09:15:42 <kamyar_> marvin3: No Luck!
09:17:25 <jcb__> kamyar: also, why have EPSG as a datatype at all? I don't know what epsg3857 etc are, but if they're just Maybe, why not just have three newtypes?
09:18:46 <kamyar_> @jcb__ Since it may have one or several of those types
09:18:46 <lambdabot> Unknown command, try @list
09:18:59 <kamyar_> for example in yaml we may add many epsg configurations
09:19:48 <kamyar_> jcb__: How can I use newtype?
09:20:44 <jcb__> like, newtype EPSG3857 a = Maybe a
09:21:27 <kamyar_> jcb__: Does this work for YAML files with epsg3857 as a key?
09:22:27 <jcb__> I don't know what epsg3857 is, but I do think that for this snippet, you don't really need to be using records
09:22:48 <marvin3> kamyar_ scale in EPSG scale above should be some concrete type. you are also using epsg as a function: epsg $ tileWidth conf. not sure how you expected that to work
09:24:20 <kamyar_> marvin3: I do need the function but the function must be from those 3 types
09:24:40 <kamyar_> marvin3: epsg3857,...
09:25:35 <marvin3> so a in EPSG a is suppose to be a function? you are using using epsg as a function though, not one of its three members
09:26:23 <kamyar_> marvin3: No it is not but AFAIK epsg3857 ... are functions. Arent them?
09:26:57 <ReinH> jcb__: That newtype won't do what you think it does
09:26:58 <marvin3> they are Maybe a, and a can be anything
09:27:05 <ReinH> It defines a data constructor named 'Maybe'.
09:27:13 <ReinH> It does not reference the type constructor 'Maybe'.
09:27:34 <kamyar_> marvin3: Yes I know. But member names in records are functions in Haskell
09:27:41 <kamyar_> Prelude> :t epsg3857
09:27:41 <kamyar_> epsg3857 :: EPSG a -> a
09:27:53 <ReinH> perhaps you meant newtype EPSG3857 a = EPSG3857 (Maybe a)
09:28:23 <marvin3> kamyar_ uh huh, sorry I really shouldn't try be helping after not having slept for over a day. I'll let someone else take over
09:28:37 <jcb__> ReinH, yeah, sorry, confused type and newtype
09:30:19 <kamyar_> Anyone else doing me the favor?
09:33:49 <Psybur> What favor?
09:34:19 <jcb__> kamyar_: can you describe what EPSG is supposed to be?
09:34:23 <kamyar_> Help with the code
09:34:50 <kamyar_> jcb__: We have YAML files, which may contain multiple EPSG items
09:35:06 <jcb__> What's an EPSG item?
09:35:07 <kamyar_> for example: epsg3857: ...... epsg3587: ....
09:35:32 <kamyar_> jcb__: Some convention and rules gfor a GIS system
09:35:33 <Psybur> Your problem is with getResolution?
09:35:41 <kamyar_> Psybur: Yes
09:35:52 <kamyar_> All functions get the EPSG as input
09:36:04 <kamyar_> in each system things vary
09:36:11 <kamyar_> in each EPSG I mean
09:36:17 <Psybur> Whats wrong with the function?
09:36:27 <kamyar_> Psybur: GHC raises error
09:36:50 <jcb__> what do the conventions and rules consist of?
09:37:03 <Psybur> kamyar_, Why do you need to do EPSG scale => ?
09:37:24 <Psybur> Why cant you get rid of that typeclass and just use getResolution :: Config -> EPSG -> [Double] -> Double
09:37:38 <kamyar_> jcb__: Each convention consist of some data
09:37:46 <kamyar_> jcb__: Wanna see the yaml sample?
09:37:49 <jcb__> sure
09:38:32 <kamyar_> http://lpaste.net/360939
09:38:35 <kamyar_> here is the yaml
09:38:57 * hackage polyvariadic 0.3.0.3 - Creation and application of polyvariadic functions  https://hackage.haskell.org/package/polyvariadic-0.3.0.3 (fgaz)
09:39:56 <kamyar_> jcb__: Did u get the point?
09:41:02 <kamyar_> jcb__: I know I can reverse the order and put epsg first but I am currently converting a php code and can not change the things
09:42:05 <Psybur> kamyar_, are you trying to map the tilewidth from the conf to an epsg?
09:42:33 <Psybur> And that epsg is a double value?
09:42:53 <kamyar_> Psybur: No! epsg is somthing like epsg3587
09:43:30 <jcb__> okay so you have these three epsg objects
09:43:30 <kamyar_> Psybur: for example I must be able to call getResolution conf epsg3587 [1,2,3,4]
09:43:47 <jcb__> epsg3857, epsg3587 and epsg3785
09:43:52 <kamyar_> jcb__: Actually they are more than 3 but now I am starting with 3
09:43:59 <jcb__> oh boy
09:44:13 <kamyar_> jcb__: But they are finite
09:44:24 <Psybur> kamyar_, Im just wondering what this part of the code does: (epsg $ tileWidth conf)
09:44:26 <kamyar_> jcb__: Maybe 10 or more
09:44:31 <Psybur> Is that valid haskell?
09:44:40 <jcb__> does each epsg object have properties like minX, minY and so on?
09:44:58 <kamyar_> jcb__: Exactly
09:45:07 <jcb__> okay, I see one issue
09:45:12 <Psybur> Hmm is that what deriving Generic does
09:45:15 <kamyar_> Psybur: It is like the last line: epsg3857 $ scaleNames conf
09:45:36 <jcb__> you're creating your top level EPSG type as a function from each object
09:45:44 <Eduard_Munteanu> kamyar_, maybe you want something like    class HasResolution a where getResolution :: a -> ...    ?
09:45:55 <jcb__> when what I think you actually want is a product type
09:46:38 <jcb__> because it seems like you have a yaml file, that may or may not have several epsg objects in it
09:46:50 <kamyar_> jcb__: Exactly!
09:46:52 <jcb__> each epsg object having some properties
09:46:55 <kamyar_> jcb__: What should I do now?
09:47:03 * hackage patat 0.6.0.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.6.0.0 (JasperVanDerJeugt)
09:47:03 <jcb__> rework your types
09:47:31 <kamyar_> jcb__: How exactly?
09:47:52 <dsal> Is there a good reason -Wall isn't on by default in new stack projects?
09:48:12 <kamyar_> jcb__: AFAIK product types can contain just one of the items
09:48:30 <kamyar_> jcb__: Either = Left | Right
09:48:41 <jcb__> that's a sum type
09:49:23 <jcb__> product type is like data Product a b = Product a b
09:49:28 <dminuoso> Or also called coproduct =)
09:49:51 <jcb__> category theory!
09:50:08 <Eduard_Munteanu> Or sewage theory, copro-duct.
09:50:14 <Psybur> kamyar_, I dont think epsg $ tileWidth conf is what you want. epsg is a record that has the fields epsg3857 etc
09:50:46 <kamyar_> jcb__: Actually they are parametrized types with multiple parameter
09:50:50 <dminuoso> kamyar_: It's very easy to remember what a product type is. Think of a type as just a set of possible values. What happens if you "multiply two sets" ?
09:51:01 <Psybur> Unless Im understanding deriving generic wrong
09:51:09 <EvanR> otoh its hard to tell what people mean by dependent product
09:51:19 <dminuoso> kamyar_: And that is a product type.
09:51:21 <EvanR> pi type or dependent pair
09:51:29 <fakenullie> is Product a b = ProductA a | ProductB b product
09:51:35 <kamyar_> Sorry I have to go
09:51:40 <kamyar_> \will return in moniyes
09:51:40 <dminuoso> kamyar_: Think of a product as a product in the set theory sense. It's a cartesian product,
09:51:44 <kamyar_> Thanks everyone
09:51:46 <jcb__> kamyar, what I would do is make some top level type like data File = File [EPSG], then define what you want an EPSG to be
09:51:52 <EvanR> fakenullie: noooooo
09:51:55 <jcb__> hahahhahaha
09:52:01 <jcb__> oh well
09:52:03 <Eduard_Munteanu> EvanR, pi type makes more sense, dependent pair is actually a dependent sum
09:52:13 <fakenullie> so product must have both types in data constructor
09:52:22 <EvanR> you will see "dependent product" for both nonetheless :(
09:52:42 <Eduard_Munteanu> I guess it depends. ;)
09:52:52 <Psybur> So kamyar_'s problem would be solved by replacing epsg with a function that takes an ESPG Double and returns a Double? D:
09:53:05 <EvanR> poor justification: since Either a b is really (tag : Bool, if tag then a else b)
09:53:10 <dminuoso> fakenullie: I like to think of it as "a cartesian product" can be seen as [(a,b), a∈A and b∈B]
09:53:29 <EvanR> wait that doesnt justify anything
09:53:38 <EvanR> but it is one such justification i read
09:54:10 <EvanR> ah, because "pair" is a product type
09:54:51 <Eduard_Munteanu> Either A B ~ Sum Bool (\tag -> if tag then B else A)
09:54:53 <ReinH> To make it more confusing, a dependent product, Pi(x:A) B(x) for constant B is a function A -> B
09:54:57 <fakenullie> @hoogle m a -> a
09:54:58 <lambdabot> Control.Exception.Lifted evaluate :: MonadBase IO m => a -> m a
09:54:58 <lambdabot> Happstack.Server.Response ok :: (FilterMonad Response m) => a -> m a
09:54:58 <lambdabot> Happstack.Server.Response noContent :: (FilterMonad Response m) => a -> m a
09:55:04 <EvanR> and "functions as set of tuples" makes it even worse!
09:55:41 <EvanR> i blame set theory
09:56:31 <ReinH> A dependent sum, Sig(x:A) B(x) is a pair (a,b) for a in A and b in B(a). If B(x) is constant, it will be (A,B), a product.
09:56:36 <Psybur> :t (<-)
09:56:38 <lambdabot> error:
09:56:38 <lambdabot>     parse error on input ‘<-’
09:56:38 <lambdabot>     Perhaps this statement should be within a 'do' block?
09:56:51 <ReinH> love too dependent types
10:00:37 <jcb__> Psybur, (<-) is just sugar for bind
10:00:40 <ReinH> What's more, Either can be canonically represented as a sigma type.
10:00:54 <Psybur> :t bind
10:00:55 <lambdabot> error:
10:00:55 <lambdabot>     • Variable not in scope: bind
10:00:55 <lambdabot>     • Perhaps you meant one of these:
10:01:06 <jcb__> :t (>>=)
10:01:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:01:32 <Franciman> Hi
10:01:32 <Psybur> oh right
10:01:56 <jcb__> (>>=) is pronounced "bind", like <$> is pronounced "map" or "fmap"
10:02:06 <Franciman> Is there a mechanical way to derive Monad instances for Monad Transfomers?
10:02:24 <jcb__> Franciman, what do you mean?
10:02:59 <Franciman> I mean. I'm trying to write an instance for Reader r (IO (Either String a))
10:03:03 <Franciman> for Monad
10:03:06 <Franciman> with r fixed
10:03:09 <Franciman> and it seems quite ad hoc
10:03:16 <tabemann> apply them to the Identity monad, and then rename them to something more palatable?
10:03:27 <EvanR> no the instance youre talking about already exists
10:03:27 <Franciman> instead the Functor and Applicative were quite general
10:03:38 <Franciman> I know. It's just an exercise
10:03:51 <EvanR> oh wait, no theres no "IOT" transformer
10:04:14 <glguy> How will we manage the Internet of Things then?
10:04:20 <Franciman> :D
10:04:23 <tabemann> lol
10:06:39 <tabemann> I should program my client so that if someone joins and parts over a certain number of times in a given time frame, it puts them on /ignore for a certain amount of time
10:07:05 <Franciman> here's my code:
10:07:06 <Franciman> http://lpaste.net/360943
10:07:26 <Franciman> as you can see, the first two instances only leverage the components' applicative instances
10:07:30 <fakenullie> just disable join/part display
10:07:44 <Franciman> or functors'
10:07:46 <tabemann> fakenullie: my client has the ability to ignore just those
10:07:53 <geekosaur> glguy: about the same way we do now: badly
10:08:34 <cocreature> Franciman: the composition of two applicative functors is always an applicative functor. the compose newtype gives you the appropriate instance. however, for monads that does not hold in general which is why you actually need to do something there
10:08:55 <Franciman> ahhh
10:09:04 <tabemann> anyways, back to work
10:09:06 * Franciman thought he were super stupid
10:09:33 <Franciman> cocreature, and do you know any example of monads not composing?
10:09:52 <mniip> Compose [] [] iirc
10:10:22 <Franciman> well. Thank you very much
10:10:49 <cocreature> you can get a Monad instance for the composition using a Traversable instance on the inner functor iirc
10:10:56 <cocreature> which allows you to “swap the layers”
10:11:00 <Franciman> yeah!
10:11:10 <mniip> or Distributive on the outer layer
10:11:34 <mniip> 1513706599 [21:03:19] <EvanR> oh wait, no theres no "IOT" transformer
10:11:36 <mniip> excuse me
10:11:51 <Franciman> thank you, again
10:12:21 <EvanR> excuse you
10:13:15 <Franciman> https://hackage.haskell.org/package/MonadCompose-0.8.4.2/docs/Control-Monad-IOT.html
10:13:17 <Franciman> how about this? :P
10:14:19 <EvanR> what in the
10:15:13 <EvanR> i am not sure how this helps
10:16:13 <int-e> Franciman: scary
10:16:50 <mniip> http://hackage.haskell.org/package/acme-iot
10:20:10 <kakashiAL> re
10:20:23 <kakashiAL> I have two questions about listings
10:21:05 <kakashiAL> 1. can I tell it somehow:   "everything on the left of :: make it red and everything on the right make it green"
10:21:45 <kakashiAL> 2. is there a way to tell lisings "make - green but make -- red"
10:21:53 <kakashiAL> sorry
10:21:57 <kakashiAL> wrong channel
10:22:03 <dsal> With the trick with attoparsec to parse multiple things?    i.e., I've got  A.Parser T and I want a [T]
10:22:51 <dsal> "feed" kind of seems right, but it seems to want my T to be monoidal.  I think I'm failing to understand something fundamental.  :)
10:24:31 <barrucadu> kakashiAL: I've had much better luck with minted than listings for highlighting Haskell.
10:24:37 * hackage llvm-hs 5.1.2 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-hs-5.1.2 (cocreature)
10:24:40 <dsal> On a related note:  I'm trying to parse my Kindle clippings.   I'll probably switch to megaparsec soon, but in the meantime, I'm not entirely sure how to handle the first line.   It's in the form of       Book Title (Author)\r\n    where Book Title sometimes also contains parens.  Is there magic for that sort of thing?
10:25:15 <kakashiAL> barrucadu: I never worked with minted, but it uses python :(
10:25:54 <dsal> And, I've reached the part of the story where I found someone else had already written this package I started last night.
10:25:58 <cocreature> dsal: "many"?
10:26:05 <dsal> oh.  ha
10:26:09 <dsal> Thanks.
10:26:19 <kamyar> I am back
10:34:21 <yohotchoc> Hey folks, wondering what the exact reason is for there not to be an IO monad transformer (for an exam question)? I've tried digging about it in a few places, but most of the answers seem to come down to "IO is always the base because it is".
10:36:41 <koala_man> yohotchoc: try writing one
10:37:15 <yohotchoc> I suppose that's the obvious way to find out 'T_T
10:37:19 <yohotchoc> I'll try that, thanks
10:38:05 <ixxie> hello #haskell
10:38:36 <Eduard_Munteanu> yohotchoc, it breaks referential transparency when you transform monads like the list monad with IOT.
10:39:01 <cocreature> hey ixxie :)
10:39:39 <Eduard_Munteanu> yohotchoc, effects may be ran multiple times when the base monad "contains multiple values".
10:40:30 <ixxie> so I am currently working as an analyst writing ML code in Python, and yearning for something better; I am very interested in trying out Haskell for this stuff, and so I am looking for arguments for / against doing so
10:40:33 <yohotchoc> Oh, I see how that'd work out, right.
10:40:36 <yohotchoc> Thanks Eduard_Munteanu
10:41:06 <ixxie> I discovered datahaskell.org which is helpful, but I was hoping to chat with people with actual experience with using Haskell for analytics / big data / ML etc.
10:41:18 <jle`> how can i get ghc to see the llvm-3.9 that i just installed?
10:41:41 <cocreature> jle`: I think it just looks in PATH?
10:42:11 <kamyar> Please help me fix this code: http://lpaste.net/360944
10:42:26 <EvanR> yohotchoc: as a deeper answer... i would look for what the criteria are for something to be a valid monad transformer, beyond having the right kind
10:42:33 <kamyar> jcb__: Are u still there?
10:42:45 <cocreature> kamyar: you’ll have to tell us what the problem is before we can help you fix it
10:42:52 <EvanR> then give one counter example for where an IOT would violate the criteria
10:43:14 <jle`> cocreature: what should i make sure to include in the path?
10:43:50 <cocreature> jle`: I would just put the whole bin directory from wherever you installed LLVM to in PATH but llc might be enough
10:44:00 <kamyar> cocreature: I need the function getResolution to be called as like getResolution epsg3857 config [1.0,2.0,3.0,4.0]
10:44:01 <jle`> hm okay. i just did it through aptitude
10:44:13 <kamyar> cocreature: But currently I get error
10:44:47 <cocreature> kamyar: your type signature says that the first argument should be the config so you’re going to need to swap the first two arguments
10:45:10 <kamyar> cocreature: Yes I mistyed here
10:45:13 <cocreature> kamyar: also your type signature expects a function "EPSG a -> a" but espg3857 has type "ESPG a -> Maybe a"
10:45:17 <cocreature> so this is not going to work
10:45:24 <kamyar> cocreature: Suppose getResolution config epsg3857 [1,2,3,4[
10:45:39 <cocreature> and you are trying to divide by epsg which is a function afaict so that doesn’t make much sense either
10:45:43 <kamyar> cocreature: Oh ok let me fix it and try
10:45:56 <jle`> cocreature: ah i see, thanks!
10:45:57 <cocreature> I think it might be helpful if you step back and explain what you are actually trying to do
10:46:15 <cocreature> jle`: adding it to PATH worked?
10:47:35 <jle`> hm actually it did not work
10:47:46 <cocreature> :(
10:48:00 <jle`> i wonder if i can ask ghc what version of llvm it thinks it is using
10:48:19 <cocreature> there is some flag to pass the path to llc explicitely iirc
10:49:17 <glguy> edit $prefix/lib/ghc-8.2.2/settings
10:50:48 <notGoodAtHaskal> so um i just started wktn
10:50:51 <notGoodAtHaskal> fuck
10:51:55 <notGoodAtHaskal> i just started with haskell, and apparently you can specify a step for a list. say a list for numbers from 1 to 20 is [1..20]. a list for numbers from 1 to 20 with step 2 is [2, 1..20]. a step size of 0 produces infinite zeroes, which is fun
10:52:51 <cocreature> ixxie: I don’t do data analytics or ML so I’m afraid I can’t be of much help but there is a datahaskell gitter channel linked on their webpage which might produce better answers
10:53:05 <jle`> glguy: huh i guess it works if i use llc-3.9 instaed of just llc, even though the llc in my path is 3.9
10:53:09 <jle`> thanks
10:53:57 <ixxie> cocreature: thanks
10:54:46 <jle`> speedups are pretty drastic, i should have done this before :)
10:54:51 <mud> notGoodAtHaskal: The details of that don't sound right
10:54:57 <mud> > [2, 1 .. 20]
10:54:59 <lambdabot>  []
10:55:01 <mud> > [1, 3 .. 20]
10:55:04 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
10:55:11 <ixxie> is it a myth that it is hard difficult to develop large scale projects in Haskell? Is architecture and recruitment of team members more challenging than with other languages?
10:55:27 <notGoodAtHaskal> [0, 1 .. 20]
10:55:32 <notGoodAtHaskal> huh.
10:55:34 <cocreature> jle`: depends on the kind of code, LLVM is great for tight loops that do some kind of number crunching. for other code it often doesn’t really make a difference
10:55:35 <Athas> ixxie: it is definitely more difficult to recruit, yes.
10:55:45 <Athas> *However*, I think there are still more Haskell programmers than Haskell jobs.
10:55:49 <mud> You have to put a > first on the line for lambdabot to process it
10:55:56 <mud> > [0 .. 20]
10:55:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
10:56:11 <Athas> As a language, I don't think Haskell is hard/difficult to use for large projects, although the tooling is clearly not as mature as for more popular languages.
10:56:27 <Athas> But it's hard to say.  There is little public knowledge about truly large Haskell programs.
10:56:32 <notGoodAtHaskal> > [0, 0 .. 20]
10:56:35 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:56:36 <jle`> actually yeah hm it does seem to depend, after trying other things
10:56:38 <notGoodAtHaskal> yep
10:56:42 <notGoodAtHaskal> there he goes
10:56:43 <notGoodAtHaskal> my hero
10:57:06 <ixxie> thanks Athas
10:57:07 <mud> notGoodAtHaskal: Ya, that's cool. I didn't actually know that one worked like that.
10:57:19 <jle`> ixxie: i'm not sure where you're hearing that myth, but if you consider just the language i think haskell is one of the best choices for large scale projets
10:57:28 <jle`> ixxie: mostly for its maintainability, safety, refactorability
10:57:54 <jle`> when you consider the ecosystem and potential recruitnment issues then you have some contest
10:58:29 <ixxie> jle`: yeah that is what I figured
10:59:05 <fresheyeball> hey folks
10:59:12 <fresheyeball> happy holidays!
10:59:15 <Athas> jle`: is much known about how maintainable Haskell is in the large?
10:59:19 <ixxie> jle`: the alternatives on the table would be Scala, F# (which I think wouldn't have a much better ecosystem) or (yuk) Java
10:59:42 <fresheyeball> I would like some advice
11:00:02 <Athas> ixxie: those are much "safer" choices than Haskell, because they piggyback on large platforms.  F# is pretty good, too.
11:00:05 <fresheyeball> I am building a system that looks something like this
11:00:21 <fresheyeball> it's a predicate system, that needs to evaluate against a data structure
11:00:25 <mud> Athas: All I know is that haskell is the only language I've ever *enjoyed* refactoring things and doing maintenance in. I've even done some work on a large project without it being painful.
11:00:27 <ixxie> Athas: yeah it looked much nicer than most options
11:00:51 <fresheyeball> I am using data families to model the predicates because different types allow for different evaluations
11:01:02 <ixxie> Athas: I found this cool article last week, which - despite knowing almost nothing about Haskell - seemed interesting: https://tech-blog.capital-match.com/posts/3-anatomy-of-haskell-web-app.html
11:01:07 <fresheyeball> data DCFieldTypes = DCInt | DCText
11:01:11 <Athas> mud: sure, I enjoy it too.  But I don't know whether my experiences would extrapolate to large systems (which I would consider at least 500k SLOC).
11:03:07 <Athas> While 500k is an arbitrary cutoff point, I think projects below that size are similarly easy to maintain in any "sane" language (useful static types, memory safety, modules, control of side effects, etc).
11:03:39 <ixxie> Athas: how is memory safety in Haskell?
11:03:54 <Athas> ixxie: Haskell is memory safe unless you start using unsafe operations.
11:04:01 <mnoonan> Athas: ..what languages are sane under that definition?
11:04:29 <ixxie> Athas: is it easy to accidently do that?
11:04:33 <Athas> mnoonan: Java, C#, Haskell, F#, ...?  They are not fuzzy requirements.  E.g, the "control of side effects" can be done by encapsulation into classes, that's fine.
11:04:35 <Athas> ixxie: no, not at all.
11:04:48 <Athas> Er, they *are* fuzzy requirements.
11:05:15 * cocreature starts running a fuzzer on Athas
11:06:08 <Athas> I got a bit tracked off my original point, though, which is that I don't think I have seen anyone talk about how Haskell scales to truly large systems.
11:06:26 <Athas> Standard Chartered has one, but they don't talk!
11:06:51 <cocreature> Athas: don has given a talk at last year’s haskell xchange iirc
11:07:00 <Athas> Oh, I must track that down.
11:08:51 <cocreature> Athas: https://skillsmatter.com/skillscasts/9098-haskell-in-the-large-the-day-to-day-practice-of-using-haskell-to-write-large-systems you’ll need to make an account but it’s free
11:10:30 <Athas> Thanks.
11:10:50 <ranberry> Does anyone have any good reading material for understanding the return function a bit better? I understand that its just a regular ol' function within the monad type class for returning a value in its default context, but I'm having some trouble seeing how bits of code know which monad's implementation of return to use
11:11:05 <dminuoso> > foldl (.) id [(.), (.)]
11:11:08 <lambdabot>  error:
11:11:08 <lambdabot>      • Occurs check: cannot construct the infinite type: b ~ a0 -> b
11:11:08 <lambdabot>        Expected type: (b -> c) -> b -> c
11:11:26 <dminuoso> If I wanted this to typecheck. Can I tell haskell "trust me, I want this!"
11:12:19 <hololeap> ranberry: return is a function that is implemented for each instance of Monad, just like prev and succ are defined for each instance of Enum
11:12:23 <mnoonan> dminuoso: -fdefer-type-errors
11:12:35 <cocreature> dminuoso: you should rather trust ghc: you don’t want this :)
11:12:51 <int-e> dminuoso: the "trust me, I may know what I'm doing with these types" functionality is `unsafeCoerce`.
11:13:06 <EvanR> infinite types are the future imo
11:13:18 <EvanR> along with infinite proofs
11:13:43 <dminuoso> [1]    68502 bus error  stack ghci
11:13:46 <dminuoso> k. that went fast.
11:14:13 <dminuoso> int-e: I guess I dont know what Im doing. The "Unsafe" warning was there. :o(
11:14:25 <EvanR> bus error, that was close
11:14:44 <dminuoso> EvanR: The first time Ive ever seen that outside my own kernel.
11:14:47 <hololeap> ranberry: in other words, return acts differently depending on which instance of Monad is being used, and the compiler can (usually) figure out which one by context
11:15:05 <ranberry> hololeap :  I totally get that return is part of the typeclass and implemented for each monad, but I'm not sure what kind of context the compiler is using to choose which implementation to use. For example:  do next <- msum . map return $ successors n b s
11:15:15 <fresheyeball> ok shit
11:15:21 <dminuoso> ranberry: The best way to understand what return does, is to understand from the perspective that it builds a) a monad, and b) what laws it follows.
11:15:24 <fresheyeball> I think I can word my question now
11:15:30 <fresheyeball> forgive me if I still butcher it
11:15:39 <fresheyeball> I need something like Map
11:15:40 <dminuoso> ranberry: the laws give you all the intuition you need.
11:15:55 <fresheyeball> but where the keys constructor can determine what values are allowed
11:15:58 <artagnon> I keep getting “Data.Binary.Get.runGet at position 0: not enough bytes”, because I’m encoding/decoding all over the place. Is there a way to get a proper stack trace?
11:16:18 <fresheyeball> data DKey = DKeyS String | DKeyInt String
11:16:19 <cocreature> artagnon: build with profiling and run with "+RTS -xc"
11:16:34 <hololeap> ranberry: the Monad it is returning has to be defined *somewhere* or it won't compile... i don't know what the type signature of successors is, but is it specific to a monad?
11:16:36 <EvanR> ranberry: you can tell by doing :t on your code
11:16:39 <fresheyeball> so that (singleton (DKeyInt "foo") 3) is ok
11:16:39 <artagnon> cocreature: The Stack equivalent?
11:16:46 <cocreature> artagnon: stack build --profile
11:16:53 <fresheyeball> but (singleton (DKeyInt "foo) "bar") is a type error
11:17:06 * artagnon tries it out
11:17:07 <fresheyeball> possible? is that out there?
11:17:08 <dminuoso> ranberry: and the relevant laws are `return a >>= m ≡ m a` and `m >>= return ≡ m`, which should show how whatever "return does", it must be the one thing that acts as a noop but just produces a result.
11:17:21 <hololeap> ranberry: for instance, if anything is ultimately being run by the main function, then the compiler knows the monad in question is IO
11:17:41 <ranberry> https://www.irccloud.com/pastebin/gaCvD036/
11:19:31 <dminuoso> ranberry: Oh I misunderstood your question. The choice is resolved when the type system determines the type. Until then it's polymorphic. Just `mempty` is not actually resolved until it has to do type unification.
11:19:44 <dminuoso> :t 5
11:19:47 <lambdabot> Num p => p
11:19:59 <dminuoso> Or this. It doesnt know what the type of 5 is until its forced to pick one.
11:20:19 <ranberry> So I guess in this case since the return type is [a] then I can assume that return will use the List Monad's implementation in this function?
11:20:25 <artagnon> There's some hearsay about space leaks in Haskell being very difficult to debug. Is this something I've got to watch out for?
11:20:45 <dminuoso> ranberry: can you show the actual code
11:21:11 <hololeap> ranberry: yeah, that
11:21:30 <hololeap> ranberry: it's using the list monad in that case
11:21:39 <cocreature> artagnon: somewhat. ime once you have a grasp on how laziness actually works, they arise very rarely in your own code. neil mitchell also has a series of blogposts on how to find them by reducing the stack size
11:21:43 <Tuplanolla> I'd say that they're very difficult to predict, but not too difficult to fix once found, artagnon.
11:22:10 * artagnon nods
11:22:46 <artagnon> Is laziness-by-default a historical mistake? It seems to be a very popular opinion.
11:23:02 <Tuplanolla> Sometimes.
11:23:21 <ranberry> hololeap: awesome, thanks! Just making sure I understood how the compiler was making the decision.
11:24:05 <geekosaur> Hard for me to call it a mistake given that Haskell was originally devised as a playpen for lazy by default
11:24:32 <hololeap> ranberry: i guess the other clue was that you were using map, which is just fmap but specific for the list monad
11:24:52 <geekosaur> it may be a mistake to use lazy-by-defualt in some contexts, but that's not news; there's always pathological cases for various programming approaches
11:25:10 * artagnon nods
11:25:47 <hololeap> actually, looking at your code snippet again, it's inferring it from the fact that you used map... if you used fmap it wouldn't know which monad to use... you should post your actual code ;)
11:28:36 <jle`> artagnon: laziness by default helps in a lot of situations and makes a lot of abstractions and compositions possible.  strictness by default helps in a lot of its own situations as well
11:29:04 <artagnon> jle`: Would you happen to have some examples handy?
11:29:12 <jle`> artagnon: laziness by default won't stop space leaks
11:29:21 <jle`> *strictness by default won't stop space leaks from laziness
11:29:32 <jle`> you just have to be aware of what is lazy and what is strict
11:29:35 <artagnon> Oh.
11:29:40 <jle`> in a strict language you'll run into performance problems from strictness
11:29:48 <hololeap> ranberry: i might have been wrong about where it is inferring the Monad instance from. you would need to post your actual code for me to say for sure
11:29:58 <jle`> i've had many many more performance and space problems from strictness than i have from laziness
11:30:16 <jle`> strict vs lazy is always a choice, and both can give perf/space issues depending on how they are used
11:31:30 <EvanR> people are born knowing how to handle the performance problems from strictness though
11:31:32 <jle`> the entire lazy.js library in javascript is actually all about using laziness to improve space and time usage
11:31:41 <jle`> http://danieltao.com/lazy.js/
11:31:54 <EvanR> using funky accumulating parameters and trampolines
11:32:51 <jle`> i think if strictness were the default, accidental strictness could cause trouble for time/space usage.  and if laziness were deafult, accidental laziness could cause trouble in other situations as well
11:32:52 <artagnon> Nice!
11:33:44 <jason85> can anyone explain what parser combinators are?
11:34:25 <jle`> jason85: parsers are first-class values, and you can build complicated ones by manipulating and putting together simpler ones
11:34:31 <jle`> using normal functions
11:34:50 <artagnon> jason85: They compose to form Parser monads.
11:35:07 <jle`> artagnon: lazy.js has a couple of examples where laziness shines
11:35:34 <artagnon> jle`: Thanks, I'll have a look.
11:36:15 <artagnon> jason85: You first build up your entire Parser, and then parse the given program (json or whatever else) in one go.
11:36:26 <artagnon> cocreature: The --profile works. Thanks much :)
11:36:32 <jle`> jason85: for example, let's say you had a parser that parses a number, 'pN' and a parser that parses a letter, 'pL'.  you can create a parser that parses a number *or* a letter using 'pN <|> pL', or a number *then* a letter using pN *> pL, etc.
11:36:48 <jle`> jason85: the difference between parser combinators and parser generators is that parser combinators work within your language
11:36:57 <jle`> and are normal values you can manipulate like numbers, bools, etc.
11:37:32 <Tuplanolla> When performance really matters, "does not allocate" is a much more useful property than "is not lazy", so I don't really find the differences between lazy and strict Haskell too meaningful, artagnon.
11:37:53 <cocreature> is there some way to simultaneously derive the Lift instance of two mutually recursive types?
11:37:58 * artagnon nods
11:38:01 * frerich wishes he could remember the fixities of <$>, <*>, *> and <*. I never get applicative parsers right on the first try!
11:38:24 <jle`> Tuplanolla: that's a nice insight, since both lazy and strict programming have to wrestle with that problem
11:39:20 <jle`> jason85: the difference between parser combinators and manual parsing of values is that manual parsing requires you to write all your parser logic interleaved and all within the same function, whereas parser combinators allow you to build complicated parsers by simply composing/manipulating/combining simpler ones you write
11:40:26 <jason85> jle`: Okay that seems clear so far, when I'm asked to implement a certain grammar in haskell using parser combinators, what steps would I take?
11:40:48 <jle`> jason85: do you have access to that grammar in BNF?
11:40:53 <jason85> jle`: yes
11:40:59 <jle`> if so, it's usually actually a straightforward translation
11:41:43 <jle`> try looking at a parser combinator tutorial...most would leave you in good shape to translate bnf to parser combinators
11:41:59 <jle`> but really, things like foo := bar | baz
11:42:05 <jle`> in haskell would just be foo = bar <|> baz
11:42:11 <jle`> for something similar
11:42:28 <cocreature> you usually want to left-factor your grammar if you want to get somewhat decent performance out of your parser
11:48:23 <ranberry> hololeap: https://wiki.haskell.org/The_Knights_Tour#LogicT_monad is the code I was looking through. I'm trying to figure out what monad is being mapped onto each tuple in the line "| otherwise = do next <- msum . map return $ successors n b s"
11:52:03 <dminuoso> Can you think of a simple container type that is not a functor?
11:53:07 <mud> dminuoso: A Data.Set
11:53:27 <eschnett> dminuoso: i container that re-orders elements as they are accessed would not be a functor
11:53:50 <dminuoso> Ah right, thanks. :)
11:54:14 <mud> Like a splay tree or something? It could be a functor though, except for that pesky constraint thing too.
11:55:11 <eschnett> if the re-ordering can be observed, then it’s not a functor. the functor law “fmap id cont == cont” would not hold.
11:57:27 <codeshot> eschnett, (==) isn't required is it?
11:58:20 <dminuoso> mud: Does it actually matter if you can observe the reordering? I mean its extensionally equivalent as far as the set is concerned, no?
11:59:14 <fakenullie> ordered set?
11:59:39 <mud> dminuoso: With Data.Set the problem isn't the ordering, it's that it would need constraints on the type of `fmap` that don't exist, and it's not allowed to add them.
11:59:46 <mud> It needs to know at a minimum that b is an instance of Ord
12:02:05 <codeshot> Something I don't get about the functor law is how you aren't allowed to count the number of fmaps. I don't understand why its important to preclude that
12:03:41 <dminuoso> mud: Oh because it has to know whether to remove duplicated objects after fmap has done its job?
12:06:18 <frerich> jason85: There's currently a series of programming puzzles called 'Advent of Code' going on; yesterday's puzzle involved interpreting a simple imperative (assembler-style) language. I decide to see whether I could use parser combinators to parse the program, you can see the result at https://github.com/frerich/aoc2017/blob/master/18.hs#L36
12:06:31 <frerich> jason85: IMHO it almost looks like a grammar in BNF!
12:07:19 <frerich> jason85: ...and I'm by no means experienced when it comes to the 'parsec' package which provides these combinators, I'm sure someone who's more experienced could make it a lot nicer.
12:17:13 <mud> dminuoso: Right, it wouldn't even be able to start its job really. It would have no idea how to even go about recreating the binary search tree (or whatever it actually uses internally)
12:18:11 <jle`> codeshot: it's so that you can do things like 'fmap f . fmap g = fmap (f . g)' as a refactoring
12:18:25 <jle`> which is something i do pretty often
12:18:41 <jle`> if you can count fmaps then that isn't a valid refactoring
12:18:45 <jle`> and it would break code
12:18:58 <jle`> also being able to eliminate 'fmap id' is nice
12:20:04 <Tuplanolla> "The functor law exists for our convenience."
12:27:27 * hackage ws 0.0.2 - A simple CLI utility for interacting with a websocket  https://hackage.haskell.org/package/ws-0.0.2 (athanclark)
12:30:29 <dminuoso> jle`: I just realized, that exact law is the basis of loop fusion, right?
12:30:35 <codeshot> jle`, makes sense
12:30:40 <codeshot> thanks
12:32:51 <codeshot> when we write = in a class law, do we always mean head normal forms are identical, weak head normal forms are identical, or just that all functions applied to it have the same value?
12:33:30 <codeshot> functions that return IO have different values because there can be more or fewer reduction steps
12:33:55 <codeshot> so the meaning of this equality is quite opaque to me
12:34:16 <Tuplanolla> It's a metatheoretical equality not expressible in code.
12:34:19 <[exa]> I always thought it's the magical mathematical = that ignores decidability
12:34:32 <codeshot> Yeah, I didn't expect it to be expressible in code
12:34:46 <codeshot> none of the three things I thought of are expressible in code
12:36:36 <mud> codeshot: I think it's the 3rd one, at least that's what I've always assumed it is.
12:36:37 <EvanR> magic = sucks, but you could say = is propositional equality
12:36:48 <EvanR> which doesnt ignore provability
12:38:27 <codeshot> for example "print $ (Identity id) <$> (Identity 1)" does more computation than "print $ Identity (id $ 1)" so the value of the two are different
12:38:52 <dminuoso> codeshot: what do you mean by value? observable time?
12:38:57 <codeshot> or rather does more state reduction
12:39:08 <codeshot> dminuoso, yeah, cpu instruction counters, etc
12:39:54 <dminuoso> codeshot: so I guess when you talk about "extensional equivalence" it really depends on what you consider "internal" and "external"
12:40:16 <dminuoso> If the instruction counter is part of your external properties, then yeah
12:40:17 <codeshot> Imagine a function optimise :: (IO a -> (forall b. Code b -> Code b) -> IO a)
12:40:33 <codeshot> This is something that can be very useful in real life
12:41:17 <codeshot> but for the two syntactical alternatives the parameter to the heuristic function will be different for the two
12:41:58 <codeshot> the heuristic should be able to use the law, but optimise itself must ignore it
12:49:50 <codeshot> I suppose we could say that an IO a is a nondeterministic value (and I guess we must to be able to run a computation in the real world where power-outages happen and stuff like that), and optimise determines a single point to provide to the heuristic
13:07:09 <[exa]> codeshot: ever heard about a program that only runs right on a power outage?
13:08:20 <ReinH> We could say that but it would probably be better if we didn't.
13:10:12 <ReinH> Also "the value of the two is different" would only be true for a completely non-standard definition of "value", which would only be confusing.
13:10:29 <ReinH> And, for that matter, of equality
13:12:52 <ReinH> So if you're going to continue with this line of reasoning, I really think you should stop using the term "value" to describe this concept.
13:16:49 * hackage eventsource-api 1.2.0 - Provides an eventsourcing high level API.  https://hackage.haskell.org/package/eventsource-api-1.2.0 (YorickLaupa)
13:19:08 * hackage eventsource-geteventstore-store 1.0.5 - GetEventStore store implementation.  https://hackage.haskell.org/package/eventsource-geteventstore-store-1.0.5 (YorickLaupa)
13:20:17 <codeshot> [exa], exactly my point
13:21:19 <codeshot> ReinH, Reading through ncatlab this is a standard line of reasoning and subject to much analysis
13:21:31 <Tuplanolla> I know some programs that are equally reliable with and without power, [exa]...
13:21:41 <ReinH> @codeshot What do you refer to when you say "this"?
13:21:41 <lambdabot> Unknown command, try @list
13:21:47 <codeshot> it is a question of definition of terms and symbols
13:21:47 <codeshot> You should check before stopping someone from learning
13:21:49 <ReinH> Ugh sorry, too much Slack
13:22:06 <ReinH> codeshot: I'm trying to stop someone from failing to communicate effectively
13:22:13 <codeshot> ReinH, I refer to a line of reasoning close to the speaker
13:22:19 <codeshot> closer than other lines of reasoning
13:22:23 <ReinH> What does that mean?
13:22:23 <codeshot> this is normal in English
13:22:32 <codeshot> Are you a bot?
13:22:40 <ReinH> Are you being intentionally obtuse?
13:22:43 <codeshot> no
13:22:49 <ReinH> So it's accidental then.
13:22:55 * hackage eventsource-store-specs 1.1.0 - Provides common test specification for Store implementation.  https://hackage.haskell.org/package/eventsource-store-specs-1.1.0 (YorickLaupa)
13:23:29 <codeshot> ReinH, Perhaps I don't have the same extent of mathematical training as you
13:23:37 * hackage wai-git-http 0.0.0 - Git http-backend CGI App of WAI  https://hackage.haskell.org/package/wai-git-http-0.0.0 (Norfair)
13:23:51 <codeshot> you have communicated ineffectively
13:24:09 <ReinH> codeshot: I asked you to clarify and you gave me a troll answer.
13:24:26 <ReinH> I'm not interested in a bad faith argument today.
13:24:37 <codeshot> You asked me to clarify one of the most fundamental words in our common tongue
13:24:44 <codeshot> that was trolly too
13:24:46 <ReinH> No, I asked you to clarify your usage of the word.
13:25:01 * hackage eventsource-stub-store 1.0.3 - An in-memory stub store implementation.  https://hackage.haskell.org/package/eventsource-stub-store-1.0.3 (YorickLaupa)
13:25:02 <ReinH> That is, to specify what it referred to
13:25:12 <ReinH> Because to me it was a dangling referent.
13:25:16 <codeshot> Yes, but you didn't need to and were consuming my time and wearing my faithfulness, which is trolly
13:25:19 <ReinH> I did need to
13:25:25 <codeshot> It's quite hurtful
13:25:26 <ReinH> Because I didn't understand you.
13:25:32 <[exa]> Tuplanolla, ReinH: The point was that the world is too complicated :] wanted to help codeshot to avoid thinking about "what if" when the problem is already complicated enough :]
13:26:04 <cawfee> hey guys doing some λcalculus here, how do I find a combinator F satisfying FIKK = FK?
13:26:11 <codeshot> "ReinH> So if you're going to continue with this line of reasoning"
13:26:30 <cawfee> other than the trivial "eater"
13:26:39 <Tuplanolla> I can't really make sense of what you're after either, codeshot.
13:26:40 <[exa]> cawfee: F = K I ?
13:26:47 <ReinH> codeshot: See, it would have been easy to answer my question in a non-trolly way.
13:27:09 <codeshot> Why do I have to accept your failings and not have the same ones?
13:27:11 <[exa]> cawfee: oh so you're trying to find it :]
13:27:26 <codeshot> You are being unfair
13:27:39 <cawfee> ya doing some textbook exercises
13:27:55 <ReinH> codeshot: Ok, none of this is productive. I'm going to ignore you now.
13:28:00 <codeshot> I have been on the receiving end of hours of the same, and I do it for seconds and I get all this criticism
13:30:01 <Average-user> cawfee: Interested on lambdacalcalculus too, don't much about it, any recommendations of where and how to start?
13:30:08 <[exa]> cawfee: well, about the systematical solution -- try to find a STLC type of FK and FIKK assuming f :: a
13:30:26 <[exa]> cawfee: then look at 'a' and find a program that has that type
13:30:51 <cawfee> wow too advanced man
13:30:57 <cawfee> this is like a chapter 1 exercise
13:31:47 <[exa]> cawfee: well, then the 'eater' is probably good enough :]
13:32:07 <Average-user> In my comment above I missed the 'know' between don't and much
13:33:11 <cawfee> [exa]: I guess I'll live with K_\infty for now then, thanks
13:33:54 <[exa]> cawfee: anyway, KI can be found this way: you can "eta-reduce" to FIK = F which reduces your search space a bit
13:34:03 <cawfee> Average-user: from most approachable to most thorough: http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf , http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf , http://www.paultaylor.eu/stable/prot.pdf
13:34:34 <cawfee> those links are from end of chapter 1 by Allen
13:37:17 <cawfee> [exa]: lmao I think I got it
13:38:05 <[exa]> cawfee: sorry I wanted to finish the sentence but it's better if you came to a solution first :]
13:38:17 <cawfee> why did I not eta-reduce it in the first place I wonder
13:39:22 <cawfee> well F=YG where G = λabc.a seems to work
13:40:23 <Average-user> cawfee: thanks! I'll have a look on them soon
13:42:21 <unclechu> hey guys, i'm trying to program on type-level, i'm trying to use Maybe as type level, like `type Foo SomeModel = 'Just SomeAnotherModel`, but when i compare it for Just or Nothing I always getting that value of Just is ambigous, any advices how to avoid this?
13:42:41 <[exa]> cawfee: also no idea why I found KI (sorry for confusion)
13:43:58 <ReinH> unclechu: But... Just isn't a type.
13:44:30 <Eduard_Munteanu> unclechu, how are you "comparing"?
13:45:11 <ReinH> Can you lpaste a minimal example and the error message?
13:45:16 <unclechu> ReinH: let's say it could be if some extensions are enabled :)
13:45:26 * hackage eventstore 1.0.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.0.0 (YorickLaupa)
13:45:54 <ReinH> unclechu: So you're using DataKinds? I just want to make sure I understand the context. An actual example would be even better.
13:46:28 <unclechu> one second, i'll just show you parts of the code
13:47:10 <unclechu> extensions: https://github.com/unclechu/sibtek-site/blob/4a6a742e1158d38b477d6c08367bb4c23c1032c0/backend/admin-api/package.yaml#L27-L43
13:47:19 <unclechu> and here the place of the issue: https://github.com/unclechu/sibtek-site/blob/4a6a742e1158d38b477d6c08367bb4c23c1032c0/backend/admin-api/src/Model/Class.hs#L58-L64
13:47:57 <unclechu> and that's what i use to compare https://github.com/unclechu/sibtek-site/blob/4a6a742e1158d38b477d6c08367bb4c23c1032c0/backend/admin-api/src/Sugar.hs#L56-L58
13:47:58 <infinisil> Damn, arrows are pretty friggin cool
13:50:37 <unclechu> here is an example of `'Just` type: https://github.com/unclechu/sibtek-site/blob/4a6a742e1158d38b477d6c08367bb4c23c1032c0/backend/admin-api/src/Model/User.hs#L30
13:53:59 <unclechu> I just wan't to infer `ParentModel` or `NoParentModel` by `Parent m` which is `Maybe *` on type-level
13:55:31 <Eduard_Munteanu> unclechu, where's ModelIdentity defined as a type?
13:56:01 <unclechu> Eduard_Munteanu: https://github.com/unclechu/sibtek-site/blob/4a6a742e1158d38b477d6c08367bb4c23c1032c0/backend/admin-api/src/Model/Class.hs#L38
13:56:39 <Eduard_Munteanu> unclechu, there are no values of ModelIdentity
13:56:58 <Eduard_Munteanu> unclechu, so what are you going to supply to ParentModel?
13:57:41 <Eduard_Munteanu> No values of 'ModelIdentity to be exact
13:59:20 <unclechu> Eduard_Munteanu: I use only bottom for `ModelIdentity`, it's just infering by scoped-type-variables
14:01:03 <unclechu> Eduard_Munteanu: I will inherit parent's fields and will do other stuff, doesn't matter right know, anyway, i wan't to solve it nothwithstanding if i'm going to actually use it or not
14:02:08 <unclechu> Eduard_Munteanu: by this type `ParentModel ∷ (Model p, Parent m ~ 'Just p) ⇒ ModelIdentity p → ParentModel m` you could see that parent model is infered by `ModelIdentity` here
14:04:09 <unclechu> and this is works when I explicitly declare `parentModel` method for `Model` instances as `ParentModel undefined`, but I could forget to do that and in this case I don't feel I'm protected by type-system, and I prefer to just declare minimal required types and other stuff will be automatically infered
14:07:19 * hackage microsoft-translator 0.1.1 - Bindings to the Microsoft Translator API  https://hackage.haskell.org/package/microsoft-translator-0.1.1 (Cliff_Harvey)
14:09:58 <codeshot> Tuplanolla, I was just after discussion of the maths around equality as it applies to Haskell and can be usefully targeted to automate the practical activities that I see being done in software engineering by utilising the advantages of Haskell's higher-level scope than most languages I see being used in earnest
14:12:23 <codeshot> Tuplanolla, Unfortunately ReinH wanted me to cease discussion, first by directing me to an interpretation that I don't find in the primary free educational materials, being an interpretation that is completely closed and doesn't support the valuable human activities I see being done, then by deliberately failing to see the extremely common common reference between only 3 lines of text, one of which was directed to
14:12:23 <codeshot> someone else and could be trivially ignored.
14:12:51 <Tuplanolla> Okay, sure.
14:12:55 <codeshot> *"common common reference" -> common mutual reference
14:14:07 <codeshot> When I tested to see if he was a trollbot tailored to Haskell he failed and got pissed off, meeting every one of his criticisms of me
14:14:17 <codeshot> that's about the size of it from my perspective
14:15:18 <codeshot> luckily, although perhaps subconciously on my part, it's hard to tell, he met each of his criticisms before levying it to me
14:16:07 <codeshot> anyhoo, if he's put me in his ignore list he won't be trying to cut my studying out, so that's a great outcome
14:16:39 <codeshot> I'll be free from subconcious political herding until the next one shows up
14:16:58 <hoon> back with another code review, please: http://lpaste.net/360949
14:18:48 <hoon> :)
14:20:07 <dmwit> hoon: `hasFlag = any` -- ?
14:20:11 <dmwit> :t any
14:20:12 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
14:20:59 <hoon> ah, yes it probably does
14:22:26 <dmwit> hoon: I think I would prefer `data Config = Config { file :: FilePath, var :: String, others :: [String] }; processArgs :: ([Flag], [String], [String]) -> IO Config` or similar.
14:22:59 <dmwit> hoon: Do you expect exactly one `File` flag and exactly one `Var` flag?
14:23:39 <dmwit> I wonder if there is an `ExactlyOne` monoid somewhere in a standard library.
14:23:58 <hoon> dmwit: on the Config suggestion, I will probably end up going that way eventually, I'm just roughing things out and getting my feet wet with getOpts
14:24:06 <dmwit> ?let data The a = None | The a | Multiple
14:24:09 <lambdabot>  Defined.
14:24:49 <hoon> dmwit: I also expect only one of each -o and -v parameters and acknowledge that I'm not error checking for the case where multiple might be present
14:24:56 <dmwit> ?let instance Monoid (The a) where mempty = None; mappend None x = x; mappend x None = x; mappend _ _ = Multiple
14:24:58 <lambdabot>  Defined.
14:25:47 <dmwit> > foldMap (\x -> case x of Left a -> (The a, None); Right a -> (None, The a)) [Left "file", Right "Var"]
14:25:49 <lambdabot>  error:
14:25:49 <lambdabot>      • No instance for (Show (The [Char]))
14:25:49 <lambdabot>          arising from a use of ‘show_M90563709629323287638356’
14:25:53 <dmwit> oh right
14:26:01 <dmwit> ?let deriving instance Show a => Show (The a)
14:26:03 <lambdabot>  Defined.
14:26:08 <dmwit> > foldMap (\x -> case x of Left a -> (The a, None); Right a -> (None, The a)) [Left "file", Right "Var"]
14:26:10 <lambdabot>  (The "file",The "Var")
14:26:22 <dmwit> > foldMap (\x -> case x of Left a -> (The a, None); Right a -> (None, The a)) [Left "file", Right "var", Right "redundant_var"]
14:26:25 <lambdabot>  (The "file",Multiple)
14:26:32 <dmwit> > foldMap (\x -> case x of Left a -> (The a, None); Right a -> (None, The a)) [Left "file"] -- missing var
14:26:35 <lambdabot>  (The "file",None)
14:26:44 <hoon> hmmm
14:26:47 <hoon> interesting
14:26:50 <dmwit> hoon: what do you think? could be a fun way to replace `hasRequiredFlags` =)
14:26:57 <ph88> hey guys, i'm trying to run wai benchmark on lts-6.3 and i'm getting these errors while building https://bpaste.net/show/1aca2c450eec how come that aeson depedency is missing ?
14:27:01 <hoon> yeah, I like that
14:27:20 <hoon> dmwit: probably would never have occurred to me to do that
14:27:46 <hoon> not aware of any "standard" way to do that?
14:28:21 <dmwit> No. I could think of a couple other uses just off the top of my head, so maybe it's worth making this into its own thing.
14:30:26 <hoon> it's certainly clever :D
14:30:27 <dmwit> hoon: well
14:30:39 <dmwit> hoon: Maybe a list would be better anyway. Then in your error you could tell all the choices you saw.
14:30:51 <dmwit> > partitionEithers [Left "var", Left "var2", Right "file"]
14:30:53 <lambdabot>  (["var","var2"],["file"])
14:31:21 <dmwit> hoon: So you could consider using `OptDescr ([String], [String])` and just `fold` to combine them all together.
14:31:39 <dmwit> (Or make a more descriptive type than `([String], [String])` if you like.)
14:31:53 * hackage parameterized-utils 1.0.0 - Classes and data structures for working with data-kind indexed types  https://hackage.haskell.org/package/parameterized-utils-1.0.0 (RobertDockins)
14:32:13 <hoon> yeah, certainly easy to handle multiples with a length > 1 check
14:32:23 <dmwit> Or just a pattern match.
14:32:29 <hoon> or that
14:32:40 <dmwit> `case files of [file] -> success; [] -> complain not enough; _ -> complain too many`
14:33:16 <ReinH> Tuplanolla: lol that was all BS
14:33:20 <hoon> yeah
14:33:25 <Tuplanolla> Keep me out of this, ReinH.
14:33:27 <hoon> can I ask one last quick question?
14:33:34 <ReinH> Tuplanolla: I would like to be kept out of it too
14:33:39 <codeshot> hoon, processArgs is actually "assertArgsAreValid"
14:33:41 <hoon> the "isVar" and "isFile" functions
14:33:56 <hoon> those feel "ugly" to me
14:34:05 <dmwit> I agree.
14:34:15 <hoon> let isFile (Var a) = True
14:34:21 <hoon> let isFile _ = False
14:34:39 <ph88> oh great lts-10.0 is out ! :D
14:34:41 <hoon> -- assuming I use "any isFile" approach
14:34:49 <hoon> is there a "better" way?
14:34:50 <dmwit> Well, that would be especially bad, because that should be called `isVar` and also the second `let` would shadow the first. =P
14:35:02 <hoon> haha
14:35:02 <dmwit> But yes, I understand the real question.
14:35:29 <hoon> right, sorry I don't know how to make lambdabot do the right dance in here
14:35:30 <hoon> :)
14:35:37 <dmwit> So the conceptual problem here for me is that you are making this a two-stage thing: first, check that the data is valid, then extract the data you want assuming it's valid.
14:35:56 <dmwit> I would want it to be a one-stage thing: in the process of checking that the data is valid, extract the data of interest.
14:36:23 <dmwit> So, instead of `hasFile :: [Flag] -> Bool` and `getFile :: [Flag] -> String`, I would want `getFile :: [Flag] -> Maybe String` or similar.
14:37:06 <hoon> ah, I see what you're saying
14:37:11 <dmwit> (Or, better yet, `parseFlags :: [Flag] -> (Maybe String, Maybe String)`.)
14:37:35 <dmwit> (Or, better still, `parseFlags :: [Flag] -> ([String], [String])`. And now we've come full-circle...)
14:38:27 <hoon> parseFile :: [Flags] -> Either String (File String) ?
14:38:56 <dmwit> Perhaps, yes. Here the first `String` is intended to be an error message or so?
14:39:13 <hoon> yeah
14:39:15 <dmwit> right
14:40:04 <dmwit> Gotta run. You seem to be firmly on the path of righteousness. =)
14:40:18 <hoon> so, parseFile, parseVar, parseFiles all combine to become something like parseArguments :: (a, b, c) -> Maybe Config
14:40:23 <hoon> haha
14:40:31 <hoon> fair enough, I'm heading out now too
14:40:35 <hoon> thank you for your input
14:44:44 <ph88> lts-10.0 guys :p
14:46:48 * hackage arithmoi 0.6.0.1 - Efficient basic number-theoretic functions.  https://hackage.haskell.org/package/arithmoi-0.6.0.1 (Bodigrim)
14:46:53 <dsal> Yeah.  Builds don't work on my ARM machine.  :(
15:10:14 <davean> dsal: what builds don't work?
15:11:42 <dsal> No information found for ghc-8.2.2.
15:11:42 <dsal> Supported versions for OS key 'linux-armv7': GhcVersion 7.10.2, GhcVersion 7.10.3, GhcVersion 8.0.1, GhcVersion 8.0.2, GhcVersion 8.2.1
15:14:43 <davean> What are you trying to use here?
15:14:59 <dsal> Just latest stack in a project with the LTS 10.0
15:15:03 <dsal> on ARM
15:15:12 <davean> https://downloads.haskell.org/~ghc/8.2.2/
15:15:22 <davean> GHC 8.2.2 is available for ARMv7 there
15:15:28 <davean> Oh, you're trying to use stack
15:15:33 <davean> Uh, no idea
15:15:39 <dsal> Yeah.  Probably will fix itself shortly.
15:15:40 <davean> if you don't use stack though you can just go install it and build it
15:16:00 <dsal> I just have a script that builds a bunch of my things on a bunch of different things.  It'll sort it out.
15:16:07 <ReinH> dsal: I mean, probably just give it a minute? :)
15:16:31 <ReinH> When was 10.0 released?
15:16:33 <dsal> :) Yeah.
15:16:40 <dsal> I don't know. I saw it earlier, so upgraded all my things immediately.
15:16:49 <dsal> It's that or like, work.
15:16:54 <ReinH> Hmmmm
15:17:06 <Average-user>  ReinH: 10.0 what?
15:17:34 <ReinH> Average-user: Stackage LTS 10.0, which was released today
15:18:11 <Average-user> ohh
15:20:15 <kadoban> dsal: Might want to submit an issue if it doesn't clear up soon. Which ... I wouldn't expect to happen I don't think. https://github.com/commercialhaskell/stack/issues
15:20:36 <kadoban> Make sure you're on the newest release also, just in case. Though I didn't think that was essential for that.
15:21:18 <dsal> No, the older version broke a different thing.  :)
15:27:50 <dsal> filed https://github.com/commercialhaskell/stack/issues/3680 anyway
15:31:24 <ph88> hey guys, with this build plan failure https://bpaste.net/show/047f0099e05b which package(s) should upgrade their dependencies actually ?
15:31:52 <ph88> hasql-pool ?
15:34:34 <ph88> should i report this somewhere ?  this is for lts-10.0
15:35:29 <ph88> oh i think i found the file i should fix
15:47:56 <jle`> i can't wait for new ghc to come out, the new monad transformers in 'transformers' look awesome
15:50:05 <lyxia> jle`: AccumT and SelectT?
15:50:35 <jle`> yeah, the other day i wanted to use Accum but was sad to find out it wasn't out yet
15:51:39 <jle`> but also why is Data.Functor.Constant still in transformers
16:10:01 * hackage objective 1.1.2 - Composable objects  https://hackage.haskell.org/package/objective-1.1.2 (FumiakiKinoshita)
16:13:42 <lyxia> "A Mortal is an object that may die. A mortal yields a final result upon death." ^
16:27:01 <madseabear> anyone alive ?
16:27:18 <hpc> no
16:27:26 <Rembane> Nope
16:27:29 <hpc> /topic welcome to #nihilism
16:27:36 <Rembane> This is the undead #haskell channel.
16:27:40 <Rembane> Brrrrrains...
16:27:43 <madseabear> i'm trying to run a simulation with this package
16:27:43 <madseabear> http://hackage.haskell.org/package/probability-0.2.5.1/docs/Numeric-Probability-Example-TreeGrowth.html#g:1
16:27:54 * yohotchoc replaces Rembane's brain with an already eaten one
16:28:05 <Rembane> yohotchoc: Hey! That was my brain!
16:28:07 <hpc> /nick Rembrain
16:28:11 <Rembane> :D
16:28:13 <madseabear> but when doing simTree 20 2 tree i get this error No instance for (Show (Numeric.Probability.Percentage.RDist Tree))
16:28:20 <yohotchoc> Are you trying to refer to old values her?
16:28:24 <yohotchoc> here*
16:28:29 * Rembane garbage collects yohotchoc 
16:28:38 <madseabear> do you have any idea why ?
16:31:07 <yohotchoc> doesn't seem to be a show instance for RDist according to https://hackage.haskell.org/package/probability-0.2.2/docs/Numeric-Probability-Percentage.html#t:Dist
16:32:18 * hackage libravatar 0.4.0.2 - Use Libravatar, the decentralized avatar delivery service  https://hackage.haskell.org/package/libravatar-0.4.0.2 (akrasner)
16:36:33 <madseabear> yohotchoc: so it's bugged ?
16:37:00 <madseabear> i'm pretty new to haskell and i'm not sure i understand
16:37:15 <yohotchoc> no, no bug
16:37:25 <hpc> are you running it in ghci?
16:37:34 <madseabear> in cabal repl
16:37:37 <yohotchoc> In order to display things you need to be able to convert them to a string - which ghci does automatically when you type a statement
16:37:39 <madseabear> if that makes a difference
16:37:41 <yohotchoc> (or the cabal repl)
16:37:44 <hpc> yeah, when you do that it tries to print out the result
16:38:08 <hpc> Prelude> id
16:38:08 <hpc> <interactive>:2:1:
16:38:08 <hpc>     No instance for (Show (a0 -> a0))
16:38:08 <yohotchoc> the conversion to string is done by show :: a -> String, but in order for that to work, the thing you're trying to print needs a show instance
16:38:13 <hpc> and so forth
16:38:28 <yohotchoc> the thing you're trying to create doesn't have a show instance, so it can't be printed
16:38:34 <madseabear> i see there's a show T -> string
16:39:00 <madseabear> and RDist a = T (Dist a)
16:40:15 <yohotchoc> that's actually a different T
16:40:31 <yohotchoc> https://hackage.haskell.org/package/probability-0.2.2/docs/Numeric-Probability-Random.html it's this one, which doesn't have a show instance
16:40:53 <madseabear> yohotchoc: you're looking at the wrong version
16:41:03 <madseabear> my link was for 0.2.5.1
16:41:22 <madseabear> http://hackage.haskell.org/package/probability-0.2.5.1/docs/Numeric-Probability-Percentage.html
16:41:25 <kamyar> See this: read . unpack <$> split (==',') "1,2,3" :: [Double]
16:41:41 <kamyar> It returns: [1.0,2.0,3.0]
16:42:03 <yohotchoc> madseabear: if you click the T beside RDist there, it'll direct you to the Numeric-Probability-Random definition of T
16:42:15 <kamyar> Now I want to give it (Just "1,2,3") and return (Maybe [Double]) instead of [Double]
16:42:21 <kamyar> please help me how
16:42:27 <yohotchoc> which doesn't (and can't, since it's essentially a wrapper on a function) have a show instance
16:43:10 <madseabear> yohotchoc: so i can't see the result ?
16:43:20 <madseabear> then how am i suppose to use it ?
16:43:42 <madseabear> assuming it's not bugged like you said
16:44:04 <yohotchoc> you need to look at the types of what you're producing and the functions defined on them
16:44:28 <kamyar> Someone please reply me
16:45:48 <kamyar> Any good guy to answer my question?
16:46:08 <geekosaur> @index readMaybe
16:46:08 <lambdabot> Text.Read
16:47:19 * hackage mios 1.6.0 - A Minisat-based CDCL SAT solver in Haskell  https://hackage.haskell.org/package/mios-1.6.0 (shnarazk)
16:47:41 <lyxia> kamyar: fmap (\x -> read . unpack <$> split (== ',') x) (Just "1,2,3") :: Maybe [Double]
16:48:14 <madseabear> yohotchoc: so i did Rnd.print & simTree ... and it works
16:48:14 <lyxia> kamyar: you could also use pattern matching.
16:48:16 <kamyar> lyxia: Thanks! and no better and more tidy way?
16:48:30 <yohotchoc> madseabear: sweet, nice
16:48:59 <yohotchoc> I couldn't really give you a more helpful answer there since I'm not familiar with that package, but it clearly worked out anyway :D
16:49:02 <madseabear> thanks for the help
16:49:04 <yohotchoc> no problem
16:54:28 <mbwgh> When should it be expected that (*>) does something different than (>>)? I just noticed this is the case for conduits.
16:57:42 <d34df00d> Hi there!
16:57:55 <hpc> u *> v = (id <$ u) <*> v and (<$) = fmap . const
16:58:14 <d34df00d> Are there any alternatives for the taggy [ https://hackage.haskell.org/package/taggy ] library that are available in recent stack lts? taggy's only available in 8.20 and older.
16:58:40 <hpc> assuming (<*>) = ap (which is a law)
16:59:11 <hpc> u *> v = ((fmap . const) id u) `ap` v
16:59:19 <kadoban> d34df00d: You could try it as an extra-dep and see if it either works or is fixable.
16:59:50 <hpc> expand out ap, u *> v = do { x1 <- (fmap . const) id u; x2 <- v; return (x1 x2) }
17:00:40 * mniip whistles
17:01:09 <d34df00d> kadoban: right, let me try that, thanks!
17:01:10 <hpc> u *> v = do { x1 <- fmap (const id) u; x2 <- v; return (x1 x2) } -- this should be equal to do {_ <- u; let x1 = id; x2 <- v; return (x1 x2) }
17:01:30 <hpc> and then some fairly basic simplification yields the same definition as for (>>)
17:01:40 <hpc> mbwgh: so i would expect (*>) to always equal (>>)
17:02:02 <mniip> *> equals >> if <*> equals ap, yes
17:02:15 <kadoban> d34df00d: The stack.yaml in the repo at least suggests that it should work with lts-9.0, so that's something. (though it could just be incorrect)
17:02:25 <hpc> (there's better ways to derive it from just the types, but just directly translating the source code with laws makes it more obvious)
17:02:37 <hpc> mbwgh: so i guess it would depend on what you're noticing
17:02:42 <mniip> hpc, well the type of *> has two implementations
17:02:55 <d34df00d> kadoban: nope :(
17:02:58 <d34df00d> http://bpaste.net/show/2f3a5f32cc14
17:03:30 <hpc> so does the type of (>>)
17:03:38 <mbwgh> hpc: That's reassuring. I just noticed that the fixities are different though, which was indeed the cause for the confusion...
17:03:41 <Durbley> is the haskell book by chris allen released physically yet
17:03:42 <kadoban> d34df00d: Hm, too bad.
17:03:56 <mniip> hpc, not really no
17:03:58 <hpc> and (>>) is even a class method
17:04:09 <mniip> Applicative has a Backwards endo"morphism"
17:04:10 <mniip> Monad doesn't
17:04:12 <d34df00d> So is there anything as dumb and straightforward? I really don't want to mess with hxt arrows for a very simple task I have here at hand.
17:04:14 <kadoban> d34df00d: That looks like a bit of a strange error just from a GHC version change, maybe some library it's using changed types a tad. It could be an easy fix ... maybe.
17:04:23 <hpc> mniip: for all Applicative f that is also Monad f, (*>) and (>>) have identical types
17:04:36 <mniip> sure
17:04:42 <hpc> mbwgh: ah, there you go then
17:04:50 <d34df00d> kadoban: I'm lazy, so finding an already working library is of higher priority than fixing this one :)
17:04:56 <kadoban> :)
17:05:09 <mniip> but like, you can't just derive the exact behavior of *> from its type
17:05:22 <mniip> you doo need the statement that <*>=ap
17:05:35 <mbwgh> hpc: It caused (*>) to sequence action "in the wrong conduit" and then values were dropped. Still, thanks for the cool equational reasoning style answer!
17:06:20 <hpc> mniip: that only carries the relationship between Applicative and Monad
17:06:41 <mniip> that relationship is a necessary assumption for your proof
17:06:56 <hpc> oh that, yes
17:07:14 <hpc> for your "there's two implementations", that's the case for both (*>) and (>>) though
17:08:22 <hpc> if someone ever writes acme-prelude, i hope they give (>>) a default instance that runs actions backwards
17:08:34 <hpc> er, default definition
17:09:36 <d34df00d> Actually, tagsoup looks quite promising, dunno why I chose taggy in the first place!
17:09:40 <mniip> x *> y  =  const <$> x <*> y  =  (const id <$> x) `ap` y  =  (const id <$> x) >>= \a -> y >>= \b -> return (a b)  =  (const id <$> x) >>= \a -> y >>= \b -> return (a b)  =  x >>= \c -> y >>= \b -> return (const id c b)  =  x >>= \a -> y >>= return  =  x >>= \a -> y  =  x >> y
17:11:04 <mniip> def of *>, monad-applicative equiv, def of ap, duplicated equation for some reason, fmap-bind law, expansion of const-id and eta contraction, bind-return law, def of >>
17:12:08 <mniip> hpc, yeah true >> has another implementation
17:12:28 <mniip> I was thinking about the importance of the part where Backwards makes a whole lawful applicative
17:12:36 <mniip> and there's no similar construction in monads
17:12:51 <mniip> not sure if that's really relevant
17:47:03 <n_blownapart> << aka crucify_me . hi when we use (const False) as the predicate here, is there a benefit other than satisfying the type where this must be a function ? please see line 10 : http://lpaste.net/360956
17:47:55 <d34df00d> Hmm, do I understand correctly that I cannot feed some HTML to HXT in pure code and purely get the results back?
17:48:07 <d34df00d> Its main arrow seems to be tied to IO, or am I wrong?
17:48:37 <jle`> n_blownapart: the function tells unnfold when to stop unfolding
17:48:46 <jle`> n_blownapart: so (\_ -> False) means never stop unfolding
17:49:06 <jle`> (\_ -> True) would mean just stop unfoding right away and return an empty list immediately
17:50:37 <d34df00d> Ah right, https://stackoverflow.com/questions/3901492/running-haskell-hxt-outside-of-io
17:50:53 <n_blownapart> jle`, thanks one moment I thought without take n this doesn't terminate
17:52:20 <jle`> n_blownapart: yes check out line 4
17:52:29 <jle`> where the function returns []
17:56:08 <n_blownapart> right jle`  I thought it would terminate but it doesn't when I run iterateUnfold (* 3) 4
17:56:45 <n_blownapart> am I tripping?
17:56:56 <n_blownapart> ie doing something wrong
17:58:32 <jle`> the termination depends on what the 'p' function returns
17:58:39 <jle`> if it ever returns True, then it will return []
17:58:43 <jle`> that's what the line:
17:58:45 <jle`>    | p x = []
17:59:08 <jle`> if p x is ever True, then it'll terminate with [].  otherwise, it'll continue consing on new items
17:59:27 <jle`> n_blownapart: so when you have iterateUnfold f = unnfold (const False) id f
17:59:42 <jle`> if (const False) ever returns True, then the list will terminate
17:59:56 <jle`> so...is there any input that would case 'const False' to return True?
18:00:01 <jle`> let's try a few to see
18:00:06 <n_blownapart> ok
18:00:08 <jle`> > (const False) 10
18:00:10 <jle`> hm, it's False
18:00:11 <lambdabot>  False
18:00:16 <jle`> > (const False) "hello"
18:00:19 <lambdabot>  False
18:00:38 <jle`> sample size of 2 seems big enough to conclude
18:00:55 <jle`> that there is nothing you can give 'const False' that will return True, so it'll never terminate :)
18:01:04 <mniip> d34df00d, unsafePerformIO :D
18:01:31 <jle`> @check \x -> const False (x :: Double) == False
18:01:33 <lambdabot>  +++ OK, passed 100 tests.
18:01:45 <n_blownapart> ok but also the next arg after (const False) must be a function so "10" is not valid given unnfold right?
18:02:20 <jle`> not unless 10 were to be interpreted as a function
18:02:23 <n_blownapart> but that is moot I suppose
18:02:28 <jle`> but an Int or a Double etc. would not be valid, yes
18:02:55 <n_blownapart> whenever id is nearby, I start getting anxious
18:03:03 <jle`> 'id' is your friend :)
18:03:08 <n_blownapart> must be freudian
18:03:41 <jle`> you found the secret
18:03:49 <n_blownapart> so we are forcing the predicate to remain false, but since this is a book example, why?
18:04:16 <jle`> it depends on the function you want to write
18:04:33 <jle`> you are defining a function that will iterate a given function forever
18:04:35 <jle`> > iterate succ 0
18:04:37 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:05:00 <jle`> this is the behavior we want, so it makes sense to give (\_ -> False) as the stopping predicate
18:05:21 <d34df00d> mniip: you're joking, but there is a library called clang-pure which tries to be pure by doing unsafePerformIO all over the place.
18:05:23 <d34df00d> Meh.
18:05:35 <mniip> shrug
18:05:50 <mniip> when's last time you peeked at bytestring or text internals
18:05:56 <n_blownapart> we want it, if we want an infinite behavior
18:06:10 <n_blownapart> right?
18:06:36 <d34df00d> Whatever those internals are, they are used (and thus tested) almost infinitely wider than clang-whatever.
18:07:28 <jle`> n_blownapart: yeah, (\_ -> False) is a predicate that will ensure that unnfold never stops
18:09:30 <n_blownapart> thanks jle` I know it involves laziness, so ...
18:09:56 <n_blownapart> soon I'll understand when this behavior is desired, I still don't have a handle on it
18:12:02 <mniip> d34df00d, still blows up every so often
18:15:24 <n_blownapart> jle`, going back to my op , I realized this was the terminus/non-terminus, but I was curious if const False had any advantage over, say, your example, (\_ -> False)
18:16:02 <n_blownapart> aside from being an elegant way to satisfy the need of a function there
18:19:04 <n_blownapart> if the type were just Bool instead of (a -> Bool) is I guess what I meant
18:21:39 <jle`> n_blownapart: there isn't quite an advantage, it's basically just inlining the definition
18:21:45 <jle`> (\_->False) even has less characters :)
18:21:55 <jle`> neither is really more elegant than the other
18:22:16 <jle`> they are both a way to provide a function that always returns False given any input
18:22:56 <jle`> i personally prefer writing (\_ -> False) instead of (const False), which might be against some people's style choices, but i don't think anyone would be mad at me
18:22:58 <jle`> besides hlint
18:24:08 <n_blownapart> is h*lint a member or a feature of an environment ? jle`
18:24:38 <jle`> hlint is a tool that analyzes your source file to suggest simple stylistic improvements
18:24:51 <jle`> usually its advice is helpful
18:24:52 <n_blownapart> yeah I had lint on the atom editor but didn't know what it was
18:25:26 <n_blownapart> atom kept crashing on me jle` so I'm now using vim which is like learning a bloody language
18:25:47 <n_blownapart> thanks for your help and patience
18:26:00 <jle`> np!
18:26:08 <boj> n_blownapart: a few of my guys use vscode, might be worth poking at if you don't want to learn vim
18:26:31 <boj> and avoid crashing
18:27:35 <n_blownapart> boj vim is sort of cool but I can barely use it.. meanwhile I'm trying to learn haskell :)    who are "your guys"?
18:28:09 <boj> n_blownapart: ah, i run a haskell dev team. they are "my guys"
18:28:34 <n_blownapart> wow, I really hope one day I can be gainfully employed with haskell boj
18:28:46 <boj> always a possibility :)
18:29:22 <n_blownapart> I'm a bit slow... its very strange, my mind complicates everything, then I realize "wait, that's not very complicated at all."
18:29:24 <n_blownapart> boj
18:29:45 <n_blownapart> comments appreciated
18:29:58 <boj> i think i was the same way. had a bit to un-learn when picking up haskell before i really got it
18:30:08 <boj> i'm sure i'm almost an advanced beginner now
18:31:10 <n_blownapart> I never programmed professionally, I went through a ruby book and a bit of SICP, I don't know what programming really is, but what I need to unlearn is the intimidation I feel boj
18:31:52 <boj> n_blownapart: interesting. intimidation programming in general, or using haskell?
18:32:18 <Welkin> I think I know what you mean by feeling intimidated
18:32:50 <n_blownapart> do you mean being programmed to be intimidated by "society" or really just by programming generally? boj
18:32:55 <Welkin> even after programming for a few years and having taken several university courses on programming and computer science, I had no idea how to build software
18:33:10 <Welkin> computer science, programming, and building software are completely different things
18:33:29 <n_blownapart> Welkin, !!
18:33:32 <Welkin> programming is a tool, like a hammer
18:33:33 <boj> n_blownapart: sorry, i meant are you intimidated by programming itself?
18:33:43 <n_blownapart> a bit yes boj
18:34:08 <Welkin> it took me at least 3 years of actually building software to get to a point where I felt comfortable and felt like I knew what I was doing
18:34:42 <n_blownapart> but I feel like I have a knack for it if you can believe it. I am very analytic but its such a strange terrain.
18:34:49 <Welkin> it's normal
18:34:50 <mniip> huh
18:35:08 <Welkin> you will feel uncomfortable for a few years in my experience and from what I have heard from others
18:35:13 <mniip> I've had the experience of building software before taking any computer science or programming courses
18:35:15 <n_blownapart> It's like I'm over analytic with this stuff
18:35:18 <mniip> I guess I'm different...
18:36:06 <boj> everyone's path is different :)
18:36:11 <n_blownapart> well-taken. everyone tells me to learn python. I'm like, naa, I want to learn haskell.
18:36:13 <Welkin> domain knowledge is more important than you may think
18:36:28 <n_blownapart> Welkin, please elaborate
18:36:50 <Rembane> I generally just fake it 'til I make it and swear a lot meanwhile. Hm... maybe you shouldn't do like I do but YMMV.
18:37:20 <Welkin> learning to program is like learning to use a hammer. Learning how to build web applications is like learning how to build a boat. KNowing how to use a hammer is not nearly enough.
18:37:23 <n_blownapart> Rembane, that's what I do in choir when I don't know a piece of music
18:37:54 <Rembane> n_blownapart: Does it work? :)
18:38:04 <n_blownapart> sort of!
18:38:26 <Rembane> Does it sound good?
18:38:42 <n_blownapart> except I try to not swear though sometimes I do in choir.
18:39:12 <Rembane> Sweet.
18:39:17 <n_blownapart> we sounded excellent on sunday. I'm not joe christian but can't resist the English tradition
18:39:30 <Welkin> in the end, the language you use is irrelevant compared to the domain knowledge, which will take many years to gain
18:39:36 <Welkin> that is what I feel bulding software is all about
18:39:40 * hackage aeson-yak 0.1.1.2 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.1.2 (tejon)
18:40:17 <Rembane> n_blownapart: Good stuff.
18:41:12 <n_blownapart> Welkin, so generally do you think haskell will become more prevalent in scientific computing and the whole big data web 3.0 ?
18:41:48 <n_blownapart> or will python continue to gain ground there?
18:42:05 <Welkin> yes, but python already has so much traction with numpy/scipy and their whole ecosystem that it is unlikely to surpass it in popularity and library support
18:42:12 <Welkin> python owns that niche right now
18:42:16 <Welkin> and that's fine
18:42:28 <Welkin> haskell has its own niches that is owns
18:42:36 <Welkin> like parsing, DSLs, compilers
18:42:42 <Welkin> and in my opinion, web servers
18:43:00 <boj> there does seem to be a haskell data science group http://www.datahaskell.org/
18:43:06 <Welkin> also, scientific computing is not about programming at all
18:43:07 <boj> maybe they'll make a small dent
18:43:11 <n_blownapart> yeah I work at UC Berkeley. its all anyone talks about, ad nauseum
18:43:16 <n_blownapart> (python)
18:43:18 <Welkin> you will do very little programming
18:43:33 <Rembane> Python is very nice until it isn't.
18:44:16 <Welkin> numpy/scipy aren't really python anyway
18:44:19 <n_blownapart> I'm just going to keep learning haskell. I'm not switching languages until I achieve a decent mastery of it
18:44:21 <Welkin> it's more lik using matlab
18:44:27 <mniip> 1513737408 [05:36:48] <Welkin> learning to program is like learning to use a hammer. Learning how to build web applications is like learning how to build a boat. KNowing how to use a hammer is not nearly enough.
18:44:27 <Rembane> Indeed, but nicer. :)
18:44:39 <Welkin> haskell is a very good language to learn how to build software
18:44:41 <Welkin> python is not
18:44:42 <boj> n_blownapart: not a bad idea. regardless of where you go there's a lot you can take away
18:44:44 <Welkin> it is a terrible
18:44:51 <mniip> yeah and then there are people who build boats driving the nails in with the handles
18:45:01 <Welkin> only learn python if you want to use numpy/scipy, but not for building applications
18:45:02 <n_blownapart> you have my attention now Welkin
18:45:29 <n_blownapart> excellent advice all. I really like it. I want to learn categories, the whole bit
18:46:25 <n_blownapart> thanks boj et al
18:47:20 <Welkin> just note that there is not a single language that is ideal for everything
18:47:34 <Welkin> and you will use dozens of languages throughout your life
18:47:49 <Guest78> Good evening, all. I'm aware of Tanenbaum's Minix, the MTX, Lion's commented Unix V6, XINU... so I ask in earnest, what is the "Haskell" of OSs, if C "is" Linux?
18:47:55 <n_blownapart> thanks
18:48:36 <boj> Guest78: maybe HaLVM?
18:48:47 <boj> more of a unikernel than a full blown OS
18:50:21 <Guest78> pardon my ignorance of unikernels - coarsely what does that leave out?
18:50:46 <Guest78> at a glance it seems to be simply a way to modularize parts of the OS for the applications to bind to when built...
18:51:16 <Guest78> But HaLVM looks very interesting, and the fact I can try it with Docker raised my eyebrow so much it hurt
18:51:19 <boj> yeah, so no actual file system, or a concept of processes
18:51:46 <Guest78> no concept of processes, so no task scheduler, no preemption?
18:51:52 <n_blownapart> no concept of processes?
18:52:27 <ReinH> House was a demo operating system in Haskell but it is no longer developed.
18:52:30 <boj> right, afaik it's a self contained process that runs on a thin OS-like layer and runs on something like Xen
18:52:41 <ReinH> Ah, https://wiki.haskell.org/Applications_and_libraries/Operating_system#Standalone_operating_systems
18:52:44 <boj> so, not truly an OS
18:53:22 <n_blownapart> that's sort of like Docker isn't it? you isolate processes without a vm ?
18:53:36 <boj> i suppose you could say, less than docker
18:53:43 <Guest78> ReinH: House, that rings a bell... I think last time I tried to research on it I might have hit 404s but I will try again
18:54:34 <ReinH> There are a few mentioned at that link. I don't think any are still under development.
18:56:36 <Guest78> But mostly (and I acknowledge asking this here is a shot in the dark, but it's close) I was asking if anyone is aware of, to put it wonkily, an innovative approach to OS like functional programming is innovative to programming (as in, departs fundamentally from Von Neumann). As I type this, perhaps a forth-based OS would be some local optimum?
18:57:45 <boj> Guest78: not as far as i think you are suggesting, but NixOS may be worth looking at. still fundamentally a linux OS, but with some interesting properties
18:58:15 <Guest78> oh my god, I love nixOS, let me show you something I just contributed to
18:58:31 <boj> ah, well then. i have no more good answers :)
18:59:59 <Guest78> -> https://gitlab.com/brainrape/nixlab - I did (directed) this with a devops guy to make a 1-click development environment with your own gitlab in the cloud, ci/cd with your own workers, and the works. I used it for a haskell project (not included)
19:00:31 <boj> very cool
19:00:52 <Guest78> thanks :)
19:01:13 <Guest78> perhaps the answer is lisp genera or something, but lest I steer the topic too far away, I will stop here. Thanks for your time and good night!
19:01:30 <boj> yep, take care
19:01:57 <mandiblegrip> git s
19:02:50 <potica> hello guys i'm new to haskell, i want to implement a parser but i can't figure out how to "go forward" in the string without returning (MyType, String) with the remaining to parse
19:03:15 <potica> there gotta be a better way
19:04:15 <glguy> A better way to return the remaining string than returning it?
19:04:31 <d34df00d> potica: arguably it's not that bad: that's what ReadS does under the hood.
19:04:38 <d34df00d> Type `:info ReadS` in ghci.
19:05:09 <glguy> potica: Maybe you want to have the remaining string managed by a parser type like in megaparsec or ReadP in base?
19:05:16 <potica> yeah but it soooo clumberstone to use :(
19:05:24 <glguy> http://hackage.haskell.org/package/megaparsec
19:07:05 <Welkin> clumberstone, haha
19:07:36 <potica> i try to implement an XML parser for starters, is really parsing tag by tag and returning the remaining string the best way ?
19:08:24 <glguy> potica: Maybe you want to have the remaining string managed by a parser type like in megaparsec or ReadP in base?
19:09:18 <potica> oh my bad i thought you said ReadS like just the message just above, i'll look
19:10:04 <jle`> potica: returning the value and string is a good intuition, but the next step is to figure out how to compose them :)
19:10:28 <jle`> potica: for example, if you have a praser of A's, like String -> (A, String)
19:10:39 <jle`> potica: and a parser of B's, like String -> (B, String)
19:10:50 <jle`> can you write a function that *uses* those to write a parser of (A, B0's ?
19:11:15 <jle`> can you write a function that takes a parser of A's and returns a parser of [A] ?
19:11:24 <potica> haha that's exactly what made me think about it twice
19:11:29 <jle`> potica: this is the foundation of parser combinators
19:11:38 <jle`> the simple primitive parsers might be ugly to implement under the hood
19:11:48 <jle`> but the magic comes when you write "combinators" to manipulate parsers as first-class values
19:12:11 <mniip> d34df00d, there's gotta be a better way!
19:12:17 <mniip> hehe
19:12:28 <jle`> potica: in real life though we usually use a pre-made parser combinator library
19:12:32 <jle`> but if you want to implement one of your own, it can be fun
19:12:39 <jle`> it's ctually usually a midterm project for most haskell courses
19:12:46 <jle`> s/most/many
19:13:34 <potica> yeah i do it to learn about this twisted functional thinking :)
19:13:45 <mniip> :t StateT (maybe empty pure . uncons)
19:13:47 <lambdabot> Alternative m => StateT [a] m a
19:13:51 <mniip> there's your parser combinator library
19:17:40 <ReinH> A parser for things is a function from strings...
19:18:00 <potica> mniip: i dont understand
19:18:11 <ReinH> No one?
19:18:14 <mniip> potica, you're not really supposed to, at your level
19:18:40 <ReinH> ... to lists of pairs of things and strings.
19:19:13 <mniip> ReinH, a parser for things is a monadic monoid family transformed by the free monad transformer of a reader functor!
19:19:21 <ReinH> type Parser a = String -> [(a, String)]
19:19:50 <glguy> mniip: Do you have the 'm' to drop in there to get parsec's behavior?
19:20:04 <mniip> "monadic monoid family"
19:20:15 <mniip> you could use ListT IO for all I care
19:20:39 <ReinH> @mniip I'm sorry I think you misspelled StateT String [] a
19:20:39 <lambdabot> Unknown command, try @list
19:20:54 <mniip> ReinH, you must be new :P
19:20:55 <ReinH> Ugh I need to fix my bad habits from SLack
19:21:04 <ReinH> mniip: I must be.
19:21:37 <mniip> @let token = FreeT . pure . Free $ FreeT . pure . Pure
19:21:38 <lambdabot>  .L.hs:368:9: error:
19:21:38 <lambdabot>      Data constructor not in scope: FreeT :: f0 a0 -> c
19:21:38 <lambdabot>      |
19:21:47 <mniip> @let import Control.Monad.Trans.Free
19:21:50 <lambdabot>  Defined.
19:21:51 <mniip> @let token = FreeT . pure . Free $ FreeT . pure . Pure
19:21:54 <lambdabot>  Defined.
19:22:09 <mniip> @let parseString = runStateT . iterTM (StateT (maybe empty pure . uncons) >>=)
19:22:12 <lambdabot>  Defined.
19:22:13 <ReinH> :t token
19:22:15 <lambdabot> Applicative m => FreeT ((->) a) m a
19:22:37 <mniip> :t parseString
19:22:39 <lambdabot> (Monad m, Alternative m) => FreeT ((->) a1) m a2 -> [a1] -> m (a2, [a1])
19:25:27 <potica> i could something like a _where_ and then fst and snd but it's so ugly
19:26:38 <ReinH> If only there were some sort of machinery we could employ to make the ugliness go away
19:27:26 <ReinH> (See section 5 of http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf, and really the whole thing)
19:33:29 <mniip> ReinH, the problem with your approach is StateT (\s -> [("I am horrible", ())])
19:35:21 <ReinH> @unmtl StateT String [] a
19:35:21 <lambdabot> String -> [] (a, String)
19:35:29 <ReinH> I don't understand
19:35:37 <mniip> :t StateT (\s -> [("I am horrible", ())])
19:35:39 <lambdabot> StateT () [] [Char]
19:35:42 <mniip> oh er,
19:35:53 <mniip> I thought it went ssa not sas
19:35:55 <mniip> :t StateT (\s -> [((), "I am horrible")])
19:35:56 <lambdabot> StateT [Char] [] ()
19:36:03 <ReinH> It's literally just an encoding of Parser with StateT
19:36:06 <mniip> this inhabitant of your type is not a parser
19:37:17 <ReinH> So either you're wrong or you're right but Parse isn't a parser either
19:37:22 <ReinH> *Parser
19:37:50 <mniip> no like
19:38:48 <mniip> this is a valid embedding of attributive grammars into StateT,
19:38:55 <mniip> and you can write a right inverse
19:39:01 <mniip> but it's not an isomorphism
19:39:30 <mniip> (which inverse is right again?)
19:39:32 <ReinH> StateT String [] a is not isomorphic to String -> [(a, String)]?
19:40:01 <mniip> StateT String [] () is not isomorphic to the set of languages
19:40:14 <ReinH> Then neither is String -> [(a, String)]
19:40:21 <ReinH> Since they are isomorphic
19:40:29 <mniip> String -> [(a, String)] isn't either
19:40:41 <mniip> well duh, they are isomorphic because they're literally a newtype
19:40:44 <ReinH> So I don't see why you're singling out the StateT construction when it's just a different way to spell the standard seussian parser
19:41:13 <mniip> not singling out StateT
19:41:17 <mniip> but rather the construction in general
19:41:23 <ReinH> Ok
19:41:31 <ReinH> Carry on then
19:41:53 <mniip> like I said, there are inhabitants of this type that don't correspond to any language/attributive grammar
19:45:06 <mniip> (why is it unmtl if mtl is just the fundep library and all types are from transformers)
19:48:56 <ReinH> because mtl is shorter?
20:03:40 <siwica> Is somebody else using Emacs + Intero + Yas-Snippets? I am experiencing an annoying behaviour when expanding the `fun` snippet: the second line of a function definiton gets indented when beginning to type the type of the function int the first line.
20:03:58 <siwica> YASnippet that is
20:09:39 <Gurkenglas> Does some library provide an IxMonad instance for something like data C i j a = { runC :: (a -> j) -> i } so I can write http://lpaste.net/360955 ?
20:10:12 <Gurkenglas> (First by dutchie, second and third by me)
20:12:37 <Gurkenglas> (?cUnit = ?C . ($()))
20:13:48 <Gurkenglas> Um I think that's wrong and it's the following? ?cUnit x = ?C $ \c -> x $ c ()
20:15:19 <mniip> huh
20:15:22 <mniip> curious
20:17:03 <jle`> mniip: it's historical
20:17:14 <jle`> mniip: mtl was the original monad transformer library i believe
20:17:26 <jle`> before transformers became the de facto standard monad transformer library
20:18:17 <jle`> mtl first showed up on hackage in 2006 and transformers showed up in 2009
20:18:33 <jle`> for for that brief three year period, mtl was an actual monad transformer library
20:18:38 <jle`> s/for for/so for
20:19:02 <jle`> and names made sense
20:20:20 <jle`> so presumably @unmtl was written in a time when mtl was a monad transformer library
20:20:40 <jle`> maybe nowadays we can alias @untransformers
20:31:32 <Gurkenglas> How should I call "\i j a -> (a -> j) -> i" if I make a library out of it?
20:32:33 <jle`> left-pad
20:33:06 <jle`> Gurkenglas: also i don't understand what that means
20:33:16 <jle`> is that Haskell?
20:33:28 <Maxdamantus> Is it meant to be a type expression, or a value expression?
20:33:30 <jle`> is it a type level lambda maybe
20:33:46 <jle`> newtyoe Foo i j a = MkFoo ((a -> j) -> i)
20:33:50 <Gurkenglas> yep
20:34:16 <Gurkenglas> kk left-pad, there's probably a reason behind that
20:34:30 <jle`> hm, it's a Functor
20:34:36 <Maxdamantus> Maybe a JS/npm joke.
20:35:45 <jle`> it's a Profunctor
20:35:56 <Gurkenglas> "Leftpad" or "LeftPad"?
20:39:02 * hackage rank2classes 1.0.1 - standard type constructor class hierarchy, only with methods of rank 2 types  https://hackage.haskell.org/package/rank2classes-1.0.1 (MarioBlazevic)
20:39:07 <Gurkenglas> In emacs with intero: Did "stack new leftpad", went into src/Control/Monad/Leftpad.hs, got http://lpaste.net/7034380502056304640
20:40:26 <jle`> oh i was joking about left-pad, sorry, it is an npm reference
20:40:36 <jle`> but also stack new, did you go into the directory it made
20:41:06 <jle`> Gurkenglas: but also yes your type is  profunctor, so maybe check profunctors to see if it's already defined there
20:41:16 <jle`> there are a bunch of funky profunctors in that library
20:45:29 <ReinH> profunkytors
20:45:56 <jle`> play that profunky music
20:46:11 <Gurkenglas> Ah I'm supposed to look at the instance list of http://hackage.haskell.org/package/profunctors-5.2.1/docs/Data-Profunctor.html#t:Profunctor . Oh man I'm probably going to miss it as a specialization of one of the longer ones
20:46:19 <Gurkenglas> Maybe I should ask the author?
20:46:42 <Gurkenglas> If I find it I'll just be giving it orphan instances for indexed monad etc :I
20:47:36 <jle`> Gurkenglas: work asking
20:47:52 <Gurkenglas> *worth?
20:47:58 <jle`> yes sorry :)
20:49:45 <Gurkenglas> Its purpose is to take anything that looks like "do a <- b; c $ \a -> do ..." and squish it into one indexed do block
20:50:43 <jle`> yeah i can see it might be useful as an indexed monad
20:51:34 <Gurkenglas> Though is it cheating if I make it that general? Measures that become goals cease to be good measures, and if I can rewrite any rat's tail into one indentation level, I don't anymore know I've displayed understanding in removing it
20:52:48 <monochrom> That is deep philosophy I don't understand.
20:55:55 * hackage aeson-yak 0.1.1.3 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.1.3 (tejon)
20:59:57 * hackage wai-extra 3.0.21.0 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.21.0 (MichaelSnoyman)
21:04:27 <Gurkenglas> When I refactor code, I attempt to do the inverse of inlining. Then I don't have to spot an uninlined pattern in raw code, I just have to remember the reasoning I've already done about the uninlined name. More powerful tools are replaced by less powerful ones if they suffice. One heuristic is that if there's a rat's tail (nested expressions of form "do a <- b; c $ \a -> ..."), you're not done with worthwhile
21:04:28 <Gurkenglas> refactoring. That heuristic may stop working if I make a combinator that deals exactly with all rat's tails.
21:05:52 <MarcelineVQ> the so-called bahamut combinator
21:06:22 <Gurkenglas> Very good, thanks.
21:08:23 <Gurkenglas> Actually I picked up the term from https://codereview.stackexchange.com/a/182917 but I don't know if
21:08:31 <Gurkenglas> *but I'm not sure of it, damn you enter key
21:08:43 <monochrom> Oh heh bahamut.
21:09:07 <nek0> hi folks. does onyone here have experience with nanovg? I try to use it together with sdl2, but loaded images get always wrong colors.
21:09:11 <monochrom> Oh yeah when on WhatsApp I sometimes press the wrong enter key, too. :)
21:12:06 <glguy> Don't forget to simulate your AoC particles!
21:12:42 <LiaoTao> Speaking of AoC
21:13:06 <mniip> and done
21:13:14 <LiaoTao> Did you guys take a graph approach to day 11?
21:13:17 <LiaoTao> The hex grid
21:14:46 <monochrom> Yikes particles.
21:16:48 <Welkin> final fantasy summons have combinators?
21:17:57 <monochrom> Oh God Backus-inspired wizardry.
21:18:46 <monochrom> "The language of summons must be simple with useful primitives and general combining forms!"
21:18:59 * monochrom was reading Backus speech-paper, yes.
21:19:05 <Welkin> the summon animation must take at least 2 minutes
21:19:20 <Welkin> and have gratuitous panning shots
21:20:16 <Welkin> those summon animations make it feel so epic during a boss battle where you have barely been holding on for 40 minutes already
21:20:20 <Welkin> and this is your last ditch effort
21:25:00 <glguy> LiaoTao: What is a graph approach?
21:27:08 <LiaoTao> glguy: Considering each hexagon as a node and then building a graph from the input string
21:27:19 <LiaoTao> Then approaching the problem with traditional graph search algorithms
21:27:24 <lstdgtfp> I just wrote `return $ return`. I'm pretty sure that means I'm doing it wrong, but I'm not sure what I should be doing instead
21:28:04 <MarcelineVQ> lstdgtfp: no one could say based on only that
21:28:04 <glguy> LiaoTao: Oh, no. That sounds like it would make it much harder than it was
21:28:40 <LiaoTao> I didn't do that either for part 1, but running into issues with part 2 using the other approach
21:29:05 <LiaoTao> s/the other/my/
21:29:11 <monochrom> lstdgtfp: I know of one use case, but it involves STM.
21:29:15 <glguy> LiaoTao: What's the other approach?
21:29:26 <lstdgtfp> I'm turning a value of type `a` into one of type `Ether Error (IO a)`
21:29:30 <lstdgtfp> *Either
21:30:03 <monochrom> That may also be a reasonable use case, depending on the rest.
21:30:22 <lstdgtfp> Oh, ok.
21:30:34 <lstdgtfp> I tend to feel like I'm not doing the "right" thing in haskell 90% of the time
21:31:12 <LiaoTao> glguy: Haven't studied enough computer science to describe it accurately, but basically it's taking a parsing approach that builds a string of tokens and then cancels out certain sequences
21:31:30 <LiaoTao> It would seem the most natural approach, especially after the preceding problems
21:32:04 <glguy> I think you could possibly make that work, but it won't be easy
21:32:21 <glguy> Have you seen this? https://www.redblobgames.com/grids/hexagons/
21:32:26 <LiaoTao> It probably works, just not very fast or very space efficient
21:34:12 <LiaoTao> glguy: Well now I feel silly
21:34:14 <LiaoTao> Thanks
21:34:21 <n_blownapart> Hi one more question re: this paste. the (const False) used as the predicate; it acts separately as the predicate but requires the second argument id , and I can see how id is left unadulterated by it. but how does that work? its like a separate thing but is using id as its second arg. ?     https://ptpb.pw/1SeV
21:34:28 <LiaoTao> Pretty surprised the parsing approach worked, to be honest
21:34:56 <n_blownapart> don't know how to pose the question any better..
21:37:10 <n_blownapart> its like it crosses a blurry line
21:40:16 <geekosaur> I feel like by this point you should have at least started to understand what's going on
21:43:26 <geekosaur> do you understand how foldr works when folding over a list of functions? and how you need a function to replace [], so in many cases you provide the identity function? (the z in foldr f z xs)
21:44:25 <geekosaur> this is similar but in reverse because you are generating a list instead of  folding over one. if it's a list of functions, you need an initial (or final depending on which direction you are unfolding) function; the identity function is usually a good candidate
21:50:55 <Gurkenglas> @tell n_blownapart perhaps it helps to consider these two intermediates? http://lpaste.net/8968995383204118528
21:50:55 <lambdabot> Consider it noted.
21:51:31 * hackage ats-format 0.1.0.2 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.2 (vmchale)
21:58:34 <n_blownapart> geekosaur, sorry, so I guess its works like this : id x = x , which is consed, then we are left with t (t x), which is equivalent to f ( f x ) . please confirm, thanks
22:05:25 <n_blownapart> still, I'm genuinely confused, because how can id which corresponds to the head, be consed where we have ' h x : '    ?     If (const False) id would drop id (the value of x to be consed) I don't see how it works    https://ptpb.pw/1SeV
22:15:25 <aku> What are some good references to learn applicatives, functors and monads?
22:18:08 <boj> aku: are you looking for standard learning resources? like a book?
22:18:35 <aku> Yes, also any video series or tutorials?
22:19:10 <boj> hmm, nothing i would suggest in good faith
22:19:19 <boj> @where haskellbook
22:19:19 <lambdabot> http://haskellbook.com
22:19:31 <liste> https://wiki.haskell.org/Typeclassopedia is nice for reference
22:19:34 <boj> this is a good way to build up and learn, if you don't mind spending a little money
22:19:35 <Gurkenglas> n_blownapart, perhaps it helps to consider these two intermediates? http://lpaste.net/8968995383204118528
22:19:52 <MarcelineVQ> Gurkenglas: you missed him again
22:19:56 <Gurkenglas> :D
22:20:01 <MarcelineVQ> so he's not seen that twice now :X
22:20:09 <boj> aha
22:20:18 <MarcelineVQ> because he's not gonna figure out lamdbabto messages
22:20:22 <liste> doesn't lambdabot have some sort of memo feature? @tell ?
22:20:32 <MarcelineVQ> liste: it's a bit of a pain to read them imo
22:20:45 <MarcelineVQ> it's more of a message box than just some queued tells
22:20:46 <liste> also there's MemoServ
22:21:49 * hackage ats-format 0.1.0.3 - A source-code formatter for ATS  https://hackage.haskell.org/package/ats-format-0.1.0.3 (vmchale)
22:24:54 <LiaoTao> glguy: Well that was ridiculously easy
22:25:25 <LiaoTao> Who'd have thought reasonable coordinate systems are a good thing
22:30:42 <jle`> most of my time was spent on parsing lol
22:32:44 <brekekoax> does anyone know if https://iohk.io/ is a good place to work?
22:33:29 <aku> \quit
22:33:49 <aku> \QUIT
22:34:38 <liste> aku: try using / instead
22:34:50 <nshepper1> LiaoTao: I used a coordinate system where going n was (dx, dy) = (0, +2) and going ne was (+1, +1)
22:35:50 <rightfold> brekekoax: ask those whomst’d’ve worked there!
22:35:51 <nshepper1> pretty arbitrary but it worked
22:36:26 <nshepper1> in that the property ne + nw = n (and all its symmetries) held
22:37:22 <LiaoTao> Yeah
22:40:03 <brekekoax> rightfold, I just figured since IOHK's hiring for Haskell devs someone here might know something
22:40:54 <dmwit> I use a coordinate system where n is (0, 1) and ne is (√2, √2).
22:41:10 <dmwit> ne + nw is not n
22:41:32 <boj> brekekoax: not sure about their work environment, but their application process is fairly math intensive, if that helps
22:42:15 <nshepper1> these cube coordinates seem interesting
22:42:44 <dmwit> but you can go at an angle of pi/6, and then tau/3, and that is n
22:43:24 <dmwit> (oops, I said tau/3 when I meant 5pi/6)
22:43:29 <brekekoax> boj, what kinds of math? more algorithms or like category theory?
22:44:22 <boj> brekekoax: the work assignment i tried was to implement something in cloud haskell, however, the explanation was written in very math heavy syntax i couldn't parse (no math background here)
22:45:07 <boj> it was very challenging, and when i asked them for feedback they gave very detailed notes from their selection process
22:45:11 <MarcelineVQ> can't even understand the market wank, the application must be brutal
22:45:20 <MarcelineVQ> *marketing
22:46:36 <MarcelineVQ> This is the advertising Hank Scorpio would have
22:48:27 <brekekoax> MarcelineVQ: I'd rather work for Hank Scorpio writing Haskell then Flanders writing C++
22:48:38 <nshepper1> dmwit: by ne i mean going to the northeast hexagon, lol
22:49:15 <nshepper1> that would be (1/2, sqrt(3)) if you are saying you used cartesian coordinates on a grid of regular hexagons
22:49:37 <dmwit> I was trolling.
22:49:44 <dmwit> I apologize for my behavior. =P
22:49:58 <nshepper1> hah
22:50:07 <nshepper1> yeah, the (+1,+1)/(0,+2) systems means the hexagons are irregular but who cares :p
22:50:10 <Maxdamantus> nshepper1: what's the use in `ne + nw = n`? It seems like a kind of special operation.
22:50:25 <Maxdamantus> Out of that system, you don't get things like `ne + ne = ne`
22:51:27 <nshepper1> Maxdamantus: if you are in a hexagonal tiling and go to the northeast, and then 1 step northwest, that is the same as going north one step
22:52:09 <Maxdamantus> Oh, I see.
22:52:33 <liste> doesn't (+1,+1)/(0,+2) mean diamonds instead of hexagons?
22:52:37 <nshepper1> maybe I should write · instead of + for sequential composition
22:52:46 <liste> with hexagons you can only go 6 directions
22:52:56 <dmwit> liste: Depends on what you're allowed to observe, I guess.
22:53:05 <liste> with (+1,+1)/(0,+2) you can go 8 directions
22:53:20 <dmwit> liste: That's only two directions!
22:53:32 <liste> dmwit: :)
22:53:41 <dmwit> liste: That sounds like a joke, but I'm serious.
22:53:49 <dmwit> If you only want six directions, you only make six directions.
22:54:04 <dmwit> You don't *have* to include (say) (+2, 0) and (-2, 0) just because you included (0, +2).
22:54:05 <nshepper1> liste: (+2, 0) and (-2, 0) are banned by order of the king :)
22:56:33 <liste> dmwit: now that I think of it, both hex coordinates and the (+1,+1)/(0,+2) system results in an "interlaced" lattice like this https://gist.github.com/ilmoeuro/7111d1950ea2b5744dc8e83eacbb3efc
23:28:49 <Athas> Any idea why 'stack test' rebuilds my project instead of only the test suite?
23:36:20 <noobie49184> I would like to print the result of a try but am having trouble: import Control.Monad.Trans.Except import Control.Monad.Catch y=try (readFile "puppies") z=ExceptT y :t z :t lift . print z >>= lift . print .   What am I missing? I would be grateful for any help someone could provide. What am I "showing" if not the exception or string?
23:37:27 <noobie49184> Pastebin version for ghci: https://pastebin.com/Knp4CXd3
23:37:49 * hackage simplessh 0.2.0.6 - Simple wrapper around libssh2  https://hackage.haskell.org/package/simplessh-0.2.0.6 (thoferon)
23:38:56 <cocreature> noobie49184: what’s the error? I suspect you’ll have to add a type annotation to specify which exceptions you want to catch
23:45:18 <noobie49184> A new pastebin with annotation is here along with the error associated with show: https://pastebin.com/h7ZSm7wD
23:45:23 <noobie49184> Thank you for your help btw
23:45:56 <noobie49184> What I was expecting was the Exception being printed or the string if the file existed. I'm not sure what I'm showing then that does not have a show instance
23:47:24 <jle`> noobie49184: it looks like you're trying to show an ExceptT
23:48:24 <jle`> noobie49184: note that an `ExceptT e IO a` itself doesn't do any IO or raise any exceptions
23:48:32 <jle`> it's just describes an IO action
23:48:54 <jle`> that could potentially "error" with 'e' when executed
23:49:14 <jle`> just assembing an `ExceptT e IO a` does not actually execute any IO actions
23:50:12 <jle`> noobie49184: think of it like [IO a], like [getLine, return "hi", getLine].  Just having a value of type [IO a], or putting one together, does not execute any IO
23:50:42 <jle`> if i did x = [getLine, return "hi", getLine] :: [IO a], and i tried to print x (if there was an appropriate Show instance), that wouldn't actually cause any actions to happen
23:50:57 <jle`> just having a value of type 'IO a' is not the same as executing it
23:51:19 <noobie49184> What would cause the actions to happen then? I thought the readline statement itself would have done that. Is this where something like mapM would come in?
23:51:20 <cocreature> noobie49184: try "y <- try …; print (y :: Either SomeException String)"
23:51:22 <noobie49184> thank you btw
23:51:42 <jle`> noobie49184: in ghci, you can execute them by putting an IO action alone as a line
23:51:50 <cocreature> <- in ghci behaves similarly to <- in do blocks
23:51:52 <jle`> or using res <- myIOAction syntax
23:52:09 <jle`> noobie49184: so you could use runExceptT :: ExceptT e IO a -> IO (Either ea)
23:52:14 <jle`> noobie49184: to get an IO action that you can execute
23:52:28 <jle`> runExceptT itself does not execute IO actions
23:52:39 <jle`> but it gives you a value of type 'IO (Either e a)', which ghci can execute for you
23:53:46 <jle`> res <- runExceptT (z >>= lift . print)
23:53:59 <jle`> (z >>= lift . print) :: ExceptT IOException IO ()
23:54:11 <jle`> so runExceptT :: ExceptT IOException IO () -> IO (Either IOException ())
23:54:23 <jle`> so in that case, res :: Either IOException ()
23:54:26 <noobie49184> runExceptT on the z value did the trick. Thank you
23:54:51 <jle`> since z :: ExceptT IOException IO String, runExceptT z :: IO (Either IOException String)
23:55:02 <noobie49184> I tend to get thrown by that sort of thing. It's a similar idea assocoated with mapM and IO I suppose?
23:55:04 <jle`> which you can execute and bind using <- syntax, and the result would have type Either IOException String
23:55:58 <jle`> noobie49184: yeah, *creating* an 'IO a' itself executes nothing, doesn't execute the actions encoded in the IO a
23:56:20 <jle`> so if you do map :: (a -> IO b) -> [a] -> [IO b], you don't really execute any actions
23:56:49 <jle`> but if you did mapM :: (a -> IO b) -> [a] -> IO [b], then you have a perfectly good IO action (IO [b]) that you can give to ghci to executefor you, or assign to 'main', or use with other IO actions, etc.
23:58:18 <noobie49184> Thank you. This has really been helpful
23:58:38 <jle`> no problem!
