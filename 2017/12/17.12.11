00:02:26 <osa1> anyone know if I can use space in superrecord field names? something like `Record '["Foo Bar" := Int]`
00:02:47 <osa1> I'm not sure how to generate field value of this type
00:04:57 <osa1> ah, it turns out I don't have to use label syntax
00:08:18 <osa1> ugh syntax is awful though. `FldProxy @"Foo Bar" := 1`
00:17:00 <dminuoso> To an experienced haskeller, is this implementation obvious? l = (ReaderT .) . (. runReaderT) . flip (.)
00:17:42 <Rembane> dminuoso: I'm not experienced enough to say yes.
00:17:53 <Rembane> dminuoso: What's the type signature?
00:18:00 <dminuoso> l :: (r -> r) -> ReaderT r m a -> ReaderT r m a
00:18:41 <dminuoso> For a given: newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }
00:18:43 <Rembane> Together with the type signature it's obvious.
00:19:07 <osa1> dminuoso: given type sig I don't even need to look at the implementation but wihtout type sig it's awful
00:19:28 <dminuoso> osa1: Fair enough, Ill stick to pointful `l f = ReaderT . (. f) . runReaderT` then
00:19:35 <osa1> (also, that functions already exists: local)
00:19:56 <dminuoso> osa1: Yeah Im implementing monad transformers myself to gain intuition about them.
00:20:16 <osa1> I'd add one more parameter to that function
00:21:06 <dminuoso> Fair enough. Im just also practicing pointfree forms.
00:22:26 <dminuoso> osa1: I've done this style in most of my monad transformers whenever possible, e.g. fmap f = ReaderT . (fmap . fmap)  f . runReaderT
00:22:30 <osa1> I only use (.) if the expression is in `f . g . t ...` form. also, as a reader I hate to see flip and (.) combined.
00:22:53 <kahlil29> What's the best/easiest way to convert from Decimal to Scientific? Need it as Scientific for Aeson (JSON) encoding
00:25:05 <osa1> in this example instead of `(fmap . fmap) f` I'd do `fmap (fmap f)`
00:25:32 <dminuoso> osa1: Fair enough. To me (fmap . fmap) has become a rather obvious way since I learned some basics about SEDs
00:25:42 <osa1> what's SED?
00:25:44 <dminuoso> So it feels a lot more intuitive than fmap (fmap f)
00:25:50 <dminuoso> semantic editor combinators
00:25:54 <dminuoso> Sorry *SEC
00:26:13 <Rembane> I like (fmap . fmap ...)
00:26:36 <Rembane> For any number of fmap
00:26:42 <dminuoso> osa1: And in a lot of monad transformers this pattern makes a lot of sense when you compare it to their respective raw monad implementations
00:26:58 <dminuoso> osa1: Where you frequently have something like (fmap f) in the monad, but (fmap . fmap) f in the transformer
00:27:19 <osa1> fair enough. maybe I don't read this kind of code enough.
00:31:32 <osa1> implementing fmap2, fmap3 and using those instead of (fmap .) chains may also be a good idea
00:33:42 <dminuoso> osa1: Interesting, I've done the exact opposite wrt to liftAx/liftMx
00:34:00 <dminuoso> replacing their respective usages with f <$> a1 <*> a2 and so forth
00:35:12 <dminuoso> I even started to do use (.) . (.) in 2 places
00:35:32 <osa1> well if you're directly applying arguments then sure. if you keep `fmap . fmap . fmap` around (maybe pass it to functions etc.) I'd rather see `fmap3`
00:39:58 <dminuoso> Ill keep it in mind. Until now I've went with practicing explicit before I dive and start using "tricks"
00:40:11 <dminuoso> So that I dont have to think about what code means when I see it.
00:47:49 <Lokathor> http://lpaste.net/2475141295648014336 going well so far
01:30:43 <angerman> Finally got the stupid android screen recording to work, so here it is, haskell android demo app demo: https://youtu.be/r9dxLXl_Tb0; using the cross compilers I posted on hackage.mobilehaskell.org. 
01:32:16 <merijn> hmm, so do unboxed tuples only allow for binary tuples or can I do better?
01:33:37 <merijn> angerman: Doing god's work :) At this rate you're gonna have things working well before I finally get to mobile dev and I won't have to deal with trash languages :>
01:34:04 <angerman> lol.
01:34:48 <angerman> merijn: the hardest part is googleing/stackoverflowing how to use the native chrome.
01:35:11 <angerman> e.g. I had no idea how to show a list of images on android or even access that stupid gallery.
01:35:57 <angerman> I'm sure there are more certified people with a lot more android dev experience than I have. But hey, I can write enough chrome ontop of a haskell lib to produce a working prototype :D
01:36:12 <angerman> (I've essentially the same app for iOS as well)
01:36:13 <merijn> angerman: Yeah...that's exactly why I don't wanna have to do it myself :p
01:36:34 <merijn> OTOH, I'm trying to write Idris in C++ so maybe I'm sufficiently masochistics afterall...
01:36:35 <angerman> I don't think it's realistic to write the chrome in Haskell.
01:36:54 <angerman> On the desktop we (sadly) converge towards: hey, let's use a webcontainer.
01:37:33 <angerman> You can do the same on mobile, but (at least my experience has been) you end up "feeling" the difference between a webview and a native UI toolkit.
01:38:08 <angerman> Part of the lag you see in the screenrecording is due to the haskell library running the stitching operation on the main thread.
01:38:48 <angerman> the haskell library being rather naively written, and not aggressively optimized.
01:39:00 <angerman> but it's just a demo. So I'm ok with it :D
01:49:15 <mrkgnao> merijn: a "standards-compliant" reimplementation, or a fork of some sort?
01:52:31 <merijn> mrkgnao: I don't mean "implement an Idris compiler", I mean "writing dependently-typed code by horrifically abusing templates"
01:52:55 <merijn> And strongly regretting using C++ instead of Haskell :p
01:56:13 <quchen> I hope you’re getting paid for it at least
01:56:18 <osa1> Lokathor: nice MGS reference ;-)
01:57:25 <merijn> quchen: That I am, else I'd have pulled the trigger and switched to Haskell now :p
02:26:22 * hackage model 0.4.4 - Derive a model of a data type using Generics  https://hackage.haskell.org/package/model-0.4.4 (PasqualinoAssini)
02:30:25 <mrkgnao> merijn: phew
02:30:41 <mrkgnao> solidarity etc
02:31:48 <dminuoso> merijn: https://gist.github.com/dminuoso/9f1525981ec072de6169bfa43f6d165a
02:32:12 <dminuoso> mrkgnao: Was a wonderful excercise. Also rolled ContT (the revelation that it just is Cont was interesting), MaybeT..
02:33:08 <merijn> dminuoso: After the magic disappears everything seems a lot more obvious :)
02:33:26 <dminuoso> merijn: The really bizarre thing is.. I implemented all of them just following types. I didnt even grasp what WriterT was 
02:33:31 <dminuoso> And it just worked somehow..
02:34:02 <dminuoso> It's almost like implementing WriterT wrong is really hard.
02:34:07 <merijn> dminuoso: The nice thing about State(T) is that there's actually only a very small number (of rather obvious once you test) errors you can possible make while making it typecheck, so it's really hard to do things wrong :)
02:34:19 <merijn> Which is one of the reasons I picked it
02:34:31 <dminuoso> merijn: Im guessing the kind of errors would be any that could produce bottom?
02:34:48 <merijn> dminuoso: You can also forget to pass in the intermediate state to the next computation
02:35:15 <merijn> dminuoso: i.e. implement <*> and passing the initial state to both. But that should be obvious quick since the updates left of <*> suddenly stop happening
02:36:20 <dminuoso> merijn: This seeming inability to implement it incorrectly, that's basically parametricity right?
02:36:33 <merijn> It's a result of parametricity, yes
02:44:07 <dminuoso> merijn: Ah I see. Well the one thing that it's still not obvious is ReaderT. The data constructor is suspiciously Kleisli arrow shapwed.
02:44:47 <merijn> dminuoso: That's because they are Kleisli arrows :p
02:45:10 <merijn> "r -> m a" is a kleisli arrow if 'm' is a monad
02:45:34 <merijn> Readert is just "r -> a", so ReaderT generalises that to 'r -> m a' which is obviously a Kleisli arrow
02:45:59 <dminuoso> merijn: Which made me realized that every function is by definition a kleisli arrow (associated with the Identity monad)
02:46:48 <dminuoso> Rembane: ReaderT is meant for (Monad m) only, no?
02:46:51 <dminuoso> Err merijn.
02:47:22 <merijn> dminuoso: Yeah
02:47:52 <merijn> Although the kind of ReaderT doesn't match with Arrow/Category, so it's not really usable as Kleisli arrow in that sense
02:51:26 <merijn> Is there a quick and dirty timing function for "MonadIO m => m a -> m (Time, a)" somewhere?
02:51:41 <merijn> There's the timeit package, but that only works with IO
03:05:26 <mniip> hmm
03:05:33 <mniip> is it possible to come up with a funky gadt
03:05:42 <mniip> that would do something similar to an occurs check
03:06:01 <mniip> so that
03:06:42 <mniip> a recursive construction would have a decidably different type from a nonrecursive one
03:09:42 <mniip> so like
03:09:52 <mniip> if we have a type formula phi
03:10:02 <mniip> and a type family F
03:10:10 <mniip> introduction of the typing constraint phi ~ F phi
03:10:18 <mniip> should have a measurable effect on F phi
03:13:17 <LJK_> Hello! I was just wondering if there is something between `.=`, and `%=`, so if there is something at this lens I would like to modify it, otherwise simply put some def value.
03:15:41 <rightfold> There is always something at a lens
03:18:19 <LJK_> Yeah, but I have state with Map in it. So I could do it like this: `%= Map.insertWith ...` but I wonder if I could omit this `Map.insertWith` with some special operator
03:18:25 <Sornaensis> modify it if what
03:20:38 <Younder> Another wish list
03:23:42 <fakenullie> LJK_: there are functions on map
03:24:01 <fakenullie> Oh, omit insert
03:31:27 <hphuoc25> Anyone here familiar with postgresql-simple? Can help me take a look at http://lpaste.net/4601514706941771776?
03:32:20 <hphuoc25> What I'm doing is I have a list of input and I want to insert into a table values from that list which doesn't exist in that table yet. It's working but it doesn't look like I'm doing it the right way.
03:33:03 <cocreature> constructing query strings my manually concatenating bytestrings is not a good idea
03:34:03 <cocreature> hphuoc25: try passing "(Only (PGArray newValues))" and then only use a single question mark
03:34:51 <merijn> cocreature: But I feel so pro when I manually build queries from strings :(
03:35:29 <cocreature> merijn: I’d recommend finding some other way to make you feel pro :)
03:35:35 <hphuoc25> cocreature: nice. That's what I'm looking for
03:35:36 <merijn> cocreature: More importantly, I haven't found a single SQL library that supports SQLite and lets me write the queries I need...
03:35:53 <cocreature> merijn: sqlite-simple doesn’t let you write the queries you need?
03:37:07 <merijn> cocreature: Only if I use string concatenation to generate the queries I pass to their API
03:37:33 <cocreature> you sure seem to write weird queries :)
03:38:29 <merijn> cocreature: Variable number of inner joins of a table onto itself... :p
03:39:30 <merijn> I could probably change the code a bit to properly use parameter substitution on top of my string concats, but I honestly can't be arsed right now
03:40:05 <hphuoc25> cocreature: seems like postgresql-simple is substituting the values on its own and send the query to server. Is there anyway I can tell it to send the query to server as a named query and let the server sanitize input itself?
03:41:25 <cocreature> hphuoc25: I don’t think so
03:41:55 <cocreature> not sure if the API postgresql-simple uses even allows for that?
03:42:09 <merijn> cocreature: Watch this beauty ;) https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/Model.hs#L163-L200
03:43:39 <cocreature> merijn: gorgeous!
03:44:15 <merijn> cocreature: I could probably use the "proper" substitution for the where clause, but that's only using data from my database anyway
03:44:38 <merijn> So I can't really be arsed
03:44:55 <cocreature> fair enough :)
03:54:02 <carbolymer> merijn, interesting repo, what's this?
04:17:34 <muzzle> :t (.)
04:17:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:18:49 <Younder> Modus Ponens
04:20:37 <Younder> First order forward chain logic
04:20:57 <cocreature> modus ponens should be "(a -> b) -> a -> b"
04:22:04 <Younder> no (a -> b) ^ (b -> c) --> (a -> c)
04:22:35 <merijn> carbolymer: about 80% of my phd research :p
04:22:54 <cocreature> Younder: wikipedia tends to disagree https://en.wikipedia.org/wiki/Modus_ponens#Formal_notation
04:24:22 <Younder> I like to think of the exact equiv of the triangle inequality
04:25:59 <Younder> That would generalize into Bayesian statistics
04:26:10 <Younder> nice, yes
04:28:23 <Younder> (The triangle inequality, given points a,b,c the (a,b)+(a,c) <= (a,c))
04:28:45 <Younder> (The triangle inequality, given points a,b,c the (a,b)+(b,c) <= (a,c))
04:28:53 <Younder> sorry
04:31:59 <Younder>  I find profound truth are usually in the basic principles. If you understand then the rest follows. Thus I call myself an empiric.
04:37:53 * hackage hpack 0.21.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.21.0 (SimonHengel)
04:46:45 <vaibhavsagar> today's AoC was another 'replace foldl with scanl' problem
04:46:52 <nilg> How to build h x y z = g (f x y) (f y z) using function composition alone?
04:50:23 * hackage llvm-hs-pretty 0.1.0.0 - Pretty printer for LLVM IR.  https://hackage.haskell.org/package/llvm-hs-pretty-0.1.0.0 (sdiehl)
04:52:06 <fakenullie> @pl h x y z = g (f x y) (f y z)
04:52:06 <lambdabot> h = (`ap` f) . (((.) . g) .) . f
04:54:49 <fakenullie> nilg: not very good
04:55:33 <nilg> OMG what does $pl does???
04:55:39 <nilg> I mean $pl
04:55:47 <nilg> I mean @pl *sorry)
04:57:01 <merijn> nilg: Rewrite PointLess aka pointfree style
04:57:07 <nilg> nevermind I got it https://wiki.haskell.org/Lambdabot thank you
04:58:15 <geekosaur> unfortunately 'pointless' often turns out to be a bit of a mean-spirited but deliberate pun...
04:58:24 <geekosaur> and sometimes all too accurate
04:59:22 <vaibhavsagar> :t flip fix
04:59:24 <lambdabot> b -> ((b -> c) -> b -> c) -> c
04:59:32 <liste> @unpl (`a` f) . (((.) . g) .) . f
04:59:32 <lambdabot> (\ x -> a (\ x0 g1 x2 -> g (f x x0) (g1 x2)) f)
04:59:56 <vaibhavsagar> :t fix
04:59:57 <lambdabot> (a -> a) -> a
04:59:59 <nilg> :t ap
05:00:00 <lambdabot> Monad m => m (a -> b) -> m a -> m b
05:01:55 <nilg> I don't understand the use of `ap` in h = (`ap` f) . (((.) . g) .) . f
05:02:36 <fakenullie> Something to do with function monad
05:03:27 <Rembane> nilg: It's fmap for monads.
05:03:29 <Rembane> :t fmap
05:03:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:03:38 <Rembane> Hm... Almost true.
05:03:47 <Rembane> :t (<*>)
05:03:49 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:03:53 <geekosaur> ^
05:04:00 <Rembane> nilg: It's cool star-operator for monads.
05:04:08 <geekosaur> ap predates Applicative
05:04:42 <Rembane> One christmas I will wish for a prelude that isn't written in chronological order.
05:04:53 * hackage merkle-tree 0.1.0 - An implementation of a Merkle Tree and merkle tree proofs  https://hackage.haskell.org/package/merkle-tree-0.1.0 (sdiehl)
05:05:08 <geekosaur> there's always the one in the Report
05:05:19 <geekosaur> split into multiple files, even
05:09:56 <Rembane> Sounds dangerous.
05:11:52 * hackage pedersen-commitment 0.1.0 - An implementation of Pedersen commitment schemes  https://hackage.haskell.org/package/pedersen-commitment-0.1.0 (sdiehl)
05:16:33 --- mode: cherryh.freenode.net set +o ChanServ
05:20:13 <arne> why are some syntax things of haskell so weird.. like 
05:20:19 <arne> multiline things with :{ :}
05:20:25 <arne> thats not symmetrical at all
05:20:54 <liste> arne: it's not haskell syntax, it's only ghci
05:21:00 <arne> ah okay
05:21:11 <Psybur> So for two things to be isomorphic it just means that there is a morphism from a to b and one from b to a?
05:21:26 <lyxia> they must be inverses
05:21:59 <liste> arne: when you do multiline you should be putting it in a separate file instead of using ghci, so :{ :} isn't really a problem
05:22:15 <arne> i get it, yeah i would really like learning haskell
05:22:18 <Psybur> Either a Void and a are isomorphic right? Are they inverses?
05:22:18 <arne> but i struggle with syntax
05:22:20 <arne> it's so different
05:22:28 <arne> than anything else
05:22:57 <liste> arne: what part of it trips you most?
05:23:10 <Psybur> Or is Either a Void isometric to a but not the other way around
05:23:11 <arne> "variables" need to be small
05:23:17 <arne> while i think modules are big?
05:23:35 <liste> arne: types are upper case
05:23:36 <arne> thats especially weird when you have cbindings where constants are all caps
05:23:40 <arne> types, that's it, yes
05:23:47 <liste> arne: and constructors are upper case too
05:23:49 <liste> and modules
05:23:54 <Psybur> Wait isomorphism isnt one way so they both must be isometric right D:
05:24:06 <arne> i laughed hard at iNADDR_ANY
05:24:09 <arne> that's sso stupid
05:24:45 <arne> but maybe it's good that way, i don't know yet
05:25:14 <liste> though in Java, Python etc the convention is CamelCase for classes anyway, Haskell takes it one step further
05:25:43 <arne> it's convention not a must
05:25:57 <arne> or am i mistaking?
05:26:02 <liste> arne: yes, it's a convention
05:26:09 <arne> is it for haskell, too?
05:26:17 <arne> so types can be small?
05:26:18 <liste> arne: yes, it's a syntactic requirement for Haskell
05:26:26 <liste> so no
05:26:27 <arne> see.. that's what i mean, really odd
05:26:35 <liste> arne: it serves a purpose
05:26:38 <arne> but i see the reasoning.. yeah
05:26:56 <arne> but you can't get around using constants from other languages. imho
05:27:22 <arne> sure, you could prefix them, but i feel like there is a better solution to this
05:27:53 <liste> arne: well every top-level value is a constant in Haskell, so I think just making it all camelCase is the best solution
05:28:29 <arne> but iN_ADDR_ANY is not camelcase :D
05:28:31 <liste> I guess iNADDR_ANY is because INADDR_ANY is familiar to people
05:29:00 <frerich> arne: For what it's worth, if the _syntax_ of Haskell is so alien to you, I think you're up for a very exciting ride as soon as you get to the _semantics_ of Haskell. :-)
05:29:36 <arne> i can't be more excited about haskell than i already am but the syntax is stopping me everytime
05:29:54 <arne> and haskell projects seem to weird, too
05:29:58 <arne> be*
05:30:28 <arne> compared to the same thing in other languages
05:30:32 <Psybur> arne, whats weird about them? Is it the defaultMain thing in stack? heh
05:30:43 <arne> i can't really put it into words.. if you take ghcjs for example
05:30:55 <arne> they do this weird complilation progress, files are amzingly big
05:31:18 <arne> other projects like "opal" from ruby, just do source-to-source transpiling/compiling, and it works flawlessly
05:31:28 <arne> haskell on the other hand, claims to be perfect for parsing and other languages
05:31:35 <arne> but overhead is insane
05:31:49 <lyxia> Psybur: Either a Void is isomorphic to a if you discount bottoms
05:32:01 <lyxia> Psybur: "they must be inverses" refers to the morphisms, not the objects.
05:32:10 <Psybur> Oh ok thanks
05:32:26 <arne> haskell projects seldom feel like plug and play, that's what i mean i think
05:32:52 <lyxia> Psybur: \(Left a :: Either a Void) -> a   is inverse to  \a -> Left a
05:33:24 <Psybur> So if f a = b and g b = a, then (f . g) b = b and (g . f) a = a
05:33:35 <Psybur> Thats what you mean by inverses?
05:33:45 <liste> arne: wrt compiling to JS, making Haskell run on a JS VM is difficult because they're semantically very different - JS is strict, Haskell is lazy
05:34:00 <liste> arne: ruby is so similar to JS that it's easy
05:34:02 <Psybur> Or more simple f . g = id
05:35:07 <liste> arne: OTOH projects like Pandoc are very natural to write in Haskell
05:37:01 <Logio> I can vouch for that, having once made a Haskell script to convert png images to Java code.
05:37:23 <liste> Logio: did it do OCR?
05:37:47 <Psybur> Logio, pictures of text?
05:37:48 <Logio> no, it was part of a driver for a LEGO printer 
05:37:57 <liste> oh
05:38:52 <Logio> just binarized the image and composed the necessary LEJOS commands to be compiled and sent to the brick
05:39:24 <mniip> 1512999198 [16:33:18] <liste> arne: wrt compiling to JS, making Haskell run on a JS VM is difficult because they're semantically very different - JS is strict, Haskell is lazy
05:39:29 <mniip> that's fairly mild
05:39:36 <mniip> literally every single platform is stricy
05:39:41 <mniip> strict
05:40:25 <mniip> everything is very semantically different from haskell
05:40:30 <mniip> ghc has that much figured out
05:41:54 <mniip> the real issues include the insane amount of complexity in the GHC RTS and haskell's code dependency on them
05:42:42 <[exa]> "insane amount of complexity in the GHC RTS"  <-- this.
05:42:51 <mniip> and then, maybe, performance implications of maintaining an STG heap in a managed language
05:43:43 <mniip> and, well, performance implications in general
05:43:59 <arne> why does the rts need to be so complex
05:44:07 <mniip> it doesn't
05:44:12 <mniip> it just is
05:44:17 <arne> lol
05:44:26 <mniip> well alright
05:44:33 <arne> why is that, nobody liked C code?
05:44:33 <mniip> the answer is because that's faster
05:44:40 <arne> i see, so it's optimization
05:44:47 <lyxia> Psybur: f . g = id, g . f = id, yes.   ("if f a = b and g b = a" is too strong a precondition)
05:44:52 <merijn> The RTS honestly isn't all that complex
05:45:05 <mniip> merijn, the dependency on it though
05:45:12 <arne> > Support for Software Transactional Memory.
05:45:14 <lambdabot>  <hint>:1:43: error:
05:45:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
05:45:21 <merijn> There's no reason you couldn't (re)implement the RTS in a language like Java
05:45:28 <arne> doesn't modern cpu support hardware transactional memory already?
05:45:41 <merijn> arne: Those are far more limited and different from Haskell STM
05:45:50 <arne> oh, sad to hear
05:45:56 <arne> how can you be limited in that regard?
05:45:57 <mniip> yeah let's see your CPU process a *retry* in a middle of a monadic traversal or something
05:46:27 <merijn> arne: think of CPU STM as being "generalised atomics so you don't pingpong cache lines all the time"
05:46:32 <arne> monad stuff is still voodoo to me, didn't write a lot of haskell yet
05:46:39 <merijn> arne: Haskell's STM is a far higher level
05:46:57 <merijn> arne: And haskell can make far stronger assumptions about what happens in  transaction
05:47:08 <arne> okay, i can't see how you can benefit from that, but still
05:47:14 <arne> i should just try, i guess
05:47:28 <merijn> The main reason the RTS stays C is: We already have one in C, it works and performs really, so why rewrite it?
05:47:52 <arne> uhm, if i rewrote it in.. let's say
05:47:52 <arne> ruby?
05:47:57 <merijn> mniip: I mean, the C RTS is also written in a strict language, so that's not really an issue
05:47:59 <arne> could i compile to ruby?
05:48:07 <arne> i mean.. doesn't haskell get compiled to llvm and to x86?
05:48:12 <merijn> arne: Sure, performance would probably suck, but you can
05:48:20 <arne> ? but haskell isn't bytecode
05:48:21 <arne> im confused
05:48:22 <merijn> arne: Compiling via llvm is not the default
05:48:44 <merijn> arne: What does being bytecode matter?
05:48:54 <mniip> merijn, that was re to what
05:48:58 <arne> uhm.. if i have x86 haskell code
05:49:00 <arne> and ruby RTS
05:49:08 <arne> how would i tell that RTS to talk to my x86 code.
05:49:15 <arne> because that's how that diagram looks
05:49:17 <merijn> arne: You'd have to compile the haskell to Ruby, not x86
05:49:24 <mniip> the easiest is probably ffi
05:49:27 <merijn> arne: Alternatively, export the Ruby via a C FFI
05:49:30 <mniip> hs_init,
05:49:31 <mniip> etc
05:49:42 <merijn> arne: No one says you HAVE to compile haskell to x86
05:49:46 <mniip> oh yea, actual easiest would be export from ruby
05:49:50 <merijn> You can compile it to whatever you want
05:50:12 <arne> like compiling to C and then to any platform?
05:50:27 <merijn> arne: Assuming your C is portable to other platforms, yes
05:50:28 <arne> or llvm
05:53:20 <arne> but back to topic
05:53:32 <arne> @guy who created ":{" ":}"
05:53:32 <lambdabot> Maybe you meant: run ghc bug
05:53:34 <arne> who does that :D
05:54:19 <mniip> all commands begin with :
05:54:25 <arne> shit that makes sense
05:54:37 <mniip> it was probably easiest that way
05:54:45 <arne> yeah i understand now
05:54:46 <mniip> otoh I've seen the specific code
05:54:53 <mniip> not sure I'd call that easy
05:58:40 <arne> where would i find the ghc code?
05:58:46 <arne> i mean rts
05:59:17 <arne> oh.. im stupid, sorry
05:59:32 <merijn> arne: In the GHC repo
05:59:43 <arne> yah i was searching in ghcjs code, not so clever
06:00:03 <cocreature> depends on which rts you want. ghcjs has a javascript implementation of the rts
06:32:20 <Bish> does haskell's fork really fork?
06:33:37 <merijn> Bish: You mean forkIO?
06:33:47 <Bish> no, i am reading warp code right now
06:33:53 <Bish> i mean fork, fork i think
06:34:08 <Bish> oh, it does define it.
06:52:23 * hackage haskell-src-exts 1.20.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.20.1 (mpickering)
06:52:46 <sepakorayl> Hello guys, how can I write isElemTypeOf correctly ? https://gist.github.com/liarokapisv/7eb9a42dbec0eee26e0ad9c95645125e
07:02:55 <jle`> sepakorayl: what's your issue?
07:06:25 <s4ke> hey guys. i was wondering about the par monad
07:06:41 <s4ke> whether it's possible to define a "looping" computation with it
07:06:58 <lyxia> in what sense?
07:07:12 <s4ke> meaning something like a torus/ring structure
07:07:27 <lyxia> what
07:07:28 <sepakorayl> jle`: It does not compile, I get unification issues.
07:07:29 <s4ke> i already have a "working" variant with the par monad 
07:07:45 <s4ke> sec
07:08:22 <mniip> you mean tying the knot
07:08:29 <mniip> (also what is the par monad)
07:09:03 <s4ke> Control.Monad.Par
07:09:15 <lyxia> https://hackage.haskell.org/package/monad-par-0.3.4.8/docs/Control-Monad-Par.html
07:09:24 <s4ke> thx
07:10:05 <s4ke> https://github.com/s4ke/Parrows/blob/master/Definition/src/main/Parrows/Skeletons/Topology.hs (careful using Arrow notation)
07:10:21 <jle`> sepakorayl: what are the errors
07:10:43 <s4ke> take a look at the torus skeleton
07:10:53 * hackage attomail 0.1.0.1 - Minimal mail delivery agent (MDA) for local mail with maildir support  https://hackage.haskell.org/package/attomail-0.1.0.1 (phlummox)
07:11:52 <lyxia> s4ke: btw the link to your paper in the README leads nowhere
07:12:00 <s4ke> the specific things are: distributedEvalN (used for the Eden backend), sharedEvalN (used for Par Monad and regular parallel)
07:12:06 <s4ke> lyxia: yeah... meaning to fix that
07:12:08 <s4ke> thanks
07:12:38 <s4ke> distributedEvalN only does parallel evaluation with Eden, sharedEvalN only for ParMonad and regular parallel Haskell using strategies
07:12:47 <s4ke> the thing is that that's ugly af
07:13:24 <lyxia> why
07:13:51 <s4ke> the problem now is that as soon as i do the same parallel evaluation with Par Monad inside the loop it breaks with <<loop>>
07:14:01 <s4ke> lyxia: why it's ugly?
07:14:29 <lyxia> yes
07:14:31 <s4ke> i mean it's a sane workaround, true, but i would like to have a somewhat unified interface. 
07:14:45 <s4ke> With Eden we have RemoteData, some kind of distributed Future
07:14:48 <s4ke> or IVar 
07:15:05 <s4ke> i want to simulate behaviour with the other backends as closely as possible
07:15:31 <s4ke> for the Par Monad and Multicore I haven't found something similar
07:15:54 <lyxia> where did you implement that arrow interface for Par
07:16:00 <s4ke> or i don't know whether such a construct would even work properly
07:16:12 <sepakorayl> jle`: https://gist.github.com/liarokapisv/7eb9a42dbec0eee26e0ad9c95645125e
07:17:07 <s4ke> lyxia: moment. but there the Future implementation is just a dummy atm. I fiddled around with forking away the parallel evaluation and returning a MVar for a while, but that didnt go far
07:17:08 <s4ke> sec
07:17:30 <s4ke> ... slow internet ... https://github.com/s4ke/Parrows/blob/master/ParMonad/src/main/Parrows/ParMonad.hs
07:18:14 <s4ke> the definition of ArrowParallel is :
07:18:54 <s4ke> i gues i am faster typing it here... class Arrow arr => ArrowParallel arr a b conf where  parEvalN :: conf -> [arr a b] -> arr [a] [b]
07:21:04 <s4ke> so far i have read that Par Monad's scheduler is not able to "stop" evaluating a blocked infinite list
07:23:03 <lyxia> Par doesn't return until it has finished evaluating, which doesn't happen on infinite structures
07:23:31 <lyxia> if you mean to evaluate all of them of course
07:24:19 <lyxia> and then the combination of NFData and ArrowLoop has a similar problem, although I can't read arrow code well enough to tell whether that's the issue with your torus
07:24:45 <mniip> hey jle`
07:25:04 <s4ke> lyxia: it has? that would explain things
07:25:39 <s4ke> lyxia: the torus works just fine with Eden (which does the evaluation to normal form differently)
07:26:25 <s4ke> (it's a port from edenskel)
07:26:31 <lyxia> ah there is a sharedEvalN conf (repeat _) in torus
07:26:58 <s4ke> the sharedEvalN is the workaround atm
07:27:36 <s4ke> what i want to do is be able remove sharedEvalN and only use the distributedEvalN which is basically something along the lines of parEvalN 
07:28:26 <s4ke> lyxia: what is the problem with ArrowLoop and NFData?
07:31:21 <lyxia> s4ke: If you loop a function that forces all of its result: evaluating the result usually forces the input, but loop makes that input the result itself. Then you have a <<loop>>
07:33:37 <s4ke> lyxia: okay. that sounds about right. then it seems like the Eden backend works slightly different in the parEvalN function
07:33:43 <s4ke> thanks for the help i think this helps
07:34:23 * hackage zm 0.3.2 - Language independent, reproducible, absolute types  https://hackage.haskell.org/package/zm-0.3.2 (PasqualinoAssini)
07:36:34 <phz_> I just updated a resolver in a stack.yaml
07:36:36 <phz_> and I get this
07:36:37 <phz_> AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
07:36:40 <phz_> wtf
07:38:21 <hoon> I'm new and dipping my toes into haskell. Looking for a feedback on a little toy code: http://lpaste.net/360694
07:40:55 <s4ke> lyxia: i think i will have to take a look into things like yielding after each evaluation step
07:41:16 <phadej> phz_: upgrade your `stack` to 1.6.1
07:42:09 <lyxia> hoon: sequence_ $ liftM a b  is  traverse_ a b
07:42:16 <phz_> phadej: thanks for the tips
07:43:58 <lyxia> hoon: and fmap is the new liftM
07:44:40 <hoon> lyxia: with my imports, I don't find a traverse_, do I need to add a particular module
07:44:53 * hackage git 0.2.1 - Git operations in haskell  https://hackage.haskell.org/package/git-0.2.1 (VincentHanquez)
07:44:58 <phadej> it's in Data.Foldable (traverse_)
07:45:16 <hoon> phadej: thank you!
07:45:19 <phadej> np
07:45:42 <lyxia> hoon: your code looks good overall
07:46:10 <hoon> lyxia: "fmap is the new liftM" meaning...everywhere I see a "liftM" I should use "fmap"? ...in general?
07:46:23 <hoon> lyxia: thanks for the feedback
07:49:23 <phadej> hoon: yes, with recent GHC liftM -> fmap is generally safe
07:49:47 <phadej> operational semantics might change, but I have trouble to come with (even controversial) example where it matters
07:49:56 <hoon> interesting
07:50:11 <hoon> I realise that Monad implies Functor
07:50:22 <phadej> (it didn't >3 years ago)
07:50:32 <hoon> but isn't it more "generic" to use the Monad version
07:50:45 <kadoban> hoon: Less generic
07:50:48 <hoon> yeah
07:50:51 <phadej> hoon: no, other way around, it's more generic to use Functor version :)
07:50:58 <hoon> got it
07:51:31 <mniip> hmmm, maybe it is possible with higher ranked types...
07:51:32 <hoon> yeah, so, aim for the generic case rather than the specific case
07:52:17 <hoon> I realize in this particular example it doesn't make much difference, but for modules and stuff...better to do the Functor version because it's more generically applied
07:52:58 <hoon> any other gripes about my "design" -- exception handling is a bit nebulous for me right now
07:53:13 <hoon> it works here, but any recommended reading?
07:54:17 <siwica> Where can I find the "unchecked rules" for specific typeclasses?
07:57:31 <lyxia> siwica: where they are defined
07:58:57 <siwica> Yes... I think the operations should adhere to some rules that exist by convention but are not checked
07:59:06 <siwica> Where are those defined?
08:00:13 <cement> most of those "rules" are called "laws" in the modules  they're defined in
08:01:15 <lyxia> siwica: I meant you can find them where the typeclasses are defined.
08:01:54 <lyxia> if they're not there either there aren't any known laws or the author is waiting for someone to make a patch.
08:02:28 <sbrg> god lens is dense to digest
08:02:31 <sbrg> ugh
08:03:13 <cocreature> sbrg: you can’t digest lens, you have to wait for lens to digest you
08:03:21 <hoon> haha
08:03:51 <sbrg> it's already digesting my patience
08:03:53 <sbrg> :(
08:04:21 <sbrg> every time I decide "i should just get used to lens", I end up wasting all my time on grokking lens instead of doing the project I'm using it for until I just get tired of it and give up.
08:05:04 <cocreature> for me picking up bits and pieces on the side rather than deliberately learning it has worked out quite well
08:05:19 <tdammers> eh, lens is one of those libraries where you're better off starting with just a few useful recipes and extend your knowledge from there, rather than trying to actually understand the implementation
08:05:52 <sbrg> i
08:05:58 <tdammers> much of the weirdness comes from the whole van Laarhoven business, representing lenses as functions over some functor instead of getter/setter pairs
08:06:06 <sbrg> I'm definitely not trying to understand the entire implementation. I'm trying to pick up pieces as I need them for a project.
08:06:15 <tdammers> right
08:06:26 <tdammers> IMO, a good starting point is the operator cheat sheet
08:06:35 <tdammers> https://github.com/ekmett/lens/wiki/Operators
08:06:38 <sbrg> and when you're faced with a question like "what is the proper lens for this situation", the question is almost impossible to answer on your own without some decent understand of all the types and how they compose
08:06:49 <tdammers> right
08:07:20 <sbrg> like right now, I would like to update a part of a map that is part of my state in the State monad
08:07:25 <tdammers> then again, even just getters, setters, Lens, and the operators from the cheat sheet already make you pretty dangerous
08:08:14 <cocreature> sbrg: sounds like you want "at" or "ix"
08:09:11 <sbrg> yeah, I wanted `at`, but I also wanted `?~` instead of `.~` (or just use Just)
08:09:22 <shapr> I got a bunch of use out of spending an hour learning how to use lens, and repeat next time I want do more stuff
08:09:24 <sbrg> but the point is that determining that from the errors or documentation is pretty difficult
08:09:31 <tdammers> even if you just go lensToMap %= Map.update key newVal -- or sth
08:10:11 <tdammers> but I agree that the errors are almost of clojurian degrees of bafflingness
08:10:26 <heath> someone shared this function with me today, and now i'm stuck thinking about recursion
08:10:29 <heath> add a b | b == 0 = a | b > 0 = add (a+1) (b-1) | b < 0 = add (a-1) (b+1)
08:11:34 <tdammers> heath: oh, but that's simple - the base case is "b is 0", in which case a holds the sum; otherwise, it moves one unit from a to b or from b to a, in order to make b smaller
08:12:16 <heath> tdammers: i'm more curious if there's a pattern here :)
08:15:54 <exio4> tdammers: ironically, the implementation is quite simple :p 
08:17:00 <tdammers> heath: yes, there is - base case + recursive case(s)
08:17:34 <mniip> I wrote a function fairly similar to that today...
08:17:52 <mniip> opt (x, y, z) | x * y > 0 = opt (x - signum x, y - signum x, z - signum x) | y * z > 0 = opt (x - signum y, y - signum y, z - signum y) | z * x > 0 = opt (x - signum z, y - signum z, z - signum z); opt w = w
08:23:07 <opqdonut> mniip: what's that for?
08:23:32 <mniip> aoc
08:23:35 <opqdonut> ah
08:23:39 <opqdonut> felt contrived
08:23:52 <opqdonut> haven't had time for the last 3 days of aoc yet
08:25:23 * hackage leancheck 0.7.0 - Cholesterol-free property-based testing  https://hackage.haskell.org/package/leancheck-0.7.0 (rudymatela)
08:33:34 <mniip> is it possible to force-construct an infinite type with type families?
08:34:10 <mniip> I mean, circumvent the occurs check
08:35:25 <exio4> mniip: the typical way to do it is with a newtype 
08:35:38 <mniip> wrong kind
08:35:45 <mniip> (not *)
08:36:06 <exio4> maybe with DataKinds? I :p 
08:36:11 <exio4> I've got no idea
08:36:33 <danza> i wish there were more entries here http://hackage.haskell.org/packages/tag/distributed-systems
08:36:53 <danza> anybody knows interesting libraries that haven't been tagged?
08:38:58 <platz> for a monomorphic data type with several fields, whats the nicest way to do a maximum over all the fields?  one way is to define something like toList (MyData a b c) = [a, b, c]
08:39:52 <lyxia> Make it polymorphic and derive Foldable?
08:39:55 <ezyang> following that line of thought to its logical end, you end up with something like syb 
08:40:25 <s4ke> lyxia: i have given up on that problem. so far the skeleton works and i portable. the internas can be refined in a follow up paper... thanks anyways
08:40:59 <lyxia> platz: np
08:41:14 <lyxia> s4ke: np
08:41:38 <s4ke> and because you told me so. i will update the link in the readme :D
08:43:18 <mniip> hmm
08:43:21 <mniip> that's p nice
08:43:36 <lyxia> s4ke: yes please! I'd like to read it!
08:44:14 <s4ke> lyxia: please not that some stuff is not finished yet. also: some stuff is about to be changed and some things are a bit wrong in the Arrows chapter. working on fixing that
08:44:23 <s4ke> s/not/note
08:44:31 <s4ke> and note that it's quite long... :D
08:44:59 <lyxia> Ok :)
08:45:32 <s4ke> link should point to an actual file now :)
08:47:11 <mniip> haaaa!
08:47:21 <mniip> dided it
08:48:03 <rblaze> arc pull
08:48:09 <rblaze> oops
08:49:43 <mniip> check this out
08:52:19 <s4ke> flixbus internet is awful
08:52:21 <s4ke> -.-
08:52:26 <lyxia> s4ke: thanks
08:53:48 <mniip> hmm there's still sharp edges...
08:54:11 <mniip> @letlpaste 2071858014175887360
08:54:12 <lambdabot>  .L.hs:305:9: error:
08:54:12 <lambdabot>      Ambiguous occurrence ‘Contains’
08:54:13 <lambdabot>      It could refer to either ‘Lens.Contains’,
08:54:43 <mniip> @letlpaste 8273121766839156736
08:54:44 <lambdabot>  .L.hs:325:17: error:
08:54:44 <lambdabot>      Ambiguous occurrence ‘Rec’
08:54:44 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.Rec’,
08:54:48 <mniip> dammit
08:55:10 <s4ke> lyxia: cool that you are interested :)
08:55:53 <mniip> @letlpaste 7929319882586324992
08:55:56 <lambdabot>  Defined.
08:56:06 <mniip> :t Cell (Cell Pure)
08:56:07 <lambdabot> Recursive 'False n '['S (CloneN n), 'S ('S (CloneN (CloneN n)))]
08:56:14 <mniip> :t let x = Cell (Cell x) in x
08:56:15 <lambdabot> error:
08:56:15 <lambdabot>     • Reduction stack overflow; size = 201
08:56:15 <lambdabot>       When simplifying the following type: CloneL s0
08:56:21 <mniip> :t let x = Cell x in x
08:56:22 <lambdabot> (('S ('S ('S t1)) : CloneL t2) ~ t2, 'S (CloneN t1) ~ t1) => Recursive 'True ('S ('S ('S t1))) ('S ('S ('S t1)) : 'S ('S ('S t1)) : 'S ('S ('S t1)) : t2)
08:56:30 <mniip> see it can detect when it's recursive!
08:56:52 <mniip> Recursive 'True vs Recursive 'False
08:59:50 <barcabuona> hey i use `ghci main.hs`but i can't access variables inside main (for debugging). how can i fix this?
09:01:42 <[exa]> barcabuona: like, inside the 'main' function?
09:02:19 <barcabuona> yes
09:03:16 <[exa]> I guess they don't exist yet (because function main was not run)
09:03:22 <dfeuer> @arr
09:03:22 <lambdabot> Ahoy mateys
09:03:52 <[exa]> lol
09:04:07 <jle`> mniip: what's up?
09:04:46 <[exa]> barcabuona: anyway, ghci is not a debugger per se, but you can perfectly run main 'by parts' in it
09:05:08 <barcabuona> also is readFile lazy?
09:05:30 <cocreature> yes
09:05:37 <cocreature> at least the one in "base"
09:06:09 <barcabuona> actually i have run the main function and i still can't access the variables. but they are declared inside main. i can't do this in ghci?
09:06:34 <AndreasK> Maybe if you set a breakpoint
09:07:37 <cocreature> Haskell has lexical scoping, it doesn’t make sense for variables defined in main to be accessible outside
09:10:42 <AndreasK> It makes sense for a debugger.
09:11:17 <AndreasK> Though not in the general case 
09:11:19 <cocreature> for a debugger it makes sense to have them available while you’re _inside_ "main", i.e., what you were referring to by setting a breakpoint
09:12:47 <barcabuona> nah doesn't seem to workd
09:13:23 * hackage viewprof 0.0.0.12 - Text-based interactive GHC .prof viewer  https://hackage.haskell.org/package/viewprof-0.0.0.12 (MitsutoshiAoe)
09:14:59 <barcabuona> any ideas?
09:15:27 <barcabuona> because i wanna actually load those values and try to hack on it a little and test new code, which i then add to the program
09:17:23 * hackage ghc-prof 1.4.0.4 - Library for parsing GHC time and allocation profiling reports  https://hackage.haskell.org/package/ghc-prof-1.4.0.4 (MitsutoshiAoe)
09:17:59 <AndreasK> barcabuona: Worst case you can run the statements in the main function one by one
09:21:53 * hackage influxdb 1.2.2.2 - Haskell client library for InfluxDB  https://hackage.haskell.org/package/influxdb-1.2.2.2 (MitsutoshiAoe)
09:24:08 <glguy> barcabuona: You can set a breakpoint ``:break main`` and then run main with ``:trace main`` and :step through it, :list shows where you are and the names will be made available as long as things are stopped at the right point
09:28:19 <mniip> jle`, that
09:29:02 <jle`> @tell sepakorayl you need to pattern match on Refl
09:29:02 <lambdabot> Consider it noted.
09:29:23 <mniip> hmm
09:29:27 <mniip> it breaks on Cell . Cell
09:31:27 <jle`> mniip: about force constructing an infinite type with type families?
09:31:49 <mniip> jle`, I'm trying to devise a datatype that can detect recursion via types
09:31:53 * hackage attomail 0.1.0.2 - Minimal mail delivery agent (MDA) for local mail with maildir support  https://hackage.haskell.org/package/attomail-0.1.0.2 (phlummox)
09:31:54 <mniip> http://lpaste.net/7929319882586324992
09:31:58 <mniip> :t Pure
09:32:00 <lambdabot> Recursive 'False n '[]
09:32:02 <mniip> :t Cell
09:32:03 <lambdabot> KnownBool (Repetitive' ns '[]) => Recursive r ('S (CloneN n)) ns -> Recursive (Repetitive' ns '[]) n ('S (CloneN n) : CloneL ns)
09:33:55 <jle`> detect recursive data types/codata/recursion at the value level?
09:34:14 <mniip> well really only looking for syntactic inclusion
09:34:24 <mniip> if you have  foo = ... foo ..
09:34:53 * hackage lifted-async 0.9.3.2 - Run lifted IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/lifted-async-0.9.3.2 (MitsutoshiAoe)
09:35:35 <mniip> think parser grammar dsls
09:35:45 <mniip> would be nice if they could just detect mutual recursion by type infrerence
09:36:33 <jle`> that would be nice
09:36:42 <mniip> hmmm
09:36:51 <jle`> i wonder if you can abuse this to do some primitive totality checking
09:36:51 <mniip> I wonder if I can...
09:37:23 <jle`> s/totality/termination
09:38:35 <jle`> hm
09:39:26 <jle`> if you had data Curry :: (j -> k -> Type) -> (j,k) -> Type; Curry :: f a b -> Curry f '(a, b)
09:39:34 <jle`> oh sorry wrong window
09:39:58 <mniip> this tyfam
09:40:03 <mniip> type family Cut' (xs :: [k]) (ys :: [k]) :: [k] where
09:40:03 <mniip> 	Cut' '[] ys = '[]
09:40:04 <mniip> 	Cut' (x ': xs) ys = If (ContainsL x ys) '[x] (x ': Cut' xs (x ': ys))
09:40:10 <mniip> I wonder if it can actually tie the knot...
09:40:15 <mniip> doesn't sound like it
09:40:16 <mniip> oh
09:40:16 <mniip> !
09:40:33 <mniip> if we factor x ': in the second equation
09:40:40 <mniip> then it's sufficiently non-strict
09:40:53 * hackage sensu-run 0.4.0.3 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.4.0.3 (MitsutoshiAoe)
09:41:26 <mniip> yuo
09:42:27 * hackage spreadsheet 0.1.3.7 - Read and write spreadsheets from and to CSV files in a lazy way  https://hackage.haskell.org/package/spreadsheet-0.1.3.7 (HenningThielemann)
09:43:25 <kuwze> What does this error mean?: AesonException "Error in $.packages.cassava.constraints.flags['bytestring--lt-0_10_4']: Invalid flag name: \"bytestring--lt-0_10_4\""
09:43:37 <kuwze> when I grep bytestring in the dir I don't find any occurences
09:43:45 <kuwze> also that happens when I run stack init
09:47:25 <mniip> huh
09:47:30 <mniip> a bug in the GHC pretty printer
09:47:50 <mniip> If (Repetitive' (Cut' ns '[]) '[n]) () :: Constraint (n ~ 'S n')
09:47:58 <mniip> that '() :: Constraint' should be parenthesised
09:48:47 <mniip> okay wow
09:48:59 <mniip> @undefine
09:48:59 <lambdabot> Undefined.
09:49:38 <lyxia> kuwze: how did you get that error
09:49:46 <mniip> this is hell of a type
09:50:10 <mniip> @letlpaste 952307829933342720
09:50:12 <lambdabot>  Defined.
09:50:33 <mniip> :t Cell (Cell Pure)
09:50:34 <lambdabot> (KnownBool (If (ContainsL ('S n) '[n]) (ContainsL ('S n) '[n]) 'False), If (If (ContainsL ('S n) '[n]) (ContainsL ('S n) '[n]) 'False) () :: Constraint (n ~ 'S n')) => Recursive (If (ContainsL ('S n)
09:50:34 <lambdabot>  '[n]) (ContainsL ('S n) '[n]) 'False) n' '[n, 'S n]
09:50:50 <mniip> I apologize in advance
09:50:52 <mniip> :t let x = Cell (Cell x) in x
09:50:53 <lambdabot> (Cut' (If (ContainsL n1 '[n2]) '[] (n2 : If (ContainsL n2 '[n1, n2]) '[] (Cut' (If (ContainsL n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))) '[n1, n2, n1] ~ t, KnownBool (
09:50:53 <lambdabot> If (ContainsL n2 '[n1]) (ContainsL n2 '[n1]) (If (ContainsL n1 '[n2, n1]) (ContainsL n1 '[n2, n1]) (Repetitive' (If (ContainsL n1 '[n2]) '[] (n2 : If (ContainsL n2 '[n1, n2]) '[] (Cut' (If (ContainsL
09:50:53 <lambdabot> n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))) '[n1, n2, n1]))), KnownBool (If (ContainsL n1 '[n2]) (ContainsL n1 '[n2]) (If (ContainsL n2 '[n1, n2]) (ContainsL n2 '[n1, n2]
09:50:53 <lambdabot> ) (Repetitive' (If (ContainsL n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))), If (If (ContainsL n2 '[n1]) (ContainsL n2 '[n1]) (If (ContainsL n1 '[n2, n1]) (ContainsL n1 '[
09:50:53 <lambdabot> n2, n1]) (Repetitive' (If (ContainsL n1 '[n2]) '[] (n2 : If (ContainsL n2 '[n1, n2]) '[] (Cut' (If (ContainsL n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))) '[n1, n2, n1])))
09:50:55 <lambdabot> [5 @more lines]
09:52:11 <mniip> hmm this is wrong
09:52:14 <lyxia> O.O
09:52:18 <mniip> this context doesn't reduce
09:52:24 <mniip> it's in fact self-referential
09:53:09 <kuwze> lyxia: trying stack init in this project https://github.com/btmura/b1
09:53:25 <cocreature> kuwze: upgrade stack
09:54:51 <mniip> but how can it not be
09:55:30 <kuwze> I tried to upgrade it and got this error:
09:55:30 <kuwze> WARNING: The "stack" executable found on the PATH environment variable is /usr/local/bin/stack, and not the version that was just installed.
09:55:46 <kuwze> I thought I locally installed it... I guess not
09:57:22 <reactormonk> kuwze, IIRC it installs somewhere in your homedir
09:58:21 <kuwze> reactormonk: it does say that it is locally installed to /home/kuwze/.local/bin/stack
09:58:33 <reactormonk> Then add that to your PATH
10:18:09 <mniip> where's edwardk
10:21:48 <kuwze> is there an easy way to save the stack output? I am trying ~/.local/bin/stack init > output.txt but output.txt doesn't contain anything
10:23:03 <jle`> try redirecting stderr
10:23:07 <kadoban> kuwze: I would imagine it's going to stderr. Try  stack init 2> output.txt
10:24:12 <kuwze> kadoban: thank you, that works
10:26:51 <fakenullie> 2>&1 > output.txt
10:27:48 <mniip> fakenullie, hahaha no
10:27:51 <mniip> rookie mistake
10:27:57 <mniip> > output.txt 2>&1
10:27:59 <lambdabot>  error:
10:27:59 <lambdabot>      • Variable not in scope: txt :: Integer -> a0 -> Result
10:27:59 <lambdabot>      • Perhaps you meant ‘text’ (imported from Text.PrettyPrint.HughesPJ)error:
10:30:20 <jle`> what's that bot that runs unix/bash
10:30:24 <fakenullie> mniip: right
10:31:59 <mniip> yahb can do
10:32:05 <mniip> but a very limited number of utils
10:32:14 <mniip> %! echo hi
10:32:14 <yahb> mniip: hi
10:33:16 <fakenullie> %! yes
10:33:16 <yahb> fakenullie: bash: line 1: yes: command not found
10:33:53 <mniip> just the coreutils
10:34:27 <mniip> even gcc is just a stub that can only print library names so that ghci doens't go crazy
10:35:10 <Lokathor> classic problem
10:35:19 <Lokathor> I got a ping, but my scrollback doesn't show it
10:35:20 <Lokathor> :(
10:36:03 <cocreature> Lokathor: 10:55 <osa1> Lokathor: nice MGS reference ;-)
10:36:16 <Lokathor> ha ha!
10:36:27 <Lokathor> if my bot had been completed and running it could have told me that
10:42:50 <yen> How do I tackle thinking about mutable global variables?
10:43:13 <Lokathor> Data.IORef, Data.MVar
10:43:18 <yen> I'm creating a library that accepts functions and calls them based on certain criteria, and I think I should use the state monad, but I--
10:43:24 <yen> Aren't those looked down upon?
10:43:51 <Lokathor> some people do but those people already look down on the very concept of a global mutable variable
10:44:31 <yen> I'd like to know if there are alternatives thhat work
10:44:49 <Lokathor> well, how global is "global"
10:44:58 <cocreature> they’re also not global on their own. that is usually done with an additional unsafePerformIO
10:45:13 <Lokathor> also true
10:45:14 <yen> yeah i've heard of that 'hack'
10:45:15 <doyougnu> yen: this article may be of use: https://www.fpcomplete.com/blog/2017/06/readert-design-pattern
10:45:45 <yen> http://lpaste.net/3145225424401858560
10:45:48 <yen> Here is what I have so far
10:45:54 <yen> and yes thank you, doyougnu I will read this now
10:46:53 <yen> basically I associate functions with an event in an event bus, or the list. then when i fire, I loop through all the events, and for each function that is linked to the event, I call that function.
10:48:15 <kadoban> Sounding a little FRP-ish
10:48:26 <kadoban> Not really sure I'm getting the correct meaning there though.
10:48:27 <yen> FRP?
10:49:14 <kadoban> functional reactive programming, for example the reflex package and a few others.
10:49:56 <yen> Maybe not, but this is just an event bus
10:50:07 <yen> I've written java counterparts, would that help you understand what I want?
10:50:59 <Lokathor> yen, as you have it here the whole event bus happens outside IO. which is fine, but you'll need to hop back to IO to get more events I think
10:51:41 <yen> Association and Dissassociation can occur outside of IO, firing should occur with IO however
10:51:52 <yen> I want it to be along the lines of (fire bus TestEvent)
10:52:16 <Lokathor> well then State on its own is not what you want
10:52:17 <yen> and every event that I had associated with TestEvent would be called. 
10:52:18 <yen> function*
10:52:21 <Lokathor> StateT might be what you want
10:52:47 <yen> difference being?
10:52:58 <cocreature> I would probably move this to IO, since I’m not sure what an event bus outside of IO is even supposed to do and then make something like a "newEventBus" which internally creates an IORef/MVar/whatever and returns associate and disaocciate functions that operate on that IORef
10:53:19 <cocreature> that way you don’t have a global variable and you can thereby have multiple event busses but you still don’t have to pass the bus around everywhere
10:53:32 <Lokathor> yen, StateT adds statefulness on top of some other base monad (IO in this case), State is a base monad, and its evaluation doesn't allow IO at all
10:53:45 <Lokathor> StateT is for StateTransformer
10:53:58 <yen> How can function execution be IO?
10:54:16 <Lokathor> just use the IO type
10:54:18 <yen> I'm just adding functions to a list, is it because the list can vary between executions of fire?
10:54:21 <yen> o
10:54:40 <Lokathor> well hold on, you said sometimes you add functions and sometimes you need to check IO for events
10:55:06 <yen> I never check IO for events, sorry if that was misunderstood.
10:55:06 <Lokathor> "checking IO for events" is the part that means you need to go out to IO at some point in this whole deal.
10:55:10 <Lokathor> oh!
10:55:14 <Lokathor> ha, well okay then
10:55:17 <yen> I just fire them, so I call them in other places
10:55:38 <yen> Im basically interfacing with another program, so instead of directly calling my code in the function, I 'hook' into it using an event.
10:55:43 <Lokathor> then you could use State, evaluate your whole list, and then return that out of the computation and then send that to whoever executes them
10:56:06 <yen> So what I have in the lpaste is on the right track?
10:56:44 <cocreature> I’m not sure how firing events outside of IO is supposed to do anything useful
10:56:52 <yen> It's hooking functions.
10:57:00 <yen> I'm leaving class atm, will be back later.
10:57:19 <cocreature> and "Event -> ()" also doesn’t contain any interesting functions
11:06:36 <Lokathor> osa1, fun fact: I added the foxdie feature because Ctrl+C wasn't working to kill the program in the VS Code terminal for whatever reason, so I just added remote kill
11:12:30 <crucify_me> hi this predicate takes an x and returns a Bool. why wouldn't it work? error: 'Couldn't match expected type'a -> Bool' with actual type 'Bool'. I realize the predicate resolves to a Bool so I'm a bit foggy on this .http://lpaste.net/360703
11:13:22 <crucify_me> sorry I wrote that mod incorrectly ^
11:13:23 <jle`> crucify_me: what do you think (3 mod x == 0) does
11:14:49 <crucify_me> jle`, thanks one moment
11:15:19 <crucify_me> http://lpaste.net/360703
11:15:35 <crucify_me> I put it in prefix notation
11:15:36 <sbrg> crucify_me: you need to introduce x as a variable before using it
11:15:48 <sbrg> > all (\x -> mod x 3 == 0) [3,6,9,12,15]
11:15:50 <lambdabot>  True
11:16:04 <crucify_me> thanks one moment ....
11:16:08 <jle`> lambdabot agrees with you sbrg 
11:16:12 <edwardk> mniip: sleeping off flying sydney-boston
11:16:20 <ertes> crucify_me: are you giving GHCi extra flags?  like -fdefer-type-errors?
11:16:32 <sbrg> > all ((== 0) . (`mod` 3)) [3,6,9,12,15] -- alternatively, crucify_me, though it's less readable
11:16:34 <lambdabot>  True
11:16:39 <sbrg> but just in case you wanted a pointfree sol
11:17:28 <ertes> crucify_me: because GHC 7.10 had a nasty "feature" where it would turn unknown variables into typed holes, so instead of a proper "not in scope" error you would get a really bizarre type error
11:18:09 <ertes> luckily this feature was quickly made optional and disabled by default for GHC 8
11:18:35 <crucify_me> hmm, I'm in GHC 8.2 I think
11:18:54 <ertes> ok, then this doesn't apply to you…  have you defined x earlier in your GHCi session?
11:19:34 <mniip> edwardk, we once had a discussion on grammar DSLs
11:19:42 <crucify_me> but I can only think of this in terms of what the predicate resolves to . isn't the predicate expecting an x from the definition , line 3 ?
11:19:53 <mniip> and came to the conclusion that they all suffer from the observable recursion issue
11:20:11 <crucify_me> sorry I cannot follow this analysis..
11:20:13 <mniip> you have to either break the laws and observe it, or mark it explicitly, or simply not care about it with a lazy LL
11:20:13 <jle`> crucify_me: the predicate is a function, a value of type (Int -> Bool)
11:20:18 <jle`> crucify_me: so you have to define a function somehow
11:20:21 <jle`> one way to do it is to use a lambda
11:20:27 <ertes> crucify_me: x is a parameter name…  you use it in the definition to refer to the parameter…  its name is not visible outside of the definition
11:20:44 <jle`> divBy3 x = x `mod` 3 == 0
11:20:53 <jle`> all divBy3 [3,5,1,2,4]
11:21:13 <mniip> edwardk, so I thought why not spice it up with some type families to let type inference observe the recursion and mark it for you
11:21:57 <ertes> crucify_me: but again, you should have gotten a "not in scope" error there…  answer this question, please: have you defined 'x' earlier in your GHCi session?  have you written something like "x = …" or "let x = …"?
11:22:00 <crucify_me> ok. because yeah you can't just do 'alll True [3,6,9,12] ' it gets the same error
11:22:07 <mniip> edwardk, and I almost got it to work
11:22:12 <jle`> crucify_me: yes, look at the type of alll
11:22:17 <jle`> crucify_me: and look at the type of True
11:22:20 <jle`> True :: Bool
11:22:35 <jle`> but all expects an (a -> Bool), 'a' being the type of whatever is in the list
11:22:40 <crucify_me> ertes well, not in this session.
11:22:50 <crucify_me> but is it lingering?
11:23:14 <ertes> crucify_me: no, definitions made in the REPL disappear when you quit, or when you :reload
11:23:23 * hackage HTTP 4000.3.9 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.9 (GaneshSittampalam)
11:23:26 <mniip> :t Cell Pure
11:23:26 <edwardk> mniip: "almost"?
11:23:27 <lambdabot> Recursive 'False n' '['S n']
11:23:31 <mniip> :t let x = Cell x in x
11:23:32 <lambdabot> Recursive 'True n '[n, n, n]
11:23:44 <aberrant> how do I import a module from the subdirectory of my current dir?
11:24:07 <crucify_me> right jle` yeah this is basic. the x in (mod x 3 == 0) is not recognized
11:24:07 <mniip> I'm having a bit of an issue with de-recursing the constraints in a way that they don't grow exponentially
11:24:09 <mniip> see e.g
11:24:12 <ertes> aberrant: modules are only imported from a selection of import paths
11:24:13 <mniip> :t let x = Cell (Cell x) in x
11:24:15 <lambdabot> (Cut' (If (ContainsL n1 '[n2]) '[] (n2 : If (ContainsL n2 '[n1, n2]) '[] (Cut' (If (ContainsL n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))) '[n1, n2, n1] ~ t, KnownBool (
11:24:15 <lambdabot> If (ContainsL n2 '[n1]) (ContainsL n2 '[n1]) (If (ContainsL n1 '[n2, n1]) (ContainsL n1 '[n2, n1]) (Repetitive' (If (ContainsL n1 '[n2]) '[] (n2 : If (ContainsL n2 '[n1, n2]) '[] (Cut' (If (ContainsL
11:24:15 <lambdabot> n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))) '[n1, n2, n1]))), KnownBool (If (ContainsL n1 '[n2]) (ContainsL n1 '[n2]) (If (ContainsL n2 '[n1, n2]) (ContainsL n2 '[n1, n2]
11:24:15 <lambdabot> ) (Repetitive' (If (ContainsL n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))), If (If (ContainsL n2 '[n1]) (ContainsL n2 '[n1]) (If (ContainsL n1 '[n2, n1]) (ContainsL n1 '[
11:24:15 <lambdabot> n2, n1]) (Repetitive' (If (ContainsL n1 '[n2]) '[] (n2 : If (ContainsL n2 '[n1, n2]) '[] (Cut' (If (ContainsL n2 '[n1]) '[] (n1 : If (ContainsL n1 '[n2, n1]) '[] t)) '[n2, n1, n2]))) '[n1, n2, n1])))
11:24:17 <lambdabot> [5 @more lines]
11:24:21 <edwardk> ahahahaha
11:24:21 <aberrant> ertes: where is this set?
11:24:26 <jle`> crucify_me: the fundamental idea is that (mod x 3 == 0) is a Bool, even if x was recognized
11:24:33 <jle`> even if x was found, (mod x 3 == 0) is a Bool
11:24:38 <ertes> aberrant: usually you shouldn't worry about it and let cabal handle it
11:24:51 <ertes> aberrant: i couldn't even tell you which GHC flag it is out of my head
11:24:53 <aberrant> ertes: hm, ok. It's not working.
11:25:01 <crucify_me> so barring a full lambda expression in the predicate spot, is there a solution ?
11:25:02 <jle`> even if you did have an 'x' in scope, (mod x 3 == 0) is Bool, but alll expects an (a -> Bool)
11:25:07 <jle`> crucify_me: i gave one earlier
11:25:08 <crucify_me> jle`,  ^
11:25:18 <jle`> all you need to give alll is a function, a value of type (Int -> Bool)
11:25:18 <ertes> aberrant: you should always use absolute module paths in your imports
11:25:26 <ertes> aberrant: GHC will find relative imports properly
11:25:28 <aberrant> I have "monad-challenges" as a subdirectory of my devel directory, and I've done a "stack install" in the "monad-challenges" directory
11:25:29 <crucify_me> sorry there are many cooks in the pot here. I've been in my editor
11:25:32 <jle`> crucify_me: there are many ways to make functions in Haskell
11:25:40 <jle`> one way is to define it/declare it
11:25:45 <jle`> divBy3 x = x `mod` 3 == 0
11:25:50 <jle`> divBy3 :: Int -> Bool
11:25:54 <aberrant> but "import MCPrelude" isn't finding it.
11:25:56 <ertes> aberrant: like if you import X.Y2.Z from X.Y1.Z, it will locate the module properly
11:25:56 <jle`> so you can do `alll divBy3 [1,4,2,3,2]`
11:26:09 <mniip> edwardk, see the problem is, I have to simultaneously tell the inner datum what tag to assume, and check whether the list of seen tags is repetitive,
11:26:12 <aberrant> "Failed to load interface for ‘MCPrelude’"
11:26:14 <jle`> alll can take any value of the right type, i doesn't matter what expression or syntactical tool was used to make it
11:26:21 <crucify_me> cool jle` either that or define it in place with a lambda
11:26:21 <mniip> edwardk, and the inner datum's tag depends on whether the tags are repetitive
11:26:32 <jle`> there are also some other sugar you can use :)
11:26:38 <jle`> like operator sections
11:26:46 <crucify_me> sections?
11:26:47 <mniip> if I could...
11:26:47 <ertes> aberrant: what's the name of the module you're importing from?
11:26:49 <mniip> introduce assumptions
11:26:56 <kadoban> aberrant: isn't finding what exactly? 'stack install' is not for installing libraries. If it's a library, you should depend on it in your cabal file.
11:26:57 <jle`> all ((== 0) . (`mod` 3)) [3,5,6,2,3]
11:27:05 <crucify_me> this chat is moving at breakneck speed
11:27:08 <aberrant> ertes: "MCPrelud"
11:27:10 <mniip> assuming (a ~ X) does (b ~ Y)
11:27:13 <aberrant> er, "MCPrelude"
11:27:16 <jle`> the point is that in Haskell, there are many ways of making functions
11:27:20 <mniip> but ghc constarint solver doesn't work like that
11:27:23 <aberrant> kadoban: I don't have a cabal file.
11:27:26 <ertes> aberrant: you're importing MCPrelude from MCPrelude?
11:27:27 <jle`> "is there another way to write a function?" is something that will never end :)
11:27:30 <aberrant> no
11:27:39 <jle`> haskell has many syntactic constructs that allow you to make functions
11:27:41 <aberrant> I'm importing MCPrelude from my "module Set1"
11:27:57 <crucify_me> jle`, yeah, this is bloody hard
11:27:58 <ertes> aberrant: is MCPrelude in a separate package or in yours?
11:28:12 <aberrant> ertes: It's in a subdirectory of my development environment.
11:28:17 <aberrant> ertes: I cloned it from github
11:28:31 <aberrant> and did a "stack init" and "stack install" on it
11:28:34 <mniip> :w
11:28:35 <kadoban> aberrant: You should probably have one.
11:28:36 <mniip> oops
11:28:52 <jle`> crucify_me: i guess what i'm saying is, try not to imagine *all* the ways to do something
11:28:53 <aberrant> if I put my code inside the subdirectory it works.
11:28:59 <aberrant> but I'd rather keep it separate.
11:29:11 <jle`> crucify_me: it's not something that's super useful to talk about
11:29:13 <mniip> edwardk, my current code looks like this http://lpaste.net/360707
11:29:14 <ertes> aberrant: if you're in Set1 and import MCPrelude, generally MCPrelude.hs should be in the same directory as Set1.hs
11:29:21 <aberrant> ertes: right.
11:29:28 <aberrant> ertes: how do I tell it it's in a subdirectory?
11:29:33 <jle`> crucify_me: just know that you have a few useful ways of doing it :)  you just pick the one that is more natural in the moment
11:29:47 <edwardk> i'm not awake enough to read that yet =P
11:29:51 <mniip> ah, err, CloneL is a remnant of the older undecidable version
11:29:54 <edwardk> will take a look after i sleep off the flight
11:30:06 <mniip> okay!
11:30:07 <kadoban> aberrant: Okay, so how exactly are you running whatever you're running, which is giving you the error where it can't find that module? What command are you doing?
11:30:31 <ertes> aberrant: first let's see if you *should* do that:  you have a cabal file with up to one "library" section and arbitrarily many "executable" sections, perhaps a "test-suite" section and a "benchmark" section
11:30:37 <aberrant> kadoban: I've created a "set1.hs" in a directory. Inside that directory I've cloned "monad-challenges" which has a "MCPrelude.hs" in it.
11:30:58 <aberrant> I want to "import MCPrelude"
11:31:04 <ertes> aberrant: if MCPrelude is in the same section as Set1, then it should live in the same directory
11:31:15 <aberrant> I don't know what a section is.
11:31:24 <aberrant> I don't have a cabal file.
11:31:25 <ertes> aberrant: just what i told you above
11:31:44 <aberrant> I just want to write some test code to solve the monad challenges.
11:31:59 <aberrant> I guess I can just copy "MCPrelude.hs" into my current directory.
11:32:03 <ertes> aberrant: i see…  well, you could just add the monad-challenges subdirectory to the search path
11:32:16 <aberrant> where is the search path specified?
11:32:19 <ertes> aberrant: it's probably -i or -I or something like that
11:32:33 <aberrant> ah. I'm running inside vscode. That will make things complicated.
11:32:40 <aberrant> ok, I'll just copy the file
11:32:45 <kadoban> aberrant: That wasn't really what I asked, though it is important information. Which repo did you clone for monad-challenges? https://github.com/mightybyte/monad-challenges this one?
11:32:50 <ertes> heh, yeah…  copying is probably easiest
11:32:55 <aberrant> kadoban: yes
11:33:15 <mniip> oooh
11:33:18 <mniip> it might as well be impossible
11:33:23 <aberrant> kadoban: sorry, I was trying to answer ertes' questions and overlooked yours.
11:33:42 <kadoban> No worries
11:33:45 <ertes> aberrant: if this is just for one-off experimentation, just copy it
11:33:52 <aberrant> ertes: it is.
11:33:55 <ertes> no need to make things complicated
11:34:11 <ertes> or learn how to tell vscode about the extra search path
11:34:18 <kadoban> Ya, copying will work fine enough then if it's just for messing around.
11:34:32 <aberrant> "cp monad-challenges/src/MCPrelude.hs ."
11:34:50 <ertes> you might have to copy the whole thing
11:35:04 <ertes> (or just write your module inside monad-challenges/src
11:35:08 <aberrant> oh.
11:35:09 <aberrant> I see
11:35:09 <crucify_me> jle`, good call thanks
11:35:42 <aberrant> yeah, that isn't working
11:35:51 <aberrant> maybe I just develop inside the existing src directory
11:35:58 <ertes> aberrant: you could create monad-challenges/src/Aberrant/Blah.hs
11:36:05 <aberrant> that sort of stinks though since I want to be able to push this to my own repo.
11:36:22 <ertes> aberrant: that gives you the benefit that you can run 'stack init' from within 'monad-challenges' and have all dependencies ready to go
11:36:49 <aberrant> ok
11:36:55 <barcabuona> anybody use printf? it won't print Integer
11:37:00 <aberrant> thanks. I'll figure this out. It's too bad you can't just import relative dependencies.
11:37:05 <barcabuona> also coming from rust compiler messages suck so much...
11:37:20 <ertes> aberrant: well, it looks like monad-challenges is designed to be used as a library
11:37:29 <kadoban> rust does error messages particularly well, so that can be a high bar to hit, yeah.
11:37:34 <aberrant> ertes: so what's the right way to install it?
11:37:35 <tdammers> barcabuona: try clojure if you think Haskell error messages are bad
11:37:35 <cocreature> barcabuona: you’ll have provide more information if you’d like help
11:37:37 <ertes> aberrant: the normal approach is to start a cabal project and just depend on monad-challenges
11:37:49 <cocreature> “won’t print Integer” without a code sample is not sufficient
11:37:54 <ertes> aberrant: well, i don't know how to do that with stack
11:37:54 <kadoban> GHC's message are improving in format in recent GHCs at least.
11:38:35 <kadoban> aberrant: Well, you can, but you have to set that up. You'd need a cabal file, and you'd need to put a small bit in the stack.yaml file to tell it to use monad-challenges as an extra-dep
11:38:37 <ertes> aberrant: the cabal-install approach is to just clone monad-challenges and add it as a source to your own project's sandbox…  with stack you probably do something very similar
11:39:05 <kadoban> And then you just depend on that library in the cabal file (in the build depends section or whatever).
11:39:17 <tdammers> yes, with stack you'd add your clone's git repo to the extra-dependencies list in stack.yaml
11:39:28 <aberrant> ok, I have a stack.yaml now that I've done "stack init" in the toplevel directory.
11:39:49 <aberrant> it has "- monad-challenges" in it
11:40:32 <aberrant> I'll be back in a bit. sorry.
11:40:41 <ertes> aberrant: BTW, in general you should *not* have other packages as subdirectories of your own
11:40:44 <lyxia> mniip: the types become somewhat more manageable if you don't use a generic If.
11:40:51 <kadoban> That doesn't sound super like what you probably want, but it's not too far off.
11:41:15 <mniip> lyxia, still cyclic dependency
11:41:24 <mniip> if there wasn't it would all reduce away
11:41:25 <kadoban> packages as subdirectories is fine in stack, that's a pretty common thing to do. You just have to tell stack wtf they are
11:41:36 <codeshot> slackman, The @ syntax used in the examples of lens-generic might have been this somehow: https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
11:42:23 <lyxia> mniip: what's the type you want at the end
11:42:28 <ertes> kadoban: it'll probably just work regardless of tooling, but i think this is kind of a layer violation
11:42:30 <barcabuona> ah it's saying he wants me to cast [1..] to something
11:42:43 <barcabuona> otherwise he won't print an element w/ "%d"
11:42:51 <barcabuona> how can i cast it?
11:43:09 <barcabuona> (next haskell report, better compiler errors)
11:43:52 <kadoban> ertes: I think it just depends how tightly tied this dependency is to the thing they're working on. Which ... yeah it sounds like it's not tied super tightly, so there's likely a better way to refer to it (like via git).
11:44:06 <kadoban> If that's what you meant
11:44:50 <ertes> kadoban: i specifically mean a cabal project as a subdirectory of another cabal project…  of course there is (almost) nothing wrong with having multiple cabal projects inside of a single git repo
11:45:24 <mniip> lyxia, that's a complicated question
11:45:32 <mniip> this is a XYZWUV problem
11:46:06 <kadoban> ertes: I'm not 100% sure I'm getting the problem. Is it just that it's weird to cart around a library with the code you're writing you mean? I wouldn't disagree with that in many cases for sure.
11:46:15 <barcabuona> > print "%d" 1
11:46:17 <lambdabot>  error:
11:46:17 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
11:46:17 <lambdabot>                    with actual type ‘IO ()’
11:46:26 <barcabuona> > printf "%d" 1
11:46:28 <lambdabot>  error:
11:46:28 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M689442517998...
11:46:28 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
11:47:01 <barcabuona> well basically on my system that works, but not if i use (take 1 [1..])
11:47:02 <mniip> lyxia, if I could attribute type-level tags to a syntactically (mutually) recursive structure
11:47:08 <kadoban> bradparker: printf is weirdly polymorphic, so you have to specify the type there usually
11:47:14 <kadoban> > printf "%d" 1 :: String
11:47:16 <lambdabot>  "1"
11:47:26 <mniip> by having something like  Recursive (tag :: Tag) (innerTags :: [Tag])
11:47:30 <cocreature> > printf "%d" (1 :: Integer)
11:47:33 <lambdabot>  error:
11:47:33 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M742628450376...
11:47:33 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
11:47:34 <kadoban> And I suck at directing things to the right person, sorry bradparker
11:47:47 <hvze> well, I am back
11:47:47 <ertes> kadoban: yeah, there is probably nothing wrong with doing that, but it just feels like a layer violation
11:47:55 <mniip> I could abstract this into a helper type that would just be a single parameter in a grammar DSL type
11:47:57 <hvze> or on the bus atleast, it’s yen btw.
11:47:58 <mniip> which
11:48:06 <mniip> basically a year ago I wrote this:
11:48:25 <mniip> http://lpaste.net/6706373501768433664
11:48:50 <mniip> this represents an attributive grammar, constructed with an applicative DSL
11:48:59 <mniip> tricky part is storing the types of the nonterminals
11:49:01 <kadoban> Yeah, I agree. Sometimes it's really convenient though (like if I have a modified version of the library for whatever reason, or if I don't have a great way to distribute it alone or whatever). Which ya, doesn't seem to be the case here at all.
11:49:05 <mniip> for which I use a type level map
11:50:01 <mniip> now
11:50:05 <mniip> this thing works, but
11:50:08 <mniip> you have to mark recursion
11:50:19 <mniip> and
11:50:25 <mniip> well basically it has to go through Typeable
11:50:44 <mniip> I couldn't find a way to let the typechecker really infer the safety of the operations
11:50:50 <mniip> partially because they aren't really safe
11:51:13 <mniip> you could mark two terms of different types with the same recursion mark
11:51:21 <mniip> and it could try coercing one into another
11:52:46 <mniip> did I reach X yet
11:52:53 <mniip> guess not
11:52:59 <mniip> basically!
11:53:09 <mniip> typed applicative parsers that construct an actual parse table internally
11:53:22 <mniip> be it LL or LR or GLR or whatever your favorite is
11:53:47 <mniip> oh but wait
11:53:58 <mniip> can it really be applicative
11:54:29 <mniip> if we hide the tags behind existentials
11:55:08 <mniip> type variables can only work as uniqs while they are actually quantified over
11:55:16 <mniip> hmmm
11:55:39 <mniip> indexed applicative?
11:55:47 <mniip> that would work
11:56:25 <hvze> If i’m using a state as a pseudo global variable, how would I pass it around?
11:56:45 <hvze> In java i’d have a singleton static instance, that’s mutable. What would the haskell alternative be
11:57:17 <mniip> hvze, you pass the state type around
11:57:30 <hvze> but as a state?
11:57:31 <mniip> everything that needs to read the variable has to be wrapped in the monad
11:57:36 <hvze> could that work?
11:57:47 <mniip> pure functions are pure
11:58:05 <mniip> global variables are an impurity that needs to be attributed appropriately
11:58:05 <hvze> ok, that’s much less of a headache than I thought
12:02:17 <frerich> Did anybody else do AoC today and consider every tile to be 2x2 units in size? I didn't see that idea anywhere yet but it makes for faily simple Haskell code: https://github.com/frerich/aoc2017/blob/master/11.hs
12:03:17 <frerich> It seems about everyone found (googled for it?) https://www.redblobgames.com/grids/hexagons/ and then used that.
12:03:32 <mniip> I didn't google anything
12:05:13 <mniip> I did practically reinvent what this article calls cube coordinates
12:05:36 <kadoban> frerich: That's rather nice. I think that's somewhat equivalent to doing a coordinate transform, but yours looks nice and simple.
12:06:40 <frerich> kadoban: I'm somehow surprised that I don't find more solutions using this way of mapping coordinates. It was just based on the observation that if you go two steps north-east, you are on the same height as when you go one step north directly, i.e. the diagonals move twice as fast horizontally than vertically.
12:07:33 <Psybur> I thought you could make classes with the same name as a data constructor. Is there a "right" way to do something similar to this? data FizzBuzz a = FizzBuzz | Fizz | Buzz | Nuzzing a; class FizzBuzz a where; classifyFizzBuzz :: a -> FizzBuzz a
12:08:33 <kadoban> frerich: Ya, I like that way of seeing it. I'll have to remember that for next time it comes up, heh.
12:09:18 <platz> i would never have known about cube coordinates without looking it up
12:09:44 <kadoban> I've done ... "tilt your head, and number rows/columns like that" before, but it's more annoying, and I don't think it's as easy to read off distance.
12:12:11 <crucify_me> sbrg, thanks for your help earlier btw
12:19:38 <hoppfull> If I make a function for example: div x y = x / y, I have to assume no one passes 0 into the y argument. Do you use runtime checking/proof assistants/some mechanism in haskell/unit testing or are you okay with assumptions and just hoping that 0 wont get passed to the y argument in a couple of months?
12:20:19 <tdammers> hoppfull: depends on the situation
12:20:19 <Lokathor> a lot of IRC codes are numeric and have names that start with RPL
12:20:22 <Lokathor> what's RPL stand for?
12:22:16 <int-e> "reply"?
12:22:38 <Lokathor> suppose it's as godo a guess as any
12:25:04 <mniip> it is reply
12:25:13 <mniip> all of them are replies
12:25:43 <mniip> though
12:25:57 <mniip> it depends a great deal on whether you're writing an IRC server or an IRC client
12:26:36 <mniip> if you're writing an IRC client then writing down constants for numerics is almost useless
12:26:55 <mniip> do you expect the less common numerics to be any sort of universal across servers?
12:27:01 <mniip> good luck
12:27:32 <hoppfull> tdammers: I just want to be done with a piece of code when I'm done with it. I don't want to have to keep thinking about all the different cases that might go wrong. It's stressful.
12:28:11 <hoppfull> tdammers: Have you used liquid haskell? Is it any good?
12:29:13 <mniip> hoppfull, it really depends on the situation
12:29:17 <tdammers> hoppfull: haven't used it myself, but a colleague seems to be mildly positive
12:29:31 <mniip> off the top of my head I can provide at least 3 different solutions that I would use in different cases
12:29:47 <mniip> partial functions,
12:29:52 <mniip> augmented return type,
12:29:52 <tdammers> hoppfull: generally speaking, the idea is to know which functions are partial, and avoid them as much as possible; this already covers a lot of ground
12:29:58 <mniip> some proof of nonzero-ness
12:31:35 <hoppfull> tdammers: What do you mean with "partial"?
12:32:16 <hoppfull> tdammers: Apologies, I googled it right away.
12:36:14 <wedify> when you're benchmarking a multi-argument function with criterion does it matter which argmument you leave out? ie will there be a difference between 'wnf (\a -> f a b) a' and 'wnf (\b -> f a b) b'?
12:37:05 <dmwit> wedify: Possibly. `f` may do some precomputation when given just one argument.
12:37:29 <dmwit> wedify: So `wnf (\b -> f a b) b` may have, say, a lookup-table computed based on `a`.
13:05:53 * hackage hedgehog-checkers 0.1.0.0 -   https://hackage.haskell.org/package/hedgehog-checkers-0.1.0.0 (bitemyapp)
13:07:52 <Gurkenglas> Shouldn't it be "callCC :: ((a -> ContT r m b) -> ContT s m a) -> ContT s m a"?
13:08:52 * hackage hedgehog-checkers-lens 0.1.0.0 -   https://hackage.haskell.org/package/hedgehog-checkers-lens-0.1.0.0 (bitemyapp)
13:08:56 <lyxia> Where are r and s bound
13:09:18 <mniip> Gurkenglas, wouldn't typecheck
13:11:13 <Gurkenglas> "callCC f = ContT $ \ c -> runContT (f (\ x -> ContT $ \ _ -> c x)) c" coerces to "callCC1 f = \c -> f (\x _ -> c x) c", right?
13:11:34 <Gurkenglas> :t \f c -> f (\x _ -> c x) c
13:11:34 <lambdabot> ((t1 -> p -> t2) -> (t1 -> t2) -> t3) -> (t1 -> t2) -> t3
13:11:49 <Gurkenglas> Note t3 only appears in two spots
13:13:49 <Gurkenglas> Oh, I suppose t3 appears within t2 when you squint
13:13:57 <mniip> t3 is the a
13:14:11 <mniip> oh er
13:14:12 <mniip> no
13:14:15 <Gurkenglas> wut? t3 should be the r/s
13:14:19 <mniip> yes
13:14:43 <mniip> t2/t3 is the r
13:15:08 <mniip> and p should be ~ (b -> r)
13:15:21 <mniip> that's the third/sixth occurence
13:16:22 <pta2002> is there any function that will strip a string of whitespace on the begining and the end?
13:16:28 <pta2002> there only seems to be one for Text
13:21:41 <barcabuona> i have s<-readFile "hey", how can i use try () to either assign the data or print a msg and exit?
13:21:43 <barcabuona> (inside main)
13:22:05 <wedify> what if readFile and writeFile were of type Maybe? ie if there are too many filehandles open they return Nothing. would this make lazy io safe?
13:23:06 <mniip> no
13:23:24 <mniip> unsafety comes not from partiality
13:23:31 <mniip> but from referential transparency breaking
13:23:37 <mniip> well, for some value of
13:23:40 <mniip> it's arguable
13:25:03 <barcabuona> i argue that Maybe is much better than runtime crash
13:25:22 <barcabuona> and i think that's what try () helps to do by catching the exception
13:25:25 <barcabuona> how can i use it?
13:26:28 <mniip> I expect readFile doesn't even open the file until you probe the first char
13:27:43 <lyxia> barcabuona: I wouldn't use try if the plan is to exit on exception.  readFile "hey" `catch` \_ -> putStrLn msg >> exitFailure
13:28:26 <barcabuona> hmmm 
13:28:37 <barcabuona> nice, just for completeness how's the try variant?
13:29:09 <wedify> mniip: oh that's a good point.
13:30:42 <lyxia> barcabuona: try (readFile "hey") >>= either (\_ -> putStrLn msg >> exitFailure) return
13:31:18 <lyxia> barcabuona: or replace either by lambda/pattern-matching
13:31:24 <monochrom> barcabuona: Read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
13:33:51 <barcabuona> if null argv then exitFailure
13:33:55 <barcabuona> is problematic because no else
13:34:00 <mniip> when
13:34:01 <mniip> :t when
13:34:03 <lambdabot> Applicative f => Bool -> f () -> f ()
13:34:11 <barcabuona> right? even tho the compiler error is awful
13:34:45 <mniip> 'parse error near ;' or something like that?
13:35:49 <barcabuona> yes
13:36:06 <monochrom> "when (null argv) exitFailure" exists. "when" is from Control.Monad
13:36:10 <barcabuona> when (null argv) exitFailure
13:36:48 <mniip> barcabuona, that's fairly mild
13:37:49 <barcabuona> mniip: mild?
13:38:17 <Gurkenglas> Okay so in "do a1 <- callCC (\a2 -> a3 a2); a4 a1", where callCC is morally "\f c -> f (\x _ -> c x) c", a4 is the continuation-that-requires-an-a1 and is passed bottom-up through the do-block-lines of a3 a2 to retrieve it. a2 as it is used within a3 might eventually receive that continuation as it is passed up, and discards it in favor of sticking the x it is given at its spot in a3 a2 into the original 
13:38:17 <Gurkenglas> continuation c, doing something that looks like jumping out of the "a1 <- callCC (\a2 -> a3 a2);" part. Did I get that right?
13:39:16 <mniip> barcabuona, there *will* be worse errors
13:39:40 <barcabuona> but is ghc/lang development stalled?
13:40:05 <mniip> no
13:41:42 <monochrom> But error message development is much slower than other aspects development (e.g., optimizer, type system), yes.
13:42:36 <mniip> the problem with error messages is that language interpretation is full of undecidable things,
13:42:46 <mniip> and then you ask questions like "what does it look like the programmer meant"
13:42:47 <monochrom> If you're going for that "a good language needs ___" talking down again, you can save your breath now.
13:42:51 <mniip> which is like undecidable squared
13:43:34 <barcabuona> > file <- readFile "/tmp/test.txt" `catch` \_ -> putStrLn "err" >> exitFailure
13:43:36 <lambdabot>  <no location info>: error:
13:43:36 <lambdabot>      not an expression: ‘file <- readFile "/tmp/test.txt" `catch` \_ -> putSt...
13:43:47 <barcabuona> > readFile "/tmp/test.txt" `catch` \_ -> putStrLn "err" >> exitFailure
13:43:49 <lambdabot>  error:
13:43:49 <lambdabot>      Variable not in scope: exitFailure :: IO String
13:43:57 <monochrom> lambdabot is not a ghci prompt.
13:44:07 <barcabuona> for some reason on my system it didnt work
13:44:18 <mniip> % readFile "/tmp/test.txt" `catch` \_ -> putStrLn "err" >> exitFailure
13:44:18 <yahb> mniip: ; <interactive>:16:58: error: Variable not in scope: exitFailure :: IO String
13:45:46 <barcabuona> monochrom: i'm not talking down, just noticing things. haskell is a scientific project after all
13:46:54 <wedify> mniip: if we could simulate an inifinite number of handles with an io scheduler that would work?
13:47:20 <wedify> just trying to understand the issue
13:47:21 <mniip> % import System.Exit
13:47:21 <yahb> mniip: 
13:47:23 <mniip> % readFile "/tmp/test.txt" `catch` \_ -> putStrLn "err" >> exitFailure
13:47:23 <yahb> mniip: ; <interactive>:18:1: error:; * Ambiguous type variable `e0' arising from a use of `catch'; prevents the constraint `(Exception e0)' from being solved.; Probable fix: use a type annotation to specify what `e0' should be.; These potential instances exist:; instance Exception Dynamic -- Defined in `Data.Dynamic'; instance [safe] Exception Void -- Defined in `Data.Void'; instance Exception ArithException -- Defined in `GHC.Exception'; ...plus two others; ...p
13:49:32 <barcabuona> yeah i get exactly that
13:49:45 <barcabuona> also i'm trying to assign that to a variable
13:49:50 <mniip> % readFile "/tmp/test.txt" `catch` \e -> (e :: SomeException) `seq` putStrLn "err" >> exitFailure
13:49:50 <yahb> mniip: err; *** Exception: ExitFailure 1
13:50:35 <shapr> % 1 + 1
13:50:36 <yahb> shapr: 2
13:50:39 <shapr> aha
13:51:02 <shapr> yet another haskell bot
13:51:36 <shapr> mniip: is that your bot? I don't see it in your github projects
13:51:58 <mniip> yes
13:52:24 <mniip> shapr, here's the backend https://github.com/mniip/sandbox
13:52:27 <barcabuona> that command still doesn't work tho
13:52:42 <barcabuona> and i'm highly confused how i can catch this exception
13:52:43 <shapr> mniip: neat, thanks!
14:04:13 <barcabuona> i cant believe the hardest part of doing this simple exercise was using hash and fucking checking a file open\
14:06:59 <monochrom> I wouldn't say other languages make it "easier", or more precisely, other language textbooks teach this stuff earlier?
14:07:54 <monochrom> If I crack open a C textbook like K&R, checking a file open is also in a middle or late chapter, and using a hash table (or any dictionary) is never.
14:09:08 <monochrom> And if you now cite how a Perl book or Python book talks about using their built-in dictionaries right in Chapter 1 --- well by the zero-sum game some other easy stuff is going to be postponed to a late chapter.
14:09:37 <monochrom> For example IIRC the Perl textbook talks about records in an advanced late chapter.
14:10:03 <monochrom> Bloody vanilla records as an advanced skill. Fancy that.
14:11:49 <osfameron> Perl doesn't really have records
14:12:02 <osfameron> I mean, you'd use a hash or an object
14:12:21 <monochrom> Right, that's why it's an advanced skill in Perl.
14:13:17 <osfameron> except that hashes and objects aren't all that advanced
14:13:38 <osfameron> but I take the point that there must be *some* other language feature that gets left till later...
14:16:57 <mniip> yeah let's just throw the reader straight into the IO monad hell
14:17:06 <mniip> how they figure out monads and IO along the way
14:17:11 <mniip> s/how/hope/
14:17:20 <monochrom> Paul Hudak did. :)
14:18:26 <mniip> how many people succeeded?
14:18:45 <monochrom> I don't know.
14:19:02 <monochrom> But may be more realistic to ask "how many people survived" instead. :)
14:20:34 <monochrom> But Hudak was not a dense or high-horse person. I think he already made it reaonsably easy.
14:20:49 <monochrom> Or at least reasonably accessible.
14:22:17 <monochrom> It did help that he wrote a higher-level library so in the early chapters you just had to use his library (which gave you simple commands for simple graphics).
14:27:28 <Gurkenglas> mniip, in puncture, why put fmap fst xs into each snd of xs, rather than the original argument to puncture?
14:28:01 <mniip> I didn't want to spoil the traverse
14:28:42 <mniip> there's also this thing that if you do decide to make it go to arbitrary depths with a recursive datatype, you will have to do this nevertheless
14:53:53 * hackage zeromq4-haskell 0.7.0 - Bindings to ZeroMQ 4.x  https://hackage.haskell.org/package/zeromq4-haskell-0.7.0 (ToralfWittner)
14:56:29 <alchzh> hmm... I have six constant values (labeled 0, 1, 2, 3, 4, 5) that I need to use throughout my code...
14:56:36 <alchzh> what is the best way to store this?
14:56:55 <merijn> alchzh: Eh, define some variables? :p
14:57:07 <alchzh> I need to use them as numbers though
14:57:18 <alchzh> would a vector be advisable?
14:57:34 <merijn> alchzh: What do you mean by "I need to use them as numbers though"?
14:57:54 <alchzh> as in I need to keep the labels as ints for some maths 
14:58:22 <geekosaur> I do not understand that assertion
14:58:23 <merijn> What's wrong with "myLabel :: Int; myLabel = 0"?
14:58:27 <glguy> Yes, a vector is fine
14:58:50 <merijn> glguy: Fine for what?
14:58:53 <glguy> I believe that alchzh has 6 values that need to be able to dynamically indexed using indexes 0 through 5
14:59:04 <glguy> storing those 6 values in a vector will serve that purpose
14:59:18 <alchzh> yeah I need fast random access to them
14:59:21 <mniip> I'd use a list
14:59:26 <mniip> ah
14:59:29 <mniip> I'd use a function then
14:59:43 <mniip> a function from Int
15:00:06 <mniip> through a vector might be faster, yes
15:00:13 <merijn> Depends on whether he needs to mutate said values
15:00:15 <glguy> Vectors make it easy to check the valid range of arguments externally with a length function, Functions make it easy to handle all possible index values
15:00:32 <glguy> and mutable vectors make it possible to mutate
15:00:51 <mniip> f 0 = x; f 1 = y; f 2 = z;... should compile to some pretty fast code if monomorphism
15:00:56 <mniip> s/phism/phic/
15:01:15 <Gurkenglas> @let puncturegurk = (`runCont` \xs -> fmap (second ($ fmap fst undefined)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs)))) -- mniip, note the undefined
15:01:15 <lambdabot>  Defined.
15:01:37 <Gurkenglas> > [y (x+1) | (x,y) <- puncturegurk [1,2,3]] -- why should there be an xs there instead?
15:01:38 <lambdabot>  [[2,2,3],[1,3,3],[1,2,4]]
15:02:10 <mniip> uhhh
15:08:51 <Gurkenglas> :t auf (iso cont C.evalCont) traverse (\x c -> c (x, \y -> fst <$> c (y, undefined))) -- mniip
15:08:52 <lambdabot> Traversable t => t a -> t (a, a -> t a)
15:09:22 <mniip> what up with the undefined
15:09:30 <mniip> I liked my partiality-free version
15:09:42 <Gurkenglas> better undefined than unused garbage
15:09:51 <mniip> I disagree
15:09:57 <mniip> I can prove my function doesn't diverge
15:09:58 <mniip> can you
15:11:06 <Gurkenglas> my function doesn't diverge iff your function always produces sensible results
15:11:39 <Gurkenglas> 1/0 shouldn't be 0 just because NaN is ugly
15:12:10 <mniip> but it could
15:12:15 <mniip> that would be mathematically valid
15:12:47 <mniip> if that would make your proof easier then well why not
15:12:50 <Gurkenglas> we're in much bigger trouble when the null pointers lead to undefined behavior rather than crashes
15:13:42 <mniip> Gurkenglas, the really simplest solution would be to use StateT to push the holes back in
15:13:52 <mniip> but that's partial
15:14:05 <monochrom> Experiment report: "f :: Int -> Char; f 0 = 'a'; f 1 = 'c'; ...; f 5 = 'z'" compiles to a jump table: "jmp *_n28O(,%rax,8)" where _n28O is an array of addresses, where a typical address holds code like "R1 := address of the correct char; return"
15:14:40 <mniip> monochrom, with bounds checking on %rax I presume
15:18:48 <lyxia> monochrom: that's very neat
15:20:25 <monochrom> Yes, there are "if rax >= 6, goto e" and "if rax < 0, goto e" where e is the address of the code that goes "R1 := closure for pattern error"
15:21:19 <mniip> uhhh
15:21:24 <mniip> but why
15:21:32 <mniip> you only need one unsigned comparison
15:21:42 <mniip> at least that's what I would do
15:22:00 <monochrom> I don't know. File a feature request? :)
15:22:08 <mniip> I don't remember whether ja/jb or jg/jl are the unsigned ones but
15:23:41 <monochrom> I used Int. This can complicate things. I don't think the GHC devs really bothered to add in optimizer code for "if the jump table is small enough, we can pretend the parameter is unsigned, it is still correct"
15:24:35 <monochrom> Then again, I guess jump tables are always small enough. Who's going to have a 33K jump table?
15:25:22 <mniip> me
15:27:09 <hpc> all of my tables are bobby tables
15:30:49 <geekosaur> why am I recalling a bug in either ghc or possibly gcc because someone assumed jump tables were always small enough?
15:34:07 <monochrom> Because your brain holds memory and receives stimulus. (Physiological tautology.)
15:35:06 <mniip> geekosaur, it all started when you were born
15:35:36 <monochrom> hee hee hee
15:38:57 <Lokathor> http://lpaste.net/6848913493408612352 gettin some good results
15:39:21 <ertes> monochrom: a jump table?  couldn't this be optimised to a lookup?
15:39:34 <mniip> Lokathor, suggestion: react on RplWelcome
15:39:41 <mniip> for nickserv/joins/etc
15:39:52 <monochrom> Yes but -O2 still outputs a jump table.
15:40:12 <mniip> I do wonder what your Join and Mode ctors look like
15:40:15 * geekosaur glances over local cogpsych stuff and then decides better to just not go there
15:40:34 <Lokathor> mniip, https://modern.ircdocs.horse/#connection-registration this says otherwise >_>
15:41:21 <mniip> this doesn't say otherwise
15:41:27 <ertes> Lokathor: you're implementing IRC?
15:41:56 <Lokathor> "Immediately upon establishing a connection the client must attempt registration, without waiting for any banner message from the server." ... "Upon successful completion of the registration process, the server MUST send, in this order, the RPL_WELCOME (001), RPL_YOURHOST (002), ..."
15:42:23 <mniip> yes
15:42:26 <geekosaur> Lokathor, that's about identifying to the server
15:42:27 <Lokathor> so 001 doesn't show up until after you've registered, and registering is a result of NICK+USER
15:42:32 <mniip> yes
15:42:38 <geekosaur> try to nickserv, join, etc. before you've id-d to the server is an error
15:42:39 <mniip> I never said registration
15:42:46 <mniip> 1513035552 [02:39:12] <mniip> for nickserv/joins/etc
15:42:56 <geekosaur> nickserv is registration with a network, not a server
15:42:58 <Lokathor> oh nickSERV
15:43:05 <mniip> yeah
15:43:08 <mniip> also implement sasl
15:43:10 <mniip> at least plain
15:43:10 <Lokathor> well the bot doesn't do any of those yet :P
15:43:12 <mniip> and ssl
15:43:14 <mniip> and external
15:43:43 <ertes> also the countless extensions that make writing a generic IRC client rather difficult
15:43:58 <Lokathor> but i don't care about any of those things
15:44:13 <mniip> tags!
15:44:19 <mniip> not that we support any...
15:45:08 <Lokathor> i care about it lurking in specific channels and then diverting pings i get into its own data stream so that they don't get lost
15:45:17 <Lokathor> and one or two other things
15:47:24 <ertes> that sounds like you're writing a bot
15:47:35 <mniip> that sounds like a job for an irc client plugin
15:47:45 <mniip> what irc client do you use!
15:47:48 <ertes> or at least a ready-made client library
15:47:53 <ertes> https://hackage.haskell.org/package/irc-core
15:48:27 <hs_newb> hello all, is there a thing called scanMap corresponding to foldMap ?
15:48:53 <ertes> hs_newb: what would its type be?
15:48:58 <mniip> this calls for a monoid transformer!
15:49:50 <hs_newb> (Foldablet , Monoid m) =>(a->m)-> ta -> ta
15:49:55 <Lokathor> ertes, seems less fun tho
15:50:11 <ertes> hs_newb: that doesn't seem like a sensible type
15:50:15 <Lokathor> mniip, i use hexchat
15:50:21 <mniip> Lokathor, what a coincidence!
15:50:24 <mniip> @hackage hexchat
15:50:24 <lambdabot> http://hackage.haskell.org/package/hexchat
15:50:34 <hs_newb> (Foldablet , Monoid m) =>(a->m)-> ta -> t m
15:50:53 <Lokathor> _however_ what you're suggesting won't accomplish the "few other things" the bot will eventually do
15:51:08 <mniip> @let newtype Prefices m = Prefices [m] deriving (Eq, Ord, Show)
15:51:09 <lambdabot>  Defined.
15:51:13 <Lokathor> including connecting to both IRC and Discord
15:51:42 <Lokathor> mniip, "At the moment only Linux is supported." pooooooo
15:51:50 <ertes> hs_newb: you can probably write scanMap in terms of foldMap
15:52:15 <mniip> @let instance Monoid m => Monoid (Prefices m) where mempty = Prefices []; mappend (Prefices xs) (Prefices ys) = Prefices (xs ++ map (if null xs then id else (last xs ++)) ys)
15:52:16 <lambdabot>  .L.hs:179:59: error:
15:52:16 <lambdabot>      • Couldn't match expected type ‘[a0]’ with actual type ‘m’
15:52:16 <lambdabot>        ‘m’ is a rigid type variable bound by
15:52:39 <mniip> @let instance Monoid m => Monoid (Prefices m) where mempty = Prefices []; mappend (Prefices xs) (Prefices ys) = Prefices (xs ++ map (if null xs then id else (last xs <>)) ys)
15:52:40 <lambdabot>  Defined.
15:52:58 <ertes> :t \f -> foldMap (pure . f)
15:52:59 <lambdabot> (Applicative f, Monoid (f a1), Foldable t) => (a2 -> a1) -> t a2 -> f a1
15:53:16 <ertes> hs_newb: you need a suitable 'f' to reconstruct 't'
15:53:25 <mniip> @let scanMap f xs = case foldMap (Prefices . return . f) xs of Prefices ps -> ps
15:53:27 <lambdabot>  Defined.
15:53:29 <mniip> :t scanMap
15:53:30 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> [m]
15:54:04 <ertes> that's not quite what they asked for =)
15:54:16 <mniip> ooh I missed the mempty
15:54:18 <mniip> > scanMap (:[]) [1,2,3]
15:54:20 <lambdabot>  [[1],[1,2],[1,2,3]]
15:54:26 <Lokathor> mniip, JOIN, MODE and other construtors https://gitlab.com/Lokathor/ekcerto-hs/blob/master/app/IRC.hs#L78
15:54:30 <mniip> should contain a [] as well
15:54:45 <hs_newb> ertes: very nice :)
15:55:08 <ertes> hs_newb: honestly i would just encode the reconstruction into the monoid itself
15:55:09 <mniip> > scanr (:) [] [1,2,3]
15:55:11 <lambdabot>  [[1,2,3],[2,3],[3],[]]
15:55:25 <ertes> hs_newb: also remember that foldMap has no specific order
15:55:29 <mniip> ertes, that's pretty much what I did...
15:55:44 <mniip> @undefine
15:55:44 <lambdabot> Undefined.
15:55:44 <hs_newb> ertes i would need two functions if i want to do that
15:55:55 <ertes> hmm…  actually mine is stupid
15:56:20 <ertes> there is no 'f' that wouldn't look like a sequence of some sort
15:59:52 <mniip> @let instance Monoid m => Monoid (NonEmpty m) where mempty = mempty :| []; mappend xs ys = foldr (<|) (fmap (NE.last xs <>) ys) xs
15:59:53 <lambdabot>  .L.hs:161:43: error:
15:59:53 <lambdabot>      Not in scope: ‘NE.last’
15:59:53 <lambdabot>      Perhaps you meant ‘BS.last’ (imported from Data.ByteString)
16:01:07 <mniip> @let instance Monoid m => Monoid (NE.NonEmpty m) where mempty = mempty NE.:| []; mappend xs ys = foldr (<|) (fmap (NE.last xs <>) ys) xs
16:01:08 <lambdabot>  .L.hs:162:31: error:
16:01:08 <lambdabot>      • Could not deduce (Cons (NE.NonEmpty m) (NE.NonEmpty m) m m)
16:01:08 <lambdabot>          arising from a use of ‘<|’
16:01:15 <mniip> @let instance Monoid m => Monoid (NE.NonEmpty m) where mempty = mempty NE.:| []; mappend xs ys = foldr (NE.<|) (fmap (NE.last xs <>) ys) xs
16:01:16 <lambdabot>  Defined.
16:02:03 <mniip> @let scanMap f = foldMap ((NE.:| []) . f)
16:02:04 <lambdabot>  Defined.
16:02:06 <mniip> :t scanMap
16:02:08 <lambdabot> (Foldable t, Monoid a1) => (a2 -> a1) -> t a2 -> NE.NonEmpty a1
16:02:38 <mniip> > scanMap id ["foo", "bar", "baz"]
16:02:40 <lambdabot>  "foo" :| ["foobar","foobarbaz","foobarbaz"]
16:02:44 <mniip> ugh
16:02:48 <mniip> still got it wrong didn't I
16:02:57 <mniip> well basiscally the idea is somewhere there
16:03:43 <ertes> i think a scanMap can't possibly be universally total, unless it's part of Foldable itself
16:04:01 <mniip> sure can
16:04:09 <mniip> just gotta write the right monoid transformer
16:06:19 <ertes> @let newtype RList a = Flip { RList :: [a] } deriving (Eq, Functor, Ord, Show); instance Foldable RList where foldMap f (RList []) = mempty; foldMap f (RList (x:xs)) = foldMap f xs <> x
16:06:19 <lambdabot>  Parse failed: Parse error: RList
16:06:32 <Lokathor> mniip, i think i have a normal constructor for Join and Mode
16:06:32 <ertes> @let newtype RList a = RList { fromRList :: [a] } deriving (Eq, Functor, Ord, Show); instance Foldable RList where foldMap f (RList []) = mempty; foldMap f (RList (x:xs)) = foldMap f xs <> x
16:06:33 <lambdabot>  .L.hs:169:54: error:
16:06:34 <lambdabot>      • Couldn't match expected type ‘m’ with actual type ‘a’
16:06:34 <lambdabot>        ‘a’ is a rigid type variable bound by
16:06:34 <mniip> needs multiple lets
16:06:42 <mniip> oh
16:06:52 <ertes> @let newtype RList a = RList { fromRList :: [a] } deriving (Eq, Functor, Ord, Show); instance Foldable RList where foldMap f (RList []) = mempty; foldMap f (RList (x:xs)) = foldMap f xs <> f x
16:06:54 <lambdabot>  Defined.
16:07:12 <mniip> Lokathor, c2s and s2c JOINs are different
16:07:27 <mniip> mode arguments are a proper list of words
16:07:42 <ertes> > scanMap id ((:[]) <$> RList [0..])
16:07:44 <lambdabot>  [1] :| [[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
16:07:51 <ertes> hmm?
16:07:56 <Lokathor> Join [ByteString] (Maybe [ByteString]) -- this covers all the cases you'd want to
16:08:03 <ertes> that doesn't look right
16:08:09 <mniip> this scanmap is broken
16:08:11 <Lokathor> because it covers all cases
16:08:15 <ertes> i think we should establish what the semantics of scanMap is first
16:08:33 <mniip> it has to return a list
16:08:42 <mniip> as it contains one more element than the input
16:09:02 <mniip> Lokathor, ehh?
16:09:13 <Lokathor> mniip, i'm not sure i understand your question :3
16:09:16 <ertes> the only semantics i can think of is a regular left-scan
16:09:36 <ertes> but then foldMap has no direction
16:09:38 <mniip> s2c join is :source JOIN target account :gecos
16:09:55 <Lokathor> that doesn't look right at all
16:10:09 <ertes> Lokathor: it is right
16:10:19 <mniip> account/gecos are enabled by an extension
16:10:34 <Lokathor> oh extensions
16:10:36 <glguy> You have to CAP enable extjoin or whatever it is
16:10:37 <Lokathor> yeah i don't do that
16:10:41 <Lokathor> :P
16:10:42 <mniip> extended-join
16:10:48 <mniip> yeah and you never plan to
16:10:50 <mniip> of course
16:10:57 <Lokathor> what does it do?
16:10:59 <hs_newb> ertes: then you can't write scanMap using foldMap right?
16:11:12 <ertes> hs_newb: it depends on what scanMap is
16:11:27 <ertes> hs_newb: so far all we have is a type
16:11:27 <hs_newb> right more like scanlMap or scanRmap
16:12:15 <haskell_student> Is Anyone here familiar with "Haskell Programming From First Principles"?
16:12:16 <ertes> hs_newb: the problem is that foldMap is not like foldr, which has a specific directionality: left-to-right
16:12:28 <Lokathor> haskell_student, yep, it's great
16:12:32 <DigitalKiwi> I'd like to think that the person asking about an irc bot is the cause of the netsplit
16:12:49 <mniip> of course he is
16:12:52 * hackage log-warper 1.7.5 - Flexible, configurable, monadic and pretty logging  https://hackage.haskell.org/package/log-warper-1.7.5 (shersh)
16:13:10 <DigitalKiwi> probably ran his test suite
16:13:29 <haskell_student> Lokathor: In the exercises for 4.9, "Correcting syntax", #2, the question reads "This is supposed to be the identity function, id: \X = x". I see nothing in the text before this question to help answer the question nor to explain the "\X = x" form. What's more, from the wording of the question, I am not exactly sure what question I am supposed to be answering. Can You point me in the direction of clarifying information on t
16:13:33 <Lokathor> mniip, i looked up extended-join, but i really don't see what it's supposed to do
16:13:41 <ertes> freenode needs to order more compute resources to handle this test suite
16:13:58 <ertes> "sure, how much do you need from the cloud?" – "the rest"
16:14:17 <Lokathor> ertes, ever read a book called Fine Structure? or perhaps Ra?
16:14:18 <lyxia> haskell_student: That is invalid syntax, so it seems you're supposed to correct it.
16:14:21 <glguy> http://ircv3.net/specs/extensions/extended-join-3.1.html it provides the account name and "real" name when a user joins so that you don't have to then do a new query every time someone joins if your client wants to track the names of all users in the channel
16:14:28 <glguy> it potentially reduces traffic
16:14:36 <lyxia> haskell_student: (guessing from the title)
16:14:39 <ertes> Lokathor: "book"
16:14:40 <ertes> ?
16:14:55 <Lokathor> yeah like a thing with pages that you read
16:15:11 <ertes> with links on them?
16:15:17 <Lokathor> sure, some do
16:15:28 <ertes> yeah, sure…  i read books all day
16:15:39 <Lokathor> haskell_student, I don't recall that problem, the #haskell-beginners channel has a lot of people who are constantly going over that book though
16:15:53 <mniip> > scanr (:) [] [1,2,3]
16:15:55 <lambdabot>  [[1,2,3],[2,3],[3],[]]
16:15:57 <ertes> Lokathor: don't understand your reference though…  do you have a link to those books?
16:16:12 <haskell_student> Lokathor: thanks, I'll try there.
16:16:17 <glguy> haskell_student: There are lots of people here who can help with Haskell questions, we just mostly don't have that book
16:16:28 <Lokathor> they're just sci-fi books that both have scenes where a character calls down immense quantities of energy out of "nowhere" to do whatever they need to do in the scene
16:16:36 <glguy> So if you just have a question, not a question about a page, you're welcome to ask
16:16:36 <mniip> > scanl (flip (:)) [] [1,2,3]
16:16:38 <lambdabot>  [[],[1],[2,1],[3,2,1]]
16:16:53 <ertes> Lokathor: sounds like a deus ex machina setup
16:17:06 <n|> is this just a bug with @pl?
16:17:06 <n|> @pl \(x,y,z) -> ()
16:17:06 <lambdabot> (line 1, column 7):
16:17:06 <lambdabot> unexpected "z"
16:17:06 <lambdabot> ambiguous use of a non associative operator
16:17:12 <MarcelineVQ> haskell_student: identity is mentioned in the very first chapter where it's working is explained in terms of the lambda calculus.  it's then mentioned in 2.6 where it's explained and used
16:17:13 <Lokathor> haskell_student, I think that you're supposed to change "id: \X = x" into something that would compile and be the identity function
16:17:46 <glguy> n|: No, it just doesn't support patterns like that
16:18:03 <Lokathor> ertes, hmm, partly. the author is quite bound to explanations for as much as possible, so it's all justified at the time within the setting
16:18:04 <MarcelineVQ> the real task, given the explanation of identity in 2.6, is what should a function look like that gives back the same input it's given, is it   \X -> x   ? if it's not, what is it?
16:18:08 <n|> ok, thanks
16:19:11 <Lokathor> glguy, mniip, i guess extended-join sounds okay but i don't really wanna track everyone's real name anyway, normal join should be good enough
16:20:03 <haskell_student> MarcelineVQ: Can You point Me to the exact part? I just reviewed 2.6 and saw nothing about lambda calculus; though I admit I might have missed it in frustration.
16:20:33 <MarcelineVQ> hmm? lambda calculus is the entire first chapter. it's identity that's used in 2.6.  Is your book version quite old perhaps?
16:21:06 <hs_newb> is there a way to group patterns for the same value in case stmt?
16:21:19 <Lokathor> hs_newb, use a tuple?
16:21:35 <glguy> hs_newb: Like you want to support any one of a set of patterns?
16:21:40 <hs_newb> glguy: yes
16:21:43 <haskell_student> MarcelineVQ: I bought it just a few days ago. While I understand the lambda calculus portion, the format of "\X = x" does not appear to be explained anywhere.
16:21:51 <glguy> hs_newb: No, there isn't syntax for that
16:22:19 <hs_newb> glguy: how do you write something like that, make another function?
16:22:40 <Lokathor> you can can just list list each pattern
16:23:15 <Lokathor> list out*
16:23:58 <Gurkenglas> What do you say to someone who has to return a value that'll never be used, so returns one that he happens to have lying around that's of the correct type, rather than a null value, because that way it's easier to prove his program nonpartial?
16:24:25 <Lokathor> "slick move"
16:24:28 <glguy> I say, hey mniip, Gurkenglas is looking for you
16:24:33 <mniip> hi
16:24:37 <glguy> (if I remember the conversation from earlier correctly)
16:25:07 <Gurkenglas> yep, was trying to find people who'd speak out against it. Why'd you go ahead and lift the masquerade?
16:25:08 <mniip> Gurkenglas, I'm not calling my implementation th ebest
16:25:19 <mniip> or most efficient
16:25:41 <Lokathor> Gurkenglas, i'm not sure what you're against here. returning a value that won't be used anyway? what's to be against?
16:26:37 <hs_newb> why would you write something whose return value is never gonna be used ? :p
16:26:57 <Lokathor> hs_newb, to satisfy a function's required type, i'm assuming
16:27:50 <mniip> :t callCC
16:27:51 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
16:27:55 <mniip> that b is never coming into existence
16:28:03 <Gurkenglas> Lokathor, if you think your term will never be evaluated, you better make it crash the program if it is anyway
16:28:19 <DigitalKiwi> implementation has to be the strangest IRC name I've seen in a while... and there are a lot of strange names :|
16:28:28 <Lokathor> i guess that's a perspective
16:28:36 <mniip> at least it's not
16:28:38 <mniip> declaration
16:28:39 <hs_newb> right, also probably some io monad returning functions
16:28:40 * Lokathor glances at DigitalKiwi
16:28:41 <DigitalKiwi> glguy !
16:28:59 <Gurkenglas> Also there's a beauty to "you shall not evaluate undefined" turning into "you shall undefine nonevaluateds"
16:29:17 <mniip> Gurkenglas, there's an adjunction somewhere here
16:29:53 <Gurkenglas> Also the reader might not know the term has no meaning if you don't call it undefined
16:30:02 <Lokathor> Gurkenglas, the fact that forever is "Applicative f => f a -> f b" instead of "Applicative f => f a -> f loop" already makes me sad
16:30:26 <Gurkenglas> Lokathor, you mean "Applicative f => f () -> f Void"?
16:30:45 <Lokathor> no, f a is correct for input
16:31:19 <Lokathor> but the output type, that's what i want them to change
16:31:26 <Gurkenglas> f Void tells you that the result can only conjure values up into infinity. f () tells you that the argument can only get rid of values by discarding them
16:31:28 <lyxia> how is "a" correct, you don't use it
16:31:39 <Gurkenglas> *conjure values out of infinity
16:32:05 <hololeap> if a monad is like a burrito, then what would be the microwave?
16:32:25 <Lokathor> lyxia, "f a" matches "f ()" but also "f Int" and others, "f ()" on its own matches against only that, and you'd have to use `void` on your operation before passing it to forever, which is bad
16:32:33 <Lokathor> the GHC runtime
16:32:37 <Gurkenglas> Lokathor, you'd have to use fmap absurd on f Void to use it somewhere else
16:33:03 <Lokathor> look i'm not saying that f Void is necessarily bad, but i just want it to be f loop is all
16:33:34 <Gurkenglas> wait you just want the default type variable names to be suggestive?
16:34:01 <Lokathor> it doesn't have to be a default type variable. if you give a type variable in the explicit sig GHCi will keep that name
16:34:22 * Lokathor is 99% sure of what he just said
16:35:40 <Lokathor> ah ha, yes
16:36:09 <Lokathor> doIt :: IO a -> IO loop; doIt = undefined; :t doIt; doIt :: IO a -> IO loop
16:36:46 <mniip> @letlpaste 360711
16:36:48 <lambdabot>  Defined.
16:36:50 <mniip> :t scanlMap
16:36:51 <lambdabot> (Monoid m, Foldable f) => (a -> m) -> f a -> NE.NonEmpty m
16:36:52 <mniip> :t scanrMap
16:36:53 <lambdabot> (Monoid m, Foldable f) => (a -> m) -> f a -> NE.NonEmpty m
16:41:57 <mniip> :t fmap getPrefices . getPrefices . foldMap (Prefices . (NE.:| [mempty]) . Prefices . (NE.:| [mempty]) . f)
16:41:58 <lambdabot> (FromExpr m, Show a, Monoid m, Foldable t) => t a -> NE.NonEmpty (NE.NonEmpty m)
16:42:25 <mniip> > let g f = fmap getPrefices . getPrefices . foldMap (Prefices . (NE.:| [mempty]) . Prefices . (NE.:| [mempty]) . f) in g (:[]) [1,2,3]
16:42:28 <lambdabot>  ([1,2,3] :| [[1,2],[1],[]]) :| [[1,2] :| [[1],[]],[1] :| [[]],[] :| []]
16:45:54 <hs_newb> :t (\f -> scanl1 (<>) . map f)
16:45:55 <lambdabot> Monoid a1 => (a2 -> a1) -> [a2] -> [a1]
16:46:07 <hs_newb> mniip: this works for me :)
16:47:51 <mniip> that only works for lists...
16:48:01 <mniip> also eww scanl1
16:48:12 <mniip> at least try to be decent and say scanl mappend mempty
16:48:23 <hs_newb> mniip: what's wrong with scanl1
16:48:34 <mniip> not really anything but
16:48:34 <hs_newb> yeah i know it's not generic in Foldable
16:48:56 <mniip> just nitpicking
16:49:11 <mniip> welcome to #haskell after all
16:50:08 <hs_newb> mniip: yes but i don't understand the nitpick; is there anything undesirable about scanl1
16:50:24 <mniip> it skips the basecase
16:50:31 <dmwit> scanl1 is fine
16:50:48 <hs_newb> right i don't actually need the empty list
16:51:07 <dmwit> You might think it's not fine by analogy to "foldr is fine but foldr1 is not fine". But it's a leaky analogy.
16:51:20 <dmwit> > scanl1 (<>) [] :: [()] -- not partial
16:51:22 <lambdabot>  []
16:53:46 <hs_newb>  > scanlMap Sum []
16:54:27 <hs_newb> uh how does the bot eval
16:54:34 <dmwit> You have an extra space at the beginning.
16:54:45 <hs_newb>  > scanlMap Sum []
16:54:51 <hs_newb> > scanlMap Sum []
16:54:53 <lambdabot>  Sum {getSum = 0} :| []
16:55:12 <hs_newb> > scanlMap Sum [1,10, 5]
16:55:13 <lambdabot>  Sum {getSum = 0} :| [Sum {getSum = 5},Sum {getSum = 15},Sum {getSum = 16}]
16:55:40 <dmwit> That... is a strange result ordering.
16:55:49 <hs_newb> > scanRMap Sum [1,10, 5]
16:55:51 <lambdabot>  error:
16:55:51 <lambdabot>      • Variable not in scope:
16:55:51 <lambdabot>          scanRMap :: (a0 -> Sum a0) -> [Integer] -> t
16:55:55 <mniip> seems natural
16:56:27 <mniip> > scanl (+) 0 [1, 10, 5]
16:56:29 <lambdabot>  [0,1,11,16]
16:56:30 <mniip> > scanr (+) 0 [1, 10, 5]
16:56:32 <lambdabot>  [16,15,5,0]
16:56:43 <mniip> hmm
16:56:45 <hs_newb> mniip: right it's reverse . scanlMap
16:56:53 <mniip> > scanrMap Sum [1,10, 5]
16:56:56 <lambdabot>  Sum {getSum = 16} :| [Sum {getSum = 11},Sum {getSum = 1},Sum {getSum = 0}]
16:57:09 <mniip> that's not exactly as it should be...
16:57:26 <mniip> I think I mixed up r and l
16:57:54 <hs_newb> also the list is reversed 
17:09:57 <aleph_null> hi, if I use 'show' on a variable it seems to make the use of overloaded strings impossible. Why does this happen?
17:10:49 <mniip> probably because you have an ambiguous type
17:11:10 <mniip> make sure the typechecker can understand which type is being shown/fromstring'd
17:11:42 <monochrom> Show actual code.
17:12:09 <monochrom> "Plain English" is not to be trusted.
17:13:55 <monochrom> There was once a a programmer whining about some OS/2 API doc. He wrote "why doesn't it just tell me, in plain English, which functions to call, in what order"
17:14:16 <monochrom> But dude, in plain English, functions are held or attended, not called.
17:16:31 <aleph_null> monochrom: http://lpaste.net/360713 this here for example
17:17:22 <monochrom> This is because OverloadedString is for literals not for arbitrary expressions.
17:17:47 <aleph_null> is there any way I can get an expression into a string literal?
17:17:58 <monochrom> No.
17:18:19 <monochrom> Do you know what's a literal?
17:18:52 <Lokathor> you could put double quotes around it, but then it's a string, and not any other kind of expression
17:19:42 <aleph_null> okay, thanks
17:19:47 <benzrf> aleph_null: think about it this way - if you write 3.5, that piece of code can be used in the place of a Double or in the place of a Float, but if you define a variable of type float to be some value, you can't use that variable as a double
17:27:52 <dmwit> aleph_null: `md5 (fromString testString)`
17:28:23 <dmwit> aleph_null: Also this is very dangerous, and you should instead look into paying proper attention to encodings, since I bet `md5` works on `ByteString`s and not an actual textual type.
17:28:36 <dmwit> ?hoogle fromString
17:28:36 <lambdabot> Data.String fromString :: IsString a => String -> a
17:28:36 <lambdabot> GHC.Exts fromString :: IsString a => String -> a
17:28:37 <lambdabot> Data.Text.Internal.Builder fromString :: String -> Builder
17:35:23 * hackage haskell-tools-ast 1.0.0.2 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-1.0.0.2 (lazac)
17:36:53 * hackage haskell-tools-backend-ghc 1.0.0.2 - Creating the Haskell-Tools AST from GHC's representations  https://hackage.haskell.org/package/haskell-tools-backend-ghc-1.0.0.2 (lazac)
17:38:23 * hackage haskell-tools-builtin-refactorings 1.0.0.2 - Refactoring Tool for Haskell  https://hackage.haskell.org/package/haskell-tools-builtin-refactorings-1.0.0.2 (lazac)
17:41:03 * hackage haskell-tools-cli 1.0.0.2, haskell-tools-daemon 1.0.0.2 (lazac): https://qbin.io/lbal73ad8
17:43:17 * hackage haskell-tools-debug 1.0.0.2, haskell-tools-experimental-refactorings 1.0.0.2, haskell-tools-prettyprint 1.0.0.2, haskell-tools-rewrite 1.0.0.2, haskell-tools-refactor 1.0.0.2 (lazac): https://qbin.io/rgbuneewc
17:44:26 * hackage haskell-tools-demo 1.0.0.2 - A web-based demo for Haskell-tools Refactor.  https://hackage.haskell.org/package/haskell-tools-demo-1.0.0.2 (lazac)
17:46:23 * hackage dumb-cas 0.1.2.0 - A computer “algebra” system that knows nothing about algebra, at the core.  https://hackage.haskell.org/package/dumb-cas-0.1.2.0 (leftaroundabout)
17:53:32 <woodson> hi guys, I am following this tutorial http://www.parsonsmatt.org/2016/07/08/servant-persistent_updated.html and I am getting an error saying that Nat is not part of servant. 
17:54:33 <woodson> how do I convert newtype App a    = App    { runApp :: ReaderT Config Handler a    } deriving ( Functor, Applicative, Monad, MonadReader Config,MonadError ServantErr, MonadIO)
17:54:49 <woodson> to convertApp :: Config -> App a -> Handler a
17:54:50 <lyxia> @lpaste
17:54:50 <lambdabot> Haskell pastebin: http://lpaste.net/
17:54:58 <EvanR> :t runReaderT
17:54:59 <lambdabot> forall k r (m :: k -> *) (a :: k). ReaderT r m a -> r -> m a
17:55:28 <EvanR> youll have to solve a puzzle ^
17:56:17 <xarchx> what puzzle?
17:56:28 <EvanR> solve for r and m
17:56:38 <woodson> http://lpaste.net/360715
17:56:42 <woodson> I tried it already
17:56:47 <woodson> but I am getting this error
17:57:00 <EvanR> you didnt apply runApp to anything
17:57:08 <EvanR> its a field accessor
17:57:18 <EvanR> where is your App
17:58:15 <mniip> :t \ReaderT{..} -> runReaderT
17:58:16 <woodson> oooohh 
17:58:17 <lambdabot> error:
17:58:17 <lambdabot>     Illegal `..' in record pattern
17:58:17 <lambdabot>     Use RecordWildCards to permit this
17:58:20 <mniip> aw
18:02:56 <woodson> I am getting more errors now
18:03:11 <EvanR> ok, read the errors
18:03:55 <woodson> it acually work the runReaderT so I guess that it lift my type
18:05:58 <lambdamu_> I just love how the Writer monad keeps on leaking space year after year,
18:06:04 <woodson> I am getting this http://lpaste.net/360717
18:07:37 <kakashiAL> I am learning haskell and try to use the principles that I learn from in haskell
18:07:47 <kakashiAL> in my javascript projects
18:09:49 <woodson> I am confuse with this tutorial 
18:10:07 <kakashiAL> but is there a functional solution for this case:  1. check if data is an object, 2. sanitize data, 3. validate data, if data is not valid throw an error, if data is valid, do nothing, 4. save sanitized data in database
18:10:35 <woodson> he wants to userServer :: ServerT UserAPI App so why return the function that converts App to Handler
18:10:48 <EvanR> sanitize doesnt sound right ever
18:11:19 <kakashiAL> EvanR: however, as you can see I have 4 steps, at the moment I have 4 function calls
18:11:20 <EvanR> 3. validate data, if data is not valid throw an error, if data is valid save in database
18:12:10 <kakashiAL> EvanR: wait a second, I will upload an example
18:13:53 * hackage quickcheck-classes 0.3 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.3 (andrewthad)
18:16:20 <kakashiAL> EvanR: https://paste.xinu.at/lzi/js
18:17:51 <kakashiAL> EvanR: https://paste.xinu.at/Dd6vh/js
18:25:53 * hackage hpack 0.21.1 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.21.1 (SimonHengel)
18:32:11 <monochrom> Most Haskell programmers would consider "check, sanitize, validate, extract" as one single thing called "parsing".
18:33:09 <monochrom> As a benefit they wouldn't need to invent intermediate "checked but not sanitized", "sanitized but not validated", "validated but not extracted" spurrious interminated states or formats.
18:33:18 <whoman> sounds more like some tom clancy stuff  
18:33:31 <whoman> parsing FSM thats all 
18:33:45 <monochrom> And also it's one-pass rather than five-passes. (The difference between Turbo Pascal and Microsoft Pascal.)
18:34:28 <whoman> ghc or haskell ?
18:34:47 <mniip> monochrom, when was the last time you worked with the ghc api :p
18:35:33 <mniip> parseModule modSum >>= typecheckModule >>= desugarModule >>= loadModule
18:36:38 <kakashiAL> monochrom: okay, I see but never the less how can I remove/reduce my imperative code that I have now?
18:36:53 <monochrom> A compiler is complex and hairy enough to warrant splitting into those stages.
18:37:22 <monochrom> I haven't looked at your current code, and I have no plan to.
18:37:47 <monochrom> If you want to write like Haskell, then write like Haskell. Write a parser combinator library. Then use it.
18:37:53 <geekosaur> also parsing is the first step; the other steps are rather more complex than just sanitising/validation
18:38:53 <aplainzetakind> What does GHC being unregistered mean?
18:39:02 <monochrom> Look for Hutton and Meijer's "monadic parser combinators" paper and port it to Javascript.
18:39:29 <koz_> Alternatively NPM probably had like 20 variations on that theme.
18:39:38 <kakashiAL> monochrom: I just would like to know, what is the functional way to do this:  run foo()  run bar() and after that run baz()   <---because this is for me very imperative
18:39:46 <geekosaur> aplainzetakind, unregisterised means it generates portable but unoptimized ANSI C, or it generates "plain" unoptimized LLVM IR
18:40:25 <dmwit> kakashiAL: Depending on the types, `baz . bar . foo` or `foo >> bar >> baz` seem like reasonable choices.
18:40:43 <monochrom> As for compilers, note that the splitting is not the kind of fine-hair-splitting "one stage for checking your let-in syntax is right, another stage for checking your do-notation is right, ..." that plagues many imperative programmers and their idea of checking and then extracting data.
18:41:11 <geekosaur> "registerised" is kinda a holdover from when the main optimization was making as much stuff as possible be in CPU registers instead of memory. it's been inaccurate for over a decade, and even more inaccurate since ghc switched to direct compilation iunstead of generating nasty C and feeding the result through an ugly perl script)
18:41:38 <monochrom> That depends on what really foo, bar, baz are. Insufficient data for a meaningful answer.
18:41:50 <mniip> daily reminder that it's registerised, no registered
18:41:57 <monochrom> In other words no there is no blanket universal answer other than "it depends".
18:43:01 <jle`> kakashiAL: by the way, if you're talking directly on the algorithm level, it doesn't make sense to just directly translate an imperative algorithm into a functional algorithm
18:43:06 <jle`> an imperative algorithm is inherently imperative
18:43:18 <monochrom> But I can explain and sympathize why imperative programmers splinter parsing into so many spurrious stages.
18:43:21 <jle`> if you want an functional way of doing a goal, it's going to be a different algorithm usually
18:43:35 <monochrom> It is because their inferior languages are hostile to parser combinator libraries.
18:43:52 <jle`> kakashiAL: there are multiple paths to get to an end goal, and it's not like you "translate" one path to another
18:43:55 <geekosaur> enh. a lot of it is just people copying a pattern that was intended specifically for tinytiny PDP11 processes
18:45:08 <monochrom> Take a look at Haskell's aeson library or cassava library for example. Look at its source code, there is no way you could write like that in C. And look at its API, there is no way you could use an API like this in C.
18:47:07 <kakashiAL> dmwit: this is composition, but that now what I need because what I have is this:
18:47:10 <kakashiAL> 1. check if you get an object, if not throw, if it is an object go to the next line (do nothing)
18:47:12 <kakashiAL> 2. validate date, if data is not valid throw an error if not go the next line
18:47:14 <kakashiAL> 3. save data in database
18:48:50 <jle`> kakashiAL: why not something like savenDatabase (parse  (input) )
18:48:54 <jle`> *saveInDatabase
18:49:36 <monochrom> If you set up a suitable monad for that, that would be a pretty vanllla do-blcok.
18:49:57 <monochrom> Just took a look at aeson (either its implementation or its usage)
18:50:06 <jle`> you probably don't even need a monad for something like a monad for something like this, this is basically function composition
18:50:23 <jle`> at best maybe a Functor/Traversable would be useful
18:50:55 <monochrom> Well the possibility of having an error case and branching out is not going to fit well with mere function composition.
18:51:08 <monochrom> But it fits perfectly with >>=
18:51:52 <jle`> mapM_ saveInDatabase (parse input)
18:52:34 <monochrom> Oh you have one single "parse" for all the checks. OK you're right.
18:52:35 <jle`> but i am speculating still, admittedly, about what is really going on
18:52:53 <jle`> yeah, parse takes an input whatever and returns Maybe a valid thing
18:53:14 <jle`> case parse inp of
18:53:18 <jle`>   Just o -> saveInDatabase o
18:53:24 <jle`>   Nothing -> putStrLn "something went wrong"
18:53:36 <monochrom> But wait a second that's just hiding the parsing detail under the rug. "parse" itself will have to be implemented with the help of >>=, or else you will have an ugly ladder of case-of's
18:54:04 <jle`> yeah, that's true
18:54:22 <monochrom> But really, study aeson already. Or even better, use aeson already.
18:54:43 <jle`> my point i guess is that at a big-picture level, things already are kind of well-suited for a functional system
18:54:45 <kakashiAL> I dont realy understand your solutions, but just in case: my validator throws an error or does nothing
18:55:28 <jle`> kakashiAL: parse would take an input and return a `Maybe Result`, which is a value that may or may not contain a result.  then we just apply a function on that Maybe Result
18:55:42 <monochrom> We are precisely talking you out of that very anti-functional way.
18:55:44 <jle`> if there isn't a result, then do nothing, otherwise if there is one, save it to a database
18:56:14 <jle`> "throw an error" might be the same here as returning not-an-object from a function
18:56:51 <kakashiAL> jle`: could you write what you mean, for me its better if I can see it :)
18:57:15 <jle`> i wrote exactly what i meant earlier, but it might not be too useful for you without some familiarity with haskell syntax
18:57:21 <jle`> i wrote it in code, that is
18:58:10 <jle`> some very basic familiarity though, like the first page of a haskell introduction :)
18:59:50 <jle`> basically the fundamental tools of writing haskell, function application and pattern matching
19:01:06 <kakashiAL> jle`: I saw your code, but you forgot something: the validator only throws
19:01:40 <jle`> i'm saying that validation and parsing are combined into one step, 'parse'
19:01:49 <jle`> parse is guarunteed to only return a valid object
19:01:53 <kakashiAL> jle`: there is no parsing
19:02:49 <monochrom> Even in the imperative world, when people use regex, they don't use two regexes: "I use one regex to validate the string, but it is super-important that if it matches it does nothing! After that stage, I use a second regex to extract data."
19:02:56 <kakashiAL> jle`: ahh, I got you, you mean that the validator should return the object
19:03:02 <jle`> kakashiAL: call it checkAndSanitize then
19:03:12 <monochrom> So why are you still religiously segregating validation and extraction?
19:04:40 <geekosaur> monochrom, you'd be surprised
19:04:56 <geekosaur> saw those about once a week in #perl :)
19:04:57 <monochrom> I mean there are surely a few rare exceptions. But they tend to be very localized, rather than as an overarching design.
19:05:48 <geekosaur> people think in small steps. they program the same way
19:06:09 <monochrom> I am coming to understand why "XY problems" was coined by the Perl people.
19:07:35 <monochrom> I am no exception in that aspect. My difference is I reflect upon it and also learn from superior people.
19:07:44 <kakashiAL> monochrom: @why segregating validation and extraction: because of seperation of concerns
19:08:19 <monochrom> For example, if there is a function writable as a foldr, I usually can't conceive the foldr version first, I have to write the explicit recursion first.
19:08:38 <jle`> kakashiAL: this isn't an FP thing, but a functional thing, but -- in Haskell, we would extract our data into a data type
19:08:47 <jle`> where it is impossible to create an "invalid" data type
19:08:59 <jle`> a data type where impossible states or data are not representable
19:09:06 <jle`> so extraction *is* validation
19:09:16 <monochrom> But my difference with other people is that I will afterwards convert it to foldr (and then judge whether it's better or worse), whereas other people just declare "done".
19:09:42 <jle`> kakashiAL: but even if you do Stringly Typed programing (Pojo typed?), you could still write validate and extract as two Obj -> Maybe Obj, Obj -> Maybe Res
19:10:10 <jle`> and so checkAndSantize x = extract =<< check x, maybe
19:10:33 <kakashiAL> jle`: well, a good server architecture only accepts perfects requests, so if you give me something that is not valid you will get an error message
19:10:50 <monochrom> Separation of concerns is to be applied iff the two concerns are really independent.
19:11:03 <jle`> kakashiAL: yes, so functinoally you could just compose the checker and sanitizer.  but in a Haskell context, we'd parse requests into a data structure where only perfect requests can exist
19:11:19 <MarcelineVQ> monochrom: are you doing AoC this year?
19:11:24 <jle`> and so parsing the request *is* your validation, and your extraction
19:11:36 <jle`> if a request is a String, it'd be a function like String -> Maybe PerfectRequest
19:11:58 <kakashiAL> jle`: so in you rsolution, if I give you something "non perfect" you will let me know, right?
19:11:59 <jle`> because it'd be impossible to parse something that is invalid or imperfect
19:12:05 <monochrom> But extraction presupposes validation, like "head of list" presupposes the "not empty" check.
19:12:06 <jle`> kakashiAL: yes because it'd be unparseable
19:12:19 <monochrom> Separating them is a false seperation.
19:12:20 <jle`> so it'd return Nothing, a no-perfectrequest-is-here value
19:12:40 <jle`> kakashiAL: if someting returns a Maybe X, then it returns a value that either has an X, or doesn't
19:12:52 <jle`> so if an X is impossible to create from that input, it'd return Nothing (no X)
19:13:08 <jle`> if it is possible, then it gives you an X you can access and use via pattern matching
19:13:11 <monochrom> You should read my http://www.vex.net/~trebla/haskell/crossroad.xhtml#philosophy for this.
19:13:58 <monochrom> And this still doesn't preclude the option that, inside the parser, you still have a few rightfully separate concerns.
19:14:09 <jle`> kakashiAL: if you parse your thing into a type that can only store valid data by construction, then there's no point even in validating
19:15:46 <monochrom> Actually s/independent/orthogonal/
19:16:43 <jle`> kakashiAL: for example, consider the situation where we parse a list into a tuple which would contain the first two items of a list
19:16:48 <jle`> you might write something like
19:16:57 <jle`> parseList (x:y:_) = Just (x,y)
19:17:01 <jle`> parseList []    = Nothing
19:17:13 <jle`> there isn't really any point in "validating that the input has exactly two items first, and throwing an error"
19:18:04 <jle`> because the result type, (a,a), is only possible to create with two items.     (well it's possible to create with one, but...this might not be the perfect example)
19:20:56 <kakashiAL> jle`: maybe I have to redesign my validator, but at the moment its like this (tell me how to redesign it): 
19:21:00 <kakashiAL> validate(data)
19:21:03 <kakashiAL> - if validation failed, I can run an function (I throw an error here)
19:21:05 <kakashiAL> - if validation failed, I get an an object back, with validate(data).isValid, validate(data).errorType (which can be 'VALIDATION', 'MISSING_REQUIRED' or 'UNKNOWN_KEYS'
19:21:07 <kakashiAL> - if validation is okay, I only get an object validate(data).isValid == true
19:23:37 <jle`> kakashiAL: you can parse your data into a type that is constructed such that it is impossible to represent invalid data
19:26:42 <aplainzetakind> jle
19:27:14 <aplainzetakind> I'm generally curious about how that can be achieved in certain cases.
19:28:03 <aplainzetakind> Say data NameAndBirthyear = NBY String Int
19:28:34 <aplainzetakind> Wow do you make absurd years unrepresentable?
19:29:59 <monochrom> That one is much harder. I would usually just resort to runtime checks at boundaries.
19:30:36 <monochrom> But if I want a binary tree, I can easily define an algebraic data type that precludes tenary trees for example.
19:31:37 <monochrom> But if it has to be a binary search tree too, I would resort to runtime checks and/or smart constructors aka careful algorithms.
19:34:01 <aplainzetakind> Smart constructors seem satisfactory mostly.
19:39:35 <geekosaur> I wouldn;t even bother with absurd years... because at some point they might not be absurd any more
19:40:08 <monochrom> hee hee
19:40:41 <geekosaur> granted if it's a transaction date in a webstore then you can make some assumptions... but I've seen too many database setups get extended to historical data, or assume people never live in the previous century [ok, right now that one is unlikely, but I was doing databases in 1985])
19:40:48 <DigitalKiwi> did you ever read the article the mongodb guy wrote about implementing dates
19:41:12 <geekosaur> (also "19100")
19:41:21 <DigitalKiwi> hmm or was it even mongodb...
19:41:54 <geekosaur> I know http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time
19:47:37 <geekosaur> (honestly I had one customer who started adding historical records and git the Gregorian trap. Twice (subset for Russian data)
19:47:42 <geekosaur> *hit the
19:48:21 <geekosaur> (commercial package, not something I'd written.)
20:12:51 <Guest78> is there a library like Helm but more like Elm in that it targets JS?
20:52:58 <Average-user> glguy: preparing to AoC?
20:55:01 <glguy> Editor and GHCi are ready to go
20:59:06 <mniip> oh shoot
20:59:57 <Average-user> Is jle` streaming today?
20:59:58 <jle`> i'm trying to figure out what else i need to set up
21:00:08 <jle`> nah, not in a good location :'(
21:00:28 <Average-user> ohh
21:07:08 <glguy> OK, done, where's jle's feed?
21:07:16 <glguy> OH, I see "not in a good location"
21:07:33 <mniip> yay
21:07:35 <mniip> done
21:07:50 <mniip> all in ghci
21:07:53 <mniip> no files
21:10:51 <mniip> that was a fairly low amount of code
21:11:26 <mniip> I really liked the part where I reused part1 in part2 :p
21:11:40 <kadoban> mniip: What was the second bit?
21:11:52 <mniip> shh solve it yourself
21:12:16 <kadoban> Too lazy. I've written connected components enough times already xD
21:12:54 <mniip> count disjoint components in the graph
21:13:14 <kadoban> Oh okay. So ... the rest of connected components xD
21:13:39 <mniip> well you are asked the size of one, and the number of them
21:14:10 <kadoban> Not exactly stirringly creative, but could be worse.
21:14:23 <DigitalKiwi> the size of one is the number one
21:14:26 <mniip> I wrote  dfs :: String -> Set String
21:14:40 <mniip> solution to part1 is evident,
21:14:48 <mniip> solution to part2 involved  nub . map dfs
21:15:12 <kadoban> Heh, ya that'll work I suppose.
21:15:12 <mniip> xD
21:15:23 <kadoban> Pretty good idea in contest format really.
21:15:35 <mniip> carefully examine what objects we haven't walked over yet?
21:15:39 <mniip> nah just nub some sets
21:17:49 <mniip> hmm
21:17:51 <mniip> I wonder
21:18:11 <mniip> if I could use loeb to find some sort of closure under union
21:18:25 <mniip> as a dfs-but-you-don't-really-say-it
21:18:37 <kadoban> loeb?
21:18:44 <mniip> @where loeb
21:18:44 <lambdabot> I know nothing about loeb.
21:18:54 <mniip> https://github.com/quchen/articles/blob/master/loeb-moeb.md
21:19:38 <kadoban> Oh those, heh. Ugh, I have no idea.
21:21:01 <mniip> really just thinking of a way to *not* write explicit dfs recursion
21:21:10 <mniip> I mean isn't this what haskell is about
21:21:24 <kadoban> Not really xD
21:24:43 <mniip> yes really
21:24:46 <mniip> conn x = go S.empty where go s y | y `S.member` s = False | y == x = True | Just ts <- lookup y ind = any (go (S.insert y s)) ts
21:24:59 <mniip> now get rid of set
21:25:15 <mniip> conn x = go [] where go s y | y `elem` s = False | y == x = True | Just ts <- lookup y ind = any (go (y:s)) ts
21:25:53 <mniip> it's much more slow!
21:26:43 <jle`> 707/566  :(
21:27:00 <jle`> part 2 basically completely re-used part 1
21:27:35 <jle`> well i wrote a function (Int -> S.Set Int), a number to the set of all items connected to that number
21:27:44 <jle`> and then just S.map'd that function over the set of all numbers
21:27:49 <jle`> so that wasn't too efficient but it worked hehe
21:28:21 <jle`> S.map :: (Int -> S.Set) -> S.Set Int -> S.Set (S.Set Int), definitely not something i ever execpted i'd be doing
21:28:34 <mniip> hah
21:28:38 <mniip> close enough to mine
21:29:16 <Lokathor> i took the keys of the mapping, and then deleted a key each time i stepped to it in my flood fill
21:29:22 <Lokathor> and if the flood fill ended that was +1 group
21:29:26 <Lokathor> until there were no keys left
21:29:42 <mniip> that's the classical one
21:29:59 <mniip> hmm looks like I just wrote a cubic solution
21:30:05 <Lokathor> no good!
21:30:48 <hexfive> if i have an `f :: Either String a` and `g :: a -> IO ()`, is there any way to mix these together within an `IO ()` function? i was trying to do something like `f >>= g` but it appears i'm fundamentally misunderstanding how this is supposed to work :\
21:31:16 <jle`> hexfive: you just need to match the types
21:31:19 <jle`> also what is an IO () function
21:31:31 <jle`> an `IO ()` is not a function
21:31:31 <Axman6> traverse
21:31:51 <jle`> traverse_ :: (a -> IO ()) -> Either String a -> IO ()
21:31:53 <Axman6> :t traverse (undefined :: a -> IO ())
21:31:54 <kadoban> hexfive: What do you want to happen if it's a Left ?
21:31:55 <lambdabot> Traversable t => t a -> IO (t ())
21:32:01 <hexfive> ok, whatever the name for a thing with a type of `IO ()` such as main, i'm unsure
21:32:07 <mniip> action
21:32:12 <Axman6> actually, foldMap
21:32:14 <jle`> or also just 'value'
21:32:14 <hexfive> i would like it to fail probably
21:32:18 <hexfive> with the Left value
21:32:24 <Axman6> :t foldMap (undefined :: a -> IO ())
21:32:25 <lambdabot> Foldable t => t a -> IO ()
21:32:34 <jle`> traverse :: (a -> IO b) -> Either String a -> IO (Either String b)
21:32:48 <Axman6> :t foldMap (undefined :: a -> IO ()) `asAppliedTo` (Left "Hello")
21:32:48 <jle`> traverse_ :: (a -> IO ()) -> Either String a -> IO ()
21:32:49 <lambdabot> Either [Char] a -> IO ()
21:32:55 <jle`> pick the behavior you want :)
21:33:02 <hexfive> i shall try :) thanks
21:33:23 <Axman6> hexfive: the answer to your question really depends on what to do in the Left case though
21:33:38 <jle`> hexfive: alternatively you can just do the simple thing, and pattern match on 'f'
21:35:02 <mniip> am I not too late
21:35:09 <mniip> g . fromRight f
21:35:14 <mniip> :D
21:35:28 <hexfive> ooh, traverse_ looks perfect. thanks a bunch jle` 
21:37:46 <jle`> no problem!
21:39:59 <jle`> my part 2 was a bit scary because i wrote it so inefficiently that the first time i ran it i thought i had written an infinite loop
21:42:35 <cocreature> jle`: huh, I thought I had already chosen the dumbest possible implementation for part 2 and it works instantly
21:42:57 <cocreature> did you use lists as sets or something like that? :)
21:42:57 <jle`> my part 2 is probably the second dumbest possible
21:43:01 <jle`> it must be my part 1
21:43:36 <glguy> after submitting I went back and switched my solution to use fgl
21:43:49 <jle`> yes this sounds like a nice thing to use to learn fgl
21:44:16 <jle`> cocreature: my part 1 was basically making several passes through the lines, filling up a set if there was anything matching in a line
21:44:24 <jle`> and then i repeated the passes until there was no change
21:44:51 <cocreature> ah I think mine is slightly smarter
21:45:09 <jle`> heh yeah i'm suspecting that my bad runtime came from that
21:45:55 <mniip> I've used fgl once before
21:46:58 <jle`> i read the docs once before
21:47:22 <mniip> no like I have a program over here that does shortest path search via fgl
21:47:29 <mniip> for a practical problem
21:47:47 <jle`> hm my first failing solution was actually to build a graph
21:48:01 <jle`> and i realize that if i had made one adjustment, it would have actually worked
21:52:46 <vaibhavsagar> cocreature: I used lists as sets :)
21:53:17 <vaibhavsagar> lots of `nub`bing everywhere, although I did use `ordNub` which is a bit nicer
21:53:38 <vaibhavsagar> my part 1 and 2 were incredibly naive but surprisingly fast
21:53:48 <platz> my part2 was pretty slow
21:53:55 <platz> sets and maps
21:54:07 <vaibhavsagar> what was your algorithm?
21:54:41 <platz> first thing that came to mind, map over every value and find their groups, make a set of those groups
21:56:13 <platz> hmm, ok with -O2 its about 400ms
21:56:14 <cocreature> vaibhavsagar: too lazy to import containers? :)
21:56:22 <cocreature> huh, fgl makes this pretty boring
21:56:28 <cocreature> just throw "dfs" at it and be done with it
21:56:33 <vaibhavsagar> cocreature: I wanted to use `map`
21:56:58 <cocreature> vaibhavsagar: you can map over sets as well
21:57:19 * vaibhavsagar is embarrassed now
21:58:36 <cocreature> vaibhavsagar: no need to be embarrased. I was just curious why you chose lists since sets don’t seem to make anything harder in this context
21:58:46 <cocreature> and part2 using fgl is just "components"
21:59:04 <glguy> cocreature: there are ever so slightly simpler functions in fgl for both parts than those!
21:59:38 <cocreature> glguy: oO, simpler than "components"? that seems to be about as simple as you can get for part 2
21:59:58 <glguy> yeah, crazy, huh? :)
22:00:07 <cocreature> *stares at glguy’s github repo*
22:00:23 <glguy> and note that I did say "ever so slightly"
22:00:47 <cocreature> heh
22:00:59 <cocreature> although for part 1 I’m not sure reachable is really simpler than dfs :)
22:01:11 <glguy> It cuts out the list you have to make
22:01:15 <vaibhavsagar> cocreature: I was more comfortable using Data.List.(\\) and nub
22:01:25 <cocreature> vaibhavsagar: fair enough :)
22:22:54 * hackage chell 0.4.0.2 - A simple and intuitive library for automated testing.  https://hackage.haskell.org/package/chell-0.4.0.2 (JohnMillikin)
22:23:23 * hackage chell-quickcheck 0.2.5.1 - QuickCheck support for the Chell testing library  https://hackage.haskell.org/package/chell-quickcheck-0.2.5.1 (JohnMillikin)
23:37:12 <osa1> anyone here have experience with unagi-chan? the documentation says Unagi.Bounded provides both blocking and non-blocking writes but I can't see non-blocking write function
23:38:25 <liste> osa1: tryReadChan
23:38:38 <osa1> liste: I mean write not read
23:39:17 <osa1> documentation says "a bounded variant with blocking and non-blocking writes" but I don't see a non-blocking write function
23:39:19 <liste> oh, sorry
23:39:22 <liste> I misread
23:39:51 <liste> tryWriteChan: "This function never blocks, but may occasionally write successfully to a queue that is already "full""
23:46:09 <ongy> is there a standard type for Something roughly `data Both a = Left a | Right a | Both a a`?
23:46:35 <vaibhavsagar> ongy: `these`
23:46:55 <vaibhavsagar> ongy: https://hackage.haskell.org/package/these-0.7.4/docs/Data-These.html
23:47:13 <ongy> thx
23:47:26 <vaibhavsagar> also look at the various diff packages
23:48:17 <vaibhavsagar> ongy: for an overview, see http://teh.id.au/posts/2017/03/29/these-align-crosswalk/index.html
23:49:18 <osa1> liste: right .. I guess it doesn't provide the function I need. I need writeChan that always writes, dropping the oldest element in the chan when necessary (i.e. when chan is already full)
23:49:54 <osa1> tryWriteChan doesn't always write to the chan so that's not what I mean .. I now realize that my question wasn't clear enough.
