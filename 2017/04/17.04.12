00:00:05 <thang1> quchen: that's a good point. I haven't gotten to the point where I really get types vs kinds yet, so I haven't run into that tripping me up yet
00:00:06 <nshepperd> Nothing :: Maybe t can be a value, or a type
00:00:32 <quchen> thang1: values have types, types have kinds, kinds have sorts, and the named hierarchy ends here.
00:01:07 <thang1> ahh right, thanks.
00:01:21 <thang1> I keep forgetting some of the most profound concepts in haskell are really just stupidly simple
00:01:56 <quchen> The naming of the hierarchy using 3 synonyms is probably not the best scheme ;-)
00:02:18 <thang1> Eh, worse ones have been used before :p
00:02:41 <thang1> joe9: To be perfectly honest. I would suggest LH over Curry
00:03:26 <thang1> Curry doesn't have a whole lot of really good beginner documentation on it. People say that Haskell is a research programming language but Curry is /really/ a research programming language.
00:03:26 <quchen> In Agda for example, you have   true : Bool, Bool : Set, Set : Set1, Set1 : Set2, ‚Ä¶
00:03:47 <quchen> So Set roughly corresponds to Haskell‚Äôs types, Set1 is like kinds, and so on.
00:03:54 <thang1> ‡≤†_‡≤†
00:04:18 <thang1> But /why/
00:04:23 <quchen> Because why not!
00:04:39 <thang1> Can you just keep going on up to SetN? Or does it stop at 2?
00:04:48 <quchen> It goes up to eleven
00:04:51 <thang1> https://jeltsch.wordpress.com/2013/04/27/a-taste-of-curry/
00:05:04 <quchen> thang1: Okay, not really. It goes up all the way.
00:05:15 <nshepperd> it goes on until you get tired
00:05:31 <thang1> okay. I wasn't sure if that was a spinal tap reference or not
00:05:36 <quchen> The index is there to avoid having ¬ªSet : Set¬´, which is Russell‚Äôs Paradox in type theory.
00:05:46 <quchen> It was. :-)
00:05:57 <thang1> Even if it was actually how that worked, I /still/ wouldn't be sure if that was a spinal tap reference or not... :p
00:06:00 <thang1> programmers are nerdy
00:06:48 <quchen> Here is a function that gives you a type that has a value iff the list has an element:    IsEmpty : [a] -> Set; IsEmpty [] = Void; IsEmpty _ = ()
00:06:53 <thang1> Makes sense. I guess if I was going to allow for an infinite chain of type hierarchies, I'd name it some generic thing and then an index...
00:07:08 <nshepperd> it might go up to eleven! kind of hard to imagine needing an element of Set11 that isn't Set10 though
00:07:49 <quchen> Usually, you use sets of level Œ±, Œ≤, and (max Œ± Œ≤).
00:07:50 <quchen> :-)
00:08:14 <quchen> Lists in Haskell can contain only homogeneous values of types of kind *, for example.
00:08:31 <rjeli> the good ol scala way
00:08:32 <rjeli> Tuple23
00:08:55 <quchen> In a dependently typed language, you can have homogeneous lists of values of any type. And Set is a type, so it‚Äôs perfectly reasonable to have a list containing [Bool, Int].
00:09:05 <quchen> In Haskell we can do this as well, using promoted data types.
00:09:15 <thang1> Really? That's cool
00:09:16 <quchen> The type-level list would be written '[Int, Bool].
00:09:36 <quchen> Well, it‚Äôs with GHC extensions, so strictly speaking it‚Äôs not *Haskell*.
00:09:52 <thang1> Most modern haskell is written with a small army of extensions, anyway :p
00:10:24 <quchen> Hm, I‚Äôm not so sure about that. Most extensions I use are syntactic ones.
00:10:36 <quchen> I certainly don‚Äôt use type families all over the place.
00:11:22 <thang1> I suppose the extension use is less pervasive than it appears to be. To me, it seems like a ton of code I see in places have at least 2-3 pragmas in most files
00:11:40 <thang1> I've seen more than 5 fairly often as well
00:12:15 <quchen> Yes, but not all of them are heavyweights like TypeInType or UndecidableInstances :-)
00:12:21 <quchen> BangPatterns for example
00:12:32 <quchen> LambdaCase, PackageImports
00:12:47 <quchen> RankNTypes
00:12:54 <thang1> True. Syntactic niceities definitely make up the majority of stuff I would use
00:13:16 <thang1> (who doesn't love writing less code, anyway?)
00:13:40 <thang1> I've become a fan of writing obscenely terse code. But not for the sake of terseness; rather, for the sake of elegance of idea expression
00:14:09 <quchen> Just be careful not to make it too elegant :-)
00:14:57 <rjeli> i think optimizing for grokkability is elegant
00:14:59 <rjeli> which isnt always terse
00:15:02 <thang1> If it's too elegant, it turns into pure haskell which is only meant to be written once and then admired from afar; a perfect diamond which one will nevefr understand
00:15:10 <thang1> (/s)
00:16:41 <quchen> When prototyping, I usually have crappy 20-line diamonds with comments and crappy names and TODOs, decorated with a simple type signature.
00:17:00 <quchen> And then the cooking begins :-)
00:17:06 <rjeli> would it be possible to use Curry for business logic
00:17:11 <rjeli> or is it for constrained domains
00:18:55 <thang1> You should have full power over business logic with Curry
00:19:02 <thang1> (https://jeltsch.wordpress.com/2013/04/27/a-taste-of-curry/ see this for a neat toy example)
00:19:24 <rightfold> I asked someone about zipping optics some time ago here, I think I found it: https://pursuit.purescript.org/packages/purescript-profunctor-lenses/3.1.0/docs/Data.Lens.Grate#v:zipWithOf
00:24:55 <thang1> rjeli: https://www.cs.princeton.edu/courses/archive/spring17/cos333/knuth-mcilroy.pdf
00:25:28 <thang1> My favorite example for elegance and grokkability
00:42:26 <Guest28734> how is functional programming these days
00:42:47 <rightfold> Guest28734: that's a very broad question
00:43:51 <kadoban> Guest28734: Pretty functional
00:43:53 <Guest28734> ok. how is haskell
00:44:07 <rightfold> It's fun
00:44:42 <halogenandtoast> It changed my life.
00:44:55 <halogenandtoast> I went from being bored to being slightly less bored.
00:45:36 <thang1> I learned how to write a factorial function in 2 lines of code /s
00:45:56 <thang1> (fuck I got distracted again) g'night for real 
00:47:17 <rightfold> The time originally spent debugging is now spent learning
00:47:27 <quchen> thang1: \n -> product [1..n]?
00:47:53 <halogenandtoast> quchen: that's one line of code :p
00:48:03 <quchen> Add newlines as desired
00:48:50 <rightfold> Put "memoize $" on the line before it
00:50:03 <halogenandtoast> I'm assuming thang1 meant fac 1 = 1; fac n = n * fac (n - 1); but that would be a partial function
00:50:41 <rightfold> Actually would be total if n :: Int
00:50:41 <halogenandtoast> well I guess it's not partial
00:51:02 <halogenandtoast> rightfold: yeah I derped too quickly
00:51:07 <rightfold> Wrap on underflow :P
00:51:39 <quchen> If your stack has that many frames you can even use it
00:51:52 <quchen> > maxBound :: Word64
00:51:54 <lambdabot>  18446744073709551615
00:51:56 <rightfold> It's sometime I wanted for some time
00:52:05 <rightfold> Detecting base cases that don't consider negative inputs
00:52:15 <rightfold> It's a common mistake
00:52:33 <lpaste> halogenandtoast pasted ‚ÄúParseMove.hs‚Äù at http://lpaste.net/354529
00:52:35 <halogenandtoast> Any suggestions on how to make that less redundant? ^^
00:52:57 <halogenandtoast> a `where` wouldn't be shared right?
00:53:37 <rightfold> halogenandtoast: it wouldn't but you can use case
00:53:44 <halogenandtoast> ah right
00:53:47 <rightfold> Or lambdacase even if you're into that
00:53:59 <halogenandtoast> rightfold: Only on the weekends.
00:54:03 <rightfold> Alternatively you can do
00:54:05 <quchen> Or you could drop the leading ¬ªf¬´ before using your function
00:54:20 <Guest28734> could u use functional programming to build a rocket
00:54:35 <rightfold> Just . (if take 2 str == "f " then Flag else Reveal) $ ‚Ä¶
00:54:44 <rightfold> Or something like that
00:55:04 <rightfold> Guest28734: I think the hardware is a bigger problem
00:55:29 <halogenandtoast> > putStrLn "=>"
00:55:32 <lambdabot>  <IO ()>
00:55:35 <halogenandtoast> there rocket ^^
00:55:43 <Guest28734> haha
00:56:12 <rightfold> FP can even help you with the hardware
00:56:24 <rightfold> Look up cŒªash
00:57:25 <halogenandtoast> iirc old IBM chips had some problem, and they used FP afterwards to better test them to prevent errors.
00:57:26 <Guest28734> halogenandtoast: putStrLn isn't exactly functional though
00:57:41 <halogenandtoast> Guest28734: is it a function?
00:57:52 <rightfold> There's no reason a discipline of referential transparency couldn't get you to the Moon
00:57:53 <halogenandtoast> Then is passes the litmus test.
00:58:01 <halogenandtoast> s/is/it/
00:58:06 <quchen> putStrLn is exactly functional.
00:58:11 <Guest28734> it causes output to be displayed i mean
00:58:16 <halogenandtoast> Guest28734: it does not
00:58:22 <rightfold> putStrLn is a function that returns the same IO () when you give it the same String
00:58:32 <halogenandtoast> the result of putStrLn is compiler dependent
00:58:39 <quchen> It results in a primitive operation that, when used by the right runtime, might instruct it to print something.
00:58:41 <rightfold> Calling putStrLn returns a IO () value
00:58:43 <rightfold> That's all it does
00:58:53 <Guest28734> hmm
00:59:12 <rightfold> If you discard the IO (), and run the executable, nothing is printed
00:59:13 <halogenandtoast> Guest28734: WELCOME TO MY WORLD MWUH HA HA HA HA
00:59:14 <quchen> > let foo = putStrLn 5 in foo `seq` ()
00:59:16 <lambdabot>  error:
00:59:16 <lambdabot>      ‚Ä¢ No instance for (Num String) arising from the literal ‚Äò5‚Äô
00:59:16 <lambdabot>      ‚Ä¢ In the first argument of ‚ÄòputStrLn‚Äô, namely ‚Äò5‚Äô
00:59:22 <quchen> > let foo = putStrLn "hello" in foo `seq` ()
00:59:24 <lambdabot>  ()
00:59:25 <Guest28734> shove it into /dev/null
00:59:33 <quchen> putStrLn is evaluated, yet does not print anything.
01:00:39 <halogenandtoast> iirc the intermediate representation doesn't even have the IO part anymore.
01:00:58 <halogenandtoast> s/intermediate/compiled/
01:01:09 <halogenandtoast> somewhere in my words is what I'm trying to say.
01:01:21 <rightfold> If you're familiar with C# then IO T is analogous to Action<T> except there's no way to invoke it
01:01:44 <rightfold> Action<T> putStrLn(string s) is pure
01:01:56 <bollu> I think I only actually understood IO once I wrote a monadic DSL
01:02:43 <quchen> I only understood IO once I understood the STG, which is what the GHC runtime runs
01:02:59 <quchen> Luckily, it‚Äôs not terribly complicated :-)
01:03:09 <halogenandtoast> I **think** I understood IO once I read: https://wiki.haskell.org/IO_inside
01:04:05 <bollu> quchen: :) alternatively, I wrote a template instantiation machine interpreter, which is way simpler than STG but still lazy. Really made laziness click
01:04:21 <quchen> halogenandtoast: The key insight is that GHC compiles Haskell to something with fixed evaluation order. And that you can run perfectly well with side-effects, so you can put in proper IO. (All safety is out the window at this stage anyway.)
01:04:23 <bollu> quchen: inspired by STGi xD http://github.com/bollu/timi
01:04:40 <quchen> bollu: Cool!
01:05:04 <halogenandtoast> quchen: Ah very true.
01:06:08 <quchen> Unspecified evaluation order is just a compiler convenience so GHC can rearrange the code to its liking
01:07:18 <quchen> halogenandtoast: Much like you have a primitive function +# to add two ints, you have a primitive function print# (not sure what the actual name is) that prints something when forced
01:08:40 <quchen> Well, it‚Äôs not that simple (because of buffering and what not), but conceptually that‚Äôs it
01:14:22 <rightfold> Takes a handle actually
01:14:52 <quchen> putStrLn does a lot of things under the hood. One of them is printing things character-wise ;-)
01:15:18 <quchen> Well, handle them character-wise, at least. But that‚Äôs because of String.
01:18:55 <Guest91238> sure you could use a functional language to build a rocket but it wouldn't fly. running time too slow ahahhaa
01:19:18 <rightfold> Buffering, encoding, probably newline stuff, locale stuff maybe
01:19:19 <Guest91238> u like?
01:22:01 <rightfold> Wouldn't call it a pinnacle of SRP
01:24:42 <Cale> Guest91238: Given the budget for those things, you might want to use a functional language to write a one-shot compiler for the control system on one of those things though, so that you can do a bunch of additional verification.
01:26:23 <Cale> Guest91238: One of the things Haskell has been used for in industry has been this kind of metaprogramming approach to building realtime control systems (for hybrid hydraulic vehicles) that are timed correctly without need for a RTOS.
01:27:51 <rightfold> With linear types you can get referential transparency and mutations at the same time
01:27:54 <rightfold> With no runtime overhead of any kind
01:29:09 <Cale> Well, the idea here isn't to be writing Haskell or other functional code which will run directly on the embedded devices, but rather to use a Haskell program to generate the machine code for them.
01:29:53 <quchen> The downside of linear types is that you then have linear types.
01:29:59 <Cale> haha
01:30:01 <Cale> yeah
01:30:14 <rightfold> I've been playing with affine types lately
01:30:17 <rightfold> It's super rad
01:30:21 <Guest91238> hmm very clever
01:30:29 <Guest91238> shove it into /dev/null
01:30:53 <quchen> Linear types are interesting, but fairly restrictive for everyday programming
01:30:59 <bollu> what are affine types?
01:31:01 <ventonegro> http://ivorylang.org/
01:31:05 <bollu> quchen: rust diasgrees :]
01:31:21 <Cale> Rust is fairly restrictive for everyday programming
01:31:28 <quchen> I disagree that rust disagrees.
01:31:30 <rightfold> bollu: handwavy, they're like linear types but with an "at most once" restriction instead of "exactly once"
01:31:41 <bollu> quchen: oh?
01:31:54 <quchen> rightfold: That‚Äôs not really handwavy, that‚Äôs pretty much the definition :-)
01:31:57 <bollu> Cale: I don't feel that way having written a decent amount of Rust
01:31:58 <rightfold> So you can throw the cake in the garbage instead of being forced to eat it
01:32:14 <bollu> rightfold: where are you using this? and in which language?
01:32:18 <rightfold> But if you do eat it, you can't have it too
01:33:05 <Cale> bollu: I do my everyday programming in Haskell though, so I'm probably spoiled.
01:33:27 <quchen> I don‚Äôt think Rust is simple to use. I think it has a good reason for this though, since the problems its type system tries to solve are fairly hard to solve.
01:33:43 <rightfold> Needs some getting used to
01:33:56 <quchen> Sure. So did Haskell.
01:34:04 <rightfold> You have to decide when writing the data type how you're gonna use it
01:34:13 <rightfold> For example I'm writing a compiler in Rust
01:34:32 <rightfold> The AST is a recursive type, so I need some form of indirection or its size would be infinite
01:35:15 <rightfold> I need to decide what indirection I want, before I can use it. Unique ownership pointer, shared ownership pointer, non-owning pointer?
01:35:30 <rightfold> Went with non-owning because I'll use an arena to allocate the AST nodes
01:35:39 <bollu> rightfold: yes, but Rust has the correct types to encapsulate those
01:35:42 <bollu> rightfold: eg. Rc
01:35:44 <rightfold> But now I can't easily switch to some other scheme anymore
01:36:19 <rightfold> I abstracted the recursion into a different type (a la recursion schemes) so the sum type is still decoupled
01:37:26 <bollu> Cale: I'm liking C++11 onwards tbh
01:38:21 <Philonous> Is there an ETA for pi-types? 8.2 doesn't have them yet, AFAICS
01:38:43 <Iceland_jack> a few years Philonous
01:38:56 <Philonous> _Years_? That's disappointing :(
01:39:13 <Iceland_jack> Take a look at https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
01:39:32 <Iceland_jack> Good things come to those who wait
01:39:33 <Philonous> Thanks, reading
01:39:41 <Iceland_jack> (kind of)
01:40:39 <Philonous> Is that Richard Eisenberg's page? It doesn't say
01:40:46 <Iceland_jack> Yeah it is
01:41:14 <quchen> Pi types in Haskell? Is that planned?
01:41:21 <Philonous> Yes
01:41:26 <quchen> Woah
01:41:32 <Philonous> You can sort-of have them already
01:41:44 <Iceland_jack> Philonous: If you want a nice bedtime read, Richard's thesis is also out
01:41:53 <Philonous> Neat!
01:41:59 <Iceland_jack> http://cs.brynmawr.edu/~rae/papers/2016/thesis/eisenberg-thesis.pdf
01:42:14 <quchen> Richard‚Äôs thesis?! I¬†thought he‚Äôs been a researcher for ages
01:42:20 <quchen> Like post-postdoc levle
01:42:57 <Philonous> No, he's been working on -XTypeInType for his thesis 
01:43:11 <rightfold> *In*
01:43:32 <Iceland_jack> For those interested, Richard also has a draft about CONSTRAINED type families
01:43:37 <Iceland_jack> (and CLOSED type classes)
01:43:39 <Iceland_jack> http://cs.brynmawr.edu/~rae/papers/2017/partiality/partiality.pdf
01:43:42 <Iceland_jack> Very interesting
01:44:03 <Philonous> Man, if we take sway his PhD, will he do more amazing work to get it back? :>
01:44:08 <Philonous> away*
01:44:11 <Iceland_jack> haha
01:45:01 <Iceland_jack> "Almost got it Richard" *dangles tantalising carrot*
01:46:33 <rightfold> Yummy, raw carrot
01:46:44 <Iceland_jack> I found the parts on "matchability" from his thesis very interesting
01:47:46 <Iceland_jack> It's also a genuinely good overview of GHC features
01:49:28 <Philonous> And thus the ever-growing list grows yet again.
01:56:15 <bollu> is there another exposition on recursion schemes other than the original paper? I find the notation confusing, especially because he packages up everything inside Mu
01:56:25 <bollu> like, does that style of thinking actually make it intuitive?
02:17:02 <joncol> exit
02:18:55 <rightfold> bollu: the recursion is removed from the type
02:19:05 <rightfold> Now you need something else to add the recursion again
02:19:13 <rightfold> Mu is one of the things that can do that
02:19:19 <rightfold> Another useful one is Cofree
02:19:52 <rightfold> This is because the structure of Mu is known to the recursion schemes
02:20:03 <rightfold> But that of any custom recursive type isn't
02:21:09 <isthatit> I'm looking for a random number generator that uses /dev/random all the time
02:21:11 <isthatit> no seeding
02:21:12 <Iceland_jack> Cofree f () = Mu f
02:21:19 <isthatit> /dev/urandom*
02:21:26 * Iceland_jack . o O ( because right adjoints preserve ... )
02:21:50 <rightfold> Iceland_jack: I think Cofree f a ~ Mu (f </\> Const a)
02:21:56 <rightfold> Where </\> is functor product
02:23:30 <Iceland_jack> Sure
02:23:45 <Iceland_jack> (</\> is aka Product, from Data.Functor.Product)
02:23:57 <Iceland_jack> Free f Void is also equal to Fix f
02:24:05 * Iceland_jack . o O ( because left adjoints preserve ... )
02:24:12 <Iceland_jack> so there are many equations
02:26:02 <rightfold> Not sure if Product has an infix in Haskell
02:26:12 <rightfold> I'm a PureScript guy üôä
02:26:19 <Iceland_jack> You can use :*: if you want
02:26:24 <Iceland_jack> that's what GHC.Generics uses
02:26:53 <rightfold> Ah
02:26:55 <rightfold> Nice
02:27:26 <rightfold> ‚äó
02:28:41 <Iceland_jack> You can also write (Cofree f a = Mu (Compose ((,) a) f))
02:28:55 <rightfold> :)
02:33:50 <Myrl-saki> Functor product?
02:34:24 <Iceland_jack> data Product f g a = Pair (f a) (g a)
02:34:35 <Myrl-saki> Ah.
02:34:50 <Iceland_jack> Instead of a product (f, g) you add an argument (f a, g a)
02:37:35 <Iceland_jack> Similarly there is a sum of products, which is like (Either (f a) (g a))
02:37:46 <Iceland_jack> data Sum f g a = InL (f a) | InR (g a)
02:38:41 <Iceland_jack> Pair "hello" (Just 'a') :: Product [] Maybe Char
02:38:45 <Iceland_jack> Sum cannot be an Applicative or Alternative, unless we know more about the relationship between f/g
02:39:16 <Iceland_jack> If you want a sum with Applicative / Alternative there is a special case 'Lift = Sum Identity'
02:39:27 <Iceland_jack> data Lift g a = Pure a | Other (g a)
03:06:01 <pandinus> hii :)
03:11:02 <vritser> hello?
03:11:45 <vritser> i have a question.
03:12:12 <geekosaur> usually better to just ask it
03:12:18 <Jinxit> well we can't answer it until you ask it
03:12:53 <vritser> I am a novice
03:13:38 <vritser> i can't understand the method foldr
03:14:04 <Rembane> vritser: What parts of foldr can you understand?
03:15:18 <vritser> foldr f acc (x:xs) = f x (foldr f acc xs)
03:15:29 <vritser>  right =
03:16:18 <vritser> why not f (foldr f acc xs) x
03:16:36 <vritser> x is the acc?
03:16:56 <quchen> ¬ªacc¬´ is very misleading for foldr, since it does not have an accumulator.
03:17:01 <Iceland_jack> vritser: You can think of 'foldr' replacing (:) with f, and the empty list [] with acc
03:17:03 <quchen> Call it ¬ªrest¬´ or something.
03:17:12 <geekosaur> > foldr f z [a,b,c]
03:17:14 <lambdabot>  f a (f b (f c z))
03:17:22 <Iceland_jack> :t foldr (:) [] :: [a] -> [a]
03:17:25 <lambdabot> [a] -> [a]
03:18:23 <quchen> vritser: An example: insert many elements into a Set.  foldr Set.insert Set.empty [1, 2, 3] === Set.insert 1 (Set.insert 2 (Set.insert 3 Set.empty))
03:19:08 <Iceland_jack> vritser: Are you aware that [1,2,3,4] is sugar for (1:(2:(3:(4:[]))))
03:19:34 <vritser> yeah i know
03:19:44 <Iceland_jack> ok
03:20:44 <Iceland_jack> Let's replace (:), [] with (+), 0: (1+(2+(3+(4+0))))
03:21:16 <Iceland_jack> > foldr (+) 0 [a,b,c,d]
03:21:18 <lambdabot>  a + (b + (c + (d + 0)))
03:21:37 <Iceland_jack> That sums the elements of the list
03:21:41 <vritser> ok
03:21:52 <Iceland_jack> Let's replace (:), [] with (*), 1: (1*(2*(3*(4*1))))
03:21:57 <Iceland_jack> > foldr (*) 1 [a,b,c,d]
03:21:59 <lambdabot>  a * (b * (c * (d * 1)))
03:23:29 <rightfold> Replacing constructors is my hobby
03:24:20 <vritser> I try to understand
03:24:28 <vritser> Thanks.
03:25:22 <Iceland_jack> vritser: Consider how you would compute the length of a list like this
03:25:35 <Iceland_jack> We would want [1,2,3,4] to turn into (1 + (1 + (1 + (1 + 0))))
03:26:38 <vritser> I know, that's one implement of length
03:27:02 <Iceland_jack> vritser: What if you wanted to get the maximum element of a list?
03:29:19 <vritser> max head $ max tail
03:30:53 <vritser> o, they are the same
03:30:59 <vritser> yes?
03:31:34 <Iceland_jack> Consider what the maximum of the empty list should be
03:31:54 <vritser> shoud be []
03:32:20 <Iceland_jack> What should the type of maximum be?
03:32:29 <Iceland_jack> Let's assume the input is [Int]
03:32:41 <vritser> It's Int
03:32:56 <vritser> not [], throw an error?
03:33:22 <Iceland_jack> yeah, that's sadly what Haskell currently does :)
03:33:24 <Iceland_jack> > maximum []
03:33:26 <lambdabot>  *Exception: Prelude.maximum: empty list
03:36:35 <vritser> Wrap it with Maybe
03:36:52 <Iceland_jack> That's one approach
03:36:59 <Iceland_jack> we could also be more specific about the lists we get in
03:37:15 <Iceland_jack> we want "non-empty" lists, but this is unrelated to your foldr question
03:37:35 <Iceland_jack> We could write: maximum :: (a, [a]) -> a
03:37:58 <Iceland_jack> where (a, [a]) models a non-empty list
03:39:04 * Iceland_jack . o O (( (a, [a]) already exists as Data.List.NonEmpty.NonEmpty a ))
03:40:21 <Iceland_jack> so you could write
03:40:25 <Iceland_jack> maximum' :: (a, [a]) -> a
03:40:29 <Iceland_jack> maximum' (x, []) = x
03:40:36 <Iceland_jack> maximum' (x, xs) = foldr max x xs
03:41:49 <vritser> en
03:44:13 <vritser> Thank you.
03:44:49 <Iceland_jack> So there are different types, and tradeoffs associated with each of them '[a] -> a' (fails on []), '[a] -> Maybe a' (everyone has to deal with the Maybe value), 'NonEmpty a -> a' (recently added data type, user has to change all their lists to NonEmpty's)
03:45:14 <Iceland_jack> vritser: The definition of NonEmpty is trivial
03:45:40 <Iceland_jack> data NonEmpty a = Cons a [a]
03:46:04 <Iceland_jack> The actual definition uses an infix constructor (:|) instead of Cons but it means the same thing
03:46:11 <Iceland_jack> data NonEmpty a = a :| [a]
03:47:37 <vritser> yes
03:47:56 <Iceland_jack> Now the definition of maximum' could be
03:48:03 <Iceland_jack> maximum' :: Ord a => NonEmpty a -> a
03:48:13 <Iceland_jack> maximum' (x :| [])   = x
03:48:24 <Iceland_jack> maximum' (x :| xs) = foldr max xs x
03:48:46 <Iceland_jack> And the type *tells* you what the function needs
03:49:49 <vritser> Yes. I understand
03:50:13 <Iceland_jack> Consider the difference between (NonEmpty a -> a) and ([a] -> Maybe a)
03:50:26 <Iceland_jack> With the latter we do not know when it fails
03:50:59 <phadej> [a] ~ Maybe (NonEmpty a)
03:51:15 <phadej> so the `latter = fmap former` ;)
03:51:29 <vritser> That's right
03:52:17 <phadej> but you could "fail" also when the list is of odd length, so latter is less precise
04:05:19 <Myrl-saki> Is there a way to use Existential types for "equality"?
04:05:40 <Myrl-saki> Basically, I want to have extensible modes.
04:06:37 <Myrl-saki> I have a feeling I'm doing this wrong tho
04:06:50 <Gurkenglas> Going from ([a] -> Maybe a) to (NonEmpty a -> a) only reduces the infinitely many bits of possibility space by, like, one.
04:07:09 <Gurkenglas> Or maybe O(1) bits
04:07:36 <Myrl-saki> Gurkenglas: But you don't have to work with functors.
04:07:38 <Myrl-saki> Or monads.
04:07:51 <geekosaur> I have no idea what `use Existential types for "equality"' means...
04:08:43 <vritser> :t foldr
04:08:44 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:09:19 <geekosaur> :t GHC.OldList.foldr
04:09:20 <lambdabot> (a -> b -> b) -> b -> [a] -> b
04:09:24 <Myrl-saki> geekosaur: Basically... `:: a -> Mode` and compare if the modes are the same.
04:09:46 <Myrl-saki> I keep a [Mode]
04:12:00 <geekosaur> that... makes no sense to me. if it's an arbitrary a, it is not necessarily a Mode. nor can types be extended at runtime; they only exist at compile time
04:12:48 <Myrl-saki> geekosaur: Makes sense.
04:12:54 <Myrl-saki> geekosaur: I guess I should just keep a [String] ?
04:13:05 <geekosaur> I could see a data Mode = Mode String (or Int or whatever)
04:13:21 <geekosaur> and a list or Map defining them, however they need to be defined
04:14:49 <Myrl-saki> geekosaur: Thanks.
04:19:22 <Guest34001> whats the coolest programming written in haskell
04:19:28 <Guest34001> program
04:19:55 <lyxia> pandoc
04:26:23 <mekeor> Guest34001: xmonad
04:27:03 <Myrl-saki> mekeor: I think house is higher.
04:27:55 <mekeor> Guest34001: GHC
04:28:27 <mekeor> darcs
04:28:54 <Myrl-saki> mekeor: Why darcs?
04:30:06 <mekeor> Myrl-saki: it's cool
04:30:23 <Myrl-saki> I'll take another look at it.
04:30:51 <mekeor> anyway, Guest34001, i think you can browse beginning at https://wiki.haskell.org/Libraries_and_tools to discover cool programs written in haskell
04:31:39 <chichou> the prelude link gives a 404 :-(
04:33:55 <geekosaur> https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/base-4.9.1.0/Prelude.html ?
04:39:24 <Guest34001> nice
04:40:16 <mekeor> wow, i just discovered that the server of "wire" messenger is written in haskell: https://github.com/wireapp/wire-server
04:42:26 <quchen> Wire is that Signal alternative?
04:42:36 <quchen> Encrypted texting?
04:44:39 <mekeor> yup
04:44:59 <mekeor> also, the most starred project written in haskell on github is: https://github.com/begriffs/postgrest
04:45:57 <mekeor> (see http://github-rank.com/star?language=Haskell )
04:58:01 <quchen> Wohoo I‚Äôm 60-something
04:58:19 <quchen> Although Agda has < 300 stars, so the metric might be a bit skewed
05:01:18 <ongy> quchen: I have 58, so it can't say much (I have like 5 users total)
05:10:19 <sheogorath> random question, is there a nice way to do optional arguments?
05:10:39 <ventonegro> maybe with Maybe?
05:12:05 <sheogorath> what if there's a lot of them? can record or record updates do anything?
05:12:21 <Gurkenglas_> sheogorath, for a large number of them, you can build a record type containing the default arguments
05:12:37 <Gurkenglas_> How did you come to suggest "record or record updates" there?
05:13:33 <Gurkenglas_> sheogorath, http://neilmitchell.blogspot.de/2008/04/optional-parameters-in-haskell.html
05:16:03 <Gurkenglas_> sheogorath, also https://ocharles.org.uk/blog/posts/2015-07-23-another-approach-to-default-variables.html - and google shows some more
05:16:58 <sheogorath> I just had some vague concepts and wanted some opinions.
05:17:04 <sheogorath> thanks, looks nice
05:41:00 <sheogorath> looking at record stuff and makeFields TH just gives the impression that records should have some structural typing or something.
05:57:08 <halogenandtoast> Another useless survey, how many people put main at the bottom of their haskell file and how many at the top (and I guess the third option... somewhere else)
05:58:45 <mutsig> Is there a way to ensure that a state-monad that recurse will fully evaluate its state before the recursion takes place? I have added what I thought was a lot of strictness annotations, but I still have issues with space leak.
05:59:26 <mutsig> Maybe I'm falling in to some common pitfall here that I don't know about...
06:01:03 <lyxia> use strict state and only put forced states
06:01:20 <lyxia> but that doesn't prevent thunks from refering to older states
06:02:55 <mutsig> I never put states, except when initializing. Only modify with the strict `modify'`. I also use strict state. But I guess that thunks refering to older states might be the issue then...
06:04:36 <mutsig> It's a transformer that uses Writer as well, but I use strict Writer also.
06:06:18 <c_wraith> If you're using Writer from mtl, it's actually WriterT Identity
06:06:34 <c_wraith> and "strict" WriterT doesn't force the state to WHNF on each tell
06:07:35 <mutsig> And this isn't true for Writer from transformers?
06:07:49 <c_wraith> It probably is
06:07:52 <cocreature> mtl just reexports Writer from mtl so it suffers from the same problems
06:07:59 <c_wraith> ok.  I just hadn't checked
06:08:42 <c_wraith> The problem is actually structural.  There's no way to implement >>= for WriterT that is strict in the accumulator
06:09:50 <cocreature> writer-cps-transformers has a version of Writer that is strict iirc
06:10:04 <c_wraith> yeah, if you change the data structure it works.
06:10:25 <c_wraith> however, a cps'd WriterT is the same data structure as StateT
06:10:30 <cocreature> sure
06:10:44 <c_wraith> so most people just use StateT with an appropriately restricted interface
06:10:51 <mutsig> Ah... That might be the problem. would putting the accumulator in the state solve this?
06:11:08 <cocreature> possibly
06:11:12 <lyxia> mutsig: "modify'" may not be strict enough either. By "put" the state I mean it in the broad sense which includes any time you modify the state.
06:11:20 <c_wraith> It will help.  No guarantee it's the only issue. :)
06:11:47 <cocreature> mutsig: also make sure that you evaluating your state to whnf as done my modify' actually evaluates all the fields that you want to evaluate
06:11:57 <cocreature> in particular using a tuple as a state won‚Äôt do that
06:12:52 <mutsig> Well, I have a rather large state-datatype which i use modify' on. I thought that would do it
06:13:14 <c_wraith> only if you have the fields you're accumulating marked strict
06:13:16 <mutsig> And the fields which I modify are strict
06:13:20 <mutsig> yes
06:13:37 <c_wraith> that should do, then.  As long as *they* are also good. :)
06:13:50 <c_wraith> Like, none of them are String or other [a]
06:14:37 <mutsig> Ah ok. I will start by removing the Writer-part of the transformer and put it in the state. No, I think all my datatypes are strict :) Thanks
06:24:28 <joe9> code : http://codepad.org/vunaxBRI error  http://codepad.org/aX4toP2U . the manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-overlap indicates that this situation is ok as there is a more specific instance. Any suggestions on what I am missing, please?
06:25:34 <c_wraith> joe9: it's ok for them to overlap - if you tell ghc that you want them to overlap
06:25:58 <c_wraith> joe9: add appropriate pragmas to indicate that the overlapping is intended.
06:26:55 <c_wraith> instance {-# Overlappable #=} IBFormat a => IBFormat (Maybe a) where ..
06:26:59 <joe9> c_wraith: Thanks.
06:27:09 <c_wraith> instance {-# Overlaps #=} IBFormat (Maybe Text) where ..
06:27:37 <halogenandtoast> If I want to use a custom data type as the "key" for Array do I need to make it an instance of Ix
06:27:47 <c_wraith> halogenandtoast: yes
06:28:06 <halogenandtoast> i.e. I have data Position = Position !Int !Int so I need to make that an instance of Ix, is there an easy way to do that?
06:28:35 <halogenandtoast> or just define range, index, and inRange
06:28:37 <halogenandtoast> and be done with it
06:28:57 <c_wraith> I'd just define them in terms of (Int, Int) - I assume you want the same behavior as that instance.
06:29:09 <halogenandtoast> c_wraith: yeah
06:30:07 <joe9> c_wraith: That does not seem to help. Do I need something in the calling file (where the instance is used)?
06:30:13 <halogenandtoast> Thanks
06:30:48 <joe9> c_wraith: code http://codepad.org/HC9ZPtHD , error  http://codepad.org/q704BTwl
06:31:12 <c_wraith> joe9: It should only be necessary at the instance definitions...  But I don't ever write overlapping instances, so my knowledge here is incomplete.
06:31:28 <joe9> case sensitive? let me try.
06:31:42 <c_wraith> I don't think pragmas are case sensitive, but it's worth checking.
07:18:40 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
07:18:40 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Wed Apr 05 12:49:54 2017]
07:18:40 --- names: list (clog heebo LordDeath Wamanuz2 ccomb kuribas zar ryantrinkle danza robkennedy capuk multichill takle cyborg-one mudfog_ SimpleL Brando753-o_O_o bennofs1 `^_^v Rembane @ChanServ sdemos spicydonuts dwarders gargawel JSharp geal Freundlich Tallenz MagBo Fubar^ statusfailed Reyu cheshircat mystfox chelfi unsymbol kjanosz bogdanteleaga poga nerdystreetrat AWizzArd vodkaInferno heath japesinator tych0 Veltas kloeri Ford_Prefect wamaral abbe vin-ivar)
07:18:40 --- names: list (zpconn__________ epta Ewout mkurkov_ Neo Ankhers PHO Profpatsch Xorlev milessabin kyagrd wenzowski jcp___ dgonyeo solidsnack micmus bengt_ ericbmerritt_ jotrk cdornan ion raek Xe ec\_ M2tias madknight bob_twinkles mikedlr sclv ephemeron monad_cat brolin_empey cow-orker Rabbit__ carter-znc srk anonus majjoha a3f ctag joeytwiddle grandy__ Jello_Raptor vincenz CindyLinz intelux armlesshobo edejong hughrawlinson Bengi tazjin OliPicard andreypopp nkpart {AS})
07:18:40 --- names: list (rellen michalrus bgyss daishan codebje Saimeidae spion tsani CARAM__ edwardk cjay quuxman imalsogreg Meanirelli mrlase henrytill liste hodapp Drezil gnusosa Belgarion0 newsham ycheng davl TimWolla dxtr yushyin tomaw Clint mbrcknl mudfog sm zenzike notdan wrmsr_ timothyh sleepynate ernst quaestor wz1000 jordanlewis adarqui Someguy123 pringlescan stasku minad RazorX aweinstock EvanR dilinger yaknyasn banjiewen paf31 rjungemann ecobos fycth thoughtpolice)
07:18:40 --- names: list (shans_ masquerade Liskni_si navilan- tolt hpc Tspoon_ vili Quintasan tek0 orzo watersoul lispy dtulig anhduy aaron7 Zemyla Squarism lwm inr dstockwell rann mbrock dsm Tritlo fuziontech jonrh jorendorff klugez mathu Chousuke Wojciech_K Athas fugyk cpu1 rom1504 Cerise orcus g2 lukky513 asm89 gareth__ SolarAquarion jml xacktm dbohdan keri Klumben alem0lars fall_ Boreeas jmct NemesisD lukexi S11001001 okeuday_bak Akii bigs_ Vq nille Jonno_FTW brennie)
07:18:40 --- names: list (lexi-lambda jorj s4kashya1 biocage rlr kml sjl_ josh5tone saylu Tristan-Speccy bdeferme urdh nurupo Maerten glguy nikolah avn_nb bind1 Ieuan p_q andjjj23 dan64 throughnothing CGML c_wraith B4tMaN u-ou dmj` earthy vfs pdxleif averell hsyl20 jtcs loupgaroublond marens staffehn Kneiva tswett dogui mokus_ kosmikus ambrosia_ Hijiri mantovani jzl cocreature julmac tibbe ynyounuo xxpor amatecha wyvern tnks Fuuzetsu __name__ Matajon wedify thewormkill kini)
07:18:40 --- names: list (Raptor8m3 bno1 emmflo s4msung tjbp mniip amoe_ clamchowder acfoltzer dschoepe [swift] c-rog Jaak c0dehero raid SuperTux88 Moyst moneytree brixen qmm MasseR amiri magicman afcondon_ ReinH Eliel d3lxa Ring0` dabukalam crosleyt glowcoil wavewave logcat betawaffle relrod gornikm_ Intensity Jinxit zchn emily1 SlashLife tippenein discrttm thi_ rodarmor flebron sveit ziman fold4 yrid joachifm sqrt2 ijp adamCS baroncharlus marmalod1 ricardo82 omilu arkeet)
07:18:40 --- names: list (fbergmann Xnuk Bob131 Myrl-saki ft Zowlyfon ajmccluskey t00m0 coup_de_shitlord phadej Ralith__ jackhill s4kashya5 o`connor_ integral lieven obiwahn arw esmiurium ajp_ luite_ gridaphobe caw carc ski benoliver999 dh Solarion palo psmolen_ \u yarou Deewiant DDR mitch_ zgrepc lassulus tdammers Monoide 5EXAANIJ9 Willis flxw vqrs NocnaShada qz bitonic Enzyme tokik mikeplus64 tomus mulk datajerk baweaver jbalint wtw_ besenwesen bcoppens peschkaj tctara_ reynir)
07:18:40 --- names: list (JDevlieghere solarus nshepperd1 briansteffens rdococ mikeizbicki kriztw jabbslad wjm nshepperd_ baetheus Vorpal fxrs _cyril_ carbolymer wto Cathy kshannon Marqin __SiCC__ pharaun joehillen rodlogic indiffernet_ Biohazard kwantam oelewapperke simony eddsteel anoe RouxTheDay j_king aidecoe seequ ChewieBeardy niluje foobars tessier Madars_ glitch_hat orion Phlogistique adelbertc _flow_ nyuszika7h Atlantic777 runawayfive Sornaensis kvazau aatxe RageD surtn)
07:18:40 --- names: list (dedgrant HalfEatenPie e qlkzy pasukon moop michaelw fingerzam max-m cstrahan int-e sovreign_ georgew tjpeden timrs2998 Ranhir lambdabot michi7x7 TommyC mbeidler greenbagels qguv bjobjo mimi_vx APic lachenmayer statusbot Enigmagic alibabzo Igloo bartavelle johtso sbauman enolan bd___ lstrano_ jaargon jix_ pyrtsa hnrk_ kipras`away pierrot ebutleriv SLi Disavowed saurik Flonk TheAuGingembre ipuustin mutsig reptar_ tg tristero mkloczko Heero_ akermu spinda)
07:18:40 --- names: list (isacloud billstclair feltnerm Purlox iphy dgpratt paroxp rgrinberg avdi mavihs jfokkan__ vikram__________ nathanic linduxed luigy Nolrai andrew__n__ bbielsa marcel incomprehensibly heyj zomg hanDerPeder arand scav ezyang cyberlard capisce_ alanz killtheliterate raibutera samgd KorriX hiptobecubic mak` gnull customminer erikd strixy nekomune nocookies92 emerson neonfuz jamiis spacebug_ kmicu solution1 folsen_ garphy eagleflo robogoat Bigcheese scared nilOps)
07:18:40 --- names: list (heurist luis dunx polux teto niko kubrat cods ircbrowse dredozubov scinawa prooftechnique sshine ahihi beaky wayne rjeli s4kashya Jaxan zhulikas tortal bitemyapp idupree louisriesener Ninja3047 dustinm maerwald acowley_away Morgawr staticfox xtsee jw358 DanZimm kennyp shapr Frankablu anachrome mjo jmaki dn1987p sanjoyd etrepum g4k cmdv xplat|work si14 ocharles aristid rstone_ s4kashya4 kriton_ numberte1 hyPiRion_ cynick kipd phz_ strmpnk eL_Bart0-)
07:18:40 --- names: list (noplamodo shiona tekacs cnr domenkozar QuantumLogic djanatyn odamn ReinH_ pinkmuffinere heinrich5991 reiddraper angerman spaceships DustyDin1o tapirus runeks sa1 tsahyt bus000 gothos chrzyki ftop malthe rootmos lapinot TallerGhostWalt brent80_plow implementation noxd SoupEvil lpaste vi0 Kestrel-029 Fylwind pikajude RevJohnnyHealey ByronJohnson tomku mt Amadiro cjwelborn giraffe Tharbakim angelos Laney andreass wrengr_away xaimus MarcelineVQ Gabemo)
07:18:40 --- names: list (redfish64 LeCamarade stux|RC-only sdx23 tromp centril Adeon bxc lenstr froztbyte comboy noctux naudiz Baughn kaol nopf ninja_in_neopren koala_man malt3 uwap mendez frontendloader dixie_ raatiniemi dequbed_ edran scopedTV mxf monty darthdeus dunj3 xa0 suzu kyren Guest9488 alpounet Theophane Twey XMunkki Tazca davean chu fryguybob mnoonan xplat Nikotiini posco twold mounty dysfun bbee Tesseraction_x cjh` ploop seliopou srhb sgript Cxom_ n1 mdarse da-x rotty)
07:18:40 --- names: list (Benzi-Junior tsou petercommand eyck caasih abra0 kolko otulp Younder zipper RGamma gregoire Ptival LeaChim Eagle_Erwin swhalen m00n burp stig houli AlainODea metalrain feepo hansihe yminsky makufiru ggherdov peteretep nbouscal trig-ger pelegreno__ FrankZappa zmanian___ SuprDewd Scorchin Gredu_ tlevine jrkp mmaruseacph2 jmnoz CodeKiwi valdyn padre_angolano kolmodin_ stefan-__ x1n4u afldcr_ pmade niklasb sbrg snsapiens mw keb Arguggi_ mk-fg chirpsal1)
07:18:40 --- names: list (theorbtwo Geekingfrog Deaddy codedmart esph voidrays mou majoh KaneTW kefin_ bananagram _6a68 thoradam Reisen TabAtkins tomjaguarpawaway zph reem wizonesolutions jchia_1 ahf cschneid irclogger_com Blkt drdo byte512 buoto przembot mauke jlouis Maxdamantus gallais pierce__ greeny ramatevish Raynes hongminhee guillaum2 DexterLB eyen tumdedum Philonous atomi myfreeweb barrucadu Chobbes worch pikhq Elsi juri_ geppettodivacin rootnode numeo Vivek irishsultan)
07:18:40 --- names: list (pdgwien codebam ixian jstolarek kav ncl28 araujo PatrickRobotham w4and0er96 ortmage dpower Natch Randy huonw solatis SAL9000 Hafydd ij metaphysician ChongLi nahra raidiant zaquest gcross Ornedan trevorriles_ trevorriles bluepixel platz micro_ haasn icedev _kit_ justicefries benzrf opios mikecaruso shesek xnyhps i-amd3 vikraman grayhatter nwf agrif pacak jrp6 robertc brezel darthvorik_ ryanpcmcquen Adluc angular_mike_ c0smo_ tharper flux CosmicRa` ssedov)
07:18:40 --- names: list (dxld_ myme squisher stephe jinblack lynn usr_ chriswk arc- asjo pchiusano gleber_ bkonkle seanparsons lancetw carter siddhu ohsix PotatoGim prefork tarcwynne_ MorTal1ty cartwright niHiggim avn aminb revprez cansis nesqi chindy dqd oberstein troydm bbaren teppic cbaines divVerent bwe ps-auxw canta msks nak niteria gpampara dcoutts lyxia sleblanc leothrix ego coeus ericsagnes jrm Unode thebored nathyong Guest28989 arpl cic noam_ rizary liyang descender)
07:18:40 --- names: list (Meow-J oleks MitchW esssing ljhms jdnavarro nek0 pfoetchen spoonm Voldenet darktenaibre amuck pranz kiltzman bencryption treehaqr peterhil jle` verement bshelden texasmynsted tolt_ Qfwfq wahrsagevogel keemyb WizJin abh pmn cmr Netwolf ogkloo tctara chrissl mehs forker johs ubsan Pilfers hydraz kotangent happy0 martingale calloc jelleke sagax dmwit anry Proteus meteo metalbot thimoteus pita zennist Xandaros beerdrop suds13_ __main__ grumble catsup defanor)
07:18:40 --- names: list (LiaoTao Nycatelos prkc greister athan dsantiago leah2 miklcct yezariaely whiteline supki joneshf-laptop aglorei dmiles jmiven Tuplanolla meck pent m1dnight_ AntiSpamMeta megaTherion zymurgy zv bydo atk sophiag marcopullo abhixec sdrodge falafel tristanp peddie fergusnoble JoelMcCracken swalladge jokester magthe cgfbee yrdz` Fairy Faucelme suppi lavalike mearnsh Lokathor noteshui rossberg animated SolitaryCypher vimto MitchellSalad holla RoyalNightGuard)
07:18:40 --- names: list (brandon-stiles shainer bungoman hvr Ferdirand electrostat hive-mind dsfox1 l_zzie anderson rotcpy LnL acro permagreen hc StoneToad oaao iCharlie uelen emc2 flout Cale ichor jud AustinMatherne kaeluka litchblade jgornick dpn` Forkk Vbitz GGMethos jluttine sw1nn slomo byorgey jophish danthemyth Taneb jameseb cheater jchia lopex bjs xfix_ nighty-- tmciver Bane^ dibblego Axman6 ph88^ baamonde Khisanth jstimpfle _ashbreeze_ hiredman mceier shutdown_-h_now)
07:18:40 --- names: list (kosorith obadz katychuang_ kian srcerer dfranke rotaerk Cthalupa mattp__ Sonderblade geekosaur firef1y robotroll Zialus Deadhand Edith qzo lordcirth isenmann dyreshark hiratara Sgeo Nik05 karce stoopkid markus1189 markus1199 theDon seagreen joe9 Majiir charco jasondockers_ DTZUZU alx741_ gcross_ IanKelling featherlessbiped vektorweg1 castlelore SpaceGazebo3 Tourist leat cross QRealm Supersonic112 hucksy darjeeling_ ertes exferenceBot brynedwards hexagoxel)
07:18:40 --- names: list (dolio Qommand0r SCHAPiE jsgrant thang1 burtons Orion3k lpsmith infinity0 a3Dman tinkyholloway fkurkowski dpepsilon felixsch_ turnage contextfree nshepperd otto_s_ mzf Jesin IndigoTiger hamishmack wagle thunderrd pzuck Kuros lithie jgt3 frangor serendependy DataComputist danvet piyush-kurur govg _paul0 tomboy64 Shatnerz0 xinming_ Sam___ quchen hurkan LuckyRawApe je5finger azahi eatman nick_h guiben takuan Sose noan_ sujeet tput- delYsid`` adraenwan_)
07:18:40 --- names: list (nick123_ pleiosaur jrslepak mgaare threshold Guest50132 Frans-Willem stvc blackdog oherrala wting cdidd tgeeky n__dles guios abrar thallada Ke xcin Logio aegray tero- tjt monochrom weinzwang exio4 owickstrom joeyh alexbiehl angseus kofdog osfameron mitchty gsingh93 tobiasBora JPohlmann nikivi gspia brisbin kgadek fairfieldt ongy tv alphor catern hegge boxofdeath vishesh CuriousErnestBro BartAdv ThomasLocke opqdonut iross mrd AtnNn lokydor `0660 Saizan bsmt)
07:18:40 --- names: list (rcschm vlatkoB ventonegro rightfold greymalkin jgertm- valkyr2e justanotheruser bollu kadoban thc202 sibi Itkovian rbocquet nemesit|znc raichoo vydd blocky mattyw armyriad Swizec ggVGc acidjnk jdt albel727 lep-delete kfish freusque bweston92 mekeor marr johnw yxadyx mmn80 gregman_ jgertm oish jaspervdj Unhammer Aidan[m] Sigyn ub reactormonk[m] wictory[m] bb010g closures999[m] alaradia[m] Naughtmare[m] NickHu davidar_ davidar riaqn roadrunner168[m])
07:18:40 --- names: list (herzmeister[m] karroffel nick2000 jyp[m] M-BostonEnginerd kaichao[m] curry[m] seequ_ m4lvin[m] elwan7[m] travisr monomon[m] unclechu jmnoz[m] sudoreboot[m] miviotros[m] zaphar_ps[m] korayal[m] M-Illandan Magnap M-berdario MatrixTraveler[m sirius[m] hendrik[m] M-schmittlauch hiq[m] M-Quora corintho[m] rdesfo[m] srenatus[m] tfc[m] bobjason[m] M-krsiehl TylerCecil[m] FederalRick[m] ptek[m] jacqueline[m] cbHXBY1D[m] hakan[m] iffsid[m] Soif[m] colton[m])
07:18:40 --- names: list (tester668[m] wr3n[m] ProofTechnique[m noraesae tomkerk[m] rfabbri[m] moonarch rakete NopeMarker[m] aspiwack[m] gentam[m] Guest91110[m] drasich[m] M92854[m] Yves[m]1 TesX[m] TheWizardTower zar[m] gkaplan[m] unknownln goodboy[m] mmmrrr[m] jascot[m] juhp laz locallycompact zero_byte silver sphinxo dcoutts_ Xanather srbaker Wizek Wizek_ cpup CurryWurst unK_ balor so ralu howdoi inkbottle harrismai Icewing netheranthem m0rphism oisdk ziarkaen nh2 Iceland_jack)
07:18:40 --- names: list (mda1 zcourts Gurkenglas detrumi sivs chichou ziocroc2 tdfirth albertid sdothum zagura ziyourenxiang theelous3 jathan harfangk anuxivm acarrico chlong filterfish_ moth asmyers ilyaigpetrov meandi ragepandemic bennofs soLucien yellowj ClaudiusMaximus Durbley bjz_ mkoenig Wuzzy aib xificurC Mysterious_Light dsh alienbot mtesseract earldouglas nakal_ vaibhavsagar pavonia tabaqui1 halogenandtoast Argue nilof insitu mada cpennington MindlessDrone dhil iAmerikan)
07:18:40 --- names: list (ejay mszczygiel fizbin srh fakenerd sheogorath crobbins machinedgod TheLemonMan bgamari ystael guampa shouyinji1 biglambda mizu_no_oto_work shayan_ Sampuka)
07:23:49 <ertes> Gurkenglas: depending on the monad you may prefer a stream processing solution, because that one builds at least the outer list in memory
07:24:11 <ertes> "that one" being (fmap concat . traverse f)
07:27:21 <Gurkenglas> > (`evalState` 0) $ fmap concat $ forM [1..] $ \i -> state $ \s -> ([i..i+s],i+s) -- you're wrong, sir
07:27:24 <lambdabot>  [1,2,3,3,4,5,6,4,5,6,7,8,9,10,5,6,7,8,9,10,11,12,13,14,15,6,7,8,9,10,11,12,1...
07:31:14 <Adam___> Hi puzzled beginner here, browsing Data.List module source in haskell.org it seems incomplete, with only isSubsequenceOf defined at the end. Where's the source for all those functons for me to look and learn from? Thanks
07:31:41 <Gurkenglas> Adam___, https://www.haskell.org/hoogle/
07:31:45 <geekosaur> these days it mostly reexports Data.Foldable
07:32:18 <quchen> Adam___: Look in the Data.OldList module, it contains the actual list functions
07:32:28 <ertes> Adam___: Data.List should only include list-specific functions now, for everything else: what geekosaur said
07:32:41 <ertes> :t foldr
07:32:42 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
07:32:53 <ertes> Adam___: ^ most of them have been geeneralised
07:33:08 <Adam___> Aaahh, so the imports in there foldable etc. have all the functions. Seems a bit odd to have only one functon definced in the Data.List module.
07:33:18 <geekosaur> backweard compatibility hack
07:33:49 * geekosaur asks subconscious whether that was supposed to be "backward" or "backweird" :p
07:34:11 <ertes> backward compatibility is always a bit weird
07:34:51 <Gurkenglas> The (fmap concat . traverse f) thing feels like it should involve alaf somehow
07:35:08 <Adam___> So the thing to dois just dig down to foldable module (and any inside that) to get the actual source.
07:41:32 <yaxu> A conundrum:
07:41:32 <yaxu> I made a function `unwrap :: Pattern (Pattern a) -> Pattern a`, which I now realise is actually `join`
07:41:32 <yaxu> so I defined bind in terms of it: `p >>= f = unwrap (f <$> p)`
07:41:32 <yaxu> However looking at the source I see the real join is defined in terms of `>>=`
07:41:32 <yaxu> This seems a bit wrong/inefficient, to have a function defined in terms of a version of itself via another function.
07:41:32 <yaxu> But it seems for some reason I can't define a monad with join, only with `>>=`
07:42:59 <tsahyt> What does ghc-mod refine do?
07:43:10 <geekosaur> yes, possibly some future will have an extension that will avoid problems but currently it is not possible to backward compatibly move join into Monad and *all* existing instances would break
07:43:27 <Freundlich> yaxu: I agree that monads should be defined using join but that's not the way it is, unfortunately.
07:43:35 <tsahyt> or rather, how to use it.
07:43:38 <cocreature> geekosaur: how would all instances break if you provide a default definition?
07:44:01 * ski thinks there should be an option to define either `join' or `(>>=)'
07:44:04 <yaxu> Freundlich: ah ok, I'm just after reassurance (or otherwise) that I'm not doing the wrong thing
07:44:29 <ski> sometimes defining `(>>=)' will be more efficient (assuming no SSC)
07:44:40 <geekosaur> hm. that was my recollection of the argument, I admit I'm short on sleep (and still choking regularly, sigh) but there were problems with just moving join into the definiton with a default
07:44:45 <geekosaur> maybe it was an optimization issue
07:45:09 <geekosaur> there may also be some wiring issues with how ghc desugars do
07:45:16 <cocreature> hm I‚Äôll have to read up on that at some point. I‚Äôve always thought that moving methods into type classes is mostly unproblematic
07:45:21 <geekosaur> (or, again. conceivably optimization)
07:45:42 <yaxu> I'll continue on this path then, thanks all
07:46:22 <ski> often it's simpler to discover how to define `join' than `(>>=)', though
07:46:52 <yaxu> ski: yes that's what I've found
07:47:05 <yaxu> ski: at least, I defined join by accident
07:47:23 <dolio> geekosaur, cocreature: The problem with join in Monad has to do with roles.
07:47:47 <dolio> join :: m (m a) -> m a
07:47:51 <Freundlich> dolio: Roles?
07:48:03 <ski> m-hm
07:48:38 * Iceland_jack hisses at roles
07:48:53 * ski smiles
07:49:01 <stelleg_web> anyone know if there's a way to drop prefixes using c2hs?
07:49:13 * geekosaur hisses at unsafeCoerce :p
07:49:19 <cocreature> at some point I actually knew what the role of roles (no pun intended) was but it seems like I forgot about everything about it :)
07:49:20 <dolio> So, if m is nominal, there are problems using generalized newtype deriving to derive Monad.
07:49:31 <stelleg_web> so instead of underscoreToCase, you could have dropPrefix "lib_"
07:49:52 <dolio> If join is in Monad.
07:50:24 <dolio> And lots of things end up nominal.
07:50:36 <lyxia> this makes things quite tricky
07:52:34 <cocreature> stefan-__:  think https://github.com/haskell/c2hs/wiki/Implementation-of-Haskell-Binding-Modules#context-hooks might be what you‚Äôre looking for
07:52:40 <cocreature> eh ^ stelleg_web 
07:52:43 <dolio> I think most monad transformers probably have to be nominal, because they include an abstract `f` that is applied (maybe indirectly) to the `a` argument.
07:53:24 <stelleg_web> cocreature: thanks!
07:53:35 <dolio> Unless you (co)Yoneda them or something.
08:00:58 <DrMentats> say I wanted to write a Parsec parser for a programming language while allowing an user of the library to extend it later with new syntax
08:01:19 <DrMentats> usually, if the user wanted to make a new kind of atom, they'd also have to rewrite the expression parser, then the statement parser and so on
08:01:25 <DrMentats> is there any way to avoid this duplication?
08:02:33 <tsahyt> before even worrying about the parser, you'd need your expression tree type to be extendable
08:03:01 <DrMentats> true, I'm looking into that right now
08:03:23 <tsahyt> this is known as the expression problem and there are several ways to go at it
08:03:49 <tsahyt> DrMentats: you might want to read the Data types a la carte paper
08:04:22 <DrMentats> will do, thanks
08:16:30 <NemesisD> probably too vague of a question but does anyone know of any techniques for creating annotated record records in haskell. for ex i've got a record and i want to annotate fields with things like descriptions that may get rendered into an HTML form or something
08:17:20 <santoast> hello
08:17:53 <santoast> Okay I've never chatted on an IRC before. Let alone one where I'm trying to learn haskell
08:18:06 <ski> hello santoast
08:18:09 <NemesisD> maybe i can come up with some sort of applicative interface, data Foo = Foo { bar :: Bar, baz :: Baz}, documentedFoo = Foo <$> doc "doc for bar" <*> doc "doc for baz"
08:18:12 <santoast> Is this how you do it? :P
08:18:21 <NemesisD> santoast: you're doing great
08:18:21 <lyxia> NemesisD: you could parameterize your records with a type of annotations: data Record ann = Record { field :: ann FieldType }
08:19:06 <ski> NemesisD : maybe `data Foo f = MkFoo { bar :: f Bar,baz 9~:: f Baz }' setting `f' to `Identity' respectively `(Annotation,)'
08:19:15 <NemesisD> lyxia: i briefly considered that. the question i guess is if i could generically traverse any record with annotated fields. perhaps actually via generic
08:20:07 <lyxia> You definitely can
08:22:19 * ski idly wonders whether santoast has any question, yet
08:22:34 <santoast> Hello ski
08:23:29 <santoast> um not anything specific, I am just checking out this stuff. I am currently learning about algebraic data types and type classes so I'm pretty new
08:23:37 * ski nods
08:23:48 <ski> feel free to lurk, if you want to
08:23:49 <Iceland_jack> Like what you see so far santoast?
08:23:57 <Iceland_jack> Haskell is a lot of fun
08:24:00 <santoast> and I figure when I do more haskell I'll have more questions so I'm pretty much breaking the ice
08:24:16 <santoast> LOL yeah I'm definitely lurking
08:24:21 <ski> newbie questions are welcome
08:24:23 <shapr> yay haskell!
08:24:41 * ski boings a bit
08:24:56 * shapr hops cheerfully
08:25:09 <santoast> awesome, yeah I'm reading a few online tutorials and I am trying to get a feel for how / why I need to learn about the types and classes
08:25:10 <sheogorath> nono, you're not lurking I'M ... err, damn
08:25:23 <mizu_no_oto_work> There's also #haskell-beginners, which might be good to lurk on. 
08:25:27 * ski spots a sheogorath
08:25:34 * Iceland_jack awkwardly shuffles
08:25:41 <santoast> oh really? cool
08:25:48 <santoast> I'll have to check that channel out 
08:26:32 <ski> that channel is connected with a particular Haskell book
08:27:11 <ski> that's not to say that beginners aren't supposed to ask here
08:27:29 <santoast> awesome, you guys are cool!
08:27:34 <ski> (feel free to be joined to both, if you want to)
08:28:40 <mizu_no_oto_work> And one thing that's helpful to know with IRC is that when you have a question, it's best to just ask it instead of first asking "can anyone help me?".  If anyone knows the answer, they'll answer.
08:28:55 <NemesisD> ski  lyxia  I may see if i can use optparse-applicative for a pattern. there's actually 3 things i want from this pattern: documentation, form generation and parsing from a more generic structure. seems like this  fits close to what OA does and  doesn't require any change to the data structure
08:29:16 * shapr hops randomly
08:29:18 <sheogorath> does anyone know a particularly cool functor?
08:29:26 <santoast> oh okay 
08:29:35 <santoast> that's good to know
08:29:36 * ski . o O ( diagonal functor )
08:30:00 <mizu_no_oto_work> And IRC is semi synchronous, like text messages, so asking to ask just kind of wastes your time
08:30:11 <NemesisD> the functor for (-> r) is kinda cool
08:30:12 <pmn> "what's your favorite functor?" should be the icebreaker question at every dinner party
08:30:16 <santoast> thanks mizu
08:30:20 <Iceland_jack> pmn: I do that..
08:30:25 * ski smiles
08:30:30 <santoast> so when I have a question just jump right in then?
08:30:34 <mizu_no_oto_work> So someone might answer after 5 or 10 min if it's particularly slow time.
08:30:36 <ski> sure
08:30:39 <Iceland_jack> santoast: go for it
08:30:40 <mizu_no_oto_work> santoast: yes, exactly
08:30:45 <Gurkenglas> santoast, you're still doing it :P
08:30:59 * ski 's had conversations, on slow channels, with hours inbetween individual messages, spanning over days
08:31:00 <santoast> LOL :P
08:31:03 <Iceland_jack> sheogorath: Do non (Type -> Type) functors count?
08:31:10 <santoast> I am ... I AM!! :D
08:31:22 <Iceland_jack> santoast: You can evaluate Haskell expressions
08:31:24 * ski nods to Iceland_jack
08:31:25 <Iceland_jack> > 1 + 2 + 3
08:31:27 <lambdabot>  6
08:31:41 <ski> @type map length
08:31:41 <Iceland_jack> By adding a "> " in front of your expression
08:31:43 <lambdabot> Foldable t => [t a] -> [Int]
08:31:45 <santoast> really? in here?
08:31:50 <ski> @help run
08:31:51 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
08:32:01 <santoast> run 1 + 2
08:32:08 <ski> @run 1 + 2
08:32:10 <lambdabot>  3
08:32:10 <sheogorath> yeah, i like (->) r. most recently i ran into FRP Event's and things. Nice and simple.
08:32:16 <ski> either `@run ' or `> '
08:32:18 <Gurkenglas> Nah, better not in here unless you want to show us something. Use /query lambdabot to ask him in private
08:32:21 <Iceland_jack> sheogorath: Fix and Free are nice functors
08:32:38 <ski> sheogorath : that's not the same as what NemesisD was talking about, though
08:32:38 <santoast> > 1 + 2
08:32:40 <lambdabot>  3
08:32:54 <kamysh> @pl let (a,b) = f x in g a b
08:32:54 <lambdabot> (line 1, column 5):
08:32:55 <lambdabot> unexpected "("
08:32:55 <lambdabot> expecting "()", natural, identifier or "in"
08:32:56 <ski> `> ' is a short-cut for `@run'
08:33:03 <santoast> wait I thought you meant you can run haskell expressions in this text box
08:33:30 <ski> kamysh : `uncurry g (f x)'
08:33:48 <ski> santoast : you just did
08:33:51 <kamysh> thanks!
08:34:05 <santoast> ah I see LOL
08:34:14 <sheogorath> ski: no? fmap=(.) ?
08:34:17 <Iceland_jack> santoast: Does this make sense: data Bool = False | True
08:34:21 <Gurkenglas> Iceland_jack, Fix isn't a Functor, unless you're refering to some category-theoretical thing? "data Fix f = Fix (f (Fix f))"
08:34:35 <ski> sheogorath : `(->) r' is `(r ->)' is not `(-> r)'
08:34:39 <santoast> Yeah so False and True are constructors right?
08:34:47 <ski> data constructors, yea
08:34:48 <Iceland_jack> that's right santoast
08:35:05 <Iceland_jack> Gurkenglas: Yeah, it is higher-order
08:35:05 <ski> `Bool' is a type constructor
08:35:23 <Iceland_jack> fmap :: (f ~> f') -> (Fix f -> Fix f')
08:35:30 <santoast> okay, so I use the data to define the types and whatnot
08:36:15 <Iceland_jack> santoast: This is how you would define negation
08:36:17 <Iceland_jack> not :: Bool -> Bool
08:36:18 <Iceland_jack> not False = True
08:36:19 <Iceland_jack> not True = False
08:37:09 <santoast> ah that makes sense
08:37:37 <ski> that's using pattern-matching, matching on particular patterns on input, covering all cases
08:38:11 <santoast> so the big picture here, at what point will I see the beauty in using/ making my own data?
08:38:12 <Iceland_jack> > not (not True)
08:38:12 <ski> `not' is being defined through multiple defining equations, each handling one pattern of input
08:38:14 <lambdabot>  True
08:38:55 <ski> santoast : when working with particular problem domains, often you'll want to make custom datatypes for concepts that you want to model there
08:39:00 <mjhoy> Has everyone read this? I very much enjoyed it on many levels. https://aphyr.com/posts/342-typing-the-technical-interview
08:39:01 <stelleg_web> > :t fix
08:39:03 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
08:39:06 <piyush-kurur> is there a reason why xml-couduit-1.5 is not entering stackage? most of the parsing functions in 1.4 have been depreciated so the use is throwing up a lot of warnings
08:39:07 <Iceland_jack> :t fix
08:39:07 <ski> that's when you'll reach for `data' (and `newtype')
08:39:07 <stelleg_web> :t fix
08:39:08 <lambdabot> (a -> a) -> a
08:39:09 <lambdabot> (a -> a) -> a
08:39:12 <santoast> And when is the turning point usually when learning Haskell?
08:39:20 <Iceland_jack> it depends santoast
08:39:21 <stelleg_web> > fix not
08:39:27 <lambdabot>  mueval-core: Time limit exceeded
08:39:38 <ski> > fix show
08:39:40 <Gurkenglas> Iceland_jack, but then wouldn't that be ambigious in the order in which you turn the levels of f into levels of f'? (Also you're missing (Functor f, Functor f')... unless you're only using one of them, and then the ambiguity is gone, but still)
08:39:40 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
08:40:02 <Iceland_jack> Gurkenglas: (~>) could package up the Functor instances
08:40:06 <ski> > fix error
08:40:08 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
08:40:35 <Iceland_jack> you are right that there are two equivalent ways of defining
08:40:58 <Gurkenglas> More like arbitrarily many
08:41:05 <ski> Gurkenglas : naturality law says that it shouldn't matter in which order you do it
08:42:00 <stelleg_web> > fix $ \x -> "we must go deeper ..." ++ x
08:42:02 <lambdabot>  "we must go deeper ...we must go deeper ...we must go deeper ...we must go d...
08:42:53 <ski> > (`fix` 12) (\fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n-1) + fib (n-2))
08:42:56 <lambdabot>  144
08:43:31 <ski> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
08:43:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:44:32 <Gurkenglas> Huh he's right, so the (~>) also packaged up an ambiguity resolution :D
08:45:20 <stelleg_web> fix ("turtles "++)
08:45:27 <stelleg_web> > fix ("turtles" ++)
08:45:30 <lambdabot>  "turtlesturtlesturtlesturtlesturtlesturtlesturtlesturtlesturtlesturtlesturtl...
08:45:35 <ski> @type cycle
08:45:35 <stelleg_web> ok i'm done
08:45:35 <Iceland_jack> I see #haskell is getting its fix
08:45:36 <lambdabot> [a] -> [a]
08:45:51 <ski> @src cycle
08:45:51 <lambdabot> cycle [] = undefined
08:45:51 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:47:53 <santoast> Well thanks Iceland and ski and everybody else for being really cool. It was a good ice breaker, now I will try and come here when I have future questions
08:48:09 <ski> you're welcome
08:48:11 <Iceland_jack> "icebreaker" D;
08:48:15 <santoast> LOL
08:48:16 <sheogorath> gl hf
08:48:23 <santoast> thanks I will
08:48:33 <Iceland_jack> good luck santoast
08:48:38 <santoast> have a good day y'all
08:48:43 <santoast> ty
08:48:44 <Iceland_jack> I might could
08:48:57 <ski> santoast : might want to consider using a stand-alone IRC client, if you're gonne come here often
08:49:02 <halogenandtoast> Is there a setting I can turn on to complain about exhaustive patterns at compile time?
08:49:12 <halogenandtoast> I'd prefer errors not warnings, but I'll take what I can get
08:49:18 <santoast> oh okay, ill look into that
08:49:32 <halogenandtoast> for this I mean in ghc
08:49:42 <ski> mIRC, HexChat, Irssi, Colloquy (sp?), AndroIRC, &c.
08:49:51 <glguy> (glirc)
08:49:57 * ski grins
08:50:03 <DrMentats> halogenandtoast: I just use -Wall myself and it comes with that as well
08:50:06 * ski isn't sure which are the most common ones, on various platforms
08:50:55 <joe9> attoparsec default error messages suck. Just want to check if there is a way to show better error messages
08:51:07 <joe9> I get this : Left "0: Failed reading: satisfy"
08:51:17 <joe9> nothing on the input string, etc.
08:52:23 <bennofs1> joe9: good error messages are hard. that's one of the reasons that makes attoparsec fast, it does not have to do all the bookkeeping to generate good ones
08:52:45 <geekosaur> joe9, it's common to test using marsec/megaparsec and then switch to attoparsec for production
08:52:49 <geekosaur> *parsec
08:53:13 <glguy> joe9: You have to annotate your parser with information using <?> and friends
08:53:17 <bennofs1> geekosaur: you could perhaps even reparse in production if attoparsec fails to pare, go give a better error?
08:53:32 <bennofs1> assuming that most input will parse successfully
08:54:10 <geekosaur> I'm vaguely recalling a package on hackage that lets you do that. parsers perhaps?
08:54:21 <halogenandtoast> DrMentats: okay fair enough, I'll need to see if I can add that as a stack default
08:54:35 <joe9> i loved aeson's error messages . took the guess work.
08:54:44 <joe9> s/work/work away/
08:55:05 <joe9> glguy: Thanks. will check out <?>
08:56:19 <joe9> glguy: <?> is a good start. Thanks.
08:56:42 <DrMentats> halogenandtoast: actually, I faintly remembered an option that turns warnings into errors and upon closer inspection it's -Werror if you're interested
08:57:32 <halogenandtoast> DrMentats: Yup I added it
08:57:39 <halogenandtoast> to my global stack config
08:57:52 <halogenandtoast> Thanks for pointing me in the right direction
08:58:03 <tig_> ls
09:06:03 <inkbottle> [noob] [1,10,45,120,210,252,210,120,45,10,1] >>= take 5
09:07:41 <ertes> inkbottle: do you have a question?
09:08:01 <fnkl> I do
09:08:07 <inkbottle> ertes: Yes, I thought the above line would work, but it doesn't
09:08:21 <ski> > take 5 [1,10,45,120,210,252,210,120,45,10,1]
09:08:23 <lambdabot>  [1,10,45,120,210]
09:08:28 <ertes> inkbottle: (>>=) :: [a] -> (a -> [b]) -> [b]
09:08:42 <ertes> take :: Int -> [a] -> [a]
09:08:56 <ertes> you're trying to match the 'a' from the first with the [a] from the second
09:09:21 <ertes> this only works, if the 'a' from the first happens to be a list type
09:09:35 <ertes> > ["abcd", "efg", "hijklmn"] >>= take 2
09:09:37 <lambdabot>  "abefhi"
09:09:57 <inkbottle> ertes: sttarting to see
09:10:52 <inkbottle> ertes: thanks for the type above...
09:11:51 <ski> @src [] (>>=)
09:11:52 <lambdabot> xs >>= f = concatMap f xs
09:12:15 <fnkl> Hya, am I right that this is where Haskell Q's come to be answered?
09:12:42 <Taneb> fnkl, yes
09:12:46 <ertes> inkbottle: remember that (>>=) passes each *elements* of the list to the function you supply‚Ä¶  your elements are numbers, but (take 5) wants lists as its argument
09:12:56 <ertes> *element
09:13:30 <ski> fnkl : it's one such place, yes
09:14:00 <fnkl> I'm in a picke - I have tons of classes, some with ID record, most w\o. Trying to implement a func which acts like Eq, but ignores the ID field
09:14:14 <fnkl> *pikckle
09:14:18 <fnkl> *pickle sorry
09:14:33 <ertes> @lpaste fnkl
09:14:33 <lambdabot> Haskell pastebin: http://lpaste.net/
09:15:14 <inkbottle> ertes: I confused it with bash (gnu find) xargs; but I was mistaken... I see now that it has to be a monad
09:16:03 <ertes> inkbottle: xargs is quite similar, if you use it with -n1
09:16:32 <nilof> What is the difference between acting on a monad with a monad transformer (say MaybeT List a) and composing it with another monad (MaybeT Identity) List a ?
09:16:52 <ertes> inkbottle: echo a.txt b.txt c.txt | xargs -n1 head -n5
09:17:29 <ertes> nilof: the difference is that the latter is a kind error =)
09:17:51 <ertes> nilof: MaybeT :: (* -> *) -> (* -> *)  -- it takes a monad and returns a monad
09:18:03 <fnkl> @ertes I have nothing specific, since don't know how to approach
09:18:03 <lambdabot> Unknown command, try @list
09:18:08 <nilof> so I fed it the Identity monad?
09:18:15 <fnkl> ertes: I have nothing specific, since don't know how to approach
09:18:17 <ertes> so (MaybeT []) is a monad
09:18:33 <ski> `MaybeT Identity' doesn't want to be applied to `List'
09:18:35 <ertes> fnkl: then explain your application
09:18:49 <nilof> ah, MaybeT Identity ( List a) then
09:18:56 <ski> ah, that's another thing :)
09:19:04 <ertes> nilof: in that case (MaybeT Identity) is your monad
09:19:29 <ski> @unmtl MaybeT Identity ([] a)
09:19:29 <lambdabot> Maybe ([] a)
09:19:30 <ski> @unmtl MaybeT [] a
09:19:30 <lambdabot> [] (Maybe a)
09:20:45 <ertes> nilof: getLine :: IO [Char]  -- this one also happens to have a list type as its result type, but that's unrelated to IO, the monad
09:20:52 <fnkl> I need to encode the concept of equivalence, things that behave the same despite being run at different times. To do so, I want to compare two records (of records, of records, so on), ignoring fields that are specific to the run, e.g. timestamp
09:21:04 <fnkl> I
09:21:38 <ertes> fnkl: from your description the only thing you need is a class that is similar to Eq
09:22:08 <nilof> How does MaybeT guarentee that the result of applying it to a monad is a monad?
09:22:10 <fnkl> It's quite boilerplatish
09:22:25 <ertes> fnkl: you can save much of the boilerplate by using generics
09:22:50 <ertes> fnkl: define instances for basic types, then use generics to derive most others
09:22:50 <fnkl> as in GHC.Generics?
09:22:55 <ertes> fnkl: yeah
09:23:29 <EvanR> with a proper record system you could instead say "compare r1 and r2 after forgetting timestamp"
09:23:43 <EvanR> without having to define a new datatype or eq algorithm
09:24:00 <ertes> fnkl: you could make a wrapper type (e.g. newtype Run a = Run { fromRun :: a }) and write a DescEq instance that always compares True
09:24:32 <ertes> fnkl: alternatively you can create a type class that defines a lens into the description part of a record
09:25:03 <ertes> fnkl: a further alternative is to keep run-time data separate from description
09:25:08 <fnkl> not sure I understand the last suggestion
09:25:14 <fnkl> *penultimate :)
09:25:17 <EvanR> thats the best idea
09:25:22 <EvanR> conceptually
09:25:29 <ertes> fnkl: i'd most likely pick the last approach
09:25:32 <Iceland_jack> propreantepenultimate
09:25:48 <ertes> fnkl: i.e. just don't mix the two types of data in the first place
09:25:59 <EvanR> instead of doing work to represent part of the monolithic type, dont make it monolithic in the first place
09:26:02 <ertes> nilof: the Monad instance guarantees it
09:26:26 <EvanR> but practically wed still be better off with a record system
09:26:28 <inkbottle> (>>=) == fmap?
09:26:37 <ertes> nilof: you can prove that the monad laws for (Monad (MaybeT m)) hold, whenever m is itself a monad
09:26:38 <Iceland_jack> inkbottle: no
09:26:41 <inkbottle> ok
09:26:43 <Iceland_jack> they have very different types
09:27:50 <inkbottle> Iceland_jack: Quite so, I can see
09:28:19 <fnkl> Thanks a lot, I'll look into these
09:30:25 <fosskers> Is it possible to write a test suite for modules living in an executable, or do I have to break the functions I want to test out into a separate library that both my main executable and my test suite can depend on?
09:33:18 <lyxia> You must put them in a separate library
09:34:42 <fosskers> alright, time for a refactor
09:36:41 <ertes> fosskers: you can add the executable's source directory via hs-source-dirs
09:36:51 <ertes> fosskers: caveat: you will compile the modules twice
09:49:02 <tabaqui1> I'm using QuickChech2 with test-framework
09:49:36 <tabaqui1> how can I specified number of attempts for some test?
09:49:58 <tabaqui1> for now there are always 100 tests for each case
09:57:31 <lyxia> tabaqui1: use PlusTestOptions and topt_maximum_generated_tests
10:03:02 <shapr> I forget my favorite functor. Must be a forgetful functor!
10:05:21 <tabaqui1> lyxia: in Property definition?
10:07:44 <tabaqui1> lyxia: ah, I see it
10:07:45 <tabaqui1> thanks
10:12:43 <thimoteus> lol shapr
10:20:09 <Geekingfrog> How would you go to write and test something like a rate limiter, which depends on a clock ? A typeclass to get the time and a different instance for testing?
10:20:59 <EvanR> a type class to get the time sounds wrong
10:21:28 <EvanR> accepting an IO action to get the time, sounds better
10:22:05 <Geekingfrog> good idea, I like that.
10:23:00 <EvanR> though IO kind of puts a wrench into the whole testing thing
10:23:10 <koala_man> maybe you can take any monadic action, so that your tests run in State while prod runs in IO
10:23:17 <EvanR> removing IO is sometimes a brain bender
10:24:23 <EvanR> honestly i dont know if you want monads for this at all
10:24:57 <Geekingfrog> The signature is going to be something like Int -> IO () anyway, I don't quite see how I could test that without IO
10:26:30 <Cale> You might even start with a totally pure specification of what ought to happen -- a pure function which takes, I dunno, perhaps a Seq of scheduled tasks (a queue), and the current time, and produces a (Maybe Task, Seq Task)
10:26:37 <EvanR> theory: a rate limiter is a function that takes an internal state, a list of (whatever, IO actions) and returns the list split up into items youre allowed to do now and items you have to wait for, and how long, and an updated state
10:27:11 <EvanR> oh yeah and takes the current time
10:27:19 <Cale> Oh, and you may also want some other information going into that, info about completion of previous tasks :)
10:27:37 <Geekingfrog> I think the completion of previous task can be stuff into the internal state
10:27:45 <EvanR> another component would be responsible for utilizing this information, or testing the dang thing
10:28:13 <EvanR> the code for this may not need any monadic anything
10:29:12 <Geekingfrog> So something like: InternalState -> CurrentTime -> (Maybe TimeToWait, InternalState) ?
10:30:11 * EvanR tries to come up with the most abstract version of this functionality
10:31:11 <EvanR> history of what happened so far -> whether you can do the next thing now
10:31:16 <EvanR> no state
10:31:33 <EvanR> (any state can be replaced with a full history of the past)
10:31:42 <Cale> Geekingfrog: Yeah, something like that
10:31:52 <Geekingfrog> EvanR, isn't that *really* inneficient ?
10:31:55 <EvanR> (and stateful programming is like na optimization on that)
10:32:12 <Cale> Geekingfrog: Perhaps  Either TimeToWait Task  rather than  Maybe TimeToWait
10:32:13 <EvanR> Geekingfrog: yep
10:32:25 <EvanR> but thats really whats going on
10:32:44 <Cale> It shouldn't be too inefficient. You can delete information about the past that you no longer need as an optimisation.
10:33:27 <reactormonk[m]> I've got an ADT which have a lot of the same fields - is there a way to shorten that into one? e.g. Enumerating OAuth error responses
10:33:34 <Geekingfrog> Cale, so you would bundle the task with the rate limiter? I was thinking more of something like acquire myRateLimiter; domything; with the acquire function perhaps blocking the current thread
10:33:54 <EvanR> ah right, for this thing you can provide a moving window of history
10:34:02 <reactormonk[m]> https://gist.github.com/b28b1e71230c9bcb18adf3709c48dec6
10:34:18 <Cale> Geekingfrog: Ah, right, you could just keep the queue separate here, since it's not like it will change your decision about what to pick
10:34:23 <EvanR> HistoryWindow -> Bool
10:34:49 <EvanR> or Maybe TimeToWait
10:34:56 <EvanR> functional programming rocks
10:35:20 <Geekingfrog> I'm still not sold on the history of events, but I'll give it a try anyway. Thanks for the suggestions Cale and EvanR 
10:35:41 <EvanR> since the whole history wont be necessary, that solves the efficiency issue
10:35:43 <Cale> Geekingfrog: Well, it doesn't need to be a complete history, but you need to know how to update it
10:35:57 <Cale> Geekingfrog: So presumably, it'll be some Set of timestamps
10:36:09 <Cale> and you can throw away any timestamps which are older than your window
10:36:17 <EvanR> a list of timestamps
10:36:27 <EvanR> you could have done two things at the same time, and that matters
10:36:36 <Cale> Can you?
10:36:41 <EvanR> sure why not
10:36:57 <EvanR> in a post handler, i always save the current time once, then log that into whatever i do
10:36:59 <Cale> I was assuming that he'd be doing one thing at a time, and then asking the rate limiter again
10:37:15 <EvanR> so it appears that a lot o things happen at the same time
10:37:46 <Cale> The other reason to use a Set would be that you can efficiently split it at an arbitrary point
10:38:11 <Cale> So that it becomes easy to discard the no-longer relevant timestamps
10:38:27 <EvanR> you need a multiset really
10:38:46 <EvanR> example, you are allowed to do a thing, then immediately ask again and are allowed to do antoher thing
10:38:59 <EvanR> the assumption that stuff takes time > 0 is kind of flaky
10:39:30 <Cale> If you want to allow multiple occurrences at once, then the requests need to say how many items you want to do right at that moment
10:39:32 <EvanR> if it doesnt show up in the set as having done more at that time, youll never be limited!
10:39:44 <Cale> Because the resulting amount of time you'll need to wait will depend on that
10:40:14 <Cale> Also, if you want to get really cute, there's a potential FingerTree data structure which would be very nice for that.
10:40:58 <Cale> (Your summaries would have the min timestamp in the subtree, as well as the sum of the task weights)
10:41:08 <EvanR> highly non cute, list -> bool, done
10:41:17 <Cale> hm?
10:41:17 <EvanR> testable, works
10:42:10 <EvanR> pulling in fancy data structures technology for this seems like overkill
10:42:11 <Cale> The point is, you need a data structure which is going to let you chop it at some arbitrary point in time, but also you need to be able to know the sum of all the items
10:42:14 <EvanR> yes overkill!
10:42:27 <EvanR> why do you need that?
10:42:57 <EvanR> trying to parallelize this simple task?
10:43:06 <Cale> No parallelism
10:43:40 <Cale> You need to be able to tell at what time you'll have enough resource remaining to fit the next task (assuming we're doing the more complicated weighted-tasks version)
10:43:41 <EvanR> i dont understand why you need to split a list
10:44:22 <EvanR> its not like you have history of the future
10:44:27 <Cale> and then having done that, you need to expire things from the history
10:44:44 <Cale> once they're old enough
10:44:50 <EvanR> oh youre talking about managing the history structure itself, not implementing the rate limiter function
10:44:55 <Cale> yes
10:45:03 <Cale> which is the interesting part of the rate limiter :)
10:45:08 <Geekingfrog> I'm actually going to implement that: https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/SmoothRateLimiter.java  which only requires an Int/Double as internal state.
10:45:40 <reactormonk[m]> Is there a "use the function defined in this class"?
10:45:44 <EvanR> a functional queue and be done with it
10:45:54 <Geekingfrog> like Seq ?
10:46:11 <Cale> This whole thing is *much* easier if the tasks are unweighted
10:46:11 <EvanR> well, i was thinking much simpler than that
10:46:29 <Geekingfrog> I do need weighted tasks though.
10:46:36 <geekosaur> reactormonk[m], most classes have more than one function. and, wanting to do that makes me suspect you're trying to use typeclasses as OOP, which won't work
10:46:38 <Cale> ah, okay
10:46:38 <reactormonk[m]> Ehh, not class, file.
10:46:56 <reactormonk[m]> geekosaur: got it, wrong name somehow.
10:47:18 <reactormonk[m]> ... I wanted "call function in this file". I've got Prelude.error conflict.
10:47:42 <geekosaur> you can fully qualify any imported name, including the implicit import of Prelude
10:47:44 <Cale> reactormonk[m]: You can explicitly qualify the module you want by writing it before the name with a dot (and no space) in between
10:47:53 <Cale> Just as you did there with Prelude
10:48:15 <Cale> But often you'll just want to import the module that you don't want the thing from with "hiding (whatever)"
10:48:23 <reactormonk[m]> Cale: what if the name is defined in the current module?
10:48:24 <Cale> e.g.  import Prelude hiding (error)
10:48:59 <Cale> You can use the current module's name to qualify, but if that's inconvenient, then just hide the import which conflicts
10:51:03 <nitrix> How can I prevent this `c` from `Game c a` to bubble up all the way to this `Result c` type?
10:51:05 <nitrix> https://github.com/nitrix/lspace/blob/develop/kawaii/Kawaii/Game.hs#L9
10:51:08 <nitrix> https://github.com/nitrix/lspace/blob/develop/kawaii/Kawaii/Ui.hs#L16
10:51:11 <nitrix> https://github.com/nitrix/lspace/blob/develop/lspace/Main.hs#L39
10:51:50 <nitrix> I can explain what I'm trying to achieve and my concern with the current solution.
10:52:40 <nitrix> `Game c a` is a newtype which contains both an internal state for the library, as well as parametrized over `c` which is a custom state the user can manipulate.
10:52:58 <nitrix> I made the instance `MonadState c (Game c)` following that idea.
10:53:55 <nitrix> Then the other big piece is that the engine lets you have UIs in your game, and each UI has an update and render phase. The update phase is able to create more UIs...
10:54:02 <Cale> nitrix: By getting rid of the Switch and Bring constructors?
10:54:12 <Cale> Or by choosing which c you want to use there?
10:54:54 <Cale> As you have it defined, Result has an obvious dependency on the choice of c
10:54:55 <nitrix> Cale: Is it possible to have it implicit or quantified is some manner that I can alleviate this? The library essentially never touches this `c` type.
10:56:14 <nitrix> Cale: I tried taking a step back with data Ui = forall c. { uiUpdate :: Event -> Game c Result, uiRender :: Renderer c () }
10:56:19 <Cale> So like, imagine that I just delete the type parameter, and don't tell you which type c is
10:56:26 <nitrix> Cale: (Silly attempt at cutting that chain of `c` bubbling up)
10:56:33 <Cale> sure, like that
10:56:43 <Cale> Now how are you ever going to use those things?
10:56:56 <EvanR> the library user wont know which Results are which
10:57:18 <Cale> uiUpdate becomes useless, because, while you can apply it to some Event, you get a result of type Game c Result, where you don't know which type c is
10:57:19 <EvanR> like you might have one parameterized over c1 and one over c2 and they look the same
10:57:33 <Cale> and so you can never actually run that thing
10:57:33 <nitrix> EvanR: updateMainMenu :: Event -> Game LonesomeSpace (Result LonesomeSpace)
10:57:44 <nitrix> I just find the type ugly.
10:57:45 <EvanR> client cant use them anyway, but if they could they might mess up
10:57:49 <nitrix> It's repetitive :(
10:57:55 <EvanR> you could use a type synonym
10:58:10 <EvanR> i did that with time bandit clone
10:58:17 <Cale> nitrix: You can just specify it in the Ui type
10:58:24 <EvanR> instead of putting TimeBandCloneState everywhere
10:58:42 <Cale> However, if things really are general with respect to the state, the type parameter is better
10:59:24 <Cale> If you specialise it to LonesomeSpace or whatever, then code which would otherwise be guaranteed not to fiddle with that state can then mess with it.
10:59:54 <Cale> So there are definite advantages to leaving it as a parameter, if that's possible at all.
11:00:24 <nitrix> I suppose I can have some ehm... type GameFoo c r = Game c (r c)
11:00:46 <nitrix> It's just very rare that `Game c a`   a ~ Result c
11:00:48 <Cale> What is it that's bothering you?
11:01:52 <Cale> I don't see anything wrong with just leaving it as  Game c [Ui c]
11:02:27 <Cale> It's a bit interesting that it's a list, but otherwise seems fine
11:03:23 <nitrix> Cale: Agreed. It was just to get it to work; I have a note to refactor it.
11:03:41 <nitrix> Cale: https://github.com/nitrix/lspace/blob/develop/kawaii/Kawaii/Core.hs
11:03:48 <nitrix> Cale: The core of the engine is relatively clean though :D
11:04:38 <Cale> Now, if you end up somehow with several type variables parameterising everything, maybe start to worry :)
11:04:40 <Geekingfrog> (That's a cute name)
11:05:11 <Cale> (but even that's not the end of the world, it's possible for that to just be the right thing in a given situation)
11:05:12 <geekosaur> i l a s sd...
11:05:30 <nitrix> Cale: Long story short, it was always Game a, and Ui, and Result and all. Then yesterday, I figured it would be nice for the user to have their custom state in that Game monad, so I added `c`, then it ended up poluting everything.
11:05:42 <nitrix> Cale: And I'm really, really, questioning if I still want it now today :/
11:06:16 <Cale> nitrix: You could just say, oh, you want custom state? Use StateT then.
11:06:41 <Cale> Oh, and also get rid of the MonadState instance for Game
11:07:09 <nitrix> Cale: That's... actually a good idea. Because the library is never, ever going to touch the `c`.
11:07:16 <Cale> Instead, define a new type class for manipulating the system's game state (possibly with more meaningful operations than 'get' and 'put')
11:07:44 <nitrix> So, the user can create their own `newtype Foo a = Foo { runFoo :: StateT LonesomeSpace Game a }`   :O
11:07:51 <Cale> and just implement it in terms of the StateT you have there
11:07:52 <Cale> yeah
11:08:26 <nitrix> Cale: Oh yeah for sure, the internal state of Game is/will be managed via monadic operations of type Game, you cannot touch the engine gamestate yourself.
11:08:40 <nitrix> Gotta user playerMove :: Player -> Game () and so on.
11:08:43 <nitrix> *use
11:08:44 <Cale> I've started to be of the opinion that usually the monads and transformers you define should *not* be instances of the MTL type classes, apart from lifting instances for transformers.
11:09:31 <nitrix> I really appreciate the rubber ducking by the way. I think I'm headed in the wrong direction and should remove that `c` and the MonadState instance.
11:09:57 <ystael> rubber duck, vt. to beat about the head and shoulders with a child's bath toy
11:09:58 <Cale> Instead, always make new type classes exposing part or all of the functionality of the transformers you used, and -- well, this is part and parcel of my old opinion that usually it's best to hide the fact that you're using monad transformers at all
11:11:22 <nitrix> Right. My previous engine was doing this. I have a little more freedom now because I'm pulling it out as a library and I'm able to chose what's exported, but it's a bit of a cheat :P
11:12:05 <nitrix> e.g. gameLiftIO. The library is able to lift any IO in that Game monad, but the user cannot.
11:12:39 <Cale> right
11:13:59 <DrMentats> is there anything equivalent to type families without parameters?
11:14:21 <geekosaur> huh?
11:14:24 <DrMentats> I'd like the programmer to be able to define new constructors without having to parameterize the type
11:15:04 <geekosaur> adding constructors to an existing type?
11:15:09 <freeside> https://wiki.haskell.org/Phantom_type ?
11:15:12 <DrMentats> basically, yes
11:15:14 <nitrix> Geekingfrog: I know right :D ? Cute name for a cute engine. Some pieces are clean, some pieces are ugly, and most of it is legacy that needs to be ported, but I'll get there.
11:15:18 <EvanR> maybe DataKinds ?
11:15:20 <nitrix> Geekingfrog: I'll show you when I'm done c:
11:15:22 <geekosaur> how do you expect that to work? types disappear after the typechecker has run
11:15:37 <DrMentats> well, the use case is this
11:16:06 <DrMentats> I have: data Value = Bool Bool | Char Char | etc., which represents values in a dynamic language
11:16:15 <ertesx> DrMentats: Either can add constructors to an existing type
11:16:19 <DrMentats> I'd like to define new cases and pattern match on them, while still being able to make [Value]
11:17:36 <freeside> https://hackage.haskell.org/package/compdata
11:22:53 <Cale> DrMentats: Okay, so what happens when you write a function which knows how to deal with what you consider to be all the constructors of Value at the time, but then someone goes and adds a new constructor? They're going to need to put in information somehow about how to implement these operations you'd already provided, but for the new cases.
11:23:32 <freeside> https://en.wikipedia.org/wiki/Expression_problem
11:23:41 <DrMentats> well, good point
11:24:03 <Cale> If that's fine, perhaps what you want is to specify the data type in terms of all the operations which you need to know how to perform
11:24:27 <Cale> i.e. it should be a record type of functions, rather than a sum type
11:25:14 <Cale> and then you'll have functions which build that record from various sorts of values, for the existing cases
11:25:45 <Cale> i.e. basically object oriented programming
11:26:24 <DrMentats> unfortunately I can't know what operations the user may implement later
11:27:28 <DrMentats> I know this sounds bad, but I was kind of expecting I could just do a catch-all for the constructors that shouldn't be used and print an error
11:27:32 <DrMentats> well, never mind
11:27:54 <Cale> You *could* add a case like  data Value a = ... | Other a
11:28:21 <DrMentats> yes, that is almost what I'm doing now, except I'm using Data.Dynamic
11:28:32 <Cale> and then you implement some operations which are polymorphic with respect to that Other case
11:28:52 <EvanR> haskell might not be the best monkey patchable language
11:29:48 <Cale> It's possible to engineer anything you might want, it's just you have to make some decisions up-front about how bendable things are going to be.
11:30:06 <freeside> you can get anything you want at Alice's restaurant -- excepting Alice.
11:30:58 <DrMentats> lol
11:31:22 <ertes> DrMentats: perhaps what you need is something like the dependent-sum library
11:31:29 <ertes> i don't know your application, so i can't tell
11:32:55 <DrMentats> I appreciate all suggestions, at the very least I'll learn something new for a future use case
11:39:15 <freeside> so, i'm building a language that's similar to SQL -- fairly limited syntax intended for business users, so i don't want to give them too much rope. Should I go with Alex+Happy or Trifecta?
11:40:10 <Tuplanolla> One vote for Megaparsec just because, freeside.
11:40:39 <freeside> ok
11:42:58 <freeside> it's not clear to me how these parsers play with one another -- they all seem to be able to do tokenization, though many seem to prefer to hand tokenization to Alex.
11:43:38 <Tuplanolla> Parser combinators don't require it at all.
11:44:07 <geekosaur> lexing doesn't particularly need to be separate; tht came about because of ancient small memory computers
11:46:09 <freeside> megaparsec looks straightforward, thanks. i'll try it.
11:46:14 <freeside> later, if i want to do stunts, i'll try trifecta.
12:20:54 <the_2nd> what is the mapM for "Except e a" ? I was using Either e a before and used mapM there
12:22:12 <Tuplanolla> What are the options, the_2nd?
12:22:30 <geekosaur> :t mapM
12:22:32 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:23:36 <the_2nd> ah of course. I changed some other part and got confused
12:23:48 <the_2nd> the transformers are monad themselves
12:26:15 <freeside> Transformers! Monads in disguise! Transformers! More than meets the eye!
12:27:48 <EvanR> what, transformers arent themselves monads
12:28:06 <EvanR> they send monads to monads
12:28:59 <EvanR> if m is a monad, ReaderT r m is a monad, but ReaderT is not
12:29:30 <the_2nd> I feel like i activated something :D
12:31:06 <thimoteus> freeside: i laughed in real life
12:31:30 <the_2nd> where would you laugh otherwise?
12:31:50 <qmm> does it make sense to use parer combinators in a non-strict functional language?
12:32:08 <thimoteus> the_2nd: in my head
12:32:17 <qmm> a non-strict, statically typed language
12:32:30 <qmm> in the ML family, not haskell, clearly :)
12:33:00 <EvanR> huh
12:33:05 <thimoteus> why wouldn't it make sense?
12:33:35 <shapr> qmm: yeah, why not? I've seen parser combinators used to good effect in Java and other languages.
12:33:51 <qmm> EvanR: i guess you could make it lazy when you need it most for parsers
12:33:56 <qmm> s/parsers/parsing
12:34:04 <EvanR> haskell is a non strict statically typed functional language
12:34:20 <EvanR> did you mean strict?
12:34:27 <qmm> hah! yeah, i did
12:34:53 <qmm> was just wondering, thanks for the input!
12:35:06 <thimoteus> oh, in that case yes, purescript fits the bill and there's a lot of parsing libraries that use parser combinators
12:35:23 <geekosaur> the token stream is a stream regardless of whether the language makes random data types behave like streams or not
12:36:12 <geekosaur> I mean, parsec 3 still manages even though it supports strict Text as a source of Char tokens
12:36:43 <shapr> qmm: I think the essence of your question is: do parser combinators rely on laziness. Is that correct?
12:37:15 <kamyar> Hello All
12:37:25 <shapr> howdy kamyar, how's code?
12:37:31 <kamyar> please answer my somewhat easy question:
12:37:48 <kamyar> I know differences between Cabal and Stack for building Haskell
12:38:06 <kamyar> I know I can use stack to make a new project and ....
12:38:31 <kamyar> But I want GHC and GHCI to use my .stack directory as default module search path instead of .cabal
12:38:50 <shapr> stack ghci ?
12:38:55 <kamyar> I mean when I am not making a new directory for new project, e.g. I am just creating a single file small utility
12:39:08 <kamyar> I dont want to say "stack ghc" or "stack ghci"
12:39:09 <geekosaur> stack ghci, stack ghc
12:39:21 <geekosaur> ghc is a compiler, not an environment manager
12:39:22 <shapr> kamyar: alias ghci=stack ghci
12:39:26 <kamyar> Can I change the default path?
12:39:47 <geekosaur> not usefully, no
12:40:03 <geekosaur> it;'s not like stack uses a custom ghc, it sets up an environment for ghc/ghci
12:40:05 <kamyar> I just want GHI and GHCI use .stack instead of .cabal
12:40:11 <geekosaur> so you have to run them through stack to get hat environment
12:40:15 <kamyar> within my home directory
12:46:04 <kamyar> Thanks anyway
12:46:15 <kamyar> Can I ask another question?
12:46:57 <geekosaur> one may always ask. the answer may not always be what you hope...
12:47:14 <geekosaur> (probably shapr's suggestion of aliases is best for your first question btw)
12:47:18 <kamyar> What is the difference between WAI and WARP?
12:48:56 <geekosaur> WAI is just routing; it expects to be used with a server, although it has a very simple one built in for testing or etc. Warp is a full-featured web server.
12:49:25 <kamyar> thanks geekosaur
12:50:17 <kamyar> Do u recommend me to use Scotty (I like Sinatra-like libs) or use Warp directly for a production service?
12:51:13 <geekosaur> I have no recommendations; I don;t normally do web stuff
12:51:43 <kamyar> Thanks :geekosaur
12:51:47 <kamyar> bye for now
13:05:38 <hexagoxel> is there a new haskell report being planned/worked on?
13:07:18 <geekosaur> there's a new haskell prime committee; their list seems reasonably active, unlike last time I looked
13:07:35 <geekosaur> or, hm, maybe not; missing months in archive list
13:07:44 <iqubic> Hello guys.
13:07:50 <iqubic> What's going on here?
13:09:02 <iqubic> Anyone have a good lenses tutorial I can look at>
13:09:03 <iqubic> ?
13:10:26 <geekosaur> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial ?
13:14:03 <hexagoxel> geekosaur: thanks, at least i know the keyword "prime" again :p ("report" doesn't yield much, unfortunately..)
13:17:58 <lpaste> fizbin pasted ‚ÄúStrictness questions‚Äù at http://lpaste.net/6848677295977136128
13:19:05 <fizbin> Hey, so a bit ago (last Thursday?) I was asking questions about how to avoid a stack space overflow. Here's the follow-up and what I came up with.
13:19:30 * geekosaur thinks NFData might be relevant here
13:19:56 <fizbin> (Thank you, Cale , for suggesting that what fastInsEdge does to Adj lists was building up unevaluated stuff)
13:21:21 <fizbin> geekosaur: Yeah, except for other reasons an NFData constraint on the types "a" and "b" would be tricky, and without that I can't really take advantage of any other NFData instances.
13:23:47 <srbaker> Anyone aware of a not-insignificant GTK app built in Haskell? I'm looking for some tips on how ot organize some ofthis stuff.
13:24:46 <fizbin> Anyway, I just kind of threw together that strictify method a bit haphazardly, and I'd love to know what more experienced Haskellers would do to avoid stack overflow there.
13:27:53 <iqubic> Are lenses ever useful in Haskell?
13:28:53 <Tuplanolla> Most of the time, iqubic.
13:29:01 <geekosaur> fairly often if you are working with records
13:29:18 <geekosaur> standard Haskell's record story isn't very good
13:29:27 <iqubic> Should I use Prisms too?
13:29:40 <Tuplanolla> If you feel like it.
13:30:29 <geekosaur> (there is ongoing work to change this, mostly by automating making simple lenses that can be adapted to work with the lens library or other lens/digestive functor implementations)
13:30:49 <iqubic> How do I make a lens in Haskell?
13:31:29 <geekosaur> you probably want to read and understand that tutorial I sent earlier
13:31:52 <iqubic> I have. Still a bit confused on how to make Lenses.
13:32:26 * monochrom bookmarks it and procratinates learning it :)
13:32:57 <iqubic> Also, does the over function return a new record?
13:33:02 <iqubic> Or how does that work?
13:33:12 <monochrom> But wait, I don't need to be talked down to about forall! :)
13:33:31 <iqubic> What does forall do?
13:33:34 <iqubic> :t forall
13:33:35 <lambdabot> error:
13:33:35 <lambdabot>     ‚Ä¢ Variable not in scope: forall
13:33:35 <lambdabot>     ‚Ä¢ Perhaps you meant ‚ÄòforAll‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
13:33:42 <iqubic> :t forAll
13:33:44 <lambdabot> (STestable prop, Show a) => Gen a -> (a -> prop) -> Test.QuickCheck.Safe.SProperty
13:34:00 <iqubic> That's not what I want at all, is it?
13:34:11 <eschnett> iqubic: no, it‚Äôs a keyword ‚Äúforall‚Äù, needs to be enabled as extension
13:34:32 <iqubic> Which extension? TemplateHaskell?
13:34:32 <Tuplanolla> If you want to understand lenses comprehensively, take a look at Lens over Tea, iqubic.
13:35:02 <Tuplanolla> Just keep in mind it refers to a sea of tea.
13:35:04 <iqubic> You mean this? https://artyom.me/lens-over-tea-1
13:35:13 <iqubic> What is a sea of tea?
13:35:22 <Gurkenglas> iqubic, try this lens tutorial https://hackage.haskell.org/package/lens-tutorial-1.0.2/docs/Control-Lens-Tutorial.html in particular Ctrl-F for "How do I create lenses?" and "over"
13:35:34 <monochrom> A sea of tea is my dream come true. :)
13:36:24 <Gurkenglas> iqubic, he meant that you're gonna be drinking a lot of tea if you read that tutorial while drinking tea
13:36:52 <monochrom> That is not sea of tea. That is so much tea you need to pee.
13:37:04 <iqubic> What does the Language Pragma Template Haskell add?
13:38:19 <Gurkenglas> It allows you to write programs that generate code. If a library asks you to enable Template Haskell to use a feature, that means they need to generate some code for you, for example lens which can define lenses for your data types if you allow it to write code
13:38:34 <iqubic> I see.
13:39:01 <iqubic> So Control.Lens requires Template Haskell?
13:39:24 <Gurkenglas> Only if you want to have it automatically define lenses for your data types
13:40:39 <iqubic> So to make a lense I just put MakeLenses as a top level statement?
13:42:07 <Gurkenglas> You're gonna have to spell it like in the example, but basically yes, that's the invocation that tells lens to automatically define lenses for you using TemplateHaskell
13:44:37 <iqubic> So, how can I make a lens without TemplateHaskell?
13:45:04 <Gurkenglas> iqubic, use Ctrl-F -> "How do I create lenses?" on the link I posted above
13:48:21 <monochrom> Wouldn't it be cool if, one day, every what-is question can be answered by "expand pi in binary and start reading at the ________th bit"
13:48:58 <monochrom> "Hi I need a monad tutorial." "Start reading at the 29038493024834084305th bit"
13:49:06 <Gurkenglas> The number of the bit would be as long as the tutorial.
13:49:50 <JuanDaugherty> i'd need the multiple worlds interpretation for that
13:50:39 <Gurkenglas> JuanDaugherty, explain.
13:51:03 <monochrom> OK, next idea. Wouldn't it be cool if, one day, every what-is question were answered by "inverse the SHA256 hash __________________________"
13:51:23 <thimoteus> we'd need a proof that pi is base-2 normal
13:51:26 <dolio> No, that wouldn't be cool.
13:51:31 <JuanDaugherty> there'd be one where anything could be done if infinite time were allowed. In real life I'm vehemently opposed to many worlds.
13:51:37 <monochrom> "Hi I need a monad tutorial." "Look for the second smallest number that SHA256-hashes to 0x3209f09230a20348aebfe"
13:51:47 <kadoban> monochrom: xD but wouldn't you have to specify which inverse it is, and wouldn't that take as many bits as the original on average, at least?
13:52:13 <monochrom> I don't know. These are all 5%-baked ideas. :)
13:52:15 <Gurkenglas> monochrom, the number in place of "second" would be as long as the tutorial minus the length of the hash.
13:52:31 <Gurkenglas> entropy be a harsh mistress
13:52:33 <Tuplanolla> > permutations "fun software" !! 25119930
13:52:38 <lambdabot>  "runoff waste"
13:52:50 <monochrom> Haha that's cool.
13:52:59 <Sonolin> lol wut
13:53:31 <Sonolin> ok I see it now... cool trick though :)
13:54:13 <hc_> lol :)
13:55:27 <monochrom> How did you found the number 25119930?
13:55:46 <monochrom> I guess brute-force search works fine.
13:55:59 <Gurkenglas> JuanDaugherty, manyworlds does not allow NP computations any more than the other interpretations as far as we know, and as far as I know we don't know whether locating a text within pi must be bruteforced.
13:56:26 <JuanDaugherty> k
13:56:50 <Cale> fizbin: The thing to do, rather than periodically strictifying things, is just to be cautious/intentional about what is going to be evaluated as you proceed with an algorithm. Sometimes you might not want to just evaluate everything -- but if there's potential for building up large unevaluated expressions, probably more evaluation is warranted.
13:57:28 <Tuplanolla> It does, monochrom. There's a better algorithm too.
13:57:56 <Tuplanolla> Unfortunately `permutations` does not generate things in lexicographic order, so it doesn't work as nicely.
13:58:03 <Cale> monochrom: It would be even cooler if pi were found to not be normal.
13:59:08 <monochrom> Ah, but the coolest outcome is that pi is not normal and the reason is it contains more monad tutorials than average. :)
13:59:27 <Cale> ahahaha
14:00:05 <kadoban> Hah
14:00:08 <Cale> As far as we know, it's possible that once you go far enough out, it's just 3's, 7's, and monad tutorials (encoded with 5's and 8's)
14:00:25 <thimoteus> but infuriatingly they're all misleading tutorials
14:00:47 <kadoban> That seems like it'd be a proof of ... something metaphysical. Maybe that god exists and he has the worst sense of humor possible.
14:01:36 <Cale> Or something deep about humanity. We're responsible for defining circles in the first place after all.
14:02:11 <Gurkenglas> No that doesnt work kadoban, you can posit a hypothetical universe beyond the reach of god where only physics and math reign, and there'd still be monad tutorials in that world's pi
14:02:54 <monochrom> But you can weaken "proof" to "suggestive evidence"
14:03:03 <Gurkenglas> So monad tutorials in our pie do not tell whether God exists
14:03:16 <Cale> Platonism will be the last god we need to kill.
14:03:27 * kadoban runs away, my head already hurts
14:04:16 <Gurkenglas> I'd count it as evidence for "this story is wrong" aka descartian demon aka someone played a prank on the pi computation researchers
14:04:33 <fizbin> Cale: It's unclear to me how that general advice applies in this case.
14:04:54 <Cale> fizbin: Well, make fastInsEdge better.
14:04:55 <fizbin> I mean, I'm going to want to do various things to the final graph, with all the edges added.
14:05:26 <Cale> (or if the existing version of it is deemed important, make a stricter variant of it)
14:06:09 <Cale> Or... well, I forget the scenario, but probably some individual operation on graphs was not sufficiently strict, just at the place where it was doing its work.
14:06:18 <Gurkenglas> kadoban, oh if you mean that it's evidence that god reached in and replaced some section of pi on your hard drive with a monad tutorial, that's fine.
14:07:04 <kadoban> Well, it seems like it'd have to be evidence that *something* is fucking with us at some level, if that were to happen. Though it's unclear at what level would be most probable, or at that point if it's even possible to tell.
14:07:36 <Cale> Gurkenglas: What if it was that said deity reached into the heads of earlier humans and put circles there so that they would have plenty of monad tutorials later?
14:07:47 <Cale> lol
14:08:04 <Gurkenglas> There's a simple turing machine that computes pi, circles are irrelevant
14:08:10 <kadoban> Cale: Even more disturbing, and kind of mind bending because it doesn't seem like circles themselves could even be that deeply encoded xD
14:08:19 <fizbin> Cale: Though I do use this "break a list arg into chunks and strictify after each chunk" pattern in another place where that advice totally applies.
14:08:30 <Cale> kadoban: Well, they probably can't be.
14:09:10 <kadoban> Cale: Or maybe they just seem like they can't be because we've been fiddled with.
14:09:26 <Cale> Gurkenglas: Circles are only relevant insofar as they're how we came to define pi and regard it as an important thing.
14:09:40 <Cale> Gurkenglas: There are Turing machines which compute lots of stuff.
14:10:17 <Gurkenglas> Short turing machines that generate monad tutorials are... actually, those are fine. Huh.
14:10:29 <Cale> pi wouldn't exist without us, and our particular ways of considering circles.
14:10:47 <JuanDaugherty> srsly?
14:10:58 <Cale> So far as I'm aware, anyway
14:10:59 <merijn> Cale: You're making some pretty strong epistemic assertions there ;)
14:11:11 <monochrom> inb4 <Cale> Platonism will be the last god we need to kill.
14:11:12 <Gurkenglas> Any flat universe with at least two spatial dimensions has pi
14:11:13 <thimoteus> you can pry my platonism from my cold dead hands
14:11:14 <Cale> I have no evidence to the contrary
14:11:45 <merijn> This discussion is way too complex for this time of day >.<
14:11:59 * JuanDaugherty marks that down, must be important, Pi is a cultural artefact
14:12:00 <Gurkenglas> There's a bunch of *really* simple series that converge to something to do with pi
14:12:05 <monochrom> Yes. Study parametricity with me. It's easier. :)
14:12:46 <merijn> monochrom: I just got back from lifting heavy things and throwing them back down. That's even simpler! Although, suspiciously said things where circles...
14:12:46 <Cale> Gurkenglas: But when did you ever run into a series untouched by a human?
14:13:17 <Gurkenglas> Do you also count natural numbers, multiplications etc as touched by humans?
14:13:21 <Cale> yes
14:13:24 <merijn> Although, I guess, not necessarily easier...
14:13:37 <thimoteus> so we've arrived at "the math that humans do is done by humans"
14:13:56 <Gurkenglas> Give me a place to stand on and I shall move the Earth. What is not touched by humans?
14:14:08 <Cale> So far as I'm aware, we don't know of any non-humans which are doing mathematics
14:14:20 <ertes> are we back to the "is math discovered or invented?" question?
14:14:25 <merijn> ertes: Yes
14:14:33 <ertes> answer: both
14:14:36 <thimoteus> i'm pretty sure my computer is "doing mathematics"
14:14:37 <iqubic> It is a bit of both I think
14:14:48 <monochrom> My friend has a better question. Is math inflicted? :)
14:15:08 <Gurkenglas> thimoteus, that doesnt work, he'll say your computer is touched by humans
14:15:11 <merijn> I say discovered, based on for example, the fact that you can't convince anyone of modus ponens or induction, unless they a priori already believe them deep down
14:15:13 <monochrom> (A clear "yes" from students, clearly. :) )
14:15:15 <shapr> ooh, stdlib found an empty flrc repo on https://github.com/IntelLabs with the title "Haskell Research Compiler"
14:15:25 <Tuplanolla> I also like "do proofs have to involve understanding".
14:15:26 <monochrom> On that note, to many students, Haskell is also inflicted.
14:15:39 <ertes> we invented prime numbers, then discovered that 2 is the smallest prime
14:15:40 <shapr> would be neat to have another Haskell compiler around
14:15:53 <merijn> shapr: Isn't that the one that optimises Core from 2013?
14:15:58 <shapr> yup
14:16:01 <shapr> http://ezyang.tumblr.com/post/62151067095/haskell-the-intel-labs-haskell-research-compiler
14:16:26 <merijn> shapr: It didn't actually compile Haskell, just had GHC produce Core and used that as a convenient IR to optimise, iirc
14:16:34 <monochrom> Intel Labs has a super secret Haskell compiler they needed to redact?! :)
14:16:53 <merijn> Funnily enough, I was at a conference talking to Intel guys doing Haskell and someone mentioned another Intel haskell project and they weren't even aware of it
14:17:04 <shapr> monochrom: that they need to release
14:17:09 <Cale> Is Haskell invented or discovered?
14:17:11 <merijn> monochrom: Some people in Twente are working on a CPU design for lazy functional languages
14:17:23 <monochrom> Neato.
14:17:27 <shapr> merijn: something other than the reduceron? tell me more!
14:17:32 <merijn> Cale: Clearly the answer is neither: It was stolen from Martians
14:17:44 <shapr> Simons says
14:17:51 <merijn> shapr: This was 3 years ago, I completely forgot all details, sadly
14:18:05 <shapr> :-(((
14:18:25 <merijn> actually...4 years...time flies
14:19:55 <Gurkenglas> You know, pi could contain more monad tutorials than average. It'd just need to contain a computation model and encode the outputs of all programs, some of which are minds that'd think it funny to output monad tutorials, for example us.
14:23:06 <TreyHarris> has it been proven that every possible sequence of digits occurs somewhere in pi's expansion?
14:23:13 <Tuplanolla> No.
14:23:38 <ertes> what about every finite sequence?
14:23:55 <Tuplanolla> Isn't that the same thing?
14:24:00 <merijn> Tuplanolla: No
14:24:14 <merijn> Tuplanolla: There's an infinite number of infinite sequences :p
14:24:17 <monochrom> Neither. (And mathematicians have only considered finite sequences.)
14:24:41 <merijn> Pretty sure it's uncountably infinite infinite sequences, even
14:24:59 <monochrom> Yes, unless one insists on a constructive logic.
14:25:13 <ertes> funny‚Ä¶  i thought that it was proven that you can find any finite sequence in the decimal expansion of pi
14:25:56 <ertes> so it's just a myth?  but then it's a fairly common one
14:26:22 <merijn> Which is trivially proven false by sequences such as "0010110111011110", which can be made infinite and loads of finite sequences are not in it
14:27:10 <sampuka> but that's a pattern
14:27:15 <sampuka> isn't pi proved to not be a pattern?
14:27:26 <ertes> sampuka: no, pi has a pattern, too
14:27:42 <Cale> pi isn't proved to be normal in any base
14:28:17 <Cale> It's not even proved that it contains all decimal digits infinitely many times.
14:28:21 <ertes> at least for some value of "pattern"‚Ä¶  you can write a formula for pi
14:28:23 <kadoban> normal is ... digits are distributed uniformly or sometihng?
14:29:00 <Cale> Yeah, normal in base b means that the probability of finding each digit in the base b expansion tends to 1/b
14:29:08 <kadoban> It would be so cool if eventually there's just no 7s anymore or something wacky.
14:30:30 <Cale> oh, sorry, that's not enough
14:30:52 <Cale> It needs to be that the probability of finding a word of length n is 1/b^n
14:31:41 <Cale> and it's "normal" if it's normal in every base b > 1
14:32:29 <Cale> Very few numbers are known to be normal in any base, and all the known examples are fairly contrived.
14:33:03 <kadoban> Pretty interesting. Initially it'd seem like that'd be almost implied by transcendental or irrational or something, but ... ya just totally isn't.
14:33:40 <Cale> But at the same time, almost all real numbers are normal (in that the set of non-normal numbers can be shown to have Lebesgue measure 0)
14:34:31 <kadoban> That's rather funny, almost all of them are, but we know of almost none
14:34:46 <thimoteus> that's not uncommon in math
14:34:57 <thimoteus> i once had a professor who said the more things there are, the harder it is to pick out any particular one
14:35:01 <ertes> > "0." ++ ([1..] >>= \n -> concat (replicateM n ['0'..'9']))
14:35:03 <lambdabot>  "0.0123456789000102030405060708091011121314151617181920212223242526272829303...
14:35:14 <ertes> this one should contain every finite sequence of digits
14:35:24 <Cale> Yeah, that thing is actually normal in base 10
14:35:36 <Cale> It's called Champernowne's number
14:35:55 <Cale> er, well, almost
14:35:59 <Tuplanolla> Why do number theorists care about base 10?
14:36:02 <ertes> you could have left me with the illusion that i just invented a super-clever sequence =)
14:36:06 <Cale> They generally don't.
14:36:13 <thimoteus> every base is base 10 ...
14:36:26 <ertes> Tuplanolla: my bases are usually prime
14:36:44 <Cale> ertes: Actually, yours is slightly different from Champernowne's, his was more like
14:37:06 <Cale> > "0." ++ concatMap show [1..]
14:37:08 <lambdabot>  "0.1234567891011121314151617181920212223242526272829303132333435363738394041...
14:37:56 <ertes> i think it's almost the same except for a prefix
14:38:28 <ertes> interestingly you can start with any 'n' and still get a sequence that has all subsequences
14:38:53 <ertes> > "0." ++ concatMap show [5837495873..]
14:38:55 <lambdabot>  "0.5837495873583749587458374958755837495876583749587758374958785837495879583...
14:39:03 <ertes> still contains all finite sequences of digits
14:39:27 <kadoban> Because eventually it wraps to  x00000000 and then slowly you get all of the smaller ones, and you get all of the bigger ones of course I guess?
14:39:39 <ertes> yeah
14:41:42 <ertes> here is a fun challenge: prove that there are uncountably many sequences that contain all finite sequences
14:42:15 <Tuplanolla> Assume not...
14:42:32 <kadoban> Oh god, that might be beyond me
14:42:32 <ertes> here is a fun challenge: prove constructively that there are uncountably many sequences that contain all finite sequences
14:42:49 <thimoteus> you can pry my classical logic from my cold dead hands
14:44:04 <Cale> http://dx.doi.org.secure.sci-hub.bz/10.1016%2FS0304-3975%2801%2900170-0
14:44:06 <monochrom> I prefer to be tautological. You can pry my cold dead hands from my cold dead hands. :)
14:46:04 <Cale> The amusing thing is that no digits of their computable absolutely normal number are apparently known
14:47:19 <monochrom> Oh God, just what I was worrying: a computable number that we don't know how to compute.
14:47:38 <Cale> I'm not sure that we don't know how to compute this one, it's just obnoxious
14:47:52 <monochrom> OK, true.
14:51:07 <srk> I'm looking for qt5 bindings, any suggestions?
14:51:22 <srk> I would like to port python qt + opengl app to haskell but so far I'm not sure
15:08:55 <thimoteus> ertes: i think i have a proof. the set FS of finite sequences is countable, and if you just consider all the permutations of this set (call it Sym(FS)), that will be a subset of the set of all sequences that contain all finite subsequences. So since FS is countable, Sym(FS) has cardinality |FS|^|FS|
15:14:55 <ertes> thimoteus: nice!
15:41:17 <imalison> I need help figuring out why https://gist.github.com/58170cd945606737c18c4e304c07e70f is giving me ambiguous instanc errors
15:41:55 <glguy> instance ... =>          InfoJoinable LayoutInfo l a where
15:42:19 <glguy> overlaps with:      instance   InfoJoinable l l2 a
15:42:49 <glguy> and that second one also overlaps with instance ... =>     InfoJoinable l LayoutInfo a where
15:42:57 <glguy> It doesn't matter that you wrote stuff on the left side of the =>
15:43:58 <glguy> 'InfoJoinable l l2 a' is the only instance you need, every other instance will conflict with it
15:47:20 <Gurkenglas> :t \f -> fmap fold . traverse f -- Can this be made to require Foldable t instead of Traversable t?
15:47:21 <lambdabot> (Applicative f, Traversable t, Monoid b) => (a -> f b) -> t a -> f b
15:47:36 <Gurkenglas> (I smell alaf)
15:48:03 <glguy> Gurkenglas: There's a newtype I've wanted where you can do that with foldMap
15:48:42 <glguy> It'd probably be: (a -> f ()) -> t a -> f ()
15:48:56 <glguy> oh, or I guess you could get it with a Monoid b, too
15:49:54 <glguy> newtype ApMappend f a = AM (f a); instance (Monoid a, Applicative f) => Monoid (ApMappend f a) where mempty = AM (pure mempty); 
15:50:08 <Gurkenglas> :t traverse_ -- For "(a -> f ()) -> t a -> f ()", isn't that just this?
15:50:09 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
15:50:40 <glguy> that doesn't use monoid to combine the things
15:50:53 <glguy> mappend (MA x) (MA y) = MA (liftA2 mappend x y)
15:52:09 <Gurkenglas> It's App! https://hackage.haskell.org/package/monoids-0.3.2/docs/Data-Monoid-Applicative.html#t:App
15:52:31 <Gurkenglas> (dammit kmett)
15:52:34 <glguy> :t \f -> foldr (liftA2 mappend . f) (pure mempty)
15:52:36 <lambdabot> (Monoid c, Applicative f, Foldable t) => (a -> f c) -> t a -> f c
15:53:41 <Gurkenglas> (I mean the undeprecated Ap https://hackage.haskell.org/package/reducers-3.12.1/docs/Data-Semigroup-Applicative.html#v:Ap )
15:54:10 <glguy> :t foldMapBy (liftA2 mappend) (pure mempty)
15:54:12 <lambdabot> (Monoid c, Applicative f, Foldable t) => (a -> f c) -> t a -> f c
15:55:34 <Gurkenglas> Ooh nice that one's going into the arsenal
15:56:14 <qmm> shapr: that is kind of the essence of the question. another way of putting it: what am i giving up by using parser combinators in a language where laziness isn't optional
15:59:00 <TreyHarris> That feeling when... out of a general sense of goodwill, you write a patch to do a bunch of messy doc fixes in a package whose documentation is for an older version, create the pull request... and _then_ notice that other people had PRs to do the same months ago and were ignored
16:00:29 * TreyHarris feels very virtuous --> feels like a chump
16:01:01 <kadoban> TreyHarris: :(
16:02:50 * JuanDaugherty would not show a general sense of goodwill on the open savannah
16:04:16 <newsham> ?src ixmap
16:04:16 <lambdabot> Source not found. There are some things that I just don't know.
16:12:18 <Gurkenglas> TreyHarris, that's when you ask hackage to make you the maintainer
16:13:18 <TreyHarris> Gurkenglas: except the reason I wrote the fixes was because I figured it out struggling with trying to use it, I barely understand the code as written ;-)
16:14:49 <Gurkenglas> That's when, hm. You ask reverse dependencies if they'd like to ask to be made maintainer? Which package is this?
16:15:21 <TreyHarris> heh. numerals
16:15:54 <Gurkenglas> Right, coulda just looked on your github
16:19:05 <Gurkenglas> roelvandijk appears very active. Maybe he just doesn't notice those notifications?
16:20:06 <TreyHarris> Gurkenglas: yeah, I looked at his overall activity before starting the patch and saw the same. I _thought_ I'd checked for redundant PR's but must've flaked
16:23:00 <TreyHarris> mine's more complete, though, so maybe he didn't accept the others because they weren't, but he'll see the notification and use mine... think happy thoughts :-)
16:54:49 <dzdcnfzd> I'm making a toy blog using servant. I want it to do exactly two things: show and upload posts. The posts don't need to be stored anywhere other than memory for now. I'm wondering if I'll have to store the posts in some sort of IO reference, or if it's possible to store them in a pure value
16:55:58 <dzdcnfzd> If this were an Elm app, it'd be based on a fold where every POST to the server updated the state of the app
16:57:06 <Welkin> dzdcnfzd: just use sqlite then
16:57:14 <Welkin> it's easier than trying to store them in memory
16:57:20 <Welkin> and you don't need to install a database
16:57:33 <dzdcnfzd> Welkin: If I use a DB, I know how to do it
16:57:33 <Welkin> I suggest using Persistent as your ORM
16:57:39 <dzdcnfzd> I'm asking more of a conceptual question
16:57:55 <Welkin> yes, you *can* do this
16:57:56 <Welkin> but why?
16:58:02 <Welkin> just use sqlite
16:58:35 <dzdcnfzd> Because I'm just getting into Servant and so these sorts of questions are how you learn :)
16:59:16 <Welkin> your question has nothing to do with servant
17:01:07 <dzdcnfzd> Welkin: yes it does. Anyways, here's the paste of what I was trying to do, and failing: http://lpaste.net/7161564774432505856
17:06:35 <Cale> dzdcnfzd: Well, there are a lot of ways you could store the posts in memory
17:07:01 <dzdcnfzd> Cale: I'm wondering if it can be done in a pure value
17:07:09 <Cale> Yeah, probably
17:07:43 <Cale> I'm not sure about with servant though...
17:07:45 <Cale> hm
17:08:51 <Koterpillar> dzdcnfzd: maybe have a ServerT with a State [Post] in the monad chain?
17:08:57 <Cale> (I've never really used Servant)
17:09:23 <Cale> Or just StateT [Post] what you already have?
17:10:21 <Welkin> the only way to do it would be wrapping in StateT, yes
17:10:29 <Welkin> otherwise some kind of IORef/MVar/TVar whatever
17:10:59 <Welkin> it's much more of a pain in the ass than just using sqlite for your example
17:12:04 <Cale> That's kind of odd... I guess it comes out of the fact that Servant is doing a bunch of type-level magic, so you can't just arbitrarily change the type of the result of these actions.
17:17:14 <dzdcnfzd> Welkin: I understand this, but the issue is of sharing state between calls to the server
17:17:55 <dzdcnfzd> if the only way to do so is to use DBs, that has massive consequences for every part of the design
17:18:04 <dzdcnfzd> (or to use MVars, etc...)
17:18:25 <Eduard_Munteanu> There's acid-state if you don't mind keeping things in memory.
17:18:26 <dzdcnfzd> I'm just screwing around at this point, so it's no big deal to experiment
17:18:57 <Cale> Eduard_Munteanu: I think the problem dzdcnfzd is tackling is just how to carry anything along
17:19:12 <dzdcnfzd> Cale: exactly
17:19:38 <Eduard_Munteanu> Oh, you can definitely use MonadReader m => ServerT m ...
17:20:50 <Cale> Is it viable to attempt to define the server recursively?
17:21:13 <Cale> I've never really thought about that.
17:21:23 <dzdcnfzd> Cale: I don't think so, actually
17:21:36 <dzdcnfzd> That's what I was trying to do
17:21:39 <dzdcnfzd> I couldn't
17:21:46 <dzdcnfzd> (I'm also very new to this library, so...)
17:23:26 <Cale> I think if you get down to the level where you're writing the Handler actions
17:23:56 <Eduard_Munteanu> https://hackage.haskell.org/package/servant-server-0.10/docs/Servant-Server.html#g:5
17:24:03 <Eduard_Munteanu> See the enter example ^^
17:24:23 <Eduard_Munteanu> Although I remember I could do it without Nat stuff at all.
17:26:09 <Cale> Weird
17:28:59 <Cale> Maybe tearing apart the implementation of serve somehow would also do it
17:43:09 <dzdcnfzd> Eduard_munteanu: In that example, do you know what "C.." means?
17:43:57 <Eduard_Munteanu> dzdcnfzd, import qualified Control.Category as C
17:44:03 <glguy> C.. is a qualified operator symbol.  C is a module name, . is the operator symbol and the middle . is like the one in Prelude.map
17:44:03 <Eduard_Munteanu> :t (C..)
17:44:04 <lambdabot> forall k (a :: k) (b :: k) (cat :: k -> k -> *) (c :: k). Category cat => cat b c -> cat a b -> cat a c
17:44:55 <dzdcnfzd> Eduard_munteanu: Thanks :) Would not have caught that
17:47:10 <Welkin> lol
17:47:14 <Welkin> that is too confusing
17:52:41 <dzdcnfzd> http://lpaste.net/4447318255664627712
17:52:53 <dzdcnfzd> I think I would have been more weirded out if that HAD worked
17:52:57 <dzdcnfzd> but it doesn't
17:53:00 <dzdcnfzd> so no worry
17:53:32 <dzdcnfzd> It seems like you shouldn't be able to do this without relying on IO 
17:53:46 <dzdcnfzd> otherwise you'd have pure functions spitting out different results
18:12:18 <Eduard_Munteanu> The problem lies with getBlog and postBlog's types.
18:17:18 <ick> I've got a dumb question but I've just spent the last hour or so on it - How does one artificially limit the values a type can inhabit in Haskell?  Specifically I'm looking to define a Sum Type that has the semantics of a type of command (e.g. readRegister | writeRegister) but carries with it a Word32 value.  The Word32 value I'm hoping to limit to a small subset of actual Data.Word.Word32's.  I guess on the 
18:17:24 <ick> whole, the goal is to acheive something like a number of C #defines (ie. #define RReg 0x0000; #define WReg 0x0001;)  and then tack on the extra constraint that only RReg and WReg are valid command types.
18:19:05 <ick> Best I've come up with is a CmdT type constructor that has 2 nullary(?) data constructors, and an auxillary function mapping those values to the Word32s
18:24:57 <ick> My other line of thinking, was to use the module system to somehow limit how one would construct a CmdT data value that ensures I can't construct a ( RReg 0x0001 ) value, or a ( RReg 0x0002 ) value.  
18:26:41 <ick> I guess I could rephrase the question as: How can I create a new type that inhabits a small subset of an already existing type?  For example just the first 4 values of Int from 0-4
18:28:37 <Rembane> ick: That sounds an awful lot like dependent types and that's kinda hard in Haskell, even though there are some workarounds.
18:28:40 <monochrom> If there are only a few legal values, do not use Word32 directly in your sum type. Define "data R = RReg | WReg". Use R in your sum type. Have a separate interpreter or converter that maps RReg to 0, WReg to 1.
18:29:25 <monochrom> If there are too many legal values, then what you said about module system.
18:34:32 <ick> monochrom: Thanks, I'll give it a go with what I have, the mapping between 0x0000-0x0004 and values of the Type, and see where I end up.  Guess theres nothing better for learning it than to keep trying it.
18:37:15 <ick> Rembane: I've heard of Dependent Types and.... my head exploded so I'm gonna try to avoid bringing those into my mental model for the moment :)
18:47:16 <joe9> any tasty users here. Do you know how to enable more verbose output? I am running it TMPDIR=/tmp/ghc stack test --file-watch --test-arguments --quickcheck-verbose
18:47:17 <joe9>  . It does not show the input and the output. It just shows failed and is repeated that data.
18:48:16 <joe9> I added trace to the test, but, the trace output is disappearing.
18:52:48 <joe9>  http://codepad.org/2cTa6JSY
19:04:19 <rotaerk> hmm, I'm planning to use 0mq for inter-process communication, but it only solves the problem of how they communicate, and not what's actually sent
19:04:52 <monochrom> Send Morse code. :)
19:04:56 <rotaerk> any recommendations for an approach to actually encode messages to be sent?
19:05:14 <rotaerk> lol
19:05:44 <rotaerk> just wondering if there's something that's particularly nice in haskell
19:06:03 <pacak> https://flagexpressions.files.wordpress.com/2010/03/semaphore-flag-codes3.jpg
19:06:16 <monochrom> I think some people use the binary package, some others use cereal.
19:06:18 <peddie> rotaerk: would the `binary` or `binary-serialise-cbor` packages work for you?
19:06:36 <rotaerk> hmm thanks; lemme check
19:06:47 <rotaerk> I see two 'binary's; looking at that first :P
19:08:27 <pacak> rotaerk: I'm using beamable (current version on hackage is outdated). It derives stuff with generics, works with arbitrary data, contains checks to ensure that data representation is the same on both sides, kind of fast and generates compact representation.
19:10:11 <rotaerk> okay, yea any of these will likely do nicely; thanks for the suggestions
20:27:13 <iqubic> I'm back.
20:27:37 <benzrf> me too thanks
20:43:54 <iqubic> Hello All.
20:44:23 <iqubic> Who's ready for me to design a game in Haskell. Or is Haskell not the right language for that?
20:47:05 <peddie> iqubic: I'm ready for you to do it
20:47:36 <iqubic> Is Haskell the right langage for game development?
20:48:08 <Sornaensis> depends on what your goals are and how familiar you are with haskell/fp 
20:48:19 <peddie> iqubic: what kind of game are you writing?  for the most part I don't see why not
20:48:22 <Sornaensis> many people have made games in haskell, including live coding VR games
20:48:46 <jle`> iqubic: the infrastructure/ecosystem  won't be as established as other language ecosystems, but haskell the language itself has a lot of advantages going for it
20:54:43 <iqubic> What advantages does Haskell have for developing games?
20:56:06 <peddie> iqubic: same advantages it has for developing other kinds of programs I imagine
20:56:58 <iqubic> Which are...?
20:57:13 <jle`> refactorability, type-safety
20:57:23 <jle`> equational reasoning, composability
20:57:25 <jle`> maintainbility
20:57:41 <jle`> verifiability
20:58:16 <jle`> scalability, etc.
20:59:10 <jle`> so if you like building games that are maintainable on the long run, then haskell is probably a good choice.  if you want to hack something together really quickly with well-established libraries then it might not be the best choice for a game
20:59:21 <jle`> not saying that type safety doesn't help you develop programs quickly, though :)
21:07:39 <Cale> Yeah, the biggest problem writing games in Haskell is that you'll often be treading new ground, rather than anything intrinsic to the language.
21:11:29 <Cale> At some point, it'll be fun to push Reflex into game engine territory. A lot of its design points came out of a lot of ideas that Ryan Trinkle and Stephen Blackheath and I developed working on an FRP system for an ARPG we were working on back in 2011 or so. (Sadly didn't get released, but we sort of proved to ourselves that it could work.)
21:12:02 <Cale> Ryan's made Reflex a way better FRP system than we had back then even
21:13:15 <joe9> check out ekmett's quine . there are some cool GL stuff there.
21:13:28 <benzrf> Cale: arpg?
21:13:47 <benzrf> joe9: thats all shader stuff, not ordinary 3d - im not sure whether its appropriate for agms
21:13:48 <benzrf> *games
21:14:21 <orion> Hi. I have functions like, "x :: Foo -> Bar -> (Info -> Info)" and "y :: Baz -> (Info -> Info)", etc. The common thread between them is that they all return (Info -> Info). What is the proper way to create a list of all these functions, given that common property?
21:14:50 <Koterpillar> orion: partially apply them
21:16:00 <iqubic> Koterpillar: How would that work??
21:16:28 <Koterpillar> :t [x somefoo somebar, y somebaz] -- [Info -> Info]
21:16:29 <lambdabot> error:
21:16:29 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚Äòt1 -> t0 -> t‚Äô
21:16:29 <lambdabot>                   with actual type ‚ÄòExpr‚Äô
21:16:39 <iqubic> Also, orion, the parentheses are not needed.
21:19:08 <Cale> benzrf: It was called Bloodknight. You ran around with a giant hammer and smashed monsters and the plan was to have a magic system that interacted with the blood on the ground. We had some melee and ranged AIs, an open world with dynamically loaded tiles. Combat was reasonably fun, but the world was still pretty empty and we still needed to build quite a lot of content, and the FRP system was still not *quite* where we wanted it at the 
21:19:08 <Cale> end of the project.
21:19:42 <Cale> benzrf: Still, the research project half of it was good, and it's easier to make money building web applications, it turns out.
21:27:07 <iqubic> What's an ARPG?
21:27:20 <iqubic> And don't most games require a mutable state?
21:27:59 <MarcelineVQ> usually action rpg which is an action game where you can improve stats or skills by defeating enemies
21:28:41 <iqubic> Ah.
21:28:56 <Cale> Also, Haskell has plenty of ways to deal with mutable state
21:29:06 <iqubic> Is there a guide to the reflex library anywhere. I want to learn about FRP.
21:29:10 <iqubic> Cale: Like what?
21:29:22 <jle`> haskell is pretty good at dealginw ith mutable state
21:29:30 <jle`> in fact i trust haskell to deal with mutable state more than i trust other languages
21:29:38 <iqubic> Cale, All I know about is IORef.
21:29:39 <jle`> haskell is where mutable state finally made sense to me
21:29:47 <iqubic> jle`: Why do you say that?
21:30:20 <MP2E> a thing that concerns me is the stop the world garbage collector, in the context of games.
21:30:21 <Cale> iqubic: IORef, MVar, boxed and unboxed mutable arrays of various kinds, STM for concurrent memory transactions...
21:30:31 <dfeuer> bitemyapp: ping
21:30:32 <MP2E> there are quite a few games where that doesn't matter but it'd be harder to make say, a AAA shooter or something similar
21:30:37 <Cale> There are weak references
21:30:46 <Cale> (Which is actually quite important)
21:31:05 <dfeuer> Weak references are a bit tricky to work with.
21:31:09 <iqubic> Cale: Haskell has Mutable arrays?
21:31:19 <dfeuer> iqubic: yes.
21:31:39 <iqubic> Can I get guides on how to use IORef, MVars, Mutable Arrays and STM?
21:31:48 <iqubic> Or should I looks those up myself
21:31:49 <Cale> iqubic: Sure, in the base package there's IOArray (mutable arrays with lazy elements) and IOUArray (unboxed mutable arrays)
21:32:00 <Cale> and then StorableArray for FFI
21:32:13 <iqubic> What's the difference between boxed and unboxed arrays?
21:32:32 <Cale> boxed arrays allow for polymorphism and lazy evaluation
21:32:43 <Cale> but they're effectively arrays of pointers to code
21:32:45 <iqubic> Cool.
21:32:47 <freeside> shouldn't we be talking about Data.Vector?
21:32:56 <Cale> and I was about to mention vector too
21:33:15 <dfeuer> Cale: that's not the base package; it's the array package. Unless you want to muck around with yucky things like GHC.Arr
21:33:25 <Cale> dfeuer: Oh, is it? Ah, right
21:33:48 <dfeuer> Does base even expose GHC.Arr? Looks internal.
21:34:32 <Cale> I figured it was base because the original Array was part of the Haskell spec, but I suppose not.
21:35:25 <Cale> iqubic: Oh, and then there's analogously STArray and STUArray, which are basically the same thing, but for the ST monad.
21:36:06 <Cale> and then there's a library called Vector which redevelops all this stuff, and gives you operations with stream fusion for the immutable arrays
21:36:33 <Cale> (and iirc, there's some funky stuff it does for mutable ones, but I'm not sure stream fusion is all that meaningful for mutable arrays)
21:36:45 <freeside> first get it right, then make it fast
21:38:36 <dfeuer> For many purposes, I think the interface vector uses is better.
21:39:19 <Cale> I mostly agree
21:39:31 <Cale> With one caveat: it doesn't use Ix for some reason
21:39:41 <dfeuer> Another option is to build on the rather spare array API offered by the primitive package. It does everything absolutely necessary and not a shred more. There may be packages that build on it to give something better; dunno.
21:39:51 <dfeuer> Cale: because Ix is *weird*.
21:40:01 <Cale> It's not that weird...
21:40:13 <dfeuer> Pretty weird that you can go to and not fro.
21:40:27 <dfeuer> I remember it getting very badly in my way once.
21:40:38 <dfeuer> But I don't remember any details.
21:41:12 <dfeuer> Doesn't that let you convert an index to an Int, but not the other way 'round? SOmething like that?
21:41:22 <kadoban> I've really grown to like the 'array' package stuff, if that's what we're talking about. It's quite flexible
21:48:02 <freeside> how do you folks keep up with the volume of CS research relevant to haskell programming?
21:48:25 <freeside> i find it a little overwhelming, all the functional pearls, and then inevitably the category theory
21:48:55 <kadoban> CT and such don't seem to be that related to practical haskell programming. At least not much more than they're related to any language, IMO.
21:49:14 <dfeuer> CT seems to inspire some library authors.
21:49:23 <freeside> with other languages, to understand and use a language feature, you read a tutorial or a chapter of an o'reilly book. with haskell, you have to read somebody's PhD thesis and then reimplement it all from scratch because the code didn't survive the latex -> dvi -> ps -> pdf process.
21:49:28 <jle`> freeside: CS research relevant to haskell program is mostly just for fun
21:49:49 <jle`> most haskell is what you describe -- a tutuorial or a chapter of an o'reilly book
21:49:53 <kadoban> freeside: I have absolutely never done anything approaching that for haskell and I get by fine
21:49:53 <MarcelineVQ> sometimes. allthough haskell phd thesis's for some reason tend to be extremely approachable
21:49:56 <jle`> i've never been required to read a phd thesis for anyhting in haskell..
21:50:22 <jle`> working with haskell practically is mostly reading blog posts and library tutorials
21:50:57 <iqubic> Anyone have a tutorial for mutable data in Haskell?
21:50:58 <freeside> maybe it's because i'm doing EDSL design and implementation in Haskell.
21:51:18 <jle`> i haven't really run into a situation where i needed to do anything remotely 'academic' to work practically in haskell
21:51:32 <jle`> and i've been using haskell for many years now, doing a lot of practical things with it
21:51:37 <jle`> as my main language for work and research
21:51:50 <jle`> disclaimer, it might be survivorship bias or something idk
21:51:57 <freeside> but don't you sometimes feel a bit anxious about the unknown unknowns?
21:52:21 <MarcelineVQ> if programming was by the numbers you'd program a program to rogram
21:52:52 <MarcelineVQ> Which actually sounds like a real fun direction to take
21:53:39 <thimoteus> until you program yourself out of a job
21:55:50 <dyreshark> that's why you have to write buggy code. then you're paid to maintain the code that replaced you
21:56:51 <dfeuer> Better: come up with new ideas later to improve what you did before.
21:56:57 <dfeuer> Or to improve *other* things in valuable ways.
21:58:34 <jle`> freeside: that's something you have to learn how to live with on your own terms
21:58:56 <dfeuer> If an employer is short-sighted and wants to get rid of the programmers as soon as "the job is done", then there's not much point trying to work for them, is there?
21:58:59 <freeside> https://emilschutte.com/stackoverflow-autocomplete/
22:38:29 <iqubic> So no one has a tutorial on mutable data???
22:39:09 <iqubic> Actually I just fouind a few by searching.
22:41:40 <jle`> the magic of google
22:43:46 <kadoban> A tutorial on mutable data is so general, not even sure what that'd encompass :-/
22:51:30 <MarcelineVQ> jle`: these dependent type posts are quite fun, makes "if it compiles it's correct" considerably less of a hyperbole, any plans for your part 3? :>
23:04:38 <jle`> MarcelineVQ: part 3 has been stalling because i haven't thought of enough things to put into it to make it worth its own part, heh
23:04:46 <jle`> but part 3 was always intended to be the conclusion :)
23:04:56 <jle`> glad you enjoyed it!
23:08:00 <MarcelineVQ> I feel I'll be referring back to it a few times for my next project, atm I'm doing the exercises at the end of part 2 and am finding the compiler help to be more pleasant than expected. also finally managed to have a use for <=< for one of these which I envision using a lot more from now on
23:09:52 <iqubic> How good is Haskell's concurrency support?
23:10:45 <Axman6> it's the best
23:10:46 <peddie> iqubic: absolutely fantastic
23:10:47 <MarcelineVQ> pretty good, it's one of ghc' selling features
23:10:50 <Axman6> (honestly)
23:11:28 <iqubic> How does concurrent Haskell work?
23:11:34 <iqubic> Anyone got a tutorial on that?
23:11:40 <MarcelineVQ> iqubic: here's the ideal resource for all of that http://chimera.labs.oreilly.com/books/1230000000929/index.html
23:12:02 <Axman6> you can fire up 100,000 threads for 100,000 connections and not have to worry too much. lots of really good tools and primitives for dealing with concurrency randing from IORefs which are excellent if you have a single shared resource, through to software transactional memory, which is world leading AFAIC
23:13:06 <iqubic> How good is this book: http://chimera.labs.oreilly.com/books/1230000000929?
23:13:21 <iqubic> The entire thing is online, for me to read and look at.
23:13:29 <Axman6> it's excellent
23:13:29 <adelbertc> iqubic: its good
23:13:38 <iqubic> Should I read through it?
23:13:47 <iqubic> I can get started on that now.
23:13:47 <adelbertc> yep
23:14:06 <adelbertc> iqubic: do you have experience with Haskell already?
23:14:13 <Axman6> it was written by Simon Marlow, who is responsible writing many of the tools which are discussed in the book, there's basically no better resource
23:14:36 <cocreature> iqubic: you might want to skip the parallel part and focus on the second chapter if you are interested in concurrency
23:14:41 <iqubic> adelbertc: Plenty of Haskell experience already.
23:14:48 <cocreature> at least I found that significantly more useful
23:14:53 <adelbertc> then yeah go for it
23:15:03 <iqubic> cocreature: I should do that.
23:15:21 <iqubic> I assume that I can read the two halves in any order.
23:15:28 <Axman6> iqubic: how much Haskell experience? I wouldn've thought that 'plenty' would include having seen how to di concurrency already :)
23:15:40 <cocreature> yep they are completely independent iirc
23:15:50 <MarcelineVQ> iqubic: best to read each half in order, but yes they can be read seperately for sure
23:16:06 <MarcelineVQ> *the contents of each half
23:16:16 <Axman6> \I believe the contents of each chapter build on earlier topics, but parallelism and concurrency are pretty orthogonal
23:16:21 <iqubic> MarcelineVQ: I will start with the concurrent half first.
23:16:28 <Axman6> at least as far as GHC is concerned
23:16:50 <cocreature> the concurrency chapter also contains the best explanation of exceptions in Haskell that I‚Äôve seen
23:16:50 <iqubic> But I will read the first chapter of the concurrent section befor the second chapter of the concurrent section.
23:16:58 <MarcelineVQ> chapter 2 is worth reading even if one doesn't care about concurrency or parallelism
23:17:07 <iqubic> I don't understand Haskell exceptions at all.
23:17:16 <cocreature> iqubic: one more reason to read that book :)
23:17:33 <iqubic> MarcelineVQ: What is the title of chapter 2?
23:18:07 <MarcelineVQ> at least, the first section of it "Lazy Evaluation and Weak Head Normal Form"  http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
23:18:28 <Axman6> iqubic: just read the whole thing, it's not very long
23:19:29 <iqubic> I know what WHNF is and what a Thunk is.
23:20:19 <iqubic> Do I still need to learn about the eval monad?
23:21:08 <MarcelineVQ> Only if you want to learn about parallelism, that first section is all I wanted to draw your attention to
23:21:57 <iqubic> What is the first section? WHNF and Thunks?
23:22:15 <Axman6> iqubic: we can't tell you what you need to know, figure that out for yourself, quit trying to take shortcuts :\
23:23:03 <Axman6> all this time asking and you could be 1/10th into the book already ;)
23:23:03 <MarcelineVQ> yeah
23:23:13 <Axman6> it;'s not a big book, just read it
23:23:19 <MarcelineVQ> yeah to your question I mean :>
23:43:09 <jgt> is there a practical difference between `i :: Int; i = 10` and `i = 10 :: Int`?
23:43:22 <jgt> (using semicolon there to denote a newline)
23:43:49 <Axman6> the latter will cause warnings from things like hlint about there being no type signature for i, but afaict that's about it
23:44:51 <cocreature> it will even cause a GHC warning with -Wall which is probably more important than an hlint warning
23:45:04 <jgt> hlint isn't warning me about it, which doesn't sound right‚Ä¶
23:45:22 <cocreature> maybe it doesn‚Äôt warn about things that GHC already warns you about?
23:45:26 <jgt> and I have `ghc-options:      -Wall -fwarn-tabs -O2` in the cabal file
23:45:34 <cocreature> jgt: is that a top-level binding?
23:45:48 <kadoban> The former is more idiomatic probably. And for more complicated I think the latter can mean different things. Like I suspect that  i = 10 :: Num a => a   might have a different meaning than expected sometimes (right?)
23:46:28 <kadoban> Or at least a different meaning than the  i ::  version would
23:46:41 <cocreature> kadoban: at least in a let binding with the monomorphism restriction enabled that should behave differently
23:46:42 <jgt> cocreature: yes, top-level binding
23:46:51 <jgt> and yes, GHC warns about it
23:46:54 <cocreature> ah ok
23:47:01 <jgt> so that's a definite answer to the question
23:47:05 <jgt> thanks folks! :)
