00:12:36 <srhb> retry: Have you tried backing up your Emacs config and making a minimal one with just Intero? 
00:12:39 <srhb> retry: 9/10 times etc.
00:13:04 <Lokathor> i wish the text package could be broken up a bit some of the time
00:13:12 <srhb> Lokathor: How so?
00:13:22 <Lokathor> srhb, it's one of the longest to build packages
00:14:42 <srhb> Lokathor: Ah, I didn't know, I use precompiled ones...
00:14:53 <Lokathor> srhb, are you one of those nix people?
00:15:08 <srhb> Lokathor: I am. :)
00:15:15 <Lokathor> ugh, you nix people :P
00:15:24 <srhb> Lokathor: Come to the future, we have binary caches. ;-)
00:15:36 <Lokathor> do they run on raspberry pi?
00:15:42 <Lokathor> will i get all my steam games too?
00:16:00 <srhb> Lokathor: Steam games, yes. Raspberry Pi, you'd probably need to set up your own Hydra, which may be quite tricky :P
00:16:26 <Lokathor> all my ~windows only~ steam games i should specify :P
00:16:45 <srhb> Lokathor: Doesn't Nix run on Windows?
00:17:00 <srhb> It probably needs some love, but I think the basics are in place.
00:17:27 <srhb> Anyway... Tangent. :-P
00:17:30 <dmj`> srhb: not well, but you can cross compile for windows
00:17:36 <Lokathor> ah, i thought it was a complete OS unto itself
00:17:36 <srhb> dmj`: Ah, ok :)
00:17:41 <srhb> Lokathor: That's NixOS
00:17:45 <srhb> Lokathor: (Built around Nix)
00:17:49 <Lokathor> ah ha
00:18:22 <dmj`> w/ NixOS you can version the kernel, the bootloader is generated out of entries from the nix store as well
00:21:07 <Lokathor> oh my gosh it finished building
00:21:42 <dmj`> text?
00:21:46 <Lokathor> yes
00:21:49 <dmj`> w/ nix?
00:21:55 <Lokathor> no just normal text
00:21:57 <srhb> Couldn't cabal new-build support binary caches as well?
00:22:09 <srhb> Doesn't it use a similarly deterministic build process to nix?
00:22:20 <srhb> Or is it just the sharing that's similar.
00:22:21 <Lokathor> we use stack around these parts, pilgrim
00:22:24 <dmj`> Lokathor: haskellPackages.ghcWithPackages (p: with p; [ text ])
00:22:33 <dmj`> nix-shell -p “ ^
00:22:33 <srhb> Lokathor: Ah, I've no idea if that could work as well.
00:22:40 <Lokathor> dmj`, i'm not using nix :P
00:22:53 <dmj`> Lokathor: it’s high time you did
00:23:04 <cocreature> srhb: even if it did, you run into problems as soon as something requires a foreign library
00:23:09 <Lokathor> just plain old debian jessie on a raspberry pi
00:23:10 <srhb> cocreature: Oh?
00:23:27 <cocreature> srhb: nix tracks everything, cabal new-build will at best track haskell libraries
00:23:35 <srhb> cocreature: Right, okay.
00:23:39 <cocreature> srhb: so if my haskell library depends on some C library you’re out of luck
00:23:40 <dmj`> cocreature: true but new-build is more incremental
00:23:57 <dmj`> I’m wondering how they will play together
00:24:08 <cocreature> dmj`: oh I’m not saying new-build is doing anything wrong. I really like it. I’m just pointing out why binary caches are not that trivial for new-build
00:24:18 <_sras_> Why does this overlapping instance happen when there is no `DbField` instance for Text http://lpaste.net/355027 ?
00:24:25 <srhb> cocreature: yeah, thanks for pointing that out. :)
00:24:35 <dmj`> cocreature: In order for nix to have incremental haskell builds, I think it would have to assemble packages w/o Cabal
00:24:48 <dmj`> cocreature: ah
00:24:52 <srhb> I think I have *most* of the goodness from Nix, aside from building statically linked binaries for use in a heterogeneous environment.
00:25:36 <dmj`> srhb: nix might soon let you swap out the lib implementation
00:25:39 <dmj`> libc*
00:25:43 <srhb> dmj`: That's interesting. :)
00:26:05 <dmj`> so using musl, since glibc has serious issues with static linking
00:26:09 <cocreature> srhb: also nix only has one version of a package in most cases which makes binary caches pretty reasonable. with cabal you’ll have to cache multiple versions of a package depending on the versions of dependencies and that would result in a gigantic cache
00:26:16 <srhb> But the basic problem is that /nix/.../whatever won't exist if I move my binary to some other server
00:26:17 <Lokathor> so folks
00:26:22 <Lokathor> i am back to the classic problem
00:26:29 <srhb> cocreature: Right.
00:26:36 <dmj`> Lokathor: right, time for nix
00:26:39 <dmj`> ;)
00:26:41 <glguy> _sras_: the left side of the => in an instance doesn't matter for picking instances
00:26:45 <srhb> cocreature: But I think people would benefit a lot from a "some of the newest ones" cached
00:26:48 <Lokathor> STM is the best for in memory concurrent modification, but your program needs to shut down eventually, so we want to store things in a database
00:26:58 <Lokathor> how do we best merge these things
00:27:06 <glguy> that just has constraints that need to be true if that instance is picked
00:27:08 <Axman6> _sras_: there _could_ be a DbField instance for Text
00:27:17 <srhb> Lokathor: You mean serializing things from some STM computation? I think it depends on "things"
00:27:22 <sophiag> does Haskell have functions like snd and fst except for sum types? like inl and inr?
00:27:35 <cocreature> srhb: I’m not so sure about that tbh. building a package once is usually not a big deal ime. building it again for every package is annoying but that’s what cabal new-build/stack already prevent
00:27:36 <Lokathor> sophiag, not in the general case
00:27:40 <clever> srhb: https://github.com/lethalman/nix-user-chroot and https://github.com/matthewbauer/nix-bundle
00:27:43 <dmj`> sophiag: Prisms I think do that
00:27:43 <srhb> cocreature: Okay.
00:27:48 <clever> srhb: this uses mount namespacing to chroot without needing root
00:27:51 <Axman6> sophiag: lens - Prism
00:28:00 <srhb> clever: What is this sorcery :o
00:28:02 <Axman6> :t _Left
00:28:04 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either a c) (f (Either b c))
00:28:14 <glguy> sophiag: inl and inr are Left and Right
00:28:21 <Axman6> > Left 1 ^? _Left
00:28:21 <clever> srhb: the same sorcery that chrome uses to sandbox its processes
00:28:23 <lambdabot>  Just 1
00:28:29 <srhb> clever: Cool!
00:28:34 <sophiag> glguy: great, thanks!
00:28:39 <Lokathor> srhb, i mean that there's some sort of state that we're controlling access and modification of with STM, but we also want to be able to make sure that all STM comitted changes become DB changes as well, so they're always matching
00:28:51 <_sras_> Axman6: DbField instance is defined be me. Not part of a library.
00:28:54 <srhb> Lokathor: Ah.
00:28:59 <clever> srhb: grsecurity was disabling non-root namespace access, but with grsecurity going subscription only, that doesnt matter now
00:29:10 <glguy> _sras_: that doesn't matter
00:29:14 <sophiag> i'm just going over some papers in OCaml and wanted to use idiomatic haskell rather than TypeOperators
00:29:15 <srhb> clever: Those are just voodoo words to me. :-)
00:29:16 <Axman6> _sras_: the point is that just because there isn't an instance fot Text now, there could be one later
00:29:51 <Lokathor> srhb, the alternative is to have the game state only be the DB, and all "game state changes" are DB actions
00:29:59 <Lokathor> and let the DB transactions handle it
00:30:03 <Axman6> _sras_: and then what happens when you call form with a ~ Text?
00:30:04 <srhb> Lokathor: But that's probably expensive, yeah.
00:30:22 <srhb> Lokathor: I mean iirc Civilization games do something like this with sqlite, but they are also painfully slow.
00:30:54 <srhb> As soon as you let go of the permanently in sync requirement, you gain a lot.
00:30:56 <Axman6> Lokathor: have you looked at something like acid-state?
00:31:19 <Axman6> gives you in memory data structures, with ACID guarantees
00:31:51 <Lokathor> srhb, in this case, the basic gameplay will be an IRC bot that you can issue commands to, and it "sets up" your turn, then once the turn runs (1/hr say, or possibly even less frequent) it does all the actions that the players did. So actually running the turns can take up to several seconds just fine
00:32:25 <srhb> Lokathor: Ah okay, then just doing everything as db actions is fine, i think.
00:32:30 <Lokathor> Axman6, in this case i'm more concerned with being able to turn the bot off and on without losing my data. Does acid-state support serialization to disk?
00:32:31 <srhb> Lokathor: Or, yes, acid-state for the awesomeness :)
00:32:36 <srhb> It does.
00:32:56 <srhb> (hence the name)
00:33:07 <Lokathor> i don't get it
00:33:13 <srhb> Well, the atomically :)
00:33:20 <Lokathor> *looks at the hackage page*
00:33:25 <Lokathor> *ACID is in caps*
00:33:33 <srhb> :-)
00:33:39 <Lokathor> "oh, ACID means something to someone somewhere I guess"
00:34:05 <srhb> atomicity, consistency, isolation, durability
00:34:29 <_sras_> Axman6: Not getting you.  "the point is that just because there isn't an instance fot Text now, there could be one later", why not complain then, when such an instance is defined?
00:34:59 <Lokathor> I think i'll consider using persistent for at least a bit. I feel like it'd be cool to show off to my friends a working example of a thing that's using a DB while also having the DB details entirely abstracted away
00:35:13 <Lokathor> one of them didn't even believe that it was possible to have a DB interface be DB-type agnostic
00:35:32 <srhb> Lokathor: It's fun for trying out, but it's way more verbose than acid-state.
00:35:36 <srhb> But yeah, try both ;-)
00:35:54 <Lokathor> does acid-state have a tutorial?
00:36:30 <srhb> Lokathor: https://ocharles.org.uk/blog/posts/2013-12-14-24-days-of-hackage-acid-state.html -- or try one of the old happstack tutorials that use it.
00:37:33 <Lokathor> >> Keep in mind that acid-state does not provide schema migrations. If you plan on changing the definition of your data-type during the lifetime if your application (you most likely do), ...
00:37:37 <Lokathor> ominious
00:37:48 <Lokathor> I will be changing the schema very, very often i think :P
00:38:12 <srhb> Lokathor: migrations really aren't that hard to write.
00:38:27 <pavonia> Given a list of infixes and a word S, how do you check if all infixes occur in S at least once such that no two of the infixes overlap each other? For example, check ["o", "oo"] "foo" would fail but check ["o", "oo"] "fooo" would be okay
00:49:05 <Lokathor> srhb, AcidState migrations are *how* easy to write through? mkMigrate "migrateAll" is pretty easy
00:49:45 <Lokathor> because this is a game i'd want to be doing incrimental development on, so i'd be regularly adding a field every time there's some new cool thing i want to add
00:50:42 <srhb> Lokathor: Basically the same, except you have to deal manually with new fields, but I assume you have to do the same for persistent really.
00:50:59 <Lokathor> if you're only adding a field, you actually don't
00:51:03 <srhb> Lokathor: (as in, if you added foo :: String to your serialized type, you will have to decide how it gets populated for existing values)
00:51:06 <srhb> Lokathor: Oh, interesting.
00:51:23 <srhb> Lokathor: How does one even handle the lack of a value then?
00:51:30 <Lokathor> it can just add a field, it will detect that the existing table lacks that field, and it just adds a column into the DB
00:51:39 <srhb> Lokathor: Which is nullable, then?
00:51:51 <Lokathor> there are special rules for non-nullable columns and default values and such
00:51:56 <srhb> Lokathor: Right, but then you're just paying the cost in the client code.
00:52:28 <srhb> You may have to anyway (explicitly making the new field Maybe NewThing) but if you don't, you can just handle it in the migration.
00:53:24 <Lokathor> true, with Persist you're limited to a subset of types, ones that fit easily into the common external DB types
00:53:35 <srhb> Yeah. :)
00:53:38 <Lokathor> AcidState lets you use any crazy haskell type, it seems
00:53:48 <srhb> Any non-function type, basically.
00:54:02 <Lokathor> dataist nonsense
00:54:06 <srhb> :-)
00:54:08 <Lokathor> pure propaganda
00:55:22 <Lokathor> well i've not used persisent deeply
00:55:28 <Lokathor> just ran through a tutorial some time
00:55:34 <Lokathor> but you might want to give it a look
00:58:33 <Lokathor> http://lpaste.net/355062 :(
00:58:44 <Lokathor> Haskell just isn't quite ready on RPi
01:02:20 <cranej> cls
01:02:30 <srhb> Lokathor: Ouch!
01:02:38 <srhb> Lokathor: And I have used persistent before, it's just a while ago.
01:03:00 <srhb> I prefer less ORM'y approaches when I need to use postgres anyway.
01:08:53 <Lokathor> i don't even know what any of that means :P
01:09:57 <srhb> Lokathor: I prefer a more raw, sql'y approach to interacting with the database :)
01:10:11 <Lokathor> but don't you want ~type safety~
01:10:20 <srhb> I do!
01:10:34 <srhb> And yes, those two are a bit at odds. :)
01:10:57 <srhb> Perhaps I should try persistent again, I just found it a bit cumbersome and lacking in expressiveness.
01:12:36 <Lokathor> ever played Neptune's Pride?
01:12:46 <srhb> Nope
01:13:02 <Lokathor> let me start by saying: never play this game.
01:13:27 <Lokathor> but anyway it's this amazing long-form real time strategy game that you can play with huge groups of people
01:13:56 <Lokathor> each game plays out managed by a server, with player inputs that actually go into effect each "tick"
01:14:19 <Lokathor> but game ticks are like 1/hour, and many neptune's pride games take days and days of time to play out
01:14:28 <Lokathor> it's the most stressful thing, really
01:14:47 <Lokathor> I want to make a game like that, with the time elements and playing out slowly, but purely co-op
01:15:28 <Lokathor> so the heavy processing comes in small bursts, most of the time the game is either totally idle or possibly parsing a player saying what they want queued up
01:16:22 <srhb> Lokathor: OK. :) 
01:16:26 <srhb> Sounds like a fun project.
01:17:04 <Lokathor> Neptune's Pride is all the fun of Risk and Monopoly, looming over your soul for days at a time :P
01:17:19 <Lokathor> this will hopefully be more fun, like Kitten's Game or Candy Box
01:21:01 <Lokathor> yep, tried a second time, aeson definitely doesn't work on RPi
01:21:06 <Lokathor> ah well
01:25:48 <Jinixt> what's the difference between StateT (ExceptT) and ExceptT (StateT)?
01:25:55 <Jinixt> (and other args of course)
01:26:54 <Lokathor> Jinixt, roughly, and as i recall it, the order of the stacking affects which can cancel the other
01:27:26 <Lokathor> so the second form is either a StateT or an error and no state changes, the first form keeps state changes up to the error point
01:27:31 <Lokathor> *i think*
01:27:49 <Athas> Lokathor: other way around.
01:28:24 * Lokathor shakes fist at his own foggy old brain
01:29:08 <Jinixt> so ExceptT (StateT) can be used for backtracking maybe?
01:29:41 <Jinixt> trying to think of it in practice
01:30:06 <Athas> Jinixt: I think you would go nuts if you tried to use backtracking where aborted branches could still have state effects.
01:30:30 <Jinixt> ah right, brainfart
01:30:53 <Jinixt> well, unless the failures are instant :)
01:31:04 <Lokathor> Athas, it'd be no worse than python!
01:31:04 <Jinixt> but yeah i see what you mean
01:33:31 <Athas> Lokathor: and look where that gets us!
01:33:45 <Athas> Jinixt: but the other way around makes sense.  Backtracking where state effects can be aborted may be useful.
01:34:56 <Jinixt> yeah
01:44:10 <Gurkenglas> Have there been proposals to write codes that only activates when some package is used, so that, say, lens, needs not drag in all the dependencies? (Is there some language where lens would not have that problem?)
01:44:33 <Gurkenglas> -write codes+allow writing code
01:48:52 <MarcelineVQ> if there's something similar to the speciic part of lens you want you could use possibly backpack to let yourself choose the provider that makes sense
01:49:54 <Lokathor> MarcelineVQ, http://hackage.haskell.org/package/pcgen :3
01:50:36 <Lokathor> Gurkenglas, if you're looking to provide optional support for a package when it's in the compilation base, you can do that, but it's clunky
01:50:55 <Lokathor> using the CPP and the MIN_VERSION macro it generates
01:52:03 <MarcelineVQ> Just needs docs and a MonadRandom instance :>
01:52:12 <Gurkenglas> Ooh. Why doesn't lens already do that?
01:53:25 <Lokathor> Gurkenglas, because it's clunky as frig :P
01:53:46 <Gurkenglas> but there'd be just up to one cpp around the entirety of each module, and one around each package dependency declaration in the .cabal
01:53:47 <Lokathor> MarcelineVQ, the generators don't get the MonadRandom instances, just the things you'd do with the generators have those
01:54:15 <Gurkenglas> What solution would be less clunky than that?
01:54:56 <Lokathor> Gurkenglas, all that MinVersion does is check what the minimum version of a package in the build is, so what you can do with that is quite limited. You're mostly able to import an additional module (or more than one) and provide an extra typeclass instance or something
01:56:43 <Lokathor> oh, i see what you're saying now
01:56:49 <MarcelineVQ> ah right, for some reason I'm always expecting monadrandom to do more than it does
01:56:54 <Lokathor> i guess lens could optionally depend on text, etc etc
01:57:03 <Gurkenglas> Huh? MinVersion on whether there's a version for unordered-containers. If so, put it into the dependencies and bring Data.HashSet.Lens into existence.
01:57:11 <Gurkenglas> Yes, that
01:57:28 <Lokathor> MinVersion can't affect the cabal file
01:57:47 <Lokathor> so i feel like the cabal file would become mysteriously confusing if you overuse that trick
01:58:10 <Gurkenglas> It's just one wrapping cpp line around each package lens serves up optionally
01:58:35 <Gurkenglas> um line pair i guess if you count however you end a block
02:01:06 <Gurkenglas> Is there some way to influence the cabal file based on the packages that are already in scope?
02:02:18 <Digit> hi following https://wiki.haskell.org/Roll_your_own_IRC_bot when i got to stage 4, upon compile it complains Equations for ‘eval’ have different numbers of arguments.  i have no idea what's causing this or how to remedy.  (haskell newbie still)
02:03:55 <Lokathor> Gurkenglas, not that I know of. The cabal file directs how the build goes, once the build is happening it's probably too late. Might be some arcane trick though.
02:04:00 <hexagoxel> Gurkenglas: not really. cabal flags affect dependencies, dependencies affect solver, and you are asking for the solver (output) to affect flags.
02:04:31 <hexagoxel> i'd need some more specialized mechanism
02:04:40 <hexagoxel> *it'd
02:05:10 <Gurkenglas> So the way to proceed here would be to patch cabal with a flag to weakly depend on a package, as in only when it's already there
02:05:42 <MarcelineVQ> Digit: include your code and error in some sort of pastebin link,  such as http://lpaste.net/
02:05:54 <Lokathor> rust supports this with "features"
02:08:03 <Gurkenglas> Hmm. Or maybe this can be hacked around. When I import a module, does its package have to be in my dependencies or only in the build plan?
02:08:41 <Digit> oh, nm.  i think i stumbled into a fix.  o_O  against what seemed to work in previous following of the tute years ago, and against what the tute seems to say.
02:09:00 <MarcelineVQ> Gurkenglas: I really think you should look at ghc backpack. what you're suggesting seems pretty brittle
02:11:02 <Gurkenglas> Actually it doesn't even sound like a hack. Just take the dependencies out of the cabal file completely, and make cpp cut out all the lens modules whose target packages are missing.
02:11:40 <Gurkenglas> I'm trying to lift the barrier to depending on lens here, wouldn't lens needing backpack make the problem even worse?
02:11:56 <MarcelineVQ> you just want to reduce lens? aren't there packages that provide each component of lens essentially if you wanted a split
02:12:06 <MarcelineVQ> like newtype and microlens etc
02:12:32 <Gurkenglas> But there are exponentially many subsets of the set of packages lens serves up lenses for
02:18:28 <Lokathor> Gurkenglas, the thing is, CPP makes testing much harder
02:18:43 <Lokathor> you have to build every possible config and test them all if you want to really cover your bases
02:18:48 <Lokathor> which is why lens doesn't do that
02:20:45 <Gurkenglas> If none of the optional modules depend on each other, is there any conceivable way that there might be problems that wouldn't be detected by testing the maximal config?
02:40:37 <Myrl-saki> @pl \x -> f (g x) x
02:40:37 <lambdabot> f =<< g
03:03:43 <jophish> ocharles: We're chatting about the differences between Rel8 and Selda in #nixos-hercules. It would be nice to hear your thoughts on this if you're willing.
03:59:24 <Myrl-saki> How to use reflex-dom to set ID?
04:23:10 <dysfun> is there a less opaque Data.Dynamic (where I can see the type) or do i have to make my own with Typeable?
04:23:21 <ephemeral> what's the typical usecase for records vs defining the same without?
04:24:26 <dysfun> wanting to access the fields by name
04:25:40 <ephemeral> yeah, but like, in the wild :P
04:26:37 <dysfun> the same answer?
04:26:41 <hexagoxel> wanting unpack/run for newtypes, i.e. the constructor's reverse.
04:27:00 <cocreature> I would say almost all of my constructors with more than 1 field are records
04:27:54 <ongy> I'd say almost all with more than 2
04:29:04 <dysfun> remember that records don't force you to type the names, so they only really impose the generation of accessors on you
04:30:00 <MarcelineVQ> record update syntax is also useful in modifying arbitrary fields of some default value while keeping the rest the default: if defaultVal is some large record with many fields you can update just one with,   defaultVal { someField = stuff }
04:30:37 <dysfun> i personally prefer lenses for that
04:30:39 <MarcelineVQ> you'll see this quite often in libraries as configurations
04:31:19 <dysfun> i saw a quite neat trick of using records to fake optional parameters
04:31:41 <hexagoxel> you don't need field names if you only ever "consume" the whole struct.
04:32:34 <hexagoxel> and perhaps when it is an information-hiding wrapper, where you internally always look on all fields anyways.
04:33:32 <hexagoxel> oh, and there is sum-types, too.. records are less common for those.
04:37:54 <ephemeral> valuable info
04:38:30 <spatial> I have a question about hmatrix
04:41:04 <srhb> spatial: Ask and you may receive and answer.
04:41:09 <srhb> an*
04:42:07 <spatial> How do I get the 'max' indexes of either all rows or all columns of a matrix ? Like np.argmax(axis-0) in Python's numpy
04:42:53 <spatial> maxIndex :: Container c e => c e -> IndexOf c in https://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra-Data.html#g:14
04:43:48 <spatial> maxIndex $ mymatrix   Should be something like this.
04:48:21 <ephemeral> hmm
04:48:26 <ephemeral> :t 1.5
04:48:28 <lambdabot> Fractional t => t
04:48:33 <ephemeral> :t 1/2
04:48:35 <lambdabot> Fractional a => a
04:48:38 <ephemeral> what
04:48:49 <ephemeral> that's not what my ghci is saying
04:48:57 <ephemeral> oh nvm
04:49:02 <ephemeral> :t Just 1.5
04:49:03 <lambdabot> Fractional a => Maybe a
04:49:06 <ephemeral> :t Just 1/2
04:49:08 <lambdabot> (Num a, Fractional (Maybe a)) => Maybe a
04:49:10 <ephemeral> what's up with that?
04:49:15 <srhb> ephemeral: Precedence
04:49:18 <dibblego> Just (1/2)
04:49:21 <ephemeral> oh
04:49:23 <ephemeral> hah
04:49:24 <srhb> ephemeral: Function application binds tighter than operator application
04:50:01 <ephemeral> so, what exactly does (Just 5)/7 mean?
04:50:06 <ephemeral> if it means anything at all
04:50:11 <srhb> ephemeral: Just what the type said. :)
04:50:23 <srhb> ephemeral: Given a Fractional instance for (Maybe a) you get a Maybe a
04:50:30 <srhb> but there isn't such an instance usually.
04:50:39 <Gurkenglas> spatial, "map maxIndex . toRows" and "map maxIndex . toColumns".
04:54:06 <ephemeral> (f . g) x is equivalent to g (f x) right?
04:54:33 <srhb> ephemeral: f (g x)
04:54:51 <ephemeral> hmm
04:55:47 <spatial> Gurgenglas : Thanks. m <- randn 4 2      map maxIndex . toRows $ m
05:01:20 <Gurkenglas> Channel convention has it to write such like "do m <- randn 4 2; map maxIndex . toRows $ m". You can rewrite that code as "map maxIndex toRows <$> randn 4 2".
05:01:33 <Gurkenglas> oops, "map maxIndex . toRows <$> randn 4 2"
05:02:51 <spatial> Use the do notation. What is the second ?
05:02:56 <Gurkenglas> oops^2 "map maxIndex . toRows $ m" is not IO so you must have written that into ghci instead of a do block
05:03:11 <spatial> That is right.
05:04:24 <Gurkenglas> so it would be "return . map maxIndex . toRows $ m" lol whatever. The second one uses (<$>), which is an alias ("synonym") for "fmap :: Functor f => (a -> b) -> f a -> f b" (IO is a Functor)
05:06:28 <spatial> maxindexes :: Matrix Double -> IO (Vector Int) maxindexes m = do   let idxs = map maxIndex . toRows $ m in     return $ fromList idxs
05:06:46 <spatial> I just have matrices and vectors now
05:06:57 <mpickering> If I have some monadic actions m (Maybe a) then I suppose I should use the MaybeT transformer to get "sequence" to do the right thing?
05:08:27 <cocreature> mpickering: yep
05:08:54 <cocreature> mpickering: at least if MaybeT does the “right thing” for you :)
05:09:11 <mpickering> Which is, if the first action evaluates to Just then don't evaluate any more of the actions
05:09:32 <Gurkenglas> asum then, not sequence
05:10:35 <Gurkenglas> :t runMaybeT . asum . fmap MaybeT
05:10:37 <lambdabot> (Functor t, Monad m, Foldable t) => t (m (Maybe a)) -> m (Maybe a)
05:11:50 <mpickering> ah right, I was using sequence because I had "fmap mconcat . sequence" which is not that I want
05:11:52 <mpickering> thanks
05:11:53 <mpickering> :t asum
05:11:55 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
05:13:07 <Gurkenglas> :t (ala MaybeT . alaf Alt) foldMap -- if you dont like the Functor constraint
05:13:09 <lambdabot> (Monad n, Foldable t) => t (n (Maybe b)) -> n (Maybe b)
05:14:48 <Gurkenglas> spatial, "maxindexes = return . fromList . map maxIndex . toRows", and there's no need for maxindexes to return IO (Vector Int) instead of the Vector Int you get if you leave out the "return ."
05:16:54 <Gurkenglas> spatial, does that even work? maxIndex returns an Int, and I don't see an Element instance for Int on https://hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra.html#t:Element
05:35:40 <spatial> Gurkenglas: I multiple an IO Vector with another IO Vector using liftM2
05:35:59 <spatial> The second Vector is the indexes Vector of Ints
05:36:37 <spatial> So I decided to return IO.
06:06:11 <mpickering> :t ala
06:06:12 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
06:40:10 <torstein> Is it possible to use a constructor from a GADT to define the type sig for another constructor in another GADT? This gives me kind errors: data Row (a :: MList CellType) where EmptyRow :: Row ('MCons 'None ('MCons 'None ('MCons 'None 'MNil))); data Game (a :: MList (MList CellType)) where EmptyGame :: Game ('MCons 'EmptyRow ('MCons 'EmptyRow ('MCons 'EmptyRow 'MNil)))
06:56:56 <geekosaur> torstein, no more than it is to use a constructor from one ADT in another ADT
06:57:18 <geekosaur> well, you can do so under the same circumstances
06:57:37 <geekosaur> (that is, type constructors yes, data constructors no)
06:57:50 <torstein> geekosaur I thought TypeInType allowed it
06:58:17 <geekosaur> TypeInType shouldn't affect *data* constructors?
06:58:22 <geekosaur> unless they are promoted
06:58:43 <geekosaur> oh, I see, it is promoted
06:58:57 <geekosaur> what ghc version? I think promotion isn't possible for some things currently
06:59:03 <geekosaur> or might require 8.2
07:00:05 <torstein> geekosaur, Yeah it's 8.0.2.
07:00:25 <torstein> So the only possible way is just to write out all the Empty cells explicitly
07:02:02 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overview which should be 8.0.1 (dunno why not 8.0.2) but I can't tell if this affects you
07:02:25 <geekosaur> also I was apparently thinking of the pre-TypeInType shortcoming
07:45:26 <pie_> what does univalence as in "Homotopy Type Theory: univalent foundations of mathematics" mean?
07:47:41 <plakband> Is it possible to have a top level definition with an instance of NFData completely evaluated at compile time?
07:56:00 <laserpants> Is there a clever way to fold a Text value with a way to "exit early"?
08:03:22 <Gurkenglas> How do I enable type applications in lambdabot?
08:08:23 <Gurkenglas> laserpants, foldlM with Either after lazily turning it into a String
08:09:28 <laserpants> Gurkenglas: ok, yes I realized that there is no point using Text when I traverse the whole thing anyway
08:09:51 <sheogorath> Can i get the compiler to complain at a constant that evaluates to a runtime error? Like 1/(5-5)
08:10:35 <exio4> > 1/(5-5)
08:10:37 <lambdabot>  Infinity
08:10:43 <exio4> sheogorath: that's not a runtime error? ;)
08:10:46 <geppettodivacin> laserpants: Alternatively, there's Text.foldr, which allows you to break out early through bouncy folds.
08:11:01 <laserpants> bouncy?
08:11:26 <geppettodivacin> I got the term from here: https://github.com/quchen/articles/blob/master/useful_techniques.md
08:11:34 <Gurkenglas> Dangit, ninja'd. You can reimplement foldlM using Text.foldr and then you dont need to turn it into a string
08:12:04 <geppettodivacin> It's really just the idea that foldr gives control flow over to your function half the time, and so that function can determine whether to keep going.
08:12:06 <sheogorath> right, div 1 (5-5) then
08:12:33 <mettekou> Is there a library out there which can compute the difference between two values of the same algebraic data type and pretty print it, much like a diff tool for text files?
08:12:36 <nrmh> sheogorath, I've never tried it, but I believe Liquid Haskell lets you do this. Donno about an easier way.
08:15:12 <nrmh> sheogorath, is there a reason you're not, say, wrapping it in a Maybe?
08:15:14 <mettekou> Never mind, this will do: http://hackage.haskell.org/package/debug-diff.
08:16:01 <sheogorath> Was looking to do fixed-point calculation where compiler can check overflow the bits.  5 bit thing * 5 bit thing is 10 bit thing, make sure it's less than 64 at compile time
08:16:11 <Welkin> What's the story with mac os sierra? does it still break haskell?
08:16:26 <Welkin> Or is it finally safe to upgrade?
08:17:37 <geekosaur> 8.0.2 should be fine
08:19:43 <nrmh> sheogorath, does the program receive any input that might affect what calculations it might do?
08:21:34 <sheogorath> don't have a program, just theorising data type. but yeah, some things are constant and should be checked but others are runtime
08:23:06 <nrmh> GADTs and the like, could give you type level information on the bits of your numbers.
08:24:09 <sheogorath> yes, moving to type level is probably the way.
08:24:57 <nrmh> But what you want to do in the case of a calculation exceeding 64 bits will probably affect what you should do.
08:25:33 <sheogorath> compile error i suppose
08:25:58 <nrmh> Well, if your program takes user input, you can't compile error based on that input.
08:26:20 <sheogorath> the number of bits are compile time but their value is run time
08:27:22 <pie_> what does deep pattern matching mean_
08:27:35 <nrmh> I'm totally lost on what your goal is. What do you need to constrain the numbers to 64 bits for?
08:29:45 <Welkin> not lazy pattern matching
08:31:15 <Welkin> https://wiki.haskell.org/Lazy_pattern_match
08:31:47 <sheogorath> fitting them in a register.
08:33:39 <nrmh> How are you encoding them as fixed point?
08:35:37 <sheogorath> a runtime word x and two compile time integers p q such that our number a is equal to x*2^p and less than 2^q or something like that
08:36:20 <montik> hi! A general fp question: Is it possible to implement fold with map?
08:36:33 <Tuplanolla> No, montik.
08:36:41 <Welkin> map is a specialized version of a fold
08:37:20 <montik> all right, thanks
08:37:20 <Welkin> the rule of `map` is that it must not modify the structure of the data
08:37:26 <Welkin> it is only allowed to modify the content
08:37:41 <Welkin> a fold can do both
08:39:49 <SlowBait> Is there a good for things other than lists?
08:39:57 <Welkin> ?
08:40:01 <SlowBait> Sorry
08:40:02 <Welkin> what do you mean?
08:40:04 <SlowBait> Fold
08:40:09 <SlowBait> A fold
08:40:17 <Welkin> I don't follow what your question is
08:41:12 <Tuplanolla> Is fold good for things other than lists? Yes.
08:41:17 <sheogorath> >:t foldr
08:41:40 <Welkin> you can fold over any data structure
08:41:46 <Welkin> as long as you define the implementation
08:42:04 <Tuplanolla> Is there a good thing for lists besides fold? Yes again.
08:42:07 <Welkin> folding over trees, graphs, sequences, arrays, maps, etc
08:42:39 <SlowBait> What would a fold for trees look like?
08:42:48 <Welkin> SlowBait: a tree traversal
08:43:29 <Welkin> whichever one you choose: in-order, pre-order, post-order, level-order
08:44:46 <SlowBait> Got it
08:45:18 <c_wraith> the easiest is pre-order, of course.  Because it always is. :)
08:49:00 <nrmh> sheogorath, why do you need runtime fixed-points that fit in your register?
08:49:28 <SlowBait> Should it always be possible to implement id with a fold?
08:49:51 <c_wraith> Depends on the exact definition of fold you're using.
08:50:10 <c_wraith> A common definition is catamorphism, in which case it's always possible to implement id
08:50:35 <c_wraith> But there are other folds.  Things like foldl aren't catamorphisms, or even close
08:50:45 <Welkin> if your fold and unfold form a catamorphism
08:51:08 <SlowBait> But it's not a requirement?
08:51:16 <c_wraith> depends on your definition of fold
08:51:32 <Welkin> I mean a hylomorphism
08:51:32 <Welkin> :P
08:51:38 <Welkin> to many morphisms
08:51:40 <c_wraith> that makes more sense.
08:51:40 <Welkin> too many*
08:52:07 <SlowBait> Heheheh
08:52:25 <SlowBait> Is there a list somewhere?
08:52:40 <Tuplanolla> Yes, but it's not a useful one, SlowBait.
08:52:46 <Welkin> https://en.wikipedia.org/wiki/Hylomorphism_(computer_science)
08:52:49 <c_wraith> SlowBait: I missed the beginning of what you're working on.  In many cases, "the fold" for a data structure means the catamorphism, which is a mechanical translation to church-encoded form.
08:52:53 <Welkin> just look at "See Also" at the bottom
08:53:04 <MitchellSalad> SlowBait: what's a list? you mean a reified catamorphism?
08:53:25 <Tuplanolla> All you really need is cata, ana and hylo, SlowBait. Anything else is just looking for trouble.
08:53:35 <Tuplanolla> Whether you like trouble is another thing.
08:53:57 <c_wraith> things like histo can give you better efficiency
08:54:17 <c_wraith> For certain use cases.
08:54:34 <SlowBait> Tuplanolla thanks
08:54:40 <SlowBait> Histo?
08:54:56 <Welkin> just look them up on wikipedia
08:54:58 <Welkin> they should all be there
08:55:25 <Welkin> lol
08:55:29 <Welkin> guess not for histomorphism
08:55:32 <c_wraith> http://www.cs.ox.ac.uk/people/nicolas.wu/publications/Histomorphisms.pdf
08:55:35 <nrmh> Wikipedia is the poorman's guide to category theory. ;)
08:55:38 <c_wraith> I don't recommend actually reading it. :)
08:55:48 <c_wraith> But if you care, the reference exists!
08:56:09 <Welkin> I found this too http://stackoverflow.com/questions/24884475/examples-of-histomorphisms-in-haskell
08:56:19 <c_wraith> that's where I got the link to the paper. :)
09:03:56 <sheogorath> nrmh: need? :) It's performance ofc. The operations like (.*.) :: P p q -> P u v -> P (p+q) (u+v)  just need a single machine multiplication, which is cool.
09:04:08 <Myrl-saki> @djinn [m a] -> m a
09:04:08 <lambdabot> Error: Undefined type []
09:04:32 <Welkin> :exref [m a] -> m a
09:04:44 <Welkin> :exfer [m a] -> m a
09:04:46 <geekosaur> it's :exf
09:04:50 <Welkin> :exf [m a] -> m a
09:04:50 <c_wraith> Welkin: you probably need to at least tell it m is a Monad
09:04:50 <Welkin> o.o
09:05:00 <Myrl-saki> Errr. Just ignore that.
09:05:03 <Welkin> :exf Monad m => [m a] -> m a
09:05:04 <Welkin> good idea
09:05:05 <Myrl-saki> Turns out that I need something better.
09:05:20 <c_wraith> :t sequence -- just in case
09:05:22 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:05:34 <Myrl-saki> c_wraith: That's m [a] though.
09:05:44 <c_wraith> oh, I see.
09:05:50 <exferenceBot> replying took too much time (60sec), aborting.
09:05:51 <c_wraith> You need a fold of some sort at the same time
09:05:52 <SlowBait> So histo is like complete induction, while cata is more like basic induction?
09:05:53 <Myrl-saki> c_wraith: But yeah. It's my fault either way.
09:05:54 <exferenceBot> could not find expression
09:06:08 <c_wraith> SlowBait: yeah
09:06:10 <Myrl-saki> c_wraith: I'm looking at the docs of the library I'm using instaed.
09:06:36 <sheogorath> nrmh: I have an Integer version im trying out which is simpler, just the current exponent x*2^p and no upper bound. But that's not as fun :)
09:08:01 <nrmh> sheogorath, why fixed-point numbers?
09:09:17 <c_wraith> fixed-point is really good for any use case where you don't want increased density around 0
09:09:30 <c_wraith> Coordinate systems is one obvious example
09:11:06 <kernelj_arch> or when you want to process stuff fast because floating point is hella slow
09:11:43 <sheogorath> well current version basically floating point with explicit exponent so that constant optimisation gets to make it fixed
09:12:01 <c_wraith> There was that amusing case with Q3:A where they ran into the resolution limits for 32-bit floats in their larger maps.  floats on ulp apart were the equivalent of a couple feet apart at the edges of some of the large maps.
09:12:14 <c_wraith> *one ulp
09:12:46 <sheogorath> if i could check overflow on the constant exponent and have a compile time error that would be cool
09:13:11 <sheogorath> also doing it because bit twiddling is fun :)
09:13:46 <nrmh> But how do you avoid runtime checking if you read numbers via IO?
09:14:51 <sheogorath> work on the maximum possible number basically. some 5 bit number times some 5 bit number is a 10 bit number
09:15:39 <kernelj_arch> unless by number you mean two's complement signed, in which case you get a 9 bit number
09:16:10 <Myrl-saki> c_wraith: Just decided to change it to `m [a]` because the docs to have nothing yet. :D
09:16:42 <c_wraith> Myrl-saki: you can always throw some sort of fold into it afterwards. :)
09:17:23 <Myrl-saki> c_wraith: Yep. :P
09:18:06 <Myrl-saki> Oh, turns out that `option` doesn't allow children.
09:18:21 <Myrl-saki> (Aside from text. This is HTML)
09:19:26 <godfrey> hi guys any good QuickCheck tutorial? no idea where to start
09:22:51 <sheogorath> kernelj_arch: really? 2 bit mul only fits in 4 bit decimal(-2*-2=4) binary(10*10=0100)
09:25:41 <kernelj_arch> that's a corner case that you would normally saturate on I guess
09:28:21 <sheogorath> I prefer my answers correct though.
09:29:27 <kernelj_arch> practically you wouldn't have -2 in a 2-bit fixed point because that isn't 1 sign bit & 1 value
09:29:52 <kernelj_arch> you'd have a symmetrical range e.g. -32767..32767
09:30:12 <sheogorath> ? "two's complement signed"
09:31:17 <kernelj_arch> the only case where you need the extra bit is -32768 * -32768
09:32:24 <kernelj_arch> it's pretty much like doing -32768 * -1 in normal two's complement arithmetic, it's an overflow condition
09:37:16 <kernelj_arch> I don't know whether to do Haskell or Java or C++ or something else... trying to prepare for job interviews
09:38:02 <Welkin> kernelj_arch: it depends on what kind of job you want to get
09:38:12 <Welkin> don't learn soething because you think it will be good for interviews
09:38:19 <Tuplanolla> Do you really need to prepare for interviews?
09:38:23 <Welkin> if there is no reason to learn C++ or java, then don't
09:38:32 <Welkin> the best language for interviews in my space is javascript
09:38:34 <kernelj_arch> I already know them -ish
09:38:39 <Welkin> because that is what I use
09:38:56 <Welkin> I used haskell in my interviews for positions where I use js and ruby though
09:38:59 <Welkin> and it worked out fine
09:39:15 <Welkin> no one there knew haskell, but they got the basic idea of what I was doing
09:39:20 <GeorgeEdward> imo it's better to learn algorithmic complexity and problem solving, doesn't matter too much about the language
09:39:20 <Tuplanolla> Your time is better spent reading about the company.
09:39:38 <Welkin> interviews are bullshit though
09:39:40 <kernelj_arch> I don't know which company is going to offer me an interview next
09:39:46 <Welkin> they vary widely from company to company
09:39:49 <GeorgeEdward> if you can whiteboard psuedocode a solution you'd be fine picking up [insert language]
09:40:27 <Welkin> kernelj_arch: I did the same thing when I got desperate while looking for work, and it ended up terribly when I tried to pick up all kinds of crap like java and c#, etc.
09:40:34 <Welkin> choose one thing and stick with it
09:40:43 <Welkin> for me that was javascript web apps and startups
09:40:57 <Welkin> it worked out much better once I chose something specific
09:40:58 <sheogorath> kernelj_arch: my point with growing the range is that there won't be overflow, but if we statically rule out the largest negative then i suppose that's fine, im not sure how that affects other operations though
09:41:59 <kernelj_arch> well I've been trying to focus on C++ and I haven't been having much luck with it for some reason
09:42:46 <Welkin> C++ jobs don't seem all that common, and the people who use it are usually extremely experienced (it seems)
09:43:01 <Welkin> it all depends on what kind of job you want
09:43:05 <Welkin> not all programming is the same
09:43:16 <kernelj_arch> nearly all my actual experience is in C/C++
09:43:27 <Welkin> right, but you are a student?
09:43:33 <Welkin> then that doesn't mean much
09:43:41 <kernelj_arch> no 4 years commercial experience
09:43:45 <Welkin> oh?
09:44:02 <Welkin> doing what though?
09:44:11 <Welkin> or a better question is, what do you *want* to do?
09:44:20 <kernelj_arch> DSP and telecoms protocol stacks
09:44:36 <GeorgeEdward> tbh if you know anything outside of the java mindset the universities are pumping out you'll be alright
09:44:37 <kernelj_arch> is what I was doing, I want to do high frequency trading or sth
09:44:50 <Welkin> I see
09:45:11 <Welkin> from what I have seen, hft uses c++ (but also ocaml at Jane street, and haskell elsewhere)
09:45:26 <Tuplanolla> They also use Visual Basic 6.
09:45:28 <monochrom> With your background, you can do radio-frequency trading and disrupt the whole industry :)
09:45:29 <Welkin> I would never write c++, because I build web apps
09:45:59 <Tuplanolla> Questionable trading is not the only disgusting part in those jobs.
09:47:29 <kernelj_arch> I haven't tried applying to Jane Street yet
09:48:13 <featherlessbiped> monochrom: that's just low frequency trading
09:48:22 <MarcelineVQ> :>
09:48:26 <monochrom> Oh oops hehe
09:49:08 <monochrom> High frequency is how many transactions per secound again?
09:49:36 <monochrom> Should I upgrade to microwave trading?
09:51:25 <featherlessbiped> sure i'll trade you my toaster for your microwave
09:51:42 <Welkin> gamma wave trading
09:51:45 <isBEKaml> monochrom: did you perhaps forget that microwave also falls under radio frequencies? 
09:52:02 <Welkin> or just use neutrinos
09:52:28 <Welkin> kernelj_arch: I'm curious why you want to do hft
09:52:41 <Welkin> it wouldn't be my cup of tea
09:53:07 <featherlessbiped> i've read that programmers are in financial industry are treated as second class to traders
09:53:08 <Welkin> I mostly build user interfaces
09:53:18 <kernelj_arch> it pays a lot because it's in finance and it means I get to do performance optimizations
09:53:19 <Welkin> and apis
09:53:24 <Welkin> lol
09:53:31 <Welkin> I somehow knew that your answer would be "it pays a lot"
09:53:45 <Welkin> that is the worst reason, but go ahead and you'll find out yourself
09:53:57 <mniip> wouldn't you be interested in better heuristics rather than performance
09:54:40 <Welkin> there is a *reason* it pays a lot :P
09:54:48 <Welkin> and it's not because they are generous
09:56:07 <mniip> wow
09:56:23 <mniip> my partially applied type families proposal
09:56:26 <pie_> monochrom, radio freq trading...lol :P
09:56:28 <mniip> has made it into rust o-O
09:56:53 <isBEKaml> mniip: you didn't make a proposal for rust too, right?
09:57:00 <Tuplanolla> Wow considering you submitted it for GHC or what, mniip?
09:57:02 <mniip> no
09:57:07 <mniip> yes
09:57:17 <sheogorath> boolean blindness
09:57:48 <mniip> well, it has made it into rust proposals somehow
09:58:14 <Welkin> mniip: it was the russian government
09:58:28 <pie_> wait, so he submitted it to haskell but it got into rust is that how im supposed to read this?
09:58:40 <mniip> https://github.com/ghc-proposals/ghc-proposals/pull/52
09:58:40 <pie_> in soviet internet, rust haskell you
10:00:20 <dmj`> his haskell is rusty
10:01:01 <isBEKaml> Well, somebody definitely wanted their rustiness haskellified
10:01:55 <isBEKaml> "Your Rustiness, would you like some Haskell in your tea?" 
10:02:27 <pie_> I love the smell of burnt Curry in the morning.
10:05:30 <Eduard_Munteanu> I would like a hask of your finest wine.
10:06:25 <mohsen_> Hi. What book do you suggest to learn Haskell>
10:06:34 <mohsen_> ?
10:06:38 <isBEKaml> !lyah
10:06:53 <Eduard_Munteanu> @where lyah
10:06:53 <lambdabot> http://www.learnyouahaskell.com/
10:06:54 <mniip> pie_, curry the mathematician?
10:06:55 <isBEKaml> uhh.. what happened to our resident bookeeper?
10:07:12 <isBEKaml> mniip: Well, Haskell "Burnt" Curry
10:07:35 <mniip> `Burnt`
10:07:38 <Eduard_Munteanu> Mr. Burns.
10:08:13 <monochrom> Haha mniip that's surreal.
10:08:22 <mohsen_> isBEKaml: I actually asked this question months ago, but I forgot the name of the book guys here suggested, but I guess they were suggesting it over lyah, I've read half of the chapters of lyah, but now my friend wants to learn Haskell, so I thought maybe its better to recommend him the book you guys suggest.
10:08:35 <monochrom> I wonder if PHP is the next :)
10:08:51 <mniip> hahaha
10:09:13 <isBEKaml> mohsen_: LYAH is good for starters. Although people here recommend haskellbook as well, if you don't mind the price
10:09:29 <hpc> lyah's main weakness is a lack of exercises
10:09:36 <hpc> which may or may not end up affecting you
10:09:40 <isBEKaml> mohsen_: http://haskellbook.com/
10:09:49 <hpc> @where learnhaskell
10:09:49 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:09:56 <hpc> ^ a decent meta-resource
10:10:00 <mohsen_> isBEKaml: Is it okay a newbie start with it? I mean haskellbook
10:10:11 <isBEKaml> mohsen_: haskellbook is bitemyapp's book with one other author
10:10:14 <nrmh> mohsen_, absolutely.
10:10:21 <Eduard_Munteanu> Pay a Haskell Programmer?
10:10:21 <monochrom> Yes haskellbook is from the ground up.
10:10:39 <isBEKaml> mohsen_: It's specifically targeted for building haskell concepts from the ground up (I mean, from first principles)
10:11:41 <mohsen_> Hmmm
10:11:55 <fragamus> is there a more idiomatic way of saying ((flip runStateT)0)
10:12:10 <monochrom> To the point that Chapter 1 has you practice substitution.
10:13:14 <monochrom> fragamus: I think that's pretty idiomatic already. But don't forget the 3rd option: infix.
10:13:38 <fragamus> oh yeah
10:13:43 <lyxia> you don't need the parentheses around flip runStateT
10:13:48 <glguy> I've been recommending Hutton's "Programming in Haskell" as a starting point
10:13:53 <fragamus> I think im going to go with ((flip runStateT)0)
10:14:09 <fragamus> Hutton book is awesome
10:14:40 <glguy> Make sure you work through the "Calculating Compilers" section toward the end, it's pretty slick
10:14:47 <mohsen_> glguy: Is the way it descibes concepts easily understandable?
10:15:12 <glguy> mohsen_: Yeah, it covers the language well and gets you there in under 300 pages
10:16:20 <mohsen_> glguy: Is it paid? Where can I find it?
10:16:52 <glguy> For example: https://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/1316626229/ref=dp_ob_title_bk
10:17:03 <glguy> Wherever you get a copy, make sure you get the second edition
10:17:09 <isBEKaml> mohsen_: IIRC, the latest edition is paid. Earlier editions are freely available on Hutton's site
10:17:13 <glguy> it was updated recently
10:17:41 <isBEKaml> Or was that Simon Thompson? I forget
10:22:47 <monochrom> @quote monochrom book
10:22:48 <lambdabot> monochrom says: rumour: SPJ will write a thick book "A New Science of Kind"
10:23:40 <isBEKaml> Sorry, I got it wrong - I somehow had it in my mind that Haskell Craft's 1st edition was freely available online from his site (Simon Thompson, not Hutton)
10:23:52 <monochrom> Actually I meant:
10:23:59 <monochrom> @quote monochrom curriculum
10:23:59 <lambdabot> monochrom says: In an imperative curriculum you're like chapter 2 for-loops and chapter 10 binary search trees.  In a functional curriculum you're like chapter 2 binary search trees and chapter 10
10:24:00 <lambdabot> XML processing using arrows.  The difference in productivity is incredible
10:24:24 <monochrom> Now I guess I have to update it to "chapter 10 writing your own compiler"
10:24:49 <Welkin> chapter 11: create a new universe
10:25:01 <isBEKaml> monochrom: heh, extremely functional productivity!
10:25:05 <Welkin> but we all know that god hacked the world together in perl
10:25:34 <isBEKaml> Welkin: I thought it was Lisp - the world is still round, not in odd shapes. Surely?
10:25:56 <Welkin> isBEKaml: https://www.xkcd.com/224/
10:26:17 <isBEKaml> I know the reference - I was playing on nail clippings
10:27:38 <monochrom> Actually I guess Richard Eisenberg wrote A New Science of Kind as his PhD thesis.
10:37:56 <Welkin> it's 1337 o'clock
10:37:57 <Welkin> :D
10:38:01 <monochrom> heh
10:39:13 <monochrom> Did you know: 31337 is a prime number.
10:39:35 <monochrom> I use it for my RSA encryption all the time. (Just kidding!)
10:43:03 <jmcarthur> 1000000000000066600000000000001 is the largest prime number I have memorized and is therefore used for all my keys
10:45:09 <Tuplanolla> My favorite prime is 27.
10:45:42 <Tuplanolla> The best part is that most people agree it's very nice.
10:46:06 <MarcelineVQ> hey if it ends in 7 it's close enough
10:46:10 <kernelj_arch> is that in octal or something?
10:47:34 <lyxia> who jokes in octal
10:50:53 <kernelj_arch> isn't -1 a prime number?
10:51:13 <iqubic> Why do programers confuse Chrismas and Halloween?
10:51:24 <iqubic> Because OCT 31 = DEC 25
10:56:55 <glguy> kernelj_arch: It's not
11:01:04 <iqubic> Are there any negative primes?
11:01:06 <ertes> 65537 is a prime number, too, and i do actually use it in my RSA keys all the time
11:01:29 <ertes> iqubic: if you generalise the notion, you could think of -1 as a prime
11:01:57 <Tuplanolla> In some contexts it's useful to think of 1 as prime, but I've never seen anyone extend it to negative numbers.
11:02:09 <glguy> But under the standard definition, prime numbers are natural numbers greater than 1 that have only themselves and 1 as divisors
11:02:44 <iqubic> I see.
11:03:04 <iqubic> How hard is it to use Haskell to calculate a prime number?
11:03:18 <ertes> iqubic: as in find prime numbers?
11:03:28 <kernelj_arch> > 1+1
11:03:30 <lambdabot>  2
11:03:38 <kernelj_arch> prime number, calculated
11:03:41 <iqubic> isPrime :: Int -> Bool
11:03:55 <ertes> iqubic: just use a library like arithmoi
11:03:56 <iqubic> That's the function I want.
11:04:08 <iqubic> ertes, those exist?
11:04:31 <ertes> iqubic: https://hackage.haskell.org/package/arithmoi-0.5.0.0/docs/Math-NumberTheory-Primes-Testing.html
11:04:40 <Tuplanolla> The answer is "pretty easy" since that's merely `Int`, iqubic.
11:05:05 <ertes> iqubic: although it doesn't *quite* have the type signature you want to, but you can apply (. toInteger)
11:05:29 <iqubic> Yeah, Integer is what I want.
11:05:35 <iqubic> Isn't it the same type?
11:06:02 <ertes> no
11:06:06 <ertes> > maxBound :: Int
11:06:08 <lambdabot>  9223372036854775807
11:06:12 <ertes> > maxBound + 1 :: Int
11:06:13 <lambdabot>  -9223372036854775808
11:07:27 <ertes> Integer is the type of integers, Int is a type of small, usually machine-sized integers
11:08:04 <ertes> Int is most likely isomorphic to Int32 or Int64 for you, depending on your architecture
11:12:49 <iqubic> ertes, I see.
11:13:00 <iqubic> Now, whats a Word?
11:13:32 <kernelj_arch> machine sized integer but unsigned
11:13:43 <pikajude> A Word is an unsigned integral type, with the same size as Int.
11:13:54 <tfc[m]> hey if i have a type "data Foo = Foo | Bar | Baz deriving (Read)", and do read "Bar" :: Foo, it works. But if i do read "bar" :: Foo (lower case), it doesn't. Is there a way for read to be case insentitive?
11:14:02 <pikajude> just like in #haskell, where negative words are discouraged, negative Words are impossible.
11:14:24 <kernelj_arch> tfc[m]: implement Read yourself?
11:14:30 <ertes> tfc[m]: not with the parsers that Read deriving generates
11:14:43 <benzrf> tfc[m]: you're not supposed to use Read for serious programs anyway, realyl
11:14:46 <tfc[m]> kernelj_arch: yes that would be the next step, although i hoped to be able to use read
11:14:51 <benzrf> i think it's supposed to be mainly a debugging thing
11:14:51 <ertes> tfc[m]: but your question suggests that Read is not what you need…  use a real parser library like megaparsec
11:14:58 <pikajude> or parsec
11:14:59 <pikajude> or attoparsec
11:15:16 <tfc[m]> ok, that's what i planned in case there is no automatic method for that
11:15:17 <tfc[m]> thanks
11:29:01 <iqubic> Are there any parser guides I can look at?
11:29:24 <sm> iqubic: megaparsec has good tutorials
11:42:01 <haskgur> hi can someone please explain myMap f = foldr ((:).f) []
11:42:18 <haskgur> i don't understand the second argument to foldr
11:42:26 <haskgur> myMap f = foldr ((:).f) []
11:43:07 <haskgur> hi can someone please explain myMap f = foldr ((:).f) []
11:44:29 <DoubleDonkey> Just so it's clear myMap f = foldr ((:).f) [] is also myMap f xs = foldr ((:).f) [] xs
11:44:44 <cocreature> haskgur: do you understand foldr in general?
11:45:13 <Tuplanolla> You might want to start with `myId = foldr (:) []`, haskgur.
11:46:51 <cocreature> inlining the definition of (.) might help if you are confused how operates on (:)
11:47:22 <Gurkenglas> inlining the definition of foldr might help
11:48:36 <pimpin8> whats this chan about
11:48:47 <cocreature> pimpin8: it’s about the haskell programming language
11:49:08 <pimpin8> whtas that
11:49:18 <cocreature> https://www.haskell.org/
11:50:03 <pimpin8> thanks mate
11:50:39 <torstein> How come that doing :t shows the type for some data types and the type constructors for others? E.g. data CellType = X | O; data State = Empty | InPlay; :t move EmptyBoard (Cell X MZ MZ) :: Board ('MCons (Cell CellType Nat Nat) 'MNil) 'InPlay
11:50:41 <Gurkenglas> Weird, why does this replace f with (:) on step 3 -> 4?
11:50:42 <Gurkenglas> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28%28%3A%29.f%29+%5B%5D+%5Ba%2Cb%2Cc%5D
11:51:35 <cocreature> Gurkenglas: huh? what’s step 3 supposed to be? and what does replacing (:) mean?
11:52:50 <Gurkenglas> That link shows me https://gyazo.com/cbd094ba61cdb2626618961b048032c5 , do you see something else?
11:53:14 <kernelj_arch> your link shows a blank page for me
11:53:40 <fragamus> i have this      pwd >>= ls >>= testdir     and I want to modify it to return m (a,b) where a is a FilePath and b is the Bool result of testDir       
11:53:40 <cocreature> oh sry, one of my filters seems to be broken and hid your message
11:53:51 <fragamus> trying to make a one-liner here
11:54:19 <simony> hm, anyone used both trifecta and megaparsec and have opinions/thoughts on picking between the two?
11:55:33 <cocreature> simony: megaparsec is significantly easier to pick up because the docs are better. trifecta has better error messages but it’s harder to figure out how to use it (not because it’s difficult but because it’s undocumented)
11:55:41 <cocreature> I haven’t compared them when it comes to performance
11:56:04 <simony> I'd guess if one is considering either one, performance may not be the main concern
11:56:11 <Gurkenglas> fragamus, will ls accept "." for the local path? Then you could do '(,) <$> pwd <*> ls "." >>= testdir'
11:56:38 <cocreature> simony: well if you need somewhat readable error messages, attoparsec is simply not an option ime
11:56:53 <cocreature> but you might still be parsing relatively large human input so performance can become a problem
11:56:58 <fragamus> Gurkenglas: wild
11:57:04 <cocreature> human generated meaning that error messages matter
11:57:38 <Gurkenglas> fragamus, oops need to bracket the (ls "." >>= testdir)
11:57:43 <simony> I did get trifecta working for a little toy project (small inputs in a chat bot), but just found megaparsec and wondering if it's worth exploring
11:58:03 <cocreature> I tend to use megaparsec for most projects these days
11:58:57 <Gurkenglas> I wonder whether there's some DSL that can be compiled to either of the parser packages, one for error messages and the other for performance
11:59:13 <cocreature> Gurkenglas: that’s the parsers package :)
11:59:57 <Gurkenglas> Parser combinator library combinators! Brilliant!
12:00:50 <simony> IIRC it's pretty easy to swap in attoparsec for the parser I wrote for trifecta
12:01:18 <cocreature> yeah, the parsers package is basically the only way to use trifecta so it’s easy to switch
12:04:03 <kamyar> Hello all!
12:04:11 <kamyar> Anyone can help me about Arrows?
12:04:20 <cocreature> kamyar: if you ask a question, me might :)
12:04:54 <kamyar> cocreature: I have got intuition about Monads, Monad Transformers, ....
12:05:09 <kamyar> cocreature: But I cant understand Arrows by now
12:05:34 <Gurkenglas> (Of course it's written by ekmett. Who else?)
12:07:31 <kamyar> cocreature: Can u help me understand and digest Arrow concept?
12:12:37 <cocreature> kamyar: https://cdsmith.wordpress.com/2011/07/30/arrow-category-applicative-part-i/ might be helpful. but tbh I never use Arrow because I never find myself in situations where it seems like the right abstraction, so I’m probably the wrong person to ask here
12:13:45 <kamyar> cocreature: I wanna use HXT which is the best xml parser in haskell world. It uses Arrows
12:20:58 <cocreature> kamyar: whether hxt is the best xml parser is at least debatable but fair enough :) although iirc hxt is one of those libraries that doesn’t really have any good reason for using Arrow and could just be using Monad, e.g, https://github.com/UweSchmidt/hxt/tree/master/hxt-monad
12:26:10 <Myrl-saki> Should I use LiquidHaskell for an API?
12:28:04 <kamyar> cocreature: Thanks anyway!
12:33:02 <kamyar> Sorry fellows! I have another question: please see my code snippet and the error: http://lpaste.net/355068
12:34:27 <kamyar> I cant guess what is the problem: MapM gets a function getting a type and returning monad (like redis.get) and a list (like lifted redis.keys output)
12:35:38 <cocreature> the type of `keys` is `keys :: (RedisCtx m f) => ByteString -> m (f [ByteString])`. so location_list is of type `f [ByteString]`. in most case f will be "Either Reply" so you’ll have to pattern match and check for the error
12:35:38 <geekosaur> but it wants a list (actually a Traversable, thus the t0) of ByteString and got a list of list of ByteString
12:36:07 <geekosaur> oh, hm, maybe
12:36:44 <kamyar> cocreature: I just wanted to omit pattern match boilerpalte using lift
12:37:10 <cocreature> kamyar: I don’t see how lift helps avoids checking for an error
12:37:52 <kamyar> cocreature: But the error text is saying sth else!
12:38:25 <cocreature> kamyar: which error text?
12:38:37 <kamyar> cocreature: At the end of my lpatse
12:39:08 <geekosaur> well, it;s saying it got some Traversable of list of ByteString
12:39:18 <cocreature> kamyar: that’s exactly what I said. mapM expects a "t ByteString" in your case where t is Traversable. but you are passing f [ByteString] so GHC sets t = f and complains that ByteString and [ByteString] are not the same
12:39:46 <kamyar> cocreature: Thanks! Got the key!
12:39:51 <kamyar> geekosaur: Thanks!
12:39:59 <geekosaur> this is one of the downsides of Traversable, so many things are Traversable that it's hard to decipher this kind of error :/
12:40:08 <monochrom> Oh w00t, hxt-monad, ertes will be happier :)
12:40:24 <cocreature> monochrom: it sadly looks like it’s sort of dead
12:40:37 <cocreature> never made it to hackage and the last signficant commit was in 2015
12:40:44 <geekosaur> (Foldable's even worse in that regard. sometimes I can see why H'98 specialized it all to lists)
12:42:04 <kamyar> Hey fellows! I am a Haskell programmer from Iran! In case it concerns to u! We are making Haskell community bigger here!
12:42:51 <torstein> I'm having some trouble writing a Show instance for a GADT: data Board l (s :: State) where DoMove :: Board l s -> Cell t x y -> Board l s ;; Getting kind errors when trying: instance Show l => Show (Board l State where ;; State already derives Show
12:43:16 <benzrf> kamyar: cool :)
12:43:26 <geekosaur> that said, a type annotation in the right place would let it know you were expecting the Traversable to be a list, and then it can tell you something more sensible
12:43:30 <cocreature> torstein: please make an lpaste with your code and the error message
12:43:33 <monochrom> "s :: State" probably does not mean what you think.
12:43:59 <cocreature> geekosaur: heh, I’ve just been wondering if I should propose adding TypeApplications to Haskell2020 for that exact reason :)
12:44:27 <torstein> monochrom, what does it mean? 
12:45:02 <geekosaur> s is a type whose kind is State
12:45:27 <cocreature> that’s to that uncommon for GADTs
12:45:27 <geekosaur> if you wanted the type s to always be State then just don't use a type variable for it
12:45:29 <ertes> hehe
12:46:28 <torstein> geekosaur, I need it to be a variable in order to use for inference in a type family
12:46:54 <monochrom> cocreature: I got my suspicion from "Show (Board l State)" and "State derives Show". In these two phrases clearly so-called "State" is a non-kind.
12:47:14 <cocreature> monochrom: good point :)
12:48:03 <torstein> monochrom: i have: data State = Empty | InPlay width DataKind
12:48:12 <torstein> with*
12:49:14 <monochrom> That doesn't change my assessment.
12:51:28 <cocreature> torstein: I really think it would help if you could paste the code or at least the relevant parts of it and the error message somewhere
12:53:30 <torstein> cocreature, monochrom: Take a look: https://pastebin.com/8RwjdXGW
12:54:19 <torstein> ignore line 21-23
12:54:45 <monochrom> You are still not distinguishing the State type and the 'State kind.
12:55:59 <monochrom> "Board l State" does not exist, period. There are only "Board l Empty", "Board l Inplay", and "Board l Finished".
12:56:38 <monochrom> This is why encoding dependent types by Haskell DataKind is morally wrong.
12:57:06 <monochrom> You encourage people to think more muddily, not more clearly.
12:57:11 <lpaste> glguy pasted “for torstein , typechecks now” at http://lpaste.net/355070
12:58:42 <torstein> monochrom, I don't know what else approach to take; functions that operate on Boards are supposed to give a compile error if the board is invalid, i.e. calling 'move' on a Finished board, calling 'whoWon' on a non-finished board etc ..
13:02:58 <monochrom> I haven't studied this particular game, but my understanding of most games is that game board status is patently a run-time-only thing.
13:04:44 <glguy> The specification for the problem is https://github.com/data61/fp-course/blob/master/projects/TicTacToe/TicTacToe.markdown
13:04:50 <glguy> (I'm assuming)
13:05:16 <torstein> Yeah that's right it's an exercise for the NICTA haskell course
13:05:25 <glguy> Whether or not it's a good idea to embed so much in the types of the game representation, that's the exercise
13:05:52 <monochrom> Oh, I guess Tic Tac Toe is one of those that have statically known end-status. (Generally any game with a pre-announced fixed length.)
13:06:58 <torstein> Yeah, but the state cannot be induced by the number of moves alone, hence it's necessary to encode the whole board in the types, at least as far as I can make out
13:07:12 <monochrom> At this rate, screw end-status. Put the whole board in types. There are only 19683 of them.
13:07:13 <iqubic> So is TicTacToe hard to make in Haskell?
13:07:22 <glguy> iqubic: Nope
13:07:35 <iqubic> Why not just use a 2-d List of chars?
13:07:55 <glguy> that'd work just fine
13:08:24 <cocreature> you probably want at least a separate type that only allows for three field states instead of using Char
13:08:40 <iqubic> Sure. That'd workd
13:09:52 <iqubic> Why are we talking about TicTacToe in Haskell?
13:10:01 <geekosaur> [29 20:04:55] <torstein> Yeah that's right it's an exercise for the NICTA haskell course
13:10:47 <iqubic> Ah.
13:11:49 <torstein> iqubic, the exercise specified that calling a function on a unsuitable board should result in a compile time error (as opposed to a runtime error or returning a Maybe)
13:14:19 <monochrom> Next April 1st, Eisenberg's postdoc paper: Dependent Haskell Chess :)
13:15:26 <Rembane> :D
13:15:29 <MarcelineVQ> monochrom: well you know, once pi types are in..
13:18:19 <MarcelineVQ> I wonder what the intended compile-time solution for the tic-tac-toe game is
13:18:31 <MarcelineVQ> what level of enforcement I mean
13:20:38 <torstein> The solution is here: https://github.com/tonymorris/fp-course/tree/master/projects/TicTacToe/haskell/src/TicTacToe
13:20:43 <torstein> Though I don't understand any of it
13:21:38 <MarcelineVQ> phew, that's a lot of kitchen sinks
13:22:21 <torstein> yeah.. Surely my attempt at a solution is better, though I'm not sure it's possible to follow through
13:23:19 <MarcelineVQ> dibblego: this feels like the kind of answer you make available to goof people that just look for the answers :>
13:30:34 <kamyar> Sorry!
13:30:49 <kamyar> I have another question!
13:31:18 <kamyar> I want to pattern match items of a list/traversable
13:32:35 <kamyar> for example: P1 x = y
13:32:38 <kamyar> then get x
13:32:54 <kamyar> now suppose I have a list of y's
13:33:08 <kamyar> and wanna get a list of x's
13:33:44 <monochrom> Haha MarcelineVQ
13:33:50 <geekosaur> Traversable'll only work with OverloadedLists extension, I think. Lists are matchable with (:) or, for fixed sizes, the [x] syntax. remember that pattern matching is on structure though, not value
13:34:03 <geekosaur> (although Num is special cased, ick)
13:36:23 <cocreature> kamyar: write a function "extract (P1 x) = x" and then map that over the list
13:36:46 <kamyar> cocreature: I just got it and I am doing! Thnx
13:43:39 <revtintin> \q
13:44:25 <ailio> hey guys, having something similar like this termbin.com/q65m can I achieve something similar like `g` of `f` or not?
13:44:46 <ailio> `g` fails but would be much nicer to write :(
13:46:33 <glguy> ailio: sum . map val
13:47:58 <ailio> yeah, this is a stupid example.. I just stripped it down to the essentials
13:49:49 <ailio> but I mean like can I transform a function `f (SomeData x)` to one that doesn't contain the constructor in the signature
13:51:02 <kernelj_arch> :t foldr
13:51:04 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:51:49 <kernelj_arch> :info Foldable
13:53:22 <kernelj_arch> ailio: you could make SomeData a Foldable and write your own foldr for it, then it will work
13:54:58 <kernelj_arch> no wait that won't work
13:55:07 <monochrom> I am not sure what you mean, ailio. For example, in your paste, which one is the ideal you desire, "g :: SomeData -> Int" or "g = foldr ((+).val) 0"? (You can only choose one.)
13:56:24 <kernelj_arch> monochrom: he wants something equivalent to f
13:57:38 <monochrom> That cannot be the complete truth. Suppose you want something equivalent to 1 bitcoin. And I give you 1 bitcoin exactly.
13:58:06 <kernelj_arch> he wants something that looks like g but works like f, I'm not sure what is hard to grasp about this
13:58:09 <ailio> kernelj_arch: thx, I think that would be handy anyway later
13:58:23 <monochrom> OK, then teach me what he means.
13:58:32 <ailio> kernelj_arch: oh, why not?
13:58:53 <kernelj_arch> it's the wrong kind
13:59:02 <monochrom> Not to mention that "looks like g but works like f" is ambiguous too.
14:00:08 <kernelj_arch> ailio: write a destructor function getData then you can have foldr ((+).val) 0 . getData
14:01:03 <kernelj_arch> ailio: or use type instead of newtype :P
14:01:34 <ailio> hm, I guess I just stick with `f` then
14:02:04 <kernelj_arch> you have to destruct the SomeData somewhere
14:04:46 <ailio> makes sense, I just thought there would be some other way. 
14:20:37 <Myrl-saki> Should I use *morphisms for actual code?
14:21:22 <Eduard_Munteanu> Probably not. I've hardly seen that in actual code.
14:22:42 <geekosaur> I'm under the impression that the only useful ones in general are already in standard libraries
14:23:36 <Myrl-saki> That.. makes sense.
14:25:36 <Gurkenglas> Why does base source say "uncurry f p = f (fst p) (snd p)", not "uncurry f (p, q) = f p q"?
14:26:35 <benzrf> Gurkenglas: i think that's lazier
14:26:44 <benzrf> like "uncurry f ~(p, q) = f p q"
14:27:11 <Gurkenglas> Oh right. That, then.
14:27:14 <benzrf> @let uncurryA f p = f (fst p) (snd p); uncurryB f (p, q) = f p q
14:27:15 <lambdabot>  Defined.
14:27:16 <geekosaur> it might also play better with some RULES pragmas
14:27:28 <benzrf> > uncurryA (\_ _ -> 3) undefined
14:27:30 <lambdabot>  3
14:27:31 <benzrf> > uncurryB (\_ _ -> 3) undefined
14:27:33 <lambdabot>  *Exception: Prelude.undefined
14:27:57 <Myrl-saki> I think I need a zygomorphism though...
14:28:32 <geekosaur> just watch out for the zygohistomorphic prepromorphisms >.>
14:28:50 <Myrl-saki> geekosaur: :D
14:29:12 <Myrl-saki>     Add a columns container
14:29:14 <Myrl-saki>     Add as many column elements as you want
14:29:16 <Myrl-saki> Each column will have an equal w
14:29:18 <Myrl-saki> Errr
14:29:20 <Myrl-saki> Dammit. Sorry.
14:29:24 <Myrl-saki> [[a] -> m a]
14:29:58 <Myrl-saki> Some crappy monad recursion magic. Is this correct?
14:32:15 <Myrl-saki> :t undefined :: [[a] -> m a]
14:32:16 <lambdabot> [[a] -> m a]
14:32:37 <geekosaur> :exf "[[a] -> m a]"
14:32:39 <exferenceBot> maybeToList Nothing
14:32:43 <geekosaur> heh
14:32:49 <Myrl-saki> lol
14:32:50 <MarcelineVQ> lazy exf!
14:32:55 <benzrf> ayy lmao
14:33:03 <Myrl-saki> The question is how I should do this...
14:33:08 <geekosaur> :exf "Monad m => [[a] -> m a]"
14:33:09 <exferenceBot> maybeToList Nothing
14:33:14 <benzrf> Myrl-saki: where does the list come from
14:33:16 <geekosaur> *eyeroll*
14:33:27 <benzrf> this doesn't seem like a plausible top-level definition type, except for something app-specific
14:33:31 <MarcelineVQ> geekosaur: what answer were you after? it's a bit of an ambigous problem
14:33:41 <Myrl-saki> benzrf: It requires MonadFix, I think.
14:33:53 <Myrl-saki> Basically, it's wiring everything to each other.
14:34:14 <geekosaur> I was just curious, I can't think of much thats generic there
14:34:20 <MarcelineVQ> ye
14:34:41 <fragamus> we need to ditch the remaining syntactic sugar and make haskell into a lisp
14:35:11 <Tuplanolla> (Yes vote.)
14:35:47 <Myrl-saki> Hmmm
14:35:52 <Myrl-saki> Maybe.
14:37:28 <iqubic> Why do we need to turn haskell into lisp?
14:38:01 <Myrl-saki> Why not?
14:38:19 <Myrl-saki> If I get this to compile, I *may* have to sacrifice my first-born.
14:38:22 <Myrl-saki> :D
14:38:53 <Matthias_> Is there someone who can clarify the Replace typeclass example in section 4 on this haskell wiki page for me: https://wiki.haskell.org/GADTs_for_dummies?
14:39:02 <Matthias_> I would have expected the first instance "instance Replace t a a t" to be "instance Replace a a b b" (i.e. more resemblant of the base case one would write in Prolog / the hypothetical example in section 2)
14:40:34 <Myrl-saki> http://ix.io/sd1
14:40:49 <Myrl-saki> Untested.
14:42:19 <Myrl-saki> That's wrong.
14:42:27 <Myrl-saki> Retrying. Lol.
14:44:35 <Myrl-saki> It...
14:44:37 <Myrl-saki> compiled.
14:44:46 <Myrl-saki> I have no idea if it works, but it compiled.
14:45:43 <Profpatsch> Is there something like V in Purscript as Haskell library? https://pursuit.purescript.org/packages/purescript-validation/3.0.0/docs/Data.Validation.Semigroup#t:V
14:49:42 <Myrl-saki> Yeah... this is stupid.
14:49:53 <fragamus> the reason why we have to turn haskell into a lisp is that template haskell sucks and lisp macros rock
14:50:33 <fragamus> macros rule templates drool
14:50:43 <c_wraith> Profpatsch: yeah..  I don't recall offhand what package it's in.
14:51:22 <iqubic> What's the difference between template haskell and a lisp macro?
14:52:08 <fragamus> when you write a lisp macro, you can depend on the fact that there is no syntax in the code that you are operating on
14:52:16 <fragamus> it is an AST
14:52:26 <MarcelineVQ> c_wraith, Profpatsch: https://hackage.haskell.org/package/validation-0.5.4/docs/Data-Validation.html#t:AccValidation
14:53:12 <iqubic> How is that better than template haskell?
14:53:46 <fragamus> so you can easily manipulate that AST, and the macro language is lisp instead of a bolted on language like template haskell
14:54:00 <Welkin> you can define arbitrary syntax with template haskell
14:54:07 <Welkin> lisp macros are still standard lisp
14:55:15 <fragamus> yes with template haskell you can get by but template haskell is a hack
14:55:24 <fragamus> bolted onto haskell
14:55:27 <Myrl-saki> Well shit. It actually compiles.
14:55:42 <iqubic> What compiles?
14:55:50 <Arizona6882> there are no good refactoring tools in haskell, that is more sad than template haskell
14:56:09 <Welkin> why do you need refactoring tools?
14:56:14 <Welkin> the compiler is your best refactoring tool
14:56:35 <Arizona6882> i mean program helping Me write and modify other programs
14:56:43 <Arizona6882> not an editor macro
14:56:44 <Jinxit> "why do we need a meat knife when we have a swiss army tool"
14:56:44 <fragamus> i don't want to start a language fracas but the reasoning is pretty well explained here: http://www.paulgraham.com/avg.html
14:56:44 <Myrl-saki> Eh.
14:57:02 <Myrl-saki> I get `sequence . fmap f` getting warned to rewrite as `traverse f`
14:57:05 <Myrl-saki> That's good enough for me.
14:57:29 <Arizona6882> Welkin: compiler can not even change name of variable, its not refactoring anything
14:57:32 <Welkin> fragamus: nothing is well explained by paul graham
14:57:40 <Welkin> he just likes to hear himself talk
14:57:43 <fragamus> well there is that
14:58:01 <Welkin> Arizona6882: find-and-replace
14:58:07 <Welkin> that is your editors job
14:58:29 <Jinxit> Welkin: how about "move this lambda to a separate function"
14:58:32 <fragamus> I just love our type system but i hate the little bits of syntax we have
14:58:37 <Tuplanolla> I put my latest project on hold, because it was too tedious to manually rename and split modules, Welkin.
14:59:00 <Tuplanolla> No amount of `awk` helped.
14:59:07 <Arizona6882> Welkin: not, you did not Understand what i said. I said help, i did not say babysit.
14:59:58 <MarcelineVQ> hmm, module split-off is reasonably oft-requested
15:00:17 <Welkin> I don't understand what the problem is
15:00:19 <sm> Arizona6882: I think some of the IDE addons can do that
15:00:33 <Welkin> there is not a magical piece of software with a button you click that reads "refactor my code"
15:00:41 <Welkin> you have to do the work yourself
15:00:54 <Jinxit> that depends on where you draw the line for "doing the work"
15:01:01 <Arizona6882> Welkin: there was haskell refactorer
15:01:15 <c_wraith> there is again.
15:01:22 <c_wraith> HaRe was resurrected and renamed.
15:01:48 <Arizona6882> c_wraith: not really, though HaRe can do stuff. c_wraith are you familiar with capabilities of original tool?
15:02:03 <Profpatsch> MarcelineVQ: Holy crap, it has a lens dependency.
15:02:06 <Profpatsch> wtf
15:02:16 <iqubic> What is HaRe?
15:02:49 <bennofs> iqubic: haskell refactoring tool
15:02:51 <MarcelineVQ> Profpatsch: hmm, that's a little silly, though I bet there's another package that does that job without that
15:05:39 <fragamus> I guess we could write a lisp that compiles to haskell as a target language
15:05:50 <iqubic> fragamus: Do we want to do that?
15:06:03 <fragamus> there are some good reasons
15:06:03 <Profpatsch> MarcelineVQ: Maybe just copy https://github.com/purescript/purescript-validation/blob/v3.0.0/src/Data/Validation/Semigroup.purs
15:06:45 <Profpatsch> It’s MIT-licensed.
15:09:32 <MarcelineVQ> Profpatsch: https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Validation.html  exists, though it also has a fair dep list due to it's other jobs
15:10:23 <Arizona6882> fragamus: "We wrote our software in wierd AI language" seriously?
15:10:59 <fragamus> I guess
15:11:04 <Arizona6882> lisp is most fundamental language of sanity, no AI at all. just good ideas.
15:11:33 <Profpatsch> edwardk: Is there a reason Validation has a Monoid constraint and not a Semigroup one?
15:11:38 <Profpatsch> MarcelineVQ: Thanks!
15:12:01 <Profpatsch> Looking for a ekmett library was my hunch as well.
15:12:03 <Profpatsch> :)
15:12:14 <edwardk> Profpatsch: adoption? =)
15:12:17 <MarcelineVQ> I think it's gabriel's
15:12:30 <MarcelineVQ> or he contributed, maybe I'm mixing up git history
15:12:41 <MarcelineVQ> Profpatsch: It has instances for semi and monoid though
15:13:29 <edwardk> Profpatsch: the Alternative needs Monoid, and Semigroup isn't yet a superclass of Monoid, so its awkward picking up (Semigroup m, Monoid m) all over in the meantime
15:13:44 <edwardk> once semigroup is a proper superclass of monoid next year or so this goes away
15:13:44 <Profpatsch> edwardk: Ah, I see.
15:13:49 <fragamus> https://gist.github.com/fragamus/984a3b9313c708b2455c0efd22bdef2d
15:13:53 <Profpatsch> I think I can live with that. :)
15:13:55 <Profpatsch> Awesome.
15:14:13 <fragamus> i need a little assistance with my gist above
15:15:59 <Profpatsch> edwardk: I get the feeling that writing stuff like EitherT is mostly just boilerplate. Is that true?
15:16:07 <Profpatsch> Or am I missing something?
15:16:24 <edwardk> ?
15:16:37 <edwardk> you mean the experience as a library author? or vs. say effect systems?
15:16:45 <Profpatsch> Yes, as a library author
15:16:52 <edwardk> you do occasionally run into tricky instances here and there
15:16:57 <edwardk> but for the most part, yeah =)
15:17:11 <edwardk> i learned a lot just from the sheer constant repetition though
15:17:19 <edwardk> helped a lot with intuitions
15:17:27 <Profpatsch> You add lots of instances to your types, so I wonder how hard it is.
15:17:51 <Profpatsch> Probably recognizing the instances and validating laws is the tricky part.
15:17:57 <edwardk> i try to ensure that all my things work with all my other things. that causes me to have to write lots of instances, because er.. haskell is bad at code reuse ;)
15:18:10 <edwardk> at least where instances are concerned
15:18:11 <Profpatsch> > bad at code reuse
15:18:14 <lambdabot>  error:
15:18:14 <lambdabot>      Variable not in scope:
15:18:14 <lambdabot>        bad
15:18:20 <Profpatsch> From a very high level, probably. :P
15:18:32 <edwardk> well, there is a rigorous way i like to talk about it
15:19:15 <Profpatsch> *using* these libraries feels like eliminating a lot of duplicate code though.
15:19:31 <edwardk> if we state that the notion of a mathematical theory is that you have sorts (types), operations as functions between those sorts, and laws about those operations, then we can make rigorous what haskell is bad at
15:19:44 <Gurkenglas> Could lens reduce its dependencies by cpp-ing the parts that provide for other packages out of scope when those packages aren't being used?
15:19:56 <edwardk> a typeclass is sort of the declaration of a theory. subclassing relationships provide refinements of theories
15:20:17 <johnw> Gurkenglas: how would you ask Hackage for "lens + this dependency I do want"?
15:20:18 <edwardk> Gurkenglas: in a lot of my packages i have -f-whatever options that can be used to turn off individual dependencies
15:20:35 <Profpatsch> It’d be npm all over again
15:20:40 <Gurkenglas> johnw, by depending on lens and that dependency
15:20:44 <johnw> ah
15:20:46 <edwardk> unfortunately they can only be used by users manually. i don't know what you are going to install later that will need those dependencies
15:21:03 <Profpatsch> Isn’t there pretty good dead code elimination done by GHC?
15:21:11 <Arizona6882> was there a proposal to make Monoid a superclass of Num? (defaulting it to addition)
15:21:26 <edwardk> Arizona6882: no refinement is being done to the num hierarchy at this time
15:21:42 <Gurkenglas> The user would have to rebuild the changed lens modules for each package that depends on it, yes
15:21:56 <edwardk> Gurkenglas: there is no way for me to detect this in lens
15:22:12 <edwardk> Gurkenglas: i can give you build flags, which i do for dozens of packages, but you have to use them manually
15:22:21 <Arizona6882> seems very good ideas to being able to call mappend on everything good, including number fields
15:23:04 <edwardk> Arizona6882: there is a fairly strong argument against it in that for Int there are a good half dozen viable monoid instances, and no clear culture that (<>) is "additive" by default.
15:23:26 <Gurkenglas> Wasn't there something about cabal generating MIN_VERSION macros that you could use to remove sections when they wouldn't compile because a dependency isn't available?
15:23:47 <edwardk> Gurkenglas: MIN_VERSION comes long after the dependency has been incurred
15:24:00 <edwardk> if you use -f-whatever, then i explicitly disable the dependency
15:24:01 <fragamus> this bug is kicking my ass https://gist.github.com/fragamus/6a54eb38952aaeefdf32a5e0636cec11
15:24:07 <edwardk> then i detect _that_ fact with MIN_VERSION
15:24:16 <Gurkenglas> I guess you know more about this stuff than me. But it sounds like a patch to cabal could make this possible?
15:24:18 <edwardk> but i can't detect that it isn't installed yet
15:24:41 <edwardk> yes you could replace the way we build packages entirely and solve this problem =P
15:24:42 <edwardk> =)
15:25:16 <edwardk> it wouldn't be a small patch and its not a small change in the set of assumptions we use
15:25:36 <Matthias_> exit
15:25:45 <edwardk> for sandbox users its pretty viable to add support to cabal for 'soft' dependencies
15:26:03 <edwardk> that require packages to be rebuilt if any of the 'soft' dependencies are later added
15:26:08 <edwardk> this might fit into the new-build culture
15:26:39 <edwardk> i take build stuff as largely gospel given and then adapt my workflow around it, so if you get that changed upstream? i'll adapt
15:26:44 <edwardk> if you don't, i'm not losing sleep ;)
15:27:08 <sm> Arizona6882: confirmed, Intellij-Haskell (eg) can do refactoring
15:27:39 <fragamus> callooh callay
15:27:49 <Arizona6882> sm: renaming?
15:28:00 <sm> yup
15:28:02 <sm> in single-package projects
15:28:16 <Arizona6882> nice, anything more advanced?
15:28:56 <sm> I see extract type parameter and a few other things in the menu
15:29:47 <Arizona6882> original refactorer had human friendly features like generalisations
15:30:21 <sm> have you investigated the recent reboot of HaRe ? Does it work ?
15:30:57 <sm> if so I'm sure it's a lot more featureful
15:31:18 <Arizona6882> i did, its basically one man project, it does work, it is a start from scratch, most of features are not yet there
15:31:57 <sm> https://github.com/haskell-tools/haskell-tools, right ?
15:32:22 <Gurkenglas> Inlining happens across package boundaries, right?
15:32:29 <sm> I think you've just described all haskell dev tools ever :)
15:33:03 <Arizona6882> sm: https://github.com/RefactoringTools/HaRe
15:34:11 <edwardk> Profpatsch: er i wa sdescribing a thing before i got distracted
15:34:15 <sm> oh interesting, two separate projects
15:34:47 <Gurkenglas> Soft dependencies could work without recompilation if you sacrifice inlining, right?
15:35:02 <edwardk> anywyas, the theory stuff, basically if we say that theories/classes are defined by operations and laws, then we can define refinements of a given theory as adding more laws or more operations (or more types)
15:35:16 <Arizona6882> sm: HaRe has good goals, of guaranteeing that program meaning does not change
15:35:48 <edwardk> in category theory terms we can look at the pushout of two refinements as a new theory as well. where we take everything implied by each refinement and add all the joint consequences of those laws
15:36:48 <edwardk> haskell deals well with theories where you add laws and operations together in lock-step, because you can't specify how your superclasses (the simpler theories you are built out of) behave due to new laws without the user having to write the instances by hand with all their members
15:37:11 <edwardk> default signatures works okay for linear class hierarchies, but it means you have to have everything defined in one ginormous source file
15:37:23 <edwardk> but it doesn't handle wide, flat "lattices" of constraints at all
15:38:07 <edwardk> the classic OOP paradigm with multiple inheritance actually gets somewhat better code reuse than the haskell typeclass model, because you can specify the behavior of your superclasses' members.
15:38:19 <edwardk> mixin traits give you something similar in other languages
15:38:28 <Myrl-saki> FRP is pretty sad. `          else return never
15:38:30 <edwardk> but if you go to do this in scala you run into a problem
15:39:19 <edwardk> you can define say, an instance of something that extends Monad[F[_]] with Comonad[F[_]] -- but often the 'theories' we're interested in are actually conditional theories.
15:39:43 <edwardk> the instance of Comonad ((,) e) is always there, but the instance of Monad ((,) e) is predicated on e being a Monoid.
15:40:53 <edwardk> and scala (and every other OOP language at present) lacks the ability to say that the object you are using as an "instance" is a subclass of Monad[(E,_)] when E is a Monoid, and a subclass of Comonad[(E,_)] all the time.
15:41:07 <edwardk> you need a form of pushout for these conditional theories
15:41:42 <edwardk> so OOP gives you better code reuse but for a crippled dialect of theories, haskell gives you worse code reuse, but a more expressive dialect of theories
15:41:47 <edwardk> if that makes any sense
15:42:59 <sm> interesting, edwardk 
15:43:08 <Gurkenglas> Perhaps a language extension that turns all identifiers into implicit parameters, so lens can define "setOf l = views l singleton" without importing Data.HashSet and then the user has to import Data.HashSet in order to use setOf
15:43:29 <Arizona6882> > compare 1 2 `mappend` compare 3 1
15:43:31 <lambdabot>  LT
15:43:42 <Arizona6882> > 1 `mappend` 2
15:43:44 <lambdabot>  error:
15:43:44 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M513011972826...
15:43:44 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
15:44:05 <edwardk> Gurkenglas: to be frank that sounds horrible
15:44:46 <Myrl-saki> @exf MonadFix m => [[a] -> m a] -> [a] -> m [a]
15:44:46 <lambdabot>  Done.
15:45:04 <MarcelineVQ> ​:exf
15:45:10 <Myrl-saki> :exf "MonadFix m => [[a] -> m a] -> [a] -> m [a]"
15:45:35 <Gurkenglas> Because it'd turn out of scope error messages into implicit parameter not provided error messages?
15:45:43 <exferenceBot> could not find expression
15:45:46 <Myrl-saki> :(
15:45:54 <Myrl-saki> @exf MonadFix m => [[a] -> m a] -> m [a]
15:45:54 <lambdabot>  Done.
15:46:00 <Myrl-saki> :exf "MonadFix m => [[a] -> m a] -> m [a]"
15:46:25 <exferenceBot> could not find expression
15:46:41 <Myrl-saki> I just realized something...
15:46:49 <Gurkenglas> Maybe it'd be "import _ as HashSet" in Data.HashSet.Lens and the user would write "import Data.HashSet.Lens using Data.HashSet"
15:47:28 <iqubic> Gurkenglas: Why do you think that would help us?
15:47:41 <MarcelineVQ> :t sequence . sequence (undefined :: [[a] -> m a])
15:47:43 <lambdabot> Monad m => [a] -> m [a]
15:47:52 <Myrl-saki> Nooo
15:48:01 <Gurkenglas> iqubic, lens could have less dependencies and more people could use lens and we wouldn't need a zoo of lens libraries
15:48:24 <Myrl-saki> :t \ms -> mfix (\xs -> traverse ($ xs) ms)
15:48:26 <lambdabot> (Traversable t, MonadFix m) => t (t b -> m b) -> m (t b)
15:48:33 <Myrl-saki> ;)
15:50:25 <Myrl-saki> @pl \ms -> mfix (\xs -> traverse ($ xs) ms)
15:50:25 <lambdabot> mfix . flip (traverse . flip id)
15:51:07 <Myrl-saki> Fuck. It still doesn't work. :(
15:51:31 <Myrl-saki> Hmmm
15:51:46 <Myrl-saki> :t mfix . flip (traverse . (&))
15:51:47 <lambdabot> (Traversable t, MonadFix m) => t (t b -> m b) -> m (t b)
15:52:20 <Myrl-saki> Meh. Too complicated. I don't want to read that after not working on the project for a week.
16:00:57 <andrei> What libraries are there to match arbitrary Haskell structures with patterns aside from t-regex? I have a datastructure and want to match several rules against it.
16:02:32 <erisco> Myrl-saki, hm, that is a rough one
16:02:37 <erisco> how about mfix . (id ~> (&) ~> id) (flip traverse)
16:04:22 <erisco> also  for = flip traverse
16:08:13 <Myrl-saki> erisco: Isn't for = flip map?
16:08:52 <Myrl-saki> But you're onto something though.
16:09:18 <Myrl-saki> :t mfix . flip (traverse . (&))
16:09:19 <lambdabot> (Traversable t, MonadFix m) => t (t b -> m b) -> m (t b)
16:09:29 <erisco> I don't know what "map" you're talking about
16:09:35 <Myrl-saki> erisco: flip map.
16:09:38 <Myrl-saki> Err
16:09:38 <MarcelineVQ> forM = flip mapM = flip traverse = for
16:09:39 <erisco> :t flip map
16:09:40 <Myrl-saki> flip fmap
16:09:41 <lambdabot> [a] -> (a -> b) -> [b]
16:10:01 <Myrl-saki> :t for
16:10:02 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
16:10:07 <Myrl-saki> Oh what.
16:10:09 <Myrl-saki> :t fmap
16:10:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:10:26 <Myrl-saki> :t mfix . for . (&)
16:10:28 <lambdabot> error:
16:10:28 <lambdabot>     • Occurs check: cannot construct the infinite type: b ~ m b
16:10:28 <lambdabot>       Expected type: a1 -> (a -> m b) -> m (a -> m b)
16:10:54 <erisco> you have to apply (&) to the second argument, which is why I am using ~>
16:10:59 <Myrl-saki> erisco: Ahh
16:11:08 <erisco> you can also use <*>
16:11:17 <erisco> :t mfix . for <*> (&)
16:11:18 <lambdabot> error:
16:11:18 <lambdabot>     • Occurs check: cannot construct the infinite type:
16:11:18 <lambdabot>         b1 ~ (((a -> a) -> b) -> b) -> b1
16:11:20 <Myrl-saki> :t mfix . (id ~> (&) ~> id) for
16:11:21 <lambdabot> error:
16:11:21 <lambdabot>     • Variable not in scope:
16:11:21 <lambdabot>         (~>) :: (a3 -> a3) -> (a2 -> (a2 -> b1) -> b1) -> t0
16:11:28 <erisco> oh, that's slightly wrong
16:11:44 <erisco> well it can still be done but we have to lift
16:12:03 <Myrl-saki> erisco: Where is ~> defined?
16:12:06 <Myrl-saki> Lens?
16:12:19 <erisco> typecompose
16:13:49 <Myrl-saki> :t mfix . for <*> (&)
16:13:51 <lambdabot> error:
16:13:51 <lambdabot>     • Occurs check: cannot construct the infinite type:
16:13:51 <lambdabot>         b1 ~ (((a -> a) -> b) -> b) -> b1
16:14:09 <Myrl-saki> Welp. I'll do this on my computer. BRB.
16:16:09 <erisco> so we can also do   mfix . (liftA2 for <$> pure <*> pure (&))
16:16:35 <Myrl-saki> :t mfix . (for =<< (&))
16:16:37 <lambdabot> Traversable ((->) ((a1 -> a -> a) -> a1)) => (a1 -> a -> a) -> ((a1 -> a -> a) -> a1) -> a
16:16:47 <Myrl-saki> That doesn't seem like it lol
16:17:27 <erisco> :t mfix . (liftA2 for <$> pure <*> pure (&))
16:17:29 <lambdabot> (Traversable t, MonadFix m) => t (t b -> m b) -> m (t b)
16:17:59 <Myrl-saki> :t liftA2
16:18:00 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:18:34 <Myrl-saki> I have no idea lol
16:18:46 <erisco> it is actually straight-forward
16:19:39 <Myrl-saki> Oh okay. Now I have a better idea.
16:20:04 <erisco> I have to keep finding it but here is the explanation http://stackoverflow.com/a/34536499/260584
16:20:05 <Myrl-saki> By "better idea" I mean that I'm getting things. Not that I found something. Whoops.
16:21:02 <Myrl-saki> Wouldn't it be better to use a cofunctor instance?
16:21:13 <Myrl-saki> Oh wait no. That still doesn't handle swapping.
16:22:37 <erisco> to go all the way you have  mfix <$> (liftA2 for <$> pure <*> pure (&))
16:22:47 <erisco> then maybe you can find reductions just using Applicative laws from here
16:22:53 <Myrl-saki> :t \a b -> f a (g b)
16:22:54 <lambdabot> error:
16:22:55 <lambdabot>     • Could not deduce (Show t0) arising from a use of ‘f’
16:22:55 <lambdabot>       from the context: (FromExpr t, Show t1, Show t2)
16:23:06 <Myrl-saki> @pl \a b -> f a (g b)
16:23:06 <lambdabot> (. g) . f
16:24:32 <Myrl-saki> erisco: Would you actually do something like this in actual code? ._."
16:24:50 <erisco> I did once
16:25:02 <Myrl-saki> :t delete
16:25:04 <lambdabot> Eq a => a -> [a] -> [a]
16:25:12 <erisco> but it would be better if we can find some reductions
16:27:09 <Myrl-saki> erisco: I think the one using TypeCompose would be the best.
16:28:24 <Myrl-saki> erisco: `(~>) id (&) for`, I think.
16:28:31 <Myrl-saki> Oh wait no.
16:28:54 <Myrl-saki> Maybe (. (&)), but I think I need more sleep to handle such type juggling.
16:29:09 <Myrl-saki> (And of course, that looks ugly. I have to read more aobut TypeCompose. Seems good.)
16:29:17 <erisco> there is a particular idiom for ~> and I illustrated it above
16:29:34 <erisco> it is from Conal's Semantic Editor Combinators
16:29:36 <Myrl-saki> erisco: Yeah. I don't quite understand it though.
16:30:10 <Myrl-saki> I'm guessing it means "keep 1st, modify second, don't post-processO?
16:30:26 <erisco> then I did something similar with the Applicative equations I linked
16:30:48 <erisco> with the hopes that some Applicative equivalances would become obvious
16:31:00 <erisco> or maybe if when the functions specialised something would be obvious there
16:31:15 <Myrl-saki> a ~> b ~> c == (\x y -> c (a x) (b y)) ?
16:31:50 <Myrl-saki> Oh wait.
16:31:57 <erisco> (f ~> g) h  is  \x -> g (h (f x))
16:32:04 <Myrl-saki> (a ~> b ~> c) == (\x y -> c $ f (a x) (b y)) ?
16:32:31 <erisco> so f maps the argument and g maps the return
16:32:40 <erisco> ~> is right-associative
16:32:42 <Myrl-saki> Mhm.
16:32:53 <Myrl-saki> Ahhh
16:35:16 <erisco> then there is another absurd method...
16:36:42 <erisco> actually I don't think that one will work well... is more impressive if all the binders are on the outside
16:38:15 <daveisdave_> Hello?
16:38:44 <daveisdave_> does anyone know anything about jquery?
16:39:51 <daveisdave_> I got the strangest spam email today, and I'm following it down the rabbit hole. But I'm pretty much computer illiterate, and need a little help. 
16:41:12 <daveisdave_> anyone?
16:41:36 <dibblego> daveisdave_: this channel is for haskell
16:42:20 <daveisdave_> ok. you know where I could go for some help? I just wanted to know what a jquery script does
16:43:28 <geekosaur> presumably #jquery
16:43:41 <geekosaur> (some 400 users even)
16:44:29 <daveisdave_> ok thanks
16:44:33 <daveisdave_> have a good one
16:46:03 <erisco> Myrl-saki, well for the sake of it anyways, it is  mfix . lurryA @N2 (for <$> _1 <*> ((&) <$> _2))
16:46:38 <Welkin> :t lurryA
16:46:40 <lambdabot> error:
16:46:40 <lambdabot>     • Variable not in scope: lurryA
16:46:40 <lambdabot>     • Perhaps you meant ‘curry’ (imported from Data.Tuple)
16:46:41 <erisco> would be nice to get mfix on the inside but I'd have to think about how to deal with the binders on the inside
16:46:47 <Welkin> wtf is `lurryA`?
16:46:57 <erisco> you need to get it from my silly data-function-tacit package
16:47:41 <Welkin> how is it possible that random people arrive in this channel who don't even know what haskell is, and asked totally unrelated questions?
16:47:48 <Welkin> ask*
16:48:18 <Welkin> what do they think it is? And are they mistyping something else? If so, what?
16:48:40 <glguy> You can list channels by population and just join popular channels
16:49:10 <Welkin> oh shit...
16:49:18 <erisco> after some linux channels and python, haskell has the most users... probably not the reason
16:49:18 <Welkin> why is nix broken on sierra???
16:49:42 <Welkin> has anyone else run into this `Illegal instruction: 4` issue with nix after upgrading to mac os 10.12?
16:50:30 <MarcelineVQ> is that irony Welkin? :>
16:50:37 <Welkin> irony?
16:50:40 <erisco> that's actually a reasonable problem I didn't think about... hrm
16:50:48 <Welkin> I was told that ghc 8.0.2 worked on sierra, so I took the chance
16:50:51 <Welkin> I thought nix would work too
16:51:02 <Welkin> I had 8.0.1 at the time running on yosemite
16:52:00 <Eduard_Munteanu> Also Maybe folks living in Haskell
16:52:04 <Eduard_Munteanu> *maybe
16:52:21 <fragamus> hey im having serious trouble i need help
16:52:35 <Welkin> MarcelineVQ: no, because it is haskell related
16:52:51 <geekosaur> the "4" is just repeating the "illegal instruction" (SIGILL = 4). but I would expect to have to reinstall stuff like nix and other package managers (homebrew, macports) after upgrading OS
16:53:07 <fragamus> i am trying to traverse a directory tree and keep a counter during the traversal but it doesnt work
16:55:17 <erisco> fragamus, we're going to need more information. can you lpaste your code?
16:56:09 <fragamus> https://gist.github.com/fragamus/6a54eb38952aaeefdf32a5e0636cec11
16:56:25 <Myrl-saki> int getRandom () { return 4; } -- determined by a fair dice roll
16:56:27 <Myrl-saki> ;)
16:56:54 <erisco> then also please tell us what the program does and what you want it to do instead
16:57:56 <Eduard_Munteanu> fragamus, I bet you're not skipping '.' and '..'
16:58:27 <Eduard_Munteanu> (hence infinite loop)
16:58:43 <Myrl-saki> `** Message: console message: http://localhost:8080/static/all.js @7186: uncaught exception in Haskell main thread: TypeError: undefined is not an object (evaluating 'a.f')
16:59:02 <fragamus> im not having that problem seemingly
16:59:32 <fragamus> but my state is not working as expected
17:01:20 <monochrom> fragamus: I am too lazy to install Stack. Could you post a sample output?
17:03:11 <erisco> I think fragamus is still working on it and just wants us for the moral support
17:03:52 <monochrom> Ah then there is a perfect despair.com poster for this... :)
17:05:38 <monochrom> https://despair.com/collections/posters/products/aspiration
17:06:53 <glguy> aspiration: the action or process of drawing breath.
17:08:48 <monochrom> The motivational speech has been cancelled because the speaker was hopitalized for an aspiratory infection. :)
17:09:25 <Eduard_Munteanu> Hehe.
17:10:36 * hodapp smacks monochrom
17:12:31 <fragamus> ok I added that sample
17:12:33 <fragamus> https://gist.github.com/fragamus/6a54eb38952aaeefdf32a5e0636cec11
17:12:55 <fragamus> in a comment to the gist
17:12:56 * Welkin hands hodapp his app
17:12:58 <Welkin> hold this for me
17:14:06 <monochrom> Ah then what Eduard_Munteanu said. You keep recursion on . so you never run the else-branch so you never increase the number state.
17:14:17 <monochrom> s/recursion/recursing/
17:14:32 <Welkin> is anyone using nix on mac os sierra? o.o
17:14:38 <Welkin> I can't get it working
17:14:39 <hodapp> Welkin: that level of pun density is inappropriate, sir.
17:14:50 <monochrom> No that's not right.
17:16:09 <monochrom> What is the type of ls?
17:18:06 <monochrom> What does view do and what is its type?
17:18:25 <geekosaur> they're both from the Turtle package
17:18:42 <iqubic> What is the Turtle package?
17:18:57 <c_wraith> turtle is a package for writing shell scripts in haskell
17:19:20 <iqubic> Oh. I thought it was a Graphics package.
17:19:45 <c_wraith> it was a pun on "shell".  Graphics would also have made sense, for a different reason.
17:20:34 <monochrom> I'm sure someone will make a graphics library and call it "Shell" because it puns on "turtle". And that will complete the confusion. :)
17:20:57 <fragamus> i simplified it: https://gist.github.com/fragamus/6a54eb38952aaeefdf32a5e0636cec11
17:21:06 <fragamus> same as before though
17:21:51 <iqubic> monochrom: You may or may not be familiar with turtle graphics, but basically you use sequential commands to tell the code where to draw.
17:21:52 <geekosaur> and justify the pun because portableGraphicsIsHell
17:22:35 <Eduard_Munteanu> fragamus, that no longer recurses
17:22:44 <monochrom> I am actually not sure who is printing the "((),1)" at all.
17:23:02 <fragamus> yeah but the lstree does the recursion to traverse the tree
17:23:53 <monochrom> Does lstree call filePathProducer? Does ls call filePathProducer?
17:24:36 <monochrom> Also, the "extra" information "ls recurses" still doesn't explain who is printing the "((),1)" at all.
17:24:40 <Eduard_Munteanu> As far as I can tell, it should call modify just once.
17:25:10 <c_wraith> I think it's a nondeterministic monad
17:27:52 <monochrom> I have a hunch that in general "StateT X (your nondeterministic monad here)" the behaviour is to fork the initial state over the multiple branches.
17:27:53 <fragamus> yes c_wraith
17:28:08 <fragamus> oh man that sucks
17:28:15 <fragamus> anything i can do about it
17:28:30 <monochrom> Use an IORef.
17:28:39 <fragamus> looking that up
17:29:29 <monochrom> This is why StateT is fake state. The illusion is burst under forkIO and [].
17:30:05 <fragamus> the IORef thing looks very naughty
17:30:17 <iqubic> Why is StateT bad?
17:30:44 <monochrom> Because you misread.
17:31:19 <monochrom> But I guess Elizer would misread too.
17:31:45 <c_wraith> :t join (,) . (+1)
17:31:47 <lambdabot> Num b => b -> (b, b)
17:34:19 <fragamus> so non-fake state really requires IO it seems
17:35:18 <monochrom> Or maybe Turtle already has a similar service so you don't have to touch IO directly.
17:35:52 <monochrom> I am still too lazy to read Turtle doc.
17:36:04 <monochrom> despair.com is so much more fun...
17:36:13 <iqubic> > let x = join (,) . (+1) in x 5
17:36:15 <lambdabot>  (6,6)
17:36:21 <iqubic> I see how that works
17:36:25 <iqubic> :t join
17:36:26 <mtn> Hi! Any chance I could get some guidance figuring out why my ghci is broken?
17:36:27 <lambdabot> Monad m => m (m a) -> m a
17:36:44 <iqubic> mtn: What seems to be the issue?
17:37:00 <monochrom> Chance is proportional to information divulged.
17:37:11 <mtn> So I installed it through stack based on the instructions provided at https://github.com/bitemyapp/learnhaskell
17:37:25 <iqubic> Sure.
17:37:31 <iqubic> What is wrong with that?
17:38:00 <mtn> When I run `stack ghci file.hs` for example, I see "Warning: Couldn't find a component for file target path/to/file. Attempting to load anyway."
17:38:09 <mtn> And the file fails to load
17:38:28 <mtn> I found the source on github but couldn't decipher it
17:38:44 <iqubic> mtn: I get the same error.
17:38:54 <iqubic> Though I wouldn't call that broken.
17:39:11 <mtn> iqubic: What do you mean by that? :P
17:39:15 <iqubic> What directory are you in when you start the repl?
17:39:29 <mtn> I'm in the directory contiaining the file I want to run
17:39:36 <mtn> or load, rather
17:39:45 <iqubic> Oh, well then I have no idea what's wrong
17:40:15 <MarcelineVQ> it still loads the file yeah?
17:40:25 <MarcelineVQ> oh you said it does fail after all
17:40:26 <mtn> Nope, it doesn't
17:41:03 <iqubic> What do you mean it doesn't?
17:41:05 <fragamus> Turtle seems to be lacking any state
17:41:06 <c_wraith> mtn: what does it do if you just use ghci instead of stack ghci?
17:41:07 <mtn> Though it doesn't display any other error message or anything
17:41:30 <mtn> c_wraith: I don't have any other ghci. I currently have ghci as an alias for stack ghci
17:41:48 <iqubic> I think that's an issue then.
17:41:50 <c_wraith> mtn: stack doesn't have its own ghci.  It's definitely installed on your system
17:41:50 <mtn> c_wraith: And if I remove the alias, it results in "command not found", so it's not conflicting
17:42:02 <c_wraith> mtn: though apparently not in your path
17:42:07 <iqubic> mtn, that's your issue.
17:42:08 <MarcelineVQ> use   stack exec ghci -- foo.hs  to load a file like normal ghci
17:42:09 <iqubic> I think.
17:42:13 <mtn> Oh, that makes sense
17:42:40 <MarcelineVQ> stack ghci  works in a project sense and you're not in a project, I suspect
17:43:03 <mtn> Yea, that's right. If I run which stack ghci, something comes up, but nothing if I run which ghci
17:43:05 <iqubic> Do you have a stack project created already?
17:43:30 <mtn> iqubic: Nope, I was just testing it on individual files
17:43:43 <iqubic> mtn, that's your issue.
17:43:45 <MarcelineVQ> that should probably be   stack exec -- which ghci
17:43:46 <fragamus> monochrom that is startling about stateT being fake state. Perhaps there's some fundamental principle that forces state to be in IO
17:44:18 <iqubic> If you want to run "stack ghci" then you need a stack project.
17:44:21 <mtn> MarcelineVQ: Oh I see, I think that's the location of my ghci
17:44:32 <mtn> Should I be adding that to my path?
17:44:35 <MarcelineVQ> no
17:44:40 <mtn> Sorry, pretty clueless
17:45:07 <iqubic> You should update your path so that you can run regular ghci, without the alias.
17:45:24 <iqubic> What is the output of "which ghci"?
17:45:39 <monochrom> fragamus: To be fair, IO is too big, but what you're looking at is something like "you can't just combine a quiet engine with a high-power engine to get a quiet high-power engine"
17:45:58 <mtn> iqubic: None
17:46:00 <monochrom> (Tony Hoare's analogy!)
17:46:27 <MarcelineVQ> mtn: https://docs.haskellstack.org/en/stable/GUIDE/#ghci-the-repl
17:46:57 <Eduard_Munteanu> Nice.
17:46:58 <geekosaur> fragamus, the question here is not really state. it's _shared_ state
17:47:26 <fragamus> well i just hadn't thought about this enough
17:47:29 <monochrom> Yeah, you can't just combine a state monad and a nondet monad to get...
17:47:31 <geekosaur> if the monad is doing something that causes the state to be shared, then the private state model of State will not work
17:47:39 <MarcelineVQ> though that won't say anything that wasn't just said, it's a link to docs where you can learn more about stack in general. short story if you don't have a system level ghc and you installed your ghc with stack you use stack commands to interact with it
17:47:42 <geekosaur> you need a shared state model, which is what STRef and IORef provide
17:47:48 <fragamus> my monad is quiet though
17:47:54 <monochrom> :)
17:48:01 <Eduard_Munteanu> You could probably make it work if you had the nondet monad as a transformer *over* StateT.
17:48:24 <fragamus> I think Turtle wants to be at the bottom
17:48:33 <monochrom> You need state to be deeply integrated as part of the nondet mechanism. They have inseparable interactions.
17:48:35 <geekosaur> Turtle is a fancy IO monad, so yes
17:49:03 <MarcelineVQ> the only path you should add manually is  ~/.local/bin  because stack will place certain executables you install via stack there
17:50:00 <geekosaur> monochrom, actually I'd say that combination worked perfectly: fragamus got a non-deterministic state monad. But that's rarely what one wants...
17:50:25 <fragamus> and its quiet
17:50:38 <monochrom> Yeah, in "you need state to be..." I mean the common expectation of state.
17:51:46 <mtn> iqubic: MarcelineVQ: Thanks for the help guys! 
17:53:41 <iqubic> mtn: Have you solved your issues?
17:54:01 <monochrom> Tangential: I know how to add incremental parsing and yield to parsec, but it has to be ParsecT Cont rather than ContT Parsec.
17:54:04 <fragamus> these IORefs are like the apple in the garden of eden
17:54:14 <fragamus> I never tried one before
17:54:52 <monochrom> If Steve Jobs found out where Eden is, would he open an Apple Store there? :)
17:55:53 <monochrom> Oh I have a cunning plan! Create a tmp file. Put your state in the tmp file.
17:55:56 <iqubic> monochrom: Yes, he would
17:56:22 <monochrom> Or environment variable!
17:56:43 <mtn> iqubic: Not quite yet. I'm looking at https://wiki.haskell.org/Haskell_in_5_steps at the moment
17:57:07 <mtn> iqubic: What confuses me is that they seem to only say to get stack and then include a header in each file so it runs, I think
17:57:12 <happyfeet> hey there, anyone here can help me with catamorphisms?
17:57:29 <iqubic> mtn: You don't need any headers at all.
17:57:51 <iqubic> Not sure why anyone would say that you need that.
17:57:58 <mtn> iqubic: I assume this isn't the full story: https://haskell-lang.org/get-started/osx ?
17:58:32 <mtn> iqubic: Becuase I already have stack, but if no ghci (or at least no ghci in path, and I'm not sure where it might be"
17:59:36 <iqubic> Yeah, you should have ghci.
18:00:12 <mtn> Am I missing something, or should it come with stack and automatically be in path?
18:03:18 <sm> mtn: "ghci" may not be in your PATH, but "stack ghci" should run one stack has installed
18:03:53 <mtn> sm: Right. Does `stack ghci` bringing up a ghci instance imply that I have ghci installed somewhere?
18:04:04 <sm> yes, "stack exec -- which ghci" shows where
18:04:29 <mtn> sm: Oh okay. And should I add what is returned to my path?
18:04:32 <geekosaur> the problem is, running it from outside of stack is problematic
18:04:38 <MarcelineVQ> mtn: to reiterate from earlier, to load a specific single file from the command line it's  stack exec ghci -- myfile.hs     and alternatively you can type stack ghci and use :load
18:04:41 <sm> no, you probably shouldn't
18:04:53 <geekosaur> because stack also sets up package visibility, and if you chaneg that outside of stack you can get (mostly nasty) surprises
18:05:01 <geekosaur> you should let stack manage it
18:05:02 <mtn> Oh okay. Sorry if I'm going in circles
18:05:22 <mtn> I'm not quite understanding what I need to do to have just `ghci` work though
18:05:27 <sm> better to alias "ghci" to "stack ghci"; or, do a manual installation of ghc/ghci yourself for use apart from stack
18:05:40 <MarcelineVQ> you can alias  stack exec ghci  if you like
18:06:00 <mtn> Right; I had an alias previously. The reason I started looking into this was that file loading failed
18:06:08 <MarcelineVQ> stack ghci isn't the same thing as stack exec ghci in the case of wanting to load a specific file
18:06:43 <mtn> perhaps alias stack exec ghci -- as ghci?
18:07:06 <mtn> that loads files as expected
18:11:07 <mtn> Unrelated, and sorry for these boring trouble-shooting problems. Syntastic doesn't seem to work (vim plugin) for haskell, though I installed hlint through stack
18:11:33 <mtn> Does anyone use the plugin and have any idea why that might be? Hlint comes up as the active checker on :SyntasticInfo
18:11:49 <m0cesta> I just can't understand: http://rosettacode.org/wiki/Combinations#Haskell (see "Dynamic programming" section)
18:11:50 <MarcelineVQ> have a gander at http://www.stephendiehl.com/posts/vim_2016.html if you haven't, I don't use vim myself
18:12:32 <mtn> MarcelineVQ: Thanks again!
18:17:44 <geekosaur> oy, tying the knot. yes. that will break your brain
18:20:35 <lyxia> m0cesta: Do you know dynamic programming? Though I don't think you actually gain much from dynamic programming anyway for this problem...
18:22:25 <geekosaur> m0cesta, what's going on here is that combsBySize produces each comb by length as a lazy list. if an element of that list is demanded, it will be computed then; and siunce the computation is recursive, that reuses the earlier computations because combsBySize is shared across all of the recursive calls
18:23:58 <geekosaur> this is a bit tricky and relies crucially on both laziness and (the way ghc implements) sharing.
18:25:08 <m0cesta> Oh, I think I'm getting the idea
18:25:38 <geekosaur> https://wiki.haskell.org/Tying_the_Knot has some discussion of the basic idea
18:26:11 <haskcat> If `f :: a -> Int`, then (from the theoretical/lambda calculus point of view), is `f`'s type `a -> Int`, or is that merely shorthand for saying that there are a FAMILY of f's who have type `String -> Int`, `Int -> Int`, and so on..
18:26:40 <haskcat> Put differently, is `a` an object in Hask?
18:27:24 <geekosaur> a is a set of objects in Hask, I think?
18:31:03 <erisco> a function's output also being its input
18:31:37 <erisco> a true ouroboros
18:53:48 <iqubic> Anyone know why I'm being told that ghc-mod is not being found, when using emacs?
18:54:40 <utdemir> iqubic: Emacs' PATH and shell's PATH variable are weirdly different. You can try `exec-path-from-shell.el`.
18:54:44 <benzrf> iqubic: is it installed? is it in your PATH/
18:55:12 <iqubic> I have ghc-mod installed.
18:55:25 <iqubic> I think it's in my path, yeah.
18:56:31 <utdemir> iqubic: You can try adding ghc-mod's path to your exec-path: https://www.emacswiki.org/emacs/ExecPath
18:56:50 <athan> I think phantom types could be kinda cool in STM: `writeTVar :: ... -> STM (Writes eff) ()`, `readTVar :: ... -> STM (Reads eff) ()`
18:57:43 <athan> where `Writes` is a sparse type family, and there includes 3 type symbols: `ReadOnly`, `WriteOnly`, and `ReadWrite`
18:58:43 <athan> i.e. `type family Writes WriteOnly = WriteOnly; Writes ReadWrite = ReadWrite` or something
19:00:53 <athan> you could probably make it even crazier, where it has a mapping of STM-capable variables (TVars, TChans, etc), and can list whether or not they're being read from or written to
19:04:48 <utdemir> Hey. I'm writing a TH function that generates a Servant API definition. However, it requires enabling -XDataKinds wherver you use that TH function. Is there any way to remove that requirement? Can I construct a Symbol without enabling DataKinds? Since I'm generating that with TH, it should not need to be pretty, it only needs to work without -XDataKinds.
19:05:19 <utdemir> I currently only need DataKinds because I need to construct a Symbol.
19:06:46 <glguy> utdemir: You'll need to turn on the extension
19:08:32 <geekosaur> A Symbol is a type-level list; type level lists require DataKinds. "Pretty" does not matter; the machinery being available/enabled matters and that requires the extension
19:12:39 <utdemir> glguy: geekosaur: What about if I implement type level lists myself using something like `data Nil; data Cons a b`, and on a seperate module, I write a type family from my lists and type-level lists (DataKinds enabled there), and I can use that type level function in modules without enabling DataKinds right? 
19:13:56 <glguy> that won't help much with Symbols
19:14:43 <utdemir> glguy: Okay, thanks :(. Have a nice day.
19:14:57 <geekosaur> also I think while ghc used to allow some things to be used without enabling the extentoion at the use site, that is now considered a bug
19:15:46 <utdemir> geekosaur: But it's kinda ugly to tell users of a library to "enable those extensions before using this TH function"/.
19:18:16 <geekosaur> (a) arguably if it's possible for Symbols to be used at all there, it should already be enabled (b) TH has never *not* been ugly
19:22:07 <fragamus> I needed streaming effects and composability, so I used pipes. I needed handy directory tree traversal so I used Turtle.lstree. I needed to have a function composed in the pipeline to count objects passing through, and do something at a certain frequency. I thought I could manage a counter in there. It didn;t work. I thought I would use StateT. it didnt work. The reason had to do with the non-determinism in Turtle.Shell.
19:22:07 <fragamus>  I was screwed before I started. I ended up using an IORef and it works now. Where did I go wrong? How could I have avoided this? What Book would have helped?
19:24:47 <Eduard_Munteanu> fragamus, I think you were bitten by too much magic in turtle, possibly not being adequately explained.
19:26:00 <iqubic> What even is Turtle?
19:31:15 <lyxia> fragamus: looking at your latest attempt with State, maybe you just lack experience with monad transformers.
19:31:32 <fragamus> Yes I had an inkling that there was non-determinism - I had reasoned that part out, but I couldnt fathom that state and non-determinism don't play well together
19:32:33 <lyxia> I don't think non-determinism is the actual issue... StateT s [] can be useful.
19:34:43 <geekosaur> don't State discussions make it clear it'[s just passing and returning extra parameters? I'd expect it to be fairly clear that if something is not passing and returning that parameter in a linear chain, the result will not behave like State
19:37:07 <lyxia> that's some intuition fragamus didn't have, so I guess that fact is not so clear
19:39:43 <Eduard_Munteanu> Is there a tool these days that autogenerates FFI definitions from header files? Or should I go the old-fashioned way with c2hs et. al?
19:43:43 <fragamus> there was forkIO in Turtle's non-determinism; that wasn't clear to me and it broke my stateT
19:48:19 <lyxia> the red flag was that you runStateT before applying view. So your action was always being run with the same initial state.
19:50:09 <lyxia> this means that the mistake can be spotted without knowing how turtle works
20:20:16 <fragamus> view has to be at the bottom of the stack like IO
20:20:35 <fragamus> Shell is the monad
20:27:34 <lyxia> and that makes it incompatible with StateT
20:27:44 <lyxia> at least in the way you expected it to work
20:29:30 <iqubic> Are we still talking about Turtle?
20:29:39 <iqubic> What's wrong with Turtle?
20:39:29 <monochrom> fragamus: You may enjoy this simpler example:
20:39:47 <fragamus> : o
20:39:52 <monochrom> > runStateT (do { x <- [3, 10]; modify (+ x) }) 0
20:39:54 <lambdabot>  error:
20:39:54 <lambdabot>      • Couldn't match type ‘[]’ with ‘StateT s m’
20:39:54 <lambdabot>        Expected type: StateT s m s
20:40:03 <monochrom> Oh!
20:40:07 <monochrom> > runStateT (do { x <- lift [3, 10]; modify (+ x) }) 0
20:40:09 <lambdabot>  [((),3),((),10)]
20:40:32 <monochrom> So this is the behaviour of StateT Integer [].
20:40:33 <fragamus> that's nice and concise
20:41:11 <monochrom> Shell is a bit more (closer to StateT Integer (ListT IO)) but I think plain [] illustrates the point sufficiently.
20:41:49 <fragamus> wait what is the end state 
20:42:05 <monochrom> There are two end states. 3 and 10 respectively.
20:42:16 <fragamus> oh right
20:42:38 <monochrom> When you do modify (+ 10) it restarts from the initial 0 and isn't aware that there was a "previous" (modify +3)
20:42:53 <monochrom> You don't get one single 13, you get [3, 10]
20:43:05 <monochrom> Initial state is forked over the two branches.
20:44:06 <monochrom> It's why I conjectured that in general "StateT (a nondet monad here)" is not going to let the state interact with the nondet.
20:44:35 <fragamus> so zooming out a sec, I don;t think that having streaming effectful pipes where one of the pipes is a counter that does some effect periodically is an unreasonable thing to want. What would be the most idiomatic way to get that
20:45:16 <fragamus> well think and answer some time in the future if you like
20:45:58 <fragamus> the IORef makes me want to take a shower but it's working
20:46:12 <monochrom> That depends on the exact semantics of "streaming effectful pipes". This is a meaningful phrase that admits too many conflicting meanings.
20:46:36 <fragamus> ok well Im using Pipes and Pipes.Core
20:46:47 <monochrom> I think when the Turtle doc says "streaming" it's half truth and half concealing.
20:46:58 <fragamus> yeah thats true
20:47:07 <monochrom> Ah I don't actually know pipes. I don't know what to do there.
20:48:05 <monochrom> But pipes doesn't do nondet so there is one fewer thing to worry about.
20:49:02 <fragamus> When you choose your composition operator Pipes decides how to connect stuff.
20:49:15 <fragamus> push vs pull etc
20:50:58 <iqubic> Is there a way to specify the type of the input to a lambda?
20:51:39 <iqubic> (\z a b -> z^2 + (a :+ b))
20:52:03 <iqubic> I want to specify that z needs to be of type Complex Double
20:52:18 <lyxia> with ScopedTypeVariables \(z :: Double)
20:52:38 <iqubic> lyxia: I'd want \(z :: Complex Double)
20:52:45 <lyxia> uh, yeah
20:52:48 <iqubic> Will that work?
20:52:52 <Maxdamantus> (\z a b -> (z :: Complex Double)^2 + (a :+ b))
20:52:53 <lyxia> otherwise you do this indirectly by annotating the whole function, or one of the use sites of z
20:53:02 <lyxia> iqubic: it will
20:53:57 <iqubic> lyxia, z is only ever used in that lambda.
20:54:43 <lyxia> did what I said contradict that
20:56:01 <iqubic> No.
20:57:02 <iqubic> So I do that, and then I'm told that a is invalid
21:10:35 <iqubic> What the difference between (^) and (**)?
21:11:02 <glguy> The types
21:11:05 <iqubic> :t (^)
21:11:07 <lambdabot> (Num a, Integral b) => a -> b -> a
21:11:16 <iqubic> :t (**)
21:11:17 <lambdabot> Floating a => a -> a -> a
21:11:29 <iqubic> Ah. Is that the only difference?
21:14:12 <iqubic> Which is easier to read: ((<= 2) . Magnitude) or (\z -> Magnitude z <= 2) ?
21:14:33 <iqubic> @pl (\z -> Magnitude z <= 2)
21:14:33 <lambdabot> (<= 2) . Magnitude
21:14:50 <rotaerk> (2 >=) . Magnitude
21:15:07 <iqubic> I think I like the second one better, and this is my code. I'll use the second one.
21:19:54 <plot> q
21:22:22 <iqubic> Isn't there a library for automatic differentiation? How does that library work exactly?
21:22:50 <iqubic> I don't mean how do I use that library. I mean, how does that library do the differentiation?
21:23:14 <glguy> What have you read about it so far?
21:24:35 <iqubic> I know that it takes an equation like ((x^2) + 7x) `div` (x) and finds the slope at a certain point.
21:25:04 <iqubic> So like if I gave it that equation and 7, it would find the instantaneous slop at x = 7
21:25:13 <glguy> There's stuff written online that you should be able to find using a search engine that will give you a lot more background than that
21:25:15 <iqubic> But *HOW* Does it do that.
21:25:55 <iqubic> Can I pattern match on a complex number, or should I use RealPart, and ImagPart?
21:26:09 <iqubic> Sorry, realPart and imagPart
21:40:05 <suzu> iqubic automatic differentiation works by using typeclass magic
21:41:03 <suzu> if i recall correctly, it was a typeclass defined on their internal ForwardDouble type
21:45:16 <ertes> iqubic: you have a math background, right?
21:46:24 <suzu> ah here it is
21:46:25 <suzu> https://hackage.haskell.org/package/ad-4.3.3/docs/src/Numeric-AD-Internal-Forward-Double.html#ForwardDouble
21:46:51 <ertes> iqubic: if yes, you may be interested in this talk, and yes, it's relevant to your question: https://www.youtube.com/watch?v=zmhd8clDd_Y
21:46:58 <suzu> so a ForwardDouble is a pair (value, deriviative)
21:47:12 <godel> !def zip
21:47:22 <ertes> @src zip
21:47:22 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
21:47:22 <lambdabot> zip _      _      = []
21:47:23 <suzu> and then there's a Floating instance for ForwardDouble where sums and multiplication use the product rule and sum rule of calulus
21:47:36 <suzu> and then there's some predefined values for pi and e^x and such
21:47:51 <godel> I'm trying to write zip without using explicit recursion
21:47:58 <godel> do you hace any idea of how to do that?
21:48:06 <godel> I tried using fold, but had no luck
21:48:45 <suzu> you can do it with some maps godel 
21:49:02 <suzu> a map and currying into a two-tuple..? i think
21:49:28 <godel> map (,) 
21:49:30 <godel> mmm
21:49:33 <godel> I mean no
21:49:37 <ertes> godel: folds can be stateful, and you can have the second list as state, while folding the first
21:49:53 <ertes> godel: http://ertes.eu/tutorial/foldr.html#stateful-folds
21:49:54 <godel> I like suzus idea better i think
21:49:59 <suzu> lol yeah map with (,)
21:50:03 <suzu> twice
21:50:07 <suzu> its ghetto but it'll do it i think
21:50:29 <godel> tbh this is homework
21:50:37 <godel> but I've been thinking about it for a while
21:50:47 <ertes> suzu's suggestion is to imitate the Applicative instance of ZipList =)
21:51:22 <suzu> ¯\_(ツ)_/¯ if you dont want recursion you gotta do what you gotta do
21:51:47 <godel> yea, its without recursion
21:51:55 <godel> well, we can use things like map or foldr
21:52:27 <ertes> godel: remember that (,) is curried, as are most multi-arg functions in haskell
21:52:38 <godel> yes yes
21:52:53 <ertes> godel: check the type of (map (,)), and it should be fairly straightforward to do
21:53:07 <suzu> iirc currying (,) wasnt possible without some lang extn before
21:53:14 <suzu> i may be wrong
21:53:29 <suzu> err rather using (,) as a constructor wasnt always a thing?
21:53:34 <ertes> suzu: you may be referring to sections…  tuple sections need an extension: TupleSections
21:53:44 <ertes> like: (, 5)
21:53:53 <suzu> yup that's it
21:54:07 <godel> yea
21:54:10 <godel> use zipwit
21:54:19 <godel> zipWith? but thats cheating I think
21:54:41 <godel> cause literally the next exercise tells me to implement zipWith (that's easy)
21:54:48 <suzu> don't use zip in your impl of zip
21:54:57 <godel> lol
21:54:57 <suzu> oh uh
21:54:59 <suzu> what
21:55:01 <suzu> lol okay
21:55:29 <godel> lol
21:55:35 <godel> if I have
21:55:49 <godel> map (,) xs     where xs :: [a]
21:56:03 <godel> when map (,) xs :: [b -> (a,b)]
21:56:51 <ertes> godel: you're not going to use the fold approach, right?
21:57:10 <godel> let me think a sec about that approach
21:57:19 <ertes> good, then i won't spoil it =)
22:00:12 <ertes> actually i don't think you can do it without a fold, unless you have other list functions at your disposal
22:00:32 <ertes> because the ZipList approach requires an equivalent to (<*>), which is pretty much zipWith already
22:00:46 <suzu> yeah i just tried this myself
22:00:54 <suzu> i need a zip to implement the zip
22:00:55 <suzu> lol
22:01:01 <suzu> i think the fold is the right way to go
22:01:06 <godel> a zipWith
22:01:09 <godel> zipWith ($) 
22:01:11 <godel> lol
22:01:13 <suzu> yeah that'll do it
22:01:21 <godel> yea, I'm thinking it with fold
22:01:26 <godel> I like your post
22:01:38 <suzu> post?
22:01:46 <godel> ertes'
22:01:54 <ertes> thanks…  also the section about stateful folds comes up often enough that i should perhaps write a self-contained version of it
22:02:02 <ertes> suzu: http://ertes.eu/tutorial/foldr.html#stateful-folds
22:02:06 <suzu> oh that!
22:02:09 <suzu> :)
22:02:46 <suzu> ertes do you write haskell professionally?
22:03:48 <ertes> suzu: yes, but it's just part of my job, not the main thing
22:05:57 <ertes> interestingly my fold approach yields a function that is more general than zipWith =)
22:06:33 <ertes> :t fAp
22:06:36 <lambdabot> Foldable t => t (t1 -> a) -> [t1] -> [a]
22:06:47 <ertes> that name is…  unfortunate…
22:07:38 <ertes> @let data V3 a = V3 !a !a !a deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
22:07:40 <lambdabot>  Defined.
22:07:54 <ertes> > fAp (V3 sin cos tan) [1,2,3]
22:07:57 <lambdabot>  [0.8414709848078965,-0.4161468365471424,-0.1425465430742778]
22:08:32 <godel> ok
22:08:37 <godel> ertes: you are a genius
22:08:40 <godel> I think I did it
22:08:46 <godel> it's very ugly though
22:08:52 <godel> let me type it ghci
22:08:54 <godel> to see if it works
22:10:17 <monochrom> ertes: It's because if you call Prelude's foldr it generalizes to Foldable in one parameter.
22:11:06 <monochrom> It would be nailed at [] last year.
22:11:27 <monochrom> Err maybe two years ago. Time flies like an arrow.
22:11:34 <ertes> yeah
22:11:39 <godel> armarPares = foldr (\a mas bs -> if null bs then [] else (a, head bs):(mas (tail bs))) (const []
22:11:47 <godel> it's in spanish but you get the idea
22:11:57 <godel> can it be done more elegantly
22:12:06 <suzu> i see ertes 
22:12:06 <ertes> godel: i suggest that you write an auxiliary function, but it's correct
22:12:13 <godel> btw thanks to this method I'm gonna be the king of this course now
22:12:14 <suzu> i note that your blog doesn't have your real name
22:12:16 <godel> thank you so much
22:12:19 <ertes> godel: 
22:12:22 <ertes> :t let apF f go (x:xs) = f x : go xs; f _ _ [] = [] in foldr apF (const [])
22:12:22 <monochrom> You should not be using null-head-tail in this context. You should use pattern matching.
22:12:24 <lambdabot> Foldable t => t (t1 -> a) -> [t1] -> [a]
22:12:26 <suzu> i've always been considering writing something but don't want to air my real name out, lol
22:13:00 <ertes> suzu: it does under "legal information"
22:13:09 <ertes> suzu: because german law actually requires it
22:13:10 <monochrom> ertes is as realname as I care.
22:13:25 <suzu> on the website? wtf for real?
22:13:26 <ertes> but yeah, call me ertes =)
22:13:33 <suzu> can't stick it in WHOIS?
22:13:37 <suzu> or host your site in not-germany
22:14:00 <monochrom> The real difficulty is not realness, but rather uniqueness. ertes goes by a different name on haskell-cafe. That's the only hurdle.
22:14:12 <monochrom> Or rather, s/uniqueness/aliasing/
22:14:17 <MarcelineVQ> is it setre?
22:14:48 <godel> ertes: I like this approach so much
22:14:50 <ertes> i could gamble, but we have lawyers ("abmahn-anwälte") who abuse the law to force money out of unwitting webmasters' pockets
22:15:10 <godel> one of the exercises was to write (++) w/o explicit recursion
22:15:20 <godel> (++) :: [a] -> [a] -> [a]
22:15:27 <godel> so what I was doing was to do
22:15:29 <ertes> monochrom: well, i do sign my cafe posts with "ertes" =)
22:15:37 <godel> (++) xs = foldr ...
22:15:54 <godel> but taking [a] -> ([a] -> [a])
22:16:00 <godel> and making foldr return functions
22:16:03 <godel> is brilliant
22:16:07 <monochrom> P.S. aliasing is also the #1 reason why reasoning about mutable data on the heap is so hard. If you see (for example C code, but not confined to C) " *p = 4; *q = 5; " you don't know what to predict because you aren't sure whether p and q are pointing to the same damn cell.
22:16:10 <suzu> stick yo func in the accumulator
22:16:17 <suzu> and modify as you go
22:16:18 <godel> it's great
22:16:39 <suzu> the state monad and several other things work similarly
22:16:50 <monochrom> And John Reynolds the Great barely started with solve it by his "separation logic" not long before he died.
22:17:01 <ertes> you can actually use StateT with foldr =)
22:17:02 <suzu> actually, not exactly - its a bit far off so scratch that analogy
22:17:03 <monochrom> s/with/to/
22:17:19 <ertes> but in most cases you can just use 'traverse_'
22:17:45 <ertes> foldr is only required if the fold needs some state of its own in those cases
22:18:12 <ertes> :t foldr (\x go -> print x >> go) (pure ())
22:18:14 <lambdabot> (Show a, Foldable t) => t a -> IO ()
22:18:18 <ertes> :t traverse_ print
22:18:19 <lambdabot> (Show a, Foldable t) => t a -> IO ()
22:19:04 <ertes> and in most cases you can just factor the stateful part out of the fold
22:19:30 <ertes> :t foldr (\x go n -> if n > 0 then print x >> go (n - 1) else pure ()) (\_ -> pure ())
22:19:31 <lambdabot> (Show a, Num t1, Ord t1, Foldable t) => t a -> t1 -> IO ()
22:19:58 <ertes> :t flip $ foldr (\x go n -> if n > 0 then print x >> go (n - 1) else pure ()) (\_ -> pure ())
22:20:00 <lambdabot> (Show a, Num t1, Ord t1, Foldable t) => t1 -> t a -> IO ()
22:20:09 <ertes> :t \n -> traverse_ print . take n
22:20:10 <lambdabot> Show a => Int -> [a] -> IO ()
22:20:17 <ertes> state factored out
22:28:07 <iqubic> What the heck is StateT, and how does it differ from a regular State?
22:28:18 <johnw> iqubic: it's a monad transformer
22:28:27 <johnw> State s a = StateT s Identity a
22:28:40 <iqubic> :t state
22:28:42 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
22:28:58 <ertes> @src StateT
22:28:58 <lambdabot> Source not found. Where did you learn to type?
22:29:19 <iqubic> johnw: Why do we care about StateT, when we have State?
22:29:31 <johnw> sometimes you want to mix state and some other monad
22:29:38 <johnw> for example, IO
22:29:40 <iqubic> What does that mean?
22:29:47 <johnw> that way, your decision about what to do in IO can depend on the prevailing state
22:29:54 <ertes> @src State
22:29:54 <lambdabot> type State s = StateT s Identity
22:29:54 <lambdabot> --OR
22:29:54 <lambdabot> data State s a = State { runState :: s -> (a, s) }
22:30:06 <iqubic> Sure.
22:30:36 <iqubic> So a monad transformer let's change which monad you're using?
22:30:54 <iqubic> Like if you want to mix State and IO?
22:30:55 <ertes> iqubic: a monad transformer takes a monad and gives you a monad in return
22:30:56 <johnw> not so much change
22:30:59 <johnw> think of it like layering
22:31:11 <ertes> iqubic: MaybeT :: (* -> *) -> (* -> *)
22:31:14 <iqubic> Can I see an example of that in use?
22:31:17 <johnw> "state in the presence of another monad"
22:31:35 <ertes> for example (MaybeT IO) is like IO with an additional short-circuit effect
22:31:46 <iqubic> I want to see an example of a monad transformer in Action.
22:32:27 <johnw> if you google "haskell monad transformer", you'll see many examples
22:32:54 <ertes> > execStateT (do x <- get; guard (even x); put (2*x)) 4 :: Maybe Integer
22:32:56 <lambdabot>  Just 8
22:32:58 <ertes> > execStateT (do x <- get; guard (even x); put (2*x)) 5 :: Maybe Integer
22:33:01 <lambdabot>  Nothing
22:33:10 <ertes> iqubic: example of (StateT Integer Maybe)
22:34:36 <iqubic> How the heck can you have a function that returns an IO (Maybe String)?
22:34:40 <godel> aw man
22:34:43 <godel> this is sick
22:34:44 <simony> :t guard
22:34:47 <lambdabot> Alternative f => Bool -> f ()
22:34:52 <iqubic> Oh, wait I see now.
22:35:05 <ertes> > execStateT (do x <- get; put (x + 1) <|> put (x - 1)) 5 :: [Integer]
22:35:07 <c_wraith> iqubic: Any IO action that might produce a String, or might now
22:35:08 <lambdabot>  [6,4]
22:35:09 <c_wraith> *not
22:35:20 <ertes> iqubic: example of (StateT Integer [])
22:35:37 <ertes> it's a list monad with an additional branching state effect
22:35:49 <iqubic> What is <|>?
22:35:52 <ertes> you can modify the state in one way in one branch and in another way in another branch
22:36:06 <simony> in these cases, is the StateT the inner monad or outer?
22:36:10 <ertes> > "abc" <|> "def"
22:36:12 <lambdabot>  "abcdef"
22:36:23 <iqubic> Why not just use :
22:36:27 <iqubic> Or ++?
22:36:44 <iqubic> well not : because it's the wrong type.
22:36:48 <iqubic> :t (++)
22:36:50 <ertes> iqubic: because (<|>) is more general…  it understands that there is a [] underneath StateT
22:36:50 <lambdabot> [a] -> [a] -> [a]
22:37:01 <johnw> simony: SateT is "outer", the underlying type is: s -> IO (a, s)
22:37:01 <iqubic> :t (<|>)
22:37:03 <lambdabot> Alternative f => f a -> f a -> f a
22:37:34 <iqubic> So, [] is an instance of Alternative?
22:37:50 <ertes> simony: it's a matter of perspective…  i would just say: [] transformed by (StateT Integer), or (StateT Integer) applied to []
22:38:25 <jle`> iqubic: you can check on ghci :) :i []
22:38:46 <jle`> the documentation for Alternative also say as well
22:39:10 <ertes> iqubic: (StateT S []) is quite useful in search algorithms
22:39:27 <iqubic> Searching?
22:40:02 <ertes> yeah, imagine you have a tree-like branching search with some per-branch state
22:40:03 <iqubic> You mean like finding all values that return True from (a -> Bool)
22:42:20 <ertes> no, that's too simple
22:43:05 <iqubic> It is??
22:44:16 <simony> :t execStateT (do x <- get; put (x + 1) <|> put (x - 1))
22:44:17 <lambdabot> (Num s, MonadPlus m) => s -> m s
22:45:19 <simony> :t execStateT
22:45:21 <lambdabot> Monad m => StateT s m a -> s -> m s
22:45:39 <iqubic> Why does that need the MonadPlus constraint?
22:47:48 <ertes> @let data BTree a = Leaf | Branch a (BTree a) (BTree a) deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
22:47:49 <simony> i'm guessing it's because execState's Monad m constraint
22:47:50 <lambdabot>  Defined.
22:47:59 <ertes> @let combPred p | not (p mempty) = const []; combPred p = flip execStateT mempty . go where go Leaf = pure (); go (Branch dx ls rs) = do x' <- get; let { x = x' <> dx} ; guard (p x); go ls <|> go rs
22:48:01 <lambdabot>  Defined.
22:48:04 <ertes> :t combPred
22:48:05 <lambdabot> Monoid t => (t -> Bool) -> BTree t -> [t]
22:48:39 <ertes> iqubic: this one computes the monoid-sum of each path through a binary tree, leaving out branches where any intermediate result does not satisfy the given predicate
22:49:27 <ertes> > combPred even (Branch 2 (Branch 4 Leaf Leaf) (Branch 6 (Branch 7 Leaf Leaf) Leaf))
22:49:29 <lambdabot>  error:
22:49:29 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M232416788264...
22:49:29 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
22:49:44 <ertes> > combPred even (Branch 2 (Branch 4 Leaf Leaf) (Branch 6 (Branch 7 Leaf Leaf) Leaf)) :: [Sum Integer]
22:49:47 <lambdabot>  error:
22:49:47 <lambdabot>      • No instance for (Integral (Sum Integer))
22:49:47 <lambdabot>          arising from a use of ‘even’
22:49:51 <ertes> oh, come on…
22:50:24 <ertes> > combPred (even . getSum) (Branch 2 (Branch 4 Leaf Leaf) (Branch 6 (Branch 7 Leaf Leaf) Leaf)) :: [Sum Integer]
22:50:28 <lambdabot>  [Sum {getSum = 0},Sum {getSum = 0},Sum {getSum = 0}]
22:50:36 <ertes> that…  looks wrong…
22:50:58 <ertes> i forgot to put the new state =)
22:51:19 <ertes> @let combPred' p | not (p mempty) = const []; combPred' p = flip execStateT mempty . go where go Leaf = pure (); go (Branch dx ls rs) = do x' <- get; let { x = x' <> dx} ; guard (p x); put x; go ls <|> go rs
22:51:22 <lambdabot>  Defined.
22:51:26 <ertes> > combPred' (even . getSum) (Branch 2 (Branch 4 Leaf Leaf) (Branch 6 (Branch 7 Leaf Leaf) Leaf)) :: [Sum Integer]
22:51:29 <lambdabot>  [Sum {getSum = 6},Sum {getSum = 6},Sum {getSum = 8}]
22:51:32 <ertes> sorry for the noise =)
22:51:56 <ertes> the branch with the 7 is ignored, because there was an odd intermediate result
22:53:42 <ertes> you can now query this: "give me the first result", and traversal is only done until the first result is found, or "give me the first ten results", "give me all results", etc.
22:53:49 <iqubic> That's really cool
22:56:31 <ertes> welcome to the rabbit hole =)
22:57:59 <godel> question
22:58:16 <godel> I wrote transpose without explicit recursion
22:58:23 <godel> transpose :: [[Int]] -> [[Int]]
22:58:33 <godel> matrix transposition
22:58:54 <godel> transpose = foldr (zipWith (:)) (repeat [])
22:59:01 <godel> fairly easy
22:59:17 <godel> but what if the matrix was given as a (Int -> Int -> a)
22:59:19 <godel> so
22:59:33 <godel> transpose :: (Int -> Int -> a) -> (Int -> Int -> a)
22:59:42 <godel> oh
22:59:46 <godel> im DUMB
22:59:48 <ertes> godel: you may want to go with the general type signature right away:  [[a]] -> [[a]]  -- it reduces the density of wrong implementations
23:00:02 <godel> yes yes sorry
23:00:08 <godel> I don't know why I wrote int
23:00:23 <ertes> if you had wrote 'int', it would have been general =)
23:00:28 <godel> transpose f i j = f j i
23:00:30 <godel> right?
23:00:36 <ertes> yeah
23:01:11 <godel> transpose = flip ?
23:01:13 <godel> mmmmmm
23:01:14 <simony> flip?
23:01:25 <godel> yea lol that was what I was thinking
23:01:30 <simony> :P
23:01:34 <godel> but the question is
23:01:55 <godel> can I define a scheme like map for a function (a -> b) for example?
23:02:16 <godel> like what would fmap be for (->)
23:02:16 <ertes> godel: what's the type signature?
23:02:29 <ertes> godel: write the type signature, and it may be fairly evident
23:03:31 <godel> m
23:03:33 <godel> lol
23:03:39 <ertes> godel: trivial even, because there is only one correct implementation of fmap for ((->) a)
23:03:49 <godel> (a -> b) -> (c -> a) -> (c -> b)
23:03:50 <godel> (.)
23:04:04 <godel> mmm
23:04:07 <ertes> s/correct/well-typed/
23:04:11 <godel> but what does that mean
23:04:26 <ertes> exactly what you said: fmap for functions is just composition
23:04:53 <ertes> given a function f, to modify its result by the function g, you postcompose g:  g . f
23:05:01 <godel> ohhhhhh
23:05:03 <godel> right
23:05:06 <godel> so easy :P
23:05:10 <godel> thanks ertes 
23:05:26 <johnw> "map over the image of 'f'"
