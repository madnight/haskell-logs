00:00:24 <dmwit> Perhaps you can describe the symptoms in some detail.
00:00:31 <Lokathor> yes one moment
00:00:37 <Lokathor> i can push it all back up to git
00:00:43 <Lokathor> already in "small example" mode really
00:00:54 <dmwit> :thumbsup:
00:01:33 <Lokathor> https://github.com/Lokathor/scratch
00:02:22 <Lokathor> when i run it i get: scratch.EXE: genesis-eo-formatted.txt: commitBuffer: invalid argument (invalid character)
00:03:16 <Lokathor> now i'm not really a christian, but i think that "commitBuffer" probably wasn't written down in any ancient hebrew books :P
00:04:03 <cocreature> Lokathor: is your locale set correctly? the behavior of "readFile" depends on that
00:04:25 <Lokathor> cocreature, it is... whatever windows defaults to
00:05:08 <cocreature> Lokathor: the hakyll docs seem to suggest that "chcp 65001" works on windows
00:05:13 <cocreature> don’t ask me what that does :)
00:05:45 <Lokathor> my terminal gives me the cryptic "Active code page: 65001"
00:05:50 <Lokathor> it's like i'm really in an adventure game
00:05:59 <Lokathor> now it works, i guess
00:06:54 <cocreature> ghc -- the game: fight the type checker, create new types, an infinite amount of values in lists and more!
00:07:44 <ongy> more like "language support the game. Fight the compiler, fight the terminal and fight anything that has to display it!"
00:08:37 <Lokathor> https://www.youtube.com/watch?v=4aGDCE6Nrz0
00:09:09 <ongy> the highest quality animation in ages
00:22:13 <Lokathor> it still confuses me that there's no "stack run" command
00:26:09 <cocreature> Lokathor: https://hackage.haskell.org/package/stack-run
00:26:38 <Lokathor> why is this not a default part of stack
00:27:00 <cocreature> dunno
00:27:04 <Lokathor> oh
00:27:04 <Lokathor> also
00:27:06 <Lokathor> unix only
00:46:13 <jennyrgb> tempu: you're in ##haskell
00:48:01 <jennyrgb> "data LL t = Empty | Node t (LL t)". shoplift = Empty
00:48:49 <jennyrgb> how do haskell infere the type of shoplift? I also have a tree that has an 'Empty' contructor. It's ambigious but ghci lets it through.
00:53:05 <boxscape> jennyrgb: what happens if you do :t Empty?
00:53:39 <jennyrgb> boxscape: it's of the latest defined typeclass
00:54:05 <jennyrgb> that uses Empty of course
00:54:39 <boxscape> is it possible that you simply overwrote the name "Empty" with the new meaning?
00:54:55 <boxscape> can you still say "Empty :: <first type>" without an error?
00:55:16 <davean> Was the other type even in scope?
00:55:36 <davean> Because it isn't reporting any ambiguity
00:57:14 <jennyrgb> Going to share two lines of code.
00:57:19 <jennyrgb> Prelude> data Tree t = Node (Tree t) t (Tree t) | Empty
00:57:23 <jennyrgb> data LL t = Empty | Node t (LL t)
00:58:18 <jennyrgb> gici did not say anything. Type of empty was 'LL t' after the second definition.
00:58:35 <jennyrgb> ghci*. It is possible that I have missed something though.
00:59:29 <boxscape> jennyrgb: but if you write "Empty :: Tree a" you get an error, right?
01:00:06 <Aruro> jennyrgb: its overridden , thats all
01:00:34 <Aruro> last definition makes Empty to be just LL type
01:03:44 <jennyrgb> boxscape: yes, it's already defined
01:04:03 <jennyrgb> how do I make an empty tree then?
01:04:18 <Aruro> say EmptyLL EmptyTree
01:04:33 <Aruro> not same name
01:05:53 <boxscape> using the same name wouldn't work in actual code anyway, just in ghci, so there's really not much point in doing it
01:06:03 <jennyrgb> Ok, nice. So they share scope? If I were to compile this instead of using the interactive console, it'd be an error?
01:06:14 <jennyrgb> oh ok :p
01:06:16 <boxscape> yes, I'm almost certain
01:07:25 <jennyrgb> seems like the constructors have the same name scope as everything else?
01:07:49 <jennyrgb> I mean, functions and "variables"
01:08:14 <jennyrgb> variables--> functions without parameters
01:08:50 <kadobanana> Constructors are values, but they're a bit separate because they must start with capital letters, and functions and other values must not
01:09:26 <boxscape> you can also only define constructors at top level, whereas you can define functions inside other functions
01:10:44 <Aruro> :t True
01:10:46 <lambdabot> Bool
01:10:57 <Aruro> :t Just
01:10:58 <lambdabot> a -> Maybe a
01:11:07 <Aruro> jennyrgb: Just is a function
01:11:59 <Aruro> so above u defined two constanst with same name (Empty) but different types
01:12:35 <Aruro> > data F = A | B Int
01:12:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
01:12:44 <Aruro> > @let data F = A | B Int
01:12:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
01:12:52 <Aruro> @let data F = A | B Int
01:12:54 <lambdabot>  Defined.
01:12:57 <Aruro> :t B
01:12:59 <lambdabot> Int -> F
01:13:03 <Aruro> :t A
01:13:04 <lambdabot> F
01:35:32 <jennyrgb> anyone else having problems with spammers on github?
01:37:02 <jennyrgb> https://github.com/CoralineAda she got my email from my commits and sent me some kind of links and also wanted me to add those files to my project. I have no idea who she is. She wanted me to install a commit filter that removes all "gender assuming pronoun" or something, "he", "she" is offensive or something.
01:43:06 <kadobanana> There's a reason email has filters. Also that doesn't really sound like spam so much as just someone you don't want to deal with, so ... ignore/filter their emails, or tell them you're not interested.
01:45:19 <otulp> This  is Haskell! Doesn't matter if it's a She or He; they all come with nice bottoms.
01:47:16 <jennyrgb> kind of. Shouldn't matter if someone sings old german nationalist songs and cry over the death of hitler, as long as they post proper code. It really hasn't anything to do with the project.
01:49:38 <quchen> Is she the toxic person Github saw fit to hire after she destroyed a couple of projects? My advice would be to wave and smile, and keep walking.
01:50:08 <jennyrgb> quchen: I'm not going to use github anymore https://imgur.com/QC51FZz
01:50:35 <jennyrgb> quchen: I fear that these people won't give up and you'll end up banned. I'm not okay with that feeling, it stresses me
01:54:23 <quchen> jennyrgb: Gitlab! :-)
01:54:43 <Akii> might have to move this one too then, https://github.com/Akii/acme-fucks
01:54:52 <Akii> oh well
01:55:15 <Akii> at least it's gender neutral
01:56:02 <jennyrgb> quchen: I googled gitlab, seems like they have the same problem. https://www.reddit.com/r/KotakuInAction/comments/45mxpt/discussion_which_git_repo_is_the_best_ive_seen/  But I found this: https://gitgud.io/
01:56:33 <kadobanana> So your problem with github is that someone, who doesn't work at github, sent you an email? I am very confused.
01:56:57 <quchen> No, she’s a Github employee.
01:57:00 <otulp> jennyrgb: Nice save, changing retards to gits. I'm sure github is not going after that particular word.
01:57:38 <MarcelineVQ> it's that weird time of the week in #haskell land
01:57:56 <kadobanana> Oh. I'd still just ignore it.
01:58:38 <quchen> One way to solve problems with words like »retarded« is also to not build projects that require such language.
01:59:33 <Philonous> As if anything ever _required_ this kind of language
02:00:34 <otulp> I'm thinking acme-fucks is a nice example here.
02:01:18 <otulp> It wouldn't work very well as acme-tootin-darns, would it?
02:01:42 <Akii> would probably be fun to come up with a political correct version
02:02:18 <MarcelineVQ> gitgud exists because someone thought pc C++ would be fun and github didn't think so
02:02:47 <MarcelineVQ> one of the reasons anyway
02:03:10 <jennyrgb> MarcelineVQ: pc C++?
02:03:21 <MarcelineVQ> mmhm, C+=
02:04:20 <jennyrgb> most feminists have balls anyway, they should use them.
02:04:44 <jennyrgb> or not. But don't bleed all over my source code :p
02:04:45 <Athas> Anyone here in academia and considering submitting to the workshop on high-performance functional programming at ICFP?
02:04:52 <otulp> jennyrgb: I think you are confused about what that bit of anatomy does.
02:04:57 <MarcelineVQ> could be, possibly a better discussion for #haskell-offtopic though, the mods here get cranky after too much ot
02:12:41 <magthe> I'm working with a rather low-level protocol in Haskell, the only datatype supported by it is UInt16, so 32-bit values are constructed by combining two UInt16... is there a go-to library on Hackage for that sort of combining-num-types-to-bigger-types (ideally also splitting of them :)?
02:13:50 <jennyrgb> magthe: your own type with two UInt16? haskell isn't really a system programming language
02:14:14 <jennyrgb> magthe: or just go with Integer or Int (32 or 64-bit) if space isn't an issue.
02:14:22 <Athas> magthe: Data.Word has very easy-to-use unsigned types.
02:14:32 <jennyrgb> or that
02:14:36 <magthe> jennyrgb: yeah, I know it isn't... but it is such a nice language :)
02:14:37 <Athas> You'll need to split them up yourself, though, but that's easily done with the usual bitshifts.
02:15:07 <Athas> I've done integer-size-sensitive code in Haskell, and it has been quite pleasant.  Probably not very fast, though.
02:15:10 <magthe> Athas: yupp, I was rather hoping someone else had already done that twiddling-of-bits
02:16:22 <Xandaros> Shift the most significant part by 16 and or in the other?
02:16:47 <magthe> jennyrgb, Athas: I guess I'll just have to write my own helper functions
02:17:18 <Athas> That seems a likely fate.
02:41:55 <bakibour> Hi, im looking for a way to "zip" two lists of key value pairs, so that the resulting list will have empty entries for keys that were not contained in the other.
02:42:06 <bakibour> It is ment to fill a table so that you get an empty cell for the missing entries in the other list.
02:44:09 <brynedwards> bakibour: This looks like a good place to start https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Merge-Strict.html#g:2
02:44:34 <bakibour> brynedwards: Thanks, checking
02:45:31 <sshine> bakibour, what are empty entries? and how does an empty entry occur in the input list if they match up? is it only if one is longer than the other?
02:46:15 <bakibour> The lists are columns in the table but the columns do not necessarily have the same length, they have a key though for the entries.
02:46:46 <bakibour> So you could have ((a, 0), (b, 1)) and ((a, 5), (c, 3)) 
02:47:16 <bakibour> And now i would like to have a list that contains a b and c but the c is empty in the first column and b in the second
02:47:53 <cocreature> bakibour: what do you mean by “being empty”? should the value be “Nothing”?
02:48:07 <bakibour> Yes
02:48:27 <bakibour> If i would transform it into a csv file in the end there is just no string, or something like NA or so
02:49:12 <bakibour> Depends on the type for the table in the end, im more interested in what kind of transformation i am looking for.
02:49:21 <bakibour> I guess something like a more intelligent zip
02:50:19 <cocreature> I think the merge function brynedwards linked to is exactly what you’re looking for
02:55:47 <bakibour> cocreature: Thanks i will check that out, did not expect to get an answer thist quick :)
02:58:46 <tsahyt> Is anybody here familiar with liquid haskell?
03:00:11 <cocreature> tsahyt: you’re more likely to get an answer if you ask your actual question :)
03:02:09 <tsahyt> okay. I'm playing around with it a bit, and my running example is integer factorization. to that end I define what it means to be a divisor of a number (I figured tackling primality is for later), {-@ type Divisor N = { x:Nat | N mod x = 0 } @-}. now I want to write a function that returns the smallest factor (other than 1) of a natural number, i.e. {-@ firstFactor :: {n:Nat | n >= 2} -> Divisor n @-}.
03:02:36 <tsahyt> such a number must exist of course. but I can't figure out an implementation that actually type checks through liquid haskell
03:02:56 <tsahyt> from all that I can see this should be correct. firstFactor x = head (filter (\n -> mod n x == 0) [2..x])
03:03:15 <tsahyt> the list is never empty of course because mod x x == 0.
03:04:10 <tsahyt> so I guess my question is how I should tackle this then. I've tried unfolding the head+filter construct manually, but ran into issues again
03:07:49 <kuribas> cabal tells me: "ghc-options: -O2' is rarely needed. Check that it is giving a real benefit"
03:08:06 <kuribas> But I find that important optimizations like inlining are only performend with -O2
03:08:19 <tsahyt> kuribas: inlining should be performed with -O1 too
03:08:38 <tsahyt> in general. GHC might be more aggressive with it when using -O2 I think.
03:08:47 <cocreature> tsahyt: can you lpaste your code? I’m having a hard time parsing it mentally inside your message :)
03:09:35 <tsahyt> cocreature: okay. should I add the liquid haskell errors in comments?
03:09:41 <cocreature> tsahyt: sure
03:12:14 <lpaste> tsahyt pasted “No title” at http://lpaste.net/354358
03:12:23 <tsahyt> cocreature: ^
03:14:23 <tsahyt> hmm actually firstFactor' might even be wrong
03:16:14 <tsahyt> and the arguments to mod in firstFactor should be swapped. I'll revise this
03:18:18 <guillaum2> Hello. Someone can help me prooving the (partial) injectivity of the type level boolean or ?
03:18:21 <guillaum2> https://gist.github.com/guibou/c58bd9d3952b37bb3b2dc56bae3e083b
03:19:18 <lpaste> tsahyt revised “No title”: “No title” at http://lpaste.net/354358
03:19:54 <tsahyt> the problems still persist though
03:21:07 <kuribas> tsahyt: weird, no I get the same performance...
03:21:33 <tsahyt> kuribas: are you sure everything got recompiled when you tried earlier? sometimes it doesn't do that for some reason
03:21:57 <kuribas> that maybe it...
03:21:58 <tsahyt> kuribas: there's value in -O2 though. a lot of the optimizations in the vector package don't trigger with -O1 in my experience.
03:22:12 <tsahyt> so when you write vector heavy code, it's usually a good idea to compile with -O2
03:22:36 <kuribas> tsahyt: it's numerical code, with some vector in there.
03:23:11 <cocreature> tsahyt: hm sorry not sure how to fix that
03:23:25 <tsahyt> kuribas: I think it should also be possible to use -O2 on a per module basis with pragmas, but I've never tried that
03:24:16 <tsahyt> cocreature: okay. thanks anyway. I'll just keep trying I guess
03:24:28 <kuribas> tsahyt: performance is ok now, it's probably not worth the effort to sqeeze every bit of performance out of it...
03:25:24 <tsahyt> kuribas: usually that's the case. once you've exhausted all the low hanging fruits, e.g. switching your vectors to unboxed or storable vectors etc, it's usually not worth going much further unless something's seriously wrong
03:25:43 <kuribas> tsahyt: It takes the union of 60 circles in 14ms
03:25:59 <tsahyt> circles as in what?
03:26:19 <kuribas> cirle paths, using bezier curves
03:27:02 <tsahyt> hmm. I have no frame of reference to judge whether that's fast or not, but if it's fast enough for your application then I'd say move on. if it becomes a problem later on you can still revisit it
03:28:00 <kuribas> I have ideas for improving it, but they may introduce new bugs...
03:28:07 <tsahyt> on the topic of performance, I'm already hyped for linear types
03:29:10 <tsahyt> kuribas: when optimizing, it's always a good idea to set up some regression tests beforehand. Over the years I've broken way too many things while trying to make them fast. numeric code in particular is painful in that regard because the types are often not very helpful
03:29:31 <kuribas> yeah, right
03:29:39 <tsahyt> and then there's this whole thing with numeric stability possibly going out the window and so on
03:30:13 <sphinxo> BinOp vs Binop? ( correct naming )
03:30:22 <tsahyt> sphinxo: I'd use BinOp
03:30:35 <sphinxo> thanks
03:30:36 <kuribas> tsahyt: yeah, most of the bugs hadn't anything to do with the complicated algorithm, but with numerical edge-cases.
03:30:52 <tsahyt> PascalCase for type/data constructors, camelCase for functions etc
03:31:19 <tsahyt> kuribas: I once spent a month correcting numerical edge cases in a mesh generator. epsilons everywhere. I think I lost a decent chunk of sanity in that time.
03:31:49 <kuribas> tsahyt: haha, so I am not alone :)
03:32:11 <merijn> tsahyt: See, this is why I only work with integers... :p
03:32:29 <tsahyt> in particular it depended on x == 0 type comparisons in a lot of places. so I learned to love the ieee754 package and its AEq class
03:32:33 <kuribas> merijn: that's just shifting the problem.
03:32:34 <merijn> Actually, that's not true, I have some stuff using floats, but it's a fixpoint computation so I don't care about accuracy that much :)
03:33:36 <merijn> kuribas: In what way?
03:34:10 <tsahyt> the last thing I wrote that made extensive use of floating point was audio processing stuff. inaccuracies don't matter *that* much in that case.
03:34:21 <kuribas> merijn: how could you find the intersection of a bezier curve with integers?
03:34:25 <tsahyt> it's not like you can hear a 1.0e-13 difference
03:34:41 <kuribas> merijn: or the root of a 9th degree polynomial?
03:34:59 <tsahyt> there was this tool to find numerical problems in code
03:35:10 <tsahyt> it was on /r/haskell quite a while ago, but I don't remember the name
03:35:25 <merijn> kuribas: You don't, I wasn't saying it was a solution, just that I avoid attempting to solve said problems :p
03:35:42 <merijn> tsahyt: I've seen several such tools, yeah. But I forgot the names
03:35:42 <peddie> tsahyt: herbie?
03:35:54 <tsahyt> yes that was it
03:36:18 <kuribas> tsahyt: I think even float is good enough for CAD or audio.
03:36:25 <tsahyt> kuribas: it is mostly, yes
03:36:29 <tsahyt> for audio, definitely
03:36:50 <tsahyt> hmm, the github page for herbie mentions GHC 7.10.{1,2}. I wonder whether it still works with ghc 8
03:39:52 <kuribas> but double and float cost the same, unless you use SIMD
03:40:00 <kuribas> or GPUs
03:40:32 <merijn> Clearly the only solution to performance is float16! ;)
03:41:43 <cocreature> float8!
03:42:44 <Athas> kuribas: or are memory bound!
03:43:12 <merijn> cocreature: Do those exist?
03:43:18 <kuribas> Athas: yeah, cache hits matter too.
03:44:00 <eatman> Hi! can someone tell me what is the meaning of the ! in from of Scalar in the Vector3 data type please?
03:44:05 <eatman> https://hackage.haskell.org/package/Octree-0.5.4.3/docs/Data-Octree.html
03:44:23 <kuribas> eatman: strict fields
03:44:41 <eatman> That is? Always evaluated before storage?
03:44:41 <cocreature> merijn: only in some specialized applications iirc
03:44:43 <peddie> eatman: it's a strict field, it means the Scalar will be evaluated whenever it's put there
03:44:53 <eatman> All right, thanks.
03:45:40 <kuribas> eatman: https://wiki.haskell.org/Performance/Data_types#Strict_fields
03:46:49 <eatman> All right, I understand now https://hackage.haskell.org/package/AC-Vector-2.3.2/docs/src/Data-Vector-V3.html#Vector3
03:46:52 <eatman> Thanks!
04:01:09 * ocramz just installed `intero` 
04:01:14 <ocramz> works like a charm
04:03:46 <quchen> Still only in Emacs though, right?
04:04:48 <brynedwards> I think there are intero plugins for neovim and visual studio code
04:04:49 <ocramz> quchen I believe so; I never made the switch to Spacemacs et al
04:25:08 <eatman> A bit late but, hey, it's hard to do haskell with vim!
04:31:26 <klottie> I have two values, I need to compare them and assign them to 'left' and 'right', respectively. Is there a better way to this than (left,right) = (min val1 val2, max val1 val2)? It works but there are 2 comparisons in this way where 1 comparison is sufficient.
04:31:54 <hpc> [left, right] = sort [val1, val2]?
04:32:50 <Taneb> klottie, you could do if val1 < val2 then (val1, val2) else (val2, val1)
04:33:53 <klottie> hpc: I had thought of that but using sort for just 2 values was unnecessary in my opinion.
04:34:04 <klottie> Taneb: that's fair enough.
04:34:08 <klottie> thanks.
05:14:56 <quchen> > let f = join (\(a,b) -> if a <= b then id else swap) in f (1, 2)
05:14:58 <lambdabot>  (1,2)
05:15:03 <quchen> > let f = join (\(a,b) -> if a <= b then id else swap) in f (2, 1)
05:15:06 <lambdabot>  (1,2)
05:17:48 <spatial> sum (map (2^) xloc)                        + sum [2^n | n <- (addVal 512 oloc)]
05:19:11 <spatial> xloc and oloc are lists. Assume they have Int '1' each. Do I use the highter order 8 bits for the first 1 and lower order 8 bits for the other 1 ?
05:19:45 <spatial> Lower order and higher order.
05:21:10 <spatial> I mean this result 00000001 00000001
05:22:27 <spatial> addVal i (x:xs) = x * 512: addVal i xs  
05:26:37 <spatial> If someone knows lisp then I can show lisp and my haskell conversion.
05:27:47 <quchen> > let f(a,b)|b<a=(b,a);f x=x in f (2,1) -- Any shorter solutions to klottie’s problem? :-)
05:27:49 <lambdabot>  (1,2)
05:30:49 <eatman> Hey, what type has a # kind?
05:30:59 <quchen> 1#
05:31:02 <quchen> Eh, Int#
05:31:11 <quchen> That is, unboxed types
05:32:12 <eatman> > :k Int
05:32:14 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:32:24 <quchen> :k Int
05:32:25 <eatman> Anyway, this gives me *
05:32:26 <lambdabot> *
05:32:38 <eatman> Not #
05:32:38 <quchen> »Int#« has kind #.
05:32:42 <quchen> Int has kind *.
05:32:44 <eatman> :k Int#
05:32:45 <lambdabot> error:
05:32:46 <lambdabot>     Not in scope: type constructor or class ‘Int#’
05:32:46 <lambdabot>     Perhaps you meant one of these:
05:33:40 <eatman> To be faire I don't know what "unboxed" means (damn second language :-()
05:34:20 <quchen> data Int = I Int#
05:34:57 <quchen> »I« is the constructor that takes the primitive (as in lies-in-your-ram-directly-just-as-in-C) value, and puts it in a box.
05:35:06 <quchen> The Int can be lazy, the Int# is always fully forced.
05:35:30 <quchen> Unboxed type basically means you can’t have thunks of that type.
05:35:50 <kuribas> > > let f=over (partsOf each) sort in f(2, 1) -- quchen 
05:35:52 <lambdabot>  <hint>:1:1: error: parse error on input ‘>’
05:35:53 <kuribas> > let f=over (partsOf each) sort in f(2, 1) -- quchen 
05:35:56 <lambdabot>  (1,2)
05:36:19 <kuribas> quchen: seems to be longer...
05:36:51 <quchen> kuribas: Invoke the power of Lens obfuscation!
05:36:52 <quchen> > let f=partsOf each%~sort in f(2, 1)
05:36:55 <lambdabot>  (1,2)
05:37:09 <quchen> > let f(a,b)|b<a=(b,a);f x=x in f (2,1)
05:37:11 <lambdabot>  (1,2)
05:37:11 <quchen> You win :-)
05:37:39 <kuribas> yay!
05:38:06 <eatman> I bet it will be crystal clear in a few days of proactice.
05:38:23 <kuribas> eatman: don't use that though
05:39:58 <kuribas> spatial: bring on the lisp :)
05:40:36 <Alex_____> Hello, what's up
05:43:44 <mofasa> When I do 'stack setup' to install GHC, it gets to "Installing GHC ... " but just stops. Nothing happens after 30 minutes.
05:44:15 <kuribas> spatial: also, your quest is very vague.
05:44:21 <kuribas> spatial: question
05:45:28 <spatial> kuribas:http://lpaste.net/354360
05:47:22 <kuribas> spatial: why mix map and list comprehension?
05:49:01 <spatial> kuribas: Can't justify. Now I have doubt about the logic itself. Tried to print binary.
05:50:08 <spatial> kuribas: The second loop if lisp multiplies by 512. Believe it tries to use 8 higher order bit and 8 lower order.
05:50:55 <spatial> kuribas:Raising to the power of 2 shift bits..
05:51:10 <spatial> shifts bits to the left.
05:51:35 <quchen> Multiplying with 2 shifts bits.
05:52:32 <spatial> Yes
05:52:51 <ski> > map (shift 1) [0 .. 8]
05:52:53 <lambdabot>  [1,2,4,8,16,32,64,128,256]
05:53:18 <kuribas> spatial: what's the question?
05:54:36 <spatial> kuribas: What exactly is lisp doing ? Does it use the first 8 bits for list 1 and next 8 for list 2 ?
05:54:57 <merijn> eatman: Do you happen to know Java?
05:55:12 <kuribas> spatial: wouldn't that be a question for #lisp?
05:55:26 <merijn> (Or maybe C#? I don't, but I think it's similar enough to Java to help my explanation)
05:56:00 <ski> spatial : could you annotate the paste with `addVal' ?
05:56:55 <spatial> ski:Done
05:57:52 <spatial> kuribas: I can try lisp forum.
05:57:53 <ski> hm, so `addVal i xs = map (* 512) xs' (`i' is unused)
05:58:14 <kuribas> spatial: why not sum [512 * 2^n | ...
05:58:49 <kuribas> or better sum [2^(n+8)]
05:58:52 <spatial> ski: Mistake.
05:58:53 <ski> `2^(x * 512)' is probably not what you want to do in the Haskell code, right
05:59:40 <ski> the common lisp code multiplies with `512' after summing .. any reason not to do that in the Haskell version ?
06:00:12 <spatial> ski: That is what I spotted. Another mistake.
06:00:46 <ski> spatial : could you confirm the bounds of `i' that `(loop for i below 9 ...)' gives you. is it `0' to `8', inclusive-inclusive ?
06:00:50 <kuribas> also why make an array instead of using 2^n directly, or shift.
06:01:34 <kuribas> in the lisp code
06:02:55 <spatial> ski: Think 0 to 8
06:03:08 <ski> ok
06:03:09 <ski> `X-locations' and `Y-locations' will only contain integers between `1' and `9', inclusive-inclusive ?
06:03:16 <brynedwards> mofasa: try `stack -v setup`
06:03:25 <sphinxo> Best way to accumulate errors? for say typechecking an ast?
06:03:31 <spatial> ski: 1 to 9
06:03:36 <ski> right
06:04:27 <ski> if you wanted to, you could make an array in Haskell, with indices from `1' to `9' .. `listArray (1,9) [2 ^ i | i <- [1 .. 9]]'
06:04:29 <peddie> sphinxo: validation applicative?
06:04:52 <Geekingfrog> sphinxo: there is the either package (from kmett) on hackage
06:05:18 <merijn> sphinxo: Validation applicative (I recommend the either package)
06:05:20 <Geekingfrog> sphinxo: it's a bit like Either e a with a monoid constraint on e and it will accumulate the errors
06:06:02 <Alex_____> Anyone here who got time to look at a problem of mine? (some instance declaration error)
06:06:38 <mofasa> Alex_____, pastebin it
06:06:40 <ski> spatial : so .. anything more you're wondering about ?
06:06:49 <ski> @paste
06:06:49 <lambdabot> Haskell pastebin: http://lpaste.net/
06:07:29 <quchen> data Validation e a = Error e | Success a; instance Applicative Semigroup e => Applicative (Validation e) where pure = Success; Error e <*> Error e' = Error (e <> e'); Success f <*> Success x = Success (f x); Error e <*> _ = Error e; _ <*> Error e = Error e
06:07:38 <quchen> sphinxo: ^
06:07:49 <merijn> quchen: Yeah, that's the one from edwardk's either.
06:08:08 <merijn> quchen: Sadly mixing ExceptT/EitherT and Validation is really annoying >.>
06:08:18 <quchen> Edward’s version is so general I usually roll my own :-/
06:08:31 <spatial> ski: Could you elaborate ?
06:08:33 <Alex_____> mofasa: To you in private or..? I don't want to disturb already ongoing conversations ^^
06:08:39 <mofasa> just here
06:08:58 <stphrolland> Hi, in a few words, why use Pipes.Network.TCP.Safe instead of Pipes.Network.TCP. In which way is it safer ? 
06:09:11 <merijn> sphinxo: I ended up using Except for my type checker and writing a custom "checkMany :: Foldable f => (a -> TC ()) -> f a -> TC ()" that replaces Except with Validation to accumulate errors
06:09:28 <stphrolland> I don't know either ones yet. I'm starting a dummy project to start learning it so as to use it, and I wonder which one is best.
06:09:52 <ski> spatial : just wondering whether you're ok now, or would like more help ..
06:10:33 <Geekingfrog> merijn: What is TC there ?
06:10:35 <spatial> ski:sum (map (2^) xloc)                        + ( 512 * sum [2^n | n <- oloc] )
06:10:37 <ski> Alex_____ : just ask in the channel. if need be, address specific nicks like this
06:10:48 <ski> spatial : sounds like a plan
06:10:52 <merijn> Geekingfrog: ReaderT Environment (Except [Doc])
06:11:00 <ski> <kuribas> spatial: why mix map and list comprehension?
06:11:05 <merijn> Geekingfrog: So just environment of bindings over Except (i.e. EitherT)
06:11:52 <spatial> ski: I am not an advanced haskell coder. Just trying the logic. Whatever works first.
06:12:00 <ski> spatial : otoh .. i need to leave now. perhaps someone else can help you more, if need be. good luck
06:12:06 <merijn> Geekingfrog: And then internally I have "toValidation :: ReaderT r (Except e) a -> ReaderT r (Validation e) a" and "fromValidation :: ReaderT r (Validation e) a -> ReaderT r (Except e) a"
06:12:19 <merijn> Geekingfrog: and do "checkMany fun = fromValidation . traverse_ (toValidation . fun)"
06:12:45 <Geekingfrog> merijn: is Except e = ExceptT e Identity ?
06:12:57 <ski> spatial : oh, and the brackets around the multiplication there are redundant
06:13:18 <spatial> ski: Sure.
06:13:26 <merijn> Geekingfrog: It's a newtype for Either (or ExceptT e Identity)
06:14:19 <Geekingfrog> Ok, I think I get what you did. I had a similar problem recently, but it was small enough that I could get away with validationToEither
06:14:23 <merijn> Geekingfrog: Because for typechecking I often want to use do notation to "first typecheck this, then that if you don't have an error", but if you want to typecheck, say, a Foldable of bindings you want to aggregate the error for each binding :)
06:14:55 <Geekingfrog> merijn: there was a really interesting talk at a london haskell meetup recently about exactly that, how to get better error messages
06:15:00 <Geekingfrog> (from compilers)
06:19:32 <stphrolland> not sure one seen my question. Is it ok using Pipes.Network.TCP, or Pipes.Network.TCP.Safe is really advised ?
06:20:07 <stphrolland> i'm starting learning the pipes ecosystem for network use, and wonder which one to start with.
06:21:57 <merijn> stphrolland: the Safe module makes sure the socket is closed when your pipeline terminates
06:22:24 <stphrolland> ok so it's busy with managing memory leaks and the likes ?
06:22:40 <merijn> stphrolland: Well, not so much memory leaks as "socket leaks", but yes
06:22:47 <merijn> I would recommend using the Safe module
06:22:57 <merijn> That way you don't have to do that yourself
06:23:17 <stphrolland> thanks. again thanks for you MyStateT exercise and guidance, it's been a real improvement in my understanding.
06:23:21 <Alex_____> Okay, I hope I gave enough information for anyone to understand my problem and I am thankful for any help ^^ https://pastebin.com/pECPXRYk
06:23:35 <merijn> stphrolland: Did you work it out with the hints? :)
06:23:41 <stphrolland> yep
06:23:45 <merijn> good :)
06:24:26 <merijn> Alex_____: Line 53
06:24:38 <merijn> Alex_____: You're implementing Weight for [Char], not Char
06:28:16 <Alex_____> merijn: But if I want to be able to have 'abc' as a Weight, don't I need to use [Char] and not Char
06:28:48 <merijn> Alex_____: You're trying to use Char, as indicated by the error, which says "No instance Weight Char"
06:28:56 <merijn> Also, 'abc' is a syntax error
06:29:08 <merijn> "abc" is a String (i.e. [Char])
06:29:20 <merijn> 'c', like you're inserting in the graph, is a Char
06:30:59 <Alex_____> merijn: I thought I could use [Char] for 'a' and for 'ab', do I need to use Char specifically for 'a' and [Char] for 'ab'?
06:31:15 <merijn> Alex_____: 'ab' is a syntax error
06:32:27 <Alex_____> merijn: Sorry, this is my first program in Haskell. What is the correct way to represent a string? "ab" ?
06:32:35 <merijn> "ab" is a String, yes
06:32:59 <merijn> Which is the same thing as [Char]
06:33:22 <merijn> So you can keep your [Char] instance and change all the Chars in your code to be strings if that's what you want
06:36:08 <Alex_____> merijn: Hmm, I changed the weights to "a" "b" etc but then I get a similar error but it says "No instnace for (Num [Char]) instead
06:36:45 <merijn> Alex_____: Hard to say what's going without knowing the types of things
06:48:22 <mofasa> Alex_____: longestPath relies on 'a' being a num instance. Char has a num instance, but [Char] does not. Either you have to make a Num [Char] instance that makes sense for your program or you have to change the type signature (and probably implementation) of longestPath
06:59:49 <Alex_____> mofasa: Okay, I thought I try make it work with only Char first so I changed the type to that. Do you know how to add the Char's? Since I used '++' when having [Char] and it doesn't work for Char 
07:00:07 <merijn> Well, what does adding Char's mean?
07:00:16 <mofasa> Alex_____, Depends on what adding chars mean
07:00:47 <mofasa> Alex_____, If you mean adding 'a' + 'b' to "ab" then that's not possible while keeping the result as char because it's [Char]
07:02:31 <Alex_____> mofasa: Would it be possible to add the value of the Char's?
07:03:12 <mofasa> Alex_____, Yes, convert char to int with 'ord' then sum them, then back to char with 'chr'
07:06:16 <giovaevale89> ciao
07:06:50 <shapr> howdy
07:07:45 <giovaevale89> !ciao
07:08:04 <Alex_____> mofasa: Okay, think I'll try to make it work with strings somehow
07:08:18 <mofasa> Alex_____, When you have questions like that using hoogle is very useful because you can search for type signatures, e.g. "Char -> Int" for finding a way of converting a CHar to an Int
07:09:08 <giovaevale89> !list
07:10:46 <Alex_____> mofasa: Ah okay, thanks :)
07:21:33 <Sornaensis> @hoogle f -> g -> f
07:21:33 <lambdabot> Prelude const :: a -> b -> a
07:21:33 <lambdabot> Data.Function const :: a -> b -> a
07:21:33 <lambdabot> CorePrelude const :: a -> b -> a
07:29:11 <Sornaensis> @hoogle (Ord a, Enum b) => a -> b -> a
07:29:12 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:29:12 <lambdabot> CorePrelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:29:12 <lambdabot> Intro enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:29:25 <Sornaensis> @hoogle (Ord a, Enum b) => a -> a -> b
07:29:26 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:29:26 <lambdabot> CorePrelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:29:26 <lambdabot> Intro enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:30:58 <merijn> so: Please use /msg to query lambdabot
07:31:07 <merijn> s/so:/Sornaensis:/
07:32:33 <mtesseract> Hi. I'm playing around with -XDataKinds. Is there any way to have a record data constructor being promoted to the type level in a way that allows referencing its fields by name? e.g., when I have "data Foo = F { field :: Nat }", this makes "F 0" be a valid type (of kind Foo), but not "F { field = 0 }". I think for my application I need the constructor to hold at least seven values — referencing them 
07:32:40 <mtesseract> simply by order seems error prone.
07:33:00 <merijn> mtesseract: Not really
07:33:21 <merijn> mtesseract: Honestly, if you find yourself wanting complex stuff using DataKinds, you might want to have a look at Idris
07:36:11 <mtesseract> merijn: :-) Probably. At least for experimenting with it and gaining experience with that level of type programming. I am currently trying to implement a Haskell library for modelling physical quantities with their units at the type level. I have something working already for length, time and mass. But according to wikipedia there are nine (I was wrong with the seven, it seems) base units. :-)
07:36:13 <lyxia> mtesseract: how about data Foo = F Field ; data Field = Field Nat
07:37:21 <mtesseract> (I meant "dimensions" — but they seem to be with 1:1 correspondence with base units)
07:37:55 <merijn> mtesseract: There's a reason why the paper on "dependent" Haskell is called Hasochism :)
07:38:10 <mtesseract> lyxia: Hmmm, that might be a workaround.
07:38:20 <merijn> mtesseract: Yeah, that's the kinda thing that would be such less hassle in Idris
07:38:34 <merijn> mtesseract: Honestly, Haskell is kinda terrible at type level programming
07:39:00 <Lokathor> really unfortunate that Num requires a -> a -> a for the math operators
07:39:05 <merijn> mtesseract: Switching to Idris or Agda will just make you go "oh...wait, this is actually kinda simple..."
07:39:13 <Lokathor> when you're trying to do things like Length * Length -> Area
07:39:19 <mtesseract> merijn: I'm not particularly fond of it either.
07:39:27 <mtesseract> Lokathor: yes.
07:39:41 <mtesseract> mult :: Qty unit -> Qty unit' -> Qty (Mult unit unit')
07:39:48 <mtesseract> This is my multiplication function.
07:39:52 <Lokathor> huh
07:40:32 <Lokathor> I did a demo of such a thing in rust without special types, because in rust the Mul trait defaults to RHS = Self, but you can make the RHS be other things as well
07:40:39 <mniip> 1491489519 [17:38:39] <Lokathor> really unfortunate that Num requires a -> a -> a for the math operators
07:41:12 <mniip> class Num a b c d e f g h i j
07:41:19 <mniip> where (+) :: a -> b -> c
07:41:24 <mniip> (*) :: d -> e -> f
07:41:25 <mtesseract> Lokathor: I see
07:42:18 <Lokathor> mniip, doesn't that clash with Num's definitions?
07:42:25 <mniip> sure dos
07:42:26 <mniip> does
07:42:34 <Lokathor> well :/
07:42:47 <lyxia> I detected sarcasm
07:43:10 <mtesseract> As an example, the term second "second `mult` second" has type "Qty ('Dim 'LIntZero ('LInt 'Plus ('S 'PosNatOne)) 'LIntZero)", which means it is a quantity whose first and third dimensions (length and mass) are the lifted integer zero, while the second dimension (time) is the lifted integer two => thus, it's time squared. :-)
07:43:18 <mtesseract> But it is not particularly nice.
07:47:36 <Lokathor> lyxia, i wasn't being sarcastic, if that's what you mean
07:49:23 <lyxia> I meant mniip.
07:50:14 <lyxia> Lokathor: how much of a problem is clashing with Num if your Num is more general
07:50:45 <Lokathor> i figured that ghc would complain about a conflicting definition
07:53:00 <heari> hi guys 
07:56:57 <lyxia> You can always hide it. But you will need to reimplement the whole ecosystem.
08:15:40 <lambdafan> I remember seeing something on reddit about the downsides of the Prompt monad, but I can't find it. Anyone have a link?
08:16:10 <Philonous> What was the extension that allowed me to pass type arguments to functions?  e.g. id @Int 
08:16:29 <Boomerang> TypeApplications
08:16:43 <Philonous> Thanks
08:50:30 <sphinxo> https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Validation.html vs https://hackage.haskell.org/package/validation ?
08:51:46 <Iceland_jack> sphinxo: alternatively, https://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Applicative-Lift.html
08:51:46 <Iceland_jack> ;)
08:52:09 <sphinxo> How would that work Iceland_jack ?
08:52:24 <sphinxo> oh wait
08:52:31 <Iceland_jack> Lift (Const e) does what you want
08:53:06 <Iceland_jack> Monoid m => Applicative (Lift (Const e))
08:53:12 <sphinxo> oh that's really awesome
08:56:33 <mniip> is the 's -> (m a, s)' StateT a monad?
08:59:10 <Iceland_jack> sphinxo: If you inline 'Const' into the definition you get: data LiftConst e a = Pure a | Other e
08:59:16 <Iceland_jack> which, surprise!, is Either
09:10:35 <sphinxo> Iceland_jack: so how best should I actually use this when checking an ast
09:15:42 <mniip> hmm
09:15:51 <mniip> a lazy insertion sort is just a selection sort
09:17:48 <leshow> What is <*> called, like, if one was going to say it outloud?
09:18:03 <Alex_____> star or asterix?
09:18:36 <barrucadu> "ap", as it's (supposed to be) the same as the `ap` function when your Applicative is also a Monad
09:20:59 <leshow> barrucadu, that works
09:21:03 <leshow> I was calling it mr pointy
09:21:48 * ski . o O ( "selection sort = insertion sort" by Graham Hutton at <https://www.youtube.com/watch?v=pcJHkWwjNl4> )
09:21:51 <mniip> hey dfeuer
09:22:13 <dfeuer> Hey mniip.
09:22:15 <mniip> wrt the sorting of Traversable contains
09:22:30 <dfeuer> Yah? Is there some cool article I should read?
09:22:44 <mniip> why do you need such a complex Sort datatype?
09:22:49 <mniip> wouldn't Compose State State suffice
09:22:57 <cobreadmonster> man.
09:23:11 <cobreadmonster> I can't figure out how to parse complex languages.
09:23:45 <dfeuer> mniip: explain? Also, is that actually simpler than    Product (State Heap) (Const Heap)?
09:23:57 <ertes> cobreadmonster: there is an MMORPG where people will write the code for you in exchange for XP
09:24:02 <ertes> it's called stackoverflow
09:24:36 <leshow> Is there a way to add a git repo as a dependency to a stack project
09:25:33 <cobreadmonster> ertes: Can I steal that?
09:26:34 <Alex_____> A bit of a newbie question from a newbie like me https://pastebin.com/kfVV3mN0
09:26:51 <sm> leshow: yup, it's in the manual
09:26:53 <ertes> cobreadmonster: the code generation algorithm?  go ahead
09:27:07 <dfeuer> mniip?
09:27:11 <mniip> one moment
09:27:18 <Boomerang> leshow: take a look at https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md
09:28:06 <ertes> Alex_____: as a beginner use pattern-matching instead of the 'head' function
09:28:37 <dfeuer> As an advanced user, also use pattern-matching instead of the head function.
09:28:50 <ertes> as an advanced user you can use foldr =)
09:29:17 <dfeuer> I believe the only good uses I've seen for the head and tail functions are in the implementation of MonadFix []. Which means they should be defined as helpers there.
09:29:46 <leshow> Boomerang, I did look in there. it says to add a location: git: ... commit: ... under packages, Ive done that and stack says "external packages should typically be treated as extra-deps to avoid spurious test case failures."
09:30:05 <dfeuer> You can also use tail for processing the results of scanl, but that's because scanl is wrong :-(
09:30:09 <leshow> No extra-dep setting found for package at URL <..>.git
09:30:11 <Alex_____> ertes: Yeah, that's what I googled myself to ^^ But if I do that, won't I have to make sure that (x:xs) isnt empty as well?
09:30:26 <ertes> Alex_____: no, you need to handle the empty case
09:30:53 <ertes> that's why 'head' should rarely be used
09:31:17 <Boomerang> leshow: I believe you can add "extra-dep: true" under the location of that package, next to the git and commit
09:31:24 <dfeuer> x:xs is certainly never empty.
09:32:14 <Alex_____> Ah okay, thanks guys
09:32:33 <leshow> Boomerang, oh I see. I thought it was telling me to change the extra-deps: [] entry to true
09:32:55 <leshow> what is the purpose of the cabal file and the yaml file? why not just one file?
09:33:22 <Boomerang> leshow: I think adding "extra-dep: true" to the package location is the same as adding the package name to the list of extra-deps
09:34:13 <Boomerang> I think stack didn't want to reinvent cabal so it just uses it.
09:34:27 <lpaste> mniip pasted “Traversable sort” at http://lpaste.net/354367
09:34:28 <mniip> dfeuer: ^
09:34:52 <leshow> Boomerang, after the git repo is in the YAML file, the name of the package should also be added to the cabal file?
09:35:45 <Boomerang> leshow: yes! While it might work without (because the package is in the context) your cabal file should definitely reflect the exact dependencies needed
09:37:07 <Sornaensis> surprise dependencies are the bane of my existence
09:37:25 <leshow> Boomerang, thanks for your help
09:37:38 <dfeuer> mniip: how's that going to be easier when trying to use a size-indexed heap to avoid the partial match in pop?
09:38:12 <dfeuer> Maybe it will be; I don't know.
09:39:28 <mniip> ah so that's the point?
09:40:03 <dfeuer> Yes, the idea is to make it as "obviously total" as possible, which was the challenge Will Fancher set out.
09:40:34 <dfeuer> You should also look at his blog post and see if you think the approach he took could go anywhere interesting.
09:40:47 <dfeuer> I have my doubts, but this whole thing is a bit weird.
09:43:12 <dfeuer> mniip: next-level challenge: find a way to do this efficiently in Safe Haskell. Some pieces seem likely to be doable with a binomial heap, but other bits seem tricky, so we'll see. We have O(log n) time per element we can use to run proofs if we like.
09:43:31 <dfeuer> But proving things about binary numbers is tricky.
09:45:10 <dfeuer> Everything has to be by structural induction to get the efficiency, which really limits proof options.
09:46:43 <mniip> can I use Data.Void?
09:46:55 <mniip> e.g absurd to avoid partiality
09:50:30 <mniip> you need to somehow get a result of shape
09:50:44 <mniip> f a -> Either (f Void) (NonEmpty a)
09:53:22 <mniip> dfeuer, this reminds me of FreeT (Reader t)
09:53:36 <mniip> Free (Reader r) rather
09:53:53 <dfeuer> mniip: you can certainly use Void. What's Free (Reader r) get you exactly?
09:54:22 <dfeuer> Pure a | Free (Reader r (Free (Reader r) a))?
09:54:27 <benzrf> Free (Reader r) is a fold, right
09:54:40 <mniip> yes
09:54:53 <dfeuer> Pure a | Free (r -> Free (Reader r) a) ?
09:55:10 <mniip> yes
09:55:28 <mniip> just a thought
09:55:29 <dfeuer> I guess the free Applicative is reminiscent of that, but certainly not the same.
10:03:34 <itachi> is there anyway to find nth element in a list using fold?
10:04:00 <glguy> :t fold -- this one specifically?
10:04:02 <lambdabot> (Monoid m, Foldable t) => t m -> m
10:04:36 <itachi> foldl foldr are also fine
10:04:43 <itachi> : foldr
10:04:48 <itachi> :t foldr
10:04:49 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:04:50 <glguy> You can do it with any of them
10:05:18 <itachi> How?
10:05:34 <glguy> foldr would be the best to start with
10:06:05 <ertes> itachi: http://ertes.eu/tutorial/foldr.html#stateful-folds
10:06:07 <ski> `foldl' wouldn't work on an infinite list
10:06:40 <itachi> I know how to find the last element but was wondering about how to find a element in the middle
10:07:03 <Boomerang> > let find n = snd . foldl' (\(i, m) x -> (i + 1, if i == n then Just x else m)) (0, Nothing) in (find 3 [0,1], find 3 [0..10])
10:07:05 <lambdabot>  (Nothing,Just 3)
10:07:42 <Boomerang> But that goes through the whole list, so not very good
10:08:19 * ski isn't sure whether itachi is looking for a solution, or just want to know whether there is one
10:08:22 <Boomerang> Also "find" is a poor name, I should have thought that through a bit more
10:08:27 <ertes> foldl* is wrong
10:08:29 <itachi> finding element is O(n) in haskell right?
10:08:34 <ertes> you need fold or foldr
10:08:45 <ertes> itachi: yes
10:08:51 <geekosaur> for a linked list type, yes, O(n)
10:08:54 <ski> indexing into a single-linked list is linear in any language
10:09:05 <itachi> yup
10:09:20 <ertes> itachi: it can be O(1) in space for lazy lists, but it's always O(n) in time
10:09:38 <itachi> lazy lists?
10:09:56 <ertes> itachi: iterate f s0 !! n  -- O(1) space
10:10:19 <itachi> k
10:10:29 <ertes> at least in terms of the number of list elements in memory
10:10:34 <ertes> the elements themselves might still grow
10:13:12 <ski> @hoogle iterate'
10:13:13 <lambdabot> Agda.Utils.Function iterate' :: Integral i => i -> (a -> a) -> a -> a
10:15:40 <itachi> Thanks
10:17:09 <cobreadmonster> Is Agda on topic here?
10:25:27 <dylukes> Any suggestions on best practices for working with GLFW/OpenGL within ghci under stack?
10:25:52 <dylukes> Can't acquire a window on OS X because OS X requires that various things obtained by GLFW be on the main thread.
10:26:21 <dylukes> Clearly Stack is in some way running ghci on a non-main thread.
10:27:04 <dylukes> Any way to pass -fno-ghci-sandbox to `stack repl'?
10:28:37 <dylukes> Seems like `stack repl --ghc-options="-fno-ghci-sandbox"' works as intended, nevermind haha.
10:28:41 <dylukes> ghci-options*
10:33:30 <cocreature> dylukes: I didn’t know about -fno-ghci-sanbbox, thanks! I’m sure that’ll come in handy at some point
11:03:40 <ph88^> when i do a readfile "myFile"  does that load from the current working directory or the application dir ?
11:04:16 <joe9> Just want to check if anyone uses Language.C library to check for missing free() calls in C programs?
11:04:18 <ertes> ph88^: current
11:04:35 <ertes> ph88^: would be pretty weird if otherwise
11:05:04 <Apocalisp> In a free monad (or extensible effects) type of program, I might want to have an algebra to record the time a portion of my program takes. A simple marker won't do, since it would mark the entire continuation of the program, but I want to mark a _delimited_ continuation of the program. How do people solve this in general?
11:06:34 <ertes> Apocalisp: the easy way would be to add a command to get the current time
11:08:27 <ertes> Apocalisp: the ugly way would be to embed a whole action, but then the effect functor is no longer agnostic to the free monad implemention, unless it uses RankNTypes
11:08:55 <Apocalisp> you mean rely on something like `MonadFree`?
11:10:21 <Apocalisp> The same kind of problem comes up in supervision and concurrency problems
11:11:26 <ertes> Apocalisp: in general in the effect functor you can only work with "futures"
11:12:11 <ertes> WithStats :: (Stats -> a -> x) -> (forall m. (MonadFree MyF m) => m a) -> MyF x
11:13:28 <ertesx> <ertes> Apocalisp: in general in the effect functor you can only work with "futures"
11:13:31 <ertesx> <ertes> WithStats :: (Stats -> a -> x) -> (forall m. (MonadFree MyF m) => m a) -> MyF x
11:13:33 <ertesx> <ertes> it's ugly, but i don't think there is another way to delimit
11:14:09 <Apocalisp> what's `Stats` here?
11:14:38 <ertesx> anything you want
11:14:44 <ertesx> timing info, memory, etc.
11:15:45 <Apocalisp> right on
11:16:56 <ertes> Apocalisp: but if Stats is a group, it's probably better to just introduce a GetStats command
11:17:06 <ertes> GetStats :: (Stats -> x) -> MyF x
11:17:30 <ertes> do t0 <- getStats; c; t1 <- getStats; let { dt = t1 - t0 }; …
11:18:05 <ertes> you can easily build a function to encapsulate this pattern:  withStats :: (MonadFree MyF m) => m a -> m (Stats, a)
11:20:25 <Jello_Raptor> hmm, things like modifyMVar' only get the MVar to weak head normal form right? if there's a datastructure, it can still have unforced thunks in it? 
11:20:46 <cocreature> Jello_Raptor: yep
11:20:50 <Jello_Raptor> cool
11:21:25 <ertes> Jello_Raptor: you can tell from the type signature
11:21:55 <ertes> there are no constraints on the content type, so modifyMVar' couldn't evaluate further, even if it wanted to
11:22:11 <cocreature> Jello_Raptor: if you really want to force evaluation to normal form use the deepseq package. but most of the time there are better solutions
11:22:46 <Jello_Raptor> right, I don't want any further evaluation, just don't want a stack of function application thunks building up
11:23:20 <Jello_Raptor> which modifyMVar' takes care of
11:34:45 <ph88^> what can i use to validate configuration files? 
11:35:35 <ph88^> when i use php i would use this component https://symfony.com/doc/current/components/config.html
11:43:38 <sophiag> could someone familiar with haskell-src-exts help me figure out a case analysis of some (relatively) simple ASTs? here's the code: http://lpaste.net/354370
11:45:59 <lyxia> sophiag: you're using App sometimes as a binary constructor, sometimes as a ternary one
11:46:41 <sophiag> i've tried wrapping it in parens, but that doesn't help
11:46:50 <lyxia> sophiag: http://hackage.haskell.org/package/haskell-src-exts-1.19.1/docs/Language-Haskell-Exts-Syntax.html#t:Exp
11:46:55 <michalrus> Hey, how can I run `cabal repl` but without loading/building the project?
11:47:25 <lyxia> sophiag: you're also missing the location field in all of these patterns.
11:48:26 <sophiag> lyxia: i'm unsure what you mean and i've read through the docs. if i parse just a string of one word it returns "App (Var (UnQual (Ident "foo")))"
11:48:48 <sophiag> i'm not confused about the types, but rather how to match for them
11:52:13 <sophiag> lyxia: parsing "amb foo [1,2,3" returns "App (App (Var (UnQual (Ident "amb"))) (Var (UnQual (Ident "foo")))) (List [Lit (Int 1),Lit (Int 2),Lit (Int 3)])"
11:52:20 <lyxia> sophiag: App is a constructor, and the docs show it has three fields.
11:52:39 <sophiag> notice how the ast returns includes a close paren where there is no open one...
11:52:41 <lyxia> sophiag: or are you perhaps using an older version
11:53:14 <lyxia> where do you see a close paren where there shouldn't be?
11:53:23 <sophiag> is import Language.Haskell.Exts.Syntax the newest version?
11:53:52 <lyxia> that's now where you look for the version of the package you are using
11:54:12 <sophiag> lyxia: in the example i posted it's the 7th close paren
11:54:54 <lyxia> it's matched with the 1st open parenthesis
11:55:20 <lyxia> "amb foo [1,2,3]" is parsed as two applications. (amb foo) [1,2,3]
11:55:52 <sophiag> oh sorry i was confused by the two Apps
11:57:14 <sophiag> and also if i do use parens around App in the case analysis it gives me a parse error
11:57:51 <sophiag> hence, back to my original question: clearly i cannot parse asts in the form match for ASTs in the form they're parsed. so how do i?
11:58:19 <lyxia> App (App (Var (UnQual (Ident "amb"))) (Var (UnQual (Ident "foo")))) (List list)
11:58:24 <lyxia> show me your error
11:58:28 <lyxia> and the code of course
11:59:04 <sophiag> hold on i'm editing it to use your version with two apps
11:59:39 <lyxia> You *must* use two App to match on two applications...
12:00:26 <lyxia> since a b c gets parsed to App (App a b) c
12:06:16 <merijn> bleh, why do I always manage to write projects that get blocked on issues with other packages, leading to the "fun" "try to get upstream fixed" dance of open source >.<
12:07:47 <merijn> Especially since I always seem to pick upstream projects with overloaded/busy maintainers >.>
12:18:43 <sophiag> lyxia: sorry for the delay (in an office where i'm the only programmer so keep getting distracted...). i think the matches are working now and i'm just dealing with an unrelated issue on the rhs. thanks for the help :)
12:31:20 <maerwald> merijn: fork everything
12:31:38 <merijn> maerwald: That's...not convenient if I want people to use my stuff :p
12:32:13 <maerwald> well, even with a "simple" haskell project I had to fork 3 libraries, and was able to drop one fork after half a year
12:32:16 <merijn> I managed to get a whole bunch of useful fixes into xml-conduit, now it's time to see if I can manage to both fix criterion and get the stuff merged by bos. Which is tricky, since he's so busy
12:32:19 <maerwald> the other I still have to maintain
12:32:40 <bitemyapp> hmm yeah
12:32:54 <bitemyapp> It's pretty hard to do something substantive in Haskell without patching the odd library
12:33:10 <bitemyapp> this is partly why I don't feel bad asking to see a Github if someone says they've used Haskell for work
12:33:15 <merijn> bitemyapp: OTOH, I believe in the compound awesomeness of incremental fixes
12:33:53 <merijn> bitemyapp: My real issue isn't needing to patch/fix libraries, but rather being in unresponsive limbo wrt your patch actually ever getting merged
12:34:51 <merijn> I understand that bos has a metric crapton of projects he has to maintain/support and likes a personal live too, but given how critical some of his stuff is to the ecosystem I wish there'd be more maintainers to increase responsiveness
12:35:08 <maerwald> "Github"... "for work"...? errm?
12:35:23 <cocreature> merijn: you’re not the only one https://github.com/bos/criterion/issues/133
12:35:36 <merijn> cocreature: Yeah, I saw that
12:36:03 <reactormonk[m]> merijn: got some patch merged within 4 days on a smaller project, can't complain
12:36:27 <merijn> cocreature: But that still doesn't unblock my current work :) I'm trying to fix/patch criterion locally and then I'll just use a sandbox for now
12:37:31 <cocreature> merijn: it’s really easy. you just need to hard fork and get everyone to switch over to your fork.
12:37:59 <merijn> cocreature: And then maintain that hard fork >.>
12:38:16 <cocreature> merijn: then you are the shitty maintainer that doesn’t respond to PRs :)
12:38:36 <merijn> cocreature: Then slowly become as influential as bos, get overloaded with work, and perpetuate the cycle... :p
12:38:44 <cocreature> exactly :)
12:39:12 <merijn> cocreature: Like I said, I don't think he's a shitty maintainer, I just think that extremely crucial/central packages need more than a single person taking care of things to avoid this
12:39:29 <leshow> When combining monad transformers, I'm confused at how they are combined. For example, StateT takes 3 types variables, s m a, ReaderT takes 3 type variables r m a. Howver when combined I end up with something like
12:39:41 <leshow> ReaderT Config (StateT Game IO)
12:39:52 <leshow> where is the third type variable to ReaderT? why is that valid?
12:40:05 <merijn> leshow: It's a partially applied type
12:40:14 <merijn> leshow: ReaderT still needs another argument
12:40:24 <leshow> oh i see
12:40:28 <cocreature> merijn: yeah I wasn’t referring to him specifically. but I think expecting people to add maintainers if they become unresponsive and the package is used heavily is not that much to ask
12:40:36 <sbrg_> if you had `type MyType = ReaderT Config (StateT Game IO)` you would be using this type as `foo :: MyType ()`
12:40:37 <leshow> merijn, I'm not crazy then that's good
12:40:41 <sbrg_> or `MyType a`
12:41:05 <merijn> cocreature: And now my cat is trying to sabotage my patching attempts >.<
12:41:22 <ph88^> how can i validate a toml file ?
12:41:28 <cocreature> merijn: punish your cat by making it the maintainer of your fork of criterion
12:42:27 <merijn> cocreature: I think she'd just kick my laptop of my lap in revenge...
12:42:39 <merijn> For as far as she isn't currently already doing that...
12:42:52 <bennofs> there is a criterion fork=
12:43:10 <merijn> bennofs: Where? And fixing what?
12:43:44 <bennofs> merijn: yeah idk where and what but cocreature said there is?
12:44:00 <merijn> bennofs: No, he was suggesting I make one
12:44:04 <bennofs> oh
12:44:14 <merijn> As a joke too :p
12:44:15 <bennofs> that's what I get for only reading a single line
12:45:04 <jgt> Jello_Raptor: are you French?
12:46:24 <merijn> cocreature: Thanks to the amazing Haskell type system, this might actually end up being a simple change </famous last words>
12:48:19 <merijn> cocreature: Maybe bos should just follow edwardk's lead and just give everyone that gets a PR merged commit access to the repo :p
12:48:42 <cocreature> merijn: seems to work out pretty well for him :)
12:48:49 <cocreature> cabal started doing that recently as well
12:50:31 <merijn> Actually, since criterion exports all it's internals, I think I could roll this functionality myself without patching criterion, but why not save every other poor soul the work...
12:51:07 <merijn> Actually, that would also involve a reasonable amount of code duplication attracting bugs...
12:51:23 <h101010> #join archlinux
12:51:44 <maerwald> no
12:59:16 <mmaruseacph2> what's the problem with criterion? :o
13:00:24 <merijn> mmaruseacph2: 1) "env" does not support a cleanup operation after the corresponding benchmarks finish 2) env doesn't support "per run" environment
13:00:42 <merijn> I have benchmarks the require per run setup/cleanup
13:01:30 <mmaruseacph2> oh, makes sense
13:03:03 <merijn> I want to benchmark my Chan implementation, but I'm really unhappy/disappointed with the benchmarks used by, e.g. unagi-chan. But doing proper benchmarks is substantially harder without the ability to have "per run" environment
13:03:39 <dolio> I ran into the same thing testing vector-algorithms.
13:04:02 <merijn> dolio: Well, maybe you can help me prod bos to merge it after I finish writing this ;)
13:04:22 <dolio> I wanted env to initialize a mutable array each time, but it only did it once.
13:04:30 <dolio> So most of my tests were on sorted arrays.
13:04:40 <merijn> There's already a PR for "envWithCleanup", but that still only does it once per run
13:05:14 <merijn> dolio: Would setup/cleanup per Benchmarkable work for your use? Or do you need actual "per run" setup?
13:06:48 <merijn> dolio: Since criterion uses "newtype Benchmarkable = Benchmarkable { runRepeatedly :: Int64 -> IO () }" to run a benchmark repeatedly. Doing setup once for the entire N runs is much easier/less invasive than doing so for every individual run
13:07:33 <dolio> I wanted it per run. The array needs to be re-initialized every time, and I wanted to not include the time to initialize it int the benchmark time.
13:07:54 <merijn> That's considerably trickier, I think...
13:08:30 <dolio> Yeah, I figured it was kind of fundamental, like you couldn't get good timing for a single benchmark run.
13:08:35 <merijn> So, in my case of wanting to benchmark, e.g. "putChan" I can easily reuse the same chan across N repeats (which it does for accuracy)
13:08:39 <dolio> Necessarily.
13:10:06 <dolio> I modified the approach I was taking, and just accepted that I had to have the per-run initialization time included.
13:10:12 <merijn> dolio: Well, actually I think you might be able to work it?
13:10:14 <dolio> So I'd have to benchmark that, too, and subtract it.
13:10:31 <hololeap> hello everyone. i made a library that uses IntSet and the Enum typeclass to map any Enum to the IntSet implementation. i had to re-write a bunch of functions, and i realized there are only a handfull of patterns that were being used to essentiall unwrap and re-wrap values. i feel like this is a common pattern and i was thinking that maybe there is a type that encapsulates this?
13:11:49 <hololeap> or any kind of abstraction of this pattern
13:11:57 <merijn> dolio: i.e. suppose the Benchmarkable gets called with 10 (as in 10 iterations) you could setup 10 unsorted arrays at once, sort all 10 arrays and finish. That way you could get what you need and still only require setup/cleanup once per Benchmarkable (which, as said, is relatively easy to patch)
13:11:59 <dolio> It's not a big deal in my case. It just didn't work the way I initially thought.
13:12:00 <hololeap> would be helpful
13:12:31 <dolio> Oh, that's true.
13:12:33 <veyd> is there an easy all-in-one IDE thjat includes a GHCi interface? I tried VSCode with Haskell extensions but I have no clue how to get it working to where I can do these Haskell tutorials on ghci
13:12:35 <merijn> dolio: So as long as your setup/cleanup functions are parametrised over the iterations in the Benchmarkable, it'd work for what I intend to patch
13:12:51 <veyd> I also tried installing Leksah but it chokes and fails on Win 10
13:13:07 <merijn> dolio: In your case you could also do that with the current env setup, I guess
13:13:15 <merijn> oh, wait, no
13:13:35 <dolio> merijn: Yeah, I don't care about the initialization happening in between each benchmark per se.
13:13:44 <leshow> in this bit of code in RealWorldHaskell
13:13:46 <leshow> https://github.com/cyga/real-world-haskell/blob/master/ch18/UglyStack.hs#L22
13:13:53 <merijn> You'd still need a "per benchmarkable" setup, since you don't know in advance how many arrays you need to sort to be accurate enough
13:13:54 <leshow> what would k look like?
13:14:15 <leshow> I have a similar problem in my own application where everything copmiles except this argument to runReaderT
13:14:53 <glguy> leshow: It would be any value that has type App a for any a
13:15:14 <leshow> glguy, Ok but I don't really understand how to construct that value
13:15:20 <merijn> leshow: k should be a "ReaderT r m a"
13:15:35 <glguy> leshow: For example constrainedCount constructs such a value
13:15:36 <CuriousErnestBro> what's so special about the city Glasgow?
13:15:42 <merijn> leshow: Note that "App a" is just a synonym of "ReaderT AppConfig (StateT AppState IO)"
13:15:49 <merijn> eh.. add an 'a' at the end there
13:15:55 <merijn> CuriousErnestBro: In what sense?
13:16:06 <CuriousErnestBro> merijn, in the ghci sense
13:16:16 <leshow> but constrainedCount's type isnt anywhere close to ReaderT AppConfig ...
13:16:21 <merijn> CuriousErnestBro: The GHC project was started by people at the University of Glasgow
13:16:32 <glguy> leshow: No, it's quite close to that
13:16:33 <CuriousErnestBro> ah ok
13:16:43 <leshow> Oh i see, the type synonym
13:16:53 <merijn> CuriousErnestBro: UHC is called the Utrecht Haskell Compiler for similar reasons ;)
13:17:08 <dolio> merijn: The only issue I forsee is that doing a bunch of initialization at the start conflicts with the idea that having irrelevant stuff in memory (or what have you) could affect the benchmark results, which is one thing that env is for. But it'd be nice to have a trade off for that.
13:17:44 <merijn> dolio: Well, irrelevant stuff *will* affect your benchmark if it takes long enough to trigger GC, but I don't see any real way around that
13:17:59 <merijn> Since extra live data == more data to copy by the GC
13:18:14 <dolio> Yeah.
13:18:51 <merijn> hmmm
13:18:56 <dolio> I can't benchmark sorting on 16 GB arrays, either. :)
13:19:06 <merijn> dolio: No? Get a bigger computer!
13:19:10 <CuriousErnestBro> cool, I have a friend at Utrecht
13:19:11 <dolio> If it needs to be able to put 10 into memory.
13:19:35 <merijn> dolio: 10 arrays of 16GB is easy, just get a nice SPARC box with 5TB memory :)
13:19:45 <ph88^> can someone help me make this code a bit more "haskell powered" ? right now it looks stupid  https://bpaste.net/show/1087e1b3b33b
13:20:10 <merijn> dolio: Although, tbh, for sorting arrays that big you don't really need criterions accuracy anyway. Who cares about nanoseconds for benchmarking that :p
13:21:05 <bitemyapp> merijn: I don't mind patching. I just want things upstreamed.
13:21:19 <bitemyapp> merijn: but a lot of programmers consider needing to patch a dependency a Hard No for using a language/ecosystem
13:21:30 <bitemyapp> so it's worth keeping in mind that it's a mental block for a lot of normies
13:21:53 <merijn> bitemyapp: Sure, but it's not like other languages got their ecosystems without ever patching things :)
13:22:12 <orion> bitemyapp: One thing that's annoying about patching dependencies is that you have to pull the entire project in to yours.
13:22:35 <merijn> orion: No, that's why he said he wants things upstreamed. That means *not* pulling in projects
13:22:45 <merijn> It means hassling upstream until your patch is included :p
13:23:03 <merijn> Thus, solving the issue for everyone else too and making the world a better place!
13:23:48 <merijn> http://www.reactiongifs.us/wp-content/uploads/2016/06/doing_my_part_starship_troopers-1.gif
13:24:23 <ph88^> merijn, what do you call some of bos critical stuff ?
13:28:15 <orion> Does anyone know if basvandijk hangs out here?
13:28:32 <merijn> ph88^: criterion, attoparsec, aeson, text, text-icu, mwc-random
13:29:15 <merijn> orion: If he does, you're unlikely to catch him now, since it's 22:30 :)
13:29:23 <dolio> merijn: I just wanted to make fancy graphs.
13:29:41 <merijn> dolio: Word :)
13:30:02 <merijn> dolio: Why do you think I'm trying to use criterion? ;)
13:30:10 <dolio> :)
13:32:12 <ph88^> merijn, do you have an advice for me what i can do about that code snippet ?
13:32:35 <merijn> ph88^: Which snippet?
13:32:48 <ph88^> https://bpaste.net/show/1087e1b3b33b
13:32:51 <ph88^> it looks stupid
13:34:23 <merijn> ph88^: Write "String -> Maybe a -> Either String a", use that to lift HL.lookup to a "Either String a" function and then use the monad instance of Either?
13:36:46 <ph88^> eehh, you mean make those two top functions into one function ?
13:40:46 <merijn> ph88^: No, wrap HL.lookup to return an Either and then use do notation to handle failures
13:41:20 <Miranda> Hi. I'm unable to declare class Foo f where fooA :: f -> (); fooB :: ()
13:41:21 <ph88^> ooh
13:41:48 <Miranda> fooB produces an error saying the type variable `f` is ambiguous. Any insight as why that's a problem?
13:42:39 <jle`> Miranda: how would you expect fooB to work?
13:42:40 <Miranda> I'm almost sure that the call site has enough information to infer the `f` because calls to `fooA` also happens.
13:42:47 <Miranda> So why is it bugging me about this `fooB` ?
13:43:00 <jle`> there is no way the call site would have enough information to infer fooB
13:43:07 <jle`> to infer the instance that fooB uses, that is
13:43:31 <jle`> Miranda: if i just had `fooB :: ()`, how would you know what f's instance is being used?
13:43:51 <jle`> it could be an instance for Int...or for Bool....or for String...
13:44:37 <Miranda> That would be a problem if it was used alone, but given  (fooA something) and (fooB something), wouldn't the type inference correctly infer `something`? 
13:44:46 <Miranda> And thus work out fooA and fooB are legal?
13:44:48 <jle`> Miranda: 'fooB something' is a type error
13:44:58 <jle`> fooB :: (), not a function
13:45:06 <Miranda> jle`: Err, sorry. Oh wait. That's why it can't figure it out :/
13:45:28 <jle`> if you have ghc 8.0, you can turn on AllowAmbiguousTypes, and provide the instance using type applications
13:46:02 <jle`> but the traditional way is to have fooB take an argument that lets ghc infer the type
13:46:09 <jle`> fooB :: forall p. p f -> ()
13:46:10 <chenyu> hello! Will someone kindly answer this questions? http://stackoverflow.com/questions/43265198/will-stack-over-flow-error-occur-in-haskell-why
13:46:31 <jle`> that way is a bit more normal-haskell
13:46:41 <jle`> then you could call `fooB (Proxy :: Proxy Int) :: ()`
13:46:43 <jle`> chenyu: 
13:46:50 <jle`> oh, sorry, pressed enter too soon
13:46:53 <Miranda> jle`: Okay, let me play a little and see if I can figure it out with the new information.
13:47:05 <Miranda> jle`: Appreciated :)
13:47:09 <jle`> no problem!
13:47:13 <chenyu> :)
13:48:50 <Sh4rPEYE> Let's say I have the following code. How can I write some QC tests for it? I was thinking mainly about encode->decode = original equality, but it seems impossible when Maybes are involved. What's the right way to do it?
13:48:55 <Sh4rPEYE> http://lpaste.net/448485359836200960
13:51:26 <koala_man> Sh4rPEYE: the fact that Maybe is involved just means that the test would additionally express that the operation should succeed
13:51:53 <monochrom> (toRoman x >>= fromRoman) == Just x
13:52:54 <monochrom> There is a fmap version too.
13:52:55 <ph88^> merijn, like this?  https://bpaste.net/show/fc0d86439270
13:52:58 <Sh4rPEYE> monochrom That won't work; let x = (-1), then in would be Nothing == Just (-1)
13:53:15 <monochrom> Oh OK, I was thinking of non-neg x.
13:53:55 <Sh4rPEYE> monochrom: I have actually no idea how to specify what Ints QC passes. If I could choose that, it would solve this problem
13:54:00 <monochrom> I don't know the details of QC, but I think you know how to say "this is for non-neg x"
13:54:05 <Sh4rPEYE> (I just started with QC)
13:54:18 <mmaruseacph2> Sh4rPEYE: https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Modifiers.html
13:54:24 <mmaruseacph2> Positive Int instead of Int
13:54:49 <merijn> ph88^: Why have separate "tableLookup" and "nodeLookup"? Aren't they basically the same?
13:55:17 <Sh4rPEYE> Thanks
13:56:39 <ph88^> merijn, yes basically, except for the 3rd argument   (TO.VTable table)
13:57:39 <ph88^> oh ye i refactered that
13:59:20 <Sh4rPEYE> Little followup: Where should I put my tests in the source code? Should I just define the properties, so they can be checked from GHCi, or should I make some form of main function and check for them myself in the source?
14:00:30 <jle`> Sh4rPEYE: for a haskell project, tests can be integrated into cabal
14:00:51 <ph88^> merijn, now i have this https://bpaste.net/show/f15dc955f7ce
14:01:00 <jle`> test suites are usually implemented as exeutables in a test/ directory
14:01:10 <Sh4rPEYE> jle`: It is rather a simple one-module exercise, so it'd be mabye good to have them at a glance
14:01:14 <jle`> some people also like doctests right in their documentation
14:01:48 <jle`> Sh4rPEYE: if it's for a one-module exercise then you can put them wherever you want :)
14:02:19 <Sh4rPEYE> I mean - how should I do it, though.
14:02:50 <Sh4rPEYE> Now I have a defined property, which should hold true for a given input. But I have no idea what to do now.
14:02:51 <jle`> i don't think there's any standard.  whatever works for your workflow
14:03:20 <jle`> you can write an IO () that tests all our properties if you want
14:07:21 <Sh4rPEYE> jle`: Good idea. Thanks :-)
14:07:22 <ph88^> merijn, i think normally you just define types and write generic function on top for this, no? or use lens ?
14:09:12 <merijn> ph88^: Yes, no, maybe?
14:10:08 <mmaruseacph2> Sh4rPEYE: if you use stack then stack new name-of-project tasty-travis should get you settled
14:11:54 <Zemyla> Oh, I figured out a way for an Integer library (which can't use anything like error or undefined) to throw an exception rather than crash the runtime if called on invalid arguments.
14:12:08 <merijn> Is there, like, a mix of <* and >>= ?
14:12:22 <merijn> i.e. pass the result of an action to the next, then return the original result?
14:12:44 <Zemyla> Using only operations from GHC.Prim:
14:13:42 <Zemyla> undefined = case atomically# (atomically# (\s -> (# s, let x = x in x #))) realWorld# of { (# _, x #) -> x }
14:14:39 <jle`> merijn: x <*= f = x >>= (liftA2 (<$) f) i suppose heh
14:14:43 <jle`> i don't think there's a built-in way
14:16:23 <romildo> Does anybody know if the function    (\test x list -> if test then x : list else list)    is already available in some library?
14:16:46 <romildo> If not, what would be a good name for it?
14:16:55 <ph88^> merijn, dunno i figured you could point my in the right direction to polish this up ^^
14:17:43 <ChaiTRex> @src if'
14:17:43 <lambdabot> Source not found.
14:18:14 <monochrom> cons_if is a good name.
14:18:35 <monochrom> condcons is a good pun but...
14:18:41 <ChaiTRex> You're one of those evil non-camelcasers, aren't you?
14:19:02 <monochrom> No, I am one of those benevolent non-camelcasers.
14:19:08 <MarcelineVQ> pCons :>
14:21:32 <romildo> With the help of a version of ($) with the same precedence of (:) and want to write expressions like    1 : 2 : consIf True 3 $: 4 : 5 : []
14:23:43 <nak> i'm trying to understand monad transformers better. given transformer (MyMonadT Maybe), what is the expected return type of >>= ? Am I expected to return MyMonad(Maybe a) or only (Maybe a) ?
14:25:37 <glguy> :t (>>=)
14:25:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:25:53 <glguy> If you're making an instance Monad (MyMonadT Maybe), then m is MyMonadT Maybe
14:26:12 <nak> ah
14:26:21 <glguy> so (>>=) :: MyMonadT Maybe a -> (a -> MyMonadT Maybe b) -> MyMonadT Maybe b
14:26:38 <nak> <3
14:26:47 <nak> thank you glguy 
14:26:50 <nak> :t return
14:26:51 <lambdabot> Monad m => a -> m a
14:26:56 <nak> parfait
14:27:34 <nak> return :: a -> MyMonadT Maybe a
14:27:37 <nak> glguy: yes ?
14:28:33 <Zemyla> :t maybe (const id) (const const) . guard -- ChaiTRex: This is a point-free definition of if'
14:28:35 <lambdabot> Bool -> a -> a -> a
14:28:54 <nak> glguy: i'm seeing things like runEitherT and runContT. is this a sort of standard interface for getting at the inner monad then ?
14:29:17 <nak> glguy: ie, should MyMonadT have a runMyMonadT field ?
14:30:05 <glguy> nak: Yes, that return type is fine. Having a runMyMonadT field is one way to consume them, fairly common. my original instance line was off, you'd typically want to write: instance Monad m => Monad (MyMonadT m) if you were making a "transformer"
14:30:47 <nak> :t runEitherT
14:30:48 <lambdabot> error:
14:30:49 <lambdabot>     • Variable not in scope: runEitherT
14:30:49 <lambdabot>     • Perhaps you meant ‘runWriterT’ (imported from Control.Monad.Writer)
14:30:59 <nak> :t runStateT
14:31:00 <lambdabot> StateT s m a -> s -> m (a, s)
14:31:28 <nak> ah ok, so the outer is run and it spits out the inner monad
14:31:34 <nak> :t runContT
14:31:35 <lambdabot> forall k a (m :: k -> *) (r :: k). ContT r m a -> (a -> m r) -> m r
14:31:37 <glguy> If it's appropriate to provide that as a field selector will depend on what your transformer is and if you intend to expose the actual implementation to the consumer of your transformer
14:31:49 <Zemyla> nak: It should have some way of taking it out. It depends on how much access to the internal state you want the user to have.
14:32:19 <nak> ok thanks ^_^
14:32:23 <nak> i'll keep poking at this
14:36:28 <merijn> Right, so how do people to decide where in, e.g., criterion to put all the INLINE annotations, etc.? How do I check I didn't horrifically break criterion's performance/accuracy?
14:41:33 <bitemyapp> orion: huh? I use git dependencies in the `stack.yaml`
14:41:45 <bitemyapp> I rarely have to vendor-as-in-inline-the-library
14:41:55 <bitemyapp> actually, never. That never happens. Git fork suffices.
14:42:56 <bitemyapp> merijn: I hear you, but it means you have to be aware of who's ideally situated to adopt the language and who might need to adjust their expectations and level up a bit first.
14:43:27 <bitemyapp> Jumping into a less developed ecosystem is a great way to mature quickly as a programmer but some people recoil at it.
14:48:35 <nak> glguy: so say I have MyMonad (Maybe a)? is there a way to lift/convert that to MyMonadT Maybe a ?
14:48:54 <napping> Can a Parsec ByteString parser capture the slice of input that some sub-parser matched?
14:49:22 <glguy> nak: Only if you write one and whatever MyMonad/MyMonadT are supports that operation
14:52:24 <nak> ok ^^
14:55:26 <Taren> Hey!
14:55:32 <Taren> This comment says "Experiments suggested that a separate top-level helper is more efficient than a local worker."https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.OldList.html#prependToAll any idea why?
14:56:46 <Miranda> nak: Small note, MyMonad would be misnamed if you're able to define an instance for (Maybe a). `Maybe a` has the wrong kind to be a monad.
14:57:00 <napping> Taren: that's surprising. Do you know how old the comment is?
14:57:45 <napping> I haven't tested it, but I'd expect it to compile exactly the same if that function was in a where clause
14:58:52 <napping> You don't have a checkout you could run 'git blame' on, do you? 
14:59:41 <Taren> not sure how to reblame on github https://github.com/ghc/ghc/commit/3daf0023d2dcf7caf85d61f2dc177f8e9421b2fd#diff-97ab0fb27f76ef26f95ad7052d83f4e8R437
14:59:52 <Taren> but older than three years
15:00:08 <Taren> and yeah, no checkout
15:00:19 <napping> ah, and that commit looks like it's just renaming the file also
15:00:55 <napping> If they made a worker that closed over "sep" instead of taking it as an argument, maybe it could have been more expensive
15:01:31 <napping> I'm pretty sure a where-clause function that doesn't actually close over any variables has basically been lifted to the top for a long time
15:03:10 <Miranda> jle`: I ended up using a Proxy. I tried to simplify it as much as I could, with  `class (Foo f) where foo :: Something f` and a phantom `data Something f = Something { ... }`, but didn't like where it was headed.
15:03:35 <Miranda> jle`: I might come back to it again. Using proxy certainly feels dirty/unecessary.
15:07:14 <mbw> I have a question about the following code: http://lpaste.net/354384 . In here, I tried to implement a filter function on vectors, which could possibly be parallelized. It consists of a map, a scan, and a conventional for loop. In the for loop, each element of a mutable result vector is modified only once. Is there a way to rewrite it to make it more explicit? I'm not a great fan of the "for each element of 
15:07:20 <mbw> this iteration space, perform these side effects" kind of thing, for obvious reasons...
15:08:01 <iqubic> Well, I finally updated to GHC 8.0.2
15:10:15 <iqubic> Now, what do curry and uncurry do? And are they useful?
15:10:39 <hpc> they translate between functions of tuples and functions of multiple arguments
15:10:49 <hpc> (or functions that produce functions if we're being precise)
15:10:52 <hpc> :t uncurry
15:10:53 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:11:00 <hpc> :t curry
15:11:01 <lambdabot> ((a, b) -> c) -> a -> b -> c
15:11:15 <hpc> or if you insert parens:
15:11:25 <hpc> uncurry :: (a -> b -> c) -> ((a, b) -> c)
15:11:34 <hpc> curry :: ((a, b) -> c) -> (a -> b -> c)
15:11:54 <hpc> they're occasionally handy, but not that often
15:12:07 <iqubic> What does that do? Unpack a tuple and shove the values into a fuction?
15:12:28 <hpc> curry takes a function that takes a tuple
15:12:38 <hpc> and produces a function that takes two arguments instead
15:13:15 <hpc> the implementation is that it takes two arguments, puts them in a tuple, and passes that to the function it gets
15:13:18 <hpc> @src curry
15:13:18 <lambdabot> curry f x y = f (x, y)
15:13:26 <hpc> uncurry does the reverse
15:13:48 <iqubic> So uncurry f (x, y) = f x y?
15:13:54 <hpc> @src uncurry
15:13:55 <lambdabot> uncurry f p = f (fst p) (snd p)
15:13:59 <hpc> pretty much
15:14:07 <dfeuer> @djinn ((a, b) -> c) -> a -> b -> c
15:14:07 <lambdabot> f a b c = a (b, c)
15:14:30 <dfeuer> Those are some lousy variable names from djinn.
15:14:32 <hpc> as for usefulness, you'll know it when you see it
15:14:48 <dfeuer> @djinn (a -> b -> c) -> (a, b) -> c
15:14:48 <lambdabot> f a (b, c) = a b c
15:15:01 <hpc> pretty much when you have an inconvenient tuple somewhere in your types, that's where curry and uncurry start to matter
15:16:28 <iqubic> Ah.
15:16:43 <iqubic> I don't see the point of tuples
15:17:17 <hpc> it doesn't come up often
15:17:24 <hpc> maybe in arrow-heavy code
15:17:30 <iqubic> Tuples, or curry and uncurry?
15:17:38 <hpc> yes
15:18:10 <iqubic> Which one?
15:18:23 <dfeuer> Also in code using the Strong from profunctors.
15:18:39 <dfeuer> But you can write a version of Strong with no tuples too.
15:18:46 <joe9> can someone please fix the module url's for this package? https://hackage.haskell.org/package/text-generic-pretty
15:19:04 <iqubic> How is it wrong?
15:19:50 <iqubic> What's the latest version of cabal?
15:20:01 <dfeuer> class Profunctor p => Strong p where lensical :: (s -> a) -> (s -> b -> t) -> p a b -> p s t
15:20:27 <iqubic> I have a question, how does one run cabal?
15:20:28 <hpc> ah yes
15:20:29 <joe9> iqubic: Was that question for me? the modules are not hyperlinked
15:20:30 <hpc> the pabst functor
15:20:57 <iqubic> Ah.
15:21:25 <iqubic> How does one run cabal? Is that a command line application?
15:21:34 <iqubic> Also, do I need both cabal and stack?
15:21:41 <iqubic> Or will just stack be enough?
15:22:21 <Sonolin> I think you need both
15:22:31 <Sonolin> I think stack is just a front for cabal + ghc
15:22:40 <iqubic> How do I install cabal?
15:22:48 <iqubic> From my command line?
15:22:54 <Koterpillar> if you have stack, you don't need cabal the tool
15:22:56 <Sonolin> *insert your package manager here*
15:22:58 <hpc> you'll likely want stack
15:23:04 <iqubic> hpc, I have stack.
15:23:05 <hpc> stack is a reproducible build tool
15:23:11 <iqubic> And not cabal.
15:23:24 <hpc> it manages its own versions of cabal and ghc, in order to maintain precise control over the versions of things
15:23:32 <iqubic> Is that fine? Too have just stack and not cabal.
15:23:35 <hpc> (which is part of reproducibility)
15:23:37 <hpc> yeah
15:23:47 <iqubic> Also, how do I get hoogle as a command line tool.
15:24:00 <mmaruseacph2> stack/cabal install hoogle?
15:24:07 <iqubic> I remember that I had that before I upgraded to GHC 8.0.2
15:26:31 <iqubic> Looks like I had to run stack setup first.
15:27:29 <iqubic> So, what is stack good for?
15:28:33 <hpc> it's a reproducible build tool
15:28:44 <Sornaensis> stack is good for building and running things
15:28:44 <iqubic> What does that mean?
15:28:53 <hpc> you have a very high degree of control over what the state of the system doing the build is
15:29:04 <hpc> and given a configuration from someone else, you can reproduce their build
15:29:20 <hpc> it makes parts of development much easier
15:29:58 <iqubic> And it also let's me install an manage libraries, right?
15:30:45 <monochrom> I am skeptic about the "manage" part. But I say this not just about stack, but also cabal.
15:31:08 <hpc> stack is primarily a build tool
15:31:33 <iqubic> So how come I can do things like "stack install hoogle"?
15:31:52 <monochrom> That's install. I didn't doubt the install part.
15:32:24 <iqubic> why do you doubt the "manage" part?
15:32:49 <monochrom> Because stack and cabal don't provide management commands.
15:33:11 <iqubic> Oh.
15:33:21 <iqubic> Why does Hoogle take a while to install?
15:34:12 <Sonolin> aren't you on Gentoo? Doesn't everything?
15:34:43 <Sonolin> and anyway I'm sure there's lots of dependencies since you're on a fresh install
15:35:24 <iqubic> sonolin, you're absolutly right.
15:37:09 <iqubic> Sonolin, actually what I've asked my computer to rebuild each library with GHC 8.0.2 support.
15:46:32 <iqubic> What's wrong my hoogle install.
15:47:23 <iqubic> After running any hoogle command I get the following line printed twice: "hoogle: unable to decommit memory: Invalid argument"
15:48:40 <monochrom> That's bizarre.
15:48:49 <monochrom> But I don't know what's wrong.
15:50:19 <iqubic> Actually, that error only shows up sometimes.
15:51:04 <geekosaur> that's the new memory manager, and presumably whether it shows up depends on how much memory and how it allocated it, such that it might or might not have a full page to decommit
15:51:20 <iqubic> Ah.
15:51:34 <iqubic> How can I give hoogle more memory?
15:51:38 <geekosaur> er?
15:51:44 <geekosaur> that's not the issue
15:51:52 <iqubic> What is the issue?
15:51:53 <Sornaensis> gotta set up swap
15:51:57 <geekosaur> sigh
15:52:16 <iqubic> I do have swap.
15:52:23 <iqubic> I know that I have swap.
15:52:54 <geekosaur> the question is whether it was able to compact in-use memory enough to have a full page available to decommit. it's not a question fo whether you have enough memory, but how it's using the memory it has
15:53:06 <geekosaur> adding swap or whatever won';t affect this at all
15:53:30 <iqubic> So is hoogle just built incorrectly?
15:53:55 <geekosaur> this is not something abouytu hoogle, it is something about the ghc runtime.
15:54:08 <iqubic> Is there a way to fix this issue than?
15:54:15 <geekosaur> I would just ignore the message, unless you want to get into debugging madvise calls
15:54:44 <iqubic> But it looks so ugly in my terminal.
15:54:48 <geekosaur> especially if it's happening just before exit since the process exiting will decommit the memory anyway
15:54:54 <stevenxl> hi folks. Haskell newbie here. Trying to understanding IO, but I don't understand why I am getting an error with teh following code: https://gist.github.com/StevenXL/2f88850645dfbc6313f5b9b929c19cc7
15:55:22 <stevenxl> The compiler says that I might need a let in a do block, which I can certainly do, but I don't understand the problem itself.
15:55:52 <geekosaur> stevenxl, you should include the full error message
15:56:19 <geekosaur> but, from what I see here, my guess is you wanted == on line 23
15:56:25 <stevenxl> sure
15:56:32 <Koterpillar> stevenxl: ==
15:56:37 <dfeuer> Anyone have any tips and tricks for formal proofs involving binary numbers? Best practices for defining addition and the like?
15:56:38 <Koterpillar> stevenxl: second last line
15:56:38 <geekosaur> 'str = yes = main' is not valid. you probably wanted comparison, str == value
15:56:51 <stevenxl> ugh 
15:56:53 <stevenxl> lol
15:56:56 <stevenxl> thank you geekosaur that was it!
15:57:09 <stevenxl> thanks Koterpillar 
15:57:18 <iqubic> So is my version of GHC just borked?
15:57:38 <iqubic> Is that why I'm getting weird messages when running Hoogle?
15:57:40 <dfeuer> geekosaur: is that something you know about, or should I ask glguy or someone?
15:58:03 <geekosaur> dfeuer, I don;t know a whole lot about it, sorry
15:58:16 <geekosaur> iqubic, if you conider that message bad then "it's broken"
15:58:58 <geekosaur> the page-based memory manager is still new and there are some known glitches, most of which are just likely-unnecessary messages
15:59:27 <iqubic> I'll just deal with it then
16:00:17 <Cale> dfeuer: While I'm sure there's some way to do everything directly, it may be easiest in some cases to lift proofs about unary natural numbers.
16:01:01 <dfeuer> Cale: that's a non-option. My insane goal is to make proofs that run in logarithmic time :-)
16:01:05 <Cale> ah
16:01:25 <iqubic> Alright, when doing a shell escape from ghci, to run hoogle, I get no memory errors at all.
16:01:52 <iqubic> Wait, yes I do.
16:02:01 <iqubic> And I don't even get any output.
16:03:08 <iqubic> alright, I can run hoogle "a -> a" from command line.
16:04:25 <iqubic> Is there a way to run hoogle from inside ghci?
16:04:56 <iqubic> Alright, I can run hoogle from inside ghci.
16:05:09 <iqubic> But some things just don't work
16:07:22 <falconasr> how to auto dim brightness upon switchin to battery power?
16:07:40 <iqubic> falconasr: This is not the right channel for that.
16:07:42 <dyreshark> probably by using IO
16:08:12 <falconasr> sorry can you refer the channel
16:08:27 <iqubic> What OS are you using?
16:08:32 <Koterpillar> falconasr: use the channel for your operating system, probably
16:08:40 <falconasr> Ubuntu 16.04
16:08:44 <Koterpillar> #ubuntu then
16:09:19 <iqubic> Alright, I got hoogle to work.
16:09:38 <falconasr> thanks
16:09:50 <iqubic> The pager memory system is still giving me lots of stupid prints, but I'll ignore those for now.
16:11:00 <iqubic> Is that a thing that other people are experiencing as well?
16:11:18 <iqubic> Or is it just me?
16:13:02 <geekosaur> there are lots of variables involved including kernel version
16:13:08 <iqubic> Really?
16:13:52 <iqubic> I'm using kernel 4.4.26
16:14:02 <geekosaur> yes, it's using a fairly recently added kernel facility, if it's not there then it tries a fallback which can lead to spurious messages, and conceivably some early kernels with the new mechanism might have bugs
16:14:12 <geekosaur> but I don;t know when the new stuff was added exactly
16:28:50 <fizbin> Can someone explain to me how stack space is used up in haskell?
16:31:05 <fizbin> Specifically, I have a program that's blowing up from a Stack space overflow and the trace points to a function that's just a call to foldl'
16:32:08 <Cale> The stack will usually consist pretty much entirely of case expressions or other forms of pattern matches
16:32:17 <Cale> As such it's not really a call stack
16:33:03 <Cale> When you pattern match on some expression, before the match can proceed, that expression needs to be sufficiently evaluated to match a constructor. The case expression waits on the stack while its scrutinee is evaluated.
16:34:08 <Cale> The only other case is where a function application waits on the stack for the *function* to be sufficiently evaluated to apply.
16:37:21 <Cale> fizbin: So, *typically* the problem is that foldl or something will build up a large expression composed of strict functions (i.e. those which need to pattern match their arguments) in the accumulating parameter, and then the resulting pattern matches blow up the stack. foldl' tries to avoid this by hinting to the compiler that the accumulating parameter should be evaluated on each step, but it's only evaluated up to the point where 
16:37:21 <Cale> the topmost data constructor can be determined
16:38:04 <Cale> So if you're accumulating something like a pair, that might not be enough evaluation and you may wish to add some annotations to ensure that the two components of the pair also get evaluated.
16:38:19 <fizbin> Hrm.
16:38:39 <Cale> e.g. foldl' (\(u,v) x -> u `seq` v `seq` ...)
16:39:51 <Cale> fizbin: If you put your program on lpaste.net or something, I can take a quick peek. I have to work soon though.
16:39:57 <fizbin> Okay. Let me try making it more strict.
16:40:43 <fizbin> The function having issues is (foldl' (flip G.insNode) g vs) , where "G" is Data.Graph.Inductive.Graph
16:41:49 <fizbin> Now, G.insNode here should be https://hackage.haskell.org/package/fgl-5.5.3.1/docs/src/Data-Graph-Inductive-PatriciaTree.html#fastInsEdge
16:43:03 <fizbin> And in theory, that's strict in various parts.
16:43:31 <fizbin> Though, it's not using Data.IntMap.Strict.
16:45:11 <Cale> Well, it's using insert rather than something like insertWith, so not too much to worry about htere
16:45:13 <Cale> there*
16:45:40 <Cale> Well, fastInsNode is...
16:46:00 <Cale> fastInsEdge is using adjust, which is a little more potentially interesting
16:48:11 <Jello_Raptor> hmm, I'd like some advice on how to structure an interface.
16:49:15 <Jello_Raptor> So, I'm playing around with propagator networks, and MonadFix is a great interface for describing them. 
16:49:46 <Jello_Raptor> I can get arbitrary finite graphs out, once there's an operator to unify two values. 
16:51:02 <Jello_Raptor> I can also instantiate the networks lazily, so if I ever ask for a single value in the network, post quiesence, I can only actually allocate and work on the subset of the network that is capable of influencing it. 
16:51:11 <Cale> fizbin: I think I can imagine a situation in which more and more occurrences of addLists build up as edges get inserted, if nothing has the occasion to evaluate the parts of those triples.
16:52:07 <Cale> fizbin: You'd have to be adding lots of edges to the same vertex -- a very large number if you're actually going to cause a stack overflow that way, and that's assuming that GHC's strictness analyser isn't catching this.
16:54:07 <Cale> Jello_Raptor: Functor-style FRP systems tend to use MonadFix that way as well.
16:54:09 <Jello_Raptor> The problem is if I want something like an infinite propagator network, my monadfix interface requires that I know, at any point, all the possible edges into a particular vertex. The issue comes when I've got any operator that results in more than one input edge to a vertex. I can't figure out a way to constrain that interface so that it is something I can instantiate lazily :/ (I can't use the default interface since I provably 
16:54:09 <Jello_Raptor> have to know the entire graph to get multiple edges into a vertex.)
16:54:25 <monochrom> fizbin: It looks like you will want Data.IntMap.Strict instead.
16:55:05 <Cale> Well, it's really hard for me to say what's causing the stack overflow without having seen the code.
16:55:17 <Cale> The stack overflow might very well be unrelated to this.
16:55:18 <fizbin> Yeah, but that stuff is all in a third party library.
16:56:09 <Jello_Raptor> and there's a lot of uses for an infinte propagator network, since it lets you effectively model recursion and the like, lazy evaluation is super nice, since I can hoist any function into the network and with unsafeInterleaveIO only ever look at the vertices the function asks for :/ 
16:59:21 <Jello_Raptor> (yes there's some issues with deadlocks, but one can get around those) 
17:13:44 <mniip> dfeuer, okay this is tough
17:16:33 <RyanGlScott> Does hlint-2.0 no longer look in HLint.hs for custom settings?
17:18:27 <fizbin> Huh. Maybe I shouldn't insert 3.9 million edges at once.
17:26:19 <robkennedy> Is there a tutorial for starting a blog with a Haskell backend? I've never deployed anything but static pages to hosting before. 
17:26:41 <Koterpillar> robkennedy: static blog or an actual server?
17:27:21 <robkennedy> I'd guess I'm trying to learn servers. Something where I can deploy a database would be amazing
17:27:48 <Koterpillar> deploying a database is orthogonal to haskell
17:28:35 <Koterpillar> I wrote a blog server (can't be static for reasons), but the content isn't in the database
17:29:34 <robkennedy> Is it? I've accessed a few databasi in my time, and no two are alike - accessing a particular database would be part of a lesson in starting a blog, I'd think
17:30:01 <Koterpillar> accessing, not deploying
17:30:19 <robkennedy> So not "deploying a predetermined database"
17:30:31 <robkennedy> We may be describing the same problem
17:30:51 <jmcarthur> Type l
17:30:54 <jmcarthur> oops
17:31:05 <jmcarthur> Sorry, disregard.
17:31:25 <Koterpillar> robkennedy: OK, so you want to build a blog that stores its content in the database?
17:31:39 <robkennedy> I suspect that any reasonable blog infrastructure would use a database 
17:31:43 <robkennedy> Yes
17:31:59 <Koterpillar> robkennedy: or do you want to _deploy_ it, as in, you have it and you want to put it on a server?
17:32:16 <geekosaur> type l 8, what, is this tenex? :p
17:34:20 <jmcarthur> I had started typing something intended to actually go here, typoed, forgot about it, came back, then accidentally hit enter.
17:34:39 <robkennedy> No, sorry, I want to in general learn about using Haskell as a backend for web application with changing data over time. I say database to imply that the data is not completely knowable to the compiler. 
17:35:43 <robkennedy> In my job I have tons of experience with private data stores, as file servers and databases. I'd expect databases as the normal solution to this problem
17:35:56 <Sonolin> robkennedy a quick google search resulted in http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
17:36:13 <Sonolin> no idea how good/bad it is
17:36:30 <Sonolin> there's also the standard Yesod tutorial but it seems their site is having issues..
17:37:09 <jmcarthur> Yesod seems like such a difficult way to get familiar with Haskell.
17:37:57 <Sonolin> well he asked about creating a blog & database in haskell
17:38:02 <robkennedy> Sololin: that's why I said "deploy" (I don't mean to imply you should understand me). I know plenty about Yesod and Servant, I use them daily. But I've only work on our intranet
17:38:27 <Sonolin> oh I see, so you really are seeking help with the deployment step
17:39:17 <robkennedy> Yeah 100%, although I don't have content to deploy yet so I'm open to formats
17:39:17 <Sonolin> sorry I don't have much production haskell experience.. but I'd imagine "stack" would be useful here, and the DB setup would be the least related to haskell
17:40:01 <Koterpillar> robkennedy: Haskell is easy to deploy, it's typically one binary
17:40:56 <robkennedy> But I've never deployed any binary to any server hosting service - all I've ever done is put HTML and JS on a webserver
17:41:01 <ertes> if you want to learn haskell, don't learn yesod though
17:41:13 <ertes> yesod is mostly magic (not in the good sense)
17:41:54 <Sonolin> ertes curious but can you recommend any full stack web frameworks for Haskell?
17:42:04 <Sonolin> i.e. for when Servant is too low level
17:42:23 <ertes> the ones i have experience with are happstack, snap, yesod
17:42:38 <robkennedy> Yesod makes my code segfault and makes GHC take 4GB, I'm no fan. It was a good way to learn Haskell though - the lore of "babby's first Haskell app is a Yesod CRUD website" held true for me
17:42:39 <ertes> each with different trade-offs
17:44:27 <ertes> Sonolin: but of course most frameworks in haskell are "full stack", as we have framework-agnostic libraries for pretty much everything
17:44:43 <ertes> yesod is perhaps the only odd one
17:45:05 <Sonolin> yea sure, I guess I'm just looking for something with session support, maybe some forms, and other such web-related stuff
17:45:12 <Sonolin> that doesn't rely on oodles of TH...
17:45:43 <robkennedy> So I'm in the somewhat odd position of (relative) resourcefulness in Haskell, but with no idea how the internet works
17:46:24 <ertes> Sonolin: pretty much all of them can do that, except for your last requirement, which disqualifies yesod
17:46:47 <Sonolin> well I'll check out the other two then, thanks 
17:47:33 <ertes> Sonolin: also check out scotty and spock…  i'm quite fond of the former
17:48:23 <Sonolin> thank you! I've actually been looking for that one
17:50:34 <Jello_Raptor> huh, shit :/ 
17:54:35 <Sornaensis> I read somewhere that ghc is "good at optimizing recursion that does is not explicit"
17:54:43 <Sornaensis> in the context of catamorphisms
17:54:53 <Sornaensis> does anyone know if this is true
17:58:01 <Cale> Sornaensis: I can't quite parse that sentence
17:59:01 <Sornaensis> Cale: sorry, "recursion that doesn't look like recursion"
17:59:03 <Sornaensis> something to that effect
17:59:15 <Cale> What does that mean?
17:59:30 <Cale> Something either looks like recursion or is not recursion.
18:00:11 <Sornaensis> hmmm
18:01:46 <Sornaensis> ohh, he said that ghc does a terrible job of optimizing recursive code
18:02:25 <dolio> That's also untrue.
18:19:17 <robkennedy> What algorithm would you use to find if a Vector Bool had only one true? Mine is 100x slower than the same word formula
18:20:42 <ertes> robkennedy: Vector Bool is a bad choice as a bit field
18:22:06 <ertes> robkennedy: if you use a Vector Word instead, skip over all zeroes, and check the popCount of non-zero words
18:22:17 <ertes> > popCount 0b1000101110
18:22:19 <lambdabot>  error:
18:22:19 <lambdabot>      • Couldn't match expected type ‘t0 -> t’ with actual type ‘Int’
18:22:19 <lambdabot>      • The function ‘popCount’ is applied to two arguments,
18:22:33 <ertes> > popCount 0xF0F0
18:22:36 <lambdabot>  8
18:23:26 <robkennedy> Yeah, so far Word and Set are the only decent options I've found is Word
18:24:05 <ertes> Integer works, too
18:27:28 <ertes> robkennedy: of course if you want to see if there is exactly one bit set in a bit field, depending on how the field is constructed you could get away without actually constructing it
18:28:00 <Sornaensis> dolio: cool
18:30:27 <Jannoo> good evening
18:30:52 <Jannoo> i do not understand this signature: (Fractional a, Ord a) => a -> Char
18:30:55 <Jannoo> isn
18:31:05 <Jannoo> isn't a fractional already ordered?
18:31:25 <ski> complex numbers aren't ordered
18:31:27 <geekosaur> no, because ^
18:34:04 <Jannoo> you guys are smart
18:34:06 <Jannoo> thanks
18:35:31 <rotaerk> yea well, complex numbers aren't real numbers, so there
18:36:10 <ertes> rotaerk: there are more counterexamples to that statement than i can list
18:36:49 <rotaerk> lol
18:37:12 <Jannoo> learning haskell = relearning math
18:57:53 <deadend> kk
18:59:30 <dfeuer> mniip: I'm not surprised it's tough. I would also not be surprised if it turned out to be utterly impossible.
19:02:50 <dfeuer> mniip: I haven't (yet) even come up with a way to fake it up with plain binary numbers standing in for the heaps.
19:03:26 <dfeuer> I conjecture that adding the heaps to the mix will be a hard slog but not conceptually difficult.
19:05:02 <jchia> I'm trying to use a directed-acyclic graph at run-time for job scheduling that I define at compile-time. Each vertex has a name (label) and some properties. The graph is specified by specifying each vertex together with its predecessor vertices (by name) (implying incoming arcs). An arc can also be explicitly added after its vertices have been defined. The graph specification has an error if an explicit arc or implied arc names an unknown vertex name. Another 
19:10:19 <dfeuer> mniip: the part that seems really hard, BTW, is the analogue of liftSort. I'm not sure how the arithmetic operations have to be structured to make that work, if it's possible at all.
19:13:35 <Jannoo> is there a chart of the hierchies of the different types and their type classes?
19:14:00 <Jannoo> i believe i searched in the past but found stuff that was missing a lot of stuff
19:15:02 <Jannoo> sorry for the novice questions
19:15:21 <dmwit> The report has one, and there's the Typeclassopedia.
19:15:44 <MarcelineVQ> jchia: your client failed to multline your message, soit ended at "unknown vertex name. Another"
19:15:54 <dmwit> Jannoo: https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1270006.3
19:15:58 <dmwit> ?where typeclassopedia
19:15:59 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:16:07 <jchia> MarcelineVQ: Thanks
19:16:09 <jchia> ... Another type of error is that the graph turns out to have a loop. Currently, I'm defining the graph at run-time using some data structures and discovering graph errors also at run-time, which is undesirable. How can I express/model the graph so that it's built at compile-time so that if it compiles, I know it has no errors?
19:16:31 <dmwit> Jannoo: But the open world assumption means no such chart can ever really be complete.
19:17:05 <dmwit> Jannoo: There's also `:i` in ghci to learn what GHC thinks are a type's or class' current instances.
19:19:17 <glguy> and then there's :info! to find them out even if they are out of of scope (but the package is loaded)
19:19:42 <dfeuer> glguy: I had no idea about that!
19:19:45 <Jannoo> thanks dmwit and glguy
19:19:59 <dfeuer> That sounds super-useful.
19:20:04 <Jannoo> the chart in the report doesn't make sense to me
19:20:09 <Jannoo> im sure im reading it wrong
19:20:23 <Jannoo> but why isnt num under the hierchy of ord
19:20:27 <dfeuer> Jannoo: it's not the best visual in the world. Also, a couple bits are out of date.
19:20:48 <dfeuer> Jannoo: complex numbers aren't ordered. Indeed, GHC no longer makes Num a subclass of even Eq.
19:21:02 <Jannoo> damn, keep forgetting about complex numbers
19:21:32 <dfeuer> Jannoo: be especially careful about Num and Enum. They're horribly unprincipled :(
19:22:03 <Jannoo> thanks dfeuer
19:22:07 <Jannoo> its still to click
19:22:29 <glguy> dfeuer: We added it about 5 years ago after some frustration with some lens code :)
19:24:36 <lpaste> Jannoo pasted “Do not understanding the type signature for output” at http://lpaste.net/354389
19:24:54 <Jannoo> why is the type for the output: number :: (Ord a, Num a, Num t) => a -> t
19:25:06 <Jannoo> shouldn't it be Integer?
19:25:22 <geekosaur> because negative numeric literals are weird in haskell
19:25:23 <glguy> No, the type of integer literals is:  Num a => a
19:26:20 <Jannoo> why is that? shouldnt it give us the most concrete type?
19:26:33 <geekosaur> although actually I think that one ought work...
19:26:44 <glguy> No, it tries to give us the most general type
19:27:13 <dfeuer> glguy: I'd love to talk to you about binary numbers sometime soon, but I can't right now.
19:27:41 <glguy> Um, OK :)
19:27:58 <Jannoo> but isn't that haskell kind of lying to us? 1 is not a double for example
19:28:06 <geekosaur> hm, nope, not negatove shenanigans
19:28:15 <glguy> Jannoo: Yes, 1 can be a Double
19:28:19 <Jannoo> but making 1 a Num means 1 can be a double
19:28:28 <glguy> > 1 :: Double
19:28:29 <Jannoo> isnt' 1.0 a double
19:28:30 <lambdabot>  1.0
19:28:50 <geekosaur> ahm,  right, not thinking...
19:29:01 <geekosaur> ok
19:29:18 <glguy> 1 :: Num a => a, and there's a Num instance for Double (this is great because it means we can do things like add Doubles)
19:29:31 <glguy> 1.0 :: Fractional a => a
19:29:36 <geekosaur> Jannoo, all numeric literals are polymorphic. one with a decimal can be any Num instance. if it has a decimal point, it can be any Fractional instance
19:29:38 <glguy> so we can use that at type double, too
19:29:43 <glguy> but not at type Int
19:30:04 <glguy> Jannoo: In some programming languages you can determine what type a number literal has from the literal itself
19:30:15 <glguy> like 1 might always be an int,  1L might always be a long int
19:30:21 <glguy> That's not Haskell, though
19:30:36 <Jannoo> i thnk that is exactly what is tripping me up glguy
19:30:45 <Jannoo> im thinking of literals in Java
19:31:36 <Jannoo> and thank you geekosaur as well
19:31:56 <Jannoo> this clears it up
19:32:04 <Jannoo> but im affraid im gonna make this mistake again
19:32:40 <Jannoo> and be back with the questions in the same vein
19:32:41 <Jannoo> ;/
19:35:29 <glguy> Jannoo: That's fine, you can come back and ask more questions
19:35:54 <Jannoo> :)
20:08:59 <dfeuer> glguy: I'm wondering if it's possible to do something like https://www.reddit.com/r/haskell/comments/63a4ea/fast_total_sorting_of_arbitrary_traversable/ efficiently without resorting to erasure. That requires doing no more than O(log n) proof work per element, which seems like it might or might not be just barely possible.
20:09:53 <dfeuer> (Replacing the pairing heap with something more structured, of course, like a binomial heap)
20:11:05 <dfeuer> This seems to require some efficient proofs of basic properties of binary representations, but the forms of proof are rather limited....
20:18:31 <glguy> dfeuer: I worked on some proofs about binary numbers in a fixed width context in Agda in the past https://github.com/copumpkin/bitvector/blob/master/Data/BitVector/Properties.agda#L88-L122
20:19:04 <glguy> We could look to see if things work out nicer before porting any of that to Haskell
20:19:23 <dfeuer> glguy: fixed-width? That doesn't seem too useful for my particular purpose; does it generalize well?
20:21:21 <dfeuer> glguy: BTW, I tried "faking up" the sort of thing I want to do with plain binary numbers in place of heaps, and the spot that I found hardest to approach was actually the "liftSort" function at https://gist.github.com/treeowl/9621f58d55fe0c4f9162be0e074b1b29#file-hstrav-hs-L41
20:21:35 <dfeuer> (well, the analogue of that, I mean)
20:22:10 <dfeuer> Things like associativity and properties of zero and commutativity all look like a horrible but straightforward slog.
20:22:33 <glguy> Would it be hard to make this a full repository instead of a list of pastes?
20:22:37 <dfeuer> [Oh, and depending on how things are arranged, I have concerns about runSort too)
20:23:58 <dfeuer> glguy: actually, michaelt made a repo of it (without my permission and without giving me any credit in the commits, which rankles a bit).  https://github.com/michaelt/traversable-sort/
20:24:36 <lpaste> moet pasted “which maybe effect is best?” at http://lpaste.net/354392
20:25:13 <glguy> dfeuer: Send him a message letting him know he's posting your code without permission
20:25:54 <dfeuer> glguy: I don't want to be too big a jerk, but I'll put up my own repo when I get a chance and let him know his isn't required any more.
20:26:19 <glguy> Someone taking your code and releasing it under their own name as author and providing a license ot other people make him the jerk
20:26:31 <glguy> https://github.com/michaelt/traversable-sort/blob/master/LICENSE
20:26:35 <dfeuer> Yes, I saw that.
20:26:50 <dfeuer> I'm going to assume he wasn't paying attention....
20:26:56 <glguy> Maybe, but that's his problem
20:27:00 <dfeuer> Yes.
20:27:30 <moet> hi #haskell, just pasted to ask about what convention is preferred to run an effect only when the Maybe _ arg is present?
20:27:45 <dfeuer> I'll take care of it soon.
20:27:56 <dfeuer> Have you any thoughts about the challenge?
20:28:29 <dmj`> moet: Data.Foldable.forM_ maybeValue ioAction
20:29:56 <moet> dmj`: hmm.. forM_ seems almost intentionally misleading :P 
20:30:02 <moet> but it's cute
20:30:29 <dfeuer> moet: misleading?
20:30:57 <dmj`> @typ forM_ (undefined :: Maybe a) (undefined :: a -> IO ())
20:30:59 <lambdabot> IO ()
20:31:20 <dfeuer> Speaking of such things, I realized that traverse_ is actually quite different from traverse.
20:31:28 <moet> dfeuer: for is associated with loops :)
20:31:40 <moet> dmj`: yeah, it's correct, it's just less readable than i want
20:32:03 <moet> thanks tho :)
20:32:15 <dfeuer> moet: yes, in Haskell we conflate data structures with control structures, which is great for programmers and horrible for compiler writers.
20:33:41 <ski> moet : think of it as looping over a collection that contains at most one element
20:33:41 <moet> hahaa.. don't tell the lispers that. they'll get jealous
20:34:07 <moet> ski: yeah, i get it.. it's cute
20:34:54 <Cale> moet: Perhaps forEachM would be clearer? But it's common enough to deserve a really short name.
20:34:57 <glguy> dfeuer: I haven't wrapped my head around all of this yet. Why is liftSort challenging in the binary context?
20:35:36 <Cale> moet: Oh, you're talking about the way we can use it with Maybe types...
20:35:44 <dmj`> moet: runIOIfJust = forM_, problem solved
20:35:49 <Cale> moet: Yeah, the original setting where it was defined was just for lists.
20:35:51 <dfeuer> glguy: I don't really quite understand why, TBH. I just know I was struggling :-/
20:36:04 <Cale> moet: But we've generalised a bunch of things like that to operate over other sorts of collections
20:36:08 <dfeuer> Things not reducing, or maybe reducing too much?
20:36:22 <dfeuer> And I couldn't wrap my mind around what was going on there.
20:37:21 <dfeuer> And then  I tried to fix it up and just made it worse.
20:37:47 <dfeuer> My current code is a godawful mess that probably needs to be thrown out (again).
20:40:54 * nshepperd suggests throwing a skew binary number system at the problem
20:42:00 <nshepperd> that seems to be the solution to all asymptotic complexity problems, from haskell talks i've seen :)
20:42:07 <dfeuer> Hah!
20:42:34 <dfeuer> Well, the skew binomial heap Okasaki presents seems too "flexible" to make it seem likely to be easy in this context.
20:42:42 <dfeuer> Maybe there's another form?
20:47:48 <dfeuer> glguy: it's quite possible that these struggles are just because I haven't developed much intuition about building formal proofs.
20:48:03 <dfeuer> And setting up operations to make those proofs easier.
20:48:12 <nshepperd> I don't actually understand any of these data structures, unfortunately
20:48:40 <glguy> That could be, or maybe it's just hard. I was just wondering about the particular type struggle you were encountering
20:49:08 <dfeuer> nshepperd: the skew stuff is complicated. A plain binomial heap is actually quite straightforward. Okasaki's explanation is very readable.
20:49:34 <dfeuer> glguy: this is one of those cases where I know that I do not know but I do not know *what* I do not know :-(
20:49:49 <dfeuer> I'll try to write up something sort of readable and come back with it and point to the troubles.
21:01:04 <adarqui> anyone have any favorite xml parsing library? i've never parsed xml in haskell.. not sure which library to use. i'm used to aeson/applicative parsers.
21:02:23 <MarcelineVQ> I had some luck with HXT, my use was quite limited though, just reading info from an imageboard
21:04:51 <adarqui> cool
21:11:14 <adarqui> i think im just going to convert the xml file to json, and parse the json file
21:11:16 <adarqui> seems easier hehe
21:19:48 <dmj`> what’s the best way to combine two Symbols into one
21:21:56 <glguy_> dmj`: with vim
21:22:22 <dmj`> glguy_: I was afraid of that :) 
21:23:05 <dmj`> we need type level Chars
21:24:10 <dmwit> Do the python thing. Who needs Char when you have String?
21:25:15 <glguy_> Yeah, type lists of single character symbols
21:27:08 <dmj`> glguy_, dmwit: yea, seems that will have to do for now. Oh the verbosity.
21:36:02 <dmj`> Had this idea about using the Generic Rep of a data type  to create SQL DDL statements. Would have been cool to see the SQL as a single Symbol, but alas.
21:38:47 <jhrcek> Could someone please explain to me what Monad instance is getting used in the following do block? http://lpaste.net/354395 Is it reader by any chance?
21:39:01 <jhrcek> I mean "(->) r"
21:39:48 <ski> @type randomR
21:39:50 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
21:40:07 <jhrcek> I know i can write it more succintly, this is just simplified example from haskellbook.com. I'm just unsure about the do block
21:40:08 <ski> yeah, `(StdGen ->)'
21:40:44 <ski> the `do'-expression could be abbreviated to just `randomR (1,6)', by the right neutral element law
21:42:10 <jhrcek> I'm wondering, Is there a way to tell in general what instance of monad is going to be resolved to in the do block?
21:42:39 <ski> looking at the types
21:43:04 <ski> the type of `randomR (1,6)' there is `StdGen -> (Int,StdGen)'
21:43:24 <ski> which is `(StdGen ->) (Int,StdGen)', so `(StdGen ->)'s the monad
21:44:36 <Jello_Raptor> hmm, does anyone know how I should generate a random (ideally uniform) sample from "Set of lists of nats with length L and sum N"? 
21:44:40 <jhrcek> ski: ok, thanks
21:44:48 <MarcelineVQ> > do { (x,y) <- randomR (1,6); _; } -- holes can help if it's too inscrutable
21:44:50 <lambdabot>  error:
21:44:50 <lambdabot>      • Found hole: _ :: t -> b
21:44:50 <lambdabot>        Where: ‘b’ is a rigid type variable bound by
21:44:51 <MarcelineVQ> > do { putStrLn "foo"; _; }
21:44:53 <lambdabot>  error:
21:44:53 <lambdabot>      • Found hole: _ :: IO b
21:44:53 <lambdabot>        Where: ‘b’ is a rigid type variable bound by
21:44:58 <Jello_Raptor> getting that distribution sorta right isn't obvious to me
21:45:37 <ski> @type do { (x,y) <- randomR (1,6); ?hole }
21:45:39 <lambdabot> (?hole::t -> b, RandomGen t) => t -> b
21:46:54 <ski> hm, if it was just lists with length and sum, it'd be multinomial ..
21:48:01 * ski presumes Jello_Raptor is thinking of finite (sub)sets
21:48:31 <monochrom> ski, I think it is just that. The "set of" is there because "a random sample from that set". This means a programmer should strip the "set of" and just produce one list.
21:48:46 <dmj`> well well then https://ghc.haskell.org/trac/ghc/ticket/12162
21:50:10 <MarcelineVQ> dmj`: neat
22:03:45 <dmj`> te3 :: Proxy (AppendSymbol "type" "level") -> Proxy "typelevel"
22:03:51 <dmj`> coming to a GHC near you
22:05:09 <nshepperd> dmj`: you could probably add that today, by writing a ghc type checker plugin similar to the ones for Nat
22:05:34 <nshepperd> manufacturing evidence that "type" ++ "level" ~ "typelevel"
22:06:08 <nshepperd> and KnownSymbol instances for these things
22:06:36 <dmj`> nsheppard: nixpkgs might have the latest ghc
22:06:39 * dmj` checks
22:06:50 <dmj`> by latest I mean head
22:20:15 <dmj`> heh, https://gist.github.com/dmjio/8ce1b87611aca8cdccc863c73e60cd8d
22:25:47 <mikeplus64> is there a way to get stack runghc to actually compile a hs file then run it? i think at the moment it simply uses runghc which runs the bytecode interpreter
22:29:48 <cocreature> mikeplus64: it seems like at that point you just want ghc. maybe write a wrapper script for "ghc File.hs -o out && ./out" or something like that
22:43:09 <iqubic> Hello guys.
22:48:39 <joe9> I am trying to figure out how a bytestring is internally represented. For example, Is there a size at the beginning of the memory? How big is this size byte? Is there a null character at the end?
22:48:44 <joe9> any suggestions, please?
22:49:00 <joe9> I cannot find anything in the Data.ByteString hackage module about it.
22:49:22 <dmj`> joe9: did you check the source
22:50:08 <joe9> no. Data.ByteString.pack? it is calling packBytes. Let me check that.
22:50:37 <pacak> joe9: It's a raw block of memory + two ints - one for offest to beginning, one for length
22:50:46 <pacak> joe9: There's no null character
22:51:08 <pacak> http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString-Internal.html#ByteString
22:51:16 <joe9> Thanks. pacak
22:51:44 <johnw> joe9: hi
22:51:53 <johnw> joe9: internally, ByteString use a data structure called PS
22:52:14 <johnw> it has three fields: Ptr into a block of pinned, allocated memory; an offset into this region, and a length of bytes used
22:53:29 <joe9> johnw: Thanks.
22:56:40 <cocreature> is there any particular reason why bytestring uses a ForeignPtr instead of a ByteArray#?
22:57:20 <cocreature> it does use ByteArray# for short bytestrings which makes this even more confusing
22:58:19 <pacak> cocreature: I suspect historical reasons.
22:59:31 <cocreature> pacak: it’s slightly disappointing how every time I expect that there is some deep reason for how something it is implemented, it turns out it’s just due to historical reasons :)
22:59:50 <johnw> it uses ForeignPtr, but it's a very special kind
22:59:54 <johnw> it contains no finalizer
23:00:08 <johnw> it's just there so that the GC gets involved once the ByteString is unreferenced
23:00:21 <cocreature> right, but GC also collects ByteArray#
23:00:40 <johnw> it allocates the ForeignPtr using mallocPlainForeignPtrBytes, which has some very specialized behavior
23:01:22 <johnw> internally, this function calls newPinnedByteArray#
23:01:31 <johnw> so, I believe it *is* a ByteArray#
23:01:39 <cocreature> oh ok
23:02:09 <iqubic> What is ByteString?
23:02:19 <cocreature> iqubic: https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html
23:02:44 <johnw> if you ever want to deal with "chunks of bytes" in Haskell, you often use ByteString
23:02:47 <pacak> A pinned one which might result in memory fragmentation if you are not careful.
23:02:56 <johnw> yes, quite true
23:03:42 <cocreature> that’s why there is ShortByteString :)
23:18:45 * ski looks at Jello_Raptor
23:18:58 * MarcelineVQ looks at niteria
23:26:05 * pacak looks around
23:33:22 <volhovm> Hello everyone. Does servant have any out-of-box support of multipart form data except for the `servant-multipart` package?
23:33:38 <volhovm> Why is `servant-multipart` so unpopular then? 
23:35:13 <cocreature> volhovm: what makes you think it’s unpopular?
23:35:20 <johnw> if anyone is willing, I'd appreciate comments on some slides meant to show practical uses of lenses: https://github.com/jwiegley/putting-lenses-to-work
23:35:22 <volhovm> 17 downloads on hackage
23:35:34 <volhovm> http://hackage.haskell.org/package/servant-multipart-0.10
23:35:40 <johnw> i'll be presenting it Saturday at BayHac, so open an issue if you have comments and I'll integrate them tomorrow
23:35:48 <pacak> Thu Mar  2 01:25:19 UTC 2017
23:35:49 <cocreature> iirc the download numbers are mostly broken atm. they don’t track stack and I think the hackage cdn also isn’t counted
23:37:00 <volhovm> cocreature: got it, thanks :)
23:37:42 <cocreature> volhovm: also speaking from personal experience, I usually just have APIs that send and receive json and don’t do any file uploads. but then again I also do very little webdev :)
23:38:51 <Jello_Raptor> ski: oh cool, let me see if I can figure out how turn this into a function I can use :)
23:39:14 <wavewave> pinned bytearray cannot be used in compact region.
23:39:49 <cocreature> wavewave: compact region as in the fancy stuff we get in 8.2?
23:39:59 <wavewave> yes.
23:40:54 <wavewave> cocreature: you can see some examples here: https://github.com/ezyang/compact
23:42:12 <wavewave> it allows for manual memory management in a sense.
23:42:35 <cocreature> luckily I’m rarely in the position where I need that :)
23:43:36 <wavewave> it should be very useful if a program hold a large long-running resource in the heap.
23:45:27 <MarcelineVQ> johnw: Getter Iso and Setter show up suddenly in the vocabulary review but they aren't mentioned previously in slide form so I assume it's review of verbal items. This is really quite nice btw, first time seeing most of these and makes a good case for them
23:45:39 <cocreature> yeah I can definitely see it being useful. I just doubt that I personally need it :)
23:52:27 <wavewave> i also doubted that i needed it until when I had to parse ~100GB JSON file. ;-) 
23:53:13 <MarcelineVQ> what about compact regions assists that sort of task?
23:56:27 <cocreature> MarcelineVQ: you can put the parsed json value in a compat region and avoid the GC tracing through it
23:56:54 <wavewave> cocreature: yes
23:57:45 <wavewave> I think it can reduce GC overhead significantly especially when doing parallel processing. 
23:58:37 <cocreature> wavewave: I’m confused. how is the compact region freed? the examples don’t seem to free explicitely and I don’t see anything in the API for that.
23:59:08 <cocreature> oh it’s still GCed
23:59:12 <wavewave> my program used almost over 80% of time doing GC when i used 20 CPUs. I want that GC time waste to be reduced. 
