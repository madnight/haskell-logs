00:00:39 <tsahyt> so instead I wrapped a type describing a wave, which itself was a behavior in the FRP part and was shared with JACK via an IORef. the JACK callback would then just evaluate as much as it needed of that wave, put it in a buffer and return. That got CPU usage down to <1%
00:01:06 <Cale> tsahyt: Well, that is also insanely higher frequency than most users are actually using it. I think there's some potential to eventually make that kind of thing perform well, but no promises about whether it'll require special compiler support.
00:01:40 <tsahyt> unfortunately, the sampling theorem mandates this kind of frequency for audio.
00:01:47 <Cale> Of course :)
00:01:54 <cocreature> arguably you shouldn’t write audio software in a high-level language such as haskell anyway :)
00:02:01 <cocreature> at least not realtime audio software
00:02:03 <Cale> cocreature: You're crazy
00:02:05 <Cale> hahah
00:02:13 <tsahyt> but using this sort of wave trickery, you can get the frequency of FRP events down and everything works :)
00:02:22 <tsahyt> cocreature: but I want to :P
00:02:29 <cocreature> Cale: :)
00:03:04 <ongy> good old walkman days. Where we had ocaisonal skips because reasons. just that it's GC instead of a bump
00:03:38 <tsahyt> something something linear types
00:04:00 <tsahyt> but in my tests I actually had no problems with the GC, since I was never handling significant amounts of data.
00:04:01 <Cale> I wonder if Ryan has any plans with respect to compact regions
00:04:11 <Cale> It's quite plausible
00:04:13 <tsahyt> as long as you're just processing buffers of reasonable size, I don't think it'd be much of an issue
00:04:46 <ongy> how often does major GC happen?
00:05:02 <Cale> It probably depends, but once every 5 minutes or so?
00:05:53 <Cale> At least, that's what it was back in 2011 the last time I cared about that statistic
00:06:53 <mniip> Cale: bntr?
00:07:05 <Cale> mniip: hm?
00:07:05 <bntr> hiya?
00:07:49 <Cale> mniip: I was about to ban because of a misbehaved bot, but bntr showed up and apologized for it, so I cancelled that.
00:07:59 <mniip> ah ha
00:08:06 <mniip> okay!
00:33:36 <tsahyt> so with the constraints based solution I was unable to pattern match on an explicit proof that c ~ Gcd c n, now with the ghc-typelits-extras based solution it's unable to infer that n ~ Gcd n n.
00:33:41 <tsahyt> this is getting slightly frustrating
00:34:32 <tsahyt> and unfortunately I cannot mix the two approaches because they use different type families for the gcd
00:37:00 <tsahyt> I'll just abuse fromJust then and leave that final proof obligation of gcd being idempotent for now.
00:37:13 <Cale> tsahyt: You've gotta expect dependently typed programming in Haskell to be pretty frustrating though
00:37:24 <tsahyt> Cale: I do, but I'm stubborn like that
00:37:27 <Cale> Given that it's not actually dependently typed :P
00:38:11 <tsahyt> there's a bit of a backstory here. In a course I'm attending we've been told to first implement factorization in a language of our choice and then in Why3 which utilizes SMT underneath to check against specification
00:38:44 <tsahyt> so I thought it'd be a fun exercise to write a haskell implementation with the same static guarantees. or at least almost the same. I want to get as close as possible.
00:39:14 <tsahyt> just to show that it's possible to get very strong guarantees in a production ready language today by just utilizing types. the production ready part also rules out idris.
00:40:38 <tsahyt> in Haskell I've hit the same roadblock as usually. I could quickly define a type that only allows valid factorizations, but actually building values of that type at runtime is tricky.
00:42:10 <Cale> ah, that's a fair enough motivation
00:46:21 <cocreature> tsahyt: arguably idris is about as production ready as the almost dependently typed part of Haskell :)
00:47:20 <lerax> almost all the libs I see is dependent of idris
00:47:42 <tsahyt> cocreature: even then I've immediately been turned off by it being strict by default. I've actually written at least part of the factorization algorithm and even for this small example I found laziness to just be nicer
00:48:11 <tsahyt> to be fair, all I'd need there are lazy lists so I can use them as a control structure, but still
00:48:33 <tsahyt> I know there are people complaining about lazy evaluation in Haskell, but imo it's just the better default
00:48:38 <cocreature> tsahyt: oh I’m not arguing that you should be using idris. I just don’t think the production-ready argument is very strong in this area
00:48:58 <tsahyt> the more time I spend with this, the more I'm inclined to agree
00:49:33 <cocreature> also competing with SMT solvers using types or even type-theory based theorem provers is really hard when it comes to proving properties about numbers
00:49:43 <tsahyt> though to be fair, a lot of my problems here are due to my inexperience with this sort of thing
00:50:10 <tsahyt> cocreature: I noticed that. I've also started a liquid haskell based solution, but didn't get too far with it yet.
00:50:38 <tsahyt> I find it rather interesting how I'm routinely expressing structural invariants in types, but arithmetic properties turn out to be so much harder to work with
00:51:06 <cocreature> you can ofc build a typechecker plugin that uses an SMT solver to resolve constraints (and I think I’ve seen that for GHC somewhere) but at that point you are just using an SMT solver :)
00:52:26 <tsahyt> well, so far I can now find the smallest prime factor of a composite (or determine that the input is not composite)
00:52:30 <tsahyt> now on to the recursion
00:58:44 <cocreature> tsahyt: it might be a bit more pleasant if you build your own inductively defined natural number type and lift that to the typelevel via DataKinds
00:58:56 <cocreature> GHC.TypeLits is especially annoying because it’s builtin magic
00:59:45 <tsahyt> I've found that over the last year or so it has become less of a pain to work with as there are now libraries cropping up that make good use of it
01:00:28 <cocreature> I’m mostly annoyed by having to pass around the KnownNat constraints everywhere instead of getting some singleton-like interface where I can just get the value by pattern matching
01:08:26 <mniip> cocreature, an idea of a library has been haunting me
01:09:04 <mniip> I mean, I don't think there's a way to GADT-ize typelits safely, so
01:09:29 <mniip> you're better off doing unsafeCoerce in a library where it can be checked by others
01:09:44 <mniip> than making ad-hoc implementations of the same thing
01:10:01 <tsahyt> │    • Could not deduce: (n1 * (n0 + 1)) ~ (n + 1)
01:10:02 <tsahyt> │      from the context: (Divides n1 (n + 1), KnownNat n1)
01:10:04 <tsahyt> so close and yet so far
01:10:31 <cocreature> mniip: I’m not sure I understand you correctly. are you talking about something like Data.Constraint.Nat from the constraints package?
01:11:23 <mniip> ooh
01:11:27 <mniip> that looks nifty
01:11:44 <mniip> yeah
01:11:48 <cocreature> well as tsahyt can tell you, it’s not super pleasant to work with :)
01:11:52 <mniip> edwardk beat me to it as always
01:12:16 * edwardk shrugs.
01:12:31 <tsahyt> it's not so much unpleasant as it didn't work for my case. At one point I needed a proof that c ~ Gcd c n, which I can get out by using sameNat and pattern matching on the Refl
01:12:46 <mniip> cocreature, I had a different construction in mind but yes, this works just as well
01:12:48 <tsahyt> but due to things I do not understand properly GHC just refused to do that with the Gcd in constraints
01:12:56 <edwardk> the combinators in Data.Constraint.Nat aren't exhaustive, they are just 'what i could think of in the moment'
01:12:57 <tsahyt> and gave me an inaccessible code error
01:13:02 <edwardk> i wrote it over the course of an hour or two
01:13:05 <edwardk> and then forgot about it
01:13:22 <tsahyt> I like the idea of using :- to prove things to the compiler though
01:13:32 <tsahyt> in a way I'm more fond of it than pulling in some magical type checker plugin for it
01:13:39 <edwardk> *nods*
01:14:04 <tsahyt> edwardk: is it possible that I get this inaccessible code error because Gcd has no equations?
01:14:27 <tsahyt> the paste is still somewhere in my logs if you need a minimal example
01:14:29 <edwardk> i've debated about writing some template haskell that would let you write the stuff at the value level and lift it to related type families on types with singleton representations easily
01:14:32 <cocreature> tsahyt: can you match on timesDistributesOverGcd to get to c * Gcd 1 n and then match on gcdOne or something like that?
01:14:50 <edwardk> tsahyt: not sure. did you paste code somewhere?
01:15:00 <tsahyt> edwardk: I did, let me dig up the link
01:15:32 <tsahyt> edwardk: this is the most minimal example I could come up with http://lpaste.net/354432
01:15:56 <mniip> edwardk, cocreature, what I had in mind was more like  p n -> (p 0 -> r) -> (forall m. p (1 + m) -> r) -> r
01:16:15 <mniip> spiced with some KnownNat probably
01:16:25 <cocreature> mniip: ah so an induction principle
01:16:30 <mniip> kinda
01:16:35 <bollu> doesn't GCD make this process somewhat undecidable?
01:16:38 <mniip> pattern matching on zero/succ rather
01:16:59 <mniip> but yes, the idea was to implement various inductions
01:17:02 <tsahyt> bollu: sameNat evaluates at runtime, hence why it needs the KnownNat constraints, and why I do this entire construction using Maybe
01:17:03 <mniip> I just never decided which
01:17:06 <cocreature> oh right that’s not induction
01:17:12 <bollu> tsahyt: I see
01:17:17 <mniip> e.g
01:17:48 <mniip> data Binary = Zero | TimesTwo Binary | TimesTwoPlusOne Binary
01:17:51 <mniip> is not a singleton
01:17:57 <mniip> because Zero = TimesTwo Zero
01:17:59 <edwardk> tsahyt: ghc is being a bit over-eager there
01:18:07 <mniip> data Binary = Zero | TimesTwoPlusOne Binary | TimesTwoPlusTwo Binary
01:18:09 <mniip> is a singleton
01:18:13 <mniip> but is annoying to work with
01:18:19 <edwardk> odd, i usually get to treat type families like that uninterpreted functions then perform equations on them
01:19:05 <cocreature> mniip: yeah I see what you mean. looking forward to your library :P
01:19:05 <mniip> hmm
01:19:12 <mniip> I suppose I could sketch something
01:19:18 <mniip> like
01:19:25 <tsahyt> edwardk: the way I read that was that GHC believes that there's no way to ever build Refl and hence thinks it's all dead code anyhow
01:19:32 <mniip> a lot of recursion schemes make sense only for nonzero naturals
01:19:42 <tsahyt> this got particularly apparent when I added a Nothing case underneath, which then compiled with just a warning iirc
01:19:56 <edwardk> if i drop the 'where' from the type family definition for Gcd does it work?
01:20:35 <edwardk> testing real quick
01:21:20 <edwardk> damn, same result
01:22:37 <mniip> edwardk, you could define a broadly-kinded family with an equation
01:22:52 <mniip> and then shrink it to the required kind with a tysyn
01:23:16 <mniip> implying that the equation doesn't apply to the restricted kind
01:23:53 <edwardk> gcdNat isn't a KnownNat, so you first need to use gcdNat to make it known
01:23:59 <edwardk> er GcdNat
01:24:54 <bollu> tysyn  = ?
01:25:04 <mniip> type synonym
01:26:02 <tsahyt> edwardk: but I am using gcdNat here to even make the sameNat typecheck, since it requires two KnownNats
01:26:08 <tsahyt> do I need to use it again somewhere?
01:26:25 <edwardk> i'm guessing so, trying to figure out what is going on
01:27:01 <edwardk> i'm _guessing_ that ghc has a bug here somewhere though, it shouldn't be ruling this out as inacessible, once i fix the type family to be open rather than closed it has no grounds to assume that the type can't reduce in another context
01:28:23 <edwardk> when i have type family Gcd :: Nat -> Nat -> Nat where then ghc is probably in a good place theoretically ruling out the match
01:28:33 <edwardk> but without the where? it seems its on shaky moral ground
01:28:44 <tsahyt> on a related note, from what I can see axiom is defined in much the same way as unsafeCoerceConstraint. so if I find myself missing any entailments to prove a property, I could use unsafeCoerceConstraint to introduce it (assuming that I've proven it).
01:28:49 <edwardk> articulating that in a form that'd convince simon/richard is another matter
01:28:59 <tsahyt> oh wait, no that's wrong
01:29:22 <edwardk> yeah axiom just basically lets you force the type checker to believe you that two types are equal
01:29:35 <edwardk> axiom :: forall a b. Dict (a ~ b) -- is just evil
01:29:49 <tsahyt> it is, but from what I can tell it's a necessary evil for this kind of functionality
01:29:57 <edwardk> yep
01:30:09 <bollu> edwardk: do you know some place where I can read about how to use ConstraintKinds?
01:30:20 <bollu> it seems very useful, but I don't know how :)
01:30:22 <edwardk> i wrote a blog post a few years ago
01:30:42 <edwardk> http://comonad.com/reader/2011/what-constraints-entail-part-1/
01:30:54 <edwardk> that post was the first attempt i know of to use constraint kinds in interesting ways
01:30:59 <mniip> edwardk, convince them about what
01:31:06 <mniip> your unsafeCoerce usage?
01:31:26 <bollu> edwardk: ooh, thanks
01:31:30 <edwardk> mniip: convince them that ghc is being too eager to rule out that Refl as unreachable code
01:31:39 <edwardk> its nothing to do with unsafeCoerce
01:31:40 <mniip> ah
01:31:43 <mniip> well
01:31:52 <mniip> it's kinda obvious when the tyfam is open
01:32:01 <edwardk> and more to do with treating a type family with a missing case as an uninterpreted function / stuck symbol
01:32:13 <mniip> you could add an equation and make it outright wrong
01:32:42 <edwardk> nothing prevents a module that we're not in adding stuff to the type family that would 'unstick' things in another context.
01:32:57 <edwardk> trick is articulating it in a way they'll accept
01:33:10 <edwardk> and that doesn't let in all sorts of other crap
01:33:55 <tsahyt> why is it important that it can flag something as inaccessible code anyhow? from a correctness perspective that is.
01:34:05 <edwardk> https://ghc.haskell.org/trac/ghc/ticket/11066
01:35:44 <tsahyt> all I wanted to do was implement an unreasonably type safe factorization algorithm, and now I've first submitted a PR to an edwardk library, and then encountered a compiler bug..
01:36:00 <tsahyt> so it goes. I guess I'll have to wait then
01:36:57 <tsahyt> unfortunately, the type checker plugins broke somewhere else, and with them I can't really write up a proof. or maybe my code is just wrong.
01:37:55 <cocreature> tsahyt: http://lpaste.net/354446 seems to work
01:39:17 <cocreature> but only with the explicit type signature
01:39:20 <cocreature> hm
01:39:51 <tsahyt> cocreature: what is the timesNat and second gcdNat for?
01:40:00 <tsahyt> I don't quite understand why this would work and the other one doesn't
01:40:35 <cocreature> tsahyt: ignore that. it works once you add a type signature even for your old version
01:41:01 <tsahyt> hmm, the original code where the numbers weren't fixed had a type signature and didn't work.
01:44:17 <tsahyt> well at least I still get a warning
01:44:35 <cocreature> yep but the version I posted actually evaluates to ()
01:45:26 <tsahyt> it still works with a case alternative for Nothing and returning Maybe ()
01:45:47 <tsahyt> but as soon as I want to actually use the n ~ Gcd n m, I get the error again
01:47:12 <tsahyt> http://sprunge.us/RCaH?hs
01:47:31 <tsahyt> unrelated, does lpaste have a way to be used from the command line?
01:52:25 <edwardk> tsahyt: i added your code to the issue i linked
01:53:38 <seequ_> Is there any nifty function to split a list to arbitrarily many lists at a specific item? So, a -> [a] -> [[a]] or (a -> Bool) -> [a] -> [[a]]
01:53:52 <cocreature> even http://lpaste.net/354448 fails with the same error
01:54:57 <cocreature> seequ_: are you looking for https://hackage.haskell.org/package/extra-1.5.2/docs/Data-List-Extra.html#v:wordsBy
01:55:01 <tsahyt> edwardk: thanks for reporting this in the right place! I searched for a bit last night and didn't find anything relevant to the error.
01:55:20 <seequ_> cocreature: yup!
01:55:58 <tsahyt> about your comment on (+), I have tested this with (n + 2) ~ (2 * n) for some n as input, and it did work after using the appropriate axioms from Data.Constraint.Nat.
01:56:18 <tsahyt> so it might not always break I guess
01:57:00 <edwardk> the issue looks to me that ghc gets really picky when it finds a term that doesn't have type variables in it
01:57:19 <edwardk> when in doubt, move back a step then make the combinator parameterized in a more general fashion
01:57:30 <edwardk> then use that to prove your more specific fact
01:58:03 <edwardk> it thinks it should be able to compare `Gcd 3 6` directly as it doesn't involve any type variables
01:58:17 <edwardk> and there isn't a type instance matching it that it can see
01:58:27 <tsahyt> edwardk: the issue originally came in a setting where I'd be getting a SomeNat, then matching out the specific Nat c and checking for c ~ Gcd c (n + 1), where n was given by the type signature
01:59:03 <cocreature> seequ_: it’s also in the "split" package if you prefer to depend on that over extra
01:59:26 <tsahyt> edwardk: so in this case it was fully polymorphic
01:59:36 * edwardk shrugs.
01:59:43 <edwardk> it seems like there be bugs in ghc land ;)
01:59:54 <tsahyt> luckily I hardly ever encounter one
02:00:04 <edwardk> they tend to be in crazy corner cases like this
02:00:10 <tsahyt> and this isn't exactly critical code that I'm working on right now, it's really just a toy to see how far I can push the type system
02:00:16 <tsahyt> and it seems I've pushed it a bit too far
02:00:26 <edwardk> compared with scala? i'll take it =)
02:01:11 <tsahyt> the most I usually ask from typelits is vector bounds and the like.
02:01:22 <edwardk> likewise
02:02:41 <tsahyt> I've now spent many hours on this problem actually, and I started out with an implementation that could be proven correct via equational reasoning within a matter of minutes. I suppose there's a lesson to be learnt here
02:03:02 <cocreature> tsahyt: proving things is hard? :)
02:03:25 <cocreature> or rather convincing computers that your proof is correct is hard
02:03:38 <tsahyt> cocreature: rather that pulling everything into types will lead to an explosion in complexity
02:04:45 <tsahyt> and that there's a triviality threshold where it just doesn't pay anyhow. I mean I've spent considerable effort trying to make the compiler understand that if n `mod` x == 0, x actually divides n.
02:05:59 <tsahyt> (technically I ended up doing it via Gcd but oh well)
02:12:55 <edwardk> tsahyt: add an axiom
02:14:23 <tsahyt> Mod n x ~ 0 :- Divides x n? but then I still need to take the value level check to the type level and end up with much the same problem I think
02:14:31 <tsahyt> unless the problem doesn't exist for Mod for some reason
02:16:28 <KunoMark> Goodest of mornings to you all!
02:17:08 <abhiroop> I am stuck with a problem in parsing using ReadP. Can someone help? http://lpaste.net/354450
02:21:09 <KunoMark> How do I do spawn-and-forget, with exception safety, for example when writing an asynchronous server that receives requests and spawns threads to process them?
02:21:37 <cocreature> KunoMark: what do you mean by exception safety in that context?
02:22:16 <KunoMark> cocreature: I mean, exceptions in child threads bubble up to parents. Basically, using the Async library.
02:23:00 <KunoMark> cocreature: A crude way to spawn-and-forget is to use forkIO, but then exceptions do not propogate to the parent, and one misses out on errors.
02:23:41 <cocreature> KunoMark: and you can’t use wait because you don’t want your main thread to block?
02:23:51 <KunoMark> Async allows you to get child exceptions, but only if you `wait` for the result of the child thread, meaning, crudely, you are blocked on the child thrwad
02:24:01 <KunoMark> Exactly! cocreature
02:24:47 <cocreature> KunoMark: make a separate thread that only “waitAnyCatch"es and then throws that exception asynchronously to your main thread
02:25:00 <KunoMark> Let me whip up a quick paste to show you what I'm currently doing...
02:25:13 <KunoMark> Huh? @cocreature
02:27:19 <cocreature> KunoMark: let me make an example
02:30:59 <cocreature> KunoMark: http://lpaste.net/354452 should do what you want I think
02:31:39 <KunoMark> Here's how I'm doing it currently, cocreature: http://lpaste.net/354453
02:31:49 <KunoMark> Let me take a look at your example. Thanks. :-)
02:33:36 <KunoMark> Oh! That's very smart, cocreature. Seems about perfect!
02:33:56 <KunoMark> I fee a bit dirty about reverting back to forkIO, though, but hey...
02:34:14 <KunoMark> As long as it's exception-safe, I'm happy. :-)
02:38:37 <cocreature> KunoMark: http://lpaste.net/354454 is probably slightly safer
02:39:20 <KunoMark> Why's that better, cocreature?
02:39:36 <KunoMark> Please remind me what `mask` does in this context?
02:39:48 <mniip> cocreature, edwardk 
02:39:52 <cocreature> mask blocks async exceptions
02:39:56 <lpaste> mniip pasted “typelit singletons” at http://lpaste.net/354455
02:40:16 <cocreature> KunoMark: I guess it doesn’t matter too much in this case
02:41:18 <iqubic> How good is the gloss-juicy library at interfacing between the JuicyPixels library and gloss?
02:41:35 <iqubic> Is it the right thing to use? Or not?
02:41:43 <KunoMark> Hmm... I need to think deeply and read up on the implications of what you said, cocreature.
02:41:57 <cocreature> KunoMark: read simon marlows book on this
02:41:57 <KunoMark> Thanks so very much for your help! :-D :-D
02:42:10 <KunoMark> Yes, I was thining I should. :-D
02:43:39 <iqubic> So, what do people think of the gloss-juicy library?
02:46:52 <cocreature> mniip: neat
02:48:07 <mniip> cocreature, now
02:48:12 <mniip> I wanted to include some other stuff
02:48:23 <mniip> like a binary induction scheme and the like
02:48:32 <mniip> but I'm not sure which ones would be useful
02:48:54 <cocreature> mniip: my main complaint is that the cases in your induction scheme are in a different order than your data constructors :P
02:49:10 <mniip> oh but
02:49:19 <mniip> undoubtedly, N = Z | S N
02:49:34 <mniip> yet induce looks so much like foldr
02:49:34 <cocreature> exactly, so your induction scheme should reflect that :)
02:55:24 <Adeon> iqubic: I just checked gloss-juicy documentation and it looks okay, it takes juicypixel images and outputs gloss pictures, which is pretty much what I would expect of such library
02:55:27 <Adeon> plus it has some convenience functions
02:55:38 <Adeon> I mean, this is all of the library right here: https://hackage.haskell.org/package/gloss-juicy-0.2.2/docs/Graphics-Gloss-Juicy.html
02:55:41 <iqubic> So if I want to create something like the mandlebrot set, how would JuciyPixels help me.
02:56:55 <Adeon> juicypixels is about loading and manipulating images and gloss already have pictures then I think it would not really help you
02:57:08 <Adeon> IIRC it does have that one convenient function where it calls your function for all pixels to generate an image
02:57:13 <Adeon> which could be used to make a mandelbrot set image
02:57:17 <Adeon> and then convert that to gloss
02:57:48 <Adeon> you can probably do that in gloss too, just not sure if it has the relevant convenience functions
02:57:54 <Adeon> which would mean some more work
02:58:52 <Adeon> https://hackage.haskell.org/package/JuicyPixels-3.2.8.1/docs/Codec-Picture.html look for `generateImage`, that might be what you are looking for
02:58:52 <iqubic> Adeon, what function does JuicyPixels have that would take a function, and create an image from that?
02:59:03 <Adeon> see above
02:59:22 <Adeon> you give it width and height of the image and then a function and juicypixels will call it for every pixel
02:59:38 <Adeon> and in this function you can the mandelbrot set or whatever computation you want
02:59:44 <iqubic> That looks like It will work for me.
03:00:15 <Adeon> there's an example that writes to png; if you want it to gloss you can maybe use that gloss-juicy library on the resulting image
03:00:21 <Adeon> or maybe save it to disk and load it from there
03:00:22 <iqubic> But can I do the same with gloss only?
03:00:45 <Adeon> I think you can do the same with gloss as well, it's just that it doesn't have readily available functions (skimming through it's documentation)
03:00:56 <Adeon> so you sort of have to manually implement `generateImage`-like function in gloss
03:00:56 <iqubic> I'll look for something.
03:01:03 <iqubic> Ah, I see
03:01:44 <Adeon> https://hackage.haskell.org/package/gloss-1.10.2.3/docs/Graphics-Gloss-Data-Bitmap.html looks like there are functions to make gloss pictures out of foreignptrs and bytestrings
03:02:00 <Adeon> those would be the low-level interface and on top of that you would implement such a function
03:02:03 <iqubic> Why does gloss picture data have kind *? and what does that mean?
03:02:04 <Adeon> unless I missed something else in gloss docs
03:02:09 <iqubic> https://hackage.haskell.org/package/gloss-1.11.1.1/docs/Graphics-Gloss-Data-Picture.html
03:02:27 <Adeon> it means it doesn't take any type parameters
03:02:35 <Adeon> data Picture :: * means the same as data Picture actually
03:02:41 <Adeon> I'm not actually sure why it's there
03:03:34 <Adeon> I think the docs pick up the explicit kind definition if it's written like that in the source code
03:03:49 <Adeon> and maybe there's a reason they did that explicitly behind the scenes but it isn't apparent in the documentation
03:04:04 <iqubic> Ah. I see.
03:04:22 <Adeon> either that or there is something about kinds I don't know about
03:04:56 <iqubic> No. I think that it actually takes zero arguments.
03:06:48 <Adeon> similar thing happens with ScopedTypeVariables, if you specify e.g. "func :: forall a. a -> a" to get the scoping of 'a' right then that forall shows up in documentation
03:06:53 <mniip> Adeon, because the datum is imported from another package
03:07:09 <mniip> I think that's relevant, at least
03:07:22 <merijn> Adeon: I suspect Picture is written using either GADTSyntax or something causing it to render like that?
03:07:33 <Adeon> no idea
03:07:55 <Adeon> importing it from another package would be a reason although I don't know why it works like that
03:07:59 <mniip> I mean, e.g
03:08:05 <iqubic> I think that there is no convienent way to create a generateImage function with just gloss functions.
03:08:05 <mniip> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:StateT
03:08:15 <mniip> likewise mtl reexports a datum from transformers
03:08:27 <Adeon> huh
03:09:13 <Adeon> well for the state one it's useful documentation
03:09:15 <mniip> I think what happens is,
03:09:34 <mniip> it is possible to have a datum imported, but not its constructors
03:10:07 <iqubic> Yeah. So I think I'll generate an image with JuicyPixels, then convert it to gloss for display.
03:10:08 <mniip> so, if that was the case, haddock would have no useful information to show
03:10:12 <mniip> other than the kind
03:10:32 <mniip> so, preemptively, haddock writes out the kind for all data reexported from another package
03:10:52 <mniip> because for other data it either has the constructors or can hyperlink them
03:11:04 <iqubic> Unless there is a simpler way to create a picture from a function using only gloss.
03:11:49 <Adeon> I would probably just hook up juicy to gloss like you are doing and do gloss-only if I find that part became a bottleneck for something
03:11:58 <Adeon> productivity over efficiency when efficiency is not that important
03:12:27 <iqubic> Yeah, I'll do that then.
03:12:33 <iqubic> Sounds good.
03:14:49 <iqubic> The only ways to simply create an image in gloss is with a Bytestring, or a ForeignPtr.
03:15:03 <iqubic> Neither of which sounds very simple
03:16:17 <Adeon> it's possible to do but yeah it's a bit more complicated
03:16:31 <Adeon> probably have to muck around with pixel formats and so on unless you target only one bitmap format
03:17:13 <iqubic> So using JuicyPixels generateImage function is certainly easier.
03:17:27 <Adeon> yup
03:18:28 <iqubic> Is there anyway to view documentantion for these libraries without having use the internet?
03:19:11 <Adeon> I don't do it myself but IIRC if you install packages with cabal and you have the correct settings in ~/.cabal/config then you get like a local documentation repository
03:19:30 <Adeon> it's been a while since I've looked at local docs so there may be some better workflows that I don't know about for viewing documentation
03:19:50 <iqubic> Cool, thanks
03:19:56 <Adeon> I haven't touched cabal the command-line program in a while...it's all stack now
03:20:13 <merijn> iqubic: You can make cabal build local docs, yes
03:21:13 <merijn> iqubic: You want to make sure ~/.cabal/config has "documentation: True"
03:21:29 <merijn> And it'll give a local copy of the html docs for every installed package
03:21:36 <iqubic> Adeon, I only use Stack mysel
03:21:49 <Adeon> no idea if stack does anything with docs
03:21:56 <Adeon> can probably build at least docs for the package you are working on
03:22:17 <Adeon> stuff like cross-linking between many packages is kind of convenient
03:23:22 <iqubic> I don't need local docs.
03:23:26 <iqubic> It's cool
03:23:35 <jennyrgb> a b c d e .. shouldn't that first run a on b, and then the result on c and run that result on d and that result on e? 
03:23:44 <jennyrgb> 1+2*3 does not follow that pattern
03:24:01 <jaspervdj> jennyrgb: That's because of operator precedence
03:24:18 <merijn> jennyrgb: There's special rules for operators
03:24:47 <jaspervdj> 1+2*3 is parsed as 1+(2*3) which is kinda like `(+) 1 ((*) 2 3)`
03:25:22 <merijn> jennyrgb: i.e. some names of function are defined to be "operators" and are treated like infix operators, like regular math notation, in cases of multiple operators (like 1+2*3) the precedence of the operators defines how things are grouped
03:26:22 <jennyrgb> what do I use "let" for?
03:27:22 <jennyrgb> I mean, works fine without it
03:27:37 <merijn> jennyrgb: Can you put an example on lpaste.net to show what you mean?
03:27:38 <jennyrgb> let string = "aaaaaa", same as string = "aaaaaa"
03:27:53 <merijn> jennyrgb: In ghci?
03:27:53 <iqubic> What's the point of generateFoldImage in JuicyPixels?
03:28:03 <iqubic> https://hackage.haskell.org/package/JuicyPixels-3.2.8.1/docs/Codec-Picture.html
03:28:08 <jennyrgb> merijn: sure
03:29:51 <iqubic> Also, what does withImage do? Isn't that the same thing with the parameters reversed
03:30:04 <iqubic> Same as generateImage I mean.
03:30:22 <maerwald> jennyrgb: try it in a source file, you'll see the difference
03:31:05 <Adeon> iqubic: it's monadic so the pixel-generation function can be an IO-action, whereas generateImage, your generation function has to be pure
03:31:40 <Adeon> also the ordering of parameters means you can do something like this: withImage 800 600 $ \x y -> doStuff x y
03:31:41 <maerwald> unfortunately the error message will most likely be a cryptic GHC parser error
03:32:04 <Adeon> looks a bit nicer
03:32:11 <Adeon> withImage 800 600 $ \x y -> do
03:32:13 <Adeon>   doStuff x y
03:32:19 <iqubic> Adeon, why is that helpful? Does it let you inline the creation function?
03:32:47 <iqubic> Now what does generateFoldImage do?
03:33:09 <Adeon> well aside from being able to thread a monad inside otherwise it seems just accommodating different way of calling it
03:33:20 <Adeon> generateFoldImage threads a state inside the generation function
03:33:36 <iqubic> What does that mean
03:33:44 <Adeon> the value `acc`, is called in each function, you can modify and at next pixel generation you can get the modified `acc` to you
03:33:46 <iqubic> ANd how will that help anyone?
03:34:14 <Adeon> it means that what's on another pixel can depend on what you did on some other pixel
03:34:18 <Adeon> not actually sure of any obvious use cases
03:34:26 <Adeon> I would at least like to know in which order the thing will call all the pixels
03:34:52 <Adeon> oh it tells you
03:35:05 <iqubic> Left to right, top to bottom
03:35:27 <Adeon> there are probably some use cases
03:35:28 <iqubic> I don't think I need that however.
03:35:33 <Adeon> I think otherwise nobody would have come up with that function
03:36:01 <iqubic> Yeah, I guess you're right.
03:36:11 <iqubic> Actually, I do have a use for that function.
03:36:43 <iqubic> I need a state that I can pass to ever single point as it gets created.
03:37:13 <Adeon> does that state change as you are writing more pixels?
03:37:20 <Adeon> if the answer is yes then the fold function is for you
03:37:26 <iqubic> Yeah. It will.
03:37:27 <Adeon> if it's the same state for every pixel then you don't need it
03:37:29 <Adeon> okaydokey
03:37:50 <Adeon> I suppose it could do things like collect statistics
03:37:54 <Adeon> "I wrote 12382 red pixels"
03:37:58 <Adeon> you get the state back at the end
03:38:09 <iqubic> So you do.
03:39:27 <iqubic> Is there a way that I can take some input, and just return a funtion.
03:39:29 <iqubic> ??
03:39:36 <iqubic> Like plusN
03:40:03 <iqubic> Which has type int -> (int -> int)
03:40:52 <iqubic> So that the function returned will add N to the input.
03:41:08 <cocreature> Int -> Int -> Int is the same as Int -> (Int -> Int)
03:41:14 <iqubic> Where N is passed in when creating the function.
03:41:14 <cocreature> so you can just use +
03:41:19 <cocreature> :t (+) 4
03:41:21 <lambdabot> Num a => a -> a
03:41:43 <iqubic> right, but in this case I want to do something more clever.
03:42:04 <iqubic> I want to take my generateImage function, and parameterize it.
03:42:43 <iqubic> What I mean to say is I want a function that is called: createGenerateImage.
03:43:05 <dmwit> jennyrgb: http://stackoverflow.com/q/42988950/791604
03:43:30 <iqubic> Which allows me to pass in a few starting parameters to my generateImageFunction.
03:44:48 <dmwit> iqubic: I don't understand the question yet. Perhaps you can make it a little more concrete by describing what you plan to do.
03:45:02 <iqubic> dmwit, it's fine.
03:46:20 <iqubic> All I really needed to know was that: "int -> (int -> int)" is the same as "int -> int -> int"
03:47:09 <iqubic> So basically it's possible to have the output of one function be a function itself.
03:48:20 <cocreature> yep
03:48:30 <iqubic> In other words, this is a possible function "plusN n = (+) n
03:49:00 <iqubic> And you can call it like this: "plusN 5 $ 5"
03:49:10 <iqubic> And that would return 10.
03:49:11 <dmwit> Yes. Or `plusN = (+)`.
03:49:17 <cocreature> you don’t need the $ here
03:49:26 <iqubic> right.
03:49:35 <iqubic> But that's a super simple example.
03:49:39 <dmwit> Or don't even define anything, and just use the original name. =)
03:50:20 <iqubic> Yeah, I know that.
03:50:29 <iqubic> This is a simple function.
03:51:01 <iqubic> But I'll be doing something a bit more complex.
03:51:10 <klottie> print $ content :: CustomType gives me an error while print (content :: CustomType) doesn't. Doesn't '$' have the highest precedence?
03:51:29 <cocreature> klottie: :: is not an ordinary operator with precedence
03:51:41 <merijn> klottie: First of, you mean lowest precedence. And second, no, :: scopes over everything before it
03:52:19 <iqubic> What that does is trys to turn the output of "print $ content" into a CustomType.
03:52:23 <klottie> sorry, I meant lowest precedence.
03:53:13 <iqubic> Yeah, but :: uses everything in the entire line, or (), as it's input.
03:54:20 <klottie> I got it. thanks for the answers.
03:55:07 <jennyrgb> are inclusion guards bad? :p
03:55:30 <dmwit> What is an inclusion guard?
03:58:41 <merijn> dmwit: I only know that term in context of C and header includes
03:58:57 <merijn> as in, the #ifndef MYHEADER; #define MYHEADER
03:59:00 <cocreature> #pragma once ftw :)
03:59:17 <dmwit> Don't write recursive modules ftw
03:59:36 <dmwit> The compiler just checks this for you without any effort on your part ftw
03:59:43 <dmwit> =P
03:59:52 <merijn> dmwit: I hate that lame as argument. Lack of recursive modules in GHC is my biggest annoyance with it's deviation of the report
04:00:13 <merijn> I find myself wanting recursive modules all the time :(
04:00:32 <dmwit> GHC allows recursive modules with only a modicum of effort.
04:00:52 <merijn> dmwit: It's a pretty substantial amount of effort, imho
04:01:08 <merijn> Which is why everyone has a Types.hs module that defines literally every ADT and typeclass...
04:03:16 <jennyrgb> lol.. I mean regular haskell guards. Are they bad, should they be avoided?
04:03:37 <merijn> eh, no? it depends on what you're doing with them :p
04:08:14 <dmwit> Often where you would use guard-like things in other languages you use pattern matching in Haskell.
04:08:29 <dmwit> But there are plenty of idiomatic uses of guards, and they are by no means "to be avoided".
04:09:56 <iqubic> So what does it mean for a function to be "Point-Free"
04:09:58 <iqubic> ???
04:10:14 <merijn> iqubic: Not binding variable names
04:10:33 <pacak> foo x = x + 1 -- x is point in this case.
04:10:40 <iqubic> Right. 
04:10:44 <pacak> foo = (+1) -- this one is point free
04:11:00 <pacak> bar = show . (+1) -- this one is also point free
04:11:23 <iqubic> Why do you need function composition there?
04:11:24 <merijn> iqubic: It's a term originating from geometry, where you transform one point into another using functions. So if the function doesn't mention a specific point (i.e. no variable) it was "point free"
04:11:44 <iqubic> Ah. I see.
04:12:19 <iqubic> Still, why is fuctional composition needed in "bar = show. (+1)"?
04:13:12 <iqubic> Is that because the un-named variable(s) need to be last argument?
04:13:15 <merijn> iqubic: Well, you could write "show (+1)", but it'd mean something very different :)
04:13:25 <merijn> :t (.)
04:13:26 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:13:51 <merijn> @src (.)
04:13:52 <lambdabot> (f . g) x = f (g x)
04:13:52 <iqubic> right.
04:14:27 <merijn> iqubic: If you'd write "show (+1)" you would instead be applying "show" to the function "(+1)" (and get a messages that you can't show functions)
04:14:45 <iqubic> And you can't just write "foo x = show (x + 1) because this should be point-free.
04:14:59 <iqubic> Should one strive to make all functions point-free?
04:15:02 <jennyrgb> what's an easier definition of tail recursion for retards?
04:15:13 <merijn> iqubic: Right, writing foo like that wouldn't be point-free
04:15:27 <merijn> iqubic: No, almost certainly not, pointfree often makes stuff way less readable :)
04:15:47 <merijn> jennyrgb: Honestly, tail recursion isn't that relevant for Haskell :)
04:15:48 <iqubic> jennyrgb: The recursive call should be the last statement in the function.
04:15:49 <pacak> @pl foo x y z = bar z y y x
04:15:49 <lambdabot> foo = flip (flip . (flip =<< flip bar))
04:16:05 <merijn> iqubic: It's basically a matter of "what's more readable?"
04:16:11 <iqubic> What does pl stand for?
04:16:12 <pacak> First version is a bit more readable compared to whatever lambdabot suggested.
04:16:19 <pacak> pointless I belive
04:16:25 <iqubic> Also, that is quit a bit worse
04:17:09 <iqubic> @pl foo x = show (x + 1)
04:17:09 <lambdabot> foo = show . (1 +)
04:17:21 <merijn> iqubic: Often you find yourself wanting to apply a bunch of stuff in a row, like "map (foo . bar . baz)" where pointfree is nice, but it's certainly not universally nicer or better :)
04:17:34 <iqubic> Yeah, it is not needed.
04:18:32 <iqubic> Is it better to always write functions to be tail-recursive?
04:18:56 <merijn> iqubic: In Haskell it mostly doesn't matte
04:19:20 <pacak> iqubic: First write something that works, profile stuff if you have performance issues.
04:19:31 <merijn> iqubic: Tail-recursion, combined with tail-call optimisation is used to avoid function call stack growth (and thus memory leaks)
04:19:53 <merijn> iqubic: However, (GHC) Haskell doesn't *have* a function call stack, so there's no point in "avoiding to grow it" :)
04:19:56 <jennyrgb> I still don't get it. The last statement.. what? in a tail recursion
04:20:13 <merijn> iqubic: Depending on your point of view, either every haskell function call is a tail call or none are
04:20:45 <pacak> jennyrgb: When last action in function is a recursive call to the same function recursion can be optimized away into a loop
04:20:53 <iqubic> I would like to create a functional programming language that only supports tail-recursion. Would that be a good idea?
04:21:06 <iqubic> Or would that be rather stupid?
04:21:09 <pacak> sum [] = 0
04:21:09 <pacak> sum (x:xs) = x + sum xs
04:21:19 <pacak> this one is not tail recursion because last operations +
04:21:41 <Myrl-saki> pacak: You'll be losing map and whatnots.
04:21:51 <jennyrgb> pacak: oh, ok, excellent, thanks
04:21:53 <iqubic> But you can make it tail recursive.
04:22:05 <pacak> sum = sum' 0
04:22:06 <pacak>   where
04:22:06 <pacak>     sum' p [] = pred
04:22:06 <pacak>     sum' p (x:xs) = sum' (p+x) xs
04:22:06 <Myrl-saki> iqubic: fooo = map ...
04:22:33 <iqubic> What does pred do?
04:22:39 <pacak> mmmm
04:22:42 <pacak> pred = p
04:22:44 <pacak> my bad
04:22:49 <jennyrgb> but all self referenting recursions can be optimized to loops
04:23:18 <iqubic> What does self referenting mean?
04:23:25 <Myrl-saki> self referencing.
04:23:54 <iqubic> Ah.
04:24:33 <iqubic> jennyrgb: all recursion is self referencing. That's the definition of recursion.
04:26:02 <pacak> iqubic: There's also mutual recursion when you have several functions calling each other
04:26:31 <iqubic> Sure, but that eventually gets around to referencing itself.
04:26:58 <iqubic> I have a qustion. What if I define these two functions:
04:27:18 <iqubic> foo x = x + 1
04:27:29 <iqubic> and bar x = x + 1
04:27:44 <iqubic> what would happen with a call of "foo 1"?
04:28:05 <cocreature> it will evaluate to 1 + 1?
04:28:25 <iqubic> Sorry what I meant was: 
04:28:32 <iqubic> foo x = bar x + 1
04:28:40 <iqubic> bar x = foo + 1
04:29:01 <iqubic> well, you get the idea.
04:29:02 <cocreature> that’s a type error. did you mean bar x = foo x + 1?
04:29:07 <iqubic> yeah
04:29:08 <iqubic> I did.
04:29:19 <iqubic> foo x = bar x + 1
04:29:29 <iqubic> bar x = foo x + 1
04:29:34 <iqubic> what would that do?
04:29:43 <cocreature> that’s an infinite loop (at least for almost the usual instances of Num)
04:29:49 <cocreature> -almost
04:30:18 <iqubic> Wait, you'd never get a StackOverFlow error ever?
04:30:33 <Myrl-saki> iqubic: Technically, you can have mutual recursion, which is not directly self-referencing.
04:31:20 <Adeon> I think ghc might detect that loop
04:31:25 <Adeon> but if it doesn't you might eventually run out of memory
04:31:41 <pacak> > let ones = 1:ones in ones
04:31:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:32:05 <iqubic> Yeah, that's an infinite list.
04:32:24 <ClaudiusMaximus> with lazy Peano naturals you'll get S(S(S(S... , equivalent to infinity = S infinity, which might be useful as it can be evaluated only as far as necessary to know that it's bigger than another nat
04:33:13 <iqubic> listOfXs x = x:listOfXs
04:33:15 <Myrl-saki> pacak: Oh whoops. Didn't realize that you mentioned mutual recursion. :(
04:33:21 <Adeon> yeah, I tried that foobar program, with -O2 you get <<loop>> exception, anything lower and you recurse infinitely until memory runs out
04:33:27 <iqubic> listOfXs x = x:(listOfXs x)
04:33:36 <iqubic> is what I mean to type
04:33:51 <iqubic> gets you an infinite list of x
04:34:20 <iqubic> At least I think. Not too sure.
04:35:11 <Myrl-saki> iqubic: That's correct.
04:35:20 <iqubic> cool.
04:35:29 <Myrl-saki> iqubic: You also dont need the parentheses.
04:35:43 <iqubic> why not?
04:35:44 <pacak> > [1..] :: [Integer]
04:35:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:35:57 <pacak> This one is also kind of infinite
04:36:17 <iqubic> What are the other kinds of infinite?
04:36:22 <bjs> iqubic: because function application binds tighter than (:)
04:36:32 <iqubic> foo x = foo x + 1
04:36:44 <Myrl-saki> > let repeat' x = x:repeat' x
04:36:46 <lambdabot>  <no location info>: error:
04:36:46 <lambdabot>      not an expression: ‘let repeat' x = x:repeat' x’
04:37:08 <bjs> @src repeat
04:37:08 <lambdabot> repeat x = xs where xs = x : xs
04:37:32 <pacak> > fix ((0:) . scanl (+) 1)
04:37:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:37:36 <iqubic> > let foo x = foo x + 1 in foo 1
04:37:38 <lambdabot>  *Exception: stack overflow
04:37:40 <Myrl-saki> @let repeat' x = x:repeat' x
04:37:41 <lambdabot>  Defined.
04:38:02 <iqubic> What does fix do?
04:38:09 <pacak> @src fix
04:38:09 <lambdabot> fix f = let x = f x in x
04:38:12 <pacak> :t fix
04:38:12 <Myrl-saki> pacak: What the hell lmao
04:38:13 <lambdabot> (a -> a) -> a
04:38:23 <bjs> Myrl-saki: what's wrong
04:38:30 <Myrl-saki> :t canl
04:38:31 <lambdabot> error:
04:38:31 <lambdabot>     • Variable not in scope: canl
04:38:31 <lambdabot>     • Perhaps you meant one of these:
04:38:43 <Myrl-saki> :t scanl
04:38:44 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
04:39:13 <Myrl-saki> Oh okay. Makes sense now.
04:39:23 <pacak> Myrl-saki: Recursion without recursion :)
04:39:27 <pacak> > fix error
04:39:29 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
04:39:46 <iqubic> Wait, so fix returns and infinite list?
04:39:52 <bjs> iqubic: no
04:39:57 <iqubic> > fix (1 +)
04:39:59 <bjs> iqubic: look at its type (a -> a) -> a
04:40:03 <lambdabot>  mueval-core: Time limit exceeded
04:40:04 <pacak> fix can do lots of stuff
04:40:09 <iqubic> Right.
04:40:28 <bjs> iqubic: it repeatedly applies f to itself, look at the source
04:40:31 <Myrl-saki> pacak: Recursion without recursion with fix tendsto be written as `fix (\f x -> f x) though. :P
04:41:06 <pacak> :t fixM
04:41:07 <lambdabot> error:
04:41:07 <lambdabot>     • Variable not in scope: fixM
04:41:07 <lambdabot>     • Perhaps you meant ‘fix’ (imported from Data.Function)
04:41:30 <bjs> iqubic: or think of this: fix' f = f (fix' f)
04:41:47 <bjs> it's a kind of fixed point of the function :)
04:41:53 <abhiroop> Question bump: http://lpaste.net/354450
04:41:57 <iqubic> fix finds the fixed point of the function.
04:42:17 <iqubic> > fix 1
04:42:18 <lambdabot>  error:
04:42:19 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M353276782070...
04:42:19 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
04:42:30 <iqubic> > fix 1 :: int
04:42:32 <lambdabot>  error:
04:42:32 <lambdabot>      • No instance for (Num (int1 -> int1)) arising from the literal ‘1’
04:42:32 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
04:42:41 <Myrl-saki> bjs: No. (* -> *) -> * is a kind of a fixed point.
04:42:49 <bjs> Myrl-saki: haha
04:42:49 <iqubic> > fix (id 1) :: int
04:42:51 <lambdabot>  error:
04:42:51 <lambdabot>      • No instance for (Num (int1 -> int1)) arising from the literal ‘1’
04:42:51 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
04:43:00 <iqubic> > fix (id x) :: int
04:43:02 <lambdabot>  error:
04:43:02 <lambdabot>      • Couldn't match expected type ‘int1 -> int1’
04:43:02 <lambdabot>                    with actual type ‘Expr’
04:43:06 <iqubic> > fix (id x)
04:43:09 <lambdabot>  error:
04:43:09 <lambdabot>      • Couldn't match expected type ‘a -> a’ with actual type ‘Expr’
04:43:09 <lambdabot>      • Possible cause: ‘id’ is applied to too many arguments
04:43:15 <pacak> You can experiment with lambdabot in private conversation
04:43:21 <iqubic> > fix id
04:43:27 <lambdabot>  mueval-core: Time limit exceeded
04:43:39 <iqubic> Why does that last thing fail?
04:43:45 <Myrl-saki> > fix (0*)
04:43:51 <lambdabot>  mueval-core: Time limit exceeded
04:43:55 <pacak> iqubic: What kind of answer do you expect?
04:44:00 <Myrl-saki> iqubic: Because id doesn't 'short circuit'
04:44:04 <iqubic> fix (2*)
04:44:10 <iqubic> > fix (2*)
04:44:15 <lambdabot>  mueval-core: Time limit exceeded
04:44:19 <pacak> > fix (const "Hello world")
04:44:21 <lambdabot>  "Hello world"
04:44:43 <iqubic> Shouldn't "fix (2*)" return 1?
04:44:49 <Myrl-saki> > fix (False &&)
04:44:51 <lambdabot>  False
04:44:59 <iqubic> > fix (2*)
04:45:05 <lambdabot>  mueval-core: Time limit exceeded
04:45:05 <bjs> iqubic: why should it return 1?
04:45:08 <iqubic> > fix (1*)
04:45:14 <lambdabot>  mueval-core: Time limit exceeded
04:45:20 <pacak> > let fib = fix (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2)) in fib 5
04:45:22 <lambdabot>  5
04:45:55 <pacak> > let fib = fix (\f -> \n -> if n < 2 then n else f (n-1) + f (n-2)) in fib 9
04:45:57 <lambdabot>  34
04:45:58 <iqubic> Alright, that last one should have returned 1. fix (1*) = 1
04:46:15 <pacak> :t fix (1*)
04:46:17 <lambdabot> Num a => a
04:46:37 <Myrl-saki> iqubic: Technically should.
04:46:41 <pacak> It is 1 from math point of view, but not from ghc.
04:46:48 <iqubic> Why doesn't it return 1?
04:47:14 <iqubic> Why doesn't ghc find out that the answer is one?
04:47:19 <Myrl-saki> pacak: How does math get 1?
04:47:34 <iqubic> 1 * 1 = 1
04:47:35 <Myrl-saki> pacak: Asking this from a Haskeller point of view. :P
04:47:52 <iqubic> fixed point of 1* = 1
04:48:00 <iqubic> 1 * 1 = 1
04:48:05 <pacak> I belive product of infinite list of ones is 1, at least a limit
04:48:12 <pacak> You can proove it by induction
04:48:30 <iqubic> So.
04:49:26 <bjs> iqubic: there are multiple fixed point functions you can implement, the Data.Function.fix one relies on lazy evaluation
04:49:52 <iqubic> Why doesn't GHC find an answer to  fix (1*)
04:50:17 <bjs> iqubic: because (1*) is strict in its other argument
04:50:24 <pacak> let 1 * 1 = 2 in 1 * 1
04:50:29 <Myrl-saki> iqubic: Because Haskell is programming.
04:50:29 <pacak> > let 1 * 1 = 2 in 1 * 1
04:50:32 <lambdabot>  2
04:50:37 <pacak> Because 1 * 1 can be 2
04:50:48 <iqubic> what the heck???
04:50:58 <pacak> > let 2 + 2 = 5 in 2 + 2
04:50:59 <bjs> iqubic: so fix (1*) is like (1*) (fix (1*)), which is like (1* (1* (fix (1*)))
04:51:00 <lambdabot>  5
04:51:02 <Myrl-saki> 3 different answers lmao
04:51:05 <bjs> iqubic: can you see how this unrolling is never gonna end
04:51:23 <bjs> iqubic: ghc is going to try execute (1* (1* (1* (1* ...
04:51:31 <iqubic> > let false && false = true in false && false
04:51:34 <lambdabot>  error:
04:51:34 <lambdabot>      • Conflicting definitions for ‘false’
04:51:34 <lambdabot>        Bound at: <interactive>:1:5-9
04:51:43 <Myrl-saki> And the reason why ` False &&` works is because it forgets its right argumentn.
04:51:50 <pacak> > let False && False = True in False && False
04:51:52 <lambdabot>  True
04:51:54 <bjs> iqubic: whereas (False &&), (const 1) etc are lazy in their second argument
04:52:15 <Myrl-saki> bjs: I don't think strict/lazy is the proper term.
04:52:17 <iqubic> Right, they leave the second argument as thunks
04:52:23 <pacak> iqubic: The trick is in all those examples we override existing functions
04:52:31 <iqubic> You do?
04:52:35 <pacak> > let 2 + 2 = 5 in 3 + 3
04:52:37 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
04:52:46 <iqubic> Ah.
04:52:46 <bjs> Myrl-saki: it's not, but it's easier to explain that way
04:53:01 <Myrl-saki> pacak: I also don't think overloading makes a difference.
04:53:19 <iqubic> I understand the concepts of Thunks and Weak Head Normal Form.
04:53:28 <Myrl-saki> > let False && x = x in fix (False &&)
04:53:34 <lambdabot>  mueval-core: Time limit exceeded
04:54:12 <Myrl-saki> > let False && False  = x in fix (False &&)
04:54:14 <lambdabot>  error:
04:54:14 <lambdabot>      • Couldn't match type ‘Expr’ with ‘Bool’
04:54:14 <lambdabot>        Expected type: Expr -> Expr
04:54:36 <iqubic> Right, that forces the second argument to be evaluated. The first one does.
04:54:45 <pacak> Myrl-saki: Overloading is only to illustrate why ghc can't figure out 1 * 1 * 1 by itself.
04:54:59 <iqubic> I see.
04:55:01 <Myrl-saki> iqubic: Exactly.
04:55:09 <iqubic> I see now.
04:55:30 <pacak> > let 0 * x = 0 in fix (0*)
04:55:33 <lambdabot>  0
04:55:47 <pacak> this works because it ignores x
04:56:04 <iqubic> > let 1 * x = 1 in fix (1*)
04:56:06 <lambdabot>  1
04:56:15 <Myrl-saki> pacak: Exactly.
04:56:17 <iqubic> And there is ignores x again,
04:56:19 <pacak> iqubic: But that's false from math point of view
04:56:36 <iqubic> what is?
04:56:49 <iqubic> What's false from math's point of view?
04:56:50 <pacak> 1 * x =1
04:56:59 <Myrl-saki> pacak: 1 * x = 1, I guess.
04:57:19 <iqubic> right. But haskell seems to like it.
04:57:24 <bjs> iqubic: this is a fixed point of the function
04:57:25 <Myrl-saki> Sorry for late sends.. Such lag, very delay.
04:57:40 <iqubic> I don't like operator overloading at all.
04:58:09 <iqubic> It leads to weird stuff
04:58:19 <bjs> iqubic: forget the rebinding then and think, let f 1 y = 1; f x y = x * y;
04:58:50 <iqubic> right. that makes more sense
04:59:32 <iqubic> > let f 1 y = 1; f x y = x * y; in fix (f 1)
04:59:34 <lambdabot>  1
04:59:51 <iqubic> So that's a simpler way for me to think of that.
05:00:58 <Myrl-saki> (1 *) == id, right?
05:01:13 <Myrl-saki> Actually, ignore what I said. lmao.
05:01:26 <bjs> Myrl-saki: no
05:01:29 <iqubic> No.
05:01:35 <iqubic> id x = x
05:01:44 <bjs> (1*) == const 1 in that example
05:01:54 <iqubic> right.
05:01:56 <Myrl-saki> bjs: I meant in actuality.
05:03:39 <Myrl-saki> Wait. Isn't `fix (1*)` R?
05:03:58 <Myrl-saki> Like, in math.
05:04:18 <bjs> Myrl-saki: i'm not following
05:04:37 <pacak> Myrl-saki: It's id in math, but in haskell it's a call to addq processor command. There are no extra checks
05:04:59 <Myrl-saki> bjs: Since we got to a math discussion of fixpoints. Then wouldn't fix(1*) be everything?
05:05:17 <bjs> Myrl-saki: it doesn't really make sense to assign multiple values to a fixed point
05:05:19 <bjs> but ... i guess?
05:05:44 <Myrl-saki> bjs: A fixpoint is where f(x) = x, right?
05:06:22 <bjs> Myrl-saki: yeah, but Data.Function.fix is a special fixed point :)
05:06:24 <bjs> that doesn't even require EQ
05:06:35 <bjs> which is sort of strange when you think about it
05:06:55 <iqubic> Yeah, but haskell has a different way of finding the fixed point.
05:07:22 <Myrl-saki> I said in math. :|
05:09:38 <Myrl-saki> @t get
05:09:38 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
05:10:09 <Myrl-saki> > get
05:10:11 <lambdabot>  error:
05:10:11 <lambdabot>      • Ambiguous type variables ‘m0’, ‘s0’ arising from a use of ‘show_M34462...
05:10:11 <lambdabot>        prevents the constraint ‘(Show (m0 s0))’ from being solved.
05:11:30 <bjs> Myrl-saki: oh okay, then yeah you could say any inputs are fixed point of id, and (1*) is just id
05:12:55 <Myrl-saki> Also, anyone else here read Clowns and Jokers? How are positions determined.
05:27:37 <seequ_> So, I was battling with a timeout problem in codingame (The mimetype challenge). In this, the commented out snippet (line 36) times out, but the longer version (line 39) doesn't. Why?
05:27:38 <seequ_> http://lpaste.net/266436500911030272
05:42:57 <lyxia> seequ_: what is the input like
05:43:42 <lyxia> I don't see any obvious issue
05:45:06 <seequ_> lyxia: "html text/html\npng image/png\n<ext> <mimetype>" ~1000x
05:48:43 <jasondockers_> what is the "in" keyword for?
05:49:31 <lyxia> It's part of "let ... in ..." expressions
05:50:07 <lyxia> it delimits local definitions
05:50:11 <jasondockers_> you have to use the "in" keyword to specify you're in the lexical scope of the let? 
05:50:19 <jasondockers_> ok
05:58:51 <bbear> hello
05:58:56 <bbear> I want to define a composite data type
05:59:15 <bbear> let say I have a type data Coord = C Int Int
05:59:34 <bbear> how can I do something like
06:00:01 <bbear> data Move = Stay | C Int Int
06:00:10 <bbear> or data Move = Stay | Coord ?
06:00:40 <bbear> what If want to define a type like : data Foo = a|b|c
06:01:01 <pacak> data Move = Stay | C Coord
06:01:01 <bbear> and then data Bar = B d | Foo
06:01:06 <pacak> data Move = Stay | Co Coord
06:01:27 <bbear> and I want my Bar type object taking values in a,b,c or d ?
06:01:30 <bbear> is that possble ?
06:01:56 <bbear> data Foo = a|b|c
06:02:02 <bbear> data Bar = d|Foo
06:02:18 <pacak> If you want to declare it as data - things around | must be constructors
06:02:48 <pacak> You can define them as type and use sum and product types - but that will make code more messy
06:02:49 <bbear> data Foo=A|B|C
06:02:58 <bbear> dat Bar = D|Foo
06:03:04 <pacak> type Foo = Either () Coord
06:03:23 <pacak> Left () will be "Stay", Right (C Int Int) will be move
06:04:50 <bbear> well Either works with two stuff
06:04:54 <bbear> I don't want that
06:05:28 <bbear> I want to be able to compile functions that take arguments of type Bar or Foo but type signature as written like it take types Bar only
06:06:47 <merijn> bbear: Yeah, that's not really possible in Haskell
06:06:52 <ongy> bbear: so you want the types to tell a lie?
06:07:04 <merijn> You basically seem to want anonymous sum types, but Haskell doesn't have those
06:07:29 <merijn> ongy: Naah, I think he wants like structural subtyping
06:07:39 <bbear> kind of overloading actually
06:08:00 <bbear> what is data Bar=D|Foo in data Foo =A|B|C anyway ?
06:08:21 <bbear> because I want to use enum
06:08:26 <bbear> messy
06:08:40 <bbear> :t Either
06:08:42 <lambdabot> error:
06:08:42 <lambdabot>     • Data constructor not in scope: Either
06:08:42 <lambdabot>     • Perhaps you meant variable ‘either’ (imported from Data.Either)
06:09:00 <ongy> :k Either
06:09:01 <lambdabot> * -> * -> *
06:10:09 <ongy> Either is the type constructor, value constructers are Left and Right (data Either a b = Left a | Right b)
06:10:23 <bbear> say I have data Alphabet = a|b|c|d|e|f|g|h|[...]|z
06:11:07 <bbear> how could I do something like [a..z] ?
06:11:46 <Myrl-saki> "The best editor is neither Emacs nor Vim, it's Emacs+Vim" Shouldn't it be Emacs*Vim?
06:12:27 <Myrl-saki> bbear: In a `data` constructor? I don't think you can do that. Maybe with TH.
06:12:47 <bbear> not in Data constructor
06:12:54 <bbear> to construct the list of all possible value that's all.
06:12:59 <bbear> to avoid boiler plate code
06:13:11 <ongy> :t \x y -> [x .. y]
06:13:12 <lambdabot> Enum t => t -> t -> [t]
06:13:33 <Myrl-saki> bbear: deriving Ord?
06:13:36 <bbear> yes
06:13:36 <ongy> bbear: you could do an instance Enum Alphabet for this
06:13:37 <bbear> ok
06:13:47 <bbear> deriving Ord should suffice
06:13:50 <bbear> I forgot
06:13:57 <bbear> I thought it was deriving Enum
06:14:28 <Myrl-saki> ongy: deriving Enum.
06:14:58 <ongy> if that's a thing, then it's even easier
06:15:26 <bbear> thanks I got my answer
06:15:28 <bbear> it was nice 
06:16:04 <bbear> wow
06:16:31 <bbear> sometimes all this function composition is giving me kind of a seasickness
06:17:07 <bbear> I write all my functions as one-liners for a specific task and then combine them all
06:17:11 <bbear> is that a good idea ?
06:17:21 <bbear> I end up a
06:17:26 <bbear> with a lot and a lot of functions.
06:19:18 <ongy> there's no universal truth. but *everything* as oneliner sounds a bit overdone to me.
06:21:04 <bbear> eventually if you don't one liners then you need to break lines
06:21:21 <bbear> So basically you start using (where, let)
06:21:45 <bbear> That's the alternative, right ?
06:22:05 <bbear> so if you forbid the use of where and let, you pretty much end up with a bunch of oneliners ?
06:22:29 <lordcirth> bbear, if a given line will only be used by 1 function, then I put it in "where".  If I think it might be used by other functions, it becomes a function.
06:23:26 <bbear> yes, but you don't have a priori knowledge that it won't need to be used elsewhere.
06:23:31 <ongy> why would you forbid let and where? I think it makes for a better spacial concentration of related code, which makes reading a bit nicer
06:23:55 <bbear> in fact if your code is truly reusable, any line of code you write could be reused anywhere.
06:23:57 <lordcirth> bbear, refactoring haskell is easy, tho.
06:24:03 <bbear> Yes
06:24:11 <bbear> I'm considering tradeoffs
06:24:13 <ongy> so? hlint even tells you when you have duplicated code blocks (and imo it's not much easier to search for functions than code snippets)
06:24:43 <bbear> I'm still a young Haskeller, i'm looking for a good style.
06:24:53 <bbear> how can you combine map applications ?
06:25:14 <bbear> map (otherFunc) $ map (func) myList
06:25:21 <bbear> <- it's ugly isn't it ?
06:25:35 <bbear> map (otherFunc. func) myList ?
06:25:55 <tobiasBora> Hello,
06:26:02 <hydraz> bbear: yep
06:26:06 <hc_> bbear: map (otherFunc . func) myList?
06:26:11 <hc_> jup
06:26:37 <hc_> I've got a question; is there an easy way to convert a ByteArrayAccess to a ByteString?
06:26:54 <hc_> ByteString.pack . ByteArray.unpack   works, but sounds inefficient
06:27:07 <tobiasBora> I'm trying to send cookies using conduit, but it does not work...
06:27:13 <bbear> oky
06:28:10 <tobiasBora> I'm using:
06:28:11 <tobiasBora> requestWithProxy {cookieJar = cookieJarM}
06:28:49 <tobiasBora> where cookieJar is get from "cookieJar = Just $ responseCookieJar resp"
06:30:16 <tobiasBora> show cookieJarM gives me the good cookie
06:31:10 <tobiasBora> But when I show the "requestWithCookie", the requestHeaders are empty,
06:31:29 <tobiasBora> and nothing is shown in the request about cookieJar
06:31:44 <tobiasBora> And, I'm sniffing the request with Wireshark
06:32:07 <bbear> any idea about a function minWith ?
06:32:16 <bbear> should define an ordering on an indicator
06:32:21 <tobiasBora> and I can't find anything
06:32:22 <bbear> :t compare
06:32:24 <lambdabot> Ord a => a -> a -> Ordering
06:32:38 <tobiasBora> bbear: compare `on` ... ?
06:32:53 <tobiasBora> :t compare `on`
06:32:54 <lambdabot> error:
06:32:54 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:32:54 <bbear> yes
06:32:57 <bbear> :t on
06:32:58 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
06:33:06 <bbear> :t compare
06:33:07 <lambdabot> Ord a => a -> a -> Ordering
06:33:38 <bbear> :t (on compare)
06:33:39 <lambdabot> Ord a => (a1 -> a) -> a1 -> a1 -> Ordering
06:34:16 <lep-delete> :t comparing
06:34:18 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
06:34:50 <bbear> comparing ?
06:35:35 <bbear> is that valid to take head (sortBy ..) rather than min(something) ?
06:35:43 <bbear> preferred method in Haskell ?
06:35:52 <bbear> :t min
06:35:53 <lambdabot> Ord a => a -> a -> a
06:36:24 <abhiroop> I am stuck with this issue in parsing using ReadP http://lpaste.net/354450
06:36:31 <abhiroop> Any help?
06:37:42 <bbear> the Prelude is kind of limited isn't it ?
06:37:58 <bbear> How can you have a more extended std library loaded in ghci by default ?
06:40:11 <yushyin> :set -XNoImplicitPrelude\n:module YourBetterPrelude in ~/.ghci
06:41:22 <abhiroop> I am trying to solve this problem in parsing using ReadP http://lpaste.net/354450 Any help?
06:42:54 <bbear> :t readP
06:42:55 <lambdabot> error:
06:42:55 <lambdabot>     • Variable not in scope: readP
06:42:55 <lambdabot>     • Perhaps you meant one of these:
06:47:52 <bbear> heya
06:48:44 <bbear> I'm kinda stuck with the interpreter.
06:49:06 <bbear> loading :m Data.List erase `on` and loading :m Data.Function erases `sortBy`
06:49:10 <bbear> what do I do ?
06:50:10 <pavonia> bbear: :m + Data.List Data.Function
06:57:12 <bbear> distanceTo (x,y) (v,w) = sqrt((x-v)**2 + (y-w)**2)
06:57:28 <bbear>  distanceTo (C x1 x2) (C y1 y2) = sqrt( (x1 - y1)**2 + (x2 - y2)**2 )
06:57:36 <bbear> No instance for (Floating Int) arising from a use of ‘sqrt’
06:57:42 <bbear> why the second is not working ?
06:57:52 <bbear> ha yes
06:57:56 <bbear> still syntax problem
06:58:50 <bbear> ha no
06:58:54 <bbear> so what's the problem ?
06:59:01 <bbear> where data Coord = C Int Int
07:00:12 <bbear> :t fromIntegral
07:00:13 <lambdabot> (Num b, Integral a) => a -> b
07:05:41 <bbear> is that fair to let the compiler infer the type from time to time ?
07:07:57 <peddie> :t sqrt   -- bbear
07:07:58 <lambdabot> Floating a => a -> a
07:08:29 <bbear> what does that mean ?
07:08:36 <bbear> I'm kinda stuck
07:08:44 <bbear> distanceTo :: Coord -> Coord -> Float
07:08:46 <bbear> distanceTo (C a b) (C c d) = sqrt( (x - v)**2 + (y-w)**2 ) where [x,y,v,w]=map fromIntegral [a,b,c,d]
07:08:52 <bbear> that doesnt compile
07:08:53 <peddie> it means you can take the square root of something that's an instance of the Floating type class
07:09:03 <peddie> oh, OK, you got that part then
07:09:06 <bbear> distanceTo (C a b) (C c d) = sqrt( (x - v)**2 + (y-w)**2 ) where [x,y,v,w]=map fromIntegral [a,b,c,d]
07:09:08 <peddie> what error do you get now?
07:09:19 <bbear> it compiles but I can't get teh type signature right
07:09:50 <bbear> GHCI gives me : `distanceTo :: Floating a => Coord -> Coord -> a `
07:09:58 <peddie> makes sense
07:10:17 <bbear> copy pasting that solved my problem
07:10:43 <bbear> so the first part before => is just the constraint on the class.
07:10:57 <peddie> yes
07:11:14 <bbear> ok
07:11:17 <bbear> easier now
07:11:29 <bbear> working with type is so much harder but then your code is so much cleaner.
07:11:58 <peddie> bbear: it definitely gets easier with practice :)
07:12:21 <bbear> i'm wondering
07:12:30 <bbear> I don't think haskell will have widespread adoption
07:12:50 <bbear> learning curve is quite steep compared to other languages.
07:12:55 <bbear> not as much actually
07:12:57 <bbear> w
07:13:00 <bbear> wondering
07:13:05 <bbear> javascript is quite complicated also
07:13:10 <bbear> and Java as well
07:13:22 <ongy> haskell isn't super new, so for any major change in adoption something weird would have to happen. But I think concepts tested out in/around haskell get adoption into other languages. Which is pretty nice aswell
07:13:42 <peddie> bbear: what exactly are you wondering?
07:15:16 <peddie> bbear: if you only knew haskell, you'd probably find the Java learning curve pretty steep ;)
07:15:56 <ongy> it's not necessarily hard, but different
07:16:03 <bbear> yes different
07:16:05 <bbear> I like t
07:16:18 <bbear> reasoning is much  easier and programs are much more cleaner.
07:16:27 <bbear> You don't end up stuck in some mess you created.
07:18:55 <bbear> need to write a where clause
07:19:02 <bbear> complicated
07:23:45 <_sras_> Is there any way to parse json passing an explict parser at run time?
07:25:49 <cocreature> :t Data.Aeson.Types.parse
07:25:50 <lambdabot> (a -> aeson-1.1.1.0:Data.Aeson.Types.Internal.Parser b) -> a -> aeson-1.1.1.0:Data.Aeson.Types.Internal.Result b
07:25:56 <cocreature> ^ _sras_
07:26:10 <abhiroop> Can anybody help with this? http://stackoverflow.com/questions/43306945/parse-multiple-instances-of-a-string-using-readp
07:26:35 <_sras_> cocreature: Yes. 
07:30:05 <abhiroop> Is it possible to use ReadP to parse multiple instances of a string inside a larger string
07:30:23 <abhiroop> I used a combinator which I found on stackoverflow
07:30:47 <bbear> Kind of find it weird when my code compile at the first trial
07:31:03 <abhiroop> which looks like this http://lpaste.net/354456
07:34:16 <_sras_> cocreature: Is there anyway to use this with the Yaml parser from Yaml library?
07:36:45 <cocreature> _sras_: use a yaml parser to parse json or have a similar function that allows you to parse yaml without relying on a parser provided by a typeclass instance?
07:37:08 <cocreature> the yaml library just reexports the parser type from aeson
07:37:19 <cocreature> and it provides parseMaybe and parseEither functions
07:46:57 <lyxia> abhiroop: what is get
07:48:35 <abhiroop> @hoogle get
07:48:36 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
07:48:36 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
07:48:36 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
07:48:46 <abhiroop> The first one
07:49:05 <abhiroop> Basically I want to parse past the first character
07:50:12 <lyxia> Do you want the result to only contain (["AB", "AB", "AB"], "GHA") and no other outcomes?
07:50:21 <abhiroop> Yes exactly
07:50:27 <lyxia> in other words, "AB" should not occur in whatever is left?
07:50:36 <abhiroop> I state the entir problem here http://lpaste.net/354450
07:50:42 <abhiroop> Yes
07:51:19 <lyxia> I found your statement a bit ambiguous but now it's clear.
07:52:13 <abhiroop> I posted the same in SO as well http://stackoverflow.com/questions/43306945/parse-multiple-instances-of-a-string-using-readp
07:53:28 <bbear> can you compute several values in a where clause ?
07:54:03 <lyxia> abhiroop: use asymmetric choice (<++) rather than <|>
07:54:42 <lyxia> abhiroop: you don't want to try the second alternative if p succeeds.
07:55:14 <abhiroop> lyxia that worked like a charm :)
07:55:16 <lyxia> bbear: sure
07:56:33 <lyxia> > let a = b where b = c ; d = 42 ; c = d in a
07:56:35 <lambdabot>  42
08:00:35 <bbear> is that ok to gov with Data.Tree to use trees ?
08:00:59 <mtesseract> Hello
08:02:06 <hc> oh wow, there is even a pdf generator lib for haskell. :)
08:04:32 <abhiroop> lyxia: I am thinking about the semantics of `<++`
08:04:40 <abhiroop> Is it sequential in nature
08:04:53 <abhiroop> whereas <|> is parallelizable
08:05:43 <lyxia> you could run the two arguments of <++ in parallel and throw away the second one if you don't need it.
08:07:34 <bbear> how many time to be good at haskell ?
08:07:40 <bbear> 1 year ?
08:08:06 <dysfun> a lifetime?
08:08:29 <dysfun> how good do you want to be? how much time will you put into it?
08:14:44 <bbear> I wonder
08:14:54 <bbear> ultimately I think it is kind of a quest to be a good programmer
08:15:08 <bbear> But right now I notice I am really slow at abstracting problems.
08:15:14 <bbear> I mean really really slow.
08:15:32 <dysfun> well you can probably fix that in a few months of practice
08:15:44 <bbear> Like coding a proper minimax IA is taking me probably 3 full days of work for a simple game..
08:15:55 <bbear> I don't know what is the standard though.
08:16:03 <bbear> But I feel myself slow.
08:16:12 <ongy> I would have to start with 1-2 Days of research, so 3 days isn't that bad :)
08:16:27 <dysfun> it depends what you're doing
08:16:36 <dysfun> i'm quite slow to start in areas where i don't know the concepts or libraries
08:16:46 <ertes> @let class Boolsheet a where { boolsheet :: a -> [Bool] }; instance Boolsheet Bool where { boolsheet = pure }; instance (Boolsheet a) => Boolsheet (Bool -> a) where boolsheet f = [False, True] >>= boolsheet . f
08:16:47 <lambdabot>  Defined.
08:16:53 <ertes> > boolsheet not
08:16:55 <lambdabot>  [True,False]
08:16:57 <ertes> > boolsheet (&&)
08:16:59 <lambdabot>  [False,False,False,True]
08:20:50 <bbear> how can you define a Tree in Haskell ?
08:21:04 <cocreature> data Tree = Empty | Node a (Tree a) (Tree a)
08:21:11 <bbear> that's a binary tree
08:21:15 <bbear> I need a rose tree
08:21:44 <bbear>  no idea ?
08:21:49 <cocreature> data Tree = Tree a [Tree a]
08:21:54 <bbear> good
08:22:02 <bbear> I suppose it will be sufficient.
08:22:07 <cocreature> eh I forgot an "a" on the left hand side
08:22:34 <cocreature> the containers package has rosetrees in Data.Tree
08:26:11 <Zemyla> bbear: data Tree a = forall s. Tree (s -> (a, [s])) s
08:26:33 <bbear> is that using the Data.Tree ?
08:26:45 <bbear> I'm not sure if building my own data structure would be better for a beginner.
08:27:18 <Zemyla> bbear: Yeah, it's probably not better for a beginner, because it uses ExistentialQuantification, and writing a monad for it isn't obvious.
08:27:25 <significance> Is `[1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)` evaluated as `[1, 2] >>= (\n -> ['a', 'b']) >>= (\ch -> return (n, ch))`, or as `[1, 2] >>= (\n -> ['a', 'b'] >>= (\ch -> return (n, ch)))`?
08:27:43 <bbear> ich
08:28:10 <joe9> I want to see the Rep of a data type. Is it possible to do that from the ghci after loading that module (which has the datatype)?
08:29:23 <mbw> Can anybody confirm that the memoize_fib function found here https://wiki.haskell.org/Memoization and also in the book "Haskell High-Performance Programming" is as fast as people seem to claim? I can't reproduce this at all.
08:29:32 <mbw> Using GHC 8.0.1 that is.
08:29:34 <lyxia> joe9: :kind! Rep MyType
08:30:15 <joe9> Thanks.
08:30:52 <lyxia> mbw: how fast do you want it to go
08:32:00 <mbw> lyxia: I know there's an O(n) algorithm. It's just that people claim that the function "memoized_fib" should be able to calculate the 10000th fib quickly...
08:32:38 <mbw> If I can't reproduce what I presume is a prototypical memoization example, something is off.
08:32:50 <mbw> I tried with and without -O2.
08:32:58 <lyxia> and what did you get?
08:33:22 <mbw> The 42th takes about 5 sec.
08:33:48 <mbw> Using Int as result type, that is. With Integer you can just forget about it
08:33:58 <lyxia> > let mfib :: Int -> Integer ; mfib = (map fib [0 ..] !!) ; fib 0 = 0 ; fib 1 = 1 ; fib n = mfib (n-1) + mfib (n-2) in mfib 10000
08:34:01 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
08:34:01 <cocreature> I get the 10000th in 0.76 seconds
08:34:11 <cocreature> without any changes
08:34:19 <mbw> huh....
08:34:22 <bbear> wait
08:34:31 <significance> Why does `guard` return `mzero` for false instead of `fail`?
08:34:34 <lyxia> looks like you're still testing the slow_fib somehow
08:36:31 <mbw> This is the way I tested it: http://lpaste.net/354457 . Maybe it's because of the way I'm calling it?
08:36:47 <joe9> need some help, please? I used generics before and when defining a default method (Rep a) was good enough. But, this time, it says Rep a is a kind.  code: http://dpaste.com/2TW6W5A  error :
08:36:50 <joe9> http://codepad.org/emlUalSo
08:37:12 <joe9> I can hack around and change Rep a to Rep a Builder and it does not error at that line.
08:37:24 <joe9> but, I want to know why or understand why I would need that.
08:37:27 <lyxia> significance: fail is yucky because not all monads have a concept of failure and guard doesn't have a good string to pass to fail anyway
08:37:45 <significance> lyxia: ahh, thank you! any reason we use mzero?
08:37:54 <significance> > fail :: [a]
08:37:56 <lambdabot>  error:
08:37:56 <lambdabot>      • Couldn't match expected type ‘[a1]’
08:37:56 <lambdabot>                    with actual type ‘String -> m0 a0’
08:37:57 <lyxia> mbw: fibLoc is supposed to call fibmem
08:38:02 <joe9> When I do :Kind! Rep Builder , I get the same info as :kind! Rep Doc (which was a module that I defined earlier and that worked with just Rep a
08:38:15 <mbw> argh
08:38:19 <glguy> joe9: :kind! Rep Doc ()
08:38:28 <mbw> Now I feel stupid lol
08:38:41 <nshepperd> significance: in recent ghc it returns 'empty', which is from Alternative typeclass. so you can use it on some things that aren't even monads
08:38:55 <significance> nshepperd: ahh, awesome -- thank you!
08:40:03 <joe9> glguy: for builder http://codepad.org/5BzVwzDH for Doc: http://codepad.org/wwaRUXtf
08:40:15 <lyxia> joe9: In GIBFormat a must have kind * -> *
08:40:24 <joe9> for builder info is http://codepad.org/lzBLzgyJ
08:40:39 <nshepperd> but yeah, either mzero or empty is better than fail, because that way you get a type error if your monad doesn't support failure
08:40:45 <nshepperd> instead of a run time exception
08:40:48 <mbw> lyxia: Thanks for your help.
08:41:00 <glguy> joe9: then they aren't instances of Generic
08:41:05 <lyxia> joe9: class GIBFormat f where gbuildIBFormat :: f p -> Builder ; gparseIBFormat :: Parser (f p)
08:42:13 <joe9> lyxia: got it. Thanks a lot.
08:48:16 <bbear> will it work ?
08:48:17 <bbear> http://vpaste.net/wzjLD
08:51:00 <bbear> build a tree from a seed
08:51:04 <bbear> do you know how to do it ?
08:51:50 <bbear> oh my
08:52:00 <bbear> http://haskell.1045720.n5.nabble.com/Building-a-tree-td3134095.html <- will I ever be able to code in Haskell
08:53:15 <Welkin> bbear: http://www.willamette.edu/~fruehr/haskell/evolution.html
09:06:09 <joneshf-laptop> If I have `newtype Foo = Foo Text deriving (ToJSON)` what will the `toEncoding` implementation look like?
09:06:31 <joneshf-laptop> Will it detour through `Value` land, or will it use the `toEncoding` of `Text`?
09:06:46 <MitchellSalad> it will use the `toEncoding` of `Text`
09:06:51 <joneshf-laptop> Great!
09:06:53 <joneshf-laptop> Thanks
09:07:29 <MitchellSalad> GeneralizedNewtypeDeriving just gives you the instances of the underlying type. How could it do any different?
09:07:33 <MitchellSalad> =P
09:07:46 <joneshf-laptop> more generally, is that a property of...just what I was going to ask :)
09:08:08 <joneshf-laptop> Thanks again.
09:08:17 <MitchellSalad> of course
09:08:59 <jennyrgb> what's {stuff} for?
09:10:02 <cocreature> jennyrgb: I think you need to provide a bit more context
09:10:43 <cocreature> maybe it’s NamedFieldPuns https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=namedfieldpuns#ghc-flag--XNamedFieldPuns
09:11:25 <MitchellSalad> {stuff} is a pattern that assigns variable name 'stuff' to what otherwise would be 'stuff record'
09:12:07 <MitchellSalad> i.e. normally with 'data User = User { name :: String }', name :: User -> String
09:12:19 <MitchellSalad> but using a 'User{name}' pattern, in that context, name :: String
09:15:27 <joneshf-laptop> Speaking of records
09:15:49 <joneshf-laptop> It feels like thelast few extensions really made most of the problems go away in day to day use.
09:16:46 <joneshf-laptop> particularly: `DuplicateRecordFields` and `RecordWildCards`
09:20:05 <tsahyt> RecordWildCards is not that new, is it?
09:20:24 <geekosaur> no
09:23:54 <jennyrgb> MitchellSalad: what's that doing? data User = User { name :: String }?
09:29:40 <geekosaur> it's the same as `data User = User String; name :: User -> String; name (User s) = s` except you can also use it in pattern matching
09:29:48 <geekosaur> and record update syntax
09:30:15 <geekosaur> named fields instead of just positional
10:06:20 <joe9> error http://codepad.org/Ocrz5UxJ , code http://dpaste.com/29FDY29 . I am missing something here. I can change the parseIBFormat definition in line 27: to be ByteString -> (a, ByteString). But, I want to figure out why I cannot use Parser a instead.
10:07:00 <joe9> any kind suggestions, please?
10:07:59 <cocreature> joe9: gparseIBFormat gives you a Parser (f x). but what you need is a Parser a
10:09:06 <joneshf-laptop> I'm writing a wai middleware that catches exceptions and dishes them off to an external server. Is it better to create my own `Manager` or use the global `Manager`? The recommended reading (https://haskell-lang.org/library/http-client) doesn't really talk about this case.
10:09:30 <joe9> cocreature:  I cannot make it just Parser f
10:10:41 <joneshf-laptop> Am I overthinking it?
10:11:04 <joneshf-laptop> Feels like it
10:11:33 <cocreature> joe9: maybe you’re looking for parseIBFormat x = gparseIBFormat (from x)?
10:12:01 <Fusionnex> i feel like it is rather challenging to structure programs because of the number of things I have to think about being a novice haskeller 
10:12:25 <joe9> cocreature: Thanks a lot. I feel brain dead that I cannot think it up.
10:12:29 <Fusionnex> i feel like my brain just doesnt think like a functional programmer so its hard to get useful things done
10:12:36 <Fusionnex> slowly shifting there
10:12:46 <joneshf-laptop> Fusionnex, then don't think about them :)
10:13:02 <cocreature> Fusionnex: practice helps :)
10:13:02 <joe9> Fusionnex: same here. I just feel that my brain cannot think this through. feel like a sheep.
10:13:17 <joneshf-laptop> A fairly huge benefit of Haskell is that you can make large changes with much confidence.
10:13:19 <Fusionnex> im working through practical haskell and learn u a haskell for great good
10:13:35 <Fusionnex> i frekaing love the compiler and the type safety is amazing compared to other languages
10:13:38 <TotallyNotNeomex> i dont care about haskell but ive heard there are cool people here
10:13:58 <joneshf-laptop> So if realize you're doing something wrong, just make changes.
10:14:10 <Fusionnex> change it till it compiles and then it works
10:14:12 <Fusionnex> :-D
10:14:39 <joe9> cocreature: I cannot use: parseIBFormat x = parseIBFormat (from x) -- as the x input is a bytestring. not the actual structure that is being parsed to. Is this where Proxy helps?
10:14:43 <joneshf-laptop> At least, that's the conventional wisdom
10:15:00 <cocreature> Fusionnex: just make sure that you are also actually writing code and not only reading books
10:15:21 <Fusionnex> im looking to contribute to some open source libraries, like possibly datascience for haskell
10:15:30 <joneshf-laptop> The problem is, when first starting out, most people don't think much in types, so the compiler isn't quite as helpful for large changes like that.
10:15:35 <Fusionnex> im a bioinformatician who happens to find functional programming fascinating
10:16:11 <Fusionnex> types and typed composition makes sense to me to some extent, and i've got map and fold down
10:16:31 <joneshf-laptop> Like, if every invariant is at the value level, type checking will not help much.
10:17:02 <joneshf-laptop> If you move invariants up to the type level, type checking is more useful
10:17:16 <Fusionnex> that makes sense
10:17:30 <joneshf-laptop> data science eh?
10:18:29 <Fusionnex> well i feel that haskell may have advantages in writing software for distributed concurrent systems in a more st ructured typesafe way
10:18:42 <cocreature> joe9: oh right sorry. I don’t think proxy is going to save you here. let me think about it
10:19:14 <Fusionnex> but i don't know enough haskell to really make it happen at the moment. i write in c#, R, and python, and have contributed to open source libraries before, just need a better practical handle on haskell
10:19:29 <Fusionnex> i'm really learning it to make myself a better programmer in general, and to learn a new way to approach problems
10:19:30 <cocreature> joe9: parseIBFormat = fmap to gparseIBFormat
10:19:31 <joe9> cocreature: found something here https://jeltsch.wordpress.com/2016/02/22/generic-programming-in-haskell/
10:19:43 <joneshf-laptop> Fusionnex, I don't want to send you down a rabbit hole this early, but there's some really interesting ideas here: https://izbicki.me/#haskell
10:19:47 <joe9> cocreature: good idea. Thanks.
10:20:00 <joneshf-laptop> Fusionnex, unfortunately, it looks like it's mostly bit rotted.
10:20:17 <joe9> cocreature: that helped. Thanks again.
10:20:45 <Fusionnex> joneshf-laptop: hmm, looks interesting
10:20:56 <Fusionnex> joneshf-laptop: i know there are tensorflow bindings for haskell which is kind of interesting
10:21:12 <Fusionnex> joneshf-laptop: although they are not a first class citizen like python
10:21:15 <joneshf-laptop> Fusionnex, I especially like this post: https://izbicki.me/blog/hlearn-cross-validates-400x-faster-than-weka.html even if I can't verify whether it's accurate or not.
10:21:32 <Fusionnex> joneshf-laptop: that's where i've seen his face!
10:21:53 <Fusionnex> joneshf-laptop: i've used weka, and i think its entirely possible to be true, but i haven't verified it
10:23:02 <joneshf-laptop> Fusionnex, cool
10:23:19 <joneshf-laptop> Fusionnex, in any case, I'd love to see what you end up doing.
10:23:35 <joneshf-laptop> Fusionnex, even if what you end up doing is not continuing with Haskell
10:23:53 <Fusionnex> joneshf-laptop: bleh, im such a novice at haskell it is going to take me a while to become productive
10:25:05 <Fusionnex> joneshf-laptop: even if i don't become super proficient at haskell, it has helped me learn a lot of functional programming paradigms in R which has absolutely been useful
10:27:26 <Fusionnex> joneshf-laptop: what projects are you working on at the moment?
10:31:17 <joneshf-laptop> Fusionnex, wrapping some APIs at the moment.
10:31:32 <joneshf-laptop> Fusionnex, Rollbar  currently, and maybe Datadog later.
10:33:25 <Fusionnex> joneshf-laptop: error logging always a good contribution :)
10:42:16 <jennyrgb> what are monads? I don't get it
10:42:48 <Fusionnex> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
10:42:54 <Fusionnex> jennyrgb: this helped me
10:43:03 <benzrf> nooooooo
10:43:05 <benzrf> Fusionnex: stop linking that!
10:43:11 <benzrf> it's not helpful!
10:43:13 <Fusionnex> :(
10:43:16 <Fusionnex> why not?
10:43:21 <maerwald> benzrf: yes it is
10:43:26 <cocreature> jennyrgb: are you familiar with Functor and Applicative?
10:43:41 <benzrf> maerwald: ??
10:43:51 <qmm> glguy: i didn't know you could run "cabal get package_name" to fetch sources. that's quite handy. i'm guessing you gave up at malformed mach-o?
10:43:55 <Fusionnex> i mean you could explain straight lambda calculus and tell them to read alonzo church's papers and come back after a graduate course in mathematics
10:44:04 <monochrom> I find that picture inaccurate, too.
10:44:08 <jennyrgb> cocreature: what's applicative? 
10:44:22 <jennyrgb> I'll just read that page :p
10:44:26 <cocreature> jennyrgb: https://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#t:Applicative
10:44:28 * benzrf sighs
10:44:29 <maerwald> benzrf: if people want a completely correct definition, they can read the maths. That link tries to give an intuition that works in a lot of cases, not in ALL.
10:44:49 <maerwald> over-nitpicking rarely helps with building up an intuition
10:44:50 <benzrf> maerwald: im not convinced it's actually a helpful intuition
10:44:57 <maerwald> I disagree then
10:45:00 <joe9> cocreature: one quick question, please? How do I parse the :+: types. I cannot know if they are the L1 or the R1 ? code http://dpaste.com/252GQBT line 113
10:45:21 <Fusionnex> benzrf: it's entirely possible that there could be inaccuracies in that, and it may not be pure enough for some, but it seems helpful for beginners
10:45:30 <benzrf> maerwald: well, i guess it's a good illustration _of certain specific monads_
10:45:32 <cocreature> joe9: just take a look at the constructors https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-Generics.html#t::-43-:
10:45:38 <cocreature> joe9: it’s somewhat similar to Either
10:45:41 <maerwald> benzrf: and that's already helpful
10:45:42 <benzrf> maerwald: i just take issue with presenting it as though it's a _pattern for monads in general_
10:45:47 <benzrf> yeah, ok
10:45:58 <Fusionnex> benzrf: there are much better youtube vidoes for explaining monads i think as well 
10:46:19 <Fusionnex> benzrf: i understand why you would take issue with _pattern_ for monads 
10:46:51 <joe9> jennyrgb: monad is a mechanism to join 2 functions together. It helps avoid boilerplate code such as checks for correct argument value , etc.
10:47:10 <benzrf> joe9: that's not really a good way of thinking aobut it
10:47:27 <benzrf> Fusionnex: mostly i just get pissy about trying to approach monads as something to understand before you can use them
10:47:33 <benzrf> Fusionnex: because ultimately the only way to understand them is to use them
10:48:10 <joe9> cocreature: I understand how the constructors work. but, when parsing a value, I would not know whether that value is on the Left side or the Right side. Does that make sense?
10:48:34 <cocreature> joe9: well you need to pattern match to figure that out. just like you do for Either
10:48:35 <Fusionnex> benzrf: I agree, and i dont think i fully grasp monads yet considering I havent used them enough. reader and writer were somewhat enlightening though
10:48:37 <maerwald> benzrf: that's not really a good approach to teaching though. You could say that about anything. When programmers look at the maths of monads, it's mostly unhelpful. Saying "just use them" is also unhelpful
10:48:50 <EvanR> a way to "join" two arrows together is a category not a monad
10:48:56 <benzrf> maerwald: i don't think it is, as long as you point to some explanations of individual monads
10:49:01 <benzrf> jennyrgb: basically heres the deal with monads:
10:49:23 <maerwald> benzrf: that doesn't really help imo
10:49:38 <Fusionnex> benzrf: thanks for giving your understanding of monads, looking at several ways to conceptualize them is important I think
10:49:58 <EvanR> just use them
10:50:20 <EvanR> later you can delve into a more sophisticated understanding
10:50:43 <benzrf> jennyrgb: it turns out that there's this particular pattern that crops up across many types, where you have a pair of functions that you tend to use in particular ways that look structurally similar even though they're doing different things in each type
10:50:45 <EvanR> you will get into the habit of going back and trying to understand what you did in some rigorous way
10:51:13 <maerwald> there're a few "fuzzy" explanations about properties and intuition of monads that are helpful and they must be fuzzy, otherwise you can't explain what they mean to you as a programmer
10:51:18 <monochrom> The picture could have saved itself by stating what it actually works for. When one makes a sentence "a monad is ___" then it has an implicit "all" and one can't just weasel out of it with "I don't mean all".
10:51:21 <maerwald> just saying "look at 500 monad instances" doesn't help
10:51:23 <benzrf> jennyrgb: so people call a particular case of a type and two functions related to it a "monad", so that you can write code which captures particular structures that you might want to do for any given monad
10:51:48 <benzrf> jennyrgb: however, it is very hard to explain exactly what it is that all monads have in common, except that you tend to use them in similar patterns of code
10:52:03 <benzrf> therefore, to understand monads, you just need to use enough different monads until you begin to recognize the pattern
10:52:08 <maerwald> no
10:52:16 <benzrf> then you can start thinking about writing code that captures these patterns
10:52:16 <maerwald> doubt it
10:52:31 <jennyrgb> brb
10:52:37 <Fusionnex> LOL
10:52:47 <EvanR> dont stop what you do maerwald
10:52:56 <maerwald> https://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative
10:53:12 <maerwald> the accepted answer is very nice
10:53:17 <maerwald> and it uses fuzzy terms
10:53:19 <maerwald> but that's fine
10:53:42 <maerwald> you can't explain that when all you want to do is be correct and catch all cases
10:53:54 <maerwald> that's not how you teach and build intuition
10:54:28 <benzrf> maerwald: i read a *lot* of monad intuition posts and i am not convinced that any of them actually helped me
10:54:43 <benzrf> well, ok, now that i'm reading the linked post -
10:54:53 <benzrf> i guess this may be helpful
10:54:54 <maerwald> that's basically the only post that helped me ;)
10:54:56 <EvanR> theres something to be said for building wrong intuition fast and going back later to fix it
10:55:06 <EvanR> if it gets the job done
10:55:10 <benzrf> but you'll notice that it's talking about how you can use a monad, not "what a monad is"!
10:55:23 <maerwald> EvanR: yeah
10:55:25 <benzrf> that is, what patterns of use are possible to implement with a monad
10:55:30 <benzrf> which is what i was talking about :)
10:55:47 <qmm> lambdabot; cd lambdabot-5.1.0.1; cabal new-build
10:55:51 <benzrf> i guess i can concede that i may have hyperfocused on ONLY learning-by-using
10:55:51 <EvanR> however wrong intuition about monads might end up being the basis of a world wide undeletable javascript framework
10:55:56 <maerwald> benzrf: but I doubt that just by looking at 20 different monad instances... most people would still not find those patterns
10:56:03 <EvanR> that would be silly
10:56:18 <benzrf> yeah ok, i guess there's value in explanations when they focus on usage patterns
10:56:20 <Fusionnex> EvanR: oh goodness, javascript makes me cry
10:56:32 <cocreature> maybe we should just accept that different people have different ways of learning things
10:56:36 <benzrf> i guess i just got so used to monad explanations trying to explain "what a monad is" rather than presenting patterns that arise with monads
10:56:45 <benzrf> that i started to habitually reject monad explanations entirely :>
10:57:00 <maerwald> we're making a pretty good case why learning haskell is hard btw :)
10:57:15 <MarcelineVQ> talking about learning haskell is hard
10:57:16 <EvanR> both of you are analyzing it from the perspective of already knowing all this
10:57:17 <maerwald> (not because it's different)
10:57:35 <maerwald> EvanR: well, I also tried to explain it to others, so I have some experience there too
10:57:57 <EvanR> i never have, i only ever explained algebraic data types and type classes
10:58:07 <EvanR> and then monads were just another thing
10:58:12 <maerwald> it's easier to teach python, java or whatever :P
10:58:19 <joneshf-laptop> maerwald, is it hard because there's years of bad information floating around?
10:58:26 <benzrf> maerwald: my opinion is generally that learning haskell is hard, but it's not much harder than learning python
10:58:35 <maerwald> joneshf-laptop: no, it's hard because the concepts in haskell are more abstract and advanced
10:58:45 <EvanR> you can use python without knowing anything about it
10:58:49 <maerwald> yep
10:58:49 <EvanR> haskell, not so much
10:58:49 <benzrf> maerwald: the problem is that people who are learning python very often already know javascript or something, so they got the difficulty out of the way, and they perceive python as easier than it is
10:59:10 <maerwald> benzrf: that's what I disagree with. I don't think the paradigm per-se or the previous knowledge is the big difference
10:59:12 <benzrf> whereas few people have a pre-existing base for haskell concepts, so it's almost always as hard as it really is
10:59:23 <maerwald> it's the abstraction and the kind of concepts haskell is promoting
10:59:42 <joe9> cocreature: I am not talking about pattern matching but while parsing http://codepad.org/89lpHzS1 (this is not valid), how would I know if it is a L1 constructor or R1 constructor.
10:59:42 <EvanR> speaking of which
10:59:50 <EvanR> why is haskell catching on more than scheme?
11:00:04 <benzrf> well, i can acknowledge that it's harder to get to a level of haskell expertise where you can use it for programs than it is to get to a level of python expertise where you can use it for programs
11:00:08 <hpc> EvanR: i think i would argue it the other way around
11:00:08 <EvanR> seems like scheme has the "easy" factor like python and is older
11:00:12 <benzrf> but like EvanR said, that's just because you can use python without knowing anything about it :P
11:00:20 <hpc> EvanR: it's a struggle sometimes just to figure out what the right import syntax is in python
11:00:21 <Fusionnex> EvanR: you may not want to hear this, but I think it is due to some larger instuitional support through stack etc
11:00:33 <joe9> I can try a case statement
11:00:35 <EvanR> stack? really?
11:00:36 <Fusionnex> EvanR: resulting in increased popularity
11:00:37 <hpc> and all those __magic_identifiers__ for basic functionality get on my nerves
11:00:58 <hpc> while haskell gives you instant feedback on everything via the compiler
11:01:08 <cocreature> joe9: well that’s a type error. you need a "Parser (a :+: b)" but your definition is constructing some sort of function
11:01:15 <Fusionnex> im not saying stack is driving it, but i am saying that larger corporate sponsorship seems to result in increased popularity of haskell
11:01:22 <joe9> cocreature:  http://codepad.org/hJJH1rCP
11:01:42 <maerwald> benzrf: doing proper C is harder than haskell, but the only really complicated "concept" are pointers. Everything else is just pitfalls, compiler details and whatnot. In haskell it's about the primary concepts used everywhere. And there are a LOT of them. Monads just being the most popular one, that's already fairly problematic for a wide audience.
11:02:13 <joe9> but the :+: is not exported by Generics. maybe I can use a Parser.try?
11:02:18 <EvanR> monads are not that different from + in terms of languages features
11:02:19 <benzrf> maerwald: i think if you look at the fundamental language semantics, haskell is really approximately on the same level as C
11:02:29 <maerwald> http://dev.stephendiehl.com/hask/
11:02:30 <benzrf> maerwald: it's just that C doesn't do as much abstraction-building
11:02:35 <EvanR> these features are going to be just as alien to somebody who doesnt know monads as monads
11:02:47 <maerwald> haskell is so full of concepts, there are very few languages that can keep up 
11:02:49 <benzrf> maerwald: yes, those are all idioms or libraries, not fundamental language semantics
11:03:10 <maerwald> benzrf: doesn't matter when half of the ecosystems uses them
11:03:12 <benzrf> and if you want to write real C, you also have to learn all kinds of idioms and libraries
11:03:26 <tsahyt> benzrf: at least as long as we're talking about about haskell98. once you bring in GHC extensions, this is no longer the case I think
11:03:30 <Fusionnex> what are the most helpful libraries for writing practical haskell ?
11:03:32 <benzrf> tsahyt: ...well, ok :)
11:03:35 <maerwald> most people only use libc when they write C. It's pretty common to reimplement everything you need
11:03:56 <benzrf> then doesnt that make it HARDER, since you have to know how to implement everything you need?
11:03:57 <EvanR> Fusionnex: parsec, optparse-applicative, 
11:04:05 <monochrom> I happen to think that Haskell has to be harder than imperative languages and other functional languages (SML for example) too.
11:04:05 <EvanR> text, bytestring
11:04:23 <maerwald> benzrf: I thought my argument was obvious: different CONCEPTS are widely used in the haskell ecosystem
11:04:25 <tsahyt> Fusionnex: containers
11:04:33 <maerwald> that's not really true for C
11:04:38 <benzrf> maerwald: btw, if you think python is easier than haskell - please try explaining to a beginner why this code is wrong: "grid = [[True] * 10] * 10"
11:04:40 <benzrf> ;)
11:04:41 <monochrom> In all other languages both "xxx" and getLine() have type String. In Haskell they have different types.
11:04:50 <joneshf-laptop> I dunno, don't you think that most of these problems stem from people starting with bad resources and having to relearn properly?
11:04:55 <tsahyt> Fusionnex: as well as unordered-containers and vector. those are probably the ones I find myself depending on most often
11:05:03 <joneshf-laptop> LYAH is like the top result for haskell stuff
11:05:07 <benzrf> maerwald: well, i mean - there's all kinds of algorithms and data structures in C
11:05:15 <maerwald> benzrf: C doesn't have nearly the amount of abstract concepts like haskell does
11:05:19 <joneshf-laptop> But it's definitely not the first resource you should try and consume.
11:05:23 <benzrf> maerwald: that's fair, yeah
11:05:25 <cocreature> joe9: using :+: as a data constructor with two arguments makes about as much sense as using Either as a data constructor and passing it both the Left case _and_ the Right case. you probably want something like "gparseIBFormat = fmap L1 gparseIBFormat <|> fmap R1 gparseIBFormat"
11:05:35 <Fusionnex> are containers like generic lists ?
11:05:37 <monochrom> If you try to learn a language just enough to write "input a line from the user, then echo it back", Haskell already needs you one or two more concepts than other languages.
11:05:54 <maerwald> benzrf: neither does python. Java is a different situation, you could argue that design patterns are a similar beast
11:06:00 <joe9> cocreature: thanks. makes sense.
11:06:01 <tsahyt> Fusionnex: containers is the package implementing things like Data.Map
11:06:25 <benzrf> maerwald: "neither does python"?
11:06:28 <benzrf> oh wait
11:06:28 <monochrom> OTOH "xxx" vs getLine() is also why I think that other languages are philosophically wrong and Haskell got it right (one way of being right anyway).
11:06:31 <tsahyt> Fusionnex: basically a bunch of container data structures that I personally end up requiring very often, since base doesn't provide much in that regard
11:06:34 <benzrf> ok, didnt connect which sentence you were continuing
11:06:58 <benzrf> 14:04 <benzrf> maerwald: btw, if you think python is easier than haskell - please try explaining to a beginner why this code is wrong: "grid = [[True] * 10] * 10"
11:07:00 <benzrf> :P
11:07:14 <Fusionnex> tsahyt: cool, ill check it out.thanks for the recommendations
11:07:18 <cocreature> Fusionnex: "containers" is the name of a package. not the name of some generic abstraction or data type
11:07:21 <EvanR> ok
11:07:57 <joneshf-laptop> Whereas a meaningful book like haskellbook is harder to find.
11:08:15 <joneshf-laptop> Like, there's years of stuff we can't erase from the internet
11:08:20 <maerwald> benzrf: that's just obfuscation and details, not really "concepts"
11:08:25 <monochrom> But when it comes to ease, apparently the wrong one is also the easier one.
11:08:31 <joneshf-laptop> It's not even on https://wiki.haskell.org/Books for instance
11:08:33 <benzrf> maerwald: are you kidding me?
11:08:35 <maerwald> benzrf: python hardly has a lot of abstraction
11:08:47 <tsahyt> joneshf-laptop: I still don't think the haskellbook is the best way to first dive into the language. it just progresses very very slowly
11:08:47 <maerwald> benzrf: how often do you see people write that code?
11:08:48 <benzrf> maerwald: object identity and mutation is one of the most fundamental concepts in python
11:09:00 <maerwald> you're coming up with a pathological example
11:09:01 <tsahyt> joneshf-laptop: I feel that for a lot of people they might lose interest before even coming to the interesting bits
11:09:04 <benzrf> i am not
11:09:10 <benzrf> ive personally made that mistake multiple times
11:09:13 <maerwald> I've never seen such python code
11:09:19 <tsahyt> that said, it's great for a second exposure
11:09:33 <joe9> Fusionnex: that is a good article about monads with pictures, etc.
11:09:44 <benzrf> maerwald: you've never seen python code where you accidentally mutate a list that you're also holding a reference to elsewhere?
11:09:49 <joneshf-laptop> tsahyt, I'm not saying that it's the best way either.
11:09:52 <benzrf> because you forgot to copy your argument?
11:10:31 <monochrom> EvanR: The thing to be said about wrong intuition fast first and fix it later is that you need to be aware that you are doing that.
11:10:34 <tsahyt> I'm waiting for the joy of haskell book. I've been waiting for a non-beginner book on Haskell for a long time now
11:10:45 <Fusionnex> cocreature: thanks for the clarification
11:10:49 <joneshf-laptop> tsahyt, but it's tons better than LYAH for a beginner
11:11:45 <EvanR> monochrom: good point, monad explanations are doing that obliviously
11:11:55 <tsahyt> joneshf-laptop: I'd say that depends a lot on the particular beginner. LYAH is much shorter and serves better as a whirlwind exposure. but because of that it also doesn't go in depth with anything
11:12:01 <EvanR> like whoever is explaining it never went back and fixed it personally
11:12:22 <maerwald> benzrf: I find your example even fairly inutitive
11:12:28 <tsahyt> I think the first few chapters of LYAH was also the first resource I used when starting to learn haskell. I then quickly switched over to RWH.
11:12:31 <benzrf> maerwald: huh?
11:12:31 <maerwald> but that's when I don't think functionally
11:12:42 <benzrf> no, it's very intuitive if you're acclimated to python
11:12:47 <benzrf> but again - try explaining the problem to a beginner!
11:13:04 <maerwald> you mean a haskell beginner? ;)
11:13:09 <benzrf> i mean a programming beginner
11:13:09 <joe9> any good books to learn the basics of haskell concepts (functor, applicative, alternative) well?
11:13:19 <joneshf-laptop> tsahyt, I also think RWH is much better than LYAH
11:13:26 <maerwald> I think it's rather intuitive for a general programmer beginner, but I don't know about that
11:13:27 <benzrf> i've been comparing "haskell to a programming beginner" and "python to a programming beginner" all along
11:13:28 <maerwald> that's guessing
11:13:38 <maerwald> I might be wrong
11:13:43 <benzrf> maerwald: the list still prints as [[True, True, True], [True, True, True], [True, True, True]] regardless of whether you've constructed it correctly or not
11:13:44 <tsahyt> joneshf-laptop: unfortunately it's outdated by now
11:13:47 <maerwald> I've never teached absolute programming beginners
11:13:49 <tsahyt> a RWH 2e would be great
11:14:19 <benzrf> maerwald: it is very natural to think of lists as "values", like something you've written down on a piece of paper
11:14:27 <benzrf> and if i change what i've written down, i just change what i change
11:14:31 <maerwald> you'll have to ask someone else, who has experience with absolute programming beginners
11:14:34 <benzrf> i don't have 3 rows that are magically the same row
11:14:39 <MarcelineVQ> benzrf: interesting, that's certainly not the list I guessed
11:14:43 <tsahyt> oh nice I just saw that with GHC 8.2, Bi{fold,travers}able will be in base
11:14:49 <benzrf> MarcelineVQ: er, i was contracting it to as if i did [[True] * 3] * 3
11:14:51 <benzrf> :p
11:14:52 <qmm> glguy: where did you specify dependent-sum-0.4 as a dependency? i don't see dependent-sum in the cabal file
11:14:56 <MarcelineVQ> o oops
11:15:08 <maerwald> MarcelineVQ: it's totally what you would expect in python
11:15:13 <MarcelineVQ> ehe
11:15:15 <benzrf> maerwald: _if you know python_
11:15:33 <maerwald> as I said: I have no idea how a total program beginner thinks
11:15:38 <maerwald> my first language was pascal
11:15:38 <benzrf> well, ok
11:15:41 <benzrf> heh
11:15:56 <benzrf> i do agree that haskell is more abstract
11:16:02 <benzrf> but im not convinced that this means more effort overall
11:16:15 <EvanR> people like abstract stuff
11:16:22 <EvanR> so haskell should be very popular
11:16:36 <glguy> qmm: I didn't
11:16:36 <monochrom> benzrf: Java has a similar disparity. Suppose I have two state variables, int x and Vector y. Then when I pass them to some method f(x, y), f can't mutate my x but it can mutate my y. Eventually we just got used to it and say "ah the difference between primitive types and classes"
11:16:39 <benzrf> if you learn something like python, you don't have to deal with such abstract concepts, but you do have to deal with mechanics that aren't clear up front such as object identity and scoping and closures
11:16:48 <glguy> qmm: I just allowed cabal to pick a newer version with --allow-newer=dependent-sum
11:17:05 <benzrf> so it's not clear to me that the extra effort for the abstractions isn't counterbalanced by the extra effort for the subtleties in python's semantics
11:17:18 <benzrf> haskell's semantics are almost entirely exactly what they seem to be the first time you learn them, i think
11:17:24 <EvanR> python has plenty of abstract concepts, the idea of an invisible mutable runtime system?
11:17:27 <benzrf> :)
11:17:36 <maerwald> EvanR: I recently talked to someone who made a proposal to write a compiler that sounded to me like a weird imperative version of what Idris, F* etc do... then I gave him a few references and this is what I got back: "I looked at haskell and now I don't understand why imperative programming is still so popular" xD
11:17:40 <maerwald> I laughed hard
11:17:43 <monochrom> Whereas C++ avoids this problem by having call-by-value vs &'s call-by-reference. (And Pascal too.)
11:17:43 <benzrf> there might be a case for C being simpler than both since its semantics are mostly what they seem and it doesn't have such abstractions
11:17:45 <benzrf> but idk
11:17:59 <EvanR> F*?
11:18:05 <maerwald> EvanR: yep, amazing language
11:18:07 <maerwald> have a look at it
11:18:15 <benzrf> oh damn
11:18:19 <benzrf> i used to have a tab about F* open
11:18:21 <benzrf> for like a month
11:18:25 <benzrf> then my session crashed
11:18:31 <maerwald> there's a channel, we're just 8 people though or so
11:18:46 <Fusionnex> benzrf: I think what you are saying is there will be less "gotchas" in haskell than in python?
11:18:58 <qmm> glguy: thanks, trying that now
11:18:59 <benzrf> Fusionnex: yeah, that's not a bad way of putting it
11:19:15 <benzrf> Fusionnex: except that i think "gotcha" may be a slightly trivializing way of putting it, because the "gotchas" are actually the core language semantics
11:19:24 <EvanR> hmm. "gotchas" ....
11:19:26 <benzrf> e.g., the problem with "[[True] * 3] * 3"
11:19:43 <Fusionnex> benzrf: for sure they are core languages features, but they definitely don't behave like you would expect
11:20:11 <benzrf> yeah :) i just mean that "gotchas" has kind of a connotation of bumps in the road, not the overall road's direction
11:20:12 <maerwald> I think ruby is more "wtf, how did this..."... but python is mostly intuitive imo
11:20:19 <Fusionnex> I'm a self taught programmer, and the first time I encountered mutability issues it was so challenging
11:20:29 <benzrf> maerwald: ruby is to python as python is to haskell, in that respect
11:20:34 <EvanR> beyond the initial grocery basket of gotchas that haskell isnt anything like any other mainstream language... you have performance gotchas
11:20:42 <benzrf> maerwald: you've just internalized python's weirdness :)
11:20:50 <Fusionnex> EvanR: performance gotchas are just not understanding the compiler ?
11:20:59 <maerwald> I use python for prototyping and I don't even care what half of the stuff does what I do. I use a subset of the language.
11:21:00 <EvanR> good question
11:21:18 <ggVGc> haskell also has the gotcha of starting to write a program and ending up with a ultra-generic library for some new type theory concepts you just learnt
11:21:24 <benzrf> ggVGc: huehuehuehuehue
11:21:34 <EvanR> at what point does performance factor in, language level, implementation level, emotional level
11:21:35 <maerwald> xD
11:21:36 <Fusionnex> EvanR: performance issues are definitely more difficult to reason about I think in haskell
11:21:53 <Fusionnex> EvanR: I firmly agree. Who cares about performance if your productivity goes through the roof XD
11:22:00 <benzrf> imo, in practice ggVGc usually ends up more like VggoGc
11:22:00 <erisco> :t traverse
11:22:01 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:22:04 <erisco> :t traverse (>>=)
11:22:06 <lambdabot> (Monad m, Traversable t) => t (m a) -> (a -> m b) -> t (m b)
11:22:24 <maerwald> EvanR: oh man, emotional level... now you've said something =D
11:22:28 <EvanR> Fusionnex: haskell = productivity going through the roof, ill have some of what youre smoking
11:22:44 <monochrom> What does "performance" mean at the emotional level? Like winning an Oscar?
11:23:00 <EvanR> performance reasoning is often driven by mysticism
11:23:21 <Fusionnex> EvanR: I think that my productivity in all languages has improved after learning some haskell :-D
11:23:33 <EvanR> is there anything in the language standard that you can logically use to reason about performance, seq ?
11:23:51 <ggVGc> I've had very few times in my life where performance became an actual issue, and it's always been just a matter of doing some extra work. All you need is a decent profiler, and I think GHC has good enough tools
11:23:53 <maerwald> EvanR: for prototyping, haskell is just pooooor. You have too much up-front design decisions and stuff you think about. Where in python you just fire up stuff and then realize it works, but also sucks in the end. Which is good for prototyping.
11:23:55 <ggVGc> at least so far in my use cases
11:24:14 <monochrom> Actually no for Haskell Report. But if you assume lazy evaluation and that seq is eager evaluation then you can do it.
11:24:30 <EvanR> heh
11:24:47 <EvanR> you cant legally reason about performance
11:24:50 <ggVGc> I think the main lesson haskell gave me is the value of composition
11:24:55 <monochrom> But both assumptions are good only 99.9% of the time.
11:24:55 <ggVGc> e.g composable types
11:25:01 <ggVGc> now I make composable types wherever I go
11:25:09 <benzrf> maerwald: well, why not think about how it should work in the first place o=
11:25:13 <glguy> For my work Haskell is excellent for prototyping. As the project changes the type system helps support making sweeping refactorings
11:25:18 <benzrf> maerwald: (but no i get what you mean :P)
11:25:40 <maerwald> benzrf: well, for Prototyping... I want to a) get VERY fast results and b) want to think about what sucked and what is problematic AFTERWARDS
11:25:45 <maerwald> so I can do the real thing properly
11:25:49 <maerwald> haskell doesn't let me do this
11:25:55 <monochrom> To be fair I actually doubt that any language standard is any better.
11:26:25 <maerwald> benzrf: which is fine btw. I'm not saying it should let me do that
11:26:37 <maerwald> it's a conflict of interest
11:26:46 <EvanR> people use C++ for performance, is there any logical basis for that? or is it mystic
11:27:09 <ggVGc> in my experience I've had way faster development and pretty much same performance with C and Lua, compared to C++
11:27:11 <joe9> code: http://dpaste.com/0NJBEPD  error: http://codepad.org/kUbEicjE . any suggestions on how to fix it, please?
11:27:12 <monochrom> It is half empirical and half extrapolation.
11:27:18 <benzrf> maerwald: yeah, i can see that
11:27:25 <EvanR> i like C better too but this is just a standalone question
11:27:38 <monochrom> There is empirical fact that you can write fast programs in C. Then people extrapolate that to C++.
11:27:54 <monochrom> And all the while forgetting that Fortran is even better. But meh, people want OOP too.
11:28:11 <ggVGc> monochrom: people also want to compile for all platforms
11:28:19 <ggVGc> I guess fortran support is more limited
11:28:21 <ggVGc> maybe I'm wrong
11:28:31 <EvanR> well youre not getting fortran or C++ on a phone
11:28:33 <monochrom> No, Fortran support is wider.
11:28:40 <ggVGc> really?
11:28:45 <joe9> I am trying to write a simple function that I can use for debugging how the serialization or deserialization works.
11:29:06 <ggVGc> could I get fortran onto some random microcontroller I pick up from aliexpress?
11:29:16 <monochrom> It has been around longer, and more scientists with less known hardware use Fortran.
11:29:52 <ggVGc> EvanR: pretty sure you can get C++ onto most phones?
11:30:06 <EvanR> i dont think its popular
11:30:22 <monochrom> No, not for microcontrollers.
11:31:13 <cocreature> joe9: you probably want to use ScopedTypeVariables
11:32:33 <tsahyt> Has anyone here been reading Type-Driven Development with Idris?
11:32:47 <Fusionnex> as a personal preference question. does anyone use haskell and visual studio code?
11:33:04 <Fusionnex> tsahyt: type driven development sounds so sexy
11:33:06 <joe9> cocreature: no, that does not seem to help.  http://dpaste.com/2THGC6E  error http://codepad.org/TI9VJKxi
11:33:11 <EvanR> tsahyt: i read the first few chapters
11:33:30 <joe9> Is the book online?
11:33:33 <monochrom> Someone did. Someone actually wrote a Visual Studio plugin for Haskell.
11:33:39 <tsahyt> EvanR: would the book be useful for a haskell programmer with no intentions of switching to idris?
11:33:44 <monochrom> Then they finished their PhD and stopped.
11:33:53 <EvanR> yes
11:34:05 <tsahyt> okay thanks. I guess I'll put it on my wishlist
11:34:15 <cocreature> joe9: scopedtypevariables have no effect without explicit forall
11:34:16 <Fusionnex> monochrom: :( that is rather unfortunate so development is stalled on the plugin?
11:34:19 <EvanR> its useful for making you jealous of dependent types
11:34:29 <monochrom> Yes. No one uses it now.
11:34:33 <EvanR> more seriously, some of the techniques in there can technically be done in haskell, at some expense
11:34:38 <monochrom> I don't even know whether it is usable or not.
11:34:51 <Fusionnex> monochrom: i'm going to give it a try right now and see what happens :-P
11:34:57 <EvanR> with GADTs, DataKinds
11:35:05 <tsahyt> EvanR: that's exactly what I wanted to hear :)
11:35:11 <tsahyt> I'll buy it then
11:35:29 <Tuplanolla> I was gone for two weeks due to hard drive failure. Did I miss anything important?
11:35:32 <Fusionnex> GADTs generalized algabraic data types?
11:35:45 <EvanR> thats what it expands to
11:35:52 <benzrf> bbl
11:36:41 <Fusionnex> monochrom: it seems functional at the moment
11:38:53 <joe9> cocreature: got it. just broke up the function into smaller pieces.
11:45:47 <joe9> instance QC.Arbitrary ClientVersion where arbitrary = return . ClientVersion =<< QC.arbitrary; I am doing this currently. Is there a generic way of doriving this?
11:45:56 <joe9> Is that what CoArbitrary does?
11:47:06 <iqubic> Hello World
11:49:20 <joe9> found it, generic-random
11:49:47 <iqubic> What does that do??
11:49:50 <ski> joe9 : `arbitrary = ClientVersion <$> QC.arbitrary'
11:50:25 <ski> joe9 : if it's a `newtype', try deriving it
11:50:30 <joe9> ski, thanks. I need to read up on Control.Applicative.
11:50:50 <ski> `(<$>)' is an alias for `fmap', belonging to `Functor', not `Applicative', btw
11:51:07 <ski> (and `CoArbitrary' is something else)
11:51:09 <joe9> ski, http://dpaste.com/2J8Z17B is the data definition line 22
11:51:27 <joe9> ski, Thanks.
11:51:56 <ski> if you change `data' to `newtype', you should be able to derive `QC.Arbitrary' (assuming you turn on extension `GeneralizedNewtypeDeriving')
11:52:34 <ski> .. oh, you're already deriving it ?
11:53:09 <joe9> ski, I was trying it. but, it does not work though.
11:53:13 <ski> (or do you have two different classes `Arbitrary' in scope ?)
11:53:20 <joe9> ski, https://byorgey.wordpress.com/2016/09/20/the-generic-random-library-part-1-simple-generic-arbitrary-instances/ found this that helps.
11:53:23 <ski> well .. try what i suggested
11:53:29 <joe9> ski, ok, will do. Thanks.
11:54:02 <ski> since presumably you'll never add another data constructor to `ClientVersion', nor add another component to the data constructor you have
11:54:25 <joe9> http://hackage.haskell.org/package/generic-random
11:57:23 <iqubic> What does generic random do?
11:57:55 <joe9> iqubic: https://byorgey.wordpress.com/2016/09/20/the-generic-random-library-part-1-simple-generic-arbitrary-instances/
12:00:27 <lyxia> joe9: what you wrote is done by GeneralizedNewtypeDeriving
12:01:08 <lyxia> generic-random is actually useful if you have large types
12:02:04 <lyxia> what's wrong with "arbitrary = ClientVersion <$> arbitrary" or deriving Arbitrary
12:02:07 <joe9> lyxia: yes, thanks. I am testing it. I have bigger data types that I want to usi it on.
12:02:19 <joe9> s/usi/use/
12:03:01 <joe9> lyxia: it works. no issues. I am building up to bigger data types and I do not fancy writing that http://codepad.org/7ufJkeJD code over and over
12:03:19 <lyxia> ok sure
12:06:53 <joneshf-laptop> Is there a simple https library like `http-conduit` that doesn't throw a crapton of exceptions?
12:08:02 <emanuel> Hi there :)
12:09:52 <ggVGc> I would hope most haskell code doesn't throw much exceptions
12:09:54 <ggVGc> :(
12:10:14 <iqubic> Is there a library for playing solid tones?
12:10:34 <Fusionnex> iqubic: I think there are some music libraries that may do some thing like that?
12:10:38 <iqubic> Not audio files, just tones
12:11:09 <iqubic> Like I want to be able to play the tone of C for 10 seconds.
12:11:39 <Fusionnex> iqubic: maybe check here: https://wiki.haskell.org/Applications_and_libraries/Music_and_sound
12:12:01 <joneshf-laptop> ggVGc, unfortunately, `http-conduit` throws exceptions like nobody's business
12:12:19 <Boomerang> iqubic: Do you want to play it from Haskell itself or create a file with the audio on it (e.g. .wav)
12:13:31 <iqubic> I'd like to play it directly from haskell, as it is a really simple tone.
12:14:06 <ggVGc> I would suggest not haskell for this
12:14:13 <ggVGc> because it'll end up being C interaction anyway
12:14:18 <ggVGc> might as well use something like ChucK
12:14:41 <iqubic> Why not Haskell?
12:15:55 <Fusionnex> iqubic: how do you get bits of information into your speakers?
12:16:16 <iqubic> Fusionnex: I think you'd have to use C.
12:16:51 <iqubic> or C++ or something/
12:17:44 <Fusionnex> iqubic: device interfacing would be correct, usually has to go through your os to comunicate with your device
12:17:55 <Boomerang> There are wrappers around C libraries that could help you (sfml, sdl) but I'm not sure you can easily generate the sound for these libraries
12:17:58 <Tuplanolla> We have bindings to SDL mixer, no?
12:19:21 <iqubic> Yes, but I don't think there are any simple ways to generate tones for something like, say Morse Code.
12:20:25 <Boomerang> I played around with generating tones to be serialized into a WAV file in Haskell a while ago. It's not great but maybe it can help you: https://gist.github.com/basile-henry/ac86f8bb8829e156d2041084bc6c3613#file-notes-hs
12:20:35 <tsahyt> We do have bindings to several ways in which we can get audio to the speakers
12:20:37 <tsahyt> SDL included
12:21:12 <tsahyt> there are also several alsa packages that I haven't looked at, as well as jack bindings
12:21:13 <erisco> how can you get ghci to expand aliases?
12:21:16 <iqubic> That may help, not sure.
12:21:20 <tsahyt> at least with the jack bindings I know that they work
12:22:05 <Boomerang> Or you could use haskell to generate MIDI and connected it to whatever instrument using jack
12:22:34 <tsahyt> oh yeah that's also a possibility
12:22:51 <tsahyt> shameless plug for my barebones midi lib
12:23:09 <iqubic> How does MIDI work?
12:23:43 <tsahyt> iqubic: basically you send messages like NoteOn C4 64, where C4 is middle C and 64 is a velocity
12:23:54 <tsahyt> and NoteOff etc. there are a bunch of different messages that you can send
12:24:06 <tsahyt> a synthesizer can then interpret this
12:24:24 <iqubic> And how do I do this in Haskell?
12:24:31 <Boomerang> If it's for a small 5 min project you could do like in the gist I shared: have haskell generate WAV samples on stdout and then pipe stdout to aplay
12:25:43 <tsahyt> iqubic: by using alsa or jack, and some suitable midi library for creating those messages
12:26:18 <iqubic> Boomerang: It's Morse Code. Preferable the input could be text, as long as I like. And then the program would start playing the correct morse code.
12:26:47 <iqubic> Also, whould this program be cross-compatible with Windows, or no?
12:27:29 <Tuplanolla> @hackage sdl2-mixer
12:27:29 <lambdabot> http://hackage.haskell.org/package/sdl2-mixer
12:27:34 <tsahyt> as soon as you start interfacing with things like alsa or jack, it's not cross platform anymore. SDL abstracts that away though
12:27:36 <Tuplanolla> I'd try this one, iqubic.
12:27:57 <Tuplanolla> It's not a big mess like most things audio.
12:28:11 <iqubic> So if I use SDL, then it will work on other OSes besides Linux?
12:28:38 <iqubic> Alright, SDL2-Mixer looks dead simplt
12:28:42 <iqubic> *simple
12:28:44 <tsahyt> it should, that's the point of sdl
12:28:54 <joe9> is ghc rts a big deal to port to a new platform?
12:28:54 <EvanR> tsahyt: jack is "cross platform"...
12:29:03 <EvanR> port audio is also a thing
12:29:14 <tsahyt> EvanR: jack is also absolutely awesome imo, but I've heard it can be a bit of a pain on Windows
12:29:30 <EvanR> are we just trying to play sound
12:29:35 <EvanR> port audio man
12:30:00 <iqubic> What I want to do is create an executable that will play sound on both Linux and Windows.
12:31:55 <tsahyt> iqubic: sdl should be a fine choice. it frees you of all the platform specific details and is not that complicated to use
12:32:25 <iqubic> So SDL is this:
12:32:32 <iqubic> @hackage SDL2
12:32:33 <lambdabot> http://hackage.haskell.org/package/SDL2
12:32:45 <tsahyt> @hackage sdl2
12:32:45 <lambdabot> http://hackage.haskell.org/package/sdl2
12:32:47 <tsahyt> case sensitive
12:32:51 <iqubic> @hackage sdl2
12:32:51 <lambdabot> http://hackage.haskell.org/package/sdl2
12:33:13 <iqubic> Isn't this simpler to use: http://hackage.haskell.org/package/sdl2-mixer?
12:33:26 <Tuplanolla> It's a plugin, iqubic.
12:33:31 <iqubic> What is?
12:33:37 <iqubic> sdl2-mixer?
12:34:02 <sm> yes, it's a standard addon extending sdl2
12:34:18 <sm> and yes it will be easier. I didn't notice a tone-playing function specifically
12:34:39 <iqubic> And still cross-compatible with Windows?
12:35:18 <sm> in theory
12:35:44 <Boomerang> I've been looking at SFML bindings and it looks pretty easy to play a pitch with "createSound", "setPitch", "pause", and "play": https://hackage.haskell.org/package/SFML-2.3.2.4/docs/SFML-Audio-Sound.html
12:35:49 <EvanR> sdl mixer is an add on library based on SDL which lets you play samples and mix them together. it also has a music-specific API
12:36:00 <Boomerang> And I'm pretty sure SFML works on both Linux and Windows
12:36:26 <EvanR> to play tones you need to use SDL audio directly and feed raw samples using the audio callback
12:36:45 <iqubic> Is that hard to do?
12:37:08 <EvanR> not really once you get the hang of it
12:37:29 <iqubic> Is there a guide somewhere for that kind of thing?
12:37:37 <EvanR> however doing that from haskell will involve using the FFI to write to output buffers
12:37:53 <EvanR> the SDL documentation exists
12:37:53 <iqubic> What's FFI?
12:38:08 <mauke> @where ffi
12:38:08 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
12:38:14 <EvanR> foreign function interface, its how haskell talks to C
12:38:45 <sm> does not sound simple
12:39:10 <EvanR> if you dont want to do all this from scratch there are plenty of sound synth libraries
12:39:42 <EvanR> https://wiki.haskell.org/Applications_and_libraries/Music_and_sound
12:39:57 <iqubic> Do any of them support playing tones?
12:40:08 <iqubic> Or is that something I'll have to write myself?
12:40:21 <EvanR> that is a basic function of a synth library
12:40:54 <iqubic> Cool.
12:41:13 <iqubic> Are any of those compatible with both Linux and Windows?
12:41:41 <EvanR> good question
12:43:16 <sm> and simple ? I am starting to think no
12:43:31 <iqubic> Why do you think these aren't simple?
12:43:33 <EvanR> i recall one library from conal that was a nice synth dsl
12:43:45 <EvanR> cant remember its name or find it at the moment....
12:44:33 <sm> iqubic: quick research, I haven't found anything that looks simple to install/understand/use
12:44:47 <EvanR> heres one that has an example of exactly what youre asking https://github.com/spell-music/csound-expression
12:45:13 <EvanR> https://hackage.haskell.org/package/csound-expression
12:45:19 <EvanR> dac (osc 440)
12:45:45 <EvanR> csound works on linux and windows
12:45:56 <iqubic> EvanR, what would that function do?
12:46:01 * sm gives that a try
12:46:04 <EvanR> play a 440Hz tone
12:46:42 <iqubic> Can I set a duration for a tone?
12:46:48 <wroathe> So I've been trying to wrap my head around functors and applicative functors... Would it be incorrect or overly simplistic to say that an applicative functor is just a functor that contains a function? And when describing it do you need to specify that that functor can be applied to other functors?
12:47:17 <iqubic> Or is that an infinitely long tone.
12:47:20 <ggVGc> in ChucK this is literally SinOsc s => dac;
12:47:34 <ggVGc> I think that's easier than using portaudio or something through haskell
12:48:02 <iqubic> Can I have a link to chuck? the only thing I was able to find was an http processing library.
12:48:12 <EvanR> iqubic: yes, csound contains functionality to create many kinds of sounds and orchestrate scores
12:48:14 <ggVGc> iqubic: http://chuck.cs.princeton.edu/doc/learn/tutorial.html
12:48:50 <iqubic> ggVGc: What backend does chuck use?
12:49:03 <ggVGc> JACK I think
12:49:15 <ggVGc> not sure if there are other options
12:49:23 <iqubic> Also, ggVGc is ChucK avalible on Hackage?
12:49:37 <ggVGc> iqubic: it's not a haskell package. It's a runtime and language of it's own
12:49:44 <iqubic> What the heck???
12:49:46 <ggVGc> I'm saying I don't think haskell is good for your task
12:49:47 <ggVGc> sorry
12:49:52 <iqubic> Oh. I see.
12:49:58 <EvanR> csound-expression works, i tried it before
12:50:06 <iqubic> I'll use that then.
12:50:12 <EvanR> its a DSL in haskell on top of csound
12:50:17 <Philonous> wroathe, Every functor can contain functions. The special thing about applicatives is that you can combine two. So you can have e.g. combine :: f a -> f b -> f (a,b) 
12:50:20 <EvanR> csound has its own array of backends
12:50:47 <sm> SDL or SFML should be the natural "easy" way to do cross platform sound, it's a pity if they don't do simple non-sampled tones
12:51:22 <EvanR> because SDL mixer is really just a mixer. SDL doesnt even do that for you
12:51:33 <EvanR> same with SFML
12:52:06 <EvanR> for just sound i wouldnt use SDL
12:52:10 <Boomerang> sm what do you mean by non-sampled tone?
12:52:35 <EvanR> he means doing DSP to synthesize sound programmatically
12:52:38 <iqubic> So I have to use csound-expression if I want to get tones?
12:52:38 <wroathe> Philonous: Thanks. That helps.
12:52:58 <sm> Boomerang: iqubic wants to play simple tones, eg a middle C, without having to make/load a sample
12:53:21 <Boomerang> I have not tested it but the link I gave to SFML Sound library seens to be able to do just that (without loading any files beforehand).
12:53:24 <EvanR> iqubic: its a library that exists and does that, youll have to learn to use it to get more complex songs out of it
12:53:45 <iqubic> I'm not trying to get complex songs.
12:53:56 <Boomerang> But SMFL is a pain to install... :/
12:54:08 <EvanR> i never understood the point of SFML
12:54:09 <iqubic> Why is it a pain?
12:54:23 <EvanR> somebody wanted to make an SDL-alike in C++
12:54:34 <EvanR> when SDL exists already
12:54:43 <iqubic> What the heck???
12:54:52 <wroathe> Philonous: So for that to be true either a or b in f a and f b needs to be a function, right?
12:55:01 <EvanR> no
12:55:04 <Philonous> wroathe, No
12:55:07 <EvanR> a and b are any type
12:55:10 <Boomerang> Right, the only reason I brought up SFML is because it's a little bit more high level and can generate a pitch
12:56:00 <sm> I was able to install csound expression but it requires a separate C package (csound)
12:56:07 <EvanR> yes
12:56:15 <sm> which brew doesn't know about
12:57:06 <EvanR> theres a tap apparently
12:57:27 <sm> it knows a bit more about SFML, trying that one
12:57:27 <Philonous> wroathe, The Definition of Applicative looks like this (<*>) :: Applicative f => f (a -> b) -> f a -> f b. So maybe that's why you think it has something to do with functions in Functors. But it doesn't. The idea is really just "we can combine the elements of the left applicative value with the elements of the right value). You could have combine :: Applicative f => f a -> f b -> f (a,b) instead and it would be equivalent.
12:57:28 <EvanR> actually im brew installing csound now without problems
12:58:03 <sm> EvanR: strange, it doesn't find csound in formulae or taps here
12:58:23 <Philonous> wroathe, That is to say, you can define (<*>) using only fmap and combine and you can define combine using only fmap and (<*>).
12:58:37 <EvanR> yep installing version 6.07.0
12:58:52 * EvanR wonders if 0 in 07 is significant
12:59:28 <Boomerang> sm if you manage to install SFML and the bindings to it before me, this is what I'm trying to run on it http://lpaste.net/354462
13:01:25 <wroathe> Philonous: I'm writing this down. Thanks for the help.
13:01:54 <wroathe> Philonous: And yes, that's exactly what I thought that way.
13:01:59 <EvanR> Boomerang: createSound creates what, a sine wave?
13:02:55 <sm> SFML 2.3.4.2 fails to build with csfml 2.4 it seems
13:03:11 <Philonous> wroathe, Obvious exercise: Try to define combine in terms of <*> and fmap and <*> in terms of fmap and combine ;)
13:03:50 <Boomerang> sm: Ah so it's not just me. SFML is probably not the right option at the moment then.
13:03:51 <EvanR> you also need to implement pure with unit :: f () and fmap
13:04:08 <wroathe> Philonous: To me it seemed like the difference was (\x -> x + 4) <$> Just 3 vs. Just (\x -> x + 4) <*> Just 3
13:04:09 <sm> Boomerang: it's very close... probably a one-line PR
13:04:17 <sm> iqubic: not giving up yet, but I think you have identified an area for improvement in haskell
13:04:27 <EvanR> > Just (+4) <*> Just 3
13:04:28 <Boomerang> EvanR: I think createSound creates a sound with the default settings (whatever these are). So yes probably sin wave
13:04:29 <lambdabot>  Just 7
13:04:42 <wroathe> EvanR: good call :P
13:04:43 <Philonous> wroathe, Maybe has a pretty boring Applicative instance. Try lists with at least 2 elements instead.
13:05:11 <Philonous> > [(+2), (*3)] <*> [1,5]
13:05:13 <lambdabot>  [3,7,3,15]
13:05:58 <Philonous> > let combine = liftA2 (,) in combine [2,3] ['a', 'b']
13:06:00 <lambdabot>  [(2,'a'),(2,'b'),(3,'a'),(3,'b')]
13:06:49 <iqubic> Wait, making a tuple is an applicative function?
13:07:06 <iqubic> @src liftA@
13:07:06 <lambdabot> Source not found. Take a stress pill and think things over.
13:07:08 <iqubic> @src liftA2
13:07:08 <lambdabot> liftA2 f a b = f <$> a <*> b
13:07:18 <iqubic> Right, that looks good.
13:07:21 <EvanR> (,) is just another function
13:07:22 <Philonous> The tuple constructor is a binary function, so you can apply it via fmap and <*>, yes
13:09:43 <sm> https://github.com/SFML-haskell/SFML/issues/23
13:11:25 <Boomerang> +1 sm :)
13:15:13 <sm> EvanR: I discovered brew tap csound/csound, but it fails to build here
13:15:32 <EvanR> whats the error?
13:15:58 <sm> oh maybe needs --HEAD
13:16:18 <iqubic> Makes sense
13:17:20 <iqubic> So, csound-expression requires a C Library? Which one?
13:17:26 <sm> csound
13:18:39 * sm feels using csound to play a tone is like using a battleship to cross a pond
13:18:58 <Fusionnex> this is great
13:19:04 <iqubic> Is there an easier way to play a tone?
13:19:05 <EvanR> yeah but iqubics requirements are pretty tough
13:19:11 <Fusionnex> i love how this all started with. can i play c for 15 seconds in haskell
13:19:12 <monochrom> But are you OK with using a battleship to ship cargo? :)
13:19:27 <EvanR> theres are 100 ways to do it and they dont like any of them
13:19:39 <iqubic> EvanR: What do you mean?
13:19:54 <iqubic> What are the ways that I can play a sound in Haskell?
13:19:56 <EvanR> this task is so simple
13:20:21 <EvanR> install a sound library, write the code to output your desired sound
13:20:31 <iqubic> what sound library should I use?
13:20:34 <sm> success: brew tap csound/csound; brew install csound --HEAD; stack install csound-expression csound-expression-dynamic csound-expression-opcodes csound-expression-typed temporal-media data-fix data-fix-cse; stack ghci, import Csound.Base, dac $ osc 440
13:20:44 <iqubic> I'm fine with just about anything.
13:20:50 <EvanR> there you go
13:21:08 <EvanR> install csound, its its own rabbit hole
13:21:15 <EvanR> then install csound-expression
13:21:21 <iqubic> I'll do that.
13:21:51 <Fusionnex> is your sound function mathematically a pure c note though ?
13:22:18 <sm> where "success" means "attainable by a skilled developer in half an hour"
13:22:20 <sm> :)
13:22:23 <EvanR> in what tuning system?
13:22:52 <iqubic> Fusionnex, does that really matter. I'm not using this to play a whole range of sounds.
13:23:04 <iqubic> I'll just pick a tone I loike, and go with that.
13:23:27 <iqubic> *like.
13:23:33 <Fusionnex> :-P i was just thinking of whether or not it was possible to express mathematically pure sounds
13:23:45 <Fusionnex> but i don't know enough about music theory to understand if that even makes sense
13:23:48 * sm . o O omg what is this piano keyboard thing
13:24:00 <iqubic> sm, what are you doing?
13:24:05 <Fusionnex> ratios all the way down
13:24:13 <cocreature> Fusionnex: well just a sine wave of a specific frequency
13:24:21 <EvanR> its not even ratios in the standard system
13:24:27 <EvanR> its irratios
13:24:36 <sm> running through the tutorial at https://github.com/spell-music/csound-expression/blob/master/tutorial/chapters/SynthTutorial.md, I just did "run osc" and did not expect a GUI to pop up :)
13:24:38 <Fusionnex> irratios all the way down ?
13:24:40 <EvanR> 12th root of two
13:25:00 <EvanR> sm: o_O
13:25:06 * sm trying to play a tone of finite length
13:25:06 <iqubic> sm, that link gives me a 404 error.
13:25:13 <sm> remove the comma
13:25:14 <iqubic> I NEED that.
13:25:46 <iqubic> I NEED a way to play a sound of a certain length X.
13:26:29 <EvanR> forkIO (threadDelay X*1000000 >> exitSuccess)
13:26:49 <sm> ugh!
13:27:10 <iqubic> So is there no clean way to get a finite length?
13:27:22 <EvanR> there is, but i dont know csound
13:27:28 <iqubic> Oh.
13:27:29 <EvanR> so i cant tell you
13:27:36 <iqubic> I'll see if I can find something.
13:27:51 <iqubic> Why are you creating a new thread?
13:28:04 <sm> lol this thing is hours of fun
13:28:13 <sm> dac $ mul (usaw 4) white
13:28:14 <iqubic> What is? csound epression?
13:28:25 <sm> yup
13:28:59 <iqubic> What does that do?
13:29:07 <iqubic> The usaw 4 thing?
13:29:37 <EvanR> the docs man!
13:29:39 <EvanR> the docs!
13:29:53 <iqubic> I'll look at the docs.
13:29:58 <Fusionnex> sm: this tutorial looks like fun
13:29:59 <sm> sorry I meant that for GHCI window. Get it installed, then you'll hear it
13:29:59 <EvanR> https://hackage.haskell.org/package/csound-expression-5.2.0/docs/Csound-Air-Wave.html
13:30:08 <sm> it sure is!
13:31:40 <Fusionnex> building csound !
13:31:45 <sm> lambdabot needs to learn to play csound snippets
13:32:17 <iqubic> But that wouldn't work.
13:33:49 <sm> why wouldn't it ? simple matter of programming
13:34:32 <Boomerang> Wouldn't you need compatible IRC clients to play the sounds?
13:34:39 <iqubic> You would.
13:34:46 <iqubic> That was my point.
13:35:24 <EvanR> what in the world
13:35:36 <iqubic> What???
13:35:42 * sm imagines IRC with per-channel ambient sounds
13:35:50 <EvanR> lol
13:36:06 <EvanR> yes and they are all playing at once as you idle in 30 channels
13:36:22 <Boomerang> What might be doable is for lambdabot to generate a sound file, post it on clyp.it and the send the link here
13:43:22 <Fusionnex> csound-expression and csound installed, time to play
13:47:01 <sm> https://github.com/spell-music/csound-expression/blob/master/tutorial/chapters/appendix/CsoundInstro.markdown#example-a-concert-a-with-scores seems about what's required to play a note
13:48:36 <Fusionnex> sm: omg that gui popup
13:48:42 <Fusionnex> sm: scared the shit outa me
13:49:36 <sm> GUIs! scary!
13:49:57 <Boomerang> Fusionnex: you can play with your keyboard too :D
13:50:55 <Fusionnex> Boomerang: wut
13:51:52 <Boomerang> As in, instead of clicking on the keys in the GUI you can play on the keys of your keyboard. But maybe you're not talking about the same csound GUI?
13:51:54 <Fusionnex> oh god this is amazing
13:52:16 <Fusionnex> im following this tutorial that was posted by sm https://github.com/spell-music/csound-expression/blob/master/tutorial/chapters/SynthTutorial.md
13:52:30 <EvanR> sm: hahaha
13:52:54 <EvanR> csound is the shit
13:53:42 <Fusionnex> if only there wasn't so much distortion :(
13:54:25 <Fusionnex> fml
13:54:26 <EvanR> hmm you might need to adjust some settings
13:54:28 <Fusionnex> make it stop
13:54:31 <Fusionnex> dac $ mul (usqr 4) white
13:56:10 <EvanR> now that we have ultimate synthesis of audio squared away, any ideas for programmatically generating vector graphics from haskell?
13:56:18 <Fusionnex> i get a bit of hissing and poping but i wonder if it is just my sound card misbehaving
13:56:21 <EvanR> diagrams? cairo?
13:56:31 <Fusionnex> u want to replace adobe illustrator w/ haskell?
13:56:40 <bennofs> EvanR: diagrams is pretty cool
13:56:48 <EvanR> hmm
13:58:07 <sm> lots of options there.. graphics seems easier than sound
13:58:42 <sm> Fusionnex: what kind of machine is that ?
13:59:10 <Fusionnex> custom built
13:59:47 <Fusionnex> sm: it has a soundblaster x-fi card in it, but it gives me some issues sometimes
14:00:15 <Fusionnex> ocassionally i straight have to kill pulseaudio for anything to work
14:01:01 <iqubic> Why???
14:01:19 <Fusionnex> iqubic: ?
14:01:41 <iqubic> Why do you have to kill pulse to get the sound to work.
14:01:42 <iqubic> ??
14:02:20 <Fusionnex> honestly not sure. i am using arch linux with the vlc backend, after updating at some point my sound get's all distored, but a simple restart of pulseaudio fixes it
14:03:20 <Fusionnex> iqubic: it used to happen every boot, now it only happens occasionally. somebody is playing with something, im just assuming updates later will fix it
14:07:22 <iqubic> So I'm having some issues with CSound-Expression.
14:08:25 <lpaste> iqubic pasted “CSound-Expression errors” at http://lpaste.net/354464
14:08:36 <iqubic> Anyone know what's going on there?
14:09:30 <Fusionnex> not sure
14:09:32 <sm> not me.. which OS ?
14:09:41 <Fusionnex> mine worked fine 
14:10:11 <iqubic> I'm using Gentoo Linux
14:11:06 <sm> maybe there's some more csound packages to install
14:11:22 <maerwald> nah, there's only one
14:11:34 <Fusionnex> i know i had to install gmm as a dependency 
14:11:45 <maerwald> could rather be misconfiguration of USE flags, who knows
14:11:51 <Fusionnex> :-/
14:12:08 <Fusionnex> gentoo is so very hardcore 
14:12:09 <sm> http://comments.gmane.org/gmane.comp.audio.csound.user/30349
14:12:18 <maerwald> gentoo often allows broken configuration
14:12:21 <Fusionnex> i don't want to take that leap just yet
14:12:29 <maerwald> Fusionnex: it really isn't
14:12:30 <iqubic> Gentoo's package manager pulls in all the depedencies when needed.
14:12:41 <iqubic> Fusionnex: What OS do you use?
14:12:44 <maerwald> iqubic: no, that depends on the correctness of ebuild definitions
14:12:50 <Fusionnex> arch currently
14:12:54 <iqubic> Ah.
14:12:55 <maerwald> which are more often incorrect than correct
14:13:09 <iqubic> so maerwald what should I do?
14:13:23 <Fusionnex> iqubic: i liked not having to compile everything, but i like rolling release
14:13:31 <maerwald> iqubic: I'd just enable all USE flags for the package and try again
14:14:14 <iqubic> maerwald: I'll do that.
14:14:18 <sm> yes ignore my link, install csound in such a way that it includes "virtual"
14:14:37 <iqubic> I will do that.
14:15:50 <maerwald> virtual keyboard?
14:16:22 <maerwald> that would be the "keyboard" USE flag https://github.com/gentoo/gentoo/blob/master/media-sound/csound/csound-9999.ebuild#L143
14:16:33 <maerwald> although I don't know how this is still haskell related
14:16:37 <iqubic> Why do I need the virtual keyboard?
14:16:45 <geekosaur> I think it's a midi emulation over a soundcard
14:17:06 <iqubic> Ah. I see.
14:18:49 <sm> this is not going to work for shipping christmas carols to my mom is it
14:19:18 * maerwald sees a mom joke incoming from a mile away
14:20:08 <iqubic> Nope.
14:20:11 <sm> only because, my mom isn't going to be getting the csound flags right. No implication about other moms intended.
14:20:17 <maerwald> xD
14:20:28 <iqubic> Can't you send here an executable?
14:20:38 <iqubic> *her
14:20:39 <sm> iqubic: maybe! that is true
14:20:55 <iqubic> Because csound should work on all machines.
14:21:16 <Fusionnex> iqubic: even embedded ones
14:21:19 <maerwald> package it in a docker container, which runs nix, which runs stack which runs cabal, which runs...err... haskell
14:22:30 <sm> yeah. It's going to be a lot of work
14:23:13 <iqubic> Wait, so making a Haskell executable is hard work?
14:23:40 <iqubic> I mean so I have something that runs on Windows.
14:23:47 <monochrom> There was a time people sent Windows exes to each other by email. And the exes were merely Christmas cards.
14:24:12 <sm> not in general, iqubic
14:25:00 <maerwald> haskell is not cross-platform by default =)
14:25:10 <monochrom> If your program is just "hello world" it's pretty easy. In fact no deployment issue for the receiver either. No extra DLLs to ship, Haskell code is statically linked.
14:25:15 <sm> though, is that windows executable going to have csound libs embedded ?
14:25:26 <iqubic> Could I do that?
14:25:32 <maerwald> you'll have to go for java bro
14:25:33 <iqubic> Or would that be a pain in the butt.
14:25:40 <iqubic> Why is Java better?
14:25:50 <monochrom> But yeah if you will involve csound then csound is the dominator of how hard it gets.
14:26:02 <sm> if you're shipping to windows users and want it to just work, using any C libraries is basically a no no
14:26:19 <iqubic> How does one package CSound into a .exe?
14:26:26 <iqubic> Is there a way to do that?
14:26:40 <maerwald> docker container :P
14:26:57 <Fusionnex> docker ie. lets just ship linux with everything
14:27:02 <maerwald> everything else probably involves more pain
14:27:11 <monochrom> Java is not going to make the csound story any better.
14:27:28 <sm> an embedded web app that plays sounds is probably easier
14:27:50 <EvanR> classic zip files with exe and dlls in it
14:27:54 <maerwald> yes, let's go full web. Start learning yesod.
14:27:58 <maerwald> should be piece of cake
14:28:15 <sm> hmm.. docker, nix.. yesod..
14:28:23 <maerwald> only the simple stuff...
14:28:26 <EvanR> sm: unfortunately, theres no audio API like the ones weve been discussing, you cant use DSP to generate sound
14:28:33 <hpc> the container needs a web browser too
14:28:33 <EvanR> you can only play samples
14:28:43 <hpc> or several, so you can pick your favorite
14:28:43 <EvanR> or control individual oscillators
14:28:48 <hpc> :D
14:29:04 <sm> EvanR: do you mean, in web land, too ? 
14:29:06 <iqubic> Is yesod simple? or not?
14:29:11 <EvanR> in browsers
14:29:17 <maerwald> iqubic: no
14:29:19 <sm> arghhhh
14:29:31 <iqubic> sm, what is so agrivating?
14:29:41 <maerwald> we've just derailed somehow
14:29:51 <iqubic> From what?
14:29:56 <maerwald> I don't remember
14:29:57 <iqubic> to where.
14:30:02 <sm> iqubic: your stupid problem :)
14:30:21 <iqubic> sm, I have decided that my issue is as solved as it can be for now.
14:30:27 <EvanR> btw my program has been playing a tone since yesterday
14:30:30 <sm> just kidding, it's a great problem. How to play musical notes in haskell, simply
14:30:39 <EvanR> x seconds at a time
14:30:48 <EvanR> but its not in haskell
14:31:11 <iqubic> EvanR: What program are you refering to?
14:31:23 <EvanR> my program right here, ive been playing with tones for a couple days
14:31:45 <reactormonk[m]> I want to keep an updated map of the current network topology via pings - how would you achieve that with haskell? I considered nmap and parsing output, other ideas?
14:33:25 <monochrom> There is Haskore for music, isn't there?
14:33:48 <iqubic> I think so. But that's not really what I want.
14:37:21 <sm> iqubic: not to keep beating on it, I'm just interested - I think the most pragmatic solution will involve either SFML or SDL
14:37:59 <EvanR> port audio
14:37:59 <sm> SFML requires a fix in the haskell lib. SDL requires that you include or generate some tone samples
14:38:43 <iqubic> I'm fine with what I have so far.
14:39:00 <sm> great
14:39:11 <sm> I'm planning ahead for my Simon game
14:39:26 <Boomerang> I just found this: http://charlieharvey.org.uk/page/audio_haskell_morse_code Which is exactly what I described with WAVE and aplay. Problably doesn't work on windows though
14:41:14 <sm> nice
14:43:24 <iqubic> Is that better than using CSound-Expression?
14:44:33 <sm> iqubic: your call, depends on your need
14:44:46 <Boomerang> CSound is a lot more flexible but this post gives a much lighter solution (the only real dependency is aplay which is on most linux systems)
14:44:56 <iqubic> I'd like to try CSound.
14:54:40 <iqubic> Goodbye guys. I have enough knowledge to do what I want with Haskell.
14:54:48 <iqubic> I'll be back later.
15:12:45 <joneshf-laptop> How does `System.Info` work?
15:12:53 <joneshf-laptop> Is  it just 100% magic?
15:13:12 <joneshf-laptop> aside from https://hackage.haskell.org/package/base-4.9.1.0/docs/src/System.Info.html#compilerName
15:13:49 <joneshf-laptop> oh, maybe this: #include "ghcplatform.h"
15:14:05 <monochrom> Right, 100% compile-time hardcoding.
15:14:47 <joneshf-laptop> wait, compile-time?
15:14:54 <monochrom> Yes!
15:15:12 <monochrom> Also, I mean GHC's own compile time, not your program's compile time.
15:15:25 <joneshf-laptop> I'm lost :)
15:15:48 <joneshf-laptop> If I put `System.Info.os` in a library, will the value be accurate for where the library is used?
15:16:04 <joneshf-laptop> Like if i develop on linux, will it say `"linux"` all the time?
15:16:08 <monochrom> Actually yes.
15:16:38 <monochrom> The exe you produce won't work on Windows, so the value is always right. Vacuously.
15:16:47 <monochrom> Or tautologically, I don't know which.
15:17:04 <joneshf-laptop> for the exe, sure
15:17:08 <monochrom> Similarly, the binary of your library
15:17:08 <joneshf-laptop> what about for a library?
15:17:53 <monochrom> If you wrote a library, and build its binary on linux, it still won't work on Windows, so no Windows user will observe a contradiction.
15:18:07 <joneshf-laptop> Correct
15:18:25 <joneshf-laptop> But if I develop a library on linux, and upload to hackage, what happens?
15:18:34 <joneshf-laptop> Will a windows user see "linux"?
15:18:38 <Tuplanolla> People compile it themselves.
15:18:45 <monochrom> A Windows user will have to take your source and compile it (or have someone else do the same). And then they will see the correct value "windows" because they are using a Windowized GHC.
15:18:54 <joneshf-laptop> Dope!
15:18:56 <joneshf-laptop> Thanks!
15:19:01 <monochrom> You can only upload source, you know that?
15:19:30 <monochrom> Or rather, yeah, the receivers will only honour the source code.
15:20:21 <joneshf-laptop> Yeah, but I don't know how magic works :)
15:21:06 <monochrom> It is no magic. (Unless the "magic number" kind where you just hardcode the answer.)
15:21:19 <Tuplanolla> It's called "magic" simply because "disgusting trickery" was too long.
15:21:42 <monochrom> It is just elimination of any falsfying experiment.
15:23:24 <joneshf-laptop> monochrom, Tuplanolla  in anycase, thanks very much for the explanation!
15:25:01 <monochrom> In fact this scheme is already leaking a little bit of inconsistency on 64-bit Windows.
15:25:20 <monochrom> On 64-bit Windows you have the choice of 32-bit GHC and 64-bit GHC.
15:26:02 <monochrom> If you use 32-bit GHC to build an exe, then its arch will say "I see 32-bit" even though you are on 64-bit Windows.
15:27:29 <monochrom> IIRC the exact strings are "i386" for 32-bit and "x86-64" for 64-bit.
15:28:35 <monochrom> Probably magic in the sense of David Copperfield.
15:59:46 <martin3> hi. what is the prefered way of installing ghc under ubuntu? anything other than apt install ghc?
16:00:45 <Koterpillar> martin3: that's good enough. You might also want to look at Stack (haskellstack.org).
16:01:37 <martin3> is that prefered over cabal sandboxes these days?
16:03:06 <Koterpillar> over sandboxes, I'd say yes. There's cabal new-build which is also better than sandboxes, whether stack is better than that or not is debatable.
16:03:18 <Koterpillar> Stack can install and manage GHC for you though.
16:04:19 <martin3> manage it how?
16:06:07 <Koterpillar> in short, stack.yaml defines the precise version you'll get (7.10.3, 8.0.2, etc.), so you can be sure what you build with is what the author had
16:06:56 <martin3> interesting
16:07:12 <martin3> can it handle multiple ghc versions?
16:07:17 <boxscape> > (\4 | True -> 2) 4 -- can you not use guards in lambdas?
16:07:18 <Koterpillar> yes
16:07:19 <lambdabot>  <hint>:1:5: error: parse error on input ‘|’
16:07:25 <martin3> nice
16:07:40 <Koterpillar> boxscape: do you want LambdaCase?
16:07:47 <centril> <3 LambdaCase
16:07:58 <boxscape> Koterpillar: no.. I'm just testing out random syntax things that come to my head :)
16:08:07 <centril> I'm having some trouble writing a function:
16:08:15 <centril> :: Traversal' s a -> [i] -> IndexedTraversal' i s a
16:08:56 <centril> :t \t is -> partsOf t . to (zip is) . traverse . itraversed
16:08:58 <lambdabot> (Applicative f, Indexable i p, Contravariant f) => Traversing (->) f s t a a -> [i] -> p a (f a) -> s -> f t
16:09:03 <boxscape> > (\case 4 | True -> 2) 4 -- would be the same, I suppose, and admittedly, it's just one word longer
16:09:05 <lambdabot>  2
16:09:24 <centril> :t (\t is -> partsOf t . to (zip is) . traverse . itraversed) :: Traversal' s a -> [i] -> IndexedFold i s a
16:09:26 <lambdabot> (Applicative f, Contravariant f, Indexable i p) => Traversal' s a -> [i] -> p a (f a) -> s -> f s
16:10:01 <centril> I need to get rid of the constraint  Contravariant f to make it an IndexedTraversal'
16:10:25 <centril> I can do a slower version atm:
16:10:42 <centril> :t (\t ds -> reindexed (ds !!) $ indexing t) :: Traversal' s a -> [i] -> IndexedTraversal' i s a
16:10:44 <lambdabot> (Applicative f, Indexable i p) => Traversal' s a -> [i] -> p a (f a) -> s -> f s
16:11:09 <centril> but that one has a quadratic complexity instead
16:11:37 <centril> anyone got any ideas ?
16:14:30 <martin3> Koterpillar so if I want to try sandboxes I guess I shouldn't install ghc manually, but let sandbox install it for me?
16:14:37 <martin3> s/sandboxes/stack
16:15:00 <centril> martin3: just use stack, people should move away from cabal
16:15:09 <Koterpillar> martin3: Stack will not interfere with your system GHC
16:15:32 <Koterpillar> martin3: you _can_ tell it you have one, and it will reuse it if it's the right version
16:15:36 <centril> and if system GHC == stack project GHC, then the system GHC will be used
16:15:41 <martin3> ah
16:16:02 <martin3> I'll definately give stack a go. sounds like it came a long way 
16:16:28 <centril> Koterpillar: any ideas about my issue ? im kinda stuck :/
16:18:14 <Koterpillar> centril: no, sorry
16:18:22 <centril> :/
16:20:39 <boxscape> > (\case x | x <- x -> x) x -- I like this
16:20:41 <lambdabot>  x
16:25:33 <Gurkenglas_> centril, I assume that the obvious n*log n version from replacing [i] with a logarithmic-access data structure isn't enough?
16:25:57 <lpaste> glguy pasted “adding indexes for centril” at http://lpaste.net/354467
16:27:37 <Gurkenglas_> glguy, whatcha think of "iso state evalState"?
16:27:52 <centril> Gurkenglas_: so what I have is a rose tree as the source of indices (decorations), corresponding 1:1 to an AST
16:28:20 <centril> and then I want to do an indexed transformMOnOf
16:28:50 <glguy> Gurkenglas_: I think it's an invalid iso
16:30:54 <glguy> but I get that in this case it saves the outside fst$
16:31:09 <boxscape> lambdabot doesn't have MultiWayIf :(
16:31:47 <monochrom> @query lambdabot
16:31:47 <lambdabot> Unknown command, try @list
16:31:55 <monochrom> oops hehe
16:34:56 <centril> glguy: oh man, thanks so much <3
16:36:58 <centril> glguy: time to break it into pieces until i understand how it works ^^
16:41:58 <michalrus> Hey, how can I do execv(3) syscall as in <unistd.h>? I.e. substitute the current Haskell process image with another one. I can’t find that in System.Process. :o
16:42:48 <centril> michalrus: how does that play with GC ?
16:43:46 <michalrus> Hmmm, I don’t know if that (and anything really) matters at all with exec(). (:
16:44:39 <centril> right, each process has its own GC heap, so it shouldnt be a problem
16:45:13 <geekosaur> michalrus, System.Posix.Process.execProcess
16:45:26 <michalrus> Wheee! Thank you, geekosaur!
16:45:34 <centril> haha, 1 sec too late
16:45:59 <centril> michalrus: obviously, it won't work on Windows, which is why you didnt find it in System.Process
16:46:06 <geekosaur> sorry, executeFile
16:46:09 <geekosaur> pheh
16:46:20 <geekosaur> and yes. System.Process is the portable stuff only. so no form or exec
16:46:22 <geekosaur> *fork
16:46:31 <centril> which is a bit sad
16:46:37 <centril> or more like: a lot sad
16:46:48 <michalrus> Ahh. Hmm, it’s a NixOS util, so whatevs.
16:46:49 <geekosaur> (fork() is problematic, btw, but not with gc)
16:47:05 <centril> geekosaur: do tell ?
16:47:08 <michalrus> +1!
16:47:26 <geekosaur> the docuimented one is "forkProcess comes with a giant warning: since any other running threads are not copied into the child process, it's easy to go wrong: e.g. by accessing some shared resource that was held by another thread in the parent."
16:48:02 <geekosaur> there's also some issues with the I/O manager becoming confused because of mutexes which might not be held any more, due to those other threads going away
16:48:10 <geekosaur> iirc
16:48:23 <centril> geekosaur: iirc haskell has a shared GC heap, so problems...
16:48:27 <geekosaur> (every Handle has a mutex, for example)
16:48:33 <centril> erlang has a GC heap per thread, so no problems
16:48:53 <EvanR> yeah erlang sends copies of data through the pipes
16:48:57 <EvanR> simplifies a lot
16:49:08 <Sornaensis> haskell should absorb erlang semantics
16:49:18 <centril> at least this is what we were told @ the Parallel Functional Programming course at Chalmers
16:49:22 <EvanR> but haskell is concerned with performance
16:49:27 <geekosaur> afaik it just reaps the no-longer-extant thread data including heap allocations on the next gc.
16:49:37 <centril> EvanR: what is "performance"? latency, or throughput ?
16:50:00 <EvanR> communication overhead between threads is very low in ghc
16:50:08 <geekosaur> forkProcess does know that the other threads went away, and frees the thread data structures appropriately
16:50:10 <centril> erlang is latency centric
16:50:27 <EvanR> low latency, high throughput
16:50:32 <geekosaur> but user code has to know that as well
16:50:39 <EvanR> so van full of mag tapes strapped to a spaceshuttle
16:51:19 <centril> EvanR: tho, i did find it really hard to get good speedups in haskell for an embarasingly parallel function such as  map
16:51:30 <EvanR> map is not embarassingly parallel
16:51:49 <EvanR> specifically because its processes linked lists
16:52:07 <EvanR> lists are a middle finger to parallelism
16:52:17 <centril> EvanR: oh, so the cons:ing is the culprit ?
16:52:28 <centril> so an Array or Vector instead would give me good speedups ?
16:52:35 <EvanR> if you use a parallel map operation
16:53:09 <centril> I should try this sometime later
16:53:12 <geekosaur> given ghc's tendency toward glaswegian, shouldn't that be two-fingers? :p
16:53:27 <centril> geekosaur: glaswegian? is that a word?
16:53:48 <geekosaur> yep
16:53:57 <geekosaur> blame scots gaelic
16:54:25 <centril> geekosaur: oh well, Chalmers is overtaking everything FP anyways, so :P
16:55:08 <centril> I guess we only need to steal Simon Peyton Jones now and we're complete - maybe Simon Marlow too
17:16:44 <joneshf-laptop> Is there a way in wai to get the request body without consuming it?
17:25:45 <EvanR> joneshf-laptop: im not sure that would make sense
17:26:24 <joneshf-laptop> Why's that?
17:28:16 <EvanR> you want to read from a socket without disturbing the socket
17:28:32 <EvanR> they just dont work like that
17:30:09 <joneshf-laptop> So it's something specific to the implementation of wai that makes it impossible?
17:30:31 <geekosaur> ?
17:30:45 <EvanR> the request you get is not complete, the body maybe streaming, infinite
17:30:51 <geekosaur> what do you believe is going on that you can do this?
17:31:25 <EvanR> you can ask for the next chunk, and that dequeues it logically from the sockets secret buffer
17:31:32 <EvanR> now you can do what you want with it
17:32:38 <joneshf-laptop> geekosaur, I hadn't looked into the internals of wai. I didn't know that the `IO ByteString` was a direct socket, rather than it "just" being a `ByteString` "in" `IO`.
17:33:44 <joneshf-laptop> EvanR, thanks, tht makes sense.
17:33:50 <joneshf-laptop> I mean, the explanation makes sense.
17:34:46 <joneshf-laptop> That's interesting though
17:36:15 <boxscape> @pl \(x,y,z) -> x y z -- what is that supposed to mean
17:36:15 <lambdabot> (line 1, column 7):
17:36:16 <lambdabot> unexpected "z"
17:36:16 <lambdabot> ambiguous use of a non associative operator
17:36:30 <joneshf-laptop> I'd figure there'd be something holding on to the `ByteString` once the request is "complete"
17:36:42 <boxscape> I suppose lambdabot doesn't allow pattern matching on higher tuples than paris
17:36:44 <boxscape> pairs*
17:37:46 <geekosaur> it's pointfree that can't do it
17:37:57 <geekosaur> since there are no standard combinators for it, yeh
17:37:59 <joneshf-laptop> Does that mean that somebody's middleware can just hijack the request body and your application might never get data?
17:38:19 <boxscape> geekosaur: er, right, that's what I meant
17:38:39 <geekosaur> joneshf-laptop, I would really hope nothing is holding onto it if it's a PUT with a 5GB body
17:39:55 <EvanR> joneshf-laptop: you are holding onto it
17:40:06 <joneshf-laptop> geekosaur, I feel like I'm thinking about this all wrong. How do you do things like send the request body to multiple programs?
17:40:26 <EvanR> once you have the body (assuming its not infinite) you can do that
17:40:41 <joneshf-laptop> who?
17:40:45 <joneshf-laptop> a middleware?
17:40:55 <joneshf-laptop> or the application?
17:40:58 <EvanR> whatever is handling the request
17:41:03 <geekosaur> either one
17:41:10 <joneshf-laptop> how's that?
17:41:35 <geekosaur> a middleware could capture a PUT to file and pass that on, or your application can do so or do something else with it
17:42:45 <joneshf-laptop> But like, if one middleware in the chain decides to consume the body and not make it available, doesn't the whole thing fall down?
17:42:46 <geekosaur> but, for wai, your application got invoked based on the path in the request. it's your application that decides what to do; nothing else will be invoked
17:43:59 <geekosaur> yes, but the middleware should be under your control as well
17:44:18 <geekosaur> otherwise I think you're doing something very wrong just from a security standpoint
17:44:35 <geekosaur> "Middleware is a component that sits between the server and application. It can do such tasks as GZIP encoding or response caching."
17:45:40 <geekosaur> so, say, a Middleware handles gunzipping a gzip stream. if something goes wrong you get no body --- but you weren't going to get anything useful anyway in that case
17:46:53 <joneshf-laptop> Hmm.
17:46:57 <joneshf-laptop> I'll buy that.
17:47:03 <joneshf-laptop> So, here's my deal.
17:47:30 <joneshf-laptop> I want to catch 500s and log them
17:47:43 <joneshf-laptop> Ideally I'd like to log the request body as well
17:48:03 <joneshf-laptop> Is there a pattern for doing that without breaking things?
17:48:18 <joneshf-laptop> like, tee-ing off the socket or something?
17:48:46 <geekosaur> sounds to me like a Middleware is exactly what you want here, then: one that captures the request, possibly throwing if it's not a fixed size (and it can log itself in that case), and what it passes on is a file containing the data
17:49:07 <geekosaur> you cant tee off a socket, you're getting the data as it is passed on from the network
17:49:23 <geekosaur> once it's been read, it's gone
17:49:44 <Koterpillar> you can save it to a file and pass a handle to that file as the new body?
17:49:53 <Koterpillar> (assuming WAI allows that, which I don't know)
17:50:06 <geekosaur> you'd have to pass the filename, I think
17:50:09 <joneshf-laptop> Am i too low level here?
17:50:16 <geekosaur> but otherwise, yes, that's what I am thinking
17:50:22 <geekosaur> yes, wai is very low level for this stuff
17:50:49 <joneshf-laptop> I'm happy to go higher, if you have a suggestion.
17:50:50 <geekosaur> a Middleware to save to file and pass that on is one way to make it higher level
17:51:43 <joneshf-laptop> Is there a conduit thing that might be of use?
17:52:30 <geekosaur> http://hackage.haskell.org/package/wai-conduit ?
17:52:45 <geekosaur> which gives you a pipeline in the application which might or might not help you, yes
18:05:35 <joneshf-laptop> hmm
18:05:46 <joneshf-laptop> Thanks. I'll play with it a bit.
18:12:04 <EvanR> any ideas for ways to visualize an arbitrary Double value in a small amount of screen area
18:24:38 <sophiag> can anyone help me debug the eval function in the following paste? it takes two records, each with Maybe Strings and one with list and the other with lambdas representing boolean conditions. ideally it should return every permutation of the lists and filter based on lambdas when the strings match (including Nothing). i'm trying to go back and build it up incrementally, i.e. first just returning unfiltered permutations, but since i
18:24:38 <sophiag> needed such complicated ADTs i keep getting the type signature wrong even for that: http://lpaste.net/354469
18:29:49 <joneshf-laptop> sophiag, what is the error?
18:31:03 <sophiag> joneshf-laptop: i added them at the bottom: http://lpaste.net/354469
18:32:28 <sophiag> on second thought it should maybe be eval :: [Amb] -> [[MultiList]] ...but that also returns a type error
18:46:19 <joneshf-laptop> geekosaur, EvanR So, I was greatly overthinking it, and I'm not sure why. Naively, can do `dup r = (\x -> (r { requestBody = pure x }, r { requestBody = pure x })) <$> requestBody r`
18:46:29 <joneshf-laptop> But that probably leaks memory or something.
18:48:36 <EvanR> that probably doesnt do what you think
18:48:53 <EvanR> it doesnt duplicate a request
18:49:15 <joneshf-laptop> what does it do?
18:49:28 <Koterpillar> rather, it doesn't do what you need, which is to log the body
18:49:45 <EvanR> it creates a request with a copy of the first chunk recieved
18:50:02 <EvanR> received
18:50:12 <joneshf-laptop> Ah!
18:50:33 <EvanR> and the original request will be affected
18:51:16 <joneshf-laptop> Koterpillar, right, I've got the logging taken care of, but noticed that the application was consuming the requestand the logger getting nothing. Which sent me down this rabbit hole :)
18:51:33 <joneshf-laptop> I find it a little hard to swallow that this doesn't exist somewhere already.
18:51:56 <joneshf-laptop> It make sme thing that I'm doing something REALLY wrong.
18:52:08 <EvanR> how are you logging a 500 when 500 is a response, not a request
18:52:33 <joneshf-laptop> in the handler
18:53:53 <joneshf-laptop> I was giving the initial request to the app, and constructing a new handler where I check what the response is, and log accordingly.
18:54:09 <joneshf-laptop> then calling the initial handler with the response
18:54:45 <joneshf-laptop> wow, my English is pretty bad right now.
18:54:54 <joneshf-laptop> sorry :|
18:57:31 <geekosaur> you need to rethink this, I think. the whole notion of duplicating a request is dubious when a request is indefinite length
18:58:02 <geekosaur> and invoking requestBody just gets you whatever the network has available right now from it --- the sender may well still be sending it at that time!
18:58:06 <EvanR> you could "tee" it, except sockets dont have that
18:58:28 <geekosaur> that is, you can't get the next chunk because it hasn't been sent yet
18:59:05 <geekosaur> this stuff runs *live*, it is not a completed request that you receive but the ongoing and quite possibly incomplete request, which can be dispatched via its header
19:00:05 <joneshf-laptop> Okay.
19:00:12 <joneshf-laptop> What might be a better way?
19:02:38 <Sornaensis> > [toDyn 4.1, toDyn "blorps"]
19:02:40 <lambdabot>  [<<Double>>,<<[Char]>>]
19:05:36 <geekosaur> joneshf-laptop, uh... I think you have to figure that out yourself, including what to do if the connection aborts after you have read a chunk (this is not necessarily the same as getting an empty chunk back; it may be sent as an exception)
19:06:23 <EvanR> getting an empty chunk = body complete
19:06:50 <EvanR> hopefully its not like getContents and you also get empty in case of error
19:07:27 <joneshf-laptop> this is thoroughly disappointing.
19:08:28 <geekosaur> so you are imagining that magic happens somewhere?
19:09:12 <geekosaur> do you understand that, fundamentally, this is all happening *online* and you do not at any point have "a single completely read request", and no wrapper can help you with this because the concept itself does not exist?
19:09:34 <geekosaur> I kinda feel like trying to teach serial terminals to someone who's only worked with block mode
19:09:51 <joneshf-laptop> Yeah, I get th eunderlying model.
19:10:55 <joneshf-laptop> I'm just disappointed that there's not an off-the-shelf way to tee the request.
19:11:52 <EvanR> so log the body to a file, later if you response is 500, remember where you put that file and use it as part of the log
19:12:04 <EvanR> otherwise delete it
19:12:26 <EvanR> i guess the application also must now use that file
19:12:31 <geekosaur> I'm not even sure how teeing the request would work. you capture to file, or you have to use something like a Chan/TChan
19:13:16 <geekosaur> you can't do it with a socket because a socket is a firehose fed by a remote system, it doesn't "do" teeing, it just sprays data
19:13:21 <joneshf-laptop> writing to a file isn't an option
19:13:46 <geekosaur> so you need to refigure your model somewhere because what you want to do is not streaming but streaming is what HTTP is
19:13:48 <joneshf-laptop> Right.
19:14:06 <joneshf-laptop> Im fine with it being streaming.
19:14:25 <Koterpillar> why can't you drain the socket first?
19:14:25 <joneshf-laptop> I don't have to have it be chunked
19:14:47 <joneshf-laptop> like with `strictRequestBody`?
19:15:05 <EvanR> seems like a mistake
19:15:18 <monochrom> strict I/O is a DDoS vulnerability.
19:15:31 <joneshf-laptop> sure.
19:16:29 <joneshf-laptop> At the end of the day, I just want a function `MonadIO f => Request -> f (Request, Request)`.
19:17:20 <joneshf-laptop> But I think since this is way too deep of a hole. I'm going to be satisfied with not logging the request.
19:17:24 <joneshf-laptop> for now
19:18:20 <EvanR> Handle -> IO (Handle, Handle) is possible, somehow
19:18:35 <monochrom> Actually, why is it not Request -> (Request, Request), in fact forall a. a -> (a, a) ?
19:19:20 <EvanR> it can spawn a worker and two fifos dedicated to reading and dumping the first socket
19:19:30 <EvanR> which are opened as two new handles
19:19:46 <EvanR> kind of over the top for what youre trying to do
19:19:57 <geekosaur> EvanR, only if a different process (or maybe thread) is reading the original and writing every chunk to the other handles
19:20:04 <EvanR> right
19:20:13 <geekosaur> which can have its own problems, especially if the processors are supposed to be synchronized somehow
19:20:15 <EvanR> dont mess with the original handle after that point, "or else"
19:20:53 <EvanR> er, not a file system fifo, but two anonymous pipes
19:24:19 <geekosaur> oh, also your duplicator will block if nothing is reading one of the Handles
19:24:55 <EvanR> that would be some unfortunately interaction
19:25:02 <EvanR> unfortunate
19:25:24 <Koterpillar> can you log as the request body is consumed?
19:25:45 <Koterpillar> if it's crashed on first 3 bytes, fine, those should be enough to reproduce the error :)
19:27:49 <joneshf-laptop> No logging should happen until the response is sent.
19:28:05 <joneshf-laptop> So if the request becomes bunk, aren't there bigger problems?
19:31:09 <geekosaur> you have to decide that, including what to do if you're getting a slowloris attack that sends 3 bytes per minute forever
19:31:25 <geekosaur> again this is a stream, not a completed request
19:32:00 <geekosaur> you want something that will make ti look like a complete request. you can only do this by reading the entire request (and possibly aborting if you decide it's too long) yourself.
19:33:04 <EvanR> have to say i had the idea that "middleware" had some nice composability properties, this doesnt sound like it does
19:33:13 <joneshf-laptop> right?
19:33:24 <EvanR> it sounds like any "ware" inserted here will mess everything up
19:33:25 <geekosaur> personally I question the whole idea, logging a possibly infinite request doesn't sound very viable
19:33:29 <EvanR> unless you redesign the whole thing
19:34:11 <geekosaur> it really does sound like you don't fundamentally get "stream", and are looking for something that will turn it into not-stream for you and magically deal with sytream behaviors like huge, indefinite, or infinite data
19:34:51 <geekosaur> ("indefinite" being that slowloris thing where not much data but the sender is malicious and keeping the request open forever)
19:35:18 <joneshf-laptop> I don't know how to explain that I do get "stream".
19:35:43 <geekosaur> you could start by asking for a behavior that is not fundamentally contradictory to streams
19:35:57 <joneshf-laptop> like teeing?
19:36:02 <geekosaur> ,,,
19:36:09 <geekosaur> duplicaitng a stream is duplicating infinity
19:36:29 <EvanR> nothing really illogical about that
19:36:45 <EvanR> storing the whole thing on a disk is
19:36:50 <joneshf-laptop> ^
19:36:51 <geekosaur> duplicaitng a stream *is not a fundamental stream operation* unless you are separately processing each stream. You cannot do it to hold a "copy", because that means somehting is now committed to infinitely buffering data
19:36:53 <geekosaur> forever
19:37:25 <geekosaur> this is the point where your understanding of stream falls apart
19:37:30 <Koterpillar> geekosaur: for a push-based stream, tee is a possible operation
19:37:41 <joneshf-laptop> geekosaur, Can you explain it then?
19:37:51 <geekosaur> I just did
19:38:02 <geekosaur> if you didn;t get it then I'm not sure what else to say except "good luck"
19:38:08 <joneshf-laptop> K
19:40:04 <geekosaur> I fear that you will come up with an Obviously Correct solution.. and then discover first hand what kind of denial of service attacks are opened by such
19:41:28 <joneshf-laptop> Nope, I'm just not going to deal with logging the body.
19:41:39 <joneshf-laptop> This is way too far off in the weeds for me to care about anymore.
19:42:11 <joneshf-laptop> Specifically for all the stuff you brought up.
20:14:47 <iqubic> So, is there a way to pass in a '-' or '.' as a char to a parameter? Like not as a minus sign or fuction composition, but a char?
20:15:19 <EvanR> > ord '-'
20:15:21 <lambdabot>  45
20:15:31 <iqubic> Cool. Just like Java
20:15:58 <EvanR> :t '-'
20:15:59 <lambdabot> Char
20:16:07 <iqubic> Got it.
20:16:28 <iqubic> I just found a neat library. It has only a few functions, but I still like it.
20:16:43 <iqubic> @hackage MorseCode
20:16:43 <lambdabot> http://hackage.haskell.org/package/MorseCode
20:18:00 <monochrom> Neat.
20:18:50 <iqubic> Yeah, I like that.
20:19:04 <iqubic> The functions all do exactly what they say they will.
20:19:09 <EvanR> should be hooked up to sound
20:19:37 <iqubic> That's my task.
20:19:56 <iqubic> I have to use CSound-Expression to hook it up to sound output.
20:20:11 <iqubic> I'm also going to want a GUI, but that'll be the last thing I do.
20:20:28 <iqubic> How hard is Haskell GUI to make?
20:21:07 <EvanR> theres three-penny-gui
20:21:46 <iqubic> What I need is something that will provide a simple Front-End that I can hook up to my Morse Code back end.
20:22:05 <EvanR> https://hackage.haskell.org/package/threepenny-gui
20:22:16 <EvanR> apparently no - between three and penny
20:22:34 <iqubic> So, why does this thing use the web???
20:23:00 <EvanR> it explains that
20:23:02 <iqubic> And will I be able to play sound from the web with this and CSound-Expression?
20:23:12 <EvanR> no
20:23:19 <EvanR> it will play from your haskell program
20:23:28 <EvanR> the browser is just for the gui
20:23:58 <iqubic> So people will still need to have CSound C library to be installed.
20:24:09 <iqubic> Are there any other GUIs that I can use?
20:24:23 <iqubic> Also, I have homework that needs doing.
20:24:35 <Koterpillar> Gtk, if relevant, is relatively nice with gi-gtk
20:24:54 <iqubic> Is GTK simple to use?
20:25:08 <EvanR> not really
20:25:46 <Koterpillar> not hard, IMO
20:26:44 <Koterpillar> https://github.com/koterpillar/tianbar/blob/master/src/System/Tianbar.hs I think this shows a few things you might want to do
20:28:26 <imalison> I often find myself writing stuff like
20:28:26 <imalison> my3ArgumentFunction <$> getSomeValue <*> (pure True) <*> (pure 10)
20:28:26 <imalison> where
20:28:26 <imalison> my3ArgumentFunction :: String -> Bool -> Int -> String
20:28:26 <imalison> getSomeValue :: IO String
20:28:27 <imalison> But this feels sort of wrong to me because a) applicative is not strictly needed for this (functor is enough) b) It feels like there should be an operator that does what <*> and pure are doing together. I realize that I could do something like
20:28:27 <imalison> (\input -> my3ArgumentFunction input True 10) <$> getSomeValue
20:28:28 <imalison> but I would much prefer something like
20:28:28 <imalison> infixl 4 <$$>
20:28:29 <imalison> (<$$>) :: Functor f => f (a -> b) -> a -> f b
20:28:29 <imalison> functor <$$> value = ($ value) <$> functor
20:28:30 <imalison> my3ArgumentFunction <$> getSomeValue <$$> True <$$> 10
20:28:30 <imalison> As you can see, it is easy enough to write the operator that I want, but I'm wondering if it exists somewhere/has an accepted name, or is perhaps generalized by some concept that I don't know about.
20:28:32 <EvanR> what
20:29:24 <EvanR> liftA3 my3ArgFunc getSomeValue (pure True) (pure 10)
20:29:39 <Koterpillar> imalison: maybe you need to flip your function arguments instead
20:29:54 <Koterpillar> imalison: so that the ones you want constant come first
20:29:56 <imalison> yeah that occured to me as well, but sometimes you just cant do that
20:30:01 <imalison> (its a library function or something)
20:32:03 <EvanR> :t liftA3
20:32:04 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
20:32:12 <Axman6> I sometimes wish we had the syntax a few languages have where you could write fmap (my3ArgFunc _ True 10) getSomeValye
20:32:18 <Axman6> I think Swift has that?
20:33:13 <imalison> EvanR: that's not really what I want though, I mean fmap does just as well here, and is actually a better thing to use because it doesn't require applicative
20:35:05 <glguy> Axman6: I know it's not actually a replacement for what you're talking about, but...
20:35:06 <glguy> (\f -> f ?? True ?? 10) :: (a -> Bool -> Int -> b) -> a -> b
20:36:41 <moet> what's `mkWeakMVar` mean in haskell? does that mean the mvar's reference won't prevent the referent from being GC'd?
20:37:37 <glguy> http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent-MVar.html#v:mkWeakMVar
20:37:44 <glguy> Make a Weak pointer to an MVar, using the second argument as a finalizer to run when MVar is garbage-collected
20:37:57 <moet> yeah, i clicked through to `Weak` and found the explanation http://hackage.haskell.org/package/base-4.9.1.0/docs/System-Mem-Weak.html#t:Weak
20:38:11 <moet> i always ask questions about things i was reading last night instead of re-reviewing docs first
20:39:27 <glguy> The reason you have a special operation for making Weak wrappers of MVars is so that it's the underlying mvar that the weak reference refers to
20:40:04 <glguy> and not the "box" around that weak reference (which is much more likely to not exist due to optimizations, or not be consistently the same box due to optimizations
20:40:13 <moet> ah..
20:40:26 <glguy> data MVar a = GHC.MVar.MVar (GHC.Prim.MVar# GHC.Prim.RealWorld a)
20:40:36 <glguy> So mkWeakMVar grabs onto that inner MVar#
20:44:04 <imalison> glguy: oh wow, ?? is exactly what I wanted
20:44:33 <imalison> seems to be exactly the same as the function that I described above
20:44:35 <imalison> 20:28 <imalison> (<$$>) :: Functor f => f (a -> b) -> a -> f b
20:44:35 <imalison> 20:28 <imalison> functor <$$> value = ($ value) <$> functor
20:54:09 <iqubic> So what's is the best GUI to use in Haskell?
20:54:17 <iqubic> > :t ??
20:54:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:54:26 <iqubic> :t ??
20:54:27 <lambdabot> error: parse error on input ‘??’
20:54:34 <iqubic> :t <$>
20:54:35 <lambdabot> error: parse error on input ‘<$>’
20:54:40 <pacak> :t (<$>)
20:54:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:54:46 <pacak> :t (??)
20:54:47 <lambdabot> Functor f => f (a -> b) -> a -> f b
20:55:28 <Koterpillar> iqubic: OS requirements?
20:55:31 <iqubic> Wait a minut, (??) looks like (>>=) with the parameters in the other order.
20:55:51 <iqubic> Koterpillar: Preferable Linux and Windows.
20:55:57 <glguy> iqubic: Look closer
20:55:57 <pacak> :t (>>=)
20:55:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:56:02 <pacak> Not quite.
20:56:21 <imalison> iqubic: not really
20:56:25 <Koterpillar> iqubic: how complex an UI?
20:56:29 <imalison> because the function is inside the context
20:56:38 <iqubic> Though I am using CSound as a C library, so I might not be able to run my application on Windows.
20:57:25 <iqubic> Koterpillar: Not too complex. Maybe just a single text box, one set of radio buttons, a regular button, and a place to output text.
20:57:43 <iqubic> I might use GTK bindings, if I had a guide for that.
20:57:56 <imalison> glguy: so ?? is a lens thing I see. I'm assuming that since its defined there its not defined anywhere else
20:58:39 <pacak> @src (??)
20:58:40 <lambdabot> Source not found. You speak an infinite deal of nothing.
20:58:48 <pacak> lambdabot:  :-P
20:58:58 <iqubic> @src (<$>)
20:58:58 <lambdabot> f <$> a = fmap f a
20:59:02 <Koterpillar> iqubic: https://github.com/haskell-gi/haskell-gi here's an example
20:59:11 <iqubic> @src fmap
20:59:11 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:59:25 <EvanR> iqubic: it certainly works on windows
20:59:42 <iqubic> CSound, GTK, or both?
20:59:46 <pacak> iqubic: fmap is defined by Functor so different functors have different implementations.
20:59:55 <EvanR> GTK works on windows
21:00:16 <EvanR> i was talking about csound
21:00:16 <Koterpillar> I don't know if gi-gtk does, though
21:00:30 <iqubic> Why might gi-gtk fail on Windows?
21:01:30 <Koterpillar> because you need GI, not just Gtk
21:01:43 <Koterpillar> IDK if that's an issue, never tried Windows
21:01:45 <iqubic> So maybe gtk2hs would be better.
21:02:11 <imalison> As someone who has dealt with it quite a bit I can tell you that gtk2hs kinda sucks
21:02:19 <iqubic> According to the Haskell wiki, it runs on all OSes.
21:02:28 <iqubic> imalison: why do you say that?
21:03:08 <Koterpillar> it's incomplete
21:03:22 <iqubic> Ah. 
21:03:31 <Koterpillar> iqubic: try gi-gtk, if it works, fine, if not, ask again :)
21:04:15 <Koterpillar> iqubic: aha! https://github.com/haskell-gi/haskell-gi/wiki/Using-haskell-gi-in-Windows
21:07:44 <vaibhavsagar> I'm trying to follow this presentation http://halvm-talk.bitballoon.com/#/halvm but I'm getting a linker error when trying to compile the executable with halvm-ghc
21:08:02 <vaibhavsagar> at this step specifically: http://halvm-talk.bitballoon.com/#/building
21:08:16 <vaibhavsagar> has anyone encountered this before?
21:10:44 <iqubic> Is GI-GTK more complete than GTK2HS?
21:11:45 <iqubic> Also, looks like GI-GTK is cross-platform.
21:11:56 <Koterpillar> it is as complete as Gtk, by definition
21:12:33 <iqubic> What does that mean?
21:12:53 <iqubic> https://hackage.haskell.org/package/gi-gtk
21:13:06 <iqubic> That provides no link to the modules in that library.
21:13:42 <iqubic> Why is that
21:13:53 <iqubic> Is that the wrong library page?
21:15:29 <Koterpillar> that means it introspects your version of Gtk at compile time
21:15:34 <Koterpillar> and generates all the functions it finds
21:15:42 <iqubic> Oh, that's wonderful?
21:15:54 <iqubic> Do I need to get the gi library as well?
21:15:59 <Koterpillar> there is a link in README at the bottom
21:16:23 <iqubic> Yeah, but not in the modules section. Why is this formatting weird?
21:16:40 <geekosaur> you were just told why
21:17:03 <iqubic> geekosaur: What does that mean?
21:17:06 <Koterpillar> Hackage probably doesn't have Gtk
21:17:12 <geekosaur> normally documentation would be generated by an automatic test build, but the builder does not have gtk installed
21:17:17 <Koterpillar> and without Gtk, it can't introspect or build anything
21:17:21 <iqubic> Ah. I see
21:17:24 <geekosaur> so the docs were uplkoaded manulally and a link put in the README
21:17:40 <iqubic> Oh. I see now. Thanks.
21:17:57 <iqubic> So, do I need the gi library to use gi-gtk?
21:18:03 <Koterpillar> you need haskell-gi, yes
21:18:21 <iqubic> Is that also on Hackage?
21:18:27 <iqubic> is gi-gtk hard to use?
21:18:36 <iqubic> Or is it simple
21:18:36 <geekosaur> stuff like gi is kinda an extreme case that the builder and doc builder can;t deal with properly, so the result is a  bit hacky
21:19:04 <geekosaur> moreover the uploaded docs may not match what you get when you install it since you are not guaranteed to have the same Gtk installed
21:19:19 <iqubic> how difficult is gi-gtk to use?
21:19:32 <iqubic> It seems rather difficult from what I hear.
21:19:32 <geekosaur> (but, Gtk devs don't believe in stability so there is nothing to be done about that)
21:19:45 <Koterpillar> iqubic: see the README here: https://github.com/haskell-gi/haskell-gi
21:19:57 <iqubic> WHAT THE HECK IS WRONG WITH THE GTK DEVS
21:20:25 <Koterpillar> iqubic: there is a complete example displaying a button and something
21:20:35 <geekosaur> they're the gnome devs now, not the gimp devs who made gtk2 and had a notion of stability
21:20:41 <glguy> gi-gtk is about as easy to use as gtk is, it binds the API directly
21:20:53 <glguy> understanding gtk will make understanding gi-gtk easy
21:21:02 <iqubic> I'll look into gtk then.
21:21:10 <geekosaur> as for what's wrong with gnome 3, ... I gave up trying to figure it out. they just don't care about anyone but themselves, and made that pretty clear when they announced they were abandoning all pretense at API stability
21:21:14 <glguy> and I mean gtk the underlying library
21:21:18 <glguy> not the Haskell one
21:21:53 <iqubic> Koterpillar: that readme doesn't tell me how to install haskell-gi.
21:22:06 <Koterpillar> iqubic: from cabal/stack
21:22:30 <iqubic> I am stupid.
21:23:13 <iqubic> So how do I link up the GTK front-end to my Haskell back-end?
21:23:23 <iqubic> With a special library, or what?
21:24:04 <Koterpillar> you link to gtk
21:24:27 <iqubic> Just like that? I don't need FRP to connect my logic to my GUI?
21:24:33 <Koterpillar> no
21:24:57 <Koterpillar> so, about the same way you link a console front-end (fprintf) to your Haskell back-end: with a "special library" called putStrLn
21:25:28 <iqubic> So how will I know if certain GUI events have happened, and how will I poll the GUI state?
21:26:01 <Koterpillar> iqubic: search for "on button" on that page
21:26:09 <iqubic> Wait a minute, you can bind actions to buttons.
21:26:22 <glguy> I'm got a small gi-gtk app you can look at that does use any extra library, it looks like this http://imgur.com/a/ISOxN
21:26:36 <glguy> https://github.com/glguy/CookieCalculator/blob/master/gui/Main.hs
21:26:42 <iqubic> the function set button can really be anything there, right?
21:27:02 <halogenandtoast> Is there a more clear way to write this? getMove = fromMaybe <$> getMove <*> (parseMove <$> getInput) 
21:27:10 <Koterpillar> iqubic: yes
21:27:23 <halogenandtoast> where getMove :: IO Move 
21:27:25 <iqubic> Right, I just have to get the type right.
21:27:26 <Koterpillar> iqubic: it's all in IO
21:28:59 <iqubic> @src liftA2
21:28:59 <lambdabot> liftA2 f a b = f <$> a <*> b
21:29:37 <iqubic> halogenandtoast: why not try "liftA2 fromMaybe getMove (parseMove <$> getInput)"
21:29:58 <iqubic> Not sure that's any cleaner, but it should still work.
21:30:30 <halogenandtoast> hrm usually if I end up using liftA2 I assume I've done something wrong :p
21:30:40 <halogenandtoast> because it's very hard to read.
21:30:42 <glguy> You don't have to feel like that
21:31:52 <iqubic> What does a .ui file do? Is that part of gtk's inner workings?
21:32:30 <iqubic> What does fromMaybe do?
21:32:32 <glguy> iqubic: You can build a window layout using the Glade tool and then save that
21:32:40 <iqubic> @src fromMaybe
21:32:40 <lambdabot> fromMaybe d Nothing  = d
21:32:40 <lambdabot> fromMaybe _ (Just v) = v
21:33:09 <iqubic> I see converts Maybe a into a, or returns a default value.
21:33:24 <iqubic> > :t getInput
21:33:26 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
21:33:42 <halogenandtoast> getInput is my own func
21:33:53 <glguy> iqubic: The glade tool editing a .ui file http://imgur.com/a/na7WL
21:33:57 <halogenandtoast> getInput :: IO String
21:34:20 <halogenandtoast> parseMove :: String -> Maybe Move
21:34:41 <iqubic> Ah. I see.
21:34:52 <iqubic> hence why you need <$> there.
21:35:47 <iqubic> Why am I getting this error?
21:36:31 <lpaste> iqubic pasted “stack repl error” at http://lpaste.net/8855615865861701632
21:37:01 <iqubic> Only happened after I added "haskell-gi and gi-gtk" to my build depends list.
21:38:44 <iqubic> Anyone know what's going on?
21:41:59 <iqubic> Anyone at all know what's up?
21:42:08 <halogenandtoast> iqubic: I'm not sure, going on a limb here, but maybe try `stack clean`
21:42:27 <Koterpillar> iqubic: do you have Gtk and GI libraries?
21:42:36 <iqubic> I'm not sure.
21:42:55 <imalison> Koterpillar: I saw that you forked taffybar. Why did you decide to do that?
21:43:20 <Koterpillar> imalison: my way is prettier
21:43:27 <iqubic> Koterpillar: what versions of gtk and GI do I need?
21:43:45 <iqubic> My package manager has a thing called dev-haskell/gtk
21:43:46 <Koterpillar> iqubic: I mean the system libraries... what OS are you on?
21:43:55 <iqubic> Gentoo Linux
21:43:58 <Koterpillar> ooooooooo
21:44:19 <iqubic> What's up??
21:44:22 <pacak> Gento is fun :)
21:44:28 <Koterpillar> iqubic: https://github.com/koterpillar/tianbar/blob/master/Dockerfile.base#L19-L20
21:44:30 <iqubic> Everyone has told me that all day.
21:44:40 <Koterpillar> iqubic: try searching for something like those
21:44:43 <iqubic> I have.
21:44:57 <iqubic> I found that I could install gtk+ 
21:45:01 <iqubic> That's a start.
21:45:20 <iqubic> Since this is gentoo, that'll take a bit of time.
21:45:54 <halogenandtoast> So this is a little interesting to me and maybe someone can explain, I have getInput = putStr "> " >> hFlush stdout >> getLine, and if I try to do liftA2 fromMaybe getMove (parseMove <$> getInput) 
21:45:58 <halogenandtoast> then I don't see the "> "
21:46:07 <halogenandtoast> but if I do   mMove <- parseMove <$> getInput
21:46:10 <halogenandtoast>   liftA2 fromMaybe getMove $ pure mMove
21:46:14 <halogenandtoast> then I do
21:46:36 <iqubic> halogenandtoast: Where are you printing the "> " from?
21:46:48 <halogenandtoast> from getInput (see the definition above)
21:46:55 <jle`> halogenandtoast: it might be buffering
21:47:03 <halogenandtoast> jle`: isn't that what hFlush is for?
21:47:14 <jle`> oh, mised that
21:47:31 <iqubic> Wait, I am super confused now.
21:47:49 <iqubic> Why isn't that being printed properly?
21:48:05 <halogenandtoast> I'll post the full source
21:48:23 <iqubic> I don't think that's needed, but sure, go ahead.
21:49:05 <halogenandtoast> https://gist.github.com/halogenandtoast/f6cb02d94c44c54404299243d3cc4e6c
21:49:57 <iqubic> Where are you printing in that code?
21:50:02 <iqubic> I don't see that anywhere?
21:50:08 <halogenandtoast> #23
21:50:26 <iqubic> I see that now.
21:50:43 <halogenandtoast> and subsequently #41 and #43
21:50:54 <halogenandtoast> s/subsequently/additionally/
21:50:57 <jle`> halogenandtoast: does it even do anything if you wrote the liftA2 fromMaybe getMove (...) ?
21:51:19 <halogenandtoast> jle`: define do anything?
21:51:37 <halogenandtoast> I can type stuff, hit enter, nothing happens
21:51:44 <iqubic> I see
21:51:47 <jle`> yeah, it looks like you have an infinite loop
21:51:55 <iqubic> Where do you call getInput from?
21:52:05 <jle`> you're defining getMove as lifA2 _ getMove blah
21:52:08 <iqubic> Wait, I see that.
21:52:24 <halogenandtoast> and getMove has to be evaluated because IO
21:52:34 <jle`> `liftA2 f x y` will execute x, then execute y, and then return the result of x and y applied to f
21:52:48 <jle`> so the first thing that getMove does is call getMove
21:52:51 <jle`> which then does getMove
21:52:57 <jle`> which then does getMove, etc.
21:52:59 <iqubic> How can that be fixed?
21:53:12 <jle`> but it never gets to a point where it would get to parseMove
21:53:19 <jle`> it's like:
21:53:28 <jle`> > let foo = foo ++ [1,2,3]
21:53:30 <lambdabot>  <no location info>: error:
21:53:30 <lambdabot>      not an expression: ‘let foo = foo ++ [1,2,3]’
21:53:31 <jle`> > let foo = foo ++ [1,2,3] in foo
21:53:37 <lambdabot>  mueval-core: Time limit exceeded
21:53:43 <halogenandtoast> Right
21:53:52 <iqubic> Is there any way he can fix that? or not.
21:54:05 <halogenandtoast> I have a "similar" problem if I do
21:54:05 <halogenandtoast>   mMove <- parseMove <$> getInput
21:54:06 <halogenandtoast>   fromMaybe <$> getMove <*> pure mMove
21:54:18 <jle`> well, what do you want to do?
21:54:31 <halogenandtoast> if mMove is Nothing recurse
21:54:33 <jle`> do you want to perform parseMove until you get a valid move?
21:54:37 <jle`> then you should do that
21:54:40 <halogenandtoast> otherwise return the wrapped Just
21:54:41 <jle`> case mMove of
21:54:45 <jle`>   Just x -> x
21:54:54 <jle`>   Nothing -> getMove
21:55:01 <iqubic> That will work.
21:55:13 <jle`> once you explain the solution in english, it's clear to see :o
21:55:18 <halogenandtoast> jle`: well kind of
21:55:23 <halogenandtoast> I need `return x`
21:55:26 <halogenandtoast> but close enough
21:55:45 <jle`> mhm
21:55:59 <iqubic> Why do you need "return x" 
21:56:20 <iqubic> if your calling makeMove until you get a valid move, then you will never be returning nothing.
21:56:21 <halogenandtoast> iqubic: because it's in IO
21:56:23 <jle`> well, x :: Move
21:56:27 <jle`> but the result should be IO Move
21:56:32 <iqubic> Ah.
21:56:36 <jle`> so return :: a -> IO a
21:56:40 <halogenandtoast> I can also use `  maybe getMove return mMove
21:56:55 <halogenandtoast> but people seem polarized on that one.
21:57:00 <halogenandtoast> I happen to like it
21:57:08 <iqubic> What does that do?
21:57:10 <jle`> it sounds like that kind of cleverness might have been what got you into this mess in the first place :)
21:57:24 <iqubic> How will maybe getMove return mMove work?
21:57:30 <Myrl-saki> How does ghc compile main?
21:57:36 <halogenandtoast> :t maybe
21:57:37 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:57:38 <jle`> iqubic: do you know what 'maybe' does?
21:57:48 <iqubic> I do now.
21:58:10 <jle`> so, you should know how that would work :)
21:58:18 <jle`> @src maybe
21:58:18 <lambdabot> maybe n _ Nothing  = n
21:58:18 <lambdabot> maybe _ f (Just x) = f x
21:58:23 <jle`> all you need to do is unroll the definition
21:58:34 <iqubic> what library do I need to get haskell-gi to work?
21:58:41 <iqubic> Is there a reuqired library?
21:58:43 <jle`> iqubic: what is haskell-gi
21:59:04 <iqubic> @hackage haskell-gi
21:59:05 <lambdabot> http://hackage.haskell.org/package/haskell-gi
21:59:23 <iqubic> I'm using it in tandem with gi-gtk
21:59:25 <jle`> are you asking what haskell libraries you need?
21:59:31 <jle`> because that information is in the description of the package
21:59:36 <jle`> under 'dependencies'
21:59:49 <iqubic> No, I think I need a certain system library to make that work.
21:59:49 <Koterpillar> iqubic: https://github.com/haskell-gi/haskell-gi/blob/master/haskell-gi.cabal#L27
21:59:53 <EvanR> so gmp integers require some messy memory managment, they arent immutable values, they are like IORefs of their own that can be modified, as if you could change the value of the number 2
22:00:00 <EvanR> how does ghc keep all that straight?
22:00:07 <jle`> Myrl-saki: what sort of answer are you looking for?
22:00:07 <halogenandtoast> Thanks for the help and explaination jle` that made perfect sense.
22:00:16 <jle`> halogenandtoast: noproblem!
22:00:17 <Koterpillar> iqubic: not being familiar with Gentoo, that's all I can say. Do you have some tool that can search for pkg-config?
22:00:25 <jle`> the important thing is that liftA2 doesn't change effects
22:00:30 <jle`> so it doesn't "short-circuit"
22:00:33 <Koterpillar> iqubic: maybe take that line to #gentoo to figure out which package (?) you have to install
22:00:36 <jle`> liftA2 f leaves effects unchanged
22:00:39 <halogenandtoast> jle`: yeah I didn't realize that.
22:00:48 <halogenandtoast> I don't really use liftA2
22:00:50 <jle`> halogenandtoast: you can also try something inspired from parser combinators, though
22:00:54 <halogenandtoast> I thought I would try it out to see what happened
22:00:55 <Myrl-saki> jle`: Hmmm. How does main work under the hood, to be more exact?
22:01:00 <jle`> parser combinator style
22:01:03 <boxscape> is there a good way to write `view' only once here? Result <$> (view lastIns) <*> (view cpuRegs) <*> (view output) <*> (view cpuSteps)
22:01:05 <halogenandtoast> and the result was interesting to me
22:01:12 <halogenandtoast> I'm fine with my cleverness: getMove = parseMove <$> getInput >>= maybe getMove return
22:01:12 <jle`> halogenandtoast: getMove = MaybeT parseMove <|> getMove
22:01:25 <jle`> or well, getMove = parseMove <|> getMove
22:01:32 <halogenandtoast> oh that looks spiffy
22:01:39 <jle`> where getMove :: MaybeT IO Move; parseMove :: MaybeT IO Move
22:01:46 <iqubic> :t (<|>)
22:01:48 <lambdabot> Alternative f => f a -> f a -> f a
22:01:55 <halogenandtoast> lol Alternative
22:01:58 <iqubic> What is an alternative?
22:02:17 <jle`> in this case it describes "choice"
22:02:27 <iqubic> I see.
22:02:32 <boxscape> > Nothing <|> Just x
22:02:34 <lambdabot>  Just x
22:02:39 <jle`> "this or that"; return the first part if it's succesful, or if it's a 'failure', do the next
22:02:50 <boxscape> > [1..5] <|> [6..10]
22:02:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:02:58 <jle`> `MaybeT IO a` wraps an IO (Maybe a), and considers a success to be a Just result, and a Nothing to be a failure
22:03:27 <jle`> so `x <|> y` for MaybeT IO's instance will execute x, and, if it's Just, stop there; and if it's Nothing, do y
22:03:58 <halogenandtoast> jle`: does parseMove need to be in IO?
22:04:12 <halogenandtoast> my current implementation doesn't do anything in IO
22:04:14 <jle`> iqubic: like for any typeclass, you just need to understand that specific instance's behavior to understand the code
22:04:21 <jle`> iqubic: you don't need to understand the typeclass in general
22:04:25 <iqubic> Yeah, I get that.
22:04:46 <iqubic> The state monad is quite different from the writer monad.
22:04:48 <jle`> halogenandtoast: oh sorry, i meant (parseMove <$> getInput) <|> getMove
22:05:30 <iqubic> shouldn't getInput come first in the parenthesis?
22:05:52 <jle`> hm
22:06:14 <jle`> (MaybeT (parseMove <$> getInput)) <|> getMove
22:06:37 <halogenandtoast> It's also weird that getMove would need to be a MaybeT as well.
22:06:42 <iqubic> Why do you need it to wrapped in a MaybeT?
22:06:50 <jle`> it's what gives it the right Alternative instance
22:06:55 <jle`> sort of like:
22:07:02 <jle`> > Sum 1 <> Sum 10
22:07:04 <lambdabot>  Sum {getSum = 11}
22:07:16 <jle`> MaybeT is a newtype wrapper that gives the thing the appropriate Alternative instance
22:07:23 <jle`> without it, you're using the Alternative instance for IO
22:07:27 <jle`> which is...very different
22:07:40 <jle`> > Any True <> Any False
22:07:42 <lambdabot>  Any {getAny = True}
22:07:43 <jle`> > All True <> All False
22:07:45 <lambdabot>  All {getAll = False}
22:08:01 <iqubic> What does that do? The Alternative IO instance?
22:08:06 <iqubic> Also, what is <>?
22:08:24 <jle`> the Alternative IO instance only considers an IO exception to be 'failure'
22:08:27 <jle`> and everything else to be success
22:08:32 <iqubic> Oh wow.
22:08:42 <jle`> MaybeT IO's instance consuders Nothing's to be failures
22:08:44 <iqubic> That's quite different
22:09:07 <jle`> <> is from the Monoid typeclass
22:09:08 <iqubic> I assume EitherT IO exists as well?
22:09:16 <jle`> EitherT e IO, yes
22:09:39 <iqubic> right, because you can only give a typeclass one parameter.
22:09:44 <iqubic> what does <> do?
22:09:56 <boxscape> :t (<>)
22:09:58 <lambdabot> Monoid m => m -> m -> m
22:10:01 <jle`> it's a part of the Monoid typeclass, so every instance gets to define it however it wants
22:10:09 <halogenandtoast> I'm glad I was able to answer my own question before I asked it.
22:10:20 <halogenandtoast> I was about to ask, "How do I unwrap a MaybeT"
22:10:20 <jle`> which is why Any True <> Any False gives different results than All True <> All False
22:10:27 <halogenandtoast> But I figured it out by guessing
22:10:33 <jle`> halogenandtoast: congrats :)
22:10:52 <iqubic> halogenandtoast: How do you unwrap that?
22:10:54 <jle`> iqubic: monoid is one of the more ubiquitous haskell typeclasses so it might be nice to look at different examples
22:10:59 <halogenandtoast> iqubic: runMaybeT
22:11:07 <halogenandtoast> :t runMaybeT
22:11:08 <iqubic> alrighty then. 
22:11:09 <lambdabot> error: Variable not in scope: runMaybeT
22:11:14 <jle`> most haskell courses talk about monoid
22:11:21 <jle`> http://ozark.hendrix.edu/~yorgey/pub/monoid-pearl.pdf
22:11:25 <iqubic> Yeah, like LYAH
22:12:09 <iqubic> Wait, <> is infix mappend. Right?
22:12:15 <jle`> the reason i brought it up here was because by using Any or All, you can take advantage of the monoid instance of different types
22:12:21 <iqubic> I know what that does then.
22:12:22 <jle`> so you can effectively "choose" the monoid instance you want to use
22:12:28 <jle`> yes, (<>) = mappend
22:12:42 <halogenandtoast> jle`: the use of `All` and `Any` is really awesome.
22:12:48 <iqubic> Is there an infix mconat?
22:12:51 <iqubic> :t any
22:12:53 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
22:13:11 <jle`> iqubic: mconcat only takes one argument, so it wouldn't really make sense to have an infix version
22:13:19 <iqubic> I get that now.
22:13:23 <iqubic> :t mconcat
22:13:25 <lambdabot> Monoid a => [a] -> a
22:14:31 <iqubic> So is there a instance of monoid for num?
22:14:45 <jle`> Num isn't a type, so, it wouldn't really make sense to have one
22:14:52 <jle`> at least not a kind-* type
22:14:56 <halogenandtoast> Is there a subjectively better way to write: https://gist.github.com/halogenandtoast/f6cb02d94c44c54404299243d3cc4e6c#file-minesweeper-hs-L30
22:15:01 <iqubic> Right. 
22:15:06 <iqubic> What is the kind of Num?
22:15:12 <jle`> * -> Constraint
22:15:16 <jle`> it takes a type and returns a constraint
22:15:23 <jle`> :k Num Int
22:15:25 <lambdabot> Constraint
22:15:42 <iqubic> :k Num a
22:15:43 <jle`> there isn't a Monoid instance for numeric types, though, typically.  like Int or Double or Float
22:15:43 <lambdabot> error: Not in scope: type variable ‘a’
22:15:55 <jle`> that's because it isn't clear which one should be used by default
22:16:01 <jle`> there is more than one way to have a monoid on Ints
22:16:18 <iqubic> You can run readMaybe over a list of things?
22:16:30 <jle`> instead, by default, haskell gives us newtype wrappers to let us chose which monoid instance we want
22:16:35 <jle`> > Sum 10 <> Sum 13
22:16:37 <lambdabot>  Sum {getSum = 23}
22:16:38 <jle`> > Product 10 <> Product 13
22:16:40 <lambdabot>  Product {getProduct = 130}
22:16:47 <iqubic> I see.
22:16:50 <jle`> iqubic: 'run' how
22:17:07 <jle`> > traverse readMaybe ["1","2","3"] :: Maybe [Int]
22:17:08 <lambdabot>  error:
22:17:09 <lambdabot>      Variable not in scope: readMaybe :: [Char] -> Maybe Int
22:17:18 <jle`> @let import Text.Read
22:17:19 <lambdabot>  Defined.
22:17:21 <jle`> > traverse readMaybe ["1","2","3"] :: Maybe [Int]
22:17:23 <lambdabot>  Just [1,2,3]
22:17:25 <iqubic> jle`: Yeah, you can do something like that.
22:17:30 <iqubic> What does that do?
22:17:49 <iqubic> Why are you not using map there?
22:17:51 <jle`> traverse for (a -> Maybe b) applies the (a -> Maybe b) to every item in the list
22:17:55 <halogenandtoast> Could do `readMaybe <$> words "1 2"`
22:17:59 <jle`> and collects the results
22:18:05 <jle`> iqubic: traverse is map + sequence
22:18:11 <iqubic> Ah, I see.
22:18:20 <jle`> if any of the results are Nothin,g the whole thing is NOthing
22:18:31 <jle`> > traverse readMaybe ["1","hello","3"] :: Maybe [Int]
22:18:33 <lambdabot>  Nothing
22:18:34 <jle`> alternative:
22:18:52 <jle`> > mapMaybe readMaybe ["1","hello","3"] :: [Int]
22:18:54 <lambdabot>  [1,3]
22:19:05 <iqubic> Wait, doesn't map already return a list?
22:19:08 <jle`> mapMaybe applies an (a -> Maybe b) to every item, and collects the Just's
22:19:15 <jle`> you can use map too, yes
22:19:26 <jle`> > map readMaybe ["1","hello","3"] :: [Maybe Int]
22:19:28 <lambdabot>  [Just 1,Nothing,Just 3]
22:19:40 <iqubic> What os the difference between traverse and map?
22:19:41 <jle`> a third possible interpretation of your original question
22:19:58 <jle`> map :: (a -> Maybe b) -> [a] -> [Maybe b]
22:20:05 <jle`> traverse :: (a -> Maybe b) -> [a] -> Maybe [b]
22:20:53 <iqubic> so travese is an all or nothing kind of deal, whereas map gives you a list every single time?
22:21:08 <jle`> yes, map just applies the function
22:21:13 <halogenandtoast> Is there anything good for [a] -> Maybe (a, a)
22:21:16 <jle`> traverse is a map + apply
22:21:19 <jle`> er, map + sequence
22:21:25 <iqubic> Yeah, I get that now.
22:21:25 <jle`> > sequence [Just 10, Just 3, Nothing]
22:21:28 <lambdabot>  Nothing
22:21:30 <iqubic> nothing.
22:21:37 <jle`> > sequence [Just 10, Just 3, Just 2]
22:21:39 <lambdabot>  Just [10,3,2]
22:21:42 <iqubic> I see.
22:21:51 <jle`> traverse f = sequence . map f, for lists
22:22:05 <iqubic> Just like you said earlier.
22:22:30 <iqubic> But why add the for list constraint there, if map only works on lists.
22:22:46 <iqubic> does map have to return something of type (maybe a)?
22:23:04 <jle`> :t map
22:23:06 <lambdabot> (a -> b) -> [a] -> [b]
22:23:06 <iqubic> > map (+5) [1..
22:23:08 <lambdabot>  <hint>:1:14: error:
22:23:08 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:23:10 <jle`> it doesn't
22:23:13 <iqubic> > map (+5) [1..]
22:23:15 <lambdabot>  [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3...
22:23:16 <jle`> it returns whatever the mapping function returns
22:23:30 <jle`> if the mapped function returns Int, it returns a list of Ints
22:23:40 <jle`> if the mapped function returns String, then the whole map returns a list of Strings
22:23:51 <jle`> if the mapped function returns Maybe Int, then the whol empa returns a list of Maybe Int's
22:24:01 <iqubic> Why did you write than??? map :: (a -> Maybe b) -> [a] -> [Maybe b]
22:24:27 <jle`> i specialized it for this specific situation
22:24:42 <iqubic> Wait, that is the type of map, where b = Maybe b
22:24:42 <jle`> if i'm using map with an (a -> Maybe b), then that is what it specializes too
22:24:45 <jle`> *to
22:24:55 <iqubic> :t traverse
22:24:55 <monochrom> "b = Maybe b" is very sad.
22:24:57 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:25:08 <iqubic> why is that monochrom?
22:25:13 <jle`> indeed it might not have been the best choice of names
22:25:32 <jle`> i might have done map :: (String -> Maybe Int) -> [String] -> [Maybe Int]
22:25:46 <jle`> i juse 'Maybe b' for the comparison to traverse
22:27:25 <jle`> iqubic: you can use any type for 'a' and 'b' in map, and the fucntion will specialize to make it work
22:27:32 <jle`> map :: (Int -> Bool) -> [Int] -> [Bool], etc.
22:28:13 <halogenandtoast> map :: ((a -> b) -> (b -> a)) -> [(a -> b)] -> [(b -> a)]
22:28:17 <jle`> if you give map an (Int -> Bool), it'll take a list of Int's and return a list of Bool's
22:28:28 <jle`> if iyou gave map an (a -> Maybe b), it'll take a list of a's and return a list of Maybe b's
22:28:38 <jle`> hence the type signature
22:33:08 <iqubic> I see. I'm not dumb, you know.
22:34:28 <jle`> i'm not assuming you're dumb :o  these things aren't necessarily obvious or intuitive, and i also don't want to make any assumptions about your haskell background
22:35:07 <jle`> besides, it's easier to explain all of the details up-front than to assume incorrectly what parts can be left out
22:40:11 <iqubic> How does one view the documentation for gi-gtk?
22:40:31 <iqubic> Since it needs to poll my GTK version, I assume local docs is all I get.
22:40:48 <Koterpillar> they are stable _enough_ to go by the docs you see on hackage
22:41:12 <iqubic> Really? I'm not sure I want to try that right now.
22:41:36 <iqubic> And I assume I should stay away from deprecated stuff
22:41:43 <Koterpillar> also, once you figure out the mapping, you should be able to just use the Gtk docs
22:41:55 <iqubic> Is the mapping simple?
22:42:02 <iqubic> Or is that a pain to understand?
22:42:27 <glguy> http://hackage.haskell.org/package/gi-gtk-3.0.11/docs/
22:42:34 <glguy> I find the mapping easy to understand
22:42:47 <iqubic> What is the mapping?
22:43:00 <iqubic> Is it a simple rule, you can just tell me?
22:43:06 <glguy> sorry, it's a secret
22:43:41 <Koterpillar> iqubic: it's mostly snake_case to camelCase
22:43:57 <iqubic> really?
22:44:02 <iqubic> What does that mean?
22:44:56 <iqubic> What's up with the # and the := in this example?
22:45:01 <iqubic> https://github.com/haskell-gi/haskell-gi
22:45:15 <Koterpillar> iqubic: that's OverloadedLabels if I understand correctly; I didn't use them
22:45:46 <iqubic> Then how do you use gi-gtk?
22:46:09 <Koterpillar> I'll just use my example again: https://github.com/koterpillar/tianbar/blob/master/src/System/Tianbar.hs
22:46:15 <Koterpillar> see this function: https://developer.gnome.org/gdk3/stable/GdkScreen.html#gdk-screen-get-primary-monitor
22:46:24 <Koterpillar> it's called gdk_screen_get_primary_monitor
22:46:32 <iqubic> Also, OverloadedLabels breaks my syntax highlighter.
22:46:36 <Koterpillar> and it was converted to displayGetPrimaryMonitor
22:48:00 <iqubic> Koterpillar: how would you write something like "on win #destroy Gtk.mainQuit"
22:48:25 <Koterpillar> just like that?
22:48:44 <iqubic> But doesn't that use OverloadedLables?
22:49:03 <iqubic> And don't you avoid those?
22:49:12 <Koterpillar> Ah
22:49:27 <iqubic> What?
22:49:27 <Koterpillar> I did when I wrote that code, I might give it a try now. But to answer your question...
22:49:38 <Koterpillar> onWindowDestroy win Gtk.mainQuit
22:49:53 <iqubic> What do you mean, when I wrote that code???
22:50:40 <iqubic> And what does "#showAll win" correspond to?
22:50:42 <Koterpillar> I mean that was a while ago, and I didn't feel like figuring out OverloadedLabels
22:50:48 <halogenandtoast> How do I add a constraint for a data constructor? For example: data Game = EmptyGame Int Int RandomGen
22:51:06 <halogenandtoast> I'm assuming I want RandomGen a => EmptyGame Int Int a
22:51:06 <iqubic> Just like that I'd assume?
22:51:08 <jle`> halogenandtoast: you aren't supposed to
22:51:13 <Koterpillar> iqubic: probably windowShowAll win
22:51:30 <jle`> halogenandtoast: why not just pick a specific type?
22:51:35 <jle`> Game = EmptyGame Int Int StdGen
22:51:46 <jle`> or, use it as a type paraemter?  data Game g = EmptyGame Int Int g
22:51:58 <iqubic> Koterpillar: do you have a list of these functions, or will I have to search from them myself?
22:51:58 <halogenandtoast> jle`: okay I'll just use StdGen for now.
22:52:37 <halogenandtoast> Thanks
22:53:04 <jle`> np
22:53:18 <Koterpillar> iqubic: https://developer.gnome.org/gtk3/stable/ 
22:54:06 <iqubic> Oh, it really is a one to one corralation of the functions.
22:54:19 <iqubic> And I assume I can use ghci to get the right types.
22:55:13 <iqubic> Or is it all IO, since this is mostly just a heaping pile of side-effects?
22:57:16 <Koterpillar> It's all IO
22:57:30 <glguy> and thus no side effects
22:57:49 <iqubic> But doesn't IO mean side effects by definition.
22:59:44 <dibblego> No.
23:00:58 <iqubic> Doesn't IO break referential transparency?
23:01:22 <jle`> can you show an example of when you think it would?
23:01:25 <Koterpillar> iqubic: no, because all the effects are happening outside the Haskell evaluation
23:01:29 <Cale> Execution of IO actions isn't referentially transparent, but evaluation of them is.
23:01:36 <iqubic> Oh. 
23:02:00 <iqubic> I just think that running getLine will always return different results.
23:02:01 <jle`> let x = putStrLn "hello" in x >> x is the same as putStrLn "hello" >> putStrLn "hello"
23:02:21 <jle`> let x = getLine in x >> x is the same as getLine >> getLine
23:02:21 <Cale> iqubic: But merely *evaluating* getLine doesn't do anything too visible.
23:02:25 <jle`> referential transparency at its finiest
23:02:25 <iqubic> Right, but getLine let's the user enter input.
23:02:34 <Cale> > getLine `seq` ()
23:02:37 <lambdabot>  ()
23:03:20 <jle`> iqubic: let x = getLine in x >> x is the same as getLine >> getLine; getLine is a pure value
23:03:23 <Cale> Of course, the distinction is a little bit subtle, because IO is abstract, so we can't talk about pattern matching IO actions.
23:03:29 <jle`> it's a pure value of type IO String
23:03:40 <iqubic> Oh, so it is.
23:03:56 <iqubic> And that makes use of the fact that IO is a monad.
23:04:10 <Cale> Well, it needn't be >> there
23:04:33 <Cale> For any function f, let x = getLine in f x x will be the same as f getLine getLine
23:04:34 <jle`> well, IO the type is referntially transparent even if there was no monad instance or it wasn't a monad
23:04:42 <jle`> te fact tiat it's referntially transparent comes from the fact that we're in haskell
23:04:59 <jle`> well, hm, maybe that's not the best description
23:05:06 <jle`> it comes from the fact that the IO type's API is pure
23:05:26 <iqubic> Right, but grabbing the value from within is a side-effect.
23:05:42 <jle`> you can't grab values from within IO
23:05:46 <jle`> there are no values inside an IO action
23:05:46 <iqubic> Like trying to extract a String from and IO String
23:05:50 <Cale> It's weird to say it like that. Carrying out the described actions has an effect.
23:06:09 <jle`> you cannot extract a String from an IO String, because there is no String inside an IO String
23:06:19 <jle`> it's not a box containing a String
23:06:22 <Cale> The difference between an IO String and a String is like the difference between /bin/ls and a list of files in your home directory.
23:07:07 <Cale> You can open up /bin/ls in a hex editor without causing a list of files to be printed to the screen, just as IO actions might be evaluated without causing their effects to occur.
23:07:12 <iqubic> Right, but running the IO action is the part that has a side-effect
23:07:16 <Cale> Right.
23:07:30 <Cale> Or, perhaps it's not even right to call it a side effect anymore.
23:07:32 <jle`> at that point it isn't really a side-effect
23:07:35 <jle`> it's just an effect
23:08:01 <iqubic> But running the same IO action might produce different results at different times.
23:08:32 <jle`> that is true; we just don't run IO actions inside haskell
23:08:42 <Cale> I wouldn't say that
23:08:49 <Cale> Execution of IO actions is part of Haskell.
23:08:51 <iqubic> You ask the underlying C code to run the IO action?
23:08:55 <Cale> It's just not part of evaluation.
23:09:13 <jle`> we use haskell to define an IO action, and then ghc compiles it to bytecode
23:09:15 <Cale> You have to understand how IO actions are executed in order to fully understand a Haskell program.
23:09:17 <jle`> and then we let a computer/CPU evaluate it for us
23:09:33 <Cale> So it's certainly "part of Haskell"
23:09:56 <jle`> yes, thanks for clarifying
23:10:07 <Cale> Also... that's not entirely true either. If you want to talk about how GHC does things... it compiles IO actions to native code along with everything else.
23:10:18 <iqubic> LOL.
23:10:26 <iqubic> Yeah, that's true.
23:10:37 <iqubic> But we don't really care about that now, do we?
23:10:42 <jle`> in haskell, you spend your time defining an IO action, using IO's pure interface
23:10:46 <jle`> that's why IO is referentially transparent
23:10:54 <jle`> every time you define an IO action, you define the same IO action
23:11:09 <iqubic> Yep. And you can run that IO action if you wish.
23:11:10 <Cale> I think it's important to make the distinction here between what part of it is referentially transparent.
23:11:11 <jle`> the actual definition of the IO action is a pure/referentially transparent process
23:11:22 <qmm> should i use <$> and <*> or liftA2, are there best practices for this?
23:11:42 <cocreature> qmm: I tend to use <$> and <*> because it’s easier to add more arguments
23:11:43 <jle`> qmm: i think both are equally ok
23:11:48 <Cale> Also, in order to talk about referential transparency, you really need to specify the context in which something is referentially transparent, otherwise, there are aspects of evaluation which are not referentially transparent either.
23:12:02 <Cale> A simple variable like x for instance, does not always refer to the same thing.
23:12:20 <iqubic> Now how does stuff like "Do x <- getLine; putStrln (x ++ x)" work?
23:12:33 <iqubic> Is that an IO action?
23:12:37 <qmm> thanks cocreature and jle` 
23:12:40 <jle`> iqubic: yes; what is its type? :)
23:12:40 <Cale> Yes, modulo case
23:12:49 <saurabhnanda> Can anyone help me with lenses here? https://stackoverflow.com/questions/43314855/shorter-way-to-traverse-nested-record-with-maybe/43315062 Especially this part -- `^. _Just` over a `Maybe Text` results in a "" However `^. _Just` over a `Maybe Int` results in the following error -- No instance for (Monoid Int) arising from a use of ‘_Just’ Is it possible to traverse over a Maybe in such a way that the entire traversal results in 
23:12:49 <saurabhnanda> a Maybe without depending on Monoid magic?
23:12:51 <glguy> liftA2 is good for cases like : f (liftA2 g)
23:13:05 <Cale> do notation works like this:
23:13:14 <jle`> iqubic: you're defining an IO action that gets a line and prints the result concatenated to itself
23:13:18 <glguy> it's like how we have sum and foldl (+) 0, both
23:13:19 <Cale> do { v <- x; <stmts> } = x >>= \v -> do { <stmts> }
23:13:29 <Cale> do { x; <stmts> } = x >> do { <stmts> }
23:13:30 <iqubic> I understand how the desuguring fo notation works.
23:13:44 <Cale> etc. etc. you apparently get it :)
23:13:50 <jle`> in haskell, we define IO complex actions by manipulating/sequencing/combining simpler primitives that GHC gives us
23:14:21 <jle`> so if i have an IO action that reads frmo the disk, and an IO action that launches missiles, I can combine them using (>>) to make a new IO action that reads from the disk *and* launches missiles
23:14:22 <Cale> Here, let's build a small toy version of the IO monad, and then write an executor for it which will turn it into a proper IO action.
23:14:24 <cocreature> > Just 1 ^? _Just -- saurabhnanda 
23:14:26 <lambdabot>  Just 1
23:14:33 <cocreature> > Nothing ^? _Just
23:14:35 <lambdabot>  Nothing
23:15:05 <Cale> data MyIO a = Done a | PutStrLn String (MyIO a) | GetLine (String -> MyIO a)
23:15:09 <iqubic> Technically every Haskell program ever is one large IO action. Just look at the type of Main.
23:15:09 <iqubic> :t Main
23:15:10 <lambdabot> error: Data constructor not in scope: Main
23:15:25 <jle`> iqubic: well, every haskell executable is an IO action
23:15:37 <jle`> that's what you do when you define a haskell executable
23:15:37 <iqubic> Cale: What is that data good for?
23:15:40 <jle`> you're defining an IO action
23:15:42 <Cale> The intention here is that we're going to represent programs which do line-based terminal I/O
23:15:49 <cocreature> saurabhnanda: note that this will only give you the first value if your traversal targets multiple elements.
23:15:56 <saurabhnanda> cocreature: thank you :) 
23:16:04 <jle`> haskell libraries are not one large IO action, though, ofc.  just haskell executables
23:16:12 <iqubic> Yep.
23:16:13 <Cale> This is heavily oversimplified, but hopefully if we understand this, it's possible to imagine extending it indefinitely to include everything else.
23:16:14 <saurabhnanda> cocreature: here's how I'm using it in real code -- fromMaybe "" (bi ^? bookerContact._Just.fullName) -- should I be careful about something?
23:16:36 <iqubic> Cale, I understand how IO works now.
23:16:47 <cocreature> saurabhnanda: looks fine. although in that case the Monoid instance would probably work?
23:16:51 <Cale> So, a MyIO action can either produce a simple result immediately without causing any effect, which is represented by Done x
23:17:18 <saurabhnanda> cocreature: it seems too magical and I'm afraid no newcomer would be able to figure out where the empty string is coming from.
23:17:30 <cocreature> saurabhnanda: yeah I agree that the solution you have is clearer
23:17:34 <Cale> Or it can start off by printing some line s to the terminal, and be followed up with another MyIO action x, which is represented by PutStrLn s x
23:17:54 <Myrl-saki> Oh whoops. Internet disconnected.
23:17:58 <Myrl-saki> Cale: Right.
23:18:03 <Cale> Or it can start off by reading a line of input from the user, and then using the resulting String to determine which MyIO action should be carried out thereafter
23:18:03 <glguy> saurabhnanda: you can even define your own ^. that doesn't allow the monoid behavior
23:18:04 <Myrl-saki> Luckily, we're talking about IO right now.
23:18:13 <Myrl-saki> How does ghc compile IO, which is "data"?
23:18:33 <Cale> which is represented by GetLine f, where f :: String -> MyIO a is a function describing what to do if the input was any given string
23:18:53 <saurabhnanda> glguy: cocreature: generally speaking, is depdending on the monoid behaviour **as a default** a wise choice by the lens library?
23:19:09 <Cale> Myrl-saki: Note that I'm not actually talking about GHC's implementation here, which involves low-level hackery
23:19:42 <iqubic> :t interact
23:19:43 <Cale> Just a useful mental model and a possible implementation (though getting it to compile nicely to quality machine code would be harder, most likely)
23:19:44 <lambdabot> (String -> String) -> IO ()
23:19:52 <qmm> > let x = [1,2,3] y = [4,5,6] in sum <$> (liftA2 (,) x y) -- is shorter than
23:19:54 <Cale> So, let's write the Monad instance for MyIO
23:19:54 <lambdabot>  <hint>:1:19: error:
23:19:54 <lambdabot>      parse error on input ‘=’
23:19:54 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
23:19:54 <iqubic> What does interact do?
23:19:59 <Myrl-saki> Cale: Can I get info either way? I'm interested in making a programming language.
23:20:00 <cocreature> saurabhnanda: depends on who you ask I guess. personally I’m not a big fan of it.
23:20:03 <glguy> saurabhnanda: I argued against it. we already have foldOf, view doesn't need to support it
23:20:03 <qmm> > let x = [1,2,3] ; y = [4,5,6] in sum <$> (liftA2 (,) x y) -- is shorter than
23:20:05 <lambdabot>  [4,5,6,4,5,6,4,5,6]
23:20:13 <Cale> iqubic: It reads stdin and passes that to the function in order to obtain stdout
23:20:19 * seequ_ remembers defining things like MyIO for animation compositions even in procedural languages.
23:20:42 <iqubic> So it's only useful in Main?
23:20:54 <qmm> that is strange
23:21:24 <Cale> iqubic: basically. It's only useful for writing fairly simplistic programs which only do simple terminal I/O
23:21:27 <Myrl-saki> :t sum
23:21:27 <jle`> qmm: did you leave out a word
23:21:28 <lambdabot> (Num a, Foldable t) => t a -> a
23:21:30 <saurabhnanda> cocreature: glguy: thanks... good to know my intuition about haskell code is shaping up :)
23:21:43 <Cale> and even at that, it's tricky to do anything too complicated with it
23:21:51 <cocreature> I seem to recall that GHC supports something like "{-# ATTRIBUTE … #-}" where the attributes can then be read in the compiler but I can’t find any documentation on it. am I missremembering here?
23:22:00 <qmm> if you set to x = [1,2,3] and y = [4,5,6], sum <$> (liftA2 (,) x y) results in Just 2, but for some reason let x = [1,2,3] ; y = [4,5,6] in sum <$> (liftA2 (,) x y) results in [4,5,6,4,5,6,4,5,6]
23:22:03 <glguy> cocreature: ANN
23:22:08 <cocreature> glguy: ah I just found it
23:22:10 <cocreature> thanks
23:22:26 <Cale> Well, before we even get to the monad instance, let's write
23:22:32 <Cale> execute :: MyIO a -> IO a
23:22:41 <Cale> execute (Done v) = return v
23:23:04 <Cale> execute (PutStrLn s x) = do putStrLn s; execute x
23:23:08 <jle`> qmm: i'm not sure how the first one is Just 2
23:23:24 <Cale> execute (GetLine f) = do s <- getLine; execute (f x)
23:23:28 <Cale> oops
23:23:29 <Cale> execute (GetLine f) = do s <- getLine; execute (f s)
23:23:34 <iqubic> Cale, why are we doing this?
23:23:37 <qmm> jle`: me either
23:23:40 <iqubic> What is the point?
23:23:47 <Myrl-saki> iqubic: Why not
23:23:51 <Cale> Basically for fun, and to see a possible implementation of this sort of thing
23:23:55 <jle`> qmm: what are you compiling?
23:24:07 <Cale> This kind of interpreter pattern is pretty useful in a lot of cases
23:24:07 <jle`> what do you expect the result to be?
23:24:09 <Myrl-saki> Cale: We had a discussion about this a few days ago. :D
23:24:25 <qmm> oh, i didn't set x to [1,2,3] and y to [4,5,6]
23:24:28 <qmm> that's why
23:24:35 <halogenandtoast> lol
23:24:38 <qmm> they Just 3 and Just 2
23:24:43 <jle`> heh
23:25:09 <jle`> anyway using Foldable for tuples makes me uncomfortable
23:25:15 <Cale> We can also implement Monad/Applicative/Functor for this type.
23:25:43 <iqubic> How do I run a thing I've built with Stack?
23:25:43 <Myrl-saki> > sum (2,3)
23:25:45 <lambdabot>  3
23:25:51 <Myrl-saki> > wutface
23:25:53 <lambdabot>  error: Variable not in scope: wutface
23:25:56 <Myrl-saki> ohwhoops
23:26:05 <iqubic> > sum (1,2)
23:26:07 <lambdabot>  2
23:26:12 <iqubic> > sum (2,1)
23:26:14 <lambdabot>  1
23:26:19 <Myrl-saki> Why not Foldable (a, a)
23:26:19 <Cale> iqubic: stack build and then run the resulting executable
23:26:40 <Myrl-saki> That's saner, isn't it?
23:26:41 <iqubic> But I don't know where it put the executable.
23:26:55 <iqubic> :t sum
23:26:56 <Myrl-saki> iqubic: `stack path`
23:26:56 <lambdabot> (Num a, Foldable t) => t a -> a
23:26:58 <Myrl-saki> or osmething
23:26:59 <Cale> It should tell you
23:27:14 <Koterpillar> iqubic: stack path --local-install-root or something
23:27:19 <Koterpillar> iqubic: stack help path
23:27:32 <jle`> Myrl-saki: you can't really write that instance
23:27:47 <Cale> stack path --help rather
23:27:49 <jle`> try it
23:27:54 <jle`> you'll see why :)
23:28:46 <Myrl-saki>   • Expecting one fewer argument to ‘(a, a)’
23:28:48 <Myrl-saki>       Expected kind ‘* -> *’, but ‘(a, a)’ has kind ‘*’
23:28:50 <Myrl-saki> ; ^ ;
23:29:04 <jle`> yup.  you could make maybe a
23:29:13 <jle`> newtype Join f a = Join (f a a)
23:29:16 <Myrl-saki> type D f a = f
23:29:18 <Myrl-saki> Welp
23:29:21 <jle`> instance Foldable (Join (,)) where ...
23:29:26 <Myrl-saki> jle`: What I was about to say.
23:29:41 <iqubic> So there is no simple way to run a stack project?
23:29:59 <jle`> iqubic: if you stack install, you can just type in the name of the executable
23:30:00 <jle`> in the command line
23:30:14 <jle`> for exampl,e if i hav ean executable called f'foo'
23:30:17 <Cale> You can also  stack exec <executablename>
23:30:21 <jle`> i can stack install => type 'foo'
23:30:32 <Myrl-saki> jle`: IIRC, FlexibleInstances is evil?
23:30:43 <jle`> FlexibleInstances is pretty normal
23:30:51 <jennyrgb> how do you interpret (+3)?
23:30:52 <iqubic> I like "stack exec executablename"
23:31:05 <iqubic> you can't jennyrgb.
23:31:07 <jle`> stack exec xecutablename won't re-install
23:31:14 <jle`> jennyrgb: it's an operator section
23:31:15 <jennyrgb> (+3)2 makes no sense to me, but it's 5
23:31:15 <tsahyt> jennyrgb: (+3) == \x -> x + 3
23:31:15 <srhb> jennyrgb: It's an operator section where the left hand argument is elided.
23:31:22 <jle`> it's syntactic sugar for \x -> x + 3
23:31:29 <iqubic> Right.
23:31:40 <jle`> jennyrgb: you can imagine that it's "waiting" for something on the left hand side of the +
23:31:44 <Myrl-saki> jle`: Get the type
23:31:50 <srhb> jennyrgb: Similarly, (3+) is an operator section where the right hand argument is elided, so, \y -> 3 + y
23:32:05 <jle`> Myrl-saki: FlexibleInstances is actually the more intuitive behavior for how typeclasses should work, i believe
23:32:05 <Myrl-saki> jennyrgb: *
23:32:18 <tsahyt> for (+), left and right sections happen to do the same (because addition is commutative), but that's of course not always the case
23:32:19 <iqubic> What does FlexibleInstances do?
23:32:21 <jle`> Myrl-saki: the reason why it's an extension is because the haskell report is a bit restritive in what is allowed for typeclass resolution and stuff
23:32:37 <jennyrgb> oh right, I forgot this. Can you make your own such "sugar" for your own operators/functions?
23:32:46 <jle`> jennyrgb: what kind of sugar do you mean?
23:32:46 <srhb> jennyrgb: It's there automatically
23:32:49 <jle`> you can use sections for any operator
23:32:55 <tsahyt> jennyrgb: sections work just fine on any operator, including your own
23:33:07 <iqubic> You can define your own operator however you want.
23:33:12 <iqubic> What does FlexibleInstances do?
23:33:13 <tsahyt> jennyrgb: they also work for functions used infix by writing them in backticks
23:33:16 <srhb> jennyrgb: The rule is: Anything that is a symbol-only name is an operator by default.
23:33:17 <jle`> @let x &*$#@ y = x * y + y in (&*$#@ 5) 10
23:33:17 <lambdabot>  Parse failed: Parse error: in
23:33:18 <tsahyt> jennyrgb: e.g. (`mod` 5)
23:33:21 <Cale> iqubic: In Haskell 98 (and 2001, which barely changed anything in H98), there was an arbitrary restriction that instances of type classes must be for a type constructor applied to some list of distinct type variables *only*
23:33:21 <jle`> >let x &*$#@ y = x * y + y in (&*$#@ 5) 10
23:33:43 <tsahyt> :t (`mod` 5)
23:33:44 <lambdabot> Integral a => a -> a
23:34:10 <Cale> iqubic: e.g. if you wanted to write an instance of some class for Foo Bar, that's not allowed, you'd have to be able to write it for Foo a
23:34:10 <halogenandtoast> Let's say I had a grid of positions and I want to place mines at random spots, but I want to guarantee a certain number of mines were placed. Is there a better way of doing this than say
23:34:10 <iqubic> Cale, what does that mean?
23:34:15 <halogenandtoast> gen <- newStdGen
23:34:23 <halogenandtoast> shuffle xs = map snd $ sortOn fst $ zip (randoms gen) xs
23:34:28 <halogenandtoast> take 9 $ shuffle [[x, y] | x <- [0..9], y <- [0..9]]
23:34:28 <jle`> iqubic: when in doubt, you can also just look at the ghc user manual
23:34:34 <jle`> iqubic: which is usually pretty clear
23:34:40 <jle`> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XFlexibleInstances
23:34:59 <jle`> it covers every extension :)
23:35:05 <Cale> iqubic: One place where this is especially painful is that it means that you can't just write an instance of some class for String specifically, since String is a synonym for [Char] which is the [] type constructor applied to Char
23:35:11 <srhb> halogenandtoast: nub and randoms ?
23:35:28 <Cale> Char being a type constructor and not a type variable, this falls foul of that rule
23:35:36 <jennyrgb> why isn't (-3) working?
23:35:42 <jle`> jennyrgb: because we can't have good things
23:35:43 <srhb> jennyrgb: - is special for prefix minus
23:35:45 <Koterpillar> jennyrgb: because it's special cased
23:35:48 <srhb> jennyrgb: Sadly. :(
23:35:50 <halogenandtoast> srhb: but how would I ensure I get 9 good results?
23:35:52 <jle`> jennyrgb: the haskell parser treats - as a special case :'(
23:35:53 <Cale> So FlexibleInstances just turns off that rule, and lets you write instances specialised to particular type arguments
23:36:03 <jle`> jennyrgb: that's why we have subtract, so you can write (subtract 3) instead
23:36:07 <srhb> halogenandtoast: "good" ?
23:36:22 <halogenandtoast> 9 total results, none of which are duplicates
23:36:29 <halogenandtoast> nub would remove duplicates, but doesn't ensure 9
23:36:37 <srhb> halogenandtoast: take 9 . nub 
23:36:42 <tsahyt> :t (3 -)
23:36:43 <lambdabot> Num a => a -> a
23:36:46 <tsahyt> that works though ^
23:36:58 <jle`> jennyrgb: haskell treats (-3) as the number "negative three"
23:37:05 <srhb> halogenandtoast: You get an infinite list of (Int,Int), so you just want to make sure those are unique, so you nub them, then you take nine of the nubbed (unique) values?
23:37:06 <jle`> instead of a section \x -> x - 3
23:37:06 <halogenandtoast> srhb: interesting, trying it out
23:37:06 <Myrl-saki> :t (- 3)
23:37:07 <lambdabot> Num a => a
23:37:08 <Cale> The place where those *Instances extensions start to become evil is with OverlappingInstances
23:37:09 <Myrl-saki> jennyrgb: ^
23:37:22 <jle`> > 8 + (-3)
23:37:24 <lambdabot>  5
23:37:24 <Myrl-saki> Ohhh. It was OverlappingInstances that was evil.
23:37:30 <Myrl-saki> Not Flexible.
23:37:34 <tsahyt> OverlappingInstances can be abused, but can also be okay
23:37:36 <Myrl-saki> Mixing up muh extensions.
23:37:48 <tsahyt> but in most cases is not what you want anyhow
23:38:10 <jle`> one of those "you should only use it if you know why you shouldn't use it" things
23:38:47 <Myrl-saki> I guess I'll change my question.
23:39:03 <Myrl-saki> I'm interested in making a Haskell-like language for Arduino. Should I use monadic main or nah?
23:39:03 <Cale> If you're going to use it, I recommend confining all the instances of the type class in question to a single module.
23:39:22 <Cale> Myrl-saki: I don't know what that question means?
23:39:42 <Cale> Myrl-saki: If you support type classes, you should have a Monad instance for IO.
23:39:53 <Myrl-saki> Cale: I'm considering doing something like `main :: World -> World`
23:40:11 <jle`> as a pure function?
23:40:14 <qmm> let x = [1,2,3] ; y = [4,5,6] in liftA2 (,) x y
23:40:16 <jle`> does that...make sense?
23:40:17 <qmm> > let x = [1,2,3] ; y = [4,5,6] in liftA2 (,) x y
23:40:19 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:40:28 <qmm> > let x = [1,2,3] ; y = [4,5,6] in lookup 1 (liftA2 (,) x y)
23:40:30 <lambdabot>  Just 4
23:40:42 <Myrl-saki> jle`: No idea.
23:40:47 <Cale> Myrl-saki: I doubt there's any reasonable type World for which that would make really good sense.
23:40:58 <qmm> how would i say fmap (lookup 1) (liftA2 (,) x y) 
23:41:02 <Cale> Myrl-saki: You might be able to get by with something like what old-timey-Haskell had
23:41:11 <jle`> Myrl-saki: if you want to build a pure language over an impure low-level one, look at purescript for a good example
23:41:11 <Cale> main :: [Response] -> [Request]
23:41:13 <Myrl-saki> Cale: Isn't that what old Haskell did?
23:41:15 <Myrl-saki> Oh.
23:41:31 <Cale> That was kind of awful to program though.
23:41:36 <jle`> its IO system is a very close-to-the-metal wrapper over javascript semantics
23:41:48 <iqubic> How does that even work?
23:41:48 <Cale> If we still had that today, people would define an IO monad pretty quickly.
23:41:56 <Myrl-saki> Cale: lmao
23:42:02 <jle`> and it has a monadic interface
23:42:11 <iqubic> How does the old style work?
23:42:33 <jle`> iqubic: your program is a function that takes inputs and returns outputs
23:42:35 <Cale> iqubic: Your function produces a list of requests, which describe I/O to be performed.
23:42:39 <Myrl-saki> Cale: I'll be including typeclasses
23:42:52 <Cale> and it gets a list of responses, which are basically the results of performing that I/O
23:42:58 <Myrl-saki> Cale: My problem is how to compile main.
23:42:59 <lpaste> qmm pasted “question” at http://lpaste.net/354472
23:43:03 <Cale> and the nth response corresponds to the nth request
23:43:17 <jle`> Myrl-saki: first you have to think about what you really mean when you say 'main'
23:43:21 <jle`> because main isn't anything special
23:43:37 <jle`> you probably are asking about how you want to compile your actual programs?
23:43:46 <halogenandtoast> Is there a method that takes a list and gives you them in groups like x = [1,2,3,4,5,6];  f 2 x == [[1,2],[3,4],[5,6]] 
23:43:51 <Myrl-saki> jle`: Compiling individual functions makes sense.
23:44:02 <jle`> halogenandtoast: chunksOf from the split package
23:44:10 <monochrom> halogenandtoast: Data.List.Split has it.
23:44:17 <Myrl-saki> jle`: But compiling main is different, if we're considering Cale's earlier definition in `MyIO`
23:44:32 <iqubic> Shouldn't the request be on LHS of the old time main type signature.
23:44:50 <halogenandtoast> thanks jle` monochrom 
23:44:51 <jle`> Myrl-saki: so you mean, how to hook your individual functions to what your arduino actually executes?
23:44:55 <Cale> iqubic: That would mean that it was getting a list of requests from the outside world
23:45:00 <Myrl-saki> jle`: Right.
23:45:40 <jle`> Myrl-saki: i consider purescript's approach to be nice here
23:45:45 <Cale> You have something like
23:45:54 <Myrl-saki> jle`: Which is?
23:45:58 <iqubic> Cale, Isn't that what happens? You request your program do something, and it give a reponse back to you.
23:46:18 <Cale> data Request = ReadFile FilePath | WriteFile FilePath String | ...
23:46:34 <iqubic> Ah. I see now.
23:46:43 <iqubic> I'm wrong.
23:46:58 <Cale> data Response = Success | Str String | Failure IOError | ... some other misc cases
23:47:11 <Cale> It wasn't terribly pretty
23:47:12 <jle`> Myrl-saki: it's a thin wrapper over ffi calls that can be composed using a monadic/functor/applicative interface
23:47:24 <jle`> huh i guess that's similar to haskell, just with a much smaller RTS
23:47:25 <Cale> https://www.haskell.org/definition/haskell-report-1.2.ps.gz
23:47:59 <Myrl-saki> jle`: I see.
23:48:01 <Cale> That was the last Haskell report which included the old-style I/O. It's in section 7 starting on physical page 69
23:48:03 <Myrl-saki> jle`: Thanks.
23:49:06 <jle`> Myrl-saki: so if you had two data types wrapping an FFI call, you can write a function that returns a sequenced one in a disciplined way
23:49:35 <jle`> i'm not exactly sure how purescript does it, but i think you can look into it; the language is written in haskell
23:49:36 <Cale> Anyway, they arranged it so that you'd write stuff like  readFile fileName (\err -> errorHandler) (\contents -> ...)
23:49:50 <jle`> purescript is nice because the generated code is pretty low-level close to what you'd expect
23:50:00 <jchia> I want to convert tuples of up to 10 elements and for each element that's a String, I want to convert it to Text. How could I go about writing a function for this conversion? Seems like I need a typeclass for the different tuple types that the function can take as input? How do I get String converted to Text but all other types left untouched? Do I need type families?
23:50:17 <Cale> and the upshot of it was very similar to programming directly in that MyIO type I defined before.
23:50:29 <jchia> e.g. (1 :: Int, "abc" :: String) gets converted to (1 :: Int, "abc" :: Text)
23:50:31 <Cale> Except that you were really manipulating these functions of lists.
23:50:41 <jle`> jchia: haskell's type system isn't meant for dealing with big tuples
23:51:01 <jle`> your best bet is to change the source of the tuple to return a reasonable data type instead
23:51:04 <jchia> jle`: I could explicitly define stuff for each tuple size in [1, 10]
23:51:08 <Cale> jchia: You notice that you already know where the Strings occur, and you write a lambda which packs those.
23:51:28 <jchia> Cale: I want to generalize it so that any element in a tuple can be String.
23:51:50 <Cale> What problem are you actually solving?
23:52:00 <jle`> are you just generalizing it for fun?
23:53:23 <Cale> It would be possible to write something that worked on tuples of Typeable-typed things.
23:53:49 <Cale> For each tuple size individually.
23:54:28 <Cale> er...
23:54:35 <Cale> actually, no, nevermind
23:54:49 <jchia> I have an actual use case. That was just a simple example to illustrate the use case. I'm calling Python from Haskell by passing arguments in a tuple, using MessagePack serialization and deserialization (data-msgpack). The legacy Python code takes str, not unicode, so where the Python function takes a str and I have a Text or String in Haskell, I need to convert it into a ByteString, which Data.MessagePack correctly presents as a str to Python. That's why I wa
23:54:53 <Cale> It's possible to make the decisions based on that, but then what's the result type?
23:55:25 <Cale> Message got cut off at "That's why I w"
23:55:42 <jchia> (String & Text gets presented as unicode to Python, and my legacy Python code was written for str, not unicode)
23:55:46 <Cale> But this sounds like a use-case for a new type class.
23:55:51 <jchia> ... That's why I want automatic Text/String->ByteString conversion of tuple elements.
23:56:24 <halogenandtoast> Is there some way to do something like this: take 4 $ [[x, y] | x <- randomRs (0, 9) gen, y <- randomRs (0, 9) gen]
23:56:31 <Cale> However, I don't know why you should need to convert tuples to other tuples
23:56:36 <jchia> requiring the callers in haskell to manually do the conversion is quite a bit of boilerplate and an eyesore.
23:56:45 <halogenandtoast> that gives me two sets of random numbers (in potentially different ranges) from the same random number generator?
23:56:46 <jle`> halogenandtoast: you see the problem, right?
23:56:59 <halogenandtoast> jle`: I know what the problem is, but not the solution
23:57:04 <jle`> halogenandtoast: you can use randomRs for tuples
23:57:11 <jchia> Text/String in Haskell gets passed to Python as unicode. I want to pass str to Python, so I need to pass ByteString, hence, the need for Text/String -> ByteString conversion.
23:57:13 <Cale> jchia: You should just have instances of some class for String and Text which do the right thing.
23:57:19 <jle`> take 4 $ randomRs ((0,0), (9,9) gen
23:57:30 <Cale> jchia: and then you have another instance for tuples which relies on the instances for each of the components
23:57:45 <halogenandtoast> > take 4 $ randomRs ((0,0), (9,9) gen
23:57:47 <lambdabot>  <hint>:1:36: error:
23:57:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:57:52 <halogenandtoast> > take 4 $ randomRs ((0,0), (9,9)) gen
23:57:54 <lambdabot>  error:
23:57:54 <lambdabot>      • Variable not in scope: gen
23:57:54 <lambdabot>      • Perhaps you meant one of these:
23:58:08 <halogenandtoast> of course
23:58:15 <jle`> > take 4 $ randomRs ((0,0), (9,9)) (mkStdGen 10) :: [(Int, Double)]
23:58:17 <lambdabot>  error:
23:58:17 <lambdabot>      • No instance for (Random (Int, Double))
23:58:17 <lambdabot>          arising from a use of ‘randomRs’
23:58:55 <jchia> Cale: Let's say String and Text are instances of Convert. Do other types get to have instances of Convert? If not, when I process the tuple, how do I rely on Convert?
23:59:05 <halogenandtoast> jle`: I'm not sure that's how randomRs works...
23:59:12 <halogenandtoast> randomRs :: (RandomGen g, Random a) => (a, a) -> g -> [a]
23:59:23 <Cale> jchia: Yes, all the types you want to be serialise need instances of the class.
23:59:34 <Cale> jchia: are you using the msgpack package?
23:59:41 <Cale> This class already exists.
23:59:51 <Cale> and it appears to have appropriate instances
