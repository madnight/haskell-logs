00:00:40 <halogenandtoast> Or I guess the problem is that there is no instance of Random for (Int, Int)
00:01:13 <Cale> jchia: https://hackage.haskell.org/package/msgpack-1.0.0/docs/Data-MessagePack-Object.html#t:MessagePack
00:07:06 <jennyrgb> wtf, does "context" have a real meaning or is it some analogous woo woo in tutorials for retards?
00:07:22 <monochrom> Both.
00:07:34 <jennyrgb> the analogies are sometimes so dumb that they cease to have any meaning
00:07:39 <monochrom> But 70% the latter.
00:08:06 <monochrom> But I wouldn't say "retard".
00:08:09 <jennyrgb> does the word "context" mean anything in the following context? fmap (+3) (Just 2)
00:08:23 <monochrom> People are not retard. People are more sinister than that. Self-deception.
00:08:35 <monochrom> No.
00:08:59 <monochrom> Maybe and [] are better off with the container analogy.
00:08:59 <cocreature> the meaning of context depends on the context
00:09:10 <tsahyt> context is context-sensitive
00:09:20 <jennyrgb> I never trust texts that have a lot of exclamation marks in them
00:09:29 <tsahyt> jennyrgb: there are all sorts of analogies for that. context, environment, boxes, tortillas... you name it.
00:09:42 <monochrom> Reader and State are the ones that benefit from the context analogy.
00:09:55 <monochrom> And Writer basically elludes both.
00:10:13 <tsahyt> for reader I prefer "environment"
00:10:31 <jennyrgb> something about boxes and contexts regarding functors.. and a lot of exclamation marks and "bam!" "boom!"
00:10:42 <monochrom> And IO is like "none of the above".
00:10:59 <jennyrgb> and instead of writing out actual numbers, they have numbers hand drawn with happy faces and different colors
00:11:07 <monochrom> And lastly, free monads are like "all of the above".
00:11:31 <tsahyt> jennyrgb: Functors are rather simple though. fmap takes a function a -> b and gives you a function f a -> f b. and on the type level, f :: * -> * takes a type and gives you another.
00:11:50 <tsahyt> and it all obeys the laws that fmap id = id, and fmap f . fmap g = fmap (f . g)
00:11:57 <tsahyt> and that's really all there is to it
00:12:29 <jennyrgb> functors in general are functions that returns functions based on a parameter
00:12:32 <tsahyt> so the f (on the type level) maps types to types, and fmap takes functions and maps them to functions under f.
00:12:35 <monochrom> This is a strange event. Just 13-14 hours ago, we had the opposite conversation, people were claiming "inaccurate fuzzy fast intuition is so helpful!"
00:12:57 <tsahyt> and the mapping preserves structure
00:13:31 <jle`> halogenandtoast: yes, that was the problem, heh
00:13:39 <jennyrgb> monochrom: only if you know what you're doing. you learn the real thing first and then make up simplified models in your head to process it faster. But you don't teach it in the first place with bullshit analogies with talking cats and dogs
00:14:03 <tsahyt> I for one am rather fond of the burrito april fools paper
00:14:05 <jennyrgb> "hi, I'm a higg bozon, I can speak and I am a gat... here's a cheese and it represents a quark" WTF! Kill yourself, do it.
00:14:08 <monochrom> And unsurprisingly, our #1 prosecutor of nitpickers stroke again with "you hate it because you are over-nitpicking".
00:15:11 <tsahyt> monochrom: I think both have value. the problem I have with fuzzy fast intuition is that some are looking for other people's intuitions, and that never works well
00:15:58 <Hakim-OP> burrito for the hungry mathematician
00:16:13 <tsahyt> once you've build your own intuition about a concept, you also know where it fails. when you try to mirror that of another, say through some box analogy, you simply don't know where it stops being useful and starts being outright wrong
00:16:26 <tsahyt> Hakim-OP: still my favorite april fools paper
00:17:05 <monochrom> My bottomline is predictive power. In the same sense as in science. The predictive power of your model.
00:17:29 <cocreature> is "-pgmlc clang" a thing that’s supposed to work? it fails because of unsupported options for me
00:17:52 <jchia> Cale: The problem is that I want to convert, say, (1 :: Int, "abc" :: Text) to (1 :: Int, "abc" :: ByteString) before I give it to Data.MessagePack.
00:18:35 <tsahyt> :t fmap @(Int,a)
00:18:37 <lambdabot> error:
00:18:37 <lambdabot>     Pattern syntax in expression context: fmap@(Int, a)
00:18:37 <lambdabot>     Did you mean to enable TypeApplications?
00:18:40 <tsahyt> hmpf
00:18:49 <Myrl-saki> jle`: Should I consider having an interpreter for my first programming language?
00:18:50 <MarcelineVQ> she doesn't to type applications
00:19:15 <MarcelineVQ> that's not a valid type application anyway though
00:19:26 <monochrom> If you have a model that gets you correct code and correct predictions for, say, both Maybe and [], then it is a fairly valuable model, and you get to say "I haven't treated State yet and I know the limitation of my model".
00:19:32 <tsahyt> MarcelineVQ: @((,) Int)?
00:19:42 <tsahyt> I still have to get the hang of that
00:19:43 <Myrl-saki> Hmmm. If i'll be writing an interpreter, that'd still be compiling.
00:19:57 <Myrl-saki> jle`: Nyeh, just ignore that.
00:20:12 <monochrom> That is a good sense of "inaccurate fast" model. But it is not fuzzy, it actually makes precise predictions.
00:20:13 <MarcelineVQ> tsahyt: yeah @((,) Int)  should show what you were after
00:20:38 <monochrom> I don't think fuzzy has value until you are broadly experienced.
00:21:18 <cocreature> ah nvm pgmlc is the llvm compiler and not the C compiler
00:22:34 <MarcelineVQ> cocreature: ah okay, I was wondering if there was some sort of other options you had to pass to 'enable llvm' or something that it wanted
00:24:36 <jle`> halogenandtoast: any more compplicated and it might be easier to use MonadRandom's interface, which wraps over System.Random
00:25:48 <jle`> halogenandtoast: then you can use (,) <$> replicateM 10 (getRandomR (0,9)) <*> replicateM 10 (getRandomR (0,9))
00:26:07 <jle`> basically those compositional combinators we all know and love
00:28:18 <Cale> jchia: But why do you want to do that? Is it choosing the wrong encodings for some types?
00:28:50 <Cale> jchia: You might just want to define your own version of the type class with your own instances.
00:29:13 <jchia> when I have a String/Text, I want to convert it to a ByteString first before giving it to Data.MessagePack so that when it goes to Python, it gets presented as a str instead of unicode
00:30:07 <jchia> String/Text on the Haskell side gets presented as unicode, not str, to the Python side
00:30:24 <Cale> jennyrgb: fwiw, I've never managed to figure out what people mean when they say "context" with respect to functors.
00:30:55 <quchen> jchia: Data.Text.Encoding
00:31:44 <Cale> jchia: Yeah, I think your problem is just that the Text and String instances for that class aren't doing the thing you want.
00:31:49 <quchen> jchia: Text does not have a ByteString representation and more than a picture has. Text is abstract text, and you can choose to represent it in different ways as bytes, just like pixels are coloured things that you can choose to represent via JPEG, PNG, …
00:31:57 <quchen> s/and/any/
00:32:15 <Cale> quchen: I think jchia wants to ignore the problem of characters outside ASCII
00:32:43 <jchia> quchen: I'm trying to do the conversion automatically for tuple elements, e.g. (1 :: Int, "abc" :: Text) -> (1 :: Int, "abc" :: ByteString), ("xyz" :: String, False) -> ("xzy" :: ByteString, False)
00:33:04 <jennyrgb> Cale: I just stopped reading the text when a bunny jumped into a hat.. I have no idea where they were going with that.
00:33:05 <quchen> Cale: Excellent! .Encoding has a function for this as well. ;-)
00:33:22 <jchia> quchen: My use case excludes non-ASCII.
00:33:23 <halogenandtoast> jle`: I might have missed an intermediate message, what do you mean by more complicated?
00:34:07 <quchen> jchia: Wonderful! Then use UTF-8, which is compatible with ASCII.
00:34:33 <quchen> Unless you want to save that bit per character.
00:34:36 <Cale> quchen: Right, jchia would just want to use *that* instead of whatever it is that the MessagePack instance is doing.
00:34:38 <monochrom> Python supports UTF-8 too.
00:34:40 <jchia> This is all about the python side. The Python legacy code expects str, so I want to make sure I give it a str.
00:35:11 <monochrom> What does "str" mean, at the metal level?
00:35:23 <jchia> monochrom: Python has str & unicode types
00:35:40 <jchia> unicode is the standard string type in Python 3. In Python 2, str is the standard string type.
00:35:53 <jchia> ...although Python 2 also has unicode.
00:36:04 <Cale> jchia: So I think the answer to your problem is just to make a new type class which mimics the MessagePack class closely, but which handles these types the way you actually want them handled.
00:36:42 <Cale> That, or make a newtype that can have the appropriate instances
00:36:46 <Cale> (of MessagePack)
00:38:06 <jle`> halogenand
00:38:26 <jle`> halogenandtoast: more complicated sequences of getting random stuff
00:38:39 <jle`> than just simple uses of randomRs
00:40:01 <halogenandtoast> jle`: Does that mean I should make a Random instance for (Int, Int) ?
00:40:26 <jle`> orphan instances are usually a bad idea
00:40:42 <jle`> replicateM 5 (getRandomR (0,9)) will get you 5 randomR's, from the MonadRandom library
00:40:59 <jle`> and you can use liftA2 zip to combine two such lists together
00:41:19 <jle`> hm, or even
00:41:29 <jchia> Cale: The msgpack package you linked to seems to be unmaintained. Hence, I'm using the data-msgpack package.
00:41:38 <halogenandtoast> right: I like (,) <$> replicateM 10 (getRandomR (0,9)) <*> replicateM 10 (getRandomR (0,9)) as a solution but I'm not in a monad at the moment.
00:41:43 <jle`> replicateM 5 ((,) <$> getRandomR (0,9) <*> getRandomR (0,9))
00:41:48 <Cale> jchia: ah, okay, let me look at that one
00:41:57 <jle`> i'm talking about using the Rand monad from MonadRandom
00:41:58 <monochrom> IIRC (Int,Int) is already a Random instance.
00:43:16 <jle`> we tried earlier and it doesn't seem like there was
00:43:37 <jle`> > take 4 $ randomRs ((0,0), (9,9)) (mkStdGen 10) :: [(Int, Int)]
00:43:39 <lambdabot>  error:
00:43:39 <lambdabot>      • No instance for (Random (Int, Int))
00:43:39 <lambdabot>          arising from a use of ‘randomRs’
00:43:44 <jchia> Cale: If I adapt MessagePack but handle String & Text differently, like you said, isn't that a lot of code to copy? Isn't it simpler to convert the String & Text elements in the tuples directly?
00:44:09 <Cale> jchia: Not if you want to handle that generically.
00:44:44 <Cale> jchia: Think about it this way: what's the type of the function you want to write?
00:45:06 <halogenandtoast> It would have been nice and easy if there was an instance for that.
00:45:35 <MarcelineVQ> halogenandtoast: if it'll make a big difference for you you can create the instance for your use
00:45:42 <jchia> I don't know. If I can somehow put String, Text and everything else in a type class, say Convert, and then be able to get a type ConvertTarget out of each Convert instance type, then I think I'm golden.
00:45:55 <jchia> Cale: Would that be type families?
00:46:06 <Cale> jchia: btw, version 0.0.9 of data-msgpack looks awful
00:46:12 <jle`> if it's for an exectuable, oprhan instances aren't too bad
00:46:13 <Cale> 0.0.8 looks more sensible
00:46:15 <halogenandtoast> Maybe I'm going about this the entirely wrong way. Any suggestions for creating a minesweeper board with random mines?
00:46:26 <jle`> it's when they are in libraries that you should try to avoid them
00:46:27 <halogenandtoast> That's the problem I'm trying to solve
00:46:29 <jchia> Cale: I haven't looked closely. What's wrong with it?
00:46:36 <Cale> https://hackage.haskell.org/package/data-msgpack-0.0.9
00:46:41 <Cale> https://hackage.haskell.org/package/data-msgpack-0.0.8
00:46:48 <Cale> They didn't expose most of the modules
00:46:56 <jle`> halogenandtoast: you can create `Rand g a` that generates a random tile, and then replicateM it or sequence it across all your tiles
00:47:15 <Cale> So you can't even write instances of the MessagePack class in 0.0.9, since the class itself isn't exported
00:47:48 <Cale> (That'll also be super annoying because you won't be able to write the type signatures of functions which are polymorphic with MessagePack constraints)
00:48:20 <halogenandtoast> jle`: What is Rand g a?
00:48:52 <halogenandtoast> Ah I think I found it: https://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html#t:Rand
00:48:53 <jle`> halogenandtoast: a computation tha tproduces a random 'a', using seed of type g
00:48:57 <jchia> Cale: I think it's just a haddock problem. In the code, there's still Data.MessagePack.Class, which experts MessagePack
00:49:11 <jchia> 'exports'
00:49:15 <Cale> It's a cabal packaging problem
00:49:28 <jle`> s/a seed/seeds
00:49:29 <Cale> https://hackage.haskell.org/package/data-msgpack-0.0.9/src/data-msgpack.cabal
00:49:43 <Cale> Only 3 of the modules are listed under "exposed-modules"
00:49:55 <Cale> The others are still there, but not exposed.
00:49:59 <jchia> Cale: You're right, only three modules are exported with 'exposed-modules'. Data.MessagePack.Class is 'other-modules'
00:50:59 <jle`> halogenandtoast: Rand is a basic wrappver over the functionality of System.Random to give you the ability to sequence/compose random generation with your favorite functor/applicative/monad combinators like replicateM/traverse/mapM
00:51:44 <jchia> Cale: Maybe they just want to stick to the official MessagePack spec and prevent users from adding their own types.
00:52:28 <halogenandtoast> jle`: Seems neat, going to take me a bit to figure out how to use it
00:52:44 <jle`> halogenandtoast: gerAndom :: Rand g a
00:52:51 <halogenandtoast> I had been using the structure EmptyGame Int Int StdGen so I have a generator width and height packaged into 1
00:52:56 <jle`> so to get two random things, you can do (,) <$> getRandom <*> getRandom
00:53:21 <halogenandtoast> so I want to somehow do something like (getRandomR (0, height), getRandomR (0, width))
00:53:26 <jle`> to get a random three-ple, do x <- getRandom; y <- getRandom; z <- getRandom; return (x,y,z)
00:53:37 <jle`> a list of random things, replicateM 10 getRandom
00:53:51 <jle`> just your typical friendly neighborhood monadic interface :)
00:55:14 <jennyrgb> what is a concrete type?
00:55:37 <jle`> depending on who you ask, it's a term that is 'considered harmful'
00:55:46 <jle`> because there is no accepted meaning
00:55:52 <jle`> it means whatever the person who is using it intends for it to mean
00:56:46 <Cale> I'll risk a definition: A concrete type is a type expression consisting entirely of type constructors and applications.
00:57:31 <opqdonut> of kind *?
00:57:32 <Cale> But I don't know if that's the sense that it got used in whatever it is that you're reading :)
00:57:38 <Cale> Not necessarily of kind *
00:57:50 <Cale> But maybe in some cases you'd want that too.
00:57:59 <jle`> so...a monomorphic type, you mean?
00:59:11 <Cale> It's a little more specific than that, since it has to do with the form in which the type is written.
01:00:35 <halogenandtoast> fg
01:00:37 <cocreature> I would have expected a concrete type to be the opposite of an abstract type
01:00:47 <cocreature> i.e. a type where the constructors are not hidden
01:01:12 <Cale> Oh, that's a completely different sense of the term, and maybe more deserving :)
01:01:41 <cocreature> but I don’t think I’ve ever heard that term used so maybe it’s best to keep it that way :)
01:01:51 <cocreature> and use something like “monomorphic type” or other more specific terms
01:02:15 <jle`> some people use 'concrete type' mean 'fully saturated type', as in, non-*
01:02:33 <jle`> um, as in, *
01:02:35 <jle`> -kinded
01:02:58 <Cale> Well, a fully saturated type synonym might produce a type of kind other than *
01:03:52 <quchen> type Foo = Monad
01:04:06 <quchen> Fully saturated, not kind *.
01:04:07 <jle`> so i guess, s/as in/or, alternatively
01:04:10 <Cale> Or less trivially perhaps, you can have stuff like  type Foo a = State [a]
01:04:11 <monochrom> Oh hai quchen long time no see
01:04:16 <quchen> monochrom: Likewise!
01:04:43 <jle`> or even type Foo a = 5
01:04:53 <Cale> heh
01:07:23 <jle`> someone should make a venn diagram of overlapping and mutually exclusive ways people use 'concrete type'
01:09:07 <quchen> »inhabited type« should work fine in Haskell, but then people would start arguing about Void
01:09:39 <opqdonut> hmm
01:09:42 <opqdonut> [a] is also inhabited
01:09:44 <quchen> Clumsy as it sounds, »type of kind *« is probably as good as it gets
01:09:55 <quchen> [a] has kind *
01:09:57 <opqdonut> right, in that sense
01:10:19 <opqdonut> Cale had a definition that ruled out type variables, and that's the sense I've seen it used in
01:11:47 <quchen> Cale: Is (Int -> Int) a concrete type by your definition? I guess it depends on whether (->) is considered a constructor
01:12:30 <opqdonut> why wouldn't it be a constructor?
01:12:39 <opqdonut> it just has funny syntax
01:13:04 <quchen> (->) is somewhat primitive
01:13:22 <monochrom> Then again, Int is somewhat primitive too.
01:13:31 <quchen> -> is primitiver ;-)
01:13:40 <opqdonut> if (Int -> Int) is not concrete, how about (Int,Int)?
01:13:45 <opqdonut> tuples are magic too
01:14:02 <quchen> Not really. They have their own syntax, but are not otherwise special.
01:14:44 <quchen> monochrom: Can you define Int in terms of -> somehow?
01:15:03 <quchen> The other way round it’s not too hard (but fairly inefficient, using Boehm-Beraducci etc)
01:15:46 <monochrom> I don't know.
01:15:56 <monochrom> But you can define -> in terms of Int?!
01:16:07 <quchen> I don’t know
01:16:15 <quchen> Well, not Int, but maybe Nat?
01:16:47 <jle`> if you can define Nat then you can define Int
01:16:49 <quchen> If Gödel numbering is the simplest way I’ll count that as a »no« ;-)
01:17:01 <jle`> hehe
01:17:16 <monochrom> Then I think you have the order flipped. Boehm-Beraducci is when you define Nat in terms of ->
01:17:39 <lpaste> halogenandtoast pasted “Minesweeper.hs” at http://lpaste.net/354475
01:17:42 <halogenandtoast> jle`: I went with something like that
01:17:46 <halogenandtoast> I'm still not happy with it
01:17:50 <quchen> Oh yes, I flipped that sentence
01:17:51 <halogenandtoast> the instance bothers me
01:18:01 <halogenandtoast> But I don't get how to use MonadRandom here.
01:18:15 <halogenandtoast> since I'm not currently in a Monad
01:18:36 <jle`> you can use Rand to "build" your StdGen -> (a, StdGen)
01:18:48 <monochrom> -> in terms of Nat amounts to writing your own Haskell interpreter and you use Nat as your code format.
01:19:12 <monochrom> It can be done but I don't want to.
01:19:20 <halogenandtoast> jle`: my guess is that `a` is `Position` or `(Int, Int)`
01:19:27 <quchen> monochrom: Sorry, only constructive proofs allowed :-þ
01:20:07 <lpaste> jle` annotated “Minesweeper.hs” with “Minesweeper.hs (annotation)” at http://lpaste.net/354475#a354476
01:20:19 <jle`> but even better would be to make initGame a Rand
01:20:19 <monochrom> Because it reminds me of the nightmare of Dana Scott's "let's use the powerset of Nat to be the semantics of System F"
01:20:39 <halogenandtoast> jle`: but does that guarantee that the mines will be unique?
01:20:48 <lpaste> jle` annotated “Minesweeper.hs” with “Minesweeper.hs (annotation) (annotation)” at http://lpaste.net/354475#a354477
01:21:00 <quchen> Speaking of constructive proofs: why are there infinitely many primes? Doesn’t this require showing how to construct a prime from a predecessor prime?
01:21:01 <jle`> halogenandtoast: it doesn't guaruntee it, but it makes it very very likely
01:21:33 <monochrom> Euclid's proof was not constructive, yes.
01:21:55 <quchen> Hm, I remember it’s easy to transform into a constructive one
01:22:09 <quchen> By showing that ab+c+d
01:22:09 <monochrom> (A dead horse beaten eternally by a crackpot in sci.math)
01:22:19 <quchen> Hah.
01:22:22 <lieven> it can be made constructive fairly easily. given n the largest prime so far, factorize n!+1 :)
01:22:46 <monochrom> (He called himself Archimedes Plutonium.)
01:22:51 <jle`> halogenandtoast: that's how the Rand monad works
01:23:01 <quchen> Well, I guess the crux is realizing that the proof does not have to construct all primes in order, but to construct some ascending sequence
01:23:07 <jle`> halogenandtoast: replicateM 5 x will take 5 random samples from x
01:23:10 <lieven> or somewhat more practical, there's a primality test in P and a construtive proof of Bertrand's postulate
01:23:15 <halogenandtoast> jle`: So I would need to call evalRandT where I call initGame from?
01:23:19 <jle`> halogenandtoast: yes
01:23:27 <monochrom> shachaf may have written such a proof.
01:23:28 <halogenandtoast> I think that was what I was missing
01:23:34 <halogenandtoast> (probably among other things)
01:23:37 <jle`> halogenandtoast: you can also just "exit" immediately
01:23:40 <jle`> like what i wrote initially
01:23:46 <halogenandtoast> Right
01:24:05 <jle`> Rand & co. are just a way of building a StdGen -> (a, StdGen), but in nice ways
01:24:31 <halogenandtoast> Right, but wrapping the StdGen updates/returns
01:24:34 <halogenandtoast> I assume
01:24:42 <monochrom> I think lieven's idea works.
01:24:42 <halogenandtoast> s/but/by/
01:24:48 <jle`> halogenandtoast: yup, the key is in its Applicative instance
01:24:58 <jle`> at least for replicateM
01:25:16 <jle`> f <*> x will "run" f, then get the resulting generator, and then feed that to x
01:25:27 <jle`> and pop out that final generator at the end
01:25:30 <halogenandtoast> Yeah this is nice, and I think I better understand how to use it, but it doesn't seem like it would solve my problem, since I want to guarantee x unique mines.
01:25:31 <jle`> so it chains usages of the seed
01:25:41 <halogenandtoast> Still grateful for the explanation and example though!
01:25:48 <halogenandtoast> s/grateful/extremely grateful/
01:26:07 <jle`> halogenandtoast: it doesn't guaruntee x unique mines, it just generates 9 independently sampled mines
01:27:01 <halogenandtoast> Is there a way to generate infinite independently sampled mines?
01:27:32 <jle`> it depends on how you want to use it
01:27:50 <halogenandtoast> take 9 $ nub $ <gen infinite list of random mines>
01:28:47 <jle`> i believe that evalRandT is lazy enough for that to work
01:30:01 <bollu> "let's use the powerset of Nat to be the semantics of System F" <- what?
01:30:05 <bollu> monochrom: enlighten me
01:30:20 <jle`> *evalRand
01:30:42 <jle`> halogenandtoast: yes, it works for me
01:31:09 <jle`> take 10 . nub $ evalRand (sequence getRandom) gen
01:31:23 <jle`> um, sequence (repeat getRandom)
01:31:42 <jle`> just don't try to get the resulting generator ;)
01:33:37 <halogenandtoast> jle`: I'll try it out, this problem was much harder than I imagined it to be.
01:35:05 <jle`> halogenandtoast: alternatively, you might just want to shuffle the set of positions and take the first 9 items
01:35:50 <jle`> halogenandtoast: you can use uniform to shuffle
01:35:54 <jle`> and you can do it all inside Rand
01:37:14 <lpaste> jle` annotated “Minesweeper.hs” with “Minesweeper.hs (annotation) (annotation) (annotation)” at http://lpaste.net/354475#a354478
01:38:46 <halogenandtoast> jle`: I'm assuming uniform doesn't ensure uniqueness either :p
01:38:55 <halogenandtoast> oh wait it will in this case.
01:39:03 <jle`> it shuffles a list
01:39:07 <halogenandtoast> right
01:39:39 <halogenandtoast> jle`: actually...
01:39:40 <halogenandtoast> uniform :: (MonadRandom m, Foldable t) => t a -> m a
01:39:54 <halogenandtoast> it returns a uniform element of the list, not a shuffled list
01:40:33 <jle`> oh :o
01:41:09 <jle`> hm
01:41:13 * monochrom has a cunning plan to fix this! Build the list of all permutations. Uniformly pick one.
01:41:16 <halogenandtoast> I usually just write shuffle xs = map snd $ sortOn fst $ zip randomRs xs
01:41:19 <halogenandtoast> jle`: ^^
01:41:34 <halogenandtoast> well with a gen passed in
01:42:00 <jle`> yeah.  it'd be neat if the module had a verison already
01:42:18 <halogenandtoast> jle`: There's https://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
01:44:33 <halogenandtoast> but I feel like my method is Good Enough™
01:46:18 <jle`> it typechecks, so ship it
01:47:14 <Cale> quchen: It would be.
01:53:08 <halogenandtoast> jle`: thanks for all the help today, you're awesome!
01:53:23 <jle`> no problem!
01:53:45 <jle`> if you don't ever use any other randomness in the program, btw, then it's fine to just have initGame return not-in-Rand
01:56:10 <boxscape> I started using Lens.Simple today - can someone tell me why `zoom' only works with the strict version of StateT? Is this different in Control.Lens?
01:56:24 <boxscape> (I haven't used Control.Lens before either)
01:57:56 <Cale> It's not the case for Control.Lens
01:58:11 <Cale> But possibly that's one of the things which got simplified
01:58:17 <boxscape> ok, I see
01:58:39 <boxscape> most things in Lens.Simple regarding state just use MonadState
01:59:04 <Cale> Control.Lens has a Zoom type class which explains how the type of monad changes when you zoom
01:59:31 <boxscape> ok
02:17:43 <jennyrgb> Maybe is a type constructor. What does it return?
02:20:39 <Iceland_jack> (Maybe a) is a type for some type (a)
02:20:49 <Iceland_jack> The kind of Maybe: Maybe :: Type -> Type
02:22:20 <tdammers> if you will, Maybe takes a type and returns a type
02:22:33 <tdammers> * -> *
02:24:34 <Iceland_jack> jennyrgb: It may help to look at the kind of Either as well (Either :: Type -> Type -> Type), I write 'Type' instead of '*' but they mean the same
02:25:08 <Iceland_jack> Partially applying the Either type constructor to Int gives us (Either Int) of kind (Either Int :: Type -> Type)
02:26:44 <jle`> jennyrgb: and applying 'Maybe' to 'Int' gives you 'Maybe Int'
02:27:28 <Iceland_jack> @kind Int
02:27:30 <lambdabot> *
02:27:31 <Iceland_jack> @kind Maybe
02:27:33 <lambdabot> * -> *
02:27:34 <Iceland_jack> @kind Maybe Int
02:27:35 <lambdabot> *
02:31:02 <jennyrgb> god damn it.. I used baking soda instead of vanilla sugar powder, this taste like shit!
02:33:33 <halogenandtoast> jennyrgb: I have that problem with Monads all the time.
02:33:47 <ongy> typesafe baking?
02:33:53 <geekosaur> one could only wish...
02:34:26 <halogenandtoast> That would definitely keep my wife from making non-sensical substitutions
02:35:02 <halogenandtoast> e.g. using coconut flour instead of flour when baking things that depend on chemical reactions.
02:35:10 <ongy> I wonder if indexed monads would be a good way to model this
02:35:35 <halogenandtoast> I actually work for a recipe sharing website, if we could make this a thing...
02:35:36 * geekosaur tries to use differently shaped containers, pattern matching seems to work well enough as a "type system"
02:35:56 <geekosaur> shape+size
02:36:08 <geekosaur> but wht works for me doesn't always work for others...
02:36:20 <ongy> so your recipies are cut out boards with the right holes?
02:37:13 <geekosaur> just the ingredients. I substitute a lot, but deliberately (typeclasses?)
02:38:27 <halogenandtoast> geekosaur: yes typeclasses
02:38:47 <halogenandtoast> I am the highest authority for answering that question.
02:39:05 <jennyrgb> I am god, I have the ultimate authority
02:39:46 <geekosaur> well, not quite, unless you want to use a dependently-kinded system :) some things just should not be mixed, however well they might substitute individually
02:40:27 <halogenandtoast> geekosaur: the answer is more typeclasses
02:40:57 <halogenandtoast> class CanBeMixedWithFlour where
02:41:45 <halogenandtoast> Just remember, with the correct encoding we can represent the current state of the universe in a single bit...
02:42:43 <Iceland_jack> jennyrgb: Protip, only make lemon cheesecakes
02:42:46 <Iceland_jack> they are delicious
02:43:12 <tdammers> If the first bit is 0, then the message represents the single test case; if it is 1, then the remaining bits encode some other case that is not the test case
02:47:39 <ongy> a testcase of the universe?
02:47:44 <tdammers> yes
02:47:45 <tdammers> of course
03:35:57 <elvisren> I have a question on the behaviour of "bracket" in Control.Exception. from the definition I think the "after a" will be called twice when "thing a" raises exception. But when I write test code it is called only once. Is there anything special I have overlooked? the function definition is here: http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Control.Exception.Base.html#bracket
03:41:09 <merijn> elvisren: After is not called twice, because onException doesn't stop the exception, it rethrows after running the handler
03:41:38 <merijn> elvisren: So either it throws, the handler from onException runs and the 2nd sequel is skipped. Or there's no exception and only the 2nd one runs
03:43:03 <elvisren> #
03:44:36 <jennyrgb> 1 + f a b, how's the precidence working here?
03:44:51 <merijn> jennyrgb: 1 + ((f a) b)
03:44:55 <jennyrgb> precedence*
03:45:03 <merijn> jennyrgb: Function application has higher precedence than ALL operators
03:45:57 <Iceland_jack> (f x + g y) becomes : (f x) + (g y)
03:46:30 <jennyrgb> ok thanks :)
03:47:11 <jennyrgb> what about f1 f2 a b,  is f1 getting f2 as an argument, or is the return of (f2 a b) an argument of f1?
03:47:40 <merijn> Function application is left associative, so: "((f1 f2) a) b"
03:47:42 <Iceland_jack> It's left associative, so ((f1 f2) a) b
03:47:53 <Iceland_jack> so the first argument to f1 is f2
03:48:05 <Iceland_jack> > ((+) 10) 5000
03:48:07 <lambdabot>  5010
03:48:39 <jennyrgb> ok ty
03:49:06 <quinor> hey, quick question: why isn't next_id :: MonadState (Sequence.Seq a) m => m Int valid type signature?
03:49:37 <quinor> (I import qualified Data.Sequence)
03:49:48 <Iceland_jack> Do you have FlexibleContexts on?
03:50:03 <Iceland_jack> Enabled in GHCi: (>>> :set -XFlexibleContexts)
03:50:23 <Iceland_jack> :t undefined :: MonadState [a] m => m Int
03:50:25 <lambdabot> MonadState [a] m => m Int
03:51:20 <quinor> Iceland_jack: nope, should I? Can I enable it by source macroes? Or somehow in ghci?
03:51:40 <Iceland_jack> in GHCi you enable it with the command (:set -XFlexibleContexts)
03:51:55 <quinor> thanks!
03:52:00 <Iceland_jack> in a source file you enable it by adding {-# Language FlexibleContexts #-} to the TOP of your file
03:52:15 <elvisren> merijn: thanks for the explanation. I scan the doc again. It looks the document need to be improved. "bracket" use "onException", and "onException" is documented using "finally", which is documented using "bracket". for all these three functions, only "bracket" mentioned re-thrown exception, so it is a little confusing.
03:52:21 <Iceland_jack> The error message should tell you to enable the FlexibleContexts extension
03:52:30 <Iceland_jack> something else may be amiss
03:52:34 <Iceland_jack> who knows
03:52:39 * Iceland_jack starts drinking
03:52:59 <quinor> Iceland_jack: thank you VERY much!
03:53:28 <Iceland_jack> You're very welcome :)
03:54:29 <quinor> Iceland_jack: it did tell me to do that btw, but it did so on a couple of other ocasions when it was totally wrog so I thought it'll be better to ask
03:55:32 <merijn> elvisren: the bracket docs already say that it 1) frees the resource and 2) reraises exceptions, no? So the only reason people would get confused is if they look at the source, without looking at any other bit of the source, like onException
03:57:05 <geekosaur> quinor, part of the reason it's an extension is because it can indicate a bug in your type. (and part is that the people who designed Haskell wanted to make it easier to implement. although ghc as the de facto reference implementation kinda clobbers that...)
03:57:36 <quinor> can I turn it on for a _single_ declaration?
03:57:51 <merijn> geekosaur: I think it's mostly just "Haskell report forgot to specify"
03:58:12 <merijn> geekosaur: Because I remember Cale telling me that GHC allowed FlexibleContexts for years before someone pointed out the report didn't allow it
04:01:45 <Cale> The Haskell report does specify that restriction, from what I recall. It's just that GHC didn't explicitly check it.
04:02:59 <jennyrgb> data Triggered = Triggered {amount::Int, what::String}  what is this?
04:03:17 <Maxdamantus> jennyrgb: a record type.
04:04:51 <merijn> Cale: Yeah, I know the report specifies it, I meant that "no one working on GHC even realised the report was that restrictive"
04:12:14 <stphrolland> I'm starting with Pipes. A bit lost between tutorials available on the net and documentation.  This is the code I have so far which cannot compile, lots of compilation errors I don't understand.  The line that don't compile is line 19, runEffect $ ... http://lpaste.net/354479
04:12:16 <stphrolland> What I want to achieve: a handler that receives Command object and outputs Command object. There will be some IO side effect performed, but for the moment if it only returns the incomming command as is, it would be sufficient for my understanding better the Pipes / Pipes.Network / Pipes.Binary libs.
04:13:03 <stphrolland> How would you write the runEffect line I whave written wrongly.
04:21:44 <Cale> stphrolland: It might help if you add the error to your paste
04:24:13 <Cale> stphrolland: Are you sure you don't want fromSocket rather than recv?
04:24:39 <stphrolland> I have updated the paste with compilation errors: http://lpaste.net/354479
04:25:02 <Cale> Try using fromSocket instead of recv
04:26:47 <stphrolland> okay, I'm gonna search for it on hackage
04:26:55 <Cale> https://hackage.haskell.org/package/pipes-network-0.6.4.1/docs/Pipes-Network-TCP.html
04:27:16 <Cale> How did you write the code which you have? :)
04:27:59 <stphrolland> From my partial understanding of the docs and the tutorial I found. 
04:28:04 <Cale> ah, okay
04:28:26 <Cale> Well, I think you probably want fromSocket and toSocket, which get you a Producer and Consumer respectively
04:29:25 <Cale> You can send and recv inside the action given to runEffect, but they only do what they normally do in IO, get a single chunk of data
04:29:30 <Cale> (or send it)
04:30:28 <Cale> You could, for instance, write
04:31:01 <Cale> do x <- PNT.recv connectionSocket pageSize; runEffect $ yield x >-> ...
04:31:04 <Cale> er
04:31:11 <Cale> that's not what I meant to write
04:31:22 <Cale> runEffect $ do x <- PNT.recv connectionSocket pageSize; yield x >-> ...
04:31:24 <Cale> yeah
04:31:41 <Cale> However, that would only get the one chunk and ship that along
04:32:09 <Cale> So you really probably want fromSocket, which will get many chunks
04:32:10 <Cale> https://hackage.haskell.org/package/pipes-network-0.6.4.1/docs/src/Pipes-Network-TCP.html#fromSocket
04:32:21 <Cale> It might be helpful to look at its implementation in terms of recv
04:33:08 <stphrolland> I have updated with fromSOcket in the code. Same kind of compilation errors. http://lpaste.net/354479
04:33:09 <Cale> It's just a loop which repeatedly runs recv, and yields the resulting chunk of bytes, until it doesn't get any more.
04:34:01 <Cale> ah I see
04:34:14 <Cale> Well, look at the type of decode from Pipes.Binary
04:34:16 <stphrolland> What seems to be blocking first here, is the encode/decode stage from ByteString to Command. noe ?
04:34:19 <Cale> decode :: (Monad m, Binary a) => Parser ByteString m (Either DecodingError a)
04:34:27 <Cale> It's apparently something called a Parser
04:34:47 <Cale> https://hackage.haskell.org/package/pipes-parse-3.0.4/docs/Pipes-Parse.html#t:Parser -- the Parser type is defined using StateT
04:35:46 <Cale> https://hackage.haskell.org/package/pipes-parse-3.0.8/docs/Pipes-Parse.html#v:parsed
04:35:56 <Cale> is apparently how we run such a Parser
04:36:06 <Unhammer> Pied Parser
04:36:09 <stphrolland> okay, that makes sense
04:36:20 <Cale> parsed :: Monad m => Parser a m (Either e b) -> Producer a m r -> Producer b m (e, Producer a m r)
04:37:01 <Cale> So we give it decode, and the Producer we'd like to consume data from, and it gives us a Producer for the parsed values.
04:38:13 <Cale> So something like  parsed PipesBinary.decode (PNT.fromSocket connectionSocket pageSize)
04:40:50 <boxscape> "The function `zoom' is applied to three arguments, but its type has only four" good job ghc -.-
04:41:08 <Cale> hah
04:41:37 <Cale> Yeah, sometimes it messes up that error message a bit.
04:41:40 <opqdonut> hey who ate my curry?
04:41:43 <opqdonut> :)
04:50:38 <ertes> boxscape: it didn't say which order it was using
04:52:02 <boxscape> ertes: I'm not sure what you mean by that
04:52:53 <ertes> > Down 4 < Down 3
04:52:56 <lambdabot>  True
04:53:02 <boxscape> ah, yeah...
04:53:31 <ertes> but my favourite GHC bug is still the one that deleted your source file when you had a type error
04:53:56 <boxscape> :D
04:54:56 <boxscape> I'm almost surprised that can even happen, given that files can be opened in different modes
04:55:08 <boxscape> seems like the sort of thing that haskell would be good at preventing
04:55:25 <ertes> Blah.hs:50:4: error: You suck.  Try again from the top, idiot!
04:57:09 <ertes> i don't know how it happened…  i'm guessing that it picked the wrong file for some reason
04:59:05 <Iceland_jack> > sortOn Down "Hello!"
04:59:06 <lambdabot>  "olleH!"
04:59:44 <jennyrgb> what exactly is one higher order function?
04:59:49 <ertes> @src sortOn
04:59:49 <lambdabot> Source not found. Maybe you made a typo?
05:00:01 <Iceland_jack> sortOn f = sortBy (comparing f)
05:00:10 <boxscape> jennyrgb: a function that either takes a function as an argument or returns a function
05:00:12 <ertes> lambdabot: you're surprisingly nice today
05:00:21 <boxscape> @src sortOn
05:00:21 <lambdabot> Source not found. Are you on drugs?
05:00:23 <boxscape> there we go
05:00:32 <ertes> yeah, tsunderebot is back
05:00:41 <Iceland_jack> Behave lambdabot
05:03:02 <Cale> We can define the order of non-function types to be 0, and then the order of a -> b is max (1 + order of a) (order of b). A function is higher order when its order is at least 2.
05:03:39 <ertes> Cale: order of id?
05:03:52 <ertes> i can only see that working on monomorphic functions
05:04:02 <Cale> Doesn't work out on polytypes, right.
05:04:11 <Cale> huh, k-lined
05:04:21 <ertes> yeah, a few times
05:04:26 <ertes> not sure why
05:04:30 <ertes> probably because of tor
05:04:48 <ertes> someone else might be abusive
05:04:48 <Cale> jennyrgb: We can define the order of non-function types to be 0, and then the order of a -> b is max (1 + order of a) (order of b). A function is higher order when its order is at least 2.
05:04:50 <jennyrgb> ertes: I said nigger in a channel
05:04:57 <ertes> ah
05:04:58 <jennyrgb> ertes: got klined
05:05:08 <ertes> well, yeah, not surprising =)
05:05:24 <jennyrgb> ertes: yeah, lots of feminists on this network
05:05:58 <ertes> let's return to the topic of haskell though
05:06:32 <Cale> As ertes points out, this doesn't necessarily produce a definite result for polymorphic functions
05:07:47 <boxscape> not necessarily? Is there an example where it does?
05:08:17 <Cale> Int -> Maybe a
05:08:17 <ertes> boxscape: i can come up with examples using DataKinds
05:08:23 <ertes> or that =)
05:08:47 <boxscape> ah, so even if you have Int -> Maybe (Int -> Int) it's still just order 1?
05:08:51 <Cale> Then again, I think just disregarding the forall would be sensible enough.
05:08:57 <Cale> yeah
05:08:58 <boxscape> ok
05:09:15 <Cale> So that id would be order 1
05:09:22 <Cale> and map would be order 2
05:09:27 <jennygbr> brb, think I need to ban evade
05:10:12 <ertes> also i was wrong…  i can't come up with examples using DataKinds, because:
05:10:15 <ertes> :k (->)
05:10:16 <lambdabot> * -> * -> *
05:10:33 <ertes> @let class Blah (a :: Bool); instance Blah False; instance Blah True  -- that was the idea
05:10:34 <lambdabot>  Defined.
05:11:01 <ertes> but * is too large
05:11:08 <boxscape> I haven't looked into DataKinds and related things.. I should do that
05:11:50 <ertes> boxscape: the more features GHC gets, the more desparate i get…  we're so close to dependent types, yet so far away =)
05:12:23 <ertes> TypeInType is the latest and so far greatest depression extension
05:13:00 <boxscape> so is it likely that ghc will ever get fully dependent types?
05:13:15 <merijn> boxscape: Magic 8ball says: Maybe.
05:13:27 <boxscape> sounds... somewhat promising
05:13:54 <Philonous> You can already simulate dependently typed programs with singletons. 
05:13:58 <ertes> i'm pretty sure the first revision of dependent types is going to be useless
05:14:47 <ertes> "here you are: dependent types…  BUT…"
05:15:30 <Cale> Making Haskell into a *good* language for dependently typed programming is going to be even harder than just technically supporting dependent types too. The fact that terms and types live and have lived in separate namespaces for so long is going to make it painful.
05:15:48 <ertes> exactly
05:16:32 <ertes> it's the usual retrofitting problem…  i'm very glad that GHC came with an interpreter early on
05:17:02 <ertes> otherwise we would have the same dilemma most language implementations have: making code work in both the interpreter and the compiler would be painful
05:18:49 <Cale> I'm surprised there doesn't appear to be at least someone interested in building a dependently typed language with lazy evaluation by default.
05:19:10 <ertes> for some reason most people think of lazy-by-default as a mistake
05:19:21 <ertes> (FWIW i disagree)
05:19:44 <fizbin> Is there a well-known, tuned datastructure that can serve as a (Map IntSet Int) replacement ? I've got profiling data telling me that 10% of my runtime and 17% of my alloc comes from a single M.lookup call that returns Nothing about 11% of the time. (And after returning Nothing, the map is then modified)
05:19:46 <Cale> Depending on who "people" includes, I'm not sure
05:20:15 <ertes> s/think/seem to think/
05:20:39 <ertes> fizbin: HashMap Integer Int
05:20:50 <ertes> fizbin: IntSet is basically a bit-field
05:20:59 <Cale> btw, HashMap doesn't seem to be safe in concurrent programs
05:21:27 <ertes> maybe IntSet has a Hashable instance itself
05:21:34 <ertes> Cale: hmm?
05:21:45 <fizbin> Cale: meaning that it's unsafe to access from multiple threads a single HashMap, or that even multiple threads each with their own HashMap run into issues?
05:21:49 <Cale> There was a guy in here the other day with a program which produced different results every time you ran it for no other reason than that it was using parallel sparks and HashMap
05:22:09 <ertes> weird
05:22:35 <mniip> was there a bug report
05:22:37 <ertes> HashMap doesn't have any unsafe hacks, as far as i can tell…  sounds like a GHC bug
05:22:53 <Cale> HashMap has tons of unsafe hacks in it
05:23:31 <fizbin> ertes: I'll need to do some minor adjustment to make my IntSets use only numbers >= 0 in a contiguous block, but I should do those adjustments anyway.
05:23:43 <Cale> insert uses reallyUnsafePtrEquality# three times
05:24:02 <fizbin> Then I have to worry about paying the IntSet -> Integer cost on each lookup.
05:24:34 <fizbin> But maybe I can work out the rest of this function to use Integers where it's currently using IntSets.
05:24:55 <ertes> oh, indeed
05:25:24 <ertes> fizbin: if your bit-field is sparse, you can probably use something more compact
05:25:33 <ertes> fizbin: like unboxed Vector Int
05:25:44 <ertes> but make sure it's sorted
05:25:56 <Cale> mniip: I'm not sure if there was or not
05:26:23 <Cale> https://github.com/tibbe/unordered-containers/issues/147
05:26:25 <Cale> ah here
05:28:26 <fizbin> ertes: It sounds like I need to collect some more data on how large, on average, my IntSets are.
05:28:56 <ertes> fizbin: the size doesn't matter as much as the density
05:29:01 <fizbin> Because I don't actually have a good a priori reason to believe they'll be sparse, or one to believe that they won't.
05:29:02 <Cale> I went through and replaced the uses of HashMap with Map instead on a hunch, and the program ran about 2% slower, but no longer exhibited the weird random results.
05:29:29 <Cale> So we decided it had to be HashMap's fault, but it's very unclear exactly why
05:29:33 <ertes> also Integer is *far* more compact than IntSet
05:29:47 <ertes> in exchange for more expensive operations, of course
05:32:00 <ertes> if your bit-fields are very sparse (only 1/64th of all bits set on 64-bit platforms), Vector Word is going to be even more compact
05:32:20 <ertes> uh
05:32:22 <ertes> Vector Int
05:32:40 <Athas> Cale: I think hashmap uses a random hash seed.
05:32:59 <boxscape> ugh, on one hand, "cpuReg r = cpu.registers.register r" looks like it should be super straightforward to eta-reduce, on the other hand, the pointfree style version looks horrible
05:33:03 <Athas> Things like HashMap.toList can certainly give different results depending on OS and compiler.
05:33:33 <ertes> fizbin: if you invest some engineering cost, you can even get the best of both: run-length encoding with the option to have dense bit-fields in the middle
05:33:37 <merijn> boxscape: Why's that? looks fine to me?
05:34:02 <boxscape> merijn: the pointfree version? because I want to keep the imperative-like cpu.registers.register
05:34:18 <merijn> boxscape: That looks fine without the 'r' to me?
05:34:33 <boxscape> @pl cpuReg r = cpu.registers.register r
05:34:33 <lambdabot> cpuReg = ((cpu . registers) .) . register
05:34:41 <merijn> oh, wait
05:34:44 <merijn> I misparsed that :)
05:34:54 <Axman6> yeah that's gross
05:34:55 <ertes> looks like lens style
05:34:59 <boxscape> that's easy to misparse
05:35:03 <boxscape> yeah, it's lens style
05:35:15 <ertes> that's why i don't use lens style, even with lenses =)
05:35:36 <boxscape> I only started using lenses today, I can't stop using lens style yet
05:36:03 <ertes> look at it this way: you're not doing OO, so stop pretending you are ;)
05:36:07 <Cale> Athas: If that's observable within a single run of the program, that's terrible.
05:36:09 <boxscape> you do have a point
05:36:39 <Cale> Athas: But I don't think it's just that.
05:37:56 <Axman6> I think that characterising lens as just a way to get OO syntax in haskell does lens a huge disservice
05:38:28 <fizbin> @type (:.)
05:38:29 <lambdabot> error:
05:38:30 <lambdabot>     • Data constructor not in scope: :.
05:38:30 <lambdabot>     • Perhaps you meant one of these:
05:38:37 <Axman6> :t (.:)
05:38:38 <lambdabot> error:
05:38:38 <lambdabot>     • Variable not in scope: .:
05:38:38 <lambdabot>     • Perhaps you meant one of these:
05:38:45 <Axman6> :(
05:38:52 <Athas> Cale: I haven't seen it vary within a single run before.
05:41:15 <fizbin> ISTR seeing something like .: used to mean f .: g = (f .) . g
05:42:12 <fizbin> And if that definition were in place, then boxscape's function could be written cpu . registers .: register
05:42:31 <boxscape> :t (f .) . g -- interesting that :t requires Show for some things
05:42:32 <lambdabot> error:
05:42:32 <lambdabot>     • Could not deduce (Show b0) arising from a use of ‘f’
05:42:32 <lambdabot>       from the context: (FromExpr c, Show a, Show a1)
05:43:01 <boxscape> at least, I think that's what's happening
05:43:16 <boxscape> fizbin: that does look alright
05:43:22 <fizbin> @type let f .: g = (f .) . g in (.:)
05:43:24 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
05:43:48 <merijn> boxscape: It's because you're using f and g :)
05:43:50 <merijn> :t f
05:43:52 <lambdabot> FromExpr a => a
05:44:03 <fizbin> :t \f g -> (f .) . g
05:44:04 <boxscape> right... but it's still not obvious to me how that leads to a Show constraint
05:44:04 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
05:44:20 <merijn> boxscape: Those are defined in lambdabot as a result simple-reflect
05:44:46 <merijn> boxscape: Because FromExpr expects functions to be applied to showable things
05:44:59 <merijn> It's how you can do neat things like:
05:45:01 <boxscape> ah, ok
05:45:05 <merijn> > foldr f z [a,b,c]
05:45:07 <fizbin> I just can't remember the name of the library that defined combinators like (.:), and Hoogle doesn't have it.
05:45:07 <lambdabot>  f a (f b (f c z))
05:45:25 <boxscape> yeah, simple-reflect is neat
05:47:20 <boxscape> fizbin: there are a few results in hayoo
05:47:30 <boxscape> like custom-prelude and Sound.SC3
05:48:27 <boxscape> at least I think that's the same function
05:48:32 <boxscape> :t (.) . (.)
05:48:33 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
05:48:39 <boxscape> looks good
05:49:03 <fizbin> Yeah, .: from custom-prelude is what I was remembering.
05:49:46 <fizbin> Lots of names for it: https://hayoo.fh-wedel.de/?query=%28c-%3Ed%29-%3E%28a-%3Eb-%3Ec%29-%3Ea-%3Eb-%3Ed
06:03:50 <fizbin> How does one use an inorder operator from a module imported qualified again? I'm trying to say (mp `IM.!`) but that's a syntax error. Every combination of parens I can think of around that is also a syntax error.
06:05:45 <lep-delete> a Mod.! b
06:06:27 <joe9> any one knows of a package to derive default values using GHC.Generics?
06:06:33 <fizbin> Oh. So my issue was too much syntax. Ok.
06:06:47 <lep-delete> :)
06:07:17 <ertes> joe9: data-default supports that
06:07:25 <joe9> ertes: Thanks.
06:07:30 <ertes> joe9: just derive Generic for your type and write an empty instance
06:08:15 <ertes> and i wish people would stop that horrible habit of completely hiding internals
06:08:29 <ertes> there is no reason to hide the GDefault class
06:08:33 <joe9> ok, will try that. yes, the docs are not that helpful https://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html
06:08:52 <ertes> joe9: for some reason it's only exported from the dependent pacakge data-default-class
06:08:56 <ertes> and only incompletely
06:12:56 <lyxia> joe9: if your type is an instance of Generic, just try an empty instance. if it typechecks you can use "def" as a default value of that type.
06:15:59 <joe9> lyxia: Thanks, got it.
06:16:18 <joe9> lyxia: btw, are you the author of generic-random?
06:19:48 <lyxia> yeah
06:21:47 <joe9> lyxia: Thanks for sharing the package . This is how I am using it. http://dpaste.com/12JHKV3 . If you do not mind me asking, Is there a way to just derive the instance? Instead of writing the instance manually?
06:22:53 <joe9> lyxia: I have a bunch of types where the types are just simple non-recursive data types and I want to use a sane default that works both for recursive and non-recursive data types.
06:23:13 <lyxia> you can just use genericArbitrary for non-recursive types
06:23:15 <joe9> got your package after reading this https://byorgey.wordpress.com/2016/09/20/the-generic-random-library-part-1-simple-generic-arbitrary-instances/
06:23:31 <lyxia> and I don't think you can avoid writing the instance
06:24:49 <joe9> lyxia: I would rather use this     arbitrary = genericArbitrary' (S Z) uniform and not worry about changing it for recursive and non-recursive data types. From the docs, I gather that it is a sane default.
06:25:38 <lyxia> As a matter of principle, there isn't a good universal instance to be derived, so I think it would be a bad idea to make Arbitrary derivable.
06:25:47 <lyxia> okay sure.
06:27:04 <joe9> your logic makes sense, making the user think about it before using it. If not for that, I wish this genericArbitrary' (S Z) Uniform could be a default method for the class.
06:27:14 <lyxia> "make Arbitrary derivable" means adding a default implementation as part of its definition in QuickCheck.
06:27:32 <joe9> then, I could just say deriving (Eq, Show, Arbitrary) and be done with it.
06:27:49 <lyxia> that's precisely what I'm arguing against
06:28:33 <ertes> lyxia: interesting package…  i think it's possible to derive uniform weights automatically though
06:28:36 <joe9> lyxia: You are the expert on this and if you have strong feelings about it, I will go with that.
06:29:26 <ertes> lyxia: for sum types i mean
06:29:30 <joe9> lyxia: from a dumb user perspective, the alternative is easier/saner.
06:29:37 <ertes> let me try something
06:29:46 <lyxia> ertes: am I not doing that
06:29:58 <ertes> hmm?  maybe i overlooked something
06:30:12 <lyxia> I have "uniform" defined!
06:30:29 <joe9> lyxia: but, that is not a sane choice across all datatypes.
06:31:12 <stphrolland> Hi, this morning I was asking about Pipes, and PIpes.Network. Things got better. But now I still cannot figure out what the type of my handler should be. I would like the handler to accept C.Command, and to output C.Command. I have tried without providing anytype signature, so as GHC tells me what it awaits... but no success: here's the code   http://lpaste.net/354479   the usage of handler would be a line 19. Any what it shoul
06:31:39 <ertes> lyxia: oh, you have
06:31:41 <lyxia> joe9: adding a default implementation to Arbitrary is not my call though :)
06:33:31 <joe9> lyxia: agreed. Thanks again for sharing the generic-random. made me avoid writing so many arbitrary instances.
06:35:50 <lyxia> Now that I think about it, for product type the default doesn't seem as controversial to me.
06:36:05 <lyxia> So maybe the default implementation could work with just that.
06:38:39 <joe9> lyxia: why not provide: genericArbitrary = genericArbitrary' (S Z) Uniform ?
06:39:03 <joe9> I could not find a genericArbitrary as described in the byorgey's article.
06:39:19 <joe9> lyxia: I presumed that it was removed as versions incremented.
06:39:28 <ertes> stphrolland: your 'handler' is not a function
06:39:53 <ertes> it's a Pipe that needs to use 'await' and 'yield' (or an abstraction of them like 'map' from Pipes.Prelude)
06:39:55 <stphrolland> understood, it should be a Pipe, but I don't know how to define it
06:40:05 <ertes> stphrolland: first write a type siganture
06:40:33 <stphrolland> map seems to be good, I want to transform incomming C.Command s
06:40:42 <ertes> stphrolland: handler :: (Monad m) => Pipe A B m r
06:40:45 <lyxia> joe9: yeah I did an update since Brent wrote that.
06:40:50 <ertes> replace A and B by the input type and B by the output type
06:40:57 <ertes> s/and B/
06:40:59 <ertes> /
06:41:30 <joe9> lyxia: sure, that is what I assumed. the name genericArbitrary is more intuitive. I wish you could provide it, please?
06:41:53 <lyxia> joe9: I just didn't figure that it would be such a useful pattern, I can certainly add it!
06:42:26 <ertes> stphrolland: if you want to write a regular function, you can also use this pattern:  … >-> P.map handler >-> …
06:42:45 <ertes> 'handler' is not a good name in either case
06:42:56 <stphrolland> how would you call it ?
06:43:03 <ertes> depends on what it is
06:43:17 <stphrolland> it receives commands from a client, and returns another command
06:43:30 <ertes> that's not quite enough information to figure out a good name
06:43:31 <stphrolland> performs some IO action on the server side at the same time
06:43:46 <ertes> if it does that, you can't use 'map', but you need 'mapM'
06:44:02 <stphrolland> okay, I will try to firgure a better name :-)
06:44:17 <joe9> lyxia: Thanks a lot. if genericArbitrary' (S Z) Uniform is a sane choice, then exposing it as genericArbitrary would have saved some time while trying to use/understand the package. Also, using genericArbitrary' (S Z) Uniform makes it seem that I am doing something not usual or different from a sanely accepted function.
06:44:18 <ertes> and its type changes, too:  handlerOrWhatever :: (MonadIO m) => Pipe Command Command m r
06:44:25 <phz_> hey folks
06:44:38 <ertes> then you can use liftIO from within it
06:44:44 <phz_> in tasty, there’s a function called defaultMain :: TestTree -> IO ()
06:44:51 <phz_> it seems it parses the command line arguments
06:45:00 <phz_> is there a way to run a specific test group from command line?
06:45:01 <stphrolland> ertes: many thanks, it's like I have all the bricks to play and experiment now
06:45:09 <ertes> phz_: yes, just give its name
06:45:18 <ertes> ./my-test-suite my-group
06:45:26 <phz_> even via stack?
06:46:54 <ertes> if stack is any similar to cabal-install, you can probably use --my-test-suite-option=my-group
06:47:18 <ertes> but the cabal/stack interface is more for tests during installation/deployment…  during development i would just call the test suite directly
06:47:55 <phz_> well, having a single entry point would be better
06:48:11 <cocreature> stack has a --test-argument option iirc that you need to use to pass arguments to your test suite
06:48:56 <phz_> Invalid option `--test-argument'
06:49:27 <cocreature> --test-arguments
06:49:29 <phz_> oh it’s 
06:49:30 <phz_> yeah
06:49:32 <cocreature> stack test --help is your friend :)
06:49:32 <phz_> thanks!
06:49:37 <phz_> yeah I’m reading through
06:50:17 <ertes> you probably also need an option to stop stack from hiding your test suite's output…  again if it's any similar to cabal-install =)
06:50:49 <ertes> cabal-install only displays output if something goes wrong, and it also disables colour
06:51:06 <phz_> ertes: yeah I hate that
06:51:09 <ertes> that's why i would just use the test suite directly
06:51:12 <phz_> but it doesn’t hide it if you pass the testsuite
06:51:35 <cocreature> I don’t think cabal disables colour. it’s the test driver that disables colour if it’s not run via a tty
06:51:36 <Myrl-saki> Uwawawa~ Why is `evaluates to` and `you can derive` distinct in Evaluation inference rules?
06:51:51 <ertes> yeah, likely
06:52:32 <Myrl-saki> Is there a reason why you can't have a rule with `pred (succ x) / x`
06:52:45 <phz_> we have colours here :)
06:52:55 <Myrl-saki> Why `x -> x / (succ x) -> (succ x)` or something similar?
06:54:43 <lyxia> joe9: are your types mostly single-constructor types
06:55:54 <lyxia> I'm wondering whether a special function just for that case is actually what you're missing
06:57:21 <lyxia> genericArbitrary' also messes with the size parameter, which might be annoying with simple types.
06:59:34 <joe9> lyxia: no, there are types like this:  data Exchange = Globex | Eurex | Smart
07:00:05 <joe9> lyxia: I would not feel comfortable using a function just for simple types.
07:00:31 <joe9> lyxia: I want to use something that works whatever the type is.
07:01:05 <joe9> lyxia: does that make sense? it would be hard to debug if the genericArbitrary stops working just because the type is a little more complicated.
07:09:05 <lyxia> I think things will break with recursive types though
07:10:23 <joe9> I thought this would not: genericArbitrary (S Z) Uniform?
07:10:25 <phz_> https://gist.github.com/phaazon/eda92a5c5dc3c5676ad3a6c0d60c2047
07:10:26 <phz_> :(
07:10:53 <joe9> lyxia: genericArbitrary' (S Z) Uniform -- missed the quote
07:11:03 <lyxia> joe9: this is not universal either
07:11:04 <sphinxo> Could anyone provide any guidance/resources for stack typing? ( not talking about haskell stack )
07:11:15 <sphinxo> as in checking a stack based language
07:11:31 <lyxia> and I don't quite like the fact that it messes with size by default
07:12:18 <lyxia> and detecting recursive types in a generic way is tricky
07:12:48 <joe9> lyxia: Is there a function that would work universally. Does not have to build infinite recursion depth. Something that just works for all types.
07:13:19 <joe9> lyxia: I understand infinite types can get tricky. Have a maximum depth for this case?
07:13:52 <joe9> lyxia: maybe hardcode the max depth to a certain default.
07:14:18 <joe9> lyxia: the "hardcode" just for this default function, I mean.
07:15:28 <phz_> no one knows about the ZonedTime parsed by aeson?
07:15:34 <phz_> that’s weird it doesn’t parse correctly
07:16:19 <lyxia> phz_: aeson parses JSON, your string doesn't contain JSON.
07:16:47 <phz_> ah
07:16:51 <phz_> I was missing a Z at the end
07:17:03 <phz_> hm, it’s gonna be boring…
07:18:29 <lyxia> phz_: have you tried to encode one to see what the expected format is
07:18:45 <phz_> I just read the sources, because the documentation is bad
07:18:51 <phz_> https://github.com/bos/aeson/blob/master/attoparsec-iso8601/Data/Attoparsec/Time.hs#L136
07:19:04 <phz_> so yeah, I need to snoc a 'Z' 
07:19:09 <phz_> I wonder how I can do that
07:19:14 <phz_> with the (.:) operator
07:19:32 <phz_> I guess I could… read a String / Text, then adds the 'Z', then readback to ZonedTime?
07:19:37 <phz_> ooooooooooooor
07:19:42 <phz_> I could just alter the source :)))
07:19:47 <phz_> and send the Z directly!
07:19:51 <phz_> yeah, I’ll do that
07:19:57 <phz_> I need to see how to do that in MSSQL
07:20:17 <phz_> hm, concatenate seems the right tool here
07:20:31 <phz_> oh SQL Server supports the + operator
07:20:33 <phz_> neat
07:21:08 <lyxia> there is a bit happening between zonedTime and eitherDecode
07:21:38 <lyxia> so the string you're passing eitherDecode isn't what gets passed to zonedTime
07:22:45 <mniip> haskell types are like constructive logic, right?
07:25:38 <merijn> mniip: An inconsistent form of constructive logic, yes
07:26:06 <mniip> and FOL is dependent types
07:26:59 <Myrl-saki> mniip: o you still remember me. '-'
07:27:01 <Myrl-saki> Do*
07:27:01 <lyxia> joe9: I don't think there is a good solution. Trying to handle all kinds of cases would make this quite heavyweight, and then there is the issue that if you try to keep it too simple you have no knowledge about the resulting distribution.
07:27:36 <mniip> no
07:27:38 <mniip> who are you
07:27:47 <Myrl-saki> mniip: rip.
07:27:56 <shapr> My gf needed some csv processing this past weekend, and I coudn't find any good example uses for cassava, so I used Python. Are there some good examples of cassava use?
07:28:09 <mniip> merijn, I know of a cubic time solver for haskell types, is there a P time solver for dependent types?
07:28:09 <Myrl-saki> mniip: I feel kinda hurt.
07:28:15 * shapr hugs Myrl-saki
07:28:31 <merijn> mniip: I have no clue
07:29:46 <lyxia> joe9: testing-feat can cover a lot of types though
07:30:58 <joe9> lyxia: Thanks will check out testing-feat. did not know about it.
07:44:14 <bennofs> Is gfoldl actually a fold? It looks more like a traverse to me
07:50:21 <lyxia> I guess those who wrote this looked at folds and traversals from far enough to consider them the same.
07:51:30 <Cale> It's also worth noting that Traversable didn't exist at the time
07:51:41 <ysahil> Hi Guys!! Can someone guide me on how to connect to a server in Haskell?
07:51:55 <Cale> I'm actually not even sure Applicative did...
07:52:07 <Cale> ysahil: What kind of server?
07:52:34 <ysahil> Actually, I am attempting to make a IRC bot using Haskell
07:52:58 <ysahil> So what is the server name we should connect to?
07:53:27 <Cale> uh, whatever IRC server it is you want your bot to connect to
07:53:31 <Rembane> ysahil: irc.freenode.net and see what happens. :D
07:54:32 <eschnett> bennofs: how is gfoldl a traverse? travers takes two functors, here i see only one (c)
07:55:36 <ysahil> I tried that and when I executed that program, two errors arose while connecting to that server, "Couldn't look up your hostname" and "No Indent response". I have no idea as to how this error arose
07:57:34 <ysahil> Rembane: Can you help me in this?
07:58:53 <geekosaur> what program are you using for this?
08:00:24 <Rembane> ysahil: Sure, answer geekosaur's question.
08:01:17 <ysahil> geekosaur: I made up my own program which, for now, just tries to connect to irc.freenode.net with port number 6667
08:01:18 <ph88^> what's the allocation strategy for Data.Vector ? 2x ?
08:02:38 <Cale> ysahil: That's normal. My IRC client gives those errors every time I connect.
08:03:08 <Cale> ysahil: also, it's Ident response -- it's the IRC server looking to see if you're running identd
08:03:39 <peddie> ph88^: are you talking about mutable vectors?  the immutable ones obviously don't resize . . . and I don't think there is automatic resizing on the mutable ones
08:04:07 <ph88^> peddie, ye what's the automatic resizing like? double up ?
08:04:23 <peddie> ph88^: I think you can call `grow` to manually resize; again, I don't think there is automatic resizing
08:04:48 <peddie> ph88^: you'd have to implement it yourself
08:05:28 <geekosaur> identd isn't often used any more, it's at beat meaningless and at worst itself a potential security hole
08:05:45 <zuul> Good day.
08:05:53 <peddie> ph88^: take a look at the docs in https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Mutable.html -- I don't think there is anything analogous to push_back
08:06:06 <Guest67729> Opinions on Graham Hutton's "Programming in Haskell" for a first time programmer?
08:06:20 <ph88^> peddie, oh ok i have to specify the grow size and thus strategy .. ok thx
08:07:33 <ysahil> Cale:So what is the remedy to this problem?We can't just leave it as it is.
08:09:55 <Cale> ysahil: Ignore those messages?
08:11:09 <Cale> ysahil: You'll see those messages even if your client is working just fine. In fact, depending on which IRC client you're using right now, you'll probably find that Freenode sent the same messages to you when you connected.
08:11:16 <Cale> ysahil: They're ignorable.
08:14:25 <ysahil> Cale:Okay, now I get it.Thanks Guys. :D
08:17:01 <lyxia> eschnett: traverse is only a special case of traversals as general concept where you go through a structure and modify its fields, sometimes with side effects.
08:27:24 <Luke> Hey guys. Anyone know of a way to mock out the current time in IO for testing purposes?
08:27:50 <tdammers> Dependency injection
08:28:00 <tdammers> Don't get the current time from IO, pass it in explicitly
08:28:30 <Luke> tdammers: I can't pass it in explicitly because some of the libraries we're using are in IO and not MonadIO
08:28:57 <tdammers> ah
08:29:16 <tdammers> you mean, the third-party functions get current time from IO?
08:29:20 <Luke> yes
08:29:35 <tdammers> ah that sucks
08:30:05 <Luke> tdammers: it's high performance networking code so it's hardcoded to IO on purpose
08:37:24 <sphinxo> Luke: you can do it on the system level with https://github.com/wolfcw/libfaketime
08:37:34 <Luke> great thank you!
08:37:51 <sphinxo> this catches the actual calls using LD_PRELOAD
08:38:01 <Luke> perfect
08:38:16 <Luke> have you used this before? did you like it?
08:38:21 <sphinxo> Are you going to be changing the time, whilst the test cases are running?
08:39:38 <ph88^> i have a file with lines like          2.152      3.760     -0.376
08:39:39 <ph88^>      i was thinking of parsing with attoparsec and then make a Vector of Vectors of Double .. is that a good idea ?
08:40:02 <mbw> Is there a way to change how ghc cuts off identifier strings in the .hp file produced by ./bin +RTS -hc[...]? I currently have ids like "(3064)bubblesortM/bubblesor...", which are not very helpful.
08:41:55 <mbw> And what does 3064 stand for?
08:42:40 <Luke> sphinxo: I'd like to have the option to change the time during the tests for timeouts etc.
08:43:06 <nshepperd_> mbw: -L sets the cutoff iirc
08:43:47 <nshepperd_> Not really sure why the rts has a cutoff anyway.... That should be done in the ui tools really
08:45:31 <mbw> nshepperd_: You are correct! Thanks. And yes, heap profiling is probably not perfect, but way better than what I'm used to from c++&friends.
08:46:39 <sphinxo> What's the best way to track position infomation through the type checking phase for better error reporting
08:49:46 <sphinxo> Luke: you can change the enviroment variable FAKETIME=<datetime> and disable caching with FAKETIME_NO_CACHE=1
08:49:56 <Luke> hmm ty
08:50:16 <sphinxo> no caching means it is forced to lookup the env var each time
08:57:24 <ertes> ph88^: depends on how precise you want those numbers to be
08:58:10 <ertes> ph88^: Double can only represent ratios of the form x * 2^e, where both x and e are integers, exactly, so for example there is no exact representation for 0.1
08:58:26 <ph88^> ertes, what are my options ?
08:58:37 <ertes> ph88^: Rational and Fixed (Data.Fixed)
08:58:56 <ph88^> how does Rational, Fixed and Double compare in speed ?
08:58:59 <byorgey> ph88^: probably Double is fine.
08:59:23 <ertes> ph88^: Rational is much slower, because it does Integer arithmetic, including calculating 'gcd'
08:59:31 <Myrl-saki> ph88^: What are the numbers supposed to represent?
08:59:37 <ertes> ph88^: Fixed is reasonably fast
08:59:45 <ertes> probably near Double speed
08:59:47 <Myrl-saki> ertes: lcd?
09:00:03 <ertes> ph88^: however, first check whether you need the precision
09:00:06 <byorgey> even without knowing what you want to do with those numbers, I am going to say with 95% confidence that you should just use Double.
09:00:10 <ph88^> Myrl-saki, http://users.rcn.com/wpacino/jitwtutr/jitwtutr.htm
09:00:20 <ertes> also Double is not *less* precise than Fixed, but it has a different trade-off
09:00:28 <ertes> for example Double can easily represent 0.000000000000000000000000000000000000000000000000000000000000005
09:00:42 <ph88^> ertes, i think speed is more important than the precision
09:00:43 <ertes> Myrl-saki: lcm involves gcd
09:00:55 <Myrl-saki> ertes: Talking about *d*
09:01:04 <Myrl-saki> ertes: Either gcf, lcd or lcm.
09:01:18 <ertes> what's lcd?
09:01:27 <Myrl-saki> least common denominator.
09:01:39 <ertes> that's the same as least common multiple =)
09:01:44 <byorgey> Myrl-saki: 'gcd' stands for 'greatest common divisor'
09:01:45 <ertes> > lcm 12 15
09:01:47 <lambdabot>  60
09:01:55 <Myrl-saki> byorgey: AOh.
09:02:03 <byorgey> > gcd 12 15
09:02:04 <Myrl-saki> byorgey: I know it more as gcf.
09:02:05 <lambdabot>  3
09:02:10 <ertes> > 12*15 `div` gcd 12 15
09:02:12 <lambdabot>  60
09:02:12 <Myrl-saki> factor <-> divisor
09:02:15 <Myrl-saki> Sorry. >.<
09:02:19 <byorgey> Myrl-saki: fair enough, but in Haskell it is called 'gcd' =)
09:02:23 <byorgey> no worries
09:02:38 <ertes> Myrl-saki: GCD is also pretty standard terminology =)
09:02:40 <ertes> and so is LCM
09:03:04 <byorgey> well, I suspect 'standard' depends on where you went to school
09:03:05 <Myrl-saki> ertes: Yeah. d just auto-translated to denominator because fractions. Whoops. my fault.
09:03:17 <ertes> true
09:03:18 <Myrl-saki> byorgey: Yeah, we use factor rather than denominator here.
09:03:20 <byorgey> everyone thinks the way *they* learned it is 'standard'
09:03:30 <Myrl-saki> s/denominator/divisor/
09:04:18 <Myrl-saki> Can you do recursion with linear types?
09:04:19 <ertes> well, in my case it's my number theory/crypto background
09:05:00 <Myrl-saki> We can't define fix, but how about explicit(?) recursion.
09:05:45 <ph88^> should i use Data.Attoparsec.ByteString.Lazy or Data.Attoparsec.Text.Lazy  ?
09:06:00 <ph88^> oh there is also a Data.Attoparsec.Lazy
09:06:02 <Myrl-saki> ph88^: That depends a whole lot.
09:06:15 <Myrl-saki> ph88^: Heck, why not even just use Parsec?
09:06:27 <ph88^> speed
09:06:36 <ph88^> our c programs takes 30 minutes
09:06:44 <Myrl-saki> ph88^: Ah. Migration.
09:07:00 <ph88^> the c program is not written well and the interface is not nice
09:07:08 <Myrl-saki> ph88^: I may be wrong here.
09:07:13 <ertes> ph88^: if you're going for raw speed, assume an encoding and use ByteString
09:07:18 <ph88^> ok
09:07:28 <ertes> ph88^: however, benchmark first
09:07:28 <ph88^> is Float faster than Double by the way ?
09:07:31 <ph88^> ok
09:07:38 <Myrl-saki> ph88^: Possible.
09:07:56 <Myrl-saki> Most likely, rather.
09:08:02 <ertes> ph88^: also see how attoparsec compares to the C program…  it's fast, but far from the optimum
09:08:19 <ertes> especially since it does automatic backtracking
09:08:54 <ph88^> don't think much backtracking will be needed in that format
09:08:59 <ertes> so you should make sure that your choices ((<|>)) are as local as possible
09:09:01 <ph88^>      2.152      3.760     -0.376   
09:09:20 <ph88^> that might vary in the amount of columns
09:09:40 <geekosaur> actually I'd tend to assume Float is the same speed aside from non-strictly-floating-point operations like copying or loading/storing
09:09:45 <ertes> abstract over the floating point type, if you can, then you can easily benchmark both
09:09:46 <Myrl-saki> `many numbers` or something.
09:09:55 <ertes> because i doubt that Double is slower on modern architectures
09:10:09 <Myrl-saki> geekosaur: Can't you do more float operations in parallel?
09:10:41 <ph88^> ertes, since i have a dynamic amount of columns, should my type be   Vector Vector.Unboxed Double ?
09:10:44 <geekosaur> the floating point unit generally works at full precision (even more than Double) internally and truncates on store
09:11:02 <ertes> ph88^: are you parsing the whole thing into memory?
09:11:17 <ph88^> no, but i need a sliding window
09:11:26 <Myrl-saki> geekosaur: Eh.
09:11:39 <ertes> ph88^: Vector is not a good choice for a sliding window, unless you use a mutable vector
09:11:48 <ph88^> oh
09:11:55 <ertes> ph88^: Seq is a good choice, but a mutable vector will still be faster
09:12:01 <ertes> like a ring buffer
09:12:45 <ph88^> ertes, i need to fill up the  ring buffer with for example 1000 values .. then i need to calculate the biggest value .. then i need move the window by 1 and calculate the next biggest value .. and so on ..
09:13:00 <Myrl-saki> http://x86.renejeschke.de/html/file_module_x86_id_6.html http://x86.renejeschke.de/html/file_module_x86_id_7.html
09:13:04 <ertes> ph88^: you don't need a sliding window for that, i think
09:13:07 <ph88^> i already figure that i don't have to compare the value with all the previous values but only the maximum previous value found
09:13:11 <ertes> ph88^: ah, nevermind, you do
09:13:14 <Myrl-saki> 4 singles vs 2 doubles.
09:13:17 <ertes> but you can limit the sliding window
09:13:24 <ph88^> what kind of limit ?
09:13:40 <Myrl-saki> Of course, AVX exists.
09:13:42 <ertes> ph88^: well, once you have a greatest value, you can remove everything that came before it
09:13:45 <Myrl-saki> Where I might be very wrong.
09:14:37 <ph88^> ertes, actually .. i don't think i need window at all ..
09:14:59 <emc2> is there some way to make a package require -threaded
09:15:02 <ph88^> i just need to calculate the window once   and then check the next value with tha maximum one
09:15:09 <ertes> ph88^: you do, because if the greatest value falls off, you need to find the next greatest value
09:15:14 <emc2> seems I've never actually used -threaded before
09:15:33 <ph88^> ertes, i think it will be enough to track the position of the greatest value
09:15:47 <emc2> but my test library needs -threaded for doing timeouts
09:16:13 <ertes> ph88^: let's say you're looking for the greatest value out of five and your window looks like this:  [10, 4, 7, 1, 6]
09:16:24 <ertes> ph88^: now a new value comes in that is still smaller than 10
09:16:27 <cocreature> emc2: you can add -threaded to your ghc options
09:16:43 <ph88^> ertes, oh yes you're right
09:17:12 <ph88^> ertes, would there be any benefit though to dropping the left half ?
09:17:14 <emc2> cocreature: that'll set it for anything that depends on it?
09:17:42 <cocreature> emc2: no sorry, that only works for executables (but a test-suite is an executable so it would work for that)
09:17:42 <ertes> ph88^: sure, whenever a new greatest value comes in, you can pretty much discard the whole window
09:18:03 <ertes> you only need the window, if the old greatest value falls off and you need to find the next one
09:18:23 <ph88^> ertes, but discarding the window does that optimize for memory or for wall time ? because i care for wall time, not memoty
09:18:34 <ertes> ph88^: both
09:18:41 <ph88^> so i use Data.Vector.Unboxed.Mutable  ?
09:19:02 <Myrl-saki> ertes: How does it help for both?
09:19:41 <ertes> ph88^: you should use Seq first, and only switch to a mutable vector when Seq is too slow, because the mutable vector variant requires some engineering effort and is easy to get wrong
09:20:33 <ph88^> ertes, https://hackage.haskell.org/package/parallel-3.2.1.1/docs/Control-Seq.html ?
09:20:59 <Myrl-saki> ertes: To be more exact, how does it help with wall time?
09:21:01 <ph88^> or this one https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html#t:Seq ?
09:21:20 <emc2> in that case, is there a way to detect if I'm running with the threaded runtime
09:21:22 <ertes> Myrl-saki: GC may have less work to do
09:21:41 <ertes> also using less memory is almost always a time benefit as well, because of caching
09:21:47 <ertes> ph88^: containers
09:22:17 <ph88^> ok
09:22:20 <ph88^> thank you
09:22:26 <shapr> mmm, vectors
09:23:08 <ertes> ph88^: in case you're going for the mutable variant, i strongly recommend that you write a ring buffer abstraction around it and test it well
09:30:25 <cocreature> emc2: I think https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/ghc-8.0.1/Config.html#v:cGhcThreaded tells you that
09:34:09 <lyxia> ph88^: Oh, I have a purely functional bounded buffer lying there https://github.com/Lysxia/breadcrumbs/blob/master/Data/Breadcrumbs/Caterpillar.hs
09:48:40 <Myrl-saki> I don't think it's possible to loop with linear types.
09:52:15 <erisco> an interesting thought... list the paths of an infinite tree
10:01:38 <ski> Myrl-saki : you probably needs some kind of "of course" or "why not" modality, aye
10:02:12 <sphinxo> What's the best way to annotate an ast?
10:02:48 <sphinxo> to add position info/ errors
10:04:01 <Myrl-saki> ski: Mhm.
10:04:21 <ski> @where DecoratingStructures
10:04:21 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
10:04:22 <ski> @where IndirectComposite
10:04:22 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
10:04:34 <ski> sphinxo : perhaps see ^
10:04:46 <Myrl-saki> ski: In Wadler's paper, `append` was only reimplemented when he reintroduced nonlinear types..
10:05:09 <sphinxo> Thanks!
10:05:28 <ski> Myrl-saki : possibly it'd be enough with a nonlinear zone
10:06:15 <Myrl-saki> ski: A bit of a segway. Why is evaluation done with `->` rather than going straight evaluation rules?
10:06:37 <ski> i'm not sure what you mean
10:06:40 <Myrl-saki> ski: Something along the lines of `pred (succ x) / x`
10:06:59 <Myrl-saki> Why go through the hoops of `x -> x / succ x -> succ x`
10:08:48 <Myrl-saki> Oh, that was an actual rule.
10:10:59 * ski is still not following, fwiw ..
10:11:53 <Myrl-saki> ski: Do you have a copy of TAPL?
10:13:06 <fosskers> Do attoparsec parsers perform better when written in Applicative style over Monadic style, or is the optimized code pretty much the same?
10:14:34 <joe9> fosskers: I would say user comprehension is more important than sysetm performance in that regard.
10:14:38 <ski> Myrl-saki : yes, but not here
10:14:55 <Myrl-saki> ski: Ah. Maybe some other time. x3
10:15:31 <lyxia> fosskers: attoparsec's <*> is implemented using >>=
10:15:40 <lyxia> http://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/src/Data-Attoparsec-Internal-Types.html#line-182
10:15:53 <ski> it seemed you were pondering something about operational semantics, rewriting systems. big-step vs. small-step. structural semantics. &c.
10:16:58 <Myrl-saki> ski: I think it's because I'm misusing inference rules.
10:19:23 <fosskers> joe9, I'm going for speed
10:19:33 <fosskers> lyxia, thanks, so no difference.
10:19:36 <Myrl-saki> Welp. G'night. It's 1 over here.
10:23:29 <boxscape> hm, it seems strange that while lens has <.= to pass through the value of .=, it doesn't have <%= as the equivalent of %= ...
10:24:26 <cocreature> boxscape: hm? https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Lens.html#v:-60--37--61- exists
10:25:00 <boxscape> huh
10:25:06 <boxscape> I looked in the wrong module apparently
10:25:07 <boxscape> thanks
10:25:35 <cocreature> boxscape: hoogle is great for that kind of stuff http://hoogle.haskell.org/?hoogle=(%3C%2B%3D)
10:26:12 <boxscape> yeah, I usually use hoogle.. I just naively assumed that it would be defined in the same place as <.= :)
10:35:16 <boxscape> (I had been looking in Control.Lens.Setter)
10:52:51 <significance> Hey all! If I have a do block that returns a list, how can I get the first element from it?
10:53:13 <significance> head do ... is of course a syntax error :P
10:54:26 <significance> nvm, got it -- head $ do.
11:19:13 <erisco> or head (do ...)
11:19:42 <infandum> What causes a NaN in Haskell? More specifically, why would (** (1 / 7)) . product $ [6703,6790,6440,6699,6933,6751,6707] cause a NaN in compiled but not in ghci?
11:20:05 <Tuplanolla> That sounds suspicious, infandum.
11:20:27 <geekosaur> platform?
11:20:55 <ChaiTRex> infandum: I can't get it to be NaN with either.
11:21:10 <infandum> (that is, when having a traceShow with that function, traceShow (x (that list), and that function result y) returns (that list, NaN))
11:21:42 <eschnett> your list has only integers. multiplying them might overflow. did you mean to convert to Double before taking its product?
11:21:45 <glguy> Incidentally you can deobfuscate that as: product [6703,6790,6440,6699,6933,6751,6707] ** (1/7)
11:21:50 <infandum> ChaiTRex: If I do it isolated in ghci it's fine, but for some reason with thousands of other values things start to become NaN even in that debug
11:22:07 <infandum> so it has to be between those steps
11:22:12 <eschnett> with thousands of values, the product might end up being zero due to integer overflow
11:22:17 <infandum> glguy: I like point free :)
11:22:33 <eschnett> … or negative
11:22:35 <infandum> eschnett: Interesting. Because there are lots of examples of this.
11:22:49 <infandum> It's fmapping over a list of lists
11:23:11 <Tuplanolla> Do you get a different result with identical input and extensions, infandum?
11:23:14 <infandum> I've never had a problem like this before on big data though
11:23:33 <eschnett> i would choose explicitly which type should be used for the product and the root
11:23:39 <Tuplanolla> Make sure you don't get anything with `-Wall`, infandum.
11:23:41 <infandum> Tuplanolla: The only extension I have is BangPatterns
11:24:24 <Tuplanolla> This sounds like a common mistake due to type defaulting, infandum.
11:24:31 <Tuplanolla> However I would not be surprised if some optimization removed a store and accidentally kept extra precision in a floating-point register, infandum.
11:25:17 <infandum> Tuplanolla: It's ok other than some name shadowing (in another function) and type inference of integer in some cases
11:25:30 <eschnett> Tuplanolla: extra precision is only a problem with 32-bit intel architectures. 64-bit architectures don’t have that feature any more.
11:25:38 <infandum> I'm on 64 bit
11:25:45 <cocreature> infandum: are you sure you are really running the exact same code in your compiled program?
11:25:50 <Tuplanolla> Well, then.
11:27:12 <infandum> cocreature: It's actually: https://pastebin.com/10BYuVTm
11:27:33 <infandum> Where head xs is a list of 7 numbers (I verified it)
11:28:12 <dcz__> hello guys, i am trying to find mp4 files in home directory. My purpose is that. For now, i listed files in $HOME but how can i convert IO [FilePath] -> [FilePath] or how can i get rid of IO ? :D, line 9 doesnt work for example. https://hastebin.com/befilogude.hs
11:28:20 <infandum> that trace results in stuff like: (NaN,[581,3498,461,4698,2675,395,2834],NaN,[6968,10050,10047,1323,9627,12393,10550])
11:29:01 <infandum> actually I removed one element in that tuple in the code I sent in order to recompile
11:29:04 <eschnett> infandum: you could replace “fromIntegral. product” by “product . fmap fromIntegral”
11:29:13 <cocreature> infandum: well that’s different from the code you used in GHCi
11:29:36 <cocreature> fromIntegral means that the product can be calculated using a different type
11:29:37 <infandum> ithat last one was the head of xs btw
11:29:54 <cocreature> the code you showed us before has to use something that is an instance of Floating
11:29:55 <infandum> cocreature: They are all integers until after the product
11:30:13 <cocreature> infandum: they’re not in the code you showed at the beginning of this conversation
11:30:15 <cocreature> :t (**)
11:30:16 <lambdabot> Floating a => a -> a -> a
11:30:24 <cocreature> both sides need to be an instance of Floating
11:30:26 <infandum> hence the fromIntegral
11:30:26 <cocreature> :t product
11:30:28 <lambdabot> (Num a, Foldable t) => t a -> a
11:30:39 <infandum> I mean, otherwise it would not have compiled though
11:30:40 <cocreature> infandum: right but you didn’t use that in the example that didn’t cause problems in ghci
11:30:49 <infandum> I can try it again
11:31:01 <ysahil> How to change the timeout parameter in sockets?
11:31:21 <ClaudiusMaximus> > product [6703,6790,6440,6699,6933,6751,6707] :: Int
11:31:24 <lambdabot>  -759020139851360848
11:31:38 <ClaudiusMaximus> eschnett++
11:31:38 <geekosaur> dcz__, you use <>>=) or do notation. You cannot "convert" or "get rid of the IO".
11:32:15 <infandum> uh
11:32:25 <infandum> huh
11:32:33 <infandum> well that's starting to explain it
11:32:49 <dcz__> geekosaur: whats the best way that thing i am trying to do ?
11:32:57 <infandum> yup, that solved it
11:33:12 <Tuplanolla> So it was a type defaulting problem after all, infandum.
11:33:15 <infandum> can someone explain why that happened?
11:33:49 <infandum> Why would product of a bunch of ints result in that number?
11:34:00 <Tuplanolla> > maxBound :: Int
11:34:02 <lambdabot>  9223372036854775807
11:34:04 <infandum> itsn't the accuracy the same?
11:34:10 <infandum> maxBound :: Double
11:34:17 <geekosaur> dcz__, you already used <- there, so x :: [FilePath]
11:34:21 <infandum> > maxBound :: Double
11:34:23 <lambdabot>  error:
11:34:23 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘maxBound’
11:34:23 <lambdabot>      • In the expression: maxBound :: Double
11:34:26 <geekosaur> why do you think you need to "convert"?
11:35:09 <infandum> > product [6703,6790,6440,6699,6933,6751,6707] :: Double
11:35:11 <lambdabot>  6.1638555625196704e26
11:35:13 <geekosaur> infandum, minBound/maxBound only work when the bounds are reachable by addition. Floating point doesn't work that way
11:35:16 <infandum> oh come on
11:35:24 <infandum> so I really should not be using Ints EVER
11:35:29 <Tuplanolla> There are no implicit conversions in Haskell land, infandum.
11:36:00 <dcz__> geekosaur: but line 9 doesnt work
11:36:11 <infandum> geekosaur: Characters work because of their integer conversion?
11:36:45 <geekosaur> "doesnt work" how?
11:36:54 <geekosaur> (I can already see one issue not related to types)
11:37:27 <infandum> Tuplanolla: So is the lesson here never use Ints for large numbers, only Doubles and Integers?
11:37:54 <Tuplanolla> The lesson is that when you say `fromIntegral 42 :: Double`, your `42` may actually secretly be `Int`, infandum.
11:37:57 <infandum> because we can't always guarentee the bounds of a measure for something like product
11:38:16 <dcz__> geekosaur: the .viminfo file is in $HOME, f <- findFiles x $ y ++ ".viminfo", print f, however returns []
11:38:31 <geekosaur> yes, that has nothing to do with types
11:38:33 <cocreature> infandum: at least don’t use Int for large numbers and expect them to not overflow :)
11:38:58 <infandum> Tuplanolla: Sure, but speaking in terms of computational accuracy I don't see why It can't report 6.16 etc e26 as an integer, either, because it is one
11:39:11 <infandum> as an Int I mean. That's not a haskell issue though
11:39:28 <Tuplanolla> The other lesson is that, indeed, bounded types may wrap, infandum.
11:39:36 <Tuplanolla> At least in Haskell land that's defined behavior.
11:40:03 <geekosaur> dcz__, so I see you print y. what does that return? now think about what the concatenation does
11:40:32 <ClaudiusMaximus> > let d = 1 :: Double ; (f, _) = decodeFloat d ; g = f * floatRadix d - 1 ; (_, r) = floatRange d ; s = r - floatDigits d ; m = encodeFloat g s in m  -- how to calculate the largest finite RealFloat value
11:40:34 <lambdabot>  1.7976931348623157e308
11:40:40 <infandum> Tuplanolla: I mean, I knew I was dealing with Ints the whole time until the end, the issue was that I didn't realize how large the numbers would get
11:41:00 <cocreature> > let x = -2^63 :: Int in (x, abs x) -- more fun with bounded types
11:41:02 <lambdabot>  (-9223372036854775808,-9223372036854775808)
11:41:49 <infandum> oh jou
11:41:52 <infandum> joy
11:42:14 <infandum> How much slower is just using Integer? haha
11:42:18 <cocreature> at some point I was planning to try and convince people that this should throw an exception in haskell but then I got lazy
11:42:37 <Tuplanolla> You either take the performance hit or become a numerical analyst, infandum.
11:42:53 <dcz__> geekosaur: concatinates lists, right. how can i do that then ? :D doesnt <- converts them to String or whatever ? 
11:43:00 <Tuplanolla> The latter option takes longer in the end.
11:43:05 <geekosaur> dcz__, ok, you are not getting it
11:43:15 <ChaiTRex> > 1.7976931348623157e308 ^ 50
11:43:17 <lambdabot>  Infinity
11:43:18 <geekosaur> "/home/foo.viminfo" is what you are getting
11:43:37 <geekosaur> or something similar to that. notice something missing??
11:43:38 <ChaiTRex> Why did they choose infinity for that, when it's much closer to 1.7976931348623157e308?
11:44:11 <geekosaur> because that's what ieee754 specifies?
11:44:22 <mauke> it's also much closer to 1
11:44:29 <ChaiTRex> Yeah, but why does it specify that?
11:45:49 <dcz__> geekosaur: ahh, i didnt realize that getHomeDirectory doesnt put "/" at the end 
11:46:07 <infandum> ChaiTRex: I assume it's because x ^ 50 /= x for that case
11:46:28 <geekosaur> most stuff doesn't. shell expansion is an exception (and sometimes I woish it wouldn't just because people come to think the OS magically does that for them always)
11:46:49 <infandum> ah, it shouldn't say Infinity, it should say PositivelyLarger
11:47:03 <infandum> or just Larger
11:47:07 <infandum> eh
11:47:07 <Tuplanolla> Read up on unums to feel less bad about floating-point numbers.
11:47:18 <AWizzArd> I want a data type which wraps a number:  data Foo = Foo Num   – how can this be achieved?
11:47:24 <geekosaur> that is more or less what Inf means in ieee754
11:47:42 <geekosaur> AWizzArd, Num is not a type
11:48:02 <geekosaur> and while there is a way to write that "properly" I suspect it won;t do what you want it to do
11:48:19 <ChaiTRex> Tuplanolla: That looks interesting. Thanks :)
11:48:48 <geekosaur> remember that typeclasses indicate the maximum interface, not the minimum. Num a => a means all you can use on it are the methods of Num --- not those of e.g. Fractional, or Integral, or etc.
11:49:11 <AWizzArd> Okay, makes sense.
11:50:42 <dcz__> geekosaur: thanks for your help and patience
11:51:48 <lexi-lambda> jml: can I ask you a question about your graphql-api package?
11:53:08 <infandum> Thank you everyone!
11:54:34 <Guest39376> hashcat benchmark for nvidia gtx 1050 and gtx1050ti
12:14:04 <dcz__> geekosaur: why map function doesnt work on x? x <- listDirectory y, f <- map (++ "f") x  
12:14:24 <geekosaur> dcz__, you can;t use <- with that, you must use let
12:14:43 <geekosaur> you should also sit down with an IO tutorial so that you can recognize the difference
12:14:58 <dcz__> :D haha okey
12:15:13 <geekosaur> http://www.vex.net/~trebla/haskell/IO.xhtml
12:15:35 <dcz__> thank you very much
12:19:57 <jml> lexi-lambda: sure. my rates are very reasonable.
12:20:42 <lexi-lambda> jml: :)
12:21:10 <jml> lexi-lambda: but probably best to ask it as a question on Github (or SO I guess, and then link me here). I'm just about to head offline
12:22:10 <lexi-lambda> Alright, I'll try and do that. I actually just left for lunch, but I'll type it up when I get back.
12:32:35 <mbw> The API for immutable Vectors exposes a lot of convenient functions for doing index-based work, for example ifoldr :: (Int -> a -> b -> b) -> b -> Vector a -> b. Is there any way to use these functions with mutable vectors? Do I have to unsafeFreeze them first?
12:33:31 <ph88^> oh lyxia don't spoil me plz :P
12:34:01 <ph88^> oh it's not a unboxed mutable vector ..
12:34:33 <lyxia> mbw: there aren't a lot of combinators for mutable vectors unfortunately
12:35:14 <lyxia> unsafeFreeze is dangerous because you have to make sure to force values you compute with it before mutating the vector further
12:36:39 <lyxia> ph88^: that wouldn't be purely functional!
12:37:10 <mbw> lyxia: Assuming that the restricted API is a design decision, and I really need to do destructive updates, am I "supposed" to write explicit go functions or use forM_ and the like?
12:37:40 <ph88^> lyxia, i care about speed mostly .. by the way i also found this https://hackage.haskell.org/package/combobuffer
12:38:27 <lyxia> oh interesting I hadn't seen it
12:39:38 <ph88^> lyxia, also found this https://johnlato.blogspot.nl/2011/07/circular-buffers.html
12:39:42 <qmm> https://aphyr.com/posts/342-typing-the-technical-interview
12:40:37 <lyxia> mbw: using forM_ is better because it is more explicit about control flow
12:41:28 <ph88^> ertes, you should check out that article
12:41:42 <ph88^> "It looks like not only is the Seq-based implementation pure, it outperforms my mutable-vector implementation and scales better too.  Completely unexpected.
12:41:42 <ph88^> "
12:46:33 <lyxia> using Foreign seems like a bad idea
12:47:22 <ph88^> lyxia, ok so another reasion to go with the seq-based implementation then
12:48:00 <mbw> lyxia: Does the Generic interface change anything in this regard? I don't really understand the documentation. What does the generic interface allow me to do?
12:50:06 <lyxia> mbw: all other vector interfaces are just specializations of the generic interface
12:50:16 <ertes> ph88^: i don't believe it before i test it myself…  it just doesn't make sense
12:50:51 <lyxia> mbw: So you'd use Generic if you want to write algorithms working with multiple vector types (Boxed/Unboxed/Storable).
12:51:09 <ertes> ph88^: i'll write a short benchmark of my own later
12:51:47 <ertes> he's right about scalability though…  a ring buffer has a fixed size
12:52:05 <ertes> so you need to pick the maximum size beforehand
12:52:16 <ph88^> ertes, that's quite the challange you've set yourself :P
12:52:40 <ertes> ph88^: hmm?  what?
12:52:59 <ph88^> write such a benchmark
12:53:11 <mbw> lyxia: Since I saw that Data.Vector.Generic exports ifoldl etc., would I be able to use this version on mutable vectors?
12:53:11 <ph88^> or you just gonna use the same code as the author ?
12:53:36 <ertes> no, i'll write my own
12:53:59 <mauke> qmm: hahaha
12:54:37 <lyxia> mbw: no mutable and immutable vectors are still strongly separated
12:54:53 <mbw> While it might be a personal choice to use explicit loops, I can write that kind of stuff more concisely in C++ or even Fortran...
12:55:37 <lyxia> I guess the API for mutable vectors could use some work
12:56:01 <lyxia> I hope there is an open issue about that.
12:56:23 <lyxia> https://github.com/haskell/vector/issues/159
12:59:41 <mbw> At least the author is not MIA.
12:59:50 <AWizzArd> Out of curiosity: does anyone here have an extremly fast cpu and can report the compile times for a big Haskell project (maybe ghc or ghcjs)?
13:07:39 <koala_man> AWizzArd: You could rent a beefy EC2 box for an hour for ~$2. if it helps, I have a 24 core VM with what appears to be 2.5Ghz Haswell
13:08:02 <ph88^> does this parser also apply for Data.Attoparsec.Bytestring.Lazy ?  https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:space
13:10:27 <ph88^> i guess one is suppose to combine lazy and strict parsers here
13:10:32 <ph88^> i see only examples with this
13:11:05 <lyxia> ph88^: yes the only difference is the parse function, the Parser type is the same.
13:16:09 <mbw> One more thing. Since I saw some people discussing performance-related stuff, I presume people use criterion. I encountered the problem that when I have two benchmark groups with four benchmarks each, the .html output is basicall broken. That is, no diagrams are shown and the regressions just say "OLS: xxx". It's probably not related to the number of benchmarks, but to some subtleties in the benchmarks 
13:16:15 <mbw> themselves (which are just simple summations with different folds). Has anyone encountered this problem, too?
13:16:48 <mbw> I'll just paste them.
13:18:17 <mbw> http://lpaste.net/354495 . Can anybody reproduce this?
13:18:40 <mbw> Needs an additional main = benchSum.
13:19:18 <lyxia> I have encountered something like this before, but haven't investigated it.
13:20:32 <lyxia> I think criterion is hittin NaNs somewhere.
13:21:32 <lyxia> it correlated with the fact that R^2 was getting closer to 1.
13:21:38 <brandon-stiles> Hi. I'm trying to use GHCJS and JS FFIs to use a JS SVG library, but I'm having a hard time figuring out how to use callbacks, or what the proper (reflex-frp) way of doing this: https://gist.github.com/stilesb/9d26ebd4c18ba1c29c06e7566f7418af. Are there any people here with experience working with GHCJS and JS FFIs?
13:21:49 * geekosaur thinks the core for that might be nice... if somehow they get optimized away in that specific form, criterion would likely be doing a divide by 0 on the time :)
13:21:51 <lyxia> mbw: have you tried with smaller lists
13:22:22 <ph88^> ertes, just for me to get going i was thinking to try this one https://hackage.haskell.org/package/combobuffer-0.2/docs/Data-RingBuffer-SeqBuffer.html what do you think ?
13:23:03 <mbw> lyxia: Indeed NaNs are shown in the console output. I haven't tried with smaller lists yet, I'll do that now. I just wanted to ask if this was a common problem.
13:24:19 <ertes> ph88^: no, i wrote my own…  it does 1e7 steps in 400 ms on my machine
13:24:39 <ph88^> ertes, can i have yours ?
13:24:40 <ertes> i wrote a probabilistic benchmark (but with a fixed seed) that does 70% pushes and 30% pops
13:24:51 <ertes> gimme a second, i'm still optimising the Seq variant
13:24:51 <ph88^> combobuffer is too old and has dependency conflicts
13:24:59 <ph88^> ok
13:25:06 <ertes> currently it uses memory proportional to the number of steps, so there is obviously something wrong
13:25:17 <ph88^> ok
13:28:24 <mbw> Btw, from the help menu introduced by criterion's default main, should I be able to infer the possible verbosity levels? I actually looked inside the source on hackage, saw that a sum type with three values and an Enum instance is used and thought it's probably 0-2...
13:29:34 <mbw> Ok, tests are finished. If I decrease the lists by a factor of 10, it works. Increasing them again now causes all but the first two tests to fail to produce the diagrams. So it's not really *that* reproducible.
13:32:49 <mbw> I should check github more often (don't even have an account :/). Seems to be this issue: https://github.com/bos/criterion/issues/65
13:41:00 <ertes> ph88^: the ring buffer version is about twice as fast as the Seq version…  i didn't expect the difference to be as small as it is, but it does meet my expectation that the ring buffer version is faster
13:41:10 <ertes> with that in mind i think i would recommend the Seq version
13:41:18 <ertes> let me paste my code
13:41:20 <ph88^> ertes, you mean the one based on mutable unboxed vector ?
13:41:30 <ertes> yeah
13:42:42 <ph88^> ertes, for my curiousity .. do you have any idea about the differences between your benchmark and the one from that post ?
13:42:48 <ertes> ph88^: https://github.com/esoeylemez/snippets/blob/master/ring-buffer-bench.hs
13:42:56 <ertes> no, sorry
13:43:06 <ertes> but i did try to write a highly optimised ring buffer
13:43:26 <ertes> you can probably speed it up by using specialisation and/or inlining
13:44:53 <ph88^> ertes, shouldn't the rbBench and the seqBench be driven by the same data ?
13:45:13 <ertes> interesting…  inlining made it *worse*
13:45:24 <ertes> they are driven by the same data
13:45:27 <ertes> the seed is fixed
13:45:42 <ertes> i'm using 'create' instead of 'createSystemRandom'
13:45:45 <ph88^> ertes, can i link your code from a github issue ?
13:45:51 <ertes> sure
13:46:19 <ertes> (even when using a random seed the results should be fairly similar)
13:46:56 <ertes>   real 3.990  user 3.977  krnl 0.011  cpu% 99%  mem 4m  ./ring-buffer-bench 100000000 vu
13:46:56 <ertes>   real 6.907  user 6.880  krnl 0.027  cpu% 99%  mem 4m  ./ring-buffer-bench 100000000 s
13:47:01 <ertes> these are my timings
13:47:35 <ertes> the unboxed ring buffer version finishes in about 4/7th of the time of the Seq version
13:49:55 <ph88^> ertes, why would you recommend the Seq version? I am quite confident that you wrote a nice vector implementation :P
13:50:14 <ertes> ph88^: i've just pushed a small change…  you can now benchmark with different buffer sizes
13:50:19 <EvanR_> please tell me that ring buffer produces audio without drop outs
13:50:36 <ertes> if you change the ring buffer size from 1000 to 10000, there is no measurable time difference
13:50:59 <ertes> however, the Seq version now uses almost 10 secs
13:51:52 <ph88^> ertes, could compare it to https://github.com/bgamari/ring-buffer/blob/master/src/Data/RingBuffer.hs
13:53:18 <ertes> ph88^: that version is almost certainly worse…  not necessarily by much, but worse nonetheless
13:53:29 <ertes> 'mod' is rather slow
13:53:44 <EvanR_> i heard quot is faster
13:53:55 <EvanR_> er, rem
13:53:57 <ertes> i've also not used 'min', because i can save one addition by doing it manually
13:54:03 <ertes> EvanR_: only for Integer
13:54:09 <ertes> for Int there should be no difference
13:54:25 <EvanR_> huh... Integer uses Int most of the time
13:54:28 <ph88^> well hhmm since those are all the implementations of ring buffers i round and yours should be the fastest might be worth packaging it
13:54:40 <ph88^> can i go back to the original problem statement for a moment ?
13:54:42 <ertes> let me benchmark with mod and rem
13:54:58 <ph88^> ok
13:55:56 <monochrom> Although Integer uses Int most of the time, there is still the overhead of asking "am I in the Int case?" every so often.
13:56:06 <ertes> ah, i can't even use rem =)
13:56:12 <ertes> i need mod, because i'm subtracting
13:56:23 <ertes> though pop can use rem, gimme a minute
13:56:56 <ertes> anyway, 'mod' made the run-time jump from 400 ms to 500 ms
13:57:04 <monochrom> Basically an Either type with a statistical fact "it is Left 99% of the time".
13:57:43 <ertes> 'min' made a much smaller difference: ~400 ms → ~420 ms
13:58:37 <ertes> i can't use 'mod' in pop either, because i have a short circuit there
13:59:07 <monochrom> mod has quite a bit more conditional branching and fixup than rem.
13:59:28 <monochrom> Because rem maps to an x86 instruction but mod doesn't.
14:00:17 <ertes> i think 'rem' is still slower in this case, because the conditional branch should be almost free with prediction
14:00:23 <mbw> Is there a specific reason why Unboxed vectors aren't Functors/Foldable etc.?
14:00:47 <Tuplanolla> The same reason `Set` is not either, mbw.
14:00:50 <ertes> mbw: unboxedMap :: (Unbox a, Unbox b) => (a -> b) -> Vector a -> Vector b
14:02:41 <ertes> alright, i have tried to optimise RingBuffer, but i'm giving up…  i don't think there is any room left for optimisation other than tweaking GHC flags
14:03:43 <ph88^> sweet
14:03:52 <mbw> ertes: Ok, that's neat. But there is probably a reason why Unboxed Vectors can't just be made Functors, right? Like the TypeFamilies thing?
14:04:20 <ertes> mbw: the reason is that there are constraints on the element type
14:05:08 <ph88^> ertes, why you choose to save the length in the RingBuffer ?
14:05:50 <ertes> ph88^: it's not the length of the ring buffer, but the current number of elements in the ring
14:06:01 <ph88^> ye i know
14:06:11 <ertes> ph88^: what would you do instead?
14:06:18 <ertes> oh…  wait a minute
14:06:32 <ph88^> well in only designed ring buffers in hardware
14:06:36 <ertes> i haven't implemented a ring buffer, but a stack =)
14:06:39 <ertes> let me fix it
14:06:45 <ph88^> i would use a read and a write counter
14:08:08 <ph88^> ertes, this is the best implementation of ring buffers i've seen so far https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/
14:08:15 <mbw> ertes: Ok thanks. It actually becomes clear once you try to implement it yourself.
14:10:54 <ph88^> lol ..  What kind of a monster would make a non-power of two ring? The kind that ran out of microcontroller SRAM for a large enough power of two ring, but could spare CPU cycles for an expensive modulo operation.
14:20:02 <mbw> Is there a way to pinpoint the exact cause of memory locations? Say I have located the function using time and heap profiles, where do I go from there? I know that I can make a more specific heap profile on a module basis or for specific constructors only. But what if in the end it's just something like PINNED or ARR_WORDS? Is there a way to approach this more systematically?
14:20:46 <mbw> I am of course still implicitly referring to my struggle with the vector library...
14:21:23 <ph88^> what you need the memory locations for
14:24:10 <dcz__> geekosaur: thank you very much, i am like enlightened. really appreciated for the tutorial 
14:24:44 <dcz__> i can't believe that for the first time i did something what i am doing :D
14:25:09 <dcz__> i know what i am doing first time :D
14:25:45 <mbw> I was implementing some example code from the book "Haskell High-Performance Programming". Specifically, a bubblesort implementation using mutable vectors. The authors claimed a runtime of 1.55 sec or something for a vector of 10000 random elements. For me it was something like 2 minutes initially. I was able to reduce it to 15 seconds or so, but there are still a surprisingly large number of allocations 
14:25:51 <mbw> involved. I pinpointed it to a function that does a foldM on an immutable vector of indices (which I had to float out manually with a let binding, since it was regenerated every time). The iteration is mapped on swapping vector elements. I wouldn't expect many allocations for that.
14:26:15 <mbw> The swap routine should be able to allocate temps on the stack if the values are unboxed, the way I understand it.
14:26:33 <mbw> To be honest, I didn't go for the full go function yet.
14:26:45 <kuribas> mbw: are you using an unboxed vector?
14:26:49 <mbw> Yes.
14:27:42 <kuribas> mbw: you aren't copying vectors?
14:27:48 <mbw> s/iteration/iteration\ space/.
14:28:02 <kuribas> mbw: you should use ST monad for mutating the vector.
14:28:33 <brandon-stiles> Ah! Here we go, this looks like it works: https://github.com/ghcjs/ghcjs/blob/master/doc/foreign-function-interface.md
14:29:08 <kuribas> mbw: you could try to see if fusion works, but it may not kick in.
14:29:16 <kuribas> mbw: also for fusion you must enable optimizations.
14:29:17 <mbw> The bubblesort just invokes a bubblesortM function that works on mutable unboxed vectors (though with a polymorphic signature, like in the book). I replaced the runST $ do ... stuff with create and it didn't make a difference.
14:29:50 <kuribas> mbw: mutating an unboxed vector shouldn't do any allocations.
14:29:55 <mbw> Yeah I did compile it with -O2. Haven't figured out how to use -fllvm though, since I have multiple versions installed.
14:30:39 <kuribas> that shouldn't be necessary
14:30:52 <kuribas> unless you want SIMD
14:31:18 <mbw> Then that is the reason I'd like to find out exactly what is causing those allocations. And I don't want to do this by trial-and-error, it should be clear that this is for pedagogical reasons :)
14:32:00 <ph88^> mbw, for llvm you need 3.5 and have the 2 binaries in path
14:32:10 <mbw> To be honest, I did it inside a stack project with a Lib.hs and a Main.hs.
14:32:33 <mbw> ph88^: I think it's 3.7 by now, and according to the ghc page 3.9 for HEAD.
14:32:37 <ertes> ph88^: fixed
14:32:42 <ertes> and still same speed
14:32:54 <mbw> I do have them installed, but have to figure out this update-alternatives thing.
14:32:54 <ph88^> mbw, i think a month ago or so it was still at 3.5 then
14:33:19 <ph88^> ertes, you ask me how would i done it, take a look at https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/
14:33:26 <mbw> Are you using GHC 8.0?
14:33:44 <ph88^> ye
14:33:49 <ph88^> what's left and right now ?
14:34:16 <kuribas> mbw: could you plast some code?
14:34:21 <kuribas> mbw: paste
14:34:25 <ph88^> ertes, left - write counter,  right - read counter ?  
14:34:29 <mbw> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/Installing
14:34:42 <mbw> Sure thing.
14:36:07 <ertes> ph88^: i'm using that approach, except that i'm using -1 instead of i + 1
14:36:18 <ph88^> ok
14:37:02 <ertes> doesn't make a difference, because you need the branch on emptiness anyway
14:37:36 <ertes> in fact i believe my approach is even better, because i can check for emptiness without arithmetic
14:38:01 <ertes> as you see in rbPop, i'm not even asking for the second index, if the buffer is empty
14:39:19 <mbw> Here it is: http://lpaste.net/354496 .
14:40:18 <mbw> I think I had an inline pragma for f at some point, and removed it.
14:44:18 <ph88^> ertes, *** Exception: user error (Pattern match failure in do expression at /home/ph88/haskell/ring/src/Main.hs:115:5-32)
14:44:55 <ph88^> oh some args suppose to go there
14:45:16 <ph88^> how can i call main with some arguments from ghci ?
14:46:02 <geekosaur> ph88^, use :main
14:46:15 <mbw> :set args should work
14:46:33 <geekosaur> or, import System.Environment and use withArgsDo
14:48:05 <ph88^> ertes, i want to test it, but i can't so quickly
14:48:11 <ph88^> i will test it tomorrow
14:48:17 <ph88^> can i ask a question about the original problem  ?
14:49:28 <kuribas> mbw: your indices array may cause allocations...
14:50:05 <ertes> ph88^: try this:  ./test 1000 10000000 vu
14:50:11 <adarqui> hi. how can i simplify my "forever alone" haskell line, so that it only has "forever" and "()", and perhaps one infix operator.. ie, forever $ pure () , would be nicer if it was: forever =<< ()
14:50:30 <deech> Hi, how do I file a bug against `syb`? The issues page is Google Code archive https://code.google.com/archive/p/scrapyourboilerplate/issues.
14:50:34 <ertes> ph88^: this selects the unboxed vector variant with a ring buffer of size 1000 and 10000000 iterations
14:50:39 <mbw> kuribas: To be fair, it's more or less the implementation from the book (probably a sales pitch for the clever fusion stuff).
14:51:01 <ph88^> ertes, yeah i mean go deeper into the algorithm and check the assumptions you made there ..  but ye ok i can run the benchmark .. 
14:51:02 <ertes> ph88^: options other than "vu" include "vb" (boxed vector) and "s" (Seq)
14:51:17 <kuribas> mbw: fusion isn't always predictable
14:51:28 <geekosaur> deech, I'd try https://github.com/dreixel/syb/issues
14:51:39 <geekosaur> since that's the clone url
14:51:51 <geekosaur> (with the issue tracker appended_
14:51:54 <deech> Nice, thanks!
14:53:13 <kuribas> mbw: also indices is used twice, so it may not be inlined...
14:53:27 <ph88^> ertes, vu is the fastest here
14:54:14 <mbw> I would try to profile it again, but stack decided to rebuild the dependencies...
14:54:38 <mbw> Can I safely ^C it?
14:55:00 <mbw> I forgot I added criterion to the dependencies, with a different resolver.
14:55:10 <lexi-lambda> jml: I asked a question on stack overflow http://stackoverflow.com/q/43333486/465378
14:55:15 <kuribas> mbw: try inlining it yourself...
14:55:39 <kuribas> mbw: and compare with an explicit loop.
14:55:58 <pungi-man> Hey! I have just started with haskell today. I installed stack on my ubuntu laptop and I tried running the command `stack setup`. I am getting this error. http://paste.ubuntu.com/24357062/ . Now I am under a proxy and I can't always comment out the variable when developing haskell because my other functionality will not work. Is there a solution for my problem?
14:57:07 <ChaiTRex> pungi-man: If it's an environment variable, try VARIABLE_NAME="" stack setup
14:57:57 <ChaiTRex> pungi-man: So like: https_proxy="" stack setup
14:58:23 <pungi-man> ChaiTRex: Thanks! I think that error is solved. But now there is another error. "HostCannotConnect "s3.amazonaws.com" [connect: does not exist (Connection refused)]"
14:58:45 <mbw> kuribas: I'll try that in a minute, once stack is finished building.
14:58:49 <pungi-man> http://paste.ubuntu.com/24357086/
14:59:07 <ChaiTRex> pungi-man: That's a weird error message, since it has to exist to get a connection refusal.
14:59:10 <scav> Is there something I am not getting? If I replace the second last 'y' with an x, it works just fine. fn :: (x -> y) -> y -> y; fn xy x = xy x 
14:59:15 <ChaiTRex> pungi-man: Not sure what to do about that.
14:59:18 <ertes> ph88^: yeah, as expected
14:59:35 <mbw> kuribas: But still, this is all very ad-hoc...
14:59:37 <ertes> ph88^: also it scales much better, because you can pretty much select arbitrary ring buffer sizes without changing the performance
14:59:59 <kuribas> mbw: you could look at the core for more information :)
15:00:35 <ski> scav : the argument type of the function `xy' must be the same as the type of the actual argument you pass to it, namely `x'
15:00:45 <pungi-man> ChaiTRex: Okay thanks! I just started out today so I don't know many things. Does stack try to download something while running `stack setup`? If that's so, can I download it using something else and pass it to `stack setup`?
15:00:46 <ertes> ph88^: if you find this useful, i can turn it into a library tomorrow
15:00:59 <scav> ski so if i were to pass in 'y', it should work?
15:01:26 <geekosaur> pungi-man, https://github.com/commercialhaskell/stack/issues/1165 suggests stack doesn't do what you need
15:01:27 <ChaiTRex> pungi-man: I'm not sure about that, sorry.
15:01:32 <ski> scav : there's no (value-level) variable named `y' in that snippet of code
15:01:51 <geekosaur> stack setup wants to download a package index. I don't know if you can do that manually
15:01:51 <scav> ski then I guess I should go back and read some more :)
15:01:54 <scav> thanks!
15:02:06 <ph88^> ertes, i'd love that
15:02:39 <ski> scav : it might perhaps help unconfuse things a bit (either for you, or for people trying to help, or both), if you didn't use the same name for a value variable as for a type variable ..
15:02:54 <pungi-man> geekosaur: Thanks a lot! That worked for me :)
15:02:54 <ph88^> ertes, i like to talk a bit how i'm gonna use the ring buffer with the program .. but i'm dead tired from kayak still and i have to work tomorrow. Nice effort on the ring buffer, talk later, byeee
15:03:28 <geekosaur> ah, so yours will let you http? then you're ok. it's specifically using an https: url for an https proxy that stack apparently does not support
15:03:29 <scav> ski thank you, noted :)
15:03:37 <ertes> ph88^: sure…  good night =)
15:04:49 <pungi-man> geekosaur: Yes it is allowing http.
15:04:50 <ski> scav : .. when you're more familiar with the type system, it can sometimes help, though
15:05:01 <kuribas> mbw: you could try if specialization helps, but it probably gets specialized by ghc...
15:05:24 <scav> ski sure, thank you for the feedback and tip
15:06:04 <ski> (people trying to help could be confused about whether you're confused about the value or the type variable, if you don't say explicitly)
15:06:35 <mbw> kuribas: Compiling with -Weverything will emit warnings like "Could not specialize[...]". Of course this is not a proof that everything not warned about was specialized...
15:07:02 <mbw> kuribas: Did you try running it?
15:08:43 <kuribas> not yet...
15:13:16 <kuribas> mbw: I get 36 sec without specialize, 32sec with
15:14:46 <mbw> I should be done building anytime now... (Currently the machine is swapping :( )
15:19:38 <mbw> kuribas: According to the book's author it took 1.55 sec for him. That is using the polymorphic signature and boxed vectors.
15:19:44 <kuribas> mbw: I am downto 30 with V.EnumFromN
15:19:52 <kuribas> mbw: maybe he has a supercomputer?
15:20:31 <mbw> He actually mentions GHC 8.0 extensions etc., so he probably used that as well...
15:20:45 <kuribas> I have ghc 8.2 ...
15:21:04 <mbw> Oh, has it been released already?
15:21:08 <geekosaur> rc1
15:22:32 <mbw> Oh boy am I looking forward to my vim plugins failing again.
15:24:19 <mbw> kuribas: Couldn't this be inside the tolerance?
15:25:22 <kuribas> what tolerance?
15:26:04 <mbw> The times you measured. 30 vs. 32 or even 36. Are they reproducible?
15:27:04 <mbw> I'm starting to get the impression bubblesort sucks D:
15:27:12 <EvanR_> lol
15:27:49 <EvanR_> n^2
15:30:16 <mbw> If my machine is just a _little_ slower, would that "propagate" quadratically as well?
15:30:57 <mbw> Sorry if that's a stupid question, it's been a long day...
15:31:55 <dcz__> how can we flip map arguments ? for example i do , map list (++ "F"), other then this "F"++EachListElement
15:32:41 <Tuplanolla> :t flip map -- Just ask, dcz__.
15:32:41 <jle`> dcz__: not sure i understand your question, but you can use flip?
15:32:42 <lambdabot> [a] -> (a -> b) -> [b]
15:32:55 <jle`> > flip map [1..10] succ
15:32:57 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
15:33:12 <dcz__> i did it actually but doesnt work like i imagined, still adding to the end
15:33:25 <geekosaur> dcz__, do you want to flip the arguments to map itself, or those to the mapping function?
15:33:28 <jle`> what are you trying, and what result do you get, and what result do you want?
15:33:38 <geekosaur> the latter is ("F" ++)
15:33:49 <dcz__> i have files list and i want to add something to the end
15:33:58 <jle`> can you show an example
15:34:08 <dcz__> sorry to the beginng not the end
15:34:10 <jle`> > map (++ "F") ["abc","def","ghi"]    -- ..?
15:34:11 <lambdabot>  ["abcF","defF","ghiF"]
15:34:18 <jle`> > map ("F" ++) ["abc","def","ghi"]    -- ..?
15:34:19 <dcz__> sorry to the beginng not the end 
15:34:19 <lambdabot>  ["Fabc","Fdef","Fghi"]
15:34:32 <dcz__> i did this too, ugh :D
15:34:35 <jle`> or you can write the explicit function
15:34:37 <dcz__> one moment
15:34:50 <jle`> > map (\x -> "F" ++ x) ["abc","def","ghi"]
15:34:51 <lambdabot>  ["Fabc","Fdef","Fghi"]
15:34:58 <jle`> > map (\x -> x ++ "F") ["abc","def","ghi"]
15:35:00 <lambdabot>  ["abcF","defF","ghiF"]
15:35:03 <jle`> your function can really be whatever you want
15:36:02 <dcz__> here is the function and the error , 
15:36:06 <dcz__> https://hastebin.com/zusizenafa.hs
15:37:58 <joe9> what is a good material to learn about kinds? I am clueless when the parameters in the function definition. such as in this line : instance (GIBFormat f, Constructor c) => GIBFormat (M1 C c f) where , I cannot figure out how to get more details on the C, c and f
15:38:01 <dcz__> omg , it was because of i did not put these around () that? 
15:38:29 <dcz__> fIOtFs a b = map ((b++"/") ++) a , this worked
15:39:15 <geekosaur> yes, section syntax is a bit finiky
15:39:19 <geekosaur> *finicky
15:39:21 <jle`> if you are having problems, you can also just write the explicit lambda
15:39:34 <jle`> map (\x -> b ++ "/" ++ x)
15:39:36 <geekosaur> it doesn't udnerstand associativity, so it doesn't know which operator is to be the one the section applies to
15:39:48 <jle`> also i'd suggest that you use something like </> instead of ++ "/"
15:40:43 <dcz__> okey cool
15:42:37 <jle`> just as a different issue :)
15:42:45 <jle`> unrelated.
15:44:41 <kuribas> mbw: I had to restart my computer, because my modifications caused a space leak.
15:45:43 <mbw> That's one hell of a space leak.
15:46:01 <kuribas> yeah
15:46:48 <kuribas> I don't get why the kernel doesn't just refuse to give memory that isn't there...
15:48:00 <mbw> I only had to hard-reset when I didn't have designated scratch space. I made an 8G swap file since then.
15:48:40 <EvanR_> kuribas: performance
15:48:52 <EvanR_> but you can change it to act that way
15:49:02 <Tuplanolla> I learned that lesson and always run with `+RTS -M1GM`, kuribas.
15:49:17 <kuribas> EvanR_: I should disable swap, it's useless anyway.
15:49:27 <kuribas> Tuplanolla: ok, thanks
15:49:42 <monochrom> I think you don't want the 2nd M, but yeah.
15:49:52 <Tuplanolla> Right you are, monochrom.
15:49:55 <mbw> Megagigs?
15:52:23 <monochrom> ghc -j65536 +RTS -M1000000G :)
15:53:17 <mbw> That's how the NSA does it.
15:53:49 <mbw> They probably use GHC 9.0, too
15:54:04 <bollu> is there a "pure" way of colorising ANSI text?
15:54:25 <int-e> monochrom: you seem to be exceeding the addressable space for current 64 bit systems
15:54:34 <bollu> every library seems to invoke IO, but I though that ANSI color escapes were well established?
15:54:58 <monochrom> Oh oops
15:55:06 <kuribas> mbw: I think that's a bug btw...
15:55:18 <mbw> What is?
15:55:55 <monochrom> Ah we could revive the EMS trick used during the 8088 days.
15:56:11 <monochrom> ghc -j65536 +RTS -M1000000G -fEMS :)
15:56:31 <glguy> bollu: for some control sequences it's not enough to emit a particular set of characters with a normal write
15:56:40 <bollu> glguy: I see :(
15:57:17 <mbw> monochrom: What does that do? Is it some segmented memory voodoo?
15:58:04 <int-e> mbw: it's a hardware mechanism that allows swapping out the physical memory that underlies a fixed window in the physical address space.
15:58:45 <geekosaur> bollu, glguy, actually what I see is that most of them want to support Windows, and until Windows 10 you couldn't do it with escape sequences, you had to call device control functions
15:59:27 <bollu> geekosaur: hm, are you aware of any library that is pure?
16:00:00 <Tuplanolla> @hackage ansi-terminal
16:00:00 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
16:00:22 <geekosaur> Tuplanolla, that's not pure, all the functions are in IO
16:00:24 <Tuplanolla> See "strawberry", bollu.
16:00:48 <bollu> Tuplanolla: yeah, but windows 10 has the fancy linux subsytem thing
16:00:52 <geekosaur> also, the ones that don;t go for Windows compat use terminfo
16:00:58 <geekosaur> so also can't be pure
16:01:11 <monochrom> mbw: https://en.wikipedia.org/wiki/Bank_switching
16:01:12 <bollu> oh, wait what, I can change to "Strawberry"?
16:01:31 <Tuplanolla> You can just ignore all the `IO` functions, bollu.
16:01:42 <bollu> Tuplanolla: cool, ty :)
16:01:58 <bollu> Tuplanolla: much appreciated
16:02:06 <mbw> Thanks for the link.
16:02:13 <mbw> And the explanation.
16:05:03 <bollu> quick offtopic question if I may: how does one touch type "+", "-" and "?" I'm trying to unlearn fucked typing habits.
16:05:57 <Tuplanolla> How does one touch type Alt + F4?
16:06:11 <bollu> I have no idea
16:06:15 <ChaiTRex> bollu: For the outer ones, press shift with one hand and the key with the other hand.
16:06:35 <bollu> ChaiTRex: ah, thanks, that may help
16:06:47 <ChaiTRex> Tuplanolla: You can probably do that with your left hand, thumb on alt and middle finger on F4.
16:07:13 <Tuplanolla> I've developed some kind of semitouch typing where my hands wander and fingering patterns are correlated in time.
16:07:44 <mbw> kuribas: What bug were you talking about?
16:07:57 <Tuplanolla> I can't imagine trying to teach it to anyone.
16:08:14 <kuribas> mbw: A bug that causes a space like with -O2
16:08:19 <kuribas> leak
16:08:47 <kuribas> mbw: and with a nested monad
16:11:36 <mbw> The version I got currently runs in constant space, with 15M maximum residency or so.
16:12:27 <mbw> Right now I am trying to make some sense out of the profiler output. Is there some way to visualize it as a call graph or make it more concise? Everything runs off to the right.
16:14:23 <mbw> kuribas: Did you use nested forMs? I think there is an open bug on the ghc page.
16:14:59 <kuribas> mbw: no, just a handrolled loop.
16:16:56 <mbw> So what did you need nested monads for? As i understand it, a handrolled loop is a strict go function.
16:18:09 <iqubic> What does Data.Complex gain from having Monad, Applicative, and Functor instance? As well as Foldable???
16:19:49 <iqubic> I guess it allows you to do things like this:
16:20:09 <iqubic> > (1 :+ 2) >>= (+1)
16:20:11 <lambdabot>  2.0 :+ 0.0
16:20:24 <iqubic> Err, what???
16:20:48 <iqubic> > (1 :+ 2) <$> (+1)
16:20:50 <lambdabot>  error:
16:20:50 <lambdabot>      • Couldn't match expected type ‘a -> b’
16:20:50 <lambdabot>                    with actual type ‘Complex Integer’
16:21:16 <iqubic> > (+1) <$> (1 :+ 2)
16:21:18 <lambdabot>  2 :+ 3
16:21:33 <iqubic> Alright, what is different between those?
16:21:43 <lyxia> > (1 :+ 2) >>= \x -> return (x + 1)
16:21:45 <lambdabot>  2 :+ 3
16:21:59 <Koterpillar> :t (+1)
16:22:01 <lambdabot> Num a => a -> a
16:22:16 <Koterpillar> :t (\x -> return (x + 1)
16:22:17 <Koterpillar> :t (\x -> return (x + 1))
16:22:18 <lambdabot> error:
16:22:18 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
16:22:19 <lambdabot> (Num a, Monad m) => a -> m a
16:22:19 <lyxia> ah
16:22:39 <lyxia> (1 :+ 2) >>= (+1) , the first argument has type Complex (Complex something)
16:22:45 <iqubic> > (1 :+ 2) >>= (+1)
16:22:47 <lambdabot>  2.0 :+ 0.0
16:23:05 <iqubic> No, I think the first argument has type complex int.
16:23:11 <iqubic> :t (1 :+ 2)
16:23:12 <lambdabot> Num a => Complex a
16:23:21 <iqubic> What???
16:23:22 <lyxia> > (1 :+ 2 :: Complex Int) >>= (+1)
16:23:25 <lambdabot>  error:
16:23:25 <lambdabot>      • Couldn't match type ‘Int’ with ‘Complex b’
16:23:25 <lambdabot>        Expected type: Int -> Complex b
16:23:29 <lyxia> > (1 :+ 2 :: Complex (Complex Int)) >>= (+1)
16:23:31 <lambdabot>  error:
16:23:32 <lambdabot>      • No instance for (RealFloat Int) arising from the literal ‘1’
16:23:32 <lambdabot>      • In the first argument of ‘(:+)’, namely ‘1’
16:23:38 <lyxia> > (1 :+ 2 :: Complex (Complex Double)) >>= (+1)
16:23:41 <lambdabot>  2.0 :+ 0.0
16:24:07 <iqubic> lyxia, why is the first argument of type Complex Complex Double?
16:24:19 <iqubic> And why does the imaginary part go to zero?
16:24:55 <biglambda> Is there as version of the lens operator (.=) that allows the second operand to be monadic
16:24:55 <Koterpillar> > (1 :+ 1) :+ (1 :+ 1)
16:24:58 <lambdabot>  (1 :+ 1) :+ (1 :+ 1)
16:25:29 <iqubic> I get that. But how does that help me Koterpillar ?
16:25:43 <iqubic> :t (1 :+ 1) :+ (1 :+ 1)
16:25:43 <lyxia> iqubic: look at the type of (>>=) :: m a -> (a -> m b) -> m b and the type of (+1) :: Num c => c -> c
16:25:44 <Koterpillar> I'm not sure
16:25:44 <lambdabot> Num a => Complex (Complex a)
16:25:54 <Gurkenglas_> biglambda, (<~)
16:26:00 <lyxia> iqubic: c -> c must unify with (a -> m b), therefore c ~ a ~ m b
16:26:16 <lyxia> iqubic: so the first argument of >>= must have type m a ~ m (m b)
16:26:26 <iqubic> I see.
16:26:43 <iqubic> So what does it do to make the first argument the right type?
16:27:14 <lyxia> then it sees (1 :+ 2) which must be some Complex d, so it unifies m ~ Complex, d ~ m b
16:27:32 <iqubic> > (1 :+ 1) >>= (:+ 3)
16:27:32 <biglambda> 7,1Gurkenglas_  
16:27:34 <lambdabot>  1 :+ 3
16:27:35 <biglambda> Thanks
16:27:47 <iqubic> What the heck is up with that example??
16:28:03 <iqubic> I don't understand the monad instance of Complex, what is good for?
16:28:26 <lyxia> thus we get Complex (Complex b) for some b which must be an instance of Num, but also RealFrac because you are using (+1) on c ~ Complex b and so b gets defaulted to Double
16:28:40 <iqubic> I see,
16:28:46 <lyxia> I'm pretty sure it's just there to confuse you
16:29:08 <iqubic> Really. I can't see anyway this monad instance could be helpful.
16:29:15 <iqubic> See this weirdness:
16:29:17 <iqubic> > (1 :+ 1) >>= (:+ 3)
16:29:19 <lambdabot>  1 :+ 3
16:29:29 <iqubic> That does weird stuff.
16:29:30 <Koterpillar> instance Monad Complex where   a :+ b >>= f = realPart (f a) :+ imagPart (f b)
16:29:59 <iqubic> Oh, I see.
16:30:09 <iqubic> I also see how my example works.
16:30:24 <iqubic> That's helpful, I suppose.
16:30:58 <codedmart> Trying to understand lenses. If I have `data SomeType = SomeType { someField :: Maybe Integer }` what does a `incSomeField` function look like that is `SomeType -> SomeType` and increments `someField` by `1` if it is `Just`? I know you can just write this as a function without lenses, but just trying to wrap my head around lenses a bit.
16:31:05 <lyxia> works just like ZipList
16:31:12 <iqubic> > return 2 :: Complex Double
16:31:14 <lambdabot>  2.0 :+ 2.0
16:31:15 <codedmart> I feel like I get it some, but then I feel confused.
16:31:20 <iqubic> That looks good.
16:31:26 <iqubic> I understand that.
16:31:34 <lyxia> well not quite since ZipList is not actually a Monad
16:31:49 <lyxia> "ZipVec"
16:33:10 <iqubic> Why is it that Data.Complex is foldable, and traversable?
16:33:45 <lyxia> codedmart: so makeLenses will give you a lens from SomeType to Maybe Integer, then _Just gives you a prism from Maybe Integer to Integer, finally you can just use set or something
16:33:57 <lyxia> to operate on that Integer
16:34:04 <lyxia> iqubic: because we can
16:34:17 <iqubic> Really. 
16:34:25 <iqubic> ??!!??!
16:34:42 <iqubic> What's an example of folding being used with complex numbers?
16:35:07 <Tuplanolla> > sum (42 :+ 13)
16:35:09 <lambdabot>  55
16:35:49 <iqubic> > fold (sum 5 :+ sum 10)
16:35:51 <lambdabot>  error:
16:35:51 <lambdabot>      • Could not deduce (Num (t0 m))
16:35:51 <lambdabot>        from the context: (Num (t m),
16:35:55 <mbw> kuribas: Ok, I wrote it down in c++. Takes 0.2ms.
16:36:01 <iqubic> > fold (Sum 5 :+ Sum 10)
16:36:03 <lambdabot>  Sum {getSum = 15}
16:36:15 <lyxia> An insane way of computing the complex modulus.
16:36:17 <iqubic> > fold (Product 5 :+ Product 10)
16:36:19 <lambdabot>  Product {getProduct = 50}
16:36:25 <Sornaensis> :t fold
16:36:27 <lambdabot> (Monoid m, Foldable t) => t m -> m
16:36:47 <Gurkenglas> > sqrt . sum . fmap (^2) $ 3 :+ 4
16:36:49 <lambdabot>  5.0
16:36:58 <iqubic> Gurkenglas: What is that doing?
16:37:06 <Sornaensis> :t (:+)
16:37:07 <lambdabot> a -> a -> Complex a
16:37:15 <Sornaensis> > 2 :+ 1
16:37:17 <lambdabot>  2 :+ 1
16:37:21 <Gurkenglas> Computing the distance of (3 :+ 4) from (0 :+ 0)
16:37:22 <kuribas> mbw: lol
16:37:35 <Sornaensis> > fmap (^) $ 2 :+ 1
16:37:37 <lambdabot>  <Integer -> Integer> :+ <Integer -> Integer>
16:37:38 <kuribas> mbw: same algorithm? 10000 doubles?
16:37:45 <lyxia> codedmart: someFieldLens . _Just %~ (+1) $ SomeType (Just 32)   I guess
16:37:53 <iqubic> Gurkenglas: See this
16:38:09 <iqubic> > magnitude $ 3 :+ 4
16:38:11 <lambdabot>  5.0
16:38:16 <mbw> yeah
16:38:27 <iqubic> Simpler way of doing the same thing.
16:38:30 <mbw> The one from wikipedia.
16:38:39 <mbw> Currently doing a brute-force translation.
16:38:44 <iqubic> What does foldr do?
16:39:19 <codedmart> lyxia: So is the benefit more noticed when dealing with nested data?
16:39:20 <iqubic> foldl (+) 10 (1 :+ 1)
16:39:29 <iqubic> > foldl (+) 10 (1 :+ 1)
16:39:31 <lyxia> codedmart: yes
16:39:31 <lambdabot>  12
16:39:40 <iqubic> just as I expected.
16:39:53 <iqubic> > length (1 :+ 0)
16:39:55 <lambdabot>  2
16:39:58 <codedmart> lyxia: Thanks!
16:40:17 <iqubic> won't the length of a complex number always be 2?
16:40:23 <Gurkenglas> Is it simpler just because it's been given its own name? (Hmm I assume that the scaling in http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.Complex.html#magnitude has a purpose so that one's probably better to use.)
16:40:56 <iqubic> What scaling?
16:41:22 <Gurkenglas> I'm just refering to what it's doing with the scaleFloat k
16:41:53 <ClaudiusMaximus> the purpose is to avoid overflow or underflow for large or small results, afaik
16:41:56 <iqubic> Ah. Yeah. I said it was simpler because it was a single function.
16:42:25 <iqubic> > maximum (1 :+ 2)
16:42:28 <lambdabot>  2
16:42:39 <iqubic> > minimum (1 :+ 2)
16:42:40 <mbw> kuribas: Sorry, that is 0.2sec, not ms.
16:42:41 <lambdabot>  1
16:42:48 <mbw> My bad.
16:42:56 <kuribas> mbw: still...
16:42:59 <joe9> need some advice, please? I am reading a constructor name in while building a generic parser. Normally, when reading any other attributes, I do parse = fmap Constructor valueParsed . But, if I am reading a costructor name as the parsed value, I cannot figure out how to convert the valueParsed to the Constructor. I can have a matchName :: String -> Datatype (but that seems too much work)
16:43:28 <robertkennedy> Where can I find base-4.10.*? 
16:43:31 <joe9> for example , matchName "Constructor" = Constructor
16:43:58 <joe9> but, I would be doing that for all data types and I wish there is a better way of going about it.
16:44:08 <iqubic> > 5 `elem` (20 :+ 30)
16:44:10 <lambdabot>  False
16:44:26 <iqubic> cool. I know understand complex numbers a lot better.
16:44:34 <iqubic> repls are amazing.
16:46:51 <iqubic> Why doesn't Java have a repl?
16:46:56 <iqubic> Would be so awesome.
16:47:01 <Koterpillar> Groovy does
16:47:39 <Gurkenglas> You can kinda evaluate expressions based on the variables in scope with the debugger
16:47:54 <monochrom> Complex is a Foldable?! This is surreal.
16:48:29 <ClaudiusMaximus> robertkennedy: i'm guessing it comes with ghc-8.2 (rc1 of which just got released), seeing as ghc-8.0.2 comes with base-4.9.1.0 and new ghc major versions typically increment the second number
16:48:35 <Tuplanolla> Oh, but surreal numbers are different.
16:48:41 <monochrom> Heh
16:48:41 <iqubic> monochrom: Why is that surreal?
16:48:42 <EvanR_> what isn't foldable? (that has the right kind)
16:49:02 <mbw> This isn't easy at all...
16:49:10 <EvanR_> surreals library plz
16:49:21 <monochrom> The stage is set for Complex (IO Double) -> IO (Complex Double)
16:49:25 <johnw> EvanR_: since there are really no laws, and anything could define foldMap _ _ = mempty, I think anything is Foldable
16:49:41 <EvanR_> that is what i suspected
16:49:52 <johnw> in those cases, folding just means "ain't nothing to see here"
16:49:58 <kuribas> mbw: I got it down to 0.3sec by specializing bubblesortM as well.
16:50:30 <Gurkenglas> joe9, does matchName happen to be equal to read?
16:51:03 <kuribas> mbw: ghc only does specializing when it's in the same module
16:51:09 <Gurkenglas> (When you attach deriving (Read, Show) to Datatype's definition)
16:51:12 <kuribas> mbw: maybe that's why it worked in the book.
16:52:13 <dcz__> guys, what should be the "undefined" part at line 21 ? https://hastebin.com/aboduwaxog.hs
16:52:48 <robertkennedy> ClaudiusMaximus: yeah, that's where my interest comes from. 
16:52:54 <joe9> Gurkenglas: very good point. When I think about it, it is a read. let me think about attaching the Read to the datatype's definition.
16:53:11 <iqubic> dcz__: What should that function do?
16:53:18 <mbw> kuribas: That sounds awesome! Could you paste your version?
16:53:28 <kuribas> sure...
16:53:29 <dcz__> should find files with extension ".webm"
16:53:36 <mbw> Also it seems realistic :)
16:53:40 <Gurkenglas> dcz__, looks like homework. I'm guessing other files should be filtered out?
16:53:52 <iqubic> And what if a file doesn't have the extention ".webm"?
16:53:58 <dcz__> not homework, i just practice to understand how haskell works
16:54:11 <iqubic> I think ff stands for fileFilter
16:54:35 <Gurkenglas> dcz__, why isn't it 'b == ".webm"' in line 20?
16:54:36 <dcz__> iqubic: thats the point where i am struggling , what if it doesnt have .. :D
16:54:54 <iqubic> dcz__: What would you like to have happen?
16:54:58 <dcz__> Gurkenglas, right :D
16:55:10 <dcz__> iqubic: it should skip it ofc
16:55:23 <monochrom> Then it is simply "ff xs"
16:55:25 <kuribas> mbw: http://lpaste.net/354496#a354500
16:55:46 <iqubic> Then Otherwise = ff xs
16:55:55 <monochrom> with lowercase o
16:55:59 <iqubic> Just don't append the current file onto the head of the list.
16:56:03 <dcz__> i did that but , *** Exception: Main.hs:(19,1)-(23,31): Non-exhaustive patterns in function ff
16:56:04 <kuribas> mbw: also vector recommends enumFromN
16:56:08 <dcz__> thats why i am asking
16:56:14 <iqubic> did what?
16:56:16 <monochrom> Yes, ff [] = ???  This is the base case.
16:56:24 <Gurkenglas> dcz__, after you've fixed that, consider defining ff like "ff = filter ..."
16:56:44 <iqubic> That makes more sense.
16:57:06 <dcz__> ff [] = ??? something real or ? :D
16:57:22 <monochrom> I mean that you need to fill in something for ???
16:57:23 <Gurkenglas> ??? is more ? than real
16:57:32 <dcz__> ff [] = [] 
16:57:33 <dcz__> cool
16:58:07 <iqubic> sure, that works.
16:58:26 <monochrom> You see the value in sharpening your thinking and your narrative, and not resort to "you know what I mean of course".
16:59:05 <dcz__> cool, now i think should this with filter :D
16:59:19 <monochrom> Yes, this is a classic application of filter.
16:59:23 <iqubic> Now, how would *you* write ff with a filter?
16:59:43 <monochrom> The code of filter is actually like what you already have, just a bit more general.
16:59:46 <dcz__> first i need to know how filter works :D
17:00:37 <Welkin> dcz__: write your own filter
17:00:41 <iqubic> I would do this:
17:00:42 <Welkin> it is just a fold
17:00:48 <Welkin> which is just a recursive function
17:00:59 <iqubic> :t filter
17:01:01 <lambdabot> (a -> Bool) -> [a] -> [a]
17:01:46 <iqubic> ff xs = filter (b /= ".webm") xs
17:01:55 <monochrom> No.
17:02:04 <mbw> kuribas: Seriously, that's it? I'll try that out right away. Also, are these recommendations part of the documentation?
17:02:05 <iqubic>    where b = snd (splitExtension)
17:02:29 <iqubic> Wait, it's not that simple.
17:02:32 <dcz__> no no dont tell me the answer pls :D
17:02:42 <iqubic> Sorry, I'll let you do it on your own.
17:02:46 <kuribas> mbw: it's in the ghc documentation, and in various tutorials
17:02:54 <iqubic> Also, what I wrote is not quite right either.
17:03:05 <iqubic> Not going to post the correct one.
17:03:07 <kuribas> mbw: just remember that ghc only specialized functions if they are called in the same module.
17:03:11 <dcz__> cool :D
17:03:23 <dcz__> i will ask soon 
17:03:39 <kuribas> mbw: And in this case specializing bubblesortM seemed to be necessary as well.
17:03:48 <iqubic> Is there a function that takes a list, and a boolean returning function, and return a list of element that returned true from the function.
17:04:10 <codedmart> lyxia: OK what about this. What if I want a fallback alternative `someFieldLens . _Just %~ (+1) <|> someFieldLens ~. Just 1`. So if someField is Nothing set it to Just 1?
17:04:24 <kuribas> mbw: wait, you mean enumFromM?  Yeah, thats from the vector documentation.
17:04:33 <iqubic> :t filter
17:04:35 <lambdabot> (a -> Bool) -> [a] -> [a]
17:04:41 <dcz__> my mind mixed recursively iqubic :D
17:05:13 <monochrom> filter does the recursion for you. This may be to your benefit or to your demise.
17:05:25 <kuribas> mbw: but polymorphism is very expensive, so it's usually a good candidate when performance is needed.
17:05:49 <iqubic> Oh, wait, what I want is something that takes a predicate and a list, and returns elements, that fail the predicate?
17:06:04 <mbw> Ok, so cross-module specialization only takes places when functions are marked specializable?
17:06:10 <dcz__> in short, filter checks list elements with some function
17:06:17 <iqubic> :t not
17:06:18 <lambdabot> Bool -> Bool
17:06:31 <iqubic> so I want filter (not b) xs
17:06:50 <monochrom> I think you will have to use filter and add your own not.
17:06:59 <iqubic> So like I just said?
17:07:01 <monochrom> I don't see a ready-made one in Data.List
17:07:17 <iqubic> where b is of type a -> Bool
17:07:22 <monochrom> For a lax version of "like".
17:07:26 <robertkennedy> Got a peek: https://downloads.haskell.org/~ghc/master/libraries/base/base/index.html
17:07:48 <iqubic> monochrom: what would you do instead of filter (not b) xs?
17:07:58 <monochrom> I would check its type.
17:08:12 <iqubic> Check what type?
17:08:17 <iqubic> does that not work?
17:08:37 <monochrom> You can perform experiments to find out.
17:09:24 <monochrom> Oh, the experiment exploded.
17:09:44 <ski> (wg 69
17:10:21 <kuribas> mbw: yes
17:10:37 <dcz__> monochrom: you are funny :D
17:11:00 <kuribas> mbw: and only for the types you give inside the SPECIALIZE pragma
17:11:42 <kuribas> mbw: unless you use the INLINABLE pragma, in which case it may try.
17:12:29 <kuribas> mbw: INLINABLE just means put the whole definition inside the interface file.
17:13:58 <mbw> But seriously, a factor 100...
17:14:44 <mbw> Sadly I wasn't successfull with my go function approach, I'll try that again tomorrow.
17:16:50 <mbw> kuribas: So I guess all these memory allocations I saw were related to dictionary arguments?
17:17:14 <kuribas> mbw: I think so
17:18:32 <mbw> Now to get it faster by a factor of 2?
17:19:03 <mbw> I'll try that tomorrow.
17:19:42 <mbw> Anyways, thanks for your help, especially taking into consideration how long it took and you had to restart and all.
17:19:49 <ryantrinkle> I'm having a bit of a tough time using ShowTag: 
17:19:49 <ryantrinkle> instance ShowTag k (ComposeMaybe k) where
17:19:49 <ryantrinkle>   showTaggedPrec = undefined
17:20:05 <ryantrinkle> whoops, wrong paste; https://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-Dependent-Sum.html#t:ShowTag
17:20:40 <ryantrinkle> Has anyone found a reasonably nice way to use that without constantly running into overlapping instances?
17:22:42 <codedmart> Can you do alternative with lenses? Anyone know?
17:23:42 <EvanR> i just "realized" that C allows field names to collide while haskell doesnt
17:23:50 <EvanR> and it all works out
17:25:11 <monochrom> Yes, C has a record system.
17:25:41 <lyxia> codedmart: I think you just use the one lens for the field and use "maybe" or pattern match on the Just.
17:26:06 <monochrom> Still, many C libraries do the same thing as Haskell programmers in uniquizing field names with prefixes.
17:28:07 <monochrom> For example, struct sigaction has fields sa_handler, sa_sigaction, sa_mask, sa_this, sa_that
17:29:40 <EvanR> whats the point of that
17:29:47 <monochrom> I don't know!
17:30:52 <monochrom> And the irony is that struct socket_address (sp?) has fields with the sa_ prefix again!
17:31:29 <monochrom> The correct spelling is sockaddr
17:31:39 <chewzerita> @lpaste
17:31:39 <lambdabot> Haskell pastebin: http://lpaste.net/
17:34:20 <dcz__> monochrom: i couldn't find the answer with filter :D
17:35:05 <monochrom> filter (\x -> determine whether x has suffix .webm or not) list
17:35:38 <monochrom> My x is the same idea as your x in x:xs
17:35:56 <dcz__> ff x:xs = filter (\s -> s == (b=".webm")) xs
17:36:03 <dcz__> doesnt work :D
17:36:15 <monochrom> No, don't bother with your own x:xs. filter already does it for you.
17:36:33 <monochrom> Also, you have a really bad case of "wth is b?"
17:36:56 <monochrom> Also, s == whatever is unlikely to work.
17:37:14 <monochrom> == really means equal, not "looks like".
17:38:29 <dcz__> yea, i just thought okey
17:39:18 <joe9> http://dpaste.com/11JENF4 is my code, line 136, I cannot figure out how to get the conName . Can anyone please help?  http://codepad.org/G4EHi352 is the function if the other file is too big to look at.
17:40:44 <joe9> Would a Proxy help to get the constructor name?
17:43:36 <Koterpillar> joe9: what's wrong with that line?
17:43:49 <Koterpillar> joe9: also, are you calling gbuildIBFormat on the same exact type again?
17:44:16 <joe9> Koterpillar: gOod catch. I need to strip the M1 there. sorry about that.
17:44:44 <Koterpillar> does it give an error or anything?
17:45:27 <joe9> Koterpillar: with gparseIBFormat, I get U1 or L1 or R1 from the gParseIBFormat. But, I cannot figure out how to run the conName?
17:45:41 <joe9> Koterpillar: I put an undefined there to mask the error.
17:46:00 <Koterpillar> joe9: run conName on what you have there
17:46:01 <joe9> Koterpillar: I want to do: fmap M1 (parseIBFormat (constructor name))
17:46:11 <Koterpillar> joe9: ah, parse... use undefined
17:46:13 <joe9> Koterpillar: on what?
17:46:27 <Koterpillar> joe9: I have an example just for you... https://www.koterpillar.com/talks/instances-for-everyone/#13
17:46:42 <Koterpillar> sorry, next page, https://www.koterpillar.com/talks/instances-for-everyone/#14
17:47:10 <Koterpillar> you need ScopedTypeVariables here, which you already have
17:47:39 <joe9> Koterpillar: exactly what I need.
17:47:49 <joe9> the (undefined :: S1 m t p) is the key
17:47:51 <dcz__> monochrom: ff xs = filter (\s -> takeExtensions s == ".webm") xs , this works :D
17:48:35 <joe9> Koterpillar: the S1 m t p are the same as that defined in the instance line? So, the type variable is matching from the undefined?
17:49:04 <Koterpillar> joe9: yes, you could write (in my example) (S1 m (Rec0 Text) p) as t doesn't matter
17:49:12 <monochrom> dcz__: Congrats.
17:50:00 <joe9> Koterpillar: it appears to be magic on how that match happens. Is there some material that can help understand it?
17:50:13 <dcz__> thank you :D it took long but i made it somehow :D i tried splitExtensions thats why struglled :D
17:50:15 <joe9> Koterpillar: if you do not mind me asking.
17:50:19 <Koterpillar> joe9: no magic, just clever instance declarations
17:50:37 <Koterpillar> joe9: read the Hackage docs on GHC.Generics and the declarations source
17:51:01 <Koterpillar> what my understanding is, conName is defined on anything that's Constructor c => C1 m t p
17:51:05 <dcz__> is there any stack data structure in hakell ?
17:51:25 <Koterpillar> joe9: sorry, Constructor m => C1 m t p
17:51:53 <kadoban> dcz__: [] works as one
17:52:09 <joe9> I can understand the above line with Constructor m =>
17:52:13 <Koterpillar> joe9: or, Constructor m => M1 C m t p, which is the same (you can use C1 in the instance declaration just fine though)
17:52:23 <joe9> what I fail to understand is how the undefined works.
17:52:41 <Koterpillar> joe9: the implementation of this conName is the same for any value of this type, the value isn't examined
17:52:50 <dcz__> kadoban: you meant , works like stack ?
17:52:58 <Koterpillar> joe9: when the program is compiled, the type is enough to select the correct instance
17:52:59 <joe9> It is almost as if we are pattern matching teh type variables in the function definiton.
17:53:25 <Koterpillar> joe9: we always are! imagine class FavoriteNumber a where fav :: a -> Int
17:53:35 <kadoban> dcz__: It's a fine implementation of one; it behaves close enough that you don't even really need a wrapper.
17:53:52 <joe9> Koterpillar: got it. Thanks. That makes perfect sense. well explained. Thanks again.
17:53:53 <dcz__> i dont know actually what i need. for example, i want to go further and backward on list elements , like playlist
17:54:01 <Koterpillar> joe9: instance FavoriteNumber Int where fav = const 1
17:54:06 <Koterpillar> joe9: instance FavoriteNumber Char where fav = const 2
17:54:16 <Koterpillar> joe9: now, fav (undefined :: Int) is 1
17:54:26 <dcz__> mpv will use it :D
17:56:01 <EvanR> zipper?
17:56:11 <kadoban> dcz__: Doesn't sound like a stack
17:56:34 <dcz__> what i need actually? queue ?
17:56:52 <joe9> Koterpillar: Thanks, That helps. and undefined is a member of all types.
17:57:23 <geekosaur> dcz__, sounds to me like you want either Seq or a zipper
17:57:25 <Koterpillar> it's the only value of that type you can produce in that context, because you haven't been given any other
17:58:12 <joe9> yes, makes sense. How did you get so good at this? any reading material that can help me too?
17:58:49 <dcz__> geekosaur: i have filepath list in hand right now. Media player will play these from terminal so i want the capability of going forward or backward. thats what i will try to do
18:00:22 <Koterpillar> joe9: I read the docs and tried to make ridiculous things
18:00:42 <Koterpillar> joe9: for high level of ridiculousness, https://aphyr.com/posts/342-typing-the-technical-interview
18:01:03 <Koterpillar> (that's not me)
18:01:13 <joe9> Koterpillar: my eyes glaze over when I see kinds. Any suggestions to understand it better? read up on GHC core? System F?
18:01:52 <Koterpillar> if it helps, I have little idea about either of those. I vaguely remember Core actually erases types, but that might be wrong.
18:02:13 <Koterpillar> but really, here's another example of FavoriteNumber
18:03:04 <joe9> I understand this. but, just looking for better intuition about haskell.
18:03:16 <joe9> there seems to be some stumbling block all the time.
18:03:33 <joe9> I feel that it might be because I am missing some important concept.
18:03:50 <Koterpillar> hmm, I can't actually write what I wanted as a one-liner. instance FavoriteNumber a => FavoriteNumber [a]
18:04:13 <joe9> that might help build better intuition about reasoning about haskell definitions.
18:05:11 <Koterpillar> this is nothing but typeclass trickery, which is: choosing the right function based on your type
18:10:01 <joe9> Koterpillar: as an fyi, this is how I used it. http://codepad.org/yU9ZKTOf
18:11:48 <Koterpillar> joe9: you can safely replace "M1 C" with "C1" everywhere
18:12:12 <joe9> yes, agreed. Thanks.
18:23:40 <biglambda> Is there a version of the lens operator (%=) that allows the right operand to be in the same monad? So I think the type would be: (Profunctor p, MonadState s m) => Setting p s s a b -> p a (m b) -> m ()  instead of (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
18:24:43 <peddie> biglambda: I have no idea, but perhaps try #haskell-lens?
18:24:54 <biglambda> Ah.. thanks.
18:30:28 <rjeli> re: https://aphyr.com/posts/342-typing-the-technical-interview
18:30:40 <rjeli> can someone explain "You smile kindly. “Haskell is a dynamically-typed, interpreted language.”
18:30:50 <mbw> Could somebody explane to me again how those timings with +RTS -s are created. I have a total runtime of 0.340 seconds, and 0.246 seconds elapsed (all of which is MUT). Everything else is zero. So, where do the other 0.100s come from?
18:30:53 <rjeli> how is type level programming dynamic?
18:30:57 <EvanR> o_O
18:32:01 <EvanR> as for the quoted quoted section, haskell has dynamic types built on top of static types, and haskell has interpreted implementations
18:33:40 <rjeli> i assume you mean something like `data Var a`?
18:33:47 <rjeli> is he doing something like that at the type level?
18:34:26 <Koterpillar> :kind Int
18:34:30 <Koterpillar> :k Int
18:34:31 <lambdabot> *
18:34:37 <Koterpillar> :k String
18:34:37 <lyxia> mbw: multithreading?
18:34:38 <lambdabot> *
18:34:45 <rjeli> o
18:34:46 <Koterpillar> rjeli: this is what she means, I think
18:35:22 <rjeli> ty
18:38:17 <mbw> lyxia: That could actually be it.
18:39:57 <mbw> Sadly, no.
18:40:37 <mbw> Is this some startup overhead of the GC maybe?
18:44:50 <mbw> This is annoying. If the elapsed time was equal to the total time, I would be on par with my C++ implementation
18:49:15 <sophiag> i have an ADT in order to store lists of multiple types in the same field of a record and want to compute all the permutations of each list, but i think i need to unwrap them to be lists of different types otherwise i just get the permutations of all the lists in that field with one another. this is my attempt to do so, but i'm getting many type errors: http://lpaste.net/354501
18:50:10 <sophiag> (i'm also wondering with all the wrapping and unwrapping i'm doing in this program whether it would make more sense to use lenses, although i'm only beginning to understand how they work)
18:54:39 <ski> sophiag : you've got multiple type issues ..
18:55:08 <sophiag> ski: an understatement perhaps
18:55:58 <sophiag> do you understand what i'm trying to here and why i (at least think) i need to unwrap them?
18:56:40 <ski> well .. i think i perhaps have some idea of what some of this is attempting to do .. but not the big picture
18:56:47 <ski> anyway, let's start with
18:56:49 <ski>   permList :: [Amb] -> [[MultiList]]
18:56:55 <ski>   permList a = map (permutations . unwrapMultiList . ambVal) a
18:57:16 <ski> `a' here has type `[Amb]' so thence the input to `permutations . unwrapMultiList . ambVal' will have type `Amb'
18:57:42 <sophiag> right
18:57:51 <ski> looking at `ambVal', it's here a selector function that will select a field of type `MultiList' in that `Amb'. so far, so good
18:58:06 <ski> next, that `Multilist' will get passed to `unwrapMultiList'
18:58:10 <sophiag> well that actually is throwing an error i believe
18:58:13 <sophiag> ambVal
18:58:17 <ski> but `unwrapMultiList :: Maybe [a] -> [a]'
18:58:31 <ski> `MultiList' does not match `Maybe [a]'
18:59:05 <ski> no, `ambVal' shouldn't be throwing an error. there's only one data constructor of `Amb'
18:59:52 <sophiag> the very last error seems to correspond to that. although i'm not sure if it's because i'm using composition instead of application with the functions in map
18:59:58 <ski> looking at the definition of `unwrapMultiList', it's argument gets passed to `unwrapSList',`unwrapCList',`unwrapIList',`unwrapFList', all of which take a `MultiList' as input
19:00:29 <ski> so it seems that the type signature of `unwrapMultiList' is wrong, in that it should be specified as taking a `MultiList' as input
19:00:36 <sophiag> i get that part. that was a careless mistake
19:00:43 <ski> (perhaps the return type is also wrong, we don't know yet)
19:00:52 <sophiag> right. i'm more thinking in the other direction
19:00:59 <sophiag> oh
19:01:05 <sophiag> but that solved the problem with ambVal
19:01:08 <ski> hmm
19:01:14 * ski nods
19:01:55 <ski> with a type error, it's usually some kind of clash between several source locations, of which at least one must be changed to avoid the type error
19:02:19 <ski> the one that one wants to change isn't always the location where the type checker discovered the inconsistency
19:02:20 <sophiag> i'm not sure i can do unwrapMultiList :: MultiList -> [a] given the outputs can be of different types
19:02:30 * ski nods
19:02:40 <ski> let's ignore that for the moment
19:02:46 <sophiag> which brings me back to the original issue of wanting permutations of the lists themselves, not the fields wrapped inside constructors
19:03:08 <sophiag> ok. i just want to be clear i'm a bit unsure about needing to unwrap them at all :p
19:03:15 <ski> what i'm saying is that the ways i suggest to try to fix the errors may perhaps not be pushing the program in the direction you'd prefer
19:03:26 <ski> but, let's see where this leads
19:03:30 <sophiag> ok
19:03:46 <ski> iow, let's not look at `unwrapSList' and friends
19:04:37 <ski> you have `unwrapSList (SList list) = mapM (...) list', with the signature `unwrapSList :: MultiList -> Maybe [String]'
19:05:01 <ski> so thus `list :: [String]' here. agree ?
19:05:10 <sophiag> yes
19:05:16 <sophiag> and that is the case
19:05:50 <ski> so the function you pass to `mapM', i.e. `\l -> case l of String x -> Just x; _ -> Nothing', will get an `l' of type `String'
19:06:07 <ski> the type of `mapM' here will be something like
19:06:29 <ski>   mapM :: (String -> Maybe a) -> [String] -> Maybe [a]
19:06:33 <ski> for some particular `a'
19:06:49 <ski> looking at the declared return type of `unwrapSList', this `a' must be `String'
19:07:07 <sophiag> yup, still following
19:07:09 <ski> so this function that is passed to `mapM' should then have type `String -> Maybe String'
19:07:42 <ski> so .. now the `case' there doesn't make sense at all
19:07:47 <ski> `l' is already of type `String'
19:08:21 <ski> also, you can't write a pattern `String x' there, and expect it to match if the thing you `case' on is a `String', and fail to match otherwise
19:08:32 <ski> types don't exist at run-time
19:08:42 <ski> you can't inspect a value, and discover its type
19:08:51 <ski> you must already know the type of the value, in order to inspect it
19:09:11 <ski> and .. we already know `l' must be a `String' here, always, so there's no need to check
19:10:09 <ski> one could simplify the function here to `\l -> case l of x -> Just x' .. or just `\l -> Just l', iow `Just'
19:10:44 <sophiag> well the purpose of using Maybe is for composition
19:11:07 <sophiag> otherwise that seems fine...although not sure it will typecheck. it says it's looking for a Literal
19:11:10 <ski> but `mapM Just' is `mapM return' which will give you back the same list that you passed it, wrapped in a `Just' (after walking through to the end, which will never terminate for infinite lists .. but presumably your lists here are finite)
19:11:29 <ski> yea .. i'm not sure where `Literal' comes from. i see no mention of it in the source
19:12:04 <ski> hm .. perhaps you do have some *data* (not type) constructor `String', possibly belonging to a type `Literal' ?
19:12:10 <sophiag> well, these were originally parsed from Literals (an AST type) but i don't understand why they would be of type Literal at this point
19:12:53 <sophiag> they're of the types you see in that paste. they shouldn't be Literals inside there at this point
19:13:01 <ski> in such case, either the above still holds, or the argument type of `unwrapSList' &co. here (and also the patterns on the left of the `='s) is wrong
19:13:23 <ski> anyway, there's another problem here as well
19:13:31 <ski> `unwrapSList' is partial
19:13:48 <ski> if you pass it a `CList ...',&c., then it's abort the program
19:13:56 <sophiag> well that's why i chose to use Maybe 
19:13:59 <ski> probably you'd prefer returning `Nothing' in these cases ?
19:14:07 <sophiag> that's what i'm currently doing...
19:14:08 <ski> adding another defining equation :
19:14:13 <ski>   unwrapSList _ = Nothing
19:14:21 <sophiag> oh i see
19:14:22 <ski> after the existing one, would be the simplest way to do that
19:14:48 <ski> (and ditto for friends)
19:14:52 <sophiag> hold on a sec
19:16:02 <sophiag> i'm a bit confused as to the difference between matching in the argument and using a case analysis that returns Maybe and having two argument types that return Maybe
19:16:16 <ski> iow, you can check, at run-time, whether the `MultiList' that you get is of the particular form/variant (*not* type !) that you expect, and in that case you'll return `Just (...)', otherwise `Nothing'
19:16:23 <sophiag> seeing as i know anything matching the given data constructor will contain that type
19:16:28 <ski> well, saying
19:16:36 <ski>   unwrapSList (SList list) = ..list..
19:16:40 <ski>   unwrapSList _ = Nothing
19:16:43 <ski> is the same as saying
19:16:53 <ski>   unwrapSList ml = case ml of
19:17:01 <ski>     SList list -> ..list..
19:17:04 <ski>     _ -> Nothing
19:17:13 <sophiag> should it be Just list in both cases?
19:17:39 <ski> so you can always rephrase "matching in the argument" with "using a case analysis"
19:17:53 <sophiag> right i know that
19:17:56 * ski ponders the ".. that returns Maybe and having two argument types that return Maybe" part
19:18:07 <sophiag> no i understand now
19:18:09 <sophiag> your example was good
19:18:37 <ski> i don't think you want argument types with `Maybe' in them, here
19:19:21 <ski> anyway .. going back to `unwrapMultiList'
19:20:04 <ski> it seems that you wanted to try one after the other of these `unwrapSList',&c. .. and then since presumably at least one of them must succeed, you used `fromJust'
19:20:06 <sophiag> right that's where my errors are at this point
19:20:13 <sophiag> exactly
19:20:21 <sophiag> that's what i did when parsing them into this adt as well
19:20:48 <sophiag> although there i applied data constructors to each and didn't return a type variable
19:20:58 <ski> do you have anything to add about why you were writing `Maybe [a]' as the argument type, or should i consider the suggested argument type `Multilist' as the corrected version for that ?
19:21:16 <sophiag> no you were correct
19:21:21 <ski> ok
19:22:13 <ski> it seems to me that *maybe* you were wanting to express some kind of existential thing here, but didn't know how. and that's explaining why you wrote `[a]' as result type here
19:22:25 <sophiag> hmm
19:22:31 <sophiag> well i know how to use existentials
19:22:41 <sophiag> not sure that would be ideal here...
19:22:56 <ski> but it's hard to say, without knowing more about how this is to be called and used
19:23:06 <ski> so let's go back to `permList'
19:23:13 <sophiag> oh, well that's why i tried to clarify if my explanation made sense
19:23:14 <ski> @type permutations
19:23:15 <lambdabot> [a] -> [[a]]
19:23:23 <Zemyla> @src permutations
19:23:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:23:40 <ski> @index permutations
19:23:40 <lambdabot> GHC.OldList, Data.List
19:23:57 <sophiag> if i map permutations the ambVal field then i get permutations of each field with one another
19:24:18 <ski> ideally, i think the desired type of `unwrapMultilist' here would be
19:24:29 <ski>   unwrapMultiList :: Multilist -> exists a. [a]
19:24:33 <sophiag> so like [[SList [..], IList [..]], [IList [..], SList [..]]]
19:25:05 <sophiag> oh ok. i have not used existentials like that before. usually in constraints
19:25:12 <ski> conceptually, if you call `permutations' on the result of type `exists a. [a]', you'd get a result of type `exists a. [[a]]'
19:25:28 <ski> makes sense ?
19:25:34 <ski> should i explain this `exists' notation i'm using ?
19:26:05 <sophiag> no i understand that
19:26:09 <ski> ok
19:26:19 <sophiag> although ghc is recommending RankNTypes when i'm already using it...
19:26:37 <sophiag> are you sure exists doesn't go in a constraint?
19:26:41 <ski> anyway, since `a :: [Amb]', and we're in a `map', the result of that would then be of type `[exists a. [[a]]]'
19:26:56 <ski> `exists' goes nowhere. it's not implemented in GHC
19:27:11 <ski> i'm just using it as a (imho) nicer way to express what we're *conceptually* after
19:27:22 <sophiag> oh ok. you mean if i had some data type that was an existential
19:27:57 <ski> i mean if we had an actual existential quantifier `exists'. like we actually *do* have a universal quantifier, `forall'
19:28:11 <sophiag> i see
19:28:21 <ski> both of these would go in types (not in constraints, unless one also added those)
19:28:36 <sophiag> ok
19:28:44 <sophiag> probably not what i want, but i understand it
19:28:49 <ski> you know how `length :: [a] -> Int' really means `length :: forall a. ([a] -> Int)', right ?
19:29:04 <ski> and it's the presence of the `forall' in the type of `length' that makes `length' polymorphic
19:29:42 <ski> anyway, a value with an `exists' in the type is "abstract", there's some part of its type that is unknown/opaque
19:30:13 <ski> if we have a value of type `exists a. [a]', then we know that there is some (unknown) type `a', such that we have a list of values, all of that same (unknown) type `a'
19:30:33 <ski> otoh, with `[exists a. a]', each of the list elements could potentially have a *different* type
19:30:42 <ski> so the exact placement of `exists' is important
19:31:01 <ski> now .. there's two main ways in which to represent/*encode* `exists'
19:31:05 <sophiag> right. and i do not want the latter or i could have avoided using MultiList entirely
19:31:31 <ski> one i'm sure you know. the `data Showable = forall a. Show a => WrapShowable a' one
19:31:37 <sophiag> yes
19:32:03 <ski> here `WrapShowable :: forall a. Show a => a -> Showable', which is the same thing as `WrapShowable :: (exists a. Show a *> a) -> Showable'
19:32:45 <ski> (just like `length :: forall a. ([a] -> Int)' is the same as `length :: (exists a. [a]) -> Int' : as long as there *exists* some type `a', such that the argument has type `[a]', then the result will have type `Int')
19:32:59 <ryantrinkle> is there a canonical representation of Data.Constraint.Dict in base?
19:33:57 <lyxia> No
19:34:03 <ski> the other way involves Continuation-Passing Style (CPS). basically instead of turning `unwrapMultiList :: Multilist -> exists a. [a]' into `unwrapMultiList :: Multilist -> SomeList' with `data SomeList = forall a. WrapList [a]'
19:35:05 <ski> you instead turn `unwrapMultiList :: Multilist -> exists a. [a]' into `withUnwrapMultiList :: Multilist -> (forall a. [a] -> o) -> o', and then you pass as an extra argument a "continuation" function that will receive the "result" as input
19:35:56 <ski> sophiag : if you're interested, i could expand more on this .. but i suspect you'd rather we go back to your code atm, yes ?
19:36:20 <ski> <ski> anyway, since `a :: [Amb]', and we're in a `map', the result of that would then be of type `[exists a. [[a]]]'
19:36:55 <ski> the result type of `permList' is declared as `[[MultiList]]', though
19:36:57 <sophiag> ha. well i understand continuations and haven't seen them used in data types like that, but it doesn't seem like a road i want to go down here
19:37:23 <ski> the CPS encoding is sometimes nicer than the "existential" data type encoding. it's a trade-off
19:37:42 <ski> anyway, `[exists a. [[a]]]' doesn't match `[[MultiList]]', even on this conceptual level
19:38:11 <ski> first, we'd have to go from `[exists a. [[a]]]' to `[[exists a. [a]]]', which should be possible (as opposed to going in the opposite direction)
19:38:15 <sophiag> well MultiList is already a list so it's nested to the same level, unless i'm confusing you
19:38:30 <ski> next, we'd need to go from the inner `exists a. [a]' to `MultiList'
19:38:59 <ski> iow, we need to actually instead one of the data constructors `SList',`CList',`IList',`FList' !
19:39:08 <ski> this is actual run-time code that is missing !
19:39:30 <ski> a value of type `MultiList' is *not* a(n ordinary Haskell) list
19:39:46 <ski> it *contains* a list, together with a tag (the data constructor), which tells the element type
19:40:04 <sophiag> right, which is why when i try to map permutations to them i get permutations of the data constructors
19:40:12 <sophiag> i.e. back to the original problem
19:40:33 <ski> so .. you're attempting to unwrap the data constructors first
19:40:35 <ski> then doing something
19:40:58 <ski> and then you presumably want to *rewrap* the *same* data constructor as you had before, right ?
19:41:06 <sophiag> perhaps i should permute them then rewrap?
19:41:33 <sophiag> tbh i'm trying to debug a more complicated function and this is the simplest behavior i'd like to start with
19:41:57 <ski> rather than looking at the whole `permList :: [Amb] -> [[MultiList]]', it's probably simpler to look at `permutations . unwrapMultiList . ambVal :: Amb -> [MultiList]'
19:42:37 <ski> i have an idea, which looks like it'll work for this code
19:42:47 <ski> but perhaps not for the more complicated case you have in mind
19:43:25 <ski> note that `permutations' doesn't care about the element type of the list. it just reshuffles the elements (iow considers only element *positions*, not the elements themselves)
19:43:37 <sophiag> yeah, i'm unsure because ultimately i do need the rest of the record in order to filter based on the Maybe Strings, but this is certainly going to be an issue somewhere in there
19:43:43 <ski> is this also true for the more complicated case you have ?
19:43:48 <sophiag> yes
19:43:59 <ski> or do you really need to know whether the element is a `String' or whatever ?
19:44:08 <sophiag> i do not
19:44:16 <ski> ok, good
19:44:43 <ski> and let me also confirm that you do want `[[MultiList]]' (rather than some kind of existential thing) as result type of `permList' ?
19:45:13 <ski> anyway, what i suggest is :
19:45:39 <sophiag> well most likely the order will be to match the other field of the record with another record that has a comparale field, then call permutations on the list wrapped in there, then filter it based on the matching other record
19:45:45 <ski> rather than call `permutations' on the result of `unwrapMultiList', instead pass `permutations' as an argument to it
19:45:58 <sophiag> so i would prefer to leave the mapping on the outside
19:46:13 <sophiag> ah, that's clever!
19:46:19 <ski> so `unwrapMultiList' will unwrap, then apply the argument function that it gets, then *rewrap* the *same* data constructor it unwrapped
19:46:32 <ski> so, better rename it to `mapMultiList' or something
19:47:00 <sophiag> yes. ideally i'd rather not have it actually print the data constructors but it seems i need them to do this operation on one record type
19:47:11 <ski> note that the type signature of `mapMultiList' will be slightly .. exotic
19:47:18 <ski> can you guess what it'll be ?
19:47:33 <sophiag> hold on let me reread
19:48:40 <sophiag> wait, i'm not even sure what function you're referring to
19:49:49 <ski> (or perhaps something like .. `processMultiList' would be a better name ? not suggesting that there's a list on which we'll apply the given function to every element thereof -- because we're going to apply the given function once, to the whole list, not once to every element of the list)
19:50:01 <ski> i'm suggesting something like
19:50:16 <sophiag> still not sure which function in my actual code this corresponds to
19:50:22 <ski>   permList a = map (processMultiList permutations . ambVal) a
19:50:30 <sophiag> ok
19:50:47 <ski> where `processMultiList' is a reformulation of `unwrapMultiList', to also rewrap, after having applied the argument function
19:50:56 <sophiag> ok
19:50:57 <sophiag> one sec
19:51:16 <ski> (and then you'd not need to use these `<|>'s .. in case that's not clear)
19:51:24 <sophiag> oh ok
19:51:52 <ski> (nor the `unwrapSList',&c. .. just match directly)
19:52:28 <sophiag> ok, writing it now
19:54:13 <sophiag> well i figured it should be like unwrapMultiList :: ([a] -> [[a]]) -> MultiList -> [MultiList]
19:54:17 <sophiag> but not quite working
19:54:49 <ski> right, good try
19:55:24 <ski> the point to note here is that we want the *argument* of this function to be polymorphic
19:55:39 <sophiag> oh so use an existential there?
19:55:49 <ski> wait, not so fast :)
19:56:07 <ski> we don't want this function, `unwrapMultiList'/`mapMultiList'/`processMultiList' (or whatever you prefer to call it) to be polymorphic
19:56:31 <sophiag> right, but i could just apply a constraint to a
19:56:37 <ski> `processMultiList' being polymorphic would mean that the *caller/user* of `processMultiList' will get to pick the type of `a'
19:56:39 <sophiag> i.e. the type of the function passed as an argument
19:56:48 <ski>   processMultiList :: ([a] -> [[a]]) -> MultiList -> [MultiList]
19:56:50 <ski> is short for
19:56:55 <ski>   processMultiList :: forall a. ([a] -> [[a]]) -> MultiList -> [MultiList]
19:57:00 <ski> or, to be extra clear
19:57:03 <ski>   processMultiList :: forall a. (([a] -> [[a]]) -> MultiList -> [MultiList])
19:57:19 <ski> which *does* mean that `processMultiList' is what's to be polymorphic
19:57:27 <sophiag> oh ok. i just had the syntax wrong
19:57:31 <ski> but you want the argument function to be polymorphic, so
19:57:37 <ski>   processMultiList :: (forall a. [a] -> [[a]]) -> MultiList -> [MultiList]
19:58:02 <ski> this means that the *caller/user* of the *argument* function, iow `processMultiList' itself, will get to pick `a'
19:58:07 <ski> which is exactly what you want
19:58:27 <ski> you want it to pick `a' as `String' in the `SList' case, as `Char' in the `CList' case, &c.
19:58:32 <ski> ok ?
19:58:45 <ski> this btw requires the extension `Rank2Types'
19:58:57 <sophiag> i'm using RankNTypes already
19:59:10 <ski> `processMultiList' is a rank-2 operation here, because it has a polymorphic argument
19:59:13 * ski nods
19:59:16 <sophiag> ghc doesn't like me applying the data constructor again if i'm like "SList x -> SList $ f x"
19:59:50 <sophiag> because that would return MultiList not [MultiList]
20:00:14 <ski> use `map' ?
20:00:26 <sophiag> ooo
20:00:39 <sophiag> all good :D
20:00:42 * ski smiles
20:01:48 <ski> so .. all good now ?
20:01:55 <sophiag> yup 
20:02:15 <sophiag> well...that was just to replicate the simplest part of a function i'm trying to debug, but i was really confused about it
20:02:43 <sophiag> and i'm still wondering whether all this wrapping and unwrapping would be a good use case for lenses. i'm on the fence considering i'm not using nested records
20:03:06 <sophiag> although i could be...probably best to get it working and consider refactoring as i begin to understand lenses more
20:03:47 * ski nods
20:04:56 <sophiag> well, thanks so much for walking me through all that! now to see if i can fix the more complicated function :p
20:18:16 <sophiag> ski: mind if i throw the more complicated case at you? it's driving me a bit nuts because it compiles fine yet always returns an empty list :/
20:18:22 <sophiag> http://lpaste.net/354506
20:37:33 <ski> sophiag : hrm, let me take a look
20:38:58 <sophiag> thanks. the recursive calls struck me as a bit janky from the start, but i don't think that's the issue
20:41:21 <ski> i'm wondering if you perhaps wanted to use `++' (or `concat') rather than `do' there
20:42:46 <ski> line `30' is dead code, redundant
20:44:26 <ski> not sure why you don't just `fromBoolAmbVal . fromJust' instead of `fromJustAmbVal', where `fromBoolAmbVal :: AmbVal -> Bool'
20:44:52 <ski> still, it'll crash and burn in case that list ever contains anything ele than `BoolVal (...)'s
20:45:46 <ski> (er, or rather, in case `reqAmbVal' on elements of the lists ever does that)
20:46:47 <ski> you're using `do' for the `[]' monad here -- it's not clear to me why you'd want to do that here. especially as you don't use `<-' to capture the results
20:46:59 <ski> > do "two" "three"
20:47:01 <lambdabot>  error:
20:47:01 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
20:47:01 <lambdabot>                    with actual type ‘[Char]’
20:47:09 <ski> > do "two"; "three"  -- er, rather
20:47:09 <sophiag> oh hmm
20:47:11 <lambdabot>  "threethreethree"
20:47:24 <ski> it's just replicate the last thing, as many times as there's elements of the list before
20:47:33 <ski> so .. in case that list is empty, the whole will be the empty lis
20:47:35 <ski> t
20:47:41 <ski> (which is probably what happened in your case)
20:47:49 <sophiag> that's a good point in that it will only return the last match whereas i want to concat the results of every pass through
20:48:00 <ski> right
20:48:04 <ski> <ski> i'm wondering if you perhaps wanted to use `++' (or `concat') rather than `do' there
20:49:07 <ski> btw, in either case, you could factor the common parts of the `if' branches out of the `if'
20:49:47 <sophiag> you mean the recursive calls?
20:49:51 <sophiag> yeah
20:49:55 <ski> yes
20:53:40 <sophiag> ok, so at least getting an exception now :)
20:56:00 <sophiag> oh ok i think it actually works now. but i realized i left out the ability to parse lists on the rhs of the lambdas (what i'm storing in Require) so they're not good for anything really
20:56:35 <sophiag> i would still prefer to remove the data constructors when it prints output tho :/
20:57:37 <sophiag> oh and also i'm matching everything twice because i couldn't think of a way to match every element using recursion. so that's not good
20:58:49 <sophiag> so with no actual filtering done i get something like "[ListVal [[IList [1,2,3],IList [2,1,3],IList [3,2,1],IList [2,3,1],IList [3,1,2],IList [1,3,2]]],ListVal [[IList [1,2,3],IList [2,1,3],IList [3,2,1],IList [2,3,1],IList [3,1,2],IList [1,3,2]]]]"
20:59:43 <sophiag> when i'd prefer just [[1,2,3], [2,1,3], [3,2,1], [2,3,1], [3,1,2], [1,3,2]]
21:01:25 <sophiag> ski: this is how it looks now: http://lpaste.net/354506
21:13:10 <halogenandtoast> if I have a nested list, how can I compose lenses to update an element, I wanted to do xxs ^? ix 2 ^? ix 1 .~ newValue but the first ^? returns a maybe list not a list
21:13:17 <halogenandtoast> is there a lens operator for Maybe values?
21:13:53 <ski> sophiag : hm, the `do' isn't needed there, now
21:14:06 <sophiag> question about Show instances. i derived my own in order to strip out the data constructors from an adt and am now unsure how to make everything else that uses that type use my custom instance for that field rather than the generic one: http://lpaste.net/354508
21:14:16 <sophiag> ah, thanks ski
21:14:56 <ski> it'll automatically use your custom instance
21:15:04 <halogenandtoast> sophiag: what ski said
21:15:26 <sophiag> you mean if i leave off "deriving (Show)" in each case?
21:15:42 <sophiag> or use OverlappingInstances?
21:15:47 <sophiag> right now it's not compiling
21:16:01 <ski> no i mean if you keep deriving `Show' for `Amb' and `AmbVal'
21:16:10 <sophiag> oh i see
21:16:12 <ski> it'll pick up your custom insteance for `MultiList'
21:16:53 <ski> anyway, even skipping the data constructors, you have differing levels of nested lists
21:17:13 <halogenandtoast> I'm a derp, I figured out my question
21:17:28 <ski> btw, i'm not really understanding what task your pattern of recursion in `eval' is meant to accomplish
21:17:59 <sophiag> oh, the problem was just i forgot to omit "deriving (Show) from the first adt :p
21:18:09 * ski notes `eval' changed return type
21:18:27 <ski> yea, right. shouldn't spotted that
21:18:42 <ski> er. s/shouldn't/should've/
21:18:48 <sophiag> i understood
21:18:48 * ski is a bit tired
21:18:59 <sophiag> yeah, my sleep schedule got a bit off this weekend :/
21:19:11 <halogenandtoast> I needed to do xxs & (ix 0 . ix 2) .~ newValue 
21:19:24 <sophiag> eval changed return types to match that of the functions in the Require records
21:20:31 <ski> oh, i noticed before but then forgot to say : the argument of `Require' is unused
21:20:42 <nshepperd> halogenandtoast: that's the same as ((ix 0 . ix 2) .~ newValue) xxs right?
21:20:57 <sophiag> ski: oh, sorry missed your question. the reason i'm recursing that way is to match _every_ element in both lists rather than just by index, i.e. like a list comprehension would. but the way i'm doing it currently results in duplicates 
21:21:08 <halogenandtoast> nshepperd: yes
21:21:24 <sophiag> ski: oh, thanks for pointing that out. that's a legacy thing from a refactor :p
21:22:23 <ski> sophiag : you want `eval xs ys' to match every element of `xs' with every element of `ys' ?
21:22:53 <sophiag> yes
21:23:11 <sophiag> and described this way of doing it as "janky" :)
21:23:14 <ski> well, you're not doing that, even (even disregarding the duplication)
21:23:21 <sophiag> oh?
21:23:43 <ski> in the recursive defining equation, you're never passing both `xs' and `ys' to a recursive call
21:23:57 <ski> so you'll never compare the elements in the tail `xs' with the elements in the tail `ys'
21:24:09 <sophiag> oh, yeah it's just the head of each
21:24:18 <sophiag> plus if they're different lengths i'm in trouble
21:24:19 <ski> how about .. using a list comprehension ?
21:24:47 <ski> (or the `[]' monad, if you prefer. amounts to the same thing)
21:25:14 <sophiag> yeah, that would certainly simplify it. i think the only reason i didn't originally was because preferring explicit filters over constraints given i'm passing functions
21:25:24 <ski> that would reintroduce `do' here .. but not in quite the way you had it before
21:25:49 <ski> (not quite sure what you mean by "constraints" here ..)
21:26:00 <sophiag> the functions in Require
21:26:18 <ski> mhm, ok
21:27:05 * ski hrms
21:27:25 <ski> i suppose, since you're using a singleton list, you could avoid the `filter' call altogether
21:28:09 <sophiag> i was trying something like: eval a r = [x | x <- a, y <- r , filter (fromJustAmbVal . reqAmbVal y) [ListVal $ permuteList x]]
21:29:37 <ski>   eval a r = [l | x <- a,y <- r,let l = ListVal (permuteList x),(fromJustAmbVal . reqAmbVal y) [l]]
21:30:12 <sophiag> ah :)
21:30:16 <ski> you want to collect `ListVal (permuteList x)'s, not `x's
21:30:20 <sophiag> i was just fixing it, but wouldn't have got quite there
21:30:53 <ski> just writing a `Bool' expression in a list comprehension will do a "guard". no need to call `filter'
21:31:09 <ski>   filter p as = [a | a <- as,p a]
21:31:25 <ski> @undo [a | a <- as,p a]
21:31:25 <lambdabot> concatMap (\ a -> if p a then [a] else []) as
21:31:40 <ski> well, which is the same as `filter p as'
21:31:45 <sophiag> i just wasn't certain whether anything returning Bool, i.e. lambdas, were ok
21:32:00 <ski> lambdas ?
21:32:04 <ski> where ?
21:32:33 <sophiag> the functions in Require are lambdas
21:33:21 <ski> well, it doesn't matter how you compute the `Bool' ..
21:33:22 <sophiag> i think i need to rewrite some of the helper functions now to make the types match
21:36:22 <sophiag> ok, it's compiling now...
21:37:32 * ski . o O ( that feeling when your program compiles the first time around, and you're wondering what's wrong )
21:38:04 <sophiag> well, i won't know until i fix how i'm parsing lambdas to take lists on the rhs
21:38:07 <sophiag> should be simple
21:38:17 <sophiag> considering i already have functions to parse lists
21:41:27 <sophiag> i'm just trying to get rid of the outer data constructor now with another custom Show instance...
21:42:36 <sophiag> the data constructor is ListVal [MultiList] so i can't do show ListVal x = show x
21:45:54 <sophiag> oh, it's fine. i was just missing parens... lisp trauma
21:47:29 <sophiag> i just have an extra level of nesting that i'm not sure i can get rid of
21:57:12 <halogenandtoast> If I have a record, how to do make a lense to a field without using makeLenses ?
21:57:28 <Koterpillar> halogenandtoast: lens wiki has an example
21:58:07 <Koterpillar> halogenandtoast: http://hackage.haskell.org/package/lens search for "define lenses"
21:59:17 <halogenandtoast> thanks Koterpillar, that seems to be without lens, in addition to without makeLenses/templateHaskell
21:59:28 <halogenandtoast> I'm fine with the dependency
22:00:08 <Koterpillar> I'm not sure how much shorter can you make it
22:00:44 <Koterpillar> if you find a better one, let me know
22:05:09 <halogenandtoast> Koterpillar: will do :\
22:17:29 <halogenandtoast> Koterpillar: I gave up and used makeLenses
22:17:35 <halogenandtoast> easier not to fight it.
22:18:19 <Koterpillar> I feel like you can derive some lenses using Generic
22:26:43 <Cale> halogenandtoast: Sometimes I like to think about the price tag associated to particular lines of code, especially TH code, in our codebase. In some cases, the developer effort to maintain the stuff that the TH is generating would be pretty large, and it's good. In other cases, the makeLenses that someone absentmindedly slapped on some type adds 10 seconds to the build time for something which wouldn't really be so hard to write by hand.
22:27:46 <halogenandtoast> Cale: right now I'm just learning lenses so I don't yet have a firm grasp of how to use them, nevermind write them.
22:28:16 <Cale> Ah, in the cases where we actually get lots of use out of the lenses, I'm not usually so upset, but those cases are pretty rare. It's usually just one line somewhere.
22:28:17 <halogenandtoast> The problem is that they are so simple they're extremely complicated
22:29:03 <halogenandtoast> I really just want a few lenses to do stuff like
22:29:30 <halogenandtoast> 5
22:29:35 <halogenandtoast> https://gist.github.com/halogenandtoast/8d4a17fa78e4719c4dfc51e7cf351f05
22:31:09 <halogenandtoast> Any suggestions on how to make that better would be appreciated.
22:31:38 <halogenandtoast> I figured since I have a nested structure lenses might be a good call.
22:32:28 <Cale> Yeah, there's not really any problem with using lenses, and if your compile times aren't bothering you it's no big deal :)
22:32:39 <Cale> But I can show you how to write a lens
22:33:09 <halogenandtoast> Cale: That would be awesome, regardless of my compile times
22:33:15 <halogenandtoast> stack build  3.54s user 1.35s system 97% cpu 5.002 total
22:33:23 <halogenandtoast> which are fine
22:33:35 <Cale> focus/build-frontend  253.12s user 36.44s system 101% cpu 4:44.89 total
22:33:37 <Cale> lol
22:33:57 <Cale> (thankfully ghci works, so that's not actually something I have to wait for very often)
22:35:48 <Cale> The key pattern is that it's like you're splitting the data structure into two parts: the part which is focused on (and which view will get out), and a function which given a replacement for that part, will reconstruct the structure with that filled in
22:36:03 <sophiag> ooo, i want to listen in on this :)
22:36:36 <Cale> So for example, let's just start with the first part of a pair
22:37:04 <Cale> If we have some pair (x,y), we can split that into the function (\x' -> (x',y)) and the value x
22:38:06 <Cale> and then to get our lens, what we want is to take some function f, and the pair (x,y) and produce (\x' -> (x',y)) <$> f x
22:38:08 <Cale> i.e.
22:38:39 <Cale> @let myFst f (x,y) = (\x' -> (x',y)) <$> f x
22:38:40 <lambdabot>  Defined.
22:38:50 <Cale> > view myFst (3,4)
22:38:52 <lambdabot>  3
22:39:03 <Cale> > set myFst "hello" (3,4)
22:39:05 <lambdabot>  ("hello",4)
22:39:59 <thimoteus> :t myFst
22:40:01 <lambdabot> Functor f => (t2 -> f t1) -> (t2, t) -> f (t1, t)
22:40:52 <Cale> Let's rename that a bit: Functor f => (a -> f b) -> (a, x) -> f (b, x)
22:41:48 <halogenandtoast> I understood the type from context.
22:42:04 <Cale> The key pattern is that you're always going to be applying this arbitrary function to the part which is extracted, and then fmapping over the result of that a function which puts back everything else in the original structure
22:43:00 <Cale> Traversals are similar, except there, you get to make use of Applicative to pick out multiple bits of the structure at once:
22:43:04 <halogenandtoast> so does view fmap with id (or something to do with Const)
22:44:37 <Cale> Yeah, view uses the Const functor
22:45:04 <Cale> > myFst Const (1,2)
22:45:06 <lambdabot>  Const 1
22:45:11 <Cale> > getConst (myFst Const (1,2))
22:45:13 <lambdabot>  1
22:45:20 <Cale> :t Const
22:45:22 <lambdabot> forall k (b :: k) a. a -> Const a b
22:45:41 <Cale> set uses the Identity functor
22:46:04 <halogenandtoast> @src view
22:46:05 <lambdabot> Source not found. :(
22:46:19 <halogenandtoast> You're dead to me lambdabot 
22:46:23 <Cale> > myFst (\v -> Identity "hello") (1,2)
22:46:25 <lambdabot>  Identity ("hello",2)
22:46:31 <Cale> > runIdentity (myFst (\v -> Identity "hello") (1,2))
22:46:33 <lambdabot>  ("hello",2)
22:47:39 <halogenandtoast> I see so Identity is used for set/over
22:47:54 <Cale> yep
22:48:09 <Cale> Now for Traversals, we can follow a very similar pattern
22:48:13 <halogenandtoast> And those by themselves aren't useful, but this allows us to compose.
22:48:28 <halogenandtoast> s/\./?/
22:48:28 <Cale> But we make use of the Applicative structure available to us to pick out multiple parts at once
22:48:45 <Cale> Sorry, what's not useful?
22:49:19 <halogenandtoast> The fact that Const and Identity are used are a byproduct of wanting to compose lenses (my assumption)
22:49:37 <halogenandtoast> We need something to fit the base case.
22:49:44 <Cale> Const and Identity are used there as a way to *use* lenses that we've already built
22:49:47 <Cale> Not so much to compose them
22:50:05 <halogenandtoast> alright
22:50:09 <Cale> Composing lenses is just a matter of function composition, with the way we've set things up
22:50:14 <Cale> :t myFst . myFst
22:50:15 <lambdabot> Functor f => (t3 -> f t2) -> ((t3, t), t1) -> f ((t2, t), t1)
22:50:42 <Cale> You'll always have something of the form
22:51:05 <Cale> (a -> f b) -> s -> f t
22:51:25 <Cale> (a -> f b) -> (s -> f t)
22:51:31 <Cale> Let's add those parens for emphasis
22:51:49 <Cale> Such functions are quite likely to compose, right?
22:53:11 <Cale> It sometimes helps to consider the case when f is a monad like IO
22:53:35 <halogenandtoast> How would one ascertain that those functions are likely to compose
22:53:41 <halogenandtoast> what's the red flag I'm looking for?
22:53:57 <Cale> Given an effectful function (a -> f b) which acts on some small part of the structure, the lens explains how to transform it to act on the whole structure, replacing the small part with its result
22:54:19 <Cale> Oh, just that the shape of the type in the domain and codomain is similar
22:54:28 <halogenandtoast> Cale: okay
22:55:20 <Cale> If it helps you may want to regard a -> f b as an "effectful" function, and the lens is then telling you how to apply that effectful function to some part of a data structure.
22:56:52 <Cale> In the case of Const, the "effect" is just to abort with the value we've obtained, without ever producing a result to replace it with in the overall structure (the Const functor doesn't have a place for us even to record that)
22:57:11 <halogenandtoast> Const a b = Const a or something
22:57:21 <Cale> Yeah, data Const a b = Const a
22:57:31 <halogenandtoast> Right
22:57:48 <Cale> In the case of Identity, it's just like I described, but no potential for effects, we're applying a basically ordinary function to the value, obtaining a replacement, and putting that in.
22:58:52 <Cale> But yeah, if you want to think of these things as a way of transforming potentially-effectful functions, that might work
22:59:12 <Cale> (to operate on some smaller piece of a larger structure)
22:59:30 <Cale> (and leave the rest untouched)
22:59:42 <Cale> Good?
22:59:54 <halogenandtoast> I'm not sure I understand the term "effectful functions" well.
23:00:24 <Cale> ah, well, I mean in the sense that you might regard a function of type a -> IO b as an "effectful function"
23:01:01 <halogenandtoast> Sure, but it doesn't have to be effectful right?
23:01:14 <halogenandtoast> I'm now assuming effectful = side effect
23:01:16 <Cale> Well, the sense of the word "effect" is arbitrary
23:01:18 <halogenandtoast> but that might be incorrect
23:01:29 <Cale> because we have any functor whatsoever there
23:02:09 <Cale> The values of a lot of functors in Haskell tend to describe effects of various sorts, but sometimes you have to stretch your notion of what an "effect" consists of somewhat
23:02:58 <Cale> e.g. lists can be thought of as computations having nondeterminism effects: they can sort of describe multiple realities in which they've produced each of a number of different results
23:03:08 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
23:03:10 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
23:03:48 <halogenandtoast> That's still black magic
23:04:01 <Cale> You can think of "running" a list there as picking an element of the list, in all possible ways
23:04:18 <Cale> Of course, it just amounts to using map and concat
23:04:42 <Cale> But it's possible to think of it that way anyhow.
23:04:46 <halogenandtoast> sure, similar to a list comprehension
23:04:59 <Cale> yeah, it's exactly the same thing as a list comprehension
23:05:09 <halogenandtoast> [(x, y) | x <- [1,2,3], y <- [4,5]]
23:05:13 <halogenandtoast> > [(x, y) | x <- [1,2,3], y <- [4,5]]
23:05:15 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
23:05:47 <halogenandtoast> The syntax is even suspiciously similar
23:05:52 <Cale> > myFst (\v -> [v, 10*v, 100*v]) (1,"hello")
23:05:54 <lambdabot>  [(1,"hello"),(10,"hello"),(100,"hello")]
23:05:59 <Cale> > myFst (\v -> [v, 10*v, 100*v]) (4,"hello")
23:06:01 <lambdabot>  [(4,"hello"),(40,"hello"),(400,"hello")]
23:07:23 <Cale> So we can enumerate many possible substitutions that way
23:08:10 <nshepperd_> Hm. Nondeterminism monad that uses a quantum coin flip to literally create multiple realities for all the possible outcomes
23:09:15 <Cale> > runWriter (myFst (\v -> do tell [v]; return "told") (42, "you"))
23:09:17 <lambdabot>  (("told","you"),[42])
23:09:52 <Cale> So here, we replace the first component of the pair with a new value, and at the same time, write what was there before to the Writer monad's log.
23:10:17 <Cale> We could play similar games with State
23:11:34 <Cale> > flip runState 0 $ myFst (\v -> do x <- get; put v; return x) (1,2)
23:11:36 <lambdabot>  error:
23:11:36 <lambdabot>      Ambiguous occurrence ‘get’
23:11:36 <lambdabot>      It could refer to either ‘Control.Monad.State.get’,
23:11:40 <Cale> tsk
23:11:48 <Cale> > flip runState 0 $ myFst (\v -> do x <- Control.Monad.State.get; put v; return x) (1,2)
23:11:50 <lambdabot>  ((0,2),1)
23:12:18 <Cale> So, there, we swap the current state with the value in the first component of the pair
23:12:41 <Cale> halogenandtoast: cool?
23:13:21 <halogenandtoast> sorry reading a bit of backlog
23:13:23 <halogenandtoast> 1 sec
23:14:36 <Cale> If we could use IO here, we could do something like
23:14:53 <halogenandtoast> Cale: I guess so, I tend to learn from practical examples, so I need to figure out how to write some lenses for my structure
23:15:15 <halogenandtoast> so 1 sec, let me try one
23:15:28 <Cale> myFst (\v -> do putStrLn ("The existing value is " ++ show v ++ " enter a new one."); getLine) ("hello", "there")
23:16:11 <Cale> Yeah, these examples aren't especially practical, they're just trying to illustrate what the lens does to some extent.
23:16:53 <halogenandtoast> Cale: so let's say I have
23:16:57 <halogenandtoast> data Square = Square { mine :: Bool
23:16:57 <halogenandtoast>                      , flagged :: Bool
23:16:57 <halogenandtoast>                      , revealed :: Bool
23:16:57 <halogenandtoast>                      , mineCount :: Int
23:16:57 <halogenandtoast>                      , position :: Position
23:16:59 <halogenandtoast>                      } deriving (Show)
23:17:05 <halogenandtoast> is this a valid lens?
23:17:06 <halogenandtoast> revealed' f square@(Square _ _ r _ _) = (\r' -> square { revealed = r }) <$> f r
23:17:26 <halogenandtoast> err almost
23:17:28 <halogenandtoast> revealed' f square@(Square _ _ r _ _) = (\r' -> square { revealed = r' }) <$> f r
23:17:43 <Cale> yeah
23:18:16 <Cale> and what's the type of revealed'?
23:18:26 <Cale> (perhaps think about it a moment before asking ghci ;)
23:19:19 <halogenandtoast> Functor f => (Bool -> f Bool) -> Square -> f Square ?
23:19:30 <Cale> yep
23:19:43 <halogenandtoast> @let revealed' f square@(Square _ _ r _ _) = (\r' -> square { revealed = r' }) <$> f r
23:19:45 <lambdabot>  .L.hs:182:21: error:
23:19:45 <lambdabot>      Not in scope: data constructor ‘Square’
23:19:45 <lambdabot>      Perhaps you meant variable ‘square’ (line 182)
23:20:36 <Cale> @let data Square = Square { mine :: Bool, flagged :: Bool, revealed :: Bool, mineCount :: Int, position :: (Int, Int)  } deriving (Show)
23:20:38 <lambdabot>  Defined.
23:20:45 <halogenandtoast> @let revealed' f square@(Square _ _ r _ _) = (\r' -> square { revealed = r' }) <$> f r
23:20:45 <Cale> @let revealed' f square@(Square _ _ r _ _) = (\r' -> square { revealed = r' }) <$> f r
23:20:46 <lambdabot>  Defined.
23:20:48 <lambdabot>  .L.hs:188:1: warning: [-Woverlapping-patterns]
23:20:48 <lambdabot>      Pattern match is redundant
23:20:48 <lambdabot>      In an equation for ‘revealed'’:
23:20:48 <Cale> haha
23:20:57 <halogenandtoast> :t revealed'
23:20:58 <lambdabot> Functor f => (Bool -> f Bool) -> Square -> f Square
23:21:21 <halogenandtoast> checks out
23:21:40 <halogenandtoast> so in the case where we use view it would be
23:21:52 <halogenandtoast> (Bool -> Const Bool Bool) -> Square -> Const Bool Square
23:21:53 <Cale> > over revealed' not (Square True False False 9 (2,3))
23:21:55 <lambdabot>  Square {mine = True, flagged = False, revealed = True, mineCount = 9, positi...
23:22:12 <Cale> > revealed' Const (Square True False False 9 (2,3))
23:22:14 <lambdabot>  Const False
23:22:22 <Cale> > getConst (revealed' Const (Square True False False 9 (2,3)))
23:22:24 <lambdabot>  False
23:22:37 <Cale> and yeah
23:23:30 <Cale> You can think of a Const Bool Square as being a computation which purports to be trying to result in a Square, but never actually will, and will instead always abort with some value of type Bool.
23:24:13 <halogenandtoast> Yeah I understand Const, it's amazing.
23:24:14 <Cale> That is, if you like this computational analogy
23:24:29 <halogenandtoast> Just makes really cool use of Phantom Types.
23:26:29 <Cale> @let squareBools f (Square m l r c p) = (\m' l' r' -> Square m' l' r' c p) <$> f m <*> f l <*> f r
23:26:31 <lambdabot>  Defined.
23:26:40 <Cale> This is silly, but let's pretend for a moment that it's not
23:26:51 <Cale> :t squareBools
23:26:51 <halogenandtoast> I'm bad at pretending.
23:26:52 <lambdabot> Applicative f => (Bool -> f Bool) -> Square -> f Square
23:27:13 <Cale> This no longer works for any Functor, but it's almost like a Lens
23:27:34 <Cale> It makes use of Applicative to be able to operate on multiple parts of the structure at once
23:27:59 <Cale> The pattern is the same: we split the thing up into a function which is basically like the original structure with some holes punched in it
23:28:13 <Cale> and then apply the given function to each of the things we popped out of the holes
23:28:25 <Cale> and substitute the results back in place
23:28:48 <Cale> > over squareBools not (Square True False False 9 (2,3))
23:28:50 <lambdabot>  Square {mine = False, flagged = True, revealed = True, mineCount = 9, positi...
23:29:00 <Cale> So, there we negate all the bools at once
23:29:48 <halogenandtoast> Right
23:30:18 <Cale> and that's basically what a Traversal is
23:31:29 <Cale> > runWriter (squareBools (\b -> tell [b]) (Square True False False 9 (2,3)))
23:31:31 <lambdabot>  error:
23:31:31 <lambdabot>      • Couldn't match type ‘()’ with ‘Bool’
23:31:31 <lambdabot>        Expected type: WriterT [Bool] Identity Bool
23:31:33 <Cale> oops
23:31:42 <Cale> > runWriter (squareBools (\b -> tell [b]; return b) (Square True False False 9 (2,3)))
23:31:44 <lambdabot>  <hint>:1:39: error: parse error on input ‘;’
23:31:49 <Cale> > runWriter (squareBools (\b -> do tell [b]; return b) (Square True False False 9 (2,3)))
23:31:51 <lambdabot>  (Square {mine = True, flagged = False, revealed = False, mineCount = 9, posi...
23:31:57 <Cale> > execWriter (squareBools (\b -> do tell [b]; return b) (Square True False False 9 (2,3)))
23:31:59 <lambdabot>  [True,False,False]
23:32:06 <halogenandtoast> Cale: thanks I was able to remove TemplateHaskell.
23:33:42 <Cale> cool
23:38:42 <joneshf-laptop> Is there an elegant way to encode the idea of a list that cannot contain some items?
23:39:11 <joneshf-laptop> Like, say I wanted a list of any `Int`s except `3`.
23:40:11 <Cale> Not really
23:40:33 <joneshf-laptop> :(
23:40:35 <Cale> You really need dependent types to encode that sort of thing
23:40:48 <Cale> (types which can be parameterised on values)
23:41:00 <joneshf-laptop> Can `GHC.TypeLits` get me part of the way? :)
23:41:11 <Cale> If you're willing to work really hard at it
23:41:20 <Cale> But it's usually not going to be worth the trouble.
23:41:27 <joneshf-laptop> poo
23:41:30 <joneshf-laptop> Okay
23:41:51 <Cale> The problem is that you need to be able to talk about the value of the Int that you have at the type level
23:42:16 <Cale> So your operation for building up the list needs to use singletons or something whose type isn't simply Int
23:43:03 <Cale> joneshf-laptop: A more straightforward approach in Haskell would be to do it via abstraction of the data type.
23:44:35 <Cale> Construct a module with a data type for lists that exclude the particular values you want to exclude (supposing that this is fixed), and carefully control the operations you provide on those lists.
23:46:47 <joneshf-laptop> Makes sense
23:46:49 <joneshf-laptop> Thanks!
23:50:59 <halogenandtoast> I had this code originally:
23:50:59 <halogenandtoast> getPosition :: MaybeT IO Position
23:50:59 <halogenandtoast> getPosition = MaybeT (parsePosition <$> getInput) <|> getPosition
23:51:07 <halogenandtoast> but I want to change it to something like
23:51:31 <halogenandtoast> getMove :: MaybeT IO Move
23:51:31 <halogenandtoast> getMove = MaybeT (Reveal <$> (parsePosition <$> getInput)) <|> getMove
23:51:41 <halogenandtoast> where Reveal is a constructor Position -> Move
23:52:13 <halogenandtoast> but those types don't line up, and I'm lost, I can't see the types at the moment.
23:52:22 <halogenandtoast> I think I'm confused by the <|> and the MaybeT
23:53:34 <halogenandtoast> but I want to extend this to handle different types of moves that will be parsed differently so if parsePosition doesn't work, then I'll have a method for parsing a flag position, so I think I want the <|> and MaybeT
23:54:06 <tsahyt> joneshf-laptop: you can also leverage liquid haskell for this
23:54:45 <tsahyt> from the top of my head, {-@ type NoThrees = { v : Int | v /= 3 } @-}
23:54:53 <tsahyt> might be != instead of /=
23:55:31 <halogenandtoast> I need to get the type: Maybe Position -> IO (Maybe Move)
23:55:42 <halogenandtoast> from Position -> Move
23:57:17 <joneshf-laptop> tsahyt, nice!
23:57:22 <halogenandtoast> and an IO (Maybe Position)
23:58:08 <tsahyt> joneshf-laptop: the problem with that is that (1) liquid haskell doesn't run with GHC >7.10 yet, (2) it requires an additional checking pass through liquid haskell, since it's not part of the compiler
23:58:23 <tsahyt> but if you can live with that, you can use it to guarantee that your list never contains a 3
23:58:40 <joneshf-laptop> Unfortunately, I can't live with either :(
23:58:53 <joneshf-laptop> It's not a big deal though
23:58:59 <joneshf-laptop> It was more a curiosity.
23:59:00 <tsahyt> in almost all cases I'd opt for creating a type with a smart constructor
23:59:30 <tsahyt> e.g. newtype NoThree = NoThree Integer, with a constructor mkNoThree x = if x /= 3 then Just (NoThree x) else Nothing or something like that
23:59:37 <tsahyt> and then don't expose the NoThree constructor
