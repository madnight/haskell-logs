00:45:05 <c137> Hello, I'm trying to configure haskell-mode in Emacs. Please help me with this part "Invoke: make EMACS=/path/to/your/emacs". Does it mean directory to my emacs init.el or what?
01:08:42 <fred-fri> https://www.hackerrank.com/challenges/diagonal-difference Wrote a quick and dirty Java solution https://pastebin.com/1EtaRW1D but struggling to solve it in Haskell. I'd be interested to see any solution anyone might come up with. (asked this earlier but was disconnected)
01:13:19 <fred-fri> jle`, ping 
01:13:51 <jle`> what have you tried?
01:15:27 <fred-fri> after parsing the input into an array of arrays, ive made a terrible explicitly recursive algo that accepts a value so far and the current iteration
01:15:51 <jle`> you mean a list of lists, right?
01:15:54 <fred-fri> yes
01:16:09 <jle`> > zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0..]
01:16:11 <lambdabot>  [1,5,9]
01:16:16 <jle`> > sum $ zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0..]
01:16:16 <fred-fri> im still stuck in imperative programming mindset
01:16:18 <lambdabot>  15
01:16:40 <jle`> that's one of the diagonals
01:16:48 <jle`> for the other you can just map reverse
01:16:48 <fred-fri> christ that easy huh
01:16:57 <jle`> > sum $ zipWith (!!) (map reverse [[1,2,3],[4,5,6],[7,8,9]]) [0..]
01:17:00 <lambdabot>  15
01:17:17 <jle`> did you expect it to be hard? :p
01:17:26 <jle`> it's hard in imperative-land at least, for sure.
01:17:37 <fred-fri> well my java solution wasnt hard necessarily it just took time
01:18:37 <jle`> > map (map read . words) . lines $ "1 2 3\n4 5 6\n7 8 9"
01:18:39 <lambdabot>  [[*Exception: Prelude.read: no parse
01:18:44 <jle`> > map (map read . words) . lines $ "1 2 3\n4 5 6\n7 8 9" :: [[Int]]
01:18:46 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
01:20:06 <fred-fri> > sum $ zipWith (!!) [[11,2,4],[4,5,6],[10,8,-12]] [0..]
01:20:08 <lambdabot>  4
01:20:42 <jle`> do you see how zipWith (!!) blah [0..] gets the diagonals?
01:20:52 <fred-fri> > sum $ zipWith (!!) (map reverse) [[11,2,4],[4,5,6],[10,8,-12]] [0..]
01:20:54 <jle`> s/diagonals/diagonal
01:20:54 <lambdabot>  error:
01:20:55 <lambdabot>      • Couldn't match expected type ‘[Integer] -> [a]’
01:20:55 <lambdabot>                    with actual type ‘[c0]’
01:21:04 <jle`> watch your parentheses
01:21:23 <fred-fri> yeah, the magic is the [0..] i guess? thats what makes it take the next one to the right
01:21:45 <jle`> [0..]
01:21:55 <jle`> > sum $ zipWith (!!) [[1,2,3],[4,5,6],[7,8,9]] [0,1,2]
01:21:58 <lambdabot>  15
01:22:05 <jle`> [0..] is just [0,1,2] there
01:22:34 <jle`> so zipWith (!!) [xs,ys,zs] [0,1,2] = [xs !! 0, ys !! 1, zs !! 2]
01:22:58 <fred-fri> > sum $ zipWith (!!) (map reverse [[11,2,4],[4,5,6],[10,8,-12]]) [0..]
01:23:01 <lambdabot>  19
01:23:10 <fred-fri> mind blown
01:23:16 <fred-fri> haskell is ridiculously powerful
01:24:12 <jle`> > map reverse [[11,2,4],[4,5,6],[10,8,-12]]
01:24:14 <lambdabot>  [[4,2,11],[6,5,4],[-12,8,10]]
03:05:13 <doomlord> how is GPU programming in haskell,
04:31:55 <redfish64> Hey, I'm looking at: http://stackoverflow.com/questions/19774564/what-does-it-mean-to-compose-two-functors and it shows a syntax I've never seen before, namely "data Compose f g x = Compose (f (g x))"
04:32:35 <redfish64> I'm trying to understand the right hand side. I would look it up, but I can't figure out the right terms to search google on 
04:32:53 <session> it's a definition of a datatyp
04:32:54 <session> e
04:33:08 <redfish64> Yes, but what does (f (g x)) mean
04:33:16 <redfish64> How does it restrict it?
04:33:27 <redfish64> I tried a simpler version "data C f x = C (f x)
04:33:28 <redfish64> "
04:33:43 <redfish64> and I noticed that it accepts "C 1"
04:33:52 <redfish64> but not "C 'c'"
04:33:59 <session> C 1 would be a complicated thing to explain
04:34:03 <session> @let data C f x = C (f x)
04:34:05 <lambdabot>  Defined.
04:34:10 <session> :t C "foo"
04:34:12 <lambdabot> C [] Char
04:34:15 <session> f ~ []
04:34:17 <session> x ~ Char
04:34:21 <session> f x ~ [Char]
04:35:24 <jle`> redfish64: when you define data Maybe a = Nothing | Just a, what d you think that does?
04:35:44 <jle`> redfish64: if i did 'Maybe Int', it'd be same as data MaybeInt = Nothing | Just Int
04:35:46 <redfish64> jle`: It creates a plethera of types
04:35:57 <jle`> redfish64: if i did 'Maybe Bool' it'd be the same as 'data MaybeBool = Nothing | Just Bool'
04:35:59 <jle`> exactly
04:36:07 <jle`> same thing for 'data Compose f g x = Compose (f (g x))'
04:36:34 <jle`> if i had `Compose Maybe IO Int`, that's the same as if i had written Compose (Maybe (IO Int))
04:37:08 <jle`> data MaybeIO a = ComposeMaybeIO (Maybe (IO a))
04:37:32 <jle`> data ListMaybe a = ComposeListMaybe [Maybe a]
04:37:35 <redfish64> Ok, so it's pattern matching on the type of the right hand side
04:37:42 <redfish64> ?
04:37:49 <jle`> data IOList a = ComposeIOList (IO [a])
04:37:57 <jle`> data Compose f g a = Compose (f (g a))
04:38:15 <jle`> no pattern matching is really going on
04:38:19 <jle`> what you're doing is *parameterizing* a type
04:38:26 <jle`> so the Compose type is *parameterized* by f, g, and a
04:38:40 <jle`> and whatever you pick for f, g, and a, gives you that type
04:38:56 <jle`> so if i pick f as IO and g as Maybe and c as Int, then Compose contains an IO (Maybe Int)
04:39:05 <jle`> same for 'data Maybe a = Nothing | Just a'
04:39:14 <jle`> i'm *parameterizing* a type, on 'a'
04:39:22 <jle`> if i pick a to be Bool, the Just contains a Bool
04:39:28 <jle`> if i pick a to be an Int, then Just contains an Int
04:39:50 <redfish64> Ok, that makes sense
04:41:23 <Myrl-saki> Quick question about classical logic.
04:41:25 <Myrl-saki> Can you go
04:41:33 <Myrl-saki> `A -o B. A. Therefore A.`
04:41:51 <Myrl-saki> s/classical/linear/
04:42:01 <Myrl-saki> Or is the only valid conclusion `B`?
04:42:02 <redfish64> like so "x :: Compose Maybe Maybe Int ;x = Compose (Just (Just 5))"
04:42:16 <session> Myrl-saki, you definitely can
04:42:19 <redfish64> thx
04:42:24 <session> @djinn (a -> b) -> a -> a
04:42:24 <lambdabot> f _ a = a
04:42:58 <Myrl-saki> session: This is linear logic though, not classical!
04:43:12 <session> ah
04:43:14 <Myrl-saki> session: Though. Using djinn as proof is pretty clever.
04:43:22 <session> that's more complicated
04:43:24 <bbear> hello
04:43:28 <Myrl-saki> session: Indeed.
04:43:38 <bbear> I find myself having trouble with working with the 'Maybe' Constructor
04:44:12 <bbear> Once you start working with it, it seems you have to carry on this kind of error handling all the way through.
04:44:39 <session> Myrl-saki, you're destroying (a -> b)
04:44:43 <session> I think that's not allowed
04:44:45 <bbear> for example I have a function that returns a 'Maybe Int' and I want to index a list with it, how would I do that ?
04:44:52 <Myrl-saki> session: Yep. That's what I'm also thinking.
04:44:57 <Myrl-saki> session: a -o b isn't used.
04:44:58 <session> now, I don't have a formal definition with me so
04:45:36 <Myrl-saki> session: That's pretty interesting though, if you think about it.
04:46:15 <Myrl-saki> session: That means that for any given list of types, there should only be one conclusion.
04:46:39 <Myrl-saki> session: Or maybe you can do some ambiguity magic?
04:48:51 <jle`> bbear: you can use fmap :)
04:48:56 <jle`> i wrote a blog post about this style, actually
04:49:18 <jle`> bbear: https://blog.jle.im/entry/inside-my-world-ode-to-functor-and-monad.html
04:49:38 <jle`> i address this exact situation
04:49:56 <Hafydd> I thought that was going to be about ordinary differential equations, at first.
04:49:58 <jle`> but basically, if you have an (Int -> a) function and a Maybe Int, you can use fmap to turn it into a Maybe Int -> Maybe a
04:50:27 <jle`> > fmap ("hello" !!) (Just 2)
04:50:30 <lambdabot>  Just 'l'
04:50:38 <session> Myrl-saki, is polymorphism allowed
04:50:56 <jle`> Hafydd: those come in part 2
04:50:58 <Myrl-saki> session: Hmmm.
04:51:20 <session> A. B. (a -> b -> b).
04:52:43 <Myrl-saki> session: Okay. I need some explanation.
04:52:47 <Myrl-saki> session: What happens to A and B?
04:53:09 <session> x:A. y:B. f:(a -> b -> b)
04:53:16 <session> f x y : B
04:53:18 <session> f y x : A
04:54:31 <bennofs> Does intero have a function to lookup the haddocks for symbol under point?
04:55:07 <bbear> jle`: thanks
04:55:20 <bbear> i'm reading the article right now
04:55:21 <Myrl-saki> session: I see.
04:55:34 <Myrl-saki> session: Wadler's papers did say something about monomorphism.
04:55:52 <session> as in antipolymoprhism
04:55:57 <session> or as in monic morphisms?
04:56:03 <Myrl-saki> session: I have no idea. :P
04:58:26 <Myrl-saki> session: https://pdfs.semanticscholar.org/4106/dd3be01f1283f80a8260420138d6ee874753.pdf
04:58:29 <Myrl-saki> session: Page 3.
05:04:48 <bennofs> Is there some standard "inverted either" type? I want to find the first Right, but if there is no Right, get all the messages of the Lefts
05:05:18 <malice> Hi!
05:06:16 <malice> I have a string that I want to output. However, I want to make it concise and amazing.
05:06:29 <malice> e.g. I know I could use putStrLn, but I'd like it to be more clever
05:06:44 <malice> However, my Haskell knowledge is limited... Do you have any suggestions?
05:07:42 <srhb> malice: putStr "foo\n" is one character shorter!
05:09:29 <Myrl-saki> bennofs: Use First?
05:09:30 <srhb> malice: (Well, two, but now you need the newline!)
05:09:37 <Myrl-saki> bennofs: Oh wait.
05:10:15 <Myrl-saki> bennofs: Yeah.
05:10:34 <Myrl-saki> @hoogle
05:10:34 <lambdabot> package base
05:10:34 <lambdabot> package bytestring
05:10:34 <lambdabot> package containers
05:10:52 <Myrl-saki> @hoogle :: Either a b -> (a -> c) -> (b -> c) -> c
05:10:52 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
05:10:53 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
05:10:53 <lambdabot> Data.Strict.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
05:11:18 <Myrl-saki> Wait. Did I just say use First for Either?
05:11:23 <malice> srhb: but it's not clever
05:11:36 <malice> I mean, it's obvious and simple. I want something more creative
05:12:55 <malice> I'm not golfing :)
05:13:23 <srhb> malice: I think anything but using putStrLn to output a string on a line is _less clever_ :-P
05:13:34 <srhb> malice: Perhaps you're looking for silly or funny instead.
05:14:11 <bbear> hard
05:14:51 <MarcelineVQ> bennofs: https://hackage.haskell.org/package/validation-0.5.4/docs/Data-Validation.html#t:AccValidation possibly
05:15:17 <malice> srhb:well, that's what I meant
05:15:36 <malice> I want to be playful with the code
05:15:44 <malice> That's what I meant by clever :)
05:17:56 <srhb> malice: OK! :) Sorry, I don't think I have any good suggestions. You could try outputting each character and then sequencing the IO actions. That's a bit more complicated at least.
05:19:45 <malice> I have some idea, I'll see how it works. If anyone else has suggestions, feel free to tell me!
05:19:47 <malice> Thaks, srhb!
05:42:27 <tobiasBora> Hello! I'm getting crazy... I put a `catch` that should stop ALL exceptions, and 1h30 of execution, my program crashs because of exception! Here the exception I got this time: Error_Packet "partial packet: expecting 4096 bytes, got: 2884"
05:45:41 <lyxia> show some code :)
05:49:34 <bennofs> tobiasBora: can you show the code where you expect to catch the exception?
05:50:01 <tobiasBora> lyxia: bennofs : Here is the whole function that do most of the work: https://pastebin.com/EXnebvdf
05:50:45 <bennofs> tobiasBora: you only catch exceptions of type HttpException there
05:51:05 <tobiasBora> bennofs: Why? At the end I've "                      _ -> do
05:51:21 <tobiasBora> "
05:51:32 <bennofs> tobiasBora: because exception catching is based on type
05:51:51 <bennofs> tobiasBora: and e is infered to be the the type that the HttpExceptionRequest constructor belongs to
05:52:21 <bennofs> tobiasBora: if you write someFun `catch` \(e :: IOError) -> ... you will only catch IO errors
05:52:26 <bennofs> (as an example)
05:53:03 <tobiasBora> bennofs: So one catch can be used only one kind of exception? I though that their where one type Exception and that others exceptions would rely on it...
05:53:14 <bennofs> tobiasBora: since in this case, you do case e of HttpExceptionRequest ..., GHC infers that e :: HttpException, thus the catch only catches HttpExceptions
05:53:42 <tobiasBora> Hum I see... So how is it possible to do a catch that catches everything?
05:54:21 <bennofs> tobiasBora: you can use SomeException, a type which can wrap any exception and can be used to catch any exception
05:54:51 <bennofs> tobiasBora: note though, that's often not what you want, as some exceptions shouldn't be caught (like HeapOverflow etc)
05:55:29 <bennofs> tobiasBora: see https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions
06:32:01 <l4m8d4> Hello there, I am a haskell noob wanting to know if there is a haskell library for manipulating terms like (term)^n, where term is some polynomial
06:34:23 <Myrl-saki> l4m8d4: Yeah.
06:34:33 <l4m8d4> Like, for example, multiplying it out to get a polynomial again, and then simplify that
06:34:48 <l4m8d4> Myrl-saki: Might I hear your suggestion? ;)
06:35:26 <Myrl-saki> l4m8d4: Hmm
06:35:42 <Myrl-saki> l4m8d4: This seems one. https://hackage.haskell.org/package/polynomial
06:36:23 <Myrl-saki> l4m8d4: `(Num a, Eq a) => Num (Poly a)`
06:42:06 <l4m8d4> Myrl-saki: Thank you, that should do the trick. Just saw it can calculate polynomial^n
06:58:17 <tobiasBora> bennofs: Hum... I'm trying to follow what the second link said, but I'm not sure to understand how to check if my "SomeException" is an "HttpMessage"
06:58:28 <tobiasBora> *HttpExceptionRequest
06:58:38 <tobiasBora> I tried something like:
06:58:40 <tobiasBora> case toException ex of
06:58:42 <tobiasBora>                       HttpExceptionRequest
06:58:51 <tobiasBora> but without surprise it's not working
06:59:19 <bennofs> tobiasBora: you need to use fromException
06:59:30 <bennofs> tobiasBora: fromException :: SomeException -> Maybe e
06:59:44 <bennofs> tobiasBora: pass in SomeException, get Maybe HttpException
07:00:23 <tobiasBora> bennofs: Oh I see. And if it's not an HttpException, it will be "Nothing" right?
07:00:50 <bennofs> tobiasBora: yes
07:03:52 <tobiasBora> bennofs: Ok great thank you. I ended up with this code, can you confirm it sounds correct please? https://pastebin.com/26R1Djpz
07:09:02 <bennofs> tobiasBora: does look correct to me
07:11:55 <tobiasBora> bennofs: Ok great, thank you very much for your help. Hope this time everything will work!
07:12:14 <ggVGc> sure
07:33:28 <Myrl-saki> ggVGc: ggccg
07:33:31 <Myrl-saki> ggVGc: ggcg*
07:33:49 <Myrl-saki> ggVGc: ggcG
07:34:58 <MarcelineVQ> ggVGc: ggccggc
07:36:01 <ggVGc> uhm
07:37:51 <session> and then he whips out a pdf A4-sized article on why he's ggVGc and not ggdG
07:38:37 <ggVGc> nope, it wasn't about that this time"!
07:38:43 <ggVGc> actually, wonder if I still have the page up
07:38:49 <ggVGc> seems so
08:08:51 <itachi> when we say a function can be consider as a value with "context"? what does context mean?
08:17:28 <hpc> itachi_: it basically just means the result of the function depends on the parameters
08:18:11 <hpc> it's nothing too profound, basically just one of hundreds of rephrasings of "first class functions are pretty nice"
08:18:24 <hpc> which they are
08:18:25 <itachi_> so if a function take a Int parameter the int value is its context?
08:56:15 <monochrom> hpc: I think when the wording is "a value with context" it is working towards a functor, applicative, monad story.
09:08:53 <yigitozkavci> Hi guys, I have a generic method and looked up on Hoogle and found nothing like it. I wonder if there is a better way of doing it. Can we post code in here?
09:10:57 <glguy> You can post code to http://lpaste.net
09:17:32 <jayshua> Say I have a record `Info a = Info {infoList :: [a]}`. How would I constrain `a` to a type class? It looks like data type contexts were removed for good reasons. Is there an alternative?
09:22:30 <implementation> jayshua: you can write constraints into the type signatures of the functions dealing with Info. And in the best case, you only add it to those functions that really require `a' to meet that constraint.
09:26:07 <implementation> for example, the function isInfoListEmpty would not require that constraint, so it shouldn't have it (that's exactly why data type contexts were removed), but the function doSomeComplexInfo (that you had in mind when designing the type) does
09:26:36 <jayshua> So if I write a function that does require the constraint, the type system will prevent calling it with a value of Info that doesn't satisfy?
09:27:03 <freeside> try it! see what happens!
09:34:23 <jayshua> Ok, I think I understand now. Thanks implementation
10:03:01 <bbear> hey buddys
10:03:42 <bbear> say I have a function that does f [a]->[a] which actually performs an operation on the last element of a and append that modified value at the end of the list.
10:04:00 <bbear> for example f :: [Int]->[Int] 
10:04:21 <bbear> f foo = foo ++ [1+(last foo)]
10:04:37 <bbear> how would I do to iterate this thing a given number of times ?
10:06:04 <freeside> unfoldr?
10:06:35 <bbear> yes maybe
10:06:38 <bbear> :t unfoldr
10:06:40 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:06:53 <freeside> what you eventually want is a State monad, i think
10:07:20 <bbear> mmh yes maybe
10:07:40 <bbear> I am just trying to get the grasp of Haskell, I cannot say I am really proficient with Haskell.
10:07:42 <tomjaguarpawaway> Someone mentioned me, but now I don't know who :)
10:10:32 <rotaerk> <nh2> tomjaguarpawaway: I don't understand what the point of ProductProfunctor is. Reading the docs, it seems like it is simply a data type that is both Applicative and Profunctor. Then, why is there need for an extra class for it, why would using `(Applicative (p a), Profunctor p) => ... p ...` not be enough?
10:10:56 <rotaerk> is the last mention of you in my history :P
10:13:47 <freeside> bbear: it is traditional to cons to the head of the list rather than append to the tail
10:13:53 <freeside> so, use : instead of ++
10:15:55 <Cale> It's not just traditional
10:16:04 <Cale> x:xs is constant time
10:16:09 <bbear> yes I know
10:16:10 <Cale> xs ++ [x] takes O(length xs) time
10:16:22 <bbear> but I would prefer to use unfoldr
10:16:42 <bbear> getPath = unfoldr (\foo -> if (snd foo)==Nothing then Nothing else Just (foo, benderNextState  foo) )
10:17:09 <bbear> I don't know if unfoldr has teh same limitation though.
10:18:59 <sk35_bot_mil> Are Lists in haskell single linked lists ? And if so then last and init more expensive than head and tail? (Apropros ++ and : )
10:19:08 <ski> @type isNothing
10:19:09 <lambdabot> Maybe a -> Bool
10:19:12 <Cale> Yes
10:19:39 <Cale> @src last
10:19:39 <lambdabot> last [x]    = x
10:19:39 <lambdabot> last (_:xs) = last xs
10:19:40 <lambdabot> last []     = error "Prelude.last: empty list"
10:19:53 <Cale> You can see here that last is recursive, and has to walk down the entire list
10:19:56 <Cale> @src init
10:19:56 <lambdabot> init [x]    = []
10:19:56 <lambdabot> init (x:xs) = x : init xs
10:19:56 <lambdabot> init []     = error "Prelude.init: empty list"
10:19:59 <Cale> similarly here
10:20:08 <Cale> @src tail
10:20:09 <lambdabot> tail (_:xs) = xs
10:20:09 <lambdabot> tail []     = error "Prelude.tail: empty list"
10:20:33 <Cale> @src (++)
10:20:34 <lambdabot> []     ++ ys = ys
10:20:34 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:20:34 <lambdabot> -- OR
10:20:34 <lambdabot> xs ++ ys = foldr (:) ys xs
10:20:51 <Cale> Here you can see why xs ++ ys would take O(length xs) time
10:21:16 <sk35_bot_mil> Yep
10:21:23 <sk35_bot_mil> Thx
10:21:27 <Cale> A common way to avoid this problem if you're writing a program which would otherwise concatenate a lot of lists
10:22:02 <Cale> is to replace the list type [a] with the function type [a] -> [a], with the idea being that you're going to construct a function which adds elements to the beginning of another list it's given
10:22:08 <Cale> [] becomes id
10:22:11 <Cale> [x] becomes (x:)
10:22:22 <Cale> and, importantly, (++) becomes (.)
10:22:38 <Cale> Since function composition is constant time, this can improve the asymptotic performance of programs
10:23:25 <Cale> You can then apply the resulting function to an empty list at the end to recover the ordinary list result.
10:24:08 <Cale> For example, suppose we had  data Tree a = Tip | Branch (Tree a) a (Tree a)
10:24:20 <Cale> and we wanted to write an in-order traversal of that
10:24:25 <Cale> We might naively start with
10:24:33 <Cale> inorder :: Tree a -> [a]
10:24:38 <Cale> inorder Tip = []
10:24:49 <Cale> inorder (Branch l x r) = inorder l ++ [x] ++ inorder r
10:25:24 <Cale> But in the worst case of a left leaning tree, this will take quadratic time
10:25:36 <Cale> So, we can apply that trick:
10:25:44 <Cale> inorder' :: Tree a -> [a] -> [a]
10:25:49 <Cale> inorder' Tip = id
10:26:01 <Cale> inorder' (Branch l x r) = inorder' l . (x:) . inorder' r
10:26:20 <Cale> and then to recover the final result, we can apply the function we built to an empty list:
10:26:27 <Cale> inorder t = inorder' t []
10:26:57 <Cale> and that's now linear time in the size of the tree
10:35:01 <sk35_bot_mil> Thats nice. 
10:37:57 <sk35_bot_mil> I am pretty new to haskell so I dont know if it is somehow possible to have a looping data constructor. Like Enum but if you rum succ on the last constructor you get the first ?
10:39:25 <freeside> https://wiki.haskell.org/Tying_the_Knot
10:40:15 <Cale> sk35_bot_mil: Oh, the behaviour of Enum just depends on how the instance is written -- usually people expect that you'll use the derived instance, but if you want, you can write your own.
10:40:48 <ExpHP> @djinn (Applicative f)=> (f Bool -> f b -> c) -> (f (Maybe b) -> c)
10:40:48 <lambdabot> Error: Class not found: Applicative
10:41:13 <ExpHP> @djinn (Monad f)=> (f Bool -> f b -> c) -> (f (Maybe b) -> c)
10:41:14 <lambdabot> -- f cannot be realized.
10:41:19 <ExpHP> :O
10:41:45 <sk35_bot_mil> Yes I thought so and my next thought was maybe someone else already did that and I just dont know it yet
10:42:20 <ExpHP> @djinn ((a -> Bool) -> (a -> b) -> c) -> (a -> Maybe b) -> c
10:42:20 <lambdabot> -- f cannot be realized.
10:42:30 <ExpHP> uhm
10:42:44 <freeside> http://stackoverflow.com/questions/5684049/is-there-some-way-to-define-an-enum-in-haskell-that-wraps-around
10:44:37 <hpc> ExpHP: that's correct
10:44:51 <hpc> you can't produce an (a -> b) to pass to that first function
10:44:58 <hpc> so you can't get c
10:45:11 <ExpHP> oh rats
10:45:58 <sk35_bot_mil> freeside: thx
10:46:41 <freeside> urwlcm
10:48:45 <bbear> how can I display my list one element per line ?
10:49:10 <freeside> unlines
10:49:41 <freeside> > putStr $ unlines $ show <$> [1..3]
10:49:43 <lambdabot>  <IO ()>
10:50:19 <ExpHP> bbear: you can do mapM_ print [1,2,3,4]
10:50:44 <ExpHP> bbear: which is the same as print 1 >> print 2 >> print 3 >> print 4 (er, mostly the same)
10:51:16 <ExpHP> :t mapM_
10:51:16 <bbear> ok
10:51:17 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
10:54:04 <bbloom> if I under `read "x"` in to ghci, I get out an Exception with "no parse" - I was surprised by that, vs getting an ambiguous instance resolution. how do i know what code is actually running here?
10:54:16 <bbloom> s/under/enter
10:54:45 <Cale> bbloom: try   read "()"
10:55:08 <geekosaur> bbloom, see the ExtendedDefaultRules ghc extension
10:55:36 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#type-defaulting-in-ghci
10:56:15 <bbloom> Cale: that's odd, since :t tells me that the type is `Read a => a` - is there a way to tell me that it will actually be unit?
10:56:22 <bbloom> geekosaur: thanks. looking
10:57:46 <Cale> bbloom: Have a look at the link I posted
10:58:05 <bbloom> Cale: thanks. reading that now
10:58:36 <Cale> bbloom: Basically, ghci tries harder than usual to default any ambiguous types, because it's easier in isolation to write expressions whose type is ambiguous
10:59:43 <bbloom> ok - gotcha. thanks folks
11:07:40 <jle`> is there a nice way to use explicit type annotations with operators?
11:07:51 <jle`> *type applications
11:08:15 <freeside> huh?
11:08:34 <jle`> instead of (+) @Int 3 4
11:08:38 <jle`> can i use (+) in operator form
11:08:49 <jle`> and still the type application?
11:08:56 <jle`> `3 + @Int 4` doesn't quite work
11:09:10 <bbear> break point s in Haskell ? Is that possible ?
11:09:53 <freeside> https://ghc.haskell.org/trac/ghc/ticket/12363
11:10:36 <arun_t> any one from India particularly from delhi/ncr in haskell community?
11:11:18 <jle`> freeside: oh thanks.  they use the same example that i used, haha
11:11:31 <jle`> i suppose + is the universal first example of an operator
11:11:44 <freeside> bbear: https://wiki.haskell.org/Debugging#Dynamic_breakpoints_in_GHCi
11:28:37 <t7> do you guys write haskell with 80 char cols?
11:29:37 <freeside> i use 40 char cols. it breeds discipline.
11:30:37 <t7> should i stop using 1/2/3 letter variable names?
11:31:17 <freeside> only after your first 1000th variable declaration.
11:31:50 <t7> do you mean 26^3 ?
11:32:00 <freeside> :)
11:32:10 <freeside> 33696
11:32:33 <freeside> 26*36*36, then
11:32:58 <ExpHP> don't forget ', _, capitals...
11:33:16 <freeside> ... unicode ...
11:36:03 <t7> @hoogle Maybe a -> Either a b
11:36:03 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
11:36:03 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
11:36:03 <lambdabot> Music.Theory.Either fromLeft :: Either a b -> Maybe a
11:36:58 <ExpHP> :t either id undefined
11:36:59 <lambdabot> Either c b -> c
11:37:17 <ExpHP> :t either Just (error "eitherToMaybe")
11:37:18 <lambdabot> Either a b -> Maybe a
11:37:31 <ExpHP> :t either Just (const Nothing) -- me dumdum
11:37:32 <lambdabot> Either a b -> Maybe a
11:37:49 <t7> @hoogle Maybe a -> Either a ()
11:37:49 <lambdabot> Agda.Utils.Either maybeToEither :: Maybe a -> Either () a
11:37:49 <lambdabot> Foreign.Ruby.Helpers runscript :: String -> IO (Either String ())
11:37:49 <lambdabot> System.Console.Readline setStartupHook :: Maybe (IO ()) -> IO ()
11:40:59 <twanvl> ?type preview _Left
11:41:01 <lambdabot> MonadReader (Either b c) m => m (Maybe b)
11:41:46 <ckubrak> Hi guys, how can I do a line break in a show instane?
11:41:47 <t7> lenses... 
11:41:51 <t7> macro hell
11:42:27 <ckubrak> instance*
11:42:59 <t7> \n ?
11:43:07 <twanvl> show (MyThing x y) = show x ++ "\n" ++ show y
11:43:38 <geekosaur> but in general if you are using Show for anything but debugging (where it should output somrthing that is valid Haskell source), you're doing it wrong
11:43:48 <geekosaur> there are prettyprinting libraries out there for formatted output
11:43:55 <ckubrak> twanvl: I get the \n printed instead
11:44:22 <geekosaur> also remember that ghci calls show by default; use putStrLn to see what it really has
11:45:44 <geekosaur> > "foo\nbar" -- uses Show
11:45:47 <lambdabot>  "foo\nbar"
11:46:04 <geekosaur> > text "foo\nbar" -- in ghci use putStrLn (bot won't do that)
11:46:06 <lambdabot>  foo
11:46:06 <lambdabot>  bar
11:48:03 <ckubrak> geekosaur: *Main> show "A\nB" gets me "\"A\\nB\""
11:48:20 <merijn> Dear jesus, will the endless bikeshedding about FTP ever end?! >.<
11:48:28 <glguy> ckubrak: That's what it's supposed to do
11:48:36 <c_wraith> ckubrak: try putStrLn
11:48:39 <monochrom> Wait, there is still bikeshedding about FTP?
11:48:40 <geekosaur> yes, because nowe you have your explicit show plus the one ghci did, so it does show (show ...)
11:48:53 <geekosaur> which is why I said use putStrLn
11:48:54 <c_wraith> monochrom: complaints about Foldable instances again.
11:49:09 <monochrom> Ah, not AMP. Nevermind.
11:49:42 <c_wraith> Though I really like ezyang's suggestion of a couple of pragmas that will cause warnings when some instance methods are called without being explicitly chosen.
11:49:52 <merijn> monochrom: If people were still bikeshedding AMP I would personally fly to their houses and beat sense into them
11:49:53 <monochrom> Actually it was not so much bikeshedding as two derivers in GHC doing different things.
11:50:31 <monochrom> And edwardk raised a good question. How do you even specify derivations?
11:50:56 <geekosaur> isn't 8.2 supposed to fix that?
11:50:59 <glguy> the current dragged out discussion isn't so much about the color of the bikeshed as the purpose of the bike
11:51:07 <geekosaur> deriving strategies
11:51:12 <ckubrak> glguy: c_wraith I have a board (let's say a chess board) and I'd like to visualize it as a board for easier reading
11:51:28 <glguy> ckubrak: that's not what show is for
11:51:44 <geekosaur> [01 18:43:16] <geekosaur> but in general if you are using Show for anything but debugging (where it should output somrthing that is valid Haskell source), you're doing it wrong
11:52:37 <geekosaur> and even more specifically it should match what the Read instance understands
11:53:16 <glguy> ckubrak: you need to define a function :: Board -> String.  and then combine that with putStr
11:55:09 <ckubrak> glguy: Why is it Board -> String and not Board -> IO if putStr is String -> IO
11:55:12 <bbear> how to read n lines from the input with EOL char stripped ?
11:56:19 <c_wraith> bbear: EOL isn't a character.
11:56:30 <glguy> ckubrak: The String -> IO () part is already done
11:56:34 <Sornaensis> > print
11:56:36 <lambdabot>  <() -> IO ()>
11:56:37 <glguy> ckubrak: Your job is Board -> String
11:56:53 <c_wraith> bbear: still, try using getLine and replicateM
11:56:54 <Sornaensis> :t '\EOF'
11:56:56 <lambdabot> error:
11:56:56 <lambdabot>     lexical error in string/character literal at character 'E'
11:57:01 <ckubrak> Ok thanks
11:57:04 <c_wraith> Sornaensis: it was EOL, not EOF
11:57:17 <Sornaensis> yes I know
11:57:21 <glguy> bbear: replicateM n getLine
11:57:54 <TheQYD> does anyone know what "->" is supposed to read like?
11:58:04 <merijn> Oh! I forgot today is SIGBOVIK proceedings are published :)
11:58:19 <c_wraith> TheQYD: I usually read it as "to"
11:58:41 <glguy> > '\LF'
11:58:43 <lambdabot>  '\n'
11:59:02 <Sornaensis> > '\CR'
11:59:04 <lambdabot>  '\r'
11:59:39 <TheQYD> @c_wraith so "a -> b" is read as "a to b"?
11:59:39 <lambdabot> Unknown command, try @list
12:00:02 <c_wraith> TheQYD: yeah.  If I want to be more verbose "a function from a to b"
12:00:06 <glguy> > '\^J'
12:00:08 <lambdabot>  '\n'
12:00:15 <c_wraith> TheQYD: which often just gets shortened to "a to b"
12:00:37 <bbear> how to print the whole content of a list ?
12:00:42 <bbear> line(by line)
12:00:42 <TheQYD> lol, how do you ping someone in here?
12:00:58 <c_wraith> TheQYD: just put their name at the start of the line
12:01:02 <glguy> TheQYD, you just use their name.
12:01:14 <bbear> how do I get intelligent ?
12:01:23 <TheQYD> <c_wraith> like this?
12:01:33 <TheQYD> lol, i guess not
12:01:36 <c_wraith> bbear: if you want to print each list on its own line, mapM_ print 
12:01:53 <bbear> mapM_ print myList
12:01:54 <bbear> ok
12:01:56 <bbear> thanks
12:03:18 <c_wraith> err,  each list *entry* on its own line.
12:04:15 <TheQYD> either way, thanks :)
12:07:38 <TheQYD> I have a second question
12:08:37 <TheQYD> It's in the chapter "Where?!" in the learn you a haskell book
12:09:39 <TheQYD> In the last example, they have a statement "(f:_) = firstname" and I don't know what that means or what it's supposed to do
12:10:32 <c_wraith> TheQYD: is that the whole line?
12:11:20 <c_wraith> > let (f:_) = "hello" in f
12:11:22 <lambdabot>  'h'
12:11:32 <geekosaur> keep in mind that any binding is a pattern match. the pattern there extracts the first character of firstname
12:11:36 <c_wraith> > let (f:_) = [False, True] in f
12:11:38 <lambdabot>  False
12:11:55 <geekosaur> (presuming firstname :: String)
12:12:03 <TheQYD> actually, the code is here: https://pastebin.com/VgrJz4fs
12:12:48 <geekosaur> yes, those are local bindings in a where clause
12:13:19 <geekosaur> and as I said, any binding is actually a pattern match; the degenerate case is one that always matches and binds the whole expression (where f = ...)
12:13:40 <TheQYD> so how does it pluck the first initial, exactly?
12:13:56 <c_wraith> TheQYD: are you familiar with how String is represented in Haskell?
12:14:23 <TheQYD> yeah
12:14:23 <geekosaur> "Hello" is the same as 'H':'e':'l':'l':'o':[]
12:14:44 <geekosaur> so you pattern match on the first : and take the thing on the left, which is the first character
12:15:05 <TheQYD> oooohhhhhhhhh i get it !!
12:15:09 <geekosaur> the _ is a wildcard that doesn't bind anything, and receives the tail ("ello" or 'e':'l':'l':'o':[])
12:15:32 <TheQYD> that's also in python !! thank you !!
12:17:37 <ski> > let f:_ = [True,False] in f
12:17:39 <lambdabot>  True
12:41:48 <sophiag> hi! can anyone point me to how to derive Show instances for existentials? 
12:44:12 <c_wraith> It seems unlikely that you can derive a Show instance for most existentials.
12:44:21 <c_wraith> How do you convert a value of an unknown type to a String?
12:47:41 <sophiag> c_wraith: well, not the correct terminology really. ghc is telling me i can "use a standalone deriving declaration instead," but i'm not sure what that means
12:48:03 <c_wraith> sophiag: what's your data declaration?
12:48:36 <alexelcu> Newbie question: Is there any way in ghci or in Emacs/Intero or some other extension to get the docs of a function or type, like what you can get from hackage? :info is only giving me the signature, which is useful, but I often find myself going to the web browser to search in hackage.
12:49:03 <sophiag> c_wraith: there are three i'm dealing with, but here's an example: "data LambdaT = forall a. LambdaType (a -> Bool)"
12:49:23 <sophiag> i'm also confused because one isn't an existential...unless i'm confused, which is very possible
12:49:28 <freeside> alexelcu: i've been wondering that too. sadly, a typical ghc install doesn't actually include the .hs source code to haskell.
12:49:36 <c_wraith> sophiag: ok, there's just no way to derive Show for that at all.  Not only is it existential, it contains a function.
12:50:15 <sophiag> ah ok. in that case i should probably just abandon the idea
12:50:29 <sophiag> i only wanted Show to test it in ghci
12:50:37 <ski> the other two ?
12:50:50 <c_wraith> sophiag: you know you can write an instance manually, right?  It just can't do anything with the function.
12:50:52 <Aruro> alexelcu: there is local docs for new versions of cabal, every package u install installs local docs
12:51:36 <sophiag> c_wraith: i know i can, but i'm asking _how_ to. as stated, i'd just like to check functions that use these constructors are working correctly
12:52:04 <sophiag> do i just write a function that prints that type?
12:52:12 <ski> you can't even do that here
12:52:17 <c_wraith> sophiag: well, basically everything you can do with that is roughly equivalent to instance Show LambdaT where show = "LambdaT <>"
12:52:21 <ski> `a' is an unknown/hidden/opaque type
12:52:34 <Aruro> alexelcu: .cabal/share/doc/i.../
12:52:42 <c_wraith> sophiag: as an aside, that type is basically useless.  You can't call the function it contains after unpacking it.
12:52:57 <ski> if you had `data LambdaT = forall a. Typeable a => LambdaType (a -> Bool)', then you could print the type at least ..
12:53:17 <sophiag> ski: oh, that helps
12:54:10 <sophiag> c_wraith: i was under the impression i could use it as long as i have a way to match the type what i'm applying it to...which i do
12:54:28 <c_wraith> sophiag: well, no.  With that definition, you don't.
12:54:30 <alexelcu> Aruro: I'm using stack, don't have a .cabal directory
12:54:48 <c_wraith> sophiag: if you used the variant with a Typeable constraint, then you'd have some way of doing something with it.
12:55:03 <Aruro> alexelcu: stack has docs too, look inside .stack
12:55:17 <ski> something like `instance Show LambdaT where showsPrec p (LambdaT f) = showParen (p > 10) $ showString "LambdaT " . showParen True (showString "_ :: " . shows (typeOf f))'
12:55:56 <sophiag> wait, so i'm fine making all these Typeable. but that doesn't seem to be enough on its own to add a Show instance
12:56:18 <geekosaur> Typeable is not sufficient
12:56:36 <sophiag> ok...so what's the real answer
12:57:01 <ski> sophiag : if you have `isUpper :: Char -> Bool', then wrap it into `LambdaType isUpper :: LambdaT', and then match than on `LambdaType f', then `f :: a -> Bool' for an *unknown* type `a'. there is no way to recover which type `a' is in this case. unless you add the `Typeable a' constraint to the existential .. or do other stuff
12:57:24 <geekosaur> and even then, the compiler iwll not automatically generate code that uses typeOf for you
12:57:32 <geekosaur> to recover something like Show
12:57:46 <ski> sophiag : did you try the instance i suggested ?
12:58:33 <sophiag> ski: i did not because geekosaur came on and said using Typeable wasn't sufficient
12:58:33 <Aruro> sophiag: haskell can not show types of functions, what do u expect :)
12:58:50 <Aruro> no show instances for functions
12:59:01 <geekosaur> you'd be surprised
12:59:08 <sophiag> Aruro: i expect if i apply a function to arguments of the correct type then it will work...
12:59:09 <ski> sophiag : it's sufficient for showing the type of the function. it's not sufficient for recovering *which* function is in there
12:59:41 <sophiag> ski: ok. that's not the question i asked
12:59:59 <Aruro> sophiag: general answer haskell good at making types, not good at all at inspecting them.
13:00:02 <sophiag> and obviously i know Typeable does that
13:00:08 <geekosaur> Aruro, in fact if you have a monomorphic function it is possible to make a non-trivial Show instance. with type-indexed Typeable that's supposed to show up soon (maybe even 8.2) that might be expandable to polymorphic functions
13:00:29 <sophiag> Aruro: general answer to what question?
13:00:34 <ski> "do i just write a function that prints that type?" suggested to me that even getting the type of it shown would help
13:00:53 <geekosaur> (the trivial instance being instance Show (a -> b) where shows _ = "<function>", which you can find in Text.Show.Functions :)
13:01:09 <sophiag> ski: did i write that quote?
13:01:13 <raduom> sophiag why not use something like: data LambdaT = forall a. Typeable a => ... ?
13:01:14 <ski> yes
13:01:25 <raduom> sophiag why not use something like: data LambdaT = forall a. Show a => ... ?
13:01:36 <ski> raduom : would not help at all
13:01:41 <ski> it's a function in there
13:02:01 <raduom> ah. got it.
13:02:07 <ski> being able to show values that could be passed as inputs to it doesn't really help with showing the function
13:02:19 <ski> (especially not if you have no idea which type that input type is)
13:02:19 <sophiag> ok, as the person who asked this question i'd like to politely state that this discussion has quickly become unhelpful
13:02:40 <Aruro> sophiag: u got answer, not possible
13:02:55 <ski> sophiag : ty for telling us. sorry, it seems that what you want isn't possible
13:03:41 <sophiag> Aruro: i got several answers...half saying it was possible band then clarifying that i had to change the meaning of "it"
13:04:14 <ski> (it still not being fully clear to me what it is you want, you not having provided much context. XY problem and all that)
13:04:26 <MarcelineVQ> my x y sense is tingling, what are you trying to do? beyond showing a function, what are you trying to learn from showing it?
13:04:32 <MarcelineVQ> oop hehe
13:04:56 <sophiag> MarcelineVQ: already said that
13:05:10 <Aruro> he wante to derive show instances for existencials, if i remember
13:05:17 <Aruro> d*
13:05:25 <ski> yes, but for which purpose ?
13:05:33 <Aruro> he did not say
13:05:34 <sophiag> purpose already stated
13:06:13 <sophiag> also, regarding types, probably safe to infer that someone with one of the most common female names in the world is not "he"
13:06:21 <MarcelineVQ> sophiag: what you said made me think you should be trying to examine what results from applying a function, knowing more about your goal would clarify whether that's a good idea or not
13:06:46 <Aruro> sophiag: dont be offended in some of the most cool cultures on earth, in their language there is no she or he.
13:07:21 <sophiag> Aruro: then speak in that language
13:07:47 <Aruro> sophio is male name in some parts of the world, btw
13:07:49 <glguy> It looks like this discussion has diverged from being about Haskell and is now about the discussion
13:07:51 <MarcelineVQ> 4 lines about it is surely enough :>     Could you restate your current goal sophiag? Not for this specific problem, but what you're using it for?
13:08:08 <sophiag> Auroro: so is "bob." both are names that are not mine...
13:08:10 <ski> unfortunately "i'd just like to check functions that use these constructors are working correctly" and "a way to match the type what i'm applying it to" aren't that clear to us. seeing more actual code might help. trying to explain more of the picture might help
13:08:12 <bjs> sophiag: can you give an example of one of your LambdaT's and what (show it) should return?
13:08:35 <Aruro> sophiag: s/he/she/ above :)
13:12:57 <Aruro> > head [[]]
13:12:59 <lambdabot>  []
13:13:42 <Aruro> sounds like a valid 1st april haskell expression
13:14:13 <bjs> Aruro: hmm?
13:14:27 <MarcelineVQ> There's better things to get mad about, like the randomness of people choosing Control vs Data namespaces
13:14:51 <Aruro> yes^ there was discussion about lense a month ago :)
13:14:55 <Aruro> Control.Lense
13:17:23 <Aruro> > tail [[]]
13:17:26 <lambdabot>  []
13:17:58 <Sornaensis> > tail []
13:17:59 <lambdabot>  *Exception: Prelude.tail: empty list
13:18:42 <Aruro> :t tail [[]]
13:18:44 <lambdabot> [[t]]
13:25:03 <lolisa> Hi, I'm doing a DSL in haskell, all is quite well, however I'm new to Haskell (although done other FP lang before), so can anyone look at my code and give some suggestion?
13:26:14 <raduom> lolisa it could help if you post it on lpaste, or some other similar paste bin.
13:26:40 <lolisa> Sry, forgot it: https://github.com/ThoughtWorksInc/DeepDarkFantasy/tree/master/lib
13:26:41 <raduom> does anyone know how i might be able to trigger scotty to shutdown from something like an external thread?
13:31:44 <kirillow> what I have is a list of numbers from 1 to 6 `[1,4,5,4,3,6]`, what i need is a list with the numbers of occurances indexed at positions 0 to 5 `[1,0,1,2,1,1]` - can somebody shove me into some direction? im completely clueless at this point
13:33:14 <raduom> kirillow you could fold the list over a 6 elements vector.
13:33:31 <freeside> reminds me of https://twitter.com/baeshaj/status/847254344277794816 lol
13:33:58 <lolisa> if you dont need eifficency, sort and group
13:38:02 <bbear> http://vpaste.net/tmfY7 what is wrong ?
13:38:08 <Welkin> vpaste? o.o
13:38:23 <bbear> BenderLib.hs:127:11: error: Not in scope: data constructor ‘SValue’
13:38:36 <Welkin> that is some weird lokoing haskell...
13:38:42 <Welkin> almost looks like a java programmer wrote it
13:39:17 <Welkin> why aren't you using case expression/pattern matching?
13:39:23 <Welkin> it wil be much easier to read
13:39:28 <Welkin> will*
13:39:32 <bbear> that's a typical else if use case
13:40:05 <geekosaur> bbear, what specifically is wrong is that uppercase initial letter is always a constructor
13:40:11 <geekosaur> you cannot define a binding SValue
13:40:49 <kirillow> thanks!
13:42:03 <ryba> hi, could anyone recommend me some online/downloadable learning material for category theory, type theory and lambda calculus?
13:42:26 <ryba> im not really used to mathy stuff, so something with more verbose explanations would be appreciated
13:43:20 <Welkin> This book is great https://www.goodreads.com/book/show/1511125.Conceptual_Mathematics
13:43:36 <Welkin> it was written to be used either in a high school class, or a first-year college course
13:43:36 <Aruro> ryba: why do u think u need it?
13:43:49 <Welkin> it's an introduction to category theory
13:44:49 <ryba> Aruro: to learn stuff that haskell is based on
13:45:04 <Aruro> what about just learning haskell?
13:45:14 <Welkin> for type systems, "Types and Programming Languages" by Benjamin Pierce
13:46:08 <ryba> Aruro: kind of done, at least i get most important parts
13:46:25 <ryba> Aruro: now i want to understand those more exotic parts :)
13:46:46 <Aruro> :) haskell is not CT, because monad is not a monad
13:47:15 <ryba> Aruro: than what is monad if it is not a monad?
13:47:39 <freeside> alongside those books, any good video recommendations?
13:48:08 <Welkin> freeside: there is a course by Wadler that is an intro to functional programming with haskell
13:48:11 <Welkin> but that is really basic
13:48:42 <Aruro> ryba: CT is overrated thats what im saying, trying to save u time.
13:49:31 <ryba> Aruro: i have plenty of time. Either this or farming in Dark Souls, or other equally stupid entertainment
13:49:49 <Welkin> ryba: are you a first-year grad student?
13:49:50 <Welkin> lol
13:50:16 <Aruro> ryba: what about devoting time to study history of science and math?
13:50:27 <dolio> Why are you trying to discourage someone from learning something interesting?
13:50:47 <Aruro> it will make u look with a good eye and perspective on that THING they call CT
13:50:48 <ryba> Welkin: nope, actually finishing masters, but i didn't have alot of math while studying
13:50:59 <ryba> Welkin: actually i regret ditching algebra now
13:51:32 <ryba> Welkin: anyway, i have more hardware oriented studies
13:51:47 <Welkin> yeah, mine was like that too
13:51:57 <ryba> Aruro: so why are you trying to convince me not to learn CT?
13:52:19 <Aruro> ryba: do u have solid math background?
13:52:22 <exio4> category theory is interesting and fun 
13:52:33 <ryba> Aruro: no, but i want to have
13:52:38 <Welkin> you don't need a "solid math background", whatever that means
13:52:59 <Welkin> I already linked a category theory book written by one of the inventors of the subject
13:53:05 <Welkin> and it is meant for high school students
13:53:05 <Welkin> o.o
13:53:09 <Welkin> or college freshmen
13:53:23 <Aruro> Welkin: :) so u say solid math background is not needed?
13:53:39 <Welkin> no, because you need to start somewhere
13:53:48 <Aruro> nothing is needed u say?
13:54:14 <Aruro> not even algebra and group theory?
13:54:17 <Welkin> ...
13:54:25 <Welkin> no
13:54:26 <exio4> you don't need to have a high level of mathematical maturity to start, you need to be open to developed it though
13:54:35 <Welkin> and this isn't going anywhere Aruro 
13:54:40 <ertes> Aruro: to learn CT you need to be able to use logical reasoning…  it's a pretty self-contained topic fortunately
13:54:41 <Welkin> you may as well quit while you are behind
13:54:53 <exio4> Aruro: I learnt the basics of CT before learning about groups, it helped me learn about group theory later though
13:55:09 <exio4> s/developed/develop/
13:55:25 <ertes> Aruro: and at least an intuitive understanding regarding sets (or types)
13:55:54 <exio4> which are pretty much high school math topics
13:56:14 <ryba> i can handle sets, i didn't ditch those classes :)
13:56:16 <monochrom> Bear in mind people vary wildly on this.
13:56:43 <ryba> anyway, CT check, Type check, anything good on lambda?
13:56:52 <monochrom> And I don't mean their opinion. I mean how well they cope.
13:57:29 <monochrom> There are people who can learn an abstraction for sustainedly a year without needing one single example.
13:57:38 <monochrom> And there are people who can't.
13:58:20 <ertes> well, one unfortunate thing about CT is that most interesting categories are *massive* (like the category of sets), and to get into some more advanced territory it helps if your brain doesn't mind things that were morphisms just a minute ago becoming the objects of a different category
13:59:07 <ertes> at least that's what i found most mind-bending…  but the core is pretty simple
13:59:35 <ryba> ertes: the more mindfuck the better i take it :P
13:59:36 <monochrom> I went through that hurdle a long time ago when learning merely set theory.
14:00:11 <monochrom> Basically I didn't get the memo early about how {{1}} /= {1}, so to speak.
14:00:35 <ertes> the indicator that you have learned logic and category theory well is when you object to my choice of words (*the* category of sets) =)
14:01:14 <monochrom> But once told, I saw that they could declare that one set (with its own elements) could play the role of a mere element in another set. From that point on, I expect everything to be possible. :)
14:01:39 <ertes> everything?  as in…
14:01:42 <ertes> > undefined -- ? =)
14:01:44 <lambdabot>  *Exception: Prelude.undefined
14:01:55 <monochrom> Oh, it's just an expectation.
14:02:23 <dolio> monochrom: None of the good set theories let you do that. :þ
14:02:26 <ryba> i did learn a bit of CT, up to some point (somewhere around cartesian closed categories, before functors), but my source was badly written, so i couldn't get past a certain point
14:02:56 <monochrom> But more specifically, every change or roles.
14:03:00 <monochrom> s/or/of/
14:04:01 <ertes> ryba: i learned CT by implementing it in agda and proving stuff within it
14:04:36 <ertes> but it's a lot of work, and not necessarily fun work
14:05:20 <ryba> ertes: not sure if im interested in agda. im interested mainly in haskell because it's more general purpose
14:06:02 <ertes> ryba: implemented for theorem proving, not programming
14:06:28 <freeside> kirillow: your problem is described by the `hist` example from https://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array.html
14:06:44 <ryba> ertes: yup, so it's not really stuff for me
14:09:15 <Aruro> ryba: now im not sure what is better CT or DarkSouls
14:09:18 <Aruro> hard choice
14:09:19 <ertes> as a non-mathematician i would never have been confident about my constructions and proofs without a proof assistant…  it wasn't a particularly smooth experience, but a useful one…  today i probably wouldn't use agda though
14:09:33 <freeside> what would you use?
14:10:10 <ryba> ertes: i'll think about it once i need it
14:11:26 <Aruro> ertes: if u used agda to back up your thoughts u are probably rather decent mathematician.
14:11:36 <ryba> ertes: besides, won't haskell be sufficient for this once it gets dependent types?
14:11:47 <ertes> freeside: good question…  i'd like something that is more interactive and less explicit about universes…  i'd like to see an implementation of HOL in haskell, because i really don't want to learn SML
14:11:58 <ertes> or ocaml for that matter
14:12:22 <ryba> ertes: expand(HOL), expand(SML)
14:12:40 <Welkin> is haskell really getting dependent types like idris has?
14:12:49 <dolio> Haskell with dependent types will probably be questionably suitable for a proof system.
14:12:59 <freeside> mmm. i'm trying to figure out how these strands fit together. i gather a defining event that created a fork in the road was two different solutions to Russell's paradox.
14:13:10 <dolio> Since it is not really geared toward being a consistent logic.
14:13:25 <ertes> ryba: probably not, even with dependent types you would need to be comfortable with fast and loose reasoning, but more practically haskell isn't much of a proof *assistant*
14:13:28 <freeside> dependent types are coming to haskell: https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
14:14:00 <ryba> Welkin: i saw some discussion on reddit that it may not because it's core isnt sufficient for that or something like it (and a lot of other stuff i didnt understand)
14:14:33 <ryba> what do you mean by fast and loose reasoning?
14:15:05 <ertes> ryba: i don't think haskell is going to be a consistent logic any time soon, so using 'undefined' you could prove anything you want
14:15:22 <ertes> fast and loose reasoning means: "i promise i'll be careful not to exploit that" =)
14:16:38 <ryba> ertes: and what's wrong with being carefull not to use that? if you want to prove something you use that, if you want to make simple program that may fail with undefined, you use that
14:16:55 <ryba> that's general purpose, the more purposes you can fulfill the better
14:17:38 <Welkin> ertes: unsafePerformIO
14:17:48 <ertes> ryba: not for theorem proving
14:18:00 <ertes> ryba: if you can prove anything, you can prove absurd statements
14:18:24 <ryba> ertes: and you can prove that you are not exploiting undefined in your proof by grepping your proof for undefined :)
14:18:39 <dolio> No, you can't.
14:18:40 <ertes> ryba: no, you can't
14:18:48 <ryba> ?
14:19:09 <dolio> 'undefined' isn't the only way to write a bad proof.
14:19:19 <ertes> > let x = x in x :: Void  -- here is a proof of "false" without using 'undefined'
14:19:25 <lambdabot>  mueval-core: Time limit exceeded
14:19:44 <dolio> With `* :: *`, the logic is already inconsistent.
14:20:08 <ryba> is any subset of haskell consistent?
14:20:18 <ertes> ryba: yes
14:20:45 <hpc> you can get, if not consistent, really damn close
14:20:48 <freeside> http://deepspec.org/research/Haskell/
14:20:58 <hpc> just with termination and {-# LANGUAGE Safe #-}
14:21:26 <ertes> ryba: uh, well, not quite
14:21:39 <ertes> ryba: the (* :: *) thing still ruins it
14:21:39 <dolio> There are also other holes in GHC, I think. Like impredicativity is inconsistent with injectivity of type constructors.
14:21:56 <ryba> im not really sure what * :: * means
14:22:11 <geekosaur> impredicability is going away though
14:22:12 <ertes> ryba: * ("type") is an element of *
14:22:37 <dolio> geekosaur: No. The GHC extension with 'impredicative' in the name is going away.
14:22:48 <dolio> But GHC's type system is still impredicative.
14:23:16 <ryba> and what's impredicability?
14:25:10 <monochrom> That you are allowed "Maybe (forall a. a -> a)
14:25:26 <dolio> That's what the GHC extension is.
14:25:41 <monochrom> In general, to instantiate a type variable by a bloody forall type.
14:26:22 <Welkin> RankNTypes?
14:26:49 <hpc> RankNTypes lets you put nested forall terms on the left side of (->)
14:26:58 <monochrom> No, RankNTypes doesn't cut it.
14:27:05 <hpc> ImpredicativeTypes extends that to arbitrary type constructors
14:28:42 <dolio> Impredicativity in general has to do with defining something in terms of some big collection of things that includes the thing you're defining.
14:29:12 <dolio> A sort of suspiciously self-referential definition.
14:29:29 <ryba> dolio: that's the explanation i like :)
14:29:38 <dolio> Although what counts as suspicious depends on who you're talking to.
14:30:03 <Jacob__> hi
14:30:10 <Jacob__> Hello everone
14:30:30 <dolio> Anyhow, GHC is impredicative when you turn on PolymorphicComponents.
14:31:02 <dolio> Because you can define a type T that contains something with type 'forall a. U[a]' in it, where a may be instantiated with T.
14:32:16 <dolio> And I think that is the only sort of impredicativity you need to be inconsistent with injectivity of type constructors.
14:32:45 <dolio> The GHC extension is just a more accessible form of impredicativity that makes type checking very difficult.
14:32:52 <ryba> dolio: what is the use of impredicative types?
14:33:12 <riff> Anyone here have any experience with the cereal library? I'm hoping there might be a way to serialize an IORef. End goal is to use haskell-mpi, but the code I'm working with is littered with iorefs :(
14:34:01 <lyxia> Get and Putter not being MonadIO, I highly doubt that is possible.
14:34:02 <monochrom> Would you love a list of polymorphic functions like [(+), (-)] :: [forall a. Num a => a -> a -> a]? :)
14:34:06 <dolio> ryba: I don't understand your question.
14:34:36 <dolio> Are you asking why you'd want them?
14:34:42 <ryba> dolio: yes
14:35:05 <dolio> Oh, well, monochrom's example is one reason.
14:35:42 <ryba> looks usefull-ish
14:36:03 <dolio> Also from a more academic standpoint, having impredicative polymorphism lets you encode all data types without including them directly in your language, which is interesting.
14:36:12 <monochrom> Actually Welkin was right, RankNTypes cuts it.
14:36:48 <dolio> Like, `forall r. r -> (r -> r) -> r` is the natural numbers, but only if r can be instantiated to that type somehow.
14:36:49 <Adeon> does quickcheck have some convenience feature to detect diverging computation? like a timeout
14:36:57 <ryba> dolio: aaand thats exactly why i need to learn type theory :)
14:37:07 <Adeon> trying to skim documentation but can't find something that looks like it's what I'm looking for
14:37:25 <dolio> Otherwise there will be some (computable) functions on the natural numbers that you cannot write.
14:37:32 <monochrom> Take for example you're back in Java, and you have a class that has some polymorphic methods, public class X { <T> T foo(T) ... }.
14:37:40 <dolio> (Like the Ackermann function, I believe.)
14:37:41 <ryba> dolio: like?
14:38:17 <Adeon> er, found it, it's called `microseconds`
14:38:34 <monochrom> Then you put a lot of such objects in a Vector<X>. So suddenly you are instantiating a type variable (that of Vector) to a type that contains a forall type.
14:38:42 <ryba> monochrom: did you just assume my programming language? :P
14:38:49 <lyxia> Adeon: you mean 'within'?
14:38:54 <monochrom> Oh, it's a safe bet. :)
14:39:03 <Adeon> er
14:39:04 <Adeon> yes
14:39:05 <Adeon> within :)
14:39:37 <ryba> monochrom: thank God not this time
14:39:38 <monochrom> Just want to make the story all the more creepy by pointing out "any average Java programmer may have already done this without knowing"
14:40:40 <ryba> monochrom: yup, the "without knowing" part is creepy
14:41:46 <dolio> Actually, there will always be some computable functions that you can't write, if your language is total. But there will be some that you would be able to write with the naturals that you can't write with the encoding. Ackermann is an example.
14:42:29 <lyxia> riff: you can only make pure (de)serializers with cereal
14:44:19 <riff> lyxia: bummer, that's the impression that I was getting. Thanks for confirming that for me, seems that I'll need to rewrite the entire program to get it working with haskell-mpi
14:57:12 <nut> test
14:57:24 <nut> :t map
14:57:26 <lambdabot> (a -> b) -> [a] -> [b]
15:00:30 <lambdabot> untest
15:00:58 <ExpHP> hm, I could've sworn there was a language extension for custom unary operators, isn't there?
15:01:05 <ExpHP> can't seem to find it now
15:02:27 <lyxia> That doesn't sound familiar.
15:03:37 <ExpHP> I can't remember where I read it, but it just basically loosened the restrictions on slice syntax so that e.g. (@ 3) didn't have to be a function
15:03:47 <glguy> postfixoperators
15:04:10 <ExpHP> oh no, I hope they aren't only postfix! :(
15:04:22 <glguy> wouldn't make sense otherwise
15:04:43 <ExpHP> well yeah, I know, if it allowed both then all prefix and postfix ops would have to be the same
15:04:57 <ExpHP> just simply because it isn't encoded in the type system which is which
15:05:23 <ExpHP> but I wanted to be able to write (%"somestring") to do formatting on a string :V
15:05:31 <ExpHP> oh well. thanks glguy
15:06:04 <CuteKitten> Hi, is there something like this that already exists? In the form of a monad possibly or combining combinators that I'm not aware?  http://lpaste.net/354181
15:06:56 <CuteKitten> I would like to do an action, collect the result, and execute another action, assuming the result passes a condition. If all is well, we repeat the process, until the first action produces a result we don't like.
15:08:01 <CuteKitten> Forget the uneccessary Applicative f => f ~ IO in the annotation.
15:08:16 <ertes> CuteKitten: do you care about the result, or only the effects?
15:08:35 <CuteKitten> ertes: Only the effect, but if it can be made even more general, I'll take it.
15:08:42 <ExpHP> CuteKitten: sounds like some kind of monadic unfold
15:09:13 <ExpHP> CuteKitten there's a bunch of loops here though I don't notice anything with quite that signature: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
15:09:22 <CuteKitten> I've noticed the pattern 5-10 times in my game. I'm using some `fix $ \loop ->` construct, but it's repetitive and error-prone.
15:09:54 <ertes> CuteKitten: 'forever' with MaybeT
15:10:36 <CuteKitten> ertes: Wont `forever $ runMaybeT` just run a MaybeT computation infinitely?
15:11:11 <ertes> no, MaybeT short-circuits
15:11:12 <ertes> :t \p c -> forever (c >>= guard . p)
15:11:13 <lambdabot> (Alternative f, Monad f) => (a -> Bool) -> f a -> f b
15:11:25 <CuteKitten> :t forever
15:11:27 <lambdabot> Applicative f => f a -> f b
15:11:35 <CuteKitten> Oh interesting, forever is generic.
15:11:53 <ertes> but you don't get to keep the results, that's why i asked
15:12:08 <CuteKitten> I think it's fine.
15:12:42 <ertes> remember to wrap a runMaybeT around that, otherwise you're short-circuiting out of something larger
15:12:47 <CuteKitten> ertes: As long as the first computation's result can be used with a predicate to determine if we continue or not.
15:14:56 <CuteKitten> ertes: runMaybeT $ do { a <- cond <$> actionA; b <- lift actionB }
15:25:50 <ExpHP> is there a way I can conditionally import a module in .ghci, only if the module exists?
15:29:17 <monochrom> Maybe import it anyway. If there is an error, does it continue with the remaining lines?
15:30:21 <ExpHP> monocrom yeah it does, it's just annoying to see all the error output
15:31:33 <sebastianrkg> hey guys, I'm wondering what is the best/your favourite Visual Studio Code plugin for Haskell?
15:32:33 <sebastianrkg> Haskero and Haskelly both have some popularity it seems, and then there are a few others out there
15:33:02 <Welkin> I didn't know people used visual studio with haskell o.o
15:33:07 <Welkin> everyone seems to use emacs or vim
15:33:48 <sebastianrkg> I've heard that VSCode's plugins are quite good. I'm not much of an emacs/vim guy (right now, I use Sublime Text)
15:34:09 <Welkin> emacs seems to have the best haskell support
15:34:41 <ExpHP> ^ my life changed when I switched from vim to spacemacs
15:34:47 <sebastianrkg> Welkin: for sure, I would agree with that. It's just not my editor of choice
15:34:55 <ExpHP> intero, man.  :O
16:00:09 <lpaste> lambdafan pasted “Type Teris with Conduits” at http://lpaste.net/354183
16:00:55 <lambdafan> any ideas?
16:04:57 <lambdafan> hi duncan
16:05:11 <lambdafan> I just posted this conduits problem I'm trying to sort
16:05:20 <geekosaur> lambdafan, you n eed a MonadIo constraint on m
16:05:22 <geekosaur> er MonadIO
16:05:36 <lambdafan> oooh!
16:05:39 <geekosaur> because sourceHandle is only meaningful if there is a (System.IO.)Handle
16:05:52 <lambdafan> I removed m
16:05:59 <lambdafan> constrainted to State
16:06:03 <lambdafan> constained I mean
16:06:24 <geekosaur> you need to remove sourceHandle if you want to get rid of the MonadIO
16:06:45 <lambdafan> the initial code compiles
16:07:09 <lambdafan> engine :: MonadResource m => Handle -> m Editor
16:07:13 <lambdafan> ^ that compiles
16:07:26 <geekosaur> ok, MonadResource is providing MonadIO then
16:07:53 <lambdafan> ah so there must not be an instance of MonadIO for StateT?
16:08:45 <geekosaur> the problem is that it's using Identity as the monad, not something over IO
16:09:18 <lambdafan> yeah that's how StateT makes State, with the Identity Monad.
16:09:49 <geekosaur> right, you can;t use State directly, you need StateT IO
16:10:02 <lambdafan> very well :)
16:11:14 <geekosaur> becuase that's the only way it can make a Conduit from a Handle, is if the Conduit is rooted in IO instead of e.g. Identity
16:12:48 <lambdafan> okay making changes
16:13:59 <lambdafan> whelp
16:14:06 <lambdafan> I spent all day banging my head against that
16:14:14 <lambdafan> thanks geekosaur
16:14:27 <lambdafan> well, it took me all day to be able to form a question to ask
16:15:11 <lambdafan> okay another question
16:15:23 <lambdafan> sourceHandle won't close the handle
16:15:29 <lambdafan> so how do I close it?
16:16:04 <lambdafan> I thought about using bracketP, but I need to munge the file prior to streaming it through
16:16:19 <lambdafan> which is why I pass in the handle
16:17:03 <geekosaur> I think you end up setting up a ResourceT yourself, so you can close it in the ResourceT finalizer
16:17:26 <geekosaur> (which is what MonadResource is doing in the ones where it opens the file itself)
16:17:56 <lambdafan> geekosaur, okay I need to go digging for examples. I am sure I've seen them
16:19:51 <lambdafan> looks like I want allocate
16:37:29 <lolisa> Hello, I am getting "Exposed modules use unallocated top-level names: DDF", when I upload my stuff on Hackage, should I be concerned about this?
16:38:57 <geekosaur> there is a preference for using the existing module hierarchy --- although this can be taken too far (see for example the weird mishmashes under Control.* and Data.*)
16:41:24 <lolisa> I mean, I know I should put my stuff into Language.DDF, but it seems rather long to import like Language.DDF.Lang and other stuff, so is it bad to just leave it under DDF, or it is OK?
17:15:24 <fred-fri> > putStr $ show $ min [1,2]
17:15:27 <lambdabot>  <IO ()>
17:15:40 <fred-fri> ^^^ how can i fix the above?
17:15:46 <fred-fri> > putStr $ show [1,2]
17:15:48 <lambdabot>  <IO ()>
17:16:12 <geekosaur> you can't do I/O in lambdabot
17:16:14 <monochrom> What is there to fix?
17:17:24 <MarcelineVQ> fred-fri: you may have wanted minimum
17:17:30 <fred-fri> putStr $ show [1,2] prints the list as expected, but when adding min it doesnt because it looses the show type i think
17:17:46 <geekosaur> :t min
17:17:47 <lambdabot> Ord a => a -> a -> a
17:17:48 <monochrom> Then what MarcelineVQ said.
17:18:02 <geekosaur> has nothing to do with Show
17:18:32 <fred-fri> MarcelineVQ, geekosaur, monochrom I'm an idiot, thank you all
17:18:43 <geekosaur> however it probably gets reported that way because it thinks you are trying to show a function, which is a partial application of `min`
17:19:03 <fred-fri> makes sense
17:20:25 <monochrom> @type putStr $ show $ min [1,2]
17:20:28 <lambdabot> IO ()
17:20:38 <monochrom> @type show $ min [1,2]
17:20:40 <lambdabot> String
17:20:46 <monochrom> > show $ min [1,2]
17:20:48 <lambdabot>  "<[Integer] -> [Integer]>"
17:21:02 <monochrom> Oh ha, that's why lambdabot doesn't give a type error either.
17:22:02 <MarcelineVQ> that's an odd thing to have on by default :>
17:23:12 <geekosaur> huh? the only way to "turn it off" is disallow partial application
17:23:44 <c0dehero> slightly off-topip, but anyone wanna help make the haskell logo on /r/place?
17:24:37 <geekosaur> unless you mean the Show instance for functions that lb uses
17:24:39 <MarcelineVQ> geekosaur: it wouldn't be a case of not defineing a show isntance for functions?
17:24:58 <monochrom> We agree violently.
17:25:18 <geekosaur> I think that's geenrally considered helpful given lambdabot's normal usage
17:26:12 <MarcelineVQ> I get it for IO results because you want to communicate that it doesn't execute but it seems out of place otherwise
17:26:33 <monochrom> I have a cunning plan. Every time you use lambdabot you first fill out a 5-minute form to choose your settings. :)
17:26:53 <MarcelineVQ> sounds reasonable, your reward is being told about @let import ...
17:28:27 <MarcelineVQ> "lambdabot: thank you for filling out this form, btw you can import with @let import ...   and  use @index to find out where things come from"
17:31:51 <Sornaensis> @let import System.IO.Unsafe
17:31:53 <lambdabot>  .L.hs:139:1: error:
17:31:53 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
17:31:53 <lambdabot>      The module itself isn't safe.
17:32:00 <monochrom> hehe
17:40:17 <lolisa> > undefined
17:40:19 <lambdabot>  *Exception: Prelude.undefined
17:40:28 <lolisa> > unsafePerformIO 
17:40:30 <lambdabot>  error: Variable not in scope: unsafePerformIO
17:41:54 <lolisa> @let import Unsafe.Coerce
17:41:56 <lambdabot>  .L.hs:145:1: error:
17:41:56 <lambdabot>      Unsafe.Coerce: Can't be safely imported!
17:41:56 <lambdabot>      The module itself isn't safe.
17:42:10 <MarcelineVQ> what have I done
17:43:34 <lolisa> @help
17:43:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:43:40 <lolisa> @help command
17:43:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:45:21 <lolisa> Wait, what is karma
17:45:26 <lolisa> @karma lambdabot
17:45:27 <lambdabot> lambdabot has a karma of 33
18:06:01 <fred-fri> whats a good way to round to nearest five?
18:07:23 <ertes> @let round5 x = 5 * round (x/5)
18:07:25 <lambdabot>  Defined.
18:07:36 <ertes> > map round5 [2,3,7,8]
18:07:39 <lambdabot>  [0,5,5,10]
18:15:32 <lolisa> > fix
18:15:34 <lambdabot>  error:
18:15:34 <lambdabot>      • No instance for (Typeable a0)
18:15:34 <lambdabot>          arising from a use of ‘show_M228743708076234977828657’
18:15:46 <lolisa> > 1 + (fix id)
18:15:52 <lambdabot>  mueval-core: Time limit exceeded
18:20:36 <Cale> > fix error
18:20:38 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:21:55 <pikajude> every time
18:24:54 <Cale> Recursion memes
18:25:57 <ertes> > fix (1 +)
18:25:59 <lambdabot>  9999999999999999999999999999999999999999999999999999999999999999999999999999...
18:27:35 <ChaiTRex> Trickery!
18:28:05 <orion> How long do @let definitions persist?
18:28:20 <Cale> Until someone does an @undefine
18:28:32 <orion> @undefine round5
18:28:32 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
18:28:37 <orion> @undefine
18:28:37 <lambdabot> Undefined.
18:28:46 <geekosaur> note that there is not a separate list for people in /msg, only the global one
18:29:04 <orion> So in other words, I could @let something in a private message and use it here?
18:29:11 <geekosaur> yes
18:29:20 <geekosaur> but also @undefine here could mess up people's private sessions
18:29:40 <geekosaur> (or someone using it in their session can mess things up for other uses including here)
18:30:16 <orion> I see.
18:30:28 <Cale> Let lambdabot serve as a warning about global mutable state
18:30:39 <orion> ha
18:31:46 <MarcelineVQ> warning, global mutable state is cute robut
18:32:24 <fred-fri> > map read ["1","2"]
18:32:27 <lambdabot>  [*Exception: Prelude.read: no parse
18:33:15 <geekosaur> > map read ["1","2"] :: [Int]
18:33:17 <lambdabot>  [1,2]
18:34:17 <ChaiTRex> > read "[1, 2]" :: [Int]
18:34:19 <lambdabot>  [1,2]
18:34:48 <fred-fri> > map (read::String->Int) ["1","2"]
18:34:51 <lambdabot>  [1,2]
18:35:09 <geekosaur> read is polymorphic, and defaulting in ghci or lambdabot makes it default to type () (see the ExtendedDefaultRules extension)
18:35:09 <fred-fri> geekosaur wins
18:38:09 <ChaiTRex> > (map::(String->Int)->[String]->[Int]) (read::String->Int) ([("1"::String),("2"::String)]::[String])
18:38:11 <lambdabot>  [1,2]
18:41:40 <ski> @type read `asTypeIn` \read -> map (chr . read) ["1","2"]
18:41:41 <lambdabot> String -> Int
18:52:48 <fred-fri> lambdabot is great but is there any pastebin like app where you can put share haskell and its runnable?
18:54:32 <geekosaur> codepad.org ?
18:56:45 <fred-fri> cool
19:10:06 <fred-fri> i feel terrible for asking these basic questions but i cant get this to compile no matter how or where i put number conversions https://pastebin.com/BzQs4XVX
19:11:00 <fred-fri> btw i know i can just do the single conversion in the read
19:11:55 <fred-fri> its calling the grade, and by extension the round5, functions that's the problem
19:14:02 <glguy> fred-fri: there aren't any types that are both RealFrac and Integral that you'll want
19:14:52 <glguy> instead of round (x / 5). use x `div` 5
19:25:10 <fred-fri> glguy, problem has shifted =) any ideas? https://pastebin.com/bSw5VXLt
19:26:26 <fred-fri> i keep reading eg https://wiki.haskell.org/Converting_numbers but 
19:27:06 <divVerent> fred-fri: I don't understand round5's type signature
19:27:13 <divVerent> what is that monster argument supposed to be
19:27:22 <divVerent> when the definition itself just expects a somewhat numeric x?
19:27:33 <divVerent> Also, your div should be a `div`.
19:28:39 <divVerent> that grade definition is also ODD
19:29:19 <divVerent> like, it should map 40, 41, 42, 43, 44, 45 into 40, 41, 42, 45, 45, 45
19:29:38 <divVerent> because if x >= 38, it'll pick the max of the rounded value and x itself
19:30:32 <lpaste> ExpHP pasted “everybody's favorite game: What has ExpHP reinvented?” at http://lpaste.net/354186
19:30:51 <divVerent> BTW, also the `div` very likely should be /
19:31:04 <divVerent> as otherwise you'll get an integer number from it, which doesn't let you usefully round
19:31:12 <divVerent> so probably you need to rather do something like
19:31:22 <geekosaur> you missed glguy suggesting div instead of (/)
19:31:37 <divVerent> ah, I see
19:31:40 <divVerent> well, div is KINDA better
19:31:47 <divVerent> but the round logic doesn't work that way
19:31:53 <divVerent> to do a rounded integer division
19:31:59 <divVerent> rdiv :: Integral a => a -> a -> a
19:32:26 <fred-fri> removing all the type shenanigans, this is what i want to do https://pastebin.com/XxG1cSF8
19:32:38 <divVerent> rdiv a b = (a + ((b + 1) `div` 2)) `div` b
19:32:48 <divVerent> wait, not b+1, just b
19:33:07 <divVerent> indeed, rdiv a b = (a + (b `div` 2)) `div` b
19:33:42 <divVerent> so for round5
19:33:45 <divVerent> you'd use
19:33:51 <divVerent> 5 * ((x + 2) `div` 5)
19:34:22 <divVerent> or of course the proper set of type conversions (fromIntegral comes to mind for the input side), and using / and round
19:35:37 <fred-fri> i guess i can do the fromIntegral at the start and let grade and round5 operate on floating types
19:35:50 <fred-fri> that should make things easier, maybe?
19:36:04 <divVerent> maybe yes
19:36:16 <divVerent> would prefer rational types though
19:36:48 <fred-fri> but doesnt that cause issues for rounding
19:37:44 <ExpHP> less issues than rounding floats...
19:38:22 <fred-fri> i see
19:38:33 <divVerent> so, 5 * round (x % 5)
19:38:43 <divVerent> x % 5 is basically a Rational
19:38:53 <divVerent> you can round that and multiply it by 5
19:38:57 <ExpHP> a rational is an exact result of dividing integers, a float is *sometimes* an exact result of dividing integers
19:39:09 <Cale> :t x % 5
19:39:11 <lambdabot> Ratio Expr
19:39:13 <divVerent> and round is a type conversion to anything Integral
19:39:14 <Cale> heh
19:39:25 <Cale> :t (x :: Integer) % 5
19:39:27 <lambdabot> error:
19:39:27 <lambdabot>     • Couldn't match expected type ‘Integer’ with actual type ‘Expr’
19:39:27 <lambdabot>     • In the first argument of ‘(%)’, namely ‘(x :: Integer)’
19:39:36 <Cale> :t \x -> (x :: Integer) % 5
19:39:38 <lambdabot> Integer -> Ratio Integer
19:40:04 <ExpHP> > unlet x -- :V
19:40:06 <lambdabot>  error: Variable not in scope: unlet :: Expr -> t
19:40:14 <fred-fri> > 5 * round (x % 5)
19:40:17 <divVerent> :t \ x -> 5 * round (x % 5)
19:40:18 <lambdabot> (Integral a, Integral a1) => a1 -> a
19:40:20 <lambdabot>  mueval-core: Time limit exceeded
19:40:23 <fred-fri> > 5 * round (3 % 5)
19:40:25 <divVerent> yes, both sides Integral :)
19:40:26 <lambdabot>  5
19:40:37 <divVerent> @pf \ x -> 5 * round (x % 5)
19:40:38 <lambdabot> Maybe you meant: pl bf
19:40:48 <divVerent> @pl \ x -> 5 * round (x % 5)
19:40:48 <lambdabot> (5 *) . round . (% 5)
19:40:53 <divVerent> yes, much... better
19:41:05 <divVerent> reads like assembly, this pointfree representation
19:41:33 <fred-fri> maybe i should give up haskell and move directly to assembly... assembly has the highest abstractions
19:41:35 <divVerent> div 5; round; mul 5
19:41:38 <fred-fri> trolol
19:42:26 <divVerent> strongly typed assembly with lazy evaluation, hindley-milner and monads NOW
19:42:38 * ExpHP makes some remark about "@pl" and "perl"
19:43:11 <divVerent> and of course lambdas, we need those lambdas in assembly a lot
19:43:29 <ski> divVerent : i don't know about the latter, but <http://www.cs.cornell.edu/talc/>
19:43:41 <fred-fri> off topic: i was recently approached by a recruiter about a position as team lead where the stack is perl, r (not rust, r) and objective c. im a java dev.
19:44:54 <divVerent> not bad, this TAL
19:45:15 <divVerent> CALL (LAMBDA x, CALL x x) (LAMBDA x, CALL x x)
19:45:29 <divVerent> sounds like it'll compile to a single VLIW instruction called HCF
19:45:38 <fred-fri> most non programmers dont seem to understand first thing about differences between languages.
19:46:14 <divVerent> you'll do fine there though
19:46:36 <divVerent> you probably are qualified for the R and ObjC parts at least just by being here and knowing Java
19:46:36 <ExpHP> To be fair, I held for the longest time the idea that "once you learn one programming language, you've learned them all"
19:46:49 <divVerent> as for perl... just wing it
19:46:54 <divVerent> so did your predecessor :)
19:47:33 <fred-fri> its true a lot of places the turnover of people is so high that no one really knows what theyre doing anyway
19:49:10 <fred-fri> are most of the regulars in this channel professional haskell devs or is it like 50/50 pro/hobby
19:49:20 * ExpHP pokes at http://lpaste.net/354186 with puppy dog eyes
19:49:21 <lolisa> > fix (+ 1)
19:49:27 <lambdabot>  mueval-core: Time limit exceeded
19:49:28 <lolisa> > fix (1 +)
19:49:34 <lambdabot>  mueval-core: Time limit exceeded
19:49:57 <lolisa> ertes, how come you get 99999 with fix (1 +)?
19:50:08 <Cale> lolisa: By redefining fix temporarily
19:50:13 <divVerent> stupid lambdabot, we all know the fixpoint of (+ 1) is +Infinity
19:50:19 <divVerent> well, and -Infinity, and NaN
19:50:33 <divVerent> does NaN count as fixpoint if NaN /= NaN?
19:51:06 <ExpHP> divVerent: fix doesn't require Eq a :)
19:51:13 <divVerent> ExpHP: I know
19:51:17 <divVerent> was talking mathematically
19:51:33 <ExpHP> well then no, obviously it eats your children
19:51:37 <divVerent> fix doesn't REALLY look for fixpoints of functions :P
19:51:59 <divVerent> it more like defines a construct that IF it can evaluate, must also be a fixpoint
19:52:05 <lolisa> @let True False
19:52:05 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
19:52:55 <lolisa> @let True = False
19:52:57 <lambdabot>  Defined.
19:53:01 <lolisa> > ! True
19:53:04 <lambdabot>  <hint>:1:7: error:
19:53:04 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:53:20 <Cale> lolisa: That definition doesn't accomplish anything
19:53:21 <ExpHP> @let LANGUAGE = espanol
19:53:22 <lambdabot>  .L.hs:162:1: error: Not in scope: data constructor ‘LANGUAGE’
19:53:36 <lolisa> > True
19:53:37 <Cale> It's a pattern binding which matches the pattern True (lazily) and binds no variables
19:53:38 <lambdabot>  True
19:54:12 <divVerent> anyway, whoever finds Haskell crazy hasn't done any QuakeC yet :P in many ways the exact opposite, because it was designed by someone without the slightest idea about languages or compilers
19:54:16 <divVerent> representative sample:
19:54:18 <lolisa> aww man
19:54:34 <divVerent> { float x = 1; x = 2; if (1 == 2) prrint(...); }
19:54:45 <lolisa> @let or = and
19:54:47 <lambdabot>  Defined.
19:54:55 <ExpHP> divVerent: meh. beats vimscript
19:54:56 <divVerent> the print will execute, because x is a constant (because of the assignment), assigning to a constant just overwrites the memory representing the constant, boom
19:54:58 <lolisa> I feel like I'm doing pure sin
19:55:04 <divVerent> beats javascript, even
19:55:40 <ExpHP> javascript has actually kinda been pulling its weight lately
19:55:54 <lolisa> > or True False
19:55:56 <lambdabot>  error:
19:55:56 <lambdabot>      Ambiguous occurrence ‘or’
19:55:56 <lambdabot>      It could refer to either ‘Data.List.or’,
19:56:06 <lolisa> @undefined or
19:56:06 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:56:07 <divVerent> and I recently tried to convince Go people to keep a data type transitively comparable
19:56:08 <divVerent> well, I failed
19:56:15 <lolisa> @undefine or
19:56:15 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:56:18 <divVerent> they insist on that change to make comparisons no longer transitive on a specific type
19:56:24 <lolisa> @undefined
19:56:25 <lambdabot> Undefined.
19:56:54 <ExpHP> @undefinemyclementines
19:56:54 <lambdabot> Unknown command, try @list
19:57:50 <ExpHP> (I've tried that @list thing and it doesn't actually list commands >_>)
19:58:29 <ExpHP> (okay I'm dumb never mind)
20:00:49 <lolisa> @karma ExpHP
20:00:49 <lambdabot> ExpHP has a karma of 0
20:00:53 <ExpHP> it has some dice rolling expression language
20:00:55 <ExpHP> @roll (2d7 + 3d6) * 7d18
20:00:55 <lambdabot> ExpHP: ((7+1) + (3+4+4)) * 76 => 1444
20:01:25 <ExpHP> that's my karma by the way.  lambdabot will lie if you ask him
20:01:39 <ExpHP> or her
20:02:06 <ski> @poll-result should-lambdabot-be-more-polite
20:02:06 <lambdabot> Poll results for should-lambdabot-be-more-polite (Closed): yes=0, maybe=6, no=13, yes=8
20:06:18 <ExpHP> @slap ExpHP
20:06:19 * lambdabot places her fist firmly on ExpHP's jaw
20:06:28 <ExpHP> it is a her!
20:08:42 <MarcelineVQ> @vixen
20:08:43 <lambdabot> The presidency has many problems, but boredom is the least of them.
20:10:43 <ExpHP> @src fix
20:10:44 <lambdabot> fix f = let x = f x in x
20:11:31 <ExpHP> @src seq
20:11:31 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:11:56 <Cale> @vixen is @nixon
20:11:57 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
20:12:17 <MarcelineVQ> coincidence
20:12:43 <ski> @palomer
20:12:43 <lambdabot> That's a lie
20:12:52 <Cale> @keal
20:12:53 <lambdabot> ghc need to have plugin that allow copy paste in xp
20:14:06 <ExpHP> oh no...
20:14:08 <ExpHP> @yarr
20:14:08 <lambdabot> What be a priate's favourite cheese?
20:14:08 <lambdabot> Yarrlsburg!
20:14:09 <MarcelineVQ> it's too bad, vixen is more interesting
20:17:57 <c0dehero> lexi-lambda: nice work! :D
20:31:23 <_sras_> What is a good library that can be used to model Money and currencies?
20:33:03 <lolisa> @quote Cale
20:33:04 <lambdabot> Cale says: "Betta watch your back when I'm packin' a nine/I'll pump you fulla holes like the rational line"
20:33:15 <lolisa> wut
20:33:18 <lolisa> @quote la
20:33:18 <lambdabot> applicative says: Even if no one else understands me, still, the Glasgow Haskell Compiler understands me
20:33:26 <lolisa> @quote lambdabot
20:33:26 <lambdabot> lambdabot says: In the definition of `yhjulwwiefzojcbxybbruweejw':
20:33:34 <lolisa> wait, wut
20:33:44 <lolisa> @quote lolisa
20:33:44 <lambdabot> No quotes match. Take a stress pill and think things over.
20:34:43 <Cale> @yhjulwwiefzojcbxybbruweejw
20:34:43 <lambdabot> "\"#$%&'()*+,\""
20:35:14 <Sornaensis> Cale: what does it mean
20:35:24 <ski> @help yhjulwwiefzojcbxybbruweejw
20:35:24 <lambdabot> V RETURNS!
20:35:50 <Cale> There used to be a fixed variable which your expression was bound to while lambdabot was evaluating it, originally v
20:36:06 <Cale> and so using v in your expression would result in recursion
20:36:22 <ertes> lolisa: i redefined (+)
20:36:28 <ertes> secretly
20:37:37 <ski> @quote parametric.polymorphism
20:37:37 <lambdabot> acowley says: Parametric polymorphism is the inspiring story you tell them to get them riled up and raring to go. It's like Braveheart for programmers.
20:37:55 <ski> @quote about.parametric.polymorphism
20:37:55 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
20:38:22 <lolisa> ertes, thx
20:38:25 <lolisa> @quote monad
20:38:25 <lambdabot> Botje says: replacing "monad" with "monkey" makes haskell much more easy to understand
20:38:28 <Cale> yhjulwwiefzojcbxybbruweejw was what the variable was briefly renamed to after people found out about v
20:38:30 <lolisa> @quote monad
20:38:30 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
20:38:30 <lambdabot> for your entire program.")
20:38:35 <lolisa> @quote monad monoid
20:38:35 <lambdabot> No quotes for this person. My pet ferret can type better than you!
20:38:38 <lolisa> @quote monoid
20:38:39 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
20:38:46 <Cale> and before it became something a bit harder to manipulate :)
20:39:12 <lolisa> lol
20:39:59 <Cale> I wonder when Phil Wadler asked about that
20:40:10 <Cale> I could have given that tutorial :)
20:43:18 <_sras_> So, is there a good package that one can use to handle money?
20:44:13 <Cale> Might want to look at what hledger uses?
20:44:15 <Cale> I don't know
20:45:36 <tippenein> it uses Decimal, which.. I'm not sure would be recommended
20:46:06 <Cale> http://hackage.haskell.org/package/hledger-lib-1.2/docs/Hledger-Data-Types.html#t:Amount
20:46:10 <Cale> It has some types...
20:46:35 <tippenein> there is https://github.com/k0001/safe-money
20:46:51 <tippenein> depends what you mean by "handle money" I imagine
20:46:59 <ski> @quote AlanPerlis
20:46:59 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
20:47:17 <Cale> Statically encoding which currencies you're working with seems pretty niche to me
20:47:49 <_sras_> tippenein: Cale I am looking for something like this https://hackage.haskell.org/package/money-0.1.0/docs/Data-Money.html
20:48:14 <_sras_> But I am not sure about using that package. Is it commonly used?
20:48:34 <Cale> If I had to guess I would say no
20:48:47 <Cale> It's had 38 downloads ever
20:50:04 <tippenein> the only thing in the readme is a link to a failing circle ci build
20:50:17 <tippenein> it's the code equivalent of a tumbleweed
20:53:57 <sophiag> anyone here familiar with prelude-extras? i'm trying to figure out how to use the Show1 class similar to what's suggested here: http://stackoverflow.com/questions/24482561/conditionally-derive-show-for-existential-type-parameterized-on-type-constructor
20:58:35 <glguy> always just ask the actual question
20:59:21 <sophiag> i'm the child who doesn't know enough to ask a question
20:59:37 <Cale> The question posed by the original poster on stackoverflow doesn't make sense.
21:00:17 <sophiag> it makes sense, it's just extremely contrived
21:01:21 <sophiag> the difference is i only have one variable wrapped in the existential
21:01:24 <Cale> Oh, maybe it does -- it sounded at first like he wanted to get rid of the Show constraint in X
21:01:29 <glguy> Yeah, you get an instance Show1 a => Show (X a)
21:02:34 <sophiag> right, and when i try something like that i get "parse error on input 'instance'"
21:02:59 <glguy> Rather than us guessing what you did wrong you can post the code to lpaste
21:03:01 <Cale> I guess if he really wanted that, you could have yet another analogue of Show1, where the Show b constraint was removed from show1's type
21:03:26 <Cale> sophiag: where are you writing it?
21:03:50 <Cale> It should be at the top level of a module
21:03:50 <sophiag> Cale: after the data type
21:04:28 <Cale> Oh, are you using the standalone deriving?
21:04:40 <sophiag> yes, but it doesn't seem to be making a difference
21:04:41 <Cale> {-# LANGUAGE StandaloneDeriving #-}
21:05:13 <sophiag> and i'm correct that in that answer the class is just an example of what's in prelude-extras?
21:05:52 <sophiag> the type causing me all this trouble (almost certain you
21:05:55 <sophiag> oops
21:06:18 <sophiag> ...almost certain you've seen it already: data LambdaT = forall a . LambdaType (a -> Bool)
21:06:46 <Cale> That looks like a pointless type
21:07:03 <Cale> You're forgetting the type of the argument to the function, so you'll never be able to apply it
21:07:39 <sophiag> the point is to store it in a record with a name that will match it up arguments of the same type in another record
21:07:58 <sophiag> so i can be certain it will work, but not through the type system
21:08:01 <Cale> The existential loses the information about which type of argument is required
21:08:45 <Cale> So when you pattern match the existential and get the function back out, you'll have a function of type a -> Bool where a is unknown.
21:08:47 <sophiag> you're saying if i put those lambdas in filters with lists of the appropriate type then it won't compile?
21:08:58 <Cale> and so it will never unify with anything
21:09:06 <Cale> You won't be permitted to apply the function
21:10:40 <sophiag> the only reason i don't want to pass in the type of a is so i can lambdas where a represents multiple types in a list of records
21:11:24 <sophiag> wow, that sentence didn't make much sense...but i think you can get it
21:11:28 <Cale> The problem with that is that if you don't know which type a is, you don't know what type of argument you need to supply
21:12:11 <Cale> The solution to this is to invent a type which in some fashion generalises all the types you actually need there
21:12:31 <Cale> There are two approaches: make a type with constructors corresponding to all the types you want to use explicitly
21:12:39 <sophiag> i do actually have that
21:13:00 <Cale> Or else make a record type with all the operations you want to be able to assume are available
21:13:02 <sophiag> because i needed it to construct the lambdas after parsing 
21:13:04 <Cale> (i.e. OOP)
21:13:08 <sophiag> oh damn
21:13:19 <sophiag> wait...why didn't i think of this...
21:13:28 <sophiag> i think you made my brain spark
21:13:59 <sophiag> (could be i'm doing this weird residency program where it's super loud and this is the first quiet time i've had all week...midnight on saturday)
21:16:10 <vaibhavsagar> sophiag: I didn't realise it had gotten that loud
21:16:19 <sophiag> i think i have an idea to make it work that should have been super obvious, but lemme show a paste of what i'm thinking since i'm not sure of the syntax (basically in need an adt that i can use instead of the type variable)
21:16:45 <sophiag> ah! vaibhav :D
21:16:57 <sophiag> yes, it's ridiculous here tbh
21:17:41 <sophiag> i talked to three guys from winter batches and one said he ended up working at home the whole time and another said he had a huge gap in his github heatmap from when he was here...
21:18:08 <vaibhavsagar> that is literally the opposite of the experience I had
21:18:39 <sophiag> there's a thread about it and this woman was like, "i think it's wrong to assume everyone works best in the same kind of environment. i personally found it really hard to get work done when i was sitting alone in the quiet." like uh...
21:19:16 <vaibhavsagar> it is basically a large open office, so I'm not surprised that there are noise issues
21:19:50 <vaibhavsagar> I recommend passive-aggressive headphone usage
21:19:53 <sophiag> well, i'm fine when it's just pair programming or whatever. but it seems a lot more tan that
21:19:59 <sophiag> i wear earplugs
21:20:03 <sophiag> they're not enough
21:20:15 <vaibhavsagar> D:
21:20:25 <Cale> "I find I get my best work done with wailing and screaming in the background."
21:20:52 <sophiag> yeah...i've never in my life heard a programmer say "can we make it a whole lot louder in here?"
21:20:54 <vaibhavsagar> I like these: http://downbeats.com/
21:21:20 <vaibhavsagar> but they're a non-solution to a serious problem
21:21:49 <sophiag> yeah, like this is surely well beyond what any earplugs are rated at
21:22:25 <sophiag> i brought it up, and nick said he felt the same way but they're so against telling people to just stfu
21:22:55 <sophiag> and the elephant in the room is like...you can't both be coding all day and loudly talking
21:22:59 <vaibhavsagar> the curse of self-direction
21:23:26 <sophiag> the curse of being in a room with 60 people half of whom don't seem to be actually working...
21:23:53 <vaibhavsagar> I don't think I was very productive but I still enjoyed my time there a lot
21:24:12 <vaibhavsagar> I did a ton of "not actually working"
21:24:33 <vaibhavsagar> in summary, it is a good thing I'm not there now
21:24:35 <sophiag> that's the thing, i would prefer to not have to choose between productivity and getting along with people
21:24:37 <sophiag> ha
21:26:38 <sophiag> i also had someone basically tell me exactly the concrete form of the project i was thinking of without me having to research it so need to focus pretty seriously on that. an open source 802.1aq implementation. apparently there are none even though it's six years old and was referred to as "the most important development in the history of ethernet"
21:27:41 <vaibhavsagar> are you both working on it together?
21:28:06 <johnw_> this might be better taken to priv chat
21:28:36 <vaibhavsagar> oops, sorry johnw_
21:28:39 <johnw_> :)
21:29:05 <johnw_> anyone know what happened to the "chunking" function from Data.List.Lens.Split? or where that module went altogether?
21:30:08 <sophiag> Cale: this seems like the smart way to do this, i.e. without existentials, but i'm not sure the syntax. http://lpaste.net/354189
21:30:47 <Cale> Well, function types aren't by default instances of Show
21:31:14 <sophiag> i suppose i just haven't had trouble with most
21:31:40 <sophiag> the issue here would seem to be in the third part not using the variable? is that correct?
21:32:08 <Cale> No, every one of those parts is a problem with respect to Show
21:32:22 <sophiag> oh, ok
21:32:27 <Cale> Because they're all functions, and functions don't normally have a Show instance
21:32:41 <Cale> What did you want to show?
21:33:41 <Cale> I'm still pretty lost about how this code fits into the overall structure of the program... it's unusual for something called "Lambda" to show up at the type level.
21:34:00 <sophiag> theoretically i could avoid printing until eval, but then it makes it very difficult to test. for example, right now this part with existentials is typechecking, but i don't understand why which is...scary
21:34:04 <Cale> Usually you'll have a type for expressions, one constructor of which will be the constructor for lambdas
21:34:13 <Cale> But I don't know
21:34:33 <sophiag> it's essentially just like quote in lisps
21:34:49 <sophiag> i want to be able to throw these functions in a data structure and use them later
21:35:11 <Cale> Also, you drop the RhsT on the left hand side of that data declaration now
21:35:14 <Cale> It's not a variable
21:35:27 <sophiag> right, that's the part i'm asking about mainly
21:35:34 <Cale> So LambdaT becomes a predicate on values, basically.
21:35:57 <sophiag> your suggestion about grouping together the possible types so i don't need LambdaT to be an existential? that's what i'm thinking
21:36:13 <sophiag> i needed RhsT anyway in order to parse them
21:36:18 <Cale> If I have any intuition about what's going on, I think I'd usually name "RhsT" something like "Value" -- isn't this the type of values for an interpreter?
21:36:55 <sophiag> yes, that's accurate to say
21:37:13 <Cale> Or maybe do away with LambdaT altogether
21:37:21 <sophiag> "Value" sounds a bit confusing to me personally
21:37:23 <Cale> and just put   constraint :: RhsT -> Bool
21:37:33 <Cale> as a field in Require
21:37:55 <sophiag> i could do that
21:38:40 <sophiag> but i still can't use a data type in the declaration of another data type, right? that's the error i'm getting
21:38:47 <Cale> hm?
21:39:07 <sophiag> "data LambdaT RhsT ="
21:39:07 <Cale> You can use any data type in the declaration of any other, including mutual recursion
21:39:16 <sophiag> i thought so, but...
21:39:28 <Cale> It doesn't make sense that RhsT is occurring as an argument to LambdaT there
21:39:28 <geekosaur> um, that declaration is meaningless
21:39:42 <sophiag> ghc is saying it wants a type variable...does that even make sense?
21:39:45 <geekosaur> yes?
21:40:02 <Cale> yes, it wants a type variable there, just because that's how the syntax of data declarations goes
21:40:05 <geekosaur> what are you trying to accomplish with that?
21:40:36 <sophiag> oh you're saying just use a variable in LambdaT and pass RhsT to the constructor, yeah?
21:40:39 <Cale> It's  data <TypeConstructorName> <typeVar1> ... <typeVarN> = ...
21:40:43 <geekosaur> because you are saying you want a type LambdaT which is always parameterized with RhsT? if that's what you want just use RhsT, don't specify it as a type parameter
21:40:54 <sophiag> i think i get it now
21:40:59 <Cale> sophiag: No, just delete that RhsT
21:41:07 <Cale> It doesn't belong on the left side of the = sign
21:41:10 <sophiag> Cale: you're probably right
21:42:00 <Cale> Now, if you wanted to be really fancy, and define a type by cases on other types
21:42:07 <Cale> You might use a data family
21:42:17 <Cale> But I don't think that's what you're looking for
21:42:25 <sophiag> do you just mean a type class?
21:42:33 <Cale> No, fancier :)
21:42:40 <sophiag> ha
21:42:41 <Cale> Basically a function on types, defined by cases
21:42:51 <Cale> each of which is like its own data declaration
21:42:51 <sophiag> well, i do still have all this structure with parsing the ASTs
21:43:19 <sophiag> so that's why those two types, OpT and RhsT, were useful
21:43:42 <Cale> What is this type Require?
21:43:52 <Cale> What are you hoping to express?
21:44:51 <sophiag> those are essentially "constraints" as in they'll be used to filter lists based on the string filed
21:44:58 <sophiag> *field
21:45:08 <sophiag> and if it's Nothing then they'll filter the whole list
21:45:28 <sophiag> so the dsl can fail specatularly, but that's ok for how i'm exposing it
21:45:36 <Cale> and if it's Just "foo"?
21:46:09 <sophiag> then it should match a list that's tagged "Just foo" and has the same type as a in a -> Bool
21:46:26 <Cale> What is the type of elements in the list?
21:46:52 <Cale> (Note: you have to say just one thing here :)
21:47:31 <sophiag> each list only has one type...but the list of records will contain lists of different types...
21:47:31 <Cale> It it RhsT?
21:47:44 <Cale> right, okay
21:47:56 <sophiag> yes it is RhsT except i have a different constructor with the list form
21:47:59 <Cale> Okay, so what does the record look like?
21:48:09 <sophiag> the other one?
21:48:19 <sophiag> data MultiList = SList [String] | CList [Char] | IList [Integer] deriving (Show)
21:48:26 <sophiag> data Amb = Amb { ambTag :: Maybe String, value :: MultiList } deriving (Show)
21:49:29 <sophiag> the thing is...it is nice to have those adts in between for parsing purposes
21:49:52 <Cale> Okay, so do we also need three different types of Require?
21:50:08 <Cale> Or do we want one type of Require, which can be applied to any of the types of list?
21:50:31 <sophiag> no, just one type
21:51:25 <sophiag> i think it makes more sense to have those intermediate adts and then just use one record for each rather than three records for each
21:51:28 <Cale> btw, if you want imprecise Show instances for your types, you could write them by hand, like:
21:51:30 <sophiag> for several reasons
21:52:18 <Cale> instance Show OpT a where show (NumOp f) = "NumOp <function>"; show (EqOp f) = "EqOp <function>"; show (BoolOp f) = "BoolOp <function>"
21:52:22 <Cale> oops
21:52:29 <Cale> instance Show (OpT a) where
21:53:14 <sophiag> oh, ok. thanks, i was wondering the format for that
21:53:14 <Cale> Or just write
21:53:26 <Cale> instance Show (a -> b) where show _ = "<function>"
21:53:30 <Cale> and then derive the instance
21:55:08 <sophiag> using the show function?
21:56:07 <Cale> Once there's an instance of Show for functions, you should be able to use deriving
21:58:10 <sophiag> sorry, i'm still a bit confused. especially if i use "instance Show (a -> b)"
21:59:04 <Cale> Well, in order to derive an instance of Show, it needs to already have an instance of Show for each of the fields of your type's data constructors.
21:59:31 <sophiag> i see
21:59:38 <Cale> If we write an instance of Show which applies to any function type at all, it'll deal with the reason why you couldn't stick deriving (Show) on those
22:00:20 <Cale> The other option being just to write the instance of Show by hand, and specify how show works at that type.
22:00:22 <sophiag> ok, so i either do "instance Show (constructor ...)" for each constructor or a general one
22:00:41 <Cale> for each *type* constructor
22:01:00 <sophiag> meaning like NumOp, not OpT yes?
22:01:20 <Cale> No, the opposite
22:01:24 <sophiag> ah ok
22:01:34 <sophiag> in that case it seems like clearly the better choice
22:01:37 <Cale> OpT is a type constructor, NumOp is a data constructor
22:01:48 <Cale> type classes apply to types
22:02:04 <sophiag> oy, i've been calling OpT the "data type" and NumOp the "constructor" :(
22:02:42 <Cale> That's fine
22:03:23 <sophiag> well, i'd ideally like to sound less foolish
22:03:30 <Cale> OpT is indeed a type (it just happens to also be a type constructor, which is a finer distinction that doesn't matter as much as that of being a data constructor most of the time)
22:04:51 <Cale> It's fine to use those words, they don't sound foolish, I'm just trying to be precise, because it's easy to be confused about what's at the type level and what's at the term/value level as a beginner.
22:05:10 <sophiag> ok, so i do need to keep those adts unless i want to totally refactor my parsers, but i think i can do away with a separate type for lambdas as you suggested by just combining two functions
22:06:05 <Cale> The distinction of being a type constructor is sort of a fine point -- type constructors are the things that instances of type classes match on when the system is deciding which instance applies for a given type.
22:07:33 <Cale> and when you write a data declaration, you introduce both a new type constructor, and a bunch of data constructors
22:07:50 <sophiag> i'm going to read simon pj and erik meijer's paper on type classes this week so hopefully i'll understand all this better
22:09:14 <sophiag> oh, i need to use standalone deriving. that's what you meant?
22:09:26 <Cale> er, do you?
22:09:32 <Cale> I didn't expect it
22:10:02 <sophiag> that's what ghc says
22:10:05 <Cale> hmm
22:10:42 <sophiag> and apparently i need to write an instance for Require even though it's not an existential now?
22:11:40 <Cale> ahh...
22:11:52 <Cale> It's confused by the constraints on NumOp
22:12:08 <Cale> er... one sec
22:12:47 <Cale> yeah -- it doesn't actually need to worry, but it's worried :)
22:13:05 <Cale> If it just wrote the Show instance it usually writes, ignoring those constraints, it would be fine
22:13:22 <Cale> I guess standalone deriving will work
22:14:00 <Cale> {-# LANGUAGE StandaloneDeriving #-}
22:14:05 <Cale> deriving instance Show (OpT a)
22:14:07 <Cale> works
22:14:16 <sophiag> yup, got that at least :p
22:15:21 <sophiag> but what i got myself confused about was i *do* either need to keep LambdaT and make it an existential, make Require an existential, or (seemingly worst option) put the Requires in an HList
22:15:52 <Cale> Why doesn't it work just to, say, make Require take a function of type RhsT -> Bool?
22:17:15 <sophiag> oh ok, i think i unconfused myself...
22:17:43 <sophiag> the idea was to just always pass RhsT to the type constructor so it's fine to cons them in a list
22:19:48 <lpaste> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/354189#a354190
22:20:06 <sophiag> oooo
22:20:09 <sophiag> :D
22:24:35 <sophiag> do i need the GADTs pragma to have the constraints in OpT without ghc considering it an existential?
22:24:37 <Cale> But yeah, if instead, you have a list of RhsT values, you obviously don't need that :)
22:25:23 <sophiag> hmm?
22:25:24 <Cale> Oh, I stuck that in hastily. You need either GADTs or ExistentialTypes to get that feature, but it's really neither of those things, it just doesn't have a name :P
22:25:33 <sophiag> right
22:25:44 <sophiag> i was just trying to figure out why you threw that in there
22:26:05 <Cale> Well, it's sufficient to make the module compile :)
22:26:15 <sophiag> oh yeah, you do need one or the other apparently
22:26:22 <sophiag> i guess because of the constraints
22:27:00 <Cale> Yeah, putting the constraints there means that GHC does something cute, where it sticks the type class dictionary into the data as an extra secret field
22:27:23 <sophiag> oh...that's interesting
22:27:29 <Cale> So, when you pattern match on NumOp, you learn that a has instances of Num and Fractional
22:28:36 <Cale> and the operations are available to use, even if the definition that you're writing didn't originally constrain the type a
22:30:15 <Cale> which is a little bit like GADTs in that you're learning something about other types while pattern matching on data constructors (though usually with GADTs proper, you might learn exactly which type it was)
22:31:07 <Cale> well, specifically, you learn about the type arguments to the type whose data constructor it was :)
22:31:17 <sophiag> tbh i'm unclear on the difference between GADTs proper and these guys, which is why i keep saying "ADTs"
22:31:35 <Cale> The classic example of a GADT is something like this:
22:31:41 <Cale> data Expr a where
22:31:49 <Cale>   Lit :: Integer -> Expr Integer
22:31:59 <Cale>   IsZero :: Expr Integer -> Expr Bool
22:32:11 <Cale>   IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
22:32:32 <sophiag> oh ok
22:32:36 <Cale> Notice that the type of the result can be more specific here than just "Expr a"
22:32:49 <Cale> Now we can write:
22:32:54 <Cale> eval :: Expr a -> a
22:33:00 <Cale> eval (Lit n) = n
22:33:08 <Cale> eval (IsZero e) = eval e == 0
22:33:13 <sophiag> i think it makes sense to actually rewrite OpT like that
22:33:28 <Cale> eval (IfThenElse b t e) = if eval b then eval t else eval e
22:33:30 <sophiag> because something i've put off thinking about is nesting the right hand sides in these lambdas :p
22:33:45 <sophiag> that's the only reason to include arithmetic expressions obviously
22:34:14 <Cale> So, notice how in the case of Lit, when we match on the Lit data constructor, GHC learns that in this branch of the pattern match, a = Integer
22:34:32 <Cale> and so we're allowed to provide n :: Integer as our result there
22:35:09 <Cale> and similarly in the IsZero branch of the pattern match, since IsZero has to produce an Expr Bool, GHC learns that a = Bool
22:35:18 <Cale> and so we're expected to produce a Bool result, which we do
22:37:09 <sophiag> oh yeah, i just tried to refactor it and realized i can't just be like (a -> a -> a)
22:38:04 <sophiag> for NumOp GADTs are perfect actually because i do want to define them that way
22:38:19 <sophiag> not sure about the other two cases where i know they're going to return Bool
22:39:15 <Cale> It does seem a little bit suspicious that this is all one type
22:39:45 <sophiag> i want to separate NumOp i think so i can define it recursively
22:40:35 <sophiag> but then i need to group it together with the others so i can still have all the Requires be of the same type :p
22:40:50 <ertes> @let boolsheet f = liftA2 f [False,True] [False,True]
22:40:51 <lambdabot>  Defined.
22:41:17 <Cale> haha
22:41:31 <Cale> > boolsheet (&&)
22:41:33 <lambdabot>  [False,False,False,True]
22:46:47 <hsk3> main = forever $ do
22:46:47 <hsk3>     l <- getLine
22:46:48 <hsk3>     putStrLn $ map toUpper l
22:47:04 <ertes> maybe it would be better to keep the sublists
22:47:21 <hsk3> If I run that program with ./test < text.txt
22:47:28 <ertes> @let deepBoolsheet f = map (\b -> map (f b) [False,True]) [False,True]
22:47:30 <lambdabot>  Defined.
22:47:33 <hsk3> Why does it exit with "test: <stdin>: hGetLine: end of file" ?
22:47:41 <hsk3> Is that an exception?
22:47:55 <Cale> yeah
22:48:48 <hsk3> But if I run that program with just ./test and type out the lines manually, I can't get an EOF with Ctrl-D
22:48:53 <hsk3> I'm on macOS
22:48:54 <ertes> hsk3: the way the APIs return EOF is inconsistent…  some throw an exception, others return an empty result, so be sure to read documentation
22:49:37 <ertes> getLine kinda has to throw an exception though, because an empty result would be ambiguous
22:53:43 <sophiag> Cale: i'm having some weirdness wrapping that GADT i made in Maybe. does that make sense?
22:55:37 <Cale> uhh, can't think of what it would be
22:56:25 <sophiag> i just solved part of it and it was when the type constructor is followed by a type rather than a variable it doesn't want the constructor in the signature. so doesn't seem to have to do with Maybe
22:57:37 <sophiag> in other words, you want (OpT a -> OpT a -> OpT a) but (OpT a -> OpT a -> Bool) rather than (OpT a -> OpT a -> OpT Bool)
22:59:16 <sophiag> except then the function i wrote to unwrap Maybes without throwing an exception on Nothing needs to be changed i think
22:59:36 <sophiag> oy. i needed to think about nesting those expressions anyway tho
23:01:41 <Cale> hmm...
23:04:02 <Cale> I was thinking earlier that you probably ought to get into using the Either String monad (or Either Something anyway), in order to propagate failure cases so that you can deal with them later, or let the user deal with them.
23:04:26 <sophiag> well that's sort of (not really) what i'm doing in the repl
23:04:43 <sophiag> because there's essentially two Rights
23:05:58 <Cale> yeah, if you're still at the part where you're fitting things together by hand, you'll know that the outcome will be Right, and won't have to worry about the other case :)
23:06:57 <sophiag> well i am worrying. it's just i have two Right cases so i made a type: "data Exprs = ExpString String | ExpAmb Amb | ExpReq (Require RhsT)"
23:07:49 <sophiag> although maybe that is convoluted since my motivation was needing a case for when Maybe would return Nothing
23:08:09 <sophiag> so i have "Just "unexpected input"" as one of the choices :p
23:09:51 <sophiag> ugh, well i think i need to revist this Maybe business tomorrow
23:10:23 <sophiag> there are just too many cases. i'm very happy to have ditched existentials tho :)
23:20:41 <sophiag> Cale: thanks so much for the lessons. it singlehandedly turned an annoying day into a productive one :)
23:21:05 <Cale> No problem :)
23:21:22 <sophiag> now i have to head home and try to get to sleep so i can debug this thing tomorrow and hopefully even finish the basics of it :p
23:21:43 <Cale> I should probably sleep as well
23:21:53 <sophiag> it's been a very good learning experience though when it comes to structuring data in haskell's type system
23:22:29 <sophiag> welp, nighty night
23:22:34 <Cale> g'night!
23:46:10 <MP2E> `/quit
