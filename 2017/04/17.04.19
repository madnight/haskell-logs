00:10:40 <kamyar> Please check my code: http://lpaste.net/354722
00:10:53 <kamyar> What is wrong with it?
00:11:27 <cocreature> kamyar: please add the error message to your code
00:13:16 <kamyar> cocreature: I did
00:14:01 <cocreature> kamyar: you can use hoogle to find the module that you need to import to get an identifier http://hoogle.haskell.org/?hoogle=runput
00:14:10 <cocreature> in your case it’s Data.Binary.Put
00:15:21 <kamyar> cocreature: thnx1
00:23:43 <halogenandtoast> What's new in the Haskell world?
00:24:20 <jle`> ghc 8.2 is almost out so that's kinda nice
00:25:07 <jle`> linear types are more or less ready to go for 8.4 i believe...and dependent haskell planned for 8.6/8.8
00:25:29 <jle`> ecosystem wise, the answer depends on when you last looked into it
00:26:03 <MP2E> wow, didn't know they were that close
00:26:05 <MP2E> excellent
00:26:41 <halogenandtoast> heh I just realized I'm still running 8.0.2
00:26:51 <cocreature> halogenandtoast: well 8.2 is not yet out :)
00:26:57 <cocreature> only rc1
00:27:05 <halogenandtoast> cocreature: was there an 8.1?
00:27:10 <cocreature> no
00:27:19 <halogenandtoast> *facedesk*
00:27:22 <jle`> we don't speak about 8.1
00:27:37 <halogenandtoast> Show me where the bad man touched your compiler.
00:27:51 <halogenandtoast> What happened in 8.1 that we don't speak about it?
00:28:02 <jle`> oh, nothing, ghc releases are just on even numbers
00:28:02 <cocreature> the same that happened to 7.9
00:29:24 <halogenandtoast> Odd, I'm not sure I'll ever understand a justification for that system of versioning.
00:29:40 <halogenandtoast> I just want semver major.minor.patch
00:29:46 <halogenandtoast> But I'll live.
00:30:09 <halogenandtoast> I'll need to read up abou tlinear types and dependent haskell, not sure what those mean just yet.
00:30:17 <jle`> https://downloads.haskell.org/~ghc/6.2.2/docs/html/users_guide/version-numbering.html
00:30:23 <jle`> odd numbers are for HEAD i believe
00:30:36 <MarcelineVQ> if it helps you can get 8.1.2 on git
00:31:41 <halogenandtoast> It probably won't help me.
00:31:58 <halogenandtoast> But I've commited to memory the versioning scheme and can live with it.
00:35:03 <jle`> it'll come up on jeopardy some day probably
00:35:32 <MarcelineVQ> base versioning, the daily double
00:36:52 <halogenandtoast> For web frameworks, is Yesod still the way to go (or Snap) or are there new more enticing options?
00:39:38 <LAZAR> How can I actually use the diamond operator for Lists? They are monoids so I should be able to [1,2,3] <> [4,5,6]
00:40:00 <kadoban> Sure
00:40:31 <kadoban> Perhaps you don't have (<>) in scope? Not sure what error you're getting.
00:40:55 <halogenandtoast> > [1,2,3] <> [4,5,6]
00:40:57 <lambdabot>  [1,2,3,4,5,6]
00:41:51 <LAZAR> i only tried it in ghci and its not in scope there
00:42:17 <LAZAR> Variable not in scope: (<>) :: [Integer] -> [Integer] -> t
00:42:34 <Sampuka> > (\x->x^2) 4
00:42:36 <lambdabot>  16
00:42:54 <vaibhavsagar> LAZAR: import Data.Monoid ((<>))
00:43:03 <kadoban> import Data.Monoid ((<>)) -- it's not in Prelude as far as I know
00:43:08 <Sampuka> > :t map
00:43:10 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:43:13 <jle`> lambdabot: you need to import it :)
00:43:16 <Sampuka> how do I ask for type?
00:43:19 <LAZAR> I have to import Monoids? lol ok
00:43:19 <jle`> * LAZAR: you need to import it :)
00:43:23 <kadoban> :t map
00:43:24 <lambdabot> (a -> b) -> [a] -> [b]
00:43:30 <Sampuka> oh
00:43:35 <jle`> LAZAR: just the Data.Monoid module
00:43:40 <LAZAR> Thats just super weird because mappend is in Prelude
00:43:51 <jle`> i think it might be for historical reasons
00:43:55 <LAZAR> Which is the same
00:44:03 <jle`> also there's another module in base that exports (<>)
00:44:04 <jle`> that is different
00:44:11 <jle`> so it might be to prevent that from getting messy
00:44:19 <halogenandtoast> Semigroup?
00:44:29 <jle`> this other module is also commonly used, so it might get messy often if prelude exported its own (<>)
00:44:34 <jle`> yes, Data.Semigroup
00:45:02 <LAZAR> well if you use both you are screwed anyways so they should have made that operator polymorphic probably
00:45:16 <jle`> well
00:45:28 <jle`> (<>)/mappend should actually be in the Semigroup typeclass
00:45:35 <jle`> and not in Monoid
00:45:45 <jle`> but moving it would break a lot of code
00:46:32 <jle`> (<>) from Semigroup should be able to replace (<>)/mappend in most situations
00:47:22 <LAZAR> java class hierarchy to the rescue lol
00:47:43 <MarcelineVQ> in the not far too future semigroup should be a superclass of monoid and that issue should relax, unless that plan was changed
00:49:10 <jle`> the issues are mostly the same as with AMP i believe
00:49:26 <Unode> MarcelineVQ: on the book I'm reading this was supposed to be a ghc-8 target. Has this changed?
00:49:34 <jle`> but semigroup is not as ubiquitous as applicative is
00:52:10 <MarcelineVQ> dunno, seems to be in the cards though as a -Wsemigroup and  -Wnoncanonical-monoid-instances flags exist
01:02:19 <lpaste> jimmy pasted “No title” at http://lpaste.net/354724
01:03:02 <sullyj3> Hey guys, I have a function that compiles ^^^ , but when I try to use it in the repl, things start exploding. Any ideas?
01:03:09 <markus_> hi! is it true that classy lenses don't allow for type changing updates?
01:03:31 <sullyj3> ```Ambiguous type variable ‘a0’ arising from a use of ‘it’```
01:04:50 <pavonia> sullyj3: How are you using it?
01:05:02 <sullyj3> eto 1
01:05:24 <sullyj3> eto 1.0 gives the same error
01:05:34 <sullyj3> sorry, pavonia 
01:06:26 <pavonia> Try giving a type annotation for the result
01:08:44 <sullyj3> pavonia: :t eto gives ```eto :: (Integral a,  a) => a -> a```, which is confusing to me. I want it to be able to return non-integrals, obviously. What about the function is causing that constraint?
01:08:51 <Cale> eto :: (Integral a, Fractional a) => a -> a
01:08:56 <Cale> Yeah, that's not good
01:09:27 <Cale> It's because you're using ^
01:09:30 <Cale> :t (^)
01:09:31 <lambdabot> (Num a, Integral b) => a -> b -> a
01:09:47 <Cale> and of course (/)
01:09:50 <Cale> :t (/)
01:09:51 <lambdabot> Fractional a => a -> a -> a
01:12:03 <sullyj3> Cale: obviously n (as in nth term) has to be Integral, but x doesn't have to be. So, x/y is a Num, right? That's not a relevant constraint
01:12:19 <Cale> You probably want a fromIntegral around the factoral
01:12:22 <Cale> factorial*
01:12:34 <sullyj3> ohhhhhh
01:13:06 <Cale> Also, the first two lines of the definition of factorial would be redundant if you used foldl to define it.
01:13:19 <Cale> factorial n = foldl (*) 1 [1..n]
01:13:30 <Cale> Or better yet, use product [1..n]
01:14:17 <sullyj3> It works!
01:14:27 <sullyj3> Thanks, also a nice tip. Appreciate it!
01:16:23 <sullyj3> So, :t factorial is just ```factorial :: (Num t, Eq t, Enum t) => t -> t```, why is that becoming an integral?
01:17:00 <jle`> sullyj3: because of (^)
01:18:10 <sullyj3> jle`: but factorial is being used over the other side of the division, why would (^) constrain its result?
01:18:25 <Cale> sullyj3: The type of the result of factorial is the same as the type of its argument
01:18:39 <Cale> So n has whatever type the factorial does
01:18:58 <Cale> and n is being used as the exponent for (^)
01:19:22 <Cale> so its type is required to be an instance of Integral for that reason
01:21:30 <sullyj3> Cale: I get it now. Took a bit of pondering. Thank you!
01:22:55 <Cale> sullyj3: Oh, also, x / y is always going to be of some Fractional type. Num isn't enough on its own.
01:23:24 <Cale> :t (/)
01:23:25 <lambdabot> Fractional a => a -> a -> a
01:24:05 <sullyj3> Oh, of course.
01:24:12 <sullyj3> duh haha
01:24:19 <sullyj3> should've thought of that on
01:24:41 <kamyar> hello all
01:25:06 <kamyar> I have read about lifting and liftIO and there are many criticism that say lifting is a bad habit
01:25:13 <kamyar> makes the code bad smell
01:26:00 <Lokathor> https://gist.github.com/Lokathor/b2df34e820c6d298dd5f110f48ed42ee made a little demo of an IRC bot using async and STM
01:26:18 <kamyar> How can we avoid? see my code: http://lpaste.net/4157881788271689728
01:26:27 <kamyar> so many liftIO's
01:27:42 <Aruro> kamyar: make separate function
01:27:45 <Aruro> which is just IO
01:27:49 <Aruro> and then lift it
01:28:04 <Aruro> now indeed looks bad :)
01:28:42 <cocreature> putStrLn' = liftIO putStrLn :)
01:29:16 <Lokathor> yeah, let liftPrint = liftIO putStrLn in ...
01:29:20 <Aruro> kamyar: whole block of geting name and password should be one function
01:29:32 <LAZAR> Any suggestions for my Euclid based primality test? isPrime n = n >= 2 && all (\z -> gcd n z == 1) [2..(div n 2)]
01:30:24 <Aruro> LAZAR: who needs primality test ? :)
01:30:53 <cocreature> Aruro: primality tests are almost as important as implementing fibonacci!
01:31:00 <MVQq> those are good ways to avoid the word lift but typically the suggestion I see for a problem like this is to use IO exceptions to handle errors when the majority of your work is IO
01:31:09 <LAZAR> Aruro: Im doing some coding exercises to get to use with haskell
01:31:44 <Aruro> LAZAR: do some simple stuff u will LIKE, and feel its YOUR code , not some artificial problem put on you by somebody
01:31:56 <LiaoTao> LAZAR: You're supposed to check up to the square root
01:31:58 <LiaoTao> Not half
01:32:40 <MVQq> Lokathor: what will you do with your robut
01:32:56 <LAZAR> LiaoTao: You are right
01:33:25 <LAZAR> Aruro: Well i love crypto and math so working with primes and alike is fun for me
01:33:40 <cocreature> LAZAR: usually you also want to use "mod" instead of "gcd" here which should be faster
01:33:46 <LiaoTao> I still don't understand how to implement a prime sieve :(
01:33:51 <Lokathor> MVQq, well now I have two versions: one in rust using the standard library, and one in haskell using STM. I think I want to learn more about rust's "tokio" library and attempt a version using that at least
01:34:08 <Aruro> LAZAR: there are many aspects of haskell which are not captured in this problems, one of the most important one is making your own data types
01:34:10 <Lokathor> MVQq, get a basic comparison perhaps
01:34:20 <Aruro> these math problems are rather language agnostic
01:34:38 <MVQq> make a rust ffi lib, save the future from the present :O
01:35:25 <Lokathor> MVQq, what? I don't get what you mean
01:36:00 <MVQq> I mean test out your rust stuff, from haskell!
01:36:52 <Lokathor> on that's easy. Rust functions can be tagged as no_mangle and given a C-compatible signature and then compiled into a C-callable module with a snap
01:36:58 <LiaoTao> LAZAR: Regardless of the performance of your algorithm, div can be replaced with quot for more efficiency
01:37:01 <Lokathor> then we'd use inline-c on the Haskell side to call that rust module
01:37:30 <cocreature> I wonder if we’ll ever get rid of the C FFI as the plumbing between different languages
01:38:34 <Aruro> cocreature: never
01:38:38 <Aruro> nobody wants it
01:38:48 <cocreature> Aruro: don’t destroy my dreams!
01:39:55 <Aruro> i share your dreams, but reality is harsh :D
01:40:10 <cocreature> I just ignore reality
01:40:23 <LAZAR> isPrime n = n >= 2 && all (\z -> gcd n z == 1) [2..(round $ sqrt $ n)] why does the (round $ sqrt $ n) part give me an No Instance error... it should evaluate to an Integral value which serves as the upper limit?
01:41:28 <cocreature> LAZAR: the problem is that "n" is an Integral and you can’t call sqrt on that
01:42:03 <LAZAR> cocreature: why can i not sqrt an integral? O.o
01:42:35 <cocreature> :t sqrt
01:42:37 <lambdabot> Floating a => a -> a
01:43:01 <cocreature> LAZAR: because the result is not an Integral
01:43:23 <LAZAR> lol... just why? the result can have a different type than the parameter
01:44:00 <LAZAR> It should be Num a => a -> Double
01:44:34 <Lokathor> let mySqrt = sqrt . fromIntegral
01:45:05 <LAZAR> its just a weird design decision not to allow taking the square root of any number
01:45:19 <LAZAR> so much ceremony
01:45:52 <Lokathor> the sqrt of almost any number is going to be a floating value, not integral. Haskell doesn't auto-convert, so they just have you convert ahead of time in this case
01:46:26 <cocreature> it definitely shouldn’t be "Num a => a -> Double". you can’t implement that function
01:46:55 <LAZAR> Lokathor: Still it doesnt make much sense to me. Yes, the return value will always be a Floating, yet the function could be polymorphic to cover all number types
01:49:15 <Aruro> LAZAR: it is polymorphic
01:50:11 <LAZAR> Aruro: well the polymorphism is not total
01:50:58 <ahihi> sqrt :: Num a => a -> Double makes no sense for e.g. complex numbers
01:51:11 <fvgs> New to Haskell, I'm looking for advice on how to best setup Haskell on macOS. Haskell Platform seems to make too many opinionated decisions. I'm looking for a simple setup.
01:51:33 <fvgs> I use Homebrew, so instinctively I would like to just `brew install` the compiler (both ghc and ghci)
01:51:44 <LAZAR> ahihi: Complex numbers are not in Num because they cant have an ordering
01:51:52 <Aruro> :t sqrt
01:51:54 <lambdabot> Floating a => a -> a
01:51:54 <Iceland_jack> They are in Num
01:51:58 <Iceland_jack> they're just not Integral
01:52:06 <cocreature> and Num doesn’t require Ord
01:52:33 * Iceland_jack . o O ( remembers a time when Num required Eq )
01:52:42 <cocreature> lambdabot: tbh I don’t even know what a more polymorphic signature for sqrt would look like
01:52:59 <cocreature> eh LAZAR
01:53:14 <Aruro> fvgs: i installed with brew platform, what is opinionated?
01:53:35 <LAZAR> cocreature: well it should accept integral and floating
01:53:53 <LAZAR> because thats how square rooting is defined
01:54:01 <cocreature> LAZAR: give me a type signature that would actually be work and is more general than the current signature
01:54:01 <LAZAR> it takes real numbers
01:54:18 <fvgs> @Aruro what do you mean by "brew platform"? I meant that the Haskell Platform seems rather opinionated given all the tools and libraries it comes with
01:54:19 <lambdabot> Unknown command, try @list
01:54:36 <ahihi> square roots are not limited to the reals
01:55:12 <Aruro> :t sqrt
01:55:14 <lambdabot> Floating a => a -> a
01:55:15 <ahihi> I also don't know what the type of the function you want would look like
01:55:23 <Aruro> realize your instance for complex, where is problem?
01:56:07 <Aruro> fvgs: haskell platform is good choice, i dont know what is opinionated in it, seriously, its just compiler and cabal
01:56:34 <Aruro> i installed it with brew and had no problems
01:57:43 <Aruro> ahihi: u have to make your complex numbers an instance of Floating typeclass
01:58:00 <ahihi> Aruro: I don't know why you're telling me this
01:58:29 <Aruro> ahihi: because u made wrong type signature there is no function sqrt::a->Double
01:58:31 <dramforever> Q: Why did Haskell designers choose to use '::' for type signature and ':' for cons? I heard that it's because they expected cons to be used more often (uh oh), but any reliable resource?
01:58:56 <Aruro> ahihi: there could be function sqrt :: Complex->Complex
01:58:59 <ahihi> Aruro: perhaps read the discussion from the beginning
01:59:34 <fvgs> Well, right now I'm considering just installing ghc via brew manually. But I'll pivot to a different question: what are the roles of cabal and stack? The downloads page seems to indicate that stack
01:59:46 <LAZAR> cocreature: sqrt :: Real => a -> Real for all real numbers and optionally complexSqrt :: Complex => a -> [Real]
01:59:48 <fvgs> can be installed as a single solution for all package management, including the installation of ghc
01:59:56 <fvgs> is the difference the same as nvm vs npm?
01:59:58 <Aruro> fvgs: dont do that, brew is crazy it wants to compile ghc, platform has binary
02:00:14 <fvgs> brew uses bottles typically?
02:00:53 <cocreature> LAZAR: that makes no sense. the first function is less general than the current function. and the second for some reason returns a list and is even less general. apart from that "Real => a -> Real" is a syntax error. you probably want "Real a => a -> Real"
02:01:38 <Aruro> :t fromIntegral
02:01:40 <lambdabot> (Num b, Integral a) => a -> b
02:02:27 <ahihi> LAZAR: so, do we then need a third function for quaternions? :)
02:02:33 <dramforever> 'Haskell doesn't auto convert'
02:02:48 <Aruro> fvgs: i dont know much about brew, but install ghc tries to compile which will take very long time, like a day
02:03:02 <Iceland_jack> dramforever: Yes in retrospect is should be the other way 'round
02:03:09 <LAZAR> cocreature: assuming Real was not the haskell real but the set of real numbers, containing both Floating and Integral and thus being more general than Floating alone
02:03:31 <dramforever> Iceland_jack: Yeah, but it's no big deal TBH
02:03:44 <Iceland_jack> It literally makes Haskell unusable for me dramforever
02:03:56 <cocreature> LAZAR: then it still doesn’t work for complex numbers, quaternions, …
02:04:09 <LAZAR> dramforever: its a parametric type with instances covering both floating and integral...
02:04:29 <LAZAR> cocreature: sqrt is not defined for complex numbers anyways
02:04:45 <dramforever> Huh
02:04:50 <cocreature> LAZAR: what? sqrt is just the inverse of ^2 and that’s definitely defined for complex numbers
02:04:55 <LAZAR> but it is generally reasonable to assume people want to sqrt both integrals and floatings
02:04:56 <ahihi> > sqrt (1 :+ 1)
02:04:58 <lambdabot>  1.09868411346781 :+ 0.45508986056222733
02:05:28 <dramforever> There's a 'branch cut' thingy that specifies which number gets returned
02:05:47 <dramforever> > (1.09868411346781 :+ 0.45508986056222733) ^ 2
02:05:49 <lambdabot>  1.0000000000000002 :+ 1.0
02:05:52 <dramforever> > (1.09868411346781 :+ -0.45508986056222733) ^ 2
02:05:54 <lambdabot>  error:
02:05:54 <lambdabot>      Precedence parsing error
02:05:54 <lambdabot>          cannot mix ‘:+’ [infix 6] and prefix `-' [infixl 6] in the same infi...
02:06:03 <dramforever> > (1.09868411346781 :+ (-0.45508986056222733)) ^ 2
02:06:05 <lambdabot>  1.0000000000000002 :+ (-1.0)
02:06:18 <dramforever> Damn I can't do math today
02:06:38 <fvgs> Aruro: perhaps the more important thing for me to understand right now is the ecosystem. Are cabal and stack complementary, in that cabal handles global packages and stack handles all sandboxing?'
02:06:54 <fvgs> Or does make sense just to use cabal OR stack?
02:07:00 <LAZAR> cocreature: The most general definition would be to accept any complex number and pass back an array containing the solutions
02:07:11 <jle`> fvgs: you can think of stack as a wrapper around Cabal the library
02:07:28 <Aruro> LAZAR: ok, here people already wrote : https://wiki.haskell.org/Generic_number_type
02:07:28 <dramforever> fvgs: cabal is actually two things
02:07:32 <cocreature> LAZAR: so now I want to use quaternions and it doesn’t work
02:07:33 <jle`> stack doesn't actually use the command line tool 'cabal'
02:07:44 <jle`> it replaces the functionality of the command line tool, using the Cabal library
02:07:52 <dramforever> fvfs: a package manager, and a packaging system
02:08:16 <dramforever> would it make more sense if I said 'front end' and 'back end'?
02:08:35 <fvgs> jle: That suggests to me that the functionality offered by stack is a superset of that offered by cabal?
02:08:37 <dramforever> stack replaces the front end, and adds compiler version managing and stackage snapshot
02:08:51 <fvgs> dramforever: I understand what you mean, yes
02:09:12 <jle`> fvgs: they implement their functionality in different ways, and it's a different workflow
02:09:34 <fvgs> my understanding so far makes them sound a far bit like npm and nvm
02:09:35 <dramforever> But the underlying packaging system is the same
02:09:48 <dramforever> A bit like npm and npm+nvm
02:09:52 <jle`> the thing that is the same is that they both know how to read '.cabal' files
02:10:08 <fvgs> so do stack users typically not use cabal?
02:10:17 <jle`> cabal actually has sandboxing/reusable builds nowadays, so you can be ok using cabal without stack
02:10:23 <jle`> fvgs: yeah, they are pretty much two independent tools
02:10:28 <fvgs> Rather, not use cabal directly via the cabal cli
02:10:40 <jle`> yeah, both of them use the Cabal library
02:10:41 <dramforever> not use cabal the front end
02:10:46 <jle`> but they are two independent tools for the most part
02:10:47 <dramforever> but use cabal packages
02:11:00 <fvgs> what are "cabal packages"?
02:11:06 <dramforever> like instead of 'npm build' you could also 'nvm build'
02:11:26 <jle`> the Cabal library lets you read '.cabal' files that specify a package.  basically package metadata
02:11:29 <Aruro> fvgs: tbh, those days when tooling were dealbraker in haskell are over, cabal and stack are both just fine, unless u are writing something mega huge
02:11:34 <dramforever> fvgs: Just like how Node has `package.json` packages
02:11:43 <dramforever> Haskell has `.cabal` packages
02:11:43 <jle`> it standardizes the packaging system that haskell uses
02:11:51 <LAZAR> cocreature: for normal application development you need quaternions? i highly doubt. even if, there are specialized modules for handling those. 
02:12:04 <jle`> but i think for the most part using only cabal or only stack is fine
02:12:11 <jle`> maybe like easy-install and pip, even
02:12:21 <fvgs> Makes sense, in the same way yarn replaces npm
02:12:23 <Aruro> LAZAR: its perfectly nomral to want sqrt to work on all numbers.
02:12:44 <jle`> they also both get their packages from the same repository
02:12:54 <jle`> stack just is smarter with managing versions
02:13:03 <jle`> well. maybe not smarter
02:13:04 <fvgs> with that said, it sounds like stack is the one to use unless you don't care about versioning your projects to a specific compiler version, which seems like a mistake in most cases
02:13:06 <jle`> more curated
02:13:37 <dramforever> I'm not so sure about that
02:13:40 <jle`> using LTS snapshots with stackage is why i use stack over cabal these days
02:13:41 <LAZAR> Aruro: which haskell obviously doesn't do, right? ;-) because it doesnt support squaring integers
02:13:58 <dramforever> > (2 :: Integer) ^ 2 -- Like that?
02:14:00 <lambdabot>  4
02:14:00 <MVQq> the point of stack is reproduceable builds, something that builds now should build a year from now, the other benefits people find in it are consequences of that decision
02:14:00 <LAZAR> *square rooting
02:14:02 <quchen> The complex square root still has just a single solution, otherwise it wouldn’t be a function (but just a relation). The quadratic equation has two solutions, but »solution of this quadratic equation« is not a map from quadratic equations to the reals.
02:14:02 <Aruro> LAZAR: did u read that article i sent you? thereare deep thought on why it is like that
02:14:06 <jle`> cabal has 'cabal freeze', which helps you get reproducable builds in the same way, though
02:14:07 <dramforever> > (2 :: Integer) ** 2 -- Oh you mean this
02:14:08 <lambdabot>  error:
02:14:09 <lambdabot>      • No instance for (Floating Integer) arising from a use of ‘**’
02:14:09 <lambdabot>      • In the expression: (2 :: Integer) ** 2
02:14:32 <quchen> s//unique/
02:14:45 <fvgs> but does cabal freeze allow you to build with a specific compiler version?
02:14:52 <jle`> but i prefer picking snapshots to freezing whatever ephemeral package version state you have
02:15:07 <fvgs> right, it sounds like it suffers the same issues as pip freeze
02:15:26 <fvgs> you need to lock down the compiler/interpreter version as well as the individual package versions
02:15:35 <jle`> i like the idea of a canonical set of package versions that everyone in the community agrees on at different stages
02:15:38 <fvgs> for guaranteed reproducible builds
02:15:48 <dramforever> Upgrading from working deps to working deps works pretty easily
02:15:57 <Aruro> fvgs: also u may wish to know that its very easy to switch your project from stack to cabal and vice versa
02:16:03 <dramforever> So I think snapshots work for Haskell
02:16:45 <fvgs> Aruro: if they use the same sort of package metadata, shouldn't they essentially interoperate?
02:16:54 <dramforever> They do
02:16:55 <jle`> i think stack and cabal are different tools that can do pretty much the same big-picture things, but with just slightly different workflows
02:17:31 <dramforever> I think you can switch your workflow on a package from cabal to stack easily
02:17:44 <jle`> and yes, both of them look at the same package metadata.  'stack' actually adds some extra metadata to help with build reproducability and makes it a bit easier to swap out local versions for dev
02:17:46 <dramforever> I haven't really tried the other direction so....
02:18:06 <jle`> i'm not sure if cabal lets you say "this package comes from this github url"
02:18:12 <jle`> but it probably does
02:18:22 <fvgs> what about for global package management and installing multiple versions of ghc?
02:18:42 <fvgs> are cabal and stack the same in that regard?
02:18:42 <dramforever> Can I say 'there's no global package management'?
02:18:55 <jle`> hm.  i don't know what cabal offers there
02:19:00 <dramforever> Oh I mean for stack
02:19:17 <jle`> stack abstracts over different ghc versions for you so that's nice
02:19:23 <quchen> fvgs: Stack is all (smartly shared) sandboxes. Cabal supports sandboxing mostly on a per-project basis, and uses the available compiler (as in $PATH).
02:19:33 <fvgs> For instance, go get takes it kinda to the extreme and makes all packages effectively global
02:19:37 <dramforever> There *is* a global project, that stack uses when you run stack outside of a stack package
02:19:54 <fvgs> which is pretty much why you can't use go get for depedency management
02:23:25 <jle`> hm.  so i guess there's an important feature difference.  stack abstracts over ghc versions and manages them for you, and you don't have to worry about $PATH or anything
02:23:25 <Aruro> LAZAR: short answer is because of floating sqrt of very big 16 may not give very big 4
02:23:25 <jle`> it just picks the one associated with the snapshot
02:23:25 <jle`> and downloads it if necessary
02:23:25 <Aruro> LAZAR: thats why there is no sqrt :: Integer -> Integer
02:23:25 <jle`> for cabal you might have to go out of your way to install it manually and adjust $PATH by hand on a per-project basis
02:23:25 <jle`> (maybe)
02:23:25 <jle`> i haven't been following cabal development too closely
02:23:25 <fvgs> that sounds like about what I would expect, if the primary difference is in stack's ability to version the compiler on a per-package basis
02:23:25 <cocreature> cabal has a --with-ghc option
02:23:25 <jle`> oh, there you go
02:23:25 <Aruro> cabal is secretly becoming better and better
02:23:25 <cocreature> and iirc cabal master also has ghc environment fiels where you can configure the compiler
02:23:25 <jle`> but i think maybe it can be said that stack abstracts over ghc versions the same way it abstracts over packages, it's all sort of one unified thing
02:23:25 <cocreature> yep
02:23:25 <jle`> the same way that your snapshot determines your package versions, it also determines your ghc
02:23:25 <dramforever> I thought it's called 'snapshot'
02:23:25 <jle`> cabal talks about them as separate entities
02:23:25 <jle`> well, i guess that's because cabal doesn't have "snapshots" per se, just per-package freezes
02:23:46 <quchen> Stackage started as a huge freeze file IIRC
02:23:53 <quchen> (Before we even had Stack)
02:24:27 <cocreature> the distinction becomes slightly fuzzy since base effectively is a freeze of the GHC version
02:25:18 <jle`> oh yeah, so freezing your package versions effectively freezes your ghc version
02:25:21 <fvgs> so do either cabal or stack formally allow for global package installation? Does the --with-ghc mean ghc is installed as another package and update by using cabal update?
02:25:34 <jle`> maybe cabal is just missing auto-downloading of ghc
02:26:00 <Aruro> fvgs: yes both global packages are alowed , we just said these tools are ALMOST same :)
02:26:17 <Aruro> u can not make big mistake, pick any
02:26:32 <dramforever> 'u can not make big mistake, pick any' -- best advice
02:26:37 <quchen> For some value of »same«. I find the Cabal workflow much less intuitive, but theoretically they’re equally capable.
02:26:37 <jle`> fvgs: stack doesn't really have global packages, just a global cache.  and the snapshot you're working on determines what part of the cache you use
02:26:39 <cocreature> yeah that’s definitely missing. but I think the main difference is more of a philosophical nature, i.e  use dependency solvers vs use a consistent snapshot. both allow using the other but are clearly targeted at one of those
02:27:19 <dramforever> I want to say if you don't understand what's going on just pick stack
02:27:46 <jle`> stack has better documentation anyways, in my opinion
02:28:00 <Aruro> jle`: cabal recently imroved
02:28:07 <Aruro> even has fancy readthedocs :D
02:28:07 <cocreature> also stack just has better defaults. without sandboxes or new-build you will shoot yourself in the foot
02:28:15 <fvgs> I'm more just curious in understanding the ecosystem rather than messing around and encountering the subtle issues firsthand. Been there done that...
02:28:16 <jle`> :D
02:28:17 <cocreature> and neither of those is the default atm
02:28:52 <jle`> the differences are subtle, it's just that if you ask us to expand on the details, we can talk about any small difference at great length, heh
02:29:25 <dramforever> The fact that both stack and cabal work on .cabal packages says a lot about how similar they are...
02:29:27 <fvgs> indeed, I think I have a better idea of what each has to offer now though :D
02:29:48 <jle`> yeah, if you want a picture of the ecosystem, you'd probably gain more on looking on how they are the same :)
02:29:55 <fvgs> can stack manage my global version of ghc?
02:29:56 <jle`> s/gain more on/gain more by
02:30:01 <fvgs> or do I also have to install ghc separately?
02:30:06 <jle`> i don't think it's made for that
02:30:07 <dramforever> fvgs: global?
02:30:13 <Aruro> fvgs: there is also nix way, which hardcore haskellers use
02:30:14 <dramforever> How global?
02:30:21 <jle`> stack installs ghc to its own cache
02:30:25 <jle`> the same place it caches its packages
02:30:32 <fvgs> the same way you might install a global version of python to your system
02:30:45 <jle`> ah, yeah.  stack isn't quite meant for that, i believe
02:30:48 <dramforever> No, stack doesn't do that
02:30:57 <dramforever> but I don't really do that either....
02:31:05 <Aruro> fvgs: nix can do what u want
02:31:21 <jle`> stack installing a ghc is the same as installing a package, it's all abstracted over when you want to build a package
02:31:22 <dramforever> stack can run single files
02:31:37 <fvgs> I've looked into nix, but haven't given it a serious try yet
02:31:39 <jle`> it uses a cached ghc and cached packages to build your package
02:31:54 <dramforever> Hmm... Anyone tried stack exec bash?
02:32:20 <jle`> i used to do cabal exec bash all the time, but now i just stack exec (thing i want to run)
02:32:37 <fvgs> it sounds like using stack to run a single file would be inappropriate since how does it know what version of ghc to use?
02:32:38 <jle`> fvgs: and yeah, stack exposes the interface of whatever ghc the snapshot is using with 'stack ghc ...'
02:32:40 <dramforever> fvgs: nvm doesn't really install a global node.js, right?
02:32:47 <fvgs> That's the use case for which I would use a globally installed version
02:32:49 <jle`> fvgs: it uses the version of the snapshot you're in
02:32:57 <dramforever> fvgs: You can specify
02:33:00 <jle`> you're always in a snapshot, no matter what
02:33:03 <fvgs> jle: right
02:33:07 <Aruro> fvgs: https://github.com/Gabriel439/haskell-nix
02:33:14 <fvgs> but you can install your own global version if desired
02:33:16 <Aruro> fvgs: too much information, isnt it?
02:33:21 <dramforever> In the file, write a line like: -- stack script --resolver lts-?.? --package ...
02:33:35 <dramforever> fvgs: essentially, write your deps in your file
02:33:38 <jle`> you can pick to use a specific ghc version of desired, which is like an override of your resolver
02:33:51 <dramforever> This: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter
02:33:55 <jle`> *specific ghc installation
02:34:01 <jle`> but you don't need to
02:34:49 <dramforever> fvgs: The most 'global' ghc stack offers is in the global project
02:35:14 <jle`> the global project is basically just a "default" resolver that stack uses if you aren't in a project with its own resolver
02:35:28 <fvgs> but does stack symlink anything from the global project into /usr/local/bin or somewhere else in your path?
02:35:36 <jle`> no
02:35:40 <dramforever> no
02:35:44 <jle`> stack does not affect anything outside of stack
02:36:00 <jle`> if you want to use ghc that stack has cached, you'd use 'stack ghc ...'
02:36:08 <jle`> or 'stack ghci'
02:36:15 <fvgs> but it might have many cached versions?
02:36:24 <jle`> yeah, so it uses the one that the resolver/snapshot specifies
02:36:48 <dramforever> jle`: Idea: how about `stack exec bash`? Can you do that?
02:36:52 * dramforever is on Windows so, can't
02:36:58 <jle`> basically all usage of ghc/ghci/etc. are abstracted over
02:37:08 <jle`> dramforever: works for me :o
02:37:23 <dramforever> Can run ghc there?
02:37:55 <dramforever> I mean, just 'ghc' gives the snapshot ghc
02:38:04 <dramforever> 'whereis ghc' should tell
02:38:32 <fvgs> if ghc is available in your path, who's putting it there?
02:38:40 <jle`> fvgs: not stack
02:38:54 <fvgs> obviously I can install ghc myself, independent of any package manager
02:38:55 <jle`> dramforever: it looks like using ghc gives me not-the-snapshot ghc
02:39:04 <fvgs> that's what I would expect
02:39:05 <dramforever> duh
02:39:14 <jle`> fvgs: yes, if ghc is in your path, then something (or someone) put it there, not stack.  stack doesn't touch that stuff
02:39:25 <jle`> dramforever: i wonder if that's a bug?
02:39:45 <dramforever> does PATH have the stack paths in it?
02:39:52 <geekosaur> fvgs, the general rule in *all* programming languages other than C/C++ is that if you want to install packages, you should also install your own version of the language not from the system package manager. and if you install the language from the system package manager, only install packages to it from the system package manager
02:40:41 <jle`> dramforever: oh
02:40:43 <jle`> yes, it does
02:40:49 <dramforever> Huh
02:40:52 <jle`> but i think i overwrode it with mby .bash_profile
02:40:54 * dramforever gotta go
02:40:55 <jle`> hehe
02:40:55 <dramforever> sorry
02:41:00 <jle`> so stack did add the right ghc version
02:41:03 <dramforever> jle`: That's nice!
02:41:11 <jle`> but my .bash_profile added another ghc version on top of that, so
02:41:19 <jle`> i guess that's the flaw of exec bash
02:41:48 <dramforever> Actually makes me think, perhaps we can make a tool that make stack work like, say, rvm
02:42:00 <geekosaur> that shouldn't happen from .bash_propfile, but it will happen if you follow the common idiocy of setting $PATH in .bashrc
02:42:16 <jle`> fvgs: btw, to make it more confusing, there's also a thing that exists called the Haskell Platform, which installs both cabal *and* stack
02:42:18 <jle`> because why not
02:42:22 <jle`> geekosaur: ah that might be it :)
02:42:27 <geekosaur> which is a lovely wayy to break stack, rvm, pyenv, ...
02:42:28 <jle`> i do do that >_>
02:42:31 <dramforever> Selecting GHC from bash
02:42:33 <dramforever> how lovely
02:42:39 * jle` hangs head in shame
02:43:02 <jle`> anyway , i'm out too :)
02:43:36 <fvgs> jle: I took a look at the Haskell Platform but quickly decided against it. Too opinionated for what I'm looking for, at least at this time
02:44:05 <fvgs> but that's part of why I thought cabal and stack might go together
02:44:13 <fvgs> as opposed to offer similar functionality
02:44:54 <Aruro> what is opinionated i still dont get
02:46:26 <fvgs> installing two package managers and 35+ libraries in addition to the compiler is opinionated imo
02:46:27 <geekosaur> espeically when stack wants to force you to use predefined resolvers/sets of packages
02:46:48 <fvgs> I mean it's perfectly fine, but as someone starting out with Haskell, I just want the bare bones
02:47:01 <Aruro> no
02:47:04 <Aruro> u want that libs
02:47:10 <geekosaur> you'll be cured of tat one the fiurst time you install something that depends on lens :)
02:47:24 <geekosaur> also, the bare bones are *very* bare
02:47:38 <Aruro> fvgs: its REALLY most beginner friendly thing
02:47:45 <fvgs> absolutely fair, but I want to understand *why* I need x, y, z, and 50 other letters
02:48:16 <Aruro> i would personallyinstall all 100 most popular packages from start.
02:49:11 <Aruro> whats to understand? everything depends on something else
02:49:34 <Aruro> tons of alternative libraries
02:50:05 <fvgs> with the objective of learning, I haven't found a need for those 100 libraries yet
02:50:52 <Aruro> haskell has really little from start
02:50:59 <Aruro> u will be inventing wheel in most cases
02:51:20 <sullyj3> say I have a function f defined at the top level, and a function g defined inside a where clause in the definition of f...
02:51:32 <sullyj3> is there a way to get the type of g from ghci?
02:51:58 <fvgs> it's the same difference between using an IDE vs building your own vimrc from scratch
02:52:36 <Aruro> i like when there is no need to go to internet for every little thing like opening a directory or reading an url
02:53:49 <Aruro> fvgs: btw cabal and stack compile libraries, so time needs to be spent to build good system
02:54:00 <Iceland_jack> sullyj3: yes
02:54:10 <Iceland_jack> with `:set +c` https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set +c
02:54:23 <fvgs> build good system?
02:54:30 <Aruro> like all tools u need
02:54:45 <fvgs> you're saying they always download source?
02:54:53 <Aruro> yes
02:55:14 <sullyj3> Iceland_jack: 
02:55:18 <fvgs> oh you're referring to building a local cache of common libraries?
02:55:19 <sullyj3> Iceland_jack: awesome thanks
02:55:44 <Iceland_jack> The most recent Haskell-mode you can use "haskell-mode-show-type-at" to easily find the type at a given point
02:55:58 <Iceland_jack> but I suppose without tooling support you'd have to type in the location manually? yuck
02:56:18 <Aruro> fvgs: yeah, installing globally or in sandbox will take time
02:56:19 <fvgs> oh yeah, also what is stackage?
02:56:40 <Aruro> its same as hackage but libs are curated
02:57:09 <Aruro> version collisions are absent
02:57:20 <fvgs> so stackage is to debian as hackage is to arch?
02:57:40 <Aruro> mmm, i have no idea about debian :D
02:58:28 <Aruro> hackage is original, stackage is maintained as a filtered set of hackage packages
03:02:03 <fvgs> thanks for answering my questions all, I'm off
03:35:21 <Engen> A question regarding using lambda expressions. I saw on this chat last night something that was of use to me today and was wondering if these sort of uses had a specific name
03:35:38 <Engen> Sort of how you have patterns in java
03:36:13 <Engen> The piece of code in question is map (\x -> myFunction x [1,2,3,4]) [1,2,3,4]
03:37:20 <Engen> And this (I think) is akin to doing two for loops in any other procedural language
03:37:54 <Engen> Loop over every element of the list, and do something with it and a list containing identical values
03:38:09 <Engen> I guess 'patterns' isn't really the right word to describe it 
03:55:02 <quchen> Engen: That’s a single »loop«: map.
03:55:24 <Gurkenglas> What library should I use to traverse a website and send a form? (I've taught tagsoup to find the form once it appears, but I think that manually constructing the POST request is a little smelly)
03:55:29 <quchen> myFunction could be anything, for example the function »\x y -> 1«.
03:57:47 <quchen> Engen: The pattern of looping over a set of things is the Iterator pattern. In Haskell we don’t have an iterator pattern because we can just abstract over this with the »map« function (or, more generally, fmap).
03:58:22 <quchen> (In Java the iterator pattern is probably also past its end of life. But it’s in GoF so it’s pretty much undead.)
04:04:03 <opqdonut> quchen: I'd say folds instead of maps
04:04:36 <quchen> Or traversals? :-)
04:05:27 <quchen> opqdonut: ^
04:06:38 <opqdonut> well, yeah
04:06:41 <opqdonut> they're folds :)
04:08:15 <Geekingfrog> «traversing a website» wouldn't that mean using some kind of queue, because links are added as they as discovered?
04:08:24 <Geekingfrog> s/as/are
04:09:17 <quchen> Gurkenglas: Sounds like a breadth-first search through the URL graph, in which case it would be a queue, yes. 
04:10:08 <Gurkenglas> I must have miscommunicated. I have the URL with the form, just need to find out how to automatically fill it out. (searching github for postRequest in Haskell files finds nothing!?)
04:11:15 <quchen> Oh, so you want to craft a HTTP request?
04:11:23 <quchen> wreq or req come to mind
04:11:28 <quchen> Haven’t used either though
04:12:01 <cocreature> I’ve used wreq and http-conduit
04:12:37 <cocreature> I don’t know of anything that automatically creates post requests based on html forms
04:12:58 <LAZAR> is it preferred to use Text over String?
04:13:14 <cocreature> yes
04:14:41 <quchen> String has one use, and that’s showing hello world in talks.
04:15:02 <saurabhnanda> tdammers: are you around?
04:19:35 <Faucelme> Both the "bound" and the "unbound" Hackage packages for abstract syntax trees seem to use the "locally nameless" representation. Is there some overview of their differences?
04:20:25 <LAZAR> cocreature: So where do I do the cast from String to Text when reading Input?
04:20:46 <cocreature> LAZAR: just read your input as Text?
04:20:51 <LAZAR> Assuming i get an IO String
04:20:57 <cocreature> why do you get that?
04:21:20 <LAZAR> well readFile returns one
04:21:26 <cocreature> use readFile from Data.Text.IO
04:22:02 <LAZAR> ah thanks
04:22:58 <fXl> hello guys, how can i add and use data and functions from DataYml in my Main function, file structure is here. https://hastebin.com/obatobevek.hs
04:23:57 <cocreature> Faucelme: it’s been quite some time since I’ve looked at either of those libraries but iirc unbound does slightly more things for you automatically at the cost of relying heavily on TH
04:24:04 <fXl> i get this error, Expected: ‘Data.DataYml’
04:24:36 <cocreature> fXl: can you show us Data/DataYml.hs?
04:24:54 <LAZAR> Is there someting like read for Texts, too?
04:25:18 <cocreature> sounds like you probably have the wrong module name there
04:25:46 <fXl> okey
04:25:50 <quchen> LAZAR: Parser libraries. Read is really just a hack for demonstrational purposes if you ask me.
04:26:03 <LAZAR> quchen: found it, Text.Data.Read
04:27:17 <fXl> cocreature, https://hastebin.com/eruqabutuf.hs
04:27:49 <cocreature> fXl: change the first line to "module Data.DataYml where"
04:28:47 <fXl> cocreature, cool it worked ty
04:35:27 <LAZAR> When an either returns Right or Left, how can I access the contents of the latter? for example if i want the integer from Right (99," guys") 
04:35:45 <cocreature> pattern matching
04:36:21 <cocreature> > case Right (99, "guys") of Right val -> val
04:36:24 <lambdabot>  (99,"guys")
04:37:46 <geekosaur> not quite the question I think
04:38:06 <geekosaur> > case Right (99, "guys") of Right (i,_) -> i
04:38:08 <lambdabot>  99
04:38:44 <cocreature> oh right, sry
04:57:07 <LAZAR> do i really have to pack all string literals as text? (Text.pack " ")
04:57:43 <quchen> LAZAR: Not if you enable OverloadedStrings
04:57:45 <tdammers> LAZAR: you can use the OverloadedStrings language extension
04:57:46 <LAZAR> the docs say i can use literals but ghc complains
04:57:48 <LAZAR> oh
04:57:53 <quchen> :set -XOverloadedStrings     <--- in GHCi
04:58:13 <tdammers> the downside is that it makes string literals polymorphic, so there may be situation where you need to explitly annotate them
04:58:16 <quchen> Then you can just write »"hello" :: Text«
04:59:55 <hpc> or in a file, {-# LANGUAGE OverloadedStrings #-}
05:01:35 <LAZAR> Ah i see
05:02:11 <Profpatsch> Hi #haskell
05:02:14 <LAZAR> whats the preferred way to handle ambiguity? Like when using Text it will require me to write Prelude.map each time I need a map...
05:02:36 <cocreature> LAZAR: qualified imports
05:02:41 <tdammers> the ambiguity is not about which map function to use, but which type to use for the string literal
05:02:44 <cocreature> import qualified Data.Text as Text
05:02:46 <fXl> http://lpaste.net/354728, i am getting this. import qualified Data.ByteString.Char8 as BS
05:02:48 <Profpatsch> I’d need a type of collection that has equality defined to be true if one element is Equal.
05:03:01 <tdammers> oh, that
05:03:09 <tdammers> nm
05:03:48 <Profpatsch> LAZAR: Also, typeclasses. Everything that is a functor has an instance for fmap.
05:04:01 <Profpatsch> fmap is Text.map for Text and List.map for Lists.
05:04:21 <cocreature> Profpatsch: it’s not. Text is not an instance of Functor :)
05:04:35 <Profpatsch> cocreature: Oh, right. Monotraversable and stuff. 
05:04:35 <cocreature> (and it can’t be because it has the wrong kind)
05:05:11 <LAZAR> Can you give an example? I already use import Data.Text as T, how will the qualified change things?
05:06:08 <cocreature> LAZAR: import Data.Text as T will import all symbols from Data.Text and make them available without any prefix. "as T" means that you _can_ refer to them by T.symbolname but you don’t have to. a qualified import will only make them available using a prefix
05:06:37 <LAZAR> cocreature: oh well i thought it was justa  shortcut
05:08:10 <LAZAR> Well if i use import qualified Data.Text, i then have to prepend Data.Text before every instance of Text...
05:09:17 <fXl> http://lpaste.net/354728, i am getting this error for import qualified Data.ByteString.Char8 as BS
05:10:04 <Clint> fXl: you're mixing strict and lazy bytestrings
05:10:28 <fXl> how should i add then ?
05:10:37 <Clint> depends what you're trying to do
05:11:06 <fXl> Clint, trying this http://blog.ssanj.net/posts/2014-10-09-How-to-read-a-YAML-file-from-Haskell.html
05:11:22 <LAZAR> So the best way to avoid both Data.Text.Text as well as Prelude.map is just using import Data.Text hiding (map)?
05:12:32 <Clint> fXl: and what's on line 34
05:14:13 <fXl> same lines there
05:14:20 <fXl> i just copied it to try
05:14:45 <tdammers> LAZAR: I usually import Data.Text (Text); import qualified Data.Text as Text
05:14:51 <Clint> fXl: that only has 18 lines
05:14:53 <tdammers> and then Text.map if you have to
05:15:03 <tdammers> however I rarely need to map over a Text
05:15:13 <fXl> Clint, i added them after my code
05:15:16 <fXl> but same lines
05:15:25 <Clint> fXl: SO WHICH ONE IS LINE 34
05:15:45 <fXl> case parsedContent of
05:16:00 <Clint> okay, and what is the type signature of decode in your version of the yaml library?
05:16:48 <Profpatsch> I’ve got a datastructure which is basically a map of mutliple keys to value
05:16:56 <fXl> i dont know how to check :D
05:17:21 <Profpatsch> Is there a type that can represent that?
05:17:22 <fXl> Data.ByteString.Lazy.Internal.ByteString -> Maybe a
05:17:39 <Clint> fXl: there you go
05:17:51 <Profpatsch> I need to be able to update an entry by referencing one of the multiple keys.
05:17:55 <fXl> :D is there any differences between them ?
05:18:05 <Profpatsch> But the entry should then be updated for all keys in the same group.
05:20:44 <LAZAR> tdammers: But that would disable treating string literals as text?
05:21:13 <LAZAR> At least i think strings cant be overloaded when you dont import Text unqualified
05:21:24 <geekosaur> incorrect
05:22:49 <LAZAR> Just checked, it won't treat literals as text if you just make a qualified import of Text
05:25:22 <Profpatsch> Is an IxSet maybe what I want?
05:29:30 <quchen> Profpatsch: How about a Map (Map ks k) v? The (Map k ks) associates all the different keys of a value (ks) with a single key (k) that then does a lookup on the outer map
05:29:48 <quchen> k could be Int, for example
05:29:55 <Unode> What's the difference between "import Modules (Module, moduleFunction)" and "import Modules (Module(moduleFunction))" ?
05:30:09 <Profpatsch> quchen: I thought about that, but I have the case where I want to update the actual values.
05:30:50 <Profpatsch> It’s probably easier than my tired brain made it out to be.
05:30:58 <geekosaur> Unode, the latter is not moduleFunction, it is data constructors and possibly field names
05:31:42 <Profpatsch> I kind of refuse to believe this is not a semi-common problem though, and already solved with a nice data structure somewhere. :)
05:32:00 <Unode> geekosaur: I get confused because for some cases both forms seem to make the compiler happy. While in other cases only one form actually works.
05:32:56 <geekosaur> 'both forms' sounds like field names, where exporting separately gives you the accessor function/deconstructor but likely doesn't allow pattern matching with record syntax or record update syntax
05:32:57 <Unode> geekosaur: so if I get it correctly, the two forms import different things?
05:33:39 <geekosaur> which is a way to hide the internal details of a type, so you can change them later without breaking the published API
05:45:29 <quchen> Profpatsch: Hm, a pair of maps sounds better: http://lpaste.net/354729
05:45:32 <quchen> Something like this?
05:46:17 <quchen> A pair of (keys -> key) and (key -> value), that is.
05:46:24 <quchen> Where (key) is whatever you want, probably Int.
05:46:36 <quchen> But anything Ord should go.
05:46:42 <quchen> s/go/work/
05:47:00 <Profpatsch> quchen: That seems nice, thanks.
05:47:19 <Profpatsch> Maybe it’s really this trivial so nobody has bothered adding it to a package.
05:47:36 <quchen> Profpatsch: What you’re really doing here is function composition, since (Map a b) is pretty much (a -> Maybe b)
05:48:10 <Profpatsch> But then it’s either a really big map or a pretty partial function. :)
05:48:46 <quchen> Sure, the runtime will be dramatically different :-)
05:50:40 <_sras_> Is there anyway to make ghc-mod to check the whole project?
05:52:00 <quchen> _sras_: GHC? :-þ
05:52:31 <quchen> Profpatsch: Wah, my code is pretty wrong type-wise now that I look at it
05:52:47 <cocreature> quchen: GHC doesn’t know about whole projects either :) you want cabal/stack
05:52:48 <quchen> It used to be a longer Maybe-do block :-)
05:53:13 <Profpatsch> quchen: Ah, that’s Maybe. :)
05:53:24 <Profpatsch> I thought it might be the Monad instance of Map or something
05:53:40 <quchen> Naah
05:54:44 <c_wraith> Profpatsch: Map would have a weird monad instance..  What would return do?
05:55:26 <Profpatsch> c_wraith: No idea, I thought when I skimmed the instances before I saw one.
05:55:30 <_sras_> quchen:  True :) But I was looking for something that can work with vim...
05:55:52 <Profpatsch> But it’s only Functor, Foldable & Traversable, what you’d expect.
05:55:52 <_sras_> and populate a window of with errors
05:56:00 <lpaste> quchen revised “No title”: “Profpatsch Map” at http://lpaste.net/354729
05:56:48 <quchen> Meh, and adjust (const v) = insert v
05:56:58 <quchen> Anyway, you get the idea. :-)
05:57:06 <Profpatsch> Yes, thanks
05:59:07 <_sras_> So I will rephrase the question, is there a vim plugin that can take the output of stack build or cabal, and populate a qucikfix window in vim?
06:12:03 <LAZAR> Whats the easiest way to print the elements of a list in one line? Like [13,16,225,14,120,10] -> 13 16 225 14 120 10
06:12:15 <c_wraith> LAZAR: mapM_ print
06:12:20 <lpaste> quchen revised “Profpatsch Map”: “Profpatsch Map” at http://lpaste.net/354729
06:12:27 <OnkelTem> Guys, when do I add dependencies to library section and to executable section?
06:12:34 <c_wraith> LAZAR: oh, wait, you said *one* line
06:12:35 <OnkelTem> in the .cabal file
06:12:51 <LAZAR> c_wraith: yeah, mapM_ would get me n lines
06:13:02 <c_wraith> LAZAR: in that case, I'd go like...  pustStrLn . unwords . map show
06:13:50 <LAZAR> c_wraith: well unwords just works on strings?
06:13:59 <quchen> :t T.unwords
06:14:00 <lambdabot> error:
06:14:00 <lambdabot>     Not in scope: ‘T.unwords’
06:14:00 <lambdabot>     No module named ‘T’ is imported.
06:14:05 <quchen> :-(
06:14:08 <c_wraith> LAZAR: that's why the "map show" part is there
06:14:09 <quchen> Text has unwords as well
06:15:25 <Iceland_jack> LAZAR: for_ ... print
06:15:36 <Iceland_jack> looks nicer (from Data.Foldable)
06:15:38 <c_wraith> LAZAR: by the time you're talking about "on a single line" you're talking about a textual representation anyway.  So yeah, you have to be converting things to a textual form.
06:15:44 <c_wraith> Iceland_jack: but it solves the wrong problem :)
06:15:51 <Iceland_jack> Correctly!
06:16:46 <c_wraith> can I use that excuse at work?  I know I was supposed to be implementing ADFS support, but I would have done that wrong so I wrote Hello World correctly!
06:17:24 <Iceland_jack> Yes you may, first step is not reading the problem description
06:17:27 <Iceland_jack> and you're well on your way
06:20:16 <OnkelTem> How to search for a package using stack?
06:20:42 <LAZAR> Someone wants to take a loot at my function? I'm trying to zip with multiply two lists, [1,2,3] * []
06:21:13 <LAZAR> [1,2,3] * [2,3,4] = 2 6 12. link is here http://lpaste.net/354732
06:22:04 <Iceland_jack> LAZAR: Can you use existing funtions like zipWith?
06:23:11 <LAZAR> Iceland_jack: Yeah, the problem is more like learning to wrap and unwrap stuff from files to string to integers and back
06:23:26 <sullyj3> So, the only way I know of repeating an IO () n times is `mapM_ [1..n]` and recursion with an explicit counter argument. Not really a fan of the first since it builds an unnecessary list, the second feels kinda ugly. Is there a nicer way? What I really want is some f :: Int -> IO () -> IO (), but hoogle didn't turn up anything like that.
06:23:38 <Iceland_jack> sullyj3: replicateM_
06:23:40 <sullyj3> ways I know*
06:23:44 <sullyj3> oohh
06:23:57 <Iceland_jack> :t replicateM_ :: Int -> IO a -> IO ()
06:23:59 <lambdabot> Int -> IO a -> IO ()
06:24:26 <Iceland_jack> :t replicateM :: Int -> [a] -> [[a]]
06:24:28 <sullyj3> Iceland_jack: Thankyou!
06:24:28 <lambdabot> Int -> [a] -> [[a]]
06:24:31 <sproingie> mapM_ shouldn't build up a list, it just returns unit
06:24:34 <Iceland_jack> > replicateM 3 [0,1]
06:24:36 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
06:24:39 <sproingie> that's the difference between mapM and mapM_
06:24:49 <Iceland_jack> you're welcome sullyj3
06:24:54 <sullyj3> sproingie: I know, I meant i don't like having the [1..n]
06:25:08 <sproingie> oh _that_ list :)
06:25:11 <sullyj3> sorry that was ambiguous
06:28:02 <muzzle> when using HaRe, how do i get it to directly apply a refactoring instead of creating .refactored.hs files?
06:28:47 <alanz> muzzle: What ide are you using?
06:28:50 <muzzle> emacs
06:29:08 <muzzle> with intero 
06:29:27 <alanz> There was a post around that recently, hold on
06:32:30 <alanz> muzzle: Here is a spacemacs hint on it: https://github.com/syl20bnr/spacemacs/issues/8664
06:32:44 <alanz> not sure how to do it with straight emacs.
06:33:09 <alanz> Otherwise the elisp shipped with HaRe should do the job, and not interfere
06:33:43 <alanz> Future support will be via https://github.com/emacs-lsp/lsp-mode 
06:33:55 <alanz> but it is still work in progress
06:35:24 <muzzle> alanz: thanks, I will look into it
06:40:00 <the_2nd> Im currently using scotty. It seems like it will only parse one parameter from an array.
06:40:10 <the_2nd> e.g. xs <- param "xs[]"
06:40:17 <the_2nd> will only contain the first x in xs
06:40:24 <muzzle> alanz: I got it to work. This is great, now I just have to get rid of the backup files. Thank you!
06:40:43 <alanz> muzzle: great. PRs gladly accepted
06:43:50 <pacak> Cale: It's not a problem with HashMap, it's a problem with that program.
06:44:41 <pacak> Cale: https://github.com/tibbe/unordered-containers/issues/147#issuecomment-295274825
06:51:50 <Cale> pacak: Ah, but wait, why is regroup run with a different number of elements each time?
06:52:37 <Cale> pacak: Also, if Data.HashMap.toList produces the elements in a randomized order, it shouldn't be a pure function.
06:53:29 <Cale> pacak: I'm not sure that's the problem, because if it were, the problem would appear in single-threaded usage, which it doesn't.
07:04:45 <Gurkenglas> When running "stack script.hs" recommends "stack solver", what do I do?
07:05:51 <quchen> Gurkenglas: Isn’t it »stack script script.hs«?
07:06:10 <Gurkenglas> nope
07:06:17 <ph88_> Can someone help me with conduit? i would like to use the conduit Producer and give it to the parser, then put numbers in a vector, run calculations on them and write the results back to a file  .. not sure how i can tie the code together, i have this at the moment  https://bpaste.net/show/efca3e4d440d
07:06:37 <quchen> Gurkenglas: stack runhaskell?
07:06:57 <Gurkenglas> just stack script.hs
07:07:41 <Gurkenglas> (using runhaskell complains about the same missing modules, but doesn't recommend stack solver)
07:07:51 <quchen> That stack invocation doesn’t look right.
07:08:00 <sproingie> more usually invoked as #!/path/to/stack.  usually there's a magic comment right below with the dependencies on it
07:08:00 <quchen> Maybe it just recommends stack solver because solver is somewhat close to script?
07:08:17 <quchen> sproingie: Ah, right, that’s true
07:09:13 <Gurkenglas> quchen, "COMMAND|FILE" in "stack"'s "Usage:"
07:09:15 <sproingie> -- stack runghc --package foo-bar
07:09:22 <sproingie> comment should look something like that
07:09:31 <quchen> Example script: Gurkenglas: For example: https://github.com/quchen/dotfiles/blob/master/bin/util/PgpPass.hs
07:10:11 <quchen> λ. PgpPass.hs ---> island conformist aztec provincial python clergyman chairlift gossamer
07:10:13 <Gurkenglas> Mine has pretty much that except for -hide-all-packages
07:10:18 <quchen> Not that that’s a particularly good password generator ;-)
07:11:10 <Gurkenglas> (mine starts with http://lpaste.net/3427771681920253952 )
07:11:36 <sproingie> quchen: beats "letmein1"
07:12:06 <quchen> In terms of entropy the two might be on par, apart from the security by obscurity thing.
07:12:18 <ph88_> i don't understand with conduit how i can put something between a Producer and a Consumer, especially with type  (AttoparsecInput a, Monad m) => Parser a b -> Consumer a m (Either ParseError b)
07:12:26 <sproingie> i don't actually know any of my passwords except for amazon, google, and lastpass
07:13:03 <sproingie> quchen: yeah it's all dictionary words, but think of it as a several-thousand char alphabet
07:13:07 <quchen> I know the one for my self-written password manager script that’s less crappy than all password managers I’ve used so far ;(
07:13:32 <sproingie> using only dictionary words you know is not great, most people have a working vocabulary of only a couple thousand words
07:13:39 <syx> hi
07:13:57 <ph88_> hi syx
07:14:06 <quchen> sproingie: The PGP wordlist is somewhat standard, which is kind of the point of that password. You can easily correct and detect typos.
07:14:12 <quchen> Downside is that it’s very long.
07:14:27 <quchen> But each word is technically worth 8 bit.
07:14:28 <sproingie> i'd figure PGP uses it for fingerprints, right?
07:14:34 <quchen> Probably
07:14:43 <sproingie> in which case you want to flatten it down some
07:15:36 <quchen> Hm?
07:15:43 <quchen> Flatten?
07:16:13 <sproingie> as in deliberately reduce the entropy, since it's aimed at being recognized quickly
07:16:37 <sproingie> generating grammatical sentences would be even better.  probably really amusing too.
07:17:00 <quchen> But then the randomness is pretty hard to judge.
07:17:16 <sproingie> 9. 9. 9. 9. :)
07:17:24 <quchen> I do have a generator running on the Bible and Faust 1 though. (I couldn’t fit HoTT in, sadly)
07:18:16 <sproingie> best text generator i saw was seeded with the works of ayn rand and kal marx
07:18:22 <ystael> sproingie: D:
07:18:22 <sproingie> *karl
07:19:36 <ph88_> can anyone explain =$= in conduit ?
07:20:35 <dolio> Cale: Arguably, it's still pure, because the order you get is determined by exactly how you built the map, not on what order things are evaluated. It's still violating the quotient most people would expect, though.
07:21:22 <Cale> dolio: Well, it *does* look like it's dependent on the order in which things got evaluated
07:21:50 <dolio> Does it?
07:22:00 <Cale> dolio: The very same program which had no randomisation or input effects and which did nothing but compute a Double, would produce different Double results each time you ran it.
07:22:45 <Cale> (and this doesn't happen with -N1 only with actual parallelism available)
07:24:20 <ph88_> i found an example of using conduit with attoparsec and i try to do the same but i get a type error  https://bpaste.net/show/a65f56373bcb
07:25:14 <Cale> ph88_: I like to think of your question there as being a general yes-or-no sort of question, rather than a request for explanation :)
07:25:37 <Cale> "can *anyone* explain =$= in conduit?"
07:26:20 <Cale> https://hackage.haskell.org/package/conduit-1.2.10/docs/src/Data-Conduit-Internal-Conduit.html#%3D%24%3D -- very implementation, wow
07:26:44 <ph88_> eh i just mean how to use it
07:26:49 <Cale> I know
07:26:58 <ph88_> not to explain the internals of that function you linked to source of
07:27:32 <ph88_> i'm just trying to recreate what i see from the example code
07:27:52 <ph88_> i have a feeling what =?= is used for but clearly i'm missing stuff (see error in paste)
07:28:23 <sproingie> https://github.com/snoyberg/conduit#legacy-syntax
07:29:01 <Cale> ph88_: What's the type of conduitParserEither?
07:29:11 <Gurkenglas__> http://hackage.haskell.org/package/shpider doesn't build with stack. What should I use instead?
07:29:14 <Cale> You have a type signature there for sinkParserEither...
07:29:21 <sirius[m]> ph88_: `conduitParserEither' yields values of type `Either ParseError b' but your sink accepts only `ByteString', hence the type error
07:29:34 <ph88_> conduitParserEither :: (Monad m, AttoparsecInput a) => Parser a b -> Conduit a m (Either ParseError (PositionRange, b))
07:30:24 <Cale> Ah, and snk is a  Consumer BS.ByteString (ResourceT IO) ()
07:30:44 <glguy> Gurkenglas__: instead of stack?
07:31:01 <Gurkenglas__> Instead of shpider.
07:31:03 <ph88_> src and snk are of the right types .. because it type check when i comment line 10, and then use snk instead of snk2
07:31:46 <Cale> ph88_: So that's the issue, you need to do something with this Either ParseError (PositionRange, [Double]) to turn it into a ByteString if you want to send it on to snk
07:32:28 <glguy> Gurkenglas__: what's it doing that stack can't handle?
07:33:34 <ph88_> sproingie, ok good to know, i replaced all operators with .| now
07:34:09 <Gurkenglas__> glguy: http://lpaste.net/2035273401144180736
07:34:19 <ph88_> Cale, how can i pattern match on that either ? at the moment it seems to be wrapped in a ConduitM
07:35:02 <ph88_> ConduitM (Either foo bar) c (ResourceT IO) ()
07:35:08 <Cale> ph88_: Well, yeah, it's a whole stream of Either ParseError ... values.
07:35:40 <butterthebuddha> Hey peeps; could someone help me out with exercise 6 -> https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
07:36:12 <ph88_> if there is a ParseError i want to send something to stderr, and when i have a vale i want to make a bytestring of it
07:36:17 <ph88_> value
07:36:44 <ph88_> how can i write a  "stream inspector" function for conduit that can direct these actions ?
07:37:43 <lyxia> butterthebuddha: what help do you need
07:37:56 <butterthebuddha> I'm not sure how to get started really
07:38:28 <ph88_> oh i done some of cis194 too :P
07:39:24 <ph88_> butterthebuddha, maybe first figure out what are the actual moves you can make on the pegs and why it require 129 moves
07:40:54 <c_wraith> seems more likely to require 127 moves...
07:40:54 <ph88_> Cale, i think i need to do something with await and yield at least
07:41:46 <butterthebuddha> ph88_: Haskell as generators??
07:42:01 <c_wraith> Oh, the extended variant takes 129.  I see
07:42:30 <ph88_> butterthebuddha, i'm reading this https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview#primitives
07:44:04 <butterthebuddha> Ah
07:46:36 <Cale> ph88_: Yeah, possibly something like  awaitForever $ \x -> do case x of Left e -> hPrint stderr e; Right v -> yield v
07:48:09 <Cale> ph88_: :: (Show e, MonadIO m) => Conduit (Either e o) m o
07:48:13 <ph88_> Cale, what monad is that ? don't i need liftIO for stderr ?
07:48:22 <ph88_> oh
07:48:24 <Cale> oh, sorry, yes, you do
07:48:31 <Cale> I just wrote that carelessly
07:48:44 <ph88_> i will try it
07:49:59 <Cale> That'll get you to the point of needing to deal with lists of Double values
07:50:19 <Cale> So maybe instead of yield v there, you just want to yield some ByteString
07:50:41 <ph88_> yes :D
07:51:00 <Cale> e.g. yield . T.encodeUtf8 . BS.pack . show $ v
07:51:06 <Cale> oops
07:51:23 <Cale> e.g. yield . T.encodeUtf8 . T.pack . show $ v
07:52:03 <Cale> (where you have import qualified Data.Text as T; import qualified Data.Text.Encoding as T)
07:52:47 <ph88_> Cale, oh actually .. those [Double] i want that to become [Vector Double]  .. so as more [Double] come in  [1.0, 2.0] and then [3.0, 4.0]   i want to turn that into  [ Vector {1.0, 3,0}, Vector {2.0, 4,0} ]    where {} is just something i came up with in the moment to describe a vector of doubles
07:53:39 <Cale> ph88_: It always takes me twice as long to figure out how to do anything with Conduit as it does with Pipes, it's like the whole library is just a little bit off. :)
07:54:09 <ph88_> hhmm i thought conduit was the go-to library
07:54:31 <c_wraith> Do you really want to accumulate into a big vector?  That is kind of the worst way to use a streaming library
07:55:14 <ph88_> i need to have a sliding window over those numbers
07:55:23 <Cale> c_wraith: Well, we're getting chunks of type [Double], so I assume that we just want each one to separately become a Vector?
07:55:38 <Cale> or... I dunno
07:55:52 <Cale> Oh, maybe the chunks are too large and you want to yield multiple times for each one?
07:55:53 <ph88_> https://bpaste.net/show/a65f56373bcb  on line 35 to 38
07:56:03 <ph88_> i need to put all the numbers of 1 column into a big vector
07:56:49 <ph88_> this is just 4 lines but a real file can be hundreds of MB's
07:58:06 <Cale> oh, of one *column*?
07:58:08 <Cale> hmm
07:58:24 <ph88_> i don't need the entire vector to already start processing the first numbers
07:59:02 <Cale> So for that sample_data.txt, what should the output look like?
07:59:24 <ph88_> that's the input data ... but the output data should be much smaller
07:59:33 <Cale> I realise that
07:59:38 <ph88_> like 1 million lines to 250 lines or so
07:59:47 <Gurkenglas__> How should I construct the POST request for a form?
07:59:53 <Cale> I just don't know what output you want
08:00:48 <ph88_> Cale, not sure how to answer that question .. it should be a file with textual format just as the input file .. and to get those new numbers i have now two functions that process the data after each other
08:01:31 <Cale> Gurkenglas_: http-conduit can do it
08:01:52 <ph88_> the first function does some kind of interpolation (already reducing the amount of numbers to 250) .. the second function does some extra processing to get the final values
08:02:40 <Cale> Gurkenglas_: there's an example here of setting the method on a request: http://hackage.haskell.org/package/http-conduit-2.2.3.1/docs/Network-HTTP-Conduit.html#t:Request
08:03:10 <Cale> Gurkenglas_: and if you scroll up, there's an example at the top which shows how to actually make the request
08:03:18 <ph88_> Cale, this is the first function which already reduces the numbers significantly .. i haven't quite figured out how it works yet, but i'm trying to rewrite this software   https://bpaste.net/show/51f01965c8c0
08:04:01 <Cale> ph88_: ah, okay
08:04:56 <ph88_> Cale, the idea was to put a chunk of numbers into a vector .. then do some calculation .. then process the next chunk
08:05:53 <Cale> ph88_: Presumably each column here has a distinct meaning?
08:05:58 <ph88_> yes
08:06:06 <Cale> ph88_: You might want to define some record type and parse to that first.
08:06:21 <Cale> Rather than to lists of Doubles
08:06:34 <Gurkenglas__> http://hackage.haskell.org/package/http-client-0.5.6.1/docs/Network-HTTP-Client-MultipartFormData.html#v:partLBS should this be ByteString, when I'm putting text into those form fields?
08:06:34 <ph88_> the amount of columns can be variable and the user should select which column he wants to process as an option to the program
08:06:46 <Cale> ahhh
08:06:47 <Cale> okay
08:06:59 <Cale> so you're basically discarding the rest?
08:07:12 <Cale> (perhaps you want to do *that*?)
08:07:21 <ph88_> i think it's faster to process [Vector Double] than Vector [Double]  
08:07:31 <ph88_> yes other columns can be discarded
08:07:39 <ph88_> might need 1 or 2 columns out of 3
08:07:51 <Cale> ah, fair enough
08:08:00 <ph88_> i figure when i have  [Vector Double] it doesn't matter that the list only hold 1 vector
08:08:08 <Cale> Well, you won't have a list
08:08:19 <ph88_> i thought a list of columns ..
08:08:33 <ph88_> where the vector is the column itself ..
08:08:44 <Cale> uhh, so you're transposing the entire input?
08:08:58 <ph88_> i thought in my conduit inspector function i can keep track of how many numbers i put in the vector already and when i have enough do some calculation
08:09:27 <ph88_> what's that transposing ? rotating ?  no no columns stay columns
08:09:30 <Cale> Well, you're not going to be "putting them in" -- Vector is immutable
08:10:03 <ph88_> need to make a new immutable vector or use mutable vector or use some other structure
08:10:47 <ph88_> i just need X numbers from the columns to start doing some calculations ... then those numbers can be discarded and i can start reading the next chunk
08:11:01 <Gurkenglas__> When stack script.hs is at 11/21, does that already mean it compiles?
08:11:18 <Cale> ph88_: I'm sure there's some way to do that with conduit...
08:11:20 <Gurkenglas> (as in, my code has done nuthin wrong)
08:11:52 <ph88_> Cale, that's why i was using conduit here (it came recommended) .. but ok you can probably tell it's my first time :P
08:12:03 <ph88_> Gurkenglas, what's that 11/21 ?
08:12:37 <Cale> ph88_: Conduit is just so much uglier than pipes...
08:12:55 <ph88_> :'(
08:13:02 <ph88_> i can throw out conduit no problem
08:13:07 <ph88_> i have nearly nothing in my code
08:13:09 <Cale> okay, let's switch
08:14:44 <ph88_> i'm looking at the C code more closely .. i thought i needed to buffer (in the vector) an amount of samples determined by the loop on line 73 to 83 https://bpaste.net/show/51f01965c8c0  but now i think i don't even need that !   all i need is to access the current sample org_sample_nr and the next sample  org_sample_nr + 1
08:15:27 <Cale> ph88_: cool... actually, it might be easy enough to do that with conduit, it's just slightly uglier because of the type of await
08:15:46 <ph88_> any way .. i think i can tweak the calculation part later .. first i just like to make some simple functions that do dummy calculations and see how to glue the code together
08:16:09 <Cale> You can do two awaits
08:16:21 <Cale> and then a yield
08:16:34 <Cale> (calculating something with the two values you obtained)
08:16:48 <ph88_> yeah good idea !
08:16:55 <Cale> Well, if you need a sliding window, that's not right
08:17:08 <c_wraith> yeah, there's no requirement that the numbers of yield and await need to have anything to do with each other.
08:17:09 <Cale> that'll work with chunks of two
08:17:16 <ph88_> well my sliding window will be of size 2 :P
08:17:34 <Cale> Okay, so for the sliding window, you'll want to use recursion
08:17:49 <ph88_> i saw it here https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview#primitives
08:18:02 <ph88_> it seems what you suggest: 2x await  then recursion
08:18:15 <Cale> Do an await at the start, and pass its result to a function which does the second await, yields a result, and then applies itself to the value it just awaited
08:18:40 <Cale> (i.e. you need one await before the recursion begins)
08:18:55 <ph88_> maybe they solved that with leftover ?
08:19:11 <ph88_> leftover i2 to put the value back
08:20:32 <Cale> ah, yes, that might also be a good way to go
08:21:08 <ph88_> thank you Cale you give me some good ideas, i will study the code for a bit and report back later ok ?
08:21:19 <Cale> sure
08:29:07 <fresheyeball> question
08:29:15 <fresheyeball> do ADTs that are uber simple have a name?
08:29:22 <fresheyeball> let me give some examples
08:29:30 <fresheyeball> data Foo = Foo | Bar | Baz
08:29:46 <fresheyeball> so to be the variety of ADT I'm interested in 
08:29:57 <fresheyeball> the type must be of kind *
08:30:19 <fresheyeball> and all its constructors must not be arrows
08:30:46 <fresheyeball> for these ADTs Ord, Bounded, Enum, Eq can all be derived
08:31:36 <zomg> iirc types which are basically X | Y | Z are known as union types
08:33:14 <paolino> hi, I don't understand the "Illegal type synonym family application in instance"
08:33:50 <Cale> paolino: Don't use synonyms in instance heads
08:34:00 <Cale> Just write the instances for the actual underlying types
08:34:02 <glguy> paolino: type synonyms don't create new, distinct types. The instances go on types introduced by data and newtype
08:34:17 <paolino> is it the same as TypeSynonymInstances ?
08:34:51 <paolino> Cale, but I cannot do it now
08:35:05 <Cale> Why not?
08:35:08 <fresheyeball> zomg: wouldn't this also be a union?
08:35:16 <fresheyeball> data Foo = Bar String | Baz 
08:35:19 <zomg> Yes
08:35:20 <glguy> paolino: You can't use type families when creating instances
08:35:22 <MitchellSalad> Cale: I don't think that's the solution to paolino's problem
08:35:32 <fresheyeball> I'm saying the constructors must not be arrows as well
08:35:39 <glguy> paolino: Those, like normal type synonyms, do not create new types that can have instances
08:35:41 <Cale> paolino: Just work out which types the instances evaluate to, and then write the instances for those types.
08:35:52 <fresheyeball> in that last example Bar :: String -> Foo
08:36:09 <Cale> If you can't do that, then what you're trying to do probably doesn't make sense.
08:36:09 <fresheyeball> is there a name for this? like a flat union?
08:36:39 <fresheyeball> it's like the staight of equivelant of an imperative Enumerable
08:36:42 <paolino> Cale I don't know the implementation but I ask for it to be an instance to use it in another
08:37:09 <paolino> if I switch to data family no complains
08:37:11 <Cale> paolino: Let's see which instance you're trying to write?
08:37:37 <Cale> paolino: Note that for example, your type family might send every type to Int
08:37:39 <zomg> fresheyeball: unfortunately my type-fu doesn't quite reach that far :)
08:38:32 <lpaste> paolino pasted “type families in head” at http://lpaste.net/354735
08:39:21 <Cale> and Zone here is a type family?
08:39:37 <paolino> yes
08:39:43 <Cale> So what if Zone a = Int?
08:39:51 <Cale> let's just suppose
08:40:17 <Cale> Is Location b a also?
08:40:37 <paolino> also what ?
08:40:40 <paolino> a tf ?
08:40:41 <Cale> a type family
08:40:42 <Cale> yeah
08:40:45 <paolino> no
08:40:55 <paolino> it's a GADT
08:41:06 <Cale> Okay
08:41:07 <glguy> paolino: That's right, type families can't have new instances, but data families can
08:41:08 <MitchellSalad> Cale: I don't think that really illustrates the issue. So what if 'Zone a' is an Int? You can write type families for Ints. The problem is that 'Zone a' changes depending on what 'a' is, so what instance are you actually writing?
08:41:16 <MitchellSalad> type classes* for Ints
08:41:32 <Cale> MitchellSalad: Right, my point was going to be that it's hard to determine 'a'
08:42:08 <glguy> The problem is that type families "go away", so there's nothing to attach an instance to
08:42:40 <Cale> Type families might not be injective: you can have Zone a = Zone b without a = b
08:43:06 <MitchellSalad> I wonder if GHC would let you write such an instance if Zone was injective though?
08:43:23 <Cale> It will -- in order to make sure it's injective, you can use a data family instead.
08:43:26 <glguy> We have injective type families in GHC 8, but it wouldn't make sense to provide an instance for one
08:43:33 <Cale> Oh
08:43:44 <MitchellSalad> yeah I meant an injective type family, not a data family
08:44:00 <glguy> The problem isn't injectivity, it's that they're aliases for other types.
08:44:14 <MitchellSalad> glguy: hm? that's not a problem
08:44:16 <glguy> It's like pattern matching on an arbitrary function instead of a value constructor
08:44:17 <Cale> ah, I wasn't aware those were a thing -- I suppose it might make sense
08:45:06 <Cale> But it would mean that when doing instance resolution, GHC would have to invert all the possible injective type families to see if an instance matched, which would suck.
08:45:20 <glguy> Cale: I think they're restricted to closed type families
08:46:07 <Cale> also, it gets quite hard to tell if instances are overlapping
08:46:08 <paolino> I'm confused now
08:46:34 <paolino> what if I put a constraint on Zone a in a function
08:46:36 <Cale> (you have to intersect the ranges of your injective type families and make sure there's no overlap)
08:47:22 <paolino> it compiles, but you said I cannot write an instance for it
08:47:27 <glguy> paolino: If you have a 'type family Zone a', and a function 'stuff :: C (Zone a) => a -> a'
08:47:36 <glguy> then you need an instance on whatever type Zone a evaluates to
08:47:48 <glguy> paolino: so suppose type instance Zone Int = Bool
08:47:56 <MitchellSalad> ghc won't allow this instance even if Zone is injective, btw. I just tried it
08:48:02 <paolino> that's not in the same position as the constraint in an instance
08:48:24 <Cale> MitchellSalad: Yeah, that makes sense, the things I was proposing would need to happen are onerous and silly.
08:49:09 <glguy> It doesn't matter if the type family is injective, you need to konw what it evaluates to so you can attach the instance to that type
08:49:36 <mjhoy> can i rexport a module under a qualified name? e.g. reexport Data.Text qualified as T ?
08:49:41 <glguy> no
08:50:07 <Cale> I suppose if it's for closed injective type families, you could have it unfold *all* the possible types
08:50:28 <Cale> and just be as if you wrote the instances for each of them
08:50:34 <ph88_> fresheyeball, looks more like an enum than a union to me
08:51:04 <Cale> That could be reasonable, though it might result in a very large amount of code being generated.
08:51:51 <dolio> An infinite amount of code.
08:52:10 <Cale> dolio: For closed type families?
08:52:16 <dolio> Sure.
08:52:39 <Cale> I just mean, you substitute in each of the finitely many instances in all possible ways
08:53:16 <MitchellSalad> glguy: ah, you're right! of course
08:53:48 <fresheyeball> ph88_: interesting
08:53:58 <paolino> with data family the types are already known so it's possible to "attach" ?
08:54:06 <fresheyeball> I should play around with what is Enum derivable and what is not
08:54:21 <glguy> Right, data families are like data and newtype, they don't evaluate away. They are distinct types from all other types
08:54:40 <paolino> well Zone :: * -> * is known
08:55:06 <ph88_> hhmm i just found out that  MonadIO m => m   is the same as   IO
08:56:12 <Cale> paolino: Suppose I want to define a function f: R -> R. Is it okay if I say something like for all x in R, f (sin x) = x^2?
08:56:40 <Cale> Even if I want to define f: [-1,1] -> R, this has a problem
08:57:13 <paolino> I'm ok with injectiveness
08:57:13 <Cale> In that there are many values of x which will give any given value sin x
08:57:40 <Cale> So, okay, think about the job that the instance resolver has to do
08:57:58 <paolino> I think I understand when I get the NB, tf might not be injective
08:58:17 <Cale> It sees something like include x y and it might know the concrete types of x and y
08:58:19 <paolino> but yeah, I don't now the machinery for typeclasses
08:58:25 <ph88_> what's the difference between an Int64 and Word64 ?
08:58:26 <Cale> perhaps x :: Int and y :: String
08:58:58 <Cale> paolino: and then it has to look at your instance for  Include (Zone a) (Location b a) and ask "does this match?"
08:59:35 <Cale> paolino: It might! But it might do so in more than one possible way. Perhaps Zone a is Int for many different types.
09:00:09 <Cale> I guess we'd need y :: Location something something
09:00:37 <Cale> paolino: Actually you might be able to get the effect you want
09:00:42 <Cale> with a type equality constraint
09:00:44 <paolino> oh b is another kind
09:00:50 <Cale> because of this Location bit
09:01:28 <Cale> What if we made it  instance (Include (Zone a) (Zone a), Include (Zone a) (Place a), c ~ Zone a) => Include c (Location b a) where
09:03:10 <paolino> goes undecidable
09:03:26 <ph88_> why does this parser take a parser ?  https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:signed
09:03:43 <Gurkenglas> What library should I use to fetch https pages?
09:04:12 <Cale> paolino: well, that's okay
09:04:18 <Cale> turn on UndecidableInstances
09:04:26 <byorgey> ph88_: I think the idea is that the argument is a parser for some kind of (unsigned) number
09:04:45 <Cale> paolino: What that'll do then is commit to the instance immediately
09:04:49 <byorgey> ph88_: so you could say 'signed integer' or 'signed float' etc. (assuming 'integer' and 'float' are parsers to parse unsigned integers and floats)
09:04:59 <ph88_> ah ok
09:05:12 <Cale> paolino: as soon as it sees that the second argument to Include is of the form Location b a
09:05:14 <paolino> Cale it compiless
09:05:29 <Cale> paolino: The part before the => is always ignored by the instance resolver when trying to decide which instance matches
09:05:44 <Cale> paolino: So, it can say "okay, we're committing to this one"
09:05:55 <Cale> and then after that, it will check the stuff before the =>
09:06:22 <Cale> in particular, it will insist that c is Zone a, and give you an error if it's not.
09:07:46 <paolino> ah
09:08:32 <ph88_> if i want to keep track of some state can i just prefix the type signature with StateT ?
09:08:51 * paolino is asked to identify by ghc after last modification
09:09:53 * paolino admitted this was Cale
09:09:56 <Cale> paolino: and yeah, the instance is undecidable now -- that just means that the usual property which guarantees that the instance resolver terminates has been violated... depending on what other instances there are and how you define these type families, it might be possible to make the compiler go into an infinite loop
09:11:14 <Cale> Rather, it's not that the instance on its own is undecidable, but that it has a property which makes instance resolution in general potentially undecidable.
09:12:11 <paolino> Never got the "instance head bigger" proglem
09:13:53 <paolino> I suppose I must take some time to understand typeclasses more
09:15:05 <OnkelTem> How to search for a package using stack?
09:15:54 <OnkelTem> if I need for example "snap" packages, how can I a) see what versions are available b) install packages c) add dependecies to .cabal file?
09:16:12 <paolino> Thanks Cale, glguy, MitchellSalad for this 
09:16:50 <Cale> OnkelTem: Start by adding the dependency to your .cabal file, and then it will install an appropriate version of snap for you
09:17:13 <Cale> OnkelTem: It won't edit the .cabal for you, as far as I'm aware
09:17:31 <Cale> But it will examine it when figuring out which dependencies to install in order to build the package
09:18:04 <OnkelTem> Cale: where should I place my deps - in library part or executable?
09:18:41 <glguy> OnkelTem: Everywhere you're using them
09:18:48 <Cale> Whatever part they're dependencies of
09:18:51 <glguy> OnkelTem: If your library has dependencies, then those go into the lib section
09:18:58 <glguy> if your executable has them, same story
09:19:07 <glguy> You don't need to list your library's dependencies in your executable
09:19:14 <glguy> (but you do need to depend on your library)
09:19:17 <OnkelTem> I don't know what is called library and what is not :) Would you point me to some reading?
09:19:30 <OnkelTem> I just try to start
09:19:41 <OnkelTem> for the 3rd damned day
09:19:56 <Cale> OnkelTem: It might be confusing because the initial project that stack makes for you defines both a library and an executable
09:20:13 <OnkelTem> Cale: that's exactly what I see yeah :)
09:20:17 <Cale> OnkelTem: If your project is just one or the other, you might want to get rid of the other section in your .cabal file
09:21:03 <sm> OnkelTem: for a, go to https://www.stackage.org/package/snap, or https://www.stackage.org/lts (eg) and search in page for "snap"
09:23:00 <abhiroop> I was looking at the Data.Graph library
09:23:02 <abhiroop> @hoogle graphFromEdges'
09:23:02 <lambdabot> Data.Graph graphFromEdges' :: Ord key => [(node, key, [key])] -> (Graph, Vertex -> (node, key, [key]))
09:23:16 <abhiroop> What does the node typevariable here stand for?
09:23:46 <abhiroop> I have type Vertex = Text    as the key
09:23:59 <abhiroop> I am just wondering about the node type variable
09:24:34 <Cale> abhiroop: It can be any type at all
09:25:24 <Cale> abhiroop: Some type with which the vertices are going to be labelled
09:26:05 <abhiroop> So I am just interested in the Graph type here
09:26:21 <abhiroop> SO from the docs type Graph = Table [Vertex]
09:26:28 <sm> OnkelTem: for reading: https://www.haskell.org/cabal/users-guide/developing-packages.html
09:26:47 <abhiroop> So do i get Table [Vertex] as the result here?
09:26:57 <OnkelTem> sm: thanks!
09:27:02 <Cale> abhiroop: yeah
09:27:03 <abhiroop> where in my case type Vertex = Text
09:27:08 <abhiroop> Okay great!
09:27:36 <Cale> abhiroop: btw, Data.Graph is kinda terrible under a lot of circumstances -- depending on how you're using the graphs
09:27:49 <abhiroop> i have a list of dependencies
09:27:56 <abhiroop> I wanted a topological sort on them
09:28:16 <abhiroop> The Data.Graph library has an in built function for that
09:28:19 <Cale> I guess if all you're going to do is topSort and be done with it, that's fine
09:28:29 <Cale> and don't need to edit the graph much
09:28:34 <abhiroop> Yup mostly that
09:29:00 <Cale> So, you can put information about what the dependencies are in those 'node' bits.
09:29:08 <ph88_> is there maybe a nicer (shorter) way to write function for record ?  https://bpaste.net/show/e32f0573fca8
09:29:20 <Cale> and the function that it gives you will recover that information from the Vertex
09:30:24 <Cale> ph88_: You *can* write  toggle (StreamState b) = StreamState (not b)
09:30:43 <Cale> ph88_: But then that definition needs to be maintained every time you add a new field
09:31:02 <Cale> and it starts becoming unclear what such a definition does, if there are many fields
09:31:07 <ph88_> ya ok .. so no joy
09:31:13 <Cale> You could also use lenses
09:31:28 <Cale> toggle = over foundStartOfMeasurement not
09:33:13 <ph88_> can i also pattern match on a record ?
09:33:18 <Cale> yes
09:34:09 <Cale> toggle state@StreamState { _foundStartOfMeasurement = b } = state { _foundStartOfMeasurement = not b }
09:34:21 <Cale> probably a little worse :P
09:38:39 <ph88_> Cale, when i try to pattern match     {_foundStartOfMeasurement = started} <- lift get    i get  parse error on input ‘{’
09:39:36 <Cale> You left out the data constructor
09:39:38 <cocreature> ph88_: you need the constructor name
09:39:45 <ph88_> oh
09:40:26 <Cale> You know, that would be another design path
09:41:06 <Cale> Decide that instead of having record types with overlapping field names, we'll just do away with the data constructors for record types
09:41:48 <Cale> and determine which type is meant by the fields present.
09:41:54 <Cale> Doesn't quite work out so nicely
09:41:59 <Cale> But almost :)
09:42:30 <Cale> (then again, I hate all the overlapping field shenanigans too)
09:42:42 <Cale> (I might actually hate this idea slightly less)
09:50:43 <ph88_> No instance for (Fractional Int64) arising from the literal ‘0.001’   In the expression: i2 - i1 > 0.001   why do i get this error ?
09:51:03 <ph88_> if i2 and i1 are Int64 then why does it want Fractional ?
09:51:41 <geekosaur> because 0.001 is Fractional
09:51:58 <geekosaur> what Int64 value is represented by 0.001?
09:52:05 <geekosaur> :t (-)
09:52:06 <lambdabot> Num a => a -> a -> a
09:53:02 <Cale> :t (>)
09:53:04 <lambdabot> Ord a => a -> a -> Bool
09:54:48 <geekosaur> (perhaps more to the point, when will any two Int64 values differ by an amount that is not Integral?)
09:57:25 <monochrom> Sometimes, you what to ask "where" rather than "when", in order to cue the answer "over my dead body" :)
10:00:18 <monochrom> Actually, for integers i1 and i2, i2-i1 > 0.001 iff i2-i1>0.
10:01:42 <geekosaur> yes, but that does not answer my question :)
10:02:13 <monochrom> Over my dead body!
10:02:33 * monochrom decides to leave it ambiguous
10:07:01 <gnull> Hello everyone!
10:08:29 <gnull> I have a little trouble with understanding haskell channels (Control.Concurrent.Chan)
10:09:33 <gnull> I want to run some programs in parallel threads, then collect their outputs into the main thread
10:11:27 <gnull> I create a Control.Concurrent.Chan and start many threads using Control.Concurrent.ThreadManager.fork
10:12:26 <gnull> Each of such threads runs some program with System.Process.readProcess, puts its output into the channel, and exits
10:13:13 <gnull> The main thread gets the data from the channel
10:15:12 <gnull> The problem is that the main thread can't determine if the child threads have already written all the data to the channel or they are still running
10:15:56 <glguy> gnull: You'll need to signal in the channel that all the data has been sent if the data can span multiple messages
10:16:19 <glguy> For example (Chan (Maybe Msg)) where Nothing signals the end
10:16:29 <gnull> I tried using Control.Concurrent.STM.TMChan that supports closing the channel, but there is another problem with it.
10:16:43 <gnull> glguy: TMChan seems to do this
10:17:20 <gnull> But closing the channel by one of the child threads will close it for all of them
10:18:04 <beech> Has anybody here bought 'Haskell Programming from First Principles'?
10:18:28 <glguy> then instead of Nothing, you can have: data Message = Done WorkerId | Content WorkerId SomeContent
10:18:34 <gnull> glguy: Probably, I could make the main thread read the data from Chan until it receives N Nothing's, where n in the number of child threads.
10:19:52 <beech> How am I able to get the latest version of HaskellBook? I have an old version of the book and no longer have the email I bought it with.
10:20:14 <gnull> glguy: Yes, that would be better
10:21:46 <gnull> glguy: I hoped that there is an out-of-the box haskell primitive like 'closable channel with N inputs and single output'
10:22:25 <gnull> glguy: But your solution is also good. Thank you.
10:30:26 <gnull> glguy: How common is this approach for solving problems like this? Isn't there a way to achieve this without implementing some kind of protocol on data passed through channel?
10:31:43 <glguy> gnull: If what you want to do is already implemented in the "async" package, then I'd use that. If you need something custom you'll have to write it. There are a lot of small variations around what you might actually want a solution in this space to do
10:32:35 <mmachenry> Did anyone see that Haskell is the most nocturnal language on StackOverflow? https://stackoverflow.blog/2017/04/19/programming-languages-used-late-night/
10:35:41 <Tuplanolla> That post made me realize that I hardly ever use Stack Overflow for Haskell questions, mmachenry.
10:36:57 <mmachenry> Tuplanolla: You're part of the problem. :) People look to those asking questions on StackOverflow for how popular the language is.
10:37:41 <gnull> glguy: Yes, async is also close to what I want, but not exactly. Looks like I'll have to write a little bit of code by myself :)
10:37:46 <Tuplanolla> Don't blame me, mmachenry. Haskell doesn't have enough common problems with stupid workarounds.
10:40:06 <Tuplanolla> Like "what standards or platforms provide `va_copy`" or "is GCC's `__thread` a drop-in replacement for `_Thread_local`".
10:40:16 <mmachenry> Tuplanolla: I blame Simon. Add more WAT!! and we'd be the next big thing.
10:55:32 <robertkennedy> Does this look like the right way to consume streaming results `consume f handle = go mempty where go acc = do {next <- get handle; if null next then return acc else let acc' = mappend acc (f acc) in acc' `par` go acc'}`
10:58:50 <robertkennedy> Hopefully the types are clear enough. In particular `get :: Handle -> IO [a]` and `f :: Monoid m => [a] -> m`
10:59:39 <EvanR> par ?
11:00:36 <robertkennedy> From Control.Parallel
11:01:49 <EvanR> is accumulating expensive enough to benefit (and not unbenefit) from parallelism?
11:03:12 <robertkennedy> The usecase is counting occurrences from 11mm objects streamed from Handle. The parallelism seems to allow the handle to immediately continue streaming. 
11:03:39 <lazarljubenovic> Just wanted to drop by to say that, my first two hours into Haskell ever, and I'm already in love.
11:03:51 <koala_man> lazarljubenovic \o/
11:03:53 <koala_man> it just gets better
11:04:14 <EvanR> another satisfied customer
11:04:32 <Tuplanolla> Then you see Template Haskell and hit the Lisp envy.
11:04:48 <EvanR> no i do not
11:05:03 <Tuplanolla> Then you see kind extensions and hit the Idris envy.
11:05:12 <EvanR> when generics doesnt work, i envy some even better language feature and not lisp
11:06:54 <lazarljubenovic> Can't wait to explore more :) But pattern matching already blew me away. And I'm NOT easy to impress!
11:07:14 <EvanR> yeah other languages are jumping on the pattern matching band wagon
11:07:36 <EvanR> it makes functional algorithms incredibly easy to express
11:09:27 <Tuplanolla> Then you see rewrite rules and... I don't actually know a single language where that's pleasant.
11:15:03 <ph88_> is there any way i can bring variables in scope in a where function without passing them as arguments ?
11:16:35 <geekosaur> no? unless they're parameters to the outer function
11:17:06 <EvanR> theres ImplicitParameters
11:17:15 <Tuplanolla> You could use record wildcards too.
11:17:24 <EvanR> sort   :: (?cmp :: a -> a -> Bool) => [a] -> [a]
11:17:28 <EvanR> sort    = sortBy ?cmp
11:18:01 <EvanR> i havent seen a good usecase for this
11:18:09 <mivael> hi
11:18:14 <mivael> > let freq = accumArray (+) 0 (1, 10) . map (head &&& length) . group . sort $ myList;  myList = [4,1,7,6,9,1,3,3,8,1,1,1,1,1,1,1,1,1,1,1,1]  in (elems freq)
11:18:16 <lambdabot>  [14,0,2,1,0,1,1,1,1,0]
11:18:24 <Tuplanolla> The syntax would be `f Args {..}`.
11:18:51 <mivael> Is there faster way to calculate the above 'freq' without using immutable types?
11:19:20 <ph88_> mivael, how fast is it now ?
11:19:23 <mivael> (Number of occurrences of each number of the input list)
11:20:17 <EvanR> ImplicitParams actually
11:21:00 <mivael> ph88_, I mean I would want to avoid "log N" multiplier in O(N * log N) due to sorting.
11:21:37 <mniip> you'd need a hashtable
11:21:37 <ph88_> mivael, just out of curiosity .. would you be able to make it faster in big-O in another language ?
11:21:45 <mniip> with O(1) amortized insert
11:21:50 <mniip> /lookup
11:22:31 <reactormonk[m]> What's the haskell equivalent to elm Never? (aka a type with no inhabitants)
11:23:13 <ph88_> reactormonk[m], you mean a type without data constructors? there is an extension for that
11:23:18 <sternenseemann> reactormonk[m]: import Data.Void (Void (..))
11:23:22 <mivael> ph88_, yes, this is O(N), in one pass (providing O(1) access to frequency array by index)
11:23:35 <sternenseemann> > :i Void
11:23:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:23:47 <sternenseemann> > undefined :: Void
11:23:49 <lambdabot>  *Exception: Prelude.undefined
11:24:09 <mniip> mivael, frequency *array*?
11:24:18 <mniip> there's a bound on the largest element?
11:24:29 <mivael> mniip, yes
11:24:31 <ph88_> that function is so difficult to read :/
11:24:34 <mniip> what is it
11:24:36 <sternenseemann> reactormonk[m]: http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Void.html
11:24:53 <reactormonk[m]> A nice way to write https://gist.github.com/dc48bb0070e74e69d8e43361b0ed4c74 ?
11:25:10 <mniip> mivael, if the upper bound is K,
11:25:21 <mniip> then it's impossible to do it in under N log K time
11:25:40 <sternenseemann> reactormonk[m]: totally fine, the code
11:26:06 <mivael> ph88_, yes, there is a bound (minimal possible and maximum possible value for an element of input list -- sorry I did not mentioned this in my question)
11:26:22 <ph88_> geekosaur, do you know why ghc reports my record update line is now a function that is applied to 4 arguments?  https://bpaste.net/show/95cc54c16387
11:26:42 <reactormonk[m]> sternenseemann: doesn't compile, because InvalidRequest is in there twice.
11:26:53 <reactormonk[m]> I'll take Void, thanks.
11:28:31 <geekosaur> ph88_, because you missed 'do' on line 32
11:28:47 <geekosaur> so the following lines are all part of the expression starting with `modifyState`
11:29:08 <ph88_> i add do and it compiles without error
11:29:28 <ph88_> -____-
11:29:35 <ph88_> ok well nice function
11:29:57 <geekosaur> and the do you put on line 30 does nothing since it's only one expression not using do syntax :)
11:30:45 <mivael> mniip, why? in an imperative language and with O(1) access to array elements it seems to be O(max(N,L)): iterating through the input list -- O(N) -- and increasing a counter in an output array -- O(1)...  Generally we also need to initialize output array with zeros -- O(L).
11:31:13 <ph88_> geekosaur, but it looks like i'm do-ing more work as programmer :P
11:31:54 <mniip> mivael, if you use a hashtable you can go down to O(N)
11:32:10 <ph88_> hurray for hashtables !
11:32:16 <mniip> but
11:32:20 <mniip> that's mutable datatypes
11:32:20 <mivael> mniip, is it an immutable type in Haskell?
11:32:29 <mniip> no
11:33:21 <mniip> you need to store an array of uniq(L) values
11:33:22 <mivael> I also could use mutable arrays, but my question is about doing it using immutable types
11:33:36 <mniip> with immutable haskell types access to such array can't be under log(uniq(L))
11:34:05 <jackhill> llcdvfvbugguchghctfinverhvfvfvfd
11:34:11 <jackhill> sorry!
11:34:19 <mniip> unless you use Array but then it's a very long write
11:34:54 <mivael> mniip, thanks!
11:35:23 <mniip> now, I don't have a formal proof,
11:35:37 <mniip> but in a finite haskell program all datatypes have a bounded number of fields
11:35:49 <mniip> and the only way you can represent an unbounded array is with a tree of some shape
11:36:31 <mniip> (Array is not a tree of some shape, but its implementation is fairly unmathematical)
11:36:35 <EvanR_> uh are there anything other than finite haskell programs
11:36:45 <mivael> mniip, I understand
11:37:07 <EvanR_> also arrays implementation as silicon suffers from the same log(n) limitation technically
11:42:13 <mivael> mniip, I was just inspired by a blog post on lazy dynamic programming (http://jelv.is/blog/Lazy-Dynamic-Programming/) and I thought that maybe there is a way to hide the actual mutations using laziness or so...
11:42:48 <mivael> mniip, EvanR_, ph88_: thank you for your help
11:56:28 <ph88_> let is not working here on line 7 https://bpaste.net/show/7caa2bdff59c what should i use instead ?
11:57:22 <geekosaur> once again, do notation... or rephrase as let-in
11:58:58 <ph88_> geekosaur, is there an elegant way to avoid that go function on line 3 ? it seems to have little purpose
11:59:05 <EvanR> do notation or don't notation, thats the question
12:00:06 <geekosaur> you could rephrase as awaitForever $ \result -> case result of ...
12:00:31 <geekosaur> although in this case I think I'd stay with the go function and absorb the case on result into it 
12:01:02 <geekosaur> go (Left e) = ...; go (Right (posRange, numbers)) = ...
12:01:22 <mniip> don't launchMissiles
12:01:43 <geekosaur> @hachage acme-dont
12:01:44 <lambdabot> http://hackage.haskell.org/package/acme-dont
12:02:24 <mniip> word
12:02:49 <ph88_> can be useful instead of using comments
12:06:04 <Hafydd> don't $ do it
12:06:38 * mniip . o O ( IOT Proxy )
12:09:52 <lyxia> Internet Of Things Proxy
12:09:55 <mniip>  > runIOT $ lift Proxy >> liftIO (putStrLn "hi")
12:09:55 <mniip> Proxy
12:10:31 <scav> will this ever return?
12:10:41 <scav> tail [1..] ?
12:10:53 <mniip> depends on your definition of return
12:11:11 <jle`> > head (tail [1..])
12:11:12 <mniip> as far as haskell's notion of strictness is concerned - yes
12:11:13 <lambdabot>  2
12:11:22 <mniip> it can be evaluated to WHNF
12:11:32 <mniip> tail [1..] = _ : _
12:12:00 <geekosaur> scav, the answer depends on the circumstances
12:12:16 <scav> i meant in any meaningful sense, as in what value will it actually return? is it limited by maxbounds e.g.?
12:12:28 <jle`> scav: the value it returns is [2..]
12:12:28 <geekosaur> > take 3 $ tail [1..]
12:12:30 <lambdabot>  [2,3,4]
12:12:38 <mniip> it will return a value representationally equivalent to [2..]
12:12:38 <geekosaur> that seems a perfectly meaningful sense...
12:12:40 <jle`> scav: and you can do whatever you'd do with [2..]
12:13:01 <jle`> > head [2..]
12:13:03 <lambdabot>  2
12:13:12 <jle`> > head (tail [1..])
12:13:12 <mniip> [2..] defaults to [Integer], so no
12:13:14 <lambdabot>  2
12:13:14 <mniip> no maxBounds
12:13:24 <geekosaur> since it's Integer, it will produce until you run out of memory to hold the value, which will take a while :)
12:13:39 <scav> you get 2 by doing 'head [1..]' and nothing else?
12:13:45 <jle`> scav: no
12:13:47 <jle`> 2 is head [2..]
12:13:56 <jle`> head (tail [1..]) = head [2..] = 2
12:14:01 <jle`> math is power ~
12:14:04 <geekosaur> even if it were Int or Int32, neither one checks bounds and neither does Enum, so it would just wrap around
12:14:22 <scav> jle` i was kinda leading that question along. 
12:14:24 <mniip> > [maxBound..] :: [Int]
12:14:26 <lambdabot>  [9223372036854775807]
12:14:28 <scav> geekosaur ah 
12:14:32 <mniip> geekosaur--
12:14:33 <jle`> scav: tail [1..] returns [2..], so head (tail [1..]) is the same as head [2..]
12:14:36 <jle`> scav: which is 2
12:14:45 <geekosaur> oy
12:14:52 <jle`> so yes, tail [1..] does return immediately with [2..]
12:15:22 <mniip> "immediately"
12:15:31 <scav> by not using head, are you ever going to see 2?
12:15:34 <mniip> in this context it's within finite time or not :p
12:15:49 <mniip> scav, you could write your own head
12:15:50 <jle`> well,the way tail is defined, it's pretty much afte rone evaluation step
12:16:02 <jle`> tail (x:xs) = xs, so tail (1:[2..]) = [2..]
12:16:11 <mniip> > (\(x:xs) -> x) (tail [1..])
12:16:13 <lambdabot>  2
12:16:21 <mniip> look ma no head
12:16:49 <jle`> if you consider [1..] = 1:[2..], then tail (1:[2..]) = [2..] 'immdiately', from the definition of tail
12:16:53 <jle`> immediately in the mathematical sense, heh
12:17:01 <jle`> no extra reduction steps required
12:17:02 <geekosaur> scav, there's a reason people are evading your direct question: *asking* that question strongly suggests misunderstanding of laziness
12:17:41 <mniip> their direct question makes no sense is all
12:18:07 <jle`> scav: if you consider the denotational semantics, tail [1..] directly returns, denotatively, [2..].  tail [1..] is operationally and denotatively identical to [2..]
12:18:15 <jle`> so whatever you'd do with [2..] is what yu'd do with tail [1..]
12:18:37 <jle`> but instead of htinking of [2..] like something that exists in memory, think of it as an abstract concept
12:18:46 <jle`> that *represents* the list [2..] forever
12:19:39 <jle`> the abstract idea of [1..] is a list that starts from 1 and goes on forever, the abstract idea of [2..] is a list that starts from 2 and goes on forever, and tail [1..] represents the same thing that [2..] represents
12:19:59 <scav> geekosaur yes, perhaps it would have been easier to just ask how long [1..] could potentially run for. i understand how everything after 1 is returned
12:20:14 <jle`> [1..] isn't "run"
12:20:21 <jle`> it represents a list, mathematically
12:20:30 <jle`> it can be manipulated using functions like head, tail, etc.
12:20:44 <mniip> are you asking what is the largest Integer?
12:20:54 <jle`> [1..] isn't actually any data structure containing 1, 2, 3, et.c in memory
12:21:01 <mniip> the answer is 2^(2^64 + 64)
12:21:23 <jle`> if you're familiar with python iterators/generaotrs, it's a similar concept
12:21:42 <scav> so it will hold every number from 0 to the largest number possible?
12:21:47 <mniip> no
12:21:49 <jle`> it doesnt "hold" numbers
12:21:51 <mniip> well
12:22:08 <mniip> it will hold, but not in memory
12:22:16 <jle`> heh yes
12:22:23 <mniip> > 718474 `elem` [1..]
12:22:25 <lambdabot>  True
12:22:31 <mniip> see, it contains the number 718474
12:22:51 <mniip> yet, even during evaluation of that, not more than a single Integer was contained in memory
12:23:43 <mniip> (that's actually a fairly strong statement depending on the implementation of elem, ||, and enumFrom, but I think I am correct)
12:24:55 <jle`> scav: it *represents* a list starting from 1, 2, 3, etc. forever
12:25:02 <jle`> it doesn't mean that it actually contains 1, 2, 3, etc. in memory
12:25:22 <jle`> its operations like head, tail, elem, etc. work on the idea that [1..] represents
12:25:31 <jle`> and not on some actual infinitely large data structure in memory
12:25:51 <mniip> (actually, head, tail, elem don't care)
12:25:59 <scav> that is purely semantics, as i would argue that the abstract concepts to represent that is contained in memory 
12:26:08 <mniip> sure
12:26:14 <EvanR> we work with abstract objects directly ;)
12:26:19 <jle`> yes, this is semantics
12:26:23 <mniip> there's an enumFrom closure
12:26:33 <mniip> pointing to an Integer 1
12:26:45 <EvanR> because you cant tell what it "really is" because "what it really is" has been erased by abstraction
12:26:46 <jle`> scav: sure, but "returning [2..]" doesn't mean that you literally return an infinite list in memory
12:26:56 <jle`> scav: tail [1..] immediately returns [2..]
12:27:34 <jle`> just from the definition of tail, and [1..].  [1..] is 1:[2..], and tail (x:xs) = xs, so tail (1:[2..]) = [2..]
12:27:35 <EvanR> you cant tell its not an infinite list in memory
12:27:43 <EvanR> because theres no observable difference
12:27:45 * mniip . o O ( does [1..] ++ [] "immediately" return )
12:27:53 <scav> jle` no, i understand that, i also understand how it is possible - i was merely curious about any actual limits to it
12:28:06 <jle`> limits to what?
12:28:11 <mniip> scav, that depends on what you do with it
12:28:11 <EvanR> only the limits imposed by the OS
12:28:16 <mniip> like, a lot
12:28:29 <jle`> limits to how much of [1..] you can expand and store in-memory?
12:28:30 <scav> EvanR thank you
12:28:42 <EvanR> see the generic versions of the list operations
12:28:45 <EvanR> :t genericIndex
12:28:47 <lambdabot> Integral i => [a] -> i -> a
12:29:16 <EvanR> not that accessing something farther than max 64bit int will ever happen
12:29:23 <jle`> scav: this is a different question than tail [1..], though; it's a question about how much of [2..] you can expand/evaluate/store in memory
12:30:02 <mniip> scav, if you do something like 'reverse [1..]'
12:30:10 <mniip> it will have to contain the entire list in memory
12:30:20 <scav> jle` questions evolves - after your initial response and after getting the semantics out of the way it was easier to formulate the question
12:30:20 <mniip> so you'll run out of memory after a couple billion integers
12:30:26 <EvanR> if you do something like reverse [1..] you get _|_
12:30:33 <EvanR> and memory means nothing
12:30:37 <mniip> if you do something like 'filter (const False) [1..]'
12:30:53 <mniip> it will only contain a single integer in memory
12:31:16 <mniip> so you might actually get closer to 2^40
12:31:31 <mniip> er
12:31:32 <seequ_> And the structures for that expression
12:31:35 <mniip> so you might actually get closer to 2^(2^40)
12:31:43 <mniip> once you survive the heat death of the universe of course
12:32:12 <EvanR> screw the universe lets get abstract
12:32:22 <mniip> filter (const False) is actually constant time
12:32:24 <mniip> er
12:32:26 <mniip> constant space
12:33:11 <Tuplanolla> The fact that you die first doesn't make the solution any less unsatisfying.
12:33:39 <mniip> closure(x) -> whnf x; if x is [] then return []; if x is _:y then tailcall closure(y)
12:34:34 <EvanR_> Tuplanolla: that might be the answer ultrafinitists were looking for
12:35:18 <EvanR_> when asked exactly what the limit of finite is
12:39:51 <mniip> I think we scared them away
12:40:00 <mniip> I think I scared them away :(
12:40:07 <scav> na, i just don`t have much more to add
12:40:32 <scav> only been doing haskell for a couple of days so far, so i guess my question was pretty dumb 
12:41:11 <Tuplanolla> In the space of inquiry, almost all questions are dumber.
12:42:11 <mniip> well
12:42:34 <mniip> unlike C, in haskell the question of how something is computed/stored in memory is a rather advanced concept
12:42:44 <mniip> that has many, many prerequisited
12:44:14 <jle`> scav: definitely not a dumb question :)
12:50:39 <mniip> I guess IOT Proxy ~ Proxy after all
12:51:11 <jle`> Proxy is the zero of monad transformers
12:51:49 <jle`> under monad transformer composition
12:52:07 <mniip> I remember there being some criterion for monad transformer commutativity
12:52:31 <scav> jle` haskell makes me feel dumb every day :)
12:52:56 <jle`> haskell is a language where you are allowed to be dumb and your programs still work
12:52:59 <jle`> so i'm ok with that
12:53:01 <jle`> :)
12:53:35 <mniip> yeah, either it works or it doesn't compile :p
12:54:42 <sproingie> if whatever you're studying *doesn't* make you feel dumb once in a while, then there's nothing left to learn
12:54:59 <sproingie> so haskell will probably make me feel dumb forever
12:55:21 <jle`> mniip: that's why i think there should be a ProxyT somewhere, maybe in transformers
12:55:27 <jle`> just for mathematical completeness
12:55:27 <mniip> isn't there?
12:55:35 <scav> i guess i feel dumbest for not having picked up haskell earlier 
12:56:09 <jle`> sometimes picking up haskell comes at a cost
12:56:13 <sproingie> gets harder to unlearn ... but then again other languages are picking up a lot of FP, types and all
12:56:17 <jle`> it makes working in other languages so much more painful
12:56:33 <jle`> see: https://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
12:56:36 <mniip> makes working with people who are mediocre programmers so much more painful
12:56:52 <sproingie> once concepts land in C++, you'll be seeing monoids and functors and whatnot all over the place
12:57:02 <jle`> the argument is that after learning haskell, programming in other languages is demoralizing to an extent that you feel less motivated and your productivity declines
12:57:06 <mniip> has C++ got return type polymorphism yet?
12:57:29 <jle`> mniip: there's only a curried form of ProxyT
12:57:31 <jle`> but no uncurried form yet
12:57:33 <sproingie> sorta, with 'auto'.  it's not quite as clever as haskell's
12:57:43 <jle`> er i mean, only an uncurried form of ProxyT.  but no curried form yet
12:57:51 <mniip> sproingie, without that you can't have a monoid or monad
12:57:55 <mniip> not it its pure form
12:57:58 <jle`> so it doesn't admit a MonadTrans instance
12:58:16 <sproingie> mniip: presumably you'd have some sort of type witness, scala style
12:58:36 <religious> hello
12:58:43 <mniip> well that kind of sucks
12:58:43 <sproingie> i'm not familiar enough with concepts to say exactly
12:59:23 <sproingie> c++'s approach is usually "get it working with gross template magic, then extend the language if necessary"
13:00:09 <sproingie> it pushes a lot of the ugly verbosity on library writers, but consuming the library is usually pretty clean
13:00:52 <sproingie> that said i got really sick of having to deal with copy/move semantics last time i dove into c++
13:02:36 <mniip> I like C++'s template magic but haskell's typesystem is just better
13:02:58 <mniip> until C++ impements at least hindley milner, you can't have all the FP stuff
13:03:16 <sproingie> scala gets by pretty well without H-M
13:03:52 <cocreature> c++ template magic is great until you want to call some undocumented library function that accepts 5 template arguments and you need to guess what the arguments should be
13:04:22 <mniip> haha yes
13:04:48 <sproingie> usually the args are inferred.  makes the error messages pretty awful tho
13:05:13 <mniip> I hear ed is writing some C++ templated library
13:05:21 <mniip> those 5 undocumented args are going to be pretty bad :p
13:05:28 <dolio> I wouldn't say Scala gets by well.
13:05:31 <Tuplanolla> Scientific C++ is pretty alright.
13:06:06 <dolio> Unless they fixed it in the newest release.
13:06:09 <Tuplanolla> It's C with `std::vector`.
13:06:21 <sproingie> scala adds plenty of noise to express the same things, but at least not dozens of lines of noise
13:07:16 <michielb> Coming to Haskell from Scala, I can say for sure a lot of concepts in Haskell 'feel' more natural (typeclasses, for starters).
13:07:23 <sproingie> which suggests the problem is mere syntax, not lack of expressivity
13:07:44 <sproingie> *mere surface syntax
13:07:45 <dolio> I mean stuff like: the order you put arguments in affects whether it can infer the types.
13:08:02 <dolio> Or whether you break them up into multiple argument groups.
13:25:20 <kamyar> Hello all! I have a question about Haskell records:
13:25:36 <kamyar> We can declare a record using data keyword and optionally use field names
13:25:51 <kamyar> How can we use field names when instantiating record?
13:26:22 <kamyar> For example instead of Person "John" "Smith" "20"
13:26:57 <kamyar> I wanna say Person {firstname="John", lastname="Smith", age=20}
13:27:04 <Taneb> If you have data Person = Person {firstName, surname :: String, age :: Int} you can write john = Person {surname = "Smith", firstname = "John", age = 20}
13:27:30 <kamyar> Taneb: Thanks!
13:29:26 <sternenseemann> reactormonk[m]: then you got to rename it, or place it in different module (which are imported qualified)
14:48:12 <OnkelTem> I'm trying to `stack build` a simple program but it doesn't build: https://apaste.info/yCgC
14:48:26 <OnkelTem> I don't understand what does it want
14:48:38 <OnkelTem> I see no error messages
14:48:55 <OnkelTem> [warn] <command line>: cannot satisfy -package-id h2-0.1.0.0-5EMJE0Ih4BwGpTWRbQJHpL -- makes no sense for me
14:49:14 <OnkelTem> ideas?
14:50:47 <isd> Is there a standard-ish function somewhere of type Either SomeException a -> IO a that raises the exception in the case of a Left? 
14:51:13 <jle`> OnkelTem: it looks like it can't find the package h2-0.1.0.0
14:51:38 <jle`> isd: you can use 'either throwIO return'
14:51:47 <OnkelTem> jle`: hm, it's the package name I'm trying to build :) LOL, I don't know how it managed to get there
14:51:55 <jle`> can you show the cabal file?
14:51:56 <OnkelTem> I was using 'stack new h2 new-template'
14:52:47 <OnkelTem> jle`: nevermind, that's correct. I was wondering why is it (h2) listed in the deps. Now I see it was an error
14:52:57 <isd> jle`: thanks.
14:53:13 <jle`> OnkelTem: no problem!
14:53:23 <jle`> it sounds like a funky cabal file maybe
14:53:42 <jle`> isd: no problem.  it might be a bit too specialized to warrant a pre-written function
14:54:12 <jle`> there are several various 'either f g' and 'maybe x f' functions that can be added into base that are useful for one situation or another
14:54:17 <jle`> kind of have to draw the line somewhere
14:54:57 <isd> jle`: yeah. I think in this instance it's actually more readable to just use an explicit case ... of
14:55:05 <jle`> mhm. or define it locally
14:55:37 <jle`> (if you need to use it in a higher-order function)
14:57:42 <fresheyeball> so I have a dependency that contains a nice attractive typeclass
14:57:54 <fresheyeball> and another dependency that has a data structure that I sure would like to be an instance
14:58:04 <fresheyeball> is there any way around orphaned instances with that?
14:59:00 <jle`> you can patch the data structure's package to include an instance
14:59:19 <fresheyeball> jle`: boo
14:59:51 <jle`> alternatively
14:59:58 <jle`> you can use the data structure with a newtype wrapper
15:00:08 <jle`> and give the newtype wrapped structure an instance
15:00:21 <OnkelTem> Folks, how to search for module or interface name? I thought https://www.haskell.org/hoogle may help but it doesn't 
15:00:22 <jle`> this is the route that some libraries have to take
15:00:47 <OnkelTem> I type: "Snap.Http.Server" and get totally unrelated stuff
15:00:54 <jle`> OnkelTem: try http://hoogle.haskell.org/
15:01:05 <jle`> haskell.org/hoogle is a few years out of date
15:01:26 <OnkelTem> Wow
15:01:29 <OnkelTem> jle`: thanks!!
15:01:33 <jle`> also http://stackage.org/
15:01:40 <jle`> aka stoogle
15:01:44 <jle`> (only i call it that)
15:01:47 <OnkelTem> Guys, I wonder how you fight through all these outdated piles :)
15:02:00 <MVQq> a googley stoooogaly
15:02:27 <jle`> haskell.org/hoogle should be updated any time now, they're just waiting on hoogle 5 to be released
15:02:32 <jle`> and they're freezing the index until then
15:03:00 <jle`> but it's been a few years, i feel like they should maybe put some sort of deprecation notice up there
15:04:34 <jle`> stackage uses hoogle 4 with an up-to-date index, and hoogle.haskell.org uses hoogle 5 alpha (which is missing some important functionality) with an up-to-date index
15:04:50 <jle`> so it seems reasonable that either would be preferable to haskell.org/hoogle's hoogle 4 with an out of date index
15:05:09 <jle`> a nice warning might be helpful :)
15:07:31 <hpc> there's also hayoo, for when you really need to find something and who cares if it's near the top of the results
15:20:21 <OnkelTem> Yahoooooo! I've build my first snap hello world program!
15:20:38 <OnkelTem> built*
15:20:39 <jle`> :D
15:20:46 <NJBS> Came across this while reading Haskell from first principles, any idea how wtf is supposed to typecheck? http://lpaste.net/8895537402194427904
15:20:54 <OnkelTem> Huh, it took 3 days.
15:21:17 <OnkelTem> But I have now working docker container with stack and stuff
15:21:59 <jle`> NJBS: which one are you confused about?
15:22:03 <Koterpillar> NJBS: which one?
15:22:12 <jle`> oh, 'wtf'
15:22:31 <jle`> NJBS: you can work through the types of 'join' and '.'
15:22:37 <jle`> it's a mechanical process
15:23:06 <jle`> or are yuo asking about what type it would have?
15:23:15 <jle`> :t zipWith (+) . (join .) . map
15:23:16 <lambdabot> error:
15:23:16 <lambdabot>     • Couldn't match type ‘[a1] -> [a]’ with ‘[c]’
15:23:16 <lambdabot>       Expected type: (a1 -> [a]) -> [c]
15:23:18 <NJBS> Both the pointfree and not pointfree `wtf` don't typecheck so I was wondering if maybe there's some language extension that would allow it to typecheck?
15:23:22 <jle`> oh
15:23:42 <jle`> it is potentially an error, then
15:24:01 <NJBS> Ah well ¯\_(ツ)_/¯
15:24:03 <jle`> i don't know of any extension that would fix that error
15:24:18 <jle`> 'fix'
15:24:29 <jle`> -fdefer-type-errors, maybe :)
15:24:39 <NJBS> :)
15:25:59 <jle`> ghci> :set -fdefer-type-errors
15:26:05 <jle`> ghci> wtf = zipWith (+) . (join .) . map
15:26:07 <jle`> all is ok :)
15:26:31 <NJBS> Now call it :P
15:27:09 <jle`> that's someone else's problem :)
15:28:15 <AWizzArd> I constructed my own version of >>= which uses traceShow to visualize the state.  I now was running  data >>= f1 >>= f2 >>= fReset >>= f4   and was surprised to see that it seems that only f4 ran.
15:28:19 <AWizzArd> Could this be a demonstration of a compiler optimization? Because my  fReset _ = state (\_ -> ("", []))  maybe? Could the compiler have detected how I am not using   data, f1 and f2?
15:28:56 <AWizzArd> Or is this more likely lazyness at play?
15:29:12 <Koterpillar> laziness, yes. There's nothing special about >>= that will make it all evaluate
15:29:22 <AWizzArd> Right.
15:29:41 <sm> congrats OnkelTem 
15:29:51 <OnkelTem> sm: thank you :)
15:30:04 <AWizzArd> I was just guessing that possibly it was detected by some kind of whole program optimization that indeed the expressions before the fReset were unused. 
15:30:17 <AWizzArd> But yeah, lazyness implicitly already solved that.
15:59:02 <pacak> Cale: Author of original program replied so I hope we'll figure it out at some point, but the fact is amount of elements in regroup is different between every time. Singlethreaded program makes evaluation order deterministics.
16:01:59 <Cale> pacak: Yeah, I couldn't see a reason that they ought to be different in any case though
16:02:25 <Cale> pacak: So, at some point before that even happens, something has already gone wrong
16:02:55 <pacak> Something to do with parallelism I suspect.
16:05:54 <ertes> i once again need a library for doing database migrations, and *only* migrations…  is there anything on hackage for that?
16:06:01 <ChaiTRex> Speaking of parallelism, why did they make it where 'concurrency', which seems like it would mean 'at the same time' doesn't describe things that definitively happen at the same time?
16:06:44 <ertes> ChaiTRex: "concurrent" can mean "interleaved"
16:06:50 <ertes> not necessarily "parallel"
16:07:04 <Koterpillar> ertes: I don't have a candidate, but I'm interested in why you only need migrations. Are you happy with SQL-only migrations? What are you using for the main interface?
16:07:21 <ertes> Koterpillar: i'm using *-simple, e.g. sqlite-simple
16:07:41 <ertes> so i pretty much just write SQL
16:08:01 <Cale> I think ChaiTRex is just referring to the etymology.
16:08:07 <ChaiTRex> ertes: Oh, sure, in the computer science definition, that's true. I'm just wondering why they made it differ from the colloquial definition of concurrency.
16:08:21 <ertes> ah
16:08:29 <ertes> ChaiTRex: well, what would you call it?
16:08:58 <ChaiTRex> ertes: I'm not sure.
16:13:58 <ertes> i'm not sure whether the colloquial definition really means "in parallel"…  aren't the moves of two chess players "concurrent" as opposed to a game, where first one player makes all of their moves, then the other player does?
16:20:28 <koala_man> ChaiTRex: it could have been at a time when computers could only do one thing, and interleaving made it look like it did two things at once. similar to how hard disks were called "random access memory" when they first came because they were compared to tapes
16:21:24 <ChaiTRex> koala_man: That makes sense.
16:30:10 <ertes> that's basically how windows 3.* worked =)
16:30:36 <ertes> if your app doesn't yield, the whole thing freezes
16:37:18 <mjora7> Is there a better learning resource than Learn You Haskell? I'm 2 chapters in and still have no idea how to properly write a program in a file, basic i/o, how to indent code, etc.
16:37:28 <geekosaur> @where learnhaskell
16:37:28 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:37:31 <geekosaur> @where cis194
16:37:31 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
16:37:41 <geekosaur> lyah is terrible for learning how to write haskell
16:38:05 <geekosaur> unless you;re a serious self-starter willing to play around in ghci with the stuff lyah parades before you
16:38:13 <Cale> Graham Hutton's book is good
16:38:14 <mjora7> lyah?
16:38:22 <geekosaur> _Learn You A Haskell_
16:38:45 <mjora7> Oh right, didn't realize there was an 'a' in there hahah
16:39:03 <mjora7> Yeah, lyah is teaching so much unnecessary stuff that I can't actually use cause I don't know how to write a damn program hahah.
16:39:18 <mjora7> What a terrible intro. Not saying it's bad, just a bad intro.
16:39:37 <mjora7> Maybe I can come back to it after a more efficient introductory book.
16:40:19 <geekosaur> it's been characterized as a 2-hour movie trailer >.>
16:40:42 <mjora7> Ok, so I'm not the only one who thinks that then!
16:41:13 <Cale> Well, I don't think it's *quite* as bad as that.
16:41:27 <Welkin> Learn You Some Erlang
16:41:36 <Cale> It does teach you how to write programs right from the beginning.
16:41:49 <Cale> Not programs which do I/O necessarily.
16:42:07 <Cale> But it doesn't necessarily make sense to learn how to do I/O right away while learning Haskell.
16:42:17 <Welkin> the best way to learn how to program is to read source code
16:42:36 <Welkin> find the complete source code for a simple project and read it all
16:43:04 <Welkin> the Write Yourself a Scheme tutorial is good for this
16:48:41 <Tuplanolla> I'm a bit skeptical of that approach. By reading other people's code, you learn how to write like said people.
16:49:00 <Welkin> Tuplanolla: that is why you read a lot of code
16:49:22 <Welkin> of course you will emulate what you see
16:49:34 <Welkin> over time it changes and you will decide for yourself how you want to write your code
16:49:39 <Welkin> it's ust how the process works
16:49:49 <Cale> I'm not sure that's a really great approach when starting out if you don't already know something pretty close like ML.
16:51:08 <Tuplanolla> I'm not a Haskell expert yet, so I can't comment on that, but had I learned C that way, I'd still be writing garbage.
16:53:28 <Welkin> it depends on what you mean by "learn"
16:53:41 <Welkin> if you know absolutely nothing, you can't start just by reading code, obviously
16:53:46 <Welkin> once you know the basics, you can
16:58:05 <geekosaur> some people can learn that way... others can't. which is why it's good to have multiple ways to learn
17:11:38 <fresheyeball> is there a haskell version of this? https://github.com/lodash/lodash/blob/master/deburr.js
17:25:58 <MVQq> dunno, seems like https://hackage.haskell.org/package/text-icu-0.7.0.1 is a good bet though for a place to start
17:27:24 <MVQq> there's also https://github.com/lodash/lodash/blob/master/.internal/deburrLetter.js for another spot to look at to determine what you need
18:21:13 <v0latil3> Is there a way to have ghci print the entered line back to stdout? or can anyone think of a way to record what happens in the terminal? I want to do something like $ script -c ghci < test.txt, and have it show the expressions I am testing, and the output
18:21:38 <v0latil3> Sorry if this isn't specific enough to haskell channel
18:22:19 <Tuplanolla> I'm just about to leave, but check out `ttyrec`, v0latil3.
18:22:38 <Koterpillar> v0latil3: 'script' utility might be something that you're looking for
18:23:14 <v0latil3> I'm already using script, and it works if I manually type stuff into the terminal, but I would like to just redirect a file of tests instead of doing that
18:24:10 <v0latil3> I think I can just paste it into the terminal from clipboard
18:25:50 <v0latil3> yeah that worked! I guess that works on a desktop at least. thanks for the suggestions
18:26:27 <peddie> v0latil3: what if you point stdin at the file?
18:27:18 <v0latil3> I tried doing like 0>1 but it just exists whatever command I do right away
18:27:44 <v0latil3> it seems script only records stdin if its the tty
19:14:58 <halogenandtoast> I feel like I should know this, but I can't seem to work out the types. I have a function that returns IO (Maybe String) and I have a function String -> Maybe Int and I want to get IO (Maybe Int) from taking the first string and passing it in the second, is there an operator I can use
19:15:32 <halogenandtoast> s/operator/infix function/
19:15:40 <vaibhavsagar> (>>=)
19:16:13 <vaibhavsagar> but you need to use fmap to get at the Maybe inside your IO
19:16:27 <halogenandtoast> vaibhavsagar: I think that was the part I was missing the fmap
19:16:45 <vaibhavsagar> :)
19:16:47 <halogenandtoast> but I don't know where it goes
19:16:56 <halogenandtoast> I'll think about your statement for a moment.
19:16:57 <kadoban> halogenandtoast: Either in a do block match the Maybe String and then use the (>>=) for Maybe and then return, or you can do something with fmap (>>=)
19:17:24 <vaibhavsagar> so if you have f :: String -> Maybe Int
19:18:00 <vaibhavsagar> and some a :: Maybe String
19:18:15 <vaibhavsagar> then you should be able to do a >>= f
19:18:30 <halogenandtoast> right that makes sense
19:19:25 <vaibhavsagar> when IO gets involved and you have some b :: IO (Maybe String)
19:19:56 <vaibhavsagar> you want _ <$> b :: IO (Maybe Int)
19:20:15 <vaibhavsagar> and the (>>= f) is somehow involved in the _
19:20:26 <vaibhavsagar> try using typed holes in GHCi and see if that helps
19:20:56 <halogenandtoast> Oh that's crazy
19:21:10 <halogenandtoast>   mguess <- (>>= readMaybe ) <$> (ask "Guess a number [1-10]")
19:21:20 <halogenandtoast> I could have less parens of course
19:22:53 <vaibhavsagar> great :)
19:28:06 <halogenandtoast> vaibhavsagar: Thanks for the help!
19:28:20 <halogenandtoast> I probably won't write my code like this, but I like seeing how to connect these pieces
19:28:23 <sophiag> hi vaibhavsagar :)
19:31:49 <vaibhavsagar> hi sophiag!
19:34:57 <Squarism> is there some channel type that you dont need to duplicate for each sender?
19:35:22 <Squarism> oh.. or is it only receiver chans you dupe? 
19:36:21 <pacak> There's https://hackage.haskell.org/package/broadcast-chan
19:36:47 <pacak> Or broadcast chan in stm
19:36:48 <sophiag> vaibhavsagar: how are things?
19:37:34 <pacak> sophiag: Are those things related to Haskell?
19:39:03 <sophiag> pacak: sure
19:39:09 <vtomole> I'm getting a "Could not find module ‘Monad’" I did a cabal update and reinstall mtl, but that did fix anything. 
19:39:30 <pacak> vtomole: There is no module Monad.
19:39:58 <Warrigal> Hey, I'm wondering if this data type is defined in the standard libraries anywhere...
19:40:09 <vtomole> That's the error i got when i tried to compile my file.
19:40:09 <Warrigal> data T a = T { runT :: a }
19:40:29 <pacak> vtomole: You probably have "import Monad" somewhere - that's wrong.
19:40:33 <pacak> Warrigal: Identity?
19:40:37 <pacak> @src Identity
19:40:37 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
19:40:55 <pacak> Unless you  really want data
19:41:00 <Warrigal> I do really want data.
19:41:12 <vtomole> I'm new to haskell. I just following this tutorial:https://upload.wikimedia.org/wikipedia/commons/a/aa/Write_Yourself_a_Scheme_in_48_Hours.pdf
19:41:31 <pacak> vtomole: paste your code somewhere?
19:41:36 <isd> vtomole: put in in a pastebin?
19:41:40 <isd> bah, beat me to it.
19:41:53 <Warrigal> T is just a trivial lazy container.
19:42:22 <vtomole> https://pastebin.com/j21AHT8M
19:42:29 <pacak> Warrigal: How about type T a = Either Void a? :)
19:43:03 <pacak> vtomole: import Control.Monad maybe?
19:43:22 <Warrigal> I think that's not quite the same, actually... then "undefined", "Left undefined", and "Right undefined" are all different things.
19:43:27 <vtomole> Awesome! Thank you.
19:43:30 <Koterpillar> Warrigal: State () a
19:43:41 <pacak> vtomole: And it's better to put type signatures next to code
19:44:15 <Warrigal> Anyway, I'm just wondering if this happens to already exist somewhere or not. It's not like T is difficult to implement. :)
19:44:25 <vtomole> Allright
19:46:28 <AfC> stack is helpfully saying "Package uses a custom Cabal build, but does not use a custom-setup stanza Using the explicit setup deps approach based on configuration Strongly recommend fixing the package's cabal file"
19:46:39 <AfC> that seems to imply a dependency on Cabal >= 1.24
19:47:03 <AfC> is that common and in the wild now, or would slapping that in a .cabal file that works for people with older codebases screw them up?
19:47:45 <pacak> AfC: That will screw up people with older codebases.
19:56:06 <kellytk> As I understand it Haskell models time as a type of IO.  Is that correct and if so what does it look like in Haskell syntax?
19:56:41 <tsani> kellytk: "models time" ?
19:56:49 <pacak> As type of IO?
20:00:58 <kellytk> I asked about it here a day or so ago, if Haskell modeled time as a type of IO with the progression of time as IO events.  Someone affirmed but may be incorrect
20:01:30 <pacak> O_o
20:02:50 <AfC> pacak: don't suppose you know what an older version of Cabal would do with stanzas it doesn't understand? I seem to remember from a few years ago that it was a bit grumpy about that sort of thing.
20:03:36 <geekosaur> kellytk, "Haskell" does not. some FTP libraries likely do
20:03:39 <geekosaur> er FRP
20:03:52 <kellytk> How does Haskell model time geekosaur?
20:03:58 <geekosaur> ...
20:04:21 <monochrom> Not modeled. Left to libraries. Free for all. Wild wild West.
20:04:24 <geekosaur> ^
20:04:25 <kellytk> I understand I'm likely not using Haskell terminology, but in plain language
20:04:41 <geekosaur> plain language is still "it's what the library does, the language fdoesn't care"
20:04:49 <geekosaur> this is not javascript in a browser
20:04:57 <kellytk> How would a Haskell library idiomatically model time?
20:05:08 <geekosaur> or javascript pretending to be in a browser
20:05:18 <pacak> AfC: I can imagine that's ghc 7.0
20:05:28 <AfC> heh
20:05:40 <monochrom> Depends on what you use time for.
20:05:41 <AfC> pacak: GHC 7.0 was grumpy about quite a few things
20:05:52 <geekosaur> we really are not communicating, are we?
20:06:07 <monochrom> The answer depends on the question. The solution depends on the problem.
20:06:47 <geekosaur> what is idiomatic depends on the idiom the library chooses to support.
20:06:54 <geekosaur> it is up to *the library*.
20:06:54 <pacak> AfC: Hmm... Or probably 7.2 as well.
20:07:08 <AfC> kellytk: so if you're asking how the runtime slices up resources (available compute) and does scheduling, then "how does Haskell model time" makes sense. But I imagine you're asking "how do I do calculations on times and dates?"
20:07:37 <kellytk> AfC: The former
20:07:44 <AfC> ah
20:08:20 <kellytk> I assume time in Haskell isn't a separate concept implemented in some base language, but is rather implemented using regular/core Haskell concepts
20:08:44 <AfC> kellytk: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts (gawd, but there you are)
20:08:54 <monochrom> I think you need to drop the habit of speaking like there is "the time".
20:09:05 <monochrom> There are approximately five different "time"s.
20:09:44 <monochrom> The other day I was looking at some Linux man pages and saw the Linux kernel already provides 3 different clocks in one single man page.
20:10:09 <monochrom> So, which one do you mean? #1? #2? #3?
20:10:24 <geekosaur> you thinking of itimers?
20:10:52 <geekosaur> which are different from alarms, and different again from the time syscalls (which are at least related to each other)
20:10:59 <monochrom> I think I was looking at the man page concerning VTALARM
20:11:02 <AfC> kellytk: and http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf (I think that's the latest paper about the I/O manager that's newer than the New I/O manager)
20:11:18 <monochrom> At any rate 3 is a lower bound.
20:11:22 <geekosaur> https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/base-4.9.1.0/Control-Concurrent.html has basic information about thread scheduling
20:11:40 <geekosaur> the documentation for the internal module GHC.Conc has more, beyond that you;re at the Commentary/Rts page
20:11:52 <geekosaur> right, that's itimers
20:14:03 <geekosaur> linux has ITIMER_REAL and alarm() do the same thing IIRC but some other OSes separate them (which is "fun"). then ITIMER_VIRTUAL (SIGVTALRM) and ITIMER_PROF (reserved for profiling libraries)
20:14:23 <kellytk> AfC, geekosaur: Thanks I'll read more
20:14:48 <geekosaur> and none of the three necessarily relates to actual time as returned in low precision by time() or high precision by gettimeofday()
20:15:30 <geekosaur> (unless you're in a realtime scheduling queue in which case ITIMER_REAL will at least try to stay in step with system time)
20:17:47 <geekosaur> anyway: short version is you have two different runtimes available, a green threads runtime and the multithreaded (N:M) runtime. threads generally yield when they would block or when they allocate memory (in N:M mode this may allow the capability/OS thread to switch to a different Haskell thread) 
20:18:35 <geekosaur> Haskell threads are very lightweight compared to OS threads, so multithreaded programs may spawn quite a few threads
20:24:23 <kellytk> Thank you
21:07:24 <sleffy> Why does Haskell infer a type of `t0 -> t1` for `(foo %)` while not attempting to infer a partially applied type for `(%) foo`?
21:08:04 <sleffy> Rephrasing: why does Haskell assume that the result of `(foo %)` is a function which takes at least one argument?
21:09:30 <Koterpillar> :t (%)
21:09:31 <lambdabot> Integral a => a -> a -> Ratio a
21:09:54 <Koterpillar> sleffy: % has that type, you gave it one argument
21:10:23 <geekosaur> do you know about sections?
21:10:25 <sleffy> Koterpillar, the (%) in Data.Ratio does. I was defining my own (%) for a DSL when this came up
21:10:38 <sleffy> Which had a rather funny polyvariadic function hack type signature
21:10:51 <c_wraith> Ah.  see, that polyvariadic hack would be why
21:10:55 <geekosaur> that's not going to work well for operators
21:10:56 <sleffy> When I used `(%) foo` it worked just fine, and inferred the correct type
21:11:14 <geekosaur> you invoked section syntax, which assumes dyadic operators
21:11:16 <c_wraith> sections get desugared as using two arguments
21:11:17 <sleffy> But when I used `(foo %)`, the fact that it was a section made Haskell assume the resulting value was typed as some sort of function
21:11:24 <sleffy> aaaaah
21:11:32 <sleffy> So `(foo %)` desugars to `\x -> foo % x`
21:11:36 <sleffy> Makes sense!
21:11:57 <c_wraith> there used to be an extension that changed that behavior.
21:12:02 <c_wraith> Is that still around?
21:13:31 <c_wraith> sleffy: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#postfix-operators
21:14:12 <sleffy> Neat! Thanks!
21:16:26 <Squarism> i asked a vague question before and got an answer on the opposite case. Is there a channel type that has many senders  and one listener? Ie, all senders use same chan value?
21:16:47 <c_wraith> Squarism: Chan itself handles that fine...
21:16:55 <Squarism> oh ok
21:21:46 <anishathalye> reload
22:12:06 <sleffy> Anyone know operator precedence values for infix type constructors? I want to know (->) in particular.
22:12:33 <glguy> sleffy: Try: :info (->)
22:12:51 <geekosaur> I think (->) is a special case though
22:12:53 <sleffy> glguy, GHCi gives nothing :/
22:13:00 <glguy> GHCi says infixr 0 `(->)`
22:13:07 <geekosaur> not here :/
22:13:12 <sleffy> huh, not in my GHCi
22:13:12 <geekosaur> probably added in 8.x
22:13:15 <glguy> Time to update
22:13:38 <jle`> is there a foldlM
22:13:41 <jle`> '
22:13:42 <sleffy> I could've sworn I had 8.whatever
22:13:42 <jle`> * foldM'
22:13:56 <geekosaur> :t foldM
22:13:57 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
22:13:58 <jle`> i wonder if that would even make sense
22:14:08 <geekosaur> oh, with prime, not so far as I know
22:14:19 <geekosaur> :t foldM'
22:14:21 <lambdabot> error:
22:14:21 <lambdabot>     • Variable not in scope: foldM'
22:14:21 <lambdabot>     • Perhaps you meant one of these:
22:14:59 <sleffy> Ah yep, my local stack GHCi is 8.0.2 and it gives infixr 0 (->)
22:15:02 <geekosaur> I suspect it would be dominated by strictness of (>>=) anyway?
22:15:18 <jle`> i suppose i could go trough the foldl library
22:15:54 <Koterpillar> jle`: yes, you want a strict version of your monad/transformer
22:15:59 <Koterpillar> not of fold
22:16:20 <jle`> even if i used Identity
22:16:29 <jle`> wouldn't nothing get evaluated until the end?
22:18:16 <jle`> i have to force >>= somehow
22:18:30 <Koterpillar> hmm, yes
22:19:39 <glguy> jle`: What about Identity?
22:20:02 <jle`> that's a "strict" monad, but foldlM would still build up thunks
22:20:09 <glguy> > undefined >>= \_ -> Identity "not strict"
22:20:11 <lambdabot>  Identity "not strict"
22:20:16 <jle`> welp
22:20:18 <glguy> It's a newtype
22:20:37 <glguy> You need the data Identity for it to be strict
22:20:37 <Squarism> im willing to pay $100 for someone experianced do a code review on my 8k line "near enterpise" gaming app. =D. Im a haskell noob since 1 year. Someone experiance in haskell Web/Threading/Database-IO. In particular i would like feedback on how i could make code more clear / concise. If monad transformers would been better to use. Its completely undocumented.  
22:21:54 <Squarism> Some experiance in ... is required! =D
22:41:06 <sleffy> Is there a nice, simple way to get `local`, but with `StateT`?
22:41:49 <sleffy> I do need `StateT`. I need to be able to modify this state, but I also want to run local computations in it, reader-style. Is there a better way than `get`-ing, preserving that value, and then `put`-ing after the computation is done?
22:42:48 <jle`> sleffy: looks like just gets
22:44:09 <sleffy> jle`, mm, no, I don't think so. `gets` lets me select a portion of the state, but I want to select a portion of the state and then use that to run a monadic computation with that state, and then jump back to execution with the previous state
22:44:18 <sleffy> I guess I could just insert an extra `runState` in there...
22:44:39 <jle`> sleffy: yes, that's what i mean
22:44:46 <jle`> :t gets . evalState
22:44:47 <lambdabot> MonadState s m => State s a -> m a
22:45:00 <jle`> since you throw away the final state anyway
22:45:09 <sleffy> Works for me! Thanks.
22:46:12 <jle`> no problem!
22:50:06 <CAD97> pl \predicates -> \match -> foldr (||) False (map ($ match) predicates)
22:50:10 <CAD97> no?
22:50:21 <CAD97> I don' t know how to IRC
22:51:06 <glguy> foldr (||) False is  or
22:51:16 <glguy> or with map   is   any
22:51:43 <glguy> any ($ match) predicates
22:54:27 <jle`> they have vanished into the air
23:14:21 <ReinH> oh no
23:48:57 <dogukan> hi
23:51:47 <dogukan> i am trying to write a haskell function that takes an string and converts it to an recursive variable, for e.g. my recursive variable is defined as data Tree a = Leaf a | Branch a (Tree a) (Tree a), and when i give "Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)" to my function, i want to return variable Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)
23:53:23 <dogukan> but actually, i do not have any idea to how to do that, if you guys have an opinion, i want to hear, I am new to haskell :)
23:54:55 <dfeuer> How can I profile something in a monadic context? (in this case, GHC's SimplM, which is probably some kind of enriched IOish type)
23:55:18 <jle`> dogukan: it's pretty straightforward with parser combinators
23:55:24 <dfeuer> Where do I put the cost center?
23:55:35 <jle`> dogukan: but that's usually a late-beginner concept
23:56:23 <pacak> dogukan: read?
23:57:09 <dogukan> jle`: thank you, i will look to parser combinators
23:57:13 <jle`> ah yeah, the default Read instance should generate the code
23:57:18 <jle`> if you want a quick solution, just derive Read
23:57:33 <dfeuer> But use readMaybe or something rather than read.
23:57:33 <jle`> it's not a flexible solution, but it's useful for development purposes
23:57:36 <dfeuer> Look in Text.Read
23:58:03 <dogukan> oh, i was about to ask "read what?" :D
23:58:09 <jle`> it pretty much has to take input exactly like waht you wrote (with extra whitespace)
23:58:10 <pacak> :t read
23:58:12 <lambdabot> Read a => String -> a
23:58:24 <jle`> so it's useful for development, but probably not for actual flexible applications
23:58:37 <pacak> > read (Just (Just (Left 4)) :: Maybe (Maybe (Either Int ()))
23:58:38 <jle`> dogukan: data Tree a = Leaf a | Branch a (Tree a) (Tree a) deriving (Show, Read)
23:58:39 <lambdabot>  <hint>:1:60: error:
23:58:39 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:58:43 <pacak> > read "(Just (Just (Left 4))" :: Maybe (Maybe (Either Int ()))
23:58:45 <lambdabot>  *Exception: Prelude.read: no parse
23:58:49 <cocreature> dfeuer: I’m not sure I understand your question. just put the cost centres on the things you’re interested in?
23:58:55 <pacak> > read "Just (Just (Left 4))" :: Maybe (Maybe (Either Int ()))
23:58:57 <lambdabot>  Just (Just (Left 4))
23:59:02 <jle`> @let data Tree a = Leaf a | Branch a (Tree a) (Tree a) deriving (Show, Read)
23:59:03 <lambdabot>  .L.hs:219:25: error:
23:59:03 <lambdabot>      Ambiguous occurrence ‘Tree’
23:59:03 <lambdabot>      It could refer to either ‘Data.Tree.Tree’,
23:59:06 <jle`> aw
23:59:09 <mauke> @let data MyTree a = Leaf a | Branch a (Tree a) (Tree a) deriving (Eq, Ord, Show, Read)
23:59:11 <lambdabot>  .L.hs:220:29: error:
23:59:11 <lambdabot>      • No instance for (Ord (Tree a))
23:59:11 <lambdabot>          arising from the second field of ‘Branch’ (type ‘Tree a’)
23:59:21 <mauke> @let data MyTree a = Leaf a | Branch a (MyTree a) (MyTree a) deriving (Eq, Ord, Show, Read)
23:59:22 <lambdabot>  Defined.
23:59:49 <mauke> > read "Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)" :: MyTree Integer
23:59:51 <lambdabot>  Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)
