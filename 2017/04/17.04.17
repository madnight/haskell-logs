01:22:47 <kaol> I wish monoid had syntatic sugar like monads' do.
01:28:19 <centril> kaol: elaborate ?
01:29:05 <Gurkenglas> > let f = (,()) in fst $ do f $ Sum 3; f $ Sum 8
01:29:07 <lambdabot>  Sum {getSum = 11}
01:34:41 <Gurkenglas> Applicative style arguably gets even shorter when used with monoids :P
01:36:05 <centril> Gurkenglas: Applicative style arguably gets even shorter when used with anything :P
01:36:25 <centril> <$> and <*> is much shorter than do notaion
01:39:10 <Gurkenglas> centril, when you aren't working with monoids, it doesn't do plumbing well. There's a reason for ApplicativeDo.
01:40:00 <Gurkenglas> (as in, when you need plumbing, it stops getting shorter)
01:40:36 <centril> Gurkenglas: well, mostly it is just    ctor <$> comp1 <*> comp2 <*> comp3 <*> ...
01:41:30 <cocreature> do notation is often easier to read but it is rarely shorter
01:41:53 <centril> cocreature: that depends entirely on if you are used to imperative or functional style programming
01:42:00 <centril> if imperative => do notation
01:43:16 <cocreature> centril: I was more referring to the fact that do notation encourages giving names to intermediate results. ofc you can do that with let and <$> <*> as well.
01:43:35 <kaol> centril: I'd like to have an implicit (<>) between lines. Like monads have an implicit (>>) with do.
01:43:53 <centril> cocreature: giving names to intermediate results needn't increase readability
01:44:45 <Gurkenglas> When you want to give names to things, names are gonna find their way in there. Forcing naming is like paying programmers per line written
01:44:47 <centril> kaol: you do have that if your monoid is also a monad - but you can always use RebindableSyntax and say that (>>) = (<>)
01:45:44 <centril> it would look a bit weird tho
01:47:17 <Gurkenglas> There's no instance Monad m => Monoid (m … what would even go here)
01:47:33 <Gurkenglas> ((), presumably)
01:48:20 <centril> do notation requires defining (>>=) afaik, so maybe it wont work... you'll have to try it
01:49:10 <kaol> https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html has an example with a "where (>>) = (+)" and no definition for (>>=).
01:49:25 <centril> kaol: =)
01:49:46 <centril> kaol: I wouldn't do that tho... none would understand the code w/o looking hard
01:50:00 <Gurkenglas> If you're only going to use that version of do notation for monads, 'x >>= f = x >> f (error "<- illegal in monoid do notation")' should work fine
01:50:06 <Gurkenglas> -monads+monoids
01:50:17 <centril> RebindableSyntax might be warranted in the case of indexed monads tho
01:50:41 <Gurkenglas> Has someone combined those last two?
01:51:37 <centril> Gurkenglas: well, indexed monads just make  pure,  (>>=), and (>>) more liberal, so it shouldn't be any problems
01:52:15 <Gurkenglas> Right, I'm asking whether anyone's actually written a thing that I can import in order to use do notation with indexed mondas
01:53:23 <centril> Gurkenglas: well, RebindableSyntax is probably per module, so you'll have to pull an IndexedMonad lib and then rebind at the top level
01:54:32 <centril> Gurkenglas: there's a note about it here, https://ocharles.org.uk/blog/guest-posts/2014-12-06-rebindable-syntax.html
01:54:54 <Gurkenglas> (Dreaming: A record library that generalizes %= and .= to the indexed state monad and then you can pull fields out of nowhere in the middle of a do block)
01:55:40 <centril> Gurkenglas: link ?
01:56:03 <Gurkenglas> Dreaming as in, this is what I hope to see in the future
01:56:36 <centril> Gurkenglas: anyways, here's a gist of an indexed monad somewhat-lib: https://gist.github.com/Centril/a87d72dc753e0cf71133568de53eb935
01:57:10 <Gurkenglas> Oh, if you're just looking for an indexed state monad library, that exists. By ekmett. Obviously.
01:57:34 <centril> Gurkenglas: well, I don't like that one that much
01:57:45 <centril> and it's highly incomplete
01:58:03 <centril> anyways... back to work
01:59:27 <Gurkenglas> https://github.com/turingjump/bookkeeper/issues/10#issuecomment-242266117
02:20:40 <jle`> Gurkenglas: every monoid is associated with a monad
02:20:50 <jle`> and some people use this to abuse do notation for monoids
02:21:24 <jle`> it's "a thing"
02:21:46 <Gurkenglas> "associated with"?
02:22:08 <jle`> there's a type that lifts monoids to monads
02:22:21 <jle`> with a homomorphism on <>
02:22:35 <Gurkenglas> (,()), you mean?
02:22:46 <jle`> i mean (,)
02:22:56 <jle`> or Writer
02:23:20 <jle`> every monoid 'w' creates an associated monad, 'Writer w'
02:23:26 <Gurkenglas> <Gurkenglas> > let f = (,()) in fst $ do f $ Sum 3; f $ Sum 8 <- 54 minutes ago :P
02:23:43 <jle`> ah yeah, that's the homomorphism
02:23:51 <jle`> commonly known as 'tell'
02:24:14 <jle`> tell x >> tell y = tell (x <> y)
02:24:49 <jle`> and now with Applicative Do, you can even use Const with do notation
02:25:02 <jle`> oh
02:25:07 <jle`> i suppose i was addressing kaol initially
02:25:09 <jle`> not Gurkenglas 
02:25:22 <jle`> misread the original person who had the wish :)
02:26:29 <jle`> kaol: with Writer, you can have implicit <>'s
02:26:39 <jle`> kaol: since do blocks use >>, and >> is <>
02:27:34 <Gurkenglas> I mean I did say that in "<Gurkenglas> > let f = (,()) in fst $ do f $ Sum 3; f $ Sum 8". Const's neater though.
02:28:03 <jle`> yeah, you did say that
02:28:14 <jle`> but just wanted to show that for Writer, (>>) is literally (<>)
02:28:27 <jle`> so it's actually literally like "having an implicit <> between each line"
02:34:44 <jle`> hm, actually, i suppose Const makes the analogy even clearer
02:34:59 <jle`> instance Monoid m => Applicative (Const m) where
02:35:08 <jle`>     pure _ = Const mempty
02:35:19 <jle`>     Const x *> Const y = Const (x <> y)
02:35:32 <jle`> it's literally just a newtype wrapper over a monoid, that you can use in do notation :)
02:42:00 <LAZAR> Is there any way to shorten this lamdba expression : map (\c -> length (filter (==c) code)) colors
02:42:20 <LAZAR> (its about counting the occurrences of colors in a color code)
02:54:33 <Axman6> @pl (\c -> length (filter (==c) code))
02:54:33 <lambdabot> length . flip filter code . (==)
02:54:57 <Axman6> not particularly satifying but not as unreadable as it could be
03:00:03 <LAZAR> Axman6: isnt that point free notation?
03:01:24 <zereraz> hi I am trying to install https://hackage.haskell.org/package/wx using stack. I did `stack install wx` and I get this error http://lpaste.net/354667
03:02:47 <pacak> zereraz: Stack is strange.
03:03:25 <zereraz> in a stack project I could do `cabal install` as well?
03:03:31 <zereraz> even that is giving error
03:04:08 <zereraz> http://lpaste.net/354668 cabal error
03:04:17 <zereraz> for `cabal install wx`
03:09:24 <pacak> zereraz: At least you can follow this  error. wxdirect wants old  version of process
03:10:03 <hvr> zereraz: it's possible there isn't an install-plan for GHC 8.0 yet
03:10:07 <pacak> You can try using --allow-newer for cabal
03:10:16 <zereraz> ok thanks I'll try that
03:10:32 <hvr> be careful w/ an unqualified --allow-newer
03:10:55 <pacak> zereraz: use cabal sandbox in order not to break all the things
03:11:16 <zereraz> ok I'll do that
03:11:44 <hvr>  --allow-newer=wxdirect:process 
03:12:15 <hvr> that's what unlocks an install plan for GHC 8.0 for me
03:12:23 <zereraz> do you guys not use stack?
03:12:42 <pacak> Nope.
03:12:51 <LAZAR> umm how do i return a custom data type? assume i have a function f :: Int -> Person and Person has some fields. Do I need to use a constructor?
03:12:58 <hvr> zereraz: no... why should I? :)
03:13:27 <pacak> LAZAR: o_O
03:13:58 <LAZAR> oh just got it... construcitng is pretty trivial.... Person param1 param2, etc
03:14:02 * hvr just noticed a problem w/ 'wxc'
03:14:10 <zereraz> I came back to haskell after quite some time so I thought that is what others are using https://github.com/commercialhaskell/stack 2k stars!
03:14:29 <LAZAR> stack is not a replacement for cabal
03:15:12 <pacak> LAZAR: Rubber duck debugging. Works as usual.
03:15:24 <zereraz> ok
03:16:18 <zereraz> I did `cabal install wx --allow-newer=wxdirect:process`
03:17:44 <zereraz> http://lpaste.net/354669 it is saying I need to install `Error: wx-config not found, please install wx-config before installing wxc`
03:19:02 <pacak> Hmm... Looks like mac
03:19:20 <hvr> zereraz: on debian, that's a CLI tool provided by either libwxbase3.0-dev or libwxgtk3.0-dev
03:19:35 <zereraz> ya mac
03:19:55 <pacak> Ubuntu says it's libwxgtk2.8-dev or libwxgtk3.0-dev
03:22:08 <zereraz> I'm trying `brew install wxmac --devel` hopefully it will install
03:22:32 <zereraz> for FRP is reactive-banana used more or yampa ?
03:24:14 <zereraz> also what about gui's is wx used or something else?
03:24:24 <hvr> zereraz: fwiw, I'm afraid the wx package may be a bit outdated; it doesn't seem to compile against wx 3.0 anymore
03:24:37 <pacak> We are using gtk
03:24:58 <zereraz> can I use something like FRP for it?
03:25:07 <zereraz> I want to learn frp by making something in it
03:25:18 <zereraz> I saw reactive-banana had wx
03:25:43 <zereraz> hvr: damn
03:25:59 <hvr> at least I'm getting tons of C++ compile errors here
03:26:10 <hvr> the package is 2 years old...
03:26:24 <pacak> zereraz: gtk can be used with frp, yes
03:26:37 <zereraz> pacak: with which library?
03:27:12 <hvr> otoh... https://hackage.haskell.org/package/wxc does claim to work w/ 3.0
03:28:07 <pacak> zereraz: https://hackage.haskell.org/package/euphoria
03:28:43 <zereraz> pacak: but does it have behavior
03:28:46 <zereraz> I can see event
03:29:09 <pacak> zereraz: No idea, I'm carefully avoiding frp related code :)
03:29:20 <zereraz> pacak: why?
03:30:05 <LAZAR> how can i access unnames members of data types?
03:30:09 <LAZAR> unnamed
03:30:21 <pacak> Our project is big and there are a bunch of smaller parts to it. I find it more fun to work on different parts of code I guess.
03:30:26 <pacak> LAZAR: Pattern matching
03:30:43 <LAZAR> data type is data Move = Move Code Int Int           deriving (Show, Eq)
03:30:58 <LAZAR> how would i match a pattern here?
03:31:10 <pacak> case blah of
03:31:10 <pacak>   Move c a b -> ...
03:31:10 <hvr> zereraz: ok, something else is going on here... I'm still investigating; I was able to install wxc w/ GHC 7.10.3
03:31:50 <pacak> LAZAR: Are you sure you are reading a textbook?
03:31:57 <zereraz> hvr: oh cool my make install is going on
03:32:12 <zereraz> pacak: got it
03:32:15 <LAZAR> pacak: im reading CIS 194
03:32:42 <justvisit> What should I do after reading 'Learn You a Haskell for Great Good'?
03:33:02 <pacak> justvisit: CIS 194 probably
03:33:23 <pacak> justvisit: I did real world haskell, but those days it's kind of dated.
03:34:05 <LAZAR> justvisit: CIS 194 is pretty nice
03:34:17 <justvisit> I'll check out CIS 194, then.
03:34:20 <justvisit> Thanks.
03:34:33 <ertes> zereraz: reactive-banana and reflex
03:34:34 <LAZAR> they just sometime shave stuff in the exams which arent covered before like pattern matching in my current case
03:34:55 <LAZAR> im more used to having named fields lol
03:35:15 <zereraz> ertes: oh wow reflex seems interesting!
03:36:52 <ertes> zereraz: generally you can use pretty much any UI toolkit with FRP, and for some of them there are libraries to connect the FRP framework to the toolkit…  personally i find it easier and more satisfying to make that connection myself
03:37:37 <zereraz> ertes: I'm a bit new, I would like to try making some bindings myself but not very sure how
03:38:16 <ertes> zereraz: oh, and regarding AFRP (yampa, wires): avoid it unless you really really need it (like when you have large, highly dynamic systems that need to run at 60 FPS)
03:38:54 <LAZAR> So the only way to access unnamed fields in data types is like this: getUserName (User name _ _ _ _ _ _ _) = name, means you just memorize the index of the field?
03:39:38 <zereraz> ertes: what is AFRP ?
03:40:03 <ertes> zereraz: A = arrowised, as in Control.Arrow
03:41:27 <pacak> LAZAR: Yes. Or you can give them names.
03:41:40 <pacak> LAZAR: Or if you are into high energy magic you can use lenses
03:41:45 <ertes> it's like Monad, except it ruins your life
03:42:03 <pacak> ertes: Is it? Why?
03:42:25 <zereraz> ya why? I thought arrows were interesting(learning it first time only)
03:42:26 <LAZAR> is it possible to deconstruct Data Type parameters like in JS, example: jsDoStuffWithUser({name, age, id})?
03:42:50 <ertes> you use Arrow when the thing you have is not a Monad (or, as in this case, not a useful Monad)
03:43:08 <ertes> in exchange for a horrible API with horrible notation
03:43:17 <pacak> LAZAR: If you have names you can use them: data Foo = Foo { foo :: Int, bar :: Int }
03:43:33 <pacak> LAZAR: doStuffWithFoo Foo{..} = xxxxxx
03:43:36 <zereraz> ertes: because if it is not a monad we don't get do syntax?
03:43:44 <LAZAR> pacak: hmm im doing an exercise from CIS which specifically requests me not to name the fields
03:43:47 <pacak> LAZAR: xxxxx can use variables foo and bar
03:44:02 <pacak> LAZAR: I see. In that case you going to suffer.
03:44:31 <pacak> zereraz: You get arrow syntax
03:44:31 <ertes> zereraz: it's really difficult to recover monadic information passing for something that acts much more like a proper Applicative
03:45:02 <ertes> zereraz: that's why you see those countless tuples and a syntax that, beside looking awful, translates into something that is incomprehensible
03:45:13 <zereraz> hmm got it
03:45:15 <ertes> unlike the fairly straightforward translation from monadic do-syntax to combinators
03:45:19 <pacak> ertes: Hmmm... ArrowApply gives you Monad powers, just in an ugly way...
03:45:33 <LAZAR> problem is they didnt really introduce Data Type comparison so even simple stuff like pulling a value out of a Data Type is difficult at best
03:45:37 <ertes> pacak: yes, but if you have an ArrowApply, you might as well not use Arrow at all
03:45:58 <ertes> there is no reason to use Arrow, if you have a Monad
03:46:19 <zereraz> ertes: have you tried purescript?
03:46:32 <ertes> zereraz: only very briefly
03:46:40 <zereraz> ertes: what do you think of https://github.com/paf31/purescript-behaviors/blob/master/test/Main.purs
03:46:54 <pacak> ertes: Hmm... Actually right now I'm trying to write some code in arrows because I do have a Monad, but I also want some stuff from Arrows specifically...
03:47:02 <pacak> Not sure yet if it's a good idea or not.
03:47:04 <zereraz> ertes:  does it seem like decent frp features? or does it lack something
03:47:37 <ertes> zereraz: looks like FRP code to me at least…  can't really say much though
03:48:02 <zereraz> ertes: ok thanks, also do you know some resource for frp?
03:48:13 <ertes> pacak: it's not a good idea…  Monad is strictly more expressive than Arrow
03:48:28 <zereraz> when does one need to use Arrow?
03:48:28 <ertes> pacak: you should want the Monad equivalent of whatever you're looking for
03:48:47 <pacak> ertes: Well, the point is in most cases I want to restrict this expressiveness
03:48:58 <zereraz> it is a generalized monad right
03:49:08 <ertes> zereraz: not really, sorry, although heinrich apfelmus, the author of reactive-banana, has written *a lot* about FRP
03:49:26 <ertes> pacak: that…  doesn't make sense…
03:49:34 <zereraz> ertes: ok thanks, I went with reactive-banana because of that :)
03:49:57 <ertes> zereraz: no, Arrow in terms of expressiveness, falls between Applicative and Monad
03:50:13 <pacak> ertes: Have you ever worked with shake?
03:50:23 <ertes> pacak: briefly
03:51:06 <pacak> We are using it to build stuff and in one condition  it fails to build because of stale files
03:51:21 <pacak> Fortunately shake is able to remove all the stale files
03:51:40 <pacak> Unfortunately it needs to build all the things for that
03:52:20 <pacak> Which fails. And there's no cheap ways to do that mostly because shake actions are monads
03:52:32 <pacak> (do that = remove stale files)
03:52:35 <LAZAR> pacak: Just figured object deconstruction like in JS works exactly the same in Haskell: doStuffWithUser (User name age id) works :-)
03:52:47 <ertes> ah, so you specifically want a proper arrow
03:52:57 <pacak> LAZAR: That's also pattern matching
03:53:12 <pacak> ertes: Right.
03:53:15 <LAZAR> pacak: yeah but much less complex than doing it inside of the function i guess
03:53:38 <pacak> LAZAR: You might want to do some separate research on haskell syntax
03:54:10 <pacak> LAZAR: pattern matches, guards, maybe list comprehensions...
03:54:12 <LAZAR> pacak: Well this is chapter 2 only in CIS i guess i will learn more in the next ones about it
03:57:44 <ertes> pacak: i don't know your use case, but wouldn't something like Codensity or even ResourceT suffice to remove stale files?
04:00:14 <pacak> Codensity? I'm affraid I'm not fluent enough in Kmettish...
04:00:41 <ertes> it's like a restricted ContT
04:00:52 <_sras_> Can Network.Mail.Smpt package send mails to SMTP servers that require TLS authentication?
04:00:55 <ertes> https://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Control-Monad-Codensity.html
04:02:07 <ertes> pacak: example: Codensity (\k -> k () `finally` c)  -- runs 'c' after the Codensity block
04:03:16 <pacak> ertes: Hmm... I'm affraid that won't help in our case. Stale files are created between runs of build system, when you checkout between different commits that remove modules
04:03:33 <ertes> ah
04:07:44 <huss_> hey
04:08:21 <huss_> Can anyone answer my question about the Reader Monad please ^^?
04:09:17 <cocreature> huss_: it’s hard to decide if we can answer that question without knowing it, so just ask it directly :)
04:09:58 <huss_> What's the difference between the Reader and State and is there any significant benefit using one of them instead of passing the state as arguments
04:10:32 <cocreature> Reader can’t modify the environment, State can
04:10:59 <ertes> huss_: Reader is really just (->) in disguise…  there is little benefit in using it
04:11:12 <hpc> @src Reader
04:11:13 <lambdabot> type Reader r = ReaderT r Identity
04:11:13 <lambdabot> --OR
04:11:13 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
04:11:34 <cocreature> the benefit of both is mostly that you don’t need to worry about passing the correct argument around
04:12:03 <ertes> actually (->) has that, too =)
04:12:14 <hpc> and for Reader, knowing that the "correct argument" never changes
04:12:34 <huss_> Thank you guys
04:12:36 <Aruro> huss_: can be their benefit is possibility to make simple monad out of these data structures
04:12:54 <huss_> Im just starting Haskell and finding it powerful lol
04:13:36 <Aruro> they use reader and state as examples of simple monads
04:13:46 <Aruro> thought they are actually rather useless
04:14:03 <huss_> For my case i'm using the reader to parse a language
04:14:13 <huss_> But i don't know if im doing it the good way let me explain
04:14:19 <hpc> huss_: fwiw, it is rare that you will use Reader or State directly, but knowing how they work will make it much easier to recognize similar functionality in other types
04:14:41 <hpc> huss_: for instance you might notice that parsec's parser type has a state component to it now
04:14:52 <ertes> State/StateT can be really useful for stateful applications…  Reader is useless, because it's just an awkward version of (->)…  ReaderT is rarely useful in isolation, but can sometimes be useful when part of a domain-specific language
04:15:22 <huss_> Reader isn't the exact same thing as the (->) >
04:15:23 <huss_> ?
04:15:35 <hpc> oh, i guess that type does explicitly use State lol
04:16:03 <ertes> huss_: not quite…  it does the same thing, but is a separate type the type checker will refuse to unify with (->)
04:16:17 <Aruro> huss_: maybe try to implement your parser without monads? and then see if monads add clarity and simplification
04:16:19 <ertes> so you can't use function application, and you can't use regular function syntax
04:16:23 <ertes> that's why Reader is awkward
04:16:43 <Maxdamantus> You can see in the declaration lambdabot showed before:
04:16:44 <huss_> @Aruro exactly what i did and i have to admit that my first parser had so many arguments to passe state
04:16:44 <lambdabot> Unknown command, try @list
04:16:47 <Maxdamantus> 23:10:52 < lambdabot> data Reader r a = Reader { runReader :: r -> a }
04:17:15 <Maxdamantus> `Reader r a` is just a wrapper around `r -> a`
04:17:24 <huss_> @ertes I understand the point now
04:17:24 <lambdabot> Unknown command, try @list
04:17:45 <cocreature> hpc: I never understood why parsec includes a custom userstate
04:17:47 <Aruro> huss_: just Name+:
04:18:06 <ertes> huss_: you can define a type for the information you need to pass around
04:18:07 <Maxdamantus> so `Monad (Reader r)` is basically the same as `Monad ((->) r)`
04:19:01 <ertes> cocreature: i don't know either, but my first guess would be that parsec is older than monad transformers
04:19:13 <cocreature> ah yeah that could be it
04:19:19 <huss_> ertes: So if i understand correctly, using theses is just a matter of syntax sugar
04:19:24 <cocreature> well I just use megaparsec these days anyway and that removed the custom user state :)
04:20:06 <hpc> cocreature: context-sensitive grammars?
04:20:22 <cocreature> hpc: sure but you can just layer StateT for that
04:20:41 <hpc> ah true, it's probably what ertes said then
04:23:29 <ij> I've got a type that implements MonadIO, but now I want to do the reverse to pass it to catchJust. How might this go about?
04:24:23 <cocreature> ij: there are two solutions to this. 1. use the exceptions package and implement MonadCatch
04:24:42 <cocreature> and 2. use monad-control and implement MonadBaseControl IO
04:24:44 <ertes> ij: the second option cocreature is about to mention will take you straight to hell =)
04:25:13 <cocreature> ertes: you can take monad-control from my cold, dead hands :P
04:25:24 <ertes> hehe
04:25:48 <cocreature> but yeah 1. is definitely preferable
04:25:53 <ij> Is there a proper way amongst these?
04:25:54 <ertes> i do like it, but it's quite a brain teaser
04:26:17 <ertes> ij: if this is only about exceptions, then the 'exceptions' package is definitely easier
04:26:28 <cocreature> ij: also hopefully you don’t have ExceptT in your monad transformer stack. then you’re pretty much lost when it comes to exceptions
04:26:35 <ertes> monad-control is much more general, allowing things like forkIO
04:26:37 <cocreature> (or something similar)
04:30:02 <ij> Any brief enlightenment about why are you lost then?
04:30:26 <cocreature> ij: https://stackoverflow.com/questions/41966893/why-is-there-no-monadmask-instance-for-exceptt/41977629#41977629
04:30:55 <cocreature> ij: the short answer is that you can’t guarantee that finalizers are run because Left shortcircuits
04:31:38 <cocreature> "catchJust" should work but anything related to "bracket" doesn’t
04:31:51 <cocreature> which at least I use significantly more often
04:34:54 <Gurkenglas> When is "au f g" not specialized "auf f g id"?
04:35:48 <LAZAR> are there functions with no parameters? what is their signature?
04:36:12 <ertes> LAZAR: every function in haskell takes exactly one argument
04:36:57 <cocreature> Gurkenglas: the docs contain an example
04:38:28 <Gurkenglas> Huh. Why isn't "auf (_Wrapping Sum) foldMap id [1,2,3,4]" "au (_Wrapping Sum) foldMap [1,2,3,4]"? :(
04:39:05 <LAZAR> ertes: sounds like a strange design decision! imagine something like generateName where you really do not need any input
04:39:10 <cocreature> Gurkenglas: oh sry I misread your question
04:39:24 <ertes> LAZAR: what would be the type of generateName?
04:39:58 <cocreature> LAZAR: there are things without parameters. they are just not called functions
04:40:53 <LAZAR> ertes: well imagine a name generator which just produces a string randomly and doesnt need any input
04:41:06 <ertes> LAZAR: so it's not String, right?
04:41:25 <LAZAR> ertes: well the Signature would be generateName :: Void -> String
04:41:30 <ertes> LAZAR: it's more likely something like IO String, right?
04:41:44 <bbear> hello
04:41:49 <LAZAR> ertes: why IO()? I could use the strings internally too
04:42:04 <cocreature> LAZAR: because you need to access the rng
04:42:14 <bbear> hello. I have a question about Haskell.
04:42:20 <ertes> LAZAR: then something like (ST s String), or perhaps (State StdGen String)
04:42:28 <bbear> Say I'm working in python and my main() program is an infinite loop.
04:42:50 <ertes> LAZAR: the point is that in haskell there is a difference between values that depend on other values (functions) and things that have effects
04:42:55 <bbear> In this case I can retain the previous state of the last loop in a global variable in memory.
04:43:08 <bbear> How can I do such a thing in Haskell ?
04:43:13 <LordBrain> there is more than one way
04:43:51 <cocreature> :t iterateM_
04:43:52 <lambdabot> error:
04:43:53 <lambdabot>     • Variable not in scope: iterateM_
04:43:53 <lambdabot>     • Perhaps you meant one of these:
04:43:58 <ertes> LAZAR: for the same reason getLine is not a function…  it's just a value
04:43:58 <LordBrain> first, of all, there's the obvious thing, you could actually use global state, you can make an ioref etc
04:44:03 <cocreature> *shakes fist at lambdabot*
04:44:09 <LordBrain> or a TVar
04:44:19 <ertes> LAZAR: an action, a description of effects…  a recipe, if you will
04:44:24 <LAZAR> ertes: so a generator wihtout any input would just be a value?
04:44:30 <ertes> LAZAR: yes
04:44:51 <cocreature> bbear: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:iterateM_
04:44:56 <LordBrain> second, you could use the recursion stack to store your state in parameters
04:45:08 <bbear> i actually use a recursive call to main
04:45:15 <ertes> bbear: you could just use recursion
04:45:21 <ertes> bbear: or StateT
04:45:25 <bbear> but yeah, chaining monadic value is actually what I'm looking for.
04:45:32 <bbear> you can't give args to main in Haskell.
04:45:44 <ertes> bbear: main = mainWith s0
04:45:46 <cocreature> bbear: well then just have main call "loop initialState"
04:45:47 <bbear> so each time the function is called it is starting fresh.
04:45:48 <LordBrain> third, you could actually use something like pipes to make an infinite stream of state values, or lazy lists (but watchout for memory leaks)
04:46:21 <LordBrain> bbear, thats not an issue, you use the fix command to make a sort of recursive lambda
04:47:29 <LordBrain> you can give as many args as you want, something like main = flip fix (initialstate1,initialstate2) $ \(state1,state2) -> do
04:48:02 <LordBrain> er
04:48:07 <LordBrain> you can give as many args as you want, something like main = flip fix (initialstate1,initialstate2) $ \loop (state1,state2) -> do
04:48:20 <LordBrain> and then call loop as a function to recurse
04:48:21 <ertes> "the fix command" just cause a weird sensation in my stomach
04:48:51 <LordBrain> sorry for the repititious text, i used the up arrow
04:48:58 <LordBrain> to edit
04:49:08 <ertes> *caused
04:50:25 <cocreature> the proper term is “the fix magic trick”
04:50:30 <LordBrain> well some people actually find it more readable 
04:51:08 <LordBrain> i guess when you get used to it, it has the advantage of not using a slew of specially designed loop functions like whileM etc
04:51:41 <ertes> replace "command" by "function"
04:51:43 <cocreature> you don’t need to use "fix" for that. just declare a recursive function in a where clause
04:52:09 <ertes> the fix trick is nice, but gets unwieldy with more than one argument
04:52:55 <LordBrain> well, yeah, you could also use a let
04:53:21 <LordBrain> i guess fix lets you get by without giving it a name tho
04:53:52 <LordBrain> its weird to newcomers, but veteren haskellers get it
04:53:59 * LordBrain shrugs
04:54:07 <cocreature> ofc they get it but there is very little benefit to it
04:54:35 <LordBrain> well thats a subjective thing, i had a guy complain because of my use of monad-loops, insisting i should be using fix everywhere
04:54:36 <ertes> not having to name the thing is actually quite a large benefit in many cases
04:54:43 <bbear> :t fix
04:54:45 <lambdabot> (a -> a) -> a
04:55:11 <bbear> LordBrain: not bad
04:55:17 <bbear> thanks.
04:56:03 <bbear> Ill think of it.
04:56:15 <LordBrain> yeah lots of options
04:56:40 <ertes> bbear: 'fix' can be nice with up to one extra argument, and it's best with no extra arguments at all
04:56:52 <ertes> for example in combination with StateT
04:57:13 <ertes> ($ s0) . fix $ \again s' -> … again s …
04:57:24 <ertes> fix $ \again -> … again …
04:57:56 <redpoppies> hello, everyone
04:58:11 <redpoppies> can anyone help with servant options? https://github.com/sordina/servant-options/issues/1
04:59:01 <shlevy> I want to write a service that comes with its own systemd unit, which must be installed into $sysconfdir/systemd/system. What's the right way to tell cabal to do that?
04:59:33 <redpoppies> why do you need cabal for it?
05:00:19 <redpoppies> is it a library? is it a standalone program and you would like to use cabal for deployment?
05:01:01 <Aruro> cabal has install options no?
05:01:06 <shlevy> I'm building the service with cabal
05:01:36 <shlevy> cabal has a --sysconfdir flag, but I don't know how to specify in my cabal file that a given file should be installed there
05:01:38 <ertes> you can use data-files to put the service file in the package, but you can't really choose its target location
05:01:47 <LordBrain> shlevy, there is a file with a bunch of directories defined under dist i think... you can try twiddling around in there
05:01:53 <Krisostoomus> Any cunts here?
05:02:06 <ertes> shlevy: consider using a deployment system around your package
05:02:09 --- mode: ChanServ set +o mauke
05:02:09 --- mode: mauke set +b $a:Kristjan1983
05:02:15 --- kick: Krisostoomus was kicked by mauke (Krisostoomus)
05:03:26 <redpoppies> shlevy: it does seem a bit out of the purpose of cabal, I might be wrong, do consider using deploy tools.. I wouldn't deploy where I do the building, too messy
05:03:59 <redpoppies> especially if the deployment target is also a production server, big no-no
05:04:15 --- mode: mauke set -o mauke
05:04:38 <redpoppies> you don't know what cabal will bring in as dependencies and with what configurations
05:05:43 <LordBrain> well, he wants to change what 'cabal install' does tho
05:05:50 <LordBrain> is that impossible?
05:06:28 <LordBrain> maybe poke around in the cabal source, maybe there is a way
05:07:00 <shlevy> I'm not talking about deployment. I'm talking about what "cabal install" will install. It's pretty standard practice for packages to come with their own systemd units, it's up to the sysadmin to decide whether or not to install those units. http://0pointer.de/public/systemd-man/daemon.html#Installing%20Systemd%20Service%20Files
05:07:54 <shlevy> Anyway, I'm guessing I'll have to extend Setup.hs
05:07:59 <LordBrain> cabal's language doesnt seem as well documented as it should be
05:08:23 <LordBrain> well you should check try to see if you can find a way not to do that
05:08:37 <ertes> shlevy: my suggestion is to use data-files to put the units into the package, then use a deployment system after build/installation to put them into the correct target directory
05:08:38 <shlevy> LordBrain: I checked the docs and asked in #haskell :D
05:08:39 <LordBrain> setup.hs is a pain
05:09:11 <LordBrain> the cabal api is notoriously unstable, you get a maintenance burden 
05:09:19 <LordBrain> take ertes advice
05:09:22 <ertes> LordBrain: what?
05:09:33 <ertes> LordBrain: i use Setup.hs all the time…
05:09:48 <LordBrain> well maybe you know better what parts of the APi to touch or not
05:09:59 <cocreature> shlevy: there is a postInst hook
05:10:28 <saep> shlevy: Make a package for the linux distribution you are building for. Shouldnt be too hard.
05:10:32 <cocreature> ertes: enjoy ifdefing your Setup.hs since Cabal 2.0 breaks everything in a non-backwards compatible way :)
05:10:39 <shlevy> ertes: I can't enforce a particular deployment system on my users though. Of course I can include it as a data file in the worst case but it is standard practice to bundle in unit files as I'm suggesting. e.g. fedora recommends its maintainers to convince upstream to include the unit as I'm suggesting :D
05:10:50 <LordBrain> there is a program cabal-debian that helps you make a package
05:10:55 <LAZAR> Can someone explain me in how far concatMap can help here? Your function should take in a length 2 and return all Code s of that length: allCodes :: Int -> [Code] Hint: This exercise is a bit tricky. Try using a helper function that takes in all the codes of length n − 1 and uses it to produce all codes of length n. You may find the concatMap function helpful.
05:10:57 <shlevy> saep: I'm not just building something for myself, I'm distributing a package
05:11:13 <shlevy> saep: I'm not going to insist on a specific package manager for my users
05:11:18 <LordBrain> i see
05:11:21 <shlevy> cocreature: Ah, thanks!
05:11:23 <saep> shlevy: Install script?
05:11:33 <ertes> cocreature: i use Setup.hs in fairly trivial ways:  main = defaultMain
05:11:38 <cocreature> shlevy: there is also preInst and instHook but I guess postInst is the most appropriate
05:11:50 <ertes> the point is that i use Setup.hs, not cabal-install
05:11:57 <shlevy> Yeah postInst sounds right
05:11:58 <cocreature> ertes: ah fair enough
05:12:02 <LordBrain> you can avoid the ifdefs if you just actually install after installing... on first run i guess
05:12:17 <LordBrain> ooooooh
05:12:20 <LordBrain> thats different ertes 
05:13:42 <cocreature> LordBrain: you can’t avoid some sort of conditional compilation of Setup.hs if you want to allow people to build your package with two different versions of Cabal and there is no way to write code that works with both
05:15:12 <LordBrain> i mean avoid it by not having much in setup.hs, other than default, simple, and have your actual executable detect its a first run and finish the install itself
05:16:08 <shlevy> Ah, so your executable needs to be run with root permissions, and hopefully it's not installed with nix where its install prefix is made readonly after the build :D
05:16:10 <LordBrain> kinda ugly, but less burdensome than custom
05:16:32 <cocreature> I highly doubt that’s less burdensome than a custom Setup.hs but that’s obviously subjective
05:16:36 <LordBrain> well, you can give the user some instruction
05:17:10 <shlevy> I'd rather just have a script in the tarball and tell the user to run it after Setup install if you want to avoid hooks
05:17:23 <LordBrain> i dont know
05:17:50 <LordBrain> i'd probably resort to custom even myself, but just dont say you weren't warned when you go ifdef crazy later
05:17:53 <Durbley> when you want to apply a function to each element in a list you call map right? What if you don't want the resulting list of results? What if calling the function suffices? Is it inefficient? Is there a way to throw away the value
05:18:10 <LordBrain> Durbley, mapM_
05:18:49 <LordBrain> Durbley, the M is because you're actually interested in the side effect, the _ says throw away the result, thats the conventional naming anyway
05:19:02 <Durbley> now, do you know if there's an erlang equivalent :^)
05:19:14 <ocharles> can anyone help explain how a cost centre can have 15% of the total allocation time, yet 0 entries?
05:19:19 <ocharles> I don't really know how to interpret that
05:19:20 <cocreature> Durbley: ask #erlang? :)
05:19:21 <LordBrain> i dont know erlang
05:19:29 <ocharles> It also has 15% of the individual allocation time
05:19:55 <ocharles> This is the cost centre, so presumably the allocation is coming from <$> https://www.irccloud.com/pastebin/q4j00XbK/
05:20:08 <Durbley> cocreature, that's the next step
05:20:16 <Durbley> i wanted to know for haskell too
05:21:17 <pacak> ocharles: profiling results can be strange with presense of optimizations.
05:21:41 <LordBrain> we have a pattern of _ for throw away result, for example sequence_ and in monad-loops package you have whileM_ and so forth.... somewhere theres' an interateM_
05:21:59 <ocharles> pacak: Hum, I thought profiling was meant to disable optimisations that caused oddities
05:22:03 <ocharles> I'll try again with -O0
05:23:20 <pacak> ocharles: profiling results can be useless without presense of optimizations :)
05:23:57 <ocharles> Fortunately optimisations don't make a huge difference to the performance of this program
05:24:32 <pacak> Try to play aroud with manually assigning cost centers - that usually works for me.
05:24:34 <ocharles> I get the same strange profiling info with -O0 though
05:24:59 <cocreature> ocharles: could you paste the .prof file somewhere?
05:25:03 <ocharles> sure
05:25:19 <ocharles> cocreature: here you go: https://gist.github.com/ocharles/538899febdc6cd857378c9923f89ed19
05:25:48 <redpoppies> can anyone help with servant options? https://github.com/sordina/servant-options/issues/1
05:26:21 <ocharles> cocreature: all source code is at https://github.com/ocharles/hs-quake-3
05:26:23 <cocreature> ocharles: so which cost centre are you talking about?
05:26:31 <ocharles> search for doDraw.\.face
05:26:51 <ocharles> 0 entries, yet individually it has time and allocations
05:27:05 <ocharles> I'd like to understand the general behaviour, not the first time I've seen this
05:37:32 <cocreature> hm that’s weird
05:38:55 <ocharles> isn't it just
05:39:09 <Gurkenglas> :t (alaf StateT . alaf MaybeT) (\f -> asum . map f) -- I rendered lambdabot speechless :D
05:41:27 <Gurkenglas> (It was not having imported Control.Monad.Trans.Maybe. Though that doesnt make sense either, it should error out. I'll be lambdabotquerying so dont be surprised if you interactions with him are inconsistent if you try chasing this.)
05:44:50 <ocharles> cocreature: indeed, that much I figured out :)
05:45:01 <cocreature> ocharles: sry not sure what’s going on there
05:45:06 <Sornaensis> :t alaf
05:45:08 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
05:45:09 <ocharles> np, I think I'll try StackOverflow
05:45:28 <Gurkenglas> This is how one borrows the features of "MaybeT . StateT s". How does one borrow the features of "StateT s . MaybeT"?
05:46:55 <cocreature> ocharles: it does have entries here https://gist.github.com/ocharles/538899febdc6cd857378c9923f89ed19#file-gistfile1-txt-L1495
05:48:35 <Gurkenglas> As in, what combination of alaf, StateT, MaybeT and perhaps some more gives me "Monad m => (a -> s -> m (Maybe (b, s))) -> [a] -> s -> m (Maybe (b, s))"?
05:49:41 <ocharles> cocreature: true. also surprising a bunch of compileGL stuff is there, as that's all meant to be in a strict map
05:49:46 <ocharles> Clearly not strict enough somewher
05:51:48 <ij> Shouldn't the code «map (foo . bar .)» be valid?
05:52:20 <pacak> :t \foo bar -> map (foo . bar .)
05:52:21 <lambdabot> error:
05:52:21 <lambdabot>     The operator ‘.’ [infixr 9] of a section
05:52:21 <lambdabot>         must have lower precedence than that of the operand,
05:52:48 <pacak> ij: Nope
05:53:22 <Gurkenglas> :t ?f :: Monad m => (a -> s -> m (Maybe (b, s))) -> [a] -> s -> m (Maybe (b, s)) -- Why does this error!?
05:53:24 <lambdabot> error:
05:53:24 <lambdabot>     • Could not deduce: ?f::(a1 -> s1 -> m1 (Maybe (b1, s1)))
05:53:24 <lambdabot>                             -> [a1] -> s1 -> m1 (Maybe (b1, s1))
05:55:08 <Gurkenglas> What was the command to locally install lambdabot when "stack install lambdabot" complains about extra deps?
05:56:26 <ij> Gurkenglas, Is "?f" just a name there or does the ? have some special meaning?
05:59:13 <LAZAR> Finally done with CIS 2... if someone wants to take a look at my solution and suggest an improvement I'd be super grateful, I feel it's far from being optimal... : http://lpaste.net/354674
05:59:32 <Gurkenglas> :t ?x :: Int -- ij
05:59:33 <lambdabot> (?x::Int) => Int
06:12:24 <hexagoxel> LAZAR: doesn't that give the wrong result for length 0? (fixing this also makes the code a tiny bit simpler.)
06:15:44 <ij> I've a function wrapped in «Control.Monad.Catch.catchJust (\e -> ([e] \\ [ThreadKilled]) `Safe.atMay` 0)», but this doesn't seem to catch a pattern matching failure. Is that odd?
06:17:27 <hexagoxel> LAZAR: `iterate` can replace `aCodes`.
06:18:30 <LAZAR> hexagoxel: allCodes 0 returns an empty list
06:18:43 <LAZAR> hexagoxel: how would you apply iterate there?
06:18:49 <hexagoxel> exactly :p
06:19:27 <LAZAR> well all codes of length 0, that should be an empty list? ;-)
06:19:34 <hexagoxel> i can think of more than zero sequences of colors that have length 0.
06:19:44 <hexagoxel> not much more than zero, though.
06:20:35 <LAZAR> hexagoxel: any idea how to use it with concatMap? I hate when the suggested solution turns out to be harder than my own -.-
06:21:57 <hexagoxel> LAZAR: but you use concatMap already, and i think in the way that was intended.
06:22:39 <hexagoxel> `iterate fullyExtendCodes`
06:23:45 <hexagoxel> LAZAR: maybe i am overly indirect again: what i mean is that there is a difference between returning [] and [[]].
06:24:26 <hexagoxel> the former says "there are no sequences of length 0", the latter "there is exacly one sequence of length 0: the empty one".
06:25:45 <LAZAR> hexagoxel: you are probably right but i guess since you are rarely interested in any 0-length permutations, this might not matter a lot ;-)
06:26:32 <hexagoxel> LAZAR: true, but then this behaviour only exists because you special-case the 0 case. so you can fix it by simplifying the code.
06:28:36 <hexagoxel> and being careless because you will "rarely use" some "special" case is asking for bugs later, too.
06:28:58 <Sh4rPEYE> I want to update hlint to v.2, but I installed it using Stack and on Stackage it is still at 1.9, the new version is only on hackage. WHat should I do?
06:30:28 <dysfun> can anyone recommend a library for "parsing" lists? where "parsing" here = pattern matching with all the nice tools i get from parsec, but over data?
06:30:32 <LAZAR> hexagoxel: damn when i remove that case it will loop forever
06:31:09 <jship> Is it safe to concurrently install multiple binaries from the same LTS via 'stack install'?  I've seen some stack issues/PRs from 2015 that added locking support - i.e. https://github.com/commercialhaskell/stack/pull/670.  Curious if anything has changed since then.
06:33:19 <hexagoxel> LAZAR: correct. but the empty case in fullyExtendCodes can become unnecessary.
06:33:46 <cocreature> dysfun: parsec supports custom token types
06:34:05 <dysfun> so i can "parse" a list with it?
06:34:34 <cocreature> :t runParserT
06:34:35 <lambdabot> error: Variable not in scope: runParserT
06:34:38 <cocreature> meh
06:34:47 <cocreature> you can parse anything that has a Stream instance
06:34:49 * dysfun is on his way to hackage
06:34:54 <cocreature> and lists are among those things
06:35:16 <cocreature> dysfun: unrelated to that you might want to use megaparsec which is a fork of parsec that’s actually maintained
06:35:17 <dysfun> sweet!
06:35:20 <dysfun> thank you
06:36:00 <cocreature> obviously you can’t use the combinators that are specific to unicode text if you are parsing some other type
06:36:35 <dysfun> yeah :)
06:36:49 <dysfun> i just want the combinators really
06:37:16 <dysfun> still, mind kinda blown that this works
06:37:44 <ij> Are pattern match failures catchable?
06:38:10 <Eduard_Munteanu> ij, yes, there's an exception for that
06:38:20 <Gurkenglas> ij, if a pattern match of form "Constructor x <- monadicaction" fails, that calls fail
06:38:58 <ij> It's a (a:[]) kind of match that fials.
06:39:42 <Eduard_Munteanu> https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html#t:PatternMatchFail
06:41:05 <Gurkenglas> ij, (a:[]) is [a] even for matching and that's not a form of pattern match the way I meant it because it could be "[x] <- monadicaction"
06:44:40 <Gurkenglas> How do i ask lambdabot "What type does this part of this expression need to have in order to have the whole expression have this other type?"
06:45:33 <mauke> :t [ ord ?x ] :: [Int]
06:45:34 <lambdabot> (?x::Char) => [Int]
06:46:59 <piyush-kurur> Is there no more stage restriction for TH ?
06:47:12 <Gurkenglas> :t [ ?f ] :: a
06:47:13 <lambdabot> error:
06:47:13 <lambdabot>     • Couldn't match expected type ‘a1’ with actual type ‘[t0]’
06:47:13 <lambdabot>       ‘a1’ is a rigid type variable bound by
06:47:27 <piyush-kurur> When using lens package, it looks like makeLenses can build lenses for types defined in the module?
06:55:52 <redpoppies> how does one use the servant NoContent type?
06:56:26 <redpoppies> I get " No instance for (Accept NoContent) arising from a use of ‘serve’"
06:57:41 <redpoppies> I want to define a route "login" :> Verb OPTIONS 200 '[NoContent] NoContent
07:00:33 <redpoppies> ok, it seems that media type cannot be NoContent
07:01:11 <redpoppies> so "login" :> Verb OPTIONS 200 '[JSON] NoContent
07:01:22 <redpoppies> for CORS preflight request done by hand
07:08:08 <bollu> does recursion schemes eliminate the need for "visitor pattern"?
07:13:57 <dolio> "Visitor pattern" is one of the ones they had to invent because they didn't have first-class functions.
07:15:02 <mauke> I thought visitor was because they didn't have multiple dispatch
07:15:21 <bollu> I think it also useful to keep state when you walk
07:15:24 <bollu> down an AST
07:15:39 <bollu> so, like, that would be some sort of paramorphism?
07:29:20 <centril> visitor because no proper ADTs
07:29:56 <centril> having recursive pattern matching down an AST is easy when you have case analysis
07:30:20 <centril> hence, in Rust, you can do it just like in haskell with match (case) expressions
07:38:33 <roconnor> Is it really true that Data.Array is not part of base?
07:38:47 <davean> roconnor: of course
07:39:36 <roconnor> Hmm, I forgot that the definition of base isn't what is in Haskell 2010.  ... Its what's required to build GHC??
07:40:28 <davean> several non-base packages are required to build GHC
07:40:31 <davean> array is one of them
07:41:12 <reactormonk[m]> I'm creating a little package with aeson instance for a custom data types - which module name should I use? Reusing the same one as the data type doesn't work.
07:41:14 <roconnor> oh, it's what's required for the Prelude ... plus System.IO ... I don't really get the criterion.
07:41:15 <reactormonk[m]> ... recursive import, etc.
07:58:14 <akegalj> hey guys. Are we maintainers of ircbrowse.net ? Seems like its down. Visiting http://ircbrowse.net/browse/haskell for example throws "libpq: failed (another command is already in progress)"
08:00:22 <akegalj> ok, I contacted maintener. Thanks
08:02:09 --- mode: ChanServ set +o mauke
08:02:09 --- mode: mauke set -b $a:Kristjan1983
08:02:40 <WarmCookie> Hi. I'm looking at dataflow languages / reactive programming and wondering something. In more familiar languages, people have some data (state, registers, whatever) and they manipulate the control-flow (if-else, short-circuiting, monads, etc) to transform the data... with dataflow/reactive, it's the opposite, the program stays still and it's the data that is passed around. A given block of code wont execute until all its inputs a
08:02:57 <WarmCookie> Which leads to my question; how to one guarantees the effects are carrried out in the proper order?
08:04:09 --- mode: mauke set -o mauke
08:06:59 <bvad> WarmCookie: I think you question got cut off 
08:09:02 <WarmCookie> http://lpaste.net/354680
08:09:30 <Tuplanolla> I can't talk much about reactive, but when monads are used for io, ordering is created by imposing an artificial dependency between computations.
08:09:59 <Tuplanolla> The dependent value itself, however, is erased by the compiler.
08:10:04 <WarmCookie> Tuplanolla: The thing is that monads are necessarily chained. So the sequencing of the IO actions is (more or less) easy to reason about.
08:11:26 <Tuplanolla> It shouldn't be that different in data flow paradigms. Only the dependencies may form a dag instead of a chain.
08:11:29 <WarmCookie> But I believe you're able to have independent "dependency graphs" in a given application with reactive/dataflow, and coordinating the effects seems really hard.
08:12:04 <WarmCookie> Tuplanolla: Also, does it means that with a data flow paradigms, lazy evaluation is also preferred?
08:12:36 <Tuplanolla> Not necessarily.
08:13:19 <WarmCookie> e.g. Imagine node A, B, C, D, E where A and B are connected to C, and then C and D are connected to E. What happens if C has effects?
08:13:44 <WarmCookie> *What happens if D has effects?
08:14:35 <WarmCookie> Are the effects carried out right away but the resulting value isn't needed by E until C finishes too, or only when C finishes will D be evaluated?
08:14:40 <akfp> if I have  a, b, c, d, e :: (Functor f, Monoid a) f a and I want to create a new `f a` that has mappended all of a..e, is there a way to lift <> to all of them in a simple manner?  Some applicable syntax maybe?
08:14:42 <byorgey> WarmCookie: yes, you typically want dataflow/reactive languages to be pure, because of exactly this problem.
08:15:09 <WarmCookie> byorgey: But even if it's pure, don't you have this exact problem regardless?
08:15:45 <byorgey> WarmCookie: by "pure" I mean computations have no effects.
08:15:58 <WarmCookie> byorgey: Oh, nevermind, I see what you mean. You'd have your inputs and outputs (I/O) that are effectful necessarily be terminating nodes of the graph.
08:16:14 <WarmCookie> Not in the middle.
08:16:39 <byorgey> well, even if they are terminating nodes in the graph, if there is more than one you would have the same problem.
08:17:26 <WarmCookie> byorgey: Then maybe I can design it such that you have only one input and one output that's a magical `IO`.
08:17:32 <WarmCookie> Kinda like Haskell's realworld.
08:18:25 <byorgey> this actually sounds much more like Haskell's older model for I/O, where input and output are modeled as magic lazy lists
08:18:46 <fendor> hello guys, i could not install intero since terminfo seems to be missing, any idea what could have gone wrong 
08:19:10 <rotaerk> I need a function of type DreamWorld -> RealWorld
08:19:19 <geekosaur> fendor, what platform/distro?
08:19:22 <Tuplanolla> That's you, rotaerk.
08:19:29 <c_wraith> rotaerk: have you tried coffee?
08:19:39 <rotaerk> heh
08:19:43 <byorgey> rotaerk: I can give you a function of type   DreamWorld -> IO (Maybe RealWorld), will that do?
08:19:58 <c_wraith> byorgey: that sounds almost like quantum suicide...
08:20:07 <fendor> geekosaur, solus
08:20:10 <byorgey> hehe
08:21:13 <WarmCookie> inception :: IO Dream(Dream(Dream(Dream Limbo))))
08:21:54 <WarmCookie> byorgey: Thanks for the food for thought. I'll try to work out the semantics and figure out the implications.
08:22:05 <byorgey> sure, have fun
08:22:06 <reactormonk[m]> stack build works, but cabal configure fails - it doesn't find anything.
08:24:12 <joneshf-laptop> How do you manage your hackage account?
08:24:48 <joneshf-laptop> This is the only link I see on the site: https://hackage.haskell.org/accounts
08:26:11 <hexagoxel> joneshf-laptop: http://hackage.haskell.org/user/$USER -> bottom link
08:28:14 <joneshf-laptop> hexagoxel, thanks! How did you figure that out?
08:29:11 <hexagoxel> i was aware of the /user/ pages, and the rest is trivial.
08:29:38 <joneshf-laptop> k
08:30:00 <hexagoxel> so you think it is not very reachable from frontpage, you may be right :)
08:30:16 <hexagoxel> s/so you/so if you/
08:31:58 <geekosaur> fendor, do you have the ncurses package installed? (OS package *not* haskell package)
08:32:23 <reactormonk[m]> Can I somehow pull in arbitrary instances from the tests of another package?
08:32:34 <joneshf-laptop> hexagoxel, :)
08:34:06 <fendor> yep
08:39:37 <sternenseemann> reactormonk[m]: you can, but I wouldn't recommend it, if you don't already depend on that package
08:39:45 <sternenseemann> reactormonk[m]: because, dependency hell etc.
08:39:47 <geekosaur> then I think you need to provide more information. I'm not familiar with solus but I did trck down its ncurses package and it looks like it should work
08:39:52 <geekosaur> @paste full build log
08:39:52 <lambdabot> Haskell pastebin: http://lpaste.net/
08:40:01 <geekosaur> ^ pastebin, NOT into the channel!
08:40:45 <reactormonk[m]> sternenseemann: oke.
08:41:29 <sternenseemann> reactormonk[m]: it is imported if you do something like import Module (Type (..)), then you should have the instances as well…
08:43:29 <glguy> reactormonk[m]: No, you can't depend on the tests of another package
08:43:52 <glguy> at least if the tests are actually in their own tests component of the package
08:48:17 <reactormonk[m]> So there's no way to declare a non-orphan instance outside of the origin package of the data type?
08:48:48 <hexagoxel> `reachable :: Ord a => [a] -> Map a [a] -> Set a` does not exist somewhere already, does it?
08:48:51 <ongy> to not be orphan you have to be in either the types or classes definition file
08:50:23 <cocreature> reactormonk[m]: an instance is already considered orphan if it is defined outside of the _module_ (not package) of either the class or the data type.
08:50:25 <geekosaur> 'orphan' is not a state you can set, 'orphan' is a description of it not being defined in the same place as either the class or the instance
08:50:29 <Gurkenglas> Why don't we have orphan instances attached to the relevant modules by the compiler so searching for instances isn't a problem?
08:50:54 <Gurkenglas> Hackage could make links like with reverse dependencies, and ghci could say where instances come from
08:51:17 <joneshf-laptop> hexagoxel, oh wow, this is a thing: https://hackage.haskell.org/api
08:52:55 <joneshf-laptop> I don't understand half of what it's saying though.
08:52:57 <glguy> Gurkenglas: If you load the package with an orphan instance into GHC, then GHC knows about the orphan instance. It's not a compiler problem
08:53:44 <butterthebuddha> Hey peeps, was reading through Learn You Haskell. The chapter on types and type classes says that the "Double" type has "double the precision". Is this strictly true, or they really mean "double precision" (which doesn't really mean double the precision, just double the bytes needed to store the number)
08:54:32 <Gurkenglas> glguy, but wasn't there a problem with ghc not knowing what modules orphan instances define instances for, and then each instance search has to go through the modules of the class, the type and all orphan modules for anything?
08:54:33 <davean> Gurkenglas: You're missing the problem
08:54:47 <davean> Gurkenglas: The problem is conflicts
08:54:58 <geekosaur> yes, it's being loose. it means whatever the platform floating point hardware means, which is usually its interpretation of what IEEE754 says
08:55:08 <davean> Gurkenglas: The orphan instances rules are about guarrenteeing stability of resolution
08:55:09 <geekosaur> ^ butterthebuddha 
08:55:57 <butterthebuddha> geekosaur: Shouldn't the book be clear about "double precision" vs "double the precision" then?
08:56:05 <Gurkenglas> davean, ah. Are there already instances today where you can't have too many dependencies because then you get double orphans?
08:56:19 <geekosaur> butterthebuddha, if you can find the author then yes, thats a valid complaint to make
08:56:24 <geekosaur> the author is not here
08:56:43 <mnoonan> that seems like a white lie, at least.. doubles have more than double the precision of singles, if you measure by mantissa
08:56:43 <geekosaur> the author has not been seen since publishing it, and there's a long list of issues with the book
08:56:52 <geekosaur> to the point that some of us disrecommend its use
08:56:57 <davean> Gurkenglas: Sure, but you're still missing hte problem
08:56:57 <butterthebuddha> Ah, in that case, is there a better book I should use?
08:57:11 <geekosaur> @where learnhaskell
08:57:11 <lambdabot> https://github.com/bitemyapp/learnhaskell
08:57:16 <geekosaur> ^ list of resources
08:57:22 <glguy> butterthebuddha: Floating-point numbers aren't the point of the book. If you're hoping to learn about the details of IEEE 754, there are much better resources.
08:57:40 <geekosaur> Gurkenglas, orphan instances are a matter of cognitive load, not compile failures
08:57:44 <butterthebuddha> glguy: I know that, but "double the precision" is just factually wrong, isn't it?
08:57:58 <tabaqui> I need a some really fast search structure, but GC makes my current IntMap much slower after some time
08:58:12 <tabaqui> I need about 4k requests per second
08:58:26 <tabaqui> typical loop - insert, 3-4 search and delete
08:58:29 <glguy> butterthebuddha: Probably, but it just doesn't matter in this context
08:58:50 <tabaqui> is there something much faster than IntMap?
08:58:59 <tabaqui> *3-4 searches
08:59:00 <geekosaur> well, they can be a source of compile failures when multiple orphans conflict, but that is again no a problem with the compiler, it's a problem with users of modules knowing what instances are where
08:59:15 <geekosaur> tabaqui, often Map itself is faster, or HashMap from unordered-containers
08:59:18 <geekosaur> try it and benchmark
08:59:26 <davean> Gurkenglas: The orphan rules are about not being surprised by *which* instance you get
09:00:25 <tabaqui> geekosaur: yeah, I know about containers/unordered-containers
09:00:26 <Tuplanolla> It's "double the precision" if you accept that 52 is roughly 23 times two, butterthebuddha.
09:00:43 <davean> Gurkenglas: non-orphan instances *will always cause a conflict* with an orphan, leading to a compile error so you never are at risk of having a non-orphan instance vary due to your includes
09:01:09 <davean> Gurkenglas: orphan instances can lead to various instance resolution by what you dependd on and include
09:01:15 <tabaqui> dunno, maybe somebody is working on *specific* library
09:03:10 <cocreature> tabaqui: you only need search and not insert?
09:04:15 <davean> Gurkenglas: do you now understand the issue with orphan instances?
09:06:35 <butterthebuddha> Uh, I have a more conceptual question about functional programming. I haven't had much exposure to functional programming before, but as a C programmer, I'm a little uncomfortable with the idea of variables never changing their value
09:06:36 <tabaqui> cocreature: full pocket: insert, search, delete
09:06:44 <butterthebuddha> Doesn't this lead to a lot of memory wastage?
09:06:53 <cocreature> tabaqui: ah ok, then a sorted unboxed vector won’t work
09:07:02 <davean> butterthebuddha: why would it? ;)
09:07:26 <davean> butterthebuddha: it can lead to no wastage at all
09:07:27 <butterthebuddha> davean: I'm imagining a situation where I have a _reaaaalllly_ big list
09:07:39 <davean> butterthebuddha: ok, so what?
09:07:51 <butterthebuddha> To simply double every element of said list, I have to declare a *new* list
09:08:02 <butterthebuddha> Which means I'm not using double the memory
09:08:08 <tabaqui> butterthebuddha: actually, haskell arrays make programmers cry
09:08:09 <geekosaur> not always
09:08:11 <davean> Nope, you're not
09:08:21 <davean> butterthebuddha: not if you only want the doubled list
09:08:22 <tabaqui> but usually you can avoid them
09:08:35 <davean> butterthebuddha: the first list is no longer referenced, so it doesn't have to be in memory
09:08:40 <butterthebuddha> I imagine haskell has some way of optimizing this, and I'd love to how
09:08:43 <davean> it might be in memory, it might not
09:08:44 <butterthebuddha> know how*
09:08:45 <geekosaur> purity means the compiler can detect that nothing else is using it and mutate it in place. you describe what you want and let the ocmpiler figure out how to do it, rather than spelling it out
09:08:55 <tabaqui> davean: QuickSort is still a problem
09:09:18 <Gurkenglas> davean, because it can cause silent compilation errors when you include the wrong thing, like anything else can, but only rarely, because usually the type is also wrong?
09:09:35 <Gurkenglas> -compilation
09:09:43 <davean> Gurkenglas: bah, no, you've missed it entirely
09:09:56 <butterthebuddha> geekosaur: and I imagine the list isn't mutated in place I do reference the original list again?
09:10:00 <hsk3> Using Haskell Stack with Docker. Why do they make it sound like this complicated mess? https://docs.haskellstack.org/en/stable/docker_integration/
09:10:00 <hsk3> Shouldn't it just be as simple as 1. creating a new docker image based on ubuntu, 2. download the stack binary, 3. download (or use from mounted volum) and compile your stack program, and 4. launch your executable with stack?
09:10:01 <hsk3> Why do they complicate things so much with that other stuff there, such as permissions stuff?
09:10:10 <hsk3> What am I missing?
09:10:17 <geekosaur> butterthebuddha, it's not whether you reference it again, it's what *else* is referencing it
09:10:26 <Gurkenglas> hah, missed a "not" in your line davean
09:11:06 <butterthebuddha> OKay yeah, that makes sense. *sigh* the idea of trusting the compiler to do this for me still makes me uncomfortable as an imperative programming :)
09:11:06 <Gurkenglas> sure, if there's a non-orphan instance then you can't write orphans because they'd overlap
09:11:09 <butterthebuddha> programmer*
09:11:14 <davean> butterthebuddha: as soon as you no longer reference something, the system is allowed to free that memory, that memory might be instantly reused
09:11:17 <Tuplanolla> In C terms, butterthebuddha: if you have two `const` variables with disjoint use sites in scope, they'll most likely live in the same register.
09:11:44 <Gurkenglas> If not knowing where to look for the orphan isn't the problem, and two orphans from different packages aren't the problem, what's the problem?
09:11:59 <Tuplanolla> You have to trust the compiler to do that too.
09:12:05 <EvanR> yeah you already rely on mysterious C compiler behavior to get performance
09:12:39 <EvanR> C runs on a virtual machine which people have vague ideas about performance, only becoming concrete through the compiler
09:13:11 <geekosaur> hsk3, I "love" it when "why complicate with ... permissions stuff" comes up, it demonstrates why some programmers are why websites get compromised all the time
09:13:51 <hsk3> geekosaur well in that case they're actually reducing security a bit, as explained..
09:14:54 <hsk3> i'm just wondering why they make things sound special. why build a "docker" command into stack? ("stack docker ...")
09:14:54 <hsk3> i wonder why it's not just like any other program that you happen to run inside of a docker image
09:14:55 <hsk3> i.e., why stack isn't totally unaware of docker
09:14:56 <hsk3> :)
09:15:00 <davean> EvanR: C is a lovely template language for ASM
09:15:11 <centril> butterthebuddha: you might be interested in Rust - which is sorta imperative but also pretty functional and is a systems programming language with stronger guarantees about mutation, no data-races, etc.
09:15:18 <EvanR> no its not
09:15:27 <EvanR> except for the part where you can inline asm
09:16:07 <centril> davean: if C is a lovely template language for ASM, then so is Haskell...
09:16:19 <davean> centril: nah, that doesn't hold
09:16:26 <EvanR> so much asm cant be accessed with regular C code, assuming you know what the compiler will do
09:16:34 <butterthebuddha> EvanR: I do rely on compilers optimizing my code, but it's still lower level than Haskell
09:16:40 <centril> EvanR: usually you have intrinsics
09:17:08 <butterthebuddha> (I have more control of what the hardware is gonna do in terms of memory etc.)
09:17:09 <centril> butterthebuddha: what do you mean by "lower level" ?
09:17:11 <EvanR> ghc has that
09:17:35 <EvanR> no doubt C is a lower level language, just that isnt very precise
09:17:49 <butterthebuddha> That said, my knowledge of Haskell doesn't extend beyond defining variables at this point
09:17:56 <EvanR> not to mention at one point C was considered high level !
09:18:05 <davean> EvanR: GHC doesn't really have intrinsics, see SSE/AVX issues for an example
09:18:06 <centril> butterthebuddha: manual memory manipulation + memory addressing doesn't mix well with purity
09:18:17 <EvanR> yes right about that
09:18:37 <davean> EvanR: its really sad, if we *did* I'd do so much more
09:18:46 <EvanR> centril: you can have a big blob of mutable bytes
09:18:51 <davean> but it doesn't really give you guarentees that lead to nice intrinsics
09:18:54 <EvanR> it just not the entire process space
09:18:59 <butterthebuddha> centril: Yep, I understand that. I am actually learning Rust right now.
09:19:07 <centril> butterthebuddha: Rust is strongly typed unlike C
09:19:18 <anohigisavay> hi. i'm submitting some haskell code on an OJ system. and it does not meet the time demand
09:19:28 <butterthebuddha> I was really intrigued by functional programming, which is why I'm learning Haskell right now
09:19:48 <EvanR> nice
09:19:55 <centril> EvanR: you can have a big blob of mutable bytes, but how are you going to mutate them outside of the IO monad and preserve purity ?
09:19:56 <rotaerk> anohigisavay, OJ system? time demand?
09:19:57 <EvanR> i hope your mind explodes regularly
09:20:12 <mauke> orange juice
09:20:15 <butterthebuddha> EvanR: that's the plan haha
09:20:18 <EvanR> centril: youre either not because its not important, or theres ST
09:20:26 <rotaerk> OJ System is innocent !
09:20:50 <Brokenprogrammer> zz
09:20:54 <mauke> programming exercise / online judge
09:20:57 <anohigisavay> rotaerk, online judge system. it has ghc which i have no idea which version
09:21:09 <centril> EvanR: well, that would involve RealWorld
09:21:10 <statusbot> Maintenance update: performing restart now -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/58f4e495c9a00f490e000589
09:21:16 <EvanR> centril: you can also do it purely, and lose efficiency
09:21:17 <anohigisavay> http://lpaste.net/354683
09:21:31 <EvanR> centril: RealWorld? i dont think that is correct
09:21:42 <Brokenprogrammer> @mauke is there online judges with exercises that accepts Haskell ?
09:21:42 <lambdabot> Unknown command, try @list
09:21:51 <anohigisavay> seems most of the time is spent on I/O
09:22:03 <centril> EvanR: the whole point of impure mutability is efficiency here
09:22:19 <EvanR> if you want to use haskell like C in the capacity that you have "control over memory" then you can in various ways
09:22:20 <centril> anyways... back to work...
09:22:22 <EvanR> just saying
09:22:42 <EvanR> i would argue thats not entirely the whole point, in some cases it actually just makes more sense to solve your problem that way
09:22:49 <mauke> Brokenprogrammer: http://www.spoj.com/
09:22:58 <EvanR> but you can also get efficiency in ghc
09:23:17 <Brokenprogrammer> mauke: Thanks buddy! :)
09:23:37 <anohigisavay> the question is about reversing a linked list every n elements
09:25:19 <Tuplanolla> The repeated calls to `putStr` worry me, anohigisavay.
09:25:50 <anohigisavay> Tuplanolla, i was using printf, but it gets worse
09:25:55 <statusbot> Maintenance update: hackage is up again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/58f4e495c9a00f490e000589
09:26:04 <Tuplanolla> It might be a better idea to concatenate the string and call `putStr` once.
09:26:28 <Tuplanolla> Using `shows`, that is.
09:26:40 <anohigisavay> Tuplanolla, thanks, will give it a try
09:27:13 <Tuplanolla> Not `show`, mind you.
09:27:46 <anohigisavay> Tuplanolla, shows :: Show a => a -> ShowS ?
09:27:58 <anohigisavay> thanks, first time i knew it
09:31:43 <sam1902> Hello, world !
09:32:02 <lambdabot> Hello.
09:38:23 <sam1902> Haskell is awesome
09:41:44 <edwardk> sam1902: such is my experience as well
09:42:32 <anohigisavay> Tuplanolla, thanks! now it has huge speed boost, and total alloc is down by a half
09:42:38 <sam1902> edwardk: I'm learning (started 5 minutes ago) and following a tutorial. The author call the language "lazy", is that the term used in english to describe it ?
09:42:47 <anohigisavay> but still time exceeded
09:42:59 <anohigisavay> i now worry there's bug in my code
09:43:33 <edwardk> sam1902: 'lazy' is referring to the fact that in most languages when I give you an Int or something it is a machine integer. in haskell it is instead some computation that will produce a machine integer when finally asked and won't do any work up until it is 'forced' to do so, whereupon it'll replace itself with its answer.
09:43:57 <edwardk> this means you can call functions with as-yet-undetermined values for arguments, and if the function doesn't use them it can still terminate, even if it
09:44:02 <butterthebuddha> How do you guys recommend unit testing in Haskell?
09:44:04 <edwardk> 'd take forever to compute those things
09:44:20 <edwardk> butterthebuddha: i tend to write doctests and use lots of parametricity to ensure that thats good enough
09:44:40 <sam1902> Ok that's what I thought, thanks for confirming my beliefs ^_^
09:44:45 <butterthebuddha> I was going through HUnit's documentation, and I'm having a hard time understanding :(
09:45:19 <anohigisavay> (i always wonder how to test IO. say HTTP requests and mock/shim stuff
09:45:27 <edwardk> sam1902: when everything in your language is lazy  you have to care a lot about side-effects, this leads to all the initially weird seeming stuff about monads and the like, but once you get your head around it, you can find that algorithms tend to compose better when they are made out of lazy parts
09:46:01 <sam1902> Oh ok, that'll be interesting I think
09:46:02 <edwardk> anohigisavay: write a class for the operations you want to supply, then build a mocked up interface using a custom monad, test against that specification.
09:46:10 <srhb> butterthebuddha: You were just getting started right? Test driven development usually looks a lot different in Haskell. I wouldn't really spend my time there initially. :)
09:46:17 <srhb> Not that HUnit is hard or anything.
09:46:23 <srhb> There are just better ways to spend your time initially.
09:46:42 <edwardk> :t readFile
09:46:44 <lambdabot> FilePath -> IO String
09:46:56 <anohigisavay> edwardk, wow thanks that sounds promising :D
09:47:11 <edwardk> class Monad m => MonadReadFile m where readFIle :: FilePath -> m String
09:47:21 <edwardk> instance MonadReadFile IO where readFile = Prelude.readFile
09:47:40 <edwardk> now you can make your own mock monad with its own instance that, say, dumps fixed text out
09:47:47 <edwardk> or whatever you want
09:47:51 <anohigisavay> oh i see, looks easier than i thought :)
09:48:04 <edwardk> for a more advanced version you can use free monads and/or data types a la carte, etc.
09:48:29 <butterthebuddha> srhb: yeah makes sense
09:48:37 <butterthebuddha> I can't figure out which library to include to make "print" work though :/
09:48:49 <srhb> butterthebuddha: print is in Prelude, so imported by default.
09:48:59 <srhb> butterthebuddha: You may be confused because print isn't putStrLn ?
09:49:25 <sam1902> How to you exite ghci's "Prelude>" thing ?
09:49:30 <edwardk> anohigisavay: that said, there is also Test.QuickCheck.Monadic, etc. which can be used to test simple, reproducible IO actions
09:49:35 <butterthebuddha> sam1902: EOF (Ctrl-D)
09:49:39 <edwardk> anohigisavay: so you have more than one option here
09:49:40 <srhb> sam1902: :exit, :quit, Ctrl-d
09:49:46 <sam1902> Oh, so Ctrl-C don't qork
09:50:06 <butterthebuddha> srhb: aight. I am getting a "naked expression at top level" error that I'm not sure how to fix
09:50:07 <sam1902> and :exit don't work too
09:50:10 <sternenseemann> sam1902: yeah, Ctrl-C is for terminating the execution of things you entre there
09:50:12 <sam1902> but :quit do, thanks
09:50:17 <sternenseemann> sam1902: like endless recursion
09:50:23 <sam1902> ok
09:50:27 <srhb> butterthebuddha: You can't simply have expressions at the top level. Only name = value pairs (and some other things you'll get to)
09:50:29 <butterthebuddha> srhb: and it's on the line I am calling my print fuction on
09:50:32 <sam1902> I usually exit any program 
09:50:35 <sam1902> too
09:50:42 <butterthebuddha> srhb: "print todigits 23 == [2, 3]"
09:50:52 <srhb> butterthebuddha: Oh.
09:51:17 <srhb> butterthebuddha: You probably mean `main = print (toDigits 23 == [2, 3])
09:51:26 <byorgey> butterthebuddha: that looks like something you would enter at the ghci prompt.  You can't just have expressions on a line by themselves in a .hs file
09:52:28 <butterthebuddha> Aight
09:52:45 <butterthebuddha> I'm also curious how the "print" function works without having any side effects
09:52:52 <butterthebuddha> Isn't printing by definition a side effect?
09:52:57 <srhb> butterthebuddha: Down the rabbit hole you go... :-)
09:54:00 <butterthebuddha> Can I assign to "main" multiple times if I want to have multiple print statements?
09:54:15 <srhb> butterthebuddha: No, but look up do notation. Do you have a reference book or something you're following?
09:54:29 <butterthebuddha> I'm working through this -> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:54:40 <srhb> butterthebuddha: You'll get to it then. :)
09:54:55 <butterthebuddha> But I need to check if my function definitions work
09:55:01 <sam1902> What mean "NaN" ? I tried to do 8/0 and the prompt returned Infinity so I tried to do 8/0*0 and it said "NaN"…
09:55:12 <srhb> sam1902: Not A Number
09:55:15 <sam1902> Oh
09:55:24 <sam1902> ok, great
09:55:46 <Hafydd> sam1902: that is specific to IEEE 754 floating point numbers: https://en.wikipedia.org/wiki/NaN
09:56:22 <sam1902> I don't have to read every docs
09:56:31 <Hafydd> Compare for integers:
09:56:37 <sam1902> I do read some (e.g. Haskell)
09:56:40 <Hafydd> > (1 `div` 0) * 0
09:56:42 <lambdabot>  *Exception: divide by zero
09:57:00 <sam1902> > 8/0*0
09:57:02 <lambdabot>  NaN
09:57:15 <EvanR> if you dont understand it, you cant control it
09:57:18 <sam1902> Oh so you've got an Haskell bot, that's great !
09:57:38 <EvanR> were lucky to have docs in some cases to help understanding
09:58:00 <sam1902> Yep, but no need to read all of them if you don't need "help to understand"
09:58:04 <geekosaur> ieee floating point is something you have to understand, really, and most programmers don't bother and then wonder why they get weird behavior
09:58:51 <srhb> butterthebuddha: Okay, I feel sort of bad giving you the "short story" but... :-P http://lpaste.net/5509242515804389376
09:59:11 <srhb> butterthebuddha: Basically it's a shorthand form of composing multiple "actions" (which, again, you'll get around to)
10:00:38 <srhb> butterthebuddha: week 8 of the spring 2013 version has the real story.
10:01:16 <srhb> butterthebuddha: It also answers your other question wrt. side effects somewhat, but I really recommend taking it in order :-)
10:10:15 <butterthebuddha> Sooo I'm trying to return the reverse of a number as list of digits
10:10:28 <butterthebuddha> And I'm not sure how to go from 001 -> [1, 0, 0]
10:11:44 <butterthebuddha> This is what I have so far -> https://gist.github.com/awesomeaniruddh/a3dcd590d0e9233d42e68bc883f1263c
10:12:18 <srhb> > 001
10:12:20 <lambdabot>  1
10:13:15 <cocreature> you can’t differentiate between the Integer 001 and the Integer 1
10:13:23 <sternenseemann> > 001 == 1
10:13:26 <lambdabot>  True
10:13:48 <butterthebuddha> Aight, I won't worry about it then :P
10:14:00 * geekosaur wonders what language butterthebuddha is used to?
10:14:07 <sternenseemann> indeed
10:14:10 <cocreature> iirc they mentioned C
10:14:17 <butterthebuddha> I just kinda forgot that that was a thing :P
10:14:24 <srhb> :-)
10:14:30 <butterthebuddha> (I've been working a lot with strings lately)
10:14:39 <srhb> You ruined the "guess the weird language game" now, though :-P
10:14:50 <Hafydd> Perhaps bash.
10:14:52 <sternenseemann> I don't think C has that problem
10:14:57 <sternenseemann> It can't
10:15:06 <sternenseemann> as long as you store numbers in binary form…
10:15:09 <cocreature> if in doubt the answer is always bash, php or perl
10:15:19 <butterthebuddha> ++ JavaScript
10:15:22 <Hafydd> (But in bash, integer literals starting with 0 are octal.)
10:15:22 <sternenseemann> inb4 php $number="000001234"
10:15:40 <butterthebuddha> Although JavaScript doesn't do that either afaik 
10:16:14 <Hafydd> -" literal"
10:16:45 <sternenseemann> haha
10:18:23 <srhb> Wow, the error messages get strange when you feed ghc invalid literals
10:18:28 <srhb> > 0o8
10:18:29 <lambdabot>  error:
10:18:30 <lambdabot>      • Variable not in scope: o8
10:18:30 <lambdabot>      • Perhaps you meant one of these:
10:18:59 <mauke> > 0 o8
10:19:01 <lambdabot>  error:
10:19:01 <lambdabot>      • Variable not in scope: o8
10:19:01 <lambdabot>      • Perhaps you meant one of these:
10:19:35 * geekosaur was thinking tcl, actually :p
10:19:37 <mauke> > let xs = [1,2,3] in elem 2xs
10:19:39 <lambdabot>  True
10:19:51 <srhb> I.. what.
10:20:10 <Hafydd> GHCi is offended by your insolence! >8o
10:20:12 <srhb> I never knew that was a thing. :-P
10:20:32 <srhb> A whole new level of obfuscation awaits.
10:20:32 <mauke> it's also a thing in perl
10:20:37 <mauke> but not C, funnily enough
10:21:09 <mauke> in C it's a preprocessing number IIRC
10:21:10 <sternenseemann> it is possible to make valid gif files, that are valid haskell files
10:21:11 <butterthebuddha> Can I get the index of an element in a list comprehension?
10:21:14 <mauke> which is then a hard error
10:21:18 <shapr> sternenseemann: I like that idea
10:21:22 <butterthebuddha> I need to perform a computation on every other element of a list
10:21:23 <shapr> sternenseemann: yeah, it's totally possible
10:21:26 <srhb> butterthebuddha: They don't have indexes, it's alinked list, but you can build one.
10:21:36 <geekosaur> butterthebuddha, we generally zip with an index in that case
10:21:39 <Hafydd> sternenseemann: especially if they are literate Haskell files.
10:21:44 <sam1902> > cos pi/2
10:21:44 <geekosaur> and yes, lists are linked lists, not arrays/vectors
10:21:46 <lambdabot>  -0.5
10:21:50 <ongy> > 015
10:21:52 <lambdabot>  15
10:22:04 <mauke> butterthebuddha: zip [0 ..] yourListHere
10:22:07 <sam1902> cos (pi/2)
10:22:14 <sam1902> > cos (pi/2)
10:22:14 <ongy> what's used for base8 literals in ghc?
10:22:16 <lambdabot>  6.123233995736766e-17
10:22:24 <mauke> > 0o15
10:22:27 <lambdabot>  13
10:22:27 <srhb> ongy: 0o or 0O
10:22:29 <sam1902> isn't that supposed to be 0 ???
10:22:50 <ongy> oh, that was 0o8 earlier, /me fails to parse
10:22:56 <srhb> sam1902: Function application has higher precedence than operator application
10:23:04 <mauke> sam1902: welcome to floating point numbers
10:23:08 <Hafydd> 0ongy
10:23:12 <ongy> both exist, but the 0o fit's better with 0b and 0x
10:23:13 <sternenseemann> shapr: I've done it already for a ctf, you had to upload a gif to execute it. You have to make the gif header sequence a data type and a Num instance for it…
10:23:25 <srhb> sam1902: Oh, you saw that :)
10:23:29 <sternenseemann> Hafydd: it works with normal one as well.
10:23:44 <sternenseemann> Hafydd: but .lhs is probably easier, indeed :D
10:24:00 <mauke> sternenseemann: https://raw.githubusercontent.com/mauke/poly.poly/master/yes.c
10:24:08 <sam1902> srhb: why do you mean ? if I ask the cos of pi/2 I'm hoping to get 0 so is that a problem of floating point or og haskell ?
10:24:11 <geekosaur> > showFFloat (Just 6) (cos (pi / 2)) ""
10:24:13 <lambdabot>  "0.000000"
10:24:31 <geekosaur> sam1902, haskell is "at fault" in showing full precision by default
10:24:34 <sternenseemann> mauke: haha!
10:24:35 <geekosaur> floating point is not exact
10:24:37 <srhb> sam1902: I was answering regarding the difference between cos (pi/2) and (cos pi)/2, which you never asked for. ;-)
10:24:44 <butterthebuddha> Better way to write this? -> "doubleEveryOther n = [ c + c | i <- [0..], c <- reverse n, i `mod` 2 == 0 ]"
10:24:48 <sam1902> Ok so it's just floating point, ok fine
10:24:57 <EvanR> > cos (pi/2) :: CReal
10:24:59 <lambdabot>  0.0
10:25:05 <EvanR> hehe
10:25:08 <sam1902> srhb: Yeah I noticed something was wrong and I corrected it ^^
10:25:16 <sternenseemann> > 0.2 + 0.3
10:25:18 <lambdabot>  0.5
10:25:22 <sam1902> > cos(pi/2) * 5
10:25:24 <lambdabot>  3.061616997868383e-16
10:25:29 <geekosaur> see the showFFloat I did earlier which uses a specified precision for display
10:25:30 <sternenseemann> > 0.1 + 0.2
10:25:32 <lambdabot>  0.30000000000000004
10:25:35 <sternenseemann> sam1902: ^
10:25:43 <sternenseemann> welcome to ieee floating point
10:25:45 <mnoonan> butterthebuddha, I don't know that it's better, but you could do..
10:25:56 <sam1902> what does the other F stands for in showFFloat ?
10:26:00 <mnoonan> > [ f x | (f,x) <- zip (cycle [id, reverse]) (words "This is a test.")]
10:26:02 <EvanR> get real
10:26:02 <lambdabot>  ["This","si","a",".tset"]
10:26:23 <EvanR> show Formatted Float
10:26:29 <mnoonan> or
10:26:39 <mnoonan> > zipWith ($) (cycle [id, reverse]) (words "This is a test.")
10:26:41 <lambdabot>  ["This","si","a",".tset"]
10:26:48 <Cale> geekosaur: Yeah, I wonder how many complaints would be saved by simply leaving out the last digit
10:26:50 <sam1902> Oh thanks EvanR
10:26:59 <EvanR> same as the f in printf
10:27:02 <srhb> Cale: Eek. :-P
10:27:30 <geekosaur> actually it's F vs. E vs. G corresponding roughly to printf's %f %e %g
10:27:44 <sternenseemann> > printf "%.3f" (0.1 + 0.2)
10:27:46 <lambdabot>  error:
10:27:47 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M475656480139...
10:27:47 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
10:27:54 <sternenseemann> > printf "%.3f" (0.1 + 0.2 :: Double)
10:27:54 <geekosaur> and indeed there are also showEFloat and showGFloat
10:27:56 <lambdabot>  error:
10:27:56 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M225227277666...
10:27:56 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
10:28:00 <sternenseemann> ahrg
10:28:03 <geekosaur> you need a type
10:28:08 <ongy> the result of printf is something weird in haskell
10:28:09 <geekosaur> because printf is an evil hack
10:28:10 <Tuplanolla> > printf "%.3f" (0.1 + 0.2 :: Double) :: String
10:28:12 <lambdabot>  "0.300"
10:28:13 <EvanR> oh, so it doesnt correspond to any word
10:28:32 <geekosaur> floating, exponential, general, I think
10:28:37 <sternenseemann> Tuplanolla: thx!
10:28:44 <geekosaur> where floating means the "conventional" floating decimal point
10:29:01 <Cale> > showFFloat (Just 16) (0.1 + 0.2)
10:29:01 <geekosaur> and "general" switches between F and E depending on the size of the number
10:29:03 <lambdabot>  <[Char] -> [Char]>
10:29:05 <Cale> > showFFloat (Just 16) (0.1 + 0.2) ""
10:29:07 <lambdabot>  "0.3000000000000000"
10:29:09 <sam1902> geekosaur: Whut I think there is a problem with showFFloat
10:29:26 <sam1902> geekosaur: whe I try   showFFloat (Just 6) (cos (pi / 2)) ""    I got an error
10:29:33 <geekosaur> import Numeric
10:29:39 <sam1902> oh thanks
10:29:48 <geekosaur> lambdabot has it imported by default, but ghci doesn't
10:29:52 <sam1902> ok that's way better
10:30:05 <geekosaur> @index showFFloat
10:30:06 <lambdabot> Numeric
10:30:08 <ongy> Numeric has a few interesting functions that should be more popular
10:30:37 <Tuplanolla> Fractional modulo when?
10:30:38 <sternenseemann> sam1902: if you want to have exact floating points, have a look at exact-real or similar packages
10:30:48 <sternenseemann> iirc exact-real has poor docs
10:31:16 <sam1902> sternenseemann: ok dank ^^
10:31:19 <EvanR> exact-real is documented fine
10:31:37 <sternenseemann> EvanR: oh okay, maybe I mixed up something there
10:31:46 <ongy> exact floating points in finite memory? What did I miss?
10:31:47 <EvanR> the one in lambdabot is Data.Number.CReal in the numbers package
10:32:01 <EvanR> "exact floating point" is not right
10:32:04 <Cale> ongy: The secret is they're not floating point
10:32:15 <sam1902> > "sam1902 is going afk now"
10:32:17 <lambdabot>  "sam1902 is going afk now"
10:32:46 <sam1902> > " > \"inception ?\" "
10:32:48 <lambdabot>  " > \"inception ?\" "
10:33:10 <ongy> > text "> \"Hi\""
10:33:12 <lambdabot>  > "Hi"
10:33:15 <Cale> ongy: They're more likely something along the lines of functions which, given n will produce a rational approximation within 1/2^n of the appropriate real number.
10:33:20 <Zemyla> Oh, someone mentioned something about ADTs with mutable variables to Haskell, like somehow, say, data Test s = Test (Mutable s Float) (Mutable s Int) or something along those lines?
10:33:30 <sternenseemann> ongy: CReal restricts the precision explicitly iirc
10:33:45 <Cale> sternenseemann: It's infinite precision.
10:34:00 <Cale> You only need to pick a precision to display at
10:34:05 <cocreature> Zemyla: there is a GHC proposal about that
10:34:07 <EvanR> one implementation of reals is a sequence of dyadic rationals that approaches some limit, so a Natural -> Rational, the bigger n, the more precise and the more computation it takes to give you an approximation
10:34:11 <sternenseemann> Cale: oh nice
10:34:35 <Cale> Which makes sense, because otherwise if you tried to display 1, it wouldn't terminate
10:34:53 <EvanR> 1 is a rational so the approximation is trivial
10:34:59 <sternenseemann> Cale: My only encouter with CReal was me fixing quickcheck properties, that would fail with Double :D
10:35:07 <EvanR> but sin(p/2) wouldnt terminate
10:35:14 <bollu> EvanR: wow, so you literally store the cauchy sequence?
10:35:17 <Cale> EvanR: But there's no way to tell that
10:35:17 <bollu> that's mad
10:35:30 <Zemyla> cocreature: Is there a link?
10:35:31 <EvanR> many exact real systems have a special case for rationals
10:35:34 <EvanR> known rationals
10:35:47 <EvanR> bollu: you dont store it, you express it as a program
10:35:52 <cocreature> Zemyla: https://github.com/ghc-proposals/ghc-proposals/pull/8
10:35:53 <bollu> EvanR: yeah, I meant that
10:36:05 <Cale> EvanR: it might be 0.999999999999999999999999999999999999999999999999999997 or something, and the first bunch of approximations you try will be indistinguishable from 1
10:36:15 <Cale> but you were supposed to have been printing 9's and not 1.00...
10:36:20 <Cale> and you can't know
10:36:24 <bollu> Cale: in general, testing if a number in R is computable or not is undecidable right?
10:36:25 <EvanR> youre talking about digit sequences
10:36:29 <EvanR> not rational approximations
10:36:44 <Cale> bollu: sure
10:36:46 <EvanR> reals are provably not synonymous with digit sequences
10:37:07 <Cale> EvanR: I'm talking about the function which displays the computable real
10:38:14 <EvanR> you mean output digits?
10:38:18 <Cale> yes
10:38:27 <EvanR> yeah you cant really do that
10:38:30 <Cale> It's not really possible to stream out digits, because it can be impossible to know ahead of time which side of 1 you're going to land on
10:38:46 <EvanR> but you can always output a rational approximation
10:38:56 <Cale> right
10:38:59 <EvanR> and we already know digits are a bad way to show that anyway
10:39:07 <Cale> I was just explaining why you need to tell it how many digits to show
10:39:07 <EvanR> since it doesnt terminate
10:39:29 <EvanR> you need to tell it how many digits, but they arent necessarily going to be all right
10:39:44 <Cale> bollu: Also, any nontrivial predicate on the computable reals is uncomputable.
10:40:17 <ongy> lambdabot is being mean. It sanitizes output :(
10:40:17 <EvanR> bollu: if its not computable, how would you even input it into a test program
10:40:47 <EvanR> in fact, once you start getting into this, i see the evidence of uncomputable reals even existing being pretty slim
10:40:50 <Cale> e.g. Checking if a computable real is positive is uncomputable
10:40:53 <Cale> hm?
10:41:00 <Cale> What do you mean by "existing"?
10:41:04 <EvanR> classical existence
10:41:07 <EvanR> i.e. who knows
10:41:18 <Cale> Well, they exist classically.
10:41:34 <EvanR> which i havent found a good meaning of
10:41:47 <Cale> I mean, they exist in ZFC's sense of the term
10:41:51 <EvanR> which is?
10:41:58 <EvanR> nevermind
10:42:04 <Cale> Which is first order logic's existential quantifier
10:42:19 <EvanR> uh huh.
10:42:45 <Cale> there exists a set in ZFC whose elements are exactly the computable elements of the real numbers
10:43:04 <reactormonk[m]> There's a few that define `leftMap` - or is it in base now? http://hayoo.fh-wedel.de/?query=%28a+-%3E+b%29+-%3E+Either+a+c+-%3E+Either+b+c
10:43:09 <Cale> Also, you can define them in Agda or Coq or many other intuitionistic theories.
10:43:16 <EvanR> the words are grammatical, and people say them, but it doesnt go anywhere in my mind
10:43:25 <EvanR> Cale: i said, uncomputable
10:43:46 <Cale> Sure, you can define the uncomputable reals in Coq.
10:44:24 <Cale> It'll be quite similar to how you'll do it in ZFC
10:44:34 <cocreature> :t first
10:44:36 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
10:44:51 <cocreature> :t Data.Bifunctor.first
10:44:52 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
10:44:58 <cocreature> reactormonk[m]: you can use that
10:45:25 <cocreature> Either is an instance of Bifunctor
10:45:26 <Cale> But probably you'll need to be more careful about what you mean by reals in the first place
10:45:41 <Cale> Since things tend to bifurcate a bit without LEM
10:45:50 <reactormonk[m]> cocreature: makes sense, thanks
10:47:25 <EvanR> well, people seem to be expressing the opinion that there is more going on than something being just grammatically correct string of logic
10:47:57 <Cale> EvanR: For example, with most definitions of the reals, even in a system like Coq, it's still going to be possible to *define* a real number whose nth binary digit is 1 if the nth Turing machine halts.
10:48:10 <EvanR> that string of logic is usually not on topic when you talk about reals
10:48:21 <Cale> What do you mean?
10:48:50 <Cale> The real numbers aren't *literally real* -- there isn't physically out there somewhere a real line. This isn't even the case for natural numbers.
10:49:07 <EvanR> in a discussion, "the uncomputable reals, the non-recursive subsets of N, etc, *exist* period."
10:49:48 <Cale> Yeah, when I say that some mathematical object "exists", what I mean is that there is a proof of its existence in my favourite formalism.
10:50:11 <EvanR> i dont doubt that
10:50:13 <Cale> (most of which are set up to be close enough to be equivalent that probably your favourite formalism will agree)
10:51:07 <Cale> and then if we disagree, then it will likely be because either one of us is wrong about the status of that proof, or we didn't pick the same formalism
10:51:10 <EvanR> but that seems rather empty, and wasnt what i was expressing
10:51:22 <Cale> I have no idea what you were expressing
10:51:33 <EvanR> right
10:51:36 <Cale> There's no sense in which mathematical objects exist beyond this one
10:51:51 <Cale> Or beyond this class of notions of existence
10:51:56 <EvanR> you defaulted to looking through ZFC
10:51:58 <Cale> at least, so far as I'm aware
10:52:00 <Cale> yeah
10:52:17 <EvanR> there is a sense in which they exist
10:52:28 <Cale> Perhaps I shouldn't do that in #haskell, I should pick HoTT or something instead.
10:52:33 <Cale> :D
10:52:50 <Cale> I tend to default to ZFC because it's what most mathematicians will expect
10:53:08 <Cale> But they will agree on this anyway
10:53:21 <EvanR> the "number" pi for example, is the abstract form of any number of ways you could do a process whose output gets closer to the area of a unit circle
10:54:18 <EvanR> the informal language of weird things existing is like all these abstractions of math procedures losing something
10:54:27 <EvanR> i mean, losing even more
10:54:31 <Cale> Okay, and what about the number between 0 and 1 whose binary representation has a 1 in the nth place if the nth Turing machine halts?
10:54:40 <Cale> Is that not real enough? :)
10:54:58 <EvanR> that making any sense relies on markovs principle
10:55:19 <EvanR> which bauer seems to believe in, so it must be true!
10:55:48 <EvanR> in what sense to a turing machine either halt or not halt
10:55:56 <EvanR> s/to/does/
10:56:45 <EvanR> in what sense does "all turing machines either halt or not halt" make sense
10:57:03 <EvanR> "classically" and were back to where we started
10:59:04 <Cale> Ah, so you want a real number which isn't computable, but which is definable without using LEM?
10:59:28 <Cale> Well, we'll need to be very particular about what the real numbers are for that to be possible.
10:59:28 <EvanR> well, that uses markovs principle which is weaker
10:59:35 <Cale> sure
10:59:48 <Cale> I only used one particular special case of LEM there
11:00:46 <EvanR> you think you can do it?
11:00:54 <benzrf> what do you mean by "definable" there?
11:01:22 <Cale> benzrf: Well, that's still up in the air -- I'm not sure which formalism EvanR wants to be working in.
11:02:09 <EvanR> martin lof type theory
11:02:23 <EvanR> if you really need a formalism
11:02:25 <Cale> okay, and do you have a favourite definition of the real numbers?
11:03:07 <Cale> It's easily possible to constrain yourself to the computable reals from the outset.
11:03:09 <EvanR> sure
11:03:23 <Cale> In which case, this becomes a bit of a moot point.
11:03:25 <EvanR> a complete ordered ring, plus whatever i just forgot
11:03:32 <benzrf> *field
11:03:37 <EvanR> hmm
11:03:53 <EvanR> ill be ok if cale does it without division
11:03:54 <Cale> Any Dedekind-complete ordered field?
11:04:11 <EvanR> since field axioms dont really work without LEM
11:04:34 <benzrf> EvanR: Definition chaitin r = forall n, bin_digit n r = true <-> halts (turing_machine_enum n).
11:04:43 <EvanR> we just went over that
11:04:52 <benzrf> yes, but im saying you have a definition right there
11:05:06 <benzrf> i don't know what else you could call a 'definition' if it's not computable
11:05:10 <EvanR> halts ?
11:05:24 <EvanR> "without using markovs principle"
11:05:25 <benzrf> chaitin : R -> Prop
11:05:44 <benzrf> it's a singleton, but not provably so without lem
11:05:57 <butterthebuddha> How do I use a list comprehension to perform a computation if a condition is true, but return the original value if it wasn't?
11:06:01 <benzrf> however you can prove that it has at most one element without lem
11:06:06 <EvanR> bin_digit makes sense?
11:06:10 <benzrf> sure
11:06:14 <EvanR> im skeptical of that
11:06:16 <Cale> butterthebuddha: In a contrived way?
11:06:19 <benzrf> depending on your representation, i suppose
11:06:31 <butterthebuddha> Cale: what would be a better alternative?
11:06:33 <Cale> butterthebuddha: Why do you want to use a list comprehension for that?
11:06:41 <Cale> An if/then/else expression perhaps?
11:06:48 <butterthebuddha> Cale: It's the only way I know of iterating over a list :(
11:07:22 <Cale> Oh, if you want to iterate over a list, you can still use the list comprehension
11:07:30 <ongy> \p f xs -> map (\x -> if p x then f x else x) xs -- butterthebuddha something like this?
11:07:38 <Cale> it's just that the bit you described is sort of independent of that
11:07:57 <Cale> > [if even x then x `div` 2 else x | x <- [1..10]]
11:07:59 <lambdabot>  [1,1,3,2,5,3,7,4,9,5]
11:08:08 <Cale> butterthebuddha: ^^ like that?
11:08:14 <butterthebuddha> Ah, thanks
11:09:53 <ongy> list comprehension. That feels like such a basic skill, and I just can't wrap my head around it
11:10:17 <EvanR> benzrf: i know that this chaitin thing, once precisely formulated, can be approximated to a couple bits by looking at proofs of particular small turing machines halting or not halting. but the assertion is that this could in principle be done for turing machines of all sizes, given enough time and intelligence
11:10:45 <EvanR> and it wouldnt cause a contradiction with other "known" mathematical facts in the process
11:10:51 <Cale> EvanR: Well, it's *not* computable, so you're not going to be able to approximate its value arbitrarily well
11:10:55 <benzrf> EvanR: i'm not sure what you're saying
11:10:57 <EvanR> or maybe the last part is not being asserted
11:11:45 <EvanR> Cale: not with a program no, but thats not what i was saying
11:12:01 <EvanR> the assertion is the number has some value regardless and we just dont know what it is
11:12:03 <Cale> Well, it doesn't matter if we're using a program or not :)
11:12:18 <EvanR> of course it does, because you get more bits by finding more proofs
11:12:41 <butterthebuddha> Cale: does that look right?   [ if i `mod` 2 /= 0 then c + c else c | i <- [0..(length n - 1)], c <- reverse n ]
11:12:44 <Cale> If just searching for proofs was sufficient, it would be computable
11:12:54 <butterthebuddha> Doubles every other element of a list from the back
11:12:56 <EvanR> youre being stubborn
11:13:03 <EvanR> you know what im talking about
11:13:28 <EvanR> time and intelligence, not just time
11:13:40 <Cale> butterthebuddha: sure
11:13:50 <Cale> EvanR: I'm not sure what you mean by intelligence
11:14:08 <Cale> Intelligence isn't going to help you
11:14:12 <EvanR> a human being sitting there thinking about turing machine 2873982743
11:14:17 <Cale> mhm?
11:14:34 <EvanR> this is where chaitin bits come from
11:14:48 <EvanR> they encode proofs
11:15:12 <Cale> So that human being will search the space of proofs and either find a proof that this Turing machine halts, or they will find a proof that it doesn't halt, or they will fail to find either.
11:15:31 <EvanR> most of the time they fail
11:15:38 <EvanR> but they arent finding them by searching
11:15:39 <Cale> and we know that for some Turing machines they *must* fail.
11:15:41 <EvanR> its not an algorithm
11:15:51 <Cale> Because no such proof will exist either way
11:16:06 <EvanR> that is one reason why this number doesnt make sense
11:16:15 <EvanR> but i would like to see an example of that
11:17:28 <EvanR> in what sense does the bit relying on that impossible proof or non proof have a value?
11:17:38 <Cale> Well, okay, the thing is, the space of proofs is recursively enumerable. For any property P, you can simply enumerate all the valid proofs, until you find a proof of P or a proof of not P. If P is decidable, this will terminate.
11:17:56 <butterthebuddha> Cale: Hmm, that code is adding an arbitrary number of additional elements to the original list :/
11:17:56 <EvanR> yeah which isnt the case here
11:18:09 <EvanR> but we come up with proofs regardless
11:18:30 <Cale> butterthebuddha: Oh, sorry, I wasn't looking carefully enough
11:18:42 <Cale> butterthebuddha: You want zip [0..] (reverse n)
11:18:58 <Cale> butterthebuddha: If you make independent choices, it will enumerate all possible combinations
11:19:07 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
11:19:09 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
11:19:21 <butterthebuddha> Ah, but I can't figure out to destructure tuples 
11:19:38 <Cale> EvanR: Well, but if *we* found the proof with intelligence, then a machine would eventually have found it without.
11:19:57 <Cale> (though it might take a very long time)
11:20:16 <Cale> butterthebuddha: (i,c) <- zip [0..] (reverse n)
11:20:32 <EvanR> Cale: and AI could conceivably just do it directly, but fine, lets turn the attention to these ones that supposedly cant be proved either way?
11:20:42 <Cale> right
11:21:22 <EvanR> how real a phenomenon is that?
11:22:08 <EvanR> and what does that mean for the value of the relevant bit of chaitins numbers
11:22:22 <Cale> Well, that's about as real a phenomenon as you could hope for in this stuff.
11:22:23 <dolio> What is the value of the smallest busy beaver number whose value is not determined by ZFC?
11:22:40 <reactormonk[m]> ... what's the recommended way to compose a few Strings for an error message? Use ++?
11:23:00 <thang1> Step 1 is to not use String /s
11:23:00 <cocreature> reactormonk[m]: use <> :)
11:23:12 <cocreature> because then it’s easy to swap out the String implementation
11:23:26 <EvanR> dolio: i would also like to know
11:23:41 <Cale> BB(1919) wasn't determined
11:23:44 <dolio> Why do you think it has one, or only one?
11:23:47 <Cale> There might have been a smaller one
11:23:50 <EvanR> i dont
11:23:54 <thang1> Oooh busy beaver functions
11:23:57 <splanch> Data.Text.Lazy.Builder is convenient for fast concatenation
11:24:01 <EvanR> i dont know what makes sense anymore
11:24:48 <EvanR> how would there be different smallest numbers
11:25:12 <Cale> Oh, that wasn't necessarily the *smallest* BB which wasn't determined by ZFC
11:25:13 <dolio> Cale: I don't mean 1919, I mean what is BB(1919)?
11:25:51 <dolio> Smallest doesn't really matter.
11:25:54 <thang1> Oh, a busy beaver function is the number that can be written by a turing machine of size X (I believe). Hold on, I'll link a scott aaronson blog on this. He's amazing at explaining it
11:26:02 <Cale> Stefan O'Rear found a 1919-state TM which searched for contradictions in ZFC.
11:26:14 <thang1> http://www.scottaaronson.com/writings/bignumbers.html
11:26:27 <EvanR> the longest runtime of the halting machines of a certain size?
11:26:52 <Cale> yeah
11:26:55 <thang1> http://www.scottaaronson.com/blog/?p=2725
11:27:04 <EvanR> that we can even begin to ask this relies on there being a clear distinction between the ones that halt and the ones that dont
11:27:12 <Cale> http://www.scottaaronson.com/blog/?p=2741
11:27:18 <dolio> Anyhow, the point is, "what is BB(1919)" presumably has different answers in different models of ZFC.
11:27:39 <EvanR> this is why ZFC makes no sense!
11:27:50 <thang1> ZFC makes plenty of sense though?
11:27:58 <Cale> EvanR: You can't expect ZFC to determine the answer to every mathematical question
11:28:01 <dolio> No, this is a problem with basically any formal system.
11:28:07 <Cale> If it did, it would be inconsistent ;)
11:28:15 <rotaerk> no, Godel's just a stick in the mud.
11:28:42 <Cale> EvanR: as such, different models of ZFC might disagree on anything that ZFC leaves open
11:28:44 <thang1> Also ZFC is actually ZF + the axiom of Choice. You can build your own set theory; it kinda feels like using lego blocks
11:28:56 <EvanR> youre asserting that the machines either halt or dont, then deriving what youre calling actual numbers from it, without ever having the hope of doing real arithmetic
11:28:59 <dolio> What makes no sense, apparently, is your belief that any question you can pose in a formal system has a unique answer in that formal system.
11:29:11 <thang1> You pick this axiom, that axiom, this other thing and that other thing and once you're done, you build up everything else from your assumptions and see what results
11:29:19 <EvanR> numeric arithmetic always gives you a unique answer
11:29:39 <thang1> Numeric arithmetic always gives you an answer, it is not guaranteed unique or correct depending on how your numeric system is setup
11:29:47 <geekosaur> ^
11:29:49 <EvanR> and in this topic, the speech is about supposed actual numbers
11:30:06 <EvanR> and its not really, so thats my gripe
11:30:09 <Cale> Well, numbers that have a definition
11:30:15 <Cale> Not necessarily numbers which are computable
11:30:48 <EvanR> in what sense do these numbers have an actual value at all, basically is what ive been saying over and over
11:31:05 <thang1> EvanR: The truth of higher mathematics and everything else is that nothing has some biblical, god-given truth.
11:31:09 <EvanR> if you can do models which give actual results, then thats the answer. and if you dont have a model then its "none"
11:31:23 <thang1> The reason math works is because math itself is consistent. Assuming you set up your model the same way, the same operations give the same answers
11:31:49 <thang1> So if I use ZFC and the normally defined natural numbers, 1+1 will always equal 2. If I use some other system and define my natural numbers weird, 1+1 might equal 3 or 4 or some other number
11:32:04 <EvanR> youre off the rails right now
11:32:11 <Cale> EvanR: Well, various models of ZFC will be able to compute *more* of the individual digits of this number.
11:32:12 <thang1> But the math itself isn't wrong or different
11:32:29 <Cale> EvanR: But it will remain uncomputable
11:32:55 <Cale> also, different models may disagree about various digits
11:33:03 <EvanR> Cale: this was asserted a few months ago in here, that all the models will give you different parts of the same answer, and they wont contradict
11:33:19 <dolio> Well, that's wrong.
11:33:22 <EvanR> ok, then you say it might not
11:33:27 <thang1> Who said that, anyway?
11:33:42 <EvanR> i dont know, might have been a random misunderstanding
11:33:56 <dolio> If all models agreed, then it'd be a theorem.
11:34:07 <EvanR> so if the "actual value" (word I am using gratuitously) depends on the model, that answers my question
11:34:12 <monochrom> I can believe that on the Internet there are a majority of random misunderstandings.
11:34:21 <dolio> Well, I suppose some could agree, and some could leave the answer open.
11:34:39 <dolio> I don't think models are really supposed to do that, though.
11:34:58 <EvanR> in which case, talking about "the chaitin constant" (modulo setup) doesnt make sense
11:35:23 <thang1> Why wouldn't it?
11:35:30 <EvanR> where setup is the language and the kind of turing machine, not the model of ZFC
11:35:34 <dolio> EvanR: I think people who talk like that probably believe that we are inhabiting some ultimate model that we care about, or something along those lines.
11:35:44 <EvanR> which model is that?
11:35:51 <thang1> "the real one"
11:35:55 <EvanR> uhg!
11:35:59 <Cale> EvanR: Don't try to make sense of that :D
11:36:18 <thang1> Comes from a misunderstanding of math and a refusal to let go of a belief in an absolute and perfect truth
11:36:33 <Cale> ^^
11:36:44 <thang1> Truth itself is a concept which has limits and flaws
11:37:04 <monochrom> @quote monchrom Kripke
11:37:04 <lambdabot> No quotes for this person. Are you typing with your feet?
11:37:06 <Cale> Truth is a (very effective) human invention.
11:37:15 <Cale> and it's not just one invention, but many
11:37:19 <dolio> So they believe if you built Turing machines (which you can't even do) and ran them, they'd either halt or not (which you couldn't know even by running them for a finite amount of time), and that answer would give you Chaitin's "constant".
11:37:33 <Gurkenglas> If we ever find a turing machine that'd simulate the universe, can we derive from that a model that'll decide all theorems whose truth can influence the world?
11:37:36 <reactormonk[m]> aeson default instance for Maybe Text description fails if the field is not present? Huh?
11:37:44 <reactormonk[m]> ... shouldn't it be Nothing?
11:38:16 <thang1> Gurkenglas: not in any meaningful sense
11:38:18 <monochrom> Oh! I was missing an o in my nick
11:38:21 <monochrom> @quote monochrom Kripke
11:38:21 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
11:38:25 <monochrom> There!
11:38:27 <reactormonk[m]> I guess you'll have to be explicit via `.:?`
11:38:31 <cocreature> reactormonk[m]: yep
11:38:36 <thang1> haha that's a great quote
11:38:42 <Cale> monochrom: lol
11:38:45 <reactormonk[m]> :-/
11:39:21 <thang1> https://en.wikipedia.org/wiki/Chaitin%27s_constant this is also helpful, I think
11:40:08 <hexagoxel> reactormonk[m]: https://hackage.haskell.org/package/aeson-1.1.1.0/docs/Data-Aeson-Types.html#v:omitNothingFields
11:40:10 <thang1> Read the first paragraph. "Omega depends on the problem encoding used" ... "Each halting probability is a normal and transcendental real number that is not computable" ... "There is not even any algorithm which can reliably guess its digits"
11:40:45 <thang1> Anyway, do y'all have any ideas as to small to medium projects that the haskell community could benefit from?
11:40:48 <EvanR> the wikipedia article has been mildly unhelpful to me on this for at least 15 years
11:40:49 <reactormonk[m]> hexagoxel: not using generic
11:41:26 <EvanR> that language in the quotes is exactly what i was griping about
11:41:30 <sleffy> I'm mucking with lens. Is there any way to take several lenses side by side, all of which have the same types, and then glue them together into a fold?
11:42:13 <thang1> sleffy: What are you trying to achieve with that?
11:42:21 <cocreature> sleffy: the problem with gluing lenses together is that they can overlap and that will usually break the lenses
11:42:24 <cocreature> *lens laws
11:42:47 <sleffy> thang1, I have a record with a bunch of fields which I've named, because they're quite specific and the number of fields won't vary
11:43:07 <sleffy> I want to traverse over all the fields of the same type. I don't *think* makeLenses will generate folds/traversals that will let me do this
11:43:15 <sleffy> s/traverse/fold, but same difference
11:43:39 <sleffy> cocreature, getters then? I can ensure that they won't overlap
11:43:58 <dolio> thang1: That the number depends on the problem encoding is different than that the number is different in different models.
11:44:24 <dolio> For instance, there are multiple ways you could encode Turing machines as natural numbers, so that would affect the number.
11:44:39 <sleffy> oh whoop
11:44:40 <nshepper1> dolio: if the Turing machine halts, there would be a proof that it halts on zfc
11:45:00 <sleffy> I missed it, it's *right* there on the Control.Lens.Getter docs. There's a monoid instance for it. That's magical
11:45:23 <dolio> But for any given encoding, different models can also give different answers about which Turing machines halt.
11:45:45 <EvanR> that issue is not addressed in wikipedia
11:45:48 <thang1> Right. But that's true for literally any sort of proof/computation/math/etc. It's a basic principle about math
11:45:50 <EvanR> and i wish it were
11:45:51 <nshepper1> The Turing machines whose halting status can't be proved, never halt
11:46:18 <thang1> nshepper1: I thought you could prove either halting, non-halting, or undecideability?
11:46:19 <EvanR> nshepper1 has asserted that if it cant be proved one way or another if a given machine halts, then it doesnt halt. now listen to the justification
11:46:22 <nshepper1> But undecidability of halting is undecidable too
11:46:43 <dolio> For instance, there are models of ZFC (I think) that assert ZFC's consistency, and that negate ZFC's consistency. So they would disagree on whether a Turing machine that halts IFF ZFC is consistent halts.
11:47:22 <EvanR> dolio: if thats true, then it seems that the answer is up to us? does that make sense?
11:47:43 <dolio> What do you mean it's up to us?
11:47:45 <EvanR> otherwise, seems like ZFC is broken
11:47:47 <thang1> It seems like you just keep assuming that everything is knowable and that all answers can be found
11:47:54 <EvanR> that the halting status is a lucid dream
11:48:01 <thang1> or that every question out there can have an answer
11:48:27 <nshepper1> thang1: no. You can't necessarily prove undecidability
11:48:27 <EvanR> thang1: i am exactly on the opposite side of this, i dont think youve been paying attention enough
11:48:29 <Gurkenglas> sleffy, you want http://hackage.haskell.org/package/lens-4.15.1/docs/Data-Data-Lens.html#v:template
11:48:36 <dolio> This is all predicated on the assumption that ZFC is consistent.
11:48:45 <EvanR> it is?
11:48:48 <dolio> Yes.
11:48:51 <EvanR> how
11:49:15 <dolio> Because we want it to have models.
11:49:36 <sleffy> Gurkenglas, that's perfect, thanks! While you're at it - is there a way I can use this to zip two structures together? I want to `mappend` all these fields from both records to create a new record.
11:49:37 <EvanR> meaning if it were inconsistent, all the models you came up with dont count somehow?
11:49:51 <dolio> Inconsistent theories don't have the models that model theorists like.
11:50:41 <thang1> It's the same line of reasoning for why, when solving differential equations, "zero" is a useless answer.
11:50:52 <dolio> I mean, if you did come up with a notion of model, it'd be one where every proposition is both true and false.
11:51:02 <dolio> So what are you even talking about, then?
11:51:06 <EvanR> thang1: what? that seems off base
11:51:37 <dolio> The point is for some things to be true, and other things to not be true.
11:51:38 <EvanR> dolio: you were talking about the same thing as before, but now you know more about the model
11:51:55 <thang1> Nah, dolio got what I was coming at. In differential equations, you can solve any equation by zeroing everything. So y'' + y' + y = 0 works if y'' and y' and y is zero. But that's an unsatisfying answer that tells you nothing about the actual equation
11:52:16 <thang1> So why would you create a model that tells you nothing? It's unsatisfying and somewhat useless
11:52:37 <EvanR> well im finding a great deal of this unsatisfying 
11:52:40 <thang1> Saying something is both true and false is the same as not bothering to say something at all
11:53:10 <EvanR> and lets not ask about useless
11:55:14 <dolio> Anyhow, if ZFC is not consistent then consistency of ZFC is not independent of it.
11:55:18 <dolio> It is a theorem.
11:55:27 <dolio> And also the inconsistency is a theorem.
11:55:43 <EvanR> dolio: what i was asking was, if you have a choice of model, and in one you get the opposite answer to another, then it seems clear the answer is subjective. And since the machine can only behave one way in real life, since its deterministic, doesnt that indicate some sort of inapplicability of the whole franchise?
11:55:44 <dolio> So all models must validate both.
11:56:12 <dolio> So you can only have models that disagree if ZFC is consistent..
11:57:08 <dolio> Aren't Turing machines inapplicable to real life, because you can't build one?
11:57:22 <dolio> You can only build finite state machines.
11:57:39 <EvanR> you dont think so/
11:57:48 <dolio> That run for a limited amount of time before they break.
11:58:04 <EvanR> in any case, i dont mean actually build it and run it
11:58:24 <nshepper1> Istm that models these models saying whether Turing machines halt or not are doing so in a rather trivial manner
11:58:25 <EvanR> the abstract behavior that is the same regardless of how its implemented
11:58:43 <EvanR> Istm ?
11:59:43 <nshepper1> Simply answering "does this Turing machine halt" with 1 is rather different than actually enumerating the states of the machine from start to a terminating state
11:59:49 <nshepper1> "it seems to me"
12:00:14 <dolio> nshepper1: Well, actually, I think it gets pretty weird.
12:00:36 <dolio> Because the ones that say it halt will probably have such 'enumerations' of the states.
12:00:53 <dolio> Because their 'natural numbers' will have non-standard elements.
12:01:48 <Gurkenglas> sleffy, I guess you could do "y & partsOf template %~ zipWith (<>) (x ^.. template)" but its kinda ugly?
12:02:46 <nshepper1> Yeah, that seems like cheating, doesn't it?
12:02:51 <dolio> Does it?
12:03:19 <nshepper1> Have a countably infinite enumeration of states, then say "see, it halts at +inf"
12:04:12 <dolio> But it is countably infinite, because coutability is about being equinumerous to the natural numbers, which are 'bigger' in this model.
12:04:42 <nshepper1> Sure, if your "natural numbers" include +inf that is in some technical sense saying that the machine halts
12:04:53 <dolio> And "+inf" is not really a good description. It's much weirder looking than that.
12:05:12 <nshepper1> But in ordinary natural numbers that's more of a proof that the machine doesn't halt
12:06:12 <nshepper1> Yeah, i know. But N + {inf} is just the simplest example of nonstandard naturals that i know
12:06:27 <dolio> That isn't even a model of the nonstandard naturals, I think.
12:06:34 <Cale> N + {inf} doesn't quite work, because you need S inf /= inf
12:06:36 <EvanR> er, if you add one you get a lot of others
12:06:46 <EvanR> successors and predecessors of inf
12:07:34 <EvanR> im not sure if this seems silly when applied to turing machines
12:08:45 <muzzle> Is there a particular reason why there is no  MonadMask m => MonadMask (MaybeT m) instance of the MonadMask typeclass in the exceptions package?
12:09:34 <dolio> EvanR: Anyhow, maybe you can look at it like this. Model theory is about studying how applicable your formal system is to "real life". You care if you can use the results in the "real world," so it is like your "standard model." Things that aren't determined by the theory, and are different in different models are things you can't use. But that doesn't necessarily mean the whole thing in useless.
12:09:35 <cocreature> muzzle: yes, see https://stackoverflow.com/questions/41966893/why-is-there-no-monadmask-instance-for-exceptt/41977629#41977629 for an explanation for ExceptT
12:09:41 <nshepper1> Cale: oh, right. Well, you can use that as a generating set, i guess
12:09:48 <cocreature> muzzle: the reason why there is none for MaybeT is the same
12:10:06 <cocreature> muzzle: the short answer is that you can’t guarantee that finalizers are run because Nothing will shortcircuit everything
12:10:18 <dolio> But also, just the study of the models can be interesting, too.
12:11:16 <muzzle> cocreature: makes sense, thanks
12:11:43 <Gurkenglas> It's like, if we ever figure out entropy and get immortality, you can start asking yourself what you'll be like at an equal-distribution random point in the infinite future, and whether there'll be an infinite amount of time in the past, and whether you should start optimizing that future now. Whether there will be such a point depends on your mathematical (!) model
12:11:46 <cocreature> muzzle: the fact that there is no MonadMask instance is the primary reason why I tend to avoid ExceptT/MaybeT
12:15:03 <mellowmaroon> Hopefully it's not a dumb question, but what's MonadMask? I've only recently learned about monad transformers
12:15:25 <geekosaur> it's less about monads than about exceptions
12:15:59 <cocreature> mellowmaroon: it’s a typeclass that allows for things like "bracket"
12:15:59 <muzzle> mellowmaroon: it's a typeclass for monads that allow you to mask asynchronous exceptions
12:16:50 <muzzle> mellowmaroon and asynchronous exceptions are basically exceptions thrown into a thread from an other thread. Which can occur at any random time form a thread's point of view
12:17:38 <EvanR> dolio: would computable reals fall into this "can use" and "same in all models" bin?
12:19:00 <nshepper1> Anyway, i guess I'm more willing to believe that we know what we're talking about when we say "the standard model of the natural numbers" or "a finite enumeration" than that there is no fact of the matter about whether Turing machines halt
12:19:43 <dolio> EvanR: I'm not sure. It might depend on exactly how you define them.
12:19:53 <EvanR> yeah markovs principle is attractive
12:20:45 <butterthebuddha> Not sure why this throws an compiler error: "sumDigits l = (foldr (+) 0 (foldr (toDigits) [] l))"
12:20:47 <EvanR> i guess theres many kinds of computability?
12:20:57 <EvanR> maybe that determines which reals there are
12:20:58 <butterthebuddha> l is an Integer that I'm trying to find the sum of the digits of
12:21:25 <Cale> mellowmaroon: It's a class for monads which support an operation that masks exceptions inside of some critical section (and gives you a way to undo the mask for some portion of that section)
12:21:29 <butterthebuddha> It doesn't like that toDigits is Integer -> [Integer]
12:21:39 <cocreature> :t foldr
12:21:40 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:21:51 <cocreature> you are using toDigits for the "a -> b -> b" part
12:21:53 <cocreature> that won’t work
12:22:06 <cocreature> and you are using an integer for the "t a" part. that also will fail
12:22:47 <butterthebuddha> Im using an empty list for the t a part?
12:23:01 <dolio> EvanR: Well, if you define them like "there exists a halting Turing machine that accepts a natural n and gives you the nth digit", then it's possible that whether such a halting machine exists depends on the model.
12:23:14 <butterthebuddha> Oh wait you mean for the inner list
12:23:22 <Cale> mellowmaroon: The argument to  mask :: ((forall a. m a -> m a) -> m b) -> m b  is a function which produces an action that you want to run with exceptions masked, and it gets passed a function you can use to restore the exceptions for some part of that.
12:23:33 <butterthebuddha> cocreature: Why doesn't the integer work?
12:23:46 <EvanR> that definition is what turing did, but later he realized thats not great
12:24:06 <dolio> EvanR: Probably it's impossible to make it completely determined, but I'm not sure.
12:24:09 <EvanR> because of the freedom you have and have to have in redundant digit-based representations
12:24:22 <cocreature> butterthebuddha: how do you fold over an Integer?
12:24:31 <dolio> Sure, some type of approximation is probably better.
12:24:41 <cocreature> butterthebuddha: and no you are not using an empty list for the "t a" part. you are using it for the "b"
12:24:42 <butterthebuddha> cocreature: I thought that argument was the accumulator?
12:25:13 <cocreature> butterthebuddha: the first argument is the combining function, the second is the initial value of the accumulator, the third is the thing you want to fold over
12:25:58 <butterthebuddha> yep, isn't the second argument 0, cocreature?
12:25:59 <dolio> The important part of it isn't how you spit out the number, but how you define the criteria for 'computing'.
12:26:18 <cocreature> butterthebuddha: I’m taking about the inner call to foldr, i.e. "foldr toDigits [] l"
12:26:49 <EvanR> i know theres higher order computation, but im not sure if it makes a difference to potential results
12:26:50 <dolio> I think even if you tried to put "it is a theorem of ZFC that this Turing machine halts" in the definition, it wouldn't be good enough.
12:27:25 <dolio> Because what things are provably theorems of ZFC (constructed internally in ZFC) are model-dependent.
12:27:43 <EvanR> why ZFC ?
12:27:49 <dolio> Pick anything you want.
12:27:58 <dolio> PA, whatever.
12:28:02 <dolio> Agda.
12:28:21 <cocreature> what’s PA?
12:28:28 <EvanR> N -> Q, function definable with lambda calculus-ish, with the proof of the cauchy criterion
12:28:28 <dolio> Peano arithmetic.
12:28:31 <cocreature> oh ofc
12:28:43 <EvanR> typed LC
12:29:40 <EvanR> but whether what you pick matters is exactly what i was wondering about
12:30:20 <dolio> It doesn't matter in the sense that they all have multiple models that can disagree.
12:30:22 <butterthebuddha> I'm thinking this is gonna work if I can flatten the list I'm iterating over: `sumDigits l = foldr sum 0 ([toDigits n | n <- l])`
12:30:52 <cocreature> butterthebuddha: you can’t use list comprehension on integers either
12:31:05 <cocreature> butterthebuddha: maybe you just want (toDigits l)?
12:31:14 <EvanR> dolio: i tried reading model theory, but my brain exploded. is there a point to models of typed LC ?
12:31:25 <butterthebuddha> cocreature: l is a list of integers
12:31:36 <butterthebuddha> sumDigits        :: [Integer] -> Integer
12:31:36 <EvanR> it seems self evident
12:31:39 <cocreature> butterthebuddha: oh you said it’s an Integer before
12:31:51 <butterthebuddha> Did I? Sorry!
12:32:31 <cocreature> butterthebuddha: alright, so you are given a list of integers. what should sumDigits return?
12:32:54 <butterthebuddha> The sum of all the digits of all the integers in the list
12:33:02 * EvanR tries to look for a model theory book that isnt just ZFC stuff
12:33:09 <cocreature> butterthebuddha: so it should return a single integer?
12:33:16 <butterthebuddha> Ueap
12:33:27 <butterthebuddha> Yeap*
12:33:48 <cocreature> butterthebuddha: alright, so first try to write a function Integer -> Integer that calculates the sum of a the digits of a single integer
12:33:57 <cocreature> butterthebuddha: then you can use that to implement sumDigits
12:34:12 <dolio> Agda is a little different, because ostensibly you aren't using it as a separate formal approximation to the real object you care about.
12:34:24 <dolio> You just care about what Agda does.
12:34:33 <dolio> And what results it spits out.
12:34:44 <dolio> Same with typed lambda calculi.
12:35:43 <EvanR> a separate formal approximation to the real object you care about? what thats a thing?
12:36:17 <EvanR> is that why all this is confusing, im missing that?
12:36:49 <dolio> Yeah. Like, I use PA to think about natural numbers, which I care about because I use them to count my livestock.
12:37:24 <EvanR> thats an approximation? i figured it was an abstraction
12:37:53 <EvanR> maybe thats the same thing somehow
12:38:14 <dolio> Even though not every question I could ask about the natural numbers is a theorem (or the negation is a theorem) in PA.
12:38:52 <EvanR> ok i though by real object you were getting at something intanglible
12:38:53 <butterthebuddha> cocreature "sumDigits l = foldr sumDigits' 0 ([toDigits n | n <- l])"
12:39:08 <butterthebuddha> That should totally work if I can figure out a way of flattening the list
12:39:10 <EvanR> like sets
12:39:29 <cocreature> butterthebuddha: what’s the type of sumDigits'?
12:39:37 <butterthebuddha> Integer -> Integer
12:39:47 <cocreature> then that won’t work
12:39:51 <cocreature> :t foldr
12:39:52 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:39:58 <cocreature> you need a function of type a -> b -> b
12:40:07 <ij> How do I (IO a, b) -> IO (a, b)?
12:40:19 <butterthebuddha> Ohh
12:40:24 <cocreature> butterthebuddha: foldr is not particularly helpful here
12:41:19 <butterthebuddha> cocreature What do you suggest?
12:42:03 <ski> ij : `\(io,y) -> fmap (\x -> (x,y)) io'
12:42:16 <cocreature> butterthebuddha: try implementing sumDigits using "sum", "map" and "sumDigits'"
12:42:31 <EvanR> ij: f (act, y) = do{ x <- act; return (x,y) }
12:43:09 <EvanR> @djinn (IO a, b) -> IO (a,b)
12:43:09 <lambdabot> Error: Undefined type IO
12:43:22 <EvanR> @djinn Monad m => (m a, b) -> m (a,b)
12:43:22 <lambdabot> -- f cannot be realized.
12:43:49 <geekosaur> :exf "(IO a, b) -> IO (a,b)"
12:43:49 <exferenceBot> \ a -> let ((,) i3 d) = a in fmap (\ g -> (g, d)) i3
12:44:16 <dolio> EvanR: You could take "the natural numbers" to be the "real object", which is pretty intangible.
12:44:21 <geekosaur> slightly odd way of putting it...
12:45:20 <dolio> Certainly it's all intangible when you're thinking about formal systems and models constructed inside another ultimately formal metasystem.
12:45:25 <nshepper1> Ooh, exferenceBot is here
12:46:02 <butterthebuddha> cocreature "sumDigits l = [sumDigits' a | a <- [sumDigits' n | n <- l]] !! 0"
12:46:06 <butterthebuddha> That seem like it'll work?
12:46:11 <dolio> But you might want to think about that because it applies to using formal systems to get your computer to put the right thing on a screen, too.
12:46:53 <kamyar> Please help me use MessagePack
12:47:55 <EvanR> natural numbers are tangible as hell, i can put them in TVars and lists and whatever all day!
12:48:43 <Tuplanolla> You come here to ask that every day, kamyar.
12:48:48 <cocreature> butterthebuddha: well it typechecks but assuming I’ve understood what you want sumDigits to calculate this won’t work.
12:49:00 <Gurkenglas> :t _1 :: (IO a, b) -> IO (a, b)
12:49:02 <lambdabot> error:
12:49:02 <lambdabot>     • Couldn't match type ‘s0 -> f0 t0’ with ‘IO (a1, b1)’
12:49:02 <lambdabot>       Expected type: (IO a1, b1) -> IO (a1, b1)
12:49:07 <cocreature> butterthebuddha: try sticking to the functions I hinted you at
12:49:08 <kamyar> Tuplanolla: No one has answered me yet
12:49:09 <butterthebuddha> I just figured out that I need to sum the list
12:49:26 <butterthebuddha> For some reason I thought that the sum would end up as the first list
12:49:34 <butterthebuddha> It works now, thanks for all your help :)
12:49:51 <Tuplanolla> That's because your question is too vague, kamyar.
12:51:20 <Tuplanolla> There's nothing we can do if you want us to read your mind and "please give codes".
12:51:59 <Gurkenglas> :t _1 id :: (IO a, b) -> IO (a, b) -- ah right duh
12:52:01 <lambdabot> (IO a, b) -> IO (a, b)
12:54:27 <cocreature> Gurkenglas: that’s a nice solution!
12:55:26 <ph88> out of curiosity .. does haskell rich information about a program help with optimizations as described here?  http://article.gmane.org/gmane.comp.lang.lua.general/75426
13:21:21 <butterthebuddha> Not sure why this is an error on line 2: https://gist.github.com/awesomeaniruddh/bc29be2a471330ee86ded850533fe8b8
13:21:41 <butterthebuddha> Shouldn't that work according to the "Declarations and variables" section of https://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html
13:22:20 <mauke> not enough information
13:22:24 <geekosaur> need context
13:22:46 <butterthebuddha> I updated the gist with the entire file
13:23:06 <mauke> you can't do that in a do block
13:23:26 <butterthebuddha> why not :(
13:23:41 <geekosaur> you want either let or where
13:23:44 <mauke> what would it do?
13:23:58 <butterthebuddha> mauke: It's just a variable that stores the list
13:24:03 <glguy> there seem to be quite a few misunderstandings in that code
13:24:42 <glguy> what do notation is, that variables aren't things you update, types
13:25:35 <butterthebuddha> ?
13:25:43 <butterthebuddha> not quite sure what you mean
13:28:48 <glguy> butterthebuddha: You seem to be thinking of do { moves :: [Move]; moves = []; moves = moves ++ [move p1 p2]; moves } where "moves :: [Move]" declares a new variables that you can update the subsequent two lines
13:29:17 <butterthebuddha> Yep
13:29:24 <glguy> it's not that
13:30:34 <butterthebuddha> What exactly is it?
13:30:43 <glguy> as is it's just invalid syntax
13:30:58 <butterthebuddha> How would I declare a variable that I can subsequently update?
13:31:03 <glguy> You don't
13:31:03 <geekosaur> you don't
13:31:09 <Tuplanolla> You could, but...
13:31:18 <glguy> You can't, but there are other things you can do
13:31:32 <geekosaur> not sure IORefs/STRefs count here
13:32:32 <butterthebuddha> I can't possible create that list in one step
13:32:49 <mauke> yes, you can
13:33:56 <butterthebuddha> mauke: the computation I need to create the list is more complicated than the code i have right now
13:34:22 <monochrom> I might want to ask "what counts as 'one' 'step'?"
13:34:50 <monochrom> To be fair, we don't need to go that far yet.
13:35:14 <monochrom> But for example "xxx = [1,2,3,4,5]" is defining a 5-item list in one go.
13:35:34 <butterthebuddha> I'm working on the fifth exercise of https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
13:35:39 <monochrom> And "yyy n = [1 .. n]" is defining a long list in one go.
13:36:08 <geekosaur> I assure you that anything in that course does not require mutable variables
13:36:24 <geekosaur> it *will* likely require you to learn how to think functionally
13:36:40 <monochrom> And if you say you want something more general than [1..n], sure, [1..n] has a recursion behind, so you can use recursion to do general things.
13:37:11 <monochrom> The code for "map" is an example of doing a fairly general thing.
13:37:16 <monochrom> @src map
13:37:16 <lambdabot> map _ []     = []
13:37:16 <lambdabot> map f (x:xs) = f x : map f xs
13:37:52 <monochrom> No mutable variables. Just recursion. Despite conventional wisdom "don't I need a mutable variable for the intermediate incomplete list?"
13:37:58 <Dr8128> :t (+)
13:38:00 <lambdabot> Num a => a -> a -> a
13:38:41 <Dr8128> let double f x = f(f(x))
13:38:47 <monochrom> I don't know whether by your standard the code of map counts as "one" "step" but it surely counts as just two lines.
13:39:00 <Dr8128> :t show
13:39:01 <lambdabot> Show a => a -> String
13:39:17 <Dr8128> double subtract 4
13:39:19 <glguy> Dr8128: You can experiment with lambdabot in private message via /msg
13:39:36 <monochrom> Also, screw conventional wisdom.
13:40:15 <Dr8128> glguy: cool thx
13:40:24 <mauke> you can define hanoi directly as a recursive function
13:40:30 <geekosaur> also you need to prefix stuff to be run with "> ", and you can;t do definitions, just expressions
13:40:35 <geekosaur> although there is @let
13:40:56 <mauke> should only take two lines (base case; recursion)
13:41:16 <monochrom> Hanoi is actually harder in loops.
13:41:24 <monochrom> Ackermann is, too.
13:42:00 <monochrom> http://www.vex.net/~trebla/compsci/imperative-functional.html
13:42:17 <Dr8128> geekosaur: thx
13:42:30 <Dr8128> lambdabot is neat its like ghci
13:42:51 <butterthebuddha> I'm not sure how to define hanoi as a recursive function; each step seems to be very complicated
13:43:11 <geekosaur> except it's not ghci
13:43:13 <butterthebuddha> And I need to figure out which peg to move each disc to depending on the state
13:43:29 <dolio> What state?
13:43:32 <Tuplanolla> It's a sheep in a wolf's clothing, butterthebuddha.
13:43:56 <butterthebuddha> dolio: depending on where the other discs are
13:43:58 <ertes> i think Codensity should be in base
13:44:02 <butterthebuddha> i can't have a larger disc on a smaller disc for exampel
13:44:04 <monochrom> Take 3 parameters, which stand for the 3 pegs.
13:44:09 <ertes> and reexported from the Prelude
13:44:32 <monochrom> Also, the question already contains the solution, except in English.
13:44:55 <monochrom> Your job is to translate that English to code. Your job is not to come up with a novel solution.
13:45:18 <monochrom> And even then, you see how that piece of English is recursive.
13:46:56 <butterthebuddha> Yea but "move n − 1 discs from a to c using b as temporary storage" is a super high level description
13:47:20 <butterthebuddha> It's a different process for each disc
13:47:30 <monochrom> That is one of the two recursive calls.
13:47:40 <monochrom> Let me put it this way.
13:47:53 <monochrom> Suppose you ask me to write a program to sum up an array.
13:48:14 <monochrom> err, list! s/array/list/ !
13:48:47 <monochrom> I'm going to say, "to sum up 10 numbers, first sum up 9 of the numbers, then add the remaining one"
13:48:47 <mauke> butterthebuddha: your program doesn't have to manage state. it's already encoded in the algorithm
13:49:10 <monochrom> You are not going to complain that my "first sum up 9 of the numbers" is an awfully high level description.
13:49:26 <monochrom> Because it simply means f (x:xs) = x + f xs
13:49:32 <monochrom> It simply means recursive call.
13:52:03 <monochrom> Or how about I call it code reuse? That's cooler.
13:52:38 <monochrom> I am already writing code to sum up a list. Why don't I reuse this code by a simple call to sum up a sublist?
13:54:16 <butterthebuddha> Yea but when you're summing a list, you're doing the same exact operation every single time, just on a different input
13:54:33 <butterthebuddha> Unless I'm missing something, I can't move every peg in the same way
13:54:43 <butterthebuddha> To get them from a to c
13:55:09 <monochrom> OK, this is why I also said: You need 3 parameters, for the 3 pegs.
13:55:42 <glguy> butterthebuddha: Notice how the English solution doesn't need to provide different cases for all the different pegs
13:55:43 <monochrom> When you see "a" "b" "c" consider them to be peg parameters. "a" does not always stand for Peg #1.
13:56:16 <glguy> It's the same operation every time
13:56:23 <monochrom> In a typical recursive call it is very possible that "a" stands for Peg #3, "b" stands for Peg #1, "c" stands for Peg #2.
13:58:39 <butterthebuddha> No I understand that
13:59:00 <monochrom> In retrospect it does not have to be 3 parameters. It could be 6 mutually recursive functions instead.
13:59:23 <mauke> the exercise tells you to write hanoi :: Integer -> Peg -> Peg -> Peg -> [Move]
14:00:34 * ski . o O ( `Natural -> Iso Peg Peg -> [Move]' )
14:00:47 <monochrom> Suppose you ask me to write this program: input a list like [w,x,y,z], output w-x+y-z. In general toggle between (+) and (-).
14:01:40 <monochrom> I am going to write this recursive helper: helper op1 op2 (x:xs) = op1 x (helper op2 op1 xs). My recursive call switches op1 with op2.
14:02:08 <monochrom> And my top-level function is going to be f xs = helper (+) (-) xs.
14:04:46 <ertes> > foldr (\x ~(xs, ys) -> (x:ys, xs)) mempty ['a'..'z']
14:04:48 <lambdabot>  ("acegikmoqsuwy","bdfhjlnprtvxz")
14:10:08 <razwelles> I'm trying to remember but does haskell let you define an integer with a specific range of valid values? Like [7..23]? Or perhaps I was thinking of another language?
14:10:20 <monochrom> It's another language.
14:10:28 <monochrom> For example Pascal.
14:11:14 <razwelles> monochrom: ohh thank you, are there other languages with that feature? Does it have a specific name?
14:11:26 <monochrom> One day shapr is going to kick me for doing what palomer did, except I use an even more ancient language :)
14:11:39 <ChaiTRex> razwelles: You could create a type like that in a module that doesn't export the constructor but a function that checks bounds.
14:11:57 <monochrom> I think Ada also has it. I forgot the name.
14:12:04 <monochrom> (The name of this feature.)
14:12:06 <ertes> razwelles: you can do it in haskell with a few extensions
14:12:17 <monochrom> Maybe "subrange type"?
14:12:24 <ertes> as long as the number range is static
14:12:37 <ertes> if it's dynamic, you can still do it, but you will wish you hadn't
14:12:46 <razwelles> haha
14:12:55 <razwelles> This is helpful, thanks everyone
14:13:27 <razwelles> subrange type was the correct name, monochrom
14:13:30 <razwelles> found it
14:13:33 <monochrom> neato
14:13:55 <monochrom> My 20th century education has some use afterall :)
14:14:05 <razwelles> haha
14:15:12 <ertes> if your range includes negative numbers, you will burn your hands while doing it
14:15:29 <ertes> if it includes fractions, you will be hearing satan's breath in your neck the whole time
14:16:13 <monochrom> I promise I will include Gaussian integers only.
14:16:34 <monochrom> I want the range from -4-5i to 3+7i.
14:18:00 <monochrom> Actually what's wrong with fractions? Dedekind did exactly that.
14:18:04 <geekosaur> and now you're going to be degaussed?
14:18:11 <monochrom> Haha
14:18:25 <ertes> monochrom: nothing, it's just satan will be watching you
14:19:05 <hexagoxel> butterthebuddha: maybe stop thinking of specific steps/moves. do you know how to move 0 discs? do you also know how to move n discs, given that you already know how to move (n-1) discs? note that moving (n-1) discs can be viewed as a single "step" there.
14:19:13 <ertes> but if your range includes real numbers, GHC might turn into a black hole
14:20:06 <monochrom> I'm OK with sticking to rational numbers.
14:20:40 <monochrom> Just allow me to specify a range like "those rational numbers whose squares are below 2" and I'll cope. 
14:22:40 <dimitrovskif> Why doesn't "log2 4" halt? log2 1 = 0; log2 x = 1 + log2 (quot x 2)
14:23:30 <monochrom> > let {log2 1 = 0; log2 x = 1 + log2 (quot x 2)} in log2 4
14:23:30 <Tuplanolla> Put it into a file, dimitrovskif.
14:23:32 <lambdabot>  2
14:23:34 <glguy> dimitrovskif: It does. Perhaps you wrote the two clauses on separate lines in GHCi?
14:23:37 <monochrom> worksforme
14:23:47 <dimitrovskif> glguy: Yeah I did. Why?
14:23:50 <dimitrovskif> It's my first program
14:24:08 <glguy> dimitrovskif: the first definition of log2 was overwritten by the second
14:24:12 <ertes> dimitrovskif: you wrote a function "log2 1 = 0", then you redefined it to "log2 x = …"
14:24:34 <glguy> dimitrovskif: You can't just paste a .hs file into GHCi and expect the same result, it's a different environment
14:25:01 <dimitrovskif> glguy: ertes: Yeah I get it
14:25:34 <ertes> dimitrovskif: you can write it like this in GHCi:  log2 1 = 0; log2 x = …
14:25:46 <ertes> but a file is more convenient
14:25:50 <dimitrovskif> I added the colon so that I don't pollute the IRC chat
14:26:31 <dimitrovskif> semicolon*. But it seems I accidentally did the right thing
14:27:24 <monochrom> semicolon is also good for ghci
14:27:39 <monochrom> semicolon is part of standard Haskell.
14:28:43 <dimitrovskif> So how do you type functions in GHCi without typing all the patterns at once?
14:28:57 <dimitrovskif> I guess it's impossible?
14:28:59 <ChaiTRex> dimitrovskif: Separate the patterns with a semicolon.
14:29:06 <monochrom> Ah I see what you mean. This is when you get to say: Great minds think alike, the designers of Haskell thought like you :)
14:29:19 <ertes> dimitrovskif: you can use the :{" syn…  no, it's impossible
14:29:22 <ChaiTRex> > let zomg 0 = 1; zomg n = n + 1 in map zomg [1..10]
14:29:24 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
14:30:07 <monochrom> Yeah if you enter one line ":{", then GHCi will wait for you to enter multiple lines. Then you end with ":}"
14:30:30 <monochrom> But very soon you will find that it is a useless trivia pursuit. It doesn't scale.
14:30:47 <monochrom> Because what happens if you want to edit a formerly entered line?!
14:30:53 <dimitrovskif> Seems to be a cool language... Not gonna ask about monads, haha.
14:30:54 <hexagoxel> dimitrovskif: :set +m
14:30:56 <monochrom> Only a real editor scales.
14:31:25 <hexagoxel> then it won't terminate the definition after your first "let" line
14:31:33 <Tuplanolla> You turn it on and it scales right out!
14:31:58 <ertes> GHCi in isolation is a calculator…  if you want to do programming, you should always have an editor open alongside GHCi
14:32:04 <ertes> if not even an editor with GHCi built in
14:32:12 <ChaiTRex> That would be nice :)
14:32:41 <monochrom> Next April 1st project: Merge GHCi with sed.
14:33:08 <ChaiTRex> Have a bunch of source files opened in tabs of a text editor and one extra tab for GHCi.
14:33:23 <ChaiTRex> Or GHCi at the bottom or something.
14:34:10 <zomg> ChaiTRex: u wot m8
14:34:31 <monochrom> Wait, +m exists? What does it do?
14:34:32 <ertes> breaking news: greatest threat to the earth since the LHC: GHC about to be merged into busybox
14:34:47 <monochrom> Ah found it.
14:34:57 <joe9> I have a timezone string "EDT" that I want to convert UTCTime to. I cannot figure out how to build the TimeZone data type from just the "EDT" (no minutes or seconds offset). Any suggestions, please?
14:35:12 <monochrom> Ah neato.
14:35:26 <monochrom> Against my philsophy, but neato, much more ergonomic now.
14:36:07 <ertes> joe9: there is minutesToTimeZone/hoursToTimeZone
14:36:18 <ertes> joe9: or you can construct the TimeZone value by yourself
14:36:41 <monochrom> ertes: I would love that! It means henceforth every home router will have GHC because it has busybox...
14:37:06 <monochrom> Hell, my Kindle will have GHC too because...
14:37:19 <joe9> ertes, the minutesToTimeZone, I need to build the minutes offset myself. I just know the zonename EDT. I can look up the minutes manually and hardcode it. But, I prefer the system does that conversion.
14:39:48 <butterth_> So I guess I understand how to code it now, but how do I code it without any mutation
14:40:15 <butterth_> I still need a way to store the moves
14:40:36 <monochrom> This is why I showed you the example of "map" first.
14:40:40 <monochrom> @src map
14:40:40 <lambdabot> map _ []     = []
14:40:40 <lambdabot> map f (x:xs) = f x : map f xs
14:40:59 <monochrom> No one stores the "output list". Output it right away.
14:41:03 <thang1> oooh dat src command is awesome
14:41:27 <monochrom> It is actually hand-curated, thang1. It does not get synced with reality.
14:41:37 <monochrom> For example:
14:41:43 <monochrom> @src length
14:41:43 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:41:52 <thang1> aww, so sad
14:42:06 <ertes> also be sure not to make typos, or you'll invoke tsunderebot
14:42:12 <monochrom> Hrm, that may actually be synced with reality. (Still, hand-synced, not automatic.)
14:42:16 <Zemyla> @src sort
14:42:16 <lambdabot> sort = sortBy compare
14:42:20 <Zemyla> @src sortBy
14:42:20 <lambdabot> -- The actual definition used by GHC is an optimised mergesort.
14:42:20 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
14:42:36 <glguy> fortunately you can just click the 'Source' link in the haddocks of most packages
14:42:37 <thang1> Although I guess it's a good idea to prevent 500 line pasting by lambdabot
14:43:05 <ChaiTRex> thang1: lambdabot automatically cuts off after a few lines or so.
14:43:11 <thang1> glguy: Being lazy, I would've liked lambdabot to actually just search hackage for me and extract the source and paste it in here or give me a link if it's more than 2ish lines
14:43:23 <thang1> ChaiTRex: I figured. Good t'know for sure though
14:43:37 <glguy> thang1: that might encourage people to do that
14:43:39 <monochrom> Ah, emitting a link is actually a good idea.
14:43:42 <butterth_> Something like this? https://gist.github.com/awesomeaniruddh/814d57009b8132f6181d3d5ecdf2e607
14:43:53 <thang1> Yeah, exactly.
14:44:00 <monochrom> Yes butterth_
14:44:06 <joe9> Is there a way to lookup the minutes offset used by TimeZone when I just know the zonename?
14:44:27 <thang1> It doesn't need to duplicate code and make random links though, but just giving me a link to the source through haddock is fine
14:44:33 <monochrom> Except there are still blanks to fill in, and you need two recursive calls not just one.
14:44:39 <monochrom> But I think you know.
14:45:00 <thang1> joe9: There are tables online. Idk if there's a pretty package made yet
14:45:45 <thang1> Also, is there any concrete description of how GHC's testing suite and automated everything actually works?
14:46:15 <ertes> joe9: i don't see an interface in the 'time' package itself, but i found this: https://hackage.haskell.org/package/timezone-olson
14:46:17 <thang1> I'm looking at summer of haskell stuff and debating between fixing GHC's testsuite and using LH to prove the base
14:46:32 <joe9> ertes, Thanks. will check it out.
14:47:01 <ChaiTRex> thang1: What's LH?
14:47:08 <thang1> s/LH/LiquidHaskell
14:47:22 <thang1> joe9: http://projects.haskell.org/time-ng/ timezone-series looks more like what you want, though
14:47:38 <thang1> Unless you're actually using binary Olson timezone files
14:48:19 <ertes> timezone-olson has a timezone-series interface
14:49:46 <monochrom> thang1: I think fixing GHC's testsuite is both more reachable and has more longlasting benefits.
14:50:19 <thang1> That's what I was thinking too. Code moves pretty fast in haskell, but GHC is slower moving
14:50:43 <monochrom> But is there some problem in the testsuite to fix?
14:50:47 <thang1> I don't have much of any information on how things are actually setup, though... Do people just run testsuites on their own computers?
14:51:03 <monochrom> The GHC devs certainly do.
14:51:09 <monochrom> I certainly don't.
14:51:18 <thang1> https://ghc.haskell.org/trac/ghc/ticket/12758
14:52:08 <butterth_> Okay, I don't really understand the code I just wrote, but it works - https://gist.github.com/awesomeaniruddh/814d57009b8132f6181d3d5ecdf2e607
14:52:09 <monochrom> Ah.
14:52:19 <butterth_> Can anyone explain how this works to me?
14:52:20 <thang1> But, like, whyyy. Test-suites should be run on servers using CI to ensure consistent measurements. Just push to test repo and then bam, metrics n shit
14:52:42 <ertes> i can imagine what the vulcans will *really* think when they visit earth: "hmm…  they're wasting 4.7 gigawatts a day for timezone computations, and their most advanced AI is telling them where to find restaurants…  they're not ready, let's go"
14:53:01 <thang1> haha I can imagine
14:54:02 <thang1> butterth_: Your first line can be replaced with hanoi 1 p1 p2 _ = [(p1,p2)]
14:54:02 <monochrom> butterth_: It means: Use a recursive call to emit instructions for the first subproblem, then emit the instruction "move 1 disc from p1 to p2", then a recursive call to emit the instructions for the 2nd subproblem.
14:54:03 <glguy> thang1: The test suite is run by the CI server, too. People tend to like the immediate feedback of being able to run a test on their machine while they're working on a problem
14:54:48 <thang1> glguy: good to know. Is there anywhere where I can find an overview of how everything is setup and a good starting point to where revamps and fixes to the testsuite would be appreciated?
14:55:06 <butterth_> No like I know what the code itself does, but I still don't understand how the algorithm works :/
14:55:57 <monochrom> I am not entirely sure what you mean. But it is possible to use induction to prove that the emitted instructions are correct.
14:57:41 <thang1> butterth_: https://www.cs.cmu.edu/~cburch/survey/recurse/hanoiimpl.html http://stackoverflow.com/questions/1223305/tower-of-hanoi-recursive-algorithm
14:57:43 <thang1> do these help?
14:58:06 <thang1> (whoops forgot the space)
15:01:23 * ski . o O ( iterative hanoi )
15:05:00 <thang1> The other project I thought of doing would be to make a superior documentation system for Haskell somehow. Because haskell documentation generally sucks ass 
15:05:40 <ertes> does it?
15:05:54 <c_wraith> haskell documentation is generally excellent.
15:06:19 <thang1> I've repeatedly heard that it's a pain point for a lot of people, with thousands of libraries consisting of literally nothing but type signatures generated by haddoc
15:06:21 <monochrom> Is that a function of the authors or is it really a function of the system?
15:06:40 <monochrom> OK but that's a function of the authors.
15:06:57 <ertes> thang1: that's a social aspect, not a technical one…  haddock is quite great
15:06:58 <thang1> monochrom: I feel it's both. If you look at the language Racket with its Scribble documentation setup, the entire ecosytem top to bottom has beautiful, comprehensive, amazing documentation compared to pretty much every other language
15:07:17 <monochrom> If you inflicted Doxygen on me I would still not lift one single finger and the resulting doc would still be like that.
15:07:22 <c_wraith> ok, any time someone described documentation as "beautiful", I know they don't care about the right things.
15:07:32 <ertes> thang1: and i'm not even calling it a social *problem*…  it's an aspect
15:07:33 <thang1> s/beautiful/useful
15:07:58 <thang1> to me, documentation is beautiful if it's useful and easily scannable. I don't care if the CSS is perfect
15:08:22 <ertes> but haddock has that
15:08:27 <c_wraith> type signatures are often all the documentation you need.  I've written code using only type signatures to do decidedly non-trivial things.  Haskell type signatures say a *lot*.
15:08:51 <Tuplanolla> Type signatures don't tell anything about exceptions or time complexity.
15:08:52 <monochrom> System-wise, I think it got all wrong right at the beginning with Javadoc (which subsequently everyone duplicates, including Doxygen and Haddock). The institutional problem is with the idea of per-method narrative.
15:09:06 <c_wraith> Sometimes they're not enough.  But most libraries where signatures aren't enough actually document the rest.
15:09:23 <ertes> thang1: the problem is that programmers are so used to languages with simplistic or non-existent type systems that they expect everything to be explained in detailed prose
15:09:41 <ertes> of course you would expect that, if the thing you're working with has side effects and global state everywhere
15:10:01 <ertes> now look at this:
15:10:07 <ertes> map :: (a -> b) -> [a] -> [b]
15:10:17 <ertes> i know exactly what this does, because the name and the type tell me
15:10:28 <glguy> obviously that returns an empty list of type [b]
15:10:30 <monochrom> Especially with OOP, the real meaning is with the interactions between objects and between methods, not with individual methods. True of FP and even more pressingly true of OOP, and ironically it's Javadoc which started this maximumly pessimistic system.
15:12:17 <thang1> So, documentation should reflect that nature and should make it as easy to write documentation to that nature as possible, discouraging the stupid/worse way of doing things
15:12:45 <Tuplanolla> We have a name for the kind of documentation you desire, monochrom.
15:12:54 <Tuplanolla> Books.
15:13:25 <thang1> Do they automatically get updated when code changes, warn you of now incomplete documentation, and are there tools which help you write those books in any way shape or form?
15:13:45 <c_wraith> thang1: that's why type signatures are such great documentation.  The compiler checks them.
15:13:50 <ertes> haddock docs are part of the source code
15:14:01 <iqubic> Why does the typeclass Traversable have Foldable as a type constraint?
15:14:18 <c_wraith> iqubic: because Traversable is strictly stronger than Foldable
15:14:20 <ertes> and yes, haddock tells you documentation coverage
15:14:26 <iqubic> c_wraith: Why is that?
15:14:34 <c_wraith> iqubic: that is, you can trivially construct all the methods in Foldable from the ones in Traversable
15:14:42 <iqubic> You can?
15:14:45 <c_wraith> iqubic: Functor is a superclass for the same reason
15:14:51 <c_wraith> iqubic: yep!
15:15:21 <iqubic> Can I see you write Foldr using just Traversable methods?
15:15:28 <iqubic> Just as an example.
15:15:29 <ertes> thang1: here is a challenge: write documentation for the 'map' function such that you don't sound like a broken record
15:15:37 <c_wraith> iqubic: see the bottom of https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Traversable.html
15:16:09 <c_wraith> iqubic: fmapDefault builds fmap from Traversable, foldMapDefault builds foldMap (a complete definition of Foldable) from Traversable
15:16:26 <thang1> ertes: But map is exactly the type of trivial function that makes people think every single haskell function can be completely understood through type signatures alone
15:16:40 <Tuplanolla> :t alaf Const traverse -- Here it is, iqubic.
15:16:42 <lambdabot> (Monoid a', Traversable t) => (a -> a') -> t a -> a'
15:16:55 <Tuplanolla> It's not particularly enlightening in that form.
15:17:09 <iqubic> what does alaf mean
15:17:27 <glguy> Tuplanolla: What function is that?
15:17:29 <ertes> thang1: what i'm trying to say is: documentation is not good because it has lots of text in it
15:18:00 <iqubic> glguy: It's foldMapDefault from Data.Traversable
15:18:25 <thang1> ertes: I found this link to be pretty good at criticising haddock: https://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/
15:18:39 <iqubic> Challenge: Can someone write foldr by only using foldMap?
15:18:41 <ertes> thang1: emacs sometimes forgets that, and it has the same built-in, comprehensive documentation system as racket, perhaps even more than racket
15:18:41 <Tuplanolla> It's `alaf Const f g = getConst . f (Const . g)`, iqubic and glguy.
15:18:56 <glguy> Tuplanolla: I see. I thought foldr was asked for
15:19:04 <glguy> (hence my question)
15:19:12 <Tuplanolla> Ah.
15:19:19 <bbear> nobody uses emacs at work
15:19:22 <bbear> it's weird
15:19:39 <iqubic> Challenge: Can someone write foldr by only using foldMap?
15:19:50 <thang1> Really? I thought almost all professional haskell programmers were doing emacs still
15:20:02 <ChaiTRex> @src foldMap
15:20:03 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:20:10 <ChaiTRex> I haven't yet.
15:20:32 <c_wraith> ChaiTRex: foldMap is part of the Foldable class - it doesn't have a single implementation
15:20:38 <iqubic> No. I use Vim to write Haskell Code
15:20:49 <glguy> Tuplanolla: If you're going the lens route,  'views traverse'
15:20:56 <Tuplanolla> Nice.
15:21:03 <thang1> Vim + Intero is pretty great, too
15:21:11 <iqubic> What's Intero?
15:21:25 <jxv> sup lexi-lambda
15:21:55 <thang1> Intero is the best thing since sliced bread
15:22:09 <thang1> https://github.com/commercialhaskell/intero
15:22:15 <ChaiTRex> Unfortunately, the documentation for foldMap gives away the answer.
15:22:18 <jxv> why?
15:22:30 <ertes> intero is like haskell-mode, but with a stack sales pitch built in
15:22:35 <thang1> (or for vim: https://github.com/myfreeweb/intero.nvim )
15:22:36 <MP2E> hah :p
15:22:46 <iqubic> ertes: Can I get it as a vim plugin? 
15:22:48 <jxv> but I don't even use ghc-mod :/
15:23:06 <thang1> Intero doesn't use ghc-mod. It uses stack, automatically installs itself if needed, and so on
15:23:17 <ertes> iqubic: if it didn't get across, i don't like it and don't recommend it ;)
15:23:29 <thang1> Much more useful than every other haskell plugin I've tried because of how easily it "just werkz"
15:23:30 <iqubic> ertes: What do you use?
15:23:35 <ertes> iqubic: haskell-mode
15:23:40 <thang1> Probably M-x butterfly on stone tablets
15:23:47 <iqubic> ertes: In Emacs?
15:23:48 <jxv> I mean having code helper plugins is not that important
15:23:54 <ertes> iqubic: yes
15:24:06 <iqubic> Ah. I use Vim.
15:24:12 <MarcelineVQ> I've been moving towards just ghcid lately, because it's reliable
15:24:18 <ertes> both haskell-mode and intero are for emacs
15:24:46 <thang1> (although intero is more of a universal backend that works with multiple text editors such as Atom, Neo-vim, emacs, etc)
15:24:46 <iqubic> ertes: This page says otherwise: https://github.com/myfreeweb/intero.nvim
15:25:01 <yushyin> that’s still nvim not vim
15:25:06 <ertes> ah, ok…  well, the original intero was for emacs =)
15:25:08 <iqubic> I use nvim
15:25:20 <iqubic> So, what is ghc-mod?
15:25:44 <yushyin> another helper binary + editor plugin
15:25:49 <thang1> ghc-mod is a heavily hacked ghci with a ton of fancy shit added into it. In my experience, it tends to break semi-constantly because I'm not good enough at babysitting it
15:25:55 <Gurkenglas> :t alaf Endo foldMap -- iqubic, here (except the arguments are the right way round)
15:25:57 <lambdabot> Foldable t => (a1 -> a -> a) -> t a1 -> a -> a
15:26:47 <glguy> :t foldrOf traverse
15:26:49 <lambdabot> Traversable t => (a -> r -> r) -> r -> t a -> r
15:26:52 <yushyin> iqubic: very much the same idea as intero but less userfriendly maybe?
15:27:01 <iqubic> What's the best plugin(s) for editing Haskell code in Neovim?
15:27:04 <thang1> ertes: http://docs.racket-lang.org/lens/lens-guide.html  vs https://hackage.haskell.org/package/lens#readme 
15:27:09 <Gurkenglas> (Though it's understandable that foldr would more often be used with its current order - like (`evalState` sometrivialstartingstate)
15:27:30 <thang1> ertes: I find the Racket one way superior and an example of the kind of documentation I like to see
15:28:05 <ertes> thang1: https://hackage.haskell.org/package/pipes-4.3.2/docs/Pipes-Tutorial.html
15:28:25 <yushyin> iqubic: there is also vaporware like haskell-ide-engine!
15:29:08 <iqubic> yushyin: What does that do? And why do you call it vaporware?
15:29:09 <ertes> thang1: the default stylesheet of haddock could be less brain-damaged, but yeah, you can have those things
15:29:48 <ertes> thang1: or to take an example of my own: https://hackage.haskell.org/package/progress-meter-0.1.0/docs/System-ProgressMeter.html
15:30:19 <Gurkenglas> :t foldrOf folded
15:30:20 <lambdabot> Foldable f => (a -> r -> r) -> r -> f a -> r
15:32:20 <thang1> Nice, ertes 
15:32:21 <yushyin> iqubic: well I could just cite the readme or you read it yourself :) vaporware because it is so long in the making and no release in sight
15:34:19 <thang1> So, to drop the documentation thing... Back to GHC testsuite
15:55:20 <robertkennedy> Did that lpaste come through?
15:56:10 <lpaste> robertkennedy revised “Odd FunctionalDependencies rejection”: “Odd FunctionalDependencies rejection” at http://lpaste.net/354696
15:58:28 <robertkennedy> There we go. Anyone have an idea why this fundeps fails? Possibly related to the undecidable super class, or more simply an overloaded instance collapse (which this pattern hacks around(
16:01:56 <monochrom> "a" basically overlaps with everyone in the world.
16:02:16 <monochrom> in "instance Trek's NotP a"
16:05:46 <robertkennedy> Right, that's why I do the `Trek' aisp a` and fork on aisp. The functional dependency holds, and the code works great - I was surprised I couldnt add the trivial dependency
16:06:23 <monochrom> a -> aisp? aisp -> a?
16:07:20 <robertkennedy> a -> aisp (aisproduct in the code, sorry)
16:07:52 <glguy> robertkennedy: since the 'a' parameter doesn't actually uniquely determine the 'aisproduct' parameter, you can't use a functional dependency there
16:07:54 <nshepper1> robertkennedy: (a :&&: b) has two Trek' instances in that code
16:10:07 <nshepper1> Your functional dependency asserts that there is only one
16:10:58 <robertkennedy> How do you figure? In particular, this module ends up only exporting `type Trek a = Trek' (CheckP a) a`, and `CheckP (a :&&: b) = IsP`
16:11:09 <glguy> It doesn't matter what you export
16:14:01 <monochrom> instances are always exported. There is no export control over this.
16:19:33 <robertkennedy> Right, but there is no remaining ambiguity. And I don't mean to focus on the import barrier as if it were magical, only to help elucidate my API, which this design may not be the most conducive to
16:20:31 <glguy> you have two dependencies:     'x -> NotP' and 'y :&&: z -> IsP'
16:20:53 <glguy> Now given some type    'a :&&: b' you've asserted that aisproduct is both NotP and IsP
16:23:36 <robertkennedy> Ahhhh. You're saying that the functional dependency asserts `further instances will clarify the dependency`, not that they should conform to it
16:25:51 <ij> Are exceptions comparable?
16:25:52 <robertkennedy> I'm not sure I communicated that well, but I think I see my problem in understanding
16:31:56 <EvanR> ij: yes, since exceptions are all dynamically typed
16:32:18 <EvanR> thats the last resort when trying to handle exceptions precisely
16:33:21 <ij> So how do I know that «e :: SomeException» is ThreadKilled?
16:34:35 <EvanR> :t toException
16:34:37 <lambdabot> Exception e => e -> SomeException
16:34:41 <EvanR> :t fromException
16:34:43 <lambdabot> Exception e => SomeException -> Maybe e
16:34:47 <EvanR> fromException
16:35:13 <EvanR> make sure you really need to catch that exception
16:35:28 <EvanR> i mean, specifically
16:35:38 <ij> It's the last resot for printing errors, so I'll catch all but ThreadKilled.
16:35:51 <EvanR> huh?
16:36:13 <ij> Why shouldn't I catch all exceptions?
16:36:25 <ij> In this case, that is.
16:36:49 <EvanR> you shouldnt catch all exceptions generally, but doing cleanup in case of any exception then rethrowing is another story
16:36:59 <EvanR> and is easier
16:37:14 <EvanR> Control.Exception bracket, finally
16:37:23 <ij> I've a server and I don't want crappy code to kill the server and close the connection.
16:37:32 <EvanR> why would it?
16:37:42 <EvanR> are you handling the connection in a separate thread?
16:37:46 <ij> Yes.
16:37:52 <EvanR> so the thread will die
16:37:57 <ij> I want reports.
16:37:59 <EvanR> not the whole server
16:38:18 <EvanR> yes the thread monitoring your connection threads can wait for death exceptions from the children
16:38:24 <EvanR> and log it
16:38:50 <ij> Hmm, so I don't need to add a catchJust in the (perhaps) dying thread, but in the monitoring thread?
16:39:03 <EvanR> ThreadKilled can be caught (if youre really using that mechanism) in the child thread to quit normally instead of crashing
16:39:42 <EvanR> the thread that spawned the thread in the first place can arrange to get the final exception from the connection threads, and the async library has a really nice wrapper for doing that
16:40:09 <EvanR> by get the exception, i dont mean crash, but get it as a value
16:40:24 <ij> :)
16:41:55 <EvanR> see exceptions were designed to be mostly ignored in your code, and perhaps handled at some central point (or not) to simplify your code. using them for complex flow control is going backwards
16:43:05 <ij> So you're saying I'm doing that? — Using them for complex flow control?
16:43:26 <EvanR> doing alot of work with exceptions at all basically is going backwards
16:43:34 <EvanR> i say
16:44:06 <EvanR> the async library helps with removing exception management from your application code
16:45:20 <ij> Do you really hate exceptions?
16:46:52 <EvanR> no
16:47:05 <EvanR> they are awesome
16:47:14 <EvanR> because by default they dont enter into the code... they are exceptions!
16:47:38 <hpc> there's a lot to not like about exceptions, but they're convenient at times
16:48:09 <hpc> i would feel better about them if they behaved more like java's managed exceptions
16:48:19 <hpc> whatever it was possible to throw being captured in the type
16:48:28 <iqubic> How does haskell handle exceptions?
16:48:28 <EvanR> that type would be ginormous
16:48:42 <hpc> yeah, main's type would be utter hell
16:48:47 <hpc> but i want it anyway
16:48:52 <EvanR> most IO primitives
16:49:11 <Tuplanolla> My main objection to that is that the type would leak abstraction details all the way down from the hardware implementation.
16:49:20 <EvanR> mains type is ideally "cant throw an exception"
16:49:30 <EvanR> because its handled (mostly by the default handler)
16:49:35 <ij> EvanR, So is there any particular function you want to suggest from async regarding catching exceptions?
16:49:36 <iqubic> How does Haskell manage exceptions?
16:49:50 <iqubic> Like can I throw an exception, and catch it later?
16:49:55 <EvanR> ij: the central function there, async
16:50:31 <EvanR> other functions in there let you wait on the child threads
16:50:36 <ij> And thenn poll?
16:50:41 <EvanR> no
16:50:49 <EvanR> no polling ever!!!
16:51:04 <ij> Sorry, waitCatch.
16:52:21 <ij> Okay, I've no idea what your suggestion was. I got that no one should write exception code though.
16:52:39 <EvanR> not very much
16:52:52 <EvanR> its just balloons if you try to do things the hard way
16:53:17 <hpc> if you think about it, exceptions are effectively invisible gotos to anywhere in your program
16:53:25 <EvanR> heres another suggestion, when you fork your connection thread, use forkFinally and do the logging of the exception from there
16:53:27 <hpc> (if you don't think about it, they are still that anyway)
16:53:43 <EvanR> from the cleanup action
16:54:32 <iqubic> Does Haskell have exceptions at all?
16:55:09 <iqubic> I haven't run into them yet.
16:55:10 <ij> Yes, https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception.html 
16:55:18 <geekosaur> considering we discussed this in your presence last night I start to think you are a troll
16:56:12 <iqubic> Geekosaur, I was not reading the logs last night.
16:56:16 <monochrom> ij: I recommend my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
16:56:48 <ij> geekosaur, me?
16:57:05 <geekosaur> ij, no, not you
16:58:16 <sveit> due to laziness of (++), isn't it efficient to use a list as a FIFO queue by appending to the end?
16:58:52 <monochrom> ij: More specifically, for ThreadKilled, you can first nail the type to AsyncException, and then pattern-match (ThreadKilled is a data constructor of the AsyncException ADT).
16:59:15 <monochrom> And sometimes you may enjoy combining both steps into one single tryJust.
16:59:39 <monochrom> But see my article for how to nail the type and how to use tryJust.
17:00:05 <monochrom> If you prefer catch* to try*, there is catchJust too.
17:00:55 <Tuplanolla> :t fetch -- Would you like it if everything looked like this, hpc?
17:00:57 <lambdabot> (Checked 'EPERM a, Checked 'EPROTO a, Checked 'EOPNOTSUPP a, Checked 'ENOTSOCK a, Checked 'ENOMEM a, Checked 'ENOBUFS a, Checked 'ENFILE a, Checked 'EMFILE a, Checked 'EINVAL a, Checked 'EINTR a,
17:00:57 <lambdabot> Checked 'EFAULT a, Checked 'ECONNABORTED a, Checked 'EBADF a, Checked 'EAGAIN a, Checked 'EWOULDBLOCK a) => String -> a
17:01:15 * monochrom jaw-drops
17:01:30 <monochrom> Oh haha I see what you did there.
17:02:01 <monochrom> Exception is approximately the only case I would like  a subtype/subclass system. :)
17:02:02 <Tuplanolla> Oh, the kernel changed its implementation! We need to add `Checked 'EINVAL a` to it now.
17:02:49 <monochrom> No wait, a co-row polymorphism system is better.
17:02:52 <hpc> heh
17:04:41 <monochrom> Idris's version would be a bit nicer, (Checked [EPERM, EPROTO, ...] a) => String -> a, or something like that.
17:05:21 <monochrom> The gist being a type-level list so you only need an n-length list rather than n Checked clauses.
17:05:53 <Axman6> you can do that in Haskell too
17:06:11 <ij> Should "fromException (SomeException ThreadKilled) :: Maybe SomeException" work?
17:06:26 <monochrom> No. I can encoding that in Haskell.
17:06:49 <monochrom> @type fromException
17:06:50 <lambdabot> Exception e => SomeException -> Maybe e
17:07:11 <monochrom> Yes.
17:07:27 <monochrom> Err, no.
17:07:29 <ij> errr, «:: Maybe AsyncException». It returns "Nothing"
17:07:52 <ij> And the «show … :: Maybe SomeException» returns «Just thread killed».
17:08:02 <monochrom> You want fromException (SomeException ThreadKilled) :: Maybe AsyncException
17:08:21 <ij> This is what happens: http://sprunge.us/PPKX
17:08:37 <monochrom> But you want neither. Just let "try" and "tryJust" do it, will ya?
17:09:04 <ij> But I want all except ThreadKilled.
17:10:06 <monochrom> Then use Maybe AsyncException, then patch-match against Just ThreadKilled.
17:11:29 <ij> But there's nothing to pattern match against, as you see — it's Nothing in the case of Maybe AsyncException.
17:12:26 <ij> > (\(ThreadKilled) -> 1) <$> (fromException (SomeException ThreadKilled) :: Maybe AsyncException)
17:12:28 <lambdabot>  Nothing
17:13:08 * ij squints. Is that pattern matching?
17:13:17 <ij> Yeah, should be.
17:16:21 <monochrom> That's odd.
17:17:16 <ij> I should really get some sleep. Tomorrow's the first work day after easter.
17:18:17 <ij> I've a bouncer, so I'll receive anything if you happen to stumble upon anything. Night night.
17:18:19 <sveit> sorry to bump, but maybe i can be more specific. Does a list work well as a FIFO queue, with push queue e = queue ++ [e]; since (++) is lazy if i only ever pop from the list it shouldn't do the O(n) append, right? so in this sense push would be O(1), as would pop?
17:19:12 <geekosaur> sveit, FIFO? no, it must traverse the list. you do not have a direct pointer to the end, so even if the push is lazy the pop will force both the push and the pop
17:19:48 <geekosaur> if you want to use a list as FIFO, use (:)
17:20:30 <sveit> sorry, i'm a bit confused. if i have push queue e = queue ++ [e], and pop = head, this is a FIFO queue, right?
17:21:26 <geekosaur> no, that's LIFO because anything you push onto the end will only be accessed after the stuff in front of it
17:22:02 <geekosaur> your "push" is [a,b,c,d,e] ++ [f], your "pop" is a : [b,c,d,e]
17:22:05 <geekosaur> er
17:22:07 <geekosaur> your "push" is [a,b,c,d,e] ++ [f], your "pop" is a : [b,c,d,e,f]
17:22:37 <geekosaur> oh wait I am confused now :/
17:22:47 <geekosaur> no, I think you're right, fifo feeds through like that
17:22:54 <geekosaur> my nap ws clearly a failure :/
17:22:55 <sveit> i think you're confused about what fifo means :)
17:23:06 <kadoban> That should be a FIFO, but it's not a very performant one, is it?
17:23:09 <geekosaur> yes, I had to stop and think. now I hgave to see what I can do about my head
17:23:45 <sveit> geekosaur: thanks for the help anyway :)
17:23:47 <geekosaur> well, with laziness it's a bunch of thunks that get forced eventually, it's not as bad as a strict one would be but it's not as good as it could be
17:24:03 <geekosaur> anyway having rethought you are correct but it's not as simple as you are suggesting
17:24:23 <geekosaur> but I should not try to work out the actual asymptotics until I figure out wha;s up with my brain tonight :/
17:25:01 <sveit> why is it not as simple as I am suggeting?
17:26:19 <geekosaur> because every append is a thunk that gets forced at pop time instead of happening at push time; you get to avoid traversal at the price of all pops taking a bit longer
17:26:20 <kadoban> If you have a list of length N, and you add to the back of it like you're suggesting, that one add requires \Theta(N) work, once you evaluate far enough to get to the end. Each addition to the end adds O(1) work for each thing you take from the front. Unless I'm massively confused somehow.
17:26:48 <geekosaur> ^ roughly that
17:26:52 <kadoban> So adding a bunch of stuff and then removing all of it should be \Theta(n^2)
17:27:27 <kadoban> (where "adding" and "removing" are using the queue operations)
17:29:33 <sveit> really? (x:xs) ++ ys = x : (xs ++ ys) and [] ++ ys = ys, so where is the extra work happening?
17:30:02 <sveit> suppose i have [a,b] and push e, then i have ([a,b] ++ [e])
17:30:16 <sveit> first pop takes O(1) work, right?
17:30:36 <sveit> second pop takes O(1) work too?
17:30:45 <sveit> so where does extra work come in?
17:31:02 <geekosaur> not at the level you are looking at
17:31:08 <geekosaur> because that level does not show thunks
17:31:20 <kadoban> sveit: The (x:xs) ++ ys = x : (xs ++ ys)   thing happens for *every* thing in the original xs.
17:32:23 <Cale> sveit: It costs O(1) *additional* work per element of xs whenever you compute xs ++ ys. That is, getting the first element of xs ++ ys is O(1) + whatever the cost of getting the first element of xs was
17:32:43 <Cale> sveit: and you continue paying that cost all throughout the elements which belonged to xs
17:33:12 <EvanR> sveit: it might help to work through the ++ expressions as they evaluate
17:33:42 <monochrom> ij: "SomeException ThreadKilled" is no longer a good test since base 4.7.0.0. "fromException (toException ThreadKilled) :: Maybe AsyncException" works, and is a more realistic test. Regardless of what you believe, the only standard is working for an actually killed thread, as opposed to your own emulation of ThreadKilled.
17:33:51 <Cale> If you end up evaluating the whole list, you'll have expended a total of O(n) additional work for that (++), with n being the length of xs
17:34:21 <EvanR> (([a] ++ [b]) ++ [c]) ++ [d] is what youre asking about, what kind of time performance you get
17:34:33 <sveit> Cale: so you're saying if i process the whole list, by the end i'll have done O(n) extra work?
17:34:38 <EvanR> note if the parens were nested the other direction it would be efficient
17:34:46 <EvanR> but its not because youre using it as a queue
17:34:51 <kadoban> sveit: Purely Functional Data Structures has a few useful queues, by the way. And has one of the few descriptions of how to work through figuring out the costs of haskell expressions that ever made any sense to me
17:34:58 <EvanR> appending stuff incrementally
17:35:26 <EvanR> @src (++)
17:35:27 <lambdabot> []     ++ ys = ys
17:35:27 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:35:27 <lambdabot> -- OR
17:35:27 <lambdabot> xs ++ ys = foldr (:) ys xs
17:35:37 <EvanR> the top one should help
17:36:37 <Axman6> yeah Okasaki's O(1) append queue is pretty cool, spreading out the cost of doing a reverse over every append (been a while since I looked at it though and can't remember exactly how it works).
17:36:51 <sveit> EvanR: that's exactly why i'm confused. that suggests if i append then take head that's O(1), right?
17:37:27 <geekosaur> no, becuase it doesn;t do any of that strictly
17:37:40 <Axman6> I implemented it for use as a Queue behind the Par monad which allows interchangable schedulers, but it performed way worse than the one which was already there which just used lists IIRC
17:37:41 <geekosaur> every time you append an item you add a (_ : _) onto the had
17:37:49 <Cale> sveit: It's O(1), yes, for each time you use (++)
17:37:53 <geekosaur> every time you pop an item you have to traverse all of those
17:38:02 <geekosaur> for eveyrthing pushed since the last time you did a pop
17:38:18 <geekosaur> iirc
17:38:26 <Cale> sveit: So if you use (++) m times by building up a list in the wrong direction one element at a time, it will be O(m) to get the head of the list
17:38:45 <sveit> btw just for discussion's sake i'm familiar with the amortized queue, where you accumulate elements in reverse and then reverse your accumulating list when you run out of elements, i'm trying to understand this "dumber" queue in the presence of laziness
17:39:26 <Axman6> yeah it's O(n) where n is the number of (++) calls made before the inspection of the head of the list
17:39:29 <EvanR> before you can get even one thing out of (([a] ++ [b]) ++ [c]) ++ [d] you will have to do all the ++'s
17:39:42 <EvanR> because the first thing to evaluate is the last ++
17:39:46 <EvanR> its at the top of the expr
17:39:52 <Cale> Well, you have to do O(1) work for each of the (++)'s
17:40:09 <Cale> you don't have to do the entire O(n^2) amount of work
17:40:11 <EvanR> yes you have to do one step of the ++ algorithm to get the head of each result
17:40:24 <Cale> but, if you eventually work your way through the queue, you will end up doing quadratic work
17:40:28 <EvanR> but you cant zip right to the very first (deepest) element a
17:40:32 <Axman6> and then the next head does O(m) work too
17:40:40 <abel-abel> Hello, I think the function name `fromChunks` in Data.ByteString.Lazy module is not that proper. It takes a list a ByteString and return a lazy bytestring which is manipulated by chunks. maybe it should be called toChunks?
17:41:10 <Axman6> abel-abel: why? it takes a list of chunks which form the lazy bytestring
17:41:15 <Cale> abel-abel: It takes a list of strict chunks and builds a lazy ByteString having those as its chunks
17:41:18 <Axman6> a lazy bytestring is made up of chunks
17:42:29 <Axman6> remember that a lazy bytestring is just a specialised list of strict byte strings, it's essentiially: data ByteString = Chunk Strict.ByteString ByteString | End
17:42:39 <sveit> ah, i think i am starting to understand, thanks very much! so if I only have O(1) appends of O(n) size lists then i still do O(n) work to process the whole thing, right?
17:43:09 <sveit> i know that's not my queue case, just checking that i understand
17:43:13 <EvanR> to process the whole thing its n^2
17:43:40 <EvanR> and you only have addressed time so far
17:43:56 <monochrom> Right, Ω(n) for just one item. Now multiply by another n for the whole list.
17:43:59 <Axman6> sveit: it's worth going through the exercise of evaluating an expression like ([a] ++ [b]) ++ [c]) ++ [d] by hand, one step at a time, and counting how mant times you have to perform a : ...
17:44:02 <EvanR> each time you append then pop, you will have to copy the whole list again
17:44:15 <EvanR> its really rather terrible
17:44:29 <monochrom> Much duplicate work.
17:44:42 <sveit> wait. (xs ++ xs) takes O(n^2) to traverse? if so i'm confused again
17:45:09 <EvanR> ((((([a] ++ [b]) ++ [c]) ++ ... es
17:45:10 <Cale> no
17:45:11 <EvanR> yes
17:45:38 <Cale> (xs ++ ys) takes O(length xs) more work than evaluating xs and ys on their own
17:46:10 <EvanR> where evaluate means force the spine here
17:46:13 <abel-abel> Axman6, Cale yep, I'm just curious about that. Yes, I can think of the function in your way. Thank you!
17:46:19 <Cale> but if you keep appending to the end, you incur 1 + 2 + 3 + 4 + ... + n = (n^2 + n) / 2 additional steps
17:46:29 <Cale> which is O(n^2)
17:47:15 <Cale> (appending one element at a time to the end of an initially empty list, until you've built up a list of length n)
17:48:29 <sveit> that i understand now. i was just checking that (xs ++ xs) still takes O(length xs) to compute. or xs ++ xs ++ xs, or any O(1) number of appends (for long xs), right? thanks for all the detailed responses btw!
17:48:38 <monochrom> Yes.
17:48:59 <Cale> Yeah
17:49:14 <Cale> xs ++ xs ++ xs will take 3 * length xs additional steps
17:49:54 <Cale> er, sorry, (xs ++ xs) ++ xs will
17:50:00 <Axman6> sveit: it's important to get the associativity correct though, ([a] ++ [b]) ++ [c] is quite different to [a] ++ ([b] ++ [c])
17:50:18 <Cale> (++) is defined to associate to the right, so it would only be 2 * length xs steps written that way
17:50:52 <Cale> and ((xs ++ xs) ++ xs) ++ xs will take about (1 + 2 + 3) * length xs extra steps
17:52:36 <Cale> But if you associate it the other way, it will behave better
17:52:58 <Cale> xs ++ (xs ++ (xs ++ xs)) will only take about 3 * length xs steps
17:53:29 <Cale> (I'm ignoring the steps at the end for matching the empty list)
17:54:03 <Cale> i.e. it's really length xs + 1, because [] ++ xs still takes a step to reduce
17:57:07 <sveit> thanks a lot! is Okasaki's book the canonical reference on reasoning about performance in Haskell, or are there other resources popele use?
18:00:08 <kadoban> If there are other good references, I'd definitely be interested in them, heh.
18:02:12 <Axman6> there are many aspects of performance which aren't covered in okasaki's book (it's relatively old and IIRC doesn't focus on any of the modern means of improving performance, avoiding laziness when it's not useful etc)
18:04:25 <kadoban> Sure. The part that I haven't seen well done elsewhere is just the basic computational model of evaluation in a non-strict setting
18:09:27 <monochrom> Try my http://www.vex.net/~trebla/haskell/lazy.xhtml
18:10:59 <Axman6> I was searching for an interactive evaluator for haskell expressions but couldn't find one :(
18:11:43 <monochrom> There used to be one but all good things come to an end.
18:14:12 <monochrom> Hrm, it lives again. http://bm380.user.srcf.net/cgi-bin/stepeval.cgi
18:40:47 <Axman6> "step _: Not implemented: List [Lit (Int 4)]" o.O
18:42:01 <Squarism> Anyone know how to get Network.Mail.SMTP work with SSL/TLS?
18:42:13 <Squarism> or should one use another package for that?
18:44:03 <Axman6> hmm, I thought I used something else to send email last time I needed to... thought it was written by Bos
18:45:20 <Squarism> Axman6, oh ok
18:47:03 <Squarism> Axman6, HaskellNet? 
18:48:31 <bsima> how do I crash a Haskell program? I'm loading a config file, and if it fails to parse, I want the program to crash
18:48:56 <bsima> like `throw` or something similar
18:49:06 <geekosaur> > error "oops"
18:49:09 <lambdabot>  *Exception: oops
18:49:14 <Axman6> Squarism: I think I used https://hackage.haskell.org/package/mime-mail-0.4.13.1/docs/Network-Mail-Mime.html which uses sendmail
18:50:40 <Squarism> ah ok
18:55:18 <bsima> geekosaur: thx
18:55:56 <Axman6> it is generally a good idea to not crash like that if possible though, just exit if the config is incorrect
18:56:33 <bsima> right, I'm thinking thru how is best to do that with my code
18:56:47 <bsima> just wanted to get it working before I refactor tho :)
18:56:56 <geekosaur> often prefered is something like Either String MyConfig
18:57:13 <Axman6> return a Maybe or Either, then pattern match on that and if it's Nothing or Left, print an error and exit with a non-zero status code
18:57:16 <geekosaur> then it's Left "description of error" or Right theConfig
19:00:18 <bsima> ah yes, this is it http://hackage.haskell.org/package/base-4.9.1.0/docs/System-Exit.html#v:exitFailure
19:00:24 <bsima> the module I need
19:00:57 <ExpHP> Is it possible to import qualified "at a distance"?  Like, through a reexport?
19:01:19 <ExpHP> like, erm, hang on
19:01:45 <lpaste> ExpHP pasted “importing qualified "at a distance", he said” at http://lpaste.net/354698
19:02:58 <ChaiTRex> ExpHP: I don't think that works, since it would mess things up when the qualified names collide.
19:03:20 <ExpHP> ChaiTRex collide with what?
19:03:40 <ChaiTRex> ExpHP: With other "at a distance" qualified names and local qualified names.
19:03:55 <ChaiTRex> ExpHP: It would be something of a mess.
19:04:12 <ExpHP> that's why I'm doing it in a prelude. you can only have one!
19:04:32 <ChaiTRex> ExpHP: The point of qualified names is to avoid name collisions.
19:04:39 <ExpHP> but okay yeah if people were doing it all over the place it could be bad >_>
19:05:47 <ExpHP> maybe the folks at ClassyPrelude ARE onto something
19:06:07 <bsima> what's the difference between importing "qualified" and using "as"
19:07:11 <ChaiTRex> bsima: With as, you can use the names unqualified or qualified (https://wiki.haskell.org/Import)
19:07:31 <bsima> I usually do `import Mod as Mod`
19:07:32 <geekosaur> 'qualified' means the name is only available qualified
19:07:49 <geekosaur> 'as' lets you specify what qualification to use, defaulting to the module name
19:08:14 <geekosaur> so 'import Foo (gunk) as Bar' lets you use gunk or Bar.gunk
19:08:16 <ExpHP> bsima: the way you are doing it, all the names are also being imported without the module name prefix
19:08:26 <geekosaur> sorry orderring there
19:08:35 <bsima> ohhhh
19:08:36 <geekosaur> import Foo as Bar (gunk)
19:08:48 <geekosaur> but import qualified Foo as Bar (gunk) only permits Bar.gunk
19:08:54 <bsima> okay I much prefer qualified, gotta go add that to my codebase
19:09:07 <sleblanc> bsima, as an example, type "import Data.Map" in your ghci interpreter and see what "lookup" now means
19:09:37 <ExpHP> (good thing nobody needs lookup)
19:09:44 <sleblanc> unless you import it qualified, GHCi will tell you the name "lookup" is ambiguous
19:10:04 <ExpHP> (...I mean, the one in prelude)
19:10:42 <bsima> yeah I get it now, thanks folks
19:12:59 <ExpHP> Hm, I was really hoping making a custom prelude would help cut down on my import lists, but it looks like I really can only cut down a small portion.  There's too many things I need qualified...
19:13:35 <ExpHP> haskell's modules break my heart once again </3
19:14:21 <rotaerk> I often, unless feeling lazy, prefer to explicitly import every symbol I use
19:14:27 <sleblanc> ExpHP, would having something like "import MyPrelude.Map as Map" work?
19:14:35 <rotaerk> unless it's an extremely common thing
19:14:54 <rotaerk> import as, or explicitly list the things I'm importing from a given module
19:15:07 <rotaerk> simply so that it's clear, when reading the code, where a given symbol came from
19:15:20 <ExpHP> sleblanc: Nope, I'm trying to cut down imports of Map, Set, ByteString, Text, and blah-de-blah all in one import
19:16:34 <ExpHP> a prelude is able to import the data type names, but if I ever want to *use* one of them I gotta import something for the functions
19:17:04 <Cale> ExpHP: Yeah, for quite a long time, I've thought it would be nice if modules could re-export things qualified in particular ways.
19:18:12 <ExpHP> rotaerk: I understand the benefits, but it seems like so much work and tedium.  I suspect every other line I write needs a new function from somewhere
19:18:25 <sleblanc> Are all types instances of the Eq class? Are there common types that do not have an instance for Eq?
19:18:45 <ExpHP> sleblanc: IO
19:18:49 <sleblanc> oh, sure
19:18:49 <sleblanc> duh
19:19:08 <Cale> Function types
19:19:35 <ExpHP> newtypes where somebody forgot to derive Eq
19:19:43 <Cale> heh
19:23:33 <bsima> Does anyone use Flow? https://hackage.haskell.org/package/flow
19:24:04 <Cale> no
19:24:43 <Cale> "Flow provides operators for writing more understandable Haskell." -- lies
19:24:47 <bsima> hm, I really like it
19:24:54 <ExpHP> 17 downloads in the last 30 days
19:25:12 <bsima> I had been defining my own operators like |> and <| for a while before I learned about Flow
19:26:14 <jmcarthur> I never understood this need some people have for function application to be flipped.
19:26:15 <ExpHP> I like how it accuses base of providing two function application operators, and then proceeds to define six
19:26:27 <Cale> jmcarthur: Yeah, it's terrible ;__;
19:26:44 <jmcarthur> Same for composition.
19:29:08 <thimoteus> "Read as 'compose backward'" pffft
19:29:35 <lyxia> (\v -> ...v ...) (some big argument) or let v = some big argument in ....v...   in both cases v is separated from either its definition or it's usage
19:29:38 <jmcarthur> I don't understand it even with lenses.   this & backward . style   just doesn't feel right to me compared to   (this . forward) style
19:29:54 <bsima> I like to think of the Flow operators as being onomatopoeic
19:30:15 <bsima> they kinda point in the direction that the data flow in the function composition
19:30:30 <lyxia> so flipping application doesn't have that inconvenient
19:30:35 <ExpHP> jmcarthur: I believe it can be summed up in one word: (Parenthephobia)
19:30:53 * ExpHP goes to make sure that isn't actually a word
19:31:01 <bsima> well I do clojure for my day job..
19:31:03 <jmcarthur> ExpHP: We even have ($) for that! (But I don't much care for ($), either.)
19:31:34 <lyxia> you still need brackets with $ applied to a lambda
19:31:39 <jmcarthur> The way I see it, if I can't express it with (.), I might as well just use parens.
19:32:38 <jmcarthur> Heh, I don't care much for lambdas either, but I definitely use them more often than I use ($).
19:33:07 <Cale> I never rely on the manner in which $ has been defined to be right-associative
19:33:13 <peddie> bsima: (.) is the same as in mathematics, f . g . h, which even schoolchildren learn :)
19:33:15 <jmcarthur> It's not clear to me why I would use ($) to immediately apply a lambda.
19:33:16 <Cale> Apart from that, I don't mind using it.
19:33:21 <monochrom> Use both ($) and (&) in mixed style to elucidate data flow.
19:33:39 <Cale> jmcarthur: You would use $ to immediately apply some other function to a lambda which spans multiple lines
19:34:16 <ski> .. in some ways, it would make more sense for function type arrow, and function abstraction, to be flipped
19:34:19 <jmcarthur> Cale: Right, but that some other function wouldn't be a lambda, which I think is what lyxia was talking about.
19:34:52 <jmcarthur> I would just make a let/where binding in that case.
19:35:00 <monochrom> "sin x < 5 where x is a parameter"  <--- lambda flipped
19:35:03 <lyxia> yeah my point here isn't very good
19:35:13 <jmcarthur> ski: Bird style is kind of nice, indeed.
19:35:33 <monochrom> Well, I guess it is more seriously (sin x < 5 <- x/)
19:35:34 <Cale> sin x < 5 <- x/
19:35:35 <Cale> lol
19:35:37 <lyxia> but I think there is value in having the variable being just between its definition and its use site
19:35:40 * ski often writes in that way, in paper notes
19:35:56 <ski> monochrom,Cale : .. btdt :)
19:36:00 <jmcarthur> I'd probably pass on reverse lambda, but reverse function type arrow is nice anyway.
19:36:10 <jmcarthur> Not sure I'd be able to get over the lambda.
19:36:24 <jmcarthur> Maybe I'd just remove lambdas, but then everybody would hate me.
19:36:48 <monochrom> \o-> sin o < 5 <-o/  (Two persons waving at you, both pointing at an expression between them)
19:37:07 <Cale> lol, surroundfix lambda, as a compromise
19:37:20 <jmcarthur> Wow.
19:37:34 <iqubic> Why are we writinting  lambdas backwards?
19:37:37 <ski> (or sometimes ⌜λ ⋯x⋯ ↤ x⌝)
19:38:14 <ski> monochrom : that's almost how you write an infix abstraction :)
19:38:17 <iqubic> Also, what's a surroundfix lambda?
19:38:25 <Cale> What monochrom did
19:38:38 <iqubic> Is that even valid in Haskell?
19:38:40 <ski> (.. obviously the type of `++' is `[a] -> [a] <- [a]')
19:38:41 <Cale> no
19:38:53 <monochrom> Haha I like that
19:38:54 <iqubic> Why are we talking about it then?
19:38:56 <jmcarthur> With surroundfix you could loosen the nesting rules so that you can terminate the scopes of variables out of order, like in adbmal.
19:39:04 <jmcarthur> Oh not out of order
19:39:06 <jmcarthur> That would be weird.
19:39:10 <iqubic> What's the point of surround fix?
19:39:21 <Cale> iqubic: It's hideous, and funny
19:39:35 <monochrom> What's the point of this line of interrogations?
19:39:46 <iqubic> Clearly the type of Max it (Num a) => a -> a <- a
19:40:11 <monochrom> But anyway adding types to the formal parameters is going to be an issue.  \o::Double -> sin o < 5 <- Double::o/ ?
19:40:14 <Cale> Or is it  a -> a <- a <= (Num a)
19:40:16 <Cale> ?
19:40:25 <iqubic> Cale, I'm not too sure.
19:40:28 <monochrom> "In Soviet Russia, Double types you"?
19:40:32 <iqubic> LOL
19:40:44 <ski> yes, a major problem is that the colon is horizontally symmetric
19:40:55 <iqubic> In Soviet Russia Functions call you.
19:42:06 <iqubic> I want someone to write a Language Extension for surround fix, and get it passed and made official.
19:42:24 <sellout-> Is there a derivative parsing library with the improvements from the 2016 paper?
19:42:28 <sleblanc> April's Fools 2018 ?
19:42:36 <iqubic> sleblanc: Sure.
19:42:36 <ski> (`[a] -> [a] <- [a]' can be conceived of either as `[a] -> ([a] <- [a])' or as `([a] -> [a]) <- [a]', being associated with the two kinds of operator section)
19:43:06 <iqubic> ski, in that case it doesn't really matter, does it?
19:43:07 <monochrom> My thesis supervisor suggested this notation ⟨x| sin x < 5 |x⟩. The idea being the redundancy on the right reminds you whose the bound variable in case the expression is so long you forgot.
19:43:13 <ski> iqubic : exactly
19:43:23 <monochrom> And also symmetry I guess.
19:43:29 <jmcarthur> Cale: The nice thing about (f :: a <- b <- c) (c :: c) (b :: b) :: a is that the last type in the function type syntax is the type of the first argument, so they appear right next to each other.
19:43:47 <monochrom> I guess s/whose/who's/
19:44:10 * monochrom doesn't mix up you're-your but mixes up who's-whose
19:44:17 <sleblanc> monochrom, what's next? Having to type a function twice to make sure you understood the implementation?
19:44:19 <ski> jmcarthur : yes, and in `(..x.. <-| x/) v' the formal and the actual parameter occur next to each other
19:44:37 <iqubic> Why are we discussing this stuff if it doesn't exist in Haskell proper?
19:44:51 <monochrom> Yes sleblanc, preferably the second time is a mirror image of the first time.
19:44:52 <jmcarthur> ski: Yeah, that does seem nice. I'm less familiar with it, is all.
19:45:00 <monochrom> I'm just kidding!
19:45:10 <sleblanc> monochrom, what if you can come up with a palindromic function?
19:45:16 <monochrom> Neato
19:45:47 <iqubic> I want to see someone write a palindromic function in Haskell.
19:46:16 <sleblanc> x = x
19:46:18 <sleblanc> done
19:46:29 <Cale> jmcarthur: right
19:46:50 <iqubic> sleblanc: what is the type of that function?
19:46:58 <sleblanc> :t x = x
19:46:59 <lambdabot> error:
19:47:00 <lambdabot>     parse error on input ‘=’
19:47:00 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
19:47:03 <sleblanc> let x = x
19:47:04 <sleblanc> :t x
19:47:05 <lambdabot> Expr
19:47:16 <sleblanc> @let x = x
19:47:17 <lambdabot>  .L.hs:188:5: error:
19:47:17 <lambdabot>      Ambiguous occurrence ‘x’
19:47:17 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
19:47:43 <glguy> Instead of generating lambdabot error messages you could write: "a -> b"
19:48:18 <sleblanc> :<
19:48:26 <sleblanc> my ghci says: x :: t
19:48:36 <glguy> Well, you said it was a function, so you probably meant a -> b!
19:49:08 <geekosaur> :t let x = x in x
19:49:09 <lambdabot> t
19:49:51 <glguy> See, ask lambdabot and get the wrong answer
19:50:24 <bsima> what idiot called it functional programming and not "logic hacking"?
19:50:31 <jmcarthur> > x
19:50:33 <lambdabot>  x
19:50:41 <jmcarthur> sleblanc: ^^ there's your problem!
19:51:24 <jmcarthur> > map f [a, b, c]   -- sleblanc: it's for stuff like this
19:51:26 <lambdabot>  error:
19:51:26 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M655573486729...
19:51:26 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
19:51:29 <jmcarthur> bah
19:51:43 <ski> > map f [a,b,c] :: [Expr]
19:51:45 <lambdabot>  [f a,f b,f c]
19:51:57 <jmcarthur> ^^ sleblanc: like that, I mean
19:52:29 <sleblanc> wow, cool feat
19:53:15 <sleblanc> > snd (a,b) :: [Expr]
19:53:17 <lambdabot>  error:
19:53:18 <lambdabot>      • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
19:53:18 <lambdabot>      • In the expression: snd (a, b) :: [Expr]
19:53:23 <sleblanc> > snd (a,b) :: Expr
19:53:26 <lambdabot>  b
19:53:41 <ski> no type ascription needed there
19:54:00 <monochrom> "logic hacking" would be Prolog and friends. But I'm OK with "equational hacking".
19:54:59 <jmcarthur> sleblanc: https://hackage.haskell.org/package/simple-reflect if you want to play with it in ghci
19:55:09 <centril> monochrom: agda ?
19:55:33 * ski . o O ( Twelf )
19:55:33 <centril> agda == constructive propositional logic in type system
19:55:54 <ski> more like s/propositional/predicate/
19:56:05 <monochrom> That is distinguished enough to warrant a more specific name, Curry-Howard hacking.
19:56:18 <centril> ski: right - but not classical predicate logic
19:56:24 <centril> because no LEM
19:56:36 <ski> you did say "constructive"
19:56:45 <centril> ski: I did =)
19:56:56 <centril> monochrom: I approve (TM) of your rewording
19:57:12 <monochrom> \∩/
19:57:30 <ski> ™
19:57:52 <centril> monochrom: i have no idea what \n/ means
19:58:12 <centril> not even google seems to know =)
19:58:23 <monochrom> Extending two arms high in celebration. And ∩ is a robotic head.
19:58:26 <ski> the intersection of division-from-the-left and division-from-the-right
19:58:34 <monochrom> Humans would write \o/
19:59:02 <centril> monochrom: oh - I usually take  \x/  where x is something to be: "whatever"
19:59:42 <monochrom> Ah then you will like my new-fangled bidirectional  \o::Double -> sin o < 5 <- Double::o/  lambda notation.
20:00:00 <MarcelineVQ> \o̦̹̩̺͕̹̞͎̅ͬͧ̇ͤ̽̈́/
20:00:01 <monochrom> (If it confuses you, "whatever" is a good response :)
20:00:25 <centril> monochrom: COOL!
20:01:38 <centril> do you guys have any sources / talks on how to teach FP/Haskell to kids? like < 16 years old, or even < 12 years old
20:02:21 <centril> when do they start with functions and equations in school, hmm... like when you're 14 years old ?
20:03:22 <sleblanc> centril, some will have played with algorithms at a very young age. think basic and logo/turtle
20:03:56 <centril> sleblanc: was thinking of logo/turtle (did that in an advanced fp course...) , but it's not very FP
20:04:01 <monochrom> Equation is earlier, but if you also need function then yeah 14 sounds right +/-1.
20:04:18 <centril> monochrom: what country?
20:04:27 <jle`> :t (\o/)
20:04:28 <lambdabot> error: parse error on input ‘/’
20:05:02 <monochrom> I have Hong Kong in mind.
20:05:26 <benzrf> :t 3 \o/ 4
20:05:27 <mniip> 1492484361 [05:59:21] <monochrom> Ah then you will like my new-fangled bidirectional  \o::Double -> sin o < 5 <- Double::o/  lambda notation.
20:05:28 <lambdabot> error: parse error on input ‘\’
20:05:32 <mniip> you're just reinventing APL
20:05:34 <benzrf> hm
20:05:37 <benzrf> mniip: lol
20:06:29 <monochrom> Although! When I was 10 or before, I took my father's calculator and pressed the sqrt button. That would be my initiation to functions.
20:07:00 <monochrom> Plus! I kept pressing it until the iterates converged to 1.
20:07:47 <monochrom> This shows that I was meant for functional programming with fixed points.
20:07:59 <ib1s> Can someone decrypt this code?   -> 05f8e434e2952475a9b2d74bf31ec4e6e28f293fd6c0f8908ed3ddd43d56f85670b26bbdfc7ebb4895081d3ed6ea9b6a155a052c74643022c844c773dbfee473
20:08:11 <MarcelineVQ> it's 20
20:08:14 <centril> monochrom: well, you didn't define your own functions, so it doesnt count :P
20:08:47 <monochrom> Ah, I think at 14 I wrote my first program for the Casio FX-3600P calculator.
20:09:14 <monochrom> But it's a toy program. The calculator allowed a program of 38 instructions only.
20:10:00 <monochrom> Also, very restrictive conditional-looping facility. (Basically, if R0>0 then goto beginning. Something like that.)
20:10:34 <monochrom> But! I did prove it correct before entering it.
20:11:18 <monochrom> (But only because I didn't own such a calculator. I had to wait until going to school so I could try my classmates's. So at home I wrote and proved it correct on paper first.)
20:11:47 <Cale> ib1s: Does that question have anything to do with Haskell?
20:12:42 <ib1s> Cale what bro?
20:12:49 <Cale> You're in #haskell
20:13:13 <Cale> This is a channel about the programming language Haskell.
20:13:31 <ib1s> Cale sorry bro
20:13:50 <ib1s> Do you know any channel where I can solve this question?
20:14:00 <Cale> It's fine, I was just wondering, given that it came out of the blue :)
20:14:00 <centril> monochrom: so this is the best I found: http://pedagog.stockholm.se/Pedagog/1%20Nya%20sajten/I%20undervisningen/LGR11/3.5%20MATEMATIK.pdf
20:14:05 <centril> https://www.skolverket.se/laroplaner-amnen-och-kurser/grundskoleutbildning/grundskola/matematik/subject.htm?webtos=GR&tos=GR&subjectCode=GRGRMAT01#anchor3
20:14:12 <centril> (Swedish)
20:14:13 <glguy> Sorry, this isn't a directory, it's for discussing Haskell
20:15:29 <centril> monochrom: "Meaning of the variable concept and it's usage in algebraic expressions, formulae and equations" <-- year 7-9 - which is like when you are 15  (year 8)
20:16:10 <monochrom> Some bad omen with "problemlösning" so close to "problem losing" :)
20:16:32 <centril> monochrom: translation: "problem solving" ;)
20:18:03 <ski> monochrom : Casio PB-100F here, around age seven .. 544 bytes available for programs, iirc
20:18:32 <monochrom> It used BASIC, didn't it? I think I saw one.
20:18:34 <centril> ski: btw, is your nickname for SKI combinators or for sking ?
20:18:41 <Cale> ib1s: There's 54 distinct bytes in that 64 bytes, so it's unlikely to be a substitution cipher. My guess is that nobody's likely to be successful without more context.
20:19:02 <ski> a version of BASIC, yes. no nested conditionals
20:19:13 <Cale> > length . map head . group . sort . map (fst . head . readHex . take 2) . takeWhile (not . null) . iterate (drop 2) $ "05f8e434e2952475a9b2d74bf31ec4e6e28f293fd6c0f8908ed3ddd43d56f85670b26bbdfc7ebb4895081d3ed6ea9b6a155a052c74643022c844c773dbfee473"
20:19:16 <lambdabot>  54
20:19:32 * geekosaur remembers a Sharp BASIC-programmable calculator. Radio Shack used to sell a branded version (you could feel the Sharp logo under the R/S logo)
20:19:51 <monochrom> That would be Sharp PC-1500. I had one too.
20:19:54 <Cale> Apparently this is #haskell-and-ciphers-and-old-programmable-calculators
20:19:57 <Cale> lol
20:20:30 <centril> Cale: no... it was a question about teaching FP to schoolchildren which went offtopic about calculators ;)
20:20:40 <monochrom> Plus its plotter. That's right, four-colour ink pens bloody vector graphics plotter
20:21:00 <monochrom> (Only 3-inch wide paper roll or something. Not big.)
20:21:01 <ski> Cale : says "Illegal channel name", when i try to join ..
20:21:36 * ski remembers printer plotters
20:23:00 <monochrom> had a lot of fun plotting the sine wave 3 times in the name of "biorhythm". and polar coordinate graphs.
20:23:34 <monochrom> Yes, wouldn't it be nice to run Haskell on it...
20:24:00 <centril> monochrom: maybe idris ?
20:24:23 <centril> (could actually potentially work since runtime is way smaller...)
20:24:34 <monochrom> No, would not be nice. But I know what's nice.
20:25:09 <monochrom> On a modern Haskell-capable computer, run a cross-compiler that compiles Haskell to PC-1500 machine code.
20:25:28 <monochrom> Now here is the hilarious part. You wouldn't believe it.
20:26:16 <monochrom> Modulate that binary file to an audio WAV file such that the audio sound is right for the cassette interface for PC-1500.
20:26:37 <monochrom> Play that audio to that cassette interface. Tell PC-1500 to load it.
20:33:31 * ski . o O ( <http://wav-prg.sourceforge.net/index.html> )
20:35:42 * geekosaur suddenly wishes he still had the SuperBoard II around to play with that >.>
20:37:50 <lordcirth> https://www.youtube.com/watch?v=uNjxe8ShM-8
20:38:04 <lordcirth> Turing-complete Powerpoint^
20:38:29 <monochrom> oh haha. But isn't it just because Visual BASIC?
20:39:20 <pacak> monochrom: Nope. It uses powerpoint animations only.
20:39:34 <monochrom> Yikes. That's neat.
20:40:00 <iqubic> What is this madness?
20:40:30 <monochrom> A system and method for running Haskell programs in Powerpoint.
20:41:15 <iqubic> HOW DOES THAT WORK??
20:44:29 <iqubic> On a related note, can I write a Lisp parser in Haskell?
20:45:03 <iqubic> How hard would that be actually?
20:45:50 <Maxdamantus> I imagine there are multiple tutorials that involve writing a Lisp implementation in Haskell, including a parser.
20:46:13 <iqubic> What I want is an interactive Lisp Parser.
20:46:46 <iqubic> So something like: main = forever $ interact parseLisp
20:46:52 <iqubic> :t forever
20:46:53 <lambdabot> Applicative f => f a -> f b
20:47:29 <iqubic> Why does forever have a type constraint of applicative? and does my skeleton of a program work?
20:47:50 <iqubic> :t interact
20:47:51 <lambdabot> (String -> String) -> IO ()
20:47:58 <jle`> iqubic: forever act = act *> forever act
20:48:04 <iqubic> :t act
20:48:06 <lambdabot> error:
20:48:06 <lambdabot>     • Variable not in scope: act
20:48:06 <lambdabot>     • Perhaps you meant one of these:
20:48:11 <jle`> that's a variable binding
20:48:14 <iqubic> Ah I see.
20:48:17 <jle`> forever x = x *> forever x
20:48:32 <gigamonkey> I just wrote this function which I feel like must be a standard thing somewhere but Hoogle on the type isn't helping me:
20:48:34 <gigamonkey> finish fn x = if x' == x then x' else finish fn x' where x' = fn x
20:48:41 <iqubic> > interact $ print "hello\n"
20:48:44 <lambdabot>  error:
20:48:44 <lambdabot>      • Couldn't match expected type ‘String -> String’
20:48:44 <lambdabot>                    with actual type ‘IO ()’
20:49:07 <iqubic> > forever $ interact print "hello\n"
20:49:09 <lambdabot>  error:
20:49:10 <lambdabot>      • Couldn't match expected type ‘[Char] -> f a0’
20:49:10 <lambdabot>                    with actual type ‘IO ()’
20:49:21 <glguy> You can play with lambdabot in /msg
20:49:57 <iqubic> How do I message lambdabot?
20:50:15 <iqubic> I can't seem to get that to work well at all.
20:50:50 <glguy> iqubic: Type: /query lambdabot
20:51:58 <centril> https://www.reddit.com/r/haskell/comments/j8ac0/haskell_for_kids_introduction_to_my_upcoming_class/
20:52:06 <iqubic> Wy doesn't lambdabot like this:
20:52:17 <iqubic> > forever $ interact id
20:52:19 <lambdabot>  error:
20:52:19 <lambdabot>      • No instance for (Typeable b0)
20:52:19 <lambdabot>          arising from a use of ‘show_M331268573624747036026026’
20:52:35 <centril> haskell is the first programming course taught to Computer Engineering students at Chalmers University of Technology
20:53:03 <centril> mostly because no-one has used it before, so everyone starts at an equal footing
20:53:09 <glguy> iqubic: because it doesn't know what type your expression has
20:53:14 <iqubic> Why not?
20:53:26 <glguy> because it's ambiguous, there are multiple types it could have
20:53:34 <iqubic> What types could that have??
20:53:47 <glguy> :t forever $ interact id
20:53:49 <lambdabot> IO b
20:54:07 <pavonia> :t interact
20:54:08 <lambdabot> (String -> String) -> IO ()
20:54:14 <iqubic> Why is it IO b?
20:54:18 <iqubic> :t forever
20:54:19 <lambdabot> Applicative f => f a -> f b
20:54:38 <jle`> it's IO anything
20:54:40 <jle`> the result can be of any type
20:54:52 <jle`> IO Int, IO Bool, IO Void, etc.
20:54:55 <iqubic> No it can't. It has to be IO ()
20:55:02 <jle`> how come
20:55:16 <jle`> look at the type of forever...the result 'f b' isn't related to the input 'f a'
20:55:24 <jle`> forever :: IO () -> IO Void is valid
20:55:25 <iqubic> :t forever
20:55:27 <lambdabot> Applicative f => f a -> f b
20:55:33 <iqubic> Oh, I see.
20:55:34 <jle`> it's not f a -> f a
20:55:48 <iqubic> So how do I fix my little interact forever program?
20:55:59 <glguy> iqubic: interact already goes forever
20:56:02 <jle`> help GHC figure out what type you want
20:56:05 <glguy> You don't need to forever it
20:56:27 <iqubic> Wait, interact already goes forever?
20:56:31 <iqubic> > interact id
20:56:33 <lambdabot>  <IO ()>
20:56:47 <jle`> interact f = forever (putStrLn . f =<< getLine)
20:56:47 <iqubic> What is lambdabot doing there?
20:56:53 <glguy> It's printing the type for you
20:57:05 <glguy> It's certainly not going to run 'interact id' for you
20:57:06 <jle`> iqubic: <IO ()> is ther esult of "show"-ing 'interact id'
20:57:12 <jle`> since remember what > does
20:57:19 <jle`> it takes an expression and evaluates it and prints out the result
20:57:25 <jle`> it shows the result of an evaluation
20:57:34 <ski> @help run
20:57:34 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
20:57:35 <iqubic> Oh. It doesn't actually run the command?
20:57:38 <jle`> and 'interact id' evaluates to an IO (), and 'showing' it in lambdabot gives you "<IO ()>"
20:57:46 <jle`> iqubic: it has never run any commands
20:57:48 <jle`> it only evaluates things
20:57:52 <jle`> just like every other time you've used it :)
20:57:52 <iqubic> Right.
20:58:07 <iqubic> Looks like it has no IO either.
20:58:19 <jle`> and interact id evaluates to something that lambdabot 'shows' as the string "<IO ()>"
20:58:27 <iqubic> I see.
20:58:30 <jle`> > show (interact id)
20:58:32 <lambdabot>  "<IO ()>"
20:58:52 <iqubic> I see.
20:59:48 <iqubic> Is there a way to stop a program written with interact?
21:00:14 <iqubic> Other than ^C?
21:02:33 <Cale> Ctrl-D
21:02:42 <Cale> Closing stdin will generally do it
21:03:34 <pacak> iqubic: The same way you close vim - reboot your computer.
21:04:05 <iqubic> Is there a way to modify interact so that an input of "quit" case insensitive will end the program.
21:04:08 <iqubic> ???
21:04:13 <iqubic> pacak: :wq
21:04:35 <pavonia> jle`: Where did you take that definition of interact from? The definition in System.IO is different
21:05:28 <pavonia> @src interact
21:05:28 <lambdabot> interact f = do s <- getContents; putStr (f s)
21:05:40 <Cale> ^^ that's the correct definition
21:06:03 <iqubic> Cale: That's not an infinite list.
21:06:12 <Cale> What's not an infinite list?
21:06:32 <iqubic> What I meant is: interact is not an infinit loop
21:06:33 <Axman6> ?
21:06:37 <Cale> getContents is magic
21:06:48 <Cale> It lazily obtains all of stdin
21:06:52 <Axman6> interact is an infinite loop if you never close stdin
21:07:00 <iqubic> @src getContents
21:07:00 <lambdabot> getContents = hGetContents stdin
21:07:10 <iqubic> That's confusing.
21:07:21 <iqubic> @src hGetContents
21:07:21 <lambdabot> Source not found. You type like i drive.
21:07:48 <Cale> The s that you get from getContents is a magical string such that attempting to evaluate a character from that string will read a character from stdin.
21:08:06 <Cale> At the same time it gives that string to you, it semi-closes stdin, so that nothing else can read from it.
21:08:27 <pavonia> Are "forever getLine" and "getContents" semantically equivalent?
21:08:39 <glguy> Sure, you can quit interact early, just stop producing output
21:08:39 <Cale> no
21:08:54 <glguy> interact (unwords . takeWhile (/= "quit") . words)
21:09:21 <Cale> yes
21:09:25 <Cale> That's the difference
21:09:32 <glguy> forever getLine won't stop getting lines, and it doesn't let you do anything with the lines you've got
21:09:37 <iqubic> glguy: What is that program doing?
21:09:50 <Cale> iqubic: try it
21:11:14 <iqubic> Alright, ghci doesn't like the interact function.
21:11:31 <iqubic> Are atleast it dislikes glguy's function
21:11:33 <c_wraith> interact wants to own stdin and stdout
21:11:46 <c_wraith> which doesn't play nicely with running inside ghci
21:11:50 <iqubic> So I should not try it in ghci?
21:12:30 <c_wraith> yeah, it's not reliable
21:12:40 <Cale> You might also want to check the buffering mode -- it'll behave rather differently with line buffering vs. no buffering
21:13:37 <mjora7> Hey, can I ask what type of projects you guys using Haskell to do?
21:13:45 <iqubic> glguy: Your function is not compiling for me.
21:13:51 <iqubic> ./test.hs: line 1: syntax error near unexpected token `('
21:13:58 <iqubic> ./test.hs: line 1: `main = interact (unwords . takeWhile (/= "quit") . words)'
21:14:11 <Cale> mjora7: The company I work for builds web applications for various clients entirely in Haskell.
21:14:13 <iqubic> I literally only defined main. That's all I did.
21:14:33 <Maxdamantus> iqubic: sounds' like you're running the Haskell as bash.
21:14:37 <Maxdamantus> s/'//
21:14:57 <Cale> mjora7: For our frontends, we use GHCJS to compile for the web, and GHC's ARM support to compile for Android and iOS.
21:15:06 <Maxdamantus> try `ghc --make test.hs && ./test`
21:15:12 <MarcelineVQ> :t interact (unwords . takeWhile (/= "quit") . words)
21:15:13 <lambdabot> IO ()
21:15:32 <iqubic> Maxdamantus: What are you suggestion I do?
21:15:46 <mjora7> Cale: Can you elaborate a bit on what you do and why you guys use Haskell in particular? I'd love to see an example application if that's possible.
21:15:58 <geekosaur> iqubic, you have typed haskell code to a bash prompt, this does not work, bash is not haskell
21:15:58 <iqubic> Linking test is taking a while.
21:16:04 <Cale> mjora7: It's really quite nice to be able to share types and code between the frontend and backend of your web applications, and be able to start some refactoring on the backend, and have type errors filter through to the frontend code, and tell you everything that needs to be changed.
21:16:22 <iqubic> geekosaur: I put the code into a source file. I know that I did.
21:16:24 <Maxdamantus> iqubic: don't run it as bash (that's what will happen if you run `./test.hs` from bash where that file lacks a #!)
21:16:31 <iqubic> Ah.
21:16:52 <iqubic> How do I run haskell programs?
21:17:07 <glguy> o.O
21:17:09 <iqubic> Wait, it gave me a compiled version to run. I feel stupid
21:17:21 <kadoban> For simple things, runhaskell works
21:17:39 <Cale> mjora7: Well, here's a talk by my boss explaining the library we use for frontend development and it explains a fair amount about why we like it https://www.youtube.com/watch?v=dOy7zIk3IUI
21:17:51 <kadoban> For more complicated, yeah either compile them yourself or stack's script interpreter thing or whatever.
21:17:56 <mjora7> Cale: Awesome, thanks for the info!
21:18:06 <iqubic> How the heck does glguy's interact thing work?
21:18:23 <Cale> mjora7: Basically the fact that the code is more maintainable and our productivity can be far higher than in basically anything else.
21:18:44 <athan> Would LinearTypes be useful for higher-order functions, maybe for resource {,de}allocation? Something like `\isRunOnce -> ...`
21:18:51 <Cale> mjora7: There are a lot of things which come together to make that be the case though.
21:21:23 <athan> hmm... could you `case` match _only once_ on `x` in `(x :: a) o- ...`?
21:58:24 <Costar> hi all
21:58:35 <pacak> o/
22:17:20 <frantelle> hey guys - new to haskell and currently trying to do something where I would typically do it in two for loops iterating over the entire list
22:17:39 <frantelle> basically I'm trying to compute how each element in a list effects every other element in the list
22:20:39 <nuskin> so I don't repeat myself, did anything that (frantelle) said before come through?
22:20:40 <EvanR> frantelle: you can iterate through a list of pairs
22:20:53 <EvanR> where you have each pair of elements, or pairs where the elements arent the same
22:21:02 <EvanR> heres how to get one of those
22:21:34 <EvanR> > let things = [1,2,3] in [(x,y) | x <- things, y <- things]
22:21:36 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
22:22:04 <EvanR> > let things = [1,2,3] in [(x,y) | x <- things, y <- things, x /= y]
22:22:06 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
22:23:21 <EvanR> this strategy is efficient because of lazy evaluation
22:24:18 <frantelle> sorry, internet dropped out
22:24:25 * EvanR facepalm
22:24:35 <EvanR> > let things = [1,2,3] in [(x,y) | x <- things, y <- things, x /= y]
22:24:37 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
22:24:40 <EvanR> this strategy is efficient because of lazy evaluation
22:26:50 <frantelle> I see
22:28:34 <frantelle> just thinking about it though, that doesn't really help with what I'm trying to do
22:29:38 <frantelle> basically if I have [1,2,3,4] I want [myFunction(1 [1,2,3,4]), myFunction(2 [1,2,3,4]), ... ]
22:29:45 <frantelle> hence why I've been trying to use map
22:30:08 <jle`> you mean myFunction 1 [1,2,3,4] ?
22:30:25 <frantelle> yes, sorry
22:30:29 <jle`> you can just map (\x -> myFunction x [1,2,3,4]) [1,2,3,4]
22:34:21 <frantelle> jle`: so that's just saying, let x individually take values from [1,2,3,4] and apply it to myFunction with the second argument of [1,2,3,4] ?
22:35:13 <frantelle> and since the type of map is to return a list, it can't not be a list by the end of it 
22:36:56 <pacak> > (*) <$> [1..4] <*> [1..4]
22:36:58 <Guest46> frantelle: i guess what you want is `fmap`
22:36:58 <lambdabot>  [1,2,3,4,2,4,6,8,3,6,9,12,4,8,12,16]
22:37:19 <Guest46> > fmap (+2) [1, 2, 3]
22:37:21 <lambdabot>  [3,4,5]
22:37:49 <pacak> > ((*) <$>) . join (<*>) [1..4]
22:37:51 <lambdabot>  error:
22:37:52 <lambdabot>      • Couldn't match type ‘a1 -> a0’ with ‘[Integer]’
22:37:52 <lambdabot>        Expected type: [Integer] -> a1 -> f a
22:38:02 <pacak> > ((*) <$>) . join (<*>) $ [1..4]
22:38:04 <lambdabot>  error:
22:38:05 <lambdabot>      • Couldn't match type ‘Integer’ with ‘Integer -> a’
22:38:05 <lambdabot>        Expected type: [Integer] -> [Integer] -> [a]
22:38:09 <pacak> Hmmm...
22:38:16 <pacak> Dont do this anyway.
22:41:46 <sssilver> studying Scheme using SICP... quite easy when you have decent knowledge of Haskell ^.^
22:41:57 <sssilver> but constantly feel like "I wish I just moved on to Haskell right now"
22:42:14 <jle`> frantelle: yes that's what it says
22:46:43 <EvanR> sssilver: i learned scheme first using SICP, later on i found it much easier to learn haskell than it seemed like other people coming from e.g. python
22:47:27 <EvanR> it was essentially just a matter of learning how the type system worked
22:47:55 <EvanR> haskell + scheme, power couple
22:49:43 <sssilver> I guess scheme made sense in a world that didn't have Haskell, but now the world does have Haskell
22:49:51 <sssilver> so /shrug
22:50:11 <EvanR> pretty much </biased-as-hell>
22:51:04 <sssilver> rofl
22:51:21 <EvanR> you could also say, ocaml makes sense in a world that didnt have haskell
22:51:25 <EvanR> etc
22:54:26 <EvanR> the etc = but we have haskell
22:56:44 <abel-abel> `catch` function is not in System.IO.Error module?
22:57:03 <EvanR> Control.Exception
22:57:15 <sssilver> EvanR well there are legitimate cases for some languages to exist. You can't render a billion vertices 60 times a second in a lazily evaluated abstract machine.
22:57:29 <EvanR> except you can
22:57:45 * EvanR digs up some ekmett shit
22:57:56 <abel-abel> EvanR, Thanks. It seems `http://learnyouahaskell.com/input-and-output#exceptions` is out of date?
22:58:02 <EvanR> https://github.com/ekmett/quine
22:58:15 <EvanR> abel-abel: i would not be surprised
22:58:55 <abel-abel> why?
22:59:06 <EvanR> learnyouahaskell is ancient
22:59:17 <abel-abel> I'm reading this book these days..
22:59:38 <abel-abel> any better recommendations?
22:59:40 <EvanR> i honestly dont know what the best freely available resource is
22:59:41 <sssilver> EvanR ehh that's a toy project
23:00:12 <EvanR> uhm
23:01:09 <peddie> @where CIS194  -- abel-abel 
23:01:09 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
23:02:02 <EvanR> sssilver: that in no way has anything to do with "you cant render foo bar baz 60 times a second in a lazily evaluated language"
23:02:19 <sssilver> EvanR OK lazily evaluated language with a garbage collector
23:02:25 <EvanR> i saw a video of this but i dont thing its online
23:02:27 <abel-abel> peddie, Thank you! I'll check it out.
23:02:29 <EvanR> at a googlable location
23:02:30 <peddie> @where learnhaskell
23:02:30 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:02:33 <peddie> abel-abel: ^
23:02:40 <EvanR> sssilver: uhm... 
23:02:58 <EvanR> something about quine has gone completely over your head ;)
23:02:59 <peddie> abel-abel: plenty of good free resources to learn haskell :)
23:03:24 <abel-abel> peddie, Thank you so much!
23:03:47 <peddie> abel-abel: good luck; I didn't make any of these, so thank the people that did!
23:24:32 <piyush-kurur> I have not found a satisfactory solution for this problem, I hope some one else though about it. Say I have a package foo
23:24:57 <piyush-kurur> with the type Foo in it and there are some test cases for Foo in the tests directory of foo
23:25:28 <piyush-kurur> Now foo does not expose an Arbitrary instance for Foo (why should it) but uses an Arbirary instacne in the tests
23:26:24 <piyush-kurur> Consider a situation where a package bar dependes on foo and wants to write some test cases for which invovles Foo. Is there any way to sneak in the instance from the test of foo
23:27:09 <peddie> piyush-kurur: it seems to me that you say "why should it [expose an Arbitrary instance]" and then immediately give a reason why it should expose one
23:27:49 <piyush-kurur> peddie: Exposing Arbitrary instace means depending on quick-check
23:28:12 <piyush-kurur> The author of foo might not want it for his non-developer users
23:28:12 <peddie> piyush-kurur: I agree that's a reason _not_ to :)
23:28:48 <peddie> piyush-kurur: you could hide it behind a cabal flag, but maybe someone else has a better idea
23:28:49 <piyush-kurur> for example UTCTime has no arbirary instance. 
23:29:36 <piyush-kurur> There is another thing that is also irritating about separate tests
23:30:09 <piyush-kurur> Say I have a type Foo which is opaque for type safety reasons. However I might want to write an Arbirary instance for it in the test cases
23:31:06 <piyush-kurur> Which means I will have to expose an Internal module with all the constructors exposes and threaten my users to keep them from using it
23:31:30 <EvanR> its called Internal so they know not to use it normally
23:31:35 <glguy> having the Internal module is the way to go
23:31:48 <peddie> piyush-kurur: I don't know a better solution to this latter problem, but `.Internal` seems like a common thing to do which people understand
23:32:01 <glguy> packages that completely hide the constructors aren't worth using
23:32:03 <EvanR> not having it is a good way to piss off people who need to import it for some reason
23:32:45 <peddie> glguy: yeah, like that goddamn unordered-containers ;)
23:32:59 <glguy> (obviously that's an exaggeration, but it's a serious issue)
23:33:10 <glguy> peddie: great example
23:33:22 <glguy> i had to fork that package because of that oversight
23:33:57 <peddie> glguy: did you need to write Arbitrary instances?
23:34:11 <peddie> (I'm still curious about piyush-kurur's first question)
23:34:25 <glguy> no, I needed an indexing operation it didn't provide
23:34:58 <peddie> I see
23:35:16 <EvanR> so this is the haskell version of monkey patching, fork the package ;)
23:35:29 <piyush-kurur> EvanR, glguy, peddie, some times the type Foo is really internal (not even supposed to be exported to the users) unfortunately it does not work
23:36:05 <piyush-kurur> It would be good if the test cases have access to the other-modules stanza of cabal
23:36:05 <glguy> that's whats the internal module is for
23:36:08 <EvanR> most haskell code is open source, you cant really hide its existence from people
23:36:17 <EvanR> you can only make it impossible for them to do their job
23:36:21 <EvanR> without forking
23:36:37 <piyush-kurur> EvanR: the idea is not hiding the type. It is just that you want better type safety
23:36:46 <EvanR> its perfectly safe
23:37:41 <cocreature> well, exposing the constructors is unsafe in the sense that now you don’t have control over all functions that produce values of that type and thereby can’t guarantee that specific invariants hold
23:38:10 <glguy> which is why it goes in the Internal module
23:38:15 <cocreature> yep
23:38:41 <EvanR> if someone imports the Internal module and messes around with it like a high voltage wire, its the same as if they forked it and messed around with it like a high voltage wire, only its a bigger pain in the ass
23:38:58 <piyush-kurur> I am just saying if test suits can access the modules in other-modules then life would be easier
23:39:40 <piyush-kurur> currently test-suites are like external packages
23:40:21 <peddie> piyush-kurur: seems like the answer is "there's no better solution right now, sorry"
23:41:07 <cocreature> cabal 2.0 has internal libs that are not exposed externally but can be accessed from test suites iirc
23:41:37 <piyush-kurur> cocreature: that looks interesting
23:41:39 <nshepperd> in the past I have used unsafeCoerce to pull out data from hidden constructors. because it seemed like less of a pain in the ass than forking the package >_>
23:41:54 <Dompruss> okay I have an odd question that will probably sound really simple/strange hopefully. So for one of my courses i'm supposed to "make sure to export the functions you implemented" does that just mean to import at the top of my .hs file?
23:42:43 <Axman6> that means you write module MyModule (finctions, and, Types, you Want(To,Export)) where
23:43:01 <cocreature> piyush-kurur: here’s the corresponding changelog entry https://github.com/haskell/cabal/blob/master/Cabal/changelog#L8
23:43:31 <Axman6> so, if you want to make foo available from the module you've written called MyModule, you're write: module MyModule (foo) where ... <definitions of foo and other functions>
23:44:17 <geekosaur> note that the default if you have no export list is to export everything
23:44:24 <geekosaur> sometimes that's what you want, sometimes it isn't
23:45:04 <geekosaur> also beware that if you export a type, you ant to export its data constructor(s) too:  MyType(Constructor1, Constructor2) or MyType(..) to export all constructors
23:46:26 <piyush-kurur> cocreature: there should also be a way to expose Arbirary instances for the test cases
23:46:55 <piyush-kurur> I was thinking whether it make sense to have two views of the package the normal view and the test view
23:47:30 <cocreature> piyush-kurur: that’s not how typeclasses work. you can’t make local instances (assuming you don’t use orphans)
23:47:32 <piyush-kurur> when bar depends on foo then the tests suits of bar should see the test view of foo
23:47:55 * geekosaur wonders if this is something backpack can help with...
23:48:19 <geekosaur> like have a Tests module and backpack foo to either include that module or not
23:48:23 <cocreature> but if you export a type you probably should export your Arbitrary instances as well. otherwise everyone that depends on your package needs to implement its own
23:49:16 <piyush-kurur> cocreature: An examples is UTCTime. I do not think it has an arbirary instance
23:51:47 <piyush-kurur> So it looks like these irritating problems will exists with tests and no one really has any solution
23:53:52 <piyush-kurur> till  geekosaur figures out a way to handle it using backpack :-P
23:55:42 <cocreature> piyush-kurur: alternatively use hedgehog which doesn’t rely on typeclasses and thereby avoids all those problems :)
23:56:48 <nshepper1> Ideally there would be some magical solution that provides the instance when you import it, but only if quickcheck is also used
23:56:52 <biglambda>  Is it easy to write a parser with parsec that replaces one occurance in a string with another?
23:57:23 <biglambda> I’m trying to fix a bug in cabal-macosx but I’ve never used this library before.
23:58:16 <cocreature> biglambda: do you really need the capabilities of parsec? search-and-replace kind of tasks are usually easier using regex libraries
23:59:46 <biglambda> Yeah it’s just already using parsec so I wanted to see if there was a quick way to modify the parser.
