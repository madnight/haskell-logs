00:00:30 <iqubic> Threads are really cool in Haskell. I love the forkIO function.
00:01:23 <joe9> how do I get the seconds :: Integer from the NominalDiffTime? toInteger does not workr.
00:01:43 <joe9> http://codepad.org/m5wj5kiW
00:03:42 <cocreature> joe9: how about floor . realToFrac?
00:03:53 <joe9> got it  ((floor :: Double -> Integer) . realToFrac ) :: NominalDiffTime -> Integer
00:04:04 <joe9> Thanks cocreature
00:04:07 <Axman6> does round now just do it?
00:04:10 <Axman6> not*
00:04:19 <Axman6> or floor?
00:04:31 <cocreature> oh yeah floor is sufficient
00:05:25 <joe9> How about the other way from Double -> MkNominalDiffTime . There does not seem to be a fracToReal
00:09:59 <cocreature> joe9: does realToFrac not work?
00:10:10 <cocreature> it seems like it should
00:11:04 <joe9> cocreature: yes, it did.
00:11:04 <joe9> h
00:11:19 <joe9> cocreature: I was thinking that tehre must be a fracToReal for that.
00:11:47 <cocreature> joe9: Double is an instance of Real and NominalDiffTime is an instance of Fractional
00:12:10 <cocreature> but they are also both instances of the other class so you can use it in both directions
00:12:33 <joe9> cocreature:  oh, ok. Thanks.
00:51:31 <Sh4rPEYE> Hello. How do I write a general listcomp for n lists, that looks similar to this: [x ++ y | x <- xs, y <- ys]
00:51:39 <Sh4rPEYE> I tried to do it somehow with map, but withou luck
00:51:51 <quchen> listcomp?
00:51:58 <quchen> general?
00:52:01 <Cale> Are you looking for sequence?
00:52:08 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
00:52:10 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
00:52:29 <Sh4rPEYE> It seems
00:52:37 <Sh4rPEYE> Thanks!
00:52:59 <Sh4rPEYE> I'll look up the source of it :-)
00:55:36 <quchen> sequence (xs:xss) = do { x <- xs; xs' <- sequence xss; pure (x:xs') }
00:56:36 <dfordivam> > isJust Nothing
00:56:38 <lambdabot>  False
00:56:44 <dfordivam> Wow nice!
00:57:34 <merijn> isJust is an awful function which should be avoided
00:58:22 <dfordivam> merijn: in what context?
00:59:03 <jle`> dfordivam: in almost every context
00:59:11 <merijn> ^^ that
00:59:25 <quchen> isJust is a perfectly valid projection onto Bool
00:59:29 <quchen> fromJust is the devil
00:59:51 <merijn> quchen: But booleans are also evil and should be avoided! :)
00:59:53 <_sras_> When I try to run ghc-mod on a file I get this error "hGetContents: invalid argument (invalid byte sequence)". How can I fix this?
00:59:54 <jle`> i prefer (()<$) for my projections to Bool
01:00:18 <merijn> _sras_: Step 1) check whether your locale/terminal is set up correctly
01:00:45 <quchen> merijn: Haha
01:01:15 <merijn> If you play with your booleans too much you'll go blind
01:01:22 <quchen> Necessary evil sometimes though.
01:01:26 <quchen> e.g. filter
01:01:35 <_sras_> merijn: That was it. 
01:01:37 <jle`> code smell, at least
01:01:48 <_sras_> Thankyou.
01:02:02 <jle`> especially for someone new to haskell, 97% of bool usage is unnecessary
01:02:31 <merijn> _sras_: I have noticed a suspicious amount of broken default locale/terminal settings on linux, so it's my goto intuition ;)
01:02:42 <jle`> quchen: the solution is to not use filter and just use mapMaybe :)
01:02:53 <mniip> hey quchen!
01:03:02 <dfordivam> I actually never use isJust, mainly do applicative...
01:03:34 <mniip> 1491674340 [20:59:00] <mniip> has anyone ever thought about using Löb for an assembler? 1491674350 [20:59:10] <mniip> and/or linker 1491674374 [20:59:34] <mniip> e.g, say the branch instruction has multiple encodings depending on the size of the operand 1491674399 [20:59:59] <mniip> and the operand is the location of the invocation target, which ultimately depends on the size of the instructions inbetween
01:03:50 <jle`> you can also pattern match, too
01:03:56 <Philonous> case isJust foo of False -> ... *cough* 
01:04:12 <jle`> reminds me of everyone's favorite
01:04:16 <dfordivam> omg
01:04:19 <_sras_> merijn: So hGetContents trying to read the file in a wrong encoding, right?
01:04:24 <jle`> foo xs | not (null xs) = f (head xs)
01:04:54 <jle`> case isJust foo of True -> ... fromJust foo ...
01:04:56 <MarcelineVQ> jle`: if pred then True else False
01:05:20 <jle`> MarcelineVQ: if pred == True then True else False
01:05:30 <merijn> _sras_: All the String versions of file access (such as hGetContents in base) guess the encoding from the locale, but if the file is a different encoding, then decoding to unicode fails and it errors, yeah
01:05:31 <mniip> map f xs = bool [] (f (head xs) : map f (tail xs)) (null xs)
01:05:33 <MarcelineVQ> :>
01:06:18 <jle`> scary though that code like that would be perfectly normal/routine in other languages
01:06:30 <jle`> that's why if not (null xs) then ... head xs ... pops up so much
01:06:35 <merijn> _sras_: You can also override the default encoding to read with (or, probably better: use the ByteString file operations with an explicit decode)
01:06:35 <jle`> people are just used to doing it
01:06:43 <mniip> well
01:06:50 <jle`> in other languages
01:06:51 <mniip> to be fair, it isn't too slow either
01:06:58 <mniip> if not, null, and head are inlined
01:07:09 <mniip> and head's other branch is eliminated as dead
01:07:14 <jle`> the performance is probably the least problematic thing about that, heh
01:07:16 <mniip> and the head binding is floated out
01:07:17 <_sras_> merijn: Yes
01:08:11 <jle`> mniip: performance in general isn't too bad if everything was inlined all the way :)
01:08:31 <mniip> you can't inline everything
01:08:34 <merijn> has anyone ever proposed aliasing ByteString to Bytes?
01:08:51 <jle`> inline `find (/= 1) (map collatz [1..]`
01:09:00 <jle`> O(1) solution to the collatz conjecture ~
01:09:16 <jle`> er, `find ((/= 1) . collatz) [1..]`
01:09:17 <mniip> merijn, and String to Unicode?
01:09:20 <merijn> I don't think we're getting rid of the type completely, for backwards compatibility, but we could improve things a little bit
01:09:25 <merijn> mniip: String is fine, I think
01:09:44 <jle`> let ghc inline 100% and the resulting program is O(1)
01:09:53 <tdammers> in fact "unicode" is a bit of a shitty name, because it's kind of an implementation detail
01:09:54 <merijn> jle`: Not really
01:09:59 <mniip> jle`, not really
01:09:59 <Philonous> Would be better if String was a synonym for Text, but that would break too much code
01:10:01 <merijn> jle`: Input dependent computation
01:10:08 <mniip> it's either O(1) or O(inf)
01:10:33 <mniip> I can't tell you which right now
01:10:41 <quchen> mniip: I did not think about Löb for years.
01:10:56 <quchen> I don’t think it’s very practical, but fairly cute ;-)
01:11:05 <mniip> quchen, I was messing with assembly the other day and it just randomly kicked in
01:11:18 <jle`> mniip: well, if the conjecture is false, no program will ever get compiled
01:11:19 <mniip> like, I've read the lob article once
01:11:24 <mniip> jle`, not true
01:11:27 <mniip> it will compile to a bottom
01:11:30 <Philonous> tdammers, "Unicode" specifies the set of allowed elements, isn't that exactly what the type should say?
01:11:49 <mniip> jle`, dead code elimination
01:12:20 <jle`> oh, um, s/false/true
01:12:40 <quchen> mniip: Should you find something out let me know :-)
01:12:54 <mniip> quchen, not sure there's anything to find out
01:13:11 <mniip> just writing a huge program for the purpose of testing out a trick
01:16:04 <tdammers> Philonous: my philosophy is that the name should signal conceptual meaning, a.k.a. functional intent
01:16:14 <YellowOnion> anyone familiar with Lens? can I make `for producer (\x -> Pipes.Zlib.decompress width (yield x)) >-> consumer` less ugly?
01:16:26 <YellowOnion> sorry not lens pipes
01:17:03 <tdammers> if you use a different encoding for your strings, and change the compiler to support it, then the conceptual meaning of your program doesn't change, but calling your strings "unicode" is now incorrect
01:17:19 <tdammers> even though the program itself is still the same
01:17:28 <merijn> tdammers: That's not true
01:17:33 <merijn> tdammers: unicode is not an encoding
01:17:35 <Philonous> tdammers, Unicode doesn't imply an encoding, just the set of elements, no? It would be different if the type was called "UTF-8" 
01:18:03 <merijn> tdammers: It's an abstract representation that GHC uses, unicode is encoded to specific encodings, but isn't one
01:18:04 <tdammers> Philonous: yes, but you could make up a character set that isn't a subset of unicode
01:18:10 <tdammers> merijn: I know
01:18:26 <tdammers> merijn: "enoding" was the wrong word
01:18:35 <merijn> tdammers: You'd deserve to be executed, revived, and subsequently executed again for that crime against humanity >.<
01:18:40 <tdammers> merijn: sure sure
01:18:53 <tdammers> but, anyway
01:19:15 <tdammers> while unicode isn't an encoding, the mapping of code points to integer indexes is an implementation detail
01:19:20 <quchen> Good gracious, what did tdammers do?
01:20:13 <tdammers> quchen: I suggested creating a character set that is not a subset of unicode
01:20:59 <MarcelineVQ> the ultimate sin
01:21:19 <merijn> Oh, wait, I forgot, GHC has DerivingLift now :D
01:21:23 <tdammers> it's a thought experiment, I'm not suggesting you actually do it
01:22:00 <Philonous> tdammers, You could do that, but that would be a different type with different semantics. I don't see why it would be sensible to give it the same name 
01:22:09 <tdammers> I'm just saying that even though there is only one true way of mapping integers to characters, ahem, code points, doesn't magically stop that mapping from being an implementation detail
01:24:09 <tdammers> what I'm interested in when I write "String" is that it's a sequence of character-like things. not necessarily that those character-like things are actual unicode code points, or that their mapping to integer ordinals is done according to unicode
01:24:45 <merijn> Honestly String will never be proper anyway
01:25:00 <tdammers> how so
01:25:10 <merijn> Text is...ok, but for actual proper unicode support you'll need text-icu
01:25:21 <merijn> tdammers: Many operations are broken according to unicode semantics
01:25:32 <Philonous> tdammers, Sounds like you're describing a type-class rather than a type. 
01:25:35 <merijn> For example "toUpper :: Char -> Char" is a plain lie
01:26:30 <tdammers> toUpper :: a -> a -- is impossible anyway, unless the locale is somehow encoded in a itself
01:26:41 <tdammers> (cf. Turkish)
01:26:46 <merijn> tdammers: GHC uses system locale
01:26:54 <merijn> But String screws even that up
01:26:59 <tdammers> and even then, it would have to be a -> Maybe a
01:27:02 <tdammers> (cf. German)
01:27:30 <tdammers> let's see, what else breaks
01:27:34 <tdammers> modifiers obviously
01:27:45 <halogenandtoast> If one were to try and assign a color to Haskell (ruby is red, python green, etc.) What would that color be? I assume either Purple or Orange.
01:27:56 <MarcelineVQ> purps
01:28:11 <tdammers> purpange or orgle
01:28:33 <merijn> > toUpper 'ﬄ'
01:28:35 <lambdabot>  '\64260'
01:28:45 <merijn> > text [toUpper 'ﬄ']
01:28:47 <lambdabot>  ﬄ
01:29:04 <merijn> > T.toUpper $ T.pack ['ﬄ']
01:29:06 <lambdabot>  "FFL"
01:30:34 <merijn> But yeah, you need text-icu for dealing with things like Turkish
01:30:37 <Rembane> ick: Not bringing in dependent types is a very good thing. :)
01:31:39 <halogenandtoast> thanks
01:33:28 <quchen> Dependent types in Haskell feels a bit like Java users trying to use lambdas.
01:33:50 <Rembane> ick: Or if you change your mind, try Idris or Agda. They are cool.
01:33:55 <Rembane> quchen: Awkward? 
01:34:05 <gallais> quchen: https://stepik.org/course/ThCS-Introduction-to-programming-with-dependent-types-in-Scala-2294/
01:34:33 <quchen> gallais: Oh, you’re also on #haskell!
01:34:54 <quchen> Rembane: Not awkward, it’s doable and everything, but it doesn’t really fit.
01:35:03 <quchen> The syntax is clumsy, you hit walls left and right
01:35:13 <quchen> Then you bolt on fixes to make the walls softer
01:35:43 <quchen> gallais: Let me finish that one way of writing dependent types first, then I’ll head over to doing it in Scala ;-)
01:37:26 <merijn> Is there a way to silence a single orphan instance warning?
01:37:40 <quchen> Nope
01:37:43 <merijn> crud
01:37:50 <quchen> Put it into its own module :-)
01:38:08 <merijn> quchen: That would make things really inconvenient
01:38:28 <quchen> https://github.com/quchen/stgi/blob/master/test/Testsuite/Test/Orphans.hs
01:38:31 <quchen> That’s what I always do
01:39:05 <merijn> quchen: See, that's the quitters approach
01:39:26 <merijn> Real men just decide to add a PRAGMA to GHC to toggle individual orphan warnings and solve the issue once and for all!
01:39:30 <quchen> Quite the opposite: it allowed me to continue with more important problems
01:39:40 * quchen is not a real man :-(
01:39:57 <merijn> quchen: Sometimes progress has to be sacrificed for the greater good!
01:40:04 <merijn> (The greater good!)
01:40:11 <quchen> (The greater good!)
01:40:40 <Iceland_jack> (crusty jugglers)
01:41:27 <merijn> quchen: I believe in the compound awesomeness of small incremental improvements :)
01:47:43 <Rembane> merijn: And human sacrifice?
01:48:29 <merijn> Rembane: I don't admit to that in public ;)
01:49:00 <Rembane> merijn: :D
01:50:55 * Iceland_jack exchanges nervous glances
01:51:04 * Iceland_jack is human
01:51:52 * Rembane hands Iceland_jack a I'm-not-a-human-hat.
01:52:44 * Iceland_jack dons hat
01:52:45 <Iceland_jack> *beep*
01:55:19 <Rembane> :D
01:55:40 <Rembane> I miss the "this package has changed"-announcements in this channel.
01:57:21 <peddie> Rembane: me too; where did that go?  it was a fun way to discover new packages
01:58:46 <quchen> That was Hackagebot
01:59:04 <peddie> what happened to Hackagebot?
02:01:13 <quchen> I don’t know
02:02:35 <Rembane> It seems like the maintainer didn't want to maintain it anymore for some reason. https://mail.haskell.org/pipermail/haskell-cafe/2016-December/125859.html
02:04:35 <peddie> I guess it probably was a bit noisy at times . . .
02:04:48 <quchen> I muted Hackagebot too.
02:05:03 <quchen> But announcing major version bumps would be fine.
02:05:12 <quchen> Problem was lots of pushes of x.x.x.FOO versions.
02:05:37 <quchen> In other words, I would like to have a feed of new packages or notable updates, and not everything.
02:06:07 <Rembane> Let it post at most once every fiften minutes and aggregate all the updates in between. And don't let the same package be seen more than once per 24hrs.
02:07:11 <quchen> Yup, that sounds good to me.
02:14:41 <quchen> Haskell has functions from type to type, for example Maybe. What (exactly) is the difference to type families here?
02:15:40 <quchen> Type constructors are closed and injective, yes, but that’s not enough.
02:16:02 <Iceland_jack> Maybe is matchable (injective + generative)
02:16:06 <quchen> Type constructors also create a new type when applied, whereas type families can be closed and injective
02:16:14 <quchen> … and still not be type constructors
02:16:30 <quchen> »Generative« sounds good. What does it mean exactly?
02:17:04 <Iceland_jack> f a ~ g b ==> f ~ g
02:17:10 <quchen> That’s injectivity.
02:17:14 <Iceland_jack> no
02:17:15 <quchen> Oh, no.
02:17:17 <quchen> Wait. Right.
02:17:23 <quchen> Coinjectivity? :-)
02:17:30 <Iceland_jack> (f a ~ f b ==> a ~ b) is injectivity
02:17:36 <Iceland_jack> together they form... MATCHABILITY
02:17:52 <LiaoTao> Matchability, it's our hero
02:18:03 <quchen> Shouldn’t it be forall a. (f a ~ g a) -> f ~ g?
02:18:07 <quchen> Why a and b?
02:20:05 <Iceland_jack> Because it generates a new type, what ever the arguments are is my understanding
02:20:16 <hexagoxel> because generative does not imply injective, i suppose?
02:21:12 <quchen> So it’s ∀ a b f g. f a ~ g b => f ~ g
02:22:37 <Iceland_jack> I believe matchability will be visible in future Haskell (DependentHaskell)
02:22:48 <Iceland_jack> with an optional tick on the arrow '->
02:54:48 <adarqui> hey what's the status on records having fields with the same names? i remember something coming in to ghc8.. records can have the same field names, as long as the code typechecks, or something
03:00:22 <lieven> DuplicateRecordFields is in 8.mumble
03:00:44 <adarqui> ah cool that's what it was called, thanks
03:05:03 <Guest10294> hey guys i'm an object oriented language and i'm here to pwn u all
03:06:10 <Ferdirand> hello. Would you like to hear how you can use object-oriented patterns in Haskell through the use of co-algebraic style ?
03:06:13 <Guest10294> u like that?
03:06:49 <Guest10294> speak.
03:06:51 <tdammers> object-oriented programming can be very useful
03:07:07 <tdammers> the hammer principle still applies though
03:09:02 <quchen> (Hammer as in hammer factory factory, yes)
03:10:10 <Iceland_jack> Guest10294: Hey welcome to #haskell
03:10:15 <Ferdirand> Guest10294: it's nothing fancy, really. Since functions are first-class values in Haskell, it is very easy to make objects as datastructures that contains the actual operations that you would call on an object
03:14:04 <Guest10294> i object
03:14:42 <Iceland_jack> I hope that's a pun :)
03:15:09 <Iceland_jack> Have you taken a look at Haskell before?
03:19:08 <tsahyt> Is there a library providing a type such as Set (cardinality :: Nat) a?
03:20:26 <tsahyt> I'm asking purely out of curiosity. There are of course several libraries for length indexed vectors and lists, so I was wondering whether we also have something analogous for sets
03:21:21 <Iceland_jack> tsahyt: It would be more difficult
03:22:28 <Iceland_jack> consing an element to a length-indexed vector increments its length, but inserting an element into a set.. well: it depends on the Eq/Ord constraint
03:23:18 <tsahyt> I suppose you could do something like insert :: a -> Set n a -> Either (Set n a) (Set (S n) a)
03:23:33 <Iceland_jack> That's right
03:23:45 <tsahyt> alternatively, require a proof that the element is not already a member of the set
03:23:56 <tsahyt> which I suppose would be much harder
03:26:24 <tsahyt> Iceland_jack: from an API standpoint, would member :: a -> Set (S n) -> Bool be preferable to allowing checks against the empty set?
03:26:37 <tsahyt> Set (S n) a that is
03:27:49 <Iceland_jack> What is that preventing? It moves the proof obligation to the user of the function
03:28:40 <tsahyt> agreed, checking membership in the empty set is a perfectly valid thing to do anyhow
03:28:54 <tsahyt> I'm just going through Data.Set and thinking about what explicit cardinality would buy me
03:28:57 <Iceland_jack> When you enter this territory Liquid Haskell feels like a better direction
03:29:58 <tsahyt> dunno, for vectors at least vector-sized is quite nice to use and compiles to efficient code too. and I get more information out of typed holes
03:30:02 <Iceland_jack> It allows modeling type level sets, you could have an insertion function that only inserts new elements (as an example)
03:30:49 <tsahyt> I still have to dig deeper into liquid haskell. first I'm gonna finish this idris book though, while trying to port as many ideas over to somewhat sane haskell code as possible. purely as an exercise to see what is possible and what isn't.
03:32:06 <Guest10294> guys
03:32:11 <Guest10294> tried writing hello world with haskell
03:32:15 <Guest10294> see u on the other side
03:32:34 <quchen> tsahyt: You’d need an existential to get the resulting set, insert : a -> Set n a -> ∃ i. Set (n + i) a or something
03:33:07 <Iceland_jack> quchen: It hides a bit too much, it only needs one bit of information
03:33:10 <Guest10294> try writing hello world with haskell
03:33:13 <tsahyt> quchen: I think I prefer the either approach here
03:33:29 <quchen> Either is an existential boolean ;-)
03:34:09 <quchen> Either a b = ∃ x. if x then a else b
03:34:19 <Iceland_jack> Why use either when you can be complicated: a -> Set n a -> ∃b. Set (if b then n else n + 1)
03:34:26 <tsahyt> quchen: on the topic of existential results, what's the sanest way to encode this anyhow? I've usually been using some version of specialized existential wrapper for this. Then there's also data Some (x :: k -> *) = forall a. Some (x a)
03:34:36 <Iceland_jack> Guest10294: How did writing hello world go?
03:34:51 <quchen> tsahyt: I think it’s pretty hard to write this in Haskell (and make it usable)
03:35:01 <quchen> Heck, I think this is pretty hard to write in general!
03:35:24 <tsahyt> hmm. I might give this a shot. just writing this sort of wrapper around Data.Set, and then see how to use it
03:35:34 <Iceland_jack> go for it tsahyt
03:35:42 <Guest10294> try writing hello world in haskell
03:35:43 <quchen> A wrapper sounds like a good start.
03:35:46 <Iceland_jack> if it turns out useful, make a package ;)
03:35:54 <Iceland_jack> Guest10294: main = putStrLn "Halló heimur!"
03:36:05 <tsahyt> Iceland_jack: if I actually end up doing it, I might. It'd probably strip a lot of functions from the underlying implementation though
03:37:03 <tsahyt> quchen: it's something I've come to appreciate about vector-sized. It doesn't actually prove much to the compiler itself but rather just wraps around ordinary vectors. but in turn you get a very efficient implementation with guarantees on top. The main downside is really that because they're vectors, you can't pattern match on them.
03:39:00 <Guest10294> i mean, try writing hello world 5 times in haskell
03:39:20 <Iceland_jack> main = do putStrLn "Halló heimur!"; putStrLn "Halló heimur!"; putStrLn "Halló heimur!"; putStrLn "Halló heimur!"; putStrLn "Halló heimur!"
03:39:27 <quchen> main = go 5; go 0 = pure (); go n = putStrLn "hello world" >> go (n - 1)
03:39:48 <quchen> main = traverse putStrLn (replicate 5 "hello world")
03:40:04 <quchen> main = replicateM_ 5 (putStrLn "hello world")
03:40:05 <Iceland_jack> main = replicateM (putStrLn "Halló heimur!")
03:40:11 <Iceland_jack> oops, _ 5 :)
03:40:52 <Guest10294> main = do putStrLn "Halló heimur!"; putStrLn "Halló heimur!"; putStrLn "Halló heimur!"; putStrLn "Halló heimur!"; putStrLn "Halló heimur!"
03:40:53 <quchen> main = fix (\rec n -> if n > 0 then putStrLn "hello world" >> rec (n-1) else pure ()) 5
03:41:20 <quchen> One more and we’ve written 5 5-helloworlds. :-)
03:41:33 <Iceland_jack> #haskell: ahead of schedule!
03:43:11 <quchen> A pity main has to have (IO a), otherwise we could recurse on it directly.
03:43:28 <Guest10294> quchen: haha told ya
03:44:07 <quchen> n = unsafePerformIO (newIORef 5); main = do { x <- readIORef n; modifyIORef' (subtract 1) n; if n > 0 then putStrLn "hello world" >> main else pure () }
03:44:57 <sternenseemann> Data.Sequence (from containers) is lazy, right?
03:45:09 <quchen> I think it has a strict spine
03:45:30 <Iceland_jack> main = putStr $ take 60 $ cycle "hello world\n"
03:45:40 <sternenseemann> quchen: what exactly do you mean by that?
03:45:57 <quchen> The elements are lazy, but the data structure itself is strict
03:46:09 <quchen> So you can’t have an infinite Seq for example
03:46:17 <sternenseemann> i see
03:46:51 <quchen> Just like Data.Map
03:46:56 <sternenseemann> mh
03:47:28 <sternenseemann> annoying though, because a) our project tries to not use lazy data structures and b) I will evaluate all elements, always
03:48:24 <sternenseemann> oh nvm
03:48:28 <Taneb> sternenseemann, is there any particular reason you're avoiding laziness?
03:48:31 <sternenseemann> I can solve it much better using map
03:48:41 <sternenseemann> Taneb: space/memory leaks, I am told
03:49:18 <Taneb> sternenseemann, I think that's made out to be more of a problem than it is
03:49:19 <quchen> Not having laziness causes time leaks.
03:51:22 <Athas> If you want to avoid laziness out of principle, Haskell may be the wrong language.
03:51:57 <pacak> In some situations you need laziness, in some - you want things to be strict. Deciding when you want which behavior is hard.
03:55:02 <Guest10294> putStrLn ; putStrLn ; putStrLn ; putStrLn ; putStrLn looks pretty sequential
03:55:09 <Guest10294> u just got pwned
03:55:48 <quchen> kek
03:56:01 <Iceland_jack> Guest10294: You can replace the semicolon with an operator!
03:56:12 <Iceland_jack> putStrLn "hello" *> putStrLn "hello" *> putStrLn "hello" *> putStrLn "hello" *> putStrLn "hello"
03:56:18 <Iceland_jack> much functional wow
03:56:20 <quchen> sternenseemann: Avoiding laziness is not a good idea in general, consider »head [1..10^100]«.
03:57:01 <quchen> sternenseemann: Learning when to have or when to avoid laziness is very useful; I don’t think avoiding it at all cost is a good default.
03:57:15 <quchen> For example, I’d say there’s nothing wrong with having the values lazy in a sequence.
03:57:43 <quchen> But you can wrap the library and force all values before inserting them into the sequence of course.
03:58:02 <quchen> Data.Map does this: .Lazy does not force, .Strict forces values before insertion.
03:58:13 <quchen> The actual Map data structure is identical (and hence compatible) in both cases.
04:01:36 <Athas> quchen: which means that e.g. the Functor instance doesn't force, right?
04:12:00 <tdammers> yeah, the strict/lazy thing with Map (and HashMap) is actually somewhat annoying sometimes
04:12:50 <tdammers> operation on maps that go through typeclasses don't know anything about whether you want lazy or not
04:13:26 <tdammers> newtyping the base map type to a strict and a lazy flavor would have been nicer IMO
04:13:51 <merijn> tdammers: But then you have to reimplement every function :)
04:14:07 <tdammers> GeneralizedNewtypeDeriving to the rescue
04:14:32 <merijn> tdammers: That doesn't derive functions, just classes
04:14:43 <tdammers> oh sure
04:15:09 <tdammers> the functions, you want most of them to be different though, don't you?
04:15:24 <merijn> tdammers: I don't think so?
04:15:33 <tdammers> or maybe not
04:15:34 <merijn> tdammers: Everything that deals with splitting/combining maps can stay identical
04:16:05 <tdammers> hmm, but you could implement that stuff for the base type, then forwarding it to the newtype wrappers shouldn't be tricky at all
04:16:18 <tdammers> I do ssee the appeal though
04:16:27 <Athas> merijn: that kind of duplication is OK in a library.
04:16:40 <merijn> Athas: It's painful to implement, though
04:16:41 <Athas> Of course, if Haskell had a proper module system we wouldn't have this issue!
04:16:50 <merijn> Maybe you could automate it with TH...
04:17:00 <tdammers> also, I think it'd be justify to pull out the TH hammer here, or maybe even CPP
04:17:15 <tdammers> s/justify/justified/g
04:17:22 <Athas> Wouldn't TH require that you write the entire library as an AST?
04:17:38 <merijn> Athas: No, I meant write TH to convert from lazy map to strict
04:18:06 <merijn> Most function can be converted in a fairly straightforward manner, just make all occurences of the content of the map strict
04:18:48 <tdammers> that, or write TH that attempts to write the functions for any given type, and call it once on the strict and once on the lazy newtype
04:19:22 <tdammers> or just use CPP to paste the same code into both modules
04:23:24 <lambda2348327432> Someone has an idea why it says duplicate declaration here? https://codepaste.net/bc61ka
04:24:26 <Gurkenglas> lambda2348327432, you wrote sumeveryTwo instead of sumEveryTwo once
04:24:41 <lambda2348327432> lol
04:24:49 <Gurkenglas> (So the line above and below that count as separate declarations)
04:25:06 <lambda2348327432> why the hell does it tell me the declaration is duplicate then?
04:25:20 <Gurkenglas> See my last line
04:25:37 <Gurkenglas> sumEveryTwo = map sum . chunksOf 2
04:26:21 <lambda2348327432> well it should rather complain about the definition being non exhausive because one case is missing?
04:26:51 <Gurkenglas> Turn on -Wall, though I'm not sure that'll show you anything while there are still duplicate declarations
04:27:29 <Athas> Sometimes GHC will not show warnings if there is an error.
04:27:35 <Athas> (Although nowadays, I think that is rare.)
04:29:45 <lambda2348327432> but why does it complain about multiple declarations in the first place? the two declarations cover different parameters
04:30:03 <Gurkenglas> They're not right next to each other, there's something else between them
04:30:15 <lambda2348327432> Oh oka, did not know this mattered
04:50:20 <lambda2348327432> in a list comprehension i can use if...else like this: [if even x then x else 0 | x <- [1..10]]. but can i also use guards here like [x | even x = 2 * x | otherwise 0 | x <- [1..10]]?
04:50:49 <lambda2348327432> probably will confuse the parser
04:56:32 <merijn> lambda2348327432: Not like that, no
04:56:57 <lyxia> what you wrote first is the simplest, but if you want to filter and keep only even numbers you can write [x | x <- [1..10], even x]
04:57:06 <sternenseemann> quchen: I totally agree, but that's the policy I guess
04:57:08 <Iceland_jack> lambda2348327432: you can bind it with a "let" but that just shuffles the if/then/else it about
04:57:10 <Iceland_jack> -it
04:57:16 <sternenseemann> quchen: we also sometimes have lazy data structures
04:58:16 <sternenseemann> quchen: if one accesses all elements of a finite data structures, laziness might be not the best idea generally e. g.
04:59:18 <quchen> Yes, if you always need all element of a data structure laziness is useless.
04:59:48 <quchen> Well, may be useless.
05:04:46 <pacak> quchen: If you produce those elements on demand and consume incrementally laziness will reduce max memory requirement.
05:05:32 <Jinxit> i have some very repetitive code, any ideas for how i can make it less repetitive? http://lpaste.net/5161123845821693952
05:05:37 <Jinxit> the instance declarations, that is
05:06:24 <Jinxit> (just realized there's a type error in there but it's less important)
05:08:01 <xificurC> is there a way to write (-2) and mean a section and not unary negation? Or does one need to write \x -> x - 2
05:08:09 <Iceland_jack> :t subtract 2
05:08:10 <lambdabot> Num a => a -> a
05:08:22 <nbro> hi
05:08:22 <Iceland_jack> > subtract 2 10
05:08:24 <lambdabot>  8
05:08:31 <Iceland_jack> Hello nbro
05:08:36 <nbro> .
05:08:40 <yhhko> > (-) 3 2
05:08:41 <xificurC> Iceland_jack: thanks
05:08:42 <lambdabot>  1
05:09:05 <xificurC> yhhko: (-) won't work since I need x-2 not 2-x
05:09:21 <nbro> is there a way to suggest corrections in the Haskell wiki?
05:09:22 <yhhko> ah gotcha :)
05:09:33 <yhhko> best i can do is "flip (-) 2" then :)
05:10:23 <Iceland_jack> subtract = flip (-) ;)
05:10:59 <pacak> Jinxit: It might help to extract recursion part...  http://blog.callcc.name/posts/free-sourcepos.html - something along those lines
05:11:18 <romildo> Which library should I use to read the contents of a HTML _local_ file?
05:11:39 <Jinxit> pacak: i'll go read that, thanks
05:11:58 <pacak> romildo: tagsoup?
05:12:35 <quchen> pacak: Hence the »may be« correction :-þ
05:13:19 <quchen> > 10 `subtract` 2
05:13:22 <lambdabot>  -8
05:13:38 <quchen> :)
05:14:29 <pacak> Jinxit: It might be not exactly your case but I successfully used this approach to save a bunch of typing for various AST manipulations.
05:14:59 <romildo> pacak, yes, I am going to use tagsoup. But how to read the content of the HTML file before giving it to tagsoup? The examples uses Network.HTTP. I was thinking that would be something simpler for that.
05:15:30 <pacak> Hmmm....
05:15:33 <pacak> :t readFile
05:15:35 <lambdabot> FilePath -> IO String
05:17:03 <Jinxit> pacak: the problem with this approach is that it assumes all AST nodes refer to other AST nodes
05:17:10 <pacak> > ((!!2) . iterate pred) 10
05:17:12 <lambdabot>  8
05:17:14 <Jinxit> my entire AST type is a tree itself
05:17:27 <Jinxit> to enforce some correctness in the type system itself
05:18:19 <pacak> Looks more like a list then..
05:19:21 <yhhko> > (+(-2)) 10
05:19:24 <lambdabot>  8
05:19:40 <yhhko> xificurC: is that what you were looking for?
05:19:52 <Jinxit> well, a Func is a TypeDef, a Maybe (TypeDef), a few MemberDeclarations, and an Annotation. a TypeDef is either a BuiltIn, a UserType, or an Array. this keeps going down the levels
05:19:58 <Jinxit> how is that a list?
05:20:17 <xificurC> > subtract 2 10
05:20:19 <lambdabot>  8
05:20:27 <xificurC> yhhko: as Iceland_jack pointed out
05:20:42 <yhhko> yeah but that uses letters. who wants letters.
05:21:01 <xificurC> yhhko: the result is the same, sure
05:21:07 <Iceland_jack> @let (.-) = flip (-)
05:21:09 <lambdabot>  Defined.
05:21:14 <Iceland_jack> > 2 .- 10
05:21:16 <lambdabot>  8
05:21:35 <yhhko> > let subtract_two x = x-2 in subtract_two 10
05:21:37 <lambdabot>  8
05:22:20 <xificurC> yeah, many ways to make it *less* readable :)
05:22:46 <yhhko> perhaps i should've called it "subtract_smallest_prime_integer"
05:25:14 <pacak> > appEndo (foldMap Endo (replicate  2 pred)) 10
05:25:16 <lambdabot>  8
05:25:26 <Iceland_jack> oh boy..
05:26:18 <Iceland_jack> That's horribly difficult to understand, let me fix it
05:26:19 <Iceland_jack> > foldMap Endo (replicate  2 pred) `appEndo` 10
05:26:21 <lambdabot>  8
05:26:22 <Iceland_jack> there we go
05:26:44 <yhhko> > (*2) . pred . (/2) $ 10 -- *prays*
05:26:47 <lambdabot>  8.0
05:26:55 <orion> :t pred
05:26:57 <lambdabot> Enum a => a -> a
05:27:18 <Iceland_jack> > fold [Endo pred, Endo pred] `appEndo` 10
05:27:20 <lambdabot>  8
05:29:08 <pacak> > let here_be_kittens = appEndo . foldMap Endo . flip replicate pred in here_be_kittens 2 10
05:29:10 <lambdabot>  8
05:33:03 <xormor> I am willing to learn Haskell! I visited the WWW page for it.
05:33:24 <xormor> how do I get started? have an URL or advice?
05:34:29 <pacak> http://learnyouahaskell.com/chapters - nice beginner  friendly book
05:35:53 <cocreature> xormor: do you already know other programming languages? maybe even functional programming languages?
05:46:16 <maerwald> pacak: please no
05:46:33 <maerwald> lyah is not very popular here
05:46:41 <maerwald> @where learnhaskell
05:46:41 <lambdabot> https://github.com/bitemyapp/learnhaskell
05:46:44 <maerwald> go there
05:47:17 <xormor> cocreature, C, C++ and assembly (x86 and amd64). I mostly know the '90's versions of the C and the C++ programming languages. I learned a bit of Java earlier, but have forgotten since.
05:47:29 <JuanDaugherty> it's not?
05:47:37 <JuanDaugherty> (lyah)
05:47:37 <xormor> cocreature, I have forgotten BASICA and QBasic.
05:48:37 <nbro> hey
05:48:44 <nbro> what would be the purpose of doing "main = do return"
05:48:57 <nbro> i.e. just doing  "return"
05:49:40 * JuanDaugherty is ready to fall in with the party line, once reeducated.
05:49:49 <alanz> it would have to be "main = do return ()", and it's basically a NOP
05:50:53 <cocreature> xormor: if you already know programming, http://haskellbook.com/ is supposed to be very good (but I haven’t read it personally since it came out after I’ve learned Haskell)
05:52:16 <cocreature> nbro: it might be worth noting that "do x" is always the same as "x"
05:52:28 <cocreature> x doesn’t even need to be a monadic action
05:52:41 <cocreature> > do 'a'
05:52:43 <lambdabot>  'a'
05:53:18 <Myrl-saki> cocreature: Scarily.
05:53:57 <cocreature> Myrl-saki: hm I think I’ve gotten used to it my now. it doesn’t seem scary anymore ;)
05:54:09 <cocreature> but yeah it’s definitely slightly confusing
05:54:26 <Myrl-saki> Petition to rewrite `do x` as `return () >> x`
05:54:28 <Myrl-saki> :D
05:54:52 <nbro> alanz: because I saw a similar expression, i.e. without () in front of return, and that’s why I was wondering if it meant something special
05:55:07 <nbro> return indeed requires an argument
05:55:32 <nbro> so it would make sense to simply "do return", unless return would also be defined somewhere else
05:55:40 <nbro> *it wouldn’t
05:55:45 <alanz> yes
05:56:02 <cocreature> > (do return) ()
05:56:05 <lambdabot>  error:
05:56:05 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M244744301726...
05:56:05 <lambdabot>        prevents the constraint ‘(Show (m0 ()))’ from being solved.
05:56:12 <cocreature> that would work :)
05:56:18 <alanz> but sometimes you would use "return ()" as a parameter in a call to a function expecting another function
05:56:30 <xificurC> @let ret = do return
05:56:32 <lambdabot>  Defined.
05:56:34 <nbro> I heard that >=> is the monadiac composition operator
05:56:40 <nbro> "> = > "
05:56:44 <pacak> :t (>=>)
05:56:45 <nbro> in practice, what does it mean?
05:56:46 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:56:55 <cocreature> :t (.)
05:56:56 <nbro> it takes two functions
05:56:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:57:02 <pacak> Same idea
05:57:12 <nbro> it’s like monads are transitive
05:57:20 <pacak> takes output from one computation shoves it into second one
05:57:24 <pacak> @src (>=>)
05:57:25 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:57:31 <pacak> lambdabot: :-P
05:57:33 <Myrl-saki> >=> is an emoticon
05:57:48 <nbro> I’m asking, in pratice, does anyone use this operator?
05:57:53 <merijn> I do
05:57:53 <Myrl-saki> nbro: Yes.
05:57:55 <pacak> I do
05:57:57 <tdammers> absolutely
05:58:01 <Myrl-saki> lmao
05:58:04 <alanz> I used it for the first time for real recently
05:58:05 <cocreature> there is also <=<
05:58:11 <nbro> can I see a concrete example where it’s really useful
05:58:14 <merijn> Fish operator is amazing
05:58:16 <Myrl-saki> cocreature: When you want to look the other way.
05:58:16 <nbro> ?
05:58:19 <merijn> nbro: xml-conduit docs
05:58:23 <cocreature> :t (<=<)
05:58:25 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
05:58:25 <cocreature> :t (>=>)
05:58:27 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:58:37 <cocreature> the former is closer to (.)
05:58:38 <Myrl-saki> Now we only need ^=^ and v=v
05:58:47 <cocreature> Myrl-saki: we already have ^+^
05:58:52 <nbro> (.)
05:58:53 <nbro> lol
05:58:53 <cocreature> I don’t think I’ve seen ^=^
05:58:58 <Myrl-saki> :t (^+^)
05:58:59 <lambdabot> error:
05:58:59 <lambdabot>     • Variable not in scope: ^+^
05:58:59 <lambdabot>     • Perhaps you meant ‘^^’ (imported from Prelude)
05:59:02 <merijn> nbro: also: https://gist.github.com/merijn/d8188ddd129718ffcfb0#file-scraper-hs-L56-L59
05:59:04 <Myrl-saki> Awww. :C
05:59:12 <pacak>         con :: Handle -> Enumerator [RawPacket] IO a
05:59:12 <cocreature> Myrl-saki: it’s in linear
05:59:12 <pacak>         con infoSock = enumTcpHandle infoSock >=> liveWooriSimDriver proto infoSock
05:59:15 <alanz> nbro: see https://github.com/ghc/ghc/commit/5282bb1772ba3f1dc999a177965e543822f342a0
05:59:17 <pacak> ^ from a real project
05:59:47 <cocreature> Myrl-saki: https://hackage.haskell.org/package/linear-1.20.5/docs/Linear-Vector.html#v:-94--43--94-
05:59:52 <alanz> makes the mapM simpler, else you need a separate function or complex lambda
06:00:04 <Myrl-saki> cocreature: Thanks.
06:00:16 <cocreature> surprisingly hoogle doesn’t know ^=^
06:00:33 <Myrl-saki> cocreature: hayoo?
06:00:53 <cocreature> doesn’t find anything either
06:01:02 <nbro> so, in layman’s terms, how would you describe the utility of this operator?
06:01:15 <Myrl-saki> nbro: "I need to use (.), but I only have monads"
06:01:24 <Myrl-saki> s/need/want/
06:01:51 <alanz> nbro: it lets you write "f (g x)" where both f and g are monadic
06:01:54 <cocreature> f <=< g = \x -> f =<< (g x)
06:02:15 <xormor> Haskell is a good-looking language. Maybe I should try drinking coffee while learning Haskell. I might have to go buy some milk from the grocery store first :-D
06:02:18 <alanz> so it means "do f after g, on the result"
06:02:22 <nbro> Myrl-saki: what if one doesn’t know about (.)
06:02:44 <cocreature> nbro: I think then it makes sense to introduce (.) first :)
06:02:48 <nbro> xormor: ahah
06:03:01 <nbro> good-looking it a nice measure to spend time loving
06:03:08 <nbro> lol
06:03:27 <nbro> *metric?
06:03:31 <Myrl-saki> nbro: Teach them about (.)
06:03:37 <nbro> > (.)
06:03:38 <Myrl-saki> :D
06:03:39 <lambdabot>  error:
06:03:39 <lambdabot>      • No instance for (Typeable b0)
06:03:39 <lambdabot>          arising from a use of ‘show_M675969288210474283411652’
06:04:16 <nbro> oh
06:04:17 <pacak> @src (.)
06:04:17 <lambdabot> (f . g) x = f (g x)
06:04:18 <nbro> never mind
06:04:22 <nbro> lol
06:04:28 <nbro> I was not thinking about .
06:04:32 * Iceland_jack is still in love with the definition of (.)
06:04:38 <nbro> but you were just wrapping it with ( and )
06:04:39 <nbro> lol
06:04:45 <nbro> ok
06:05:17 <cocreature> nbro: you need to wrap operators in parenthesis if you want to use them in a non-infix way
06:05:20 <cocreature> which includes things like :t
06:05:30 <nbro> @todo something
06:05:31 <lambdabot>  @todo has no args, try @todo-add or @list todo
06:06:04 <cocreature> lambdabots definition of (.) would prevent GHC from inlining (.)!
06:06:13 <Iceland_jack> :t (+)
06:06:15 <lambdabot> Num a => a -> a -> a
06:06:15 <nbro> cocreature: yeah, right, I was imply not visualizing (.) in my head as the operator "composition of functions"
06:06:22 <Iceland_jack> > (+) 10 200
06:06:24 <lambdabot>  210
06:06:26 <nbro> imply=*simply
06:06:48 <nbro> *deferencing
06:06:54 <nbro> lol
06:06:59 <nbro> dereferencing
06:07:07 <nbro> omg
06:07:18 <nbro> > [1..10]
06:07:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
06:07:22 <nbro> lol
06:07:29 <nbro> @seen
06:07:30 <lambdabot> Say again?
06:07:37 <Myrl-saki> * is dereferencing.
06:07:42 <Myrl-saki> :P
06:08:07 <nbro> I meant, when you dereference simply you get imply
06:08:41 <nbro> I almost laugh in the 9th dimension of this multidimensional existence
06:08:45 <nbro> *laughed
06:08:56 <xificurC> anyone used haskell for web scraping with some tips on what lib to use?
06:09:09 <nbro> @free
06:09:09 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
06:09:16 <cocreature> xificurC: I just use http-conduit & html/xml-conduit
06:09:18 <nbro> @dummy
06:09:18 <lambdabot> dummy
06:09:24 <nbro> @dice
06:09:25 <lambdabot> unexpected end of input: expecting number, "d" or "("
06:09:31 <cocreature> xificurC: merijn has a gist of scraping cartoon images somewhere iirc
06:09:36 <nbro> @undo
06:09:36 <lambdabot> Error: expected a Haskell expression or declaration
06:09:41 <cocreature> nbro: you can send private messages to lambdabot instead of spamming here
06:10:02 <Myrl-saki> @dice d
06:10:02 <lambdabot> unexpected end of input: expecting number
06:10:04 <nbro> @search "blah"
06:10:04 <lambdabot> Unknown command, try @list
06:10:14 <merijn> cocreature: I just linked it, but it's bitrotted
06:10:32 <nbro> cocreature: I know and I should at least lie and tell you I’m not doing it on purpose
06:10:35 <Myrl-saki> merijn: owo hi hi~
06:10:35 <merijn> It relies on the Monad instance of Async, for one
06:10:49 <pacak> @dice 1d20
06:10:49 <lambdabot> pacak: 10
06:10:51 <nbro> but my me of the 7th dimension is ruining me
06:10:57 <merijn> xificurC: But see here: https://gist.github.com/merijn/d8188ddd129718ffcfb0
06:11:21 <cocreature> I guess bringing it up2date shouldn’t be terribly hard
06:11:41 <merijn> cocreature: Well, depends on your definition of bringing it up to date
06:12:02 <cocreature> merijn: getting it working with a new version of async :)
06:12:05 <merijn> cocreature: async dropped the monad instance of Concurrently, so it's actually impossible with modern async
06:12:46 <cocreature> merijn: well you can just manually implement concurrency
06:12:52 <merijn> But the scraping part should work
06:14:09 <merijn> bleh, now I need to benchmark criterion >.>
06:14:20 <nbro> endofunctor
06:14:20 <merijn> To see if my changes broke things >.<
06:14:28 <nbro> and functor from a category to itself
06:15:07 <merijn> oh, semi-relatedly...
06:15:13 <nbro> clearly
06:15:16 <merijn> What's the cheapest semaphore like operation I can do in GHC?
06:15:46 <merijn> Like...if I need synchronisation cheaper than MVars how fast can I get?
06:16:43 <quchen> atomicallyModifyIORef?
06:16:54 <quchen> Very small semaphore
06:17:02 <nbro> so arrows in category theory are like a generalization of linear maps for vector spaces
06:17:03 <quchen> But I think it outperforms MVars. But don’t quote me on that.
06:17:39 <merijn> quchen: Makes it hard to block until time X, though...
06:17:54 <merijn> Now I need to benchmark semaphore-ish operation so I can write my actual benchmark >.>
06:18:10 <nbro> what’s a "groupoid"?
06:18:16 <nbro> well, it depends on how you read it
06:18:17 <nbro> :D
06:19:49 <quchen> merijn: How about atomicModifyIORef?
06:19:59 <quchen> It’s like »withMVar with a () lock«
06:20:25 <quchen> If you really need an n-lock, i.e. a semaphore, then I’m not sure what to use but Data.Sem
06:20:40 <quchen> Or whatever the standard Foo.Concurrent semaphores are called
06:21:02 <fizbin> Can someone explain the difference between http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Strict.html#v:modify-39- and http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#v:modify-39- ?
06:21:04 <merijn> quchen: Yeah, but those seem fairly expensive compared to the operations I wanna benchmark >.>
06:21:21 <merijn> fizbin: One is for Strict State, the other for Lazy?
06:21:32 <quchen> »Seem«?
06:21:36 <fizbin> But look at the description of modify'
06:22:09 <merijn> quchen: Well, I'm trying to benchmark writeChan, which is basically 2 MVar operations :)
06:22:27 <fizbin> Specifically, is modify' the same as modify when working in C.M.State.Strict ?
06:22:45 <cocreature> fizbin: strict vs lazy state monad does not mean strictness in the state value
06:23:00 <cocreature> fizbin: the lazy statemonad does a lazy pattern match on the tuple
06:23:23 <cocreature> fizbin: https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.State.Strict.html#line-214 vs https://hackage.haskell.org/package/transformers-0.5.4.0/docs/src/Control.Monad.Trans.State.Lazy.html#line-217
06:23:25 <fizbin> Which "the tuple"?
06:23:45 <cocreature> State is a function s -> (a, s)
06:23:47 <ski> monochrom has some examples of lazy `State', iirc
06:25:17 <cocreature> https://kseo.github.io/posts/2016-12-28-lazy-vs-strict-state-monad.html also has some examples
06:26:40 <merijn> Quick question: If I have 'x :: a' and 'f :: a -> IO b' what's the best way to ensure the function is fully evaluated (without executing the IO)? "let !act = f x in ..."?
06:28:19 <fizbin> So I'm still a bit confused then (even after reading that) about what C.M.State.Strict is actually strict in.
06:28:41 <ski> fizbin : see "control.monad.state.lazy" by monochrom in 2010-11-25 at <http://lpaste.net/41790>
06:29:29 <ski> fizbin : "lazy ST example" by ibid in 2012-02-18 at <http://lpaste.net/63925> might also be interesting
06:29:59 <quchen> State m >>= f = State (\s' -> let  (x1,s1) = runState m s;  (x2,s2) = runState (f x1) s1 in (x2,s2)) 
06:30:08 <quchen> State m >>= f = State (\s' -> let ~(x1,s1) = runState m s; ~(x2,s2) = runState (f x1) s1 in (x2,s2)) 
06:30:13 <quchen> Lazy vs strict state.
06:30:50 <quchen> Probably full of typos. Anyway, the irrefutable pattern (the tilde) is the difference between strict and lazy state.
06:30:59 <fizbin> quchen: Right, I can read the definitions. I'm just having trouble figuring out what that means for what gets evaluated.
06:31:12 <fizbin> And when.
06:31:36 <quchen> To be *sure* see the STGi ;-)
06:33:03 <quchen> In the lazy case with the tildes, you get the final result, (x2,s2) without evaluating the runState computations
06:33:21 <quchen> They’re forced only when pattern-matching on the tuple
06:33:51 <quchen> Well, what you get is »the result«. And matching »the result« will give you (x2,s2), and in the process force the entire thing.
06:34:11 <merijn> oh...I guess I can just seq my IO action?
06:34:41 <quchen> Sure
06:34:59 <fizbin> It seems that it's the rough equivalent of "strict state will evaluate your do expression stack roughly similar to the way you expect an imperative language to behave, whereas lazy state will behave the way it would if you remember that it's all haskell functions really and seemingly infinite tail recursion can be fine if you don't stare into the abyss"
06:35:01 <merijn> That's probably simpler than messing with NFData
06:35:11 <merijn> Since I don't think IO has an NFData instance
06:35:19 <merijn> oh, wait, I guess I want pseq
06:35:27 <merijn> since seq doesn't guarantee ordering
06:36:32 <quchen> If you’re in IO anyway, you can use »evaluate x«.
06:36:34 <quchen> :t evaluate
06:36:35 <lambdabot> a -> IO a
06:36:39 <quchen> »IO-seq«
06:36:41 <fizbin> However, evaluating functions in your "do" list or (>>=) chain is distinct from actually evaluating state.
06:37:06 <ski> `evaluate' is for the result of an `IO' action. it seemed merijn wasn't in such a situation ?
06:37:26 <quchen> Evaluate takes any thunk as argument.
06:37:27 <math493> Can anyone here construct a simple (not too sophisticated) example showing the power of functional programming? Something where you can see the power of Haskell compared to e.g. Python? I am trying to learn what functional programming is, but none of the examples I have seen so far couldn't be done in Python (even though I was adviced not to use a multi-paradigm language for functional programming). Preferably no more than 5 lines 
06:37:51 <math493> I heard that there are some things which you could not just have used Python for (or which would be very ugly or cumbersome in Python).
06:37:52 <quchen> evaluate x = x `seq` pure x   (almost)
06:38:10 <merijn> ski: I'm in IO and have 'x :: a', 'f :: a -> IO b' and want to evaluate the application 'f x', specifically to ensure that, if 'x' is not used inside 'f' it can be GCed directly instead of being kept live by the thunk
06:38:12 <Iceland_jack> math493: honestly, you will never see the power of it from one, two or thirty examples
06:38:44 <quchen> math493: How would you show the power of OOP in maybe 5 lines?
06:39:19 <math493> quchen: Well, from what I understand, OOP is a lot more... verbose.
06:39:24 <math493> Iceland_jack: So it is impossible to show some nice (and uncomplicated) example illustrating what functional programming is and why it is nice?
06:39:26 <quchen> Well, give it 50 lines.
06:39:38 <quchen> The point is, single examples don’t tell you much.
06:39:38 <Iceland_jack> it's about building a vocabulary and seeing powerful pattern emerging from that, to someone not familiar with those patterns they will seem trivial and boring
06:39:39 <ski> quchen : "almost", yea. it's not quite that
06:39:51 <quchen> ski: The docs give the details, yes
06:39:58 <Iceland_jack> math493: Not in any way that has real substance
06:40:23 <ski> merijn : *nod*
06:40:29 <quchen> math493: Seeing how you know OOP already, consider how often you’re playing the »where is the actual work happening« game. Or the »is this initialized correctly«. Or the »in what state am I and may I do this«.
06:40:37 <ski> ("run-time compilation", perhaps)
06:41:00 <math493> quchen: Yeah :)
06:41:10 <quchen> FP avoids these problems for the most part: mutable/implicit state is minimal if present at all, and usually there’s a very clear picture of what you have.
06:41:17 <merijn> ski: It's just unclear how I can best accomplish that, since I'm not sure "let !act = f x in ..." works and cobbling something together with seq is kinda tricky
06:41:25 <math493> But OK, if I allow more than 10 lines, could you then come up with an example? Again, please try to keep it simple, so it is easy to understand (or at least, if it is complicated, please explain it to me) :)
06:41:33 <quchen> Scopes are very small: maybe 2-3 variables. There is no »wait this global variable might be false so …«
06:42:02 <quchen> math493: Well, you’ve seen the map-and-filter examples. That’s as far as 10 lines get you.
06:42:24 <merijn> math493: You already know 1 or more other languages, right?
06:42:37 <math493> merijn: Yes. But no functional programming language.
06:42:40 <merijn> math493: What's the hardest issue you encounter finding/preventing/fixing bugs?
06:43:07 <ski> merijn : initially i thought you had already considered something like `let y = f x in seq y (..y..)', and considered it not pretty enough ..
06:43:09 <math493> merijn: Well, it depends, I would say. But sometimes finding the right part...
06:43:30 <ski> (hence `let !y = f x in ..y..' instead)
06:43:47 <merijn> ski: That doesn't actually do what I need, though :)
06:43:54 <ski> oh ?
06:44:06 <merijn> ski: Since it's not guaranteed the left hand of 'seq' is forced before the right hand
06:44:17 <merijn> The order of 'seq' is unspecified
06:44:20 <ski> oh, right. s/seq/pseq/ then
06:44:50 <math493> But let me try to phrase my question in another way: I guess people in #haskell like Haskell. Why do you like Haskell? What are the advantages of Haskell compared to e.g. Python? Why don't you use Python instead?
06:45:08 <math493> I guess it has some strengths :)
06:45:40 <quchen> It’s easier to reason about programs, so I don’t have to think as much. :-)
06:45:47 <Sornaensis> haskell is easier to test and refactor than python
06:45:54 <quchen> Data point: we don’t have debuggers. We sometimes want debuggers, but not very often.
06:46:16 <quchen> Debugging Haskell mostly means reading the code, as opposed to running it and seeing where it crashes.
06:46:24 <_101010> Hello everyone! Sorry if it's a real stupid question, but do I need cabal separately if I install stack? I can't get SublimeText3 to work with stack.
06:46:28 <math493> :)
06:46:28 <quchen> This is because individual parts are usually small and understandable.
06:46:32 <Sornaensis> you can use ghci for limited debugging
06:46:43 <quchen> _101010: No, you do not need Cabal to install Stack.
06:46:44 <Sornaensis> it's not usually necessary
06:47:10 <quchen> I don’t know the Sublime plugin though, maybe it’s not written to be compatible with stack? :-/
06:47:36 <_101010> It's this, https://github.com/SublimeHaskell/SublimeHaskell
06:48:03 <merijn> math493: I would say "finding the right part" is usually difficult, because usually some part of the state of your program is not what you expect it to be, but it's hard to track where it changed
06:48:06 <_101010> It mentions stack, but also mentions cabal. I thought stack is all I need. Maybe I am wrong
06:48:22 <math493> merijn: I agree.
06:48:32 <merijn> math493: Pure functional program reduces where and how state can get changed, thus making it easier to think about your program
06:49:44 <quchen> math493: Data point. I’ve made breaking core changes to codebases with ~10% test coverage without serious problems. In Python this would be completely impossible.
06:50:11 <math493> quchen: Hm, sounds cool :)
06:50:29 <quchen> Haskell generally relies on making illegal states unrepresentable in your program. Python takes the approach to test all programs whether they contain no illegal states.
06:50:37 <merijn> Data point about Python: 10 times in the past two days I've ran a script, waited over 15 minutes for results to get computed and...all I get was a stack trace and a "variable not defined" message
06:50:51 <quchen> The difference is that a test is easy to forget, but a compiler verification is not.
06:50:56 <lpaste> merijn pasted “No title” at http://lpaste.net/7791473864998912000
06:51:15 <merijn> ski: That's what I'm going with atm
06:52:28 <merijn> ski, quchen: Think there's anything I missed?
06:52:32 <quchen> math493: Even more importantly, some people believe tests are for wuzzies that don’t know how to code. If you come across a codebase without any tests, you’d much rather have that in Haskell than in Python ;-)
06:52:53 <quchen> (That said, those people are dangerously incompetent. Even in Haskell.)
06:53:03 <merijn> quchen: :(
06:53:04 <quchen> (That said, they exist anyway.)
06:53:13 <quchen> merijn: Hm?
06:53:13 <Sornaensis> cowboy codin'
06:53:24 <merijn> quchen: You're calling me dangerously incompetent!
06:53:37 <quchen> merijn: Am I?
06:53:49 * quchen gets his pitchfork to hunt merijn
06:54:04 <merijn> I only write tests for my GHC patches :p
06:54:21 <quchen> Sounds like you’re writing tests.
06:54:31 <merijn> Not for my non-GHC code :p
06:54:38 <quchen> Don’t ruin it.
06:54:40 <quchen> :-s
06:54:48 <ski> merijn : `x' corresponding to `env' and `i' ?
06:55:05 <merijn> ski: Yeah
06:55:16 <quchen> I even write tests in Agda, so the »type system handles this for me« does not count.
06:55:31 <quchen> test3 = 3 + 5 == 8; test3 = _
06:55:32 <quchen> :-)
06:55:37 <merijn> quchen: I don't even write tests for a lot of my non-Haskell code! :p
06:55:40 <tsahyt> it's impossible to use Data.Set.map to get from a non-empty set to an empty set, isn't it?
06:55:48 <c_wraith> Sometimes I write tests.  Like to ensure that there isn't a space leak in my anticipated use pattern.
06:55:52 <tsahyt> the smallest set you can create with it should be a singleton set
06:55:58 <tsahyt> given that the input is non-empty of course
06:56:28 <c_wraith> tsahyt: seems right to me
06:56:46 <tsahyt> good
06:56:49 <tsahyt> thanks
06:57:05 <ski> merijn : hm, perhaps use `finally' rather than `onException' (and the extra `clean')
06:57:16 <tsahyt> some parts of Data.Set turn out to be very hard to wrap into a cardinality indexed type. map, filter, partition, etc.
06:57:26 <tsahyt> anything that can do pretty much arbitrary changes to the cardinality
06:57:41 <merijn> ski: This is just copying the implementation of bracket
06:57:49 <tsahyt> as well as union and friends
06:58:00 <tsahyt> but a set module without union feels very incomplete
06:58:04 <merijn> ski: Could probabyl simplify it if it works, yes
06:58:45 <c_wraith> tsahyt: this is related to why Data.Set doesn't have a Functor instance.
06:58:54 <quchen> merijn: I admire people that don’t need tests, as long as I don’t have to touch their code or use their software. But the ability to hammer out 30ksloc without tests and get something that does *anything* is amazing.
06:59:02 <tsahyt> c_wraith: there's also mapMonotonic though. but that's rather unsafe
06:59:48 <JuanDaugherty> dangerously incompetent ftw, the armada is on it's way
07:00:10 <merijn> quchen: Only up to 13k so far ;)
07:00:52 <tsahyt> on the plus side I got some mileage out of the additional type parameter for all the findMin etc functions, which turn out to actually be partial in Data.Set
07:02:14 <xificurC> how does one turn on pragmas in a running ghci session?
07:02:44 <c_wraith> xificurC: for language extensions, use :set -XExtensionName
07:03:01 <c_wraith> xificurC: for other pragmas..  They don't really make that much sense in ghci anyway, do they?
07:04:48 <c_wraith> (I might be forgetting about something that does make sense in ghci but isn't a language pragma)
07:04:54 <joe9> any jhc users here? heard that it's code is easy to understand and I want to learn the internals.
07:06:42 <xificurC> c_wraith: thanks
07:09:17 <dfeuer> tsahyt: there are now total versions of those.
07:09:35 <dfeuer> If I'm not very much mistaken.
07:11:38 <tsahyt> dfeuer: looks like deleteFindMin and deleteFindMax do not have a total version
07:11:50 <tsahyt> I can only see lookupMin and lookupMax that return Maybe
07:12:41 <dfeuer> tsahyt: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Set.html#v:maxView
07:13:08 <tsahyt> oh right
07:14:05 <tsahyt> I should pay more attention. I even ended up wrapping those too, not even realizing that they do the same thing but safely
07:15:46 <shapr> everybody seen https://github.com/IntelLabs/flrc ?
07:18:51 <tsahyt> I guess the best that I can do for union is existential quantification with bounds on the cardinality
07:21:28 <c_wraith> shapr: is that the one they promised to open source many years ago?
07:24:13 <shapr> c_wraith: yup, research papers were published from 2012 - 2013
07:24:30 <c_wraith> I'm glad it finally was released.
07:24:54 <c_wraith> also, it looks like a backend to GHC, meaning it should handle anything GHC can (at least for supported versions of GHC..)?
07:26:44 <shapr> yeah, their own intermediate representation -> pillar and mlton in there somewhere
07:28:04 <joe9> shapr: is it easier to port?
07:28:22 <c_wraith> doubt it.
07:28:33 <c_wraith> I mean, it needs ghc as a front-end
07:28:44 <joe9> makes sense.
07:28:57 <c_wraith> So you can skip the registerized backend, but you still need a haskell compiler to bootstrap the whole thing
07:29:00 <joe9> c_wraith: any experiences with JHC?
07:32:30 <Aruro> what does flrc can do?
07:32:38 <Aruro> better than ghc
07:33:23 <c_wraith> when the papers were written, it had much faster results in a few benchmarks.
07:34:49 <Aruro> having much faster result and still depending on TONS of software it not good.
07:35:02 <Aruro> s/it/is
07:35:43 <Aruro> c c++ + ghc + mlcompiler. wow
07:35:48 <shapr> Aruro: well, it was a research compiler
07:37:10 <Aruro> fortran is still used on supercomputers
07:37:26 <Aruro> i was expecting fortran dependency too :)
07:38:44 <shapr> compilers are complicated
07:39:24 <JuanDaugherty> who knew?
07:40:02 <Aruro> sure sure. thats why 40 years ago people already wrote good compiler :)
07:40:27 <Aruro> not even good readme, why people should care about this new compiler.
07:42:05 <c_wraith> it's really more of a meta-compiler.  It's designed as a backend for many functional languages.  haskell was the testbed they used to show that it could get performance improvements over real-world comilers in some cases.
07:43:22 <Aruro> i dont think some cases actually matter in this turbulent field
07:43:35 <Aruro> either its good and big idea, or useless
07:43:51 <Aruro> they abandoned this metacompiler, so result is clear
07:44:05 <c_wraith> that seems like a very narrow viewpoint.  Worst case, it's a source of ideas for implementers of all functional languages.
07:44:05 <exio4> the results of their research might be helpful later on
07:44:06 <tsahyt> where does it say they abandoned it?
07:44:36 <tsahyt> also I can't think of a single good compiler from 40 years ago tbh
07:44:40 <tsahyt> not by modern standards
07:44:43 <Aruro> tsahyt: in readme
07:44:59 <tsahyt> 40 years ago was when C compilers were still regularly outperformed by college students with modest assembly skills
07:45:31 <Aruro> tsahyt: seems modern researches have no assembly skills :)
07:45:53 <tsahyt> as a modern researcher, no I don't. but I also don't need them, we have good compilers now
07:46:14 <tsahyt> this is going off topic though
07:47:19 <exio4> compilers are (quite often) about tradeoffs, too :)
07:48:02 <BlueShark> probably stupid question, but what does foo.bar mean in haskell
07:48:02 <BlueShark> ?
07:48:24 <tsahyt> BlueShark: do you have some context?
07:48:26 <JuanDaugherty> a c compiler would still be easily outperformed by a novice assembly coder, 
07:48:29 <c_wraith> BlueShark: all lowercase?
07:48:36 <JuanDaugherty> you just don't often hear of it
07:48:52 <BlueShark> tsahyt: no, I was looking for a generic meaning. if there's one?
07:49:01 <BlueShark> c_wraith: yes.
07:49:01 <c_wraith> BlueShark: because there are some special syntax rules around . which depend on whether there is a space preceeding it, and whether the token preceeding it is capitalized
07:49:27 <c_wraith> BlueShark: in that case, it means . was being used as a binary operator
07:49:35 <c_wraith> BlueShark: not really any different from foo+bar
07:49:35 <JuanDaugherty> and amusingly the instruction set is like fuddled now compared to the olden days like on my museum wiki page
07:50:01 <c_wraith> BlueShark: (except of course that . is a different operator from +)
07:50:29 <JuanDaugherty> ( https://en.wikipedia.org/wiki/User:Lycurgus/MoCA )
07:51:07 <yhhko> BlueShark: could be function composition
07:51:11 <Akii> isn't foo.bar just function comp..
07:51:14 <Akii> :D
07:51:16 <c_wraith> BlueShark: there is a special case with . though.  When there are no spaces around it and the token before it starts with a capital letter, it's a namespace resolution operator instead.  Foo.bar means "the value bar from the namespace Foo"
07:51:54 <yhhko> BlueShark: could be a lens-style parameter getter/setter
07:52:20 <yhhko> (which is also just function composition but that requires some discussion)
07:52:35 <Aruro> JuanDaugherty: Burroughts is very interesting company
07:55:03 <Aruro> BlueShark: u see u did not give context and people wasted time to write kilometers of options
07:55:25 <Aruro> BlueShark: hard to be clear?
07:55:48 <yhhko> Aruro: joke's on us for wasting our precious time
07:55:51 <mathk> @pl \x -> f x * 1 - f x
07:55:52 <lambdabot> liftM2 (-) f f
07:56:08 <mathk> @pl \x -> f x * (1 - f x)
07:56:08 <lambdabot> liftM2 (*) f ((-) 1 . f)
07:56:22 <Akii> actually found that interesting
07:56:26 <BlueShark> Aruro: function composition was what I was looking for. sorry about the delayed response, was busy with something.
07:56:56 <mathk> @pl \x ->  (1 - f x) * f x
07:56:57 <lambdabot> ap ((*) . (-) 1 . f) f
08:01:50 <JuanDaugherty> Aruro, yes they were
08:02:27 <JuanDaugherty> *it was/is, they bought univac
08:05:03 <nitrix> That's a lot of irccloud users joining...
08:12:04 <Philonous> Uh, is that normal?
08:12:26 <BlueShark> Philonous: No. It's a netsplit.
08:12:38 <cocreature> arguably netsplits are normal :)
08:12:41 <Philonous> Oh, netplit, ok
08:12:48 <BlueShark> https://en.wikipedia.org/wiki/Netsplit
08:13:01 <BlueShark> cocreature: uhm, not *that* normal, I believe?
08:13:47 <cocreature> BlueShark: well they don’t happen every hour but they also happen often enough that you get used to it
08:14:57 <GreySunshine> Hello! I am trying to generate my blog with Hakyll and I'm trying to create a template by substituting values into another template. My (minimal) code is here (http://lpaste.net/354556), my template is here (http://lpaste.net/354554) and this is the error that I get (http://lpaste.net/354555). What am I doing wrong? Please help!
08:40:06 <wizwizwizwiz> so is there any prospect of making a haskell-like language suitable for realtime applications?
08:40:23 <wizwizwizwiz> i suppose that would mean some rethink of lazy eval and gc
08:40:28 <lyxia> linear haskell perhaps
08:43:56 <wizwizwizwiz> i'm trying to find linear haskell and i'll i'm finding is linear algebra packages,... google fail?
08:45:35 <bodisiw> wizwizwizwiz, i think search for "linear types"
08:47:08 <joe9> wizwizwizwiz: I am reading about jhc for a similar purpose
08:48:51 <wizwizwizwiz> haha i enjoyed this quote: "weights can be either 1 or omega"
08:53:16 <dfeuer> Does modern Cabal actually work with nhc98, YHC, Hugs, HBC, Helium, JHC, LHC, or UHC?
08:54:15 <vaibhavsagar> wizwizwizwiz: http://blog.tweag.io/posts/2017-03-13-linear-types.html
08:54:33 <dcoutts> dfeuer: I'm not sure people actually test the rarer ones
08:54:51 <vaibhavsagar> I think at present you might enjoy pure11: https://github.com/pure11/pure11
08:55:09 <dfeuer> Oh, looks like nhc98 and Hugs are not actually supported....
08:55:57 <dfeuer> Looks like a bunch of cruft.
08:56:12 <jackhill> there are also DSLs embedded in Haskell for realtime work, like atom: https://hackage.haskell.org/package/atom
09:03:08 <heath> https://hackernoon.com/bayhac-2017-5ae29c196cd0
09:03:55 <ternary> What would be the effective difference between f x <$> y and do { result <- y; f x result }?
09:03:59 <ternary> They both compile, but if I use the first one, f is never actually called
09:04:37 <rightfold> They should give the same result
09:04:43 <glguy> no
09:04:45 <rightfold> No
09:04:50 <rightfold> Wait, I'm stupid
09:04:59 <cocreature> :t \f x y -> f x <$> y
09:05:00 <lambdabot> Functor f => (t -> a -> b) -> t -> f a -> f b
09:05:06 <cocreature> :t \f x y -> do result <- y; f x result
09:05:08 <lambdabot> Monad m => (t1 -> t -> m b) -> t1 -> m t -> m b
09:05:11 <cocreature> ternary: does that help?
09:05:33 <rightfold> do { result <- y; f x result } should give the same result as join (f x <$> y)
09:05:44 <glguy> You can factor out the 'f x' as 'g' and you have:    g <$> y     and    do { result <- y; g y }
09:06:15 <glguy> now you can compare g <$> y and g =<< y
09:06:49 <glguy> and    do { result <- y; g result }*
09:08:12 <ternary> cocreature: Not really, I understand that <$> works on functors, but I thought that the functor instance of a monad would work like a do block
09:08:35 <glguy> ternary: f <$> x    is like    do { y <- x; return (f y) }
09:08:46 <glguy> ternary: It's the 'return' that you were missing if you wanted them to work the same
09:09:09 <ternary> Oh duh
09:09:15 <ternary> That makes way more sense
09:09:43 <ternary> Thanks
09:17:29 <Myrl-saki> Any thoughts on `f x x` for `f x y | x == y` ?
09:24:20 <mbrock> ugh, ghc has now started to hang indefinitely while linking the program I'm developing...
09:27:47 <geekosaur> you might look at switching the linker to gold (it's probably the bfd ld currently, which copes terribly with lots of small objects)
09:29:31 <cocreature> lld might also be worth considering
09:29:45 <nshepperd> Myrl-saki: those are called non-linear patterns. the reasons against it here seem reasonably convincing to me http://code.haskell.org/~dons/haskell-1990-2000/msg04005.html
09:30:18 <mbrock> yeah, I don't know what else to try; but it's not like my program has gotten more huge, it's more that for some strange reason the link time has suddenly gone from a few seconds to ostensible infinity
09:30:33 <cocreature> mbrock: see https://www.reddit.com/r/haskell/comments/63y43y/liked_linking_3x_faster_with_gold_link_10x_faster/ and https://www.reddit.com/r/haskell/comments/63shj7/link_with_the_gold_linker_for_faster_build_times/
09:30:50 <mbrock> one time I "fixed" it by doing cabal clean and then recompiling, but that doesn't work anymore :/
09:30:52 <mbrock> thanks
09:31:31 <yaxu> If you look closely you can see the first track on this is made with Haskell https://www.youtube.com/watch?v=_OAKUlRlNF0
09:32:29 <geekosaur> bfd ld hits a knee abruptly and starts swapping, iirc. so you may well be right on the edge of what it can cope with
09:32:33 <geekosaur> ...wheeeee
09:32:36 <cocreature> yaxu: nice :)
09:34:42 <Myrl-saki> nshepperd: Aww. :C
09:37:28 <scav> Been learning Haskell for a couple of weeks now, and it just dawned on me how beautiful the language is
09:38:06 <scav> Never had an emotional reaction to a language before. Is this normal? :)
09:39:13 <freeside> haskell improved my dreams. i'm flying a lot more now, and changing the environment too.
09:39:28 <joe9> scav: it puts you through the grinder.
09:39:49 <sm> highs and lows :)
09:39:52 <nshepperd> the grinder of love
09:39:55 <scav> hehe
09:42:00 <_sras_> Is there a way to rebuild a stack project even if none of the files have changed?
09:42:29 <adamCS> _sras_: "stack clean <name of local project>"
09:43:16 <adamCS> "stack clean" will clean (and rebuild) that and all the "packages" as well.
09:43:50 <adamCS> or you could delete ".stack-work" and then it will rebuild/redownload all the dependencies as well.  I think.
09:44:12 <adamCS> start with stack clean --help
09:45:50 <sm> or stack build --force-dirty
09:46:14 <Sornaensis_> TIL intel was working on a back end for haskell written in SML
09:48:06 <scav> Sornaensis Haskell Weekly? :)
09:49:11 <mbrock> gold doesn't seem to help; moreover, while waiting, there is not even a gold process running, and in fact no process is taking much CPU or memory at all, so something strange is going on
09:51:58 <Sornaensis> scav: it was on hn
09:52:19 <scav> Oh - generally avoid that site
09:58:12 <fresheyeball> anyone know if there is a way to make ghc-mod work with a custom dist folder?
09:58:24 <fresheyeball> I like cabal configure --builddir foo
10:01:07 <Sornaensis> scav: ?
10:02:48 <mbrock> haha, sorry for the FUD, I'm just an idiot and was running a blocking command after make in a shell pipeline :(
10:02:59 <mbrock> but thanks for the gold tip ;)
10:23:28 <tsahyt> is there a way to get GHC to show the context of a typed hole? e.g. Ord t, etc
10:24:12 <tsahyt> I'm getting additional context out of a pattern match on a GADT, but it's pretty much invisible. it's there because I can make it type check but during development it'd be nice to see it
10:27:35 <nshepperd> hm, maybe you could manufacture one of those 'could not deduce <constraint>' errors
10:30:48 <lykos_> I'm trying to make some code be multithreaded, when it's currently being processed in a single thread:
10:31:46 <lykos_> moveEvals =  [(m, evaluateMove m) | m <- candidateMoves] 
10:31:53 <nshepperd> tsahyt: class Hole a where { __ :: a }
10:32:11 <nshepperd> tsahyt: use __ as a hole that also prints context :)
10:32:16 <lykos_> where I then select (effectively) the max element from the list.
10:32:25 <tsahyt> that's a creative solution
10:32:29 <lykos_> Does anyone here know of a good way to do that?
10:32:40 <lykos_> (pardon the interleaved messages)
10:33:00 <nshepperd> actually printing the context for normal holes maybe needs to be added
10:34:29 <Sornaensis> {-# LANGUAGE InformativeHoles #-}
10:34:52 <Sornaensis> or maybe SmartHoles
10:38:12 <nshepperd> -XDeepHoles
11:04:57 <joe9> is there a writeFile that uses RawFilePath instead of FilePath?
11:09:05 <pavonia> joe9: You mean with system-dependent encoding?
11:09:53 <joe9> pavonia: no
11:10:19 <pavonia> rawfilepath has writeFile :: RawFilePath -> ByteString -> IO () 
11:10:22 <geekosaur> they want a version of writeFile that uses POSIX pathname semantics instead of the String one
11:10:26 <joe9> pavonia: I wanted to check if I am missing something simple as my filename is Text and I did not want to unpack the file name before writing to it.
11:10:37 <dxtr> I postgresql-simple the recommended postgresql library?
11:10:41 <dxtr> Is*
11:10:46 <geekosaur> note that this is the *pathname* not the *content*
11:10:49 <dxtr> I find the documentation to be.. Lacking :)
11:10:57 <joe9> let me check rawfilepath. Thanks.
11:11:24 <joe9> pavonia:  exactly what I wanted. Thanks.
11:12:03 <pavonia> No problem
11:13:50 <joe9> pavonia: is there something like that which uses a Text filename and Text arguments too?
11:14:15 <geekosaur> afaik there is nothing that uses Text for filenames
11:14:24 <geekosaur> it's even less safe than the default String
11:14:44 <joe9> geekosaur: oh, ok. good to know. Thanks.
11:14:49 <geekosaur> yes, I know everyone desperately wants all unixes to redesign themselves around unicode paths
11:14:53 <geekosaur> it won't
11:16:03 <geekosaur> pathnames are ByteString and you cannot safely infer any encoding for them
11:17:51 <joe9> geekosaur: ok, Thanks.do you have any opinion on JHC btw? I am looking for a small haskell that I can port to  a different platform and that seems to be the best out there.
11:18:04 <geekosaur> jhc's effectively dead :(
11:18:46 <joe9> i understand but that is the only one I could find. the core seems to stick with Haskell 2010 and that is good enough for my purposes.
11:20:08 <geekosaur> for portability it should be pretty good. one shortcoming and I think the reason it's dead now is that there've been ongoing issues with garbage collection
11:20:39 <joe9> pavonia: as an fyi, this seems similar too.
11:20:41 <joe9> https://hackage.haskell.org/package/posix-paths-0.2.1.1/docs/System-Posix-FilePath.html
11:20:56 <joe9> pavonia:  but it does not have writeFlie
11:21:07 <joe9> just for joining the dirs and filenames
11:21:47 <joe9> geekosaur: oh, really. good to know. That is the kind of info that I want before I end up with a dead end. Thanks a lot.
11:21:59 <Tuplanolla> Path names are less than 64 alphanumerical, plus, dash, dot, at or underscore characters or you will be given a stern look.
11:22:48 <pavonia> joe9: Apparently, it's supposed to be an extension to the unix package
11:23:14 <geekosaur> actually my recollection (you probanly want to dig up the mailing list and look for details) is the original didn't really do gc, then a boehm gc was implemented, then I think some preliminary work was done on a true gc and things stalled?
11:23:49 <geekosaur> and the boehm gc was itself not fully implemented and I think a bit buggy
11:26:15 <Tuplanolla> What should I call things that aren't quite large enough to be packages? Modulets? Projectoids?
11:26:39 <glguy> Packets
11:26:51 <Cale> Letters
11:26:56 <Cale> lol
11:27:06 <joe9> geekosaur: good info. Thanks a lot. are you aware of something similar that is more active?
11:27:12 <geekosaur> isn;t that what French does :)
11:27:31 <joe9> uhc?
11:27:41 <geekosaur> no, afaik the only active haskell project is ghc, although utrecht students still hack on uhc (it's on github these days)
11:27:45 <Tuplanolla> A hypothetical package, packet, pack, p hierarchy?
11:28:02 <geekosaur> but afaik only utrecht folks care about it any more
11:28:04 <Cale> parcel
11:28:08 <rightfold> Is anyone aware of a purescript-halogen port to Haskell?
11:28:46 <joe9> I read that JHC source is easy to comprehend. that is what attracted me to it.
11:28:50 <rightfold> For GHCJS or something like GTK+
11:29:23 <geekosaur> yes, and I think one of the problems was that it would have to be redesigned completely to take proper advantage of even Boehm gc much less a true gc
11:29:25 <Cale> rightfold: Perhaps you're looking for reflex-dom?
11:29:38 <geekosaur> (re jhc)
11:29:52 <Cale> rightfold: https://github.com/reflex-frp/reflex-platform/blob/develop/README.md
11:30:22 <joe9> oh, wow. did not realize the effort involved. Thanks geekosaur.
11:32:10 <rightfold> Cale: that doesn't seem like the same model
11:33:23 <rightfold> Seems more like an FRP approach
11:33:39 <Cale> Well, it is
11:34:01 <Cale> I'm not sure what you meant by "port", and I don't actually know what halogen is about :)
11:34:23 <Cale> (beyond quickly looking it up)
11:35:48 <rightfold> Halogen is basically Elm's model except state is local and doesn't have to be propagated all the way from the top
11:36:27 <Cale> (The first thing I found about Halogen makes it look like it's trying to do FRP to some extent, though it looks similar to Elm's we-can't-decide-if-this-is-a-behaviour-or-event-Signal-thing)
11:37:29 <math493> f [] = []
11:37:29 <math493> f (x:xs) = f ys ++ [x] ++ f zs where {ys = [a | a <- xs, a <= x]; zs = [b | b <- xs, b > x]}
11:37:32 <math493> What does this do? :)
11:37:50 <Cale> it sorts a list
11:38:09 <math493> Oh. So I should be able to call it like... f [1..10]?
11:38:17 <Cale> yeah, though that would be a boring example
11:38:27 <math493> *** Exception: <interactive>:144:1-92: Non-exhaustive patterns in function f
11:38:28 <rightfold> math493: What is the type?
11:38:32 <math493> Apparently it doesn't even work
11:38:39 <Cale> math493: Where did you put it?
11:38:45 <math493> rightfold: The type of what? 
11:38:48 <rightfold> f
11:38:54 <Cale> math493: Note that if you type those lines into ghci, the second line will shadow the first
11:38:55 <math493> Cale: In GHCi
11:39:01 <math493> Cale: Oh...
11:39:01 <Cale> and you'll end up with an incomplete definition
11:39:03 <math493> That's why.
11:39:07 <math493> Semicolon?
11:39:10 <Cale> You should put the definition in a file and load it
11:39:15 <Cale> or yeah, semicolon
11:39:18 <Cale> Or :{
11:39:21 <Cale> and then the definition
11:39:23 <Cale> and then :}
11:39:30 <lyxia> sad then happy
11:39:58 <math493> Yeah, it actually sorts the sequence :)
11:40:00 <Cale> But really, you shouldn't define things at the ghci prompt for the most part :)
11:40:09 <math493> Cale: I'll try to avoid it :)
11:40:21 <kadoban> math493: It looks to be an implementation of quicksort, if that helps
11:40:22 <math493> Why does it sort? I came across it in some slides. 
11:40:34 <Cale> okay, let's look closely at these lists ys and zs
11:40:52 <Cale> ys is the list of elements a where a is selected from xs, and a is less than or equal to x
11:41:11 <math493> http://imgur.com/a/r4TyC - the slide, if you want to see it. From a MOOC
11:41:17 <Cale> that's how "ys = [a | a <- xs, a <= x]" is read
11:41:18 <math493> An archived MOOC though.
11:41:23 <math493> I'm just browsing through the material.
11:41:34 <Cale> and then zs is similarly the list of elements b from xs where b is greater than x
11:42:07 <Cale> So we know that in an eventually sorted result, x will have to occur between the elements in ys and the elements in zs
11:42:10 <math493> Cale: It seems clever, even though it might be boring for experienced Haskell programmers. I mean, it's very... concise.
11:42:17 <Cale> It's quicksort
11:42:34 <math493> Nice. Quick sort in a one-liner? Wow.
11:42:39 <Cale> (well, depending on what you consider quicksort to be -- it's not in-place)
11:42:39 <mauke> math493: what other programming languages do you know (if any)?
11:43:22 <math493> mauke: Well, some Java and Python (if Python counts as a programming language, that is). And then MATLAB and R, but they probably not count either.
11:43:24 <Cale> math493: So, yeah, we sort both ys and zs, recursively, and then stick x in between the results
11:44:04 <math493> I like that example, especially after the explanation.
11:44:05 <mauke> I don't remember how python does list concat
11:44:21 <joe9> geekosaur: if you were to guess, how much effort do you think would jhc require? atleast a few months of dedication ?
11:44:43 <Cale> math493: I don't think I ever fully understood quicksort until I saw an example much like that one
11:44:45 <math493> I guess Haskell does not have a built-in sort function?
11:44:49 <Cale> It does.
11:44:54 <Cale> There's a sort in Data.List
11:44:57 <geekosaur> how do you define built-in?
11:45:00 <Cale> which is a merge sort
11:45:06 <kosmikus> depends on what you mean by "built-in"
11:45:08 <geekosaur> the whole language is not in the Prelude
11:45:09 <Cale> Well, yeah, it's not really *built in*
11:45:13 <math493> Yeah, OK :)
11:45:17 <Cale> It's just part of the standard library
11:45:19 <geekosaur> and very little is wired into the compiler
11:45:33 <Cale> The sort in Data.List is a merge sort
11:46:05 <Cale> (which works better for linked lists than quicksort, and has a better worst case complexity)
11:46:06 <mauke> ys = [a for a in xs if a <= x]; zs = [b for b in xs if b > x]; return f(ys) + [x] + f(zs)
11:46:14 <mauke> I believe that's valid python code
11:46:20 <math493> mauke: Let me try :D
11:46:26 <geekosaur> joe9: I don't really know. I think rewiring jhc to properly support gc instead of manually managed memory allocation would be fairly significant effort (year+) but that's likely the way it should ultimately go.
11:47:08 <geekosaur> also it's unlikely to support all of ghc's extensions, and some of the harder ones to implement are very widely used (mtl relies on multiparameter typeclasses, for example)
11:47:21 <joe9> geekosaur: Thanks again.
11:47:32 <math493> mauke: What's the input list in your example?
11:47:32 <geekosaur> (well, MPTC *itself* is easy, but making them usable requires functional dependencies or type families)
11:47:43 <math493> xs?
11:47:51 <math493> I guess?
11:47:56 <mauke> math493: [x] + xs
11:48:11 <Cale> Yeah, you'd need to take apart the list which was input
11:48:25 <mauke> same as in the haskell version. but for a complete translation you'd have to check for an empty list and otherwise shift the first element off
11:48:48 <math493> mauke: So it's not *that* clean in Python :D
11:48:55 <mauke> indeed
11:48:56 <Cale> right
11:49:05 * mauke proceeds to write a perl version. heh
11:49:24 <Cale> Pattern matching is so nice to have, it's really pretty sad that more languages don't have it.
11:49:45 <math493> mauke: But you didn't really define f, did you?
11:50:01 <mauke> this is part of the definition of f
11:50:03 <fnurglewitz> Cale, heh, some languages don't even have type aliases
11:50:14 <math493> mauke: I mean, in your Python code.
11:50:20 <ertes> just today i gave guile scheme another shot as a shell replacement on systems where i'd rather not install nix+GHC
11:50:30 <fnurglewitz> (i'm not pointing my finger on you, Java)
11:50:32 <Cale> fnurglewitz: Type aliases I can live without, but algebraic types, pls
11:50:37 <joe9> geekosaur: on a slightly different note, would you recommend any other language or tool that can be lazy, pure and pattern matches? Something that can be easily ported?
11:50:40 <ertes> perhaps the most important module for me was (ice-9 match), which provides pattern matching
11:51:05 <ertes> programming without pattern-matching has become a really horrible experience for me
11:51:09 <Philonous> How well do algebraic types work without a static type system though?
11:51:15 <mauke> math493: yes, that's what I meant
11:51:25 <Cale> Philonous: Well, Erlang sort of has that...
11:51:30 <Cale> iirc
11:51:36 <ertes> Philonous: not very great, because the compiler is no longer your friend
11:51:36 <Philonous> Oh? Interesting, should look into that
11:51:48 <mauke> sub f { my ($x, @xs) = @_ or return; f(grep $_ <= $x, @xs), $x, f(grep $_ > $x, @xs) }
11:51:56 <geekosaur> joe9, I don't know of one. But it occurs to me that, depending on what you are looking for, you could also see about resuscitating Hugs (note that it's just an interpreter though) 
11:51:58 <mauke> that's actually not bad at all
11:52:05 <math493> mauke: That looks like Chinese to me :D
11:52:06 <ertes> Philonous: for example the only way to really model your application is in terms of prose or some form of pseudo-syntax
11:52:21 <Cale> Not sure if it's full algebraic data types, but it has some amount of pattern matching, which extends to picking apart cons lists, and tuples
11:52:44 <geekosaur> joe9, or, piggybacking on the other discussion going on here, any language can be made lazy by turning terms into functions, so you could think about Erlang if you're willing to compromise on purity
11:52:56 <reliability> Hi. I have a typeclass YesNo, can someone tell me what is wrong with this: instance (Integral a) => (YesNo a) where
11:53:01 <Cale> Philonous: and I believe it also has atoms which can be pattern matched against
11:53:24 <Cale> Philonous: So at the very least, you can build tuples whose first component is an atom that you match as if it were a data constructor
11:53:27 <ertes> reliability: need more information
11:53:32 <rightfold> Erlang pattern matching is pretty cool
11:53:41 <geekosaur> (or hugs could be turned into an erlang-style language with a fair amount of work. in fact I could see someone retargeting it to beam instead of its own bytecode, and suddenly you get a larger universe to play with)
11:53:44 <ski> pattern-matching in Erlang is basically the same as in Prolog (except it's *matching*, not *unification* as in Prolog. and you don't have compound terms labelled with "functors", you have tuples. still have atoms/symbols, though)
11:53:52 <rightfold> It can do stuff like dissecting bytestrings and match on equality of two parts etc
11:54:10 <ski> also, you can match on a previously instantiated variable in Erlang
11:54:16 <reliability> ertes: https://pastebin.com/UqZZSHGJ
11:54:35 <joe9> Curry seems to be the king of pattern matching though , imho.
11:54:41 <ertes> reliability: the problem with your instance is that it's an instance for *all* types
11:54:56 <ski> it's also interesting that if you instantiate a variable in all branches of a `case' (or `if' or `receive'), then you can use that variable afterwards
11:54:59 <geekosaur> reliability, the context plays no part in instance selection
11:55:16 <ertes> reliability: instance resolution is a bit counter-intuitive in that regard…  the context of the instance (the (Integral a) part) doesn't matter for instance resolution…  it is only used to constrain usage *after* resolution
11:55:18 <ski> can't match on lambdas, though
11:55:28 <geekosaur> the second instance is "instance YesNo a where" plus a use-site check to see if the selected a has an Integral instance
11:55:28 <monochrom> Philonous: Various Scheme compilers and libraries provide ADT mechanisms.
11:55:59 <ski> there's a typed scheme in Racket, iirc
11:56:02 <reliability> ok, what do you mean by instance resolution?
11:56:58 <ertes> reliability: the compiler selects an instance based on types…  this selection process is called instance resolution
11:57:04 <ertes> > "abc" <> "def"
11:57:06 <lambdabot>  "abcdef"
11:57:15 <ertes> because the arguments are lists, the list instance of Monoid is used
11:57:22 <reliability> ok
11:58:04 <ertes> reliability: in general don't write a mere variable after the class in an instance…  this is almost never the correct way to do it
11:58:19 <reliability> But, given the fact that, e.g., 1 is a an integral, couldn't the compiler figure out which function to use?
11:58:30 <monochrom> Instance selection follows the motto of "better sorry than safe".
11:59:13 <ertes> reliability: the problem with your instance is that it conflicts with your (YesNo [a]) instance
11:59:41 <math493> Does functional programming languages like Haskell have loops or do you always use things like map here?
11:59:45 <reliability> But lists are not integral, are they?
11:59:52 <ertes> reliability: yesno [5]  -- instance resolution will come up with *both* instances in this case
12:00:14 <ertes> reliability: that's correct, and that's where the fact that instance resolution does not care about context comes in
12:00:26 <geekosaur> reliability, you're still missing that the context (Integral a) doesn't matter for instance selection
12:00:29 <ertes> it will still select both instances and then complain about overlapping
12:00:35 <reliability> ok, i see
12:00:37 <monochrom> math493: I always write my own recursion and I always use things like map.
12:00:45 <rightfold> math493: A loop is a construct that executes the same code many times in a row
12:00:58 <reliability> but how do I achieve what I wanted to achieve? ;-)
12:01:17 <math493> rightfold: Yes, I know :)
12:01:22 <rightfold> math493: In Haskell you do this with recursion, or with abstractions that hide the recursion from you (such as map, traverse, cata, foldl, etc)
12:01:23 <Cale> math493: There are loops, but they are generally higher order functions :)
12:01:23 <math493> What I asked is: Does it exist in Haskell?
12:01:31 <Cale> :t forM
12:01:32 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
12:01:37 <Philonous> math493, You can implement while/for loops if you really want to, but I've never actually needed them 
12:01:46 <math493> I was just curious.
12:01:50 <Philonous> math493, It's not part of the language, but you can implement it yourself 
12:01:52 <Cale> oh, of course, this is now right off the deep end :D
12:01:59 <monochrom> Recursion exists in Haskell. Loop exists in Haskell iff loop means recursion.
12:02:17 <monochrom> To me, loop means recursion, same difference, so yes.
12:02:24 <math493> monochrom: But you can only do things recursively, not iteratively? :)
12:02:34 <monochrom> What's the difference?
12:02:51 <math493> monochrom: Well, the result is the same, but... different approaches :)
12:02:56 <rightfold> Such abstractions should be preferred over manual recursion, as they make it more difficult to introduce nonterminating loops
12:03:00 <Cale> anyway, this is a little bit general, but it takes some data structure whose elements can be traversed, and a function which, given an element of that structure, will determine which action to take, to produce some result, and will give you an action which iterates over all the elements and constructs a new data structure of the same shape as the original with the results replacing the elements
12:03:19 <monochrom> Some recursions I write are conceptually while-loops.
12:03:22 <math493> Cale: What are higher order functions? Sounds fishy :D
12:03:33 <Cale> math493: Functions which take other functions as arguments
12:03:41 <ertes> reliability: newtype NumYesNo a = NumYesNo { fromNumYesNo :: a }
12:03:41 <Cale> (e.g. the loop body)
12:03:47 <monochrom> For example foldl's code is a loop. (OK, I didn't write it.)
12:03:54 <ertes> reliability: instance (Integral a) => YesNo (NumYesNo a)
12:04:13 <math493> Cale: Hm, so how would I use a keyword like "for"? Not that I need to, but I was just wondering
12:04:20 <monochrom> Or rather, s/is/is conceptually/
12:04:21 <Cale> math493: I can write an accurate representation of C's for loop as a function in Haskell, but nobody would use it :)
12:05:11 <monochrom> There is no keyword "for". You just write recursion, or use a library function that does the recursion for you.
12:05:12 <math493> But I guess if-else-constructions exist in Haskell, right?
12:05:13 <Cale> math493: We'd write its definition recursively, of course :)
12:05:18 <Cale> Yeah
12:05:32 <Cale> (and if they didn't, well, pattern matching)
12:05:54 <monochrom> if-then-else is orthogonal to "for".
12:06:06 <math493> Cale: Can pattern matching always replace if-else-things?
12:06:14 <Cale> Yeah, it's just pattern matching against Bool
12:06:17 <ertes> math493: you may wonder how exception handling works in haskell…  1. we have first-class actions, so actions (effectful programs) are regular values, 2. we can write functions that take actions and return actions
12:06:19 <math493> Or could there be cases where it's really needed?
12:06:21 <ertes> :t finally
12:06:22 <lambdabot> IO a -> IO b -> IO a
12:06:34 <ertes> now something like 'finally', which would be a built-in construct in another language, is just a regular function
12:06:39 <Cale> You can always replace  if foo then bar else quux  with  case foo of True -> bar; False -> quux
12:06:43 <math493> ertes: Cool :)
12:06:47 <rightfold> There is if/else, however constructs like "if null xs then 0 else head xs" should be avoided as they make it difficult to move the code around due to flow-encoded assumptions
12:07:16 <ertes> math493: with this power in hand, we tend to write more domain-specific control constructs than something like a "for loop"
12:07:23 <math493> rightfold: But code like Cale showed me is OK?
12:07:25 <ertes> there is no benefit in having for-loops
12:07:42 <math493> rightfold: Like case foo of True -> bar; False -> quux
12:07:50 <math493> Or is this equally bad?
12:07:56 <monochrom> Untill and unless you consider [1..10] to be a for-loop.
12:08:03 <rightfold> math493: well you'd prefer case xs of { [] -> 0; (x : _) -> x }
12:08:23 <rightfold> So that moving the code around will break if you accidentally try to take the head without knowing the list is nonempty
12:08:35 <rightfold> It won't compile because x won't be in scope
12:08:35 <ertes> math493: the next ingredient is laziness: we can use data structures to model control at no cost
12:09:01 <ertes> math493: mapM_ print [0..]  -- this program prints all natural numbers, if you wait long enough…  it runs in constant memory
12:09:52 <math493> ertes: Haha, maybe there will be no more memory, if I wait long enough? :D
12:10:13 <ertes> math493: ok, that was a lie…  the numbers grow, of course =)
12:10:15 <Cale> Well, if you wait long enough it will eventually use all the memory on the gigantic integers
12:10:29 <Cale> (but practically, no)
12:10:33 <math493> :D
12:10:36 <ertes> but the list is pretty much non-existent…  it compiles into the tight loop you would have written by hand using a for-loop
12:10:39 <reliability> ertes: slowly but surely, it starts to make sense... ;-)
12:10:42 <reliability> ertes: thanks
12:11:30 <math493> What are some cool features of Haskell? Something which Haskell is particularly good at, which would be ugly or maybe even impossible in other languages?
12:11:49 <monochrom> Programming proves the Sapir-Whorf effect. Programmers' mind are imprisoned by their language.
12:11:56 <math493> Other languages = non-functional languages, that is
12:12:02 <ertes> math493: the type system
12:12:15 <math493> ertes: How is the type system special?
12:12:53 <math493> ertes: Is it different?
12:12:57 <Cale> math493: That's a big question... we can bite off pieces of it :)
12:13:05 <math493> :D
12:13:47 <Cale> So, starting on the shallow end, first off all we have type variables (parametric polymorphism) which is convenient to use and people use it everywhere
12:13:50 <Cale> :t map
12:13:52 <lambdabot> (a -> b) -> [a] -> [b]
12:13:56 <Athas> math493: type-system wise, higher-kinded types are unusual for Haskell.
12:13:57 <math493> I was just wondering *why* Haskell was great. I only started learning Haskell today and I went though some tutorials and examples. And from what I understand, many people really like it for its... conciseness.
12:14:08 <ertes> math493: it's expressive (if your program is correct, it can most likely be expressed in haskell), it's self-dependent (rarely needs your help in the form of type signatures), it's supportive (because the compiler has so much information about your program, it can write parts of your code), etc.
12:14:20 <monochrom> Parametric polymorphism make a difference. Suppose I provide you a function "f :: a -> a" and I keep my code secret. Still, in one test you will know what it does.
12:14:24 <Athas> math493: are you wondering why Haskell is good compared to mainstream languages, or compared to other functional languages?
12:14:39 <math493> Athas: Compared to mainstream languages like Python and Java :)
12:14:40 <Cale> math493: Actually, far more than the conciseness, I like the fact that when programs compile, with an almost unreasonably high probability, they also work
12:14:42 <monochrom> If you test with "f ()" and its answer is "()" then you know my f is as good as \x -> x.
12:14:46 <math493> I never programmed functionally before.
12:14:48 <ertes> math493: also it's a sane language…  types in haskell are for programmers, not for the compiler
12:15:24 <rightfold> math493: I use a language closely related to Haskell for my job, and when people say "if it compiles, it works", they barely lie. This is the main reason I like it so much
12:15:28 <Athas> math493: I find it very useful that you can trust the types.  When you program purely, there are no hidden effects.  A function that claims to take an integer and return a bool (or whatever) really *will do nothing else*.
12:15:41 <ertes> compare:  const :: a -> b -> a
12:15:46 <Cale> math493: I work as a web developer for Obsidian Systems, we build web applications pretty much entirely in Haskell -- with the frontend compiled to Javascript for the web by GHCJS or ARM code for mobile devices by GHC, and the backend compiled to x64 code by GHC.
12:16:00 <Cale> math493: This means we get to share code and types between our frontend and backend
12:16:08 <ertes> to: tempalte <typename A, typename B> A const_(A x, B y);
12:16:10 <ertes> *template
12:16:13 <monochrom> In fact, here is my secret code: f = fmap fix pure
12:16:23 <math493> Cale: Oh, it can also be used for web applications?
12:16:35 <Cale> I can start a refactor on the backend, or in the code shared between the two, and the type errors propagate through the backend and frontend, letting me know all the things which need updating
12:16:44 <Cale> math493: Sure. It can be used for pretty much anything.
12:16:47 <math493> Cale: I know PHP, but I really dislike it after I started learning other languages. It was my first language.
12:16:51 <monochrom> You haven't known fmap, fix, or pure, so you "don't know" what my f does. No matter. The type is a->a, so you just need one test:
12:16:56 <monochrom> > fmap fix pure ()
12:16:58 <lambdabot>  ()
12:17:05 <monochrom> Therefore fmap fix pure = id.
12:17:18 <monochrom> You don't even need other tests.
12:17:24 <Cale> math493: The one area where you kind of can't use it directly is on microarchitectures, but people still use Haskell to emit the programs to run on their microcontrollers :)
12:17:29 <rightfold> If the type is a -> a you don't even need a test
12:17:47 <ertes> @djinn a -> b -> a
12:17:47 <lambdabot> f a _ = a
12:17:49 <math493> Athas: That's a nice thing :)
12:17:50 <monochrom> I need a test. I don't know whether it comes out bottom.
12:17:51 <Cale> (i.e. one-shot compiler sort of stuff)
12:18:11 <rightfold> monochrom: meh bottom
12:18:23 <Athas> math493: it may sound like a small thing, but it means you need to keep fewer moving parts in your head when thinking about a piece of code.
12:18:30 <monochrom> And a->a is not a very real-world example.
12:18:34 <Athas> Because interfaces are simpler and more explicit.
12:18:35 <dolio> monochrom: You need two tests.
12:18:57 <monochrom> A more realistic example is a->[a]. This is something you may actually use.
12:18:57 <Cale> math493: About a month ago, a coworker and I took a web application that our team had been working on for a year for a client, and reworked the entire thing to be multi-tenant -- so you'd have a single backend serving multiple copies of the application each with their own separate, and secure database.
12:19:07 <dolio> monochrom: In Haskell, at least.
12:19:20 <monochrom> And it needs a test even if you are assured of no bottom.
12:19:22 <dolio> Wait, what am I saying. That's wrong.
12:19:31 <Cale> math493: It took us 2-3 days to do what would be a few weeks to a month or more if we didn't have the type system
12:19:36 <rightfold> monochrom: you need to test the output length, that's all :)
12:19:37 <math493> Cale: That sounds like much work :)
12:19:49 <monochrom> But if you test it and it says "f () = [(), (), ()]", then you know f is as good as \x -> [x,x,x]
12:19:57 <monochrom> Yeah.
12:20:10 <dolio> Now in that example, you need more tests.
12:20:15 <ertes> math493: not in haskell…  easy refactoring is one of the secret weapons of a haskell developer =)
12:20:21 <rightfold> All elements are the same, and the length is independent of the input 👍🏻
12:20:50 <Athas> ertes: er, except that Haskell has no refactoring tools.
12:21:01 <Athas> It's much easier to refactor in Java or C#, but it's harder to say whether the refactoring is correct.
12:21:12 <Athas> (Or maybe not even that, in most cases.)
12:21:24 <ertes> Athas: practical refactoring does not involve renaming functions
12:21:30 <monochrom> OK, right, my test does not distinguish \x -> [x,x,x] from \x -> x `seq` [x,x,x]
12:21:33 <Cale> math493: Basically, we changed a couple of basic types: the type representing a pool of connections to the database, and the type representing a user token being the main ones -- and the compiler pointed us at everything that needed to change throughout the entire system
12:21:41 <ertes> Athas: it involves more abstraction, more functionality
12:21:49 <monochrom> This one may actually benefit from testing "f undefined"
12:21:52 <ertes> so tools are useless…  the only useful tool is the compiler
12:21:54 <Athas> ertes: things like 'extract to method'-functionality?
12:22:01 <monadicDuck> %s/varName/newVarName/g
12:22:04 <monadicDuck> #refactor
12:22:06 <math493> Cale: That sounds really nice. 
12:22:11 <ertes> Athas: never needed that, honestly
12:22:14 <rightfold> Types and referential transparency are more useful refactoring tools
12:22:25 <math493> Even though the concept is a bit hard to grasp, I think it might be worth learning :)
12:22:46 <Athas> Definitely!  Haskell is the best general-purpose programming language there is.
12:22:46 <rightfold> They ensure that moving code around and deduplicating it is safe
12:23:17 <rightfold> No further knowledge about the code is required
12:23:21 <ertes> Athas: i can see how a java developer might need it, but in haskell?  that's why we love our associativity =)
12:23:57 <math493> Do you know any good "toy examples" which show some of the strengths of functional programming, which are readable for beginners?
12:23:58 <Cale> math493: So, one of the components of the type system is algebraic data types, these are types which have multiple constructors, each of which can have zero or more fields of various types, and you can pattern match on the constructors to extract the data again.
12:24:08 <monochrom> http://haskelltools.org/
12:24:08 <Tuplanolla> My primary gripe is still the memory footprint. You can't easily predict that without testing the code extensively.
12:24:17 <Athas> ertes: I don't know, there have definitely been cases where I've found the Haskell ecosystem lacking in tools, despite my code base only being medium-sized.
12:24:20 <Cale> math493: So, for example, we can have a simple enumeration:
12:24:28 <Athas> Certainly, Haskell's properties make the lack of tooling far more tolerable.
12:24:34 <Cale> data Colour = Red | Green | Blue | White | Black
12:24:55 <Cale> Or something like a record:
12:25:23 <Cale> data Employee = MkEmployee String Integer
12:25:36 <math493> What is MkEmployee here? :)
12:25:41 <monochrom> It is true that if you call "rename this thing" and "pull out that local definition" refactoring, that's quaint. But you still want a tool to do them for you.
12:25:50 <Cale> It becomes a function which takes a String and Integer, and constructs an Employee
12:26:06 <Cale> e.g.  MkEmployee "John" 110000
12:26:14 <Cale> would have type Employee
12:26:46 <Cale> These types can also be parameterised by another type:
12:26:56 <Cale> data Either a b = Left a | Right b
12:27:04 <Cale> This one has two parameters
12:27:08 <math493> And there are 5 different colours? Does that mean it wouldn't have accepted "Yellow"? :)
12:27:09 <Cale> So a value of type Either Integer String
12:27:13 <Cale> right
12:27:19 <Cale> Red :: Colour
12:27:20 <ertes> math493: i suggest that you just learn the basics…  they are easy enough to get into, before you get to the more advanced stuff
12:27:21 <Cale> etc.
12:27:27 <Cale> and those are the only values of type Colour
12:27:38 <ertes> math493: here is the definition of the Bool type:  data Bool = False | True
12:27:41 <math493> ertes: I'm trying :)
12:27:56 <Cale> Right, Bool doesn't need to be built in, because we can define it :)
12:28:05 <ertes> a value of type Bool can be in one of two shapes:  False and True
12:28:10 <math493> Cale: So no boolean exist already? :)
12:28:12 <ertes> nothing else is a Bool
12:28:14 <Squarism> ive done alot of java refactoring and one bigger in haskell - its was different nature. Where as java has extract method-or-variable/renames/introduce parameter/signature-change/pull-members - haskell constructors make it easier to do flow of control refactorings. (amatuer reflection). The haskell refactoring i did would prolly take longer in java. 
12:28:28 <geekosaur> math493, that's what the Prelude is for
12:28:29 <ertes> Cale's Colour type follows the same logic
12:28:50 <ertes> Bool exists, but it's not built into the language…  it comes with the base library
12:29:22 <Cale> So yeah, this  data Either a b = Left a | Right b
12:29:33 <Cale> If I have something of type Either Integer String
12:29:46 <Cale> that means it's either of the form  Left n  where n has type Integer
12:29:50 <math493> ertes: You created a Bool type, but how would I use this type? :)
12:29:53 <Cale> or  Right s  where s has type String
12:30:08 <ertes> @let data MyBool = MyFalse | MyTrue  deriving (Eq, Ord, Show)
12:30:09 <lambdabot>  Defined.
12:30:11 <math493> Cale: That's nice :)
12:30:18 <ertes> @let myNot MyFalse = MyTrue; myNot _ = MyFalse
12:30:19 <lambdabot>  Defined.
12:30:39 <ertes> @let boolsheet1 f = map f [MyFalse, MyTrue]
12:30:41 <lambdabot>  Defined.
12:30:47 <ertes> > boolsheet1 myNot
12:30:47 <Cale> @let myAnd MyFalse _ = MyFalse; myAnd MyTrue x = x
12:30:49 <lambdabot>  Defined.
12:30:49 <lambdabot>  [MyTrue,MyFalse]
12:31:06 <Cale> > myAnd MyFalse MyTrue
12:31:08 <lambdabot>  MyFalse
12:31:15 <Cale> > myAnd MyFalse (error "oops!")
12:31:17 <math493> Haha, I really like the lambdabot :D
12:31:17 <lambdabot>  MyFalse
12:31:23 <Cale> ^^ it short circuits!
12:31:23 <monochrom> There is something wrong with how "boolsheet" pronounces like... :)
12:31:35 <ertes> @let boolsheet2 f = map (\b -> map (f b) [MyFalse, MyTrue]) [MyFalse, MyTrue]
12:31:37 <lambdabot>  Defined.
12:31:41 <ertes> > boolsheet2 myAnd
12:31:43 <lambdabot>  [[MyFalse,MyFalse],[MyFalse,MyTrue]]
12:32:28 <math493> Why is the "deriving (Eq, Ord, Show)" part necessary?
12:32:40 <ertes> they're not, but they predefine certain functions like (==)
12:32:43 <Cale> That just makes the compiler write out a bunch of basic definitions for us
12:32:47 <ertes> > MyTrue == MyTrue
12:32:49 <lambdabot>  True
12:32:54 <math493> Nice :)
12:33:04 <math493> Otherwise, it wouldn't have been possible to compare booleans?
12:33:07 <Cale> Right
12:33:14 <ertes> it would be, but you would have to write the code yourself =)
12:33:18 <Cale> Unless we explicitly added an instance of Eq for MyBool
12:33:24 <Cale> We could instead write
12:33:28 <Cale> instance Eq MyBool where
12:33:37 <Cale>   MyTrue == MyTrue = True
12:33:46 <Cale>   MyFalse == MyFalse = True
12:33:53 <Cale>   _ == _ = False
12:34:01 <ertes> the Show instance is particularly expensive to write by hand
12:34:10 <ertes> > show [Just MyTrue, Nothing]
12:34:12 <math493> ertes: Oh, that's a hardone? :)
12:34:13 <lambdabot>  "[Just MyTrue,Nothing]"
12:34:18 <rightfold> not to mention Foldable
12:34:19 <math493> *hard one
12:34:34 <math493> Foldable? That's why you're called rightfold? :D
12:34:38 <ertes> it turns any haskell value into a readable string representation
12:34:42 <ertes> (quite literally Read-able)
12:34:43 <rightfold> rightfold is another name for foldr, which is a Haskell function
12:34:53 <ertes> > read (show True) :: Bool
12:34:55 <lambdabot>  True
12:35:01 <math493> Cool :D
12:35:19 <ertes> @let deriving instance Read MyBool
12:35:20 <lambdabot>  Defined.
12:35:28 <ertes> > read (show MyTrue) :: MyBool
12:35:31 <lambdabot>  MyTrue
12:35:41 <pikajude> does lambdabot have type applications?
12:35:42 <ertes> that was a pretty-printer/parser round-trip
12:35:50 <ertes> > id @ Integer 5
12:35:52 <lambdabot>  error:
12:35:52 <lambdabot>      Pattern syntax in expression context: id@Integer
12:35:52 <lambdabot>      Did you mean to enable TypeApplications?
12:35:56 <pikajude> nope
12:37:11 <Cale> math493: Anyway, a really important type in Haskell is of course the type of functions: if A and B are types, then A -> B is the type of functions which accept an argument of type A, and produce a result of type B
12:37:22 <Cale> math493: In Haskell, this is more meaningful than in most programming languages
12:37:31 <Cale> It really has to be a mathematical function
12:37:33 <math493> Cale: That sounds very mathematical :D
12:37:40 <ertes> math493: it *is* mathematical
12:37:52 <ertes> indeed, you can use equational reasoning in haskell, i.e. algebra
12:37:53 <Cale> i.e. if x = y then f x = f y
12:37:57 <Athas> Well, but every type is lifted, which is a little odd from a mathematical perspective...
12:38:12 <Cale> Athas: Not that odd :)
12:38:55 <Cale> math493: This makes things a lot easier to test in general
12:39:13 <math493> I see :)
12:39:18 <Cale> math493: You know that if a function produces some result in isolation, it'll produce the same result in production, when supplied with the same arguments
12:39:36 <ertes> math493: you can go as far as to set up a system of equations with some unknowns and solve for the unknowns in order to write code…  but more importantly you can reason about your code *precisely*, in terms of algebra, not in terms of loose prose
12:39:41 <math493> That's a very nice property.
12:39:58 <Cale> math493: And you know for certain that the only things which can influence the result of the function are the values of those arguments
12:40:28 <math493> What was the purpose of these boolsheet1 and boolsheet2 again? Sorry, I know that we moved on, but I was just reading up and trying things out :)
12:40:33 <ertes> math493: that's why getLine is neither a function nor a string in haskell =)
12:40:46 <math493> :)
12:40:52 <Cale> It takes a while to relearn how to program under these restrictions, but once you do, it removes a huge burden in terms of how hard you have to think in order to understand programs.
12:41:02 <merijn> ski: wrt your comment earlier about using finally, that doesn't really make sense as then I'd either 1) double mask or 2) not properly unmask, since the code is already running inside mask
12:41:13 <math493> Cale: I'm sure it will take some time, but I intend to try :)
12:41:21 <ertes> math493: boolsheet2 f = [f MyFalse MyFalse, f MyFalse MyTrue, f MyTrue MyFalse, f MyTrue MyTrue]
12:41:34 <ertes> math493: boolsheet1 f = [f MyFalse, f MyTrue]
12:41:47 <ertes> more conventionally called truth tables, but i like the word "bool sheet" =)
12:41:55 <math493> Oh, it's a truth table :)
12:42:07 <ertes> oh, boolsheet2 was wrong
12:42:18 <ertes> boolsheet2 f = [[f MyFalse MyFalse, f MyFalse MyTrue], [f MyTrue MyFalse, f MyTrue MyTrue]]
12:42:41 <math493> ertes: By the way... if I may ask, how does it know that it should use the type Bool, if Bool isn't mentioned anywhere?
12:42:55 <Cale> ertes: Type inference :)
12:43:12 <ertes> math493: what Cale said =)
12:43:18 <Cale> If you use False and True, those can only be values of type Bool
12:43:45 <math493> Hm, but we don't. We use something called MyFalse and MyTrue - for some reason? Rather than False and True.
12:43:57 <Cale> Ah, yeah, those are values of type MyBool
12:44:06 <Cale> and the compiler knows that because we declared them to be such
12:44:08 <math493> Oh :)
12:44:11 <ertes> math493: type inference goes incredibly far in haskell…  i don't expect you to understand how the following piece of code works, but it's the magic of type inference and type classes combined
12:44:26 <ertes> > sequence ["Hh", "e", "Ll", "l", "oO0"]
12:44:29 <lambdabot>  ["HeLlo","HeLlO","HeLl0","Hello","HellO","Hell0","heLlo","heLlO","heLl0","he...
12:44:49 <Cale> heh, that's less impressive before you know anything about Monad
12:45:06 <orion> Hi. Let's say I have a banking service that allows customers who are programmers to script the authorization or denial of their credit card. I want them to submit raw code to me that I will run for every transaction. What are the pros/cons of allowing them to write Haskell in a restricted Monad vs. a Fre Monad DSL?
12:45:10 <math493> :D
12:45:31 <math493> Monads, is that a functional programming concept?
12:45:33 <orion> s/Fre/Free
12:45:59 <ertes> orion: one contra is that they might write really poor code that ends up eating your resources
12:46:14 <Cale> math493: Kinda
12:46:16 <ertes> orion: also, of course, you need proper sandboxing and Safe Haskell
12:46:32 <Cale> math493: It's originally from category theory, which is a branch of mathematics, and we stole it
12:46:50 <Cale> math493: and you kind of need a language with a pretty decent type system to get any mileage out of it
12:46:57 <math493> Cale: I thought you were a mathematician? I recall that I've seen you in ##math sometimes :)
12:47:03 <ertes> math493: it's impossible to explain monads (in the context of haskell) at this point…  you really need the language basics first
12:47:06 <Cale> (basically, you need type classes and type functions)
12:47:24 <cocreature> Cale is a magician that knows basically everything
12:47:36 <Cale> math493: I'm an applied logician who spends his time writing interesting proofs of trivial propositions in an inconsistent intuitionist logic.
12:47:52 <Cale> (i.e. Haskell)
12:48:13 <math493> Cale: Logician? I think Haskell was functional, not logic? You are probably also a Prolog programmer? :)
12:48:18 <Cale> (but yeah, I have a degree in pure mathematics)
12:48:30 <Cale> Ah, maybe I should bother explaining this
12:48:30 <ertes> math493: the only useful high-level overview i can think of is: "they are rich structure we can abstract over to get many things for free"
12:48:31 <Cale> heh
12:48:34 <Sornaensis> haskell supports type level programming
12:48:44 <Sornaensis> which is technically logic programming I think
12:48:51 <Cale> math493: I mean that Haskell's type system is itself structured similarly to a logic
12:48:56 <ertes> Sornaensis: if you do it in terms of instance resolution, yeah
12:49:02 <dmiles> isnt this type system some sort of OO?
12:49:04 <ertes> but you can also do it with type families, which is rather functional
12:49:06 <math493> Cale: Yeah :)
12:49:23 * dmiles ducks
12:49:34 <orion> ertes: Let's say for sake of argument that safe guards are in place.
12:49:36 <Cale> math493: In logic, if you want to prove A -> B (i.e. "A implies B") then you start by assuming A and trying to somehow conclude B, and if you succeed, by natural deduction you have A -> B
12:49:54 <math493> My programming lecturer was offering an elective course on term rewriting. He introduced it to convince us to take his course, but it didn't really work, when he started to talk about induction :D
12:50:01 <Cale> math493: In Haskell, if you want to write a function of type A -> B, you start by assuming you have a variable x of type A, and trying to construct a term y of type B
12:50:17 <Sornaensis> what's your day job Cale if I may ask
12:50:18 <Cale> math493: and if you succeed, you can write a lambda term (\x -> y) which is a function of type A -> B
12:50:45 <Cale> Sornaensis: I work for Obsidian Systems on web applications for various clients
12:51:00 <Cale> We use (and develop) the functional reactive programming system Reflex
12:51:39 <ertes> orion: well, by giving them haskell you give them general recursion anyway…  so you need to guard against poor code quality
12:51:44 <Cale> Our web applications are pretty much 100% Haskell (with some bits of Javascript FFI thrown in here and there)
12:51:53 <Cale> (and some SQL)
12:52:02 <Sornaensis> :O
12:52:19 <Sornaensis> is reflex front end and back end?
12:52:32 <ertes> orion: also you need well written docs, because most of the customers likely won't be fluent in haskell
12:52:37 <monadicDuck> does anyone use spock + elm ?
12:52:37 <Cale> Frontend for now. I'd like to get some backend-related reflex stuff going
12:53:37 <Cale> But FRP is mostly well-suited to situations where you have a lot of complicated interactions between stateful things, and our backends are trying as far as possible to be stateless (though there is a bit of per-user state now)
12:54:00 <ertes> math493: i think what causes most people's brain to shut down is unfamiliar terminology and the associated math phobia it triggers, when in reality it's a really simple concept
12:54:04 <Cale> (well, "stateless" apart from the database ;)
12:54:13 <math493> :D
12:54:17 <ertes> math493: i bet you have been doing some form of induction in your own code without knowing =)
12:54:18 <Sornaensis> do you use warp on the back end?
12:54:41 <Cale> Sornaensis: we're using Snap on the backend, actually, we do use Warp in the mobile frontend though
12:55:12 <math493> ertes: Really? I took a discrete mathematics course, which was mandatory, and I never really mastered induction... and I don't see the connection with code at all :D
12:55:25 <Sornaensis> how does Snap compare to Yesod?
12:55:43 <Cale> It's a bunch simpler, not so much template Haskell
12:55:50 <Cale> tbh, we're barely using Snap too
12:56:01 <ertes> Sornaensis: yesod is built on black boxes, whereas snap is fairly transparent
12:56:06 <Cale> Our applications are pretty much single page things which communicate over a websocket a bunch
12:56:06 <Sornaensis> heh
12:56:11 <Sornaensis> ah
12:56:23 <Sornaensis> single page that talks to a db?
12:56:24 <math493>  > boolsheet2 myNot
12:56:26 <math493> Shouldn't this work?
12:56:27 <Cale> There's now some file streaming stuff in one of them
12:56:32 <Cale> yeah
12:56:38 <math493> > boolsheet2 myNot
12:56:41 <lambdabot>  error:
12:56:41 <lambdabot>      • Couldn't match type ‘MyBool’ with ‘MyBool -> b’
12:56:41 <lambdabot>        Expected type: MyBool -> MyBool -> b
12:56:45 <math493> lambdabot is not happy 
12:56:56 <Cale> math493: That one wants a function of two arguments
12:57:01 <Cale> :t boolsheet1
12:57:02 <lambdabot> (MyBool -> b) -> [b]
12:57:04 <Cale> :t boolsheet2
12:57:05 <lambdabot> (MyBool -> MyBool -> b) -> [[b]]
12:57:10 <math493> Oh, that's why
12:57:23 <math493> So I cannot give myNot to it?
12:57:26 <Cale> right
12:57:34 <ertes> math493: induction in general is the idea of a base case and a recursive case to cover something entirely
12:57:39 <math493> Hm, I don't think I have any function with two arguments
12:57:41 <ertes> math493: for example a list fold is inductive
12:57:45 <Cale> I defined myAnd earlier
12:57:50 <math493> Oh :)
12:57:52 <Cale> > boolsheet2 myAnd
12:57:54 <lambdabot>  [[MyFalse,MyFalse],[MyFalse,MyTrue]]
12:58:06 <Cale> myAnd MyFalse _ = MyFalse; myAnd MyTrue x = x
12:58:10 <Cale> in case you missed it :)
12:58:20 <Cale> Note that it'll shortcut when defined like this
12:58:26 <ertes> math493: induction in proofs is not really different, except that you write proofs instead of values inductively
12:58:45 <Cale> > myAnd MyFalse undefined
12:58:47 <lambdabot>  MyFalse
12:58:49 <Cale> undefined
12:58:55 <Cale> > undefined
12:58:57 <lambdabot>  *Exception: Prelude.undefined
12:59:06 <Cale> undefined produces an exception if evaluated
12:59:25 <Sornaensis> > fst (1,undefined)
12:59:28 <lambdabot>  1
12:59:43 <Cale> So we can use it to observe when the value of something would need to be evaluated
13:00:20 <math493> Is boolsheet2 f = map (\b -> map (f b) [MyFalse, MyTrue]) [MyFalse, MyTrue] identical to boolsheet2 f = [[f MyFalse MyFalse, f MyFalse MyTrue], [f MyTrue MyFalse, f MyTrue MyTrue]]?
13:00:29 <Cale> yeah
13:00:35 <Sornaensis> :t (1, undefined)
13:00:37 <lambdabot> Num t1 => (t1, t)
13:01:01 <ertes> math493: why don't you just try it? ;)
13:01:05 <orion> ertes: Sure. For the sake of this discussion, let's assume I have wonderful docs and a magical black box which can detect poor code.
13:01:17 <math493> ertes: I could of course :)
13:01:17 <ertes> @let boolsheet2' f = [[f MyFalse MyFalse, f MyFalse MyTrue], [f MyTrue MyFalse, f MyTrue MyTrue]]
13:01:18 <lambdabot>  Defined.
13:01:43 <ertes> > boolsheet2 myAnd == boolsheet2' myAnd
13:01:45 <lambdabot>  True
13:01:51 <ertes> or even…
13:01:54 <Cale> math493: So yeah, to move along with the demonstration of Haskell's type system, let's define a binary tree having values of some type a on the branch nodes
13:02:09 <ertes> @check \f -> boolsheet2 f == boolsheet2' f
13:02:10 <math493> Yeah :)
13:02:11 <lambdabot>  error:
13:02:11 <lambdabot>  • No instance for (CoArbitrary MyBool) arising from a use of ‘myquickcheck’ ...
13:02:16 <ertes> oh, of course…
13:02:21 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
13:02:35 <Cale> (and we can derive Eq, Ord, Show, etc. for this)
13:02:37 <math493> Oh, you can define trees in Haskell?
13:02:41 <Cale> yep
13:02:47 <ertes> math493: Cale just did =)
13:02:50 <Cale> So, this is our first example of recursion in a type
13:03:13 <math493> Are Branch and Tip built-in?
13:03:22 <Cale> We define them by that line
13:03:31 <Cale> That line defines three things at once
13:03:33 <math493> Oh, that's also the definition of these :)
13:03:55 <Cale> The type Tree (which is actually a type level function, taking a type of values that the tree will carry)
13:04:06 <Cale> and then two data constructors
13:04:15 <Cale> Tip :: Tree a  -- which has no arguments
13:04:24 <Cale> Branch :: a -> Tree a -> Tree a -> Tree a
13:04:46 <Cale> a function which takes a value of type a, and two subtrees
13:05:02 <ertes> math493: in words the line says:  values of type (Tree a) are either of the shape Tip or of the shape (Branch x ls rs), where x is of type 'a' and ls and rs are of type (Tree a)
13:05:12 <Cale> @let data Tree a = Tip | Branch a (Tree a) (Tree a) -- will lambdabot let me define this, or am I going to have to rename it?
13:05:13 <lambdabot>  .L.hs:167:25: error:
13:05:13 <lambdabot>      Ambiguous occurrence ‘Tree’
13:05:13 <lambdabot>      It could refer to either ‘Data.Tree.Tree’,
13:05:15 <Cale> yeah
13:05:22 <Cale> @let data BinTree a = Tip | Branch a (Tree a) (Tree a) -- will lambdabot let me define this, or am I going to have to rename it?
13:05:24 <lambdabot>  Defined.
13:05:26 <Cale> oops
13:05:27 <Cale> hah
13:05:29 <Cale> @undefine
13:05:29 <lambdabot> Undefined.
13:05:37 <Cale> @let data BinTree a = Tip | Branch a (BinTree a) (BinTree a) -- will lambdabot let me define this, or am I going to have to rename it?
13:05:38 <lambdabot>  Defined.
13:05:40 <Cale> okay
13:05:53 <Cale> heh, could've removed the comment on that last one
13:06:07 <Cale> > Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)
13:06:09 <lambdabot>  error:
13:06:09 <lambdabot>      • No instance for (Show (BinTree a0))
13:06:09 <lambdabot>          arising from a use of ‘show_M309630444005167036127282’
13:06:13 <Cale> no show yet
13:06:25 <math493> :D
13:06:25 <Cale> @let deriving instance Show a => Show (Tree a)
13:06:26 <ertes> would be nice, if lambdabot had per-user modules
13:06:27 <lambdabot>  .L.hs:162:1: error:
13:06:27 <lambdabot>      Duplicate instance declarations:
13:06:27 <lambdabot>        instance [safe] Show a => Show (Tree a) -- Defined at .L.hs:162:1
13:06:31 <Cale> @let deriving instance Show a => Show (BinTree a)
13:06:33 <lambdabot>  Defined.
13:06:44 <ertes> but as we all know…
13:06:47 <ertes> @src blah
13:06:47 <lambdabot> Source not found. Do you think like you type?
13:06:53 <ertes> lambdabot is not nice =)
13:06:54 <Sornaensis> Data.Tree.Tree.Lazy.Tree.Tree.Strict
13:06:59 <Tuplanolla> Would be nice if lambdabot even had sane imports.
13:07:01 <Cale> How can I explain to Sigyn that I'm not a spammer?
13:07:13 <Sornaensis> :list
13:07:19 <Sornaensis> @list
13:07:19 <lambdabot> What module?  Try @listmodules for some ideas.
13:07:38 <math493> Sigyn? :D
13:08:00 <Cale> My messages are tripping anti-spam measures, apparently. If I get k-lined, that'll be why.
13:08:10 <math493> Haha :D
13:08:27 <Cale> anyway, let's write some functions on this tree type
13:08:31 <merijn> Cale: What do you mean?
13:09:06 <Cale> merijn: I got a NOTICE from Sigyn saying that my actions in #haskell tripped automated anti-spam measures, but were ignored based on time in channel, and asking me to stop.
13:09:37 <merijn> Maybe ask about that in #freenode?
13:09:37 <MarcelineVQ> :>
13:09:39 <ertes> you could report that in #freenode or something
13:09:40 <math493> Is Sigyn some bot?
13:10:01 <math493> https://pastebin.com/sSmtrnCi - why does that not work? Isn't it just what Cale did here?
13:10:23 <ertes> math493: :seti -XStandaloneDeriving
13:10:31 <ertes> lambdabot has that extension enabled by default
13:10:38 <math493> ertes: Oh :)
13:11:00 <Cale> math493: You could also include the deriving as part of the data declaration, I just did it that way because I forgot tbh
13:11:01 <math493> I just wanted to try to reproduce it :)
13:11:03 <ertes> "seti" = "set for interactively written code"
13:11:08 <math493> :)
13:11:26 <ertes> nothing with extra-terrestrials
13:11:46 <Sornaensis> > System.IO.Unsafe.unsafeCoerce 'a' :: Int
13:11:48 <lambdabot>  error:
13:11:48 <lambdabot>      Not in scope: ‘System.IO.Unsafe.unsafeCoerce’
13:11:48 <lambdabot>      No module named ‘System.IO.Unsafe’ is imported.
13:12:09 <math493> Cale: Hm, so would something like data BinTree a = Tip | Branch a (BinTree a) (BinTree a) deriving instance Show a => Show (BinTree a) be OK?
13:12:21 <math493> [22:11] -Sigyn- Your actions in #haskell tripped automated anti-spam measures, but were ignored based on your time in channel; stop now, or automated action will still be taken. If you have any questions, please don't hesitate to contact a member of staff
13:12:22 <math493> Hm...
13:12:39 <ertes> Tip Branch BinTree
13:12:44 <jle`> Sornaensis: not quite the right module, even if it was allowed :)
13:13:01 <ertes> data tip branch bintree instance show
13:13:09 <mniip> too late
13:13:10 <mniip> it is gone
13:13:44 <math493> ertes: Hm, where?
13:13:55 <ertes> math493: where what?
13:14:04 <ertes> math493: i was just trying to trigger Sigyn
13:14:10 <math493> ertes: Where would I write "Tip Branch BinTree"?
13:14:11 <math493> Oh :)
13:14:12 <ski> Sigyn is a bot, yes
13:14:33 <mniip> ertes, it was /(bintree a)/
13:14:38 <Cale> Okay, staff cleared the temp patterns for #haskell, we're safe for now
13:14:45 <math493> :D
13:14:52 <ertes> but apparently Sigyn loves me…  at least more than lambdabot does =)
13:15:22 <math493> [22:11] <math493> Cale: Hm, so would something like data BinTree a = Tip | Branch a (BinTree a) (BinTree a) deriving instance Show a => Show (BinTree a) be OK?
13:15:23 <ertes> mniip: that's a weird thing to trigger it
13:15:40 <Cale> math493: data BinTree a = Tip | Branch a (BinTree a) (BinTree a) deriving (Eq, Ord, Show)
13:15:49 <mniip> ertes, it learns from live data *shrug*
13:15:50 <Cale> (or you can just put Show in there)
13:15:57 <math493> Oh :)
13:16:23 <math493> Nice :)
13:16:24 <nbro> so, tell me, what is the angriest guy in this group?
13:16:26 <ertes> the wonders of machine learning =)
13:16:39 <ertes> nbro: mauke
13:16:40 <nbro> last time there was a person that kicked me because I said I would have asked one thing in this group
13:16:43 <math493> Now we defined a binary tree? Can we use it in some way? :)
13:16:44 <nbro> and I did not even talk
13:16:46 <nbro> no
13:16:51 <Cale> math493: sure
13:16:53 <nbro> it’s not mauke
13:16:57 <nbro> there’s another
13:17:01 <nbro> but I do not remember the name
13:17:11 <nbro> completely mad person
13:17:11 * ski has noticed Sigyn accidentally three times
13:17:33 <Cale> @let treeDepth Tip = 0; treeDepth (Branch _ l r) = 1 + max (treeDepth l) (treeDepth r)
13:17:35 <lambdabot>  Defined.
13:17:51 <ertes> nbro: /query lambdabot, then type:  @where ops
13:18:29 <ertes> (don't do it in the channel, please)
13:18:31 <Cale> @let treeSum Tip = 0; treeSum (Branch x l r) = x + treeSum l + treeSum r
13:18:32 <lambdabot>  Defined.
13:18:48 <nbro> I think it was dibblego
13:18:49 <nbro> omg
13:18:50 <nbro> that guy
13:19:11 <Cale> > treeDepth (Branch 1 (Branch 2 (Branch 3 Tip Tip) Tip) (Branch 4 Tip (Branch 5 Tip Tip)))
13:19:13 <lambdabot>  3
13:19:19 <Cale> > treeSum (Branch 1 (Branch 2 (Branch 3 Tip Tip) Tip) (Branch 4 Tip (Branch 5 Tip Tip)))
13:19:21 <lambdabot>  15
13:19:53 <math493> Hm, how do I see that the depth of the tree is 3?
13:20:05 <dolio> nbro: I'm not impressed with your behavior so far this time.
13:20:15 <Cale> Well, you could try drawing a picture of it. The root node is the one labelled with 1
13:20:32 <Cale> it has a left subtree labelled 2, which has a left subtree labelled 3
13:20:34 <mniip> > treeDepth (fix $ join $ Branch ())
13:20:34 <ertes> @let treeFold _ t Tip = t; treeFold b t (BinTree x ls rs) = b x (treeFold b t ls) (treeFold b t rs)
13:20:35 <lambdabot>  .L.hs:168:15: error: Not in scope: data constructor ‘BinTree’
13:20:36 <lambdabot>  *Exception: stack overflow
13:20:37 <nbro> dolio: what?
13:20:38 <jle`> @let appendTree Tip = id; appendTree (Branch x l r) = appendTree l . (x:) . appendTree r
13:20:39 <lambdabot>  Defined.
13:20:44 <ertes> @let treeFold _ t Tip = t; treeFold b t (Branch x ls rs) = b x (treeFold b t ls) (treeFold b t rs)
13:20:45 <lambdabot>  Defined.
13:21:37 <Cale> ertes already abstracting over my recursion ;)
13:21:38 * geekosaur agrees with dolio
13:21:48 <jle`> > appendTree (Branch 1 (Branch 2 (Branch 3 Tip Tip) Tip) (Branch 4 Tip (Branch 5 Tip Tip))) []
13:21:50 <lambdabot>  [3,2,1,4,5]
13:22:07 <ertes> @let treeDepth' = treeFold (\x sl sr -> 1 + max sl sr) 0
13:22:08 <lambdabot>  Defined.
13:22:11 <geekosaur> also I just found the log in question and you had been trolling in #scala and threatened to spread it to #haskell, so popping into #haskell immediately afterward was not the wisest of ideas
13:22:23 <math493> Hm, I find it a bit hard to imagine what (Branch 1 (Branch 2 (Branch 3 Tip Tip) Tip) (Branch 4 Tip (Branch 5 Tip Tip))) would look like :)
13:22:32 <ertes> > treeDepth (Branch () (Branch () Tip Tip) Tip)
13:22:34 <lambdabot>  2
13:22:37 <ertes> > treeDepth' (Branch () (Branch () Tip Tip) Tip)
13:22:40 <lambdabot>  2
13:22:49 <Cale> math493: Well, Branch x l r means a branch node labelled x, with l and r as its left and right subtrees
13:23:16 <Cale> math493: and Tip represents an unlabelled leaf (which we're regarding as having depth 0)
13:23:27 <Cale> i.e. the empty tree
13:23:33 <math493> So (Branch 2 (Branch 3 Tip Tip) Tip) is left subtree and (Branch 4 Tip (Branch 5 Tip Tip)) is right subtree of the root?
13:23:41 <Cale> yeah
13:23:49 <math493> And these again have subtrees? :)
13:24:06 <Cale> yeah, the one labelled 2 at the root has (Branch 3 Tip Tip) as its left subtree
13:24:09 <Cale> and Tip as its right
13:24:30 <Cale> The one labelled 4 has Tip as its left subtree, and (Branch 5 Tip Tip) as its right
13:24:45 <Philonous> I have an API-design question: I'm working on a function in a dbus package that returns values received via dbus. Is it better to just return the unmarshalled values (and leave conversion to the user), convert according to a type class (which mean type annotations are sometimes necessary) or convert to a fixed set of Haskell types (arbitrary and makes it less convenient to marshal other types)
13:25:00 <math493> Cale: I only have Paint to draw, so it's not pretty, but does it look like this? http://imgur.com/a/lwivB
13:25:46 <merijn> Philonous: Why not combine options? Implement option 1) raw unmarshalled values and implement a convenience type class based one on top of that?
13:25:48 <Cale> math493: sort of, but depending on how you're drawing tips, it should look a little different
13:26:24 <math493> Is a tip what we usually call a leaf?
13:26:29 <Philonous> merijn, I guess that makes sense. It's what I have now
13:26:42 <ski> a tip is like a leaf, but without a value
13:27:59 <Philonous> The one I'm using most myself is a combination of the type class and a newtype + type family that fixes the return types (so no type annotations), I just have to write "R val <- call «...»" all the time (but that's better than having to write types)
13:28:42 <ertes> Philonous: the aeson library does something similar:  provide a type for generic JSON values (Value), parse into that, then provide type classes to go from that to other haskell types and back
13:29:28 <Cale> math493: http://cale.hn.org/share/tree.png
13:29:31 <Cale> math493: yeah
13:29:49 <ertes> Philonous: and instances can be written using generics, so it's pretty much completely automatic, if you want it to be
13:29:51 <Cale> math493: Though usually I'll use the word "Leaf" when there's actually data there too
13:30:09 <math493> Cale: Oh :)
13:30:09 <Philonous> ertes, I have TH that generates instances
13:30:27 <math493> Cale: More pretty than this: http://imgur.com/a/9K9jF (that would have been my second guess)
13:30:31 <Cale> math493: depending on how you think about it, perhaps 3 and 5 are leaves
13:30:43 <Cale> yeah, that's right
13:30:56 <Philonous> merijn, ertes thanks
13:31:02 <ertes> Philonous: i understand your suffering, but you can always just switch to generics =)
13:31:04 <math493> But mine is not that pretty :D
13:31:13 <Cale> inkscape :D
13:31:16 <math493> :D
13:31:21 <Philonous> ertes, I actually don't mind writing TH too much
13:31:22 <nbro> @let x = [1..]
13:31:23 <lambdabot>  Defined.
13:31:28 <nbro> > x
13:31:30 <lambdabot>  error:
13:31:30 <lambdabot>      Ambiguous occurrence ‘x’
13:31:30 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
13:31:38 <Cale> > L.x
13:31:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:31:50 <math493> But what was the treeSum doing? The sum of what? Like sum [1..5]?
13:31:59 <Cale> yeah, the sum of the elements of the tree
13:32:16 <math493> Cale: These can be seen as values in the nodes?
13:32:20 <Cale> We said that treeSum Tip = 0, i.e. the sum of an empty tree is 0 (since that's the identity for addition)
13:32:36 <Cale> and then that  treeSum (Branch x l r) = x + treeSum l + treeSum r
13:32:46 <Cale> i.e. we add x to the sum of the left and right subtrees
13:32:57 <math493> That's nice :)
13:33:04 <math493> You are a great teacher.
13:33:15 <nbro> thanks!
13:33:30 <Cale> thanks!
13:33:44 <math493> :D
13:33:48 <Sornaensis> herr herr
13:34:27 <Cale> Let's take a look at the type of treeDepth and treeSum
13:34:30 <Cale> :t treeDepth
13:34:31 <lambdabot> (Num t, Ord t) => BinTree t1 -> t
13:34:49 <Cale> This was inferred by the compiler since I didn't specify it
13:34:56 <math493> [22:20] <ertes> @let treeFold _ t Tip = t; treeFold b t (Branch x ls rs) = b x (treeFold b t ls) (treeFold b t rs)
13:34:59 <math493> What was this again? :)
13:35:02 <math493> Some abstraction?
13:35:05 <Cale> Let's get to that in a moment
13:35:15 <Cale> yeah, it abstracts over the pattern in treeSum and treeDepth
13:35:21 <math493> :)
13:35:36 <Cale> Basically, it expresses the idea that we're replacing each Tip in the tree with some value t
13:35:43 <Cale> and each Branch with some function b
13:35:55 <ertes> @let treeFoldl' f s0 xs0 = treeFold (\x ls rs s'' -> let !s' = ls s''; !s = rs s' in f s x) id xs0 s0
13:35:57 <lambdabot>  Defined.
13:36:06 <ertes> :t @treeFoldl' (+) 0
13:36:07 <lambdabot> error: parse error on input ‘@’
13:36:08 <Cale> heh
13:36:09 <ertes> :t treeFoldl' (+) 0
13:36:10 <lambdabot> Num t1 => BinTree t1 -> t1
13:36:16 <Cale> Let's just start with treeFold directlyu
13:36:25 <nbro> @let lambdabot = "stupid"
13:36:26 <lambdabot>  Defined.
13:36:30 <nbro> ahah
13:36:33 <nbro> stupid bot
13:36:41 --- mode: ChanServ set +o Cale
13:36:51 <Cale> nbro: btw, you can talk to the bot in private
13:36:51 <nbro> > lambdabot
13:36:53 <lambdabot>  "stupid"
13:37:23 <nbro> Cale: yeah, I know
13:37:41 <Cale> nbro: Please try to keep your signal to noise ratio higher.
13:38:06 <Cale> anyway
13:38:15 <ertes> math493: i have a fairly long and comprehensive tutorial on list folds, if you're interested…  treeFold is pretty much the same idea, but for trees
13:38:16 <nbro> Cale: I will try to make things better in the future
13:38:20 <nbro> np
13:38:25 <nbro> or
13:38:26 <nbro> p
13:38:28 <nbro> who knows?!
13:38:34 <math493> I'll be happy to read it later :)
13:38:37 <Cale> math493: You can see that in treeSum, we're effectively replacing each Tip with 0, and the function Branch with (\x l r -> x + l + r) throughout the tree
13:38:41 <ertes> math493: it's here: http://ertes.eu/tutorial/foldr.html
13:38:46 <math493> Thanks, ertes 
13:39:06 <math493> Cale: So now the tips are turned into leaves?
13:39:32 <Cale> math493: Well, the trees are all turned into numbers
13:40:23 <Cale> math493: So, each Tip becomes the number 0, and at each Branch, instead of forming a tree, we want to add up the given value with the values from the subtrees
13:40:45 <Cale> (which will be numbers, once we do all this replacing)
13:41:05 <math493> Cale: So basically, we follow a path? From root to tip?
13:41:52 <Cale> Given a data type defined in the way we've been seeing, it's often the case that it's handy to define a function which will take replacements for each of the data constructors we introduced, and make those substitutions throughout a data structure
13:42:09 <math493> I can imagine that :)
13:42:18 <Cale> I'm going to do it a little differently from ertes, but it'll amount to the same thing:
13:42:36 * ski . o O ( algebra )
13:43:03 <Cale> ski: Well, more similar than that, I'm basically writing the same thing, just a little differently
13:43:23 <Cale> @let treeCata tip branch = g where g Tip = tip; g (Branch x l r) = branch x (g l) (g r)
13:43:24 <lambdabot>  Defined.
13:43:48 <Cale> So, this is a function which, given some values tip and branch, produces the function g
13:43:50 <merijn> Is it me or is criterion overly dramatic with it's "severely inflated" remark about variance introduced by outliers?
13:43:58 <Cale> and what g does is to replace each occurrence of Tip with tip
13:44:07 <Cale> and each occurrence of Branch with branch, throughout the whole tree
13:44:32 <merijn> I have a 129 ns average with (124.5 ns min and 134.7 ns max) and it reports variance introduced by outliers: "92% (severely inflated)"
13:44:44 <monochrom> merijn: I don't know, but keep repeating until the variance is small :)
13:44:57 <math493> Oh :)
13:45:15 <Cale> merijn: That means it's 92% higher variance than there would be if there were no outliers
13:45:19 <merijn> monochrom: Isn't that what it's supposed to do autmatically
13:45:24 <ertes> merijn: that could mean that there are almost no points near the line
13:45:37 <merijn> ertes: ?
13:45:46 <monochrom> OK I was joking.
13:45:57 <math493> Cale: What are tip and branch? Something very similar to Tip and Branch?
13:46:07 <Cale> math493: Well, they're the arguments to treeCata
13:46:09 <monochrom> But the range 124-134 doesn't look all that bad.
13:46:17 <merijn> monochrom: Hence my confusion
13:46:17 <ski> they're what we're replacing the data constructors `Tip' and `Branch' with
13:46:23 <math493> Oh, so they could be numbers?
13:46:27 <Cale> math493: So we get to plug in whatever we want there
13:46:36 <Cale> :t treeCata
13:46:37 <monochrom> May it be true that the range 124-134 does not include outliers?
13:46:37 <lambdabot> t1 -> (t -> t1 -> t1 -> t1) -> BinTree t -> t1
13:46:45 <merijn> monochrom: No idea
13:46:50 <Cale> We can choose t1 and t to be whatever types we want
13:46:59 <Cale> So, if we have a BinTree Integer, for example
13:47:01 <ski> so that `treeCata tip branch' applied to `Branch 0 (Branch 1 Tip Tip) (Branch 2 (Branch 3 Tip Tip) Tip)' will be `branch 0 (branch 1 tip tip) (branch 2 (branch 3 tip tip) tip)'
13:47:04 <Cale> and we want to add everything up
13:47:12 <Cale> We might choose t1 = Integer as well
13:47:27 <Cale> So tip would be an Integer in that case
13:47:28 <math493> Nice, it's very flexible :)
13:47:37 <Cale> and branch would be a function which takes three Integer values and somehow combines them
13:47:53 <Cale> (the value at the root, and the values obtained by collapsing the left and right subtrees in this way)
13:48:14 <ski> `branch' must be a function of type `t -> t1 -> t1 -> t1', `t' being the element type in the tree, and `t1' the "final answer" type that we'd like to get in the end. `tip' must also be of type `t1'
13:48:26 <Cale> :t treeCata Tip (\x l r -> Branch x r l)
13:48:28 <lambdabot> BinTree a -> BinTree a
13:48:41 <Cale> ^^ this function will flip a binary tree over left to right
13:48:43 <ski> @type treeCata Tip Branch
13:48:45 <lambdabot> BinTree a -> BinTree a
13:48:52 <Cale> ^^ and that one does nothing :)
13:49:03 <nbro> :) 
13:49:16 <math493> Hm, why is it interesting, if it does nothing? :D
13:49:24 <nbro> it’s inert
13:49:26 <Cale> Because it's a starting point
13:49:38 <math493> Oh, you're extending it :)
13:49:43 <Cale> for thinking about what treeCata does in general
13:49:46 <nbro> the craft of being lazy
13:50:27 <ertes> merijn: well, if your algorithm always takes 100 ns or 200 ns, then the mean will be 150 ns, and it will report "severely inflated"
13:50:33 <Cale> > treeCata Tip (\x l r -> Branch (10*x) l r) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
13:50:35 <lambdabot>  Branch 10 (Branch 20 Tip Tip) (Branch 30 Tip Tip)
13:50:40 <ertes> merijn: that's how i understand it
13:50:45 <Cale> ^^ here's an example of applying a function to all the elements in the tree
13:50:54 <merijn> ertes: I'm benchmarking messy IO stuff, so it's going to be noisy regardless
13:50:56 <math493> Cale: That's nice! :D
13:51:09 <Cale> > treeCata 0 (\x l r -> 1 + max l r) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)) -- tree depth again
13:51:12 <lambdabot>  2
13:51:25 <ski> > treeCata [] (\a l r -> a : l ++ r) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
13:51:27 <lambdabot>  [1,2,3]
13:51:40 <Cale> ^^ preorder traversal
13:51:55 <math493> [22:50] <@Cale> > treeCata Tip (\x l r -> Branch (10*x) l r) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
13:51:55 <math493> So as first argument, you just write... Tip?
13:52:01 <Cale> yeah
13:52:11 <ski> replacing the empty tree with itself
13:52:14 <math493> Cale: Because it's unmodified?
13:52:16 <Cale> yeah
13:52:17 <ski> yep
13:52:33 <math493> I really like these Haskell examples.
13:52:36 <ski> @type treeCata Tip
13:52:38 <lambdabot> (t -> BinTree a -> BinTree a -> BinTree a) -> BinTree t -> BinTree a
13:52:52 <nbro> :k treeCata
13:52:54 <lambdabot> error: Not in scope: type variable ‘treeCata’
13:52:56 <nbro> ok
13:52:59 <mniip> :t fix (`treeCata` id)
13:53:00 <lambdabot> error:
13:53:01 <lambdabot>     • Occurs check: cannot construct the infinite type:
13:53:01 <lambdabot>         t1 ~ BinTree (t1 -> t1 -> t1) -> t1
13:53:01 <Cale> :k BinTree
13:53:03 <lambdabot> * -> *
13:53:11 <mniip> hum
13:53:31 <dfeuer> edwardk: ping
13:53:50 <ertes> @let treeAna f = go where go = maybe Tip (\(x, sl, sr) -> Branch x (go sl) (go sr)) . f
13:53:52 <lambdabot>  Defined.
13:53:55 <Cale> math493: Now, something to notice... let's drop back to a simpler example of a type
13:53:58 <Cale> :t map
13:54:00 <lambdabot> (a -> b) -> [a] -> [b]
13:54:05 <math493> Yeah :)
13:54:11 <Cale> Or indeed, we could do this for BinTree:
13:54:26 <Cale> :t (\f -> treeCata Tip (Branch . f))
13:54:27 <lambdabot> (a1 -> a) -> BinTree a1 -> BinTree a
13:54:33 <Cale> but anyway
13:54:39 <nbro> very interesting that I’m almost reaching a climax
13:54:43 <Cale> something to observe is that just based on the type
13:55:00 <mniip> :t fix . flip (flip treeCata id) x
13:55:01 <lambdabot> error:
13:55:01 <lambdabot>     Ambiguous occurrence ‘x’
13:55:01 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
13:55:02 <mniip> :t fix . flip (flip treeCata id)
13:55:03 <lambdabot> BinTree (c -> c -> c) -> c
13:55:08 <mniip> there we go
13:55:14 <Cale> We can tell that any value occurring in the resulting data structure *must* have come from applying the given function to a value which was in the input structure
13:55:22 --- mode: ChanServ set +q *!*@31.10.154.65
13:55:24 <dfeuer> Cale: what do you think? Should the Strong class have a method  lensical :: (s -> a) -> (s -> b -> t) -> p a b -> p s t ?
13:55:35 <math493> Cale: Wow, that's really nice :)
13:55:41 <Cale> dfeuer: No opinion, I've never used that class.
13:56:11 <Cale> math493: So if you write the type signature up front, the compiler almost won't let you screw up
13:56:22 <ski> > snd (treeCata (\i -> (i,Tip)) (\a i_l i_r i0 -> let (i1,l) = i_l (i0 + 1); (i2,r) = i_r i1 in (i2,Branch (i0,a) l r)) (Branch 'a' (Branch 'b' Tip Tip) (Branch 'c' Tip Tip)) 0)  -- a bit hard to follow ..
13:56:25 <lambdabot>  Branch (0,'a') (Branch (1,'b') Tip Tip) (Branch (2,'c') Tip Tip)
13:56:28 <dfeuer> Cale: me neither, but it seems like it should be; avoid the tupling, and win defaults for dimap and also the other Strong methods.
13:56:34 <Cale> You might end up writing something which transforms the structure inappropriately, but that's almost harder than doing the right thing
13:56:56 <mniip> :t fix . flip (`treeCata` Branch)
13:56:58 <mniip> theeeere we go
13:57:00 <lambdabot> BinTree a -> BinTree a
13:57:07 <Cale> dfeuer: It can be inter-defined with the existing methods, right?
13:57:13 <dfeuer> Cale: yes.
13:57:17 <Cale> dfeuer: do it then :)
13:57:29 <dfeuer> Cale: not going to be up to me! But I'll submit the PR.
13:57:30 <math493> Cale: I'm sure that's useful in larger programs :)
13:57:50 <Cale> math493: Yeah, the effect that this kind of thing can have over a large codebase is great
13:57:56 <math493> Does people also write Haskell programs, which are like... thousands of lines?
13:58:17 <Cale> Yeah, most of the projects I'm working on these days are at least a few thousand lines, if not in the tens of thousands
13:58:20 <mniip> they are always refactored to 1 line
13:58:33 <dfeuer> Cale: tens of thousands of lines of Haskell?
13:58:37 <math493> Wow :O
13:58:48 <dfeuer> That sounds ... enormous.
13:59:02 <Cale> nbro: Well, the open sourced part is basically reflex-platform for now.
13:59:03 <ski> dfeuer : hmm .. somehow reminds me of Dialectica
13:59:06 <monochrom> But 1000 lines of Haskell may very well replace 5000 lines of other languages.
13:59:15 <dfeuer> ski: what be that?
13:59:38 <Cale> One thing we're doing for a client is intended to become a competitor to Slack with a bunch of additional features
14:00:01 <Cale> like integration with email (you can send an email from a channel and replies to the email will return to that channel)
14:00:02 <ski> dfeuer : <https://en.wikipedia.org/wiki/Dialectica_space>
14:00:29 <monochrom> Also bear in mind that Cale's employer has been operating for a few years. It got to build up that much code (and good code).
14:00:33 <dfeuer> ski, that be way over my 'ead.
14:00:41 <mniip> 1000 lines of haskell isn't that many really
14:00:49 <dfeuer> This is based on something phadej wrote, IIRC.
14:00:57 <dfeuer> Yes.
14:01:09 <dfeuer> BTW, is phadej here?
14:01:13 --- mode: Cale set -o Cale
14:01:27 <mniip> * [phadej] idle 34:08:59
14:01:34 <math493> [22:51] <ski> > treeCata [] (\a l r -> a : l ++ r) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)) - this was preorder traversal, right? :)
14:01:39 <Cale> yeah
14:01:42 <hexagoxel> pandoc is 48k loc judging by simple wc -l
14:01:44 <dfeuer> mniip: how discovered that you did?
14:01:52 <mniip> /whois
14:01:57 <Cale> That preorder traversal has a subtle performance problem though
14:02:03 <ski> mniip : as Cale said, yes
14:02:06 <ski> er ..
14:02:08 <ski> math493 ^
14:02:12 <Cale> The problem is that xs ++ ys takes O(length xs) steps to evaluate
14:02:23 <math493> Oh... but well, for toy examples... :)
14:02:26 <Cale> and so that will result in quadratic time, for leftward leaning trees
14:02:36 <Cale> There's a standard trick we can use to fix it though
14:02:45 <math493> Oh, it's probably simple?
14:02:57 <mniip> oh oh oh is it hughes lists
14:02:58 <math493> I mean, this is more "proof-of-concept" :)
14:02:58 <Cale> Which is, instead of producing a list of type [a], we will produce a function of type [a] -> [a]
14:03:07 <Cale> which adds elements to the beginning of any list we give it
14:03:21 <Cale> Then [] will become id (the identity function, which adds no elements)
14:03:25 <ski> instead of producing `[0,1,2]' we produce `\ns -> 0 : 1 : 2 : ns'
14:03:39 <Cale> and the one element list [x] will become (x:) -- the function which adds x to the beginning of alist
14:03:41 <Cale> a list*
14:03:55 <math493> Oh :)
14:03:55 <Cale> and lastly, and most importantly (++) will become (.) -- function composition
14:04:02 <Cale> Function composition is O(1)
14:04:23 <Cale> So this will asymptotically improve the performance, and then we can apply the resulting function to an empty list at the end
14:04:38 <math493> I see, that's nice :)
14:04:44 <Cale> :t treeCata id (\x l r -> (x:) . l . r)
14:04:46 <lambdabot> BinTree a -> [a] -> [a]
14:04:49 <Cale> :t treeCata id (\x l r -> (x:) . l . r) []
14:04:51 <lambdabot> error:
14:04:51 <lambdabot>     • Couldn't match expected type ‘BinTree a’ with actual type ‘[t0]’
14:04:51 <lambdabot>     • In the third argument of ‘treeCata’, namely ‘[]’
14:04:55 <Cale> oops
14:04:56 <Cale> right
14:05:08 <Cale> :t \t -> treeCata id (\x l r -> (x:) . l . r) t []
14:05:10 <lambdabot> BinTree a -> [a]
14:05:32 <Cale> that's pre-order
14:05:40 <Cale> :t \t -> treeCata id (\x l r -> l . (x:) . r) t []
14:05:42 <lambdabot> BinTree a -> [a]
14:05:42 <Cale> in-order
14:06:06 <mniip> preorder as in entry time order?
14:06:26 <Cale> As in, the root comes before everything else
14:06:34 <ski> as in node element listed before / to the left of elements of children
14:06:50 <mniip> never heard of this word being used in this context before
14:07:01 <Cale> pre-order, in-order, post-order
14:07:06 <math493> mniip: It's standard terminology
14:07:22 <ertes> @let testTree = > treeAna (\g' -> let (x, g) = randomR (0, 100000 :: Integer) g'; (gl, gr) = System.Random.split g in do guard (x /= 1); pure (x, gl, gr)) (mkStdGen 50)
14:07:22 <lambdabot>  Parse failed: Parse error: >
14:07:26 <ertes> @let testTree = treeAna (\g' -> let (x, g) = randomR (0, 100000 :: Integer) g'; (gl, gr) = System.Random.split g in do guard (x /= 1); pure (x, gl, gr)) (mkStdGen 50)
14:07:28 <lambdabot>  Defined.
14:07:50 <ertes> you can stop writing those long literals by hand now =)
14:07:54 <ertes> > testTree
14:07:55 <Cale> hah
14:07:56 <lambdabot>  Tip
14:07:59 <Cale> hahaha
14:08:00 <ertes> you gotta be joking…
14:08:04 <math493> Cale: What you did, was that some general pattern? You didn't do traversal of specific trees, did you?
14:08:20 <ertes> > treeAna (\g' -> let (x, g) = randomR (0, 100000 :: Integer) g'; (gl, gr) = System.Random.split g in do guard (x /= 1); pure (x, gl, gr)) (mkStdGen 100)
14:08:22 <lambdabot>  Branch 681 (Branch 78924 (Branch 31528 (Branch 79033 (Branch 23754 (Branch 5...
14:08:26 <ertes> seriously?
14:08:33 <Cale> math493: That only applied to our BinTree type that we defined earlier
14:08:55 <ertes> i picked the one seed out of 100000 that produces a Tip
14:09:06 <Cale> math493: But these ideas, like defining a function which does that substitution of constructors, tend to be often useful for many types
14:09:35 <Cale> math493: The functions I wrote will work for any BinTree though, no matter what the element type is
14:09:57 <Cale> math493: and moreover, the type signature that the compiler inferred lets us know that it doesn't fiddle with the elements at all
14:09:57 <math493> Cale: So if I wanted to do pre-order traversal of (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip)) using your functions, how would I do that? :)
14:10:21 <Cale> > (\t -> treeCata id (\x l r -> (x:) . l . r) t []) (Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip))
14:10:22 <Habib> Hey, does anyone here know how common it is to use a PaaS like Heroku for Haskell-based cloud projects?
14:10:25 <lambdabot>  [1,2,3]
14:10:34 <ski> > foldr (\n c_ns c -> c_ns (c . (n :) . c)) (\c -> c []) "abcd" id
14:10:35 <math493> Nice :)
14:10:36 <lambdabot>  "abacabadabacaba"
14:10:54 <Cale> math493: Going back to lists, foldr is the function which does this replacement of constructors for a list
14:11:11 <ertes> > take 4 . drop 8 $ foldr (\n c_ns c -> c_ns (c . (n :) . c)) (\c -> c []) "abcd" id
14:11:13 <lambdabot>  "abac"
14:11:23 <ertes> > take 4 . drop 10 $ foldr (\n c_ns c -> c_ns (c . (n :) . c)) (\c -> c []) "abcd" id
14:11:24 <ski> > foldr f z [a,b,c,d]
14:11:24 <Cale> Every list in Haskell is either the empty list [], or it is a nonempty list formed as x : xs from an initial element x and some tail xs
14:11:25 <lambdabot>  "acab"
14:11:26 <lambdabot>  f a (f b (f c (f d z)))
14:11:28 <Cale> (which is another list)
14:11:53 <Cale> foldr f z is the function which replaces each (:) in the construction of a list with f, and the [] at the end (if any) with z
14:12:09 <Cale> > foldr f z [1,2,3] -- magic
14:12:11 <lambdabot>  f 1 (f 2 (f 3 z))
14:12:13 <ski> > foldr (-) z [a,b,c,d]
14:12:15 <lambdabot>  a - (b - (c - (d - z)))
14:13:12 <Cale> (we have some magic constants in lambdabot named with single letters which have various operations defined on them to build up expression strings)
14:13:19 <math493> Cale: Would \t -> treeCata id (\x l r -> l . r . (x:)) t [] be post-order then?
14:13:23 <Cale> yep
14:13:34 <ski> > filter (`notElem` "a") (foldr (\n c_ns c -> c_ns (c . (n :) . c)) (\c -> c []) "abcd" id)
14:13:36 <lambdabot>  "bcbdbcb"
14:13:46 <Cale> you'd get all the left subtree's elements, then all the right subtree's, and then the one at the root
14:14:02 <math493> Yeah :)
14:15:16 <math493> This is really cool stuff.
14:15:34 <Cale> There are a whole bunch of other things we haven't really gotten to yet, but yeah, hopefully this gives a bit of a sense of it
14:15:56 <Cale> I wanted to give some examples involving bad implementations of map and how the compiler won't let us screw it up
14:16:09 <Cale> Supposing we get our type signature right:
14:16:14 <Cale> map :: (a -> b) -> [a] -> [b]
14:16:23 <Cale> Let's suppose we wrote
14:16:27 <Cale> map f [] = []
14:16:32 <Cale> map f (x:xs) = x : map f xs
14:16:34 <ertes> @let treeTake = flip $ treeCata (const Tip) (\x ls rs n -> if n > 0 then Branch x (ls (n - 1)) (rs (n - 1)) else Tip)
14:16:36 <lambdabot>  Defined.
14:16:44 <Cale> This function has a mistake in it
14:16:48 <Cale> We forgot to apply the function
14:17:00 <Cale> The compiler will detect this and complain:
14:17:07 <ertes> @let testTree2 = treeAna (\g' -> let (x, g) = randomR (0, 100000 :: Integer) g'; (gl, gr) = System.Random.split g in do guard (x /= 1); pure (x, gl, gr)) (mkStdGen 100)
14:17:09 <lambdabot>  Defined.
14:17:16 <ertes> > treeTake 2 testTree2
14:17:18 <lambdabot>  Branch 681 (Branch 78924 Tip Tip) (Branch 73332 Tip Tip)
14:17:25 <Cale> :t let map :: (a -> b) -> [a] -> [b]; map f [] = []; map f (x:xs) = x : map f xs in map
14:17:26 <lambdabot> error:
14:17:27 <lambdabot>     • Couldn't match type ‘b1’ with ‘a1’
14:17:27 <lambdabot>       ‘b1’ is a rigid type variable bound by
14:17:42 * ski . o O ( `treeCutDepth')
14:17:47 <Cale> not enough room to give us the whole error, but yeah
14:18:07 <math493> Cale: Hm... yeah, it's complaining at least :)
14:18:23 * ski . o O ( ".. I've got the most wonderful error message, but the margin of the channel is too small to display it" )
14:18:36 <math493> Where would I add apply to fix it?
14:18:38 <Cale> It can take a little practice to learn to read the error messages, but they really do tend to be helpful
14:18:55 <Cale> We need to apply f to x in the second case
14:19:00 <Cale> :t let map :: (a -> b) -> [a] -> [b]; map f [] = []; map f (x:xs) = f x : map f xs in map
14:19:01 <lambdabot> (a -> b) -> [a] -> [b]
14:19:06 <ertes> math493: fun fact: if you insist on writing 'map' in terms of 'foldr' there is exactly one way to get it right and one way to get it wrong =)
14:19:09 <math493> Oh, that worked :)
14:19:19 <Cale> What if, I dunno, we tried to apply the function twice?
14:19:22 <math493> ertes: Haha :D
14:19:26 <Cale> :t let map :: (a -> b) -> [a] -> [b]; map f [] = []; map f (x:xs) = f (f x) : map f xs in map
14:19:28 <lambdabot> error:
14:19:28 <lambdabot>     • Couldn't match expected type ‘a1’ with actual type ‘b1’
14:19:28 <lambdabot>       ‘b1’ is a rigid type variable bound by
14:19:31 <Cale> nope
14:19:59 <Cale> because a and b would need to be the same type for that to work, and the type signature says they're allowed to be anything, in particular they might be different
14:20:00 <ertes> math493: so in haskell by generalising you actually improve your code correctness, because the compiler will more likely catch your mistakes
14:20:16 <ertes> by generalising and abstracting
14:20:21 <math493> :)
14:20:35 <math493> I really learn something today!
14:21:29 <math493> If I may ask a question related to the bool thing, how does this definition work? myAnd MyFalse _ = MyFalse; myAnd MyTrue x = x
14:21:29 <math493> I mean, what's the logic? Is myAnd basically defined by a truth table?
14:21:52 <ertes> math493: when two arguments come in, the two clauses are matched in order
14:21:53 <ski> `x' matches any argument, and gives it that name
14:21:55 <Cale> When we apply myAnd to some arguments, it will try to match each of the patterns in turn
14:22:00 <Cale> The first one to match is the winner
14:22:11 <ertes> myAnd MyFalse MyTrue, by the first clause, is MyFalse
14:22:14 <ski> `_' matches any argument, doesn't give a name to it. often called a "wildcard" or "anonymous pattern"
14:22:19 <Cale> So, if the first argument is MyFalse, and the second argument is anything, the result is MyFalse
14:22:24 <ertes> myAnd MyTrue MyFalse, by the second clause, is MyFalse
14:22:27 <ski> ("don't care","anything goes")
14:22:28 <ertes> because myAnd MyTrue x = x
14:22:32 <ertes> for all x
14:23:02 <math493> So this says "if the first operand is false, then return false"?
14:23:02 <Cale> math493: A cool thing about this is that if the second argument would have been a lot of work to compute, we don't have to do that work
14:23:05 <ertes> whoops
14:23:07 <Cale> yeah
14:23:23 <ertes> sorry, that was non-sense
14:23:24 <math493> And the other part is considered an "else if" part?
14:23:32 <math493> myAnd MyTrue x = x
14:23:42 <Cale> You can think of it that way, sure
14:23:45 <ertes> in any case, the clauses are matched against the arguments in order, and the first match wins
14:23:59 <math493> So if the first one is True and the second one is False, then it's False.
14:24:05 <Cale> right
14:24:11 <math493> If the first one is True and the second one is True, then it's True.
14:24:15 <Cale> yep
14:24:21 * ski . o O ( annoying order dependance is annoying )
14:24:39 <math493> Basically, if True is the first one, then the result is defined to be equal to the second operand.
14:24:46 <Cale> yes
14:25:04 <Cale> @src (&&)
14:25:04 <lambdabot> True  && x = x
14:25:05 <lambdabot> False && _ = False
14:25:05 <math493> Would myOr be equally simple to write using pattern matching?
14:25:11 <Cale> sure
14:25:18 <ertes> math493: try it
14:26:38 <math493> Would this be OK?
14:26:38 <math493> myOr MyFalse MyFalse = MyFalse; myOr _ _ = MyTrue
14:26:43 <math493> > myOr MyFalse MyFalse = MyFalse; myOr _ _ = MyTrue
14:26:45 <lambdabot>  <hint>:1:22: error:
14:26:45 <lambdabot>      parse error on input ‘=’
14:26:45 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
14:26:53 <ertes> math493: it's almost fine
14:26:54 <math493> @let myOr MyFalse MyFalse = MyFalse; myOr _ _ = MyTrue
14:26:55 <lambdabot>  .L.hs:195:6: error:
14:26:55 <lambdabot>      Not in scope: data constructor ‘MyFalse’
14:26:55 <lambdabot>      Perhaps you meant ‘False’ (imported from Data.Bool)
14:27:04 <ertes> math493: it has the semantics you want, but there is one disadvantage
14:27:07 <Cale> oh, someone must have cleared the definitions
14:27:25 <Cale> @let data MyBool = MyFalse | MyTrue deriving (Eq, Ord, Show)
14:27:27 <lambdabot>  Defined.
14:27:27 <math493> Oh, then I'll just try it in my own console :)
14:27:32 <ertes> math493: if the first argument is True, then the result is True, independent of the second argument
14:27:43 <ertes> math493: ideally
14:27:53 <ertes> > myOr True undefined
14:27:55 <lambdabot>  error:
14:27:55 <lambdabot>      Variable not in scope: myOr :: Bool -> t0 -> t
14:28:04 <ertes> oh
14:28:05 <Cale> @let myOr MyFalse MyFalse = MyFalse; myOr _ _ = MyTrue
14:28:07 <lambdabot>  Defined.
14:28:09 <Cale> there :)
14:28:13 <math493> That was what I tried to express. I wanted to say "if both are false, return false, else, return true"
14:28:15 <ertes> > myOr MyTrue undefined
14:28:17 <lambdabot>  MyTrue
14:28:25 <ertes> oh =)
14:28:31 <ertes> of course
14:28:45 <Cale> That's actually kind of interesting
14:28:46 <ertes> i had a twist in my brain
14:29:02 <math493> But maybe I should have done it the other way :)
14:29:03 <Cale> I think at some point in the past, it didn't work that way :)
14:29:13 <Cale> possibly
14:29:15 <ertes> this is how i would have written it:  myOr MyTrue _ = MyTrue; myOr MyFalse x = x
14:29:28 <ertes> but it's the same thing
14:29:31 <Cale> math493: Apparently either is fine :)
14:29:49 <ertes> well, i guess GHC matches the arguments in order
14:30:17 <Cale> math493: ertes (and to be honest, myself as well), was expecting that since the first pattern given matched both arguments against a constructor, they would both be evaluated right away
14:30:17 <WarmCookie> What alternatives would be viable in a world where Haskell's parser wouldn't be whitespace sensitive?
14:30:29 <math493> Oh :)
14:30:31 <Cale> WarmCookie: semicolons and braces
14:30:34 <WarmCookie> I suspect the language would need additional syntax? What are the implications?
14:30:59 <Cale> WarmCookie: Haskell already supports semicolons and/or braces and becomes whitespace insensitive if you use them
14:31:02 <ski> no additional syntax
14:31:07 <math493> Could I also define implication and things link that?
14:31:11 <math493> *like
14:31:15 <ski> yes
14:31:17 <ertes> math493: now observe the coolness of your function…
14:31:29 <math493> ertes: Coolness how? :)
14:31:43 <math493> In what sense?
14:32:01 <WarmCookie> Cale: ski Thanks.
14:32:01 <Cale> math493: Of course -- we can define any function we like on these :)
14:32:31 <math493> Cale: But then I'd have to check the Rosen book to find the truth table - I don't remember that one :D
14:32:39 <ertes> @let toMyBool False = MyFalse; toMyBool True = MyTrue
14:32:40 <lambdabot>  Defined.
14:33:17 <math493> Or consult Wiki: https://en.wikipedia.org/wiki/Truth_table#Logical_implication
14:33:51 <math493> ertes: Is toMyBool the implication arrow? :)
14:34:11 <Cale> math493: Nah, it just converts ordinary Bool values to MyBool
14:34:19 <ertes> > foldr (\x xs -> toMyBool (even x) `myOr` xs) MyFalse (1 : [2,4..])
14:34:21 <lambdabot>  MyTrue
14:34:34 <Cale> The cool part here is that we're folding over an infinite list
14:34:41 <Cale> > 1 : [2,4..]
14:34:43 <lambdabot>  [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:34:53 <ertes> ah, wait
14:34:57 <ertes> > foldr (\x xs -> toMyBool (odd x) `myOr` xs) MyFalse (1 : [2,4..])
14:35:00 <lambdabot>  MyTrue
14:35:07 <ertes> that one is more spectacular =)
14:35:33 <math493> Cale: Jättebra! :D
14:35:52 <ertes> math493: foldr (\x xs -> toMyBool (odd x) `myOr` xs) MyFalse (1 : [2,4..]) = toMyBool (odd 1) `myOr` (toMyBool (odd 2) `myOr` (toMyBool (odd 4) `myOr` …
14:36:16 <ertes> there is one odd number in an otherwise infinite list of even numbers
14:36:27 <ertes> your function short-circuits
14:36:41 <Cale> of course, if that one odd number isn't there, it searches forever for something it will never find
14:36:42 <math493> Hm... :D
14:37:03 <ertes> > foldr (\x xs -> toMyBool (odd x) `myOr` xs) MyFalse [2,4..]
14:37:05 <lambdabot>  *Exception: stack overflow
14:37:19 <Cale> heh, that's worse than I imagined
14:37:34 <ertes> kinda odd
14:38:38 <ertes> @let myOr' False x = x; myOr' True _ = True
14:38:40 <lambdabot>  Defined.
14:38:54 <ertes> > foldr (\x xs -> odd x `myOr'` xs) False [2,4..]
14:39:00 <lambdabot>  mueval-core: Time limit exceeded
14:39:28 <ertes> @let myOr'' False False = False; myOr'' _ _ = True
14:39:30 <lambdabot>  Defined.
14:39:32 <ertes> > foldr (\x xs -> odd x `myOr''` xs) False [2,4..]
14:39:35 <lambdabot>  *Exception: stack overflow
14:39:43 <ertes> i think i see why it happens
14:40:04 <ertes> the "proper" version doesn't actually insist on pattern-matching the recursive value…  it just returns it
14:40:09 <ertes> so it's less strict after all
14:40:32 <ertes> > myOr'' True undefined
14:40:34 <lambdabot>  True
14:40:53 <ertes> this looks wrong
14:41:09 <ertes> ah, no
14:42:29 <ertes> yeah, i get it…  it builds up a stack of myOr'' invocations, because it still insists on pattern-matching on the right argument to see if it's False, in which case it returns False
14:42:42 <ertes> the proper version doesn't actually care what the second argument is at all
14:43:11 <ertes> subtle difference =)
15:02:38 <math493> But thanks a lot, especially to Cale and ertes :)
15:03:25 <math493> I'm busy saving all the examples :D
15:18:54 <math493> > instance Eq MyBool where {MyTrue == MyTrue = True; MyFalse == MyFalse = True; _ == _ = False}
15:18:56 <lambdabot>  <hint>:1:1: error: parse error on input ‘instance’
15:18:56 <math493> Shouldn't this work?
15:19:20 <ski> math493 : looks fine
15:19:51 <math493> ski: Hm, lambdabot is complaining
15:19:57 <ertes> math493: if you're trying to give that to lambdabot, instances are declarations, so you need to use @let
15:20:06 <math493> Oh
15:20:06 <glguy> math493: That's fine, it's just not OK to define instances with '>'
15:20:14 <math493> @let instance Eq MyBool where {MyTrue == MyTrue = True; MyFalse == MyFalse = True; _ == _ = False}
15:20:15 <lambdabot>  .L.hs:194:27: error:
15:20:15 <lambdabot>      • Overlapping instances for Eq MyBool
15:20:15 <lambdabot>          arising from the 'deriving' clause of a data type declaration
15:20:22 <math493> Hm...
15:20:28 <math493> @let instance Eq2 MyBool where {MyTrue == MyTrue = True; MyFalse == MyFalse = True; _ == _ = False}
15:20:29 <ertes> math493: the instance is already defined
15:20:29 <lambdabot>  .L.hs:196:10: error:
15:20:30 <lambdabot>      Not in scope: type constructor or class ‘Eq2’
15:20:30 <lambdabot>      Perhaps you meant one of these:
15:20:52 <math493> Why doesnt Eq2 work then?
15:21:10 <ski> <ertes> @let data MyBool = MyFalse | MyTrue  deriving (Eq, Ord, Show)
15:21:17 <ski> already gave you an `Eq' instance
15:21:25 <ski> there is no type class named `Eq2' in scope
15:21:51 <math493> ski: Oh, but I thought the idea was I could create my own this way :)
15:22:37 <math493> But then I have to leave out Eq in deriving?
15:22:50 <math493> The name Eq is important?
15:22:54 <math493> I cannot rename it? :)
15:23:16 <Tuplanolla> @let class Eq2 a where (===) :: a -> a -> MyBool -- Is this what you want, math493?
15:23:18 <lambdabot>  Defined.
15:23:21 <math493> I thought I could create an Eq2 instance then
15:23:38 <barrucadu> You can't make an Eq2 instance until an Eq2 class exists
15:23:48 <Tuplanolla> @let instance Eq2 MyBool where {MyTrue == MyTrue = MyTrue; MyFalse == MyFalse = MyTrue; _ == _ = MyFalse}
15:23:49 <math493> Tuplanolla: Well, this was just to learn, not something I needed to use for a specific purpose :)
15:23:50 <lambdabot>  .L.hs:203:16: error: ‘==’ is not a (visible) method of class ‘Eq2’
15:23:51 <barrucadu> Otherwise how is GHC to know what methods the class has?
15:24:03 <Tuplanolla> @let instance Eq2 MyBool where {MyTrue === MyTrue = MyTrue; MyFalse === MyFalse = MyTrue; _ === _ = MyFalse}
15:24:05 <lambdabot>  Defined.
15:24:09 <Tuplanolla> That's how it'd go, math493.
15:24:16 <math493> Thanks, Tuplanolla :)
15:25:28 <math493> I was basically trying to use Cale's code above - essentially, I just changed Eq to Eq2 :)
15:26:24 <Cale> math493: You can make your own instance of the Eq class from the Prelude, if you leave out the deriving (Eq)
15:26:57 <math493> Cale: Oh :)
15:27:24 <math493> Tuplanolla: Should it be == or ===? I guess three?
15:28:07 <Tuplanolla> The latter, math493. As shown, the other way is to make your own `Eq` class altogether.
15:28:25 <math493> OK :)
15:28:57 <math493> So unless I leave out Eq from deriving, then it would be:
15:29:06 <math493> class Eq2 a where (===) :: a -> a -> MyBool
15:29:07 <math493> instance Eq2 MyBool where {MyTrue === MyTrue = MyTrue; MyFalse === MyFalse = MyTrue; _ === _ = MyFalse}
15:30:48 <math493> How can I then use Eq2, if I want to compare with Eq?
15:31:03 <Tuplanolla> They're completely disjoint now.
15:31:10 <Tuplanolla> You could however define `instance Eq a => Eq2 a` or `instance Eq2 a => Eq a` to unify the two.
15:31:37 <math493> Disjoint in what sense?
15:31:47 <math493> They both work on MyBool, right?
15:32:03 <Tuplanolla> Yes, but they produce different types and have different implementations.
15:32:08 <math493> @let instance Eq2 a => Eq a
15:32:10 <lambdabot>  .L.hs:194:27: error:
15:32:10 <lambdabot>      • Overlapping instances for Eq MyBool
15:32:10 <lambdabot>          arising from the 'deriving' clause of a data type declaration
15:32:17 <math493> Hm...
15:32:52 <math493> I should probably just leave out Eq from deriving then :)
15:33:03 <Tuplanolla> Indeed.
15:33:50 <math493> Tuplanolla: https://pastebin.com/mUnEGqCP
15:33:52 <math493> Hm...
15:34:02 <math493> I tried:
15:34:03 <math493> Prelude> data MyBool = MyFalse | MyTrue  deriving (Ord, Show)
15:34:07 <math493> Doesn't work.
15:34:26 <glguy> Ord requires an Eq instance
15:34:33 <glguy> so if you aren't going to derive Eq, you don't get to derive Ord
15:34:56 <glguy> (or you need to do the deriving and instance declaration all in one unit
15:35:02 <math493> Oh, well... :)
15:36:46 <math493> If I just do
15:36:47 <math493> data Bool = False | True
15:36:54 <math493> Should it then be possible to say
15:37:04 <math493> instance Eq Bool where {True == True = True; False == False = True; _ == _ = False}
15:37:19 <math493> Or something like this?
15:37:33 <math493> Here I don't derive anything
15:39:43 <math493> But still not OK, apparently
15:40:19 <Cale> math493: What error are you getting? That Bool is already defined?
15:40:35 <math493> @let instance Eq Bool where {True == True = True; False == False = True; _ == _ = False}
15:40:36 <lambdabot>  .L.hs:207:10: error:
15:40:36 <lambdabot>      Duplicate instance declarations:
15:40:36 <lambdabot>        instance [safe] Eq Bool -- Defined at .L.hs:207:10
15:40:40 <Cale> math493: Try adding  import Prelude hiding (Bool(..))  to the top of your file
15:40:48 <Cale> and then you can define Bool like that
15:40:57 <Cale> the problem is that Bool already exists and has an instance of Eq
15:41:02 <Cale> So you can't write another
15:41:05 <math493> Oh.
15:41:21 <math493> So Haskell has a Bool?
15:41:26 <Cale> yep
15:42:06 <math493> Hm, no...
15:42:09 <sophiag> has anyone here tested Haskell projects with SimGrid (http://simgrid.gforge.inria.fr/) via the FFI? they have what they describe as a "legacy interface" in C, but the primary one is in C++ and i'm not sure how difficult that is to work with, having never used the FFI before.
15:42:12 <Cale> It's in the Prelude, which is a module that's automatically imported unless you explicitly turn it off with  import Prelude () <-- i.e. those parens contain a list of what to import
15:42:21 <math493> Cale: http://imgur.com/a/ynVD9
15:42:23 <ClaudiusMaximus> you need to  import qualified Prelude as P  too so you can reference P.True and P.False on the rhs of the == defn
15:42:34 <Cale> ohh
15:42:40 <Cale> You're doing this at the ghci prompt
15:42:49 <Cale> Try putting it into a file
15:42:53 <Cale> and then just load that with ghci
15:42:57 <math493> Cale: Oh, the prompt doesn't work? :D
15:43:04 <Cale> The prompt is... different
15:43:15 <Cale> It'll accept some declarations
15:43:19 <math493> I'll try with a file.
15:43:27 <Cale> But I don't know if that import Prelude hiding will work
15:43:40 <Cale> oh, right
15:43:42 <Cale> also...
15:43:47 <Cale> ClaudiusMaximus has a point
15:44:01 <Cale> (==) always results in something which is of the *Prelude's* Bool type
15:44:15 <Cale> So it might just be easier if you rename your Bool somehow
15:44:19 <Tuplanolla> Besides it won't work as expected, because `Bool` has a special standing wrt `if` and guards.
15:44:38 <Cale> It should work, there's no if-expressions
15:44:48 <Tuplanolla> I don't remember if `RebindableSyntax` changes those two.
15:44:52 <Cale> I think it does
15:45:02 <math493> Hm, maybe it's a stupid thing to do... I just wanted to try it, but anyway... :)
15:45:08 <Cale> Try
15:45:15 <Cale> data B = F | T
15:45:21 <Cale> and then make the instance of Eq for that :)
15:45:24 <math493> The file didn't work either. If I only put these three lines exactly as they were written here.
15:45:29 <Cale> right
15:45:31 <math493> I can try
15:45:37 <Cale> You'll need  import qualified Prelude as P
15:45:46 <Cale> and then P.True and P.False as the results of (==)
15:45:51 <Cale> (but not the arguments)
15:46:38 <math493> Prelude> data B = F | T
15:46:39 <math493> Prelude> instance Eq B where {T == T = T; F == F = T; _ == _ = F}
15:46:42 <math493> Shouldn't this be OK?
15:46:46 <Cale> nope
15:46:50 <Cale> because ...
15:46:53 <Cale> :t (==)
15:46:55 <lambdabot> Eq a => a -> a -> Bool
15:47:05 <math493> Oh...
15:47:06 <Cale> It results in a proper Prelude Bool
15:47:29 <Cale> If you wanted an Eq which worked with your new Bool, then you really do have to redefine the class
15:47:33 <Tuplanolla> This is why I briefly introduced `Eq2` earlier, math493.
15:48:05 <math493> OK :)
15:48:26 <math493> Anyway, I just wanted to try, since I thought it would be straightforward based on your example... :)
15:48:43 <math493> We can leave it, I think :)
15:49:13 <ClaudiusMaximus> note that Prelude.Eq is hardwired into some syntax too, like pattern matching of numeric and (overloaded) string literals
15:55:13 <math493> But thanks :)
16:01:54 <sveit> is there a function like scanl that also gives you the tail of the list? maybe i should be using a different abstraction? here is an example implementation that does what I want on lists: (\f a xs -> zip (scanl f a xs) (zipWith (flip const) (undefined:xs) $ iterate tail xs))
16:02:17 <Cale> sveit: scanl over tails xs?
16:02:23 <Cale> :t tails
16:02:25 <lambdabot> [a] -> [[a]]
16:07:03 <sveit> ok, so i implemented tails xs = (zipWith (flip const) (undefined:xs) $ iterate tail xs), which means i can now write my original function as (\f a xs -> zip (scanl f a xs) $ tails xs). is this what you meant?
16:08:12 <dmead> ?yow
16:08:12 <lambdabot> I've got a COUSIN who works in the GARMENT DISTRICT ...
16:08:25 <sveit> or (simpler?) (\f a -> zip <$> scanl f a <*> tails). can this be made more idiomatic/efficient?
16:09:57 <ClaudiusMaximus> i'd say that r-> usage is a bit confusing, at first glance i had to double-check which applicative instance it was using (i thought it might be [] which would do something completely different)
16:10:55 <ClaudiusMaximus> sveit: import Data.List (tails)   is probably better than defining it youself
16:13:53 <sveit> thanks. incidentally, if i were defining tails, is tails xs = zipWith (flip const) (undefined:xs) $ iterate tail xs a reasonable way to do it? I can see it is defined in terms of the build machinery in base, but this definition should fuse well as well since it's just using zipWith, right?
16:14:01 <orion> :hello
16:14:16 <orion> Hmm, I guess that command is disabled.
16:17:57 <c_wraith> sveit, zipWith doesn't actually fuse on the consumption side. though tails probably doesn't either. 
16:18:31 <sveit> why doesn't zipWith fuse?
16:19:14 <c_wraith> the current fusion framework doesn't handle two lists as input at the same time. 
16:20:38 <c_wraith> it's been shown basing fusion on hyperfunctions can do that, but that isn't something that's been adopted into the libraries. 
16:22:45 <sveit> so this means that when any part of the zipWith is forced, it actually allocates the whole spine?
16:24:16 <c_wraith> no.. 
16:24:20 <c_wraith> it's still lazy. 
16:24:49 <c_wraith> it just means that (:) constructors on its input lists will be allocated and pattern-matched
16:25:04 <c_wraith> fusion eliminates that. 
17:00:40 <greymalkin> Haha, I've been using `sequence` for months now and only today did the penny drop that I could use it with maybe values too.
17:00:56 <KiChjang> okay, i'm going to ask the most FAQ ever, why learn haskell?
17:01:27 <c_wraith> KiChjang, because it's different. :) 
17:01:44 <glguy> Learning Haskell is about the only way to successfully write programs in Haskell
17:02:02 <c_wraith> KiChjang, there are lots of more specific benefits, but the most important one is that it's really different. 
17:02:20 <KiChjang> hmph, i think brainfuck is very different but i don't see myself learning it
17:02:31 <c_wraith> KiChjang, do you ever feel like every language you know is a skin over the same couple ideas? 
17:02:44 <KiChjang> yeah, sort of, especially when it comes with OOP languages
17:03:19 <c_wraith> KiChjang, even brainfuck is a (minimal) skin over procedural ideas. 
17:03:33 <KiChjang> you mean haskell isn't a turing-complete language?
17:03:53 * geekosaur cannot see where you got that
17:04:03 <c_wraith> it is, but its core ideas come from lambda calculus rather than Turing machines. 
17:04:30 <c_wraith> and sure, we all know they are equivalent - but it doesn't mean that using them is the same. 
17:04:42 <pacak> KiChjang: Haskell is obviously superior to other languages.
17:04:58 <KiChjang> i had my go with OCaml before but it wasn't very pleasant
17:05:16 <KiChjang> mostly because the person i worked with had very strict coding standards and styles
17:05:43 <c_wraith> as to whether haskell is better than any other language.. that's just opinion. what isn't opinion is that haskell doesn't let you work in half-measures. you need to commit to a different approach. 
17:06:05 * KiChjang wonders if he just walked into a cult
17:06:10 <c_wraith> I'd say Prolog is a language with that same quality in a different direction. 
17:06:13 <MarcelineVQ> pacak: whether that's true or not it's a hard line to make people believe stated that way
17:06:32 <c_wraith> you can't treat prolog like it's not a logic language. 
17:06:42 <KiChjang> prolog is something i can relate with
17:06:57 <KiChjang> tried that before, the problems that it's trying to solve is definitely different than the traditional ones
17:07:10 <c_wraith> I don't know if that's a pun, but if it is, I appreciate it. :) 
17:07:27 <pacak> MarcelineVQ: I don't want to make other people to belive, only those who can understand that for themselves. It helps to avoid shitstorms like one about Foldable instance for pair recently in cafe
17:07:32 <pacak> > length (1,2)
17:07:35 <lambdabot>  1
17:08:31 <KiChjang> i've often heard haskell is like THE go-to language when it comes to FP
17:08:54 <c_wraith> KiChjang, for what it's worth, I'd say haskell is actually a usable and practical language, at least as good as most languages for most jobs. but that's opinion. :) 
17:09:16 <c_wraith> yeah, people point at haskell because you don't get back doors. 
17:09:27 <c_wraith> you have to learn the new stuff. 
17:09:51 <pacak> c_wraith: unsafeCoerce, unsafePerformIO, goto monad....
17:09:58 <KiChjang> oh no
17:09:59 <KiChjang> the M word
17:10:02 <KiChjang> what is a monad?
17:10:15 <dyreshark> it's simply a monoid in the category of endofunctors /s
17:10:18 <c_wraith> pacak, and as much as those exist, they still don't let you pretend you're not using haskell. 
17:10:24 <Tuplanolla> Does lambdabot have the burrito link?
17:10:27 <glguy> It's an abstraction that won't make sense yet if you haven't started learning Haskell, generally
17:10:41 <pacak> KiChjang: Something to describe computations and how you can compose them.
17:11:03 <c_wraith> KiChjang, Monad is a distraction. getting into the details too early will just bog you down. 
17:11:17 <glguy> Tuplanolla: hopefuly not
17:11:21 <EvanR> Monad is a type class. What's a type class? Learn haskell
17:11:21 <MarcelineVQ> @where burrito -- Tuplanolla: which one? :O
17:11:21 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
17:11:43 <Tuplanolla> The Fud one, MarcelineVQ.
17:12:18 <c_wraith> KiChjang, worrying about monad before picking up the more basic bits is like worrying about multiple inheritance before you even know what a class is. 
17:12:48 <c_wraith> Oh hey. "multiple inheritance" is also an m-word! :) 
17:13:02 <Cale> Ironically, one of the things you'll want to know about before trying to understand Monad is also named "class"
17:13:05 <EvanR> i though about "whats a class, really" earlier but didnt want to bring it up
17:13:12 <EvanR> like, in C++
17:13:27 <EvanR> that cant be a good answer to the question
17:13:40 <Cale> (but it's not the same as an OO class, it's type classes)
17:13:57 <Welkin> or javascript classes
17:14:07 <Welkin> which are just dictionaries
17:14:21 <c_wraith> KiChjang, which is not to say that monad is hard, useless, or really anything else.. there is just a knowledge base necessary before it makes sense. 
17:17:50 <c_wraith> KiChjang, and for what it's worth, all the other descriptions were correct - it's a pattern for composing certain values that has really nice properties in practice. 
17:17:56 <adamCS> KiChang:  Not sure if this is only my experience but Haskell seems to reward generalization more than some other languages.  Code gets easier to write as you try to generalize it, often clearer, and often without any penalty in performance.  But that might be true of any language that so embraces polymorphism and something like Haskell's typeclasses.
17:18:40 <EvanR> typeclasses are ok but not really the core workhorse of reusability i think
17:19:08 <KiChjang> great, i've had a couple of instances in OCaml where code gets decoupled and generalized, but the end result is confusion
17:19:10 <EvanR> they just let you use the same name for different things
17:19:28 <EvanR> (and do wild-ass type level programming, in an advanced course)
17:20:04 <KiChjang> because there are many different functions that have the same type signature but do very different things and i end up not knowing which one to use
17:20:09 <Welkin> say goodbye to your SingeltonFactoryManagerFactory :D
17:20:46 <Welkin> functions all the things
17:20:48 <bergey> Type classes also let us write code that is parametric over a subset of Haskell types.  That's great for reuse.
17:21:10 <t7> go's typesystem is better
17:21:14 <c_wraith> KiChjang, one nice thing about haskell is that as you learn the type system, you learn how types can really restrict what a function can do if used properly. it's nice, because it becomes a form of machine-checked documentation. 
17:21:26 <EvanR> its not really parametric in the sense of parametric polymorphism
17:21:34 <EvanR> its equivalent to passing in a record of functions
17:21:39 <Welkin> t7: trying to start a flamewar? Won't work here
17:21:59 <t7> just a funny joke
17:22:38 <KiChjang> so this is like going back to the drawing board again
17:22:48 <KiChjang> starting from what types are supposed to mean mathematically
17:22:53 <Welkin> t7: a funny joke would have been "javascript's type system is better"
17:23:00 <c_wraith> KiChjang, it is indeed. 
17:23:08 <EvanR> yeah, what do types mean
17:23:14 <Welkin> which is also funny because, other than the type system, javascript is a really nice language compared to almost everything else
17:23:46 <adamCS> KiChjang; (sorry I mistyped your name!).  I don't know OCaml so I can't speak to the differences.  And I agree with EvanR that typeclasses, are just a record of functions with some syntactic sugar.  But either don't always see my way to that equivalence or the syntactic sugar is strong.  Either way, Haskell imposes some discipline and grants some freedoms--like any language--but the combination works nicely for some tasks/peopl
17:23:46 <adamCS> e.
17:23:55 <adamCS> Welkin: :)
17:23:58 <Welkin> functions in functions that produce functions that ...
17:24:04 <t7> Welkin: wut
17:24:04 <Welkin> I function all the things in js
17:24:34 <EvanR> if only javascript didnt need gynastics to do concurrency, nevermind
17:24:47 <KiChjang> IIFE in JS could be quite trippy
17:24:53 <Welkin> you don't do concurrency in the browser
17:24:59 <EvanR> yes you do
17:25:02 <KiChjang> you do with web workers
17:25:04 <t7> YOU dont
17:25:04 <glguy> The merits and flaws of Go and Javascript and the other non-Haskell languages are out of scope on #haskell
17:26:59 <Gurkenglas_>  (a -> Dynamic) (Dynamic -> b)
17:27:24 <EvanR> by the power of category theory, we conclude that is impossible
17:27:33 <EvanR> since its (a -> b)
17:27:37 <Gurkenglas_> Whoops. Is there a version of Dynamic such that the question "How do I check whether two given functions of types (a -> Dynamic) and (Dynamic -> b) compose?" makes sense?
17:28:06 <abcdefg>  /part
17:28:37 <Welkin> not greyskull?
17:28:41 <glguy> Gurkenglas_: The type 'Dynamic -> b' claims to be able to handle all Dynamic values. You'd need to encode failure somehow. 'Dynamic -> Maybe b' or something
17:28:56 <geekosaur> Gurkenglas_, that works to some extent with the current version, assuming you know what a and b are in that situation
17:29:56 <geekosaur> with current Dynamic that means concrete types only. 8.2 will have type-indexed Typeable, which Dynamic is built on, but I don't know offhand how that will affect any such test
17:31:33 <geekosaur> if you don't have any idea what a and/or b are, the question is ill-formed regardless of type system
17:32:04 <Gurkenglas_> To rephrase: I want D such that each value of (a -> D) or (D -> a) produces/consumes values of only one actual type each
17:32:55 <glguy> Gurkenglas_: Then you don't want Dynamic, you need something that doesn't hide the types
17:33:59 <glguy> data T a = forall b. C (a -> b) -- stuff like this so that you know there's exactly one type that it returns
17:36:03 <glguy> The important part is that the type of the result of the function is quantified outside of the function, so we know that it doesn't depend on the argument to the function
17:42:43 <fragamus> putStr $ join $ map ( (++"o\n") . (\n->replicate n ' ') . (20+) . round  . (*20) . sin . (*0.25)) [0..]
17:43:13 <fragamus> it might be my imagination but I think this gets slower as time goes on
17:44:08 <EvanR> replicate takes longer the bigger n is, then youre appending to the end of a [Char]
17:44:38 <EvanR> but sin is bounded...
17:44:44 <fragamus> the replicate is from 0 to 40
17:44:54 <fragamus> yeah
17:45:45 <fragamus> im running it on an amazon micro so maybe im just experiencing bandwidth stuff
17:46:09 <EvanR> i changed join to concat and haha it works
17:46:13 <EvanR> sine wave!
17:46:36 <EvanR> its flickering so much it looks like double helix DNA
17:47:19 <fragamus> cool
17:47:28 <EvanR> not slowing down (ghci)
17:48:08 <Gurkengl1s_> Hmm. Can eval know what b is in order to typecheck a string at runtime?
17:48:42 <Gurkengl1s_> in the "data T a = forall b." scenario
17:48:44 <EvanR> types dont exist at runtime, but Typeable does
17:49:33 <Gurkengl1s_> kthx
17:50:20 <Gurkengl1s_> Can I restrict T to Typeable a? "data T a = forall b. Typeable b => ..."?
17:51:54 <fragamus> @EvanR does concatMap bring any improvement
17:51:54 <lambdabot> Unknown command, try @list
17:52:02 <fragamus> EvanR does concatMap bring any improvement
17:52:11 <EvanR> @src concatMap
17:52:11 <lambdabot> concatMap f = foldr ((++) . f) []
17:52:22 <Welkin> concatMap is concat . map
17:52:24 <fragamus> i guess not
17:52:36 <EvanR> i hope not, plus i dont see it needing any improvement
17:52:40 <EvanR> its friggin fast
17:54:08 <fragamus> yeah im teaching some kids to code and im setting up byobu to have lots of visually stimulating panes because this is the ADD videogame crowd 
17:54:28 <Welkin> not SUBTRACT?
17:54:46 <geekosaur> Gurkengl1s_, you can with a GADT, otherwise you want the restriction at use sites
17:54:52 <Welkin> what is byobu?
17:55:06 <fragamus> its tmux and screen 
17:55:14 <Welkin> is it a chinese version?
17:55:26 <fragamus> dunno man
18:00:45 <pacak> Welkin: japanese
18:01:05 <pacak> Welkin: 屏風
18:07:46 <LiamM> I'm seeing a few dead links for download different versions of ghc 8.0.2: e.g. https://downloads.haskell.org/~ghc/8.0.2/ghc-8.0.2-src.tar.xz
18:08:10 <LiamM> Anybody know what's  up with that?
19:15:10 <sophiag> basic (i think) question about list comprehensions... i have one like so: eval a r = [l | x <- a, y <- r, let l = ListVal (permuteList x), (fromJustAmbVal . reqAmbVal y) l] but only want permuteList called *once* for every element in a rather than once for every time elements in a and r match. i also want the guard applied to the nested lists inside the permutations rather than to the list *of* permutations. how would i achieve that?
19:16:17 <Cale> You could put a let before the y <- r
19:18:01 <Cale> [l | x <- a, let {p = permuteList x}, y <- r, let {l = ListVal p}, fromJustAmbVal . reqAmbVal y $ l]
19:18:10 <Cale> btw, what is reqAmbVal?
19:18:40 <Cale> You can put a pattern on the left of a <-
19:18:48 <Cale> and elements not matching the pattern will be discarded
19:19:14 <Cale> > [x | Right x <- [Left 1, Right "hello", Left 2, Right "there"]]
19:19:16 <lambdabot>  ["hello","there"]
19:20:06 <sophiag> reqAmbVal is a field in Require. could have been better named...
19:20:16 <Cale> ah
19:20:42 <sophiag> actually i'm going to rename it :p
19:21:11 <Cale> fromJustAmbVal sounds similar to fromJust, which is a function I usually try to avoid
19:21:24 <Cale> but its type is quite different from context
19:21:53 <sophiag> one sec...let me circle back and change some things
19:23:48 <sophiag> Cale: i'm unfamiliar with that let syntax
19:24:58 <sophiag> hmm also it still doesn't solve the problem
19:25:19 <sophiag> (meaning the first problem: multiple permutations for elements in a)
19:32:11 <sophiag> regarding the second issue it would seem i'd want something like "map (fromJustAmbVal . reqVal y) l" except that throws a type error
20:32:09 <iqubic> How are people doing?
20:56:32 <xaimus_> dl
22:05:19 <pacak> Suppose I have a typeclass StorageSize a with method size :: a -> Int, where size of Bool is 1, size of Word64 is 8 and size of ByteString is BS.length. How would you go about computing StorageSize for let's say (a, b) (generics or otherwise) if you want to have sizes for things like (Int, Int) computed at compile time?
22:06:45 <glguy> if you only want to determine the size based on the type, it's better to have size :: proxy a -> Int
22:07:08 <glguy> yes, you can use GHC.Generics to derive sizes for product types
22:08:58 <pacak> glguy: That will work for things with constant sizes but won't work with (Int, ByteString) for example
22:09:14 <glguy> right
22:09:45 <pacak> Ideally I want something to make a function that will try to calculate size for variable sized objects and add some constants
22:10:21 <pacak> But ghc compiles things like (a :: Int, b :: ByteString, c :: Int)  as (8 + length b + 8)
22:10:36 <pacak> Constants won't be folded
22:11:45 <pacak> I know how to implement that with TH, but not sure how to approach this with generics
22:12:14 <pacak> or simple monoidal compositon
22:17:02 <glguy> You have to write your generics function to arrange the terms in the way you want them arranged
22:17:28 <glguy> so if that means accumulating the "constants" in one place, you'd write a function that does that
22:18:04 <pacak> Hmm... Right, I guess that'll work.
22:18:25 <glguy> Your typeclass would need to help distinguish things that are constant from things that are not
22:18:46 <glguy> size :: a -> (Int,Int) -- (constant part, variable part)
22:19:32 <pacak> Thanks for the tip, I'll try :)
22:23:36 <athan> How do I declare an instance to overlap in GHC 8?
22:24:35 <glguy> athan: You can search for Overlapping Instance in the GHC users guide search box
22:25:04 <athan> right on :) thanks glguy 
22:25:49 <glguy> There are pragmas that you can add after the keyword instance
22:27:25 <athan> hm, it seems that declaring the most "vague" instance as {-# OVERLAPPING #-} doesn't defeat my error
22:27:48 <athan> GHC also states that the instance itself is [overlapping], so I at least applied the pragma :x
22:29:33 <glguy> The very general (vague?) instance should be OVERLAPPABLE
22:29:49 <halogenandtoast> What is the purpose of overlapping?
22:30:56 <glguy> halogenandtoast: Are you asking about the purpose of overlapping instances in general?
22:32:38 <halogenandtoast> glguy: Yes
22:33:37 <glguy> Under normal Haskell rules they aren't needed. Instances are always provided for a type constructor applied to zero or more type variables: instance SomeClass (SomeConstructor x y z...)
22:33:58 <glguy> but once you relax that you can provide instances where one is more general than the other
22:34:15 <glguy> instance SomeClass  (SomeConstructor x y z...); instance SomeClass (SomeConstructor x Char z...)
22:34:38 <glguy> where you intended for that second instance to be prefered when y is Char and to use the first otherwise
22:35:16 <glguy> Maybe you have an implementation that works for lists in general: instance C [a]
22:35:20 <glguy> but a special one for strings
22:35:26 <glguy> instance C [Char]
22:39:07 <geekosaur> this does come at a potential price though; the ghc manual points out how this can make the type system unsound
22:44:42 <halogenandtoast> glguy: Thanks, interesting
22:47:30 <sophiag> i feel a bit silly asking this, but i'm trying to debug something by breaking it down into the simplest cases and wondering why this list comprehension isn't typechecking: [l | x <- [[1,2,3],[4,5,6]], y <- [(\x -> x /= [1,2,3]), (\x -> x /= [2,1,3]),(\x -> x /= [6,5,4])], let l = permutations x, map y l]
22:48:22 <glguy> sophiag: You've got a stray 'map y l' at the end there
22:48:53 <glguy> When you have a bare expression like that in a list comprehension it needs to have type Bool
22:48:58 <sophiag> yeah, i realize that's a problem. it doesn't typecheck without it, though, so i left it because i don't understand why it's a problem
22:49:24 <sophiag> but shouldn't it be matching elements in y?
22:50:25 <sophiag> i get the same problem with, for example: [l | x <- [[1,2,3],[4,5,6]], y <- [[1,2,3],[2,1,3],[6,5,4]], let l = permutations x, l /= y]
22:50:56 <glguy> You can't compare l and y with /=, they don't have the same type
22:51:15 <glguy> :t permutations
22:51:16 <lambdabot> [a] -> [[a]]
22:51:27 <glguy> :t (/=)
22:51:28 <sophiag> could i throw in a map there tho?
22:51:29 <lambdabot> Eq a => a -> a -> Bool
22:52:40 <sophiag> shouldn't this be ok? [l | x <- [[1,2,3],[4,5,6]], y <- [[1,2,3],[2,1,3],[6,5,4]], let l = permutations x, map (/= y) l]
22:52:49 <geekosaur> no, the result is [Bool]
22:53:05 <glguy> no, map (/= y) l  doesn't have type Bool
22:53:06 <sophiag> ah ok. my intention was to apply a guard
22:53:34 <sophiag> basically to filter each of the permutations of x by the contents of y
22:53:48 <geekosaur> > [l | x <- [[1,2,3],[4,5,6]], y <- [[1,2,3],[2,1,3],[6,5,4]], l <- permutations x, l /= y]
22:53:49 <glguy> instead of map you can use any or all.
22:53:50 <lambdabot>  [[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[1,2,3],[3,2,1],[2,3,1],[3,1,2],[1,...
22:54:11 <geekosaur> hm, no
22:54:34 * geekosaur should not atempt this when half asleep
22:54:38 <sophiag> geekosaur: so that's what i was trying to get to typecheck so i could diagnose exactly that problem
22:54:38 * geekosaur slinks away
22:54:44 <glguy> To determine if one list is a permutation of another I'd recommend comparing the sorted versions of each
22:55:10 <glguy> > all (0 ==) [1..10]
22:55:12 <lambdabot>  False
22:55:17 <sophiag> glguy: no, not exactly. whether any elements in a permutation of one list are equal to boolean constaints in another
22:55:22 <glguy> > any (5 ==) [1..10]
22:55:24 <lambdabot>  True
22:56:03 <sophiag> in other words, i'd like to filter the permutations of every element in x by all the element in y
22:57:11 <sophiag> so basically my understanding is what geekosaur tried should work, yet it doesn't...
22:57:55 <sophiag> i assume maybe because it's not matching the nested lists in each l with each nested list in y?
23:00:22 <redpoppies> hi guys
23:00:43 <redpoppies> can anyone help with wreg : https://paste.gnome.org/pers66acy
23:00:48 <redpoppies> *wreq
23:00:54 <glguy> > [ permutations x \\ [[1,2,3],[2,1,3],[6,5,4]] | x <- [[1,2,3],[4,5,6]] ]
23:00:57 <lambdabot>  [[[3,2,1],[2,3,1],[3,1,2],[1,3,2]],[[4,5,6],[5,4,6],[5,6,4],[6,4,5],[4,6,5]]]
23:00:58 <redpoppies> assume a let at the beginning
23:01:26 <redpoppies> it returns an empty answer although the equivalent curl request does return what it should
23:01:41 <redpoppies> my only assumption is that payload is not properly sent
23:02:12 <cocreature> redpoppies: could you show us the exact curl request that you used?
23:02:13 <redpoppies> but that would not explain the 200 status, because vision does fail on incorrect format
23:02:49 <redpoppies> curl -v -H "Content-Type: application/json" -d @/home/adrian/Desktop/gvreq.txt https://vision.googleapis.com/v1/images:annotate?key=mykeyhere
23:02:58 <sophiag> glguy: thanks. so \\ is like a guard in list comprehensions?
23:03:06 <redpoppies> hi @cocreature, my kind of guy :)
23:03:24 <glguy> No, (x \\ y) removes the elements of y from x
23:03:51 <sophiag> oh. great
23:03:57 <glguy> http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#v:-92--92-
23:03:58 <pacak> @src (\\)
23:03:58 <lambdabot> (\\) = foldl (flip delete)
23:04:04 <sophiag> ah ok
23:04:15 <cocreature> redpoppies: what’s the content of gvreq.txt?
23:04:20 <sophiag> my actual use case is a list of lambdas i want to filter by though
23:04:33 <redpoppies> a json payload equivalent to the string in the pastebin link
23:04:56 <redpoppies> practically a base64 encoded image with some metadata
23:05:03 <cocreature> redpoppies: so then it seems like your curl request doesn’t make a multipart request?
23:05:09 <cocreature> while your wreq request does?
23:05:18 <glguy> sophiag: then it would be good to learn about any and all , which an be found on that same page
23:05:34 <redpoppies> @cocreature, no multipart on wreq either
23:05:34 <lambdabot> Unknown command, try @list
23:05:44 <glguy> redpoppies: @ is for bot commands
23:05:45 <cocreature> redpoppies: "partBS" is a multipart request
23:05:58 <sophiag> glguy: thanks. i'll play with it for a bit
23:06:00 <redpoppies> really, the docs say it adds no headers
23:06:18 <redpoppies> glguy, thanks, apologies
23:07:49 <redpoppies> cocreature, so how do i send a normal payload? i see no function
23:08:24 <cocreature> redpoppies: postWith accepts any payload that is an instance of Postable
23:08:34 <cocreature> redpoppies: that includes aeson’s Value and ByteString
23:08:47 <cocreature> so either build a Value or just use your bytestring directly
23:09:11 <redpoppies> ok, thanks, I will try that, missed it in the docs
23:09:16 <redpoppies> i will let you know
23:09:21 <cocreature> the aeson solution is probably better since you don’t need to mess around with encoding your value as json
23:09:33 <cocreature> i.e. you can’t screw up parenthesis and things like that
23:10:08 <redpoppies> cool, it works, thank you again
23:10:11 <cocreature> np
23:10:18 <redpoppies> kind of silly for me not to realize that
23:10:30 <cocreature> we all make mistakes :)
23:10:38 <redpoppies> i should be out here more often to help out too where i can
23:10:52 <redpoppies> you guys have been amazing
23:12:01 <halogenandtoast> @src (//)
23:12:01 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
23:23:38 <sophiag> glguy: it's the last function here that i'm stuck on: http://lpaste.net/354572
23:24:30 <sophiag> it always seems to return multiple permutations of each element in a for as many as are in r plus isn't actually filtering them
23:25:26 <sophiag> this is not to mention matching the Maybe Strings in each...i don't think the second to last statement is actually doing what i want. i'd rather have it be like "if ambTag x == reqTag y then ..." except i can't do that in a list comprehension
23:28:01 <orion> If I'm writing a Free Monad based DSL and I want to represent a "Plus" command which can take any Num, how would I write my AST?
23:32:00 <orion> Normally I'd write something like: data AST next = Plus Integer Integer (Integer -> next) deriving Functor -- but I want to generalize it for all Num-like types.
23:33:30 <Guest34989> hey guys how are things going with my favorite programming language...
23:33:47 <Guest34989> java!
23:35:25 <rinon> is there a haskell implementation on top of the JVM? that'd be kinda cool
23:36:00 <thimoteus> yes, look at frege
23:36:14 <cocreature> rinon: http://eta-lang.org/
23:36:19 <pacak> rinon: There is https://github.com/typelead/eta
23:38:15 <rightfold> orion: data AST n next = Plus n n (n -> next); then add a Num constraint to the interpreter
23:38:37 <rinon> cool :)
23:40:05 <orion> rightfold: Thank you.
23:40:32 <rightfold> other option would be data AST :: * -> * where Plus :: Num n => n -> n -> (n -> next) -> Plus next
23:40:42 <rightfold> But I'm not sure how usable that is
23:40:58 <rightfold> Eh that last Plus should be AST
23:41:34 <rightfold> But with this GADT you could use different number types in the same action
23:41:56 <cocreature> I don’t think the existential/GADT approach works here
23:42:06 <rightfold> Yeah there are probably issues
23:42:24 <cocreature> you can’t do anything if you know that something is an instance of Num apart from combining it with other things that are Num
23:42:35 <cocreature> but you can’t inspect or convert it to anything else
23:42:49 <cocreature> so it’s mostly useless in the (n -> next) function
23:42:57 <rightfold> Coyoneda Identity
23:46:55 <rightfold> orion: if you write a Bifunctor AST instance then you can change the number type with lmap, might be useful
23:57:50 <Guest34989> haskell's curry
23:58:17 <Theophane> I'm hungry now. :(
23:58:59 <cocreature> Theophane: I’ve heard that eating can help with that
23:59:41 <tsahyt> Theophane: may I interest you in the tortilla endofunctor?
