00:00:24 <vaibhavsagar> fair enough, I used it to replace the strictness annotations I was manually putting everywhere
00:12:59 <tsahyt> more likely than not you don't want strictness annotation everywhere in the first place
00:13:35 <tsahyt> although strict fields are often a good idea, I'll concede that
00:40:23 <Magnap> Hey mniip. Better late than never? :P
01:34:20 <jake__> .
01:41:26 <Gurkenglas> An Iso' (Tree a) (Cofree [] a) would be nice.
01:43:07 <Gurkenglas> Waaaaaaaaaaait a second. *checks with lamdabot*
01:44:22 <phz_> hey folks!
01:44:34 <phz_> is there a good library to connect to a MSSQL database?
01:44:45 <merijn> phz_: Honestly? I doubt it
01:44:56 <phz_> merijn: currently, we‚Äôre using a C# proxy
01:45:04 <phz_> but I don‚Äôt like that as our codebase is only Haskell for now
01:45:11 <merijn> phz_: There's a bunch of good/decent ones for Postgres, MySQL, and SQLite, but I haven't seen MSSQL in Haskell before
01:45:14 <phz_> having two languages around is a mess
01:45:22 <phz_> arf
01:45:26 <phz_> what a pity :(
01:45:47 <Aruro> haskell is Microsoft Research funded, surely there is MSSQL support
01:46:54 <merijn> Aruro: You do realise MSR is a non-profit academic research institution that just happens to be funded by MS, no? Not a product development lab
01:50:36 <Gurkenglas> local ghci says unsafeCoerce works between them :D is this safe?
01:50:38 <brynedwards> There are a couple of libraries for connecting via odbc in Haskell
01:50:40 <Aruro> merijn: where did u get non profit part? MR sits under same domain as microsoft, they just fun academics.
01:50:51 <Aruro> d*
01:51:16 <brynedwards> Like this https://github.com/hdbc/hdbc-odbc , probably your best choice for MSSQL
01:51:22 <brynedwards> ...in Haskell
01:56:21 <Aruro> merijn: in fact mircosoft tell us itself : esearchers are embedded in the company‚Äôs global network of product creation, and they contribute to products across platforms in addition to shipping their own.
01:56:37 <Aruro> https://www.microsoft.com/en-us/research/products/
02:02:38 <Chitzaa> hi
02:26:13 <fred-fri> pairs xs = zip xs (tail xs) doesn't give all pairs of a list, what does? (note, i need all pairs, not just all unique pairs)
02:26:51 <merijn> fred-fri: Are duplicates okay? i.e. should pairs [1..10] include (1, 1)?
02:26:51 <reactormonk[m]> Carthesian product of a list with itself?
02:27:08 <merijn> This sounds like a job for...the list monad! ;)
02:27:50 <fred-fri> fascinating how something so simple can have so much ambiguity =) 
02:28:15 <reactormonk[m]> Apparently it's not simple.
02:28:18 <ertes> > (\xs -> [ (x, y) | x:ys <- tails xs, y <- ys ]) [1..4]
02:28:21 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
02:28:27 <ertes> fred-fri: like that?
02:29:00 <merijn> > let l = [1..4] in do { x <- l; y <- l; return (x,y) }
02:29:02 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
02:30:14 <ertes> > (\xs -> [ (x, y) | x:ys <- tails xs, y <- x:ys ]) [1..4]  -- or that, if elements should pair with themselves as well
02:30:15 <merijn> Which I suppose is identical to
02:30:16 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
02:30:24 <reactormonk[m]> > let l x = (,) <$> x <*> x; l [1..4]
02:30:27 <lambdabot>  <hint>:1:36: error:
02:30:27 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
02:30:31 <merijn> > let l = [1..4] in [(x,y) | x <- l, y <- l]
02:30:34 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
02:30:38 <fred-fri> what have i unleashed
02:30:53 <merijn> fred-fri: Mostly these are slightly different ways to write the same thing :p
02:31:03 <merijn> fred-fri: only ertes' is different (that one has no duplicates)
02:32:28 <fred-fri> actually im not sure myself whether pair [1,2] should result in just [(1,2)] or [(1,2),(2,1)]. i do know that it shouldnt contain (1,1) or (2,2) though
02:33:17 <Iceland_jack> Morning y'all
02:33:35 <merijn> ugh...I just had the annoying realistion that I can't indepedently typecheck my ADTs and definitions, since my ADTs could potentially have definitions in them...
02:34:57 <fred-fri> i will try some of what you provided and see how i go, thanks
02:36:10 <ertes> @let select [] = []; select (x:xs) = (x, xs) : map (\(y, ys) -> (y, x:ys)) (select xs)
02:36:12 <lambdabot>  Defined.
02:36:50 <ertes> > (\xs -> [ (x, y) | (x, ys) <- select xs, y <- ys ]) [1..4]
02:36:52 <lambdabot>  [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
02:37:07 <ertes> fred-fri: ^ here is one further possibility
02:38:46 <Iceland_jack> (\(y, ys) -> (y, x:ys)) is (second (x:))
02:39:42 <merijn> @ask phadej Since you're working on bound: Do you know if there's a way to safely check whether all bound variables have been substituted in a Scope? I think instantiate currently only lets you produce bottom when your substitution function doesn't have the relevant variable?
02:39:42 <lambdabot> Consider it noted.
02:39:57 <ertes> or (_2 %~ (x :))
02:40:06 <ertes> or even (_2 <>~ [x])
02:40:08 <ertes> or ‚Ä¶
02:40:30 <Iceland_jack> :)
02:43:43 <tsahyt> There was a post on /r/haskell pointing to some linear logic course, but I can't find it anymore. Does anyone have the link?
02:44:55 <Iceland_jack> tsahyt: https://www.cs.cmu.edu/~fp/courses/15816-f16/ ?
02:45:12 <tsahyt> yes that's it! thank you!
02:55:45 <phz_> is there any way to call C# from Haskell?
02:56:01 <merijn> phz_: C FFI from Haskell to C#'s C FFI
02:56:09 <dmj`> phz_: System.Process
02:56:17 <dmj`> shell ‚Äúapp.exe"
02:56:18 <phz_> duh that‚Äôs ugly
02:56:21 <merijn> dmj`: That seems...a poor idea for most cases
02:56:33 <phz_> I‚Äôm trying to find a way to cope with that MSSQL stuff
02:56:43 <phz_> we currently have a client written in C# exposing some kind of a webapp
02:56:45 <phz_> but I don‚Äôt like that
02:56:50 <phz_> because we also have the haskell webapp
02:56:59 <phz_> that‚Äôs like a lever of unnecessary indirection
02:57:02 <phz_> level*
02:57:38 <merijn> phz_: The two sane options are: 1) use some IPC (sockets, pipes, whatever) to query the C# version from Haskell or 2) use the FFI to call C# code directly
02:57:58 <phz_> I want to implement #2!
02:58:10 <phz_> but it seems a bit overkill, right?
02:58:16 <merijn> phz_: Honestly, Haskell's FFI is pretty simple
02:58:19 <cocreature> you just need to implement a inline-c# library analogous to the inline-java library
02:58:26 <dmj`> yea, simple
02:58:27 <earthy> https://wiki.haskell.org/Salsa is an experimental third alternative
02:58:28 <merijn> I have no experience with C#, but I can't imagine their FFI is very hard
02:58:32 <cocreature> (I‚Äôm not being completely serious)
02:58:43 <earthy> it's a tad oldish though.
02:59:03 <phz_> yeah, well‚Ä¶ :D
02:59:13 <earthy> and even older is hs-dotnet http://haskell.forkio.com/dotnet
02:59:51 <brynedwards> phz_: Have you looked at HDBC-odbc?
03:00:36 <brynedwards> Here's a reddit thread from a couple of months ago where people mention using that to work with MSSQL https://www.reddit.com/r/haskell/comments/5ogaoy/mssql_and_haskell/
03:00:55 <phz_> I saw it kinda sucks?
03:01:07 <dmj`> phz_: would porting to sql and haskell from c# and mssql be out of the question? How much .net code is it
03:01:20 <earthy> oh, and obviously https://wiki.haskell.org/GHC:FAQ#Why_isn.27t_GHC_available_for_.NET_or_on_the_JVM.3F
03:01:29 <phz_> dmj`: it‚Äôs a lot of code ; we are writing Haskell proxies to it
03:01:36 <brynedwards> It doesn't look super reliable unODODODfortunately
03:01:38 <phz_> it‚Äôs existant, 10-years old code
03:01:45 <dmj`> phz_: how many lines
03:01:50 <phz_> I don‚Äôt know, a lot
03:01:52 <cocreature> phz_: tbh I think just using some ipc is probably the easiest solution
03:01:53 <reactormonk[m]> Somehow eta is missing on that list
03:02:00 <dmj`> phz_: is it closed-source?
03:02:07 <phz_> dmj`: unfortunately, yeah
03:02:11 <cocreature> unless exposing c# methods via a C ffi is very easy
03:02:12 <phz_> it‚Äôs work stuff
03:02:20 <phz_> (yeah, I do haskell at work <3)
03:02:50 <tsahyt> reactormonk[m]: eta is still relatively new. probably newer than that list
03:03:25 <dmj`> phz_: so you‚Äôre just wrapping the database w/ haskell and accessing it in a read only way?
03:03:37 <phz_> dmj`: currently, we‚Äôre writing views to it
03:03:43 <phz_> readonly, but we‚Äôll have write access soon
03:03:52 <earthy> phz_: otoh, wouldn't writing an F#-wrapper be a better idea?
03:04:16 <dmj`> two apps with write access to the same db, make sure they don‚Äôt step on each other‚Äôs toes
03:05:43 <phz_> dmj`: we‚Äôre decommissioning the old one in favour of the Haskell one
03:05:46 <phz_> it‚Äôll take time
03:05:56 <phz_> in the end, we won‚Äôt even need the C# stuff anymore
03:06:04 <phz_> as we‚Äôll be using our own technology
03:06:18 <phz_> but in the meantime, for an unknown period of time, we‚Äôll need those proxies :/
03:07:04 <dmj`> sure, makes sense. Is your haskell built on windows?
03:14:28 <bollu> is there anyone here familiar with the "derivative of a type as a one hole context"? I'm trying to interpret what the derviative of (a -> b) i.e b^a is with respect to b
03:14:51 <bollu> d(a->b)/db = d(b^a)/db = a . b^(a - 1)
03:19:21 <opqdonut> you have a pair (value, function-for-everything-else-except-value)
03:19:36 <opqdonut> you've removed f(value), kind of
03:20:32 <opqdonut> or that's my intuition
03:20:38 <opqdonut> you'd need to use virtual (negative) types to formalize that
03:21:58 <opqdonut> I haven't really looked at derivatives of function types ever though
03:22:54 <bollu> opqdonut: no, but I'm checking the derivative with respect to _b_
03:23:01 <bollu> opqdonut: so I removed something in the codomain
03:23:05 <bollu> opqdonut: which is what I find confusing
03:23:07 <opqdonut> yes
03:23:25 <bollu> opqdonut: so the preimage of that thing in the codomain could be many a's, or none at all
03:23:36 <bollu> opqdonut: I would have expected ([a], b^(a - 1))
03:23:36 <opqdonut> mmh, right!
03:23:49 <bollu> opqdonut: but it says (a, b^(a - 1)) which I find strange
03:24:08 <bollu> opqdonut: tell me more about negative types?
03:24:58 <opqdonut> the type a-b is formalized as <a,b> with equality <a,b> = <c,d> <=> a+d = b+d
03:25:16 <opqdonut> so the usual algebraic trick of introducing inverses
03:25:21 <bollu> ah
03:25:27 <bollu> but in this context, "+" being choice?
03:25:32 <opqdonut> yes.
03:25:37 <bollu> I see. 
03:26:00 <bollu> opqdonut: do you have a reasonable interpretation of the logarithm of a type?
03:26:10 <opqdonut> I've thought about that
03:26:11 <bollu> or, well, anyone here
03:26:28 <opqdonut> but I can't remember what I thought about it :(
03:26:40 <opqdonut> it somehow turned types into paths
03:26:55 <bollu> "paths" in the HoTT sense?
03:26:58 <opqdonut> (a*b -> a+b, so you either went left or right)
03:27:08 <bollu> ah
03:27:09 <bollu> interesting
03:27:12 <opqdonut> (a^b -> b*a, so pick a x and f(x))
03:27:17 <Phyx-> phz_: C# is designed for interopability with C, in both direction. What it comes down to is that your Haskell library has to host and start the CLR before you can call your C# methods
03:27:30 <bollu> wow, so you interpret it in terms of the homomorphism. clever :P 
03:27:51 <bollu> (a + b -> gibberish, though)
03:27:54 <Phyx-> phz_: so you need to use the .NET Hosting APIs https://msdn.microsoft.com/en-us/library/ms404385(v=vs.110).aspx and https://msdn.microsoft.com/en-us/library/dd380850(v=vs.100).aspx should get you started
03:27:57 <opqdonut> bollu: yeah
03:28:12 <opqdonut> exponentiation takes X into "set of X"
03:28:16 <bollu> opqdonut: yeah
03:28:23 <opqdonut> so logarithm needs to do the inverse, which is a bit mind-boggling
03:28:43 <opqdonut> but the elements of a^b are pairs b*a, so it kinda makes sense
03:28:51 <bollu> yeah, I guess
03:29:09 <Phyx-> phz_: that said, you need GHC 8.2, because of a stack initial size issue with the older GHCs which conflicts with the CLR. Though smaller examples may work..
03:30:37 <bollu> a + b -> log(a + b). I suppose we should make | log(a) == "path through a" as an axiom 
03:30:49 <bollu> then log(a * b) = log a + log b makes sense
03:30:49 <Phyx-> phz_: hosting the Haskell runtime in C# is much easier though.
03:31:05 <bollu> perhaps log(a) = "pick a" is a reasonable interpretation
03:31:45 <bollu> hmm
03:31:53 <bollu> log_a(a) = 1
03:32:04 <bollu> is consistent, there is only one way to pick a out of a
03:32:21 <bollu> log_a(a^n) = n, still consistent. There are "n" ways to pick "a" out of a^n
03:32:49 <opqdonut> nice
03:34:08 <bollu> log_a(c^d) = log_a(c . c . c ‚Ä¶ (d times)) = d . log_a(c) -> if you have "c" repeated "d" times, the #of ways of picking "a" is the number of choices of "c" you have, multiplied by the number of choices of "a" in "c"
03:34:10 <bollu> neat
03:35:28 <opqdonut> in this type algebra case it's important to not mix up a^b as a shorthand for a*a*...*a and a^b as an alternative to b->a
03:35:37 <opqdonut> the former is easy to handle usually, the latter can be tricky
03:35:47 <bollu> ah right
03:35:47 <bollu> crap
03:35:51 <bollu> hm
03:36:29 <bollu> opqdonut: actually I'd argue they're the same
03:36:29 <opqdonut> tuples vs. functions
03:36:30 <bollu> in some sense
03:36:45 <bollu> opqdonut: a function is an "infinite tuple"
03:36:56 <opqdonut> yeah well the meaning of a^(3-1) is clear, the meaning of a^(Int-1) is less clear :)
03:37:05 <bollu> opqdonut: yeah
03:37:20 <opqdonut> sorry I gotta go now, this was an interesting discussion
03:37:21 <bollu> opqdonut: I would argue that it means this: you have all the variants of Int
03:37:26 <bollu> opqdonut: np
03:40:29 <fred-fri> foo [1,2,3,4] should output [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)] my best attempt so far is https://pastebin.com/STYzmJwf but i suspect theres a better way
03:43:04 <Iceland_jack> > [ (x, y) | x:ys <- tails [1,2,3,4], y <- ys ]
03:43:06 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
03:43:31 <bollu> >  let foo xs = (liftA2 (,) xs xs) & filter (uncurry (<)) in [1..4]
03:43:34 <lambdabot>  [1,2,3,4]
03:43:41 <bollu> > ¬†let foo xs = (liftA2 (,) xs xs) & filter (uncurry (<)) in foo [1..4]
03:43:43 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
03:44:04 <fred-fri> interesting, thanks
03:44:12 <shiona> :t (&)
03:44:13 <lambdabot> a -> (a -> b) -> b
03:44:17 <Iceland_jack> x & f = f x
03:44:29 <Iceland_jack> (recently added to Data.Function)
03:44:40 <bollu> Iceland_jack: I much prefer (|>) 
03:44:46 <bollu> Iceland_jack: but I suppose I lost that battle
03:45:05 <Iceland_jack> Yes
03:45:38 <fred-fri> bollu, are you saying you prefer what Iceland_jack wrote?
03:46:14 <bollu> fred-fri: no, F# uses the operator called (|>) which is the same as (&). But I find that (|>) carries the intent better (to me at least)
03:46:22 <bollu> fred-fri: IIRC there was some discussion around what to adopt
03:46:22 <Iceland_jack> (<|), (|>) are a lot less arbitrary than ($), (&)
03:46:29 <bollu> yeah
03:46:49 <bollu> but, the reasoning for & is "x & f & g" is "take x and do f and do g"
03:46:54 <bollu> which is at least "explainable"
03:46:57 <bollu> unlike $
03:47:07 <Iceland_jack> Haskell people are obsessed with money
03:47:12 <bollu> :P
03:47:17 <fred-fri> Iceland_jack, correct me if I'm wrong but what you wrote is a list comprehension?
03:47:24 <Iceland_jack> fred-fri: Correct
03:47:34 <fred-fri> If so I need to read up that and make this the first list comprehension I "get"
03:47:45 <Iceland_jack> Well let's first "get" tails
03:47:47 <Iceland_jack> > tails "hello"
03:47:49 <lambdabot>  ["hello","ello","llo","lo","o",""]
03:48:05 <bollu> fred-fri: Iceland_jack's code is more general and faster than mine :) I just wrote mine to exploit some cuteness
03:48:14 <ahihi> > let foo1 xs = [ (x, y) | x:ys <- tails xs, y <- ys ]; foo2 xs = (liftA2 (,) xs xs) & filter (uncurry (<)); xs = [4,3,2,1] in (foo1 xs, foo2 xs)
03:48:17 <lambdabot>  ([(4,3),(4,2),(4,1),(3,2),(3,1),(2,1)],[(3,4),(2,4),(2,3),(1,4),(1,3),(1,2)])
03:48:53 <Iceland_jack> the list comprehension I wrote involves some "tricks", for example if a pattern match (x:ys) fails it skips that element
03:49:06 <fred-fri> actually if i had known about list comprehension yesterday i bet this could be improved by it https://gist.github.com/androidfred/057fc0d23fde5b2653f03877f969ed08
03:49:11 <Iceland_jack> > [ str | str <- tails "hello" ]
03:49:14 <lambdabot>  ["hello","ello","llo","lo","o",""]
03:49:15 <Iceland_jack> > [ s:str | s:str <- tails "hello" ]
03:49:18 <lambdabot>  ["hello","ello","llo","lo","o"]
03:49:28 <Iceland_jack> > [ s:v:str | s:v:str <- tails "hello" ]
03:49:31 <lambdabot>  ["hello","ello","llo","lo"]
03:50:03 <Iceland_jack> > [ x:xs | str <- tails "hello", let x:xs = str ]
03:50:06 <lambdabot>  ["hello","ello","llo","lo","o","*Exception: <interactive>:3:36-45: Irrefutab...
03:50:34 <Iceland_jack> I could also have written mine with (concat :: [[a]] -> [a])
03:51:15 <Iceland_jack> > [ map (x, ) ys | x:ys <- tails [1,2,3,4] ]
03:51:18 <lambdabot>  [[(1,2),(1,3),(1,4)],[(2,3),(2,4)],[(3,4)],[]]
03:51:23 <Iceland_jack> > concat [ map (x, ) ys | x:ys <- tails [1,2,3,4] ]
03:51:27 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
03:51:59 <fred-fri> i think that last example is the easiest to get for a newbie
03:52:11 <fred-fri> but the list comprehension one is probably the most idiomatic?
03:52:33 <fred-fri> optimally you want to generate the end result in one go without having to trim anything
03:55:49 <fred-fri> thanks for the help, much appreciated. love this channel.
03:58:30 <Iceland_jack> fred-fri: yw!
04:08:19 <mniip> Magnap, hey
04:10:36 <kuribas> Is having recursion as tailcalls an advantage?
04:10:50 <merijn> kuribas: In Haskell?
04:10:53 <kuribas> yes
04:11:20 <merijn> kuribas: In general, no. As, depending on your point of view, either every haskell function call is a tail call, or none are
04:12:00 <merijn> kuribas: Tail calls are usually used in combination with tail-call optimisation to avoid stack growth for recursive functions. But (GHC) Haskell doesn't use a function call stack, so there's also no call stack growth to avoid
04:12:32 <kuribas> and in a monadic context?
04:13:05 <kuribas> say myAction (x:xs) = do anAction x; myAction xs
04:13:11 <merijn> kuribas: No, but there's some other general overhead for repeated monadic binds
04:13:20 <merijn> kuribas: Are you familiar with DList?
04:13:26 <kuribas> sort of...
04:13:47 <merijn> kuribas: There's "Codensity transform", which is basically DList generalised to (among other things) monads
04:14:39 <merijn> kuribas: The main reason to do tail calls is to fix strictness. And there it's just incidental (because that's how you fix the strictness) not a root issue
04:15:37 <merijn> kuribas: Consider "sum (x:xs) = x + sum xs", the problem with this code is that it creates a huge thunk of pluses to evaluate (typical lazy leak), to avoid this leak we want to keep forcing the sum as we go, but we can't do that in this version
04:16:35 <merijn> "sumHelper n (x:xs) = n `seq` sumH (n + x) xs" solves the leak by forcing 'n' at every step (and happens to be tail recursive). But the speedup/improvement here is fixing the laziness, not the tail call bit.
04:16:36 <kuribas> merijn: I'd use a strict foldl'
04:16:56 <merijn> kuribas: Well sure, but someone needs to implement foldl' this way first ;)
04:17:16 <merijn> kuribas: s/sum/foldl'/ and you have the same problem AND solution :)
04:18:03 <kuribas> I see, so thunks take place of the stack in other languages...
04:19:20 <kuribas> except that the order for the stack is well defined.
04:19:29 <merijn> kuribas: Haskell uses a pattern matching stack, instead of a function call stack, yes
04:19:46 <merijn> kuribas: We only evaluate thunks while performing a case-of, right?
04:20:16 <kuribas> right
04:20:32 <merijn> So if we have "case e of { ... }" we need to evaluate 'e', but what if evaluating 'e' to WHNF includes another case? Clearly we need a stack to store whatever pattern we were matching before so we can return to it
04:21:43 <kuribas> So ghc uses the stack for that?
04:21:46 <merijn> kuribas: Function calls, in contrast, in Haskell are basically compiled to simple JMP instructions in assembly (rather than C's CALL)
04:21:57 <kuribas> Does it every use call?
04:22:00 <kuribas> ever
04:22:03 <merijn> kuribas: Well, it's not like there is a "the stack"
04:22:15 <merijn> kuribas: The stack is simply "a bit of memory we have reserved to be the stack"
04:22:20 <kuribas> the x86 stack
04:22:30 <merijn> kuribas: No, GHC doesn't use CALL afaik
04:23:01 <kuribas> or PUSH, SP?
04:23:21 <kuribas> except for FFI of course.
04:25:09 <kuribas> I suppose strict code could use a stack, but that may interfere with lazyness...
04:25:36 <kuribas> So not using a stack makes it less complicated.
04:27:15 <msl09> hello
04:27:28 <msl09> anybody have some experience with postgresql-simple?
04:28:08 <msl09> I'm trying to make my data an instance of FromRow
04:28:10 <msl09>   fromRow = MessageLog <$> field <*> field <*> field <*> field <*> field <*> field
04:28:54 <msl09> but I'm getting an error saying that ‚ÄòfromRow‚Äô is not a (visible) method of class ‚ÄòFromRow‚Äô
04:29:26 <msl09> what does that mean?
04:30:45 <kuribas> msl09: that the class FromRow doesn't have a method called "fromRow"
04:30:51 <lyxia> msl09: Database.Postgres.Simple only exports the class name
04:32:23 <lyxia> Try deriving Generic instead and leaving the instance of FromRow empty
04:32:53 <kuribas> Maybe you need to import Database.PostgreSQL.Simple.FromRow?
04:35:31 <kuribas> lyxia: strange, the documentation says you can derive an instance this way...
04:35:41 <kuribas> lyxia: here: https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/Database-PostgreSQL-Simple-FromRow.html
04:35:45 <msl09> >Database.Postgres.Simple only exports the class name
04:36:10 <msl09> what's why does that happens?
04:36:55 <kuribas> The latest from hackage has: FromRow(..)
04:37:17 <kuribas> msl09: can you post a snippet?
04:37:30 <msl09> yeah sure
04:37:34 <lyxia> kuribas: right, I was suggesting an alternative with less boilerplate
04:38:32 <lyxia> kuribas: where do you see FromRow(..)? Isn't the latest https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/src/Database-PostgreSQL-Simple.html ?
04:38:36 <lpaste> msl09 pasted ‚Äúpostgresql-simple‚Äù at http://lpaste.net/354238
04:38:43 <msl09> there
04:39:04 <kuribas> lyxia: https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/src/Database-PostgreSQL-Simple-FromRow.html#FromRow
04:39:27 <kuribas> msl09: yeah, you need import Database.PostgreSQL.Simple.FromRow
04:39:32 <lyxia> Okay but I was talking about the root module
04:40:01 <lyxia> which is what msl09 quoted
04:40:03 <Myrl-saki> For linear types, when is duplication harmful? Aside from concurrency.
04:40:15 <kuribas> lyxia: right, I was looking at the other module
04:41:17 <kuribas> Myrl-saki: maybe garbage collection?  Without duplication you don't need it...
04:41:44 <Myrl-saki> kuribas: Right. But harmful?
04:42:25 <msl09> so to expose "fromRow" Postgresql.Simple would have to list the typeclass as "FromRow(..)" in the module declaration?
04:42:53 <lyxia> right
04:43:17 <msl09> ic, thanks!
04:45:27 <lyxia> Myrl-saki: duplication of resources is one cause of "use after free"
04:46:08 <lyxia> the resource is consumed both by free and the usage after it.
04:48:13 <Aruro> msl09: official: https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1000005.2
04:48:32 <Aruro> item 4
04:49:53 <msl09> ah I see
04:49:56 <msl09> thanks Aruro 
05:00:53 <mniip> hum
05:01:14 <mniip> it appears that vector spaces are related to representable functors
05:01:23 <mniip> with dimensions being the representation
05:06:02 <Aruro> and?
05:12:09 <Aruro> mniip: u know that functors first appeared in topology? which in turn is about topological spaces, which in turn are generalisation of metric spaces?
05:15:13 <mniip> Aruro, I'm talking about a stronger relationship
05:15:19 <mniip> something along the lines of
05:16:06 <mniip> a functor is a vector space iff it is representable
05:23:06 <Aruro> mniip: do u have any example of representable functor?
05:24:02 <ertes> "left-to-right associativity"‚Ä¶  i can only assume what that means‚Ä¶  why do people write stupid prose instead of a clear symbolic expression?
05:26:09 <mniip> Aruro, data Pair a = Pair a a
05:26:26 <Aruro> how?
05:26:35 <ertes> mniip: representable by (->) Bool?  i have no experience with representable functors
05:26:53 <Aruro> end cathegory has to be sets, where are sets here?
05:27:09 <Aruro> and functions
05:27:25 <ertes> Aruro: in type theory, it's a category of types and functions instead of sets and functions
05:27:37 <ertes> that's fine, they are similar enough for this
05:27:39 <Iceland_jack> Aruro: (Pair a) is isormophic to a function from Bool: (Bool -> a)
05:27:47 <Iceland_jack> to *functions
05:29:16 <Iceland_jack> The representing type (Bool) acts as a sort of key indexing into (Pair a)
05:29:18 <Aruro> functions from bool to a dont form cathegory
05:29:28 <Aruro> i dont see from what to what this functor maps stuff
05:29:30 <ertes> Aruro: they form a functor
05:30:16 <ertes> @let myPair i = if i then 15 else 20
05:30:18 <lambdabot>  Defined.
05:30:24 <ertes> @let myBoth p = (p False, p True)
05:30:27 <lambdabot>  Defined.
05:30:31 <ertes> > myBoth myPair
05:30:34 <lambdabot>  (20,15)
05:30:41 <ertes> > myBoth (fmap (+ 1) myPair)
05:30:44 <lambdabot>  (21,16)
05:30:48 <ertes> Aruro: ^
05:31:13 <Aruro> its not representable functor :)
05:31:33 <Aruro> first we have to define cathegory which we are Representing
05:31:33 <ertes> Pair is the representable functor‚Ä¶  it's represented by Bool
05:31:51 <Iceland_jack> ((->) Bool) is also an obvious representable functor :) represented by Bool
05:32:03 <Iceland_jack> Isomorphism between (Bool -> a) and (Bool -> a)
05:32:40 <Aruro> Iceland_jack: reread definition of representable functor, this is maximum some endofunctor
05:33:20 <Iceland_jack> ((->) Bool) and Pair are both (endo)Functors
05:33:45 <Iceland_jack> Have you looked at https://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html
05:34:10 <ertes> Aruro: Hask (a category of types and functions) is used as a substitute for Set here
05:34:20 <ertes> Aruro: Pair is an endofunctor from Hask to Hask
05:34:40 <ertes> it is represented by the object Bool
05:34:41 <Aruro> then there are no representable functors in haskell, if u make it equal to sets
05:34:54 <Aruro> kills whole point of representable functors
05:35:04 <Aruro> this all are endofunctors
05:35:09 <ertes> Aruro: there is no category of sets in haskell or type theory for that matter‚Ä¶  it's a different mathematical foundation from set theory
05:35:36 <Aruro> then its not good idea to use same naming
05:35:49 <Aruro> better invent something more computing friendly
05:36:23 <ertes> Aruro: i would almost agree, but category theory itself is usually stated in a foundation-agnostic way
05:36:32 <ertes> Set is an unfortunate counter-example
05:37:33 <ertes> fortunately a category of types and functions is so similar to Set that you can pretty much use it as a substitute
05:45:06 <Aruro> for CT afficionados, parametric types have to be called homomorphisms and simle types objects :)
05:45:35 <Aruro> no mix two things in one bucket
05:45:47 <Aruro> i mean on language level
05:47:00 <ertes> in Hask only concrete types exist‚Ä¶  but there is also a category of kinds and type functions
05:47:31 <ertes> so yes, something like Maybe would be a morphism in the kind category
05:47:41 <Aruro> i mean data Bool and data Bool1 a , are obviously two different things
05:47:50 <Aruro> Bool1 a should not be in data keyword
05:48:10 <ertes> why?
05:48:10 <Aruro> morph Pair a = Pair a a
05:48:22 <Aruro> data Bool = False | True
05:48:31 <ertes> maybe you like this syntax better:  data Bool1 :: * -> * where ‚Ä¶
05:48:49 <Aruro> yes, helps
05:49:36 <ertes> @let data Bool1 :: * -> * where False1 :: Bool1 a; True1 :: Bool1 a
05:49:38 <lambdabot>  Defined.
05:49:40 <lyxia> why use up more keywords when you can just use one
05:49:41 <ertes> you're welcome to use it ;)
05:49:56 <Aruro> lyxia: mental honesty
05:50:07 <Aruro> and clarity
05:51:18 <lyxia> I really don't see what's dishonest about Pair a being a "data type"
05:51:30 <Aruro> because its not object
05:51:36 <Aruro> which data naively implies
05:51:52 <Aruro> well.
05:52:06 <lyxia> For every object in Hask, Pair a is an object... isn't that sufficient
05:52:15 <ertes> Aruro: i don't see anyone with deep familiarity with category theory ever making that mistake‚Ä¶  it defines a "type"
05:52:29 <ertes> s/with/without/
05:52:31 <lyxia> It's like id :: a -> a actually being id :: forall a. a -> a in a way
05:52:50 <ertes> Aruro: if you really complain on that level, you should be complaining that Hask is a highly questionable category to begin with
05:53:14 <Aruro> ^ :)
05:53:34 <Aruro> well, people seem to like sticking with CT models on top of poor hakell
05:53:41 <Aruro> wanted to make life easier
05:54:30 <ertes> Aruro: it's like quantum mechanics (a model) and the real world (the application)‚Ä¶  CT is a model for haskell, the real world, and it's "good enough"
05:54:41 <Aruro> i would introduce explicit keywords Functor Applicative instead of data
05:55:05 <ertes> you disregard some of the uglier aspects of haskell when using CT or, indeed, even just equational reasoning
05:55:09 <Iceland_jack> Aruro: Would "data A a b" have a separate keyword? How about higher-order functors like Fix?
05:55:35 <Iceland_jack> They are sufficiently distinguished by their kinds
05:55:37 <Aruro> like -- functor Pair a = Pair a a where fmap =
05:56:10 <Iceland_jack> Aruro: What about invariant constructors, like data Endo a = Endo (a -> a)?
05:56:18 <ertes> Aruro: otherwise you will not be using any form of logical reasoning for haskell, because it's all invalid from a rigorous logical perspective
05:56:56 <Aruro> ertes: but people seem to ingore this part
05:57:27 <ertes> Aruro: so you say that logical reasoning shouldn't be used, unless it's 100% rigorous?
05:57:33 <Aruro> Iceland_jack: i mean i would fuse functor declaration with its data declaration, to make stuff more clear
05:57:58 <Aruro> ertes: have no idea, but that is something i would definitely would say at first :)
05:58:11 <Iceland_jack> I don't see the benefit
05:58:29 <ertes> Aruro: then, as i said, you will not be using any logical reasoning with haskell‚Ä¶  you will not use the fact that fmap is structure-preserving
05:58:32 <merijn> Fast and Loose Reasoning is Morally Correct! *duck*
05:58:46 <ertes> Aruro: because it's invalid
05:58:59 <ertes> Aruro: you see what i mean?
05:59:37 <Aruro> ertes: thats why i would argue for field tested layman alternative to CT
06:00:13 <ertes> Aruro: why not use CT itself as a model?  every model and associated proofs we construct in CT are *valid*, and then we apply them to haskell
06:00:29 <msl09> can I pattern match an IO?
06:00:33 <msl09> ioReverse :: IO (String) -> String ioReverse (return (a)) = reverse a
06:00:37 <msl09> oops
06:00:38 <ertes> msl09: n
06:00:40 <ertes> no
06:00:44 <msl09> why?
06:00:47 <Iceland_jack> msl09: fmap reverse
06:00:59 <ertes> msl09: what would (ioReverse getLine) be?
06:01:35 <ertes> msl09: please state the answer in the form of an equation
06:01:48 <Aruro> Iceland_jack: u think there is no benefit mergin Functor declaration with its datatype declaration?
06:02:03 <lyxia> I also think so.
06:02:04 <ertes> msl09: if, right now, you're thinking: "that doesn't make sense", you're absolutely correct‚Ä¶  it doesn't make sense =)
06:02:13 <merijn> Aruro: Well, why make functor special and not, e.g. also Applicative and Monad?
06:02:20 <Aruro> i suggest that
06:02:21 <Iceland_jack> Your proposal is too vague to evaluate
06:02:39 <Aruro> functor Pair a = Pair a a where fmap =
06:02:53 <merijn> ertes: You can pattern match IO, though...it just means reaching into GHC's voodoo guts :)
06:03:08 <ertes> merijn: pssssssht
06:03:33 <Iceland_jack> Not everything "data P a" is a functor, it may not even be "Type -> Type"
06:03:42 <Aruro> Iceland_jack: then its data
06:04:10 <Iceland_jack> Not loving the idea :) sorry
06:04:37 <Aruro> is data P a a data then?
06:04:40 <Aruro> what is it?
06:04:52 <merijn> Aruro: I think you're overthinking things
06:04:53 <Aruro> im reading your code. what shoul i think?
06:04:57 <msl09> ahh I see ertes
06:05:00 <Iceland_jack> It's invalid Haskell
06:05:28 <ertes> msl09: https://www.vex.net/~trebla/haskell/IO.xhtml
06:06:14 <Aruro> Iceland_jack: u just got used to data meaning anything :) fine aswell.
06:06:26 <Iceland_jack> No, I get that meaning from the kinds
06:06:38 <Aruro> not everybod writes them
06:06:56 <Iceland_jack> so you want mandatory kind signatures?
06:07:08 <msl09> the result of (return a) and the result of getLine are completely different things, even though they have the same type declaration
06:07:16 <Iceland_jack> That's a much better direction imo
06:07:40 <lyxia> Or have haddock generate it
06:07:52 <Aruro> no need of mandatory, just said data can be confusing in terms of CT naming convention
06:07:59 <Aruro> Iceland_jack: ^
06:09:02 <Aruro> if u will declare something in first place as functor,it CAN (can not) help somebody read your code
06:09:30 <Iceland_jack> okay
06:09:33 <ertes> msl09: the thing is: any answer you might give (let's say: ioReverse getLine = "blah"), i would follow up with: "so (ioReverse getLine = ioReverse (return "blah"))?  why don't you just use "blah" in the first place?"
06:10:59 <ertes> msl09: the tutorial i linked explains why it doesn't make sense, and how to actually do it properly *in general*
06:11:45 <Iceland_jack> I'd need something more concrete, not saying it couldn't be useful
06:12:35 <ertes> Aruro: haskell is not a categorical language
06:12:56 <ertes> CT is just a model we use one abstraction layer above
06:13:00 <msl09> well I understand that I shouldn't use ioReverse (or that it shouldn't be possible create it in the first place)...
06:13:03 <msl09> ahhhhhhhhhhhh
06:13:29 <Aruro> ertes: i agree with u.
06:13:32 <msl09> I would also be breaking the purity
06:13:50 <ertes> msl09: first understand what purity means:  essentially it means that you can use equational reasoning
06:14:07 <ertes> with that in mind ioReverse would not make sense at all
06:14:20 <ertes> msl09: example: this is unconditionally true: getLine = getLine
06:14:26 <ertes> because equality is reflexive
06:14:54 <Aruro> msl09: he tells that good haskell program is gian formula and few lines of IO code
06:15:00 <Aruro> *t
06:15:04 <ertes> therefore clearly getLine cannot be a string, not even a "tainted string" as some people mistakenly interpret it
06:15:18 <msl09> yes
06:15:23 <ertes> Aruro: no, that's not what i'm saying
06:15:38 <ertes> my code is quite IO-heavy in fact =)
06:15:42 <Aruro> no? what is equational reasoning then?
06:15:59 <ertes> Aruro: using equations, along with the usual laws that equality follows
06:16:10 <Aruro> well that is formula :)
06:16:27 <Aruro> symbolic construction
06:16:39 <ertes> Aruro: not in code, in reasoning
06:16:47 <ertes> for example the monoid laws are stated as equations
06:17:01 <ertes> but they don't appear explicitly in code
06:17:07 <Aruro> yes, and allow to treat pure code as formula
06:17:12 <ertes> of course any equations you write explicitly in code, are also valid equations
06:17:20 <ertes> foldr f z [] = z  -- for all f and z
06:17:35 <msl09> yeah no I'm confused again
06:17:40 <msl09> I have to read that tutorial
06:17:46 <ertes> msl09: yes =)
06:18:21 <mniip> ertes, one catch
06:18:25 <Aruro> msl09: pure also means returning same result on same input, IO does not have that
06:18:34 <mniip> f () = 1; f () = 2
06:18:38 <stephAne_> merijn: I tried implementing your exercise for understanding MonadTransformers, with MyState.hs and MyStateT.hs, but I'm blocked on MyStateT.hs, i have a compile error which I cannot deal with. It's in the implementation of modify and fmap. I have put the compilation error at the top of my code: http://lpaste.net/354240 
06:18:45 <ertes> mniip: indeed, yeah
06:18:56 <ertes> Aruro: IO is pure
06:19:19 <Aruro> until u run it yes
06:19:30 <ertes> "until you run it"?  you never do in haskell
06:19:37 <Aruro> main = print
06:19:38 <mniip> Aruro, of course IO doesn't have that
06:19:41 <mniip> IO isn't a function
06:19:45 <mniip> there is no input
06:19:56 <merijn> stephAne_: line 35, what is the type of mVal?
06:19:59 <mniip> putStrLn is a function and it returns the same result on same input
06:20:01 <Aruro> readFile there is input
06:20:01 <ertes> Aruro: i think you're also using the "tainted" interpretation, and it doesn't really do you any good
06:20:09 <ertes> Aruro: is getLine a string to you?
06:20:22 <mniip> Aruro, referential transparency is only concerned about functions
06:20:40 <stephAne_> merijn: i would say m (a, s)
06:21:04 <mniip> Aruro, we require that 'f (g x) (g x) == let y = g x in f y y'
06:21:06 <mniip> nothing more
06:21:13 <merijn> stephAne_: Do you know how "s <- foo; return s" desugars?
06:21:38 <mniip> requiring that "do y <- g x; y' <- g x; f y y' == do y <- g x; f y y" would be silly
06:21:47 <mniip> consider
06:21:51 <stephAne_> I have to write it down, let me a minute
06:21:54 <merijn> @undo do { s <- get; return s }
06:21:54 <lambdabot> get >>= \ s -> return s
06:22:08 <merijn> stephAne_: So it implicitly uses >>=
06:22:15 <merijn> :t (>>=)
06:22:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:22:20 <ertes> @quote /bin/ls
06:22:20 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
06:22:22 <mniip> > let g = enumFromTo 0; x = 1; f = (,) in do y <- g x; y' <- g x; f y y'
06:22:23 <stephAne_> yep, but i always have to rewrite the function bind awaits
06:22:26 <lambdabot>  error:
06:22:26 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò(,) Integer‚Äô with ‚Äò[]‚Äô
06:22:26 <lambdabot>        Expected type: [b]
06:22:27 <ertes> Aruro: ^
06:22:36 <mniip> > let g = enumFromTo 0; x = 1; f = (return .) . (,) in do y <- g x; y' <- g x; f y y'
06:22:38 <lambdabot>  [(0,0),(0,1),(1,0),(1,1)]
06:22:43 <mniip> > let g = enumFromTo 0; x = 1; f = (return .) . (,) in do y <- g x; f y y
06:22:46 <lambdabot>  [(0,0),(1,1)]
06:22:54 <mniip> this does not break referential transparency
06:23:01 <merijn> stephAne_: Well, the 'a' in 'MyState s m a' is basically the 'a' in 's -> (a, s)'
06:23:07 <mniip> likewise, readFile producing different "results" does not
06:23:14 <merijn> stephAne_: So the fmap on line 36 is redundant
06:23:31 <merijn> stephAne_: You want to just do "f mVal"
06:23:42 <Myrl-saki> lyxia: Thanks.
06:24:09 <Aruro> mniip: ertes: https://wiki.haskell.org/Pure
06:24:17 <Aruro> i did not write that page :)
06:24:30 <stephAne_> merijn: do you mean it desugars both from MyStateT and m monad ?
06:24:40 <ertes> Aruro: it says "function" there
06:24:43 <ertes> getLine is not a function
06:24:49 <Aruro> so then its impure
06:24:56 <merijn> stephAne_: There is only one monad "MyStateT s m" is the monad :)
06:24:58 <ertes> Aruro: is (3 :: Integer) impure?
06:25:07 <stephAne_> yep but m is a monad also ?
06:25:08 <Aruro> its not function as u said
06:25:12 <Aruro> :t getLine
06:25:14 <lambdabot> IO String
06:25:21 <Aruro> ok same here
06:25:27 <Aruro> :t readFile
06:25:29 <lambdabot> FilePath -> IO String
06:25:31 <merijn> stephAne_: Yes, but that's irrelevant now, because GHC isn't using that one, it's using the "MyStateT s m" one
06:25:37 <ertes> Aruro: readFile is a function, and yes, it's pure
06:25:44 <Aruro> how?
06:25:44 <merijn> stephAne_: You used the 'm' monad while implementing "Monad (MyStateT s m)"
06:25:49 <ertes> Aruro: (readFile "blah.txt") is always the same IO action
06:26:14 <ertes> Aruro: remember that the result of readFile is *not* a string
06:26:17 <merijn> stephAne_: But I have a meeting now, I'm sure others here can help you, though :)
06:26:25 <ogrady> For how long on average does one have to use haskell until one doesn't go to hoogle.com instead of haskell.org/hoogle any more?
06:26:32 <brynedwards> :D
06:26:39 <Aruro> ertes: well u just shifted logical meaning towards IO Something being not something
06:26:43 <stephAne_> I'm going back at it with your remarks, thanks
06:26:53 <ogrady> *.org
06:27:11 <ertes> Aruro: an IO action is something fundamentally different from its result‚Ä¶  see the /bin/ls quote
06:27:12 <merijn> ogrady: I setup chrome so that "h <search term>" in my address bar just directly searches hoogle ;)
06:27:26 <merijn> ogrady: Pretty sure firefox let's you do the same :)
06:27:29 <Aruro> but r <- readFile x is not pure function in Mathematical sense as a function from x to r
06:27:33 <mniip> 1491225977 [16:26:17] <Aruro> ertes: well u just shifted logical meaning towards IO Something being not something
06:27:36 <mniip> that's the entire idea
06:27:42 <ogrady> merijn: that's what I'm about to do. Just trips me up every time
06:27:49 <mniip> Aruro, you can't write r <- readFile x in haskell
06:28:24 <ertes> Aruro: let's use a valid example:  do l <- getLine; putStrLn l
06:28:37 <Aruro> no
06:28:41 <Aruro> there is no argument
06:28:44 <Aruro> add argument
06:28:58 <ertes> Aruro: do s <- readFile "blah.txt"; putStr s
06:29:00 <ertes> better?
06:29:19 <mniip> I think they mean \x -> do s <- readFile x; putStr s
06:29:21 <ertes> (of course putStr(Ln) takes an argument itself, but nevermind) =)
06:29:38 <ertes> it's difficult to tell what they mean =)
06:29:39 <Aruro> mniip: yes
06:29:41 <ertes> ok
06:29:55 <Aruro> argument is passed to readFile
06:29:55 <ertes> (\fp -> do s <- readFile fp; putStr s)
06:29:59 <ertes> good?
06:30:03 <Aruro> yes
06:30:28 <Aruro> from fp to s
06:30:29 <ertes> (\fp -> do s <- readFile fp; putStr s) "blah.txt"  -- this is the same IO action every time you write it
06:30:55 <Aruro> and we are not they :D
06:31:13 <ertes> indeed, you can replace ((\fp -> do s <- readFile fp; putStr s) "blah.txt") by (do s <- readFile "blah.txt"; putStr s) and get the same program every time
06:31:40 <ertes> the point is: you're substituting IO actions, not their results
06:32:08 <Aruro> ertes: i think u want to say that pure implies ref transp but ref transp does not require pure? 
06:32:20 <ertes> Aruro: no
06:32:27 <ertes> purity is a vague term
06:32:34 <Aruro> i gave wiki link
06:32:39 <Aruro> written by haskell folk
06:32:41 <Aruro> https://wiki.haskell.org/Pure
06:32:53 <ertes> and referential transparency is something from linguistics i'm not even sure i understand whether it can be used for a language like haskell
06:33:20 <mniip> Aruro, purity implies every function can be implemented with a mathematical function
06:33:29 <mniip> and that is not different for readFile
06:33:44 <ertes> mniip: however, purity implies that you can use equations
06:33:46 <mniip> hence readFile is pure
06:33:47 <Aruro> it will give different results depending on the content of the file
06:33:52 <mniip> no?
06:33:56 <mniip> it will not
06:33:57 <ertes> it does not make sense to write something like (f() = g()) in javascript
06:34:04 <ertes> but in haskell it makes sense to say (x = y)
06:34:32 <ertes> Aruro: (readFile "blah.txt") does not depend on the file's contents
06:34:42 <Aruro> (\fp -> do s <- readFile fp; putStr s)
06:35:00 <mniip> that function is also pure
06:35:02 <Aruro> this function from fp to s, can give different results on the same fp
06:35:05 <mniip> no
06:35:06 <mniip> it is not
06:35:11 <Aruro> late on in time?
06:35:16 <Aruro> i changed the file
06:35:23 <mniip> it is a function from String to IO ()
06:35:39 <mniip> for the same string
06:35:43 <mniip> it produces the same IO ()
06:35:53 <ertes> Aruro: even if you change the file contents during the run-time of the program (readFile "blah.txt") will still be the same IO action
06:36:11 <ertes> it will still be the IO action that reads the file's contents
06:36:19 <mniip> Aruro, you cannot conflate functions (a -> IO b) with functions (a -> b)
06:36:32 <Myrl-saki> I think the "interpreter" "definition" of IO might help.
06:36:47 <Iceland_jack> yes
06:36:57 <Aruro> mniip: yeah, u just removed IO a-> a functions, what are we talking about then ? :D
06:37:04 <Aruro> so long
06:37:17 <ertes> Aruro: what Myrl-saki is trying to say is that you might interpret IO as this:  data IO :: * -> * where GetLine :: IO String; PutStr :: String -> IO (); ‚Ä¶
06:37:17 <Aruro> all my functions return () therefore im golden
06:37:32 <mniip> there isn't an IO a -> a function (*)
06:37:35 <ertes> Aruro: in other words: IO does not have any side effects
06:37:55 <ertes> it's just a DSL
06:38:21 <Aruro> simply beacuse main is always ()
06:38:30 <Iceland_jack> (PutStr "hello") versus (PutStr "hello")
06:38:31 <Myrl-saki> Welp.
06:38:35 <Myrl-saki> Aruro: Nope.
06:38:57 <mniip> Aruro, you're trying to prove that IO is impure
06:39:01 <Myrl-saki> Aruro: Basically, IO is just a "structure" of the program.
06:39:11 <Aruro> in above example putStrLn was Discarded as result of program and () was proclaimed as result, problem solved :)
06:39:13 <mniip> let's define a set of axioms of purity
06:39:20 <ertes> haskell has composable first-class actions:  getLine is the action that reads a line from stdin, (putStrLn s) is the action that writes s to stdout, (getLine >>= putStrLn) is the action that reads a line and then writes it to stdout
06:39:25 <Myrl-saki> Aruro: It's a "definition" of how the program will run. It's not how the program runs.
06:39:28 <Myrl-saki> Or something.
06:39:46 <ertes> Aruro: feel free to replace "action" by "program" or "recipe" or whatever
06:39:51 <ertes> getLine is *not* a string
06:40:03 <ertes> it's an action/program/recipe that would produce a string
06:40:12 <Aruro> ertes: btw lets look at its definition :) what is it?
06:40:13 <mniip> forall f :: X -> Y. forall x, y :: X.  x == y  implies f x == f y
06:40:24 <ertes> Aruro: doesn't matter
06:40:33 <mniip> Aruro, can you disprove this axiom in case of haskell?
06:40:55 <mniip> actually, let's be more explicit
06:41:01 <Myrl-saki> mniip: No swearing please.
06:41:02 <Myrl-saki>  /s
06:41:08 <mniip> forall X, Y :: Type. forall f :: X -> Y. forall x, y :: X.  x == y  implies f x == f y
06:41:30 <ertes> i would write "=" instead of "=="
06:41:45 <Iceland_jack> PARENTAL ADVISORY #haskell EXPLICIT LANGUAGE
06:42:05 <Myrl-saki> mniip: forall x :: X. forall y :: Y. ?
06:42:23 <mniip> x,y,z::t  is haskell syntax
06:42:27 <Aruro> ertes: ok lets sum up, what getLine is?
06:42:41 <Myrl-saki> mniip: Oh whoops. I misread.
06:43:10 <Aruro> ertes: u have to define what recepie is, is it a type?
06:43:33 <ertes> Aruro: a recipe that produces an X is a value of type IO X
06:43:53 <Myrl-saki> Aruro: It's an action that will return a String.
06:44:00 <Myrl-saki> s/return/produces/
06:44:20 <Aruro> so show is not action?
06:44:23 <Aruro> :t show
06:44:25 <lambdabot> Show a => a -> String
06:44:25 <Myrl-saki> Aruro: No.
06:44:29 <ertes> Aruro: correct
06:44:32 <Aruro> :)
06:44:34 <Myrl-saki> Err
06:44:38 <mniip> Show is not an action
06:44:40 <Myrl-saki> No meaning "no, it is not an action."
06:45:05 <Aruro> so whole program is pure?
06:45:08 <ertes> Aruro: 'show' is a value of type (Show a => a -> String), not a value of type (IO X) for some X
06:45:17 <Myrl-saki> Aruro: It's confusing, isn't it? xD
06:45:25 <Aruro> :)
06:45:27 <ertes> it's not that confusing, if you think really really simple
06:45:58 <Aruro> so all haskell programs are pure? right?
06:46:04 <ertes> Aruro: correct
06:46:06 <Aruro> since IO is pure, we are good
06:46:28 <Myrl-saki> Aruro: Okay, how about this. `int main (void) { printf("Hello world!"); }` should* result in the same code when compiled, right? (* not really)
06:46:39 <ertes> IO does not break purity, because haskell doesn't allow you to actually execute IO actions
06:46:54 <ertes> there is a good reason why there is no function of type (IO a -> a)
06:47:13 <Aruro> of course there is
06:47:17 <Aruro> only outside haskell
06:47:24 <Aruro> when haskell code is used as intermediate
06:47:24 <ertes> you could say that
06:47:30 <Myrl-saki> Aruro: You seem to be starting to get it.
06:47:55 <ertes> Aruro: but it's not really a haskell function of type (IO a -> a)‚Ä¶  it's really just a process outside of haskell that has no in-language counterpart
06:49:01 <Aruro> so all haskell programs are functions of the type a-> IO ()?
06:49:19 <ertes> a haskell program is typically of type (IO ()), namely the 'main' action
06:49:22 <Myrl-saki> Aruro: Just IO ()
06:49:24 <Iceland_jack> All Haskell programs are (IO a)
06:49:44 <AlexRnd_> Hello! I'm trying to use stack to script my ghc program for the first time and got an error which recommends to add some packages to extra-deps. Details are here - https://pastebin.com/PyRMQtqw , any suggestions?
06:49:50 <ertes> 'main' can actually have a different result type, because the result of 'main' is ignored
06:50:02 <ertes> main :: IO String  -- so this is allowed, but the resulting String is ignored
06:50:27 <Aruro> when i type ghc MyGreatCode , isnt ghc :: a -> IO () ?
06:50:43 <Iceland_jack> what is the 'a'
06:50:51 <Aruro> String?
06:50:51 <Myrl-saki> Aruro: More like IO () -> Obj
06:50:53 <Myrl-saki> I think.
06:50:57 <Myrl-saki> Oh.
06:51:03 <ertes> Aruro: there is nothing in haskell that corresponds to the "ghc" command
06:51:07 <ertes> unless you could 'id'
06:51:16 <ertes> *count
06:51:39 <Iceland_jack> Aruro: Not within the Haskell language, but you can think of runhaskell as such
06:51:43 <Myrl-saki> @hoogle (String -> IO ())
06:51:44 <lambdabot> Prelude putStr :: String -> IO ()
06:51:44 <lambdabot> Prelude putStrLn :: String -> IO ()
06:51:44 <lambdabot> Debug.Trace traceIO :: String -> IO ()
06:52:10 <shiona> what's the philosophy of return codes from programs in haskell? To me it would make sense to have main :: IO Word8 (although that might be too environment-specific)
06:52:31 <ertes> Aruro: you could imagine a highly magic function of type (IO a -> ByteString) that takes an IO action and produces a compiled program
06:52:50 <ertes> Aruro: but i would question that it makes much sense
06:53:19 <ertes> such a function would have to produce an infinite ByteString for something like (forever (putStrLn "blah"))
06:53:25 <Iceland_jack> shiona: You use special functions for that (exitWith (ExitFailure 4)) just like program arguments
06:53:59 <Iceland_jack> Main could in theory be defined "[String] -> IO Word8"
06:54:14 <Iceland_jack> :)
06:54:23 <ertes> shiona: a 'main' that executes to the end can be interpreted as successful, therefore exitWith actually throws an exception
06:54:47 <Myrl-saki> @hoogle (IO String)
06:54:47 <lambdabot> Prelude getLine :: IO String
06:54:48 <lambdabot> Prelude getContents :: IO String
06:54:48 <lambdabot> System.Environment getProgName :: IO String
06:54:55 <Aruro> ertes: mniip: ty was interesting discussion
06:55:24 <ertes> shiona: some libraries unfortunately abuse IO exceptions for *successful* exits though, like many command line option parsers
06:55:35 <ertes> (for stuff like "--help")
06:56:56 <Myrl-saki> I forgot how to free monads lmao
06:57:04 <lpaste> mniip pasted ‚ÄúIO‚Äù at http://lpaste.net/354241
06:57:04 <mniip> Aruro, take a look at this
06:57:24 <mniip> this is a pure implementation of IO
06:57:40 <mniip> with a separate function that "converts" our pure IO into haskell's built-in IO
06:59:33 <Aruro> mniip: nice
07:00:11 <mniip> I could write a readFile in the same fashion
07:00:15 <mniip> and it would definitely be pure
07:01:51 <Myrl-saki> I was writing one with free monads. <.<
07:01:54 <Aruro> nice Join :)
07:07:31 <ertes> Myrl-saki: https://gist.github.com/esoeylemez/93aa5b1553a76469b63d50a2d15eb694
07:08:05 <Myrl-saki> Oh cool. I wasn't too far off.
07:08:37 <ertes> i used the church-encoded Free, because 'compile' is easier to write
07:08:40 <Myrl-saki> http://ix.io/pxU
07:09:00 <Myrl-saki> I was able to define a functor, but died in the end.
07:09:41 <ertes> Myrl-saki: putStr' :: String -> Interpreter' ()
07:10:03 <ertes> putStr' s = liftF (PutStr s ())
07:10:32 <ertes> note: i tend to put the continuation argument first, because it makes those actions a bit nicer to write
07:10:44 <ertes> putStr' = liftF . PutStr ()
07:11:39 <ertes> oh, and of course the actual type of putStr' can abstract over the underlying free monad constructor =)
07:11:43 <Myrl-saki> ertes: Pointfree best freee.
07:11:51 <ertes> putStr' :: (MonadFree Interpreter' m) => String -> m ()
07:11:58 <Myrl-saki> ertes: Thanks.
07:12:00 <ertes> now you can use putStr' with F, Free, FreeT and FT
07:12:35 <Myrl-saki> ertes: I forgot how Free is defined. Whoops.
07:12:50 <ertes> most of the time it doesn't even matter =)
07:13:02 <ertes> it matters sometimes for interpreters, but very often you can just use iter/iterT
07:13:17 <Myrl-saki> ertes: True, but it would have helped me make the code. :P
07:13:50 <Myrl-saki> Like, I literally forgot everything about Free except `instance (Functor a) => Monad (Free a)`
07:14:25 <ertes> instance Monad (F f)  -- =)
07:14:48 <Myrl-saki> ertes: :o It doesn't need a functor instance?
07:14:53 <ertes> nope
07:15:01 <lyxia> "Functor a" makes me a bit uncomfortable
07:15:23 <lyxia> fmap :: (f -> g) -> (a f -> a g)
07:15:24 <Myrl-saki> lyxia: lmao. I just realized it when I said it.
07:15:33 <Myrl-saki> lyxia: /o\
07:15:43 <Myrl-saki> lyxia: How to get banned from a Haskell convention.
07:17:43 <ertes> "i wrote an implementation of the factory/facade pattern in haskell, with full dependency injection‚Ä¶  it uses singletons (not the kind of singletons you're thinking of, but REAL singletons)"
07:18:57 <ystael> ertes: because everybody knows all awesome software contains Spring -- you can't be awesome if you don't have Spring
07:21:53 <mniip> wow
07:21:58 <mniip> C++17 is going algebraic
07:22:20 <dzdcnfzd> Once again, I'm working with SQL, and once again, I'm desperately wishing that it made select statements / joins / where conditions first class objects that could be manipulated on their own and combined, copied, etc... using variables. Is there a Haskell library that does this sort of thing?
07:22:59 <mniip> std::variant being a disjoint union type
07:23:08 <brynedwards> dzdcnfzd: esqueleto , opaleye if you're using postgresql
07:23:08 <dzdcnfzd> I don't want to have something that takes care of fetching results for me or packing them into records or anything. I just want to be able to manipulate SQL syntax programmatically
07:28:10 <dzdcnfzd> brynedwards: thanks!
07:28:32 <brynedwards> np
07:52:01 <erisco> is there a modern package for finding prime factors?
07:52:11 <kuribas> the ghci debugger sucks so much...
07:53:02 <cocreature> I‚Äôve been meaning to try using the ghci debugger but I always just use printf debugging because I‚Äôm too lazy to figure out how to use it
07:54:10 <kuribas> cocreature: I wish you could tell it which parts of the evaluation graph to descend, and which to simply force.
07:54:13 <shapr> I like to write tests.
07:54:41 <cocreature> shapr: but what do you do if a test fails? :)
07:55:01 <shapr> Usually I have enough tests that I know how to fix it.
07:55:13 <kuribas> shapr: I have this big stateful algorithm, it's hard to test.
07:55:16 <shapr> oh
07:55:23 <shapr> No way to break it into pieces?
07:55:36 <kuribas> I guess I should...
07:55:43 <shapr> I've heard that debuggers cover a different part of ... programming? than tests, but I don't get it.
07:58:31 <cocreature> shapr: well it‚Äôs more about when you want to know intermediate states in your tests instead of just knowing that the final result is incorrect. in some cases splitting your test up so that this is not necessary is not possible or more work than just using a debugger
07:58:44 <kuribas> I have a set of curves, and a new curve which should be added to it, but for some reason it doesn't...
07:58:57 <kuribas> With a proper debugger I should find the reason quickly...
07:59:09 <Cale> kuribas: There was a tool (or set of tools) called hat which could do this
07:59:32 <cocreature> tbh 99% of the time when I‚Äôm opening gdb/lldb I just want to fix a segfault :)
08:00:43 <dolio> Someone was still developing hat up to 2015.
08:00:49 <dolio> But it seems to have stopped again.
08:01:09 <kuribas> The thing I miss in ghci is fine grained control.
08:01:18 <erisco> you could say it hit a break point
08:01:42 <kuribas> erisco: If you know the precise location of the error
08:02:02 <dolio> No, that was a pun.
08:02:13 <shapr> hit a breakpoint?
08:02:26 <Cale> Hat's development did ;)
08:02:47 <kuribas> dolio: oh, right :)
08:02:57 <dolio> Except I'm not sure hat has breakpoints. That's not the debugging model it's going for mostly.
08:02:58 <erisco> has that been portmanteau'd already? okay
08:03:27 <Cale> Yeah, it's mostly about unfolding evaluation interactively
08:03:38 <kuribas> dolio: isn't it just a big dump of the whole execution trace?
08:04:13 <dolio> Yeah, with tools to interact with it.
08:04:18 <geekosaur> wasn't hat replaced by hood/ghood which in turn was replaced by ghc-vis?
08:04:42 <geekosaur> specifically because hat does evil things that break with every new ghc?
08:05:00 <dolio> geekosaur: If so, that's confusing, because the hat page says it has stuff inspired by hood.
08:05:11 <geekosaur> would guess that's a backport
08:05:24 <erisco> cabal install primes
08:05:36 <geekosaur> by whoever picked it up again after its hiatus
08:05:38 <Cale> Hood and Hat have been developed in parallel over a long period of time
08:05:45 <erisco> after that compiles I just need to cabal install composites and I'll have all the integers defined
08:06:19 <Cale> In fact, both were already around when I started programming in Haskell :)
08:12:19 <kuribas> this looks interesting: https://wiki.haskell.org/Hoed
08:13:25 <erisco> > partition False [1]
08:13:27 <lambdabot>  error:
08:13:27 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äòa -> Bool‚Äô with actual type ‚ÄòBool‚Äô
08:13:27 <lambdabot>      ‚Ä¢ In the first argument of ‚Äòpartition‚Äô, namely ‚ÄòFalse‚Äô
08:14:19 <ventonegro> > partition (const False) [1]
08:14:21 <lambdabot>  ([],[1])
08:17:42 <stephAne_> hi, in this code http://lpaste.net/354242 , can someone indicates me why I can write let newVal = f mVal    at line 12,  for me mVal is not of type s, but of type m(a,s), thus could not be a parameter of f :: s -> s. I'm still stuck at this point.
08:18:18 <Cale> because mVal :: s
08:18:57 <Cale> stephAne_: mVal is the result of executing get, which is an action whose result has type s
08:19:38 <geekosaur> stephAne_, look at the desugaring in the comment below, and look at the type of (>>=)
08:19:42 <geekosaur> :t (>>=)
08:19:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:20:28 <stephAne_> but get :: Monad m => MyStateT s m s , contains a function which returns (s,s), not s, isn't it ?
08:20:47 <stephAne_> m(s,s) I meant
08:20:47 <glguy> stephAne_: As a technicality, note that let doesn't desugar into a lambda like that, even though it works out in this case to be the same
08:20:49 <Cale> Internally, but that's an implementation detail
08:21:00 <ph88> hey guys, i want to send commands to a device, but some sequences of commands are invalid, how can i build some software that checks the sequence before it executes?
08:21:41 <glguy> ph88: You can build some software using Haskell
08:21:42 <Cale> ph88: Well you see, you build some software that checks the sequence before it executes.
08:22:40 <ph88> i can interpret it using haskell, but what language ? i can't ask other people to write haskell sorry
08:22:49 <stephAne_> So in fact I don't understand the get, how it can returns an s, instead of m(s,s)
08:22:56 <geekosaur> stephAne_, you're confusing the monad with its result
08:22:59 <Cale> stephAne_: Look at its type
08:23:05 <Cale> What is the type of get?
08:23:19 <stephAne_> MyStateT s m s
08:23:23 <Cale> right
08:23:26 <ventonegro> stephAne_: modify just builds a chain of function calls, `s` will be provided in the future
08:23:31 <geekosaur> or rather confusing the monad with its desugaring
08:23:44 <Cale> So this is M s for our monad M = MyStateT s m
08:23:46 <ventonegro> stephAne_: when it comes, >>= will pass it around
08:23:57 <Cale> So its result simply has type s
08:24:18 <Cale> Don't worry about the internal details of how it's implemented at all
08:24:20 <stephAne_> as if type s = MyStateT s m s
08:24:25 <Cale> hm?
08:24:26 <Cale> No.
08:24:28 <stephAne_> or MyStateT s' m s'
08:24:38 <Cale> Nope, there's only one s
08:25:15 <Cale> stephAne_: In a do-block for some monad M, when you write:
08:25:16 <Cale> v <- x
08:25:24 <Cale> If x :: M t, then v :: t
08:25:45 <stephAne_> ohhhhhhhhh i get it
08:25:49 <stephAne_> many thanks
08:25:51 <Cale> You can read that as "let v be the result of executing x"
08:26:50 <stephAne_> sorry for insisting, moment of illumination
08:27:54 <ventonegro> insisting till understanding is good
08:28:19 <ventonegro> unless your brain starts to hurt, then a pause is also good
08:29:48 <erisco> I don't think you have nerve endings in your brain
08:30:19 <ventonegro> interesting... how do headaches work then?
08:32:21 <erisco> probably similar to a brain freeze
08:32:40 <geekosaur> over (or sometimes inside; see: sinuses) the skull, not under
08:33:49 <ventonegro> so pretend I just meant "headache"
08:35:04 <ventonegro> the hardest part for me when first learning State was to always keep in mind that the actual state would only come later
08:36:53 <erisco> > (fmap (product *** product) . zipWith splitAt [0..] . repeat) [2,2,5,5]
08:36:55 <lambdabot>  [(1,100),(2,50),(4,25),(20,5),(100,1),(100,1),(100,1),(100,1),(100,1),(100,1...
08:37:02 <erisco> thought that was fun :)
08:37:22 <erisco> um, hm, slight mistake :P
08:37:28 <michi7x7> erisco: is that arrows?
08:37:50 <erisco> well I tried to work around an aux definition using zipWith and splitAt
08:37:57 <erisco> but it is supposed to just give you the partitions
08:38:30 <Iceland_jack> michi7x7: (***) is from Control.Arrow, but Data.Bifunctor.bimap does the same thing in this case
08:40:25 <Iceland_jack> @ty [(***), bimap]
08:40:27 <lambdabot> [(b -> c) -> (b' -> c') -> (b, b') -> (c, c')]
08:40:44 <erisco> though it is sensitive to ordering. I miss (10, 10) for example
08:41:16 <rotaerk> hmm, how important was it for the restriction that types start with capital letters and values start with lower-case letters? as in if that restriction were suddenly lifted, what else would have to change to compensate?
08:41:38 <glguy> rotaerk: There's no such restriction that types start with capitals and values start with lowercase
08:41:52 <Athas> rotaerk: you need some other way of doing certain syntactic disambiguation.
08:41:52 <rotaerk> oh is that just convention?
08:42:07 <glguy> rotaerk: No, what you wrote just isn't the case. Maybe you meant something different?
08:42:11 <Athas> rotaerk: no, there is a lexical distinction, but the rule is more complicated than that.
08:42:37 <Athas> glguy: I feel what is important in the question is not the specifics of the rule, but the purpose it serves.
08:42:38 <itachi> Hi if I write "let ioi = readIO "1" :: IO Integer"
08:42:53 <itachi> Is there anyway to use "show ioi"
08:42:55 <kuribas> > (-1) <$> Just 1
08:42:56 <itachi> ?
08:42:57 <lambdabot>  error:
08:42:57 <lambdabot>      ‚Ä¢ Could not deduce (Num a0)
08:42:57 <lambdabot>        from the context: (Num (a -> b), Num a)
08:43:02 <glguy> Athas: The question as written is just based on a completely false assumption
08:43:11 <Iceland_jack> itachi: fmap show ioi
08:43:24 <glguy> Athas: so it's important to understand what is meant before guessing the answer
08:43:30 <Iceland_jack> fmap show (readIO "1" :: IO Integer) --> "1"
08:43:44 <rotaerk> well now I have two questions then...
08:43:53 <itachi> Thanks Iceland_jack
08:43:58 <Iceland_jack> you're welcome
08:44:07 <kuribas> why would (-1) <$> Just 1 give Just (-1)?
08:44:26 <rotaerk> 1) if there were no lexical distinction between type-names and value-names, what would break, what would have to be done to compensate?
08:44:44 <rotaerk> 2) what exactly is that lexical distinction if not for the case of the starting character
08:44:49 <Athas> rotaerk: consider a type ascription like 'x : Foo a.  With the current rules, you know that 'a' is a type variable.  Without it, maybe it's some type 'a' in scope.  Maybe 'Foo' is a type variable, too.
08:45:30 <glguy> rotaerk: constructors are capitalized, variables are lowercased. When a type signatures uses variables we know they are unique to that type signature, but that the type constructors are not
08:45:54 <Athas> rotaerk: Pattern-matching also becomes more complicated.  Maybe a function clause 'f x = x' is a binding of the variable 'x' to any value, and maybe it's matching the constructor 'x'.
08:46:01 <Athas> (Standard ML has this latter problem, and it's a mess.)
08:46:05 <glguy> at the value level, constructors can be used in patterns as their own identity while variables introduce new names
08:46:07 <lyxia> are we talking about values vs types or constructors vs variables
08:46:45 <monochrom> constructors vs variables
08:47:17 <rotaerk> got it; thanks
08:47:23 <Athas> Haskell's solution is very elegant.  I believe OCaml does it that way, too.
08:48:11 <monochrom> SML did a right thing at the type level. x is a type constructor. 'x is a type variable.
08:48:32 <monochrom> Imagine going the last step of doing it at the value level too :)
08:48:45 <ystael> were those apostrophes originally intended as an ASCII shorthand for Greek letters?
08:48:46 <Athas> I think Haskell's approach is prettier.  Although my favourite approach is to require explicit quantification of type variables, like Purescript does it.
08:48:55 <Athas> ystael: yes.
08:48:57 <monochrom> Yes I think so.
08:49:13 <Athas> Although I don't think they imagined that it would ever be possible (like the modern Unicode shenanigans in Haskell).
08:49:33 <ystael> agda syntax is best syntax :D
08:49:51 <ystael> your code is not awesome until you need a TeX symbol translator to type it
08:50:19 <erisco> so I need the partitions of all the rotates as well
08:50:23 <lpaste> mtesseract pasted ‚ÄúHeterogeneous Maps‚Äù at http://lpaste.net/354243
08:51:11 <rotaerk> I was just wondering because someone mentioned to me that there have been times when haskellers got frustrated over being unable to use upper-case greek letters as variable names
08:51:24 <rotaerk> so I wondered what would be the harm in lifting that restriction
08:51:25 <kuribas> how is (-1) <$> Just 1 not a type error (in my ghci session)?
08:51:33 <Athas> That does sound like something only a Haskeller could get upset about.
08:51:46 <Athas> I guess it would be harmless to lift it for non-ASCII letters.
08:51:56 <erisco> kuribas, what does it evaluate to?
08:52:01 <mtesseract> Hi. I have a question regarding the above pastebin (http://lpaste.net/354243). I am trying to implement heterogeneous maps, but I am wondering if that could be done without OverlappingInstances. The issue is that I have two instances for HMapContains. Is there another way to "propagate" this existence of a key/value pair without such a rather hacky solutions (or is it not to be considered hacky?)?
08:52:04 <glguy> kuribas: Because you have the Num instance in scope for functions
08:52:13 <kuribas> erisco: Just (-1)
08:52:59 <ertes> rotaerk: well, uppercase letters are used for constructors
08:53:00 <glguy> kuribas: You can use ':i Num' to see all the Num instances as well as the module that's defining an instance on `(->) a`'
08:53:08 <Iceland_jack> kuribas: it's using a Num (a -> b) instance
08:53:17 <glguy> oops, left of a variable there
08:53:29 <rotaerk> ertes, yep, that's what they were saying above
08:53:30 <glguy> and a letter off of of
08:53:35 <kuribas> glguy: it says NumInstances-1.4:Data.NumInstances.Function
08:53:37 <rotaerk> constructors vs variables, not types vs values
08:53:41 <glguy> kuribas: mystery solved!
08:53:41 <Iceland_jack> there you go
08:53:47 <Iceland_jack> Drinks are on me!
08:53:50 <ertes> rotaerk: in order to allow that, it would require a special case, and i would actually mind more special cases
08:53:54 <lyxia> mtesseract: I don't think overlapping instances is *that* hacky
08:54:01 <erisco> I am not sure how the Num instance for functions makes that type check
08:54:08 <lyxia> mtesseract: especially if it remains within a single module
08:54:34 <ertes> rotaerk: we already have enough special cases of that sort (for example type operator variables are no longer possible, because at some point they decided to allow arbitrary operator symbols for type constructors)
08:54:39 <erisco> (<$>) :: Functor f => (a -> b) -> f a -> f b
08:54:55 <erisco> ah, because (-1) is polymorphic
08:55:01 <erisco> that's sneaky lol
08:55:05 <Iceland_jack> (-1) becomes "const (-1)"
08:55:18 <lyxia> mtesseract: I just wrote something very similar yesterday, but I didn't think of tracking the keys in the types. https://github.com/Lysxia/type-map/blob/master/src/Data/TypeMap/Internal.hs
08:55:27 <mtesseract> lyxia: Hmm. Thanks for the comment. I am not really familiar with type-level programming, so I'm not sure if I'm missing something obvious here. :-)
08:55:31 <erisco> I am not sure how I feel about that
08:55:34 <ertes> rotaerk: something like (C (-->) a b -> a --> b) used to be possible, but it no longer is, because (-->) can now be a type constructor
08:56:09 <erisco> it defines number application, and that is weird
08:56:34 <erisco> i.e.  1 2 = 1
08:56:35 <mtesseract> lyxia: Yeah, I wanted to get rid of the "Maybe" during a lookup so that it more resembles a record created at runtime.
08:56:51 <rotaerk> hah
08:57:55 <ertes> i guess type operator variables are rare enough, but i did use them quite extensively at one point, and i had to rewrite a lot of code when that change happened
08:58:18 <mtesseract> lyxia: I think there is a general pattern behind this kind of "HasXY"-classes. They can easily be implemented inductively. This means, as I see it, two instance declarations.
09:02:20 <Aruro> :t fmap 1 Just 1
09:02:21 <lambdabot> (Num (Maybe t -> t1), Num t) => t1
09:02:30 <Aruro> :t fmap 1 (Just 1)
09:02:31 <lambdabot> (Num (a -> b), Num a) => Maybe b
09:02:57 <lyxia> mtesseract: yes indeed, but I think you'll still need some form of overlappingness at some level
09:03:09 <erisco> ah, fun! you can find all the rotations just from the partitions
09:03:34 <mtesseract> lyxia: Thank you for your input
09:03:55 <Aruro> :t fmap (1 Just) 1
09:03:57 <lambdabot> (Num ((a -> Maybe a) -> a1 -> b), Num (f a1), Functor f) => f b
09:04:04 <erisco> > partitions [1..4]
09:04:06 <lambdabot>  [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([4,3,2,1],[])]
09:04:12 <erisco> see where the rotations are? :)
09:05:29 <lyxia> mtesseract: the hlist package (Data.HList.HList module) has stuff you can reuse here.
09:06:35 <infandum> Is there a way to read a function? Like, read "take 2" :: ([a] -> [a])?
09:06:41 <Iceland_jack> no
09:07:04 <infandum> Iceland_jack: So there is no way to have a function as a command line input to a program?
09:07:25 <erisco> > fmap (uncurry (++) . swap) . partitions $ [1..4]
09:07:28 <lambdabot>  [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3],[4,3,2,1]]
09:07:42 <glguy> infandum: There are packages for helping you to use GHC as a library like mueval and hint
09:08:50 <Aruro> infandum: problem with types, different functions with have different types
09:08:54 <Iceland_jack> infandum: First ask if you need the full power of Haskell
09:09:29 <Iceland_jack> Do you want to support arbitrary functions or some domain-specific subset
09:10:02 <monochrom> Yeah, if your usage is limited, it may be more lightweight, and also less security vulnerability, to parse and interpret yourself.
09:10:08 <infandum> Iceland_jack: I want to let the user input any function they want with type (Data.Sequence Text -> Text)
09:10:13 <mtesseract> lyxia: I was actually having a look at precisely this module, but didn't find anything helpful for me at first glance (neither did I see something about overlap), but I will check again.
09:10:54 <infandum> monochrom: I would be most worried about security.
09:11:40 <infandum> monochrom: But if it's a pure function, there *should* be nothing to worry about
09:11:48 <infandum> of that type
09:11:49 <Iceland_jack> infandum: Do you want to parse lambdas? How do you use the resulting function
09:12:25 <Iceland_jack> Lambdas like (\_ -> "hi")
09:12:43 <infandum> Iceland_jack: That would be fine, yes
09:12:44 <erisco> > nub . fmap (product *** product) . concatMap partitions . rotations $ [2,2,5,5]
09:12:47 <lambdabot>  error:
09:12:47 <lambdabot>      Variable not in scope: rotations :: [Integer] -> [[t]]
09:12:57 <Iceland_jack> Hm
09:13:06 <erisco> > nub . fmap (product *** product) . concatMap partitions . rotations $ [2,2,5,5]
09:13:08 <lambdabot>  [(1,100),(2,50),(4,25),(20,5),(100,1),(10,10),(50,2),(5,20),(25,4)]
09:13:41 <lyxia> mtesseract: HMember seems relevant, I'm not sure how to use it, but it uses HEq which has the two overlapping instances.
09:13:43 <glguy> mtesseract: A minor adjustment I'd recommend for your HMapContains class would be to make the class method have type  hMap -> proxy key -> valType, rather than making instances with (proxy key) as one of the matched parameters
09:13:44 <erisco> probably not the best way to do it
09:15:31 <monochrom> infandum: If you use mueval or hint, and you check the type, and you know that unsafePerformIO is not imported, then yes.
09:15:57 <infandum> monochrom: I'm looking at hint right now (holy moly it's amazing what you can do)
09:16:21 <infandum> I just need to figure out how to use it
09:17:27 <infandum> It's looks like I would have to run another interpreter inside the program though, that might be a bit overkill and slow performance down...
09:17:40 <mtesseract> glguy: Thanks
09:18:36 <glguy> mtesseract: Are you aware of the vinyl package? It seems to address a similar problem.
09:18:50 <geekosaur> infandum, yes, haskell is not interpreted, and even if you could so imputting machine code at the terminal is painful 
09:19:38 <geekosaur> (and wouldn't help much since most functions don't actually work that way in ghc... they're labeled STG graph nodes)
09:22:39 <infandum> geekosaur: Maybe I should just provide a bunch of different pre-coded methods and the user can choose
09:22:52 <mtesseract> lyxia: I'm looking at it!
09:23:28 <mtesseract> glguy: Yes, looked at it briefly.
09:27:35 <erisco> give them K and S and let them at it
09:33:31 <nbro> hi guys
09:33:41 <nbro> I have a Java program to tokenize
09:33:51 <nbro> do you have any idea what‚Äôs meant by "which tokens should get associated lexical values?"
09:34:01 <nbro> what‚Äôs exactly a lexical value?
09:35:37 <erisco> if I was to guess I'd say it was a token, heh
09:36:59 <erisco> maybe they mean, for example, an integer is a lexical value and an INTEGER token maybe associated with this value
09:38:07 <erisco> so whatever intermediate values there are to construct tokens with
09:47:58 <monochrom> nbro: I am going to guess, too, take it with a grain of salt. If I am to write an algebraic data type for tokens, it may go like "data Token = It'sAComma | It'sANumber Integer | It'sAnIdentifier String | It'sADoubleQuote | ..."
09:49:09 <monochrom> in which the It'sANumber case and the It'sAnIdentifier case are associated with values, whereas It'sAComma and It'sADoubleQuote are not.
09:50:09 <erisco> that is more or less what I meant
09:50:22 <monochrom> If the input string is like "5,v", my token stream will be like [It'sADoubleQuote, It'sANumber 5, It'sAnIdentifier "v", It'sADoubleQuote]
09:50:42 <nbro> monochrom: ok, but that depends on the implementation of the lexer
09:50:49 <nbro> this is actually a manual exercise
09:51:19 <nbro> so I cannot know which "lexical values" are associated with a token if not in the context of a lexer or scanner
09:57:53 <erisco> monochrom, do you prefix all your tokens with It'sA ?
09:59:17 <rotaerk> data Mario = It'sAMe
10:01:46 <lep-delete> i compiled some .hs file to an .o file. how can i load this file in ghci
10:01:56 <lep-delete> loading the .hs-file is bad since it takes very long to compile
10:02:13 <itachi> guys why does "fmap (*2) $ Just 2" work but not "fmap (*2)  Just 2" ?
10:02:31 <shapr> :t fmap
10:02:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:03:03 <lep-delete> doing just `ghci compiled.o` doesn't work
10:03:33 <monochrom> erisco: I was being silly. :)
10:03:52 <infandum> :t flip fmap
10:03:53 <lambdabot> Functor f => f a -> (a -> b) -> f b
10:04:35 <infandum> :t fmap (*2) Just 2
10:04:37 <lambdabot> (Num (Maybe t), Num t) => Maybe t
10:05:07 <infandum> fmap (*2) (Just 2)
10:05:08 <erisco> itachi, because  fmap (*2) Just 2  is  ((fmap (*2)) Just) 2
10:05:16 <infandum> :t fmap (*2) (Just 2)
10:05:17 <lambdabot> Num b => Maybe b
10:05:25 <robkennedy> Itachi: the second thing would have fmap as a function of three values whose second argument is `Just` and whose third arg is 2
10:06:04 <itachi> ohh makes sense. I usauly get confused with the order
10:06:13 <erisco> with the association
10:06:27 <erisco> which is left-associative for function application
10:07:38 <itachi> when a fuction is defined as a->b->c->d it is  ((a->b)->c)->d right?
10:07:39 <robkennedy> > fmap (+3) (*5) 10
10:07:42 <lambdabot>  53
10:07:59 <robkennedy> Oh crazy didn't know that would work. I don't like it tho
10:08:33 <itachi> Things like these get me confused :/
10:09:04 <rotaerk> > (+3) <$> (*5) $ 10
10:09:06 <lambdabot>  53
10:09:20 <itachi> How do we get the order in which function will apply?
10:09:31 <lyxia> itachi: it's the other way around. a -> (b -> (c -> d))
10:09:34 <erisco> itachi, no, -> associates to the right
10:10:02 <itachi> So what associates to left?
10:10:11 <erisco> many things, such as function application
10:10:31 <itachi> what do you mean be function application?
10:10:37 <erisco> f x
10:10:45 <infandum> 2 ^ 2 ^ 3
10:10:55 <infandum> one day it'll listen to me
10:11:25 <jle`> infandum: for normal function application, it associates from the left
10:11:28 <jle`> * itachi 
10:11:38 <jle`> itachi: so f x y z is ((f x) y) z
10:11:40 <ertes> itachi: f x y = (f x) y
10:11:45 <erisco> when you juxtapose two expressions in Haskell that means to apply the left expression to the right expression
10:11:59 <jle`> f 1 2 3 4 5 is ((((f 1) 2) 3) 4) 5
10:12:07 <itachi> k
10:12:28 <ertes> itachi: and that's in correspondence with the right-associativity of (->):  a "function of two arguments" (A -> B -> C) is really a function of one argument that returns a function (A -> (B -> C))
10:12:42 <infandum> jle`: Which makes perfect sense with the right association with (->)
10:12:48 <ertes> itachi: so if you apply a function to an argument (f x), the result is a function that you can apply:  (f x) y
10:13:55 <itachi> so when I have two function supose f and g when using "f g x" what will happen?
10:14:01 <infandum> f takes in one argument, 1, returns a function that takes one argument, 2, etc., and in the type you have that same effect, but the parentheses are mirrored because that's how the function is typed (takes one argument, a, etc.)
10:14:15 <erisco> same thing, it is (f g) x
10:14:17 <jle`> infandum: that's (f g) x
10:14:21 <ertes> itachi: let's use a practical example:  'map' is a function that takes a function as its first argument
10:14:28 <ertes> > map sin [1,2,3]
10:14:29 <jle`> * itachi : that's (f g) x
10:14:31 <lambdabot>  [0.8414709848078965,0.9092974268256817,0.1411200080598672]
10:14:32 <jle`> do you see the pattern?
10:14:44 <jle`>   f 1 2 3 4 is (((f 1) 2) 3) 4
10:14:54 <jle`> so f g x a b is (((f g) x) a) b
10:14:55 <ertes> itachi: but:  map sin [1,2,3] = (map sin) [1,2,3]
10:14:56 <jle`> etc.
10:14:59 <infandum> :t (.)
10:14:59 <jle`> it doesn't matter what the variables are called.
10:15:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:15:09 <ertes> itachi: (map sin) is the function that applies the 'sin' function to each element of its argument list
10:15:28 <ertes> > (map sin) [1,2,3]
10:15:30 <lambdabot>  [0.8414709848078965,0.9092974268256817,0.1411200080598672]
10:15:34 <APic> sin > cos
10:15:45 <itachi> k. get it now :)
10:16:01 <jle`> btw, functions are just normal values in haskell
10:16:06 <APic> Good.
10:16:11 <ertes> itachi: keep in mind that functions in haskell only ever take exactly one argument =)
10:16:32 <APic> > (map sin [cos 1, cos 2, cos 3]
10:16:33 <infandum> itachi: That's what makes curry so powerful
10:16:34 <lambdabot>  <hint>:1:31: error:
10:16:34 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:16:41 <jle`> so saying "what happens when x is a value for (f x) vs. g is a function for (f g)" is silly, because functions in haskell *are* just values
10:16:42 <infandum> well it IS currying actually
10:16:44 <APic> > (map sin) [cos 1, cos 2, cos 3]
10:16:46 <jle`> so if it works for values, then it works for functions
10:16:47 <lambdabot>  [0.5143952585235492,-0.4042391538522658,-0.8360218615377305]
10:16:54 <APic> üôå
10:17:13 <erisco> help from the Haskell hydra
10:17:24 <ertes> swarm, not hydra
10:28:30 <johnw> jle`: except for 'case', perhaps?
10:39:44 <_sras_> How can I do this? http://lpaste.net/177974356595441664
10:40:59 <johnw> do you mean: mapM (\(Client amt payAmt) -> Client <$> convert amt <*> convert payAmt) listOfClients
10:41:45 <yhhko> _sras_: maybe you want to have a CurrencyRates data type for passing around the going rates for various currencies?
10:41:57 <yhhko> so you can read that once and use it often
10:42:22 <erisco> _sras_, updating items in a list is just creating a new list with the items updated
10:42:31 <erisco> _sras_, so this is just done with fmap
10:43:02 <_sras_> johnw: Doesn't that make one db call for every client?
10:43:49 <erisco> you can look at the Reader monad to store the currency conversion table
10:43:55 <erisco> can you retrieve the whole thing?
10:43:59 <mniip> hmm
10:44:03 <_sras_> erisco: I am looking for a way to do it in a single db call
10:44:06 <johnw> _sras_: so, I didn't fully understand your question
10:44:07 <mniip> since when has lpaste been augmented like this
10:44:18 <erisco> yes, that is what I am describing with the Reader monad
10:44:56 <erisco> your convert function is going to also take the conversion table
10:44:59 <_sras_> erisco: I am already inside a reader.
10:45:06 <erisco> that's fine
10:45:23 <erisco> you can either add the conversion table to your state or add another reader
10:45:41 <_sras_> erisco: I am aware of that option. But I want the interface of the function to be really simple. 
10:45:47 <erisco> or you do not have to use reader and can use parameter passing
10:45:50 <dmwit> _sras_: assuming `getConversion :: M (Decimal -> Decimal)` (for some monad `M`), you can `do f <- getConversion; return [Client (f bill) (f payment) | Client bill payment <- clients]`.
10:46:08 <erisco> well the reader lets you hide away the extra parameter
10:46:32 <lyxia> mniip: That may be what you get with a "private" paste
10:46:54 <erisco> you cannot have it simpler than it needs to be
10:47:21 <erisco> Einstein told me
10:50:00 <rotaerk> sure you can; it'll just be wrong
10:50:49 <dmwit> _sras_: I think erisco's Reader suggestion is overkill, for what it's worth.
10:51:19 <johnw> the _sras_ the mapM statement I wrote would work under Reader as well as under a query environment
10:52:37 <_sras_> johnw: But it makes two db calls for every client, right?
10:53:12 <dmwit> Only if `convert` makes a DB call.
10:53:44 <dmwit> _sras_: What is the type of your DB call?
10:54:29 <_sras_> dmwit: It is a Logger monad wrapped in a Reader..
10:54:54 <dmwit> _sras_: Let's call your whole monad stack `M`. What is the type of your DB call?
10:55:03 <erisco> _sras_, I know, try implicit parameters
10:55:09 <erisco> that should keep your code perfectly concise
10:55:22 <dmwit> Ignore erisco. This is a simple problem, and begs for a simple solution, not overengineering.
10:55:32 <erisco> dmwit, are you serious?
10:55:47 <dmwit> I am.
10:55:55 <erisco> well you're just wrong
10:56:10 <erisco> try out implicit parameters and you'll see it can work for this problem very well
10:56:22 <erisco> just bring the conversion table into scope and then any call to convert can pick it up implicitly
10:56:44 <dmwit> Boring old explicit parameters work just fine as well.
10:57:05 <_sras_> :dmwit   convert :: [Money] -> Currency -> m [Maybe Money]
10:57:48 <dmwit> _sras_: Hm. Is `Money` a number-like type?
10:58:34 <_sras_> dmwit: It wraps a Currency and a number.
10:59:10 <_sras_> Currency is just newtype over string..
10:59:52 <dmwit> _sras_: Cool. How hard would it be to write `[Currency] -> Currency -> m [Money -> Maybe Money]` instead?
11:00:18 <dmwit> Or perhaps something like `[Currency] -> Currency -> m [Maybe Multiplier]`?
11:01:10 <dmwit> Sorry, the first suggestion should be something like `[Currency] -> Currency -> m [Maybe (Decimal -> Decimal)]` or so.
11:02:58 <_sras_> dmwit: That interface is too complex...
11:03:18 <dmwit> Too complex for you to understand, too complex to implement, too complex to use?
11:03:28 <_sras_> Too complex to use.
11:03:47 <dmwit> Okay. Unfortunately there is a fundamental tradeoff between simplicity and efficiency that pervades computer science.
11:03:48 <_sras_> This is a simple functionality..
11:04:20 <dmwit> Also, `Currency -> Currency -> m (Maybe Multiplier)` or similar doesn't *seem* complex to use to me.
11:04:40 <_sras_> dmwit: Ofcourse..I don't debate that. Just wondering if there is some thing obvious that I am missing....
11:05:32 <dmwit> Well. I think you could potentially use the type you gave (`[Money] -> Currency -> m [Maybe Money]`). But then there will be some annoying work to do to convert your `Client`s to `[Money]`s and back.
11:05:57 <dmwit> Whereas the interface I'm proposing will be much simpler to use on `Client`s directly, and I think not that much more cumbersome for implementation and other uses.
11:08:02 <sm> in johnw's first suggestion (eg) you just bind "convert" once, it won't keep calling the db
11:08:30 <_sras_> dmwit: Isn't it better to 'seed' a function with conversion rates, using partial application, and use it to convert all the clients?
11:08:45 <dmwit> _sras_: Isn't that what I'm suggesting?
11:08:54 <_sras_> In a way, yes
11:09:24 <dmwit> `[Maybe (Decimal -> Decimal)]` is the list of (possible) conversion functions, partially applied to the source and destination currencies.
11:10:08 <dmwit> Or `[Maybe Multiplier]` is the "reified" version, under the assumption that all conversion functions are just multiplications.
11:11:05 <athan> Anyone here ever mess around with deriving storable?
11:11:33 <sm> dmwit: pardon me if I'm out of line but aren't you too complicating it now :)
11:12:10 <dmwit> sm: I'm perfectly open to simpler suggestions.
11:12:51 <dmwit> sm: I'm operating under a few assumptions that make me think I'm not complicating it, though, which may not be apparent. The main one being that fetching multiple conversions from the DB at once can be done more efficiently than making multiple fetches of single currency pairs.
11:13:09 <athan> er wait, why aren't lists storable?
11:13:20 <dmwit> Storable instances all have fixed in-memory sizes.
11:13:46 <athan> ...or CStrings? :(
11:13:50 <dmwit> :t sizeOf
11:13:52 <lambdabot> error:
11:13:52 <lambdabot>     ‚Ä¢ Variable not in scope: sizeOf
11:13:52 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
11:13:58 <glguy> CStrings have fixed size, they are pointers
11:14:21 <sm> I probably missed some extra requirement in there..
11:14:25 <dmwit> Well. `sizeOf :: Storable a => a -> Int`, but also the documentation demands "The value of the argument is not used.".
11:15:25 <glguy> sizeOf hails from a simpler time when people didn't know properly guard their proxy arguments
11:15:25 <dmwit> athan: `instance Storable (Ptr a)` and `type CString = Ptr CChar`
11:15:38 <athan> wait I'm silly, sorry. Thanks dmwit 
11:15:45 <c_wraith> yeah, Storable isn't appropriate for recursive data structures
11:15:56 <athan> sorry yall :x
11:17:22 <dmwit> (Aside: since johnw didn't show the implementation of `convert`, I'm not convinced that "it won't keep calling the db".)
11:27:32 <_sras_> dmwit: It is no big deal..
11:34:47 <johnw> dmwit: convert :: MonadReader m Prices => Decimal -> Decimal
11:57:26 <dmwit> Earlier I dismissed erisco and his contributions out of hand, rather than focusing on technical advantages and disadvantages of various approaches. That was unprofessional, and I apologize for losing my cool in that way.
11:58:17 <erisco> thank-you dmwit. you're a frequent and positive member of the community and I think we can put this incident behind us
12:03:59 <NemesisD> hey folks. i'm working on a logging library and was looking for some advice. internally every time you log it pushes it into a bounded queue and a background worker for each backend reads from this queue and basically calls a callback for it in IO
12:06:03 <NemesisD> this means that the worker can be blocking since its inputs are already buffered. but what if a backend wants to have a pool of concurrent threads. one option is they could start a bounded queue themselves and maintain a worker pool that reads from it. another is to use an MVar and have the threads fight over it. is this a Very Stupid Idea?
12:06:50 <ocharles> If I have a [Map k1 (Map k2 (Map k3 a))] - what's the best way to collapse that list down into a single  Map k1 (Map k2 (Map k3 a))  ? I can use  Map.unionsWith (Map.unionWith (Map.unionWith mappend))  , but it seems a shame to have to drop straight down to pairwise combination from the first map
12:07:03 <NemesisD> the disadvantage with having a backend maintain its own queue is that at worse you're using up 2x queue bound * message size of memory, whereas using an MVar at the inner level it would be queue bound * message size + message size
12:08:29 <Cale> NemesisD: I don't think it would be too silly to use an MVar
12:08:50 <Cale> It also shouldn't be too bad to use an unbounded Chan
12:09:03 <Cale> I haven't ever run into issues with either
12:09:13 <NemesisD> well an unbounded chan is dangerous here if the backend goes offline
12:09:16 <Cale> Basically because it's very rare to be doing so much logging that it would be an issue
12:09:51 <Cale> Why would it? Won't you just have a tight "forever" that takes things off the Chan and writes them?
12:09:53 <c_wraith> I've run into issues with a Chan for logging. 
12:10:20 <NemesisD> so for instance one backend is elasticsearch. if elasticsearch gets congested or has temporary networking issues, your logs will build up in memory
12:10:29 <Cale> ohh
12:10:32 <NemesisD> by using a bounded queue i'm saying if the queue is full, your writes get dropped
12:10:34 <c_wraith> it's easily possible to outpace the logging output if it's not going to file. 
12:10:37 <Cale> okay, I was thinking it would just be writing to a file
12:10:48 <NemesisD> oh sorry, we support that but also other backends
12:10:58 <Cale> Yeah, use an MVar then
12:11:32 <ocharles> Oh, unionsWith isn't anything but a bunch of mappends anyway
12:12:03 <Cale> Well, it'd be fair to use a bounded channel, that will eventually behave like the MVar once enough congestion happens, and block things
12:12:06 <NemesisD> i should just benchmark. i guess the test would be to pump N messages through outer bounded queue -> inner bounded queue -> worker pool, stop timing when all queues are flushed vs outer bounded queue -> inner mvar -> worker pool, stop timing when outer queue is empty, mvar is empty
12:12:27 <NemesisD> ocharles: i was staring at the problem and couldn't see why mconcat wouldn't work
12:12:30 <Cale> But it might be a little bit nicer when there's no congestion
12:12:43 <ocharles> NemesisD: it all works fine, I just wondered if there was anything more efficient
12:12:56 <ocharles> though mconcat on Map itself is useless, as is Map's monoid instance
12:13:48 <NemesisD> ah ok so you're trying to merge values when keys match
12:14:55 <NemesisD> @ocharles i just recently heard of https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Map-Merge-Strict.html in a blog post http://teh.id.au/posts/2017/03/03/map-merge/index.html but i havn't read it yet. maybe check it out
12:14:55 <lambdabot> Unknown command, try @list
12:15:06 <NemesisD> whoops, this isn't twitter
12:16:29 <ocharles> NemesisD: Mmm, I do know of that - it's quite cool
12:23:25 <Myrl-saki> Errr
12:24:45 <Myrl-saki> According to Linear types can change the world, is `f : U -o V |- f : U -o V` valid?
12:25:02 <Myrl-saki> With VAR rule
12:27:46 <tempu> what does this mean? "Normal a a	 Normal m s is a normal distribution with mean m and stddev sd." (from https://hackage.haskell.org/package/random-fu-0.2.7.0/docs/Data-Random-Distribution-Normal.html)
12:28:07 <tempu> or is it just a typo?
12:28:24 <shapr> In Python, I really miss being able to know what input type a function requires.
12:28:48 <Myrl-saki> tempu: Not really.
12:28:59 <Myrl-saki> tempu: I guess it should be Normal m sd.
12:29:12 <Myrl-saki> tempu: But the `Normal a a` is correct. For the type to be correct.
12:29:40 <tempu> Myrl-saki: thanks, doesn't "a a" imply that it takes two arguments of the same type?
12:29:45 <Myrl-saki> tempu: Mhm.
12:29:45 <n1k> yesx
12:30:53 <yhhko> Myrl-saki: i don't know that paper but it looks like an instance of the identity function, which is usually linear?
12:31:22 <Myrl-saki> yhhko: U -o V is not linear.
12:31:26 <Myrl-saki> s/linear/identity/
12:31:49 <yhhko> Myrl-saki: the map (U -o V) -o (U -o V) is
12:32:13 <Myrl-saki> yhhko: Ah. It's the VAR rule, which is `x : T |- x : T`
12:32:22 <Myrl-saki> rule/axiom
12:33:10 <yhhko> (do you mean i answered your question?)
12:33:47 <Myrl-saki> yhhko: Indirectly, I think.
12:34:13 <Myrl-saki> I also see no other way to introduce a -o.
12:43:20 <tempu> where am i wrong? i'm trying to a random value from a normal distribution (via Data.Random.Distribution.Normal)  "normal 4 (Normal 0 1)"
12:44:09 * tempu is struggeling with the syntax
12:44:56 <Myrl-saki> tempu: the type of 4 is different from (Normal 0 1)
12:45:21 <Myrl-saki> 4 :: Num a => a; (Normal 0 1) :: Num a => Normal a
12:47:15 <tempu> Myrl-saki: how else would i include the seed?
12:47:31 <Myrl-saki> tempu: Is 4 the seed?
12:48:33 <tempu> oh no, i assumed Normal includes it
12:48:45 <Myrl-saki> tempu: What do you mean?
12:51:50 <tempu> Myrl-saki: oh, i'm supposed to use "normal 0 1" instead, since it constructs the Distributed Normal right?
12:52:34 * tempu is confused
12:53:42 <Myrl-saki> tempu: Seems so.
12:53:49 <Myrl-saki> tempu: Though, you might want to use stdNormal
12:55:05 <tempu> i'd like to make sigma variable
12:57:22 <tempu> means stdNormal seems out of question (assuming i got the docs right=
13:09:49 <Myrl-saki> From Wadler's Linear types can change the world, I can only define id and nothing else. =_=
13:10:18 <Myrl-saki> x : T |- x : T
13:10:37 <Myrl-saki> |- (\x : T. x) : T -> T
13:11:00 <Myrl-saki> Anything else seemes Impossible...
13:11:31 <fXl> Hello guys, i am trying to implement the question on geeksforgeeks. I am getting these errors https://hastebin.com/ugoqudixih.sql , http://www.geeksforgeeks.org/find-missing-number-arithmetic-progression/  
13:11:37 <Myrl-saki> I mean -o
13:11:43 <fXl> The code also in there, can you guys have a look at ?
13:15:32 <hexagoxel> fXl: `search  y:ys` is parsed as `(search y):ys`. you'd probably get a better error when adding a type signature for `search`.
13:17:47 <erisco> hrm, if you have an enumeration, how might you start the enumeration at a favourable element?
13:18:14 <erisco> so for example, say you have the Cartesian product of two lists of integers, and you prefer to see pairs of square numbers first
13:19:38 <fXl> hexagoxel: okey i added type signature
13:19:56 <Myrl-saki> erisco: sortBy?
13:20:15 <erisco> so I want to express all the elements of the numeration but be flexible in the order they are enumerated
13:20:48 <erisco> no the point is that they have to be enumerated in a favourable order to begin with, not ordered after the fact
13:21:21 <ski> Myrl-saki : `|- (\x : T. \f : T -o U. f x) : T -o ((T -o U) -o U)' should be possible
13:23:54 <ski> Myrl-saki : with "either", "tensor", "with", "void", "unit", "erase", "of course", more interesting stuff should be possible
13:24:18 <Myrl-saki> ski: Of course! (no pun intended)
13:24:27 <Myrl-saki> ski: (Actually, pun totally intended.)
13:24:44 <Myrl-saki> ski: What I'm confused about though is how he got ther.
13:25:07 <Myrl-saki> ski: I've been playing with my pencil and paper for so long already, and the only thing that I can define is id (or I).
13:25:21 <Myrl-saki> s/ther/there/
13:26:07 <ski> Myrl-saki : `flip' should be totally possible
13:26:19 <Sh4rPEYE> Hello. I'm going through Haskell Book and I'd like to ask, why should foldMap for Constant be defined like this. Could somebody elaborate?
13:26:24 <Sh4rPEYE> newtype Constant a b = Constant a
13:26:33 <Myrl-saki> ski: I'm curious how to do it using the inference rules.
13:26:42 <Sh4rPEYE> instance Foldable (Constant a) where foldMap _ _ = mempty
13:27:25 <erisco> :t foldMap
13:27:27 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
13:28:00 <ski> Myrl-saki : if you're familiar with inference rules, it shouldn't be too hard to figure out (since they're syntax-directed here .. except for weakening and contraction (and exchange if you include that), but in this case those only applies for "of course" (and "why not") but you don't use that for `flip')
13:28:05 <Myrl-saki> ski: Should I just skip Linear types can change the world and go to A taste of linear logic*?
13:28:31 <Myrl-saki> ski: I'm not too familiar with them, to be honest.
13:29:08 <ski> Myrl-saki : if you're not that familiar with inference rules, then perhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> could be of some use
13:29:45 * ski doesn't recall which of "Linear types can change the world" and "A taste of linear logic" would be more demanding
13:30:03 <Myrl-saki> ski: Also, I'm currently only interested in the linear system as defined by Figure 2.
13:32:12 <erisco> :t foldMap :: Monoid m => (b -> m) -> Constant a b -> m -- does it make sense now Sh4rPEYE?
13:32:13 <lambdabot> error:
13:32:13 <lambdabot>     ‚Ä¢ Could not deduce (Foldable (Constant a1))
13:32:13 <lambdabot>         arising from a use of ‚ÄòfoldMap‚Äô
13:32:23 <erisco> okay, well, it would specialise in that way
13:32:35 <Myrl-saki> ski: Oh wait. I think I've been overthinking it.
13:32:45 <Myrl-saki> ski: Do I literally just define it using VAR?
13:33:35 <ski> ok, so that gives you "void","either","unit","tensor", but not "erase","with","bot","par","of course","why not"
13:33:45 <ski> define what using `VAR' ?
13:34:01 <Myrl-saki> The combinators.
13:34:28 <ski> .. i also don't what you mean by "defining something using `VAR'"
13:34:56 <ski> for `id' above, you used `VAR' to introduce the identifier expression `x'
13:35:02 <Myrl-saki> ski: Right.
13:35:13 <Myrl-saki> ski: How would I work with flip?
13:35:16 <ski> i wouldn't call that defining anything, but perhaps this is what you meant
13:35:22 <Sh4rPEYE> erisco: Oh, of course. At first I though you would have to return 'f b', but as b is discarded, I have to return mempty. 
13:35:33 <Myrl-saki> ski: Mhm. That's what I meant.
13:36:26 <erisco> Sh4rPEYE, as far as I can tell there is actually no obligation to use f in any implementation
13:36:36 <ski> Myrl-saki : very commonly, it's easiest to construct a derivation tree employing inference rules, by first setting out the root (the end goal) (possibly not having pinned down the (whole) expression to derive yet, only the context and the type of the expression), and then work backwards/upwards from that
13:36:49 <Myrl-saki> ski: I see.
13:36:52 <erisco> but in spirit you're supposed to
13:37:13 <ski> i would say that `VAR' establishes a use of an identifier
13:38:03 <ski> if reading the derivation tree top-down (from leaves to root/goal), then `VAR' could be said to introduce a variable (both into the context, and into the expression on the right)
13:38:46 <ski> if reading the tree bottom-up, then the rule for lambda, and the one for `case', introduces variables
13:38:49 <Sh4rPEYE> erisco: It makes sense this way... Sort of "I have b, I want to have m. Luckily I also have m->b"
13:40:12 <erisco> I mean if the foldMap instance for [a] also just returned mempty I don't see what law that violates
13:40:22 <erisco> other than it clearly goes against the spirit of Foldable
13:41:09 <Sh4rPEYE> Oh, yes, it is possible to define it like that.
13:41:48 <Sh4rPEYE> Anyway, thanks :-) Good night
13:42:05 <erisco> though it should alarm that there may be problems with Foldable...
13:42:09 <erisco> if I can write a universal instance
13:43:56 <ski> given `sing :: a -> t a', one could want `forall f. foldMap f . sing = f', aka `(. sing) . foldMap = id'
13:44:04 <Myrl-saki> ski: Question. What does it mean/imply when the left side of the turnstile is empty?
13:44:19 <ski> that the expression has no free variables, that it is a combinator
13:44:26 <Myrl-saki> ski: Ohhh
13:44:45 <Myrl-saki> ski: Right. Since the assumption list is a context?
13:44:55 <ski> the context/environment, the list of free-variable & type associations is empty
13:45:11 <Myrl-saki> ski: I see. Thanks.
13:45:24 <ski> Myrl-saki : did you look at the Schwartzbach paper i mentioned ?
13:45:37 <Myrl-saki> ski: Mhm.
13:46:04 <erisco> ski, maybe Foldable should have been defined with a sing then
13:46:15 <Myrl-saki> ski: Still at page 4-5. Went back to Wadler's though, to try going from bottom-to-top on the combinators.
13:46:38 <ski> Myrl-saki : ok
13:46:54 <erisco> ski, I am not sure it fully captures the wishes though
13:47:15 <erisco> for example, why couldn't the list instance ignore all but the head
13:47:21 <erisco> since sing will only give singleton lists
13:47:26 <ski> erisco : maybe. it's not that clear how much is has to do with "folding", though
13:48:06 <fresheyeball> anyone here know how to tell xmonad to use my whole display for the layout?
13:49:31 <erisco> if it is Alternative then perhaps  foldMap f (x <|> y) = foldMap f x <> foldMap f y
13:49:46 * ski was just thinking of `Alternative'
13:50:14 <ski> but then how should `foldMap' interact with `(<*>)' ?
13:56:14 <Myrl-saki> ski: I think I'm close. :D
13:56:45 <Myrl-saki> ski: I've done all the -oIs now. I just need to do the -oE.
13:58:39 <erisco> ski, I don't know, how are <|> and <*> supposed to interact?
14:01:16 <Myrl-saki> ski: Thanks. I understand way better now.
14:04:00 <ski> erisco : <https://en.wikibooks.org/wiki/Haskell/Alternative_and_MonadPlus#Other_suggested_laws>
14:04:06 <Myrl-saki> ski: In Schwartzbach's paper, does A differ from ellipses?
14:04:08 <erisco> http://stackoverflow.com/a/13081604/260584
14:04:22 <Myrl-saki> ski: Page 4's inference rules.
14:05:19 <ski> `A' there is a meta-variable standing for a context / type environment / "symbol table"
14:05:58 <Myrl-saki> ski: So A is there verbatim?
14:06:09 <ski> for the variable rule, `...,x : sigma, ...' means a context with `x : sigma' occuring in it somewhere
14:06:16 <Myrl-saki> ski: Ah.
14:06:26 <ski> a common alternative way to write this would be `A_0, x : sigma, A_1'
14:06:49 <ski> or even `A, x : sigma', if we take the context to be a set (or at least bag), rather than a list
14:07:18 <ski> this notation is also used in the rule for lambda there
14:07:19 <Myrl-saki> ski: Right. Such as Wadler's VAR for nonlinear type.
14:07:25 <erisco> seems we're too late for Alternative/Applicative laws
14:07:45 <erisco> not sure how one became a sub class of the other without the laws prescribed
14:07:56 <Myrl-saki> ski: Okay. I'm pretty sure I'm getting this so well now.
14:08:17 <Myrl-saki> ski: So, in the case of `A |- 0 : Int`, there's nothing required of the context.
14:08:22 <Myrl-saki> ski: It can be literally anything.
14:08:43 <sophiag> i'm a bit confused about how to use overlapping instances. i have two data types with a Maybe field and one requires me to derive an instance of Show. in addition to the regular derived instance, i had to derive one for (Maybe a) as well (a bit confused as to why), which i guess overlaps with the Maybe field in the other data type. and putting the overlapping pragma in the derived instance for Maybe didn't resolve the error. would
14:08:44 <sophiag> anyone mind explaining how this works?
14:08:52 <ski> Myrl-saki : yep
14:09:11 <Myrl-saki> I'm pretty sure I read something similar in one of Wadler's papers.
14:09:34 <ski> Myrl-saki : you can think of it as an implicit weakening on all unused variables being built-in to all "leaf" rules there
14:09:35 <Cale> How to use overlapping instances: Step 1. Fix your instances so that they don't overlap. Step 2. Thank yourself later.
14:09:56 <ski> Myrl-saki : and similarly an implicit contraction being built-in to the branching rules
14:10:11 <Myrl-saki> ski: Makes sense.
14:10:21 <Cale> sophiag: What are your instances?
14:10:35 <geekosaur> why would you need to derive an instance for Maybe a?
14:11:32 <erisco> ski, foldMap (uncurry f) (x >*< y) = fold (f <$> f <*> y)
14:11:32 <erisco>   where (>*<) x y = (,) <$> x <*> y
14:11:53 <Myrl-saki> "the first because -oI places no constraint on the assumption list, and the second because ->I places no constraint on the argument or result type." (A taste of linear logic, p. 13)
14:11:55 <ski> Myrl-saki : this is handy if you're building your derivation bottom-up (from root to leaves), since you delay the choice as much as possible. if you instead wanted to build your derivations top-down (from leaves to root), then you'd "go to the other extreme", so to speak
14:12:05 <erisco> sorry, that should be  fold (f <$> x <*> y)   on the right
14:12:24 <Myrl-saki> ski: Wait, which part here is the root and which part here is the leaves?
14:12:32 <ski> erisco : "Warning: Singleton variables : `x'"
14:12:39 <Myrl-saki> ski: Oh wait. Root is the end, right?
14:12:45 <sophiag> Cale: well as mentioned, one is for (Maybe as), which i'm confused as to why i needed it just because the other field in the data type (i'm using record syntax) needed it derived. the one that's actually throwing the error is another with record syntax and a similar Maybe String field that i don't need a standalone instance for
14:12:47 <ski> Myrl-saki : yep
14:12:52 <erisco> ski, hm?
14:12:53 <ski> root is the end goal
14:12:59 <sophiag> *that should read (Maybe a)
14:13:01 <Myrl-saki> ski: Thanks.
14:13:09 <ski> erisco : `c' doesn't occur on the right hand side of that equation
14:13:14 <ski> er, `x', not `c'
14:13:25 <erisco> ski, see my correction
14:13:36 <ski> ah
14:13:54 <Cale> sophiag: I can't tell why they'd overlap if I don't know all the instance heads
14:14:11 <sophiag> Cale: these are the ones that are overlapping: http://lpaste.net/354249
14:14:37 <Cale> oh, you can't derive an instance of Show for Maybe because that already exists
14:14:47 <sophiag> yeah, hence why i'm confused...
14:14:54 <Cale> So just delete that line
14:14:55 <erisco> ski, it doesn't look so pretty but that is what I could think of
14:14:58 <sophiag> without that the instance below it throws an error tho
14:15:07 <Cale> Yeah, but what error?
14:15:36 <sophiag> "No instance for (Show (Val -> Maybe Val)) arising from a use of ‚ÄòshowsPrec‚Äô (maybe you haven't applied a function to enough arguments?)"
14:15:51 <ski> erisco : i suspect that can be derived from interaction with `fmap'
14:15:53 * geekosaur just saw that. yes, you cant Show a function
14:15:54 <erisco> ski, eh, I think that is already covered by the stated relation to fmap
14:15:59 <geekosaur> has nothing to do with Maybe
14:16:12 <Myrl-saki> ski: This reminds me. What's with Linear types can change the world's grammar? I can follow it, but it seems less... formal/
14:16:28 <sophiag> geekosaur: i suspected as much. i'm always freaked out when things compile that don't make sense to me
14:16:33 <ski> Myrl-saki : page ?
14:16:34 <erisco> ski, yeah I really have to pull the <*> outside but I am not sure how that would be done
14:16:45 <geekosaur> well, you can "show" it but you can't derive it, you have to write your own instance that ignores or prints a constant string for the function
14:17:02 <Cale> sophiag: The problem there is that you have no instance of Show for functions.
14:17:07 <Myrl-saki> ski: Page 5, for example.
14:17:20 <sophiag> Cale: so what geekosaur said?
14:17:23 <Myrl-saki> T ::= K | (U -> V)
14:17:35 <Myrl-saki> Why not, say, `T :: = K | (T -> T)
14:17:36 <sophiag> i need to actually write the instance?
14:17:45 <sophiag> err function rather
14:18:24 <ski> Myrl-saki : some people would say `t,u,v ni T ::= K | (T -> T)'
14:19:29 <erisco> but regardless we can have the <|> interaction which is straight-forward
14:19:35 <Myrl-saki> ski: That makes me a bit more confused, what happens to t, u and v?
14:19:38 <Cale> sophiag: An instance of Show for functions, yeah, and there really isn't a possible good instance, so you have to write a half-assed one if you want that Show instance.
14:19:43 <erisco> and <|> in turn interacts with <*>
14:19:51 <Myrl-saki> ski: Why state it when it's not anywhere else?
14:19:59 <Cale> sophiag: So something like  instance Show (a -> b) where show _ = "<function>"
14:20:13 <sophiag> Cale: are we talking something similar to to Show1 from prelude-extras?
14:20:20 <Myrl-saki> ski: Oh wait. I think the problem is that I don't understand the grammar of the grammar either.
14:20:22 <ski> Myrl-saki : in that version `t',`u',`v' would be actual meta-variables, while `T' should be thought as the (meta-)type of them. cf. `data T = Base K | Fun T T'
14:20:55 <Cale> no
14:21:00 <Myrl-saki> ski: Ahh
14:21:01 <Cale> Just plain Show from ordinary Prelude
14:21:16 <Cale> sophiag: So just stick in that line that I wrote
14:21:22 <sophiag> just asked because Show1 seems to have a similar implementation to what you wrote
14:21:25 <Cale> and it should be able to give you a Show instance for the other thing
14:21:34 <erisco> together with the sing law, though it would be now the pure law, you get exactly how it should work for lists
14:21:35 <edwardk> import Text.Show.Functions -- its in base for the silly reason that its a godawful terrible orphan but at least this way it only comes from one place if you need it
14:21:36 <sophiag> anyway, i'm a little unsure what the actual function body should be...
14:21:39 <Myrl-saki> ski: Thanks so much. ; ^ ;
14:21:55 <ski> Myrl-saki : the purpose of ‚åút,u,v ‚àã T ‚à∑= ‚ãØ‚åù would be to express the intent of using ‚åút‚åù,‚åúu‚åù,‚åúv‚åù as meta-variables for terms
14:22:09 <sophiag> edwardk: thanks! must be the power of keyword notifications :)
14:22:26 <edwardk> sophiag: just good timing =)
14:22:52 <erisco> foldMap f (pure x <|> pure y) = foldMap f (pure x) <> foldMap f (pure y) = f x <> f y
14:23:19 <edwardk> sophiag: Show1 is for containers that are showable if their arguments are showable
14:23:23 <edwardk> that is a different concern
14:23:27 <sophiag> ah ok. i know someone in another channel who has it set so he just pops up whenever someone mentions his name or anything he's worked on
14:24:07 <mniip> hey edwardk do you know of a construct diverse enough to represent vector spaces in a useful way?
14:24:11 <Myrl-saki> ski: i don't quite understand why \ni.
14:24:16 <sophiag> but Text.Show.Functions provides functions for types that aren't showable otherwise?
14:24:17 <mniip> representable functors are kind of close
14:24:18 <edwardk> i do pop up when my name is mentioned or when a couple of keywords get mentioned (i rotate the keywords occasionally) but if my machine dinged whenever anybody mentioned anything i wrote, i'd go mad ;)
14:24:38 <mniip> but apparently there are vector spaces that aren't representable
14:24:46 <edwardk> mniip: all vector spaces are free vector spaces, so representable functors are exact. everything else is a cheat ;)
14:24:57 <edwardk> there are _modules_ that aren't free
14:24:57 <mniip> yeah but
14:25:00 <ski> Myrl-saki : er, sorry, on second thought that should be `\in'
14:25:01 <edwardk> but all vector spaces are
14:25:11 <Myrl-saki> ski: Ah. Makes sense now. Thanks.
14:25:27 <ski> (maybe i've seen ‚åúT ‚àà t,u,v ‚à∑= ‚ãØ‚åù ? not sure)
14:25:31 <edwardk> ideals for rings aren't a free module for instance
14:25:32 <mniip> edwardk, the vector space of Z_2 sequences with finitely many ones
14:25:51 <mniip> edwardk, it is countable, and aleph-null-dimensional
14:26:03 <mniip> while 2^aleph-null = aleph-1
14:26:13 <Cale> sophiag: What did you mean by "the actual function body"?
14:26:29 <Cale> sophiag: You can't *actually* turn a function into a string in a meaningful way most of the time
14:26:52 <edwardk> mniip: how does that get in the way of it being representable?
14:26:59 <mniip> hey sophiag still battling your lambdas issue?
14:27:00 <Cale> sophiag: So the best you can do is just produce a stupid string like "<function>" because it's essentially a black box.
14:27:18 <mniip> edwardk, the space isn't an exponential object at all
14:27:28 <sophiag> Cale: i know what you meant now because it's in the docs for the library edwardk showed me
14:27:33 <Cale> ah :)
14:27:49 <sophiag> something like: "showsPrec _ _ = showString \"\<function\>\""
14:27:52 <Cale> Yeah, I literally meant the code that I wrote -- I didn't mean for you to fill that bit in or anything :)
14:27:59 <geekosaur> sophiag, if you could access the function body it would be an STG graph, not meaningful to anyone who saw it
14:28:00 <sophiag> i didn't realize that
14:28:22 <geekosaur> this is not python or some other interpreted language, the source does not exist at `show` time
14:28:27 <sophiag> geekosaur: no i thought he was using a placeholder, like "fill this part in"
14:28:55 <mniip> edwardk, there is not a D for which 2 -> D ~ N
14:29:07 <mniip> no wait
14:29:13 <mniip> D -> 2
14:29:15 <Cale> Though I think it would be really cool if you could build programs in a mode where the runtime expression graph would be useful to humans.
14:29:53 <hpc> lisp? ;)
14:30:00 <edwardk> You have (N -> Z_2) with the constraint on the function that the function can only return 1 for a finite number of D. so here's where we run into the issue with variance involved with the representable form.
14:30:32 <mniip> representable functors imply an isomorphism don't they
14:30:39 <edwardk> In a real free vector space we'd be able to say you have some kind of map from basis elements to values, that is only finite in length. this would be covariant in the basis.
14:30:40 <mniip> here we clearly have a one-way injection
14:31:05 <edwardk> the problem here is that using (R^x) directly we've incurred an extra 'twist'
14:31:59 <edwardk> there is an adjunction * -| *, so if we look at the form i tend to encode vector spaces with in haskell, then what we really do is move to the 'free vector space' and then compose with the * above.
14:32:18 <mniip> *?
14:32:21 <edwardk> unfortunately this can be bigger
14:33:28 <edwardk> the dual space operator
14:33:38 <mniip> ah
14:33:55 <edwardk> anyways this is why we can get back to a monad for (a -> r) ->_L r
14:34:09 <edwardk> where ->_L is assumed to be a linear functional
14:34:34 <edwardk> this is the underlying 'lie' that makes linear, etc. all work
14:34:48 <hpc> not gonna lie, i read that as bottom for a second
14:34:54 <edwardk> which is why the docs there talk about them as useful for 'low dimensional' vector spaces
14:34:57 * ski did as well
14:34:59 <edwardk> hpc: =)
14:35:35 <scav> what kind of editor are you guys using? just emacs/vim or anything heavier? coming from a java/scala background I am used to everyone just running the same IDE.
14:35:47 <edwardk> i live in vim personally.
14:35:48 <ski> emacs here
14:36:34 <edwardk> there are plugins for emacs/vim that make your haskell development feel IDE-like. i've not had much in the way of good experiences with them. YMMV. Others seem to get by
14:37:07 <scav> well, i generally just enjoy some kind of auto-complete, i don`t need a full blown ide experience 
14:37:34 <thimoteus> neovim here
14:37:43 <mniip> plain vim with no completiong here
14:37:59 <mniip> 1491255213 [00:33:33] <edwardk> anyways this is why we can get back to a monad for (a -> r) ->_L r
14:38:04 <mniip> edwardk, mind expanding on that?
14:38:58 <edwardk> i don't mind, but my thinking is pretty fuzzy today. (i'm at the end of a long diet before i do a radiation thing tomorrow, and my ability to think is pretty frazzled)
14:39:36 <edwardk> i wrote up a bunch of this somewhere to turn into an article. i just don't know where i put it
14:39:56 <mniip> ouch
14:40:07 <sophiag> Cale: to be clear, it can only print <function> in ghci, but the function is still there when i want to use it, right? i finally got all the parsing to compile so want to make sure it's working correctly...
14:40:31 <scav> thank you for your answers guys, still trying to find a non-intellij editor i can live with :)
14:40:38 <sm> good luck edwardk
14:40:45 <mniip> get well soon then!
14:40:50 <geekosaur> sophiag, it's there, just not in a form that prints nicely
14:40:58 <edwardk> anyways, a 'proper' free vector space would only have a finite number of non-zeroes, so you could put it into a covariant form like [(e, r)] or Map e r.
14:41:19 <edwardk> once you add the *'s that come along above, it gets bigger, allowing an infinite number of non-zeroes
14:41:24 <sm> scav: I'm using intellij along with emacs, but no real completion/smart jumps, just project-wide search
14:41:24 <sophiag> geekosaur: thanks. i don't need it to actually print
14:41:50 <edwardk> but we recover the size stuff by using the requirement of linearity in the ->_L, when we talk about the new "dual" space
14:43:24 <edwardk> e.g. instead of looking at sequences of Z^2 with finitely many 1s, we can look at linear functionals (N -> Z_2) ->_L Z_2, which can only query at finitely many locations and still be linear. the problem turns on its head.
14:44:12 <edwardk> the trick then becomes dualizing all of your problem statements in this manner ;)
14:44:42 <edwardk> i've had some success doing this with things like geometric algebra to get a form of geometric coalgebra, etc.
14:44:56 <edwardk> but i also never really wrote any of that up
14:46:33 <edwardk> anyways this ->_L thing is a rather dubious story, which is what led me to work out with a coworker what is really going on involving the composition of the free -| forget adjunction for free vector spaces and the * -| * adjunction for dual spaces
14:47:00 <mniip> edwardk, wait
14:47:04 <mniip> is this the same lie
14:47:24 <mniip> as X ~ (X -> Bool) -> Bool
14:48:03 <edwardk> its related, here we're not requiring the last function to be any function but rather ->_L which is more constrained. you can get more information out
14:48:06 <mniip> where your function can only be so complex because it has to be expressed with a finite piece of code and executed in finite time?
14:48:14 <Cale> sophiag: That's right.
14:48:24 <edwardk> but as intuitions go, you're on track
14:49:09 <mniip> no wait
14:49:10 <edwardk> we're basically working with Cont, but requiring linear operators for instance denies you callCC.
14:49:13 <mniip> that was something else
14:49:29 <mniip> I think it was Eq a => Eq ((a -> Bool) -> Bool)
14:49:53 <edwardk> instance Eq a => Eq (Cont Bool a) ?
14:50:42 <edwardk> both that and the ~ you gave come down to the same issue
14:50:48 <mniip> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
14:51:02 <edwardk> but on the other hand (forall r. (a -> r) -> r) ~ a
14:51:22 <edwardk> so if we put constraints on how we use 'r' we can get more information out.
14:51:22 <mniip> forall r. sure
14:51:31 <edwardk> i'm offering up Codensity here as an example
14:51:40 <edwardk> all the free vector spaces can't care what 'r' is in their operation
14:51:51 <edwardk> so its closer to truth than you'd think
14:52:07 <Cale> It would be interesting to think about whether other continuation-y types have compact topologies
14:53:14 <edwardk> anyways, yeah, i was going to point you to the seemingly impossible functionals bit =)
14:53:27 <mniip> wondering if it'd be possible to define a Representable'y typeclass for vector spaces that is actually useful
14:54:25 <edwardk> mniip: linear just gives up and adds an 'Additive' class that is completely ad hoc and suite to dealing with maps, etc. as infinite dimensional sparse vector spaces
14:55:23 <mniip> problem is,
14:55:25 <edwardk> i wonder if i should consider a form of linear algebra based on discrimination to fold over common basis elements
14:55:41 <mniip> R-> is a vector space functor
14:55:48 <mniip> so it gets to be an instance
14:55:55 <mniip> what can we do with it in haskell? Nothing
14:56:17 <mniip> basis? it exists. Can we see it? nah
14:56:23 <edwardk> i can add them, subtract them, give you a zero vector... ;)
14:56:31 <mniip> well
14:56:41 <mniip> that much you can do with Representable
14:56:45 <edwardk> i can query it at individual basis elements to figure out the projection onto that basis
14:57:01 <mniip> f + g = tabluate (\x -> index f x + index g x)
14:57:04 <edwardk> by dint of it being, you know, a function =)
14:57:12 <mniip> yeah no
14:57:24 <mniip> you can't query it at basis elements that have infinite support
14:57:39 <mniip> and there isn't a basis of only finite support in R->R I don't think
14:57:49 <edwardk> well, sure, we're stuck in constructive 'at the end of the day i have to compute something' land
14:58:30 <edwardk> once you start talking about infinities everywhere you get all sorts of things you can only talk about obliquely
14:58:47 <edwardk> maybe what you really want is a theorem prover
14:58:53 <mniip> hmm
14:59:18 <mniip> what *is* (X -> Bool) -> Bool
14:59:25 <mniip> if -> is from Hask and not Set
14:59:37 <mniip> that is, has a computable implementation
15:00:19 <ski> (do you mean it's algorithmic, or only that it's computable ?)
15:00:32 <mniip> ski, algorithmic?
15:00:57 <ski> implementable as a finite program, with lambda calculus or whatever
15:01:01 <edwardk> it lets you smuggle out as much information about X as you can get by asking it a finite number of boolean valued questions. to do more you need to know more about that function.
15:01:11 <jle`> mniip: 
15:01:13 <mniip> ski, no like it can run on TM in a finite amount of steps
15:01:28 <edwardk> in Hask there is no requirement that it runs in a finite amount of steps
15:01:36 <edwardk> just that you get _|_ if you try to do more
15:01:38 <jle`> oh, sorry
15:01:47 <edwardk> as Bool isn't just True and False, but also potentially _|_
15:02:07 <ChaiTRex> True | False | FileNotFound
15:02:29 <edwardk> i find thinking about hyperfunctions and the like informative when you play with questions like these, because they highlight the importance of _|_ in the language
15:02:30 <hpc> ChaiTRex++ for putting true and false in the objectively correct order :D
15:02:34 <ski> you could imagine a program of type `(Nat -> Y) -> Z' being fed a stream of input from the external world (perhaps temperature readings or something), without needin to know whether those temperature readings can be described by an algorithm
15:03:18 <edwardk> if we require computability in finite time for all inputs the space of programs shrinks alarmingly.
15:03:35 <edwardk> and you get things like Cont Bool Natural ~ Natural !!?!?
15:03:43 <mniip> they're all countable
15:03:56 <ski> (ditto for implementing addition of real number represented by cauchy sequences. it doesn't matter whether here those sequences are algorithmic, it only matters whether you can compute them, somehow)
15:04:14 <edwardk> N = 2^(2^N) is completely nonsensical in Set, but here in Hask, restricted to computations that terminate in finite time holds.
15:04:49 * ski . o O ( bar induction )
15:05:00 <edwardk> https://github.com/ekmett/hyperfunctions/blob/master/examples/Cantor.hs#L33
15:05:01 <mniip> ski, f :: (X -> Bool) -> Bool, such that, assuming x :: X -> Bool is computable then f x is computable
15:05:24 * ski nods
15:05:52 <edwardk> ^- that code shows an isomorphism between Natural and (Natural -> Bool) -> Bool in hask
15:06:11 <edwardk> where the latter are constrained to be any function that terminates in finite time for all inputs
15:07:41 <edwardk> did i ever mention that hyperfunctions are weird =)
15:08:05 <edwardk> they make mockery of many Set-based assumptions
15:09:19 <edwardk> ChaiTRex: you got the capitalization wrong: =) https://hackage.haskell.org/package/acme-php-0.0.3/docs/Prelude-PHP.html
15:10:17 <hpc> to be fair it took me a couple of hours to write that package
15:10:26 <hpc> even i can't get code to work perfectly the first time
15:10:26 <edwardk> =)
15:10:30 <mniip> type Bool = Int#
15:10:58 <Eduard_Munteanu> @src Bool
15:10:58 <lambdabot> data Bool = False | True deriving (Eq, Ord)
15:11:30 <edwardk> mniip: my current code is basically implementing booleans as a 256 bit wide register full of 8 32 bit ints that are all 0 or ~0, so not too far off base. =)
15:11:32 <ph88^> how does this parser work?  https://hackage.haskell.org/package/megaparsec-5.0.0/docs/src/Text-Megaparsec-Combinator.html#endBy   let p = char 'a'; let end = char ';'  then   a;  should be ok .. but    aa;  should fail ?
15:11:41 <mniip> ~0 :D
15:11:45 <mniip> just like BASIC
15:11:55 <mniip> seriously though that thing was genious
15:12:04 <mniip> logical and same as bitwise and
15:12:28 <ChaiTRex> edwardk: The mathematics functions in that are nice.
15:13:25 <Eduard_Munteanu> ph88^, yes
15:13:27 <mniip> weird
15:13:32 <mniip> did my acme-iot package get lost
15:13:56 <edwardk> ph88^: endBy p sep = many (p <* sep) -- does what it says on the tin.
15:14:08 <mniip> or did I never submit it
15:14:31 <pikajude> someone really needs to start designing tins for library functions
15:14:33 <mniip> ah there it is https://hackage.haskell.org/package/acme-iot
15:14:35 <edwardk> e.g. endBy (many (char 'a')  semi) parses aaaa;aaa;aaaa;aaaaa;  but you have to rememberthe trailing ;
15:14:39 <mniip> should fix up the categries
15:15:39 <edwardk> in your case aa; fails because it matches 'a' then it goes to match  the ';' and fails to find it between the first a and the second.
15:16:00 <ph88^> edwardk, ya actually i know it does that out of experience .. but by reading the code for it i don't understand the why. Because i thought when you try to parse first   p and then end   and end fails that the whole parser fails and many stops trying another time
15:16:07 <edwardk> this combinator doesn't include a try block, but if megaparsec is like all the oher parsec/trifecta/etc. alikes thenyou giveup
15:16:26 <mniip> https://hackage.haskell.org/package/acme-iot-0.1.0.1/docs/Control-Monad-Trans-IO.html#t:IOT
15:16:38 <edwardk> ph88^: ah you're confused by try semantics
15:16:56 <edwardk> ph88^: in general parsec style parsers only try the next <|> if they left hand side didn't consume any input
15:16:59 <edwardk> er the
15:17:30 <edwardk> so 'p' "consumed" an a before end failed, so the many can't fail over to its other case.
15:18:08 <ph88^> so the fact that something was already consumed makes the parser succeed ?
15:18:16 <splanch> the consumed cont is infectious
15:18:35 <ph88^> i'm talking about the  (p <* end)  parser
15:18:49 <ph88^> which i read:  parse p and then parse end   and return p
15:18:58 <ph88^> so if end fails it still returns p ?
15:18:58 <edwardk> lets take          many q = qs where qs = (:) <$> q <*> qs <|> pure []
15:19:13 <edwardk> and consider many (char 'a' *> char ';') 
15:19:17 <edwardk> er <*
15:19:54 <ph88^> oh you fmap : over the parser ?
15:20:18 <edwardk> just supplying a stock definition of 'many'
15:21:18 <edwardk> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#many writes it in an ass-backwards manner, but it translates ot thesame thing
15:21:24 <ph88^> q   stands in for the result of   (p <* end)
15:21:37 <edwardk> q _is_ p <* end
15:22:26 <edwardk> many (p *< end) = qs where qs = ((:) <$> (p <* end) <*> qs) <|> pure []
15:22:33 <edwardk> added some unnecessary parens for emphasis
15:23:22 <HallaSurvivor> Hey, why can I write:    data Tree a = Node (a, [Tree a]) deriving Eq
15:23:33 <HallaSurvivor> Shouldn't I need to place an Eq restriction on a?
15:23:34 <edwardk> many (p <* end) = qs where qs = do { x <- p; _ <- end; xs <- qs; return (x:xs) } <|> pure [] -- if you prefer do notation
15:23:35 <ph88^> so you run the parser, it consumes input, and then gives that input back  and then you cons it
15:23:48 <HallaSurvivor> but GHCI is totally fine with it
15:23:55 <edwardk> HallaSurvivor: if you look at your derived instance, it figures out it needs that Eq
15:24:01 <edwardk> and writes instance Eq a => Eq (Tree a)
15:24:09 <fXl> hello, i am trying to implement this in Haskell. http://www.geeksforgeeks.org/find-missing-number-arithmetic-progression/ , i couldnt make it happen, can anybody help me on this one ? 
15:24:18 <fXl> here what i did so far, https://hastebin.com/imelinepey.vbs
15:24:20 <jle`> HallaSurvivor: use :i Tree to see
15:24:21 <ph88^> i just thought that if   _ <- end fails   that it doesn't get to   return (x:xs)
15:24:25 <edwardk> if you need particularly tricky constraints you can't use 'deriving' but have to use 'standalone deriving' where you can hint to the compiler that stuff
15:24:36 <edwardk> but in this case the compiler is smart enough to figure it out
15:24:36 <HallaSurvivor> edwardk: that's pretty cool O.o
15:24:59 <HallaSurvivor> jle`: thanks! I almost never use :i, so i forget it exists, haha
15:25:06 <ph88^> edwardk, does   return (x:xs)   still work  because the result of end (the _) is not used in the return statement ?
15:25:23 <edwardk> it doesn't make it there
15:25:31 <edwardk> it fails to parse, thenit doesn't terminate the list either
15:25:36 <edwardk> so the whole failure cascades out
15:25:42 <edwardk> a;a;a; parses fine
15:25:48 <edwardk> a;a;aa   fails and parses _nothing_
15:26:00 <edwardk> it complains about a parse error at the second a in aa
15:26:00 <ph88^> ya ok, but how can   aa;   parse fine ?
15:26:04 <edwardk> it can't
15:26:27 <edwardk> endBy (char 'a') (char ';')  applied to aa;  will fail
15:26:51 <ph88^> oh ok
15:26:52 <Eduard_Munteanu> endBy (many1 (char 'a')) (char ';') would succeed, though.
15:26:58 <edwardk> aa; -- will complain about no parse being available because it expects a ; at the second a
15:27:15 <edwardk> :t some
15:27:17 <lambdabot> Alternative f => f a -> f [a]
15:27:53 <edwardk> endBy (some (char 'a')) (char ';') will parse aa;aaaaa;aaa;aa;   
15:28:12 <ph88^> i understand it now
15:28:22 <edwardk> endBy (many (char 'a') (char ';')) will parse a;a;;;;aaaaa;;;;; so long as the last thing is a ;
15:28:36 <edwardk> er i missed a paren
15:28:42 <edwardk> endBy (many (char 'a')) (char ';') will parse a;a;;;;aaaaa;;;;; so long as the last thing is a ;
15:29:51 <edwardk> the key to all of this is knowing that parsec doesn't backtrack and try the <|> branch when you've consumed input and that 'try' resets knowledge that you've consumed input on failure, erasing error location information, but allowing you to try the other branch.
15:29:52 <ph88^> i just got tripped up on that if you do   (many (char 'a'))    on  aa;   that you think it fails on ;  but actually it doesn't because it succeed on  aa
15:30:13 <ph88^> it's like try one 1 parser
15:30:27 <edwardk> many p -- always succeeds, so long as p either consumes something or fails without consuming anything
15:31:21 <edwardk> if you had many (char 'a' *> char 'a') then tried to parse an even number of 'a's it'll give you a list of the results. if you try to parse an odd number of 'a's it'll die hard with an error pointing to the last one.
15:31:52 <edwardk> many (try (char 'a' *> char 'a')) -- will succeed regardless, and consume an even number, leaving the last odd one there if it was unmatched
15:32:29 <edwardk> try semantics are important to error reporting. this is why attoparsec can never give you real error messages.
15:32:43 <edwardk> because it always backtracks and has no clue what to say was the problem
15:33:02 <edwardk> the flip side is that 'try' is a terrible combinator for error reporting
15:33:18 <edwardk> because you always should use try p <?> "something"
15:33:29 <edwardk> so that error reporting has a thing it can say was the missed alternative
15:33:37 <ph88^> an idea i had for maybe later is first try to parse with attoparsec for speed and then if it fails reparse the whole thing with megaparsec
15:33:55 <edwardk> ph88^: you can do that with the combinators in 'parsers', btw.
15:34:14 <edwardk> well, i never wrote megaparsec instances because that wasn't a thing and i don't see the point, but anyways
15:34:29 <edwardk> i can parse with attoparsec or whatever then switch to trifecta for nice errors.
15:34:57 <ph88^> you reparse the whole input or backtrack a little bit and then reparse with trifecta ?
15:35:29 <fXl> hello, i am trying to implement this in Haskell. http://www.geeksforgeeks.org/find-missing-number-arithmetic-progression/ , i couldnt make it happen, can anybody help me on this one ? 
15:35:30 <edwardk> good question. right now? just reparse the whole thing. i don't have much in the way of support infrastructure around this
15:35:33 <fXl> here what i did so far, https://hastebin.com/imelinepey.vbs
15:35:48 <edwardk> i just write my combinators generic in the "TokenParsing" instance or whatever, then just invoke it twice
15:36:32 <edwardk> the problem is attoparsec doesn't know what code path 'doomed' it to failure
15:36:48 <ChaiTRex> fXl: To do it in O(n) time, you'll need arrays rather than lists.
15:36:54 <edwardk> backing up a little bit would require knowledge of what went wrong and why
15:36:59 <ChaiTRex> fXl: I mean O(n log n)
15:37:06 <ChaiTRex> fXl: log n*
15:37:08 <ph88^> edwardk, ye me too, i have a typeclass where i write the code once and then depending on what i want returned i get a parser or a printer, but i can easily add a parser from another library
15:37:38 <edwardk> i've had bad luck writing mixed parser/pretty printing libs in haskell, but i'm glad its working out for you
15:37:48 <edwardk> i do use a trick like that in c++ though
15:38:14 <fXl> ChaiTrex: i am just trying to implement it first, but couldnt make it :D 
15:38:29 <monochrom> Haha yikes, parse the second time in case of parse error :)
15:38:32 <ph88^> eh sorry i don't mix the parser with the printer .. i mix the parser with the arbitrary generator
15:39:23 <ChaiTRex> fXl: You can use (!!) to get an element at a certain index, much like using arr[i].
15:39:24 <edwardk> the general approach in the crytek serialization library / glenn fiedler's articles:http://gafferongames.com/building-a-game-network-protocol/serialization-strategies/ works really well there
15:39:37 <ph88^> monochrom, when you have a big repository with source files and you are working on a file and for checking if everything is ok you also need to check other files (which are likely to be ok) then those can be fast
15:40:03 <edwardk> i use it to write one serializer and get a binary format, json encode/decode for humans, immediate mode user interface for editing, wire format...
15:40:05 <ChaiTRex> fXl: To directly translate the code, that's a better approach, since they use arr[...] a bit.
15:40:32 <edwardk> an automatic quantizer that duplicates the effect of sending the data over the wire in place..
15:40:48 <fXl> ChaiTrex: can you tell me why my approach doesnt work ? 
15:40:52 <edwardk> overall, good power to weight ratio =)
15:40:57 <ChaiTRex> fXl: Let me take a look.
15:41:05 <fXl> thank you
15:41:23 <ph88^> oh ye you are big into c++ as well
15:41:42 <edwardk> i use it when i need a break from haskell
15:42:06 <edwardk> and my current work can't be expressed in haskell until we fix the compiler in some ways
15:42:11 <edwardk> so, c++ it is!
15:42:12 <edwardk> =)
15:42:16 <ph88^> :)
15:42:31 <ph88^> maybe you can put your thought for the compiler in a ghc ticket
15:42:40 <edwardk> its already being worked on
15:42:49 <ph88^> does it have a ticket ?
15:42:49 <edwardk> but we won't see results until 8.4 at the earliest
15:42:55 <edwardk> ben gamari made one iirc
15:43:15 <ph88^> when is 8.4 due for ?
15:43:27 <edwardk> next year this time
15:43:35 <ph88^> oh that's quick
15:43:39 <edwardk> i raised the issue a month  or so
15:43:42 <edwardk> er ago
15:44:04 <ph88^> well good thing you're doing c++ then
15:44:15 <edwardk> basically our calling convention doesn't allow passing 256bit or 512bit vector types in ymm or zmm  registers
15:44:30 <edwardk> so they always spill
15:44:37 <monochrom> :S
15:45:03 <edwardk> this means i can't write fancy custom c-- primops to implement assembly opcodes we cant write directly in ghc and then hope for link time optimization to inline them
15:45:11 <ph88^> what would be cool if you have a big number, say 1500 bit integer and you can write an abstraction so that the compiler automatically figure out if and how it can use avx for that in the most efficient way
15:45:18 <edwardk> because they'll just inline to messy spill logic, op, messy spill logic
15:45:21 <edwardk> rather than 'op'
15:45:47 <edwardk> ph88^: i'm currently working on a lot of SPMD-on-SIMD code.
15:45:52 <ph88^> nice
15:46:03 <ph88^> i was thinking of doing some hardware simulation on the long term
15:46:11 <ph88^> so i need to handle large bit vectors
15:46:16 <fXl> ChaiTrex: any suggestions ?
15:46:31 <edwardk> in general trying to get obvious simd parallelism out of simd opcodes for one straightline flow of code is a sucker's game. you can generally scale up to about a 4x lane width, but anything further gets under utilized
15:46:54 <edwardk> you need to spot all sorts of non-obvious independencies properties, etc.
15:47:23 <ChaiTRex> fXl: Why are you checking whether the difference of things is 2?
15:47:24 <ph88^> don't know about that
15:47:33 <edwardk> on the other hand, gpu code works great and it executes 'sideways', where you have, say 8 'copies' of the code running at the same time on different data, and a current execution mask of what parts of the simd registers you are using right now
15:48:17 <fXl> ChaiTrex: the list i gave is [1,3,5,9,11] so it should say 7 is missing
15:48:18 <monochrom> Oh sweet, 3-address instructions make a comeback.
15:48:36 <edwardk> then if you compute a boolean (as 8 booleans computed, simd style) and branch on it with an 'if' what you do is figure out if any of the 8 bools was true, if so, mask off all the cases where it holds, and take the true branch, flip the mask, then check if any were false, then take the false branch 
15:48:40 <ph88^> was just considering which language can have nice abstractions (including for parallelism) and give as much raw performance as possible .. not that i think the GC is so much a bottleneck, but i still i have a feeling that mutable would be faster
15:48:53 <fXl> ChaiTrex: the elements should have 2 in difference
15:48:54 <edwardk> mutable doesn't really matter here
15:49:02 <edwardk> its more about this style of control flow
15:49:03 <alex4> Hey guys, I was wondering if any of you knew of any reference material for conventions in haskell? Things like organizing a projects/modules, best practices (concepts like avoiding explicit recursion, etc.), perhaps some kind of architectural models
15:50:05 <ph88^> for the hardware simulation or for your simd you're working on ?
15:50:22 <edwardk> alex4: no idea. my code is typically unorganized (ask anyone), and i use lots of explicit recursion =)
15:50:41 <edwardk> ph88^: no hardware simulation here. i'm running on x86-64
15:50:58 <ChaiTRex> fXl: search [1,3,5,9,11] is 7.
15:51:14 <ph88^> edwardk, ya ok .. i mean i was just saying i would like these optimization to get more performance when doing simulations ..
15:51:21 <edwardk> just saying that i don't need my host language to be all fancy about mutation, i can get by with haskel like semantics and in many way they encourage a better style of code for me
15:51:28 <edwardk> ah
15:51:49 <ph88^> ye that's cool
15:52:04 <edwardk> as for why haskell-like stuff works better, i have to keep that execution mask around, right? which i need when doing scatters/gathers from main memory
15:52:06 <ChaiTRex> fXl: As an aside, one bug is that x isn't the element right next to the middle element.
15:52:12 <alex4> I'm no expert in haskell by any means, but I was thinking about working on collecting knowledge for writing conventional, practical haskell in real applications in a single place of reference (probably the haskell wiki)
15:52:28 <alex4> I was just curious if such a thing has been done
15:52:34 <edwardk> but when if i use explicit ternary blends with a mask and two source operands, i don't need to care about my mask, reducing my operation count
15:53:05 <edwardk> but in c++ with operator overloading i can't tell that reusing a temporary without changing my execution mask shouldn't bother to mask off before re-assignment
15:53:13 <edwardk> it'd be better for me to be using fresh variables everywhere in the loop
15:53:17 <edwardk> but c++ makes that hard
15:53:26 <fXl> ChaiTrex:  can you try this one ? [1,3,5,7,9,11,13,17,19] 
15:53:35 <fXl> 15 should be the missing
15:53:53 <ph88^> edwardk, i'd prefer the good stuff be moved into haskell, because i bet on there :P
15:54:03 <edwardk> sure.
15:54:15 <edwardk> i'm writing my code in c++ at the moment so i can figure out how to write a compiler for it in haskell ;)
15:54:47 <edwardk> that and its still nicer to write graphics stuff out in c++ than in haskell
15:54:54 <edwardk> as sad as that may be
15:56:11 <edwardk> it continually astonishes me that we don't have a std::vector equivalent to make it easy to do push_back style growth of arrays, etc.
15:56:27 <edwardk> there are some obvious gaps in our libraries
15:56:32 <edwardk> maybe i should fix that one at some point =)
15:56:37 <ChaiTRex> fXl: Right, and that searches [1,3,5,7,9,11,13,17,19], then [11,13,17,19]. At that point, x is 11 rather than 13.
15:59:33 <edwardk> (yes you can roll your own atop an IORef and a Mutable Vector)
16:00:25 <ChaiTRex> fXl: Your code has no chance of working properly. You can't tell where an element is missing by looking at only whether two elements surrounding the middle one have the proper distance.
16:00:45 <ChaiTRex> fXl: To see why, tell me whether I should look left or right if the middle elements are 9, 11, 13?
16:00:55 <ChaiTRex> fXl: There's no way of telling which way to go.
16:02:24 <fXl> ChaiTrex: yeah, i couldnt think how to handle if nothing misses :D if understood you correctly
16:04:31 <mniip> edwardk, [] and :?
16:04:41 <mniip> : is literally push_front
16:05:09 <Koterpillar> no random access though
16:08:44 <Sonolin> is there a common way to short circuit a monad (i.e. "throwM"), but recover the previous result (before the exception)?
16:09:18 <Sonolin> for example, one implementation of my simple interpreter is "Maybe" - I want a "Nothing" value anywhere in the chain to just return the previous Just
16:09:27 <Koterpillar> Sonolin: you aren't even going to know the type of that result
16:09:49 <Koterpillar> maybe you want some kind of ContT?
16:09:51 * ski supposes Sonolin wants `[Maybe a] -> Maybe a
16:09:55 <ski> '
16:10:07 <Sonolin> Hmm yeaw I was thinking of ContT
16:10:19 <Sonolin> and ski perhaps I can just implement my interpreter for [Maybe a] instead of Maybe a hmm..
16:10:39 <jle`> Sonolin: the main problem is that, yeah, the last Just in a (Maybe a) might not have type 'a'
16:11:22 <Sonolin> well the type of the function in question returns a "Maybe a" for an "a" value 
16:11:29 <Sonolin> that's the one I'm trying to "short circuit"
16:11:44 <Sonolin> so I guess I technically know that if its a "Just" value the value inside will be the same as the parameter
16:12:05 <monochrom> I think it would be the clearest if you wrote some mock code and say what it should do. "Previous result" doesn't seem to be meaningful.
16:12:32 <Koterpillar> Sonolin: do { x <- Just 1; y <- Nothing; return (Just "hello") }
16:12:50 <Koterpillar> Sonolin: it'll error on Nothing, do you want 1 instead of "hello"?
16:13:01 <Sonolin> yea I guess you're right
16:13:05 <Sonolin> I think I just want ContT
16:13:19 <Sonolin> well I'll try that at least, thanks guys
16:14:00 <jle`> Sonolin: also do { x <- Just 1; y <- Nothing } :: Maybe String
16:14:22 <jle`> the last Just was 1, but like, how would you know that if you had Maybe String
16:14:34 <Sonolin> yay ConT has MonadThrow
16:14:36 <jle`> * do { x <- Just 1; Nothing } :: Maybe String
16:14:41 <Sonolin> I think that should work :)
16:16:10 <johnw> Sonolin: how about ExceptT (a, String) b?
16:21:41 <jle`> johnw: for some monad b?
16:22:53 <fXl> ChaiTrex: thank you for your help
16:26:33 <ChaiTRex> fXl: You're welcome.
16:34:41 <Ptival> what are possibilities for a Haskell program segfaulting? the program only uses readFile, readCreateProcess, writeFile
16:34:50 <Ptival> can it be some OOM issue?
16:35:15 <jle`> segfaulting during runtime usually comes from bad ffi
16:35:23 <jle`> or an unsafe interface
16:36:49 <dmj`> Ptival: can you paste code?
16:39:27 <Ptival> dmj`: trying to reduce the culprit space a bit before, but will do :)
16:40:21 <dmj`> as jle` said,  if you have your own ffi bindings to stuff, those are prime candidates
16:43:30 <johnw> jle`: oops :)
16:55:31 <Ptival> no, the code does almost nothing, it just opens files, calls git commands through `readCreateProcess`, and writes files
16:55:41 <Ptival> it takes forever to crash so testing is slow :)
16:56:25 <Ptival> I am now testing with less memory contention, I'm not sure whether it will segfault, will see :\
17:13:56 <Jello_Raptor> Hmm, I'm looking for algorithms for sub-hypergraph isomorphism with a few caveats. Basically, the vertices on the hypergraph are typed, the edges are typed, and each edge has named vertices, all the types and names must match for the sub-hypergraphs to be isomorphic. 
17:14:33 <Jello_Raptor> that has so many additional constraints that it should be easier than the raw problem, but I'm wondering what the literature would call problems like that. 
17:15:24 <Jello_Raptor> I'm not sure what terms to search for. 
17:29:24 <mniip> Jello_Raptor, you probably could assemble gadgets to reduce your problem to a regular graph iso problem
17:35:57 <Jello_Raptor> mniip: yes, but there's no way that's going to vaguely efficient
17:36:11 <mniip> that depends
17:36:36 <Jello_Raptor> Though I should probably go through a graph-io and hypergraph-iso algorithms to see if any are adaptable.
17:36:40 <Jello_Raptor> mniip: mmm? 
17:38:44 <dosequis> hi all - not sure how to search for this. Basically, I want a function like this: http://lpaste.net/6008476942922153984 - I was expecting to be able to do this via pattern matching, but that doesn't appear to be the case
17:38:50 <jle`> huh, these docs definitely got mangled during rendering
17:38:51 <jle`> http://hackage.haskell.org/package/data-default-0.7.1.1/docs/Data-Default.html
17:39:22 <jle`> dosequis: 'Show a => a -> String' means that your function has to work for *all* types 'a' that are instance sof Show
17:39:45 <jle`> dosequis: so, you should be able to pass (), Maybe Int, Double, etc.
17:40:00 <jle`> dosequis: but, how you've pattern matched, it seems like it only works for Maybe-something's
17:40:09 <Koterpillar> dosequis: what is the type of (Just x)?
17:40:12 <dosequis> jle`: ah ok I see
17:40:35 <dosequis> well basically I want to avoid having the "Just x" printed out
17:40:43 <dosequis> where x could be an Int, for example
17:40:56 <dosequis> basically, I just want a 'short' string representation
17:41:08 <dosequis> instead of "Nothing", just want ""
17:41:36 <Koterpillar> dosequis: that's fine, what is the type of (Just x)?
17:41:39 <jle`> dosequis: maybe change the type signature, show' :: Show a => Maybe a -> String
17:42:25 <dosequis> jle`: yeah but they won't always be Maybe's
17:42:35 <jle`> dosequis: if they aren't Maybe's, then use show
17:43:21 <dosequis> jle`: hmmm ok - basically I have another block of code that maps show over a list of 'things'
17:43:47 <dosequis> jle`: I just figured I would have a custom show function that would do this for me
17:43:57 <dosequis> jle`: instead of having to go in and 'figure' that out
17:44:09 <dosequis> jle`: on the collection of things that is
17:44:20 <jle`> dosequis: well, don't you know if your things are Maybe or not?
17:44:34 <jle`> or do you want it to work polymorphically for all Show a's?
17:44:50 <jle`> Haskell's type system enforces something called parametric polymorphism
17:45:12 <jle`> which means that any implementation you write for a polymorphic function has to work equally/the same for *all* possible instances/types that it is given
17:45:22 <dosequis> jle`: yeah I want it polymorphic - basically, they are usually not Maybe's, but if someone maps a function that generates Maybes, then I want to display them "compressed"
17:45:57 <jle`> yeah, that would break parametric polymorphism if done directly
17:45:59 <dosequis> jle`: ok - I was thinking I could just handle the cases I care about and default to show
17:46:20 <jle`> you have to treat the input identically, no matter what type it is
17:46:28 <jle`> there are hacks you can do to get around this
17:46:29 <dosequis> jle`: hmm ok seems like I would have to read up on this
17:46:39 <dosequis> jle`: ok yeah I think I understand
17:46:44 <jle`> yup, it's the same principle that lets you prove that 'id :: a -> a' has only one implementation
17:46:49 <jle`> it can only return the same value it is given
17:47:02 <jle`> because it has to work identically on all types, regardless of what type is given
17:47:15 <jle`> if what you were proposing could be done, you would be able to write something like:
17:47:20 <jle`> id 'c' = 'a'
17:47:21 <jle`> id x = x
17:47:22 <dosequis> jle`: yeah I suppose that makes sense - but I mean in this case it would always still return a String
17:47:36 <jle`> so id would work different when given a Char, then when given a different type
17:47:49 <dosequis> jle`: basically I am just defaulting to the default show implementation
17:47:51 <jle`> so there goes all type safety in haskell
17:48:03 <jle`> out the window :'(
17:48:15 <dosequis> jle`: hmm ok I think I have to thing / research this one - thanks for pointing me on the right track 
17:48:22 <dosequis> jle`: think*
17:48:29 <jle`> no problem.  there are some hacks that would let you get this behavior, but i don't think any of them are ideal
17:48:51 <dosequis> jle`: yeah I generally prefer to avoid the hacks when possible
17:49:43 <jle`> parametric polymorphism is pretty powerful in what it tells you you can or can't do, heh
17:50:02 <dosequis> jle`: yeah never stop learning with Haskell
17:50:58 <dosequis> jle`: still not sure why I can't pattern match in this case - is it because the compiler figures that I am always using Maybe's, when I am also trying to support 'all other types' in my last statement?
17:51:25 <jle`> whatever implementation you use has to work uniformly across all types
17:51:25 <dosequis> jle`: if you don't mind me asking, of course...
17:51:43 <jle`> so pattern matching on Just *only* if it was Maybe would mean a different implementation for Maybe types
17:51:55 <jle`> than for normal types
17:52:04 <jle`> you are essentially able to branch on "is this maybe or not"
17:52:48 <dosequis> jle`: hmmm ok so would I be able to rewrite the function by checking if it's a Maybe? like if Maybe do this, if not, just show 'a'
17:53:49 <dosequis> jle`: or is the mere fact that I am making this check breaking the guarantees haskell imposes
17:54:12 <jle`> yes, you can't make that check and keep it polymorphic for all Show a
17:54:15 <ski> "if Maybe do this, if not, just show 'a'" is also against parametricity, unless you add some extra info to enable that
17:54:32 <dosequis> jle`: ok thanks again!
17:54:37 <dosequis> ski: thanks!
17:54:49 <jle`> kind of like my example with id.  if you could check such a thing, then you could write 'fakeId :: a -> a; fakeId (Just x) = Nothing; x = x'
17:55:00 <jle`> then 'fakeId :: a -> a' breaks parametricity
17:55:24 <dosequis> jle`: hmmm ok thanks again for taking the time - I'll read up on this and make sense of it
17:55:43 <jle`> the ways to get around this are essetnailly to pass in extra information that lets you branch on the type
17:55:59 <jle`> so it's not "perfectly polymorphic", but constrained to only be things you have runtime information for typechecking on
17:56:05 <jle`> s/typechecking/checking the type
17:56:31 <jle`> or other ways of passing in information, like using typeclasses
17:56:39 <jle`> that's what the 'Show' typeclass does, by the way
17:56:43 <dosequis> jle`: ah ok I think I understand now
17:56:51 <JamEngulfer> I'm having some really tricky issues with types and stuff. I've got a lambda in a map being applied to an array, that's supposed to end up with an array of strings. The thing is, " map (\(x,y) -> "") a " works fine, but " map (\(x,y) -> replicate (3 'x')) a " fails to compile, telling me this error: https://gist.github.com/anonymous/3d7f90dc67f3ee7ee7332dff325cd136
17:56:55 <jle`> the Show typeclass associates a unique 'show' method for every type, so every type gets its own "showing" function
17:57:20 <jle`> so one thing you might be able to do as a hack is a 'ShowTruncated' typeclass, and those instances can be written on a per-type basis
17:57:26 <dosequis> jle`: yeah I was trying to avoid having my own typeclass for this usecase, but I think that would solve my problem
17:57:31 <JamEngulfer> I've been at this nearly an hour and I can't for the life of me figure out what's wrong
17:57:37 <jle`> it would solve your problem but introduce new ones for sure, heh
17:57:52 <jle`> JamEngulfer: can you post your code too
17:57:57 <dosequis> jle`: yeah but I think in most cases, I will just have to deal with Maybe or 'normal' values
17:58:10 <dosequis> jle`: anyways thanks for your time
17:58:10 <Koterpillar> dosequis: what do you want to do with this value:
17:58:16 <Koterpillar> :t Just (Just (Just 3)))
17:58:16 <dosequis> jle`: very helpful
17:58:17 <lambdabot> error: parse error on input ‚Äò)‚Äô
17:58:19 <Koterpillar> :t Just (Just (Just 3))
17:58:20 <lambdabot> Num a => Maybe (Maybe (Maybe a))
17:58:34 <Koterpillar> dosequis: how many layers will you peel off
17:58:37 <Koterpillar> also
17:58:40 <Koterpillar> :t [Just 1, Nothing]
17:58:42 <lambdabot> Num a => [Maybe a]
17:58:53 <dosequis> Koterpillar: yeah I see - didn't think about it that way
17:59:18 <dosequis> Koterpillar: I think I will just create a typeclass for my particular usecase
17:59:25 <dosequis> Koterpillar: seems like the simplest solution
17:59:28 <jle`> "i had a problem, so i made a typeclass.  now i have two problems"
17:59:32 <JamEngulfer> jle`: https://gist.github.com/anonymous/49bae37d6c04e4155ce4e42d9c4bb769
17:59:37 <ski> JamEngulfer : it's not an array, it's a (single-linked) list. remove the pair of brackets following `replicate'
17:59:40 <dosequis> jle`: haha yeah 
17:59:57 <jle`> JamEngulfer: what do you think replicate (3 'c') does
18:00:09 <jle`> actually, what do you think 'replicate' does?
18:00:14 <JamEngulfer> makes an array containing 3 instances of 'c'
18:00:19 <jle`> not quite
18:00:32 <jle`> replicate 3 'c' make sa list of 3 'c's
18:00:35 <Koterpillar> JamEngulfer: no need for brackets around function parameters
18:00:37 <JamEngulfer> It couldn't be that simple XD
18:00:38 <jle`> bot replicate (3 'c') doesn't quite make sense
18:00:44 <jle`> s/bot/but
18:00:54 <jle`> that means that you're applying the function 3 to 'c'
18:01:02 <jle`> but in most sane situations, 3 isn't a function
18:01:13 <dosequis> jle`: I mean basically I have a "Fretboard" which is just a [[Note]], where Notes have a "nice" show like C, C#, D, etc. Now if I map say "notes2degrees", I end up with a Maybe Degree, and now my "Fretboard" looks awful because I have Just and Nothing all over the place. I want to have a nice compact representation.
18:01:53 <jle`> dosequis: if you're only going to use it with Note, then just write a separate function for showing [[Note]]s and [[Maybe Note]]s
18:02:38 <JamEngulfer> That's super infuriating. I *swear* I tried it without the brackets around the arguments.
18:03:02 <JamEngulfer> Well, it's all fixed now
18:03:07 <dosequis> jle`: yeah I guess I just wanted to have that be transparent. So if you have fretboard A, and then you map some transformer over it, you can just display it in the console without having to call a different funciton depending on the type
18:03:23 <JamEngulfer> Thanks for the help! I guess habit from other programming languages just tripped me up
18:03:24 <ski> JamEngulfer : also, you could use `concatMap'
18:03:31 <monochrom> It is in fact possible to write your own class, and make two instances: one for Note, one for Maybe a.
18:03:37 <dosequis> jle`: mostly just for convenience/elegance on my end
18:04:00 <dosequis> jle`: and not having to remember to call a different function depending on what I end up with
18:04:05 * geekosaur would not use Show for this but instead make a FretV class
18:04:09 <JamEngulfer> ski: oh neat, thanks for the tip
18:04:39 <jle`> using a different function depending on what type you have isn't too painful, though
18:04:41 <geekosaur> with a default class method that requires Show, so it can be "auto-derived" as a fallback. or provide your own
18:04:43 <jle`> especially if you only have two possibilities
18:04:46 <dosequis> monochrom: ok yeah that's what I think I will do
18:05:01 <geekosaur> although yes, it does depend on whether there will be other instances...
18:05:29 <ski> > [c | (x,y) <- range ((0,0),(1,2)),c <- "ccc"]
18:05:29 <dosequis> ok thanks for all the suggestion all - I have some different options to explore
18:05:29 <monochrom> If you really have 10 or fewer types in question, write your own class and instance them.
18:05:31 <lambdabot>  "cccccccccccccccccc"
18:05:55 <dosequis> monochrom: yeah probably just 1-3 types, I suspect
18:05:58 <geekosaur> but it does simplify this kind of thing
18:06:15 <dosequis> I think I'll just have a FretShow class
18:06:29 <dosequis> that will default to using show
18:07:49 <dosequis> have to leave but thank you everyone for the help - much appreciated!!
18:39:15 <JamEngulfer> Is there any function to convert a char to the int it represents and back without having to add and subtract 48 from it after using chr and ord?
18:43:13 <monochrom> One moment, I think I have seen it before.
18:44:02 <monochrom> Ah digitToInt in Data.Char. Convert's A-F to 10-15 too.
18:44:15 <monochrom> > digitToInt '4'
18:44:17 <lambdabot>  4
18:44:21 <monochrom> > digitToInt 'b'
18:44:23 <lambdabot>  11
18:44:29 <JamEngulfer> oh nice, thanks !
18:54:47 <Ushakovo> Is there anyone around who could answer a newbie question about folds?
18:55:31 <Sornaensis> don't ask to ask just ask
18:56:55 <Ushakovo> Ok I am having trouble understanding how to pass more than two arguments to a fold function
18:57:14 <Koterpillar> what do you want that to do?
18:57:20 <pacak> What kind of fold  function? And what kind of arguments do you have in mind?
19:00:43 <Ushakovo> Never mind I realized that what I wanted to do would work with just a fold
19:01:23 <pacak> Rubber duck debugging.
19:01:26 <pacak> Works always.
19:01:47 <exio4> rubber duck debugging is precious
19:02:03 <exio4> had been fighting with a few bugs since yesterday, got it solved when I asked about it :)
19:02:18 <exio4> it was in the details I had to explain that the issue was obvious
19:03:01 <Ushakovo> I have never heard that term before but that's just what I need to do
19:28:09 <freeside> m4lvin[m]: if you turn up in the next few weeks, ping me, i'd like to chat about your work
19:29:03 <freeside> m4lvin[m]: i've been researching model checking for modal logics and have come across a load of work by Gerardo Schneider and Cristian Prisacariu that i'd like to discuss with you
19:31:43 <freeside> so far I have identified three languages for non-epistemic logics that are equipped to various degrees with verifiers -- CLAN (Gothenburg), CDL (Stanford), and SPINdle+ (Data61). in particular Prisacariu's PhD thesis looks very close to your work: "A Dynamic Deontic Logic over Synchronous Actions".
19:44:38 <lpaste> lambdafan pasted ‚Äúinterleaving problem with conduits‚Äù at http://lpaste.net/354263
19:44:50 <lambdafan> yo
19:48:01 <Cale> isolate :: Monad m => Int -> Conduit a m a -- perhaps try this?
19:48:32 <lambdafan> Cale: thanks I was about to write my own version of sourceHandle ;)
19:49:07 <lambdafan> Cale: what module is isolate in?
19:49:16 <Cale> Data.Conduit.List
19:49:44 <jayshua> I was trying to learn about Haskell's sequences, but my searches for "sequence" on hackage only came up with this library: http://hackage.haskell.org/package/sequence-0.9.8/. I finally stumbled across a link on stack overflow to the real sequence docs: http://hackage.haskell.org/package/containers-0.5.10.2. Any reason it was so hard to find? Am I m
19:49:44 <jayshua> issing some search secret?
19:50:24 <lambdafan> how did you go about doing the serch, did you try using hoogle?
19:50:33 <Cale> https://www.google.ca/search?q=Haskell+Data.Sequence
19:50:54 <Cale> first result for me is the generic link to the containers package
19:51:05 <jayshua> I was here: http://hackage.haskell.org/packages/search?terms=sequence
19:51:06 <Cale> https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html
19:51:28 <Cale> That search is really only good for searching by module name
19:51:31 <Cale> er, package name
19:51:38 <Cale> Or package name and description, I suppose
19:52:05 <Cale> If you were to search for "containers" you'd find the package there
19:52:25 <Cale> But even Data.Sequence doesn't find you containers.
19:52:46 <Cale> It's better to either use google or some specialised API search like Hoogle
19:53:12 <jayshua> I see. Normally I do search on Hoogle, I didn't realize they gave two different results.
19:53:19 <Cale> https://www.haskell.org/hoogle/?hoogle=Data.Sequence
19:53:55 <jayshua> Thank you!
19:54:20 <lambdafan> Cale: ah you use it with the sink not the source
19:54:42 <lambdafan> I was trying to constrain the source
19:56:20 <Cale> you might prefer pipes
19:57:31 <Cale> Well, at least I find the way that it does things makes a bit more sense
19:57:55 <Cale> In pipes, the corresponding thing is called 'take', and its implementation is simply this:
19:57:57 <lambdafan> Cale: next time maybe, but I'm too invested in this codebase to start over
19:57:59 <Cale> https://hackage.haskell.org/package/pipes-4.3.2/docs/src/Pipes-Prelude.html#take
20:00:28 <lambdafan> Cale: Thanks so much. This did motivate an ivestigation into pipes next time I have a streaming problem
20:00:38 <lambdafan> but that did the trick
21:00:44 <vaibhavsagar> I'm trying to configure Hakyll to route a blog post based on both the date and the filename. The date is in the metadata and there doesn't seem to be a simple way to construct a route based on both the Identifier and the Metadata. Is there something I'm missing?
21:01:41 <vaibhavsagar> One option is to add a "slug" field to the metadata and another is to add the date to the filename
21:02:40 <vaibhavsagar> but is there a customMetadataRoute?
21:18:43 <dmj`> vaibhavsagar: you mean like blog.com/<date>/<name>
21:20:14 <Myrl-saki> "The reason is that the semi-algorithm terminates for all typable expressions and only fails to terminate for a very small fraction of untypable expressions
21:21:07 <vaibhavsagar> dmj`: exactly
21:21:16 <Myrl-saki> Polymorphic Type Inference, p. 20
21:21:24 <vaibhavsagar> that's the way it works in the SSG I'm switching from
21:22:55 <vaibhavsagar> actually more like blog.com/yyyy/mm/dd/<name>
21:23:54 <vaibhavsagar> currently I'm using <date>-<name>.md for my filenames and https://github.com/vaibhavsagar/hakyll-website/blob/6010314e7dd2ba778ba4955dfdf14f3dcceb5e13/site.hs#L86-L97
21:27:16 <dmj`> yea, hakyll isn‚Äôt simple 
21:27:23 <dmj`> did you try to match on metadata
21:27:29 <dmj`> https://hackage.haskell.org/package/hakyll-4.9.5.1/docs/Hakyll-Core-Rules.html#v:matchMetadata
21:29:21 <dmj`> ah there is a metadata route, https://hackage.haskell.org/package/hakyll-4.9.5.1/docs/Hakyll-Core-Routes.html#v:metadataRoute
21:32:15 <vaibhavsagar> the metadata doesn't contain the filename :(
21:34:08 <dmj`> hmm, what does it contain?
21:34:11 <vaibhavsagar> customRoute would give me the Identifier but grabbing the Metadata from an identifier requires me to be in IO
21:34:23 <vaibhavsagar> just YAML frontmatter
21:36:56 <dmj`> and the filename isn‚Äôt in the yaml front matter?
21:37:06 <vaibhavsagar> nope
21:37:15 <jle`> you can get the metadata without IO
21:37:40 <vaibhavsagar> tell me more jle` :)
21:37:42 <jle`> in fact you aren't supposed to use IO get metadata
21:37:48 <jle`> http://hackage.haskell.org/package/hakyll-4.9.5.1/docs/Hakyll-Core-Metadata.html
21:38:07 <vaibhavsagar> ah, I see
21:38:21 <vaibhavsagar> but I can't do it within a pure function
21:38:42 <jle`> you're trying to make your route, right?
21:39:18 <dmj`> vaibhavsagar: I think you need to add both date and title to your markdown files, and then it will be in the metadata
21:39:33 <vaibhavsagar> jle`: yes
21:40:01 <vaibhavsagar> dmj`: this is what I meant by a 'slug' field
21:40:02 <jle`> vaibhavsagar: can you use metadataRoute?
21:40:12 <vaibhavsagar> jle`: that doesn't contain the filename
21:40:17 <jle`> for my blog it uses slug first and filename if it doesn't have one
21:40:21 <jle`> vaibhavsagar: you can compose routes
21:40:25 <jle`> using composeRoutes
21:40:37 <dmj`> jle`: I didn‚Äôt know your blog was hakyll, thought it was homegrown
21:41:04 <vaibhavsagar> I'm trying to replicate my Pelican setup
21:41:10 <jle`> nah its hakyll :) i made a whole blog post abotu the transition
21:41:13 <vaibhavsagar> so I already have a cleanUrls route
21:41:19 <jle`> actually you don't even need to use composeRoutes
21:41:28 <jle`> metadataRoute :: (Metadata -> Routes) -> Routes
21:41:33 <dmj`> jle`: ah yes, I vaguely remember
21:41:59 <jle`> vaibhavsagar: so you can check the metadata, and use the title to make your route
21:42:00 <dmj`> https://blog.jle.im/entry/blog-rewrite-with-hakyll-and-purescript.html
21:42:17 <dmj`> so when is the ghcjs rewrite?
21:42:20 <dmj`> ;)
21:42:26 <vaibhavsagar> jle`: I want the filename though
21:43:10 <jle`> you can think of "route" as (FilePath -> ...)
21:43:17 <jle`> a Route has access to the filepath
21:43:18 <dmj`> vaibhavsagar: so you‚Äôre assuming that filename won‚Äôt be accessible because you need IO to fetch it
21:43:31 <jle`> i mean, look at 'setExtesion :: String -> Route'
21:43:53 <vaibhavsagar> dmj`: no, I can get that with customRoute
21:44:44 <vaibhavsagar> jle`: I think I understand about "route"
21:45:20 <jle`> you can use gsubRoute
21:45:29 <jle`> to manipulate the filepath arbitrarily
21:45:30 <vaibhavsagar> and I do currently
21:45:54 <jle`> you can use gsubRoute w/ metadata route, and then you have access to both the filepath and to the metadata
21:46:24 <jle`> metadataRoute (\md -> gsubRoute (something) (something involvimg metadata))
21:46:36 <vaibhavsagar> hmm, that makes sense
21:46:52 <vaibhavsagar> then that becomes a composeRoute?
21:47:11 <jle`> this way you don't need composeRoute, unless you want to compose the gsubRoute
21:47:25 <vaibhavsagar> cool, I will try that, thanks!
21:49:36 <jle`> no problem!  my blog is open source at https://github.com/mstksg/blog btw if you ever wanted to peek
21:49:57 <jle`> when iwas making it i actualy transitioned from a different system so i had to put in some work to make everything match up
21:50:07 <jle`> so it might be a good example of twisting hakyll past its comfort zone, heh
21:52:11 <vaibhavsagar> yeah, I feel like that's what I'm trying to do here
21:52:46 <vaibhavsagar> my dream is to swap my Pelican blog over to it and have all the links still work
21:53:07 <vaibhavsagar> preferably with minimal post edits
22:03:23 <jle`> i almost got it perfect for me, except for the fact that github pages serves the wrong mime types for some of my files
