00:26:11 <fendor> i love it that it is so empty in the morning
00:26:33 <cocreature> only 1488 people, it’s really empty :)
00:43:46 <reuben364> Yo. Can anybody tell me why this won't typecheck and how to fix it: https://pastebin.com/z3XL306L
00:44:58 <opqdonut> you might need ScopedTypeVariables
00:45:11 <opqdonut> otherwise you can't refer to the same w
00:45:16 <reuben364> That is already included.
00:45:26 <opqdonut> ok
00:45:31 <opqdonut> what's the error?
00:45:39 <reuben364> It can't find the instance of FiniteBits
00:46:48 <reuben364> I think for some reason the ScopedTypeVariables isn't carying the constraint.
00:47:38 <opqdonut> btw the nicer way to type this is
00:47:38 <reuben364> But I wouldn't know how to fix that.
00:47:55 <opqdonut> example proxy = finiteBitSize (undefined `asProxyTypeOf` proxy)
00:50:39 <reuben364> K, that fixes the example, but the context that I wanted to use such a function still doesn't work.
00:51:12 <opqdonut> weird
00:51:29 <reuben364> I want to write a function beSplit :: (Integral w, FiniteBits w, Integral v, FiniteBits v) -> v -> [w]
00:52:21 <mathk> @pl (\ch -> 'a'<=ch && ch <= 'z')
00:52:21 <lambdabot> liftM2 (&&) ('a' <=) (<= 'z')
00:53:12 <reuben364> k, brb. need to leave with laptop and don't have bnc
00:54:05 <opqdonut> reuben364: try an explicit forall, it fixes your `example` function for me. So: example :: forall w. FiniteBits w => Proxy w -> Int
00:54:19 <mathk> @pl (\ch a z -> a <=ch && ch <= z)
00:54:19 <lambdabot> ap (flip . (((.) . (&&)) .) . flip (<=)) (<=)
01:01:03 <dysfun> is there some writeup on type families that explains it like it's an idiot reading?
01:03:20 <phz_> hey
01:03:22 <phz_> :t (#)
01:03:26 <lambdabot> error: parse error on input ‘)’
01:03:31 <phz_> anyone knows where this operator come from?
01:03:34 <phz_> (besides lens, of course)
01:03:48 <phz_> I saw it in diagrams samples code
01:05:55 <reuben364> continuing the discussion on my problem: https://pastebin.com/z3XL306L
01:06:35 <[exa]> dysfun: it's for adhoc overloading; i.e. when all overloaded stuff with one name doesn't actually have the same type scheme
01:07:51 <[exa]> dysfun: C++ and template specializations (e.g. vector<bool> a completelly different structure than vector<int>) are a prime example of adhoc overloading
01:08:44 <dysfun> aha, i know c++ templates
01:10:04 <dysfun> i'm building something like datascript in haskell and i have some difficulties tightening up some of the looseness you get in datascript (because clojure is a dynamic language)
01:10:13 <dysfun> i am not quite sure if type families are the answer
01:10:39 <dysfun> my gut feeling with comparison to c++ templates is no
01:10:55 <[exa]> dysfun: now to do that, you need some logic in type system that for type (Vector Bool) generates one specialization (i.e. one form of data constructor) and for type (Vector _whatever) generates a generic one
01:11:36 <dysfun> oh right
01:11:38 <dysfun> i see
01:11:41 <dysfun> thanks ;)
01:11:51 <[exa]> the fact that it is carried out by "type functions" and that Vector is now a type function can be abstracted out I guess
01:12:01 <[exa]> maybe dive directly into your problem?
01:12:15 <dysfun> good idea
01:13:00 <dysfun> datascript essentially stores all data as (entity,attribute,value) tuples, so it's pretty loose
01:13:12 <dysfun> they have a schema where you can add validation on top
01:13:49 <dysfun> the closest haskell equivalent to that seem to be to define a datatype that is a union of all possible attributes
01:14:13 <dysfun> am i making sense so far?
01:14:45 <[exa]> so you want to rewrite the schemas to type language and expect not to receive an invalid schema, right?
01:14:59 <[exa]> *invalid tuples
01:16:34 <dysfun> well, this is all quite experimental, but at the minute i've defined a datatype that is a union of all possible attributes. For example in datascript you may have an (1,UserEmail,123) ; pseudocode 
01:17:02 <dysfun> i've dropped the tuple part and gone for a datatype where UserEmail String is one of the constructors
01:17:18 <dysfun> that 123 should have been "foo@example.org" of course
01:19:04 <dysfun> now, i figure i can create an enum instance to derive an 'attribute' value (because they're just unique identifiers) and the value can be that union type
01:20:49 <dysfun> but now i am trying to do the rest of their schema. for example they have three possible uniquenesses - not unique, unique where insert duplicate is an error, unique where duplicates overwrite
01:21:24 <[exa]> well, not sure if the type system can handle uniqueness
01:21:38 <dysfun> i don't expect it to - i'll check :)
01:21:55 <[exa]> you'd have to stuff in some kind of function that stores other values and autochecks it
01:22:24 <dysfun> but now i'm writing a typeclass method for each of the possible values (with the idea being that you can choose for each of the constructors of the datatype what Uniquity to return, Cardinality to return etc. and the default is Nothing
01:23:55 <[exa]> so I guess you want the function "specialized" for different cases of uniquity (unique returns Maybe a, non-unique returns [a], exact cardinality can return (a,a,a...) ) etc?
01:25:40 <dysfun> hrm, i hadn't considered that. datascript just has 'one' and 'many'
01:25:49 <[exa]> if that's true it sounds a tiny bit like multiparameter typeclasses
01:25:52 <[exa]> https://downloads.haskell.org/~ghc/4.08/docs/set/multi-param-type-classes.html
01:25:52 <phz_> hm, is there a function that takes a list and remove its duplicate using a Set?
01:25:59 <phz_> toList . fromList, something like that
01:26:13 <dysfun> already using multiparameter typeclasses :)
01:26:32 <reuben364> I have no background of datascript. Is the collection of tuples (e, a, v) a superset of databases, where each entry can have any number of attributes.
01:26:33 <[exa]> phz_: nub
01:26:34 <dysfun> nub removes duplicates
01:26:43 <phz_> [exa]: it’s implemented with a Set?
01:27:06 <[exa]> phz_: probably not, docs say it's O(n^2)
01:27:09 <phz_> O(n^2)
01:27:09 <phz_> yep
01:27:14 <phz_> I don’t want that then
01:27:25 <dysfun> reuben364: e is an integer, a is one of a set of keywords (which can be added to by simply using a column) and v is any value at all
01:27:52 <[exa]> The name nub means `essence'.        wat.
01:27:57 <dysfun> so it's (entity-id, attribute-id, attribute-value)
01:28:11 <phz_> [exa]: don’t look for the meaning
01:28:12 <phz_> :D
01:28:24 <phz_> Haskell gets exotic in a lot of spaces
01:28:27 <dysfun> [exa]: anglicism
01:28:38 <[exa]> it always amazes me.
01:28:39 <phz_> it’s all about pictures!
01:28:56 <phz_> the fix function, even though it means something, has an exotic name to me
01:29:04 <phz_> fix is more about recursion than finding a fix point :)
01:29:39 <[exa]> you said it, "is more about recursion than finding a fix point" is exactly the basic property of Y
01:29:49 <[exa]> naming is hard.
01:30:38 <phz_> [exa]: of Y?
01:31:14 <dysfun> reuben364: there are then three indexes of these tuples, which are collections ordered by three different permutations of column order
01:31:55 <mniip> phz_, it does find the least fix point
01:32:06 <phz_> mniip: we don’t use it for that
01:32:16 <mniip> the least fixpoint of '1:' is 'cycle 1'
01:32:17 <phz_> we use it to bind a recursive value inside itself
01:32:24 <phz_> yeah
01:32:27 <mniip> phz_, that's the same thing
01:32:45 <phz_> mniip: well to me those are two different things
01:32:48 <[exa]> phz_: the other name for fix.
01:32:57 <dysfun> reuben364: a user is able to write a query using a datalog dialect that queries it
01:33:52 <dysfun> i'll worry about the query engine later, that's obviously going to be difficult
01:33:52 <mjora7> The Haskell text that I'm using uses (x:xs) for array parameter pattern matching. What does the 'x' and 'xs' stand for, something mathematical? I'd call them 'head' and 'tail', or something like that.
01:34:14 <dysfun> if x = 'ex', than 'xs' = 'exes'
01:34:26 <mjora7> dysfun: Hahh, ok, that makes sense.
01:34:41 <mniip> (x:xs), you have one x, and multiple x'es
01:35:30 <mjora7> Is this a common name scheme that people use, or just my textbook?
01:35:38 <dysfun> it's pretty widely used
01:35:39 <mniip> yes
01:36:18 <dysfun> in prolog and erlang they use h and t a lot
01:36:24 <mjora7> dysfun: Thanks.
01:36:52 <dysfun> remember that 'head' and 'tail' exist in prelude
01:36:52 <kamyar> hello all
01:37:01 <kamyar> Any Haskell pro here?
01:37:13 <dysfun> yes
01:37:22 <kamyar> Is this article applicable? http://nikita-volkov.github.io/record/
01:37:31 <mjora7> dysfun: Yep.
01:38:51 <dysfun> there are several first class records libraries. what do you mean applicable?
01:39:20 <mivael> hello all!
01:40:06 <kamyar> dysfun: I mean if it is mature and valid, why it is not viral and popular?
01:40:06 <mivael> I wonder whether using a Builder is necessary to convert an integer value to ByteString?  Or maybe I'm missing something?
01:40:57 <cocreature> kamyar: because a lot of people don’t like TH
01:41:09 <dysfun> i'm immediately put off by the fact it uses two quasiquoters
01:42:27 <kamyar> cocreature: Many projects like Persistent and other ORM-like libraries use TH but do not use any first class record
01:44:00 <dysfun> but there are first class record libraries that don't use TH
01:47:41 <ertes> mivael: Builder is never *necessary*, but if you need to build a ByteString from a concatenation of multiple chunks, Builder is going to be significantly more efficient than appending ByteString
01:50:18 <ertes> mivael: instead of storing the actual string, it stores instructions on how to build the string…  when building a lazy ByteString from a Builder chunks of fixed lengths are allocated and filled from the Builder
01:50:52 <mivael> thanks, now it makes sense for me
01:54:42 <mjora7> Trying to implement filter two different ways, why does the second one fail? As far as I know, I'm doing the exact some thing, one with parameter pattern matching, and one with guards: https://repl.it/H1XK/0
01:55:44 <mjora7> Ahhh... I think I see what is wrong. The list@(x:xs) isn't a catch all pattern.
01:56:01 <mjora7> That makes sense. Is there a way to make it one but still capture (x:xs)?
01:56:10 <mjora7> I guess I could use head and tail on it.
01:57:20 <mivael> Is there any way to abstract from specific integer type when using ByteString.Builder?  I mean something like 'decimal' (Data.Text.Lazy.Builder.Int) instead of int32Dec, int64Dec, ...?
01:57:38 <mjora7> Revised edition, I think that's the proper way: https://repl.it/H1XK/1
01:58:23 <mjora7> Pattern matching is much nicer :)
01:58:26 <mniip> mjora7, filter2 is bad style
01:58:34 <mniip> make sure to avoid that kind of cod
01:58:35 <mniip> e
01:59:11 <mjora7> mniip: Ok, I agree, but can you explain why it is bad style? From what I see, it's just not as readable.
01:59:24 <mniip> head and tail are partial
01:59:33 <mniip> in fact here you are relying in lazy evaluation
01:59:49 <mniip> with partial functions is much harder to reason about totality of your function
02:00:02 <mjora7> mniip: Partial?
02:00:11 <mniip> it doesn't return a value on all inputs
02:00:25 <mjora7> mniip: Ah, like an empty list.
02:00:36 <mniip> yes
02:01:51 <mjora7> mniip: Any other tips for good style, at my skill level (you can probably tell what it is from that code/my questions)?
02:02:18 <mniip> fn -> f
02:02:41 <mniip> if you have 2 or more functions you can go f, g, h
02:02:48 <mjora7> mniip: Ok
02:03:13 <mniip> | cond = x; | otherwise = y
02:03:20 <mniip> is better expressed as 'if cond then x else y'
02:03:23 <mjora7> mniip: I'm definitely having a hard time with the sparse naming. Is that a Haskell thing?
02:03:33 <mniip> if there's only 2 branches, why use guards
02:03:37 <mjora7> mniip: Ah ok yeah I thought about writing it that way
02:03:39 <mniip> questionable advice though
02:03:44 <mniip> some would disagree
02:04:11 <mniip> mjora7, can't say much more than that because your definition is identical to the prelude definition
02:04:13 <mniip> @src filter
02:04:13 <lambdabot> filter _ []     = []
02:04:14 <lambdabot> filter p (x:xs)
02:04:14 <lambdabot>     | p x       = x : filter p xs
02:04:14 <lambdabot>     | otherwise = filter p xs
02:04:51 <mjora7> if `cond then x else y` reminds me of the ternary operator `cond ? true-branch : false-branch` from C, which I like.
02:05:01 <mjora7> mniip: That's neat!
02:05:12 <gehmehgeh> mjora7: It is the ternary operator
02:05:19 <mjora7> gehmehgeh: Awesome.
02:05:28 <gehmehgeh> mjora7: (As far as I know)
02:06:05 <mjora7> gehmehgeh: Looks a little nicer though.
02:08:12 <mjora7> mniip: Is this the proper way to format that? I think it's a bit hard on the eyes as a one liner. https://repl.it/H1XK/3
02:08:35 <mniip> there's no proper way
02:08:59 <mniip> also I'm not the best person to ask because I have a fairly peculiar formatting preference
02:09:10 <mniip> (I use tabs too)
02:09:15 <reuben364> dysfun: perhaps some inspiration with using type families https://pastebin.com/D0c9G3uU
02:09:23 <mjora7> mniip: That's scary.
02:09:26 <dysfun> reuben364: thanks :)
02:11:37 <mniip> edwardk, you around?
02:11:55 <reuben364> dysfun: It may be terrible. I don't know a lot about haskell's extensions, but I am a bit familiar with dependently typed programming.
02:12:10 <dysfun> i've done a little bit with agda
02:20:35 <reuben364> Say I have a function example :: (Integral v, FiniteBits v) => Whatever -> [v], is it possible to use finiteBitSize for the v type. I have tried with ScopedTypeVariables and it doesn't work.
02:21:00 <mniip> it's possible without scopedtyvars
02:21:02 <mniip> but it's tricky
02:22:32 <mniip> @let example = let result = replicate (finiteBitSize (head result)) 0 in result
02:22:34 <lambdabot>  Defined.
02:22:36 <mniip> :t example
02:22:38 <lambdabot> (Num b, FiniteBits b) => [b]
02:22:45 <mniip> > example :: [Int]
02:22:48 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
02:22:50 <mniip> > example :: [Word8]
02:22:53 <lambdabot>  [0,0,0,0,0,0,0,0]
02:23:15 <reuben364> XD
02:23:16 <mniip> do note that 'head' is here just for the type inference, it is never invoked
02:23:45 <mniip> with scopedtyvars
02:24:18 <mniip> @let example' :: forall v. (Num v, FiniteBits v) => [v]; example' = replicate (finiteBitSize (undefined :: v)) 0
02:24:20 <lambdabot>  Defined.
02:24:27 <mniip> :t example'
02:24:28 <lambdabot> (FiniteBits v, Num v) => [v]
02:24:36 <mniip> > example' [Word8]
02:24:39 <lambdabot>  error:
02:24:39 <lambdabot>      • Couldn't match expected type ‘[t0] -> t’ with actual type ‘[v0]’
02:24:39 <lambdabot>      • The function ‘example'’ is applied to one argument,
02:24:39 <mniip> > example' :: [Word8]
02:24:42 <lambdabot>  [0,0,0,0,0,0,0,0]
02:25:07 <mniip> you need explicit foralls for the vars you want to be scoped
02:25:25 <reuben364> Well there's my problem.
02:25:29 <reuben364> Thanks.
02:26:54 <filostrato> I'm trying to set up for Yesod development atm, but running into something I'm not sure is specific to Yesod: `Failed to load interface for ‘Yesod’`
02:27:00 <filostrato> thought I had set things up correctly
03:02:35 <mivael> Could anyone help with attoparsec?
03:02:52 <mniip> with what specifically
03:02:59 <mivael> GHC says that (parseOnly myparser) has type (Data.ByteString.Internal.ByteString -> Either P.String [a0]) although it should be (Data.ByteString -> Either String a) according to the docs (http://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:parseOnly).
03:03:54 <mniip> what's the type of 'myparser'?
03:05:33 <mivael> I did not try to specify its type explicitly.
03:05:34 <mivael> (A8.decimal `A8.sepBy1` (A8.char ' ')) <* A8.endOfInput   -- Data.Attoparsec.ByteString.Char8 as A8
03:05:53 <mniip> what type does ghc infer for it
03:06:20 <mivael> I will check.
03:12:32 <mivael> mniip, I thought I can do it :)    I have very little experience wiith ghci, do not know how to check that.
03:13:04 <mniip>  :t myparser
03:14:12 <mivael> *Main> myparser = (A8.decimal `A8.sepBy1` (A8.char ' ')) <* A8.endOfInput
03:14:19 <mivael> <interactive>:3:10: parse error on input ‘=’
03:14:23 <mniip> add a 'let'
03:14:29 <mivael> oh
03:14:56 <mivael> myparser
03:14:57 <mivael>   :: P.Integral a =>
03:14:57 <mivael>      Data.Attoparsec.Internal.Types.Parser
03:14:57 <mivael>        Data.ByteString.Internal.ByteString [a]
03:15:07 <mniip> well
03:15:16 <mniip> sounds about right then
03:15:24 <mniip> that it returns Either String [a]
03:15:47 <mivael> That's okay.
03:16:08 <mniip> I don't see what your problem is then
03:16:10 <Kototama> how can Traversable be implemented (without deriving) for a type data Exp a = Num Int | Mul (List a) ?
03:16:22 <mivael> mniip, The problem that it can not match Data.ByteString.Internal.ByteString with Data.ByteString
03:16:23 <mniip> List a?
03:16:34 <mniip> mivael, Data.Bytestring is not a type
03:16:36 <Kototama> [a] ?
03:16:57 <mivael> mniip, sorry I was not specific
03:17:14 <Kototama> how to get a value of type `a` when traversing the (Num Int) node?
03:17:34 <mniip> traverse f (Num x) = pure (Num x)
03:17:46 <mniip> traverse f (Mul xs) = Mul <$> traverse f xs
03:18:21 <mivael> mniip, Couldn't match type ‘B8.ByteString’ with ‘Data.ByteString.Internal.ByteString’  -- Data.ByteString.Lazy.Char8 as B8
03:18:38 <mniip> mivael, well, you are mixing strict and lazy bytestrings
03:18:46 <mniip> is there any reason you need lazy bytestrings
03:19:07 <mivael> a large number of integers are in my input
03:19:17 <Kototama> shouldn't traverse return a type m (t b) whereas in pure (Num x) is of type m (t a) ?
03:20:02 <mivael> mniip, I want to avoid reading the whole stdin into memory
03:20:22 <mniip> mivael, well, in order to 'parseOnly' you will have to do that
03:20:41 <mniip> Kototama, yes and yes
03:20:57 <hexagoxel> Kototama: the (Num x) have different types on both sides of the equation
03:20:58 <mniip> however notation prevents you from seeing that it isn't a problem
03:21:08 <mniip> Num x has that type 'forall a'
03:21:23 <mniip> traverse should return that type with a specific b
03:21:25 <mivael> I'm not sure I need parseOnly.  What other options I have?  (Ones which are compatible with lazy bytestrings.)
03:21:29 <mniip> (b is a skolem type variable)
03:21:33 <mniip> aka rigid
03:22:08 <mniip> mivael, googling attoparsec lazy bytestring seems to yield some results
03:22:43 <Kototama> oh i see, thank you
03:28:24 <mivael> mniip, Data.Attoparsec.ByteString.Lazy, I see.  Does this mean that I should use Data.Attoparsec.ByteString.Parser, not Data.Attoparsec.ByteString.Char8.Parser?
03:29:04 <mniip> uhhh
03:29:08 <mniip> that I'm not sure
03:29:13 <mniip> Char8 is a bad idea in general
03:29:40 <mivael> Someone advised me to them earlier.  Why are they bad in general?
03:30:02 <EvanR> instead of Char8 you can use local definitions of commonly used "chars", like let lf = w8 10
03:30:14 <EvanR> > ord '\n'
03:30:16 <lambdabot>  10
03:33:43 <mivael> EvanR, well, I'm not sure I understood.  I will try to avoid *.Char8, though.  What specific purpose do *.Char8 have?
03:34:00 <EvanR> its supposed to be convenient when you only have ASCII data
03:34:05 <mniip> it's for lazy people who don't care about encoding
03:34:33 <EvanR> many binary protocols have ASCII text embedded within then in places
03:35:05 <EvanR> if its all ASCII... then were not talking about binary anymore, nor is it unicode, so we have a missing feature in haskell
03:35:15 <EvanR> the 7bit ascii char data type
03:35:47 <EvanR> situation shouldnt be ignore imo
03:35:49 <EvanR> ignored
03:39:08 <dysfun> reuben364: think this code example is starting to make sense. feels like magic
03:39:35 <quchen> type SevenBit = Either Bool (Either (Bool,Bool) (Either (Bool, Bool, Bool) (Either …)
03:40:16 <mniip> quchen, that has one too few inhabitants
03:40:25 <EvanR> Vect 7 Bit
03:40:45 <mniip> try...
03:41:00 <mivael> EvanR, mniip: that's competitive programming contests, ascii only
03:41:10 <mniip> :t let f :: x -> Either x x in f (f (f (f (f (f (f x))))))
03:41:11 <lambdabot> error:
03:41:12 <lambdabot>     The type signature for ‘f’ lacks an accompanying binding
03:41:16 <mniip> :t let f :: x -> Either x x; f=f in f (f (f (f (f (f (f x))))))
03:41:17 <lambdabot> Either (Either (Either (Either (Either (Either (Either Expr Expr) (Either Expr Expr)) (Either (Either Expr Expr) (Either Expr Expr))) (Either (Either (Either Expr Expr) (Either Expr Expr)) (Either (
03:41:18 <lambdabot> Either Expr Expr) (Either Expr Expr)))) (Either (Either (Either (Either Expr Expr) (Either Expr Expr)) (Either (Either Expr Expr) (Either Expr Expr))) (Either (Either (Either Expr Expr) (Either Expr
03:41:18 <lambdabot> Expr)) (Either (Either Expr Expr) (Either Expr Expr))))) (Either (Either (Either (Either (Either Expr Expr) (Either Expr Expr)) (Either (Either Expr Expr) (Either Expr Expr))) (Either (Either (
03:41:18 <lambdabot> Either Expr Expr) (Either Expr Expr)) (Either (Either Expr Expr) (Either Expr Expr)))) (Either (Either (Either (Either Expr Expr) (Either Expr Expr)) (Either (Either Expr Expr) (Either Expr Expr))) (
03:41:18 <lambdabot> Either (Either (Either Expr Expr) (Either Expr Expr)) (Either (Either Expr Expr) (Either Expr Expr)))))) (Either (Either (Either (Either (Either (Either Expr Expr) (Either Expr Expr)) (Either (
03:41:19 <lambdabot> [5 @more lines]
03:41:46 <mniip> oops s/Expr/()/
03:42:16 <mivael> EvanR, mniip: Data.Attoparsec.ByteString does not seem to contain 'decimal'...  (it is in Char8 subspace for some reason)
03:42:57 <Myrl-saki>  mniip Reeee. What.
03:43:32 <biglambda> How would I use attoParsec to read a 32 bit float from a byteString?
03:44:22 <EvanR> mivael: since decimal gives you a regular Internal.Parser ByteString, should work fine with other stuff
03:44:45 <Myrl-saki> ertes: Yep.
03:44:52 <EvanR> biglambda: read 4 bytes, then decode float
03:45:07 <EvanR> :t decodeFloat
03:45:09 <lambdabot> RealFloat a => a -> (Integer, Int)
03:45:13 <EvanR> hmm
03:45:33 <Myrl-saki> :t encodeFloat
03:45:35 <lambdabot> RealFloat a => Integer -> Int -> a
03:45:49 <Myrl-saki> What does that mean?
03:46:01 <mniip> exponent, mantissa
03:46:22 <EvanR> yeah, im missing the one that encodes decodes literal ieee754 binary
03:46:51 <EvanR> > decodeFloat 3.14
03:46:53 <lambdabot>  (7070651414971679,-51)
03:47:05 <EvanR> > encodeFloat 7070651414971679 (-51)
03:47:07 <lambdabot>  3.14
03:47:21 <Myrl-saki> > encodeFloat 1 1
03:47:23 <lambdabot>  2.0
03:47:30 <Myrl-saki> Interesting...?
03:47:46 <biglambda> EvanR what module is decodeFloat in?
03:47:50 <opqdonut> EvanR: Data.Binary sounds right for that
03:47:51 <Myrl-saki> Prelude
03:48:09 <EvanR> > sqrt 2 / 2
03:48:11 <lambdabot>  0.7071067811865476
03:48:29 <biglambda> opqdonut: I’m basically looking for a combination of Parsec and Data.Binary
03:49:17 <Myrl-saki> biglambda: Well, yeah. attoparsec is what you need.
03:49:54 <Myrl-saki> Also.
03:50:30 <Myrl-saki> You should be able to use {encode,decode}Float here, but it will be a mess.
03:51:05 <mniip> (unsafeCoerce :: Double -> Int64)
03:51:12 <EvanR> one thing about 32bit encoded floats is theres endianness issues, which you have to decide on when programming it yourself
03:51:33 <EvanR> but i would expect this to be solved, which i suspect has been done in Data.Binary
03:51:46 <mniip> but yeah, otherwise you have to take the 8 bytes,
03:51:57 <mniip> split the sign, exponent, mantissa with bit shifts
03:51:59 <mniip> and then encodefloat
03:52:16 <Myrl-saki> Mhm.
03:52:19 <biglambda> Wow, that’s a mess
03:52:50 <Myrl-saki> In C, that would be..
03:52:52 <EvanR> from what i understand, protocols tend to avoid this by encoding the float in "textual" form, possible in hex notation
03:52:59 <Myrl-saki> (1 << msize) | m
03:53:04 <Myrl-saki> For the mantissa.
03:53:07 <EvanR> then it doesnt matter what either side needs
03:53:18 <Myrl-saki> And the sign wolud require you to use if/else.
03:53:40 <Myrl-saki> :t bool
03:53:42 <lambdabot> a -> a -> Bool -> a
03:53:56 <Myrl-saki> bool 1 2 True
03:54:00 <Myrl-saki> > bool 1 2 True
03:54:02 <lambdabot>  2
03:54:30 <EvanR> > floatToDigits 16 3.14
03:54:33 <lambdabot>  ([3,2,3,13,7,0,10,3,13,7,0,10,3,14],1)
03:55:45 <EvanR> not space efficient but avoids endianness encoding issues
03:55:47 <mniip> biglambda, well, imagine running your haskell code on a machine that doesn't use IEE754 floats
03:56:00 <mniip> you would have to implement IEEE754 in one way or another
03:56:20 <Myrl-saki> biglambda: encodeFloat (bool id negate sign $ 1 `shiftL` msize .|. m) exp
03:56:51 <mniip> that's wrong
03:56:54 <EvanR> Myrl-saki: this is assuming little endian? or
03:57:05 <Myrl-saki> EvanR: No assumption on the encoding.
03:57:08 <Myrl-saki> Rather.
03:57:11 <EvanR> uh
03:57:17 <Myrl-saki> It's encoding agnostic.
03:57:25 <Myrl-saki> mniip: Care to say why it's wrong?
03:57:26 <EvanR> with a Word32 or Word64, i think it does
03:57:51 <EvanR> well at the time you convert from [Word8] to one of those
03:57:51 <Myrl-saki> EvanR: That's assuming processing already.
03:57:53 <mniip> > decodeFloat (-3)
03:57:55 <lambdabot>  (-6755399441055744,-51)
03:57:59 <mniip> ok, maybe not
03:58:59 <EvanR> http://hackage.haskell.org/package/data-binary-ieee754-0.4.4/docs/Data-Binary-IEEE754.html
04:01:17 <EvanR> read 4 bytes with attoparsec, then parse that with binary (and this add on lib), which technically cant fail
04:01:27 <EvanR> any pattern of 4 bytes is "valid"
04:01:31 <biglambda> I see
04:01:40 <biglambda> That’s a good find thank you
04:02:28 <mniip> > decodeFloat (1e-315)
04:02:30 <lambdabot>  (6791492634935296,-1099)
04:03:00 <EvanR> or if you have the Word32 patched together already, theres quicker methods for that. 
04:03:21 <EvanR> which is a pain in the ass in itself
04:11:10 <mniip> where's all the type theory folk :o
04:11:26 <EvanR> probably ##typetheory
04:11:34 <mniip> I have a concept of an idea of a typesystem extension
04:11:50 <EvanR> oh, you mean applied type theory ;)
04:12:01 <mniip> well, GHC type theory
04:12:07 <opqdonut> #ghc?
04:12:44 <mniip> idunno
04:15:20 <pacak> mniip: Try  haskell-cafe mailing list?
04:15:34 <mniip> yeah I was just thinking about that
04:16:08 <mniip> but it's at a such a concept stage that it is entirely possible that I'm missing some obvious detail
04:25:00 <Chong> how can I set up my directory structure for a project?
04:25:13 <Chong> I have two files in src/Tables
04:25:20 <Chong> one of them imports the other
04:25:24 <Chong> but it can't find it
04:25:50 <merijn> Chong: How are you compiling?
04:26:59 <Chong> I'm not compiling anything
04:27:05 <Chong> only using runhaskell
04:27:17 <bartavelle> what does "to a T" mean in "That's been my experience with Haskell to a T" ?
04:27:37 <Chong> means it's an accurate descroption
04:27:39 <bartavelle> (more an English than a Haskell question, but well)
04:27:44 <bartavelle> thanks
04:28:17 <bartavelle> oh I thought that was a pun I didn't get, I should have just googled "to a T" :/
04:28:56 <merijn> Chong: Ah, in that case step one should be to stop using runhaskell and start compiling using either cabal or stack :)
04:29:05 <Chong> so I have two files in src/Tables
04:29:16 <merijn> (Everyone seems to recommend stack for beginners, but I'm not familiar with it)
04:29:20 <Chong> Bid.hs and Go.hs
04:29:33 <Chong> Ithe modules are called Tables.Bid and Tables.Go
04:29:53 <Chong> I try to import Tables.Bid from tables.Go and ti doesn't work
04:30:02 <EvanR> ive seen beginners recommend stack to each other, and beginners struggle with stack
04:30:11 <EvanR> im like, try cabal by itself
04:30:15 <Chong> but if I rename the module to just Go then I can't import it from any files in src/
04:37:24 <merijn> Chong: As soon as you have multi-module programs you'll want to use cabal or stack to compile them for you
04:38:58 <cocreature> both use cabal project files so the question of how to organize your project is largely independent of whether you use cabal or stack
04:39:40 <merijn> cocreature: Yes, but I'll get badgered by the "Stack Evangelism Strike-Force" if I tell people to use cabal :p
04:39:43 <laserpants> Is it possible to use MathJax or some sort of LaTeX in Haddock now, or how is it? When generating HTML I mean.
04:39:56 <merijn> Not AFAIK?
04:40:10 <cocreature> merijn: I wasn’t trying to correct you. I was just expanding on your answer :)
04:40:17 <cocreature> it definitely is
04:41:06 <cocreature> laserpants: the docs are here https://github.com/haskell/haddock/pull/525/files
04:41:52 <laserpants> cocreature: Thanks. I remember reading about it somewhere.
04:41:59 <mniip> what was the word
04:42:10 <cocreature> mniip: huh?
04:42:28 <mniip> the kind of equality that means that two functions are equal if their outputs are equal on all inputs
04:42:35 <cocreature> extensional equality
04:42:41 <mniip> uhh no
04:42:45 <cocreature> or functional extensionality
04:42:51 <EvanR> funext
04:43:16 <mniip> hm, maybe extensional is an even better word than what I had in mind
04:43:28 <cocreature> I didn’t make this up, it’s a standard term :)
05:07:01 <Kototama> what is the equivalent of cataM (purescript) in Haskell?
05:07:18 <EvanR> foldM ?
05:07:21 <EvanR> :t foldM
05:07:22 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
05:08:26 <Kototama> is foldM top down or bottom up?
05:09:04 <cocreature> that depends on your Foldable instance
05:09:31 <Kototama> so you cannot have both
05:10:02 <cocreature> at least not without newtypes
05:14:04 <Kototama> But how do you make it top or bottom if the type is something like that: data Exp a = Num Int | Mul [a] ?
05:15:40 <cocreature> I just use manual recursion like a peasant
05:15:46 <cocreature> :)
05:17:45 <Kototama> :)
05:18:00 <Kototama> i wish i could
05:18:07 <cocreature> Kototama: there is a recursion-schemes package that might be interesting to you
05:19:01 <Kototama> yeah i'm more or less using the equivalent in purescript but asking here because they sleep in the purescript channel :)
05:20:22 <Kototama> not just sure how i could say "eh take the parent first" in foldMap f (Mul children) = foldMap f children since the parent has no value to put in the fold
05:26:04 <mniip> pacak, tadaa https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126893.html
05:35:13 <pacak> mniip: Hmm... I think there was a reason behind not allowing partial application in type families, but we'll see
05:35:32 <mniip> I mentioned that in my post
05:41:16 <ij> Are functions bifunctors?
05:41:27 <EvanR> profunctors
05:42:01 <EvanR> the left hand side is contravariant
05:42:14 <mniip> oh
05:42:20 * mniip read "functors"
05:43:18 <ij> Ok, now I see that it couldn't be made to work with bifunctor.
05:43:21 <mniip> ij, if they were bifunctors, then you would have a mapping (a -> b) -> ((a -> c) -> (b -> c))
05:45:17 <laserpants> When using stack repl (or cabal repl), is there a way to reload the cabal file without exiting? 
05:46:16 <laserpants> For example, if I change "exposed-modules" in the library settings.
05:46:17 <bennofs> laserpants: pretty sure there is not
05:46:43 <laserpants> ok.
05:49:50 <qwr> Hi. Given a lexer/parser written in alex/happy, I'd like a Show instance for the ast such that calling "show" results in (more or less) the parser input. Are there any tools/packages/... that can help me with that?
05:50:40 <merijn> qwr: Well, that's not a job for Show
05:50:46 <merijn> qwr: Show should print valid Haskell
05:51:01 <merijn> qwr: You want one of the 20 or so pretty-printing libraries on Hackage
05:51:17 <merijn> quchen: If you stopped slacking I could recommend yours! :p
05:55:23 <davean> qwr: Show is usually the actual Haskell data.
05:55:39 <davean> qwr: its at least supprising, if not bad form, to use show inconsistent with that
05:56:21 <MonadHendrix> is it bad for to use Show as a quick n dirty pretty printer
05:56:23 <EvanR> if theres a function in my record, i would rather see everything else than an error
05:57:18 <davean> EvanR: thats phylisophically in line with Show though
05:57:19 <quchen> merijn: Yes yes
05:57:21 <qwr> Okay, then I'll stop doing that. :) But still: "How do I pretty-print what I have parsed with alex/happy?"
05:57:28 <EvanR> huh
05:57:43 <davean> EvanR: at least in my mind
05:57:49 <mniip> quchen, merijn, any comments :o https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126893.html
05:57:53 <quchen> merijn: I’m still working on it occasionally. I just pushed another important change (namely exposing the Doc type in an Internal module so people can write adaptors)
05:58:16 <merijn> \o/
05:59:13 <merijn> mniip: Partial type family application is equivalent to type level lambda's, which would make type checking undecidable
05:59:20 <merijn> mniip: Which is why it's not possible atm
05:59:29 <mniip> did you even read :v
06:00:17 <merijn> mniip: I was just reading after skimming :p
06:00:29 <merijn> mniip: I don't feel qualified to comment on the impact of type safety of that :)
06:06:23 <matrium> hi, I have a constrained type parameter in some of my functions (e.g. usingEntities :: Rdf a => RDF a -> Node -> [Node]). I now want to refactor the "Rdf a => RDF a" parameter into a reader monad. Can I somehow create a type like  "type RDFReader a = Rdf r => Reader (RDF r) a"?
06:06:25 <quchen> merijn: Is it, though? Why? Don’t we have kinds, giving us a simply-typed lambda calculus, which is strongly normalizing?
06:08:14 <ski> matrium : i think you'd want a `forall r.' in there
06:08:39 <merijn> quchen: eh...I thought about this long and hard 1 or 2 years ago and only remember my conclusion >.>
06:10:21 <ski> matrium : alternatively, you could encode an existential ..
06:16:42 <matrium> ski: thanks! "type RDFReader a = forall r . Rdf r => Reader (RDF r) a " works for me
06:17:31 <lpaste> Hamlet pasted “Find largest prime factor of 600851475143” at http://lpaste.net/354943
06:18:31 <ski> matrium : you might need to enable higher-rank types .. if you use that type synonym in an argument position. but possibly you won't need that
06:18:40 <Hamlet> Hello #haskell, can anyone help me with the following code? Thanks.
06:19:03 <Hamlet> http://lpaste.net/354943
06:20:47 <mniip> where do I start
06:21:12 <quchen> merijn: We don’t have a Void-kind, do we?
06:21:31 <quchen> Meh, not sure if that is related. Nevermind.
06:22:57 <mniip> :k Foo -- quchen
06:22:58 <lambdabot> Void -> *
06:23:05 <mniip> it behaves nothing like Void though
06:23:17 <ski> Hamlet : variable names can't start with an upper case letter. change `N' to `n' ?
06:24:08 <quchen> mniip: That’s nod of kind Void, it’s of kind ->.
06:24:15 <quchen> nod...yeah right
06:24:28 <Hamlet> If you can list the mistakes I can change one by one directly. Thanks
06:24:40 <ski> Hamlet : `(isPrime n == True)' can be simplified to just `isPrime n'. `isPrime n' will already compute to a boolean (a truth-value, `True' or `False'). no need to compare it with `True', only to get back the same truth-value again
06:24:49 <ski> Hamlet : that's what i'm doing :)
06:24:51 <mniip> quchen, the argument of Foo has kind Void
06:26:05 <ski> Hamlet : in the definition of `isPrime', no need to use a boolean expression guard (and `otherwise' in the other case), only to return either `True' or `False'. simply directly return the boolean expression (after the `='), not using any guards (the `| ...' stuff)
06:27:03 <ski> Hamlet : `isFactor x = (n `mod` x == 0)' could be just `isFactor x = n `mod` x == 0', no need for that extra pair of brackets
06:28:06 <ski> Hamlet : in `main', either put the `let n = ...' after the `do' .. or else define it after a `where' at the end. also you need to indent `then' and `else' more, and line up `print' with `if'
06:28:10 <c_wraith> ski: I once saw a person put (== True) in a chain of composed functions, and couldn't convince them it was the same as id.
06:28:22 * ski smiles
06:28:29 <quchen> mniip: Oh, right. But is it really uninhabited? I mean you can easily create a new kind called »Void«
06:28:50 <mniip> it is inhabited by forall a.a
06:28:52 <EvanR> they probably were denying principle of function extensionality
06:29:44 <ski> Hamlet : however, in Haskell, you can't put variable bindings in the `then'&`else' branches of an `if', and expect them to be in scope "after" it. instead, you can use `let largestPrimeFactor = if ... then ... else ...' (broken down over multiple lines, indented properly, if you prefer)
06:30:49 <ski> well, `seq id ()' is equal to `seq (== True) ()', so the function extensionality problem shouldn't apply ..
06:32:40 <ski> Hamlet : in the definition of `findLargestPrimeFactor', `if (True) then ..something.. else ..alternative..' is equivalent to just `..something..', skipping the `if' and the `else'-branch. but i suspect this isn't what you wanted
06:34:02 <ski> Hamlet : just before the `if', you have a command in the `do'-block that's `isPrime n'. presumably you wanted to either put this condition in the `if' ? or else, possibly name the result of that expression, and then put that variable name in the `if' ?
06:35:42 <Hamlet> do-block for which function?
06:35:58 <ski> <ski> Hamlet : in the definition of `findLargestPrimeFactor', ...
06:36:19 <ski> Hamlet : here again, you have the `then' branch consisting of a `let' (without an `in'), but this time no such thing in the `else' branch. instead you have a further `let' command after the whole `if'-`then'-`else'. it's not clear what you intended here, elaborate ?
06:37:04 <ski> Hamlet : one further problem i can see is that your definition of `findLargestPrimeFactor' accepts a list of numbers, but in `main', you're calling `findLargestPrimeFactor' with a single number, not a list
06:38:11 <Hamlet> - Let me read up more on syntax, clear up the mistakes you've pointed to.. then I'll return to this channel again.- Thanks for the help so far. Regards
06:38:35 <ski> Hamlet : oh, it also looks like `main' expects that `findLargestPrimeFactor' will return a number (judging from you naming the result `largestPrimeFactor' in `main'), but in the first defining equation of `largestPrimeFactor', you're returning a list (specifically, the empty list)
06:38:57 <ski> (it's not clear what you intended to return in the second defining equation of `largestPrimeFactor' ..)
06:47:17 <dzdcnfzd> I'm trying to get through Stephen Diehl's vim 2016 advice and running into troubles with `stack install ghc-mod`. The errors are here: http://lpaste.net/354949. Any suggestions?
06:49:50 <quchen> dzdcnfzd: Is your LTS release too old?
06:49:53 <MarcelineVQ> it tells you what to do dear. but you're usually better off using it per project, so in your project you'd type stack build ghc-mod and to use it you'd go stack exec ghc-mod
06:50:03 <quchen> What does your stack.yaml say in the »resolver« field, dzdcnfzd?
06:50:14 <MarcelineVQ> also like quchen suggests you may want to bump up your lts version in the stack.yaml file it mentions
06:50:27 <dzdcnfzd> resolver: lts-3.19
06:50:33 <quchen> That’s ooold
06:50:40 <quchen> Current is 8.something
06:50:57 <quchen> Stackage did not use to include that many packages
06:51:07 <dzdcnfzd> quchen: is there an automated update process I should be doing?
06:51:16 <dzdcnfzd> I just did stack update with no effect
06:51:19 <quchen> dzdcnfzd: Just replace the string in your stack.yaml
06:51:23 <quchen> And go again
06:51:24 <Aruro> dzdcnfzd: did u recently installed ghc and stack?
06:51:45 <Aruro> dzdcnfzd: stack update does not much help, better clean reinstall
06:51:57 <dzdcnfzd> Aruro: no, not as I recall
06:51:59 <MarcelineVQ> Aruro that's unlikely to help
06:52:20 <Aruro> dzdcnfzd: what is version of ghc and stack?
06:52:33 <dzdcnfzd> MarcelineVQ: so in this case, just download the vim repo, build the executable, and add it to my path?
06:52:35 <Aruro> ghc-mod couples with specific ghc version
06:52:58 <dzdcnfzd> or is there a general way to stack install for the whole system using particular code?
06:53:18 <dzdcnfzd> (sorry -- I should know this stuff better. Dev environment has never been my strongpoint)
06:53:38 <Aruro> dzdcnfzd: yes global configuration is what stack will do if not in project dir
06:54:03 <Aruro> dzdcnfzd: if u did not waste much time yet, i suggest clean reinstall of everything with new versions
06:54:20 <Aruro> ghc+cabal+stack, and then repeat stack install ghc-mod
06:54:37 <MarcelineVQ> you can install it globally but it becomes a problem because ghc-mod expects specific library versions depending on what it was built with as Aruro mentions, which is why it's best to build it per project since each project will have its own lts version and thus its own specific library version ranges
06:55:07 <dzdcnfzd> MarcelineVQ: are the libraries dynamically or statically linked?
06:55:24 <Aruro> dzdcnfzd: last but not least are u sure u alread need ghc-mod? maybe hlint will suffice on this level?
06:55:29 <MarcelineVQ> idk about that, it's more about brittle api than linkage I think
06:55:58 <dzdcnfzd> This is sort of a big question, but why isn't it possible to stack install a bunch of things globally with different deps?
06:56:13 <MarcelineVQ> if there's a vim plugin that invokes ghc-mod for you hopefully it knows to check your stack paths first, in which case   stack build ghc-mod  from your project's directory would be enough to have ghc-mod work for your project
06:56:30 <dzdcnfzd> MarcelineVQ: oh, really!?
06:56:48 <MarcelineVQ> well I don't use vim but atom and emacs have plugins that work that way
06:57:45 <Aruro> dzdcnfzd: if u are into ide, people say intero is good, but im not sure its for vim
06:57:57 <MarcelineVQ> it's not a big question exactly, but the answer is the point of stack so my reponse would be to read the docs :>​https://docs.haskellstack.org/en/stable/GUIDE/
06:58:59 <dzdcnfzd> Aruro: I'm not looking for an IDE. I'm a regular vim-user, but working with an IDE for work for about two years has fairly well convinced me that on-the-fly type info and the like is enormously useful
06:59:11 <MarcelineVQ> neo vim has an intero plugin iirc
06:59:16 <dzdcnfzd> MarchelineVQ: thanks -- will do
06:59:25 <Aruro> yes i have seen haskellers use neovim
06:59:33 <dzdcnfzd> I'm trying to just use SDiehl's setup
06:59:39 <Aruro> and brag that there are some good plugins for it
06:59:45 <MarcelineVQ> If you can't manage to get ghc-mod working for you I'd try intero if you want mouse-over checking, and be sure to try out  ghcid  if all else fails because it's pretty good too
07:00:08 <dzdcnfzd> What is this weird world where people try to convince someone not to use VIM
07:00:12 <dzdcnfzd> am I in the future?
07:00:28 <Aruro> hm, neovim is not vim?
07:00:43 <MarcelineVQ> I've personally moved away from ghc-mod to mostly using ghcid just because it's a bit of a memory hog and a little brittle
07:01:14 <MarcelineVQ> I should learn emacs like a good little rabbit but life is only so long
07:01:28 <dzdcnfzd> Aruro: I was referring to intero :)
07:01:53 <dzdcnfzd> MarcelineVQ: will check out ghcid
07:04:18 <Aruro> dzdcnfzd: type indication on fly is good, but from my experience its not that big deal
07:04:33 <Aruro> flycheck i think is much better
07:04:38 <dzdcnfzd> Also, random question that really belongs in the vim irc, but I just got all of Stephen Diehl's vim config, and backspace stopped working in insert mode. Anyone ever seen anything like this? Know what plugin or setting might be causing it?
07:04:43 <MarcelineVQ> I found it really helpful while still learning how types fit together, now not so much
07:04:45 <dzdcnfzd> Aruro: Don't know what flycheck is
07:05:32 <dzdcnfzd> Also, what MarcelineVQ said is exactly right. I'm still building up intuition about a lot of stuff -- it's either on-the-fly type checking or really painstakingly putting together the types myself
07:06:24 <dzdcnfzd> On a monad-transformer-stack where I'm screwing something up and I don't know why, I'd rather just be able to ask a compiler
07:07:32 <glguy> i find the fly check type errors are only useful when you know how to fix things just by being told where the problem is
07:07:42 <MarcelineVQ> > Just "some type" :: _tellmeyoursecrets  -- you can annotate too to get type info
07:07:44 <lambdabot>  error:
07:07:44 <lambdabot>      • Couldn't match expected type ‘_tellmeyoursecrets1’
07:07:44 <lambdabot>                    with actual type ‘Maybe [Char]’
07:07:53 <glguy> if you want to read the whole message it's a bit cramped
07:08:23 <Hamlet> Revised code: 
07:08:33 <lpaste> Hamlet pasted “Find largest prime factor of 600851475143” at http://lpaste.net/354950
07:09:14 <glguy> but it's not a replacement for having to understand the types of things
07:10:39 <Aruro> glguy: yes that was my point, that interactive types are not that useful at the end
07:11:33 <Aruro> especially when u add new libs ghc-mod starts to brake or can not find type, and mess starts
07:11:45 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
07:11:52 <MarcelineVQ> that problem doesn't happen if you build and run it per-project
07:12:30 <MarcelineVQ> But it's often still a fair memory hog
07:13:13 <shapr> Tools are never a replacement for understanding.
07:14:34 <Aruro> flycheck helps to be certain that everything u wrote so far is not complete nonsense, and this feeling is kinda helpful
07:15:01 <Aruro> at least for me.
07:15:33 <MarcelineVQ> dzdcnfzd: iirc hlint does the job of flychecking for ghc-mod which is why stephen has you install them together
07:16:17 <ski> Hamlet : still redundant brackets, on lines `11',`21',`25',`31'. if you indent the `if' on line `31' (and following lines belonging to it) more, then you can omit the curly brackets there. also remove `largestPrimeFactor = ' from both branches. you already have a `let largestPrimeFactor = ' on line `30' that will receive the value of the whole `if'-expression
07:26:28 <Squarism> Ive got a <<loop>> error. What is a good way of approaching that? It could be one of atleast 8 threads
07:26:51 <edwardk> mniip: 5 hours later, yeah =)
07:26:53 <Squarism> ...other than sprinkle code with trace statements
07:27:03 <mniip> edwardk, https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126893.html
07:28:47 <edwardk> in ermine we have something we half-jokingly call "really liberal type synonyms" where you can use partial application of `type`s, inside other type declarations, so long as when the whole thing is finally inlined at the use site it is fully saturated.
07:28:54 <lyxia> Squarism: compile with profiling, +RTS -xs https://wiki.haskell.org/Debugging results not guaranteed.
07:29:59 <edwardk> anyways re your proposal I'm going to shrug and say I don't have any idea how sound it is. =)
07:30:13 <edwardk> i know the somewhat weaker thing we use is sound
07:30:52 <Squarism> lyxia, thanks. Will try that
07:30:52 <ski> edwardk : how does that differ from `LiberalTypeSynonyms' in GHC ?
07:31:32 <dzdcnfzd> Aruro: do you have any resources for fully removing stack?
07:31:43 <dzdcnfzd> got rid of all my .stack-work dirs
07:31:49 <dzdcnfzd> want to make sure I've got nothing else
07:34:11 <edwardk> https://www.irccloud.com/pastebin/Tlz9eEjD/ReallyLiberalTypeSynonyms
07:34:57 <plakband> Is there anyone here who has succesfully built repa with llvm on windows?
07:35:29 <ski> .. i tend to think of `LiberalTypeSynonyms' in terms of staged programming, or higher-order macros
07:37:11 <ski> e.g. at <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#liberalised-type-synonyms>, i think of `Generic' has having kind `(<*> -> <*>) -> (<*> -> <*>) -> <*>'
07:38:13 <ski> `Id' having kind `<*> -> <*>', while `[]' has kind `<* -> *>', but it can be construed has having the former kind. so `Generic Id []' has kind `<*>'
07:41:20 <ski> the idea being that `type Foo a = a -> a -> Bool' is thought of as `type Foo a = <{a} -> {a} -> Bool>', while an application `Foo (forall b. b -> b)' is thought of as `{Foo <forall b. b -> b>}'. `<...>' being quasiquotation and `{...}' unquotation
07:42:54 <mivael> Good news: attoparsec is great :) and I'm now acquainted enough with it to make it work!  http://codepad.org/SQWA7OXP
07:43:15 <mivael> Bad news: competitive programming sites seem to not like attoparsec: http://codeforces.com/contest/456/submission/26683927
07:43:46 <merijn> mivael: line 51 has redundant parens on both sides of the : :)
07:43:52 <mivael> "Data.Attoparsec.ByteString.Lazy: Can't be safely imported!  The module itself isn't safe."
07:44:01 <mniip> good on them
07:44:08 <mniip> the module  really isn't safe
07:44:23 <mivael> mniip, in what sense?
07:44:23 <ski> edwardk : ok, so the definiens (and definiendum) of a `type' declaration wouldn't necessarily have to be "concrete" (/ saturated)
07:44:29 <mniip> mivael, in safehaskell sense
07:44:35 <edwardk> ski: yeah
07:44:49 <mniip> mivael, as in, can be run in sandbox
07:44:58 <Squarism> dzdcnfzd, why escape from stack? I thought it was the best option out there
07:45:05 <mniip> lambdabot, for example, runs haskell code on a real machine
07:45:20 <mniip> only a set of 'safe' functions is available however
07:45:32 <mniip> those safe functions are managed by SafeHaskell
07:45:50 <mniip> it naturally excludes things like unsafeCoerce, unsafePerformIO
07:45:50 <merijn> edwardk: How come I've never before heard of you structs package? :O
07:46:11 <edwardk> merijn: i wrote it on a weekend, gave a 5 minute talk then put it away =P
07:46:54 <merijn> edwardk: Looks like the kinda thing I desperately want in Haskell :p
07:47:44 <merijn> Unrelatedly, I wish base had a convenient name for "flip when"
07:48:45 <mivael> mniip, what parse library should one use instead of attoparsec, then, in competitive programming context (large number of input should be parsed rather fast)?
07:49:10 <mniip> what is the input
07:50:25 <mivael> mniip, say, 100000 decimal integers from stdin (can be not just integers, ascii char strings are also possible, depending on specific problem)
07:50:53 <mniip> have you timed 'map read . lines . getContents'
07:51:56 <mivael> mniip, yes... I can provide a couple of links to my practice submissions on codeforces
07:53:56 <mivael> fast haskell version (bytestring): http://codeforces.com/contest/456/submission/26607428
07:54:20 <mniip> dfeuer, before I embarass myself on the list, what exactly is the problem with nullary/dependent families
07:54:55 <mniip> nullary families can be reduced immediately
07:55:00 <mivael> slow haskell version (interact $ unlines . map show . solveMany . map read . words): http://codeforces.com/contest/456/submission/26607734
07:55:17 <mniip> also equality usually has a kind in which it is conducted
07:55:27 <mniip> which can be used to reduce dependent families
07:55:39 <dfeuer> mniip: what about class instances?
07:55:51 <mivael> fast C++ version (same algorithm): http://codeforces.com/contest/456/submission/26591537
07:56:32 <mivael> mniip: 124 ms, 514 ms, and 62 ms correspondingly
07:56:40 <dfeuer> mniip: I'm just pointing out that using a funny arrow doesn't seem to distinguish constructors from families in all cases.
07:57:25 <mniip> dfeuer, it can be used to distinguish equatable from inequatable types
07:57:40 <mniip> since that was the problem with partially applied families
07:57:46 <mivael> mniip, the "fast haskell version" (124 ms) is okay regarding speed, but I did not like the souce code -- so I was advised to try attoparsec.
07:58:08 <mivael> s/souce/source/
07:58:17 <mniip> mivael, well, you can't go much faster without bytestring
07:58:37 <dfeuer> mniip: I don't know enough about it, perhaps. That was just my concern when I was thinking about the idea; it doesn't mean there's a real problem necessarily.
07:58:43 <mniip> if your algorithm is N log N or better haskell is going to drag you down a lot if you stick to Safe
07:58:58 <mniip> dfeuer, thanks for the input though
07:59:15 <mivael> mniip, I know.  But I wanted the code be more fancy and easier to memorize/retype/etc
07:59:17 <mniip> dfeuer, I was told goldfire is going to do typesystem stuff this summer
07:59:47 <ski> mniip : .. i wonder how far the "staged programming" idea could be taken here
07:59:58 <mniip> ski, ?
08:00:22 <iqubic> Hello guys.
08:00:25 <ski> basically the idea that `type' synonyms should be treated as macros, or staged programming
08:00:46 <mniip> ah
08:00:47 <ski> and that `LiberalisedTypeSynonyms' then could be seen as allowing (at least some forms of) higher-order "macros"
08:01:02 <ski> <ski> e.g. at <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#liberalised-type-synonyms>, i think of `Generic' has having kind `(<*> -> <*>) -> (<*> -> <*>) -> <*>'
08:01:29 <iqubic> What is a macro? What does it mean in haskell
08:01:57 <ski> (it would help here if you were a bit familiar with MetaML/MetaOCaml .. or at least staged programming (or macros) in the Lisps)
08:02:22 <mniip> iqubic, nothing and nothing
08:02:26 <mivael> mniip, is Parsec safe by the way?  And could it be used with ByteString to achieve better I/O/parsing speed?
08:02:32 <mniip> we are hypothesizing type system changes
08:02:35 <ski> "macro" here is used as a syntactic short-hand for staged programming
08:02:36 <dzdcnfzd> Squarism: not escaping -- just installing clean
08:02:40 <mniip> mivael, I'd have to check
08:03:19 <ski> the idea being that type synonym application is not the same thing as type constructor application
08:03:35 <mivael> mniip, I'll check it some time later
08:04:06 <iqubic> ski: What is staged programing?
08:04:26 <ski> iqubic : programs that write programs. also sometimes programs that analyze programs
08:05:05 <iqubic> That sounds hard.
08:05:06 <ski> specifically i'm thinking of some kind of quasiquotation and unquotation mechanism
08:05:14 <iqubic> Wow.
08:05:47 <ski> anyway .. i'm not really suggesting a full-blown such system here. only that it may be that type synonyms may be gainfully understood in this sense
08:06:32 <ski> one could embed and construct snippets of language B in language A using such quasiquotation. that's heterogenous staged programming
08:07:07 <mivael> merijn, I know :)   I thought it is more readable with parentheses
08:07:18 <ski> one could also embed snippets of the same language in itself. that's homogenous staged programming. which naturally then also needs to possibly having more than two stages
08:07:36 <ski> anyway, `ReadS (Maybe Integer)' would be elaborated by a binding-time analysis into really saying `{ReadS <Maybe Integer>}'
08:07:47 <ski> `<...>' is here quotation. `{...}' is unquotation
08:08:07 <mivael> merijn, by the way, the ones to the left of ':' are needed as it seems (note the '$' inside)
08:08:33 <ski> so what this means is that the application `ReadS <Maybe Integer>' runs and simplifies at *compile*-time (or, macro-expansion-time, or type-synonym-expansion-time, if you prefer)
08:08:37 <merijn> mivael: Yeah, I realised that later, but I'd probably replace that $ with () then :)
08:09:35 <dolio> merijn: Did you want something from me yesterday?
08:10:11 <merijn> dolio: I think I recall you mentioning writing criterion benchmarks for vector-algorithms, right?
08:10:11 <ertes> we could also unify the type language with the value language =)
08:10:15 <ertes> Blah :: Type
08:10:17 <ertes> Blah = Integer
08:10:34 <ski> iqubic : a standard example is writing a version of exponentiation, with a natural number exponent (say), which simplifies away the exponentiation at compile-time. this assumes that the exponent is given statically, naturally
08:11:01 <merijn> dolio: And having problems for things like sorting, since it doesn't have per-run environments
08:11:39 <dolio> Yes.
08:12:09 <merijn> dolio: So, yesterday I finally finished up and made a PR (still lacking some tests and a tiny bugfix relating to <* not being in Prelude for old GHCs), so I wanted to ask if you could have a look whether the interface works for your usecase and if yes, help me badger people into getting it merged
08:12:14 <merijn> dolio: https://github.com/bos/criterion/pull/136
08:12:27 <dolio> Okay, cool. I'll take a look.
08:13:18 <merijn> dolio: Relevant functions/API is here: https://github.com/merijn/criterion/blob/3aa421e81620739ea6e65650a92efbbc1f2fae69/Criterion/Types.hs#L456-L561
08:13:41 <merijn> dolio: I'm going to the gym now, so if you have comments, dump them in the PR/issues I opened
08:13:57 <dolio> Okay, well, I'm at work now, so I probably won't get to it for a while.
08:14:04 <merijn> s'okay :)
08:16:49 <mniip> mivael, weird
08:17:14 <mniip> I just wrote a lines which is 10x faster than the stock one
08:17:35 <ski> iqubic : something like `pow :: Integer -> <Integer -> Integer>; pow exponent = <\base -> {let loop 0 _ = <1>; loop e0 b0 = <let b1 = {b0} * {b0} in {if r == 0 then loop e1 <b1> else <b0 * {loop e1 <b1>}>}> where (e1,r) = e0 `divMod` 2 in loop exponent <base>}>'
08:19:21 <mniip> how did that happen
08:19:52 <ski> iqubic : an application `pow 11' will evaluate to (with some cosmetic variable renaming) the code snippet `<\b0 -> let b1 = b0 * b0 in b0 * let b2 = b1 * b1 in b1 * let b3 = b2 * b2 in let b4 = b3 * b3 in b3 * 1>'
08:20:12 <mivael> mniip, what do you mean by "the stock one"?
08:20:24 <mniip> Data.List.lines
08:21:44 <mivael> You mean that the cause of slowness of the "slow" (514 ms) version is probably in 'lines' slowness?
08:23:28 <mniip> I'm investicating
08:29:45 <mivael> Can you share you fast 'lines' version so that I could try it locally as well?
08:30:47 <mniip> ok
08:30:51 <mniip> it's only 3x as fast
08:30:59 <mniip> right now getContents seems to be the bottleneck
08:31:28 <lpaste> mniip pasted “lines” at http://lpaste.net/354954
08:43:44 <Squarism> is there some way to get threadid/label printed on errors that usually have the format :<executable-name> : <error-message> ? 
08:45:36 <Squarism> <executable-name> : <error-message>
08:47:23 <bartavelle> is there a trick to get a string representation of the type of an expression?
08:47:37 <bartavelle> humm
08:47:48 <bartavelle> yes there is!
08:48:19 <geekosaur> TypeRep has a Show instance
08:48:31 <bartavelle> hah, that might be nicer
08:49:41 <mniip> mivael, ^ if you didn't see
08:49:49 <Haskell> Need help with this script...
08:50:02 <sm> Squarism: error' = (unsafePerformIO getProgName ++) ?
08:50:24 <mivael> mniip, thanks.  Experimenting with it.
08:50:46 <sm> error' = ((unsafePerformIO getProgName ++ ": ") ++)
08:51:07 <Squarism> sm, where is error defined? In Prelude?
08:52:05 <Hamlet> http://lpaste.net/354950
08:54:29 <Hamlet> Need help with this script...
08:54:41 <Hamlet> http://lpaste.net/354950
08:55:58 <Hamlet> Need help with this script. http://lpaste.net/354950
08:56:11 <pavonia> Hamlet: What is the problem with this?
08:56:30 <Hamlet> It doesn't compile
08:56:56 <geekosaur> including full error messages is helpful
08:57:00 <pavonia> Add the full error message to the paste
08:57:08 <geekosaur> since various of us run different versions of ghc and the errors do change
08:57:20 <geekosaur> oh
08:57:25 <ski> <ski> Hamlet : still redundant brackets, on lines `11',`21',`25',`31'. if you indent the `if' on line `31' (and following lines belonging to it) more, then you can omit the curly brackets there. also remove `largestPrimeFactor = ' from both branches. you already have a `let largestPrimeFactor = ' on line `30' that will receive the value of the whole `if'-expression
08:57:25 <sm> Squarism: http://hoogle.haskell.org/?hoogle=error&scope=set%3Astackage
08:57:29 <geekosaur>     then let largestPrimeFactor = n
08:57:30 <ski> Hamlet ^
08:57:32 <geekosaur> that does not work
08:58:05 <ski> Hamlet : i see you did the last of those suggestions
08:59:04 <ski> Hamlet : what's the point of `largestPrimeFactor' in the definition of `findLargestPrimeFactor' ? (hint, it has nothing, per se, to do with  largestPrimeFactor'  inside `main')
08:59:58 <Squarism> sm, not sure how i would be able to redfine "error" - if that is what you meant? 
09:00:33 <geekosaur> they defined error' not error
09:00:52 <Hamlet> This is self-commented code to make it more meaningful. Also, largestPrimeFactor' is used in main, while the first one is used in defn of findLargestPrimeFactor (i.e. general good programming practice I think)
09:01:01 <ski> <ski> <ski> Hamlet : in the definition of `findLargestPrimeFactor', ...
09:01:08 <ski> <ski> Hamlet : here again, you have the `then' branch consisting of a `let' (without an `in'), but this time no such thing in the `else' branch. instead you have a further `let' command after the whole `if'-`then'-`else'. it's not clear what you intended here, elaborate ?
09:01:15 <ski> <ski> Hamlet : one further problem i can see is that your definition of `findLargestPrimeFactor' accepts a list of numbers, but in `main', you're calling `findLargestPrimeFactor' with a single number, not a list
09:01:22 <ski> <ski> Hamlet : oh, it also looks like `main' expects that `findLargestPrimeFactor' will return a number (judging from you naming the result `largestPrimeFactor' in `main'), but in the first defining equation of `largestPrimeFactor', you're returning a list (specifically, the empty list)
09:01:27 <ski> <ski> (it's not clear what you intended to return in the second defining equation of `largestPrimeFactor' ..)
09:01:39 <ski> .. i don't think you have responded to those points, yet
09:02:19 <ski> Hamlet : "while the first one is used in defn of findLargestPrimeFactor (i.e. general good programming practice I think)" -- no, you attempt to *define* (not use) it in there. you don't use it anywhere
09:02:32 <Hamlet> can you correct all the mistakes and post as a new file..? I will then study the differences
09:02:52 <ski> i possibly could, but i won't
09:03:15 <ski> part of the point is that you should learn to understand the problems you're running into, so that you can handle, and preferable avoid, them yourself
09:04:05 <ski> in some of the cases here, it's unclear to me what you even tried to achieve. so there i can't really correct your mistake
09:04:05 <Hamlet> What do I do? In steps, thank you...
09:04:21 <mivael> mniip, I did not notice time changes on my environment (neither faster, nor slower, around 570...670 miliseconds).  Compilation/runtime options and the source code are here: http://codepad.org/l4p4gKgH http://codepad.org/HO7ACVyD
09:04:59 <mniip> mivael, tried replacing cat with a file redirect?
09:05:08 <ski> Hamlet : i'd like you to respond to the messages of mine above which i copied over from a while back ..
09:05:24 <Hamlet> which one?
09:05:32 <davean> Hamlet: clearly all of them
09:05:36 <davean> Hamlet: he took the time to repeat them
09:05:47 <ski> specifically, "it's not clear what you intended here, elaborate ?"
09:05:58 <mniip> mivael, also, well, I don't know
09:06:02 <Hamlet> line #?
09:06:06 <mniip> I would debug the IO performance separately from the computations
09:06:55 <ski> Hamlet : oh, sorry, i just realized you did fix the second problem there, the number vs. list of numbers one. but there's still one small lingering problem related to that. in `main' you pass `findLargestPrimeFactor' two arguments, but the definition of it clearly expects only one argument before returning a number
09:07:39 <ski> Hamlet : so after you fix that, there's still the `let' in the `then' branch in the definition of `findLargestPrimeFactor' to keep track of .. also the base case returning an empty list
09:07:44 <Hamlet> ...I meant to use a composition
09:07:46 <mivael> mniip, tried redirection (time ./hs.exec +RTS -K16777216 < 10pow5shuffled.in.txt)... no changes, unsurprisingly
09:08:39 <mivael> mniip, I just wanted to compare to my previous results, which I profiled earlier
09:08:47 <ski> Hamlet : oh, like `(reverse . listOfFactors) myGivenNumber' ? you'll still need an extra pair of brackets there, in order to not pass two arguments to `findLargestPrimeFactor'
09:09:11 <Hamlet> yes, I think
09:09:42 <ski> .. however, you could just as well pass `reverse (listOfFactors myGivenNumber)' as an argument
09:09:42 <mivael> mniip, they were with te same calculations...  Also, 'main' 'individual time' is 85-95 per cent from all the other.
09:09:52 <mivael> s/te/the/
09:09:55 <Hamlet> yes
09:10:17 <Hamlet> reverse (listOfFactors myGivenNumber)
09:10:25 <ski> if you prefer the composition here, perhaps for the exercise of using it, then go ahead
09:10:44 <mivael> s/from all the other/comparing to the whole run time/
09:11:35 <Hamlet> how?
09:11:45 <ski>   (reverse . listOfFactors) myGivenNumber
09:11:47 <ski> is equal to
09:11:51 <ski>   reverse (listOfFactors myGivenNumber)
09:14:26 <mivael> ...and equal to:  reverse . listOfFactors $ myGivenNumber
09:14:28 <mivael> ;)
09:14:52 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
09:15:47 <ski> mivael : yea, but i don't suggest that, since i think using `$' much is ugly ;)
09:16:19 <ski> Hamlet : to summarize, the remaining things i see are (a) `main' expects `findLargestPrimeFactor' to return a number, but the base case returns an empty list; (b) the recursive case of `findLargestPrimeFactor' is confused, specifically the `then' branch; (c) the call to `findLargestPrimeFactor' in `main' being passed two arguments (we just talked about that); ..
09:16:24 <ski> Hamlet : .. and (d) (style) redundant (round) brackets on lines `11',`21',`25',`31', and redundant curly brackets on `30'-`33', which you can avoid by indenting the `if'-expression more
09:16:56 <ski> Hamlet : you're still missing an extra (required) pair of brackets on line `33'
09:17:43 <ski> Hamlet : `findLargestPrimeFactor reverse (...)' is passing `reverse' as one argument to `findLargestPrimeFactor', and `...' as another argument. if you want to apply `reverse' to `...', then you must wrap that application in brackets, in order to pass the result thereof to `findLargestPrimeFactor' as an argument
09:17:47 <mivael> ski, I like it for some reason :)  maybe it reminds me '|' of unix command line which I use extensively, just in reverse direction
09:18:26 <ski> Hamlet : .. and with that, i must leave now. good luck. perhaps someone else can carry on here ..
09:18:42 <Hamlet> thnx
09:24:12 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
09:24:31 <Jaxan> My stack installation uses 3gb of space (in ~/.stack), is there a way to trim it down a bit?
09:26:34 <Jaxan> I guess it's safe to just delete that whole dir, isn't it?
09:29:23 <phadej> Jaxan: it is safe; but it will grow to that size quite quickly again
09:29:48 <Jaxan> It's really annoying, since I'm working in a VM with just 8GB of disk
09:30:05 <phadej> (IIRC 2GB sandboxes were quite common, so 3.3GB isn't that much)
09:32:44 <phadej> Jaxan: try ls ~/.stack/snapshots/x86_64-linux | while read s; do du -hs ~/.stack/snapshots/x86_64-linux/$s; done
09:33:13 <phadej> it'll show how space is used by packages from different snapshots (so you can try to optimise)
09:33:29 <phadej> note: it's not safe to remove single snapshot
09:34:16 <phadej> e.g. I have 1,4G .stack/snapshots/x86_64-linux/nightly-2017-04-01
09:36:37 <davean> Jaxan: frankly, any modern toolset will probably be in that size range, I know of single C++ libraries that can install to that large
09:37:15 <davean> Jaxan: I know thats not that nicest answer but ...
09:39:11 <Jaxan> Maybe 8GB for my VM was a bit optimistic ;D
09:39:18 <davean> I think it was.
09:39:24 <Jaxan> pacman is alsop using a cache of 3GB -.-
09:39:39 <na_th_an> pacman -Sc (or -Scc)
09:39:44 <na_th_an> to clean the cache
09:39:56 <davean> You probably don't require a whole bunch more space, but you're really causing yourself more issues then its probably worth to not add a few GBs
09:40:34 <davean> any improvements in size are going to come at a massive increase in CPU time or a massive restriction in what you can use
09:40:52 <davean> And these options *do* exist, but they're not easy
09:42:03 <Hamlet> Need help with this script... 
09:42:07 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
09:44:31 <mniip> Hamlet, what ski said
09:44:42 <mniip> no one is going to do your homework
09:44:57 <mniip> read the advice you've been given and try fixing the mistakes yourself
09:45:30 <Hamlet> I did the steps (except the brackets ones which I kept), and some refactoring
09:46:30 <mniip> you're applying 'take' wrong
09:46:47 <Jaxan> phadej, davean and na_th_an: thanks, I will find a way to manage ;D
09:46:54 <mniip> you're applying take to 1 then to findLargestPrimeFactor and then to (reverse ...)
09:46:58 <mniip> it should be
09:47:11 <mniip> take 1 (findLargestPrimeFactor (reverse ...))
09:47:52 <dzdcnfzd> is there a canonical function which does fmap lift? 
09:47:54 <dzdcnfzd> :t fmap lift
09:47:56 <lambdabot> (Functor f, Monad m, MonadTrans t) => f (m a) -> f (t m a)
09:49:10 <mniip> dzdcnfzd, are you sure that's what you want?
09:49:18 <mniip> you have a functor of transformers?
09:49:29 <dzdcnfzd> mniip: I'll give you the context
09:49:50 <mniip> Hamlet, next, I'm not sure what you want the findLargestPrimeFactor  function to return
09:49:58 <mniip> is it a number or Maybe number?
09:50:57 <dzdcnfzd> mniip: http://lpaste.net/198162261959770112
09:51:23 <dzdcnfzd> mniip: You can see that postBlog' is an attempt to do postBlog without do notation
09:51:37 <dzdcnfzd> I'm trying to do that as simply as possible, and I think it's likely I'm screwing up
09:51:48 <mniip> you don't want to use fmap here
09:52:12 <mniip> ahhhh
09:52:20 <mniip> it's fmap for the function type
09:52:25 <mniip> just use .
09:52:36 <mniip> lift . (flip modifyTVar ...)
09:52:48 <mivael> mniip, I tried that without calculations (except for summing up the input numbers).  Environment and options are the same.  The run time seems to be statistically smaller with your 'lines' version (390+ miliseconds) comparing to Prelude.lines (430+ miliseconds).   http://codepad.org/lerwSm8h
09:56:26 <mivael> phadej, Jaxan, maybe something like this also can be useful:  du -kxa -- ~/.stack/snapshots/x86_64-linux | sort -nr | head -100
09:57:38 <mivael> (top of candidate directories for optimization)
09:57:43 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
09:59:28 <Hamlet> ... gives complicated & confusing error message...
09:59:31 <mniip> Hamlet, what does 'findLargestPrimeFactor' do?
09:59:47 <mivael> s/directories/directories and files/
10:02:03 <Hamlet> it returns the first prime number in a list of ordered [largest to smallest] factors of a number
10:06:33 <monochrom> findLargestPrimeFactor (reverse (listOfFactors myGivenNumber))
10:07:02 <mniip> Hamlet, then why do you return Nothing
10:07:08 <mniip> and
10:07:12 <mniip> why do you check for primality
10:07:57 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
10:10:13 <Hamlet> Problem sol'n strategy: First, take the listOfFactors of myGivenNumber; Second, reverse the list to give largest -> smallest factors; Third, check each factor until first prime factor is found.. that is largestPrimeFactor
10:23:24 <mniip> what if none are found
10:25:32 <Hamlet> Q: How do you take a value from a list? e.g. I want the value of the singleton list [5]
10:26:09 <EvanR> > (\[x] -> x) [5]
10:26:11 <lambdabot>  5
10:26:14 <EvanR> > (\[x] -> x) []
10:26:16 <lambdabot>  *Exception: <interactive>:3:2-10: Non-exhaustive patterns in lambda
10:27:12 <EvanR> (\[x] -> x) also known as head, requires you to know that the list isnt empty. or else kablooey
10:27:36 <EvanR> in general you cant have any value from a list, it might be empty
10:27:45 <mizu_no_oto_work> There's also safeHead
10:28:03 <mizu_no_oto_work> thttps://hackage.haskell.org/package/safe
10:28:12 <EvanR> which leads to asking how you get the value from a Maybe
10:28:37 <mizu_no_oto_work> :t maybe
10:28:39 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:28:49 <EvanR> with safeFromJust!
10:29:00 <Hamlet> "what if none are found" - Any number is composite or prime, ie. there is a minimum prime number factor for any given (composite) number
10:29:03 <MonadHendrix> :t catMaybes
10:29:04 <lambdabot> [Maybe a] -> [a]
10:29:06 <EvanR> you probably want to do some strategy like maybe directly on that list anyway
10:29:10 <ExpHP> am I right in thinking that 'let m' = (m >>= (pure $!)) in m' >>= f" will reliably force m's contents before they are passed into f?
10:29:14 <Lokathor> hmm, libraries that provide typeclasses should provide more quickcheck properties about those typeclasses :P
10:29:37 <ExpHP> (since it hides the data constructor for the monad behind $!)
10:30:05 <Hamlet> Q: How do you take a value from a list? e.g. I want the value of the singleton list [5]
10:30:20 <Tuplanolla> You should define an F-algebra `headAlg` and then use `extract . cata headAlg`, Hamlet.
10:30:33 <kadoban> Hamlet: Pattern match, or if you know it's exactly that, you could use the 'head' function, though it'll crash if you're wrong.
10:30:34 <Lokathor> Hamlet, usually "head", or a pattern match, or !!
10:30:46 <Lokathor> what kadoban said :3
10:30:57 * EvanR waits for the question to be repeated
10:30:58 <kadoban> Well you added !! which I forgot about xD
10:32:03 <mizu_no_oto_work> > fromMaybe 0 $ listToMaybe [1,2,3]
10:32:06 <mizu_no_oto_work> > fromMaybe 0 $ listToMaybe []
10:32:06 <lambdabot>  1
10:32:08 <lambdabot>  0
10:32:13 <mizu_no_oto_work> Hamlet ^
10:32:30 <EvanR> if its impossible for the list to be empty, that wouldnt make much sense
10:32:44 <EvanR> since its the list of prime factors
10:32:48 <EvanR> ...
10:33:16 <Tuplanolla> For `1`, EvanR?
10:33:16 <mizu_no_oto_work> listToMaybe in Data.Maybe is the same as headMay in Safe.
10:33:47 <EvanR> the answer is clear [1]!
10:35:04 <mizu_no_oto_work> Safe also has "headNote :: String -> [a] -> a ", so you could get the head of the list via `headNote "factorizations must contain prime numbers, so this should never be empty" factors`
10:35:10 <Tuplanolla> Is this a `listOfUsuallyPrimeFactors`?
10:35:18 <mizu_no_oto_work> Alternatively, pattern matching works
10:35:38 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
10:35:41 <EvanR> it does simplify the question of dealing with empty lists
10:35:58 <Hamlet> My file above has the code
10:36:50 <rblaze> listOfUsuallyPrimeButSometimesNotFactors
10:36:59 <MonadHendrix> rblaze: lol
10:38:12 <reactormonk[m]> For a bit of dependent typing, I can't use typeclasses anymore - how would I make https://gist.github.com/23c639d34302d918a41ba4e555d4dd37 compile?
10:38:19 <reactormonk[m]> ... which data structure would I need?
10:38:35 <nitrix> Can GHC optimize the wrapping/unwrapping of Maybe in the examples above?
10:38:54 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
10:41:09 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
10:41:57 <cocreature> nitrix: which examples are you referring to?
10:43:35 <nitrix> cocreature: \f -> fromMaybe f . listToMaybe
10:43:42 <Hamlet> http://lpaste.net/354950
10:45:22 <Hamlet> @nminip, this is my script... http://lpaste.net/354950
10:45:22 <lambdabot> Unknown command, try @list
10:46:00 <cocreature> nitrix: yep
10:46:11 <cocreature> nitrix: you can use -ddump-simpl to see the core ghc produces
10:46:26 <cocreature> it takes a while until you get used to reading it but then it’s really useful
10:47:00 <cocreature> nitrix: in this case it looks like this http://lpaste.net/354965
10:47:59 <nitrix> cocreature: (@ c_ay5)
10:48:11 <nitrix> cocreature: There's an implicit type as first agument?!
10:48:17 <cocreature> yep
10:48:24 <cocreature> there is in Haskell as well
10:48:32 <cocreature> and with -XTypeApplications you can specify it :)
10:49:08 <nitrix> I've played with -XTA but I thought it was a trickery of the type inference, not actually part of the implementation.
10:49:35 <cocreature> core has had explicit type applications for quite some time, maybe even forever
10:49:58 <Tuplanolla> I'm pretty sure forever.
10:50:21 <cocreature> probably
10:50:38 <Hamlet> How do I message someone directly?
10:50:50 <geekosaur> /msg user stuff
10:51:00 <geekosaur> note that they can disable this if you are not registered with nickserv
10:51:18 <nitrix> cocreature: This reads fairly nicely if I squint my eyes. I see that Maybe did get eliminated.
10:51:21 <ExpHP> or "/query user" usually opens a new tab where you can type stuff on most clients
10:51:26 <nitrix> cocreature: I wish I could understand the naming convention though.
10:51:37 <nitrix> s/convention/generation/
10:52:14 <cocreature> I have no idea how they are chosen :)
10:52:27 * nitrix flips cocreature upside down.
10:52:32 <cocreature> oO
10:52:52 <cocreature> what did I do to deserve that
10:52:53 <thoughtpolice> You can use -dsuppress-uniques to get output far closer to what they originally were, for certain bindings.
10:53:13 <Hamlet> Need help with this script... http://lpaste.net/354950
10:53:16 <dolio> I think it involves a hash function.
10:53:33 <thoughtpolice> Some bindings are simply introduced. Some others, like dictionaries, tend to follow a certain convention already (something like 'fOrdInt' or something IIRC)
10:55:32 <nitrix> thoughtpolice: Good to know for -dsuppress-uniques.
10:56:57 <nitrix> cocreature: You changed my perspective on the world. I'm just making you look straight again :P
10:57:19 <cocreature> heh :)
11:13:55 <Lokathor> *go to the project's repo to report a bug in the windows build*
11:14:02 <Lokathor> *they already have the fix posted*
11:14:05 <Lokathor> :D
11:41:36 <MonadHendrix> anyone got some good code to read
11:42:29 <shapr> MonadHendrix: have you seen hedgehog?
11:43:25 <MonadHendrix> i haven't
11:43:34 <garlvinland> hi, can I direct any summer of haskell 2017 questions here or is there a dedicated channel?
11:43:44 <shapr> I think there's a dedicated channel, but I forget the name
11:43:45 <MonadHendrix> https://github.com/hedgehogqa/haskell-hedgehog this?
11:43:51 <shapr> MonadHendrix: yeah!
11:44:02 <MonadHendrix> shapr: thanks, will take a look
11:44:36 <Zemyla> You know, it occurs to me that, if you have a type f such that, for some Monad m, you don't have (<*>) :: f (a -> b) -> f a -> f b, but you do have (<*=>) :: f (a -> b) -> f a -> m (f b), then you can still make an Applicative from it.
11:44:39 <MonadHendrix> anything similar to that 'typing the technical interview' is also cool, finished reading all the Monad Readers and am procrastinating at record levels
11:45:44 <MonadHendrix> garlvinland: #haskell-gsoc
11:46:04 <MonadHendrix> garlvinland: how poroficient do you need to be to enter that, looks cool
11:46:09 <MonadHendrix> *proficient
11:47:02 <shapr> MonadHendrix: oh, I like The Monad Reader
11:47:12 <shapr> Though there's not been a new issue for years
11:47:16 <monochrom> Zemyla: How do you make an Applicative from it?
11:47:22 <shapr> I'm tempted to restart TMR
11:47:47 <MonadHendrix> maybe ill write an article one day
11:47:59 <monochrom> That's what I said too. 5 years ago.
11:48:01 <garlvinland> @MonadHendrix thanks. no idea, I've started learning haskell on my own and thought it would be a good incentive to go all-in on the learning experience
11:48:01 <lambdabot> Unknown command, try @list
11:48:13 <akr[m]> how does `cabal report` work exactly? It gives me no output in the shell after I input my login information, even with  -v3
11:48:18 <garlvinland> MonadHendrix thanks. no idea, I've started learning haskell on my own and thought it would be a good incentive to go all-in on the learning experience
11:48:27 <akr[m]> and nothing has changed on the page for the package at hackage
11:48:57 <Zemyla> monochrom: Well, to start, look at this post I made on Curried Yoneda Applicatives and `confusing` in lens: https://www.reddit.com/r/haskell/comments/5715b3/when_can_i_expect_overhead_for_lens/d8p78os/?context=3
11:49:00 <shapr> monochrom: did you write an article?
11:49:09 <monochrom> No.
11:49:13 <shapr> WHY NOT?
11:49:19 <shapr> I wrote an article for TMR once
11:49:56 <Zemyla> But you'll want to use a subtly different type: newtype MCurr m f a = MCurr { unMCurr :: forall r. f (a -> r) -> m (f r) }
11:50:20 <monochrom> Ah no wonder.
11:50:50 <shapr> Zemyla: want to write an article for The Monad Reader?
11:51:20 <Zemyla> Oh? How would I do that?
11:51:41 <shapr> Well, you write an article, and the editor likely accepts it.
11:51:49 <Zemyla> Though actually, I have an idea on a good example.
11:52:11 <shapr> ezyang: any word on new TMR issues?
11:52:21 <shapr> I think ezyang was the most recent person running TMR
11:52:37 <monochrom> TMR? HWN?
11:52:53 <shapr> I thought haskell weekly news was something else entirel?
11:52:59 <shapr> wasn't CosmicRa` running HWN?
11:53:07 <monochrom> Yes. I think ezyang was doing HWN.
11:54:35 <monochrom> Nevermind. You're right.
11:55:37 <monochrom> First order of business is to enter the new age and call it The Applicative Reader. Then you can also get to put the latex code in a tar file.
12:01:11 <pie_> so, as type systems get more and more advanced, do we not go from writing programs to writing programs in type systems? isnt that basically just shifting the burden?
12:02:08 <geekosaur> spreading it, really. a program literally written in the type system would be run by compiling; most programs still run the traditional way, instead of being compiled to run
12:02:17 <monochrom> No, it is worse (or better). You write the program twice, once at the term level, once at the type level.
12:03:30 * pie_ mumbes smething about redundancy i guess
12:03:56 <monochrom> It has the prospect of being better because what Hoare said about "oh but how wonderful would it be if you could get rid of a lot of bug by just writing your code twice!"
12:04:09 <pie_> you guys know anything that discusses this in a little more depth or is there no point?
12:04:21 <pie_> monochrom, hehh
12:04:33 <isd> So, the thing is, as you write more in the type system, you also have fewer things you can only check via tests. The redundant code for verification is going to be *somewhere* if you're doing things correctly, but with the type system it will be more exhaustive, if it can capture the checks.
12:04:45 <monochrom> And indeed he said that to support types, although he only had the monomorphic ones in mind, i.e., in Algol you had to declare "i : int".
12:05:18 <monochrom> But writing specifications as types is his sentence taken to the extreme.
12:05:48 <isd> Like, I've seen plenty of python unit test that check for trivial type errors.
12:05:57 <monochrom> Redundancy is the basis of error detection.
12:06:03 <pie_> <isd> Like, I've seen plenty of python unit test that check for trivial type errors.
12:06:13 <pie_> this is really my main problem with python right now
12:06:15 <EvanR> the more tests you can write, the more typing you do, the more productive you are, dont question this
12:06:16 <pie_> otherwise i like it
12:06:16 <monochrom> And moar redundancy is the basis of error correction.
12:06:33 <isd> In my experience, when you can verify with the types instead of tests, it's more concise *and* more exhaustive.
12:06:42 <pie_> monochrom, quantity over quality right? ;PPPP
12:06:44 <EvanR> yes but writing the program twice in a row is almost the worst way to add redundancy
12:06:58 <EvanR> only surpassed by writing it 3x in a row
12:07:00 <pie_> but thats not even wrong because types hopefully cover the entire space of the thing
12:07:02 <monochrom> No, it is more about working on two perspectives.
12:07:12 <pie_> yeah thats what i figured
12:07:47 <monochrom> You usually use one mindset to write the spec, another mindset to write the code. The two perspectives together form a very good cross-check.
12:08:38 <EvanR> RMS said that computer science is the easiest of all sciences, each programming piece has no change of messing up, breaking, overheating, getting EMI, etc because its mathematically simple. and you "just" have to then worry about the complexity of putting the pieces together
12:09:02 <EvanR> he was almost certainly talking about lisp programming
12:09:06 <EvanR> or C
12:09:11 <monochrom> Test-driven programming is based on the same philosophy, except that people don't realize that tests are small specifications.
12:09:37 <EvanR> tests are error prone specifications
12:09:49 <EvanR> usually
12:09:55 <Tuplanolla> Not C, EvanR. I'm working on a project where changing include order affects program behavior right now.
12:09:57 <monochrom> No.
12:10:06 <isd> He was talking about the fact that code doesn't "go bad" -- not that you can't have errors, but you don't have programs beginning to fail as a direct result of being old.
12:10:28 <EvanR> but you cant deny that the include mechanism is so simple it hurts (when you put many includes together)
12:11:15 <monochrom> Electronic computers are messed up by overheating and EMI all the time.
12:11:15 <Zemyla> shapr: So how and where do I submit an article for The Monad Reader?
12:11:21 <EvanR> anyway as easy as it all seems, its amazing how adding the more and more sophisticated type system makes it even easier
12:11:58 <monochrom> OTOH if you do it Dijkstra's way, programming by pen and paper, then you are immune to EMI, but you may still overheat your pen tip :)
12:12:31 <EvanR> i do most haskell on pen and paper
12:12:49 <EvanR> because i dont usually make it to the point where typing it in would make any sense
12:13:26 <EvanR> so productivity per line of code is skyrocketing
12:16:35 <pie_> https://www.youtube.com/watch?v=ZKmodCApZwk category theory, type theory or proof theory in what order? wat do?
12:17:02 <pie_> monochrom, heh :)
12:17:28 <pie_> or in other words: i dont know types, wat do
12:17:36 * pie_ is aiming for idris
12:17:49 <cocreature> if you’re aiming for idris, read edwin’s book :)
12:17:54 <Tuplanolla> I'd leave categories last simply because all the examples are from other fields, pie_.
12:18:07 <pie_> cocreature, i have a copy :D but id still like to understand types
12:18:31 <pie_> cocreature, not to criticize edwins pedagogy xD thats not what i meant
12:18:42 <mniip> 1493233554 [22:05:54] <monochrom> And moar redundancy is the basis of error correction.
12:18:43 <mniip> no
12:19:02 <pie_> more like its probably going to take me a lot of the idris book to get a little bit of type theory. then again learning TT mathematically might be unpractical :P
12:19:17 <mniip> the basis of error correction is non-intersecting spheres
12:19:20 <EvanR> look at the first chapter of the HoTT book
12:20:53 <pie_> EvanR, ok \o/
12:21:27 <cocreature> harper’s book is also pretty good although I have to admit I never finished it due to a lack of time & interest :)
12:21:47 <monochrom> Yes the first chapter is good for type theory. If you don't need the "Ho" part you can simply stop after the first chapter.
12:22:20 <Zemyla> So the last issue of the Monad Reader seems to have been published in 2015?
12:22:25 <Zemyla> Unless there's another one out there?
12:22:52 <cocreature> Zemyla: sounds about right. it’s been dead for some time
12:23:21 <monochrom> mniip, non-intersecting spheres means how to use the redundancy most meaningfully, rather than meaning irredundancy.
12:23:42 <Zemyla> So someone suggested I write up a technique I found and submit it to it. Is there another good place for me to submit it where people can read it and I don't need to have a blog of my own?
12:23:54 <EvanR> github repo maybe
12:26:22 <zomg> Zemyla: medium? :P though you should start a blog if you like to write :)
12:27:24 <Tuplanolla> Some sort of community blog, Zemyla?
12:27:54 <monochrom> reddit
12:28:17 <Tuplanolla> If you don't mind being drowned in a sea of garbage, monochrom.
12:28:38 <monochrom> Create two accounts on stackoverflow. Use one account to ask a fake question, whose solution is your article. Use another account to post the solution, which is your article. :)
12:29:04 <monochrom> Post on facebook.
12:29:28 <monochrom> Make a video of scrolling through your article slowly. Post the video on Youtube. :)
12:29:52 <monochrom> Post on comp.lang.haskell
12:30:11 <monochrom> (Does anyone want to ask "what is comp.lang.haskell?"? :) )
12:31:26 <monochrom> Post on haskell-cafe
12:39:17 <Ankhers> monochrom: You can answer your own questions on SO. It is even encouraged. They have a checkbox when you are asking your question to let you answer it immediately before it is even posted. As for comp.lang.haskell, that sounds like a usenet group. Haven't actually looked though.
12:41:07 <monochrom> Ah that's better than two accounts :)
12:43:55 <Hamlet> Need help with this program.. http://lpaste.net/354950
12:45:07 <monochrom> Hamlet, I am not sure how a comment causes a type error.
12:45:08 <pie_> monochrom, the wrong question to ask is will this help me? http://www.cse.chalmers.se/research/group/logic/book/book.pdf
12:45:24 <pie_> im already not really getting the whole judgement/proposition thing
12:46:55 <MonadHendrix> monochrom: stick a $ after findLargestPrimeFactor in the second let statement of main
12:47:29 <monochrom> pie_, I agree with you, I didn't understand the distinction until two years after I aced a logic course that was supposed to insist on the distinction. :)
12:47:44 <MonadHendrix> uh
12:47:47 <MonadHendrix> Hamlet: ^
12:48:16 <pie_> heh
12:48:16 <pie_> ok
12:48:24 <pie_> i mean i think i have a vague inkling
12:48:36 <pie_> moar meta
12:48:42 <MonadHendrix> `findLargestPrimeFactor reverse_listOfFactors myGivenNumber` is doing ((findLargestPrimeFactor reverse_listOfFactors) myGivenNumber)
12:48:46 <monochrom> But it may help to say the two things are on two different levels, judgment is at the meta level, proposition is at the target level. There are other points too.
12:48:56 <MonadHendrix> not (findLargestPrimeFactor (reverse_listOfFactors myGivenNumber))
12:49:01 <pie_> the problem is i dont really get the meta in this case :P
12:49:06 <pie_> well, we'll see how it goes
12:49:26 <pie_> i mean i see that its meta, i just dont know that that actually means
12:49:28 <MonadHendrix> i hope your terminal is wide enough for that to be clear
12:49:33 <MonadHendrix> because mine isn't
12:50:41 <lpaste> Hamlet revised “Find largest prime factor of 600851475143”: “Find largest prime factor of 600851475143” at http://lpaste.net/354950
12:50:52 <monochrom> OK, I'll try an analogy, I don't know how well it works and how much it breaks. Compile-time computations are like meta level. Run-time computations are like target level.
12:51:19 <pie_> monochrom, if i havent learned any topology proper yet, is HoTT not for me?
12:51:36 <pie_> man theres so many areas of math i wish i had better grounding in
12:51:47 <monochrom> If you haven't seen topology, only the "Ho" part is not for you.
12:52:03 <pie_> ok
12:52:08 <monochrom> HoTT's chapter 1 is really vanilla Martin-Löf, no Ho.
12:52:37 <pie_> does the fact that this has topology give some kind of geometric meaning to programs?
12:52:54 <pie_> (topology just makes me think geometry, is that a bad trigger?)
12:52:55 <monochrom> I don't know.
12:53:01 <monochrom> Yes.
12:53:04 <pie_> ok
12:53:11 <pie_> i mean i know its not the same as geometry
12:53:23 <Hamlet> Updated file.. still errors http://lpaste.net/354950
12:53:41 <monochrom> Geometry cares about distance, in fact look at the "metry" suffix, it's all about distance. Topology ignores distance.
12:54:05 <Tuplanolla> Having studied general topology first, it didn't help me understand homotopy type theory at all, pie_.
12:54:05 <pie_> "Topology is the field concerned with the properties of geometric objects that are unchanged by continuous mappings. In practice, this often means dealing with large-scale properties of spaces, such as connectedness and compactness." huh.
12:54:11 <pie_> Tuplanolla, ok
12:54:50 <pie_> monochrom, felix kleins imagining of geometry is actually all about groups \o/ (iirc)
12:55:39 <pie_> anyway, geometry is cool (tm)
12:55:41 <monochrom> I have a tea cup with a handle in front of me. If I say "this is equivalent to a donut" it may sound odd. It is false for geometry, the distances (rather, ratios between distances) don't match up. But it is true in topology, there is a continuous bijection, whose inverse is continuous too, between my cup and the donut.
12:55:57 <bperez> Looking for some help with ghc plugins. Every time I use -fplugin I get an error telling me the plugin module imports itself, even though that's not the case. I've even tried this with the example plugin on the ghc wiki
12:55:59 <pie_> i wish my cup was a fonut :(
12:56:12 <Hamlet> By the way, I'm perusing this.. http://www.open.ou.nl/bhr/heeren-helium.pdf | Not sure if Helium is helpful for beginners.. any feedback from anyone here?
12:56:15 <pie_> im having sugar cravings. probably addicted to sugar.
12:56:31 <pie_> i really miss me some american donuts...
12:56:51 <monochrom> And I keep forgetting what homotopy focuses on.
12:57:04 <pie_> well homo means same and topos means plave
12:57:05 <pie_> place
12:57:08 <pie_> so i have no idea :P
12:57:25 <Tuplanolla> I also don't understand why people always mention embeddings when they want to explain topology. It looked more like set theory on steroids to me.
12:57:53 <pie_> Tuplanolla, that sounds plausible
12:58:10 <meiji11> I'm generating Haskell code using Template Haskell, and the code it pretty prints generates parse errors on ghc 8.0.1. is there any way I can rectify that? I had similar problems with GHC 7.8.2 and I had to roll back to 7.6.2.
12:58:34 <monochrom> Mathematicians tend to present everything as sets on steroids. Recall that vector spaces are glorified sets too.
12:58:59 <monochrom> Well, even a 2-tuple is a glorified set.
12:59:09 <Sornaensis> > (1,"blorps")
12:59:12 <lambdabot>  (1,"blorps")
12:59:37 <cloudhead> hey, does anyone know how I can use digestive-functors to parse a form with dynamically generated inputs with the same 'name' field?
12:59:38 <monochrom> They have a highly set-manipulating proof for fst(x,y) = x.
12:59:41 <sampuka> :t (,,,,,,,,,,,,,,)
12:59:42 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
12:59:48 <cloudhead> I've been struggling to find a way
13:00:25 <Sornaensis> :t (,) . (,)
13:00:27 <lambdabot> a -> b1 -> (b -> (a, b), b1)
13:00:31 <monochrom> You will probably enjoy the book "Topology via Logic" which gets rid of sets.
13:00:48 <monochrom> It's also fairly cheap and thin.
13:01:22 <Tuplanolla> Topology could have been presented in a pointless manner, but no, the books had to do their earnest to make it as boring and unpleasant as real analysis.
13:01:33 <monochrom> But IMO embedding is a good idea.
13:01:37 <Tuplanolla> My bias may be showing a little here.
13:02:17 <ystael> Tuplanolla: point set topology divides into two parts: boring technical nonsense to implement real analysis, and boring technical nonsense to implement homotopy theory. :)
13:02:47 <monochrom> I have a tea cup in front of my, and I still think that the best way to visualize it is to embed it in the 3D space I live in, rather than me shrinking down to an ant to walk on its surface 2Dly.
13:03:22 <Hamlet> Q: Has anyone used Helium here?
13:03:32 <monochrom> Err actually both perspectives are valuable. You certainly want to do both, sooner or later.
13:04:02 <monochrom> So, please don't hate embedding, even though you can hate sets as much as you want, I'm in agreement there :)
13:04:30 <monochrom> haha ystael
13:06:57 <pie_> monochrom, well, something somthing foundations of mathematics so...yknow
13:09:59 * pie_ wished continuous meant differentiable
13:11:29 <shapr> Zemyla: as far as I can tell, ezyang is the current TMR leader, but I'll see if they're bored with it.
13:11:39 <shapr> if the answer is yes, then I can be the next TMR editor/leader! w00t!
13:14:52 <dzdcnfzd> Anybody have any ideas? Stuck on figuring out how to make the right natural transformation for my Servant Server: http://lpaste.net/5053080047955476480
13:15:35 <merijn> dzdcnfzd: What's :~> ?
13:15:37 <dzdcnfzd> (see lines 57 - 71)
13:16:05 <dzdcnfzd> merijn: it's from https://hackage.haskell.org/package/servant-0.10/docs/Servant-Utils-Enter.html#t::-126--62-
13:16:31 <merijn> dzdcnfzd: Also, rather than using the awful C.. for composition from Control.Category, why not just hide regular (.)?
13:16:49 <merijn> Since Control.Category.. works in all cases where (.) does
13:17:01 <dzdcnfzd> merijn: perhaps, but that's not really my problem right now
13:17:34 <merijn> dzdcnfzd: Yeah, but I'm tired and not getting much useful ideas on the actual problem :p
13:17:42 <Zemyla> shapr: If you do get it, or get ezyang to take submissions, PM me.
13:17:50 <dzdcnfzd> merijn: :)
13:18:00 <merijn> Kinda confused why they're reinveinting mmorph, tbh
13:18:01 <shapr> ok, sure
13:18:07 <ezyang> shapr: Did you want to take over TMR?! 
13:18:21 <shapr> ezyang: maybe? it looks inactive?
13:18:32 <merijn> dzdcnfzd: Anyway, "import Prelude hiding ((.))" as first import should remove the need to qualify your use of (.) :)
13:18:40 <ezyang> yeah, I haven't had cycles ^^ 
13:18:42 <shapr> ezyang: but if you're working on it, I don't want to distract you
13:18:47 <shapr> ezyang: ok! sure!
13:18:55 <dzdcnfzd> merijn: I'll do that!
13:19:04 <shapr> I get to be first and fourth editor of TMR!
13:19:15 <shapr> unless there was someone between wouter and ezyang 
13:19:40 <ezyang> byorgey 
13:19:41 <merijn> dzdcnfzd: I'm not too sure what's going on with the real problem, sadly :)
13:19:58 <shapr> oh good, that makes me fifth editor
13:23:19 <merijn> Style question/poll: When moving the RHS of a function to a new line (because of being too long), should I move the = too?
13:23:27 <lpaste> merijn pasted “Style poll” at http://lpaste.net/354971
13:24:07 <Tuplanolla> I always go for option #1, because then I don't need to think about alignment, merijn.
13:24:51 <MonadHendrix> merijn: i submit to hindent
13:25:32 <shapr> Zemyla: sounds like you send the article to me!
13:25:52 <Zemyla> It should be in PDF and LaTeX format, or something?
13:26:24 <shapr> Zemyla: yeah, I like LaTeX
13:26:49 <shapr> TMR started out as wiki-only article, but that changed to LaTeX so you could produce a downloadabel PDF
13:27:21 <Zemyla> shapr: Would you accept LyX? I don't know raw LaTeX, but I can use a WYSIWYG LaTeX editor. :V
13:27:41 <shapr> maybe?
13:28:29 <fragamus> in ghci can I find out which import is associated with a given symbol
13:28:30 <Tuplanolla> It's like reading a disassembly, shapr.
13:29:19 <shapr> Tuplanolla: want to write a TMR article?
13:29:35 <shapr> Tuplanolla: when you put it that way, doesn't sound like I want lyx
13:29:39 <fragamus> i figgered it out
13:29:47 <shapr> fragamus: what was it?
13:29:50 <Tuplanolla> I'm building my own blog at the moment, shapr. Maybe later.
13:30:04 <shapr> ok
13:30:09 <fragamus> :i sym
13:30:16 <Squarism> is it possible to switch between with and wo "--profile" when using stack? accidently missing it seems to throw away everything and then wait for 10 minutes of recompiling w/ or wo  profiling.
13:30:43 <MarcelineVQ> merijn: fwiw I also use option 1
13:31:00 <kadoban> Squarism: I think there's a way to specify that stuff in the stack.yaml
13:31:07 <hexagoxel> merijn: maybe consider the case that you have one action, and add a "do" + a second one. "=" at end of line is nicer then.
13:31:20 <Squarism> kadoban, ok - ill check it out
13:31:40 <merijn> hexagoxel: I use "= do\n" for do blocks, yes. But I was wondering what'd be nicer for single lines
13:32:03 <eschnett> “=“ and “==“ are conceptually similar. where would you place the “==“? or another infix operator?
13:32:28 <merijn> eschnett: I tend to avoid linewrapping with infix operators
13:32:46 <merijn> Unrelatedly: In which directory does cabal run tests when you do "cabal test"?
13:32:55 <Tuplanolla> The low effort solution is to shove all the awkward things to the end of the line, merijn. The result is ugly too, which is a plus: http://lpaste.net/352328
13:32:59 <eschnett> merjin: there’s you answer — put it onto one line and use where?
13:33:05 <monochrom> merijn: I don't move the "=". In fact usually I write "f x =" one line, "    x + x" next line (if "x + x" is long)
13:34:03 <monochrom> I also write "f x = do" if "do" is involved.
13:34:46 <hexagoxel> merijn: yeah, i meant to focus on how much refactoring is necessary when you add/remove a second line.
13:35:14 <merijn> Good point, actually
13:41:14 <hexagoxel> (i might like \n= longexpr\n+ longexpr, but i also generally avoid such uses of infixops)
13:47:39 <merijn> Using quickcheck and testy I need to generate some random filename and random short bytestring, any pointers?
13:48:53 <merijn> Right now I'm just hardcoding a filename and some data, but that seems wrong
13:58:45 <MarcelineVQ> does the bytestring become the file? is it a temporary file? does it get deleted after you use it or is it being compared to another file?
13:59:18 <merijn> MarcelineVQ: I'm creating a file temporarily to verify that it's getting deleted
14:07:09 <MarcelineVQ> I'd probably let the  temporary  package handle the file and filename, an issue with quickcheck is that generators tend to start simple so if you're using Test.QuickCheck.Gen to get a random bytestring you'll probably want to adjust the size of what you get. with the  quickcheck-instances  package you can get a random bytestring simply with  generate (arbitrary :: Gen ByteString)
14:09:35 <MarcelineVQ> tasty also has support for golden tests, if that becomes useful to you now or later on, https://hackage.haskell.org/package/tasty-golden
14:16:53 <merijn> Argh
14:17:07 <merijn> Why does Data.ByteString.hGetContents close the Handle? >.<
14:17:21 <merijn> Who the hell thought that was a good idea?!
14:17:55 <merijn> Anyway I can read a file completely into memory without closing the handle?
14:18:26 <geekosaur> it's necessary
14:18:28 <Gurkenglas> Can I ask lambdabot whether a message was received, and should we add that?
14:18:34 <merijn> geekosaur: Why?
14:18:52 <MarcelineVQ> lazy bytestring?
14:18:56 <geekosaur> merijn, the Handle is handed to unsafeInterleaveIO. you cannot safely manipulate it afterward because it's accessed from pure code
14:18:58 <merijn> No, strict
14:19:14 <merijn> geekosaur: Eh, why would it be handled to unsafeInterleaveIO?
14:19:17 <MarcelineVQ> I​ mean is lazy bytestring a solution? idk much about them
14:19:20 <geekosaur> oh,strict bytestring, don;t know if it does the same thing
14:19:21 <merijn> This is strict, not lazy ByteString
14:19:29 <geekosaur> but I would expect it to maintain the same API
14:19:32 <merijn> geekosaur: It does, else I wouldn't be running into this bug
14:19:57 * geekosaur goes looking
14:20:11 <merijn> That's really obnoxious, because it means I can't read a file multiple times by reseting via hSeek
14:20:16 <monochrom> I will still defend closing it. But I can see a minority of alternative use cases of not wanting it closed.
14:20:44 <merijn> monochrom: I could understand defaulting to closing, but there's no non-closing alternative
14:20:47 <geekosaur> the use a different API
14:20:49 <monochrom> OTOH history is written by historical reasons.
14:21:11 <geekosaur> isn't that hGetSome?
14:21:19 <monochrom> The strict case closes because the lazy case closed and no one at that time thought of alternatives.
14:21:22 <merijn> geekosaur: "use a different API" is basically "reimplement hGetContents"
14:22:19 <merijn> geekosaur: hGet and hGetSome require me to know the length I'm trying to read
14:22:20 <glguy> merijn: I know! go down to the unix layer and duplicate the file descriptor, use that to make a duplicate Handle, hGetContents that duplicated handle
14:22:23 <geekosaur> hGetContents is there to replicate an existing API. (One which imo kinda sucks anyway...)
14:22:25 <monochrom> hGetSome requires you to cite a number.
14:22:32 <merijn> glguy: Then the tests won't run on windows!
14:22:38 <glguy> What's windows?
14:22:51 <monochrom> Haha glguy
14:22:53 <Tuplanolla> You can use seeking to find the size of the file, merijn.
14:22:54 <merijn> glguy: I don't care, but I don't see that helping my case to get my patch merged
14:22:55 <geekosaur> whatever, ok yes hGetContents should be a different API from hhGetContents elsewhere
14:23:02 <geekosaur> obviously nobody expects APIs to be the same
14:23:26 <glguy> merijn: Getting the operation you want exposed in the library is a good way forward, of course
14:23:31 <Tuplanolla> You're already seeking, so that shouldn't be much of a stretch.
14:23:58 <merijn> Is hGetSome guaranteed to basically be hGet when dealing with files?
14:24:19 <monochrom> I agree with Tuplanolla regarding getting it done today. For tomorrow, file a request.
14:24:33 <merijn> (I can probably manage an educated guess about the file length, but blocking indefinitely) would be a problem
14:24:57 <monochrom> Maybe you can just hGet and not worry about hGetSome
14:25:12 <geekosaur> hGetSome actually looks like it's intended more for sockets
14:25:16 <merijn> geekosaur: It is
14:25:16 <glguy> You shouldn't have to guess the length, you can query the file size
14:25:32 <geekosaur> so yes, hGet or hGetNonBlocking
14:25:33 <merijn> monochrom: Oh, wait, I suppose if I over guesstimate the size hGet will still return when it hits EOF
14:25:39 <geekosaur> yes
14:26:10 <monochrom> YES! ASK FOR 1TB! :)
14:26:28 <glguy> hFileSize :: Handle -> IO Integer
14:26:36 <merijn> glguy: Yes, I could, but my guesstimate is way easier to compute and doesn't require fiddling with annoying things :p
14:26:52 <glguy> easier to compute than importing it from System.IO?
14:26:54 <merijn> hmmm, I suppose hFileSize works
14:27:11 <merijn> glguy: I'll go with "equally easy, so I'll do the right thing"
14:27:16 <glguy> yay
14:27:51 <monochrom> No no no. The easiest thing to do is to detect the file system and then look up a known table on wikipedia about maximum file size support for this file system and request that number of bytes.
14:27:57 <monochrom> (Just kidding!)
14:28:24 <Tuplanolla> Was my suggestion too complicated, merijn?
14:28:27 <monochrom> (But for example, if it's FAT32, just ask for 4GB. OK I'm done.)
14:28:39 <glguy> there's always 'maxBound'
14:29:07 <merijn> Tuplanolla: Well, first seeking, then querying the offset is less nice than simply using hFileSize :)
14:29:25 <glguy> Oh, I wouldn't recommend overguessing... hGetSome uses createAndTrim
14:29:33 <glguy> maxBound might be too big...
14:29:38 * monochrom was very surprised and annoyed when discovering for the first time he had an 8GB file to put on a FAT32 USB (32GB capacity) and the error message was "disk full" WTF?)
14:29:43 <MarcelineVQ> it almost might be too small, potentially
14:29:51 <bperez> I'm currently compiling something with -prof and am getting "Cannot load -prof objects when GHC is built with -dynamic"
14:30:01 <bperez> is there a good workaround for this?
14:30:28 <MarcelineVQ> maxBound only gurantees.. 512 megs for Int?
14:30:40 <MarcelineVQ> > (2^29-1) / 1024 / 1024
14:30:45 <lambdabot>  511.9999990463257
14:31:24 <monochrom> You know what, my program uses both hFileSize and seek-and-thou-shalt-find. Because one of them works for files, the other works for /dev/sr0.
14:32:26 <monochrom> Here: https://github.com/treblacy/random-read/blob/master/random-read.hs
14:32:59 <monochrom> Actually you can safely scroll down to line 72 and I should have put that in the URL
14:45:52 <kamyar> Hello all
14:46:16 <kamyar> Please help me build a project using HaskForce plugin of IntellijIDEA
14:46:21 * merijn sighs
14:46:53 <monochrom> Must you use IntellijIDEA and/or HaskForce?
14:46:56 <merijn> I keep having to wait for some slow stuff to finish to check whether it's still slow or I fixed it...
14:47:49 <monochrom> merijn: Yeah, it happens to me too when there is a disk error or slow website.
14:48:14 <monochrom> "I have to try 3 times to make sure. And each time takes 1 minute of waiting."
14:48:52 <kamyar> monochrom: Leksah does not run on GHC 8.0.2, and is ther eany better IDE? BTW I get habit of JetBRains IDE's
14:49:09 <monochrom> Not to mention that so-called "1 try" is implemented by the lower layer by 3 low-level tries. Ah the fractal structure of tries.
14:49:10 <kamyar> I have used PyCharm and IntellijIDEA for ears
14:49:37 <monochrom> kamyar, that doesn't really answer my question.
14:50:14 <kamyar> monochrom: What do u wanna know? u mean using a simple text editor?
14:50:29 <merijn> Yay! Fixed it
14:50:33 <merijn> Now it's fast :)
14:50:33 <monochrom> I want to know: Must you use IntellijIDEA and/or HaskForce?
14:50:42 <monochrom> What happened, merijn?
14:51:37 <kamyar> monochrom: No! It is my own project!
14:51:59 <monochrom> Then consider a simple "cabal init" and a text editor.
14:52:06 <merijn> monochrom: Writing tests for criterion and it was running the benchmark as much as it would to benchmark normally, whereas I just need one iteration to validate the results
14:52:17 <merijn> i.e. whether the test passes or fails
14:52:27 <merijn> So limiting iterations to 1 is much faster
14:52:29 <kamyar> monochrom: I guessed! I am now using stack builder not cabal
14:52:40 <kamyar> monochrom: alongside with textmate
14:52:46 <monochrom> OK, there is a stack way too, I just don't know it.
14:53:05 <kamyar> monochrom: But I like auto-completion and error corretcion features
14:53:32 <Tuplanolla> Vim and Emacs have plugins for those, kamyar.
14:55:14 <Tuplanolla> Pick your poison, I guess.
14:55:16 <kamyar> Tuplanolla: For completion? What is the name of emacs plugin ?
14:55:26 <kamyar> Tuplanolla: I am using mepla 
14:55:34 <kamyar> Tuplanolla: *Melpa 
14:55:38 <monochrom> haskell-mode
14:55:58 <monochrom> It does some completion but there are limitations.
14:57:08 <monochrom> I am a perfectionist. My flaw is I will keep looking for the perfect code in my head before I write down one single letter in the editor.
14:57:40 <kamyar> Tuplanolla: I have it installed. It does not have completion
14:57:48 <monochrom> Most of you don't have this flaw. But you have the dual flaw. You keep looking for the perfect editor or IDE or plugin before you write down one single letter of code.
14:58:09 <monochrom> Hell, even before that, you keep looking for the perfect font.
14:58:36 <Tuplanolla> At all or of the kind you wish, kamyar?
14:58:39 <monochrom> So whereas I spend omega time, you guys spend omega+omega time.
14:59:10 <kamyar> Tuplanolla: dunno! I need Import and function call completion
14:59:50 <Tuplanolla> I can't help you with those since I don't have them either, kamyar.
15:00:11 <Tuplanolla> There's always that one language extension or TH trick that wrecks any plugin.
15:03:53 <c_wraith> -XCPP breaks basically everything 
15:04:28 <thang1> What about IncoherentInstances combined with UndecidableInstances? You're basically guaranteed to have a fun time with a bottle of vodka :p
15:04:51 <c_wraith> those break programs, not parsers. :P
15:05:02 <thang1> a parser is a program, obvs /s
15:05:28 <monochrom> Does it break your vodka? :)
15:05:45 <thang1> It helps me appreciate it, that's for sure
15:07:33 <thang1> http://joelgrus.com/2016/05/23/fizz-buzz-in-tensorflow/ I love it
15:11:35 <merijn> Right, time for bed and hoping all my tests will have succeeded in the morning, so I can start the endless process of badgering upstream to merge stuff...
15:11:45 <thang1> hah, nice. Good luck
15:19:15 <monochrom> hahah thang1
15:20:08 <monochrom> "how far are you intending to take this?" "just two layers"
15:21:31 <f0x> leave
15:23:37 <thang1> ಠ_ಠ
15:50:44 <halogenandtoast> Sometimes I'm convinced Haskell hates me...
15:50:56 <halogenandtoast> Expected type: IO (Maybe (IO (Maybe Text))) Actual type: Maybe (Maybe (IO (Maybe Text)))
15:51:14 <halogenandtoast> No idea how I've dug this hole.
15:52:00 <hpc> needs more Maybe
15:52:01 <davean> well
15:52:03 <hpc> or possibly more IO
15:52:07 <hpc> @lpaste
15:52:07 <lambdabot> Haskell pastebin: http://lpaste.net/
15:52:08 <davean> you can "join" out the first maybes
15:52:11 <davean> and return it all to get an IO
15:52:22 <davean> "return . join" and you're types match
15:52:27 <davean> though, uh
15:52:38 <davean> I mean, I think you fucked something else up to get that
15:52:39 <halogenandtoast> davean: yeah I'm assuming I'm doing something very wrong in the first place
15:52:47 <halogenandtoast> and the type system is just mad at me
15:52:55 <davean> As it probably should be
15:52:55 <hpc> can you paste your code?
15:53:13 <davean> halogenandtoast: so it sounds like its past you that hates current you, and Haskell is trying to save your ass ;)
15:53:32 <lpaste> halogenandtoast pasted “MoreIO.hs” at http://lpaste.net/354973
15:53:39 <halogenandtoast> I THINK that's the relevant code
15:54:10 <davean> ... and I'm out
15:54:14 <halogenandtoast> It's quite possible some of the things I'm doing (fmap, liftIO) aren't needed, but I've been type-flailing
15:54:39 <beebe23> join
15:54:51 <halogenandtoast> ha sorry davean, out of curiosity what do I do to KO you? 
15:55:05 <halogenandtoast> I'm going to blame Yesod, but if it was something I did, let me know.
15:55:09 <davean> halogenandtoast: Oh, I'm just alergic to Yesod :)
15:55:15 <halogenandtoast> ha fair enough
15:55:25 <Tuplanolla> When's Nood?
15:55:26 <halogenandtoast> beebe23: join in front of the liftIO?
15:55:30 <davean> If I try to help you I'll just end up angry
15:55:36 <davean> And I like being happy
15:56:34 <halogenandtoast> Yeah that's fair, I don't actually think this is a Yesod problem
15:56:47 <halogenandtoast> I think I'm just a bad.
15:57:54 <davean> halogenandtoast: of course, but I'd have to read the yesod docs
15:58:25 <halogenandtoast> I think the only Yesod part is lookupPostParam which is IO (Maybe Text)
15:59:03 <halogenandtoast> hashPasswordUsingPolicy is crom Crypto.BCrypt and is IO (Maybe ByteString)
15:59:20 <halogenandtoast> well HashingPolicy -> ByteString -> IO (Maybe ByteString)
15:59:39 <halogenandtoast> s/crom/from/
16:01:10 <halogenandtoast> Anyways, I'll do some more type-flailing later, time to record a podcast.
16:01:48 <Eduard_Munteanu> halogenandtoast, fmap digestPassword gives you a Maybe (IO ...)
16:02:10 <halogenandtoast> Eduard_Munteanu: yeah I tried removing the fmap
16:02:28 <halogenandtoast> Wich has less wrapping, but is still wrong
16:02:32 <Tuplanolla> You probably want to `mapM_` over the `Maybe` or `sequence_` the stack to transpose the monads, halogenandtoast.
16:02:46 <Eduard_Munteanu> Yup ^.
16:03:23 <Eduard_Munteanu> digest <- mapM (liftIO . digestPassword) password
16:04:08 <halogenandtoast> Hmm there's a new error, I'll have to check out the types and see what that's doing
16:04:12 <halogenandtoast> Thanks for the help all
16:04:36 <Eduard_Munteanu> You need the Traversable-based mapM
16:04:43 <halogenandtoast> I keep forgetting you can use things like mapM for things that aren't lists
16:05:40 <Tuplanolla> Another way to look at it is that the last `ByteString` in `HashingPolicy -> ByteString -> IO (Maybe ByteString)` is the point of four levels of functors, so you can `fmap` to it and `join` the result.
16:06:03 <Tuplanolla> Only for entertainment though.
16:06:19 <halogenandtoast> Alright have to get ready now, thanks everyone for the help, I'll reference this conversation and see if I can fix it a bit later.
16:10:27 <Tuplanolla> :t fmap . fmap . fmap . fmap :: Functor f => Functor g => (a -> b) -> (HashingPolicy -> ByteString -> f (g a)) -> (HashingPolicy -> ByteString -> f (g b)) -- It doesn't get better than this.
16:10:29 <lambdabot> (Functor g, Functor f) => (a -> b) -> (HashingPolicy -> ByteString -> f (g a)) -> HashingPolicy -> ByteString -> f (g b)
16:11:15 <Eduard_Munteanu> :t fmap `fmap` fmap `fmap` fmap `fmap` fmap
16:11:16 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f3 (f2 (f1 (f a))) -> f3 (f2 (f1 (f b)))
16:33:03 <actualHuman_452> Does anyone know of some sort of documentation/tutorial/written explanation for us mortals that might explain the Monad instance of (->) ?
16:33:47 <Zemyla> actualHuman_452: Okay, let's go through the types.
16:34:13 <Zemyla> return is type a -> m a. In this case, with m = (->) e, return :: a -> e -> a.
16:34:20 <Zemyla> What function do you know with type a -> e -> a?
16:34:54 <actualHuman_452> const?
16:34:59 <Zemyla> Yep.
16:35:26 <Zemyla> Then we have (>>=) :: m a -> (a -> m b) -> m b. It becomes (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b.
16:36:05 <Zemyla> Write a function that solves this.
16:38:29 <mniip> well that's the implementation
16:38:32 <mniip> the meaning though
16:39:59 <jmcarthur> This path may be easier: actualHuman_452, do you understand Reader?
16:40:59 <Zemyla> actualHuman_452: Okay, the meaning is that it provides an "environment" of type e. This environment is passed to every subcomputation in the monad.
16:42:59 <Zemyla> In a do block, you can fetch it with something like env <- id.
16:43:22 <actualHuman_452> Right, following
16:48:59 <Zemyla> That's basically all there is to it.
16:49:17 <Zemyla> It's an uncomplicated monad.
16:50:11 <monochrom> I think you should still try your hands at writing that function.
16:50:47 <monochrom> At present it is best to use the desired type to guide writing the code.
16:51:17 <monochrom> Afterwards, you can ponder on "what does this code mean?" and it will be valuable too.
16:51:36 <monochrom> But use the known certainty to solve the unknown uncertainty. Not the other way round.
16:51:47 <monochrom> At present the type is the known certainty.
16:53:10 <Zemyla> I mean, take a look at sequence for it.
16:53:17 <Zemyla> sequence :: [e -> a] -> e -> a.
16:53:34 <Zemyla> sequence :: [e -> a] -> e -> [a], rather.
16:53:43 <monochrom> Yeah, I was wondering :)
16:53:45 <Zemyla> :t \a b -> sequence a b
16:53:46 <lambdabot> Traversable t1 => t1 (t -> a) -> t -> t1 a
16:54:25 <actualHuman_452> So, this actually comes back to the problem that got me on this whole tack - bindF f y v = (y (f v) v)
16:54:46 <Zemyla> actualHuman_452: Precisely. See how v is used twice.
16:57:12 <monochrom> It is nice to visualize a function (of type K->V) to be a huge table of V's using K's for keys. Lookup table.
16:57:44 <monochrom> (and all lookups always succeed, all keys are present, unlike pilthy Data.Map and hash tables :) )
16:59:38 <monochrom> bindF f y (aka f >>= y) means: lookup in table f, then pass the answer to y to obtain yet another table, then lookup in that table. (I am deliberately hiding away "v". In all lookups, use v for the key throughout)
17:01:00 <monochrom> y is like two levels of tables.
17:05:53 <monochrom> No, better description of y: y is a dependent table --- which table you get depends on the first parameter you give.
17:06:14 <actualHuman_452> Ok, thanks folks - I think I mostly get it. At the very least, I now understand why/how the liftM(n) functions are super nice for composing a bunch of predicates
17:06:30 <monochrom> Ah yes
17:10:18 <actualHuman_452> So, (hopefully) final question -
17:12:12 <actualHuman_452> Where does "a" go, if (a->e) is like  (->) e ? Can type constructors be partially applied, or is the (a) just somehow implicit?
17:12:44 <monochrom> No, e->a is (->) e a
17:13:00 <actualHuman_452> Oh, right, because it's infix
17:13:37 <monochrom> And then, partially applied, (->) e
17:14:11 <monochrom> We absolutely want the partially applied (->)e in "instance Monad ((->)e) where"
17:15:52 <godfrey> hey there, anyone know about the IDE Haskell for Mac? How is it?
17:17:18 <monochrom> I have heard of it, I'm happy it exists, but I don't have a Mac, so I haven't tried.
17:17:30 <jle`> i've heard good things about it, but i always feel weird about the name
17:18:05 <monochrom> Last evening I ate a Big Mac.
17:18:07 <glguy> Just keep in mind that it's not a generic development environment, it's more of an interactive workbook a la iPython
17:20:40 <monochrom> Oh too bad, ircbrowse is still throwing libpq exceptions.
17:21:33 <monochrom> Should have sent kamyar down the well-intended path of buying a Mac so as to use Haskell for Mac.
17:25:10 <mniip> jle`, it's simple
17:25:14 <mniip> I never use scopedtyvars
17:25:39 <jle`> :o
17:26:40 <mniip> jle`, change that 'Proxy' into a 'proxy' (and get rid of the import) and I'd merge it
17:27:03 <fresheyeball> what the heck does intersectionWith do?
17:27:21 <monochrom> Whose intersectionWith?
17:27:29 <fresheyeball> Map
17:27:45 <jle`> mniip: i don't think it is possible
17:27:45 <mniip> iirc it lets you supply a combination functino
17:27:49 <fresheyeball> :t Data.Map.intersectionWith
17:27:50 <lambdabot> Ord k => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
17:27:56 <jle`> mniip: Proxy is used as a value there
17:27:59 <mniip> :t GHC.TypeLits.natVal
17:28:00 <lambdabot> GHC.TypeLits.KnownNat n => proxy n -> Integer
17:28:19 <mniip> finites = finitesProxy undefined
17:28:19 <jle`> :O
17:28:21 <monochrom> The a->b->c function manipulates the values.
17:28:22 <mniip> or
17:28:25 <jle`> was it always that way?
17:28:36 <mniip> finites = let result = ... natVal (head result) ... in result
17:28:58 <fXl> hello guys, how can we pretty print yaml to a file ? 
17:29:12 <jle`> huh i seem to remember natVal taking Proxy for some reason
17:29:15 <jle`> alright
17:29:20 <monochrom> When and only when (k,x) and (k,y) are in the two input maps, respectively, the output map has (k, f x y), where f is the a->b->c function.
17:29:21 <jle`> i know now what i must do
17:29:23 <lyxia> finites = finitesProxy []
17:29:29 <fresheyeball> :t (\f x y -> Data.Map.map f $ Data.Map.intersection x y)
17:29:31 <lambdabot> Ord k => (a -> b1) -> M.Map k a -> M.Map k b -> M.Map k b1
17:29:37 <mniip> lyxia, wrong
17:29:42 <lyxia> :(
17:29:51 <mniip> cannot unify [a] with proxy a
17:29:57 <lyxia> what
17:29:58 <mniip> er
17:30:05 <mniip> cannot unify [a] with proxy n, where n :: Nat
17:30:07 <fresheyeball> monochrom: ok that makes sensish
17:30:14 <lyxia> aah
17:30:42 <jle`> yeah the first thing i tried was Nothing
17:30:57 <jle`> i thought i was being clever
17:31:47 <monochrom> (\f x y -> Data.Map.map f $ Data.Map.intersection x y) is different. It ignores the values in the y map. It only cares that the keys are present at all.
17:31:47 <actualHuman_452> fresheyeball : sample usecase for Map.intersectionWith - You want to see the overlapping set of values in two maps where the keys are the same, but there is some condition by which you'd want values from one map instead of the other
17:32:16 <monochrom> Because that's what intersect does.
17:32:54 <fresheyeball> monochrom: oh no!
17:32:59 <fresheyeball> the keys just have to match
17:33:29 <fresheyeball> ok I got it now
17:33:31 <fresheyeball> thanks folks
17:34:26 <jle`> mniip: i feel slightly uneasy but, adjustments made
17:34:28 <jle`> how do you live like this
17:34:36 * jle` shudders
17:35:12 <mniip> oh you haven't seen the *stuff*
17:35:22 <monochrom> Eh? Living with general "proxy" is happier than living with specific Proxy.
17:36:19 * mniip tries to find an example of stuff
17:36:33 <jle`> monochrom: i mean, living without ScopedTypeVariables
17:37:03 <jle`> and not using Proxy when something expects general proxy :o
17:37:05 <monochrom> Ah. More proxies and fewer handwritten type sigs I guess.
17:37:07 <mniip> unfortunately I'm all out
17:40:40 <dopey_> is there a way to leave attributes of a dataType out of toJSON and fromJSON encoding/serialization?
17:40:53 <dopey_> w/out rewriting the implementations
17:41:12 <tathougies> is there a name for arrows without `arr`?
17:42:25 <mniip> Category?
17:43:16 <lyxia> There's still &&& and ***
17:43:16 <pacak> tathougies: Category + Profunctor
17:43:39 <tathougies> but profunctor let's me map arbitrary functions over the input and output
17:43:42 <tathougies> i don't want that
17:43:50 <tathougies> only functions that can be expressed in my arrow
17:43:52 <pacak> So does arrow
17:43:59 <tathougies> not without arr?
17:44:16 <mniip> I think they want a whatsitcalled
17:44:21 <tathougies> basically i want a strong profunctor without the profunctor bits :/
17:44:24 <mniip> no
17:44:31 <mniip> abelian category wasn't it
17:44:51 <tathougies> i think it might be a cartesian category?
17:44:59 <mniip> no, that's too strong
17:45:10 <tathougies> why?
17:45:18 <johnw> tathougies: what is it that you want to do?
17:45:21 <mniip> that involves coproducts too
17:45:42 <johnw> I thought only cocartesian or bicartesian involved coproducts
17:45:55 <johnw> just cartesian is category + products
17:46:13 <tathougies> johnw: i want arrow without arr. Then I could create a GADT for my primitive arrow operations, and ones for first, second, (&&&), and (***). This GADT would represent a computation and could be serialized
17:46:28 <johnw> tathougies: I ask because I might have sometheing better to offer you
17:46:39 <tathougies> @johnw :o what?
17:46:39 <lambdabot> Not enough privileges
17:46:51 <johnw> tathougies: what about lifting your computations to arbitrary categorical terms that can be serialized by instantiating them in a different target category
17:47:13 <johnw> all you'd need is as much categorical structure as your computation demains; from just composition, all the way up to bicartesian closed
17:47:19 <johnw> s/demains/demands
17:47:55 <jle`> tathougies: not sure why you "need" a typeclass
17:47:57 <johnw> for example, I recently used this approach to transport regular Haskell functions into Z3 solver equations -- without needing to "speak Z3"
17:48:02 <jle`> can't you just write your methods directly for your GADT?
17:48:11 <tathougies> jle` I don't want a type class, I just want the name of the thing so I can read more about it
17:48:16 <jle`> ah
17:48:23 <tathougies> i figure finding a type class would probably lead to a link to a paper
17:48:28 <tathougies> :D
17:48:36 <johnw> tathougies: http://conal.net/papers/compiling-to-categories/
17:48:52 <johnw> tathougies: if you have questions after reading that, find me; I'm using categories for lots of things recently
17:48:54 <tathougies> Ah this was a recent paper, right? I read it
17:49:04 <tathougies> let me re-read it with my problem in mind
18:00:24 <mniip> jle`, https://hackage.haskell.org/package/finite-typelits-0.1.2.0/docs/Data-Finite.html#v:finites
18:01:03 <jle`> :D
18:01:25 <jle`> i wasn't sure about the name either
18:01:36 <jle`> i suppose it could also have been called 'range' or something
18:03:16 <mniip> universe
18:03:17 <mniip> more like
18:04:27 <jle`> perhaps more fitting
18:04:30 <mniip> oh fun
18:04:35 <mniip> I have a reverse dependency \o
18:05:05 <jle`> i popped you into vector-unsized :3
18:05:08 <jle`> er, vector-sized
18:07:39 <tathougies> @johnw this looks great! Is this GHC plugin already available?
18:07:39 <lambdabot> Not enough privileges
18:08:51 <tathougies> woops. johnw: this looks great, is the ghc plugin already available?
18:14:13 <mniip> jle`, have you seen my tysystem extension proposal :o
18:14:33 <ezyang> anyone here know doctest and can tell me how the -package-db command line parsing is supposed to work 
18:18:27 <johnw> tathougies: yes, it works fine, please see the open issues though
18:18:36 <johnw> tathougies: I'd be happy to talk with you more about it after dinner, say in 3-4 hours
18:23:39 <jle`> mniip: i have not :o
18:23:52 <mniip> thread on ML
18:31:55 <tathougies> johnw: thanks . i'll ping you in a bit. thanks!
19:23:30 <mniip> hmm
19:23:53 <mniip> then (~>), (->) :: * ~> * ~> *
19:26:58 <ezyang> I'm writing newcomer tasks for Cabal. Here's one https://github.com/haskell/cabal/issues/4044 
21:10:34 <_sras_> Why is using generics better than template haskell?
21:10:52 <Koterpillar> _sras_: Is it?
21:11:32 <_sras_> Koterpillar: I am not sure. People seem to avoid TH, but does not seem to have a problem with generics.
21:12:58 <pacak> TH makes compiling stuff more troublesome.
21:13:13 <Koterpillar> TH breaks your module compilation into phases, so you can't refer to later symbols from earlier. And it is, after all, running arbitrary code at compile time.
21:13:44 <pacak> It makes compiling with profiling more fun.
21:13:49 <pacak> And crosscompilation.
21:14:21 <pacak> Generics on the other hand can slowdown compilation speed
21:14:26 <pacak> And produce crappy runtime performance
21:14:50 <pacak> So both are worse :)
21:16:13 <_sras_> Koterpillar: Regarding the compiling in phases, isn't it solved by placing TH calls at the bottom of the module?
21:16:44 <_sras_> pacak: Why does generics produce slower code?
21:16:46 <Koterpillar> yeah, but what if you want to actually use the generated definitions?
21:17:07 <pacak> _sras_: It relies on ghc being smart which is not always the case.
21:17:59 <pacak> I've seen examples when adding one more field reduced performance by about 2 orders of magnitue
21:20:23 <_sras_> Koterpillar: Yes. That can get tricky.  But I guess one can always split modules....
21:20:49 <pacak> _sras_: That won't solve profiling issue
21:21:34 <_sras_> pacak: What is the profiling issue?
21:21:54 <pacak> You'll have to compile module that defines TH code without profiling to get splices you can run and then with profiling to get something you can run
21:22:58 <pacak> p_o files and so on.
21:23:16 <pacak> And if your project is big - that's doubles compilation time
21:38:33 <johnw> tathougies: hi
21:47:58 <parsnip> i wanted a newer hledger on a VPS, so i tried to install with haskell-stack, but it was running out of space. i increased the size some, but still the same issue. maybe an issue with how some VPS do /tmp? 
21:52:26 <johnw> parsnip: have you tried Docker? I'd think that would be easier
21:52:51 <parsnip> johnw: might not have the weird /tmp issue? 
21:54:04 <johnw> and it's easier to throw away intermediate images
22:00:39 <Lokathor> i have a type that is trivially a DeepSeq instance, but i also don't want my library to depend on deepseq
22:00:45 <Lokathor> such a quandry
22:01:21 <MarcelineVQ> why not
22:02:05 <jhrcek> Anyone here got experience with lens-aeson? I want to do some quick data extraction from HAR (HTTP Archive = json format listing http communication between client and server).
22:02:13 <pacak> Lokathor: Isn't it bundled with ghc those days?
22:02:21 <Lokathor> pacak, maybe?
22:02:32 <jhrcek> I'd like to basically filter out aeson's Array to keep only some of its contests ..http://lpaste.net/354977
22:02:37 <Lokathor> MarcelineVQ, because having more dependencies is inherently bad compared to having less when possible :P
22:05:16 <MarcelineVQ> ah, hmm, if that's the case then you know what must be done
22:06:06 <Lokathor> i wish haskell had a better way to say "if they've got this typeclass, include this instance, but otherwise just forget about it"
22:06:10 <MarcelineVQ> but tangentially, inherent is one of those words I distrust a little more each time I see it
22:07:28 <Lokathor> "inherent" means "i can't explain it you gotta go with it"
22:17:29 <cocreature> Lokathor: can you do that with TH?
22:17:58 <Lokathor> cocreature, you can probably do it really clunkily with the CPP even
22:18:17 <cocreature> Lokathor: how do you check if an instance exists with CPP?
22:18:23 <Lokathor> but either way I want it to be a better supported thing than that
22:18:47 <Lokathor> cocreature, you can check a package's minimum version with CPP
22:19:24 <cocreature> right but then I need to check myself which version provides the instance
22:19:55 <Lokathor> no i'm suggesting that you check if the typclass you want to make an instance of exists within the build, and if it does you write your instance
22:20:17 <cocreature> oh ok
22:20:44 <Lokathor> eg, if they will use RandomGen, make this RNG thingy a RandomGen, but if not just keep going because you can use the type without that instance
22:20:49 <tathougies> johnw: hello!
22:21:11 <tathougies> if you're still around, i would appreciate some more info on the compilation to categories idea
22:21:35 <Lokathor> how does one specify to stack which build profile it should load into ghci?
22:22:26 <Lokathor> oops, nevermind
22:22:33 <johnw> tathougies: sure, I'm here
22:22:35 <Lokathor> (--main-is TARGET)
22:22:43 <johnw> tathougies: we can privmsg if you'd rather not occupy the channel
22:22:48 <tathougies> yah sounds good
22:23:31 <MarcelineVQ> Lokathor: you might not even need main-is, the TARGET syntax should be able to cover that by letting you select your stanza
22:23:47 <Lokathor> huh, main-is didn't seem to work
22:23:55 <Lokathor> i want to pick a benchmark named "pcgen-bench"
22:24:00 <Lokathor> but i don't know how :(
22:25:35 <MarcelineVQ> stack build --bench pcgen-bench  no good?
22:26:05 <Lokathor> that runs the benchmark, but i want to run ghci with the benchmark profile loaded in
22:26:41 <cocreature> stack ghci --bench pcgen-bench doesn’t work?
22:27:16 <Lokathor> says it's not found
22:27:36 <Lokathor> but it gives a help URL i guess
22:27:41 <Lokathor> let's check that i support
22:27:43 <Lokathor> su8ppose*
22:28:13 <Lokathor> oh, okay, "stack ghci --bench" is what it wanted
22:29:22 <MarcelineVQ> TARGET syntax explained here: https://docs.haskellstack.org/en/stable/build_command/#target-syntax
22:31:34 <Lokathor> yeah the answer is apparently "don't give a target you idiot"
22:32:44 <MarcelineVQ> hmm, depends if you want all your benches loaded or not
22:32:55 <Lokathor> aside, http://lpaste.net/354979 yay benchmarks also run now, and my type beats the standard type by about 2x-3x
22:33:14 <MarcelineVQ> is it uniform?
22:33:33 <Lokathor> is the RNG's output uniform?
22:33:57 <Lokathor> naw, it's always 4, https://xkcd.com/221/
22:33:58 <MarcelineVQ> yeah, though idk if that's a valid question
22:34:39 <Lokathor> well, I don't actually know much about RNGs, but there's this website here http://www.pcg-random.org/ by the professor who came up with it i guess
22:35:13 <Lokathor> and i was like "hey it's 1 struct and 1 function, I can do that in haskell", and then this is like the version 2 where i'm making it into its own reusable package instead of being mixed into other things
22:37:13 <MarcelineVQ> neat stuff
22:37:55 <Lokathor> now to do the unboxed version, which i can assume will be faster based on previous work
22:38:04 <Lokathor> but which doesn't run on 32 bit machines :P
22:39:13 <jle`> mniip: it's interesting. is it possible
22:40:25 <Lokathor> cocreature, http://lpaste.net/354980 like this
22:41:46 <Lokathor> i wish that GHC knew how to derive Read for Word#
22:42:26 <pacak> Lokathor: O_o
22:42:40 <Lokathor> pacak, ?
22:43:02 <pacak> Word# is unboxed, read returns boxed value
22:43:35 <Lokathor> yeah but it should be able to derive a Read for a value that as a Word# field and just do the unboxing in the process
22:44:03 <pacak> o_O
22:44:17 <Lokathor> https://github.com/Lokathor/galaxy-break/blob/master/lib/PCGen.hs#L177 it's not hard
22:45:19 <pacak> data PCGen = PCGen Word# Word#
22:45:27 <pacak> Why not data PCGen = PCGen !Word !Word ?
22:45:39 <Lokathor> because that's slower
22:45:56 <pacak> Do you have benchmarks?
22:46:01 <Lokathor> I do have that version as well, and it works on 32bit machines
22:46:26 <pacak> With optimizations recent ghc will unbox those values so code will be the same as you wrote
22:46:27 <Lokathor> I do not have benchmarks any more currently. I took some long ago when I wrote that file
22:46:48 <Lokathor> I'll get you some more benchmarks as soon as I get the unboxed version in order in the new project
22:47:48 <pacak> I'm pretty sure you can get exactly the same performance by doing strictness annotation
22:48:25 <Lokathor> welp, i'll get back to you in like 20 minutes on taht
22:49:17 <pacak> Try passing -O2 -ddump-simpl -ddump-stg -ddump-to-file and compare whatever ghc produces
22:49:44 <MarcelineVQ> are you sure you're not thinking of {- UNPACK -}
22:49:54 <Lokathor> i invite you to do that, but i wanna finish getting the unboxed version in place first :P
22:50:02 <jle`> Lokathor: it's the wrong kind, though
22:50:17 <jle`> read :: forall (a :: *). Read a => String -> a
22:50:58 <Lokathor> jle`, but it's not a Read for a Word#, it's a read for some type Foo that has a Word# in it, so it should try to read a Word, and then do the unpacking, and put that into the final Foo (which is of Kind *)
22:51:03 <MarcelineVQ> actually I guess since the first example didn't unpack it wouldn't matter for the second
22:52:58 <Lokathor> question: If you put an UNPACK on a Word64, but the machine isn't 64 bits, will it silently ignore it and use Word64 as a boxed value?
22:54:05 <pacak> It's been a while since I last time saw 32bit machine...
22:54:13 <Lokathor> raspberry pi is 32 bits
22:55:33 <opqdonut> Lokathor: if it can unpack !(Int,Int), it surely can unpack a Word64
22:55:41 <opqdonut> (see https://downloads.haskell.org/~ghc/7.0.3/docs/html/users_guide/pragmas.html)
22:57:17 <Lokathor> opqdonut, the issue is that a Word64 needs to still be 64 bits after unpacking, but unpacking makes it into a machine width word, but the machine's width is only 32 bits
22:57:37 <opqdonut> why does unpacking make it into one word?
22:57:46 <opqdonut> the docs don't say so
22:57:47 <pacak> Lokathor: unpacking of product types "inlines" them.
22:57:56 <opqdonut> yeah, think C structs
22:58:16 <Lokathor> well, let me back up then, a Word# is always the machine width in size
22:58:30 <Lokathor> i guess it doesn't specify that a Word64 unpacks into a Word# precisely
22:58:46 <pacak> Word64 will be unpacked into Word64#, no?
22:58:53 <Lokathor> there is no such type
22:59:38 <pacak> O_o
22:59:41 <pacak> data {-# CTYPE "HsWord64" #-} Word64 = W64# Word64#
22:59:44 <opqdonut> yeah that's what the haskell source looks like... but I would assume all Word# stuff is magic
22:59:58 <pacak> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Word.html
23:00:01 <opqdonut> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Word.html#Word64
23:00:13 <opqdonut> heh, that's changed :)
23:00:31 <opqdonut> oh, no, it isn't
23:00:35 <opqdonut> #if WORD_SIZE_IN_BITS < 64
23:00:39 <opqdonut> there's two definitions
23:00:40 <opqdonut> great!
23:10:21 <Lokathor> Word32# doesn't seem to be a type you can access
23:10:33 <Lokathor> it's not exported anywhere in GHC.Prim or similar, that I can see
23:14:01 <MarcelineVQ> GHC.Word
23:15:20 <MarcelineVQ> it has a W32# for Word32 but the Word# inside it will vary by arch I suppose
23:16:34 <MarcelineVQ> though maybe not, the dichotomy is mostly between 32 and 64, it's only in ghc source that I've seen concerns over units smaller than 32
23:17:38 <parsnip> out of space :( http://sprunge.us/ZaJA
23:18:40 <dmj`> parsnip: time to ditch stack for nix
23:20:15 <pacak> Stack was fixed some time ago to clean up stuff from /tmp
23:20:35 <pacak> Probably before nobody actually used stack to compile big projects.
23:21:20 <MarcelineVQ> further there's an option for finer control from 1.3.0 onwards, https://docs.haskellstack.org/en/stable/faq/#can-i-change-stacks-default-temporary-directory but the item downloaded fine and failed on extraction idk if it'll help
23:21:46 <parsnip> using stack version 1.4.0
23:22:30 <dmj`> parsnip: the nix store is large it won’t run out of space this easily. All builds are isolated as well, obviated the need for containers
23:22:38 <Lokathor> wordify (a,b) = (fromIntegral a :: Word, b)
23:22:41 <dmj`> obviating*
23:22:42 <Lokathor> i make all the best functions
23:24:02 <MarcelineVQ> then he unpacked all the tuples and shouted to the sky, finally I am a haskell lib author
23:24:29 <dmj`> Lokathor: cabal upload wordify
23:24:55 <Lokathor> MarcelineVQ, oh i see, GHC.Word is in base but it has a flag to not be documented :P
23:25:32 <MarcelineVQ> ye anything on that module list is reachable, things that aren't don't get listed, mm afaik
23:26:26 <Lokathor> {-# OPTIONS_HADDOCK hide #-}
23:27:01 <MarcelineVQ> that's sneaky-speak for "why are you using this module?"
23:27:29 <MarcelineVQ> just like GHC.Arr
23:28:41 <Lokathor> https://youtu.be/jdbBS9rK5XI?t=20s
23:31:45 <Lokathor> oh no!
23:31:49 <Lokathor> I am made the fool!
23:32:21 <Lokathor> without UNPACK the unboxed version is faster, but when you add UNPACK to the boxed version it's faster
23:32:38 <Lokathor> very close though either way
23:33:39 <pacak> Lokathor: Benchmarking is hard, ghc should generate exactly the same code.
23:34:14 <pacak> Plus you don't even need UNPACK - recent ghc contains -funbox-small-strict-fields which is on by default
23:34:22 <Lokathor> ah, hmm, i guess they're so close that different runs make them float above and below each other
23:35:27 <pacak> clean up your code, allow ghc to do it's thing.
23:35:35 <MarcelineVQ> you don't have to guess :> you can compare core
23:36:17 <Lokathor> pacak, incorrect on the "you don't need UNPACK front", there is a repeatable difference of more than 10% if you leave out the UNPACK
23:36:35 <pacak> (13:48:55) pacak: Try passing -O2 -ddump-simpl -ddump-stg -ddump-to-file and compare whatever ghc produces
23:36:46 <Lokathor> ~58ms without unpack, and ~40-45 with unpack
23:36:47 <Lokathor> okay
23:36:56 <Lokathor> ...how do i pass that through stack?
23:37:02 <Lokathor> i'll jsut add it to cabal
23:37:20 <pacak> {-# OPTIONS ....
23:37:23 <pacak> on top of your file
23:38:02 <Lokathor> alright okay
23:38:35 <MarcelineVQ> I prefer -ddump-prep is there a reason to prefer simpl? you might also want some of the -dsuppress-* flags
23:39:06 <Lokathor> okay but
23:39:12 <Lokathor> i'm not seeing where it dumped it to
23:39:33 <pacak> Lokathor: Should be right next to object  file
23:39:51 <Lokathor> Bench.dump-hi ?
23:40:02 <pacak> Bench.dump-simpl
23:40:22 <Lokathor> only have a dump-hi
23:40:33 <pacak> Oh noes!
23:41:05 <Lokathor> should i lpaste that anyway?
23:41:18 <pacak> dump-hi? No, it's interface stuff
23:41:51 <Lokathor> oh, okay
23:41:51 <Lokathor> so
23:42:02 <Lokathor> it only works for executables?
23:42:13 <Lokathor> i just changed the benchmark type to executable type and now it works
23:43:29 <MarcelineVQ> it wortks for other things, but it's possible there might be some nonsense in getting it to work right for bench's and tests with stack
23:44:51 <Lokathor> packed, http://lpaste.net/354981  and unpacked, http://lpaste.net/354982
23:45:03 <Lokathor> i have no idea what any of this means
23:46:49 <pacak> http://stackoverflow.com/questions/6121146/reading-ghc-core 
23:48:00 <Lokathor> you're the one who wanted to read the core and see that it was the same no matter what or whatever
23:48:03 <MarcelineVQ> you probably want to try all of the -dsuppress-* flags except for -all and -unfoldings and maybe -uniques as well to keep things readable, ymmv
23:48:16 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flags.html#compiler-debugging-options
23:48:32 <pacak> Right. I'm looking at those files side by side and except for variable names there's no difference.
23:49:15 <Lokathor> well then it's alignment in memory or something, i dunno, i just know what the benchmark says
23:50:32 <Lokathor> the unboxed version runs faster than the boxed and unpacked version most of the time though, so oh well
23:50:56 <pacak> Core is the same => in memory representation and all operations are the same.
23:51:32 <pacak>  Boxed version with strictness annotation is more maintainable.
23:52:02 <pacak> Doing low level stuff you not 100% understand can result in fun process of bughunting.
23:52:38 <pacak> Lower level is - more extreme fun can be.
23:52:55 <pacak> But feel free to ignore whatever I'm saying.
23:55:29 <Lokathor> regardless of if the version with or without the UNPACK pragma runs the same
23:55:38 <Lokathor> the unboxed version using primops runs faster
23:56:23 <jchia> Sometimes when I define an 'inner' function with a let inside an 'outer' function, and I give the 'inner' function a type signature, GHC complains "Couldn't match type ..." but when I remove the signature, the problem goes away. I don't think the signature is wrong because if I move the inner function with its signature out, the problem also goes away. Why is that?
23:56:30 <jchia> I don't have a simple example right now, though.
23:56:55 <Lokathor> jchia, can you give an example?
23:57:08 <pacak> jchia: ScopedTypeVariables?
23:57:09 <MarcelineVQ> the type variables aren't the same variable without ScopedTypeVariables on
23:57:11 <Koterpillar> jchia: monomorphism restriction?
23:58:54 <Lokathor> i should have read the last line
23:59:01 <jchia> I have a big example in a project. Let me see if I I can distill it.
23:59:28 <Lokathor> well you can just give the entire file as an lpaste if you want, and include the error
23:59:53 <Lokathor> assuming it's like, less than a billion lines
