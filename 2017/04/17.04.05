00:00:08 <jle`> it has 18 methods
00:02:54 <jle`> if your type implements sqrt then it also has to implement hyperbolic arctangent
00:03:08 <cocreature> jle`: well how do you split them up reasonably?
00:03:25 <jle`> there is no good answer
00:03:27 <jle`> ;_;
00:03:31 <cocreature> 12 of those 18 methods are just the trygonometric functions so these belong in one class
00:04:18 <cocreature> I guess you can argue that exp, log, sqrt, (**), logBase could go in a separate class
00:04:33 <cocreature> but I’m not sure if that would actually enable more instances
00:06:15 <jle`> i don't think it would, that i know of
00:06:30 <jle`> but i was just speaking from the perspective of the burden of writing the instances
00:08:23 <cocreature> fair enough
00:08:32 <cocreature> hm, I don’t think I’ve ever written an instance of Floating
00:11:14 <jle`> Floating is similar to Num/Fractinal in that all its methods are '-> a'
00:11:20 <jle`> er, '.. -> a'
00:11:40 <jle`> so it can be implemented for all Applicatives using pure/fmap/liftA2/etc.
00:25:00 <glguy> jle`: still up?
00:25:17 <jle`> i am
00:25:34 <lpaste> glguy annotated “some generics” with “some progress” at http://lpaste.net/354316#a354320
00:26:26 <glguy> I need to do the logic to curry/uncurry those V n a -> a operations still
00:26:29 <jle`> well, if it compiles, then let's ship it
00:26:41 <jle`> oh i see
00:27:12 <glguy> and I'm reproducing some of the machinery that Data.Functor.Rep gives you
00:27:37 <glguy> I think that these types might change too much for that to work out directly
00:27:41 <glguy> but it feels quite related
00:29:22 <jle`> where is Data.FUnctor.Rep ?
00:29:45 <glguy> http://hackage.haskell.org/package/adjunctions-4.3/docs/Data-Functor-Rep.html#t:Representable
00:31:07 <glguy> Instead of : tabulate :: (Rep f -> a) -> f a
00:31:28 <glguy> I want tabulate' :: (Rep x a -> a) -> x
00:31:45 <glguy> index :: f a -> Rep f -> a  --->    index' :: x -> Rep x a -> a
00:32:31 <glguy> correction: I want tabulate' :: (forall a. Rep x a -> a) -> x
00:33:45 <jle`> ah hm
00:39:47 <jasondockers> Any suggestions on how to set up a Haskell environment on Windows? 
00:41:55 <Gurkenglas_> jasondockers, https://docs.haskellstack.org/en/stable/README/
00:42:49 <jasondockers> Gurkenglas_, thanks. I actually didn't know about that site.
00:52:09 <Aruro> jasondockers: do u have possibility to install linux?
00:53:43 <jasondockers> Aruro, I'd rather not. I would have to run a VM which is significantly slower than using the host operating system (windows 10)
00:54:02 <jasondockers> though I thought windows 10 could execute elf files?
00:54:30 <Aruro> jasondockers: most haskellers are on linux, just saying
00:54:57 <jasondockers> given the support for other operating systems, I'm not surprised
00:55:08 <jasondockers> but I'm not using it seriously, so less than perfect support should be alright
00:58:10 <jasondockers> the language syntax in the REPL is the same as when compiling it, right? I could have sworn I read that the syntax is slightly different, which seems odd to me 
00:58:22 <Aruro> same
00:58:27 <Aruro> in ghc 8
00:58:40 <Aruro> had some mandatory let statements before, not anymore
00:59:01 <glguy> That's not to say that you can paste a .hs file line by line into GHCi and expect it to work
00:59:31 <jasondockers> okay, thanks. 
00:59:50 <Aruro> jasondockers: you should load file in ghci, ghci MyWindowsHopes.hs
01:00:04 <Aruro> or with :l command
01:00:10 <jasondockers> alright
01:00:43 <jasondockers> okay, for the time being I'll just run from the command line and edit with visual studio code. heh
01:01:31 <Aruro> some editors have haskell syntax coloring
01:02:34 <Aruro> maybe even notepad++
01:04:56 <jasondockers> visual studio code has syntax highlighting support and it is apparently aware of the compiler with an extension
01:05:11 <jasondockers> visual studio code != visual studio
01:05:24 <Aruro> nice nice
01:08:48 <glguy> jle`: *Derive> genericOpN @Num @('S ('S 'Z)) (+) (1,2.3) (4,5.6) -- (5,7.8999999999999995)
01:09:24 <jle`> glguy: nice :O
01:09:36 <jasondockers> Aruro, https://marketplace.visualstudio.com/items?itemName=UCL.haskelly
01:10:49 <lpaste> glguy annotated “some generics” with “more curry” at http://lpaste.net/354316#a354321
01:11:37 <Disavowed> Evening all. Likely another stupid question: is there a way to view the source for a function from within ghci? Something similar to Clojure's (source <function_name>), if anyone is familiar.
01:11:52 <Aruro> jasondockers: actually pretty much same ide support at on linux, very nice
01:11:58 <Aruro> as*
01:12:23 <glguy> Disavowed: There is not.
01:12:27 <Aruro> Disavowed: not, haskell does not like looking.
01:12:33 <Aruro> sadly.
01:12:51 <glguy> Source code is typically linked in the generated haddock documentation, however
01:13:06 <Aruro> @source map
01:13:07 <lambdabot> Unknown command, try @list
01:13:29 <Aruro> @list
01:13:29 <lambdabot> What module?  Try @listmodules for some ideas.
01:13:53 <Aruro> uhh, there is some simplistic source command in lambdabot
01:14:10 <Disavowed> Aruro: I believe you! Thank you for trying. 
01:14:17 <Disavowed> glguy: TIL Haddock. Thank you
01:14:21 <kadoban> @src print
01:14:22 <lambdabot> print x = putStrLn (show x)
01:14:26 <Aruro> there^
01:14:33 <Disavowed> Ah nice! 
01:14:38 <Aruro> @src foldr
01:14:38 <lambdabot> foldr f z []     = z
01:14:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:14:48 <kadoban> lambdabot's @src command is pretty crappy though honestly. It just reads from a custom text file, so it's both missing a ton and full of lies
01:14:57 <Aruro> true
01:15:04 <Aruro> but would be nice to have it in ghci
01:15:27 <Aruro> especially for beginners
01:15:42 <jasondockers> maybe you should get rid of it if it has the potential to be misleading
01:16:22 <glguy> It's useful for explaining how simple operations work
01:16:50 <Phyx-> 08:51:47 < Aruro> jasondockers: do u have possibility to install linux? <--  I wish people would stop with this useless arrogant pointless advice
01:17:20 <Aruro> Phyx-: what is arogant? that i want him to use free things people actually contribute to?
01:17:26 <Aruro> or that u want to sell stuff?
01:17:30 <glguy> Right? Obviously the answer is a mac
01:17:37 <kadoban> It's not useless or arrogant. A VM is a valid solution. The linux/unix/whatever tooling for haskell seems to be much better tested and well used.
01:17:58 <kadoban> It's not language wars nonsense, typically, it usually appears to be an attempt at practical advice.
01:18:03 <jasondockers> I would use Linux based on advice from Aruro and others if it were in a professional setting. but it's just for recreation.
01:18:06 <kadoban> er OS wars nonsense I meant
01:18:34 <brynedwardz> I'm on Windows 10 at work and do all my development through an Arch Linux guest vm
01:18:35 <jasondockers> I use every mainstream OS :) -- they are all terrible in unique ways
01:18:39 <brynedwardz> ^
01:19:12 <Phyx-> brynedwardz: that's great for you. But if someone asks how to set up haskell on Windows, answer the question for windows or don't answer
01:19:22 <brynedwardz> Phyx-: Of course!
01:19:28 <Phyx-> "install linux" is dismissive of all those who work on improving haskell on Windows
01:19:39 <brynedwardz> I agree, to each their own
01:19:51 <kadoban> Phyx-: Now who's arrogant? Nobody can answer except the way you want them to?
01:20:04 <Phyx-> if you have a specific complaint about the tooling on Windows, report it. don't passively aggresively say install another OS
01:21:18 <jasondockers> kadoban, this new place I work at actually lets you use any OS and any language (decided at the beginning of a new project) based upon what fits the best for the given problem. assuming the learning curve isn't absurd for those involved. it's kind of nice.
01:22:01 <kadoban> jasondockers: That does sound like a nice policy. I've been stuck in ... weird combinations of tools before because of IT rules :-/
01:22:21 <jasondockers> kadoban, well, we have to use different computers to read our emails :)
01:23:17 <kadoban> Heh, different from the dev machines? I guess that's reasonableish
01:23:28 <jasondockers> yes
01:23:35 <Aruro> Phyx-: there is nothing wrong with trying to convert people to open world. its your right to defend tooling on windows. nobody is against haskell on windows.
01:29:17 <stphrolland> merijn: i'm blocking on the last part of your execrise on MyStateT. I don't succeed to write the (>>=) operator. I find no way to escape from the m monad. I find ways to have some sort of m(MyState s m b) stuff. But I find no way to only have MyStateT. On Hoogle there's something interesting: sequence :: (Traversable t, Monad m) => t (m a) -> m (t a), that would invert the encapsulation order between t and m...  
01:29:24 <stphrolland> but that would need to bring the constraint Traversable, which I think is not the aim of the exercise. 
01:29:33 <stphrolland> Do you have any clue or indication of what I must search so has to complete the exercise on writing the bind operator for MyStateT, where is the trick ?
01:30:18 <merijn> stphrolland: Can you lpaste what you have so far?
01:30:43 <stphrolland> yep
01:32:46 <stphrolland> http://lpaste.net/354324
01:33:29 <stphrolland> I wanted to have inspiration from the (<*>) implementation, but nothing sparkles
01:33:40 <merijn> stphrolland: btw, you can simplify your version of modify :)
01:34:00 <stphrolland> merijn: with bind ?
01:34:11 <merijn> bind and/or fmap :) "fmap f get >>= put"
01:34:17 <merijn> The let is kinda redundant
01:34:35 <merijn> You could also write "newVal <- f <$> get; put newVal"
01:35:08 <merijn> stphrolland: You also shouldn't have to qualify the 'return' on line 13/16
01:35:18 <merijn> just "return" instead of Control.Monad.return
01:35:49 <stphrolland> I think it was in reaction to the compiler, but I will try it again without
01:36:35 <merijn> stphrolland: You could also simplify the Functor, I think
01:37:15 <stphrolland> okay, I will search for a short version
01:37:58 <lpaste> merijn pasted “Simplified” at http://lpaste.net/354325
01:38:18 <merijn> It's basically the same, but avoids introducing a lot of names with one use
01:38:29 <osa1> anyone know a portable fork() in some library? I have a GUI app and I want to fork it on startup to be able to detach it from the running shell
01:38:53 <merijn> osa1: Define portable
01:39:02 <merijn> osa1: POSIX?
01:39:08 <osa1> merijn: that's portable enough
01:39:12 <osa1> well
01:39:15 <osa1> fork() is already POSIX, right?
01:39:25 <osa1> so maybe I should just fork()
01:39:45 <osa1> I can't even find a wrapper though
01:39:54 <stphrolland> merijn: yes, I clearly prefer your shorter version with <$>
01:40:01 <merijn> osa1: System.Posix.Process in unix?
01:40:28 <merijn> stphrolland: Pretty sure you can similarly simplify your <*> (honestly, I can't read it well enough to check at the moment ;))
01:40:58 <stphrolland> merijn: understood, but it helped me decompose the problem in steps, each steps a change of type needed for the result
01:41:22 <osa1> merijn: thanks
01:41:45 <merijn> stphrolland: Sure, I write plenty of messy code like that, but I recommend seeing if you can simplify after getting it working, by just refactoring little bits at a time
01:42:43 <stphrolland> okay, anyway the <*> is based on the use of Control.Monad.ap so as to have the (a->b) function operate on the inside of the MyState m s a to be transformed
01:42:55 <merijn> stphrolland: i.e. my version of functor was basically: 1) replace fmap with <$> in mbs 2) inline mas into mbs 3) inline mbs into fsMbs 4) inline fsMbs into line 27 using a lambda :)
01:43:14 <stphrolland> okay, i clean the code and repaste it
01:45:34 <merijn> stphrolland: Ok, so first hint: Suppose we replace the result of line 61 with: "= MyStateT $ \s -> do" which Monad is the do block working in?
01:46:51 <stphrolland> m
01:48:14 <jasondockers> is standard ML far different from Haskell's syntax to a beginner? 
01:48:48 <merijn> stphrolland: Right, and what's the type of fsMas? :)
01:49:28 <merijn> jasondockers: It is rather different, yes. You could probably *read* Haskell reasonably easily, but don't expect to write it as easily :)
01:49:28 <stphrolland> MyStateT s m a
01:49:36 <merijn> stphrolland: Ah, is it?
01:49:42 <jasondockers> merijn, okay. 
01:49:54 <stphrolland> no it's pattern matched sorry
01:50:01 <merijn> jasondockers: So you already know ML?
01:50:08 <jasondockers> merijn, more or less
01:50:10 <merijn> @where tutorial
01:50:10 <lambdabot> http://www.haskell.org/tutorial/
01:50:14 <stphrolland> s -> m(a,s)
01:51:00 <merijn> jasondockers: The Gentle Intro (not commonly thought of as gentle :p) was written when most people came from (S)ML, so it explains Haskell via comparison to ML. So it's probably a better starting point than the "Haskell from imperative" books
01:51:17 <jasondockers> okay
01:51:37 <merijn> stphrolland: Right, so if you think about about the two types you just named, can you figure out how you might fit those together? :)
01:51:43 <jasondockers> I just need to learn enough to translate SML into less-than-passable Haskell for the moment :) 
01:51:51 <jasondockers> merijn, thanks
01:52:02 <jasondockers> I learned some haskell a while ago but forgot all of it
01:52:25 <jasondockers> then I found SML to be a nicer language, but it's kind of a toy
01:52:28 <jasondockers> imho
01:52:36 <jasondockers> not nicer, but easier
01:52:42 <stphrolland> my first thought is to write MyStateT $ \s -> do a <- fsMas 
01:52:51 <stphrolland> I have to play a bit with the idea
01:53:16 <merijn> stphrolland: Well, fsMas is a function, so you need to apply it to something to get an 'm' you can use with do notation
01:53:31 <stphrolland> the s
01:53:46 <stphrolland> it was a typo: MyStateT $ \s -> do a <- fsMas s
01:53:58 <stphrolland> but it is still improsoned in m ?
01:54:02 <merijn> jasondockers: Well, Haskell has grown a bit crufty over time, so I'd say it's probably less elegant than SML, but SML hardly has real world libraries. Ocaml is more practical, but not any less crufty than Haskell and awful syntax :)
01:54:16 <merijn> stphrolland: Well, remember this:
01:54:32 <merijn> @undo do { a <- fsMas s; foo a }
01:54:32 <lambdabot> fsMas s >>= \ a -> foo a
01:54:40 <merijn> :t (>>=)
01:54:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:55:03 <jasondockers> merijn, I still wish my pseudo language I write on paper and use on whiteboards actually compiled. the nice thing about it is that the syntax changes to suite the given problem as I personally find intuitive :p
01:55:14 <Athas> jasondockers: Coq can do that!
01:55:42 <Athas> merijn: I find some parts of SML, like equality types, much more nasty than anything in Haskell.
01:55:57 <Athas> Haskell 2010 isn't really less elegant than SML I think, but full Glasgow Haskell clearly is.
01:56:21 <merijn> stphrolland: So, if you can somehow turn faMSsb from 'a -> MyStateT s m b' into 'a -> m ?', you can use >>= to get 'a' "out" of the 'm' :)
01:56:46 <jasondockers> was haskell invented in scotland? 
01:56:58 <stphrolland> yep, but inside the do only
01:57:01 <merijn> Athas: Haskell2010 is still a bit messy, Num hierarchy stays a bit ugly, the Prelude is a bit dated nowadays
01:57:43 <stphrolland> if I apply it the function a -> MyStateT m s b, my result will still be inside the m monad of the do notation ? 
01:57:56 <merijn> stphrolland: Well the entire 'do' block will result in some 'm ?', so, can you somehow turn a 'm ?' into 'MyStateT s m ?' :)
01:58:30 <stphrolland> and then use join ?
01:58:38 <merijn> stphrolland: Yes, so you need to get rid of that MyStateT for a bit and later rewrap the entire 'm' block back into MyStateT
01:58:59 <merijn> stphrolland: You mean use join on "MyStateT s m (MyStateT s m b)"? 
01:59:16 <stphrolland> yep, so as to reduce two levels of the monad
01:59:18 <Athas> merijn: it's elegant, just not very practical.
01:59:22 <Athas> And SML is worse in that regard.
01:59:26 <merijn> stphrolland: Sadly, no, since 'join' is implemented using >>= :)
01:59:35 <stphrolland> ha...
01:59:44 <merijn> stphrolland: You can use 'join' on 'm' (I don't remember whether that's needed, though)
02:00:07 <stphrolland> well I will play with your indication a moment, I come back after exploring the thing
02:00:28 <merijn> stphrolland: You might be able to make things less messy by changing the datatype to "data MyStateT s m a = MyStateT { runMyStateT :: s -> m (a, s) }"
02:01:08 <merijn> stphrolland: That gives you "runMyStateT :: MyStateT s m a -> (s -> m (a, s))", which makes unwrapping less of a hassle (you can avoid having to introduce pattern matches
02:01:22 <stphrolland> clearly
02:01:52 <merijn> stphrolland: Also, syntax note: you can define operators using infix notation which looks (completely biased personal opinion) better
02:02:09 <merijn> So '(<*>) (MyStateT fsMfabs) (MyStateT fsMas) = MyStateT $ fsMbs' can also be written:
02:02:25 <merijn> 'MyStateT fsMfabs <*> MyStateT fsMas = MyStateT fsMbs"
02:02:51 <stphrolland> less parenthesis... :-°
02:04:02 <merijn> And similarly "MyStateT fsMas >>= faMSsb = "
02:20:16 <merijn> GHC8 (or at least, hdevtools using GHC8) seems *a lot* slower than it was with 7.10
02:20:27 <jophish_> Is it possible that -XTypeFamilies could cause my code to not typecheck
02:20:56 <jophish_> well, it's happening :)
02:22:15 <merijn> Any alternatives for hdevtools with decent vim support that are faster?
02:22:38 <cocreature> jophish_: type families implics things like MonoLocalBinds iirc so it definitely seems possible
02:22:42 <cocreature> *implies
02:24:08 <jophish_> merijn: I've been using hdevtools with neovim without an issue fwiw
02:24:23 <jophish_> I've found ghc-mod to be much slower, and can't seem to find any alternatives 
02:24:25 <merijn> jophish_: Takes about a second or so to typecheck a file or report a type
02:24:43 <MarcelineVQ> ghc-mod is pretty slow when combined with stack, for me at least
02:24:55 <merijn> Even though I have hdevtools options set to "-O0 -fno-code" which used to be blazing fast before
02:25:53 <jophish_> merijn: how are you using it, hdevtools does like recompiling everything from scratch if the options change
02:26:05 <jophish_> is it still as slow when you run it from the terminal
02:26:12 <jophish_> (after the first run)
02:26:23 <merijn> I'm just using vim-hdevtools and syntastic
02:26:24 <jophish_> cocreature: that would make a lot of sense, thanks!
02:27:01 <brynedwards> This does async syntax checking for neovim and vim 8 https://github.com/w0rp/ale
02:27:09 <cocreature> jophish_: tbh I’ve never thought about why TypeFamilies has to imply MonoLocalBinds
02:27:09 <merijn> jophish_: I'm not changing options in my cabal file or anything, just editing files and saving them with syntastic running on every file safe and vimhdevtools running it to query a type
02:27:13 <jophish_> hmm, NoMonoLocalBinds didn't fix things
02:27:20 <jophish_> I suppose I could just add a signature
02:27:34 <merijn> jophish_: It's pretty instant from the terminal
02:27:43 <cocreature> I’m not sure if you can just overwrite this. there is probably a reason why TypeFamilies turns that extension on
02:27:46 <jophish_> merijn: one sec, I think I know what it is
02:27:54 <merijn> jophish_: Oh, no
02:28:05 <merijn> In the terminal it's also slow if I save between runs
02:28:28 <jophish_> yeah, I know, trying to find the issue
02:28:57 <jophish_> https://github.com/hdevtools/hdevtools/issues/33
02:29:07 <jophish_> I bet that vim saving is passing an absolute path 
02:29:56 <merijn> jophish_: That doesn't explain why it's always slow after a save
02:30:01 <jophish_> to debug this I used something like `#!/usr/bin/env bash; echo "hdevtools called with: $@" >> some-log`
02:30:23 <merijn> jophish_: if saving uses an absolute path I would still expect it to be fast...
02:30:31 <jophish_> merijn: probably because when you save, syntastic is calling hdevtools with /home/merijn/file.hs
02:30:33 <merijn> Because it's not alternating
02:30:55 <merijn> jophish_: So? That issue says if you *switch* but if syntastic always uses full path that doesn't switch
02:30:55 <jophish_> hmm, you've got a point
02:31:24 <jophish_> sorry, I send my penultimate message before reading your preceding one
02:32:49 <merijn> Almost seems like it's reconfiguring cabal every run or something
02:33:31 <jophish_> might still be worth logging the calls to hdevtools, I don't know how syntastic works and it could be doing something fishy
02:34:04 <jophish_> is it slow if you call it from the cli and just `echo ' ' >> File.hs` between hdevtools runs
02:35:08 <merijn> jophish_: Except hdevtools is *also* slow if I run it from the CLI if I save the file in between
02:35:53 <jophish_> are you running it on the cli with the same arguments syntastic uses?
02:37:01 <merijn> Yes, but even without it's slow on every save
02:37:15 <jophish_> hmm, and reloading in ghci is fast?
02:37:20 <merijn> And I'm sure it wasn't when I was using GHC7.10
02:37:31 <merijn> And the old version of hdevtools I had
02:38:45 <merijn> GHCI is faster than hdevtools when reloading although still a bit slow
02:39:02 <bennofs> merijn: I think hdevtools reloads too much, it clears the package db stack in between or somehting like that
02:39:18 <merijn> bennofs: I'm not using stack
02:39:38 <merijn> bennofs: But I think it's reconfiguring cabal or something on every run or something silly like that
02:39:55 <bennofs> merijn: i did not mean stack, I meant package-db stack as used in GC
02:39:57 <bennofs> s/GC/GHC
02:41:34 <merijn> bennofs: It just seems odd I'm the only person to notice this/there's no issue yet? Because it's making hdevtools borderline unusable
02:42:02 <bennofs> merijn: i didn't know that many people use hdevtools?
02:42:51 <vaibhavsagar> I <3 hdevtools
02:43:01 <merijn> bennofs: Well, the only alternative I'm aware of is ghc-mod, which is 10fold slower and this intero business, but that seems to have no support outside stack/emacs?
02:43:15 <bennofs> why does there need to be ghc-mod., intero and hdevtools :/
02:43:27 <merijn> bennofs: Well what else?
02:44:00 <bennofs> merijn: oh why is ghc-mod so much slower? perhaps that a problem with the vim backend, because it supports persistent server mode nowadays as well
02:44:16 <MarcelineVQ> intero is quite different, it leverages ghci in an interesting, way in fact ghci has commands in it now for editor integration that are quite interesting, and some more coming in the next ghc release iirc
02:44:19 <merijn> bennofs: I haven't used ghc-mod in a while, tbh, so maybe they solved that
02:44:47 <bennofs> MarcelineVQ: yeah well it uses a fork of ghci that adds some commands
02:44:58 <merijn> MarcelineVQ: Yes, I know it's based on the ghcid stuff to avoid this "tool hardbuild against GHC" issue
02:45:25 <bennofs> i don't think it has any connections with ghcid
02:45:46 <bennofs> in fact, I think it hardbuilds a different version of the backend for each project (stack snapshot) depending on ghc version
02:45:57 <merijn> bennofs: I'm just annoyed by the fact that there's been an order of magnitude regression in speed that makes a for me important tool basically unusable :\
02:46:25 <bennofs> merijn: it's probably fixed some other issue though
02:46:40 <bennofs> merijn: iirc, you can make the GHC API fast but sometimes incorrect or slow but without stale caches
02:46:52 <MarcelineVQ> bennofs: possibly merijn meant ghci-ng rather than ghcid, or both
02:46:54 <merijn> I like iteratively filling in typed holes, if I need to wait 2 seconds at every refinement that slows me down A LOT
02:47:02 <merijn> MarcelineVQ: oh, yes ghci-ng
02:47:15 <bennofs> merijn: also, have you changed your GHC version in between?
02:47:45 <merijn> bennofs: I moved from 7.10 to 8, which is the only reason I touched it in the first place
02:48:24 <bennofs> merijn: GHC 8 may be slower. Another reason could be, though not sure if they've changed it, but I remember hdevtools having problems when you run 'cabal configure' after adding deps, it would still pickup the old ones or something like that (if they changed it, then perhaps that check is costing perf?)
02:48:31 <merijn> bennofs: That's the problem, the regression could be anywhere and it's impossible to troubleshoot
02:49:21 <bennofs> merijn: do you know when you've last used the well-perfoming hdevtools=?
02:51:00 <merijn> bennofs: I'm using "-O0 -fno-code", my project is less than 1k lines and the file I'm working on is only 200 lines. So I refuse to believe GHC8 takes over a second to typecheck that
02:51:09 <bennofs> merijn: https://github.com/hdevtools/hdevtools/commit/1d21b8d225183c6654a93ae2901f60009d91bbc6 looks like it may cause something like this
02:51:28 <bennofs> perhaps it disables -fno-code or something
02:52:04 <bennofs> merijn: is needsTemplateHaskell graph true for your project?
02:53:13 <merijn> no true, but I had one file with TemplateHaskell enabled (oversight, since I wasn't using it) so let's see if that helps
02:54:10 <merijn> ok, now querying the type is near instant
02:54:50 <merijn> I think I might still be suffering the issue jophish_ Pointed out
02:55:09 <bennofs> merijn: I think TemplateHaskell forces disabling of -fno-code
02:55:12 <merijn> If I only safe it's fast, if I only query types it's fast, but alternating is slow
02:55:20 <merijn> s/safe/save
02:55:37 <merijn> So I suspect they use differing relative/absolute paths
02:56:22 <bennofs> merijn: there may be something else here
02:56:38 <bennofs> merijn: perhaps GHC mod uses some differing flags for query type/type checking
02:56:47 <bennofs> forcing cache invalidation when switching
02:57:02 <merijn> bennofs: no, both have the exact flag setup for hdevtools
02:57:30 <bennofs> merijn: but hdevtools changes GHC.log_action for example
02:58:25 <merijn> bennofs: I don't understand what you mean?
02:59:22 <bennofs> merijn: hdevtools may use different DynFlags for check/query, thus invalidating GHC's cache 
02:59:31 <bennofs> merijn: that would be a problem with hdevtools code
02:59:50 <bennofs> i'm not 100% sure what things cause GHC to re-compile
03:00:28 <merijn> bennofs: Sure, but given the fact this is 2 different vim plugins using the same tool AND a documented issue about switching between relative and absolute paths resulting in slowdown, that seems like the most likely first thing to check
03:00:51 <bennofs> hmm yeah ;)
03:17:08 <stphrolland> merijn: I think I got it. Many thanks for your guidance. If you have any complementary remarks, I am eager of them. My final code is: http://lpaste.net/354327 with simplified <*>, and my version for >>=.
03:30:10 <bollu> can I generate out STG from GHC? I'm trying to understand what "id" would look like in STG
03:31:05 <jasondockers> wow, the definition of quicksort is so terse and readable compared to C :p
03:31:18 <bollu> jasondockers: it's not actually quick sort though
03:31:24 <bollu> jasondockers: in the sense that it is not in-place
03:31:47 <jasondockers> bollu, what's the runtime complexity? 
03:32:07 <mniip> jasondockers, quadaratic
03:32:10 <mniip> because pivot
03:32:13 <jasondockers> that's not quicksort! 
03:32:17 <mniip> it is
03:32:23 <jasondockers> on the average 
03:32:26 <mniip> vanilla quicksort has quadratic worst case
03:32:32 <mniip> yeah no, average n log n
03:32:34 <jasondockers> I mean, is it quadratic on average?
03:32:38 <mniip> no
03:32:48 <mniip> n log n average, quadratic worst case
03:33:07 <jasondockers> so the only difference between this quicksort and "real" quicksort is that it isn't in-place?
03:33:23 <mniip> sort-of
03:33:51 <bennofs> bollu: try -ddump-stg
03:35:19 <bollu> bennofs: thanks!
03:36:15 <quchen> bollu: If you want to understand STG, I don’t think reading GHC’s output is an easy starting point.
03:36:29 <bollu> quchen: I want to see how "id" is encoded
03:36:36 <quchen> bollu: This might be more helpful, https://github.com/quchen/stgi/
03:36:39 <bollu> quchen: because, in haskell, "id x = x"
03:36:52 <bollu> quchen: I looked into using it, but I'm not sure how to feed it haskell input
03:36:58 <bollu> quchen: I love STGi though :)
03:37:07 <quchen> You feed it STGi input, it’s independent of GHC
03:37:17 <quchen> But it has its own Prelude, which includes the id function
03:37:20 <bollu> quchen: yes, but I want to know how to *write* id in stg
03:37:22 <bollu> ooh, OK
03:37:32 <quchen> https://github.com/quchen/stgi/blob/master/src/Stg/Prelude/Function.hs#L52
03:37:52 <quchen> This is the STG language version of it, it’s not much of a difference compared to Haskell.
03:38:00 <bollu> quchen: if you can explain this to me: in the STG grammar, https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
03:38:01 <quchen> You can write a program using it to see how it looks in memory though
03:38:38 <quchen> I chose *not* to use the syntax from the 1992 paper and go for a more readable, Haskell-like syntax. The translation to 1992 syntax is straightforward though.
03:38:48 <bollu> quchen: an "expr" cannot have something  "simple" on the RHS right? it has to be function application, construction, or some primitive
03:38:59 <bollu> quchen: so I don't understand *how* \x -> x is legal
03:39:16 <quchen> I write \(x y) a b =>, 1992 writes {x y} \u {a b} ->
03:39:25 <quchen> Hmm? What’s »simple«?
03:39:38 <bollu> quchen: like, in Haskell, I would say "id x = x"
03:39:51 <bollu> but in the STG case, it looks like I have to "apply" it to something?
03:40:35 <bollu> or am I mis-understanding the STG grammar for Expr?
03:41:16 <quchen> The RHS of all STG definitions is a »lambda form«, which is a function of free variables, bound variables, an update flag, and the body
03:42:17 <quchen> The body is an expression, which is the usual case/let etc. https://github.com/quchen/stgi/blob/master/src/Stg/Language.hs#L175
03:42:22 <quchen> bollu: ^
03:43:18 <bollu> quchen: 
03:43:19 <bollu> yes
03:43:37 <bollu> quchen: but look at the grammar of Expr in the paper, there is no way to simply specify something without applying it
03:43:43 <bollu> unless you consider "x" as 0 application or something
03:44:03 <bollu> in "id x = x", what sort of Expr is the THS?
03:44:05 <bollu> RHS*
03:44:12 <quchen> Oh, yes, that’s x applied to nothing
03:44:17 <bollu> ah, OK
03:44:19 <quchen> There’s no difference in STG
03:44:20 <bollu> that's what I was wondering
03:44:37 <bollu> quchen: also, how do you know what the final state is?
03:44:42 <bollu> the paper mentions nothing about termination :)
03:44:50 <quchen> The semantics of function evaluation in STG is »push all arguments, enter the value«.
03:45:08 <quchen> bollu: The final state is when there are no further state transitions possible :-)
03:45:18 <mniip> jasondockers, a more conventional qsort will look slightly differently
03:45:26 <quchen> The paper says »machine halts when it runs out of rules to try« somewhere
03:45:34 <bollu> quchen: ahh, I missed that, ty
03:46:20 <jasondockers> mniip, I've only seen / written qs in C and Python, so I'm unsure how it would look in a FP language
03:46:32 <quchen> bollu: I think just reading my README.md could be very helpful, even if you don’t want to play around with STGi itself
03:46:42 <quchen> jasondockers: It looks fairly similar
03:46:52 <bollu> quchen: yep, I'd read it before, I think I should read it again
03:46:56 <lpaste> mniip pasted “qsort with nlogn worstcase” at http://lpaste.net/354328
03:46:59 <mniip> jasondockers, ^
03:47:10 <jasondockers> oh
03:47:10 <quchen> bollu: In particular, have a look at the »map« code example
03:47:40 <quchen> Proper Quicksort in Haskell uses in-place updates using ST, so it’s the same mess of index-pointer-juggling as in C
03:48:52 <jasondockers> ah, okay. thanks for the link. I don't  think it'd be a great use of time to try to dissect / read it right now. but I'll bookmark it and come back
03:49:21 <jasondockers> actually, I think it makes sense 
03:49:34 <mniip> jasondockers, are you familiar with median of medians
03:49:39 <quchen> I’m not sure this is n*log(n).
03:49:56 <quchen> But maybe it’s just terrible constants.
03:50:18 <mniip> quchen, split is linear and !! is dominated by qsort
03:50:51 <mniip> sure, terrible constant
03:51:05 <jasondockers> mniip, no, I haven't used that pivot selection before. 
03:51:57 <mniip> well, I'm not familiar with other pivot selection algorithms which give a logarithmic worst case
03:52:05 <quchen> mniip: I’m not even sure ordinary naive-haskell-quicksort is n*log(n), since list concatenation likes to introduce additional factors.
03:52:10 <mniip> excuse my ignorance if there's a simpler one
03:52:23 <quchen> Like foldl (++) [] xs isn’t linear, for example.
03:52:52 <merijn> bennofs: Quick check (and lunch) later: hdevtools and syntastic are indeed switching between absolute/relative paths
03:52:56 <jasondockers> mniip, what would the complexity of randomly selecting a pivot be?
03:53:17 <mniip> quchen, ++ is linear  yes
03:53:18 <bennofs> merijn: I'm suprised though that this invalidates ghc's caches
03:53:33 <jasondockers> I thought random pivot selection was like "amoritized" n log(n)
03:53:35 <mniip> jasondockers, random pivot is nondeterministic
03:53:41 <merijn> bennofs: I'm not sure it does, could just be a hdevtools bug
03:53:47 <mniip> arguably you can "find" a quadratic worstcase still
03:53:51 <jasondockers> mniip, right
03:54:23 <jasondockers> (I'll just look at the book on my table instead of bothering this channel
03:54:25 <mniip> I think any pivot that doesn't exxplicitly try to be bad will give you an average n log n
03:55:08 <mniip> heh
03:59:46 <jasondockers> yeah, that's pretty much my understanding too
04:00:24 <mniip> quchen, if we pretend that all operations are strict, http://mathb.in/136315
04:01:49 <mniip> no wait
04:03:30 <mniip> ah right I messed up
04:03:44 <mniip> I shouldn't use qsort in median of medians but rather quickselect
04:04:57 <vandenoever> how can i tell stack to build on multiple cores? it doesnt seem to be doing that
04:05:51 <lyxia> stack -j4
04:07:11 <cocreature> it should default to building in parallel iirc
04:07:19 <cocreature> https://github.com/commercialhaskell/stack/blob/9f794e129954f458a8fcf98e0bb2d5fbc209920a/src/Stack/Types/Config.hs#L325
04:07:58 <lpaste> mniip revised “qsort with nlogn worstcase”: “qsort with nlogn worstcase” at http://lpaste.net/354328
04:08:05 <mniip> jasondockers, ^
04:08:58 <jasondockers> mniip, so it's theta(n log n)?
04:09:10 <quchen> I don’t believe it until I see a proof.
04:09:28 <quchen> It looks at least quadratic to me, due to nested (++) calls.
04:09:29 <mniip> quchen, can you believe that if qselect is linear then qsort is nlogn
04:09:41 <jasondockers> mniip, yes, please write a proof and peer review it :p
04:09:48 <mniip> oh but
04:10:28 <merijn> mniip: I agree with quchen that repeated ++ will kill your log n
04:10:31 <mniip> Blum et al (August 1973). "Time bounds for selection"
04:11:52 <quchen> Even if qselect is O(1), heck – O(0), you could still get quadratic concatenation.
04:12:25 <quchen> ((a ++ b) ++ c) ++ d <- quadratic
04:13:14 <mniip> if a..d have O(N) length sure
04:13:44 <mniip> quchen, ok, look
04:14:09 <jasondockers> If it was O(0) wouldn't that kill all of us? Just thinking of energy and the lorentz factor.
04:14:22 <jasondockers> please don't write O(0) algorithms
04:14:50 <mniip> quchen, qselect(N) = pivot(N) + \\(N) + 2filter(N) + qsort(aN) + qsort((1-a)N) + ++(N)
04:14:56 <mniip> \\(N) = O(N)
04:15:04 <mniip> ++(N) = O(N)
04:15:10 <mniip> filter(N) = O(N)
04:15:18 <mniip> pivot(N) = O(N)
04:15:32 <mniip> qselect(N) = qsort(aN) + qsort((1-a)N) + O(N)
04:16:05 <merijn> mniip: qsort is O(n log n) because it's in place so you don't actually do ++ in any imperative implementation
04:16:23 <jmcarthur> lol, I've been using splittable random number generators for years and I only just now realize that the split function might as well just be an implementation of Random for PRNGs.
04:16:24 <mniip> oops
04:16:30 <mniip> s/qselect/qsort/
04:16:50 <mniip> merijn, right
04:16:56 <mniip> but out functional implementation is still nlogn
04:17:23 <mniip> so
04:17:33 <mniip> qsort(N) = qsort(aN) + qsort((1-a)N) + O(N)
04:18:14 <jasondockers> or would a O(0) time just mean it happened backwards in time? since velocity > c?
04:18:28 <mniip> by Akra-Bazzi, we have p=1 and c=1
04:19:01 <quchen> O(0) means you get it at no cost. Or something.
04:19:09 <mniip> qsort(N) = Theta(x (1 + int 1/n))
04:19:16 <mniip> qsort(N) = Theta(N (1 + int 1/N)) *
04:19:26 <mniip> = Theta(N log N)
04:20:48 <mniip> quchen, are you convinced?
04:21:30 <mniip> Mohamad Akra, Louay Bazzi: On the solution of linear recurrence equations. Computational Optimization and Applications 10(2):195–210, 1998.
04:21:47 <jmcarthur> Ah... random /= split due to the polymorphism in the prng
04:22:40 <jmcarthur> Sort of a bummer. The idea of generating independent PRNGs from a PRNG seems more elegant to me than the idea of a splittable PRNG.
04:22:59 <quchen> mniip: The issue is not the recursive structure of qsort (which is n*log(n), sure), but your use of (++) to concatenate the two sorted halves.
04:23:15 <mniip> quchen, I included the cost of ++
04:23:17 <mniip> in the computation
04:23:31 <quchen> Which part was that?
04:23:36 <mniip> ++(N)
04:24:07 <quchen> Hmm.
04:24:17 <jmcarthur> The concatenation is already paid for by the filtering.
04:24:30 <mniip> you can plop on arbitrarily many linear things in every iteration of qsort
04:26:50 <mniip> merijn, and qsort is n log n not because of that
04:27:27 <mniip> because it divides into proportional parts and conquers in linear time
04:28:09 <mniip> any algorithm that does that will be nlogn due to master theorem/akra-bazzi
04:28:10 <quchen> Okay, I change my vote to »probably convinced«, and will not contradict you anymore. :-)
04:28:39 <tabaqui1> is there any community statistics?
04:28:53 <tabaqui1> ya' know gender, age, race
04:29:07 <mniip> race?
04:29:20 <tabaqui1> medium income, country
04:29:37 <mniip> not sure race would corelate in any kind of significant way
04:30:07 <mniip> quchen, hooray there goes my first peer rewier
04:30:13 <mniip> review
04:30:14 <quchen> We usually sign up with our street address and our skin tone on IRC, sure.
04:30:18 <quchen> mniip: Hehe.
04:30:34 <quchen> mniip: »Some guy on the internet was OK with my proof« ;-)
04:30:42 <tabaqui1> mniip: no way, just want to compare
04:30:50 <mniip> some guy on the #haskell
04:30:51 <merijn> Whoo!
04:31:09 <merijn> Some quick patches later hdevtools is an order of magnitude faster and usable again!
04:34:43 <lyxia> We don't like data races too much around here.
04:35:12 <jmcarthur> Is there a good existing implementation of something allowing to construct records using labelled fields with Applicative?
04:35:40 <merijn> jmcarthur: You can construct records without record syntax
04:35:51 <jmcarthur> Of course, but I want the labelled arguments.
04:36:01 <merijn> Not that I'm aware of, then
04:36:05 <cocreature> jmcarthur: do notation and ApplicativeDo?
04:36:06 <jmcarthur> Thanks.
04:36:21 <jmcarthur> cocreature: Then I just have to invent intermediate names for everything.
04:36:31 <hexagoxel> and RecordWildcards, probably
04:36:37 <cocreature> ^ that
04:36:38 <merijn> Maybe SHE can help?
04:36:44 <jmcarthur> Ooh, RecordWildcards, I forgot I could do that.
04:36:46 <merijn> I think SHE has idiom brackets
04:36:46 <mniip> who is she
04:36:54 <merijn> mniip: You mean what :p
04:37:02 <merijn> mniip: Strathclude Haskell Extensions
04:37:07 <cocreature> is SHE still a thing?
04:37:07 <merijn> *Strathclyde
04:37:10 <jmcarthur> Ah, but then I can't use NamedFieldPuns to match on a record in the same function.
04:37:16 <merijn> cocreature: No clue :)
04:37:36 <jmcarthur> In this case I can get away with it, but in general I can't.
04:37:39 <cocreature> looks like the version on hackage was last updated 2011
04:37:49 <cocreature> so not particularly active :)
04:38:34 <jmcarthur> Yeah, idiom brackets seems like it would be the right solution for this, but I'm not interested in adding a preprocessor step. :(
04:38:48 <lyxia> that would be a good addition to https://github.com/dramforever/each
04:39:16 <mniip> that would make a fine addition to my collection *
04:39:38 <lyxia> Idiom brackets as quasiquotes
04:39:50 <lyxia> mniip: :)
04:40:02 <jmcarthur> Yeah, something along the lines of Idris' bang syntax (what lyxia's each thing looks like to me) would also work well for me.
04:41:55 <jmcarthur> (it so happens I have a monad this time, which of course is the only bang syntax could work)
04:42:00 <jmcarthur> *the only way
04:42:04 <lyxia> hmmm it may already support it
04:42:58 <jmcarthur> I wonder... can bang syntax ~subsume idiom brackets? It seems like there could be an ApplicativeDo-like treatment for bang syntax.
04:44:52 <quchen> Edwin said that bang syntax is a fairly simple addition and well-defined, and probably suitable for Haskell.
04:46:39 <jmcarthur> Of course we would need a different concrete syntax, and whatever we come up with is likely to be pretty noisy. :\
04:46:55 <jmcarthur> Still better than not having it, I think.
04:48:55 <jmcarthur> Idris has a lot of nice syntax sugar.
05:13:40 <piyush-kurur> in the context of  https://www.reddit.com/r/haskell/comments/63cka9/beware_of_numeric_type_classes/. Is it possible to make GHC warn about potential incorrect usage of numerals.
05:14:56 <merijn> piyush-kurur: The main way is to avoid using stupid instances of Num :)
05:15:24 <piyush-kurur> merijn: yes I agree
05:15:42 <merijn> You could annotate every literal with a type to avoid that sorta thing ever happening
05:16:23 <Iceland_jack> piyush-kurur: If you wanted, you could define impossible instances
05:16:28 <piyush-kurur> merijn: It would be good if the compiler can warn it
05:16:30 <Iceland_jack> instance Int ~ Bool => Num (a -> b)
05:17:16 <Iceland_jack> Or: instance TypeError (Text "FUNCTIONS != NUMBERS") => Num (a -> b)
05:17:58 <piyush-kurur> Iceland_jack: where should this be included?
05:18:25 <piyush-kurur> I mean in your own library so that we are protected from upstream authors 
05:18:41 <Iceland_jack> idk
05:19:43 <spatial> http://lpaste.net/354330 In this code segment I read and write to an IOArray. The array is returned from 'nextvalue' after that. Is that how it is done ?
05:20:14 <spatial> The IOArray has the written values when it is returned. Right ?
05:21:12 <lyxia> you don't need to return the array, it mutates
05:22:01 <spatial> I am returning so that other functions write their values.
05:22:29 <lyxia> other function can just take the same reference you passed to this function
05:23:11 <lyxia> just like in every other language
05:23:24 <spatial> Ok. If I return it and send it as a parameter it works too. Right ?
05:23:29 <systadmin> ello
05:23:31 <_sras_> is there any way to add validation (using digestive functors) to the `FromJSON` instances that are implemented using genericParseJson function?
05:24:11 <spatial> array <- nextvalue .... and then send array as parameter.
05:24:55 <lyxia> It's unnecessary. Unnecessary things confuse people.
05:25:24 <lyxia> _sras_: what kind of validation
05:25:59 <the_2nd> Attoparsec's "double" parser allows signs for doubles
05:26:11 <the_2nd> I want "+3.0" to fail, how can I achieve this?
05:26:19 <_sras_> lyxia: string fields does not exceed a certain length etc...
05:26:53 <lyxia> _sras_: you can just compose with a function that does the validation
05:31:15 <_sras_> lyxia: The parseJson function now looks like this   `parseJSON = genericParseJSON defaultOptions`. So compose with another function, (Parser a -> Parser a)?
05:33:28 <the_2nd> or how can I make attoparsec fail on certain input?
05:34:43 <lyxia> spatial: by your logic, why aren't you writing "a <- writethevalue a ..."?   (s', a') <- nextvalue ... a s; continue s' a'   is equivalent to   s' <- nextvalue ... a s; continue s' a   which is simpler.
05:34:52 <lyxia> the_2nd: lookahead?
05:35:26 <lyxia> _sras_: or Value -> Value, depending on the actual check you want to do
05:37:41 <spatial> lyxia: I understand. Just that when I learnt to use IOArrays I was mislead. Just determining if my logical flow is wrong if I do what I am doing. Will improve later.
05:39:58 <spatial> lyxia: I also couldn't refactor this properly. http://lpaste.net/354331 Here conditions dictate what is being written.
05:40:39 <spatial> So I started returning and passing IOArrays
05:41:56 <cocreature> spatial: I think you have some misconceptions if you believe that returning an IOArray solves some problem in your code
05:41:58 <the_2nd> lyxia, http://lpaste.net/9055646679113400320  ?
05:42:26 <cocreature> spatial: are you familiar with IORefs?
05:43:39 <spatial> cocreature:Know about them but haven't used. As I mentioned not making it more functional lead me down the wrong path.
05:43:43 <cocreature> spatial: return an IOArray that is passed to you as a parameter is about the same as returning the same filename that you get as a parameter
05:43:55 <the_2nd> lyxia, my parser seems to work, thanks
05:44:23 <cocreature> spatial: the function could of course have written to that file but returning the file name doesn’t help with anything
05:45:32 <spatial> cocreature: Hope you don't mean http://lpaste.net/354331 breaks the logic because I am returning it.
05:46:09 <cocreature> spatial: it doesn’t break the logic, it’s just not useful. so since you are still doing it I think you have some misconceptions that I’m trying to clear up :)
05:46:20 <cocreature> spatial: also you should really start by splitting that function up in smaller parts
05:46:53 <spatial> Exactly. That is what I should do.
05:47:34 <spatial> Somehow I believed IOArrays cannot be global. Are they ?
05:48:41 <spatial> I started using the State monad and thought any state is managed only like that.
05:50:01 <cocreature> spatial: think of it like a file: if you have access to the filename you can write to it and read from it. but the filename doesn’t change so you don’t need to return it from a function that writes to that file. an IOArray is similar: you can write to it but that will actually modify the array. the reference (~ the filename) still points to the same place so you don’t need to return it
05:50:06 <the_2nd> spatial, just an example for state updates (older version, far from perfect, could provide newer one) : https://github.com/I3ck/HGE2Ddemo/blob/master/src/StateTransform.hs#L74
05:50:42 <cocreature> the_2nd: that’s exactly what you don’t need to do with IOArrays …
05:50:42 <spatial> Oh! You mean pass by reference.
05:55:52 <spatial> In languages like Java a filename is an object and guarded from concurrent modifications by threads.
05:56:52 <cocreature> that doesn’t change the fact that returning the filename is not helpful
05:58:26 <spatial> I meant the concurrent modification of IOArrays is not possible in Haskell. Right ?
06:12:45 <quchen> spatial: It doesn’t need to be I think.
06:12:50 <quchen> Depends on the particular implementation.
06:13:31 <quchen> I’m pretty sure IOVector isn’t guarded against concurrent modification.
06:18:52 <ilyaigpetrov> is haskell as good for writing async code as, e.g., nodejs? Let's say I want to write a proxy server
06:19:23 <merijn> ilyaigpetrov: Much better, I'd say
06:20:43 <the_2nd> ilyaigpetrov, now go ask the node channel ;)
06:20:58 <ilyaigpetrov> merijn: ok, so package/async is the way I guess
06:22:11 <merijn> ilyaigpetrov: (GHC) Haskell has lightweight threads, so instead of writing async code using callbacks, you'd just use 1 thread per task and write regular blocking code for each thread.
06:22:37 <merijn> ilyaigpetrov: When a thread blocks on IO it just gets suspended and another thread is run until IO has finished
06:24:56 <merijn> This whole "async/promises/futures/etc." is basically just hacks to workaround crappy language restrictions
06:25:15 <merijn> Hell, even Go, the most backwards language in several decades got lightweight threading right
06:25:33 <fendor> backwards language?
06:26:52 <merijn> fendor: Go ignores every single development and discovery in programming language research since the 60s. There's literal languages invented in the 60s that are more modern than Go
06:27:54 <ph88^> when i have many documents and many groups how do i encode a many to many relationship in haskell ?
06:29:08 <ph88^> data Rel = Rel Int Int   ?
06:29:27 <quchen> Ignoring language development doesn’t *have* to be bad though. Just think about »let’s not have subtyping polymorphism everywhere«.
06:30:48 <merijn> fendor: See http://cowlark.com/2009-11-15-go/
06:30:50 <the_2nd> fendor, quchen https://groups.google.com/forum/#!topic/golang-nuts/f32UN1TYiAI
06:30:59 <merijn> quchen: I'm not saying you should have *everything*
06:31:14 <merijn> quchen: But when you pick up literally nothing, maybe it's time to question what you're doing
06:31:18 <quchen> merijn: Sure, I got what you said, I merely wanted to augment it a bit.
06:33:39 <merijn> Man...recursive types are a pain...I figured this System F_ω would be a time saver, having the same representation for types and expressions...turns out it just makes my type checker confusing >.<
06:33:49 <the_2nd> fendor, no generics, no overloading. everything has to be defined for all types explicitly
06:34:24 <merijn> the_2nd: Generics are too hard and confusing for programmers!
06:34:45 <fendor> thanks for your explanations!
06:34:51 <fendor> ill read your links 
06:34:54 <quchen> merijn: Your two last statements combine in a funny way :-þ
06:35:15 <merijn> quchen: Not really, generics have been working for ages >.>
06:36:15 <the_2nd> merijn, If you like re-inventing the wheel, go for go
06:36:20 <the_2nd> ;)
06:36:51 * quchen tries reinventing wheels in Agda, but has trouble proving what »round« is
06:36:57 <merijn> quchen: :)
06:37:02 <KongWubba> cowlark is REALLY interesting!! thx for the link
06:37:35 <merijn> quchen: My problem is that I have "data Expr a = ... | Pi String (Expr a) (Scope String Expr a) | ..."
06:38:19 <merijn> quchen: Since Expr represents both types and values my type annotations are just another Expr
06:39:21 <merijn> Now, I typecheck by substituting variables with their type, so I get "Expr Type" unfortunately, since type is itself an 'Expr a' with potential variables I get "newtype Type = Type (Expr Type)" and it all gets very confusing
06:41:37 <Philonous> I wonder what it is about Haskell that attracts so much sneering and contempt. Or do all languages attract sneering and contempt and I'm just not seeing it?
06:42:00 <merijn> Philonous: In what sense?
06:42:26 <Philonous> merijn, Well, I regularly see articles like this: http://www.virtuouscode.com/2017/04/04/the-pretentious-haskell-phase/
06:43:13 <Iceland_jack> Philonous: Haskell is neat, it can go to your head at first
06:44:00 <merijn> Philonous: I think that's more projection of the author
06:44:55 <Philonous> Well yes, it's certainly not a well-founded criticism of Haskell (it's not a criticism at all - just sneering), but Haskell seems to attract this kind of response in a way other languages don't 
06:45:43 <merijn> Philonous: because Haskell is: 1) well-known, 2) attracts an enthusiastic community, and 3) is VERY different from existing languages
06:46:10 <Philonous> merijn, Isn't that same true for e.g. prolog or ML?
06:46:24 <merijn> Philonous: Lisps have about the same mindshare and enthusiastic community, but it's still rather similar to imperative languages
06:46:44 <merijn> Philonous: naah, I think prolog and ML have a fraction of the mindshare Haskell has
06:47:08 <merijn> The average JS programmer has never heard of prolog or ML, but they have probably heard about Haskell and "monads"
06:47:45 <Iceland_jack> gonads..
06:48:00 <ystael> Philonous: I think there's a number of people out there who hear Haskell advocacy, and what they hear -- regardless of whether it's what's being said -- is "I use Haskell because I'm smarter, and if you were smarter you would use Haskell too"
06:48:11 <Philonous> Maybe you're right and I'm just typical-minding here. 
06:49:00 <merijn> ystael: Which is of course wrong, because we're all using Haskell 'cos we're dumb :)
06:49:20 <Philonous> If I was smart I'd need no type checker. 
06:49:24 <ystael> merijn: To quote Michael Gira of Swans: "I know that, and you know that. But our purpose is to tell _everybody_ that."
06:49:45 <Philonous> (I guess that's what you meant)
06:49:59 --- mode: ChanServ set +o dibblego
06:50:03 --- mode: dibblego set +b *!*@nat184.lu.usi.ch
06:50:08 --- kick: nbro was kicked by dibblego (nbro)
06:50:16 --- mode: dibblego set -o dibblego
06:53:20 <quchen> merijn: People who want to badmouth languages are going to do that. For other languages, people often find easy targets, such as your »Go has ignored all progress« or »Javascript callback hell« or »C unsafety«.
06:54:01 <merijn> I can badmouth Haskell just as easily :p
06:54:47 <quchen> There are lots of valid criticisms of Haskell, but that reqiures learning a language. You can say, without learning Go, that the lack of parametric polymorphism is nonsense. In Haskell you have historical accidents (String, for example), but nothing completely terrible.
06:54:57 <quchen> And in particular, completely obviously terrible.
06:55:02 <merijn> newtype wrapping for instance selection is a pain, Num is a mess, the redundant Prelude functions after AMP mess up everything, the binary operations leave to be desired, Text/BS/String is a mess :)
06:55:04 <quchen> Records are awkward, sure.
06:55:30 <merijn> Haskell's messes are just less disastrous as the rest :p
06:55:38 <ystael> The Haskell community _is_ claiming a position of high social rank, in the sense that most software people regard "smart" as a positive value, and the Haskell community regards the language as possessing a high "smart rating" compared to other languages in common use.
06:55:45 <tdammers> Haskell's biggest problem IMO is the learning curve
06:56:04 <dibblego> I use haskell because I'm not smart.
06:57:01 <merijn> dibblego: You seems to have about 7 minutes of lag ;)
06:58:30 <ilyaigpetrov> I want to learn haskell because I heard it's the best way to learn functional programming
06:58:44 <ilyaigpetrov> purely functional language
06:59:14 <merijn> ilyaigpetrov: I would agree, since I only know of, like, 4 purely functional languages and Haskell is the only mainstream one of them :)
06:59:38 <Philonous> Have you people seen the paper on the new typed reflection mechanics? It's pretty neat: "Have you seen the paper on the new typed reflection mechanics? It's pretty neat: https://www.microsoft.com/en-us/research/publication/typed-reflection-in-haskell/
06:59:54 <Iceland_jack> It is
07:00:04 <Philonous> Errr, miss-paste :(
07:01:15 <quchen> > cycle "Have you seen the new paper about recursion? It’s pretty neat: "
07:01:17 <lambdabot>  "Have you seen the new paper about recursion? It\8217s pretty neat: Have you...
07:01:47 <rotaerk> hmm, a good chunk of intelligence is intellectual responsibility ... I'd say haskell *is* for smarter people, and using it does require a certain amount of perseverance.  you don't need type checking and the other language features because you're "dumb" but because you're not god
07:03:16 <rotaerk> the main problem is when people turn it into a social-status issue in the first place ... like you have no right to advocate the language, or you're just an annoying evangelist who thinks he knows better than them
07:03:29 <ilyaigpetrov> why this room is more popular than ##javascript (1200 members)?
07:03:43 <rotaerk> (and you really *do* know better than them; they just can't accept that)
07:04:38 <Philonous> Heh, I could have sworn I found the paper on reddit, but I can't seem to find the tread any more
07:04:57 <ilyaigpetrov> Philonous: chrome://history...
07:05:15 <Aruro> rotaerk: even without type checking haskell still will be better, just because its easier to write
07:05:29 <ystael> rotaerk: I think my point is that there are some people for whom it can't _not_ be a social status issue, because you're implicitly threatening the hierarchy they've invested in developing their position in
07:06:13 <rotaerk> yes, people become "expert beginners"; they really don't know all that much but they think they know it all, and you're threatening this delusion
07:06:24 <quchen> Aruro: I disagree. I wrote a good amount of STG, which is pretty much untyped (and desugared) Haskell, and it’s an awful experience.
07:07:04 <Aruro> well writing 1km long cases can not be fun, but you get what i mean :)
07:07:36 <rotaerk> the main downside to haskell is that there's quite a learning curve, and having prior experience in other languages doesn't really put you at much of an advantage
07:07:40 <Aruro> abstraction simply better in haskell, if there will appear new language will better abstractions i will switch first day.
07:07:47 <Aruro> with*
07:07:48 <rotaerk> and people just don't want to have to learn anything difficult
07:08:26 <c_wraith> The funny thing is, all that knowledge from other languages turns out to still be useful when using haskell.  Just not while learning it.
07:08:46 <rotaerk> yea
07:09:29 <Aruro> come on, people learn difficult stuff. like ugly c++ is easy to learn
07:09:42 <Aruro> in fact majority of stuff people learn is ugly difficult stuff
07:10:04 <rotaerk> C++ isn't really conceptually difficult; it's fairly simple conceptually, just with a minefield of gotchas
07:10:10 <Aruro> so!
07:10:30 <opqdonut> rotaerk: some of the new stuff like move semantics are conceptually difficult too
07:10:32 <Logio> one big part is probably that many programmers eschew math on principle, and Haskell has a very "mathy" way of putting things
07:10:33 <opqdonut> IMO
07:10:37 <rotaerk> ah
07:10:42 <c_wraith> I actually think Haskell is a simpler language than most, in terms of number of things you need to know to use it.  It's just that the things you need to know contain a lot of things you don't need to know in other languages.
07:10:49 * rotaerk hasn't touched C++ in over a decade.
07:10:49 <opqdonut> yeah
07:10:56 <eschnett> C++ has so many trees that it’s difficult to see the forest
07:11:04 <Itkovian> shapr first Haskell thingie in a loooong time :)
07:11:18 <eschnett> for example, templates can (in principle) take other templates as arguments, but no one does this, at least not in the standard library
07:11:21 <shapr> yay! what is it?
07:11:32 <merijn> eschnett: "no one does this" <- hah, I wish
07:11:49 <eschnett> the haskell equivalent would be to write “Functor f” as a constraint — quite common
07:12:06 <merijn> eschnett: You clearly haven't seen some of the atrocities I've committed: https://github.com/merijn/GPU-benchmarks/blob/master/TemplateConfig.hpp
07:12:09 <eschnett> merjin: do you have an example? i’m struggling with this (not the concept, the gotchas)
07:12:20 <rotaerk> c_wraith, eh, at its core haskell is simple, but it's got quite the ecosystem of abstractions, and that ecosystem grows over time
07:12:43 <rotaerk> people who work in other languages don't tend to build conceptually difficult abstractions
07:12:44 <merijn> lines 151-158 and 195-204 amongst others
07:12:52 <eschnett> “template<typename,typename,typename,typename...> class BaseConfig”: nice!
07:13:16 <rotaerk> although you *can* build conceptually difficult abstractions elsewhere, it's just not usually done
07:13:21 <c_wraith> rotaerk: but that isn't language complexity.  There's nothing in Haskell as complicated as inheritance, for instance.
07:13:26 <merijn> You know you're doing something right when your template signature is 10 lines long :)
07:13:41 <eschnett> yes, it’s not done because it’s too difficult to see the forest when you try and do so, because there are too many trees in C++
07:13:53 <quchen> ?hackage sessions merijn 
07:13:53 <lambdabot> http://hackage.haskell.org/package/sessions merijn
07:14:32 <merijn> quchen: Yeah, but GHC has better type inference
07:14:42 <Aruro> imo CT scares a lot of people from simple language of haskell
07:14:59 <merijn> quchen: I have to wrute atrocities like "ecltype(warp_dispatch<Warp>::work(0,0).kernel)"
07:15:20 <eschnett> here is my atrocity: https://gist.github.com/eschnett/5e6d9b166ac53888a4b6783975bb8ab6 (foldr in C++)
07:15:29 <eschnett> only 8 lines, though…
07:15:36 <merijn> eschnett: Nice :)
07:18:10 <rotaerk> c_wraith, in practice, it's not the complexity of the language that matters, but the complexity of idiomatic use of the language
07:18:17 <rotaerk> which draws on a lot of those abstractions
07:20:51 <cocreature> we can’t even get strings right so how can this language be good for anything? ;)
07:21:02 <rotaerk> most programmers I know don't even want to learn the language they use beyond what they have to... some C# programmers I know don't even know what generics are
07:21:15 <cocreature> ups I haven’t scrolled down, nvm
07:21:17 <rotaerk> so I can see why people just don't gravitate towards haskell
07:21:42 <Aruro> sorry but life spend coding in c++ and in haskell is two different lifes
07:21:57 <Aruro> they dont gravitate because cant
07:22:39 <Aruro> its same why we dont use electric cars
07:22:41 <chipmadness> why does this not work? removeNonUppercase x = filter isUpperSpace x where isUpperSpace = isUpper x || isSpace x
07:23:06 <rotaerk> because isUpperSpace is a Bool, not a Char -> Bool
07:23:13 <rotaerk> and you're applying it to x
07:23:30 <Aruro> :t filter
07:23:32 <lambdabot> (a -> Bool) -> [a] -> [a]
07:23:32 <merijn> Also, 'x' is a list and you're applying isUpper to it
07:24:02 <rotaerk> err eyes didn't track the fgilter
07:25:28 <chipmadness> how do you suggest to remove all uppercase letters in a string and ignore the spaces
07:26:13 <Philonous> > let f x = filter isUpperSpace x where isUpperSpace x = isUpper x || isSpace x in f "ABc Def"
07:26:15 <lambdabot>  "AB D"
07:26:30 <Aruro> chipmadness: removeNonUppercase x = filter isUpperSpace x where isUpperSpace c = isUpper c || isSpace c
07:26:42 <Philonous> You where missing the parameter to isUpperSpace 
07:27:07 <chipmadness> LOL thanks Philonous
07:27:19 <Philonous> Also, not shadowing the outer parameter helps with legibility, yes
07:27:58 <Aruro> chipmadness: did u read what compiler told u?
07:28:03 <brynedwards> > filter (not . isLower) "ABc Def"
07:28:05 <lambdabot>  "AB D"
07:28:49 <Aruro> > isLower ' ' 
07:28:51 <lambdabot>  False
07:29:16 <Philonous> > (filter (not . isLower) "123", filter (\x -> isUpper x || isSpace x) "123") 
07:29:18 <lambdabot>  ("123","")
07:29:49 <brynedwards> ops
07:30:21 <Aruro> > isUpper ' ' && isUpper '1'
07:30:24 <lambdabot>  False
07:31:30 <Iceland_jack> > all isUpper " 1"
07:31:32 <lambdabot>  False
07:31:47 <Aruro> same for lower
07:33:47 <fendor> > isUpper ' ' || isLower ' '
07:33:49 <lambdabot>  False
07:33:53 <fendor> lol
07:34:08 <Aruro> yeah, filtering cases preserves spaces
07:34:12 <Aruro> and numbers
07:34:19 <fendor> > (isUpper $ toUpper ' ') || (isLower $ toLower ' ')
07:34:22 <lambdabot>  False
07:34:28 <fendor> more lol
07:37:26 <_sras_> Is there a version of Data.Map that does not require Eq, Ord instances for keys, but instead accept a function :: (Ord realKey) => (key -> realKey) for calculating the actual keys?
07:38:04 <merijn> _sras_: Not really, but you can newtype the key type to provide your own Ord/Eq
07:39:33 <_sras_> merijn: Yes. can do that...
07:39:48 <_sras_> But was looking for something easier...
07:40:21 <vaibhavsagar> _sras_: can you use Data.HashMap?
07:40:38 <_sras_> vaibhavsagar: Yes.
07:41:11 <_sras_> vaibhavsagar: Can HashMap do this?
07:41:36 <vaibhavsagar> it doesn't require an Eq or Ord instance
07:41:48 <vaibhavsagar> but your key type has to be Hashable
07:41:58 <vaibhavsagar> which you can define on your own if you need to
07:43:18 <vaibhavsagar> actually, that's not 100% correct, you do need an Eq instance
07:43:39 <_sras_> vaibhavsagar: looks like it needs Eq instance for keys...insert :: (Eq k, Hashable k) => k -> v -> HashMap k v -> HashMap k v
07:43:40 <vaibhavsagar> but if you don't have that I can't imagine any hashtable working for you
07:44:11 <_sras_> vaibhavsagar: Can you tell me why?
07:44:33 <mnoonan> _sras_: how else would you handle hash collisions?
07:44:34 <opqdonut> it's for hash collisions
07:44:35 <Philonous> _sras_, In case of hash collision, keys need to be compared to find the actual one
07:44:45 <merijn> Isn't implementing Hashable about as much work as just newtyping?
07:44:55 <opqdonut> of course you could just have a custom Eq instance that compares the hash code :P
07:45:21 <_sras_> merijn: But I don't have to change the exsisting code that uses this function...
07:45:25 <mnoonan> newtyping has the annoyance of un-newtyping whenever you want to pull something out of the map
07:45:47 <vaibhavsagar> you can derive Hashable and Eq
07:46:25 <_sras_> mnoonan: I can guarantee that there wont be hash collisions, I mean, for the data set and hashing function I have.
07:47:22 <vaibhavsagar> if you have a hashing function, then you've done 90% of the work for a Hashable instance :)
07:47:25 <_sras_> vaibhavsagar: I don't want Eq instance because a sensible Eq instance for this particular data type in a global context might cause a performance hit. 
07:47:39 <cocreature> _sras_: but HashMap has to work for any hashing function and data set. so it has to require an Eq constraint even if it’s not used in your specific usecase.
07:47:58 <vaibhavsagar> _sras_: as someone pointed out above, compare hashes for equality
07:48:40 <_sras_> Yes. I understand.
07:49:48 <vaibhavsagar> or you could allocate a giant array and index it using your hash function, that way you can avoid having to implement Eq, Hashable, or Ord instances by implementing your own hashtable :D
07:50:40 <phz_> is there some kind of TH to query the name of the current cabal project?
07:50:55 <phz_> the `name` field
07:52:31 <phz_> https://hackage.haskell.org/package/cabal-file-th
07:52:33 <phz_> maybe this?
07:53:40 <vaibhavsagar> that looks perfect
07:54:16 <jayjam124> is there a way to fix indentation errors quickly in Notepad++?
07:54:40 <cocreature> phz_: somewhat recent versions of cabal define a "CURRENT_PACKAGE_KEY" cpp macro but I’m not sure what exactly that contains
07:55:03 <phz_> is there any documentation about that somewhere cocreature?
07:55:06 <phz_> sounds promising
07:55:34 <cocreature> phz_: https://cabal.readthedocs.io/en/latest/developing-packages.html?highlight=CPP#conditional-compilation explains that it’s defined but at least for myself there is not enough information to say what it actually contains :)
07:55:44 <cocreature> just trying it out is probably the easiest solution :)
07:57:04 <phz_> hm, anyway
07:57:19 <phz_> how can I use a Q Exp as a function?
07:57:24 <phz_> https://hackage.haskell.org/package/cabal-file-th-0.2.4/docs/Distribution-PackageDescription-TH.html#t:PackageIdentifier
07:57:29 <phz_> oops
07:57:36 <phz_> https://hackage.haskell.org/package/cabal-file-th-0.2.4/docs/Distribution-PackageDescription-TH.html#g:1
07:57:39 <phz_> packageVariable
07:57:44 <phz_> I thought it was something like
07:57:48 <phz_> ($packageVariable …)
07:58:01 <phz_> maybe it’s $(packageVariable …)
07:58:18 <phz_> yep
07:58:57 <jayjam124> http://puu.sh/vaa56/3d8d48ca37.png does anyone see any indentation errors with the highlighted code?
08:00:06 <cocreature> jayjam124: the lines in a "do"-block need to be aligned
08:00:07 <jayjam124> parse errors on line 36
08:00:42 <cocreature> also I’m not sure if you can use {} around a do block without using ; but that might work
08:00:42 <jayjam124> so how do you mean cocreature?
08:01:02 <athan> How did lambdabot know when hackage had a package uploaded? Is there a way to register 3rd party services for pinging?
08:01:10 <cocreature> jayjam124: e.g. everything that belongs to the do block started in line 35 needs to line up with "i <- …" in line 35
08:01:25 <cocreature> athan: iirc there is an rss feed that lambdabot used
08:01:31 <cocreature> or rather hackagebot
08:02:59 <jayjam124> http://puu.sh/vaaie/3662b296e0.png like this cocreature?
08:03:28 <cocreature> jayjam124: no "let newguesslist = …" doesn’t align with "i <- randomRIO …"
08:03:37 <cocreature> they need to start in the same column
08:04:11 <jayjam124> http://puu.sh/vaalI/4db8ef3c2a.png LIKE THIS?
08:04:15 <jayjam124> sorry caps my bad
08:05:19 <cocreature> jayjam124: yep that looks like it might work. if not try removing { and } around the do block or add ; after each line in the do block
08:05:31 <cocreature> I’ve never used {} in a do block so I’ve no idea if it works without ;
08:06:20 <jayjam124> yeah that worked, ty
08:28:08 <jayjam124> hi
08:28:38 <jayjam124> so I was working on this game: http://puu.sh/vabxY/95b4f19802.png
08:29:08 <jayjam124> https://pastebin.com/ZBbgELtz
08:29:23 <jayjam124> but I'm sure I've done the main bulk of the program but nothing pops up when I run "main" in GHCI?
08:29:26 <jayjam124> and compile it, so wtf?
08:32:25 <mniip> I feel like I've seen this before
08:33:11 <mniip> jayjam124, well I don't see any output in your program
08:33:48 <jayjam124> I think showStr has something to do with that right?
08:33:58 <mniip> right
08:34:02 <mniip> but it's not called anywhere
08:34:09 <jayjam124> my prof provided me that
08:34:17 <jayjam124> it was a template so you fill in the gaps
08:34:19 <cocreature> then maybe you should try using it :)
08:36:59 <jayjam124> I'm  pretty sure I have to call showStr and pass in the generating numbers?
08:39:54 <jayjam124> yeah or no?
08:41:08 <cocreature> jayjam124: you can pass a string to "showStr" and it will be printed to stdout. I don’t know what you want to print, that’s up to you :)
08:41:28 <jayjam124> well I mean I'm generating random numbers
08:42:00 <jayjam124> fuck this is confuisng
08:44:03 <jayjam124> ok
08:44:38 <jayjam124> yeah idk
08:44:46 <jayjam124> not sure how to print this stuff out
08:45:14 <cocreature> what exactly do you want to print?
08:45:26 <cocreature> showStr "hello world" will print hello world
08:45:30 <jayjam124> yes
08:45:48 <jayjam124> I mean in the program brief it says at the end I need to output the number of removed digits and the number of guesses
08:45:51 <jayjam124> that should be simple
08:46:01 <jayjam124> but I'm not sure how to output the interaction for the user to use my game
08:46:50 <jayjam124> but you need something to you know, allow the user to interact with it
08:47:58 <jayjam124> it's tying it into my professor's template which is the hard part
08:48:16 <jayjam124> because my prof doesn't want it changed too much from his :(
08:56:04 <James123> Can someone give me some hints on how this works: head >>= (. tail) . (:) . toUpper ? It convert the first letter of a string to uppercase, but it seems a bit confusing...
08:59:59 <glguy> First let's deobfuscate it slightly:
09:00:02 <glguy> ?unpl head >>= (. tail) . (:) . toUpper
09:00:02 <lambdabot> (\ a0 -> ((:)) (toUpper (head a0)) (tail a0))
09:00:16 <glguy> It's using the instance Monad ((->) e)
09:00:40 <glguy> (\ a0 -> ((:)) (toUpper (head a0)) (tail a0)) === (\a -> toUpper (head a) : tail a)
09:01:47 <glguy> > ((f :: Expr -> Expr) >>= (g :: Expr -> Expr -> Expr)) x
09:01:49 <lambdabot>  g (f x) x
09:02:08 <glguy> When you are using this monad instance,    (f >>= g) x = g (f x) x
09:02:24 <glguy> I needed some type annotations on f and g because they're overloaded in lambdabot
09:03:42 <James123> glguy: thank you, now it makes sense :)
09:04:57 <Sornaensis> :t runConT
09:04:59 <lambdabot> error:
09:04:59 <lambdabot>     • Variable not in scope: runConT
09:04:59 <lambdabot>     • Perhaps you meant one of these:
09:05:04 <Sornaensis> :t runContT
09:05:05 <lambdabot> forall k a (m :: k -> *) (r :: k). ContT r m a -> (a -> m r) -> m r
09:25:39 <obiwahn> http://paste.debian.net/926126/
09:25:46 <obiwahn> what could be missing
09:27:29 <ClaudiusMaximus> import Data.Monoid
09:28:47 <ClaudiusMaximus> they're in Prelude since recent base, so I guess you're trying to compile new code with older ghc
09:30:02 <tolt> I saw a package a while ago that I can't seem to find... It gives functions for getting information on when you compiled a program
09:30:22 <tolt> Does anyone know what package I'm thinking of?
09:30:48 <obiwahn> ah ok
09:31:24 <obiwahn> what is the strategy to reproduce a build on some other system?
09:32:23 <ClaudiusMaximus> tolt: https://hackage.haskell.org/package/gitrev perhaps?
09:32:57 <tolt> ClaudiusMaximus: I found that but I thought it was information about cabal/time
09:34:27 <obiwahn> is there something like npm
09:34:58 <glguy> jle`: https://glguy.net/~pi/lift-nary-operator/Derive.html#v:genericOpN
09:34:59 <geekosaur> obiwahn, that's generally what stack is for
09:35:05 <obiwahn> System.IO.Temp - i use hoogle but it is still not clear to me what is missing here
09:35:51 <glguy> genericOpN @Num @('S ('S 'Z)) (+) (1.2, 3) (4.5, 6) -- (5.7,9)
09:36:18 <glguy> (just cleaned up from last night)
09:37:14 <obiwahn> https://github.com/Eelis/cxxdraft-htmlgen
09:41:38 <amazon4BTC> hey im trading $250 amazon giftcards for $60 in bitcoin pm me fam
09:41:53 --- mode: ChanServ set +o glguy
09:41:54 --- mode: glguy set +b *!*@gateway/web/freenode/ip.50.151.27.165
09:41:54 --- kick: amazon4BTC was kicked by glguy (offtopic)
09:42:07 <NeverDie> Could anyone help me return an Int from this function?
09:42:12 <NeverDie> sumArray = fromMaybe 0 . fmap (sum . init . tail . sort)
09:42:36 <NeverDie> Keeps returning `Maybe Int` if I do `sumArray = fmap (sum . init . tail . sort)`
09:42:48 <NeverDie> Where I just want this: sumArray :: Maybe [Int] -> Int
09:43:30 <tabaqui1> how can I convert two arbitrary real numbers?
09:43:43 <glguy> :t maybe 0 (sum . init . tail . sort)
09:43:44 <lambdabot> (Ord b, Num b) => Maybe [b] -> b
09:43:45 <bennofs> :t fromMaybe 0 . fmap (sum . init . tail . sort)
09:43:47 <lambdabot> (Ord c, Num c) => Maybe [c] -> c
09:43:57 <tabaqui1> I'm looking at Double type
09:44:00 --- mode: glguy set -o glguy
09:44:13 <tabaqui1> and cannot see any convertion alike (Float a) => Double -> a
09:44:17 <tabaqui1> or a -> Double
09:44:21 <glguy> tabaqui1: realToFrac
09:45:26 <tabaqui1> glguy: thanks!
09:46:34 <tabaqui1> I've lost in default numeric types
09:46:45 <tabaqui1> ah, frac is not a subclass of real
09:47:47 <NeverDie> @glguy: How can I make it work with less than 2 elements?
09:47:47 <lambdabot> Unknown command, try @list
09:48:18 <glguy> NeverDie: You'd have to define what it means to work with fewer than 2 and add a case for that
09:49:42 <glguy> neverdie (Just xs@(_:_:_)) = ...; neverdie _ = 0 -- perhaps
09:51:19 <NeverDie> glguy: Hmm, I don't get it.
09:51:35 <glguy> You'll have to be more specific.
09:52:00 <NeverDie> glguy: sumArray (Just xs@(_:_:_)) = x?
09:52:24 <glguy> with 'x' replaced with the actual definition
09:55:11 <NeverDie> glguy: As in like `sumArray (Just xs@(_:_:_)) = xs`?
09:55:31 <glguy> NeverDie: That'd be a type error, wouldn't it?
09:55:34 <glguy> You wanted the result to be an Int
09:55:42 <NeverDie> Equations for ‘sumArray’ have different numbers of arguments
09:55:44 <NeverDie> Yeha.
09:55:46 <NeverDie> Yeah*
09:55:52 <glguy> No, they both had 1 argument
09:56:08 <glguy> at least as I wrote them
09:56:27 <NeverDie> `sumArray (Just xs@(_:_:_)) = maybe 0 (sum xs)` Doesn't seem to work either lol.
09:56:49 <glguy> It seems like you're just guessing...
09:57:09 <glguy> Can you explain what this pattern means: (Just xs@(_:_:_)) ?
09:58:20 <NeverDie> I have no idea what it means lol.
09:58:32 <NeverDie> No matter what the first 3 elements are?
10:01:03 <NeverDie> First time I see the @ sign in Haskell.
10:02:27 <NeverDie> xs as (_:_:_) ?
10:03:00 <Cale> Yeah, it binds the entire list to xs, and also ensures it matches against the pattern (_:_:_)
10:06:16 <NeverDie> Cale: This is the only thing that pops into my head but it doesn't work https://ghostbin.com/paste/okdw7
10:10:56 <Cale> All the clauses of a single function definition need to have the same number of arguments
10:11:05 <Cale> But also, what is the idea of this function?
10:11:28 <Cale> sum usually doesn't produce a Maybe result
10:13:29 <NeverDie> Cale: It's for a codewars problem.
10:13:39 <NeverDie> That's the type signature they gave to work with.
10:18:51 <mniip> ugh
10:19:01 <Cale> NeverDie: The type signature could make sense, apart from the fact that the function clearly has nothing to do with arrays
10:19:20 <Cale> NeverDie: But I don't understand what the function is supposed to compute
10:20:15 <jle`> glguy: ar you planning on hackaging it
10:20:27 <jle`> if so then i'll just scrap mine
10:20:42 <Cale> NeverDie: If I was asked to write a function having that name and type, the most obvious thing I'd expect to have to write is  sumArray = maybe 0 sum
10:20:59 <jle`> glguy: and i can submit a pr with https://github.com/mstksg/generics-lift/blob/master/src/GHC/Generics/Numeric.hs :)
10:21:29 <Cale> (that would be the whole definition)
10:23:10 <Shimapan> Hi, how do I go about creating a newtype that is transforming IO, ideally also deriving MonadIO and yet, not allowing the other modules to lift IOs into it?
10:23:44 <Shimapan> I essentially would like to not have the `instance MonadIO MyType` to be exported.
10:23:45 <Cale> Shimapan: You're asking for conflicting things
10:23:55 <Cale> deriving MonadIO is what allows things to liftIO
10:24:36 <Shimapan> Cale: It's because I want the type to have IO capabilities while not exposing it for the user. But working with a lot of monad transformers is painful so I was hoping to add MonadIO and keep the instance locally for my module.
10:24:42 <Shimapan> Cale: But it seems like this isn't possible.
10:24:46 <Cale> You probably want to define a local equivalent of liftIO, e.g. io x = MyType (liftIO x)
10:24:50 <Cale> and then not export that
10:25:08 <jle`> that's what i have had to do
10:25:15 <Cale> There's no way to prevent instances from being exported
10:25:17 <Shimapan> Cale: Why does haskell always export instances?
10:25:59 <jle`> alternatively you can give your type a newtype wrapper, and then work with that type internally.  and that newtype wrapper could have a MonadIO.  but the best way is to probably write your own custom io-lifter
10:26:34 <Cale> Shimapan: Instances are assumed to be globally unique conventions about how operations are implemented
10:26:38 <Shimapan> jle`: It's already a newtype though. So you're saying a newtype of a newtype to chose what instances are exposed and which aren't ?
10:26:55 <jle`> Shimapan: you have to write the instnaces for that newtype
10:27:00 <jle`> so you can choose what instances that newtype has
10:27:15 <jle`> see, for example, Sum, Product, All, And, Endo, First, Las, etc.
10:27:19 <jle`> from base
10:27:31 <jle`> (...did i forget any?)
10:27:36 <Shimapan> Am I also able to define some form of type equality or do I have to refactor the existing code for the extra newtype?
10:27:54 <jle`> you'd just have to unwrap and wrap it if you work with it internally
10:28:14 <jle`> the better solution is to just use your own internal custom io-lifter, like suggested before
10:28:25 <jle`> myLiftIO :: IO a -> MyType a
10:28:26 <Shimapan> Mhh. That's unfortunate, but at least now I have a few options. Thanks, jle` and Cale.
10:28:42 <jle`> coherency is an important part about what makes typeclasses usable
10:28:51 <jle`> so being able to hide instances would kill that
10:29:11 <jle`> imagine hiding an Ord instance for a type, and then getting a Set or Map oof that type
10:29:17 <jle`> you can then define a custom Ord instance, breaking everything
10:29:32 <Shimapan> I see.
10:29:55 <jle`> or worse, what if a module uses both modules with two different instances for Ord of a type
10:30:04 <Shimapan> Maybe it could be a system similar to functional dependencies, where you can say "This type isn't allowed isn't instance of class X".
10:30:21 <jle`> not sure i follow
10:30:25 <Cale> Shimapan: If what you need isn't a convention about how operations are implemented, then you shouldn't be using type classes
10:31:01 <Cale> Haskell does have first class functions which you can pass around if you want local conventions about it :)
10:31:19 <Shimapan> jle`: *A system that lets a module define an instance locally, and prevents other modules from declaring their own instances.
10:31:23 <cocreature> and if you have multiple functions that belong together, just put them in a record
10:31:39 <Shimapan> jle`: Or having access to the local instance. Like a twisted version of functional dependencies but for type classes.
10:32:33 <Shimapan> Cale: I suppose. I simply think it's unfortunate that I can't used the existing generalization that is available to me (MonadIO) :(
10:32:48 <jle`> you can use it
10:32:59 <Shimapan> jle`: *Locally.
10:32:59 <jle`> myLift = MyConstr . liftIO :)
10:33:30 <Cale> (note that I also suggested that above)
10:33:36 <jle`> at least, you're taking advantage of it
10:35:05 <Shimapan> Thanks for the talk.
10:35:19 <Shimapan> It's much clearer now. I'll go with the myLift approach.
10:35:35 <Shimapan> @karma++ jle` 
10:35:35 <lambdabot> jle`'s karma raised to 30.
10:35:37 <Shimapan> @karma++ Cale
10:35:37 <lambdabot> Cale's karma raised to 84.
10:38:26 <jle`> no problem!
10:39:38 <EvanR> @karma++ lambdabot 
10:39:38 <lambdabot> lambdabot's karma raised to 34.
10:55:50 <reactormonk[m]> I'm trying to understand Eff - I'm not sure which property allows it to reorder computations.
11:01:56 <Jenaf> hi there! I've got some beginners Problems with data/type declaration
11:02:32 <Jenaf> I wanted to use simething like data RelativeCoordinates = (double,double)->MasterCoordinates
11:02:43 <Jenaf> but ghci doesn't want to parse that. 
11:02:58 <Jenaf> Is there a way to define a type or data structure wich is a function?
11:03:04 <glguy> Jenaf: You need to specify the value-level constructor
11:03:15 <glguy> data TypeConstructor = ValueConstructor (Field -> Type)
11:03:30 <cocreature> something like "data RelativeCoordinates = RelativeCoordinates ((double, double) -> MasterCoordinates)"
11:03:37 <geekosaur> or were you looking for a type alias?
11:03:45 <glguy> and then probably capitalize Double
11:03:53 <geekosaur> (which doesn't require a constructor, but is also indistinguishable from the original type)
11:04:06 <Jenaf> That was a type here with the lowercase Double
11:04:24 <cocreature> types never have lowercase names
11:04:34 <Jenaf> I'd rather have something more than an alias because iw ant typechecking and patternmatching help me to net get confused and spot errors
11:04:35 * geekosaur thinks "type" in that last was "typo"?
11:04:41 <geekosaur> (use/mention funny?)
11:04:49 <cocreature> oh right
11:04:57 <Jenaf> sorry I'm not good at using keyboards
11:05:59 <cocreature> Jenaf: if you want a separate type then what glguy or I showed should do the trick
11:06:17 <Jenaf> I definetly want it.
11:06:43 <Jenaf> I'm transforming between 2d coordinate systems. And using a strict typing I can reduce the ammount of unspottet errors
11:08:47 <Jenaf> just making an lpaste
11:10:09 <Jenaf> seems like lpaste does not like me today
11:10:51 <Jenaf> http://lpaste.net/354339
11:10:55 <Jinxit> how would one write (Applicative f, Applicative g) => g (f (a -> b)) -> g (f a) -> g (f b)?
11:11:13 <Jenaf> here we go line 6 doesn't parse
11:11:49 <cocreature> Jenaf: you need a constructor name
11:11:59 <cocreature> newtype MyPath = MyPath [MyPathStep]
11:12:05 <jle`> :t liftA2 ($)
11:12:06 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
11:12:07 <Jenaf> even if I use newtype?
11:12:10 <jle`> :t (liftA2 . liftA2) ($)
11:12:11 <lambdabot> (Applicative f, Applicative f1) => f1 (f (a -> c)) -> f1 (f a) -> f1 (f c)
11:12:13 <cocreature> Jenaf: yes
11:12:18 <jle`> ^ Jinxit 
11:12:21 <Jinxit> neat, thanks
11:12:38 <Jenaf> then (please bear with me) does line 2 work?
11:12:42 <jle`> alternatively liftA2 (<*>) should work
11:12:53 <jle`> :t liftA2 (<*>)
11:12:54 <lambdabot> (Applicative f, Applicative f1) => f1 (f (a -> b)) -> f1 (f a) -> f1 (f b)
11:13:00 <cocreature> Jenaf: line 2 looks fine
11:13:12 <Jenaf> I know, btu why don't I need a constructor name there
11:13:14 <Jenaf> ?
11:13:14 <jle`> but (liftA2 . liftA2) ($) reads more clear to me for some reason
11:13:25 <cocreature> Jenaf: "RelCoord" is the constructor name
11:13:30 <Jinxit> the latter is clearer to me
11:13:39 <Jinxit> but i'm not used to seeing $ outside of avoiding parenthesis
11:13:54 <Jenaf> newtype MasterCoord =(Double, Double)
11:13:57 <jle`> Jinxit: ($) here means 'apply the function'
11:13:59 <Jenaf> I ment that line
11:14:09 <cocreature> Jenaf: oh that shouldn’t work either
11:14:09 <pikajude> you do need a constructor name there
11:14:12 <pikajude> that's invalid
11:14:16 <jle`> Jinxit: so liftA2 ($) :: f (a -> b) -> f a -> f b
11:14:20 <jle`> "lift function application"
11:14:30 <Jinxit> oh that makes sense
11:14:38 <geekosaur> Jenaf, a value constructor is how haskell tracks the type. so you need it for data or newtype which give you things that behave as distinct types, but don't use it for type which gives you an alias to an existing type
11:14:40 <jle`> (liftA2 . liftA) ($) :: g (f (a -> b)) -> g (f a) -> g (f b)
11:14:44 <jle`> Jinxit: "lift function application twice"
11:14:52 <Jenaf> okay
11:15:07 <Jenaf> i think I'm getting a bit closer to actually understanding it.
11:15:14 <jle`> (liftA2 . liftA2 . liftA2) ($) :: h (g (f (a -> b))) -> h (g (f a)) -> h (g (f b))
11:15:25 <jle`> Jinxit: "lift function application three times"
11:15:27 <jle`> etc.
11:15:40 <Jinxit> yeah i see the pattern
11:15:59 <jle`> Jinxit: synatictically, a newtype declaration is the same as a data declaration
11:16:01 <jle`> * Jenaf 
11:16:09 <jle`> Jenaf: so all the rules apply
11:16:30 <Jenaf> Yeah I think I understood it so far.
11:16:35 <jle`> the extra syntactic restriction is that you must have exactly one constructor and one field
11:16:42 <Jenaf> I'll pop up again on my next blunder
11:16:43 <jle`> Jenaf: so if 'data' would require a constructor, so would 'newtype' :)
11:17:46 <Jenaf> would you say it's a good idea to avoid data/newtype unless you explicitely want pattern matching or type safety?
11:18:00 <jle`> it's a good idea to use them
11:18:10 <Jenaf> yay I've had a good idea!
11:18:23 <jle`> cause the compiler will help you write your code more nicerly
11:18:28 <cocreature> Jenaf: well the only reason to use “newtype” is that you gain type safety. but gaining type safety is great, so that’s a pretty strong reason to use it!
11:18:47 <Jenaf> thats the reason I started using it ^.^
11:18:52 <javjarfer> hi everyone!
11:19:01 <jle`> hello javjarfer !
11:19:04 <Sonolin> hello
11:19:14 <Jenaf> also I'ts always impressive how helpfull you guys 'n' Gals in here are! hanks a lot
11:19:14 <javjarfer> Has anyone used the (awesome) package dependent-map? 
11:19:44 <javjarfer> Jenaf, Sonolin, hey there :)
11:19:59 <jle`> javjarfer: i believe i've used it
11:20:00 <glguy> javjarfer: If you have a real question about the package it's better to just ask that
11:20:14 <jle`> but even if i haven't, just ask your question :)
11:20:53 <javjarfer> glguy, of course I have a question, HOW did you use it xD?
11:21:06 <jle`> like, what sort of applications did we use it for?
11:21:09 <javjarfer> sorry, it was for jle`
11:21:24 <cocreature> iirc I’ve used it in combination with reflex
11:22:03 <javjarfer> jle`, it's that I have just tried to use it today, but the example from the README is broken
11:22:16 <augur> anyone know if its possible to use GHC to extract the types for some code?
11:22:26 <javjarfer> I have opened and issue just today
11:23:27 <javjarfer> augur, well, it really should be possible because GHCI does it
11:23:39 <jle`> oh it looks like i used it with the singletons library to write Binary instances
11:23:44 <jle`> that was cute i guess
11:24:03 <jle`> augur: ghc-mod might be the smoothest route there
11:24:21 <jle`> javjarfer: what's the error for the readme code?
11:25:06 <augur> jle`: oh? tell me more
11:25:13 <geekosaur> augur, generally people wrap ghc-mod or etc., although you can use ghc-api (or wrappers like hint) or do like intero and use recent ghci (or ghci-ng if needed for an older ghc) to extract them
11:25:35 <javjarfer> jle`, it's detailed in this issue, https://github.com/mokus0/dependent-map/issues/15
11:25:37 <augur> for instance, i *believe* that liquid haskell somehow manages to do stuff like this, right? it hooks into GHC and gets Core terms, and also maybe some types somewhere/somehow???
11:25:40 <jle`> lambdabot uses ghci i think
11:25:57 <jle`> ghc-mod hooks into ghc and abstracts over the super unstable ghc api i believe
11:26:05 <javjarfer> but basically it infers the tag, as being the type of the future maps parameters
11:26:09 <javjarfer> don't know why
11:27:05 <jle`> augur: a lot of editor/ide plugins use ghc-mod i believe
11:27:35 <jle`> javjarfer: where are you getting FooGADT from
11:27:38 <javjarfer> Jenaf, augur I would say that almost all of them
11:28:03 <javjarfer> I'm getting it from the dependent-sum package I think
11:28:36 <javjarfer> Could that be really the problem?
11:28:51 <jle`> javjarfer: from here? https://github.com/mokus0/dependent-sum/blob/master/examples/FooGADT.hs
11:28:56 <jle`> not sure, just trying to diagnost the problem
11:28:57 <javjarfer> yes
11:29:05 <jle`> because the behavior should depend on the types of Foo and Bar
11:29:06 <augur> ok i'll take a look at ghc-mod then :)
11:29:41 <javjarfer> jle`, yes that should be the whole point
11:29:57 <jle`> augur: ghc-mod uses the ghc api, so you could directly use that, i believe.  but it abstracts over it and makes it a little more stable
11:30:47 <augur> okiedoke
11:31:54 <cocreature> augur: https://github.com/hdevtools/hdevtools/blob/master/src/Info.hs#L47 might serve as an example fo how to use the “raw” ghc api
11:33:56 <jle`> javjarfer: it looks like tag expects items in a functor
11:34:15 <jle`> and now the library parameterizes the map by that functor
11:34:27 <jle`> i'm not sure if this is a new change, maybe previously the functor was Identity by default
11:34:52 <sophiag> does anyone have time to look at this paste? there are a bunch of errors appended, but i've commented the two problem lines where i'm not sure what do: http://lpaste.net/354336
11:34:58 <jle`> javjarfer: try x = fromList [Foo :=> Identity pi, Baz :=> Identity "hello there"]
11:35:34 <javjarfer> jle`, yes! I tried the identity trick but I don't remember why I stopped
11:35:58 <javjarfer> I think that was because I didn't get a conclusion of "why I really needed it"
11:35:59 <jle`> i'm not sure if the readme was with a version where the f was fixed to Identity
11:36:26 <jle`> it's because (:=>) :: tag a -> f a -> DSum tag f
11:36:54 <jle`> so if your tag a is 'Foo String', then the second argument shold be 'f String' for some f
11:39:04 <jle`> javjarfer: i don't think the readme would have ever worked
11:39:08 <jle`> even in old versions
11:39:33 <jle`> this is why doctests are important, folks
11:39:48 <javjarfer> haha yes, please, listen him
11:39:56 <jle`> (but i should be the last one to be talking)
11:40:19 <javjarfer> (of course, but that wasn't the point true? :) )
11:40:22 <jle`> (because most of my packages have 0% test coverage)
11:40:45 <javjarfer> we should != I do xD
11:41:12 <javjarfer> jle`, okay... thanks you, I think I get the why
11:41:27 <javjarfer> but now let's make this output something xD
11:42:50 <javjarfer> now of course it complains that the first type is (Identity v) instead of v
11:44:56 <Jenaf> is there a simple way to exclude the equality of two parameters of foo :: Foo -> Foo -> b ?
11:45:08 <Jenaf> like have an error or exception when that happens
11:45:43 <Jenaf> getRelCoords (a,b) (a,b)     = error("undefined relative coordinates") doesn't work
11:47:00 <cocreature> getRelCoords a b | a == b = error "undefined relative coordinates"
11:47:36 <Jenaf> time ofr copy and paste ProgramminG!
11:49:21 <cocreature> Jenaf: the name for this is “pattern guard”
11:49:41 <cocreature> iirc it’s explained pretty well in http://learnyouahaskell.com/syntax-in-functions (search for “guard”)
11:50:28 <glguy> pattern guards are when you start doing:  | Just x <- y
11:51:15 <geekosaur> right, that's just a normal guard, not a pattern guard
11:51:29 <Jenaf> okay
11:51:34 <Jenaf> something is broken
11:51:53 <cocreature> oh good point
11:52:03 <Jenaf>  * The function `relCoord' is applied to one argument,
11:52:05 <Jenaf>    but its type `RelCoord' has none
11:52:06 <Jenaf> --snip
11:52:08 <Jenaf> newtype RelCoord    = RelCoord ((Double, Double) -> MasterCoord)
11:52:09 <Jenaf> --snip
11:52:37 <Jenaf> so something is wrong there
11:52:52 <monochrom> Please paste complete verbatim uncut code.
11:52:58 <Jenaf> okay
11:53:00 <cocreature> Jenaf: where’s the lowercase "relCoord" coming from?
11:53:02 <glguy> If relCoord :: RelCoord, then you can't just apply relCoord to an argument
11:53:14 <glguy> because its type is distinct from the type of functions
11:53:15 <Jenaf>  where relCoord = getRelCoords start end 
11:53:29 <Jenaf> perhaps I need to really make a constructor
11:53:38 <Jenaf> full lpaste incoming (with some comments)
11:54:43 <Jenaf> http://lpaste.net/354343
11:55:30 <cocreature> Jenaf: you need to pattern match to remove the RelCoord constructor before you can apply it
11:56:07 <javjarfer> jle`, Am I wrong if I say that the function described as addFoo cant exist as defined
11:56:27 <javjarfer> because it needs to combine the value inside the two functors?
11:56:49 <Jenaf> @cocreature how to?
11:56:49 <lambdabot> Unknown command, try @list
11:57:25 <cocreature> Jenaf: try writing a function "RelCoord -> (Double, Double) -> MasterCoord"
11:57:53 <cocreature> Jenaf: or alternatively just change the where clause to RelCoord relCoord = getRelCoords start end"
11:58:10 <Jenaf> i think I'll go for the latter
11:58:29 <akegalj> hey. How come there is no WSS (websockets over TLS) implementation in Haskell. Its hard to grasp that no-one had this usecase so far ?
12:00:34 <jaspervdj> akegalj: Do you want server-side or client-side?
12:01:53 <akegalj> jaspervdj: I would like to have wss between client (browser) and server (haskell server).
12:02:13 <akegalj> jaspervdj: can I manage this with warp-tls + wai-websockets ?
12:02:17 <jaspervdj> akegalj: The server in the websockets package does not support TLS (and it not meant for production)
12:02:36 <jaspervdj> akegalj: But yeah if you use warp+tls + wai-websockets it should work, same for snap+websockets-snap
12:03:19 <akegalj> jaspervdj: then we have the solution. Thanks <3
12:06:41 <dberg> How does this expression work? data Expr f = In (f (Expr f))
12:07:04 <dberg> This is from the paper Data types a la carte.
12:07:55 <dberg> The example is data Val e = Val Int; type IntExpr = Expr Val
12:08:00 <monochrom> There are examples in the paper too, though few.
12:08:00 <javjarfer> jle`, okay, if you give this definition, it keeps working
12:08:58 <dberg> I'm having a hard time understading how the substitution would work in the data Expr definition.
12:08:59 <javjarfer> sorry, 'it works' "addFoo :: (Applicative f) => Foo v -> f v -> f v -> f v"
12:09:07 <monochrom> Expr Val is going to be boring, but a typical value is "In (Val 5)"
12:09:23 <cocreature> dberg: IntExpr is actually fairly boring if you look at it: in that case you have In (Val (Expr Val)) but val ignores it’s type argument
12:09:26 <javjarfer> it only need to be a "Type Constructor" of type * -> *
12:10:26 <monochrom> I am not sure that you should think in terms of substitution.
12:10:37 <javjarfer> No matter what, so of course Identity works using the Applicative interface, thanks you so much for the explanation you will be mention in the issue solving jle` !
12:10:47 <ij> 1. does building static pkgs with stack require just --ghc-options='-static -fPIC'? 2. Do I've to build all deps with the same flags first too?
12:12:28 <dberg> Ok, so given In (Val (Expr Val)), when In (Val 10) is given, the inner Expr Val is "replaced" by 5? I'm obviously missing something here.
12:12:48 <monochrom> Instead, Val 5 :: Val e, therefore you can specialize it to Val 5 :: Val (Expr Val), therefore In (Val 5) :: Expr Val.
12:13:14 <monochrom> Eh? You are replacing type by value. That won't help.
12:13:26 <javjarfer> jle`, the incredible thing about this (I don't know if you are interested in reactive systems) is that, the UNIQUE TYPE SAFE way to create a reactive system which network could be inspected and recomputed, or even parsed from a declarative schema, is using this kind of structure
12:17:17 <dberg> monochrom: that was a good explanation. thanks!
12:21:18 <EvanR> javjarfer: proof?
12:22:30 <sophiag> trying asking this again. i'm unsure how to structure this parser where i use two state monads to cons input into lists and then need to pass the final state to eval when it's called. here's what i have so far, complete with the REPL boilerplate: http://lpaste.net/354336
12:22:51 <EvanR> two state monads o_O
12:24:25 <sophiag> EvanR: what's wrong with that?
12:24:55 <EvanR> is there a good reason to use two?
12:26:00 <sophiag> it's just simpler. particularly given how i'm calling them from parsers
12:26:24 <EvanR> i see you have no parsers here in the sense of parsec
12:26:34 <sophiag> i'm not using parsec, that's correct
12:26:45 <EvanR> and you do not actually use your state monads because theres no runState or similar
12:27:12 <Aruro> do people use ansi-wl-pprint?
12:27:15 <sophiag> i know. that's part of the question i asked and also noted in a comment
12:27:46 <EvanR> I dont see even one state monad helping here
12:27:48 <sophiag> i do wonder if i combined them into one parser if it would be easier to call the eval function on the state?
12:27:57 <sophiag> um what?
12:28:02 <javjarfer> EvanR, working on it! xD
12:28:29 <sophiag> EvanR: there are two state monads...you can search for the word state if that helps?
12:28:47 <EvanR> i dont see even one state monad being a help
12:29:04 <EvanR> being better than not using any state monads
12:29:06 <sophiag> can you elaborate on what "being a help" means?
12:29:18 <sophiag> i need to collect a list
12:29:51 <sophiag> if by "being a help" you mean "not being called correctly" then please reference my original question
12:29:51 <EvanR> do you need to access the list too, within the parser?
12:29:57 <EvanR> no i dont
12:30:26 <EvanR> i am saying i have rarely seen State by itself being beneficial over regular functional programming, if ever
12:30:41 <sophiag> monads are "regular functional programming" ...
12:31:05 <EvanR> well, nevermind then, that invalidates what i said somehow
12:31:37 <EvanR> i think you can do this in a simple way without State
12:31:40 <EvanR> simpler
12:31:53 <EvanR> is my last attempt
12:32:45 <sophiag> how so?
12:33:48 <EvanR> for example, in an algorithm which simply collects results into a list, you can pass a list around and prepend things to it
12:34:15 <Knoxrgy> Hi, anybody to talk about OpenWrt?
12:35:01 <dolio> OpenWrt is off topic.
12:35:04 <sophiag> EvanR: if a parser needs to pass it to itself then that parser would have to be a state monad...
12:35:10 <monochrom> Or better yet, don't even pass a list around. Produce the final list right away, like map and unfoldr do. new_item : recursive_call
12:35:22 <EvanR> right, that is what i mean
12:35:48 <EvanR> sophiag: that is not the case
12:36:09 <sophiag> EvanR: so you're proposing one large state monad that both handles parsing and stores two types of state is simpler than three functions?
12:36:22 <Aruro> he proposes function with arguments
12:36:26 <Aruro> no monads
12:37:07 <EvanR> parsing is usually, but not necessarily a bigger pain in the ass than "state", and monadic parsing could help
12:37:12 <EvanR> but i dont know what language youre dealing with
12:37:14 <sophiag> monochrom: if you're producing the list all at once then where do you store the input as it comes into the REPL?
12:37:45 <EvanR> incrementally processing input from a repl is yet another task that can be decomposed
12:37:59 <monochrom> the input is understandably a parameter. like map and unfoldr, again.
12:38:00 <EvanR> each stage is a separate problem, luckily
12:38:25 <EvanR> iteratees, pipes, machines
12:38:30 <EvanR> or "regular functional programming"
12:38:47 <sophiag> EvanR: you just suggested i *recompose* three functions into one. nothing you've said here has made any sense to me whatsoever. use monads, don't use monads, write a language without parsing, etc.
12:38:53 <EvanR> no i did not
12:39:32 <sophiag> monochrom: can you expound on that? you type arguments into a REPL, but don't store them in a list. where do they go?
12:40:13 <Aruro> sophiag: do u need to realize repl yourself? you could use things like haskeline
12:40:16 <EvanR> depending on the language parsed, you may not need to store any inputs at all
12:40:25 <EvanR> zero lookahead
12:40:39 <EvanR> or lookbehind
12:40:50 <sophiag> EvanR: i do.
12:41:03 <sophiag> Aruro: the REPL works fine
12:41:18 <monochrom> You saw the code of map? You saw the code of unfoldr?
12:41:22 <sophiag> guys, i'm really just looking for answers to the specific question i asked
12:41:23 <EvanR> each state of the parser can be a function, whatever data it needs to remember can be in a closure
12:41:53 <sophiag> EvanR: wow, it's almost like...that's exactly what i'm doing now...
12:41:59 <EvanR> it takes the next character and returns the new parser
12:42:08 <EvanR> or the final answer
12:42:17 <EvanR> or an error
12:42:37 <Gurkenglas> https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/time-1.2.0.3/Data-Time-Clock.html how do I get the picoseconds out of a DiffTime, in order to multiply them by a factor before putting them back?
12:43:44 <EvanR> DiffTime and NominalDiffTime are Nums
12:44:02 <EvanR> hmm
12:44:11 <monochrom> Gurkenglas, you're using GHC 7.0.4?
12:44:58 <merijn> Looks like someone needs to get Hackage-Fu :p
12:45:12 <EvanR> diffTimeToPicoseconds :: DiffTime -> Integer
12:45:19 <Gurkenglas> That's what google gave me for Data.Time.Clock and the ghci im teamviewering to here seems not to have diffTimeToPicoSeconds so Im assuming that closer than the other versions of that package I found
12:45:53 <EvanR> seems like a glaring omission from that version of the lib
12:46:21 <Gurkenglas> (I'm now doing all the multiplication on the picoseconds side and only making difftimes temporarily when i need them
12:46:43 <Gurkenglas> * - yay for lessons derived from lifting functions into monads!)
12:49:22 <monochrom> Gurkenglas, DiffTime is a Num instance, you can do arithmetic directly without conversion.
12:49:47 <Gurkenglas> monochrom, where do I get the factor? (It's between 0 and 1.)
12:49:58 --- mode: ChanServ set +o geekosaur
12:50:00 <Gurkenglas> You shouldnt exactly be able to multiply times to get times
12:50:11 <EvanR> its a Num and a Fractional so you can multiply by 1/10 for example
12:50:14 <monochrom> Admittedly, (5 :: DiffTime) * your_DiffTime "doesn't make sense" according to physicists' dimension analysis.
12:50:16 --- topic: set to 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017' by geekosaur
12:50:19 --- mode: geekosaur set -o geekosaur
12:50:40 <EvanR> yeah the units are wrong
12:50:47 <monochrom> But it really does multiply your time by 5.
12:51:07 <EvanR> Gurkenglas: are you sure you dont want to use NominalDiffTime
12:51:22 <EvanR> so you can actually communicate with UTCTime
12:52:03 <Gurkenglas> Not my code, I seem to be getting a type clash between the two right now
12:52:26 <EvanR> you can only cross between Nominal and NonNominal by using leap second tables
12:53:35 <Gurkenglas> Ah there, NominalDiffTime is to UTCTime as vectors to points
12:54:02 <EvanR> right
12:59:20 <Gurkenglas> Maybe I'm going about this wrong. How do I make a thread wait for a given amount of picoseconds?
13:00:46 <semigroup> Is there an easy way to suppress warnings about OverlappingInstances being deprecated? -fno-warn-warnings-deprecations doesn't suppress it for me. 
13:00:53 <geekosaur> picoseconds isn't a thing, I think. threadDelay does nanoseconds
13:01:15 <merijn> semigroup: You mean, besides the obvious "stop using OverlappingInstances"? :)
13:02:45 <semigroup> merijn: Yup, I'm adding a package that uses it my build and don't want to patch it right now
13:03:22 <geekosaur> once debian stops shipping 7.6...
13:03:36 <merijn> semigroup: The only other thing I can say "have you tried checking the GHC manual?"
13:05:02 <merijn> I forget: Where do I find Fix/Mu?
13:05:57 <tolt> merijn: Control.Monad.Fix?
13:06:21 <merijn> tolt: No, that's MonadFix for mfix
13:06:48 <merijn> I mean the recursive functor type
13:07:00 <tolt> oh sorry, thought I would be quick
13:07:02 <tolt> Yeah
13:07:25 <merijn> Else I'll just have to define my own
13:08:26 <lyxia> http://hackage.haskell.org/package/recursion-schemes-5.0.1/docs/Data-Functor-Foldable.html#t:Mu
13:08:41 <klottie> Can a 'where' clause consist of only a 'let in' clause?
13:08:48 <semigroup> merijn: Found -fno-warn-warnings-deprecations in the manual, but I guess I'm using it wrong
13:09:11 <merijn> semigroup: I think that's for deprecation pragmas, not deprecated pragmas
13:09:31 <geekosaur> klottie, no, where is kinda an upside-down let-in
13:09:31 <dmj`> there’s no way to pattern match on a type synonym in a closed type family… is there?
13:09:54 <merijn> dmj`: What makes you say that?
13:10:23 <dmj`> merijn: because I tried, and I get a overlapping patterns warning
13:10:32 <dmj`> s/a/an
13:10:51 <merijn> dmj`: How much hackiness and convolution are you willing to put up with?
13:11:22 <dmj`> merijn: I’d be willing to try anything at this point
13:11:35 <Gurkenglas> How did you fix that thing where you have to confirm all stdin input by pressing enter?
13:11:55 <dmj`> merijn: how much hackiness are we talking though
13:12:32 <lyxia> type S a = Maybe a ; type family F a where F (S a) = a ; F a = a    compiles silently...
13:12:35 <merijn> dmj`: So I have this hacky implementation of type level `elem`, which should be trivial to turn into a type level Eq, which should let you write type level case
13:12:44 <merijn> dmj`: https://gist.github.com/merijn/6130082
13:12:45 <klottie> geekosaur: So is this invalid "foo f where let g = 5 in foo f = replicate g f"
13:13:06 <merijn> klottie: Well, what's the point of having "let" there?
13:13:20 <geekosaur> klottie, yes, that is invalid. in fact it looks rather broken, redefining foo like that
13:13:33 <merijn> klottie: You could just write "where { g = 5; foo f = replicate g f }" directly
13:13:49 <geekosaur> Gurkenglas, hSetBuffering stdin NoBuffering (and I wish ghc didn't conflate that with termios...) (also, unix only; windows does something different but I don;t know details off the top of my head)
13:14:21 <Gurkenglas> Ah this guy already had that but hes using windows.
13:14:22 <dmj`> merijn: have you tried this with synonyms
13:14:31 <merijn> dmj`: ah...no
13:14:34 <lyxia> dmj`: what's the type family you're having problems with
13:14:47 <lyxia> dmj`: I just showed an example of a type family with a type synonym.
13:15:15 <dmj`> lyxia: did you compile with -Wall
13:15:51 <Gurkenglas> https://ghc.haskell.org/trac/ghc/ticket/2189 around since 9 years ago, touched 2 weeks ago, last post was asking for a workaround. :(
13:16:09 <ij> barrucadu, Hi. Can the irc-client-1.0.0.0 receive msgs while a handler is running? I'm implementing a "bot status/multi ping" command and it doesn't work in 1.0.0.0 any more. http://sprunge.us/jQRe
13:16:26 <lyxia> dmj`: I did
13:17:18 <dmj`> lyxia: type SK a = Maybe a; type SS a = Maybe a;  F (SS a) = a; F (SK a) = a; shows an overlap
13:17:18 <dmj`> can’t differentiate on type synonyms
13:17:33 <lyxia> ok that's what you meant
13:17:47 <klottie> merijn: geekosaur: thank you.
13:18:20 <lyxia> dmj`: I can't see how that could work. What is that for?
13:19:11 <merijn> dmj`: oh, that's what you meant
13:19:18 <merijn> dmj`: Well, why wouldn't those overlap?
13:19:33 <dmj`> lyxia: for an idea
13:20:00 <dmj`> merijn: they would, but I was hoping they could be treated separately with an extension or other
13:20:45 <dmj`> lyxia: I’m using a type family on the Generic Rep of an ADT. I’d like to treat type synonyms specially in certain cases
13:21:10 <geekosaur> afaik a type synonym is exactly that and cannot ever be treated specially
13:22:04 <dmj`> geekosaur: I see, sigh
13:22:09 <geekosaur> "type alias" is a better name for them
13:23:43 <dmj`> geekosaur: Was hoping in the same way type synonym instances lets you differentiate on type synonyms in type class, the same could be done with a family.
13:24:01 <dmj`> in a type class instance
13:24:03 <geekosaur> uh type synonym instances don't work that way in typeclasses eithger
13:24:40 <geekosaur> you can;t for example have different instances for String and [Char], all you can do with the extension is say String instead of [Char] in the instance declaration
13:24:41 <merijn> Yeah, TypeSynonymInstances just lets you avoid writing out the full type
13:25:04 <geekosaur> which is normally forbidden as a reminder that they are the same thing and *cannot* be differentiated
13:26:12 <ij> I want to make a type that has a "true type" and a "false type", both with string inside and a monoid that'd be concat on true<>true and false<>false, but with my own monoid instance code otherwise. Can I use some existing code or is this something totally new?
13:26:12 <codedmart> Is there a built in function to convert a Tuple to a List?
13:26:18 <codedmart> Can't seem to find one.
13:26:23 <dmj`> merijn, geekosaur: Ah, yea, my mistake
13:26:37 <merijn> codedmart: No, because that doesn't make sense, in general
13:27:58 <codedmart> I have (Word32, Word32, Word32, Word32) and I want to go to Text. So my intial thought was to convert to List then intercalate.
13:28:24 <merijn> codedmart: honestly, simplest would just be to write that function out
13:28:34 <codedmart> OK fair enough
13:28:49 <codedmart> Thanks
13:28:56 <merijn> \(a,b,c,d) -> [a,b,c,d]
13:32:41 <cocreature> I’m disappointed. even lens doesn’t seem to have a function for that
13:33:19 <geekosaur> tuple to list? that's going to be Hard
13:33:30 <cocreature> geekosaur: well it exists for two tuples
13:33:36 <cocreature> > (1,2) ^.. both
13:33:38 <lambdabot>  [1,2]
13:33:44 <geekosaur> sure, the problem is it has to be done separately for each tuple size
13:33:50 <cocreature> ofc
13:34:08 <cocreature> but lens already does that for things like _1 so I wouldn’t be surprised if something exists for this as well
13:35:53 <barrucadu> ij: I decided to remove the concurrency in the handlers (a little rationale here: https://github.com/barrucadu/irc-client/pull/40), so if you want to have handlers run for a while without delaying handling of future messages, you'll need to use the `fork` function exported from Network.IRC.Client.
13:42:30 <ij> barrucadu, Ah, thanks!
13:44:36 --- mode: ChanServ set +o dibblego
13:44:39 --- mode: dibblego set -b *!*@nat184.lu.usi.ch
13:44:47 --- mode: dibblego set -o dibblego
13:46:22 <hexagoxel> > (1,2,3) ^.. each
13:46:24 <lambdabot>  [1,2,3]
13:48:12 <hexagoxel> :t (^.. each)
13:48:13 <lambdabot> Each s s b b => s -> [b]
13:55:00 <lyxia> codedmart: you can do this using one-liner
13:56:24 <lyxia> codedmart: gfoldmap (For :: For ((~) Word32)) (:[]) :: (Word32, Word32, Word32, Word32) -> [Word32]
13:56:50 <lyxia> it's longer than \(a,b,c,d) -> [a,b,c,d] but it's polymorphic
14:13:31 <jgt> No instance for (Monoid (R.Redis (Either R.Reply [ByteString])))
14:13:32 <jgt>       arising from a use of ‘concatMap’
14:13:37 <jgt> this means I have to write the instance, right?
14:14:07 <lyxia> or that a Redis is not a monoid.
14:14:11 <jle`> jgt: well, it depends on what you want to do
14:14:29 <jle`> usually, orphan instances aren't the answer
14:14:58 <jgt> jle`: `ids <- ExceptT $ concatMap (\d -> R.zrangebyscore ("companies:date:" <> d) 0 99999999) (map (C8.pack . filter isDigit . showGregorian) days)` is what I'm trying to do
14:15:13 <jgt> I have a list of days
14:15:27 <jle`> looks like you want mapM, and then fmap concat, maybe
14:15:29 <jgt> I want to get all the values of a sorted set for each day
14:15:44 <jgt> yeah, maybe I want a mapM
14:16:04 <jle`> if you are mapping an (a -> m b), then usually yeah you want traverse or mapM
14:18:09 <jle`> i'd factor out the thing you're (map (...) days) and give it its own nam
14:19:12 <jgt> yeah, that'll happen
14:19:13 <MarcelineVQ> jle`: did you tell me about  (f <.> g) x = f <$> g x  ?
14:19:17 <jgt> but, one thing at a time :)
14:19:29 <jle`> MarcelineVQ: what is <.> ?
14:19:41 <jle`> from 'filepath' ?
14:20:08 <MarcelineVQ> no that's the whole definition here, fmapped composition
14:20:25 <jle`> oh, yeah, i haven't seen that
14:20:32 <MarcelineVQ> ah dang, trying to attribute the tricks listed in my utility lib
14:21:00 <MarcelineVQ> maybe it was pjdelport
14:30:48 <iqubic> How are people.
14:30:50 <iqubic> ???
14:31:06 <adamisntdead> I'm good how are you
14:31:17 <iqubic> I just learned about arrows? How often are they used in actually Haskell programs?
14:31:37 <jle`> well
14:31:38 <adamisntdead> Ah never heard of them, but I am only starting out haha
14:31:44 <jle`> certain arrow instances are used very often
14:31:55 <jle`> but Arrow as a generic abstraction is not used very often in modern Haskell
14:31:59 <iqubic> LOL. Yeah.
14:32:13 <jle`> the Arrow abstraction was hot in the early 2000's, but fell out of favor when Applicative became popular
14:32:31 <jle`> because a lot of the problems that the arrow abstraction was meant to solve ended up being easier when addressed by Applicative
14:32:36 <adamisntdead> Ahh
14:32:53 <iqubic> jle` What does tell do again? In regrads to the writer monad?
14:32:54 <adamisntdead> Looked them up just there but yeah I have seen them
14:33:11 <jle`> but there are still some use cases where Arrow makes sense.  but tehy tend to be more niche
14:33:27 <jle`> the vast majority of situations where the arrow abstraction used to be used for are now covered by Applicative API's
14:33:40 <jle`> iqubic: 'tell x' accumulates x into your accumulator
14:33:56 <iqubic> adamisntdead: Every time you write a function you have a line that looks like this: "int -> int -> int"
14:34:19 <adamisntdead> Yeah I know, I just didnt know there was a name for them
14:34:24 <iqubic> jle`, how does that helps us solve our forM_ challenege from yesterdat.
14:34:25 <iqubic> ??
14:34:31 <jle`> iqubic: well you can use tell to accumulate every item
14:35:08 <jle`> forM_ lets you give a  (a -> Writer [a] ()) that it will run and sequence for every item in a Foldable
14:35:08 <iqubic> You can? how?
14:35:18 <jle`> so you can just give it (\x -> tell [x])
14:35:29 <iqubic> Can I see an example?
14:35:30 <jle`> and now it'll run that function and accumulate all of the x's, for every item in the Foldable
14:35:46 <jle`> accumulateAll :: Foldable t => t a -> Writer [a] (); accumulateAll = mapM (\x -> tell [x])
14:36:00 <JuanDaugherty> yello iqubic , arrows are a sideshow, like FRP and whatnot
14:36:12 <jle`> > execWriter (mapM_ (\x -> tell [x])) "hello")
14:36:14 <lambdabot>  <hint>:1:44: error: parse error on input ‘)’
14:36:19 <jle`> > execWriter (mapM_ (\x -> tell [x]) "hello")
14:36:21 <lambdabot>  "hello"
14:36:25 <JuanDaugherty> a perseveration of CT as a model of computation
14:36:28 <jle`> > execWriter (mapM_ (\x -> tell [x]) (S.fromList "hello world"))
14:36:30 <lambdabot>  " dehlorw"
14:36:47 <jle`> > execWriter (mapM_ (\x -> tell [x]) (M.fromList [(1, 'a'),(10,'b'),(3,'c')]))
14:36:49 <lambdabot>  "acb"
14:37:02 <jle`> > execWriter (mapM_ (\x -> tell [x]) Nothing)
14:37:03 <jle`> etc.
14:37:04 <lambdabot>  []
14:37:25 <jle`> execWriter :: Writer w () -> w; it basically extracts the accumulator
14:37:30 <jle`> it should be called extractAccumulator
14:37:35 <jle`> execWriter is such a weird name
14:38:19 <iqubic> jle` How would I define th function accumlateAll in GHCi?
14:38:29 <jle`> you can write it like i just wrote it
14:38:41 <jle`> you'd have to import Control.Monad.Writer or Control.Monad.Trans.Writer first
14:38:57 <iqubic> I did that.
14:39:11 <jle`> then you're good :)
14:39:26 <iqubic> No, I'm not.
14:39:31 <jle`> what's the issue?
14:40:22 <lpaste> iqubic pasted “accumulateALL issues” at http://lpaste.net/354346
14:40:29 <iqubic> That is the issue
14:40:43 <jle`> you didn't write what i posted
14:41:10 <iqubic> I didn't?
14:41:16 <iqubic> What did I miss?
14:41:17 <jle`> if what you pasted is what you wrote
14:41:21 <jle`> scroll up again and see what i wrote
14:41:25 <jle`> it doesn't begin with 'let'
14:41:46 <jle`> what you wrote was only marginally related to what i wrote, heh
14:42:00 <jle`> you left out half of the stuff and added in extra letters lol
14:42:04 <iqubic> What should I put into ghci?
14:42:08 <jle`> what i wrote earlier
14:42:18 <jle`> i'll re-send it
14:42:29 <iqubic> I have no idea how to view scroll back with irssi.
14:42:29 <jle`> accumulateAll :: Foldable t => t a -> Writer [a] (); accumulateAll = mapM (\x -> tell [x])
14:42:47 <jle`> sorry, it should have been mapM_
14:43:19 <Aruro> does ghc have design flaws?
14:43:20 <iqubic> <interactive>:7:52: parse error on input ‘;’
14:43:42 <jle`> iqubic: what version of GHC are you using?
14:43:48 <SLi> Having tried to get stuff done in Haskell, I have a question. How do you avoid that which seems to happen much more in Haskell than any other language, that you have a problem, you start thinking about whether it fits nicely into some CoWeird model ("it's such a great language, I bet there's a clever way to do it") and suddenly you notice that lots of time has passed and you have no code?
14:43:55 <iqubic> How do I check my version of GHC?
14:44:07 <jle`> when you load up ghci it should tell you
14:44:14 <jle`> but also ghc --version
14:44:25 <iqubic> 7.10.3
14:44:28 <iqubic> Is that old?
14:44:30 <SLi> At best it seems I manage to write some code and then spend 10 times the amount of time polishing it and making it instances of whatever :P
14:44:31 <jle`> SLi: it's all about self-control, really
14:44:52 <jle`> iqubic: it's kind of outdated, yeah
14:45:00 <jle`> um we can fix what i wrote to have 7.10 be happy with it
14:45:08 <iqubic> Can we?
14:45:12 <jle`> let accumulateAll :: Foldable t => t a -> Writer [a] (); accumulateAll = mapM_ (\x -> tell [x])
14:45:16 <Aruro> SLi: its true. haskell is very hyped, people dont think much. many pervious BIG ideas are now forgotten and considered bad
14:45:30 <Aruro> iteratee , arrows, uff u name it
14:45:41 <iqubic> How do I update my GHC version?
14:45:55 <jle`> SLi: haskell doesn't demand that you over-abstract things, but, the temptation is pretty strong in haskell
14:45:59 <jle`> iqubic: how did you install ghc?
14:46:16 <SLi> Aruro: Yeah, that's actually one part of the problem. Whenever I start looking into whether something fits, usually somebody tells me after three days that nobody uses that anymore. I wish this information was somewhere easily accessible :P
14:46:30 <SLi> For example, I didn't know arrows are frowned upon!
14:46:42 <maerwald> SLi: they are not, don't follow all hypes you come across
14:47:00 <iqubic> jle` I used the Gentoo package manager.
14:47:02 <jle`> it's a good idea to check the date of any articles you read
14:47:25 <maerwald> iqubic: emerge -avu world
14:47:50 <iqubic> I'll try that.
14:47:51 <jle`> iqubic: if you want, you can use stack to manage your ghc versions, which is cross platform.
14:48:11 <maerwald> iqubic: the _very_ latest haskell packages are not in the gentoo tree, but in the haskell overlay sometimes
14:48:14 <maerwald> so you might have to add that
14:48:28 <maerwald> but that could blow up your depgraph as well
14:48:28 <iqubic> jle` I have been able to get stack to work on my gentoo machine
14:48:37 <jle`> ah then you can use 'stack ghci'
14:48:58 <jle`> and it'll load up ghci using the default resolver, which you can configure
14:49:10 <maerwald> since haskell packages are a mess of upper bounds, and almost no one seems to understand that upper bounds make the version selection problem np-complete, which is the reason for the so called "cabal dependency hell"
14:49:19 <jle`> lts-8.* resolvers all use ghc 8+ i believe
14:49:34 <iqubic> maerwald: I already have the Haskell overlay installed
14:49:39 <SLi> I never understood why people consider the upper bounds a good idea (except "don't open that can of worms").
14:49:39 <jle`> 7.10 isn't super out of date though, it just happened to be different in that specific example we had
14:49:40 <iqubic> or added rather
14:50:01 <iqubic> jle` what is the latest version of GHC currently out?
14:50:04 <maerwald> iqubic: then you should get latest ghc
14:50:18 <iqubic> How can I do that?
14:50:18 <c_wraith> 8.0.2
14:50:19 <maerwald> iqubic: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-lang/ghc
14:50:28 <maerwald> even 8.2.1_rc1 is there
14:51:49 <iqubic> How do I install stuff from that github branch?
14:51:59 <maerwald> iqubic: ?
14:52:07 <maerwald> sync your repositories
14:52:15 <maerwald> via layman or emerge
14:52:22 <maerwald> read the gentoo documentation
14:52:48 <iqubic> I have synced my repositories.
14:53:05 <iqubic> The latst version of GHC is not being found and added.
14:53:30 <maerwald> emerge -av1 =dev-lang/ghc-8.0.2::haskell
14:54:15 <iqubic> I'll do that once my world finishes updating.
14:54:25 <maerwald> I suspect a user error here
14:54:55 <maerwald> (overlays naturally are unstable arch btw)
14:55:16 <maerwald> but that's also explained in the README
14:56:21 <iqubic> Yeah, I think I just need to go ahead and keyword everything.
14:57:48 <maerwald> iqubic: that will be fun, only keyword */*::haskell rather
14:58:23 <iqubic> That's what I meant to say.
14:58:46 <iqubic> Who here runs XMonad? Just trying to get a feel for the community.
14:59:07 <maerwald> there's probably a xmonad channel is there not?
14:59:33 <iqubic> Yeah.
14:59:57 <iqubic> I just want to see how many Haskellers use XMonad. I don't actually want help with it.
15:00:13 <maerwald> they don't have a configuration format, so I don't like it. Learning a random haskell API vs learning a very simple config format (like i3) is a huge difference
15:00:21 <maerwald> so I don't want to waste my time with xmonad
15:00:43 <maerwald> especially since it involves installing a lot of custom code/plugins
15:01:05 <iqubic> I have no problems with XMonad.
15:01:12 <iqubic> I don't like i3 much.
15:01:14 <maerwald> sure, people say the same about emacs
15:01:26 <sanitypassing> i3 is weird after using XMonad for so long
15:01:30 <iqubic> I don't like emacs either. VIM ALL THE WAY.
15:01:32 <maerwald> it's just that it really lacks a configuration format
15:01:35 <byorgey> iqubic: it's hard to say how many use it.  There's really no way to count.
15:01:40 <sanitypassing> (so long = 7-8 months)
15:01:54 <iqubic> sanitypassing: I have been using XMonad for a year now.
15:02:03 <maerwald> even though I can write haskell, I don't want to be bothered _writing_ haskell in order to configure something
15:02:07 <byorgey> iqubic: I use it. (I have actually used it for... 8 years maybe?)
15:02:19 <iqubic> I just find non-tiling WMs to be a pain in the arse
15:02:33 <erisco> funny when something seemingly simple, like finding dependencies, is actually complicated
15:02:41 <jackhill> maerwald: maybe someone will end up writing a contrib module that reads a config file ☺
15:02:46 <maerwald> erisco: that's because of the input
15:02:48 <jackhill> for the record, I'm an XMonad user
15:03:09 <iqubic> too much RSI from moving between the mouse and keyboard makes non-tiling WMs a pain to use.
15:03:10 <maerwald> erisco: and the input wrt hackage is just off all charts
15:03:34 <sanitypassing> I use XMonad pretty much all the time; I have MATE installed in case someone needs to borrow my computer or I need to run a program that doesn't cooperate with XMonad (and I haven't found workaround yet) though
15:03:46 <maerwald> I guess no one bothered to read about dependency resolution problems when they started writing cabal and applying "best practices" :P
15:04:17 <maerwald> https://research.swtch.com/version-sat
15:04:20 <erisco> why bother because it doesn't sound so difficult at the outset
15:04:41 <maerwald> because currently the only "solution" is sandboxing or freezing states
15:05:12 <iqubic> That's odd.
15:05:26 <iqubic> maerwald: I just tried emerge -av1 =dev-lang/ghc-8.0.2::haskell
15:05:41 <iqubic> And got this: zsh: dev-lang/ghc-8.0.2::haskell not found
15:05:53 <maerwald> then you haven't updated your repositories
15:05:53 <erisco> I am often surprised by how small features have huge implications
15:05:55 <maerwald> fix it
15:06:05 <iqubic> How?
15:06:11 <maerwald> read the gentoo docs
15:06:20 <maerwald> they have a wiki
15:06:27 <iqubic> I have done that. It doesn't help me.
15:06:35 <maerwald> then ask in #gentoo, not here
15:06:40 <ClaudiusMaximus> that's a zsh error, not an emerge error - try 'quotes'
15:06:48 <monochrom> Yes, the cabal creators 10 years ago did not bother to read a December 2016 article.
15:07:03 <maerwald> monochrom: wrong, that was known a long time ago, there's a paper from debian
15:07:05 <maerwald> which is old
15:07:07 <maerwald> google it
15:07:14 <monochrom> Or Knuth's latest Fascicle 6.
15:07:19 <iqubic> Around what ClaudiusMaximus?
15:07:38 <ClaudiusMaximus> iqubic: the =...haskell i guess
15:07:38 <iqubic> Alright, I got it to work
15:07:59 <iqubic> Yeah. I assume ZSH was trying to expand the =...haskell
15:08:16 <iqubic> Looks like ghc 8.0.2 has a bunch of dependencies.
15:10:11 <iqubic> I see now why I can't get a later version of GHC.
15:10:30 <maerwald> iqubic: btw. there's also a #gentoo-haskell channel
15:10:36 <maerwald> where you might get more specific support
15:10:44 <maerwald> because what you're doing now is offtopic here
15:11:06 <iqubic> Yeah, I know.
15:11:43 <lpaste> iqubic pasted “Masked Package” at http://lpaste.net/354347
15:11:56 <iqubic> That's why my version of GHC is so old.
15:12:09 <iqubic> Looks like that's bot going to be fixed any time soon though.
15:12:09 <EvanR> to make a thread wait for a number of picoseconds, round to the nearest microseconds, then (if the result is less than 9 billion billion) convert to Int and use threadDelay
15:15:08 <iqubic> Does XMonad require any specific version of GHC?
15:15:55 <maerwald> iqubic: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/x11-wm/xmonad/xmonad-0.13.ebuild#L27
15:18:51 <iqubic> maerwald: what does that mean?
15:19:06 <maerwald> iqubic: that you need at least ghc-8.0.1
15:20:06 <iqubic> That's can't be right. I have XMonad AND ghc 7.10.3
15:20:20 <iqubic> What is going on???
15:20:33 <maerwald> iqubic: not xmonad-0.13
15:21:10 <iqubic> I have xmonad-0.12
15:21:14 <iqubic> How can I update that?
15:21:31 <maerwald> you really need to go to #gentoo or #gentoo-haskell
15:21:41 <maerwald> you have problems with basic operations
15:21:46 <iqubic> Do I?
15:21:48 <maerwald> yes
15:23:49 <iqubic> How so? Why are you saying that maerwald?
15:24:14 <maerwald> because everything else are non-haskell issues, those are gentoo maintenance issues, which are offtopic here
15:24:22 <maerwald> and those are basic operations (like updating your system)
15:25:52 <maerwald> there are adequate channels where you can get help, as I mentioned
15:27:23 <Aruro> brew was trying to complie ghc on mac, terrible experience.
15:33:32 <lolisa> Hi, suppose I has a open type family, F a :: *
15:34:05 <lolisa> Now, how can I achieve something like Eq a => Eq (F a)?
15:34:54 <veyd> Hello. I'm starting "Programming in Haskell" by Hutton, and he's instructing me to download the Haskell Platform, but I've read that Platform has been largely deprecated in favor of Stack?
15:35:00 <jle`> lolisa: you can't make instances of naked type families like that
15:35:05 <jle`> but you can wrap it in a newtype wrapper
15:35:14 <veyd> This this relevant to just starting out? Should I just go with PLatform and worry about Stack later on?
15:35:15 <jle`> veyd: you'll get varying opinions, and it's not uninamous
15:35:22 <veyd> *Is this
15:35:23 <jle`> but i hear that the platform includes stack these days
15:35:42 <jle`> if you use stack then you just need to prefix your commands with 'stack', like 'stack ghci', 'stack ghc', etc.
15:35:57 <jle`> i'm not really sure what the role of the platform is in the ecosystem these days, but if oyu have stack, you don't need it
15:36:04 <monochrom> Haskell Platform is not deprecated.
15:36:08 <veyd> Well I have zero experinece with 
15:36:11 <lolisa> Yes, but are there other option? F a recursively invoke itself so wrapping it in newtype hurt alot
15:36:11 <veyd> with Haskell
15:36:20 <lordcirth> Leksah just froze while trying to do a simple find+replace in a small project
15:36:26 <veyd> so I'm not sure if I should deviate from the book at all
15:36:28 <jle`> lolisa: the newtype won't add any runtime overhead
15:36:38 <sm> veyd: you'll have to
15:36:51 <veyd> monochrom: so you recommend I just follow the book and use Platform?
15:36:59 <jle`> lordcirth: newtype WrapF a = WrapF (F a)
15:37:02 <jle`> * lolisa 
15:37:06 <monochrom> Yes.
15:37:11 <veyd> sm: why? it's the second edition that just came out in Spt. 2016
15:37:16 <veyd> *Sept
15:37:28 <jle`> lolisa: but i don't think you'll be able to write that instance
15:37:31 <veyd> surely it's not THAT out of date already
15:37:37 <jle`> even if you could have typeclass instances
15:37:37 <lolisa> jle`, I am maniuplating term in EDSL with finally tagless style... so they wont get erased :(
15:37:43 <lolisa> Yeah that's a problem
15:37:50 <jle`> lolisa: because 'Eq a' doesn't ensure that 'F a' is Eq
15:38:01 <sm> well that's true, and the instructions therein might be exceptionally robust, but I'll be amazed if you don't find some changes necessary
15:38:07 <jle`> such as type instance F Int = F (Bool -> Int)
15:38:09 <monochrom> It is OK to check out stack too on the side. But following the book is least confusing if you plan to follow it in the first place.
15:38:11 <lolisa> Yes. I am thinking of using some Data.Constraints trickery to make it work
15:38:28 <veyd> ok, last question and I'm sure you all get this all the time, but what's the best IDE for Haskell?
15:38:39 <lolisa> With associated type, I can add a requirement to make sure it can derive Eq
15:38:50 <lolisa> But than it isnt naked...
15:38:52 <jle`> lolisa: the any Eq a => Eq (F a) instance would be necessarily false
15:38:54 <jle`> it's a lie
15:38:59 <jle`> because of things like what I just wrote
15:39:15 <sm> emacs/vim/atom/idea/vs code get the most votes currently
15:39:42 <lolisa> jle`, what Iam thinking is, when you define the associated type saying F Int is F (Bool -> Int), you have to supply the instance for Eq
15:39:53 <monochrom> In fact, why involve Int in the RHS? F Int = F (Cont Bool String).
15:40:03 <veyd> alright, thanks everyone
15:42:07 <monochrom> That would require sneaking F into the original definition of Show.
15:42:51 <monochrom> Perhaps don't impose this requirement on F itself. Impose on functions that involve F.
15:43:19 <monochrom> operation_number_1 :: Show (F a) => F a -> F a -> F a
15:43:47 <monochrom> (Bad example but still.)
15:44:19 <monochrom> Err, good example if you call Debug.Trace.trace somewhere in there! :)
15:45:15 <monochrom> Err, s/Show/Eq/
15:45:31 <monochrom> and nevermind about trace.
15:47:00 <lolisa> This is probably the best way to go...
15:50:38 <iqubic> Do I need to update to GHC 8?
15:53:48 <iqubic> Will people shun me if I don't use GHC 8?
15:53:53 <monochrom> No.
15:54:13 <monochrom> I think you worry too much.
15:54:46 <monochrom> Maybe two years in the future you will have to update, but there is still no hurry now.
15:55:10 <monochrom> Also it depends on your purpose so no one can answering accurate for you.
15:55:35 <iqubic> monochrom I have too many packages that still rely on GHC 7. So I can't update yet.
15:55:43 <monochrom> I know that many desktop computers in banks are still using OS/2 version 2.1, for example.
15:56:30 <monochrom> And a few small business desktops still using Windows 98 because WinFax.
15:56:49 <dolio> They should upgrade to OS/2 Warp.
15:57:52 <monochrom> An acquaintance who still sticks to mIRC from 1997.
15:59:24 <monochrom> And therefore hates you for using UTF-8.
15:59:49 <Rembane> Latin-1 is the charset of IRC.
16:00:29 <monochrom> No, they reject all non-ascii.
16:29:47 <buff3r> any alternatives to django rest framework you guys like?
16:30:24 <haasn> is there a way to get `criterion` to benchmark functions returning a Double and score the results for a test in the same way as the execution time? Context: I have a slow-but-correct function and a series of incremental approximations that sacrifice some precision for speed. I want to benchmark both the average execution time and the average score for each function. (lower is better for both)
16:31:02 <Rembane> buff3r: Take a look at servant. http://haskell-servant.readthedocs.io/en/stable/
16:31:04 <haasn> ah actually that would require something like Arbitrary as well
16:31:04 <iqubic> Why does alsamixer depend on ghc?
16:32:23 <iqubic> Or rather, what is dev-haskell/alsamixer?
16:35:44 <fDev2179> iqubic, can't answer the question about dev-haskell/alsamixer, but I can say that on my Arch Linux machine, the only dependency for alsamixer is glibc.
16:36:32 <iqubic> Alright then.
16:40:23 <geekosaur> dev-haskell/alamixer would be the haskell bindings to alsamixer; unsurprisingly this requires a haskell compiler
16:40:53 <iqubic> Yeah, I know.
16:41:10 <iqubic> And I have packages that rely on dev-haskell/alsamixer.
16:41:52 <iqubic> So, it looks like GHC 7.10.3 is here to stay.
16:42:11 <iqubic> I have too many things that still rely on GHC 7.10.3
16:44:07 <Welkin> have fun being left in the dust
16:44:26 <iqubic> Why do you say that I'll be left in the dust.
16:44:32 <monochrom> That was unnecessary, Welkin.
16:44:42 <iqubic> When was it that GHC 8 came out?
16:45:02 <Welkin> there exist some people (who know who they are) who won't even use anything from after typeclasses were added to haskell
16:45:05 <Welkin> lol
16:45:38 <monochrom> Welkin, again, it is unnecessary to be snark.
16:46:27 <kadobanana> iqubic: Earlyish last year, maybe June timeframe I think
16:47:22 <iqubic> Ah so how long will it be until packages get around to updating to GHC 8?
16:48:06 <Welkin> iqubic: some never will because they get abandoned
16:48:16 <Welkin> it's just the nature of progress
16:48:40 <kadobanana> iqubic: There's a pretty decent selection that already are, ya all will probably never be.
16:48:45 <Welkin> which packages are you talking about specifically?
16:48:58 <iqubic> XMobar.
16:49:03 <geekosaur> I would expect active packages to be updates already. If you;re not seeing this, and are using stack, you might want to check for more recent resolvers
16:49:08 <Welkin> I have ended up forking or writing my own libraries because existing ones were old (and also not written well)
16:49:23 <monochrom> Those actively maintained have already been updated. If you see a stale one, you can assume it is not actively maintained. You can give a nudge to the maintainer.
16:49:35 <kadobanana> In my limited experience, updating code to ghc8 was quite painless
16:49:36 <Welkin> xmonad is not actively maintained any more I don't think
16:49:42 <geekosaur> uh
16:49:47 <Welkin> or at least not actively developed
16:49:52 <Koterpillar> Welkin: wrong
16:49:53 <geekosaur> 0.13 was just released, welkin
16:49:56 <Welkin> really?
16:49:59 <geekosaur> could you cite your sources?
16:50:07 <Welkin> I thought there were no releases for 2 years
16:50:08 <iqubic> So how long will it be until XMobar will be updated?
16:51:33 <Welkin> lol
16:51:47 <Welkin> you both seem offended that I owould suggest such a thing
16:52:04 <Welkin> I haven't tried xmonad because I couldn't get it working
16:52:09 <Welkin> I just settled on i3
16:52:50 <monochrom> No, I am fine with pointing out issues about old software. Your tone is the problem, what with all your left-in-dust and lol.
16:53:05 * pacak likes xmonad
16:54:03 <pacak> Updating packages to new ghc is not as hard as it seems.
16:54:22 <geekosaur> for xmobar you're often better off running the git version, althoygh I see no commits mentioning ghc8 compatibility (last commit was a month ago)
16:54:49 <iqubic> geekosaur: Is there a way I can XMonad without a status bar?
16:55:05 <geekosaur> why would xmonad require a status bar?
16:55:21 <Welkin> you can use xfce-panel if you want
16:55:24 <Welkin> or gnome-panel
16:55:26 <Welkin> or anything else
16:55:30 <geekosaur> (in particular it does not require xmobar; xmobar was inspired by xmonad, it is not part of xmonad or required by it
16:55:57 <Sonolin> yea I'm pretty sure it doesn't have xmobar by default
16:56:05 <iqubic> How can I make the change to a different status bar?
16:56:17 <Sonolin> implement a loghook
16:56:33 <Sonolin> i.e. with dynamicLogWithPP
16:56:51 <Koterpillar> iqubic: which bar?
16:57:18 <geekosaur> dynamicLog has predefined hooks for xmobar and dzen; others can be defined fairly easily by providing your own PP
16:57:31 <iqubic> Koterpillar: Something other than XMobar, since XMobar is not yet updated to GHC8
16:58:04 <Sonolin> iqubic this might help: https://wiki.haskell.org/Xmonad/Config_archive/Remi's_xmonad.hs
16:58:25 <Koterpillar> iqubic: there's a lot of status bars
16:58:27 <Sonolin> essentially you just have to start whichever bar you want, and then implement the loghook if you want some custom stuff
16:58:37 <Welkin> you just run it
16:58:37 <Welkin> o.o
16:58:41 <Welkin> and it appears
16:58:51 <Sonolin> yea that works too ;)
16:59:35 <Welkin> i3 is a reall pain in the ass to set up with all my function keys though
16:59:45 <iqubic> Alright, I am going to switch to dzen. Does that depend on GHC?
16:59:51 <Welkin> it breaks my audio
17:00:31 <geekosaur> no, it's written in C
17:00:39 <Welkin> why not B?
17:00:46 <iqubic> Cool. How can I get that rolling?
17:00:51 --- mode: ChanServ set +o monochrom
17:00:57 --- mode: monochrom set +b *!*@107-147-70-64.res.bhn.net
17:00:57 --- kick: Welkin was kicked by monochrom (Welkin)
17:01:02 --- mode: monochrom set -o monochrom
17:01:57 <iqubic> Shall I head over to the #xmonad channel?
17:02:08 <geekosaur> usually via your package manager
17:03:16 <iqubic> Now how do I add a dzen hook to xmonad?
17:06:50 <jayjam124> https://0bin.net/paste/6gWOXN5LTgxi+FVk#T4NprMJ2166hKrcMwtBBDk2x+ebOH3HbTNt8tSV28c1
17:06:56 <jayjam124> can anyone identify any race conditions in my code?
17:07:01 <jayjam124> I can't
17:07:38 <iqubic> Why do you think that there is a race condition in that code?
17:07:51 <monochrom> I get "404" "Either this paste has expired or this page never existed."
17:07:57 <jayjam124> sorry here's another
17:07:58 <jayjam124> https://0bin.net/paste/r37Qdg2gBbvHpbDx#tWfXeUhXJSuwJGQ6FOSZ43f1EfZdRhV8ETRiQSGLKgd
17:08:01 <jayjam124> and I don't think there does
17:08:26 <jayjam124> I mean, if there isn't a deadlock, which my code does not have
17:08:28 <monochrom> Haha "did not seem code, will not colorize"
17:08:31 <jayjam124> then that means a race condition also can't happen?
17:09:08 <monochrom> No, race condition and deadlock are orthogonal.
17:09:33 <monochrom> As in, no, you can't make deductions either way.
17:09:38 <jayjam124> then I am confused
17:10:17 <iqubic> How the heck do I get XMonad to use dzen?
17:11:31 <jayjam124> ok monochrom, can you tell if there is a race condition in there?
17:11:33 <jayjam124> if not why not?
17:11:35 <jayjam124> if yes why yes?
17:11:40 <monochrom> What should your program do? What observation did you see that you consider a race condition?
17:12:36 <jayjam124> A race condition is an undesirable situation that occurs when a device or system attempts to perform two or more operations at the same time, but because of the nature of the device or system, the operations must be done in the proper sequence to be done correctly.
17:12:52 <monochrom> Yes, that's a perfect definition.
17:13:05 <monochrom> So now what is desirable to you and what is undesirable to you?
17:13:23 <jayjam124> what do you mean|?
17:13:39 <jayjam124> I mean it's desirable that you don't have a race condition
17:13:45 <jayjam124> you want your program to be perfect 
17:13:49 <monochrom> OK, that's circular logic.
17:13:54 <jayjam124> huh?
17:14:01 <Koterpillar> jayjam124: what do you want your program to do?
17:14:19 <Koterpillar> if the only thing is "not have race conditions", this suffices: main = return ()
17:14:20 <jayjam124> I don't want collisions
17:14:34 <monochrom> May I ask again?
17:14:37 <monochrom> What should your program do? What observation did you see that you consider a race condition?
17:15:00 <barrucadu> What do you mean by collisions?
17:15:19 <jayjam124> when you have data but two or more operations want access to the data
17:15:32 <jayjam124> and it can mess up the data
17:15:42 <jayjam124> monochrom so you're asking me what my program does?
17:16:07 <barrucadu> You only have one thread taking from the MVar
17:16:16 <jayjam124> main yeah
17:16:54 <jayjam124> if I only have one thread taking from MVar
17:16:57 <barrucadu> So there will never be a situation where more than one thread wants "access to" the data, if by "want access to" you mean "reads".
17:16:58 <jayjam124> then that means that other threads aren't
17:17:02 <jayjam124> yeah
17:17:05 <jayjam124> so no race conditions
17:17:23 <jayjam124> ...right?
17:18:13 <Tertiary> Can someone tell me a more concise way to write this? I feel like there is something obvious I'm missing, but after playing with it a bit, I can't get anything except this or the do-block version of it to typecheck
17:18:20 <Tertiary> f x = ask >>= return . someField >>= (\g -> g x)
17:18:23 <barrucadu> jayjam124: Right.
17:19:30 <jayjam124> barrucadu :) thanks
17:19:39 <barrucadu> The main thread does "race" with the genThread and userThread, in that the relative order of their execution is not controlled anywhere, but that doesn't appear to be undesirable.
17:19:40 <Tertiary> someField is just a record field on the state object that that is of type String -> SomeMonad m
17:20:09 <glguy> f x = ask >>= \y -> someField y x
17:20:36 <geekosaur> first off, (ask >>= return . someField) is (asks someField)
17:20:56 <jayjam124> barrucadu makes sense, thanks
17:21:22 <barrucadu> jayjam124: But what monochrom was getting at is that whether something is a race condition or not very much depends on what you want your program to do. It doesn't really make much sense to present some code and ask if it has any races, with no explanation of what it *should* do.
17:21:39 <jayjam124> yeah so he's asking what it was doing
17:21:45 <jayjam124> I understand, I was just confused that's all
17:21:45 <geekosaur> (\g -> g x) can be written ($ x)
17:24:36 <Tertiary> Thanks geekosaur, I was trying something similar, but just did it slightly wrong
17:25:36 <trevorriles> \quit
17:29:15 <iqubic> What does hscolor do, and has it been updated to work with GHC8?
17:30:19 <Koterpillar> iqubic: likely yes: https://www.stackage.org/package/hscolour
17:30:51 <geekosaur> it outputs colorzied source code, eiteher as html or for terminal display, and as such it likely needs more work if it's not ghc8 compatible because it would need to learn about things like the TypeApplication extension which changes the language syntax
17:32:28 <iqubic> Is it fine if I get rid of hscolour? What functionality would I be losing?
17:33:17 <geekosaur> probably hyperlinked and colorized source in locally generated documentation
17:34:29 <iqubic> I never look at locally generated documentation.
17:37:48 <iqubic> What is Haddock, and why hasn't it been updated to GHC *
17:37:55 <iqubic> GHC 8
17:39:57 <Koterpillar> iqubic: what makes you think it hasn't?
17:40:09 <iqubic> I misread something.
17:42:32 <iqubic> How can I tell which of my packages still relies on an old version of GHC?
17:44:34 <Koterpillar> try building them with the new one
17:44:39 <Koterpillar> using stack, for example
17:44:52 <Koterpillar> or do you mean "packages I created" by "my packages"?
17:45:16 <iqubic> I mean packages that I have downloaded through the gentoo package manager.
17:45:38 <iqubic> How do I get stack to work on Gentoo?
17:46:03 <geekosaur> iirc you don't currently
17:46:19 <geekosaur> and you also don't get to tell gentoo to use a newer ghc for its packages; you get what it uses
17:46:40 <iqubic> So I have to live with an outdated version of GHC?
17:46:49 <geekosaur> that's the problem with distribution packages; you get someone else's configuration, not the one you would prefer
17:47:13 <Koterpillar> geekosaur: why can't you install Stack on Gentoo?
17:48:01 <iqubic> Can I just purge all the packages that rely on GHC, and just re-install the ones that I need, when I need then?
17:48:39 * geekosaur is trying to remember
17:49:00 <geekosaur> iqubic, don't use gentoo's packages if you don't want gentoo's ghc version
17:49:33 <iqubic> Yeah, I got that. Is there any way to get myself out of the hole that I've dug for myself.
17:49:41 <geekosaur> as I just said, this is what you get when you use a distribution's packages. you get what they package (or in this case what they wrote a port for)
17:50:06 <geekosaur> you can probably install ghc from the generic binary distribution and then use that to install packages
17:50:57 <iqubic> But what do I do with the existing version of GHC.
17:51:33 <geekosaur> uninstall it
17:51:54 <geekosaur> either use portage and only portage, or use a separate ghc install and don't use portage for anything haskell related
17:52:02 <geekosaur> you cannot mix and match
17:52:15 <geekosaur> (the same is true to varying extents of perl, python, ruby, npm, ...)
17:52:29 --- mode: ChanServ set +o monochrom
17:52:38 <geekosaur> (and most of the will refuse to support you if you say you are using a distribution installed version; we at least try to help...)
17:52:48 --- mode: monochrom set -b *!*@107-147-70-64.res.bhn.net
17:52:57 --- mode: monochrom set -o monochrom
17:53:08 <iqubic> But If I uninstall it, tons of packages will be without a crucial dependency.
17:53:11 <geekosaur> re stack on gentoo, http://lpaste.net/6559619481490948096 was the reported issue. I don't know if this has been fixed since then (January) but last I heard people were still having linker issues
17:53:50 <geekosaur> iqubic, I already said you have to remove those and reinstall using the new ghc, you CANNOT mix and match
17:54:03 <iqubic> I'll do that now.
17:54:08 <geekosaur> distribution packages are not designed for mix and match, they are designed for you to install everything from the distribution
17:54:24 <geekosaur> so either use everything from the distribution or use nothing from it
17:55:22 <geekosaur> this is true even of ports-based systems, although tye usually at least try to allow for a little more flexibility, there's no way to be fully flexible and yet provide some guarantee of things working
17:56:41 <robkennedy> I'm working on a Sudoku solver to practice speeding up Haskell. From all your collective experience, do you think anything will go faster to represent the possible values of a cell than Word16 (with each bit from the right representing if that number is a possibility)? I've tried IntSet and OrdList which were ~ 1.2x and 3x slower
17:59:42 <dolio> I would be surprised if anything else were faster.
18:00:39 <geekosaur> there's likely an optimized bitset implementation on hackage that will be faster than a simple bit vector implementation, but otherwise probably not
18:00:47 <dolio> Aside from packing multiple cells together in a larger size word.
18:01:16 <dolio> Although that involves more arithmetic for certain things.
18:08:20 <robkennedy> Yeah. I'd hoped that I could handcraft a `type Possibilities = (Bool,Bool,...,Bool)` type to compete, but the lore I've learned says Bool takes 8 bits
18:08:39 <robkennedy> *newtype
18:09:04 <dolio> Way more than that.
18:10:26 <iqubic> Just moving over to GHC 8.0.1 now.
18:11:54 <iqubic> It's a hard proccess, because I'm also moving away from using the Gentoo distribution GHC.
18:13:15 <robkennedy> Okay, on the other side: do you think if I went more granular, and shrunk my functions to Word8 after a number had been solved, I could get a speedup?
18:13:57 <dolio> No.
18:15:32 <robkennedy> Yeah, I agree. I'll test it anyway. 
18:15:55 <dolio> Testing it is almost certainly a waste of time.
18:16:08 <dolio> Both Word8 and Word16 use a machine word internally.
18:16:26 <iqubic> Alright, how does one install GHC 8 from binary sources.
18:17:13 <robkennedy> Oh good point
18:17:16 <dolio> Unless you're storing them in an unboxed array or something.
18:17:56 <dolio> Just using Word might be faster because it doesn't have to do modular arithmetic at all, if you're doing arithmetic.
18:18:00 <dolio> But that'd probably be negligible.
18:18:13 <iqubic> Alright, I think I am now able to update to GHC 8
18:18:43 <robkennedy> For the word16 representation of Possibilities it's mostly hacking against Data.Bits
18:19:06 <dolio> Yeah. So there'd probably be no difference, then.
18:19:41 <iqubic> Alright, does it really take two hours to compile GHC 8.0.2 from source?
18:20:20 <dolio> Depends on your computer.
18:20:57 <robkennedy> Right now I change my representation by changing `import PossibilitiesWord as Possibilities` to `import PossibilitiesVector as Possibilities`. Can I swap to `class Possibilities a` with no cost if I inline enough?
18:21:22 <geekosaur> iqubic, if you have the bindist, you "./configure --prefix=/where/you/want/to/install/it" then "make install"
18:21:24 <kadobanana> If you're just trying to install GHC, you generaly don't have to build it from source, in case you weren't aware. It still takes a while to ... I don't even know it calls it, bootstrap or something, but it's not too terribly long.
18:21:39 <geekosaur> installing from source requires another ghc to bootstrap and it has to be within 2 versions
18:22:05 <iqubic> geekosaur: I don't have that. Not sure where to download that.
18:22:25 <iqubic> geekosaur: Do you run Gentoo?
18:22:35 <geekosaur> https://www.haskell.org/ghc/download_ghc_8_0_2
18:22:39 <geekosaur> and no, I don;t run gentoo
18:22:45 <iqubic> Oh.
18:22:46 <iqubic> I see
18:24:07 <iqubic> So do you recomend trying to compile GHC from source or not?
18:25:22 <monochrom> No, don't do that, unless you need the heat.
18:25:44 <monochrom> But wait, gentoo... :)
18:26:16 <Koterpillar> I wonder how does it deal with bootstrapping
18:26:54 <glguy> it downloads a binary to compile with
18:26:58 <iqubic> monochrom: I can install it with out going through the system's package manager.
18:27:06 <iqubic> glguy: How do you know that?
18:27:21 <monochrom> I think it certainly had to address bootstrapping once upon a time, but since then there is no worry. Like GHC.
18:27:47 <glguy> iqubic: that was a response to the question of boot strapping
18:27:57 <glguy> I know that because it's the only option
18:28:11 <Koterpillar> you could build a chain of GHCs all the way back?
18:28:23 <iqubic> glguy: I know that. I was wondering how you knew that Gentoo fetched a binary so that it could compile GHC.
18:28:50 <iqubic> Is there a list of new features in GHC 8.0.2?
18:28:55 <iqubic> I'd like to see that.
18:28:56 <monochrom> iqubic: Yes, I recommend what geekosaur recommended, download the binary tarball and use --prefix for good organization.
18:29:25 <iqubic> Oh. I'll do that.
18:29:35 <monochrom> If you do something like --prefix=/usr/local/myghc802, it will mean more hassle with PATH, but it will also mean easy erasure.
18:30:06 <iqubic> And then will I have to avoid using the Gentoo Package manager when installing Haskell packages.
18:30:11 <lordcirth> Apparently I am missing something obvious.  I am trying to declare a lens, 'player', that goes from a GameState record to a list 'creatures' to it's first element, ie gs^.player == gs^.creatures._head.  But player = creatures._head errors
18:30:16 <monochrom> The GHC User's Guide has a section on new features.
18:30:34 <_sras_> What is the difference between a Natural Transformation and Just a simple function?
18:30:48 <iqubic> lordcirth: Do you understand Haskell?
18:30:55 <lordcirth> iqubic, the basics
18:31:16 <Koterpillar> lordcirth: what's the error?
18:31:21 <iqubic> you'd write that like: player = head creatures
18:31:27 <glguy> iqubic: afaik Gentoo only builds ghc from source if you tell it to
18:31:33 <iqubic> Oh.
18:31:37 <Koterpillar> iqubic: that's lenses
18:31:42 <monochrom> A natural transformation is not just a simple function. In some examples not a function at all.
18:32:08 <monochrom> And in some examples, an indexed family of functions rather than one single function.
18:32:11 <iqubic> Koterpillar: I'm just not used to seeing stuff that looks like OOP.
18:32:20 <monochrom> And that last sentence is already the most boring example.
18:32:35 <glguy> lordcirth: _head is not a lens
18:32:45 <lordcirth> https://hackage.haskell.org/package/lens-3.0.1/docs/Data-List-Lens.html
18:32:49 <lordcirth> https://gist.github.com/lordcirth/a14d3f1974109c3ac2c60ba0a21fd3c3
18:33:04 <lordcirth> glguy, so, it being "Simple Lens" is the problem?
18:33:08 <_sras_> monochrom: What is the difference. How is it different from a function from one monad to another monad. For example a function from Maybe a -> Either String a ?
18:33:15 <glguy> lordcirth: and that documentation link is out of date, old version
18:33:56 <monochrom> I will want to emphasize the omitted "forall a" there. forall a. Maybe a -> Either String a.
18:34:02 <iqubic> Koterpillar: Does his code actually work. That doesn't look like actual Haskell to me.
18:34:07 <monochrom> That is an example of natural transformations.
18:34:24 <monochrom> But that also has one particular example category in mind.
18:34:33 <Koterpillar> iqubic: it's almost correct, and yes, lenses look very OOP: http://hackage.haskell.org/package/lens
18:35:04 <glguy> iqubic: haskell has operators. as you learn more of it you'll see lots more of them
18:35:32 <monochrom> Also you don't need monad. You just need functor.
18:35:38 <lordcirth> glguy, ok.  So what is the proper way? creatures.(ix 0) doesn't work either
18:35:44 <iqubic> glguy: Yeah, I've seen several of the operators
18:35:53 <_sras_> monochrom: Isn't a lift a function from one Monad ot another Monad. So what is the difference between a Nat and a Lift?
18:36:10 <monochrom> I don't understand the question.
18:36:10 <glguy> lordcirth: use ^? instead of ^.
18:36:36 <monochrom> Also there are non-lifting natural transformations.
18:36:55 <jmcarthur> TFL you add lens to a cabal file and have to install 20 or so more packages for it even though you already have a lot of dependencies built.
18:36:56 <_sras_> monochrom: Ok. But I am trying to see the difference. 
18:37:00 <lordcirth> glguy, ok, but it won't even let me declare the lens function in the first place
18:37:12 <lordcirth> Or should that be in the definition?
18:38:04 <monochrom> You're probably restricting yourself to the category of Haskell types and functions, and so natural transformations look just like a special case of polymorphic functions.
18:38:59 <glguy> lordcirth: you can't define a Lens using _head or ix
18:39:10 <glguy> you get a Traversal
18:39:18 <lordcirth> glguy, I see
18:39:39 <lordcirth> glguy, so, player = creatures.preview ?
18:39:41 <monochrom> And even worse, natural transformations don't cover all polymorphic Haskell functions.
18:39:54 <_sras_> monochrom: Does it make sense to have a Nat from a Maybe to an Either?
18:40:06 <monochrom> No.
18:40:14 <_sras_> Why is that?
18:40:34 <monochrom> There is no object "Either Int" for example.
18:41:28 <monochrom> But you can correct that to: can have a natural transformation from Maybe to Either Int.
18:41:34 <iqubic> No, but there is Either a Int or Either Int b
18:41:44 <monochrom> Right, like that.
18:42:41 <iqubic> Both are correct.
18:42:52 <glguy> lordcirth: no. I'm on my phone, hard to write code out
18:43:13 <glguy> preview isn't something you compose with a Lens
18:43:47 <lordcirth> Apparently I really don't understand Lenses
18:43:54 <glguy> where I'm taking about (.) as compose
18:44:56 <lordcirth> I had GameState containing _player :: Player and _monsters :: [Monster] but I changed that to _creatures :: [Creature] where _creatures !! 0 == the player
18:44:57 <glguy> preview and view are lens * consumers*
18:45:10 <lordcirth> glguy, like over and set?
18:45:17 <glguy> yeah
18:47:29 <iqubic> So what even is a lens, and how useful is it really?
18:47:52 <lordcirth> glguy, so in order to do gs^.player just like I used to, but actually get gs^.creatures !! 0, what does 'player' need to be defined as?
18:48:08 <lordcirth> iqubic, they are very useful, and I have only the faintest idea what they are XD
18:48:48 <iqubic> lordcirth: Those seem like contradictory things
18:49:24 <glguy> lordcirth: You can do:   gs ^? player . ix 0
18:49:42 <Koterpillar> iqubic: type Lens a b = (a -> b, b -> a -> a)
18:49:54 <Koterpillar> (not the real definition)
18:50:19 <lordcirth> glguy, but how must 'player' be defined?
18:50:22 <Koterpillar> iqubic: means you can read that part and set it to another value (like "player" part of the game state in lordcirth's example)
18:50:58 <Koterpillar> iqubic: now throw a ton of combinators at them - read the examples in Lens hackage - and you've got a very useful tool
18:51:26 <lordcirth> glguy, did you mean, gs ^? creatures . ix 0   ?
18:51:58 <jmcarthur> :t maybe (Left Nothing) (left Just)   -- feels like something that should be doable with just one or two tokens
18:51:59 <lambdabot> Maybe (Either a b) -> Either (Maybe a) b
18:52:18 <glguy> lordcirth: Yeah
18:53:19 <lordcirth> glguy, ok, so if I want to make 'player' a shorthand for that, what's the correct way to do that?
18:53:26 <jasondockers> I'm slightly confused by `fib = 1 : 1 : [a+b | (a,b) <- zip fib (tail fib) ]`. what does zip fib (tail fib) evaluate to? would it be (1,1) to begin with, but then fib has [1,1,2]. so how would zip [1,1,2] [2] evaluate? 
18:53:33 <lordcirth> Or do I not do that?
18:53:38 <glguy> lordcirth: player = creatures . ix 0
18:53:47 <lordcirth> glguy, oh ok.  Makes sense.
18:53:53 <jmcarthur> I guess it's sequence, but where the applicative focuses on the first type argument of Either instead of the second.
18:54:07 <glguy> It'll be something like: player :: Traversal' GameState Creature
18:54:12 <Koterpillar> jasondockers: fib is infinite
18:54:26 <jasondockers> Koterpillar, okay, so it is only computed as needed?
18:54:32 <Koterpillar> jasondockers: correct
18:54:39 <Koterpillar> jasondockers: its tail is also infinite
18:54:49 <jasondockers> Koterpillar, maybe I should say we perform a "select first 10" on it?
18:55:01 <lordcirth> glguy, I get the same error.  perhaps the type is being inferred wrong because of something elsewhere?
18:55:06 <Koterpillar> jasondockers: you can if you want
18:55:13 <jasondockers> Koterpillar, I'm having trouble imagining how it is computed when needed / how the list expands
18:55:28 <Koterpillar> jasondockers: everything is lazy, it's not computed until needed
18:55:36 <jasondockers> Koterpillar, yes, when it is needed. 
18:55:49 <Koterpillar> jasondockers: _if_ someone calls fib, they'll first get [1, 1, ...
18:56:07 <Koterpillar> and then for the third element, what happens?
18:56:58 <jasondockers> in pseudo code, I guess, "1+1 | (1,1) <- zip [1,1] [1]".. so [1,1,2,...]
18:57:27 <jasondockers> if someone requires it is computed
18:58:20 <Koterpillar> correct, except those lists there aren't finite, they are just the same infinite list
18:58:42 <glguy> lordcirth: did you forget the type signature for player?
18:58:58 <glguy> or can you just paste the actual code and error so I can look at that?
19:00:12 <lordcirth> glguy, https://github.com/lordcirth/haskell-rogue/blob/master/src/GameState.hs
19:00:50 <jasondockers> Koterpillar, when the fourth element in the list is computed is the sum of the resulting tuple from zip [1,1,2] [2] used?
19:01:09 <lordcirth> glguy, https://gist.github.com/lordcirth/5af5c34ce22a215a70bc2eac41f74de5
19:01:39 <Koterpillar> jasondockers: so you have three elements, then fib = [1, 1, 2, ...
19:01:51 <Koterpillar> jasondockers: therefore, tail fib = [1, 2, ...
19:01:55 <jasondockers> oh, oops!
19:02:05 <jasondockers> tail x:xs = xs, so to speak
19:02:12 <jasondockers> for a moment I thought it was the last element 
19:02:14 <Koterpillar> > tail [1, 2, 3, 4]
19:02:16 <lambdabot>  [2,3,4]
19:02:21 <Koterpillar> > last [1, 2, 3, 4]
19:02:23 <lambdabot>  4
19:02:24 <jasondockers> yeah
19:03:20 <Koterpillar> @src tail
19:03:20 <lambdabot> tail (_:xs) = xs
19:03:21 <lambdabot> tail []     = error "Prelude.tail: empty list"
19:03:52 <jasondockers> > [a+b | (a,b) <- zip [1,2,3,4] (tail [1,2,3,4])]
19:03:54 <lambdabot>  [3,5,7]
19:04:05 <jasondockers> okay, this makes sense now
19:04:55 <Koterpillar> > let loopy = cycle [1, 2, 3] in take 10 (zip loopy (tail loopy))
19:04:56 <lambdabot>  [(1,2),(2,3),(3,1),(1,2),(2,3),(3,1),(1,2),(2,3),(3,1),(1,2)]
19:05:03 <jasondockers> granted, 3,5,7 isn't the right sequence, but close enough
19:05:22 <dolio> > [ a+b | a <- [1..4] | b <- [2..4] ]
19:05:26 <lambdabot>  [3,5,7]
19:06:15 <jasondockers> Koterpillar, yeah, I follow loopy 
19:07:13 <Koterpillar> jasondockers: note that dolio used an extension that allows parallel iteration
19:07:24 <Koterpillar> > [a + b | a <- [1..4], b <- [2..4] ]
19:07:27 <lambdabot>  [3,4,5,4,5,6,5,6,7,6,7,8]
19:07:28 <jasondockers> yeah, I don't recognize that syntax
19:07:55 <jasondockers> I know about generators and boolean guards in list comprehension, I believe
19:08:08 <jasondockers> I'm just reading the tutorial
19:08:10 <Koterpillar> dolio: what's the name?
19:10:06 <dolio> ParallelListComprehensions? Something like that.
19:10:41 <glguy> lordcirth: I can't reproduce your problem
19:10:51 <glguy> lordcirth: Maybe you're loading the wrong version of the file
19:11:17 <lordcirth> glguy, that's odd
19:12:10 <lordcirth> glguy, it doesn't compile for you, though, right?  There are (and should be) other errors from the ongoing refactor
19:12:22 <glguy> lordcirth: That GameState.hs loads for me
19:12:37 <lordcirth> glguy, right, that file by itself.  ok.
19:13:15 <lordcirth> I will try it by itself
19:14:04 <lordcirth> glguy, interesting, if I just do 'stack ghci' in the directory, it compiles GameState then crashes at the rest
19:14:44 <lordcirth> glguy, is there something that Leksah might be doing that is odd?  
19:15:18 <jasondockers> glguy, are you programming opengl in haskell?
19:15:31 <glguy> jasondockers: Nope.
19:15:34 <glguy> lordcirth: I couldn't say
19:16:21 <lordcirth> glguy, what IDE do you use?
19:16:38 <glguy> vim or macvim
19:17:03 <lordcirth> ah.  I was using vim, but tried leksah today and it's more enjoyable
19:17:13 <lordcirth> except for now, obviously...
19:23:41 <iqubic> What is Leksah? And can I install it on my machine?
19:24:18 <kadobanana> It's a haskell IDE that not that many people seem to use
19:24:35 <iqubic> Isn't it written in Haskell?
19:24:38 <geekosaur> yes
19:24:52 <iqubic> What library does it use for GUI stuff?
19:25:27 <geekosaur> gtk
19:25:43 <geekosaur> http://leksah.org/
19:25:49 <iqubic> Ah. Not some native Haskell thing like Fudgets?
19:25:57 <iqubic> Why does it use GTK?
19:26:12 <iqubic> Does Leksah support GHC 8.0.2?
19:27:03 <lordcirth> glguy, I just ran 'cabal configure' in the project directory and relaunched leksah and it fixed it... argg
19:27:14 <lordcirth> glguy, thanks for all your help with Lens
19:27:33 <lordcirth> iqubic, as best I understand, it supports whatever your cabal version does
19:31:20 <glguy> lordcirth: you're welcome.
19:32:04 <lordcirth> glguy, yeah apparently I / stack upgraded cabal from 1.2.2 to 1.2.4 and it didn't run configure, or something
19:34:12 <d34df00d> Hi!
19:34:46 <d34df00d> https://wandbox.org/permlink/Po2QAbCP5WTuPHSZ why doesn't it typecheck?
19:35:28 <d34df00d> From what I understand, every usage of `Typ a` implies that `a` is of `TypHolder`, hence `Typ a` should implement Eq.
19:36:56 <geekosaur> you're telling it that every Typ a is a TypHolder a *if* it has an Eq instance
19:37:27 <geekosaur> hm, wait, typoe family
19:37:40 <geekosaur> type family.my fingers are the typo family :p
19:38:51 <glguy> d34df00d: TypHolder a implies that Eq (Typ a)
19:39:19 <glguy> but that doesn't mean that any particular Typ a has an Eq constraint on its own
19:39:28 <glguy> you need the TypHolder a still
19:39:30 <d34df00d> glguy: yeah, but I cannot use `Typ a` without meaning that `TypHolder a`, can I?
19:39:48 <iqubic> It looks like Leksah is on hackage, is that right?
19:39:51 <geekosaur> that was my "hm, wait", yeh
19:39:56 <geekosaur> iqubic, yes
19:40:14 <geekosaur> you will likely find you need to install a bunch of C libraries before it will build
19:40:23 <iqubic> Does that mean I can use Cabal to install leksah on my machine?
19:40:29 <geekosaur> yes
19:40:30 <glguy> d34df00d: You actually have to have the constraint to know how Eq is implemented
19:40:56 <d34df00d> glguy: uhm, why?
19:40:58 <glguy> the TypHolder a one, if you don't just happen to independently have an Eq (Typ a) around
19:41:17 <glguy> d34df00d: Because that constraint as the actual method definitions of (==) and (/=) in it
19:41:22 <glguy> has the*
19:41:47 <Henson> is there some idiomatic way to take a list of items, and wherever a certain item appears to segment the list at that point?  For example [1,2,3,4,5,3,6,7,8,3,9] when segmenting on 3 would become [[1,2],[4,5],[6,7,8],[9]].  You could optionally have the segmentation "key" be part of the list.  I can do it with recursion, but this problem and several others I have encountered call for a functional..
19:41:55 <d34df00d> glguy: so, in other words, "the TypHolder a one" means that merely using/writing `Typ a` doesn't prove `a` is of TypHolder?
19:42:06 <iqubic> So when using cabal to install things, am I installing straight from hackage?
19:42:11 <Henson> tool similar to a fold, but instead of applying the fold function to every item in the list, allows the fold function to determine the remaining items in the list to pass on for further processing.
19:42:12 <glguy> d34df00d: correct
19:42:16 <d34df00d> glguy: why? :)
19:42:37 <d34df00d> Typ is defined in that class, doesn't it automatically imply that class then?
19:42:51 <Koterpillar> Henson: does Data.List.Split do what you want?
19:43:17 <iqubic> Is there a way to impose a limit onto takeWhile such that it either takes the first n items that satisfy the boolean, or just the first n items.
19:43:24 <iqubic> ??
19:43:53 <glguy> d34df00d: No, just because you wrote Typ a, doesn't mean there's actually a TypHolder a instance around
19:44:08 <Koterpillar> iqubic: apply it to take n ...
19:44:10 <glguy> I can ask for the kind of Typ () without the corresponding instance
19:44:17 <iqubic> Right. 
19:44:30 <d34df00d> glguy: but if you're writing that in a context that "requires" a full type?
19:44:41 <glguy> and given some 'Typ a' I can't tell what a was
19:45:09 <glguy> I don't know what you mean about the context
19:45:19 <iqubic> so "take n $ takeWhile bool list"
19:45:21 <glguy> but you won't be able to talk yourself into a free Eq instance for an arbitrary Typ a
19:46:03 <d34df00d> Ok, I'm probably having XY problem here then.
19:47:22 <d34df00d> So I have a bunch of mutually recursive data structures (representing some AST, for instance). I'd like to parametrize them to allow carrying around some context, and I guess the context could be different for different node types. What are my best options?
19:48:01 <glguy> const 42 :: Typ () -> Int. I can write that without it making much sense or having an instance of TypHolder ()
19:48:21 <d34df00d> I thought about a typeclass with a type family, and then `data Expr a = Expr (Context a (Expr a)) [ChildExpr a]; data ChildExpr a = ChildExpr (Context a (ChildExpr a))` etc.
19:48:57 <d34df00d> But Expr, ChildExpr and a few dozen of other types need to implement Eq, Show, Generic, NFData and some others, and I really don't want to write a few hundred of "deriving instance" by hand.
19:49:12 <d34df00d> Which kinda prohibits me from going the GADT route and adding the constraint to the ctor.
19:49:48 <iqubic> What's the difference between "$" and ".:
19:50:05 <iqubic> Sorry "$" and "."?
19:50:17 <glguy> $ applies a function to an argument, the other builds a new function out of two functions
19:50:37 <Henson> Koterpillar: what I'm looking for is closer to (break (== key) list), but coupled with some fold-like function.  I can achieve it with recursion, but wonder if I don't know about a function that I should be using.
19:51:30 <d34df00d> Or, avoiding type families of kind * -> * and sticking with *, this somewhat illustrates what I'd ideally want: https://wandbox.org/permlink/JZPCh76WiZawkKMB
19:53:23 <geekosaur> iqubic, ($) is just function application with lowest possible precedence (normal application is highest precedence, aside from record updates) so you can sometimes omit parentheses 
19:54:03 <geekosaur> operationally, in x $ y, y is a value; in x . y, y is a function that requires one or more values
19:54:37 <geekosaur> (that is something of a lie, but will do for now)
19:57:15 <lordcirth> glguy, this player :: Traversal' GameState Creature ; player = creatures . ix 0 ;  returns a Maybe Creature.  I know that the player will always exist.  What's the correct way to assume this in 'player'?  'singular'?
19:57:50 <glguy> lordcirth: the correct way would be to move player to a separate field on your GameState that always exists so that you don't have to promise that the list is non-empty
19:57:58 <glguy> or you could use a NonEmpty list type for the list of creatures
19:58:10 <glguy> otherwise singular is an option
19:58:25 <lordcirth> glguy, well, the reason I moved it to the list, was so that I could do things like "damage all creatures on this tile" etc
19:58:51 <d34df00d> Worse than that, with standalone deriving the amount of constraints that needs to be specified manually grows combinatorially: https://wandbox.org/permlink/XhvHdhNN7sakofkX
19:59:30 <lordcirth> glguy, so where precisely do I put 'singular'? player = creatures . singular . ix 0 ?
20:00:03 <glguy> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Traversal.html#v:singular
20:00:38 <lordcirth> glguy, yeah, that's where I'm looking
20:02:24 <glguy> OK, cool. That's the right place
20:04:28 <lordcirth> Ok, so leksah keeps giving me confusing type errors that go away when I restart it
20:12:35 <iqubic>  Alright, If I just want to download GHC 8
20:17:05 * dmwit wonders if iqubic is still planning to add a "then" to his "if"
20:17:45 <Koterpillar> Henson: can you post sample input and output?
20:18:43 <glguy> dmwit: Maybe it was a question. iqubic, yes, that's alright.
20:19:10 <iqubic> dmwit: If I just want to download GHC 8 and avoid going through my package manager, can I do that?
20:19:41 <vaibhavsagar> iqubic: that's what stack and nix do by default
20:20:15 <dmwit> iqubic: Yes.
20:20:22 <glguy> iqubic: Sure, that's how lots of us install GHC. You can download the binary distribution from haskell.org http://downloads.haskell.org/~ghc/8.0.2/
20:20:44 <dmwit> iqubic: GHC is generally careful not to clobber itself, so you can have many versions installed at once with no problem.
20:21:06 <Henson> Koterpillar: say a function "cutAt :: a -> [a] -> [[a]]" that works like this: cutAt 3 [1,2,3,4,5,3,6,7,8,3,9] = [[1,2],[4,5],[6,7,8],[9]]
20:21:22 <dmwit> ?hackage split -- Henson
20:21:22 <lambdabot> http://hackage.haskell.org/package/split -- Henson
20:21:32 <iqubic> And then would I be able to install the latest version of XMonad, and XMonad-Contribe with out any trouble?
20:21:53 <dmwit> d34df00d: I'm not sure I've understood your question fully yet, but you might like to look at Eq1.
20:22:14 <dmwit> iqubic: Hm. I think so. What version of GHC are you having trouble with currently?
20:22:35 <Koterpillar> Henson: that exists in split, what did you refer to about folds?
20:22:46 <Henson> dmwit: oh my god, that is the best package description I have ever seen.
20:22:59 <dmwit> byorgey++ for having fun
20:23:37 <iqubic> dmwit: GHC 8.0.2 is being a pain in the back to install
20:24:21 <dmwit> iqubic: Well, somebody may be able to help you. But not with *that* problem description. =)
20:24:25 <Henson> Koterpillar: ok, I didn't know about the split package.  As for the fold-like function, it would be nice to have a function that works on a list and an accumulator, like fold, but instead of applying its "worker function" to every item in the list, the worker function itself determines the remaining items to be processed.
20:24:52 <dmwit> :t unfoldr -- perhaps?
20:24:53 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:25:05 <Koterpillar> looks like
20:25:38 <dmwit> Henson: What would you want the type of that fold to be?
20:28:59 <Koterpillar> guessing: (a -> b -> (Maybe a, b)) -> a -> b
20:29:12 <Koterpillar> (really, a is a list, but it doesn't have to be)
20:29:35 * Henson is thinking
20:30:06 <Koterpillar> at which point, it might well be a variation of iterate
20:34:17 <Henson> let's call it foldr2 :: ([a] -> b -> ([a],b)) -> b -> [a] -> b.  Here the accumulator is b.  The "worker function" takes the entire list and the accumulator, then returns as a tuple the rest of the list to be processed and the new accumulator.  This would allow the function to take multiple items from [a] in creating the new accumulator.
20:36:07 <d34df00d> dmwit: that's probably slightly different.
20:36:15 <d34df00d> But I'm not sure how to reformulate my question :(
20:36:29 <Koterpillar> Henson: that never stops
20:36:42 <Koterpillar> Henson: and you never use the fact that [a] is a list
20:37:03 <dmwit> Koterpillar: It could stop. e.g. if the third argument is empty.
20:37:10 <dmwit> Which would also incidentally address your other complaint. =P
20:37:20 <Koterpillar> I know, but I don't like that
20:37:31 <Koterpillar> my signature is better, except I forgot an argument
20:37:46 <dmwit> :t \f g -> head . dropWhile g . iterate f
20:37:47 <lambdabot> (c -> c) -> (c -> Bool) -> c -> c
20:38:14 <dmwit> ?let foldr2' f g = head . dropWhile g . iterate f
20:38:15 <lambdabot>  Defined.
20:38:57 <dmwit> :t \f b as -> fst . foldr2' f (null . snd) $ (b, as)
20:38:58 <lambdabot> Foldable t => ((c, t a) -> (c, t a)) -> c -> t a -> c
20:39:19 <Henson> ok, consider the break function applied to a list: (break == key) list -> (front,key:rest).  This splits the list into items in front of the key, the key, and the rest of the list.  To segment the list, you'd just take the front and add that to the accumulator.  Then you'd want to feed the "rest" to another invocation of the same thing.  This seems amenable to a fold, but you want the worker...
20:39:36 <Henson> function to decide the remaining items in the list to process, you don't want to apply the worker function to every item in the list.
20:40:04 <Koterpillar> Henson: so why not fold over the result of break?
20:40:05 <Henson> the (->) arrow was meant to show the result, not a lambda function.
20:40:26 <dmwit> :t unfoldr (\xs -> case break (3==) xs of ([], []) -> Nothing; (head, _:tail) -> Just (head, tail))
20:40:27 <lambdabot> (Num a, Eq a) => [a] -> [[a]]
20:40:37 <dmwit> Henson: That's an unfoldr.
20:42:25 <Henson> dmwit: excellent!
20:43:05 <Henson> thank you guys for helping me figure out the missing function!  I've needed to use this kind of function several times in the past but didn't know it existed, so I always just built a recursive function to do it.
20:55:54 <vaibhavsagar> iqubic: do you have stack installed?
20:56:41 <vaibhavsagar> if so, you should be able to run `stack setup 8.0.2 --no-system-ghc`
20:57:32 <vaibhavsagar> you'll have to add it to $PATH manually or use `stack exec -- ghc`
20:58:35 <kadobanana> That would likely be stack setup --resolver ghc-8.0.2 or something
20:58:41 <kadobanana> I don't think it understand 8.0.2 by itself
20:59:14 <monochrom> I think that iqubic is not using stack.
21:00:57 <vaibhavsagar> I think it is actually `stack setup 8.0.2`
21:01:01 <vaibhavsagar> https://github.com/vaibhavsagar/prepare-ghcjs/blob/77942c98cec9d0df1090017010bc96f9b59c2cda/.travis.yml#L19
21:01:08 <vaibhavsagar> but I could be wrong :)
21:02:17 <kadobanana> Hmm, looks like you're right, I wasn't aware it accepted that
21:17:54 <iqubic> How does one install GHC from source?
21:18:01 <iqubic> Is there a guide anywhere?
21:18:35 <MarcelineVQ> iqubic: https://ghc.haskell.org/trac/ghc/wiki/Building/QuickStart
21:19:08 <glguy> iqubic: that's not something you'll likely need to do at this point, 
21:19:42 <iqubic> It isn't?
21:19:46 <iqubic> Why do you say so?
21:19:53 <dmwit> Installing GHC from source is quite involved. Why do you think you need to do that?
21:20:13 <iqubic> Because I can't seem to get my package manager to do it for me.
21:20:50 <dmwit> You can install binaries without going through your package manager.
21:21:02 <dmwit> "From source" means building the whole compiler yourself, which is usually not needed.
21:21:08 <iqubic> That's what I want to do. How hard is that?
21:21:15 <iqubic> I mean the first thing.
21:21:20 <iqubic> Installing from binary
21:21:40 <dmwit> It is easy to install binaries. Just grab a tarball from the GHC website, untar it, ./configure, make install.
21:21:50 <dmwit> Probably sudo make install.
21:22:10 <iqubic> How do I untar something, and where do I tell it where to install to?
21:22:45 <dmwit> `tar xf blah.tar.gz` will untar `blah.tar.gz`. You can ask for a specific install directory with `./configure --prefix /path/to/installation`.
21:23:33 <iqubic> Alright. Where do I go to get the binary?
21:23:48 <dmwit> https://www.haskell.org/ghc/download_ghc_8_0_2
21:24:32 <iqubic> That page recomends getting a proper Haskell distribution. Should I do that?
21:25:37 <iqubic> Or is that not needed in my case.
21:25:39 <iqubic> ??
21:25:39 <dmwit> The "Minimal installers" at that link are a pretty nice bootstrap.
21:26:00 <dmwit> Ultimately the decision is yours. There is some discussion of the tradeoffs at the link you mentioned.
21:26:31 <dmwit> Generally I just install GHC. But I am also relatively experienced with getting whatever else I need as it comes up.
21:27:06 <dmwit> It should be possible to make good progress no matter which you choose.
21:27:41 <dmwit> If your goal is xmonad, I would be tempted to recommend avoiding stack, just because I suspect that will make xmonad's "recompile to reconfigure" strategy a bit more difficult.
21:28:19 <iqubic> No. My goal is a fully fledged Haskell development environment.
21:28:32 <iqubic> XMonad is just the WM I like to use.
21:28:39 <Koterpillar> stack is a good choice for dev
21:28:54 <iqubic> Does Stack run on Gentoo?
21:29:09 <dmwit> What would prevent stack from running on gentoo??
21:29:18 <iqubic> I don't know.
21:29:27 <iqubic> It just never has run on Gentoo for me.
21:29:35 <Koterpillar> https://docs.haskellstack.org/en/stable/install_and_upgrade/#linux-generic
21:29:39 <dmwit> Have you found other things that run on most Linuxes but not on Gentoo?
21:29:43 <iqubic> No.
21:29:47 <iqubic> Just stack.
21:30:02 <iqubic> What's the difference between cabal and stack?
21:30:07 <Koterpillar> iqubic: the instructions there even mention gentoo specially
21:30:19 <iqubic> They do? Why?
21:30:27 <lambdafan> how can I use stack to build my dependencies for profiling?
21:30:29 <iqubic> Also, where?
21:30:36 <Koterpillar> iqubic: search for "gentoo"?
21:30:39 <Koterpillar> on that page
21:31:00 <iqubic> I don't find it.
21:31:07 <iqubic> What page are you looking at?
21:31:11 <Koterpillar> https://docs.haskellstack.org/en/stable/install_and_upgrade/#linux-generic
21:31:45 <iqubic> I was still looking at the GHC pages.
21:32:11 <iqubic> So I install Stack first, then get GHC?
21:32:19 <lambdafan> yep
21:32:39 <iqubic> Why?
21:32:40 <Koterpillar> https://docs.haskellstack.org/en/stable/README/ <- iqubic
21:32:47 <Koterpillar> first paragraph
21:33:05 <MarcelineVQ> lambdafan: most directly you just pass --profile as an option when using a command
21:33:35 <lambdafan> hmm, I'm getting empty postscrip files when trying to capture heap data
21:33:48 <lambdafan> I thought it was because I hadn't properly compiled my dependencies
21:33:53 <Koterpillar> as for the difference, with stack you can have independent build environments with pinned versions, with clever sharing to avoid rebuilding
21:34:17 <iqubic> Or I could have just gotten my package manager to work.
21:34:34 <iqubic> But I don't think I did.
21:34:34 <dmwit> ...whereas with cabal, you can have independent build environments with pinned versions and clever sharing to avoid rebuilding.
21:34:38 <lambdafan> you shoudn't use your package manage to install haskell libraries
21:35:04 <iqubic> I shouldn't, why not?
21:35:31 <dmwit> I quail to explain the difference between stack and cabal.
21:35:31 <lambdafan> because one day you'll just end up having to uninstall and do it thr right way. So save yourself time and just do it the right way first time out.
21:35:36 <MarcelineVQ> lambdafan: you're following the steps here? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling-memory-usage
21:36:02 <iqubic> I'm actually at the point where I have to uninstall and do it the right way now.
21:36:04 <dmwit> iqubic: But be careful to read what lambdafan said very carefully. You shouldn't use your package manager to install Haskell *libraries*. Installing GHC itself through the package manager is fine.
21:36:07 <Koterpillar> dmwit: is there a guide where I can learn about this cabal functionality, so I don't mislead people anymore
21:36:08 <dmwit> ?where sicp
21:36:08 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized
21:36:08 <lambdabot> Packages"
21:36:24 <lambdafan> MarcelineVQ: yes, but I thought maybe I had messed up step 1.
21:36:30 <dmwit> iqubic: See the second link there for details on why the package manager can be dangerous if you don't know what's going on.
21:36:55 <MarcelineVQ> lambdafan: I see, I've not used that feature myself so I don't have anything useful to add
21:36:59 <dmwit> Koterpillar: http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/
21:37:42 <dmwit> iqubic: (I can't count. I meant the last link, not the second one.)
21:38:24 <lambdafan> stack test --profile --ghc-options "+RTS -h -RTS"
21:38:54 <lambdafan> ^^ I did that but ended up with an empty postscript file. I mean the graph fram was there, but no plotted graph.
21:39:26 <lambdafan> it does produce the .prof file fine
21:39:28 <dmwit> lambdafan: Presumably `+RTS -h -RTS` should go to the test, not to GHC.
21:39:41 <lambdafan> but I want to make sure I'm using constant memory, and figure the grpah would show me .
21:40:15 <lambdafan> dmwit: I'm not sure of syntax
21:40:45 <lambdafan> how do I pass the -h to stack test then?
21:40:46 <dmwit> Okay. Me neither. But I'm sure `--ghc-options "+RTS -h -RTS"` isn't it.
21:41:06 <lambdafan> hmm okay I will investigate along those lines and see what I come up with
21:41:09 <dmwit> Perhaps `stack test` supports the usual GNU convention of `--` to pass arguments to the spawned processes?
21:41:37 <dmwit> Also might be worth staring at `stack test --help` to see if it has some information on passing arguments to the test program.
21:41:42 <lambdafan> stack test --profile -- -h?
21:41:55 <dmwit> stack test --profile -- +RTS -h -RTS
21:42:06 <lambdafan> ah I WAS JUST ABOUT TO SAY i NEED THOSE BOOKENDS
21:42:10 <lambdafan> oops
21:42:38 <lambdafan> no it makes stack think I want a directory names +RTS
21:43:05 <MarcelineVQ> test is just a --test flag to the build command, so it's quite hard to tell how to pass things along :X
21:43:11 <lambdafan> stack: Most RTS options are disabled. Link with -rtsopts to enable them.
21:43:16 <lambdafan> I got that when I tried
21:43:21 <MarcelineVQ> try --test-arguments=" ..."
21:43:24 <lambdafan> stack test --profile +RTS -h -RTS
21:43:26 <Koterpillar> dmwit: thanks. Am I correct in saying that new-build doesn't pin GHC or support Stackage snapshots?
21:43:35 <dmwit> lambdafan: Indeed, that's definitely not the right syntax either.
21:44:05 <lambdafan> MarcelineVQ: Your syntax started a test!
21:44:18 <lambdafan> okay we'll see if I get a plotted graph from this
21:44:19 <dmwit> Koterpillar: You can pin a GHC version. You can pick a Hackage server, which is what I believe is the essence of Stackage snapshots, right?
21:44:58 <Koterpillar> dmwit: right, I think they even provide something like that
21:45:16 <Koterpillar> dmwit: but not out-of-the-box
21:47:39 <dmwit> I don't know whether Stackage offers its resolvers in a way that's friendly to cabal's `remote-repo` setting. If not, cabal probably does not support Stackage snapshots. If so, it does.
21:49:53 <Koterpillar> dmwit: looks like yes: https://www.stackage.org/lts-8.8/cabal.config
21:51:50 <lambdafan> editor-0.1.0.0: test (suite: editor-test, args: =+RTS -h -RTS +RTS -p -RTS)
21:52:00 <lambdafan> editor-test: unrecognized option `-h'
21:52:06 <newbie83> Hi, a quick question. So there's haskell 98 report, 2010 report, when is the next report?
21:52:13 <lambdafan> Try `editor-test --help' for more information.
21:52:23 <lambdafan> bash-4.1$ editor-test --help
21:52:23 <lambdafan> bash: editor-test: command not found
21:53:13 <glguy> newbie83: no particular schedule
21:53:13 <dmwit> newbie83: I haven't heard much news from the Haskell' committee recently. It wouldn't surprise me if it has stagnated again indefinitely.
21:53:18 <Koterpillar> lambdafan: if all else fails, stack has already compiled you that binary, find it and run it manually
21:53:45 <newbie83> dmwit, thx. I am just curious :)
21:54:05 <newbie83> also glguy :)
21:54:54 <lambdafan> Koterpillar: found it :)
21:55:52 <MarcelineVQ> supicious arg pasing, equals plus? =+RTS
21:56:21 <Koterpillar> MarcelineVQ: is that from your "--test-arguments="?
21:56:27 <lambdafan> yeah
21:56:31 <MarcelineVQ> idk I've never passed things to a test before
21:56:38 <Koterpillar> lambdafan: try getting that equals sign out of it
21:57:19 <lambdafan> oh I think
21:57:26 <lambdafan> I think I see a problem
21:57:49 <lambdafan> I had a space in between --test-arguments and =
21:59:08 <MarcelineVQ> you should be able to use one rts bracket as well:  +RTS -h -p -RTS
21:59:31 <lambdafan> well --profile does +RTS -p -RTS automatically
21:59:37 <MarcelineVQ> fair enough :D
21:59:51 <lambdafan> I just wish --profile took arguments
22:07:57 <iqubic> Currently installing GHC 8.0.2, after a ton of trouble.
22:29:18 <Tertiary> Is it possible to define a function that is local to a class instance? I can obviously use let or where to define something local to one of the class functions, but I would like to have something be accessible by all of them
22:30:47 <dmwit> Nope, not possible.
22:30:50 <EvanR> no, youd have to put it in another module entirely
22:31:37 <Tertiary> That's too bad
22:33:13 <EvanR> you often have a module entirely for instances anyway
23:01:08 <Lokathor> any quick and easy way to make non-ascii characters in a string print out in ghci using their actual character?
23:01:18 <dmwit> putStrLn -- ?
23:01:31 <Lokathor> ghci> print $ dexify "gxis"
23:01:31 <Lokathor> "\285xis"
23:01:47 <dmwit> s/print/putStrLn/
23:02:03 <Lokathor> isn't print just putstrln.show ?
23:02:11 <dmwit> yes?
23:02:13 <dmwit> and?
23:02:33 <Lokathor> okay, well, i guess that worked, now it just throws an exception :P
23:02:51 <dmwit> Make sure your terminal and ghci agree on what encoding is appropriate.
23:02:56 <significance> Is the derived Functor implemenation for ZipList just like that of []?
23:03:04 <dmwit> yes
23:03:14 <significance> dmwit: thanks! 
23:04:33 <Lokathor> dmwit, it's windows, so i'm sure the terminal doesn't agree with anything at all
23:06:28 <MarcelineVQ> the wonders of ｌｏｃａｌｅ
23:07:16 <Lokathor> hmm
23:07:17 <Lokathor> http://lpaste.net/354356
23:07:27 <Lokathor> that is not what i expected
23:07:39 <Lokathor> am i being too rusty with my pattern matching?
23:10:19 <cocreature> Lokathor: I can’t reproduce this
23:10:28 <cocreature> Lokathor: are you sure you’ve reloaded in ghci?
23:10:42 <Lokathor> hmm
23:10:51 <cocreature> the first one results in "\285" and the second in 1
23:10:52 <Lokathor> oh blast it
23:11:04 <Lokathor> it was another encoding bug!
23:11:33 <Lokathor> the windows terminal lets you *type in* accented letters, showing them as normal letters
23:12:07 <Lokathor> so i'd typed "ĝx" and it just looked like "gx"; thanks windows
23:12:24 <pacak> :)
23:12:35 <Lokathor> alright got that squared away
23:12:41 <cocreature> let’s go back to ascii and eliminate all the encoding bugs!
23:12:43 <pacak> I always thought there's just one user of ghc on windows.
23:13:14 <cocreature> pacak: nah there are several. and at least one is also actively working on improving windows support!
23:16:29 <Lokathor> not me!
23:16:54 <Lokathor> that's one area where Rust is really pulling ahead of Haskell; Windows is a proper citizen of their community
23:17:18 <Lokathor> but no rusti for playing around with :/
23:22:17 <EvanR> that might make less sense than a C repl
23:25:18 <Koterpillar> C REPLs exist
23:25:34 <MarcelineVQ> cling is p. cool
23:28:42 <jasondockers> Holy C is a great C-like REPL 
23:38:09 <Lokathor> i want the (!?) operator for my Data.Map values, but stackage is lettin me down :/
23:38:59 <Lokathor> EvanR, I'm not sure why rusti would necessarily make any less sense than python or javascript as a REPL
23:40:32 <pacak> Lokathor: (!?)?
23:41:20 <Lokathor> pacak, the newest version of containers added a new infix op for Data.Map, (!?) :: Ord k => Map k a -> k -> Maybe a
23:42:11 <dmwit> :t M.lookup
23:42:12 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
23:45:30 <Lokathor> dmwit, yes
23:45:41 <Lokathor> but look how many more characters that is when you write it infix
23:45:42 <Lokathor> so many more
23:46:21 <pacak> Lokathor: (!?) = Map.lookup
23:46:22 <Lokathor> instead you have to define your own "m !? k = M.lookup k m" deal
23:47:01 <Lokathor> here i am trying to be grump, and #haskell is just trying to make me not so grump
23:47:02 <Lokathor> <3
23:49:13 <dmwit> I agree, (!?) is more ergonomic in many ways.
23:50:27 <pacak> Not when you have 2-3 different containers in scope and have to use it qualified. In which case lookup is more readable.
23:50:54 <vaibhavsagar> Lokathor: what if you specify containers-5.10 as an extra-dep?
23:51:14 <vaibhavsagar> I tried that the other day and it worked fine for my project
23:51:29 <vaibhavsagar> involved recompiling half of Stackage though :)
23:53:30 <Lokathor> yeah i did that on one project that i really needed it for
23:53:44 <Lokathor> but right now my problem is that String won't let me write out an accented letter, it seems
23:58:46 <dmwit> I doubt it's String's fault.
23:59:05 <Lokathor> yes, well, with some further testing, seemingly GHC itself simply unable to process esperanto characters?
23:59:22 <Lokathor> it gives invalid character problems even with a compiled program and not using ghci
23:59:26 <dmwit> very much doubt this
