00:01:10 <MarcelineVQ> @let foo :: a -> a; foo ex = (ex :: a)
00:01:11 <lambdabot>  .L.hs:169:11: error:
00:01:11 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äòa1‚Äô with actual type ‚Äòa‚Äô
00:01:11 <lambdabot>        ‚Äòa‚Äô is a rigid type variable bound by
00:01:33 <MarcelineVQ> the a of ex :: a is an entirely new a completely unrelated to the a of foo's signature
00:01:53 <pacak> unless you add forall a. and ScopedTypeVariables
00:03:23 <MarcelineVQ> alternatively in the case you're likely preparing where it's a new function you're defining, just use different letters, unless you really mean to make the compiler check that it's the same a, most often it's not needed
00:05:51 <MarcelineVQ> since parametricity will do that checking for you when you use it
00:11:05 * dysfun isn't quite sure how nobody has fixed the "GHC tells you to enable dangerous extensions without warning you they're dangerous" by now
00:11:19 <MarcelineVQ> which once? undecidable?
00:11:33 <dysfun> oh various things. undecidable is probably the most common
00:12:29 <dysfun> ambiguous types, overlapping instances and incoherent instances are others
00:13:56 <MarcelineVQ> ah, hmm overlapping has been relegated to source annotation pragmas now I think, or is at least in the process of depreciating
00:14:12 <dysfun> aha
00:14:22 <MarcelineVQ> dunno about the rest
00:14:43 <dysfun> i mean i know when i need to turn them on, but newbies don't
00:15:35 <MarcelineVQ> :> on the plus(minus) side, most people don't read the errors well enough when they start out to take the errors advice anyway, based on questions that have been fielded here repeatedly
00:16:13 <jchia> Here's the distilled example of the GHC compilation problem I mentioned earlier: http://lpaste.net/354983
00:16:24 <jchia> I'm going to refine it further and add necessary imports
00:16:33 <kuribas> undecidable is scary sounding, but it is actually common
00:16:45 <MarcelineVQ> jchia: thank you, see above
00:18:02 <lpaste> MarcelineVQ annotated ‚ÄúCouldn't match type ‚Äòd1‚Äô with ‚Äòd‚Äô‚Äù with ‚ÄúCouldn't match type ‚Äòd1‚Äô with ‚Äòd‚Äô (annotation)‚Äù at http://lpaste.net/354983#a354984
00:19:49 <Lokathor> MarcelineVQ, I've read the errors before and started turning on flags wildly to make things work
00:19:50 <Lokathor> they did not work
00:20:03 <jchia> MarcelineVQ: In my case where should I add the forall? I added "forall m rd d ." for both foo and bar but it didn't help.
00:20:56 <Koterpillar> Lokathor: I had a case of that, GHC scared me with stating that it was attempting to perform something that is known to be Turing complete
00:21:24 <MarcelineVQ> ah, did the version I put not work? that should have been enough. I believe that implicity they already have those foralls in both spots so repeating that is possibly self-defeating
00:21:33 <jchia> MarcelineVQ: I see you added it only to foo. What's the most straightforward way to understand the logic GHC is using in this sort of situation?
00:21:40 <Lokathor> solve $ M.lookup "Halting" problemsMap
00:21:56 <Koterpillar> Lokathor: at compile time
00:22:03 <MarcelineVQ> possibly 'everything in foo shares the type variable scope I define for foo'
00:22:21 <Lokathor> Koterpillar, means it'll run faster at runtime though!
00:23:35 <MarcelineVQ> I'm not a great person to ask about the why of forall :>
00:24:37 <jchia> Changing the type variable names for bar's context didn't work, either
00:27:24 <MarcelineVQ> didn't work isn't a particularly useful error report
00:27:43 <Saizan> jchia: changing the type variable names would probably make things worse
00:28:27 <Saizan> jchia: btw, it's easier to help if you give the full error from ghc, even better if you provide source we can load in ghci
00:30:07 <jchia> Saizan: http://lpaste.net/354983#a354985
00:30:24 <jchia> Error is still on the line "Just ss -> pure . Just ..."
00:31:14 <jchia> I do have SCT on
00:33:28 <Saizan> jchia: you need the "forall m rd d. .." part on foo and to keep the same names on bar
00:34:02 <Saizan> or maybe just remove the type signature from bar
00:37:03 <Saizan> your signature for bar is promising to work for every d', but actually it can only work for d' = d, where d is the one in the signature for foo
00:37:31 <Saizan> just reusing the variable names does not work though, because they are implicitly freshly bound at the ::
00:37:38 <Lokathor> so is there a way to get a CPP option enabled while compiling a package for my global stack project?
00:38:00 <MarcelineVQ> Lokathor: as a pre-check, why would you need that?
00:38:03 <Saizan> that's why of the forall and the SCT, the forall acts as an explicit binders and SCT allows that scope to extend to the signature of bar
00:38:22 <Lokathor> https://github.com/haskell-game/sdl2/issues/139
00:39:06 <Lokathor> i could do it in a project, but i also like being able to install stuff to the global stack project if it's possible
00:40:41 <jchia> Saizan: Yeah, I saw that adding the forall outside helped, but MarcelineVQ also suggested "just use different letters", so I'm just saying it doesn't work.
00:42:41 <jchia> It's still quite mysterious to me, so I'm looking for ways to understand the error.
00:42:58 <kreetx> hi! question: I'm using declareFields to derive a classy lens, but get a 'Ambiguous occurrance of lensName', what gives? I.e isn't the whole purpose of classy lenses to overcome this?
00:43:37 <MarcelineVQ> Lokathor: passing custom flag options doesn't seem to apply for snapshot packages :(
00:45:58 <MarcelineVQ> Lokathor: but give this a shot anyway   stack install sdl2 --ghc-options="-D_SDL_main_h"
00:46:20 <Lokathor> nope :(
00:46:22 <Lokathor> oh well
01:08:08 <johnw> does anyone build diagrams programs with Nix?
01:09:51 <phadej> johnw: I guess you miss some libs?
01:09:58 <phadej> (c-libs?)
01:10:03 <johnw> yeah, Cocoa
01:10:09 <johnw> it works with nix-build, but not with nix-shell
01:10:56 <phadej> Cocoa :O, that's far from my comfort zone (haven't tried nix on macOS)
01:12:22 <phadej> johnw: wild guess; have you tried nix-shell --pure?
01:12:50 <johnw> that makes other problems
01:13:11 <phadej> johnw: :/
01:16:42 <johnw> ok, I just needed to be inside nix-shell to run cabal build, cabal configure alone is not enough
01:17:45 <phadej> johnw: great you solved it
02:28:04 <Hamlet> Need help with this program..
02:28:09 <lpaste> Hamlet revised ‚ÄúFind largest prime factor of 600851475143‚Äù: ‚ÄúFind largest prime factor of 600851475143‚Äù at http://lpaste.net/354950
02:29:26 <Rembane> Hamlet: You need a = sign on line 30, maybe replace the first $ with a = ?
02:30:24 <Hamlet> No, that gives an error of a more subtle kind..
02:30:41 <Rembane> Hamlet: then it is that error you need to fix. Which error does it give?
02:32:00 <Hamlet> complicated message that I don't understand yet.. so, someone suggested using $ instead... and I get this much less complicated error
02:34:10 <lpaste> Hamlet pasted ‚ÄúError‚Äù at http://lpaste.net/4669923305354952704
02:36:54 <pacak> Hamlet: Add type signatures to every  definition
02:37:56 <Rembane> Hamlet: The FlexibleContexts error generally means: "Hi, I'm the typechecker and I don't get what types you're using. Please give me some clues."
02:39:22 <Hamlet> If I do that, it should resolve the errors(?)
02:40:47 <Rembane> Hamlet: Or give you another one. It is good practice regardless.
02:53:51 <Hamlet> What should be the signature for 'findLargestPrimeFactor'?
02:54:43 <jle`> Hamlet: what do you want it to do?
02:55:16 <Hamlet> It should return a number from a list of numbers
02:55:32 <jle`> sounds like [Int] -> Int, maybe?
02:55:46 <jle`> or [Integer] -> Integer if that's your thing
02:57:01 <jle`> Hamlet: btw, the reason you got a less complicated looking error was because you basically wrote a file that wouldn't parse
02:57:48 <jle`> that's like fixing a leaky boat with a bomb, because then at least it sinks in a less complicated way
02:58:07 <Hamlet> ... because of the $ operator instead of =?
02:58:10 <jle`> yes
02:58:28 <jle`> the syntax goes 'let ... = ... in ...'
02:58:33 <jle`> so there needs to be an equals sign
02:58:36 <jle`> or else it doesn't even make sense
02:58:47 <pacak> type signatures. All over the place.
02:58:58 <pacak> And compare what you think it is with what ghc thinks
02:58:59 <jle`> or, for do notation, the syntax is 'let ... = ...'
02:59:10 <jle`> you're defining a binding
02:59:16 <jle`> 'let x = 10' defines x as 10
02:59:35 <jle`> 'let x' doesn't fit the syntax...and, it doesn't even really make sense as something to say, heh
03:00:31 <jle`> but yeah, you have a type error, and you tried fixing it making a file that doesn't parse.  just becuase the error is simpler doesn't mean that it's a step in the right direction :)
03:00:47 <jle`> i can get rid of any complicated-looking error by just erasing the entire file, after all :)
03:01:18 <jle`> and that gives a much much less complicated error message! :o
03:01:50 <jle`> so yeah, instead of writing invalid syntax, a good step is to add type annotations to everything
03:02:11 <jle`> findLargestPrimeFactor :: [Integer] -> Integer, maybe?
03:02:15 <jle`> listOfFactors :: ??
03:02:18 <jle`> isPrime :: ??
03:02:22 <jle`> main :: ??
03:07:47 <qwr> merijn++ MonadHendrix++ thank you for telling me that Show is not for pretty printing. :)
03:08:25 * qwr hopes the karma thing worked.
03:10:07 <Rembane> jle`: A long time ago there was a bug in GHC which deleted all your source files if you got a type error.
03:12:12 <mfukar> nothing like negative reinforcement
03:28:56 <jchia> I'm trying to use bracketP (https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#v:bracketP) but for the first argument, I don't have a IO a. I only have a MonadIO n => n a. For the second argument, I can also provide a a -> n ().  Is there something I can do to be able to use bracketP with n a instead of IO a?
03:29:26 <kuribas> you don't need GADTs for phantom types, right?
03:30:28 <kuribas> I could do data MyData a = MyData no_a_here
03:30:46 <Akii> kuribas: yes
03:31:11 <kuribas> okay, thanks
03:31:19 <Akii> data Proxy a = Proxy
03:34:25 <kuribas> In my case the extra type gives more information (open curve vs closed curve).
03:37:08 <lyxia> jchia: IO is an instance of MonadIO
03:56:54 <jchia> lyxia: The problem is that bracketP requires IO a, not any MonadIO m => m a.
03:58:26 <Kototama> if free monads are similar to a list of functor, is it nonetheless possible to represent a rose tree with a free monad?
04:03:35 <dibblego> Kototama: with Cofree
04:06:10 <pteiavn> Hi, I'm having a problem installing diagrams with cabal: can someone look at it please? https://pastebin.com/C1vM3573
04:07:13 <pteiavn> I'm using Windows 7 and prior to this I installed the haskell platform (https://www.haskell.org/platform/)
04:08:27 <Kototama> dibblego: no chance without Cofree?
04:09:06 <dibblego> Kototama: sure, you can do it without Cofree, but Tree ~ Cofree []
04:10:06 <Kototama> do you have any examples with just Free?
04:10:53 <Kototama> when interpreting with a monad, how do you merge the monad of the children (for example)?
04:21:48 <lyxia> jchia: how is that a problem
04:22:08 <lyxia> jchia: Every   MonadIO m => m a   is a   IO a
04:23:31 <Kototama> dibblego: can you use multiple times the quantifier variable to represent different children?
04:24:09 <lyxia> jchia: do you mean you're in a context where m is rigid
04:34:56 <Boomerang> Hey ##haskell! What would be an appropriate parallel strategy to filter a list lazily on multiple cores? parBuffer seems close to what I would want but it may be more efficient to put the data in chunks (like parListChunk does but not lazily).
05:06:12 <lyxia> I think it depends on what you consider to be costly. Chunking is okay if applying the predicate dominates over traversing the list (to chunk it)
05:15:06 <mbw> After having gotten to know Repa, I have a collection of questions that need answering. There are a few choices on where to post them. StackOverflow, the Repa google group, haskell-cafe or maybe others. Which would be the most appropriate?
05:15:25 <mbw> Oh, and Reddit maybe.
05:27:54 <mbw> Hmm, seems like this was a stupid question to ask :(
05:28:47 <vaibhavsagar> no, IRC is just quiet right now
05:28:57 <vaibhavsagar> don't take it personally :)
05:29:16 <mbw> Ok then. Phew.
05:29:18 <vaibhavsagar> IRC is a good place to start, but you have to be patient
05:30:29 <vaibhavsagar> I'd go StackOverflow, the google group, haskell-cafe, reddit, and the github issues for Repa in that order
05:31:58 <phadej> SO is good place; helps others 
05:32:17 <zereraz> hi how to watch for file change and build when file changes? stack has a --file-watch flag, does cabal have it?
05:33:07 <mbw> StackOverflow seems like a reasonable choice, since it allows me to typeset Code as well as Math. And like phadej said, it might serve some documentation purpose also. I'll go with so then.
05:40:47 <Athas> mbw: what are you doing with Repa?
05:47:12 <mbw> Athas: Nothing large scale. I have implemented a few toy quantum chemistry programs, which is mostly linear algebra. And it's not like I "failed" to do anything, it's just that there isn't alot of documentation except the one found in the tutorial, the papers, Marlow's book and a few blog posts here and there.
05:48:58 <Tuplanolla> I did the same thing with physics, mbw.
05:49:09 <Tuplanolla> I only ended up publishing GHC bug reports though.
05:49:49 <mbw> That must have been discouraging.
05:56:52 <Tuplanolla> At least I learned a lot about Haskell.
05:59:02 <Tuplanolla> The compiler developers did too, I presume: https://ghc.haskell.org/trac/ghc/ticket/11126#ticket
06:00:13 <mbw> Tuplanolla: But then you HAVE to know this. The standard way to implement the "ijk matmul" seems to be a sum . zipWith on array slices. However, this doesn't scale to the more general forms of tensor contractions. If matmul is "c^i_j = a^i_k * b^k_j", then an expression like "w^i = a^i_k * b^k_j * v^j" won't work with zipWith any more. Now I could either manually zip things, since functions like zip3/zip4 do 
06:00:19 <mbw> exist, but they return manifest, unboxed arrays, not delayed ones. I can delay those, but I don't know if that has an effect on compile-time fusion. OR I could create an intermediate delayed tensor with fromFunction and fold twice. More generally it seems like fromFunction can tackle a lot of problems, but I don't know how "structured" it is, i.e. how much information can be inferred by Repa in order to 
06:00:25 <mbw> parallelize things. Have you encountered this kind of situation?
06:00:58 <mbw> Ah, I've read that bug report before I think.
06:02:12 <Tuplanolla> I don't think I've done that, but I did encounter something similar when calculating vdW interactions.
06:03:49 <mbw> Did you gain any insights?
06:04:12 <Tuplanolla> I duplicated the source array, did the work and finally used `traverse2` to combine them again.
06:04:42 <robertkennedy> I've been getting an increasing number of segfaults while using GHCi. Ideas to start debugging? My current work around was to not add lens to my build-deps, but I think that's just pigeon rites
06:05:11 <c_wraith> robertkennedy: the best place to start is anything that interacts with native libaries.
06:05:23 <mbw> Tuplanolla: Did you use manifest representations as intermediaries?
06:06:01 <Tuplanolla> You generally want to keep the `D` representation as long as possible.
06:06:25 <c_wraith> robertkennedy: some things are especially suspect, like the libcurl bindings.
06:06:26 <Tuplanolla> I only computed `U` when I wanted intermediate results.
06:06:48 <c_wraith> robertkennedy: but any place there's FFI where the type annotations aren't 100% right can result in memory corruption
06:06:50 <robertkennedy> c_wraith: the segfaults seem to happen in code I can reasonably guess is fine (ie read a file in and decide json). I think it might be linking issues?
06:06:51 <Philonous> What's the type of equality called that's encoded by data a := b where Refl :: a := a  ?
06:07:28 <robertkennedy> *decode json
06:07:40 <mbw> Ok, that's what I thought. I always found it confusing that sample algorithms or the stuff found in repa-algorithms returns manifest representations, which can't be fused. Why not just make returning Ds the default and let the caller computeS/P it...
06:08:43 <mbw> A rule of thumb is probably to avoid Ds if you have an iterative algorithm, where one array depends on a the array of a previous iteration...
06:09:01 <c_wraith> robertkennedy: I mean..  If something is segfaulting, the code is not fine.  But memory corruption is subtle.  It can cause the segfault to happen in code very unrelated to where the memory actually got corrupted.
06:10:14 <robertkennedy> Maybe generic aeson or text is messing up, but those are pretty well tested. Stack hiding some cabal failure though, that seems very possible. 
06:10:58 <c_wraith> cabal just calls the system linker.  If that was broken, it would show up in a lot of other places
06:13:31 <robertkennedy> Sure, but I'm pretty sure I've had situations of cabal dependencies leading to runtime segfaults. Trying to remember that case, I think it was like: install old GHC prim, install quick check, install new containers, old GHC prim is updated, use quick check, segfault. 
06:14:03 <Philonous> Ah, found it, it's propositional equality.
06:15:28 <robertkennedy> But you may be right, a linking issue seems like it would be more consistent
06:16:13 <c_wraith> There are two major ways to get a segfault in GHC-compiled code
06:16:30 <c_wraith> The first is an uncorrect unsafeCoerce (or equivalent)
06:16:55 <c_wraith> Something that breaks the type system can result in non-functions being called as functions, which usually results in a segfault
06:17:09 <c_wraith> The second is broken FFI
06:17:14 <c_wraith> Which is far more common.
06:17:19 <LiaoTao> FFI?
06:17:32 <c_wraith> Foreign Function Interface
06:17:41 <LiaoTao> c_wraith, Right, thanks
06:18:07 <c_wraith> the FFI library basically gives you all the unsafety of C, even without linking to C code. :)
06:19:02 <robertkennedy> My segfaulting usually looks like "load ghci, run your environment initialization commands (:set -XTypeApplications et al), pull in massive data stores from files, and if that all works I'm in the clear and the rest of my code is great. 
06:21:42 <robertkennedy> I'll try debugging the mongoDB package - I noticed unsafe functionality, it's probably my least trusted package, and maybe one of the leafs of my json decoding goes through bson. It's a possibility ... 
06:36:45 <vaibhavsagar> can I parametrise a TypeApplication?
06:37:39 <vaibhavsagar> e.g. encodeDecode c = coerce @c . fromJust. decode . encode . c
06:38:44 <erisco> vaibhavsagar, c is a value by being a parameter, and c is a type by being a @-arg, and in Haskell types and values are distinct
06:39:06 <vaibhavsagar> can I use scopedtypevariables or something to allow me to do this?
06:39:23 <erisco> maybe, but you need to describe more of your problem
06:39:42 <vaibhavsagar> it's not a problem, just a curiousity
06:40:04 <erisco> then no, as-is it is an impossibility because types and values are distinct
06:40:04 <vaibhavsagar> so I find that I have to do a bit of newtyping to declare ToJSON instances for my types
06:40:33 <vaibhavsagar> and coerce from Data.Coerce has been a big help, but sometimes it needs a hint
06:40:53 <vaibhavsagar> and in Aeson, an obvious test is encoding and decoding
06:41:12 <vaibhavsagar> e.g. fromJust . decode . encode
06:41:23 <vaibhavsagar> with coercion on both sides
06:41:38 <vaibhavsagar> e.g. coerce . fromJust . decode . encode . coerce
06:42:07 <erisco> scoped type variables will bring the type of c into scope
06:43:30 <vaibhavsagar> so I could define a roundtrip :: c -> Bool; roundtrip constructor = coerce @c . fromJust . decode . encode . constructor?
06:44:44 <erisco> I am not sure what the interaction between TypeApplications and ScopedTypeVariables is, but that seems reasonable, other than I think you want to supply c as the second parameter
06:44:47 <erisco> :t coerce
06:44:49 <lambdabot> error:
06:44:49 <lambdabot>     ‚Ä¢ Variable not in scope: coerce
06:44:49 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòcoerced‚Äô (imported from Control.Lens)
06:45:13 <erisco> okay well I don't know the type of coerce. I was thinking unsafeCoerce
06:46:05 <vaibhavsagar> :import Data.Coerce
06:46:07 <lyxia> vaibhavsagar: roundtrip :: forall c. c -> Bool ; ...
06:47:27 <lyxia> With ScopedTypeVariables, the forall brings the type variable c in scope so that you can write coerce @c. But what you wrote will still be ill-typed because you did not specify what to coerce from, and the result is not Bool-typed.
06:47:38 <vaibhavsagar> lyxia: would roundtrip :: forall c. c -> c work?
06:48:09 <vaibhavsagar> roundtrip :: forall c. (ToJSON c, FromJSON c) => c -> c
06:48:16 <lyxia> that fixes the second issue I mentioned
06:48:25 <lyxia> but why do you even need to coerce
06:48:44 <vaibhavsagar> newtypes
06:49:16 <c_wraith> why not just use the constructor?  then the type system is your ally
06:49:20 <lyxia> Do you mean that decode is not decoding to Maybe c?
06:50:08 <vaibhavsagar> c_wraith: I could definitely use the constructor
06:50:30 <vaibhavsagar> lyxia: I'm really just trying to make coerce @c make sense :)
06:50:31 <Unode> I'm trying to understand infix vs prefix syntax while using applicatives but I'm getting a little stumped with the details. How do you write "(+) <$> a <*> b" in a prefix way? "fmap (+) a <*> b" isn't correct.
06:51:10 <erisco> Unode, how does (+) <$> a <*> b not qualify as prefix? I am confused
06:51:18 <lyxia> vaibhavsagar: You haven't described enough of the problem for us to see the relevance of coerce.
06:51:34 <vaibhavsagar> ToJSON and FromJSON instances of coerce
06:51:39 <Unode> erisco: <$> is infix right?
06:51:48 <vaibhavsagar> oops
06:51:59 <ystael> Unode: liftA2 (+) ?
06:52:21 <erisco> Unode, oh, you're trying to use <$> as prefix, alright. Well then you can  (fmap (+) a) <*> b  . You just had a precedence problems
06:52:21 <vaibhavsagar> lyxia: I'm newtype wrapping types from other modules and defining ToJSON and FromJSON instances for them
06:52:43 <vaibhavsagar> and trying to test these with a cute roundtrip function
06:52:51 <vaibhavsagar> and wondering if I can generalise it
06:53:09 <Unode> erisco: thanks, that's it. I was thinking that the <*> applied first.
06:53:47 <Unode> I think I don't quite get what part is the function in the b argument after <*>
06:55:14 <erisco> sorry back up a minute, I misread
06:55:23 <Unode> oh, nevermind I see what my mistake is
06:55:38 <erisco> fmap (+) a <*> b  and  (fmap (+) a) <*> b  are the same thing
06:55:56 <Unode> the first fmap turns all 'a' into (x +) functions.
06:56:08 <Unode> x being the value contained in a
06:56:21 <erisco> (+) <$> a <*> b  is  ((+) <$> a) <*> b  is  (fmap (+) a) <*> b  is  fmap (+) a <*> b
06:57:35 <Unode> I could swear I had tried the last form...
06:58:17 <Unode> I was doing fmap (+) (a <*> b)
06:58:33 <erisco> yes, that's the incorrect form
06:58:36 <Unode> thanks for the clarification
06:59:09 <erisco> we like to think as applying the function over the operands, so that form feels intuitive
06:59:45 <erisco> but it is as wrong as thinking f x y is f (x y)
07:00:00 <Unode> yup that was my mistake
07:00:08 <Unode> still trying to wrap my head around it
07:00:20 <mbw> Apparently, fromListUnboxed (Z:.100:.100) [1,1..] :: Array U DIM2 Double is bottom :(
07:01:08 <erisco> Unode, another way to think about it is  pure (+) <*> a <*> b
07:02:23 <erisco> so like we read  f x y  as  "f applied to x then applied to y"  we read  f <*> x <*> y  as  "f applied to x then applied to y"
07:02:28 <erisco> which is why another name for <*> is ap
07:03:03 <erisco> now we're lifted in the Applicative, so that is why pure (+) rather than just (+)
07:03:42 <erisco> but otherwise it is designed to mimic function application
07:05:02 <vaibhavsagar> I did it! roundTrip :: forall a b. (Coercible a b, FromJSON a, ToJSON a) => a -> b
07:05:03 <Unode> I still haven't quite understood pure. Working on it.
07:05:22 <vaibhavsagar> roundTrip = coerce @a . fromJust . decode . encode
07:05:38 <vaibhavsagar> thanks lyxiz and erisco!
07:06:53 <erisco> Unode, it is the simpler of the two and should be mostly understood by the type pure :: a -> f a
07:07:14 <Unode> erisco: thanks for the parallelisms. I'll keep reading. Still not at the intuitive level.
07:07:21 <erisco> crudely, it takes a value and sticks it in the Applicative
07:07:38 <erisco> so if it is a list it just makes the singleton list
07:07:43 <erisco> if it is a function it just returns the value
07:08:12 <erisco> if it is Maybe then it sticks it in Just
07:08:51 <erisco> the rest of the understanding of pure comes from the Applicative laws, but for the most part the intuitive definition of pure is the right one
07:11:38 <erisco> Unode, https://en.wikibooks.org/wiki/Haskell/Applicative_functors#Applicative_functor_laws
07:13:13 <erisco> Unode, the homomorphism  pure f <*> pure x = pure (f x)  may be particularly enlightening
07:13:39 <erisco> this is directly establishing the relationship between <*> and $
07:16:06 <erisco> from this you get  pure (+) <*> pure x <*> pure y = pure (x + y)
07:16:57 <mniip> homomorphism?
07:17:21 <Unode> the jargon makes my understanding engine hurt :D
07:17:53 <mniip> homomorphism of what algebraic structures o
07:17:55 <mniip> :o
07:19:45 <erisco> Unode, you can ignore the jargon. it just the equivalence that matters
07:20:35 <erisco> mniip, I don't know, that's just what the Wiki deems it, and it bears the shape of one
07:21:25 <Unode> erisco: yeah I still don't quite get it. in this context 'f' is a structure, not a function right?
07:21:42 <erisco> in  pure f <*> pure x = pure (f x)  ?
07:21:47 <Unode> yes
07:22:03 <Unode> nevermind I see it can be also a function.
07:22:03 <erisco> it is a function
07:22:23 <Unode> I think I'm confusing things.
07:22:26 <erisco> well it has to be because of the type
07:22:59 <erisco> I don't know if it is particularly useful thinking of functions and structures (I presume you mean data types) as being all that different
07:23:18 <Unode> but the type of pure is "a -> f a". I don't get where the f comes from in that context
07:23:42 <erisco> at the type level there isn't anything additionally interesting about it
07:24:02 <erisco> at the value level you have constructors for data types, sure, but you also have syntaxes to construct functions (like lambda)
07:24:05 <c_wraith> Unode: it comes from the instance
07:24:23 <mniip> these are two different f's
07:24:29 <Unode> c_wraith: the instance of?
07:24:31 <c_wraith> Unode: that is, to be an instance of Applicative, a type needs to define pure for its specific type f
07:24:55 <Unode> c_wraith: so in that context, the instance is 'a'?
07:25:07 <c_wraith> Unode: no, the instance is Applicative f
07:25:10 <c_wraith> :t pure
07:25:11 <lambdabot> Applicative f => a -> f a
07:25:13 <Phlogistique> Unode: in other words, you can think of "a -> b" as "(->) a b"
07:25:30 <Phlogistique> and "a -> f a" as "(->) a (f a)"
07:25:43 <erisco> a big unlearning for me has been treating functions as different from data
07:26:12 <erisco> of course there are differences, but they're not so special as to forget the similarities
07:26:33 <erisco> most especially at the types where -> is just any other type constructor
07:26:47 <erisco> (other than specialties like with RankNTypes and so on, but w/e)
07:26:52 <Unode> Phlogistique: doesn't help. Still confused
07:27:37 <erisco> the surprise of seeing Applicative ((->) a) is just that of forgetting this similarity
07:29:06 <erisco> can you implement pure :: a -> Maybe a? sure, pure a = Just a. pure :: a -> (b -> a) ? sure, pure a = \_ -> a
07:29:21 <erisco> it is not all that crazy to see the similarity between Just and (\_ ->)
07:30:23 <Unode> except that one leaves structure afterwards
07:30:31 <erisco> my point is they both do
07:30:36 <Unode> really?
07:31:00 <Unode> I didn't follow then
07:31:07 <erisco> when comes down to the semantics of the language functions have a special place, yes
07:31:31 <erisco> but in a syntactic sense it is similar
07:32:03 <erisco> Just constructs Maybe a, and \_ -> constructs a -> b
07:32:12 <Unode> ok so pure is more like a constructor in other languages? i.e. it ensures things have the same type?
07:32:17 <erisco> particularly  Just :: a -> Maybe a  and  (\_ ->) :: a -> (b -> a)
07:32:53 <erisco> now of course \_ -> is not valid syntax, but this is really a small point
07:33:03 <erisco> because  const x = \_ -> x
07:33:23 <erisco> and if we had  foo x = f x  we'd normally be allowed to eta-reduce to  foo = f
07:33:37 <erisco> and so seeing  const = \_ ->  is not so crazy, thought not allowed in Haskell
07:33:43 <erisco> though*
07:35:04 <erisco> can we pattern match on \_ -> x ? no, and that is a difference
07:36:04 <Unode> I think there's more to that than I can currently grasp.
07:36:19 <Unode> I understand the comparison, but not the implication
07:37:40 <Sornaensis> @src (>>)
07:37:40 <lambdabot> m >> k = m >>= \_ -> k
07:38:55 <erisco> Unode, that's okay. and to answer your question, no pure is not like an OOP constructor, if that is what you meant
07:39:41 <Unode> erisco: yes, that's what I meant
07:39:52 <erisco> the only resemblance is that both can take a value and give you a new value of a different type
07:40:02 <erisco> but so can many functions
07:40:42 <Unode> but pure itself as a function is useless right? it only makes sense in the presence of an instance that defines its behavior
07:40:44 <ski> `pure' is just a type class method
07:40:59 <erisco> data constructors have more resemblance in that they're also authoritative (i.e. this is the only way to construct this type)
07:41:03 <Unode> in other words, ^ yes that's what I was going to say
07:41:09 <Unode> what ski said
07:41:42 <ski> a use of `pure' will either determine the type class instance to use, determining its behaviour, or it will cause the operation using `pure' to itself be overloaded, deferring the choice of instance to the caller of the operation
07:41:43 <erisco> well no, it is not useless
07:42:01 <Unode> so is it correct to say that 'pure's behavior is undefined until a type is given as context?
07:42:13 <erisco> if we want to run a program then yes, we need an instance, but we can still write algorithms on pure without any instance
07:42:26 <erisco> no, that is not correct, as it is defined by the Applicative laws
07:42:29 <ski> Unode : if you're fine with saying that the behaviour of `(+)' (addition) is undefined until a type is given as context, then yeah, sure
07:42:41 <erisco> (as well as the type and theorems derived thereof)
07:42:44 <ski> .. though i'd not express it as "undefined"
07:43:52 <ski> it's a matter of whether the specific instance to use is resolved here, or somewhere else. at some point it must be resolved, however, in order for the code using `pure' (or whatever type class method) to be evaluated
07:44:02 <Unode> ski addition has constrains but yes, I was hinting at the fact that different numeric types could implement different kinds of addition.
07:44:30 <Unode> ok I think I'll go with that for now
07:44:40 <erisco> but you always expect addition to be commutative, associative, have an identity, and so on
07:44:44 <Unode> it's not correct but lets see how far it gets me
07:44:48 <erisco> which is why Float is a right bastard :P
07:45:19 <ski> `pure' is useful in base cases, "trivial" branches
07:47:02 <Unode> thanks everyone
07:47:24 <erisco> here is another way to word it, Unode. "pure" is a specification. To run it, we need an implementation (i.e. instance). Nonetheless, we can still write programs just using the specification of pure
07:47:38 <Unode> always nice to talk to humans when the book and the interpreter don't quite get what I'm trying to say :)
07:47:43 <erisco> also the word "interface" works in place of "specification"
07:48:05 <Unode> erisco: that's how I'm thinking about it, yes
07:48:08 <Sornaensis> :t pure
07:48:10 <lambdabot> Applicative f => a -> f a
07:48:33 <Sornaensis> I thought pure was applicative injection
07:48:51 <Unode> is this also true of every function that has a ":: Type x =>" constraint?
07:48:54 <erisco> and the specification is the type plus the Applicative laws
07:49:10 <Sornaensis> :t return 5
07:49:12 <lambdabot> (Num a, Monad m) => m a
07:49:24 <erisco> Unode, type classes are not types, so Type x => seems suspect
07:49:30 <ski> it shouldn't say `Type', it's not a (concrete) type, it's a type class. better say `Class' then
07:49:34 <Sornaensis> > Just (+3) <*> pure 6
07:49:37 <lambdabot>  Just 9
07:50:01 <Unode> ski, erisco right, sorry, that's what I meant
07:50:29 <ski> Unode : but yes. every such operation is either itself a type class method, or its definition uses a type class method, or an operation which uses ...
07:50:46 <Unode> I still get confused with this distinction. Need to get the hands a bit more into the code.
07:50:56 <ski> (unless you frivolously add a constraint where none were needed ..)
07:51:10 <Unode> ok
07:51:21 <erisco> when we say  f :: a -> B  we're requiring the specification "a is any type". when we say  f :: C a => a -> B  we're requiring the specification "a is any type and a has an instance of C"
07:51:37 <erisco> or "is an instance" perhaps, since in Haskell we only get one
07:51:38 <Unode> ah!
07:51:40 <ski> s/and/such that/
07:51:45 <ventonegro> > (+) <$> Just 3 <*> pure 42
07:51:47 <lambdabot>  Just 45
07:52:01 <Sornaensis> the power of applicative
07:52:45 <ventonegro> > Just (+) <*> pure 3 <*> pure 6
07:52:47 <lambdabot>  Just 9
07:52:51 <ventonegro> and so on
07:53:17 <erisco> the similarity in OOP is generic constraints
07:53:42 <erisco> unconstrained we're welcoming any type. constrained we're welcoming any type which also implements an interface
07:54:29 <erisco> a key difference being that in Haskell type classes are not types
07:54:34 <erisco> whereas in OOP interfaces are types
07:55:24 <erisco> in Haskell, type classes construct constraints (that's what goes left of =>)
07:55:41 <erisco> :k Applicative
07:55:42 <lambdabot> (* -> *) -> Constraint
07:55:51 <ski> @kind Eq
07:55:53 <lambdabot> * -> Constraint
07:56:29 <sproingie> trust me you'll accidentally try to use a class as a type more than once
07:56:30 <Sornaensis> :k StateT
07:56:31 <lambdabot> * -> (* -> *) -> * -> *
07:56:42 <Sornaensis> scary
07:56:57 <sproingie> the fact that they look identical doesn't help of course
07:57:17 <erisco> should have required script case :P
08:01:13 <sproingie> maybe outline letters:  (>>=) :: ùïÑùï†ùïüùïíùïï m => m a -> (a -> m b) -> m b
08:01:40 <shapr> whoa
08:01:57 <nut> Hello could anyone install stack on Windows subsystem for linux?
08:02:48 <thang1> "it's possible"
08:02:52 <Unode> nut: it runs Ubuntu so in theory should be possible
08:03:02 <thang1> https://www.reddit.com/r/haskell/comments/5h9npf/ghc_now_runs_in_windows_subsystem_for_linux/ 
08:03:21 <nut> i know that ghc runs on it
08:03:27 <ongy> not all syscalls are implement/fully compatible on the WSL stuff. And the 1TiB VMEM usage of newer ghc-compiled stuff seems to make problems
08:03:28 <thang1> Unode: it's not a full Ubuntu. They're translating  individual system calls natively back and forth
08:04:00 <sproingie> lot of OS's use syscall translation, doesn't make it second-class
08:04:13 <sproingie> 'course if the translation layer isn't complete...
08:04:35 <thang1> (which the Windows <-> Ubuntu layer isn't, iirc)
08:05:43 <sproingie> well so much of modern linux distros is tied up in systemd, i don't guess they have that translated
08:05:44 <shapr> tromp: want to write an article for The Monad.Reader in your copious spare time?
08:05:55 <sproingie> er, ported
08:06:29 <shapr> I wonder what tmoertel is doing these days?
08:06:33 <shapr> !seen tmoertel
08:06:34 <sproingie> creator update broke the gcc that was bundled with ghc.  i imagine stack has fixed that by now?
08:06:47 <ongy> sproingie: what that's tied to systemd would make sense in WSL? o.0
08:07:20 <sproingie> ongy: if you wanted a full distribution that behaved like ubuntu, basically
08:07:38 <ongy> that's not what wsl can do at the moment either way
08:07:58 <sproingie> but yeah it wouldn't make a lot of sense for MS to support something so completely parallel to services.exe
08:11:09 <c_wraith> it works, but there's some bug in the translation layers that makes the way ghc does IO slow. like, it takes ghci 30 seconds to start 
08:13:04 <liste> @seen tmoertel
08:13:04 <lambdabot> +MOER731
08:13:22 <liste> so @seen == @leet apparently
08:13:39 <shapr> too bad
08:13:43 <ongy> there was also some stuff about the 1TiB memory usage and windows memory manager really not liking forks with that. Iirc that's going to be fixed soonTM
08:14:04 <Sornaensis> @seen yer mam
08:14:05 <lambdabot> yEr M4m
08:14:32 <Squarism> I have a function that now is : IO (SomeType, Writer x y) - i understand that can be written in done in a nicer way with some monad transformer right?
08:14:42 <spatial> http://lpaste.net/354997 Can anyone point out the mistake here ?
08:14:43 <Squarism> -done
08:14:51 <shapr> liste: want to write a tutorial on writing rogue-links in Haskell for TMR?
08:15:08 <liste> shapr: no thanks
08:15:12 <shapr> aw, ok
08:15:21 <tfc[m]> hi there. i am using the persistent library for my DB related work. now i have the problem that i can hardly haddock-document the record fields of the data types i define through the persistent framework. can i somehow "afterward" document them in some markup format? didnt see that in the haddock documentation.
08:15:24 <sproingie> rogue-links?
08:15:31 <shapr> rogue-like, typo
08:15:42 <sproingie> ooh i've been itching to start a roguelike in haskell
08:15:55 <tsani> Squarism: WriterT x IO (SomeType, y) should be equivalent I believe
08:16:01 <sproingie> not too fond of curses tho, i'd want to target gloss or sdl
08:16:15 <shapr> sproingie: want to write a short tutorial about it for The Monad.Reader?
08:16:36 <spatial> Trying to get a list of those random numbers in order to convert into a matrix later.
08:16:57 <sproingie> shapr: sure, once i actually figure it out.  i've been catching up on my theory lately, my actual haskell has rusted away to nearly nothing
08:17:18 <shapr> well, I'm hoping I can get five articles by July, so you have a few weeks.
08:18:46 <shapr> I'm planning on writing an article on going from clash-lang source to a working design on the ice40 FPGAs
08:19:04 <sproingie> interesting.. what's the application?
08:19:30 <liste> shapr: how long an article? maybe on second thought I could write that tutorial, I'm working on a roguelike-like survival/settler game in Haskell
08:19:43 <shapr> I started learning about FPGAs a week ago, so I don't really have one yet; but I did get thoughtpolice' example to build and load onto the ice40
08:20:00 <MarcelineVQ> shapr: that is tangentially relevant to my interests and I wish to subscribe to your newsletter
08:20:17 <shapr> liste: yeah, that's why I asked you :-) Even a few pages of "how to structure a rogue-like and here's a small example" would be good.
08:20:30 <shapr> I prefer LaTeX literate Haskell, but I'll take what I can get.
08:20:46 <shapr> MarcelineVQ: FPGAs?
08:21:18 <MarcelineVQ> Yep
08:21:24 <shapr> I'm taking over as editor for The Monad.Reader again, so I'm looking for articles
08:21:28 * shapr hops excitedly
08:21:32 <shapr> MarcelineVQ: want to write something?
08:22:20 <sproingie> bird-style literate haskell works nice for blogs
08:22:25 <MarcelineVQ> oh no I got you excited :O I don't know anything, they're becoming relevant to other things I'm learning about so I'm interested in them
08:23:54 <MarcelineVQ> *I'm interested in them but know very little about them
08:24:49 <shapr> MarcelineVQ: I learned a bunch in the past week, it's much easier with the yosys/icestorm/arachne-pnr open source toolchain for the ice40
08:26:05 <sproingie> "striving for backwards compatibility is stupid, and we should stop doing it."
08:26:13 <sproingie> sigh.  yeah, screw stable software ecosystems
08:27:02 <robkennedy> Man, the subreddit has been spammed quite a bit lately by news bots
08:27:23 <kosmikus> shapr: http://www.cs.uu.nl/docs/vakken/afp/doc/assignments.pdf still contains (Section 4.3) my old AFP project description to implement a simple rogue-like in Haskell. this is what LambdaHack / Allure on hackage originated from. the task description is hardly Haskell-specific, but it perhaps contains a nice breakdown of a few simple ingredient so that the project of implementing a roguelike appear a bit 
08:27:29 <kosmikus> less intimidating.
08:27:35 <sproingie> what is the deal with those news bots anyway?  does the bot owner get anything of value from it?
08:27:49 <sproingie> is it just some misguided public service or some kind of spam?
08:28:33 <shapr> kosmikus: ooh, want to contribute an article to TMR? perhaps you are familiar with lhs2TeX? ;-)
08:28:33 <robkennedy> I think it's building up reps for accounts to votespam marketing
08:28:50 <sproingie> so basically report them as spam every time
08:28:57 <kosmikus> shapr: sorry, but I have too many commitments right now already. perhaps another time :)
08:29:06 <shapr> Not surprised
08:29:24 <shapr> kosmikus: commitments that involved writing Haskell, yeah?
08:29:31 <sproingie> kosmikus: that's a pretty neat tutorial right there
08:29:38 <kosmikus> sproingie: thanks
08:30:02 <shapr> kosmikus: will you be at the next ICFP?
08:30:12 <kosmikus> shapr: a mixture of writing Haskell, preparing talks, teaching, admin and so on :)
08:30:17 <shapr> sounds like fun!
08:30:19 <kosmikus> shapr: yes, I'm planning to be
08:30:29 <shapr> oh good, I haven't seen you since .. er I forget when.
08:30:29 <kosmikus> shapr: will you be?
08:30:38 <shapr> I'm planning on it, yes.
08:30:44 <kosmikus> since Uppsala?
08:30:52 <shapr> yow, that long?
08:30:57 <kosmikus> I don't know
08:31:02 <kosmikus> I know for sure you've been there
08:31:10 <kosmikus> not certain about any ICFPs after that
08:31:33 <kosmikus> but I think I'm missing one
08:31:33 <shapr> I was at the one in Portland 2006, were you there?
08:31:36 <kosmikus> right
08:31:41 <kosmikus> that's plausible
08:31:43 <kosmikus> yes, I have
08:31:57 <shapr> oh yeah, you crawled in the hotel room window, I remember that.
08:32:07 <kosmikus> what?
08:32:34 <sproingie> functional programmers be a wild and crazy bunch
08:32:46 <shapr> The hotel room windows all led to a rooftop, and you were walking by while edwardk and I were chatting, so I yelled at you, and you came in the window.
08:33:47 <kosmikus> ok, that again sounds somewhat plausible :)
08:33:54 <shapr> :-)
08:40:57 <sm> sproingie: re backwards compatibility, check the date on that post
08:43:02 <sproingie> heh.  ok, i am seeing some of the tongue in cheek tone
08:44:14 <sm> I was a bit disappointed :)
08:44:44 <sproingie> one thing i like about cpan is that installs run the unit tests by default, and every installer can opt-in to have results reported
08:46:06 <c_wraith> hmm. having cabal report build failures on package installation would be pretty cool. 
08:46:54 <sproingie> distribution networks could still learn a lot from cpan.  i like being able to browse by author.
08:47:14 <sproingie> the vague stab at hierarchial package naming helps, too
08:47:57 <sproingie> tho that seems to be a lost battle in most other languages' package networks
08:48:32 <shapr> I like the idea of running unit tests on install, how do we make that happen?
08:49:36 <sm> prototype it in the Cabal lib, I guess
08:49:58 <sm> so maybe it'll work for both cabal-install & stack
08:50:04 <sproingie> depends what the state of 'cabal test' is.  last i used cabal in anger, it was ... well, anger was the appropriate word
08:50:32 <sproingie> stack probably doesn't need it so much for stable stackage versions.  might help suss out platform-related problems tho
08:51:04 <sm> well for stackage an alternative is to run tests at snapshot build time. Maybe they do that already
08:51:53 <sproingie> i imagine that's how a package makes it into a curated version.  no idea what really happens tho.
09:09:23 <MitchellSalad> sproingie: i believe it's just 'stack test' with the default flags
09:12:55 <orion> Would it be terribly controversial for me to suggest that MPTC and fundeps get added to the language, and for MonadBase and MonadBaseControl to get added to base, while MonadIO is removed?
09:14:07 <MitchellSalad> yes...
09:14:11 <MitchellSalad> MonadIO removed? LOL
09:14:16 <EvanR> exactly what is MonadBaseControl good for
09:14:43 <EvanR> all belonging to us?
09:15:00 <Sornaensis> why remove MonadIO?
09:15:07 <cocreature> EvanR: for passing non IO things to things like forkIO
09:15:20 <orion> MonadIO is redundant in the face of MonadBase.
09:15:27 <cocreature> non IO meaning monad transformer stacks on top of IO
09:15:47 <Sornaensis> what does MonadBase do
09:16:02 <EvanR> so its for using forkIO in an IO based transformer
09:16:10 <orion> "Lift a computation from the base monad"
09:16:13 <MarcelineVQ> it gives you liftIO for something not neccesarily IO
09:16:34 <cocreature> EvanR: except it‚Äôs not specific to forkIO, it also allows for things like bracket, ‚Ä¶
09:17:08 <EvanR> i have yet to delve into this embracing IO but not really kind of haskell
09:17:19 <EvanR> im still on purely functional 
09:17:29 <EvanR> or just IO
09:18:44 <cocreature> EvanR: no ReaderT config IO for you? :)
09:18:59 <EvanR> i am so over that
09:19:24 <EvanR> is that an example of when you need monad base control?
09:20:06 <cocreature> try passing something of type "ReaderT config IO a" to "forkIO" and you‚Äôll get a type error :)
09:20:56 <EvanR> dright
09:21:31 <cocreature> monad-control allows you to implement https://hackage.haskell.org/package/lifted-base-0.2.3.10/docs/Control-Concurrent-Lifted.html#v:fork
09:21:55 <EvanR_> and if i try passing a StateT foo IO a to a forkIO, i also get a brain error
09:22:45 <Philonous> You mean because it violates linearity of the state?
09:23:02 <EvanR_> whats linearity of the state
09:24:41 <MitchellSalad> there's a good blog post called "MonadBaseControl is tricky" by Ed Yang... I will try to find it. that's what Philonous is referring to
09:24:53 <MitchellSalad> http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/
09:25:02 <Philonous> I mean that the graph of state dependencies is linear
09:25:28 <Philonous> I.e. each state only depends on it's previous state and only has one successor state
09:25:30 <EvanR> linear graph... state dependencies...
09:25:31 <cocreature> MonadBaseControl feels like a very clunky abstraction but it can be useful sometimes
09:27:15 <sproingie> once you're forking something with state, isn't linearity pretty much out the window?
09:27:52 <EvanR> speaking of IO... heres a weird incongruity i am running into. lets say i have an algebraic data type for making "primitives or combinations of other foos", and one of the constructors encloses an IO action
09:28:05 <sproingie> assuming said forks actually join somewhere
09:28:06 <EvanR> now to build values of this type, i can use global IO actions that are always available
09:28:31 <EvanR> or i can pass in IO actions that i made somewhere else, like if im hooking up a new system
09:28:48 <EvanR> it seems odd i have to pass IO actions in on one hand, but not another, they are global
09:29:03 <EvanR> like "would be nice if it was all global"
09:29:28 <EvanR> or set uppable so the ones i wanted to use were global
09:29:31 <EvanR> which i know we dont like
09:29:41 <EvanR> yet we have putStrLn
09:29:57 <sproingie> which tends to be globally useful
09:30:07 <MarcelineVQ> sounds like your issue is more to do with implicit prelude yeah?
09:30:39 <EvanR> i mean, the ones we use a lot arent passed into a main function from somewhere else after being set up
09:30:48 <EvanR> then passed to "whatever needs it"
09:31:56 <EvanR> i guess i could set up global IVars and have global IO actions based on their resources, which i instantiate later
09:32:36 <EvanR> i could justify it by saying "look, getChar is the same way"
09:32:37 <sproingie> can always use modules to limit visibility.  or pass 'em around if you really want fine-grained control
09:33:00 <sproingie> Prelude is not exactly a paragon of modularity
09:33:08 <EvanR> its not just prelude
09:33:28 <sproingie> well sure.  in general the "import all the things" behavior.
09:33:40 <EvanR> its the difference between your program set up the IO or it was set up by GHC runtime
09:34:10 <sproingie> i prefer to not rely on static initialization behavior :)
09:34:37 <Sornaensis> @info IVar
09:34:37 <lambdabot> IVar
09:34:52 <EvanR> if you didnt need it, it would make a lot more sense to be a global action
09:34:57 <EvanR> if you didnt need initialization
09:35:05 <sproingie> there's less damage such behavior can do in haskell, but once you're dealing with mutable junk in IO, all the same caveats are there
09:35:26 <EvanR> heres my use case
09:35:32 <EvanR> embed "playSound
09:35:42 <EvanR> embed "playSoundEffect" inside values
09:35:59 <EvanR> playSoundEffect is on the same level as putStrLn
09:36:26 <sproingie> you might want to distance your app's action of "play sound" from the actual IO action
09:36:30 <EvanR> except GHC didnt already initialize my sound system for me, it initialized stdio
09:37:06 <EvanR> well, im un-overnegineering right now and getting rid of a lot of framework
09:37:23 <EvanR> having Monoid, IO () makes it really easy
09:38:42 <EvanR> otherwise, i guess putStrLn should also be viewed with suspicion, dont print directly, create a framework for representing the need to print and a separate system to actually do it
09:39:14 <sproingie> FRP is a lot of what that's about
09:39:28 <sproingie> you stream out effects that eventually boil down to IO actions
09:39:39 <erisco> how can I find a list of classes [a] implements?
09:39:46 <erisco> with Hoogle or Hayoo or something perhaps
09:40:03 <sproingie> :i []
09:40:08 <EvanR> sproingie: for my purposes, it seems like a giant waste of time
09:40:13 <EvanR> and code
09:40:35 <sproingie> it's a waste if you don't need it.  not if you do.
09:40:46 <EvanR> how much separation of code into two cooperating code bases can occur
09:41:07 <sproingie> separating effects from their execution means you can test things easier
09:41:12 <EvanR> before your hands get injured
09:41:36 <EvanR> im not writing a test suite
09:41:43 <EvanR> but yeah
09:42:11 <sproingie> if you play around with any of your functions in ghci or write a stub to try it out, you're writing tests
09:42:36 <sproingie> your test runner just happens to be a Mk 1 Eyeball
09:43:17 <EvanR> i went this route and ended up with like 9 systems with their own runners, testers, version of IO
09:43:49 <erisco> sproingie, this only lists for classes you have imported
09:44:06 <sproingie> there's an infinite number of classes you haven't imported
09:44:46 <sproingie> browsing packages by types and classes would be A Neat Idea
09:44:58 <EvanR> ok i reified the IO actions as you suggested
09:45:05 <sproingie> hayoo's probably as close as you'll get but it's kind of the reverse of the index you want
09:47:10 <erisco> sproingie, I realise this
09:47:36 <erisco> but for a library writer trying to export a newtype, it is good to provide the most common instances
09:48:17 <erisco> even just getting everything in base is a bit of work
09:50:13 <erisco> like there is some type classes for serialisation or something or dynamic or something that I never use
09:50:16 <erisco> and I don't even recall the names
09:50:18 <sproingie> the nice thing about open classes is you don't have to think about all the instances up front
09:50:58 <erisco> no one is enthused about standalone instances either
09:51:36 <erisco> right, Data and Typeable
09:52:07 <sproingie> well Typable is pure magic afaict
09:53:02 <aweinstock> win 30
09:53:08 <aweinstock> oops
09:53:14 <erisco> and Generic
09:53:16 <sproingie> damn bro, that's a lot of windows
09:53:20 <erisco> I don't even know what that one is for
09:53:37 <erisco> so it'd be nice to have a list to make this easier
09:53:38 <EvanR> Generic is pretty dope
09:53:58 <EvanR> generate support from the structure of the ADT without template haskell
09:54:37 <lyxia> I love Generic
09:54:51 <erisco> ugh, and Generic1... how many am I missing XD
09:55:26 <glguy> But if you *are* generating code for datatypes via Template Haskell, consider looking at http://hackage.haskell.org/package/th-abstraction-0.1.0.0/docs/Language-Haskell-TH-Datatype.html
09:55:49 <erisco> though if I :i [] with GHC.Generics imported it only gives me Rep [a] and Rep1 [a]
09:56:04 <erisco> oh nvm, I see Generic and Generic1 now... blind
09:59:35 <erisco> "even with cunning GeneralizedNewtypeDeriving"
10:00:03 <EvanR> -XCunningGeneralizedNewtypeDeriving ?
10:01:59 <erisco> didn't know DeriveTraversable was a thing... apparently newtype deriving can't get it
10:02:12 <sproingie> -XCunningPlan
10:02:34 <glguy> erisco: It's just different altogether from NewtypeDeriving
10:02:44 <erisco> then for some reason both Rep and Rep1 are not allowed derivings
10:02:52 <sproingie> GNTD is unfortunately still not kosher with Safe
10:03:50 <sproingie> something to do with leaking private details from modules
10:04:36 <erisco> I haven't a clue how this Rep/Generic stuff works, or even what it is
10:04:47 <erisco> do I just need deriving Generic and Generic1 and not Rep and Rep1?
10:05:03 <glguy> deriving Generic or Generic1 will automatically derive Rep and Rep1
10:05:41 <erisco> okay, thanks
10:10:38 <glguy> Generics allows you to look and normal algebraic data types as sums of constructors ((:+:)(L1,R1)) and products of fields ((:*:)(:*:)) in a sort of binary tree view. metadata is interspersed into the representation at the datatype level (D1), constructor level (C1), and field level (S1), finally you get to fields (K1): from "test" == M1 (R1 (M1 (M1 (K1 't') :*: M1 (K1 "est"))))
10:11:23 <glguy> D1 C1 and S1 are all type synonyms for M1, the metadata itself is accessible via phantom type parameters
10:13:04 <adamCS> There are some libraries which are like generics but use a different representation.  generics-sop uses type-level-list indexed sums (of constructors) and products (of fields) indexed by type-level lists. generics-eot is another.
10:14:00 <adamCS> Those representations are all derivable from the GHC generics one.  I found it helpful to look at those (especially generics-sop). 
10:31:45 <orion> :t (:*:)
10:31:46 <lambdabot> error: Data constructor not in scope: :*:
10:31:51 <orion> :k (:*:)
10:31:53 <lambdabot> error:
10:31:53 <lambdabot>     Not in scope: type constructor or class ‚Äò:*:‚Äô
10:31:53 <lambdabot>     Perhaps you meant ‚Äò:~:‚Äô (imported from Data.Typeable)
10:32:04 <orion> Are these standard operators?
10:32:22 <mniip> yes
10:32:32 <mniip> :k GHC.Generics.:*:
10:32:33 <lambdabot> error:
10:32:33 <lambdabot>     Operator applied to too few arguments: GHC.Generics.:*:
10:32:38 <mniip> :k (GHC.Generics.:*:)
10:32:40 <lambdabot> (* -> *) -> (* -> *) -> * -> *
10:35:27 <jaykay123> hey
10:35:36 <jaykay123> so what does it mean when a Haskell expression is referentially transparent?
10:35:45 <jaykay123> it always evaluates to the same thing
10:35:47 <jaykay123> what does that mean?
10:35:58 <EvanR> i dont think thats the right answer
10:36:09 <jaykay123> what siis it?
10:36:12 <jaykay123> is8
10:36:13 <jaykay123> *
10:36:41 <EvanR> people mix up that longer phrase with "pure" a lot
10:37:07 <jaykay123> pure just means it doesn't consult memory right?
10:37:18 <mniip> no
10:37:24 <jaykay123> what does it mean then?
10:37:25 <EvanR> both terms lead to separate universes of interpretations
10:37:52 <c_wraith> referentially transparent means that there's no difference between an expression and the result of that expression. 
10:38:06 <jaykay123> c_wraith do you have an example?
10:38:13 <EvanR> result of an expression
10:38:28 <mniip> jaykay123, (1+2) in every aspect is equivalent to 3
10:38:31 <mniip> you cannot tell them apart
10:38:32 <jaykay123> yeah
10:38:57 <c_wraith> jaykay123, the important part is that it applies to *all* expressions. 
10:39:20 <c_wraith> you can't write a function that does anything more than just calculate its result. 
10:39:39 <EvanR> that gets into purity
10:39:54 <mniip> EvanR, I'm probably guilty of that too, RT is the part where a function's definition can be substituted at call site, right?
10:39:55 <c_wraith> it's also part of referential transparency. 
10:39:59 <EvanR> and in explaining what functions cant do, when they obviously cant by definition of function, its confusing as hell
10:40:20 <EvanR> as for referential transparency, i think its been diluted and misinterpreted to all hell to become almost useless
10:40:48 <Tuplanolla> I thought referential transparency meant that this 42 over here is indistinguishable from that 42 over there.
10:40:58 <jaykay123> this is confusing af
10:41:00 <EvanR> that sounds like yet another kind of RT, from OOP
10:41:02 <sproingie> it means you can replace a function with its result everywhere
10:41:02 <Hamlet> Q: Does anyone know of / has used Helium (compiler)? It's supposed to be for newbie Haskellers.
10:41:24 <sproingie> you can think of a function in that sense as a "reference" to its result, ergo it's transparent
10:41:30 <EvanR> sproingie: do you mean, replace a function application with a result?
10:41:53 <sproingie> naturally.  the function itself is a value, application yields its result.
10:42:09 <c_wraith> Hamlet, it is primarily for avoiding ghc's error messages, which often refer to much more advanced concepts than a beginner is ready for. 
10:42:12 <sproingie> (precise terminology being at odds with clarity sometimes)
10:42:19 <jaykay123> an expression is 1+2 yeah:?
10:42:27 <jaykay123> so 1+2 is always 3
10:42:29 <jaykay123> never changes
10:42:33 <c_wraith> Hamlet, but the cost is that it doesn't support more advanced features at all. 
10:42:45 <jaykay123> thus why that expression is referentially transparent
10:42:46 <EvanR> sproingie: alright, so in what sense can i NOT replace unsafePerformIO launchMissiles with ()
10:42:47 <sproingie> learning to read ghc's error messages is a skill people should learn from day 1
10:42:52 <Hamlet> I don't mind. I'm new to the language.
10:43:29 <EvanR> what missing thing from your explanation did that run afoul on
10:43:30 <sproingie> EvanR: in that it has side effects you expect it to execute on every call.  if you substituted it, then it would only launch ze missiles once (presumably after you evaluated it once for the result)
10:43:37 <c_wraith> Hamlet, in many cases, you could. those advanced features include things like (+) working with more than the pre-defined set of types. 
10:43:44 <jaykay123> am I right in what I'm saying about for the referentailly transparent?
10:43:53 <EvanR> sproingie: thats so far afield from referntial transparency...
10:44:25 <sproingie> if you consider the effect part of the returned value, then it's RT again
10:44:27 <EvanR> jaykay123: youll need to take literally everything people "know" with a grain of salt here, and look up some book references
10:44:34 <EvanR> sproingie: :|
10:44:36 <c_wraith> Hamlet, or along those lines but even simpler, supporting (==) for user-defined types 
10:44:43 <jaykay123> but that means the whole concept of it is screwed then right?
10:45:03 <EvanR> jaykay123: do you know what a pure function is?
10:45:29 <jaykay123> it's when you take an input into a function and there's no side effects
10:45:41 <EvanR> hrm.
10:45:57 <EvanR> the level of precision here is lacking
10:46:00 <EvanR> oh well
10:46:09 <sproingie> your function that calls launchMissiles can still be pure in other respects, so if there's no observable effect outside of functionThatCallsLaunchMissiles, you're fine
10:46:21 <EvanR> launchMissiles isnt a function
10:46:21 <sproingie> just that launching missiles tends to be observable :)
10:46:31 <jaykay123> side effects being that nothing else can change the state
10:46:34 <jaykay123> what you put in is what you get out
10:46:37 <jaykay123> always
10:46:49 <EvanR> theres not necessarily any state in sight here
10:47:37 <erisco> ski, did we ever figure out the Applicative/Alternative interaction?
10:47:40 <sproingie> launchMissilesAndAdd
10:47:41 <EvanR> sorry youre looking for a quick answer that i havent seen any evidence for the existence of in a few years
10:47:53 <sproingie> can still have a perfectly pure add function in there
10:50:30 <sproingie> unsafePerformIO is a deliberate backdoor though
10:52:01 <pikajude> is safePerformIO in the standard library anywhere
10:52:09 <erisco> I also remember something like  data X a b = This a | That b | Both a b  but cannot remember X
10:52:16 <pikajude> These
10:52:20 <erisco> thanks
10:52:30 <pikajude> sure thing
10:52:38 <mniip> pikajude, id
10:52:57 <EvanR> jaykay123: you will find people referring to referentially transparent programming languages, referentially transparent expressions, referentially transparent functions, referentially transparent contexts, at least. without more effort you may find yourself or other people making up some sort of meanings these on the spot based on the fact that they all use the same words, so it must mean the same thing somehow
10:53:01 <Tuplanolla> You could say the runtime has it and calls it once with `main`, pikajude.
10:53:05 <pikajude> how can I be sure id is safe
10:53:21 <erisco> a nice use for  tie :: (These a b -> c) -> [a] -> [b] -> [c]
10:53:27 <mniip> annotated by safehaskell
10:53:33 <sproingie> there's only one thing id can do
10:53:36 <erisco> like zip, but consumes up to the longer list
10:53:47 <mniip> sproingie, about 3 things actually
10:54:17 <sproingie> paying no attention to bottom, yeah
10:55:42 <Hamlet> How do I start using it? [I just downloaded the file from https://hackage.haskell.org/package/helium]
10:56:10 <EvanR> jaykay123: try this one https://plato.stanford.edu/entries/belief/#2.3
10:56:16 <sproingie> mniip: with bottom there's two things it could do, what's the third?
11:00:52 <erisco> lol... if only the "these" package wasn't silly in its dependencies...
11:00:58 <erisco> I need attoparsec? oO
11:00:58 <sproingie> helium's homepage recommends cabal-installing it
11:01:06 <erisco> because it has ToJSON instances I think
11:01:06 <EvanR> erisco: i know...
11:01:13 <sproingie> looks like it hasn't been touched in a whole, not sure if it even still works
11:03:50 <dolio> EvanR: That article won't help explain what people mean by "referential transparency" in the context of functional programming.
11:05:31 <EvanR> it seems that some instances of what people mean could be explained by taking that articles critical sentence and changing a couple words to match haskell, and then probably open up a few more questions
11:06:10 <EvanR> first of all, what kind of thing can be RT
11:06:39 * ski . o O ( "Referential Transparency, Definiteness and Unfoldability" by Harald S√∏ndergaard,Peter Sestoft in 1987-11-30 - 1990-01-04 at <http://www.itu.dk/people/sestoft/papers/SondergaardSestoft1990.pdf> )
11:06:53 <Hamlet> I tried running 'cabal' to install Helium, but got error messages. | I think it best to install from source [which I downloaded].
11:07:10 <sproingie> looks like the epistemological definition of referential transparency lines up just fine with the CS definition
11:07:34 <Hamlet> I.e. How do I install directly from source?
11:07:37 <mniip> sproingie, hmm, maybe you're right
11:07:46 <mniip> I was confusing with () -> ()
11:07:51 <EvanR> sproingie: *the* definitioins?
11:08:40 <c_wraith> ok, I've got a better definition now. referential transparency is when let x = exp1 in exp2 is always the same as inlining exp1 for all uses of x in exp2
11:09:26 <sproingie> if Quine in fact coined the term, then it would be the same definition (har har)
11:09:26 <EvanR> is the same, so they have the same meaning, same interpretation?
11:09:37 <sproingie> unlike, say, "monad"
11:09:50 <Tuplanolla> Good find, ski.
11:09:55 <glguy> Hamlet: Helium doesn't appear to build because one of its dependencies, lvmlib, hasn't been updated to work on recent versions of GHC and the author didn't both documenting the versions that it does work on
11:10:03 <EvanR> not necessarily the same result when reduced, since that doesnt capture side effects
11:10:45 * mniip . o O ( have you tried proton-proton synthesis )
11:10:50 <dolio> The whole point is that side effects break this property.
11:10:56 <erisco> so... let x = exp1 in exp2 ‚â° [x/exp1]exp2  ?
11:11:00 <Hamlet> Yes. So I'm attempting to install from downloaded source (via Hackage)
11:11:36 <EvanR> yes, so its a very roundable way to say that
11:11:39 <dolio> Or, they may.
11:11:40 <EvanR> roundabout
11:11:54 <sproingie> easy with stack for maintained packages.  otherwise, you get to figure out which stackage version it might build with, if any at all
11:11:55 <ski> hm, <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf> may be a better link
11:12:11 <EvanR> and so purity is the shorter more direct way to talk about that
11:12:49 <dolio> "Purity" is sometimes used for a different property.
11:12:55 <sproingie> the interesting thing about helium to me was the graphical stuff.  ghc error messages aren't actually that cryptic, just very verbose
11:13:01 <erisco> let x = exp1 in exp2  can also be seen as  (\x -> exp2) exp1  (then you get EvanR's statement)
11:13:13 <sproingie> they used to be worse.  i remember when hugs had the better error messages
11:13:37 <EvanR> now its a question of function purity
11:13:42 <ski> @where purely-functional
11:13:42 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
11:14:14 <Hamlet> <Ahem...>
11:14:58 <Tuplanolla> Cabal already installs from source, Hamlet. Your question is too vague.
11:15:45 <Tuplanolla> (Cabal Install, really.)
11:15:59 <erisco> EvanR, I am not sure if function purity really touches on the same thing though, because c_wraith was getting at the equivalence after substitution
11:16:22 <EvanR> "you can exchange equal things with equal things to get an equal thing"
11:16:35 <Hamlet> I downloaded tar file of helium-1.8 from Hackage.. unpacked it.. .. Am trying to build it or whatever to use it
11:16:45 <EvanR> which at least sweeps several different issues under the same rug
11:16:55 <erisco> yes, which doesn't answer the same question
11:17:02 <dolio> No, there are two somewhat related properties in question.
11:17:19 <dolio> One is that you can factor out or inline subexpressions without changing the answer.
11:17:36 <dolio> One is that you can evaluate expressions in different orders without changing the answer.
11:17:47 <erisco> if we suppose f does care about the reference x, then it doesn't matter whether x refers to m or to n
11:17:56 <EvanR> thats two more issues yes
11:18:13 <EvanR> which isnt addressing the sending of email as a result of evaluation
11:18:24 <EvanR> or depending on the time of day
11:18:25 <sproingie> helium doesn't even have type classes.  you want that experience, try Elm
11:18:37 <sproingie> elm has the advantage of actually being maintained and having a community
11:19:01 <dolio> Okay. I misspoke. I don't care about "the answer" I care about what I care about. What matters is that those transformations don't change anything that I care about.
11:19:30 <EvanR> interesting
11:19:35 <dolio> Whether or not my program sends an e-mail, or what order it sends them in, is something I care about.
11:20:06 <EvanR> ok
11:20:37 <EvanR> now that we elucidated that much, the word "reference" here now seems pretty contrived
11:21:07 <EvanR> we should call it what-i-care-about-durability
11:21:20 <Hamlet> ... ahem! ...
11:21:22 <sproingie> don't need first class "references" to talk about "referential"
11:21:39 <dolio> No, the 'reference' part is there because I have no way to even talk about inlining/factoring without having names/references.
11:21:44 <monochrom> My http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz explains the equal-for-equal thing.
11:21:56 <monochrom> But yeah evaluation order is an orthogonal issue.
11:22:07 <EvanR> expressions dont have to be references or names or anything, its just syntax
11:22:37 <sproingie> "name" works pretty well too.  fully applied function is just another name.
11:22:54 <monochrom> Hamlet: Are you sick? Is your throat doing OK? Do you need to see a doctor?
11:23:17 <EvanR> if there are no references or reeferring going on, whats the point
11:24:20 <dolio> EvanR: The point isn't the 'what-I-care-about-durability'. The point is that there are multiple different things that I want to be durable.
11:24:21 <sproingie> in my house, reefering doesn't go on til around 4:20 if i want any work done
11:24:23 <EvanR> if the whole program is being analyzed, and what-i-care-about is the subject
11:24:27 <dolio> Each different thing has its own name.
11:24:45 <EvanR> why are we coopting this linguistics term that is about something entirely else
11:25:00 <EvanR> yes
11:25:17 <dolio> Because someone 15 years ago borrowed terminology and language has evolved.
11:25:18 <Hamlet> waiting to start building the Helium package from source. ... Haven't the foggiest idea how to do that. :)
11:25:19 <erisco> because humans operate on analogy
11:25:49 <sproingie> as for the semantics of using a name, that's actually a pretty deep rabbit hole
11:25:49 <dolio> Maybe more than 15.
11:26:05 <EvanR> analogy, the situation is as dolio described, and more or less often we deal with it by making up a retroactive reason for these words to be used
11:26:17 <EvanR> i guess thats analogous
11:26:20 <EvanR> in some way
11:26:29 <erisco> I am using "ZigZag" in my new module
11:26:53 <Hamlet> there is a 'Setup.hs' script.. but loading that gives a '*Main>' prompt
11:26:58 <erisco> because if you squint and draw a picture it looks like a zig-zag
11:27:06 <EvanR> i guess id like to see a principled reconstruction of jargon here
11:27:25 <erisco> and it is a short name
11:27:40 <erisco> intuition + short name = excellent nomenclature
11:28:28 <Hamlet> ... there is also a Cabal configure file
11:28:32 <sproingie> Hamlet: runhaskell Setup.hs
11:28:40 <sproingie> that's the entry point to cabal
11:28:50 <sproingie> i can just about guarantee you it won't work out of the box tho
11:29:16 <erisco> in conversations with other people I say things like  toasted (onion <> butter <> bread) = excellent sandwich
11:29:28 <sproingie> building bit-rotted haskell projects was sheer hell before stack
11:29:35 <sproingie> now it's only slightly hell
11:29:57 <Hamlet> it loads a module, nothing else
11:30:21 <erisco> and to my surprise they ask me if this instance of <> commutes
11:30:42 <sproingie> it loads a module that parses the CLI.  i believe running it without args gives help
11:31:21 <sproingie> whoever designed the interface obviously liked how python distutils does it
11:33:37 <erisco> I asked the worker at Subway to fix me a sandwich but they said their register could not prove the total
11:34:08 <sproingie> fix sandwich = sandwich(sandwich(sandwich(sandwich...
11:34:46 <kuribas> is it possible to have unboxed vectors with compacted fields?  Unboxed tuples vectors are tuples of vectors, which have bad locality...
11:36:40 <sproingie> Data.Vector.Unboxed?
11:36:58 <kuribas> sproingie: yes
11:37:19 <kuribas> Vector (Double, Double) is (Vector Double, Vector Double).
11:37:24 <kuribas> It has bad locality
11:38:00 <dolio> No, it has good locality for some things and bad for others.
11:38:02 <Hamlet> Q: How do I use cabal to run configure file [helium.cabal] file?
11:38:09 <dolio> Just like the alternate way of storing it.
11:38:27 <sproingie> usual thing when you want a packed vector is to just flatten it and use n-length spans of that vector
11:38:36 <sproingie> at least that's how all the opengl code i've had to write goes
11:38:48 <monochrom> batman_song = fix Na -- while we're at it
11:38:58 <dolio> Anyhow, there could be tuple instances for Prim (I think that's the class), but there aren't right now.
11:39:01 <kuribas> sproingie: right
11:39:02 <sproingie> (not in haskell though, i never got past immediate mode in haskell opengl)
11:39:12 <dolio> Storable vectors are array of structures.
11:40:27 <lyxia> You can also implement a custom unboxed Vector that has the layout you want
11:42:04 <Boomerang> I'm curious: Why isn't the function splitOn (from the split package) part of Prelude when other more specialized functions are (e.g: lines, words)?
11:42:50 <lyxia> History
11:43:38 <erisco> oh, hmm... so has the campaign for  Semigroup m => Monoid m  begun?
11:45:38 <sproingie> may as well add Magma too
11:45:56 <erisco> I don't think that one makes any sense
11:46:09 <sproingie> associativity not being enforceable, they'd be the same thing i guess
11:46:22 <lyxia> Boomerang: http://mail.haskell.org/pipermail/haskell-cafe/2006-July/016559.html basically people get lost in bikeshedding every time it coomes up
11:46:34 <sproingie> i just like Magma, i'm a DF fan :)
11:46:48 <erisco> it doesn't make sense because we already have closure by the type
11:47:29 <erisco> so not only is there an absurd number of Magma instances for most types, but there is nothing added
11:51:27 <erisco> you even have const and flip const for free
11:53:19 <erisco> I also wonder how long it will take after DT Haskell (which is already somewhere over the rainbow) to get class laws added to the classes
11:55:06 <erisco> might be harder than DT Haskell itself :P
11:55:26 <rightfold> Is there a nice way to signal to a thread that is probably waiting on a TQueue to cancel this operation? Do I have to use throwTo?
11:55:41 <Boomerang> lyxia: thanks for the link! I've been implementing my own splitOn function for many HackerRank problems. Turns out, the split library is included anyway ^^
11:56:18 <erisco> :t splitOn
11:56:19 <lambdabot> Eq a => [a] -> [a] -> [[a]]
11:56:40 <erisco> weird
11:57:24 <erisco> for many problems? what problems is it used in?
11:58:16 <sproingie> > "foobarbazbarxyzzy" `splitOn` "bar"
11:58:18 <lambdabot>  ["bar"]
11:58:28 <sproingie> well that was less than expected
11:58:46 <Boomerang> all hackerrank problems require to parse some input. I tend to use interact as the only IO function and then have to split the String properly
11:58:55 <rightfold> sproingie: flip splitOn
11:58:56 <sproingie> > splitOn "bar" "foobarbazbarxyzzy"
11:58:58 <lambdabot>  ["foo","baz","xyzzy"]
11:59:04 <erisco> > splitOn [1,2,3] [9,8,1,5,2,5,4,3,0]
11:59:06 <lambdabot>  [[9,8,1,5,2,5,4,3,0]]
11:59:13 <erisco> well I don't understand it actually
11:59:39 <erisco> oh, so this is PHP's explode
11:59:59 <erisco> or preg_split I guess because I think explode is just on a single char... been years :P
12:00:09 <Boomerang> > splitOn "\n" "hello\nworld\n!!!" -- same as lines
12:00:11 <lambdabot>  ["hello","world","!!!"]
12:00:36 <erisco> make sense... not sure why I thought of some other weird thing
12:00:44 <ski> > splitOn "" "abcd"
12:00:46 <lambdabot>  ["","a","b","c","d"]
12:01:13 <sproingie> the leading "" is kind of unexpected
12:01:18 <ski> weird with the initial empty string ..
12:01:20 <Boomerang> why isn't there an extra "" at the end?
12:02:03 <Boomerang> The reason they have extra empty strings is to you can reverse it with intercalate
12:02:08 <Boomerang> *so
12:02:36 <Boomerang> But with empty string as separator it doesn't matter anyway
12:02:48 <erisco> I find the notion of splitting on the empty string strange, never mind what it actually does
12:03:32 <ephemeral> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-List.html#v:intercalate
12:03:34 <Tuplanolla> I would've expected an infinite list of empty strings.
12:03:48 <ephemeral> hmm, where can I find the actual function definition, and not just the type signature?
12:04:26 <geekosaur> that should have a Source link at the far right
12:04:43 <geekosaur> but, it might actually be in Data.Foldable...
12:04:44 <ephemeral> right on, sitting on a very wide screen, so totally missed it
12:05:07 <rightfold> When I read a TVar, then block on a TQueue read inside the same transaction A. And then a different transaction B modifies the TVar, is transaction A retried immediately?
12:05:17 <sproingie> always advancing at least one position makes sense for a split algorithm, so no infinite lists
12:05:21 <sproingie> *of ""
12:05:38 <sproingie> which also makes the leading "" make some sense, even if it's useless
12:05:53 <erisco> lets see... if we look at the problem non-deterministically then we can start with all the 2-partitions of the string
12:06:19 <ephemeral> heh, so xss is the usual way to refer to the value of a list of lists?
12:06:25 <erisco> so "foobarqux" has ("f","oo","barqux") for example as a 2-partition
12:07:02 <erisco> then we find just those with a middle group of the needle and conquer on the left and right groups
12:07:30 <erisco> then we can observe that all paths lead to the same answer
12:08:33 <lyxia> rightfold: Having just tried it, it seems to work that way
12:08:36 <erisco> so to answer the empty string problem we just have to be careful about how we define the 2-partitions
12:08:56 <ski> i suppose with `splitOn sep list' you want no element of the resulting list to have `sep' as a contiguous sublist
12:08:59 <rightfold> lyxia: that's very nice, but I couldn't make it up from the docs
12:09:01 <erisco> so ("","foo","barqux") might be one, as well as ("foo","","barqux"), and also ("foo","barqux","")
12:09:02 <lyxia> rightfold: for you initial question you can use <|>
12:09:10 <erisco> or ("foobarqux","","") and so on
12:09:11 <ski> which makes the case with `sep = []' problematic
12:09:32 <sproingie> which suggests to me empty results should just be elided
12:09:33 <ski> hm .. i suppose that specification isn't though
12:09:35 <lyxia> rightfold: I don't think the docs explain that
12:09:49 <erisco> so... we certainly have  ("","","foobarqux")  then, so "" has to be a split
12:09:49 <ski> > splitOn "aba" "xababay"
12:09:51 <lambdabot>  ["x","bay"]
12:10:04 <ski> (why not `["xab","y"]' ?)
12:10:05 <erisco> but so is ("foobarqux","","") and so "" is another split on the end
12:10:07 <rightfold> lyxia: thanks, I'll get to my PC and give it a try
12:10:36 <erisco> and there are a bunch of empty splits in the middle
12:11:15 <erisco> so they've gone with it differently where the partitions may coincide on the start but not in the middle nor the end
12:11:28 <ski> sproingie : a somewhat similar problem arises in Prolog, with a concat/2 predicate, where `append(ListOfLists,Concatenation)' is to hold when `Concatenation' is the concatenation of all the lists in `Concatenation'
12:11:34 <sproingie> > splitOn "foo" "foobar"
12:11:36 <lambdabot>  ["","bar"]
12:11:46 <sproingie> aha
12:11:54 <erisco> > splitOn "bar" "foobar"
12:11:56 <lambdabot>  ["foo",""]
12:12:00 <erisco> oh wow
12:12:07 <Boomerang> @check ((\x sep -> (intercalate sep . 
12:12:08 <Boomerang>                   splitOn sep) x == x) :: [Char] -> [Char] 
12:12:08 <lambdabot>  <unknown>.hs:1:32:Parse error: EOF
12:12:11 <Tuplanolla> > splitOn "foo" "foo"
12:12:13 <lambdabot>  ["",""]
12:12:19 <erisco> well actually this one is fine, because that is ("foo","bar","")
12:12:22 <Tuplanolla> > splitOn "" ""
12:12:23 <lambdabot>  [""]
12:12:28 <lyxia> rightfold: I guess it's implicit that blocking is implemented with 'retry'
12:12:29 <ski> sproingie : in case `Concatenation' is known, and `ListOfLists' is solved for, there's infinitely many solutions, unless we disallow the empty list being an element of `ListOfLists' .. but in that case, for consistency, we should fail if `ListOfLists' known to contain an empty list, and `Concatenation' is solved for ..
12:12:34 <Tuplanolla> I'm unsatisfied with this.
12:12:35 <Boomerang> @check ((\x sep -> (intercalate sep . splitOn sep) x == x) :: [Char] -> [Char] -> Bool)
12:12:37 <lambdabot>  +++ OK, passed 100 tests.
12:12:53 <sproingie> eh.  every language's "split" has odd corner cases.
12:13:06 <ski> Boomerang : yes, that's the least one could expect
12:13:13 <Tuplanolla> We should implement and provide all possible definitions.
12:13:17 <lyxia> rightfold: and the semantics of 'retry' are either assumed to be common knowledge, or nobody bothered to extract it from the paper and put properly in the docs.
12:13:54 <erisco> empty haystack is interesting because the partitions have to coincide on the start, middle, and end, but we have to exclude middles and ends
12:14:00 <erisco> so that has to be a special case
12:14:13 <erisco> this is a good example of why their version is odd
12:14:30 <lyxia> somehow I doubt that QuickCheck test had a lot of coverage.
12:15:38 <Boomerang> Doesn't QuickCheck prioritise the obvious edge cases? Such as empty lists?
12:15:40 <erisco> well actually it is just the base case, isn't it, so whatever
12:16:13 <erisco> ("","","") doesn't make any sense for it because then we conquer on "" again, twice, and never terminate
12:17:49 <rightfold> lyxia: I can confirm! https://glot.io/snippets/epc5vk63os
12:17:53 <rightfold> Thanks!
12:19:00 <lyxia> Boomerang: sure, but for intercalate to do anything remotely interesting, the string must contain the separator. This is quite improbable as the size increases.
12:20:00 <erisco> I thought QuickCheck could inspect definitions
12:20:25 <erisco> and thus find the separator case
12:20:44 <ski> er .. no, not at all ?
12:21:04 <erisco> well that's weird... I thought that was exactly what the guy was talking about when I watched some slides on it a long time ago
12:21:13 <c_wraith> the only information "available" to quickcheck is the types of the arguments to the test you provided it
12:21:19 <erisco> that they could infer good cases based on the definition
12:21:34 <erisco> phft, well that is weak sauce
12:21:49 <c_wraith> are you maybe thinking of quickspec? 
12:21:56 <erisco> could be
12:22:37 <Tuplanolla> @check \ x -> abs (x :: Double) >= 0
12:22:39 <lambdabot>  +++ OK, passed 100 tests.
12:22:48 <Tuplanolla> @check \ x -> abs (x :: Int) >= 0
12:22:50 <lambdabot>  +++ OK, passed 100 tests.
12:22:56 <Tuplanolla> Neither is true.
12:23:27 <mniip> what?
12:23:34 <erisco> why I rue test cases
12:23:45 <c_wraith> @check \ xs -> xs == reverse xs
12:23:47 <lambdabot>  +++ OK, passed 100 tests.
12:23:52 <Tuplanolla> Is there a way to tell QC to prioritize pathological cases?
12:24:03 <mniip> well, that's defaulting to ()
12:24:17 <sproingie> ship the code, users will find the pathological case right away ;)
12:24:19 <c_wraith> make your Arbitrary instance produce pathological cases first. 
12:24:32 <erisco> yeah but the last place you want gotchas is in your tests
12:24:45 <kadoban> Tuplanolla: Perhaps smallcheck is worth looking at, by the way.
12:24:58 <c_wraith> that's why you put as much in your tests as possible. 
12:25:05 <c_wraith> err. in your types as possible. 
12:25:06 <Tuplanolla> Why aren't `minBound`, `maxBound` and `nan` already in the instance for `Double`?
12:25:07 <thoughtpolice> My favorite QuickCheck failure was when its distribution was skewed very badly due to the RNG. Slide 3 is great: https://wiki.haskell.org/wikiupload/7/74/Hiw2012-michal-palka.pdf
12:25:14 <erisco> > abs (minBound :: Int)
12:25:16 <lambdabot>  -9223372036854775808
12:25:20 <EvanR> Tuplanolla: Double doesnt have minBound or maxBound
12:25:23 <c_wraith> the proves types. 
12:25:26 <EvanR> is one reason
12:25:33 <Tuplanolla> Well, the equivalents, EvanR.
12:25:51 <erisco> does +Infinity and -Infinity work? Double is already screwed up
12:25:58 <kadoban> Hmm, why doesn't Double have minBound/maxBound. Because of NaN and Infinity or something?
12:26:07 <EvanR> whats funny is i tried coming up with tests Double actually could pass, and couldnt. they fail just because Double, ime
12:26:09 <Tuplanolla> Same question for `Int` though.
12:26:58 <EvanR> erisco: Double is supposed to approximate real numbers, which are unbounded. another issue is not all values are less than Inf or greater than -Inf
12:27:12 <erisco> anyone know when Not-A-Number was first included as a number on CPUs? and who is responsible?
12:27:23 <sproingie> IEEE
12:27:37 <kadoban> erisco: Int is supposed to approximate the integers, isn't it? It's still Bounded.
12:27:47 <kadoban> EvanR: ^
12:27:47 <geekosaur> it some sense it is not "a" number; it's a set of bit patterns which usually record something about the origin of the NaN
12:27:54 <EvanR> Int is certainly supposed to be exactly Z mod something
12:28:04 <geekosaur> and yes, it's IEEE 754 standard
12:28:11 <kadoban> I thought that was just an implementation detail
12:28:20 <EvanR> it wraps around
12:28:28 <EvanR> not maxes out or errors on overflow
12:28:37 <erisco> it is clearly Maybe Z for some modulo
12:28:47 <sproingie> pre-IEEE 754, every CPU did it differently.  some might have done NaN before, IEEE754 standardized it
12:29:18 <erisco> why didn't they settle on interrupts?
12:29:29 <sproingie> the behavior of NaN /= NaN is probably IEEE's fault
12:29:42 <erisco> who was advocating using NaNs as a regular value?
12:30:30 <erisco> I read someone else's memory and I get interrupted
12:30:35 <sproingie> who knows.  NaN behavior was pretty hotly disputed back then too
12:30:43 <erisco> I divide by zero and we just pretend that's a thing
12:30:59 <EvanR> not all CPUs have division, so that solves that
12:35:48 <monochrom> They settled on "support both NaN and interrupt, let the user decide"
12:36:05 <erisco> there is a flag I can set? hm
12:36:25 <sproingie> most FPUs then were external units with slow communication to the CPU
12:36:39 <Tuplanolla> Too bad nobody knows about `feenableexcept`.
12:36:56 <mniip> I think I saw that on C jeopardy once
12:36:59 <sproingie> so performance could have been a real barrier to adoption
12:37:26 <erisco> okay, but why do you need the interrupt to be fast?
12:37:50 <sproingie> real time code?
12:38:23 <sproingie> i dunno, standards are a sausage-making process
12:38:25 <erisco> I am assuming we're not programming to recover from this interrupt, it is just an abort
12:38:32 <monochrom> I don't think it's really the performance angle.
12:38:52 <monochrom> Instead I think it's more the lost of knowledge and rise of myth angle.
12:39:50 <erisco> maybe there are some vital uses where you need a Maybe-style failure and you check for it at the end
12:39:53 <monochrom> C became popular, and preserving the reputation "C is oh so portable" also became popular, so people lost the knowledge that you could actually choose exception and the platform-specific API for that.
12:40:20 <erisco> and having a more elaborate structure (like Maybe) for this is just not acceptable
12:40:29 <monochrom> (Not to mention that C sucks on exceptions. Unix too.)
12:40:40 <erisco> but I dunno, that seems small
12:40:55 <Tuplanolla> The reasoning I've heard, in hpc, is that you don't want to slow the normal code path with exception handling, erisco.
12:41:28 <sproingie> neither C nor fortran had a standard ability to communicate the exception to the user.  and those being _different_ standards bodies...
12:41:30 <erisco> well maybe it is an exception
12:41:44 <monochrom> heh
12:41:55 <erisco> that is a higher-level thing, and I am not even convinced you'd care to handle this exception
12:42:28 <erisco> in what case is it so important to recover from the interrupt versus prevent it?
12:42:53 <sproingie> because abort() makes for a distinctly inflexible way of handling errors
12:42:59 <monochrom> It is tricky to prevent.
12:43:27 <monochrom> Err, nevermind, I had overflow rather than NaN in mind.
12:43:44 <sproingie> same deal tho
12:44:14 <erisco> no because you just evaluate the operand first and check if it is within defined bounds, if you must
12:44:17 <monochrom> But I do think that the scientists prefer NaN's to propagate and show up in final answers.
12:44:35 <sproingie> yah that's probably closer to the real answer
12:45:03 <c_wraith> if that's all they did, it be fine. but when they don't show up in final results, and just break conditionals instead... 
12:45:07 <monochrom> To be fair, there is no good answer to the alternative question "OK if you run into sqrt(-1) what do you want to do?"
12:45:15 <erisco> I think the perceived convenience, particularly at the time, is a stronger case
12:45:18 <sproingie> also accounts for the NaN != NaN behavior
12:46:05 <monochrom> The superiority of our Maybe is predicated on actually having a plan B for the Nothing case. If you have no such plan then it doesn't matter all that much.
12:46:40 <erisco> that's why I say you'd probably not handle such an exception or interrupt anyways, you'd just let your program abort and file a bug report
12:47:15 <erisco> but I also have tried to make this point about Maybe in Haskell before and I failed to be convincing
12:47:48 <erisco> because somehow totality is seen as more important than actually having anything defined on the Nothing case
12:47:48 <monochrom> So take for example you have "fmap sqrt array_of_inputs" or the Fortran equivalent. It looks fairly reasonable to specify "it's OK if the output is [1,414, NaN, 4, 5]
12:48:16 <monochrom> I mean, not for all use cases, but certainly for some use cases.
12:49:08 <sproingie> i get it all the time when i'm graphing with rrd
12:49:14 <monochrom> In Haskell it is good to want the output to be [Just 1.414, Nothing, Just 4, Just 5]. But a floating-point unit doesn't have Maybe.
12:49:20 <sproingie> it just results in no plot for that period
12:50:19 <monochrom> And yeah if you say "throw an exception, the exception handler will do the Nothing part", that may be too much overhead.
12:50:29 <Tuplanolla> The solution is maybe hardware.
12:51:54 <EvanR> then youd need full ADT hardware
12:52:06 <Tuplanolla> Sounds good to me.
12:52:11 <EvanR> Maybe (Maybe Double)
12:52:17 * ski . o O ( <https://mumble.net/~campbell/proposals/restart.text>,<http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Restarts.html>,<http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html> )
12:52:28 <thang1> Maybe (Maybeline)
12:52:42 <erisco> talk to conal about that, actually :P
12:52:48 <sproingie> huh, MIT scheme had restarts?
12:53:21 <ski> (has)
12:54:25 <sproingie> i always think of it as that primitive dialect you need for SICP
12:54:38 * ski . o O ( <https://en.wikipedia.org/wiki/PCLSRing> )
12:55:16 <sproingie> racket's #lang sicp didn't survive the transition to immutable conses very well
12:55:57 <sproingie> in that it works up to a point, then lots of mysterious errors about mcons
12:57:56 <erisco> does anyone else have the inseparable association of scones and cons?
12:58:36 <sproingie> i used to build some C projects with scons
12:58:42 <osfameron> perhaps it depends on how you pronounce "scone"
12:59:51 <monochrom> Or how you pronounce cons :)
13:00:16 <monochrom> data List a = Rod | Cones a (List a)
13:02:18 <Tuplanolla> This reminds me of a great idea I had that should be standardized: `data Graph i a = Graph (Spine i) (Noodle a)`.
13:02:51 <monochrom> Yikes, what is Spine, what is Noodle?
13:03:04 <monochrom> Also, why what Spaghetti and Noodle for the kick of it? :)
13:03:17 <monochrom> (Just kidding!)
13:03:24 <Tuplanolla> The spine is the structure of the graph without the elements and the noodle is the elements without structure.
13:03:50 <monochrom> Hrm interesting.
13:04:50 <EvanR> what in the world, noodle?
13:05:07 <erisco> I don't know if I can be taken seriously talking about graph noodles
13:05:22 <sproingie> Scrap Your Sauce
13:05:44 <monochrom> Oh! Graph (Waffle i) (Spaghetti a). Now that's perfect. :)
13:06:47 <sproingie> waffles and spaghetti?
13:07:05 <monochrom> waffle has structure, spaghetti has content :)
13:07:26 <erisco> and maple syrup goes with either
13:07:31 <sproingie> monads are just like ravioli...
13:09:58 <monochrom> or Graph (Waffle i) (Syrup a) would also pun greatly.
13:10:37 <monochrom> "A novel graph representation for high performance, high carb, high fructose, and high gluten"
13:11:18 <EvanR> higher order fructose corn syrup
13:12:41 <sproingie> i remember when i was first learning OO, i had no idea about class design.  so i had singleton classes in production code named "Banana" and "Kumquat"
13:13:16 <erisco> certainly more inventive than MyClass
13:13:40 <monochrom> What did your Banana class represent?
13:13:45 <sproingie> i sort of miss those days, at least i actually got code written
13:14:05 <sproingie> hard to recall exactly, i think one was a CGI request handler and the other was database routines
13:14:14 <erisco> now you just need to decide how Kumquats interact with the world, and what constitutes a Kumquat
13:14:16 <MonadHendrix> lol Banana
13:14:25 <erisco> what things a Kumquat holds secretly and what it shares
13:15:03 <MonadHendrix> type-level cooking
13:15:11 <monochrom> It's a singleton, so it's really just one Kumquat.
13:15:19 <sproingie> was written in Delphi, i eventually ported it to a web UI instead (newfangled concept at the time) and used perl
13:15:32 <monochrom> w00t Delphi
13:16:18 <erisco> sproingie, are you saying nowadays you can't write code?
13:16:38 <sproingie> feels like it.  analysis paralysis has a big hold on me.
13:17:08 <monochrom> Yeah, 99% of my time is spent on "what is a good name for this?"
13:17:14 <sproingie> when you only know one stupid way to do something, you waste no time in getting on it
13:17:20 <erisco> at first it was great to just make anything that worked
13:17:38 <erisco> now it is about avoiding all the things which don't work well
13:17:43 <sproingie> back when doing anything that worked was rewarding in itself
13:17:49 <EvanR> "if its a dumb way that works, then its not dumb"
13:17:58 <monochrom> I think a renamer tool will help mitigate it greatly. Just call it "john" for now. Rename later.
13:18:01 <sproingie> i remember when people were impressed by me being able to make a computer do anything at all
13:19:06 <erisco> at least the diamonds are out there if you sift long enough
13:20:07 <fragamus> https://gist.github.com/fragamus/3cc5ab02a9ea89c42111ed7069d7e53b
13:20:47 <sproingie> part of it's just from getting old.  kids still get plenty of wonder from making stuff in minecraft
13:21:23 <erisco> consider me a kid then... have you played the mods?
13:21:25 <EvanR> working software? so old.. so passe
13:21:34 <andromeda-galaxy> Is there a way to ask the GHC RTS to "adopt" a foreign pointer? In particular I would like to write some C which outputs the native layout of haskell data and then hands off that data to haskell
13:21:48 <andromeda-galaxy> (e.g. a json parser that correctly creates the haskell layout but is accelerated by being written in C)
13:22:15 <sproingie> played a few mods, but i just couldn't get into the experience.  programmable MUDs were the thing for me for a while
13:23:14 <andromeda-galaxy> (in particular is there maybe some way to (ab)use the compact regions functionality for this?)
13:23:42 <merijn> It's a miracle how my code always manages to fail on Travis while working perfectly fine locally...
13:24:27 <sproingie> where "local" is your dev box that's accrued eleventy hojillion little diffs?
13:24:59 <sproingie> i guess that's some of the motivation for nix, run your code atop a virgin platform + only what you give it
13:24:59 <merijn> sproingie: I dunno, I didn't setup the Travis, I'm just trying to get some fairly simple patches merged and my pull request keeps failing on Travis
13:25:23 <merijn> sproingie: That doesn't solve the issue of "works fine with GHC8, but fails on some obscure old stackage lts"
13:26:32 <erisco> it is difficult to accept the imperfections of the product over the perfection of just the idea
13:26:33 <jle`> is there an Ord class with only max and min?
13:26:37 <jle`> cause that would be nice
13:26:50 <sproingie> Bounded?
13:27:00 <EvanR> jle`: sounds like a lattice?
13:27:26 <jle`> sproingie: i don't think it's bounded
13:27:34 <EvanR> join and meet
13:27:46 <erisco> I'd rather stay in toy land for that reason
13:27:51 <EvanR> \/ /\
13:28:10 <jle`> oh interesting
13:28:57 <erisco> but it is hard to get paid for playing with toys
13:29:17 <jle`> Ord is just pesky because you return something that isn't a value of the instance
13:29:52 <EvanR> actually lattices is a thing you put on top of a (partial) order
13:29:57 <Younder> As for perfect code. The minute you start handling input, errors etc code gets messy.You need to know elegant code when you see it and also when to break those rules.
13:30:06 <erisco> jle`, what return?
13:30:20 <jle`> erisco: for <, >, compare, >=, <=, etc.
13:30:35 <erisco> > compare GT LT
13:30:35 <jle`> the value of the result for Ord a is not 'a'
13:30:37 <lambdabot>  GT
13:30:59 <erisco> oh I see what you mean
13:31:08 <jle`> contrast to classes like Num, Fractional, Floating, Monoid, Semigroup
13:31:35 <erisco> in what context is this pesky?
13:31:37 <jle`> where all of the methods for an instance of 'a' return an 'a'
13:31:41 <EvanR> hmm maybe you dont need the underlying order. wikipedia has a "algebraic" lattice
13:31:44 <EvanR> with some laws
13:31:45 <sproingie> Younder: for me it's not even so much about making the code perfectly elegant than it is about just being fun again
13:31:47 <jle`> well, you can't write instances for "deferred" computation kinda things
13:31:52 <jle`> like, (->) r
13:31:53 <jle`> or IO
13:32:08 <sproingie> i liked how other people could immediately play around with stuff i wrote in MUDs
13:32:14 <erisco> Younder, I think it goes further than that though, because I'm willing to accept a lot of ugliness even when implementing good ideas in Haskell or any other language
13:32:20 <jle`> or, in my case, Acc from accelerate
13:32:35 <erisco> you always take on some noise, boilerplate, idioms
13:33:11 <erisco> it is that you're going to be faced with problems where good solutions probably exist but you haven't the time to dedicate to finding them
13:33:15 <erisco> that is when it becomes frustrating for me
13:33:37 <jle`> since if your instance is a deferred computation, then writing an Ord/Eq/Real instance requires you to "force" it
13:33:45 <jle`> which might not be possible for, say, IO
13:33:50 <Tuplanolla> It doesn't help that the ideal solution to almost any problem is really intricate and complicated.
13:33:51 <jle`> or (->) r, or Acc
13:34:01 <erisco> I want to start a solution with generalising and theorising about the whole problem space
13:34:11 <jle`> or well it's possible for Acc but unideal
13:34:15 <jle`> (in my situation)
13:34:40 <erisco> but pragmatically you're forced to specialise and stick in something that just works well enough for now
13:35:30 <EvanR> i made a data type for animations that can split, emit outputs and be sequenced in time http://lpaste.net/355007
13:36:37 <jle`> i could fake 'max' and 'min' with Num
13:36:44 <lpaste> mivael pasted ‚Äúhow to profile 'main' individual %time?‚Äù at http://lpaste.net/7402310821088329728
13:37:14 <fragamus> :t >~>
13:37:15 <lambdabot> error: parse error on input ‚Äò>~>‚Äô
13:37:29 <erisco> so you could say I'd rather be a theoretician than an engineer, and I think many feel similarly
13:37:35 * geekosaur hands fragamus some parentheses
13:37:39 <jle`> EvanR: that's pretty cool
13:37:41 <EvanR> jle`: https://en.wikipedia.org/wiki/Lattice_(order)#Lattices_as_algebraic_structures
13:37:47 <fragamus> :t (>~>)
13:37:49 <lambdabot> error:
13:37:49 <lambdabot>     ‚Ä¢ Variable not in scope: >~>
13:37:49 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
13:38:10 <EvanR> a class for this is probably in one of the algebra packages
13:38:10 <geekosaur> also, hoogle/hayoo (I mostly use the latter)
13:38:47 <geekosaur> possibly http://hackage.haskell.org/package/pipes/docs/Pipes-Core.html#v:-62--126--62- ?
13:39:31 <EvanR> min and max is just one example of this structure
13:39:46 <EvanR> but you could do like Monoid and call the operations min and max ;)
13:39:49 <jle`> lattice makes sense here
13:40:49 <sproingie> standardized unicode aliases would be nice
13:41:11 <erisco> EvanR, can you provide an example so I can know what you intend as an Animation?
13:42:21 <EvanR> imagine a final visible animation as an Animation Picture, defined in terms of several other Animation Pictures running in parallel and fmap mconcatted
13:42:57 <EvanR> each picture could be defined in terms of fmapped rendered Primitives, like a periodic counter for frame, or path through space for offset
13:43:36 <EvanR> at known points in time one animation could Split to spawn a side animation which will be flattened under a Parallel by reduce
13:43:48 <EvanR> and they can disappear with Expire
13:44:39 <EvanR> example, a complex scripted animated picture like the beginning of super mario bros 3
13:44:51 <EvanR> or in my case mario bros 1983
13:45:23 <EvanR> Fire is there to insert sound effects at particular points, basically
13:45:56 <erisco> is the only input Delta? if so then these are movies rather than interactive, yes?
13:46:05 <EvanR> yes
13:46:23 <EvanR> dont try to interact with an animation, you might hurt yourself
13:48:44 <erisco> this is the kind of way I'd prefer to approach problems
13:49:01 <erisco> we need to make an animation? okay, lets talk about a way to express animations
13:49:26 <erisco> other than the human problems I ran into, the other problem I found is maintenance
13:49:59 <erisco> because requirements change so does need the capability of Animation
13:50:52 <erisco> and if you've already spent quite a while thinking about the current definition, making sure everything is defined and makes sense, then this can throw a real wrench in things
13:51:22 <erisco> where now you're trying to incorporate what may seem like a simple new feature into an already sophisticated language
13:51:52 <EvanR> its possible to add new features to this, but only if they make logical sense
13:52:00 <erisco> and this burden comes from having to find the general solution
13:52:48 <erisco> it is absolutely possible, yes, but maybe the cost is high
13:52:53 <jle`> EvanR: i'm sure you already know this, but if your only interaction with animations is through view and elapse, you can also just store the results of view/elapse in a data type, instead of having the different constructors
13:53:40 <EvanR> jle`: view, elapse, next, and reduce. 
13:53:44 <jle`> then your constructors now would abstract constructors
13:53:46 <erisco> for example, I spent a while designing a fairly sophisticated graph query language embedded in C#
13:54:01 <jle`> what is 'next' ?
13:54:04 <EvanR> to display it in real time, before knowing how fast you want to display it?
13:54:15 <erisco> it was designed to cooperate with specifications like Open Graph (or whatever it is called again, can't remember)
13:54:18 <EvanR> i guess you can wrap it all in a Time -> a
13:54:21 <erisco> or JSON-LD or something
13:54:26 <EvanR> but youd have to start over from scratch from each frame
13:54:55 <EvanR> jle`: next time reduce would do anything (the minimum "after" time)
13:55:16 <erisco> so all queries were guaranteed to be semantically valid if they type checked
13:55:17 <jle`> ah
13:55:34 <jle`> what is reduce? successive elapsing?
13:55:36 <erisco> but the problem was that adding some capabilities to this were actually quite difficult
13:55:39 <EvanR> no
13:55:47 <erisco> for example, a requirement comes in that we have to be able to order results by multiple columns
13:55:56 <EvanR> there are reduction rules for things under a Parallel
13:56:11 <erisco> well now I have to redesign this part of the language plus the compiler for it
13:56:17 <EvanR> ..., Split _ x y, ... becomes ..., x, y, ...
13:56:37 <EvanR> recursively (if x or y then satisfied more rules)
13:56:39 <erisco> and now I'm competing for time against the solution of just using strings
13:56:43 <erisco> SQL strings or something
13:57:22 <erisco> this is the frustration
13:57:57 <Tuplanolla> "Your design, erisco? You mean our intellectual property."
13:58:00 <EvanR> the interpretation of an Animation would indeed be (Time -> a, [(Time, Output)]) but i cant practically use that in the final product
13:58:33 <jle`> is reducing just grabbing all of the things that are fired?
13:58:42 <EvanR> thats part of it
13:58:43 <erisco> Tuplanolla, heh, well I suppose that code is forfeit but the idea can't be copyrighted
13:58:58 <Tuplanolla> Yet.
13:58:59 <EvanR> its also flatting trees of Split and culling Expireds
14:00:30 <jle`> ignoring reduce, you could have data Animation a = Animation a (AddInf Delta) (Delta -> Animation a), i believe
14:00:54 <EvanR> are you suggesting church encode for performance?
14:01:12 <mivael_> hello all!  Could anyone give me a hint on ghc profiling?  main's individual %time is 93.5, but how to find out what are those 93.5% consist of?  All components of 'main' (except maybe (.) and ($) functions) are present in the *.prof file and show very little time:  http://lpaste.net/7402310821088329728
14:01:15 <jle`> the first field is the result of applying view, the second field is the result of applying next, and the third is a result of applying elapse
14:01:27 <erisco> one day maybe I'll get it into Haskell but I haven't had a reason to interface with such things myself
14:01:28 <jle`> EvanR: the suggestion was more for simplicity
14:01:42 <EvanR> next wouldnt be much use without being able to reduce, because once you get there elapse wont work anymore until you do
14:01:47 <erisco> it is something that Facebook and Netflix (was it?) started figuring out
14:02:00 <erisco> that, hey, all this data we have can be represented as a graph, and we can query it
14:02:06 <EvanR> at least if i fix the code here
14:02:09 <erisco> so why don't we start designing our web APIs this way
14:02:22 <erisco> and W3 is slapping their foreheads, but whatever
14:02:40 <sproingie> graphql is kind of along those lines
14:02:53 <erisco> yeah that is what I mean, GraphQL, not Open Graph, lol
14:03:15 <sproingie> one size really doesn't fit all
14:03:49 <erisco> well that explains why you have a dozen formats
14:03:51 <sproingie> graphql is great if all your data fits into JSON and your queries are all more or less QBE
14:04:29 <erisco> I don't like a lot of things in GraphQL but buried in it is the simple idea of graphs, and that is all I'm after
14:05:24 <erisco> so you have your domain objects, like Person, Product, Article, and so on, and relationships between them, and there is your graph
14:05:51 <erisco> give me the Persons that look like this and give me the Articles they author (the relationship) that look like that
14:05:55 <EvanR> jle`: in my imagination, i saw an animated version of the expression tree, like Time -> Animation a that periodically committed outputs to a history list. sort of abstract operational semantics
14:06:11 <erisco> this was all I was interested in doing
14:06:17 <EvanR> and viewing the final a in time was kind of an after thought
14:06:30 <EvanR> i mean, the point was to easily construct the animations mostly
14:06:33 <jle`> EvanR: in theory you could always just store the results of each function on each constructor, instead of the constructor, i believe
14:06:39 <jle`> this lets you construct them just as easily
14:06:49 <EvanR> yes church encode
14:07:01 <jle`> instead of 'Pure'/'Parallel' being concrete, they're just abstract constructors now
14:07:01 <Myrl-saki> TIL, GraphQL.
14:07:07 <EvanR> im not sure if my brain could handle implementing the algorithms that way though
14:07:09 <jle`> you could even make them Pattern Synonyms
14:07:26 <jle`> the types would all be the same
14:07:35 <EvanR> huh
14:07:38 <jle`> before, you had Pure :: a -> Animation a
14:08:08 <jle`> in the abstract version, you'd have pure x = Animation x Inf (\_ -> pure x)
14:08:11 <jle`> same type :)
14:08:18 <EvanR> the implementing doesnt seem simpler
14:08:47 <EvanR> its like the make separate objects for each case of a switch, or just write a switch
14:08:51 <jle`> it's just sort moving the burden of implementation from the implementation of elapse/reduce/next to the construction of your patterns
14:09:06 <erisco> when designing the language it is about how you model these objects, the relationships, the constraints, and the ways they fit together
14:09:23 <erisco> and I found a nice inductive way to do it
14:09:44 <EvanR> jle`: yes any GADT can be destroyed this way and you get a performance boost, as i understand it
14:09:54 <erisco> where you start with an empty query and work towards a root object
14:10:29 <erisco> and iirc it is a category with initial and terminal objects but I'm not so versed in CT so that's about all I can say
14:10:40 <jle`> EvanR: it's sort of like State s a = State (s -> (a, s)) vs. State s a where Get :: State s s; Put :: s -> State s (); Pure :: a -> State s a; Bind :: ..., etc.
14:11:19 <EvanR> i can sort of see how the source code would look after doing that, and you think its better?
14:11:33 <EvanR> there would be no cases
14:11:36 <jle`> i think the data type itself is simpler
14:11:46 * EvanR boggles
14:12:01 <jle`> although i suppose that's a matter of taste too
14:12:19 <EvanR> how much simpler than a GADT AST could you get
14:12:24 <jle`> the advantage of making a big GADT like you have there, to me, is that you can deconstruct it and inspect it
14:12:35 <EvanR> i think what youre saying is its more theoretically pure, youre defining the type in terms of its universal properties
14:12:38 <BytesAndCoffee> what's the best YCM-like vim plugin for haskell dev?
14:12:51 <jle`> EvanR: what i wrote, data Animation a = Animation a (AddInf Delta) (a -> Animation a)
14:13:00 <jle`> * Delta -> Animation a
14:13:03 <EvanR> thats not really enough but yeah
14:13:13 <BytesAndCoffee> i love jedi/YCM for Python, and im wanting to get into Haskell
14:13:23 <erisco> I think denormalising is also a perf trick in Haskell, right, so there may be that
14:13:32 <sproingie> Animation a -> (a -> Animation b) -> Animation b
14:13:33 <sproingie> hmmmmm
14:13:59 <jle`> if you really wanted performance, there's another step you can do, as well
14:13:59 <EvanR> yep not sure if its the most theoreticaly, or even necessary
14:14:15 <EvanR> theoretical
14:14:32 <EvanR> sproingie: that canna be done keptin
14:14:55 <erisco> I spent a long time adding function predicates to Data.Set
14:15:22 <erisco> I have a way to do it with just one form, but I can also denormalise to something like 3 forms
14:15:27 <BytesAndCoffee> anyone?
14:15:40 <erisco> I haven't published it yet because I haven't run the benchmarks to see what the difference is
14:16:24 <sproingie>  ghc-mod seems popular for vimsters.  intero also has a vim frontend.
14:16:38 <erisco> also there is variation where you just add complement Data.Set
14:16:46 <erisco> and I haven't worked out how to best organise these options
14:16:55 <EvanR> jle`: also called tagless final, i think
14:16:55 <erisco> other than just completely separate modules
14:17:32 <EvanR> complement of Data.Set
14:17:35 <EvanR> crazy talk
14:18:03 <erisco> I'm insane then :P
14:19:42 <erisco> odds = complement (isEven `intersection` integers)  I made that possible
14:20:48 <erisco> well, I think I did it like  withCharacter isEven  to form the set, rather than an overloaded (type classed) intersection function, but whatever
14:22:02 <erisco> and there is a naive way to implement this but I spent time working out how to optimise on-the-fly
14:23:05 <erisco> so determining if a number is in odds is actually just as efficient as Set.member in this case
14:23:27 <EvanR> its even more efficient
14:23:40 <EvanR> (==0) . (`mod` 2) ;)
14:23:43 <EvanR> er
14:23:48 <EvanR> (==1) . (`mod` 2)
14:24:18 <erisco> well, could be, but it doesn't know any number theory... it just knows about sets
14:24:45 <erisco> so integers is a set of things and withCharacter isEven is a set of things and so on
14:25:48 <erisco> the challenge was finding the form that remains closed
14:26:10 <erisco> or one such form, as obviously there are equivalents
14:27:19 <erisco> then the benchmarking is determining whether just using the general form is better or if it is worth having the specialisations of it that I do
14:28:06 <erisco> since I didn't go with the naive implementation to begin with, this whole exercise has to be about performance, and that is why it matters
14:29:03 <EvanR> high performance at any cost, high cost at any performance
14:31:49 <erisco> and if I wanted to be scientific I'd also have to implement and bench the naive one...
14:32:10 <erisco> which is why after finally working it all out and facing this remaining boring work I said "meh"
14:39:34 <zereraz> hi could someone tell me why the code does not wait 5 seconds and then stop http://lpaste.net/355011
14:40:02 <zereraz> also is that a good way to run a timer with IO ?
14:41:01 <EvanR> because the program ends immediately
14:41:09 <erisco> going to guess it is because you don't wait for the thread to complete
14:41:20 <EvanR> your main action is over with before the other thread even gets started sleeping
14:41:37 <EvanR> when the main thread ends, the whole program ends
14:42:07 <EvanR> if you use the async library, you can spawn a thread and wait for it to finish (or crash) before continuing
14:42:27 <sproingie> thing is, the threads actually seem to run on top of each other
14:42:31 <sproingie> that's the result i get
14:42:42 <EvanR> that also happens
14:42:47 <EvanR> since they both print
14:43:22 <EvanR> unrelated to how long the program runs for
14:43:23 <erisco> so what we want to do is step back and think about a general expression of concurrent computations
14:43:35 <EvanR> pi calculus anyone
14:43:37 <EvanR> anyone
14:43:54 <erisco> yes, actually, but don't expect me to recite it
14:44:02 <sproingie> oh i see where the two are overwriting
14:44:02 <thang1> Hmm...
14:44:04 <thang1> https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126903.html
14:44:14 <thang1> What does "Strong knowledge of haskell programming language fundamentals" mean here?
14:44:16 <sproingie> didn't see the putStrLn at the end
14:44:22 <lyxia> zereraz: the main thread does not wait for its children to terminate
14:44:33 <EvanR> sproingie: its really funny to me that the threads are interleaved so fast
14:44:39 <EvanR> but there you have it
14:45:23 <EvanR> at least the output is serialized somehow, and not "half 'W' half '3' in position 0"
14:45:26 <erisco> thang1, well we obviously cannot know what the author intended, so are you just asking what we consider as fundamental knowledge?
14:45:46 <sproingie> EvanR: it makes me wonder how efficient putStrLn is, honestly
14:46:02 <EvanR> @src putStrLn
14:46:02 <lambdabot> putStrLn s = do putStr s; putChar '\n'
14:46:08 <EvanR> @src putStr
14:46:08 <lambdabot> putStr s = hPutStr stdout s
14:46:12 <thang1> erisco: yeah, sorry. Should've worded that a little better.
14:46:40 <thang1> Chris isn't on the irc (I don't think) so I can't just ask directly. However, I'm just curious what sort of level "fundamental knowledge" is considerd at.
14:46:56 <EvanR> sproingie: for each Char, it evaluates to WHNF (NF) so it can get the next char to output, then it encodes into UTF-8 (or something), then does the actual write in the IO manager
14:47:13 <sproingie> so yeah, nothing like "shove this whole line into stdio buf"
14:47:15 <EvanR> String is really not fabulous
14:47:30 <sproingie> but hey, i'll take the nice thread scheduler any day
14:48:40 <erisco> thang1, then the other implicit I get is that maybe you are not sure if you're strong enough with Haskell
14:49:24 <sproingie> thang1: i'd say at minimum you grok all the stuff in LYAH
14:49:33 <erisco> thang1, have you read through a Haskell book or completed several Haskell exercises?
14:49:37 <sproingie> the rest depends on how quick you learn
14:49:44 <sproingie> this being the sort of thing interviews are for
14:50:02 <sproingie> (ostensibly)
14:50:41 <erisco> if I asked you to, for example, write a function which found the mode of a list, could you do that?
14:51:39 * sproingie would have to google 'mode' to remember which that was
14:51:48 <erisco> "most occurring"
14:53:11 <erisco> you need to be able to write basic algorithms such as that at a minimum
14:53:47 <erisco> then because it is particular to Haskell and not just FP generally I'd expect them to want to familiar with type classes and particularly Functor, Applicative, Monad
14:55:17 <erisco> and then flesh this out with familiarity with the common data structures
14:55:48 <erisco> so unit, Maybe, Either, [], Set, Map
14:56:56 <erisco> then you've got enough to sit down and write lots of programs
14:57:17 <erisco> and in many years you might write them really well too. I'm still working on it :P
14:57:58 <erisco> oh, also tuples, can't forget those
14:58:06 <EvanR> or write few programs badly that make you tons of money
14:58:11 <EvanR> one of the two
15:00:17 <thang1> I'm currently on chapter 11 (almost 12) of the first principles book. I plan to be done with the book around the beginning of June
15:01:14 <erisco> this sounds like a bernalex project
15:01:22 <thang1> I am questioning whether or not I'm strong enough in Haskell, but I'm also wondering what more advanced people consider, reflexively, "fundamentals" when there are job postings or blog articles that start with (eg) "so let's assume a good grasp of the fundamentals"
15:01:59 <Zemyla> 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
15:02:01 <erisco> "You will be the team's expert on computer programming
15:02:01 <erisco> and the Haskell programming language."
15:02:08 <sproingie> that's a lotta nothing
15:02:27 <erisco> or a lot of something on certain architectures
15:02:40 <thang1> Exactly why I was wondering :p
15:02:54 <hexagoxel> Zemyla: your message got cut off near "0000"   :D
15:02:58 <erisco> well it is weird of them to say that and then go into "fundamentals"
15:02:59 <thang1> I've seen "you're the team expert" be anything from "script kiddy" to "a PhD is a nice start"
15:03:48 <mniip> thang1, no one is strong enough in haskell :D
15:04:09 <erisco> well here is what I gather from their project, in a quick glance
15:04:34 <erisco> they have some mathy ideas that they want to translate into Haskell for purposes of teaching
15:04:37 <sproingie> i'd say quick learning and effective knowledge transfer ability would be critical
15:04:50 <mniip> oh
15:04:56 <mniip> there is a specific context
15:04:58 * mniip shuts
15:05:05 <erisco> now this is ages 11-14, so I don't expect it to include complicated numerical methods and matrix transformations and so on
15:05:12 <thang1> sproingie: that's my strong point. Math, theory, and explaining technal things to people
15:05:46 <sproingie> math and cs background are gravy
15:05:48 <mniip> IMO curry-howard is the best thing since sliced bread
15:05:51 <thang1> My entire family is filled with teachers and my mom has a masters in special ed && English teaching. So, I've been exposed to all of that my entire life.
15:05:57 <mniip> and is the most fundamental piece of logic ever
15:05:58 <mniip> but
15:06:03 <mniip> it's so impossibly hard to explain
15:06:06 <erisco> so if you can take problems appropriate to ages 11-14 (and don't underestimate how smart these kids can be) and implement them in Haskell then I think you're good to go
15:06:15 <erisco> so, that would be very much a problem like "find the mode of a list"
15:06:22 <thang1> Right, sounds good to me.
15:06:28 <sproingie> mniip: and thus eludes the rest whom it hasn't been explained to
15:06:40 <erisco> though if these kids have never programmed before it would be even more basic problems, I imagine
15:06:53 <erisco> the intro to FP I took in uni was incredibly basic
15:06:59 <mniip> sproingie, I see people struggling with writing proofs all around me
15:07:02 <sproingie> i get the idea of CH, i just don't know the deeper implications
15:07:04 <erisco> where advanced functions were things like groupBy
15:07:05 <mniip> I'm like,
15:07:10 <mniip> man this is modus ponens
15:07:45 <thang1> mniip: my formal logic class last quarter was fucking brutal for that reason
15:07:57 <mniip> like
15:08:02 <thang1> I saw the teacher just spend like 20 minutes with one guy during class once just trying to get him to understand why he couldn't do something
15:08:13 <mniip> 90% of the people can't reproduce the 'lim of sum = sum of lim' proof
15:08:15 <thang1> and it was... /super/ basic stuff we went over week 1 of class (this was two weeks before finals)
15:08:36 <mniip> and with CH it's trivial,
15:08:42 <erisco> I never heard of it, so I'm in the 90% :P
15:08:44 <mniip> you abstract over eps, and apply givens to eps/2
15:09:00 <monochrom> lim of anything is actually very hard. Because you're looking at forall-exist-forall. Three levels of alternating quantifiers. Already hard for computers, so nevermind humans.
15:09:21 <sproingie> yep, ya lost me
15:09:24 <erisco> yeah, if Siri can't do it then may as well not even bother
15:09:48 <monochrom> But yeah if modus ponens poses an obstacle too, then we do have too much lead in our water.
15:10:05 <sproingie> i'd say there's clearer evidence than that
15:10:10 <mniip> erisco, forall sequences a_n, b_n, (lim a_n = A /\ lim b_n = B) => lim (a_n + b_n) = A + B
15:10:11 <monochrom> haha
15:10:45 <monochrom> And the pumping lemmas are yet one level more.
15:10:48 <erisco> mniip, I intuited as much, but then I don't know the theory of limits and sums
15:11:18 <mniip> monochrom, oh god
15:11:23 <thang1> Well I'll put it this way, to study for my midterm in formal logic I skipped every single homework assignment, then blindly wrote down proof solutions from the back of the book to see how things fit together. After about 4-5 proofs I understood everything, after 7 I was writing them without checking any solution, and after about 10 I was doing them instantly in my head
15:11:23 <erisco> I know they gave lots of problems in school and I tried to memorise them but after the exams I jettisoned it all
15:11:26 <mniip> pumping lemma
15:11:42 <thang1> pumping lemma is great. We're doing that in class right now (well, just finished it)
15:11:49 <mniip> I think our lecturer just gave up and said "imagine you're playing a game"
15:12:06 <erisco> mniip, or does lim even stand for limit? that is something else isn't it
15:12:10 <erisco> see, I haven't a clue
15:12:10 <EvanR> "the only way to win is not to play"
15:12:17 <monochrom> YES! I feel that the game semantics is best for explaining alternating quantifiers.
15:12:19 <thang1> erisco: lim == limit but less typing
15:12:36 <mniip> monochrom, I guess,
15:12:46 <mniip> but mentally I'm like... this is trivial
15:12:58 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html
15:13:00 <mniip> about as trivial as \f g x -> f x (g x)
15:13:04 <erisco> what is a limit of a series, even?
15:13:15 <thang1> Now we're on Myhill-Nerode theorem :p
15:13:21 <erisco> sequence, I mean
15:13:51 <erisco> mniip, S! I know one
15:14:07 <mniip> erisco, definition: given a sequence a_n, lim a_n = A  <=>  forall eps > 0. exists N. forall n > N. |a_n - A| < eps
15:14:09 <thang1> A limit of anything is the behavior of it as it approaches your asymptote bound
15:14:18 <niez> erisco, mode of a list: http://lpaste.net/355012 (how ugly is that? :))
15:14:36 <monochrom> haha niez
15:15:06 <mniip> :t head . last . sortOn length . group . sort
15:15:07 <lambdabot> Ord c => [c] -> c
15:15:11 <monochrom> I think you can eliminate reverse by sorting in decreasing order to begin with
15:15:18 <mniip> ha
15:15:24 <mniip> almost the same as mine
15:16:32 <erisco> niez, that shows good competency actually because you are seeking to solve the problem with existing definitions
15:17:02 <erisco> whereas a more beginner approach is to write more things as explicit recursion
15:17:10 <monochrom> Yeah, my comment is not a criticism.
15:17:27 <erisco> well I would have said the same thing monochrom, but you said it first :P
15:17:39 <mniip> ouch
15:18:00 <niez> ah, so it's not so bad, glad to hear that :)
15:18:14 <thang1> > head . maximumBy (comparing length) .group .sort $ [1,2,3,4,2,2,2,1,2]
15:18:16 <lambdabot>  2
15:18:35 <thang1> (shamlessly stolen from stackexchange)
15:21:56 <erisco> I was thinking of a different solution that counted elements
15:22:13 <erisco> well, yours of course does that by finding the group length, but I wasn't going to sort
15:22:53 <erisco> always nice to see alternatives
15:23:49 <sproingie> i was trying to think of a one-liner way to do it in one pass too
15:24:27 <mniip> :t foldr (M.insertWith (+) 1) M.empty
15:24:29 <lambdabot> (Num k, Num a, Ord k, Foldable t) => t a -> M.Map k a
15:25:15 <erisco> even more concise, nice
15:25:26 <erisco> I was starting with  unionsWith (+) . fmap (flip Map.singleton 1)
15:25:28 <mniip> it's not complete
15:25:39 <mniip> you need to find the key of the max element in that map
15:25:44 <erisco> I know
15:25:47 <mniip> it is faster though I believe
15:25:57 <erisco> I am browsing for what in Data.Map will let me do that :P
15:26:31 <mniip> M.foldrWithKey
15:27:16 <mniip> M.foldrWithKey (\k x (l, y) -> if x > y then (k, x) else (l, y))
15:27:28 <erisco> was hoping for something more direct so I didn't end up with that
15:27:47 <erisco> I'd have to at least figure out a pointfree version and that'd be a pain
15:28:16 <thang1> Isn't foldr is theoretically less ideal due to intrinsic inability to be parallelized (it forces a notion of linear consumption where there doesn't need to be one)? but eh, splitting hairs and Haskell's compiler doesn't do a whole lot of parallel anyway :p
15:28:20 <mniip> maximumBy snd . M.toAscList .
15:28:48 <mniip> thang1, you have a data dependency on the map
15:29:25 <erisco> mniip, but that is ascending by key
15:29:33 <mniip> yes
15:29:37 <mniip> it fuses though
15:29:44 <mniip> with maximumBy
15:30:05 <erisco> and what is different with just M.toList?
15:30:54 <mniip> stupid me
15:30:56 <mniip> :t maximum
15:30:57 <lambdabot> (Ord a, Foldable t) => t a -> a
15:31:02 <mniip> it's foldable!
15:31:14 <mniip> no wait, damn, we need the key
15:31:50 <erisco> yeah that is part of the pain
15:31:59 <erisco> so after the maximumBy we still have to project fst
15:32:45 <thang1> So you don't really gain anything at that point, correct?/
15:32:55 <LordBrain> anyone here working on a jitted language?
15:33:15 <mniip> erisco, hmm
15:33:29 <mniip> (\k x (l, y) -> if x > y then (k, x) else (l, y))
15:33:42 <mniip> (\k x (y, l) -> if x > y then (x, k) else (y, l))
15:33:52 <mniip> (\k x (y, l) -> max (x, k) (y, l))
15:34:21 <erisco> > fst . maximumBy (comparing snd) . Map.toList . unionsWith (+) . fmap (flip Map.singleton 1) $ [3,6,2,4,2,2,9,6]
15:34:23 <lambdabot>  error:
15:34:23 <lambdabot>      Not in scope: ‚ÄòMap.toList‚Äô
15:34:23 <lambdabot>      Perhaps you meant one of these:
15:34:35 <erisco> > fst . maximumBy (comparing snd) . M.toList . unionsWith (+) . fmap (flip M.singleton 1) $ [3,6,2,4,2,2,9,6]
15:34:37 <lambdabot>  error:
15:34:37 <lambdabot>      ‚Ä¢ Variable not in scope:
15:34:37 <lambdabot>          unionsWith
15:34:41 <thang1> lol
15:34:56 <erisco> ugh, well you get it, modulo mniip's variations
15:35:00 <mniip> :t M.foldrWithKey (\k x -> max (x, k)) (0, undefined) . foldr (M.insertWith (+) 1) M.empty
15:35:01 <lambdabot> (Num t, Num t1, Foldable t2, Ord t, Ord t1) => t2 t1 -> (t1, t)
15:35:13 <NextHendrix> @type (.) . (.)
15:35:15 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
15:35:21 <mniip> @let mode = M.foldrWithKey (\k x -> max (x, k)) (0, undefined) . foldr (M.insertWith (+) 1) M.empty
15:35:22 <lambdabot>  Defined.
15:35:22 <NextHendrix> D:
15:35:26 <thang1> @type (.) . (.) -- heh boobies
15:35:28 <lambdabot> (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
15:35:34 <mniip> > mode [1,2,2,2,4,4]
15:35:36 <lambdabot>  error:
15:35:36 <lambdabot>      Ambiguous occurrence ‚Äòmode‚Äô
15:35:36 <lambdabot>      It could refer to either ‚ÄòText.PrettyPrint.HughesPJ.mode‚Äô,
15:35:41 <mniip> > L.mode [1,2,2,2,4,4]
15:35:43 <lambdabot>  (15,1)
15:35:50 <mniip> hmm
15:35:55 <mniip> that's a bit wrong
15:36:02 <erisco> I'm a bit unhappy when I read undefined in the definition
15:36:10 <fragamus> I have a question about pipes and the >~> operator
15:36:12 <fragamus> https://gist.github.com/fragamus/3cc5ab02a9ea89c42111ed7069d7e53b
15:36:30 <mniip> erisco, the overall function is partial
15:36:33 <mniip> mode [] = ?
15:37:09 <erisco> I know, but that doesn't mean we should proceed with abandon
15:37:17 <fragamus> Why is the first yield directed to the function argument and the remaining yields are directed to the await function?
15:37:23 <mniip> @undef
15:37:23 <lambdabot> Undefined.
15:37:30 <mniip> @let mode' = M.foldrWithKey (\k x -> max (x, k)) (0, undefined) . foldr (flip (M.insertWith (+)) 1) M.empty
15:37:31 <lambdabot>  Defined.
15:37:38 <mniip> > mode' [1,2,2,2,4,4]
15:37:40 <lambdabot>  (3,2)
15:37:42 <mniip> yeah
15:38:17 <mniip> > mode' ["hi","moo","hi","hi"] :: (Double, String)
15:38:19 <lambdabot>  (3.0,"hi")
15:38:52 <thang1>  nice
15:40:26 <erisco> I guess we don't get a foldr1 variant from Data.Map
15:40:56 <mniip> foldr1 wouldn't work
15:41:17 <erisco> why is that?
15:42:24 <erisco> > foldr1 max [1..10]
15:42:26 <lambdabot>  10
15:43:01 <mniip> look at the folding function closely
15:43:28 <thang1> http://stackoverflow.com/questions/13782185/haskell-foldr-vs-foldr1
15:44:12 <erisco> mniip, I am not sure what you mean
15:45:45 <erisco> I expect  foldr1WithKey :: ((k, a) -> (k, a) -> (k, a)) -> Map k a -> a  modulo some currying
15:46:12 <mniip> ah
15:46:16 <mniip> well, we don't need the a
15:46:23 <mniip> we need the k
15:46:42 <erisco> the return type should have been  (k, a)
15:47:31 <erisco> the other way to get this is simple
15:47:38 <erisco> :t foldr1 max . M.toList
15:47:40 <lambdabot> (Ord a, Ord k) => M.Map k a -> (k, a)
15:47:55 <thang1> oooh 
15:50:34 <erisco> though we have to swap the tuples, like you did mniip
15:51:18 <Zemyla> Is there a monad that's both a MonadFix and a MonadCont?
15:52:55 <erisco> :t swap
15:52:57 <lambdabot> (a, b) -> (b, a)
15:53:48 <monochrom> Zemyla: I think not. I also think someone proved that it can't be done.
15:55:47 <erisco> we can do that with  (swap ~> swap ~> swap) max  with ~> from TypeCompose
16:00:47 <erisco> also, just as a style note, it is sensible to define a function counts :: (Ord a, Num b) => [a] -> Map a b
16:01:57 <Zemyla> monochrom: Would this not be a conforming instance? instance MonadIO m => MonadFix (ContT r m) where mfix f = ContT $ \c -> do { (mv, a) <- liftIO $ do { mv <- newEmptyMVar; a <- unsafeInterleaveIO $ readMVar mv; return (mv, a) }; runContT (f a) (\b -> liftIO (tryPutMVar mv b) >> c b)
16:02:02 <erisco> or possibly eliminate the Map, but I am hesitant to make early reductions
16:02:20 <robkennedy> How close is the odd function to `odd n = 0 == countTrailingZeros n`?
16:02:54 <thang1> ‡≤†_‡≤†
16:03:02 <erisco> I don't understand what you wrote there robkennedy
16:03:47 <erisco> oh, I get it now, okay
16:03:49 <thang1> "How closely does the odd function's behavior mirror that of a theoretical function "foo n = 0 == countTrailingzeroes n"
16:04:11 <thang1> https://codereview.stackexchange.com/a/161606 look at this mess 
16:04:28 <erisco> well it isn't that at all because look at the type
16:04:39 <erisco> it isn't defined on bit fields, it is defined on all Integrals
16:04:50 <robkennedy> Yeah, Integral and Bits have nothing in common
16:05:31 <erisco> if it were a bit field then we just need to check the smallest bit, yes? why count any more than that?
16:06:02 <robkennedy> Oh yeah I guess testBit 0 is better than what I wrote >.>
16:06:48 <erisco> now I think with GHC you can define special implementations for particular types
16:07:09 <erisco> but I haven't experience with the GHC performance kung fu
16:07:30 <c_wraith> yeah, rewrite rules can be triggered by types. 
16:07:49 <sproingie> i imagine "n & 1 == 0" is as fast as it gets on most architectures
16:07:56 <robkennedy> But the thrust of my question is: how much low level engineering lies behind our core functions? For instance, I've determined that Sets of ADTs with less than 64 constructors don't seem to be represented as sets. 
16:08:12 <robkennedy> *represented as Words
16:08:22 <sproingie> whether ghc gets it to that, dunno
16:08:40 <thang1> oooh you're asking about some pretty black magic tbh
16:08:49 <thang1> maybe check the ghc developer mailing list and the ghc trac?
16:08:52 <erisco> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Real.html#odd
16:09:06 <Zemyla> robkennedy: I think actually you could write a function bToInteger :: Bits a => a -> Integer, just by repeatedly testing and consuming the lowest bit.
16:09:31 <erisco> I don't see any magic in there, but it could be added I'd think
16:11:19 <robkennedy> erisco: I didn't find anything for `x rem 2` in there. 
16:11:36 <erisco> well it doesn't matter beyond that I don't think
16:11:40 <robkennedy> Okay, cool, I like doing this sort of thing, I'll see if something's on the trac
16:11:55 <erisco> there'd have to be a rule specifically for \x -> x rem 2 to do anything special here
16:12:59 <erisco> and there could be but I am not sure
16:14:36 <sproingie> could be done as an optimization pass much lower (like in gcc or llvm)
16:14:41 <erisco> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Real.html search for "Integral Int"
16:14:55 <erisco> then you'll see, as well as on other instances, there is no special case for 2
16:15:20 <erisco> well, we get to here http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#remInt
16:15:47 <erisco> which gets us to remInt# and beyond that I don't know
16:15:54 <erisco> so maybe there is an internal optimisation for it
16:16:10 <erisco> (in fact that is highly likely)
16:19:40 <erisco> so I am guessing you'd see in the assembly a mask for the low bit and a compare to zero
16:20:39 <erisco> or whatever clever instruction does all that and makes you breakfast at once
16:20:46 <polll> Hi. Does anyone know how to send a command to an Intero REPL in Emacs?
16:21:10 * erisco was wondering what a mmand was for a moment
16:21:58 <thang1> hah
16:22:19 <sproingie> far as i know you can send the whole buffer to intero, not any specific part of it
16:23:31 <sproingie> just to interact with it, ctrl-c ctrl-z
16:29:35 <polll> Hmm, I'm surprised that feature doesn't exist. Time to dig into the elisp I guess. Thanks anyways.
16:29:39 <sproingie> as a worker, i turn problems into solutions.  i have coworkers.
16:29:53 <thang1> lol
16:30:04 <thang1> coworkers turn solutions into problems, right?
16:30:11 <robkennedy> Ericso: Thanks for hunting that all the way to remInt 
16:30:19 <Koterpillar> is solution a coproblem?
16:30:28 <EvanR> :t remInt
16:30:30 <lambdabot> error:
16:30:30 <lambdabot>     ‚Ä¢ Variable not in scope: remInt
16:30:30 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
16:32:07 <sproingie> solutions would be the codomain of problems, yes
16:34:05 <sproingie> https://yow.eventer.com/yow-2014-1222/stop-treading-water-learning-to-learn-by-edward-kmett-1750 -- skip to 6:20 for the joke
16:35:43 <hkeylocal> decrypt bcrypt plss ????      $2a$08$Cf1f11ePArKlBJomM0F6a.xzfpEexCPc/xm.u/Tv/pK6K..cagbv.
16:35:44 <hkeylocal> $2a$08$Cf1f11ePArKlBJomM0F6a.YTE/dxTNZTTS/WFqp31Sk68Qm2j15EO
16:36:06 <EvanR> are you a b. o. t.
16:36:31 <sproingie> it reads "your mom was fun"
16:36:41 <thang1> https://github.com/ekmett/structs/blob/9ff2818f888aff4789b7a41077a674a10d15e6ee/src/Data/Struct/Internal.hs
16:36:56 <thang1> goddamn this is some ugly shit. Yet, somehow not ugly. Yet, somehow terrifying
16:38:03 <sproingie> the commit message at top is hilarious in context
16:38:49 <thang1> "remove a bunch of language extensions"
16:38:57 <thang1> *first thing you see is 20  language extensions*
16:39:09 <erisco> I like it when you do a bunch of hairy ugly stuff on the inside but on the outside it looks great
16:39:23 <thang1> Like how in Linux, everything is a file
16:39:26 <hkeylocal> Does anyone know how to decrypt (bcrypt) ?? I pay !!
16:39:28 <sproingie> yeah that goes for more than haskell
16:39:43 <thang1> how the fuck they managed to make a CPU into a file I don't fucking know
16:39:49 <sproingie> hkeylocal: shoo
16:39:56 <thang1> but some genius wrote that horrifying nightmare to let me cat my CPU  :p
16:40:00 <EvanR> no it should be gross and ugly on both sides, but the interface is nice
16:40:37 <sproingie> meh, you want "everything is a file" taken to extremes, try plan9
16:40:40 <dfeuer> Ping edwardk
16:40:41 <EvanR> "everything is a file" seems pretty silly
16:40:57 <erisco> when everyone is a file, no one is a file
16:41:02 <thang1> Which is the point
16:41:24 <thang1> When everything is a file, the pipe becomes a universal way to compose arbritrary programs and functions on the commandline
16:41:34 <EvanR> :|
16:41:41 <EvanR> yes ByteString is so universal
16:41:43 <hkeylocal> Does anyone know how to decrypt (bcrypt) ?? I pay !! plsss
16:41:50 <erisco> it has all the allure of stringly typed programming
16:41:57 <thang1> code is data, data is code, everything is a file, nothing is a file, everything performs on text, text based tools work on everything, etc
16:42:15 <EvanR> that also explains how nice it is to write code in untyped lambda calculus
16:42:16 <kadoban> stringly typed programming, that's a nice one xD
16:42:26 <sproingie> hkeylocal: my rates start at a mere $10/hour.  might take a few hours :)
16:42:48 <sproingie> figure that'll give me a modest side income
16:42:51 <thang1> pffh, hkeylocal, I'll do it for $50/hour
16:42:57 <subtlebot> seems like a low rate
16:43:16 <thang1> subtlebot: it's not a low rate if you do a bruteforce search for the password :p
16:43:33 <subtlebot> lol
16:43:33 <hkeylocal> sproingie??? i pay ! decrypt pls
16:43:39 <monochrom> Zemyla: I think maybe the unsafeInterleaveIO part is a bit unsettling. But apart from that I don't know.
16:43:44 <EvanR> can we not do cracking inhere
16:43:47 <sproingie> thang1: see, i'm undercutting you already.  figure i could get a few such customers, and i won't have to run my radiator to heat the place
16:44:10 <thang1> sproingie: better buy some AMD GPUs
16:44:20 <sproingie> meh, i *am* being paid by the hour
16:44:30 <hkeylocal> bruteforce is password crypted bcrypt ? 
16:44:40 <sproingie> don't want to stress my laptop i suppose
16:44:54 <EvanR> hkeylocal: do you have anything haskell related to ask
16:44:56 <sproingie> hkeylocal: brute force is what it'll take to educate you
16:44:57 <thang1> Yeah, but AMD gives off much more heat. Just buy like 10 GPUs and string them in a little serverfarm and you've got the whole house heated
16:45:23 <EvanR> so far seems like a bot, and has been doing this a few days
16:45:46 * thang1 petitions to ban hkeylocal
16:45:48 <MarcelineVQ> not a bot, just unreasonably hopeful
16:46:03 <sproingie> any sufficiently advanced stupidity is indistinguishable from a bot
16:46:09 <thang1> ^
16:46:09 <sproingie> the co-Turing test
16:46:27 <monochrom> OK, I'll kick hkeylocal and see what happens. Anyone wants to veto?
16:46:39 <Zemyla> monochrom: Well, the same unsafeInterleaveIO is used in fixIO.
16:46:44 <monochrom> Also:
16:46:56 <monochrom> @remember sproingie any sufficiently advanced stupidity is indistinguishable from a bot
16:46:56 <lambdabot> It is stored.
16:47:20 <geekosaur> probably not a bot, just an idiot that thinks that IRC automatically is defined as skriptkiddie territory and can't possibly be anything at all else
16:47:41 <robkennedy> Is SL Peyton Jones just SPJ? (From his bibliography)
16:48:06 <sproingie> i'm not up with the blackhat community, but don't most scriptkiddies use tor sites now?
16:48:14 <hkeylocal> lol
16:48:17 <monochrom> Ah right Zemyla, OK so maybe it's the MonadIO constraint that makes one go "OK you can't do it more generally, you need one more assumption/restriction"
16:48:22 <hkeylocal> kick me ? because ?
16:48:27 --- mode: ChanServ set +o monochrom
16:48:58 <sproingie> robkennedy: what's the L?
16:49:20 <thang1> sproingie: yeah, the idiots do use sites. Anyone on the irc is hidden behind pretty hard to find servers because they don't wanna waste their time with morons
16:49:22 --- mode: monochrom set -o monochrom
16:49:36 <thang1> thx, monochrom
16:49:41 <EvanR> thats an interesting kick
16:49:57 <thang1> I didn't see the message, what was it?
16:50:00 <geekosaur> it's less than a kick
16:50:10 <geekosaur> [27 23:48:55] * hkeylocal (~hkeylocal@177.138.196.168) has left #haskell (requested by monochrom (hkeylocal))
16:50:11 <sproingie> yah me neither, i have parts filtered which apparently covers kicks
16:50:24 <EvanR> well you filtered it out, so you cant ask about it
16:50:37 <hkeylocal> What is the purpose of this channel?
16:50:43 <thang1> ‡≤†_‡≤†
16:50:53 <MarcelineVQ> hkeylocal: this is a channel for discussion about the haskell programming language
16:50:56 <subtlebot> I think this channel might have to do with Haskell
16:50:57 <sproingie> i love how *polite* that "requested" thing is.  is there some actual irc extension that politely asks clients to /part before a kick happens?
16:51:10 <geekosaur> it's just a remotely induced /part
16:51:23 <geekosaur> s/remotely/third party/
16:51:24 <hkeylocal> ok, sorry
16:51:33 <geekosaur> hkeylocal, this channel is about the Haskell programming language
16:51:45 <thang1> It's also about programming in haskell
16:51:55 <sproingie> which i thought /kick was.  eh, not worth wasting brain cells on it
16:52:06 <robkennedy> I was just browsing his old bibliography for ST papers and notice SL Peyton Jones but I couldn't access those papers
16:52:10 <thang1> sometimes people even talk about weird shit like haskell. Every now and then someone mentions category theory and we make coffee jokes
16:52:10 <hkeylocal> bye :/
16:52:13 <MonadHendrix> and the england rugby player, James Haskel
16:52:24 <robkennedy> Rip hkeylocal
16:52:31 <robkennedy> Wo ai ni
16:52:50 <hkeylocal> Rip? ... im are Anonymous
16:53:00 <thang1> sure you is
16:53:14 <monochrom> sproingie: I used the "remove" command which is special to freenode.
16:53:26 <sproingie> looks like you might need something stronger :)
16:53:39 <MonadHendrix> hkeylocal: learn some haskell lad
16:53:46 <sproingie> for great good!
16:53:52 <hkeylocal> bye
16:54:17 <monochrom> Its semantics is to have the server side simulate a client-side /leave
16:54:42 <monochrom> The hope is that it confuses the hell out of auto-rejoin scripts (and the human)
16:54:51 <robkennedy> A clojure AGI is born. It buffers 32G of open parenthesis and dies
16:55:12 <thang1> great weapon against bots
16:55:15 <MarcelineVQ> yo, this is a bit meta but, messing with people who are being off-topic people is pretty off-topic
16:55:18 <robkennedy> A Haskell AGI is born. It desugars to a no-op
16:55:20 <monochrom> What is AGI? But yeah 32G of parentheses sounds awesome :)
16:55:38 <thang1> AGI == artifical germ infection
16:55:41 <EvanR> MarcelineVQ: that is why i was getting annoyed
16:55:42 <sproingie> hey i just meta but here's my topic chat me maybe
16:55:43 <davean> Artificial general Inteligence
16:55:45 <robkennedy> Artificial General Intelligence 
16:55:53 * thang1 was close
16:57:21 <robkennedy> Any other good ones you can think of? If I can get one or two more I'd like to add it as an intro
16:58:22 <thang1> A C AGI is born. It immediately segfaults.
16:58:23 <sproingie> A Lisp AGI is born.  it's mostly FFI calls into C.
16:59:10 <thang1> A Rust AGI is born. It spends all of its time rewriting itself in Rust.
16:59:23 <monochrom> robkennedy: SL Peyton Jones = SPJ, the L is a middle name I forgot what is.
16:59:25 <robkennedy> A python AGI is born. It's adopted by a mother who wants to connect to her programmer son. 
16:59:42 <thang1> A Perl AGI is born. @#%^%%^&%^$#@$#$1)#
17:00:06 <EvanR> are you just copy pasting these from somewhere
17:00:10 <robkennedy> No
17:00:15 <sproingie> A PHP AGI is born and is immediately declared brain dead
17:00:48 <sproingie> (i still can't get used to typing AGI instead of AI)
17:01:03 <thang1> type AI = AGI
17:01:43 <thang1> A C++ AI is born. It immediately declares that it wants nothing to do with the C AI
17:02:14 <robkennedy> Lol
17:02:45 <MonadHendrix> A Brainfuck AGI is born, and +>+++>+<<<<-]>++.
17:04:05 <sproingie> an APL AI is born, takes over, and abolishes the alphabet
17:04:17 <Welkin> god wrote the world in perl though
17:04:18 <thang1> lol I was just gonna write an APL one
17:04:34 <EvanR> and not a single Haskell AGI was born... despite the topic
17:04:38 <sproingie> oh here's another.  an API AI is born.  it's a one-liner.
17:04:43 <Welkin> https://www.xkcd.com/224/
17:04:43 <sproingie> damn it
17:04:47 <sproingie> *APL
17:04:53 <MonadHendrix> EvanR: haskell one was further up
17:04:54 <monochrom> No, Haskell AGI was the second one born up there.
17:04:56 <thang1> >   robkennedy ‚îÇ A Haskell AGI is born. It desugars to a no-op
17:04:59 <lambdabot>  error: Variable not in scope: robkennedyerror:
17:04:59 <lambdabot>      Variable not in scope:
17:04:59 <lambdabot>        (‚îÇ) :: t0 -> ((Unwrapped s0 -> s0) -> s0 -> Unwrapped s0) -> terror:
17:05:05 <sproingie> BWA
17:05:08 <thang1> whoops
17:05:09 <sproingie> TERROR
17:05:14 <MonadHendrix> doesn't typecheck
17:05:32 <monochrom> But it desugared to a no-op so maybe that's why you didn't see it :)
17:05:59 <EvanR> im so glad i learned haskell so i could make sense of lisp
17:06:15 <sproingie> a haskell AGI is born.  lambdabot has it bumped off to eliminate the competition
17:06:26 <Welkin> what is AGI?
17:06:40 <Welkin> artificial general intelligence?
17:06:44 <sproingie> yep
17:06:50 <sproingie> what normal folk call "AI"
17:07:16 <EvanR> weak head normal folk
17:07:20 <Welkin> it's debatable whether general AI is possible with current computer technology
17:07:31 <Welkin> I'm thinking biotech is where it might be possible
17:07:34 <sproingie> EvanR: that does describe a lot of normal folk
17:07:56 <thang1> Welkin: Well really the debate centers entirely on what consciousness is and how we'll come to understand it
17:08:07 <EvanR> >_<
17:08:20 <Welkin> but then with biotech, it's no longer "artificial"
17:08:25 <Welkin> it is an organic life form
17:08:28 <thang1> If conscious is a fundamental aspect of the universe, like Gravity, then it should be possible to write a AGI with a computer
17:08:29 <MonadHendrix> conciousness is just a meme
17:08:43 <thang1> but not guaranteed :p
17:08:45 <sproingie> artificial intelligence can be precisely defined as "the shit we haven't figured out how to make a computer do yet"
17:08:47 * monochrom considers all-natural homeopathic intelligence
17:09:02 <thang1> If consciousness is a universal aspect, then it's guaranteed we can do it with a computer
17:09:28 <MonadHendrix> went to a homeopathy march the other day but there was barely anyone there, apparently "that's how it works"
17:09:37 <monochrom> hehe
17:09:45 <thang1> However, that being said, even quantum computers are highly limited and can't do several things our brains can do, so there's either several levels higher of computation that we're missing or we're missing the consciousness factor
17:10:11 <Welkin> thang1: architecture matters too
17:10:15 <Welkin> it's not just about raw compute power
17:10:41 <Welkin> the brain is very different from a silicon von neumann machine
17:11:13 <thang1> That's irrelevant, though. The brain works on electrochemical impulses and is made up of electrons and adams just like a silicon machine is
17:11:28 <MonadHendrix> mr brain runs on SPARC
17:11:29 <Welkin> lol, adams
17:11:38 <sproingie> they tried the 1-bit pathways thing, made the most goddam cool LOOKING machine out of it: http://www.corestore.org/cm200-6.jpg
17:11:45 <thang1> s/adams/atoms/ lol
17:11:57 <Welkin> thang1: yes, but it has capabilities that a silicon machines does not
17:12:04 <sproingie> i would love to see something like the CM-1 scaled up on modern hardware
17:12:08 <Welkin> it reconfigures itself constantly
17:12:14 <MonadHendrix> we're all biquinary computers
17:12:25 <thang1> Silicon can do that too... *cough lisp cough*
17:13:01 <Welkin> if you want general AI, grow a lifeform in a lab
17:13:02 <Welkin> done
17:14:01 <Jinixt> it's not AI if we haven't designed it, and when we have "it's just an algorithm"
17:14:17 <Welkin> you can design it
17:14:19 <Welkin> entirely
17:14:25 <Welkin> you can write every sequence of DNA if you wish
17:14:29 <Welkin> it's called syntehtic biology
17:14:36 <Welkin> synthetic*
17:15:00 <mniip> if I apply 'id' to the human genome, does that make it synthetic
17:15:25 <monochrom> No, but you will have an identity crisis, literally :)
17:15:43 <mniip> so yeah
17:15:45 <mniip> not as simple
17:16:04 <sproingie> eh, identical twins give you that.  since both have different versions of RealWorld, even they drift somewhat
17:16:30 <Welkin> they don;t drife somewhat
17:16:55 <Welkin> epigenetics means that biologically identical twins will have completely different gene expression as they age
17:17:11 <Welkin> one may get cancer and die young while the other is strong and healthy into old age
17:17:27 <Welkin> and their dna is totally different at that point
17:17:35 <Welkin> at least the active and inactive genes
17:17:35 <sproingie> i wouldn't say "totally"
17:18:08 <tjtaill> Hi anyone know how to build intero on windows or where I can get prebuilt binary ?
17:18:30 <Welkin> you can build anything on windows?
17:20:51 <sproingie> i just installed intero in emacs and it bootstrapped itself.  have you tried that?
17:21:24 <tjtaill> sproingie I will try that thanks
17:21:34 <tjtaill> you recommend spacemacs ?
17:21:52 <sproingie> whichever emacs churns your butter, i don't care
17:39:32 <parsnip> say i have <random-simple-app> served on port 8080 on my server, is there some drop-in dealie to add password protection to my server? 
17:39:56 <EvanR> thats super underspecified
17:40:34 <parsnip> i want to add a login to my helloworld page
17:40:52 <geekosaur> there is no such drop-in, unless someone came up with something hideous at kernel level that would probably make linux kernel folks cringe
17:41:09 <EvanR> so a web app, with cookies and a session
17:41:26 <EvanR> are you using a framework ?
17:41:32 <geekosaur> now, if you mean app architecture, I suspect you could plug in a Middleware to most of the common Haskell web frameworks to do Basic auth
17:41:59 <pacak> parsnip: You can look into a knock sequence. It kind of can serve as a password protection.
17:42:07 <parsnip> yeah, i have hledger-web running, and right now i use tunneling, but i'd prefer login+password
17:42:39 <geekosaur> however, modern auth systems (e.g. oauth2) require a bit more work. Most if not all of the frameworks support that as well, but it's not quite drop-in; modern auth is a bit more pervasive than that
17:43:57 <parsnip> https://groups.google.com/d/msg/hledger/lZ-pHliX_y4/XsodJe7cHAAJ
17:44:03 <erisco> someone said that talking about the product of lists was weird
17:44:06 <erisco> is that actually weird?
17:44:19 <EvanR> cartesian product?
17:44:23 <erisco> yes
17:44:32 <EvanR> nope
17:44:34 <pacak> (,) <$> [1..4] <*> "abc"
17:44:37 <pacak> > (,) <$> [1..4] <*> "abc"
17:44:39 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c'),(4,...
17:44:41 <pacak> Is it?
17:45:14 <monochrom> Yes, that's product of the two lists there.
17:47:58 <erisco> then is (1,'a') an element of the product or how else do I describe it?
17:48:11 <monochrom> I wonder which one the person means, the product or talking about the product.
17:49:14 <monochrom> Yes, (1,'a') is an element of the product.
17:50:47 <monochrom> Consider the possibility that people don't find math weird, but they find it weird if you and me on a bus talk about math like we are not satisfied with merely talking about weather and celebrities.
17:51:50 <Welkin> my math instructor was on the same bus as I was, and he was reading a math book
17:51:59 <Welkin> I think it was a book on lie algebra
17:52:11 * monochrom rubs his hands
17:54:24 <monochrom> I tell you what could be weirder than talking about math in public.
17:55:33 <erisco> I'm always looking for ways to be less normal
17:55:43 * erisco starts writing a custom Show instance
17:56:12 <monochrom> I was on a plane with another student and we were talking about programming contest problems and solutions. On a row of 3 seats, so there was a 3rd person and stranger. The 3rd person told me "you are clearly very intelligent and a good explainer".
17:59:28 <monadicDuck> prove it.... explain category theory :P
18:00:08 <erisco> just, like, out of the blue? lol
18:00:12 <monochrom> Ah but I am only a good explainer for the topics I've really figured out.
18:02:08 <monadicDuck> :D
18:09:15 <parsnip> me too
18:12:53 <thang1> oooh lie algebra?
18:13:56 <thang1> monochrom: that's the secret. Nobody's a good explainer for topics they haven't really figured out
18:14:20 <sproingie> not understanding what one is explaining leads to monad tutorials
18:14:44 <thang1> ITS A BURRITO OK
18:14:58 <thang1> in comes value, out comes taco; can't explain that
18:15:06 <sproingie> in the category of quesofunctors
18:15:23 <thang1> have you seen that burritos for the hungry mathematician paper?
18:16:03 <sproingie> yep :)
18:16:26 <thang1> (link for the unenlightened: ttp://emorehouse.web.wesleyan.edu/silliness/burrito_monads.pdf )
18:16:33 <thang1> http://emorehouse.web.wesleyan.edu/silliness/burrito_monads.pdf ...
18:17:16 <sproingie> that's how i learned about the Hegelian Taco
18:17:26 <thang1> the wut
18:17:36 <sproingie> it's a thing
18:17:48 <sproingie> or not a thing.  or perhaps the thing inbetween those two things.
18:17:50 <thang1> I just googled it. Apparently it is. I have no idea wtf I'm looking at though :p
18:19:33 <thang1> I think I am going to, ah, do something slightly stupid and go grab a pizza... haven't had food all day and it's making me way too unproductive right now
18:19:55 <Welkin> lol
18:19:58 <Welkin> I have to share that
18:20:16 <Welkin> "Burritos for the Hungry Mathematician"
18:20:19 <thang1> I just love satire papers, they're my favorite
18:20:34 <thang1> https://isotropic.org/papers/chicken.pdf
18:22:00 <thang1> https://ia802501.us.archive.org/7/items/pdfy-tG1MuMpwvrML6QD0/228831637-Optimal-Tip-to-Tip-Efficiency.pdf
18:22:22 <thang1> (yes, this is the dick joke from Silicone Valley made into a math paper)
18:22:44 <Welkin> masturbation joke*
18:23:15 <thang1> http://www.cs.northwestern.edu/~ago820/cs395/Papers/Heckbert_1987.pdf
18:23:45 <Welkin> thang1: that dick paper is too good not to save
18:23:49 <Welkin> I'll forward it to everyone
18:23:59 <thang1> http://www.princeton.edu/~pkrugman/interstellar.pdf check out the abstract in this one, Welkin 
18:24:12 <Koterpillar> what is the chicken one and is there a service for chickenizing papers?
18:24:38 <thang1> The chicken one is the first one I linked. It's literally just a math paper with every word/diagram/etc replaced with chicken
18:25:17 <Koterpillar> ...which one?
18:25:18 <sproingie> wonder if that's where chicken scheme got its name
18:25:33 <thang1> https://isotropic.org/papers/chicken.pdf <-- chicken.pdf is, in fact, the chicken paper
18:26:01 <Koterpillar> thang1: what did it say before the chickenizing?
18:26:11 <thang1> It didn't, they submitted it as is :p
18:26:15 <thang1> https://pdos.csail.mit.edu/archive/scigen/
18:26:31 <thang1> I love that it's cited by 17 other papers
18:27:14 <thang1> https://news.cs.washington.edu/2013/08/14/chicken-chicken-chicken-chicken-chicken/ here's the background for the chicken paper
18:35:46 <sproingie> the sun's not yellow it's chicken
18:41:52 <Welkin> the sun has all colors
18:42:39 <geekosaur> it actually radiates most strongly in a greenish yellow... but it's all strong enough that you'd never notice; you just see white
18:43:11 <erisco> I like this newtype wrapper for clarity but at the same time it is noisy =\
18:43:32 <thang1> for what?
18:43:41 <erisco> the purpose of a list
18:44:00 <thang1> I don't see any code so I've got no idea what's noisy :p
18:44:14 <erisco> to do list operations on it I have to unwrap and rewrap
18:46:39 <sproingie> make it Foldable and there's there's a fair number you'll get for free
18:54:23 <erisco> yeah I am just running into weirdness
18:54:34 <erisco> whether this is an internal wrapper or it is worth exporting
18:55:09 <mniip> geekosaur, strong claim
18:56:10 <mniip> like, I get the idea of the black body radiation and the photosphere, but it is not immediately obvious that the spectrum is maxed in visible light
18:57:28 <sproingie> class G star, makes it a bright yellow
18:58:51 <sproingie> sorry, bright chicken
19:04:22 <Myrl-saki> In my code, `g c (x:xs) = c : f (g c xs); ...`, I observed that `fmap succ (g c xs) = g (succ c) xs`,
19:04:27 <Myrl-saki> When is this true?
19:05:02 <Myrl-saki> I'm assuming if f is of the form `x +`, where x is any integer?
19:07:14 <erisco> do I have to export instances or do those always export
19:08:23 <mniip> Myrl-saki, umm
19:08:25 <mniip> always?
19:08:35 <mniip> that's the ((->) r) fmap
19:08:54 <glguy> you can't avoid exporting instances
19:09:44 <erisco> good
19:10:02 <iqubic> Hello World
19:11:12 <iqubic> So I get that (,) is a product type, and Either is a sum type.
19:11:34 <sproingie> yep
19:11:44 <iqubic> What is the algebra of a list?
19:11:55 <iqubic> Like what kind of a data type is a list.
19:12:14 <sproingie> most generically?  a Functor
19:12:39 <iqubic> List a = Empty | Cons a (List a)
19:12:56 <iqubic> Is that a sum type, or a product type?
19:13:10 <iqubic> Like how do recursive data types work?
19:13:12 <sproingie> well, it can be *either* Empty or a cons
19:13:49 <Koterpillar> l(a) = 1 + a*l(a)
19:14:07 <iqubic> How does that work Koterpillar?
19:14:23 <sproingie> that's expressing List in different notation
19:14:37 <iqubic> Sure.
19:14:58 <sproingie> IOW, it's an algebraic type containing a sum and a product
19:15:56 <mniip> l(a) = 1 / (1 - a)
19:17:00 <Koterpillar> this reminds me of a geometric progression, which List kind of is...
19:17:30 <sproingie> pretty amazing seeing how it's all the same
19:17:46 <sproingie> but just remember, God still hacked the universe together in perl :)
19:19:57 <lyxia> iqubic: a recursive type can be seen as a fixed point
19:20:10 <erisco> why does importing from GHC.Classes ask for ghc-prim package when it should be in base?
19:20:47 <sproingie> type List a = Fix (L a)
19:21:31 <sproingie> i once grokked how that worked.  i think i killed those brain cells long ago.
19:22:54 <sproingie> most concepts in FP take me about three or four tries before they sink in
19:23:21 <lyxia> erisco: why should it be in base
19:24:14 <erisco> where does Prelude export Eq and Ord from?
19:25:20 <sproingie> Data.Eq and Data.Ord most likely
19:25:35 <glguy> http://hackage.haskell.org/package/base-4.9.1.0/docs/src/Prelude.html
19:25:49 <glguy> it's in the middle of the export list there
19:26:10 <glguy> oh, you mean where does it import it?
19:26:21 <erisco> yes
19:26:49 <erisco> Read and Show come from GHC.Read and GHC.Show, I think
19:31:02 <sproingie> http://hackage.haskell.org/package/ghc-prim-0.5.0.0/src/GHC/Classes.hs
19:31:16 <sproingie> Eq is there, line 124-ish
19:31:45 <erisco> yeah, but then cabal complains I need ghc-prim as a dependency
19:31:53 <sproingie> it's kinda built in
19:32:09 <sproingie> is it insisting on a higher version or something?
19:32:24 <erisco> maybe it requires that I list all my direct dependencies
19:32:30 <erisco> so it isn't enough that base depends on ghc-prim
19:32:34 <erisco> I have to list it as well
19:32:47 <iqubic> What's the best data type for working with highly precise decimal numbers. I'm currently using RealFloat, but I think I'm coming up against rounding errors
19:32:50 <iqubic> ?
19:32:55 <erisco> I am going for the import Prelude() style, so that's why this is happening
19:33:46 <sproingie> still don't imagine you need to depend on ghc-foo packages, just a minimum base would do
19:33:57 <erisco> but maybe I should take these through Prelude anyways so I don't need ghc-prim explicitly
19:34:01 <erisco> less version problems
19:34:01 <iqubic> Is Float more precise than RealFloat?
19:35:40 <iqubic> What's the most precise I can make my complex numbers?
19:36:31 <iqubic> As in how many places after the decimal point will they be accurate for?
19:36:50 <Koterpillar> Complex is parametrized by the number type
19:37:33 <sproingie> iqubic: RealFloat is a class, Float and Double are its instances
19:38:17 <sproingie> and there's probably arbitrary-precision instances to be had third-party if you need them
19:38:35 <iqubic> sproingie: I see.
19:39:00 <iqubic> So I think I want to use RealFloat => Floating (Complex a)
19:39:39 <Koterpillar> @hackage scientific --iqubic
19:39:39 <lambdabot> http://hackage.haskell.org/package/scientific --iqubic
19:39:56 <sproingie> possibly, i actually don't know much more about numerics in haskell
19:52:26 <erisco> I definitely installed a markdown editor for Windows a while ago... now I cannot remember what it was called
19:52:44 <Welkin> erisco: emacs?
19:52:57 <Welkin> it runs everywhere
19:53:17 <erisco> no, I had one for idiots
19:54:18 <Welkin> why a markdown editor?
19:54:24 <Welkin> why not a latex editor?
19:54:28 <Welkin> like texshop
19:55:32 <erisco> maybe I just used an online one
19:59:20 <sproingie> appnesia - (noun) The condition in which one forgets which app they downloaded to fulfill some one-off need long ago, and now need to install again.
19:59:42 <Welkin> do you use more or less?
19:59:52 <sproingie> less is more
20:00:21 <Welkin> lol
20:00:26 <Welkin> there is also a program called most
20:00:32 <Welkin> most, more, and less
20:00:40 <sproingie> more or less
20:01:33 <Welkin> https://unix.stackexchange.com/questions/81129/what-are-the-differences-between-most-more-and-less#81131
20:01:42 <Welkin> so it looks like `less` is the best one to use
20:02:13 <erisco> I need a Haddock to MD converter
20:02:19 <erisco> maybe one exists... just been doing it by hand each time
20:02:22 <Welkin> o.o
20:02:25 <Welkin> try pandoc
20:02:37 <sproingie> "less" has been the default on osx and pretty much every linux forever.  
20:03:30 <cranej> "most is supposed to be more than less" lol
20:03:45 <sproingie> it mostly is
20:04:29 <sproingie> if it's smarter about external formatters than less, i wouldn't mind that
20:04:45 <Welkin> or you can just use emacs
20:04:46 <sproingie> lesspipe not being the most satisfying thing
20:04:47 <thang1> it is
20:05:07 <thang1> Welkin: I like emacs as much as the next person, but I am /definitely/ set in my vim/unix ways
20:05:24 <Welkin> but no one knows how to exit vim once they open it
20:05:28 <thang1> different programs for different shit. I don't need my PS1 to be emacs
20:05:30 <sproingie> i used to use vimpager, that was pretty satisfying for colorizing stuff
20:08:35 <thang1> s/PS1/init
20:08:38 <thang1> http://www.informatimago.com/linux/emacs-on-user-mode-linux.html
20:09:08 <evincar> I've got a small challenge involving an AST and I'm wondering if a generics library like syb/uniplate can help
20:09:17 <thang1> What's your challenge?
20:09:26 <evincar> Essentially I have 'data Stat' and 'data Expr' where 'Stat's contain 'Expr's, typical
20:09:40 <evincar> I want to traverse the AST and collect all the function calls, in the order that they would be called
20:09:54 <Nolrai> How bad is -XAllowAmbiguousTypes?
20:09:58 <evincar> And for conditional statements (if) and expressions (?:) return a list of the calls at the same level
20:10:11 <evincar> So AST -> [[Name]], basically
20:10:32 <evincar> For example: f(); if (x) { g(); } else { h(); } => [[f], [g, h]]
20:10:50 <evincar> And f(g(), h()); => [[g], [h], [f]]
20:11:41 <evincar> It looks like syb/uniplate only give me top-down, left-to-right order by default
20:11:55 <evincar> Just wondering if I can change that in the middle of a traversal or something
20:12:41 <evincar> Nolrai: It's fine if you have a compiler with -XTypeApplication (GHC 8.0+ IIRC)
20:13:03 <Nolrai> Okay! Thanks!
20:13:04 <evincar> Nolrai: Because (I'm pretty sure) you can always disambiguate
20:14:04 <Nolrai> Yeah but the whole reason I am doing this is to not need too.
20:14:21 <thang1> Nolrai: as a rule of thumb, any pragma with the words "ambiguous", "undecidable", "incoherent", etc... are pretty risky. AmbiguousTypes with TypeApplication adds the safety back in that you lost (iirc)
20:14:45 <evincar> Hm,a ctually I suppose I need a tree as the result, for things like f(); if (x) { g(); h(); } else { i(); }
20:15:27 <evincar> Maybe not, I guess that could be represented as [[[f]], [[g, h], [i]]]
20:15:57 <evincar> I could do it manually but it's a largish AST and I'd rather not write out all the cases by hand
20:16:01 <Nolrai> I want a fuction that will take both ((a->b),(b->a)) and (a-> MyMonad b, b -> MyMonad a)...but the type class I wrote wont know when to stop wrapping. >.<
20:16:37 <Nolrai> Wait..
20:16:46 <thang1> You sure?
20:18:20 <sproingie> a->b is fully generic and would subsume a -> MyMonad b
20:18:45 <sproingie> er, polymorphic.  whatever.
20:18:50 <thang1> sproingie: even if it's (a -> m b) (m a -> b) ?
20:19:04 <sproingie> b is any arbitrary type, including m b
20:19:19 <sproingie> (ok that's confusing taken by itself)
20:19:34 <erisco> oh how am I doing this wrong... again... trying to upload to Hackage
20:19:36 <erisco> I never get it right
20:19:37 <thang1> whoops, (a -> mb) (b -> m a) is what I meant. Either way, the monad is on a and b but not consistently
20:19:48 <sproingie> probably a simple solution involving kinds, i'm a little too fried to think of it
20:20:32 <thang1> so, to my mind, if you have a -> b and you pass a (monad b) in as b, how does the program know to apply that monad to the other one?
20:21:19 <sproingie> it wouldn't.  in fact it doesn't know how to do anything to b without some type or constraint
20:22:40 <Nolrai> Right but because both a and b are constrained by being the input..its posible to do in theory.
20:22:47 <thang1> Yeah, that's what was tripping me up :p
20:23:19 <Nolrai> I am not sure its possible in practice..but the error I am getting is really odd.
20:23:21 <sproingie> @djinn a -> (a -> b) -> b
20:23:22 <lambdabot> f a b = b a
20:23:44 <thang1> @djinn ((a->b),(b->a))
20:23:45 <lambdabot> -- f cannot be realized.
20:24:06 <thang1> whoops, brain fart, that's not a proper type signature lol
20:24:16 <Nolrai> It is!
20:24:27 <Nolrai> But its not a function
20:24:43 <erisco> and also not implementable
20:24:46 <sproingie> @hoogle a -> b -> (a->b) -> (b->a)
20:24:46 <lambdabot> package base
20:24:47 <lambdabot> package bytestring
20:24:47 <lambdabot> package containers
20:24:57 <sproingie> that was less than illuminating
20:25:20 <Nolrai> What I am doing is using quick cheeck to test if two functions are inverses.
20:26:30 <evincar> So you want something like forall x. f (g x) = x for pure functions and forall x. f =<< g x = pure x for monadic things?
20:26:30 <Nolrai> And unfortunately in some pairs both functions return errors, some one function produces error, and in others neither function produces errors.
20:26:45 <Nolrai> Yeah basicly.
20:26:55 <sproingie> leave it as a -> m b and lift into Identity?
20:26:57 <evincar> Why not use Identity?
20:26:58 <evincar> Yeah
20:27:26 <evincar> Just use (pure . f, pure . g)
20:28:03 <Nolrai> No..because that will only take the monadic case.
20:28:11 <Nolrai> *non-monadic
20:28:18 <erisco> not sure if the bot is still running, so I'll have to plug it myself http://hackage.haskell.org/package/data-list-zigzag
20:28:49 <Myrl-saki> mniip: Isn't it []?
20:29:49 <sproingie> oddly i grok monads far more than applicatives
20:30:22 <sproingie> i get the basic difference, i just don't steer toward using applicative
20:30:27 <Nolrai> Wait now I get it. I think that will work.
20:31:03 <Nolrai> Just practice I think is the only "treatment" for that.
20:31:18 <evincar> sproingie: How do you mean? Like writing "do { a <- ma; b <- mb; return (f a b) }" instead of "f <$> ma <*> mb"?
20:31:46 <sproingie> i grok the syntax ok enough, though i hate typing it
20:31:58 <sproingie> anything that makes me lean on the shift key is syntax i don't care for
20:32:36 <evincar> I just swapped digits and symbols in my keyboard layout :P
20:32:42 <evincar> Although <> are still shift characters
20:33:13 <evincar> You can always use liftA2, etc.
20:33:29 <iqubic> erisco: Why would lambdabot be down?
20:33:30 <sproingie> oh <> is fine, that's super easy to type on most keyboards, i love doing monoids with that
20:33:41 <iqubic> > 1 + 2
20:33:43 <lambdabot>  3
20:33:46 <erisco> iqubic, I haven't seen it mentioning package updates lately, have you?
20:33:59 <iqubic> @hackage gloss
20:33:59 <lambdabot> http://hackage.haskell.org/package/gloss
20:34:03 <geekosaur> hackagebot is down, yes
20:34:24 <geekosaur> rather, the bot was inadvertently left running but the infrastructure it was polling was taken down, iirc
20:34:29 <iqubic> erisco: I have been around here for a month, and never seen hackagebot once.
20:34:51 <sproingie> really it's just that i've not developed the muscle memory for haskell's punctuation-heavy operators like i have with perl and c++ code
20:34:52 <geekosaur> chrisdone is still looking for someone to take it over and rehabilitate it, iirc
20:36:17 <thang1> (^_^) is an actual operator in haskell
20:36:18 <sproingie> it's weird how the use case for a language feature like applicative can be driven by one's preferences in how elegant the operators look and feel to type
20:36:34 <Nolrai> ...
20:36:36 <erisco> so now you can enumerate the Cartesian product of lists differently, if you were bored of the default way
20:36:46 <sproingie> but in the end, languages are user interfaces
20:37:10 <thang1> sproingie: definitely feel that. I'm a fan of ultra terse code but at the same time I hate overly verbose ascii drawings masquerading as operators
20:37:12 <evincar> Yeah, people will tend toward the "easy" thing (semantically or syntactically)
20:37:28 <Nolrai> So what does this "* Could not deduce: linked0 b (EMG b)" I mean how is that even a context constructor: it's lowercase!
20:37:41 <evincar> Come to think of it, an Emacs input method for Haskell operators based on TeX mode would be nice
20:37:42 <sproingie> i like scala's trick where any method of one argument is an infix operator
20:38:01 <evincar> \fmap => <$>, \ap => <*>, \alt => <|>, \bind => >>=, that sort of thing
20:38:15 <sproingie> basically haskell's backticks without the backticks
20:38:46 <sproingie> in turn requiring other syntax compromises, so ... yeah
20:39:06 <evincar> Yeah, juxtaposition is already taken in Haskell, for better or worse
20:39:21 <evincar> It would be nice to be able to overload application sometimes
20:39:27 <Nolrai> I often define operators without exporting them, just to be used in that file.
20:39:28 <erisco> -XOverloadedJuxtaposition
20:39:37 <sproingie> implement it
20:39:38 <evincar> Which you can kinda do by making instances of typeclasses for (->)
20:40:01 <evincar> Eh
20:40:05 <evincar> I don't want it enough to implement
20:40:16 <sproingie> far as i can tell, the way various -X flags got added was some damn fool just went and did it
20:40:17 <evincar> And I should really do that InlineDoBind extension I was thinking of first
20:40:33 <evincar> (Similar to Idris !-notation)
20:40:47 <evincar> The typeclass approach is enough, usually
20:40:49 <sproingie> then went through a proper patch process to merge in of course
20:41:07 <evincar> For example, I once made an API like "forAll $ \ x y z -> ..." for generating fresh type variables in a compiler
20:41:29 <evincar> Which was good enough
20:42:28 <sproingie> i need to learn more about dependent types sometime
20:43:10 <Nolrai> I wish ghc would give me a warning if I have a type Blaw, and a type variable blaw.
20:43:26 <sproingie> is the idea to obliterate the boundary between the type language and the programming language?
20:43:37 <evincar> Something like that
20:43:52 <ezyang> usually it fails to compile anyway 
20:43:59 <evincar> Dependent types let you talk about (proofs concerning) runtime values at compile time
20:44:32 <evincar> Simple example: foo is a function that takes a non-negative Int
20:45:11 <Nolrai> sproingie: Yes, but it lets you do some amazing things...but we have not figured out how to make it easy to do the really cool things. :/
20:45:15 <evincar> In order to call it with an Int x, you need a proof that x is non-negative
20:45:23 <erisco> sproingie, well you certainly don't need much of the type language weirdness anymore
20:45:24 <evincar> Which you can obtain by checking x, if it's a runtime value
20:45:35 <evincar> Or you get for free if x is known statically
20:45:41 <thang1> evincar: look at how emacs and Agda do their unicode input
20:45:42 <erisco> though you lose -> as a type and pick up binders which are a new strangeness
20:45:59 <sproingie> binders full of women
20:46:28 <erisco> and I think if you could have more power and yet keep the separation you would
20:47:40 <Nolrai> If I could get it to work, I find the syntax of liquid haskell way way better.
20:47:43 <erisco> it isn't all roses because it is more complicated
20:47:57 <sproingie> i imagine it'll shake itself out to something more usable
20:48:55 <Nolrai> Yeah, and we really need a beter kind of poly-morphism. As described in that paper that is an extended shakespear pun IIRC.
20:49:04 <sproingie> i first poked my nose into haskell around 2000, things were a little wild and wooly then
20:49:22 <sproingie> said it before, but i suffered through *every* monad tutorial
20:49:25 <Nolrai> sproingie: Yeah..but might take about that much time, still.
20:49:35 <Nolrai> Hah, I read them all too.
20:49:46 <sproingie> even now, i approach monad transformer stacks with dread
20:50:06 <erisco> and worse is that given the power I don't think I can write a program ever again
20:50:12 <Nolrai> Only one that helped was the one that lied to me and just told me how to use the IO type.
20:50:15 <sproingie> i get HOW they work, but when they don't, the errors make me start gibbering in some strange tongue
20:50:22 <erisco> because I can spend an eternity adding every possible bit of information to the types
20:50:49 <thang1> erisco: then you don't need to actually run the program. Just compile it and get the statically compiled answer :p
20:50:53 <evincar> It's funny, I never really read any monad tutorials
20:50:59 <evincar> Or even Haskell learning materials
20:51:04 <Nolrai> erisco: yeah, and proofs are still really hard to formalize..soo..
20:51:12 <evincar> I mainly learned from examples, and trial and error
20:51:24 <evincar> Apart from the basic syntax
20:51:24 <thang1> I really like the idea of liquid haskell, but honestly a lot of the syntax drives me up the wall
20:51:44 <pacak> :t confusing
20:51:46 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
20:51:53 <thang1> lol
20:51:56 <pacak> evincar: trial and error this?
20:51:56 <sproingie> it doesn't help that i have basically zero math background, i'm just a dilettante in CS and math
20:51:59 <Nolrai> I've never been able to get LH to compile..
20:52:15 <Nolrai> thang1: what parts?
20:52:22 <pacak> :t cata
20:52:23 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
20:52:24 <erisco> I was working on a solver for association proofs. I'd say "at the type level" but it is all the same level
20:52:30 <evincar> pacak: What, my AST problem? I'm trying :P
20:52:36 <evincar> Oh, confusing
20:52:43 <evincar> Meh
20:52:48 <erisco> not that strong in DT yet and so I struggled to model it correctly
20:53:19 <evincar> Lens deliberately uses transparent types to gain reusability, e.g., (.)
20:53:25 <evincar> At the cost of shit error messages
20:53:26 <thang1> Nolrai: the non math syntax :p
20:53:27 <sproingie> any monad-tutorial traps i should avoid wrt learning DT?
20:53:45 <thang1> sproingie: literally don't read any monad tuorials ever :p
20:53:50 <Nolrai> thang1: Like "mesure"?
20:53:59 <sproingie> oh i grok monads fine ... NOW
20:54:06 <erisco> as I understand you normally do such a thing with a "tactic" which uses other facilities...
20:54:15 <Nolrai> Yes...
20:54:18 <erisco> but it seemed reachable to actually do this plainly
20:54:28 <sproingie> monad transformer stacks OTOH, always feel really wobbly to me
20:54:51 <Nolrai> sproingie: why?
20:55:06 <evincar> Yoneda in the sense of (forall r. (a -> r) -> f r) ~ f a is just a CPS transform, no?
20:55:16 <sproingie> no intuition on reading the signatures on why this type is that
20:56:03 <Nolrai> Well monad stacks implement their effects out-side in.
20:56:13 <monochrom> pacak: catmorphism :: Functor f => (f a -> a) -> Meow f -> a :)
20:56:42 <evincar> Monad transformers are most useful at only one level of nesting, IMO
20:57:10 <thang1> Nolrai: yeah I don't really like measure and things like that. I prefer writing things using first order formal logic notation
20:57:15 <sproingie> i think it's just my anglo-saxon tendency to want to reduce concepts to a single noun, preferably one syllable
20:57:26 <thang1> Especially with unicode
20:57:28 <sproingie> big stacks confuse my brane
20:57:28 <evincar> Whenever I want an "application" monad stack (reader of state of such-and-such), I just implement it myself directly
20:57:37 <pacak> evincar: Yoneda gives Functor instance without requiring f to be a Functor
20:57:57 <thang1> {-@ insert :: k:_ -> _ -> m:_ -> {v: _ | keys v = add k m } @-}  -- this looks like garbage
20:58:21 <evincar> pacak: Cool, I'd forgotten that
20:58:33 <evincar> Add that to the arsenal of "get an X without a Y instance"
20:58:47 <evincar> E.g. Free = get a Monad with only a Functor instance
20:58:59 <sproingie> thang1: that looks like a rewrite rule or something.  those are usually hairy.
20:59:01 <evincar> Prompt = Monad without Monad instance?
20:59:14 <sproingie> rewrite rules exist so you don't have to write code that awful
20:59:41 <Nolrai> So just define "newtype MyMonad x = MkMyMonad {unMkMyMonad :: Monad Stack Of Doom x} deriving {Monad}.
21:01:02 <Nolrai> Lets you use the mtl stuff but not have as insane type errors. 
21:02:01 <pacak> noraesae: Also deriving MonadStack, MonadOf and MonadDoom
21:03:00 <Nolrai> Yep. :P
21:11:03 <Nolrai> Why would I get "(needs flag -package-key mtl-2.2.1)"?
21:11:20 <dfordivam> Is there a way to specify the type signature of a value on the lhs of a do notation like do { a:: Char; a <-getChar}
21:12:48 <Nolrai> dfordivam: With -XScopedTypeVariables you can write "do {(a :: Char) <- getChar}"
21:14:17 <dfordivam> I know I can write do { a <- getChar :: IO Char}, but I want to just specify the type of value...
21:14:28 <Nolrai> Well actually not that persay..but "do {(a :: Char) <-getChar; foo a}" because the last line of a do statement cant be an asignment.
21:14:47 <Nolrai> Yes with -XScopedTypeVariables you can do that.
21:15:02 <dfordivam> Nolrai: I see let me try... 
21:17:54 <dfordivam> Nolrai: Yeah this is what I needed.
21:19:17 <Nolrai> Glad I helped!
21:40:47 <andrei> I have a project that links with stack build and stack ghc but fails to work with stack ghci. stack ghci doesn't give ghci the proper linker flags to pick up the dynamic libraries it should.
21:40:56 <andrei> Where would one look to understand why?
21:42:08 <sm> andrei: stack issue tracker ? 
21:42:36 <sm> I've seen discussion of flags not being passed, might have been there
21:42:43 <andrei> sm: There are closed tickets on this
21:42:44 <andrei> https://github.com/commercialhaskell/stack/issues/467
21:43:05 <andrei> But I can't see any solutions or any suggestions about how to figure out what's going on
21:45:04 <sm> also, did you try latest GHCI ? I think it keeps getting better at matching ghc behaviour
21:45:41 <andrei> sm: Yeah. I'm using 8.0.2
21:48:00 <iqubic> Is it possible to use Data.Complex and Data.Scientific together?
21:48:13 <Koterpillar> iqubic: sure, why not
21:49:12 <iqubic> Well, I don't think it would be of type RealFloat a => RealFloat (Complex a)
21:49:38 <iqubic> Because there is no instance of RealFloat Scientific.
21:50:21 <Koterpillar> what's wrong with Complex Scientific?
21:51:03 <iqubic> I don't think I'd be able to use it in my application.
21:52:52 <Koterpillar> well, Scientific isn't RealFloat (IDK why, haven't looked at it)
21:53:10 <iqubic> Yeah, I know.
21:53:40 <iqubic> Koterpillar: Do you have a guide to Haskell numbers I can look at? I want to learn more about the various number typeclasses.
21:54:30 <iqubic> :t (\z -> z^2 + (5 :+ 5))
21:54:32 <lambdabot> RealFloat a => Complex a -> Complex a
21:54:46 <iqubic> Why does that have the RealFloat constraint?
21:55:00 <jle`> check out the source
21:55:21 <iqubic> :t (\z a b -> z^2 + (a :+ b))
21:55:22 <lambdabot> RealFloat a => Complex a -> a -> a -> Complex a
21:55:47 <iqubic> That's a more generic version. Still has the RealFloat constraint for some odd reason.
21:56:16 <jle`> check out the instance definition
21:56:29 <iqubic> Of what?
21:56:38 <jle`> Complex
21:56:42 <jle`> Num
21:56:44 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Complex.html
21:56:51 <iqubic> RealFloat a => RealFloat (Complex a)?
21:56:52 <jle`> ^ and + use the Num instance
21:56:58 <jle`> not the RealFloat instance
21:57:02 <geekosaur> iirc, ensuring (a) you aren;t doing Complex (Complex a)) (b) you can do sqrt, so you can do abs which is required for Num
21:57:15 <jle`> you don't need RealFloat to use ^/+, you just need Num 
21:57:24 <jle`> so check out the implementation of the Num instance :)
21:57:29 <nshepperd> '
21:57:37 <nshepperd> 'instance (RealFloat a) => Num (Complex a)' :(
21:57:53 <jle`> iqubic: go to http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Complex.html and find the intsance of Num
21:57:55 <jle`> for Complex
21:58:03 <jle`> and click 'Source'
21:58:05 <iqubic> jle` Why does GHC seem to think that I want the RealFloat instance of a? Is this DMR at play?
21:58:06 <Koterpillar> ...so maybe you can't have it for Scientific?
21:58:15 <jle`> iqubic: it's because you use ^/+
21:58:26 <jle`> iqubic: which requires a Num insatnce of Complex a
21:58:38 <jle`> and check out what constraint on 'a' you need for 'Num (Complex a)'
21:59:10 <jle`> in fact, you can even type ':i Complex' in ghci
21:59:18 <jle`> and you'll see what constraint you need on 'a' for Num (Complex a)
21:59:37 <iqubic> Why? What is in the Num instance of Complex that requires a RealFloat
21:59:39 <iqubic> ??
21:59:54 <jle`> check out the instance definition :)
22:00:01 <nshepperd> iqubic: abs (a :+ b) = sqrt(a^2 + b^2)
22:00:02 <jle`> go to http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Complex.html , find the list of instances for Complex
22:00:11 <jle`> and find the Num instance
22:00:17 <jle`> click the little '#' link
22:00:34 <jle`> er i mean, the little 'Source' link
22:00:36 <geekosaur> Source link; # is just the anchor that brings you to that spot
22:00:48 <geekosaur> also I answered this already :)
22:01:04 <nshepperd> more reasons to fix haskell's numeric hierarchy
22:01:15 <iqubic> I also see this: RealFloat a => Floating (Complex a)
22:01:19 <jle`> geekosaur: you don't need RealFloat to do sqrt
22:01:31 <jle`> iqubic: yeah, but you didn't use any Floating methods in what you gave us
22:01:40 <iqubic> What is the difference between RealFloat and Floating?
22:01:41 <jle`> that would be an interesting instance, but, ultimately unrelated
22:01:47 <jle`> iqubic: check out the docs :)
22:01:49 <jle`> or :i in ghci
22:01:52 <jle`> they just have different methods
22:01:57 <jle`> kind of like the difference between Ord and Num
22:02:00 <jle`> or Monad and Monoid
22:02:00 <geekosaur> you need Floating. the other one is why you need Real, and you could either say (Real a, Floating a) or you can say RealFloat a
22:02:19 <jle`> RealFloat a is more than just (Real a, Floating a)
22:02:32 <jle`> the reason why it requires RealFloat is because it uses 'scaleFloat'
22:02:42 <jle`> which is a method of the RealFloat typeclass
22:03:07 <jle`> although i suppose it really shouldn't need it
22:03:53 <iqubic> jle`: I'm not seeing the scaleFloat function being used in the Num instance of Complex
22:03:53 <jle`> iqubic: the difference between RealFloat and Floating is the same as the difference between Monoid and Functor, Num and Ord, etc; they are just different typeclasses with different methods 
22:04:07 <nshepperd> oh, it's an optimization. gross
22:04:18 <jle`> iqubic: it's in abs z = magnitude z :+ 0
22:04:24 <jle`> and magnitude uses scaleFloat
22:04:33 <iqubic> Ugg.
22:04:35 <jle`> (signum also uses magnitude)
22:04:49 <jle`> although yes i suppose it technically doesn't have to use scaleFloat
22:05:07 <iqubic> So I can't have (Complex Scientific) as a Complex Num?
22:05:19 <jle`> you can't have a Num instance for Complex Scientific
22:05:29 <nshepperd> it should be specialized for floats and doubles or something
22:05:32 <iqubic> That really blows.
22:05:45 <iqubic> nshepperd: What should be specialized?
22:05:51 <jle`> iqubic: but even if it didn't use scaleFloat, it still wouldn't work
22:06:07 <jle`> the very minimum you could have is Floating a => Num (Complex a)
22:06:07 <iqubic> Oh, why not?
22:06:13 <nshepperd> Scientific could have a Floating instance, couldn't it?
22:06:17 <jle`> but there's no Floating instance for Scientific
22:06:22 <iqubic> Why do you need Floating?
22:06:30 <iqubic> Why is that the minimum?
22:06:41 <jle`> iqubic: for abs
22:07:03 <iqubic> Why does abs need float?
22:07:07 <geekosaur> abs uses magnitide which uses sqrt
22:07:11 <geekosaur> *magnitude
22:07:14 <jle`> abs (r :+ i) = sqrt (r*r + i*i) :+ 0
22:07:21 <geekosaur> because the magnitude of a complex value ^
22:07:26 <jle`> but admittedly this is probably more a problem with why Num even has 'abs' in it
22:07:38 <geekosaur> (think pythagorean theorem)
22:08:00 <iqubic> Wait... sqrt requires a Float a?
22:08:08 <jle`> it requires Floating
22:08:14 <nshepperd> sqrt is in the Floating typeclass
22:08:16 <opqdonut> that abs doesn't fulfil the law, right?
22:08:16 <iqubic> Yeah, I see that.
22:08:23 <opqdonut> the law is x == signum x * abs x
22:08:50 <jle`> there aren't any laws for Num, but the Num instance for Complex actually does follow that
22:08:58 <iqubic> It does?
22:09:03 <jle`> > signum (1 :+ 3) * abs (1 :+ 3)
22:09:05 <lambdabot>  1.0 :+ 3.0
22:09:11 <opqdonut> oh right I guess if you define signum properly
22:09:20 <opqdonut> as x/abs x
22:09:23 <opqdonut> yeah that's fine actually
22:09:30 <jle`> it's actually defined as the angle from the positive real axis
22:09:38 <jle`> the "argument", in the polar form for complex numbers
22:09:57 <nshepperd> huh? no it isn't. it's just the normalized number
22:10:00 <jle`> which is cute because it becomes -1/0 for Complex where there is 0 imaginary part
22:10:09 <jle`> oh ah, yeah, sorry
22:10:44 <jle`> it's the location of the angle on the unit circle :3
22:11:30 <jle`> i wonder why Scientific has no Floating instance
22:11:50 <iqubic> So while I can have Complex Scientific, it won't be an instance of Num.
22:11:56 <nshepperd> so anyway, Num probably shouldn't have abs in it in the first place
22:12:03 <nshepperd> so that we can use it for general rings
22:12:25 <nshepperd> and then we could have gaussian integers, too. Complex Integer
22:12:39 <iqubic> What the heck is the difference between Integer and Int?
22:12:55 <geekosaur> Int is a machine word, Integer is arbitrarily sized
22:13:02 <geekosaur> > maxBound :: Int
22:13:03 <lambdabot>  9223372036854775807
22:13:11 <geekosaur> > maxBound :: Integer
22:13:13 <lambdabot>  error:
22:13:13 <lambdabot>      ‚Ä¢ No instance for (Bounded Integer)
22:13:13 <lambdabot>          arising from a use of ‚ÄòmaxBound‚Äô
22:13:28 <geekosaur> ...because the bound is the size of available memory to hold it
22:13:39 <jle`> > fromIntegral (maxBound :: Int) ^ 100 :: Integer
22:13:41 <lambdabot>  3082994025277634712274218621887248264746878848022492393788592018245624105661...
22:13:44 <pacak> iqubic: Int is a bit faster.
22:13:55 <pacak> Integer is a bit bigger.
22:14:12 <iqubic> I'm looking through the docs for Scientific and see that you have scientific :: Integer -> Int -> Scientific
22:14:17 <iqubic> That's odd.
22:14:28 <iqubic> That's how you construct it.
22:14:53 * nshepperd . o O (Acme.Integer.Bounded: maxBound :: Integer that detects the size of your system's memory and makes an Integer that big)
22:15:04 <monochrom> haha
22:15:26 <jle`> iqubic: there are multiple ways to construct it
22:15:30 * geekosaur refrains from chekcing hackage to see if someone's already done that >.>
22:15:31 <jle`> that's just one :)
22:15:35 <monochrom> No no, I have a better idea. The detection is done at compile time.
22:16:10 <pacak> nshepperd: Program will explode during first GC...
22:16:11 <iqubic> Alright, so Scientific has isFloating :: Scientific -> Bool, but no Floating instance???
22:16:15 <monochrom> So, build it on a 64GB RAM machine. Deploy it in an Amazon 512MB virtual machine...
22:17:31 <nshepperd> monochrom: or maybe it could dynamically do it based on the available free space? so that maxBound gets smaller as your program runs :)
22:17:34 <geekosaur> iqubic, did you consider reading the documentation?
22:17:41 <jle`> it can be done at runtime by just doing 'succ' repeatedly until an out of memory exception happens, under unsafePerformIO
22:18:08 <iqubic> geekosaur: Documentation for what?
22:18:11 <iqubic> Scientific?
22:18:22 <geekosaur> yes
22:19:10 <iqubic> I'll read it later. I know that it won't work for my projects
22:23:10 <thang1> neatttttt
22:23:19 <thang1> Finally found a legit use for as-pattern
22:23:49 <iqubic> Which is...?
22:23:54 <jle`> as-patterns are as-tounding
22:23:56 <thang1> capitalizeWords = map (\l@(x:xs) -> (l, toTitle x : xs)) . words
22:23:57 <jle`> ha ha
22:24:03 <MarcelineVQ> making your patterns look 20% cooler
22:24:27 * pacak likes smell of as-patterns in the morning
22:24:33 <geekosaur> myKeys conf@(XConfig {modMask = modm}) = ...
22:24:45 <jle`> sometimes i just do _@ on my patterns to make them look cooler
22:24:54 <thang1> ‡≤†_‡≤†
22:25:10 <thang1> (what does _@ do, anyway?)
22:25:14 <jle`> map f _@[] = []; map f _@(x:xs) = f x : map f xs
22:25:18 <jle`> thang1: it's an as pattern
22:25:21 <jle`> that binds nothing
22:25:37 <jle`> > let _@(x:xs) = [1..] in x
22:25:39 <lambdabot>  <hint>:1:6: error: parse error on input ‚Äò@‚Äô
22:25:40 <thang1> okay, I thought that was the case. Just wanted to make sure I wasn't crazy :p
22:25:42 <monochrom> an as-pattern that replaces the var by the wildcard meaning "I don't actually need it"
22:26:34 <jle`> (it's actually not valid syntax, don't try it in real code :) )
22:26:38 <monochrom> Like you buy a laptop, pay cash, collect the change, and leave the laptop behind.
22:26:41 <jle`> or i suppose, if you do, there isn't too much harm it could do
22:26:56 <Maxdamantus> > let f _@_@_@_@x = x + 1 in f 4
22:26:57 <monochrom> Because you paid counterfeit cash!
22:26:58 <lambdabot>  <hint>:1:8: error: parse error on input ‚Äò@‚Äô
22:27:19 <iqubic> Why would you use _@ ever?
22:27:20 <nshepperd> the compiler isn't interested in your tomfoolery
22:27:28 <jle`> > let f x@(y@(z@(a@(b@c)))) = x + 1 in f 4
22:27:30 <lambdabot>  5
22:27:52 <Maxdamantus> are those brackets necessary?
22:27:53 <iqubic> jle`: What do all those @s mean?
22:27:59 <jle`> iqubic: they are as-patterns
22:28:25 <Maxdamantus> Don't seem to be.
22:28:26 <thang1> iqubic: You wouldn't, really
22:28:27 <pacak> Something to make your code look more like lisp
22:28:39 <jle`> iqubic: they let you deconstruct on a pattern match, and also name the entire input
22:28:43 <monochrom> Did you know: SML has you spell out the "as". Example: fun f (v as (x::xs)) = ...
22:28:57 <monochrom> (I forgot which parentheses are optional.)
22:29:02 <thang1> capitalizeWords = map (\l@(x:xs) -> (l, toTitle x : xs)) . words  -- This is a "legit" use of as-patterns
22:29:14 <thang1> jle`'s nonsense is just abusing it for shits and giggles
22:29:21 <jle`> > case Just 10 of x@(Just y) -> (x, y)
22:29:23 <lambdabot>  (Just 10,10)
22:30:10 <monochrom> More subtly: case [] of ~v@(_:_) -> seq v ()  = bottom
22:30:43 <iqubic> monochrom: What's SML?
22:30:59 <monochrom> I am not talking to you.
22:31:07 <iqubic> Why not?
22:31:31 <monochrom> (Best paradox since "this sentence is false")
22:31:35 <thang1> wtf is that ~ thing
22:31:45 <jle`> thang1: it's a lazy pattern match
22:31:49 <SrPx> Hey guys, got a new mac and want to install Haskell on it, any up-to-date tutorial on what exactly I should do to avoid doom? Last time I checked I shouldn't use brew, etc. so yea
22:31:52 <thang1> ahh got it
22:31:53 <monochrom> irrefutable pattern. decreases strictness.
22:32:09 <jle`> hopefully that's enough keywords for help in googling further :)
22:32:37 <pacak> thang1: Is that in type signature or in pattern match?
22:32:43 <monochrom> SrPx: Will you like "Haskell for Mac"?
22:32:47 <jle`> SrPx: 'use stack' is a common very-hard-to-mess-things-up kind of advice that people throw around a lot these days
22:33:01 <thang1> Stack is amazing :p
22:33:25 <thang1> pacak: what do you mean?
22:33:31 <pacak> ~
22:33:40 <monochrom> pattern
22:33:46 <iqubic> ~ was in the pattern yeah.
22:33:48 <thang1> ooh, everyone else already answered the question lol
22:33:54 <monochrom> because I just showed ~v@(_:_)
22:33:55 <jle`> thang1: ~ is also reserved for haskell syntax in type signatures, as well
22:34:07 <jle`> a lot of haskell syntax tokens are hopelessly overloaded, heh
22:34:13 <SrPx> yea I mean stack was how I did it on my last mac, I guess it stays the norm then
22:34:19 <iqubic> What's its meaning there?
22:34:26 <monochrom> "Hi what does comma mean in Haskell?"
22:34:28 <jle`> it's a constraint for equality
22:34:46 <jle`> iqubic: so like how 'Num a' is a constraint that a is an instance of Num
22:34:51 <iqubic> monochrom: I think a comma is a data costructor for a tuple
22:34:52 <jle`> (a ~ b) is a constraint that a and b are the same type
22:35:03 <MarcelineVQ> thang1: I've found that toTitle x : xs useful enough that I often define a helper for it, mapFirst
22:35:04 <jle`> the pipe | is pretty overloaded
22:35:15 <jle`> but '->' is super overloaded
22:35:25 <jle`> so many completely unrelated usages of ->, heh
22:35:25 <monochrom> The other day someone asked "what does | mean in Haskell" and everyone was only able to recall 3 out of the 4 meanings/contexts.
22:36:02 <MarcelineVQ> > mapFirst toTitle "donkey"
22:36:04 <lambdabot>  "Donkey"
22:36:06 <monochrom> (And here I am wondering if it's 3 out of 5 actually. :) )
22:36:12 <iqubic> | is used in Guards
22:36:23 <iqubic> Where else is it used?
22:36:29 <vaibhavsagar> fundeps?
22:36:31 <thang1> MarcelineVQ: that's a good idea
22:36:33 <jle`> defining data types
22:36:40 <jle`> data Maybe a = Nothing | Just a
22:36:48 <iqubic> Also, is (->) the same as (<-)?
22:36:48 <nshepperd> hm. guards. fundeps. sum types
22:36:48 <monochrom> "data X = X | Y", guards, [ n | n <- [] ], fundeps
22:36:51 <MarcelineVQ> hmm.. guard, two similar ways comprehension, fundeps, quasiquotes, constructors
22:37:06 <jle`> injective type families is probably the same usage as fundeps
22:37:07 <pacak> iqubic: -> points the other way
22:37:23 <jle`> iqubic: -> and <- are both haskell syntax tokens, but they are used in different situations
22:37:24 <monochrom> Oh yeah quasiquoting. See, my fear has come true. :)
22:37:29 <iqubic> What are fundps and quasiquotes?
22:37:46 <jle`> iqubic: you can't interchange -> and <- in any situation
22:37:53 <MarcelineVQ> iqubic: stuff you shouldn't worry about quite yet but aren't bad things to ask about
22:38:05 <iqubic> Alright, I can think of a few different uses for (<-) already.
22:38:07 <rotaerk> what does this mean in haskell: *does a little dance*
22:38:08 <MarcelineVQ> But also readily answered by google
22:38:08 <nshepperd> iqubic: you can look them up on the haskell wiki
22:39:04 <nshepperd> rotaerk: that must be the dwim operator
22:39:13 <iqubic> Fundeps are weird
22:39:23 <jle`> monochrom: they're in multiway-ifs, too
22:39:27 <jle`> unles you count those as the same as guards
22:39:31 <monochrom> Yikes
22:39:33 <nshepperd> {-# LANGUAGE DoALittleDance #-}
22:39:41 <jle`> they are kinda the same as guards, so i wouldn't count it twice
22:39:45 <iqubic> I count those as guards, jle` 
22:39:45 <rotaerk> heh
22:39:57 <monochrom> I'll call it 5.1 then.
22:40:36 <nshepperd> you can also put | in an operator, but I guess that doesn't count
22:40:51 <monochrom> Right, let's stick to | as its own token.
22:40:59 <iqubic> Like .|. as bitwise or.
22:41:07 <iqubic> Yeah, let's not go there.
22:41:46 <jle`> yeah, talking about syntax tokens.  -> can be in operators too :)
22:42:02 <nshepperd> oh! injective type families
22:42:11 <nshepperd> although that's also a kind of fundep
22:42:36 <jle`> hm
22:42:42 <jle`> does it count in MINIMAL pragmas as syntax
22:43:00 <monochrom> God, what have I done? :)
22:43:22 <pacak> > let (<‚ò≠>) = fmap in show <‚ò≠> (Just 4)
22:43:24 <lambdabot>  Just "4"
22:43:26 <MarcelineVQ> haskell code obfuscation contests 2019, nothing but |
22:43:32 <Koterpillar> monochrom: https://xkcd.com/356/ ?
22:43:36 <vaibhavsagar> you knew this would happen monochrom :)
22:44:09 <monochrom> Yeah I just thought of nerd sniping too.
22:45:50 <jle`> > let (|||) (||||) = (||||) || (||||) in (|||) True 
22:45:52 <lambdabot>  True
22:46:15 <jle`> > let (|||) (||||) | (||||) = (||||) || (||||) | (|||) (||||) = (||||) in (|||) True 
22:46:17 <lambdabot>  True
22:46:33 <MarcelineVQ> everyone's full of beans tonight
22:47:50 <EvanR> did anyone ever solve that infinite resistor xkcd
22:48:02 <iqubic> No?
22:48:32 <Koterpillar> https://physics.stackexchange.com/questions/2072/on-this-infinite-grid-of-resistors-whats-the-equivalent-resistance
22:51:51 <EvanR> "apparently involves some 2D fourier analysis"
22:52:21 <thang1> Hmm, dumb question. Is Data.List.Split in the base or do I have to add it in Stack?
22:52:50 <cocreature> thang1: it‚Äôs in the "split" package
22:52:53 <cocreature> i.e. not in base
22:53:34 <jle`> you would have to add it to build-depends if you're in a project
22:53:36 <Lokathor> i considered for 10 moments that i could write a project in erlang
22:53:43 <Koterpillar> EvanR: there's a link to that in the SO answer, too
22:53:52 <EvanR> right
22:53:54 <Lokathor> but then i could not because i forgot how to write the program i wanted without a Maybe do-block
22:58:00 <iqubic> Does Erlang not have Mayve, or Monads?
22:58:30 <vaibhavsagar> not at the syntax level
22:58:47 <iqubic> What does that mean?
23:01:07 <EvanR> it does not
23:04:02 <Lokathor> iqubic, it means your function are always ugly to look at even when they work
23:05:05 <iqubic> Oh.
23:05:12 <iqubic> Sounds terrible
23:05:21 <Lokathor> :P
23:15:43 <vaibhavsagar> iqubic: Monads are (>>=) and pure/return, they can be implemented in any language with first-class functions
23:16:11 <vaibhavsagar> but IMHO do-notation is what makes them really excellent in Haskell
23:16:25 <vaibhavsagar> Erlang doesn't have do-notation
23:18:30 <Lokathor> oh yeah
23:18:43 <Lokathor> is there a top class guide to putting a package on hackage?
23:19:26 <vaibhavsagar> https://github.com/Gabriel439/slides/blob/master/bayhac2017/slides.md#publishing-to-hackage
23:19:37 <exio4> vaibhavsagar: type classes are quite a big reason for Monad(s) to exist, though
23:19:40 <vaibhavsagar> assumes stack though
23:19:48 <exio4> vaibhavsagar: as they allow you to write algorithms over any monad :)
23:19:56 <vaibhavsagar> exio4: you're absolutely right
23:20:08 <Lokathor> vaibhavsagar, what luck, i prefer stack over cabal :#
23:20:13 <Lokathor> :3 *
23:20:27 <vaibhavsagar> :)
23:21:32 <vaibhavsagar> exio4: you can have monads in a dynamically typed language though
23:22:21 <vaibhavsagar> I still think do-notation is the big draw here
23:22:50 <vaibhavsagar> in fact I wrote a blog post about this: http://vaibhavsagar.com/blog/2016/10/12/monad-anti-tutorial/
23:33:17 <Lokathor> vaibhavsagar, you should update your tutorial
23:33:55 <vaibhavsagar> with the Applicative constraint?
23:34:09 <vaibhavsagar> or the fact that neither Set nor Map are monads :)?
23:34:19 <Lokathor> the former
23:34:40 <vaibhavsagar> I don't think bringing Applicative into the picture is helpful here
23:34:51 <vaibhavsagar> and I do say it 'looks something like'
23:34:56 <Lokathor> After having gone through a series where Monad is taught only after teaching Functor and Applicative, I feel strongly that teaching Monad by itself is foolhardy at best
23:35:22 <vaibhavsagar> did you do the data61 course?
23:35:30 <vaibhavsagar> I completely agree btw
23:35:40 <Lokathor> no, the Haskell Programming From First Principles book
23:35:51 <vaibhavsagar> but I think of it more as a do notation tutorial rather than a Monad tutorial
23:36:05 <exio4> vaibhavsagar: it's really hard to have them in dynamically typed languages like in Haskell, as Haskell's type class rely heavily on types resolving ambiguity :P
23:36:21 <vaibhavsagar> it's good advice and I appreciate it :)
23:36:54 <vaibhavsagar> exio4: I increasingly feel that type classes are a way of doing principled duck typing
23:37:06 <vaibhavsagar> e.g. traverse, coerce, fmap
23:37:20 <exio4> vaibhavsagar: try to implement pure with `duck typing` =)
23:37:38 <vaibhavsagar> ha, well played
23:37:58 <vaibhavsagar> I think it's doable though
23:38:09 <_sras_> I am trying to implement a generic validation function for records (using Digestive functors). I am stuck here where I have to extract names a particular field using the generics type machinery. http://lpaste.net/355022
23:38:22 <Lokathor> "When I type read.show, GHC should just know what type I wanted it to give me back"
23:38:50 <vaibhavsagar> Lokathor: I had a question about doing this with newtypes and Aeson yesterday
23:39:12 <vaibhavsagar> https://github.com/vaibhavsagar/duffer/commit/6c6b78ee1e3c9e34e57468334fd364fecc42ff15
23:39:43 <vaibhavsagar> looking at it more closely I might even be able to get rid of the constructor at the end
23:39:50 <vaibhavsagar> duck typing for everyone!
23:41:00 <vaibhavsagar> and I realised `flip g <*> f` == `f >>= g` for functions just now, so I have to change that too
23:53:25 <matrium> Hi, I wrote a MTL-style function "renderGraph :: Rdf r => MonadReader (RDF r) m => MonadIO m => Map Node [(Node, Node)] -> [Node] -> m ()", but now I'm not quite sure how to construct the concrete monad instance to run the run the function in
23:57:00 <Lokathor> https://github.com/Lokathor/pcgen-hs/blob/master/src/Data/PCGen.hs does this all look about right? (before I upload to hackage that is)
