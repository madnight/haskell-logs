00:00:22 <cocreature> tsahyt: is that an endofunctor on the general category of food or only on some subcategory?
00:00:29 <Theophane> cocreature: yeah can't really eat right now, I'm an amphitheatre
00:00:40 <Theophane> tsahyt: tell me more about this :P
00:00:51 <Theophane> With your most sophisticated french accent!
00:02:32 <MarcelineVQ> le crêpe aux tumeric
00:02:42 <Theophane> :')
00:03:32 <cocreature> Theophane: are you _at_ an amphitheatre or are you an amphitheatre yourself? I didn’t know amphitheatres could talk :)
00:03:38 <rightfold> It's time to get up and work
00:04:30 <tsahyt> cocreature: I guess it maps only to the subcategory of food that is wrapped in a tortilla
00:04:41 <Theophane> cocreature: :') sorry, I'm at one
00:05:04 <orion> rightfold: Interesting. Do you know of any examples?
00:05:16 <cocreature> tsahyt: but I guess there is no restriction on its domain?
00:05:24 <tsahyt> no, anything can be wrapped in a tortilla
00:05:27 <cocreature> nice
00:05:44 <tsahyt> given a sufficiently strong press, you can also merge tortillas, so you get T (T a) -> T a
00:07:29 <Theophane> did you folks read Aphyr's "Typing the technical interview"? =)
00:08:48 <tsahyt> was that the one that solved n-queens on the type level?
00:09:16 <rightfold> orion: e.g. lmap fromInteger, to convert AST Integer next to AST Double next
00:09:52 <Theophane> tsahyt: Y E S 
00:09:54 <rightfold> I think GHC doesn't support Bifunctor deriving yet
00:09:56 <Theophane> :D
00:10:02 <tsahyt> that was quite nice
00:11:20 <tsahyt> not too surprising that it's possible, given that this is a thing: http://hackage.haskell.org/package/register-machine-typelevel
00:11:40 <cocreature> rightfold: now I want bifunctor deriving
00:11:59 <orion> rightfold: I see. Would I have to put a Bifunctor constraint anywhere?
00:12:04 <rightfold> No
00:12:19 <orion> Interesting.
00:12:20 <cocreature> not even generic-deriving seems to support bifunctor
00:12:43 <cocreature> seems like I’ll need to write that myself :)
00:12:53 <cocreature> ah no https://hackage.haskell.org/package/bifunctors-5.4.1/docs/Data-Bifunctor-TH.html#v:deriveBifunctor
00:14:15 <rightfold> Add Contravariant and Profunctor deriving while you're at it
00:14:37 <rightfold> Derive everything
00:15:28 <cocreature> I use contravariant and profunctor a lot less than I use bifunctor so I don’t care too much about this :)
00:18:57 <tsahyt> Idris has this concept of decidable predicates. Is this even possible in Haskell? e.g. data Dec (p :: Type) :: Type where { Yes :: p -> Dec p; No :: (p -> Void) -> Dec p }
00:19:07 <tsahyt> the yes part is pretty trivial, it's the No part that I can't figure out
00:19:27 <tsahyt> in Idris you can use impossible to denote that a pattern cannot ever be matched
00:19:52 <tsahyt> now GHC does have this inaccessible code analysis for GADTs at least since the GADTs meet their match paper. so I was wondering whether I could leverage that somehow
00:20:12 <tsahyt> the concrete use case here is to decide that a size indexed structure is empty or non-empty
00:20:36 <tsahyt> and if it's non-empty, ideally refine it's index n via n ~ m + 1, although the quantification of m might be another problem entirely
00:20:47 <tsahyt> otherwise, at least bring a 1 <= n constraint into scope
00:37:27 <xormor> I have learned some Haskell! :-)
00:38:09 <xormor> I like it as much as I like C and C++, and it is more handy in mathematics than C and C++. Assembly is best for creating machine dependent quick, small programs but Haskell is super for math.
00:47:24 <halogenandtoast> Haskell is super for many things
00:47:27 <halogenandtoast> not just math
00:48:12 <hc> haskell is super for generating assembly code for machine dependent quick, small programs ;-)
00:50:20 <jle`> haskell is my favorite way to generate assembly code
00:56:35 <xormor> jle`, wow! how is that possible?
00:56:49 <xormor> jle`, how do I create assembly code with haskell?
00:57:00 <jle`> sorry by assembly code i really meant bytecode
00:57:12 <xormor> hc, how?
00:57:17 <xormor> jle`, I see...
00:57:41 <xormor> jle`, so is the bytecode runnable in GNU/Linux, MS-DOS (DosBox) or Windows (WINE)?
00:57:54 <jle`> whatever you want :o
00:57:57 <jle`> there are many backends
00:57:59 <xormor> great
00:58:29 <xormor> I want to do it. The last time I was this excited about a programming language was in the 1990's when I learned C and C++.
01:04:21 <rightfold> GHC can generate machine code
01:04:27 <rightfold> You don't have to use the bytecode interpreter
01:06:02 <hc> xormor: ivory, for example
01:06:35 <hc> xormor: http://hackage.haskell.org/package/ivory
01:17:51 <Guest34989> guys
01:17:56 <Guest34989> whats the best language
01:18:01 <tsahyt> maths
01:18:14 <Philonous> icelandic 
01:18:54 <Guest34989> programming language
01:19:12 <Guest34989> that is
01:19:20 <hc> does neurolinguistic programming count as programming to you? ;)
01:20:01 <Guest34989> hc: shove it into /dev/null
01:20:42 <TheLemonMan> best language for doing what?
01:20:44 <xormor> Guest34989, I like: C, C++, Haskell (that I have newly learned), and amd64 and x86 assembly languages.
01:20:44 <Gurkenglas_> Can I have stack let import statements just work without me specifying what packages they came from?
01:21:12 <xormor> Guest34989, Turbo Pascal was a good language in the 1980's and BASIC in the 1980's.
01:21:31 <xormor> Guest34989, Turbo Pascal in the '90's I meant.
01:21:33 <geekosaur> Gurkenglas_, since stack is specifically a repeatable builds tool, I doubt it
01:22:07 <Guest34989> TheLemonMan: general purpose
01:22:23 <TheLemonMan> Guest34989, there's no silver bullet
01:22:36 <tsahyt> is either (const Nothing) Just :: Either a b -> Maybe b already defined somewhere?
01:23:09 <tsahyt> @hoogle Either a b -> Maybe b
01:23:09 <lambdabot> Data.Either.Combinators leftToMaybe :: Either a b -> Maybe a
01:23:10 <lambdabot> Agda.Utils.Either maybeLeft :: Either a b -> Maybe a
01:23:10 <lambdabot> Music.Theory.Either fromLeft :: Either a b -> Maybe a
01:23:10 <xormor> Guest34989, try C, C++ or Haskell. or even Java or JavaScript for web programming.
01:25:41 <Guest34989> why does haskell io need iomonad
01:27:05 <Guest34989> iomonad: no offense
01:28:33 <TheLemonMan> Guest34989, https://wiki.haskell.org/IO_inside
01:29:10 <Guest34989> looks nasty
01:29:26 <ongy> stack does repeatable builds? as in hash equivalent builds?
01:30:21 <ongy> the way IO is handled looks really annoying until you understand it and use it for some time. Then it feels pretty good. At least that's how it went for me
01:30:38 <tsahyt> Guest34989: you could do IO without monads too. Haskell predates its own use of Monads.
01:30:41 <Gurkenglas_> Can I let System.Eval.Haskell's eval import modules that didn't exist at compile time?
01:30:49 <tsahyt> it just turns out that monads are a very nice abstraction to handle IO
01:32:52 <John[Lisbeth]> is a monad a way of representing mutability in a purely functional way?
01:33:22 <tsahyt> John[Lisbeth]: monads can be used to model mutable state
01:33:47 <John[Lisbeth]> can you model mutable state in a purely functional way without monads?
01:34:46 <tsahyt> I'm pretty sure you could use continuations instead, but I've never looked into that
01:35:23 <tsahyt> mutable state in general can be modeled adequately through functions that take a state and return a state (in addition to whatever else they return), e.g. s -> (s, a) for some state type s
01:35:39 <tsahyt> what monads bring to the table is an elegant way of working with those functions
01:42:49 <markus1209> to test my understanding: are type constructors not surjective because we go from Type -> Type and all of the right hand side Type are Maybe xyz, therefore e.g. Int is not in the codomain for Maybe
01:43:14 <Heffalump> anyone know where the source of ghc 8.2.1 rc1 is? I'm getting 404 errors from the links at https://downloads.haskell.org/~ghc/8.2.1-rc1/
01:43:50 <markus1209> * if we take the Maybe type constructor as an example
01:47:05 <tsahyt> markus1209: sounds about right. for Type -> Type to be surjective, you'd need an input for all outputs.
01:48:42 <tsahyt> but as you said, Maybe only maps to a subset of all possible types. by virtue of being a functor, the image of Maybe is a subcategory of Hask unless I'm much mistaken
01:48:50 <tsahyt> and it's a proper subcategory
01:50:57 <tsahyt> type constructors should be injective though. given T a ~ T b, you should be able to deduce that a ~ b. this is not true for type families.
01:51:03 <tsahyt> or even type synonyms I think.
01:56:28 <Gurkenglas_> Is "#!/usr/bin/env stack" why all my error line numbers seem to be off by one?
01:56:37 <NikolajK> Why is 
01:56:37 <NikolajK> Type : Type 1 while (Type, Type) : (Type 1, Type 1). 
01:56:38 <NikolajK> Not sure if that's the right place for Idris, but the response times there are longer than my online times.
01:56:46 <NikolajK> not*
01:57:02 <NikolajK> (Type, Type) : (Type, Type) says the interactive enviroment, and I don't get it
01:57:20 <tsahyt> NikolajK: I've also been unable to get Type 1 : Type 2, so there's that
01:57:49 <NikolajK> I can stomache that, if we think of code being in Type and the rest is meta
01:59:13 <markus1209> tsahyt: thanks ;)
02:02:47 <Gurkenglas_> (Never mind, I didn't recompile the file after deleting the line.)
02:22:54 <cow_2001> woah! an israeli asked an haskell question! :D https://stackoverflow.com/questions/43347582/permission-denied-when-reading-from-clipboard
02:23:48 <John[Lisbeth]> A monad can be a function true or false?
02:24:18 <TheLemonMan> it is an algebric structure, so no
02:24:29 <Philonous> (-> r) is a Monad 
02:24:42 <Philonous> ((->) r) I mean
02:24:45 <John[Lisbeth]> it is impossible to create a function that is a monad?
02:25:12 <Philonous> John[Lisbeth], Monads have kind * -> *, functions have kind *, so no. 
02:25:27 <Philonous> I mean yes, it's impossible 
02:25:43 <John[Lisbeth]> Can a monad have a name?
02:26:04 <TheLemonMan> of course
02:26:15 <John[Lisbeth]> can you name a monad f and can you name a monad g ?
02:26:29 <rightfold> "The I/O monad", "the maybe monad", "the list monad"
02:26:39 <Guest34989> sure it's called a monad
02:27:03 <John[Lisbeth]> Can you apply a monad f to a monad g?
02:27:19 <TheLemonMan> those questions sound a lot like homework
02:27:26 <John[Lisbeth]> I am self taught
02:27:27 <megaTherion> yeah he is working his sheet off
02:27:34 <megaTherion> ...and you guys fall for it :D
02:27:36 <rightfold> Technically when you say "the X monad", it means "the Monad (X ...) instance", but it may refer to "X" itself in everyday speak
02:27:53 <John[Lisbeth]> I am simply asking logical questions which I think are most likely to help me figur eout what a monad is
02:29:09 <TheLemonMan> you can compose monads, applying monads make little or no sense
02:29:38 <rightfold> Composing monads doesn't always give a monad
02:29:59 <John[Lisbeth]> I can name a function f and I can name a function g and I can say f(g)=c. But can I similarly have a monad named t and a monad named p and say t(p)=g AND p(t)=g ? Is that what makes them different?
02:29:59 <rightfold> `newtype Compose f g a = Compose (f (g a))` has no `(Monad f, Monad g) => Monad (Compose f g)` instance
02:30:21 <rightfold> It has an `Applicative` instance though
02:30:28 <TheLemonMan> yeah, I'm not well versed in the monad algebra
02:30:53 <John[Lisbeth]> For a monad f and a monad g is it always true that g(f) = f(g) ?
02:31:39 <rightfold> Which is useful for, for example effectful validation. `Compose IO (AccValidation e)`
02:31:51 <Athas> Uh, in Haskell it is unlikely that you can apply a monad to another, unless it is a transformer.
02:32:16 <Philonous> It's not unlikely, it's impossible. The kinds don't match
02:32:25 <Athas> Yeah, you're right.
02:35:32 <rightfold> Impossibly implies unlikely :)
02:35:58 <Philonous> Fair enough ;)
02:48:47 <John[Lisbeth]> a monad is a function that takes a function and binds it to another function
02:50:02 <Philonous> That's not true. A Monad (in Haskell) is a data type that implements a certain type class. 
02:50:08 <tsahyt> TheLemonMan: the fact that monads don't compose in general is why we have monad transformers
02:51:38 <John[Lisbeth]> if monads don't compose then what do they do
02:53:01 <tsahyt> they provide (>>=). anything for which you can define (>>=) and return (but that's also in Applicative) such that it obeys a set of laws is a monad
02:53:12 <tsahyt> the same goes for join, which is an alternative way to define monads
02:53:17 <tsahyt> but not the one used in haskell
02:54:41 <John[Lisbeth]> bind is a function that takes a monad and takes a function which returns a value that is a monad
02:55:19 <tsahyt> :t (>>=)
02:55:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:56:15 <tsahyt> kinda sorta, although "takes a monad" and "value that is a monad" sound very off. you can think of 'm a' as a value in a monad, but really it's the image of a under the functor m.
02:56:41 <tsahyt> :k Maybe
02:56:42 <lambdabot> * -> *
02:56:57 <tsahyt> as an example, note that Maybe takes a type to another type
02:57:25 <John[Lisbeth]> :t Monad
02:57:26 <lambdabot> error: Data constructor not in scope: Monad
02:57:27 <tsahyt> Maybe Int is a type in its own right. it's the image of Int under Maybe.
02:57:46 <tsahyt> and Maybe is a functor. it's also an instance of the Monad class, so (>>=) is defined on it
02:58:05 <tsahyt> for Maybe, you'd get (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b.
02:58:24 <Athas> :info Monad
02:58:28 <tsahyt> Athas: lambdabot doesn't do info
02:58:32 <Athas> Too bad.
02:58:35 <tsahyt> it'd spam the channel I think
02:58:56 <rightfold> Monad exists because it has both many instances and many use cases. It is no more special than other interfaces that have these two properties, such as Ord.
02:59:03 <tsahyt> John[Lisbeth]: for Maybe in particular, using join for construction provides better insight imo
02:59:09 <tsahyt> join :: Maybe (Maybe a) -> Maybe a
02:59:46 * geekosaur prefers lists for that, because there's a fairly obvious mapping map <-> fmap, concat <-> join
02:59:53 <seequ_> > Maybe 5 >>= \x -> Maybe (2 * x)
02:59:55 <lambdabot>  error:
02:59:56 <lambdabot>      • Data constructor not in scope: Maybe :: Integer -> m Integer
02:59:56 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)error:
03:00:09 <seequ_> whoops
03:00:25 <seequ_> > Just 5 >>= \x -> Just (2 * x)
03:00:27 <lambdabot>  Just 10
03:00:32 <tsahyt> :t \x f -> join (fmap f x)
03:00:33 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
03:01:00 <halogenandtoast> > (*) <$> Just 5 <*> Just 2
03:01:02 <lambdabot>  Just 10
03:01:08 <halogenandtoast> (* 2) <$> Just 5
03:01:15 <halogenandtoast> > (* 2) <$> Just 5
03:01:17 <lambdabot>  Just 10
03:02:36 <tsahyt> find (> 4) <$> Just [1..10]
03:02:43 <tsahyt> > find (> 4) <$> Just [1..10]
03:02:45 <lambdabot>  Just (Just 5)
03:02:51 <halogenandtoast> lol
03:03:06 <tsahyt> > join (find (> 4) <$> Just [1..10])
03:03:08 <lambdabot>  Just 5
03:03:25 <seequ_> > Just [1..10] >>= find (> 4)
03:03:28 <lambdabot>  Just 5
03:03:50 <Athas> So, what happens if I have a type with more than two type parameters, so I cannot use Bifunctor?
03:04:20 <tsahyt> Athas: do you want to be able to map over all of them?
03:04:40 <rightfold> Athas: Trifunctor
03:05:11 <Athas> rightfold: when does it stop?
03:05:35 <Athas> I don't actually have this problem right now, but I was wondering.
03:05:37 <tsahyt> I'm not sure there even is a Trifunctor class
03:05:38 <rightfold> Whenever you need
03:05:50 <tsahyt> but there's a library for generating fmap etc for functors of any arity
03:05:53 <tsahyt> http://hackage.haskell.org/package/genifunctors
03:06:00 <rightfold> tsahyt: It conceptually does, at least
03:06:09 <tsahyt> rightfold: yes, but I've never seen one in Haskell
03:06:15 <rightfold> Same
03:06:16 <tsahyt> nor did I ever need one. I hardly ever need Bifunctors either
03:06:32 <Athas> There is one on Hackage, but it's kind of obscure.
03:06:39 <rightfold> There's Clown and Joker to lift Functor to Bifunctor
03:07:02 <tsahyt> the only time I needed Bi{functor,traversable,foldable} was when dealing with a large AST type that was parameterized over its symbol and signature type, so I could register the data with a C lib before passing it, and still construct the AST in pure code before.
03:07:17 <Gurkenglas_> Athas, I think the general case is adressed by lens
03:07:28 <tsahyt> the answer is always lens
03:07:34 <Athas> Probably.  Well, I'll deal with those type errors when I get there.
03:08:08 <rightfold> tsahyt: I just used lmap on an either
03:08:27 <tsahyt> I hardly ever use Either either.
03:08:28 <Athas> I'm only just now adding Bitraversable instances to my project instead of having tons of boilerplate for AST traversal.
03:08:34 <Athas> We'll see whether it works well!
03:08:35 <rightfold> tsahyt: :)
03:08:48 <tsahyt> and when I do, I do it for composability of error conditions. and once you lmap on it, you're now in a different monad
03:08:50 <rightfold> ExceptT with newtype unwrap
03:08:55 <tsahyt> which makes composition a bit harder
03:09:08 <tsahyt> although I just used it for a hacky existential
03:09:30 <tsahyt> https://github.com/tsahyt/indexed-set/blob/master/src/Data/Set/Indexed.hs#L249
03:09:44 <rightfold> I needed a natural transformation Either String ~> Either Error
03:10:06 <tsahyt> yes, that sounds like lmap
03:11:27 <tsahyt> so I spent a few hours wrapping most of Data.Set into this cardinality indexed set type, and now I forgot what I actually wanted to do with it
03:11:47 <tsahyt> I'm still not sure whether it's even remotely usable, since a lot of it requires existentials
03:13:00 <tsahyt> I guess the most useful part of it may turn out to be the index based access, because that's now type safe. but probably also a pain to use.
03:14:01 <rightfold> tsahyt: very cool
03:14:26 <rightfold> Like singleton :: a -> Set '1 a?
03:14:50 <rightfold> Oh I see the GH link now
03:15:22 <tsahyt> rightfold: yes it provides that
03:15:28 <tsahyt> but the problem is with functions like union
03:15:48 <tsahyt> there's no way to deduce the cardinality of the output purely by that of the inputs
03:15:56 <tsahyt> the best I can do is provide bounds, but I'm not sure that's even useful at all
03:16:57 <tsahyt> to give a definitive answer, I'd either need to inspect the sets at type level, which is somewhere between impossible and massive pita, or at least a proper dependent pair return type
03:17:46 <tsahyt> I also lose some instances, because mappend :: Set 1 a -> Set 1 a -> Set 1 a doesn't make any sense at all
03:17:52 <tsahyt> same for semigroup of course
03:18:21 <rightfold> tsahyt: how efficient (compile time wise) are these type level nats?
03:18:36 <tsahyt> I've never noticed them making much a difference in terms of compile times
03:18:42 <rightfold> Nice!
03:18:55 <tsahyt> GHC doesn't treat them as inductively defined
03:19:08 <tsahyt> and indeed they actually aren't, which makes it harder to write inductive proofs with them
03:19:11 <tsahyt> compared to say Nat in idris
03:19:14 <rightfold> We use type level nats in PureScript and it's kinda slow
03:19:30 <tsahyt> defined as Nat = Z | S Nat?
03:19:32 <rightfold> Also reifying to value level is O(n) which is lame
03:19:53 <rightfold> Well as data Z :: Type and data S :: Type -> Type
03:20:05 <tsahyt> reification to the value level for TypeLits should be O(1), but it depends on passing the KnownNat dictionary around, so I think there might still be some overhead
03:20:06 <rightfold> Then type classes for functions 🤓
03:20:51 <rightfold> Haskell's DataKinds are better
03:21:06 <tsahyt> they're currently just not extremely useful yet
03:21:21 <tsahyt> with -XDependentHaskell or whatever it will end up being called they should become much more useful I think
03:21:37 <tsahyt> but so far we've at least gotten a nice length indexed vector library out of them, as well as servant.
03:21:47 <tsahyt> and many hours of "why won't you compile" for me
03:21:50 <rightfold> :3
03:22:59 <tsahyt> which is why you'll see in this library that I either don't bother at all, since the ISet constructor will readily construct me sets of *any* cardinality I tell it to, or use some unsafe trickery to provide constraints for the bounds etc
03:23:59 <tsahyt> the former works mostly because there's no connection between the type level nat and the actual value. it's a phantom parameter.
03:25:34 <Gurkenglas_> Do I have to use zoom to get the full power of %%~ in =-land?
03:34:20 <Gurkenglas_> ie what should I write instead of "l %%= maybe (empty :: MaybeT (StateT S M) ())  pure . f"?
03:36:27 <LuciusVorenus> Haskell seems quite mathematical.
03:36:49 <LuciusVorenus> How do I learn it properly without being a math expert?
03:37:00 <Athas> You just treat it as a programming language.
03:37:01 <mauke> uh, just write code
03:37:24 <Athas> Only some libraries are described in mathematical terms.  Most are just like libraries in any other language.
03:37:47 <Athas> You just have to treat names like 'Monad' and 'Functor' as APIs, rather than worry about how they map to mathematical concepts.
03:41:22 <tsahyt> is there a deeper reason behind idris being strict by default than "that's what we wanted"?
03:41:39 <rightfold> tsahyt: ease of implementation
03:41:56 <tsahyt> I still count that as "that's what we wanted"
03:42:01 <Athas> SPJ says that the next Haskell will be strict, so maybe that's why!
03:42:10 <rightfold> Then no
03:42:11 <tsahyt> Athas: then I'll stick to the current one, as much as I respect spj
03:42:19 <Athas> To fulfil the prophecy.
03:45:40 <tsahyt> Athas: I think it's very very unlikely that Haskell itself will become a strict-by-default language. Laziness is part of the reason why Haskell exists in the first place. it was meant as a research language for purely functional languages with lazy evaluation semantics.
03:45:59 <Athas> tsahyt: right, he was talking about the successor of Haskell.
03:46:02 <Rodenbach> http://learnyouahaskell.com/for-a-few-monads-more#state shows an example of how to use the state monad. One such snippet is:   pop = State $ \(x:xs) -> (x,xs)      – Haskell (Intero) complains here and asks me if I mean StateT.   Was something renamed since the book was written?
03:46:11 <Athas> And I think he actually said that it would be strict *by default*, but still support laziness.
03:46:42 <Athas> I don't think this is a controversial POV.  Most people seem to think that some form of parametric strictness will be developed (so a function can be polymorphic in evaluation order).
03:46:42 <tsahyt> I prefer the opposite
03:47:16 <rightfold> Rodenbach: "State s a" is a type alias for "StateT s Identity a"
03:47:24 <rightfold> And StateT is a data constructor of StateT
03:47:56 <Rodenbach> I do  `import Control.Monad.State`  and it tells me that `State` is not in scope.
03:48:08 <rightfold> The State type or the State constructor?
03:48:29 <rightfold> Maybe that book was written for an older version of the library.
03:48:58 <Rodenbach> rightfold: yes, I think Learn you a Haskell was written in 2011.
03:49:09 <tsahyt> Athas: many people seem to prefer strictness by default, but I've found laziness to be much less of a pain than strictness. I'd rather place a few strictness annotations around my code than litter everything with laziness annotations such that I have to care less.
03:49:30 <shane> Rodenbach: you probably want just: state
03:49:32 <tsahyt> which is really the point. I use haskell because I acknowledge my own ineptness.
03:49:33 <Rodenbach> The book suggests to import Control.Monad.State and then use the State data constructor.
03:49:39 <tsahyt> laziness allows me to be more lazy most of the time, so to speak
03:49:39 <rightfold> So you probably want something like "pop = StateT $ \(x : xs) -> pure (x, xs)"
03:49:43 <shane> instead of State
03:49:48 <rightfold> Ah yeah, "state"
03:49:51 <shane> State is only a type alias
03:50:41 <shane> whereas state is StateT specialized to the identity monad
03:50:42 <tsahyt> e.g. the way I can just dump things out into where bindings, order them in any way I please, etc.
03:51:12 <tsahyt> Athas: relevant edwardk post https://www.reddit.com/r/haskell/comments/5xge0v/today_i_used_laziness_for/deia53t/
03:53:48 <shane> Rodenbach: pop = state $ \(x:xs) -> (x, xs) should also work
03:53:59 <Rodenbach> Good, thanks.
03:54:01 <Rodenbach> Yes, works.
04:03:03 <Gurkenglas_> Does System.Eval.Haskell work nowadays? These two machines throw "user error (Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times).)" as a response to 'eval "2+2" []'. (What package do I use for eval?)
04:05:54 <GreySunshine> Hello guys, Is there an irc channel or mailing list for emacs's haskell-mode. I could not find anything here (https://wiki.haskell.org/IRC_channel#Related_channels) and the link here is broken (http://projects.haskell.org/haskellmode-emacs/)
04:08:08 <bollu> jle`: ping
04:11:03 <Philonous> GreySunshine, #haskell-emacs
04:11:41 <geekosaur> GreySunshine, projects.haskell.org is the graveyyard, that list shut down in mid-2016
04:12:04 <geekosaur> https://github.com/haskell/haskell-mode might be of interest
04:12:39 <geekosaur> although I see it hs a mailing list link that points to the same graveyard :/
04:13:19 <geekosaur> I wonder if anyone told them projects.h.o is going away and everything formerly on it is in archive mode
04:37:42 <magneticduck> suppose I wanted to make a datatype representing a process to enumerate values of a type a
04:38:03 <magneticduck> a first try would be "data Enumeration a = Enumeration Integer (Integer -> a)"
04:38:54 <magneticduck> but it would be nice if Enumeration could be Monad-like -- so perhaps I won't always know the length of the enumeration before-hand
04:39:23 <magneticduck> and some things are hard to enumerate, so I'd like to use a state machine: so I try "data Enumeration s a = Enumeration s (s -> Maybe s) (s -> a)"
04:40:15 <magneticduck> but this free "s" type isn't important for anything besides the implementation, and it sort of gets in the way 
04:41:24 <magneticduck> maybe I'd try "data Enumeration a = Enumeration STATE (STATE -> Maybe STATE) (STATE -> a)" ... but it's inconvenient to have to choose some beforehand "STATE" for all my different enumeration-generating state machines to use
04:41:53 <magneticduck> what can I do?
04:42:34 <Philonous> Why not just [a] ?
04:42:53 <magneticduck> how would you instance Functor or Monad?
04:43:06 <tsahyt> [] is already a functor and a monad
04:43:26 <magneticduck> oh I misunderstood
04:45:59 <magneticduck> lol
04:47:31 <Philonous> > let fromState s0 nextS fromS = let go s = fromS s : (case nextS s of Nothing -> []; Just s' -> go s') in go s0
04:47:33 <lambdabot>  <no location info>: error:
04:47:33 <lambdabot>      not an expression: ‘let fromState s0 nextS fromS = let go s = fromS s : ...
04:47:40 <Philonous> > fromState s0 nextS fromS = let go s = fromS s : (case nextS s of Nothing -> []; Just s' -> go s') in go s0
04:47:42 <lambdabot>  <hint>:1:26: error:
04:47:42 <lambdabot>      parse error on input ‘=’
04:47:42 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
04:48:07 <magneticduck> yes, I see
04:48:33 <magneticduck> apparently I was trying to implement a lazy Haskell list without lazy Haskell lists
04:49:07 <hodapp> ML is that way, sir
04:50:31 <magneticduck> hm?
04:52:12 <lush> is someone here that knows ContourTrees and may skim a little bit of code to tell me what's wrong about it? :-D
04:57:03 <FALANXXX> in haskell, what does it stand for? the variable i mean
04:57:07 <FALANXXX> 'it'
04:57:48 <magneticduck> "it" is a clever encoding of the word "it"
04:58:03 <FALANXXX> lol i thought it would be an abbreviation
04:58:30 <FALANXXX> something like 'last' would have been more verbose
04:59:16 <magneticduck> theThing
04:59:41 <lyxia> in ghci it refers to the previous value
05:00:06 <lyxia> it doesn't mean anything in particular outside ghci, it is just a variable
05:12:08 <lush> any computational topologists here?
05:12:49 <inkbottle> I read '$' is a kind of parenthesis; however "return 3 >>= $ \x -> [x]" raises a parse error.
05:13:01 <FALANXXX> Okay I get lazy evaluation but can anyone explain this: let x = 1, bindings will show it's bound to _ (not evaluated yet). but even after i evaluate it by typing x in ghci, it remains being bound to _. Am I missing something?
05:13:26 <Philonous> inkbottle, ($) is a normal function. It's defined as f $ x = f x 
05:13:28 <hpc> inkbottle: ($) is an operator with low precedence, not a syntactic substitute
05:13:39 <hpc> it has to appear where operators are legal
05:13:40 <Philonous> inkbottle, It can replace parens because of it's precedence
05:13:54 <inkbottle> OK
05:14:00 <inkbottle> thx
05:14:22 <FALANXXX> also even it seems to be bound to _.... weird
05:14:50 <FALANXXX> i mean 'it' is bound to _ even after evaluation
05:18:36 <alem0lars> is there a commandline arguments parser library that can be used to automatically generate autocomplete functions for known shells (like zsh) ?
05:19:24 <FALANXXX> Okay I get lazy evaluation but can anyone explain this: let x = 1, bindings will show it's bound to _ (not evaluated yet). but even after i evaluate it by typing x in ghci, it remains being bound to _. Am I missing something?
05:20:04 <lyxia> FALANXXX: x is going to be polymorphic, of type Num a => a
05:20:08 <hexagoxel> FALANXXX: _ does not mean "not evaluated yet".
05:21:07 <FALANXXX> What else does it mean? That was my best bet
05:21:07 <lyxia> every time you use it, a is newly instantiated, and you get a thunk.
05:21:53 <FALANXXX> i would just assume x to be bound after i assign it a value and use it
05:23:22 <hexagoxel> FALANXXX: maybe _ is used to signify a polymorphic value, that, due to being polymorphic, has no better representation.
05:24:24 <FALANXXX> hexagoxel: that might be. it just seems to be super counterintuitive to make all variable declarations being polymorphic... basically negates the use of bindings
05:24:35 * hexagoxel never knew that :show bindings can indeed return information about a chunk being evaluated or not, interesting.
05:25:47 <lyxia> FALANXXX: are you perhaps using :sprint, try :sprint
05:26:53 <lyxia> FALANXXX: Also making all bindings polymorphic by default is also a specificity of GHCi which has -XNoMonomorphismRestriction by default, whereas ghc doesn't.
05:26:54 <FALANXXX> lyxia: what do you mean, im in ghci i dont verbosely print
05:26:55 <hexagoxel> wait, after i `:set -XMonomorphismRestriction` the behaviour with let is different? i thought that was the default.
05:27:39 <FALANXXX> basically i assign x = 1 and afterwards just enter x which assumingly evaluates x
05:27:40 <lyxia> FALANXXX: :print with a colon in front is a ghci command to show a value without forcing it
05:28:00 <lyxia> and you get _ ?
05:28:44 <lyxia> I get 1.
05:29:14 <FALANXXX> https://codepaste.net/fgpf9m
05:29:20 <FALANXXX> Take a look at it
05:29:28 <OnkelTem> Hi all
05:30:19 <OnkelTem> I'm trying to use official docker image of Haskell but I can't compile examples from there. I get the same output as in this [not resolved] issue: https://github.com/freebroccolo/docker-haskell/issues/53
05:30:22 <lyxia> It is what I said, x being polymorphic with a Num constraint you can't force it further without specializing it first
05:30:26 <OnkelTem> Any ideas what's wrong?
05:30:29 <lyxia> which results in a new value
05:31:31 <OnkelTem> https://github.com/freebroccolo/docker-haskell/tree/master/examples/7.10/snap - here is the source
05:32:29 <hexagoxel> FALANXXX: maybe you want to `:set -XMonomorphismRestriction` to get monomorphic let-binds by default.
05:33:27 <hexagoxel> and _ apparently can mean both "unevaluated" and "unevaluated due to being polymorphic", which may be confusing.
05:33:57 <FALANXXX> hexagoxel: that is confusing indeed! so when i try thing outside of ghci it should work tho?
05:34:31 <lyxia> because under the hood x :: Num a => a is actually a function
05:34:39 <hexagoxel> ^
05:35:15 <hexagoxel> when you sprint, it defaults, i.e. automatically passes in the Num a dict. but the value returned is still a new thunk every time you do that.
05:35:49 <hexagoxel> which is unevaluated, even if you have forced a value previously returned from that "function".
05:36:47 <hexagoxel> you get better behaviour by either setting mmr, which makes it monomorphic by default, or by giving `x` a type signature and making it monomorphic that way.
05:36:53 <hexagoxel> i.e. let x = 1 :: Int
05:37:24 <hexagoxel> with that definition, the behaviour is what one would expect normally.
05:37:54 <FALANXXX> hexagoxel: thanks for the type signature i was wondering all the time how you can use these in ghci
05:38:13 <lyxia> alem0lars: optparse-applicative has a Completer module, I have no idea what it's worth.
05:38:36 <FALANXXX> can confirm it works
05:40:55 <hexagoxel> FALANXXX: regarding difference between ghci/ghc: i think MMR is on by default in ghc, so i think it will be less likely to run into unexpected cases of non-sharing.
05:41:39 <hexagoxel> outside of ghci that is.
05:44:16 <laz> alem0lars: https://github.com/pcapriotti/optparse-applicative#bash-completion
06:00:11 <ysahil> In Haskell, can we use one do inside another do?
06:01:08 <hexagoxel> > do do do True
06:01:10 <lambdabot>  True
06:05:30 <mmo> Could somebody please help with creating a Gtk GUI window from an XML file? I have managed to create the XML read it with a builder and grab the mainWindow Object. However the type of the mainWindow seems to be to general to do anything with it. I have no idea how to preceed as I can't find any documentation or tutorial on this. I have the following code:
06:05:30 <mmo> https://github.com/marcelmoosbrugger/hsudoku/blob/master/src/Hsudoku.hs
06:09:31 <mmo> The window can be grabbed with "Gtk.builderGetObject" but somehow not be converted to a Window with "Gtk.toWindow"
06:14:37 <hexagoxel> mmo: with gtk3, there is a `castToWindow` method; with gi-gtk i see GI.Gtk.castTo but it lacks docs..
06:16:20 <mmo> @hexagoxel: Ok thanks. I'll have a look at it. But what is the intention of "GI.Gtk.Objects.Window.toWindow" then?
06:16:20 <lambdabot> Unknown command, try @list
06:18:08 <mmo> hexagoxel: Ok thanks. I'll have a look at it. But what is the intention of "GI.Gtk.Objects.Window.toWindow" then?
06:18:22 <hexagoxel> mmo: upcasting from stuff like Dialog, Window, or Assistant, perhaps (in the gtk heirarchy.
06:18:50 <mmo> Ah ok. Thank you
06:18:57 <tsahyt> mmo: relevant piece of code from reactive-banana-gi-gtk https://github.com/mr/reactive-banana-gi-gtk/blob/master/reactive-banana-gi-gtk/src/Reactive/Banana/GI/Gtk.hs#L64
06:19:29 <tsahyt> there's a usage example here https://github.com/mr/reactive-banana-gi-gtk/blob/master/example/app/Main.hs#L48
06:20:06 <tsahyt> I've found castB to be very useful, so you might want to grab that function. the library's license is public domain.
06:21:44 <mmo> tsahyt: Thanks for the tipp. But besides the missing cast is my way of creating the GUI correct? (I am new to GUIs in Haskell)
06:22:49 <tsahyt> I think so, I always just go by example files when dealing with GUIs. You'll have to call widgetShowAll (or something like that) to actually show the window.
06:42:46 <N0F4C3_47> hello ?
06:43:48 <cocreature> hey N0F4C3_47 
06:44:19 <magneticduck> any quick examples of types that are Applicative but not Monad?
06:45:03 <cocreature> magneticduck: AccValidation
06:45:49 <N0F4C3_47> Is this the chaenel haxor ? sorry
06:46:04 <cocreature> this channel is about the Haskell programming language
06:46:16 <Theophane> :')
06:47:02 <lyxia> magneticduck: ZipList, Const
06:47:18 <N0F4C3_47> ohh this chaenel is chaenel programing ?
06:47:21 <magneticduck> haskell -> hakell -> haker -> haxor
06:47:35 <N0F4C3_47> yeh i know ?
06:48:34 <N0F4C3_47> Anyone know the link to download a web template?
06:50:58 <Theophane> hey, can someone remind me if (and how) I can use a custom template for `stack new`?
06:51:11 <tsahyt> Theophane: stack new <projectname> <templatename>
06:51:25 <tsahyt> see stack templates for names of templates
06:51:46 <Theophane> no, I mean
06:52:12 <Theophane> each time I use haskeleton I tweak some stuff, like the directory names, and stuff
06:52:27 <Theophane> how I can I tell stack "hey, use this custom template I made, plz"?
06:52:31 <lyxia> @let newtype I = I (forall a. Num a => a)
06:52:32 <lambdabot>  .L.hs:209:1: error:
06:52:33 <lambdabot>      Multiple declarations of ‘I’
06:52:33 <lambdabot>      Declared at: .L.hs:207:1
06:52:44 <tsahyt> Theophane: local templates are at ~/.stack/templates
06:52:49 <lyxia> > I undefined `seq` ()
06:52:51 <lambdabot>  ()
06:52:51 <Theophane> oh, neat, thanks tsahyt 
06:53:38 <cocreature> lyxia: huh, I didn’t expect that. but I also never thought about what happens in this case
06:53:41 <lyxia> I can understand why that evaluates but still that looks so wrong
07:01:03 <metahumor> hi everyone!
07:01:22 <metahumor> is this the proper place to ask about GHC build-from-source configs?
07:02:33 <ongy> there's #ghc aswell, which might be a better shot, but this channel is generally ok for ghc questions
07:02:47 <metahumor> cool, i'll try here i guess
07:03:00 <metahumor> i'm trying to get GHC working well (with stack) on Xenial through WSL
07:03:36 <ongy> WSL? that's the windows linux layer? Last I checked that didn't implement a required syscall for ghc.
07:03:45 <metahumor> and am having the 1 TB virtual mem allocation problem. i tried building from source, passing "./configure --disable-large-address-space", but the built GHC still allocs 1TB mem
07:04:15 <metahumor> i also tried making sure all the "#under USE_LARGE_ADDRESS_SPACE" lines were uncommented in the config.h and config.h.in
07:04:23 <metahumor> *#undef
07:04:35 <metahumor> the new Creators Update does implement it
07:05:20 <ongy> oh cool
07:06:16 <metahumor> basically, `stack build` anything takes a pretty long time because Windows is unhappy with the large alloc, and I can't seem to figure out how to get the GHC build-from-source to respect "--disable-large-address-space"
07:06:41 <metahumor> the GHC I pulled is from the git repo, 8.0.2
07:07:34 <ongy> erm, afaik that 1TB thing is the allocator that got introduced in 8.0)
07:07:50 <ongy> https://downloads.haskell.org/~ghc/master/users-guide/8.0.1-notes.html#runtime-system first point here. But I'm not sure how to disable it
07:11:04 <ongy> ah, should be the USE_LARGE_ADDRESS_SPACE. you probably want to complain about that in #ghc then
07:22:28 <metahumor> @ongy here's the WSL bug thread about the underlying issue
07:22:28 <lambdabot> Unknown command, try @list
07:22:28 <metahumor> https://github.com/Microsoft/BashOnWindows/issues/1671
07:22:44 <metahumor> ongy: here's the WSL bug thread about the underlying issue
07:23:00 <metahumor> i'm trying to find the reddit comments that suggested that build flag
07:25:39 <metahumor> here is the reddit comment: https://www.reddit.com/r/haskell/comments/64ixk6/stack_on_windows_subsystem_for_linux/dg41e6z/?context=10000
07:31:49 <metahumor> the #ghc channel suggests that the flag might not even fix it, so i'll just fall back to 7.10
07:31:56 <metahumor> thanks, ongy
07:59:33 <OnkelTem> Hi all
07:59:37 <Sornaensis> o7
07:59:43 <OnkelTem> What web framework you'd recommend?
08:00:12 <OnkelTem> I read about snapframework, but isn't it outdated or something?
08:00:44 <Sornaensis> afaik it isn't
08:01:23 <Sornaensis> I've only taken a cursory look at it but it seems nice and straightforward. There is also scotty and yesod 
08:01:30 <bennofs> OnkelTem: "Latest commit 5ef3883  16 days ago" https://github.com/snapframework/snap
08:03:19 <OnkelTem> Ok, I see. The reason why I thought it could be old is pretty naive - they use cabal in their docs
08:03:31 <OnkelTem> while I was told - use stack 
08:03:41 <Cale> OnkelTem: There are still people using cabal.
08:03:57 <Sornaensis> I use cabal now and again
08:04:05 <ertes> OnkelTem: i've never used stack even once
08:04:09 <OnkelTem> hehe
08:04:16 <Cale> Of course, meaning cabal install. Stack uses cabal the library.
08:04:20 <OnkelTem> so cabal is safe! good to know :)
08:05:07 <ertes> to be fully honest i don't even know what problem stack solves
08:05:57 <LAZAR> how do i return a kind of None value in haskell? Like i want to get the last element in a list but the list is empty, what should this return?
08:06:00 <Sornaensis> stack allows me to build stuff identically on the several systems I use without having to write separate configurations
08:06:08 <ertes> LAZAR: see Maybe
08:06:47 <mauke> safeLast :: [a] -> Maybe a
08:06:56 <LAZAR> ertes: i just ask because even builtin functions like last will not catch this case but throw an Exception instead
08:07:17 <ertes> LAZAR: yeah, it's an unfortunate historical mistake (at least in my opinion)
08:07:24 <Sornaensis> you can always install a better prelude
08:07:25 <Sornaensis> :D
08:07:57 <LAZAR> i just wonder which way is better, letting it crash (like last) or something else
08:08:18 <Cale> LAZAR: it really depends how sure you are that the list will be nonempty
08:08:26 <ertes> > foldr (const . Just) Nothing [1..10]
08:08:29 <lambdabot>  Just 1
08:08:37 <Cale> and how much you don't care if your program dies if it is
08:08:41 <Sornaensis> lists should never be empty
08:08:44 <Sornaensis> D:
08:08:49 <ertes> > foldl (\_ -> Just) Nothing [1..10]
08:08:51 <lambdabot>  Just 10
08:09:23 <LAZAR> What would be the way to implement such function? Like when i use an if...else to check if the list is empty, what would I return?
08:09:44 <Sornaensis> :t safeLast
08:09:46 <lambdabot> error: Variable not in scope: safeLast
08:09:49 <ertes> LAZAR: first try with explicit recursion
08:09:56 <ertes> @let safeLast = foldl (\_ -> Just) Nothing
08:09:58 <lambdabot>  Defined.
08:10:21 <mauke> LAZAR: avoid if/else for now
08:10:23 <Sornaensis> > safeLast []
08:10:26 <lambdabot>  Nothing
08:10:28 <mauke> LAZAR: prefer pattern matching
08:10:31 <Sornaensis> s/ now/ever
08:10:38 <mauke> shh
08:11:16 <LAZAR> Wouldnt be Nothing/Maybe a way to circumvent the rule that each expression should evaluate to something?
08:11:39 <ertes> LAZAR: Nothing is a something
08:11:44 <ertes> ironically enough
08:11:47 <Sornaensis> Maybe values are still values
08:11:57 <Sornaensis> exceptions are weird magic
08:12:06 <Sornaensis> :t error
08:12:07 <lambdabot> [Char] -> a
08:12:12 <ertes> LAZAR: the names don't really matter…  Maybe is just another type you could have defined yourself:  data Maybe a = Nothing | Just a
08:12:30 <ertes> like a list type with at most one element
08:12:56 <ertes> data List a = Nil | Cons a (List a)  -- in Maybe the latter, recursive field of Just is not there
08:13:43 <ertes> LAZAR: regarding what mauke said about avoiding 'if' you can read the first half of this subsection: LAZAR: read the first half of this section: http://ertes.eu/tutorial/foldr.html#heads-tails-and-a-digression
08:14:04 <ertes> whoops…  too much copy/paste =)
08:15:00 <halogenandtoast> I can't figure out why this is wrong: fmap (map fst) . fmap (sortOn snd) . zip <$> getRandoms) <*> [1,2,3]
08:15:10 <halogenandtoast> Can anyone point me in the first direction
08:15:42 <halogenandtoast> Sorry the easier to read version: (fmap (map fst. sortOn snd) . zip <$> getRandoms) <*> [1,2,3]
08:16:40 <halogenandtoast> :t (fmap (map fst. sortOn snd) . zip <$> getRandoms)
08:16:41 <lambdabot> error:
08:16:42 <lambdabot>     Variable not in scope: getRandoms :: f [b]
08:16:45 <metahumor> halogenandtoast: what are you trying to do?
08:16:57 <halogenandtoast> metahumor: shuffle
08:17:05 <halogenandtoast> I know there are other ways
08:17:06 <ertes> halogenandtoast: what's the type of getRandoms?
08:17:16 <metahumor> @let getRandoms :: MonadRandom m => m [a]
08:17:17 <lambdabot>  .L.hs:210:1: error:
08:17:17 <lambdabot>      The type signature for ‘getRandoms’ lacks an accompanying binding
08:17:17 <lambdabot>  
08:17:25 <metahumor> @let getRandoms :: MonadRandom m, Applicative m => m [a]
08:17:25 <lambdabot>  Parse failed: Parse error: ,
08:17:31 <ertes> halogenandtoast: that's not quite the same type as [1,2,3]
08:17:32 <halogenandtoast> @import System.Random
08:17:32 <lambdabot> Unknown command, try @list
08:17:33 <metahumor> @let getRandoms :: (MonadRandom m, Applicative m) => m [a]
08:17:34 <lambdabot>  .L.hs:210:1: error:
08:17:34 <lambdabot>      The type signature for ‘getRandoms’ lacks an accompanying binding
08:17:34 <lambdabot>  
08:17:41 <ertes> halogenandtoast: unless there is some OverloadedLists magic going on
08:17:49 <ertes> you're mixing up two applicative functors
08:17:55 <halogenandtoast> ertes: the type before <*> is (Random b, MonadRandom f, Ord b1) => f ([b1] -> [b])
08:18:04 <ertes> also the pattern (fmap f . zip) looks suspicious
08:18:28 <halogenandtoast> I'm just trying to play with the Random monad so I don't have to pass StdGen all the way down
08:18:32 <bennofs> :t \f -> fmap f . zip
08:18:34 <lambdabot> ([(a, b)] -> b1) -> [a] -> [b] -> b1
08:18:38 <bennofs> looks good to me
08:18:43 <ertes> halogenandtoast: are you trying to use (<*>) with the m functor or the list functor?
08:18:56 <metahumor> :t (((fmap fst) . (sortBy snd) . zip) <$> _)
08:18:56 <ertes> bennofs: not wrong, just suspicious
08:18:56 <halogenandtoast> ertes: with Rand
08:18:58 <bennofs> halogenandtoast: I think you want pure [1,2,3] instead of [1,2,3]
08:18:58 <lambdabot> error:
08:18:58 <lambdabot>     • Couldn't match type ‘[b0] -> [(a0, b0)]’ with ‘[(a, b1)]’
08:18:58 <lambdabot>       Expected type: [a0] -> [(a, b1)]
08:19:06 <ertes> halogenandtoast: then you probably want (pure [1,2,3])
08:19:15 <halogenandtoast> ertes: you're correct
08:19:19 <metahumor> yeah
08:19:37 <halogenandtoast> (fmap (map snd . sortOn fst) . zip <$> getRandoms) <*> pure [1,2,3]
08:19:41 <halogenandtoast> is what I wanted
08:19:48 <ertes> halogenandtoast: as a side note the mwc-random library has a very efficient shuffling function predefined
08:20:18 <metahumor> just my ignorance, why are there two levels of fmap?
08:20:20 <halogenandtoast> ertes: yeah I just wanted to play with the random monad
08:20:25 <halogenandtoast> :t fmap
08:20:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:20:28 <halogenandtoast> :t (fmap . fmap)
08:20:30 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
08:20:36 <halogenandtoast> f1 = Rand, f = []
08:20:42 <metahumor> ah gotcha
08:20:52 <bennofs> metahumor: fmap f . g   = pattern to compose f after two-arg g
08:21:02 <ertes> halogenandtoast: https://hackage.haskell.org/package/mwc-random-0.13.5.0/docs/System-Random-MWC-Distributions.html#g:5
08:21:36 <halogenandtoast> ertes: cool, is that better than https://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html
08:22:02 <ertes> halogenandtoast: most likely
08:22:04 <halogenandtoast> is seems like there are more fancy words on your page
08:22:08 <ertes> almost certainly in fact
08:22:20 <halogenandtoast> PrimMonad, MVector, PrimState
08:22:43 <ertes> halogenandtoast: whenever you see an 'm' with a PrimMonad context, think of it as IO or (ST s)
08:22:53 <ertes> it's just a way to abstract over such "primitive monads"
08:23:12 <halogenandtoast> Those sentences don't help me yet.
08:23:18 <halogenandtoast> I mean I "kind of" get it
08:24:11 <ertes> uniformShuffleM :: (Unbox a) => Vu.MVector s a -> Gen s -> ST s ()
08:24:23 <ertes> where: import qualified Data.Vector.Unboxed.Mutable as Vu
08:24:46 <Sornaensis> what is ST
08:24:55 <Sornaensis> and why do I feel like I need an adult
08:24:57 <halogenandtoast> But that function returns ST s () I assume I want a returned no?
08:25:04 <ertes> it abstracts over both the PrimMonad and the exact vector type (boxed, primitive, storable, unboxed vectors)
08:25:27 <ertes> mwc-random is an effectful library, unlike 'random'
08:25:39 <ertes> so you always use it in the context of some primitive monad
08:26:09 <ertes> you can still use it purely by using ST, but the actual generation of random numbers will be ST-effectful
08:26:54 <ertes> Sornaensis: ST is a way to write a value using effects that are not observable from outside
08:27:23 <ertes> Sornaensis: for example you can use a mutable random number generator with a fixed seed, so the actual result is deterministic and does not depend on observable effects like reading a file
08:28:16 <halogenandtoast> Ha, the entire reason why I couldn't get my code to work earlier (mainly because I'm tired) is I went to hoogle and searched for "f (a -> b) -> a -> f b" and the first "result" was <*>
08:28:22 <halogenandtoast> and I used it without thinking
08:28:32 <ertes> > runST (do v <- newSTRef 5; modifySTRef v (+ 5); readSTRef v)
08:28:34 <lambdabot>  10
08:28:35 <halogenandtoast> without realizing it wasn't the same type signature that I had searched.
08:28:38 <ertes> Sornaensis: ^
08:30:32 <ertes> Sornaensis: unlike a state monad this one doesn't emulate mutable state using functions, but it does in fact use mutable variables and in-place update
08:30:54 <Sornaensis> neat
08:30:54 <halogenandtoast> ertes: that sounds terrible
08:31:00 <ertes> like a restricted subset of IO (it *is* in fact a restricted subset of IO)
08:31:00 <Sornaensis> is that easier than using state for rng
08:31:41 <ertes> Sornaensis: i would rather not compare them…  they have some overlap in utility, but not much
08:32:10 <ertes> > evalState (state (randomR (0, 9))) (mkStdGen 50)
08:32:12 <lambdabot>  1
08:32:41 <ertes> > evalState (let c = liftA2 (:) (state (randomR (0, 9))) c) (mkStdGen 50)
08:32:43 <lambdabot>  <hint>:1:57: error: parse error on input ‘)’
08:32:46 <ertes> > evalState (let c = liftA2 (:) (state (randomR (0, 9))) in c) (mkStdGen 50)
08:32:49 <lambdabot>  error:
08:32:49 <lambdabot>      • Couldn't match type ‘f0 [Integer] -> f0 [Integer]’
08:32:49 <lambdabot>                       with ‘StateT StdGen Identity a’
08:32:56 <ertes> > evalState (let c = liftA2 (:) (state (randomR (0, 9))) c in c) (mkStdGen 50)
08:32:59 <lambdabot>  [1,9,0,8,9,9,3,3,1,8,8,7,3,4,2,7,7,2,0,0,0,3,0,4,3,2,3,1,9,8,4,3,7,6,3,5,9,6...
08:33:04 <ertes> sorry for the noise
08:35:35 --- mode: ChanServ set +o glguy
08:35:35 --- mode: glguy set -bbbo *!*@85.255.13.137 *!*@h35-65.pool95-168.dyn.tolna.net *!*@gateway/web/freenode/ip.50.151.27.165 glguy
08:35:47 <ertes> for example you can use StateT as a utility with lenses, something that ST would handle rather poorly
08:35:51 <Sornaensis> > evalState (let c = liftA2 (:) (state (randomR (0,9))) c in c) (mkStdGen 50)
08:35:54 <lambdabot>  [1,9,0,8,9,9,3,3,1,8,8,7,3,4,2,7,7,2,0,0,0,3,0,4,3,2,3,1,9,8,4,3,7,6,3,5,9,6...
08:36:03 <Sornaensis> > evalState (let c = liftA2 (:) (state (randomR (0,9))) c in c) (mkStdGen 51)
08:36:06 <lambdabot>  [5,5,2,7,7,9,6,6,0,8,8,2,6,5,4,5,7,3,1,2,4,6,0,3,6,4,1,5,9,5,3,8,0,1,6,7,1,7...
08:36:23 <Sornaensis> I forgot that mkStdGen was pure
08:36:40 <ertes> :t mkStdGen
08:36:42 <lambdabot> Int -> StdGen
08:37:01 <halogenandtoast> huh really?
08:37:04 <halogenandtoast> :t newStdGen
08:37:05 <lambdabot> IO StdGen
08:37:11 <halogenandtoast> Ah I see
08:37:14 <Sornaensis> :t mkStdGen
08:37:15 <lambdabot> Int -> StdGen
08:37:15 <Sornaensis> :P
08:37:31 <halogenandtoast> It's pure, but useless :p
08:37:31 <ertes> newStdGen is just an abstraction over mkStdGen to fetch the seed from system sources
08:38:28 <ertes> no, not useless…  you can use it in cases where fixed seeds don't matter like primality testing, or where they can be even beneficial like test suites
08:38:34 <ertes> or anything where you need to be able to reproduce
08:39:02 <Sornaensis> primality testing random numbers? or using random numbers?
08:39:21 <ertes> some primality tests like the common millar-rabin test use randomness
08:39:21 <halogenandtoast> ertes: I was mostly kidding
08:39:26 <stphrolland> Hi, is there something existing that given two Maybe Bool, or even a list of Maybe Bool, would short-circuit if any Nothing is present, or perform a 'all' if all value are Just. ?
08:39:28 <LAZAR> How can I write a function that doubles any number regardless of whether its a double or an integer?
08:39:35 <rightfold> World generation in games is more fun if reproducible
08:39:39 <ertes> LAZAR: (2 *)
08:39:58 <Sornaensis> :t (2*)
08:39:59 <lambdabot> Num a => a -> a
08:40:15 <Sornaensis> polymorphism is a hell of a drug
08:40:18 <rightfold> stphrolland: and (== Just True)
08:40:25 <ertes> stphrolland: something like asum?
08:40:29 <rightfold> Or maybe it's called all
08:40:53 <ertes> > asum [Just 1, Just 2, Nothing, Just 3]
08:40:55 <lambdabot>  Just 1
08:40:58 <LAZAR> ertes: how is thissignature composed? where is the argument?
08:40:59 <ertes> ah, no
08:41:23 <Sornaensis> isn't that just applicative?
08:41:28 <stphrolland> i like the and (== Just True), it's so straigthforward... i'm ashamed ;-)
08:41:37 <ertes> :t traverse guard
08:41:39 <lambdabot> (Alternative f, Traversable t) => t Bool -> f (t ())
08:41:40 <bennofs> stphrolland: it's `all (== Just True)` actually
08:41:46 <bennofs> but same idea
08:42:10 <rightfold> > map (all (== Just True)) [ [Just True, Nothing], [Just True, Just False], [Just True, Just True] ]
08:42:12 <lambdabot>  [False,False,True]
08:42:33 <ertes> > fmap (maybe False (const True)) . traverse guard $ Nothing : repeat (Just True)
08:42:35 <lambdabot>  error:
08:42:35 <lambdabot>      • Couldn't match expected type ‘Maybe Bool’
08:42:35 <lambdabot>                    with actual type ‘[Maybe Bool]’
08:42:59 <ertes> > maybe False (const True) . traverse_ guard $ Nothing : repeat (Just True)
08:43:01 <lambdabot>  error:
08:43:01 <lambdabot>      • Couldn't match type ‘Maybe Bool’ with ‘Bool’
08:43:01 <lambdabot>        Expected type: [Bool]
08:43:55 <ertes> :t maybe False (const True) . traverse_ guard
08:43:57 <lambdabot> Foldable t => t Bool -> Bool
08:44:09 <LAZAR> So when I have a function double = 2*, what would the Signature be? double :: (Num a) -> a?
08:44:12 <ertes> :t maybe False (const True) . traverse_ (>>= guard)
08:44:14 <lambdabot> Foldable t => t (Maybe Bool) -> Bool
08:44:24 <ertes> > maybe False (const True) . traverse_ (>>= guard) $ Nothing : repeat (Just True)
08:44:26 <lambdabot>  False
08:44:27 <rightfold> LAZAR: Num a => a -> a
08:44:46 <ertes> stphrolland: but yeah, just use 'all (== Just True)'
08:45:04 <LAZAR> ertes: what does the => mean in this context?
08:45:18 <LAZAR> Looks like a 2 param function at first glance
08:45:22 <bennofs> ertes: that is... complicated
08:45:37 <ertes> LAZAR: it's a function of type (a -> a), where there is an instance (Num a), such that you can use (*) :: a -> a -> a
08:45:42 <mauke> LAZAR: the parens are not optional. it's (2 *)
08:45:45 <bennofs> ertes: maybe False and . sequence I could understand
08:45:48 <ertes> bennofs: i'm just playing around
08:46:06 <mauke> LAZAR: in general, the => separates class constraints from the rest of the type
08:46:09 <ertes> :t traverse_ (>>= guard)
08:46:10 <lambdabot> (Alternative f, Monad f, Foldable t) => t (f Bool) -> f ()
08:46:36 <ertes> bennofs: takes a list of actions and, if they result, passes their results to 'guard'
08:46:51 <ertes> the (>>=) takes care of handling Nothing, while 'guard' takes care of False
08:49:32 <halogenandtoast> where does guard come from?
08:49:48 <Sornaensis> > map (fmap and . sequence) [ [Just True, Just False], [Nothing, Just True]]
08:49:50 <lambdabot>  [Just False,Nothing]
08:50:19 <Taneb> halogenandtoast, it lives in Control.Monad
08:50:23 <halogenandtoast> thanks Taneb 
08:50:25 <mauke> @hoogle guard
08:50:25 <lambdabot> Control.Monad guard :: (Alternative f) => Bool -> f ()
08:50:25 <lambdabot> Monad guard :: Alternative f => Bool -> f ()
08:50:25 <lambdabot> Web.Simple.Controller.Trans guard :: Monad m => Bool -> ControllerT s m a -> ControllerT s m ()
08:51:19 <halogenandtoast> mauke: yeah I asked, then realized I should hoogle
08:51:33 <Sornaensis> > sequence $ [Nothing] ++ [Just x | x <- [1..]]
08:51:33 <halogenandtoast> although lately it's been letting me down
08:51:35 <lambdabot>  Nothing
08:52:05 <math932> What's the advantage of writing add :: (Int, Int) -> Int before writing add (x, y) = x + y? It works perfectly without that. Why would I specify the types?
08:52:06 <Sornaensis> it's neat how laziness allows you to test short circuiting
08:52:34 <mauke> halogenandtoast: there's also hayoo
08:52:35 <Sornaensis> math932: it's good form for top level definitions
08:52:47 <Sornaensis> allows people who are reading your code to see the types, not just the compiler
08:53:00 <mauke> math932: it helps human readers, and it helps you get better error messages
08:53:05 <Sornaensis> mauke: also those are not the same
08:53:06 <math932> Sornaensis: I see. But then I could as well have written a comment, right?
08:53:14 <Sornaensis> + will work for any Num
08:53:27 <Sornaensis> add :: Num a => (a, a) -> a would be equivalent
08:53:55 <Sornaensis> math932: no because comments are not type checked
08:54:02 <Sornaensis> meaning they can lie
08:54:23 <mauke> math932: when you have a type error in your program, the compiler can tell things don't fit together, but it doesn't know what you intended to write
08:54:37 <math932> mauke: I see :)
08:55:07 <mauke> i.e. the compiler might infer a type you didn't want for your function, which then leads to weird errors elsewhere
08:55:15 <ertes> LAZAR: in haskell the notation (2 *) is short-hand for (\x -> 2 * x)
08:55:28 <ertes> so (2 *) is an actual function
08:55:31 <ertes> > (2 *) 5
08:55:33 <lambdabot>  10
08:55:51 <LAZAR> ertes: lol then it makes a bit more sense... i thought the argument went missing
08:56:21 <LAZAR> why is it sometimes necessary to write \x instead of plain x for the left side value?
08:56:30 <ertes> LAZAR: kind of…  the argument is not missing, but actually abstracted over =)
08:56:44 <ertes> you always write "\x" to introduce a lambda
08:56:51 <mauke> \PARAMETERS -> BODY is the syntax for functions
08:57:29 <ertes> math932: think of type signatures as formal comments =)
08:57:40 <ertes> comments that both humans *and* the compiler can understand
08:57:42 <math932> ertes: Yeah :)
08:58:19 <LAZAR> mauke: wait why does it work without the backslash then? i can write a function definition with f x y = x + y
08:58:41 <ertes> math932: they are very often better than comments in prose…  so much so that i sometimes have difficulty writing documentation for my code where i don't sound like a parrot
08:59:05 <ertes> because i find myself just repeating what the type signature already says in a more useful way
08:59:09 <math932> :D
08:59:25 <mauke> LAZAR: that's just syntactic sugar for f = \x y -> x + y
08:59:50 <mauke> LAZAR: which happens because there's more than one symbol on the left side of =
09:00:12 <math932> ertes: I found some slides, where they mention length :: [a] -> Int as an example of a polymorphic function, but isn't this only a type signature? I mean, I couldn't use this, could I?
09:00:20 <math932> If I wanted to try it?
09:00:39 <qmm> i have never heard of Equal before. it was called a a lower-order abstraction similar to a semigroup or a monoid
09:00:42 <qmm> what is it?
09:00:55 <ertes> math932:
09:00:59 <ertes> > length [1..5]
09:01:01 <lambdabot>  5
09:01:05 <ertes> > length "hello world"
09:01:07 <lambdabot>  11
09:01:14 <math932> So basically, they add a type signature to a built-in length function?
09:01:15 <Sornaensis> Monoid under equality of terms?
09:01:23 <Sornaensis> @hoogle Equal
09:01:23 <math932> Or how does it know what length is?
09:01:23 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Equal :: ComparisonFunction
09:01:24 <lambdabot> Agda.Syntax.Concrete Equal :: Range -> Expr -> Expr -> Expr
09:01:24 <lambdabot> Data.SBV.Internals Equal :: Op
09:01:27 <math932> We didn't tell?
09:01:34 <ertes> math932: it's not "built in" the way you think it is…  it's defined in haskell as a regular library function
09:01:39 <Sornaensis> wait that don't make sense
09:01:45 <math932> > length [False, True] 
09:01:48 <lambdabot>  2
09:01:51 <math932> > length [1, 2, 3, 4]
09:01:53 <lambdabot>  4
09:02:05 <ertes> math932: in fact only few things in haskell are built in compared to other languages
09:02:07 <math932> Hm... so do I modify the library function by this type signature?
09:02:13 <Sornaensis> math932: do you know how pattern matching works?
09:02:26 <mauke> math932: no, the type signature is just added for clarity
09:02:28 <math932> Sornaensis: Well, I have seen a few examples, but I only started learning yesterday :)
09:02:32 <Sornaensis> ah ok
09:02:35 <mauke> that's its normal type
09:02:46 <ertes> math932: there is a utility module called Prelude that is imported implicitly, which gives you, among many other things, 'length'
09:02:47 <Sornaensis> most everything in haskell revolves around the concept of pattern matching
09:03:10 <math932> But isn't 'length' already polymorphic? Or did it become polymorphic because I did this?
09:03:12 <ertes> math932: it's as if you had written "import Prelude" in every module you write
09:03:20 <math932> Yeah :)
09:03:23 <Sornaensis> you can match any data type in haskell with its constructors
09:03:30 <ertes> math932: it was already polymorphic, because it has a type variable in its type
09:03:34 <ertes> 'id' is also polymorphic
09:03:36 <ertes> :t id
09:03:38 <lambdabot> a -> a
09:03:38 <Sornaensis> > (\(a:_) -> a) [3,4,5]
09:03:41 <lambdabot>  3
09:04:05 <ertes> math932: also the type you gave is a bit of a lie in modern haskell =)
09:04:06 <ertes> :t length
09:04:08 <lambdabot> Foldable t => t a -> Int
09:04:09 <Sornaensis> (:) is actually the `[a]` data type constructor
09:04:09 <ertes> that's the actual type
09:04:15 <ertes> > length (Just 5)
09:04:17 <lambdabot>  1
09:04:33 <math932> Haha :P
09:04:40 <ertes> incoming WAT – seemingly
09:04:45 <ertes> > length (1, 2)
09:04:47 <lambdabot>  1
09:05:20 <ertes> it's not really a WAT, because there is a logical reason why the length of a tuple is 1, but ignore that for now =)
09:05:46 <mauke> > length (length, length, [length, length])
09:05:48 <lambdabot>  error:
09:05:48 <lambdabot>      • No instance for (Foldable ((,,) (t0 a0 -> Int) (t1 a1 -> Int)))
09:05:48 <lambdabot>          arising from a use of ‘length’
09:05:52 <mauke> clearly
09:06:20 <math932> :D
09:07:04 <math932> @let second xs = head (tail xs)
09:07:06 <lambdabot>  Defined.
09:07:12 <math932> second [1..5]
09:07:16 <math932> > second [1..5]
09:07:20 <lambdabot>  error:
09:07:22 <lambdabot>      Ambiguous occurrence ‘second’
09:07:24 <lambdabot>      It could refer to either ‘Control.Arrow.second’,
09:07:28 <math932> Hm... 
09:07:29 <mauke> @undefine
09:07:29 <lambdabot> Undefined.
09:07:35 <ertes> math932: use a different name
09:07:41 <mauke> better, don't use @let
09:07:44 <math932> Why?
09:07:50 <mauke> > let second xs = head (tail xs) in second [1..5]
09:07:52 <ertes> because lambdabot
09:07:52 <lambdabot>  2
09:08:01 <mauke> because then you don't run into conflicts with existing functions
09:08:04 <ertes> (it has Control.Arrow imported, which has a function of the same name)
09:08:05 <Sornaensis> > e
09:08:08 <lambdabot>  e
09:08:51 <math932> http://i.imgur.com/xo4Ww8N.png - I was just trying to understand what each of these functions did (slides from an archived MOOC) :)
09:08:56 <math932> Some of them are fairly obvious though.
09:08:59 <math932> Most of them actually.
09:09:19 <ertes> math932: you can use @let if you want, but the namespace of lambdabot is polluted by lots of imports
09:09:23 <raf_> how can I install the Haskell platform on mac in a custom directory (e.g in my home directory)?
09:09:28 <math932> Oh
09:09:30 <math932> So...
09:09:38 <math932> > second xs = head (tail xs)
09:09:40 <lambdabot>  <hint>:1:11: error:
09:09:40 <lambdabot>      parse error on input ‘=’
09:09:40 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
09:09:41 <math932> Better?
09:09:45 <math932> Hm. No?
09:09:48 <mauke> math932: see my example above
09:09:50 <math932> I still need to rename it?
09:10:04 <ertes> no, 'let' bindings shadow other names
09:10:10 <ertes> > let x = 5 in x + x
09:10:12 <lambdabot>  10
09:10:21 <ertes> even x is predefined in lambdabot =)
09:10:22 <Sornaensis> > (\0.3 -> True) 0.3
09:10:25 <math932> Oh.
09:10:25 <lambdabot>  True
09:10:28 <Sornaensis> > (\0.3 -> True) (0.1 + 0.2)
09:10:30 <lambdabot>  *Exception: <interactive>:3:2-13: Non-exhaustive patterns in lambda
09:10:43 <glguy> > 0.3 == 0.1 + 0.2
09:10:43 <math932> > let second xs = head (tail xs)
09:10:45 <lambdabot>  False
09:10:46 <lambdabot>  <no location info>: error:
09:10:46 <lambdabot>      not an expression: ‘let second xs = head (tail xs)’
09:10:50 <ertes> but by using 'let' the outer 'x' is invisible ("shadowed") in the 'in' part
09:10:56 <math932> Haha. Oh, well...
09:11:03 <mauke> > (\0.3 -> True) (0.1 + 0.2 :: Rational)
09:11:05 <lambdabot>  True
09:11:14 <ertes> math932: see mauke's example
09:11:17 <math932> But I guess it's supposed to return the second element in a list?
09:11:18 <Sornaensis> n, n
09:11:21 <mauke> math932: see my example above
09:11:39 <math932> [18:07] <mauke> > let second xs = head (tail xs) in second [1..5]
09:11:42 <math932> Oh, like this?
09:11:51 <mauke> yes
09:11:55 <ertes> math932: yeah:  let DEFINITIONS in EXPRESSION
09:12:05 <mauke> :t let second xs = head (tail xs) in second
09:12:07 <lambdabot> [a] -> a
09:12:17 <mauke> you can directly ask lambdabot for the type
09:15:13 <math932> Nice :)
09:16:02 <math932> Thanks!
09:16:20 <ertes> math932: if these weren't already recommended to you, i highly recommend that you use these lecture notes: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
09:16:56 <ertes> math932: they have a good balance between explanations and exercises
09:17:20 <math932> Thanks, ertes :)
09:18:30 <ertes> perhaps the only problem i have with it is the very late introduction of IO
09:19:40 <Sornaensis> meh the cool thing about haskell is you can learn so much before you even get to hello world
09:20:43 <ertes> hello world?  fac 0 = 1; fac n = n * fac (n - 1)  -- you mean this?
09:21:18 <maerwald> ertes: I've thought about that too, but I don't see a reasonable way of introducing it earlier without falling back to metaphors and white lies
09:22:53 <ertes> maerwald: i generally introduce syntax, basic types and polymorphism, then go straight to IO, because i found it beneficial to give beginning developers the tools to write interesting programs
09:23:00 <ertes> it has worked out very well so far
09:23:24 <ongy> ertes: how big are your groups?
09:23:26 <maerwald> without having introduced monads?
09:23:35 <ertes> ongy: 5-10 people
09:23:39 <math932> https://pastebin.com/bVKtyVPe - anyone who can spot the error here? :)
09:24:21 <ertes> maerwald: yeah, i do introduce (>>=) and 'pure' with specialised types (with a disclaimer that it's actually more general, "but ignore that for now, we'll revisit that")
09:24:38 <ongy> yea, that's a bit different than a lecture. I think for a lecture doing a lot of stuff, before IO makes kinda sense, but for teaching a few people IO early makes more sense (since questions can be handled reasonable well)
09:24:51 <ertes> math932: abs -42 = abs - 42
09:25:00 <ertes> math932: abs (-42) = abs (negate 42)
09:25:23 <math932> Oh, brackets...
09:25:25 <math932> :D
09:25:29 <ertes> ongy: yeah, my workshops are usually more focussed than a generic lecture
09:25:41 <ertes> also i generally have *much* less time
09:25:45 <math932> Thanks, ertes 
09:26:21 <ongy> 2nd difference. volunteers. It's easier to introduce "hard" (or rather weird) concepts with people that want to learn. Lecture should first grab attention, then do that
09:26:30 <ertes> another important difference is that i can't exhaust the attention span of my attendees
09:27:11 <ongy> I don't quite know how to parse that. Do they have a longer span than what your time, or do you think you should not do that?
09:28:08 <ertes> ongy: i lure them in with a specific goal like "we're gonna write a game" or "we're gonna write a web app"
09:28:13 <ertes> then i have 9-12 hours to do that =)
09:28:15 <Sornaensis> oh
09:28:21 <Sornaensis> yea well that makes sense
09:28:51 <ertes> if the only thing they see for the first six hours is equations and type errors, i lose them
09:29:07 <ongy> write a game in 12h? And you get more than pong done?
09:29:08 <Sornaensis> do you do live coding
09:29:16 <Sornaensis> or do you come with something prebuilt
09:29:23 <Sornaensis> or both
09:29:29 <ertes> ongy: no, of course not
09:29:54 <ertes> Sornaensis: everything is live
09:30:13 <ertes> i don't even have slides…  all i have is an emacs org-file with a loose agenda =)
09:30:23 <ongy> I think I would have prefered that to the way I learned haskell. But lectures just give way different boundaries
09:30:40 <ertes> lectures can be slower-paced and much more in-depth
09:30:46 <Sornaensis> I would have preferred learning haskell from someone who knew it well
09:31:08 <ertes> and they can have a strict agenda as well
09:31:10 <Sornaensis> my uni prof was like taking the course with us so many people lost interest
09:31:32 <ongy> mandatory course for me :)
09:32:03 <ongy> not haskell, but functional programming. And I got lucky (I guess? I haven't tried anything new except rust since then)
09:32:37 <ertes> i think the most important aspect to keep your audience interested is playfulness…  haskell is a tool to do fun stuff
09:32:50 <ertes> for some people the fun is in the math, but for others it's the result that matters =)
09:33:14 <ertes> for them haskell is just a tool…  a unique tool, but a tool nonetheless
09:33:25 <ongy> I have fun with the type system
09:35:33 <ertes> ironically i have more fun with haskell in a workshop that is completely unrelated to haskell: a crypto workshop
09:36:36 <ertes> lens-based manipulation of a piece of text is always worth a few jaw drops…  "what tool are you using?!  it's amazing!" – "oh, it's just a programming language…  it's called haskell"
09:37:17 <ongy> he. I was playing around with wrapping the linux crypto api (socket stuff) in haskell. Abstracting common things is hard in this area
09:38:28 <ertes> i would like to see a working, maintained binding to NaCl or libsodium
09:39:28 <ongy> the state of crypto wrappers on hackage is scary. but I have a few things that I think should be done, that may be stupid
09:39:52 <sm> ertes, agreed on playfulness! It's easy to lose that in the haskell swamps 
09:41:21 <jgt> hey folks, I have two lists of ByteStrings, and I'd like to find the common elements of the two lists. I know there is Data.List.intersect, but is that the most efficient way? My first list has ~55,000 elements. My second list has ~766,000 elements. It's taking a bit too much time to compute the result.
09:41:35 <Sornaensis> ertes: lens operations on strings?
09:41:46 <Camm> Hello everyone. I've been reading the Typeclassopedia and it talks a lot about context and containers. I understand that containers are something that holds a value, for instances, data types like List and Maybe. However, I don't really understand what a context is. And why some people, somethimes says the context of List or the context of Maybe. Are they contexts too? why?
09:41:55 <ertes> jgt: if the lists are sorted, you can write a fairly efficient intersection function…  if not, use Data.Set
09:42:14 <ertes> Sornaensis: on Text actually
09:43:05 <Sornaensis> ertes: ah
09:43:20 <ertes> Camm: "context" is nothing formal really…  we say stuff like: "(>>=) in the context of Maybe" to mean the semantics of (>>=) of the (Monad Maybe) instance
09:45:39 <ertes> Camm: it's easiest to ignore the informal terminology and focus on semantics
09:45:46 <Cale> A context is the thing which occurs to the left of a => at various places in the syntax, but that's probably not how they meant it.
09:47:02 <Cale> However, I too have trouble figuring out what people mean by "context" when they're talking about monads, it seems to stem from a way of thinking that's foreign to me.
09:47:33 <ertes> Camm: some older monad tutorials use the word "context" to abstract over things like "computation" and "container"…  in essence they are trying to rename "Monad" to something else…  i don't know if the typeclassopedia is doing it, but it's still a metaphor, and metaphors don't work here
09:47:55 <alanz> I regard "context" in this sense to mean whatever it is for the concrete version you are talking about.
09:49:33 <LAZAR> Can someone tell me what is wrong with my function? Just a hint would be fine https://codepaste.net/szgrfm
09:50:22 <ysahil> I have a function(say G(x)) which returns IO Text and Another Function (say F(X)) which takes Text. Can anyone Suggest how can we compose (F(G(X))???
09:50:38 <ertes> ysahil: fmap
09:50:51 <ertes> fmap :: (a -> b) -> IO a -> IO b
09:51:08 <mauke> LAZAR: why do you think something's wrong?
09:51:26 <LAZAR> mauke: the output is wrong for numbers > 100
09:51:47 <mauke> LAZAR: your function should be recursive but it isn't
09:52:19 <Cale> Did you read the error that the compiler gave?
09:52:28 <Cale> oh, it didn't give an error :)
09:52:40 <Cale> Because you didn't just have this function sitting around
09:52:45 <ertes> not all wrong programs are ill-typed…  yet…
09:53:11 <LAZAR> mauke: typos are just the worst of mistakes
09:54:07 <ertes> LAZAR: side note: if you use gists or lpaste.net, i can see your paste, too =)
09:54:55 <Camm> Thank you guys.
09:57:37 <ysahil> Can we have a function of type signature IO Text -> Text???
09:58:16 <mauke> yes
09:58:24 <mauke> but you won't like it
09:58:45 <ysahil> mauke: Sorry, I didn't understand
09:59:04 <mauke> foo :: IO Text -> Text; foo x = "psych"
10:00:20 <ysahil> mauke: can we only make constant string functions using this?
10:00:30 <LAZAR> is there a way to access the last list elements like func (x,y,xs) = ... ? maybe (xs, secondlast, last)
10:01:17 <Cale> No efficient way. You could write a function to do it, but that's an unnatural way to access a list
10:01:56 <Cale> Usually the answer if you have to do a lot of such an operation is to either store the list in reverse order, or else use a different data structure.
10:02:13 <ysahil> mauke: can we only make constant string functions using this?
10:05:20 <jgt> ertes: you've saved my life
10:05:20 <monochrom> ysahil: You need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
10:05:41 <koala_man> ysahil: you can't "get the Text out", no. there's not actually a Text inside it. 
10:06:35 <mauke> ysahil: yes
10:07:11 <Cale> ysahil: You can run an action of type IO Text as part of another IO action though.
10:07:53 <ysahil> Cale: I didn't understand the point you made
10:07:54 <Cale> ysahil: If you write  v <- x  in a do-block it means "execute the action x :: IO t, and whatever its result is, name that v"
10:08:17 <ertes> jgt: i have?
10:08:21 <Cale> and then the do-expression as a whole will have type IO s (it'll match the type of the last action in it)
10:09:18 <Cale> ysahil: A value of type IO t is not very much like a value of type t at all. It is a description of an action which could be taken that would result in a value of type t at the end, if it finishes normally.
10:09:42 <Cale> ysahil: i.e. the difference between IO String and String is like the difference between /bin/ls and a list of files in your home directory
10:10:05 <jgt> ertes: intersecting a ~55k list with a ~776k list pinned my CPU. Don't know how long the computation would have taken, because my HTTP request to it timed out. Turning my lists into sets first made the whole thing run in ~13s.
10:11:05 <ertes> jgt: ah, that…  if you need to do this repeatedly you can probably do even better than that
10:14:04 <jgt> ertes: I probably don't need to optimise it further for now, but it might be nice in the future
10:14:11 <jgt> unless there's low-hanging fruit I'm not seeing
10:14:19 <jgt> (which is likely, because I'm quite nooby)
10:14:40 <jgt> grateful if you'd share what else I should learn!
10:15:24 <ertes> jgt: the first optimisation i'm thinking of is to get unrelated data out of the way
10:15:31 <ertes> turn (Set K) into (Map K A)
10:16:08 <tathougies> Is there a GHC extension that would let me do something like `type Foo = Bar Identity deriving (Show, Eq)`, as shorthand for `type Foo = Bar Identity; deriving instance Show Foo; deriving instance Eq Foo`. This would be useful when the instance for `Bar Identity` could be easily derived but not for other instantiations of `Bar`?
10:16:13 <ertes> the next is to get rid of expensive data types, e.g. replace String by Text
10:16:57 <ertes> tathougies: 'type'?  not 'newtype'?
10:17:20 <tathougies> @ertes yes, type not newtype. 
10:17:20 <lambdabot> Unknown command, try @list
10:17:26 <tathougies> ertes: yes, type not newtype
10:17:33 <jgt> ertes: my data is coming out of Redis, so they're all ByteStrings
10:18:34 <tathougies> I know it's an odd request, but it's useful for one of my libraries that messes around with type families inside types. The context for the general instance `Show (Bar f)` is huge, and undecidable in general, but not for `Show (Bar Identity)`. `Bar Identity` is the only type most would want to Show or Eq though.
10:19:06 <tathougies> I feel it would be a nice addition if `TypeSynonymDeriving` let me add deriving instances to the type declaration instead of having to write 'deriving instance' time
10:19:20 <ertes> tathougies: why are you not deriving the instances for Bar instead of Foo?
10:19:28 <ertes> then StandaloneDeriving should suffice
10:19:47 <tathougies> like I said, the instance for `Bar f` is undecidable due to the constraints
10:20:02 <ertes> deriving instance Show (Bar Identity)
10:20:32 <tathougies> Yeah I can totally do that. I want to save on line space
10:20:32 <ertes> it's the same thing anyway, even in the presence of type families
10:20:44 <tathougies> I'm trying to minimize the number of lines users of my library will have to write
10:20:51 <tathougies> This is for my beam library: I'll show you This is for my beam library: https://github.com/tathougies/beam/blob/travis/beam-0500/beam-sqlite/examples/Chinook/Schema.hs
10:21:13 <tathougies> as you can see the `deriving instance` declarations get tedious, it would be much simpler to write them inline, and there wouldn't be any ambiguity (I think)
10:21:16 <ertes> i don't think there is a shorter way to write that
10:21:34 <ertes> if you derive for Bar, at least you don't need TypeSynonymInstances
10:21:54 <tathougies> but then i need `UndecidableInstances` which is much scarier for library users to enable IMO
10:21:57 <tathougies> also unnecessary
10:22:14 <ertes> you don't need it for Foo?
10:22:26 <tathougies> nope
10:22:37 <ertes> wait, why would you need it?  i can see that you would need FlexibleInstances, but not UndecidableInstances
10:22:47 <tathougies> Did you look at my example?
10:23:17 <tathougies> the context for Show (ArtistT f) would be Show (Columnar f Int32), Show (Columnar f Text), which is undecidable according to GHC since Columnar is a type family
10:23:38 <tathougies> but since `Columnar Identity x ~ x`, the context for `Show (ArtistT f)` is statically `Show Int32` and `Show Text`, which are easily shown by the compiler
10:24:32 <tathougies> thus, the compiler has no problem `deriving instance Show (ArtistT Identity)`, but forcing users to write out the full context and turn on undecidable instances is annoying, especially when most users only really want `Show`, `Eq`, etc instances for the types parameterized over Identity
10:27:20 <ertes> tathougies: without learning the whole beam library, what is the meaning of 'f' in (Columnar f)?
10:27:38 <ertes> i.e. when is it not Identity?
10:29:03 <Sornaensis> ertes do you own any pets
10:32:46 <ertes> tathougies: (i'm trying to figure out whether you're doing something like this: <http://ertes.eu/tutorial/config-monoids.html>)
10:33:00 <tathougies> ertes: beam is a library for database access. `f` can be many things. For example, sometimes, it becomes `QExpr`, which means `Columnar QExpr x ~ QExpr x`. `QExpr` is a newtype over the type of SQL expressions where `x` is a phantom type parameter indicating the type of the result of the SQL expression when it's ultimately executed
10:33:14 <tathougies> othertimes, `f` is `TableField` which is a datatype tat describes how a field is stored in a table.
10:33:34 <ertes> Sornaensis: not sure how to respond to that
10:33:38 <tathougies> ertes: yes i am doing that, but with more convenience to the use
10:33:51 <tathougies> to the user*… namely using type families to avoid the newtype unwrapping for Identity
10:34:41 <tathougies> `f` can also be `Nullable g`. `Columnar (Nullable g) x ~ Columnar g (Maybe x)`. So there's quite a bit of complexity in the `Columnar` type family
10:34:42 <ertes> tathougies: reason i ask is that you can probably get rid of the type family altogether
10:34:50 <tathougies> no i do not want to do that
10:35:15 <tathougies> i have been down the road of manual newtype unwrapping and asking users to do that is too much
10:36:26 <tathougies> The entire point of `Columnar` is that when your type is applied to `Identity` you get a type whose fields are not newtypes or wrapped in anyway… just the 'normal' Haskell type you're trying to interface with your database
10:36:43 <tathougies> which is why i want a `deriving` clause on the end of my `type` synonyms :P
10:36:59 <LAZAR> Okay I solved this problem (doubling every other element in a list). The problem is: It was requested that the doubling takes place from right to left which seems super complicated... what would be the way to do this as requested? http://lpaste.net/354583
10:37:08 <Cale> Type synonyms can't have different instances from the types they're synonyms of though.
10:37:32 <ertes> Cale: tathougies isn't asking for that though
10:37:41 <Cale> Fair enough.
10:37:51 <TheLemonMan> LAZAR, are you writing a Luhn number checker?
10:37:53 <ertes> they're trying to trick GHC into doing partial type application with type synonyms, i think
10:37:55 <tathougies> Cale: what I want already exists. I just want more convenient syntax
10:38:17 <Cale> But if you want an instance for a newly defined synonym, you can write than instance before you introduce the synonym.
10:38:23 <ertes> i wouldn't even have known that you can abuse type families for that
10:38:39 <LAZAR> TheLemonMan: yes
10:38:42 <Cale> that*
10:39:16 <LAZAR> TheLemonMan: i do not even get why they specifically request to do the doubling from right to left
10:39:31 <TheLemonMan> because that's how the algorithm works heh
10:39:38 <tathougies> ertes: that's the key feature of the library — using seemingly regular haskell types to represent the type over sql expressions, regular haskell values, column descriptions, whatever. The migrations framework included even lets the same type hold information on foreign references, etc. Nevertheless, you never want to actually show these types, as they are internal to the library. Users just want to be able to Show the types parameterized over Identity
10:39:47 <Cale> What is the type a synonym of?
10:39:57 <tathougies> Cale: https://github.com/tathougies/beam/blob/travis/beam-0500/beam-sqlite/examples/Chinook/Schema.hs
10:40:08 <tathougies> look at the type of ArtistT
10:40:21 <tathougies> see how we derive instances for Show Artist and Eq Artist, where Artist ~ ArtistT Identity?
10:40:23 <tathougies> GHC can do that
10:40:36 <tathougies> I was wondering if there was any syntax extension to let me add a deriving clause to the end of the type synonym declaration
10:40:41 <LAZAR> TheLemonMan: the problem is that while it is easy to do this with the (f:s:xs) syntax, it is very hard for me as a beginner to do this from right to left
10:40:42 <ertes> tathougies: to be honest i would most likely still go with the newtype approach and then just implement the necessary convenience features using generics, because they are entirely mechanical
10:41:16 <Cale> Ah, and it's not smart enough to derive the corresponding instance for ArtistT?
10:41:39 <ertes> tathougies: then users can just use regular deriving
10:41:44 <tathougies> ertes: the point is that users only have to write their data types once. The library internals can easily deal with newtype unwrapping. People who use the library don't want to have to change all their data types simply because they're using beam to serialize them. As it is now, you have to change your type, but then you can just define a synonym parameterized over Identity, and voila, you have your old non-beam type back
10:42:03 <tathougies> Cale: GHC can do it if you give it the right context, but the type families make the context undecidable
10:42:23 <ertes> tathougies: i understand that…  that's also the point of the article i linked (you may want to skip to the "unifying phases" section)
10:42:24 <TheLemonMan> LAZAR, yep, but if you do all the steps together it only takes a couple of lines of code
10:42:28 <Cale> I see
10:42:53 <ertes> tathougies: i would do this:  data ArtistT f = ArtistT { … field :: f Field }  deriving …
10:43:23 <ertes> tathougies: the newtype wrappers can be eliminated by a combination of generics and lenses
10:43:54 <tathougies> ertes: i've done that before and got endless complaints from people using the library
10:44:00 <dmwit> :t foldr
10:44:02 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
10:44:07 <LAZAR> TheLemonMan: well reverse (doubleEveryOther (reverse [1,2,3,4])) works but its ugly as hell
10:44:21 <tathougies> the lenses did not help. If you look at older versions of beam, you'll see i included methods to use Generic to derive lenses
10:44:26 <tathougies> still had uses complain
10:44:42 <metahumor> LAZAR: I don't think the order matters for your purposes -- the right to left was probably for systems that are little-endian
10:44:49 <dmwit> :t foldr (\(multiplier, list) x -> (3-multiplier, multiplier*x : list)) 1 [1,2,3]
10:44:51 <lambdabot> error:
10:44:51 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ (a, [a])
10:44:51 <lambdabot>     • In the second argument of ‘(*)’, namely ‘x’
10:45:02 <ertes> tathougies: well, now you're picking a point on the scale between inconvenient and evil =)
10:45:04 <metahumor> LAZAR: especially the original mechanical systems
10:45:13 <tathougies> lol, well people really like using the type synonyms
10:45:15 <dmwit> > foldr (\x (m, xs) -> (3-m, m*x : xs)) 1 [1, 2, 3]
10:45:17 <lambdabot>  error:
10:45:18 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M416378450196...
10:45:18 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
10:45:21 <LAZAR> metahumor: i just wondered why they specifically requested this... as if there were some sorts of trick to this really elegant in haskell
10:45:34 <MarcelineVQ> LAZAR: to make it harder
10:45:36 <tathougies> and honestly, i think that's best, because you really never interact with the other parameterizations of your tables. The library takes care of that for you
10:45:44 <tathougies> .oh well, i guess i'll stick with the deriving instance for now
10:46:14 <dmwit> > foldr (\x (m, xs) -> (3-m, m*x : xs)) (1, []) [8,7,6,5]
10:46:16 <lambdabot>  (1,[16,7,12,5])
10:46:19 <LAZAR> MarcelineVQ: It just becomes ugler because i have to reverse twice
10:46:20 <dmwit> > foldr (\x (m, xs) -> (3-m, m*x : xs)) (1, []) [1,2,3]
10:46:20 <ertes> tathougies: yeah, you're already tricking the type class system to some extent
10:46:22 <lambdabot>  (2,[1,4,3])
10:46:24 <dmwit> LAZAR: ^^
10:46:48 <Cale> It's kind of interesting that you can get away with this :)
10:47:04 <tathougies> it's not a trick, I swear! :P
10:47:09 <ertes> tathougies: BTW, these inevitable complexities are the reason why i gave up on database abstractions
10:47:29 <tathougies> ertes: hmmm… beam so far has been a dream to use
10:47:31 <EvanR> databases deserve abstractions!
10:47:41 <metahumor> LAZAR: you don't need the second reverse
10:47:42 <Cale> ertes: Eventually we're going to figure it out, I promise
10:47:44 <EvanR> the backends though...
10:47:48 <ertes> hehe
10:47:50 <dmwit> > foldr (\x (m, xs) -> (1-m, shiftL m x : xs)) (1, []) [1,2,3]
10:47:52 <lambdabot>  (0,[2,0,8])
10:48:04 <metahumor> LAZAR: what are you going to do with the results of the doubled array?
10:48:04 <dmwit> haha, whoops
10:48:10 <ezyang> "sqls are pretty good abstraction" 
10:48:19 <EvanR> :(
10:48:26 <ertes> my approach is not to abstract over "databases", but model the application itself and then write backends using whatever database system
10:48:27 <dmwit> > foldr (\x (m, xs) -> (1-m, shiftL x m : xs)) (0, []) [1,2,3]
10:48:29 <lambdabot>  (1,[1,4,3])
10:48:35 <ertes> nice bonus: i can write an STM-based implementation for testing
10:49:06 <LAZAR> metahumor: its just a luhn number checker
10:49:06 <MarcelineVQ> metahumor: it's an exercise http://cis.upenn.edu/~cis194/spring13/hw/01-intro.pdf
10:49:19 <Cale> I think Ryan is right, we need a way to take ordinary looking Haskell code (perhaps with some pretty heavy restrictions on what you can write), and lift it to a somewhat arbitrary category (constrained based on what features of the language you used)
10:50:34 <metahumor> you can do some crazy Fold magic for that checker if you want to limit the number of times you traverse the list
10:50:37 <dolio> Then you need a database system that's a good category.
10:50:40 <dolio> And not SQL.
10:51:04 <dmwit> metahumor: It's not even crazy. I posted how above.
10:51:28 <Cale> dolio: Yeah, that's the other part of it, figuring out a convention for accessing a SQL database that lets us pretend that it's a good categorical one
10:51:30 <metahumor> :t shiftL
10:51:32 <lambdabot> Bits a => a -> Int -> a
10:51:36 <dmwit> Oh, maybe you mean for the whole checker and not just the "double every other number" part. In which case, okay, maybe. I've never tried it before.
10:52:19 <metahumor> yeah that's what I meant
10:52:36 <dolio> Cale: The other problem is that there are no SQL databases.
10:52:45 <metahumor> for the "sum digits", "sum of sums", and "all" 
10:52:50 <dolio> Except maybe Postgres.
10:53:32 <Cale> Postgres will do
10:53:40 <dolio> Well, I'm not even sure about it.
10:54:14 <Cale> An abstract way to store bits will do, so long as we're still allowed to tell customers that we're using Postgres ;)
10:56:04 <TheLemonMan> LAZAR, if you fold the doubling + the truncation + the sum you end up with something like this (in Ocaml though) https://ptpb.pw/5Wwu
10:57:58 <significance> Why are monads always applicative functors? Is there some trivial way to get <*> from >>=?
10:58:15 <dolio> Yes.
10:58:29 <rightfold> significance: (<*>) = ap
10:59:23 <significance> thank you!
11:00:08 <metahumor> significance: but be careful, because (<*>) does not imply an ordering on the arguments, but `ap` does
11:00:16 <metahumor> :t (<*>)
11:00:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:00:23 <metahumor> :t ap
11:00:25 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:00:56 <significance> Is the ordering implied in the declaration of Monad?
11:00:56 <EvanR> imply ordering?
11:01:13 <EvanR> the look exactly the same except for f / m
11:01:17 <metahumor> significance: as in, the @f a@ effect could "happen" before @f (a -> b)@ for Applicative f
11:01:35 <metahumor> but never for Monad f
11:01:36 <EvanR> ordering of the effects
11:01:39 <EvanR> not arguments
11:01:52 <metahumor> yes, sorry, misphrased that
11:01:54 <significance> ahh, thank you!
11:02:11 <metahumor> in general, people expect (<*>) and ap to order the effects the same way
11:02:35 <metahumor> the monad man will haunt you if you don't. maybe.
11:03:09 <significance> :%s/m/M ? :P
11:03:21 <EvanR> class MonadMan
11:03:46 <significance> oh, haha, I was referring to Maybe
11:03:49 <significance> but the mirth holds :)
11:04:21 <significance> just to be clear, the @f a@ effect is the effect on a that is caused by being placed in an applicative?
11:07:49 <metahumor> :t [(++ "2"), (++ "3"), (const "1")]
11:07:50 <lambdabot> [[Char] -> [Char]]
11:08:51 <metahumor> :t sequenceA [[(++ "2")], [(++ "3")], [(const "1")]] 
11:08:52 <lambdabot> [[[Char] -> [Char]]]
11:10:46 <metahumor> significance: yes. here's a nice blog post about how to utilize Applicatives for parsers
11:10:50 <metahumor> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
11:10:59 <significance> thank you!!
11:11:00 <fresheyeball> is there a way to make a map and guarentee there is a key for each element of an ADT?
11:11:10 <fresheyeball> for example
11:11:20 <EvanR> theres something called a total map
11:11:20 <fresheyeball> data Foo = Bar | Baz
11:11:32 <EvanR> theres also a dependent map
11:11:38 <Cale> There's also just functions
11:11:44 <fresheyeball> I want to ensure that `Map Foo a` is complete and not have to deal with Maybes
11:11:49 <EvanR> yeah, Key -> Value
11:11:56 <fresheyeball> I know I could do it with a function, but I don't have total control over the api
11:12:14 <EvanR> what are the other restrictions then
11:12:17 <fresheyeball> EvanR: can you point me at total map and dependant map?
11:12:19 <cheater> you need dependant types for that fresheyeball 
11:12:30 <fresheyeball> The api is looking for a `Map a b`
11:12:34 <EvanR> you dont need dependent types for this
11:12:43 <fresheyeball> And I make one with a literal of a list of tuples
11:12:47 <cheater> no? how would you do that EvanR?
11:12:53 <fresheyeball> and I want to compiler to yell at me if I extend the ADT
11:12:59 <EvanR> we havent figured out all the arbitrary restrictions of this problem yet
11:13:23 <fresheyeball> cheater: is cheating
11:13:44 <EvanR> so what is the actual api
11:13:57 <fresheyeball> is there a way I can convert a function from `a -> b` to a `Map a b`?
11:14:00 <EvanR> wants a Map, returns a Map ?
11:14:13 <fresheyeball> Map is the input, so I need to make one
11:14:40 <fresheyeball> right now I just do `foo = Map.fromList [(Bar, 3), (Baz, 4)]`
11:14:49 <fresheyeball> but when I add to the ADT, the compiler is silent
11:14:49 <EvanR> you can make a smart constructor which checks that all keys are present and outputs a map
11:14:57 <Cale> :t M.fromSet
11:14:58 <lambdabot> (k -> a) -> S.Set k -> M.Map k a
11:15:10 <fresheyeball> Ooooo
11:15:25 <EvanR> you would still need to make the set of keys and make sure its complete
11:15:30 <fresheyeball> So I could use bounded to pull this off
11:15:39 <EvanR> one way to have the compiler check that is have a function that case analyzes your key type
11:15:45 <metahumor> significance: there's also this nice short answer showing how Applicative effect ordering might matter http://stackoverflow.com/a/23342577
11:15:50 <fresheyeball> data Foo = Bar | Baz deriving (Enum, Bounded)
11:15:56 <EvanR> if its not a complete case analysis, the compiler can warn
11:16:08 <fresheyeball> right!
11:16:12 <significance> ooh, sweet - thanks!
11:16:21 <EvanR> enum bounded could be used to do a runtime test that your arent complete
11:16:28 <EvanR> which is not as nice
11:16:59 <fresheyeball> I am thinking I can write a function like this
11:17:31 <fresheyeball> makeCompleteMap :: (Enum k, Bounded k) => (k -> v) -> Map k v
11:17:53 <EvanR> what you can do is convert a total map to a map
11:17:59 <EvanR> yeah or that
11:18:29 <EvanR> if you add a new k, the case analysis in the k -> v will be a warning
11:18:33 <EvanR> until you fix it
11:18:44 <koala_man> how practical are the Haskell-to-JS compilers these days? are there other options if I want to write strongly typed functional code to run on a javascript engine?
11:18:44 <EvanR> it doesnt even need enum bounded
11:19:43 <metahumor> koala_man: typescript? purescript? elm?
11:19:48 <EvanR> ghcjs
11:20:26 <Sornaensis> ghcjs++
11:20:35 <fresheyeball> koala_man: we use ghcjs at work, and its lovely
11:20:47 <fresheyeball> koala_man: Purescript and Elm are also very nice
11:21:02 <fresheyeball> koala_man: Elm is the easiest to get going and has the most mature tools
11:21:17 <fresheyeball> koala_man: ghcjs has the nicest language and can be used for client server type sharing 
11:21:29 <fresheyeball> EvanR: totalMap f = M.fromSet f [minBound..maxBound]
11:21:32 <koala_man> awesome info, thanks!
11:22:07 <fresheyeball> koala_man: I wrote a blog post on this http://mutanatum.com/posts/2017-01-12-Browser-FP-Head-to-Head.html
11:22:30 <koala_man> perfect :3
11:24:22 <EvanR> fresheyeball: hmm yeah
11:24:55 <EvanR> i wanted a class specifically for enumerating all the elements
11:25:29 <Cale> If you have Bounded and Enum, you can try [minBound .. maxBound]
11:25:39 <EvanR> Enum, despite its name, doesnt do that really. adding bounded kind of fixes it but the whole thing is not as targeted as an abstraction
11:26:28 <EvanR> and doesnt work for stuff like Natural which doesnt have an upper bound
11:26:38 <EvanR> but does have an infinite list of its elements
11:27:21 <EvanR> allTheThings :: Enumerable a => [a]
11:27:33 <geekosaur> @hackage universe
11:27:33 <lambdabot> http://hackage.haskell.org/package/universe
11:28:13 <EvanR> nice
11:29:38 <EvanR> ~ * a Integer => Universe (Ratio a)
11:29:46 <EvanR> is this a haddock snafu or
11:30:36 <EvanR> and Universe doesnt have an instance for Natural built in :(
11:31:15 <geekosaur> haddock glitching over a kind
11:31:46 <geekosaur> and I think universe predates Natural; dunno if anyone's been maintaining it, for all the packages out there :/
11:33:24 <Tuplanolla> Is it possible to sanely communicate with a machine that has `CHAR_BIT > 8`?
11:33:38 <geekosaur> TYPE L 8 :)
11:33:48 <EvanR> theres no instance for Double, interesting
11:33:53 <geekosaur> (bit of internet history for you)
11:34:39 <geekosaur> anyway yes, but sometimes it takes some care. Tenex/Twenex systems had CHAR_BIT == 9 and were all over the early Internet
11:34:42 <EvanR> i guess Double is considered a (theoretically crippled) real number type in this case
11:34:58 <fresheyeball> EvanR: I think haveing a map with a key for every Natural would be a bad idea
11:35:11 <EvanR> your problem stems from the api not just taking a function
11:35:25 <EvanR> you can trivially convert a map into a function, but not the other way
11:35:50 <Tuplanolla> What even should happen if you send eight bits and eof to a machine that's expecting nine? Will there be padding or an early eof?
11:36:07 <fresheyeball> EvanR: well that may be the source of the pain. But I think its also reasonable to wish for a compiler warning for incompleteness of a Map
11:36:15 <EvanR> what machine takes 9 bits? is that an april fools joke?
11:36:24 <monochrom> I Googled for "type l 8" (with the double quotes), I got a list of how to do onramps with highways. http://www.dot.ca.gov/dist11/news/8impl/images/ex2.pdf
11:36:46 <Tuplanolla> "Thought experiment". EvanR.
11:37:00 <EvanR> fresheyeball: you solved it in an adequate way, but a separate thing along these lines is, at some point i just wanted a class for enumerating all the values
11:37:42 <fresheyeball> EvanR: I think that would be easy enough if they are bounded
11:37:44 <EvanR> Tuplanolla: since the internet is going to give them 8 bits per octet... i guess it would put a default value for the 9th bit
11:38:02 <fresheyeball> unbounded sounds hard because what would be the head of the list?
11:38:08 <EvanR> fresheyeball: what i was saying was, Enum + Bounded is a poor way to express that, because of the way Enum and Bounded really are in haskell
11:38:33 <EvanR> > [0..]
11:38:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:38:38 <EvanR> 0 is the head of this list
11:38:40 <monochrom> Hrm, L means LOCAL
11:38:40 <fresheyeball> EvanR: I'm sorry, I'm not understanding
11:38:47 <fresheyeball> right, 0 is a bound
11:39:01 <EvanR> Natural isnt an element of Bounded
11:39:04 <lpaste> aa pasted “a” at http://lpaste.net/354585
11:39:06 <EvanR> instance of
11:39:18 <fresheyeball> :i Natural
11:39:23 <fresheyeball> erp
11:39:27 <fresheyeball> how I do that in IRC?
11:39:29 <EvanR> also Rational is enumerable but not bounded
11:39:36 <Tuplanolla> @info Natural -- Not very helpful, fresheyeball.
11:39:37 <lambdabot> Natural
11:39:38 <geekosaur> you don't; it'd be too spammy
11:39:46 <monochrom> geekosaur, your encyclopedic knowledge of ancient computers is creepy. :)
11:39:47 <fresheyeball> ok
11:39:48 <geekosaur> and @info is edit corrected to @undo
11:40:00 <lpaste> bb pasted “b” at http://lpaste.net/3418910391294492672
11:40:05 <Sornaensis> how do I embed a web browser into irc
11:40:19 <fresheyeball> so would you be happy with a class exposing a function like this? 
11:40:27 <fresheyeball> startingWith :: a -> [a]
11:40:38 <badmann> is lpaste supposed to be this laggy?
11:40:41 <fresheyeball> startingWith x = [x..]
11:40:42 <EvanR> thats another bell and whistle on top of what it needs to do
11:40:49 <Tuplanolla> Sometimes, badmann.
11:40:51 <badmann> i remember it was laggy like a month ago
11:41:02 <EvanR> and requires Enum which is theoretically impossible for stuff that is infinite (because Int)
11:41:03 <geekosaur> lpaste is on a tiny vm instance iirc
11:41:07 <badmann> no point in using it instead of ix or pbp if its laggy..
11:41:18 <geekosaur> also I saw two pastes go by earlier
11:41:19 <fresheyeball> EvanR: right, we need atleast a minBound
11:41:29 <EvanR> fresheyeball: after enough haskell + etc, you start to notice these mathematical deficiencies ;)
11:41:30 <ertes> fresheyeball: you should revisit the reflex section, because it is misleading and in places plain wrong
11:41:31 <geekosaur> [14 18:38:43] <lpaste> aa pasted “a” at http://lpaste.net/354585
11:41:45 <EvanR> fresheyeball: rational has no minBound, neither does integer, but they are enumerable
11:41:52 <EvanR> see the universe package, exists already
11:42:01 <monochrom> aa pasted "a", and bb pasted "b". Will cc paste "c" soon? :)
11:42:13 <ertes> fresheyeball: "Reflex is highly composable and flexible, by mixing Monadic abstractions like crazy. This means developer discipline, as IO can be done anywhere in the code, and discrete state machines are common."
11:42:16 <EvanR> universe :: Universe a => [a]
11:42:18 <badmann> geekosaur: that was me i was trying to get a feel
11:42:19 <ertes> fresheyeball: that's pretty much complete non-sense
11:42:26 <badmann> are the pastes automatically deleted?
11:42:32 <Sornaensis> @hoogle a -> b
11:42:33 <lambdabot> Prelude id :: a -> a
11:42:33 <lambdabot> Data.Function id :: a -> a
11:42:33 <lambdabot> GHC.Exts breakpoint :: a -> a
11:42:42 <monochrom> No, I don't think the pastes are ever deleted.
11:42:43 <Sornaensis> >:{
11:42:46 <geekosaur> pastes live forever currently
11:42:55 <fresheyeball> ertes: can you expound on that?
11:42:59 <monochrom> Or at least, have ever been.
11:43:13 <ertes> fresheyeball: not without explaining reflex
11:43:19 <EvanR> geekosaur: well, past pastes seem to have moved, ive noticed links on old forums going to the wrong paste
11:43:28 <EvanR> like the keys changed
11:43:32 <fresheyeball> ertes: I'm happy to hear the critcism 
11:43:43 <fresheyeball> ertes: I use reflex at work, it what I do 8 hours a day
11:43:45 <geekosaur> several years ago lpaste lost its brain and got reset. everything since then has been stable
11:43:49 <fresheyeball> it's*
11:43:57 <metahumor> ertes: i think that snippet has "means" mean "monadic abstractions REQUIRE developer discipline to not use IO everywhere, in the sense that otherwise, you go crazy"
11:44:02 <ertes> fresheyeball: its semantics is pure
11:44:16 <monochrom> Oh, maybe that is why my paste of type inference of (.) (.) (.) is lost.
11:44:33 <monochrom> It was such a cool exercise.
11:44:41 <fresheyeball> ertes: what do you mean by that? Reflex is highly monadic and effectful
11:44:54 <fresheyeball> MonadWidget is monadic and needed to accomplish any work
11:44:59 <Sornaensis> :t (.) (.) (.) (.) (.) (.)
11:45:00 <lambdabot> (b1 -> b -> c) -> (a1 -> b1) -> a1 -> (a -> b) -> a -> c
11:45:04 <ertes> fresheyeball: now you're talking about reflex-dom
11:45:20 <fresheyeball> ertes: well to be fair, its an article about fp in the browser 
11:45:25 <Tuplanolla> Was it like this, monochrom: convert to `(.)` to `fmap`, infer, specialize `fmap` to `(.)`?
11:45:35 <fresheyeball> Maybe I should be more clear the whole section is about Reflex Dom
11:45:39 <Sornaensis> :t fmap . fmap . fmap
11:45:40 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f2 (f1 (f a)) -> f2 (f1 (f b))
11:45:58 <fresheyeball> I don't really think there is a clear path for using reflex in the browser without reflex-dom
11:46:01 <monochrom> No, I did it to (b -> c) -> (a -> b) -> (a -> c) directly.
11:46:10 <Tuplanolla> Wow, lewd.
11:46:13 <monochrom> Also, it would be fmap fmap fmap, without dots.
11:46:32 <fresheyeball> monochrom: thats one of the uglies tricks around
11:46:32 <EvanR> > fmap fmap . fmap . fmap fmap
11:46:34 <lambdabot>  error:
11:46:34 <lambdabot>      • No instance for (Typeable f1)
11:46:34 <lambdabot>          arising from a use of ‘show_M714224249303599581412308’
11:46:44 <fresheyeball> @type fmap fmap fmap
11:46:46 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
11:46:53 <fresheyeball> @type fmap . fmap
11:46:54 <ertes> fresheyeball: everything else in your article seems fine to me, either because i agree, or because i don't have experience with the tools you mentioned…  but to be honest the reflex section made me roll my eyes more than once, even on a sentence-by-sentence basis
11:46:54 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
11:47:34 <monochrom> The original question was "(.) . (.)" but first thing I did was eliminating the infix to reduce confusion.
11:47:51 <fresheyeball> ertes: are most of your concerns based on the distinction between reflex and reflex-dom? Because I admit I used them interchangably and relied on the reader to know from context I mean reflex-dom
11:47:52 <monochrom> (Second thing was rename them to comp1 comp2 comp3.)
11:47:55 <geekosaur> anyway chrisdone passed lpaste on to someone else and there's a move to bring it under haskell.org admin, and hopefully it will be activeluy developed again and maybe get things like putting expiration dates on pastes
11:48:41 <ertes> fresheyeball: yeah, you shouldn't assume that…  i'm using reflex, but i haven't used reflex-dom so far
11:48:42 <fresheyeball> ertes: most of the feedback I recieved was overwhelming positive. Or annoyance that I left out someone's favorite tech.
11:48:58 <fresheyeball> ertes: ok fair enough, I am happy to update the title of that section
11:49:18 <fresheyeball> ertes: question, because I've not used reflex without reflex-dom yet
11:49:32 <fresheyeball> ertes: is holdDyn a common thing in non-dom land?
11:49:44 <ertes> fresheyeball: but even in the context of reflex-dom it seems overly negative, as if you were trying to say: "you need to be super-careful with reflex-dom"
11:49:59 <fresheyeball> ertes: you do
11:50:03 <fresheyeball> ertes: absolutely
11:50:22 <ertes> fresheyeball: my use cases holdDyn is far less common than foldDyn
11:51:07 <ertes> fresheyeball: i can't really tell due to my limited experience with reflex-dom, but the API looks pretty safe to me, to be honest
11:51:20 <fresheyeball> ertes: higher order inside MonadIO requires the most developer discipline of any pure language platform I've used
11:51:22 <ertes> as far as i can tell the only thing it does is to add automatic widget creation and management
11:51:31 <ertes> which of course requires IO
11:51:50 <fresheyeball> ertes: right, this is not the case with other models
11:52:17 <fresheyeball> in reflex-dom there is no way to track side effects in a guarenteed fashion
11:52:39 <fresheyeball> and infinite loops are unfortunately a common bug, and difficult to reason about
11:53:05 <fresheyeball> don't get me wrong, I think reflex-dom is excellent 
11:53:20 <fresheyeball> but that doesn't mean it doesn't have comparative flaws, which is clearly does
11:53:30 <ertes> hmm…  reflex-dom, from an API standpoint, seems in line with every other FRP/UI framework i've seen so far or even created myself
11:53:33 <bennofs> the amount of knot-tying that reflex code requires is insane :)
11:53:50 <fresheyeball> ertes: I think UI frp api's might differ from backend ones
11:53:54 <bennofs> leads to easy infinite recursion, with MonadFix
11:54:34 <fresheyeball> bennofs: yes, MonadFix mdo stuff is what I meant by "discrete state machines are common"
11:54:35 <ertes> i mean: instead of creating a widget and then assigning event handlers and updating it, you create a widget and attach behaviours/events to it, and it returns events/behaviours
11:54:49 <fresheyeball> ertes: there are a ton of options here
11:55:17 <ertes> sure, you could also abstract away the whole process of creating widgets, essentially modelling the entire document as a single reactive system
11:55:28 <fresheyeball> you could sort of reify html and have a `Dynamic t HtmlThing` that get piped into a render
11:56:02 <fresheyeball> you can have an frp system that does not do IO inline at all, and would have a pure foldDyn
11:56:14 <ertes> but then you quickly find yourself emulating (main :: [Response] -> [Request]) in FRP, which is not nice to work with =)
11:56:21 <fresheyeball> or you could restrict the IO that can be performed using a free monad
11:56:28 <fresheyeball> and say only reflex IO can be done
11:56:29 <ertes> foldDyn *is* pure
11:56:42 <Sornaensis> > toDyn 5
11:56:44 <lambdabot>  <<Integer>>
11:56:52 <fresheyeball> no its not
11:57:01 <fresheyeball> its does an allocation
11:57:05 <Sornaensis> > fromDyn (toDyn 5) :: Char
11:57:07 <lambdabot>  error:
11:57:07 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘a0 -> a0’
11:57:07 <lambdabot>      • Probable cause: ‘fromDyn’ is applied to too few arguments
11:57:12 <fresheyeball> foldDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Dynamic t b)
11:57:13 <ertes> fresheyeball: so does Data.Vector.fromList
11:57:26 <ertes> allocation doesn't make something impure
11:57:40 <fresheyeball> sure, thats a fair point
11:57:53 <bsima> :t toDyn
11:57:54 <fresheyeball> you could hide the allocation by removing the m
11:57:55 <lambdabot> Typeable a => a -> Dynamic
11:57:57 <Sornaensis> > fromDynamic (toDyn 5) :: Char
11:57:59 <lambdabot>  error:
11:58:00 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘Maybe a0’
11:58:00 <lambdabot>      • In the expression: fromDynamic (toDyn 5) :: Char
11:58:01 <Sornaensis> > fromDynamic (toDyn 5) :: Maybe Char
11:58:03 <lambdabot>  Nothing
11:58:06 <ertes> the reason why foldDyn requires a monad is semantics:  foldDyn is tied to a certain point in time
11:58:07 <fresheyeball> and it would be pure
11:58:16 <ertes> and time is not a first-class concept in reflex
11:58:20 <fresheyeball> ok sure
11:58:27 <ertes> it's modelled entirely by a monadic language
11:58:41 <fresheyeball> I'm just saying there an numerous ways around this problem, that done require allowing for liftIO
11:58:50 <fresheyeball> or having side effects on the dom inline with your code
11:58:50 <ertes> which problem?
11:59:01 <fresheyeball> having a reactive dom system
11:59:49 <fresheyeball> there is nothing about just having an frp UI system that requires that it have these problems baked in
12:00:17 <ertes> you mean something like 'brick', which models the whole application, including widget creation, purely?
12:00:35 <fresheyeball> ertes: I've not heard of brick, but sure
12:00:52 <ertes> 'brick' attempts to replace vty-ui
12:02:10 <ertes> to be honest i've tried using brick, but it was a horrible experience…  i went back to vty-ui
12:02:20 <Tuplanolla> I liked it.
12:02:24 <fresheyeball> sure, so I think its fair to warn that Reflex requires discipline 
12:02:44 <fresheyeball> I don't think its so much discipline that its bad or anyting
12:02:51 <fresheyeball> anything*
12:02:53 <ertes> fresheyeball: you're confusing reflex and reflex-dom again =)
12:02:57 <fresheyeball> I think reflex-dom is awesome
12:03:22 <fresheyeball> ertes: I know the differnce, we've established that, no need to beat up on me for trivial semantics
12:04:27 <ertes> if you prefer something like brick, then reflex-dom is not the right solution…  but doing something like brick on the scale of a whole web app is bound to be problematic, at least in terms of performance, but more importantly in terms of flexibility
12:05:24 <fresheyeball> ertes: I think reflex-dom is excellent for a reason :)
12:05:33 <fresheyeball> ertes: I also called it a hero in that article 
12:07:53 <ertes> fresheyeball: oh, and if it came across like that, i'm really not trying to be difficult or insulting…  i'm trying to understand the problem you're talking about, and i think i understand it
12:08:05 <fresheyeball> ok cool
12:08:24 <fresheyeball> I will update the title of that section when I get around to it
12:08:35 <ertes> perhaps i just don't view it as a problem…  in particular i don't view IO as problematic =)
12:08:46 <EvanR> i love that haskells standard date library has an algorithm for easter
12:09:15 <fresheyeball> ertes: discipline is not necissarily a problem, but it is discipline 
12:09:20 <EvanR> its like, the most arbitrary computation 
12:09:29 <Aruro> EvanR: Yeah, like all cultures on earth need easter...
12:09:36 <Cale> reflex-brick?
12:09:37 <Cale> :)
12:09:43 <fresheyeball> ertes: as long as there is performUnsafeEvilFireTheMissilesAndTellNoOne
12:09:54 <fresheyeball> haskell requires more discipline than Elm
12:10:06 <fresheyeball> I still think Haskell is better :)
12:10:21 * hexagoxel has written a reflex wrapper around brick
12:10:39 <EvanR> unsafe fire the missile and tell no one is the easy one
12:10:48 <Cale> I wouldn't usually think of unsafePerformIO as part of the ordinary Haskell toolkit. It's more like 'last resort before we modify the compiler'
12:10:56 <Cale> and we *do* modify the compiler, so...
12:11:05 <Cale> But yeah, not a day to day thing
12:11:06 <ertes> fresheyeball: well, it could be possible to limit the monads involved in reflex-dom not to allow IO, but that would be an arbitrary limitation without any real benefit
12:11:16 <bollu> Cale: unsafePerformIO is useful for writing FFI as well
12:11:29 <bollu> Cale: when the API is "theoretically pure" but the FFI taints it with IO
12:11:48 <EvanR> is unsafePerformIO appropriate in that case?
12:11:56 <EvanR> the FFI has a built in thing to declare it as pure
12:11:58 <monochrom> I think it is not so much discipline as how easy to reason. For example I am ready to admit that lazy evaluation causes more difficulty in reasoning how much time and space, and indeed by the time you go lazy I/O (e.g., getContents) it gets close to a black art.
12:12:06 <bollu> EvanR: what? I didn't know this :O
12:12:15 <Sornaensis> you mean like converting a C math function into a pure haskell function?
12:12:20 <bollu> EvanR: well fuck, I think I need to and rewrite a bunch of code
12:12:22 <bollu> Sornaensis: yeah
12:12:27 <bollu> EvanR: link?
12:12:33 <EvanR> yes, import sine from math.h and hook it up as pure, ok hold on
12:12:58 <EvanR> https://en.wikibooks.org/wiki/Haskell/FFI#Calling_a_pure_C_function
12:13:02 <EvanR> you just dont put IO in the type sig
12:13:14 <monochrom> So for example if you are just writing 10 lines of code and you don't know that you're writing an infinite loop by mistake, that's some indication of difficulty to reason.
12:13:17 <bollu> EvanR: what if you need to call a "collection of functions" which are pure when taken together?
12:13:24 <thoughtpolice> EvanR: That doesn't work if your function is still conceptually pure, but might need e.g. a temporarily allocated memory buffer. This is a case where the FFI signature doesn't work; but unsafePerformIO does.
12:13:31 <Cale> EvanR: Well, sometimes you want to do some extra marshalling around the thing before it's properly a pure function, so you can't just import it at a non-IO type
12:14:01 <EvanR> yes unsafePerformIO is necessary sometimes when you have to do other stuff
12:14:09 <EvanR> but if its just pure, theres this
12:14:19 <Aruro> monochrom: in same way how haskell elders discourage naive recursion, its there but dont use it.
12:14:36 <Aruro> use fold and such.
12:14:45 <bollu> Cale, EvanR: can I do that with this? https://github.com/bollu/symengine.hs/blob/master/src/Symengine/BasicSym.hs#L106
12:14:57 <bollu> or this? https://github.com/bollu/symengine.hs/blob/master/src/Symengine/BasicSym.hs#L162
12:14:57 <monochrom> I don't quite agree that it's the same way, or rather the same degree.
12:15:04 <Sornaensis> Aruro: what's wrong with naïve recursion
12:15:17 <Aruro> Sornaensis: easy to do mistakes
12:15:20 <Aruro> sadly
12:15:36 <EvanR> i use it all the time, unless theres a canned pattern already implemented as a higher order function
12:15:53 <monochrom> For ordinary recursion there is a very good rule of thumb (refinable to exact condition) for termination. "The argument has to be 'smaller'."
12:15:58 <EvanR> for loops in IO too
12:16:21 <monochrom> But it looks like with reflex you don't even have this much help.
12:16:27 <ongy> I feel like the work put into a fold is the same as naive recursion for me. Just that it's more thinking than typing, which I like better
12:16:35 <EvanR> the argument doesnt have to be smaller to ensure termination
12:16:40 <EvanR> it just does if it is
12:18:33 <Aruro> also easier create leaks with naive recursion, i guess that was one of the reasons people discouraging it
12:18:35 <fresheyeball> ertes: EvanR: I agree limiting reflex-dom to disallow IO would not provide much benefit
12:18:52 <EvanR> i wasnt in that conversation
12:19:03 <fresheyeball> EvanR: appologizies 
12:19:12 <EvanR> what is "naive recursion" ?
12:19:15 <fresheyeball> I wish weechat had spellcheck
12:19:34 <Aruro> EvanR: when u dont use folds and write like beginner?
12:20:01 <Aruro> and haskell does not like that.
12:20:01 <EvanR> when you use recursion but it ends up being inefficient in some way?
12:20:07 <Aruro> yeah
12:20:12 <EvanR> hmm.
12:20:34 <Aruro> foldl' is classic example
12:20:37 <Aruro> of this trap
12:21:08 <EvanR> so you wouldnt call the recursion that implements folds or list processing algorithms to be naive
12:21:44 <Aruro> beginners will rarely write it from first attempt
12:21:45 <EvanR> im not sure naive is the right word for inefficient
12:22:14 <Aruro> no, inefficiency is problem of language not writing style
12:22:26 <ongy> would anyone come up with the definition currently in GHC library on a first try?
12:22:45 <EvanR> hole in 1
12:22:54 <monochrom> No no no, I'm sure half of this is a few "elders" unreaonsably scaremongering against writing your own recursion, and the other half of this is the readers of said "elders" adding further misunderstandings.
12:23:39 <EvanR> oh yeah i forgot to even consider who the heck these elders are or if they exist
12:23:50 <Aruro> monochrom: u dont get it. to think like u u need time wasted on experimenting.
12:23:51 <EvanR> the cabal
12:23:56 <monochrom> For example it was foldl and foldr, the canned recursion, that would use more space than ideal. (And no, I refuse to say "space leak" which connotes not knowing why.)
12:24:08 <fresheyeball> what is wrong with foldl?
12:24:40 <monochrom> And until foldl' appeared, it is writing your own recursion that allowed you to place "seq" at the place you want to reduce space usage.
12:24:43 <bollu> who are the elders?
12:24:59 <MarcelineVQ> we don't speak of the elders
12:25:04 <Aruro> monochrom: seriously? writing recursion with seq? at beginner level?
12:25:08 <Aruro> good one
12:25:22 <Cale> fresheyeball: foldl without strictness analysis will result in accumulating large expressions before evaluating them -- if the function which it's applied to then pattern matches its argument, you can end up with a stack overflow
12:25:31 <monochrom> Seriously, no, I am not talking about beginners.
12:26:02 <Cale> Usually strictness analysis (which gets turned on by -O) will catch that -- at least in most cases.
12:26:05 <EvanR> i guess Cale is pretty elderly
12:26:13 <Cale> But usually you don't want to leave it to chance.
12:26:25 <monochrom> And still, seriously, beginners need to learn how to write their own recursion too. Maybe without seq at first. But beginners would be not in a position to worry about space usage either.
12:26:32 <Tuplanolla> Glasgow Haskell Chance.
12:26:32 <fresheyeball> What would you advise instead of foldl?
12:26:37 <Cale> foldl'
12:26:42 <EvanR> bang patterns man
12:26:46 <EvanR> way better
12:26:47 <Cale> when the function doing the combining is strict
12:26:56 <fresheyeball> ouch
12:27:09 <Aruro> monochrom: if beginners will see all haskell mess from start, i doubt the will like it
12:27:09 <fresheyeball> thats no good
12:27:15 <Cale> fresheyeball: what?
12:27:16 <fresheyeball> the effiecent version is prime?
12:27:31 <Cale> Well, the stricter version is prime
12:27:35 <monochrom> I was a beginner and I took it.
12:27:38 <EvanR> its not about efficient, they act differently
12:27:46 <fresheyeball> the advisable version should be the cannonical version
12:27:51 <monochrom> Also, the mess can't be hidden.
12:27:54 <Cale> foldl' might in other cases do more work than is necessary
12:27:56 <EvanR> and the unprimed one is just useful 0.0% of the time
12:28:03 <Cale> But usually it's the one you want, yes.
12:28:18 <monochrom> You teach them foldr (hey they are "beginners"!), they enter "foldr (+) 0 whatever" in ghci, they will know.
12:28:20 <Cale> Actually foldl is just fine like 95% of the time or something
12:28:28 <Cale> so long as you turn on optimisations
12:28:45 <Cale> The strictness analyser is pretty good at its job
12:28:46 <EvanR> i mean, specifically when you need lazy foldl
12:28:56 <EvanR> is rare to never
12:28:57 <Cale> reverse :)
12:29:06 <Cale> reverse and that's almost all :)
12:29:07 <ongy> Cale: when does the strict version do work, that's not required? for fold I actually don't know
12:29:23 <monochrom> But I was not even talking about that. I was talking about how hard or easy it is to play safe when writing recursion.
12:29:25 <dolio> last
12:29:26 <Cale> Well, there are some other cases
12:29:27 <Cale> yeah
12:30:19 <ongy> ohhh, right. because reverse builds another list. So it can be more efficient, when we build another lazy structure and don't consume all of that?
12:31:02 <monochrom> Actually foldl and foldl' do the same thing if you use them for reverse.
12:31:10 <Cale> ongy: yeah
12:31:26 <Cale> monochrom: Is the code identical? It might be.
12:31:33 <monochrom> There is no difference between "f (x : y)" and  "f $! (x : y)"
12:31:39 <EvanR> so you might need lazy foldl for last, and thats it
12:32:02 <monochrom> The code is not identical but I'm saying reverse's accumulator is in whnf by construction.
12:32:08 <Cale> ah, okay
12:32:18 <ongy> What difference does it make for last?
12:32:20 <Cale> Yeah, it's only a tiny bit worse... at worst :)
12:32:20 <LAZAR> Wow.... https://www.cis.upenn.edu/~cis194 just compare the 2013 with the 2016 version O.o the current version is like 100% worse with a focus on graphics to make it easier
12:32:36 <Cale> Semantically, it's the same
12:33:00 <Cale> LAZAR: Each year is different
12:33:10 <monochrom> last is a bit problematic.
12:33:49 <LAZAR> lol the last is ENTIRELY different i mean for someone who has programmed quite a bit it feels like going back to Logo
12:34:05 <monochrom> err, I don't actually know how to use foldl for last. I'll have to see it before I can predict.
12:37:05 <Cale> @src foldl1
12:37:06 <lambdabot> foldl1 f (x:xs) = foldl f x xs
12:37:06 <lambdabot> foldl1 _ []     = undefined
12:38:20 <Cale> > foldl1 (\_ x -> x) [1..10]
12:38:22 <lambdabot>  10
12:39:57 <monochrom> @type foldl
12:39:59 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:41:25 <monochrom> @src foldl
12:41:25 <lambdabot> foldl f z []     = z
12:41:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:42:23 <monochrom> Oh that's interesting, foldl' will seq the individual items.
12:43:09 <monochrom> If you have "foldl' (\_ x -> x) undefined [undefined, undefined, 5]" for last, you won't get your 5.
12:52:42 <LAZAR> How do I load multiple source files in ghci?
12:57:55 <Tuplanolla> Use `import`, LAZAR?
12:58:14 <LAZAR> like import file1 file2 file3?
12:58:31 <Tuplanolla> Like importing any other module.
12:59:08 <LAZAR> I only know :module and :load
12:59:35 <Tuplanolla> Have you never written `import Data.List` etc?
13:03:18 <LAZAR> nope, mainly used ghci by now
13:04:02 <Tuplanolla> Well, you can do that. Give your module a name, put it into `Name.hs` and `import Name`.
13:04:11 <thoughtpolice> You can also do `:m+ Module.Name" fwiw
13:04:56 <LAZAR> https://www.cis.upenn.edu/~cis194/spring15/lectures.html The first Expercise... you need to load the HW01Tests into GHCI
13:06:52 <LAZAR> when entering :module +HW10Tests it cant find the module even tho its in the same dir
13:07:20 <LAZAR> *HW01Tests
13:10:17 <monochrom> It's :load not :module for your own code.
13:10:27 <LAZAR> oh
13:10:32 <monochrom> Whereas it's :module or import for a library.
13:11:10 <LAZAR> wait but :load only loads one module? if i load one specific file, Prelude and any other ones will not be loaded any more
13:11:18 <monochrom> Also, my "your own" is inaccurate. It's whatever source code sitting right in front of you, include your own but also school's.
13:11:29 <monochrom> That is not true.
13:11:36 <monochrom> And a simple test will show it.
13:11:51 <monochrom> :load something and ask about 4+5.
13:12:20 <Sornaensis> > 3 :+ 1
13:12:22 <lambdabot>  3 :+ 1
13:12:25 <Sornaensis> > 3 :+ 1 * 2
13:12:27 <lambdabot>  3 :+ 2
13:12:32 <Sornaensis> > (3 :+ 1) * 2
13:12:34 <lambdabot>  6.0 :+ 2.0
13:13:49 <LAZAR> Well after :load HW01Tests.hs and again :load myownfile.hs i can no longer access the files of HW01Tests
13:13:51 <Aruro> is there any extension which allows to write map (+1+2) list ?
13:14:29 <Aruro> simplifying lambdas of the form \x->x+y+z
13:16:30 <monochrom> Does myownfile.hs import HW01Tests? Or the other way round?
13:16:32 <MarcelineVQ> :t (+1) . (+2)
13:16:33 <lambdabot> Num c => c -> c
13:16:35 <rightfold> I have written bytecode interpreters before, but never for a lazy language, and I would like to find out more on this matter. The GHC bytecode language and interpreter are quite complex, is there something similar and more educational out there?
13:18:33 <Aruro> MarcelineVQ: writing lambda becomes shorter than composition :)
13:19:06 <Aruro> especially if number of terms grows
13:25:26 <LAZAR> Can someone help me with https://www.cis.upenn.edu/~cis194/spring15/hw/01-intro.pdf ? I have no idea how to import both my own and the testing files in ghci... it always tells me the test files are inaccessible from within ghci
13:26:46 <mauke> how are you loading it?
13:27:06 <Aruro> LAZAR: u just said u have big programming experience :) or I overheard?
13:29:11 <LAZAR> I literally said I have programmed quite a bit. I added an import to my file and GHCI loads them, yet they are not accessible
13:30:30 <clmg> Who likes puzzles? I have a tree and I am traversing it. I need to delete one branch using lenses. How?
13:30:49 <LAZAR> Aruro: http://lpaste.net/354589
13:31:03 <clmg> Specifially, one child of a parent needs to become the parent, and the other child needs to disappear
13:32:00 <dfeuer> clmg: if you really want to do that, I think you'll need to build the lens as you traverse the tree. But why do you want to do that with lenses?
13:32:01 <MarcelineVQ> can you lpaste the module that defines runTests?
13:32:49 <LAZAR> MarcelineVQ: Check the pdf, runTests should be defined in either of them (all of them are loaded)
13:33:09 <Aruro> LAZAR: something is not in scope, modules have been loaded
13:33:26 <LAZAR> runTests is in Testing
13:33:36 <Aruro> LAZAR: does it export it?
13:33:55 <LAZAR> it was listed when using _browse so i guess they are exported?
13:35:39 <Aruro> before error u typed browse?
13:36:07 <r33ky> hi
13:36:20 <dmwit> LAZAR: Which module exports `runTests` and `ex1Tests'?
13:36:31 <MarcelineVQ> try typeing   import Testing   in ghci after loading validate.hs
13:36:39 <dmwit> LAZAR: Currently, only `Main`s definitions are in scope (see the "*Main" prompt).
13:36:57 <mauke> LAZAR: what's the first line of validate.hs?
13:38:00 <LAZAR> Here is the full outPut: http://lpaste.net/279110524199763968
13:38:35 <LAZAR> validate.hs starts with {-# OPTIONS_GHC -Wall #-} (newline) import HW01Tests()
13:38:58 <monochrom> Yikes, don't put () there, it defeats the point of your import.
13:39:10 <erisco> that means to import nothing
13:39:12 <Aruro> LAZAR: do u need to do homework? read course and move on to real world
13:39:19 <mauke> Aruro: dude, stop
13:39:22 <mauke> what are you doing
13:39:23 <dmwit> LAZAR: Use `:m + Testing HW01Tests` to bring those module's exports into scope.
13:39:35 <monochrom> What is the assignment URL again?
13:39:42 <mauke> /lhttps://www.cis.upenn.edu/~cis194/spring15/hw/01-intro.pdf
13:39:47 <monochrom> Thanks.
13:39:49 <mauke> https://www.cis.upenn.edu/~cis194/spring15/hw/01-intro.pdf
13:39:52 <Aruro> mauke: towers of hanoi as first homework in haskell? what am i doing?
13:40:36 <Aruro> no first how to import export, how to use ghci
13:40:42 <Aruro> straight to math.
13:41:21 <mauke> Aruro: it looks like what you're doing is to annoy LAZAR
13:41:22 <mauke> or me
13:41:43 <Aruro> mauke: i asked if he has to do it? whats wrong with that?
13:42:04 <LAZAR> Aruro: Lol check the date of the course please. ;-)
13:42:15 <LAZAR> Spring 2015
13:42:18 <monochrom> LAZAR: It looks like you should be able to just :load HW01Tests and have everything, because it already imports everything.
13:42:22 <mauke> ok, it might also be a language barrier issue
13:42:36 <monochrom> And you should be putting your solution in HW01.hs
13:42:42 <LAZAR> monochrom: well that would not import my own code right?
13:42:51 <LAZAR> oh well thats true
13:43:01 <LAZAR> but why is this such a hassle?
13:43:22 <monochrom> Because not following the assignment down to the letters?
13:43:55 <monochrom> To be sure, it can be done without following it exactly, but then you need to know much more about ghci.
13:47:34 <Aruro> LAZAR: ironically these issues described in last lecture http://www.seas.upenn.edu/~cis194/spring15/lectures/13-building.html
13:52:24 <Aruro> LAZAR: you can consul also GHC manual (which is good) https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html
13:55:54 <Aruro> LAZAR: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#what-s-really-in-scope-at-the-prompt
13:56:33 <EvanR> rightfold: the keywords for this is graph reduction machine, and theres a book on it "implementation of functional programming languages"
13:56:51 <rightfold> EvanR: thanks!
13:57:05 <EvanR> and its availble in electronic form for free https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/
13:57:45 <Cale> rightfold: also https://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
13:57:48 <EvanR> ghc itself has advanced past the material in the book but personally i need a foundation
13:57:59 <rightfold> Cale: thanks!
14:02:39 <Gurkenglas__> clmg, you telescope down into the parent node (similar to https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Cofree.html#v:telescoped ) and %~ it by _rightChild?
14:09:50 <AntonF> Hello everyone. I have quite a silly question: what is best up to date minimal vim plugin for Haskell? Say, reasonable indentation is all I want. Thanks in advance.
14:13:34 <clmg> Gurkenglas: I'm new to lenses. I feel like what I'm trying to do shouldn't be that complicated
14:14:07 <clmg> When I traverse the tree I'm looking for a node with a branch of a specific name. If the branch has that name, destroy its brother and replace the parent with the child.
14:14:13 <clmg> http://lpaste.net/354592
14:14:19 <clmg> That's the code I wrote to do it
14:14:24 <Cale> AntonF: set expandtab, set smarttab, set autoindent
14:14:41 <clmg> However, when I call that method on my tree it /erases the entire tree/
14:14:42 <clmg> why????????
14:14:45 <clmg> why why why
14:14:52 <clmg> I've been working on this for so long
14:15:00 <Sonolin> yea I don't think I even have any hs related vim plugins :)
14:15:05 <Sonolin> although a smart indent one would be nice
14:15:28 <Sonolin> i.e. something to keep vertical lines/blocks indented at the same level
14:15:33 <clmg> A Split is either (Split Direction Split Split Nothing) or (Split Nothing Nothing Nothing Window)
14:15:49 <clmg> That is, it's either has two children or it is a leaf
14:16:26 <Cale> Sonolin: Yeah, it would be nice if any edit which caused the first non-whitespace character following a layout keyword to move would cause the entire rest of the block to move accordingly
14:16:48 <Cale> (in any text editor)
14:17:19 <Cale> That feature would singlehandedly be enough to get me to switch to whatever text editor it was that supported it.
14:18:01 <geekosaur> structured-haskell-mode, anyone? :p
14:18:10 <AntonF> Cale: I would also want guard statements to be aligned along ='s
14:18:15 * geekosaur now remembers playing with syntax-directed editors in the 90s
14:18:33 <geekosaur> inspired by "Alice: The Personal Pascal"
14:18:43 <Cale> geekosaur: No, that's way too annoying
14:19:38 <raichoo> AntonF: Not sure if it fits your needs, but it's the one I develop and use at work every day. https://github.com/neovimhaskell/haskell-vim
14:20:06 <raichoo> It's opinionated though.
14:21:13 <monochrom> structured-haskell-mode is not a vim plugin :)
14:21:14 <geekosaur> hm, actually that was mid-late 80s
14:21:31 <AntonF> raichoo: thanks, I will have a look
14:22:29 <Sh4rPEYE> Hey! I'm doing some tasks on CW and I stumbled upon this kata called "Functional streams". First they define infinite sequence like this:
14:22:30 <Sh4rPEYE> data Stream a = S a (Stream a)
14:22:33 <clmg> Did anyone respond to my lpaste I got dc'd
14:22:38 <Sh4rPEYE> But then they write:
14:22:44 <Sh4rPEYE> -- Note: We will define Stream with the equivalent infix operator constructor.
14:22:44 <Sh4rPEYE> data Stream a = a :> Stream a
14:23:05 <EvanR> seems legit
14:23:09 <Sh4rPEYE> What does the last line mean? I guess the dame as the first one, but what is this (:>)?
14:23:21 <EvanR> its just like S, only infix
14:23:24 <Sonolin> Cale: I believe Spacemacs had something similar to this I quite liked
14:23:35 <Sonolin> although its definitely much more than another editor 
14:23:40 <Cale> Yeah, they just renamed S to :> which is then written infix because it's a name made of symbol characters.
14:24:07 <Sh4rPEYE> Oh, so just and arbitrary name for a function that constructs a Stream, one might say?
14:24:09 <EvanR> Sh4rPEYE: you know [1,2,3] is sugar for 1:2:3:[], (:) is the infix constructor for lists
14:24:34 <Gurkenglas> clmg, then why isn't it "data Split = Split { _direction :: Direction, _left :: Split, _right :: Split } | Window { _window :: Window }"?
14:24:35 <mauke> Sh4rPEYE: data Stream a = (:>) a (Stream a)
14:24:36 <Cale> Sh4rPEYE: yep
14:25:15 <EvanR> with that (:>) you could write let x = 1 :> 2 :> 3 :> x
14:25:21 <EvanR> in x
14:25:25 <Sh4rPEYE> Oh, of course. Thanks! I saw (:>) in Sequences and I was quite take aback when I saw it used here... I somehow though it was that one
14:25:37 <EvanR> yeah its colliding with Sequence
14:27:37 <Sh4rPEYE> EvanR: Just to verify, the headStream would simply look like this then:
14:27:38 <Sh4rPEYE> headS (x :> xs) = xs
14:27:52 <Cale> That would be tail
14:28:03 <Sh4rPEYE> Oh, ofc, pasted the wrong one
14:28:36 <EvanR> unlike list head, stream head is totally safe!
14:28:56 <monochrom> And stream last is totally unsafe!
14:29:52 <EvanR> a stream always has a beginning, by construction
14:30:34 <Sh4rPEYE> Yes
14:38:06 <dmwit> monochrom: (untotally safe?)
14:39:29 <Gurkenglas> What libraries should I use to write a web IRC client?
14:41:03 <Gurkenglas> Hmm. Scratch web, unless it's convenient, for I guess locally would be fine too and I don't actually have a server
14:42:44 <EvanR> https://hackage.haskell.org/package/irc-client
14:42:52 <Eduard_Munteanu> Gurkenglas, I'd say servant for a REST/WebSockets <-> IRC gateway, and ghcjs/Elm/etc. for the client app
14:44:01 <jle`> bollu: pong?
14:57:46 <EvanR> ok
14:57:50 <EvanR> Data.Unique
14:58:22 <EvanR> is based on a global IORef containing a counter that starts at 0
14:58:49 <EvanR> something doesnt seem that unique to me about this
14:59:41 <EvanR> also if the program runs a long time, the counter just increases forever
14:59:47 * geekosaur thinks this sounds like Data.Unique is just lisp's gensym
15:02:32 <EvanR> so then i looked at Data.Unique.Really
15:02:58 <EvanR> which is based on Data.Unique, but then does a evaluate then a makeStableName on the unique value.
15:03:53 <EvanR> is it really guaranteed that the stable names wont compare equal for "different" values of the unique?
15:04:10 <EvanR> like one unique 0 vs "another"
15:06:47 <erisco> newtype X a b = X (a -> (b, X a b))   I sense this fits some known pattern
15:07:09 <EvanR> its a state machine
15:07:46 <erisco> I am looking for packages that have elaborated on this type
15:08:04 <EvanR> theres a few by ekmett im sure
15:08:35 <EvanR> https://hackage.haskell.org/package/machines-0.6.1/docs/Data-Machine-Mealy.html
15:10:48 <EvanR> so if a program is utilizing Integer counter as a source of unique IDs, and it just keeps counting up
15:10:59 <EvanR> and it runs indefinitely
15:11:09 <EvanR> and you have 1G of ram
15:11:16 <EvanR> what can you say about the reliability of this program?
15:11:34 <erisco> lets do some maths to see how quickly you can fill the RAM
15:11:57 <erisco> assuming, say, we increment the integer at 1Ghz
15:12:41 <MarcelineVQ> EvanR: not to sound too glib but it may say that you need a better way to go about using your uniques if your integer is reaching 1gb
15:13:01 <EvanR> is an integer the size of 1G even possible
15:13:13 <geekosaur> even on 32 bit you get over 2GB
15:13:19 <geekosaur> oh, that size, nm
15:13:31 <EvanR> size in memory
15:13:40 <geekosaur> I think you could get an Integer that big, but now I will echo MarcelineVQ :)
15:13:53 <EvanR> by incrementing?
15:14:11 <geekosaur> you seriously need to rethink what you're doing if you're generating them that much
15:14:19 <erisco> I have a feeling you won't count to 2^(10^9) any time soon
15:14:37 <geekosaur> because, really, you can't do much better than what it is doing.
15:14:53 <EvanR> the rate of generating them is not going to be 1GHz or even 1MHz, its a reasonable usage of the generator, but even at 1GHz it seems like a combinatorial physical impossibility
15:15:06 <geekosaur> most of the alternatives are even larger, and if you're seriously worried about a 1GB size int you can;t even think about the usual UUID / GUOID setup
15:16:15 <EvanR> this feels weird
15:16:18 <erisco> it has 301 million decimal digits, according to Wolfram
15:16:41 <EvanR> is it on the same level of implausibility as getting a non-unique UUID
15:18:51 <erisco> for reference, this number is about 10^100000000 and the number of grains of sand on Earth is about 10^24
15:19:18 <EvanR> heres the use case, in a video game enemies will spawn and get a unique ID. but then they will eventually disappear, after that the IDs might still be lingering somewhere
15:19:29 <EvanR> so if you reuse them, it could go haywire
15:19:37 <erisco> and the number of atoms in the universe is 10^80
15:20:17 <Tuplanolla> You can apply the concept of garbage collection to identifiers too, EvanR.
15:20:19 <MarcelineVQ> for a video game I would simply keep a set of what's in use
15:20:45 <Tuplanolla> Go through the live set and see if an identifier is no longer in use anywhere.
15:20:48 <EvanR> the tables have keys for whats in use, but that doesnt tell you what is holding onto this numbers
15:21:08 <MarcelineVQ> If you need to track a history of enemies then a unique could matter more, i fact I need to do something related for a side-project I have so this is a useful convo
15:21:54 <EvanR> Tuplanolla: yes thats how the same issue doesnt come up with pointers
15:22:11 <EvanR> the object isnt retired until *no one has a reference period*
15:22:21 <EvanR> but i want to be able to manually delete 
15:22:28 <erisco> okay, but, I think it is clear that if we're alright with using Integer that there just isn't a problem
15:22:49 <EvanR> yes this tangent is "figure out a better way to use your uniques"
15:23:54 <erisco> if you add bookkeeping cost to IDs then you limit the number you can issue in real time
15:24:09 <erisco> other than simplicity, this is one reason you'll see such a system in games
15:24:40 <EvanR> would a 64-bit Int be just as good?
15:24:55 <EvanR> im having a hard time coming back to programmer mode rather than math mode
15:25:33 <erisco> well, if you see my napkin math above it is mathematically clear that we don't have enough time to observe a problem
15:25:39 <Tuplanolla> I've seen a monitoring system written in SDL run out of frame numbers and jam firsthand.
15:25:41 <EvanR> heh
15:25:48 <erisco> for 64-bit I am not sure, but you can do the same sort of analysis again
15:26:02 <erisco> how quickly are you issuing IDs and how long can any ID live?
15:26:03 <Tuplanolla> (It uses its own `Uint32`.)
15:26:11 <EvanR> yes 32-bit regularly overflows in reality
15:26:14 <erisco> the lifetime is relevant wrt the rollover of a 64-bit integer
15:26:43 <EvanR> well, a max of 1GHz covers anything a PC can ever do
15:26:57 <EvanR> itll never be that fast
15:27:08 <geekosaur> erisco, I can see a busy MMORPG server generating uniques often enough to require resetting monthly or so to avoid 64-bit rollover
15:27:15 <erisco> even with rollover, if your life times are short enough you can guarantee (or have be likely) that IDs will not collide
15:28:00 <EvanR> the max Int is a little under ten billion billion right
15:28:03 <erisco> and if you have objects of hugely different life times you can consider separate ID spaces for them
15:28:05 <geekosaur> Integer should work for one that'll be up for a while, but really I'd want better management at that point --- you have bigger problems than reuse, if stuff is hanging around beyond when it should then you're leaking more than Uniques and your players will be very unhappy
15:28:15 <Gurkenglas> Physics as we know it do not permit incrementing numbers to exceed 2^400. https://arxiv.org/abs/quant-ph/0110141
15:28:21 <geekosaur> (and so will the server operator, and so will you when the OOM killer triggers)
15:28:27 <erisco> so, for example, player characters in your MMORPG, which exist for years, may have a separate ID space from the mobs that live for just a few minutes or hours
15:29:10 <EvanR> im definitely trying to avoid completely unnecesssary optimizations
15:29:13 <geekosaur> I can imagine an item taken off a mob member retaining *something* about said member. that said it should clone what it needs rather than keeping the mobber around
15:29:37 <geekosaur> again, this isn;t just uniques leaking, this is a memory leak that will crash your game eventually
15:29:38 <EvanR> maybe 128-bit Int then ;)
15:29:44 <Tuplanolla> My main issue is that it's unsatisfying to an obsessive mind.
15:29:56 <EvanR> Tuplanolla: heh
15:32:26 <EvanR> so the answer really is... dont have bugs that involve lingering IDs for things that shouldve been logically deleted
15:32:31 <erisco> machines are limited
15:32:34 <EvanR> and then just use the least unused number
15:32:42 <erisco> limited RAM, time, space
15:32:58 <Rembane> You cannot have the last digit of pi. :(
15:33:14 <erisco> so estimate the limitations and plan to be well within those margins
15:33:32 <EvanR> well haskell doesnt give you tight guarantees of that
15:34:09 <EvanR> i have no idea how much memory ill need, my tests indicate i could be using constant 75k of memory while not obviously allocating more and more stuff
15:34:33 <EvanR> but who knows
15:34:58 <EvanR> an incrementing Integer causes that number to slowly creep up
15:35:17 <erisco> start with a guess of how many IDs you will issue per game update (worst case)
15:35:44 <dmwit> geekosaur: You can see a busy MMORPG issuing trillions of IDs per second?
15:35:45 <erisco> then guess how long the game has to be running continuously
15:35:50 <dmwit> > 2^64/31/24/60/60
15:35:51 <EvanR> much less than 1 since it would only happen if you spawn or remove objects
15:35:52 <lambdabot>  6.887225236600041e12
15:36:16 <erisco> then see what size of integer you need so that you won't run out of IDs
15:36:45 <dmwit> You're gonna need 1000 servers doing nothing but issuing IDs and managing to do that in only a few cycles per ID.
15:37:07 <EvanR> this is an arcade game for a bar that is 100 years old, so theres no telling how long it will continue standing
15:37:21 <erisco> there are games you can leave running for months or a year or more and they actually do overflow
15:37:31 <EvanR> yeah i consider those shit
15:37:32 <erisco> some funny things you can see on YouTube ;)
15:37:55 <EvanR> oh, the power is probably going to go out and reset it from time to time...
15:38:02 <erisco> such as Peach baking a cake has to cook it for just the right amount of time
15:38:18 <erisco> which is either about 30 seconds or some many months plus 30 seconds :P
15:39:38 <erisco> but if you think ahead you can set the bar to be absurd, such as requiring a hundred years or more
15:40:43 <EvanR> > 2**64 / 10**9 / (86400 * 365)
15:40:45 <lambdabot>  584.942417355072
15:40:52 <EvanR> 584 years 
15:40:59 <EvanR> > 2**63 / 10**9 / (86400 * 365)
15:41:01 <lambdabot>  292.471208677536
15:41:06 <EvanR> uhg
15:44:15 <erisco> another overflow is in Hearthstone where there is an ability to double HP, so it exponentially grows
15:44:38 <erisco> therefore in not many steps (though in context of the game it is absurd to make happen) you can overflow the HP
15:44:49 <erisco> and HP less than zero kills :P
15:45:22 <erisco> but that's doubling and with IDs we're only incrementing
15:46:23 <EvanR> process ids seem to just go up until you reboot
15:46:29 <EvanR> i wonder
15:46:56 <Tuplanolla> They're recycled every now and then.
15:46:57 <dolio> In Final Fantasy Mystic Quest, you can kill the final boss by curing him, because of an overflow.
15:47:55 <dolio> Only one of the characters is able to do it, though.
15:49:29 <EvanR> i want to make a fake "kill screen" which simulates the sort of problems old arcade games had with this, but having it affect normal game play would be embarassing!
15:50:25 <Tuplanolla> Back then you could reprogram the game with just the controller, the way it should be.
15:50:58 <EvanR> that would be cool too but i havent figured out a proper language for that
15:51:42 <Tuplanolla> I guess you'd need a virtual machine without a memory protection model.
15:53:20 <hpc> Tuplanolla: that's easy, just make it in flash
15:55:41 <diegonolan> @pl \a b -> a * b - 3 * b
15:55:41 <lambdabot> (`ap` (3 *)) . ((-) .) . (*)
16:12:07 <joe9>  I want to get the interval between 2 UTCTime's. I see diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime  . But, I cannot figure out how to get the seconds from the NominalDiffTime. Can anyone please help?
16:12:30 <joe9> > :t realToFrac (100 :: NominalDiffTime) :: Integer
16:12:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:12:42 <joe9>  http://codepad.org/qkOGdvlx
16:13:45 <joe9> there is a diffTimeToPicoseconds but nothing from NominalDiffTime
16:18:20 <joe9> got it , round . realToFrac
16:50:36 <monochrom> If your program can't fit in constant space, then the next best thing is log-space and it isn't all that bad.
16:52:36 <monochrom> For example if it has taken no less than 10 days for your unique IDs to need n bits, then it will take 10 more days to grow that need to n+1 bits.
16:56:10 <monochrom> And then 20 more days before you need n+2 bits. In general going from n bits to 2n bits takes exponential time.
16:56:46 <monochrom> Pretty sweet deal if you asked me, short of outright free lunch.
17:02:57 <hpc> i always thought free breakfast was more satisfying
17:04:29 <monochrom> Haha neat, this coincides with how you can grow array size and still get amortized O(1) time. You need one more bit for your IDs right when you need to double your array size. How neat is that.
17:05:34 <monochrom> I want free steak dinner.
17:08:56 <julianleviston> I have a few questions about dynamic context “introspection”: is there a way I can determine a list of the available declarations and their types within a particular point in the source? I’ve done a fair bit of research into this area in that I’ve looked at and used hint, Language.Haskell.Exts and Control.Lens quite a bit, and had a look into Dynamic. So I know I can get a list of the exports of a module with h
17:08:56 <julianleviston> for example. This ends up being [String], and I could coerce that to [Dynamic], but I’m not sure how I’d get *local* (this-module/this-file/within-this-function) declarations, also this brings me to my subsequent question… (which I’ll provide after this one)
17:11:22 <iqubic> Hello everyone.
17:17:34 <julianleviston> Once I have these declarations, I’d like to filter them to determine which ones *could* be put into a lensed focus, which is where things get *really* tricky, because a) I don’t know how to filter [Dynamic] based on type, and b) I’d have to match on the *return* type, so I can’t do this statically with AST (AFAIK). Also I have the issue that things would have to be an instance of Typeable, so no polymorphic 
17:17:35 <julianleviston> declarations… so that stickies things up a lot.
17:18:00 <julianleviston> I might put this up on stack overflow...
17:24:45 <Gurkenglas> julianleviston, Dynamic is internally just a runtime representation of a type and a magic Any value that allows coercion. A function type's TypeRep contains its argument and result type's TypeReps like any other datatype does it.
17:25:20 <julianleviston> Gurkenglas: Ooh… I’ve never even *heard* of TypeRep before.
17:25:46 <julianleviston> Is there also such a thing for non-function values?
17:26:34 <c_wraith> see Data.Typeable
17:26:39 <julianleviston> Ah it’s part of Data.Typeable
17:26:55 <julianleviston> Ok so that’s why it won’t work with non-concrete types.
17:27:12 <Gurkenglas> "data Dynamic = Dynamic TypeRep Obj" "splitTyConApp :: TypeRep -> (TyCon, [TypeRep])"
17:27:18 <julianleviston> very cool… (:~:) 
17:27:36 <geekosaur> also note that this is changing in 8.2.1 (try rc1 which is out now) in a way you might like
17:27:54 <c_wraith> if you need to represent a polymorphic type, wrap it in a monomorphic newtype
17:28:29 <julianleviston> yeah I knew I could do that, thanks :)
17:28:57 <julianleviston> ^ c_wraith sorry that was directed at you.
17:30:35 <julianleviston> Any answer to my actual first question tho? As in… How I could possibly get *local* declarations? Is the answer just to wrote it to a module and import it then get the exports using hint like that? I think that’d work, actually.
17:31:12 <julianleviston> also really not sure how to do this *inside* a function, but possibly that might be able to be done via traversing the AST and evaluating inner declarations with a new scope in hint… mmm
17:32:52 <Gurkenglas> "data S = forall a. S { worker :: a -> M (); jobs :: [a] }" <- I want to allow the user to supply code for a new worker (b -> M ()) and a morphism (a -> b) at runtime, and check whether the types match. What eval library should I use, and can this existential approach work?
17:34:28 <dijonmustard> So I'm wondering if my solution to generalizing access to a field was the right way to go about it. Can anyone chime in? It's pretty simple. https://pastebin.com/xySV6bKi
17:35:25 <Gurkenglas> (And is it just me or does System.Eval.Haskell not work at all, instead crashing at runtime complaining about GHC_PACKAGE_PATH when you try to use its eval?)
17:38:45 <julianleviston> Gurkenglas: I’ve only used hint, I think.
17:38:50 <julianleviston> Gurkenglas: works really well.
17:39:00 <Gurkenglas> dijonmustard, lens solves this problem. http://lpaste.net/3683558570902683648
17:41:58 <iqubic> Gurkenglas: Shouldn't that read MakeLens?
17:42:35 <iqubic> And what is the type of HasPosition?
17:43:00 <Gurkenglas> iqubic, makeLenses doesn't make typeclasses for it, so doesn't allow multiple both Person and Enemy to use position
17:43:41 <iqubic> So what does MakeField do?
17:43:44 <dijonmustard> wait, so does makeFields automatically generator typeclasses or something?
17:44:16 <iqubic> dijonmustard: You need to use the language pragma TemplateHaskell for that to work I think.
17:44:51 <dijonmustard> right, so is this just essentially generating my original code at compile time?
17:45:02 <iqubic> Yes.
17:45:07 <iqubic> It it is.
17:45:18 <iqubic> It is also making it easier to read.
17:45:41 <julianleviston> dijonmustard: it’s template haskell. It uses haskell to write boilerplate for building lenses for field access.
17:45:42 <iqubic> Gurkenglas: What the heck does makeFields do?
17:45:47 <dijonmustard> So lenses aside, my solution was correct?
17:45:58 <iqubic> Yeah, I think so.
17:46:04 <iqubic> Not too sure though.
17:46:09 <julianleviston> dijonmustard: looked good to me.
17:46:25 <iqubic> Gurkenglas: What does it mean for something to of type hasPosition?
17:46:57 <julianleviston> dijonmustard: typeclasses are pretty powerful, though, so might not wanna reach for them all the time straight away
17:47:55 <julianleviston> lenses are really nice because they compose (you can focus deeper on things when you have complex structure), and by making something a lens, you get all the general functions within the lens library (getters, setters, “over” which runs a function on the focussed thing, and many other things like `+=` etc)
17:48:35 <Gurkenglas> Oh shoot, makeFields makes "HasPosition Person Position" and "HasPosition Enemy Position". Is there a way to do that without the addition Position argument everywhere?
17:49:00 <julianleviston> dijonmustard: anytime you say “generalized access”, most Haskellers are going to say “lens”.
17:49:07 <iqubic> I still don't understand the difference between makeLenses and makeFields.
17:49:25 <Gurkenglas> iqubic, http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html
17:50:31 <dijonmustard> Okay cool. template haskell will be my next step. 
17:50:57 <puregreen> iqubic: docs for microlens have longer explanations for makeLenses and makeFields so you could try reading those: http://hackage.haskell.org/package/microlens-th-0.4.1.1/docs/Lens-Micro-TH.html#v:makeLenses, http://hackage.haskell.org/package/microlens-th-0.4.1.1/docs/Lens-Micro-TH.html#v:makeFields
17:51:16 <puregreen> in a nutshell, `makeFields` generates a class for each field name
17:51:17 <iqubic> What does makeClassy do?
17:52:15 <Gurkenglas> hint seems to require a witness of the type I want to create. Can I get out of the "data S = forall a. S { worker :: a -> M (); jobs :: [a] }"?
17:52:16 <Gurkenglas> *that
17:52:44 <puregreen> iqubic: makeClassy generates a class for each record type, not each name, and lets you do a kind of subtyping
17:53:02 <puregreen> it's the most complicated one to explain
17:53:32 <iqubic> What does that mean? If i have a record with 7 fields of different types, I get 7 different type classes?
17:53:56 <puregreen> with makeFields you get 7 different type classes even if all fields have the same type
17:54:06 <puregreen> with makeClassy you get one type class with 7 methods
17:54:31 <iqubic> I don't understand, but that's fine
17:55:13 <puregreen> okay, another example: if you have “Foo {fooX, fooY :: Int}” and “Bar {barY, barZ :: Int}”, you'll get three type classes with makeFields: “HasX”, “HasY”, “HasZ”
17:55:32 <puregreen> because there are three different names after you throw away prefixes
17:55:57 <puregreen> Foo will be an instance of HasX and HasY, Bar will be an instance of HasY and HasZ
17:56:00 <puregreen> is this clear so far?
18:00:07 <iqubic> Yeah, I got it.
18:00:24 <iqubic> I see why people say Haskell is the best imperative language.
18:02:20 <julianleviston> Gurkenglas: sounds pretty tricky… have you tried TH?
18:02:37 <Gurkenglas> How'd that help?
18:02:42 <julianleviston> Gurkenglas: I’m not sure why hint’s interpreter woudln’t work with what you’re trying to do, though.
18:03:38 <Gurkenglas> How does hint know what type to read "flip replicateM someaction :: Int -> M ()" as?
18:04:34 <dijonmustard> So trying to get Gurkenglas example of lenses to compile and as they said earlier 'makeFields makes "HasPosition Person Position"'. Can someone explain this to me?
18:05:31 <Gurkenglas> Well, it's going to work with http://lpaste.net/3683558570902683648#a354599 but that's ugly so the question remains
18:06:08 <Gurkenglas> (And you could do type Positional a = HasPosition a Position, but still)
18:06:46 <dijonmustard> what does that even mean to pass a type into a function?
18:07:03 <dijonmustard> is it someone specifying some polymorphic type?
18:07:06 <julianleviston> dijonmustard: where are you passing a type into a function?
18:07:31 <dijonmustard> oh nevermind, I just got it
18:07:42 <geekosaur> dijonmustard, thats a typeclass
18:07:44 <julianleviston> Gurkenglas: I haven’t really used hint like that. I build an expression as a string and then have it evaluate it and grab the result I’m after out and use that elsewhere. I guess it depends where the lines you’d like to draw in terms of evaluation are.
18:07:46 <geekosaur> instance
18:07:53 <dijonmustard> HasPosition Person Position is the typeclass with specified types
18:08:28 <julianleviston> dijonmustard:  `HasPosition Person Position` is a type, isn’t it?
18:09:06 <dijonmustard> yeah
18:09:09 <dijonmustard> makes sense
18:09:32 <mniip> constraindkinds!
18:09:39 <julianleviston> dijonmustard: oh sorry, I’m not sure what I’m talking about - I didn’t check what HasPosition was.
18:51:06 <seekr_> I'm trying to get GHC working in Windows 10, but the recently released Windows 10 Creators Update broke GHC. issue: https://ghc.haskell.org/trac/ghc/ticket/13411 . The link mentions a patched GHC, but I don't see where I can get it.
19:08:38 <geekosaur> http://downloads.haskell.org/~ghc/8.0.2/ghc-8.0.2-x86_64-unknown-mingw32-win10.tar.xz but it's still experimental I think
19:09:06 <geekosaur> (name may change so don't save a link to anything but that dir... they were still hashing this out within the past day)
19:17:12 <halogenandtoast> Could not deduce (Ord a0) arising from a use of ‘sortOn’
19:17:13 <halogenandtoast>       from the context: RandomGen g
19:17:26 <halogenandtoast> is there a way to say that the values from RandomGen should be in Ord?
19:20:38 <geekosaur> you can't poke an additional constraint into RandomGen but you can add your own constraints (RandomGen g, Ord g ) => ...
19:20:48 <halogenandtoast> related code: shuffle xs = (fmap (map snd . sortOn fst) . zip <$> getRandoms) <*> pure xs
19:21:14 <halogenandtoast> I think the problem is that I'm not in some other monad m
19:21:22 <halogenandtoast> getRandoms :: Random a => m [a]
19:21:37 <halogenandtoast> it works in GHCI because I'm in IO
19:21:43 <geekosaur> what is the type signature for shuffle?
19:21:44 <halogenandtoast> but it doesn't work in my code because I'm not
19:22:00 <geekosaur> this likely has nothing to do with IO, but with defaulting in ghci
19:22:17 <geekosaur> which has to be done per line instead of per file, so it likely inferred Integer early
19:22:18 <halogenandtoast> shuffle :: MonadRandom f => [b] -> f [b]
19:23:13 <geekosaur> actually that didn't help me as there appear to be several
19:23:26 <geekosaur> (and IO *is* relevant for one of them, it turns out)
19:23:48 <geekosaur> oh
19:24:04 <geekosaur> shuffle :: (MonadRandom f, Ord b) => [b] -> f [b]
19:24:51 <geekosaur> and, again, ghci will have been forced to figure out b early and picked Integer, so there's no problem with the Ord constraint.
19:25:16 <geekosaur> but in a file, MonadRandom likely blocks normal defaulting so you need to give more information. you'll run into even more of this later I suspect
19:26:33 <halogenandtoast> geekosaur: sortOn is being called on the result of getRandoms, not on b
19:27:26 <geekosaur> ok, then you need to force that type to something with an Ord instance.
19:27:54 <geekosaur> you cannot use defaulting here, unless you want to switch on {-# LANGUAGE ExtendedDefaultRules #-} like ghci uses
19:28:46 <halogenandtoast> It looks like I have only 2 instances of MonadRandom to work with
19:28:48 <halogenandtoast> IO and RandT
19:28:58 <halogenandtoast> but Rand should work hmm
19:29:13 <geekosaur> IO has nothing to do with sorting'
19:29:17 <geekosaur> IO is *not* the problem
19:30:22 <halogenandtoast> geekosaur: I wasnt claiming it was, but I might be addressing the wrong problem anyways
19:30:28 <halogenandtoast> I was trying to type case getRandoms
19:30:35 <halogenandtoast> getRandoms :: (Random a, MonadRandom m) => m [a]
19:30:38 <geekosaur> constrain it afterward
19:30:40 <halogenandtoast> so I needed some value for m
19:30:49 <halogenandtoast> :i MonadRandom
19:31:02 <halogenandtoast> instance [safe] MonadRandom IO
19:31:07 <halogenandtoast> instance (RandomGen g, Monad m) => MonadRandom (RandT g m)
19:31:11 <halogenandtoast> are the only instances
19:31:20 <geekosaur> yes, I already said you can;t do it there
19:31:33 <halogenandtoast> Okay then I guess I misunderstood
19:31:48 <halogenandtoast> I was trying to do something derpy like: shuffle xs = (fmap (map snd . sortOn fst) . zip <$> (getRandoms :: m [Int])) <*> pure xs
19:32:42 <geekosaur> I think you need something like: shuffle xs = (fmap (map snd . sortOn (fst :: (b,Int) -> Int)) . zip <$> getRandoms) <*> pure xs -- with ScopedTypeVariables and 'forall b.' in the signature
19:33:09 <geekosaur> unless you rearrange so you have something of the type to be sorted without other types involved
19:34:29 <halogenandtoast> This seems not worth the trouble :\
19:34:43 <halogenandtoast> I just wanted to get away from passing around StdGen
19:34:45 <geekosaur> this is one of the downsides of being clever with pointfree, the points are where you can inject type annotations sanely
19:35:08 <halogenandtoast> I didn't think I was being pointfree
19:35:11 <halogenandtoast> I pass in xs
19:35:33 <halogenandtoast> Or are you referring to internals
19:35:42 <geekosaur> internally, yes
19:36:01 <geekosaur> you pipeline the random stream through without ever exposing a point that could be used to type it
19:36:17 <geekosaur> without dragging in some other type, either that of xs or that of the monad
19:37:41 <geekosaur> :t (^)
19:37:42 <lambdabot> (Num a, Integral b) => a -> b -> a
19:38:22 <geekosaur> this is another (albeit simpler) example, one constantly gets warnings about defaulting for b because it's almost never used in a way that gives it an explicit type
19:39:26 <geekosaur> anyway you could try just turning on ExtendedDefaultRules for that file so it'll work more like ghci does
19:40:32 <geekosaur> I don't normally recommend that because it means things suddenly typecheck that wouldn't have before, by defaulting uselessly to ()
19:41:56 <halogenandtoast> Yeah I think I'll just pass StdGen around
19:42:31 <halogenandtoast> I was just trying to play with MonadRandom and shuffle a deck
19:45:26 <lpaste> halogenandtoast pasted “Main.hs” at http://lpaste.net/4255346991493545984
19:45:32 <halogenandtoast> for reference ^^
19:46:03 <halogenandtoast> I had a more complex example in another program, so I wanted to try with something rather isolated.
19:46:37 <halogenandtoast> The fact that initialDeck has to accept StdGen, but doesn't use it, made me feel like I wanted a Monad Transformer
19:46:51 <halogenandtoast> (in my actual program the StdGen gets passed down even more levels)
19:48:00 * geekosaur would have used the other MonadRandom (the package by that name), btw --- the parameter is the random type so it's easy to add an annotation, and it's just a state monad with methods that delegate to the actual RNG
19:48:22 <geekosaur> you're still "passing StdGen around" but it's done transparently
19:48:41 <geekosaur> instead of using a hidden IORef somewhere
19:52:02 <halogenandtoast> geekosaur: I "think" that was what I was trying to do
19:52:11 <halogenandtoast> I'm fine with passing it "transparently"
19:52:23 <halogenandtoast> MonadRandom comes from Control.Monad.Random right?
19:52:41 <geekosaur> which package?
19:52:47 <halogenandtoast> MonadRandom
19:53:09 <halogenandtoast>   build-depends:       base >= 4.7 && < 5
19:53:09 <halogenandtoast>                      , random
19:53:09 <halogenandtoast>                      , MonadRandom
19:53:12 <geekosaur> that sounds wrong, unless they decided to complicate things at some point :/
19:53:55 <geekosaur> ok, yes, at one point that was just a glorified state monad, now it's annoying :/
19:54:30 <geekosaur> sad
19:56:18 <halogenandtoast> lol
19:56:50 <geekosaur> I mean, really all that's needed is a state monad with some helpers
19:59:43 <geekosaur> ok, guess the path is official now for the Creators Update-compatible ghc
20:59:26 <codygman> Does anyone know how I can wait for an interactive haskell repl in haskell-mode to load before trying to insert stuff into it?
21:00:12 <codygman> I'm browsing through the source but can't find it
21:00:26 <codygman> I think maybe I can use haskell-interactive-at-prompt
21:08:37 <ertes> geekosaur: at one point i completely removed any dependency on MonadRandom from all of my packages, precisely because it used StateT and had StateT-based instances of MonadRandom
21:09:41 <geekosaur> that's orthogonal, it should _behave like_ state, it doesn't have to take up a StateT
21:09:58 <geekosaur> requiring a monad it can hide a ref inside is better??
21:11:14 <ertes> geekosaur: oh, then i don't understand what you mean…  RandT is just a newtype around StateT
21:12:57 <ertes> not sure why its constructor is hidden though (for god's sake, stop doing that OOP bullshit already!)
21:15:08 <seekr_> geekosaur: Thanks a lot for the link, I got GHC working.
21:15:47 <geekosaur> ertes, copy around a seed like a state monad, but the methods it provides are those for randomness, not those of MonadState
21:16:35 <geekosaur> no MonadState instance, no get/put (might provide renames as backdoors but I suspect there's more api appropriate stuff)
21:17:12 <ertes> geekosaur: yeah, for some reason it really tries hard not to look like StateT
21:17:30 <ertes> highly inspired by java i take it
21:18:09 <ertes> anyway, just use StateT and dispense with the extra library dependency =)
21:18:38 <ertes> MonadRandom doesn't seem to provide any real benefit
21:47:50 <iqubic> WHat is the best way to get random numbers in Haskell??
21:48:19 <iqubic> Like if I want N random integers X and Y, what do I do?
21:50:12 <iqubic> Also, when using Lenses, when would I ever need a traversal?
21:52:58 <Cale> iqubic: Probably the easiest way is just  replicateM n (randomRIO (x,y))
21:53:35 <Cale> Depending on how heavily you're using random number generation though, there might be better options.
21:54:59 <iqubic> What's randomRIO?
21:55:30 <iqubic> :t randomRIO
21:55:32 <lambdabot> Random a => (a, a) -> IO a
21:55:50 <iqubic> Why is that returning something of type IO a?
21:55:59 <iqubic> Also, when using Lenses, when would I ever need a traversal?
21:56:24 <iqubic> Trying to understand traversals here. I can look at the log to learn about random number generation.
21:56:59 <iqubic> I know what lenses are, well enough. I just need to know why a travesal would ever be helpful ever.
21:58:37 <jle`> iqubic: it returns an IO computation that produces a random 'a'
21:58:46 <iqubic> And while we're at it, what the heck is a prism???
21:59:04 <jle`> i use traversals more often than i use lenses
21:59:09 <ertes> iqubic: a lens points to exactly one value, whereas a traversal can point to arbitrarily many values
21:59:22 <ertes> iqubic: i use them much more often than lenses
21:59:53 <iqubic> ertes: So if I have [a], I can have a traversal that points to all 'a' in the list
22:00:03 <ertes> iqubic: a prism is a traversal that points to up to one element, and it has enough information to *construct* that element
22:00:04 <jle`> yup
22:00:08 <Cale> iqubic: Well first of all, are you familiar with "traverse"?
22:00:11 <jle`> iqubic: it's actually included in 'base'
22:00:21 <jle`> called traverse :: Traversal [a] [b] a b
22:00:24 <Cale> Traversals in general are things which behave much like traverse does.
22:00:25 <iqubic> Not too well Cale. What does travers do?
22:00:30 <Cale> :t traverse
22:00:32 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:00:37 <ertes> _Just is a prism
22:00:42 <ertes> > _Just # 5
22:00:44 <lambdabot>  Just 5
22:00:47 <iqubic> That is too complex for me to handle.
22:00:53 <jle`> iqubic: traverse is like an "effectful" map
22:00:54 <Cale> So t a here is some data structure filled with values of type a
22:00:57 <iqubic> The type signature for traverse.
22:01:00 <jle`> map :: (a -> b) -> [a] -> [b]
22:01:08 <jle`> traverse :: (a -> f b) -> [a] -> f [b]
22:01:13 <Cale> and a -> f b is a function describing something to be done for each value of type a
22:01:32 <jle`> it's like map, but your mapping function can be 'effectful'
22:01:34 <Cale> i.e. given some value of type a, you get an f-computation whose result will have type b
22:01:36 <jle`> if you're familiar with mapM, it's the same thing
22:01:38 <ertes> iqubic: have you implemented a lens by yourself?
22:01:40 <Cale> e.g. f might be IO
22:01:58 <ertes> iqubic: without using any of the automations of the lens library
22:02:18 <iqubic> traverse putStr ["H", "E", "L", "L", "O"]
22:02:21 <iqubic> Does that work?
22:02:23 <jle`> yes, exactly
22:02:28 <jle`> that returns an IO [()]
22:02:37 <iqubic> Why is it that type???
22:02:51 <jle`> it's basically putStr "H" >> putStr "E" >> putStr "L" >> putStr "O", but also collects the results
22:02:56 <jle`> iqubic: look at the type signature of traverse
22:03:00 <iqubic> I see now.
22:03:09 <jle`> yes
22:03:12 <jle`> let the power flow through you
22:03:23 <iqubic> ertes: I have never constructed a lens by myself. I always use TemplateHaskell.
22:03:31 <ertes> iqubic: then do that
22:03:43 <jle`> map applies an (a -> b) over all the a's in a struture, and collects the results back
22:04:01 <jle`> traverse applies an (a -> f b) over all of the a's in a sturcture, sequences the effects, collects the results
22:04:01 <ertes> iqubic: here is an exercise:  write the following lens:  traverseFst :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
22:04:53 <jle`> iqubic: another common thing people traverse, besides lists, is Map's
22:05:09 <codygman> Is there a pointfree lens way of doing this: fmap (<> "!") (bs ^? key "filepath" . _String)
22:05:10 <jle`> a `Map k a` is a map of keys of type k and values of type a
22:05:21 <jle`> codygman: that's already pointfree
22:05:54 <iqubic> ertes: traverseFst f (a, b) = (f a, b)
22:05:59 <iqubic> Is that correct?
22:06:04 <codygman> jle`: I would like something like:  bs ^? key "filepath" . _String . someFunctionLikeFmap (<> "!")
22:06:18 <ertes> iqubic: ask GHC whether it's correct
22:06:36 <ertes> iqubic: there is only one way to write this function
22:06:56 <iqubic> I'll see what GHC thinks
22:07:28 <ertes> (i could tell you, but then i would encourage you to guess instead of think) =)
22:08:17 <iqubic> Looks like that's not the correct implementation.
22:08:52 <ertes> your result needs to be of type (f (b, c)), but you are returning something of type (f b, c)
22:09:10 <jle`> iqubic: traverse for maps is (a -> f b) -> Map k a -> f (Map k b) -- apply the (a -> f b) to all of the a's in the map, and sequences the effects and collects them all into a new map
22:10:08 <iqubic> ertes: I'm not sure of the correct way to write traverse first.
22:10:50 <ertes> iqubic: there is a way to get an (f b), and you have a value of type 'c' from the second argument
22:11:07 <ertes> iqubic: do you see a way to combine them into an (f (b, c)) with the hint that 'f' is a functor?
22:11:28 <iqubic> I'll try.
22:12:28 <iqubic> I think I need to use fmap or <$> somewhere.
22:12:38 <ertes> that's right
22:12:45 <iqubic> Not sure where though.
22:12:57 <ertes> iqubic: if you had a 'b', do you see how to turn it into a (b, c)?
22:13:05 <iqubic> No.
22:13:27 <iqubic> I think I'd need to apply a data constructor of (,) some how.
22:13:32 <ertes> yes
22:13:51 <ertes> let's say that (x :: b), and (y :: c)
22:13:54 <iqubic> But I don't know where
22:13:57 <ertes> can you give me a value of type (b, c)?
22:14:08 <iqubic> sure: (x, y)
22:14:12 <iqubic> done.
22:14:16 <iqubic> That was simple
22:14:16 <ertes> correct
22:14:25 <iqubic> traverseFst :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
22:14:35 <iqubic> That's what I'm aming for
22:14:51 <ertes> now you have only (y :: c), can you write a *function* that, given a value of type 'b', returns a (b, c)?
22:15:09 <iqubic> Yes.
22:15:19 <jle`> codygman: you can probably use 'to'
22:15:41 <iqubic> makeFst b = (b, c)
22:15:53 <iqubic> provided that the second argument has the right type
22:15:57 <ertes> iqubic: correct, but let's use the lambda form:  (\b -> (b, c))
22:16:01 <ertes> uhm
22:16:08 <iqubic> What now?
22:16:20 <ertes> let's use this instead in order not to mix up values and types:  (\x -> (x, y))
22:16:26 <iqubic> Sure.
22:16:33 <ertes> this function is of type (b -> (b, c))
22:16:38 <iqubic> correct.
22:17:03 <ertes> now given a function of type (b -> (b, c)), do you see a way to turn it into a function of type (f b -> f (b, c)), given that 'f' is a functor?
22:17:31 <iqubic> Using fmap or <$>?
22:17:45 <jle`> codygman: probably 'to (<> "!")'
22:18:16 <ertes> iqubic: how exactly?  you can use the lambda now
22:18:36 <jle`> codygman: bs ^? key "filepath" . _String . mapped . to (<> "!")
22:18:39 <iqubic> Not sure.
22:18:50 <iqubic> Don't we need a function in order to use fmap?
22:19:25 <ertes> iqubic: you have a function
22:19:33 <iqubic> I just realized that.
22:19:41 <jle`> iqubic: "now given a function..."
22:20:02 <iqubic> \x -> x <$> (\x -> (x, y))
22:20:07 <iqubic> Done.
22:20:17 <iqubic> I think that works
22:20:18 <jle`> ask ghc :)
22:20:19 <ertes> nope
22:20:27 <iqubic> That's wrong? how??
22:20:30 <ertes> and yes, sorry…  you should ask GHC =)
22:20:33 <jle`> the best part about haskell is that you can always ask ghc if what you wrote is correct
22:20:44 <jle`> that's the best advantage of haskell over other languges :)
22:20:57 <ertes> however, GHC will not actually complain about that one, as far as i see
22:21:16 <iqubic> It won't?
22:21:37 <ertes> iqubic: (\x -> (x, y)) :: b -> (b, c)  -- assuming (y :: c)
22:21:46 <iqubic> Sure.
22:21:54 <ertes> fmap :: (u -> v) -> (f u -> f v)
22:22:19 <ertes> do you see a way to turn a (b -> (b, c)) into an (f b -> f (b, c))?
22:22:26 <iqubic> Yes. I do.
22:22:55 <ertes> ok, give me an (f b -> f (b, c))
22:23:04 <iqubic> fmap (\x -> (x, y)
22:23:15 <ertes> apart from the missing bracket, exactly
22:23:21 <iqubic> Right, sorry.
22:23:33 <iqubic> Now, how does this help use with: traverseFst :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)?
22:23:45 <iqubic> Wait, let me try it on my own.
22:24:17 <ertes> fmap (\x -> (x, y)) :: f b -> f (b, c)  -- this function returns a result of exactly the right type you need for traverseFst…  all you need now is an (f b) you can apply it to
22:24:40 <iqubic> And how do I get that (f b)?
22:25:06 <ertes> traverseFst f (x, y) = _  -- for _ there is (f :: a -> f b) in scope
22:25:24 <ertes> if you could apply f to something, you would get an (f b), right?
22:25:33 <iqubic> yeah. I would.
22:25:38 <iqubic> What do I apply it to?
22:25:47 <ertes> well, do you have a value of type 'a'?
22:25:51 <iqubic> I do.
22:26:02 <ertes> ok, now try it =)
22:28:19 <iqubic> traverseFst f (x, y) = fmap (\x -> (x, y)) x
22:28:24 <iqubic> I think that's right.
22:28:29 <ertes> try it
22:28:38 <iqubic> GHC tells me it's right, I think.
22:28:51 <ertes> then you forgot to write a type signature for traverseFst
22:28:53 <iqubic> Not quite.
22:28:57 <iqubic> I did.
22:29:07 <ertes> then GHC will not agree
22:29:16 <iqubic> Why is this so hard???
22:29:44 <ertes> symbolic/logical reasoning takes some getting used to, but you're really close
22:29:48 <Cale> iqubic: You just forgot to make use of f
22:30:00 <iqubic> Cale: I did nothing with f?
22:30:13 <iqubic> f is a function right??
22:30:15 <Cale> yeah
22:30:16 <ertes> you did not use f anywhere, but you need to use f to get the (f b)
22:30:31 <iqubic> got it.
22:30:39 <iqubic> traverseFst f (x, y) = fmap (\x -> (x, y)) (f x)
22:30:42 <iqubic> done.
22:30:45 <iqubic> That works.
22:30:45 <ertes> correct
22:30:49 <iqubic> GHC agrees.
22:30:53 <Cale> That is actually not just a traversal, it's a lens
22:30:59 <ertes> congratulations, you have just written your first lens
22:31:05 <iqubic> That's just a lens??
22:31:09 <ertes> yes
22:31:12 <iqubic> Let me guess
22:31:25 <ertes> you can replace the type signature by:  traverseFst :: Lens (a, c) (b, c) a b
22:31:37 <Cale> Lenses are the special case of traversals which only traverse one element
22:31:42 <ertes> if you look up the definition of the Lens type alias, you will find that it matches your type exactly
22:31:57 <Cale> and which as such, don't need the full Applicative structure, just Functor
22:31:58 <iqubic> traverseSnd f (x, y) = fmap (\y -> (x, y)) (f y)
22:32:03 <Cale> (you only needed fmap)
22:32:04 <Cale> yeah
22:32:04 <iqubic> Is that right?
22:32:12 <iqubic> Did I get traverseSnd?
22:32:17 <iqubic> So what is a lens, then?
22:32:24 <iqubic> a single element traversal?
22:32:28 <ertes> iqubic: you can now import Control.Lens and use traverseFst to access/modify the first element of tuples
22:32:28 <Cale> yeah
22:32:30 <iqubic> What's a traversal then?
22:32:43 <Cale> Now if you look at what you've done here
22:32:46 <ertes> iqubic: before we get to traversals, do you understand *why* this function is a lens?
22:32:50 <Cale> You've split the structure into two parts:
22:32:52 <iqubic> Do?
22:33:07 <iqubic> NO. I have no idea why that is a lens at all.
22:33:11 <Cale> the part which you're applying f to, the bit that the traversal/lens is focusing on
22:33:28 <Cale> and a function which replaces that part in the whole structure
22:33:29 <ertes> there are quite a few ways you can use traverseFst…  the obvious way is to use it with f = Identity to map over the first element
22:33:43 <ertes> @let traverseFst f (x', y) = fmap (\x -> (x, y)) (f x')
22:33:44 <Cale> you can think of (\y -> (x, y)) as being like a pair with a hole punched in it by the lambda
22:33:44 <lambdabot>  Defined.
22:33:56 <Cale> i.e. the second component is a blank which still needs filling in
22:34:07 <ertes> > runIdentity (traverseFst (\x -> Identity (x + 5)) (10, 20))
22:34:09 <lambdabot>  (15,20)
22:34:17 <iqubic> Can I try writing another lens?
22:34:32 <iqubic> Can someone give me another lens to try writing?
22:34:50 <ertes> iqubic: sure…  try writing a lens into the real part of a Complex from Data.Complex
22:34:54 <Cale> This is a general pattern with lenses: you're splitting the structure into a function which acts like the original structure with a hole punched in the appropriate place, and the part that you punched out of there
22:35:15 <Cale> and then you're applying your arbitrary function to the part that you punched out and fmapping the function over it
22:35:18 <iqubic> I'll try that.
22:35:19 <glguy> a lens for the least significant bit in an Int
22:35:45 <ertes> iqubic: glguy's exercise is better, because it's less similar to the tuple exercise
22:36:07 <iqubic> ertes: traverseReal f (x :+ y) = fmap (\x -> (x :+ y)) (f x)
22:36:15 <ertes> yeah, exactly
22:38:40 <iqubic> Now, how do I work with bits in an interger?
22:38:46 <ertes> Data.Bits
22:38:48 <Cale> Math
22:39:27 <iqubic> And I can use Data.Bits to make a lens for the least significant bit of an int?
22:39:27 <ertes> (you could also use 'mod', 'even' and (+))
22:39:34 <ertes> yeah
22:39:46 <iqubic> Cool. Let me try that.
22:39:53 <ertes> here is a similar exercise:  write a lens into the absolute value of an Integer
22:40:16 <iqubic> What does that even mean?
22:40:34 <ertes> (-50) ^. traverseAbs = 50
22:40:45 <ertes> (-50) & traverseAbs +~ 10 = -60
22:40:46 <iqubic> Oh, I see.
22:41:04 <iqubic> ertes: I don't know what those infix functions are doing.
22:41:22 <Cale> +~ is silly, just use over :P
22:41:35 <ertes> over traverseAbs (+ 10) (-50) = -60
22:41:36 <N0F4C3_47> this is chaenel h4cker or math hehe :P
22:41:40 <iqubic> I see.
22:41:59 <iqubic> So I don't know where to begin with that?
22:42:14 <Cale> iqubic: Did you read my general description of how a lens works?
22:42:22 <iqubic> Can I see the type signature of traverseAbs?
22:42:23 <Cale> Several people were talking about that time
22:42:34 <ertes> revisit traverseFst:  you had a way to split the data into two parts: the focus part (fst) and the remainder part (snd)
22:42:49 <Cale> traverseAbs :: (Integer -> f Integer) -> Integer -> f Integer
22:42:54 <ertes> you used pattern-matching to do it, but you could just as well have used 'fst' and 'snd'
22:43:09 <iqubic> I know. I know.
22:43:14 <Cale> (With the guarantee that the Integers involved in the function argument are nonnegative)
22:43:17 <ertes> traverseFst f xy' = fmap (\x -> (,) x (snd xy')) (f (fst xy'))
22:43:31 <ertes> fst/snd are splitting, (,) is reassembly
22:43:32 <iqubic> Right.
22:43:35 <iqubic> I know that.
22:43:44 <ertes> Integer splits into two parts:  a sign and an absolute value
22:43:58 <iqubic> How do I get the sign?
22:43:59 <ertes> 'signum' and 'abs' will be helpful for that
22:44:10 <iqubic> :t signum
22:44:12 <lambdabot> Num a => a -> a
22:44:17 <ertes> and reassembly is just (*)
22:44:26 <ertes> > signum (-5) * abs (-5)
22:44:27 <iqubic> What does signum do?
22:44:28 <lambdabot>  -5
22:44:36 <ertes> > map signum [-3..3]
22:44:38 <lambdabot>  [-1,-1,-1,0,1,1,1]
22:44:43 <jle`> iqubic: check out the docs :)
22:44:51 <iqubic> I ss how that works.
22:45:09 <jle`> http://hackage.haskell.org/package/base-4.9.1.0/docs/Prelude.html#v:signum
22:45:52 <Cale> @let onesDigit f n = let (q,r) = quotRem n 10 in (\r' -> 10*q + r') <$> f r
22:45:53 <lambdabot>  Defined.
22:46:22 <Cale> > view onesDigit 47837
22:46:24 <lambdabot>  7
22:46:35 <Cale> > set onesDigit 2 47837
22:46:37 <lambdabot>  47832
22:47:38 <iqubic> traverseAbs f x = (\x' ->  x' * signum x) <$> (f $ abs x)
22:47:45 <iqubic> Not sure that will work.
22:47:54 <ertes> iqubic: not quite
22:48:04 <ertes> oh, wait
22:48:10 <ertes> yes, it should
22:48:16 <Cale> yeah, looks fine to me
22:48:24 <iqubic> Cool. I did a thing.
22:48:33 <iqubic> @let traverseAbs f x = (\x' ->  x' * signum x) <$> (f $ abs x)
22:48:35 <lambdabot>  Defined.
22:48:59 <iqubic> > over traverseAbs (+ 10) (-50)
22:49:02 <lambdabot>  -60
22:49:05 <iqubic> It works.
22:49:19 <ertes> iqubic: now the important question is: how is traverseAbs an actual lens?  using f = Identity we can *change* the value, but a lens also features *extraction*
22:50:04 <iqubic> How do I extract something from a lens like traverseFst?
22:50:07 <ertes> traverseFst :: (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
22:50:19 <ertes> can you think of an 'f' that would return an 'a'?
22:50:29 <iqubic> id?
22:50:36 <ertes> i mean the type 'f'
22:50:44 <iqubic> Identity?
22:50:57 <ertes> nope:  Identity (b, c) ≃ (b, c)
22:51:09 <ertes> you need an f such that:  f (b, c) ≃ a
22:51:20 <iqubic> Not sure how to do that.
22:51:44 <ertes> well, think about it…  it's an 'f' that ignores its argument type (which is (b, c)), and just returns an 'a'
22:52:07 <ertes> a function that ignores its argument…  does that sound familiar?
22:52:19 <ertes> (in this case a type-level function of course)
22:52:37 <iqubic> I have no idea.
22:52:42 <iqubic> Is it const?
22:52:46 <ertes> yeah, exactly!
22:52:56 <ertes> it's the constant functor
22:53:00 <iqubic> I was just making an educated guess.
22:53:00 <ertes> :k Const
22:53:01 <lambdabot> * -> k -> *
22:53:07 <iqubic> Oh. I see
22:53:09 <ertes> your guess was correct =)
22:53:19 <iqubic> So how does that help with traverseAbs?
22:53:29 <ertes> traverseFst :: (a -> Const a b) -> (a, c) -> Const a (b, c)
22:53:32 <iqubic> And extraction
22:54:02 <iqubic> > over traverseAbs (const 1) (-60)
22:54:04 <lambdabot>  -1
22:54:13 <ertes> Const has a constructor, also named Const…  it has type:  Const :: a -> Const a b
22:54:14 <iqubic> Darn it.
22:54:31 <iqubic> > over traverseAbs (\x -> Const x) (-60)
22:54:33 <lambdabot>  error:
22:54:33 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ Const a b0
22:54:33 <lambdabot>      • In the expression: Const x
22:54:35 <ertes> can you think of a function 'f' you can use with traverseFst when the type f = Const a?
22:54:53 <iqubic> is it id?
22:54:59 <iqubic> Just guessing here.
22:55:11 <ertes> nope…  the argument you need is of type:  a -> Const a b
22:55:30 <ertes> can you think of a function of that type?
22:55:36 <iqubic> That's not the function, but the argument.
22:56:09 <ertes> once again the type signature instantiated with f = Const a:  traverseFst :: (a -> Const a b) -> (a, c) -> Const a (b, c)
22:56:28 <iqubic> What function can I use?
22:56:35 <iqubic> Is that the question?
22:56:42 <ertes> can you think of an argument of type (a -> Const a b) you can apply this function to?  if not, read the last few lines i wrote carefully
22:56:55 <iqubic> \x -> Const x y
22:57:00 <iqubic> Does that work?
22:57:07 <ertes> that's a type error:  Const takes only one argument
22:57:20 <jle`> :t Const
22:57:21 <lambdabot> forall k (b :: k) a. a -> Const a b
22:57:28 <iqubic> \x -> Const x
22:57:33 <iqubic> Does that work
22:57:36 <ertes> yeah…  or simply Const
22:57:48 <ertes> > traverseFst Const (3, 5)
22:57:50 <lambdabot>  Const 3
22:58:06 <iqubic> > traverseAbs Const (-60)
22:58:08 <lambdabot>  Const 60
22:58:13 <iqubic> oh, that works.
22:58:24 <iqubic> That's how my function was a lens.
22:58:25 <kellytk> Hi, how well suited to making trading bots is Haskell?
22:58:31 <ertes> that's exactly what 'view' or (^.) does
22:58:47 <iqubic> Oh, is it.
22:58:52 <ertes> except that it also gets rid of the Const wrapper
22:59:07 <Cale> kellytk: I think some people actually do that, but I don't know what sort of libraries or techniques they use.
22:59:07 <iqubic> traverseAbs^.(-60)
22:59:12 <ertes> kellytk: you may have to write some support code first, like machine learning libraries
22:59:13 <jle`> kellytk: it depends on how important hard real-time is for you
22:59:15 <iqubic> >traverseAbs^.(-60)
22:59:24 <iqubic> > traverseAbs^.(-60)
22:59:26 <lambdabot>  error:
22:59:27 <lambdabot>      • Could not deduce (Num t0)
22:59:27 <lambdabot>        from the context: (Num (Getting a ((t -> f t) -> t -> f t) a),
22:59:39 <iqubic> Why doesn't that work?
22:59:46 <iqubic> > traverseAbs ^. (-60)
22:59:46 <jle`> > (-60) ^. traverseAbs
22:59:48 <lambdabot>  60
22:59:49 <lambdabot>  error:
22:59:49 <lambdabot>      • Could not deduce (Num t0)
22:59:49 <lambdabot>        from the context: (Num (Getting a ((t -> f t) -> t -> f t) a),
22:59:50 <Cale> jle`: I would expect something like a Haskell EDSL to be pretty good approach to writing one-shot compilers for trading bots
22:59:52 <kellytk> jle`: Soft is fine, I'd be coming from Node.js/TypeScript.  ertes: ML for the trading strategies?
22:59:55 <Cale> (for HFT)
23:00:04 <jle`> iqubic: (you flipped the arguments for ^.)
23:00:16 <ertes> kellytk: i would assume that you use ML for automated trading
23:00:23 <iqubic> I did?
23:00:37 <iqubic> (-60) ^. traverseAbs
23:00:44 <iqubic> > (-60) ^. traverseAbs
23:00:47 <lambdabot>  60
23:00:50 <iqubic> so I did.
23:00:58 <kellytk> ertes: I'm getting started so they'd be static strategies and quite simple ala buy low sell high :-) 
23:01:00 <jle`> mhm.
23:01:00 <Cale> ertes: Just because Jane Street?
23:01:06 <ertes> iqubic: does everything make sense so far?
23:01:11 <iqubic> Yes.
23:01:18 <iqubic> What more do you want to teach me?
23:01:37 <jle`> kellytk: for something like that, haskell-the-language is kind of great for that 
23:01:41 <iqubic> I get that a lens is a single element traversal
23:01:49 <ertes> kellytk: ah, then i see no problem in that regard…  you may still need support libraries like bindings to your broker's API, for example
23:01:59 <jle`> it's just that the ecosystem is kind of lacking compared to for other languages
23:02:18 <ertes> kellytk: as for how much haskell as a language is suitable: very suitable =)
23:02:18 <kellytk> ertes: Also basic networking such as hitting a JSON HTTP endpoint once every x seconds
23:02:32 <ertes> kellytk: the basic stuff is all there
23:02:41 <kellytk> jle`: How fast can gaps be filled with Haskell?
23:02:41 <iqubic> ertes: What more is there to learn about lenses?
23:02:45 <ertes> including JSON/XML/HTTP/…
23:03:00 <ertes> iqubic: a *lot* =)
23:03:00 <dysfun> lenses go on forever and ever
23:03:09 <iqubic> How does the makeLens TemplateHaskell thing work with records?
23:03:12 <kellytk> ertes: That's pretty high-level IMHO but I suppose not coming from JS which also offers a lot
23:03:30 <ertes> iqubic: here is a challenge: can you write a lens into *both* components of a tuple?
23:03:41 <iqubic> What does that mean?
23:03:52 <ertes> iqubic: traverseBoth :: (Functor f) => (a -> f b) -> (a, a) -> f (b, b)
23:03:57 <iqubic> ertes: Won't that be a travesal for realsie this time?
23:04:02 <iqubic> or not yet?
23:04:08 <ertes> iqubic: note: i'm calling this a challenge, not an exercise
23:04:14 <iqubic> I'll try it.
23:04:16 <kellytk> ertes: Does Haskell offer anything helpful for parallel code?
23:04:20 <iqubic> Is it hard to do?
23:04:26 <jle`> kellytk: haskell gaps can be usually be easy to fill in
23:04:29 <ertes> kellytk: so much that there is a whole book about it
23:04:40 <ertes> kellytk: http://chimera.labs.oreilly.com/books/1230000000929/
23:04:42 <iqubic> Or is it just confusing to write that lens?
23:04:54 <Cale> also note: it won't be a lens, just a traversal
23:04:55 <ertes> iqubic: try it first, before i answer that
23:05:06 <iqubic> I will.
23:05:17 <iqubic> Cale: this will be a traversal?
23:05:19 <Cale> Yeah
23:05:27 <Cale> You will need Applicative
23:05:33 <iqubic> Why is that?
23:05:34 <ertes> iqubic: the actual exercise is, as soon as you hit the road-block, to explain *why* you can't do it =)
23:05:41 <ertes> but Cale already spoiled it
23:05:44 <Cale> With only fmap, you can only replace one thing
23:06:23 <ertes> you may still want to try though
23:06:39 <iqubic> It's like trying to apply (+) to two Maybe Ints without an applicative.
23:06:47 <iqubic> It can't be done.
23:07:03 <iqubic> ertes: I'll try.
23:07:44 <iqubic> So first I need a function that takes something of type a, and makes a tuple of (a, a). Let's use (,) for that.
23:07:49 <dysfun> what useful libraries make use of Applicative but *not* Monad?
23:07:56 <rotaerk> cereal package ... downloads: 158452.  votes: 1.
23:08:00 <cocreature> dysfun: validation
23:08:03 <ertes> iqubic: it's impossible to do, but try to come up with an idea of what you *would* need to write it
23:08:10 <dysfun> aha
23:08:10 <Cale> dysfun: Traversable
23:08:12 <iqubic> dysfun: Apparently Traversals do.
23:08:13 <ertes> iqubic: i.e. why Functor is not enough
23:08:16 <cocreature> dysfun: or more accurately AccValidation
23:08:21 <tinkywinky> poll: what software are you writing with Haskell, or are you just gazing into the navel of category theory?
23:08:34 <dysfun> okay, thanks folks :)
23:08:47 <iqubic> I'm learning about lenses. They're teaching me.
23:08:54 <Cale> tinkywinky: The company I work for, Obsidian Systems, builds web and mobile applications for various clients entirely in Haskell.
23:09:10 * dysfun is building a compiler in haskell, which is a bit of a cliche
23:09:13 <cocreature> tinkywinky: I’ve written web backends, (toy) compilers, small tools that help me with other things and more, …
23:09:14 <tinkywinky> Cale , that sounds cool are you using purescript perhaps?
23:09:24 <ertes> dysfun: since we're talking about it: lenses use proper Applicative a lot =)
23:09:25 <Cale> tinkywinky: We use GHCJS to build Haskell -> Javascript to run on the web, and GHC to turn the same Haskell into ARM code to run on mobile devices.
23:09:31 <Cale> Haskell only, no purescript
23:09:49 <dysfun> ertes: i really only use lenses at the highest level, i never did bother to try and understand the monster underneath
23:10:03 <jle`> dysfun: lens is a good example
23:10:11 <Cale> tinkywinky: (We also use GHC to build our application backends of course)
23:10:12 <jle`> oh someone already brought it up
23:10:29 <iqubic> traverseBoth f xy' = (,) <$> f (fst xy') <*> (snd xy')
23:10:34 <iqubic> I think that works.
23:10:35 <jle`> dysfun: lens is a nice library that explicitly takes advantage of the difference between Applicative and Monad to make stornger guaruntees about code
23:10:49 <ertes> dysfun: if you've ever used traversals, you have used the Applicative part of lens
23:11:08 <dysfun> i have used traversals
23:11:08 <iqubic> I know I used an applicative, but I see no way to apply (,) to two values without an applicative.
23:11:17 <tinkywinky> dysfun adit.io has the best explanation of lenses ive seen yet. I'm putting you down for navel-gazing :P
23:11:20 <ertes> iqubic: it does work, but it has another type
23:11:20 <iqubic> ertes: traverseBoth f xy' = (,) <$> f (fst xy') <*> (snd xy')
23:11:25 <ertes> iqubic: a less generic one
23:11:34 <iqubic> What does that mean?
23:11:39 <dysfun> tinkywinky: i'm not navel-gazing. i said i'm writing a compiler
23:11:39 <ertes> iqubic: this happens to be a proper traversal
23:11:49 <ertes> iqubic: proper in the sense of "not a lens"
23:11:50 <iqubic> I wrote a proper traversal?
23:11:57 <ertes> iqubic: yeah
23:11:59 <tinkywinky> dysfun: sorry I withdraw my statement
23:12:12 <iqubic> Wow. I didn't think that code would actually work.
23:12:25 <Cale> I've also used traversals in production code... though not too commonly.
23:12:25 <jle`> welcome to haskell
23:12:27 <ertes> ah, you have one error there
23:12:28 <dysfun> that said, periodically i have curiosities that #haskell is very good at solving
23:12:43 <iqubic> You need an applicative, because you can't apply (,) to two valuse with just functors.
23:12:45 <ertes> iqubic: ^
23:12:54 <iqubic> ertes: What's the error?
23:12:58 <dysfun> i am not convinced anyone is ever 'done' learning haskell
23:12:59 <jle`> i mostly use traversals as a design pattern and not as a literal lens Traversal
23:13:05 <ertes> iqubic: you actually need to apply 'f' twice
23:13:22 <iqubic> ertes: traverseBoth f xy' = (,) <$> f (fst xy') <*> f (snd xy')
23:13:24 <jle`> when i want to create both a 'mapper' and a 'replacer' for my data types
23:13:27 <iqubic> Right, like that.
23:13:29 <jle`> and i don't want to define two different functions
23:13:30 <ertes> iqubic: yeah, exactly
23:13:32 <iqubic> I just fixed it.
23:13:33 <jle`> i can define a traversal and get both for free
23:13:40 <Cale> dysfun: I'm kinda 'done', in some sense, though I guess there are always new features being added to GHC.
23:13:41 <ertes> @let traverseBoth f xy' = (,) <$> f (fst xy') <*> f (snd xy')
23:13:42 <lambdabot>  Defined.
23:13:56 <ertes> > (traverseBoth +~ 5) (3, 8)
23:13:58 <lambdabot>  (8,13)
23:14:08 <iqubic> what does +~ do?
23:14:10 <Cale> dysfun: Of course, if you count the new libraries that people are building, then sure, can't ever be done :)
23:14:20 <dysfun> yes!
23:14:22 <iqubic> wait I see that.
23:14:23 <ertes> iqubic: l +~ dx = over l (+ dx)
23:14:28 <iqubic> I got that now.
23:14:33 * dysfun is looking forward to when 'freer' has sane error messages
23:14:47 <iqubic> ertes: What other traversal should I try to write next?
23:15:17 <ertes> iqubic: easy or difficult?
23:15:27 <jle`> try writing one over lists ;)
23:15:31 <iqubic> easy for now. I'm still learning.
23:15:38 <iqubic> jle`: is that simple?
23:15:39 <ertes> iqubic: then what jle` said
23:15:48 <iqubic> How is that simple??
23:15:52 <jle`> it's simple, but there's one conceptual jump
23:15:57 <iqubic> Seems like it'd need recursion.
23:15:59 <jle`> but it illustrates a common pattern for writing traversals
23:16:00 <Cale> It does.
23:16:05 <ertes> iqubic: it's less simple than traverseBoth, because you need recursion, but still simple enough
23:16:10 <jle`> which is pattern match on all of the constructors
23:16:16 <jle`> and re-assembple them using <$>/<*>
23:16:29 <jle`> so traverseList f [] = ...; traverseList f (x:x) = ...
23:16:34 <jle`> *x:xs
23:16:41 <ertes> iqubic: traverseListElems :: (Applicative f) => (a -> f b) -> [a] -> f [b]
23:16:55 <Cale> hint: you've probably already seen this thing
23:17:03 <iqubic> I have.
23:17:06 <ertes> iqubic: oh, and don't cheat…  you're not allowed to use 'traverse' or 'mapM' or any of their siblings =)
23:17:08 <iqubic> I know what it's called.
23:17:18 <jle`> you can use this same pattern to write a traversal for Maybe, Either e, etc.
23:17:28 <iqubic> ertes: I will write the implementation of traverse.
23:17:31 <jle`> just match on all of the constructors
23:17:34 <iqubic> How does that sound
23:17:42 <ertes> iqubic: that's exactly what this is
23:17:53 <ertes> iqubic: in fact 'traverse' is itself a proper traversal
23:18:03 <ertes> > (traverse +~ 5) [10,20,30]
23:18:05 <lambdabot>  [15,25,35]
23:19:23 <jle`> > traverse (\x -> Const [x]) [10,20,30]
23:19:25 <lambdabot>  Const [10,20,30]
23:19:39 <iqubic> traverseListElems f [] = f []; traverseListElems f [x:xs] = f x : traverseListElems f xs
23:19:47 <iqubic> I don't think that works at all.
23:19:50 <jle`> ask ghc :)
23:19:53 <ertes> > ["hel", "lo ", "wor", "ld"] ^. traverse
23:19:55 <lambdabot>  "hello world"
23:20:02 <ertes> iqubic: ignore that =)
23:20:13 <ertes> i'll explain how/why this works later
23:20:19 <iqubic> That's just applying <> to all the elements
23:20:26 <iqubic> Isn't it?
23:20:36 <ertes> yes, but where does the (<>) come from?
23:20:55 <ertes> xs ^. traverse = getConst (traverse Const xs)
23:21:15 <iqubic> Instance Monoid [Char] where...
23:21:21 <iqubic> It's a monoid thing.
23:21:29 <iqubic> I know about monoids.
23:21:30 <ertes> it is, but how did it get there?
23:21:44 <iqubic> I don't know.
23:21:58 <ertes> the trick is:  instance (Monoid a) => Applicative (Const a)
23:22:14 <iqubic> How does one write a travesal for a list? 
23:22:21 <iqubic> I have no idea how to do that.
23:22:26 <ertes> iqubic: jle` gave you a template
23:22:40 <iqubic> That template is just the pattern matching.
23:22:51 <iqubic> It doesn't actually help me.
23:22:55 <ertes> iqubic: traverse f [] = _  -- this one is easy
23:22:59 <ertes> _ = ?
23:23:00 <iqubic> Is it?
23:23:27 <Cale> iqubic: Have you seen mapM?
23:23:28 <ggVGc> man, haven't written any haskell in months
23:23:30 <ggVGc> kind of miss it
23:23:45 <Cale> iqubic: I don't know exactly how new you are :)
23:23:50 <ertes> iqubic: there is nothing you can apply 'f' to, so your only option to construct an (f [b]) is something that doesn't rely on 'f'
23:23:56 <iqubic> Cale: I know what mapM is.
23:24:03 <jle`> iqubic: look at the type
23:24:12 <jle`> traverse f [] should return f [b]
23:24:13 <ggVGc> has anyone here used haskell with children?
23:24:15 <ertes> iqubic: now 'f' might include effects…  what do you call something that does *not* include effects?
23:24:31 <iqubic> f [] = pure
23:24:43 <iqubic> traverseList f [] = pure
23:24:43 <jle`> pure is a function
23:24:52 <jle`> pure...what?
23:24:57 <iqubic> traverseList f [] = pure []
23:25:00 <iqubic> I think.
23:25:02 <jle`> hooray
23:25:03 <ertes> iqubic: there you go
23:25:17 <ertes> iqubic: now:  traverseList f (x : xs) = …
23:25:31 <ertes> the argument list has a head and a tail, so the resulting list also has a head and a tail
23:25:57 <ertes> traverseList f (x : xs) = _a <$> _b <*> _c
23:26:02 <ertes> so this is the template
23:26:09 <Cale> ggVGc: I have. Back in 2004 or so, when I was working for a summer as a research assistant at McMaster University, there was an experimental program going on which involved teaching a bunch of Haskell and basic math to kids in grade 6 or so.
23:26:19 <Sh4rPEYE> I'm sorry to interrupt the conversation. Does anyone know why this doesn't work? Please note that (:>) is a "Stream", or infinite list, data constructor...
23:26:19 <Sh4rPEYE> fibS = 0 :> 1 :> zipWithS (+) fibS (tailS fibS)
23:26:26 <ertes> iqubic: if _b gives the head, and _c gives the tail, what should _a be?
23:26:33 <jle`> Sh4rPEYE: what is the error?
23:26:44 <jle`> and what is the implementation of zipWithS ?
23:26:47 <jle`> and tailS ?
23:26:54 <iqubic> traverseList f (x:xs) = : <$> f x <*> traverseList f xs
23:26:56 <Sh4rPEYE> Also the "...S" functions are simply the analogies of the list counterparts
23:26:59 <jle`> and what do you mean by 'doesn't work'?
23:27:03 <jle`> does it compile and give the wrong answer?
23:27:06 <jle`> does it not compile?
23:27:10 <ertes> iqubic: right thought process, wrong syntax
23:27:12 <Sh4rPEYE> Does not typechceck
23:27:16 <jle`> does it compile and give the write answer, but not terminate?
23:27:19 <jle`> alright
23:27:20 <Cale> ggVGc: It seemed to go pretty well. I wasn't strongly involved in it, but I was around, and would sometimes help explain something or answer questions.
23:27:24 <Sh4rPEYE> zipWithS :: (a -> b -> c) -> Stream a -> Stream b -> Stream c
23:27:24 <Sh4rPEYE> zipWithS f (x :> xs) (y :> ys) = f x y :> zipWithS f xs ys
23:27:26 <jle`> Sh4rPEYE: post your code and the error message
23:27:30 <iqubic> ertes: how is that the wrong syntax?
23:27:37 <Sh4rPEYE> Ok, I'm on it. 
23:27:38 <jle`> Sh4rPEYE: then we can reasonably begin to start
23:27:53 <ertes> iqubic: in prefix form it's written like this:  (:)
23:28:07 <iqubic> Ah.
23:28:26 <ertes> iqubic: and that's pretty much it
23:28:47 <ggVGc> Cale: what age groups was that?
23:28:57 <ggVGc> and do you know in which way haskell was used?
23:28:58 <jle`> iqubic: but yeah, that's the general pattern for writing traversals for ADT's
23:29:01 <ertes> @let traverseList f [] = pure []; traverseList f (x : xs) = (:) <$> f x <*> traverseList f xs
23:29:03 <lambdabot>  Defined.
23:29:04 <Cale> I guess they'd have been around 11 years old.
23:29:15 <ertes> > (traverseList +~ 5) [10,20,30]
23:29:17 <lambdabot>  [15,25,35]
23:29:25 <ertes> iqubic: your code at work =)
23:29:35 <jle`> traverseFoo f (SomeConstructor x y z) = SomeConstructor <$> (something f) x <*> (something f) y <*> (something f) z
23:29:58 <ggVGc> Cale: I'm about to get involved with teaching children programming through a project my coworker is running. We're currently using lisp within a tool he's written, which is basically a REPL and a drawing area, and a small library for drawing. They seem to really get it
23:30:00 <Cale> ggVGc: I believe they worked through the book called "The Haskell Road to Logic, Maths and Programming"
23:30:06 <ggVGc> but I've been wondering if haskell would be a good candidate too
23:30:11 <iqubic> [1..10]^..traverseList
23:30:18 <iqubic> > [1..10]^..traverseList
23:30:20 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:30:22 <Cale> Which is not the best Haskell book, and not the best math book, but it has an interesting combination of them.
23:30:28 <ggVGc> ah
23:30:32 <ertes> iqubic: want a more challenging exercise?
23:30:32 <ggVGc> this sounds like older ages
23:30:40 <iqubic> ertes: yes please.
23:30:41 <ggVGc> I'm talking 9-11 year olds
23:30:47 <ggVGc> even 8
23:30:52 <Cale> Well, they were that young, but they were reasonably bright.
23:30:54 <ertes> iqubic: write a traversal into the bits of a Word64
23:30:56 <ggVGc> oh
23:30:58 <Sh4rPEYE> Code: https://gist.github.com/EugLion/c8e34bf0335d824788eadda8678c101f
23:30:59 <ggVGc> that's cool
23:31:15 <iqubic> ertes: How do I access the bits of a Word64?
23:31:30 <ertes> iqubic: Data.Bits
23:31:38 <iqubic> I'm not too familiar with working with bits, or what a Word64 is.
23:31:51 <Sh4rPEYE> And it has some type problems with "Stream a0" and "Integer"
23:32:01 <ertes> iqubic: a Word64 is an unsigned 64 bits integer
23:32:17 <iqubic> Is it a seperate type?
23:32:27 <cocreature> Sh4rPEYE: please add the error message to your gist
23:32:27 <Cale> I think some might've been 9 or 10, I'm not sure any were younger than that
23:32:30 <ertes> iqubic: yeah, you need to import Data.Word
23:32:35 <iqubic> Alright.
23:32:58 <Cale> So I can say I taught a bunch of 10 year olds about monads and they got it.
23:33:00 <Cale> lol
23:33:23 <ertes> iqubic: one way to do it is to use testBit, setBit and clearBit from here: https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Bits.html
23:33:34 <cocreature> Cale: how many burritos were involved in that? :P
23:33:45 <iqubic> How many bits in Word64?
23:33:50 <iqubic> And does that matter?
23:33:54 <Cale> cocreature: none
23:34:00 <cocreature> iqubic: 64, that’s why it’s called Word64
23:34:04 <ertes> iqubic: the type is:  bitsWord64 :: (Applicative f) => (Bool -> f Bool) -> Word64 -> f Word64
23:34:04 <iqubic> LOL
23:34:20 <iqubic> and will I use recursion for that?
23:34:23 <iqubic> or what?
23:34:31 <Sh4rPEYE> cocreature: Done.
23:34:33 <iqubic> How will I apply an operation 64 times?
23:34:33 <ertes> feel free to write this instead:  bitsWord64 :: Traversal' Word64 Bool
23:34:56 <ertes> iqubic: strictly speaking you don't need recursion, but you should use it anyway
23:35:04 <jle`> iqubic: well, you applied an operation 2 times, with traverseBoth
23:35:07 <cocreature> Sh4rPEYE: try declaring :> as infixr
23:35:33 <ertes> iqubic: if you're wondering how exactly to use the recursion, try to write your own replicateM_
23:35:48 <iqubic> What does replicateM_ do?
23:36:05 <kellytk> Is https://github.com/jameysharp/corrode/blob/master/Main.md an example of Haskell code?  Including the comments
23:36:21 <ertes> iqubic: replicateM_ 5 c = c *> c *> c *> c *> c *> pure ()
23:36:27 <ertes> :t replicateM_
23:36:29 <lambdabot> Applicative m => Int -> m a -> m ()
23:36:36 <cocreature> kellytk: it’s a markdown file with Haskell code blocks in it
23:36:47 <kellytk> Oh
23:37:05 <kellytk> What do comments look like?
23:37:11 <geekosaur> -- something here
23:37:17 <cocreature> or {- comments -}
23:37:20 <geekosaur> or: {- something here -} thois is outside the comment
23:37:29 <Sh4rPEYE> infixr
23:37:31 <cocreature> in particular the latter allows for multiline comments
23:37:36 <iqubic> So replicateM_ is running the function s to itself n times?
23:37:37 <kellytk> Thanks
23:37:39 <geekosaur> also beware of {-# #-} which is a pragma
23:37:41 <Sh4rPEYE> cocreature: reat, that worked! thanks
23:37:41 <cocreature> Sh4rPEYE: "infixr :>" should be sufficient
23:38:10 <cocreature> Sh4rPEYE: the problem is that by default you’ll get (1 :> 2) :> … instead of 1 :> (2 :> …)
23:38:11 <ertes> iqubic: let me write that differently:
23:38:15 <Sh4rPEYE> cocreature: Yes, it now typechecks :-)
23:38:23 <kellytk> How would you distribute the categories of Haskell's use across client apps, server code, and a wildcard I don't even know about?
23:38:27 <ertes> iqubic: replicateM_ 5 c = c *> (c *> (c *> (c *> (c *> pure ()))))
23:38:52 <iqubic> do I need guards for this?
23:38:58 <ertes> iqubic: happen to know a shorter way to write c *> (c *> (c *> (c *> pure ())))?
23:39:03 <iqubic> I do.
23:39:07 <ertes> tell me
23:39:23 <iqubic> Wait, I actually don't know how to do that.
23:39:35 <ertes> iqubic: given replicateM_ …
23:39:52 <iqubic> replicateM_ 5 c
23:39:59 <Cale> kellytk: At the company I work for, we use Haskell to develop web and mobile applications, and use it both for the frontend and backend.
23:40:24 <ertes> iqubic: let me use a different example:  fac 5 = 5 * (4 * (3 * (2 * 1)))
23:40:26 <Cale> kellytk: It's really nice being able to share a bunch of types and code between those
23:40:43 <ertes> iqubic: the factorial function…  happen to know a shorter way to write (4 * (3 * (2 * 1)))?
23:40:44 <kellytk> Cale: How do you use it for the frontend?  Is there a good translator to iOS/Android?
23:40:57 <iqubic> I know how the factorial function works.
23:41:56 <Cale> kellytk: We use GHCJS to compile to Javascript for the web, and GHC's ARM support to compile the same code for iOS and Android (and we're using JSaddle right now to make that work)
23:41:57 <ertes> iqubic: i don't doubt that…  i'm using these examples to reinforce a pattern =)
23:42:09 <iqubic> I don't know the pattern.
23:42:17 <ertes> fac 5 = 5 * _shorterWayToWriteTheRest
23:42:20 <ertes> fill this in
23:42:36 <iqubic> fac ( 5 -1
23:42:47 <Cale> kellytk: Well, specifically, the jsaddle branch of reflex-platform
23:42:48 <ertes> yeah
23:42:50 <Cale> https://github.com/reflex-frp/reflex-platform
23:42:54 <kellytk> Cale: That sounds quite interesting.  Is there a large and active enough community that you see it not only continuing development but growing?
23:42:59 <ertes> iqubic: now use the same logic for replicateM_
23:43:06 <kellytk> I found that earlier it looks good
23:43:07 <iqubic> fac 0 = 1; fac n = fac (n - 1)
23:43:12 <Cale> Well, we're sort of in the middle of it :)
23:43:16 <ertes> iqubic: replicateM_ 5 c = c *> _shorterWayToWriteTheRest
23:43:42 <Cale> It would probably continue if we vanished, but it would probably take some time before anyone was as well equipped as Ryan Trinkle to really work on it.
23:44:05 <Cale> (On reflex and reflex-dom anyway)
23:44:22 <kellytk> Cale: That's an obvious concern, can you think of a tradeoff that makes it worth it?
23:44:38 <Cale> Well, it's just ridiculously more productive than anything else
23:44:42 <iqubic> replicateM_ 0 f = pure (); replicateM_ n f = f *> replicateM_ (n - 1) f
23:44:44 <iqubic> got that.
23:44:55 <ertes> iqubic: exactly
23:44:57 <kellytk> Cale: Have you written web front/backends and mobile apps natively before?
23:45:11 <Cale> kellytk: Some
23:45:18 <iqubic> Now, how does that help use write a traversal into the bits of a Word64?
23:45:19 <ertes> iqubic: now here is how you print "hello world" 64 times:  replicateM_ 64 (putStrLn "Hello world!")
23:45:40 <ertes> iqubic: emphasis is on "64"
23:45:40 <iqubic> Alright then.
23:45:46 <iqubic> Is see.
23:45:58 <iqubic> Now what it the signature for the traversal?
23:46:16 <ertes> bitsWord64 :: (Applicative f) => (Bool -> f Bool) -> Word64 -> f Word64
23:46:25 <iqubic> Cool.
23:46:28 <kellytk> Cale: How is it better than that?
23:46:42 <kellytk> I should say, more productive which were you words
23:47:01 <iqubic> Now how do I run the function 64 times on 64 *different* bits?
23:47:13 <Cale> kellytk: Well, a bunch of things come together. The main thing though I'd have to say is that Haskell's type system makes refactoring a lot simpler.
23:47:35 <Cale> kellytk: I can start changing something on the backend, and the type errors will bleed through to the frontend and tell me everything I need to update.
23:47:50 <iqubic> ertes: I know how to get a bit, and set a bit again.
23:48:03 <kellytk> Cale: Could the same not be experienced with TypeScript?
23:48:29 <ertes> iqubic: here is a variant of replicateM_ that communicates the current counter value:  constructM_ 0 _ = pure (); constructM_ n f = f n *> constructM_ (n - 1) f
23:48:38 <Cale> kellytk: I don't know TypeScript all that well, but somehow I doubt that its type system is anywhere close to as expressive as Haskell's
23:48:51 <jle`> Sh4rPEYE: not sure if you already solved your problem, but try adding parentheses to see what's wrong
23:48:52 <iqubic> :t constructM_
23:48:54 <lambdabot> error: Variable not in scope: constructM_
23:48:58 <jle`> oh wait you already got it, nvm
23:49:04 <iqubic> why is that not in scope?
23:49:10 <ertes> iqubic: and here is a program that prints the numbers [64,63..1]:  constructM_ 64 print
23:49:17 <Cale> kellytk: I'm sure it would get you a little of that though.
23:49:17 <ertes> iqubic: because i invented it =)
23:49:22 <iqubic> Oh. 
23:49:29 <ertes> iqubic: in practice you would just use 'traverse_' from Data.Foldable
23:49:37 <iqubic> what does that do?
23:49:43 <Cale> kellytk: The type system is a lot more meaningful in Haskell than in most other industrially-viable languages
23:49:47 <ertes> :t traverse_
23:49:48 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
23:50:01 <ertes> :t traverse_ print [64,63..1]
23:50:02 <lambdabot> IO ()
23:50:05 <iqubic> That's a traversal that throws out the result
23:50:17 <ertes> *results, yeah
23:50:27 <iqubic> Alright.
23:50:46 <iqubic> But don't we want the results when working with a travesal?
23:50:48 <kellytk> Cale: Can it do usual things like connect to a PostgreSQL/SQLite instance or process command-line input?
23:51:02 <Cale> kellytk: As an example, on one of our client projects, a chat application which is kind of slack-like but with a bunch of other features, such as integration with email (you can send an email from a channel and the replies will come back there), task management and other organisational features
23:51:18 <ertes> iqubic: yes, this is just conceptual to give you an idea on how to implement the traversal
23:51:21 <kellytk> Very real-worldy there
23:51:28 <Cale> We'd been working on it about a year, and a coworker and I took 2-3 days to turn it into a multi-tenant app
23:51:47 <iqubic> I have no idea how to implement that traversal
23:51:55 <Cale> with one backend serving multiple database schemas on subdomains
23:52:04 <iqubic> I'm sorry.
23:52:09 <Cale> that are kept secure from one another
23:52:34 <iqubic> ertes: Can you help me with that?
23:52:47 <Cale> I think in just about anything else, that change easily might've taken weeks
23:53:00 <iqubic> traverseList f (x:xs) = : <$> f x <*> traverseList f xs
23:53:17 <Cale> kellytk: and yeah, it connects to postgresql
23:53:18 <iqubic> So there we're appending the results into a new list.
23:53:18 <ertes> iqubic: it's not that different from the list traversal:  bitsWord64 f x = combineBits <$> bitWord64 0 f x <*> bitWord64 1 f x <*> … <*> bitWord64 63 f x
23:53:44 <kellytk> Cale: https://github.com/search?utf8=%E2%9C%93&q=haskell+graphql&type=Repositories it even has GraphQL implementations.  Is the JS generation good enough to write a web client that gets data via a GraphQL API?
23:54:06 <ertes> iqubic: bitWord64 :: (Functor f) => Int -> (Bool -> f Bool) -> Word64 -> f Word64
23:54:16 <kellytk> (and build the GraphQL server of course but I infer that's possible)
23:54:20 <iqubic> ertes: I need to right my own combineBits function though.
23:54:29 <iqubic> That doesn't exist.
23:54:34 <ertes> iqubic: not really…  again, this is conceptual
23:54:43 <iqubic> Oh.
23:54:53 <iqubic> So what should I do?
23:54:58 <Cale> kellytk: I'm sure all the parsing stuff would compile. The network I/O probably wouldn't make sense directly.
23:55:13 <Cale> kellytk: You'd have to replace that bit with some XHR or something.
23:55:26 <Cale> But I'm sure it wouldn't be too hard.
23:55:41 <kellytk> Cale: When going outside the paved, is it much trouble?
23:56:01 <ertes> iqubic: let me think of an example i can write for you that doesn't spoil this exercise, but gives you a good clue
23:56:44 <Cale> kellytk: Well, Haskell is almost as nice a language as you could ask for as a baseline.
23:57:08 <Cale> kellytk: and of course, there's FFI in cases where you really don't want to rebuild something in Haskell
23:57:26 <Cale> e.g. we use Javascript FFI to do stuff with Google Maps in a couple of our apps
23:57:28 <ertes> iqubic: are you familiar with the 'vector' library?
23:57:47 <iqubic> Yes. I am
23:58:00 <iqubic> This exercise is quite hard.
23:58:03 <Cale> and of course, there's FFI on the backend which binds the Postgres C library.
23:58:12 <ertes> iqubic: i'll write a horribly inefficient traversal into the elements of a vector, and i'll deliberately use indexing
23:58:13 <Cale> (we didn't have to write that of course, but someone did)
23:58:18 <ertes> iqubic: yes, it is
23:58:28 <iqubic> I like trying this.
23:59:26 <kellytk> So Haskell can call out to other code, such as a JS package from NPM?
