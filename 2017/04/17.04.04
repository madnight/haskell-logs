00:15:38 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
00:15:38 --- topic: set by glguy on [Fri Jan 13 08:41:11 2017]
00:16:07 <jvtbatman> cocreature: Yeah, I got a different error message when trying that but I guess I'll try solving that instead then. Thanks for the help!
00:16:34 <cocreature> jake__: you can split the problem in two parts: first write a function "[(Int, Int)] -> [Int]" and then use the sum function you already have
00:17:15 <cocreature> jake__: oh nvm, sry I didn’t read your question properly
00:18:31 <jake__> cocreature: the fact it's a tuple is really confusing me :/
00:19:11 <cocreature> jake__: so let’s say you want to implement this function using foldr
00:19:13 <cocreature> :t foldr
00:19:14 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
00:19:25 <cocreature> jake__: what is "a" and "b" in your case?
00:23:20 <jake__> cocreature: a would be a function, the (+) function and b would be an integer value, from the pair in the list
00:24:00 <cocreature> jake__: no I mean what is the specific type of "a" and "b" if you want to use it to implement a function [(Int, Int)] -> [Int]
00:25:13 <jake__> :t (+)
00:25:14 <lambdabot> Num a => a -> a -> a
00:25:22 <jake__> and Int?
00:26:12 <cocreature> jake__: let’s step back for a moment, let’s say you implement sum :: [Int] -> Int by "sum = foldr (+) 0"
00:26:19 <cocreature> now look at the type signature of foldr
00:26:21 <cocreature> :t foldr
00:26:23 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
00:26:41 <cocreature> so the first argument you are passing to it is (+)
00:26:57 <cocreature> in your specific case (+) has type "Int -> Int -> Int"
00:27:15 <cocreature> so "a -> b -> b" has to unify with "Int -> Int -> Int"
00:27:26 <cocreature> thereby both a and b have to be Int
00:27:32 <cocreature> does that make sense?
00:27:44 <jake__> I'm following
00:28:20 <cocreature> jake__: alright, now you’re trying to implement "sum :: [(Int, Int)] -> [Int]"
00:28:39 <cocreature> by something like foldr _somefunction _someinitialvalue
00:28:54 <cocreature> where somefunction and someinitialvalue are things that you still need to figure out
00:29:09 <cocreature> eh you want "sum :: [Int, Int)] -> (Int, Int)" sorry
00:29:48 <cocreature> so foldr accepts a list of as
00:29:57 <cocreature> in your specific case that list has type [(Int, Int)]
00:30:01 <cocreature> so what does a have to be?
00:34:27 <jake__> cocreature: so a has to be (Int, Int) right?
00:34:43 <cocreature> jake__: exactly!
00:34:55 <cocreature> jake__: alright so now we need to figure out what "b" is
00:35:22 <cocreature> foldr returns something of type "b" and you want your sum function to return something of type (Int, Int). so what is b?
00:36:25 <jake__> cocreature: so that must be (Int, Int) aswell
00:36:29 * ski idly recalls Wittgenstein's suggestion that different variable names have to stand for different things
00:37:43 <cocreature> jake__: right, so now you know that somefunction  has to be of type "(Int, Int) -> (Int, Int) -> (Int, Int)" and someinitialvalue has to be of type "(Int, Int)"
00:37:59 <dysfun> ski: i hear programming errors are made when variables go on holiday
00:38:02 <cocreature> jake__: now try writing the function and figure out what the initial value is
00:38:26 <cocreature> jake__: just write it as a top-level function. if you want you can try to express it as a lambda after that
00:38:47 <ski> (or a function defined in a `where'/`let'-`in')
00:38:56 <mutsig> #haskell is so awesome. People are so helpful and open minded
00:39:40 <scav> opposed as to what most people like to portrait the haskell community as 
00:39:41 * ski undrar stilla om mutsig har tappat en bokstav
00:39:59 <cocreature> ski: I have no idea what that means
00:40:01 <mutsig> ski: lol :)
00:40:12 <scav> ski hello neighbour! :)
00:40:35 <mutsig> hej
00:41:18 <ski> hejhej. det finns även #haskell.se och #haskell.scandinavian
00:41:42 <scav> really?
00:42:11 <scav> Legendary topic!
00:43:41 <f-a> I am getting this error while uploading to hackage http://paste.debian.net/plain/925840
00:44:27 <f-a> and this is the .cabal file http://ariis.it/link/repos/lentil/lentil.cabal , which seems correct to me (conditional -Werror, default off)
00:44:57 <f-a> welp, test suite too :s sorry for the noise
00:46:21 <otulp> Rubber Duck debugging in action. :)
00:46:48 <f-a> hehe
00:49:13 <Reisen> Dumb question
00:49:25 <Rembane> Reisen: Shoot!
00:49:28 <Reisen> Inside a do block with ExceptT, if I want to ignore a failure case, how can I do so?
00:50:02 <Rembane> Catch it and return () ?
00:50:47 <Reisen> I feel so dumb, catchE it is
00:50:53 <Rembane> :D
00:50:54 <Reisen> Thanks, brain just completely crapped itself 
00:51:00 <Rembane> No worries.
00:51:12 <Rembane> It does from time to time and IRC can fix this. :)
00:52:04 <Reisen> Very true
00:53:47 <quchen> ski: Hah, Wittgenstein as a variable naming authority. I’m sure he’d have liked that.
00:54:23 <quchen> data Box a = Box a
00:54:26 <quchen> data Beetle = …
01:17:00 <otulp> module Acme.Wittgenstein ( Box, beJustAsSloshedAsSchlegel ) where ...
01:18:32 <tsahyt> I decided to put my hoogle powered gtk haddock viewer on github. https://github.com/tsahyt/hdocview in case anyone cares or wants to tear my code apart.
01:18:48 <tsahyt> it's really just a little convenience tool for personal use but I figured someone else might want it too
01:24:40 <quchen> tsahyt: Add screenshots!
01:24:41 <quchen> :-)
01:25:12 <quchen> (Probably *the* most important thing to do to get users.?
01:25:22 <quchen> s/?/)/  <- ugh
01:26:47 <tsahyt> that's not a bad idea
01:27:12 <otulp> tsahyt: Thanks. I had a quick look and learned something new, which is always nice.
01:27:18 <tsahyt> especially since this is built with haskell-gi, the whole of which takes literally an eternity to compile
01:28:01 <tsahyt> otulp: I mostly learned that compiling OverloadedLabels heavy code is incredibly time consuming
01:28:19 <tsahyt> otulp: out of curiosity, what did you find?
01:29:30 <otulp> Uhm, well. That time-consuming haskell-gi world for one. It's been a while since I had a look at GUI stuff. Nothing
01:29:48 <otulp> ... Nothing's ever fit quite right.
01:31:07 <tsahyt> I'm still not quite sure what the best way to write GUIs in haskell is either. The gi-gtk stuff is okay to work with, FRP makes it all a bit nicer. What I'm unsure about is mostly organization. Here I pass a GUI type around most of the time to retain access to the handles I nedd
01:31:09 <tsahyt> need*
01:31:16 <tsahyt> of course I could also do this in a reader monad
01:35:20 <tsahyt> quchen: screenshot added
01:35:40 <tsahyt> bind shall serve as the example
01:36:14 <otulp> Sure, but passing gui around works fine, too. I don't think anybody's getting lost in all the function parameters.
01:38:08 <tsahyt> at this project size, yes. I'm unsure how well it scales though.
01:38:49 <tsahyt> in fact for this particular project I'm also getting very little mileage out of using FRP
01:39:04 <tsahyt> but it still feels cleaner than dealing with callbacks explicitly, so there's that
01:39:57 <otulp> The screenshot helps immensely. All apps should have at least one.
01:40:37 <tsahyt> I agree. as the author you tend to forget that though, because you of course already know what it looks like
01:40:57 <tsahyt> for me this is really the one logical layout for such an application, but I suppose other people would come up with different ones
01:41:03 <tsahyt> UI design can be surprisingly tricky
01:41:54 <otulp> FRP is also one of those things I haven't quite made up my mind about. At the current complexity of hdocview I guess it serves as a fine practical introduction to using reactive-banana with gtk.
01:43:00 <otulp> Oh, you could surely have made something that looked terrible. The screenshot establishes nicely that you didn't.
01:43:27 <tdammers> as far as I am concerned, GUI programming is still an unsolved problem
01:47:01 <tsahyt> tdammers: agreed. I think FRP is a good start though
01:47:31 <Jello_Raptor> Is there an ST like abstraction with support for parallelism? computations that look (and act) pure from the outside, but are implemented with mutable state and multiple threads for efficiency? 
01:47:37 <tsahyt> otulp: thanks! I'm still looking for something that allows me to use FRP more extensively. I once did a small asteroids clone using the wires AFRP library.
01:48:11 <Jello_Raptor> ST doesn't look like it does parallelism :/ I can't find anything like forkIO
01:48:37 <cocreature> Jello_Raptor: well how do you ensure that it’s deterministic if you can introduce race conditions via multiple threads?
01:49:08 <cocreature> Jello_Raptor: you can probably use "par" in ST but that’s a different model of parallelism than forkIO
01:49:10 <otulp> All I want is a cross-platform, perfect looking, efficient GUI toolkit that lets me decouple everything from everything while being foolproof, very strongly typed and opinionated (with opinions matching my own). I mean, is that so hard?
01:49:25 <Jello_Raptor> cocreature: i thought "par' was just concurrency on a single thread
01:49:32 <tsahyt> otulp: the opinionated part might be very hard. there are a lot of opinions out there
01:49:33 <tdammers> tsahyt: definitely
01:49:43 <cocreature> Jello_Raptor: are you talking about OS threads or Haskell threads?
01:49:57 <cocreature> Jello_Raptor: "par" definitely parallelizes using multiple OS threads
01:50:16 <tsahyt> otulp: One day I want to attempt writing a GUI library in Haskell, just to explore the design space
01:50:24 <tsahyt> but that'd have to be a bigger project than I have time for at the moment
01:50:27 <cocreature> I’m not sure if it uses multiple Haskell threads. it relies on sparks and I’m not sure how they interact with haskell threads
01:50:47 <otulp> tsahyt: Best of luck to you. Surely someday *someone*
01:51:01 <otulp>  tsahyt: ... will get most things right.
01:51:12 <otulp> My pinky's too long, it seems.
01:51:28 <Jello_Raptor> cocreature: It's one of those "assuming all the laws hold, it's a provably convergent process even in the presence of race conditions" type thing
01:51:40 <cocreature> Jello_Raptor: if you are really sure that you’re code presents a pure interface, just use "unsafePerformIO"
01:51:41 <tsahyt> I actually rather like gtk, except for a few quirks. but that's also because I don't really care about other platforms.
01:51:58 <tsahyt> I suppose if you wanted that, wrapping qt into better abstractions would be an option
01:52:09 <cocreature> the point of ST is that you can’t present a non-pure interface using it
01:52:20 <cocreature> and not “trust me I know it’s pure”
01:52:22 <tsahyt> there's also wxwidgets which supposedly looks native on every platform, but the bindings seem to be unmaintained.
01:52:27 <cocreature> that’s what unsafePerformIO is for
01:53:19 <Jello_Raptor> cocreature: ahh, okay, interesting. The ideal case would be something where I can end up using more than one CPU while living inside an ST monad. But that makes sense, cool. 
01:53:43 <cocreature> Jello_Raptor: if you can express your algorithm using "par" that should work I think.
01:54:06 <cocreature> but I don’t think "par" and mutable state interact very well
01:57:17 <Jello_Raptor> cocreature: *nods* yeah, that interface doesn't give you any good way to thread thing around. It sounds like I should get the guarantees I want with STM and IO, and the interface I want with unsafePerformIO. 
02:08:12 <_sras_> Ok. Why does my Stack use stack.yml file from a completly different folder?
02:08:33 <_sras_> I mean, stack.yaml
02:12:14 <otulp> _sras_: I have to ask: Does the working directory have a stack.yaml file in it?
02:13:08 <cocreature> _sras_: since you mentioned having moved the directory before, did you try nuking .stack-work?
02:14:22 <cocreature> _sras_: if you have, the directory structure you’re using (including the file that stack chooses) would be interesting
02:17:19 <_sras_> otulp: Yes
02:17:33 <_sras_> cocreature: I tried it.
02:19:37 <ph88^> how come PS.anyChar is not greedy enough that it consumes the second ; ? https://bpaste.net/show/d6a1b91419d6
02:21:33 <cocreature> ph88^: anyChar consumes the first ';', the second is consumed by the separator
02:22:22 <Aruro> is it possible to sugarise mappend as (>>) ?
02:22:44 <Aruro> thus relaxing constraint from forall a b . to forall a a.
02:23:06 <Aruro> so do block is just sum of its elements
02:23:51 <ph88^> cocreature, ah yes i accidentally put the wrong parser, i meant this one https://bpaste.net/show/e1fd067a0807 which fails .. but how can i create a parser that consume any char except the text that is matched by the  end  parser   ?
02:24:20 <mniip> Aruro, if you can find a lawful >>= sure
02:27:56 <Aruro> mniip: i can not, so far, because type of (>>) conflicts with mappend, its too general
02:28:00 <Aruro> :t (>>)
02:28:02 <lambdabot> Monad m => m a -> m b -> m b
02:28:08 <Aruro> b is problem
02:28:17 <mniip> use a phantom type
02:29:41 <Aruro> hm, maybe that will work
02:32:19 <tsahyt> :t Const
02:32:20 <lambdabot> forall k (b :: k) a. a -> Const a b
02:32:29 <tsahyt> maybe relevant?
02:32:43 <cocreature> ph88^: "many1 anyChar" consumes ";;" but then you have no separator at the end
02:34:15 <augur> :k Const
02:34:16 <lambdabot> * -> k -> *
02:34:26 <augur> interesting
02:34:44 <augur> strange choice. i wonder why its that
02:35:35 <cocreature> augur: hm? what other choice do you have?
02:35:50 <_sras_> cocreature: The only thing is that my old path was inside a linux vm, and the new path is on my host machine, mac os, and the folder is shared with the linux vm.
02:35:52 <augur> * -> * -> *
02:36:18 <ph88^> cocreature, how can i express to consume any char except ; and then at the end a ; ?
02:36:19 <cocreature> augur: well that’s less general :)
02:36:21 <augur> i mean, i get that b doesn't need to be so constrained since we never try to take an argument of it
02:36:41 <cocreature> ph88^: noneOf is probably what you’re looking for
02:36:42 <augur> im just curious what the use cases are that motivate this
02:36:58 <cocreature> augur: iirc I’ve used it with DataKinds at some point
02:37:04 <augur> interesting!
02:37:18 <ph88^> ok
02:41:19 <tsahyt> Aruro: why did you need the sugar for (>>) to begin with?
02:41:24 <tsahyt> I suppose for use in do notation?
02:43:28 <jake__> cocreature: Hey, I'm still working on the same problem. I managed to solve it recursively, but I can figure out how to do it using foldr & or lambda functions. I think i'll just do some more study into this area, i'm having a lot of trouble wrapping my head around the concepts. I just wanted to say thanks for your help earlier :)
02:43:31 <tsahyt> I wonder whether this would also be possible by abusing Const and ApplicativeDo
02:43:42 <jake__> *can't
02:43:46 <tsahyt> but I guess not
02:44:21 <cocreature> jake__: what kind of problems did you ran into while writing "f :: (Int, Int) -> (Int, Int) -> (Int, Int)"?
02:44:39 <cocreature> jake__: if you want I can ofc show you the solution but usually you learn more if you come up with it yourself :)
02:45:59 <lpaste> Booba pasted “LimitedHangman.hs” at http://lpaste.net/354266
02:47:01 <Booba> ertes: Hello! I'd struggled a bit with maybies and monoids and finally figured it out, I guess. Mind taking a look and giving your opinion? http://lpaste.net/354266
02:49:30 <jake__> cocreature: even getting started on it, I couldn't really figure out where to begin. I would start on a solution, and then realize I was solving it recursively, and start again. Also knowing the types everything needed to be didn't help much as I couldn't figure out how to write a function that actually expresses those types. 
02:51:40 <cocreature> jake__: alright, let me just show you the solution http://lpaste.net/354267
02:51:51 <cocreature> jake__: feel free to ask if you have trouble understanding what this function does
02:52:37 <jake__> cocreature: I swear I did this!!! GHCI was chuckin errors at me! :P What are the commas after the x?
02:52:54 <ski> pairs
02:53:01 <cocreature> jake__: (x, y) is a tuple of two elements with the elements being x and y
02:53:06 <cocreature> :t (1, "hi")
02:53:07 <lambdabot> Num t => (t, [Char])
02:53:14 * ski . o O ( components )
02:53:20 <cocreature> :t (True, "hi")
02:53:22 <lambdabot> (Bool, [Char])
02:54:25 <jake__> cocreature: Not the commas, the x' sorry. Inverted comma? Apostrophe?
02:54:39 <cocreature> jake__: oh x' is just a variable name like any other
02:54:44 <ski> that's part of the variable name
02:54:57 <cocreature> jake__: call it "z" or "foobar" or whatever you like :)
02:55:06 <ski> by convention, adding an apostrophe means roughly "a variant"
02:55:22 <jake__> cocreature: whaaat... I did that and it wouldn't work
02:55:38 <cocreature> jake__: it’s hard to tell you what you did wrong without seeing the code :)
02:56:04 <bollu> is there a maintained implementation of miniKraken for haskell?
02:56:28 <jake__> cocreature: I understand. It's reassuring that i'm not going insane and that i'm on the right theoretical track :P I'll have another try, thanks
02:59:26 <jake__> cocreature: IT WORKS. MY CODE WORKS :'( I spent so long on it and i had it right at the beginning. I must have had a typo or something... I was reading the ghci errors and didn't see anything indicating typos. Thank you so much for helping hahaha :)
03:00:04 <cocreature> jake__: I’m happy, you got it working :)
03:17:15 <peddie> bollu: if you mean miniKanren, then I don't think there is, I looked around a few months ago
03:18:14 <cocreature> peddie: heh, I first thought it was a typo as well, but it looks like minikraken is actually a thing as well :)
03:18:23 <peddie> oooops, sorry :)
03:18:46 <cocreature> although maybe it was a typo and that’s just a coincidence :)
03:19:28 <peddie> cocreature: the BLAST program?
03:20:01 <cocreature> peddie: it looked like something related to DNA processing but I didn’t really look into it
03:20:36 <peddie> got it!  well, bollu, I don't know of any miniKraken implementations in Haskell either ;)
03:22:12 <vaibhavsagar> bollu: this looks like the least unmaintained one https://github.com/sergv/hkanren
03:50:37 <HugoDaniel> hello
03:50:59 <HugoDaniel> i was asked to give a 2h workshop on begining haskell, any advice from the pros ?
03:51:24 <JuanDaugherty> get paid first
03:53:11 <bollu> peddie: yes, I did mean miniKanren :)
03:53:19 <bollu> peddie: brain chose to fill it in as "Kraken"
04:03:55 <ertes> Booba: on a first glance that looks fine
04:05:07 <liste> minikraken sounds cute
04:06:06 <tdammers> (V) ;,,; (V)
04:06:09 <tdammers> zoidberg agrees
04:10:34 <tsahyt> TIL logic programming with proper types is already a thing
04:10:38 <tsahyt> well there goes another phd thesis idea
04:10:55 <tsahyt> not that it was a serious idea to begin with, but still. this is interesting though
04:11:09 * ski . o O ( Mercury )
04:22:37 <JuanDaugherty> tsahyt, y, higher order ones even
04:25:02 <{AS}> Is there a monadic version of traverse that also joins?
04:27:21 <{AS}> i.e. (a -> f (t b)) -> t a -> f (t b) 
04:29:00 <tsahyt> JuanDaugherty: do you have a link perhaps?
04:29:37 <abhiroop> does anybody have experience with the optparse-applicative library?
04:31:12 <JuanDaugherty> tsahyt, http://teyjus.cs.umn.edu/
04:31:42 <hpc> abhiroop: are you having some particular problem with it?
04:32:05 <JuanDaugherty> (e.g. there are others)
04:32:14 <abhiroop> hpc: yes I was wondering if its possible to parse a list of filepath using it?
04:32:50 <hpc> should be quite possible
04:33:25 <hpc> i would expect you would need to do something like make an argument you can pass multiple times (like grep's -e) or parse a comma-separated value
04:34:35 <tsahyt> JuanDaugherty: thanks
04:35:45 <JuanDaugherty> np
04:36:16 <abhiroop> hpc: currently my single file parser looks like this http://lpaste.net/354269
04:36:42 <abhiroop> I was wondering if I can modify this to include multiple files
04:40:09 <brynedwards> abhiroop: maybe http://lpaste.net/354269
04:40:16 <rubenz> how come the Haskell Platform on Ubuntu is GHC 7.10.3 instead of GHC 8 ?
04:40:44 <xenog> I would like to know if there is a way to know whether a thread has died knowing only its ThreadId.
04:41:48 <merijn> xenog: Make the thread signal an MVar/TVar/whatever upon exit?
04:41:49 <xenog> By thread I mean a lightweight thread created with forkIO.
04:42:12 <hpc> abhiroop: a rather lazy solution would be to replace strOption with option auto
04:42:13 <cocreature> :t threadStatus
04:42:14 <lambdabot> error: Variable not in scope: threadStatus
04:42:19 <ertes> xenog: use the 'async' library
04:42:20 <hpc> abhiroop: which would use the Read instance for [FilePath]
04:42:22 <JuanDaugherty> rubenz, b/c ubuntu don't give a shit?
04:42:24 <cocreature> xenog: threadStatus might be what you’re looking for
04:42:48 <cocreature> xenog: it’s in GHC.Conc
04:42:52 <xenog> @merijn, yes, I know that. @ertes, I also know about the async library. Perhaps threadStatus is what I need.
04:42:53 <lambdabot> Unknown command, try @list
04:42:59 <hpc> abhiroop: the first thing i might try is writing a value of type ReadM [String] that just splits on ',' though
04:43:03 <hpc> and passing that to option instead
04:43:12 <xenog> @cocreature, thank you. That I think will help me solve my problem.
04:43:12 <lambdabot> Unknown command, try @list
04:43:35 <abhiroop> The solution which brynedwards : gave seems correct too
04:43:41 <abhiroop> http://lpaste.net/354269
04:43:52 <xenog> Damn, this is IRC, I don't have to prefix names with '@'.
04:43:54 <ertes> xenog: if this is really the only thing you care about, then yes, but as soon as you need things like clean exits, use async
04:44:29 <brynedwards> I think with my code you would have to do `:main --file <file1> --file <file2>` etc.
04:44:47 <Booba> ertes: so if I would want to make a LimitedHangman game, should I expose Hangman constructors? I mean, once I have a constructred Hangman game, there is no way I can run it. Only hangmanStdio can run it.
04:44:58 <ertes> xenog: i would use async even in this case, because importing GHC.* modules makes me feel dirty =)
04:45:02 <JuanDaugherty> also hp changed structure which likely creates additional work for ubuntu
04:45:13 <Booba> ertes: Note: I'm trying to build LimitedHangman in a separate module
04:45:29 <xenog> ertes, I am writing a tiny library for Erlang-style actors. It has to deal with keeping mailboxes automatically for any thread on the system for which it may make sense.
04:45:44 <ertes> Booba: is there a reason for Hangman to be opaque in your opinion?
04:46:00 <hpc> abhiroop: oh that's probably better - forgot about Alternative
04:46:01 <ertes> xenog: single-process?
04:46:06 <xenog> It's meant to just work and not require any setup. That's why I need to know about threads that aren't longer available. I wouldn't want to keep mailboxes forever.
04:46:24 <stephAne_> HI, i need to apply (f1,f2) to a value (a1,a2). I can define a local function that does this or lambda like \(f,f') (a,a') -> (f a, f' a'), it's not that complicated. But I wanted to know if there's not a more direct/elegant/haskellish way to do it.
04:46:32 <xenog> ertes, yes, single OS process, multiple lightweight or OS threads.
04:46:41 <merijn> stephAne_: bimap?
04:46:44 <merijn> :t bimap
04:46:45 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
04:46:47 <Booba> ertes: none that I can see right now.
04:46:59 <stephAne_> perfect, that's what I kind of remembered
04:47:06 <rubenz> JuanDaugherty, they should warn you about that somewhere so you dont install it
04:47:06 <stephAne_> bimap
04:47:24 <ertes> Booba: that's correct, Hangman is correct by construction
04:47:30 <merijn> stephAne_: There's also the cryptic stuff from Arrow, but I would prefer Bifunctor over arrows for this
04:47:37 <xenog> ertes, I will force users to start/stop processes using provided functions, although they will very well be encouraged to manage them using an OTP-style supervisor library.
04:47:38 <ertes> Booba: there are no special invariants
04:48:30 <xenog> When I mean processes in the last message I mean light threads.
04:49:03 <xenog> s/mean/said/
04:49:18 <Booba> ertes: ok, got it. About LimitedHangman. Is it ok to assert that its shape could conform the Hangmans shape? In a sense: representation + next steps
04:49:41 <Booba> ertes: I can reuse representation of Hngman an define my orn next steps on top of Hangman steps
04:49:47 <ertes> Booba: sorry, i don't know what you mean
04:50:12 <ertes> Booba: ah, the thing that LimitedHangman introduces is a "lost" state
04:51:04 <ertes> xenog: well, go ahead, although i think there are already a few unused actor model libraries on hackage =)
04:51:11 <Booba> ertes: yes, LimitedHangman has 'brand new' Lost state and some sort of analogy to Guess - a running game that is a composition over Hangman game
04:52:42 <xenog> ertes, I haven't found exactly what I'm looking for. I didn't look much though. I may end up using the existing supervisor library. Cloud Haskell is too much.
04:53:41 <novakboskov> I have a little problem with stack build tool
04:53:52 <ertes> xenog: i guess my question is why you need a supervisor library in the first place…  i can't imagine many scenarios where the "withAsync" pattern isn't enough
04:54:10 <novakboskov> It this right place for a little question about stack?
04:54:49 <xenog> ertes, I'm writing a peer-to-peer application.
04:54:52 <ertes> xenog: and when it really isn't enough, there is the 'resourcet' library
04:55:17 <brynedwards> novakboskov: what's the question?
04:56:18 <xenog> ertes, managing many peers as well as some processes that handle state can become a bit annoying with just async. This is yet another iteration where I'm trying an Erlang-like approach to the problem.
04:56:42 <xenog> I have tried various approaches already. None of them have been satisfactory.
04:56:47 <ertes> xenog: in a P2P application i would most likely just fire up threads and let them handle themselves
04:57:03 <novakboskov> brynedwards: I've made a new project with stack new my-project and done stack setup then tried to stack build and got a weired error that says: In the dependencies for some-completely-unrelated-project ....
04:57:19 <ertes> xenog: if they die, they die…  as long as they clean up properly, that's fine
04:57:41 <xenog> ertes, I kind of want to separate the logic that deals with threads dying and how to recover from that.
04:58:13 <brynedwards> novakboskov: maybe paste the full error here http://lpaste.net/
04:58:36 <ertes> xenog: well, haskell does support erlang-style concurrency patterns, so go ahead…  just keep in mind that haskell actually supports many more patterns
04:59:01 <ertes> xenog: for example with STM there is often little reason to be really aware of which threads are running
05:00:12 <novakboskov> brynedwards: http://lpaste.net/354270
05:00:16 <xenog> ertes, yes, I have tried using the withAsync system and asynchronous actors communicating with channels, but the way I was doing it was ugly since I wasn't abstracting the actor management enough. I tried to combine this approach then with STM and no mailboxes, but I have a hard time reasoning about my code now. So the Erlang pattern is what I'll try now.
05:01:23 <xenog> ertes, STM worked well when I had copy-cat threads all using the same state. When different thread code used the same STM variables, I started encountering unpleasantness.
05:02:04 <xenog> ertes, I expect in the end use a combination of various techniques.
05:02:32 <xenog> The idea always being that I want the code to be very easy to maintain and reason about, and obviously correct.
05:03:01 <brynedwards> novakboskov: You'll need to either change your week5.cabal file to allow a newer dependency for containers or use an older stackage snapshot
05:03:29 <xenog> The Erlang style of communicating processes (threads) allows for quite compartmentalized code free of defensive exception management structures.
05:04:32 <xenog> I don't really know if in the end I'll achieve what I'm looking for, but a priori it seems that it will make my code easier to maintain and reason about.
05:04:56 <novakboskov> brynedwards: I've done so. This is the week5.cabal http://lpaste.net/3465455935428755456
05:05:09 <ertes> xenog: well, of course all threads using the same STM state need to assume the same invariants, and there is a really easy way to achieve that: write a separate module with "allowed transactions"
05:06:08 <brynedwards> novakboskov: maybe try `stack clean --full && stack build`
05:07:11 <xenog> ertes, that's an interesting idea. Would you elaborate?
05:07:18 <brynedwards> novakboskov: another possible solution is, in stack.yaml, change `resolver: lts-X.X` to `resolver: lts-6.30`
05:07:29 <ertes> xenog: that's pretty much it
05:07:33 <novakboskov> brynedwards: No change... And why is week5 relevant for a totally unrelated project?
05:08:11 <brynedwards> novakboskov: I'm afraid I don't know, sorry
05:09:14 <lyxia> novakboskov: what is in your stack.yaml
05:09:42 <novakboskov> lyxia: of what project?
05:10:08 <lyxia> novakboskov: whichever one you are using
05:11:24 <novakboskov> lyxia: there is no stack.yaml only .cabal
05:12:59 <lyxia> I didn't think you could run stack build with no stack.yaml
05:15:14 <lyxia> novakboskov: try stack init to set up a stack.yaml file
05:17:47 <novakboskov> lyxia: It looks like stack init stucks at fetching some indices... It says Updating package index Hackage (mirrored at https://s3.amazonaws.com/hackage.fpcomplete.com/) .../home/novak/.stack/indices/Hackage/hackage-security-lock: createDirectory: already exists (File exists)
05:20:42 <lyxia> https://github.com/commercialhaskell/stack/issues/3055 ?
05:24:48 <novakboskov> lyxia: Yup, it's it... I've manually deleted that lock and everything is fine again. I haven't seen that error message... My fault... Thanks
05:35:37 <Booba> ertes: I ended up having something like this:
05:35:44 <lpaste> Booba pasted “LimitedHangman.hs” at http://lpaste.net/354272
05:36:03 <Booba> ertes: Am I at least moving in the right direction?
05:36:59 <Booba> ertes: Am I supposed to  figure out this types properties (Monoid, Monad, Applicative, etc) at this point, or earlier, or later when more features arrive?
05:43:46 <ertes> Booba: yeah, looks reasonable
05:44:47 <ertes> Booba: not sure about your last question…  i figured those structures out as i read docs, as i read code and as others made me aware of them
05:45:23 <Booba> ertes: that helps =)
05:48:26 <Booba> ertes: is it okay that `run` function is not part of the datatype as opposed to original Hangman?
05:49:15 <Booba> ertes: I ask this in scope of a large team project. Does it follow any code styles/conventions set be the original Hangman?
05:49:47 <Booba> ertes: IOW, if I would extend your Hangman game this way, and you were my codereviewer, will it pass?
05:56:57 <ertes> Booba: well, i would have renamed the 'run' function, perhaps to 'move' or 'guess'
05:57:08 <ertes> other than that it looks reasonable to me
05:57:53 <ertes> Booba: in fact you recently mentioned the idea of a type class to abstract over things that support "moves"
05:57:57 <piyush-kurur> alanz: ping
05:58:04 <ertes> that's probably the approach i would have taken
05:58:48 <alanz> piyush-kurur: pong
05:58:55 <Booba> ertes: Thanks! That's really helpful.
05:59:39 <ertes> Booba: the idea being that you can abstract over this class
06:00:07 <ertes> Booba: for example you could write a generic bot that tries to beat games that support "moves"
06:00:33 <lpaste> Booba pasted “LimitedHangman.hs” at http://lpaste.net/354273
06:00:41 <Booba> ertes: ^ And another option
06:00:47 <piyush-kurur> alanz: to handle the -no-pie problem what exactly should be done?
06:01:06 <Booba> ertes: I incorporated `move` into datatype and made a smart constructor for it
06:01:32 <ertes> Booba: if you're going to do it that way, you shouldn't expose the Hangman itself
06:01:40 <ertes> because now you have redundancy
06:02:20 <ertes> you should only expose the challenge and the move function
06:02:25 <ertes> and the number of guesses left
06:03:29 <alanz> piyush-kurur: probably best to delete ~/.stack/programs directory, then run stack setup
06:04:04 <piyush-kurur> alanz: let me try.
06:04:05 <ertes> Booba: in fact i like this approach better, because it's closer to the idea of exposing a safe abstraction from the start…  this version, once you have eliminated the redundancy, does not assume any invariants that the data type itself doesn't already enforce
06:04:36 <alanz> It will rebuild the lts into a new subdirectory with nopie in the name
06:05:07 <piyush-kurur> alanz: I hope it is sufficient to just get rid of 7.10.*
06:05:22 <alanz> liquidhaskell works only with 7.10, so yes
06:05:25 <Booba> ertes: I'm not sure I understand: I do not expose Hangman from LimitedHangam. You have to construct the game yourself oand pass it to `limited` function.
06:06:01 <Booba> ertes: limitedHangmanStdio_ $ limited 5 $ fromString "Hello World"
06:06:11 <alanz> piyush-kurur: but if you are getting linker issues with that one, you may be getting them with others too.
06:06:34 <alanz> And I just realised there may be another issue affecting this. Let me know how that works first
06:07:28 <alanz> piyush-kurur: you may need to do this too: https://github.com/commercialhaskell/stack/issues/3072
06:07:31 <piyush-kurur> alanz: No I do not seem to have problems with 8.*
06:07:50 <piyush-kurur> I mean ghc-version-8.*
06:08:17 <piyush-kurur> With stack < 7 the ghc-version becomes 7.10 I guess then all hell breaks loose
06:08:43 <ertes> Booba: you see, in Hangman the actual state of the game is completely encapsulated in 'singleton' and 'mappend'
06:08:51 <alanz> ok. But liquidhaskell specifically uses that lts version, as it needs GHC 7.10
06:09:07 <ertes> Booba: you can do the same with LimitedHangman…  there is no reason to expose the Hangman game
06:09:49 <Booba> ertes: or you're saying I should push it further and abstract over Hangman demanding that LimitedHangman only wants some representation and a `good` function to get constructed??
06:10:22 <ertes> Booba: consider that the type signatures of 'limited' and 'move' wouldn't change at all
06:10:33 <Booba> ertes: more like making a LimitedGame instead?
06:11:05 <ertes> Booba: it's still Hangman, but if you actually implement the type class idea, then yes, you can use Limited for a wide variety of games
06:11:46 <ertes> (you can already do that, but you would have to write multiple implementations of 'limited', one for each game type)
06:12:17 <Booba> ertes: I'll try that later. But I still can't see where redundency is in current implementation
06:13:14 <Booba> ertes: You're saying that Hangman should be opaque, right?
06:13:19 <ertes> no
06:13:42 <ertes> Booba: LimitedGuess Integer [Maybe b] (a -> Maybe (LimitedHangman a b))  -- would this be limiting?
06:14:30 <Booba> ertes: that was my next suggestion: I can construct the limited game "from scratch", is that what you're saying?
06:14:59 <ertes> Booba: no, you would still reuse Hangman, but there is no reason to *expose* it once you have handed it to 'limited'
06:15:33 <Booba> ertes: I'll give it a thought, thanks
06:17:07 <Booba> ertes: ok, so your suggested LimitHangman says that it has a representation and a `move` of its own. But the actual implementation would reuse the ones of Hangman, right?
06:17:28 <ertes> Booba: yes
06:18:03 <piyush-kurur> alanz: I remember doing this editing some time ago but do not remember where. sorry. This was when I was moving from stack-6 to stack-7. As fate would have it, at that time it was stack-7 that was giving problems.
06:18:27 <piyush-kurur> What I do not understand is that it seems to be fine with travis builds which are on ubuntu
06:19:18 <Booba> ertes: should I assert that this approach is better because it is more flexible in terms of implementation - I am free to use another game, but Hangman?
06:19:48 <Booba> ertes: as long as I am able to derive Nothing "state" of its?
06:20:29 <ertes> Booba: basically you're approaching a more generic automaton-based approach step by step
06:20:54 <ertes> and Limited is a way to stop an automaton prematurely
06:21:12 <ertes> if it doesn't conclude within a certain number of steps
06:23:08 <Booba> ertes: I see. I was thinking about it this way: I am extending the Hangman game to LimitedHangman by composing over it. This I reflect in my datatype: LimitedHangman explicitly uses Hangman.
06:23:48 <Booba> ertes: But it appears that further iterations can abstract over Hangman and make the LimitedHangman more generic, right?
06:25:18 <alanz> piyush-kurur: the travis vm is ubuntu 12.04 or something equally archaic
06:26:04 <alanz> And this is the file to edit: ~/.stack/programs/x86_64-linux/ghc-nopie-7.10.3/lib/ghc-7.10.3/settings
06:27:27 <piyush-kurur> alanz: how did you get a ghc-nopie executable there. Did you compile it on your own?
06:27:37 <piyush-kurur> I do not seem to have any
06:28:39 <alanz> piyush-kurur: in the liquidhaskell directory, do "stack setup"
06:28:56 <alanz> or, "stack setup --resolver=ghc-7.10.3"
06:29:24 <ertes> Booba: you can answer that question yourself
06:35:49 <piyush-kurur> alanz: I am getting the following errors
06:36:42 <piyush-kurur> in liquidhaskell directory if I do a stack setup it installs ghc-7.10.2 instead of 7.10.3 and then fails with linker error (after the change that you mentioned)
06:37:21 <alanz> piyush-kurur: what is the precise linker error? Maybe post it via lpaste or similar
06:37:34 <alanz> and 7.10.2 should be fine too
06:38:17 <alanz> in which case "stack setup --resolver=ghc-7.10.2"
06:40:43 <piyush-kurur> alanz: http://lpaste.net/2636326002313134080
06:42:53 <alanz> piyush-kurur: that is the wrong compiler, it is not the no-pie version
06:44:55 <alanz> piyush-kurur: this is what you should see: http://lpaste.net/5657215890182111232
06:45:11 <piyush-kurur> however the 7.10.3 says a different error. It says no cabal file in liquidhaskell/liquid-fixpoint
06:45:51 <piyush-kurur> alanz: I fixed the 7.10.2 issues. The liquid haskell that I had was a bit old so I cloned the latest
06:46:00 <piyush-kurur> but then something new comes up
06:46:17 <alanz> piyush-kurur: what branch are you using? develop?
06:46:26 <piyush-kurur> alanz: yes 
06:46:46 <piyush-kurur> I mean whatever is the default branch from a git clone
06:46:46 <alanz> you need to make sure you do a "git submodule update --init" to get the right submodules
06:46:51 <piyush-kurur> okey
06:47:20 <piyush-kurur> sorry I did not realise there were submodules
06:48:30 <piyush-kurur> okey that fixed it now gives a lot of dependency problems. Seems to not like the base version.
06:48:31 <alanz> piyush-kurur: you need these prerequisites too: https://github.com/ucsd-progsys/liquidhaskell/blob/develop/INSTALL.md
06:48:40 <alanz> z3 or equivalent
06:49:22 <piyush-kurur> alanz: I have the z3 from debian distro I guess that should be fine
06:49:39 <alanz> I am on debian testing and it works fine for me
06:49:59 <alanz> package libz3-dev
06:54:57 <piyush-kurur> Dependency problem on stack build  (http://lpaste.net/852335151789637632)
06:55:40 <Booba> ertes: Last question for today, I promise! =) Should LimitedHangman has a Won constructor of its own in your suggestion?
06:57:47 <ertes> Booba: if you hide Hangman, then yes
07:00:12 <Booba> ertes: Got it! Thank you for your guidance a lot! I really struggled to find a nice guide on how to approach problems the haskell way on the internet.
07:01:30 <piyush-kurur> alanz: finally things are building yaahooooo
07:01:51 <Aruro> can where span several definitions? would be really handy
07:01:55 <ertes> Booba: this is of course only one application, but it should give you a general idea of working with DSLs
07:02:23 <ertes> Booba: both Hangman and LimitedHangman are DSLs, and 'limited' translates from one to the other
07:04:54 <Aruro> f1 x y = 1 + x +y**2, f2 x y = 1+2*x+y**2; i want to say f1 x y = ..+b;f2 x y = ...+b where b = y**2
07:05:09 <alanz> piyush-kurur: great
07:05:10 <piyush-kurur> alanz: I jumped around too early looks kiek I am bitten by the pic bug
07:05:19 <piyush-kurur> s/kiek/like
07:07:03 <alanz> ok
07:07:26 <lyxia> Aruro: no
07:08:23 <alanz> piyush-kurur: heads up, the liquidhaskell develop branch no longer uses the "Prop" keyword. So if the docs say "Prop v", change it to just "v"
07:08:40 <lyxia> Aruro: this proposal seems close to what you are looking for https://github.com/ghc-proposals/ghc-proposals/blob/context-fixes/proposals/0000-context-fixes.rst
07:08:51 <Sornaensis> > True <> False
07:08:53 <lambdabot>  error:
07:08:53 <lambdabot>      • No instance for (Monoid Bool) arising from a use of ‘<>’
07:08:53 <lambdabot>      • In the expression: True <> False
07:09:01 <Sornaensis> > True <|> False
07:09:03 <lambdabot>  error:
07:09:03 <lambdabot>      • Couldn't match expected type ‘f a’ with actual type ‘Bool’
07:09:03 <lambdabot>      • In the first argument of ‘(<|>)’, namely ‘True’
07:09:13 <Sornaensis> oh
07:09:15 <Aruro> lyxia: ty
07:10:12 <ski> > Any True <> Any False
07:10:14 <lambdabot>  Any {getAny = True}
07:10:18 <ski> > All True <> All False
07:10:20 <lambdabot>  All {getAll = False}
07:13:35 <piyush-kurur> alanz: any way thanks for your patience. It is not working as of now. I will hack it when things work out.
07:14:43 <Aruro> lyxia: closest is generator function pattern
07:20:57 <tsahyt> @hoogle (a,b,c) -> (a -> b -> c)
07:20:58 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
07:20:58 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
07:20:58 <lambdabot> GHC.OldList zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
07:21:01 <tsahyt> hmpf
07:21:42 <tsahyt> oh that's completely wrong anyhow
07:22:11 <tsahyt> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
07:22:11 <lambdabot> Data.Tuple.HT uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
07:22:11 <lambdabot> Data.Tuple.Lazy uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
07:22:11 <lambdabot> Data.Tuple.Strict uncurry3 :: (a -> b -> c -> d) -> ((a, b, c) -> d)
07:22:16 <tsahyt> that's better
07:41:18 <tsahyt> Is there a way to surpress the warning for a specific orphan instance? I could add a pragma for the whole file, but it'd be nicer to do it on a per instance basis imo
07:44:47 <quchen> tsahyt: I don’t think so, no
07:45:13 <tsahyt> okay, then I'll have to add the pragma
07:45:17 <quchen> I typically put my orphans into an »Orphan« module for this reason
07:45:23 <quchen> At least I can group *only* orphans this way
07:46:13 <tsahyt> actually this instance is completely pointless to begin with
07:46:21 <tsahyt> I'll just do away with it altogether, it's an ugly solution here
07:57:59 <kuribas> why doesn't haskell provide export declarations for instances?
07:58:38 <shapr> kuribas: huh?
07:58:47 <kuribas> like (instance Functor MyType, ...)
07:59:17 <shapr> oh, I don't know.
08:00:20 <geekosaur> kuribas, instances are always exported and must be
08:00:28 <geekosaur> (likewise imported)
08:00:35 <kuribas> must be why?
08:00:46 <glguy> instances are expected to be globally unqiue, they don't have names so there's no namespace pollution to worry about
08:02:14 <geekosaur> iirc the type system is inconsistent if you allow a different version of an instance in different places. (or you'd need to carefully partition data so that you can't use different instances on the same data at different times)
08:03:28 <geekosaur> or, consider: module A has instance Foo Bar, module B has a different instance Foo Bar, module C uses both A and B and needs to use instance Foo --- which one wins? in the presence of polymorphism, it can't reliably pick one
08:04:04 <geekosaur> (again unless you annotate at runtime every data value with whatever instance was used with it)
08:05:41 <geekosaur> possibly not even then as you have to worry about transfection (value A got used with value B that got associated with instance 1, does it need to be associated with instance 1 as well?)
08:09:31 <reactormonk[m]> You can get around having multiple instances by wrapping the type in a newtype - see e.g. Sum/Product for Monoid Int or the ZipList for Applicative List
08:13:08 <mnoonan> here's a terminology question for this maximally-biased audience: locally, people use "applicative style" to mean something akin to "pure functions only" (in a C++ codebase). Would you also make that association, or is "applicative" too overloaded?
08:13:36 <mnoonan> or: what would you say is the opposite of "imperative style"?
08:13:49 <eschnett> “declarative”?
08:14:04 <sm> +1
08:14:04 <merijn> mnoonan: Applicative means something very different in Haskell
08:14:18 <mnoonan> I realize, that's why this is the "maximally biased" place to ask :)
08:14:50 <mnoonan> declarative could work. it makes me think more of prolog, but still not bad
08:14:56 <merijn> I would say declarative is the opposite of imperative, yes
08:15:12 <merijn> Imperative == telling the computer what to *do*
08:15:20 <merijn> declarative == telling the computer the result you want
08:15:28 <Sornaensis> what does declarative mean specifically
08:15:52 <mnoonan> I honestly don't know where the use of "applicative style" came from here. via Tom Reps / UW indirectly, I guess.
08:17:54 <WarmCookie> Sornaensis: It's a programming philosophy in which you declare the desired outcome to the computer, rather than the steps to achieve the outcome. e.g. `SELECT * FROM table`.
08:18:32 <conal> Peter Landin's seminal "The next 700 programming languages" deprecates the fuzzy terms "declarative" and "functional" in favor "denotative", which really gets to the heart of the matter for me. Some more specifics (quotes & links) here: http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-626
08:18:37 <WarmCookie> Sornaensis: The idea being that the system/computer/language has an abstraction of how it should proceed to successfully get the desired outcome.
08:18:39 <chocopuff> that's one of the tradeoffs you get, not as much low level control as something like C would give you
08:19:04 <Sornaensis> what's wrong with functional though
08:19:16 <chocopuff> Sornaensis: it's just a style I suppose
08:19:24 <WarmCookie> Sornaensis: As opposed to what? Dysfunctional?
08:19:32 <merijn> Sornaensis: Well, not all declarative languages are functional
08:19:33 <chocopuff> WarmCookie: made me crack up 
08:19:38 <Sornaensis> yea
08:19:44 <Sornaensis> but functional is well defined
08:19:52 <Sornaensis> like imperative
08:19:55 <merijn> conal: Well, does denotative really replace those terms?
08:20:01 <mnoonan> conal: thanks, 'denotative' actually seems best for the case I had in midn
08:20:04 <mnoonan> midn
08:20:06 <mnoonan> heh
08:20:13 <conal> Sornaensis: "functional" is not well-defined, leading to many pointless arguments.
08:20:14 <Sornaensis> denotative seems like a superset
08:20:42 <Sornaensis> how so
08:20:43 <merijn> conal: Actually, yeah, I suppose prolog could be denotative too
08:20:58 <merijn> Sornaensis: Try talking to anyone about "functional" programming
08:21:14 <merijn> Sornaensis: Does it mean ML like, with types? Is Scheme a functional language? Is JavaScript?
08:21:15 <mnoonan> "functional" feeds that silly "isn't everything a function in functional programming?" conversation
08:21:24 <merijn> Is ocaml functional, despite not being pure?
08:21:30 <mnoonan> but I guess saying everything is a denotation in denotational programming isn't so bad :)
08:21:41 <Sornaensis> if you have first class functions you are a functional language, what's the problem with that
08:21:52 <xenog> Functional is not extremely well-defined, but the union of all definitions would involve functions that can be passed around as arguments to other functions.
08:21:54 <merijn> mnoonan: Well, wouldn't it be everything HAS a denotation, rather than *is* a denotation
08:21:55 <Sornaensis> is there some other definition?
08:22:24 <merijn> Sornaensis: Well, both Haskell and JavaScript have first class functions, yet calling those similar styles of programming seems...odd at best
08:22:31 <Sornaensis> huh how
08:23:01 <xenog> I would be hard-pressed to consider every language that has first-order functions a functional language though.
08:23:17 <merijn> Anyway, I leave that discussion up to others, I'm going home :)
08:23:21 <Sornaensis> k
08:23:22 <xenog> merijn, you can code in a very functional style with JavaScript.
08:23:44 <Sornaensis> the implication of functional is just that functions are data
08:23:49 <Sornaensis> nothing more specific
08:23:51 <Sornaensis> afaikl
08:24:51 <Sornaensis> you can even write the Y combinator directly in javascript, because javascript is typeless
08:25:28 <conal> I guess one could reasonably argue that imperative OO languages have first class functions, just with an awkward notation.
08:25:49 <Sornaensis> some do
08:26:15 <xenog> Functional-mainly languages at their core usually offer first-class functions and tail call elimination.
08:26:36 <Sornaensis> you can for instance write modern C++ in a very functional style 
08:26:38 <conal> Sornaensis: no, i mean typically -- as objects. 
08:27:21 <xenog> Oh, and anonymous functions, I almost forgot that one. If you find a language with tail call elimination, first-class functions, and a syntax for anonymous functions, then you are probably looking at a functional language.
08:27:36 <Sornaensis> xenog: so, C++? :P
08:27:50 <xenog> C++ has no tail call elimination at its core.
08:27:55 <xenog> I think you can do it with trampolines.
08:28:01 <Sornaensis> hmm
08:28:09 <conal> Sornaensis: i'm pointing out that the criterion of "has first class functions" is probably not going to hold water.
08:28:25 <xenog> But if you have to do it with constructs that aren't part of the language core, then it is not a functional language, but a language that has been beaten into shape. :P
08:28:31 <sumeet_> hi everyone,i am new to haskell. any tips to get started. thanks
08:28:42 <Sornaensis> conal: I think that's just arbitrary
08:28:55 <xenog> sumeet_, Learn You a Haskell for Great Good.
08:28:57 <conal> The clearest way I know to start sorting out these language classification issues is to have a precise denotation and then examine its nature.
08:28:58 <Sornaensis> you can't treat functions as data in java
08:29:32 <xenog> Sornaensis, Java is an example of a language that has been beaten into shape, but most definitely not a functional language.
08:29:48 <Sornaensis> you need the ability to have anonymous functions in order to have functions as data
08:30:22 <conal> Sornaensis: why do you think so?
08:30:26 <Sornaensis> many languages do not support var = function(type: argument) { /*/ */ }; and they would therefore not be functional
08:30:27 <xenog> Java has the ability to pass around functions as first-class citizens (objects that have a single method), syntax for anonymous functions (lambdas), but it has no tail call elimination.
08:30:44 <Sornaensis> oh did they finally add lambdas
08:30:50 <sumeet_> thanks xenog
08:32:06 <conal> IIRC, Haskell's predecessor Miranda (non-strict & purely functional) didn't have anonymous functions (and didn't need them).
08:32:30 <xenog> conal, interesting, so then anonymous functions are not strictly necessary to get a functional language.
08:33:00 <xenog> That leaves first-class functions and tail call elimination, but I'm not sure of the last.
08:33:06 <conal> xenog: not in my book. it's the denotation, not the notation.
08:33:41 <conal> I'm surprised to see tail call elimination put forward as a requirement. It's an implementation notion, not a language/semantics notion.
08:33:53 <Sornaensis> how do you get around not having anonymous functions
08:33:55 <xenog> conal, I agree with that.
08:34:06 <xenog> That's why I say that I am not sure about it.
08:34:24 <xenog> Sornaensis, you define a function and you pass it around.
08:34:52 <Sornaensis> how do you define a function
08:35:22 <padre_angolano> conal: does haskell need anynomous functions unlike Miranda? If so, when?
08:35:34 <xenog> `let myFunction x = x + 1 in print (map myFunction [1..3])` is a valid functional statement without having anonymous functions.
08:36:01 <xenog> It's equivalent to `print (map (+1) [1..3])` and no less functional.
08:36:02 <Sornaensis> let is just syntax sugar for anonymous functions though
08:36:13 <conal> padre_angolano: i don't think haskell needs anonymous functions (lambda) any more than Miranda did. convenient, but unnecessary.
08:36:22 <padre_angolano> conal: ah, ok :-)
08:36:26 <Sornaensis> also the googling I did says that Miranda doesn't have lets either
08:36:56 <Sornaensis> I mean haskell is compiled into Core, where everything is transformed into anonymous functions
08:37:00 <xenog> I do think that JavaScript, for example, should be classified as a functional language.
08:37:06 <bartavelle> is there something like haskeline + optparse-applicative ?
08:37:20 <WarmCookie> As far as I know, you can adapt the language so that there's no anonymous functions; with the biggest implications for Applicative probably.
08:37:57 <xenog> Java doesn't feel like it passes though.
08:38:16 <conal> Sornaensis: Haskell is a language, not an implementation. Core is part of one implementation.
08:38:25 <xenog> What's the difference between JavaScript and Java that makes the former a functional language and the latter not one?
08:38:58 <xenog> Perhaps being forced to program using objects makes Java not a functional language?
08:39:27 <bartavelle> xenog, as there is no definition of "funtional language" it is pretty hard to have a definite answer
08:39:31 <frontendloader> you can write either in a functional style
08:39:40 <frontendloader> but neither is explicitly functional
08:39:41 <Sornaensis> if java has higher order functions then it supports functional programming
08:39:57 <glguy> bartavelle: I don't know of such a thing (maybe it exists?) but I've got something like that that I use in my IRC client. you get a structured command definition, syntax highlighting, and place-holders for missing command arguments that works in a readline-like environment. It's not a separate library but might be worth looking at for inspiration
08:40:04 <frontendloader> javascript is usually referred to as "prototypical inheritance"
08:40:06 <conal> bartavelle: exactly. a factory of fruitless arguments.
08:40:08 <frontendloader> and java as OO
08:40:15 <xenog> I'm doing the exercise to try to find a definition of functional language that could work, but I'm having a hard time.
08:40:16 <bartavelle> glguy, where is that ?
08:40:24 * Sornaensis shrugs
08:40:40 <conal> "As tedious as arguing about definitions is, it can't hold a candle to arguing without definitions." - David R MacIver (http://www.drmaciver.com/tag/bad-arguments/)
08:40:48 <glguy> Example definition: https://github.com/glguy/irc-core/blob/v2/src/Client/Commands.hs#L286-L292 and then all these modules for implementation: https://github.com/glguy/irc-core/tree/v2/src/Client/Commands
08:40:50 <bartavelle> conal, nice one
08:41:17 <conal> bartavelle: yeah!
08:41:52 <xenog> conal, yes, it is frustrating not having a proper definition for what a functional language is, one that would leave Java and C++ out while leaving Scala in, for example.
08:42:06 <Sornaensis> oh
08:42:06 <conal> also applicable to arguing without (clear and agreed-upon) definitions: "The single biggest problem with communication is the illusion that it has occurred." - George Bernard Shaw
08:42:08 <Sornaensis> well there you go
08:42:25 <bartavelle> glguy, at first glance, it looks like what I would need. I'll look it up and try to see if it fits, thanks!
08:42:44 <Sornaensis> xenog: does java support returning a function as a value?
08:42:50 <xenog> Going to eat. See you later.
08:42:53 <xenog> Sornaensis, yes.
08:43:03 <Sornaensis> then it supports functional programming
08:43:09 <Sornaensis> what is the issue
08:43:11 <Sornaensis> ..?
08:44:00 <bartavelle> Sornaensis, the issue is that nobody agrees on what "supports functional programming" means :)
08:44:51 <Sornaensis> well some people are trying to modify the definition to exclude certain languages
08:45:25 <bartavelle> there is no definition
08:46:01 <bartavelle> it is like OOP
08:49:47 <Sornaensis> bartavelle: but if a language allows treating functions as values then you can write functional code in it. I'm not understanding the issue. You should be able to encode everything the same way you could write λ-calc. Even if it's really awkward compared to purpose built language
08:50:16 <Sornaensis> even if it doesn't ''work'' because of implementation issues like stack overflows
08:54:07 <bartavelle> Sornaensis, you can encode lambda calculus in any general purpose language, not sure what that proves about that language
08:54:40 <hodapp> Sornaensis: if awkwardness of implementation is completely irrelevant, you can "write functional code" in anything that can perform computations.
08:54:54 <geekosaur> Sornaensis, ^ and I would say an important aspect of support is making it not terribly awkward to write
08:55:09 <bartavelle> also, then you need to define what "functional code" is :)
08:55:29 <hodapp> the only thing that sets apart a pile of beach sand from a Haskell compiler is how awkward it is to implement things in it
08:55:34 <Sornaensis> uhh
08:55:56 <Sornaensis> translating from lambda calc to a language is not what I am suggesting
08:55:58 * geekosaur considers looking for the crab computing article >.> but this starts to feel like a diversion
08:56:00 <Sornaensis> obviously you can do that
08:56:06 <bartavelle> also "treat functions like values" works in most languages, for some definition of "value", even in C
08:56:22 <Sornaensis> I am talking about writing code in the language without any imperative statements
08:56:25 <erisco> I don't think C has functions as values
08:56:36 <Sornaensis> you obviously cannot do that in e.g. assembly
08:56:38 <bartavelle> erisco, you have function pointers, you can create functions on the fly
08:56:43 <Sornaensis> because all you can do is change registers and stuff
08:56:58 <bartavelle> erisco, with a LOT of hacking thouhg
08:57:49 <bartavelle> (for the creating functions part)
08:58:05 <Cale> bartavelle: Function pointers aren't the same thing as first class functions of course. You can construct closures explicitly using them, but it's hard to actually construct the *abstraction* of first class functions in C.
08:58:26 <bartavelle> Cale, of course, I just use that to point out that it is mostly a matter of definition
08:58:57 <Cale> For me, the point where you go from dealing with closures to dealing with functions is when you can no longer separate the code and environment
08:59:09 <marvin2> bartavelle you can construct functions in C on the fly these days? or are you thinking C++
09:00:34 <bartavelle> marvin2, these days it's a bit harder because you have to create a writeable + executable mapping if you want to create functions that are exactly like those you can call
09:01:07 <bartavelle> Cale, not sure I am knowledgeable enough to understand what you mean by "code" and "environment"
09:02:02 <hodapp> <insert needlessly inflammatory Bob Harper article here>
09:02:11 <bartavelle> :)
09:02:35 <Cale> bartavelle: Well, so the standard way of implementing first class functions is to pair up some code (e.g. what a function pointer gives you would be good enough) representing the "body" of your lambda, with a mapping from the variables occurring freely in that body, to the values that those variables had in the context where the lambda was constructed
09:02:47 <glguy> Writing functions into executable memory isn't really part of "C"
09:03:02 <Cale> (and the code will look up the values for those variables in the mapping)
09:03:14 <bartavelle> ah I see
09:03:27 <Cale> e.g. consider something like (\x -> (\y -> x + y))
09:03:30 <robkennedy> How can I check whether `popCount word16 == 1` is faster than `countLeadingZeros w16 + countTrailingZeros w16 = 15` is quicker?
09:03:54 <Cale> after having applied this function to the value 5, we're supposed to get as a result the function (\y -> 5 + y)
09:04:15 <Cale> However, we typically don't want to be compiling separate code for that function at runtime
09:04:53 <Cale> So instead, we'll represent that as a pair, something I might schematically represent like ((\y -> x + y), {x := 5})
09:05:32 <bartavelle> and what you call "environment" would be the second element of that pair ?
09:05:36 <Cale> yeah
09:05:41 <bartavelle> alright
09:05:59 <Sornaensis> :t error
09:06:00 <lambdabot> [Char] -> a
09:06:05 <Cale> With functions in Haskell, or other high level functional programming languages, you can't really tear that pair apart again and inspect or fiddle with the environment, creating the illusion that what you have is really (\y -> 5 + y)
09:06:06 <Sornaensis> @src error
09:06:06 <lambdabot> error s = throw (ErrorCall s)
09:07:12 <bartavelle> Cale, it is interesting that your definition of "first class functions" resides in the absence of a capability!
09:07:21 <Cale> yep
09:07:31 <bartavelle> anyway I gtg :/
09:08:00 <xenog> Perhaps the definition should not only include first-class functions, but closures instead.
09:08:18 <Cale> Nah, closures are an implementation detail
09:08:22 <xenog> But that doesn't change much. Java and C++ still are functional languages under that definition.
09:08:28 <xenog> No, it isn't, it is syntactic.
09:08:33 <Cale> C "has closures", in that you can implement closures with it.
09:08:41 <Cale> But you can't implement functions as I've been describing them
09:08:45 <Sornaensis> idg why it is so important to find a definition that excludes certain languages
09:08:48 <Cale> because you can't formulate that abstraction barrier
09:09:05 <Cale> Sornaensis: The point isn't to exclude certain languages
09:09:07 <xenog> You write a function that closes over lexically-scoped variables defined outside of the function.
09:09:19 <xenog> Or lexically-scoped bindings.
09:09:31 <Cale> xenog: But that's not "having closures" -- I would separate implementation from interface there :)
09:09:34 <doomlord> is haskell any good at driving GPUs,
09:09:56 <Cale> You can also implement first class functions *with the same semantics* in a lot of other ways, some of which don't involve closures.
09:10:06 <erisco> Sornaensis, because on the other end all languages have all features
09:10:19 <erisco> if you can write an interpreter in the language then you can just claim it has all features
09:10:25 <erisco> well, that's absurd
09:10:36 <Sornaensis> that's also obviously not what I'm talking about
09:10:51 <Cale> Closures are specifically the technique of pairing up code for a function, together with an environment that associates free variables in the function body with values. If you can't see the pair any more, it's not really a closure, it's become a function proper :)
09:10:54 <xenog> Yeah, but if you write an interpreter to add the function, then the interpreted language has the function, but not the language in which the interpreter has been written.
09:10:55 <Sornaensis> why bother discerning features at all at that point
09:11:01 <erisco> well, that is why you need definitions that exclude some languages
09:11:03 <Sornaensis> all turing complete languages are equivalent
09:12:03 <Cale> That's why I'm careful to distinguish "closure" from "first class function which captures the values of variables occurring in its body", the latter of which I usually just refer to as "function"
09:12:21 <erisco> I could claim C# has ADTs because I can make a reasonable emulation of them
09:12:40 <_sras_> Does Stack cache urls of the locations specified in "packages" section of the stack.yaml file anywhere?
09:12:48 <erisco> but I wouldn't because it is a type system feature, and C# clearly doesn't have it
09:13:00 <xenog> Well, we need a proper definition of functional language, and that definition may as well be "because most programmers in traditionally-functional languages like Haskell recognize [lang] as a functional language".
09:13:02 <Sornaensis> no, a language either supports functions as values or it does not
09:13:04 <Cale> You can implement the latter via graph reduction instead, and not really involve closures, because the code for your function will consist of a graph which simply has arcs pointing at the right things.
09:13:05 <xenog> It is a bad definition though.
09:13:27 <Sornaensis> the implementation of that shouldn't matter
09:13:45 <romildo> Is there any emacs mode that supports editing alex files? Alex is lexical analyser generator for Haskell.
09:13:58 <Cale> I'm actually not even certain these days that being a functional language is primarily about first class functions -- certainly those are a prerequisite.
09:14:27 <erisco> it is necessary but not sufficient, Cale
09:14:32 <Cale> But pattern matching and algebraic data types are pretty damn important to functional programming, and without them, a language feels very different.
09:14:59 <hodapp> Sornaensis: Turing-completeness isn't actually relevant here either. Total functional languages are not TC.
09:15:01 <xenog> Perhaps we are asking the wrong question.
09:15:32 <erisco> lets begin again: what is computing?
09:15:49 <Sornaensis> hodapp: okay..?
09:15:49 <xenog> Perhaps a functional language is one that supports functional programming well, and functional programming is a paradigm with a constellation of practices.
09:16:06 <Cale> I agree with that sentiment.
09:16:15 <Sornaensis> hm
09:16:32 <Cale> Reasonable people can disagree on whether any given language supports functional programming well.
09:16:51 <xenog> I think what we have then are languages that support functional programming to varying degrees.
09:16:57 <Cale> There are a bunch of idioms and features involved in supporting those idioms
09:18:02 <ystael> also many reasonable people will be surprised by a definition of "functional programming" that doesn't extend to the Lisp family, but dynamically typed functional languages don't typically provide pattern matching in core
09:18:49 <Sornaensis> and LISP is certainly feels different from haskell :P
09:18:54 * ski . o O ( Erlang )
09:19:13 <xenog> So, closures, pattern matching, tail-call recursion, abstractions for linked lists, immutable data, all of these things are used in functional programming.
09:19:24 <cobreadmonster> Man, I've forgotten all my parsec.
09:19:48 <Cale> xenog: I would again be cautious about those first two, because they discuss details of a language implementation, rather than language features.
09:20:28 <Cale> Graph reduction is a common implementation technique which, in some of its forms, throws those two things into question.
09:20:46 <Cale> First of all, by not involving a call stack at all
09:20:51 <geekosaur> you mean two out of the first three; pattern matching is very much a thing :)
09:20:59 <xenog> Cale, would you make your case that closures and pattern matching are an implementation technique as opposed to a syntactic feature of a language?
09:21:00 <geekosaur> (but might mean different things...)
09:21:15 <geekosaur> xenog, Cale mean t tail calls not pattern matching there
09:21:19 <Cale> xenog: I don't use the word "closure" when I want to mean "function"
09:21:31 <Cale> A closure is a special sort of pair
09:21:35 <Cale> A function is not.
09:22:02 <geekosaur> closures and tail calls are implementation details, not fundamentals
09:22:04 <Cale> (a pair of code and environment, which can be separated and manipulated as such)
09:22:19 <Cale> You use closures to implement functions
09:22:20 <xenog> A closure is a function that has access to free variables that are available to its lexical scope, but not necessarily the lexical scope of the caller.
09:22:25 <Cale> But they're not the only way to implement them
09:22:54 <xenog> Perhaps closure can be defined in more than one way.
09:22:55 <Cale> and they're not even the only way to implement functions which have access to free variables in their lexical scope of definition
09:23:47 <Cale> Template instantiation being another
09:24:11 <Cale> and many forms of graph reduction don't involve anything which particularly looks like closures
09:24:14 <xenog> So, when I refer to a closure, I am referring to the syntactic feature of a language that allows creating a first-class function that has access to the lexical scope available at the point of its definition.
09:24:18 <ski> what the Scheme Report calls "proper tail recursion" (a misnomer), is not so much an implementation detail, as a an symptotic constraint on the operational semantics
09:24:32 <xenog> (transparently, I must add)
09:24:37 <Cale> yeah, I'm very picky about that, and that's never what I mean when I use the word "closure"
09:25:25 <Cale> Because the original meaning of the word is the implementation mechanism of pairing code and environment, and I think it's good to keep the word for that purpose alone.
09:25:34 <ski> (er, s/a an symptotic/an asymptotic/)
09:26:43 <xenog> Cale, is there a better/more accepted word than closure to define the language-level feature that I have been referring to as closure?
09:27:53 <benzrf> xenog: i think it tends to be implied - what languages have first-class functions which can be dynamically created but which DON'T have lexical binding?
09:28:04 <ystael> benzrf: emacs lisp
09:28:04 <ski> (namely that the operational semantics can support an unbounded number of active tail calls in bounded space. whether this property is implemented by reusing activation/stack frames, or in some other way (such as heap-allocating (and GCing) the activation frames) is immaterial)
09:28:12 <Cale> Normally, I just say "functions", but if that's not specific enough, I'll say "lambda terms" if that would be understood, or "functions which capture the values of variables in lexical scope"
09:28:13 <benzrf> ystael: ...well damn
09:28:23 <benzrf> ystael: can't i just pretend that all languages are lexically scoped ;u;
09:28:26 * ski . o O ( "first-class functions" )
09:28:43 <Cale> Or indeed, "first class functions"
09:28:49 <benzrf> Cale: i think if you need to get as specific as that final term, "closure" isn't the worst word to use
09:29:09 <ski> (may need qualification about lexical scoping, though)
09:29:19 <Cale> benzrf: That bothers me though, because it dilutes the meaning of that word in a confusing way
09:29:26 <benzrf> that's probably true...
09:29:48 <xenog> Cale, according to the Wikipedia definition, if that is to be considered canonical at all, there is a programming-language-level closure, which is also called a lexical closure, which is what I'm talking about, and there is an operational or implementation-specific definition, which goes with what you say a closure is.
09:30:16 <Cale> xenog: Yeah, I will freely admit there are whole communities of people which define the terms differently
09:30:49 <xenog> So when talking in the context of programming language definitions, the lexical closure definition is more appropriate, because implementation details correspond to another level of abstraction.
09:30:51 <benzrf> Cale: i sympathize with your urge to prescriptivism :>
09:30:56 <Cale> xenog: I'm just especially picky, because I've seen a lot of flamewars and other "discussions" full of people arguing about whether language X "has closures"
09:30:59 <benzrf> i dont know whether it's valid in this case, idk
09:31:15 <benzrf> sorry that was kind of snide
09:31:24 <Cale> heh
09:32:09 <Cale> I'm not ordinarily much of a prescriptivist, but when it comes to technical definitions, I think it can matter.
09:33:01 <xenog> So, "lexical closures" should hopefully exclude the lower-level implementation detail also known as closure.
09:33:11 <benzrf> i should get into a habit of clarifying definitions before wading into these arguments...
09:33:20 <Cale> Note also that it's possible to use closures to implement things which don't behave like functions
09:33:27 <Cale> and in fact, that's pretty common
09:33:42 <xenog> Yeah, I just want to come up with a good definition of functional programming to get my friends into it.
09:34:03 <xenog> - "Dude, you should totally start doing functional programming"
09:34:11 <xenog> - Sure, what is it?
09:34:13 <xenog> - It's cool!
09:34:15 <Cale> Well, it's hard to encircle it properly
09:34:31 <padre_angolano> It's programming with functions. Like function(a) in Pascal!
09:35:04 <Sornaensis> functional programming is defined as programming while being way cooler than other programmers
09:35:29 <Cale> One thing which I think is pretty central to the idea of functional programming, is the construction of libraries which behave like special purpose programming languages unto themselves, which allow you to describe a space of problems out of various building blocks, and then which serve to solve those problems by recursion over the descriptions.
09:35:52 <Cale> That's sort of our ultimate goal with all of these features
09:35:59 <xenog> Functional programming: programming when done by a hipster.
09:36:06 * ski . o O ( EDLSs )
09:36:38 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/ -- here's a good talk about the approach
09:37:30 <Cale> It's not the entire story to functional programming, but embedded domain specific languages, or EDSLs, are one of our major design goals, and when the plan works, it tends to work exceptionally well.
09:37:55 <Cale> You end up with programs which are very flexible to a wide variety of changes in design requirements
09:38:05 <Sornaensis> in the future all programming languages will just be EDSLs within some descendant of haskell
09:38:16 <Cale> and whose correctness is easier to check
09:38:51 <Cale> But actually achieving that goal requires an understanding of your problem space which is not always so simple to come by.
09:38:53 <benzrf> xenog: expression-oriented programming
09:39:14 <ski> record types (with "message-dispatching") tend to be an important aspect of OO. variant types (with pattern-matching) are big in many expressions of FP
09:39:46 <benzrf> xenog: one major aspect of FP is the focus on composing expressions rather than sequencing effects
09:40:15 <ski> another aspect is that FP tend to be expression oriented, and discourage side-effects (partially due to encouraging HOFs, and storing functions in data structures)
09:40:58 * ski fie hives benzrf
09:44:26 <ski> ((even) lists in the lisps can be seen as an implicit expression of pattern-matching, via predicates and selectors. a list is either empty or a "cons")
09:47:02 <Cale> Sometimes I like to imagine an idealised version of the distinction between traditional FP and traditional OO as being an emphasis on inductive data types and coinductive ones.
09:48:20 <Sornaensis> :t bimap
09:48:22 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
09:48:32 <lep-delete> :hoogle clamp
09:49:20 <lep-delete> @hoogle clamp
09:49:21 <lambdabot> Brick.Util clamp :: (Ord a) => a -> a -> a -> a
09:49:21 <lambdabot> Clay.Color clamp :: Ord a => Num a => a -> a
09:49:21 <lambdabot> Numeric.Interval.Kaucher clamp :: Ord a => Interval a -> a -> a
09:50:32 <lep-delete> @hoogle Ord a => Interval a -> a -> a
09:50:33 <lambdabot> Data.Number.Interval ival :: Ord a => a -> a -> Interval a
09:50:33 <lambdabot> Numeric.Interval (...) :: Ord a => a -> a -> Interval a
09:50:33 <lambdabot> Numeric.Interval.Internal (...) :: Ord a => a -> a -> Interval a
09:50:46 <glguy> lep-delete: You can play with lambdabot in private message. Please don't spam the channel 
09:50:59 <lep-delete> not really playing but ok
10:12:21 <nbro> hey guys
10:12:59 <guillaum2> I'm wondering, but with DataKinds and its friend, we can use any type as kind. But why can't we use any function on value as a function on types ?
10:13:00 <nbro> maybe you know something about it… why is this https://pastebin.com/Nxuy3MmF grammar not LL(1) ?
10:14:46 <infandum> If I have Map.unionsWith (Map.unionWith (Data.Sequence.><)) on a [Map a (Map b (Data.Sequence.singleton c))], would the resulting Map (Map (Data.Sequence.fromList [c])) conserve the order? Like, index 3 of [c] from one map be from the same "place" as index 3 of [c] from another map? Assuming all maps had the same as and bs.
10:15:13 <infandum> It's a predictable join, right? Right map added to left, right sequence added to left?
10:15:49 <infandum> I messed up the parenthases a bit but I hope you get the idea
10:15:53 <Ferdirand> nbro: because of the ) ?
10:16:09 <Sornaensis> how does that grammar terminate
10:17:11 <nbro> Sornaensis: true or false
10:17:24 <Sornaensis> but then it expects a B
10:17:27 <nbro> Ferdirand: why?
10:18:05 <nbro> I think something is missing from this grammar
10:18:09 <Sornaensis> true and false should be lower on the rule list
10:18:10 <Cale> nbro: The right hand side of every production contains a B
10:18:10 <nbro> because my original grammar was
10:18:23 <Cale> nbro: So you'll never be finished
10:18:33 <nbro> https://pastebin.com/mVhnh2cQ
10:18:39 <nbro> and I wanted to remove left-recursion
10:19:41 <Sornaensis> I think if you make the last three rules separate
10:20:10 <Sornaensis> make them all B, then replace EXPR with B in the first three, that works
10:21:09 <nbro> Sornaensis: let me see
10:21:12 <Sornaensis> so B refers to EXP in the last rule, but not to itself, and EXP refers to B, and B terminates
10:21:52 <nbro> I see
10:21:57 <nbro> but I’m not sure if that’s enough
10:23:16 <Sornaensis> are you trying to use this grammar for something or just remove left recursion
10:23:21 <nbro> Sornaensis: because Exp && Exp could also be ((Exp || Exp) && Exp), but your idea doesn’t cover it
10:23:38 <Sornaensis> so you need another rule that says EXP ::= B
10:24:04 <nbro> Sornaensis: actually I’m trying to implement a recursive descent parser
10:24:09 <Sornaensis> or move the ! operator down, depends on what you want
10:27:28 <EvanR> so...
10:27:38 <EvanR> conversion of Rationals to Double right
10:27:42 <EvanR> having issues
10:28:33 <EvanR> 117488266195314702899699858804834304 % 166153499473114484104070118945921497 is a close approximation of 1/sqrt2, more than Double can handle. but if you do the conversion with realToFrac, the last digital is not as close as possible
10:28:56 <EvanR> where as doing literally 1 / (sqrt 2) with doubles gets it right
10:29:00 <EvanR> annoying
10:36:44 <erisco> nbro, are you asking how to refactor the grammar such that it is not left-recursive?
10:37:28 <erisco> it is also ambiguous, so you may want to resolve that as well
10:37:40 <nbro> erisco: yeah
10:41:54 <erisco> nbro, so what you do, and it as been a while since I've worked with grammars, is you instantiate the left non-terminal to find all the left terminal productions
10:42:12 <erisco> so what I mean is, for example,  Exp || Exp  instantiates to   true || Exp
10:42:24 <erisco> you do this for all of them
10:43:06 <erisco> and you should end up with something like this http://lpaste.net/354282 where S is your starting non-terminal
10:44:57 <nbro> erisco: before that, my question is, why do you say the grammar is ambigous?
10:45:13 <nbro> I’m not sure it is or not
10:45:14 <erisco> what is the parse tree of  true || true && true  ?
10:45:57 <glguy> the original grammar I saw pasted used prefix operators, not infix
10:46:29 <nbro> but actually my original grammar is the one with infix operators
10:47:07 <erisco> with the grammar I pasted you only get one, but the original you have two
10:49:40 <nbro> erisco: yes, you’re right, that can have more than one parse tree, i.e. either (true || true) && true or true || (true && true)
10:50:26 <erisco> and I have a mistake, let me correct it
10:50:47 <erisco> I made a correction with an annotation so you can compare
10:52:26 <erisco> ! true || true   is ambiguous
10:52:36 <nbro> but your production Exp' ::= ! Exp, doesn’t include !true
10:52:47 <nbro> which can be generated by the original grammar
10:52:52 <erisco> see the correction I just posted
10:54:00 <nbro> erisco: ok, now we do not have left-recursion, but are you sure this isn’t ambigous?
10:54:10 <erisco> I just provided another ambiguity :P
10:55:14 <nbro> if we decide to give precedence to the operators
10:55:21 <nbro> do you think we can remove ambiguity?
10:55:26 <nbro> I mean
10:55:40 <erisco> if you have a grammar which supports precedence, sure
10:56:07 <nbro> suppose then that I establish the following precendence 
10:56:10 <erisco> it can also be solved just by adjusting the BNF grammar you have here
10:56:48 <dmwit> > 1/sqrt 2
10:56:50 <lambdabot>  0.7071067811865475
10:57:13 <nbro> parenthesis (higher precendence), then true and false, then !, then && and finally ||
10:57:17 <dmwit> > showCReal 16 (117488266195314702899699858804834304/166153499473114484104070118945921497)
10:57:19 <lambdabot>  "0.7071067811865475"
10:57:34 <nbro> erisco: what do you mean
10:57:44 <dmwit> > 117488266195314702899699858804834304/166153499473114484104070118945921497 :: Double
10:57:46 <lambdabot>  0.7071067811865476
10:57:50 <dmwit> ouch
10:58:04 <erisco> I refactored the BNF grammar to remove left recursion. you can also refactor it to remove ambiguity
10:58:41 <byorgey> dmwit: where on earth did that fraction come from
10:59:53 <EvanR> it came out of my exact real number code
11:00:05 <EvanR> its 1/sqrt2 at approximation level 1/zillion
11:00:09 <byorgey> oh, I see the scrollback now
11:00:21 <lush> Hey! I'm currently trying to do some simple "computation topology" stuff as an university internship (Mathematics student here) in haskell. What do you think is the best way to implement a category as follows in haskell: http://lpaste.net/354285
11:00:24 <EvanR> clearly i need to not rely on doubles to display the results
11:00:38 <lush> I know there is no real notion of a topological space but I don't really need that
11:00:50 <lush> however... is there a way to "enforce" h. g = f ?
11:01:01 <EvanR> theres are plenty of ways to do topology on the computer
11:01:13 <jle`> > realTofrac $ 1/sqrt 2 :: Rational
11:01:14 <lambdabot>  error:
11:01:15 <lambdabot>      • Variable not in scope: realTofrac :: Double -> Rational
11:01:15 <lambdabot>      • Perhaps you meant ‘realToFrac’ (imported from Prelude)
11:01:19 <jle`> > realToFrac $ 1/sqrt 2 :: Rational
11:01:21 <lambdabot>  1592262918131443 % 2251799813685248
11:01:22 <EvanR> topology is really about regions, so you can have a working algebra of regions
11:02:03 <EvanR> > realToFrac (1592262918131443 % 2251799813685248)
11:02:05 <lambdabot>  0.7071067811865475
11:02:21 <EvanR> so roundtrips correctly
11:02:42 <lush> EvanR: yeah I know but I don't think I'll need sth of that right away
11:03:19 <lush> EvanR: I'm just interested whether it is possible to somehow implement sth similar to the category described in the link and whether it'd still be useful ^^
11:04:52 <EvanR> so a category of topological fields?
11:06:03 <EvanR> you could certainly build all this up in agda
11:06:59 <lush> EvanR: yeah I found a paper that interpreted contour trees in a category theoretic way and I was interested in that
11:07:55 <lush> do you think it is possible in haskell as well EvanR?
11:08:17 <lush> In the end I need it to work very performant as we will test how functional compares to imperative
11:10:44 <erisco> tortoise and the hare
11:12:29 <erisco> so I decided I just need the zig-zaggy enumeration of Cartesian product
11:12:52 <erisco> then if I order each factor I also get the enumeration in the correct order
11:13:10 <erisco> implemented that years ago but going to try again
11:13:34 <EvanR> lush: haskell is more about programming than math, agda is geared towards formalizing math
11:13:56 <EvanR> what sort of programming problems would a field interface like that be good for
11:14:57 <EvanR> assuming theres a decent way to express it in haskell
11:16:30 <lush> mhm I need some kind of "scalar field" anyway in my project
11:16:45 <nbro> erisco: you’re grammar is still wrong
11:16:59 <nbro> because you can’t generate true || true && true
11:17:01 <nbro> for example
11:17:10 <nbro> I think
11:17:16 <erisco> try again ;)
11:17:36 <lush> EvanR: so if it possible to let haskell know this forms a category that'd be cool
11:18:38 <lush> EvanR: is there a way to enforce laws like g.h = f?
11:18:58 <nbro> erisco: tell me how then
11:19:03 <cocreature> lush: no, for that kind of stuff you want a theorem prover like agda or coq
11:19:39 <nbro> you need to start either with Exp’ || Exp or Exp’ && Exp
11:19:57 <lush> cocreature: mhm ok
11:20:03 <lush> I see^^
11:20:10 <dmwit> lush: Laws are generally advertised but not enforced in Haskell.
11:20:17 <erisco> oh I also have another mistake, heh
11:20:24 <dmwit> (And associated with type classes, specifically.)
11:20:24 <cocreature> lush: tbf you can’t really express that in any somewhat programming mainstream language :)
11:20:47 <cocreature> eh s/programming mainstream/mainstream programming/
11:20:49 <erisco> nbro, you probably got stuck at the last "true"
11:20:51 <nbro> erisco: you probably meant Exp’ || S or Exp’ && S, at this point
11:21:12 <erisco> yes I added another annotation
11:21:22 <erisco> I changed it in Exp' on the first fix and forgot to do it in Exp
11:21:26 <lush> cocreature: ok then, ty though ^^
11:22:07 <cocreature> lush: if you are interested in that, definitely play around with something like coq or isabelle :)
11:22:18 <nbro> erisco: anyway, this example is a very similar example to the unambigous grammar with * + where * has higher precendence
11:22:19 <Sornaensis> nbro: are you using a parser generator
11:23:00 <erisco> well we didn't really do that here because || and && effectively have the same precedence
11:23:03 <nbro> but I’m not sure how to convert it to an unambigouous grammar yet
11:23:15 <Sornaensis> I ask because happy can use left recursive grammars
11:23:21 <lush> cocreature: I will but I have to finish that project first :-D
11:23:48 <erisco> I'd change ! S to instead be three rules
11:23:59 <erisco> ! true, ! false, and ! ( S )
11:24:37 <erisco> that's saying ! has high precedence
11:25:02 <nbro> why?
11:25:30 <nbro> never mind
11:25:30 <erisco> because in  ! true || true   we're saying it binds to true, not true || true
11:25:39 <nbro> you also added the parenthesis
11:25:43 <erisco> so it has higher precedence than ||
11:28:24 <nbro> erisco: but why do you need !true and !false too?
11:28:40 <erisco> you don't
11:29:00 <erisco> that removes  ! true || true  as a sentence though
11:29:02 <Sornaensis> you can separate precedence levels into rules
11:29:15 <Sornaensis> where true | false | ( S ) are at the bottom
11:29:28 <erisco> yes you can, of course, that is an easy refactor
11:30:36 <erisco> remember that conjunction distributes over disjunction
11:31:21 <jayjam124> anyone here good with threads in Haskell?
11:31:30 <srhb> jayjam124: Plenty of people, ask. :)
11:31:35 <glguy> jayjam124: always just ask your actual question
11:32:08 <jayjam124> ok
11:32:37 <jayjam124> I presume there is, I gotta go for a bit but I will be back, thanks
11:32:40 <erisco> what if we replied and said "no, go away" :P
11:32:46 <jayjam124> then I would be disappointed hahaha
11:33:28 <srhb> Some day I will learn that (<>) is not in Prelude.
11:33:55 <cocreature> srhb: someday (<>) will be in Prelude
11:34:10 <srhb> cocreature: I think that's probably the same day, given past experience.
11:34:22 <EvanR> <> still isnt in the prelude?
11:34:31 <srhb> EvanR: How can you not notice ._.
11:34:32 <Sornaensis> you should probably be using a better prelude anyway
11:34:40 * EvanR goes back to rip van winkle land
11:34:43 <cocreature> huh, for some reason I thought it made it in 8.2 but ghci says I’m wrong
11:35:21 <srhb> cocreature: 8.2 is out?
11:35:42 <cocreature> srhb: preliminary tarballs for rc1 have been released today
11:35:45 <EvanR> out of the options, "prelude sucks deal with it", "you can use alternative preludes", and "prelude doesnt suck" ...
11:35:51 <EvanR> :(
11:36:05 <EvanR> or a combination of the last two
11:36:17 <srhb> I deal. I just tend to notice that I have to type import Data.Monoid ... post-hoc quite a lot of times for small one offs :P
11:36:40 <EvanR> i have at least 5 import lines for small one offs
11:37:19 <srhb> I mean, I _know_ most of the imports I want beforehand, and write them, but then I compile and I've used <> without getting Data.Monoid :P
11:37:37 <EvanR> -X<>IsInPrelude
11:37:43 <srhb> Hah
11:37:43 <cocreature> also everytime I switch code from String to Text I need to import Data.Monoid
11:38:03 <srhb> cocreature: That's actually one of my motivators for using <> to start with. Though i suppose that's probably premature.
11:38:18 <EvanR> shoulda called <> ++ to start with
11:38:26 <EvanR> or vice versa
11:38:36 <cocreature> srhb: nah I use <> in new code as well. but I still have to work with old code occasionally :)
11:38:41 <srhb> Right. :)
11:40:11 <cocreature> btw one thing that annoys me about OverloadedStrings is that it results in potential ambiguity. have there been any discussions about something like {-# LANGUAGE OverloadString Text #-} which always defaults to Text instead of resolving via IsString?
11:40:38 <erisco> parameterised extensions, oh boy
11:40:59 <erisco> ten years from now there is an entire macro system for them
11:41:19 <Sornaensis> lmfao
11:41:29 <Sornaensis> (pls no)
11:43:12 <cocreature> great even my Setup.hs fails to build with several errors when I try compile with 8.2
11:43:23 <cocreature> but those new error messages are really nice!
11:47:14 <erisco> I think I can achieve the n-ary zig zag in a slightly strange way
11:47:22 <erisco> with a stream of diagonals and non-diagonals
11:55:17 <jayjam124> i <- randomRIO (0,9)
11:55:17 <jayjam124> let c = "0123456789" !! i
11:55:42 <jayjam124> how do I put this into a thread?
11:55:47 <jayjam124> randomly generating Integers
11:58:40 <lyxia> what are you going to do with c
11:59:06 <lyxia> why do you want to put this into a thread
11:59:11 <lyxia> what does it even mean
11:59:13 <jayjam124> it's to do with my homework it is
11:59:18 <jayjam124> it generates random digits
11:59:38 <jayjam124> it generates a new random digit
11:59:51 <jayjam124> one new random digit sorry
12:00:12 <jayjam124> so basically the game is when you have a thread that generates random digits, and the user has to guess whether a digit is in that random list
12:00:52 <jayjam124> if the user guesses a random digit in the list it's removed. the user has 10 guesses, so once 10 guesses are done that's it game is over and the number of guesses are returned
12:01:00 <jayjam124> and how many were removed
12:01:05 <jayjam124> that's the big picture of what I have to do if interested
12:01:41 <lyxia> I can't see how threads are involved in this game
12:01:46 <jayjam124> ok so
12:01:51 <jayjam124> one thread is responsible for generating the digits
12:01:57 <jayjam124> one thread is responsible for getting the key presses
12:02:05 <jayjam124> and another is responsible for the logic
12:02:28 <jayjam124> you could do it without threads but I have to do it with threads
12:02:40 <dmwit> :t forkIO
12:02:41 <lambdabot> error: Variable not in scope: forkIO
12:02:46 <dmwit> ?hoogle forkIO
12:02:46 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
12:02:46 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
12:02:47 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
12:03:07 <dmwit> ?hoogle MVar -- for very simple communication between threads; there are many other fun tools available
12:03:07 <lambdabot> Control.Concurrent.MVar.Lifted newEmptyMVar :: MonadBase IO m => m (MVar a)
12:03:07 <lambdabot> Math.FFT.Base lock :: MVar ()
12:03:07 <lambdabot> Transient.Internals printBlock :: MVar ()
12:04:20 <jayjam124> so uh, what do I do?
12:04:33 <jayjam124> I can see that these are related to concurrency but what do I actually do with this?
12:05:25 <srhb> jayjam124: Have you ever used forkIO before?
12:05:28 <jayjam124> no 
12:05:36 <jayjam124> first time with this assignment
12:05:36 <dmwit> Write an IO action that does all the random number generation and communicates its results via `MVar`. Then use `forkIO` to spawn a thread with that action.
12:06:24 <int-e> seriously, hoogle finds lifted-base before base? meh...
12:07:01 <jayjam124> dmwit the IO acction is this right?
12:07:02 <jayjam124> i <- randomRIO (0,9)
12:07:02 <jayjam124> let c = "0123456789" !! i
12:07:23 <srhb> jayjam124: I think you might benefit from doing some simple experiments with it first then. For instance, try just _printing_ a single number from it first (dealing with the handoff via eg. MVars later) while the main function is waiting on user input or something like that.
12:07:44 <srhb> jayjam124: ie. hello world but in a forked thread.
12:08:03 <jayjam124> any example code?
12:08:18 <srhb> jayjam124: forkIO, getLine and putStrLn is all you need really.
12:08:47 <jayjam124> this homework is going to be a nightmare xD
12:08:58 <srhb> jayjam124: Well, you just need some basic building blocks to work with first. :)
12:09:16 <jayjam124> do you think I can do it in 2 days?
12:09:22 <jayjam124> I only finished my other piece of work yesterday
12:09:26 <jayjam124> so it's been non-stop 
12:09:30 <jayjam124> and I panic
12:09:46 <srhb> jayjam124: No idea. :) THe less time you spend worrying the more time you have to learn and solve it, though.
12:10:17 <WarmCookie> https://www.youtube.com/watch?v=7kI1d7DMbco
12:10:26 <WarmCookie> Interesting. Lightning is implemented as a A* algorithm.
12:10:49 <jayjam124> srhb aight so how do I use forkio?
12:11:01 <srhb> jayjam124: Well, look at its type again
12:11:03 <srhb> :t forkIO
12:11:04 <lambdabot> error: Variable not in scope: forkIO
12:11:07 <srhb> Ack.
12:11:26 <srhb> jayjam124: forkIO :: IO () -> IO ThreadId
12:11:39 <srhb> jayjam124: We can ignore the ThreadID for now and think of it as IO () -> IO ()
12:11:49 <srhb> jayjam124: Meaning it takes an IO action and produces an IO action.
12:11:54 <nbro> erisco: but if you wanted to give higher precedence to && with respect to ||, how would you change that grammar?
12:12:02 <srhb> jayjam124: More specifically, it takes an IO action and executes it in a thread.
12:12:18 <erisco> nbro, similarly to how we did it with !
12:12:46 <srhb> jayjam124: So given any IO action foo, forkIO foo executes it in a separate (lightweight) thread.
12:14:39 <jayjam124> I don't even remember how to actually write in Haskell it's been months lol
12:14:47 <jayjam124> main = putStrLn "Hello World"
12:14:51 <jayjam124> first program
12:14:53 <srhb> jayjam124: That's a good start!
12:15:06 <jayjam124> yes :D
12:15:08 <Aruro> jayjam124: u have haskell class in school?
12:15:15 <jayjam124> yah but I already did it and forgot it
12:15:17 <jayjam124> terrible memory, terrible
12:15:19 <srhb> Now, rename that to otherThread and make a new main that forks off otherThread
12:15:43 <srhb> jayjam124: (Then experiment with it and see what you observce)
12:15:44 <sophiag> would anyone mind helping me with this snippet: http://lpaste.net/354292? i'm trying to use Either to dispatch to either an error message or two state monads (and a third function "eval," which i could make a state monad for uniformity but doesn't require it)
12:15:47 <Aruro> jayjam124: not terrible memory, too much information.
12:16:07 <jayjam124> you mean teachers give you too much and it just overloads your brain?
12:16:10 <jayjam124> yeah I can agree with that
12:16:18 <Aruro> yes. they are no smart.
12:16:21 <Aruro> t*
12:16:24 <jayjam124> mmm I do agree
12:16:59 <erisco> nbro, a typical setup is like this, where Exp1 is the starting non-terminal http://lpaste.net/354293
12:17:11 <mizu_no_oto_work> jayjam124: did the professor specify that you should use Haskell for this assignment?
12:17:43 <jayjam124> yes
12:17:49 <jayjam124> got to use it
12:17:51 <erisco> nbro, as you go down the precedence becomes higher
12:18:30 <jayjam124> srhb what's the next thing I do?
12:18:32 <jayjam124> forkIO
12:18:34 <jayjam124> ?
12:18:47 <int-e> sophiag: how are the State monad actions supposed to become strings?
12:18:52 <erisco> nbro, sorry I had to make an edit to line 7 it should have been Exp3 ::= ! Exp3
12:18:55 <srhb> jayjam124: What's the type of otherThread now?
12:19:12 <int-e> sophiag: err, unit actually
12:19:24 <jayjam124> main = 
12:19:24 <jayjam124> otherThread = putStrLn "Hello World"
12:19:41 <srhb> jayjam124: Put it differently, what's the type of putStrLn "Hello World" ?
12:19:47 <jayjam124> it's a String
12:19:51 <srhb> No, it's not.
12:19:53 <jayjam124> oh
12:19:56 <jayjam124> ummmmm
12:19:59 <srhb> jayjam124: Try defining it in ghci and asking it
12:20:05 <jayjam124> so :t otherThread?
12:20:06 <srhb> Or we can do...
12:20:08 <srhb> Yes
12:20:10 <jayjam124> ok
12:20:21 <jayjam124> sorry I can't remember a lot of this
12:20:23 <jayjam124> my apologies
12:20:25 <srhb> You need to have no errors in the file first though :)
12:20:31 <jayjam124> yes I removed main
12:20:38 <srhb> jayjam124: No time for apologies and small-talk, hand-in is in two days! Chop chop! ;-)
12:20:46 <jayjam124> indeed
12:21:01 <jayjam124> the type is
12:21:04 <jayjam124> otherThread :: IO()
12:21:11 <jayjam124> so IO
12:21:15 <srhb> IO ()
12:21:18 <jayjam124> IO()
12:21:20 <nbro> erisco: what’s the difference between this grammar and your previous, except that apparently now && has higher precedence than ||?
12:21:23 <jayjam124> ok
12:21:33 <srhb> So that looks suspiciously like the type of forkIO's argument, doesn't it.
12:21:46 <erisco> nbro, that is what you asked for
12:22:10 <sophiag> int-e: they return unit. is that not sufficient? i have alternate versions where they actually return the current state (which i would prefer), but not sure how to write the type signature for evalString
12:22:25 <erisco> nbro, it also includes the ambiguity fix for !
12:22:40 <jayjam124> main = 
12:22:40 <jayjam124> otherThread = putStrLn "Hello World"
12:22:48 <jayjam124> so what do I do to do a forkIO on otherThread?
12:22:59 <erisco> nbro, and the omission of double negation sentences i.e. ! ! x
12:23:35 <srhb> jayjam124: It's argument is exactly something of type IO (), so you just apply forkIO to otherThread like any other function application. Ie. like you used putStrLn on its (String) argument.
12:23:48 <srhb> Its*
12:24:13 <jayjam124> main = forkIO otherThread
12:24:14 <jayjam124> otherThread = putStrLn "Hello World"
12:24:15 <jayjam124> like that?
12:24:18 <srhb> jayjam124: Yes, exactly.
12:24:21 <jayjam124> ok
12:24:36 <jayjam124> ouch
12:24:37 <jayjam124> not in scope
12:24:39 <jayjam124> import module I guess
12:24:45 <srhb> jayjam124: Look up where forkIO is from. :)
12:24:52 <jayjam124> :t forkIO
12:24:54 <lambdabot> error: Variable not in scope: forkIO
12:24:58 <jayjam124> how do I look up?
12:25:01 <Aruro> import Control.Concurrent
12:25:05 <srhb> I tend to google things...
12:25:05 <jayjam124> thanks
12:25:13 * geekosaur uses hayoo
12:25:15 <int-e> sophiag: You may be misunderstanding what "State" does; it doesn't have any global variable or the like; State s a is essentially the same as the function  s -> (a, s) which maps a state to a successor state and a value. The Monad instance allows one to thread that state through several actions in the same state monad. "runState" and friends can be used to specify an initial state and get the...
12:25:21 <int-e> ...corresponding final state and return value. But any value of type "State s a" is still just that, a value; it doesn't have any effect.
12:25:25 <jayjam124> lol I got back
12:25:33 <jayjam124> HeTlhlroe aWdoIrdl d2
12:25:33 <jayjam124> 7
12:25:36 <jayjam124> random like that
12:25:46 <jayjam124> when I call main
12:26:01 <jayjam124> is that supposed to happen or?
12:26:16 <mizu_no_oto_work> jayjam124: looks like you have two threads that are both calling putStrLn
12:26:24 <jayjam124> hmmmmmm
12:26:26 <jayjam124> import Control.Concurrent
12:26:26 <jayjam124> main = forkIO otherThread
12:26:26 <jayjam124> otherThread = putStrLn "Hello World"
12:26:27 <srhb> jayjam124: ghci is interfering with the order, try compiling it and you'll see some different weirdness
12:26:28 <jayjam124> all I got it this
12:26:40 <srhb> jayjam124: Which is what I wanted you to see.
12:26:40 <jayjam124> ok
12:26:57 <jayjam124> so you want me to go into GHCI
12:27:01 <jayjam124> and compile it in there?
12:27:12 <jayjam124> the way I do it is I double click on the .hs file to compile normally
12:27:19 <srhb> jayjam124: actually your can probably runhaskell file.hs
12:27:27 <srhb> jayjam124: or ghc file.hs && ./file
12:27:38 <jayjam124> is it ok if I just double click the .hs file?
12:27:50 <jayjam124> I guess it is
12:27:50 <srhb> jayjam124: Nope. No idea what that does. Something unpredictable.
12:27:56 <jayjam124> oh
12:28:33 <jayjam124> uh wait, so what do I type into GHCI to compile the .hs file?
12:28:34 <srhb> (Or rather, I have no idea what it does on your system, so i don't care to guess about it.)
12:28:41 <srhb> jayjam124: Not into ghci, into your terminal.
12:29:05 <jayjam124> oh so windows cmd
12:29:13 <srhb> Oh oops, Windows is a thing. Yeaaah...
12:29:19 <jayjam124> ok
12:29:22 <Aruro> jayjam124: is there no seminars where u can practice with tutor?
12:29:24 <srhb> No idea how that works. Maybe it's just on PATH :-)
12:29:25 <Aruro> online course?
12:29:41 <jayjam124> ok
12:29:42 <jayjam124> so
12:29:51 <jayjam124> Aruro nah man
12:29:54 <jayjam124> my University SUCKS
12:29:58 <jayjam124> they leave you on your own
12:30:01 <Aruro> :)
12:30:18 <jayjam124> don't want to vent too much but the attitude they give is
12:30:21 <sophiag> int-e: i do understand that. i'm using the state monads to take values and cons them onto lists. that's not currently working because of the type signature. i'm asking how to correct it
12:30:27 <jayjam124> teaching is the second part of their job which they don't want to do
12:30:31 <jayjam124> they'd rather work on their research and shit
12:30:49 <jayjam124> srhb
12:30:50 <jayjam124> Hello World
12:30:50 <jayjam124> ThreadId 24
12:30:53 <jayjam124> so this is what returns
12:31:10 <srhb> jayjam124: That looks like ghci output. Otherwise I've no idea where ThreadId 24 is from
12:31:20 <jayjam124> I typed runhaskell helloworldthread.hs
12:31:27 <jayjam124> into Windows CMD
12:31:28 <srhb> Oh, really?
12:31:30 <jayjam124> yes
12:31:44 <jayjam124> I can show a pic but trust me yes that is what returned
12:31:46 <srhb> jayjam124: Can you try ghc yourfile.hs and then execute the resulting file?
12:31:53 <jayjam124> in windows cmd?
12:31:55 <srhb> jayjam124: Yes.
12:31:56 <jayjam124> I can try that sure
12:32:12 <jayjam124> ah ok seems to be doing something more now
12:32:18 <erisco> nbro, how do BNF grammars relate to Haskell for you?
12:32:24 <jayjam124> "Linking helloworldthread.exe"
12:32:27 <srhb> jayjam124: It should be compiling an executable first
12:32:30 <jayjam124> yes
12:32:33 <srhb> jayjam124: Yes, run that exe file in cmd
12:32:38 <jayjam124> ok
12:32:46 <jayjam124> what's linking again out of curiosity?
12:32:46 <cocreature> hey, GHC 8.2 apparently has a new warning simplifiable-class-constraints. however, I’m having trouble understanding what GHC is telling me to simplify http://lpaste.net/354295
12:32:48 <int-e> sophiag: I'm not sure what you should do; a workable type could be  evalString :: String -> Either String (State ([Amb],[Require a]) (Either [Amb] ()))  but this doesn't look very nice. (Also, in order to use State [Amb] ([Amb]) inside the latter monad, you'll end up with something like  get >>= \(s1,s2) -> let (x, s1') = execState (amb ast) in put (s1',s2) >> return x ... eww.
12:32:48 <cocreature> any ideas?
12:33:14 <jayjam124> ok I ran "helloworldthread.exe" and it returns simply Hello World and nothing else
12:33:15 <srhb> jayjam124: Combining your executable with other libraries, system libraries etc.
12:33:22 <jayjam124> makes sense
12:33:26 <srhb> jayjam124: That's a start, that's the base behaviour with all the flavour of ghci etc.
12:33:34 <jayjam124> ok, what next?
12:33:57 <int-e> (is there any light-weight package (not lens) that abstracts from this, running a state monad on a projection of a state?)
12:34:31 <jle`> microlens has this
12:35:32 <srhb> jayjam124: Pick some minor part of the objective and try to integrate that into your program. Like, having the thread do something repeatedly, or waiting for user input, or...
12:35:41 <jle`> zoom :: Lens' s t -> State t a -> State s a
12:35:52 <jayjam124> the simplest thing to do is
12:36:09 <jayjam124> is to make a thread that repeatedly generates Integers
12:36:15 <jayjam124> that's defo the first simplest thing to do in the task
12:36:31 <jayjam124> agree or disagree?
12:36:32 <srhb> jayjam124: OK, maybe start by generating the one random integer then and simply outputting that :)
12:36:33 <jayjam124> :)
12:36:39 <jayjam124> ok sure
12:37:34 <joe9> I want to generate C code. It appears that the Language.c is the best way forward. Any suggestions for samples using that library, please?
12:41:29 <int-e> jle`: thanks
12:50:39 <sophiag> int-e: (sorry for the delayed responses, I'm dealing with several things at once that are making it difficult to focus). i agree about the ugly code. this is why i was thinking it would be easier if i used the versions of the state monads that return unit. but you're saying that doesn't affect the type signature of evalString?
12:51:14 <nbro> erisco: apparently this is an equivalent grammar, but unambiguous: https://pastebin.com/abmgN1HG
12:51:18 <nbro> what do you think?
12:51:34 <nbro> wait
12:51:54 <nbro> this one: https://pastebin.com/hS6Mrwex
12:57:54 <erisco> nbro, I don't know. The one I posted isn't ambiguous either
13:05:17 <nbro> erisco: are you sure about yours?
13:05:25 <erisco> nbro, yes
13:06:44 <erisco> the grammar you last posted has a different language because the negation productions are different
13:06:52 <erisco> it does not have ! true for example
13:07:23 <erisco> what the designer of this grammar has clearly done is ensure that it can be recognised by a lookahead-1 parser
13:07:54 <erisco> the problem is that in the way this one done it is not going to make for a good executable grammar
13:08:43 <erisco> the way you'd have to construct the AST is awkward
13:14:00 <erisco> well, thinking it through more it would be easy
13:14:56 <erisco> but generally speaking, with more complicated grammars, I am not sure how easy it would be
13:15:14 <erisco> that is a reason to have parser generators
13:15:33 <erisco> so you can write a more obvious grammar without worrying about parsing implementations
13:16:18 <Sornaensis> there are parser generators that accept left recursive grammars
13:16:51 <erisco> it can either factor it out or use a parsing implementation that accepts it
13:17:12 <ggVGc> My favourite parsing tool so far has been LPeg actually
13:17:19 <ggVGc> but PEG seems not very popular in general
13:17:40 <ggVGc> and I haven't seen an implementation for anything else that's even close to as nice as LPeg (which is lua)
13:46:39 <Younder> ANS.1 that protocol defining language. 
13:47:17 <merijn> ASN.1, but close enough ;)
13:48:22 <johnw> 1N.SA?
13:48:27 <johnw> not close enough?
13:49:23 <Younder> And yes everything comig out of ITU ilike LDAP is heavy and awkward. But what do you expect fom a comity in some dusty office in the bottom of the UN building. (Yes telecom standards are under the UN ..)
13:50:00 <merijn> honestly, if you give me the choice between "everything is ASN.1 defined" or "everything is JSON (like now)", I'd kill for the ASN.1 option...
13:52:12 <bennofs> i'm still looking for a json-like (self-describing) format with optional schema support...
13:52:23 <bennofs> where there is a compiler to generate data types out of the schema
13:53:18 <bennofs> like a mix of protobuf and json
13:53:59 <merijn> bennofs: Why JSON-like?
13:54:13 <merijn> JSON can't even do integers
13:54:13 <bennofs> well it should be self describing and ascii so it can be inspected easily
13:54:18 <bennofs> rest idc
13:55:31 <bennofs> and preferably self-delimiting so you can easily send multiple messages on a stream
13:56:56 <joe9> would swagger help?
13:57:43 <erisco> and it can be concatenated, and there is an empty document
13:57:59 <bennofs> swagger is in the right direction, but I don't really need to spec a whole API, just a data format
14:00:08 <Younder> Doesn't anyone do EBNF and recursive decent anymore?
14:01:42 <EvanR> gross
14:03:11 <glguy> There's a decent amount of recursive descent still.
14:03:55 <nbro> erisco: you’re grammar actually has problems… 
14:04:02 <nbro> it doesn’t seem to generate true or true
14:04:13 <nbro> i.e. conditionals with true without parentheses
14:04:27 <nbro> i.e. where we have an OR
14:05:44 <erisco> the parse tree is  1 (5 (8 10)) (2 (5 (8 10)))
14:10:26 <argent0> hi, to reinstall some project's dependencies 'from scratch' is it enough to remove the .cabal-sandox?
14:10:45 <erisco> it is very similar to the other grammar
14:10:57 <erisco> I just haven't factored out the common prefix in Exp1 and Exp2
14:11:15 <nbro> I can derive it manually
14:11:19 <nbro> but there’s some problem
14:11:20 <nbro> ...
14:11:43 <erisco> well the grammar does not have that problem then :P
14:13:30 <erisco> nbro, are you saying it doesn't work with a parser? there is a difference between parsing implementations
14:13:43 <erisco> they don't all recognise the whole of CFG
14:14:20 <erisco> instead they recognise different subsets of it for their own performance reasons
14:15:02 <erisco> if you're using a lookahead-1 parser then the grammar I gave is incompatible because Exp1 and Exp2 have multiple productions with the same prefix
14:15:24 <erisco> a parser generator may be smart enough to refactor this automatically
14:15:37 <erisco> but the other solution is to refactor it by hand, which is easy to do
14:18:39 <Inneedofhelp> Jion
14:19:07 <Inneedofhelp> Anyone here? 
14:20:50 <lambdabot> Hello.
14:21:02 <Inneedofhelp> Hello
14:21:28 <erisco> nbro, are you focused on analysing grammars or parsing or what is your task here?
14:21:39 <nbro> erisco: I would like to parse that grammar
14:21:49 <erisco> the one I gave?
14:21:49 <nbro> using recursive descent
14:22:04 <nbro> my original grammar
14:22:15 <nbro> but I would like to convert it first to LL(1)
14:22:23 <erisco> your original grammar is ambiguous and left recursive
14:22:32 <nbro> erisco: I know
14:22:38 <Inneedofhelp> Can anyone help? 
14:22:43 <nbro> that’s why I was trying to remove left recursion
14:22:58 <erisco> we did that
14:22:58 <nbro> and then ambiguity
14:23:03 <erisco> also did that
14:23:29 <Inneedofhelp> Anyone reading this? 
14:23:46 <erisco> Inneedofhelp, ask your question
14:23:46 <glguy> Inneedofhelp: If you have a question about Haskell, you can ask that.
14:23:48 <nbro> I created a simple parser, but the problem is that it seems to give always precedence to ands and never to ORs
14:24:13 <nbro> in other words, things like this "true or true" are not recognized
14:24:20 <erisco> well I think the intent is to give && higher precedence than ||
14:24:45 <erisco> not recognising "true or true" is not a problem with precedence
14:24:56 <nbro> erisco: the intent was to give higher precedence to && than to ||
14:25:33 <erisco> a problem with precedence would be getting the wrong tree for  true || true && true  for example
14:26:18 <erisco> you should pastebin your parser so we can take a look
14:26:33 <Inneedofhelp> I have heard that this group is really helpful in general. I have a list of pages on facebook that spread hate speech. I would need help with reporting them. 
14:26:54 <glguy> Inneedofhelp: Nope, the topic here is Haskell programming.
14:27:03 <dmwit> Inneedofhelp: This isn't the right place, sorry.
14:27:17 <nbro> erisco: let me try to have a look at it
14:27:26 <nbro> one more time
14:27:31 <Inneedofhelp> Ops where should I be going? Sorry guys. 
14:27:44 <glguy> Inneedofhelp: That's up to you, but this isn't the place to ask
14:28:05 <Inneedofhelp> Okay, thanks 
14:28:09 <dmwit> Inneedofhelp: Sorry, this also isn't the right place to ask where the right place is. =P
14:28:33 <Inneedofhelp> Hah, thanks anyway. 
14:28:33 <nbro> I should be reading about parsing, but I have no time
14:28:42 <nbro> that’s why I’m in this shit situation
14:28:50 <nbro> I’m missing the prerequisites
14:29:24 <erisco> parsing is made unnecessarily complicated by the myriad of methods
14:29:57 <erisco> in university they want to go over all these things like LL and SLR and LR and (1) and (k) and (*) and recursive descent and all the things
14:30:51 <erisco> which is fine once you first have a grasp of what parsing is even about, in my view, but before then it is putting the cart before the horse
14:31:02 <srk> it's good to know the difference
14:31:31 <srk> but I agree it's complicated for start
14:31:43 <srk> indeed
14:33:31 <nbro> I don’t think it’s complicated, it’s just that I need to have time to read chapter on a book and put all the info I’ve been gathering on the web together
14:33:49 <nbro> but yea, I agree, there are different ways of parsing and this may be confusing for a beginner
14:37:45 <erisco> I am sure there are many simple ways to start, but one of them is just learning the two fundamental operators of grammars
14:38:07 <erisco> if you understand these then the problem of parsing is much clearer
14:39:27 <srk> what are these?
14:39:41 <nbro> yeah, indeed
14:40:15 <nbro> also, I should have practiced more about grammars in the past… 
14:40:59 <erisco> they go by many names, unfortunately, so I'll just give them the Haskell names of <*> and <|>
14:41:15 <erisco> but you might also call these "followedBy" and "choice"
14:41:47 <erisco> in grammars they are juxtaposition and | respectively
14:42:36 <srk> yeah, that's why I'm asking :)
14:42:42 <erisco> though in grammars you can write | differently by instead writing two productions with ::= for the same non-terminal
14:43:00 <erisco> same operations, just written differently
14:43:09 <srk> right
14:43:42 * srk calls | alternative :D
14:44:15 <erisco> <*> is the product of two languages, and <|> is the union of two languages
14:45:19 <erisco> once you see that, then parsing is clearly the problem of searching through this space of products and unions for the parse tree which matches the sentence at hand
14:46:32 <erisco> and you can observe the differences between two parsers just by how they implement these two operations
14:46:57 <erisco> I haven't spent much time with bottom-up parsing so I don't know how to relate it yet
14:48:16 <erisco> the problem it is solving can be described in the same way but I am not familiar with implementations of it
14:49:24 <srk> are there any automated parser generators that can produce parsers from samples of text?
14:49:51 <erisco> that sounds dubious
14:50:05 <srk> would be nice to get like basic structure for attoparsec parser and then just finish it by hand
14:50:10 <erisco> the simple solution is a production for each sample sentence
14:50:34 <erisco> so to get beyond that you have to start qualifying what a better grammar looks like
14:50:58 <srk> true
14:54:14 <erisco> srk, that is an interesting problem though, hm
14:54:25 <erisco> I don't think it is impossible to qualify but that seems the chief problem
14:55:43 <erisco> given arbitrary sentences of a language (not infinite), can you construct a grammar of that language
14:56:01 <srk> hmm :)
14:56:12 <EvanR> one rule for each sentence, brilliant
14:56:16 <erisco> well, it is going to matter in what order they're enumerated
14:56:42 <erisco> if I take n samples the enumeration could exercise a new production at n + 1
14:57:28 <erisco> so you need an enumeration such that at some n you've exhausted all the features of the language
14:57:32 <erisco> whatever qualifies as a "feature"
14:57:52 <erisco> and lets assume we can know this n when we're trying to reconstruct the grammar
14:58:06 <erisco> in practical application where we do not know this n we'd just improve our guess as more samples came in
14:59:07 <erisco> so the question is somewhere around whether it is possible to enumerate the language in such a way that all the features can be seen by a finite n
14:59:52 <erisco> or if, like my earlier argument, it is always the case that a new feature is revealed at some m > n
15:00:23 <erisco> maybe there is some informational argument to it as well, I don't know
15:00:31 <erisco> only touched on my information theory book
15:00:45 <erisco> but in some sense you'd only expect a grammar to fit together in so many ways
15:00:51 <erisco> and beyond that you can only repeat known patterns
15:02:55 <erisco> then if you solved this problem it would be interesting to see what happened if you ran it over a few gigabytes of English text, heh
15:03:45 <erisco> the idea being that perhaps the grammar ceases to change because all patterns are exhausted (which I doubt)
15:11:36 <srk> you can download lots of gigs of english text from wikipedia :D
15:11:37 <srk> it might work as there's a lot of repetition 
15:11:39 <srk> I would probably try to employ some heuristics when doing such thing trying to mimic how would one write such parser by hand
15:11:44 <srk> counting and grouping
15:11:59 <srk> would end up with an AI..
15:14:31 <erisco> there is something you have to give up
15:14:37 <erisco> S ::= a | S
15:14:54 <erisco> there is nothing we can observe from sentences to suggest this grammar
15:15:04 <erisco> we can definitely find S ::= a
15:15:40 <erisco> in fact if our grammar is only constructed of choice (and terminals) then we can clearly re-derive it
15:16:26 <erisco> but you can take parse tree samples instead to tackle S ::= a | S
15:18:12 <erisco> so for just sentence samples then we can only hope to find a language equivalent grammar
15:25:15 <iqubic> I have a haskell question.
15:25:49 <iqubic> I understand that monads are great and all, but what if I have a function that requires two values?
15:26:01 <iqubic> Like +
15:26:19 <erisco> I am not sure what the relationship is to monads here, can you provide more detail?
15:26:24 <iqubic> how do I go about adding one maybe int to another maybe int?
15:26:33 <iqubic> To get a third maybe int.
15:26:36 <erisco> oh, use liftA2 (+)
15:26:44 <dmj`> jle`: ping ping
15:26:55 <iqubic> What does liftA2 do?
15:27:14 <erisco> liftA2 (+) is \x y -> (+) <$> x <*> y
15:27:19 <dmj`> @src liftA2
15:27:20 <lambdabot> liftA2 f a b = f <$> a <*> b
15:27:47 <erisco> you don't even need to get into Monad for this, just Applicative
15:27:50 <Koterpillar> iqubic: you can think of all functions as taking one argument
15:27:56 <iqubic> And is there a list of important functions like that? Like Lift, liftM, liftA and so on?
15:28:04 <Koterpillar> iqubic: and returning a function of one less argument
15:28:12 <iqubic> Koterpillar: And then I use currying to apply them all?
15:28:17 <erisco> there is liftA2, liftA3, and a few like that
15:28:18 <Koterpillar> iqubic: yes
15:28:19 <iqubic> @src curry
15:28:19 <lambdabot> curry f x y = f (x, y)
15:28:25 <Koterpillar> not that
15:28:25 <erisco> the liftM2 and liftM3 and so on are historic relics
15:28:31 <iqubic> Really?
15:28:38 <Koterpillar> liftA2, etc. do exactly that for you
15:28:43 <iqubic> @src liftA
15:28:44 <lambdabot> liftA f a = pure f <*> a
15:28:44 <Cale> iqubic: Or for monads specifically, liftM2. It may be instructive to look at the implementation:
15:28:56 <Cale> liftM2 f x y = do u <- x; v <- y; return (f u v)
15:28:57 <iqubic> @src liftA3
15:28:57 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:29:26 <geekosaur> the database @src uses is lame (and not always related to what the actual source is)
15:29:50 <erisco> lambdabot, I own a toaster that can find sources better than you
15:30:07 <iqubic> What would liftM2 (+) [1,2,3] [1,2,3] return?
15:30:08 <mmaruseacph2> does it run on Haskell?
15:30:19 <erisco> iqubic, that is easy to test, isn't it?
15:30:21 <mmaruseacph2> > liftM2 (+) [1,2,3] [1,2,3]
15:30:23 <lambdabot>  [2,3,4,3,4,5,4,5,6]
15:30:29 <iqubic> Yeah, it is simple to test
15:30:36 <iqubic> I have ghci on this computer.
15:30:56 <lyxia> Or you can ask lambdabot
15:31:12 <erisco> there is no real point to liftA as that is just fmap
15:31:29 <iqubic> what do I need to import to get liftM2?
15:31:33 <mmaruseacph2> I've never used liftA, fmap, <$> and <*> all the way
15:31:49 <nbro> erisco: how would you implement a recursive descent parser for your grammar: http://lpaste.net/354293? For example, in my implementation, if I try to parse true || true, it doesn’t work, but I guess I’m not really implementing a recursive descent
15:31:59 <erisco> iqubic, liftM2 is instructive in its definition but it is no longer necessary. use liftA2 instead.
15:32:07 <lyxia> liftA can be useful to derive Functor
15:32:11 <erisco> iqubic, and that comes from Control.Applicative
15:32:22 <lyxia> but since there is already an extension for that...
15:32:37 <erisco> there is no real harm though they should have called it liftA1 perhaps
15:32:48 <erisco> consistency with the rest of the liftA* family is fine
15:33:09 <erisco> then liftA0 needs to be $>, heh
15:33:35 <iqubic> Well, I can't run liftA (+) [1,2,3] [1,2,3]
15:34:03 <iqubic> It's liftA2 that I want
15:34:04 <erisco> that is a type error, use liftA2
15:34:08 <lyxia> liftA0 = pure
15:34:34 <iqubic> Is there a list of all the functor, applicative, and monad laws out there?
15:35:07 <dmj`> jle`: have some dank types to show you
15:35:37 <erisco> iqubic, I have seen a few sites/pages with lists but you can also just look on the doc pages http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Applicative.html
15:35:53 <iqubic> Are the laws important to follow?
15:35:59 <erisco> absolutely
15:36:18 <iqubic> Why?
15:36:31 <iqubic> Isn't it just more stuff you have to remember?
15:36:37 <iqubic> @src <*>
15:36:38 <lambdabot> Source not found. There are some things that I just don't know.
15:36:38 <mib> The soul of law
15:36:48 <erisco> iqubic, I assure you we don't just want more stuff to remember
15:37:09 <iqubic> So what's the point behind the laws?
15:37:14 <erisco> iqubic, the reason is because if you know a property holds for all instances then you can write generic algorithms on those instances
15:37:24 <iqubic> Ah.
15:37:46 <iqubic> Is it a good Idea to try writing my own monad?
15:37:48 <erisco> and know properties of those algorithms
15:37:53 <iqubic> Or should I not do that?
15:38:07 <erisco> as an exercise you can do that, sure
15:38:35 <lyxia> the laws are quite natural in a way. A non-lawful instance of Monad is like the non-associative addition of IEEE floating point numbers.
15:38:46 <iqubic> Is see.
15:39:01 <iqubic> So should I go ahead and just memorize the laws?
15:39:23 <erisco> I haven't bothered. I just look them up when it is relevant to me
15:39:27 <iqubic> @src $
15:39:27 <lambdabot> f $ x = f x
15:39:28 <lyxia> It is more difficult to program *without* the laws because we're just so used to them.
15:39:42 <iqubic> @src .
15:39:43 <lambdabot> (f . g) x = f (g x)
15:40:23 <iqubic> Why do Haskell coders like to avoid using parentheses and just go for . and $ ??
15:40:44 <erisco> they don't. we have different style preferences
15:41:24 <mmaruseacph2> sometimes it makes for easier to read code, sometimes it makes for harder to read code
15:41:40 <iqubic> So, how does the state monad work?
15:41:51 <iqubic> I've been trying to wrap my head around that for a while now.
15:41:59 * erisco cues Cale
15:42:40 <erisco> so if you're interested how it works I presume you mean you want to know the implementation, not just how to use it
15:43:23 <iqubic> erisco, that would be helpful
15:43:34 <erisco> so, a State is just a function s -> (s, a)
15:43:46 <erisco> a function that takes a state and returns a new state plus some other value
15:44:16 <erisco> newtype State s a = State { runState :: s -> (s, a) }
15:44:51 <erisco> get :: State s a -> State s s   see if you can implement this function
15:45:16 <iqubic> I'm not sure what the s and the a mean in the new type declaration.
15:45:29 <erisco> those are type variables
15:45:39 <iqubic> And can be whatever I want?
15:45:51 <erisco> as long as they have kind *, yes
15:46:04 <iqubic> Cools.
15:46:14 <iqubic> So what does run state do?
15:46:34 <iqubic> I see it in the newtype declaration.
15:46:39 <erisco> runState :: State s a -> (s -> (s, a))
15:46:44 <erisco> it just projects the function
15:47:09 <jayjam124> https://pastebin.com/50uwN5hH
15:47:19 <jayjam124> what's a good way to generate new digits in this thread?
15:47:23 <jayjam124> constantly
15:47:42 <iqubic> What does that tuple repersent? I assume fst is the output of applying the function to the current state, and scnd is the new state?
15:48:18 <erisco> the first element is the new state, the second element is some other value
15:48:46 <erisco> I think the official implementation has this tuple the other way around but it is the same thing
15:48:55 <iqubic> What other value? the output from running the state?
15:49:08 <iqubic> So what should the get function do?
15:49:19 <iqubic> I want to try implementing that.
15:49:21 <erisco> well, the idea of having a state is we want to do something else with that state
15:49:31 <iqubic> Sure, like a stack.
15:49:40 <erisco> so this "other value" is that something else
15:49:43 <iqubic> Or a random number with a generator.
15:49:47 <mib> what's is Haskell?
15:50:03 <Sornaensis> @google haskell
15:50:05 <lambdabot> https://www.haskell.org/
15:50:12 <erisco> mib, Haskell is a functional programming language, see the website ^
15:50:13 <iqubic> I ask again, what is get supposed to do?
15:50:21 <Sornaensis> :t get
15:50:22 <lambdabot> MonadState s m => m s
15:50:47 <erisco> no no, they've made it complicated nowadays Sornaensis :P
15:50:59 <jayjam124> I guess no-one is able to help me with what I asked earlier then?
15:51:05 <erisco> iqubic, "get" fetches the current state for us
15:51:12 <Sornaensis> ; _;
15:51:15 <erisco> jayjam124, I don't know anything about threading in Haskell, sorry
15:51:33 <iqubic> Can you giveme the type signature for get? I want to try implementing it.
15:51:41 <jayjam124> I just wanna know how to generate random digits
15:51:46 <Sornaensis> @info State
15:51:47 <lambdabot> State
15:51:47 <erisco> I did, but here it is again:  get :: State s a -> State s s
15:51:56 <jayjam124> and put them into a variable of some kind
15:52:14 <iqubic> I don't understand that type signature.
15:52:17 <Sornaensis> get looks something like get = State $ \s -> (s, s)
15:53:04 <erisco> sorry, that is the wrong signature -.-
15:53:09 <erisco> it is  get :: State s s
15:53:32 <iqubic> right. It returns a 2-tuple with both elements being the new state?
15:53:32 <mib> what's make Haskell special?
15:53:43 <erisco> yes
15:53:52 <iqubic> How would I go about writing my own state monad thing?
15:53:59 <erisco> then there is  put :: a -> State s a
15:54:42 <Sornaensis> mib: the type system
15:55:15 <iqubic> What is the implementation of put?
15:55:33 <erisco> mib, Haskell is lazy, pure, has ADTs, type classes, and excellent type inference, to name a few things
15:55:58 <iqubic> put a = State $ (s, a)
15:56:02 <iqubic> Is that right?
15:56:15 <iqubic> I think it should be, but I don't really know.
15:56:18 <erisco> not quite, that is a type error
15:56:19 <stevenxl> Hi everyone. I am trying to understand how foldl works, specifically in comparison with foldr. 
15:56:27 <erisco> remember that State is constructed with a function
15:56:41 <erisco> State :: (s -> (s, a)) -> State s a
15:57:22 <erisco> > foldl f z [a,b,c,d] -- stevenxl
15:57:24 <lambdabot>  f (f (f (f z a) b) c) d
15:57:32 <erisco> > foldr f z [a,b,c,d] -- stevenxl
15:57:34 <lambdabot>  f a (f b (f c (f d z)))
15:58:05 <iqubic> So I need to do: put s = State $ \s -> (s, s)
15:58:21 <erisco> put a = State (\s -> (s, a))
15:58:22 <iqubic> No, because that's the implementation of get.
15:58:32 <erisco> get = State (\s -> (s, s))
15:58:38 <Sonolin> ooh how do I get ghci to expand statements like that?
15:58:51 <erisco> Sonolin, afaik that is a lambdabot feature only
15:59:07 <Sonolin> ah ok, pretty sweet
15:59:15 <Koterpillar> no, they are special types
15:59:16 <Koterpillar> :t f
15:59:17 <peddie> erisco: Sonolin: isn't that the simple-reflect library?
15:59:17 <lambdabot> FromExpr a => a
15:59:31 <Koterpillar> ^
15:59:37 <Koterpillar> http://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect.html
15:59:38 <iqubic> Wait, what is that function doing? the \s -> (s, a)
15:59:39 <stevenxl> thansk erisco I have to keep looking at it. 
15:59:39 <erisco> well yes, but can you actually type something like that into ghci and get that output Koterpillar?
15:59:40 <iqubic> In put
15:59:47 <peddie> erisco: https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect.html
16:00:02 <iqubic> How does the put function work with state monads?
16:00:26 <erisco> ah, okay, I get it :P
16:00:33 <Koterpillar> erisco: yes, import that
16:00:36 <Sonolin> nice thanks Koterpillar
16:00:46 <erisco> I thought it added something to the front end
16:00:55 <erisco> but no, it just shadows all your variable names, great
16:00:59 <Koterpillar> just some clever show instances
16:01:04 <peddie> oh lol Koterpillar I didn't see you'd sent the same link right before I did :)
16:01:22 <Koterpillar> peddie: you've pointed to the library before I did :)
16:02:04 <erisco> iqubic, I should stop trying to explain it as I keep screwing it up :P
16:02:22 <iqubic> Alright how the heck does the modify function work?
16:03:02 <peddie> iqubic: I think you can write `modify` if you already have `get` and `put`
16:03:07 <erisco> put :: s -> State s ()  and   put s' = State (\s -> (s, ())   that is the correct version iqubic, sorry
16:03:25 <mib> do I get an "exe" file of my code?
16:03:54 <mib> output exe in Windows?
16:04:06 <iqubic> peddi, let me try to write modify myself
16:04:12 <erisco> mib,  ghc myprogram.hs -o myprogram.exe
16:04:50 <stevenxl> erisco: I know that it is possible to define map and filter in foldr. 
16:05:04 <mib> erisco, Okay interesting.
16:05:12 <stevenxl> Can you suggest a function that I can implement in foldl to test if I am getting it.
16:05:19 <erisco> mib, so it works the same as if you were compiling C code
16:05:37 <erisco> stevenxl, sure, define filter and map :P
16:05:40 <iqubic> So, do I need to pass in a state monad to my modify function for states?
16:06:05 <stevenxl> those can be done in terms of foldl? Cool. I'll take a shot at it. 
16:06:54 <mib> erisco, is Haskell open source and free?
16:07:24 <iqubic> modify s f = put $ get s $ f
16:07:28 <iqubic> I think that is correct
16:07:33 <iqubic> where s is a state.
16:07:50 <iqubic> Not sure how to make that point free though, like put and get are.
16:08:02 <erisco> mib, yes
16:08:26 <iqubic> Not sure how to avoid passing in the state to my function, but I think I just wrote modify correctly
16:08:48 <erisco> iqubic, you can always try it in ghci
16:09:09 <iqubic> How do I create a state that I can try that on?
16:09:27 <erisco> use whatever, like Int
16:09:58 <mib> erisco, last question, what about making GUI application in Windows?
16:09:59 <erisco> > runState get 5
16:10:01 <lambdabot>  (5,5)
16:10:28 <iqubic> why does it return (5,5)?
16:10:34 <peddie> stevenxl: implement foldr using foldl
16:10:42 <erisco> mib, there are several packages on Hackage which can assist you in developing different kinds of applications on different platforms
16:11:02 <erisco> iqubic, you can evaluate it by hand to find out
16:11:09 <mib> GUI?
16:11:14 <iqubic> Can I?
16:11:17 <erisco> yes, including GUI
16:11:20 <nbro> erisco: I think I implemented a recursive descender, but not using your grammar
16:11:30 <iqubic> @src runState
16:11:31 <lambdabot> Source not found. My pet ferret can type better than you!
16:11:35 <erisco> you'll find bindings to many popular GUI libs as well as APIs brewed in Haskell
16:12:02 <iqubic> Wait a minute. get = return
16:12:04 <erisco> iqubic, there is no source to that function, but if there was it would be   runState (State f) = f
16:12:06 <iqubic> I am so stupif
16:12:12 <mib> Thanks erisco
16:12:17 <nbro> erisco: I used this grammar: https://pastebin.com/QdhFJWZu
16:12:31 <erisco> return :: a -> State s a   and   get :: State s s   so no, they are not the same
16:12:56 <iqubic> right, return makes a stateful computation that always returns a
16:13:10 <iqubic> or rather always evaluates to a
16:13:22 <iqubic> How does one make a state?
16:13:28 <iqubic> With a function?
16:13:34 <erisco> you make a State with a function, yes
16:13:39 <erisco> :t State
16:13:41 <lambdabot> error:
16:13:41 <lambdabot>     • Data constructor not in scope: State
16:13:41 <lambdabot>     • Perhaps you meant one of these:
16:13:52 <erisco> okay, well it is   State :: (a -> (s, a)) -> State s a
16:13:55 <mib> So, if I developed application in Linux I can compile it in Windows? Do I?
16:14:18 <erisco> or you can choose   State :: (a -> (a, s)) -> State s a
16:14:24 <erisco> I can't remember which the official one is
16:14:35 <iqubic> the official one puts the s second.
16:14:41 <erisco> mib, if you use portable libraries then yes
16:14:48 <sophiag> anyone have time to help me with a (theoretically) simple list processing function? i have two versions, one that uses pattern matching and another with a list comprehension. i'm having trouble figuring out the (very long list of) errors in the former, but i don't think it does what i want anyway: compare every element in one to every element in the other rather than mapping elements of the same index. here's the code:
16:14:48 <sophiag> http://lpaste.net/354300
16:15:17 <iqubic> s is supposed to be the current state of the monad
16:15:38 <erisco> nbro, sorry I didn't get time to write a parser
16:16:54 <iqubic> Why the heck won't GHCI accept "let s = get 5"?
16:17:04 <nbro> erisco: you don’t have to say sorry, of course
16:17:09 <nbro> I appreciate all your help ;)
16:17:24 <nbro> anyway, my implementation is in Scala
16:17:32 <nbro> if someone wants to see it
16:17:35 <erisco> iqubic, because get is not a function
16:17:43 <iqubic> it isn't
16:17:55 <erisco> you are using it as one by applying it to 5
16:18:01 <iqubic> Oh.
16:18:21 <iqubic> So how do I create a state in ghci?
16:19:01 <erisco> you make any function which unifies with the type  s -> (a, s)
16:19:13 <erisco> then you apply it to the State constructor
16:19:42 <iqubic> Alright I just tried let x = State $ /s -> (s, s) and got an error saying that State is not in scope.
16:19:46 <iqubic> What the heck?!?!
16:19:51 <erisco> that isn't usually what you're going to do though
16:20:03 <iqubic> What do I usually want to do?
16:20:04 <erisco> instead you'll use get, put, return, and >>=
16:20:45 <erisco> did you define State?
16:21:17 <iqubic> No. I thought that would be done by importing Control.Monad.State
16:21:48 <iqubic> Also let x = return $ get 5
16:21:59 <iqubic> just doesn't work at all either.
16:22:02 <erisco> try  import Control.Monad.Trans.State
16:22:13 <erisco> you are still using get as a function
16:22:15 <iqubic> Why do I have to import that?
16:22:27 <iqubic> How is get supposed to be used?
16:22:32 <erisco> because State is defined in transformers
16:22:49 <erisco> Control.Monad.State is from mtl iirc and that is old
16:23:56 <iqubic> How does one correctly use get?
16:24:12 <erisco> well, you use it to retrieve the current state
16:24:19 <erisco> get :: State s s
16:24:25 <erisco> so you use it like you'd use a State s s
16:24:32 <pacak> :t get
16:24:33 <lambdabot> MonadState s m => m s
16:24:37 <erisco> I gave the trivial example of  runState get 5
16:25:01 <iqubic> And that doesn't use get as a function???
16:25:14 <erisco> no, because it is not a function
16:25:24 <iqubic> So what is get 5 doing?
16:25:30 <erisco> runState get 5 = (runState get) 5
16:25:31 <pacak> :t runState
16:25:32 <lambdabot> State s a -> s -> (a, s)
16:25:37 <pacak> 5 - s in this case
16:25:57 <pacak> > runState get 5
16:25:59 <lambdabot>  (5,5)
16:26:06 <iqubic> Ah. so get is a state???
16:26:10 <erisco> yes
16:26:12 <pacak> > runState (get >> return ()) 5
16:26:14 <lambdabot>  ((),5)
16:26:31 <erisco> get :: State s s, that means it has the type State s s, so it is a State
16:26:37 <pacak> > runState (get >>= return . show) 5
16:26:39 <lambdabot>  ("5",5)
16:27:12 <erisco> I think what you really want is someone to take you from start to end of what State is about and how it works
16:27:19 <erisco> I'm just giving an overview of the involved functions
16:27:21 <Sornaensis> > evalState (modify (+2) >> get) 5
16:27:22 <iqubic> I would like that.
16:27:24 <lambdabot>  7
16:27:33 <erisco> usually Cale does that... I don't know if I have the energy
16:27:42 <iqubic> Where is Cale now?
16:28:02 <erisco> it doesn't sound like you are confident with simpler concepts yet
16:28:15 <iqubic> Well I know what a monad is.
16:28:36 <lapinot> i just asked on #ocaml how they would compare the feature sets of ocaml and haskell so to complete the debate i think i should bring it over here too
16:29:35 <iqubic> Can I see the implementation of put once more?
16:29:47 <iqubic> I think that will help me a lot
16:29:58 <erisco> you can read some on it here https://wiki.haskell.org/State_Monad
16:30:21 <peddie> iqubic: can you figure out the implementation of `put` from its type?
16:30:25 <robkennedy> ?src put
16:30:26 <lambdabot> Source not found. I feel much better now.
16:30:34 <erisco> put s' = State (\s -> ((), s'))
16:31:26 <iqubic> Great and get is: get s' = (\s -> (s, s))
16:31:29 <iqubic> Is that right?
16:31:40 <iqubic> I think that would be right.
16:31:41 <erisco> close, but no
16:31:44 <lapinot> (some conclusion was that haskell typeclass has problems with uniqueness problem of instances and orphan instances)
16:31:45 <lyxia> lapinot: https://www.reddit.com/r/ocaml/comments/3ifwe9/what_are_ocamlers_critiques_of_haskell/
16:31:49 <erisco> remember  get :: State s s
16:31:50 <Sonolin> get has no parameter..
16:32:22 <iqubic> get = (\s -> (s,s))
16:32:26 <iqubic> is that correct?
16:32:26 <erisco> iqubic, you may know what a monad is but it seems you have to learn more about types first
16:32:47 <erisco> iqubic, that will make this easier, as the implementations of put and get are actually determined by the type alone
16:32:56 <iqubic> What more do I need ot know about types?
16:33:23 <erisco> well it should be clear that  get s' = (\s -> (s, s)) cannot possibly be right because that wouldn't have the type  State s s
16:33:39 <iqubic> Yeah, I see that now.
16:33:53 <lyxia> lapinot: I like the amount of type-level magic you can do in Haskell, but this can make APIs inaccessible to newcomers.
16:34:02 <robkennedy> ericso: do you know if a State Monad computation that doesn't call get or put simplies out the state?
16:34:38 <erisco> okay, but, you're either wildly guessing or you need to practice more on these basics, because that should have been obvious to you
16:34:58 <naushadh> hello #haskell, any persistent/mysql devs here?
16:35:11 <iqubic> Alright what's the type of modify?
16:35:29 <robkennedy> I've used persistent with tsql, may be able to help
16:35:30 <iqubic> I want to try writing the implementation for that.
16:35:39 <erisco> modify :: (s -> s) -> State s ()
16:36:27 <iqubic> So it takes a single function of type (s -> s) and returns a state.
16:36:32 <iqubic> Is that correct?
16:37:25 <erisco> robkennedy, I am not sure what optimisations GHC can make here, but you can look at the Core output if you're inclined
16:37:38 <erisco> yes
16:37:43 <lapinot> lyxia: thanks, that's actually what i looked for!
16:37:47 <iqubic> Alright, I have no idea what the implementation of modify should be.
16:38:05 <iqubic> I know that it might be super obvious, but I don't know it.
16:38:38 <erisco> okay, well, this time it is not entirely determined by the type what we're supposed to do here, but there is an intention to it
16:38:46 <iqubic> Oh.
16:38:53 <erisco> the intention is that we apply the function to the state to get a new state
16:39:10 <erisco> and apply it just once
16:39:25 <iqubic> But what happens to the other value in the state?
16:39:37 <erisco> well, you tell me what that value is
16:39:45 <iqubic> Is it () ?
16:39:48 <erisco> yes
16:40:24 <iqubic> Modify f = (\s -> (f s, ()))
16:40:43 <iqubic> That has the right type.
16:40:50 <naushadh> robkennedy: I've forked persistent-mysql to create persistent-mysql-haskell. https://hackage.haskell.org/package/persistent-mysql-haskell
16:41:02 <erisco> not quite, but that is just about it. it is  modify f = State (\s -> (f s, ()))
16:41:20 <naushadh> robkennedy: I'm looking for any kind of feedback 
16:42:26 <iqubic> Now I'm having trouble getting GHCi to accept that as a valid function.
16:42:39 <erisco> if we have put and get defined we can also define it as  State (get >>= put . f)
16:43:00 <iqubic> Ah, yes. Yes you can just do that.
16:43:09 <erisco> tell me what the error is
16:43:28 <Sonolin> state is second part of tuple by default guys
16:44:00 <erisco> Sonolin, I'll never remember it :P
16:44:13 <iqubic> But really, GHCi should be accpeting "let modify' f = StateT (\s -> (f s, ()))
16:44:16 <iqubic> But it doesn't
16:44:35 <erisco> well try swapping the tuple as Sonolin pointed out
16:44:41 <iqubic> I will.
16:45:10 <Sonolin> well iqubic StateT is a monad transformer, that could be your issue
16:45:16 <iqubic> Oh.
16:45:38 <iqubic> But "State" is not in scope.
16:45:51 <Sonolin> but you should be able to use either "State" constructor (newer) or "state" (older)
16:46:17 <erisco> yes, it has become fancier and now we have StateT instead
16:46:33 <iqubic> "State" is not in scope, even though I have Control.Monad.Trans.State imported
16:46:46 <erisco> yes, use the lowercase "state"
16:47:00 <iqubic> Why?
16:47:00 <erisco> State is defined as a type alias of StateT
16:47:16 <erisco> look here http://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-State-Lazy.html
16:47:20 <iqubic> But StateT is in scope, and State is not
16:47:31 <Sonolin> try :i State iqubic
16:47:34 <Sonolin> it should show you the alias
16:47:36 <erisco> State is not a value
16:47:52 <iqubic> It does show me that alias.
16:48:02 <iqubic> Why won't GHCi use that alias?
16:48:11 <erisco> in the old days we had  newtype State s a = State { runState :: s -> (a, s) }  but this has been discarded in favour of transformers
16:48:22 <erisco> so now there is the more generic StateT on which the old State can be defined
16:48:29 <erisco> but we no longer have the State type and State constructor
16:48:42 <erisco> instead we have a State alias and a "state" function which acts as the constructor
16:48:53 <iqubic> So if I want to use a State constructor what should I do?
16:48:54 <erisco> it does use the alias
16:49:08 <iqubic> Not for me.
16:49:28 <erisco> there is a difference between types and values! there is "State" the type constructor and not "State" the data constructor
16:49:42 <erisco> I mean "State" the type alias
16:49:48 <iqubic> Ah. Gotcha
16:50:03 <erisco> type State s = StateT s Identity
16:50:16 <iqubic> So if I want to write a function modify' what would I do?
16:50:28 <erisco> so you can use State in types, but there is nothing of the same name defined as a value
16:50:56 <erisco> use the function called "state"
16:50:59 <iqubic> So there's no value constructor called "State"
16:51:14 <erisco> it works the same as the old data constructor named "State"
16:51:16 <iqubic> Isn't the lowercase version old and outdated?
16:51:34 <erisco> no, it is the other way around
16:51:44 <iqubic> Ah. I see
16:54:16 <robkennedy> naushadu: sorry, I don't think my usecase for ditching persistent is addressed by these sorts of changes
16:54:53 <iqubic> Why does "print $ runState get 5" work but not "print $ runState put 5"
16:55:10 <erisco> look at the types
16:57:14 <sophiag> ok, trying this again. anyone free to look at some list processing code? i'm mainly struggling with how to compare every element of two lists (rather than just mapping between those at the same indices) using pattern matching, but also have a number of errors in what i've written so far that i think are related to the data types i'm using: http://lpaste.net/354300
16:57:39 <iqubic> not sure how looking at the types helps me.
16:57:59 <erisco> the reason it "does not work" is because it is a type error, and so looking at the types will inform you why it is a type error
16:58:31 <jayjam124> is anyone good at concurrency within Haskell here?  I may as well ask because if nobody is I won't ask the question
16:58:43 <iqubic> Oh, I see the type error now.
16:58:45 <jayjam124> I mean someone must be here but it depends who is on at the time
16:58:53 <iqubic> How is put supposed to be used?
16:59:29 <erisco> you apply it to something, the new state you want to set
16:59:40 <erisco> > runState (put 2) 1
16:59:40 <sophiag> iqubic: put is the opposite of get
16:59:42 <lambdabot>  ((),2)
17:00:01 <robkennedy> naushadu: looking through the package, I'm wondering about the heirarchy, though. I left persistent for it's higher level opinions, but kept with HDBC-odbc as a low-level. I would love to replace that low-level for some translated version of what you've provided, but to do so I'd apparently be back in persistent land. 
17:00:38 <iqubic> wait, so the previous value of the state is overridden with put.
17:01:36 <sophiag> iqubic: often you want to get the state and then modify it somehow before calling put. you can also just call modify which applies a function to the existing state and then puts it
17:01:49 <robkennedy> naushadu: Of course I can ignore the (one?) function that targets persistent. But where is that dependency coming from? 
17:02:16 <iqubic> Alright. I kinda get states, but not really.
17:03:13 <sophiag> iqubic: think about it like you have a variable you're mutating...except since we don't do that you have to get the old one and then put a new different one in its place. that simple
17:03:38 <sophiag> it's really all in the name :)
17:05:09 <erisco> nbro, I typed up a parser for you, keeping everything simple, but lpaste is borked
17:05:44 <sophiag> lpaste is borked? i just used it
17:05:50 <erisco> 502 for me
17:05:51 <naushadh> robkennedy: I've retained the hierarchy from upstream. there are separate hackage/stackage libs for each database backend though the source code is all in one place (sub dirs for each backend).
17:06:39 <iqubic> lpaste works for me.
17:06:58 <erisco> did you try pasting something though?
17:07:00 <nbro> erisco: I actually wrote the parse but not for your grammar and in Scala..
17:07:02 <erisco> ah it is back again
17:07:10 <erisco> nbro, here you go http://lpaste.net/354303
17:07:24 <naushadh> robkennedy: I'm sorry, I'm don't understand which function or dependency you're referring to. 
17:07:33 <erisco> note that it does not accept spaces
17:07:46 <erisco> I'd recommend tokenising first to fix that
17:07:54 <iqubic> I just wrote a stateful stack implementation.
17:08:04 <iqubic> And it is really stupidly simple.
17:08:07 <sophiag> lpaste is always super slow...
17:09:04 <iqubic> Wait, is a 2-tuple a monad?
17:09:17 <erisco> oh I am missing parseExp4 _ = Nothing at the end there, let me add that in
17:09:28 <iqubic> how do I unbind variables in GHCi?
17:09:50 <erisco> :r is one way, or you can overwrite them
17:10:27 <nbro> erisco: thanks a lot for all your help, I will have a look at it and try to understand why my implementation based on your grammar actually was working
17:10:41 <nbro> the thing is, I’m learning Scala, Haskell, Compilers, etc, at the same time
17:10:42 <nbro> lol
17:11:07 <nbro> not because I want to
17:11:29 <erisco> I never appreciated the rate at which university crams materials down your throat
17:11:54 <erisco> I just wanted to slow down and think about a topic for a while
17:12:01 <nbro> since I’m of the idea that we should stick to learn one language for a while before trying to move to another..
17:14:10 <jayjam124> how do you define data that can be shared between threads?
17:14:13 <nbro> even though Scala is quite is to pick up once you know a little bit of Haskell, but you end up not being as productive as you would like
17:14:18 <nbro> *quite easy
17:15:54 <iqubic> So alright, I just defined a function: "let test a = do put a; modify (+1); get;
17:16:07 <iqubic> and now I can't run that function at all
17:16:39 <erisco> iqubic, a better format for some of your "it doesn't work" questions would be to pastebin what you're trying to run along with the error ghci gives you
17:17:30 <sveit> Two intero questions: 1) is there a way to add necessary import statements without jumping to the top of the file, then jumping back? Detection of the relevant import would be nice too.
17:18:54 <lpaste> iqubic pasted “State Testing” at http://lpaste.net/354305
17:19:11 <iqubic> Yeah, so that's the output from ghci.
17:19:16 <iqubic> It isn't working
17:19:56 <iqubic> It might be a type error of sorts, I suppose
17:20:33 <Koterpillar> you have to give initial state
17:20:44 <erisco> when you print something in the REPL it uses the Show instance
17:21:10 <erisco> so since you've tried to print something with the type a0 -> a0, it has looked for Show (a0 -> a0) and didn't find it
17:21:18 <erisco> because we can't print functions in Haskell
17:21:25 <iqubic> I have to give an itial state even though it gets overriden?
17:21:26 <sveit> 2) is there a way to get types of functions (esp. imported ones) even when the code doesn't compile?
17:21:46 <Koterpillar> iqubic: yes, because you can't guarantee it is
17:21:48 <erisco> this is just the wrong way to think about the problem here iqubic
17:22:06 <iqubic> What is the right way to view the problem?
17:22:12 <erisco> run this   :t  execState $ test 1
17:22:27 <Sornaensis> :t execStateT
17:22:28 <Welkin> this is haskell, not javascript
17:22:29 <lambdabot> Monad m => StateT s m a -> s -> m s
17:22:31 <Welkin> it's different
17:22:55 <erisco> you see the type of that is  Num a => a -> a
17:23:01 <Sornaensis> sveit: yea you can tell GHC to defer errors and it will type check
17:23:03 <iqubic> Yeah.
17:23:25 <iqubic> I can't print something of type a -> a
17:23:31 <erisco> that's right
17:23:58 <sveit> Sornaensis: is there a way to tell intero to do that? Or the vanilla haskell-mode?
17:24:02 <Welkin> you *can*
17:24:08 <Welkin> you just need to define a Show instance for it
17:24:21 <Welkin> but then you decide what it looks like as a String
17:24:22 <iqubic> I have to give an itial state so that the function get a type of num a => a
17:24:31 <erisco> yeah but the Show Nazis will descend upon you
17:24:54 <iqubic> Why do I have to supply an intial state if that just gets overriden?
17:25:07 <erisco> because that is what the type is
17:25:19 <iqubic> Alright then. Fair enough
17:25:25 <Welkin> what do you mean overriden?
17:25:30 <Welkin> there is no over-riding in haskell
17:25:49 <Koterpillar> iqubic: here's a function from Int to Int: f _ = 10
17:25:55 <Welkin> State is just a nicer way of passing around data
17:25:59 <geppettodivacin> jayjam124: Usually you use either an MVar or a TVar. These are storage locations to put mutable data, and it can be accessed safely by many threads at once.
17:26:03 <Koterpillar> iqubic: it ignores its argument, but you can't call it without one
17:26:04 <erisco> > runState (put 1) undefined -- in this sense, Welkin
17:26:06 <lambdabot>  ((),1)
17:26:20 <Welkin> you have an initial State value that gets *replaced* with a new one when you make any "changes" to it
17:26:40 <erisco> iqubic, your question is like asking why you need to pass another argument to  const 0
17:26:53 <iqubic> Now, can someone give me a situation in which a state would be used, so I can have practice with states
17:26:54 <erisco> iqubic, the answer is because that is what the type says
17:27:11 <Welkin> iqubic: you'll never use it
17:27:19 <Welkin> I never have
17:27:21 <iqubic> Why not Welkin?
17:27:34 <Welkin> I used it as an exercise to make a small game, but ST is better for that anyway
17:27:35 <erisco> yeah I can't say I've used it either =\
17:27:41 <Welkin> Reader is very useful
17:27:44 <Welkin> learn about that one
17:27:46 <Welkin> and Writer too
17:27:59 <erisco> but then again I haven't written any large or product oriented Haskell programs
17:28:04 <erisco> and I suspect it becomes more relevant there
17:28:08 <iqubic> I understand Writer fairly well.
17:29:00 <erisco> well at least Reader becomes more relevant, so you can pass your configuration around
17:29:19 <erisco> maybe a video game example where you have a game state
17:29:20 <Welkin> I suppose State is helpful for making a toy game in haskell
17:29:28 <Welkin> then you will quickly switch to using ST
17:29:37 <Welkin> for web apps, it's not useful at all
17:29:45 <Welkin> all of your state is stored in a database anyway
17:30:06 <iqubic> What is ST?
17:30:17 <Welkin> it's like State, but it lets you mutate inside of it
17:30:20 <erisco> State for daredevils
17:30:24 <Welkin> State Thread
17:30:58 <Welkin> ST is very cool
17:31:12 <iqubic> Wait, can't you mutate the variable in state?
17:31:16 <Welkin> no
17:31:25 <Welkin> State is just a nice way to pass around immutable state
17:31:36 <Welkin> you could do the same thing by explicitly passing around your data in every function
17:31:55 <iqubic> But doesn't modify change the data in a state?
17:31:57 <erisco> that is the implementation of State, of course, just passing around the state as an argument
17:31:58 <Welkin> no
17:32:03 <Welkin> it replaces it
17:32:21 <iqubic> Ah. I see
17:32:34 <erisco> iqubic, (+1) 1 does not change the value of 1 to 2
17:32:51 <erisco> iqubic, so similarly for modify
17:32:52 <Welkin> ST is still pure, but allows mutation inside
17:33:15 <iqubic> Right, it creates a new state.
17:33:33 <Welkin> http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z
17:33:41 <Welkin> the best intro paper on ST
17:33:48 <Welkin> and my favorite haskell paper so far
17:34:18 <rotaerk> oo, he researches principals
17:34:29 <Welkin> https://www.microsoft.com/en-us/research/publication/lazy-functional-state-threads/
17:34:52 <Welkin> previous link isn't working right
17:35:01 <Welkin> pdf: https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf
17:35:02 <iqubic> Alright, how can I demonstrate my understanding of the writer monad.
17:35:16 <Welkin> iqubic: create a logger
17:35:44 <Welkin> you can use it to, for example, log moves made in a game
17:35:45 <iqubic> What does a logger do?
17:35:47 <Welkin> like hangman
17:35:53 <Welkin> it logs data
17:36:11 <iqubic> Alright. What functions do I need to implement?
17:36:39 <Welkin> you want to write your own Writer implementation? Or you want to use Writer?
17:36:51 <Welkin> either way, figure out what you want to do with it
17:37:38 <iqubic> I want to use the Writer.
17:38:30 <iqubic> I want to make sure I know the Writer well enough to use it.
17:39:52 <rotaerk> iqubic, maybe make an arithmetic expression evaluator that also lists every step of reduction
17:40:03 <Welkin> LYAH has a good explanation here http://learnyouahaskell.com/for-a-few-monads-more#writer
17:40:24 <c_wraith> writer is rarely used in practice. it's a good illustration, but it's only the correct choice to actually use in very rare cases. 
17:40:58 <iqubic> I'll write myself an RPN calculator that keeps a log of the things it's doing.
17:41:17 <iqubic> c_wrait, why do you say writer is only rarely used?
17:41:43 <sophiag> you can almost always use applicatives instead of Writer
17:41:53 <c_wraith> because it frequently is very bad for memory use. 
17:42:15 <rotaerk> hmm, how are applicatives substitutable for Writer?
17:42:28 <iqubic> But I want to have a String of output created as my RPN calculator goes along.
17:43:23 <sophiag> rotaerk: usually you're just using Writer as a monoid so you can do that with just by calling Const on an applicative
17:46:21 <rotaerk> ah
17:46:46 <sophiag> glad that made any sense because i didn't explain it very well :)
17:48:40 <rotaerk> I don't fully grasp it, but it gave me enough information that I'll get there if I think about it
17:50:21 <sophiag> i would recommend reading essence of the iterator pattern for an intro to applicative style. it uses one example that's very familiar and simple and contrasts monadic and applicative style
17:50:48 <Welkin> sophiag: is that the title of the paper? Could you provide a link?
17:50:53 <sophiag> it's actually helped me understand the monad hierarchy in general as a beginner
17:50:57 <sophiag> sure, one sec
17:51:43 <sophiag> Welkin: https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
17:56:05 <iqubic> So, is the Writer Monad important to understant?
17:56:44 <jle`> important as in you'll use it often?
17:56:46 <jle`> not really
17:56:49 <sophiag> iqubic: if you understand monads in general there's really not much to it
17:57:00 <jle`> important as in insightful?
17:57:02 <jle`> maybe
17:57:11 <sophiag> as mentioned, i find it's mostly used with monoids. it's very important to understand monoids
17:57:27 <iqubic> What the point of a monoid?
17:57:36 <sophiag> oh boy
17:57:41 <sophiag> have you read lyah?
17:57:43 <jle`> oh boy
17:57:49 <jle`> http://ozark.hendrix.edu/~yorgey/pub/monoid-pearl.pdf
17:57:54 <iqubic> I have read all of LYAH.
17:58:01 <jle`> monoids are one of the most beautiful structures that we talk about often in haskell
17:58:11 <sophiag> they talk about monoids plenty in lyah...
17:58:39 <iqubic> I know that a monoid are really great for taking a whole bunch of values, and turning them into a single value
17:59:04 <jle`> monoids are great cause they do it in a principled way that's easy to analyze and optimize
17:59:12 <jle`> but the Monoid typeclass is also great because it lets you abstract over it polymorphically
17:59:29 <Sornaensis> :t foldr
17:59:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
18:00:00 <iqubic> Wait, not everything can be folded over? Why is that?
18:00:20 <jle`> iqubic: if you want a fun Writer challenge, try using Writer with forM_/mapM_/traverse_/for_ to collect all of the items in a Traversable into a list
18:00:41 <jle`> iqubic: what do you mean not everything can be folded over?
18:01:44 <iqubic> the foldl function has a type constraint of foldable t
18:02:06 <jle`> that's because foldr/foldl are methods of the Foldable typeclass
18:02:13 <iqubic> Ah. I see.
18:02:27 <jle`> sort of like how (+) is a method for the Num typeclass, etc.
18:02:34 <iqubic> Yeah, I see
18:02:35 <jle`> if you want to use (+) with a type, you have to write a Num instance for it
18:02:44 <iqubic> Yeah, I get it now.
18:02:50 <jle`> well, my answer is actually a bit handwavey
18:03:10 <jle`> the real answer is that yes, it's not possible to write a meaningful Foldable instance for every type
18:03:28 <iqubic> So how would one get started with the forM_ and Writer monad challenge?
18:04:09 <jle`> forM_ :: (Foldable t, Monad f) => t a -> (a -> f ()) -> f ()
18:04:18 <jle`> so if you use it with Writer
18:04:30 <sophiag> jle`: do you have a minute to help me figure out this error that's driving me nuts? http://lpaste.net/354300
18:04:31 <jle`> forM_ :: Foldable t => t a -> (a -> Writer ??? ()) -> Writer ??? ()
18:04:38 <iqubic> You'd need to get the results one by one as thery were found
18:04:56 <jle`> yes, but can you accumulate all of the results in a way that you can extract them after the traversal is finished?
18:05:38 <iqubic> I don't think *I* can.
18:05:43 <jle`> we are basically re-implementing toList :: Foldable t => t a -> [a]
18:05:49 <geekosaur> sophiag, I have a feeling you're still barking up every wrong tree you can find, but you are trying to apply unwrapJust to a function
18:05:50 <jle`> but using forM_ and Writer
18:06:09 <geekosaur> you might have wanted to apply it to the result of applying the function
18:06:16 <sophiag> geekosaur: every wrong tree? i'm almost done with this whole program :)
18:06:19 <jle`> iqubic: forM_ sequences your (a -> f ()) to every item in the Traversable, one-by-one
18:06:23 <jle`> *in the Foldable
18:06:37 <iqubic> Sure, what do I do with that though?
18:06:38 <jle`> iqubic: and we know that a 'Writer' action is an action that accumulates a thing
18:07:02 <sophiag> geekosaur: but yeah, my problem is with just one half of the type
18:07:12 <geekosaur> come to think of it, it's *possible* that you just wanted (.) instead of ($)
18:07:13 <jle`> iqubic: so, we just use (a -> Writer [a] ()) to accumulate the 'a' that we see into a list
18:07:15 <iqubic> But what is the type of the writer we need.
18:07:23 <jle`> oh i accidentally gave away the answer
18:07:29 <jle`> you're accumulating all the a's into a list
18:07:30 <iqubic> It's fine.
18:07:32 <geekosaur> but I don't think the types line up for that
18:07:34 <jle`> so the accumulating type is [a]
18:07:42 <sophiag> geekosaur: ?
18:07:52 <iqubic> but why is the other part of the writer an empty tuple?
18:07:59 <jle`> well, Writer has to return something
18:08:02 <jle`> but we don't care about what it returns
18:08:05 <jle`> so it can be anything w/e
18:08:12 <jle`> (a -> Writer [a] Whatever)
18:08:17 <jle`> we only care about it for its effects
18:08:23 <iqubic> Ah.
18:08:35 <sophiag> geekosaur: the issue is the functions are of type Val -> Maybe Val so i just need to unwrap the result
18:08:48 <jle`> iqubic: if you use forM/mapM/for/traverse, the results are actually all collected
18:08:59 <geekosaur> sophiag, you are unwrapping *the function itself*
18:09:00 <iqubic> So why not just use that?
18:09:12 <jle`> iqubic: well, all we care about here is the accumulated accumulator
18:09:20 <jle`> the result isn't useful for this challenge
18:09:30 <iqubic> Ah. I see.
18:09:31 <geekosaur> you presumably want to apply the function to each item in the list, then unwrap that
18:09:35 <sophiag> geekosaur: but it's not all wrapped in Maybe...otherwise what i'm doing would work
18:09:42 <geekosaur> no
18:09:49 <jle`> iqubic: it is admittedly not a challenge that utilizes every aspect of Writer
18:09:58 <jle`> but it might help you become more familiar with it :)
18:09:59 <geekosaur> you are confusing ($) (immediate application) with (.) (compositon)
18:10:19 <sophiag> i understand the difference, but not how composition would make sense in this case
18:10:26 <sophiag> it's not type 
18:10:29 <sophiag> oops
18:10:30 <jle`> btw there's actually a separate type, Writer-Where-We-Don't-Care-About-The-Result, too, that people oftne use instead of Writer for this situation
18:10:32 <iqubic> jle` what does tell do?
18:10:40 <jle`> so Writer is overkill for this, but it's fun
18:10:41 <geekosaur> you are trying to unwrap the function produced by (getReqConstraint y), *then* apply it to the thing in the list
18:10:41 <sophiag> Maybe Require a
18:10:55 <jle`> iqubic: 'tell x' is a Writer action that accumulates x into the accumulator
18:10:56 <geekosaur> because that's what using ($) means
18:11:16 <iqubic> Is that what we want to do here jle`>
18:11:24 <geekosaur> if you want to apply the function produced by (getReqConstraint y) to the thing in the list and then unwrap that, you use composition
18:11:31 <jle`> iqubic: yes, you can use tell to acucmulate the stuffs you see into the accumulator
18:11:32 <sophiag> yes, and i understand the problem with that. but composition doesn't make sense to me either
18:11:39 <sophiag> that would imply Maybe [Require a]
18:11:48 <sophiag> i have to use the getter first
18:12:03 <iqubic> I assume tell uses mappend to do the accumulation though.
18:12:40 <jle`> iqubic: yes, when you sequence multiple tells, the things you tell are mappended together
18:12:41 <iqubic> Or not.
18:12:43 <geekosaur> sophiag, I can't see how the types could work together at all, and suspect you are really confused
18:12:52 <jle`> 'tell x >> tell y' is 'tell (mappend x y)'
18:13:01 <geekosaur> in particular, you are talking about Require but there is no Require here
18:13:06 <geekosaur> there is MultiList hjere
18:13:08 <jle`> or, written nicer if you use (<>) = mappend:
18:13:13 <jle`>   tell x >> tell y = tell (x <> y)
18:13:14 <geekosaur> as the error message says
18:13:16 <sophiag> geekosaur: y is of type Require...
18:13:29 <geekosaur> that doesn't matter
18:13:31 <iqubic> yeah, but tell doesn't have a type constraint of Monoid
18:13:42 <jle`> yes, you don't need a MOnoid constraint to tell anything
18:13:46 <jle`> but you need a monoid constraint to sequence tell's
18:13:49 <sophiag> right, because i called the getter on it
18:13:51 <geekosaur> (getReqConstraint y) is fine, the Require is not the problem
18:13:57 <sophiag> right
18:13:58 <geekosaur> but it gives you a Val -> Maybe Val
18:14:06 <sophiag> right
18:14:06 <iqubic> You don't need the monoid constraint??? Why not?
18:14:10 <geekosaur> it does not give you a Maybe anything, so you cannot unwrapJust it
18:14:18 <jle`> iqubic: well, you never need to do any monoiddy stuff with it
18:14:20 <sophiag> exactly...that's the question i'm asking
18:14:24 <geekosaur> you have to *apply that function* to get a Maybe
18:14:26 <jle`> iqubic: the monoidy stuff only happens when you sequence together tell's
18:14:26 <sophiag> and i don't see how compositon solves it
18:14:51 <jle`> > runWriter (tell 123)
18:14:53 <lambdabot>  error:
18:14:53 <lambdabot>      • Ambiguous type variable ‘w0’ arising from a use of ‘show_M616952825319...
18:14:53 <lambdabot>        prevents the constraint ‘(Show w0)’ from being solved.
18:14:57 <jle`> heh
18:15:02 <geekosaur> it makes sure the list value is applied to the funtion returned by getReqConstraint
18:15:05 <benzrf> heh
18:15:10 <jle`> why
18:15:10 <iqubic> Why is it that the newtype declaration of State and Writer look very similar?
18:15:12 <jle`> :'(
18:15:23 <benzrf> iqubic: how so
18:15:28 <jle`> iqubic: well
18:15:31 <geekosaur> if you use $, then it applies unwrapJust to the function and then tries to apply the result of that to the list item
18:17:35 <jle`> the relationship is kind of complicated
18:17:35 <iqubic> newtype Writer w a = Writer { runWriter :: (a, w) }  
18:17:35 <sophiag> geekosaur: the function returned is passed to filter...
18:17:35 <geekosaur> ...
18:17:35 <Axman6> @unmtl Writer [Int] ()
18:17:35 <geekosaur> no, it is not
18:17:35 <lambdabot> ((), [Int])
18:17:35 <iqubic> newtype State s a = State { runState :: (a, s) } 
18:17:35 <jle`> wait um not really
18:17:35 <iqubic> AM I wrong?
18:17:35 <benzrf> iqubic: no that's incorrect
18:17:35 <jle`> newtype State s a = State { runState :: s -> (a, s) }
18:17:35 <geekosaur> the function returned is passed to unwrapJust, because *that is what $ means*
18:17:35 <iqubic> Ah, I am wrong
18:17:36 <geekosaur> it means exactly "apply this"
18:17:36 <sophiag> geekosaur: i KNOW that
18:17:36 <geekosaur> if you do, then there is clearly something else you do not
18:17:36 <sophiag> if i remove it and do "unwrapJust $ filter p xs" then it still doesn't work
18:17:36 <sophiag> yes, i asked a question
18:17:37 <iqubic> jle' how do I make the forM_ work with a writer?
18:17:41 <sophiag> if i knew how to do this i wouldn't be on irc asking a question
18:17:41 <geekosaur> and I gave you an answer and got an argument
18:17:45 <jle`> iqubic: it already works with Writer
18:17:57 <iqubic> It does?
18:17:58 <jle`> iqubic: forM_ takes an (a -> f b) function, for any Monad f
18:18:06 <iqubic> so what's the challenge then?
18:18:09 <jle`> iqubic: so you can just give it an (a -> Writer [a] ()), to do our job
18:18:14 <jle`> iqubic: well, you need to write the function
18:18:22 <sophiag> my question wasn't "why isn't this working?" it was "how can i make this work?" you gave me answer that does not work
18:18:24 <jle`> use forM_ + Writer to write toList
18:18:33 <iqubic> I'll try that.
18:18:39 <geekosaur> because it makes no sense which is what I also said earlier
18:18:54 <sophiag> composition makes even less ense
18:18:55 <geekosaur> but your attempts to tell me what you think it is doing are also wrong
18:18:56 <sophiag> *sense
18:19:16 <jle`> iqubic: remember that forM_ 'runs' the (a -> f b) on every item inside the Foldable, and sequences the resulting 'f b's together
18:19:28 <sophiag> ok, i'd welcome an explanation. i was under the impression i'm calling filter. why am i not?
18:19:36 <jle`> iqubic: so you want to give it a (a -> Writer [a] ()) that "adds the a to the accumulator"
18:20:06 <iqubic> And how would I do that?
18:20:41 <geekosaur> you are calling filter, with a nonsense expression
18:20:46 <jle`> well, 'tell :: w -> Writer w ()'
18:20:53 <jle`> iqubic: so 'tell x' will add x to the accumulator
18:20:54 <sophiag> which expression? the predicate?
18:20:58 <geekosaur> yes
18:21:12 <iqubic> What is the type singnature of the toList function I want to write?
18:21:14 <sophiag> right. that's what i'm trying to solve
18:21:20 <jle`> toList :: Foldable t => t a -> [a]
18:21:32 <sophiag> i've deleted the unwrapJust about 20 minutes ago, fyi
18:21:37 <jle`> but first, write something like accumulateItems :: Foldable t => t a -> Writer [a] ()
18:21:48 <geekosaur> and no, I think I'm done with the discussion because what you have doesn't make sense at all, if you fix the ($) you are still left with it wanting to use a MultiList as a Val
18:21:59 <iqubic> what would accumulateItems do?
18:22:07 <geekosaur> and I'm not particularly interested in analysiung the whole program to figure out if that even makes sense
18:22:18 <jle`> it would traverse through all of the items in the Foldable, tell-ing each of those items into the accumulator
18:22:28 <jle`> and the end result will be a Writer [a] () that contains all of the items in the Foldable
18:22:50 <sophiag> uh...you could have just not answered me in the first place instead of 20 minutes leading up to "i don't care"
18:23:02 <MarcelineVQ> sophiag: What do you have currently?
18:23:08 <jle`> using mapM_ :: Foldable t => (a -> Writer [a] ()) -> t a -> Writer [a] ()
18:23:21 <iqubic> Yes. I got that.
18:23:43 <iqubic> How do I tell a whole bunch of things together?
18:23:44 <jle`> so you can probably write it as accumulateItems = mapM_ (\x -> ?????)
18:23:55 <jle`> well, you can just tell them one-at-a-time
18:23:58 <iqubic> I'll try that.
18:24:04 <jle`> and 'mapM_' is what ties it all together
18:24:11 <sophiag> MarcelineVQ: http://lpaste.net/354300
18:24:22 <jle`> mapM_ "does the thing" for all of the items in the Foldable
18:24:32 <geekosaur> I did care, before you ignored "the types don't work and I can't tell what you are trying to do" to argue about how composition wasn;'t 100% the fix
18:24:39 <jle`> so if "the thing" is "tell the item into the accumulator", then it'll do that for every item in the accumulator
18:25:04 <jle`> *it'll do that for every item in the Foldable
18:25:05 <iqubic> Well, my first attempt has the wrong type signature.
18:25:14 <MarcelineVQ> sophiag: filter takes a predicate that results in Bool, did you perhaps mean to use isJust or something similar after applying getReqConstraint y?
18:25:18 <jle`> feel free to paste it :)
18:25:28 <Sornaensis> @info join
18:25:28 <lambdabot> join
18:25:32 <Sornaensis> @src join
18:25:33 <lambdabot> join x = x >>= id
18:25:33 <iqubic> accumulateItems = mapM_ (\x -> tell x)
18:25:41 <jle`> very close
18:25:49 <iqubic> accumulateItems :: (Foldable t, MonadWriter w m) => t w -> m ()
18:25:49 <jle`> but remember our Writer is acumulating [a]
18:25:59 <jle`> but x is :: a
18:26:03 <sophiag> MarcelineVQ: will that work? it's of type Val -> Maybe Val
18:26:06 <iqubic> Ah, I see what to do.
18:26:10 <jle`> we are accumulating a list, but you're "telling" an item
18:26:50 <jle`> iqubic: also you might be using 'tell' from mtl, instead of 'tell' from transformers
18:27:03 <jle`> tell from mtl generalizes "telling" to many different types, not just Writer
18:27:11 <iqubic> How do I tell which one I am using?
18:27:12 <jle`> so the type signature will be more polymorphic than you might expect
18:27:29 <jle`> did you import Control.Monad.Writer, or Control.Monad.Trans.Writer ?
18:27:36 <jle`> either one works for this exercise, though
18:27:38 <MarcelineVQ> sophiag: that depends how you write it, you can supply the Val to getReqConstraint first and then use isJust or compose the functions. e.g.  ,   (\x -> isJust (getReqConstraint y x))  (isjust . getReqConstraint y)
18:27:49 <jle`> just letting you know why your type signature looks different than what we expected
18:27:57 <iqubic> I am using Control.Monad.Writer
18:28:00 <jle`> it's because 'tell' in mtl is generalized to work for all sorts of different types, not just Writer
18:28:03 <jle`> yeah, that's tell from mtl
18:28:06 <jle`> no big deal though, both will work
18:28:08 <iqubic> tell :: MonadWriter w m => w -> m ()
18:28:11 <sophiag> wait, isJust makes no sense whatsoever to call on a function
18:28:17 <iqubic> That's the version of tell I am using.
18:28:28 <jle`> yeah, both versions work fine.  just explaining the type signature is all
18:28:30 <sophiag> no, there's no case in which isJust makes sense
18:28:37 <MarcelineVQ> I'm not, I'm applying it to the result of fully applying getReqConstraint
18:28:56 <sophiag> so to filter?
18:28:59 <MarcelineVQ> and I suspect what you had originally was equivalent to    (isJust (getReqConstraint y) x
18:29:01 <iqubic> so jle` how do I accumulate a list of item with a writer?
18:29:06 <MarcelineVQ> which would have been that problem
18:29:15 <sophiag> no
18:29:16 <MarcelineVQ> * (isJust (getReqConstraint y)) x
18:29:20 <jle`> iqubic: well, if you have Writer w, then you can accumulate something into it with tell :: w -> Writer w ()
18:29:22 <sophiag> iJust is not fromJust
18:29:31 <jle`> iqubic: so you have Writer [a] here, so you can use tell :: [a] -> Writer [a] ()
18:29:33 <sophiag> isJust would delete the entire function i'm using
18:29:43 <MarcelineVQ> :t isJust
18:29:44 <lambdabot> Maybe a -> Bool
18:29:46 <MarcelineVQ> filter takes a predicate that results in a Bool
18:30:49 <iqubic> I can't seem to get this to work properly. What am I missiing?
18:30:58 <jle`> can you paste what you're trying to do?
18:31:01 <iqubic> jle`: I can't figure out what is wrong.
18:31:05 <jle`> write your (a -> Writer [a] ())
18:31:06 <sophiag> isJust $ Just (\x -> x == 0) is the same as isJust $ Just (\x -> /= 0)
18:31:07 <jle`> using tell
18:31:19 <jle`> (\x -> tell ???)
18:31:19 <sophiag> both return True
18:31:21 <iqubic> let accumulateItems = mapM_ (\[x] -> tell x)
18:31:25 <sophiag> hence the function does not matter
18:31:34 <jle`> iqubic: the function takes single items
18:31:35 <iqubic> but that's wildly wrong
18:31:43 <jle`> maybe you meant accumuateItems = mapM_ (\x -> tell [x])
18:31:50 <iqubic> I did.
18:31:52 <jle`> yes let's go with that
18:31:56 <iqubic> But that's still wrong
18:32:04 <jle`> it is? :o
18:32:14 <Koterpillar> sophiag: but can't you use the result of filter?
18:32:16 <MarcelineVQ> sophiag: Perhaps what I'm suggesing doesn't fit your problem, it's hard to tell, but that doesn't change how filter works so let's step back, how are you intended to provide filter with a Bool?
18:32:23 <MarcelineVQ> *intending
18:32:29 <jle`> iqubic: it should be right
18:32:33 <sophiag> just look at the types
18:32:41 <sophiag> i'm passing it a *function*
18:32:48 <sophiag> the return type is a Maybe Bool
18:32:51 <jle`> > mapM_ (\x -> tell [x]) (S.fromList "hello world")
18:32:53 <lambdabot>  error:
18:32:53 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M427790427465...
18:32:53 <lambdabot>        prevents the constraint ‘(Show (m0 ()))’ from being solved.
18:33:16 <iqubic> See, that's why it's not working.
18:33:24 <Koterpillar> sophiag: I must have missed your paste, mind showing again?
18:33:30 <jle`> > mapM_ (\x -> tell [x]) (S.fromList "hello world") :: Writer [Char] ()
18:33:32 <lambdabot>  WriterT (Identity (()," dehlorw"))
18:33:37 <sophiag> Koterpillar: http://lpaste.net/354300
18:33:49 <sophiag> i suspect i can solve this by combining MultiList and Val somehow
18:33:53 <jle`> iqubic: it does work, you just needed to give it a type signature so it knows what instance of MonadWriter you want heh
18:33:57 <jle`> it's because we're using the generic mtl version
18:34:02 <iqubic> Ah.
18:34:10 <jle`> so 'tell' works polymorphically for a bunch of different types
18:34:14 <jle`> we want Writer, so, yeah
18:34:59 <Koterpillar> sophiag: are you sure you don't want catMaybes or similar?
18:35:05 <iqubic> How do I get GHCi to accept this function as a thing?
18:35:09 <sophiag> i don't know what that is
18:35:13 <Koterpillar> :t catMaybes
18:35:15 <lambdabot> [Maybe a] -> [a]
18:35:18 <Koterpillar> :t mapMaybe
18:35:19 <lambdabot> (a -> Maybe b) -> [a] -> [b]
18:35:31 <jle`> iqubic: accumulateItems :: Foldable t => t a -> Writer [a] (); accumulateItems = mapM_ (\x -> tell [x])
18:35:54 <jle`> and once you have a Writer, you can get the log out of it
18:35:55 <sophiag> but that's not what i want
18:36:01 <jle`> execWriter :: Writer w a -> w
18:36:08 <sophiag> (a -> Maybe a) -> (a -> a)
18:36:08 <jle`> execWriter should really be called extractAccumulator
18:36:11 <jle`> but w/e
18:36:14 <sophiag> it's a *function*
18:36:14 <jle`> what a weird name
18:36:22 <Koterpillar> sophiag: what do you want?
18:36:34 <sophiag> (a -> Maybe a) -> (a -> a)
18:36:43 <sophiag> anyway i can just deal with that after
18:36:48 <sophiag> i need to deal with the other error first
18:36:57 <Koterpillar> that function can't exist
18:37:07 <Koterpillar> what would it return on const Nothing?
18:37:21 <glguy> :t \f x -> fromMaybe x (f x)
18:37:23 <lambdabot> (t -> Maybe t) -> t -> t
18:37:40 <Koterpillar> oh, sorry, I'm wrong... but it's not fully defined by that signature
18:37:43 <jle`> anyway gotta run!
18:37:50 <jle`> good luck!
18:38:49 <Koterpillar> sophiag: this is really one error
18:39:03 <sophiag> glguy: i think that might work...fiddling with it now
18:41:57 <sophiag> i really think i need to link my data types somehow
18:42:04 <MarcelineVQ> "<sophiag> the return type is a Maybe Bool" What has that return type?
18:42:07 <vaibhavsagar> jle`: thanks again for your help yesterday! I got it to work and it was almost exactly how you described it: https://github.com/vaibhavsagar/hakyll-website/blob/b3a6879dcbc43d314a148ffd73271e8672e181d7/site.hs#L96-L103
18:42:18 <sophiag> i tried going one way, but probable makes more sense to include Val in MultiList
18:45:43 <sophiag> i was thinking if i add a data constructor to MultiList like "VList [Val]"
18:50:52 <sophiag> MarcelinVQ: ah, finally got it half right :p
18:54:13 <sophiag> MarcelineVQ, glguy: this is what i was referring to. now i just need to deal with the Maybe. it *seems* like fromMaybe should work, but it's not currently
18:54:18 <sophiag> oops: http://lpaste.net/354300
18:58:03 <sophiag> all i need to do is unwrap the Maybe that returns after applying filter, but that's not working with any of the sensible functions :(
18:59:22 <Koterpillar> sophiag: \val -> val == BoolVal True
18:59:29 <Koterpillar> like that?
19:00:50 <glguy> sophiag: Well, getReqConstraint y :: Val -> Maybe Val. but you need something :: Val -> Bool
19:00:54 <sophiag> well if i compose unwrapJust (function i wrote that's like a better fromJust) with getReqRequest then i get the most sensible error message at least. it wants Val -> Bool and gets Val -> Val. except Val can be a Bool...so not sure how to unwrap *that* part
19:01:06 <sophiag> glguy: exactly
19:01:13 <glguy> sophiag: so write a function with that type
19:01:53 <glguy> Do you not know about case expressions?
19:01:55 <Koterpillar> sophiag: \val -> val == Just (BoolVal True)
19:02:01 <sophiag> they are...they're just wrapped in this Val data type for parsing purposes
19:02:11 <sophiag> glguy: of course
19:03:10 <glguy> If they're "wrapped in this Val data type" , you can get at them with a case expression
19:03:18 <sophiag> maybe i can change unwrapJust to unwrap Val as well...
19:03:33 <sophiag> glguy: yup, that's what i'm trying now
19:06:36 <sophiag> um, doesn't Data.Bool come with a data constructor for Bool?
19:06:42 <Koterpillar> two of them
19:06:53 <sophiag> i'm getting not in scope...
19:07:04 <sophiag> oh, wait
19:07:05 <Koterpillar> they are named (drum roll) True and False
19:07:07 <sophiag> yeah
19:07:08 <sophiag> lol
19:07:33 <sophiag> um, i need to use the type constructor like a data constructor
19:07:47 <Koterpillar> a type constructor?
19:07:55 <sophiag> Bool
19:08:04 <Koterpillar> sophiag: unwrapThatThing (Just (BoolVal True)) = True; unwrapThatThing _ = False
19:08:13 <sophiag> ah ok
19:08:13 <Koterpillar> (also, why?)
19:08:26 <sophiag> to fix this fucking function :p
19:08:41 <sophiag> it's complicated why it's like this...i'm parsing asts recursively
19:08:50 <sophiag> it may be a bit hacky and i'll refactor, not sure
19:09:01 <Koterpillar> I mean in particular, why did you need the type constructor?
19:09:59 <sophiag> i don't. i'm doing the obvious thing you just told me to
19:10:13 <sophiag> and fixed...
19:10:24 <sophiag> but i didn't even get to asking the serious question :p
19:11:06 <sophiag> ok, so here's the working function: http://lpaste.net/354300
19:11:45 <sophiag> it seems that does actually match every element in each list with every element in the other, right? although perhaps poorly from an efficiency standpoint? 
19:12:07 <sophiag> because that's what i need, not just by index like map
19:12:20 <sophiag> i feel like this branching recursion is a hacky way to do it tho
19:14:11 <sophiag> Koterpillar: does that make sense?
19:15:51 <Koterpillar> sophiag: sorry, I'm missing the larger context. What I answered before didn't require any actual understanding of your types, I'm reading them now
19:16:41 <sophiag> oh, what i'm asking now doesn't require you to think about that
19:17:10 <sophiag> it's just i need to match every element in both lists against one another
19:17:33 <sophiag> that's why i'm recursing twice, but not sure if there's a better way. it seems kind of hacky and inefficient
19:18:03 <Koterpillar> I can see that your recursion isn't symmetric
19:18:24 <sophiag> right
19:19:16 <Koterpillar> and I'm a bit worried that you're calling eval xs [y] from eval xs (y:ys)
19:19:40 <sophiag> am i?
19:19:59 <Koterpillar> I'm ignoring the filter statement
19:20:04 <sophiag> it's from eval (x:xs) (y:ys)
19:20:27 <Koterpillar> eval a@(x:xs) r@(y:ys) = if ... then do ... eval xs [y]; eval [x] ys
19:20:36 <sophiag> whether or not there's a match it tests that first element against every one in the other list
19:20:38 <sophiag> but for both
19:20:38 <Koterpillar> note that [y] is y:[]
19:21:00 <sophiag> hmm?
19:21:20 <sophiag> it does look weird how i had to wrap the heads in lists like that
19:21:24 <Koterpillar> oh, sorry, you are recursing
19:21:26 <Koterpillar> ignore that
19:21:27 <Koterpillar> afk
19:23:30 <sophiag> i still have an error i haven't worked out so i could just focus on solving that and put this off until i've actually tested it
19:27:55 <sophiag> here's what i'm dealing with: http://lpaste.net/354311. it's pretty obvious why there's an error trying to call eval there given the type, but i'm unsure whether this is even a sound way to structure it... regardless i need to not pass the _whole_ ast to the state functions, but just the lambda and list types and also parse out tags if they're included to call different constructors
19:27:55 <sophiag>  
19:28:30 <sophiag> err, actually they should select for those types for me
19:28:51 <sophiag> i think parsing the tags is more complicated since they have the same types as what i'm using for the case analysis in general
19:29:28 <sophiag> i probably need to add them before the existing ones and just use an additional Var with a variable
19:29:46 <sophiag> i think i can handle that, but unsure how to fit eval in there :/
19:30:41 <sophiag> OR i use totally separate versions of evalString for each and the choice operator...
19:40:35 <sophiag> ok, what's the deal with the term "Squiggolers?"
19:42:58 <sveit> i upgraded LTS versions in my global stack config, and have some local projects listed in that global config as well. Now i can't get them to load into ghci. When I run "stack ghci --package LOCALPACKAGE" the output is some configure/build steps but then i can't load the relevant modules
19:43:07 <sveit> is there some cache I need to delete?
19:48:03 <glguy> sveit: I don't know if there's a stack command for it, but when stack breaks I wipe out the ~/.stack/snapshots/ 
19:49:09 <sveit> glguy: i was hoping to avoid that :)
19:49:45 <glguy> Oh, I misunderstood your problem
19:50:20 <glguy> I misread it as upgrading your OS somehow (I just installed Ubuntu LTS Desktop in a VM today)
20:03:21 <vaibhavsagar> sveit: how do you make your local projects accessible globally?
20:13:48 <Axman6> sveit: #haskell-stack might be more helpful
20:14:07 <Axman6> (though with longer response time usually)
20:44:26 <sveit> vaibhavsagar: you put them as packages in the global stack.yaml
20:44:48 <sveit> on windows the file is in AppData/Roaming/stack/global-project
21:36:08 <arctictern> Is there a way to define an Eq instance for a function? E.g. (this is from the Haskell Programming book)
21:36:08 <arctictern> newtype Combine a b = Combine (a -> b)
21:36:08 <arctictern> instance Eq (Combine a b) where
21:36:09 <arctictern>   (==) (Combine f) (Combine g) = undefined
21:36:10 <arctictern> I want to somehow say that f and g always give the same result for any input. But that seems impossible to express, since that would require an infinite amount of checking(?)
21:37:08 <geekosaur> only possible when inputs and outputs are of bounded types (there's even a set of packages for this on hackage: universe and its dependents)
21:38:55 <arctictern> In that case, is there a way to check equality besides listing out every possible input?
21:39:39 <Koterpillar> you get to decide what equality means
21:40:12 <Koterpillar> but to satisfy the laws and get anything meaningful out of it... you'll be limited with above
21:40:19 <arctictern> Equality in the sense that: a == b => f a == f b 
21:40:38 <Koterpillar> then you have to check that for all inputs
21:40:39 <arctictern> Yea I guess it's impossible to check that
21:40:45 <arctictern> (if infinite input) 
21:40:52 <Koterpillar> you can't do anything else with f other than applying it
21:41:23 <arctictern> gotcha
21:41:24 <arctictern> thanks
21:41:30 <EvanR> are cis 194 notes still around?
21:43:07 <EvanR> arctictern: you could express this with dependent types
21:43:53 <EvanR> (isnt a = b => f a = f b clear from f being a function)
21:44:15 <EvanR> @where cis 194
21:44:15 <lambdabot> I know nothing about cis.
21:44:22 <EvanR> o_O
21:44:42 <arctictern> oh sorry mean g b 
21:45:08 <EvanR> you mean for all x . f x = g x
21:45:13 <Koterpillar> there's an implied "for all a"
21:45:20 <arctictern> i'm not familiar with dependent types. is there a high level explanation you can give, or should I just read up 
21:46:47 <Koterpillar> I can take a guess: if you limit the type of functions, you'll be able to reduce the domain of a
21:47:08 <Koterpillar> for example, instead of forall a b. a -> b, require forall a b. Bounded a => a -> b
21:47:44 <Koterpillar> sorry, instead of concrete a and b
21:50:49 <geekosaur> http://hackage.haskell.org/package/universe-reverse-instances-1.0/docs/Data-Universe-Instances-Eq.html
21:51:48 <_sras_> Is there a way to limit the length of a String field in the target type, in a FromJSON instance?
21:52:10 <geekosaur> @where cis194
21:52:10 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
21:52:58 <vaibhavsagar> _sras_: you can `take len decoded` in a manually written instance
21:55:45 <_sras_> vaibhavsagar: But it wont result in a parse failure, right?
21:55:52 <arctictern> geekosaur thanks. In context of the problem I was being a bit stupid, it suffices to use quickcheck to generate random inputs
21:58:01 <glguy> testing random inputs isn't sufficient to write a reasonable Eq instance for functions
21:58:19 <vaibhavsagar> _sras_: it shouldn't, I think `take` is total
21:58:22 <ezyang> "unless they're polynomials!" 
21:58:34 <vaibhavsagar> unless your input is not a string
21:58:47 <vaibhavsagar> in which case you'd get a parse failure anyway
21:59:21 <vaibhavsagar> so using `take` shouldn't cause a parse failure when no parse failure would have occurred otherwise
22:00:13 <_sras_> vaibhavsagar: What if I do a check like `(length $ take maxLength+1 input) == maxLength + 1` and throw an error if it is True?
22:01:06 <vaibhavsagar> _sras_: you can `fail` with an error in that case if you want
22:01:19 <vaibhavsagar> can you tell me a bit more about the use case?
22:02:01 <jle`> is there any library that lets me generate Num instances using Generics
22:02:22 <_sras_> vaibhavsagar: I am getting this object from a web request, and I want the parsing of this object to break if this particular string is larger than a certain length..
22:02:59 <glguy> jle`: I don't know, but I can help if you start implementing it yourself
22:03:21 <glguy> I'm guessing you intend to support product types where all the fields themselves have Num instances
22:03:30 <jle`> yes that is basically it
22:03:41 <jle`> i have a lot of those and it's been getting tiring implementing Num/Fractional/Floating for all of them
22:04:05 <jle`> i see this package https://hackage.haskell.org/package/generic-deriving but it doesn't even have Num
22:04:12 <Koterpillar> it's not hard to write
22:04:14 <glguy> You'll just need 4 instances, M1, :*:, K1, U1
22:04:43 <Koterpillar> glguy: do you know why are they named like that?
22:04:48 <jle`> Koterpillar: it's just that they are boilerplate, that's all
22:04:51 <jle`> and i have several dozen
22:04:57 <Koterpillar> jle`: I meant the Generic instances
22:05:02 <jle`> oh yeah, yes, it's not that hard
22:05:03 <glguy> Metadata, * for product, K for constant, U for unit
22:05:09 <jle`> which is why i'm surprised that it's not done yet
22:05:20 <Koterpillar> glguy: "Metadata" is _already_ better than M1
22:05:40 <Koterpillar> I know what they mean, and I've read the paper (looks beautiful, too), but it's a barrier
22:06:02 <jle`> it looks like the names of the types in in GHC.Generics were designed to be especially opaque
22:06:06 <glguy> The hard part is just learning to think in those terms, the words are the easy part
22:06:11 <jle`> despite not being that difficult
22:06:20 <glguy> the instances get long enough with 2 character names
22:06:30 <EvanR> i noticed for slick implementations like stuff, they like to use single letter ctors where possible, to make typing the implementation code easier
22:06:31 <Koterpillar> glguy: what about Rec0?
22:06:57 <Koterpillar> glguy: why is Rec0 a type synonym through K1?
22:07:15 <glguy> They used to have a special case for recursive occurences
22:07:28 <Koterpillar> in the library?
22:07:39 <Koterpillar> or just in the paper?
22:07:39 <vaibhavsagar> _sras_: yes, I think that will work
22:07:56 <glguy> In the library, but now there's just one version of K1 generated
22:07:59 <jle`> im going to make the package i guess
22:08:05 <glguy> It lingers for backward compatibility
22:08:10 <Koterpillar> heh, ok.
22:08:13 <jle`> i spent a while searching through hackage for 'numeric' and 'generics' but didn't find anything
22:08:54 <Koterpillar> jle`: to be sure, I searched for GNum and Num' but they look unrelated
22:08:59 <glguy> jle`: Be a pro, generate the instances using generics
22:09:14 <glguy> all the method definitions are going to be boring mechanical!
22:09:16 <vaibhavsagar> _sras_: maybe this section of Artyom's Aeson tutorial will help: https://artyom.me/aeson#more-interesting-choices
22:09:37 <jle`> glguy: yea,h i'm going to make a package with them
22:09:38 <glguy> Oh, nevermind, just make 3 class methods
22:09:51 <glguy> one for lifting binary operators, one for unary, one for nullary perhaps
22:10:25 <jle`> is the best way to do this to make a GNum typeclass
22:10:38 <jle`> is that just to avoid having a naked constraint on Rep
22:11:03 <glguy> Yeah, make a new typeclass. the methods will be different from Num anyway
22:11:32 <jle`> what methods should i expect it to have?
22:11:36 <EvanR> generate Generic instances using generics?
22:11:39 <glguy> liftOp2 :: (forall a. Num a => a -> a -> a) -> f p -> f p -> f p
22:11:40 <Koterpillar> jle`: mirror Num
22:11:42 <jle`> ah.
22:11:45 <Koterpillar> ooh
22:11:54 <jle`> that's probably better.
22:11:54 <Koterpillar> glguy: nice
22:12:03 <glguy> jle`: or make Num a parameter of your class
22:12:05 <jle`> then i could write instances for Floating/Fractional/Num as well
22:12:19 <jle`> using only that one typeclass
22:12:22 <glguy> and then you can reuse it for Floating, Fractional, etc
22:12:31 <jle`> ...i could even derive Monoid too
22:12:52 <jle`> or any other typeclass where all of the functions are of the form ... -> a
22:13:24 <jle`> but i think Num/Fractional/Floating/Monoid/Semigroup are the only ones in base
22:14:04 <jle`> but now is the hardest part...
22:14:09 <jle`> picking a name for the package
22:14:26 <vaibhavsagar> acme-number?
22:14:32 <Koterpillar> genumeric
22:14:41 <jle`> generics-lift
22:14:52 <jle`> then people can use it to implement their own typeclasses too
22:15:01 <Koterpillar> why not make a PR for an existing one?
22:15:02 <jle`> since this pattern can be used to easily implement Num/Fractional/Floating/Monoid/Semigroup
22:15:07 <jle`> what existing one?
22:15:33 <Koterpillar> generic-deriving or whatever you found
22:16:22 <glguy> Hmm, fromIntegral is going to be hard to fit neatly into the generic deriving class
22:16:46 <jle`> fromIntegral would just be lift0
22:17:15 <glguy> what type would that have?
22:17:52 <glguy> Oh, I guess we'll be able to do:   fromIntegral x = lift0 (fromIntegral x)
22:18:13 <glguy> I had started doubting myself :)
22:24:15 <jle`> not sure if should make it as a PR or as a new package
22:24:30 <glguy> step 1, try it out
22:24:41 <jle`> good call
22:25:11 <f-a> hello, in my cabal file (for an executable) I put a bunch of "other modules". Do I need them? Or can I erase them safely? (same for tests)
22:25:59 <jle`> f-a: do you mean do you need to put those modules there?
22:26:03 <jle`> or are you asking if you need those modules at all
22:26:11 <f-a> first one, jle` 
22:26:25 <jle`> it's good practice to list them if you use them, i believe
22:26:29 <jle`> i think cabal warns you if you don't
22:26:30 <kadoban> f-a: Generally you can't erase them safely, assuming they're used. AFAIK, every module you have should be in exposed-modules or other-modules for some component
22:26:39 <f-a> okie dokie
22:27:14 <kadoban> I believe if you do it wrong you end up with wacky linker errors in some pattern that I've yet not been able to decipher.
22:29:56 <f-a> also what happened to hackage download numbers
22:30:01 <f-a> did we finally make it big :P
22:32:16 <lpaste> glguy pasted “some generics” at http://lpaste.net/354316
22:32:48 <glguy> jle`: I want to figure out how make that generic so it works over operations of arbitrary arity next...
22:33:15 <jle`> my gut says that that isn't possible
22:33:42 <jle`> but i won't stop you
22:33:57 <dmj`> "arbitrarity"
22:35:19 <dmj`> Maybe something with ConstraintKinds and type families
22:36:55 <glguy> But we've got so many extensions now, everything should be possible!
22:37:10 <jle`> hm
22:37:18 <jle`> i suppose it might be possible with some Printf-type magic
22:37:31 <glguy> I suspect we'll need more magic than Printf
22:38:26 <Koterpillar> what if you curry it all?
22:38:56 <Koterpillar> instead of a -> a -> a -> a, use a type-level list as the only argument: (a, (a, (a, ()))) -> a
22:39:16 <jle`> hm.  yeah you can write a generic curry using HList
22:42:38 <jle`> actually it would definitely be nice to have a version with arbitrary arity
22:43:50 <dmj`> @package poly-arity
22:43:50 <lambdabot> http://hackage.haskell.org/package/poly-arity
22:43:58 <dmj`> think athan was doing something similar a while ago
22:44:33 <EvanR> lisp eat your heart out
22:44:35 <glguy> yeah, that's basically what I'm working with now, but with a Nat instead of a list
22:48:06 <mikeplus64> i have a complicated quickcheck property where two of the generated parameters depend on another -- is there a nice way to get them included in the output? i'd rather not resert to just 'print'
22:48:21 <glguy> I'm running into cases I've told people on this channel that they can't avoid :)
22:50:10 <mikeplus64> so i have something like: testProperty "asdf" (\dep -> do x <- genThing dep; y <- genThing (f x dep); return (f x (f y dep) === f (commute x y) dep)
22:50:27 <EvanR> https://pbs.twimg.com/media/C8QejJ1VoAAQgDE.jpg
22:51:41 <mikeplus64> where i'd like 'x' and 'y' to be included in the output somehow without just print'ing them (because the output might get very confusing for a large test suite ran in parallel ... maybe tasty is magic though)
22:52:36 <mikeplus64> oh, durr, forAll. crisis averted
22:55:38 <jle`> EvanR: love it
22:57:03 <dmj`> EvanR: so much truth in that
22:59:42 <Squarism> anyone know if theres any work done on creating a platform agnostic runtime for haskell? Like what is available for java? Or is that concept dated now that docker and likes are maturing?
23:00:44 <EvanR> jle`: dmj` on the twitter post i got this from, the bottom 4th is cut off
23:00:55 <EvanR> i only realized the punchline after opening in a new tab
23:01:18 <EvanR> i was like... what and then i got it
23:01:27 <MarcelineVQ> :>
23:01:40 <EvanR> down with transformers!
23:01:45 <dmj`> EvanR: was it from Cale? :)
23:02:45 <Koterpillar> Squarism: there's eta
23:03:11 <EvanR> dmj`: data Matt where
23:04:39 <Squarism> Koterpillar, i knew about that. I thought there would be lots of compromises reusing jvm - not that i know about the details.
23:05:44 <jle`> glguy: it all works, nice https://github.com/mstksg/generics-lift/blob/master/src/GHC/Generics/Numeric.hs
23:05:48 <jle`> ty for the help
23:06:14 <dmj`> EvanR: related: https://pbs.twimg.com/media/CypY7B1W8AAvqwl.jpg
23:06:25 <jle`> now i'm going to spend my time figuring out how to generalize the arity, but for no practical benefit
23:06:33 <jle`> just another day in haskell
23:06:50 <glguy> jle`: :)
23:06:52 <EvanR> hahahhahhaa
23:07:13 <cocreature> jle`: you just need to claim you’re doing it for science, then it seems really important
23:08:37 <jle`> how many hours have i sunk for 'science'
23:09:00 <jle`> i suppose i could harvest imaginary internet points if i distill it into a blog post
23:34:56 <abhiroop> has anybody encountered this error: "Haskell process command errored with: (error "Unexpected response from haskell process.")" while working in haskell mode in emacs
23:52:14 <Gurkenglas_> abhiroop, http://haskell-channel-logs.blogspot.de/2017/01/haskell-channel-featuring-zennist.html
23:53:10 <abhiroop> I saw this
23:53:20 <abhiroop> It says there might be an issue with the cabal file
23:53:29 <abhiroop> My cabal file looks like this: https://github.com/rahulmutt/codec-jvm/blob/master/codec-jvm.cabal
23:53:41 <abhiroop> Does anybody see any issue in this?
23:54:34 <Gurkenglas_> *summons ertes*
23:59:03 <jle`> why is Floating so huge
