00:01:38 <mjora7> Should $ be used in place of parens whenever possible?
00:01:44 <mjora7> Or is that frowned upon.
00:02:42 <liste> mjora7: parens are sometimes frowned upon, we're distancing ourselves from lisp ;)
00:02:49 <liste> but use whichever is most readable
00:03:16 <liste> usually haskellers consider "a . b . c . d $ e" more readable than "(a (b (c (d e))))"
00:03:49 <mjora7> Ok, thanks!
00:05:09 <liste> it's curious how two pieces of code with so different syntactical mechanism (function application vs lists) end up looking similar
00:06:08 <glguy> mjora7: no, you don't need to about parentheses whenever possible
00:06:24 <glguy> avoid*
01:01:49 <johnw> next to ask: a . b . c . d $ e, or a $ b $ c $ d e ?
01:07:56 <evtl> johnw: The former, IMHO
01:10:21 <LiaoTao> johnw: Whatever minimizes the clutter!
01:10:25 <LiaoTao> :D
01:11:42 <geekosaur> context matters too: in xmonad layout hooks we're prone to use ($) to separate layout modifiers and (.) when needed within them
02:35:35 <Profpatsch> fast and loose matching on constructors, how to?
02:35:47 <johnw> hmm?
02:35:56 <Profpatsch> data Foo = A String | B Something | C … | D
02:36:17 <johnw> you want to pick "just B" if it's there?
02:36:19 <JuanDaugherty> hackage is down?
02:36:24 <Profpatsch> parseFooToString :: Foo -> Maybe String
02:36:38 <Profpatsch> parseFooToString (A s) = s
02:36:41 <Profpatsch> *Just s
02:36:55 <Profpatsch> parseFooToString _ = Nothing
02:37:01 <johnw> makePrisms ''Foo; parseFooToString = preview _A
02:37:03 <Profpatsch> parseFooToSomething …
02:37:15 <Profpatsch> Hm.
02:37:22 <johnw> the lens library's prisms are really the way to do just what you want here
02:37:45 <Profpatsch> I see …
02:37:49 <johnw> and when you start mixing and matching lenses with prisms in deep structure, it's pure magic
02:38:39 <johnw> I have a project I was working on today that uses lenses in that way, heavily, also using the map/array accessors and state manipulators, and it made some code *so* easy to write that would have been an absolute nightmare otherwise
02:38:43 <Profpatsch> johnw: That’s basically also what you do when you want to transform NExprs in hnix
02:38:49 <johnw> yep
02:38:58 <johnw> do we use lens yet in hnix?  we should
02:39:10 <Profpatsch> Probably, yes.
02:39:27 <Profpatsch> Better: Define Prisms without dependending on lens
02:39:47 <johnw> in one module today I had this:
02:39:49 <johnw> _2 . at name . non (kind, M.empty) . _2 . at component . non M.empty . at meta ?= value
02:40:03 <johnw> just thinking about the Haskell I'd have to write to mimick this makes my head ache
02:40:30 <johnw> but with lens, I type it out just the way I'm thinking of the verb
02:40:38 <JuanDaugherty> (no hackage.org)
02:40:40 <srhb> I did not know about hnix. Is it being used for something in particular?
02:40:49 <johnw> srhb: some people tell me they use it every day
02:41:02 <srhb> johnw: I wonder what for. :)
02:41:08 <johnw> srhb: mostly, I think, for serious surgery on Nix files, or dynamically generating complex expressions
02:41:12 * srhb nods
02:41:16 <johnw> that's about all it can do right now
02:41:22 <johnw> shlevy is working on a Haskell version of the nix store
02:41:23 <srhb> Interesting! :)
02:41:30 <johnw> once we have that, we're inches away from an actual operating Nix
02:41:36 <srhb> That would be so cool.
02:41:42 <johnw> just need an evaluator to construct the derivation scripts
02:41:56 <srhb> I wonder if there's some not-too-complex corner I could bite at
02:42:08 <johnw> srhb: sure, there's plenty I'd say
02:42:16 <johnw> the parser need optimization
02:42:24 <johnw> there's notes in the GitHub issue on it about the problem
02:42:31 <srhb> johnw: I'll have a gander. Thank you :)
02:42:39 <johnw> and I wrote parsec-free to allow in depth analysis of what parsec is doing too much of
02:42:47 <johnw> thanks!
02:44:11 <Profpatsch> johnw: I’m not exactly in the lens flow (yet).
02:44:31 <johnw> Profpatsch: https://www.reddit.com/r/haskell/comments/66xqro/putting_lenses_to_work_talk_and_slides/
02:44:55 <Profpatsch> Especially with Traversals it’s kind of easy to do too loose matching I think.
02:45:07 <johnw> i don't use traversals nearly as much
02:45:13 <Profpatsch> Where you get [] and have no idea at which part of the chain it failed
02:45:18 <johnw> or least, I use the "I only want one thing" type of them
02:45:22 <Profpatsch> Maybe the same with deep prisms.
02:45:35 <johnw> you can guard your prisms accessors using "failing"
02:45:49 <johnw> [] ^?! failing (ix 1) (error "This list be too tiny")
02:46:03 <johnw> I do this a lot to get better stack traces of where my assumptions failed
03:03:42 <LAZAR> Does anyone know if / is overloaded to work with any kind of Num?
03:03:51 <Myrl-saki> Flycheck, which uses stack if it's installed is faster than stack build. Does this have something to do with `stack ghc` being faster than `stack build`?
03:03:51 <srhb> Does Hackage insert some kind of default bounds if the cabal file is missing them?
03:03:52 <johnw> :t (/)
03:03:54 <lambdabot> Fractional a => a -> a -> a
03:03:58 <LAZAR> Like in mean :: (Num a) => [a] -> Double; mean xs = (sum xs) / (length xs)
03:04:05 <johnw> srhb: not that I know of
03:04:05 <Myrl-saki> LAZAR: Nope.
03:04:13 <Myrl-saki> :t genericSum
03:04:13 <bennofs> srhb: i don't think it doe
03:04:15 <lambdabot> error: Variable not in scope: genericSum
03:04:18 <Myrl-saki> Oh no.
03:04:21 <Myrl-saki> :t genericLength
03:04:22 <lambdabot> Num i => [a] -> i
03:04:56 <srhb> johnw, bennofs: Hmm, okay, thanks.
03:05:00 <LAZAR> Hmm im trying to calculate a mean function so i want to divide the sum of any number array by its length
03:05:17 <Myrl-saki> LAZAR: You can't.
03:05:26 <LAZAR> Amazing
03:05:30 <Myrl-saki> LAZAR: Mmm.
03:05:36 <Myrl-saki> :t toFractional
03:05:38 <lambdabot> error:
03:05:38 <lambdabot>     • Variable not in scope: toFractional
03:05:39 <lambdabot>     • Perhaps you meant ‘toRational’ (imported from Prelude)
03:05:44 <bennofs> :t realToFrac
03:05:46 <lambdabot> (Fractional b, Real a) => a -> b
03:05:55 <Myrl-saki> > realToFrac 1
03:05:57 <lambdabot>  1.0
03:06:02 <Myrl-saki> > realToFrac (1 :: Int)
03:06:04 <lambdabot>  1.0
03:06:12 <bennofs> LAZAR: length returns an Int, so you need to convert that to a float with realToFrac
03:06:13 <Myrl-saki> bennofs: How does `Real` contrast with `Num`?
03:06:32 <bennofs> > let mean xs = xs / realToFrac (length xs) -- LAZAR
03:06:35 <lambdabot>  <no location info>: error:
03:06:36 <lambdabot>      not an expression: ‘let mean xs = xs / realToFrac (length xs) -- LAZAR’
03:06:39 <bennofs> > let mean xs = xs / realToFrac (length xs) in mean [1,2,3] -- LAZAR
03:06:43 <lambdabot>  error:
03:06:43 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M575956214089...
03:06:43 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
03:06:44 <Myrl-saki> bennofs: That still wouldn't work if xs is not Fractional.
03:06:52 <LAZAR> Indeed
03:07:01 <bennofs> LAZAR: then realToFrac sum xs as well
03:07:10 <LAZAR> So basically i cant generify it to Nums just to Fractional
03:07:15 <Myrl-saki> And realToFrac . length == genericLength, ish.
03:07:44 <LAZAR> Oh the boilerplate
03:08:00 <Myrl-saki> :t \xs -> realToFrac (sum xs) / genericLength xs
03:08:01 <lambdabot> (Real a1, Fractional a) => [a1] -> a
03:08:16 <Myrl-saki> LAZAR: If you're fine with that, at least.
03:08:48 <Myrl-saki> LAZAR: Turns out that I normally don't have a generalized mean function.
03:09:07 <Myrl-saki> lambdabot: And if I do, it's `Fractional a => [a] -> a`
03:09:29 <LAZAR> its just weird how generics are so cumbersome in haskell sometimes
03:09:57 <bennofs> LAZAR: the Num hierarchy in haskell sucks
03:10:01 <Myrl-saki> :t (+)
03:10:03 <lambdabot> Num a => a -> a -> a
03:10:13 <Myrl-saki> ^ messed me up when I was starting.
03:11:44 <LAZAR> bennofs: i think its beacuse Num includes some esoteric stuff which does not support regular arithmetics defined on real numbers
03:12:09 <torstein> what does this mean: newtype s >> a = Named a
03:12:23 <LAZAR> It would be nice to have the classical math hierarchy: Complex -> Real -> Fractional -> Integer -> Natural
03:13:06 <srhb> LAZAR: There are alternative numerical towers in the wild, I think.
03:16:15 <LAZAR> This works for Fractionals: mean :: (Fractional a) => [a] -> a mean xs = (sum xs) / (realToFrac (length xs))
03:17:19 <srhb> LAZAR: Side note, you're traversing xs twice there. You may want a different definition unless this is just example code :)
03:17:58 <LAZAR> srhb: Well dont i have to traverse it twice?
03:18:12 <srhb> LAZAR: No, you can do a fold where you calculate the running sum and running length
03:18:36 <LAZAR> oh well im doing the exercises from realworldhaskell and folds havent been introduced yet
03:18:43 <srhb> LAZAR: OK, great :)
03:18:55 <srhb> LAZAR: Just wanted to point it out.
03:57:29 <torstein> is there any difference between: data Sing :: Color -> * where SRed :: Sing Red ;; and this: data Sing (c :: Color) where SRed :: Sing Red
04:11:13 <cocreature> torstein: afaik there is no difference
04:20:25 <lpaste> Ulrar pasted “map” at http://lpaste.net/355081
04:20:47 <Ulrar> Hi, I'm having some trouble with _mapM, and I'm not sure what I'm doing wrong
04:21:15 <Ulrar> sendMsg is from SimpleIRC, if that matters. It does perform IO
04:23:41 <lyxia> you misspellt mapM_
04:25:01 <lyxia> Ulrar: identifiers with a leading underscore which are not in scope are interpreted as "holes" for which GHC prints the expected type.
04:25:04 <Ulrar> Ah, you are right ..
04:25:10 <Ulrar> That's good to know
04:25:14 <Ulrar> Thanks !
04:25:47 <lyxia> if you're not expecting it, it's equivalent to "variable not in scope"
04:27:28 <Ulrar> That make sense
04:27:51 <Ulrar> Don't know why I was thinking _ in front, guess it looks like _ <-
04:55:46 <LAZAR> How doI deconstruct this? data Tree a = Node a (Tree a) (Tree a)             | Empty               deriving (Show), like height Node x ltree rtree does not work
04:56:20 <dysfun> put parens around (Node x ltree)
04:57:14 <LAZAR> dysfun: lol thanks
05:02:57 <Alex__> Is it possible to take the head of a type?
05:03:14 <cocreature> Alex__: what is that supposed to mean?
05:05:29 <Alex__> cocreature: https://pastebin.com/fNZW8vbw
05:06:20 <cocreature> Alex__: how is Graph defined
05:06:46 <Alex__> cocreature: Woops, sorry. I'll add that, 1 sec
05:07:12 <cocreature> also the complete error message including the part of the code that GHC thinks is responsible is often useful
05:07:48 <Alex__> cocreature: https://pastebin.com/VN4pJPeU
05:10:05 <cocreature> Alex__: it’s still not entirely clear to me what you are trying to do. your function is called “addVertex” suggesting that it should add a vertex to the graph but it returns a VertexID instead of a new graph
05:10:49 <dysfun> what can i use to parse dates and times according to format strings?
05:11:06 <cocreature> :t parseTimeM
05:11:08 <lambdabot> error: Variable not in scope: parseTimeM
05:11:23 <cocreature> gnah, I’m really bad at guessing what lambdabot has in scope these days
05:11:31 <cocreature> dysfun: anyway, that’s probably what you’re looking for
05:11:39 <dysfun> thanks
05:11:44 <Alex__> cocreature: Yeah, I had it so it returned a new graph at first but I want it to return the id of the vertex added to the graph
05:12:53 <cocreature> Alex__: you are aware that variables in Haskell are immutable, right? so you can’t modify the existing graph, you have to return a new graph
05:14:55 <__Myst__> Is the result of Data.Map.toList guaranteed to be sorted?
05:14:59 <cocreature> Alex__: you can return a new vertex id _and_ the modified graph by returning a tuple
05:16:23 <Gurkenglas> Okay so I installed emacs and i went through like 40% of the tutorial before getting bored and then i somehow put the thing at the top of http://commercialhaskell.github.io/intero/#install into what i hope is an init file and at some point I ran stack new intero-demo and I opened its app directory in emacs and clicked on Main.hs and now how do I get it to show the error as in the gif in the previously linked page 
05:16:23 <Gurkenglas> instead of https://gyazo.com/72d306af4b11c7bc36c12466aabfdcf6 ?
05:16:26 <cocreature> __Myst__: I think it is currently the case but the API doesn’t guarantee it. if you care about that use “toAscList” or “toDescList”
05:16:55 <cocreature> yep currently toList = toAscList
05:17:17 <__Myst__> cocreature: thank you very much
05:17:44 <cocreature> but if you use toAscList it’s also easier to see that you depend on the output being sorted, so there is little reason to not use it :)
05:22:57 <Alex__> cocreature: Hmm, okay. But then I still have the problem with how I should go about returning the vertex id
05:25:09 <cocreature> Alex__: right, so let’s first fix the type signature. you want to return the modified graph and the VertexID so the type signature should be addVertex :: Graph a -> a -> (Graph a, VertexID)
05:26:50 <Alex__> cocreature: Yeah, that I got :)
05:27:28 <chrissound> Hello!  Does anyone know if any existing module for this sort of thing exists: a way to navigate to the (nth) window? (a single keybinding)
05:27:57 <cocreature> Alex__: you probably want something like that http://lpaste.net/355082
05:32:56 <Alex__> cocreature: Okay thanks :) I'll see if it works
05:40:37 <cocreature> does haddock support documenting non-record fields of a constructor?
05:40:50 <cocreature> I know I can document the complete constructor but I’d like to document a single field
05:41:23 <jophish> cocreature: you could try documenting the arguments in a constructor in a GADT
05:41:32 <jophish> I'm not confident that that'll work though
05:42:14 <cocreature> jophish: also I don’t really want to switch to GADT syntax just to be able to annotate it :)
05:52:47 <jophish> cocreature: you could use something like this: https://gist.github.com/dc7656578cb16d0d565cc4d4968192c3
05:53:10 <jophish> Note that the ::: operator is already defined in CLaSH.NamedTypes
05:54:00 <jophish> We use that quite a lot to annotate function arguments, but it works just as well for ADTs
05:54:06 <cocreature> jophish: tbh I’m not really looking for workarounds here. I was mostly wondering if I’m too stupid for haddock or if haddock really doesn’t support this. otherwise I’ll just document the constructor instead of the individual arguments :)
05:54:44 <jophish> cocreature: gotcha.
05:54:53 <jophish> as far as I know haddock doesn't support this
05:55:00 <cocreature> alright, thanks :)
05:55:31 <jophish> https://github.com/haskell/haddock/issues/95
05:57:02 <bennofs> cocreature: you can also give the arguments names
05:57:16 <bennofs> cocreature: like data A = A { foo :: Int, bar :: String }
05:57:25 <cocreature> bennofs: right, that’s the record syntax I mentioned
05:57:43 <bennofs> cocreature: oh I missed the non-record part :)
05:57:52 <jophish> That's less nice when one has a sum type as nobody wants partial functions around
05:57:56 <cocreature> exactly
06:17:23 <reuben364> In the pipes library, is one of these types more powerful: (Producer a m r -> Producer b m r) or (Pipe a b m r)?
06:29:03 <lyxia> You can map the second one to the first one, but the other way seems difficult.
06:29:37 <Myrl-saki> What has `type Foo a = (a,a)` ?
06:29:38 <Gurkenglas> "type Producer b = Proxy X () () b", "type Pipe a b = Proxy () a () b". They don't unify. Did you mean the second one to be "Pipe a b m r -> Pipe a b m r"?
06:29:39 <Myrl-saki> And so on?
06:30:08 <Gurkenglas> Myrl-saki, give me some more "and so on", not sure which direction you wanna generalize
06:30:14 <Myrl-saki> (a,a,a) ...
06:30:30 <Myrl-saki> Think V2, V3, but as a type synonym.
06:30:47 <Gurkenglas> Why do you want that as a type synonym?
06:31:10 <Myrl-saki> I mean, we have V{2,3,*}
06:32:05 <reuben364> Gurkenglas: Sorry, I didn't mean in the sense of more specific. I mean in terms of obtaining one from the other.
06:32:06 <Myrl-saki> But I'm not working withu vectors.
06:32:12 <Myrl-saki> I'm working with repeating elements of fixed sizes.
06:35:20 <Gurkenglas> Control.Lens.Each gives you something to work with tuples of equally typed elements. Why do you want a type synonym here?
06:35:41 <Gurkenglas> One reason to not prefer (a,a) is that fmap goes only over the right half
06:36:10 <Gurkenglas> I'm having trouble setting up intero, anyone wanna hop on teamviewer and help?
06:37:49 <lyxia> reuben364: The other way around (left to right) seems to assume that the argument Producer a m r is used linearly.
06:43:09 <reuben364> lyxia: I don't understand what you said. Is it that usage of Producers should be linear?
06:47:11 <lyxia> reuben364: I'm just saying that functions (Producer a m r -> Producer b m r) that do not use their argument linearly cannot be represented as a Pipe a b m r.
06:47:36 <reuben364> Ah
06:49:47 <reuben364> Thanks
06:51:41 <reptar_> how can i specify that this tree is of type Tree Int? http://lpaste.net/8845755308144852992
06:54:02 <Gurkenglas> reptar_, your Branch 1 in lines 6 and 7 seems to take 3 arguments. Did you mean to put line 7 there?
06:54:02 <lyxia> reptar_: the actual problem is that fill is missing an argument
06:55:21 <lyxia> reptar_: as for your question, (Branch 1 (...) (...) :: Tree Int)
06:55:28 <reptar_> lyxia: you are completely right :) thank you!
06:56:14 <Gurkenglas> Looks like I fell into the same trap here as the compiler. Listen to lyxia instead.
07:00:17 <Myrl-saki> Gah.
07:00:21 <Myrl-saki> I'm going to need help now.
07:00:26 <Myrl-saki> I need lists.
07:00:34 <reuben364> [1,2,3]
07:00:38 <Myrl-saki> HVect, I think?
07:00:55 <Myrl-saki> What kind of stuff can I guarantee with HVect?
07:01:32 <reuben364> You can guarentee each element has a certain type and that the list has a certain length.
07:01:36 <Myrl-saki> :t sequence
07:01:38 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
07:01:53 <Myrl-saki> I see.
07:03:20 <Xenasis> Probably a silly question, but how do I actually use libraries I download from cabal? That is, what do I add to my compilation string to GHC? I'm attempting to try Aeson but can't seem to google the solution to this
07:03:59 <bennofs> Xenasis: if you ran `cabal install aeson`, you shouldn't have to add anything to GHC, just import the module from the package
07:04:24 <Xenasis> That was what I did, hmm
07:04:46 <Myrl-saki> Well. I'm stating the obvious here.
07:04:56 <Myrl-saki> But this is clearly way harder than I expected.
07:05:03 <bennofs> Xenasis: if the project is larger, I recommend creating a `.cabal` file for your project and making it a proper cabal project. This way, you also can use sandboxing so you don't get conflicts when multiple projects require different library versions
07:05:17 <Myrl-saki> Is there a better syntax for HVect? I'm using it for a library.
07:05:42 <reuben364> What do you aim to do with it?
07:05:47 <Xenasis> It should just be ~200 lines and a single file
07:05:53 <bennofs> Myrl-saki: i generally try to avoid heterognous collections. the api is just way too complicated
07:06:04 <Myrl-saki> reuben364: My current code is
07:06:09 <Xenasis> Though yeah thanks for letting me know that it /should/ just work
07:06:14 <Xenasis> Will tinker with cabal
07:06:20 <bennofs> Xenasis: so you ran `cabal install aeson`, that suceeded and `import Data.Aeson` fails?
07:06:24 <Myrl-saki> reuben364: :: MonadFix m => [[a] -> m] -> m [a]
07:06:33 <Myrl-saki> reuben364: And I plan to rewrite that into HVect.
07:07:01 <Xenasis> I was pretty sure it succeeded but perhaps it didn't, though yes that is what happened I believe
07:07:47 <Myrl-saki> This is the current API. http://ix.io/sh0
07:07:54 <lyxia> Xenasis: are you using a sandbox
07:08:14 <Myrl-saki> (And yeah, that doesn't work, because heterogenous lists.)
07:08:14 <Xenasis> I'm not, I'll update everything in cabal and reinstall Aeson
07:08:41 <reuben364> Myrl-saki: And all you want to do is have a fixed length, right?
07:09:22 <Myrl-saki> reuben364: I think I should talk about what I want to fix rather than my current fix.
07:10:33 <Myrl-saki> reuben364: I'm using reflex-dom, and I'm working on a library for a CSS framework that maps the DOM's elements to the CSS framework's elements. The CSS framework has some "rules"(which are not really enforced, but I want to enforce them in this library.) One rule is that specific collection elements have to have specific children.
07:11:01 <Myrl-saki> reuben364: (I hope you get where the `:: MonadFix m => [[a] -> m a] -> m a` comes from now.
07:11:54 <reuben364> Myrl-saki: which function has that signature?
07:11:54 <reuben364>  
07:11:57 <Myrl-saki> reuben364: I think I can get away by using GADT, instead.
07:12:04 <Myrl-saki> Ah, sure.
07:12:42 <Myrl-saki> :t \f -> sequence . traverse f
07:12:43 <lambdabot> (Applicative t, Traversable m, Traversable t, Monad m) => (a1 -> t a) -> m a1 -> m (t a)
07:13:15 <Myrl-saki> :t \ms -> mfix (\xs -> sequence . traverse ($ xs) $ ms)
07:13:17 <lambdabot> (Applicative t, Traversable m, Traversable t, MonadFix m) => m (t a -> t a) -> m (t a)
07:13:21 <Myrl-saki> reuben364: ^
07:14:10 <Myrl-saki> Why do I have a sequence there lol
07:14:24 <Myrl-saki> :t \ms -> mfix (\xs -> traverse ($ xs) ms)
07:14:26 <lambdabot> (Traversable t, MonadFix m) => t (t b -> m b) -> m (t b)
07:14:31 <Myrl-saki> Better.
07:16:35 <Myrl-saki> I think I can use HVectElim for one of these things.
07:20:59 <reuben364> Myrl-saki: At the point all I think I'm good for is being a rubber ducky.
07:21:53 <Myrl-saki> reuben364: Hahaha. Wel, we all need rubber duckies. :D
07:26:14 <LAZAR> Okay this works: changeName :: Person -> String -> Person where Person is an abstract data type. But what if I have State -> String -> Int -> State where State is a function String -> Int? How can I modify a function, like adding new state variables?
07:35:00 <lyxia> the result is a function, so you can start by writing a lambda
07:35:37 <sproingie> LAZAR: for passing a function as a value, you'll want parens in the signature, e.g. State -> (String -> Int) -> State
07:37:24 <LAZAR> lyxia: yeah but my problem is i somehow want to store key-value pairs without hardcoding them... basically adding more cases to an existing function
07:38:08 <sproingie> Data.Map might come in handy
07:39:03 <lyxia> Data.Map won't help since State is a function type
07:39:35 <sproingie> it can certainly represent a mapping of Strings to Ints
07:40:02 <LAZAR> Well according to the assignment i have to use functions: https://www.cis.upenn.edu/~cis194/spring15/hw/03-ADTs.pdf
07:40:33 <sproingie> well if there's constraints on the homework, then you're not allowed to use the full toolbox
07:40:41 <LAZAR> It seems they want to represent the state not as a data structure but as a polymorphic function
07:41:01 <LAZAR> Well im not doing it for homework but just for fun to learn it
07:42:00 <LAZAR> I just have no clue how to extend a function at runtime by additional definitions
07:42:09 <lyxia> LAZAR: since the result is a function, you can do comparisons on the argument to decide what to return
07:42:36 <sproingie> ah ok the assignment is different than what i thought you were doing
07:42:59 <lyxia> changeState state newKey newValue = \key -> if key == newKey then ... else ...
07:43:38 <LAZAR> lyxia: yeah but the result should be a polymorphic function so somehow you need to preserve the former definition
07:43:42 <sproingie> type State = [(String, Int)]
07:43:50 <sproingie> not as efficient as a Map, but it'll do
07:44:43 <lyxia> LAZAR: where do you see a polymorphic function
07:44:46 <LAZAR> sproingie: well im not sure if state is supposed to be stored in an array... it seems they want me to create just overloaded definitions covering different args
07:45:39 <sproingie> the assignment doesn't seem to constrain the implementation
07:45:45 <LAZAR> lyxia: the state returns integers for given strings, so you either modify a given function to cover additional patters or you create a new definition which is polymorphic
07:45:56 <lyxia> this is not what we call polymorphism.
07:45:58 <sproingie> you don't modify functions, you pass them different args
07:46:02 <lyxia> it's just a function
07:46:17 <LAZAR> sproingie: hmm in that case querying the state would be pretty inefficient? i would need to loop over the state and then get the value
07:46:29 <sproingie> oh it won't be efficient, no
07:46:44 <sproingie> it'll be fast enough for this though
07:47:13 <LAZAR> sproingie: look at the function signature tho... extend expects a single state to extend, not a list
07:47:19 <EvilMachine> Hi. What type class has operators equivalent to (<>) and (pure)? Because I can ("abc" <> "d") but I can’t ("abc" <> 'd'), so I need something like ("abc" <> pure 'd')… if you understand what I mean…
07:47:23 <sproingie> LAZAR: a list is a single thing
07:47:44 <sproingie> you've got a desired implementation stuck in your head, you need to get it unstuck
07:48:28 <sproingie> if you have a list of (Int, String), and a function that takes such a list, an int, and a string, the implementation is obvious
07:48:49 <LAZAR> sproingie: yeah but i cant insert a [state] into extend. i know i could easily store a state in any kind of data structure like lists, what confuses me is that they want me to hold the application state inside one single function
07:48:53 <lyxia> sproingie: "we define a State to be a function of type String -> Int"
07:48:57 <sproingie> in fact if it's a list of (a,b) and not any specific type, then there's only one possible implementation
07:49:03 <sproingie> *that* BTW is what polymorphism is
07:49:25 <lyxia> extend :: (String -> Int) -> String -> Int -> (String -> Int) is what the exercise is asking
07:49:42 <sproingie> @djinn [(a,b)] -> a -> b -> [(a,b)]
07:49:42 <lambdabot> Error: Undefined type []
07:49:47 <MarcelineVQ> > "abc" <> pure 'd'
07:49:50 <lambdabot>  "abcd"
07:49:52 <EvilMachine> (Lol, ("abc" <> pure 'd') actually already works. But I don’t want to use something as complex as applicative.)
07:49:54 <LAZAR> lyxia: exact, it expects a function and changes this one
07:49:59 <sproingie> @djinn foo :: [(a,b)] -> a -> b -> [(a,b)]
07:49:59 <lambdabot> Cannot parse command
07:50:03 <sproingie> i lose
07:50:22 <EvilMachine> MarcelineVQ: So the question boils down to: What’s a simpler version of (pure) that doesn’t require all of Applicative?
07:50:23 <lyxia> LAZAR: what I wrote is part of the answer
07:50:26 <MarcelineVQ> > "abc" <> ['d']
07:50:29 <lambdabot>  "abcd"
07:50:52 <EvilMachine> MarcelineVQ: Unfortunately, I need it to be as generic as possible.
07:51:01 <EvanR> EvilMachine: what laws would this "simpler" class follow
07:51:04 <lyxia> LAZAR: define a new function (\key -> ...) in terms of the old one (state)
07:51:31 <EvilMachine> EvanR: It would just have two operators. One like (pure) and one like (<>).
07:51:34 <EvanR> there used to be a class Pointed which was Applicative without <*>
07:52:24 <EvilMachine> EvanR: Did Pointed have a combinating operator?
07:52:28 <EvanR> EvilMachine: what is the type of these ops
07:52:34 <LAZAR> lyxia: yeah i know i could just return a new function, that would be simple. but not to overwrite the old definition i would need to "break up" the old state and create a new function alltogether
07:53:21 <LAZAR> after extending the function body itself has to be rewritten at runtime
07:53:32 <sproingie> don't rewrite the function, just wrap it
07:53:41 <lyxia> something's wrong with this
07:53:42 <EvanR> or memoize
07:53:55 <sproingie> didn't realize it required State to be that function type
07:53:58 <EvilMachine> EvanR: I want a function that can put an element in a list/set/…, with the only condition being that that list/set/… is something, where on cas put elements (of that type) in.
07:54:09 <EvilMachine> cas=can
07:54:22 <lyxia> LAZAR: you return a new function, it IS that simple
07:54:27 <EvanR> youre about to fall into the "container" trap
07:54:34 <EvilMachine> EvanR: I know. :)
07:54:37 <EvanR> "clearly its a class for generic containers"
07:54:40 <lyxia> LAZAR: I don't understand why you're writing about overwriting anything
07:54:41 <EvanR> which means....
07:54:52 <sproingie> ah "we define a State to be a function of type String -> Int".  i only tend to pay attention to the code parts
07:54:56 <EvilMachine> EvanR: I just corrected myself, including something like Applicative too.
07:55:03 <EvanR> huh?
07:55:05 <lyxia> LAZAR: Everything is immutable here
07:55:37 <EvanR> EvilMachine: well, still, you should be able to produce types?
07:55:39 <EvilMachine> EvanR: So not just “put in” as in “container”, but also as in “apply to”
07:55:44 <EvanR> then you can worry about laws
07:55:57 <EvanR> or see that there can be no laws because its too polymorphic
07:55:59 <LAZAR> I define this simple Function f :: Int -> String and offer one definition f n | n == 5 = "Five | otherwise "Default". How would I extend this at runtime to cover an input of 4 = "Four"?
07:56:27 <lyxia> LAZAR: okay maybe we have a different idea of what it means to "return a new function"
07:56:53 <EvilMachine> EvanR: Well, in my case it is actually for the purpose of container managing. But I hoped I could get something more generic, and benefit from that. :)
07:57:04 <EvanR> i am skeptical that you will
07:57:15 <EvanR> especially if you dont have types for these operations
07:57:17 <lyxia> LAZAR: \n -> if n == 4 then "Four" else f n  defines a new function that extends f.
07:57:58 <lyxia> LAZAR: there is no need to "overwrite" f
07:58:41 <lyxia> LAZAR: you just define a new function from it and pass it around in various ways
07:58:43 <EvilMachine> EvanR: Why the judgmental self-fulfilling prophecy mood? I feel like you push me towards that stereotype that you despise, until I am that, and I am not stress-resilient enought to fight it. … I am very aware of the trap, and if anything, would prefer nudging in the other direction instead.
07:58:46 <sproingie> LAZAR: think of it this way: you have a function that if someone gives it "Four", it returns 4.  now you want a new function, let's say mapping "Five" to 5, and if the input isn't "Five", try your old function.  see how that works?
07:58:49 <EvanR> EvilMachine: the Set, Map, Array, Vector, etc etc etc APIs all tend to have similar operations and the same names. not just singleton and append. 
07:59:04 <sproingie> LAZAR: you wouldn't use a pattern guard, just a plain old 'if'
07:59:13 <EvanR> but they arent part of a class because you cant give them a common type
07:59:25 <sproingie> looks like your base case is that any unresolved identifiers have a value of 0
07:59:29 <EvanR> and in your case, youre arbitrarily taking only two of the operations. why?
08:00:02 <EvanR> in practice you cant make that code polymorphic on the entire API for all those containers, it just doesnt make sense
08:00:16 <EvanR> this is where java and friends mess up
08:00:18 <EvilMachine> EvanR: Well, (CommonType RelatedType -> RelatedType -> CommonType RelatedType) would be the common type of their “add/apply/…” operation.
08:00:44 <EvanR> oh i misunderstood, i thought you were talking about pure
08:00:45 <EvilMachine> EvanR: it suffices to make it polymorphic on the CRUD operations.
08:00:47 <EvanR> not insert
08:01:05 <EvilMachine> EvanR: Hmm, pure is needed in the case of <>.
08:01:07 <EvanR> now youre talking about more than 2
08:01:13 <EvanR> eh?
08:01:17 <EvilMachine> EvanR: Of course in general, it’s different.
08:01:46 <EvilMachine> EvanR: So you fell into the specialization trap too? ;)
08:01:47 <EvanR> in general... im just saying ive seen this kind of speculation a lot and it never goes anywhere good
08:02:08 <EvilMachine> EvanR: I know. Don’t worry. I’m not that much of a newbie anymore. :)
08:02:16 <EvilMachine> EvanR: I would probably act the same way. ^^
08:02:40 <EvanR> "container" is an emotional thing it seems, not a mathematical abstraction
08:02:51 <EvilMachine> EvanR: Well thankfully!
08:03:06 <EvilMachine> EvanR: I’m not Spock, you know? :D
08:03:11 <sproingie> "emotional" seems a rather imprecise term
08:03:19 <LAZAR> lyxia, sproingie : Thanks i guess that was what i was looking for... totally forgot. Extend would look like this: extend :: (Int -> String) -> Int -> String -> (Int -> String) extend f i s = (\n -> if n == i then s else f n)
08:03:22 <EvanR> right
08:03:25 <EvilMachine> sproingie: It is a very precise term though.
08:03:42 <EvanR> is it?
08:04:09 <EvilMachine> EvanR: Yes. See: https://www.youtube.com/watch?v=KbacW1HVZVk (and part 2.
08:04:11 <EvilMachine> )
08:04:23 <EvanR> what is the title of that
08:04:38 <Welkin> does anyone use stack with nix here?
08:04:41 <EvilMachine> EvanR: Antonio Damasio. Brain and mind: from medicine to society. 1/2
08:04:58 <EvanR> how long
08:05:04 <EvilMachine> EvanR: He’s a neuroscientist, and this is a speech about the topic.
08:05:07 <sproingie> LAZAR: pretty much, though you'll want to initialize it with the base case that always returns zero.  makes it so you'll largely be using it in curried form
08:05:23 <EvilMachine> EvanR: Too long. :)
08:05:27 <Welkin> last night I ran into a problem that I should have forseen: setting up on older project with nix, and it downloaded the latest packages for everything, but the API broke/changed with one of the libraries I'm using
08:05:28 <EvanR> mmkay
08:05:36 <EvilMachine> EvanR: More something for the evening.
08:05:42 <EvanR> youtube is too slow for me
08:05:43 <EvilMachine> EvanR: ~1h
08:05:48 <Welkin> I know this is a solved problem with stack (maybe there is a simple way to deal with it in nix too)
08:06:11 <EvilMachine> EvanR: Yes, but I haven’t found it in a condensed written form yet. Nevermind then. :)
08:07:14 <EvanR> EvilMachine: clojures penchant for pretending a bunch of different data structures are really the same, relies on "container", but i had issues trying to actually program that way
08:07:41 <EvanR> and understanding what would happen when i used the container API
08:07:50 <LAZAR> sproingie: yeah thats part of the assignment too... i think building an interpreter is a good way to learn a language
08:08:06 <NikolajK> Is there a documentation for color codes in type system presentations?
08:08:13 <EvanR> maybe it the same issue as with having "one true number type"
08:08:14 <NikolajK> There seem to be some conventios
08:08:40 <EvanR> values are red, types are blue
08:09:09 <EvanR> (in idris repl)
08:09:50 <lyxia> sounds like the start of a poem
08:10:55 <sproingie> "i learned a haskell and so can you"
08:11:06 <sproingie> ok let's not let me do poetry anymore
08:11:54 <EvanR> heres a question
08:13:05 <EvanR> if you issue a majorGC, to try and drop a lot of data, but you have still a single large object that you want to keep, can you somehow put that object in statis to hide it from the majorGC and save time duringn collection?
08:13:20 <MarcelineVQ> yes
08:13:29 <EvanR> stasis*
08:13:43 <MarcelineVQ> https://downloads.haskell.org/~ghc/master/libraries/html/compact/Data-Compact.html
08:13:54 <EvanR> duuude
08:16:59 <EvanR> GHC 8.2 and later
08:18:47 <Welkin> there is no 8.2
08:18:50 <Welkin> only 8.0.2
08:19:24 <EvanR> then these docs ....
08:19:31 <EvanR> are lying to me
08:19:39 <sproingie> 8.2 is the upcoming release
08:19:53 <MarcelineVQ> sure there is, it just happens to be called head currently, as the link suggests
08:19:56 <MarcelineVQ> *master
08:20:18 <EvanR> which link
08:20:27 <MarcelineVQ> the one you clicked on
08:20:35 <sproingie> ghc does that "odd unstable, even stable" thing linux used to do
08:21:11 <EvanR> oh i dunno why i thought this was a normal library on hackage
08:21:20 <EvanR> its part of GHC
08:21:31 <Welkin> upcoming when?
08:21:36 <EvanR> so can these be used at all?
08:21:37 <sproingie> when it's done
08:21:43 <EvanR> Data.Compact
08:22:05 <JuanDaugherty> nowish
08:22:13 <EvilMachine> EvanR: well, the one true number type would have to be of literally infinite length. :))
08:22:59 <EvanR> types have a length?
08:23:01 <sproingie> store it on the infinite tape of your turing machine
08:23:15 <MarcelineVQ> EvanR: the in-dev version is really something like 8.1.somedate but that stuff should be available on it currently, I'd have to rebuild my local here to confirm
08:23:38 <EvanR> man i was excited to try and use this for my video game project
08:23:53 <EvanR> now the prospect of cross compiling experimental GHCs appears
08:24:09 <EvanR> good way to lose sanity i fear
08:24:10 <Welkin> does anyone know wtf happened to the AWS library?
08:24:11 <Welkin> o.o
08:24:24 <Welkin> it changed how it allows you to specify the aws region
08:24:26 <EvilMachine> EvanR: Inside RealWorld they do. :)
08:24:35 <EvanR> what are you talking about
08:24:41 <Welkin> either using a lens interface (which doesn't work?) or using `within`, which doesn't work either
08:25:03 <EvilMachine> sproingie: Oh, no problem then, I just use a virtual machine, and set it to “Turing machine” upon initialization.
08:25:07 <MarcelineVQ> EvanR: angerman in #ghc works on cross-compiling if it's a subject that interests you, probably bgamari too, can't recall
08:31:01 <reuben364> How would I do the following in lens: extract a value from a monad transformer stack with statet using a prism and instead of using the monoid instance, run something in the monad if the value is missing?
08:31:43 <EvanR> MarcelineVQ: interests is probably the wrong word
08:32:10 <EvanR> but is #ghc really a good place to get support for that?
08:32:11 <reuben364> for example: someField . _Just %%= doSomething, except throw an error if it is nothing
08:32:27 <MarcelineVQ> in the mean time if youj want gc to not tread on you you can probably use ffi pointers, not really sure though
08:32:50 <MarcelineVQ> EvanR: idk about get support exactly, but certainly a more informed opinion
08:35:10 <Gurkenglas> :t preview -- I suppose a "(MonadReader s m, Alternative m) => Getting (First a) s a -> m a" version of this would help reuben
08:35:12 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
08:36:30 <Welkin> does anyone know where the hell I set envRegion in the AWS library?
08:36:53 <srhb> Welkin: Which library?
08:37:04 <srhb> Welkin: Or rather, which package? aws?
08:37:16 <Welkin> http://hackage.haskell.org/package/amazonka-1.4.5/docs/Network-AWS.html#v:envRegion
08:37:21 <Welkin> http://hackage.haskell.org/package/amazonka-1.4.5/docs/Network-AWS-Env.html#v:within
08:37:24 <Welkin> either of those
08:37:45 <Welkin> I used to be able to set the region here http://hackage.haskell.org/package/amazonka-1.4.5/docs/Network-AWS.html#v:newEnv
08:37:54 <srhb> Oh, amazonka.
08:38:21 <JuanDaugherty> amazonka
08:39:15 <Welkin> I tried setting it on the result from `newEnv` and get errors
08:39:28 <Welkin> I tried on the request object, and it had errors
08:40:02 <Welkin> "Could not deduce (AWS.HasEnv (IO AWS.Env)) arising from a use of ‘AWS.envRegion’"
08:40:32 <EvanR> MarcelineVQ: ffi pointers? interesting
08:41:13 <EvanR> like, data is stored outside haskell but you can view it with unsafePerformIO (and the view is not kept around so gets GCd)
08:41:33 <Gurkenglas> How do I make intero make M-. jump to definitions even for library functions?
08:41:53 <Welkin> Gurkenglas: set up the keybinding in your .emacs file
08:42:11 <Welkin> finally I got it to build...
08:42:18 <sproingie> that's the binding.  the trick is making it jump to library functions
08:42:28 <Welkin> I had to set it on the AWS.Env object, not IO AWS.Env
08:42:28 <sproingie> i don't think intero can do that
08:43:19 <sproingie> i have a hard enough time convinving intero to jump to stuff that's defined in my project
08:47:38 <spatial> Should be possible using hmatrix. (matrix1 == matrix2).mean()
08:48:22 <Gurkenglas> I usually work with pieces of code instead of projects, and am not too familiar with all this project stuff. How would I go about taking code from, say, a stackoverflow question, and make intero let me work with it?
08:49:03 <Gurkenglas> Ah, let's say stack scripts
08:49:12 <spatial> It is gives a matrix of  ones and zeros. matrix1 == matrix 2 Mean is Sum of ones / Total No: of elements
08:49:36 <cheshircat> hello, does anyone know Diagrams? I'm wondering if there is a way to slice a diagram in half
08:50:05 <cheshircat> I could just create the pieces, but it would be easier to create the whole thing and then slice it at y intervals
08:51:10 <Gurkenglas> cheshircat, would this be a separation of pixels to either side of a line or a separation of diagrams whose center points fall to either side of a line?
08:54:18 <cheshircat> separation of pixels
08:54:33 <EvanR> gives you subpixels?
08:54:46 <Welkin> end the segregation
08:55:42 <cheshircat> huh?
08:56:30 <EvanR> cheshircat: you can slice up a bitmap image using vector operations
09:04:53 <hseg> Hi. I'm trying to list the values of a binary function on integers in a table. Is there a package that will do this? Or at least make all columns the same width?
09:06:12 <EvanR> > printf "%5d %5d" 3 4
09:06:13 <cocreature> hseg: _all_ values? Integer is only bounded by your memory so there are a lof of values :)
09:06:15 <lambdabot>  error:
09:06:15 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M617148618746...
09:06:15 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
09:06:20 <EvanR> > printf "%5d %5d" 3 4 :: String
09:06:23 <lambdabot>  "    3     4"
09:06:30 <EvanR> > printf "%5d %5d" 35 433 :: String
09:06:33 <lambdabot>  "   35   433"
09:06:51 <hseg> Well, I'm using finite subsets.
09:06:54 <EvanR> theres also this https://hackage.haskell.org/package/boxes
09:06:57 <matrium> hi, what's the best way to model overlapping datatypes? e.g. in RDF a triple consists of a subject, predicate and object. The subject can be an IRI or a blank node, the predicate just an IRI and the object can be an IRI, a blank node or a literal. If I would use just a single data Node = IRI | Blank | Literal I wouldn't be able to check that a literal is not used as subject. If I would model three separate types, there would be a lo
09:07:30 <hseg> EvanR: But I don't know the width in advance and don't want to have to fiddle with it.
09:07:32 <srhb> matrium: You got cut off at "there would be a lo"
09:07:39 <gedda> quick question, is there some way to write this cleanly without do? https://hastebin.com/iyugukegug.hs
09:07:49 <glguy> matrium: data RDF = RDF (Maybe IRI) IRI IRI
09:07:52 <cocreature> hseg: there is https://hackage.haskell.org/package/tabular and https://hackage.haskell.org/package/table-layout
09:08:08 <EvanR> hseg: did you look at the boxes library i just linked
09:08:12 <matrium> srhb: "If I would model three separate types, there would be a lot of redundant/boilerplate code"
09:08:28 <srhb> :t liftM2 (++)
09:08:30 <lambdabot> Monad m => m [a] -> m [a] -> m [a]
09:08:35 <srhb> gedda: That? ^
09:08:39 <hseg> cocreature: Thanks
09:08:57 <gedda> srhb: Something like that yes, hmm..
09:09:24 <EvanR> > printf "%5d %5d" 35 4388773 :: String
09:09:28 <lambdabot>  "   35 4388773"
09:09:36 <EvanR> ouch
09:10:59 <matrium> glguy: I don't quite get the point of that
09:11:43 <glguy> matrium: Which part don't you understand?
09:13:01 <sproingie> which one is the maybe?
09:13:03 <matrium> that only allows (IRI, IRI, IRI) triples. But (Blank, IRI, Literal) is also a valid combination
09:13:24 <glguy> sproingie: The one that was optional, the subject
09:13:31 <glguy> oh
09:13:34 <glguy> there were two options
09:13:39 <glguy> matrium: data RDF = RDF (Maybe IRI) IRI (Maybe IRI)
09:13:51 <sproingie> eh.  i'd use typeclasses and instances
09:14:01 <hseg> cocreature: Unfortunately, I don't have access to a GHC under my control, so I only have ideone ATM, which doesn't support those classes.
09:14:06 <hseg> s/classes/packages/
09:14:06 <glguy> How would typeclasses help with making RDF values?
09:14:28 <srhb> gedda: You may also be looking for applicative style, if that's not quite it?
09:14:36 <sproingie> it would help in declaring what various things are RDF triples
09:14:39 <EvanR> abuse of type classes
09:14:46 <sproingie> you don't even have to pick a single form
09:14:48 <hseg> Unless the fpcomplete ide is still up?
09:14:49 <srhb> > (++) <$> Just [1,2,3] <*> Just [4,5,6] -- gedda
09:14:51 <lambdabot>  Just [1,2,3,4,5,6]
09:14:58 <matrium> glguy: The RDF thing is just an example. I'm looking for a general pattern for handling overlapping types
09:15:01 <glguy> sproingie: It probably isn't a good idea to have multiple types for the single concept of RDF triple
09:15:15 <sproingie> the class is a single concept
09:15:33 <glguy> matrium: OK. this is an example of the pattern. You start with the common bits and then build up bigger types where you need more values
09:15:41 <sproingie> but yeah probably not too wise to have multiple representations going around to start with
09:16:06 <nshepperd_> matrium: I'd just use different types for these things and not worry about the "boilerplate"
09:16:16 <sproingie> might look at the existing rdf stuff.  rdf4h maybe?
09:17:07 <matrium> nshepperd_: Ok, so something like a newtype for IRIs, BNodes and Literals and then something like "Subject = IRISubject IRI | BNodeSubject Bnode"
09:17:14 <sproingie> or just 'rdf'.  https://hackage.haskell.org/package/rdf-0.1.0.1/docs/Data-RDF-Types.html
09:17:36 <nshepperd_> matrium: yes
09:17:49 <EvanR> i like their solution
09:18:00 <nshepperd_> You can share functions for handling IRIs and Bnodes
09:18:13 <EvanR> data Triple = Triple Subject Predicate Object
09:18:22 <EvanR> what you see is what you get
09:18:43 <matrium> looks very alike nshepperd_'s suggestions
09:19:06 <EvanR> lovin it
09:19:14 <sproingie> looks like rdf has nicer types, rdf4h has better parsing
09:19:51 <sproingie> (in that it has parsers at all)
09:20:17 <matrium> sproingie: currently I'm using rdf4h, but I'm quite unsatisfied with the types
09:21:01 <matrium> in rdf4h Triple = Node Node Node and there is a runtime check for the allowed types
09:21:15 <EvanR> yuck
09:22:11 <sproingie> bleh.  yeah, rdf seems to have richer types
09:23:05 <EvanR> rdf has parsers
09:23:36 <EvanR> attoparsec
09:23:41 <Welkin> ottoparsec
09:24:59 <hpc> i am surprised there isn't a parsing library called au yet
09:25:01 <sproingie> yeah not as many parsers tho, looks like just n-quads, which is not a bad syntax
09:25:28 <sproingie> i always used turtle back when i was doing rdf stuff
09:25:52 <Welkin> lol
09:25:58 <Welkin> template haskell in the servant template form stack
09:26:00 <Welkin> from*
09:27:08 <Ulrar> Anyone knows of a package to parse a string as html and extract the text out of it ? Something to transform "<p>test</p>" into "test" for example
09:27:17 <Welkin> Ulrar: pandoc
09:27:53 <EvanR> tagsoup
09:28:48 <EvanR> innerText :: StringLike str => [Tag str] -> str
09:28:55 <EvanR> Extract all text content from tags (similar to Verbatim found in HaXml)
09:29:41 <Ulrar> Ah, that looks promising thanks
09:29:47 <cheshircat> Thank you EvanR
09:34:04 <Ulrar> It does exactly what I need it do to, perfect
09:35:26 <EvanR> and my powers goin out
09:47:36 <EvanR> just had an "interesting" idea. a haskell source file (with restrictions) could be considered a data structure. you could load this structure and operate on it like a Map or Graph. then save it back as haskell source file.
09:47:54 <EvanR> so you could have self modifying program
09:48:01 <iqubic> What do you mean?
09:48:23 <EvanR> example, if i have a module full of numeric parameters
09:48:23 <erisco> so you parse it, manipulate the AST, then write it out again
09:48:53 <EvanR> to adjust the numbers, you have a program to view the results
09:49:24 <EvanR> but the final numbers are not a separate configuration file, it should be part of the code
09:50:07 <EvanR> and you might want to add more parameters later so it shouldnt be baked in forever
09:51:22 <EvanR> haskell source code-as-database
10:00:46 <Ulrar> I'm having trouble depending on HTTP-Simple in a cabal file, I installed it and added it to the build-depends but when I do a cabal build it says Network.HTTP.Simple doesn't exist
10:01:24 <Myrl-saki>     columns_ :: MonadFix m => (HVect ((:) (HVectElim (Append as ts) (m a)) ts)) -> HVect as -> HVect (Append ((:) (HVectElim (Append as ts) (m a)) ts) as)
10:01:26 <Myrl-saki> Help
10:01:30 <Myrl-saki> lmao
10:02:05 <Myrl-saki> I'm trying to make a type generic version of `:: [[a] -> m a] -> [a] -> m [a]`
10:03:31 <Ulrar> Oh it's http-conduit ..
10:03:41 <Welkin> Mondad m, Traversable t => t (t a) -> m a -> t a -> m (t a)
10:03:43 <Welkin> ?
10:03:48 <Welkin> Monad*
10:04:03 <Myrl-saki> Welkin: By type generic, I mean heterogenous.
10:04:14 <Welkin> oh
10:04:27 <Welkin> why do you want a heterogenous list?
10:04:39 <Myrl-saki> Welkin: Hard to explain.
10:04:53 <Myrl-saki> Welkin: Basically, I want to do an `mdo`.
10:05:16 <Myrl-saki> Welkin: But I also have to insert an `:: (Monad m) => m a -> m a` before everything.
10:05:43 <chewzerita> @pl \n x -> let w = div n x in (w, n - w * x)
10:05:43 <lambdabot> ap (ap . (ap (,) .) . (. (*)) . (.) . (-)) div
10:06:35 <Myrl-saki> Basically, I want to do `mdo { x <- f $ m0 [y, z]; y <- f $ m1 [x, z]; z <- f $ m2 [x, y]}` but I "need" it to be generic length.
10:06:53 <Welkin> what is that new record field extension called?
10:06:54 <Myrl-saki> Technically, I could do just that.
10:07:03 <Myrl-saki> I mean just write exactly what I wrote.
10:07:07 <EvanR> have you tried a FunList sort of thing
10:07:12 <Welkin> so we don't need to prefix our record field accessors with _ or a fully qualified name
10:07:16 <Myrl-saki> But I don't trust the users to remember to place `f` the whole time.
10:07:32 <Myrl-saki> EvanR: What does FunList do/
10:07:42 <Welkin> found it https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/DuplicateRecordFields
10:07:52 <Welkin> does anyone use this now though? Does it work without issues?
10:11:40 <Myrl-saki> `t2 is untoucheable` what?
10:12:13 <c_wraith> Myrl-saki: that usually means an existential is involved somewhere.
10:12:28 <c_wraith> Welkin: it's really awkward right now, as there's almost no inference.
10:13:01 <Myrl-saki> c_wraith: So, it's possible that I can't type a well-typed program?
10:13:51 <c_wraith> Myrl-saki: it's possible, but it's more likely it isn't actually well-typed.  There are a bunch of subtleties.  There are also small things you can often do to fix the situation.
10:13:59 <Welkin> c_wraith: so I should avoid using it for now?
10:14:24 <nshepperd> Myrl-saki: what stops you from just defining m0' = f . m0 and using m0'
10:15:06 <Myrl-saki> nshepperd: They can still write m0.
10:15:08 <c_wraith> Welkin: I found the current state to be too much work for too little benefit, but you might have a better use case than I did.
10:15:27 <Myrl-saki> http://ix.io/shM
10:15:33 <Myrl-saki> The two programs. :D
10:16:28 <nshepperd> Myrl-saki: so only expose m0' from your module?
10:16:49 <Myrl-saki> nshepperd: They should be able to use m0 anywhere else.
10:18:17 <Myrl-saki> Arbitrary requirements, I know.
10:18:30 <nshepperd> maybe m0' could be a different type to m0
10:18:39 <nshepperd> and you have to use f to convert from one to the other
10:18:55 <Myrl-saki> nshepperd: Mmm... possible.
10:19:19 <Myrl-saki> nshepperd: The base library is FRP. Would it handle that well?
10:19:51 <Myrl-saki> nshepperd: I think I'll have problems with wiring if it's like that.
10:20:07 <nshepperd> no idea
10:20:21 <Myrl-saki> Hmmm... actually, probably not.
10:20:25 <Myrl-saki> nshepperd: Thanks. I'll consider that.
10:20:33 <EvanR> theres a library called FRP
10:20:34 <EvanR> ?
10:20:48 <Myrl-saki> EvanR: Nah. I'm using Reflex.
10:20:52 <EvanR> oh
10:21:19 <EvanR> Myrl-saki: youre trying to make a list of actions to represent a recursive do? 
10:21:25 <Myrl-saki> EvanR: Mhm.
10:21:27 <EvanR> doesnt seem right
10:21:32 <monochrom> Oh, wxHaskell is not dead, there is a new version
10:21:42 <Myrl-saki> EvanR: But I want to wrap the list of actions in everything.
10:21:47 <Myrl-saki> Err
10:21:53 <Myrl-saki> EvanR: I want to wrap the list of actions with something.
10:22:00 <EvanR> if its a mere list of actions, its not a monad or needing do notation
10:22:07 <monochrom> I hope next time when someone asks, I won't forget and say "wxHaskell hasn't been updated for years".
10:22:17 <EvanR> it would be a monoid
10:22:23 <Welkin> it can be :: [a]
10:22:32 <Welkin> or, [IO a]
10:22:41 <Myrl-saki> Basically.
10:22:46 <EvanR> [m ()]
10:22:53 <Welkin> oh yeah, it's heterogenous
10:23:05 <EvanR> i dont see why
10:23:12 <adamCS> Myrl-saki: You have a fixed length list of differently typed things and you would like to apply an action to them?  
10:23:12 <Myrl-saki> I want to wrap everything in a `divClass str`
10:23:19 <EvanR> if youre trying to use the bound variables, then no, its not a list
10:23:33 <EvanR> its a free monad
10:23:36 <Myrl-saki> Then compose everything.
10:24:10 <adamCS> Myrl-saki:  Right.  I have EvanR's question.  Are you trying to use the results from earlier in the list to do actions later?
10:24:31 <adamCS> Or just do something to each item in the list and then compose them?
10:24:55 <Myrl-saki> adamCS: The former.
10:25:08 <EvanR> so you dont have a list really
10:25:11 <Myrl-saki> adamCS: And I also have to do something to each list before doing the former.
10:25:16 <Myrl-saki> to each item in the list*
10:25:24 <Welkin> the only reason that heterogenous lists/arrays work in languages like javascript is that it's really implemented as a hashmap/object
10:25:31 <Myrl-saki> before (mutually) recursively using the results.
10:25:39 <Welkin> wait, I guess that's not quite why
10:25:40 <adamCS> Yeah.  That's more complicated.  What are you actually trying to do?  More specifically?
10:25:56 <Gurkenglas> I often have conversations with lambdabot to prepare a line for here. Can intero give me something better than that?
10:25:57 <EvanR> Welkin: its because they arent really hetero, everything has the same dynamic type
10:26:06 <Myrl-saki> I'll give the homogenous list version.
10:26:08 <Welkin> EvanR: sure, I just realized that too
10:26:26 <EvanR> real hetero lists are an advancement you get only with advanced type system
10:26:29 <Myrl-saki> adamCS: http://ix.io/shP
10:26:39 <EvanR> and a quantum leap of logic out of stuff like js
10:26:49 <EvanR> like "what am i really going to do with this list"
10:27:41 <adamCS> Myrl-saki: And the type "a" is fixed or you want that to be heterogenous?
10:28:24 <Myrl-saki> adamCS: I want it to be heteorgenous.
10:28:46 <adamCS> And this is all so you can apply css to a table?
10:28:58 <EvanR> which requires answering what you intend to do with it
10:29:17 <Myrl-saki> adamCS: Ish. :P
10:29:28 <EvanR> the answer may lead back to a homolist
10:29:50 <Myrl-saki> EvanR: I'm thinking of using GADT, for this.
10:29:59 <Welkin> lol... what?
10:30:02 <Welkin> for css?
10:30:02 <monochrom> Yes. Even if you use an existential type, the exact design of the existential type still requires "what will you do with the content?"
10:30:24 <monochrom> And even OOP ways don't exempt you from that.
10:30:49 <Welkin> Myrl-saki: I don't understand you use case
10:30:52 <erisco> chewzerita, I came up with   liftA3 (((&&&) id .) . flip (.) (*) . (.) . (-)) <$> const <*> flip const <*> div
10:30:53 <Myrl-saki> Welkin: For DOM, to be more exact.
10:30:54 <Welkin> your*
10:31:05 <Welkin> what exactly are you doing? What's the end result??
10:31:16 <EvanR> OOP = defer answering what you will do with it, and when it becomes apparent that what you did made no sense, dynamically detect the class and just get it done anyway, and go home
10:31:59 <adamCS> I've done a bunch of stuff, with Reflex, for applying actions to a heterogenous list--usually obtained from a generic representation of a type and then putting that back together into the type, or leaving it as a hetero list of actions.
10:32:04 <EvanR> Myrl-saki: youre not using a dynamically typed DOM ?
10:32:24 <Gurkenglas> Requesting "Maybe (a, b) -> (Maybe a, Maybe b)". Probably something lensy.
10:32:25 <Myrl-saki> EvanR: That's something else I was considering, just for this specific case.
10:32:29 <cocreature> EvanR: I like the going home part
10:32:55 <erisco> chewzerita, which can be shortened to  liftA2 (<*>) (((&&&) id .) . flip (.) (*) . (.) . (-)) div
10:33:18 <Welkin> @unpl liftA2 (<*>) (((&&&) id .) . flip (.) (*) . (.) . (-)) div
10:33:18 <lambdabot> liftA2 (<*>) (\ x x0 -> (\ x1 -> x1) &&& \ x2 -> x - (x0 * x2)) div
10:33:25 <Myrl-saki> (Rather than use heterogenous list, just have dynamic results and arguments.)
10:33:26 <erisco> you don't really want to do pointless arithmetic
10:33:33 <Welkin> pointless is pointless
10:33:38 <Welkin> most of the time
10:33:44 <erisco> I like it
10:34:06 <Welkin> if you like to code golf and write code no one can understand
10:34:17 <EvanR> variables are cool
10:34:18 <erisco> I can
10:34:43 <erisco> well, that particular example isn't good, but it is a worthwhile exercise
10:35:02 <lordcirth> What annoys me is that 'pointless' style is full of points '.'
10:35:08 <ski> @type maybe (Nothing,Nothing) (Just *** Just)
10:35:10 <lambdabot> Maybe (a1, a) -> (Maybe a1, Maybe a)
10:35:11 <lordcirth> Terrible naming
10:35:21 <erisco> tacit style
10:35:28 <Gurkenglas> chewzerita, erisco, it's divMod
10:35:48 <ski> in actual math, the composition symbol is ⌜∘⌝
10:36:18 <erisco> Gurkenglas, what is?
10:36:33 <ski> the "points" referred to are the input variables
10:36:34 <erisco> oh, the function, heh
10:36:42 <Gurkenglas> :t [\n x -> let w = div n x in (w, n - w * x), divMod]
10:36:44 <lambdabot> Integral t => [t -> t -> (t, t)]
10:36:53 <erisco> well I wasn't interested in the content... just the rewrites to make it pointless
10:37:20 <erisco> eh, the similarly of those types doesn't say enough
10:37:37 <erisco> :t [divMod, (,)]
10:37:39 <lambdabot> Integral a => [a -> a -> (a, a)]
10:37:49 <monochrom> @quote monochrom point\ free
10:37:50 <lambdabot> monochrom says: "point free" can be decomposed to: "point" refers to ".", "free" refers to using no "$". :)
10:37:52 <monochrom> :)
10:39:01 <ski> @pl \f -> f x
10:39:01 <lambdabot> ($ x)
10:39:29 <Welkin> :t ($)
10:39:31 <lambdabot> (a -> b) -> a -> b
10:39:42 <Welkin> lol, it's `id`
10:39:53 <monochrom> Yeah
10:39:55 <Welkin> those are fun tricks
10:40:01 <dysfun> wow, when they said "ghcjs will take a long time to build", they weren't kidding
10:40:14 <monochrom> > not `id` False
10:40:16 <lambdabot>  True
10:40:18 <Welkin> dysfun: you can install it in a couple minutes using reflex-platform
10:40:34 <Welkin> it downloads a cached binary
10:40:53 <Welkin> I never had any luck getting ghcjs to build properly, and I remember it taking 2-3 hours each time
10:40:56 <dysfun> this stack snapshot was supposed to
10:41:45 <dysfun> i was actually leaning towards transient rather than reflex
10:42:07 <Welkin> you can just use reflex-platform to install ghcjs
10:42:10 <Welkin> you don't have to use reflex
10:42:15 <Welkin> it is just a setup script
10:42:16 <dysfun>   hrm
10:42:38 <dysfun> oh god, nix
10:42:41 <Welkin> lol
10:42:43 <dysfun> i think i'll pass
10:42:47 <Welkin> it's not that bad
10:42:57 <dysfun> i used it as a desktop for a couple of months
10:42:59 <dysfun> i was not a fan
10:43:02 <Welkin> just run the script and it drops you into the nix-shell
10:44:21 * dysfun wonders if haskell is the appropriate language to build a nix-like thing in
10:44:52 <Welkin> nix-like?
10:44:53 <dysfun> then again, most of what one does in nix is in IO anyway...
10:44:53 <erisco> and here is the derivation I did, so you can see the fun it is :) http://lpaste.net/6428620848659169280
10:45:24 <dysfun> well, the most painful thing about nix for me was the nix language
10:45:43 <Gurkenglas> Is there some notion of a traversal that leaves nothing untraversed?
10:45:45 <monochrom> dysfun: There is the IO angle, yes. But there is also the data structure angle, I mean "how to be less error-prone with your data structures" angle.
10:46:02 <Gurkenglas> In the sense that there is no further decoration in the thing traversed over
10:46:21 <dysfun> at least if everything is in IO there are no questions about how to compose everything
10:47:21 <lyxia> Gurkenglas: so, something excluding (,) and Either?
10:47:51 <Gurkenglas> Yep. Actually I think it's exactly Each, indicating Each is missing a method
10:49:09 <dysfun> woot, ghcjs built
10:49:27 <Welkin> dysfun: what are you creating?
10:50:30 <monochrom> web browser :)
10:50:36 <dysfun> shiny calendaring
10:51:06 <Gurkenglas> spine :: Each s t a () => t -- Since we have all the information about t if we know its contents are all ()
10:51:29 <erisco> Fix (Compose Maybe (Join ((,,) a)))
10:52:02 <erisco> maybe that's not a pleasant way to work with binary trees... would views help? hrm
10:52:29 <monochrom> pattern synonyms will help. But yeah I didn't even see it's a binary tree.
10:52:42 <monochrom> Then again I don't know Join.
10:52:44 <lyxia> Gurkenglas: couldn't you have   Each (x, a) (x, ()) a ()
10:53:06 <erisco> it does like little join for functions
10:53:12 <Gurkenglas> No, that's not an instance of each lyxia
10:53:17 <erisco> Join :: (a -> a -> *) -> a -> *
10:53:20 <Gurkenglas> *of Each
10:53:44 <lyxia> Oh I see, there are fundeps
10:54:05 <lyxia> but there *is* s b -> t
10:54:14 <lyxia> So actually I don't see
10:54:43 <Gurkenglas> I'm saying that Each does not currently specify all that it conceptually tries to
10:55:04 <lyxia> Okay
10:56:07 <Gurkenglas> Only which of the equivalent additional methods should we add?
10:56:40 <Gurkenglas> Each s t () b => b -> t
10:57:40 <lyxia> how would that work with lists
10:58:14 <Gurkenglas> Shoot, you're right, I'm describing a subclass of Each
11:00:57 <Gurkenglas> > each .~ 2 $ undefined :: (Int, Int) -- heh, it appears this already works where it makes sense
11:01:00 <lambdabot>  (2,2)
11:03:15 <erisco> monochrom, I made it a bit better
11:03:27 <erisco> monochrom, type Tree l f n = Fix (Compose (Either l) (Compose ((,) n) f))
11:03:36 <c_wraith> huh.  The Each instance for (,) uses lazy pattern matching?
11:03:40 <erisco> type BinaryTree a = Tree () (Join (,)) a; type RoseTree a = Tree () [] a
11:04:15 <erisco> a while ago, maybe a couple years ago, I genericised Data.Tree... I could try and dig it up but I am too lazy... just rethinking it :P
11:05:49 <erisco> the point is that you can write all the algorithms more generically thanks to Foldable and Traversable and so forth
11:06:01 <Gurkenglas> erisco, I'd think RoseTree a = Tree Void [] a
11:06:02 <erisco> rose trees easily become a special case
11:06:25 <Gurkenglas> erisco, know of Free and Cofree?
11:06:29 <erisco> no, that'd be wrong because then you cannot construct a leaf
11:07:34 <Gurkenglas> erisco, that's deliberate https://en.wikipedia.org/wiki/Rose_tree
11:07:54 <c_wraith> Rose trees are a special case of Cofree already...
11:09:26 <erisco> weird, I don't remember them like that
11:09:38 <erisco> then I suppose so, yes
11:10:07 <iqubic> How does StateT Work?
11:10:15 <c_wraith> @src StateT
11:10:15 <lambdabot> Source not found.
11:10:52 <c_wraith> Well then.  newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }
11:11:04 <iqubic> Actually, let's start with a simple MonadTransformer: MaybeT
11:11:15 <c_wraith> in other words, a StateT value is a wrapper around a function.
11:11:22 <iqubic> Just so I can get a feel for MonadTransformers
11:11:49 <c_wraith> Ok.  First step then..  Are you comfortable with the Monad instance for Maybe?
11:12:20 <turnage> I want to introduce some random numbers to a project I'm working on which so far is mostly pure functions. Random numbers are ofc IO. I'm new to haskell and wondered what some approaches to this are? I would prefer not to change all the functions those numbers propagate to to IO.
11:12:23 <Gurkenglas> I've got three sketchtoy drawings of mine I regularly link to to explain State s, Maybe and StateT s Maybe, but ircbrowse is down, can someone find them?
11:12:24 <erisco> I see rose trees are an instance of Cofree, yup, neat
11:12:46 <Gurkenglas> It should be "sketchtoy" "State s" "Maybe" "StateT s" all in a single line with "Gurkenglas"
11:12:47 <c_wraith> turnage: don't use IO except for creating the seed.  Just pass a generator around instead.
11:13:12 <turnage> c_wraith: Ahhh. That's good.
11:13:29 <iqubic> c_wraith: I understand how the Maybe Monad works.
11:13:47 <zacharypch> Hey working through the nicta course now, kind of stuck on Applicative. So applicatives are pure + <*>.  what's <*> called?
11:13:49 <c_wraith> turnage: in some cases, you can get away with using randoms and just passing the infinite list around, too
11:14:02 <iqubic> How does the MaybeT Monad work/
11:14:22 <c_wraith> iqubic: so start with..  newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
11:14:28 <iqubic> Sure.
11:14:44 <iqubic> It's a Monad wrapped around a Maybe A
11:14:51 <c_wraith> iqubic: and see if you can write the following:  instance Monad m => Monad (MaybeT m)
11:14:58 <ertes> helo
11:14:59 <erisco> Free also accounts for some trees
11:15:00 <c_wraith> iqubic: it almost all follows from the types
11:15:09 <iqubic> What does?
11:15:15 <erisco> we can be more general than them both, though
11:15:25 <c_wraith> iqubic: the Monad instance I suggested
11:15:29 <iqubic> The usage of MaybeT?
11:15:51 <iqubic> I'll try to right the MaybeT Monad Instance.
11:16:04 <c_wraith> iqubic: just try writing the Monad instance I suggested.  I can't think of a better way to learn than just trying
11:16:09 <ertes> zacharypch: we sometimes call it "ap"
11:16:09 <turnage> c_wraith: Thanks!
11:16:13 <iqubic> I will
11:16:18 <ertes> zacharypch: because:
11:16:18 <ertes> :t ap
11:16:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
11:16:41 <iqubic> What is ap?
11:16:42 <chewzerita> @pl counter m = filter (not . hasDup . show) [1..m]
11:16:42 <chewzerita> @pl \m = [1..m]
11:16:42 <chewzerita> @pl \m -> [1..m]
11:16:42 <lambdabot> counter = filter (not . hasDup . show) . enumFromTo 1
11:16:42 <lambdabot> (line 1, column 4):
11:16:42 <lambdabot> unexpected "="
11:16:42 <lambdabot> expecting operator, pattern or "->"
11:16:42 <lambdabot> enumFromTo 1
11:17:38 <ertes> iqubic: haskell has this kind of "wiki effect", where you want to learn one thing, but then something else catches your attention, and you diverge, ultimately learning neither
11:17:48 <ertes> iqubic: i suggest that you stick with learning monad transformers now =)
11:17:56 <iqubic> Yeah.
11:18:11 <iqubic> ertes, I'll start with MonadTransformers
11:18:20 <Gurkenglas> zacharypch, you can read it ap and call it the sequential application operator
11:20:06 <iqubic> How do I write the return function for MaybeT?
11:20:18 <ertes> iqubic: what is a (MaybeT m a)?
11:20:35 <ertes> try to come up with a sentence
11:20:50 <iqubic> It is a Monad containing a Maybe a
11:21:19 <ertes> a monad doesn't contain
11:21:24 <ertes> let me rephrase the question
11:21:32 <ertes> what is a value of type (MaybeT m a)?
11:21:41 <iqubic> I don't know.
11:22:02 <ertes> it's an m-action with a result type of (Maybe a)
11:22:20 <iqubic> What's an m-action?
11:22:26 <ertes> so a (MaybeT IO Integer) is basically an IO (Maybe Integer)
11:22:28 <Welkin> monad transformer stacks are inside-out
11:22:35 <iqubic> I see.
11:22:39 <ertes> an IO action with a result type of (Maybe Integer)
11:22:46 <iqubic> So how do I write the return function for that?
11:23:05 <iqubic> Can I have MaybeT (Maybe Integer)?
11:23:14 <ertes> iqubic: return :: a -> MaybeT m a
11:23:15 <Welkin> iuhave you taken a look at the way they are written in mtl or transformers?
11:23:31 <iqubic> Welkin, I have not.
11:23:38 <ertes> iqubic: it takes a value and returns a pure (MaybeT m)-action with a result type of 'a'
11:23:45 <Welkin> read the sourcecode in base
11:23:49 <Welkin> it is very helpful to learn
11:23:53 <ertes> no, don't read the source code
11:23:55 <Welkin> it has tons of comments
11:24:03 <ertes> it will spoil pretty much every monad transformer exercise =)
11:24:20 <iqubic> I'm trying to write the MaybeT monad instance without looking at the source
11:24:52 <ertes> iqubic: write it piece by piece:  it's a function, right?
11:24:58 <ertes> return x = _
11:25:20 <iqubic> Well, it needs to be of type MaybeT
11:25:22 <ertes> now load this into GHCi and look at the error GHC gives you…  it will reveal the type of _
11:25:37 <zacharypch> ok, so i was trying to define <$>, and I arrived at `(<$>) g f = (pure g) <*> f`, but in testing when trying to use `Id 2` for example, it fails because there is not an instance of this Applicative for Id.  I wanted to use syntax such as `(<$>) g (Just a) = Just (g a)`, i.e. `(<$>) g (f a) = pure (g a)`?
11:25:46 <ertes> iqubic: (the "_" is called a typed hole…  GHC handles holes specially)
11:26:24 <iqubic> So I should just plug that into ghc and see what type it gives me?
11:26:34 <ertes> yeah
11:28:03 <iqubic> What module contains MaybeT?
11:28:36 <cocreature> iqubic: Control.Monad.Trans.Maybe
11:29:05 <cocreature> iqubic: hoogle is pretty good at answering this kind of question http://hoogle.haskell.org/?hoogle=MaybeT
11:29:46 <MarcelineVQ> note that if you just look at the answer you won't really learn it, better to ask more questions instead
11:30:22 <ertes> iqubic: define it yourself
11:30:37 <ertes> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
11:30:53 <dmj`> iqubic: using typed holes can help
11:31:14 <dmj`> instance Monad m => Monad (MaybeT m a) where return a = _a
11:31:31 <dmj`> Monad (MaybeT m)*
11:31:57 <ertes> iqubic: you can't use the predefined one anyway, because that one already has a Monad instance
11:33:46 <lpaste> iqubic pasted “MaybeT Monad” at http://lpaste.net/355085
11:33:51 <iqubic> That's what I came up with.
11:33:56 <iqubic> Does that work?
11:34:29 <ertes> iqubic: does GHCi like it?
11:34:49 <iqubic> GHCi loves it.
11:35:03 <ertes> it's also correct =)
11:35:19 <iqubic> Why does that work?
11:35:40 <ertes> (MaybeT m) is m with an extra short-circuiting effect
11:35:41 <iqubic> I cobbled that together by examining the types, but I have no idea how that works
11:35:51 <c_wraith> iqubic: welcome to using Haskell. :)
11:35:58 <c_wraith> iqubic: first you make it work, then you understand it
11:36:14 <c_wraith> sometimes there's a big gap in between :)
11:36:21 <ertes> look at your code and see what happens, if 'x' returns a Nothing
11:36:46 <iqubic> if x returns Nothing, then maybe_value = nothing
11:37:02 <c_wraith> edwardk describes the process as "using the compiler as a brain multiplier".  You can write code you're not smart enough to write because the compiler makes sure you got it right.
11:37:16 <iqubic> Therefore we run return Nothing.
11:37:22 <ertes> iqubic: now 'f' is in a sense the "continuation", the action that should "follow" x
11:37:32 <ertes> iqubic: how do you use f, if x returns Nothing?
11:37:44 <iqubic> ertes: You can't
11:37:53 <ertes> iqubic: exactly…  you don't use it at all
11:38:19 <iqubic> Right. Which Monad's return function is being called in return Nothing?
11:38:23 <iqubic> Is it m's
11:38:24 <ertes> iqubic: now try this with a real example…  write the following action:  getNonEmptyLine :: MaybeT IO String
11:38:32 <ertes> yes
11:38:51 <iqubic> ertes: I'm not sure how to use MaybeT in a real example.
11:38:54 <ertes> write getNonEmptyLine such that it only returns non-empty lines
11:39:08 <iqubic> And Nothing otherwise?
11:39:18 <ertes> if the user enters an empty line, it should "abort" (by returning Nothing)
11:39:24 <dmj`> iqubic: providing explicit annotations can be really helpful as well
11:39:29 <dmj`> iqubic: http://lpaste.net/8231308482096136192
11:39:45 <dmj`> since most types are inferred, it’s easy to “gloss over” their definitions
11:40:18 <ertes> it's really unfortunate that you need ScopedTypeVariables for those annotations
11:40:29 <iqubic> What does RunMaybeT do?
11:40:29 * ski . o O ( `forever (liftIO putStrLn =<< getNonEmptyLine)' )
11:40:32 <ertes> but you can use InstanceSigs to write regular type signatures
11:40:38 <dmj`> ertes: agreed, oh and TypeInstanceSigs
11:40:43 <ertes> iqubic: look at its type
11:40:51 <dmj`> derp, instance sigs?
11:40:57 <ertes> dmj`: InstanceSigs
11:41:14 <iqubic> :t RunMaybeT
11:41:16 <lambdabot> error:
11:41:16 <lambdabot>     • Data constructor not in scope: RunMaybeT
11:41:16 <lambdabot>     • Perhaps you meant variable ‘runMaybeT’ (imported from Control.Monad.Trans.Maybe)
11:41:19 <dmj`> ertes: they all blur together at some point
11:41:22 <iqubic> :t runMaybeT
11:41:25 <lambdabot> MaybeT m a -> m (Maybe a)
11:41:33 <ertes> iqubic: do you see what it does?
11:41:37 <iqubic> I don't understand that.
11:41:48 <ertes> iqubic: you might call it "unwrapMaybeT"
11:42:29 <Aruro> iqubic: transofrmer is nothing else but a type wrapper, so functions are need to take stuff out
11:42:33 <iqubic> So it runs the m action?
11:42:45 <ertes> iqubic: imagine you had written this:  newtype MaybeT m a = MaybeT (m (Maybe a))
11:42:56 <iqubic> Sure. Sounds good.
11:42:57 <ertes> iqubic: then you had written a function:  runMaybeT (MaybeT c) = c
11:43:09 <ertes> it just removes the MaybeT constructor
11:43:13 <iqubic> Oh.
11:43:24 <ertes> the "run" bit of the name is just a convention
11:43:25 <dmj`> iqubic: when you define a data type like "data F a = F { unF :: a }” the first argument of the record field will always be its data constructor, in this case unF :: F a -> a, `runMaybeT` works the same way. MaybeT m a -> m (Maybe a)
11:43:30 <iqubic> So I use that, and then I can run the funtion.
11:43:37 <Aruro> iqubic: did u investigate haskell book's monad transformers chapter?
11:43:46 <iqubic> Aruro: No.
11:43:58 <Aruro> iqubic: haskell wiki book, free good and nice
11:44:07 <ertes> iqubic: write getNonEmptyLine, then you will learn how to use runMaybeT
11:44:30 <iqubic> What's the tyoe signature I'm going for?
11:44:40 <ertes> iqubic: getNonEmptyLine :: MaybeT IO String
11:44:55 <iqubic> Wait, no inputs are taken?
11:45:02 <ertes> what inputs would you take?
11:45:37 <iqubic> So that is an IO action that returns a Maybe Strign?
11:45:47 <iqubic> s/Strign/String
11:45:49 <ertes> yeah, except wrapped by MaybeT
11:45:59 <iqubic> Why not just us IO (Maybe String)?
11:46:15 <ertes> because then you would be using (>>=) of IO, not of (MaybeT IO)
11:46:19 <Aruro> iqubic: did you understand Maybe instance of a Monad? :)
11:46:28 <iqubic> Aruro: I did.
11:46:37 <Aruro> iqubic: so? Maybe + IO
11:46:42 <ertes> iqubic: the only reason you define the wrapper type is to be able to use a different Monad instance
11:46:50 * ski points upward to `forever' example
11:47:17 <iqubic> Wait. What the heck would MaybeT [] Integer be?
11:47:26 <iqubic> Because I think that's possible to have.
11:47:34 <ertes> iqubic: we can look at that later…  focus =)
11:47:39 <iqubic> I will.
11:47:59 <ertes> iqubic: yes, it is possible…  MaybeT will work with any monad
11:48:20 <Aruro> iqubic: why not wiki book, irc is not productive to learn
11:48:30 <ertes> iqubic: since that's how you defined it:  "instance (Monad m) => Monad (MaybeT m)"
11:48:51 <simony> i think it's important to note that monads don't compose which is the motivation for transformers
11:49:51 <simony> so the reason for that getNonEmptyLine is for further composition w/ other things that may be IO (Maybe a) type things. it probably isn't much interesting on its own?
11:50:43 <ertes> getNonEmptyLine is just an exercise…  you wouldn't write/use it in practice, but you would just use 'guard'
11:51:15 <ertes> do line <- liftIO getLine; guard (not (null line)); …
11:51:33 <iqubic> getNonEmptyLine = do line <- getLine; if line == "" then MaybeT $ return Nothing; else MaybeT $ return $ Just line
11:51:42 <iqubic> I really don't think my thing works.
11:51:49 <ertes> iqubic: feed it to GHCi
11:51:55 <ski> type error
11:52:10 <ski> (`IO' doesn't match `MaybeT IO')
11:52:22 <iqubic> What do you mean?
11:52:32 <iqubic> How should I write this function?
11:52:43 <ski> (it's not a function, it's an action)
11:53:02 <ertes> iqubic: type this into a source file after its type signature:  getNonEmptyLine = _
11:53:08 <ski> `getLine' has type `IO String', so that whole `do'-expression must then have type `IO X', for some type `X'
11:53:09 <ertes> then see what GHCi tells you about _
11:53:24 <ski> but `if line == "" then MaybeT $ return Nothing; else MaybeT $ return $ Just line' has type `MaybeT IO String' ..
11:53:39 <iqubic> Ertes: I will try that.
11:54:05 <iqubic> ski: So my if statement is correct?
11:54:21 <ski> depends on what you mean by "correct"
11:54:43 <ertes> iqubic: once you have that keep in mind that there is only one way (apart from 'return') to construct a MaybeT action:  the MaybeT constructor
11:55:21 <ski> a type inconsistency involves at least two locations in the source. at least one of them needs to be changed in order to avoid the inconsistency
11:55:44 <ski> sometimes one can solve the problem by either changing one location (and perhaps something more), or the other location (and perhaps something more)
11:56:16 <iqubic> Ertes: How would you write getNonEmptyLine? Using an if statement like I did.
11:56:50 <ertes> iqubic: the 'if' is not the problem…  it's fine to use it
11:57:19 <ski> iqubic : it's the interaction of that `if' (or rather the `then' and `else' branches of it) with the `getLine' (mediated by the surrounding `do'-expression) which causes the inconsistency here
11:57:19 <iqubic> So does my if statement have the right type?
11:57:35 <ski> depends on whether and how you change the rest of the definition
11:57:36 <iqubic> I have no idea how to fix that.
11:57:49 <ertes> iqubic: i strongly suggest that you tackle this problem piece by piece: don't start with a full non-solution and convert it into a solution, but start with an incomplete solution
11:57:59 <ertes> iqubic: again, type this:  getNonEmptyLine = _
11:58:13 <ertes> i will show you how you can use GHCi to guide you to the correct solution
11:58:30 <iqubic> Alright. Do I type that into a new source file?
11:58:42 <ertes> iqubic: the one that contains your MaybeT implementation
11:58:49 <ski> i could say that your `if' has the right type. i could also say that it has the wrong type. it depends on how the rest of the code will be changed
11:59:00 <ski> possibly it will be simpler to follow ertes' recommendation
11:59:13 <Aruro> isnt there haskell-beginners channel?
11:59:24 <dmj`>  yea #haskell-beginners
11:59:27 <ski> beginner questions are welcome here
11:59:27 <iqubic> I'm supposed to put my MaybeT definition into a new file?
11:59:30 <iqubic> I can do that?
11:59:36 <iqubic> I can indeed do that.
11:59:38 <Aruro> ski: it becomes a good lesson
11:59:44 <Aruro> or a lecture
11:59:51 * ski nods
12:00:06 <ertes> iqubic: you should…  i recommend always to use a real source file…  dumping everything into GHCi gets unwieldy very quickly, and you can't easily change definitions
12:00:16 <iqubic> I'll do that.
12:01:26 * ski idly wonders whether iqubic instanced `MonadIO' yet
12:01:35 <ertes> ski: i don't think so
12:01:41 <iqubic> I haven't
12:01:53 <Aruro> somebody hates books ..
12:02:01 * ski likes books
12:02:02 <ertes> iqubic: once you have the source file, just load it into GHCi…  whenever you make a change, just type ":r", and GHCi will reload
12:03:18 <iqubic> Alright, what does MaybeT look like.
12:03:31 <iqubic> Shouldn't it be a newtype
12:03:38 <ertes> iqubic: yes
12:03:42 <ertes> @src MaybeT
12:03:42 <lambdabot> Source not found. My mind is going. I can feel it.
12:03:44 <ski> <ertes> iqubic: imagine you had written this:  newtype MaybeT m a = MaybeT (m (Maybe a))
12:04:05 <ertes> iqubic: use this one:  newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
12:04:06 <ski> well, even
12:04:07 <ski> <ertes> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
12:04:11 <ertes> it gives you runMaybeT for free
12:10:57 <iqubic> Alright so I've written out MaybeT in a source file. GHC-mod is telling me that I haven't written an applicative instance for MaybeT.
12:11:16 <ertes> see, that's why you really need to use proper source files =)
12:11:17 <Aruro> neither u have writetn functor
12:11:32 <ertes> Monad is a subclass of Applicative:  class (Applicative m) => Monad m
12:11:48 <iqubic> ertes: What would the Applicative Class for this look like?
12:11:58 <ertes> iqubic: start by writing a Functor instance
12:12:15 <iqubic> What do I need in the Functor instance?
12:12:29 <ertes> iqubic: you need to define 'fmap' for (MaybeT m)
12:12:49 <iqubic> How would that work?
12:13:10 <ertes> iqubic: class Functor f where fmap :: (a -> b) -> f a -> f b
12:13:15 <iqubic> Right.
12:13:17 <ertes> iqubic: now (f = MaybeT m)
12:13:54 <iqubic> And I need to write something like instance Monad m => Functor (MaybeT m)
12:14:14 <ertes> iqubic: you don't need m to be a monad to implement fmap
12:14:16 <ski> `Functor', not `Monad'
12:14:33 * ski 'd rename `m' to `f'
12:14:40 <Aruro> and people ask why haskell has a hight learning curve
12:14:55 <ertes> only Applicative and Monad need m to be a monad here
12:14:56 <koala_man> what's a good way of parsing regex where "$" can be both literal and an anchor? separate lexing pass that identifies contexts or just lookaheads? 
12:15:37 <andrei> What's the right way to use makeLenses and makeFields on external data types that don't have fields? I'd like to somehow provide my own names for their arguments.
12:16:48 <iqubic> So what type signature do I need for fmap?
12:17:06 <ertes> iqubic: i told you
12:17:08 <ski> ertes already gave the signature for `fmap'
12:17:20 <kamyar> Hi all
12:17:21 <ski> you just need to specialize it, as indicated
12:17:37 <kamyar> Just a somehwat simple question:
12:17:56 <kamyar> (*3) <$> Just 7 gis Just 21
12:17:59 <kamyar> gives
12:19:06 <kamyar> Sorry! Solved!
12:19:15 <ski> heh, ok
12:19:17 <ertes> =)
12:19:32 <iqubic> So How will I specialize this?
12:19:47 <ski> old trick of realizing how to solve a problem, when figuring out how to explain it
12:19:54 <ertes> iqubic: f = MaybeT m
12:20:19 <iqubic> sure.
12:20:25 <iqubic> I realize that.
12:20:37 <ski> good
12:20:47 <ertes> iqubic: if (f = MaybeT m), then what's the type of fmap for (MaybeT m)?
12:21:16 <iqubic> :t fmap
12:21:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:21:49 <iqubic> (a -> b) -> MaybeT m a -> MaybeT m b
12:21:58 <ertes> iqubic: correct
12:22:22 <Myrl-saki> EvanR: I gave it some thought.
12:22:51 <Myrl-saki> EvanR: columns :: (forall a. (m b -> m (a, b)) -> m (a, b)) -> m b
12:23:00 <iqubic> but how do I do anything with that?
12:23:20 <ertes> iqubic: well, first you need to implement it =)
12:23:21 <ski> follow the types
12:23:30 <Myrl-saki> That'd make sense, right?
12:23:46 <Myrl-saki> (What I was doing.)
12:23:53 <Myrl-saki> Basically, I want to enforce the usage of the argument.
12:23:56 <kamyar> ok
12:23:58 <ertes> iqubic: write the following template:  instance (Functor m) => Functor (MaybeT m) where fmap f c = _
12:24:04 <kamyar> I get the question now:
12:24:15 <ertes> (ski: i don't want to rename m right now)
12:24:20 <kamyar> newtype TokenInfo = TokenInfo {token :: String}
12:24:45 <kamyar> Now I want to use TokenInfo on a IO String instead of String and get IO TokenINfo
12:25:05 * ski . o O ( "Follow the types. Follow Follow Follow Follow Follow the types!" )
12:25:26 <Myrl-saki> I actually worked.
12:25:28 <ertes> iqubic: comment out the Monad instance, so GHCi doesn't yell at you
12:25:34 <ski> kamyar : use `fmap' or `<$>' ?
12:25:59 <kamyar> ski: Does not work!
12:26:01 <Myrl-saki> I think "just follow the types" is some kind of subliminal Haskell message. :D
12:26:06 <monochrom> "Follow the types, wherever they lead you."  -- Neil DeGrasse Typson
12:26:20 <ertes> kamyar: TokenInfo :: String -> TokenInfo
12:26:47 <iqubic> If I unbox a MaybeT and it turns out to be a Nothing, what do I do then?
12:26:58 <kamyar> ertes: Now I want IO String -> IO TokenInfo
12:27:01 <ski> @remember NeilDeGrasseTypson "Follow the types, wherever they lead you."
12:27:02 <lambdabot> Okay.
12:27:10 <ski> kamyar : does too !
12:27:14 <ertes> kamyar: yeah…  there is a function for that
12:27:25 <ertes> kamyar: ski told you two of its many names
12:27:39 <kamyar> ertes: Does not work!
12:27:52 <kamyar> TokenInfo <$> IO "test"
12:27:54 <ski> it works in *my* head ..
12:27:58 <ertes> kamyar: well:  fmap TokenInfo :: IO String -> IO TokenInfo
12:28:06 <kamyar>  Data constructor not in scope: IO :: [Char] -> f String
12:28:08 <ski> `IO' is a type, it shouldn't be put in value expressions
12:28:12 <ertes> kamyar: what's 'IO "test"'?
12:28:25 <iqubic> What do I do with fmap if the MaybeT given happens to be Nothing?
12:28:26 <ski> (this is what you get, by naming data constructors and type constructors the same ..)
12:28:36 <kamyar> ertes: Yes u r right.
12:28:37 <ertes> iqubic: nothing
12:28:43 <kamyar> I have to send main code
12:28:43 <ski> ertes : beat me to it :)
12:29:06 <iqubic> So how do I write that Ertes?
12:29:10 <Myrl-saki> columns :: MonadWidget t m => [Text] -> (forall a. ([Text] -> m b -> m (a, b)) -> m (a, b)) -> m b
12:29:18 <Myrl-saki> Is there a better way to enforce the usage of the passed function?
12:29:28 <Myrl-saki> I'm currently doing `(,) undefined <$> divClass (T.unwords $ "column":classes) inner`
12:29:32 <Myrl-saki> For the passed function.
12:29:47 <ertes> iqubic: if the action returns Nothing, just return Nothing
12:29:56 <ertes> iqubic: much like fmap for Maybe does
12:30:00 <ertes> > fmap (^2) Nothing
12:30:03 <lambdabot>  Nothing
12:30:14 <ski> kamyar : the `Functor m' constraint on the `instance' declaration should give you a hint that you'll probably need to use `fmap' for `m' somewhere ..
12:30:20 <iqubic> But I don't have the return function availible to me when writing fmap.
12:30:27 <ski> er, sorry, that was meant for iqubic
12:30:38 <ski> you don't need `return'
12:30:43 <ertes> Myrl-saki: i'm answering without any context: if you want to ensure that a function is used, use either parametricity, or create a type, values of which can only be returned by that function
12:30:57 <ertes> iqubic: you do have fmap
12:31:04 <ertes> because m is a Functor
12:31:04 <iqubic> So...?
12:31:13 <iqubic> I don't understand what to do?
12:31:40 <iqubic> I know that I have fmap.
12:31:45 <ertes> iqubic: fmap f (MaybeT c) = MaybeT (_ c)  -- you need to do something to c, right?
12:31:46 <iqubic> I don't see how that helps me.
12:31:47 <Myrl-saki> ertes: Am I not using parametricity there? (with te forall a.)
12:31:53 <ski> iqubic : consider `fmap f c = ?0', what is the expected type of the "hole" `?0' (not actual syntax) ?
12:32:15 <iqubic> The hole needs type MaybeT m b
12:32:38 <iqubic> where b is the result of f.
12:32:40 <ski> yes, how do you construct a value of that type ?
12:33:02 <ertes> iqubic: feel free to type what i gave you as the definition of fmap
12:33:07 <ertes> then GHCi will give you a type for _
12:33:25 <ski> ertes jumped slightly ahead. feel free to continue from either
12:35:01 <iqubic> Looks like I need something of MaybeT m a -> m (MaybeT b)
12:35:11 <iqubic> That will fill my hole properly.
12:35:12 <ski> yep
12:35:23 <ski> now, what's the type of `c' ?
12:35:30 <iqubic> Now, how do I get that?
12:35:35 <ertes> not quite
12:35:45 <ski> ertes : they used a mixture of both ..
12:36:03 <ertes> the type iqubic gave is a kind error
12:36:20 <ski> they probably just mistyped it over here
12:36:23 * ski looks at iqubic
12:36:37 <ertes> yeah, but it makes me wonder whether they continued from your point or mine =)
12:36:47 <ski> <ski> ertes : they used a mixture of both ..
12:36:48 <iqubic> ertes, I just put it into GHCi. I need MaybeT m a -> m (MaybeT b)
12:37:04 <ski> (as i said ..)
12:37:19 <ertes> iqubic: don't put it into GHCi though…  write it into your source file
12:37:39 <iqubic> Alright. What I have so far is this: fmap f x = MaybeT $ (_ x)
12:37:51 <ski> `$' is redundant there
12:37:52 <ertes> the ($) is not necessary
12:38:00 <iqubic> Yeah I know.
12:38:03 <ski> now, what's the type of `x' ?
12:38:13 <iqubic> x is MaybeT m a
12:38:18 <ski> can you match on it ?
12:38:26 <iqubic> Possible.
12:38:29 <iqubic> Not sure how.
12:38:36 <ertes> do you happen to have a function of type (MaybeT m a -> m (Maybe a))?
12:38:54 <ski> iqubic : how would you construct a value of type `MaybeT m a' ?
12:39:04 <iqubic> ertes: Isn't that just fmap
12:39:09 <ertes> nope
12:39:32 <iqubic> ertes: It's runMaybeT
12:39:33 * ski points out to iqubic that they're trying to *write* `fmap' at the moment ;)
12:39:40 <ertes> iqubic: the problem here is that 'x' is still MaybeT-wrapped, but you need the underlying (m (Maybe a))
12:39:50 <ertes> and there are two ways to "unwrap" MaybeT
12:39:56 <iqubic> ertes: I'm going to use runMaybeT
12:40:03 <ertes> yeah, that's one option
12:40:15 <ertes> here is one that is a bit nicer:  fmap f (MaybeT c) = MaybeT (_ c)
12:40:37 <ertes> at least if our senses of aesthetics are compatible =)
12:40:58 <ski> (generally, it's usually nicer to pattern-match, if you can do so in a non-contrived way)
12:41:28 <iqubic> Alright. I now have this: fmap f (MaybeT x) = MaybeT $ (_ x)
12:41:41 <ertes> iqubic: now what does GHCi tell you about _?
12:41:52 <iqubic> To fill in the hole I need something of type m (Maybe a) -> m (Maybe b)
12:42:11 <iqubic> How will I get that?
12:42:14 <ertes> yeah…  and there is a way to construct such a function, right?
12:42:19 <ertes> because m is a Functor
12:43:06 <iqubic> I think there is.
12:43:14 <iqubic> :t fmap
12:43:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:43:28 <ertes> yeah, and what are 'f', 'a' and 'b' in this case?
12:44:08 <iqubic> f is MaybeT. a and b are just the input and output of my function f from fmap f (MaybeT x)
12:44:13 <ertes> nope
12:44:32 <Myrl-saki> Is there something like Vault, but doesn't require IO/ST?
12:44:42 <iqubic> No? Ertes, how am I wrong?
12:44:54 <ertes> Myrl-saki: Map _ Dynamic
12:45:07 <Myrl-saki> ertes: I'm not sure if I should...
12:45:08 <Myrl-saki> =_=
12:45:25 <Myrl-saki> ertes: But that seems correct though. :(
12:45:33 <ertes> iqubic: see, you need an (m (Maybe a) -> m (Maybe b))
12:45:34 <ski> iqubic : the `f' in `fmap' would not be `MaybeT' in your situation
12:46:03 <ertes> iqubic: so a function that, given an m-action returns another m-action
12:46:12 <ertes> Myrl-saki: you might be able to use dependent-map
12:46:16 <iqubic> Isn't that just fmap.
12:46:28 <ertes> iqubic: yeah, but not fmap for (MaybeT m)
12:46:39 <ertes> f is not (MaybeT m) here
12:46:58 <iqubic> It's fmap for the m in instance functor m => (MaybeT m)
12:47:02 <Myrl-saki> ertes: Thanks. :D
12:47:06 <ertes> iqubic: exactly
12:47:14 <ertes> iqubic: now what are 'a' and 'b'?
12:47:20 <iqubic> I don't know.
12:47:37 <ertes> iqubic: you do…  let's use different names to make it less confusing:
12:47:44 <ertes> fmap :: (x -> y) -> m x -> m y
12:47:51 <iqubic> Alright.
12:47:54 <ertes> you need:  m (Maybe a) -> m (Maybe b)
12:48:03 <iqubic> Okay?
12:48:11 <ertes> using which x and y would give you such a function?
12:48:56 <iqubic> a and b?
12:49:08 <ertes> iqubic: nope
12:49:15 <iqubic> Can you just tell me.
12:49:23 <ertes> iqubic: i'll give you a hint:
12:49:23 <iqubic> I have no effing clue here.
12:49:33 <ertes> fmap f :: m x -> m y
12:49:36 <ertes> where f :: x -> y
12:49:43 <iqubic> Alright.
12:49:48 <ertes> you need:
12:49:48 <iqubic> So what f do I use?
12:49:49 <ski> (better to rename `f')
12:49:58 <ertes> oh, yeah
12:50:04 <ertes> fmap g :: m x -> m y
12:50:08 <ertes> where g :: x -> y
12:50:12 <ertes> you need:
12:50:18 <iqubic> Sure. Sounds good.
12:50:19 <ertes> fmap g :: m (Maybe a) -> m (Maybe b)
12:50:34 <ski> solve the equation
12:50:35 <ertes> what are x and y?
12:50:39 <ski>   m (Maybe a) -> m (Maybe b)  =  m x -> m y
12:50:53 <iqubic> Maybe a and Maybe b?
12:50:58 <ertes> yeah
12:51:01 <ski> (treat `m',`a',`b' as constants, if you care about that)
12:51:13 <ertes> so the missing piece is g
12:51:16 <iqubic> Alright where do I get the Maybe a and Maybe b?
12:51:18 <ski> what type will `g' have then ?
12:51:34 <iqubic> g will have type Maybe a -> Maybe b
12:51:37 <ski> right
12:51:40 <ertes> fmap f (MaybeT x) = MaybeT (fmap _g x)
12:51:50 <ertes> now GHCi will confirm that:  _g :: Maybe a -> Maybe b
12:51:53 <ski> now, can you write `_g' ?
12:52:16 <ski> (or fill the hole, if you prefer that terminology)
12:52:37 <ertes> for that you might find it useful that Maybe is also a functor
12:53:08 <ski> (one could also use plain pattern-matching)
12:53:23 <iqubic> Alright. I need to write a function of type Maybe a into Maybe b
12:53:37 <ski> yes. given which pieces of information ?
12:53:54 <iqubic> given a function f of type (a -> b)
12:54:07 <iqubic> and Maybe a
12:54:28 <iqubic> I think I can do that
12:54:41 * ski nods
12:54:56 <dmj`> @typ fmap :: (a -> b) -> Maybe a -> Maybe b
12:54:58 <lambdabot> (a -> b) -> Maybe a -> Maybe b
12:55:06 <iqubic> Wait, what I just described sounds a lot like fmap.
12:55:14 <ski> <ertes> for that you might find it useful that Maybe is also a functor
12:55:17 <iqubic> LOL
12:55:24 <ertes> iqubic: yeah, you're staring to see the patterns =)
12:55:38 <ertes> the matrix is revealing itself to you =)
12:56:28 <ski> with some practice, you should be able to play this game of "figure out type of hole, plug it partially, repeat" without asking the interactor for the types as much
12:57:38 <ertes> Myrl-saki: i made a few experiments, and i think that Vault can only be safe as it is in IO/ST
12:58:02 <iqubic> Well I think I just wrote fmap for MaybeT
12:58:08 <iqubic> GHCi likes it.
12:58:17 <ertes> Myrl-saki: otherwise you really need something like dependent-map or just live with dynamic typing
12:58:47 <ertes> iqubic: great…  it was a long way, but this will really help you in the future
12:58:54 <iqubic> :t fmap f (MaybeT x) = MaybeT $ fmap (fmap f) x
12:58:56 <lambdabot> error:
12:58:56 <lambdabot>     parse error on input ‘=’
12:58:56 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
12:59:05 <iqubic> fmap f (MaybeT x) = MaybeT $ fmap (fmap f) x
12:59:10 <iqubic> Is that correct.
12:59:11 <iqubic> ??
12:59:14 <ertes> iqubic: yeah
12:59:23 <iqubic> Now, how the heck does that work?
12:59:30 <iqubic> Why do I need fmap twice?
12:59:34 <Myrl-saki> ertes: I see.
12:59:44 <ertes> iqubic: because you have two functor layers to cross
12:59:54 <iqubic> I do? Which layers?
12:59:56 <ertes> iqubic: one is the m layer, the other is the Maybe layer
13:00:12 <iqubic> Ah. I see.
13:00:40 <iqubic> Now. Time to work on the applicative instance.
13:00:44 <ertes> iqubic: now write the Applicative instance:  instance (Monad m) => Applicative (MaybeT m)
13:01:54 <iqubic> Well, Pure was simple as heck.
13:02:20 <ertes> iqubic: once you wrote 'pure', you can remove 'return' from the Monad instance…  they are the same function
13:02:25 <iqubic> I just stole the definition from the return function.
13:02:56 <ertes> 'return' defaults to:  return = pure
13:03:24 <iqubic> Now for f <*> x I need a something of type MaybeT m b
13:03:43 <iqubic> where m is monad and b is err... somthing.
13:03:46 <ertes> iqubic: yeah, and since 'f' and 'x' are both MaybeT-valued, you can pattern-match right away
13:03:57 <ertes> MaybeT cf <*> MaybeT cx = _
13:03:58 <iqubic> :t <*>
13:04:00 <lambdabot> error: parse error on input ‘<*>’
13:04:04 <iqubic> :t (<*>)
13:04:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:04:45 <iqubic> Isn't this the exact same as fmap from here?
13:04:56 <c_wraith> not quite.
13:05:04 <c_wraith> the (a -> b) is inside an f
13:05:20 <iqubic> so I extract that, then it becomes the same as fmap.
13:05:35 <c_wraith> In your case, yes.
13:05:49 <ertes> iqubic: there are actually two possible semantics for (<*>)…  keep in mind that you want short-circuiting semantics
13:05:50 <c_wraith> There are cases where there's nothing to extract, which makes it more interesting :)
13:06:17 <ertes> i.e. if the first action returns Nothing, the second action should be ignored
13:06:31 <ski> (three possible, i suppose)
13:06:40 <iqubic> ertes, only on of the inputs of <*> is an action.
13:06:43 <ertes> yeah, at least two
13:06:48 <ertes> iqubic: no, both are
13:06:53 <ertes> look at the type
13:07:16 <iqubic> I see the action of (a -> b) and the action of a
13:08:26 <ski> yep
13:08:43 <iqubic> So what do I do with <*>?
13:08:58 <ertes> iqubic: use the same approach as before
13:09:03 <ski> run action, check result ?
13:09:07 <ertes> MaybeT cf <*> MaybeT cx = _
13:09:33 <ertes> if you think that the first layer of _ is obvious, just fill it in and leave a new hole
13:09:50 <iqubic> I need something of type m (Maybe b)
13:10:06 <ski> yes
13:10:09 <ertes> does GHCi agree?
13:10:42 <iqubic> ertes, I'm only going to list the type signature after checking it with GHCi
13:11:19 <ertes> ok, now there is only one way to get a value of type 'b'
13:11:29 <iqubic> run the function f.
13:11:35 <iqubic> That's the only way to do it.
13:11:51 <ertes> the way you wrote it 'f' is not a function
13:12:01 <iqubic> where f comes from MaybeT f <*> MaybeT x
13:12:08 <ertes> i suggest that you rename it to cf or something
13:12:11 <iqubic> I will
13:12:36 <iqubic> So I need to run cf to get a result of b.
13:12:52 <ertes> cf gives you a result of what type?
13:13:38 <iqubic> Maybe b
13:15:12 <iqubic> Now what do I do with that Maybe b?
13:16:14 <Lokathor> pattern match on it
13:16:22 <iqubic> I'll try that.
13:16:36 <Lokathor> i haven't been following along one bit, but that's my default response
13:16:48 <Lokathor> you might want a smarter funciton than that, depending on context :P
13:17:05 <ij> I've a record R with a field F and an «F -> Maybe F». How do I make this into «R -> Maybe R»?
13:17:22 <laserpants> In haddock, I am trying to create a link to an anchor, but there seems to be no way to change the link description. Is there some other way to create a link to some point within the same page? E.g., to a title == MyTitle, or using the $ annotation?
13:17:28 <ertes> iqubic: wrong
13:17:36 <ertes> cf has a different result type
13:17:48 <glguy> ij: Apply the lens corresponding to that field to that function
13:17:58 <iqubic> Right. It appears to be m (Maybe b)
13:18:06 <iqubic> Where m is a monad
13:18:53 <glguy> ij: For example: _1 :: (a -> Maybe a) -> (a,b) -> Maybe (a,b)
13:18:59 <ertes> iqubic: nope, but you don't need to guess here…  look at the hole error GHCi reports
13:19:08 <ertes> iqubic: it actually shows you the type of 'cf'
13:19:54 <iqubic> Right. m (Maybe (a -> b)) is the type of cf
13:20:34 <ertes> iqubic: so:  MaybeT cf <*> MaybeT cx = MaybeT (do mf <- cf; _)
13:21:01 <ertes> iqubic: you can use do-notation, because m is a monad
13:21:33 <iqubic> Right.
13:23:09 <iqubic> How do I get a value of m (Maybe b)
13:23:35 <EvanR> :t return Nothing
13:23:37 <lambdabot> Monad m => m (Maybe a)
13:23:47 <iqubic> Oh. I see what to do.
13:25:34 <iqubic> Wait, no. No I don't/
13:27:07 <ertes> iqubic: first you need to check whether cf actually gave you a function by pattern-matching on mf
13:27:18 <ij> glguy, Huh! So no Control.Lens functions, I just use lens. Wow.
13:27:49 <iqubic> So I pattern match on mf and get either a Nothing or a Just val.
13:27:59 <iqubic> What do I do with those?
13:28:09 <ski> think about what you *can* do in each case
13:28:27 <iqubic> Well in the case of Nothing, I can't do anything.
13:28:44 <ski> well, you have to give a result of .. which type ?
13:29:08 <glguy> ij: If you want to use something from Control.Lens, you can use traverseOf (which is implemented as 'id')
13:29:09 <iqubic> I have to give a result of m (Maybe b)
13:29:23 <ski> yes
13:29:34 <ertes> iqubic: what are your option to get a value of type 'b'?
13:29:41 <ertes> *options
13:30:08 <iqubic> Ertes, I don't know.
13:30:27 <ertes> iqubic: is there anything that would give you a value of type 'b'?
13:30:28 * ski . o O ( "What, you mean a european option or an american option?" )
13:31:20 <iqubic> I think that mf would give me a type of b
13:31:52 <ertes> iqubic: if it happens to be Just, it gives you a function that returns a 'b'
13:32:07 <ertes> iqubic: what if it's Nothing?
13:32:23 <iqubic> I can only do return Nothing.
13:32:28 <ertes> yeah
13:32:41 <iqubic> But what do I do if I get a Just?
13:32:46 <ertes> well, you could run cx, but you couldn't do anything with its result
13:32:58 <ertes> first handle the Nothing case
13:33:08 <ertes> leave a hole for the Just case
13:34:28 <iqubic> Alright, I have narrowed down my type holes to needing something of type a.
13:34:37 <iqubic> I have the function of (a -> b)
13:34:46 <iqubic> but now I need the a to supply it.
13:35:03 <ertes> correct, now in the Just case you might be able to construct something of type 'a'
13:35:11 <ertes> that's where cx comes in
13:35:21 <ertes> (or whatever you called it)
13:35:38 <iqubic> Yeah. But how do I unbox that
13:35:51 <ertes> paste what you have right now
13:35:55 <iqubic> cx currently has the type of m (Maybe a)
13:36:54 <ertes> so:  you need an (m (Maybe b)), and you have an (m (Maybe a))
13:37:01 <ertes> as well as a function of type (a -> b)
13:37:05 <ertes> does that sound familiar?
13:37:18 <iqubic> http://termbin.com/mnak
13:37:24 <iqubic> That hole has type a
13:37:56 <ertes> return to this:  Just func -> _
13:38:07 <ertes> there is no way to get an 'a' there
13:38:20 * ski suggests reverting `return $ Just $ func _' back to `_', continuing from there with this new information
13:38:49 <ertes> you solved your way into a dead end =)
13:38:57 <iqubic> If I have Just func -> _ then I need something of type m (Maybe B)
13:39:04 <ertes> yeah
13:39:18 <ski> now you know that you'll probably need `cx' in there
13:39:30 <ertes> you have (cx :: m (Maybe a)), and you need (m (Maybe b))
13:39:30 <ski> how can you use it, in a sensible way ?
13:39:36 <ertes> you also have (func :: a -> b)
13:39:38 <iqubic> Bind?
13:39:41 <ertes> does that sound familiar?
13:39:42 <ski> that's one way
13:40:25 <iqubic> No. I don't think that bind works
13:40:40 <ertes> "you have an X, and you need a Y" is basically the same as: "you need an X -> Y"
13:40:46 <iqubic> Sure.
13:40:49 <iqubic> How do I do that?
13:40:56 <ertes> so you have:  func :: a -> b
13:41:06 <iqubic> I just use func?
13:41:08 <ski> remember the `Functor' instance ?
13:41:08 <ertes> and you need:  m (Maybe a) -> m (Maybe b)
13:41:25 <ski> (but bind will too work)
13:41:32 <ertes> in other words: you need to do something to cx
13:41:37 <ertes> Just func -> _ cx
13:41:43 <iqubic> Yeah. I remeber the functor instance.
13:41:48 <ertes> this might ring a bell
13:42:47 <iqubic> Do I use fmap?
13:42:58 <ertes> well, is m a Functor?
13:43:14 <iqubic> Yes.
13:43:16 <iqubic> It is.
13:43:21 <ertes> then you can use fmap
13:43:31 <iqubic> but What do I use fmap on?
13:43:37 <iqubic> What is the type of func?
13:43:48 <ertes> Just func -> _ cx
13:43:55 <ertes> _ :: m (Maybe a) -> m (Maybe b)
13:43:58 <ertes> does that help?
13:44:01 <ski> what is the type of `mf' ?
13:44:29 <ertes> (not sure how mf is helpful here)
13:44:45 <ski> ("<iqubic> What is the type of func?")
13:44:54 <ertes> ah
13:45:14 <ertes> overlooked
13:45:15 <iqubic> How do I get something that is Maybe a -> Maybe b?
13:45:37 <ertes> iqubic: well, if you had an (a -> b), you could use the fact that Maybe is a functor
13:45:50 <lyxia> http://lpaste.net/355086 Look ma, no brackets! (Warning, abuse of syntax)
13:46:17 <iqubic> I just got it.
13:46:42 <Myrl-saki> Holes are awesome once you learn to use them.
13:47:26 <iqubic> http://termbin.com/lhag
13:47:29 * ski has fond memories of Alfa
13:47:38 <iqubic> That's what the three instances look like now.
13:48:02 <iqubic> And GHCi claims that their all correct.
13:48:03 <ertes> iqubic: you made it
13:48:14 <ski> looks right
13:48:17 <iqubic> Now, what does this thing actually do??
13:48:24 <iqubic> Why is this MaybeT useful?
13:48:26 <ertes> GHCi only claims that they are well-typed, but yes, they are indeed correct
13:48:39 <ertes> iqubic: now that you have those, we can return to the original exercise
13:48:44 <ski> iqubic : try my `forever' example (after also making a `MonadIO' instance) ?
13:48:50 <ertes> iqubic: getNonEmptyLine :: MaybeT IO String
13:48:59 <ski> (and after completing that exercise, yes)
13:49:33 <Myrl-saki> ertes: TBF, you'd most likely be using `:: IO (Maybe String)` :P
13:49:49 <ertes> Myrl-saki: depends…  i'm quite a regular user of MaybeT
13:49:57 <Myrl-saki> ertes: For IO ops?
13:50:02 <ertes> Myrl-saki: yeah
13:50:06 <Myrl-saki> ertes: Interesting.
13:50:16 <Myrl-saki> ertes: That does make sense though.
13:50:42 <Myrl-saki> Isn't MaybeT a newtype?
13:50:48 <ertes> it is
13:50:54 <ertes> @src MaybeT
13:50:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:51:22 <Myrl-saki> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }` IIRC?
13:51:52 <iqubic> Alright, what is MonadIO?
13:52:02 <ski>   class Monad m => MonadIO m
13:52:04 <ski>     where
13:52:12 <ski>     liftIO :: IO a -> m a
13:52:21 <ertes> iqubic: have you completed getNonEmptyLine?
13:52:23 <iqubic> No.
13:52:26 <glguy> > do 1 + 2; * do 3 + 4 -- lyxia, you can use the semicolon to get things back on one line
13:52:27 <ski> do that first
13:52:28 <iqubic> I have not tried that.
13:52:29 <lambdabot>  21
13:52:43 <ertes> iqubic: then do that first…  you're very easy to distract =)
13:52:46 <Myrl-saki> glguy: wow.
13:53:00 <iqubic> I will do that first
13:53:49 <ertes> you can also line up the operator with the 'do's
13:54:19 <Myrl-saki> Can you nest dos without brackets?
13:54:28 <ertes> > do do do do Nothing
13:54:31 <lambdabot>  Nothing
13:54:36 <Myrl-saki> > do 1 + do 2
13:54:39 <lambdabot>  3
13:54:43 <Myrl-saki> Reeee
13:54:53 <Myrl-saki> > do 1 + do 2;; * 4
13:54:54 <ertes> yeah, that one nests
13:54:55 <lambdabot>  9
13:55:03 <Myrl-saki> I'm scared.
13:55:16 <iqubic> Alright, why is it that I can't just write "do line <- getLine"
13:55:25 <ertes> (do 1 + do 2) = do 1 + (do 2)
13:55:36 <iqubic> Apparently type IO /= type MaybeT IO
13:55:59 <Myrl-saki> (Of course.)
13:56:00 <ertes> iqubic: getNonEmptyLine = _  -- how do you construct a MaybeT again?
13:56:07 <iqubic> MaybeT 
13:56:15 <iqubic> I use the data constructor
13:56:22 <ertes> iqubic: getNonEmptyLine = MaybeT _  -- correct…  now continue from here
13:56:49 <Myrl-saki> iqubic: Do you know what to put inside MaybeT?
13:57:04 <Myrl-saki> (Look at the type, it will help.)
13:57:17 <iqubic> Looks like I need something of IO (Maybe String)
13:57:25 <iqubic> if that seems right.
13:57:29 <ertes> iqubic: yeah
13:57:45 <Myrl-saki> ;)
13:58:18 <ertes> iqubic: just try it on your own…  remember that _ is just a plain old IO action with a result of type (Maybe String)
13:58:27 <ertes> it's no longer related to MaybeT in any way
13:59:06 <iqubic> Got it.
13:59:59 <ertesx> disconnected…  <ertes> iqubic: just try it on your own…  remember that _ is just a plain old IO action with a result of type (Maybe String) <ertes> it's no longer related to MaybeT in any way
14:01:25 <lyxia> glguy: how fun
14:01:41 <iqubic> How do I use that action I just wrote?
14:02:08 <iqubic> I want to test it.
14:02:55 <Aruro> :t do 1
14:02:57 <lambdabot> Num t => t
14:03:02 <Aruro> :t return 1
14:03:03 <lambdabot> (Num a, Monad m) => m a
14:03:14 <iqubic> http://termbin.com/ae4j
14:03:41 <iqubic> Does that look like the right implementation of getNextNonEmptyLine?
14:05:14 <iqubic> I think it's right, but I don't know how to test that.
14:07:01 <glguy> Aruro: The 'do' in do-notation does not introduce a Monad constraint per se
14:08:45 <ertes> iqubic: main = runMaybeT getNonEmptyLine >>= print
14:09:05 <iqubic> Does my function work?
14:09:39 <ertes> iqubic: it's correct, but you can write it slightly more nicely
14:10:01 <iqubic> How?
14:10:02 <ertes> iqubic: do line <- getLine; pure (if null line then Nothing else Just line)
14:10:49 <ertes> there are nicer ways than that, but those require introducing new functions
14:10:59 <ski> (factoring out the `return')
14:11:41 <iqubic> I did factor out the return.
14:12:12 <iqubic> And changed line == "" to null line
14:13:31 <pikajude> hlint will tell you about that btw
14:13:38 <pikajude> if you're using `== ""`
14:13:43 <iqubic> I don't use hlint
14:13:53 <pikajude> hmmm
14:13:57 <pikajude> it may be time
14:14:25 <ertes> iqubic: you're fine…  hlint does warn about some useful things, but it's also highly opinionated as to what makes good haskell coding style
14:14:32 <pikajude> ok fair
14:14:35 <Aruro> null vs =="", thats the problem
14:16:29 <Aruro> :t null
14:16:31 <lambdabot> Foldable t => t a -> Bool
14:16:35 <Aruro> :t (==)
14:16:37 <lambdabot> Eq a => a -> a -> Bool
14:16:42 <ertes> most of the suggestions *i* get from hlint trigger my bullshit alarm =)
14:17:19 <Aruro> why hlint hates lambdas that the question
14:17:26 <ertes> every time it wants me to remove "unnecessary parentheses" or "why not fromMaybe"
14:17:27 <kadoban> For me it's about 50/25/25 good ideas/bullshit/kinda meh but sure
14:20:30 <ertes> for me it's 20/80 bullshit/"leave me alone, i'll do that later"
14:21:47 <kadoban> I know you can change wtf it hints to you, but I've never gotten around to actually seeing if I could improve its advice that way.
14:22:02 <kadoban> "improve" as-in closer to my personal preferences that is
14:22:50 <iqubic> So, what more do I need to know about Monad Transformers?
14:23:18 <ertes> iqubic: you haven't really "used" MaybeT yet
14:23:55 <iqubic> But I wrote getNextNonEmptyLine :: MaybeT IO String
14:24:05 <iqubic> That's got to count for something.
14:24:11 <ertes> iqubic: now comes the interesting part: you need to implement a MonadTrans instance, which you can import from Control.Monad.Trans.Class
14:24:33 <iqubic> What is MonadTrans?
14:24:34 <ertes> class MonadTrans t where lift :: (Monad m) => m a -> t m a
14:24:52 <iqubic> Should I write this in a source file?
14:25:02 <ski> always
14:25:04 <ertes> just keep writing to the file you had
14:25:21 <Aruro> i think new file is needed
14:25:32 <iqubic> Aruro, why do you say that?
14:25:44 <ertes> because Aruro wants you to write orphan instances =)
14:25:50 <iqubic> ertes: what do you want me to create?
14:25:59 <ertes> iqubic: instance MonadTrans MaybeT
14:26:13 <iqubic> Does that require an import?
14:26:21 <ertes> iqubic: import Control.Monad.Trans.Class
14:26:28 <ski> @index MonadTrans
14:26:28 <lambdabot> Control.Monad.Trans.Class
14:27:39 <iqubic> Do I need any constraints on that?
14:27:53 <ertes> you don't have any type variables to constrain
14:29:13 <iqubic> So, how does lift work?
14:29:35 <ertes> first of all let's understand what it does:
14:29:35 <ski> figure out the specialized type of `lift', for your instance
14:29:52 <ertes> example instantiation:  lift :: IO a -> MaybeT IO a
14:30:00 <ertes> iqubic: does that answer your question?
14:30:28 <iqubic> How hard is that to write?
14:30:42 <ertes> it's fairly straightforward given your experience
14:30:52 <iqubic> :t lift
14:30:54 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:31:03 <ski> not hard, if you've understood the process you did before
14:31:11 <ski> it's probably good practice
14:31:25 <ertes> use the usual hole-by-hole approach again
14:31:36 <ertes> lift c = _
14:31:55 <iqubic> MaybeT m a
14:31:56 <ski> perhaps you can figure out the types of the holes yourself, this time ?
14:31:59 <iqubic> How do I get that?
14:32:17 <ertes> well, remember how to construct MaybeT
14:33:16 <iqubic> How do I get something of type m (Maybe a)?
14:33:34 <ertes> iqubic: what do you have?
14:33:49 <iqubic> an m a
14:34:01 <ski> so you want to go `m a -> m (Maybe a)'
14:34:07 <iqubic> yes I do.
14:34:16 <ski> now .. how could you do such a thing ?
14:34:19 <ertes> so you have (m a), but you need (m (Maybe a)), which means that you need to do something to c again
14:34:25 * ski looks at scrollback
14:35:09 <iqubic> Sure.
14:35:18 <ertes> if you Just had a function of type (a -> Maybe a), you could…
14:35:35 * ski sees what ertes did there ..
14:36:02 <iqubic> I have a function of a -> a Maybe a
14:36:06 <iqubic> It's called Just
14:36:15 <ski> yes. how to proceed, then ?
14:37:15 <iqubic> I don't know.
14:37:39 <ski> you have `Just :: a -> Maybe a'. you want to get a `m a -> m (Maybe a)'
14:37:53 <ski> have you done something similar to this in the past ?
14:38:30 <iqubic> Is this fmap?
14:38:43 <ertes> depends: is m a functor?
14:38:47 <iqubic> Yes.
14:38:49 <iqubic> It is.
14:38:52 <ertes> how do you know?
14:39:19 <iqubic> I don't
14:39:27 <ski> what do you know about `m' ?
14:39:32 <iqubic> Nothing really.
14:39:41 <ertes> let's review the class definition
14:39:46 <ertes> @src MonadTrans
14:39:46 <lambdabot> Source not found. You type like i drive.
14:39:46 <ski> what is the (specialized) type signature of `lift' here ?
14:39:58 <iqubic> Monad m
14:40:00 <ertes> you got it, tsunderebot…
14:40:13 <ski> iqubic : yep .. and ?
14:40:54 <iqubic> MonadTrans t
14:40:56 <ertes> iqubic: ski wants you to give a full type signature for lift specialised to t = MaybeT
14:41:11 <iqubic> I don't know how to write that.
14:41:13 <ski> well, i wanted
14:41:26 <ertes> lift :: (Monad m) => …
14:42:11 <ski> iqubic : anyway, `m' is known to be an instance of `Monad'. what does that buy us ?
14:42:25 <ski> @src Monad
14:42:25 <lambdabot> class Applicative m => Monad m where
14:42:25 <lambdabot>     -- Note: Applicative wasn't a superclass before GHC 7.10
14:42:25 <lambdabot>     (>>=)  :: m a -> (a -> m b) -> m b
14:42:25 <lambdabot>     (>>)   :: m a -> m b -> m b
14:42:25 <lambdabot>     return :: a -> m a
14:42:27 <lambdabot>     fail   :: String -> m a
14:42:38 <ski> @src Applicative
14:42:38 <lambdabot> class Functor f => Applicative f where
14:42:38 <lambdabot>     pure  :: a -> f a
14:42:38 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:43:06 <iqubic> Ski, it buys us fmap, <*>, return, and >>=
14:43:09 <ski> right
14:43:13 <aidan`> \exit
14:43:25 <aidan`>  
14:43:26 <ski> an instance of `Monad' is already an instance of `Applicative', and thus also of `Monad'
14:43:30 <ski> so you do have `fmap' for `m'
14:44:08 <ski> so you know the answer to
14:44:09 <ski> <ertes> depends: is m a functor?
14:44:48 <ski> (.. er, and thus also of `Functor', i meant to say. and taht buys us `fmap' for `m')
14:45:09 <iqubic> WHy does fmap help us again?
14:45:24 <ertes> iqubic: lift c = MaybeT (_ c)
14:45:33 <ertes> _ :: m a -> m (Maybe a)
14:45:42 <ertes> you happen to have an: a -> Maybe a
14:45:49 <ertes> and m is a functor
14:47:04 <iqubic> Now I just need an a -> maybe a
14:47:15 <ertes> you have one
14:47:23 <iqubic> got it
14:47:26 <ski> <iqubic> I have a function of a -> a Maybe a
14:47:37 <iqubic> lift c = MaybeT $ fmap Just c
14:47:40 <EvanR> a maybe a
14:47:41 <ski> right
14:47:51 <iqubic> Now, why the heck does that help me?
14:47:53 <ski> that wasn't so hard, now was it ?
14:47:54 <EvanR> does not compute (kind check)
14:48:11 <iqubic> EvanR: GHC is fine with it
14:48:14 <EvanR> oh i was thinking a (maybe a)
14:48:18 <ertes> iqubic: now you can actually *use* MaybeT:  'lift' lets you…  well…  "lift" an IO action into MaybeT IO
14:48:22 <ski> btw, note that `return = Just' in the `Maybe' case
14:48:32 <iqubic> I see.
14:48:34 <ski> so, instead of `Just', you could say `return', if you wanted to ..
14:49:11 * ski . o O ( `forever (liftIO putStrLn =<< getNonEmptyLine)' )
14:49:25 <ertes> iqubic: so you can write something like:  do lift (putStrLn "Say something!"); ln1 <- getNonEmptyLine; lift (putStrLn "Say something else!"); ln2 <- getNonEmptyLine; lift (do putStrLn "You said:"; putStrLn ln1; putStrLn ln2)
14:49:50 <iqubic> ertes: what would that do?
14:49:56 <ski> try it ?
14:50:00 <ertes> iqubic: if at any point the user enters an empty line, the whole thing short-circuits
14:50:26 <ertes> iqubic: give this action a name:  testMaybeT
14:50:40 <ertes> then try it:  main = do runMaybeT testMaybeT; pure ()
14:50:50 <iqubic> I will try that.
14:50:58 <iqubic> Why do you need the pure () at the end?
14:51:07 <ski> you don't
14:51:13 <ertes> next try ski's example, but replace "liftIO" by "lift"
14:51:33 <ertes> you do, if you're like me and always write type signatures for top-level definitions =)
14:51:35 <ertes> main :: IO ()
14:51:46 <ertes> runMaybeT testMaybeT :: IO (Maybe ())
14:51:49 <ski> just write `main :: IO (Maybe ())' instead :)
14:52:08 <iqubic> What should I write to test this?
14:52:19 <ertes> iqubic: in GHCi just type:  :main
14:52:25 <ski> ertes gave code for testing `testMaybeT'
14:53:02 <ertes> in fact you can ignore my testing code and just type this directly into GHCi:  runMaybeT testMaybeT
14:54:25 <torstein_> what does this mean? newtype s >> a = Named a  
14:54:47 <ertes> torstein_: you're defining a type named (>>)
14:54:48 <ski> `(>>)' is an infix type operator
15:00:32 <iqubic> I love that testMaybeT thing
15:02:46 <ertes> iqubic: try ski's example, too
15:02:51 <iqubic> And we could not have made the action short-circuit if we had just used IO (Maybe ())
15:03:04 <iqubic> We had to use MaybeT IO ()
15:03:12 <ertes> runMaybeT (forever (lift . putStrLn =<< getNonEmptyLine))
15:03:12 <iqubic> what was ski's example?
15:03:24 <irithor> Hello, anyone there?
15:03:33 <ertes> i took the liberty of fixing a bug =)
15:03:57 <ertes> iqubic: well, you can short-circuit, but you need to do it implicitly
15:04:04 <ertes> *explicitly
15:04:11 <ertes> with MaybeT it's implicit in the semantics of (>>=)
15:04:12 <irithor> Just starting out learning Functional Programming and stumbled across this group. I'm good at OO programming - are there any good resources out there to help?
15:04:26 <iqubic> ertes: GHCi doesn't like that. Not in scope forever MaybeT IO () -> MaybeT m a
15:04:32 <ertes> hi and welcome, irithor!
15:04:44 <irithor> Hi there :)
15:04:45 <ertes> iqubic: import Control.Monad
15:04:48 <kadoban> irithor: I quite like http://haskellbook.com/ (warning: it's not free). There's other free resources that are okay
15:05:48 <MonadHendrix> TIL i can do `x, y, z :: Integer`
15:05:55 * MonadHendrix rejoices
15:06:15 <irithor> Thanks kadoban! I will check that one out.
15:06:15 <kadoban> Haah, yeah. Not used too much, but it works well some places.
15:06:16 <ertes> irithor: the first step is to be open-minded…  you will not be doing OO in haskell
15:06:17 <iqubic> ertes. I like that a lot too.
15:06:33 <iqubic> I like the forever thing a lot
15:06:33 <ertes> irithor: it's a very different way to solve software engineering problems
15:06:44 <glguy> MonadHendrix: That works both in records and when making normal definitions
15:06:57 <irithor> Ok I understand, I'll clear my head - go on
15:07:15 <iqubic> Do you have GHC installed?
15:07:20 <iqubic> DO you have GHCi?
15:07:55 <irithor> Installing it now!
15:07:58 <ertes> irithor: are you going to *learn* haskell, or do you just want to get a feeling for what it's like?
15:08:42 <irithor> I just want to get a feeling. I'm studying functional programming for my degree you see, and I thought learning a functional language could help me to grasp the theory.
15:08:46 <ertes> (biased opinion: you should learn it) =)
15:08:51 <MonadHendrix> glguy: cool, i just used it to make flycheck shut up with -Wmissing-signatures :p
15:09:15 <MonadHendrix> instead of having three separate type signatures
15:09:18 <ertes> irithor: actually i think these are fine in either case: https://www.seas.upenn.edu/~cis194/spring13/lectures.html
15:09:22 * MonadHendrix king of compromise
15:09:24 <kadoban> Sounds important, learning a function language.
15:09:35 <EvanR> irithor: youre about the enter a world...
15:09:44 <EvanR> er... dang
15:10:03 <EvanR> functional programming rocks
15:10:34 <ertes> irithor: if you have 10 minutes, here is also a funny demo: https://www.youtube.com/watch?v=RqvCNb7fKsg
15:10:57 <irithor> Thanks! I'm watching now.
15:11:42 <Tuplanolla> Has anyone just so happened to use CiNii?
15:11:45 <MonadHendrix> possibly the best haskell video ever
15:12:02 <MonadHendrix> hfeflflfo
15:13:03 <rightfold> What is the newtype wrapper for IO for which (<*>) does parallelism called?
15:13:32 <rightfold> In PureScript it's ParAff, but in Haskell ParIO *seems* to be different (as it also has a Monad instance)
15:13:38 <ertes> rightfold: https://hackage.haskell.org/package/async-2.1.1.1/docs/Control-Concurrent-Async.html#t:Concurrently
15:14:00 <rightfold> ertes: Thanks a lot, seems to be it! (Y)
15:17:56 <irithor> Hahahahaha, Swedish greeting.
15:18:40 <iqubic> How does that last function work?
15:18:59 <iqubic> The one in the video that appears to be infinite?
15:19:35 <ertes> it's not infinite
15:19:45 <ertes> he's applying 'very' to 'very'
15:20:28 <iqubic> So why does that make a super super long string?
15:20:28 <ertes> @let very f = f . f . f
15:20:31 <lambdabot>  Defined.
15:20:35 <ertes> > very very f
15:20:38 <lambdabot>  error:
15:20:38 <lambdabot>      • No instance for (Typeable b0)
15:20:38 <lambdabot>          arising from a use of ‘show_M158506368030085294131433’
15:20:46 <ertes> > very very f :: Expr
15:20:49 <lambdabot>  error:
15:20:49 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘b0 -> b0’
15:20:49 <lambdabot>      • Probable cause: ‘very’ is applied to too few arguments
15:20:52 <ertes> oh…
15:20:56 <ertes> > very very f x :: Expr
15:20:58 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
15:21:08 <iqubic> How is that not infinite?
15:21:18 <iqubic> It is, isn't it?
15:21:22 <ertes> graham's number is also not infinite =)
15:21:36 <iqubic> How many times does that apply f?
15:21:44 <c_wraith> I'd guess 81
15:21:55 <ertes> 27 times, i think
15:22:03 <iqubic> I think it's 27
15:22:07 <ertes> iqubic: very very f = very (very (very f)) = very (very (f . f . f)) = very (f . f . f . f . f . f . f . f . f)
15:22:07 <c_wraith> Oh, I think I associated backwards
15:22:30 <MarcelineVQ> > very very (+1) 0
15:22:33 <lambdabot>  27
15:22:44 <iqubic> It's 27 times then
15:23:01 <ertes> it's not even that large
15:23:03 <rightfold> pi is infinite, 27 > pi, therefore 27 is infinite :troll:
15:23:11 <ertes> he just aborted it very quickly
15:23:15 <iqubic> LOL
15:23:57 <ertes> > very very very (+1) 0
15:24:00 <lambdabot>  *Exception: stack overflow
15:24:05 <irithor> lol
15:24:07 <int-e> now which is larger, very very very f x, or very (very very) f x
15:24:25 <rightfold> (.) is associative
15:24:31 <rightfold> I think they're the same
15:24:40 <MarcelineVQ> rightfold: try them :>
15:24:42 <int-e> well, they're not the same.
15:24:44 <ertes> no, i don't think so
15:24:46 <rightfold> OK
15:25:21 <int-e> > very (very very) (+1) 0 -- this might still work, actually.
15:25:24 <lambdabot>  19683
15:25:25 <MarcelineVQ> it will
15:25:46 <int-e> > 3^27 -- very very very (+1) 0
15:25:48 <lambdabot>  7625597484987
15:26:05 <ertes> it's a bit like knuth's up arrow
15:26:10 <ertes> explodes very quickly
15:26:19 <iqubic> Yeah. I get that.
15:26:19 <int-e> ertes: very much so ;-)
15:27:18 <int-e> (it helps to know that `very` is the Church numeral 3)
15:27:20 <irithor> I'm cracking up at this video. Brilliant. 
15:28:31 <iqubic> Alright, now that I understand MaybeT, what more is there to understand about Monad Transformers?
15:28:51 <ertes> iqubic: well, first familiarise yourself with the others
15:28:56 <ertes> StateT is a particularly useful one
15:29:23 <iqubic> How the heck does StateT work.
15:29:31 <ertes> remember State?
15:29:31 <iqubic> I understand State as a Monad.
15:29:39 <iqubic> But not StateT
15:29:47 <ertes> newtype StateT s m a = StateT { runStateT :: s -> m (a, s) }
15:30:03 <ertes> adds a state effect to m
15:30:36 <iqubic> Can I see an example?
15:31:08 <iqubic> Or do you want me to go through and write the functor, applicative, and monad instances?
15:31:39 <Tuplanolla> Don't overthink it, iqubic. It's a rather trivial generalization.
15:31:43 <ertes> > runStateT (do x <- get; when (x == 0) (lift Nothing); put (2*x)) 15
15:31:45 <lambdabot>  Just ((),30)
15:31:47 <ertes> > runStateT (do x <- get; when (x == 0) (lift Nothing); put (2*x)) 0
15:31:50 <lambdabot>  Nothing
15:32:11 <iqubic> What do those do?
15:32:30 <ertes> iqubic: that's StateT over Maybe
15:32:47 <ertes> Maybe is a short-circuiting monad, and StateT makes it stateful
15:33:54 <ertes> this is really easy to see, if you just look at the definition:  an action of type (StateT S Maybe A) is basically a function of S that returns (Maybe (A, S))
15:34:14 <iqubic> I understand.
15:34:28 <rightfold> The implementation is a lot like that of State, but roughly, you replace in some places id by pure, ($) by (=<<), and (.) by (<=<)
15:34:38 <ertes> similarly you can equip IO with state:  StateT S IO
15:34:56 <iqubic> How does that work?
15:35:12 <ertes> StateT S IO A ≃ S -> IO (A, S)
15:36:11 <iqubic> Can I see an example of StateT IO A in action?
15:37:09 <rightfold> incr = do { old <- get; liftIO (print old); modify (+ 1) }
15:37:11 <ertes> iqubic: try to come up with one yourself
15:37:29 <ertes> iqubic: remember that (StateT s) is a monad transformer, so you can use 'lift'
15:38:14 <iqubic> rightfold: Does that add one to the state, and print out the old value?
15:39:04 <glguy> iqubic: You can try these things in GHCi
15:39:54 <glguy> There you'll be able to try running it with different parameters to see what happens
15:40:13 <iqubic> What do I need to import to have access to the liftIO function?
15:40:39 <glguy> If you're not sure what to import, Hoogle and Google are both effective for looking it up
15:42:22 <glguy> another good tool is: /msg lamdabot ?index some_function_here
15:43:01 <iqubic> @index liftIO
15:43:01 <lambdabot> Control.Monad.IO.Class
15:43:26 <iqubic> GHCi really hates this: incr = do { old <- get; liftIO (print old); modify (+ 1) }
15:44:53 <glguy> iqubic: GHCi doesn't have emotions
15:45:11 <wizwizwizwiz> except the glory emotion
15:45:25 <iqubic> Yeah, but it won't accept that function
15:45:31 <iqubic> @index modify
15:45:31 <lambdabot> Control.Monad.Trans.State.Strict, Control.Monad.Trans.State.Lazy, Control.Monad.Trans.State, Control.Monad.Trans.RWS.Strict, Control.Monad.Trans.RWS.Lazy, Control.Monad.Trans.RWS
15:45:31 <wizwizwizwiz> and since pride is a side effect of glory, it also has pride
15:45:41 <wizwizwizwiz> because haskell uses the glory monad
15:45:53 <glguy> iqubic: It's not a function; and we can't read your screen. If you need help understanding an error you can ask about the error message
15:46:35 <glguy> wizwizwizwiz: That was all removed in GHC 8, unfortunately
15:48:08 <wizwizwizwiz> but it's still part of the string libraries
15:49:11 <wizwizwizwiz> why would i use haskell over irdis? irdis looks like it has more awesome
15:49:26 <iqubic> What is irdis?
15:49:58 <davean> wizwizwizwiz: idris is more restrictive, it depends on the balance appropriate to what you're wroking on
15:50:09 <iqubic> Question: Haskell or Lisp?
15:50:15 <davean> iqubic: Lisp
15:50:28 <iqubic> Why lisp?
15:50:32 <iqubic> Why not haskell?
15:50:37 <glguy> No, the topic of the channel is Haskell
15:50:42 <wizwizwizwiz> irdis is strict by default
15:50:43 <davean> homoiconic, I really miss that
15:50:52 <iqubic> Lisp GUIs must be a pain in the ass to work with.
15:50:55 <davean> wizwizwizwiz: yah, which is really annoying
15:51:03 <wizwizwizwiz> orly?
15:51:11 <wizwizwizwiz> i thought the haskell community thought lazy by default was a bad idea
15:51:13 <davean> wizwizwizwiz: well, it ruins a lot of composability
15:51:17 <davean> wizwizwizwiz: uh no
15:51:29 <glguy> No, lazy by default is well regarded by the community
15:51:49 <wizwizwizwiz> interesting
15:52:29 <davean> its usually only people learning the language who don't realize how important non-strictness is because they don't understand whats actually happening in their code yet
15:53:09 <wizwizwizwiz> i am just generally concerned about things which can introduce massive sudden latency
15:53:17 <wizwizwizwiz> you know a > 1 msec pause etc
16:43:04 <tobiasBora> Hello,
16:43:21 <stevenxl> Hi folks. I'm blanking on the name of this concept, but when I have a function whose type signature is (a -> b -> a), and another function whose type signature is (b -> a -> b), these are the same. 
16:43:31 <stevenxl> I'm trying to look it up but can't find the name for this. 
16:43:33 <tobiasBora> I'd need an efficient database access
16:43:42 <suzu> stevenxl: isomorphism?
16:43:45 <tobiasBora> with pool access
16:44:00 <tobiasBora> Is there any example to do that ?
16:44:06 <MarcelineVQ> alpha equivalence
16:44:11 <geekosaur> ^
16:44:22 <stevenxl> Ah yes alpha equivalence.
16:44:24 <stevenxl> Thank you!!
16:44:25 <tobiasBora> I saw https://hackage.haskell.org/package/resource-pool-0.2.3.2/docs/Data-Pool.html and HDBC, not sure how good it is
16:46:01 <Gurkenglas> alpha equivalence of signature1 and signature2 is equivalent to (((undefined :: signature1) :: signature2) :: signature1) compiling, right?
16:48:06 <Ieuan> Hi, I'm working through this https://wiki.haskell.org/Parsing_a_simple_imperative_language howto, but I'm getting an error when I try to run the code
16:48:24 <Ieuan> The code I've copied is here: https://pastebin.com/UY3V32qw - it's telling me there's a "parse error on input 'return'" online 81
16:48:34 <Ieuan> s/81/80/
16:48:40 <Ieuan> s/online/on line/
16:50:30 <geekosaur> all of the do expressions lost leading spaces
16:50:38 <geekosaur> after the first line
16:51:39 <geekosaur> actually lost exactly one leading space. so for example the "cond <- bExpression" needs to line up directly under the "reserved "if"" on the previous line
16:52:50 <Ieuan> Ah, I'll try and fix that, cheers
16:53:04 <glguy> Ieuan: You can look at the wiki page you copied this from originally to see what it's supposed to look like
16:54:10 <Ieuan> Yeah, I was a little lazy copying the whitespace - didn't think haskell was too fussy; I'm gonna go double check everything else too now, thanks
16:55:46 <Ieuan> That works fine now, thanks!
17:18:46 <AWizzArd> Anyone here who tried Selenium with Haskell?
17:20:02 <AWizzArd> I was giving the hs-webdriver a try and tried out that little example at https://github.com/kallisti-dev/hs-webdriver/blob/master/examples/readme-example-beginner.md  but get an UnknownCommand exception.
17:22:42 <wizwizwizwiz> haven't tried it,... i find in general if you try to use software that isn't well used, you end up with problems like the one you are describing
17:23:38 <jabesed> does using DataKinds, imply that any declaration "data X = ... " defines both a kind X and a type X? 
17:24:09 <Welkin> that is my understanding, but I haven't used it before
17:24:11 <johnw> that's my understanding; not sure if the compiler needs to see you use it as a kind to do the work
17:24:16 <jabesed> or is there some way to specify data kind / that type definition
17:24:58 <jabesed> that results in a lot of junk... 
17:25:05 <Welkin> it's okay if it defines kinds that you don't use
17:25:08 <Welkin> you just don't use them
17:25:11 <MarcelineVQ> it is both, where it's used will determine which you meant
17:26:10 <jabesed> Welkin: sure, likewise for types, but one may accidentally use them, leading to more complicated errors than necessary
17:26:22 <AWizzArd> wizwizwizwiz: although this library seems as if someone has put lots of effort into it. Well written tutorial and readme, commits since many years, even recent ones.
17:27:59 <jabesed> another question... is there some de facto standard these days for extensible records? 
17:28:10 <jabesed> it appears some applications use heterogeneous lists
17:28:48 <jabesed> I wanted to defined some ASTs for a language that may be extended
17:29:19 <homesitter> let's give it a try : https://gammastorm.github.io/robot.html
17:29:29 <jabesed> so as of right now I was just considering parameterizing them (and use that parameter for possible extensions)
17:30:48 <jabesed> (for no extension I'd use Void as parameter)
17:33:41 <monarch_> when using Persistent, how can I set another entity's implicitly generated Primary Key Id as a Foreign key constraint?
17:34:05 <Welkin> TableNameId
17:34:12 <Welkin> just add Id to the end of it
17:34:27 <Welkin> for a Person, it would be PersonId
17:34:37 <Welkin> yeah, template haskell is a pain in the ass
17:34:39 <Welkin> too much magic
17:34:56 <Welkin> you'll have to read up on docs for persistent/yesod or look at the source
17:35:07 <Welkin> but once you know how it works, it's great
17:35:28 <monarch_> Welkin: I get "no explicit primary key fdef=ForeignDef"
17:35:41 <Welkin> monarch_: http://www.yesodweb.com/book/persistent
17:35:49 <monarch_> Welkin: for "Foreign Entity entityId EntityId"
17:36:00 <Welkin> monarch_: what is the name of your entity?
17:36:37 <Welkin> It can't be Entity since that is already taken by Persistent
17:37:16 <Welkin> here is a simple example http://www.yesodweb.com/book/persistent#persistent_synopsis
17:38:50 <monarch_> Welkin: here's are really simple version of the problem https://pastebin.com/9FY6DnGS
17:39:16 <monarch_> that gets error "no explicit primary key fdef=ForeignDef"
17:39:25 <Welkin> monarch_: you don't need the Foreign part
17:39:33 <Welkin> look at the example I linked
17:39:43 <Welkin> all you need is `dogId DogId`
17:40:05 <Welkin> this is written in a DSL using template haskell
17:40:10 <Welkin> it's "magic"
17:43:29 <monarch_> Welkin: I had read that tutorial and that was what I had tried before, the problem is that gives a INTEGER NOT NULL REFERENCES constraint
17:43:43 <Welkin> yes
17:44:01 <Welkin> there are ways to specify a different primary key if you wish
17:45:00 <monarch_> Welkin: so there's no way to reference an implicit primary key as a foreign key
17:45:21 <Welkin> https://github.com/yesodweb/persistent/wiki/Persistent-entity-syntax
17:45:31 <Welkin> what is your implicit primary key?
17:45:43 <Welkin> you mean the default integer?
17:45:56 <monarch_> yes, the default INTEGER PRIMARY KEY
17:46:03 <monarch_> named "id"
17:46:22 <Welkin> https://github.com/yesodweb/persistent/blob/master/persistent-test/src/CompositeTest.hs#L53
17:46:29 <arctictern> this is probably a stupid question, but does anyone know why this doesn't typecheck?
17:46:29 <arctictern> myTest :: (Bounded a) => a
17:46:30 <Welkin> there is an example of how you can do it
17:46:31 <arctictern> myTest = minBound :: a
17:46:42 <monarch_> Welkin: yup, that's what led me to try what was in that pastebin I sent
17:47:05 <Welkin> although from your error you pasted, it looks like your problem is that you are naming one of your tables "Entity", which is a type already taken by persistent
17:47:41 <monarch_> Welkin: no table is named Entity, I was just trying to be generic to not confuse you with my table names
17:47:54 <Welkin> youo have to be specific
17:47:59 <Welkin> and just paste you real error
17:48:03 <Welkin> your*
17:48:52 <Welkin> 20:35 < monarch_> Welkin: for "Foreign Entity entityId EntityId"
17:49:01 <Welkin> you also have an extra type at the end
17:49:07 <Welkin> there are no types in this case
17:49:44 <Welkin> try `Foreign Dog dog`
17:50:28 <Welkin> it also depends on what your primary key is for Dog
17:50:31 <Welkin> in this case, what is it?
17:51:04 <monarch_> Welkin: this is the error for "Foreign Dog dog": https://pastebin.com/jQL5C5PA
17:51:04 <Welkin> in the github example above, it is `Primary name name2 age`
17:51:35 <Welkin> so the referncing table uses `Foreign TestParent fkparent name name2 age`
17:51:51 <monarch_> Welkin: yeah, they have an explicit primary key. But you can see from my first paste, that I do not, and I'm wondering if it's possible to not have an explicit key
17:52:00 <monarch_> and still use Foreign to link them
17:52:07 <Welkin> why do you need Foreign then?
17:52:08 <monarch_> that first paste being https://pastebin.com/9FY6DnGS
17:52:25 <Welkin> it should just work with `dogId Dog`
17:52:28 <monarch_> I need Foreign to have a Foreign Key Constraint
17:52:30 <Welkin> er
17:52:49 <Welkin> you should be able to
17:52:56 <monarch_> otherwise it's not a FOREIGN KEY, it's a NOT NULL REFERENCES constraint
17:53:04 <Welkin> try `Foreign Dog dog id`
17:53:58 <monarch_> Welkin: same problem. https://pastebin.com/PtmntCaG
17:54:38 <Axman6> can I give a small word of warning? It's possbile to his the limits of persistent quite quickly if you need do do anything more difficult than what it was designed for, and esqueletto feels like a limited when comparexd to SQL and has comparatively weird syntax. I spent last weekend rewriting our persistent based app using hasql and I'm much happier for it
17:54:47 <Axman6> hit*
17:55:02 <Axman6> s/like a/quite/
17:55:09 <Welkin> persistent is meant to be a simple ORM
17:55:23 <monarch_> Welkin: I should note that I'm using SQLite, which disables foreign keys by default, but I've supposedly turned them on using "set fkEnabled True $ mkSqliteConnectionInfo databaseName" elsewhere
17:55:24 <Welkin> when I had to do custom postgres things, I used the rawSql function
17:55:40 <Axman6> sadly it's not particularly simple
17:55:44 <monarch_> Axman: I've definitely done so before, it just needs to be done this way for this problem
17:55:54 <Squarism> Anyone can see why i get this error : http://lpaste.net/355091
17:56:48 <Welkin> monarch_: it looks like your error tells you what needs to be done
17:56:54 <Welkin> add an explicit primary key
17:57:00 <Squarism> im doing a liftIO in a WriterT typed function - i wonder why the foldM expects a WriterT when im in liftIO scope
17:57:00 <Welkin> then try it
17:57:17 <monarch_> Welkin: guess it's not possible. Okay. I'll adjust accordingly.
17:57:44 <Koterpillar> Squarism: so I'm guessing ga_handleToGameMsg is IO something, and you need to lift it?
17:57:49 <monarch_> Welkin: thanks for looking through it with me
17:57:57 <Squarism> Koterpillar, it is
17:59:21 <Squarism> Koterpillar, but the foldM is invoked in liftIO already - thats not enough?
18:00:53 <Squarism> Koterpillar, i thought "f" got type "IO ..." 
18:01:19 <Koterpillar> Squarism: GHC tells you what type did f get
18:01:35 <Koterpillar> Squarism: perhaps you want to manually type it to MonadIO
18:01:51 <Squarism> yeah i guess ill try that
18:31:54 <drostie> Was wondering if anyone else remembered this: I have a dim memory of someone who was essentially describing a heterogeneous list of arrows which all agreed on their intermediate representations, something which would store something like `data ArrList arr x y = A1 (arr x y) | A2 (arr x k, arr k z) | A3 (arr x k, arr k l, arr l y) | A4 (arr x k, arr k l, arr l m, arr m y) | ...`. Am I misremembering something or crazy or is there some type-level trickery to
18:31:55 <drostie>  make that sort of list-type thing happen?
18:33:33 <byorgey> drostie: not crazy at all.  http://hackage.haskell.org/package/thrist
18:33:35 <drostie> whoops, that second one should be A2 (arr x k, arr k y)
18:33:47 <byorgey> I have seen this idea show up in multiple places so there might be something else you are remembering as well
18:34:37 <byorgey> free Applicatives are somewhat related as well https://hackage.haskell.org/package/free-4.12.4/docs/Control-Applicative-Free.html
18:36:05 <drostie> Thanks, I'll look at those. :D
18:42:40 <lpaste> lambdafan pasted “Need Help With My Evaluator” at http://lpaste.net/136471726836940800
18:42:53 <lpaste> lambdafan pasted “Need Help With My Evaluator” at http://lpaste.net/2788601744215506944
18:50:05 <lambdafan> ah yeah scratch that
19:11:29 <iqubic> So, how does StateT work?
19:11:51 <iqubic> Like can I get an example of StateT IO a being used?
19:13:08 <glguy> What've you tried so far?
19:13:14 <glguy> Which part don't you understand?
19:13:34 <iqubic> I haven't tried anything. And I understand nothing.
19:14:14 <glguy> OK, in that case you should start here to at least see the operations and the types available http://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Monad-Trans-State-Lazy.html
19:14:53 <glguy> There are even examples there
19:15:10 <iqubic> Looks like you can construct a StateT with the state function.
19:15:22 <iqubic> How does that decide what Monad to use?
19:15:59 <glguy> It doesn't decide, you do
19:16:27 <iqubic> But when?
19:16:46 <iqubic> When do you select the monad that the return type will use?
19:19:39 <glguy> When you write your program. Maybe make an example where this is confusing and put it on lpaste.net
19:21:17 <iqubic> Actually I found a talk about monad transformers. Watching it now.
19:23:22 <iqubic> Do people find it helpful to write their own typeclasses?
19:23:29 <iqubic> Or is that commonly done?
19:23:58 <iqubic> *Not
19:24:01 <glguy> 3 minute talk on monad transformers?
19:24:34 <lpaste> lambdafan pasted “Need Help With My Evaluator - redux” at http://lpaste.net/5956570558047977472
19:24:51 <iqubic> glguy, it's 56 minutes long. I'm just asking questions in the middle of the talk.
19:27:11 <glguy> lambdafan: You don't know that num equal Integer
19:28:47 <glguy> (and you only have an instance for   Integer)
19:28:54 <glguy>   Equals      :: Expr (Number num)  -> Expr (Number num) -> Expr Bool
19:29:08 <glguy> This constructor will work for other choices of num, too
19:29:19 <lambdafan> yes I would like it too
19:29:45 <lambdafan> I just want one constructor for both Ints and Doubles
19:30:22 <glguy> lambdafan: Perhaps you want another GADT for Number, instead of a data family
19:30:35 <lambdafan> glguy, hmm I had tried that prior
19:30:45 <lambdafan> okay I will try that direction again
19:31:09 <lambdafan> glguy: I would then need an eval function for that gadt as well yes?
19:31:50 <glguy> lambdafan: That'd be a good idea
19:33:37 <iqubic> What's a data family?
19:34:42 <glguy> this is a good place to start https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTypeFamilies
19:37:10 <glguy> also https://wiki.haskell.org/GHC/Indexed_types
19:37:28 <glguy> the wiki link is probably a better starting point
19:37:59 <lambdafan> I found stack overflow helpful
19:51:40 <glguy> lambdafan: Did you get it working?
19:53:56 <spatial> find :: Container c e => (e -> Bool) -> c e -> [IndexOf c] in https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra-Data.html
19:54:05 <spatial> Doesn't accept Vector.
19:57:20 <glguy> spatial: It'd help to see the actual error message and the code
19:59:22 <spatial> http://lpaste.net/355093
20:01:30 <pacak> IO (Vector Double) as input parameter seems wrong.
20:01:48 <glguy> pacak: Make sure you're using Vector as exported from Numeric.LinearAlgebra
20:01:50 <glguy> err
20:01:54 <glguy> spatial: Make sure you're using Vector as exported from Numeric.LinearAlgebra
20:02:05 <pacak> spatial: s/mat/m/ ?
20:02:22 <pacak> spatial: At line 4
20:02:35 <glguy> Yeah, that's certainly going to need to be fixed, too :)
20:03:49 <spatial> Sorry. Mislead by the error. Fixed it.
20:05:02 <spatial> I mean fixed Line 4
20:06:55 <glguy> spatial: If there's a new error you can annotate that onto the paste with the fixed code
20:07:12 <glguy> We can't load your code, its missing imports
20:07:52 <spatial> glguy: No new error. Code is long.
20:20:57 <qmm> > if (any (== Nothing) [Just 1, Just 2, Just 3]) then (any (== Nothing) [Just 1, Just 2, Just 3] else False
20:21:00 <lambdabot>  <hint>:1:96: error: parse error on input ‘else’
20:23:19 <qmm> i am trying to say, if the first list of values contains a Nothing, then check that a second group of values has a Nothing value. if both of the lists contains a Nothing then return False and otherwise if the first list doesn't contain Nothing, return it. otherwise if the second list doesn't contain a Nothing, return it
20:23:39 <iqubic> What is this: https://hackage.haskell.org/package/extensible-effects
20:23:59 <qmm> it feels weird asking how to do this, maybe i need to think about it longer than 30 seconds
20:24:29 <iqubic> That thing bills itself as the eff monad.
20:24:44 <glguy> > find (all isJust) [   [Just 1, Nothing] , [Just 1, Just 2, Just 3] ]
20:24:46 <lambdabot>  Just [Just 1,Just 2,Just 3]
20:25:17 <iqubic> :t find
20:25:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
20:25:20 <iqubic> :t isJust
20:25:22 <lambdabot> Maybe a -> Bool
20:25:29 <glguy> or: a> asum (map sequence [   [Just 1, Nothing] , [Just 1, Just 2, Just 3] ] )
20:25:35 <glguy> > asum (map sequence [   [Just 1, Nothing] , [Just 1, Just 2, Just 3] ] )
20:25:38 <lambdabot>  Just [1,2,3]
20:26:00 <glguy> instead of returning a list with all Just constructed values
20:26:03 <glguy> it returns Just of the list
20:26:17 <qmm> that is really nice!
20:26:52 <glguy> :t foldMap sequenceA
20:26:54 <lambdabot> (Foldable t, Applicative f, Traversable t1, Monoid (f (t1 a))) => t (t1 (f a)) -> f (t1 a)
20:27:16 <glguy> Hmm, that's a more complicated type than I had in mind, but it does the same thing in this case
20:27:46 <glguy> > foldMap sequenceA [ [Nothing, Just 1], [Just 2, Just 3], [Just 4] ]
20:27:48 <lambdabot>  Just [2,3,4]
20:27:54 <glguy> oh, no it doesn't :)
20:28:15 <glguy> that one collects all the lists together that had no Nothings in them
20:28:27 <pacak> I think you can use MonadPlus or Alternative here
20:28:33 <glguy> pacak: Yeah, that's what asum did
20:28:48 <pacak> foldMap will try to fold all the things
20:28:53 <glguy> right
20:29:04 <pacak> (didn't noticed asum)
20:33:01 <kamyar> Hello fellows
20:33:12 <kamyar> PLease help me with the code snippet
20:34:09 <kamyar> http://lpaste.net/355094
20:34:26 <kamyar> The last line of function post gives the below error
20:34:52 <kamyar> token is of type IO String, but json function (in scotty) needs String
20:35:08 <kamyar> How can I fix it?
20:35:15 <Axman6> so what's the type of json?
20:35:33 <kamyar> json :: ToJSON a => a -> ActionM ()
20:35:43 <Axman6> ah, try json =<< instead
20:35:49 <kamyar> Sorry! json gets any object not string
20:36:15 <kamyar> and token is of Type newtype TokenInfo = TokenInfo {token :: String} deriving (Show, Generic)
20:36:40 <pacak> Looks ugly.
20:37:06 <pacak> Factor out token?
20:37:17 <kamyar> Axman6: Does not work
20:37:26 <kamyar> pacak: What do u mean?
20:37:36 <pacak> With full type signature
20:37:42 <Axman6> "does not work" is not a type error I can help you with ;)
20:37:52 <pacak> As far as I can see Token refers to nothing inside your monadic action
20:38:08 <Axman6> look at the line before
20:39:04 <kamyar> Thanks Axman6! json =<< lift token Worked!
20:39:22 <pacak> Axman6: Lines 4..6 refer to each other, but they are not related to anything inside the monadic action
20:39:38 <kamyar> pacak: What do u mean? token is filled and working
20:40:24 <kamyar> WoW! It Worked!
20:40:40 <kamyar> Axman6: What does =<< do? it is second time it saved me!
20:40:54 <pacak> :t (=<<)
20:40:56 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:40:58 <pacak> :t (>>=)
20:41:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:41:04 <pacak> @src (=<<)
20:41:05 <lambdabot> f =<< x = x >>= f
20:41:43 <Axman6> :t (<*>)
20:41:45 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:41:47 <Axman6> :t (=<<)
20:41:49 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:42:02 <Axman6> notiveuh
20:42:07 <Axman6> :t (<$>)
20:42:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:42:44 <Axman6> notice that =<< takes a "monadic function"
20:42:44 <kamyar> I know about <$> and <*> , but did not remind =<<
20:42:52 <kamyar> Thanks anyway!
20:45:30 <kamyar> Axman6: Yes! json in fact gets a type and returns a monadic value to feed Scotty! So your notation worked! Since my token variable is monad itself and I needed its containing value
20:54:26 <iqubic> @src return
20:54:27 <lambdabot> Source not found.
20:54:31 <iqubic> Why not?
20:54:42 <iqubic> Is it because Monad is a typeclass?
20:54:48 <iqubic> @src >>
20:54:48 <lambdabot> m >> k = m >>= \_ -> k
20:55:15 <Koterpillar> iqubic: yes, because return is different for every monad
20:55:38 <Koterpillar> iqubic: and also, the src command isn't GHC-accurate
20:56:39 <iqubic> But >> looks right.
20:56:49 <Koterpillar> because it can be expressed using >>=
20:56:53 <iqubic> Ah.
20:57:13 <iqubic> Can't @src just say "return = pure"?
20:57:15 <Koterpillar> @src join
20:57:15 <lambdabot> join x = x >>= id
20:57:30 <iqubic> That's not right at all.
20:57:37 <iqubic> Least, I don't think so.
20:57:41 <Koterpillar> which one, join?
20:57:52 <iqubic> Join doesn't look right
20:58:12 <iqubic> > Just (Just 5) >>= id
20:58:15 <lambdabot>  Just 5
20:58:17 <Koterpillar> return = pure yes, I suppose it can, but @src isn't a replacement for searching Hackage yourself
20:58:22 <Koterpillar> http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-Instances.html#t:Monad
20:58:27 <iqubic> > Just (Nothing) >>= id
20:58:28 <Axman6> join is definitely right
20:58:29 <lambdabot>  Nothing
20:58:38 <iqubic> > Nothing >>= id
20:58:42 <lambdabot>  Nothing
20:58:48 <Koterpillar> > Nothing >>= undefined
20:58:51 <lambdabot>  Nothing
20:58:56 <iqubic> How does that join work?
20:59:19 <Axman6> try it out by hand for a few different monads
20:59:25 <Koterpillar> iqubic: find out the type of x >>= id
20:59:35 <Axman6> like Maybe, [], Either
21:00:03 <iqubic> IO (IO Int) >>= Join
21:00:11 <iqubic> > IO (IO Int) >>= Join
21:00:13 <lambdabot>  error:
21:00:13 <lambdabot>      • Data constructor not in scope: IO :: t0 -> m a0
21:00:13 <lambdabot>      • Perhaps you meant one of these:
21:00:27 <iqubic> Looks like that doesn't work
21:00:35 <glguy> Yeah, IO isn't a data constructor
21:00:39 <Koterpillar> :t (undefined :: IO (IO Int)) >>= join
21:00:42 <lambdabot> error:
21:00:42 <lambdabot>     • Couldn't match type ‘Int’ with ‘IO b’
21:00:42 <lambdabot>       Expected type: IO Int -> IO b
21:00:44 <Koterpillar> :t (undefined :: IO (IO Int)) >>= id
21:00:47 <lambdabot> IO Int
21:01:08 <glguy> iqubic: Go back to trying Maybe. [], and Either Something, as suggested
21:01:14 <iqubic> > [[1, 2, 3] [4, 5, 6] [7, 8, 9] [10]]
21:01:18 <lambdabot>  error:
21:01:18 <lambdabot>      • Couldn't match expected type ‘[Integer]
21:01:18 <lambdabot>                                      -> [Integer] -> [Integer] -> t’
21:01:29 <iqubic> > [[1, 2, 3] [4, 5, 6] [7, 8, 9] [10]] >>= id
21:01:33 <lambdabot>  error:
21:01:33 <lambdabot>      • Couldn't match expected type ‘[Integer]
21:01:33 <lambdabot>                                      -> [Integer] -> [Integer] -> [b]’
21:01:43 <iqubic> What's wrong with that?
21:01:49 <Koterpillar> iqubic: commas between lists
21:02:02 <iqubic> > [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]] >>= id
21:02:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:02:38 <iqubic> > Right (Right "Hello") >>= id
21:02:41 <lambdabot>  Right "Hello"
21:02:51 <iqubic> > Right (Left "Hello") >>= id
21:02:54 <lambdabot>  Left "Hello"
21:03:00 <iqubic> > Left (Left "Hello") >>= id
21:03:03 <lambdabot>  Left (Left "Hello")
21:03:13 <iqubic> > Left (Right "Hello") >>= id
21:03:15 <lambdabot>  Left (Right "Hello")
21:03:19 <iqubic> What?
21:03:20 <Koterpillar> tee hee
21:03:24 <iqubic> What the heck???
21:03:35 <Koterpillar> Either monad never changes the error type
21:03:46 <iqubic> You can't join if the outer part is Left?
21:03:55 <Koterpillar> if it started as Either String, it'll be Either String
21:03:58 <iqubic> So I see how join works.
21:04:10 <Koterpillar> you started as Either (Either String a), and you'll end up with Either (Either String a)
21:04:21 <Koterpillar> iqubic: try fmap on Either
21:04:28 <Koterpillar> > fmap negate (Right 1)
21:04:31 <lambdabot>  Right (-1)
21:04:34 <Koterpillar> > fmap negate (Left 1)
21:04:37 <lambdabot>  Left 1
21:04:51 <iqubic> Wait, that never changes the type or value of the error.
21:04:58 <Koterpillar> correct
21:05:17 <Koterpillar> you want the function under fmap to work on the actual values, not the error
21:05:24 <Koterpillar> > fmap negate (Left "haahaahahahaa")
21:05:27 <lambdabot>  Left "haahaahahahaa"
21:05:38 <Koterpillar> (what did you expect here?)
21:05:52 <Koterpillar> > fmap negate (Left (Left (Left "haahaahahahaa")))
21:05:54 <lambdabot>  Left (Left (Left "haahaahahahaa"))
21:06:22 <iqubic> > fmap negate Left $ Left $ Right -5
21:06:24 <lambdabot>  error:
21:06:24 <lambdabot>      • No instance for (Typeable b0)
21:06:24 <lambdabot>          arising from a use of ‘show_M662705632048384262710688’
21:06:36 <iqubic> > fmap negate Left (Left (Right -5))
21:06:39 <lambdabot>  error:
21:06:39 <lambdabot>      • No instance for (Typeable b0)
21:06:39 <lambdabot>          arising from a use of ‘show_M572224612319037068310699’
21:06:48 <Koterpillar> more brackets
21:06:50 <iqubic> > fmap negate $ Left $ Left $ Right -5
21:06:53 <lambdabot>  error:
21:06:53 <lambdabot>      • No instance for (Typeable b0)
21:06:53 <lambdabot>          arising from a use of ‘show_M693465644332150467910714’
21:07:11 <iqubic> > fmap negate (Left (Left (Right -5)))
21:07:14 <lambdabot>  error:
21:07:14 <lambdabot>      • No instance for (Typeable b0)
21:07:14 <lambdabot>          arising from a use of ‘show_M823180959412907230410747’
21:07:22 <Koterpillar> > (-5)
21:07:25 <lambdabot>  -5
21:07:30 <iqubic> > fmap negate (Left (Left (Right (-5))))
21:07:32 <lambdabot>  Left (Left (Right (-5)))
21:08:27 <Koterpillar> iqubic: if you try writing the Monad instance for Either yourself, you'll see that this is the only thing that can ever happen
21:08:43 <Koterpillar> (well, Functor for a start)
21:08:45 <iqubic> I'll do that.
21:08:49 <iqubic> Just not now.
21:08:54 <iqubic> I have homework to do.
21:09:14 <iqubic> But I'd love to do that.
21:09:25 <iqubic> Then maybe try ExceptT too.
21:09:35 <iqubic> Like try writing that out myself too.
21:10:31 <iqubic> And, as before, type holes are my friend
21:12:31 <iqubic> Just write a skeleton, use a type hole. Fill in part of the type hole, get a new type hole. Repeat.
21:31:18 <saurabhnanda> is there a way to build a collection/list of types? something like `AllCustomFields = [SingleLineField, MultiLineField, CheckboxField]`
21:32:10 <Koterpillar> and do what with it?
21:33:00 <saurabhn_> is there a way to build a collection/list of types? something like `AllCustomFields = [SingleLineField, MultiLineField, CheckboxField]`
21:33:50 <Koterpillar> and do what with it?
21:34:40 * ski is seeing double
21:34:54 * pacak confirms
21:35:08 * iqubic also confirms
21:38:29 <saurabhn_> Koterpillar: loop over it in the UI?
21:38:57 <saurabhn_> Koterpillar: "What kind of field do you want? <Single Line, Multi Line, Checkbox, ...>
21:39:59 <Koterpillar> data FieldType = SingleLineField | MultiLineField | CheckboxField
21:40:54 <saurabhn_> Koterpillar: nope, they need to be **TYPES** for various other reasons.
21:40:54 <pacak> class UI_Loopable
21:41:17 <iqubic> Why do they need to be types?
21:41:27 <saurabhn_> data SingleLineField = SingleLineField {slfName :: Text, slfHelpText :: Text, slfMinLength :: Int, slfMaxLength :: Int} 
21:41:31 <saurabhn_> data MultiLineField = MultiLineField {mlfName :: Text, mlfHelpText :: Text, mlfMinLength :: Int, mlfMaxLength :: Int, mlfRows :: Int} 
21:41:33 <pacak> data Loopable = forall a. UI_Loopable UL a
21:41:50 <pacak> [UL <single line>, UL ... ]
21:42:14 <Koterpillar> ^ that is one way
21:42:29 <saurabhn_> pacak: come again?
21:42:32 <iqubic> pacak: can't he just use an ADT with different records for each constructor?
21:42:41 <pacak> (12:40:32) pacak: class UI_Loopable
21:42:44 <pacak> (12:41:11) pacak: data Loopable = forall a. UI_Loopable UL a
21:42:46 <pacak> (12:41:28) pacak: [UL <single line>, UL ... ]
21:43:12 <iqubic> pacak: Would the class UI_Loopable have any functions with it?
21:43:23 <Koterpillar> I still feel like at some point, you'll need a function from FieldType to Loopable
21:43:43 <iqubic> Yeah.
21:43:51 <glguy> Another option is to make a new list type, normal [] is by definition a list of values that all have the same type.
21:44:00 <pacak> iqubic: If the goal is only to loop in UI - probably not, but if he wants to perform any operations - probably yes.
21:44:07 <iqubic> But what about my suggestion?
21:44:08 <glguy> but the sum type solution is the most likely best
21:44:18 <iqubic> can't he just use an ADT with different records for each constructor?
21:44:25 <iqubic> Won't that work?
21:44:27 <Koterpillar> GADT, yes
21:44:35 <saurabhn_> iqubic: that was my firt attempt
21:44:36 <iqubic> What's a GADT?
21:44:47 <saurabhn_> iqubic: but it doesn't work when you need to define typeclass instances for each ADT value.
21:44:47 <iqubic> generalized ADT?
21:45:00 <saurabhn_>  because typeclass instances can be defined only for *types*, not *ADT values*
21:45:01 <Koterpillar> data Field where SingleLine :: Text -> Text -> Int -> Int -> Field; MultiLine :: Text -> Text -> Int -> Int -> Int -> Field
21:45:19 <glguy> That's not a GADT, it just happens to use the syntax...
21:45:30 <pacak> that's just sum type
21:45:31 <iqubic> what is GADT?
21:45:32 <Koterpillar> actually, yes
21:45:32 <glguy> Where are GADTs coming into the solution?
21:45:50 <Axman6> 6psurely you meant data Loopable \ forall a. UI_Loopable a => UL a?
21:45:57 <Axman6> s/\/=
21:46:11 <Axman6> bloody hell, struggining with this new keyboard
21:46:17 <Axman6> sdfgkjh
21:46:57 <saurabhn_> glguy: this has actually nothing to do with GADTs. My original question was very straightforward, how do define a list of types.
21:47:17 <Axman6> saurabhn_: the problem is that this isn't straightforward
21:47:24 <iqubic> saurabhn_: Doesn't look like you can. At least not easily
21:47:32 <glguy> saurabhn_: the problem is that a list of types probably isn't what you actually want
21:47:56 <pacak> ['Int, 'Word] -- list of types!
21:47:56 <Koterpillar> so you've got the value (of some type) back from the UI, what do you do with it?
21:47:56 <glguy> it sounds like you might be asking for a list of values that don't all have the same type (which is something else)
21:48:02 <saurabhn_> glguy: well at this point in my design, that's exactly what I want :)
21:48:16 <glguy> saurabhn_: you can have a list of types, turn on DataKinds and make one
21:48:24 <Koterpillar> saurabhn_: you are describing a solution that you want; what is your problem?
21:48:35 <glguy> '[Int, Bool, Char] :: [*]
21:48:40 <glguy> but surely that's not going to help you
21:48:42 <glguy> that's a "list of types"
21:48:46 <iqubic> What is DataKinds?
21:48:47 <saurabhn_> writing an RFC on Reddit
21:48:48 <saurabhn_> kinda hard to exlain
21:48:58 <Koterpillar> saurabhn_: ultimately, you'll have to use this list to create a value, right?
21:49:19 <iqubic> I think what he wants here is a parser.
21:49:50 <glguy> saurabhn_: Was that list of types what you were looking for?
21:49:57 <saurabhn_> hang on, hang on.
21:50:11 <saurabhn_> [SingleLineField, MultiLineField, CheckboxField, DropdownField]
21:50:33 * pacak sighs
21:50:50 <glguy> OK, you're done. that's a list of types
21:51:19 <SrPx> Where can I read about Philip Wadler's history and contributions to Haskell?
21:51:57 <pacak> Are you trying to do Java in Haskell?
21:53:02 <saurabhn_> https://www.reddit.com/r/haskell/comments/68k456/rfc_how_to_model_types_with_some_common_behaviour/
21:53:44 <Koterpillar> are you sure this isn't GADT?
21:54:29 <saurabhn_> pacak: oh please. I'm sick of people trying to bash down idioms from other languages without trying to come up with viable idioms of their own. Please don't tell me how NOT to do things in Haskell. Please tell me the right way to do things in Haskell. That's far more constructive. /end of rant.
21:54:54 <Koterpillar> data Field where Checkbox :: Field Bool; SingleLine :: Field Text; MultiLine :: Field [Text]
21:54:57 <Koterpillar> saurabhn_: ^
21:55:06 <ski> .. it would help if we knew what you wanted to do
21:55:42 <glguy> Koterpillar: That won't load
21:55:43 <saurabhn_> ski: I know. Tried putting a long-form explanation on Reddit at https://www.reddit.com/r/haskell/comments/68k456/rfc_how_to_model_types_with_some_common_behaviour/
21:55:53 <Koterpillar> glguy: yeah, I missed a type parameter
21:56:04 <glguy> Koterpillar: and when you add the parameter it won't help
21:56:29 <glguy> now you can't write: [Checkbox, SingleLine]
21:56:56 <saurabhn_> ski: glguy: does the context in the Reddit post help?
21:58:21 <Koterpillar> glguy: you're right
21:59:19 <glguy> saurabhn_: You can just have: data Field = Checkbox | Singleline | Multiline...
21:59:19 <Koterpillar> glguy: combined with a forall type though?
21:59:30 <glguy> and then some logic that generates the next form based on the choice
21:59:36 <glguy> lists of types don't factor in here
21:59:54 <saurabhn_> glguy: is there a way to define typeclass instances for ADT values?
22:00:09 <ski> i don't understand what `FilterEq' is for, and so i don't understand "the good think about giving each field-type its own separate Haskell type is that one can define typeclass instances easily"
22:00:10 <glguy> You can only define type class instances for types
22:00:56 <ski> (i also don't know what the alternative(s ?) to "giving each field-type its own separate Haskell type" would be, in your mind)
22:01:44 <Lokathor> the drop function on Text is O(n), which seems unfortunate
22:01:49 <Lokathor> but i'm no UTF-16 expert
22:02:08 <glguy> Lokathor: that's the magic of variable width encodings like utf-16 and utf-8
22:02:22 <Lokathor> but Text says that, internally, it's always UTF-16
22:02:44 <glguy> and utf-16 is variable width
22:03:19 <Lokathor> but can't it just advance a pointer however many bytes the first character is, and then the rest of the bytes stay the same width?
22:03:52 <Lokathor> because Text.head is O(1), which is what's strange to me you see
22:03:53 <glguy> each code point takes either 16-bit or 32-bit
22:04:07 <Axman6> each utf-16 codepoint is 16 bits, but they may be combined
22:04:09 <Axman6> iirc
22:04:19 <Lokathor> ah, oh well
22:04:36 <Axman6> (my knowledhe of the exact terminology is pretty poor)
22:05:10 <Axman6> so finding the nth codepoint is O(1) but the nth... character? is O(n)
22:05:14 <glguy> U+10000 to U+10FFFF are encoded as "surrogate pairs"
22:05:27 <glguy> so indexing a Text has to be O(n), too
22:05:41 <Axman6> yeah
22:06:42 <Lokathor> wait wait
22:07:00 <Lokathor> is the 'n' in drop's O(n) the Text length or the drop value?
22:07:16 <cocreature> drop value
22:07:26 <Lokathor> ohhhhhh, okay that makes sense :P
22:07:31 <Axman6> I think it must be the length
22:07:43 <iqubic> So going back to what saurbahn_ wanted, can't he just use pattern matching to get filterEq to work with an ADT?
22:07:45 <cocreature> Axman6: huh? why
22:07:45 <Axman6> in the worst case you might have to look at the whole Text value
22:08:05 <Axman6> because of the above problem
22:08:15 <cocreature> Axman6: right but then the drop value is larger than the Text length so O(drop value) still works
22:08:23 <Lokathor> Axman6, if you can look at the head in O(1), i'm not sure why you can't drop 1 in O(1), for example
22:08:35 <nshepperd> you have to decode each character that you drop to identify its size
22:09:22 <nshepperd> you don't need to look at the rest of the string
22:10:29 <Axman6> https://en.wikipedia.org/wiki/UTF-16#Description
22:10:36 <nshepperd> 'drop n xs' is even O(min(n, length xs)), really
22:11:47 <Axman6> afaict, the maximum size of a single unicode codepoint is two 16 bit values
22:13:28 <iqubic> Whis the difference between UTF-16 and UTF-8?
22:14:22 <iqubic> s/Whis/What is
22:14:28 <Lokathor> http://lpaste.net/355095 whee
22:15:06 <nshepperd> Axman6: yes. so drop n takes n steps
22:16:00 <nshepperd> each step being O(1) to uncons 2 bytes, check whether it's a surrogate pair, and if so uncons another 2 bytes
22:17:17 <Maxdamantus> is the goal to split by codepoints or characters?
22:18:15 <Maxdamantus> note that something like 'a】is represented as two codepoints.
22:18:39 <Maxdamantus> assuming my phone's terminal didn't mess that up.
22:19:03 <Maxdamantus> > "a\769"
22:19:05 <lambdabot>  "a\769"
22:19:29 <ski> > text "a\769"
22:19:31 <lambdabot>  á
22:20:20 <ski> > "á"
22:20:22 <lambdabot>  "\225"
22:21:01 <pacak> > "аa"
22:21:03 <lambdabot>  "\1072a"
22:21:10 <nshepperd> codepoints, probably. can't represent a sequence of combining diacritics with a Char
22:23:49 <ski> > "á"
22:23:52 <lambdabot>  "a\769"
22:24:25 <iqubic> >"a?"
22:24:30 <iqubic> > "a?"
22:24:33 <lambdabot>  "a?"
22:25:33 <iqubic> Can GeneralizedNewtypeDeriving became an official part of Haskell please? 
22:25:36 <iqubic> Thank you.
22:57:55 <wizwizwizwiz> is there any hope of one programming language coming to dominate most application domains
22:58:05 <wizwizwizwiz> or is a diversity of languages an inevitability
22:58:27 <pacak> wizwizwizwiz: There's no hope.
22:58:42 <wizwizwizwiz> pacak: is there a no hope theorem?
22:58:48 <wizwizwizwiz> perhaps we need a new hope,...
23:00:15 <wizwizwizwiz> care to justify that perspective?
23:01:22 <pacak> Let's pick language A - arbitrary assembly language for a low powered SoC. Let's pick language B - a theorem prover that can prove that a + a = b + a and can probably even calculate how much 4 + 5 is (taking a few minutes on that).
23:01:35 <pacak> Then try to apply language A where language B fits and vice versa.
23:02:03 <wizwizwizwiz> well,... one might argue that theorem provers should be separated as "language tooling"
23:02:11 <wizwizwizwiz> so you specify the program in the programming language
23:02:39 <wizwizwizwiz> but then can reason about certain properties of it which are not part of the language using the tooling
23:03:50 <spatial> hmatrix Vectors are mutable ?
23:04:36 <cocreature> spatial: afaik they are
23:04:41 <cocreature> eh no I meant immutable
23:05:07 <spatial> How can I change and element ? Some references to runST are there
23:05:09 <pacak> spatial: I don't think soi.
23:05:29 <spatial> http://dis.um.es/~alberto/material/hmatrix.pdf
23:05:44 <Axman6> There might be mutable versions of each type, like how Vector does things
23:06:50 <spatial> Page 16.
23:06:56 <cocreature> there is https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra-Devel.html#v:runSTVector
23:07:12 <glguy> There are unsafe operations that can turn an "immutable" storable vector into a mutable one, (and safe versions, too, that copy)
23:07:25 <pacak> cocreature: But that's STVector, not Vector :)
23:07:36 <glguy> the operations are called "thaw" and "freeze"
23:07:36 <cocreature> right
23:08:15 <glguy> But one will find unexpected results trying to mutable otherwise "immutable" vectors and then using them again
23:08:43 <pacak> (unsafe thaw and freeze can lead to enormous amounts of fun https://github.com/tibbe/unordered-containers/issues/147)
23:10:03 <spatial> I started with a Vector
23:10:16 <pacak> I especially like the part when `a /= b && show a == show b` holds for a, b :: Int.
23:10:50 <pacak> Or even show a /=  show b && show a == show b...
23:10:55 <cocreature> pacak: I’ve seen this bug report and the corresponding ghc issue before but I’m still scared by it
23:11:21 <wizwizwizwiz> i find it intersting that the mathematics/physical sciences/engineering community has a very uniform notation for mathematics with only minor variations (like i versus j for current or transposed matrix representations in computer graphics)
23:12:46 <wizwizwizwiz> that is a pretty remarkable accomplishment
23:17:29 <spatial> You mean I can copy the Vector and change it ?
23:17:56 <pacak> thaw, change, freeze
23:29:39 <Myrl-saki> How to add documentation for a package I want to publish to Hackage?
23:31:26 <cocreature> Myrl-saki: are you asking how to upload the generated haddocks it or how you can add haddock documentation to your package?
23:31:45 <Myrl-saki> The latter, I think.
23:32:08 <cocreature> the haddock user guide is fairly readable https://www.haskell.org/haddock/doc/html/
23:32:23 <cocreature> you can generate the haddocks using `cabal haddock` or `stack haddock`
23:32:57 <Myrl-saki> Thanks. I'll give it a try.
23:33:22 <cocreature> also just looking at the source of packages on hackage can help figuring out the markup for specific kinds of documentation
23:34:08 <Myrl-saki> I get MemoTrie errors, I think?
23:34:30 <cocreature> you’re going to need to provide a bit more information here
23:34:40 <Myrl-saki> Yeah.
23:34:44 <Myrl-saki> This is ghcjs.
23:34:50 <Myrl-saki> Let me upload the log.
23:35:11 <Myrl-saki> http://ix.io/slg
23:37:21 <Myrl-saki> I'm trying without ghcjs, if that changes anything.
23:37:47 <Lokathor> http://lpaste.net/355096
23:37:47 <cocreature> huh that’s a weird error
23:37:55 <cocreature> sry not sure what’s going on here
23:38:06 <Myrl-saki> cocreature: It's fine. I'm wondering if it's because I'm using ghcjs.
23:39:05 <Myrl-saki> Lokathor: Do lines 12-15 get shown in the documentation?
23:39:13 <cocreature> Myrl-saki: afaik the differences between ghcjs and ghc are far below the layer of the parser, so parse errors like this shouldn’t be specific to ghcjs. but trying to reproduce it using ghc is probably still a good idea
23:39:28 <Lokathor> Myrl-saki, nope, not at all
23:39:48 <Myrl-saki> Lokathor: FOr functions, how do you annotate the arguments?
23:39:51 <cocreature> line 1-3 and 8-9 will get shown in the docs
23:40:01 <cocreature> Myrl-saki: https://www.haskell.org/haddock/doc/html/ch03s02.html#idm140354810892448
23:40:21 <Lokathor> Myrl-saki, you can use the same "-- ^" comment markup and split the signature over more than one line
23:40:35 <Myrl-saki> Also happens with ghc.
23:40:40 <Myrl-saki> :(
23:41:02 <Myrl-saki> https://github.com/conal/MemoTrie/issues/10
23:41:12 <Myrl-saki> Exact problem lol
23:41:39 <cocreature> seems like you just need to use a newer version
23:42:40 <Myrl-saki> Mhm.
23:42:44 <Myrl-saki> Trying 0.6.5.
23:43:12 <Myrl-saki> How long does stack haddock take to engerate, and how large do the docs tend to be? (And how do I clean them up later)
23:43:57 <prat> \help
23:46:19 <Lokathor> Myrl-saki, longer the first time, stack rebuilds with docs enabled. After that, not too long
23:46:54 <Lokathor> and you can just clear out the .stack-work/ directory to clean all your build files and docs and all that, or you can also clear just the docs if you look around inside
