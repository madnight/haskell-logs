00:14:07 <matrium> hi, a library exports an "newtype PrefixMappings   = PrefixMappings (Map T.Text T.Text) deriving (Eq, Ord,NFData, Generic)". Is it possible for me to use functions on an instance of the newtype that take the generic Map as a parameter?
00:15:20 <quchen> You mean whether you can e.g. use ¬ªMap.insert¬´ on a PrefixMappings directly? No.
00:40:33 <matrium> quchen: ok, thanks. So I have to entirely rely on the functions for the newtype, exported by the module?
00:49:54 <quchen> matrium: ¬ªrely¬´?
00:50:07 <quchen> You‚Äôll have to unpack it every time to gain access to the Map, if that‚Äôs what you mean
00:51:08 <quchen> Or write a function ¬ªPrefixMappings -> (Map k v -> Map k v) -> PrefixMappings¬´ and use that like ¬ªwithPrefixMapping foobar (\containedMap -> insert key value containedMap)¬´
00:53:12 <[exa]> quchen: offtopic just out of curiosity, what keyboard shortcut do you have for these ¬ªquotes¬´ ?
00:54:58 <quchen> [exa]: Shift-4 ¬ª  Shift-5 ¬´  I type QWERTZ with the 3rd layer taken from Neo http://www.neo-layout.org/
00:55:19 <quchen> Can recommend it fully without any drawbacks. (Works equally well with QWERTY.)
00:55:42 <[exa]> quchen: cool thanks
00:56:23 <quchen> Time to reach speed parity with before was just a few days, none of which were painful. (Going full neo *is* painful and takes much longer, but special characters are straightforward.)
01:10:50 <quchen> I now type special characters pretty much as fast as capital letters, including combinations.
01:11:09 <quchen> >>= is iio
01:11:15 <quchen> -> is li
01:11:27 <quchen> :-) is √∂lk (roll your right hand over the keyboard)
01:11:41 <quchen> <+> is uni
01:11:54 <quchen> ‚Ä¶ you get the idea
01:12:05 <quchen> ‚Ä¶ is on Q on the 3rd layer by the way :-)
01:15:15 <akr[m]> quchen: seems interesting, but it's for German only?
01:15:40 <quchen> Not really, no.
01:16:02 <quchen> I mean *Neo* is made for German, but there‚Äôs not much to it that makes it ¬ªGerman only¬´.
01:16:26 <quchen> On the US layout you‚Äôd have to use the key above return as your right-hand 3rd layer modifier.
01:16:31 <akr[m]> I meant that the layout is constructed for the German language
01:16:31 <quchen> But that‚Äôs it.
01:16:51 <quchen> Full Neo? Yes. But it works well for English as well.
01:17:28 <quchen> The only issue is that German has ¬ªsch¬´ instead of ¬ªsh¬´, and ¬ªsh¬´ is typed via the QWERTY-¬ªhu¬´.
01:17:49 <quchen> So that‚Äôs two times the same finger, which is otherwise very rare.
01:18:28 <akr[m]> ah, ok
01:18:42 <quchen> And since lots of crappy programs assume QWERTY or something not too far from it, going full Neo can be a bit of work. Examples: Games.
01:18:47 <quchen> WASD is all over the place in Neo.
01:18:56 <quchen> Can‚Äôt reconfigure the game? You‚Äôre screwed.
01:19:03 <quchen> Vim? You‚Äôre screwed.
01:19:42 <akr[m]> well ideally they would also provide a vim mapping on the website :)
01:19:44 <quchen> hjkl is u/ze.
01:20:01 <hastell> Does anyone know if there are functions available to traverse graphs in https://github.com/snowleopard/alga ?
01:20:13 <quchen> Sure, but you don‚Äôt want to worry about this every time you start a new program. But I know people that use Neo and love it.
01:20:27 <quchen> Anyway, this is OT so now that there‚Äôs a Haskell question I‚Äôll stop :-)
01:28:23 <akr[m]> anyone using the `has` library?
01:28:32 <akr[m]> I'm having trouble building it https://github.com/nonowarn/has/issues/2
01:30:04 <akr[m]> also, stack-related question: if I'm using a non-lts resolver, can I expect my project to compile in the future as is or not really?
01:31:12 <quchen> akr[m]: I didn‚Äôt experience many breaking issues with Stackage so far, so I‚Äôd say when it builds with LTS it likely builds with most things 
01:31:50 <akr[m]> but I'm not / can't use LTS
01:32:25 <akr[m]> hmm, or, at least don't know how - one of my dependencies conflicts with a package in the lts
01:33:33 <quchen> You can override the LTS choices in your stack.yaml
01:33:49 <quchen> So you can just add whatever lib you want instead
01:34:08 <akr[m]> ah okay I should try that
01:34:13 <quchen> https://github.com/quchen/stgi/blob/wl-pprint-dependency-rewritten/stack.yaml
01:34:24 <quchen> Here I‚Äôm using my own fork of wl-pprint instead of the Hackage-provided one
01:34:50 <akr[m]> I see, thank you
02:18:32 <Naga31> Hello everyone. I'm puzzled by a task i'm given and would really appreciate if someone quickly looked over it. I summed it up in a structured pastebin: https://pastebin.com/CY8TVBpf
02:22:38 <quchen> What kind of terrorist asks his students a straightforward problem and excludes the obvious straightforward solution?!
02:23:56 <quchen> The only way to solve this is by using the same semantics that lists give you, but since you‚Äôre not allowed to use lists or their semantics, you‚Äôll have to obfuscate the solution enough for it not to be recognizable.
02:24:05 <Naga31> I dont know. We just started with Haskell, so even if he allowed lists - i'd have to look it up. Hes expecting us to solve it without them, though. :-(
02:24:40 <Naga31> I was thinking about a somewhat complicated recursion, with 2 help-functions
02:24:47 <Naga31> one iterating through x values and one through y
02:24:52 <quchen> With lists, there‚Äôs an elegant and easy to understand solution. Without lists, you have to write the recursion yourself.
02:24:54 <Naga31> but that doesnt seem very elegant to me.
02:25:07 <unlmtd[m]> its quite obscure how to contribute to packages on hackage. any guidelines?
02:25:21 <quchen> unlmtd[m]: Step 1, make an account
02:25:56 <unlmtd[m]> I mean, do they use git? I dont see any git trees there, just a raw text source page
02:26:47 <merijn> unlmtd[m]: Hackage pages should have a link to the repository
02:26:55 <merijn> unlmtd[m]: Hackage is package hosting, not development hosting
02:27:14 <merijn> unlmtd[m]: People use whatever they want as version control separate from Hackage
02:27:31 <merijn> git, darcs, mercurial, fossil, SVN, CVS (for the true masochist), whatever
02:28:29 <unlmtd[m]> im guessing the packages im interested in dont have a public repo
02:28:42 <merijn> unlmtd[m]: Like?
02:28:57 <unlmtd[m]> dont forget pijul. tried it lately and I was very impressed
02:29:20 <quchen> Naga31: Something like this? http://lpaste.net/354879
02:29:38 <unlmtd[m]> wait I just had a 'slap in the face' moment
02:29:40 <quchen> Naga31: I haven‚Äôt tested it, but the idea is manually enumerating all the matrix entries and counting how often the predicate holds.
02:30:40 <unlmtd[m]> I was in a sub-section of a bigger module, lol
02:31:08 <merijn> unlmtd[m]: Yeah, the repo links are listed on the "Contents" main page for packages :)
02:36:09 <unlmtd[m]> anyone who uses yi?
02:36:56 <merijn> Probably not many, I'd say it's about 1/3rd vim, 1/3rd emacs, 1/3rd "other" in here :)
02:37:31 <LordBrain> i made a contribution to yi way back when it was mostly don stewart working on it
02:38:11 <unlmtd[m]> may be cool to build HS interface for xi, which is supposed to be very fast
02:38:25 <LordBrain> did you mean yi, or is xi another one?
02:38:54 <unlmtd[m]> https://github.com/google/xi-editor
02:39:03 <LordBrain> i'd like an improved version of vim really, nothing creative, just something incredibly compatible
02:39:07 <unlmtd[m]> very cool theory behind it
02:39:46 <unlmtd[m]> vim has shown some anoying limitations in term of remapping keys
02:39:58 <merijn> Really? What kinda remapping are you trying to make?
02:40:23 <LordBrain> try #vim first, maybe some expert can tell ya how to do it
02:40:44 <unlmtd[m]> I want a much more modular approach to the keyboard. I need a lower level access, something like langmap but deeper and covering everything
02:40:52 <LordBrain> i've noticed glitchiness in vim tho, actual bugs
02:40:58 <unlmtd[m]> I think iv covered the options already
02:41:15 <merijn> LordBrain: Well, how old is your vim? :p
02:41:26 <LordBrain> well, vim 7 from debian stable
02:41:30 <merijn> LordBrain: Some systems have nearly decades old vim versions because no one ever updated :p
02:41:33 <unlmtd[m]> well im on nvim for the record
02:41:53 <LordBrain> yeah merijn but.. it should have been bug free a decade ago
02:42:10 <merijn> LordBrain: Have you ever looked at the vim codebase? It's a wonder it works at all :p
02:42:15 <LordBrain> well "bug free" you know what i mean
02:42:35 <merijn> I guess it depends on what you do, I've never really ran into any issue
02:42:54 <unlmtd[m]> the acidic dreamy-plans I had about the keyboard actually involved a system-wide system to handle the input which can be interacted with by individual applications, like vim. inputs in general are quite broken
02:43:17 <LordBrain> i mean it was surprising to me, the bugs, because it had a good reputation for being solid before i noticed them
02:43:19 <kuribas> I'd like to write a purescript frontend for emacs, and then improve haskell-mode...
02:43:35 <LordBrain> it may be some kind of bitrot, like something about the system changed that vim relied upon
02:43:59 <unlmtd[m]> probably the legacy of trying to run algorithms in 512bits of ram
02:44:00 <unlmtd[m]> or memory whatever
02:44:23 <LordBrain> no
02:44:30 <LordBrain> they didnt show up that long ago
02:44:32 <merijn> unlmtd[m]: Depends on your OS, OSX lets you do pretty fancy things with keyboard input
02:44:47 <LordBrain> i mean, long for now, but there was a period during hte gigabyte era, where vim was working fine for me
02:45:17 <LordBrain> it got seemingly more buggy like a couple of years ago only
02:45:38 <LordBrain> i actually did download the source and take a peek
02:46:27 <xintron> I'm using necoghc-vim + ghc-mod for autocompletion in vim but every time I add a new dependency to my project I need to restart vim to get autocompletion working for the new module. Does anyone know how to work around this?
02:46:39 <LordBrain> maybe they've fixed the bugs tho, and i didnt notice, its been fine lately
02:47:28 <unlmtd[m]> merijn: not at all on the level im thinking
02:47:29 <merijn> xintron: Sounds like it's only inspecting your cabal setup when you launch vim and never after. Not sure if that's easily fixable
02:48:24 <merijn> unlmtd[m]: Really? I've been able to do some incredibly fancy things with minimal effort. LaTeX to unicode mapping, arbitrarily complex keyboard layouts and remappings, applications specific mappings, etc.
02:48:29 <xintron> matrium, My understanding is that every completion calls ghc-mod so I don't see why the cache should have any affect here (and if the cache is vim-specific or not)
02:49:34 <unlmtd[m]> merijn: more like having a general concept, like "opening" or "spawning a new instance", and those can be assigned to a certain input, then every program can refer to the system-wide configuration to associate its own "opening" and "spawning new instance" to the keys configured as such. No more configuring shortcuts in every applications
02:50:12 <unlmtd[m]> install a new program and start using your muscle memory with it instantly
02:50:48 <LordBrain> hmm
02:51:09 <LordBrain> you could do that tho, no? i mean if the programs wanted to do that they could provide vim files
02:51:45 <LordBrain> to get everyone to participate, you need something to become standard, one fancy editor using it wouldnt be good enough
02:52:27 <LordBrain> and that has a benefit for the consumer, but then the standard whatever it is, its going to end up being a common denominator
02:54:15 <LordBrain> and the new thing would take a while for adoption, we'd have the old things around for legacy, and so there is the meantime complexity cost
02:54:39 <LordBrain> most likely the legacy wouldnt go away, because hey it supports this or that that the new thing doesnt
02:55:25 <LordBrain> so i guess, you need a scalable standard
02:56:04 <LordBrain> something that has a core of features supported everywhere, detectability of new features, kind of like html for key binding.
02:56:53 <LordBrain> the libm17n package has a key-binding language, lisp-like
02:57:16 <LordBrain> you could mess around with that right now, it will work in your editor if you install ibus-m17n, it works everywhere.
02:58:36 <LordBrain> i use it to get all those digraphs when i'm not in vim... so i can make symbols the vim way here in xchat, etc
02:59:01 <LordBrain> so e' becomes È
02:59:49 <LordBrain> i once even set it up to use ctrl-k as the trigger, just like vim does, but i lost my work
03:00:05 <LordBrain> also i dont think ctrl-k is ideal anyway
03:05:06 <unlmtd[m]> thanks
03:05:42 <unlmtd[m]> input is going to change tremendously in the coming years
03:06:01 <unlmtd[m]> so wel
03:06:23 <LordBrain> we can offload some of the editor functions to the operating system instead
03:06:24 <unlmtd[m]> well need a common interface for all those new way of giving inputs to interract with our system
03:06:41 <unlmtd[m]> thats why I like xi, its built very modularly
03:06:48 <LordBrain> but we cant have wars, so we have to support both moded editing vim style and emacs style editing
03:07:21 <unlmtd[m]> think about voice, eye movement as inputs, maybe a new kind of hand input factor
03:07:47 <unlmtd[m]> so keyboard gets refactored in the process
03:07:48 <LordBrain> oh definitely
03:08:02 <LordBrain> i was looking a bit at implementing robot computer vision
03:08:15 <unlmtd[m]> I dont think vim is ready for that
03:08:16 <LordBrain> without lidar
03:08:34 <LordBrain> well, a vim-sub-system is what we need
03:08:39 <LordBrain> as in
03:08:54 <unlmtd[m]> xi
03:08:56 <LordBrain> its not vim, and its not even an editor, its an editor support layer built into the system
03:09:36 <unlmtd[m]> right, so its on open field, which means lots of work
03:10:03 <javjarfer> hi everyone, there is any difference between this two kind signatures? T :: forall k. (k -> *) -> *, T :: (* -> *) -> * -> *
03:11:10 <javjarfer> okay sorry the first one is "T :: forall k. (k -> *) -> k -> *"
03:11:32 <pacak> First one is more general
03:11:52 <javjarfer> I see... in the second one the second parameter type is not fixed by the former function parameter
03:12:10 <unlmtd[m]> looks like google is designing our next kernel
03:12:13 <pacak> That as well
03:13:48 <javjarfer> pacak, thanks I only needed to say it louder xD
03:20:32 <NickHu> Is there a neater way of doing x = record (lens ^. a) (lens ^. b) ... (lens ^. z)?
03:53:37 <tomboy64> record $ map (lens ^.) [a..z] ?
03:53:45 <tomboy64> if that even works
03:53:47 <tomboy64> :D
03:55:02 <pacak> :t record
03:55:03 <lambdabot> error:
03:55:03 <lambdabot>     ‚Ä¢ Variable not in scope: record
03:55:03 <lambdabot>     ‚Ä¢ Perhaps you meant ‚Äòsecond‚Äô (imported from Control.Arrow)
03:55:15 <pacak> NickHu: Record? O_o
03:55:49 <mivael> tomboy64, this does not look like equivalent of the original expression
04:16:16 <ph88_> how can i convert a Double to bytestring ascii ?
04:16:45 <ph88_> 1.23 -> "1.23"
04:17:27 <liste> @hackage bytestring-show
04:17:27 <lambdabot> http://hackage.haskell.org/package/bytestring-show
04:20:00 <ph88_> liste, that looks nice .. i'm surprised though that i would need a package of this .. isn't there something in base or more primitive libraries ?
04:50:57 <mivael> Hello!  Could someone advise me on better ways of using ByteString (or maybe not ByteString)?  I achieved faster input/output but now I do not like my source code :)   Details are here: http://codepad.org/xJFmWwBf
04:59:41 <merijn> mivael: By using attoparsec to parse the bytestring
05:00:35 <mivael> merijn, thank you, I will look into it
05:03:02 <Axman6> yeah that definitely needs a proper parser library
05:27:10 <mivael> Are there ready-to-use attoparsec+ByteString templates/examples you would recommend?  Or, maybe, I'd be better just read attoparsec docs?
05:28:39 <merijn> mivael: I'd recommend reading one of the Parsec tutorials/examples, since attoparsec has basically the same general idea
05:28:58 <merijn> In fact, most Parsec parser can be turned into attoparsec parsers by replacing 1 or 2 imports
05:32:06 <ph88_> hi guys, i'm trying to write a conduit function that turns Double into ByteString .. the code i wrote requires an instance with Maybe https://bpaste.net/show/70ca475b1755  but i'm not sure why that Maybe is there and what i did wrong
05:33:09 <MarcelineVQ> what's the type of await
05:36:25 <cocreature> ph88_: MarcelineVQ already hinted you at the solution. await gives you a Maybe
05:38:49 <KingBuzzo> hey folks, I'm currently implementing a rather complicated algorithm for my master's thesis and the core element of the algorithm is a two-dimensional table. i've used the array type in haskell and both time and memory consumption literally explode even with a rather small table. any idea what the problem might be?
05:39:12 <kuribas> KingBuzzo: lazyness?
05:39:39 <kuribas> KingBuzzo: Hard to tell from the information you have given.
05:40:08 <KingBuzzo> i broke my code down to a very short expression to focus solely on the problem. can i just paste it in here?
05:40:29 <mizu_no_oto_work> KingBuzzo: http://lpaste.net/new/haskell
05:41:11 <kuribas> KingBuzzo: If possible use unboxed matrices: https://hackage.haskell.org/package/matrices
05:41:14 <merijn> Array is also not very good for matrices
05:41:17 <MarcelineVQ> lpaste sure is slow lately ehe
05:41:27 <merijn> Depending on your computation you might also just want hblas
05:41:37 <merijn> Which are haskell bindings for BLAS
05:42:11 <kuribas> KingBuzzo: also, modifying immutable matrices is going to be very slow.
05:42:27 <kuribas> KingBuzzo: because you need to copy the whole matrix
05:42:53 <KingBuzzo> i don't need to modify anything. just need to have access to already computed entries when computing new ones
05:43:15 <kuribas> alternatively use lisppaste: http://paste.lisp.org/
05:44:08 <kuribas> KingBuzzo: dynamic programming?
05:44:19 <merijn> ok, so I'm updating my vim/haskell setup and I keep running into people using neocomplete, but as of yet I'm unsure what the hell neocomplete actually *does*, anyone that can explain?
05:44:20 <KingBuzzo> kuribas: yep!
05:44:28 <ph88_> how do i go from a conduit stream of Double to an unboxed vector ?
05:44:53 <kuribas> KingBuzzo: lazyness may work, but a mutable unboxed array is going to be faster.
05:45:53 <lpaste> KingBuZZo pasted ‚Äúarray problem‚Äù at http://lpaste.net/354882
05:47:24 <cocreature> KingBuzzo: so what values are you using for width and height that cause the claim that ‚Äúmemory consumption explodes‚Äù? also how are you measuring this?
05:48:14 <kuribas> KingBuzzo: so you use an unboxed array of Integer?
05:48:30 <KingBuzzo> for width=height=2000, ghci already needs 3 seconds and 2 gig of space consumption
05:48:40 <ph88_> KingBuzzo, not related to your question of memory usage but maybe this package will be interesting for you too https://hackage.haskell.org/package/hmatrix 
05:48:46 <KingBuzzo> and i need to deal with much bigger tables basically
05:48:50 <cocreature> KingBuzzo: how are you measuring the 2gig
05:49:55 <KingBuzzo> using the :set +s option in ghci, it tells me for width = height = 2000 the following (2,92 secs, 2.146.888.368 bytes)
05:50:24 <cocreature> that‚Äôs the memory allocated, not the max memory residency
05:50:25 <MarcelineVQ> ah, you're in luck, that's not max residency but total allocations
05:50:34 <kuribas> KingBuzzo: ghci isn't very efficient, try compiling
05:50:50 <KingBuzzo> it's much more than the two other algorithms dealing with this problem take
05:51:02 <KingBuzzo> which i already implemented successfully
05:51:14 <cocreature> also add explicit type signatures
05:52:10 <KingBuzzo> okay so from what i gathered, using a different data type for the table should solve the problem right? sorry if my questions are noobish
05:52:41 <KingBuzzo> the table isn't filled with integers but a custom data type which itself consists of three Ints BTW
05:53:04 <mizu_no_oto_work> KingBuzzo: before you rewrite it, how does it perform if you compile it with -O2?
05:54:12 <ph88_> does hmatrix have efficient memory usage ?
05:54:14 <KingBuzzo> what do you mean with -O2?
05:54:24 <ph88_> KingBuzzo, O2 is the maximum optimization level of ghc
05:54:46 <mizu_no_oto_work> It's a compiler flag to optimize your code
05:54:51 <ph88_> there are also other optimizations you can turn on (i don't know them of the top of my head though)
05:55:02 <KingBuzzo> gimme a second i'll try
05:55:04 <kuribas> ph88_: probably, since it uses the ffi
05:55:23 <ph88_> i was thinking maybe hmatrix can help KingBuzzo with his problem
05:55:39 <ph88_> 1027 commits on that package
05:56:15 <kuribas> I like the matrices package, because it's pure haskell.
05:56:34 <ph88_> i'm sure you like speed too :P
05:56:54 <kuribas> matrices is based on Data.Vector
05:56:57 <ph88_> actually i don't know the speed of hmatrix or matrices :D
05:57:32 <kuribas> KingBuzzo: if you are doing image manipulation have a look at repa and repa-devil
05:57:54 <cocreature> I don‚Äôt think either matrices or hmatrix are particularly useful for the kind of dynamic programming problem KingBuzzo is having
05:58:11 <cocreature> they‚Äôre more targeted at collective operations like matrix multiplication
05:58:26 <ph88_> what does he need ?
05:58:40 <cocreature> they pasted their code above
05:58:43 <ph88_> oh
05:59:42 <KingBuzzo> the algorithm deals with comparing grammar-compressed words for equality. calculating the table entries is the sophisticated part, but that's not my problem, what i wrote works fine. in the end, all i need to do is read one particular table entry
06:01:10 <merijn> Anyone have any pointers on how to get the hoogle commandline program to be useful? A lot of documentation on it seems horrifically out of date
06:01:27 <cocreature> merijn: use hoogle 5 which indexes all of stackage
06:02:11 <merijn> cocreature: I want it setup so that it also indexes every locally installed package (and preferably sandboxes)
06:02:22 <merijn> I know cabal is Hoogle aware now, but I'm unsure how to fit things together
06:02:42 <cocreature> merijn: sry I only know how to do this with stack (it just includes a stack hoogle command)
06:02:55 <cocreature> I also would expect that cabal still uses the old format
06:03:50 <merijn> cocreature: Why? Cabal support was added only fairly recently afaik
06:04:36 <cocreature> merijn: it‚Äôs not that recent iirc while hoogle 5 is quite new
06:04:45 <cocreature> but I‚Äôm happy to be proven wrong
06:05:48 <cocreature> merijn: according to the Cabal changelog it‚Äôs supported since 2008 so maybe you are referring to something different
06:07:35 <merijn> hmmm
06:08:16 <merijn> Hoogle supposedly supports a textual interface (which cabal generates via haddock) and a binary one and you can convert the textual to the binary one
06:08:25 <merijn> At least, that's what the wiki says (which the package links to)
06:09:26 <KingBuzzo> i'm gonna give hmatrix a try, thanks for your help!
06:10:49 <merijn> cocreature: Anyway, this is entirely my problem, there doesn't seem to be any comprehensive description of how to make things work :)
06:11:50 <ph88_> KingBuzzo, do you know how to check the max memory residency ?
06:12:29 <KingBuzzo> nope.
06:12:41 <cocreature> merijn: maybe "hoogle generate --local" works?
06:14:15 <KingBuzzo> thing is that this algorithm should run faster than another one but doesn't. basically i just need an efficient datatype for the table that allows me to read already computed values when calculating a new one
06:14:15 <cocreature> merijn: I think https://github.com/ndmitchell/hoogle/blob/master/docs/Install.md is the document that you should consult
06:14:18 <ph88_> KingBuzzo, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#profiling-memory-usage
06:14:50 <cocreature> KingBuzzo: the "vector" package can often be master than "array", especially if you use unboxed vectors
06:15:09 <ph88_> i think he means vector can be faster than array
06:15:29 <cocreature> eh yeah s/master/faster/
06:15:31 <cocreature> typing is hard
06:16:00 <ph88_> unboxed vectors
06:16:27 <KingBuzzo> alright then i'll try those out i guess. thanks!
06:18:54 <merijn> cocreature: Somehow doing that ends up with 81 package missing databases, according to the commandline. I'll try again some other time...I mean, someone must've managed to get it working...
06:19:16 <cocreature> merijn: have you enabled the hoogle stuff in your cabal config?
06:19:21 <merijn> cocreature: Yeah
06:19:30 <KingBuzzo> the tables dimensions correspond with the number of production rules in the grammar i'm working with. the two other algorithms can deal with up to 1 million production rules and take less than one or two minutes for computations. in theory, the table should give me similar results
06:19:32 <cocreature> merijn: hm sorry I‚Äôm out of ideas
06:21:39 <kuribas> cocreature: or matrices, which is just a wrapper around vector
06:33:08 <ExpHP> https://github.com/k0ral/conduit-parse/blob/master/Data/Conduit/Parser/Internal.hs#L44-L48 -- "tell me more master, is this why (<|>) unconditionally uses catchError, and try = id?"
06:33:57 * ExpHP has had it up to here with O(n) memory "surprises"
06:35:10 <merijn> ExpHP: Well, the only alternative is randomly dropping an unknown number of items when a parse fails
06:35:23 <merijn> Which seems...undesirable
06:35:32 <ExpHP> merijn: which is perfect and has O(1) memory in the common case
06:35:47 <merijn> ExpHP: How is that perfect if you rely on backtracking for parsing?
06:36:02 <ExpHP> merijn: I don't!
06:36:21 <merijn> ExpHP: Well, don't use a stream parser then?
06:36:30 <merijn> ExpHP: That's whayt they're for....
06:36:31 <ExpHP> I can parse the entire file using only one token of lookahead, which conduit provides with peek
06:37:37 <ExpHP> merijn: any idea why the Parsing typeclass has a "try" method then?
06:38:12 <merijn> ExpHP: Because try is for backtracking parsing?
06:38:20 <ExpHP> (also, isn't "randomly losing x tokens" what Parsec does?)
06:39:08 <merijn> ExpHP: parsec requires explicit try to backtrack, but afaik most other parser combinator libraries don't
06:39:43 <ExpHP> merijn if try is for backtracking parsing, that seems to imply there's a usecase for non-backtracking
06:40:03 <ExpHP> otherwise all Parsings would have implicit backtracking
06:41:02 <merijn> ExpHP: The parsing typeclass is a generic interface, not all instances actually support non-backtracking parsing. In fact, afaict only one instance actually does support that (i.e. Parsec)
06:41:36 <c_wraith> Parsec doesn't drop an unknown quantity of tokens on the floor then continue, by the way - it just fails to match at all.
06:41:54 <c_wraith> ie, once it matches the first token in a branch, it commits to that branch.
06:41:55 <ExpHP> c_wraith: even better
06:42:15 <merijn> ExpHP: I'm not quite sure where you're going with the entire argument?
06:43:03 <ExpHP> merijn not a damn clue :).  I'm probably just trying to weasel out of having to write my own Conduit wrapper with an Alternative instance
06:43:05 <merijn> ParserConduit is a backtracking parser, so if you don't need/want a backtracking parser, then don't use it?
06:43:21 <nuskin> I'm trying to find is some function satisfies a given input over a range of inputs and return True if any are satisfied and False otherwise
06:43:26 <ExpHP> (though I guess I'd still have to write it even after arguing...)
06:43:47 <nuskin> I can think of how one would typically do this with a loop but on account of haskell not having any I'm quite stumped on how to proceed
06:43:58 <c_wraith> there was a release of attoparsec that *did* drop an unknown number of tokens on the floor then continue.  That version got marked as broken very rapidly.
06:44:07 <ExpHP> merijn: thanks
06:44:19 <nuskin> I have a lists of lists where each list contained is the function input
06:44:37 <merijn> ExpHP: I suspect there's probably several other conduit parsers around somewhere, one of them might not backtrack
06:46:22 <ExpHP> the tricky part is finding one with support for arbitrary input types (not just Text/ByteString). conduit-parse seems unique in this regard
06:46:38 <ExpHP> I'm dealing with an Event stream from Libyaml
06:47:24 <c_wraith> There must be an integration between megaparsec and conduit somewhere.
06:47:34 <merijn> ExpHP: Well, if you only need a lookahead of 1 you could just write a loop that fetches 1 element, inspects it, branch based on that, continue?
06:48:17 <ExpHP> of course, I'm just currently busy being a whiny lazy bastard
06:48:40 <ExpHP> ...I should go implement that. >_>
06:56:51 <ExpHP> stack new conduit-ll1  #  >:D
06:58:13 <ij> A javascript irc bot is eating less(25M) than my haskell bot(50M). Why could this be? ldd shows its been compiled dnyamically.
06:59:03 <ExpHP> ij try throwing unicode at it
06:59:30 <dysfun> or you could have a space leak. they're fairly common
07:00:18 <ij> I could try restarting it and see if the usage changes.
07:01:43 <ij> Dropped to 19M, could be a space leak.
07:02:28 <ph88_> how do i go from a conduit stream of Double to an unboxed vector ?
07:04:44 <cocreature> ph88_: convert it to a list and then use fromList?
07:08:43 <dysfun> hrm, vector is O(n) to snoc :/ what do we have that's cheaper?
07:09:07 <Axman6> https://hackage.haskell.org/package/vector-conduit-0.5.0.0/docs/Data-Conduit-Vector.html might be useful
07:09:30 <Aruro> would u name ease of refactoring as haskell's strongest side?
07:09:32 <ExpHP> Is that really O(n) all the time, and not just O(n) armortized?
07:09:48 <dysfun> i don't know. it just says O(n)
07:09:57 <Axman6> (requires sepcifying the size of the vector up front, but this would probablt reduce the overhead you'd get with repeated snocs)
07:10:34 <Axman6> ExpHP: it's O(n) always, it must do a full copy in pretty much all situations (unless it fuses which repeated snocs probably won't)
07:10:37 <dysfun> i don't know how big it's supposed to be
07:10:42 <pgiarrusso> ExpHP: O(n) amortized would also be worseómaybe you're thinking of O(n) worst-case, O(1) amortized
07:11:03 <ExpHP> pgiarrusso: ah, lol, you're right :)
07:11:15 <byorgey> dysfun: Data.Sequence gives you O(1) cons and snoc
07:11:33 <dysfun> does it have cheap slices too?
07:11:48 <pgiarrusso> byorgey: that's implemented with finger trees right?
07:11:51 <byorgey> pgiarrusso: yes
07:12:10 <Axman6> dysfun: it has O(log n) slicing IIRC
07:12:35 <pgiarrusso> Axman6: yes
07:13:39 <dysfun> aha, i can do it with viewl and viewr
07:13:45 <dysfun> perfect, thanks!
07:15:16 <pgiarrusso> Aruro: many do
07:15:21 <ph88_> cocreature, how do i go from a conduit to a list? i think it involves this package https://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit-List.html but i don't see a function that gives a list
07:15:50 <cocreature> ph88_: sourceToList should work
07:16:41 <dysfun> huh, so Seq uses fingertrees, but doesn't actually expose them?
07:16:59 <dysfun> i'm a bit surprised there isn't a fingertree implementation in containers if that's the case
07:17:06 * dysfun normally uses 'fingertrees'
07:19:26 <Aruro> pgiarrusso: seems much better selling point than "purity" 
07:20:23 <ph88_> thank you cocreature 
07:20:30 <dysfun> purity perhaps requires experience using it to appreciate
07:20:49 <pgiarrusso> Well, "ease of refactoring" is a consequence of purity
07:21:18 <dysfun> i have recently been working on a research project in haskell, so things being torn up a lot. i felt confident i caught everything when refactoring. that's not the usual experience in other languages i've had
07:22:06 <pgiarrusso> Aruro: see e.g. http://neilmitchell.blogspot.it/2015/02/refactoring-with-equational-reasoning.html https://www.fpcomplete.com/blog/2016/12/software-project-maintenance-is-where-haskell-shines
07:22:31 <quchen> dysfun: Sequences use finger trees internally.
07:22:35 <dysfun> yes and no. as someone who writes a lot of clojure (which emphasis immutableness, if not purity), the type system was the biggest thing for helping refactoring to me
07:22:47 <pgiarrusso> But I would not actually discuss too much on "what's the strongest advantage" since that's subjectively
07:22:52 <quchen> dysfun: The same way as Map uses binary trees internally.
07:23:03 <dysfun> but we have binary trees
07:23:12 <quchen> containers exposes no binary trees.
07:23:21 <dysfun> oh, again, not in containers :/
07:23:35 <quchen> It has rose trees.
07:23:46 <quchen> Not sure why though, it doesn‚Äôt really fit.
07:24:07 <c_wraith> I'd rather go to cofree for rose trees anyway..
07:24:56 <pgiarrusso> dysfun: you can use Data.Sequence.Internal if you want to expose how Seq is implemented...
07:25:02 <c_wraith> though..  that monad instance is wacky.  Best to pretend it doesn't exist. :)
07:25:10 <c_wraith> It's valid! Just wacky.
07:25:15 <dysfun> "wacky"?
07:25:55 <c_wraith> You won't ever guess what it does.
07:26:01 <dysfun> heh
07:26:08 <quchen> My threshold for wackiness is the list monad
07:26:19 <ph88_> cocreature, ghci infered the following type for me, but i don't understand why it infered the constraint. streamToVector :: VU.Unbox [Double] => Source [] Double -> VU.Vector [Double]  streamToVector stream = VU.fromList $ sourceToList stream
07:27:13 <cocreature> ph88_: dou probably want fmap VU.fromList (sourceToList stream)
07:27:17 <c_wraith> https://hackage.haskell.org/package/free-4.12.4/docs/src/Control-Comonad-Cofree.html#line-159
07:27:19 <cocreature> *you
07:27:40 <pgiarrusso> dysfun: FWIW, try refactoring code using exceptions to see the relation between purity and refactoringóthe type systems helps you only with effects tracked in types (of course), not with other ones :-)
07:27:55 <ph88_> thanks !
07:28:33 <quchen> c_wraith: Can you explain what it does? I think I understand the source but I can‚Äôt put it in a sentence.
07:29:20 <dysfun> pgiarrusso: i know from experience that purity does help with refactoring, but i naturally write 90% pure code in clojure anyway, so i guess it's just not as noticeable any more, compared to the type system, which very much is
07:29:29 <mirpa> Cabal "missing C library" is misleading error message. I had to run ghc itself in order to figure out that library itself isn't missing, but it needs additional symbols from other libraries.
07:30:37 <Aruro> pgiarrusso: ty
07:30:39 <pgiarrusso> mirpa: I'm guessing that happens because loading the library fails...
07:31:10 <pgiarrusso> mirpa: that sort of thing happens not just with Cabal... but I would still agree it's a bug
07:31:27 <Aruro> why most frequent (nonconflicting) ghc extensions are not on by default? speed?
07:31:42 <c_wraith> quchen: no.  I can't explain what it does.
07:31:47 <dysfun> if you set your default language to Haskell2010, you get a few
07:31:48 <quchen> GHC tries to be a compiler for exactly Haskell.
07:31:58 <quchen> Language extensions are not Haskell.
07:32:02 <Aruro> we know that useless now
07:32:11 <Aruro> nobody does exactly Haskell
07:32:17 <Aruro> so that is out of the picture :)
07:32:28 <quchen> No, that‚Äôs exactly the answer to your question.
07:32:46 <Aruro> well, 100 percent of haskell community has to type thousands of lines
07:33:05 <Aruro> everyday, because somebody is stuck in 2010
07:33:27 <pgiarrusso> Aruro: that's an oversimplification
07:33:36 <quchen> GHC does a fairly good job at being Haskell. I can‚Äôt recount all the deviations, but I think it‚Äôs not much more than AMP, FTP and Num superclasses. And some quirks with section semantics.
07:33:50 <Aruro> ok why not at least TURN ON EVERYTHING flag?
07:33:59 <dysfun> that would be a terrible idea
07:34:00 <ph88_> Aruro, when there will be a new language spec it will include some things that are now extensions ... so *work in progress*
07:34:01 <quchen> We had that, it was removed.
07:34:02 <c_wraith> Aruro: it exists.  People don't use it.
07:34:04 <quchen> -fglasgow-exts
07:34:05 <dysfun> you'd never understand the error messages
07:34:15 <pgiarrusso> Aruro: you can add extensions you like to your Cabal file
07:34:23 <c_wraith> Aruro: it's more useful to b e explicit.
07:34:36 <pgiarrusso> I can guarantee you that you don't want *all* extensions
07:34:43 <Axman6> oh man, I'd forgotten about the days of -fglasgow-exts. you've brought on a strange feeling of nostalgia quchen
07:34:58 <pgiarrusso> even some of the most sensible ones have downsides
07:35:07 <quchen> Axman6: f (n+1) = n * f n -- here, have some more
07:35:15 <dysfun> i wasn't convinced for the longest time that OverloadedStrings was a bad default. then i changed my name
07:35:20 <Axman6> I never really liked n+k
07:35:21 <dysfun> s/name/mind/
07:35:32 <quchen> Booo
07:35:43 <cocreature> Axman6: heretic!
07:35:43 <pgiarrusso> dysfun: because of the extra constraints?
07:35:59 <dysfun> because the error messages when it fails aren't helpful to beginners
07:36:01 <Aruro> yeah overloaded is good example, they are everywhere
07:36:26 <Axman6> it's a lovely thing to have if you're writing proofs, but it doesn't exactly bring a huge amount of benefit
07:36:26 <quchen> There should be a pragma that un-overloads strings to all be Text.
07:36:35 <dysfun> +1
07:36:40 <cocreature> quchen: yeah I‚Äôve thought about making a proposal for that
07:36:42 <cocreature> but I‚Äôm lazy
07:36:52 <c_wraith> OverloadedStrings also makes a lot of things fail that wouldn't otherwise.  IE, turning it on breaks valid Haskell programs.
07:36:55 <Axman6> -XOnlyTextStrings
07:36:57 <quchen>  cocreature `seq` ()
07:36:59 <quchen> There you go
07:37:10 <Axman6> ()
07:37:11 <c_wraith> That sort of thing is why it's awkward to turn on all extensions
07:37:15 <cocreature> quchen: I‚Äôm not sure if whnf is sufficient
07:37:28 <cocreature> Axman6: you probably want the type it defaults to to be configurable
07:37:38 <quchen> cocreature: We‚Äôll talk about this once you send me a link to the proposal
07:37:42 <cocreature> and that would lead you down a rabbit hole of parametrized extensions or something like this
07:37:47 <glguy> putting Text in the default declaration can help if extended defaulting is used
07:38:13 <pgiarrusso> could you use the existing defaulting mechanism for this?
07:38:28 <Axman6> actually, I would love an extension which allowed you to write T"foo" as a Text string, B"foo" for bytestring, etc
07:38:36 <Axman6> does C++ have that these days?
07:38:49 <quchen> Yes. Proof: C++ has everything.
07:39:08 <quchen> (Okay I have no idea)
07:39:15 <pgiarrusso> Yes. Proof: C++ has this specific thing and people extend it with C++ macros
07:39:31 <cocreature> quchen: the only things missing are a sane syntax and sane semantics
07:39:39 <Axman6> http://en.cppreference.com/w/cpp/language/user_literal
07:39:44 <Jinxit> you can do it as "foo"_postfix
07:39:54 <Jinxit> and the _ is required
07:39:56 <glguy> Axman6: you can write t :: Text -> Text; t = id
07:40:11 <Axman6> I believe I've done that many times in the past :(
07:40:34 <quchen> show t "hello world" -- glguy :-(
07:41:07 <glguy> yeah, it's still going to need some () or$ of course
07:41:13 <dysfun> actually it's quite cool. you can use it to get type safety for unit maths
07:41:19 <Axman6> I was going to say that using ::Text isn't much more typing, but it also needs brackets most of the time
07:41:33 <tsani> id @Text ;)
07:41:50 <tsani> Really still not very good though.
07:41:55 <Axman6> :t "Foo"@Text
07:41:57 <lambdabot> error: parse error on input ‚Äò@‚Äô
07:41:57 <quchen> LANGUAGE OverloadedStrings Text  ‚Üê  parameterized pragma would be cool, but that would be something entirely new
07:42:00 <tsani> yeah :(
07:42:01 <Axman6> :t "Foo" @Text
07:42:03 <lambdabot> error: parse error on input ‚Äò@‚Äô
07:42:09 <Axman6> :(
07:42:09 <tsani> I wish literals could have type applications
07:42:11 <pgiarrusso> quchen: what about `default (Text.String)`
07:42:24 <pgiarrusso> that's already allowed by the language it seems
07:42:33 <pgiarrusso> > Haskell's defaulting mechanism is extended to cover string literals, when -XOverloadedStrings is specified.
07:42:35 <lambdabot>  <hint>:1:68: error: parse error on input ‚Äò,‚Äô
07:42:52 <cocreature> pgiarrusso: that‚Äôs not -Wall clean
07:42:53 <quchen> pgiarrusso: I think defaults can‚Äôt be orphans ..?
07:43:16 <glguy> defaults are per module
07:43:26 <glguy> nothing to do with orphans
07:43:27 <Axman6> jesus, reading that user defined literal stuff for C++, I am reminded just how insane C++ is. it's like people like making corner cases for the spec just so they can feel superior for knowing obscure facts about the spec >_<
07:43:28 <pgiarrusso> (source: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-string-literals)
07:43:58 <quchen> I think nomeata proposed something like the un-specialization you mentioned, cocreature, now that I think of it. He used it for lists though if I recall correctly
07:44:38 <pgiarrusso> cocreature, glguy: OK, but do you want a *different* semantics for your extension?
07:44:48 <Aruro> cabal has haskell 2010 and 25 language extensions, i can see now why haskell 2010 is important 
07:45:42 <pgiarrusso> Aruro: half of those extensions either complicate the language *or* break working code *or* break guarantees *or* have other downsides
07:46:03 <pgiarrusso> Aruro: it's not like people haven't tried to extend the standard
07:46:04 <quchen> Or we don‚Äôt understand them (or their interaction, rather)
07:46:40 <Aruro> base is using 38 language extensions, i am Haskell2010 adept now
07:46:42 <pgiarrusso> I heard even standardizing MultiParamTypeClasses was too controversial, forget why
07:47:13 <Aruro> pgiarrusso: point is nobody write Haskell2010
07:47:22 <Aruro> so no guarantees anycase
07:47:29 <glguy> pgiarrusso: I haven't proposed a new extension
07:47:42 <pgiarrusso> glguy: ah, cocreature wanted to
07:47:45 <quchen> I write Haskell 2010 for the most part.
07:48:09 <glguy> Aruro: no, that's not true. many try to stick to Haskell 2010
07:48:16 <Axman6> what did 2010 add again?
07:48:25 <pgiarrusso> Aruro: you're welcome to volunteer help to standardize MultiParamTypeClasses: https://prime.haskell.org/wiki/MultiParamTypeClassesDilemma
07:48:27 <quchen> FFI, pattern guards
07:48:52 <rasrajat> i know object oriented concepts and java programming how or from where can i start data Science??
07:49:18 <quchen> ?quote elliott H2010
07:49:18 <lambdabot> elliott says: An interesting exercise is to try and imagine a language revision more conservative than H2010.
07:49:21 <Axman6> rasrajat: do you want to use Haskell?
07:50:42 <ph88_> what do i need to put these two streaming functions together?  https://bpaste.net/show/fe33f4017ef3  i think at least the bind function, but also i need to deal with the state and probably give it the default state, should i use runState too ?
07:53:14 <Aruro> glguy: is it worth to stick to Haskell 2010?
07:53:49 <ph88_> Aruro, better use some extensions
07:53:56 * shapr hops excitedly
07:54:01 <ph88_> lol
07:54:08 <ph88_> what's up shapr 
07:54:20 <shapr> I've mostly figured out how to get clash-lang to go from Haskell to an ice40 FPGA!
07:54:28 <ph88_> sweet !
07:54:55 <shapr> ph88_: I spent a few hours this weekend figuring out how to install clash-lang from stack, and install yosys, icestorm, and arachne-pnr to get code loaded onto my ice40-hx8k breakout board!
07:55:38 <ph88_> shapr, can you make a blog post about that ?
07:55:49 <Axman6> Aruro: it's not something I've ever had to think about, and I've been writing Haskell for about 9 years
07:56:14 <Axman6> shapr: nice!
07:56:23 * Axman6 seconds the blog post request
07:56:26 <glguy> it's worth it to make the code as simple as you can
07:56:38 <glguy> easier to get right and understand
07:57:24 <glguy> sometimes extensions pay for themselves, but it's not a given
07:57:34 <shapr> ph88_: yeah, once I get the last clash-lang problem solved, I'll put up a blog post on the haskell-embedded site
07:57:43 <Aruro> well, base is using extensions, how to write clean HAskell2010
07:58:10 <Axman6> why not use extensions?
07:58:36 <Aruro> Axman6: people here tried to argue Haskell2010 does exist
07:59:21 <Axman6> It was such a minor change that I guess it's just seen as the natural progression of the language
07:59:30 <Axman6> no one thinks about it
08:00:04 <Axman6> it's just https://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
08:00:16 <pgiarrusso> Aruro: see https://mail.haskell.org/pipermail/haskell-prime/2006-February/000289.html for example downsides of extensions
08:00:27 <Axman6> (wow, we didn't have heirarchical module names before then? 
08:01:01 <pgiarrusso> people require extremely high quality (essentially perfection) before standardizing an extension
08:01:56 <Aruro> pgiarrusso: does it matter? code started to live its own life, people do use all of that mentioned in the email
08:02:01 <pgiarrusso> > I have another worry about MPTCs [...] The result is that missing instances get reported later than they do now.
08:02:05 <lambdabot>  <hint>:1:38: error: parse error on input ‚Äò]‚Äô
08:02:24 <pgiarrusso> Aruro: well, I don't use just Haskell 2010
08:02:39 <pgiarrusso> Aruro: you're the one complaining that more extensions aren't standardized
08:02:59 <Aruro> im complaining that they are not on by default
08:03:03 <Aruro> and i have to type
08:03:14 <Aruro> at least most major ones
08:03:32 <Aruro> and everybody types
08:03:53 <pgiarrusso> there's copy-paste, Cabal files, and even editor support for adding them if you use intero
08:04:28 <pgiarrusso> complaining in this channel won't change the "Haskell2010 by default" policy
08:04:35 <Aruro> who knows
08:05:36 <pgiarrusso> Well, who knows what happens if I drop an apple? We can make educated guesses on both, with similar confidence :-)
08:05:55 <Aruro> pgiarrusso: come on, a lot of people read this channel
08:06:19 <pgiarrusso> I'd be less certain on a mailing list thread
08:06:47 <pgiarrusso> but there are reasons for the status quo
08:06:52 <Aruro> maybe spj does not read, but some of his coauthors certainly do read 
08:07:04 <pgiarrusso> you can use `-fglasgow-exts` for now
08:07:15 <Aruro> pgiarrusso: ty
08:07:22 <pgiarrusso> as people mentioned
08:08:42 <pgiarrusso> Aruro: well, the topic has been debated to death and some tradeoff has settled, that's the thing.
08:09:14 <Aruro> i understand, just saying that those debates lose meaning when de facto there is no haskell2010
08:09:23 <Aruro> in real life
08:12:34 <sproingie> silly question: what's the difference between -XGADTSyntax and -XGADTs?
08:14:08 <Aruro> one enables GADTS another just syntax
08:14:21 <Aruro> which can be used in data declarations
08:15:12 <Aruro> sproingie: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#generalised-algebraic-data-types-gadts
08:17:03 <sproingie> "Notice that the return type of the constructors is not always Term a, as is the case with ordinary data types."
08:17:10 <sproingie> i take it that's the crucial distinction?
08:17:54 <sproingie> guess i could just switch the flags on some existing code and see
08:17:55 <dolio> GADTSyntax lets you write things in the 'data Foo where' style. GADTs lets you write actual GADTs.
08:18:15 <orion> dolio: What is an "actual" GADT?
08:18:41 <orion> i.e. how is an actual GADT distinct from writing "data Foo where..."?
08:18:54 <sproingie> i assumed GADTs were mostly (very nice) syntax sugar for existentials
08:19:54 <nshepper1> orion: Something where the return type of the constructor is not just Foo a, or with an equality constraint
08:20:12 <pgiarrusso> nshepper1: yes
08:22:48 <dolio> orion: It's a data type that you wouldn't be able to write using normal data syntax (without using features that GADTs enables). :P
08:23:32 <dolio> And also not merely an existential type, I guess, because support for that predates GADTs.
08:23:50 <dolio> ls
08:24:01 <dolio> Whoops.
08:25:11 <orion> dolio: But GADTSyntax isn't normal data syntax.
08:25:47 <geekosaur> the description on that web page seems pretty clear to me
08:26:44 <geekosaur> orion, data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a -- is GADT syntax but a normal ADT (all constructors have the same result type)
08:27:24 <sproingie> it was the differing result type that i missed
08:27:40 <orion> Oh, I see now.
08:27:43 <geekosaur> and is identical in effect to the ADT syntax (but may be easier to understand)
08:28:13 <geekosaur> so, with actual GADTs, (a) the different constructors can have different types (b) those types come into scope when the constructor is pattern matched
08:28:27 <geekosaur> you can get (a) with an existential; GADTs add (b)
08:28:37 <geekosaur> and you can't get that any other way
08:28:51 <dolio> Eh?
08:28:53 <ski> (with an ordinary algebraic data type, the return type of each data constructor must be the type constructor being defined, applied to zero or more *distinct* type variables, and also the types of the data constructors must have no constraints)
08:29:04 <dolio> The things that GADTs add over existentials is equality constraints.
08:29:38 <ski> (oh, and all (free) type variables in the argument types of the data constructors must occur also in the result type)
08:29:55 <dolio> Having non-uniform result types is the extra power of GADTs (which is equivalent to taking an equality argument).
08:30:52 <ski> (.. so it's not so much about "can have different types", but that it can differ from the format of tycon applied to distinct tyvars)
08:31:08 <dolio> Yeah.
08:35:37 <orion> When you write "data Foo a = ..." is there an implicit (forall a.) added for every constructor?
08:36:37 <geekosaur> yes
08:36:42 <dolio> Yeah, the result of every constructor is `Foo a`.
08:40:47 <ph88_> i have little clue about how to use these functions together  https://bpaste.net/show/fe33f4017ef3  i think i need at least bind and runState but i don't know in which order to apply them ..
08:41:31 <sproingie> with the evaluator example in the docs, i was able to get away with defining Term using just GADTSyntax and ExistentialQuantification
08:41:40 <sproingie> pattern matching however demanded full blown GADTs
08:42:35 <sproingie> i must say, seeing 'where' and specific types looks a lot more "existential" than the previous existential syntax
08:43:36 <orion> Does anyone know of any other uses of GADTs that aren't the canonical evaluator example?
08:43:49 <ExpHP_> Boo yeah! Here's the memory profile of my new O(1)-memory-overhead streaming Yaml parser: https://goo.gl/5wHnz6
08:44:04 <sproingie> it's a pretty good example imho.  beats Foo and Bar
08:44:25 <ph88_> ExpHP, what do we have to compare it to ?
08:45:00 * ExpHP starts furiously pressing up in his IRC client...
08:45:14 <sproingie> lot of complex datatypes are isomorphic to some evaluator anyway.  i pulled that trick in lisp all the time.
08:45:18 <Sh4rPEYE> I want to have something like homebrew for hackage, so I can have the latest version of libraries and tools (hlint comes to mind). I don't build big projects, rather just individual files, so stack (I guess) doesn't really fit my needs. Is there something else?
08:45:29 <sproingie> Sh4rPEYE: that'd be stack
08:45:33 <ph88_> by the way ... how big is that yaml file that it needs 3 seconds to process
08:45:39 <ExpHP> ph88_: here: https://goo.gl/tLdaJy is the overhead of fromJSON :: Parser Value
08:45:50 <ExpHP> for a 4MB yaml file
08:46:02 <ph88_> attoparsec ?
08:46:08 <sproingie> stack is perfectly good for individual files too
08:46:48 <ExpHP> old one is yaml (aeson interface), new one is yaml (Libyaml interface) + conduit
08:46:50 <sproingie> tho in that case you're using it mostly like RVM
08:46:50 <ph88_> ExpHP, did you use those code annotations ? i don't remember what they are called .. but to define names in the memory profiling
08:47:21 <ph88_> ah you use ffi ?
08:47:33 <ExpHP> ph88_ I just throw a bunch of flags at GHC https://github.com/ExpHP/haskell-memory-halp/blob/master/makeit
08:47:34 <Sh4rPEYE> sproingie: It might be, I'm just a beginner. I though you have to use stack new/build and then it downloads specified libraries used by your project...
08:48:05 <ExpHP> ph88_ no ffi.  (though I'm sure Text.Libyaml uses ffi under the hood)
08:48:05 <sproingie> Sh4rPEYE: put "#!/usr/bin/env stack" at the top of your file, then "-- stack runghc --package foo" as the second line (substituting foo for whatever package you're pulling in)
08:48:12 <glguy> orion: I don't know if this is different enough for you, but here's an example https://github.com/glguy/irc-core/blob/v2/src/Client/Commands/Arguments.hs#L24-L36
08:48:22 <sproingie> make it executable and pow, single file script that fetches all deps
08:48:59 <ph88_> ExpHP, seems you use a lot less memory but it's twice as slow
08:49:04 <Sh4rPEYE> sproingie: Thanks
08:49:35 <sproingie> Haskell is the best scripting language :)
08:49:39 <Sh4rPEYE> And if I want to have something like hlint always up-to-date systemwide?
08:50:21 <sproingie> with stack there isn't so much a "systemwide" to think of anymore, though it does cache all the things
08:50:26 <ExpHP> uh... well crud.  
08:50:51 <ExpHP> (though I think having a slow thing that runs is better than a fast thing that crashes)
08:51:08 <ph88_> aeson crashes ?
08:51:18 <ExpHP> out of memory errors
08:51:22 <ph88_> oh
08:51:25 <ph88_> buy more memory :P
08:51:39 <sproingie> Sh4rPEYE: though when you install a lot of deps with the default resolver, that version will end up accruing a lot of packages.  you'll always have the latest curated stackage version though.
08:51:46 <ExpHP> I try to parse a 2GB file and it balloons to like 16GB RAM
08:51:48 <Sh4rPEYE> sproingie: That's the problem I had with it initially. So what would be the way there? 
08:51:55 <sproingie> which isn't necessarily the bleeding edge version, but it's the one known to work
08:52:05 <ph88_> wow 2GB of yaml ? 
08:52:18 <ExpHP> ph88_: blame the physicists
08:52:19 <ph88_> maybe yaml is the wrong format for that in the first place
08:52:22 <ph88_> lol
08:52:23 <ph88_> ok
08:52:31 <ph88_> ok they can wait longer :P
08:52:39 <sproingie> if you need specific versions, you may have to use different options in the stack comment.  i'm not sure how, at that point it might be better to just start a stack project
08:52:58 <ph88_> ExpHP, ask them to export something that you can load directly into memory with mmap :P
08:53:07 <ph88_> ExpHP, then you don't need to parse it :D
08:53:08 <orion> glguy: Thanks.
08:53:12 <Sh4rPEYE> Well, I use hlint in VSCode, so the "systemwide" thing might be better
08:53:20 <ph88_> ExpHP, what do you do after parsing ?
08:53:52 <ph88_> ExpHP, by the way .. could you take a look at my conduit question ? since you are using conduit yourself maybe you have an idea
08:54:03 <ExpHP> ph88_ I *cough* I write the vectors back out to binary files so I can read them faster later...
08:54:12 <ph88_> lol
08:54:17 <ExpHP> ph88_ then I do many many many dot products
08:54:21 <stelleg_web> anyone know how to access opaque constants in c2hs?
08:54:27 <glguy> orion: for context the 'ArgumentSpec' is used here where it's index is matched with an implementation. https://github.com/glguy/irc-core/blob/v2/src/Client/Commands.hs#L106-L115
08:54:41 <ExpHP> ph88_ possibly but I am also a complete noob at conduit :)
08:54:47 <ph88_> hi fellow noob !
08:54:48 <ExpHP> this will be the blind leading the blind
08:54:57 <ph88_> i have these two functions https://bpaste.net/show/fe33f4017ef3
08:55:04 <ph88_> no clue how to put them together
08:55:14 <ph88_> obviously not in the way on line 4
08:55:20 <ph88_> something with bind and runState i assume
08:56:11 <sproingie> IDE support stuff like hlint, might just install that globally if your IDE isn't otherwise stack-aware
08:56:45 <sproingie> (intelliJ's stuff is stack-aware, dunno about VS)
08:58:28 <sproingie> global install would of course be cabal-install 
08:58:30 <ExpHP> ph88_ it looks like at the very least something needs to be made "impure".  The StateT in the error message has Identity as its base so it can't support IO
08:58:40 <sproingie> tho hlint probably has standalone builds too
09:00:24 <ExpHP> ph88_ in fact I'm not sure conduits with differnent base monads can be composed easily at all
09:00:28 <Sh4rPEYE> sproingie: I'll cabal-install that and use your method for the scripts.
09:00:47 <ph88_> ExpHP, ok ok thanks for trying :P
09:00:53 <ph88_> i also don't know
09:02:06 <eiriksfa> anyone here who can help me a bit? trying to learn haskell by 'converting' some of my old oo code, and I end up in a loop that I can't seem to solve (code: https://pastebin.com/0v9pUh0N, a bit messy, only the parts I consider relevant are added, can put up the rest if needed)
09:02:51 <ph88_> i need to find the smallest Double, so i like to start of with the biggest Double to compare to, how do i get the biggest Double in haskell ?
09:03:20 <ExpHP> ph88_ 1/0?
09:03:46 <ExpHP> > 1/0 :: Double
09:03:47 <prophile> ph88_: it's kind of disgusting, but I've done it as `read "Infinity" :: Double` before
09:03:47 <lambdabot>  Infinity
09:04:02 <ExpHP> > Infinity
09:04:03 <ph88_> then i saw this comment and started to doubt  https://stackoverflow.com/questions/2354707/in-haskell-is-there-infinity-num-a-a#comment2332197_2354766
09:04:04 <lambdabot>  error:
09:04:04 <lambdabot>      ‚Ä¢ Data constructor not in scope: Infinity
09:04:04 <lambdabot>      ‚Ä¢ Perhaps you meant variable ‚Äòinfinity‚Äô (imported from Data.Number.Natural)
09:04:19 <ph88_> > encodeFloat (floatRadix 0 - 1) (snd $ floatRange 0)
09:04:21 <lambdabot>  Infinity
09:05:14 <ertes> err‚Ä¶
09:05:16 <ertes> https://www.haskell.org/onlinereport/haskell2010/
09:05:35 <ph88_> o/ ertes 
09:05:37 <ertes> at the top it says "Copyright notice."
09:05:54 <ertes> i assume that's unintentional
09:08:30 <sproingie> eiriksfa: you could move a lot of those guards to pattern matches in multiple definitions
09:09:05 <glguy> ertes: I think that that is intended to be read as the header for the following paragraph.
09:09:48 <sproingie> the isNothing checks for instance.  usually when you have a Maybe, you want to fmap over it, not check what it is
09:12:21 <sproingie> also, if you find yourself doing a lot of \a -> (a, morestuff), then you have other functions that extract that a, you can get much cleaner looking code with do-notation in some monad
09:12:43 <sproingie> but if you're not at that point, don't worry about it :)
09:14:53 <eiriksfa> any tips are appreciated, so thanks :)
09:15:28 <eiriksfa> wrote them up, will look at them in order
09:16:06 <eiriksfa> but the issue of the code looping, is that a result of using 'Maybe' wrong?
09:18:02 <sproingie> hard to say without knowing where it's looping.  infinite loops would be from either trying to consume infinite input, or forgetting a base case
09:18:56 <ph88_> I want to pipe a   ConduitM BSC.ByteString Double IO ()   into a   Conduit Double (State StreamState) Double   but i don't know how to go from a ConduitM to a Conduit, anyone know ?
09:22:30 <cocreature> ph88_: Conduit is just a type synonym
09:22:41 <cocreature> and the only restriction is that the last argument of ConduitM is ()
09:22:51 <cocreature> so in your case there is nothing to do
09:22:53 <ertes> glguy: oh yeah, makes sense
09:56:23 <ExpHP> think fast: using a function which is almost 90% guaranteed to already be in the dependency graph of any arbitrary haskell file...
09:56:31 <ExpHP> parse a float with possible failure
09:56:41 <ExpHP> (e.g. String -> Maybe Double)
09:57:35 <ExpHP> 0 points to whoever says fmap fst . find ((""==). snd) . reads because I'm currently doing that and it's extremely dumb
09:59:01 <ski> > (\s0 -> listToMaybe [x | (x,s) <- (reads :: ReadS Double) s0,("","") <- lex s]) "12.3 "
09:59:03 <lambdabot>  Just 12.3
10:00:26 <ExpHP> 0 points
10:00:43 * ski nods
10:02:22 <ReinH> At least readMaybe is in base
10:02:47 <ExpHP> :t readMaybe
10:02:48 <lambdabot> error: Variable not in scope: readMaybe
10:03:01 <ReinH> (but not in Prelude)
10:03:22 <monochrom> Text.Read
10:03:54 <monochrom> @type fmap fst . find ((""==). snd) . reads
10:03:56 <lambdabot> Read b => String -> Maybe b
10:04:52 <ExpHP> @source readMaybe
10:04:53 <lambdabot> Unknown command, try @list
10:05:33 <ExpHP> @src readMaybe
10:05:33 <lambdabot> readMaybe s = case readEither s of
10:05:33 <lambdabot>                 Left _  -> Nothing
10:05:33 <lambdabot>                 Right a -> Just a
10:05:41 <ExpHP> >_>
10:05:45 <ExpHP> @src readEither
10:05:46 <lambdabot> -- The old-style Read definition. The real one uses readPrec instead.
10:05:46 <lambdabot> readEither s =
10:05:46 <lambdabot>   let s' = dropWhile isSpace s
10:05:46 <lambdabot>   in  case [x | (x, rest) <- reads s', all isSpace rest] of
10:05:46 <lambdabot>         [x] -> Right x
10:05:48 <lambdabot>         []  -> Left "Prelude.read: no parse"
10:05:50 <lambdabot>         _   -> Left "Prelude.read: ambiguous parse"
10:06:12 <ExpHP> >_< why
10:06:24 <monochrom> What's wrong?
10:06:28 <ExpHP> how on earth is 'reads' the foundation of all fallible reading?
10:06:40 <ExpHP> (in base)
10:06:40 <monochrom> Haha
10:07:31 <monochrom> It was thought that it would be nice to accomodate ambiguous grammars so the result should be an arbitrary-length list rather than nailing to 0-or-1.
10:07:31 <ExpHP> @djinn ByteString -> Double
10:07:31 <lambdabot> Error: Undefined type ByteString
10:07:39 <ExpHP> @djinn String -> Double
10:07:39 <lambdabot> Error: Undefined type String
10:07:48 <ExpHP> @djinn [Char] -> Double
10:07:48 <lambdabot> Error: Undefined type []
10:07:54 <monochrom> Sure, 20 years later, we have found that no one actually uses the flexibility.
10:10:33 <ski> > do b <- (do Just False `mplus` do Just True); guard b
10:10:35 <lambdabot>  Nothing
10:10:37 <ski> > (do b <- Just False; guard b) `mplus` (do b <- Just True; guard b)
10:10:39 <lambdabot>  Just ()
10:10:48 <ski> > do b <- (do [False] `mplus` do [True]); guard b
10:10:50 <lambdabot>  [()]
10:10:53 <ski> > (do b <- [False]; guard b) `mplus` (do b <- [True]; guard b)
10:10:55 <lambdabot>  [()]
10:14:21 <qmm> what does the convention where an underscore is the last character in a variable name represent? e.g. let foo_ = ...
10:14:45 <ph88_> cocreature, could you give me a hint where i'm suppose to eval the state?  i'm trying this  (a :: ConduitM BSC.ByteString Double IO ()) .| (evalState (b :: Conduit Double (State StreamState) Double) startStreamState)   but i think that does everything inside out (i get a type error here)
10:15:11 <ph88_> i think i'm first suppose to "unpack" the conduit before i eval the state
10:16:40 <ph88_> getting confused here
10:20:04 <ph88_> i see an example here with conduit and state https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview#lifting-operations  but the first chain all conduits together before calling runState on it ... but when i chain all conduits together first it all goes wrong
10:21:03 <ph88_> they do    result = source $$ conduit =$ CL.consume    runState result 5     i do  a .| b   and it goes wrong there already before i even have the chance to call evalState on the result of   a .| b
10:22:49 <ph88_> maybe i need to fmap state over a first ?
10:23:38 <ph88_> fmap (x :: a -> State a) (y :: ConduitM BSC.ByteString Double IO ())
10:23:52 <ph88_> (i renamed a to y here)
10:24:52 * mivael is trying to understand what exactly is "sequential" about the sequential application operator...
10:25:07 <ph88_> hmmm state should just be return when i'm in the state monad
10:25:10 <mivael> Why <*> is sequential application, whereas ($) is just "application"?
10:25:25 <mivael> Are there hints how to build an intuition about Applicative in a right way?
10:25:38 <mivael> I seem to understand mechanics of 'pure' and '<*> but I'm confused with this "sequential" thing about applicative functors.
10:26:06 <ski> very roughly one could say that `Applicative' is about "static sequencing"
10:26:49 <johnw> mivael: (<*>) can also be written liftA2 ($), if that helps
10:27:02 <Gurkenglas> mivael, "f <*> x :: State s b" will use the initial state to compute f and the resulting state to compute x
10:27:09 <ExpHP> mivael: Try writing a parser in attoparsec and it will become quite clear :)
10:27:13 <c_wraith> mivael, consider the case when both arguments to <*> are IO actions. they must happen in some order. that is the sequential it's talking about. 
10:27:16 <ph88_> mivael, as i see it when you do      add 2 $ 2 `add` 3   can still add 2 + 2   before adding 4 + 3   
10:29:23 <ph88_> mivael, and how i see <*> is that it's a function to apply a function to a value inside a container. But if you have a containered type like   a :: Maybe Foo Bar Bla Int  then there is an order to which you must unwrap the stuff to get your Int ... so you have to use a lot of <$> there, but they will go in the sequence of first Maybe then Bar .. and so on
10:32:16 <ski> mivael : with `fmap' (aka `(<$>)') you can "map over the contents" of a "container" (that's not always a very helpful analogy to think of it in terms of). but you can only map a "one-argument" function
10:32:18 <mivael> c_wraith, IO is a Monad, isn't it?  (not just Applicative)
10:32:57 <ExpHP> ph88_ are you familiar with the 'mtl' library or 'transformers'?
10:33:22 <ski> mivael : with `(<*>)'/`liftA2', you can "map multiple-argument function", or in other words, *combine* several "values-in-context" to a resulting "value-in-context" (that's also not necessarily a very enlightening analogy)
10:33:40 <ph88_> ExpHP, a little bit i think ... i vaguely remember including mtl in a project
10:34:10 <byorgey> mivael: yes
10:34:17 <ExpHP> ph88_ The main issue here is that the two conduits have a different base monad
10:34:21 <ExpHP> ph88_ you have
10:34:28 <ExpHP> ConduitM BSC.ByteString Double m ()
10:34:33 <ExpHP> ConduitM Double         Double m Double
10:34:44 <ExpHP> oops, copied the wrong things
10:34:55 <ExpHP> ConduitM BSC.ByteString Double IO                  ()
10:35:00 <ExpHP> ConduitM Double         Double (State StreamState) Double
10:35:08 <ExpHP> ^ that's what you have
10:35:44 <ski> mivael : when we combine several such "actions"/"containers"/"computations"/&c. the particular applicative functor we're using is *allowed* to depend on the *order* in which we combine them. thus `Applicative' *enables* (static) sequencing. this does not mean that every `Applicative' functor *actually* cares about the ordering, only that the interface `Applicative' *allows* it to depend on the "sequencing" ordering
10:35:45 <ExpHP> your first one can be generalized to (MonadIO m)=> ConduitM BSC.ByteString Double m ()  by putting liftIO in front
10:35:50 <ski> (which btw need, in general, have nothing to do with evaluation ordering)
10:36:13 <ph88_> mivael, no me Monad is Applicative (so wrapper-like stuff) with an extra dimension of values. The extra dimension it specific to the monad, for example if the Either monad fails it chooses to return the Left value i belief
10:36:13 <ExpHP> your second one can be generalized to (MonadState StreamState m)=> ConduitM Double Double m Double
10:37:09 <ExpHP> I think both of these signatures can be satisfied if your "core" is a StateT StreamState IO
10:37:23 <mivael> ski, Gurkenglas: in some sense, we do sequential computations without Applicative's, when composing functions:  (*4) . (+7) $ 2   and   (+7) . (*4) $ 2   ...  form me it looks like sequencing
10:37:27 <ph88_> ExpHP, how to converge them ?
10:37:46 <ExpHP> ph88_ I will throw up a paste with some ideas
10:38:11 <ski> mivael : this is all a bit abstract, and hard to grasp, i realize. actual concrete `Applicative' functors (sometimes known as "idioms") do very different things, but have in commonality the "static sequencing" part i'm attempting to get at here
10:38:33 <mivael> Gurkenglas, I would say that (+7) $ 2 is a statof computation for (*4) . (+7) $ 2
10:38:39 <ReinH> mivael: (<*>) :: Applicative f => f (a -> b) -> f a -> f b is "f'y application", where what it means to be application depends on what it means to be "f'y". For IO, that means application sequences IO effects. For Maybe, that means application with a notion of failure. For Identity, it's the same as ($)
10:38:46 <ph88_> mivael, applicative is about container structures (to me), sequencing values with $ does not involve container
10:38:47 <ski> mivael : true. that is sequencing in data-flow
10:39:06 <ReinH> You can't talk about what <*> means generally except in generalities.
10:39:26 <ski> mivael : both `Functor',`Applicative' and `Monad' are about "contexts" or "containers", as ph88_ says
10:40:46 <ski> mivael : in the `Maybe' case, the "context" means that either we get an answer (the "default" or "pure" case), or (deviation from default) we get no answer (we get `Nothing')
10:41:34 <ReinH> For ((->) r), it means argument sharing (S combinator), [] is choice, ZipList is pointwise, etc, etc. In every case, the meaning of <*> depends on the structure of f.
10:41:49 <ski> mivael : in the `[]' (list type constructor) case, the pure case is to get (exactly) one answer. the deviation (or effect) is the possibility of getting no answer (empty list) or more than one answer (list with at least two elements)
10:41:53 <ph88_> Functor and Applicative is about the same to me (because i don't know enough yet)
10:42:31 <ski> `[]' is about possibly getting many potential answer (or no answer), and then continue computation by *trying them all* ! in all combinations
10:43:16 <ski> > (+) <$> [100,200] <*> [3,4,5]
10:43:18 <lambdabot>  [103,104,105,203,204,205]
10:43:31 <ski> > do x <- [100,200]; y <- [3,4,5]; return (x + y)
10:43:33 <lambdabot>  [103,104,105,203,204,205]
10:43:44 <ski> > [x + y | x <- [100,200],y <- [3,4,5]]
10:43:46 <lambdabot>  [103,104,105,203,204,205]
10:43:47 <ReinH> What they have in common are the types and the applicative laws, and that's all
10:44:22 <ski> in this case, "sequencing" means roughly "nesting loops trying all combinations of possibilities"
10:44:59 <ReinH> Honestly, I wish we wouldn't talk about <*> as sequencing except in cases where it makes sense, i.e., not as a general way to describe <*>
10:45:14 <ph88_> by the way how come i haven't run into MonadPlus yet ?
10:45:32 <ski> well, it *enables* sequencing. a particular idiom might not care about the sequencing order
10:45:53 <ExpHP> ph88_ MonadPlus is just alternative with some (very tenuous) rules
10:46:03 <ph88_> maybe not sequence of execution but sequence of wrapping containers
10:46:07 <ski> just like a monoid *enables* the combination operation to be non-commutative, but some monoids are in fact commutative
10:46:11 <ExpHP> apparently most instances don't satisfy the "right zero" law
10:46:24 <ph88_> ah ok ^^
10:46:48 <ph88_> ExpHP, that monad of  StateT StreamState IO  sounded like a good idea
10:46:53 <ph88_> i mean the type makes sense to me
10:47:01 <ski> so the lack of a "commutative law" in the laws of `Applicative' means that it (in this sense) enables expressing sequencing
10:47:17 <mivael> ski, it seems I understood it!
10:47:42 <ReinH> If we want to be consistent, ($) has to be sequential application too, since it's isomorpohic to <*> of Identity
10:47:55 <ReinH> Which renders the term sequential meaningless as applied generally to <*>
10:47:59 <ski> i.e. the interface itself is related to being able to express sequencing. a particular instance of `Applicative' can well ignore this aspect of it, though
10:48:16 <ExpHP> ph88_ yeah but now that I'm trying to code up an example I'm not actually sure how to transform the IO conduit
10:48:25 <ski> (which leaves us then with a mere ability to express orderless "combination")
10:48:26 <markus_> was about to ask a question, but figured it out while writing.. #haskell -- also a rubber duck :)
10:48:26 <ReinH> if every type of application is sequential, what explanatory power does the word have?
10:48:34 <dolio> Identity is an example of a commutative Applicative.
10:48:46 <ExpHP> ph88_ since liftIO needs an IO to turn into something that isn't IO, and your IO is tucked away inside a conduit
10:49:09 <ExpHP> ph88_ however the state appears to be easy, because ConduitM implements MonadSTate when the core does
10:49:32 <mivael> While (+) is a symmetric operation, we can get different results depending on sequencing: (+) <$> [100,200] <*> [3,4,5] and (+) <$> [3,4,5] <*> [100,200] will result in different lists.  This is what the sequencing is all about here.  Right?
10:49:51 <ph88_> ExpHP, you can reach io with liftIO from ConduitM i think because it's a monad transformer (honestly i don't know what i'm talking about but i've read something like that)
10:49:56 <ReinH> I guess if you're willing to try hard enough, you can make sequencing mean whatever you need
10:50:14 <ph88_> ExpHP, liftIO is on this page  https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
10:50:14 <mivael> ReinH  :)
10:50:17 <lpaste> ExpHP pasted ‚Äúidea for ph88_‚Äù at http://lpaste.net/7954594931899629568
10:50:20 <ski> mivael : anyway, you may perhaps wonder why i keep saying "*static* sequencing". well, using the same terminology, i'd say that `Monad' expresses "*dynamic* sequencing". of course that term requires explanation as well, in order to grasp what is meant by it
10:50:45 <ski> mivael : well ..
10:51:22 <ReinH> mivael: I don't think we need to invoke "sequential" just to point out that something isn't commutative.
10:51:40 <ski> mivael : you get different results there because `[]' isn't "commutative" (meaning : cares about ordering). if we imagine that we could have used sets instead of lists, then we'd have gotten identical results, though
10:51:44 <ReinH> (+) is commutative, liftA2 (+) is not (necessarily).
10:52:18 <ReinH> that is to say, not all Applicatives are commutative
10:52:24 <ReinH> as dolio pointed out above
10:52:32 <ski> mivael : .. have you grasped the `Monoid' type class, yet ?
10:53:18 <ReinH> commutativity can be a handy way to represent sequencing though, as in e.g. trace monoids, so I suppose the connection isn't all that tenuous
10:53:30 <ph88_> ExpHP, wow you making your own monad now ?? o_O
10:53:55 <ExpHP> ph88_ actually the thing with MonadIO is that a lot of times it is used to "section off" parts of a monad.  e.g. to prevent the side-effects of one from leaking into another.  (this is because IO itself is kind of a blank slate to start with, and it is the input to liftIO)
10:54:00 <mivael> ski, acquianted with it, I'd say  :)
10:55:14 <ExpHP> ph88_ it isn't necessary for this small example but it can make it easier if you need to add more layers to the monad
10:55:26 <ph88_> ok
10:55:52 <ExpHP> I get the impression that it's generally a good idea to "hide" monad stacks when possible, since they don't always compose too well...
10:56:08 <ski> mivael : well, if we write `x <> y <> z', `x',`y',`z' all of some type `T', being an instance of `Monoid', then we have combined them in *sequence* into a new value of type `T'
10:56:22 <heath> i'm trying to recall a link and i'm not sure where i found it. the article was essentially a cheatsheet for common features between different languages: left/right function composition, left/right function application, etc.
10:56:41 <heath> i think it was comparing f#, haskell, elm, and purescript
10:57:25 <ski> mivael : in `Sum 2 <> Sum 1 <> Sum 3', this given sequence of three values is actually immaterial, you'd get the same result (`Sum 6') with any other ordering of the three values (let's say the type is `Sum Integer' here, for concreteness)
10:57:26 <paf31> this one? https://hakonrossebo.github.io/functional-programming-babelfish/
10:57:38 <paf31> heath: ^
10:58:17 <ph88_> paf31 got triggered by purescript :P
10:58:23 <ski> mivael : in `Last (Just 2) <> Last (Just 1) <> Last (Just 3)' (of type `Last Integer'), the given sequencing actually matters
10:59:11 <mivael> ski, I understand
10:59:11 <heath> paf31: that's the one!
10:59:18 <tobiasBora> Hello,
10:59:31 <tobiasBora> I'd like to know, is there any class for "string-like" structures?
10:59:38 <ski> mivael : the same holds for combining "actions" with `(<*>)' beloning to `Applicative' -- whether the actual sequencing order matters or not depends on the particular type that's an instance of `Applicative' that's being used
11:00:12 <ph88_> tobiasBora, what's "string-like" ?
11:00:14 <tobiasBora> Because I'm tired of having to deal with Text, String, or Bytestring, and I'd like to write general code that could work with any of these types
11:00:18 <mivael> ski, I understand that
11:00:44 <ph88_> ooh
11:01:47 <ski> mivael : however, in a sense, the "wiring" is fixed/static, with `Applicative', you can't have the "context" of a latter part in the sequence depend on the value computed in a former part -- hence "static". otoh, with `Monad', context of latter part *can* depend on value in former part -- hence "dynamic sequencing"
11:01:53 <mivael> ski, ...though the concept of static (as well as dynamic) sequencing seems still be hidden from me :)   Maybe there is something I should read about that?
11:02:16 <MarcelineVQ> tobiasBora: https://github.com/haskell-backpack/backpack-str
11:02:42 <MarcelineVQ> idk if that's complete but backpack is about that sort of idea so it's worth looking at
11:02:52 <ski> mivael : "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <http://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html> is about this distinction
11:04:32 <ReinH> ski: ugh are you convincing me to reevaluate my stance on "sequential"?
11:05:22 <mivael> ski, what you say about dependence of context seems enlightening... I will tink about it (and read the blog post as well).  Thanks!
11:05:27 <ski> mivael : another example of this is parsing. with a monadic parser, you can first parse some text into some partial result (perhaps reading a token word, or reading a potentially more complex description of a format, or reading a packet (or whatever) length number), and then you decide which parser to continue parsing with, depending on the actual run-time value parsed just before
11:05:39 <tobiasBora> MarcelineVQ: It seems that backpack allow to change the whole code to go from one type to another, but it does not handle one code for all the types if I read it carefully...
11:06:40 <ReinH> mivael: you can see this in the types
11:06:44 <ski> mivael : with an applicative parser, this can't happen. you can't make part of the parser up at "run-time" (parser-time). you must fix it beforehand. this also means that applicative parsers can potentially be more efficient, since they can analyze the structure of the parser before any parsing has started
11:06:50 <ReinH> :t (<*>)
11:06:51 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:06:55 <ReinH> :t (=<<)
11:06:56 <lambdabot> Monad m => (a -> m b) -> m a -> m b
11:07:13 <ski> ReinH : i'm not sure what your stance on "sequential" is
11:07:22 <ReinH> =<< (and >>=) lets your function make a choice of m, whereas <*> does not
11:08:17 <ReinH> ski: that talking about sequencing in general for applicatives isn't helpful. Once you relate it to commutativity of the underlying product it makes more sense.
11:09:00 <ReinH> in fact, =<< *requires* your function to make a choice of m, although one is always trivially available with pure.
11:09:43 <ski> "talking about sequencing in general for applicatives" is a bit vague. talking about it in general, for some individual (but more or less otherwise unspecified) instance of `Applicative' .. is probably not that much helpful
11:10:22 <ski> talking about it in terms of the "interface" `Applicative' itself, what it allows and does not allow .. may be more useful
11:11:13 <ski> if you know any group theory, i'd say the situation is a bit similar to e.g. categorical coproduct in there
11:11:27 <MarcelineVQ> tobiasBora: that sounds right, I guess it depends on your usecase, people sometimes use things like https://hackage.haskell.org/package/mono-traversable to write the same code over things like that, there may be more things like that
11:11:33 <ski> given two, say, abelian groups, what is the coproduct ?
11:12:00 <ski> well, it depends on whether you're after "coproduct of them as *groups*" or "coproduct of them as *abelian* groups"
11:12:07 <sproingie> everything i know about category theory i learned from Bartosz Milewski
11:12:41 <ski> so, it doesn't matter as much that the groups happen to be abelian in this case. what matters is whether you're taking that into account or not, when considering the coproduct
11:13:11 <ski> it's not a property of the groups themselves that you're concerned with. it's a property of the "context" in which you're considering the groups
11:15:24 <jaspervdj> If I do `mytool --version`, I'd like to see whether or not `mytool` was compiled using e.g. `-O2`.  Is that info available anywhere at compile time?
11:15:54 <mivael> Thanks to you all!  This was very helpful.  Now I should take my time to think the whole thing all over again :)
11:15:58 <ski> i'm sorry if this is perhaps a not that elucidating attempt to try to make my point. i'm still trying to find better ways to get at what i mean
11:17:07 <ph88_> ExpHP, i think i need to follow this answer http://stackoverflow.com/a/24528696 does that make sense to you ?
11:17:30 <mivael> ski, you mentioned several important points which triggered re-think process :)   Thank you very much.
11:17:42 <ski> mivael : in any case, i emphasize again that the "sequencing" we're talking about here is a *conceptual* sequencing. it doesn't necessarily have anything to do with the order in which things are evaluated
11:17:44 <mivael> *my re-thinking process :)
11:18:08 <ski> (i mention this, because that seems to be a common misunderstanding about newbies to this)
11:18:28 <mivael> ski, okay, I will try to keep that in mind  :)
11:18:50 <ski> what the "sequencing" actually *means*, depends on the particular type that's an instance of `Applicative' or `Monad'
11:19:17 <sproingie> jaspervdj: at *compile* time, you have the flags because you're passing them.  you could put them in a CPP macro and expand it somewhere in your source
11:19:26 <ph88_> what does this guy mean by "it's required to diagonalize by the monad laws" http://stackoverflow.com/a/31361060
11:19:36 <ski> (as i said, in the case of lists, the sequencing can be concretely be thought of as "nested looping, trying all alternatives/combinations". for other instances, it will mean something different, concretely)
11:20:12 <jaspervdj> sproingie: Yeah I can put them in a CPP macro but was wondering if there's an existing macro or TH call I can use.  I suppose not
11:20:43 <sproingie> jaspervdj: nothing i know of.  FSM knows i've wanted that feature in other languages too
11:21:04 <ski> ReinH : i believe that there's something to thinking about `Applicative' functors as relating to "sequencing". but that newbies get this confused in many ways, e.g. confused with order-of-evaluation, to mention one
11:21:08 <sproingie> you kinda get it for free in C with CFLAGS but that doesn't always match reality
11:21:36 <ski> i'm attempting to grasp at that "something" .. perhaps not that successfully
11:21:52 <ReinH> ski: I think you're doing well, you're starting to convince me. :)
11:22:32 <ski> ok, ty
11:26:01 <Gurkenglas> @tell merijn http://hackage.haskell.org/package/one-liner-0.8.1/docs/Generics-OneLiner.html#v:binaryOp should help with http://lpaste.net/354843
11:26:01 <lambdabot> Consider it noted.
11:26:49 <ski> (if i were to be more complete, i'd possibly say "sequencing of combination", and not just "sequencing". since even in the case of instance of `Applicative' resp. `Monad' that are "commutative", we're still left with the conceptual "combination" aspect to interpret in each particular such cse)
11:38:03 <nut> is this code a bug? map (flip addUTCTime now) [1..3]
11:38:10 <ph88_> how can i leave a message with lambdabot ?
11:38:20 <nut> where 'now' is UTCTime
11:38:26 <nitrix> ph88_: @tell <name> <message>
11:38:52 <nut> map (flip addUTCTime now) [1..3] produces an infiite list. I don't get it
11:39:06 <sproingie> impossible
11:39:29 <sproingie> what's addUTCTime look like?
11:39:39 <nut> :t addUTCTime
11:39:41 <lambdabot> error: Variable not in scope: addUTCTime
11:39:50 <ReinH> map can't change the size of the list
11:40:02 <ReinH> so something else is the problem
11:40:20 <nut> addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
11:40:26 <monochrom> Is it an infinite list? Is it a really long finite list?
11:40:35 <ReinH> apparently it's [1..3]?
11:40:43 <ReinH> wait
11:40:44 <nut> try it in 'stack ghci'
11:40:47 <ReinH> the ..
11:40:59 <MarcelineVQ> nut: what is 'now' ?
11:41:01 <ReinH> what is [1..3] :: [NominalDiffTime] ?
11:41:03 <monochrom> Enum for NominalDiffTime may give you a lot of fractions between 1 and 3.
11:41:05 <ReinH> I bet it's infinite
11:41:12 <ReinH> or very long
11:41:31 <sproingie> how could it be more or less than 3 elements?
11:41:40 <ReinH> because .. depends on the Enum instance
11:41:40 <monochrom> It's finite but very fine-grained, it's one of the fixed point number types from Data.Fixed, probably the Pico one.
11:41:41 <nut> monochrom: ah...right
11:41:46 <ReinH> which can do whatever it wants
11:42:12 <nut> so what's the step for [1..3]
11:42:19 <ReinH> e.g., interpret 1 as hours and then succ by microseconds
11:42:19 <nut> i thought it is 1
11:42:19 <nitrix> monochrom: What determines the step size of Double vs. NominalDiffTime?
11:42:26 <monochrom> > 0 :: E1
11:42:28 <lambdabot>  error:
11:42:28 <lambdabot>      ‚Ä¢ No instance for (Num E1) arising from the literal ‚Äò0‚Äô
11:42:28 <lambdabot>      ‚Ä¢ In the expression: 0 :: E1
11:42:42 <ReinH> The implementation of Enum determines the step size.
11:42:43 <sproingie> oh indeed it's a very big list
11:42:48 <monochrom> Ah, I'm supposed to:
11:42:54 <monochrom> > [1..3] :: Deci
11:42:56 <lambdabot>  error:
11:42:56 <lambdabot>      ‚Ä¢ Couldn't match type ‚Äò[Integer]‚Äô with ‚ÄòData.Fixed.Fixed E1‚Äô
11:42:56 <lambdabot>        Expected type: Deci
11:43:29 <ReinH> try map (flip addUTCTime now . fromInteger) [1..3]
11:43:41 <ReinH> forcing [1..3] :: [Integer]
11:43:43 <nut> thanks you guys!
11:43:57 <ReinH> or just use [1,2,3]
11:43:58 <monochrom> Oh! List!
11:44:01 <monochrom> > [1..3] :: [Deci]
11:44:03 <lambdabot>  [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8...
11:44:06 <ReinH> heh
11:44:07 <monochrom> There.
11:44:21 <nitrix> That's very nice.
11:44:28 <monochrom> NominalDiffTime is only worse. (Pico, 10^-12)
11:44:48 <ReinH> haha it was even worse than I thought
11:44:49 <sproingie> i imagine [1..3] is an example.  any range would be a problem
11:44:55 <nitrix> So, I suppose it's using Enum (Fixed Deci) ?
11:45:06 <nitrix> Which is implemented as steps of 0.1 ?
11:45:16 <ReinH> [n..m] is sugar for enumFromTo n m, which uses succ internally
11:45:23 <ReinH> and succ determines the step size
11:45:55 <ReinH> Enum is kind of weird. 
11:46:06 <nitrix> Does this means someone could implement a "theorically" finite list, as far as Haskell is concerned, when it's in reality infinite precision?
11:46:19 <nitrix> (e.g. some Integer-like float)
11:46:20 <monochrom> For Deci it is fairly uncontroversial to have step size 0.1 because that's what Deci does and it's a discrete number system.
11:46:21 <ReinH> nitrix: I could define succ for natural numbers as succ n = n
11:46:30 <ReinH> then any enumeration of these broken nats would be infinite
11:46:44 <nitrix> ReinH: but that's breaking some of the laws isn't it ?
11:46:45 <sproingie> thus the name Deci.  Is there a Centi?
11:46:48 <ReinH> what laws?
11:46:55 <monochrom> Yes!
11:47:03 <monochrom> Check out Data.Fixed for much goodies.
11:47:14 <MarcelineVQ> this is indeed much goodies
11:47:17 <monochrom> type Deci = Fixed E1
11:47:24 * sproingie usually works with Data.Broken
11:47:28 <nitrix> ReinH: I'd expect `succ x > succ`
11:47:30 <monochrom> Haha
11:47:31 <ReinH> nitrix: please point me to these Enum laws ;)
11:47:34 <nitrix> ReinH: I'd expect `succ x > x`
11:47:49 <ReinH> Ok, please point me to where that is specified.
11:47:51 <sproingie> :i Enum
11:48:02 <monochrom> I know the Enum laws. But they are still pretty much open-ended.
11:48:19 <nitrix> ReinH: It's a throw in the dark. I see where you're going with this. That's very naughty.
11:48:25 <ReinH> Enum is lawless.
11:48:30 <ReinH> It is cats and dogs living together.
11:49:12 <monochrom> Even if you take into account the common laws, it's basically "try your best at an order isomorphism between your type and Integer or Natural"
11:49:13 <sproingie> i imagine one such law would be succ x < x
11:49:15 <sproingie> er >
11:49:33 <sproingie> greater, lesser ... pfft who cares ;)
11:49:34 <ReinH> monochrom: there are Enum suggestions.
11:49:45 <monochrom> And there is an order isomorphism between Integer and Fixed E1. It scales by 10.
11:50:09 <ReinH> > succ ()
11:50:11 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
11:50:12 <ReinH> how about those laws
11:50:18 <nitrix> Now that I think about it, `succ x /= x` would be the most important, otherwise you don't even have a successor, but I can't find that anywhere.
11:50:44 <nitrix> ReinH: Ah! Case in point. Nice example.
11:50:46 <sproingie> unsafety really succs
11:50:56 <ReinH> why must succ x /= x?
11:51:05 <ReinH> that's true for Peano numbers, but it's true axiomatically.
11:51:35 <ReinH> also let's not even get into the correct number of 'c's in suc
11:51:37 <nitrix> Because if you have only one element, there's no succession o.<
11:51:46 <ReinH> according to your definition of succession
11:51:49 <nitrix> Why would Enum () even exist.
11:51:49 <sproingie> but unit is still an Enum instance
11:51:52 <ReinH> why am I bound by your definition of succession?
11:52:07 <ReinH> > fromEnum ()
11:52:09 <lambdabot>  0
11:52:14 <ReinH> > toEnum 0 :: ()
11:52:16 <sproingie> nitrix: convenience, just in case you wanted another way to raise runtime errors
11:52:16 <lambdabot>  ()
11:52:19 <ReinH> That's the entire reason it exists.
11:52:29 <ReinH> oh wait
11:52:36 <ReinH> > [() .. ()]
11:52:37 <lambdabot>  [()]
11:52:49 <nitrix> Cute ascii robot :]
11:53:03 <ReinH> > [(),()..()]
11:53:04 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
11:53:07 <ReinH> fun times
11:53:15 <sproingie> my god.  it's full of units.
11:54:30 <nitrix> That makes me think toEnum/fromEnum should be independent of `succ` somehow, but I'm sure I'm alone on that view.
11:54:43 <ReinH> The type [()] is a forgetful list, a.k.a. a natural number.
11:54:56 <monochrom> I don't think it's useful to make a distinction between "law" with "suggestion".
11:55:11 <sproingie> the suggestion of gravity
11:55:14 <MarcelineVQ> you have to be able ot enforce laws
11:55:16 <ReinH> monochrom: Well, they are not laws in the conventional sense of being laws.
11:55:34 <ReinH> they aren't documented with the typeclass
11:55:36 <Tuplanolla> Can you not use laws in rewrite rules, monochrom?
11:55:42 <MarcelineVQ> "Enum, you betrayed the law"
11:55:46 <sproingie> Suggestion of Gravity would be a cool band name
11:56:02 <ReinH> maybe they are folk laws
11:56:16 <monochrom> Haskell 2010 section 6.3.4: "For any type that is an instance of class Bounded as well as Enum, the following should hold:" "The calls succ maxBound and pred minBound should result in a runtime error."
11:56:24 <ReinH> monochrom: yes, note the caveat
11:56:33 <ReinH> those are laws for (Enum t, Bounded t)
11:56:34 <MarcelineVQ> playing tonight Suggestion of Gravity with opening set by Boson Bison
11:56:41 <monochrom> If you honour the "should" there, that clause applies to ().
11:57:04 <monochrom> It is not because nitrix likes it. It is because Haskell 2010 likes it.
11:57:19 <sproingie> sure would be nice if the prelude were safe
11:57:22 <ReinH> Again, that doesn't apply to Enum, it applies to Enum + Bounded
11:57:35 <monochrom> () is Enum + Bounded
11:57:36 <ReinH> Enum per se does not have laws
11:57:41 <ReinH> Yes, so?
11:57:43 <monochrom> > maxBound ()
11:57:45 <lambdabot>  error:
11:57:45 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M140710939598...
11:57:45 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
11:57:50 <monochrom> > maxBound :: ()
11:57:51 <lambdabot>  ()
11:57:58 <monochrom> So succ () = bottom.
11:58:01 <cocreature> > succ (maxBound :: ())
11:58:03 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
11:58:12 <ReinH> Yes. That's true, but doesn't imply that Enum has laws.
11:58:15 <nitrix> See, to me `succ` should belong in Bounded.
11:58:27 <ReinH> It just implies that Enum + Bounded has laws, which was the premise.
11:58:29 <cocreature> nitrix: that doesn‚Äôt make sense either
11:58:39 <cocreature> nitrix: why do you need something to be bounded to provide a successor function
11:58:43 <sproingie> Integer isn't bounded, that has succ
11:58:58 <nitrix> cocreature: Ah sorry, no you're right, this is still flawed.
11:59:27 <tobiasBora> MarcelineVQ: Thank you!
11:59:30 <Tuplanolla> :t suck -- We clearly need this too.
11:59:32 <lambdabot> Enum a => a -> Maybe a
11:59:39 <ReinH> If Enum had laws, they might be things like "succ should equal toEnum . succ . fromEnum when it is defined"
11:59:58 <tobiasBora> Another question,
12:00:02 <sproingie> Suckable a
12:00:11 <monochrom> Fine.
12:00:16 <tobiasBora> I'd like to return a type "IO (Either String String)"
12:00:51 <ReinH> monochrom: some fast and loose laws of that nature might be useful
12:00:59 <ReinH> "if it's defined it must behave like so"
12:01:04 <monochrom> No, that is not my disagreement.
12:01:17 <tobiasBora> I've a function "myfunction :: Int -> Either String String" 
12:01:41 <monochrom> "All prime numbers are odd" from your POV is a theorem about prime numbers not natural numbers. From my POV it is a theorem about natural numbers too.
12:01:45 <ski> tobiasBora : use `return' ?
12:01:54 <ReinH> it doesn't follow from "an instance of Enum has laws, which it gets by virtue of also being an instance of Bounded" that "Enum has laws".
12:02:01 <monochrom> Err, "all prime numbers above 2".
12:02:08 <sproingie> well, a subset of naturals.  4 is a natural number
12:02:28 <ReinH> it is properly a theorem about natural numbers which are also prime numbers
12:02:33 <tobiasBora> ski: The thing is that if "myfunction" returns "Right ...", I'd like to do others stuff
12:02:34 <ReinH> it says nothing about natural numbers which are not prime numbers
12:02:36 <sproingie> the theorems kind of define the subset in the first place
12:02:41 <ReinH> the same is the true for the Enum + Bounded laws
12:02:49 <cocreature> if you phrase it like "forall (n : nat), is_prime n -> is_odd n" it‚Äôs a statement about all natural numbers
12:03:04 <ReinH> monochrom: anyway, this isn't a particularly interesting thing to disagree on
12:03:24 <ski> tobiasBora : then do so ?
12:04:00 <ski> tobiasBora : you can use `let result = myfunction myInt' as a command in a `do'-block
12:04:26 <ski> tobiasBora : then you could use `case' (or the function `either') on `result'
12:04:59 <ski> tobiasBora : an alternative, iiuc, would be to use `ExceptT String IO String' instead of `IO (Either String String)'
12:05:01 <Tuplanolla> Suddenly `forall (x : real), is_nat x -> is_prime (round x) -> is_odd (round x)` is a statement about all numbers, cocreature.
12:05:13 <ReinH> :t let myFunc = undefined :: Int -> Either String String in return . myFunc
12:05:14 <lambdabot> Monad m => Int -> m (Either String String)
12:05:25 <cocreature> Tuplanolla: yep :)
12:05:29 <ski> (all that does is hide the extra plumbing of the `case', and not continuing in the case of `Left')
12:05:32 <monochrom> It is fundamental. Suppose you have two functions f,g and they satisfy "f . g = id". Is this a law about f? g? id?
12:05:45 <ReinH> cocreature: this is a boring disagreement about either definitions or logical connectives. ;)
12:05:57 <monochrom> My POV is that it is useless to rigidly put laws into bins like that.
12:06:01 <cocreature> ReinH: yeah, I‚Äôll shut up now :)
12:07:09 <ski> tobiasBora : i.e. .. *if* indeed you're using the `Left' case as "failure detected, abort further processing", *then* a use of `ExceptT' here could be appropriate
12:07:37 <monochrom> But people who absuse the Curry Howard correspondence do precisely that. They want the type of f to fully specify the properties of f. Ah but you can't, it is the mutual interaction of f and g, even and id, that is the most important property.
12:07:54 <ReinH> monochrom: and mine is just that a proposition which holds forall A + B does not (necessarily) hold forall A. If all men are named Fred, that doesn't imply that all people are named Fred. See how boring this argument is? ;)
12:08:04 <monochrom> My POV is "X has laws" should be laxly interepreted as "there are laws involving Enum".
12:08:33 <cocreature> I don‚Äôt think you are going to agree here no matter how long you explain your povs :)
12:08:35 <ReinH> Ok, a disagreement about definitions then. :)
12:09:00 <monochrom> I am explaining to other people.
12:09:03 <sproingie> "This is not 'nam, this is programming.  There are rules!"
12:09:05 <ski> well, `forall x : A. exists y : B. R (x,y)' is equivalent to `exists f : A -> B. forall x : A. R (x,y)'. in the former case, the property is baked into the result of the operation. in the latter case, the property is stated separately
12:09:28 <ReinH> ski: Yes, as I said, it's a disgreement about either definitions or which connectives we're using. :D
12:09:31 <ExpHP> does adding an INLINABLE attribute toa function have any effect when its only uses are inside the same module?
12:09:32 <ReinH> *disagreement
12:09:35 <ski> (so it only applies to one way of using the CH)
12:10:00 <ski> ReinH :)
12:10:36 <MarcelineVQ> tobiasBora: there's a few options as you can see, so if you want a more specific answer for your question you'll need to show the code you're working on and what you intend for it to do
12:10:52 <ReinH> ski: I don't think either of us are going to benefit from pursuing it, but I don't mind monochrom clarifying his point.
12:11:09 <ski> was someone claiming that there should be laws that apply when you have something that simultaneously an instance of `Enum' and `Bounded' (or `Read' and `Show', or ...) ? (i didn't follow the start of the conversation)
12:11:32 <monochrom> Yes. It's in Haskell 2010.
12:11:34 <ReinH> ski: The argument was that "there are laws for Enum" because "there are laws for Enums which are also Bounded"
12:11:46 <ReinH> And we disagree about which entailment we're using.
12:11:51 <ski> monochrom : *nod*. i believe that's a mistake
12:12:16 <ski> ReinH : mhm
12:13:05 <ReinH> or which quantifier, or something
12:13:13 <ReinH> whatever :)
12:13:39 <monochrom> If you're commenting on that law itself, I am fine with either "succ maxBound = maxBound" or "succ maxBound = bottom". I am not OK with leave it open so some types do one thing and some other types do the other thing.
12:13:45 <Tuplanolla> It should not, unless you export it, ExpHP.
12:13:54 <sproingie> what would be Bounded and not Enum?
12:13:58 <ski> (.. or at least, it being a mistake, without there being some kind of "pushouty" machinery, if you'll allow that vague term, that determines the interaction. and in this case, there's presently no such machinery, i believe)
12:15:52 <ski> sproingie : hm .. how about some partially, but not totally, ordered type, having a maximum and minimum element ?
12:15:53 <ReinH> ski: timey wimey pushouty wooshouty
12:16:04 <monochrom> I think (Enum t, Bounded t) is already the pushout?
12:16:14 <ski> > minBound :: (Bool,Bool)
12:16:16 <lambdabot>  (False,False)
12:16:28 <ExpHP> thanks Tuplanolla
12:16:53 <ReinH> monochrom: btw did you see that idris removed constraint products and now curries them? so Enum t => Bounded t => ...
12:16:59 <ski> monochrom : yes, but then were does the law "attach" ? nowhere afaics
12:17:05 <ReinH> This makes me wonder if I've been confused about what => means this whole time
12:17:24 <ski> (er, s/were/where/)
12:17:50 <tobiasBora> ski: Hum ExceptT may be usefull, I'm tired of using case everywhere
12:18:05 <monochrom> ski, if I have a law "f . g = id", do you attach it to id?
12:18:06 * ski smiles
12:18:32 <ski> i dunno. i suppose you could, if you really wanted to
12:18:44 <monochrom> The whole reason why I don't attach rigidly.
12:19:47 <ski> if person A makes `T' an instance of `Enum', and person B makes `T' an instance of `Bounded', then whose responsibility is it to check the additional laws ?
12:20:00 <sproingie> id being just a function, the context how you use it depends on the class.  should be attached to, say, Functor
12:20:17 <sproingie> not that you can enforce it there either
12:20:25 <monochrom> Ah. I'll arbitrate it to the chronologically second person.
12:22:14 <ReinH> ski: ah you want the cartesian product ;)
12:23:00 <ReinH> in the category of, I guess, mostly garbage sequences of mostly ASCII
12:23:20 <ski> if person A puts a group structure on a set `S', and person B puts a topological structure on `T', then whose responsibility is it to check that we have a topological group ?
12:23:20 <monochrom> I suppose you then say "we don't know who's chronologically second"
12:23:23 <ReinH> you want (Enum t, Bounded t) to exist somewhere in code once Enum t and  Bounded t do separately
12:23:51 <ReinH> maybe it's a shame that we're working in mostly garbage sequences of mostly ASCII for this
12:24:22 <ski> (er, puts a topological structure on `S', not `T'. sorry)
12:24:41 <monochrom> Then by the law of Excluded Middle, this sofware is either corporately developed or open-sourcedly developed.
12:24:47 <ReinH> heh
12:25:05 <monochrom> If corporately developed, the project manager will do the arbitration.
12:25:14 <sproingie> law, fallacy, whatev ¬Ø\_(„ÉÑ)_/¬Ø 
12:25:16 * ski excludes middlemen
12:25:39 <monochrom> If open-sourcedly developed, the matter will be democratically resolved by loud yelling.
12:27:40 <monochrom> Oh I guess that doesn't show the full beauty of excluded middle, eh?
12:28:23 <monochrom> In the corporate setting, a lout of loud yelling is also how the project manager (or God help us, a lot of project managers) arbitrates.
12:28:35 * ski thinks "excluded middle" (in the general), to the extent it's applicable, is basically `id'
12:28:51 <monochrom> So, excluded middle followed by disjunction elimination yields: loud yelling.
12:28:52 <ph88_> is there a last seen function on lambdabot ?
12:29:12 <monochrom> Not anymore.
12:30:33 <monochrom> Next I show you the beautiful proof of why the set { n in Nat | the twin-prime conjecture is true } is decidable. :)
12:30:40 <ReinH> monochrom: once again why we must decisively smash the formalist clique
12:30:48 <sproingie> monochrom: won't fit in the margin, eh?
12:30:55 <monochrom> will fit
12:31:02 <monochrom> 3 lines
12:31:04 <ReinH> for sufficiently large sizes of margin
12:31:12 <ski> (iow, if you're proving `A or B' by assuming `not A' and proving `B', what you're doing is shirking the responsibility of refuting `A' to the "opponent". if and when they do that, you promise to then prove `B'. iow, instead of getting to the work of determining the alternative, you wait for the opponent to do some work)
12:31:13 <sproingie> becauseISaidSo :: a -> Bool
12:31:22 <monochrom> By excluded middle, the twin-prime conjecture is true or false.
12:31:58 <monochrom> If true, \x -> True decides that set. If false, \x -> False decides that set. Disjunction elimination => the set is decidable.
12:32:18 <ski> (.. so, it amounts to two different senses in which to take `or')
12:34:51 <ski> therefore, the proof above proceeds by using an introduction rule for one kind of disjunction, and then using an elimination rule for another kind of disjunction :)
12:35:16 <monochrom> I'm pretty sure both "or"s enjoy elimination.
12:35:32 <ski> indeed
12:37:14 * shapr hops cheerfully
12:37:25 <monochrom> That came out bizzare if anthropomorphized. "Both John and Johan enjoy elimination" Yikes.
12:38:47 <sproingie> not eliminating at all tends to be unpleasant
12:39:51 * ski idly ponders destructive logic
12:40:19 <cocreature> ski: hm, does that mean you‚Äôre only allowed to use elimination rules?
12:41:01 <ski> (cf. Subtractive logic, Dual-intuitionistic logic. Rajeev Gore, Crolard, Igor Urbas, &c.)
12:41:13 <monochrom> allow excluded middle, disallow absurdity ((p and not p) -> q)
12:41:54 <ski> monochrom : hm. the last now reminds me of relevant/relevance logic
12:43:05 <monochrom> I don't know how to use this logic, but I love dualization.
12:44:43 <ski> cocreature : no. i think one way to look at it is to consider the primary judegment being "does not follow from". so to speak, everything is considered to be potentially true, until (and if) it has definitely been refuted
12:45:52 <ski> `exists a : A. forall b : B. R (a,b)' should be equivalent to `forall f : A -> B. exists a : A. R (a,b)'. cf. Kreisel's "no counter-example interpretation"
12:46:51 <monochrom> R(a, f a) in the second.
12:46:56 <ski> er, right
12:46:58 <ski> ty
12:47:59 <monochrom> Wait, forall f? exists f?
12:48:35 <ski> it's some kind of "backwards choice"
12:48:55 <monochrom> It's forall I guess.
12:49:24 <ski> pick `R (a,b)' as `not (S (a,b))', apply classical logic to arrive at choice
12:51:00 <monochrom> Ah yes. Beautiful.
12:53:03 <ski> to refute `exists a : A. forall b : B. R (a,b)', you should for any given `a : A' produce a `b : B' refuting `R (a,b)'. to refute `forall f : A -> B. exists a : A. R (a,f a)' you provide this transformation from `a : A' to `b : B', so that in the event of someone daring to put forward an `a : A', you can refute `R (a,f a)'
12:56:22 <ski> <https://xorshammer.com/2008/08/13/kreisels-no-counterexample-interpretation/> has some info on Kreisel's no counterexample interpretation
12:56:49 <sproingie> great blog title
13:14:24 <ij> I can't find strict-io in stackage https://www.stackage.org/lts-7.17/hoogle?q=strict-io, but upon requiring it in stack.yaml, it finds it only to complain about incompatability with some package. How come?
13:15:35 <ezyang> well... the incompatibilit yis probably why it isn't in stackage? 
13:17:23 <ij> So it will try to use things that are out of the compatible pkg set?
13:17:54 <woddy> so I'm not into imperative programming
13:18:10 <shapr> but Haskell is the best imperative programming language :-(
13:18:17 <winmillwill> how do I find the package that requires another package that is causing the "indirectly depends on multiple packages" problem?
13:18:20 <woddy> question: has someone mapped Z notation to Haskell?
13:18:32 <woddy> as in you write Z notation and then you get haskell code?
13:18:54 <woddy> would that be something realistically achieveable?
13:18:58 <bennofs> winmillwill: ghc-pkg check may help
13:19:08 <bennofs> winmillwill: but I'm not sure if it detects that
13:19:39 <ezyang> ij: I'm not sure what you tried, but if you did the "how to add a non-stackage package to stackage yml", if the package is actually incompatible with the stackage snapshot, you're kind of out of luck, as far as stackage is concerned 
13:19:41 <bennofs> winmillwill: also perhaps configure with -v2 gives some useful info?
13:19:45 <ezyang> you'll have to depsolve yourself into a solution 
13:19:45 <winmillwill> k, do you know how I could do that in the context of a failing nix-build ?
13:20:06 <bennofs> winmillwill: so you have a shell.nix that fails to build?
13:20:35 <bennofs> winmillwill: i need to info about how your nix build looks like. did you autogenerate it with cabal2nix or is it something you wrote?
13:20:45 <winmillwill> autogenerated
13:21:02 <bennofs> winmillwill: ok so you cabal2nix'ed it, generated shell.nix and then probably edited it a little right?
13:21:14 <winmillwill> a default.nix, but yeah
13:21:40 <bennofs> winmillwill: hmm. then you can run nix-shell --pure to get a shell where the build would be run
13:22:11 <bennofs> winmillwill: so you can do something like: nix-shell --pure and then type `cd /tmp` and then `genericBuild` which starts the build of the package as nix would do it
13:23:39 <winmillwill> ghc-pkg isn't even in the environment of nix-shell...
13:23:49 <winmillwill> it should be needed for the build to work, right?
13:23:58 <bennofs> winmillwill: let me check. did you already run genericBuild?
13:24:02 <winmillwill> yeah
13:25:25 <bennofs> winmillwill: hmm no I think that is correct
13:25:41 <geekosaur> cabal and ghc use libraries to access the package database, and shouldn't need ghc-pkg itself
13:25:56 <winmillwill> k, so Setup might be able to tell me?
13:26:01 <geekosaur> I should say Cabal (i.e. the library, so stack should also be covered)
13:27:18 <winmillwill> I can get a failed build to hang around with nix-build -K, but then I'm not sure what I should be checking
13:27:58 <ij> Can you run ghc executables in alpine linux in docker? pthread_setname_np is missing, but based on googling ghc+alpine, it seems that someone has been able to run it.
13:28:07 <bennofs> winmillwill: in the shell, when you run genericBuild, it should show something like "building with /nix/store/.../ghc". you can copy that path to find where ghc-pkg ist
13:29:55 <bennofs> winmillwill: it appears that you should see what packages require which version from the output of the build
13:30:01 <bennofs> winmillwill: you may need to scroll a little
13:31:18 <bennofs> winmillwill: the lines should look like "package foo-xxx requires bar-yyy"
13:31:29 <winmillwill> well, I can see "package haskell-src-exts-simple-1.19.0.0 requires haskell-src-exts-1.19.1" but not what requires THAT
13:31:39 <winmillwill> so I don't know which cabal to override
13:32:12 <bennofs> winmillwill: and other packages require other versions of haskell-src-exts? can you paste your default.nix somewhere?
13:32:27 <winmillwill> sure
13:34:07 <lpaste> winmillwill pasted ‚Äúdefault.nix ‚Äù at http://lpaste.net/354886
13:34:26 <winmillwill> dependencies.nix is just the output of cabal2nix
13:35:26 <winmillwill> state-plus.nix is me saying `doCheck = false` because it blew up wanting a specific version of QuickCheck
13:36:23 <bennofs> winmillwill: oh hmm this does look correct
13:36:43 <bennofs> winmillwill: is there also some package requiring a different version of haskell-src-exts?
13:38:02 <winmillwill> it's not even a top-level dep for me
13:38:16 <winmillwill> dependencies.cabal is just: build-depends:       base < 5, apply-refact, codex, hasktags, hlint, hoogle, pointfree, pointful
13:39:48 <winmillwill> of course, the other thing that this is showing me is that although these are logically related by being "dev tools" there's no reason the actual executables need to use any of the same libs, so I should just back off and install them separately
13:40:43 <winmillwill> but of course now I'm curious about how to solve the incidental problem too
13:41:32 <bennofs> unrelated to nix, is there a command to find out which package requires a given package when cabal configure fails?
13:41:42 <bennofs> (due to multiple conflicting options)
13:42:03 <winmillwill> there's ghc-pkg dot but IIUC that only looks at what successfully got installed
13:42:20 <bennofs> winmillwill: it would show you which things depend on the wrong lib version though
13:42:37 <winmillwill> how? nothing is getting installed
13:42:40 <winmillwill> we're dying in configure
13:42:52 <bennofs> winmillwill: all the dependencies are already installed at that point
13:43:47 <winmillwill> I'm not seeing any of them in the output
13:43:58 <winmillwill> of ghc-pkg dot
13:44:17 <bennofs> winmillwill: you need to run it inside the nix-shell
13:45:17 <bennofs> winmillwill: anyway, in this particular case, the reason for this can be found in configuration-common.nix in the nixpkgs repo. I agree that this is not very discoverable
13:45:52 <bennofs> winmillwill: in particular, this causes the problem: https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/configuration-common.nix#L696-L697
13:46:24 <winmillwill> heh
13:46:39 <winmillwill> did you just know to go check the top-level deps there?
13:46:45 <bennofs> winmillwill: yeah :/
13:47:43 <winmillwill> at least I didn't miss something super obvious
13:51:37 <winmillwill> bennofs: is there a reference of things like genericBuild so I can try to step through things like this?
13:52:32 <bennofs> winmillwill: i don't think there is any in-depth reference of the haskell infrastructure. there's only http://nixos.org/nixpkgs/manual/#users-guide-to-the-haskell-infrastructure
13:53:25 <bennofs> winmillwill: `genericBuild` actually works for all nix packages, it just a helper function that executes all the phases of a nix build for you (as long as it uses stdenv, which all nix builds should)
13:54:12 <winmillwill> cool, thanks for the help
14:08:22 <AWizzArd> Impure function vs action. Both okay? I mean, every Haskeller will understand it when I call getLine a ‚Äûfunction‚Äù. But should one still better call it an ‚Äûaction‚Äù instead?
14:08:51 <bennofs> AWizzArd: call it operation?
14:09:04 <AWizzArd> Yes, also doing that sometimes.
14:09:05 <Tuplanolla> :t getLine -- What's so function about this, AWizzArd?
14:09:06 <lambdabot> IO String
14:09:12 <Tuplanolla> There's no arrow to be seen.
14:09:29 <lyxia> Well it's a function in the C sense
14:09:31 <AWizzArd> Tuplanolla: I totally agree. What I mean is that there is context understanding.
14:09:56 <AWizzArd> A Haskeller will not be puzzled and totally confused what I am talking about. He won‚Äôt mistake this for a conversation about the moon landing.
14:10:07 <Tuplanolla> I always call C functions procedures instead, lyxia.
14:10:11 <AWizzArd> But: operation or action are preferrable?
14:10:44 <phillip> Hi, I have the following problem https://pastebin.com/raw/8GHQ8EJ4, thanks for your help!
14:10:51 <bennofs> AWizzArd: probably action is better as it is more common (i believe)
14:11:15 <AWizzArd> What is an impure function?
14:11:24 <AWizzArd> I saw this term used in the Haskell literature.
14:11:39 <Rembane> AWizzArd: A function that has side effects.
14:11:54 <AWizzArd> Rembane: but not necessarily IO?
14:12:02 <AWizzArd> Because, then it would be an action or operation.
14:12:33 <Rembane> AWizzArd: Hm... yes. You can have side effects when using StateT for instance.
14:12:53 <Tuplanolla> Without any context my guess would be some `a -> m b`, AWizzArd.
14:13:27 <AWizzArd> Ah okay, so as a rule of thumb:   a -> m b   functions are potentially candidates to be impure.
14:13:45 <AWizzArd> Good, thanks for your inputs guys.
14:13:45 <Sonolin> I don't think that's the general consensus, though
14:14:05 <Tuplanolla> If you consider Kleisli impure and disgusting...
14:14:29 <AWizzArd> I am not even sure who Kleisli is.
14:15:17 <Tuplanolla> A mathematician, what else?
14:19:37 <monochrom> "Kleisli arrow" means "a -> M b" where M is a Monad.
14:20:19 <AWizzArd> Under ‚Äûarrow‚Äù I could understand two things. There is a combination of two chars that visually looks like an arrow:   ->
14:20:40 <AWizzArd> But there is also an abstraction, which is a bit similar to Monads (but weaker).
14:20:53 <Tuplanolla> Here it means a morphism.
14:21:05 <Tuplanolla> That in turn is a generalization of a function.
14:34:37 <inkbottle> [noob]: When I get "Could not find module ‚ÄòCodec.Compression.GZip‚Äô It is not a module in the current program, or in any known package." (stack ghci); Does that mean I have to use "stack install ..."?
14:34:54 <inkbottle> And how do I guess the name of the package to install?
14:35:48 <sproingie> if you're using stack, it means it has to be in your build dependencies.  is this your own code or are you building some other package?
14:35:50 <tommd> It means you need to install a package, be it via stack, cabal or something else.
14:36:11 <glguy> inkbottle: Google's a good way to guess. I often search for "haskell" and the name of the module
14:36:17 <sproingie> if you're not using stack, you'd cabal-install it.  as for finding the package name, hoogle is good for that
14:36:22 <tommd> And if you use `cabal install` or `stack install` then yes, what sproingie said.  If you are using `ghci` or `cabal build` then you'll need to explicitly install it.
14:36:34 <sproingie> or just googling it which will usually point where hoogle does anyway
14:37:20 <tommd> inkbottle: hoogle also works (https://www.haskell.org/hoogle/?hoogle=Codec.Compression.GZip)
14:37:27 <tommd> Not always, but for some set of packages.
14:37:41 <inkbottle> sproingie: own code; actually snippets from the web
14:37:57 <sproingie> how much of hackage does hoogle index, anyway?
14:38:35 <tommd> Is ndm here these days?
14:38:49 <tommd> Nope
14:39:38 <tommd> sproingie: From the manual "By default, searches look at the Haskell Platform and Haskell keywords."
14:39:58 <tommd> https://github.com/ndmitchell/hoogle/blob/master/README.md
14:42:24 <inkbottle> sproingie: do you mean if I were not using "stack" but instead plain ghc, then it would install automatically?
14:43:06 <tommd> inkbottle: The other way around.  If you are installing a package via `stack install` or `cabal install` then it will automatically install dependencies and all you need to do is list the correct dependencies in the projects `*.cabal` file.
14:43:26 <sproingie> if you have a single-file project, you can do "stack runghc blahblah.hs --package zlib"
14:43:35 <phillip> Hi, I have the following problem https://pastebin.com/raw/8GHQ8EJ4. Why does reusing the given funktion "op" makes problem?
14:43:38 <tommd> inkbottle: But if you are running `ghc someFile.hs` then it will use whatever packages are already installed.
14:44:10 <sproingie> if you have a multi-file project, probably gonna need to do a proper stack project
14:44:20 <inkbottle> sproingie: tommd: Nice, thanks a lot
14:44:21 <tommd> phillip: You are passing a single argument to your recursive foldList call.
14:44:39 <tommd> phillip: What do you think "op tail x" does?
14:45:18 <tommd> consider instead "foldList op (tail x)"
14:46:53 <phillip> tommd: ahh thanks a lot. Thats what it should do!
14:49:55 <phillip> have a great week, bye!
14:50:21 <jle`> sproingie: hoogle is actually out of date
14:50:27 <jle`> ( tommd )
14:50:33 <jle`> its index hasn't been updated in almost three years
14:51:09 <bennofs> jle`: even the one at http://hoogle.haskell.org/ ?
14:51:15 <reactormonk[m]> jle`: what happened?
14:51:16 <reactormonk[m]> that would explain why hayoo is decent. Or just use stackage search?
14:51:25 <jle`> bennofs: that one is being updated, i believe
14:51:35 <jle`> just the 'official' hoogle is out of date
14:51:47 <jle`> reactormonk[m]: updates were suspended pending the upcoming release of hoogle 5
14:51:59 <lyxia> "upcoming" since forever
14:52:53 <jle`> to be fair, it's a complete rewrite
14:53:02 <jle`> this is the latest news i believe http://neilmitchell.blogspot.com/2015/01/hoogle-5-is-coming.html
14:53:52 <lyxia> yeah he seems to be pretty busy
14:55:06 <jle`> oh this is the latest update http://neilmitchell.blogspot.com/2015/02/why-is-hoogle-index-so-out-of-date.html
14:59:18 <sproingie> ugh.  didnt know it was *that* out of date now
15:00:34 <sproingie> second system effect ("it's a total rewrite! it'll be awesome! real soon now!") and its effect on the current version
15:00:58 <sproingie> maybe "vaporware strike" is the term, even if it's self-directed?
15:04:45 <monochrom> endomorphic vapourware strike :)
15:04:57 <sproingie> that'd be a good band name
15:05:13 <Gurkenglas> He's been working for years on a tool that'll save him two hours on each several-yearly index update?
15:05:51 <sproingie> i'd imagine more features too
15:18:05 <That_Guy> Hello, question. Supposed I have a type  "data Foo (a :: Bool) = Foo" and I want to have a function that does something similiar to the following "checkFoo :: Foo a -> Foo b -> Foo (a && c)"
15:18:34 <That_Guy> woops thats supposed to be "a && b", basically i want to and the types. Is that possible?
15:19:20 <jle`> That_Guy: you would have to define your own &&
15:19:27 <That_Guy> yes thats my intent
15:19:29 <jle`> but otherwise, yes, it's possible
15:19:45 <That_Guy> cool, What extensions would I  need for something like that?
15:19:46 <jle`> type family a && b where False && b = False; a && b = b
15:19:49 <jle`> TypeFamilies
15:19:58 <jle`> * True && b = b
15:20:48 <That_Guy> ok, I will try that nvr tried type famalies before :) thx
15:21:11 <jle`> no problem!  be aware that bools at the type level are much less useful than bools at the value level, though
15:21:18 <jle`> and there's uaually a better way of doing what you want to do
15:21:36 <sproingie> type level bools are () and Void, no?
15:21:48 <That_Guy> oh well
15:21:55 <jle`> type level bools are data Bool = False | True
15:21:57 <That_Guy> the example i gave was really simple
15:22:26 <That_Guy> What I really have is an Operation type, so  "data Operation (o :: Optype) l r = ..."
15:22:37 <That_Guy> and my op type has  "Fixed | Streamed"
15:23:14 <That_Guy> I basically want semantics "Fixed && Fixed = Fixed" "Stream && Stream == Error" and  "Stream && Fixed = Stream"
15:24:04 <That_Guy> So I basically want a compiler error on  "Stream && Stream"
15:24:10 <jle`> is Error a different type you haven't mentioned here
15:24:12 <That_Guy> though  not sure if that is going to work
15:24:22 <sproingie> yah, not so much bools as isomorphic to them.  fiddling with unit and void at the type level is type-level bools qua bools
15:24:25 <That_Guy> ah well by Error I meant "compiler error"
15:24:25 <jle`> oh you want a compiler error
15:24:40 <jle`> you can use GHC.TypeLits in your type family to get compiler errors on bad combinations
15:24:44 <jle`> with nice error mesages
15:24:55 <That_Guy> oh really!?
15:24:55 <monochrom> Instead of an "error" type, simply omit anything that specifies what to do with Stream && Stream.
15:24:57 <That_Guy> that be nice
15:25:24 <sproingie> ooh anything that lets me have friendlier type errors is nice
15:25:27 <jle`> see the example in http://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-TypeLits.html#t:TypeError
15:25:37 <sproingie> it's weird that i know more about how to do that in C++ than haskell
15:25:54 <monochrom> Oh yikes haha that's better.
15:26:27 <sproingie> c++ you just make a template that has a deliberately failing static_assert to rule out illogical types
15:26:38 <monochrom> I guess it's an addition I didn't notice when upgrading to GHC 8
15:26:45 <sproingie> and your assert has a nice friendly error you give it
15:26:50 <That_Guy> I don't support there is a nice code example of doing what I want to achieve?
15:28:32 <That_Guy> actually this might be similiar to what I want no? type family And (a :: Bool) (b :: Bool) :: Bool where from the type family page
15:28:38 <sproingie> in c++?  i could probably dig up template metaprogramming examples.  for haskell i'm pretty much a newb at type-level stuff
15:29:10 <jle`> That_Guy: the example i linked to is close to what you mean
15:29:12 <jle`> and yes
15:29:29 <That_Guy> k thanks alot jle, I'll give it a shot :)
15:30:02 <sproingie> oh you just create instances of TypeError for whatever you want to reject?
15:30:53 <sproingie> that's ... pretty much the same as c++'s approach, come to think.  with much less evil syntax.
15:32:39 <sproingie> any way to do arbitrary integer arithmetic at type level?  c++'s constexpr makes that pretty simple.
15:33:35 <jle`> there are a couple of ways you could go about it
15:34:17 <sproingie> i'm reasonably comfortable doing it strictly symbolic though, a la prolog
15:34:32 <sproingie> where it = complex type logic
15:35:01 <sproingie> and i'm told haskell's type system is isomorphish to prolog
15:42:11 <That_Guy> jle`, is there a way to do the type error pre ghc 8.0
15:42:29 <jle`> i'm not sure
15:42:36 <That_Guy> :(
15:42:47 <That_Guy> Is there a way to do any error at all?
15:42:56 <That_Guy> 'error' doesn't work
15:43:04 <sproingie> that's runtime
15:43:11 <That_Guy> yup
15:43:13 <That_Guy> makes sense
15:43:25 <monochrom> The instance system actually. "instance Monoid a => MonadWriter a m" = "MonadWriter(a, m) :- Monoid(a)".
15:44:09 <monochrom> Actually, add a cut there, too. No backtracking after "MonadWriter(a, m)" matches.
15:44:35 <glguy> You can't learn the Monoid instance of a from the fact that there's a MonadWriter(a,m) instance
15:44:38 <monochrom> Also, in reality, MonadWriter also somes with a functional dependency I don't know how to translate to Prolog.
15:45:24 <jle`> That_Guy: well you can have it be a compiler error if you just leave off that branch
15:45:29 <jle`> like monochrom mentioned earlier
15:45:52 * monochrom uses the subtraction method :)
15:46:09 <That_Guy> ok, that I gues will work, thx jle`
15:46:10 <monochrom> To get more compiler errors, simply delete more code. :)
15:46:32 <monochrom> But TypeError is more ergonomic and self-documenting.
15:46:33 <exio4> That_Guy: ("This failed" ~ "") 
15:47:07 <glguy> exio4: That works for generating impossible constraints, at least
15:47:26 <exio4> ("This failed" ~ "") => () :)
15:47:30 <glguy> It doesn't help to make an impossible case in a type family like this though
15:48:04 <exio4> I guess so, I haven't played much with type families :P
15:48:51 <That_Guy> typefamilies seem to be very powerful, I need to find the time to really learn about them
15:49:02 <That_Guy> though I think for now I can achieve what I need :)
15:54:37 <That_Guy> Hmm so I am getting any error, I think I am using the type families wrong. http://lpaste.net/354891
15:54:51 <That_Guy> complains o1 is applied to too many type arguments
15:56:02 <glguy> That_Guy: XOR o1 o2
15:56:05 <glguy> it's like any other type
15:56:21 <That_Guy> ahh
15:56:23 <That_Guy> thx!
15:56:44 <glguy> or turn on TypeOperators and   o1 `XOR` o2
15:56:52 <That_Guy> yes, just found that :)
16:05:28 <kamyar> Hello fellows
16:05:42 <kamyar> Please help me understand this Haskell code: https://gist.github.com/Fristi/7327904
16:06:00 <kamyar> Lines 21 to 23
16:07:06 <geekosaur> those are associated data families https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#associated-data-and-type-families
16:08:30 <Molosse> yo
16:10:11 <kamyar> geekosaur: What that means?
16:10:49 <kamyar> * -> *
16:10:57 <kamyar> DOes it mean anything to anything?
16:11:14 <sproingie> it means a type to a type
16:11:36 <sproingie> which means it's a type with one arg.  usually a functor
16:12:17 <sproingie> or a function (which is also a functor)
16:12:31 <glguy> Kinds: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-640004.1.1
16:12:51 <jle`> in modern times we might have written it as 'Type -> Type'
16:13:11 <jle`> so things like IO, Maybe, Either Int, etc.
16:13:25 * glguy isn't ready to give up on * yet
16:13:45 <jle`> i've already made the switch since * doesn't work when you have TypeInTyoe on :'(
16:14:11 <geekosaur> kamyar, * represents a "normal" type, one which has values
16:14:20 <jle`> oh wait it does work
16:14:32 <geekosaur> jle`, I think you just have to import it?
16:14:38 <kamyar> geekosaur: What is an anormal type then?
16:14:47 <jle`> yeah, it works
16:14:47 <geekosaur> :k Maybe
16:14:48 <lambdabot> * -> *
16:14:54 <jle`> i guess my main problem is that it is a special-case syntax
16:15:05 <kamyar> geekosaur: Ok thnx
16:15:05 <geekosaur> you can;t have things of type "Maybe", but you can have things of type "Maybe Int" or ...
16:15:31 <jle`> *'s characters suggest it is an operator, but it's not
16:15:34 <kamyar> geekosaur: It means concrete type
16:15:37 <jle`> so the syntax has to be special-cased
16:15:46 <jle`> kamyar: 'concrete type' isn't a term we like to use, since it's ambiguous
16:15:58 <jle`> there are many different definitions of concrete type
16:16:49 <kamyar> jle`: That means a type with no partial or generci-like parts
16:17:01 <geekosaur> ...
16:17:11 <sproingie> Maybe Int vs Maybe a?
16:17:12 <kamyar> geekosaur: So for example 'Just 5' can not be used there
16:17:21 <geekosaur> huh?
16:18:36 <Tuplanolla> :t concrete
16:18:38 <lambdabot> Reinforced
16:18:50 <sproingie> heh
16:19:21 <sproingie> :kind weed
16:19:38 <jle`> they left
16:33:50 <manek> Hello! Is there anything in haskell that is similar to Enum, but just allows me to assign ascending numbers to constructors, that could not be nullary
16:33:52 <manek> ? :)
16:34:33 <thang1> what sort of thing would you use that for?
16:34:45 <sproingie> Numbers?  as in aliases for ints?  that's not what Enum is in haskell.
16:35:22 <manek> thang1: just for implementing Ord class in Lexer
16:36:08 <manek> sproingie: I know, I've written, something similar to enum :) Maybe it was to simplified, sorry for the confusion. I just want, having a value of a specific onstructor, get it number 
16:37:23 <jle`> you can achieve something similar with generics
16:37:39 <Tuplanolla> Can you not derive `Enum` and use `fromInteger` and `toInteger`, manek?
16:37:58 <jle`> data types with non-nullary constructors can't derive Enum
16:38:00 <geekosaur> I think they want this for a non-nullary constructor?
16:38:02 <geekosaur> so no, Enum not derivable
16:38:22 <geekosaur> but Ord *should* be derivable. so, why is it not being derived?
16:39:28 <jle`> yes you can probably implement this using GHC.Generics
16:39:29 <MonadHendrix> quick way to check if a list of Maybe Ints has any nothings in it?
16:39:53 <sproingie> toEnum/fromEnum seems as close as it gets, but yeah only nullary constructors need apply
16:39:58 <jle`> MonadHendrix: null . catMaybes ?
16:40:17 <geekosaur> that sounds like any non-nothings
16:40:25 <manek> geekosaur: Ord is derivable, but it's not a valid Ord then. In fact this is kind-of not a real problem. It is caused by I think unnecesary constraint in megaparsec, which tells that every token has to be Ord'able. In fact everything works even if you define Ord without implementation. I asked the question out of curiosity - if it is just possible in any standard way
16:40:31 <manek> without implementing it in generics by myself
16:40:40 <MonadHendrix> jle`: ah yes catMaybes is what ive been looking for
16:40:42 <MonadHendrix> cheers
16:40:45 <ChaiTRex> MonadHendrix: not . null . dropWhile isJust or something like that
16:41:10 <geekosaur> :t any . isNothing
16:41:11 <lambdabot> error:
16:41:11 <lambdabot>     ‚Ä¢ Couldn't match type ‚ÄòBool‚Äô with ‚Äòa -> Bool‚Äô
16:41:11 <lambdabot>       Expected type: Maybe a1 -> a -> Bool
16:41:20 <Sornaensis> :t any isNothing
16:41:21 <lambdabot> Foldable t => t (Maybe a) -> Bool
16:41:23 <geekosaur> yeh
16:41:25 <Tuplanolla> Sounds like a job for `asum`.
16:41:42 <Sornaensis> :t asum
16:41:43 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
16:41:53 <ChaiTRex> Yeah, any isNothing is nice :)
16:41:58 <jle`> asum might potentially do too much work
16:41:59 <sproingie> meh.  generalization is general
16:42:14 <jle`> > isJust . asum $ repeat Nothing
16:42:14 <Sornaensis> generalization makes me blush'
16:42:19 <lambdabot>  mueval-core: Time limit exceeded
16:42:24 <jle`> > isJust . asum $ repeat (Just ())
16:42:26 <lambdabot>  True
16:42:36 <jle`> > isNothing . asum $ repeat (Just ())
16:42:38 <lambdabot>  False
16:42:59 <jle`> asum would do too much work since it has to check after the first Nothing it encounters
16:43:10 <jle`> actually i'm not sure it could even be used to detect if there are any nothings
16:43:15 <jle`> it wouldn't be asum...it'd be sequence
16:43:22 <jle`> > isJust . sequence $ repeat Nothing
16:43:24 <lambdabot>  False
16:43:32 <jle`> > isNothing . sequence $ repeat Nothing
16:43:34 <lambdabot>  True
16:43:46 <jle`> sequence should stop at the first Nothing
16:43:50 <jle`> er, but use sequence_
16:43:51 <MonadHendrix> > length $ catMaybes [Just 5, Just 6] == 2
16:43:52 <lambdabot>  error:
16:43:53 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[a1]‚Äô with actual type ‚ÄòBool‚Äô
16:43:53 <lambdabot>      ‚Ä¢ In the second argument of ‚Äò($)‚Äô, namely
16:43:58 <Sornaensis> :t sequence_
16:44:00 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
16:44:11 <jle`> > isNothing . sequence_ $ repeat Nothing
16:44:13 <lambdabot>  True
16:45:23 <jle`> sequence is some dual of asum i suppose
16:45:37 <Sornaensis> @src asum
16:45:37 <lambdabot> Source not found. My pet ferret can type better than you!
16:45:41 <Sornaensis> >:{
16:45:45 <jle`> if Just is True, then sequence ~ all, asum ~ any
16:45:49 <Sornaensis> @hoogle asum
16:45:49 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
16:45:49 <lambdabot> Data.Conduit.Combinators asum :: (Monad m, Alternative f) => Consumer (f a) m (f a)
16:45:49 <lambdabot> CorePrelude asum :: (Foldable t, Alternative f) => t (f a) -> f a
16:46:00 <jle`> asum = foldr (<|>) empty
16:46:09 <jle`> it's like mconcat but with <|> instead of <>
16:46:37 <MonadHendrix> > length (catMaybes [Just 4, Just 6]) == 2
16:46:39 <lambdabot>  True
16:46:54 <MonadHendrix> > length (catMaybes [Just 3, Nothing]) == 2
16:46:56 <lambdabot>  False
16:47:07 <MonadHendrix> :t length . catMaybes
16:47:08 <lambdabot> [Maybe a] -> Int
16:48:00 <MonadHendrix> im using it to check if either or both of the two values inputted are Nothing
16:48:40 <MonadHendrix> i could just `case choice of (a == Nothing) || (b == Nothing)
16:49:01 <thang1> Can you not just pattern match it?
16:49:04 <jle`> that doesn't make sense
16:49:16 <jle`> i'm not sure if that's even valid syntax?
16:49:30 <MonadHendrix> me neither but you get the idea
16:49:31 <jle`> if you want to return Nothing if either thing is Nonthing, use *>
16:49:36 <jle`> MonadHendrix: i don't get the idea :(
16:49:41 <jle`> that's why i mentioned it
16:49:46 <jle`> i'm not sure what you're trying to write
16:49:46 <MonadHendrix> ok
16:50:05 <MonadHendrix> user inputs 2 ints, using `readMaybe <$> getLine` each time
16:50:06 <jle`> if you want to return Nothing if either thing is Nothing, you can use (*>)
16:50:16 <MonadHendrix> i want to exit if either are Nothing
16:50:16 <jle`> :t \x y -> isNothing (x *> y)
16:50:17 <lambdabot> Maybe a1 -> Maybe a -> Bool
16:51:22 <thang1> MonadHendrix: a lot of haskell is designed around handling errors gracefully and robustly. Why do you want to blow everything up if the user messes up?
16:52:08 <MonadHendrix> thang1: when i say quit, i of course mean restart the program ;)
16:52:28 <MonadHendrix> the point is detecting if either of the inputs are nothing
16:52:32 <jle`> if you actually want to *use* the things inside the results, you can use fmap or applicative combinators or do notation
16:55:01 <MonadHendrix> hmm, i could just `(+) <$> a <*> b` then check if its Nothing on its own after
16:55:36 <jle`> mhm, thats the beauty of the applicative abstraction :)
16:55:45 <Welkin> :t fmap <$> fmap <*> fmap
16:55:46 <lambdabot> Functor f => (b -> b) -> f b -> f b
16:55:52 <MonadHendrix> > isNothing $ (+) <$> Just 3 <*> Just 5
16:55:54 <lambdabot>  False
16:56:18 <MonadHendrix> > isNothing $ (+) <$> Just 4 <*> Nothing
16:56:20 <Welkin> (fmap <$> fmap <*> fmap) id (Just 3)
16:56:20 <lambdabot>  True
16:56:23 <Welkin> ? (fmap <$> fmap <*> fmap) id (Just 3)
16:56:26 <Welkin> > (fmap <$> fmap <*> fmap) id (Just 3)
16:56:28 <lambdabot>  Just 3
16:56:33 <Welkin> lol
16:56:49 <Welkin> > (fmap <$> fmap <*> fmap) (+1) (Just 3)
16:56:51 <lambdabot>  Just 5
16:56:58 <Welkin> hahaha
16:57:03 <MonadHendrix> got it, cheers for letting me bounce my head off you
16:57:24 <Welkin> I created a monster
16:57:26 <thang1> > (fmap <$> fmap <*> fmap) (+1) id id id id id id id id id id (Just 3)
16:57:29 <lambdabot>  error:
16:57:29 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M885504224118...
16:57:29 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
16:57:32 <thang1> ;-;
16:57:40 <jle`> no problem!
16:57:43 * MonadHendrix goes off to scrub up on Applicative
16:57:59 <Tuplanolla> :t fmap <$> fmap <*> fmap
16:58:00 <lambdabot> Functor f => (b -> b) -> f b -> f b
16:58:13 <Tuplanolla> That's... great.
16:59:00 <Welkin> I often find very interesting functions by typing ins random things
17:00:58 <Tuplanolla> :t let fap = fmap fmap fmap in ap fap fmap -- I prefer this form though.
17:00:59 <lambdabot> Functor f => (b -> b) -> f b -> f b
17:01:24 <Tuplanolla> It rolls right off the tongue.
17:02:53 <Welkin> : flip const fmap
17:02:56 <Welkin> :t flip const fmap
17:02:57 <lambdabot> error:
17:02:57 <lambdabot>     ‚Ä¢ Ambiguous type variable ‚Äòf0‚Äô arising from a use of ‚Äòfmap‚Äô
17:02:57 <lambdabot>       prevents the constraint ‚Äò(Functor f0)‚Äô from being solved.
17:03:17 <Welkin> o.o
17:03:36 <Welkin> :t fmap (flip const)
17:03:37 <lambdabot> Functor f => f b -> f (c -> c)
17:03:50 <thang1> :t fmap $ flip const
17:03:52 <lambdabot> Functor f => f b -> f (c -> c)
17:04:00 <Welkin> :t fmap (flip const . (+1))
17:04:01 <lambdabot> (Num b, Functor f) => f b -> f (c -> c)
17:04:14 <thang1> :t fmap . flip const
17:04:16 <lambdabot> Functor f => b1 -> f b -> f b
17:12:38 <MonadHendrix> > Just (3 / 0)
17:12:40 <lambdabot>  Just Infinity
17:12:44 <MonadHendrix> heh
17:13:50 <thang1> > Just (-3 / 0)
17:13:52 <lambdabot>  Just (-Infinity)
17:14:02 <thang1> neat. Do we have NaN too?
17:14:17 <thang1> Just (0 / -0)
17:14:23 <thang1> > Just (0 / -0)
17:14:26 <lambdabot>  error:
17:14:26 <lambdabot>      Precedence parsing error
17:14:26 <lambdabot>          cannot mix ‚Äò/‚Äô [infixl 7] and prefix `-' [infixl 6] in the same infi...
17:14:38 <ExpHP> ba dum tish
17:14:39 <MonadHendrix> > Just (0 / (-0))
17:14:41 <lambdabot>  Just NaN
17:15:07 <thang1> Haskell is great
17:15:20 <Welkin> for great good
17:15:32 <thang1> Now I got a particular question I'm just curious about
17:15:55 <thang1> If I write a function "extend" which takes one string and repeats it over and over to the length of a second string
17:16:07 <Welkin> :t extend
17:16:08 <lambdabot> error: Variable not in scope: extend
17:16:17 <Welkin> :t Control.Comonad.extend
17:16:18 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
17:16:21 <Welkin> :D
17:16:27 <thang1> eg: "lmao" and "this is war!" -> "lmaolmaolmao"
17:16:37 <glguy> :t zipWith const . cycle
17:16:38 <lambdabot> [c] -> [b] -> [c]
17:16:44 <thang1> Yeah, I know that part
17:16:52 <thang1> (which I'm mostly familiar with how that works)
17:17:07 <thang1> But if I want it to be -> "lmao lm aolm"
17:17:10 <thang1> how do I do that?
17:17:32 <Welkin> check for spaces
17:17:36 <Welkin> and keep them
17:17:39 <thang1> I ended up writing a 4 line go function
17:17:59 <Welkin> you can fold over the first string cycled infinitely
17:18:15 <thang1> I know you check for spaces and keep them, I was just wondering if I can avoid going from a very concise and elegant "zipWith const . cycle" -> 4 line recursive go function
17:18:16 <Welkin> > cycle "habari"
17:18:18 <lambdabot>  "habarihabarihabarihabarihabarihabarihabarihabarihabarihabarihabarihabarihab...
17:19:14 <Welkin> you can write a fold
17:19:20 <glguy> first thought:
17:19:21 <glguy> > set (partsOf (traverse . filtered (not . isSpace))) (cycle "lmao") "this is war"
17:19:23 <lambdabot>  "lmao lm aol"
17:20:08 <thang1> oooh
17:20:22 <ExpHP> :i partsOf
17:20:29 <ExpHP> :t partsOf --doh
17:20:31 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
17:20:41 <ExpHP> ohdear
17:20:51 <thang1> lol
17:21:11 <thang1> that would explain why that was not my first thought
17:22:23 <Welkin> too much lens
17:22:27 <glguy> > snd $ mapAccumL (\ (x:xs) y -> if y == ' ' then (x:xs,y) else (xs,x)) (cycle "lmao") "this is war"
17:22:29 <lambdabot>  "lmao lm aol"
17:23:02 <Welkin> aol!?!
17:23:16 <thang1> That's the correct output :p
17:25:18 <Welkin> :t mapAccumL
17:25:19 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
17:25:38 <Welkin> kind of a fold
17:26:14 <Welkin> I've never sen mapAccumL used though
17:26:18 <Welkin> seen*
17:27:29 <thang1> I didn't even know it existed
17:27:34 <glguy> > foldr (\x next (y:ys) -> if x == ' ' then x : next (y:ys) else y : next ys) (const "") "this is war" (cycle "lmao")
17:27:35 <lambdabot>  "lmao lm aol"
17:30:02 <thang1> :t next
17:30:04 <lambdabot> RandomGen g => g -> (Int, g)
17:30:13 <thang1> wut
17:31:33 <glguy> > unfoldr (\(xs,y:ys) -> uncons xs <&> \(x,xs') -> if x == ' ' then (x,(xs',y:ys)) else (y,(xs',ys))) ("this is war", cycle "lmao")
17:31:35 <lambdabot>  "lmao lm aol"
17:31:46 <glguy> that about does it
17:32:11 <glguy> thang1: next is locally bound by the anonymous function
17:33:20 <thang1> ooh so it's not actually the random generator function, it's just in the anonymous function. Got it. Got confused there for a second :p
17:35:33 <ExpHP> y u no exist (Control.Monad.<<)
17:35:39 <ExpHP> <* is ugly
17:35:58 <Welkin> flip (>>)
17:35:58 <thang1> :i <&>
17:36:05 <Welkin> even though it's not the same as <*
17:36:13 <ExpHP> i was about to say...
17:36:37 <Welkin> it is similar
17:36:42 <thang1> shouldn't flip (>>) be (<<) ? /s
17:36:44 <Welkin> slightly different
17:37:07 <ExpHP> a >> b and b << a have quite different meanings for parsers
17:37:21 <thang1> (I know, it was a joke about semantic meaning of 'flip' in english)
17:37:39 <glguy> << isn't defined to mean anything, so if it's different or not is up to how you've decided to define <<
17:37:40 <ExpHP> goddamn invisible internet sarcasm tags
17:37:59 <thang1> What are ya talking about? I used /s. That's about as explicit as you can get
17:38:04 <Welkin> glguy: in this case (<<) = flip (>>)
17:39:00 <glguy> Right, but like you mentioned, that's different from (<*)
17:39:51 <ExpHP> this is almost as crazy as 'unless' being defined in Control.Monad
17:40:07 <thang1> :t unless
17:40:08 <lambdabot> Applicative f => Bool -> f () -> f ()
17:40:09 <glguy> which is crazy?
17:40:18 <thang1> why the fuck is that in Control.Monad?
17:40:23 <ExpHP> ^
17:40:32 <glguy> Because Monad is older than Applicative
17:40:41 <ExpHP> history schmistory
17:40:53 <thang1> move fast, break shit, avoid success at all costs
17:41:06 <thang1> "haskell's not really sorta kinda never mindish" motto
17:41:07 <MonadHendrix> shout out to Applicative for letting me do cool things
17:41:23 <Welkin> what about Arrow?
17:41:33 <thang1> I'll understand it eventually... I'm still on chapter 11 of Haskell from first principles
17:41:55 <ExpHP> shout out to Arrow for giving nice functions to use on regular functions
17:42:06 <ExpHP> and the other bit
17:43:01 <thang1> For me the biggest shoutout so far is actually to pattern matching
17:43:19 <MonadHendrix> yeah thats pretty great too
17:43:25 <thang1> being able to just define my different cases for things is amazing. Makes working in another language far uglier and more stupid after you're used to it
17:43:57 <thang1> if (this isn't zero) do stupid shit; if (that isn't wrong) do other stupid shit; while (things aren't fucked up) fuck shit up; if (not enough semicolons) maore semicolons;;;;;;;;;;
17:44:11 <thang1> so dumb. Just let me pattern matchings
17:45:32 <MonadHendrix> sometimes ill go write something small in python because type coersion feels so naughty
17:45:42 <ExpHP> ooh la la
17:46:59 <MonadHendrix> bay area haskell vids just came out, shame the sound is so abysmal
17:47:12 <thang1> Do they have subtitles or any captioning for things?
17:47:27 <thang1> I'm pretty deaf so audio is always abysmal :p
17:47:34 <MonadHendrix> lol
17:49:04 <mzabani> Hi everyone! In Reflex/Reflex-Dom, how can I create a function f :: (a -> [b]) -> Dynamic t a -> [Dynamic t b] ?
17:49:38 <MonadHendrix> my calculator works woo https://ptpb.pw/1n1k/hs
17:50:01 <Lokathor> how do i tell stack to make a new project with a given name in the present working directory?
17:50:11 <Lokathor> "stack new packageName ." doens't seem to work
17:50:14 <MonadHendrix> stack new <name>
17:50:31 <MonadHendrix> no .
17:50:43 <Lokathor> right but that makes it in a subdirectory
17:50:47 <lyxia> stack new --bare
17:51:42 <Lokathor> nice
17:51:44 <lyxia> (you can find it under   stack new --help)
17:51:47 <ExpHP> (cue 15 second wait as everybody tries it out and has to wait for fifteen indices to download)
17:51:52 <MonadHendrix> stack new <name> && mv <name>/* .
17:51:57 <MonadHendrix> :^
17:52:20 <MonadHendrix> smartparens-strict mode wont let me type smileys
17:52:27 <Welkin> ExpHP: or just use nix and you never need to compile libraries again :D
17:52:39 <ExpHP> Welkin: What if they update
17:52:40 <thang1> MonadHendrix: C-q <key>
17:52:51 <Lokathor> or you use windows have have all C library support break every single update :/
17:52:52 <thang1> C-q means "disable everything and let me type what I fucking wanna type"
17:52:58 <MonadHendrix> :^)
17:53:11 <Lokathor> rust looks good compared to haskell just because it has a good windows story :/
17:53:15 <MonadHendrix> nice
17:53:26 <Welkin> Lokathor: they are not meant for the same use case...
17:53:42 <thang1> Lokathor: Rust looks good compared to Haskell because it's designed to be successful as fast as possible and is backed by a lot more money than haskell is
17:53:43 <ExpHP> oh my god it's another gabriel thing
17:53:56 <MonadHendrix> haskell community > rust community
17:54:02 <MonadHendrix> -- True
17:54:10 <thang1> Also it's got 20+ years of experience to draw from in modern language design. Haskell has eons of backwards compatibiility and cruft to work through and fuck around with
17:54:14 <Lokathor> sure, sure, but just make the sdl2 package work on windows :P
17:54:14 <ExpHP> I swear, gabriel, edward kmett and yesod are the only thee people/organizations that write haskell libraries
17:54:32 <Welkin> ExpHP: correction: yesod -> snoyberg
17:54:44 <ExpHP> ah right
17:54:45 <thang1> (read: lists are bad for everything, length shouldn't be foldable, etc...)
17:54:47 <ExpHP> THREE PEOPLE
17:54:54 <Welkin> not really though
17:55:01 <ExpHP> okay wait there's  also the hoogle/Shake guy
17:55:01 <MonadHendrix> most downloaded rust crate is LibC, pretty suspect for a language thats trying to replace it
17:55:02 <thang1> s/PEOPLE/genius overachievers who don't sleep/
17:55:06 <Welkin> take a look at servant and reflex-frp
17:55:11 <Welkin> they are written by other people
17:55:33 <thang1> MonadHendrix: The cannonical way to "replace" C is to incrementally rewrite
17:55:49 <thang1> So the goal is to be able to work with C 100% and then just replace single things as you go.
17:55:51 <Lokathor> MonadHendrix, naw, gotta bootstrap somehow
17:56:01 <MonadHendrix> thang1: https://i.imgur.com/c111qqp.jpg
17:56:29 <thang1> That was basically my entire exchange with glguy, MonadHendrix lol
17:58:09 <MonadHendrix> my favourite thing about haskell is being able to refactor anything to unreadably terse
17:58:26 <MonadHendrix> the Monad Reader had a really good example
17:58:30 <ExpHP> MonadHendrix: I do this without even thinking
17:58:57 <MonadHendrix> also the random custom ascii operators 
17:58:59 <ExpHP> next thing I know I wake up with something like  ((f .) . g <$>)
17:59:05 <MonadHendrix> those are great
17:59:18 <sproingie> yeah the ascii infix operators i am not fond of
17:59:35 <MonadHendrix> reverse = foldl (flip (:)) []
17:59:40 <thang1> One of my bigger pet peeves with haskell is some of the really basic stuff
17:59:54 <MonadHendrix> parsing input
17:59:56 <thang1> : shouldn't be for lists, : should be for types. Goddamnit, Haskell
17:59:59 <sproingie> MonadHendrix: that's actually quite obvious and concise even to me
18:00:07 <Welkin> thang1: haskell is like perl in that you can write it however you want
18:00:09 <MonadHendrix> https://wiki.haskell.org/wikiupload/9/9d/TMR-Issue1.pdf
18:00:11 <MonadHendrix> page 6
18:00:14 <thang1> f : Int -> Int, not f :: Int -> Int
18:00:15 <Welkin> you can write it to be unreadable if you want
18:00:17 <sproingie> and i'm hardly one to go for obfuscated haskell
18:00:23 <Welkin> you can also write it to be very easy to read
18:00:33 <sproingie> TMTOWTDI
18:00:48 <MonadHendrix> `if it compiles, its right`
18:00:53 <MonadHendrix> tru
18:00:58 <sproingie> FSVO "right"
18:01:13 <thang1> hahaha that's funny, Welkin, because that's literally what happened on a particular StackOverflow question
18:01:21 <ExpHP> I'm hardly ever trying to go for obfuscated, I'm just trying to eliminate variables whose names I could potentially mix up
18:01:22 <sproingie> if it compiles, you probably translated the idea right.  your idea might still be dead wrong.
18:01:34 <Welkin> thang1: http://www.willamette.edu/~fruehr/haskell/evolution.html
18:01:37 <Welkin> related
18:01:44 <MonadHendrix> lol
18:01:54 <thang1> length :: [a] -> Int; length = 4 -- My favorite number
18:02:11 <Lokathor> I want an API that I can understand that also runs as fast as possible under the hood
18:02:29 <thang1> aka aggressive and insane rewriting rules :p
18:02:45 <c_wraith> thang1, I disagree solely for reasons of improved lexical uniformity. making (:) a constructor means infix constructors all starting with : is a less jarring rule. 
18:03:09 <Lokathor> thang1, you mean "length _ = 4" perhaps :3
18:03:26 <MonadHendrix> _ = 4
18:03:28 <thang1> eh, it gets the point across
18:03:43 <sproingie> shame about other infix operators.  lens-heavy code looks like APL to me
18:03:54 <thang1> APL is more readable because it's unicode
18:03:56 <Welkin> sproingie: all lens functions have named versions
18:04:00 <thang1> goddamn I love the idea of APL. I need to learn it
18:04:18 <MonadHendrix> dont you need a special keyboard for that
18:04:40 <sproingie> J and K have the ideas of APL but use ascii
18:05:09 <thang1> No, APL always worked with a normal keyboard
18:05:22 <sproingie> just a different input method
18:05:25 <thang1> The special keyboard had the symbols on the letters
18:05:51 <thang1> so the 'j' key was like (+) or something but you didn't need a special keyboard 
18:06:26 <thang1> sproingie: I really like the non-ascii part of APL though. Otherwise what's the point? The meaning's in the symbols and notation. That's why math notation is so powerful
18:06:32 <biglambda> Is there any way to see how memory has been allocated by malloc. I‚Äôm getting weird memory errors with some FFI code. Errors appear inconsistently.
18:06:46 <sproingie> thang1: there's a little more to it than notation
18:06:48 <MonadHendrix> space cadet keyboards had all those symbols
18:07:12 <sproingie> but yeah, the unicode symbol set does make it terse
18:07:27 <sproingie> well, wasn't really unicode at the time
18:08:52 <MonadHendrix> btw that static haskell programmer one where he does it all with the types is pretty amazing
18:09:08 <thang1> The "typing the tech interview"?
18:09:24 <thang1> or just the idea of brutally abusing the haskell type system to do depndent types in general?
18:10:23 <MonadHendrix> thang1: in the evolution of a haskell programmer page
18:10:31 <MonadHendrix> http://www.willamette.edu/~fruehr/haskell/evolution.html
18:10:40 <MonadHendrix> scroll down to "Static Haskell Programmer"
18:10:41 <thang1> oh right, that
18:10:50 <thang1> You'd like the "typing the tech interview" article then
18:11:01 <thang1> https://aphyr.com/posts/342-typing-the-technical-interview
18:11:04 <thang1> The entire series is great
18:12:31 <MonadHendrix> lol wtf am i reading
18:13:19 <sproingie> yeah that's aphyr for ya
18:13:20 <thang1> Keep going, it gets better
18:13:32 <sproingie> read his call-me-maybe series for more goofy goodness
18:13:55 <thang1> c_wraith: I still like : for types because it's more consistent with mathematical notation. :: for lists is just fine imo
18:14:19 <MonadHendrix> aph<tab> -> No match
18:14:21 <MonadHendrix> :()
18:14:24 <MonadHendrix> uh
18:14:28 <MonadHendrix> :(
18:15:45 <MonadHendrix> "‚ÄúYou could do that,‚Äù you concur, but, so quietly he cannot hear you, continue to believe the exact opposite."
18:15:52 <MonadHendrix> brilliant
18:16:02 * MonadHendrix goes off to read
18:16:03 <thang1> sproingie: where's his call-me-maybe series?
18:16:20 <sproingie> https://aphyr.com/tags/jepsen
18:16:30 <sproingie> it's sorted most recent first, so it starts at the bottom right
18:16:41 <thang1> So just read all of them?
18:16:58 <sproingie> basically it's a deep dive into distributed databases and the CAP theorem
18:17:09 <ExpHP> (aside) huh, so there literally IS an M-x irc command...
18:17:13 <thang1> I also wish we could get rid of the grip that ascii and stupid shit like that has on writing things with keyboards
18:17:22 <sproingie> ExpHP: oh there are several irc clients for emacs
18:17:28 <thang1> ExpHP: Didn't someone make a M-x butterfly as well?
18:17:33 <MonadHendrix> so: ah
18:17:49 <thang1> There's also several differnt terminals, several different games, a few web browsers, some reddit clients, ...
18:18:11 <ExpHP> there's probably a port of wine
18:18:23 <Welkin> use a cangjie keyboard :D
18:18:42 <thang1> Welkin: hah, funny. Not quite what I meant :p
18:19:03 <thang1> I meant more like how we can't type \forall and other symbols nicely so everyone's scared to use math notation in programming languages even when it makes it more readable
18:19:10 <sproingie> hell there's a whole emacs power-user subculture of org-mode.el users
18:19:18 <Welkin> you can have your text editor do it for you
18:19:25 <Welkin> that's how people write agda/coq
18:19:37 <sproingie> i never did take a shine to org-mode, but my brain has stubbornly resisted all attempts to impose organization
18:19:52 * EmacsHP fiddles around trying to figure out how to get back to his code...
18:19:54 <thang1> Well sure, but that doesn't change the fact that needing the text editor to cope for a shitty keyboard means most languages aren't ever going to support unicode n shit
18:20:01 <sproingie> oh yeah, agda uses emacs ... i thought coq had its own editor?
18:20:13 <EmacsHP> evil is in some weird light blue state right now. Never seen that before...
18:20:26 <thang1> I like Agda a lot and wish notation like that was more accepted and easier to use in mainstream languages
18:20:34 <sproingie> thang1: most languages that matter already support unicode
18:21:09 <sproingie> hell even c++ is dragging itself toward realizing that wchar_t is crap
18:21:28 <thang1> Not quite what I meant :p
18:21:29 <Welkin> javascript supports unicode even o.o
18:21:50 <jordan_> hi
18:21:51 <thang1> If I write ¬¨ instead of not, it won't compile in the vast majority of languages
18:22:03 <sproingie> sure, because those languages have hardwired operator sets
18:22:08 <thang1> even if it did, nobody would ever accept code in a codebase using ¬¨ instead of not
18:22:21 <ExpHP> #DEFINE BEGIN {
18:22:23 <thang1> Just try and get ¬¨ into any codebase for Haskell. Not gonna happen :p
18:22:35 <sproingie> hell i suspect even Haskell98 wouldn't let you use ¬¨ the way you want
18:22:38 <sproingie> (ghc probably)
18:22:39 <geekosaur> who invited Steve Bourne into the channel? :p
18:22:41 <thang1> #DEFINE END ) /* pure evil */
18:23:08 <MonadHendrix> in the 1st edition of that graham hutton book all his source had fancy symbols
18:23:22 <MonadHendrix> was quite hard to read tbh
18:23:38 <sproingie> as it is, input methods in OS's are so horribly anemic, i had to copy/paste ¬¨ using the mouse just to type it
18:23:59 <thang1> hah, same. I can use the compose key, but I need to program it in
18:24:03 <sproingie> so the unicode source problem ain't getting solved til input methods become at all freakin decent
18:24:05 <thang1> ‡≤†_‡≤† <-- written with compose key
18:24:05 <MonadHendrix> uk keyboard has it on S-`
18:24:14 <thang1>  ¬Ø\_(„ÉÑ)_/¬Ø
18:24:33 <thang1> sproingie: which was my original gripe. Input sucks balls
18:24:48 <sproingie> languages aren't gonna get hip to unicode til input methods do
18:24:51 <Welkin> you haven't even mentioned multi-language input
18:24:52 <Welkin> IME
18:24:52 <MonadHendrix> thanks for reminding me i havent set a fallback font for meme unicode
18:25:02 <Welkin> writing in russian is the worst
18:25:02 <thang1> ( Õ°¬∞ Õú ñ Õ°¬∞) orly?
18:25:10 <MonadHendrix> ‚ò≠
18:25:14 <Welkin> japanese and chinese are at least usable because of romaji and pinyin
18:25:30 <Welkin> for russian you need a russian keyboard (or stickers)
18:25:31 <MonadHendrix> <compose> C C C P gives ‚ò≠
18:25:34 <thang1> Isn't the japanese writing system fucked up beyond all repair?
18:25:41 <ExpHP> why are we all talking about leopards all of a sudden
18:25:42 <Welkin> thang1: no....
18:26:00 <sproingie> katakana makes good emoji tho ¬Ø\_(„ÉÑ)_/¬Ø
18:26:02 <thang1> s/fubar/extremely complicated/
18:29:02 <ExpHP> it feels like I'm doing something silly when I write  "a >=> pure .  b" but I'm not sure what
18:29:10 <ExpHP> :t \a b -> a >=> pure . b
18:29:12 <lambdabot> Monad m => (a1 -> m a) -> (a -> c) -> a1 -> m c
18:30:21 <ExpHP> @djinn Monad m => (a1 -> m a) -> (a -> c) -> a1 -> m c
18:30:21 <lambdabot> -- f cannot be realized.
18:30:50 <ExpHP> the all-knowing
18:30:55 <thang1> is it something to do with your a1 vs a?
18:31:09 <c_wraith> djinn doesn't know about monads. 
18:31:26 <thang1> http://stackoverflow.com/questions/28134149/why-does-djinn-fail-to-realize-common-monadic-functions 
18:31:39 <ExpHP> oh oh
18:32:01 <ExpHP> I think I'm basically doing 'fmap (fmap f)', but flipped
18:32:50 <geekosaur> :exf "Monad m => (a1 -> m a) -> (a -> c) -> a1 -> m c"
18:32:51 <exferenceBot> \ f1 f2 -> fmap f2 . f1
18:32:56 <ExpHP> ...eh. sometimes this arises from me initially thinking I need >>=, so I already have things written in that order and it's a nuisance to flip...
18:33:13 <thang1> What does exf do?
18:33:15 <ExpHP> geekosaur :o
18:33:51 <geekosaur> https://github.com/lspitzner/exference
18:33:58 <geekosaur> djinn on steroids
18:34:07 <thang1> nice. Just googled that after realizing it's probably common knowledge to nerds
18:34:17 <geekosaur> handles recursive types, handles typeclasses like Monad, etc.
18:34:24 <thang1> neat
18:34:46 <Welkin> so exf puts us all out of a job?
18:35:10 <Welkin> :exf a -> [a] -> [a]
18:35:11 <exferenceBot> parse error: more than one input
18:35:17 <Welkin> :exf "a -> [a] -> [a]"
18:35:18 <exferenceBot> (:)
18:35:35 <rotaerk> thang1, that "typing the technical interview" is one of the most absurd haskell things I've ready :P
18:35:38 <ExpHP> :exf "forall a. a"
18:35:44 <ExpHP> uh oh
18:35:44 <rotaerk> read *
18:35:47 <geekosaur> exference also lets you have flags for that lookup, so if the type looks too much like it has a flag in it you need to qyote
18:36:04 <ExpHP> > are you okay lambdabot
18:36:05 <exferenceBot> could not find expression
18:36:06 <lambdabot>  error:
18:36:06 <lambdabot>      ‚Ä¢ Variable not in scope: are :: t0 -> t1 -> t2 -> t
18:36:06 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
18:36:09 <geekosaur> it'll time out eventually
18:36:21 <geekosaur> also LB and exferenceBot are two different things
18:36:24 <ExpHP> holy crap I didn't even notice the second bot
18:37:25 <Welkin> :exf "forall a. a"
18:37:30 <Welkin> :exf "forall a. a -> b"
18:37:36 <Welkin> :exf "forall a. a -> a"
18:37:37 <Welkin> o.o
18:37:39 <exferenceBot> id
18:37:42 <Welkin> lol
18:37:57 <Welkin> it ignores you if it can't answer
18:38:08 <exferenceBot> could not find expression
18:38:08 <thang1> so it only answered the last one
18:38:12 <exferenceBot> could not find expression
18:38:14 <thang1> oh nvm
18:38:16 <Welkin> haha
18:38:28 <Welkin> is it looking these up somewhere?
18:38:36 <Welkin> that's cheating D:<
18:38:39 <thang1> anyway I'm gonna get off. I have to drive back home and then get started on some boring java homework
18:38:58 <Welkin> thang1: driving back to 1999?
18:38:59 <thang1> Welkin: it's like Djinn so I assume it's using formal logic to walk backwards from a type to implementation
18:39:03 <geekosaur> ^
18:39:07 * ExpHP invents stackOverflowBot
18:39:19 * thang1 invents StackSort algorithm
18:39:30 <ExpHP> :sob how do I sort a list
18:39:31 <thang1> https://gkoberger.github.io/stacksort/
18:39:32 <geekosaur> but because it supports typeclasses, it can get lost in the weeds and eventually time out
18:39:33 <MonadHendrix> > bot names in camelcase
18:39:35 <lambdabot>  <hint>:1:11: error: parse error on input ‚Äòin‚Äô
18:40:29 <ExpHP> :exf "Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]"
18:40:29 <exferenceBot> <<exception: no support for FunCon>>
18:40:44 <ExpHP> :exf "Functor f => Traversing (:) f s t a a -> LensLike f s t [a] [a]"
18:41:08 <exferenceBot> could not find expression
18:41:16 <jer1> q
18:41:24 <ExpHP> :exf "(:)"
18:41:41 <ExpHP> what on earth is that
18:41:47 <exferenceBot> could not find expression
18:42:16 <peddie> :exf Monad m => (b -> m a) -> (a -> c) -> b -> m c
18:42:16 <exferenceBot> \ f1 f2 -> fmap f2 . f1
18:42:24 <thang1> Anywya, Welkin, nah my professor just loves Java and insists our "messenger app" (cough irc clone cough) be written in it for our term project
18:42:37 <thang1> I'm gonna use Java 8 so it's less terrible than it could be...
18:42:50 <MonadHendrix> >java
18:42:58 <thang1> yay University
18:43:02 <sproingie> one guess as to which single language the prof knows
18:43:18 <thang1> Oh he knows C++ too, that's why he likes Java so much
18:43:30 <MonadHendrix> OO is like wading through dog poo
18:43:42 <dyreshark> you should limit messages on this messaging app to ~100 characters. this way, you won't be able to discuss class naming over it.
18:43:58 <thang1> nvm I meant C. He's was a professor during the 90s "omg C++ is jesus" phase so he missed that
18:44:02 <sproingie> OO has plenty of things good about it when done right
18:44:11 <MonadHendrix> dyreshark: lol
18:44:24 <thang1> "when it's done right" yeah that's the problem
18:44:47 <thang1> good paradigms make it easier to write good code. Bad paradigms require shooting yourself in the nuts to write good code
18:44:51 <sproingie> it hasn't really solidified as a formal discipline yet
18:45:10 <thang1> OOP or programming? Because both are pretty fresh and wild still
18:45:28 <sproingie> OOP.  scala's been doing some work on that.  and yeah programming in general
18:45:31 <thang1> Although, fair warning, I'm more in the Dijkstra camp of things.
18:45:55 <thang1> I always liked Erlang's version of OOP the most
18:46:14 <MonadHendrix> record syntax is enough OO for me
18:46:39 <sproingie> record syntax that doesn't make me stabby is enough for me too
18:46:57 <c_wraith> I've come to consider Haskell's approach to OOP to be as much as I need for problems I've encountered. 
18:47:04 <thang1> s t a b  a l l  t h e  t h i n g s
18:47:21 <MonadHendrix> typeclasses are sort of inheritance in reverse
18:47:28 <thang1> typeclasses are amazing. Learning about them really made me realize that I only ever want inheritence and composition when talking about types
18:48:01 <thang1> Subsequently all of my java programs have been written with all my classes being considered a type mentally in my head. It's helped a lot even though my teacher almost marked me off for not having enough inheritance
18:48:11 <c_wraith> Haskell OOP has nothing to do with type classes, though. 
18:48:26 <thang1> what's Haskell OOP then? Lenses?
18:49:22 <thang1> Now one style of OOP that I /really/ like is Rust's way of thinking about it
18:49:51 <c_wraith> the problem I find myself seeking to solve is "I need lots of values with different behavior and the same type". the solution is a record of functions. 
18:49:53 <Lokathor> rust's style isn't OOP >_>
18:49:56 <thang1> (which is basically Haskell's). That is, you have traits ("interfaces") and implementations ("instances" in haskell or "X implements Y" in Java)
18:50:17 <thang1> Lokathor: exactly. It's what OOP should be :p
18:50:19 <Lokathor> http://lpaste.net/354899 is there some fancy haskell way to make these expressions more concise?
18:50:49 <Lokathor> (besides just taking out the newlines :P )
18:51:07 <sproingie> meh, it's 7 lines, that's pretty concise to me
18:51:11 * MonadHendrix waits for someone to pipe in with an unreadable one line answer
18:51:13 <c_wraith> Lokathor, nothing that will make it better. 
18:51:15 <thang1> s/gen/g  s/newGen/ng/ ...
18:51:34 <Lokathor> sproingie, yes i was mostly wondering what the unreadable oneliner version would look like
18:52:19 <MonadHendrix> substitute in some silly ascii symbols for sure
18:52:27 <c_wraith> :t runState
18:52:29 <lambdabot> State s a -> s -> (a, s)
18:52:29 <thang1> and some type aliases too
18:52:50 <sproingie> type-level befunge
18:52:50 <thang1> mkPCGen? That's 7 letters when it could just be 1-2
18:53:09 <thang1> Just tell people to read the types in the documentation; it'll suddenly become clear /s
18:55:01 <c_wraith> :t runState $ state random -- Lokathor, you wanted dumb? 
18:55:02 <lambdabot> (RandomGen s, Random a) => s -> (a, s)
18:55:40 <Lokathor> heh
18:56:00 <c_wraith> Lokathor, you can throw an fmap and join in to make it a one-liner
18:56:41 <c_wraith> something like.. 
18:57:27 <c_wraith> runState . fmap (join mkPCGen) . state $ random
18:57:43 <c_wraith> not tested, not better. :) 
18:58:18 <thang1> What are you talking about? That's one line. It's at least 75% more beautiful /s
18:58:31 <thang1> anyway I'm off for reals now
18:58:59 <ExpHP> you cannot escape #haskell
19:00:13 <benzrf> :t mkPCGen
19:00:14 <lambdabot> error: Variable not in scope: mkPCGen
19:03:26 <roboguy`_> :t first (join _) . random
19:03:28 <lambdabot> error:
19:03:28 <lambdabot>     ‚Ä¢ Found hole: _ :: a0 -> a0 -> c
19:03:28 <lambdabot>       Where: ‚Äòc‚Äô is a rigid type variable bound by
19:03:55 <benzrf> :]
19:04:48 <c_wraith> I mean.. it's shorter, if you don't count the import. 
19:05:05 <c_wraith> *imports 
19:05:25 <ExpHP> quick! Convert an integer 23 into a padded 3-digit string "023"!
19:05:49 <c_wraith> f 23 = "023"
19:05:52 <c_wraith> bam!
19:05:58 <ExpHP> 0 points
19:06:10 <MonadHendrix> > "0" : (show 23)
19:06:12 <lambdabot>  error:
19:06:12 <lambdabot>      ‚Ä¢ Couldn't match type ‚ÄòChar‚Äô with ‚Äò[Char]‚Äô
19:06:13 <lambdabot>        Expected type: [[Char]]
19:06:24 <MonadHendrix> dam
19:06:49 <c_wraith> ExpHP, I don't see the problem. I implemented the specification exactly. 
19:06:55 <MonadHendrix> > '0' : (show 23)
19:06:57 <lambdabot>  "023"
19:07:00 <MonadHendrix> ayy
19:07:16 <ExpHP> c_wraith: the specification was buggy, apparently there are other numbers less than 1000 as well
19:07:28 <ExpHP> in fact there are 998 of them. who knew
19:07:39 <c_wraith> whoever wrote that spec should be fired. 
19:07:39 <MonadHendrix> there are more than that
19:07:43 <roboguy`_> there are even a few more than that!
19:07:45 <MonadHendrix> infinitely many
19:07:50 <ExpHP> nonnegative integers*
19:08:06 <MonadHendrix> 999 then
19:08:08 <ExpHP> shoot
19:08:27 * ExpHP is fired
19:09:38 <ExpHP> hmmm
19:09:50 <ExpHP> :t reverse . take 3 .  (: cycle '0') . reverse . show
19:09:52 <lambdabot> error:
19:09:52 <lambdabot>     ‚Ä¢ Couldn't match expected type ‚Äò[[Char]]‚Äô with actual type ‚ÄòChar‚Äô
19:09:52 <lambdabot>     ‚Ä¢ In the first argument of ‚Äòcycle‚Äô, namely ‚Äò'0'‚Äô
19:10:00 <ExpHP> :t reverse . take 3 .  (: repeat '0') . reverse . show
19:10:01 <lambdabot> error:
19:10:02 <lambdabot>     ‚Ä¢ Couldn't match type ‚Äò[Char]‚Äô with ‚ÄòChar‚Äô
19:10:02 <lambdabot>       Expected type: a -> Char
19:10:18 <ExpHP> :t reverse . take 3 .  (++ repeat '0') . reverse . show
19:10:19 <lambdabot> Show a => a -> [Char]
19:10:21 <MonadHendrix> : and , in strange places always makes me suspicious
19:10:28 <ExpHP> :t (reverse . take 3 .  (++ repeat '0') . reverse . show) 23
19:10:29 <lambdabot> [Char]
19:10:47 <ExpHP> > (reverse . take 3 .  (++ repeat '0') . reverse . show) <$> [9, 23, 104]
19:10:49 <lambdabot>  ["009","023","104"]
19:11:56 <MonadHendrix> are you trying to write an nodejs module
19:12:05 <ExpHP> lol
19:12:28 <ExpHP> locating files created by csplit
19:13:12 <geekosaur> [0-9][0-9][0-9] :p
19:13:27 <ExpHP> problem is I did csplit kind of recursively
19:14:02 <ExpHP> I have stuff-[0-9][0-9][0-9]-[0-9][0-9][0-9] and I want to get all the stuff-001s first, etc
19:14:11 <MonadHendrix> lol
19:14:21 <MonadHendrix> nuke and pave
19:14:58 <glguy> > printf "%03d" 42 :: String
19:15:00 <lambdabot>  "042"
19:15:08 <ExpHP> tell me that's not in prelude
19:15:11 <ExpHP> TELL ME
19:15:14 <MonadHendrix> lmao
19:15:19 <geekosaur> Text.Printf
19:15:23 <ExpHP> oh whew
19:15:37 <geekosaur> but showFFloat isn't in Prelude either (it's in Numeric)
19:15:47 <geekosaur> and showInt doesn't take a precedemce
19:16:05 <MonadHendrix> yesterday i found readMaybe and it was a good day
19:16:22 <geekosaur> and printf is something of a hack, showing off typeclass abuse more than anything else
19:17:41 <butterthebuddha> Is there a more abridged Real World Haskell like book out there? I really don't need to read paragraphs about why static types > dynamic types; I'd like a comprehensive, but to the point description of the language's features.
19:18:18 <glguy> butterthebuddha: Have you found the Haskell Report yet?
19:18:34 <butterthebuddha> Never heard of that, but I'll definitely check that out
19:20:01 <butterthebuddha> Ah, I didn't really mean I want to read the language's standard
19:20:21 <glguy> You should
19:32:03 <ExpHP> :exf IO [a] -> IO ()
19:32:10 <exferenceBot> fmap (\ es -> fold (es, mempty))
19:32:25 <ExpHP> hurrr
19:32:59 <geekosaur> it can't reason about IO, really
19:33:12 <ExpHP> :exf (a -> IO ()) -> IO [a] -> IO ()
19:33:36 <exferenceBot> could not find expression
19:33:41 <ExpHP> :t join . mapM
19:33:42 <lambdabot> Traversable t => (a -> t a -> b) -> t a -> t b
19:33:50 <ExpHP> :t (join .) . mapM
19:33:52 <lambdabot> (Traversable m, Monad m) => (a1 -> m a) -> m a1 -> m a
19:34:43 <ExpHP> :t \f as -> join $ fmap mapM f as
19:34:45 <lambdabot> Traversable t => (t1 -> a -> t a -> b) -> t1 -> t a -> t b
19:38:44 <ExpHP> join $ (mapM_ removeFile) . filter ("edit.yaml-" `isPrefixOf`) <$> listDirectory "."
19:38:45 <ExpHP> boom
19:39:16 <glguy> ExpHP: You can replace your join/fmap with one =<<
19:39:31 <ExpHP> aw yisss
19:40:28 <ExpHP> I... wonder if I should just replace this with "do" and "guard"
19:41:04 <ExpHP> ah, wait, nope, wouldn't work. Was thikning of the Shell monad
19:58:11 <k__> hi all! 
19:58:56 <ExpHP> hey, it's my favorite letter of the alphabet!
19:59:07 <Lokathor> data PCGen = PCGen !Word64 !Word64
19:59:17 <Lokathor> do i need to declare BangPatterns for this to be strict?
19:59:29 <Lokathor> or is that just for strict args in a funciton declaration or something?
19:59:33 <glguy> No, that's not part of the BangPatterns extension
19:59:47 <glguy> That's just part of Haskell
19:59:53 <Lokathor> okay cool
20:00:19 <k__> quick question: is there any way to coerce a value of type "Floating a => a" to a value of any concrete numeric type? (Float, Double)
20:00:53 <Lokathor> do you mean of any type? or of a specific type?
20:01:11 <Lokathor> you can just say (val :: Float) and it'll force it into being a Float for example
20:01:47 <roboguy`_> k__: I think you might be thinking of it backwards. 'Floating a => a' can take on any floating point type already, including Float and Double
20:01:54 <roboguy`_> since those types are instances of Floating
20:02:52 <roboguy`_> :t let x = 3.2 :: Floating a => a    in (x :: Double)   -- Note that this is not casting
20:02:53 <lambdabot> Double
20:03:25 <k__> ok, got it
20:03:39 <k__> can you help me understand why this function def doesn't compile?
20:03:45 <k__> f :: (Floating a) => a -> Float 
20:03:49 <geekosaur> @paste
20:03:50 <lambdabot> Haskell pastebin: http://lpaste.net/
20:04:41 <k__> http://lpaste.net/354900
20:05:17 <roboguy`_> k__: well, like I said, it's not type casting. "Floating a => a -> ..." means that argument must be able to be *any* Floating type
20:05:18 <geekosaur> this is what people were trying to tell you
20:05:23 <geekosaur> you are lookng for a cast
20:05:31 <glguy> No, you can't write a function with type   Floating a => a -> Float
20:05:44 <geekosaur> :: is a specification. if a type can conform with the specification, it will; otherwise it is a compile error
20:06:12 <geekosaur> in this case, the Floating instance was picked by the caller, so there is no guarantee that it can conform with Float
20:07:58 <Lokathor> k__, saying (x :: Type) is just for when you have an expression that's very generic, and you want to specify that you intend for it to be a more specific type (which can sometimes help the optimzer for example).
20:09:04 <k__> hm, ok, thanks all
20:09:25 <Lokathor> or it can clear up confusion when you think an expression is one type and GHC is inferring another type, GHC will tell you where the mismatch happened instead of letting the inference go to far in a bad state
20:10:34 <roboguy`_> k__: if there's a larger context to this problem, maybe we can help with that?
20:11:15 <k__> yep, the larger context is that i'm having trouble with the polymorphic types in the haskell `ad` (autodiff) library
20:11:23 <k__> thanks for the offer, by the way :)
20:11:48 <Lokathor> you can make an lpaste of the larger example and the error message and we might be able to help
20:12:00 <jchia> I have a question about a compilation error. How can I make foo compile properly? bar works but I need to pass in a Proxy, which is undesirable. http://lpaste.net/354901
20:12:32 <roboguy`_> k__: hmm, in that case, I wouldn't be surprised if you maybe wanted something more like '(forall a. TypeClass a => a) -> ...', but lets see
20:12:48 <k__> Lokathor: there's no specific error message; i'm just trying to get around this polymorphic `ad` type
20:12:58 <k__> so it can only take the gradient of a polymorphic function f :: Floating a => [a] -> a
20:13:02 <glguy> I'd be surprised if a Rank-2 type was the solution
20:13:09 <roboguy`_> glguy: for ad stuff?
20:13:32 <glguy> yeah
20:13:35 <roboguy`_> hmm
20:14:07 <glguy> Who knows, maybe I'll be surprised :)
20:14:22 <k__> but i'm also using this library `gloss` that requires everything to be floats, and i don't see how to make them cooperate nicely
20:16:25 <roboguy`_> k__: maybe you could give an example of the part causing an issue?
20:17:14 <k__> roboguy`_: yeah, i'm trying to think of a good minimal example
20:19:31 <k__> for example, i have a complicated type of an object `data Obj = Obj { xcoord :: Float ... (other omitted fields that are floats) }`,
20:19:59 <k__> and want to take the gradient of some complicated function of all the object's parameters
20:20:44 <roboguy`_> k__: you could use `data Obj0 a = Obj { xcoord :: a ... (everything else is type a) };  type Obj = Obj0 a`
20:20:51 <k__> in order to take this gradient automatically, i need to use autodiff's `grad` function, which requires me to extract all the objects' coordinates into a giant list of `Floating a`
20:20:56 <roboguy`_> er, type Obj = Obj0 Float
20:21:21 <frew> I find myself in the deep end of haskell because I am trying to configure TaffyBar (gtk thing) so pardon me for asking a few basic questions; first off: what does this mean: `foo :: bar baz biff` (I know the right of :: is types and the left is a function I'm declaring)
20:21:30 <roboguy`_> try to keep it as Floating a as long as possible and only attempt to turn it into Float when you absolutely have to
20:21:57 <roboguy`_> frew: so, something like 'x :: Maybe Int'?
20:22:02 <k__> roboguy`_: is dealing with polymorphism in record fields doable? i tried for a few minutes and got compile errors, googled and saw a lot of scary posts about how you had to turn on existential types
20:22:18 <roboguy`_> k__: yep, it's possible
20:22:34 <roboguy`_> especially if you add a type argument
20:22:44 <frew> roboguy`_: well precisely it's: `weaCallback :: Gtk.EventM Gtk.EButton Bool`
20:22:58 <frew> is it really all wrapper types?
20:23:06 <roboguy`_> frew: do you understand stuff like Maybe Int, though (because its the same idea, essentially)
20:23:10 <frew> ues
20:23:12 <frew> yes*
20:23:15 <frew> huh
20:23:17 <frew> very weird
20:23:30 <roboguy`_> frew: so, in 'Maybe Int', the type constructor 'Maybe' is being applied to the type 'Int' to get a type
20:23:53 <roboguy`_> in your example the type constructor Gtk.EventM is applied to two types to get back a type
20:24:03 <frew> I found an example of usage of the call and it simply seems to return a bool (https://github.com/travitch/taffybar/blob/e9b9c39540d77eb8f3e0e723ddfd033456f61364/src/System/Taffybar/LayoutSwitcher.hs#L93-L100) and it looks like it's just returning a bool
20:24:08 <frew> ok
20:24:10 <frew> thanks
20:24:11 <roboguy`_> (well, it could also be a type family, but I imagine its a standard type constructor)
20:24:13 <roboguy`_> np!
20:24:32 <roboguy`_> frew: well, 'return' is a (badly named) function
20:24:36 <roboguy`_> :t return
20:24:37 <lambdabot> Monad m => a -> m a
20:25:01 <roboguy`_> frew: so, in this case, that return takes in a Bool and gives back a 'Gtk.EventM Gtk.EButton Bool'
20:25:07 <frew> ok weird
20:25:10 <frew> thanks a lot
20:25:11 <frew> that helps a lot
20:25:16 <Lokathor> so, are Typable and Data important classes for my data type to implement if I'm trying to write it as a long term library that i'll use over and over?
20:25:36 <Lokathor> also, Storable?
20:26:22 <geekosaur> depends on what you will be doing with it
20:27:26 <geekosaur> seeing Data there makes me thing generics
20:27:29 <geekosaur> *think
20:27:30 <Lokathor> it's an RNG, holds two Word64 values, basically a suped up newtyped tuple
20:28:08 <roboguy`_> Lokathor: if its an actual newtype, you could get away with a lot in the future just by using 'coerce'
20:28:19 <glguy> k__: Your job using 'ad' is to define functions that *only* use floating operations with types like:  Floating a => a -> a; or  Floating a => [a] -> a
20:28:28 <k__> roboguy`_: ok, i'll try it, thanks for the suggestion
20:28:45 <glguy> k__: then grad can process such a function to give you back one that also has a similar type
20:28:55 <Lokathor> it's not an actual newtype. There's a Boxed version with two strict Word64, and an unboxed version I'll be making with two Word# values (but which will obviously only work with Word# is 64 bit wide, hense the Boxed fallback)
20:28:56 <glguy> and then you can use *that* result where you pick 'a' to be Float
20:29:56 <Lokathor> most of the time I'll be using the unboxed version, but i'd also like it to be operable on my raspberry pi, so there's a slow fallback option when needed
20:29:56 <k__> glguy: yeah, the problem is that the lists of objects can be very complex/structured and i'd like to operate on objects inside a function, not a giant list of floats
20:30:37 <iqubic> Anyone have a guide for emacs haskell mode. I want to be able to open up a REPL with my Stack deps already pulled in.
20:30:45 <k__> glguy: er, giant list of `Floating a`. so i was trying to "reserialize" the `Floating a` back into the list of objects, which required "casting"' to Float
20:30:53 <glguy> k__: OK, then you'll have to parameterize your objects
20:31:01 <k__> but maybe using roboguy`_'s suggestion will help WRT parametrization
20:31:11 <k__> yeah
20:31:14 <iqubic> Also, isn't there a way to get the infered type signature of a function from Haskell Mode?
20:31:31 <iqubic> Anyone able to dig up a tutorial for emacs Haskell Mode for me?
20:31:49 <MonadHendrix> i read that as `infrared`
20:32:13 <iqubic> Yeah, I misspelled that.
20:32:18 <k__> iqubic: i have also been looking for one for a while...
20:32:23 <iqubic> *inferred.
20:32:31 <MonadHendrix> iqubic: flycheck and ghc-mod
20:32:36 <k__> https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md ?
20:32:58 <MonadHendrix> install ghc-mod on your system then package-install ghc
20:33:10 <MonadHendrix> and enable ghc minor mode
20:33:41 <MonadHendrix> shows type sig of thing at point in minibuffer
20:33:41 <iqubic> How do I check if I have ghc-mod installed?
20:33:50 <k__> https://haskell.github.io/haskell-mode/manual/latest/
20:38:33 <iqubic> MonadHendrix: I know what ghc-mod is. I just don't know *if* I have it installed
20:39:33 <iqubic> Looks like I didn't have that installed.
20:40:03 <iqubic> But I'm installing it now. 
20:40:36 <Lokathor> https://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#randomIvalInteger is this actually a function that will generate all possible results in the range equally probably?
20:40:42 <Lokathor> I don't know enough math to be able to tell :(
20:41:49 <iqubic> Looks complex
20:41:54 <iqubic> I think it's right.
20:41:58 <iqubic> Not sure though
20:43:12 <iqubic> What's the @ symbol I sometimes see in pattern matches: foo list@(x:xs) = ...
20:43:33 <iqubic> Where foo is a function.
20:43:46 <alx741> iqubic: to let you match the whole thing with the name 'list' in that case
20:44:15 <alx741> so 'list' is the whole list, 'x' the first element, and 'xs' the rest of the list
20:44:22 <MarcelineVQ> > let foo list@(x:xs) = list ++ xs in foo "abcd"
20:44:24 <lambdabot>  "abcdbcd"
20:47:10 <MarcelineVQ> Lokathor: hard to say but have a look at random-fu as it provides various distributions and it should plug in nicely, for testing, if you're already defining things over MonadRandom
20:48:22 <Lokathor> if random-fu still uses the Random typeclass, it might be hard to measure :P
20:48:34 <Lokathor> that function is how most of the Random instances are defined
20:48:37 <timmm0> hello guys
20:48:43 <timmm0> im a newb
20:48:50 <timmm0> tons of questions might come your way
20:49:00 <timmm0> and i do rtfm
20:49:14 <Lokathor> timmm0, got a particular project you're working on?
20:49:30 <timmm0> just training with basic commands
20:49:50 <k__> iqubic: it's called an as-pattern
20:53:11 <Lokathor> > uses the "at" symbol, but calls it an "as" pattern.
20:53:22 <lambdabot>  <hint>:1:21: error: parse error on input ‚Äò,‚Äô
20:54:03 <Lokathor> http://lpaste.net/354904 whee, version one organized. Mostly just grabbing from old code, not much new here, but nice to get it put in a place.
21:10:02 <leafgreen> I'm wondering, is there a reason why infinite recursion in Haskell may not use any apparent CPU?
21:10:14 <leafgreen> I've been googling about this and not finding anything.
21:10:41 <leafgreen> Is it a compiler optimization that checks if the stack memory isn't changing with each recursion, and it just does nothing?
21:11:36 <pacak> leafgreen: Depends. Infinite recursion might even terminate
21:11:47 <pacak> > let ones = 1:ones in take 3 ones
21:11:48 <leafgreen> well apparently it isn't
21:11:49 <lambdabot>  [1,1,1]
21:12:04 <leafgreen> ah I'm aware of the lazy evaluation cases
21:12:33 <leafgreen> the situation is one of my students apparently made a mistake and performed infinite recursion without changing the parameters passed in the call
21:12:48 <leafgreen> But they were convinced it wasn't an infinite recursion hang because the cpu showed 0% usage for the thread.
21:12:52 <iqubic> Is (:) a valid data constructor??
21:13:00 <iqubic> :t :)
21:13:02 <lambdabot> error: parse error on input ‚Äò:‚Äô
21:13:04 <iqubic> :t (:)
21:13:05 <lambdabot> a -> [a] -> [a]
21:13:11 <iqubic> So it is.
21:13:24 <iqubic> > 1:2
21:13:26 <lambdabot>  error:
21:13:26 <lambdabot>      ‚Ä¢ Ambiguous type variable ‚Äòa0‚Äô arising from a use of ‚Äòshow_M727745955427...
21:13:26 <lambdabot>        prevents the constraint ‚Äò(Show a0)‚Äô from being solved.
21:13:41 <iqubic> > 1:2 :: [Integer]
21:13:43 <lambdabot>  error:
21:13:43 <lambdabot>      ‚Ä¢ No instance for (Num [Integer]) arising from the literal ‚Äò2‚Äô
21:13:43 <lambdabot>      ‚Ä¢ In the second argument of ‚Äò(:)‚Äô, namely ‚Äò2‚Äô
21:13:56 <iqubic> Why doesn't that work?
21:14:03 <iqubic> > 1:2:[] :: [Integer]
21:14:04 <leafgreen> You can't cons an int onto an int. Only onto an int list.
21:14:05 <lambdabot>  [1,2]
21:14:19 <iqubic> So cons is Right assosiative?
21:14:20 <leafgreen> That one is okay because you are consing onto an empty int list
21:14:28 <iqubic> That's what my test seems to show.
21:14:44 <iqubic> > 1:2:[]
21:14:46 <lambdabot>  [1,2]
21:15:06 <leafgreen> > (0$0 :)
21:15:08 <lambdabot>  error:
21:15:08 <lambdabot>      The operator ‚Äò:‚Äô [infixr 5] of a section
21:15:08 <lambdabot>          must have lower precedence than that of the operand,
21:15:14 <pacak>  Prelude> :info (:)
21:15:14 <pacak> data [] a = ... | a : [a]       -- Defined in ‚ÄòGHC.Types‚Äô
21:15:14 <pacak> infixr 5 :
21:15:16 <leafgreen> infixr -> it is right associative
21:15:26 <leafgreen> lol the info command is nice. I didn't know that.
21:16:02 <iqubic> Question: If a function is looking for a Rational, and I give it 1 :: Integer, will that pass type checking?
21:16:07 <leafgreen> the 0$0 hack seems to show the info for some things that :info does not, strangely.
21:16:31 <iqubic> What does th 0$0 even do?
21:17:48 <iqubic> Does a greater infix number mean the operater is evaluated first, or last?
21:18:20 <roboguy`_> iqubic: no. But it is pretty easy to convert to a Rational from an Integer
21:18:27 <iqubic> roboguy`_: How?
21:18:35 <roboguy`_> :t fromIntegral (3 :: Int) :: Rational
21:18:36 <lambdabot> Rational
21:18:43 <iqubic> Ah, I see.
21:18:44 <roboguy`_> I use fromIntegral quite a bit
21:18:49 <roboguy`_> it's fairly general
21:19:02 <roboguy`_> :t fromIntegral
21:19:03 <lambdabot> (Num b, Integral a) => a -> b
21:19:22 <iqubic> Yeah, but that goes the wrong way.
21:19:47 <roboguy`_> oh, I thought you wanted to give an Integer to a function that takes a Rational
21:19:53 <iqubic> I do.
21:20:00 <roboguy`_> that should go the right way then...
21:20:03 <iqubic> or rather other way around.
21:20:25 <roboguy`_> for the other way...
21:20:27 <roboguy`_> :t fromRational
21:20:29 <lambdabot> Fractional a => Rational -> a
21:20:34 <roboguy`_> :t (ceiling, floor, round)
21:20:35 <lambdabot> (Integral b, Integral b1, Integral b2, RealFrac a, RealFrac a1, RealFrac a2) => (a2 -> b2, a1 -> b1, a -> b)
21:20:36 <iqubic> I want to have a function of the type (Num a, Integral b) => a -> b
21:21:00 <roboguy`_> it depends on the rounding behavior you want
21:21:14 <iqubic> Is it possible to take the ceiling of 1 % 2?
21:21:29 <glguy> what happened when you tried?
21:21:35 <roboguy`_> > ceiling (1 % 2)
21:21:37 <lambdabot>  1
21:21:52 <iqubic> for me percent is not in scope.
21:21:54 <leafgreen> > 2 :: Rational
21:21:56 <lambdabot>  2 % 1
21:21:59 <roboguy`_> iqubic: import Data.Ratio
21:22:03 <leafgreen> See, that works automatically.
21:22:18 <leafgreen> Because of this. http://stackoverflow.com/a/22637684
21:23:13 <leafgreen> the 0%0 hack forces an error message that is very revealing about the parse and operator precedence and associativity. It works because of something it does that can never parse in Haskell.
21:23:26 <leafgreen> See http://stackoverflow.com/a/23587308
21:25:29 <iqubic> > (0$0 !!)
21:25:31 <lambdabot>  error:
21:25:32 <lambdabot>      The operator ‚Äò!!‚Äô [infixl 9] of a section
21:25:32 <lambdabot>          must have lower precedence than that of the operand,
21:25:42 <iqubic> I don't get that error
21:25:51 <leafgreen> It just showed above...
21:26:14 <leafgreen> I see it in ghci too, which version are you using?
21:26:29 <iqubic> I can see it in GHCi too.
21:26:45 <leafgreen> don't get = don't understand?
21:26:55 <iqubic> Yeah
21:27:02 <iqubic> I don't understand it.
21:27:08 <leafgreen> The info you want to glean from that is the [infixl 9] part. The rest is just complaining about the parse error.
21:27:23 <leafgreen> The parse error was done on purpose to get the message to show.
21:28:16 <iqubic> Oh. I see.
21:28:19 <leafgreen> :info (:)
21:28:20 <iqubic> Cool little hack.
21:28:36 <thang1> > (0:0 !!)
21:28:37 <iqubic> leafgreen: I have seen the info command. It's rather cool.
21:28:38 <lambdabot>  error:
21:28:38 <lambdabot>      The operator ‚Äò!!‚Äô [infixl 9] of a section
21:28:38 <lambdabot>          must have lower precedence than that of the operand,
21:28:46 <thang1> see?/ neat :p
21:29:02 <leafgreen> > :info (!!)
21:29:03 <iqubic> Yeah, I get what going on. 
21:29:04 <lambdabot>  <hint>:1:1: error: parse error on input ‚Äò:‚Äô
21:29:26 <thang1> wait, why does info work for !! but not for : 
21:29:29 <iqubic> So we can use any infixl 0 function between the zeros?
21:29:46 <thang1> nvm, leafgreen and lambdabot are the same color in my terminal and I had a brainfart
21:29:51 <leafgreen> Haha.
21:29:56 <leafgreen> Yeah info seems not to work in here.
21:30:08 <iqubic> lambdabot don't do info
21:30:33 <leafgreen> interestingly :info (!!) doesn't show the assoc info, but the 0$0 hack does.
21:30:50 <thang1> Which is pretty funny. You'd think info would be... informative
21:30:58 <iqubic> Yeah, when not specified, assume infixl 9
21:31:21 <iqubic> Did you read those stack overflow answers you posted? Answer was in there.
21:31:28 <thang1> Or... :info can specify it?
21:31:42 <leafgreen> iqubic I read them back when I bookmarked them. I didn't memorize the contents
21:31:53 <thang1> I hate it when informative commands leave out "defaults"
21:32:18 <thang1> if I'm asking for the info, there's a good chance I don't know it, so don't leave out implied defaults...
21:32:48 <iqubic> Why do you have those bookmarked???
21:33:22 <leafgreen> I bookmark anything I find interesting... and sure enough I had reason to pull up the bookmark in this convo
21:33:42 <thang1> hah, I'm the same way except I use Pocket
21:34:20 <thang1> Literally hundreds of links in Pocket. Far easier to remember small metadata about something than the actual thing. I liken it to a table cache in my brain
21:34:45 <leafgreen> if I lost my bookmarks my productivity would drop by a lot. it's my own personal search engine at this point
21:35:12 <iqubic> What's Pocket?
21:35:24 <rotaerk> hmm I don't really use bookmarks... I've bookmarked things but I never go back actually revisit it
21:36:03 <leafgreen> You never know when something might be useful. That's why I bookmark and tag almost anything remotely interesting
21:36:09 <leafgreen> saved me a bunch of times
21:36:16 <thang1> Pocket is similar to "bookmarks in the cloud" concept
21:36:26 <thang1> You have an account and it allows you to save links and tag them
21:36:47 <leafgreen> most browsers have a built-in concept like that now
21:36:51 <thang1> so I have links tagged "programming", "haskell", "cooking", etc. But I can access them on my phone, laptop, or even some random webbrowser in a library
21:37:20 <thang1> I prefer pocket because it doesn't depend on using a certain browser :) I switch between chrome and firefox a lot
21:37:45 <leafgreen> I see
21:37:53 <leafgreen> I've been partial to ff for a long time
21:38:24 <thang1> I love firefox solely for its vimperator plugin. Muh keyboard bindingz
21:38:48 <thang1> Chrome, however, I use on Android because it's baked so thoroughly in at this point that it has a gazillion neat features that come in handy a lot
21:39:34 <leafgreen> Well, I gotta run. Interesting talking to you all
21:41:19 <thang1> see ya
21:41:30 <m0cesta> Why pure (Left 10) returns Left 10?
21:41:46 <c_wraith> m0cesta: ghci lies to you
21:42:05 <c_wraith> m0cesta: ghci is defaulting to to IO
21:42:25 <c_wraith> m0cesta: so..  pure (Left 10) :: IO (Either Integer a)
21:42:51 <c_wraith> m0cesta: and when you give ghci an IO action, it runs it and prints the result if it's something in Show other than ()
21:43:14 <m0cesta> I see, thanks
21:43:21 <c_wraith> > pure (Left 10) :: Maybe (Either Integer String)
21:43:23 <lambdabot>  Just (Left 10)
21:58:30 <frew> I am trying to apply a callback to a Gtk widget, the code is https://github.com/frioux/dotfiles/blob/taffybar-advance/taffybar/taffybar.hs#L34-L37 and I'm getting this as an error: http://paste.scsys.co.uk/559024 .  Reading various things on the internet about that error it sounds like a constraint ( => I think
21:58:42 <frew> ) would at least make this more clear, though likely not resolve the problem
21:58:56 <frew> anyone have any ideas or tips?
22:00:44 <thang1> Spawn is unsafe and then you just blindly return true
22:01:02 <thang1> How do you know you actually, ah, made the widget?
22:01:29 <lpaste> glguy pasted ‚Äúfor frew‚Äù at http://lpaste.net/5174934910162436096
22:01:31 <frew> I think I'm just attaching a callback?
22:01:39 <frew> that's what I'm trying to do anyway
22:01:41 <glguy> frew: That would probably typecheck. I don't know if it's how you're supposed to use this tool
22:01:47 <iqubic> What does spown do?
22:02:05 <frew> it's supposed to just run a program, if I understand correctly
22:02:11 <iqubic> Yeah, it does.
22:02:24 <frew> it's from https://hackage.haskell.org/package/xmonad-contrib-0.11.1/docs/XMonad-Util-Run.html
22:02:41 <iqubic> I use spawn in my XMonad config to get keybindings to work.
22:02:45 <frew> right
22:03:02 <frew> so I'm trying to use spawn in TaffyBar, a GTK bar for XMonad basically
22:03:18 <iqubic> I can post my config if you'd like. It's nothing too fancy.
22:03:38 <iqubic> It uses dzen though.
22:03:48 <frew> nah, thanks though
22:03:51 <iqubic> You want me to help you with taffybar?
22:04:02 <frew> I had dzen for a while but I wanted to kinda go further, with graphs and such
22:04:06 <frew> that'd be great, if you don't mind
22:04:33 <frew> fwiw I have Xmonad working perfectly; I just am trying to get TaffyBar working how I had awesomewm working
22:04:34 <iqubic> What isn't working in your taffybar set-up?
22:04:48 <frew> well I wanted to start by making my widgets clickable
22:05:03 <frew> so if I click a weather widget, open a browser to a page about that weather
22:05:13 <iqubic> Is that possible with taffybar?
22:05:15 <lpaste> glguy annotated ‚Äúfor frew‚Äù with ‚Äúor maybe you're supposed to do this?‚Äù at http://lpaste.net/5174934910162436096#a5904117509736366080
22:05:32 <frew> iqubic: I don't see why not, it's just gtk widgets
22:05:56 <iqubic> Why are you using unsafeSpawn, over spawn?
22:05:57 <frew> glguy: lemme see; someone said something like that on github but I didn't nuderstand it
22:06:19 <frew> iqubic: it's the same thing, don't I need to use unsafeSpawn to pass args?
22:06:27 <iqubic> Yes.
22:07:11 <frew> glguy: well that passes type constraints
22:07:41 <iqubic> I mean you can get the same functionality if you use spawn instead of unsafeSpawn.
22:07:42 <frew> doesn't launch the program but that's some kind of progress
22:08:00 <frew> iqubic: ok, yeah I just must have misread or something
22:09:11 <frew> I wonder if I need to wrap the widgets in an ebox to make events actually work
22:09:29 <frew> this is what makes me think that: https://github.com/travitch/taffybar/blob/e9b9c39540d77eb8f3e0e723ddfd033456f61364/src/System/Taffybar/LayoutSwitcher.hs#L93-L100
22:10:17 <iqubic> frew, what happens when you use your current set-up?
22:10:31 <iqubic> What happens when you click on the weather widget?
22:10:52 <frew> nothing at all, no new tab in firefox, nothing logged to the console
22:11:11 <iqubic> Alright, I'll try and see if I can see what's wrong.
22:11:33 <frew> thanks!
22:12:35 <iqubic> Have you tried wrapping the widget in an ebox?
22:13:05 <frew> no, that was my next idea, but I'm honestly not sure how; might try doing it in the new do block I have that was recommended by glguy 
22:13:30 <iqubic> Sounds good.
22:13:36 <frew> trying now
22:15:06 <frew> !!!
22:15:08 <frew> it worked!
22:15:11 <iqubic> Cool.
22:15:22 <frew> thanks for your help iqubic, glguy
22:15:32 <iqubic> Can I see the final config. I'm rather curious about what you did now.
22:15:34 <iqubic> ??
22:15:35 <frew> yeah totes
22:15:37 <frew> just a sec
22:16:13 <frew> https://github.com/frioux/dotfiles/blob/taffybar-advance/taffybar/taffybar.hs#L60-L65
22:17:28 <iqubic> Cool, that looks great.
22:18:41 <frew> alright, now to make some pull requests as examples for TaffyBar :)
22:20:33 <iqubic> Why? Why do you need to make a pull request
22:21:56 <frew> only to improve the docs
22:22:08 <frew> I figure that with something as powerful as Gtk people will be bound to want to do this kind of thing
22:22:14 <frew> so making it obvious how to do it seems worthwhile
22:23:58 <thang1> frew: what's your actual setup look like?
22:25:18 <frew> thang1: not sure what you are asking; I use XMonad as a window manager and TaffyBar (was using AwesomeWM but the break in backcompat was just too frustrating)
22:25:59 <thang1> I was just curious how your actual bar and windows look
22:26:02 <frew> ah
22:26:08 <frew> sec I can take a screenshot
22:26:40 <iqubic> How do you make it so that the window don't cover up the status bar?
22:26:50 <frew> that's called "struts"
22:26:54 <frew> it's a thing that most bars do for you
22:27:10 <frew> basically they tell the WM (or X11?) "I take up this much space" and you tell XMonad to honor it
22:27:30 <thang1> lemonbar doesn't (or bspwm doesn't give a shit). I configure mine manually :p
22:27:36 <iqubic> With my config, Dzen always gets covered up, and I have no idea how to fix that.
22:27:45 <frew> sec I can show you
22:27:48 <frew> I did it with Dzen
22:28:20 <frew> iqubic: https://github.com/frioux/dotfiles/blob/master/xmonad/xmonad.hs#L19
22:28:32 <frew> I think that comes from ManageDocks
22:28:38 <biglambda> Is there a way to determine if malloc or realloc is failing?
22:29:23 <iqubic> What does SendMessage ToggleStruts do?
22:29:41 <frew> ToggleStruts lets you turn them off and on
22:29:48 <frew> I never do it but I'm trying it out
22:29:51 <frew> you can leave it out
22:29:55 <frew> thang1: https://imgur.com/a/6SuYk
22:30:17 <thang1> nice
22:30:25 <thang1> butt ugly, but functional
22:30:31 <frew> the blank graph is going to be a battery graph but that's broken, green is cpu, blue is memory, two temps are different geographic locations that I'll add labels to eventually
22:30:40 <frew> yeah I don't care about how it looks honestly :)
22:32:01 <iqubic> Weird. I wonder why my config covers up my dzen status bar. I also have avoidStruts.
22:32:14 <frew> ok I also was using Tasker
22:32:21 <frew> it's possible that was advertising the struts
22:32:28 <thang1> Mine: http://i.imgur.com/F0kDvmG.jpg
22:32:30 <iqubic> What does Tasker do?
22:32:50 <frew> shows the icons that some programs require, like dropbox etc
22:33:05 <iqubic> So it's like "trayer"
22:33:11 <frew> oh sorry
22:33:12 <frew> I meant trayer
22:33:15 * frew can't think
22:33:22 <thang1> lol we've all been there
22:33:27 <frew> thang1: your chat is gorgeous
22:33:59 <thang1> I take my ricing seriously
22:34:05 <frew> lol
22:34:09 <thang1> (semi seriously)**
22:34:28 <frew> yeah I have let that part of my brain rot
22:34:36 <frew> I'm purely functional (ha ha ha)
22:34:40 <iqubic> LOL
22:34:50 <iqubic> So does dzen not have struts?
22:34:57 <frew> I could have swore it did
22:35:15 <iqubic> And if not, is there a way to make it so that dzen is not covered up?
22:35:33 <frew> you could do what iqubic did and just tell it not to go over the top 24 (or w/e) pixels
22:35:59 <frew> iqubic: when you run tasker, try running with --SetPartialStrut true
22:36:09 <iqubic> I don't use tasker.
22:36:13 <frew> sorry, trayer
22:36:22 <iqubic> I don't even use trayer
22:36:25 <frew> or do you not use that either?
22:36:26 <frew> huh
22:36:31 <iqubic> I use just dzen
22:36:34 <frew> hardcore.
22:36:37 <iqubic> Nothing else but dzen
22:36:47 <iqubic> And I don't want dzen to be covered up
22:36:53 <frew> I had the feel that dzen might not be doing it because it looked like it was a couple pixels off
22:37:00 <Lokathor> they just imagine the bits that they want to have written directly written into RAM
22:37:15 <frew> thang1: how did you tell xmonad not to overlay dzen, or are you *just* using trayer?
22:37:28 <iqubic> frew uses bspwm
22:37:36 <iqubic> Or rather thang1 does.
22:37:49 <iqubic> thang1: Do you use bspwm?
22:38:03 <iqubic> http://termbin.com/dgyx
22:38:13 <iqubic> That's my XMonad config.
22:38:30 <iqubic> https://mail.haskell.org/pipermail/xmonad/2010-December/010913.html
22:38:37 <iqubic> Also see that related thing.
22:39:27 <iqubic> https://mail.haskell.org/pipermail/xmonad/2010-December/010913.html
22:39:33 <iqubic> https://github.com/xmonad/xmonad/issues/21
22:39:37 <iqubic> And that second thing.
22:40:34 <frew> huh, I'm on 0.12 fwiw
22:40:43 <frew> (which isn't much, since I'm not using dzen anymore
22:41:23 <iqubic> I switched to 0.13 about 2 weeks ago.
22:41:25 <frew> iqubic: have you asked in #xmonad?
22:41:41 <frew> yeah I just use what's shipped by the package manager unless I have a really compelling reason not to
22:42:26 <iqubic> frew: I have not done that.
22:42:54 <frew> might be worth a shot; I got some help setting up some more basic things there I think
22:44:41 <iqubic> I just asked in there. Now we wait.
22:45:05 <frew> if you don't get a response, it might be worth asking again in about 8 hours
22:45:14 <frew> not sure what TZ the channel is mostly you know?
22:45:50 <iqubic> No.
22:46:16 <iqubic> I'm not sure what the TZ is in #xmonad
22:50:52 <frew> well it's late here; thanks again for your help!
22:50:55 <frew> & zzz
22:59:43 <thang1> sorry, yes I use bspwm. My bar is lemonbar
23:00:21 <thang1> the text editor is emacs running spacemacs. The web browser is firefox with vimperator and a few plugins to hide all the useless shit
23:05:07 <iqubic> thang1: Do you have a list of all the spacemacs commands for interacting with Haskell Mode? I have been looking for that for a while.
23:06:01 <iqubic> I use spacemacs, but I don't know how to use spacemacs *and* Haskell Mode
23:09:42 <thang1> I use spacemacs + Intero
23:10:14 <thang1> So in your dotspacemacs-configuration-layers setting
23:10:24 <magthe> iqubic: I guess you've already checked the layer's docs via `SPC h l`, right?
23:10:26 <thang1> haskell-completion-backend 'intero is what I have set
23:15:19 <iqubic> magthe: I haven't actually looked at that.
23:15:33 <cobreadmonster> What's up peeps?
23:15:36 <iqubic> thang1: Can't I use auto-completer?
23:20:18 <moet> does haddock generate docs for associated data families' constructors and parameters?
23:21:07 <moet> it seems documented "yes" https://www.haskell.org/haddock/doc/html/markup.html ... but it seems to not work
23:22:04 <thang1> Sure, auto completion is fine in Haskell
23:22:39 <thang1> I've never really needed it when writing haskell because it's so terse in general... The autocomplete setup that I have right now isn't IDE level, though
23:24:43 <cocreature> moet: do you have some minimal examples that doesn‚Äôt work? I know it works for associated types, e.g. https://hackage.haskell.org/package/supermonad-0.1/candidate/docs/Control-Supermonad-Constrained-Functor.html, but I don‚Äôt think I‚Äôve tried associated data families
23:25:07 <Lokathor> the thing about auto complete, and editor features in genral, is that an editor will seemingly never know what i really want
23:25:13 <Lokathor> it will always do the wrong thing
23:25:23 <cocreature> moet: http://lpaste.net/354908 works just fine
23:27:53 <moet> cocreature: i'll try to make a repro
23:28:10 <moet> i'm referring to the `-- | prose` in the documentation no showing up for me
23:28:26 <cocreature> oh ok
23:28:58 <zomg> Super monads?
23:29:04 <zomg> Do you guys never have enough?
23:29:05 <zomg> :D
23:29:13 <thang1> Ever seen the Tardis monad?
23:29:19 <cocreature> zomg: I was just randomly looking for a package with associated types :)
23:29:40 <cocreature> moet: http://lpaste.net/354909 works as well for me
23:32:15 <lpaste> moet revised ‚ÄúNo title‚Äù: ‚Äúno haddock prose on data family intance‚Äù at http://lpaste.net/354909
23:32:47 <moet> cocreature: uh, that overwrote your paste? but.. anyhow, i meant on the instance..
23:32:54 <cocreature> np
23:33:12 <cocreature> moet: I can reproduze that
23:33:23 <moet> cocreature: sad to hear that :P
23:35:34 <cocreature> moet: well now you know you need to fix it :P
23:37:32 <iqubic> What is the tardis monad? As a Doctor Who fan, I need to kno what that is.
23:37:54 <cocreature> https://hackage.haskell.org/package/tardis
23:37:54 <jle`> @hackage tardis
23:37:55 <lambdabot> http://hackage.haskell.org/package/tardis
23:37:56 <thang1> It's literally a time traveling monad
23:38:01 <moet> cocreature: yes, er. just let me fire up my trusty ghc build environment.. then i can submit a patch with the trac account i totally have ;)
23:38:11 <iqubic> thang1: How does it work?
23:38:25 <cocreature> moet: haddock is just a cabal package, no need to set up a ghc build environment :P
23:38:27 <thang1> I, uhh, have not a good understanding of monads. So the answer to me is "black magic"
23:38:33 <moet> cocreature: OH
23:38:34 <moet> cool.
23:38:37 <jle`> thang1: understanding monads isn't relevant here
23:38:38 <moet> thank you :)
23:38:41 <jle`> it's just a specific instance :)
23:38:44 <cocreature> moet: and I think you can submit patches on github, so you‚Äôre out of excuses :P
23:38:55 <moet> cocreature: yes, yes i am. hmm..
23:38:59 <moet> it's bedtime!
23:39:01 <thang1> https://github.com/DanBurton/tardis 
23:39:04 <jle`> iqubic: it helps if you are familiar with State, but it's basically just State but the state propagates backwards instead of forwards
23:39:30 <iqubic> How does that work?
23:39:33 <thang1> "It is isomorphic to a StateT on top of a ReverseStateT"
23:39:38 <jle`> that's how it works
23:39:44 <iqubic> Alright then.
23:39:53 <jle`> you just switch where you get the state from :)
23:39:56 <iqubic> What is a ReverseStateT?
23:40:00 <jle`> and which direction the state moves in
23:40:02 <thang1> k so if I say that x = x + 5 I just changed the state of x
23:40:27 <thang1> if you think about it in terms of "time", I went from x ......-> x+5
23:41:00 <thang1> since haskell is referentially transparent, all changes in state are reproducable**, so you can go backwards from x+5 -------> x
23:41:00 <iqubic> Sure. I get that.
23:41:04 <jle`> for State, *> sequences changes in state.  so `x *> y`, where x and y are state actions, becomes a new state action where 'x' is done, then 'y'
23:41:17 <thang1> hence, traveling back in time
23:41:32 <jle`> but for ReverseState, if x and y are reverse state actions, then 'x *> y' is a new reverse state action that does 'y', then does 'x'
23:41:39 <jle`> it's basically kind of like flipping (*>)
23:42:17 <jle`> if x *> y is "do x then do y" for State, then x *> y is "do y then do x" for reverse state.  they're just the flipped implementation
23:42:32 <jle`> if you write <*> for State, then you can write <*> for ReverseState.  just flip everything :)
23:42:32 <iqubic> Why is that useful?
23:42:42 <thang1> It's not, it's just cool
23:42:43 <jle`> it's mostly novel
23:43:14 <thang1> However it does provide a super elegant (and really fucking slow) implementation of the water bucket area problem (or whatever that problem is actually called)
23:43:34 <iqubic> What is that??
23:43:36 <jle`> thang1: being referentially transparent doesn't mean that changes in state are invertible
23:43:48 <jle`> it doesn't actually invert any state changes
23:44:02 <jle`> all it does is just flip the parameters to <*>/>>=, more or less
23:44:06 <thang1> http://chrisdone.com/posts/twitter-problem-loeb
23:44:22 <thang1> jle`: my bad. Told ya I didn't understand shit :p
23:44:41 <thang1> The ** was to signify I was talking out my ass and was probably wrong but I forgot to actually write the disclaimer
23:47:15 <zalun> hey - anyone here worked on phabricator integration for haskell-infra ?
23:47:24 <zalun> https://github.com/haskell-infra/libphutil-haskell/tree/master/src/extensions/differential/customfield
23:49:32 <Axman6> the #haskell-infrastructure channel might be a better place to ask
