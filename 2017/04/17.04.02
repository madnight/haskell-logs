01:25:29 <zq> :t manyTill
01:25:30 <lambdabot> error: Variable not in scope: manyTill
01:25:35 <zq> damn
01:25:40 <zq> does lambdabot not have parsec loaded?
01:26:02 <c_wraith> apparently not
01:26:14 <c_wraith> @let import Text.Parsec
01:26:14 <zq> :m + Text.Parsec
01:26:16 <lambdabot>  Defined.
01:26:20 <zq> c_wraith: thanks!
01:26:36 <c_wraith> :t manyTill
01:26:37 <lambdabot> Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
01:29:57 <zq> > parse ((,) <$> (manyTill anyChar . Text.Parsec.try $ Text.Parsec.char 'g') <*> Text.Parsec.many anyChar) "" "asdfgh"
01:29:59 <lambdabot>  Right ("asdf","h")
01:30:19 <zq> is this a bug? i don't see why 'g' is consumed, since the manyTill end is wrapped in `try`
01:31:10 <zq> i expected: Right ("asdf", "gh")
01:33:09 <cocreature> zq: "try" does not result in a parser never consuming input. it results in a parser that doesn’t consume input _if it fails_
01:33:50 <opqdonut> you might want to try lookAhead instead of try
01:33:56 <opqdonut> my parsec is a bit rusty though
01:34:02 <zq> cocreature: ohcrap, i forgot
01:36:22 <cocreature> > parse ((,) <$> (manyTill anyChar . Text.Parsec.lookAhead $ Text.Parsec.char 'g') <*> Text.Parsec.many anyChar) "" "asdfgh"
01:36:24 <lambdabot>  Right ("asdf","gh")
01:36:27 <cocreature> ^ zsq
01:36:29 <cocreature> ^ zq
01:36:51 <cocreature> oh opqdonut already said that
01:36:53 <zq> opqdonut: cocreature thanks
01:37:23 <zq> i'm a bit confused about lookAhead's commentary, though. "lookAhead p parses p without consuming any input.
01:37:27 <zq> If p fails and consumes some input, so does lookAhead. Combine with try if this is undesirable"
01:37:35 <cocreature> zq: note that "try" has no effect when you apply it to "char" since "char" already doesn’t consume input on failure
01:37:43 <zq> so, how could p consume some input if p is parsed without consuming any input?
01:37:59 <cocreature> zq: it is parsed without consuming input if p succeeds
01:40:03 <zq> oh i see
01:40:17 <zq> if p succeeds, then it rolls back. otherwise, if p fails, lookAhead fails with it
01:40:24 <cocreature> exactly
01:41:00 <cocreature> the megaparsec docs are a bit clearer on this https://hackage.haskell.org/package/megaparsec-5.2.0/docs/Text-Megaparsec.html#v:lookAhead
02:00:29 <fred-fri> does this challenge not have an error in it? should the answer not be 4 because 12 should be included in the set? https://www.hackerrank.com/challenges/between-two-sets
02:03:04 <cocreature> fred-fri: 12 is not a factor of 16 :)
02:03:49 <cocreature> and it’s also not a factor of 32
02:22:21 <Aruro> why Char is not an instance of Num?
02:22:34 <fred-fri> cocreature, this is what I have so far https://pastebin.com/NcxMQ5fk
02:23:15 <fred-fri> pretty sure my first condition in the filter is OK but not the second
02:23:24 <Taneb> Aruro, why should it be? Characters aren't numbers
02:23:39 <Taneb> What should 'x'*'[' be
02:24:13 <Aruro> > instance Num Char where fromInteger = chr . fromInteger
02:24:15 <lambdabot>  <hint>:1:1: error: parse error on input ‘instance’
02:24:27 <Aruro> ah, lambdabod can not make instances
02:26:57 <cocreature> fred-fri: I think it’s the other way around. your second condition tests correctly whether n divides all bs. however your first condition tests whether n divides all as instead of testing whether all as divide n
02:30:34 <Aruro> Taneb: [1..256] :: String will work with above definition
02:31:20 <fred-fri> cocreature if i only do filter (\n -> (sum (map (mod n) bs) == 0)) numbersBetween it still outputs empty 
02:31:37 <fred-fri> ie that condition (which is the second one in my paste) seems wrong
02:31:51 <cocreature> Aruro: you can make an instance of Num for Char. the reason why there isn’t one is that arithmetic operations on Chars don’t make a lot of sense so requiring the explicit conversion via chr/ord ensures that you don’t accidentally use it
02:34:42 <Xandaros> Are there any totality checkers for glasgow haskell? I don't care about safely using partial functions, just something that makes sure everything is total
02:34:51 <cocreature> fred-fri: ah you need "map (`mod` n)" i.e. partial application on the second argument
02:35:16 <freechips> a = 8/2 `mod` 5
02:35:24 <freechips> throws a weird error about ambiguous types
02:36:13 <freechips> same for a = 2.2^2 `mod` 5
02:36:28 <cocreature> / requires Fractional but mod requires Integral
02:36:33 <Taneb> Aruro, ['\1'..'\256'] works just as well
02:37:28 <freechips> ah ok i was coming from python
02:37:33 <freechips> so ill just cast
02:38:20 <Xandaros> Why does it need integral? Does "5.2 `mod` 5.1 = 0.1" not make sense?
02:38:53 <fred-fri> cocreature, ah so i wasnt going crazy
02:38:56 <fred-fri> yes that works
02:39:00 <fred-fri> uh, what does it do
02:39:06 <freechips> a = (truncate (4/5)) `mod` 5 -- works
02:39:12 <freechips> also am i forced to use main = do
02:39:20 <freechips> and let  before every variable?
02:39:56 <Xandaros> mod' from Data.Fixed works for reals, it seems
02:44:04 <freechips> getting so many errors..
02:44:11 <fred-fri> ooooh so mod and `mod` is the same function, just syntax becomes different 
02:44:15 <fred-fri> mod a b == a `mod` b
02:44:42 <fred-fri> hard to know for a noob who is just shotgunning when stuck
02:45:33 <Xandaros> Yeah - you can do that with any function that has at least two arguments, though it is most useful if it has exactly two
02:45:58 <freechips> yeah the compiler errors kinda suck. just using a parenthesis wrong game ve 300 errors. feels like returning to C
02:46:06 <Xandaros> Some functions are meant to be used this way and it reads really nicely when used infix
02:46:21 <freechips> i was using a = truncate (a/b) `mod` c --- just fine
02:46:37 <Aruro> freechips: u did not return to c, u did not learn enough :)
02:46:42 <freechips> actually a = (truncate (a/b)) `mod` c 
02:47:00 <freechips> but a = (truncate (a^b)) `mod` c -- not fine
02:47:11 <freechips> but a = truncate (a^b) `mod` c -- fine
02:47:14 <freechips> no idea about that
02:47:36 <freechips> Aruro: ?
02:48:08 <Xandaros> > (truncate (2^5)) `mod` 5
02:48:10 <lambdabot>  2
02:48:35 <Xandaros> Seems to work fine
02:48:39 <freechips> basically every time i add a line i get 200 compiler errors. now a*(b-c) `mod` d -- not works
02:48:50 <freechips> Xandaros: don't know what to tell you..
02:49:42 <freechips> https://ptpb.pw/qUno
02:49:47 <Xandaros> Can you lpaste your code ... nvm
02:50:45 <freechips> for comparison, this is the original py https://ptpb.pw/9vMo
02:51:09 <freechips> i thought i would need just a couple of changes, but turning that small snippet into haskell is annoying
02:52:47 <Aruro> why do u need haskell?
02:52:53 <Aruro> for this code calculator is even better
02:53:08 <freechips> just wanted to try to see if haskell was faster
02:53:13 <Aruro> its not
02:53:17 <Aruro> haskell is slow on numerics
02:53:20 <freechips> also i want to get to use haskell sometimes
02:53:37 <Aruro> slowest of all
02:53:41 <freechips> ah
02:53:47 <freechips> cool...
02:54:12 <freechips> but you see im gonna do these calculations in a programming language because ill need to interwine the 2 things.
02:54:17 <freechips> i need programming more than numbers
02:54:29 <freechips> so im not gonna drop down to a calculator or bc or whatever..
02:55:38 <Xandaros> Ohh, I see... yeah, that's a subtle one
02:56:12 <Xandaros> Hmm, nope
02:56:49 <Taneb> freechips, do div' and mod' in Data.Fixed help? http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Fixed.html
02:57:33 <Aruro> freechips: define all your constants before main function, then no need of let
02:57:49 <Aruro> just main = print c
02:57:51 <Xandaros> freechips: let qinv = (truncate (1/fromIntegral q)) `mod` p
02:58:04 <Xandaros> Also, what Aruro said
02:58:46 <Xandaros> The (/) required q to be fractional, so it couldn't be integral anywhere else. It Is rather subtle
02:59:03 <freechips> Taneb: wut? im a noob
02:59:10 <freechips> Data.Fixed?
02:59:24 <freechips> Aruro: thanks!
02:59:29 <freechips> that's nice
02:59:36 <Aruro> freechips: haskell has rather complicated system for crunching numbers, and beginners should HATE haskell for that, i do
02:59:50 <Xandaros> I mentioned Data.Fixed earlier...
02:59:58 <freechips> what about the other non-constants? like m1 etc
03:00:06 <Aruro> also possible
03:00:19 <Aruro> they are just math functions (no input output actions involved)
03:00:38 <Aruro> everything above main and main = print c
03:00:40 <Aruro> no lets
03:00:55 <Xandaros> In your current code, they are also constant. They are just calculated constants
03:02:05 <freechips> Integer is not fractional?
03:02:34 <freechips> what if i just made a mod that extends to real numbers?
03:03:07 <freechips> much better than turning 1/q % p into what Xandaros wrote...it becomes hard to understand
03:03:34 <Xandaros> Data.Fixed.mod' is the first thing I mentioned -_-
03:03:53 <Xandaros> You didn't seem to want to use it
03:03:55 <freechips> ah ok i get it thanks Xandaros
03:04:04 <freechips> i did not understand it was an alternative implementation of mod
03:04:14 <Aruro> freechips: there http://lpaste.net/354198
03:04:21 <freechips> these subtleties really ruin the experience of haskell :(
03:04:38 <Aruro> freechips: yes, because u take number crunchin as easy task, its not
03:04:47 <Aruro> remember horrors of float rounding errors
03:05:20 <Aruro> just be patient, and u will make it
03:05:27 <Aruro> annoying but possible
03:10:25 <freechips> import Data.Fixed
03:10:27 <freechips> mod = Data.Fixed.mod'
03:10:34 <freechips> complains...i want to overwrite mod
03:10:41 <Aruro> say mod1
03:10:42 <freechips> also it seems to be working fine in ghci :D
03:10:50 <freechips> so i can't overwrite mod?
03:11:58 <freechips> Aruro: that lpaste gives me a lot of errors..
03:12:12 <freechips> ghc version 8.0.1
03:14:05 <freechips> i mean i can deal with truncate. but truncate + fromInteger is not bearable. id much rather say mod=Data.Fixed.mod' and use `mod` as if it were normal
03:15:37 <zaquest> freechips, you can't override, you can either specify which version you want with x `Prelude.mod` y or x `Data.Fixed.mod` y, or hide prelude's mod with import Prelude hiding (mod)
03:16:05 <Xandaros> You can just do import Data.Fixed (mod') and then use `mod'`
03:16:31 <zaquest> not Data.Fixed.mod, YourModuleName.mod i mean
03:17:19 <freechips> alright
03:17:22 <freechips> mod' it is
03:17:25 <freechips> not too bad i guess
03:20:10 <freechips> https://ptpb.pw/nITi had to add a couple of parens but otherwise pretty similar to the original py
03:20:19 <freechips> would you say that is good haskell style programming?
03:23:07 <Xandaros> One very important thing: Provide type signatures for your top-level definitions for documentation.
03:23:41 <Xandaros> You don't necessarily need that for your constants but something like "main :: IO ()" is imo missing.
03:23:59 <Xandaros> You may also want to indent the "print m"
03:24:45 <Xandaros> (The "do" is also superfluous, but let's not confuse you with the semantics of do just yet :P)
03:24:46 <zaquest> freechips, there's also no indentation in main, and you don't need do block for a single statement so just main = print m
03:26:18 <freechips> alright thanks.  id problably use signatures for a real program but this is just a quick number-script for now
03:30:25 <lpaste> ads pasted “sdf” at http://lpaste.net/354201
03:37:31 <jgt> hey folks
03:38:41 <jgt> I want to send my client a file from a Yesod app. I know I can do something like `sendFile "text/plain" "foo.txt"`, but this expects a file to exist at that path. Can I send a file response without actually writing this (temporary) file to disk?
03:38:50 <Aruro> onse without 
03:38:59 <jgt> or is it a better idea to just write to a temporary file before sending it?
03:40:21 <michi7x7> jgt: can't you just set the content-type  and content-disposition headers manually?
03:40:58 <jgt> michi7x7: Oh… I suppose I could. I hadn't thought of that
03:51:04 <jgt> michi7x7: that totally worked, and was very easy
03:51:09 <jgt> to an almost spooky degree
03:51:30 <jgt> so… Thanks!
03:52:22 <michi7x7> jgt: you're welcome
03:57:41 <freechips> it also looks like N is a reserved variable.....hmmm
03:58:10 <freechips> ah i cannot have variables that start uppercase
04:30:01 <fuzzy-id> may i ask what package you guys are using when it comes to date and time processing?
04:30:23 <fuzzy-id> i made a decision for hourglass and just found several drawbacks
04:31:01 <cocreature> fuzzy-id: I use the time package "time"
04:31:05 <fuzzy-id> e.g. no instance for Hashable, no arithmetics on for time periods and time stamps
04:31:11 <cocreature> eh remoe one of those times
04:32:03 <cocreature> fuzzy-id: fwiw the Monoid instance on periods in "hourglass" let’s you add them
04:32:51 <cocreature> and there is a "timeAdd" function to add intervals to dates
04:32:58 <cocreature> adding to time stamps doesn’t make sense
04:33:06 <fuzzy-id> ah, ok, i haven't seen the Monoid instance
04:33:56 <cocreature> I guess subtracting two periods might be slightly annoying
04:36:04 <fuzzy-id> i'll probably have a look at time anyways
04:36:19 <fuzzy-id> why did you choose it over hourglass, btw?
04:37:49 <cocreature> fuzzy-id: because it’s what most other people seemed to do :) iirc it’s even bundled with ghc
04:42:48 <Sh4rPEYE> Hey. I'd like to learn something about algorithms, preferably in Haskell (or at least some other functional language). My background is just high-school math, and I didn't even finish calculus yet. No CS whatsoever (i.e. I don't know anything about graphs or similar common CS data structures and algorithms and I feel I'm missing put a lot).
04:43:10 <Sh4rPEYE> Do you know any good book or resource I could use?
04:45:28 <Sh4rPEYE> I was looking at: Grokking algorithms (Python, though), Intro to algorithms (Scheme), SICP (less algorithm-y, but still pretty informative; Scheme).
04:45:45 <dysfun> hello. how can i write a lens over a data structure which depends on some data within that data structure?
04:46:27 <dysfun> (i have a map within the data structure and i need to lookup the 'current' key to navigate within it)
04:49:44 <michi7x7> Sh4rPEYE: you should probably just start with learn you a haskell. This should teach you the basics about implementing algorithms in Haskell
04:52:12 <Sh4rPEYE> michi7x7: I'm learning Haskell with "Haskell programming from first principles" and I find it really good! If I start with another introductory book now there might be a lot of needless repetition... Isn't there something dedicated to functional algorithms?
04:52:30 <Sh4rPEYE> The boo fits my needs in all other aspects
04:52:54 <cocreature> there is “pearls of functional algorithm design” but it’s not really targeted at beginners iirc
04:53:23 <Fendor> Learn yourself a Haskell for great good is imo one of the best books for beginners
04:53:32 <Fendor> introduces some algorithms too
04:53:45 <dysfun> a very different type of book though
04:53:50 <Fendor> yes
04:54:40 <Sh4rPEYE> When I searched 
04:55:26 <Sh4rPEYE> * sorry: when I looked for the best book to learn Haskell, LYAH was said to be too shallow. Thus I chose Haskellbook instead...
04:57:20 <Sh4rPEYE> Of course I can read it as well. I just though there'd be a lot of ground I'd already covered with HaskellBook. What about the books I takhled about? SICP/Intro/Grokking?
04:57:36 <Axman6> dysfun: yu might find it easiest to do it by hand: current (Foo cur mp) f = at cur f mp (I think)
04:58:01 <dysfun> :/
04:58:03 <Axman6> :t at 1
04:58:04 <lambdabot> (Functor f, Num (Index m), At m) => (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
04:58:37 <Axman6> :t at 1 @_ @_ @(Map k v)
04:58:38 <lambdabot> error: parse error on input ‘@’
04:59:28 <Axman6> dysfun: it's not like it's ugly or anything :\
05:01:05 <michi7x7> Sh4rPEYE: well, LYAH is very well structured. You can skip things you already know and probably find some hints here and there. Don't know about books deticated to algorithms though
05:02:41 <Axman6> ther's Okasaki's functional data structures book
05:03:17 <Axman6> but understanding the finer points in it requires a good grasp of laziness and its implications
05:03:38 <Axman6> Sh4rPEYE: what exactly do you mean by "functional algorithms" anyway?
05:05:57 <Sh4rPEYE> Axman6: I should've rather said "functional implementations" I guess. I could as well use a general algo book and implement them myself, but as I'm just a beginner, it'd be nice to check against something.
05:06:36 <Axman6> well look at Okasaki's book
05:07:15 <cocreature> Sh4rPEYE: I think one problem is that a significant portion of standard algorithms & data structures don’t fit easily in a functional paradigm
05:08:11 <cocreature> so you can either write an imperative algorithm in a functional language (which is a perfectly reasonable thing to do) or you try to look for other algorithms
05:08:25 <Axman6> paticulatly when such a large number of imperative programmer's algorithmic knowledge boils down to "why not just use a hashmap, they're constant time everything"
05:08:43 <cocreature> tbf hash maps are pretty great :)
05:09:33 <bennofs> Is it possible to have cabal fallback to hardcoded paths if pkg config is not available?
05:09:35 <Axman6> not if you need immutability
05:09:48 <bennofs> I thought using Manual: false flags would do that, but it seems it doesn#t
05:11:22 <Sh4rPEYE> cocreature: Yes, I was unable to find something myself... That's why I eventually came here to ask. 
05:11:56 <cocreature> Sh4rPEYE: it kind of depends on what your goal is. do you want to learn standard algorithms using a functional language or do you want to learn functional algorithms?
05:12:56 <Sh4rPEYE> cocreature: As I'm a beginner, I could benefit from both. I'd rather go the functional algorithms route, because I'm sure I'll have to learn imperative at the University.
05:13:37 <Sh4rPEYE> cocreature: Not mentioning functional algorihms will be more fun :-D
05:13:52 <Axman6> do you have any particular algorithms you want to now about?
05:14:02 <cocreature> Sh4rPEYE: I think I would recommend going with standard algorithms either in a functional language or even an imperative one first since most literature will probably assume you know those
05:15:17 <Sh4rPEYE> Axman6: Not really. I keep hearing graphs are great for various programming tasks, so maybe some algos associated with that.
05:15:31 <Sh4rPEYE> cocreature: And what would you recommend for that?
05:15:59 <Axman6> I've never actually found a use for a graph structure
05:16:59 <cocreature> Sh4rPEYE: the standard book on that topic is “introduction to algorithms” but personally I’ve mostly learned them from the lecture notes associated with the courses I attended
05:18:31 <Sh4rPEYE> Axman6: Well then I've been mystified. What algos should I learn in your opinion then?
05:19:08 <Sh4rPEYE> I know the questions I keep asking are too general; it's just that I don't know almost anything about the matter, so I have to ask in this stupid way.
05:19:24 <cocreature> unless you have some specific application in mind, learn a few of each category so you know what’s out there when you’re trying to solve a problem
05:19:52 <Sh4rPEYE> cocreature: Ok, so I'll take a look at the Intro to algorithms
05:20:01 <cocreature> you can spend years studying sorting algorithms but that won’t help you if your programs doesn’t have anything to do with sorting
05:20:08 <cocreature> and the same holds for any other category of algorithms
05:20:36 <Sh4rPEYE> Sure. Some general knowledge is something I had on my mind initially
05:46:08 <kgadek> hi. I'm wondering on real-world usage of various exceptions. Async seem unmanageable, I think I recall someone mention disadvantages to checked exceptions. Need food for thought, any good pointers?
05:46:43 <Aruro> Sh4rPEYE: u can study this https://en.wikipedia.org/wiki/List_of_algorithms
05:47:49 <Aruro> Sh4rPEYE: then this https://en.wikipedia.org/wiki/Computational_complexity_theory
05:49:39 <_sras_> I am seeing some spooky behavior in ghci. One of my programs produce a different output when run immediatly after a compile. 
05:49:59 <_sras_> Output changes when it is run a second time.
05:50:04 <mniip> petition to expand the r/haskell icon 2 pixels down and use a readable 3x5 font
05:51:48 <_sras_> Both of the times, the program is stuck in an infinte loop, so I have Ctrl c it. But when run immediately after a compile, it prints some output from 'traceShow' calls. This disappear when running the same function a second time.
05:53:48 <kgadek> _sras_: looks like race condition
05:54:05 <kgadek> I can imagine that after compile, the app is in cache so is quicker to get to some state
05:54:34 <kgadek> or the other way around: first exec causes cache-miss, subsequent will be ran from cache
05:54:44 <kgadek> do you have a good repro?
05:57:51 <mbw> Hello everybody. Is there some tutorial-like literature about deriving parallel versions of sequential functions? I have found quite a few papers which deal with monoid/list homomorphisms, which once identified seem to imply the possibility of a divide&conquer approach. However, all these papers seem to deal with automatic parallelization by a compiler, not "by hand", for instance via equational reasoning. 
05:57:57 <mbw> To me it seems there is a huge gap between "foldMap == mapReduce :D" and stuff aimed at compiler implementers...
06:00:32 <_sras_> kgadek: repro?
06:00:49 <kgadek> code that reproduces the issue
06:00:52 <kgadek> that you can share
06:05:12 <drdo> Hmm, is there any way to call a function with an explicit class instance?
06:05:59 <Aruro> :t read :: String->Int
06:06:01 <lambdabot> String -> Int
06:07:25 <drdo> Aruro: The problem is really that you can only have one instance for Int, in that example
06:12:23 <Aruro> drdo: elaborate
06:14:07 <drdo> Aruro: Imagine you want to print something of type [A]
06:14:38 <drdo> But you want to print the As in some way different from the Show instance of A
06:15:36 <drdo> the show function for List takes an implicit argument of the Show instance to print the elements with
06:15:47 <drdo> I'd like to explicitly pass that Show instance
06:36:45 <bollu> if there's a function of the form f :: (a -> b) -> c. At runtime, can I "peek" at what function the first parameter is to "f"?
06:36:53 <bollu> I don't care if this involves deep GHC magic
06:38:04 <bollu> I want to inspect the body of (a -> b)
06:38:16 <bollu> actually, is this possible with TH at compile time at least?
06:38:50 <madgen> Hello, do type class laws needs only apply at semantic level or syntactic as well?
06:39:40 <madgen> e.g. having an explicit Append constructor and instantiating to Monoid might lead to values with different associativity syntactically, but are really the same
06:41:12 <erisco> madgen, the laws are stated with an unspecified equality (as far as I can tell) but it is assumed to be whatever == is
06:41:55 <cocreature> bollu: in general you can’t, even at compile time. the definition of the function might not be available (e.g. if it is from a separate module).
06:42:06 <bollu> cocreature: ah, unfortunate
06:42:18 <madgen> erisco: hmm, not the answer I was hoping for, but oh well. Thank you very much!
06:42:19 <bollu> cocreature: I'm trying to JIT out a free monad at compile / runtime
06:42:46 <bollu> cocreature: so to encode the branches of the language of the form Lang next = Get Key (Value -> next) | …
06:42:58 <bollu> I need to be able to find out which function is passed to Get
06:43:00 <erisco> madgen, what answer were you hoping for?
06:43:04 <bollu> cocreature: any ideas on how to solve this?
06:43:59 <madgen> erisco: "it won't blow up in your face if you use it like that" or something to that effect
06:44:19 <cocreature> bollu: what exactly do you hope to end up with?
06:44:44 <erisco> madgen, can you explain your circumstance more?
06:45:02 <bollu> cocreature: a way to feed in a free monad and get out corresponding LLVM
06:45:09 <bollu> cocreature: either at compile time or at runtime
06:45:17 <_sras_> kgadek: When I change a division operation into an addition, it runs to completion....
06:45:23 <erisco> "having an explicit Append constructor" does this just mean Append is a constructor? "instantiating to Monoid" does this just mean there is an instance of Monoid for the type of Append?
06:45:50 <_sras_> kgadek: the concerned datatype is Scientific
06:46:14 <erisco> "lead to values with different associativity syntactically but are really the same" well, that is the associativity law
06:46:18 <madgen> erisco: So I have a bounded lattice over an elaborate mathematical structure, in which equality is non-trivial, instance of a bounded lattice requires absorption but it is not always clear if the operand is top or bottom without further evaluation
06:47:04 <madgen> erisco: so I was thinking of representing Meet and Join explicitly as data structures
06:47:47 <kgadek> drdo: if you want your own Show instance, just write a newtype. Then you just use `show . PrintWithMyCustomFunction`
06:47:53 <madgen> erisco: with the whole Append thing I was giving a simpler example, but yeah basically do I need the law to be satisfies with `==` is my actualy question as your paraphrased very nicely
06:48:01 <cocreature> bollu: that’s definitely not possible at runtime. at compile time you could try to lookup the definition and throw an error if it’s not available
06:48:13 <cocreature> bollu: but really if you want to JIT I wouldn’t allow arbitrary Haskell functions
06:49:17 <kgadek> _sras_: if you're dealing with race condition, the change of div into (+) could have random impact. Inc. "now the program seems to work"
06:49:19 <kgadek> *incl
06:49:49 <_sras_> kgadek: From the documentation page of Data.Scientific. "WARNING: recip and / will diverge (i.e. loop and consume all space) when their outputs are repeating decimals."
06:50:04 <_sras_> is this what is happening?
06:51:12 <kgadek> hmm, doesn't look like so
06:51:20 <erisco> madgen, == does not have to be structural equality. maybe that helps you
06:51:28 <kgadek> _sras_: do you have any parallelism in your code?
06:51:35 <_sras_> kgadek: No
06:51:50 <drdo> kgadek: right, there's the newtype trick
06:51:54 <drdo> thanks
06:52:26 <madgen> erisco: Indeed. Anyway, thank youuu.
06:54:14 <bollu> cocreature: hm, but I'm not sure how to restrict this to "subset of Hask"
06:54:27 <bollu> cocreature: interesting, let me try this at compile time
06:54:42 <cocreature> bollu: well just make an ADT that represents the language you can actually JIT
06:55:05 <bollu> cocreature: but at that point, I lose the ability to use do-notation to represent variable binding? that is what makes the free monad so cute
06:55:27 <bollu> cocreature: do's <- automatically becomes the Lang's (Value -> next)
06:55:32 <cocreature> bollu: not necessarily. depending on your ADT you can provide an instance of Monad
06:55:38 <bollu> cocreature: really?
06:55:40 <bollu> cocreature: example?
06:55:53 <bollu> cocreature: I've never seen this before
06:56:13 <kgadek> _sras_: hm. Honestly, don't know what to tell you now. Don't have much time now to investigate, sorry. This could be "this thingy from Scientific has a bug", "this thingy from Scientific is implicitly parallel", to even "ghc bug"
06:56:25 <freechips> can i find something like python's 3 parameter pow in haskell?
06:56:50 <freechips> like when you have a**b % c then you can use pow(a,b,c) and it will be much faster
06:57:00 <freechips> because of another algorithm
06:57:04 <cocreature> bollu: https://github.com/angerman/data-bitcode-edsl/blob/master/src/EDSL/Example/HelloBranch.hs#L22
06:57:25 <bollu> cocreature: neat, much appreciated
06:57:41 <kgadek> freechips: you think about modulo exp. I don't recall this being in stdlib
06:58:03 <bollu> cocreature: has anyone tried this before?
06:58:04 <angerman> cocreature: you keep on plugging my edsl :p Thanks :D
06:58:10 <bollu> cocreature: JITting free / something similar?
06:58:17 <bollu> angerman: hey :)
06:58:17 <cocreature> angerman: it’s pretty neat!
06:58:44 <kgadek> freechips: https://rosettacode.org/wiki/Modular_exponentiation
06:58:52 <angerman> cocreature: hope I'll be able to get back to that... however currently the linker is more important.
06:59:32 <cocreature> angerman: judging from your ramblings in #ghc your pain tolerance seems to be quite high given than you’re still working on the linker :P
07:00:00 <angerman> cocreature: well. "Der Weg ist das Ziel"? :p
07:00:10 <cocreature> heh
07:00:11 <kgadek> freechips: this ^ could be your starting point. I would certainly try to generalize this code. And if you hit performance issues with this code, specialize (unbox) version
07:00:42 <angerman> cocreature: as long as I'm making *some* progress, I'm happy. And elf/armv7 is working proper now. 
07:01:10 <cocreature> angerman: btw, why are you working on the linker? I missed the beginning of all this :)
07:01:19 <angerman> cocreature: just found out we don't have *any* elf/aarch64 code. And there I was thinking, that excoding macho/aarch64 was missing because no one used it. Didn't know how wrong i was.
07:01:27 <angerman> cocreature: TH all the things.
07:01:46 <freechips> kgadek: thanks! this site is cool, it'll tell you the best possible manner to to this, such that if i didn't know a function was in the stdlib i would find out
07:01:50 <cocreature> angerman: ah is that the “TH in crosscompilation” stuff?
07:01:55 <angerman> cocreature: yep
07:01:59 <cocreature> nice
07:02:01 <freechips> anyway haskell doesnt have it in the stdlibs....kinda sad
07:02:17 <bollu> cocreature: so you;re telling me that I can build an EDSL with do-notation and still have compile-time /runtime inspectability?
07:02:55 <bbear> is the Foldable type class a Monad ?
07:03:16 <bollu> bbear: no, not all Foldable are Monad.
07:03:31 <bbear> :t (find foo where foo _=true)
07:03:33 <lambdabot> error: parse error on input ‘where’
07:03:50 <bbear> and List is a Monad ?
07:04:01 <bollu> bbear: yes, it is
07:04:34 <bbear> I am trying to get a working example of chaining operations with (>>=) using Lists and Maybe
07:05:15 <cocreature> bollu: well, if you want to use do-notation only for variable binding you should be able to just use some State Int monad that generates new names and then use those
07:05:24 <cocreature> wrap this up behind a nice API and you should be good to go
07:07:08 <bollu> cocreature: cool
07:07:29 <bollu> cocreature: I'm assuming this can be inspected at compile time as well?
07:07:51 <cocreature> bollu: well you run into the same problems of definitions potentially not being available
07:08:09 <kgadek> drdo: not actually a trick, this was (AFAIK) newtype
07:08:15 <kgadek> 's design goal
07:08:36 <bollu> cocreature: I see. worth a shot though
07:08:47 <cocreature> bollu: at least you can definitely inspect them at runtime
07:09:05 <bollu> cocreature: think I'll get any speedup by doing this?
07:09:29 <cocreature> bollu: what is “this” and what are you comparing the performance to?
07:09:36 <_sras_> kgadek: evaluating 1/3 from ghci indeed hangs.
07:09:42 <bollu> cocreature: let's say I implement a DSL to express stencil computations.
07:09:48 <cocreature> JITing can obviously improve performance
07:09:51 <bollu> yeah
07:09:52 <bbear> :t let lowerCase = ['a'..'z'] in [[x,y,z]|  x<-lowerCase , y<-lowerCase, z<-lowerCase]
07:09:53 <lambdabot> [[Char]]
07:10:02 <bollu> has someone tried this? If not, I find this to be an interesting experiment :)
07:10:14 <bollu> cocreature: It would be nice if I can package this up as a library or something
07:10:44 <cocreature> lot’s of people have tried JITing languages
07:11:10 <_sras_> So the question is "How can I divide two scientific values and safely limit the computation to some number of decimal places"
07:11:14 <bollu> cocreature: yes, I know that :) But, I meant, an embedded easy to use haskell DSL
07:11:25 <cocreature> bollu: I guess you can see accelerate as one such example
07:11:39 <cocreature> anthony cowley also has one but it’s not public
07:11:56 <cocreature> stephen diehl probably has worked on several of those iirc
07:12:14 <bollu> cocreature: Interesting
07:12:22 <bollu> cocreature: cool, thanks for the pointers
07:16:01 <_sras_> How can I safely divide two scientific values, without getting into an endless loop?
07:16:38 <abhiroop> Are there any examples of actually parsing binary data using binary or cereal or attoparsec available? I could not find anything
07:20:24 <bbear> OMG I understood Monads
07:20:46 <bbear> I just chained two operations together.
07:21:41 <bollu> bbear: :)
07:24:16 <cocreature> bbear: it’s obligatory that once you have understood monads, you write a monad tutorial
07:24:59 <bbear> let myDict = let lowerCase = ['a'..'z'] in [[x,y,z]|  x<-lowerCase , y<-lowerCase, z<-lowerCase] in (>>=) (find (\x-> (head x)=='u') myDict) (find (\x-> x=='a'))
07:25:24 <bbear> yes I thought about that « teaching Haskell the right way »
07:26:36 <bbear> I am not sure I fully understand it yet and, well, I think probably the most effective way to learn Haskell is to try to solve real problems.
07:27:10 <bbear> :t let myDict = let lowerCase = ['a'..'z'] in [[x,y,z]|  x<-lowerCase , y<-lowerCase, z<-lowerCase] in (>>=) (find (\x-> (head x)=='u') myDict) (find (\x-> x=='a'))
07:27:11 <lambdabot> Maybe Char
07:28:09 <_sras_> Can someone help  be explain the behaviour of Scientific library when it just hangs on evaluating (1/3), when I am only asking to print a couple of decimal places.
07:28:27 <bbear> I must master (return) now
07:30:39 <bbear> this video is not bad https://www.youtube.com/watch?v=gEoruozy3mk
07:33:12 <bbear> what is the return useful for ?
07:33:20 <bbear> Just to end the Monadic chain ?
07:35:01 <bollu> bbear: it's used to lift a non-monadic value into the monad's context
07:36:19 <bbear> ha yes
07:40:37 <_sras_> bbear: it just "wraps" the given value in the expected data type. so return 4 :: [Int] will give you [4], and return 4 :: Maybe Int will give you 'Just 4'...
07:41:12 <bbear> ah ok
07:41:31 <_sras_> bbear: if you are wondering where the "expected" part, come from, it is from type inference mechanism.
07:41:50 <ggVGc> imo, return is a very bad name
07:42:19 <ggVGc> pure is much more descriptive
07:42:26 <bbear> :t read "11" ::Int  
07:42:28 <lambdabot> Int
07:43:13 <jmcarthur> I think neither return nor pure are great names.
07:43:42 <jmcarthur> But agreed that pure is better than return.
07:43:48 <_sras_> bbear: Yes. something similar. Here, Haskell know that you want an Int. So it calls the "read" function in the "Read" instance of the Int.
07:44:20 <bbear> Read is a typeclass ?
07:44:28 <_sras_> Yes
07:44:32 <bbear> Like Monad is typeclass
07:44:39 <_sras_> Exactly
07:44:48 <bbear> typeclass is really at the top of everything in Haskell ?
07:46:01 <_sras_> bbear: I am not sure about that.. :)
07:46:40 <_sras_> bbear: I mean, I am a beginner myself.
07:47:15 <cocreature> bbear: what exactly do you mean by “at the top of everything”? what concepts are we talking about here and when is one of those above another one?
07:49:39 <bbear> typeclass defines a lot of things I mean.
07:51:23 <cocreature> typeclasses are an important concept, yep
07:52:38 <orion> And yet, there are those who say that you should avoid typeclasses because you likely won't need them.
07:53:48 <cocreature> they might say that you should avoid _creating new typeclasses_. but I’ve never heard anybody say that you shouldn’t use typeclasses at all.
07:53:55 <orion> cocreature: That's what I meant.
07:53:59 <_sras_> Can someone tell me how am I supposed to work with monetary values stored in Scientific. It turns out that I cannot use it in currency conversions because it gets into an endless loop when the result in a repeating fraction..
07:54:24 <cocreature> and the most vocal proponent of this (gabriel) has slightly retracted his statement since iirc
07:54:30 <orion> _sras_: Can you give a concrete example?
07:55:03 <_sras_> orion: https://github.com/basvandijk/scientific/issues/38
07:56:06 <_sras_> orion: It just hangs, even when I use a function to print it, that is supposed to print only a specified number of decimal places.
07:56:37 <bbear> you can't write a concat function in monadic way ?
07:59:38 <bbear> https://youtu.be/mlTO510zO78?t=1435
08:00:30 <Cale> bbear: join
08:00:40 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
08:00:42 <lambdabot>  [1,2,3,4,5,6,7,8]
08:00:47 <Cale> :t join
08:00:48 <lambdabot> Monad m => m (m a) -> m a
08:02:07 <cocreature> bbear: if you want an exercise, try implementing the "join" function Cale showed using ">>=" :)
08:02:25 <bbear> yes I was looking for that sort of challenge.
08:02:54 <bbear> Is that sort of thing implemented separately for each Monadic type ?
08:03:04 <cocreature> nope
08:03:36 <_sras_> cocreature: nope?
08:04:06 <Cale> Only (>>=) and return are implemented separately
08:04:07 <bbear> so there is only one join for all Monads ?
08:04:16 <Cale> Everything else derived from them is written only once
08:04:17 <bbear> okay
08:04:23 <cocreature> _sras_: join is not implemented separately for each type. it’s implemented in terms of ">>=". that however is implemented separately for each type
08:04:26 <Cale> That's actually kind of the entire point of Monad right there
08:04:49 <cocreature> or of typeclasses in general :)
08:04:52 <Cale> yes
08:04:55 <bbear> and what is the implementation of (>>=) for lists ?
08:05:07 <Cale> Or even more generally, it's the point of abstraction ;)
08:05:18 <Cale> Well, let's look at its type
08:05:22 <Cale> and see if we can guess
08:05:24 <noam> I'm trying to derive Eq instance for a parameterized type, but can't get it to work, help? code: http://rextester.com/WOAI98630
08:05:29 <Cale> [a] -> (a -> [b]) -> [b]
08:05:29 <Fendor> > [1,2,3] >>= (2*)
08:05:31 <lambdabot>  error:
08:05:32 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M588818997035...
08:05:32 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
08:06:02 <Cale> So you give it a list of values of type a, and a function which given a value of type a, will produce a list of values of type b, and it somehow gets you a list of values of type b
08:06:06 <_sras_> Cale: No. I thought bbear was asking if every Monadic type has to implement its own Monad instance.
08:06:11 <Cale> ah
08:06:19 <Cale> Well, *that* is the case
08:06:26 <Aruro> > [1,2,3] >>= return . (2*)
08:06:28 <lambdabot>  [2,4,6]
08:07:01 <glguy> noam, it looks like you're done
08:07:27 <Fendor> Aruro, thanks, tried to find my error for the last 2 minutes
08:07:31 <Cale> bbear: So, the obvious thing to start would be to apply the function to all the elements of the given list:
08:07:44 <noam> glguy: i get ```Variable ‘a’ occurs more often than in the instance head
08:07:45 <noam>       in the constraint: Eq (f a)```
08:07:45 <Cale> xs >>= f = ... map f xs ...
08:07:47 <bbear> (>>=) [1,2,3] return
08:07:53 <Cale> but map f xs has type [[b]]
08:07:57 <Cale> while we want [b]
08:08:14 <Cale> So, the obvious thing to do then is to concatenate :)
08:08:22 <cocreature> noam: does enabling "FlexibleInstances" work?
08:08:23 <glguy> noam, ah I guess that got cut off in the paste
08:08:25 <Cale> xs >>= f = concat (map f xs)
08:08:47 <Cale> > (>>=) [1,2,3] return
08:08:49 <lambdabot>  [1,2,3]
08:08:59 <glguy> Noam, you can either add a Show1 constraint to do it or separate constraints for f String
08:09:03 <Cale> One of the monad laws is that x >>= return is always x
08:09:22 <glguy> and f Int
08:09:50 <_sras_> bbear: Also, it might me well to mention that every instance of the Monad you write have to obey the Monad laws. https://wiki.haskell.org/Monad_laws
08:10:23 <glguy> Noam, it doesn't help to have a constraint on  f a, that a isn't related to String or Int
08:10:40 <cocreature> if your Monad instance doesn’t obey the laws you’ll get arrested
08:10:43 <Aruro> _sras_: does not have, better have
08:10:51 <cocreature> by the monad police
08:11:23 <bbear> but thats useless since I already had x 
08:11:39 <noam> glguy: I want it to be general so i can later put any Eq-type in `PersonF`. No idea what is this `Show1` thing is :p
08:11:49 <bbear> nevermind
08:12:19 <glguy> Noam, ok, then you'll need to read about Show1
08:13:02 <glguy> http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor-Classes.html#t:Show1
08:13:32 <glguy> that's the version in base, which is a little harder to use than the one in prelude-extras
08:15:14 <dzdcnfzd> I was trying to stack build a package that depends on stack using an EC2 Micro Instance and I kept getting compiler errors with exit code -11. geekosaurus, here, suggested it could be a memory issue. Does anyone have experience developing on EC2 with Haskell, or generally have any pointers about how much memory I'll likely need?
08:15:41 <noam> glguy: I'll check this out. Do I need Show1 or Eg1? (well actually I want both Show and Eq instances anyway)
08:20:50 <cocreature> dzdcnfzd: less than 2gb is probably going to be problematic
08:22:02 <glguy> dzdcnfzd: it completely matters what you are compiling
08:22:26 <dzdcnfzd> glguy: in this case I just added "servant" to the deps
08:22:37 <dzdcnfzd> and it started running into problems
08:22:56 <lpaste> lambdafan pasted “open a file skipping the first line” at http://lpaste.net/354209
08:22:57 <Aruro> why liftA functions are not in prelude? since applicative is
08:23:26 <lambdafan> Check out BasicPrelude, or any of the others.
08:24:24 <lpaste> lambdafan revised “open a file skipping the first line”: “open a file skipping the first line” at http://lpaste.net/354209
08:24:55 <Aruro> seems authors are not annoyed to write x <$> y <*> z all the time
08:25:01 <Cale> Aruro: I'm not sure, but there's a lot of politics involved in getting anything into the Prelude.
08:25:19 <lambdafan> Isn't that why other preludes have appeared?
08:25:31 <Cale> It was already pretty challenging to get Applicative in there on its own :)
08:25:43 <noam> glguy: If I understand the docs correctly, I need to define the instance of `Eq1` myself, and this will be a lot of boilerplate for a larger type or multiple type. I'd rather avoid boilerplate.
08:26:04 <dzdcnfzd> cocreature: if I get a 2gb instance, do you think that'd work
08:26:28 <Cale> Aruro: and yeah, usually people actually do use <$> and <*> over liftAn, perhaps because it's a little easier to manipulate
08:26:37 <cocreature> dzdcnfzd: maybe? as glguy said it really depends on the things you compile
08:26:43 <erisco> Aruro, if that reason alone was acceptable then everything involving Applicable would be in Prelude. you see the problem?
08:26:45 <_sras_> orion: Any luck?
08:27:07 <dzdcnfzd> cocreature: what's the important metric? Number of transitive deps?
08:27:13 <glguy> noam, yeah, the design you're using will require some extra work
08:27:18 <Welkin> Aruro: <$> <*> is more general
08:27:43 <erisco> and, really, why should Prelude be bigger? import what you need
08:27:49 <Cale> Applicable ;)
08:27:52 <cocreature> dzdcnfzd: the number of deps does not matter unless you want to compile them in parallel. it depends on the code inside those deps :)
08:28:05 <erisco> Cale, I see I missed an opportunity :P
08:28:16 <Welkin> it' common for haskell files to have 20 or 30 lines of imports at the top
08:28:17 <Welkin> that is normal
08:28:19 <erisco> take (.) for example
08:28:22 <Welkin> import away
08:28:23 <glguy> there might be ghc.generics code or template haskell code to automate instance generation. I don't remember
08:28:34 <erisco> if you would rather (.) from Category then you have to hide the Prelude definition of it
08:28:35 <Cale> Welkin: Yeah, it's actually kind of annoying :)
08:28:37 <Aruro> typing <$> is not best thing in life
08:28:40 <Welkin> lol
08:28:46 <erisco> and so the more you put into Prelude the more it conflicts with other modules
08:28:51 <dzdcnfzd> cocreature: I see. Is there any way, as a dev, I can make these guesses? "I'm compiling an app which uses libs X, Y, and Z. How much memory am I likely to need?"
08:28:52 <noam> glguy: I looked at generics and it might be what I want yes. looks super complicated though
08:29:03 <dzdcnfzd> or is this just totally guesswork
08:29:12 <Cale> I really wish there was at least a way to combine together all the imports of the same module
08:29:28 <Welkin> Cale: alternative preludes?
08:29:29 <noam> glguy: In any case thanks for the `Eq1` pointer. I wouldn't have found it myself
08:29:32 <cocreature> dzdcnfzd: just try it out :)
08:29:40 <Welkin> Aruro: you could import an alternative prelude if you want
08:29:53 <Welkin> there are many
08:30:00 <Cale> I'd love to be able to write things like  import Data.Text (Text), qualified as T
08:30:17 <cocreature> Cale: it’s a shame that anthony’s proposal for that got stuck
08:30:24 <Welkin> Cale: what do you mean?
08:30:53 <Cale> Welkin: That would unfold to
08:30:57 <Cale> import Data.Text (Text)
08:31:05 <Cale> import qualified Data.Text as T
08:31:10 <dzdcnfzd> cocreature: in particular, with this build, the error code is -11, which is segfault -- how would you go about verifying that it's an oom issue? (see https://github.com/commercialhaskell/stack/issues/2575#issuecomment-248172456 for an example of why I think it is)
08:31:13 <Welkin> oh
08:31:27 <Aruro> there should be applicative tick like 'm' means m <$> x <*> y
08:31:28 <Welkin> I'm okay with typing imports multiple times
08:31:45 <Aruro> i hate imports, super ugly
08:31:56 <erisco> Aruro, use Idris where they have idiom brackets
08:32:00 <Welkin> Aruro: you can extend the language however you want
08:32:08 <Cale> It's not the worst thing in the world, but it's kind of annoying. Especially the maintenance of those imports with respect to warnings that you're importing things redundantly
08:32:11 <Welkin> everything is just libraries
08:32:31 <Welkin> but beware that you may make your code impossible for others to read/use
08:32:43 <Cale> Like, I might not actually need the unqualified import of Text because maybe none of my type signatures in the module involve Text yet.
08:33:28 <Cale> I could just ignore the warning, but those warnings are in general pretty useful for trimming the imports :)
08:33:38 <Welkin> Aruro: also, you just described liftA2
08:33:52 <Aruro> yes, i was complaining why its not in prelude
08:34:12 <Welkin> forget about the prelude
08:34:17 <Welkin> it's just there for convenience
08:34:23 <erisco> import Prelude ()
08:34:25 <Welkin> it is not meant as a "Standard library" like in other languages
08:34:37 <Cale> You basically can't write anything nontrivial in Haskell anymore without importing at least a handful of modules.
08:34:45 <Aruro> why not, i want no imports
08:35:01 <erisco> first you have to set up your LANGUAGE pragma with a dozen extensions
08:35:05 <Cale> :D
08:35:06 <erisco> that's even before you get to importing :P
08:35:09 <Welkin> Aruro: then create a file called Imports.hs with all your imports, done
08:35:30 <Aruro> Welkin: true :)
08:35:47 <Cale> Actually, I think it might be better to have separate pragmas now, Ed Kmett style, just because it makes them easier to manipulate.
08:36:09 <Welkin> Cale: what is ed's style?
08:36:17 <Cale> One LANGUAGE pragma per line
08:36:22 <Welkin> oh, yeah
08:36:24 <Welkin> I use that too now
08:36:33 <Welkin> I saw it in many places and just started using it
08:36:59 <Cale> (I'm associating that with him just because some of his talks started with a slide filled with pragmas :D)
08:37:08 <Welkin> but then you need to line up the closing brackets of all of them
08:37:14 <Cale> no
08:37:19 <Welkin> yes!
08:37:32 <Cale> I also don't like lining up module names and import lists in the imports
08:37:37 <Welkin> o.o
08:37:55 <Cale> It just wastes time, and makes things hard to edit
08:38:12 <Welkin> everything needs to be lined up perfectly
08:38:12 <Cale> You add a new import with a longer name, and then you have to edit everything again
08:38:35 <tsahyt> I do like to keep qualified imports separate from unqualified ones
08:38:35 <erisco> this is my style http://lpaste.net/354211
08:38:36 <Cale> and it doesn't actually make anything more readable, since those are separate unrelated things
08:38:44 <jmcarthur> I love the idea of hindent, if only it supported a style I liked.
08:38:52 <tsahyt> i.e. in a separate block of imports, separated by an empty line
08:39:09 <Cale> tsahyt: I like to keep them in alphabetical order, ignoring the qualified bit
08:39:21 <Welkin> lol what
08:39:26 <Cale> I really really wish that the syntax was  import Foo qualified as ...
08:39:31 <tsahyt> Cale: yeah me to. I sometimes forget doing that though, so I end up with ordering commits.
08:39:33 <Welkin> Cale: you don't like to line them up, but they need to be alphabetized?
08:39:39 <tsahyt> jmcarthur: Is this yours? http://hackage.haskell.org/package/stable-memo
08:39:41 <Welkin> o.o
08:39:48 <Cale> Welkin: yeah, because that serves a purpose when you're trying to find stuff
08:39:49 <jmcarthur> tsahyt: yes
08:39:50 <Welkin> alphabetizing is the most annoying thing ever
08:39:51 <Welkin> I hate it
08:40:11 <tsahyt> jmcarthur: I just remembered when I saw your nick. It doesn't compile with GHC 8 anymore, due to a version bound problem.
08:40:18 <tsahyt> On ghc-prim iirc
08:40:21 <Cale> Well, you can almost just sort, except for the qualified ones :)
08:40:24 <Welkin> I tend to group by purpose
08:40:24 <Aruro> why ghc does not infer imports from types?
08:40:32 <Aruro> in most cases there are no problems
08:40:35 <Cale> Welkin: Oh, I do that too actually.
08:40:39 <glguy> Aruro: because it infers types from imports
08:40:53 <Welkin> all of the containers go together, all of the control modules together, specific libraries, internal modules
08:41:07 <jmcarthur> tsahyt: I really need to stay on top of these things. Thanks for letting me know. I will update it. I should probably also throw all my projects on github just so there is a reasonable place for people to file bug reports like this...
08:41:20 <Cale> Usually project imports are separate from imports from our in-house library of miscellany which are separate from external imports.
08:41:21 <sm> Welkin: omg that would be an endless project
08:41:53 <sm> I group by mine / external, that's it
08:41:54 <jmcarthur> tsahyt: What I first made that I was still on my stubborn kick of using darcs (and I'd still like to be, but I have since compromised on only using darcs for projects I don't intend to share with others...)
08:41:59 <tsahyt> jmcarthur: it's been a while but it compiled just fine after just changing the version bound, and from what I could gather nothing should be affected by the changes in ghc-prim, but I didn't test it properly. I ended up needing something that worked via Eq on the keys
08:42:22 <jmcarthur> tsahyt: Thanks!
08:42:50 <tsahyt> you're welcome. I figured it's such a small change that sending an actual patch would be more work than just telling you. I just never got around to it :)
08:43:12 <tsahyt> more work in applying the patch I mean
08:43:13 <sm> jmcarthur: the darcs authorities notice you have not yet reported to darcs hub yet.
08:44:05 <tsahyt> I should maybe have a look at darcs one day. but git also does everything I want from it.
08:46:06 <jmcarthur> sm: I haven't?
08:46:07 <sm> jmcarthur: oops, the darcs authorities are wrong. Their bureaucracy is imperfect, thank god
08:46:14 <jmcarthur> :)
08:47:31 <tsahyt> since people keep asking me about haskell books, were there ever any plans of a second edition of real world haskell?
08:47:32 <erisco> {#- LANGUAGE x, y #-} = {-# LANGUAGE x #-}; {-# LANGUAGE y #-}   it's a monoid morphism :3
08:47:48 <tsahyt> I used that book back then and it was already slightly outdated, but I found it to be a very good resource for learning the language initially
08:49:32 <erisco> "book, back then" not "book back, then" heh
08:51:02 <Aruro> its one of those rare books which treated haskell like programming language not like Cathegory Theory toy
08:52:19 <tsahyt> yes. it's probably part of the reason why I saw practical value in the language from the very start. I only later got bogged down in exploring all the nice abstractions
08:52:39 <hsk3> These two books are great for beginners: http://learnyouahaskell.com http://haskellbook.com
08:52:41 <tsahyt> but I'm also a sucker for elegant design based on mathematical ideas
08:52:46 <tsahyt> so I'd have stuck with it either way I guess
08:52:54 <hsk3> i'm a sucker for pure funcs
08:52:56 <tsahyt> hsk3: they're what I usually recommend these days
08:53:02 <Welkin> I couldn't get into RWH
08:53:03 <Welkin> o.o
08:53:23 <hsk3> RWH was really bad imo, sorry to say. I was spending 99% of my time reading about some goddamn JSON parser lol
08:53:26 <hsk3> gave up
08:53:36 <Welkin> lol, exactly
08:54:31 <jmcarthur> I don't have unit tests for this. Wat.
08:55:13 <erisco> you always have the mempty test
08:55:26 <Aruro> hsk3: a least it was the book which described clearly crap like hSetBuffering
08:55:36 <tsahyt> hsk3: that's a bit of an exaggeration. the JSON example is really rather short
08:56:06 <hsk3> maybe i'll try it again
08:56:19 <hsk3> now that i know more about it. always good to learn stuff from diff authors
08:56:24 <hsk3> u get diff take on things
08:56:40 <Aruro> haskell designers hate beginners, this book helped that part
08:57:26 <Aruro> solving real world things with begginner unfriendly tool
08:57:51 <tsahyt> hsk3: the libraries used in RWH are really outdated these days. you'll probably run into quite a few problems because the APIs simply aren't the same anymore
08:58:04 <hsk3> ah damn
08:58:04 <hsk3> ok
08:58:09 <hsk3> thanks for the heads up
08:58:23 <erisco> the meaning people often ascribe to "real world" either doesn't understand what "real" or "world" means
08:59:13 <Welkin> it's a crappy reality tv show
09:00:34 <Aruro> just today guy got stuck in ingenious design of haskell numerical classes, i think he went back to python
09:00:37 <tsahyt> Aruro: I've found that the haskell language as such is actually very beginner friendly. it's the towers of abstraction that we've come to love and expect that isn't
09:00:49 <NikolajK> does Haskell have join for IO (IO ())?
09:01:02 <erisco> yes, as do all instances of Monad
09:01:13 <tsahyt> :t join (f :: IO (IO ()))
09:01:14 <lambdabot> error:
09:01:14 <lambdabot>     • No instance for (FromExpr (IO (IO ()))) arising from a use of ‘f’
09:01:14 <lambdabot>     • In the first argument of ‘join’, namely ‘(f :: IO (IO ()))’
09:01:16 <tsahyt> damn
09:01:20 <tsahyt> :t join (undefined :: IO (IO ()))
09:01:21 <lambdabot> IO ()
09:01:23 <tsahyt> there
09:01:44 <jmcarthur> :t join :: IO (IO a) -> IO a
09:01:45 <lambdabot> IO (IO a) -> IO a
09:01:52 <tsahyt> :t join
09:01:54 <lambdabot> Monad m => m (m a) -> m a
09:01:57 <tsahyt> the general version
09:02:11 <tsahyt> NikolajK: note that this doesn't constrain you to some specific monad. it works for all monads
09:02:18 <NikolajK> can someone tell me what's wrong here, then
09:02:18 <NikolajK> https://pastebin.com/cWk0PHrW
09:02:21 <tsahyt> you could read this as forall m. Monad m => m (m a) -> m a
09:02:28 <tsahyt> forall m a. actually
09:03:05 <tsahyt> NikolajK: why the join and fmap construct over just using >>=?
09:03:23 <NikolajK> it's just to understand 
09:03:44 <tsahyt> :t \f -> join . fmap f
09:03:45 <NikolajK> the code with do works, I'd like to write it with join now
09:03:45 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
09:03:49 <tsahyt> :t (>>=)
09:03:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:03:58 <tsahyt> well, up to argument order
09:04:17 <Aruro> NikolajK: import Control.Monad
09:04:22 <jmcarthur> NikolajK: Is the error message that join doesn't exist? You might need Control.Monad.
09:04:48 <NikolajK> oh, thx!
09:04:58 <NikolajK> why can I use monadic do wihtout that package then oO
09:05:05 <Aruro> because!
09:05:16 <jmcarthur> The Monad type class is in Prelude, but some of the related functionality is not.
09:05:34 <NikolajK> makes you think join isn't implemented ;)
09:05:38 <erisco> the do-notation only needs >>=
09:05:55 <NikolajK> I thought that might be the case because I read somewhere IO is treated specially
09:07:36 <erisco> > do 5
09:07:38 <lambdabot>  5
09:07:43 <erisco> though I haven't figured out that one
09:07:50 <jmcarthur> IO doesn't get any special treatment in terms of interface.
09:08:19 <jmcarthur> It's only "special" in that it's a primitive type.
09:09:56 <erisco> I guess if you go through the desugaring rules only <- is relevant and everything else is just as-is
09:10:03 <erisco> and "let" is special, but otherwise
09:11:17 <erisco> and so the types are figured out after that
09:11:32 <erisco> otherwise I'd expect it to be looking for a Monad instance with "do 5"
09:13:01 <Aruro> :t do undefined
09:13:03 <lambdabot> a
09:14:02 <Cale> > let in do 0
09:14:04 <lambdabot>  0
09:15:07 <erisco> > do let; 0
09:15:09 <lambdabot>  <hint>:1:10: error:
09:15:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:15:29 <Cale> > do let {}; 0
09:15:31 <lambdabot>  0
09:15:38 <erisco> weird
09:15:56 <Cale> It thinks the 0 is inside the let
09:16:27 <erisco> ah I suppose that is ambiguous
09:17:28 <erisco> give me the book back then
09:18:17 <Cale> > do let in "the cat, would you?"
09:18:19 <lambdabot>  "the cat, would you?"
09:18:31 <hpc> heh
09:25:10 <Hafydd> Haha.
09:25:40 <mrwonko> Hi, I just stumbled across a `AppSettings {..}` constructor and am wondering about the .. syntax. It's one of those phrases you can't Google for... Looks like it might use variables of matching name? Where can I find out more?
09:25:56 <bollu> > let in 5
09:25:58 <lambdabot>  5
09:26:01 <bollu> interesting
09:26:08 <bollu> why would that even be needed?
09:26:13 <bollu> is there some sort of laziness effect?
09:26:18 <erisco> mrwonko, is that actual code?
09:26:28 <Hafydd> mrwonko: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-wildcards
09:27:16 <mrwonko> erisco, yes, the yesdo-postgresql template contains a "return AppSettings {..}" line
09:27:30 <mrwonko> *yesod
09:27:36 <mrwonko> thanks, Hafydd, I'll take a look
09:27:37 <Hafydd> Yes, do!
09:27:53 <lambdafan> http://stackoverflow.com/questions/43170646/how-can-i-replace-my-usage-of-bracket-with-bracketp
09:27:59 <erisco> eh, I don't know why people are so attracted to these things
09:28:04 <lambdafan> I'm trying to replace my usage of bracket with bracketP
09:30:50 <erisco> I recently started using record puns because that solves a legitimate problem
09:31:00 <erisco> but I am not sure what this wildcard is solving
09:33:04 <mrwonko> here's the context I saw it in, fwiw: https://github.com/mrwonko/victory-disaster/blob/master/Settings.hs#L63-L88 without the wildcard there'd be a lot of redundancy, wouldn't there?
09:35:27 <erisco> eh, it could be written in Applicative-style instead
09:35:56 <erisco> but this introduces issues with maintaining correct order
09:36:43 <erisco> I can see the legitimacy in this specific scenario
09:38:13 <erisco> it is overlapped with implicit parameters
09:39:12 <erisco> so you could also see X{..} as the implicit wrapper on the constructor X
09:39:23 <erisco> except in the pattern position where it means something else
09:40:05 <erisco> and I don't like it in the pattern position at all because it adds a problem
09:40:29 <erisco> the problem record puns solves is you do not depend on the constructor arity in your definitions
09:40:41 <pepe`> TH question: does anyone know the incantation to splice a type variable in when generating a type ? 
09:40:54 <pepe`> > wrapInIO ( _ :: Proxy a) = [| IO $a |]
09:40:56 <lambdabot>  <hint>:1:26: error:
09:40:57 <lambdabot>      parse error on input ‘=’
09:40:57 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
09:40:57 <erisco> so if you add or remove fields in your data you do not necessarily have to change other definitions
09:41:33 <erisco> now if you add this wild card you reintroduce the problem!
09:41:37 <pepe`> > let wrapInIO ( _ :: Proxy a) = [| IO $a |] -- $a does not do what I want
09:41:39 <lambdabot>  <hint>:1:33: error: parse error on input ‘|’
09:42:13 <pepe`> And of course that should be a type splice: wrapInIO ( _ :: Proxy a) = [t| IO $a |]
09:42:28 <erisco> because you can cause name conflicts
09:44:11 <erisco> (you also do not depend on field order with record puns, I forgot)
09:55:42 <Deewiant> Is there any package with a UTF-8 codec supporting roundtripping of lone UTF-16 surrogates? Like RoundtripFailure in https://hackage.haskell.org/package/base-4.9.1.0/docs/GHC-IO-Encoding-Failure.html (but without having to use a GHC.* module that only operates in IO land)
09:56:35 <erisco> come one come all to IO Land, where anything is possible!
10:00:55 <phi_> Does anyone know a good encoding of free algebra over a monoid? I want a type T a b where a is the base field, and b is a monoid. The best I can think of is Map b a but I can the multiplication in T a b being pretty.
10:01:44 <erisco> phi_, I had the question of what qualifies as a free algebra and I was particularly wondering about monoid, so if you have any knowledge to offer that'd be great
10:02:30 <erisco> for example, is Maybe a free algebra over a monoid? I don't know
10:03:42 <phi_> @erisco I am talking about unital associative algebra i.e vector space with associative multiplication 
10:03:42 <lambdabot> Unknown command, try @list
10:04:18 <erisco> okay, I don't know what that is, but could you explain what a free algebra is?
10:04:26 <abhiroop> Are there any examples of actually parsing binary data using binary or cereal or attoparsec available? I could not find anything
10:05:41 <phi_> By free algebra I just mean that the basis elements are the elements of the monoid and we multiplication is just the multiplication of the monoid extended by linearity 
10:06:00 <centril> is there any operator  :: (a, b) -> (c, d) -> ((a,c), (b, d))  ?
10:06:11 <centril> in base or any other popular package
10:07:18 <centril> also:  :: (a, a) -> (a -> b) -> (b, b)
10:09:20 <tippenein> abhiroop: most things I've ever done look similar to this https://gist.github.com/niteria/5565110
10:10:24 <erisco> centril, not any operator I am aware of but these are easily defined tacitly, I think
10:10:49 <tippenein> centril: this one's close: Data.Tuple.HT mapPair :: (a -> c, b -> d) -> (a, b) -> (c, d)
10:11:05 <tippenein> n/m, not really
10:11:09 <centril> erisco: sure sure, i just wanted a ready one to not make up my own notation
10:11:59 <tippenein> (***) :: (a -> a') -> (b -> b') -> (a, b) -> (a', b')
10:12:11 <centril> tippenein: ye, but (***) is not what I want ^^
10:12:23 <Deewiant> :t join (***) :: (a -> b) -> (a, a) -> (b, b)
10:12:25 <lambdabot> (a -> b) -> (a, a) -> (b, b)
10:12:28 <Deewiant> :t join bimap :: (a -> b) -> (a, a) -> (b, b)
10:12:29 <lambdabot> (a -> b) -> (a, a) -> (b, b)
10:12:39 <Deewiant> I prefer the latter but YMMV
10:13:20 <centril> I want to do:    (`div` 2) * (id &&& (+1))
10:13:23 <centril> for some operator *
10:13:46 <jmcarthur> :t biliftA2 (,) (,) :: (a, b) -> (c, d) -> ((a,c), (b, d))
10:13:48 <lambdabot> error:
10:13:48 <lambdabot>     • Variable not in scope:
10:13:48 <lambdabot>         biliftA2
10:14:00 <jmcarthur> It's in Data.Biapplicative from the bifunctors package.
10:14:45 <centril> jmcarthur, Deewiant : cheers
10:14:49 <erisco> centril, what is that supposed to do, though?
10:15:11 <centril> :t (`div` 2) &&& (`div` 2) . (+1)
10:15:12 <lambdabot> Integral b => b -> (b, b)
10:15:17 <centril> erisco: ^
10:15:39 <erisco> so  (`div` 2) * (id &&& (+1) = (`div` 2) &&& (`div` 2) . (+1)  ?
10:16:09 <centril> erisco: yes
10:18:10 <jmcarthur> I think it's pretty well known that StdGen is not a very good PRNG. Is there an alternative that still has a RandomGen instance?
10:18:48 <erisco> hm, why not  (h &&& i) * (f &&& h) = h . f &&& i . h   ?
10:19:25 <jmcarthur> I see tf-random, but am not sure how to evaluate it.
10:19:31 <centril> erisco: that repeats h 
10:19:39 <erisco> so what, use join
10:21:01 <centril> erisco: like ?
10:21:16 <erisco> :t join (&&&)
10:21:17 <lambdabot> Arrow a => a b c' -> a b (c', c')
10:22:42 <centril> erisco: so this is a join on the (-> b) monad ?
10:22:47 <erisco> yes
10:23:10 <erisco> I don't know if * is implementable as I stated it, but you want something as regular as that
10:23:53 <erisco> really you'd just use ***
10:25:10 <erisco> > (join (***) (`div` 2) . (id &&& (+1))) 5
10:25:12 <lambdabot>  (2,3)
10:25:49 <centril> erisco: right, and we can just say  (*) = join (***)
10:26:00 <erisco> no, * = .
10:27:25 <erisco> pictorially, &&& splits one line into a pair of lines, and *** maps a pair of lines
10:27:26 <jmcarthur> I'll just go with tf-random for now, because I see indications that it's pretty high quality, but I'm a little sad that it's probably pretty slow. I'm pretty sure there has been some more recent work on splittable PRNGs that should be pretty fast, but I don't remember how to find it.
10:27:39 <erisco> these operations are concatenated with (.)
10:28:15 <erisco> once you have the pair of lines you can keep using *** to map them
10:28:22 <centril> erisco: (*) f g = join (***) f . g
10:28:55 <erisco> so  (h *** i) . (f *** g) = h . f *** i . g
10:29:13 <erisco> but I don't think you can get something similar for &&& because of the types
10:30:00 <erisco> eh, no, I wouldn't define that centril
10:32:34 <erisco> at most I would give a name for  join (***)
10:32:56 <erisco> I don't see the purpose of including function composition in it
10:43:23 <erisco> phi_, I can't follow the jargon there, sorry
10:45:55 <erisco> phi_, I don't know what "multiplication of the monoid extended by linearity" means
10:48:01 <phi_> @erisco no problem. The basic idea is this: an element of Free algebra is of the form sum_{i}(a_{i},b_{i}) where b is an element of monoid and a the element of base field
10:48:01 <lambdabot> Unknown command, try @list
10:49:11 <erisco> what does it mean for an element to be of that form?
10:52:12 <phi_> This means that I have a scalar multiplication which is a formal multiplication (aka tupling) between an element of my base field and an element of monoid. Then an arbitrary element is a formal sum of elements obtained in this way.
10:52:32 <phi_> So morally this is like Set(a,b)
10:54:26 <erisco> why you say "an element of Free algebra" are you saying "a Free algebra"?
10:54:46 <phi_> But I also need to define multiplication between two such elements and I do this by just expanding and for term of the expansion using multiplication of base field and mconcat of the monoid
10:55:36 <phi_> Free Algebra is a type
10:55:50 <erisco> as in, "an element of Real" is the same as "a Real"
10:56:02 <erisco> okay
10:57:33 <erisco> and so the actual type we choose only has to be isomorphic to this sum of tuples, right?
10:58:49 <phi_> Yes but we need to cut down by the relation imposed such as (a,b)+(c,b) = (a+c,b) 
10:59:30 <erisco> okay
11:06:59 <erisco> phi_, and what about (a,x)+(b,y) ?
11:07:46 <phi_> That a,b,x,y are all distinct that is just a formal sum
11:08:32 <phi_> if a and b are same then it is a*(x+y)
11:08:45 <erisco> no sorry I asked incorrectly
11:09:07 <erisco> I mean in our free algebra, what is the sum of these?
11:10:00 <erisco> so one element is from another monoid, and one is from our base field
11:10:33 <phi_> It is just this. There is no way to reduce this for arbitrary a,b,x,y. That is roughly what it means to be free here.
11:10:49 <phi_> The monoid and base field are both fixed
11:11:26 <phi_> so a and b are both elements of base field and x , y come from the monoid
11:11:31 <erisco> okay, I am struggling to go between your definition and the implementation
11:11:48 <erisco> but I am back to my earlier confusion which can't be what free algebras are supposed to be
11:11:53 <erisco> let me see if I can dig itup
11:12:21 <phi_> I don't have an implementation, it is what I want.
11:12:32 <erisco> I know
11:12:58 <erisco> well I can't remember where I put it so I will just retype it
11:14:31 <erisco> here: http://lpaste.net/354212
11:14:42 <erisco> you can play this game for every type class
11:15:25 <erisco> then also you get  eval :: Monoid a => FreeMonoid a -> a
11:17:22 <erisco> you don't necessarily need the reduction of Mempty's there either and can instead offload it to ==
11:18:33 <erisco> phi_, you can add another monoid in there along for the ride. It should be easy to adapt, but I don't know if this relates at all to what you're thinking of
11:18:56 <phi_> This is a free monoid but my question would be more like if it is possible to encode associativity in the type as well
11:19:42 <erisco> what is an example of that? or any other law?
11:20:13 <erisco> I don't understand how associativity of mappend can be encoded in the type FreeMonoid a
11:20:43 <erisco> would that mean the only type-correct implementation of mappend is associative?
11:22:49 <phi_> I don't know how to encode it, but in this case you can write an Eq instance that makes Mappend (a (Mappend b c)) == Mappend ((Mappend a b) c)
11:23:21 <phi_> A free algbra has more such relations and I was wondering if someone has a good way of dealing with them
11:23:25 <ph88^> i'm trying to write a parser which parses like this https://bpaste.net/show/f499ac22b819  but i'm getting a bit confused, i used parsers before, but i don't know how to start with this one
11:24:31 <erisco> phi_, ah, so that equality must be decidable without inspecting the values of a
11:25:26 <erisco> phi_, or did I misunderstand?
11:26:01 <ph88^> i'm gonna give it a shot, hold on
11:26:47 <erisco> otherwise, if I can just write  instance (Eq a) => Eq (FreeMonoid a)  it is easy
11:28:28 <erisco> I suppose it should also be realised that FreeMonoid doesn't have any values of a, heh
11:29:09 <phi_> What I meant was you can probably export some smart constructor such that using them you can't observe the difference between mappend (a (mappend b c)) and mappend ((mappend a b) c)
11:29:13 <erisco> and in that case it is easy to write the instance without Eq a
11:32:35 <phi_> I see that now and I also think it is not quite the right FreeMonoid. I think FreeMonoid is actually just [a] with mconcat being concat. And it is associative.
11:33:47 <erisco> what makes it the right one?
11:35:41 <_sras_> I was a function to strip tags from a piece of possible html and extract only the text content. The 'Hakyll' package has a function for this, it feels a bit massive dependency for just one function. Is compiler smart enough to just include code for this function, and leave the rest of the package, in the final executble? 
11:36:07 <phi_> In my mind at least (not sure what the rigorous definition is) Free version of some algebraic structure A is just some instance of A which has no relations expect those implied by the definition of A
11:36:29 <erisco> is it the case there are multiple or is one actually wrong?
11:37:47 <geekosaur> _sras_, it works like any other linker, because this is up tot he linker. dynamic libs get linked completely (but you don't really care as it's shared), static libs link only what's needed
11:37:49 <erisco> I am guessing the problem with my FreeMonoid is that, in terms of the "moral set" you spoke of, it is empty
11:38:24 <erisco> because there are no free terms related to base terms
11:38:33 <phi_> In the version you put up the only possible values are Mempty, Mappend Mempty Mempty , Mappend (Mappend Mempty Mempty) Mempty and so on which should all be Mempty 
11:38:59 <phi_> I mean using the laws of Monoid they should all be Mempty
11:38:59 <erisco> then it may as well be  instance Monoid (Proxy a)
11:39:31 <_sras_> geekosaur: So what does that mean?
11:39:41 <geekosaur> it would even split modules up with --split-objs (--split-sections in ghc 8.2 which is even better) but this is unusual for non-core libs because it's slower and more complex
11:39:46 <erisco> yes, that's right, but what makes this wrong? well I can't see how it is from your description
11:39:51 <erisco> other than it is trivially correct
11:39:54 <geekosaur> um
11:40:20 <erisco> whereas with [a] you do have a related free term for every base term
11:40:33 <erisco> i.e. x:[] relates to x
11:41:35 <_sras_> geekosaur: I mean, should I worry about the size of the dependency?
11:41:36 <geekosaur> "yes if hakyll is bulit statically, no if it is built dynamically, if it is built dynamically *stop worrying about it*, and which one you get depends on how ghc was built. if this does not make sense to you, stop worrying about it"
11:41:46 <erisco> phi_ is this the correct way to look at it?
11:42:03 <geekosaur> _sras_, in a world where dynamic linking is normal, your question makes no sense
11:42:08 <phi_> x is not an element of [a] only x:[] is
11:42:17 <geekosaur> libraries always get pulled in completely because that's how they work
11:42:25 <erisco> I didn't say it was, that isn't what I meant
11:42:52 <geekosaur> this is true of *any* language that produces native code. The answer will not differ for Haskell or C or C++ or rust or golang or ...
11:42:58 <erisco> I am pointing out the difference between my FreeMonoid a and [a]
11:43:15 <erisco> with FreeMonoid a the relation of free terms to base terms is empty
11:44:08 <erisco> so it is a trivial free algebra (I am conjecturing), whereas for every x :: a there is  x:[] :: [a]
11:45:26 <erisco> that is how I am qualifying the difference between the two. otherwise I don't see why we care between the two
11:46:47 <phi_> FreeMonoid and Free Algebra over a monoid are two very different things. The monoid in a Free Algebra is not necessarily free 
11:46:50 <_sras_> geekosaur: Guess I will just go into the source and just copy paste what ever there is..
11:46:56 <geekosaur> sigh
11:47:04 <geekosaur> ok, hellbent on micromanagement. buuild a statci ghc
11:47:28 <geekosaur> make sue to build the rest of the os static too, even though you will in fact end up wasting space that way but it will look smaller to you
11:47:31 <erisco> phi_, well you said FreeMonoid was correct at one point. can you clarify what is wrong about it now?
11:49:16 <akfp> is there a function for lists that work like grep -A 3 - i.e. give me a context of 3 elements before and after the element?
11:49:39 <erisco> and let me also change FreeMonoid a so it has a non-empty relation
11:49:57 <phi_> I was wrong, the problem is that by your FreeMonoid has only one value, which is a relation (or restriction) not required by definition of monoid.
11:50:55 <phi_> But according to http://comonad.com/reader/2015/free-monoids-in-haskell/ even my intuition about List being the free monoid is wrong.
11:51:04 <erisco> if it does not require it then having it does not make it wrong
11:51:19 <erisco> not-a-requirement is not the same as requiring the absence
11:52:16 <phi_> But that is what Free part means at least morally. 
11:52:51 <erisco> well I tried to be specific about what that moral was. why do you object to my specification?
11:53:44 <_sras_> geekosaur: Are you saying I should include all of Hakyll for this function, stripTags, here https://hackage.haskell.org/package/hakyll-4.1.2.1/docs/src/Hakyll-Web-Html.html#stripTags?
11:57:38 <erisco> okay, the whole argument is predicated on this: " If (ordinary) lists were the free monoid, there would be a unique monoid homomorphism from lists to snoc lists."
11:58:02 <erisco> why can this be assumed?
11:58:25 <erisco> also they say "the free monoid" as though there can only be one
12:00:26 <erisco> if I could get a clear understanding of what qualifies as a free algebra this wouldn't be so confusing
12:04:02 <erisco> they bother to define "single :: a -> SL a" and a law "h [x] = single x" so I suspect my qualifier earlier is on point
12:04:20 <erisco> though if so then it is required that this exist for a free algebra
12:06:03 <erisco> though there must be a more precise way of saying it, because I think, say, single = const y  for some y :: SL a  wouldn't be satisfactory
12:06:15 <erisco> such as why not  single = const Empty
12:06:44 <erisco> " a function that embeds a into SL a"
12:06:47 <erisco> so whatever "embeds" means
12:09:20 <erisco> so then I can imply that if X a is a monoid and there is a function f :: a -> X a which embeds a in X a, then it is candidate as a free algebra (i.e. those are required but not sufficient)
12:10:23 <erisco> but then I have a difficult time piecing together the rest of it, because then it seems to say that if I can come up with any two candidates and I cannot find a homomorphism between them then neither is a free algebra
12:17:14 <lifter> I use evil and general, and SPC is my leader key. My leader key doesn't work when in Help mode, however. Is there an easy way to get it to work?
12:21:37 <erisco> lifter, what are you talking about again?
12:22:05 <lifter> Sorry I asked in the wrong room! :(
12:39:09 <msl09> I have a question
12:39:11 <msl09> In this expression
12:39:16 <msl09> [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
12:39:45 <msl09> I expected it to be evaluated as
12:40:20 <msl09> ([1,2] >>= \n -> ['a','b']) >>= (\ch -> return (n,ch))
12:40:36 <msl09> because haskell is left associative
12:41:00 <msl09> but instead it's evaluated as [1,2] >>= (\n -> ['a','b'] >>= \ch -> return (n,ch))
12:41:01 <glguy> operators have whatever associativity you specify
12:41:25 <glguy> and in this case the rule for parsing lambda expressions is winning out
12:41:32 <Sornaensis> what part of haskell is the worst
12:41:51 <msl09> what's the rule for parsing lambdas?
12:42:12 <qmm> https://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/  <- since the crux of this article is that you become distracted, i think there needs to be a "why learning category theory makes you a worse haskell programmer"
12:42:33 <qmm> i need to be writing haskell, but i'm too much interested in category theory :P
12:43:00 <glguy> lambda span as far right as they can
12:43:13 <msl09> hmm
12:43:28 <msl09> is there a place where I can find those rules?
12:44:19 <Sornaensis> yea, the ghc source I guess
12:45:12 <msl09> o_o
12:45:19 <msl09> I guess I'll never know then
12:46:03 <Sornaensis> msl09: https://hackage.haskell.org/package/haskell-src-1.0.2.0/docs/Language-Haskell-Syntax.html#t:HsExp <-- Haskell98 AST
12:52:54 <qmm> which convention for naming a function which returns a Maybe is suggested:  mSomething, maybeSomething , or something?
12:53:01 <erisco> no one knows. we only learn of syntaxes experimentally
12:53:09 <erisco> at least that is how I feel when I program C++ :P
12:53:44 <erisco> qmm, somethingMaybe has been used
12:54:48 <MarcelineVQ> msl09, Sornaensis, erisco: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003  "The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible."
12:56:21 <erisco> that is not uncommon to say
12:57:01 <erisco> you state an ambiguous grammar for simplicity's sake and you either ignore the fact because it doesn't matter or you disambiguate by other means (which they've done the latter)
12:57:49 <Cale> Minimal munch would be so annoying
12:59:52 <Welkin> safe head has been called headMay, safeHead, etc.
13:00:13 <Welkin> the m- prefix is often used for pattern matching
13:00:39 <Welkin> muser <- <some action>
13:00:52 <Welkin> then you match on muser for Maybe user or Nothing
13:00:54 <Welkin> er
13:00:56 <Welkin> Just user*
13:01:16 <erisco> what if your context also includes people who muse?
13:01:26 <Welkin> mmuser
13:01:44 <erisco> but without uncertainty
13:03:25 <erisco> I have started using underscores a little bit
13:06:21 <Welkin> how terrible
13:07:05 <erisco> sometimes you want something like a suffix, and that is a standard notation for it
13:07:15 <erisco> like p_min and p_max rather than pMin and pMax
13:28:17 <bennofs> minP maxP
13:39:08 <Sornaensis> @info Rational
13:39:08 <lambdabot> Rational
13:42:11 <geekosaur> no @info or :info in lambdabot
13:46:14 <robertkennedy> Can you express every unary function in the form `type Nat c fi fo = forall i. c i => fi i -> fo i`? Ie `show :: Nat Show Identity (Const String)`?
13:47:59 <lambdafan> binary operators take two values, unary operators take one value, what do you call an operator that takes no value
13:48:09 <rotaerk> a value
13:48:25 <lambdafan> nullary?
13:48:51 <geekosaur> nullary, yes
13:48:52 <lambdafan> wow nulary is a word
13:48:56 <lambdafan> nullary
13:48:58 <lambdafan> huh
13:49:34 <rotaerk> robertkennedy, what about functions where there is more than one class constraint?
13:51:28 <rotaerk> I guess you could just make a new class that inherits them, and use it as a proxy for them
13:51:42 <robertkennedy> rotaerk: you could create a new type `type TwoConstraint a = (C1 a, C2 a)`? But then you're partially implying a type
13:52:18 <robertkennedy> No yeah you can. `class (C1 a, C2 a) => C a`
13:54:22 <rotaerk> right
13:58:46 <erisco> infinitary
13:59:42 <erisco> is printf... arbitary?
14:00:02 <geekosaur> xview api functions when you forget the trailing ..., 0, 0
14:00:06 <geekosaur> :p
14:08:56 <mniip> robertkennedy, yes
14:09:01 <mniip> but fi/fi don't have to be functors
14:09:04 <mniip> and it's not an iso
14:13:42 <robertkennedy> You mean what I've described isn't isomorphic to function type signatures?
14:21:52 <BlueShark> \x -> x x - what is this supposed to mean?
14:22:15 <BlueShark> I don't have any Haskell knowledge, ELI5 :p
14:25:33 <hpc> it's a function that takes a thing as a parameter
14:25:37 <hpc> let's name it 'x'
14:25:47 <hpc> and produces the value of x applied to itself
14:25:49 <hpc> as a function
14:26:24 <BlueShark> Does it have any connection with hex?
14:26:34 <hpc> hex?
14:26:53 <BlueShark> hexadecimal?
14:26:55 <BlueShark> \x 
14:26:57 <Cale> no
14:27:02 <hpc> oh, nothing to do with that
14:27:11 <Cale> \ is ascii art for the Greek letter λ
14:27:24 <Cale> which is a traditional notation for introducing a function
14:27:43 <hpc> and x itself could be any identifier
14:27:47 <hpc> \bananas -> bananas bananas
14:27:52 <Cale> The function's parameters go between the \ and the ->
14:28:01 <Cale> and then the result of applying the function is to the right of the ->
14:28:12 <Cale> > (\x -> x^2) 5
14:28:14 <lambdabot>  25
14:28:14 <BlueShark> An example would be really nice.
14:28:22 <mniip> hey Magnap
14:28:26 <Cale> > (\x -> 10 * x) 5
14:28:28 <lambdabot>  50
14:28:35 <thimoteus> :t \ bananas -> bananas bananas
14:28:37 <lambdabot> error:
14:28:37 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
14:28:37 <lambdabot>     • In the first argument of ‘bananas’, namely ‘bananas’
14:28:43 <Cale> > (\x y z -> x + y + z) 1 10 100
14:28:45 <lambdabot>  111
14:28:49 <mniip> BlueShark: hahahaha
14:28:52 <Cale> map (\x -> x^2) [1..10]
14:28:58 <mniip> did they make it a hint
14:28:58 <Cale> > map (\x -> x^2) [1..10]
14:29:00 <BlueShark> mniip: lol
14:29:00 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
14:29:13 <BlueShark> mniip: yes
14:29:31 <thimoteus> > (\ x y -> x y) (+ 1) 3
14:29:33 <lambdabot>  4
15:29:22 <Jello_Raptor> Is there a haskell library somewhere (probably in GHC?) that lets me mess around with thunks more directly? It doesn't look like such a thing exists but I'd like to be sure. 
15:32:00 <ezyang> what do you mean by "mess around directly" 
15:34:16 <Jello_Raptor> view unforced thunks at runtime, though I think what I want to do (lazily create mutable objects only when they're needed, while keeping track of a network of references ala observableSharing) 
15:34:38 <Jello_Raptor> is doable with unsafePerformIO, and being very very careful. 
15:36:26 <ezyang> You could try programming with IVars instead 
15:36:45 <ezyang> An IVar is a write once mutable variable 
15:41:28 <Jello_Raptor> nope, what I need is the ability to crate LVars on the the fly. I'm playing around with possible APIs/implementation structures for a dynamic propagator network. I want a user to be able to write propagators that are lazy in however many variables, and where the system doesn't actually create an LVar until it's needed.
15:42:19 <benzrf> what is an lvar?
15:42:56 <ezyang> well, an LVar is a lattice variable, Lindsey Kuper's thesis work 
15:43:01 <Jello_Raptor> Paper => http://dl.acm.org/citation.cfm?id=2502326, Package => http://hackage.haskell.org/package/lvish
15:43:07 <ezyang> they generalize IVars 
15:43:44 <Jello_Raptor> mhmm, but the expectation is that the value in them will alwys grow monotonically with respect to some partial order, and the values stored in them form a commutative monoid 
15:45:25 <Jello_Raptor> commutative, idempotent monoid* 
15:45:29 <Squarism> i found this GHC.IO.Handle - does "stderr" has handle defined globally?
15:45:40 <ezyang> yes it's a global handle 
15:46:27 <Squarism> does it have a name?
15:46:30 <Squarism> ezyang, ?
15:47:05 <ezyang> uh... stderr? 
15:47:09 <ezyang> :t System.IO.stderr 
15:47:11 <lambdabot> GHC.IO.Handle.Types.Handle
15:48:18 <Squarism> ok thanks
15:51:27 <lyxia> Jello_Raptor: Hqve you seen this relevant SO question http://stackoverflow.com/questions/28687384/test-if-a-value-has-been-evaluated-to-weak-head-normal-form
15:56:01 <Jello_Raptor> lyxia: right, that's similar to the unsafePerformIO solution I thought of. But it's good to see I'm on the right track, at least iff this how i want to structure the final system. 
16:09:22 <lyxia> Jello_Raptor: The second answer seemed closest to it.
16:36:18 <sophiag> this is my first time using a GADT and i'm getting some errors i don't understand calling its data constructors: http://lpaste.net/354215
16:41:45 <mniip> sophiag, well first of all NumOp is a binary constructor
16:41:52 <mniip> and you're applying it to a binary function
16:42:38 <mniip> a similar mistake is in EqOp and BoolOp
16:43:35 <mniip> sophiag, I can't exactly see what you were trying to do here
16:43:37 <sophiag> mniip: i don't understand the latter part of that. the return types of those functions match, except wrapped in Maybes. i tried testing it without the Maybes and got the same errors
16:44:44 <mniip> ignoring contexts and equational constraints, what you've defined is
16:45:14 <mniip> data OpT a = NumOp a a | EqOp (OpT a) (OpT a) | BoolOp Bool Bool
16:46:23 <sophiag> oh... so the problem is in how i'm writing the constructors? as mentioned, this is my first time working with GADTs
16:46:44 <mniip> what are you trying to say
16:47:15 <mniip> I mean, what do you want to express with your code
16:47:23 <sophiag> well, if you're saying that's what OptA translates into then it's clearly not correct
16:47:39 <tobiasBora> Hello,
16:47:45 <tobiasBora> I've a strange problem with regexp:
16:47:56 <sophiag> before i made it a GADT it looked like this: data OpT a = (Num a, Fractional a) => NumOp (a -> a -> a) | (Eq a) => EqOp (a -> a -> Bool) | BoolOp (Bool -> Bool -> Bool)
16:48:01 <tobiasBora> (regexp and unicode)
16:48:07 <tobiasBora> If I do:
16:48:09 <tobiasBora> import Text.Regex as REG
16:48:32 <tobiasBora> str = "🔶@BO.com
16:48:34 <tobiasBora> "
16:48:51 <mniip> tobiasBora, you might want to pastebin if it's long
16:48:54 <mniip> @where lpaste
16:48:54 <lambdabot> http://lpaste.net/
16:49:42 <mniip> sophiag, what should the 'a' in OpT imply?
16:51:25 <sophiag> the variables in the data constructors
16:51:53 <tobiasBora> mniip: It was 3 lines, but I put it here: http://lpaste.net/354218
16:52:18 <mniip> sophiag, that's not enough information
16:52:46 <tobiasBora> And the problem is that basically, the unicodes char like "\128310" match the regexp "^([a-zA-Z0-9])$" which is really weird!
16:53:34 <sophiag> mniip: can you correct my understanding then? i was under the impression variable in type constructors corresponded to the same variable in data constructors
16:53:41 <Koterpillar> > len "\128310" 
16:53:43 <lambdabot>  error:
16:53:43 <lambdabot>      • Variable not in scope: len :: [Char] -> t
16:53:43 <lambdabot>      • Perhaps you meant one of these:
16:53:47 <Koterpillar> > length "\128310" 
16:53:49 <lambdabot>  1
16:55:45 * geekosaur wonders which backend was used there, and if it speaks utf8
16:56:12 <mniip> tobiasBora, what module are you using for Text.Regex
16:56:20 <tobiasBora> geekosaur: I think it's supposed to be emoji from instagram...
16:56:29 <mniip> what comes to mind is that in PCRE [a-z] really means isAlpha
16:56:36 <mniip> which will match unicode chars too
16:56:46 <tobiasBora> mniip: What do you mean? I really wrote in my code (or in ghci) the code I paste
16:56:54 <geekosaur> ...
16:56:54 <dmwit> tobiasBora: https://wiki.haskell.org/Regex_Posix "If you want a bug-free and/or portable POSIX extended regular expression library to use from Haskell, then regex-posix will not help you. You should use the regex-tdfa package instead."
16:57:35 <geekosaur> you are very confused. nobody is talking about *your* code, but the package you imported Text.Regex from (if you didn't specify one, you get to go find ghc's compile log to see which one it picked).
16:58:13 <mniip> errrr
16:58:16 <mniip> package
16:58:20 <mniip> is the word I was looking for
16:58:21 <geekosaur> and if it's from regex-posix, there's a very good chance it fails in bizarre ways with UTF8
16:58:21 <mniip> yes
16:59:04 <mniip> sophiag, in GADT you write out the type of the constructor
16:59:04 <geekosaur> if it's from pcre, you need to make sure the pcre library it used was built with utf8 support (some platforms don't, or force you to install a specific package to get the utf8 one)
16:59:23 <tobiasBora> dmwit: Ok I'll try it thank you!
16:59:25 <mniip> sophiag, like, a proper type
16:59:46 <geekosaur> tdfa is slower because it's pure haskell, but it is guaranteed to work correctly
16:59:55 <fDev2179> I've written some simple functions which can generate a uniform N-dimensional grid.  I'd like a critique if someone has the time.  
16:59:56 <mniip> sophiag, my question regarding what you want the tyvar in 'OpT a' be is the key point of using GADTs
17:00:08 <fDev2179> Here's the code: https://pastebin.com/23wnPVSX
17:00:08 <tobiasBora> geekosaur: Indeed I was confused
17:00:10 <mniip> you could have nontrivial logic behind the typing of your datatype
17:00:16 <mniip> that is the whole point of GADTs
17:00:31 <tobiasBora> geekosaur: I also found text-icu, is it supposed to be more efficient?
17:00:31 <fDev2179> I'm still a Haskell newbie so I'm trying to figure out where I can do better.
17:00:37 <geekosaur> most system regex libraries *specifically* mishandle character ranges like that, because they expand it to an array and index it with the single-byte character they think you gave it
17:00:48 <robertkennedy> Does `getBool >>= \b -> return $ if b then 2 else 0` desugar to use fmap?
17:00:52 <geekosaur> which fails completely with utf8
17:01:08 <mniip> fDev2179, getCoordinate could be a record accessor
17:01:20 <dmwit> fDev2179: Why does `extrudeGrid` need a special case for `[Point []]`? What goes wrong if you leave it out?
17:01:38 <geekosaur> tobiasBora, it should be
17:01:47 <fDev2179> Not familiar with Record accessors, that I know of.
17:01:54 <fDev2179> dmwit, let me look.
17:02:08 <mniip> brb
17:02:59 <tobiasBora> geekosaur: I'm not sure to understand what does "ICU library, which is not included". Does it means that the library must be installed from apt-get for example at compile time?
17:03:00 <dmwit> :t zipWithM
17:03:02 <lambdabot> Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:03:11 <tobiasBora> *what does ... means
17:03:36 <sophiag> i'm still confused as to how a data constructor with only one type variable is a binary function...
17:03:38 <geekosaur> tobiasBora, yes
17:03:47 <tobiasBora> ok thank you
17:03:56 <fDev2179> dmwit, you are correct that the special case of extrudeGrid [Point []] isn't needed.
17:04:13 <fDev2179> Didn't realize that.
17:05:09 <dmwit> > mapM (\(lo, hi, n) -> [lo + (fromIntegral v/fromIntegral n) * hi | v <- [0..n]]) (zip3 [0,0,0,0] [1,1,1,1] [5,3,2,2])
17:05:11 <lambdabot>  [[0.0,0.0,0.0,0.0],[0.0,0.0,0.0,0.5],[0.0,0.0,0.0,1.0],[0.0,0.0,0.5,0.0],[0....
17:05:40 <fDev2179> Wow.
17:05:44 <Koterpillar> tobiasBora: it's a C library
17:05:53 <mniip> sophiag, (,) is a binary function
17:06:07 <mniip> hmm bad example
17:06:12 <mniip> data P a = Pair a a
17:06:21 <mniip> one type variable, Pair is a binary function
17:06:26 <tobiasBora> Koterpillar: So if I don't manually link the library to the binary, I will need to install it on the user computer as well right?
17:06:28 <sophiag> ok i see
17:06:48 <Koterpillar> tobiasBora: s/manually/statically/, then it's correct
17:07:11 <tobiasBora> Koterpillar: ok thank you!
17:07:35 <fDev2179> Problem is, I need to write this code in matlab, but I can usually think about recursion more clearly in haskell.
17:07:54 <dmwit> Implement mapM in matlab. ;-)
17:07:58 <dmwit> I am kidding. Don't do that.
17:08:10 <fDev2179> Hahahaha
17:08:46 <fDev2179> I wish I didn't have to use matlab, but I don't have a choice.  I need to try to digest what you wrote.
17:08:59 <fDev2179> Not too familiar with mapM
17:09:14 <dmwit> So the lambda is just your `myLinspace`,.
17:09:17 <sophiag> mniipp: and is the reason you're saying the functions i'm calling them on are unary is because they're wrapped in Maybes? i don't think so because i tested that, but trying to understand since their return types are binary
17:09:31 <mniip> nah
17:09:31 <fDev2179> Okay, I can see that.
17:09:45 <mniip> sophiag, you have a constructor of type 'a -> a -> OpT a'
17:09:55 <mniip> and you're applying it to a function 'b -> b -> b'
17:10:17 <dmwit> So forgetting `mapM` for a moment, and thinking of `map` instead, the `map myLinspace (zip3 ...)` constructs a list whose elements are the ranges of each coordinate.
17:10:18 <fDev2179> you used zip3, but that only works for 3 dimensions, right, dmwit?
17:10:18 <mniip> perhaps you meant the constructor to be '(a -> a -> a) -> OpT ?'
17:10:44 <dmwit> fDev2179: No, it works for any number of dimensions but only for three *arguments*. But the three arguments are not the dimensions; the lists are the dimensions.
17:11:00 <sophiag> mniip: probably the return types of the function to be something like that rather
17:11:03 <sophiag> lemme give it a try
17:11:14 <dmwit> fDev2179: The first argument is the low value for each dimension. The second argument is the high argument for each dimension. The third argument is the number of points in each dimension.
17:11:24 <fDev2179> Ohhhh, I see.
17:11:27 <mniip> sophiag, you have to think about what you want to represent
17:11:31 <mniip> hence my question
17:11:37 <fDev2179> Very neat!
17:11:44 <mniip> will the return type of the function be useful?
17:12:10 <fDev2179> That's kind of hilarious that you just converted my ~50 lines of code into one line.
17:12:19 <mniip> fDev2179, welcome to haskell
17:12:23 <dmwit> fDev2179: Then once you have all the possible choices for each dimension (given by `map (...) (zip3 ...)`), you can take all possible ways of choosing one value for each dimension with `sequence`.
17:12:33 <dmwit> > sequence ["123", "abc", "xyz"]
17:12:35 <sophiag> mniip: i have. as mentioned initially, i'd like it to be the same as that data type i posted except it makes more sense for it to be a GADT and i don't fully grok how they work yet
17:12:35 <fDev2179> Haha, thanks, mniip.
17:12:36 <lambdabot>  ["1ax","1ay","1az","1bx","1by","1bz","1cx","1cy","1cz","2ax","2ay","2az","2b...
17:12:57 <dmwit> fDev2179: (and `mapM` is just a combination of `sequence` and `map`)
17:13:08 <fDev2179> Oh, okay, that helps.
17:13:25 <mniip> sophiag, yeah no, I mean, you can put whatever you want into the type of the constructor. The question is will it be useful
17:13:27 <fDev2179> I'm taking notes.
17:13:35 <mniip> sophiag, consider an example gadt:
17:14:18 <dmwit> Actually, it's probably cleaner to use `sequence` and `zipWith3`.
17:14:40 <sophiag> mniip: i'm saying it worked fine when i used that data type i showed you, but i'd rather use a GADT to do the same thing. it seems cleaner seeing as i need the same language pragma, but primarily i'd like to be able to define some of the arguments recursively
17:14:40 <mniip> data Expr a where TrueExpr :: Expr Bool; IntExpr :: Int -> Expr Int; IfThenElseExpr :: Expr Bool -> Expr a -> Expr a -> Expr a
17:15:02 <mniip> here, clearly, Expr a is an expression that evaluates to a "thing" of type 'a'
17:15:06 <fDev2179> Beautiful.  That's why I started learning Haskell.  Thanks for the feedback, dmwit!
17:15:35 <sophiag> mniip: can you give an example of calling one of those constructors using the return value of another function?
17:16:00 <mniip> IntExpr (3 + 3)
17:16:10 <mniip> map IntExpr [1..5]
17:16:11 <mniip> idunno
17:16:39 <mniip> sophiag, are you trying to represent functions?
17:16:57 <mniip> you might have more luck with OpT a b
17:17:06 <mniip> representing a thing that takes a as input and produces b
17:17:32 <sophiag> what i've been asking the entire time is this: if you call "IntExpr func" then what's a suitable type signature for func?
17:17:40 <sophiag> to put it in concrete terms
17:18:23 <mniip> func :: Int
17:18:44 <sophiag> ah ok
17:20:01 <mniip> @let data Whatever a b c where Constructor :: Int -> (beep, boop) -> Maybe (p -> q) -> Whatever (Whatever a) p (,)
17:20:02 <lambdabot>  Defined.
17:20:04 <mniip> :t Constructor
17:20:05 <lambdabot> Int -> (beep, boop) -> Maybe (p -> q) -> Whatever (Whatever a) p (,)
17:20:21 <mniip> ^whatever you type as the type of the constructor *becomes* the type of the constructor
17:23:01 <mniip> question: Is there an existing notation for logarithms in type algebra?
17:26:01 <mniip> Log a a = 1; Log a (x * y) = Log a x + Log a y; Log a (x -> y) = x * Log a y
17:26:18 <mrjake> Has anyone used the Matplotlib library?   http://lpaste.net/6001640235455217664  http://lpaste.net/4341213425079156736  It basically works as an executable, but I'm having problems trying to generate plots interactively.
17:27:14 <mniip> pretty similar to the type derivative
17:28:21 <mniip> defined by something like
17:28:53 <mniip> b = Log a b -> a
17:38:11 <sophiag> mniip: i'm testing it without the Maybes for simplicity's sake and still don't have things quite right: http://lpaste.net/354215
17:39:00 <mniip> you need to drop <$> as well
17:39:10 <mniip> and <|> makes no sense in absence of Maybe
17:39:22 <sophiag> ah true
17:39:43 <mniip> and on top of that
17:39:47 <mniip> your type is
17:40:04 <mniip> parseOp :: Exp -> OpT a
17:40:06 <mniip> can't worl
17:40:27 <sophiag> why is that?
17:40:39 <mniip> that type implies that the caller decides what 'a' is
17:40:55 <mniip> but clearly the function parseOp has to decide, based on the contents of Exp
17:41:35 <sophiag> so.. parseOp :: Exp -> a -> OpT a   ?
17:41:40 <mniip> generally with GADTs you want to avoid a conflating function like this
17:41:53 <mniip> no, there's no way it will ever work
17:42:31 <sophiag> so i just can't have a function like this?
17:42:41 <mniip> ask yourself why do you need one
17:43:19 <sophiag> because i'm parsing an expression that can be any of those three types
17:43:38 <mniip> but you use GADTs to explicitly differentiate between the three types
17:44:13 <sophiag> if i didn't need a generalized type i would have just defined them separately
17:44:31 <mniip> that much is good, but
17:44:59 <mmaruseacph2> HCAR Call for Contributions has been sent https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126678.html
17:46:11 <mniip> sophiag, you've defined your types to explicitly avoid conflating OpT Int and OpT Bool
17:46:45 <mniip> you can't define a function that returns either
17:47:26 <sophiag> ultimately i need the OpT type
17:47:33 <mniip> are you sure you have to parse a thing that has to be either of the tree types in the same place?
17:47:42 <sophiag> yes
17:47:46 <Koterpillar> well, you can have a cast :: OpT x -> Maybe (OpT y)
17:47:48 <mniip> if you insist, parseOp :: Exp -> (forall a. OpT a -> r) -> r
17:47:54 <Cale> Actually, it might make sense to wrap the GADT in an existential... but I kind of feel as if this type hackery might be going way overboard
17:48:01 <mniip> yeah
17:48:14 <sophiag> no. no more existentials :(
17:48:19 <mniip> time to rethink your types
17:48:20 <Cale> right, exactly
17:48:23 <mniip> or maybe your call stack?
17:48:23 <Cale> heh
17:48:34 <Cale> Yeah, these things aren't quite separate
17:48:38 <mniip> sophiag, XY?
17:48:41 <sophiag> Cale: you're the one who told me to do it this way! you even wrote a paste like this...
17:48:51 <Cale> Yeah, but I was focused on a smaller part of your program
17:48:55 <mniip> what are you trying to do on a larger scale
17:49:01 <Cale> I hadn't seen some of this parse-related stuff
17:49:34 <tobiasBora> Grr I'm getting crazy... I tried to extract email with this regexp: let reg = ICU.regex [] $ T.pack "^(.*[^a-zA-Z0-9]|)([a-zA-Z0-9][-a-zA-Z0-9.]*@[-.a-zA-Z0-9]*\\.[-a-zA-Z0-9.]*[a-zA-Z]).*$"
17:49:38 <Cale> Yeah, taking a step back is probably warranted
17:49:54 <thimoteus> oh my
17:49:54 <Koterpillar> how will you use the result of parseOp?
17:49:57 <tobiasBora> However, when I run (ICU.findAll reg $ T.pack "I'm myname-real@gmail.com")
17:50:05 <mniip> tobiasBora, email? regex? just give up
17:50:16 <thimoteus> i agree with mniip
17:50:41 <tobiasBora> Then I have "real@gmail.com", but not "myname-real@gmail.com", even find findAll
17:51:09 <tobiasBora> mniip: Really? Why? I tried to use parser but I was getting very ugly solutions
17:51:36 <mniip> and regex is somehow cleaner?
17:51:47 <mniip> also
17:51:57 <tobiasBora> mniip: Well I hoped that regex would be faster
17:51:57 <mniip> email addresses are known to be hard to parse properly
17:52:04 <mniip> faster?
17:52:08 <mniip> faster to write?
17:52:13 <tobiasBora> mniip: No, to execute
17:52:20 <mniip> eeeeenope
17:52:45 <tobiasBora> (I made benchmark, and indeed in my test they were twice faster, and my parser was not even recognising the good email form)
17:53:00 <exio4> a regex is a fancy way to say a finite state machine
17:53:06 <exio4> so I am guessing it could be quite fast 
17:53:26 <mniip> well, yes, with knowledge of regularity,
17:53:32 <mniip> a compiled regex can be crazy fast
17:53:42 <exio4> if you can make the transition function extremely fast, I guess it gotta be faster than most solutions
17:53:44 <sophiag> mniip, Koterpillar, Cale: what i need to do is store a record of lambdas with one bound variable, which can be each of these three types, and then everything else can be compound forms of all those operators listed and values of the same type as the bound variable.
17:53:57 <mniip> probably reaching cpu cycle per character speeds
17:54:41 <tobiasBora> mniip: For example, how would you say with a parser "I want to have the biggest sequence of letter, numbers, dot, and '-', but finish with a letter. 
17:54:51 <lyxia> tobiasBora: you can just drop the first group BTW
17:55:37 <lyxia> with the ^
17:55:59 <tobiasBora> lyxia: oh yes of course, you are true
17:56:05 <tobiasBora> Why did I do that...
17:56:13 <sophiag> here are example inputs i'd parse and then the output all at once:
17:56:14 <tobiasBora> Don't know
17:56:21 <tobiasBora> Well it works indeed
17:56:38 <lyxia> the problem was that the first group didn't exclude -
17:57:43 <mniip> depending on the combinator library, something along the lines of 'lazyMany anyChar *> (satisfies isAlpha <**> (:) <$> (many (satisfies isAlnum <|> anyOf ".-")))'
17:57:59 <lyxia> that regex is also pretty restrictive
17:58:00 <tobiasBora> lyxia: Well if I didn't exclude - I wouldn't be able to parse: "I'm -myname-real@gmail.com"
17:58:16 <tobiasBora> (sometimes people do not put space before email...)
17:58:45 <tobiasBora> lyxia: Yes, I restrict it for the IRC example, but in right, here is what I'm using:
17:59:08 <tobiasBora> [a-zA-Z0-9][a-zA-Z0-9!.#%&é*+-/=?^_`{|}~]*@[-.a-zA-Z0-9]*\\.[-a-zA-Z0-9.]*[a-zA-Z]
17:59:22 <mniip> that random é
17:59:34 <lyxia> hahaha
17:59:38 <pacak> tobiasBora: You don't really want to extract emails with regexp.
18:00:50 <sophiag> input : "require (\\x -> x + 1)" "require foo (\\y -> y == \"asdf\")" "require bar (\\z -> z >= (1 /3))" output: [[reqTag : Nothing, constraint : \x-> x + 1], [reqTag: Just "foo", constraint : \x -> x == "asdf"], [reqTag : Just "bar", constraint : \x -> x >= (1 / 3)]]
18:00:51 <tobiasBora> mniip: lazyMany? I didn't know that, I was always dealing with "try many"...
18:01:21 <pacak> tobiasBora: http://stackoverflow.com/questions/20771794/mailrfc822address-regex
18:01:40 <nshepperd> tobiasBora: if you're looking to extract email addresses from a document, you could use word boundary marks \b, instead of having the first group there
18:02:19 <tobiasBora> nshepperd: If I remove this group, doesn't it solve the problem?
18:03:06 <nshepperd> probably
18:04:37 <nshepperd> pacak: there's nothing wrong with finding email addresses using a regex
18:04:51 <mniip> tobiasBora, that's a made up name
18:05:04 <mniip> it is implemented differently in different combinator packages
18:05:06 <pacak> nshepperd: In theory.
18:05:14 <nshepperd> pacak: you're talking about validation
18:06:46 <nshepperd> it's fine to find X email addresses, and 1 string that's not an email but looks like one, if you validate it later, by one method or another
18:06:57 <tobiasBora> mniip: Let's say we are using parsec, how would you code "lazyMany efficiently ?"
18:07:06 <pacak> nshepperd: It will either find a bunch of stuff that not exactly email or will miss some of them. I did some experiments when I was working  on spam filtration.
18:07:27 <mniip> I wouldn't use parsec :)
18:08:29 <mniip> finding the longest substring is a backtracking operation
18:08:36 <mniip> and parsec is about all but that
18:09:45 <mniip> if you don't care about performance then a bunch of try is fine
18:09:56 <nshepperd> common GUI applications find emails and URLs in text using regexes, because the cost of making a string clickable is not very high if it's not actually an email or URL (the user just won't click)
18:11:48 <mniip> sophiag, hmm
18:12:09 <mniip> how are those different
18:12:17 <mniip> why do you even need OpT to have a type parameter
18:12:26 <mniip> if you don't differentiate between them in a visible way
18:15:11 <sophiag> because i'd like to be able to parse compound expressions
18:16:14 <sophiag> i also have a type that represents all the possible types i could use. so i realized that should be in the signature of parseOp instead of a variable
18:21:57 <tobiasBora> mniip: The thing is that I care about performance... That's why I'm using regexp for now. Do you have a better parser than parsec?
18:22:38 <sophiag> parsec3 is almost as fast as attoparsec. faster than that and you need to write your own
18:23:23 <sophiag> although i suppose fundamentally working with bytestrings must be faster
18:23:57 <tobiasBora> And how would you define lazyMany in parsec3?
18:24:18 <ipso_wacko> Hey anyone in here who I can talk to about /r/place
18:25:11 <sophiag> tobiasBora: i think if you look at the docs it says something about lazy parsers
18:26:10 <tobiasBora> sophiag: Well maybe lazy is not the good term then, is lazy means "you can deal with lazy string" or means "you can do backtrack like operations". Because it's the second one I need...
18:26:30 <mniip> ipso_wacko, #haskell-blah
18:26:38 <sophiag> yeah, actually i'm not sure what i just said is even true
18:26:49 <sophiag> i took a glance at the docs
18:26:59 <ipso_wacko> I can't join because I'm on unsecure network or something..
18:27:08 <ipso_wacko> (using firefox plugin)
18:27:12 <mniip> ahwell
18:27:27 <mniip> shame
18:27:46 <c0dehero> wat?
18:27:49 <ipso_wacko> Well I'm the pencil you fighting and I'm looking for truce
18:28:19 <c0dehero> are there security restrictions for channels?
18:28:32 <mniip> c0dehero, +S ssl only
18:28:36 <ipso_wacko> I can talk here but it said SSL only for channel
18:28:46 <mniip> ipso_wacko, /sslserver irc.freenode.net 6697
18:29:28 <c0dehero> oh, so you're that guy :D
18:29:29 <c0dehero> i thought it was fine the way it is?
18:29:29 <c0dehero> mniip: huh. i did not know that
18:30:01 <ipso_wacko> Not sure what to do w. that command, sorry. Well I tried xD thanks 
18:30:35 <mniip> ipso_wacko, we're not very picky about the border but does the pencil need to be as long
18:30:50 <c0dehero> okay well. what do you propose?
18:30:54 <ipso_wacko> Honestly we started it and ran into your border on accident
18:31:01 <ipso_wacko> I'd just like to see it stay?
18:32:13 <c0dehero> i don't mind it the way it is
18:32:19 <c0dehero> but others might still try to cover the pencil
18:32:33 <mniip> me neither really
18:33:00 <ipso_wacko__> Ok well we'll just keep cleaning up then. 
18:33:06 <ipso_wacko__> Mexico tryna eat us anyway
18:33:27 <c0dehero> really i'm more worried about face guy
18:33:47 <mniip> which
18:33:49 <ipso_wacko__> I figured it was yours cus the color
18:34:18 <mniip> the purple thing with orange eyes thing?
18:34:23 <mniip> not afaik
18:34:58 <c0dehero> nah. that thing isn't ours
18:35:40 <c0dehero> it's trying to eat us as well
18:37:14 <c0dehero> anyways. nice to see that it brought someone here, lol
18:37:25 <ipso_wacko_> Might look ok if they invade border but not actual sign, cus you're going purple as far as I can tell 
18:37:27 <c0dehero> you want your free explanation of monads?
18:37:29 <ipso_wacko_> Might look ok if they invade border but not actual sign, cus you're going purple as far as I can tell 
18:37:50 <c0dehero> i guess
18:38:18 <mniip> do you want your explanation of free monads?
18:38:40 <mniip> do you want your free monad of explanations?
18:38:45 <ipso_wacko_> If I get downtime on ours I'll help you out cus I feel indebted by taking border
18:38:57 <ipso_wacko_> also no idea if you're talking to me but I have no idea what you're talking about and so I assumed you're not
18:39:34 <mniip> ipso_wacko_, c0dehero is just trying to convert you to--
18:39:44 <c0dehero> thanks. i'll help repair the pencil then if i see something
18:39:46 <mniip> ipso_wacko, c0dehero is just trying to convert you to church Churh
18:39:58 <ipso_wacko> Church Haskell?
18:40:07 <c0dehero> mniip: hush!
18:40:07 <ipso_wacko> I'd never heard of you before now x) 
18:41:21 <ipso_wacko> My coding skills go as far as making sweet myspace layouts and I've never programmed anything so, might be a bit lost on me x)
18:41:44 <c0dehero> well, are you interested in programming?
18:42:02 <c0dehero> ah, okay
18:42:17 <mniip> ipso_wacko, that was a failed attempt at a joke. Alonzo Church is a mathematician fairly relevant to haskell and functional programming in general
18:42:52 <c0dehero> if you ever decide to give it a serious try, you should learn haskell at some point
18:42:55 <ipso_wacko> honestly no. I wish I could say yes and be welcomed into your lil community but.
18:43:09 <c0dehero> :D np
18:43:09 <mniip> doesn't matter
18:43:28 <mniip> we have documented cases of internet trolls ending up learning the language
18:43:42 <tobiasBora> By the way, is it possible to compile a regex from regex-tdfa? I cannot find a way to do that...
18:43:46 <ipso_wacko> I know I'm like well, *thinking* maybe I could learn this thing
18:44:17 <c0dehero> mniip: lol rly? :D
18:44:25 <tobiasBora> Oh wait, I may found it
18:44:40 <mniip> https://gist.github.com/quchen/5280339
18:45:52 <mpiechotka> @pl a %+ f b
18:45:52 <lambdabot> a %+ f b
18:46:05 <mpiechotka> @pl \a b -> a %+ f b
18:46:06 <lambdabot> (. f) . (%+)
18:46:09 <monochrom> And where is xQuaser now?
18:46:35 <monochrom> Therefore, I conclude that this documents failing to get a troll to learn Haskell.
18:48:00 <mniip> monochrom, ahem
18:48:03 <jayshua> I'm scrolling around on a /r/place on a tiny cell phone screen trying to find this pencil dispute. Could someone maybe give me a general location for it?
18:48:19 <c0dehero> lol. that is amazing
18:48:36 <monochrom> Why is everyone coming to #haskell to talk about /r/place?
18:48:46 <mniip> [08:30:16] <xQuasar> oherrala: i will buy that book now
18:48:46 <mniip> [08:31:00] <xQuasar> oherrala: i will practice for a year and come back. thank you. bye.
18:48:46 <c0dehero> jayshua: https://www.reddit.com/r/place#x=281&y=561
18:49:04 <c0dehero> monochrom: because we're doing advertisement
18:49:19 <mniip> that book = LYAH looks like
18:49:29 <c0dehero> it's not like haskell is good at marketing. someone's gotta do it
18:49:47 <jayshua> Ah thanks c0dehero
18:49:50 <mniip> monochrom, therefore I conclude you're jumping to conclusions
18:49:59 <monochrom> OK, then why do they come to ask about pencils as opposed to Haskell?
18:50:08 <c0dehero> you're welcome :D
18:50:08 <c0dehero> well...
18:50:20 <monochrom> mniip, where is xQuaser now?
18:50:28 <mniip> because "the haskell dispute" is ambiguous
18:50:31 <c0dehero> :o
18:50:43 <c0dehero> i can see the bold text o_o
18:51:21 <mniip> monochrom, that I can't tell
18:51:25 <mniip> last seen 4w ago
18:52:19 <c0dehero> he probably wrote a haskell bot to automate trolling
18:53:25 <c0dehero> give a man an irc client and he'll troll for a day. teach him to code and he'll troll for a lifetime
18:53:51 <ipso_wacko_> I just spent like 10 min on the Haskell homepage playing the interactive tutorial
18:53:55 <ipso_wacko_> I have no idea what any of this means
18:54:11 <c0dehero> :D
18:54:25 <ipso_wacko_> I'm now on wiki reading about what a ''functional programming'' is x)
18:54:26 <mniip> welcome to the club
18:54:30 <ipso_wacko_> MEANWHILE MY PENCIL!!
18:54:53 <mniip> anyway!
18:55:25 <tobiasBora> I can't understand how to build the CompOption from this page: https://hackage.haskell.org/package/regex-tdfa-text-1.0.0.3/docs/Text-Regex-TDFA-Text.html#t:CompOption
18:55:29 <mniip> it would seem as if all vector spaces are exponential objects over their scalar field
18:55:52 <mniip> at least, I can't find any that aren't, is that so?
18:56:28 <tobiasBora> Ah, maybe from https://hackage.haskell.org/package/regex-tdfa-1.2.2/docs/Text-Regex-TDFA-Common.html#t:CompOption
18:56:48 <mniip> do K-modules also have this property?
18:56:54 <mniip> I assume not
19:23:51 <msko>  
19:25:15 <mniip> but if linear spaces are X -> K
19:25:20 <mniip> then bases are just X -> X -> K
19:25:32 <mniip> forall X
19:25:46 <sophiag> mniip: i'm still struggling with this GADT :/
19:25:55 <sophiag> would it help to see the full code?
19:26:14 <mniip> is there a natural isomorphism between Set x Field and Vect?
19:26:21 <mniip> sophiag, probably
19:29:09 <sophiag> mniip: here you go: http://lpaste.net/354215. hopefully better than my verbal explanation :p
19:29:32 <mniip> uhhuh
19:29:41 <sophiag> you see i do have that type RhsT that groups together everything that could be in the type variable for OpT
19:29:44 <mniip> a better explanation would be one including what you're trying to do on large scale
19:30:07 <sophiag> mniip: i did include that
19:30:30 <mniip> I only see code
19:30:34 <sophiag> also i'll be totally honest, this is the first time i'm talking to you...but two other people asked me the same thing when i told them it yesterday
19:30:35 <mniip> and some errors
19:30:45 <sophiag> i'm saying i said that right when you asked me earlier
19:30:55 <sophiag> and gave examples of input and output
19:30:59 <mniip> because as we already established you need to take a step back
19:31:06 <mniip> well you need an even further step back
19:31:15 <mniip> after you've parsed the stuff what are you going to do with it
19:32:21 <sophiag> i'm going to match up the two lists of records and filter the lists in Amb with lambdas in Require when their strings match. if there are no strings then they apply to all the lists
19:32:41 <sophiag> and call permutations on them
19:33:23 <sophiag> i have the behavior very well defined because i've already written it in Scheme, plus hardcoded examples into the list monad
19:33:41 <sophiag> it's parsing lambdas that's giving me trouble and i figured at the end of yesterday i was almost there
19:33:50 <mniip> filter sounds like you want all results to be boolean
19:34:09 <sophiag> what do you mean by results?
19:34:18 <mniip> well
19:34:22 <mniip> end result lambdas
19:34:29 <mniip> or something
19:34:30 <sophiag> yes, and you can see that's the case in my code
19:34:41 <sophiag> all lambdas have type (RhsT -> Bool)
19:34:49 <mniip> then why do you say you need a generic parse?
19:34:56 <robertkennedy> It looks like you're putting parseNumOp as the first arg of NumOp. Maybe needs an fmap?
19:35:28 <sophiag> mniip: i don't understand what you mean by "generic parse"
19:35:41 <sophiag> robertkennedy: can you expand on that?
19:35:41 <mniip> sophiag, parseOp :: Op a
19:35:43 <mniip> forall a
19:35:48 <mniip> or exists a
19:35:49 <mniip> either way
19:36:19 <sophiag> well it needs to take an expression...
19:36:33 <mniip> sophiag, with that specification...
19:36:54 <mniip> I'm afraid GADT isn't the right choice for you
19:37:03 <sophiag> that's fine. how would you do this?
19:37:12 <mniip> a GADT could be the output of a typechecker
19:37:17 <mniip> but not the parser
19:37:21 <sophiag> i keep getting different advice and then people are like oops, sorry
19:37:48 <mniip> do you care about type checking/inference/soundness in your DSL?
19:37:56 <sophiag> you woudln't use a parser? how else do you get strings from a command line into data structures?
19:38:11 <xiaohu> hello，everyone！
19:38:13 <mniip> nonono
19:38:14 <sophiag> mniip: no. obviously the way i defined it it can be abused
19:38:16 <mniip> that's not what I said
19:38:29 <mniip> I'm saying you can't directly feed a parser into a GADT
19:38:51 <robertkennedy> On 135 I would think you'd want something like `parseOp exp = (NumOp <$> parseNumOp exp) <|> (CharOp <|> parseCharOp exp)` etc
19:38:51 <sophiag> and i'm saying i only used a GADT because someone told me to yesterday and seemed very sure about it
19:38:54 <mniip> sophiag, then I'd use a regular datatype for an AST
19:39:06 <mniip> no GADTs involved
19:39:25 <mniip> then write something like
19:39:32 <robertkennedy> Sorry that second one should also be `CharOp <$> parseCharOp exp`
19:39:41 <sophiag> then how would you handle recursive cases? like (\x -> x == (1+2)) or something like that
19:39:41 <mniip> tryEval :: Value -> Either TypeError Value
19:40:08 <mniip> it's called Abstract Syntax *Tree* for a reason
19:40:21 <mniip> are lambdas always unary
19:40:22 <sophiag> robertkennedy: it appears you're not reading the function that's throwing errors...
19:40:27 <mniip> and/or can you use lambdas in lambdas
19:40:53 <sophiag> always unary, no lambdas in lambdas
19:41:39 <robertkennedy> I think the first 10 errors are all about lines 135-138?
19:42:35 <sophiag> robertkennedy: yes, but i have no idea what you're suggesting. you're using new data constructors without defining them, for example
19:42:46 <mniip> data Value = IntValue Int | BoolValue Bool
19:43:10 <mniip> data Expr = ArgumentExpr | ContExpr Value | Operator (Value -> Value -> Maybe Value)
19:43:12 <jmcarthur> It's very reasonable to make a GADT from a parser, but somehow it's going to have to do typechecking at the same time, and that's just not very fun.
19:43:18 <mniip> eval :: Expr -> Maybe Value
19:43:33 <sophiag> mniip: this code you're throwing out is in place of what>
19:43:36 <sophiag> *?
19:43:44 <mniip> all your data structures
19:44:04 <mniip> ditch OpT and RhsT
19:44:43 <sophiag> what about all the rest? 
19:44:57 <mniip> o wait
19:45:02 <sophiag> what about parsing strings?
19:45:06 <mniip> Operator (Value -> Value -> Maybe Value) Expr Expr
19:45:13 <mniip> parsing strings stays mostly as is
19:45:18 <mniip> just produces new AST
19:45:38 <sophiag> how can it stay as is if i delete the data type it uses?
19:45:42 <mniip> also if you didn't catch, I'm spewing out very general code
19:45:50 <mniip> having taken 2 steps back
19:46:12 <sophiag> i'm not catching *anything* that you're saying
19:46:20 <mniip> :v
19:46:23 <mniip> ok
19:46:31 <mniip> you asked what would I do
19:46:49 <mniip> and I started explaining what I would do in general if I was presented with this task
19:46:58 <robertkennedy> sophiag: you're right, I thought I was close enough to be helpful. `parseOp exp = unwrapJust ((NumOp <$> parseNumOp exp) <|> (EqOp <$> parseEqOp exp) ...)`
19:47:01 <sophiag> you responded that i should delete all my data types yet keep functions that use them...
19:47:18 <mniip> no
19:47:26 <mniip> I started with the AST datatype
19:47:33 <sophiag> robertkennedy: so...my code exactly as is?
19:48:01 <sophiag> Literal?
19:48:18 <robertkennedy> Are we looking at the same code?
19:48:55 <sophiag> i'm having trouble handling two conversations at once
19:49:04 <sophiag> also with suggestions and not knowing what they refer to
19:49:23 <mniip> sophiag, okay, forget about your existing code for a bit
19:49:36 <sophiag> okay
19:49:46 <mniip> think about a generic expression AST augmented with one feature
19:49:54 <mniip> a special token that stands for the lambda argument
19:50:05 <sophiag> ok
19:50:07 <mniip> that's what I called ArgumentExpr in my case
19:50:40 <mniip> since you don't care about types, you can evaluate that AST right away once you have the Argument
19:50:53 <sophiag> how do you construct actual lambdas from AST types, though? i tried that and it didn't work
19:51:06 <mniip> actual lambdas?
19:51:32 <sophiag> as in you can't just pass an AST to a function
19:51:45 <mniip> what distinguishes an actual lambda from a fake lambda?
19:51:51 <mniip> what is a fake lambda
19:51:54 <sophiag> a lambda vs. the ast of a lambda
19:52:05 <mniip> that's where 'eval' steps in
19:52:13 <mniip> you write a function that can evaluate your AST
19:52:46 <sophiag> well first i obviously need a data structure that lets me store all parts of the asts in a list
19:52:57 <mniip> what why
19:53:06 <mniip> why a list
19:53:11 <sophiag> remember when i described what this code does?
19:53:23 <sophiag> that was what i said.
19:53:39 <sophiag> a few times i think
19:53:50 <sophiag> i mean, i'm open to other wways
19:54:02 <mniip> maybe I'm not understanding what you're trying to say
19:54:12 <mniip> it sounded like you want to represent a single lambda as a list
19:54:17 <sophiag> no...
19:54:34 <mniip> okay then what is the problem
19:54:47 <mniip> your Require datatype seems to do just that
19:55:19 <sophiag> i'm going to match up the two lists of records and filter the lists
19:55:19 <sophiag> 	  in Amb with lambdas in Require when their strings match. if there
19:55:19 <sophiag> 	  are no strings then they apply to all the lists. then call permutations on the lists
19:55:35 <mniip> what records
19:55:37 <sophiag> mniip: yes, Require does do that...that's why i wrote it :)
19:55:41 <mniip> and what is Amb
19:56:04 <sophiag> Amb is the list of lists 
19:56:13 <sophiag> Require is the list of lambdas (plural)
19:56:24 <mniip> uhhhhh
19:56:41 <mniip> "the two lists of records" sound like very concrete lists of records but you never mentioned them before
19:57:11 <sophiag> those sentences above are copied and pasted from a half hour ago
19:57:18 <mniip> right
19:57:49 <sophiag> i also said the same thing with a little less detail a few hours ago
19:57:57 <mniip> I had the same question pop up in my head half an hour ago
19:58:10 <mniip> but i decided to ignore it because we were focused on something having no relevance to it
19:58:11 <sophiag> not just in your head...you asked it. and i answered
19:58:40 <sophiag> and i did say this earlier as well. i'm trying to give as much detail as possible and willing to state it multiple times
19:58:53 <robertkennedy> Is your current goal to just get the code in http://lpaste.net/354215 to compile? 
19:59:13 <mniip> sophiag, I don't think I've asked until now?
19:59:26 <sophiag> robertkennedy: basically yes
20:00:16 <sophiag> mniip: trust me, i don't write long descriptions of code irrelevant to the problem i'm trying to solve unless someone going out fo their way to help me asks
20:00:27 <mniip> sophiag, okay, I'm going to ask all things I haven't figured out yet
20:00:39 <sophiag> ok
20:02:20 <mniip> What are you doing on a large scale? What are these predicate lambdas being called with? What are records? What are the two lists? How are they related to the Amb datatype? What is the Amb datatype for? What do the "strings" mean? What are "all the lists"? What do you mean "permutations"?
20:03:46 <sophiag> there are two records: Amb and Require. Amb is for data and Require is for the lambdas. so far i'm just testing consing the lists with the two state monads of the same names. permutations means the function called permutations
20:03:55 <robertkennedy> In addition to fixing the error I mentioned before about your missing (<$>) in 135 etc, the type of `parseRequire` may be more prohibitive than you want? You could replace it with `Exp -> Require a` for free I think
20:04:35 <mniip> what are records
20:04:39 <sophiag> robertkennedy: i removed <$> because mniip suggested it
20:04:55 <mniip> [that's missing some context]
20:05:27 <dfeuer> edwardk: Plonk
20:05:30 <sophiag> robertkennedy: can you say the names of functions you're specifically referring to as well rather than alternative names? if it's not in my code then i don't know what you're talking about
20:05:44 <sophiag> mniip: they just use record syntax is all
20:06:01 <mniip> aha
20:06:20 <sophiag> that's sort of irrelevant. the point is those two are the highest level data types i use here. they actually store everything
20:06:45 <mniip> so Amb is irrelevant to the lambdas issue?
20:06:52 <sophiag> Amb works fine
20:06:59 <sophiag> so, yes
20:07:01 <mniip> we can focus on the lambdas
20:07:06 <sophiag> exactly
20:07:08 <mniip> in large you need to parse text into a predicate
20:07:21 <sophiag> yes, essentially
20:07:53 <mniip> ok, so far I've explained what would be a good AST to parse into
20:08:06 <mniip> and you wonder how to make a predicate out of an AST?
20:08:24 <sophiag> as mentioned, i tried working with raw ASTs but had no clue how to parse one into a lambda
20:08:31 <xiaohu> I am a newcomer of Haskell. When I install leksah,I meet a problem.I installed it step by step according to the guidance of github. But when I execute ./leksah ,there is an error with displaying " cabal : unrecognised command".
20:08:33 <robertkennedy> Man Im sorry, I meant `parseReq :: Exp -> Require (RhsT -> Bool)` could be `parseReq :: Exp -> Require a` as it currently is set up
20:08:33 <sophiag> err eval not parse
20:09:05 <mniip> sophiag, can you write a function 'eval :: Expr -> Value -> Maybe Value'
20:10:15 <mniip> where as said above Expr is an AST and Value is a primitive datatype
20:10:17 <sophiag> mniip: yeah...basically *all* of the functions in this section are broken down pieces of trying to do that
20:10:27 <sophiag> right?
20:10:34 <mniip> no
20:10:41 <sophiag> yes, that's what i'm trying to do here
20:10:41 <mniip> I don't see a single piece of evaluation code
20:11:03 <sophiag> i don't actually evaluate them, but in parseReq i piece them together into lambdas
20:11:08 <mniip> yeah no
20:11:10 <mniip> that can't work
20:11:19 <mniip> wellllllll maybe
20:11:20 <sophiag> ok
20:11:23 <sophiag> ok
20:12:01 <xiaohu>  When I install leksah,I meet a problem.I installed it step by step according to the guidance of github. But when I execute ./leksah ,there is an error with displaying " cabal : unrecognised command".
20:12:05 <sophiag> robertkennedy: i've already tried the two things you suggested quite a while ago and they don't fix these errors. have you test them and i'm missing something?
20:12:09 <jayshua> xiaohu: Did you follow the fistep that said to get ghc and cabal by going to haskell.org/downloads?
20:12:12 <mniip> okay
20:12:16 <mniip> it might somewhat work
20:12:27 <xiaohu> jayshua yes
20:12:39 <mniip> but your lambdas will still be littered with Value
20:12:45 <mniip> as you have no types
20:12:51 <jayshua> xiaohu: Do you know if cabal is in your path?
20:12:53 <sophiag> they're all of the same type
20:13:00 <sophiag> RhsT -> Boll
20:13:00 <mniip> Int vs Bool?
20:13:06 <sophiag> *Bool
20:13:14 <xiaohu> The Glorious Glasgow Haskell Compilation System, version 7.10.3
20:13:17 <mniip> Rhs is the argument of the lambda?
20:13:58 <sophiag> yes. and the part i'm not typechecking is that it matches the lists i'm filtering it with. that's where you can break the dsl, but i'm okay with that
20:13:59 <xiaohu> cabal-install version 1.22.6.0  using version 1.22.5.0 of the Cabal library
20:14:08 <xiaohu> jayshua right?
20:14:13 <mniip> sophiag, you need a different lambda type
20:14:33 <sophiag> mniip: i had one and deleted it on someone's advice yesterday
20:14:36 <mniip> you need a datatype that can hold all intermediate values that arise in the computation
20:14:51 <mniip> and then your lambdas will have type RhsT -> That
20:14:52 <jayshua> xiaohu: If you type "cabal" into your command prompt/terminal you should see something along the lines of "cabal: no command given"
20:15:05 <sophiag> well they do all return Bool
20:15:09 <mniip> no
20:15:16 <mniip> in the end they do
20:15:18 <xiaohu> cabal: no command given (try --help)
20:15:20 <xiaohu> yes
20:15:28 <mniip> but their intermediate parts do not neccesairly do that
20:15:33 <xiaohu> what should I do?
20:15:54 <mniip> think about it structurally
20:16:03 <sophiag> ok, well between the types i have they do store all that...i just think i need to refactor OpT
20:16:13 <mniip> if you have xyz == abc
20:16:33 <xiaohu>  I have add the ~/cabal/bin to the PATH
20:16:39 <mniip> to evaluate that, you evaluate xyz, then evaluate abc, then check if they are equal
20:16:57 <mniip> you do return Bool
20:17:02 <mniip> but xyz and abc not so much
20:17:12 <sophiag> but the lhs in this case is a bound variable
20:17:47 <mniip> how do I explain
20:17:49 <sophiag> i think you're referring to the recursive cases on the rhs i was trying to solve with the GADT
20:18:29 <jayshua> xiaohu: Well, I've never used leksah I'm afraid. Maybe someone else on here can help more. The only thing that comes to mind is restarting to make sure the new path is picked up everywhere. On the other hand, it's possible to learn Haskell without leksah if that's what you're trying to do. Sorry I can't be of more help!
20:18:55 <mniip> I understand it intuitively in like 3 separate ways but I can't convey it with words
20:19:03 <sophiag> mniip: i think most helpful would be to start with the code i have and make concrete suggestions about the parts that aren't working
20:19:09 <sophiag> i.e. OpT
20:19:33 <mniip> your whole code is poorly structured
20:19:40 <mniip> because it can only handle simple expressions
20:20:20 <mniip> if your expression type was more flexible you could handle expressions in expressions much more easily
20:20:49 <mniip> hence why I'm suggesting you expand the result type to include all intermediate types
20:20:49 <sophiag> it depends on what you mean by simple. in some ways i am restricting them, in some ways it may just be starting simple in ways that don't scale
20:20:52 <xiaohu> jayshua: Leksah requires ghc --version >=7.10.3 and cabal --version >=1.24. To get them go to haskell.og/download and choose the Minimal GHC or Haskell Platform.
20:21:00 <xiaohu> this is from github
20:21:15 <mniip> because that way your complete lambda type is the same as your subexpression type
20:21:15 <sophiag> but regardless, you don't mean "my whole code" because we already went over the parts that do work
20:21:21 <xiaohu> cabal-install version 1.22.6.0 using version 1.22.5.0 of the Cabal library 
20:21:28 <mniip> I'm only talking about lambdas now
20:21:35 <xiaohu> this is the version of cabal in my computer
20:21:44 <mniip> sophiag, are you familiar with the reader monad?
20:21:51 <sophiag> yes
20:21:55 <mniip> ok then
20:22:03 <mniip> imagine that your lambdas aren't functions
20:22:06 <sophiag> does that really makes sense here
20:22:08 <mniip> but rather actions in the reader monad
20:22:19 <sophiag> ok
20:22:27 <mniip> \x -> (x + 1) > 5
20:22:29 <xiaohu> Version is too low ？？？？
20:22:41 <mniip> do x <- ask; return (x + 1) > 5
20:22:58 <mniip> now, that's not very structural
20:23:07 <jayshua> xiaohu: Possible, but the problem sounds like Leksah can't find cabal for some reason.
20:23:09 <sophiag> why not just use \x -> x > 6 ?
20:23:15 <mniip> example reasons
20:23:21 <jayshua> xiaohu: Not that it found the wrong version.
20:23:33 <sophiag> but i'm saying that by restricting it to the cases i already explained i don't need all that generality
20:23:39 <pikajude> binaries created from haskell programs take about ten billion years to start on WSL
20:23:49 <pikajude> anyone know what that's about
20:24:06 <mniip> but then you will not be able to support two-level expressions without a complete overhaul
20:24:11 <mniip> is that what you want
20:24:16 <sophiag> i already stated i don't intend to
20:24:33 <robertkennedy> xiaohu: if you need leksah you may have to hack it up to date; the project is not maintained to my knowledge
20:24:34 <mniip> you will also write a ton of cases for 'x > 5' '5 > x' etc
20:24:43 <sophiag> well, only the former
20:24:57 <mniip> okay then
20:25:04 <mniip> if that is what you want
20:25:08 <sophiag> and yes, i will. it's a dsl so that's easy
20:25:29 <MarcelineVQ> robertkennedy: the github source is active, hackage release is behind
20:27:02 <sophiag> mniip: i would consider refactoring for very general cases of lambdas if you could communicate how to do so, but it's been literally hours and hours so i'd prefer to just make the way i'm doing it work. right?
20:27:25 <hamishmack> xiaohu: To upgrade cabal-install run.  cabal upate && cabal install cabal-install
20:27:28 <xiaohu> I do not know why my computer can not find cabal command
20:27:47 <Camm1> Hello everyone. I need your help to understand the value of a ReaderT Monad Transformer. The example that I've done simple shows that a ReaderT enables me to avoid sending configurations to a function through a parameter. However, I don't really understand the value of that. http://lpaste.net/354225
20:28:10 <mniip> sophiag, I was trying to explain how to make it structurally better
20:28:14 <mniip> sorry for wasting your time
20:28:21 <xiaohu> hamishmack: ok ,I try it now
20:28:33 <pikajude> ah indeed, it's a bug in WSL's handling of uncommitted pages
20:28:35 <mniip> sophiag, what you're trying to do is fairly simple
20:28:36 <pikajude> ignore me everyone
20:28:58 <Camm1> Could you help me please to understand how could I use ReaderT in other situations?
20:29:18 <Camm1> When is relevant to use ReaderT?
20:29:27 <sophiag> mniip: no i'm sure you're correct. i'm just making a distinction between "i'd always like to learn" and "what i actually need here"
20:29:41 <Axman6> passing configuration around is the most common use of ReaderT
20:30:02 <mniip> sophiag, so, you have a fixed set of shapes for your lambda, right?
20:30:12 <sophiag> yes, currently that's how i'm doing it
20:30:34 <jle`> Camm1: some people use ReaderT to solve "the configuration problem"
20:30:46 <Koterpillar> Camm1: a lot of Web frameworks use it for confligration
20:30:49 <jle`> Camm1: in your case it's a bit overkill
20:30:51 <Koterpillar> Camm1: so does XMonad, for example
20:30:55 <mniip> then you want to implement that logic into a function of type Exp -> Maybe (RhsT -> Bool)
20:30:55 <jle`> Camm1: but imagine if you had hundreds of functions like myReader
20:31:03 <sophiag> as mentioned, if you could even hack together something short explaining a better way i'd definitely try it. but not sure that's going to happen
20:31:05 <jle`> er, hundreds of actions
20:31:30 <jle`> Camm1: imagine if they all call each other, from each other.  passing parmaeters manually gets tedious, and you also might accidentally pass the wrong parameter
20:31:41 <sophiag> mniip: yes. i think it just comes down to that GADT. i professed my ignorance from the start
20:31:48 <mniip> no GADTs here
20:31:53 <sophiag> ok cool
20:32:21 <mniip> suppose you have two function shapes
20:32:22 <sophiag> i probably still need the pragma tho for constraints. something interesting i learned yesterday 
20:32:32 <mniip> x <relation> <number>
20:32:40 <mniip> x <arith> <number> <relation> <number>
20:32:46 <sophiag> yes, that's curretnly sort of the form
20:33:24 <mniip> first you make an auxiliary function that turns "<relation>" into Ord a => Maybe (a -> a -> Bool)
20:33:31 <mniip> just its name
20:33:39 <mniip> then the same for the <arith>
20:34:07 <mniip> then you let parseOp pattern match the Exp constructors and depending on the shape query the two auxiliary functions
20:34:14 <mniip> and assemble a lambda out of the results
20:34:44 <sophiag> yes
20:35:08 <sophiag> this is the same code i've had for days :p
20:35:21 <mniip> oh sorry
20:35:23 <mniip> parseLambda
20:35:27 <sophiag> been trying to debug the same errors and keep getting told one thing then another that turns out not to work :p
20:35:34 <mniip> parseOp would parse an operation
20:35:36 <mniip> not something you can do
20:35:54 <sophiag> well i combined it to just create the record directly
20:36:10 <sophiag> although frankly i'd rather have a lambda type since i need one version that tags it as well
20:36:14 <Camm1> jle`: For instance, somethig like this: http://lpaste.net/354226
20:36:36 <sophiag> i should probably abandon all suggestions from the person who gave me the one that didn't compile
20:36:50 <sophiag> i'm establishing a mental list of who not to listen to in this channel :p
20:37:01 <sophiag> it's hard when you yourself are a newbie
20:37:13 <mniip> who was that if I may
20:37:18 <jle`> Camm1: yes, like that.  except maybe even more layers of nesting might make it more worthwhile
20:37:40 <mniip> it's very rare that someone says something wrong and isn't immediately corrected
20:37:42 <Camm1> Well, I think I understand your point. Thanks jle` :-)
20:37:45 <sophiag> mniip: i like him so sort of don't want to say
20:37:51 <jle`> Camm1: it's "easy" to pass parameters directly even in that example, but for large projects with things over multiple files and modules, it gets less trivial
20:38:00 <mniip> sophiag, it is likely that you misinterpreted what they said
20:38:10 <jle`> i use implicit params though instead of ReaderT these days.  even though there are drawbacks
20:39:59 <sophiag> plus it's not like it's out of ignorance almost all the time. it's verbal communication problems
20:39:59 <sophiag> this solution worked in the abstract and/or some other case than mine
20:40:11 <sophiag> mniip: he said earlier it was the reverse
20:40:28 <sophiag> it was an honest mistake
20:40:40 <mniip> hum
20:40:43 <sophiag> it's just many honest mistakes amount to 100s of hours of my time :/
20:40:50 <mniip> ahhhh
20:40:55 <mniip> all this time I thought you're using TH
20:41:05 <sophiag> TH?
20:41:07 <sophiag> oh
20:41:08 <sophiag> no
20:41:12 <sophiag> ha
20:41:25 <mniip> Exp and the constructors had fooled me for a long time
20:41:32 <mniip> making me reluctant to code up some prototype
20:41:35 <sophiag> that probably would be a route to achieve this sort of thing, right?
20:41:44 <sophiag> but i figure it'd take me a while to learn
20:41:45 <mniip> quite the opposite
20:41:48 <Koterpillar> sophiag: maybe you need to prepare a paste that has your problem description and goals on top
20:41:55 <Koterpillar> (meta-suggestion)
20:42:26 <sophiag> koterpillar: i am starting to archive my answers to the same questions so i can answer the same people when they ask several times a day
20:43:00 <sophiag> "but what does your program do?" *copy and paste the same thing i pasted five times to the same person yesterday*
20:46:31 <Camm1> jle`: Implicit parameters seems interesting! Which type of drawbacks do they have?
20:47:14 <jle`> the main one is that things get complicated when you want to use more than one configuration in the same program
20:47:31 <jle`> also they can't be used in typeclass instances
20:47:36 <jle`> i think those are the main ones
20:51:16 <Camm1> Ok, thanks jle`
20:55:04 <mniip> sophiag, coming up with some code
20:55:14 <mniip> for recursive expressions
20:55:17 <sophiag> mniip: all i needed to do to make parseOp compile was ditch the GADT for a normal data type :p
20:55:30 <sophiag> but then i have lost the recursive definitions
20:56:10 <sophiag> and still have an error on line 148
21:03:34 <lpaste> mniip pasted “stuff” at http://lpaste.net/354227
21:03:37 <mniip> sophiag, ^
21:04:45 <mniip> that's how I'd do it
21:04:54 <mniip> sans runCode, that's just testing
21:06:46 <sophiag> wow :D
21:06:54 <sophiag> ok, lemme try it out
21:08:06 <sophiag> Value does need to be Integers, Strings, and Chars
21:08:54 <mniip> adapt as needed
21:09:12 <sophiag> also it's confusing to me to say (Value -> Maybe Value) instead of (Value -> Bool)
21:09:52 <sophiag> mainly evalExpr solves what i haven't been able to i think
21:10:13 <mniip> because I'm using evalExpr recursively
21:10:17 <sophiag> and your structure for parsing is more clever, i.e. less verbose
21:10:19 <mniip> hence it's not retunrning Bool
21:10:25 <sophiag> ah ok
21:11:11 <mniip> runCode "\\x -> x + x + x + 12" (IntValue 10)
21:11:11 <mniip> IntValue 42
21:11:54 <mniip> hmmm you probably want to have
21:12:08 <mniip> evalExpr var (Paren _ e) = evalExpr var e
21:12:39 <sophiag> yeah, likely
21:13:30 <sophiag> i haven't tested this, but i'll be able to call runCode from a state monad like in my broken version?
21:14:01 <mniip> probably
21:14:16 <mniip> though you said you want lambdas in a list
21:14:23 <mniip> you should use evalLambda directly
21:14:53 <sophiag> oh right
21:15:59 <sophiag> mainly i'm just debating going home since it's sunday and i'm beat vs. refactoring my program now :p
21:16:13 <sophiag> this great though :D
21:16:53 <sophiag> everything i was fooling around with that GADT for i could have just used a recursive function
21:20:06 <mniip> 7 am counts as monday, right?
21:21:21 <sophiag> eastern europe?
21:21:26 <sophiag> i'm in new york
21:21:41 <lambdafan> NYC represent!
21:21:48 * lambdafan waves
21:21:53 <sophiag> ha
21:22:18 <sophiag> if i was rich i'd take out an ad campaign convincing people not to move here
21:23:10 <Guest35162> Anyone available to check why my haskell script does not work? Concurrency related :D (willing to pay via btc  it's 50 lines literally. Thanks in advance
21:25:24 <lyxia> @lpaste Guest35162 You can just paste your code and link it here.
21:25:24 <lambdabot> Haskell pastebin: http://lpaste.net/
21:25:26 <peddie> Guest35162: why don't you post your code on lpaste first and share the link here; people will probably help for free
21:26:11 <Guest35162> http://lpaste.net/354228
21:28:04 <mniip> Guest35162, what's not workign?
21:28:09 <Guest35162> I am new to functional programming :/
21:28:37 <Guest35162> For some reason it says it's not parsing the input Event
21:28:54 <mniip> ?
21:29:57 <mniip> ahh
21:30:01 <Guest35162> That's the problem : http://lpaste.net/6525819317232074752
21:30:02 <mniip> your indentation is messed up
21:30:14 <Guest35162> Is there any indentation fixer? :/
21:30:26 <Guest35162> It's painful every time to fix the indentation
21:30:35 <mniip> fix?
21:30:39 <Guest35162> Yah
21:30:47 <mniip> why is it messing up?
21:31:01 <Guest35162> I am getting used to the way of thinking of Functional programming but there is a lot ahead
21:31:02 <sophiag> mniip: thanks so much for your help today. pretty sure that snippet is going to fix the problem i've been pulling my hair out for days dealing with. i think i need to head home and find some food, but will update you next time i see you on here :)
21:31:18 <Guest35162> the indentation?
21:31:31 <Guest35162> I tried haskell beautifiers and what not but it did not work for me
21:31:50 <monochrom> Haskell indentation cannot be automated.
21:31:59 <Guest35162> Ah thanks for letting me know :P
21:32:00 <Guest35162> <3
21:32:08 <mniip> monochrom, sure can?
21:32:20 <mniip> sprinkle it with {;} and use none?
21:32:29 <Guest35162> I am willing to pay via BTC for ur time if anyone can help me finish it.
21:32:50 <monochrom> mniip, I don't think that's worth answering, and you know it.
21:33:51 <mniip> monochrom, the assignment or the layout pedantry?
21:37:48 <Guest35162> Anyone willing to help?
21:40:46 <seafood> I wanted to know what the status of Generic Haskell is.
21:41:47 <pacak> Generic Haskell?
21:42:58 <Jello_Raptor> seafood: mmm? https://wiki.haskell.org/Generics
21:43:05 <Guest35162> Anyone can help me willing to pay via btc small script 50 lines
21:43:33 <Jello_Raptor> I mean if you're asking you've probably already seen that, I'm just wondering which of those things you mean by Generic Haskell
21:44:26 <seafood> Okay, so I was looking at an old paper by Ralf Hinze on deriving zippers for any data type.
21:45:07 <seafood> And I wanted to look at the source code. But http://generic-haskell.org no longer appears to hold that code.
21:45:28 <seafood> Looks like an SEO company stole that domain name.
21:46:11 <Jello_Raptor> seafood: https://hackage.haskell.org/package/instant-zipper-0.0.0 ?
21:47:10 <Jello_Raptor> hmm that actually doesn't look useful
21:47:19 <Guest35162> anyone with free time?
21:48:28 <pacak> Guest35162: Lots of people, but "small script 50 lines" is not descriptive enough to make a decision.
21:48:33 <glguy> Guest35162: It doesn't seem like you've asked a question yet
21:49:30 <mniip> hey glguy I thought you would know,
21:49:36 <seafood> Jello_Raptor: Hmm, perhaps that could be useful.
21:49:58 <mniip> is there a common notion of logarithms in type algebra?
21:50:21 <Guest35162> Here is my script
21:50:21 <Guest35162> http://lpaste.net/3614414072793006080
21:50:34 <Guest35162> Here are the instructions : http://lpaste.net/6525819317232074752
21:50:51 <Guest35162> Keep getting test.hs:36:3: error: parse error on input ‘Event’
21:51:13 <lyxia> mniip: that reminds me of this https://www.arxiv.org/abs/1502.04634
21:51:22 <lyxia> it's not really "common" though
21:51:42 <pacak> data Event = C Char | Time Char
21:51:48 <Guest35162> yes
21:51:50 <pacak>   Event <- readChan c
21:51:57 <Guest35162> Yes?
21:52:11 <pacak> This line should contain a patternmatch against one of the constructors
21:52:15 <pacak> Either C or Time
21:52:40 <pacak> And if it can get arbitrary events - you need to use case
21:53:09 <Guest35162> I thought of the channel like a queue, and that it could look like that:
21:53:13 <pacak> You seems to have this case on the next line but it won't typecheck
21:53:27 <pacak> So it can be
21:53:28 <Guest35162> 'timer' 9, 'C' 5,'timer' 2 ,'timer' 3
21:53:34 <pacak> event <- readChan c
21:53:52 <pacak> case event of
21:53:52 <pacak>   C c -> xxxx
21:53:52 <pacak>   Time  t -> yyyy
21:53:58 <Guest35162> so what I do? I am lost?
21:54:06 <Guest35162> Yes
21:54:52 <pacak> I haven't looked at remaining code but fixing event and using case should get you a bit further.
21:55:04 <lyxia> seafood: I was wondering about generic zippers just recently. I couldn't find an implementation with GHC.Generics, which is the current approach to generic programming in haskell.
21:55:07 <pacak> Try doing that and we'll have a look at the next error if there's any.
21:55:20 <Guest35162> So
21:55:24 <Guest35162> I have to change
21:55:32 <Guest35162> the typeclass to what?
21:55:50 <pacak> It's not typeclass, it's data type
21:55:57 <Guest35162> data type yeah
21:55:58 <pacak> You need to match against constructors
21:56:23 <Guest35162> and how do I match? the documentation is not the best I have seen cause I am not used to functional programming :/
21:56:45 <Guest35162> That's why I am willing to pay for anyone's time, I need to get this done and understand when it actually compiles lol
21:57:35 <pacak> I can't make you understand, there's no shortcuts into Haskell. You'll have to study on your own :)
21:57:39 <pacak> https://www.haskell.org/tutorial/patterns.html 
21:58:01 <pacak> This link seems reasonable - you need case expressions
21:58:25 <Guest35162> Why? are there any shortcuts in other things to be in haskell lol :P
21:59:08 <Cale> Guest35162: What documentation are you reading?
21:59:20 <pacak> If you took other shortcuts without actually understanding you'll get stuck in a different place.
21:59:21 <Cale> You should get a full tutorial or book of some sort.
21:59:30 <Guest35162> The lectures I had in uni
21:59:33 <Guest35162> where super basic
21:59:40 <monochrom> I learned Haskell from https://www.haskell.org/tutorial/ too.
21:59:42 <Guest35162> and now out of the blue we have to know this..
22:00:04 <Guest35162> Those tutorials are 1999 lol
22:00:11 <pacak> http://learnyouahaskell.com - I like this one
22:00:15 <Guest35162> and the lecture notes are simple
22:00:32 <Cale> http://www.cis.upenn.edu/~cis194/spring13/lectures.html has some decent notes
22:00:42 <Guest35162> I have seen learnyouahaskell
22:00:57 <mniip> lyxia, hmm
22:01:08 <mniip> lyxia, I'm thinking of log_a F(x)
22:01:15 <mniip> similar to dF(x)/dx
22:01:20 <mniip> the type derivativw
22:01:25 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html -- this is a good book
22:01:27 <glguy> mniip: I don't know of any such syntax myself
22:01:54 <mniip> err
22:01:58 <mniip> log_a F(a)
22:05:37 <mniip> hmm
22:06:02 <mniip> every vector space has a dimensionality which is a cardinal number, right
22:06:17 <mniip> which means that all vector spaces *are* exponential objects of scalar fields
22:06:46 <mniip> kinda tempted to represent vector spaces as functions
22:11:36 <lyxia> functional analysis is kind of about that
22:12:01 <loorke> Guys, which one should I learn first -- Haskell or Scheme (Racket)?
22:15:07 <pacak> loorke: Depends on a channel you asking. Here the answer would be #haskell.
22:17:11 <mikeplus64> hmmm -- anyone tried building Yi with ghcjs?
22:25:28 <mikeplus64> alternatively, and completely tangentially, is there an efficient way to observe laziness (maybe by giving thunks unique ids?) -- maybe just 'data Thunk a = Thunk !Int a'...
22:26:01 <Sebastian_> I would love to use TVars to solve a particular problem, but I have one problem: modifyTVar/modifyTVar' return () instead of any return value
22:26:56 <Sebastian_> Is there any way, other than doing insane things like settings a local TVar and then setting the return value to that TVar, to perform a TVar or similar datastructure modification and return a value?
22:27:00 <Sebastian_> *setting
22:27:11 <Guest35162> https://www.youtube.com/watch?v=ZhuHCtR3xq8 MoNADS
22:27:45 <cocreature> Sebastian_: can’t you just use "readTVar" after "modifyTVar"?
22:28:30 <Sebastian_> cocreature: Oh, I could do that within an atomically block and it would be still safely be ... atomic.
22:28:31 <MarcelineVQ> or do the steps that modify does yourself
22:28:40 <Sebastian_> cocreature: damn it, it was so obvious
22:28:54 <Sebastian_> LOL sorry guys, I've been programming in Go and JavaScript for the last little bit. Thanks.
22:31:12 <cocreature> no worries
22:53:24 <jle`> oh boy first timing turning on -XStrict and it already backfired on me
22:53:31 <jle`> i'm never writing strict-by-default code ever again
22:53:34 <jle`> not even once
22:54:17 <monochrom> haha
22:54:22 <thimoteus> what happened?
22:55:07 <jle`> oh it was kind of silly on hindsight, i just had a function generate an infinite list lazily
22:55:20 <jle`> but i didn't realize that -XStrict would break it
22:56:45 <monochrom> Yeah, don't use list.
22:57:08 <jle`> well the function was made to be a lazy pure generator, basically Stream
22:57:16 <jle`> but i just added a ~ and now things are fine i guess maybe?
22:57:39 <jle`> who knows
22:57:48 <jle`> reasoning with strict code is so weird
23:11:19 <cocreature> friends don’t let friends turn on -XStrict
23:44:54 <vaibhavsagar> what about -XStrictData?
23:45:12 <cocreature> vaibhavsagar: what about it?
23:45:29 <vaibhavsagar> is that similarly frowned upon?
23:47:17 <cocreature> vaibhavsagar: depends on who you ask. obviously some people like it otherwise they wouldn’t have added it
23:47:29 <jle`> i don't think either are frowned upon; -XStrict doesn't actually change the semantics of haskell or anything
23:47:37 <jle`> -XStrict and -XStrictData are basically syntactic sugar
23:48:08 <cocreature> personally I find it confusing to invert the default behavior so I don’t use either of them
23:48:18 <cocreature> but that’s at least partially because I’m so used to the old behavior
23:48:52 <jle`> it's definitely confusing to switch from file to file having to be aware of what the default behavior was
23:49:11 <jle`> but -XStrictData is much less pervasive than -XStrict so it's a little easier to rad
