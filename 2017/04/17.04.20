00:00:26 <dogukan> oh, this is the best irc channel i have ever seen :D
00:00:49 <pacak> dogukan: It will hapilly explode in your face if something is not matching.
00:01:17 <dfeuer> cocreature: I jus tdon't have a clear sense of what that ends up meaning. Do I end up seeing the cost of *calculating* actions, or of *executing* them?
00:01:18 <pacak> dogukan: And will kill your program with "Prelude.read: no parse"
00:01:34 <jle`> > readMaybe "Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)" :: Maybe (MyTree Integer )
00:01:37 <lambdabot>  error:
00:01:37 <lambdabot>      • Variable not in scope:
00:01:37 <lambdabot>          readMaybe :: [Char] -> Maybe (MyTree Integer)
00:01:43 <jle`> @let import Text.Read
00:01:45 <lambdabot>  Defined.
00:01:47 <jle`> > readMaybe "Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)" :: Maybe (MyTree Integer)
00:01:49 <lambdabot>  Just (Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6))
00:01:54 <jle`> > readMaybe "Brach 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)" :: Maybe (MyTree Integer)
00:01:56 <lambdabot>  Nothing
00:01:59 <cocreature> dfeuer: hm good point. in my experience, it always seemed to be the cost of the execution but I never really thought about it, sry
00:02:26 <dfeuer> cocreature: you may well be right. I just don't have enough of a clue.
00:02:59 <jle`> dogukan: but if you wanted to write it from scratch, parser combinators would make it simple.  'deriving Read' actually uses parser combinators behind the scenes to generate the 'read' function in a composable way
00:03:30 <pacak> :t reads
00:03:32 <lambdabot> Read a => ReadS a
00:04:00 <cocreature> dfeuer: one thing to keep in mind is that CPSed monads tend to attribute the whole do-block to the first action and so on which can be quite confusing (not sure if that applies to SimplM)
00:04:48 <dogukan> ok then, thank you guys, i appreciate your help
00:04:58 <jle`> parseTree = parseLeaf <|> parseBranch; parseLeaf = Leaf <$> (string "Leaf" *> parseThing); parseBranch = Branch <$> (string "Branch" *> parseThing) <*> parseTree <*> parseTree
00:05:04 <jle`> is more or less the entire parser written using parser combinators
00:05:10 <jle`> aside from whitespace handling
00:06:05 <tsahyt> wouldn't you need some combinator for parentheses there too?
00:06:05 <dfeuer> cocreature: thanks. I doubt it's CPSey, but I should check.
00:06:15 <jle`> ah yes
00:31:33 <dogukan> i couldn't even get your codes working on hugs, it is so hard for me to get used to haskell :D
00:32:02 <liste> hugs? what is this, 1999?
00:32:31 <dogukan> :D 
00:35:04 <mniip> do not use hugs
00:35:32 <liste> ^ that
00:35:51 <mniip> it's been unmaintained for years
00:36:33 <mniip> you wouldn't use Turbo C would you
00:37:20 <Rembane> Challenge accepted!
00:38:02 <dogukan> i prefer gcc :P
00:38:17 <mniip> right, likewise you should prefer a modern tool like ghc
00:46:55 <jle`> there are so many things wrong with using hugs today
00:47:01 <jle`> all up and down the toolchain
00:53:43 <dogukan> i found an online ghc compiler, now i am working on that instead of hugs :P
00:54:43 <tsahyt> why not just use ghci if you want a repl?
00:56:20 <dogukan> i do not have sufficient permissions to install anything to the computer that i am currently working on
01:05:38 <xormor> should Haskell suffice as a language for me to use as a mathematics studying aid?
01:07:52 <jle`> suffice in what way
01:08:01 <jle`> that you won't need to learn any other programming languages?
01:08:51 <Axman6> xormor: depends what sort of mathematics I guess
01:09:33 <mivael> hello
01:09:58 <jle`> hello mivael 
01:10:46 <mivael> Could someone please explain what "Some" part means in "data Map k v = IntMap (Some k v)" in the Data.HashMap description?  (http://hackage.haskell.org/package/hashmap-1.3.2/docs/Data-HashMap.html)
01:11:22 <xormor> Axman6, I am thinking of counting equations - derivatives and then integrals as I have learned them.
01:11:24 <Axman6> what's the definition of Some?
01:13:17 <MVQq> mivael: just looks like a stand-in for some type
01:13:22 <mauke> data Some k v = Only !k v | More !(M.Map k v) deriving (Eq, Ord)
01:13:25 <mauke> says the source
01:13:28 <mauke> it's an internal type
01:13:37 <MVQq> welp that's me being wrong :>
01:13:53 <Axman6> if you want a hashmap you should look at the unordered-containers package btw
01:14:04 <dogukan> i coulnd't get it working, i wrote this https://pastebin.com/RqKRkbuS but ghc gives "parse error (possibly incorrect indentation or mismatched brackets)" at lines 2 and 9                                                                                                                                                 
01:14:04 <Axman6> hashmap is quite old
01:14:53 <tsahyt> mivael: either a hash maps to exactly one element, or there is a hash collision, which needs to be resolved somehow. It does that by storing a Map of values that all have the same hash
01:14:56 <jle`> dogukan: what's line 7 doing there?
01:15:05 <tsahyt> mivael: that's what the Some type here is for
01:15:10 <jle`> you can only put declarations/definitions in haskell files
01:15:17 <jle`> stray expressions don't really make sense :o
01:15:23 <jle`> (at the top level, at least)
01:16:03 <jle`> dogukan: also you don't need the type annotation on line 9
01:16:14 <jle`> 'fringe (read "...")` should be fine
01:16:30 <jle`> oh wait i guess you do need the type annotation
01:16:56 <jle`> anyway, once you get rid of line 7, the syntax errors should go away
01:17:09 <jle`> then you just have a type error...you want print (fringe (read "..." :: MyTree Integer))
01:19:04 <dogukan> jle`: thanks again!
01:19:08 <jle`> no problem!
01:19:12 <dogukan> :D
01:20:06 <dogukan> is there a way to do this without type annotation?
01:20:44 <dogukan> forcing it to :: MyTree Integer
01:20:54 <jle`> the problem is that haskell needs a way to know that you want to read in Integers
01:21:12 <jle`> and not, say, Bools or ()s
01:21:40 <jle`> you could annotate the result of fringe, print (fringe (read "..") :: [Integer])
01:22:03 <jle`> if you're in ghc 8+, like you should be, you can also use type applications
01:22:15 <jle`> `main = print (fringe @Integer (read "..."))`
01:22:43 <jle`> the @Integer there says "use fringe with 'Integer' filled in for the type variable 'a'"
01:22:56 <jle`> you'd need to add {-# LANGUAGE TypeApplications #-} to the top of your file
01:24:34 <mniip> read @Integer
01:24:38 <mniip> seems to be more canonical
01:24:52 <jle`> it would have to be read @(MyTree Integer)
01:25:07 <mniip> ah
01:25:11 <mniip> I thought we're reading integers
01:25:21 <mauke> > read @(MyTree Integer) "Branch 5 (Branch 10 (Leaf 2) (Leaf 3)) (Leaf 6)"
01:25:23 <lambdabot>  error:
01:25:24 <lambdabot>      Pattern syntax in expression context: read@(MyTree Integer)
01:25:24 <lambdabot>      Did you mean to enable TypeApplications?
01:25:27 <mauke> aww
01:25:31 <jle`> :')
01:25:34 <jle`> * :'(
01:25:46 <mniip> @let {-# LANGUAGE TypeApplications #-}
01:25:48 <lambdabot>  Defined.
01:25:54 <MVQq> canonical? it's brand new :>
01:25:56 <mniip> I bet that doesn't work though
01:26:03 <mniip> :t id @Int
01:26:05 <lambdabot> error:
01:26:05 <lambdabot>     Pattern syntax in expression context: id@Int
01:26:05 <lambdabot>     Did you mean to enable TypeApplications?
01:26:05 <jle`> i've tried that before, but it seems like lambdabot just adds a comment to L.hs
01:26:11 <mniip> well yes
01:26:12 <cocreature> :set -XTypeαpplications
01:26:14 <jle`> it doesn't move it to the top of the file :(
01:26:19 <cocreature> I can’t even type
01:26:23 <mivael> Axman6, thank you for mentioning unordered-containers!  Looks like something I was looking for.
01:26:25 <MVQq> lambdabot doesn't to typeapps due to overlapping syntax concerns
01:26:27 <mniip> well, enabling arbitrary extensions could lead to bad things
01:26:27 <jle`> @let -- hello everyone
01:26:29 <lambdabot>  Defined.
01:26:44 <mniip> there was a command...
01:26:50 <jle`> @let {-# LANGUAGE NoSafe #-}
01:26:52 <lambdabot>  Defined.
01:27:29 <makalu> it seems that there is no library for writing tls websocket servers? There's wuss for clients and the websockets library supports non-encrypted websockets but what about servers?
01:27:43 <halogenandtoast> Does anyone know how to filter params in Yesod's logging. I'd like password not to show up.
01:28:10 <jle`> makalu: is the problem with 'websockets' that it's unencrypted?
01:28:19 <makalu> jes
01:28:25 <makalu> yes* sorry
01:28:28 <cocreature> makalu: iirc you can just use the websockets library in combination with warp-tls
01:29:49 <Axman6> halogenandtoast: as in URL params? you should never have password in URL params...
01:30:07 <mniip> I guess not
01:30:11 <mniip> well, there is http://silicon.int-e.eu/lambdabot/State/Pristine.hs
01:30:15 <mniip> but that's not the L.hs
01:30:39 <jle`> :t cata
01:30:41 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
01:31:58 <fvgs> Any macOS users here who successfully installed ghc via Homebrew?
01:32:31 <merijn> fvgs: No, I generally just install the binary release of GHC and build cabal with that
01:32:35 <vaibhavsagar> mniip: is there a joke I'm not getting here?
01:32:43 <Axman6> I just use stack to install GHC
01:33:10 <fvgs> merijn: Do you mean this one? https://www.haskell.org/ghc/download_ghc_8_0_2#macosx_x86_64
01:33:11 <merijn> fvgs: There's ghcformacosx, but it doesn't seem to have a GHC 8 version
01:33:15 <merijn> fvgs: Yeah
01:33:51 <merijn> fvgs: Download, unzip read instructions (which boil down to "./configure --prefix=path/to/install && make install") and it works
01:33:53 <dogukan> thanks everyone for helping me, i started to understand haskell :)
01:33:55 <fvgs> I expected Homebrew to install a bottled version, but now it's compiling it from source which supposedly takes hours
01:34:01 <dogukan> (finally)
01:34:15 <fvgs> merijn: is it relatively quick?
01:34:18 <MVQq> oh it really shouldn't take hours :>
01:34:26 <merijn> fvgs: Yes, like...seconds
01:34:52 <merijn> fvgs: It's a binary, it's already compiled, it's just copying stuff to the right paths
01:35:11 <quchen> fvgs: You’re a beginner, right? Use Stack! (Others have probably suggested this before, so here I am adding emphasis.)
01:35:12 <merijn> fvgs: Of course you need to make sure the prefix you specify is actually on your path, but other than that :)
01:35:19 <fvgs> As I'd expect. I just don't understand why Homebrew doesn't do that... the Homebrew formula even downloads the binary
01:35:25 <fvgs> but then proceeds to compile from source
01:35:35 <merijn> fvgs: Well, they need a binary to compile the source :p
01:35:50 <merijn> fvgs: Since GHC is written in Haskell you can't compile it without GHC :p
01:35:51 <halogenandtoast> Axman6: no it was in post params
01:35:55 <merijn> fvgs: No clue why they do that
01:35:59 <halogenandtoast> POST /auth/page/emailRegister/register
01:36:00 <halogenandtoast>   Params: [("_token","SyIeBitRXJ"),("email","halogenandtoast@gmail.com"),("password","password")]
01:36:19 <merijn> There's also stack, which I've stubbornly refused to learn, so I can't tell you how to do that :p
01:36:30 <chichou> what's wrong with homebrew ghc? I'm a beginner and have it installed, it's working well so far for me :-)
01:36:35 <fvgs> merijn: Right, I figured that's why they download it. But I would rather it manage the binary package instead of compiling from source xD
01:36:48 <merijn> chichou: Nothing wrong per se, except they compile for source for no particular reason
01:36:49 <quchen> curl -sSL https://get.haskellstack.org/ | sh
01:36:50 <quchen> Done
01:37:00 * merijn smacks quchen 
01:37:02 <quchen> inb4 oh noes pipe to shell
01:37:03 <fvgs> I have looked into stack. I was asking about stack vs cabal, etc. here yesterday
01:37:09 <merijn> Don't teach people to pipe to shell >.<
01:37:10 <quchen> fvgs: I remember.
01:37:12 <chichou> oh yeah it took a while to install I reckon
01:37:43 <merijn> chichou: So if you've already got it setup. Leave it, but I wouldn't recommend wasting a few hours compiling if you don't have it yet :)
01:38:05 <makalu> cocreature: yeah jaspervdj says in a reddit comment that websockets should be used with warp. I'll have to find out how. Thanks.
01:38:07 <chichou> merijn: thanks :)
01:38:14 <quchen> fvgs: If piping to shell isn’t your cup of tea then there are also manual download links, https://docs.haskellstack.org/en/stable/install_and_upgrade/#linux
01:38:21 <cocreature> makalu: there is a websockets-wai package or something like that
01:38:50 <quchen> fvgs: Once you have stack in your $path your problems are probably all gone. Stuff is loaded automatically into the right places (inside ~/.stack) and all that.
01:38:50 <makalu> cocreature: nice thanks!
01:38:52 <merijn> fvgs: Opinions are divided. Some people claim stack is the messiah solving all your dependency problems. Others (i.e. me) don't really seem to run into too many issues with cabal and, since I already know cabal, I'm too lazy and curmudgeony to invest time into figuring out stack :p
01:38:56 <quchen> No fiddling with libs and so on.
01:39:10 <merijn> Also, stack seems to involve way too much typing of "stack <command>"
01:39:29 <quchen> Cabal seems to involve way too much typing of »cabal <command>«
01:39:39 <quchen> GHC seems to involve way too much typing of »ghc <command>«
01:39:45 <mniip> vaibhavsagar, I don't think so?
01:40:09 <fvgs> I was semi sold on stack yesterday, but after reading through many of the features in the docs I feel like maybe it tries to do too much
01:40:19 <quchen> When I tell Stack to profile, it profiles.
01:40:26 <fvgs> And cabal seemed like more my cup of tea
01:40:41 <quchen> When I tell Cabal to profile, it tells me the libs aren’t there and I should rebuild with profiling, which I then have to figure out how to do.
01:40:59 <merijn> quchen: Not if you just update your .cabal/config once and be done with it :p
01:41:02 <vaibhavsagar> mniip: is that the lambdabot Prelude equivalent?
01:41:09 <mniip> it is
01:41:28 <mniip> it is used to initialize L.hs
01:41:41 <mniip> which is appended with whatever people give to @let
01:41:42 <vaibhavsagar> I thought it might be a parody of the average Haskell source file
01:41:56 <fvgs> any experience with installing stack via homebrew?
01:42:17 <fvgs> it claims ghc and cabal-install as build dependencies
01:42:20 <vaibhavsagar> 1 page of language extensions, 2 pages of imports, 3 one liner function definitions
01:42:36 <merijn> fvgs: FWIW, if you like having a more minimalist setup with cabal it works just fine for me and many others :)
01:42:40 <Axman6> I think installinmg stack via homebrew is the recommended method
01:42:58 <vaibhavsagar> I don't know the fact that it's legitimate makes me happy or sad
01:43:06 <Axman6> that might not be true any more though
01:43:53 <vaibhavsagar> homebrew seems to have the latest version of stack fwiw: https://github.com/Homebrew/homebrew-core/blob/master/Formula/haskell-stack.rb
01:43:54 <fvgs> the things is I also value reasonable package management. which is why my preference would have been to install ghc and cabal via homebrew
01:44:01 <fvgs> but the installing ghc part is insane
01:44:06 <mniip> vaibhavsagar, 2 pages of imports, but count how many pages of code have people evaluated in here
01:44:31 <fvgs> so that just leaves installing the haskell platform cask or stack via homebrew
01:44:36 <vaibhavsagar> mniip: lambdabot is incredibly useful, no argument there
01:44:46 <vaibhavsagar> fvgs: have you looked into Nix?
01:44:50 <mniip> I count 31 kloc
01:45:06 <terrorjack> Is it possible to use template haskell to "summon" unexported data constructors so I can derive a Show instance for a type?
01:45:10 <MVQq> "<quchen> When I tell Cabal to profile, it tells me the libs aren’t there and I should rebuild with profiling, which I then have to figure out how to do." sounds like you might like new-build, e.g. cabal new-build --enable-profiling
01:45:17 <merijn> fvgs: Well, the nice part of the ecosystem is that GHC nicely separates it's package databases by version, so multiple versions never override each other. Cabal is backwards compatible, so newer cabal's work with older GHCs. So I just install multiple binary versions of GHC and switch by changing my path and it "just works" for me
01:45:23 <fvgs> vaibhavsagar: I have in the past, haven't tried it on macOS though
01:45:24 <Axman6> terrorjack: you may be able to do it with Generic I think
01:45:25 <mniip> 37 kloc with -beginners
01:45:35 <ertes> someone mentioned an apt source for debian (and potentially ubuntu) that provides up-to-date versions of GHC and cabal-install…  does anyone know which one it was?
01:45:49 <quchen> ertes: Probably hvr’s repo?
01:45:53 <merijn> ertes: hvr's ppa, but I dunno the URL
01:46:02 <ertes> thanks
01:46:03 <quchen> ertes: https://launchpad.net/~hvr/+archive/ubuntu/ghc
01:46:52 <fvgs> does stack's ghc lag behind the stable release?
01:47:13 <Axman6> no
01:47:14 <jle`> stack doesn't "have" a ghc
01:47:20 <Axman6> it just downloads the official binary
01:47:25 <merijn> fvgs: Not significantly, I think. More importantly, I would advise beginners to lag GHC stable releases :p
01:47:32 <quchen> Nightly builds are up-to-da(y|te), LTS releases are usually a couple of months behind.
01:47:40 <Axman6> it's alkready possible to use stack with GHC 8.2.1 RC
01:47:43 <merijn> fvgs: I generally recommend "current version - 1" of GHC for beginners
01:47:55 <fvgs> merijn: why?
01:48:09 <terrorjack> Axman6: but the type doesn't has Generic instance either, and without constructors in scope it can't be derived
01:48:10 <merijn> fvgs: Bleeding edge leads to lot of breakage, so older GHCs have better ecosystem support
01:48:12 <Axman6> merijn: except on macOS where you need 8.0.2 because Apple broke things
01:48:26 <jle`> stackage snapshots are associated with ghc's; the nightlies follow stable releases, and LTS lags behind a few months as mentioned
01:48:35 <jle`> but the stack tool itself doesn't endorse a particular ghc version
01:48:38 <Axman6> terrorjack: this sounds like you're trying to solve a problem you're not supposed to be able to solve ;)
01:48:38 <merijn> fvgs: Additionally, most new features in GHC are "advanced" features, which beginners aren't generally needing :)
01:48:43 <fvgs> merijn: But stable release by definition shouldn't be bleeding edge
01:48:52 <Axman6> if you "need" show, make a function Foo -> String
01:48:52 <cocreature> 8.0.2 can hardly be called bleeding edge at this point
01:49:03 <jle`> terrorjack: http://hackage.haskell.org/package/true-name
01:49:15 <merijn> fvgs: stable release is "stable", not containing to many bugs, it's NOT necessarily backwards compatible
01:49:36 <merijn> fvgs: Libraries might need to be patched/updated, which can take a few months after release
01:49:53 <merijn> cocreature: Sure, but we're nearing 8.2 release, so it's about time to switch to 8.0 as "current - 1" ;)
01:49:59 <cocreature> fair enough
01:50:17 <merijn> fvgs: I usually only upgrade GHC when 1) I need a new feature or 2) I run into a blocking bug
01:50:22 <jle`> by the time LTS adopts a ghc version, enough of the ecosystem has moved forward to make it a justifiable decision to move up i think at least
01:50:28 <cocreature> I tend to recommend to switch once .2 is out
01:50:42 <merijn> Axman6: What was broken on macOS? I was using 7.10.3 up until a month or so ago
01:51:09 <cocreature> merijn: are you as good at upgrading macOS as you are at upgrading ghc? :)
01:51:18 <merijn> cocreature: Yes, for much the same reason :p
01:51:23 <cocreature> iirc it was only a problem with newer versions
01:51:24 <merijn> Actually...
01:51:42 <merijn> I just remembered I didn't update macOS yet :p
01:52:02 <merijn> Still on Yosemite, rather than Sierra, since I like other to suffer the pain of bugfixing for me :p
01:52:31 <merijn> See! It's sound life advice!
01:52:37 <merijn> Always lag on non-security updates!
01:53:35 <fvgs> Can't argue with that. I updated from macOS 10.12.3 to 10.12.4 and it broke my monitor setup. Been complaining to Apple for weeks to get a fix...
01:54:22 <fvgs> what version of ghc does stack ghc run?
01:55:00 <fvgs> brew install ghc has been running for over an hour now while it compiles the source. So I'm getting ready to ctrl+c it and either install the platform or stack
01:55:04 <sophiag> shouldn't i be able to pattern match with exponentials on both sides using ViewPatterns and/or TypeApplications? i'm running into trouble here: http://lpaste.net/354750
01:56:41 <halogenandtoast> Does anyone know how to filter params in Yesod's logging. I'd like password not to show up. Currently looks like: `Params: [("_token","SyIeBitRXJ"),("email","halogenandtoast@gmail.com"),("password","password")]`
01:57:14 <mauke> sophiag: you can't deconstruct functions
01:58:05 <jle`> sophiag: do you think that '->' is a constructor?
01:58:14 <jle`> oh, it's VIewPatterns
01:58:25 <mauke> not really
01:58:35 <jle`> er
01:58:50 <sophiag> mauke: what would you recommend then if i need to somehow convert between those function types? the former results from parsing ASTs and the latter is necessary to actually apply them :/
01:59:35 <jle`> what do you want to write?
01:59:39 <mauke> sophiag: depends on what you want it to actually do
02:00:21 <jle`> what does the final Bool return?
02:00:25 <sophiag> it's exactly like i said...i'm parsing lambdas from ASTs into the first exponential in that signature, but they're all really of the second 
02:00:32 <sophiag> True or False
02:00:38 <sophiag> but that's not known until application
02:00:42 <jle`> how does it decide whether to return True or False?
02:01:02 <mauke> fromJustAmbVal _ = \_ -> False
02:01:04 <sophiag> in this case they're meant to be the predicate in filter
02:01:16 <mauke> there we go, that fits your type
02:01:19 <jle`> yes, but where does the Bool come from
02:01:31 <halogenandtoast> mauke: why not just const False ?
02:01:34 <sophiag> the bool is wrapped up in AmbVal
02:01:46 <sophiag> and i don't see how having it always return False helps?
02:01:50 <jle`> then we need to know the definition of AmbVal
02:02:04 <jle`> mauke's point was that there really isn't any way we can know what BOol to return, from the information you've given us
02:02:09 <jle`> so returning False is just as good as any other guess
02:02:09 <halogenandtoast> sophiag: it doesn't, but it fits the amount of information we have.
02:02:09 <mauke> sophiag: it doesn't, but you're not telling us what you want it to do, just the type
02:02:22 <mauke> sophiag: so I gave you something matching that type
02:02:32 <jle`> "i want a function Foo -> Bool, but i won't describe what the function actually does.  how do i write it?" :)
02:02:46 <sophiag> well, it would return true of false when applied as a predicate
02:02:59 <mauke> my function does that
02:03:00 <jle`> mauke's answer also does that
02:03:19 <halogenandtoast> Basically we need to know WHY it would return True or False
02:03:22 <sophiag> doesn't it always return False no matter what? i seem to be confused about this
02:03:32 <jle`> yes, when used as a predicate, it returns False
02:03:43 <jle`> but that's literally as good as any answer we can give you, unless you give us more information
02:03:43 <mauke> sophiag: what's the problem with that? your only requirements are that it should return True or False, which it does
02:03:49 <jle`> do you see the issue?
02:03:51 <sophiag> even if the data satisfies the predicate then it returns false?
02:03:57 <mauke> sophiag: what predicate?
02:04:08 <sophiag> anyway, this is updated with the type of AmbVal: http://lpaste.net/354750
02:04:13 <jle`> what if someone came up to you and said, "i need to write an Int -> Int.  it has to return an Int when applied."
02:04:23 <jle`> there really isn't any way you can meaningfully help them
02:04:38 <jle`> what predicate are you talking about?
02:05:07 <sophiag> (filter (\x -> x /= 0) [0,2,0,43,0,5]) /= (filter False [0,2,0,43,0,5])
02:05:35 <halogenandtoast> sophiag: that's an error
02:05:44 <halogenandtoast> I assume you mean const False or (\_ -> False)
02:05:48 <halogenandtoast> but sure
02:05:59 <jle`> yes, they're different, but you haven't given us any reason to prefer one over the other
02:06:02 <sophiag> halogenandtoast: i don't understand anything about that
02:06:03 <halogenandtoast> this doesn't tell us WHY yet
02:06:04 <mauke> sophiag: what's the problem with that?
02:06:20 <sophiag> mauke: it doesn't actually filter out the zeros?
02:06:21 <jle`> sophiag: what 'predicate' are you talking about?
02:06:30 <mauke> sophiag: you never said anything about filtering zeroes
02:06:31 <jle`> sophiag: can you give us sample inputs and ouputs you want to have?
02:06:35 <sophiag> filter <predicate> <list>
02:06:49 <sophiag> jle`: i just gave one. how many would you like?
02:06:57 <jle`> i mean, for fromJustAmbVal
02:06:59 <mauke> sophiag: that doesn't use AmbVal
02:07:04 <jle`> what are some sample inputs to fromJustAmbVal
02:07:07 <jle`> and some sample outputs
02:07:08 <halogenandtoast> jle`: I assume (\x -> x /= 0) is not an AmbVal
02:07:09 <sophiag> i updated the paste, as asked
02:07:15 <sophiag> i gave an example, as asked
02:07:24 <halogenandtoast> Not sure why I said jle` sorry
02:07:24 <jle`> can you give us an example usage of fromJustAmbVal
02:07:27 <halogenandtoast> sophiag: ^^
02:07:40 <jle`> fromJustAmbVal (????) = ????
02:07:41 <mauke> sophiag: you gave us an example of code that has nothing to do with AmbVal
02:08:04 <jle`> because we really aren't sure what fromJustAmbVal is supposed to return
02:08:08 <jle`> other than "a Bool"
02:08:13 <halogenandtoast> sophiag: Just for clarification, we're not being jerks, we literally don't know what you're trying to get at yet.
02:08:16 <sophiag> fromJustAmbVal $ Maybe (\x -> Just (x /= 0))
02:08:36 <sophiag> oops, i meant: fromJustAmbVal $ Just (\x -> Just (x /= 0))
02:08:37 <jle`> do you mean Just (\x -> Just (x /= 0)) ?
02:08:38 <halogenandtoast> sophiag: Maybe (\x -> Just (x /= 0)) is not an AmbVal
02:08:50 <jle`> sophiag: that doesn't match the type you gave us
02:09:02 <sophiag> how so?
02:09:06 <jle`> Just (\x -> Just (x /= 0)) :: Maybe (Int -> Maybe Bool)
02:09:31 <jle`> but, as you have given us fromJustAmbVal, it expects Maybe (AmbVal -> Maybe AmbVal)
02:10:20 <sophiag> fromJustAmbVal $ Just (AmbVal x -> Just BoolVal (x /= 0))
02:10:30 <mauke> that's a syntax error
02:10:31 <jle`> that isn't a valid haskell function
02:10:33 <sophiag> err wait
02:10:40 <sophiag> fromJustAmbVal $ Just (CharVal x -> Just BoolVal (x /= 0))
02:10:45 <mjora7> I compiled a Hello world program and it's a whopping 1.7mb's. That's crazy! How is that even possible?
02:10:47 <mauke> that's a syntax error
02:10:47 <jle`> that is also not a valid haskell function
02:11:07 <jle`> mjora7: most of it is the runtime system
02:11:09 <halogenandtoast> mjora7: stop caring, move on with life.
02:11:15 <merijn> mjora7: Because now effort is taken to link a "minimal subset" of the runtime system
02:11:16 <mauke> after that, it's a type error
02:11:26 <jle`> mjora7: but, try printing hello world twice
02:11:33 <jle`> you'll see that the result isn't 3.4 mb :)
02:11:40 <mauke> merijn: s/now/no/
02:11:49 <merijn> mauke: Typing is hard!
02:11:49 <mjora7> Ok I see, so there shouldn't be a much of a difference past that initial runtime system.
02:12:05 <mutsig_> :r
02:12:07 <mutsig_> oops
02:12:26 <sophiag> i was just asking about pattern matching for functions, but would you guys like to see the entire code or more examples or what?
02:12:40 <jle`> sophiag: you can't pattern match on functions
02:12:48 <mauke> sophiag: no, we want to understand what the hell you want this function to do
02:12:54 <jle`> but, if you want us to help you write fromJustAmbVal, you have to explain to us what it does
02:13:02 <sophiag> i did
02:13:05 <mauke> no, you didn't
02:13:07 <sophiag> i gave several examples
02:13:10 <merijn> mjora7: Right. Also, by default GHC simply statically links all haskell libraries into your program, there's some stuff you can use to reduce the "bloat" that introduces, but honestly, it's not that worth it, imo
02:13:10 <mauke> no, you didn't
02:13:13 <jle`> you didn't give any examples that worked
02:13:16 <merijn> mjora7: Since disk space is pretty cheap
02:13:16 <jle`> every example you gave was a syntax error
02:13:21 <jle`> and also a type error
02:13:28 <sophiag> how so? you saw the adt
02:13:32 <mauke> you didn't give a single example of fromJustAmbVal
02:13:36 <sophiag> i did above
02:13:37 <jle`> the ADT we understand
02:13:42 <jle`> fromJustAmbVal is what we don't understand
02:13:46 <jle`> you did not give any working examples
02:13:54 <mjora7> merijn: Yeah I don't really care about the size, I was just curious as to why it was so big, but I guess I'm comparing it to the Hello, world! C binary equivalent, which isn't fair at all.
02:13:59 <sophiag> <sophiag> fromJustAmbVal $ Just (CharVal x -> Just BoolVal (x /= 0))
02:14:02 <mauke> the one thing involving fromJustAmbVal you posted was 1) a syntax error 2) didn't include the expected result
02:14:07 <mauke> sophiag: SYNTAX ERROR
02:14:08 <jle`> sophiag: that isn't valid haskell
02:14:15 <jle`> we don't even know how to interpret that
02:14:15 <halogenandtoast> mjora7: yeah not really fair.
02:14:34 <jle`> mjora7: for what it's worth, C has a runtime overhead as well, it's just smaller than ghc haskell's :)
02:14:35 <mauke> sophiag: even if it wasn't 2 syntax errors and 2 type errors, it's still not a complete example because it doesn't include the result
02:14:40 <merijn> mjora7: The runtime system has GC, threading (depending on the version), semi-preemptive scheduling, etc.
02:14:51 <jle`> sophiag: we're trying to help you, but you haven't given us a single working example :(
02:14:58 <mauke> sophiag: without the expected result we still don't know what you want this expression to do
02:15:03 <jle`> the fact that we're still talking to you know shows that we are trying to help
02:15:16 <sophiag> it unwraps Maybe and AmbVals
02:15:30 <jle`> that isn't descriptive enough for us to know what you want
02:15:37 <jle`> you have to give us an example usage of fromJustAmbVal
02:15:40 <jle`> one that actually is valid haskell
02:15:48 <jle`> a sample input, and a sample output
02:16:04 <jle`> do you see why the example you gave isn't valid haskell?
02:16:12 <halogenandtoast> sophiag: keep in mind Just (CharVal x -> Just BoolVal (x /= 0)) is not valid Haskell
02:16:41 <sophiag> hard to keep in my mind when it's repeated by three different people several times each
02:16:51 <jle`> we don't even know how to begin interpreting (CharVal x -> Just BoolVal (x /= 0))
02:16:52 <halogenandtoast> That sounds like the opposite.
02:17:36 <jle`> okay, i'll provide an input that is valid haskell, and can you tell me what you expect it to return?
02:17:44 <halogenandtoast> sophiag: please don't get angry, we're doing our best to help you with the information we have.
02:18:04 <sophiag> halogenandtoast: i just told you the best way you can help is not repeating something that's already been said
02:18:07 <jle`> what should `fromJustAmbVal (\_ -> Just (FloatVal 3.9))`
02:18:12 <jle`> return
02:18:38 <jle`> er, fromJustAmbVal (Just (\_ -> Just (FloatVal 3.9)))
02:18:54 <jle`> should it return \_ -> True ?
02:18:59 <sophiag> (\_ -> 3.9)
02:19:04 <jle`> that doesn't typecheck
02:19:07 <jle`> the result has to be Bool
02:19:09 <mauke> 3.9 isn't a Bool
02:19:19 <sophiag> right. i would never have that input
02:19:23 <jle`> okay
02:19:26 <jle`> so what input would you have?
02:19:27 <sophiag> it should actually return undefined for htat
02:19:53 <jle`> how about fromJustAmbVal (Just (\_ -> Just (BoolVal False))) ?
02:20:14 <sophiag> that would work, but it's not a likely input
02:20:21 <jle`> what is it supposed to return?
02:20:29 <jle`> we're trying to find the pattern
02:20:41 <sophiag> (_ -> False)
02:20:41 <mauke> sophiag: fromJustAmbVal (Just f) = \x -> case f x of Just (BoolVal b) -> b
02:20:49 <jle`> do you mean (\_ -> False) ?
02:20:50 <mauke> I think that's the complete definition you have in mind
02:21:00 <jle`> (_ -> False) isn't valid haskell
02:21:17 <jle`> sophiag: how about fromJustAmbVal (Just (\_ -> Nothing)) ?
02:21:50 <sophiag> i could type a response if i could type that fast
02:22:14 <jle`> no need to rush.  any time is better than never :)
02:22:51 <mauke> well, I think I've solved it :-)
02:22:58 <Iceland_jack> Time flies like an arrow.. fruit flies like a banana
02:23:08 <sophiag> look at that i was about to clarify
02:23:19 <sophiag> mauke: i'll wait until you're done tho
02:23:30 <mauke> what do you mean, done?
02:23:32 <mauke> I am done
02:23:40 <sophiag> ok
02:23:55 <mauke> I already gave you the code I think you're looking for
02:24:01 <mauke> it's just a single line
02:24:24 <sophiag> mauke: i'm trying to respond to jle` asking me to clarify what i'm looking for here but i can't because of your badgering
02:24:36 <mauke> wtf
02:24:40 <sophiag> again, i'll wait a good long time until you're done
02:24:42 <mivael> tsahyt, "It does that by storing a Map of values that all have the same hash" -- I don't think so.  Now I think that HashMap (the one from the hashmap package) internally maps keys not just to correspondent values but to combined values (the key itself and the correspondent value).  Only to one such combined values, not to many.
02:24:47 <mauke> ok, good luck
02:25:02 <jle`> >_>
02:25:12 <mauke> but IRC is an asynchronous communication medium with multiple senders/receivers
02:25:15 <sophiag> i agree it is hard to sovle a problem when you can't get information from the person asking because you constantly interrupt them
02:25:36 <jle`> you aren't required to respond to every message being sent :)
02:25:41 <mauke> you'll never get anywhere if you wait for the channel to be silent for N minutes while typing your response
02:26:16 <sophiag> no, i just see new things directed at me from the people who already asked me to answer something
02:26:26 <halogenandtoast> This is heading dangerously close to help vampire territory.
02:26:37 <mauke> I thought you were waiting for me to stop talking?
02:26:47 <sophiag> i still am
02:27:01 <mauke> AFAICS I didn't ask you anything (apart from the initial requests for something resembling a spec)
02:27:29 <sophiag> btw just ignored the person who referred to me as a "vampire"
02:27:33 <sophiag> that was a nice touch
02:27:42 <mauke> not "vampire". "help vampire"
02:28:24 <halogenandtoast> I like the announcement though.
02:28:27 <sophiag> does that make the person saying it not a "jerk" but a "help jerk?"
02:28:59 <mauke> eh?
02:29:05 <jle`> 'help vampire' referes to a specific term
02:29:12 <mauke> this one: http://www.skidmore.edu/~pdwyer/e/eoc/help_vampire.htm
02:29:23 <jle`> which means something altogether different than just a variation of 'vampire'
02:29:24 <halogenandtoast> I'm curious to find out what they think I meant?
02:30:33 <sophiag> i asked one question once so i don't see how i fit that definition
02:30:56 <sophiag> i do understand irc attracts an extremely high number of people suffering from autism tho
02:31:17 <sophiag> i can understand how verbal interaction would be difficult for them
02:31:20 <jle`> pretty sure that's uncalled for
02:31:23 <Iceland_jack> Doesn't sounds like you're acting in good faith now sophiag
02:31:39 <sophiag> um, i'm responding to being insulted for trying to ask a question
02:31:57 <Iceland_jack> You can do it without negatively calling people autistic
02:32:04 <sophiag> i literally asked one question once and then have only aswered other people since
02:32:10 * Iceland_jack shrug
02:32:20 <mjora7> sophiag: It's normal for IRC, just ignore the rude people.
02:32:51 <sophiag> mjora7: thank you. i suppose i should put the lot of them on ignore
02:32:54 <halogenandtoast> For the record, I wasn't saying he was a help vampire, just that the behavior exhibited was approaching that, but now it's too late, it is full blown help vampire territory.
02:33:09 <sophiag> so the two who justify insulting people as well
02:33:19 <sophiag> done
02:37:28 <mauke> mjora7: who do you think was rude here?
02:38:50 <mauke> for the record, I don't think sophiag's behavior fits the checklist in that article
02:40:10 <halogenandtoast> mauke: that's fair.
02:41:36 <halogenandtoast> mauke: I didn't cite that checklist so I wasn't using it as my metric, but I think it's fine to let this issue drop.
02:42:10 <mauke> yeah
02:42:42 <halogenandtoast> if I was the rude one then so be it. It wasn't my intent and I am unable to apologize for making someone feel attacked, so there's little to be done
02:42:50 <halogenandtoast> 仕方が無い
02:43:19 <Iceland_jack> ¯\_(ツ)_/¯ 仕方が無い
02:43:27 <halogenandtoast> Iceland_jack: exactly
02:43:37 <cloudhead> hey, is it possible to get some kind of stack trace out of tasty-hunit? Or some kind of indication on what line threw an exception?
02:44:52 <mauke> ゆっくりしていってね
02:47:51 <merijn> cloudhead: I believe you can get stack traces using HasCallstack nowadays, but I don't know how it works :p
02:47:53 <Iceland_jack> Anyone hiring in Japan? lol
02:48:01 <merijn> cloudhead: I'd recommend consulting the GHC manual
02:49:15 <cloudhead> merijn: thanks will have a look
02:49:55 <halogenandtoast> Iceland_jack: depends on how much you want to make
02:50:10 <halogenandtoast> I've been eyeballing Arrow, but I couldn't leave my current job :\
02:50:23 <halogenandtoast> I am however trying to force my company to do Haskell
02:50:27 <halogenandtoast> It's my two year plan
02:50:31 <merijn> cloudhead: Googling for HasCallstack will probably also turn up some useful stuff :)
02:50:45 <merijn> Iceland_jack: Closest I know is Singapore ;)
02:51:03 <Iceland_jack> merijn: I would melt :)
02:51:10 <halogenandtoast> I hear Singapore is always hiring.
02:51:24 <Iceland_jack> I recently relocated to London so it was tongue-in-cheek
02:51:26 <halogenandtoast> Iceland_jack: for your reference: https://arow.info/index-en.html
02:51:27 <Iceland_jack> but one day
02:51:34 <Iceland_jack> Thank you halogenandtoast
02:51:57 <halogenandtoast> Iceland_jack: no problem, I love it here, we need more Haskellers.
02:52:15 <merijn> halogenandtoast: They are :p
02:52:28 <halogenandtoast> They are what?
02:52:35 <halogenandtoast> Oh
02:52:37 <merijn> halogenandtoast: Always hiring
02:52:37 <halogenandtoast> Singapore
02:52:37 <halogenandtoast> yeah
02:53:08 <vaibhavsagar> merijn: are you in Singapore? I just moved here
02:53:27 <merijn> vaibhavsagar: No, not even close :p
02:54:11 <halogenandtoast> I'll probably visit Singapore next year.
02:54:21 <vaibhavsagar> I'd heard that there were a lot of Haskellers at my company but it turns out they all left a few months ago :(
02:54:36 <halogenandtoast> vaibhavsagar: that sucks
02:54:39 <vaibhavsagar> pretty disappointed to find that out on my first day, but at least they didn't lead me on :)
02:54:42 <halogenandtoast> They all leave together?
02:54:45 <Iceland_jack> vaibhavsagar: Make new ones
02:55:09 <cocreature> vaibhavsagar: which company are you working at?
02:55:24 <merijn> vaibhavsagar: If you wanna do Haskell in Singapore, Standard Chartered is always hiring there :p
02:55:59 <vaibhavsagar> I did apply to SC a while ago
02:58:29 <Iceland_jack> halogenandtoast: I don't know how competitive Japan salaries are, how are they with work visas do you know?
02:58:57 <halogenandtoast> Iceland_jack: are you asking about Arow or companies in general?
02:59:12 <Iceland_jack> If you know about Arrow, otherwise in general
02:59:20 <Iceland_jack> if companies help with relocation and such
03:00:40 <halogenandtoast> Iceland_jack: most companies I've talked to here (non-Haskell) have offered some amount for relocation, and have been able to provide work visas.
03:00:51 <halogenandtoast> The work visa situation for IT here is pretty good.
03:01:15 <Iceland_jack> That's good
03:01:21 <halogenandtoast> I don't know specifically about Arow, I moved here under very "different" circumstances
03:02:09 <halogenandtoast> If you happen to be top notch with Ruby on Rails, I know my company would pay for relocation and would get you a visa, but it's not Haskell YET
03:02:29 <Iceland_jack> What is the opposite of "top notch"? :)
03:02:34 <Iceland_jack> that's me with RoR
03:02:58 <halogenandtoast> Iceland_jack: happens to the best of us.
03:03:17 <halogenandtoast> I'm pretty bottom notch with Haskell
03:03:48 <Iceland_jack> I don't even know what a notch is..
03:04:08 <mauke> the author of minecraft
03:04:45 <halogenandtoast> Iceland_jack: notches are indentations used sometimes for measurement, being top notch means the highest value of whatever you're measuring.
03:05:05 <Iceland_jack> cool!
03:05:07 <MarcelineVQ> alternatively a notch is a setting on as machine
03:05:09 <MarcelineVQ> *on a
03:05:16 <MarcelineVQ> you're top machine setting!
03:05:27 <Iceland_jack> :D
03:05:30 <Iceland_jack> joy
03:05:30 <halogenandtoast> Or a deep, narrow mountain pass.
03:05:42 <MarcelineVQ> you're top deep, narrow mount pass!
03:05:59 <halogenandtoast> I've been waiting for this moment.
03:06:03 <Iceland_jack> I've been called worse
03:06:12 <MarcelineVQ> belts also have notches
03:06:36 <Iceland_jack> What a versatile word
03:06:45 <Iceland_jack> top notch
03:07:40 <halogenandtoast> Iceland_jack: I've been called worse too, pretty sure I was called autistic today :\
03:07:54 <halogenandtoast> as a negative.
03:08:20 <halogenandtoast> Being a mountain pass as a negative would be interesting.
03:08:22 <MarcelineVQ> I got banned once for saying autisic in a positive way, though not here
03:08:49 <Iceland_jack> I can't think of a single bad about mountain passes
03:08:53 <Iceland_jack> they help people pass
03:09:14 <MarcelineVQ> the two bad things are gettin stuck in one due to weather and robbers living in them
03:10:33 <Iceland_jack> maintain pass robbers *shakes fist*
03:10:38 <halogenandtoast> Returning to my question from long ago
03:10:48 <halogenandtoast> Anyone know how to filter post params from Yesod logs?
03:11:07 <halogenandtoast> *specific* post params like "password"
03:17:12 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | https://summer.haskell.org Summer of Haskell 2017'
03:17:12 --- topic: set by geekosaur!allbery@dreamshell.ttuttle.net on [Wed Apr 05 12:49:54 2017]
03:18:07 <maaarcocr_> Hi! I'm trying to run in interpreted mode some haskell with runHaskell. My main problem is that it seems like it's not able to load local modules. The funny thing is that the same command works on Windows but not on Linux.
03:20:23 <halogenandtoast> maaarcocr_: Did you try -i to specify an include dir?
03:22:59 <maaarcocr_> runghc -i~/test main.hs something like this?
03:23:17 <AfC> Without the ~
03:23:21 <AfC> ie ./
03:24:24 <maaarcocr_> neither of them works
03:24:32 <maaarcocr_> it's really weird :/ 
03:24:51 <halogenandtoast> Can you make a paste of your directory structure, the error, and the command?
03:25:13 <maaarcocr_> ok (i'm using stack, I hope it's not a problem)
03:25:19 <halogenandtoast> not for me.
03:26:34 <maaarcocr_> . ├── checking.hs ├── professor.hs └── student.hs
03:26:53 <maaarcocr_> ops sorry, anyway the directory structure is very simple, just 3 files in the same dir
03:28:21 <halogenandtoast> maaarcocr_: okay, can you use http://lpaste.net/new/haskell to paste the command and error.
03:28:32 <halogenandtoast> or other pastebin of your choice.
03:30:03 <maaarcocr_> https://pastebin.com/Y8727rnk
03:31:39 <Cale> maaarcocr_: It looks for modules in files having the same name. At the very least, professor.hs should probably be Professor.hs
03:31:39 <maaarcocr_> Oh, I solved it! Thanks anyway for being so prompt in helping me :) (the problem was the filename)
03:31:47 <halogenandtoast> I don't know if this would be related, but are you on a case sensitive file system?
03:32:20 <halogenandtoast> Okay, glad you solved it.
03:32:30 <halogenandtoast> Seems it was related.
04:55:37 <abhiroop> Is there any way to interoperate between the Text in this module https://hackage.haskell.org/package/text-0.11.2.3/docs/Data-Text-Lazy-Internal.html#t:Text
04:56:08 <abhiroop> And the Text in Data.Text module https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text.html#t:Text
04:56:36 <abhiroop> actually I am formatting a string using text-format. I want to write that string to a file
04:57:36 <pavonia> Are you trying to use two different versions of the same package in one project?
04:58:57 <pacak> abhiroop: toStrict/fromStrict
04:58:57 <Cale> If not, then the answer is Data.Text.Lazy.fromChunks
04:59:23 <pacak> and toChunks/fromChunks
04:59:42 <pacak> pavonia: Sounds like bad idea.
04:59:51 <Cale> Or yeah, indeed, toStrict/fromStrict
05:09:31 <__Myst__> Hi, can I ask for a code review?
05:09:52 <__Myst__> If so, I was wondering if there was anything non-idiomatic or generally wrong/bad witih this code http://termbin.com/0wws
05:12:02 <ggVGc> I want to consume a few endpoints of a rest api that returns JSON blobs. What's my best/quickest bet_
05:12:05 <ggVGc> ?
05:12:11 <ggVGc> I don't need to do any posts or puts atm
05:12:14 <ggVGc> just retrieving data
05:13:48 <kuribas> __Myst__: my preference is to avoid long lines.
05:14:01 <abhiroop> Cale: I am dealing with Data.Text.Internal.Lazy not Data.Text.Lazy
05:14:03 <__Myst__> kuribas: L27?
05:14:14 <liste> ggVGc: wreq
05:14:16 <abhiroop> Have a look at the format function here: https://hackage.haskell.org/package/text-format-0.3.1.1/docs/Data-Text-Format.html
05:14:27 <abhiroop> The Text that it returns
05:14:27 <liste> @hackage wreq -- ggVGc 
05:14:27 <lambdabot> http://hackage.haskell.org/package/wreq -- ggVGc
05:14:28 <kuribas> __Myst__: "let [nick, cs'] = splitOn ..."
05:14:42 <Cale> abhiroop: The type which is defined there is re-exported by Data.Text.Lazy
05:15:35 <ggVGc> liste: yeah, I was looking at that. But I also think Servant might be interesting? https://haskell-servant.github.io/client-in-5-minutes.html
05:15:48 <liste> ggVGc: servant's mostly for serving, not consuming
05:16:10 <liste> ggVGc: the client library is best when coupled with a servant server
05:17:38 <liste> ggVGc: wreq's tuned for consuming json blobs in an ad-hoc manner
05:20:38 <ggVGc> alright
05:20:44 <ggVGc> have you used wreq?
05:21:17 <liste> ggVGc: yes, a bit
05:21:59 <liste> see the tutorial: http://www.serpentine.com/wreq/
05:23:32 <Axman6> ggVGc: servant-client is quite a nice way to get the client functions 'for free', you just model the API of the service and it takes care of much of the rest of it
05:26:27 <__Myst__> kuribas: how could i split that up?
05:26:39 <kuribas> __Myst__: with layout
05:27:00 <__Myst__> layout?
05:27:06 <__Myst__> maybe like this? http://termbin.com/ea3e
05:28:01 <kuribas> __Myst__: that looks better
05:33:56 <__Myst__> kuribas: anything else?
05:34:56 <kuribas> __Myst__: undefined means not yet implemented?
05:49:03 <__Myst__> kuribas: means that it's wrong input
05:49:29 <kuribas> __Myst__: better use error then
05:50:05 <__Myst__> why?
05:50:12 <kuribas> __Myst__: better error messages
05:51:05 <__Myst__> error "{functionName}: {reasonForInvalidInput}!"?
05:51:41 <kuribas> yes
05:52:16 <abhiroop> Thanks Cale
05:52:20 <kuribas> __Myst__: if that is reachable, you'ld probably need something better.
05:52:58 <kuribas> __Myst__: Using an exception, or returning Either.
05:59:00 <c_wraith> in general, the rule of thumb between the cases is to use error if some invalid input represents programmer error, and something like Maybe/Either if it's bad input the programmer can't reasonably prevent
06:00:37 <Kototama> does it make sense to use free monads to operate on an ADT, even if the ADT does not represent operations but data? to gain the flexibility of interpreting the data in different way?
06:00:56 <merijn> Kototama: "Yes, No, Maybe, It Depends" ;)
06:01:16 <merijn> Kototama: You'll get better answers if you can give some more detailed examples of what you're doing
06:02:33 <Kototama> i need to transform a tree-like ADT into another datastructure
06:02:59 <Kototama> and i need to map values from an external service back to this tree-like ADT
06:03:23 <c_wraith> What the free monad does is very constrained.  If it works, it makes sense. :)
06:03:35 <Kototama> :)
06:04:29 <Kototama> just all example online are for encoding a DSL
06:04:32 <nshepperd> sounds like maybe recursion-schemes would be of interest
06:04:42 <Kototama> whereas my ADT is just data
06:05:26 <nshepperd> if you define a treelike data type as a fixpoint of a functor, you get various foomorphisms for free
06:07:01 * pacak loves  the smell of foomorfisms in the morning
06:07:03 <Kototama> i don't know how to do that, do you have articles / blogs?
06:07:06 <merijn> nshepperd: Honestly, every time I look at recursion-schemes I mostly just get confused and decide to write the "foomorphisms" myself by hand :p
06:07:22 <Kototama> pacak foodmorphism?
06:08:34 <pacak> merijn: recursion-schemes is not that bad and it helps if you have a tree-like structure and still want to use foomorfisms.
06:09:14 <fendor> is there an irc channel for stack?
06:10:12 <pacak> merijn: https://medium.com/@jaredtobin/practical-recursion-schemes-c10648ec1c29
06:10:16 <pacak> have you seen this?
06:10:33 <nshepperd> Kototama: I'm not sure what is the best introduction
06:10:58 <nshepperd> maybe the one pacak linked
06:11:01 <kuribas> __Myst__: I use undefined only for "I'll fill this expression in later", even then some people prefer error.
06:11:36 <nshepperd> the short version is, instead of 'data Tree a = Leaf a | Node (Tree a) (Tree a)' and manual recursion, you write 'data TreeF a r = Leaf a | Node r r; type Tree a = Fix (TreeF a)'
06:11:51 <pacak> Kototama: http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf - or this
06:12:05 <pacak> Kototama: Your  brain will hurt at the beginning, but you'll get used to it.
06:12:16 <Kototama> my tree is not recursive like that, each layer has different type
06:12:22 <nshepperd> and the you get the function 'cata :: (TreeF a b -> b) -> Tree a -> b' for free
06:12:33 <nshepperd> which is like foldr for trees
06:13:54 <nshepperd> well, this can work for any recursive ADT
06:14:09 <nshepperd> unless it's irregular recursion. then, uh
06:14:27 <merijn> pacak: Yeah, I *understand* them, I just don't find them easy to use :)
06:14:34 <Kototama> i don't have the same ADT at the first and at the second level
06:14:57 <merijn> kuribas: Don't use undefined for "I'll fill this in later", use typed holes!
06:15:18 <merijn> kuribas: Much more robust/less likely to escape unnoticed
06:17:11 <pacak> merijn: They are nice if you want to transform AST - normalize expression, partially evaluate, simplify and so on.
06:18:13 <kuribas> merijn: then you cannot run the rest of the program?
06:18:25 <merijn> kuribas: You can, I fixed that several versions of GHC ago :)
06:18:34 <kuribas> merijn: oh great :)
06:18:40 <merijn> kuribas: -fdefer-typed-holes turns typed holes into runtime errors
06:18:51 <kuribas> right
06:18:57 <merijn> Similar to -fdefer-type-errors, but working on holes only :)
06:19:12 <kuribas> __Myst__: so what merijn and c_wraith said... 
06:19:26 <merijn> In which case they're identical to undefined, except with neat compiler warnings about their presence ;)
06:19:31 <ph88_> i have a math formula with small n and big N is there a convention for naming haskell variables of things which are usually put as capital ?
06:21:26 <nshepperd> Kototama: I guess the answer to that depends on your exact situation
06:21:28 <merijn> ph88_: Not really, tbh
06:21:34 <ph88_> oki
06:23:20 <pacak> > let ɴ = 3 ; n = 4 in ɴ * n
06:23:21 <nshepperd> Kototama: for me it feels like recursion-schemes is sort of the equivalent of free monads for data, though, which is why i bring it up. I think it's useful to know about anyway :)
06:23:22 <lambdabot>  12
06:23:58 <pacak> ph88_: You can use small n and big N as variables as long as they both are small.
06:24:08 <Kototama> nshepperd: thank you :) it may be a bit too complex for me now
06:24:16 <__Myst__> Why would I use Fix over regular recursion?
06:24:39 <Kototama> i have somecode here http://paste2.org/U2pLwYBN (in PureScript)
06:24:41 <ph88_> pacak, haha that first n looks big, but is still small :P
06:25:04 <ph88_> i'll take it
06:30:23 <ph88_> since both indexing and safe-indexing are O(1) why would you wanna use (unsafe?) indexing ?  https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector-Unboxed.html#g:4
06:30:37 <nshepperd> Kototama: oh, I see, it's not recursive at all. I suppose recursion-schemes won't really help here then
06:30:38 <pacak> ph88_: range checking
06:31:15 <ph88_> you wanna use unsafe indexing for range checking ?
06:31:34 <nshepperd> avoiding range checking gets the maximum performance, I assume
06:31:48 <pacak> save indexing will give friendly error message when index is out of bounds. unsafe will explode, burn your house and eat your cat.
06:31:55 <pacak> But unsafe is faster.
06:31:56 <merijn> ph88_: O(1) says the operation is constant time, it doesn't say anything about the size of the constant
06:32:04 <ph88_> ah ok
06:32:31 <merijn> ph88_: So safe-indexing could be a million times slower than indexing, but still be constant time
06:33:49 <ph88_> foldl' was the fastest fold right ?
06:34:13 <pacak> Depends
06:34:18 <merijn> It Depends (TM)
06:36:19 <nshepperd> for an operation on small data that is strict in both arguments, it's a safe bet
06:37:57 <pacak> nshepperd: Not if operation is expensive and you can get away with folding only part of the list.
06:38:53 <ph88_> merijn, which fold could i best use here ?  https://bpaste.net/show/54a30c73f361
06:39:14 <ph88_> for speeeeeeed
06:41:34 <ph88_> does it even matter if i do foldr or foldl for +  ?
06:41:56 <merijn> for + you want foldl'
06:41:57 <ph88_> maybe i should use sum ?
06:42:01 <pacak> map and sum
06:42:08 <pacak> those are more readable
06:42:34 <mniip> @src sum
06:42:34 <lambdabot> sum = foldl (+) 0
06:42:40 <mniip> you want foldl'
06:42:48 <ph88_> so not use sum ?
06:43:00 <mniip> well, depends on how smart ghc is
06:43:08 <ph88_> sum' = foldl' (+) 0
06:43:09 <nshepperd> pacak: then you want foldl' with some sort of early stopping condition attached, I guess. which amounts to foldr with some continuation stuff
06:43:53 <mniip> nshepperd, but what about strictness
06:47:10 <nshepperd> what about it
06:48:06 <nshepperd> @let sum100 xs = foldr (\x k acc -> if acc >= 100 then min 100 acc else k $! (acc + x)) id xs 0
06:48:08 <lambdabot>  Defined.
06:48:15 <nshepperd> > sum100 [1..]
06:48:17 <lambdabot>  100
06:48:39 <nshepperd> > sum100 [1..10]
06:48:42 <lambdabot>  55
06:49:02 <ph88_> i'm getting confused now, what should i put for sum_1  ?   https://bpaste.net/show/c695241f3974
06:51:04 <ph88_> is this right?    sum_1 = sum' $ map (\x -> sum_2 ** 2) list_j
06:53:31 <jchia_1> I have newtype Foo a = Foo (a, a). Can I make a Bifunctor instance for it? I'm having trouble because there's only one type param.
06:53:44 <Cale> No.
06:53:50 <Cale> You could make a Functor instance for it.
06:54:04 <jchia_1> Cale: What's the closest I can get? I want to be able to use the Bifunctor functions on it.
06:54:17 <Cale> Then you should newtype it differently
06:54:24 <jchia_1> Cale: Sometimes I want to fmap the left side, sometimes the right side.
06:54:30 <jchia_1> Cale: How?
06:54:32 <Taneb> jchia_1, why aren't you just using (,)
06:54:37 <nshepperd> ph88_: maybe it would help to write down some types for these things
06:54:45 <ph88_> ok
06:54:54 <Cale> newtype Foo a b = Foo (a,b)
06:54:56 <jchia_1> Taneb: Readability and type safety. I want to have function names be meaningful that work for it.
06:55:10 <Taneb> jchia_1, then do something like data Foo a b = Foo a b
06:55:24 <jchia_1> Taneb: The left and right side have to be the same type.
06:55:37 <Cale> jchia: Think about, e.g. what happens when you apply  first show  to something of type  Foo Integer
06:55:48 <nshepperd> ph88_: there's a sum_2 for each j, right? so that should be a list of Doubles or something
06:55:54 <Cale> Supposing that there were some sort of Bifunctor instance available
06:55:55 <c_wraith> jchia_1: Bifunctor and Functor are type-based.  If you want to treat the two components differently, you need something other than the type to dispatch on.
06:56:07 <c_wraith> jchia_1: lenses are the usual answer
06:56:14 <nshepperd> ph88_: then sum_1 is the sum of squares of sum_2
06:56:16 <jchia_1> Cale: You get (String, Integer)
06:56:17 <ph88_> nshepperd, yes .. i want to sum the [Double]
06:56:47 <Cale> jchia_1: Yeah, which obviously doesn't work if you only have one type parameter
06:56:53 <jchia_1> Cale: I mean I want it to give me (String, Integer), but I see the problem.
06:57:00 <Cale> wait, what?
06:57:10 <Cale> It would have to give you Foo something, for sure
06:58:01 <Cale> (but really, it makes no sense at all, because it would be a kind error)
06:58:07 <jchia_1> I mean I want first show (Foo 1 2) to give me back a type Foo "1" 2, but I see the probem when there's only one type param.
06:58:18 <Cale> yeah
06:58:33 <Cale> also, that would be using data rather than newtype then
06:58:50 <jchia_1> OK, at least I can make a Functor instance
06:59:30 <jchia_1> Cale: OK, just to illustrate the idea
07:02:03 <merijn> Any linux users willing to quickly test something for me?
07:06:49 <jchia_1> merijn: What do you need to test?
07:09:10 <merijn> jchia_1: I have a small library dealing with pty's which works fine for me on OSX, but someone reported it wasn't working on linux, so I need someone to check if the terminal config is getting messed with
07:09:34 <jchia_1> OK, specifically, what needs to be done on Linux for the test?
07:09:43 <jchia_1> I'm not familiar with pty.
07:10:15 <merijn> jchia_1: Basically, it's a matter of 1) cloning https://github.com/merijn/posix-pty 2) building with tests 3) running the "dist/build/stty/stty" executable cabal builds and then running "stty -a" and dumping the output of both on lpaste
07:11:43 <jchia_1> OK, let me try.
07:12:25 <jchia_1> merijn: How do I build it? I'm not familiar with how to do cabal non-stack builds.
07:14:04 <hsk3> When I run my app like this:
07:14:04 <hsk3>     stack --docker-run-args='-p 4567:4567' exec my_web_app -- -p 4567
07:14:06 <hsk3> I cannot connect to that app on my local computer's localhost:4567
07:14:06 <hsk3> Why not?
07:14:07 <merijn> jchia_1: "cabal configure --enable-tests && cabal build" should probably work (since afaik all the dependencies ship with GHC)
07:14:12 <glguy> jchia_1: if you only know how to build with stack, use stack
07:14:31 <merijn> glguy: He can't, because I didn't write a stack.whatever :p
07:14:42 <glguy> that's not important
07:15:00 <glguy> stack.yaml shouldn't be in the repo anyway
07:15:10 <glguy> that's what stack init is for
07:16:11 <ph88_> why does my vector go out of bounds ?  https://bpaste.net/show/7287aaff59ac
07:16:54 <glguy> libraries can't depend on a custom stack.yaml since they're destined to be built as dependencies in another project
07:17:03 <ph88_> nshepperd, ^
07:19:55 <ph88_> oh i think i know why .. but i thought lazy solved it
07:20:09 <jchia_1> merijn: Still working on it
07:24:01 <merijn> jchia_1: no worries :)
07:25:59 <glguy> ph88_: takeWhile (<= n) [m..].   is.   [m..n]
07:26:43 <jchia_1> merijn: I ran "stack test" and got some output. I'll chat the output to you directly.
07:28:39 <merijn> jchia_: You can also simply lpaste it if that's easier :)
07:28:56 <jchia_> merijn: Never mind, here's the lpaste: http://lpaste.net/354759
07:29:28 <merijn> jchia_: Could you also paste the output of "stty -a" if you run it in the same terminal?
07:30:59 <jchia_> merijn: That was just stty. Here's "stty -a": http://lpaste.net/354761
07:32:30 <merijn> jchia: I think the second one is the same as the output of the test? ;)
07:35:17 <quchen> glguy: Careful,
07:35:18 <quchen> > takeWhile (<= 3) [0.1 ..]
07:35:20 <lambdabot>  [0.1,1.1,2.1]
07:35:25 <quchen> > [0.1 .. 3]
07:35:27 <lambdabot>  [0.1,1.1,2.1,3.1]
07:35:52 <glguy> quchen: check the paste
07:35:54 <merijn> A pox upon the insanity that is Enum for Double
07:36:05 <glguy> we're talking about vector indexes?
07:36:13 <quchen> glguy: Oh, it was about a paste. Nevermind then
07:36:24 <quchen> Anyway: enumerating the reals is hard :-)
07:38:05 <spear2> hi all, does anyone know about xmobar "avoidStruts" layout breaking with newer versions of xmonad + xmobar ?
07:39:08 <spear2> i just upgraded to xmonad 0.13 + xmobar 0.24.3 and now xmobar is hiding behind xmonad windows
07:40:19 <jchia_> merijn: Yes, they look the same except for blank lines, but that's what I got. Do you want me to try something else?
07:41:12 <Taneb> spear2, might be worth asking in #xmonad ?
07:41:12 <merijn> jchia_: I find it odd that "stty -a" would include both a Haskell error and a size of 10x10, because I wouldn't expect you to use a 10 by 10 terminal :)
07:41:24 <spear2> Taneb: thx
07:43:51 <jchia_> merijn: Yeah, that looks odd.
07:47:51 <lpaste> hexagoxel pasted “merijn” at http://lpaste.net/354763
07:48:34 <merijn> hexagoxel: Ok, that looks mostly sane
07:48:42 <merijn> hexagoxel: Which distro?
07:48:47 <hexagoxel> arch
07:49:46 <merijn> hexagoxel: Which glibc version?
07:51:31 <ph88_> which i could quickly plot graphs form ghci
07:51:36 <merijn> Unrelatedly: Apparently my Hackage password got wiped from my password store and while Chrome remembers it, I can't actually get the plaintext to use "cabal upload" >.<
07:51:49 <stphrolland> Hi everyone. I'm getting compilation errors when I try to pass a lens getter as a parameter of a polymorphic function. Code is here: http://lpaste.net/354766. I don't grasp the error I am doing. Could you give me any insight on the problem ?
07:52:06 <hexagoxel> merijn: 2.25
07:52:35 <merijn> hexagoxel: hmmm, error is happening on Debian with 2.24, so maybe that combo is just broken
08:09:03 <Kototama> Is it possible to transform that http://paste2.org/Whe1waGp into a F-algebra?
08:15:15 <ph88_> seems that pandoc is not perfect :(   http://pandoc.org/try/?text=TDEV(n+*+%5Ctau)+%3D++%5Csqrt%7B+%5Cfrac%7B1%7D%7B6n%5E2(N-3n%2B1))%7D+%5Csum_%7Bj%3D1%7D%5E%7BN-3n%2B1%7D+%5Cleft(+%5Csum_%7Bi%3Dj%7D%5E%7Bn%2Bj-1%7D+(x_%7Bi%2B2n%7D-2x_%7Bi%2Bn%7D%2Bx_i)%5Cright)%5E2+%7D&from=latex&to=asciidoc
08:18:07 <shapr> ph88_: put up a PR?
08:18:27 <ph88_> that's quite complex .. i found a website that does it
08:18:34 <ph88_> http://www.sciweavers.org/free-online-latex-equation-editor
08:22:20 <Sentry812> What's haskell?
08:22:49 <Iceland_jack> A programming language
08:22:53 <ph88_> true story
08:23:08 <Sentry812> Oh.
08:23:46 <ph88_> it even has two websites !  https://haskell-lang.org/  https://www.haskell.org/
08:24:08 <Sentry812> Hm.
08:24:25 <rom1504> Sentry812: it starts with h, continues with a, then it progresses to s, to get to k, eventually it gets to e, and it finishes by 2 l
08:24:32 <quchen> ph88_: Looks like something more serious, since http://pandoc.org/try/?text=%5Cfrac%7B1%7D%7B1%7D&from=latex&to=html5
08:24:38 <rom1504> you can use something called google to know about it
08:24:41 <ph88_> rom1504, you could have lambdabot write that
08:25:05 <Iceland_jack> > map toUpper "Haskell!"
08:25:07 <lambdabot>  "HASKELL!"
08:37:04 <ph88_> how can i parse everything until "\r\n" with attoparsec ?
08:40:51 <ski> > [c | c <- ['\0' ..],isUpper c,isLower c]
08:40:55 <lambdabot>  ""
08:41:04 <ski> > zipWith toCase (map charCase "Haskell!") "PASCAL ?"
08:41:07 <lambdabot>  "Pascal ?"
08:42:13 <ph88_> cute
08:49:59 <ph88_> i try to parse everything up to "\r\n" , this is what i have so far  https://bpaste.net/show/fcd09185ec91   don't understand what's wrong with the bytestring types
08:51:27 <mauke> apparently you're mixing strict and lazy bytestrings
08:56:25 <ph88_> which one is lazy ?
08:57:26 <ph88_> i use string from here   https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:string
08:57:37 <ph88_> it's strict i think
08:58:13 <ph88_> singleton from here https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html#v:singleton  .. also strict
08:59:13 <codedmart> How does `Double` work with Aeson? I am testing some decoding in the console. The output is not what I would expect.
08:59:13 <codedmart> https://gist.github.com/codedmart/f4ebb71728742a6643c403392437cb59
08:59:25 <codedmart> I would expect this to fail parsing and return `Nothing`?
08:59:31 <ph88_> ooh i see it i think   import qualified Data.ByteString.Lazy as B
08:59:35 <ph88_> using the wrong package :/
09:01:18 <ph88_> how can i convert Char to Word8 ?   https://bpaste.net/show/7dab35c01f48
09:02:18 <ph88_> codedmart, you mean because of _length ?
09:02:21 <lyxia> codedmart: https://github.com/bos/aeson/blob/1cf3edc3fab98a530042891b63bd363c94cf15de/Data/Aeson/Types/FromJSON.hs#L181-L185 NaN <-> null
09:02:46 <codedmart> ph88_: Yeah
09:02:51 <codedmart> lyxia: That seems odd to me.
09:03:10 <codedmart> So I need to account for this myself then
09:03:37 <lyxia> ph88_: toEnum . fromEnum
09:04:02 <ph88_> codedmart, this seems wrong to me as well .. line 183
09:06:08 <codedmart> @phadej you around? It looks like you added that?
09:06:08 <lambdabot> Unknown command, try @list
09:06:24 <ph88_> lyxia, uf that's a bit ugly i think .. but ok .. i try to implement it https://bpaste.net/show/80852fd0b2ea
09:07:39 <ph88_> codedmart, i think null is another type .. maybe he intended to parse NaN into NaN there ? i think JS has also NaN so it's good to account for that case
09:08:11 <lyxia> If you're using the Char8 module you don't need to convert Char explictily
09:08:53 <ph88_> how do i use the Char8 module ? just import ?
09:09:15 <lyxia> yeah
09:09:39 <lyxia> ph88_: the last <*> should be <$>, or more simply, import Data.ByteString.Char8 as BSC  ... BSC.singleton <$> anyChar
09:11:55 <ph88_> lyxia, i try it https://bpaste.net/show/793141aad59b
09:11:59 <ph88_> oh shit
09:12:01 <ph88_> <*>
09:12:01 <ph88_> nvm
09:12:36 <ph88_> ok this is not easy with so many modules
09:12:47 <ph88_> i use no 5 !!! modules about bytestring !
09:13:10 <phadej> codedmart: ?
09:13:28 <ph88_> phadej, about this https://github.com/bos/aeson/blob/1cf3edc3fab98a530042891b63bd363c94cf15de/Data/Aeson/Types/FromJSON.hs#L181-L185
09:13:46 <codedmart> phadej The NaN in FromJSON
09:14:02 <codedmart> I guess what ph88_ said makes sense though.
09:14:21 <phadej> it makes `Double` and `Float` preserve NaN's
09:14:37 <codedmart> I would expect Null to not parse though.
09:14:39 <phadej> because `toJSON NaN = Null` 
09:14:50 <codedmart> Because Null is not the same as NaN in js.
09:15:00 <ph88_> ups .. forgot i have a rust workshop this evening
09:15:53 <phadej> codedmart: if you thing it's wrong, open an issue
09:15:58 <ph88_> phadej, maybe toJSON and fromJSON don't have to be the reverse of each other
09:16:36 <codedmart> I didn't know NaN existed in Haskell. Is that in Base?
09:16:44 <phadej> ph88_: there indeed aren't such requirement; but in 99.9999% you do want that
09:16:45 <pikajude> it's a Double
09:16:50 <pikajude> NaN is part of the ieee-whatever standard
09:17:00 <Sornaensis> > NaN
09:17:02 <pikajude> oh i guess it's also a float
09:17:03 <lambdabot>  error: Data constructor not in scope: NaN
09:17:06 <pikajude> > 0 / 0
09:17:08 <lambdabot>  NaN
09:17:10 <pikajude> there you go
09:17:12 <Sornaensis> > isNaN (0/0)
09:17:14 <lambdabot>  True
09:17:16 <pikajude> there's no NaN literal
09:17:20 <pikajude> nor should there be really
09:17:30 <Sornaensis> > (0/0) == (0/0)
09:17:33 <lambdabot>  False
09:17:36 <Sornaensis> cool
09:17:44 <pikajude> that's also part of the ieee754 standard
09:17:48 <codedmart> Yeah I guess that makes sense. Just didn't realize it.
09:17:58 <ph88_> yes the fpu in the cpu will give the result if a number is a NaN .. it's not on the software level ..
09:18:01 <pikajude> i hope I put enough e's in that
09:18:04 <pikajude> ieeeee754
09:18:13 <Sornaensis> eye triple ee
09:19:13 <ph88_> anyway that doesn't explain why   null should be converted to NaN  :P
09:19:47 <ph88_> remove this line https://github.com/bos/aeson/blob/1cf3edc3fab98a530042891b63bd363c94cf15de/Data/Aeson/Types/FromJSON.hs#L183 and null will be a type error i think
09:20:51 <lyxia> but why would you want to encode *less* of a type
09:21:13 <pikajude> well
09:21:15 <pikajude> if it's wrong
09:21:19 <phadej> it's not
09:21:24 <phadej> NaN is correct Double value
09:21:27 <pikajude> i know, but i'm providing an example
09:21:48 <phadej> if you want non-NaN Double, use newtype
09:21:56 <pikajude> for example, you wouldn't really want parseRealFloat to accept string inputs
09:22:03 <pikajude> and convert them to doubles
09:22:06 <lyxia> good thing it doesn't
09:22:06 <Sornaensis> why not
09:22:18 <pikajude> it's a recipe for disaster Sornaensis 
09:22:29 <pikajude> for example, strings have more precision than doubles
09:22:30 <Sornaensis> Sure but any specific reason?
09:22:34 <Sornaensis> ah
09:22:44 <phadej> and aeson tries to preserve the whole type domain (and precision), because otherwise generic deriving would do wrong thing
09:22:45 <pikajude> node.js will sometimes return the same inode for separate files
09:22:51 <phadej> when you don't care about actual wire format
09:22:52 <pikajude> because they're downcasted from a 64-bit int to a 53-bit double
09:22:52 <Sornaensis> I mean I know for instance using Integer is bad because arbitrary memory usage
09:22:56 <pikajude> or a 52-bit double
09:22:58 <phadej> only that parseJSON . toJSON = id
09:23:14 <pikajude> well, haskell's Integer type converts between int and bignum iirc
09:23:19 <pikajude> so you don't have to worry about that too much
09:23:30 <phadej> pikajude: in aeson you have
09:23:36 <phadej> because 1e1000000
09:23:41 <Sornaensis> if you are deserializing a heug number
09:23:44 <phadej> would blow you memory
09:23:51 <pikajude> well that's what Scientific is for, right
09:24:21 <phadej> pikajude: yes, but you shouldn't use Integer instance when parsing untrusted JSON
09:24:23 <pikajude> anyway, my point being that it wouldn't make any sense for aeson to decode strings as doubles even though it is technically encoding "less" of a type
09:24:48 <phadej> pikajude: and it doesn't, however it makes sense to decode null into NaN
09:24:48 <pikajude> because the string to double conversion is fraught with peril
09:24:54 <pikajude> i know
09:24:59 <pikajude> but the question was "why would you want to encode less of a type"
09:25:04 <pikajude> and my answer is "if encoding more of the type is incorrect behavior"
09:25:19 <pikajude> i'm not saying null -> NaN is
09:25:21 <pikajude> just giving an example
09:25:37 <phadej> and infact htere is a bug in aeson
09:25:38 <phadej>  encode (1/0 :: Double)
09:25:38 <phadej> "null"
09:25:59 <phadej> but I don't know elegant way to solve that (except encoding infinities as strings)
09:27:29 <phadej> > 1/0 :: Double
09:27:31 <lambdabot>  Infinity
09:28:15 <Sornaensis> > (1/0) > (0/0)
09:28:18 <lambdabot>  False
09:28:30 <Sornaensis> > compare (1/0) (0/0)
09:28:32 <lambdabot>  GT
09:38:39 <orion> Let's say I wanted to start a service like Amazon Lambda, but instead of running nodejs or python code, I ran Haskell code. What packages/modules should I look in to for compiling/running the code?
09:38:51 <orion> Is the `plugins` package any good, or is it an unmaintained mess?
09:42:10 <geekosaur> plugins is a wrapper around hint these days, you might go direct to the source. (plugins originated before hint)
09:42:40 <geekosaur> but it depends on exactly what you want to do, there are multiple approaches available (hint/plugins, cloud haskell, etc.)
09:43:33 <orion> I don't think Cloud Haskell is what I am looking for.
09:44:14 <burtons> but...cloud
09:44:42 <geekosaur> just mentioning as another possibility. there's more than that but I'm still working on my first coffee...
09:45:15 <orion> I want something simple like, "When a FOO happens, execute this piece of Haskell code, which will return a code that will cause me to BAR."
09:45:31 <orion> s/code/Haskell value
09:46:05 <cocreature> geekosaur: I’m pretty sure plugins is not a wrapper around hint. plugins can do things like compile to object code and then load that while hint does runtime interpretation
09:46:43 <orion> And a major working assumption I have: I possess a magical way of weeding out "bad" code that would, say, execute forever.
09:47:06 <cocreature> orion: that’s easy. just kill it after a fixed time frame
09:47:10 <orion> cocreature: Right.
09:47:34 <orion> So what I'm wondering is what options besides `plugins` is available.
09:49:35 <geekosaur> cocreature, pretty sure it is, to the extent that it uses hint instead of ghc-api directly for most (possibly not all) things
09:50:04 <cocreature> geekosaur: it doesn’t even depend on hint
10:01:40 <paolino> is it correct that unfoldr makes more code than explicit  recursion ?
10:02:35 <kuribas> :t unfoldr
10:02:37 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:04:07 <paolino> mh, unless you have the (b -> Maybe (a, b)) for other reasons :-)
10:08:30 <kuribas> > unfoldr (\x -> guard (x /= 0) >> Just (intToDigit (digitTox `quot` 10), x `div` 10)) 2341
10:08:33 <lambdabot>  error: Variable not in scope: digitTox :: Int
10:08:44 <kuribas> > unfoldr (\x -> guard (x /= 0) >> Just (intToDigit (digitToInt `quot` 10), x `div` 10)) 2341
10:08:46 <lambdabot>  error:
10:08:46 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Char -> Int’
10:08:46 <lambdabot>      • Probable cause: ‘quot’ is applied to too few arguments
10:11:33 <kuribas> > reverse $ unfoldr (\x -> guard (x /= 0) >> Just (intToDigit (x `rem` 10), x `div` 10)) 2341
10:11:35 <lambdabot>  "2341"
10:13:44 <paolino> kuribas, guard is an ace 
10:15:39 <spatial> A basic question. Why is pattern matching considered a functional concept ? 
10:16:31 <kuribas> > let f y x | x == 0 = y | otherwise = f (intToDigit (x `rem` 10):y) (x `div` 10) in f [] 2341
10:16:34 <lambdabot>  "2341"
10:17:56 <kuribas> spatial: is it?
10:18:35 <Cale> spatial: It's more historical than anything -- algebraic data types come out of the same approaches to mathematical logic that we get lambda from.
10:19:34 <Cale> I suppose that doesn't exactly get you as far as pattern matching, but you need something to match before you can have pattern matching :)
10:20:20 <spatial> Was curious. Java 10 has such a proposal.
10:22:21 <Cale> spatial: In logic, if you want to prove the implication A -> B, you typically start by assuming A, and then try to prove B, and then if you're successful, by natural deduction, conclude A -> B
10:23:00 <Cale> spatial: In lambda calculus, if you want to construct a function of type A -> B, you start by introducing a variable x of type A, and try to construct some term e of type B
10:23:27 <Cale> and then if you're successful, you can form the lambda term (λx. e) of type A -> B
10:23:27 <spatial> Cale: You mean the roots are in math ?
10:24:01 <Cale> Yeah, what I'm hinting at here is a connection between logic and lambda calculus
10:24:57 <Cale> This actually can be carried through to the introduction and elimination rules for all of (intuitionistic) logic.
10:25:08 <seequ_> Also pattern matching is a very functional way to decompose structures, compared to manually checking variants and picking out values
10:25:36 <Cale> Logical conjunction (and) corresponds to pairs, and gives the basic pattern for product types
10:25:40 <seequ_> And of course was introduced in functional languages, which is a big part of it
10:26:10 <Cale> Disjunction (or) corresponds to what we call Either in Haskell, and gives the pattern for sum types
10:26:44 <Cale> and as I mentioned, implication corresponds to function types
10:28:45 <Cale> It's sort of funny that functional programming languages ended up being called that, and logical programming languages came to refer to something different.
10:29:06 <Cale> The type systems of functional programming languages correspond very directly to logics of various sorts.
10:30:19 <Cale> But of course, first class functions are pretty important to the way we actually write programs, so it's not that strange :)
10:31:14 <eschnett> i want to define a type class that has an associated type (?), and that type should be an instance of functor
10:31:18 <eschnett> like this: <https://gist.github.com/eschnett/5e7abcd9153619ee324c49137fead2e3>
10:31:21 <dolio> Functional programming is propositional programming.
10:31:28 <dolio> Logic programming is judgmental programming.
10:31:33 <eschnett> what is the right definition for this?
10:31:46 <eschnett> the “instance” keyword in the class definition isn’t accepted.
10:31:54 <lyxia> eschnett: class Functor (Bnd m) => Manifold m
10:32:04 <glguy> eschnett:   class Functor (Bnd m) => Manifold m
10:32:23 <glguy> also type Bnd Grid a = GridBnd a should probably be: type Bnd Grid = GridBnd
10:32:54 <eschnett> thanks!
11:02:08 <ski> dolio : elaborate ?
11:06:39 <dolio> ski: In functional programming, you use logic to define a term T such that |- T (or what have you), so T is like a proposition, and computation is defined for these 'propositions'.
11:07:45 <dolio> ski: In logic programming, you are giving a bunch of inference rules between judgments G |- P, and the computation is using your inference rules to find a proof of a judgment.
11:10:13 <ski> dolio : does that apply to e.g. lambdaProlog as well ?
11:10:29 <dolio> I think so.
11:10:41 <dolio> I'm no expert, though.
11:11:36 <ski> i'm not quite getting the logic programming connection with inference rules, there
11:11:37 <dolio> Lambda prolog just gives you a richer proposition language for your judgments, I think.
11:13:31 <ski> is this related to the judgements-as-types paradigm, in e.g. Twelf, <http://twelf.org/wiki/Judgment> ?
11:13:36 <dolio> Maybe that's not a good description. Maybe a better one is that you give axiom judgments and it tries to cut them together?
11:14:40 <ski> well, that would correspond to resolution in Prolog, i think
11:16:20 <ski> but the semantics of lambdaProlog isn't given in terms of adding the negation of the query as an axiom, and trying to deduce the empty (absurd) judgement -- it's given in terms of a direct (though focused) proof search, ND-style
11:16:35 <dolio> I mean, part of the problem is that there are kind of correspondences between a lot of stuff. Inference rules vs. judgments. vs hypothetical propositions.
11:16:47 <JoshS> Great my virus scanner says manoflag's sign off is malware and it wants to restart my computer to remove #haskell's log
11:17:16 <JoshS> that's pretty sneaky
11:17:19 <ski> dolio : yes .. so it's not clear to me where the distinction you're talking about really lie ..
11:17:20 <dsh> JoshS, i just got the same thing
11:17:27 <dsh> i was like wtf
11:17:33 <JoshS> someone needs to ban him for that
11:17:57 <dsh> for serious
11:18:36 <kadoban> Heh, what'd they do, put some virus signature in their part message? I have parts hidden.
11:18:45 <dsh> kadoban, it looks like it
11:19:03 <dsh> oddly enough no virus scanner on virus total detects it
11:19:11 <dsh> perhaps it's tripping heuristics only
11:19:17 <JoshS> window's defender does
11:19:24 <kadoban> That's rather funny, but ya I suppose it's a bit antisocial too xD
11:19:34 <dsh> JoshS, yeah microsoft security essentials does for me
11:19:43 <dsh> but not when virustotal runs MSE
11:20:09 <JoshS> it's a little bit of javascript, a reference to a malware site
11:20:30 <Sornaensis> lol
11:20:33 <JoshS> lol 
11:20:34 <Sornaensis> you're using webchat?
11:20:38 <JoshS> no
11:20:43 <JoshS> I'm using hexchat
11:20:46 <dsh> hexchat with logging
11:20:50 <JoshS> yeah
11:21:08 <JoshS> :3 lol I won't miss the #haskell log
11:21:26 <dolio> ski: Anyhow, in most functional languages, proof search is type checking/inference. In logic languages, proof search is the primary form of computation.
11:21:35 <JoshS> I'm not sure why I'm in here, I've never used haskell, I just have an interest in programming languages in general
11:21:59 <dsh> i love haskell but i never use it
11:22:10 <Sornaensis> I use haskell but don't love it
11:22:21 <dsh> lol i wonder if that K-Lined is legit
11:22:24 <JoshS> I tend to prefer dynamically typed languages when I'm not going for to-the-metal
11:22:31 <dolio> But in logic languages with types, I guess you might have two proof searches.
11:23:32 <JoshS> Someone said to me the other day that when you're programming in Haskell, you have to come up with the types before you come up with the algorithm.  I don't think I'll ever get the hang of that
11:23:35 <geekosaur> that will be real, yes; freenode is pretty good about prefixing the actual source
11:23:44 <dsh> depends on what you mean by dynamic but static typing is the best
11:23:56 <Cale> JoshS: You don't *have* to, but it can be helpful
11:24:08 <dsh> in dynamic languages you need to do that too though if you want to implement the algorithm well
11:24:15 <Sornaensis> usually you start out by thinking of what you are mapping to and from
11:24:18 <JoshS> Well I like scheme except for the syntax.  I like lua but it's not quite as powerful as scheme...
11:24:20 <Cale> JoshS: and sure, you'll get used to it if you use the language for a while and make sure to write the types down.
11:24:21 <Sornaensis> and then that turns into types, and then code
11:24:25 <geekosaur> it;d be "Quit: ..." if they were trying to make their quit message look like a k-line. that works on other irc networks but not freenode because of the prefix indicating it was an actual quit
11:24:43 <dsh> geekosaur, neat
11:25:11 <dolio> That isn't all that odd, though, because you can have many sorts of judgments in a presentation of logic/type theory.
11:25:14 <nshepper1> JoshS: that's a rather classic trick. Like the ATH0 thing https://everything2.com/title/%252B%252B%252BATH0
11:25:18 <Sornaensis> that site doesn't even resolve for me
11:25:20 <JoshS> I tried writing something in lua for a couple months and it turned out TOO SLOW, and I'm starting over in c++ and weirder things, an in-memory C compiler for scripting.  Sometimes nothing is fast enough
11:25:49 <JoshS> That project is a general gaming thing.  Scriptable board games.
11:26:14 <Cale> JoshS: Personally, I have a hard time beginning to write any code without having a pretty clear idea of the type of thing that it is that I'm trying to write.
11:26:23 <Cale> At least locally :)
11:27:30 <JoshS> It depends.  If the algorithm is new, and you're overwhelmed with complexity, it's nice to have nothing to think about other than the algorithm
11:27:50 <JoshS> if you have to think about types too, thats a little more complexity on top of it, and you can trip over them
11:28:44 <kadoban> Coming up with the types for an algorithm is usually fairly trivial, or at least no more work than coming up with the data structures involved, which you'd have to do anyway.
11:30:20 <kadoban> Haskell is actually my favorite language for playing with algorithms and data structures, it makes it really nice to express them usually.
11:30:37 <JoshS> It's not consistent.  Sometimes types help you keep things organized.  Sometimes they get in your way.  If you don't do the kind of programming where you get in way over your head you're they won't get in the way
11:30:43 <JoshS> I like to get in over my head >.>
11:31:25 <allenj12> does anyone know of a haskell(ish?) language that is actually a lisp?
11:31:26 <kadoban> I'm in over my head most of the time recently ... been doing a lot of competitive programming recently.
11:31:43 <JoshS> But as a principle, there's something nice about "you don't type anything in your program that isn't the algorithm"
11:32:04 <JoshS> I'm writing my first compiler.  I'm pretty overwhelmed
11:33:11 <JoshS> I've greenspun's 10th on the problem.  My parser generates s-expressions that are programs that compile the program >.>
11:33:28 <JoshS> So yeah, I basically wrote a lisp 
11:34:51 <JoshS> It's a little weirder because the expressions are fexpressions so I can control the order in which I evaluate tree nodes and whether i evaluate them at all
11:35:13 <JoshS> http://lambda-the-ultimate.org/node/5424
11:36:58 <dolio> I don't think what you're saying makes any sense to me, anymore.
11:37:36 <JoshS> lol, yeah
11:38:21 <JoshS> an fexpression is a function that doesn't evaluate its arguments.  But it's handed an environment and you can manually evaluate them as needed.
11:38:31 <dolio> No, I understand fexpressions.
11:38:48 <dolio> Well, somewhat.
11:39:57 <Sornaensis> is lambda the ultimate still written in PHP
11:40:12 <JoshS> in that post I linked, I explained that a problem with a parser generator is that it evaluates actions in an order that has to do with when it recognizes 
11:40:27 <ski> dolio : aye
11:40:30 <JoshS> but when you're generating code, that isn't the order you want to walk the tree in
11:41:28 <Sornaensis> what do you mean
11:41:37 <JoshS> So if the tree is recast as a s-expression full of fexprs you can walk it in a controlled order in one pass
11:41:44 <nshepper1> Why use a parser generator that runs actions when you can just build an ast
11:41:48 <Sornaensis> You just build the tree
11:42:30 <JoshS> parser generators don't actually make abstract syntax trees, they make concrete syntax trees that follow the grammar
11:42:54 <balor_> Given a `[Maybe Int]` does it make sense to be allowed to transform it into a `Maybe [Int]`?
11:42:55 <JoshS> an abstract syntax tree would be one that follows the semantics not the grammar
11:43:18 <JoshS> but once you have the tree, then you have to process it
11:43:28 <JoshS> in this case I'm building a tree that knows how to process itself
11:46:27 <tsahyt> are there any benchmarks of trifecta vs attoparsec?
11:50:26 <cocreature> balor_: sure that function is called "sequence"
11:50:28 <ski> @type sequence :: [Maybe Int] -> Maybe [Int]
11:50:30 <lambdabot> [Maybe Int] -> Maybe [Int]
11:50:30 <ski> @type (\xs -> let ys = catMaybes xs in if null ys then Nothing else Just ys) :: [Maybe Int] -> Maybe [Int]
11:50:32 <lambdabot> [Maybe Int] -> Maybe [Int]
11:50:36 <ski> balor__ : any of those ^ ?
11:50:48 <cocreature> balor_: obviously you lose information in that process but if that’s fine in your usecase then by all means go ahead
11:50:51 <balor__> ski, thanks
11:51:06 <ski> the first of them gives `Nothing' in case any element of the input list was `Nothing'
11:51:28 <ski> the second gives `Nothing' only in case no element in the input list was of the form `Just (...)'
11:55:54 <Sornaensis> > 3^9/2^
11:55:55 <Sornaensis> > 3^9/2^9
11:55:56 <lambdabot>  <hint>:1:7: error:
11:55:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:55:58 <lambdabot>  38.443359375
11:57:03 <jackhill> Hi, I have some (I think) pretty simple XML that I would like to parse into Haskell data so I can play around with in in the REPL to see what's there. What XML library would you recommend?
11:59:11 <cocreature> jackhill: I’ve used xml-conduit in the past and it worked pretty  well for me
12:00:00 <jackhill> cocreature: thanks!
12:28:48 <tsahyt> Is there any package providing generalized algorithms for local search?
12:29:02 <tsahyt> I'm just looking for project ideas, and a quick hackage search didn't yield anything usable
12:29:33 <tsahyt> nvm, there is one
12:30:27 <Cale> tsahyt: What do you mean by "local search"? Does A* fit that?
12:31:04 <tsahyt> Cale: no. in the terminology I learned, local search refers to things such as hill climbing, simulated annealing, etc
12:31:11 <Cale> ah, okay
12:31:31 <Cale> So nonlinear optimisation sorts of things
12:31:44 <tsahyt> yeah that'd be one application
12:32:03 <tsahyt> genetic algorithms also fall into that category. it's really very broadly applicable
12:33:01 <cocreature> tsahyt: which library did you find?
12:33:10 <tsahyt> http://hackage.haskell.org/package/local-search
12:33:48 <tsahyt> it's an interesting approach too
12:33:54 <tsahyt> with that stream type underneath
12:36:09 <cocreature> neat
12:36:11 <tsahyt> seems unmaintained though. the project page leads nowhere too
12:36:43 <cocreature> it has a surprising amount of documentation for an older, unmaintained haskell library :)
12:39:13 <tsahyt> judging by the project URL it originated from academia. that makes the documentation even more surprising
13:31:42 <adamCS> Hello all.  Is there a way to give an argument to a function such that , for any a in some given list of type level lists xss, and two given functors, f and g, there is a function f a -> g a?  I know I can do it as a constraint (the machinery in the generics-sop package does this with something like "All2 (HasFunction f g) xss" with "class HasFunction f g where do::f a -> g a") but I'd rather not burden the caller with
13:31:42 <adamCS>  creating an instance of a class just to use the machinery.   
13:32:19 <jle`> adamCS: you're looking for (forall a. f a -> g a)
13:32:31 <adamCS> jle':Except, not for all a
13:32:38 <adamCS> jle`:
13:32:40 <adamCS> sorry
13:32:45 <adamCS> just the a in xss
13:32:55 <cocreature> adamCS: is it ok if the caller needs to pass a list of those functions?
13:32:59 <jle`> what is an example of xss
13:33:26 <jle`> what is its kind?
13:33:31 <jle`> [[k]]?
13:33:31 <adamCS> cocreature: I'm interested in any way to do it and then I can zero in on a better interface if there is one
13:33:37 <adamCS> xss :: [[*]]
13:33:48 <adamCS> I mean, higher kinded would be okay too
13:33:53 <adamCS> but I'd be content with *
13:33:54 <jle`> why not just [*] ?
13:34:00 <cocreature> adamCS: also should that class me "HasFunction f g a where do :: f a -> g a"? without the a it seems wrong
13:34:08 <adamCS> cocreature: yes
13:34:09 <adamCS> sorry!
13:35:12 <jle`> it makes more sense to me to expect a type a in a list of types
13:35:15 <Ozymandy> How to add two numbers to the end of array?
13:35:16 <adamCS> jle`:  Good point.  I already have the xss in that form but some of this maybe some dictionary re-arranging anyway?
13:35:20 <Ozymandy> And to the start
13:35:22 <jle`> if you get a [[*]], you can just concatenate it
13:35:33 <jle`> Ozymandy: what array type are you using?
13:35:35 <jle`> Data.Array?
13:35:40 <Ozymandy> Integer
13:35:48 <jle`> that's not an array :'(
13:36:08 <Ozymandy> so what is it?
13:36:11 <EvanR> godel said you can implement anything with Integer!
13:36:13 <jle`> that's just an Integer
13:36:31 <jle`> it's not an array of anything
13:36:36 <jle`> it's just lik...6, or 10
13:36:39 <Ozymandy> Hmm, well so how? can you write code for me? I'm failed on it
13:36:40 <jle`> or maybe even 30
13:36:52 <jle`> Ozymandy: we need to know what type of array you are working with
13:36:55 <adamCS> jle`: Yeah.  Some of this is my confusion.  I will, eventually, need to be able to express it as "HasFunction f g a" at each a when the function is used.
13:36:56 <jle`> so we can know how to work with that array
13:37:06 <jle`> adamCS: you can do something like (forall a. Sigma a -> f a -> g a)
13:37:12 <EvanR> Ozymandy: do you mean a list
13:37:20 <Ozymandy> jle`: Just I have number list and I need add two numbers to the end
13:37:20 <adamCS> and the way the function will be used is in a product of products indexed by the xss
13:37:21 <jle`> Ozymandy: do you mean [Integer], maybe?
13:37:25 <Ozymandy> [2,3,5,]
13:37:30 <Ozymandy> this
13:37:32 <jle`> Ozymandy: ah yeah, so you're using a List
13:37:34 <monochrom> You can add a digit to the end of an Integer by (\x -> x*10 + digit)
13:37:37 <adamCS> jle`: What's Sigma there?
13:37:43 <EvanR> > [1,2] ++ [3,4,5,6] ++ [7,8]
13:37:45 <lambdabot>  [1,2,3,4,5,6,7,8]
13:37:59 <jle`> er sorry, i mean (forall a. Sigma as a -> f a -> g a)
13:38:04 <Ozymandy> Ok, but how to add to the start?
13:38:07 <Ozymandy> of list
13:38:15 <Sornaensis> > 1 : [2,3]
13:38:18 <lambdabot>  [1,2,3]
13:38:25 <jle`> Ozymandy: [1,2] ++ myList
13:38:37 <Ozymandy> source_file.hs:1:1:
13:38:37 <Ozymandy>     Couldn't match expected type IO t0 with actual type [Integer]
13:38:37 <Ozymandy>     In the expression: main
13:38:37 <Ozymandy>     When checking the type of the IO action main
13:38:45 <jle`> Ozymandy: paste your entire code
13:38:51 <jle`> adamCS: some way to choose from the list
13:38:51 <EvanR> not in the channel
13:38:54 <Sornaensis> please use lpaste
13:39:14 <jle`> you can use 'Index' from type-combinators, which is the same
13:39:16 <Ozymandy> jle`: I have no code now.
13:39:22 <jle`> Ozymandy: where did your error come from then?
13:39:50 <cocreature> adamCS: does something like this help http://lpaste.net/354781 ?
13:39:53 <Ozymandy> jle`: http://rextester.com/l/haskell_online_compiler from here. I just type that code with ++
13:40:38 <cocreature> adamCS: Rec f g as is then a type that contains the functions for all a in as
13:40:41 <jle`> adamCS: http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Data-Type-Index.html
13:40:50 <monochrom> main = print $ [1,2] ++ [3,4,5,6] ++ [7,8]
13:41:08 <jle`> adamCS: so you'd have (forall a. Index as a -> f a -> g a)
13:41:36 <adamCS> cocreature: Yes!  Hmm.  
13:41:45 <adamCS> jle`: And that!
13:41:49 <jle`> @let data Index as a where IZ :: Index (a ': as) a; IS :: Index as a -> Index (b ': bs) a deriving Show
13:41:50 <lambdabot>  .L.hs:233:15: error:
13:41:50 <lambdabot>      Ambiguous occurrence ‘Index’
13:41:50 <lambdabot>      It could refer to either ‘Lens.Index’,
13:41:53 <jle`> aw
13:42:10 <jle`> @let data Index' as a where IZ :: Index' (a ': as) a; IS :: Index' as a -> Index' (b ': bs) a deriving Show
13:42:11 <lambdabot>  .L.hs:235:14: error:
13:42:11 <lambdabot>      • Can't make a derived instance of ‘Show (Index' as a)’:
13:42:11 <lambdabot>          Constructor ‘IZ’ has existentials or constraints in its type
13:42:21 <jle`> @let data Index' as a where IZ :: Index' (a ': as) a; IS :: Index' as a -> Index' (b ': bs) a
13:42:23 <lambdabot>  Defined.
13:42:37 <Ozymandy> Thank you!
13:42:59 <jle`> @let type UniNatTrans as f g = forall a. Index as a -> f a -> g a
13:43:00 <lambdabot>  .L.hs:236:38: error:
13:43:00 <lambdabot>      • Expecting one fewer argument to ‘Index as’
13:43:00 <lambdabot>        Expected kind ‘k0 -> *’, but ‘Index as’ has kind ‘*’
13:43:05 <jle`> @let type UniNatTrans as f g = forall a. Index' as a -> f a -> g a
13:43:07 <lambdabot>  Defined.
13:44:13 <jle`> :t foo :: UniNatTrans '[Int,Bool] List Maybe; foo = \case IZ -> Just . sum; IS IZ -> \_ -> Nothing
13:44:13 <cocreature> I’m always surprised that lambdabot has the extensions enabled for that kind of madness
13:44:14 <lambdabot> error: parse error on input ‘;’
13:44:36 <jle`> @let untTest :: UniNatTrans '[Int,Bool] List Maybe; untTest = \case IZ -> Just . sum; IS IZ -> \_ -> Nothing
13:44:38 <lambdabot>  .L.hs:238:37: error:
13:44:38 <lambdabot>      • Pattern synonym ‘List’ used as a type
13:44:38 <lambdabot>      • In the second argument of ‘UniNatTrans’, namely ‘List’
13:44:42 <jle`> heh
13:44:47 <jle`> @let untTest :: UniNatTrans '[Int,Bool] [] Maybe; untTest = \case IZ -> Just . sum; IS IZ -> \_ -> Nothing
13:44:50 <lambdabot>  Defined.
13:44:58 <jle`> > untTest IZ [1,2,3]
13:45:00 <lambdabot>  Just 6
13:45:05 <jle`> > untTest IS [True, False]
13:45:07 <lambdabot>  error:
13:45:07 <lambdabot>      • Couldn't match expected type ‘Index' '[Int, Bool] Bool’
13:45:07 <lambdabot>                    with actual type ‘Index' as0 a0 -> Index' (b0 : bs0) a0’
13:45:14 <jle`> > untTest (IS IZ) [True, False]
13:45:14 <monochrom> madness magnus :)
13:45:16 <lambdabot>  Nothing
13:45:16 <EvanR> untzTest?
13:45:22 <adamCS> jle`, cocreature: I like both these ideas.  And I think they both point to more or less the same thing; use the same machinery that holds all the rest of the data indexed by these lists to hold all the functions.  Now I need to wrap that up so that the constraint version works too.
13:45:24 <jle`> > untTest (IS IZ) [1,2]   -- should be an error
13:45:26 <lambdabot>  Nothing
13:45:29 <jle`> aw man
13:46:36 <jle`> @let untTest2 :: UniNatTrans '[Int,Bool] [] Maybe; untTest2 = \case IZ -> Just . sum; IS IZ -> Just . and
13:46:37 <lambdabot>  .L.hs:248:18: error:
13:46:38 <lambdabot>      • Could not deduce: a ~ Bool
13:46:38 <lambdabot>        from the context: as ~ (a : as1)
13:46:46 <jle`> i guess Index isn't strong enough
13:47:37 <jle`> oh, i defined it wrong initially :'(
13:47:39 <jle`> @undefine
13:47:39 <lambdabot> Undefined.
13:47:40 <cocreature> seeing jle` repeatedly fight lambdabot reminds me of when I was guessing de bruijn indices for an ocaml coq plugin an hour ago
13:48:09 <jle`> @let data Index' as a where IZ :: Index' (a ': as) a; IS :: Index' as a -> Index' (b ': as) a
13:48:10 <lambdabot>  Defined.
13:48:31 <jle`> @let type UniNatTrans as f g = forall a. Index' as a -> f a -> g a
13:48:32 <lambdabot>  Defined.
13:48:37 <jle`> @let untTest2 :: UniNatTrans '[Int,Bool] [] Maybe; untTest2 = \case IZ -> Just . sum; IS IZ -> Just . and
13:48:38 <lambdabot>  Defined.
13:48:46 <jle`> > untTest2 (IS IZ) [1,2]   -- should be an error
13:48:48 <lambdabot>  error:
13:48:48 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘1’
13:48:48 <lambdabot>      • In the expression: 1
13:48:51 <jle`> :)
13:54:04 * jle` . o O ( Index as a ~ Sum (a :~:) as )
13:55:15 <adamCS> jle`: huh?
13:55:26 <jle`> adamCS: cocreature's version is a skolemized version of mine i believe
13:55:28 <butterthebuddha> How do I pattern match something like "E 25 25 str" to get the 25 and 25 out as integers and str out as a string?
13:55:42 <jle`> adamCS: oh, that's the common Sum type
13:55:57 <butterthebuddha> I believe something like num:rest_of_string only pattern matches a single character
13:56:01 <jle`> butterthebuddha: case E 25 25 str of E x y s -> ...
13:56:14 <butterthebuddha> 25 & 25 could be any number
13:56:19 <jle`> yes
13:56:23 <jle`> case myEThing of E x y s -> ...
13:56:28 <jle`> or foo (E x y s) = ...
13:56:38 <jle`> adamCS: it's basically chained Either's
13:56:52 <jle`> adamCS: Sum f [a,b,c] is a sum between f a, f b, and f c
13:57:00 <adamCS> jle`: ah
13:57:18 <butterthebuddha> jle` where "foo" is a function?
13:57:43 <jle`> i'm defining a function called 'foo' there
13:57:47 <butterthebuddha> "parseMessage ('E' x y s)" <- that's giving me an error
13:58:01 <jle`> parseMessage (E x y s) = ...
13:58:36 <butterthebuddha> Yeah but I want to pattern match the character E
13:58:43 <butterthebuddha> It could be a different character
13:59:13 <jle`> oh, are you matching on the actual string?
13:59:17 <jle`> i thought E was a constructor here, heh
13:59:30 <jle`> you can unwords
13:59:30 <butterthebuddha> Nah, the string is something liek "E num num message"
13:59:34 <jle`> i see
13:59:40 <jle`> *words
13:59:56 <jle`> foo (words->'E':x:y:s:[]) = ....
14:00:04 <jle`> that gets x, y, and s as strings
14:00:41 <jle`> > case words "E 25 25 str" of 'E':x:y:s:[] -> (read x, read y, s)
14:00:43 <lambdabot>  error:
14:00:43 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
14:00:43 <lambdabot>        Expected type: String
14:00:53 <jle`> > case words "E 25 25 str" of "E":x:y:s:[] -> (read x, read y, s)
14:00:55 <lambdabot>  (*Exception: Prelude.read: no parse
14:00:56 <butterthebuddha> jThat's giving me an Illegal view pattern error :/
14:01:19 <jle`> ah, sorry, yeah, i was using some syntactic sugar there that's not on by default
14:01:28 <jle`> but you can use 'words' to split that string into its words
14:01:34 <jle`> > words "E 25 25 str"
14:01:35 <lyxia> you aren't using view patterns
14:01:36 <lambdabot>  ["E","25","25","str"]
14:01:49 <jle`> > case words "E 25 25 str" of "E":x:y:s:[] -> (read x, read y, s) :: (Int, Int, String)
14:01:51 <lambdabot>  (25,25,"str")
14:01:52 <lyxia> most likely butterthebuddha's syntax is wrong
14:01:58 <jle`> i used viewpatterns a few lines up
14:02:04 <lyxia> ah
14:02:06 <lyxia> nvm
14:02:12 <ski> > [(x,y,s) | let s0 = "E 25 25 str",("E",s1) <- lex s0,(x,s2) <- (reads :: ReadS Integer) s1,(y,s) <- (reads :: ReadS Integer) s2]
14:02:14 <lambdabot>  [(25,25," str")]
14:02:45 <ski> butterthebuddha ^
14:05:30 <ski> butterthebuddha : .. fwiw, can any of the integers be negative, and are they wrapped in brackets in that case ?
14:06:28 * ski suspects not
14:09:25 <Ebuc> Hello 
14:09:44 <Ebuc> Anybody? 
14:09:53 <lambdabot> Hello.
14:10:11 * Clint pats lambdabot on the head.
14:10:26 <ski> @botsnack
14:10:26 <lambdabot> :)
14:11:38 <Ebuc> Do you know if I have integrated graphics card I can add second monitor to my laptop without lags?
14:11:38 * ski waits to see whether Ebuc has any question
14:11:53 <ski> .. well, a Haskell-related question, perhaps ?
14:11:56 <glguy> Ebuc: Oops, wrong channel. This channel is for the Haskell programming language
14:12:11 <Ebuc> How integrated graphics card work? 
14:12:23 <Ebuc> oh sorry 
14:12:42 <Ebuc> do you know which channel is best for me? 
14:12:48 <ski> perhaps if you join ##graphics, they could suggest a more appropriate channel to ask in
14:12:57 <glguy> Ebuc: This isn't a directory service channel either, actually
14:13:08 <Ebuc> Okay, thanks ski
14:13:15 <ski> or perhaps a channel related to what Operating System you're running
14:13:35 <Ebuc> ok thanks 
14:14:00 <Ebuc> and apologize for my questions 
14:27:22 <cheshircat> Does anyone have a solution for either intero or ghc-mod in a nix shell?
14:31:05 <nitrix> unable to decommit memory: Invalid argument
14:31:31 <nitrix> I'm having a curious problem with GHC on a new system.
14:36:45 <bperez> Trying to get a ghc plugin up and running and having some issues. When I type "ghc --fplugin=MyPlugin" into the command line I get the error: "Module imports form a cycle:   module ‘BindWithLoc’ (./BindWithLoc.hs) imports itself"
14:37:10 <bperez> this seems to happen even with preexisting plugins
14:53:46 <iqubic> hello
14:53:53 <iqubic> Can people see this?
14:54:08 <iqubic> What name does it show for me?
14:54:08 <ChaiTRex> iqubic: Yes.
14:54:17 <ChaiTRex> iqubic: iqubic.
14:54:27 <iqubic> Cool. That's really good
14:54:40 <iqubic> I'm trying out a new irc set-up
14:57:32 <iqubic> So, how does one get started with Emacs' Haskell mode?
14:59:44 <dmj`> iqubic: haskell-mode for emacs has a good readme and wiki
15:00:06 <dmj`> you might still have to pick an indentation mode, but you can get it from elpa / melpa
15:00:07 <iqubic> I'll look at that.
15:00:20 <iqubic> What's an indentation mode?
15:00:42 <nitrix> Is `class Foo c where data Li :: * -> *` valid using TypeFamilies?
15:00:51 <nitrix> https://github.com/iteratee/haskell-tracker/blob/master/Data/Torrent/Bencode.hs#L65
15:00:58 <dmj`> iqubic: http://haskell.github.io/haskell-mode/manual/latest/Indentation.html#Indentation
15:01:06 <nitrix> This is giving me an error but the project seems to indicate it was compiling fine at some point.
15:01:35 <iqubic> Why is it that I can't view the logs for this channel when browsing to this web page? http://ircbrowse.net/browse/haskell
15:01:56 <dmj`> nitrix: that would need to be a data family, which type families should enable 
15:02:02 <dmj`> nitrix: what’s the error?
15:02:15 <iqubic> Is there another place I can look at the logs for this channel, from at least the past week?
15:02:57 <dmj`> iqubic: seems to be a problem with that site, it lost the db connection
15:03:14 <sophiag> ircbrowse has been down for a while
15:03:15 <iqubic> Is there a different site with a better DB connection.
15:03:37 <iqubic> I kinda need to view the logs for the past week or so from this channel
15:04:10 <ChaiTRex> iqubic: Try the tunes.org link in thhe topic.
15:04:27 <ChaiTRex> iqubic: http://tunes.org/~nef/logs/haskell/?C=M;O=D
15:04:41 <dmj`> iqubic: if you use irc cloud app, it can email you logs
15:04:57 <iqubic> I don't
15:05:04 <iqubic> But that should be good enough for me.
15:05:38 <iqubic> Now I just have to remember when it was that I talking about my XMonad config.
15:08:56 <glguy> iqubic: I'd try 2017-04-05.log
15:09:08 <iqubic> Why do you say that?
15:09:35 <iqubic> Ah that seems about right for what I need.
15:09:48 <iqubic> Do All channels keep their logs around?
15:10:01 <ChaiTRex> iqubic: Not all.
15:10:16 <iqubic> Do you think the XMonad channel keeps it's logs around?
15:10:24 <glguy> Youd want to ask in #xmonad
15:11:42 <iqubic> I have, no one's answered yet.
15:37:26 <bvad> I'm trying to implement MonadBaseControl for my transformer stack, but I'm kind of stuck. The problem is shown here: http://lpaste.net/227445533667491840 with comments containing the type errors I'm getting
15:37:47 <bvad> Maybe I'll take that question to #haskell-beginners.. Sorry
15:38:20 <glguy> bvad: #haskell-beginnners is just a different channel altogether; it's not the beginners area of #haskell. This channel is fine
15:38:51 <bvad> glguy: Yeah I figured, but I really do feel like a beginner facing this issue 
15:40:00 <bitonic> Is it possible to include some data constructor but not the type constructor?
15:40:18 <glguy> bitonic: Include? Import?
15:40:32 <bitonic> glguy: yeah, import
15:40:48 * monochrom considers creating #democratic-republic-of-haskell-experts-and-beginners-SPQR
15:40:50 <bitonic> E.g. `import Data.Maybe (Just, Nothing)` (clearly this does not work)
15:41:18 <Rembane> monochrom: Just do it!
15:41:48 <monochrom> I think you can't, I think you have to import the type name as well, because it wants you "Type(DataConstructor)"
15:56:31 <xificurC> tips to using sqlite from haskell? I found 2 options when browsing - persistent and sqlite-simple. Not sure what the general opinion on yesod libs is and if there's another general-purpose DB library I missed
15:58:45 <Hafydd> #democraitc-people-s-republic-?
16:01:30 <pacak> xificurC: It's easy to implement your own version if you want to do strange things.
16:04:48 <lpaste> glguy annotated “Failing to implement MonadBaseControl” with “This type checks - for bad” at http://lpaste.net/227445533667491840#a354784
16:05:32 <lpaste> glguy annotated “Failing to implement MonadBaseControl” with “instance for AppLoggingT” at http://lpaste.net/227445533667491840#a354785
16:05:36 <xificurC> pacak: no strange things, just simple stuff :)
16:06:17 <glguy> bvad: That was supposed to say "- for bvad" but autocorrect ate your name in my browser
16:07:13 <bvad> glguy: everything makes sense now.. Thank you so much!
16:08:18 <glguy> bvad: I've never needed to use that class, so I'm not sure that that's right. You should test that it does what you expected
16:09:22 <bvad> glguy: I think it does, but I'm considering getting rid of the newtype wrapper around LoggingT, it's really just there to avoid an ophan instance of MonadAWS 
16:24:27 <LHoT10820> Okay, I'm not making any progress on this. How can I output C from ghc? Only thing I found suggested I add "--enable-unregisterised" to the config, but it's my first time working in haskell and I have no idea where this config exists if it's something I don't make myself.
16:27:05 <kadoban> LHoT10820: Wait, what are you trying to do? Compile haskell code to C?
16:27:33 <LHoT10820> Yes.
16:27:57 <LHoT10820> Why? No good reason, simply curious.
16:28:06 <kadoban> Don't know if GHC can even do that, IIRC it used to use C as a step in its compilation, but I don't think it even does anymore.
16:28:26 <geekosaur> unregisterised still generates ANSI C
16:28:39 <geekosaur> you need to build ghc with that option
16:28:49 <kadoban> Oh, huh.
16:29:04 <kadoban> I'm surprised that's even still a feature. Is it used for anything internally?
16:29:09 <geekosaur> porting
16:29:15 <kadoban> Ah
16:30:08 <geekosaur> the code it generates isn't very good, so it;s something of a last resort if you can't do something like use -fllvm and keep temporary files so you can copy llvm bytecode over to the target
16:30:09 <LHoT10820> So, I would need to rebuild ghc and have --enable-unregisterised in the ghc build config file. Not anything to do with the file I'm building at the moment.
16:32:27 <LHoT10820> Am I on the right track?
16:38:09 <geekosaur> pretty much
16:39:42 <LHoT10820> Great, thanks geekosaur!
17:46:25 <Sgeo__> Was there any malicious activity in here or anyone pasting in malware signatures? My AV thinks the #haskell logs are malicious
17:47:39 <kadoban> Sgeo__: Someone's quit message a while back included some stuff that seemed designed to trip anti-virus
17:54:49 <c_wraith> I probably shouldn't paste the whole EICAR-STANDARD-ANTIVIRUS-TEST-FILE string in here, right? 
17:56:35 <kadoban> Seems like a bad idea xD
18:07:32 <mrjake> Does anyone have a working emacs config for getting offline haddocks, hlint, etc? 
18:35:00 <sm> http://haskell.hackage.org/package/tweet-hs is great
18:36:06 <Welkin> hackage is down
18:36:06 <sm> and by that I mean http://hackage.haskell.org/package/tweet-hs 
18:36:10 <Welkin> oh lol
18:36:30 * sm attempts to be hackagebot
18:37:23 <sm> oh! hackagebot is here
18:38:06 <sm> but I gave it to a new maintainer. But I failed to shut down the keep-me-up jobs
18:40:41 <sm> fortunately it was polling a special url which had gone away
19:01:23 <siiky> hello haskellers, can someone explain a few things? im defining a class and trying to instanciate it (https://paste.rs/Hpp) but ghci complains about Maybe b not being of general type c
19:01:56 <siiky> shouldnt anything match type c?
19:02:26 <siiky> i havent used haskell in a while and maybe i have a few wrong assumptions
19:03:33 <geekosaur> in this case, c is a type specified by the caller, not by you
19:04:32 <geekosaur> so it ends up working like
19:04:36 <geekosaur> :t undefined
19:04:37 <lambdabot> a
19:05:00 <geekosaur> a type you have no control over and know nothing about, so the only value it can have is bottom/nontermination
19:06:31 <siiky> if c its the type of the value returned by the function, how can it be specified by the caller? it cant be specified
19:07:36 <ChaiTRex> siiky: A lower-case type variable means it can be anything. You're trying to force it to be a Maybed type, which can't be anything, since it can't be a non-Maybed type.
19:07:53 <siiky> and since this is obviously wrong, is there a way to do this? it seems so simple to me, but maybe because im missing something
19:08:09 <siiky> aaah
19:09:06 <dramforever> That's... not how it works
19:09:10 <dramforever> Can you explain in English?
19:09:22 <dramforever> Can you explain what you want to do in English?
19:10:18 <ChaiTRex> It looks like `inject` is `fmap`.
19:10:26 <ChaiTRex> Or the intent of it is `fmap`.
19:10:37 <ChaiTRex> Hmm, not really.
19:10:47 <ChaiTRex> My brain isn't working well this late.
19:11:23 <siiky> what i want inject to do? given a type of this class, i want to change the value inside it (if possible, as with Maybe _ in this example)
19:11:39 <Sornaensis> looks more like `pure x <*` ?
19:11:43 <siiky> or do nothing (as with Nothing in this example)
19:11:49 <Sornaensis> er no
19:11:58 <Habib> Hey, does anyone know why some packages expose a type to be used like (undefined :: Type) instead of just defining a unary constructor, Type?
19:12:10 <Sornaensis> fmap (const x)
19:12:41 <Sornaensis> > fmap (const 5) $ Just 6
19:12:43 <lambdabot>  Just 5
19:13:02 <geekosaur> Habib, generally it's intended to be a type without values, where only the type is important. using undefined for that is actually obsolescent; these days one uses Proxy
19:13:11 <sproingie> Habib: if a constructor isn't exported, you can't pattern match on it, which makes it an opaque type
19:13:23 <sproingie> which makes it "private"
19:13:35 * siiky looking at Functor instance of Maybe
19:14:00 <Habib> geekosaur what do you mean by Proxy?
19:14:23 <geekosaur> https://downloads.haskell.org/~ghc/8.0.2/docs/html/libraries/base-4.9.1.0/Data-Proxy.html
19:14:23 <Sornaensis> siiky: I think you are trying to do something that doesn't make much sense in haskell
19:14:48 <sproingie> @faq can haskell compute nonsense?
19:14:48 <lambdabot> https://wiki.haskell.org/FAQ
19:15:07 <sproingie> aww did i mess that up?
19:15:14 <Sornaensis> :t absurd
19:15:15 <lambdabot> Void -> a
19:15:20 <Sornaensis> ^
19:15:34 <geekosaur> sproingie, the old thing ("Yes!") hasn't existed in some years
19:15:51 <ChaiTRex> siiky: This is one potential solution: http://lpaste.net/354793
19:15:54 <sproingie> absurt (unsafeCoerce 1 :: Void)
19:15:58 <sproingie> *absurd
19:16:37 <sproingie> geekosaur: i've been away a while.  kinda sad to see that one go.
19:16:56 <siiky> Sornaensis: think what im looking for is Functor, at least fmap does exactly what im trying to do with inject
19:17:16 <geekosaur> :t fmap
19:17:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:18:54 <Habib> geekosaur, so Proxy would be used like (Proxy :: Proxy Type), instead of (undefined :: Type)?
19:19:01 <geekosaur> yes
19:19:07 <geekosaur> if that's what they are doing with it
19:19:18 <geekosaur> it's safer than having `undefined` running around loose
19:19:26 <Habib> for more context, I'm trying to set up AES256/CTR encryption https://hackage.haskell.org/package/cryptonite-0.22/docs/Crypto-Tutorial.html
19:19:40 <Habib> The construct just looks ugly, with or without Proxy.
19:19:59 <siiky> ChaiTRex: didnt remember `m a`...
19:20:24 <siiky> but yeah, seems what im looking for is Functor. inject is a special case of fmap
19:20:53 <dramforever> Habib: agreed
19:21:05 <geekosaur> yes, it will, haskell has gained type level features but it'll likely never be pretty
19:21:49 <Habib> I don't understand why it's so important to make it unable to be pattern-matched on
19:22:18 <dramforever> geekosaur: I think in this case just exporting data AES256 = AES256 would be cleaner
19:22:31 <sproingie> same reason as any private data, so it can be changed without breaking APIs
19:22:33 <Habib> dramforever  My thoughts exactly.
19:22:57 <dramforever> If you don't like it: Go -> https://github.com/haskell-crypto/cryptonite/issues
19:23:06 <dramforever> sproingie: but the data isn't used at all
19:23:12 <dramforever> only the type
19:23:23 <sproingie> phantom type maybe.  dunno.
19:23:27 <Habib> Why not just export an aes256 value, and don't export the constructors?
19:23:44 <glguy> Habib: What part are you stuggling with?
19:23:47 <dramforever> But tagging *is* a safe solution IIUC
19:24:09 <Habib> I'm not struggling with using it, I'm just trying to understand why it's necessary to, in my eyes, complicate things.
19:24:17 <glguy> Habib: which part seems complicated?
19:24:44 <Habib> Well, the part where I can't just pass a value in (AES256), and have to pass in undefined where I specify a type (undefined :: AES256)
19:24:51 <glguy> You don't pass an undefined
19:24:59 <sproingie> having to pass in undefined would be a very bad API
19:24:59 <glguy> An AES256 actually is the key
19:25:02 <Habib> Or Proxy, whatever.
19:25:08 <glguy> No, Proxy won't do
19:25:21 <Habib> Well, the tutorial passes in undefined https://hackage.haskell.org/package/cryptonite-0.22/docs/Crypto-Tutorial.html
19:25:25 <sproingie> ew
19:25:30 <Habib> Exactly
19:25:39 <Habib> Specifically, this part: cipherMakeKey (undefined :: AES256) secret
19:25:41 <vaibhavsagar> I would also like to know what to replace this with
19:25:44 <sproingie> undefined shouldn't exist.  it does because it's convenient.  but normally, no.
19:25:58 <Habib> Tell that to the package author.
19:26:01 <glguy> Habib: You get one like this: cipherInit :: ByteArray key => key -> CryptoFailable cipher
19:26:15 <glguy> the key is embedded in the AES256 value assuming it validates
19:26:26 <sproingie> sounds like the tutorial isn't so hot
19:27:29 <Habib> glguy: don't I have to cipherMakeKey first?
19:27:53 <dramforever> There should be better ways of passing in the type...
19:27:57 <Habib> Wait, hold on.
19:28:09 <glguy> Habib: No, I don't think that 'cipherMakeKey' is even defined by the library
19:28:29 <geekosaur> that's defined in place by the example
19:28:42 <Habib> Ah, yeah, so it is.
19:29:02 <Habib> Wow, this tutorial really complicates things.
19:31:03 <glguy> I think that this tutorial might have been written as part of an earlier version of the library and just wasn't updated
19:37:48 <Habib> cipherInit :: ByteArray key => key -> CryptoFailable cipher
19:38:09 <Habib> I'll write a aes256Init :: ByteString -> CryptoFailable AES256
19:38:48 <glguy> like: aes256Init = cipherInit :: ByteString -> CryptoFailable AES256 ?
19:39:39 <Cale> btw, Typeable instances used to do a very similar thing (passing undefined as an argument in order to fix a type parameter)
19:39:40 <Habib> Well, like aes256Init = cipherInit, but just give it a type signature. It'll be a top-level function, so the type signature won't look weird
19:39:46 <glguy> I've since given up on cryptonite and have gone to HsOpenSSL
19:40:24 <Habib> HsOpenSSL seems restricted to OpenSSL “Partial OpenSSL binding for Haskell”
19:41:49 <sproingie> i could see it for Typeable since that's about types at runtime.  why would a crypto lib need undefined?
19:41:54 <glguy> Yeah, it's possible that whatever you were trying to do isn't part of the binding
19:42:08 <glguy> sproingie: No, passing undefined as an argument doesn't help with runtime
19:42:27 <Cale> sproingie: Because it was abusing type classes where it really wanted to be passing around records of functions
19:42:30 <sproingie> well, (undefined :: Foo) does ... kinda
19:42:55 <glguy> Nope, that's just there to help with the type at compile time
19:44:37 <sproingie> compile time makes me think of phantom types.  but i guess i'm still a novice at Evil Type Trickery
19:45:29 <glguy> Yeah, "phantom" types are another example
19:46:35 <AfC> Habib: be aware that if you're trying to make a library that uses (depends on) HsOpenSSL and that is needs to run on multiple platforms you need to jump through some hoops.
19:48:00 <Habib> AfC, I'm using cryptonite for AES256, not HsOpenSSL
19:49:09 <AfC> Habib: ie https://github.com/afcowie/http-streams/blob/master/lib/Network/Http/Inconvenience.hs#L235 
19:49:38 <AfC> Oh, sorry, it was glguy that said they'd gone to HsOpenSSL
19:58:31 <pmn> Obligatory shoutout to Noise (https://hackage.haskell.org/package/cacophony) and NaCl (https://hackage.haskell.org/package/saltine)
20:00:14 <godfreygyz> can anybody explain "((+) . (+)) <$> (*100) <*> (+) <*> (+100) <*> (- 100)" to me pls ?
20:01:25 <Cale> @unpl ((+) . (+)) <$> (*100) <*> (+) <*> (+100) <*> (- 100)
20:01:25 <lambdabot> (((((\ x -> (+) ((+) x)) <$> \ a0 -> a0 * 100) <*> (+)) <*> \ a0 -> a0 + 100) <*> (-100))
20:01:38 <Cale> heh, thought it would do a better job
20:01:54 <Cale> oh, but this (-100) is probably wrong
20:02:45 <Cale> Well, nope, that's not the only problem
20:02:49 <Habib> Take a number, apply (+) to it, which gives us (n +) partially applied. Apply (+) to that, which…
20:03:00 <Habib> Should be a type error, right?
20:03:19 <Habib> (+) expects a number, not a partially applied function.
20:03:21 <godfreygyz> at least :t doesn't complain about it
20:03:25 <MarcelineVQ> not an error exactly, just an instance mess
20:03:29 <monochrom> @type ((+) . (+)) <$> (*100) <*> (+) <*> (+100) <*> (- 100)
20:03:29 <Habib> So that first ((+) . (+)) doesn't typecheck, does it?
20:03:30 <lambdabot> (Num ((a -> b) -> a -> b), Num ((a -> b) -> a), Num (a -> b)) => (a -> b) -> b
20:03:41 <Habib> @type ((+) . (+))
20:03:43 <lambdabot> (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
20:03:47 <Cale> oh, well, :t won't complain, but it will require instances which won't likely exist
20:04:13 <Habib> Lol, Num (a -> a)
20:04:42 <monochrom> instance Num a => Num (Cont r a) where ... :)
20:05:31 <Habib> i mean, what would a sensical definition for (+) look like for functions?
20:05:45 <Habib> that return the same value as they were passed in.
20:05:51 <Habib> Only id does that, right?
20:05:58 <Cale> @let instance (Num b) => Num (a -> b) where fromInteger n x = fromInteger n; (f + g) x = f x + g x; (f * g) x = f x * g x; negate f x = negate (f x); abs f x = abs (f x); signum f x = signum (f x)
20:06:00 <lambdabot>  Defined.
20:06:15 <sproingie> just watched bartosz milewski's videos on category theory and i'm finally starting to get half the shit that's eluded me about haskell for 10 years :)
20:06:18 <Cale> > cos^2 + sin^2 $ 5
20:06:20 <lambdabot>  0.9999999999999999
20:06:54 <Habib> whoaaa
20:07:35 <godfreygyz> completely lost ;(
20:07:44 <sproingie> plus it's awesome when he goes off on philosophical tangents
20:08:16 <Cale> > (((+) . (+)) <$> (*100) <*> (+) <*> (+100) <*> (- 100)) id
20:08:19 <lambdabot>  -10100
20:08:21 <Cale> heh
20:08:57 <Cale> So, we can force it to typecheck, but probably someone meant to write something different than what they actually wrote
20:09:12 <monochrom> I don't think anyone is meant to understand this clearly deliberately obscure code.
20:10:28 <monochrom> Well let's see if it's better if we fix the (- 100) problem.
20:10:32 <Cale> :t ((((+) .) . (+)) <$> (*100) <*> ((+) <$> (+100) <*> (subtract 100)))
20:10:33 <Cale> ((((+) .) . (+)) <$> (*100) <*> ((+) <$> (+100) <*> (subtract 100)))
20:10:34 <lambdabot> Num a => a -> a -> a
20:10:42 <Cale> Possibly they meant to write that
20:10:46 <monochrom> OK that's better.
20:11:32 <Cale> @unpl ((((+) .) . (+)) <$> (*100) <*> ((+) <$> (+100) <*> (subtract 100)))
20:11:33 <lambdabot> (((\ x x0 -> (+) (x + x0)) <$> \ a0 -> a0 * 100) <*> (((+) <$> \ a0 -> a0 + 100) <*> subtract 100))
20:11:37 <sproingie> kids and their new math
20:11:39 <Cale> so close
20:11:42 <Cale> heh
20:13:04 <Cale> anyway (+) <$> (+100) <*> (subtract 100)  is just (\x -> (x + 100) + (x - 100))
20:13:20 <Cale> which is basically (\x -> x + x)
20:13:37 <Habib> which is basically…
20:13:39 <Habib> (+)
20:13:40 <sproingie> but sparklier
20:13:42 <Habib> nice one
20:13:45 <godfreygyz> lol
20:13:46 <Cale> no
20:13:49 <Habib> whoops, meant (* 2)
20:13:53 <Cale> sure
20:13:54 <Habib> late here
20:13:57 <Habib> ;)
20:14:22 <sproingie> i suggest an automated transform for such shiny code :)
20:14:31 <Cale> and then we're passing the same argument to (*100)
20:15:12 <Cale> and adding those things together with another argument
20:15:28 <Cale> So all in all, it amounts to (\x y -> 102 * x + y)
20:15:42 <Cale> But is needlessly convoluted
20:15:45 <sproingie> if that kind of obfu code had some nice 2d visualization...
20:17:23 <Cale> godfreygyz: How much do you know about Monad/Applicative already?
20:17:59 <godfreygyz> I just finished "Function as Applicative Functor" in learn you a haskell for great good
20:18:03 <Cale> ah
20:18:18 <Cale> Well, yeah, this uses the Applicative instance for (->) e
20:18:37 <Cale> For whatever reason, I find it easier to start with the Monad instance
20:18:50 <Cale> and then work out what the Applicative does from there
20:19:24 <godfreygyz> it gives me an example of (+) <$> (+3) <8> (*100)
20:19:35 <Cale> yeah
20:19:54 <sproingie> slot machine code
20:20:10 <Cale> So, in this Monad/Applicative instance, "running" an action means applying it to the argument that the whole function has been applied to
20:20:32 <Cale> do x <- (+3); y <- (*100); return (x + y)
20:20:39 <Cale> Is an equivalent way to write that
20:20:50 <sproingie> that fits way easier into my brane
20:21:19 <godfreygyz> yeah I understand that
20:21:23 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
20:21:25 <lambdabot>  ("hello","olleh","HELLO")
20:21:52 <sproingie> oh neat, named composition steps
20:22:02 <sproingie> self documenting code
20:22:19 <sproingie> (potentially)
20:23:38 <godfreygyz> but what if I want to, say, creating something equivalent to \x -> (x+3) + (x*100) + (x - 50) using applicative
20:24:06 <godfreygyz> in a pattern similar to (+) <$> (+3) <*> (*100)
20:24:59 <Cale> :t (\x y z -> x + y + z) <$> (+3) <*> (*100) <*> (+ (-50))
20:25:01 <lambdabot> Num b => b -> b
20:25:46 <Cale> heh, ragequit? :)
20:25:57 <pacak> @pl  \x -> (x+3) + (x*100) + (x - 50)
20:25:58 <lambdabot> ap ((+) . liftM2 (+) (3 +) (100 *)) (subtract 50)
20:25:58 <godfreygyz> nope
20:26:01 <godfreygyz> accidents
20:26:25 <Cale> > (\x y z -> x + y + z) <$> (+3) <*> (*100) <*> (+ (-50)) $ 17
20:26:27 <lambdabot>  1687
20:26:40 <Cale> > (\x -> (x+3) + (x*100) + (x - 50)) 17
20:26:42 <lambdabot>  1687
20:26:45 <pacak> lambdabot suggests something similar I think
20:26:54 <pacak> just more ugly
20:27:00 <godfreygyz> lol
20:27:01 <Cale> This is exactly the kind of expression which is not aided very much by this Applicative instance
20:27:37 <pacak> > join (*) 4
20:27:39 <lambdabot>  16
20:27:41 <pacak> yuck.
20:28:23 <sproingie> i never did get into applicatives, just sort of dove straight into monads
20:28:39 <godfreygyz> well......then i wonder when would Applicative (r ->) become helpful 
20:29:58 <vaibhavsagar> f <*> g == f x (g x)
20:30:16 <Cale> It's pretty rare to be honest, but it is kind of nice that it lines up perfectly with the SK calculus
20:30:24 <vaibhavsagar> and it's Reader
20:31:39 <godfreygyz> alright then, I think it's kind of useless to me since I have no idea what is SK calculus lol
20:32:13 <godfreygyz> anyway I think I should move into monad 
20:32:21 <vaibhavsagar> https://en.wikipedia.org/wiki/SKI_combinator_calculus
20:32:26 <Cale> Well, yeah, don't worry about it much for now
20:33:09 <godfreygyz> true
20:33:43 <godfreygyz> thx a lot ;)
20:34:04 <Cale> godfreygyz: Sometimes, when you're manipulating a bunch of functions in particular ways, sometimes it's possible to provide a variation or two on <*> and actually build up a useful little language...
20:36:24 <godfreygyz> lol
20:36:56 <Cale> ah, I thought I had a handy example, but I misremembered it, the one I was thinking of was with a composite of Dynamic (for values changing over time) and some Applicative for accumulating validation failures.
20:38:37 <godfreygyz> Cale: How did you learn and practice haskell? I just know learn you a haskell, real world haskell and haskell99
20:38:55 <pmn> check out haskellbook.com
20:39:01 <Cale> I started learning Haskell back in 2001-2002 or so
20:39:13 <Cale> The set of resources available was rather different.
20:39:21 <godfreygyz> true....
20:39:36 <Cale> I learned from a variety of things. One of which was https://www.haskell.org/tutorial/
20:39:51 <Cale> The "Gentle" bit is kind of a lie
20:40:35 <Cale> It leaves a lot out and it's pretty short, but it is a good tutorial nonetheless to get a start on a bunch of ideas.
20:41:33 <godfreygyz> haskellbook.com looks nice
20:41:34 <Cale> I think Graham Hutton's book is pretty good
20:41:38 <godfreygyz> ummmmm
20:41:48 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html
20:42:23 <godfreygyz> hah
20:43:25 <godfreygyz> I saw this one when I was looking up books about haskell in kindle store
20:43:43 <godfreygyz> think im gonna read that latter
20:45:02 <godfreygyz> thx a lot guys ;)
21:16:05 <hsk3> I have built my Haskell web app using Stack. I use Stack's Docker functionality, so the binary will work both locally and on the server.
21:16:06 <hsk3> The question is, what is the best way to deploy the binary + source code to the server?
21:16:30 <hsk3> I can get the source code on to the server, because that's on the GitHub repo
21:16:56 <hsk3> (well, i only need a subset of the code on the server, such as HTML template files etc.)
21:17:30 <hsk3> the question is, how to get the binary to the server
21:17:47 <hsk3> the binary is buried somewhere inside .stack-work
21:17:52 <hsk3> so I wonder if there are best practices here
21:18:07 <Koterpillar> hsk3: copy it out of `stack path --local-install-root`
21:20:39 <hsk3> Koterpillar do i need to worry about relative paths? in other words, how exactly does "stack exec" run the binary?
21:21:02 <hsk3> (i'm wondering if i need to keep that same long path on the server by creating that same folder structure for the binary)
21:25:54 <Koterpillar> no, it runs it in the current directory
21:26:07 <Koterpillar> there are no absolute or relative paths hardcoded into it
21:35:09 <hsk3> Koterpillar so after getting the binary path, it's just a matter of making a script that runs scp for the binary and all other files i need?
21:35:17 <hsk3> (i'm wondering if there's a more standard, recommend way of doing it)
21:35:22 <hsk3> recommended*
21:37:25 <Koterpillar> Yes. I've actually compiled all the templates inside the binary, so I just needed to copy one
21:38:09 <hsk3> Koterpillar nice, how did you compile those into the binary?
21:38:59 <Koterpillar> hsk3: https://github.com/koterpillar/multiblog/blob/master/src/Views.hs#L159
21:41:06 <hsk3> what mechanism here compiles it into the binary? i wonder if the same is possible with Heist
21:41:16 <Koterpillar> TH
21:42:37 <Koterpillar> this might be useful: https://hackage.haskell.org/package/include-file
21:43:28 <hsk3> Thank you!
21:43:35 <hsk3> great stuff
22:39:37 <Lokathor> stack seems to have put "ghc-options:        -threaded -rtsopts -with-rtsopts=-N" in my new project for the testing and exectuable parts
22:39:47 <Lokathor> is this normal? or have i left some old config some place?
22:40:48 <cocreature> Lokathor: that’s normal
22:40:50 <MarcelineVQ> yep very normal
22:41:23 <cocreature> apart from debugging the rts there is very little reason to use the non-threaded rts. and automatically choosing the right number of cores is also a good thing
22:41:53 <Lokathor> oh sure, but sometimes seemingly good ideas magically are bad in Haskell Land
22:42:13 <dfordivam> If I have two Data constructors (D1 :: String -> D1) and (D2 :: String -> D2), and I do serialization of (D1 "text"), then I can construct both D1 and D2 from the bytestring. Is there some way to restrict this so that (decode (encode (D1 "text")) :: D2 is not possible.
22:42:15 <Lokathor> like, "don't use -O2 unless you need to, just use -O, sometimes -O2 makes things slower instead"
22:42:47 <kadoban> Lokathor: If you like you can change your default template, that stuff is all configurable.
22:42:57 <cocreature> dfordivam: what’s the type of encode and decode?
22:43:34 <dfordivam> Lets say I use Data.Serialize or Data.Aeson
22:44:05 <Lokathor> dfordivam, it's probably possible, because once it's passed through "encode" it's the same as any other <whatever text-like data type you encode and decode from>
22:44:09 <cocreature> dfordivam: you probably can’t get "decode (encode (D1 "text")) :: D2" to not typecheck but you can make it fail at runtime during deserialization
22:44:49 <dfordivam> Yes I want the decode to be Nothing / Left ie runtime failure..
22:45:06 <dfordivam> But it is not a runtime failure right now
22:45:21 <cocreature> oh wait decode (encode (D1 "Text")) :: D2 doesn’t even make sense
22:45:26 <cocreature> D2 is a constructor not a type
22:45:37 <dfordivam> I mean if I use the default instances of cereal/aeson library
22:45:49 <dfordivam> data D2 = D2 String
22:46:59 <cocreature> just write a custom instance
22:47:39 <jchia> How can I define Generic instance for Data.Vector.Sized.Vector 3 a that's isomorphic to the Generic instance for (a, a, a)? I'm quite confused about D1, C1, S1, Rec0, etc.
22:47:48 <cocreature> e.g. encode D2 s to {"tag": "d2", "value": s}
22:48:41 <dfordivam> :( I expected the serialization/de-serialization would maintain type info
22:49:17 <cocreature> dfordivam: how should it do that? there could be multiple types called "D2".
22:49:38 <cocreature> now you can add the module info but there can also be multiple modules with the same name containing the same type
22:50:00 <cocreature> adding the package, module and type name would probably be sufficient but at that point the overhead starts to matter
22:50:20 <dfordivam> cocreature: May be I will introduce a tag type in constructor... I dont want to write instances manually
22:50:34 <cocreature> dfordivam: also I’m not quite sure when that would be useful. do you have some minimal example of this?
22:50:54 <cocreature> in most case I would expect that switching to "data D = D1 String | D2 String" is more appropriate
22:55:14 <dfordivam> cocreature:Right this looks the proper way of doing this...
23:12:00 <ArchaicLord> hello, I am here becuase I have been dabbling with tiling mangers. Somone suggested xmonad over i3. I read xmonad needs haskell knowledge which i know nothing about. so wondering if anyone can point in a good direction to get started please
23:16:02 <peddie> ArchaicLord: try #xmonad perhaps -- not sure xmonad needs much haskell knowledge to configure, and it certainly doesn't need any to use apart from configuration :)
23:17:00 <ArchaicLord> ok
23:17:21 <peddie> ArchaicLord: at least I was using xmonad for over a year before I knew how to write "hello world" in haskell
23:40:19 <ArchaicLord> is worth the pain xmonad
23:41:41 <ArchaicLord> I followed a guide to instlal it but the setup on the guide is crap. I wanted to start again but this time learn it so i understand it
23:45:12 <trudyjane> I just used other peoples configs and have been modifying those over time.
23:47:49 <trudyjane> In fact, had to modify my .xmobarrc file tonight because xmonad has been freezing on me lately.
23:48:13 <trudyjane> So far so good...
23:49:13 <peddie> ArchaicLord: I've been using it since early 2008 and barely ever touch the configuration file.  so I guess unless the config file is extremely painful for you, I'd say it's worth it
23:50:55 <hsk3> Are there Haskell packages with multi-word names that use _ instead of - ?
23:50:56 <hsk3> I'm wondering if using _ would break conventions
23:51:47 <Koterpillar> hsk3: https://www.stackage.org/lts-8.11 search for "_" on that page
23:52:13 <hsk3> lol
23:52:38 <hsk3> Koterpillar and for those that produce executable binaries, do those binaries also tend to use - instead of _ ?
23:54:01 <Koterpillar> not sure how to check that, but I think you are right, "-" is more common
23:54:34 <hsk3> cool, thanks
23:55:03 <_sras_> Is there a way to visualize dependencies between various local modules in a stack project?
23:55:33 <_sras_> some thing like `stack dot`,  but for local, user modules?
23:57:37 <cocreature> _sras_: https://github.com/yav/graphmod
23:58:31 <Koterpillar> hsk3: ls /bin | grep - | wc -l -> 947; ls /bin | grep _ | wc -l -> 229
23:58:57 <hsk3> :)
