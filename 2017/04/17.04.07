00:00:01 <cocreature> but then calling it “Non-GC'd, contiguous storage for immutable data structures.” seems confusing
00:00:19 <cocreature> it’s just gced all at once or not at all if I understand this correctly
00:00:53 <wavewave> it's only one-time GCed, i think
00:01:22 <cocreature> I guess I should read the paper at some point :)
00:01:31 <Cale> Oh, interesting
00:01:42 <Cale> Does this thing mean we can serialise IO actions?
00:01:43 <wavewave> when there are no compact pointer remained.  
00:02:10 <wavewave> Cale: does it mean that?
00:02:38 <Cale> oh, apparently not
00:02:48 <Cale> "The object in question must not contain any functions or mutable data; if it does, compact will raise an exception"
00:03:12 <wavewave> ah. yeah. it gives run-time error.
00:03:21 <ski> how about `Handle's ?
00:03:33 <wavewave> for example, if one uses pinned bytearray.
00:03:42 <ski> are they considered mutable here ?
00:03:51 <cocreature> it is still pretty neat to be able to serialize data structures without functions
00:04:11 <cocreature> ski: they contain an mvar somewhere, don’t they?
00:04:21 <cocreature> or am I confusing that with some socket type
00:04:28 <cocreature> nope they do
00:04:32 <cocreature> I doubt that’ll work
00:05:10 <Cale> Yeah, still pretty neat, though one thing I've always thought would be really cool is if a program could "pause" by essentially writing its continuation to disk, and reloading it on next run.
00:06:40 <wavewave> compact region cannot contain thunks.
00:06:53 * ski . o O ( "FPL Marshalling Survey" by Joachim Durchholz in 2004-05-03 at <https://web.archive.org/web/20070706205236/http://durchholz.org/jo/fpl-marshalling-survey/index.html> )
00:07:11 <wavewave> it's kinda alternative to deepseq in terms of evaluation.
00:07:37 <Cale> yeah
00:08:26 <wavewave> I think compact region will have great impact on parallel computing in haskell.
00:10:40 <ski> cocreature : like `exportML' and `exportFn' in SML/NJ at <http://www.smlnj.org/doc/SMLofNJ/pages/smlnj.html> ?
00:10:43 <ski> er
00:10:45 <ski> Cale ^
00:11:00 <peddie> johnw: if I'm not mistaken, slide 37, wrong example for map with an absent key?
00:11:30 <Cale> ski: Yeah, a lot like that :)
00:13:01 <jennyrgb> can I see the definition of a function?
00:13:12 <ski> (also in MLton <http://www.mlton.org/MLtonWorld>. and i believe in some lisp systems)
00:13:25 <jennyrgb> I want to add two patterns for a function in ghci, can that be done?
00:14:21 <Cale> jennyrgb: You can put semicolons between them to smush the whole definition on to one line, or use :{ and :} to make a multiline definition
00:14:38 <Cale> However, if you're making multiline definitions, usually just put that stuff in a file and load it
00:14:57 * ski suspects jennyrgb wants to adapt (extend ?) an existing definition
00:15:05 <Cale> It's really easy to lose the contents of your ghci session, so don't put stuff in there which it would be even mildly irritating to lose
00:15:37 <Cale> oh, extend an existing definition? Not really, though you could define a new function which uses the original one.
00:16:11 <ski> so i suppose the question then is whether open recursion would be required
00:17:34 <ski> jennyrgb : there's no mechanism to adapt a definition in general, nor to see the source. the package docs often has links to source. which function in particular would you like adapted (and how) ?
00:17:51 <tsahyt> I just noticed that maxCommutes from the constraints package is wrong
00:17:53 <tsahyt> https://github.com/ekmett/constraints/blob/master/src/Data/Constraint/Nat.hs#L206
00:18:08 <tsahyt> unless I'm much mistaken
00:18:15 <cocreature> tsahyt: make a PR to fix it :)
00:18:33 <tsahyt> cocreature: Should I just go and make a PR straight away or post it as an issue first?
00:18:49 <cocreature> tsahyt: just go for a PR straight away
00:27:18 <nak> :t runContT
00:27:19 <lambdabot> forall k a (m :: k -> *) (r :: k). ContT r m a -> (a -> m r) -> m r
00:28:30 <nak> so if i had a ContT r Identity a, runContT would return an Identity a ?
00:29:06 <nak> is that normal for monad transformers to return a monad of the transformed type (m) from their run* function ?
00:29:23 <Cale> nak: assuming you gave it a continuation of type (a -> Identity a)
00:29:37 <Cale> yes, that's normal
00:30:05 <Cale> also, don't say "return a monad", because the monad is a type level thing -- they return an action in the monad m
00:30:31 <nak> ok ^^
00:31:09 <Cale> e.g. IO, Maybe, State s, are examples of monads, but getLine, Just 4 and put "hello" aren't.
00:31:10 <nak> Cale i'm lookin at: runCont m k = runIdentity (runContT m (Identity . k))
00:31:22 <Cale> right
00:31:51 <nak> so here I see it's manually handling the runIdentity stuff because runCont is aware of Identity as an implementation detail
00:32:00 <Cale> That's because Cont is defined in terms of ContT, yeah
00:32:27 <nak>  Cont r = ContT r Identity)
00:32:29 <nak> yeah
00:33:49 <nak> ok so ContT handles removing its outer box (in runContT) and the derived monad (Cont) handles removing the inner box (in runCont)
00:33:57 <nak> is this pattern sort of normal too?
00:34:22 <Cale> box?
00:34:26 <phadej> quite common yes, we define `FooT` and `type Foo = FooT Identity`
00:34:51 <nak> cale i just mean the monad container
00:34:56 <nak> sorry i don't know the words very well
00:35:18 <Cale> Are you talking about which data constructor is being pattern matched?
00:36:00 <nak> Cale i guess i' trying to get at the monad transformer *interface*, as some sort of generic template
00:36:47 <nak> Monad is so nicely defined with return and >>=
00:37:17 <Cale> A monad transformer is a type level function of kind (* -> *) -> (* -> *) which, given a monad, produces another monad
00:37:22 <_sras_> Is there any way to stop GHCI from displaying all the loaded modules in repl?
00:37:25 <Cale> and moreover, it has an instance of MonadTrans
00:37:36 <Cale> which provides just a single method called lift
00:37:37 <Cale> :t lift
00:37:39 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
00:38:04 <Cale> lift turns an action in some monad m, into an action in the transformed monad t m
00:38:23 <Cale> and it needs to do this in a way which is compatible with return and bind
00:39:03 <nak> ah MonadTrans is what I was looking for ^_^
00:39:26 <nak> lift . return = return ?
00:39:39 <Cale> Yeah, lift (return v) = return v, and lift x >>= (\v -> lift (f v)) = lift (x >>= f)
00:39:40 <nak> i've never seen (lift . return) on the left of an =
00:39:49 <nak> or (f . g) = ...
00:40:06 <nak> even `lift (m >>= f) = lift m >>= (lift . f)` is confusing
00:40:09 <Cale> Well, this is a mathematical equation which needs to be true, rather than Haskell syntax proper
00:40:21 <nak> ah! so a contract of sorts
00:40:33 <nak> or a law?
00:40:36 <Cale> yes
00:42:17 <Cale> Basically, what it amounts to is that if you take a bunch of actions in the original monad, lift them all separately and put the results together using the monad operations, the result will be the same as if you put them together in the original monad and lift the result.
00:42:18 <nak> is there a reason i'm not seeing an IOT transformer?
00:42:28 <Cale> For a few reasons.
00:43:25 <nak> ah makes sense (re: "Basically, what it amounts to ...") - it reminds me of function composition laws or the regular monad laws. the notation was just screwing with me
00:43:34 <Cale> One is that IO is opaque and implemented in terms of low level hackery, rather than being defined as some sort of free monad with an interpreter.
00:44:32 <_sras_> Is there any way to stop GHCI from displaying all the loaded modules in repl?
00:45:06 <Cale> _sras_: why?
00:45:11 <cocreature> _sras_: :set prompt "> "
00:45:14 <Cale> oh
00:45:26 <Cale> Yeah those modules :)
00:45:27 <cocreature> put that in your ~/.ghci if you want ghci to always behave this way
00:46:14 <Cale> you may also want to set prompt2, which is the prompt used for continuation lines
00:46:38 <nak> Cale: interesting re: IO. how does one go about something like IO (Either e a) then ?
00:47:06 <Cale> EitherT e IO ?
00:47:15 <_sras_> Cale: cocreature Yes.  It works. Thanks guys.
00:47:33 <magthe> any clever way to take the two first values from a list and pass them to a function (foo :: a -> a -> b)? (besides pattern matching)
00:48:16 <nak> Cale isn' Either of IO different than IO of Either ?
00:48:19 <Cale> nak: The other reason is that it wouldn't make a very useful transformer anyway, because running it would be weird
00:48:29 <Cale> It is.
00:48:40 <Cale> Either e (IO a) is quite different
00:49:05 <Cale> newtype EitherT e m a = EitherT { runEitherT :: m (Either e a) }
00:49:24 <Cale> So, internally, an EitherT e IO a action consists of an IO (Either e a) action.
00:49:39 <nak> ... very weird ...
00:49:46 <Cale> Not that weird.
00:50:07 <Cale> This is the only way around that it actually makes sense to define a transformer :)
00:50:29 <Cale> If you try to do it the other way, then in some cases you just wouldn't have an action in the base monad at all.
00:51:05 <nak> ok so like ContT r Identity
00:51:39 <nak> how can i picture them?
00:51:46 <nak> Cont of Identity? or Identity of Cont?
00:52:21 <Cale> I guess both, but only because it's the same as Cont
00:52:28 <Cale> and composing with Identity doesn't do much
00:52:31 <nak> MaybeT Foo => Foo of Maybe? or Maybe of Foo?
00:52:35 <Cale> But otherwise neither
00:53:02 <Cale> ContT r [] a is neither [Cont r a] nor Cont r [a]
00:53:22 <nak> ah right
00:53:41 <nak> does that make ContT exceptional in this regard?
00:53:44 <Cale> and in general you shouldn't expect that to work -- composing monads that way tends not to produce a monad except in fairly special cases
00:54:07 <Cale> However, EitherT and MaybeT both work like that
00:54:54 <nak> interesting. i always thought the transformers were named after the outer type, not the inner type
00:54:56 <Cale> ReaderT and WriterT actually just happen to as well, so I guess it's easy to get misled :)
00:55:29 <Cale> ReaderT affects the outside though, and WriterT affects the result
00:55:52 <Cale> newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
00:56:11 <Cale> newtype WriterT w m a = WriterT { runWriterT :: m (w,a) }
00:56:20 <Cale> (or (a,w))
00:56:36 <Cale> StateT does both:
00:56:50 <Cale> newtype StateT w m a = StateT { runStateT :: s -> m (s,a) }
00:56:52 <jennyrgb> isn't there a reload command for the file I just loaded?
00:56:56 <Cale> :r
00:57:43 <Cale> oops, that w was meant to be an s :)
00:58:11 <Cale> also, while I prefer (s,a) as the order, the mtl and transformers libraries use (a,s), I should probably just be writing it that way :)
00:58:37 <Cale> The reason I prefer (s,a) is that (,) s is itself a functor
00:58:49 <tsahyt> Cale: but what if you want to map over the state
00:58:56 <Cale> heh
00:59:04 <bartavelle> glguy, about the haskeline + commands stuff you showed me last time in your IRC client, it turns out that integrating optparse-applicative into haskeline isn't too hard!
00:59:29 <nak> cale all very useful information thank you :)
00:59:30 <Cale> tsahyt: Then you want (,) to be a functor Hask -> (Hask -> Hask)
00:59:43 <phadej> bartavelle: it isn't; but last time I checked wasn't trivial either
00:59:46 <Cale> tsahyt: and then you can use the resulting natural transformation ;)
00:59:51 <nak> i'm reading a category theory book right now. i'm hoping it helps me with some fundamentals of fp in general
00:59:56 <tsahyt> Cale: I think I'll stick with Bifunctor for practical reasons
01:00:03 <Cale> tsahyt: :D
01:00:25 <Cale> nak: Some for sure.
01:00:57 <bartavelle> phadej, well, the main problem is that the help message very much looks like that of a command line program (go figure), but now I realized that both libraries have auto-complete capabilities, so I'll see if it is easy to use
01:00:58 <Cale> nak: It's a definite sidetrack if your interest is just to be an excellent Haskell programmer.
01:02:23 <Cale> nak: But especially if you have interests in other areas of mathematics as well, it can be very worthwhile, and there's lots of stuff in there which helps to find the "right" definitions when approaching some new area of study.
01:04:48 <phadej> bartavelle: you can modify the optparse-applicative quite a lot, but (last time I checked) not all building blocks were exported
01:04:57 <phadej> e.g. I did tab-completion to editline input
01:05:25 <phadej> but had to copy&paste some internals to run optparse-applicative Parser in pure context
01:05:32 <bartavelle> ah :(((
01:05:54 <bartavelle> I don't really mind running it in IO, this is quick'n'dirty interface
01:05:58 <phadej> but it was in optparse-applicative-0.11 or so time; so I have no idea about current state of affairs
01:06:16 <phadej> bartavelle: IIRC editline tab-completion wants pure function
01:06:34 <bartavelle> alright, that sucks
01:06:58 <bartavelle> thanks for the feedback though!
01:07:28 <phadej> or no, it doesn't make sense; how you could fill the files from the fs
01:07:50 <phadej> completionMatches :: String -> (String -> IO [String]) -> IO (Maybe (String, [String]))
01:08:07 <phadej> maybe the reason was exactly that I don't want the "Usage: ..." printed if match fails
01:08:19 <phadej> sorry, I cannot find my experiments anymore ;(
01:10:47 <bartavelle> np
01:11:47 <jennyrgb> so patterns are matched in the order they're defined?
01:13:52 <cocreature> jennyrgb: yep, the pattern that comes first in a definition/case clause will be tried first and so on
01:25:30 <ph88^> hi guys, can anyone sport opportunities to refactor this code any further? https://bpaste.net/show/f15dc955f7ce
01:28:36 <dysfun> ph88^: you could use 'maybe' from Data.Maybe to shorten it a bit
01:28:54 <dysfun> oh no, it's an Either, so 'either' from Data.Either
01:30:03 <dysfun> ah no, you can't, my mistake
01:33:43 <cocreature> ph88^: you could replace eitherLookup by "maybe (Left errorMessage) Right (HL.lookup key table)" but it’s questionable whether that’s more readable
01:34:41 <cocreature> ph88^: using otherwise in the last case of a case statement is slightly weird. you probably want to use _ here. -Wall will show you that the variable "otherwise" is unused
01:39:00 <doubleleft>     forever (do
01:39:02 <doubleleft>         putStr "λ> "
01:39:03 <doubleleft>         input <- getLine
01:39:05 <doubleleft>         interprete input
01:39:06 <doubleleft>         )
01:39:12 <geekosaur> @paste
01:39:12 <lambdabot> Haskell pastebin: http://lpaste.net/
01:39:22 <geekosaur> please don't paste code into the channel
01:40:02 <doubleleft> sorry, http://lpaste.net/354402
01:41:28 <doubleleft> Why does the action 'putStr "\> " work unexpected ?
01:41:56 <doubleleft> But in ghci it works well
01:42:17 <cocreature> doubleleft: what do you mean by "works unexpected"?
01:43:11 <geekosaur> at a guess, you are in default buffering mode when you compile but ghci runs unbuffered
01:43:14 <doubleleft> I want it will print "\> " before input something but it won't
01:43:23 <geekosaur> hSetBuffering stdout NoBuffering
01:47:12 <adarqui> hey, anyone experiencing this with haskell-persistent: when i store a [Text] array in the db, my strings have an 's' prepended to them. i could just be losing my mind though.. but, before the values go into the db, i dont have an 's' prepended.. in the db i have ["sblah"] .. when i pull the entry out of the db via select etc, it doesn't have the 's' prepended, iget the expected ["blah"]
01:47:21 <doubleleft> geekosaur: thx, it works well
01:49:52 <geekosaur> adarqui, persistent type-tags things it stores. it's not a quick and dirty way to store data that other things can use
01:50:28 <adarqui> ah so, persistent is definitely type-tagging and adding that 's' then
01:50:41 <adarqui> i'll double check the docs but, if that's the case, it makes sense
01:50:56 <adarqui> i've just been trying to figure it out for 30 minutes and started to think, this has to be something with persistent
01:55:51 <geekosaur> I suspect it always uses varchar columns for db storage because database column types don't necessarily map to haskell types, even for "atomic" types. so it needs to tag the data it stores
02:04:04 <adarqui> thanks!
02:42:06 <kuribas> If an operation has O(log n) amortized time, but O(n) worse case, isn't it possible to have worst case repeatedly when reusing the datatype?
02:42:29 <kuribas> Like in not using the modified structure?
02:46:17 <pacak> Depends. O(n) might be caused by having to evaluate a bunch of thunks and even if you ignore modified structure you will still get updates in your original one.
02:46:47 <kuribas> hm right
02:48:05 <jennyrgb> do the haskell project suffer from SJW-ism or is it safe to contribute?
02:48:42 <jennyrgb> gave ghci a look. I'm sure they don't want to refactor it, but there are great improvements to be done without changing the specs
02:49:06 <jennyrgb> if it's hosted on github though, I'm out. Not touching that SJW place ever again.
02:50:51 <pacak> jennyrgb: What would you  improve?
02:51:37 <kuribas> what's SJW?
02:54:51 <jennyrgb> kuribas: first result on google (sjw github) https://github.com/opal/opal/issues/941 we've had massive such spam lately, our bug report system got clogged up with stuff like that
02:55:38 <jennyrgb> kuribas: in the end github decided to remove one of our projects because it had the word "retard" in the comment somewhere in our 10M line of code, so we had to move it all.
02:56:17 <jennyrgb> kuribas: think I'm bullshitting? Maybe that thought should give you an estimate on how crazy it has become.
02:56:27 <kuribas> that's insane
02:57:03 <pacak> jennyrgb: I don't think I saw discussion like that in Haskell projects. But coming back to ghci - what would you improve?
02:57:27 <jennyrgb> there are github users with staff status that does nothing else than ask random projects to add a feminist CoC to their projects.
02:57:54 <zomg> I'm not hugely inclined to think that a project where one of the maintainers uses the anonymous logo as their avatar is particularily impartial on matters such as this
02:58:13 <kuribas> jennyrgb: my rule no 1 is, keep it to technical issues.
02:58:53 <zomg> at least as far as this irc channel goes, I've never seen any big issues with anything like that
02:59:04 <kuribas> jennyrgb: I don't see how it relates to haskell though...
02:59:08 <jennyrgb> good to hear
02:59:21 <kuribas> Most of the people here are friendly and tolerant.
02:59:40 <kuribas> Much more tolerant the me actually :-O
03:00:20 <zomg> a lot of places are tolerant but the way they deal with people perceived to... shall we say push the envelope... is sometimes problematic
03:00:38 <kuribas> I am often surprised in other irc channels
03:00:59 <zomg> the issues I've seen here have always been resolved in a sensible manner which is more than what I can say about some other places
03:01:33 <jennyrgb> I raelly don't care about race, sex, gender, orientation, color, identity, culture or whether someone is a nazi or eat dogs and babies. It has nothing to do with haskell. Problem with SJWs is that they find racism and "problems" in everything though. They used to fill up 70% of the mails in the mailinglists with long threads about changing "problematic" UNIX terminology in Linux such as "kill". Linus just banned them and told them to F off.
03:02:15 <zomg> Linus may be a dick but on that I would agree with him
03:02:16 <zomg> lol
03:02:41 <aidalgol> jennyrgb: you don't happen to have a link handy to that in the archives, do you?
03:02:50 <jennyrgb> off topic, but just a taste https://github.com/nodejs/node/issues/3721
03:03:19 <zomg> lol yeah nodejs is the worst when it comes to this...
03:03:23 <jennyrgb> aidalgol: it's a never ending shitlist https://hacked.com/sjws-trying-frame-linux-creator-linus-torvalds-fake-sexual-assault-charges/ I could talk about this all day :D but I don't want to be ot
03:04:11 <kuribas> zomg: he may be a dick, but it's only when people push him...
03:04:29 <kuribas> zomg: I think his rants are quite funny
03:04:40 * ski . o O ( "The idea of anathematising all of a person’s good works because of something else they said or did .." <https://medium.com/@maradydd/when-nerds-collide-31895b01e68c>)
03:06:05 <zomg> it will be interesting to see what happens with this stuff tbh
03:06:05 <kuribas> jennyrgb: but I think they will appreciate contributions if they are substantial, not just cosmetic...
03:06:33 <zomg> with the nodejs community, there's almost an air of terror there
03:06:49 <zomg> you're constantly being watched for slipping up and someone is compiling a list of it
03:07:06 <zomg> I'm not even joking, I had this done on me, and I know of others too
03:07:23 <zomg> and I'm not even a contributor, just some random guy who was on their irc channel helping people solve their problems :P
03:07:23 <reactormonk[m]> zomg: the internet never forgets?
03:08:04 <zomg> reactormonk[m]: Tolerance-KGB gonna knock on your door
03:08:06 <zomg> :P
03:08:18 <geekosaur> could someone explain to me when this channel became the trump zone?
03:08:53 <zomg> don't get me wrong, I think the ideas are good
03:08:56 <nbro> reading this article "https://wiki.haskell.org/Do_notation_considered_harmful" it says "Newcomers might think that IO is somehow special…" isn’t that true? IO operations are special with respect to other type of computations!
03:09:12 <zomg> it's the people enforcing them who are the problem, just like in any system like that
03:09:14 <aidalgol> oh good, an on-topic question.
03:09:17 <Taneb> nbro, IO is special because it's the type of main
03:09:26 <kuribas> nbro: they are, but do notation isn't
03:09:27 <geekosaur> take the politics elsewhere
03:09:35 <Taneb> And when the program is ran, "main" is what is executed
03:09:44 <Taneb> However, they are semantically values just like everything else
03:09:46 <kuribas> nbro: it's (>>=) and (return) which are special
03:10:10 <Taneb> You can have a list [print 1, print 2] just fine and nothing will be printed
03:10:15 <Taneb> > length [print 1, print 2]
03:10:17 <lambdabot>  2
03:10:24 <kuribas> their implementation is magic
03:10:28 <pacak> Do notation is just a syntactic sugar that gets desugared to Monad or Applicative typeclass.
03:11:12 <reactormonk[m]> mostly Monad. For Applicative, you need the ApplicativeDo language extension.
03:11:23 <Iceland_jack> nbro: Mentally Separate "Monad" / "do-notation" / "IO" and consider the question for each of those
03:11:31 <pacak> That is (>>=) / return / join for Monad or (<*>) / pure for Applicative
03:11:46 <nbro> So I would say the do notation is also special in the sense that it’s a syntactic sugar construct to allow to handle monadiac opeations..
03:12:00 <geekosaur> > do 5
03:12:02 <lambdabot>  5
03:12:09 <geekosaur> not that special...
03:12:17 <pacak> > do (return 5) :: Maybe Int
03:12:19 <lambdabot>  Just 5
03:12:26 <pacak> No IO, but do.
03:12:41 <Iceland_jack> > do (return 5) :: [Int]
03:12:43 <lambdabot>  [5]
03:12:45 <mlehmk> that way IO isn't special
03:12:52 <mlehmk> it's just like Maybe etc.
03:13:14 <nbro> I think the problem now is what we consider special
03:13:15 <nbro> lol
03:13:23 <Iceland_jack> good observation
03:13:34 <pacak> You need IO if you want to launch missiles or feed a cat.
03:13:43 <Alex____> I am pretty new to Haskell, I'd appreciate some help regarding my small question ^^ https://pastebin.com/BLh8HwTD
03:13:59 <kuribas> IO isn't special in that it operates outside of the language, like ($)
03:14:01 <mlehmk> IO could have been called World, as being the state machine
03:14:26 <ski> Alex____ : use `case' rather than `head'
03:14:27 <mlehmk> input output to world state
03:15:05 <pacak> Alex____: pattern match. Or listToMaybe
03:15:34 <kuribas> Alex____: you want find instead of filter
03:15:37 <kuribas> :t find
03:15:38 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
03:16:18 <Alex____> Feels like everyone is saying different things ^^
03:16:45 <geekosaur> pattern match and case are the same thing
03:16:48 <mlehmk> or they are saying the same things from a differen pov
03:16:57 <geekosaur> the others are alternative approaches
03:17:21 <pacak> listToMaybe + filter is the same as find
03:17:29 <kuribas> Alex____: find p = listToMaybe . filter p
03:20:26 <Alex____> You mean like this; https://pastebin.com/pPhN3yuN ?
03:21:17 <pacak> find will give you Maybe
03:21:41 <pacak> so if you want to use that with zip you need to convert it back to list O_O
03:21:53 <pacak> :t maybe [] (:[])
03:21:54 <lambdabot> Maybe t -> [t]
03:22:12 <pacak> Hmmm...
03:22:14 <pacak> :t lookup
03:22:16 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
03:22:33 <pacak> lookup is a slightly specialized find
03:23:06 <pacak> snd $ head $ filter (\(a,b) -> a == startVertex)
03:23:08 <pacak> this is
03:23:16 <pacak> lookup startVertex
03:23:30 <pacak> Just shorter and with less explosions
03:23:38 <pacak> @src lookup
03:23:38 <lambdabot> lookup _key []                      = Nothing
03:23:39 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
03:23:39 <lambdabot>                         | otherwise = lookup key xys
03:24:20 <thomas-oneill> hey I'm wondering where my cabal binaries are going, there's no bin/ in my .cabal/ :s
03:24:35 <oherrala> $HOME/.local/bin ?
03:24:53 <Alex____> pacak: But how do I handle the Maybe value?
03:25:20 <Alex____> Expected type [(Char, a)] Actual type: [(Char, Maybe a)]
03:26:00 <nbro> I’ve just read that arrows are apparently are even a more general concept than monads and that monads in category theory were believed to be equivalent to arrows: https://en.wikipedia.org/wiki/Arrow_(computer_science)… could this be an example where a concept introduced in cs was then adopted in math?
03:26:10 <thomas-oneill> oherrala: I don't have one of those either.
03:26:31 <pacak> Alex____: What kind of list do you expect to see there?
03:27:01 <thomas-oneill> my .cabal/config says my extra-prog-path is $HOME/.cabal/bin but it doesn't exist
03:27:48 <pacak> nbro: Arrows is what you get when you combine Category and Profunctor. I think they are a bit more restricted than Monad
03:28:03 <thomas-oneill> there are some other bindirs but they have $prefix in them, I'm not sure what $prefix is
03:28:10 <pacak> mkdir ~/.cabal/bin
03:28:42 <aidalgol> My Haskell is a bit rusty.  ghc doesn't like the example program in the readme from https://github.com/jaspervdj/websockets
03:28:49 <aidalgol> server.hs:1:1: The function `main' is not defined in module `Main'
03:29:43 <pacak> aidalgol: Which example program? I see server and client. Both seems to be valid
03:29:51 <MasseR> pacak: "server.hs:1:1:"
03:30:18 <aidalgol> pacak: The one that is inline in the readme.
03:30:19 <pacak> But there are no server.hs in repo. There is server.lhs
03:30:26 <aidalgol> MasseR: that's not from the repo
03:30:29 <aidalgol> I mean the filename
03:30:31 <MasseR> oh that's true
03:30:53 <geekosaur> I'm pretty sure that's intended to be loaded into ghci
03:31:04 <aidalgol> The readme has this bit: "The following program echoes messages back after appending meow:" and then what appears to be a complete program.
03:31:08 <aidalgol> geekosaur: ohhhh...
03:31:11 <pacak> aidalgol: One from readme is not a real example
03:31:15 <geekosaur> as noted, it does not define "main" so it is not a standalone program
03:31:59 <Alex____> pacak: What exactly do you mean by, what type of list?
03:32:08 <aidalgol> What does the "LANGUAGE OverloadedStrings" line do?
03:32:26 <pacak> Alex____: Well.. What context will be there? With filter and head it will be at most one element
03:32:47 <pacak> Alex____: If it's only 0 or 1 elements - you don't really need zip
03:33:17 <geekosaur> aidalgol, it lets you not have to wrap literal strings in T.pack to make them valid Data.Text values
03:33:18 <cocreature> aidalgol: OverloadedStrings is an extension that results in string literals having type "IsString a => a" instead of String
03:33:26 <pacak> aidalgol: That allows you to use string literals ("Blah") to define something like Text or ByteString
03:35:36 <kuribas> I am looking at weight balanced kd-tree's.  It appears the balancing can be amortized so insert is O(log n).  I'm surprised there is no literature for this...
03:41:13 <Alex____> pacak: Maybe I am approaching my problem from the wrong way. https://pastebin.com/5cUgULnS
03:41:20 <kuribas> I probably haven't look well enough though...
03:41:24 <Alex____> Or for anyone who could help me
03:41:56 <pacak> > repeat 0
03:41:58 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
03:42:10 <pacak> That gives you infinite list
03:42:13 <pacak> :t (:[])
03:42:15 <lambdabot> a -> [a]
03:42:43 <pacak> That takes one element and gives a list containing just one element
03:43:15 <pacak> Alex____: What exactly are you trying to write?
03:43:39 <k0001> Does anybody know how to write `type family ReverseList (xs :: [k]) = (sx :: [k]) | sx -> xs` respecting the injectivity stated there using `TypeFamilyDependencies`?  
03:43:53 <geekosaur> Alex____, I think the best you can do there is possibly a Monoid constraint and use mempty. But if this is a list of distances, why would a distance be a String?
03:44:05 <Alex____> pacak: Acyclic directed graph, that part should calculate the distance between the vertices
03:44:20 <Iceland_jack> k0001: Not possibly I believe, TypeFamilyDependencies is very restrictive
03:44:23 <Alex____> Or, create a list of it rather
03:45:07 <Alex____> geekosaur: I want the vertices to be able to have strings or numbers as weights
03:45:10 <k0001> Iceland_jack :'(
03:45:43 <Iceland_jack> k0001: This is due to non-covering type synonyms
03:45:52 <Iceland_jack> this will be fixed in the future, probably
03:45:55 <pacak> So... That's collecting all the vertices between points A and B?
03:46:10 <Iceland_jack> Richard Eisenberg just released a pre-print of a paper for constrainted typed families which addresses this
03:46:20 <geekosaur> hm. I think you need Monoid, or pass in a "null" value to use 
03:46:25 <Alex____> pacak: Yes, I mean, I got it working for numbers
03:46:25 <Iceland_jack> sorry, *draft
03:46:33 <Iceland_jack> http://cs.brynmawr.edu/~rae/papers/2017/partiality/partiality.pdf
03:47:04 <geekosaur> hm, no, Monoid doesn't work either because you'd need the Sum newtype. sigh
03:47:23 <geekosaur> I think you'll have to pass in the null weight value to use
03:47:26 <k0001> Iceland_jack: Very nice! Thanks for the pointers! 
03:47:27 <Iceland_jack> Simple injectivity annotations like (type instance ListElem [a] = a) is not actually injective
03:47:49 <Iceland_jack> because of horrible families like (type family Loop where Loop = [Loop])
03:48:11 <Iceland_jack> *Simple type functions like
03:48:40 <Alex____> geekosaur: Hmm, how do I pass in a null value weight?
03:49:17 <geekosaur> add an additional parameter of type a, use it as the parameter of repeat
03:51:59 <osa1> give a package on hackage is there a way to get the full dependency tree? I'm wondering if a package is already a dependency of another package
03:52:03 <osa1> given*
03:56:04 <Alex____> geekosaur: I see what you mean, but what would be the null value? For numbers it would be 0, what would it be for [Char]? Or am I on the wrong path here?
03:56:25 <geekosaur> "" presumably, but it's your algorithm, I presume you know what the weights should be
03:56:44 <geekosaur> (if you don't, you likely have bigger problems than just how to code it)
03:59:39 <geekosaur> osa1, not from hackage, and not that I can see via packdeps.haskellers.com. iirc stack has a 'dot' command that will generate a dependency graph, but you'd have to download the package to use it
04:01:06 <geekosaur> (aside: now I'm wishing more commands had an "apropos" subcommand to search the help text for a particular string/option...)
04:01:39 <osa1> geekosaur: wow stack dot is great. thanks
04:51:42 <jonatan> Might I borrow someone's superior haskell-reasoning in getting a hint about the memory usage of a trial-divison factorization program? https://gist.github.com/CookiesBestDinner/584ef62c06c92c44892dc6f8b045af01
04:52:06 <jonatan> It's doing trial division and I'd like to think it should use near-to-no memory. But it's using 2.5GB for my test-data
04:52:32 <cocreature> jonatan: 2.5gb max residency or 2.5gb allocation?
04:52:43 <jonatan> res, I believe
04:52:58 <cocreature> how are you measuring memory usage?
04:53:01 <jonatan> time -v says res, and my monitor-program-thing climbs
04:53:10 <cocreature> ok
04:53:52 <jonatan> I've tried running the expression that's doing all the work in ghci. THAT doesn't use memory. So .. not sure how to continue my reasoning about it
04:53:53 <cocreature> jonatan: so the first thing you might want to try is explicitely call factorize at type Int
04:54:01 <cocreature> jonatan: GHC defaults to Integer which generally uses more memory
04:54:16 <cocreature> but 2.5gb sounds like a bug
04:54:57 <jonatan> Then I will try that. Though measuring might get trickier with a smaller number.
04:55:24 <cocreature> jonatan: you can run your program with "+RTS -s" and it will tell you max residency
04:55:45 <cocreature> but 999998727899999 is smaller than 2^64 so on a 64bit system you should be fine even with Int
04:56:06 <cocreature> eh I guess it needs to be smaller than 2^63-1 but that’s still the case
04:56:24 <electrocat> cocreature: yeah, Int is signed
04:56:50 <cocreature> jonatan: oh are you using runghc instead of compiling your program?
04:56:51 <Myrl-saki> Where do I read on evaluation of programming languages?
04:56:53 <jonatan> Oh, right. Thought it'd be 32-bit but I suppose that could be machine specific (did some sloppy googling) -- anyway, still uses all that memory
04:57:01 <jonatan> I am!
04:57:04 <cocreature> don’t :)
04:58:09 <jonatan> Yeah, okay. That fixed the memory. But shouldn't ghci then also be using memory?
04:58:10 <cocreature> I get 44,384 bytes max residency which seems quite reasonable
04:58:23 <Aruro> just when stack people wanted to advertise portable scripts
04:59:29 <jonatan> So my bad assumption here was that runghc would be roughly equivalent to ghci.
05:00:05 <Aruro> its not bad assumption, bad to make runghc available :)
05:00:29 <cocreature> jonatan: yeah that’s usually a fairly reasonable assumption afaik
05:00:57 <cocreature> jonatan: if I load that file in ghci and execute ":main" I’m also seeing a lot of memory usage
05:00:59 <Aruro> cocreature: u just said dont :)
05:01:35 <cocreature> Aruro: I said you shouldn’t use it to judge if a program is using too much memory. just like you shouldn’t be using ghci for that
05:01:42 <jonatan> cocreature: yeah me too. But that expression itself doesn't. So.. some kind of memoization-ish thing going on?
05:02:32 <jonatan> Well. Okay. Don't judge based on ghci or runghc. Probably don't use runghc for any substatial amount of computing. Got it. Thanks :>
05:04:00 <cocreature> jonatan: not sure why the expression itself doesn’t use that much memory
05:04:04 <Aruro> is there a library which recompiles binary when there is newer source? for single file scripts
05:04:44 <ph88^> is it possible to combine the IO monad with the Either monad here?  https://bpaste.net/show/10df0bc9339a
05:04:51 <ph88^> so that i can use do notation
05:05:22 <cocreature> jonatan: oh I know why I think. it’s not garbage collecting "potentialFactors" because you might use it in the next iteration.
05:05:51 <cocreature> ah no ignore that
05:05:54 <jonatan> :<
05:06:20 <jonatan> It might just not be important at all - something that isn't promised to me and that I shouldn't rely on. I'm fine with that
05:08:04 <Aruro> ph88^: there is either monad transformer
05:09:54 <merijn> jonatan: Yeah, as a rule of thumb always actually use ghc to compile and then run to benchmark things (ideally using -O or -O2)
05:10:18 <merijn> jonatan: ghci is actually a bytecode interpreter that can't use all fancy optimisation and doesn't produce binary at all
05:10:21 <merijn> Not sure about runghc
05:10:41 <merijn> In most case you probably want to use cabal to build your code anyway :)
05:10:51 <Aruro> are there a lot of fancy optimisations?
05:11:05 <merijn> Aruro: In GHC? Yes
05:11:22 <Aruro> yes in ghc. 
05:12:07 <merijn> pure languages invite lots of optimisation, since it's simpler for the compiler to reason about code
05:12:33 <Myrl-saki> merijn: (imagine if only we had linear types)
05:12:44 <Aruro> i hear only about sream fusion, apparently very important thing
05:12:49 <Aruro> t*
05:12:56 <hpc> this is true to a limited extent in gcc (with const) as well, but haskell's combination of language features is particularly suited to taking advantage of it
05:13:23 <Aruro> what are other important optimisations?
05:14:07 <hpc> having a good garbage collector probably counts as optimization
05:14:14 <merijn> Aruro: So we just finished our compiler lecture and most optimisations discussed are as follows: "here's a neat idea for an optimisation" -> "explain why it becomes unsafe/impossible in an impure language" -> "spend tons of research to determine whether some code is pure enough for said optimisation"
05:14:22 <Aruro> hpc: heh, perhaps
05:14:57 <hpc> ghc's gc competes with java's for the most advanced in a production language
05:15:19 <hpc> merijn: haha
05:15:23 <hpc> sounds about right
05:15:26 <Aruro> gc is not optimisation, its runtime
05:16:13 <Aruro> written in what, c? :)
05:20:09 <Aruro> 50000 lines of c code
05:20:16 <Aruro> sounds like good optimisation to me.
05:43:25 <nh2> phadej: ping
05:49:27 <doomlord> how is Haskell for GPU programming,
05:49:45 <merijn> doomlord: Honestly, not relevant
05:49:58 <doomlord> not relevant in what way,
05:50:05 <doomlord> not relevant to the channel?
05:50:06 <merijn> doomlord: Then again, neither is anything besides CUDA
05:50:23 <doomlord> or are you saying haskell is not a good option
05:50:25 <merijn> doomlord: No, I meant "if you care about GPU performance, don't use haskell (or anything other than CUDA)"
05:50:35 <doomlord> ok fair enough.
05:50:40 <nh2> opencl also works
05:50:48 <merijn> nh2: Honestly not really
05:50:49 <cocreature> and if you don’t care about gpu performance, don’t use gpus :)
05:51:07 <merijn> doomlord: Accelerate seems it might do "ok" if you have regular/dense algorithms
05:51:25 <merijn> doomlord: But if your goal is "squeeze the last bit of performance" I'd skip it
05:51:48 <nh2> merijn: I've built a KinectFusion (3D reconstructon by voxel integration) ported from CUDA to OpenCL so that it runs on Android phones, and it worked
05:51:57 <doomlord> well there is a middle ground, 'getting code in a form that is suitable for GPU stream processing', which will still exceed the CPU
05:52:38 <doomlord> i was just curious if there were libraries out there that attempt to extract expressions from haskell and insert them into GPU kernel code
05:52:49 <merijn> nh2: OpenCL is an incredibly unwieldy language, the portability is questionable (given how buggy most implementations are). OpenCL2.0 is slightly more usable in terms of features, but still lagging behind CUDA, so the only reason would be "portability", except all non-NVidia GPUs are pretty trash in terms of performance, so portability to them isn't very relevant :p
05:52:54 <nh2> doomlord: accelerate works, but there are restrictions. Not the same performance as writing CUDA or OpenCL directly, and it lacks a key feature to keep state on the GPU memory between Haskell IO actions. If you don't need that feature, you can give accelerate a shot
05:52:58 <doomlord> if the haskell language itself gives you the tools to construct such a library
05:53:36 <merijn> doomlord: I don't think such a tool really exists, but mostly because building it would be very time consuming and tedious
05:53:39 <hodapp> nh2: what was your KinFu port to OpenCL & Android?
05:53:50 <hodapp> I was writing one at one point
05:54:12 <nh2> merijn: I agree that opencl is not as ergonomic, but it is more portable simply because most phones dont have nvidia gpus
05:54:44 <merijn> nh2: I'm doing GPGPU from a performance background, and no one is going to run HPC code on phones anyway ;)
05:55:07 <hodapp> plenty of reason to do it there
05:56:18 <nh2> merijn: live 3D scanning and reconstruction on your phone requires GPGPU on your phone, so no choice but opencl there
05:58:08 <buglebudabey> has anyone set up tensorflow for haskell before?
06:00:05 <Athas> doomlord: Obsidian gives you a lot more GPU control than Accelerate.
06:00:49 <Athas> Accelerate is more of a platform-neutral high-performance library.  In principle it can run on many different platforms.  I'm not even sure their GPU/CUDA backend is their best one anymore.
06:02:14 <hodapp> interesting, haven't looked at Obsidian
06:02:31 <nh2> hodapp: I improved the OpenCL version of https://github.com/pamela-project/slambench (which itself is a port from kFusion); later completely rewrote it to use surfel fusion instead of voxels (but that's a different topic)
06:03:46 <hodapp> I had wanted to reimplement KinFu using some kind of spatial subdivision data structure since it was so inefficient with the dense voxels but I never did end up progressing here
06:04:20 <nh2> hodapp: some people did that in their papers, integrating into octrees and reported it worked (but did not publish code)
06:04:45 <hodapp> nh2: OctoMaps and the like?
06:05:38 <doomlord> r.e. 'suitability of haskell' - it seems to me it should be possible to seperate out the code that manages how state sits in GPU buffers, vs passing in lambda functions that specify what operations you perform (e.g. 'what activation function to perform in a neural net', etc)
06:06:00 <nh2> hodapp: doing a quick google it seems that somebody actually did release some code: https://github.com/dkotfis/Octree-SLAM (but that is not the paper I had in mind)
06:06:15 <merijn> doomlord: I think using Haskell as CPU-side boilerplate to call CUDA from would be perfectly reasonable
06:06:40 <hodapp> nh2: ahh, I haven't read that one but I read most of the papers it cited
06:06:46 <doomlord> i guess that sounds similar to how i've used GPUs so far with C++ /OpenCL
06:07:00 <hodapp> it was late 2012, early 2013 that I worked with KinectFusion on a work project
06:07:05 <merijn> doomlord: The only reason I'm not is because I couldn't invest the time to make good library to do that (also, I was worried about the library being slightly unpredictable in terms of runtime, which would mess up my benchmarks)
06:07:09 <Athas> doomlord: Haskell at its core is probably not very suitable.  Lazy evaluation and pointer structures are generally a no-go for GPU performance.  But Haskell is sometimes useful for embedding DSLs, which is what Accelerate takes advantage of.
06:07:25 <nh2> doomlord: that definitely works, I do exactly that with inline-c (which can do C++ too)
06:07:43 <merijn> Athas: Hell, just having a high level Haskell binding around, e.g., CUDA streams would make haskell much nicer to work from than C :)
06:07:59 <doomlord> Athas that makes sense, my hope was 'lazy evaluation' actually means 'a framework or library can choose the best time and place to evaluate something'
06:08:38 <doomlord> i'm really just experimenting and actually building or adapting a library is a valid excercise
06:08:44 <Athas> merijn: definitely; Haskell is good for libraries of all sorts.  It's a great meta-language.  But running Haskell *directly* on a GPU, not a chance.
06:08:53 <doomlord> if i actually needed to get something done, sure i'd just use tried and tested CUDA.
06:08:53 <Athas> Accelerate goes through massive pains.
06:09:00 <nh2> doomlord: IIRC just make sure that if you use multithreading on the Haskell side, do the CUDA part in forkOn so that it runs on the same thread (cuda-malloc and functions that use those buffers running on the same thread)
06:09:02 <merijn> Athas: Sure
06:09:36 <merijn> nh2: I don't think that's required? Pretty sure all main CUDA functions are thread safe
06:10:59 <doomlord> i guess i hoped that with the amount of inference going on with Haskell (comparing the experience to lazy-expression templates/TMP in C++) , you might be able to write sane looking expressions, but which get instantiated intelligently into GPU code.. hence with the lambda-friendly syntax of haskell you'd have something very pleasant to use
06:11:24 <doomlord> zipping buffers together etc
06:11:33 <doomlord> tree-like 2D fold
06:12:03 <nh2> merijn: my knowledge may be outdated; a quick google gives me "However, since CUDA 4.0, multiple CPU threads can share context. You can use cuCtxSetCurrent to tie the context of the kernel to the current thread"
06:12:14 <Athas> doomlord: Haskell is too powerful a language.  Many seemingly-simple expressions are hard to instantiate.  Especially if you want to preserve the lazy semantics.
06:12:34 <Athas> It's worth remembering that GPUs are really bad at control flow, and the main power of Haskell is the ease of powerful control flow.
06:13:48 <nh2> Athas: I don't think doomlord wants to run vanilla haskell; his last message implied to me that he wants to writ eexpressions that happen to infer first-class data types to bring to the GPU, like accelerate does
06:13:52 <doomlord> ok, i just saw the basic functional idea as looking very GPU friendly (applying functions to buffers)
06:14:26 <Athas> nh2: oh, that does work.  But it's still difficult (witness the trouble Accelerate goes through with recovering sharing and handling nested parallelism).
06:14:41 <Athas> doomlord: it definitely is.  functional array programming is a great model for GPUs.
06:14:58 <doomlord> nh2 Athas Correct. i dont want *to port haskell programs to the GPU* .. i'm asking if its possible to utilize haskell as a tool for writing new code that is still *GPU specific*
06:15:22 <Athas> Look at Obsidian.
06:15:23 <merijn> doomlord: Sure, haskell is great for things like "write a DSL that generates GPU code"
06:16:13 <Athas> In my experience, however, embedded DSLs have terrible ergonomics.  Horrible type errors and hard to debug.  Haskell may be the *best* language for such things (maybe excepting Lisp), but it's still not very good IMO.
06:16:42 <nh2> doomlord: the approach you have in mind (e.g. writing `2 * sin 0.5` and having it turn into an inspectable data structure) definitely works. I believe it is simply that people haven't gone all the way to the end to make it totally awesome and ergonomic. E.g. the lack of state in accelerate forbids many great applications, but there is no technical reason for its lack; just lack of developer time so far
06:16:59 <buglebudabey> im trying ti install a package with stack but i'm getting an error saying 'Could not parse '/Users/davidanekstein/.stack/global-project/stack.yaml':
06:17:00 <buglebudabey> InvalidYaml (Just (YamlParseException {yamlProblem = "could not find expected ':'"'
06:17:19 <buglebudabey> anyone know how to address this?
06:17:27 <nh2> buglebudabey: paste that yaml file
06:17:40 <reactormonk[m]> Yeah, looks like a faulty yaml file. I suggest posting it.
06:17:51 <nh2> buglebudabey: probably you forgot a : after a dictionary key
06:18:25 <doomlord> nh2  ok it sounds like 'an open problem', and worth experimenting, I do indeed want to play around with actually constructing such a library.. i'm not here with a problem to solve,looking for a dependable library
06:19:04 <buglebudabey> http://lpaste.net/462994772974370816
06:19:06 <redpoppies> hello, @everyone
06:19:07 <buglebudabey> nh2 ^
06:19:20 <redpoppies> can anyone help with a quick servant problem?
06:19:38 <buglebudabey> nh2 i never wrote this file, it already existed in my stack build
06:19:39 <redpoppies> don't know how to accept an octet-stream body
06:19:46 <nh2> buglebudabey: you need to make a space after "extra-deps:"
06:22:11 <Athas> doomlord: the problem is that libraries like Accelerate can't access the original AST, and some things (e.g. lambdas) have to be represented awkwardly.  It's an open problem indeed, and not an easy one.
06:22:28 <Athas> Other languages use macros to solve the problem, but they have typing issues.
06:22:53 * ski . o O ( typed macros )
06:29:16 <merijn> typed macros, isn't the lame way of saying Typed TH? ;)
06:29:43 <Iceland_jack> Athas: using lambdas isn't very awkward depending on your solution
06:30:15 <Iceland_jack> it's not ideal but things like patterns and cases are worse
06:31:17 <Athas> Iceland_jack: the body of a lambda can be complicated, if it contains further bindings.  E.g., Accelerate requires you to use special functions if you want to have loops.
06:45:09 <sea_wulf> Hey guys, I see the lens library as a dependency in a lot of packages but haven'
06:45:20 <sea_wulf> t gotten around to using it. What's the use case for it?
06:46:21 <kgadek> sea_wulf: it's used as a helper. Esp. in larger programs, it makes accessing/modifying the value of deeply-nested structures quite readable
06:47:23 <Iceland_jack> sea_wulf: More interestingly in my opionion, it takes the vocabulary of Foldable and Traversable and lifts it to much richer structures
06:47:25 <kgadek> e.g. you could write `some_counter += 1` if you are in State monad and you have a `some_counter` lens to access a part of the state
06:49:09 <Iceland_jack> It provides "sumOf" which is a generalisation of Data.Foldable's "sum = sumOf folded"
06:49:40 <Iceland_jack> Which means you can sum the first component of a tuple (sumOf _1), the second (sumOf _2) or both (sumOf both)
06:50:12 <Iceland_jack> > sumOf each (1, 10, 100, 1000)
06:50:15 <lambdabot>  1111
06:50:17 <Iceland_jack> > sumOf each (1, 10, 100, 1000, 10000)
06:50:20 <lambdabot>  11111
06:50:35 <mniip> coercions are erased at runtime, right?
06:50:38 <Iceland_jack> > toListOf each (1, 10, 100, 1000, 10000)
06:50:40 <lambdabot>  [1,10,100,1000,10000]
06:50:53 <sea_wulf> Thanks! That sounds pretty helpful for dealing with not so nice states.
06:50:53 <buglebudabey> thanks nh2, that worked
06:51:23 <mniip> :t folded
06:51:26 <lambdabot> (Applicative f1, Foldable f, Contravariant f1, Indexable Int p) => p a (f1 a) -> f a -> f1 (f a)
06:53:16 <sshine> that certainly isn't abstract!
06:59:56 <Iceland_jack> sea_wulf: If you want, you can even sum "every other" component of a tuple
06:59:59 <Iceland_jack> > sumOf (traversed. Control.Lens.indices even) [1, 10, 100, 1000, 10000, 100000]
07:00:01 <lambdabot>  10101
07:00:12 <Iceland_jack> > sumOf (each. Control.Lens.indices even) (1, 10, 100, 1000, 10000, 100000)
07:00:14 <lambdabot>  error:
07:00:14 <lambdabot>      • Couldn't match type ‘Indexed Integer a (Const (Endo (Endo a)) a)’
07:00:14 <lambdabot>                       with ‘Integer -> Const (Endo (Endo a)) Integer’
07:00:35 <Iceland_jack> Of a list anyway ;)
07:01:16 <sea_wulf> Iceland_jack: Can you sum over arbitrary integer equivalence classes (e.g. [3], [5], ...)?
07:01:38 <Iceland_jack> Can you give me example input / output
07:01:44 <nbro> can we say that JS is like milk for people that do not digest lactose? lol
07:02:16 <Iceland_jack> You can easily write
07:02:16 <Iceland_jack> > sumOf (folded.folded) [[3], [5]]
07:02:18 <lambdabot>  8
07:03:50 <frontendloader> nbro: why you taking shots at JS?
07:04:07 <mniip> ye not like it can defend itself
07:04:14 <nbro> frontendloader: shots, I think, is the right term
07:04:24 <nbro> this should answer your question
07:04:25 <sea_wulf> [1, 10, 100, 1 000, 10 000, 100 000, 1 000 000] over [3] goes to 1 001 001
07:05:24 <sea_wulf> Iceland_Jack: I assume it should look something like sumOf (each. Control.Lens.indices 5) or something
07:05:45 <nbro> JS is the worse language ever created, even my cat I don’t have could have created it
07:05:49 <nbro> *worst
07:06:02 <merijn> nbro: This isn't particularly on topic here
07:06:14 <nbro> merijn: and?
07:06:22 <Iceland_jack> You can write
07:06:22 <Iceland_jack> > sumOf (folded.Control.Lens.indices (\n -> n `mod` 3 == 0)) [1, 10, 100, 1000, 10000, 100000, 1000000]
07:06:25 <lambdabot>  1001001
07:06:26 <nbro> this is irc
07:06:31 <nbro> not stack overflow
07:06:35 <frontendloader> this is #haskell
07:06:39 <Iceland_jack> sea_wulf: That what you want?
07:06:52 <sea_wulf> Hahaha, I should have though of that, thats perfect Iceland_jack
07:07:02 <mniip> nbro, this is a topical channel
07:07:05 <merijn> nbro: off-topic, i.e. not haskell related discussion/conversation should go in #haskell-offtopic
07:07:34 <nbro> ok, I will not further continue this dicussion ;) just take a break(dance)
07:07:53 <Iceland_jack> sea_wulf: the cool part is that it works between list boundaries
07:08:50 <sea_wulf> What, really? So over something such as [[1,2,3],[4,5,6]]? Or am I misinterpreting "list boundaries"?
07:09:04 <mniip> "even my cat I don’t have could have created it" - ex falso quodlibet :p
07:09:23 <nbro> are emoticons on topic here?
07:09:30 <nbro> ahah
07:09:50 <nbro> maybe we need to generalize everything, even arrows
07:09:51 <mniip> no, haskell and haskell accessories only
07:10:18 <Iceland_jack> sea_wulf: I actually forgot how to do that atm
07:10:43 <Iceland_jack> There is a way to do it, some other #haskell denizen will help me out
07:10:43 <Iceland_jack> > toListOf (folded.folded.Control.Lens.indices even) [[0], [1, 2], [], [3, 4, 5]]
07:10:46 <lambdabot>  [0,1,3,5]
07:11:00 <Iceland_jack> I wanted [0,2,4]
07:11:18 <ph88> is that right when i use EitherT with IO that i need to do liftIO to access IO functions ?
07:11:20 <nbro> > map (\x -> x + 1) [1, 2, 3]
07:11:22 <lambdabot>  [2,3,4]
07:11:23 <mniip> > toListOf (folded.Control.Lens.indices even.folded) [[0], [1, 2], [], [3, 4, 5]]
07:11:26 <lambdabot>  [0]
07:11:28 <cocreature> ph88: yes
07:11:31 <mniip> maybe not
07:11:42 <cocreature> ph88: unless they are already written in terms of MonadIO, then it should work out of the box
07:12:00 <nbro> : > do "something"
07:12:05 <sea_wulf> It's cool, I have an internet connection, so I can just google it. Thanks for all hte help Iceland_jack!
07:12:06 <mniip> Iceland_jack, wait, [0,2,4] ?
07:12:12 <mniip> what's the logic behind that
07:12:16 <nbro> > do "something"
07:12:18 <nbro> lol
07:12:19 <lambdabot>  "something"
07:12:48 <Iceland_jack> mniip: Same as flattening the list [0, 1, 2, 3, 4, 5] and picking every other [0, 2, 4]
07:13:04 <mniip> ah
07:13:21 <nbro> you caught in flagrant 
07:13:32 <nbro> *me
07:13:41 <nbro> > do "something else"
07:13:43 <lambdabot>  "something else"
07:13:46 <Iceland_jack> Lens Can Do It®, I just forgot how
07:14:17 <nbro> > do "drugs"
07:14:20 <lambdabot>  "drugs"
07:14:35 <Iceland_jack> nbro: -XMagicHash
07:14:55 <nbro> Iceland_jack: is that the command prompt of a Prolog shell?
07:15:00 <ph88^> cocreature, when i use EitherT and do notation how can i specify what to do (putStrLn) on the Left situation? like on line 5 here https://bpaste.net/show/10df0bc9339a
07:15:09 <itachi> In functor defination "class Functor f where" f should always be able to take one input(parameter) right?
07:15:21 <Iceland_jack> itachi: Yes, its kind should be "Type -> Type" (* -> *)
07:15:44 <itachi> so if f takes zero are more than one input it can not be a functor
07:15:46 <cocreature> ph88^: if you want to react different to Left at different points in your do block, you don’t want EitherT
07:15:56 <cocreature> ph88^: EitherT just exits when it encounters a Left
07:16:17 <Iceland_jack> itachi: Yes, but keep in mind that (Either a) is a Functor
07:16:24 <ph88^> cocreature, is there any other way i can refactor this christmas tree of Left and Right ?
07:16:27 <itachi> thanks
07:16:37 <Iceland_jack> Either itself is (Type -> Type -> Type), so it has to be partially applied
07:16:56 <cocreature> ph88^: sry I have to go, I might be back in a bit
07:17:15 <nbro> > do "a functor inside a tractor"
07:17:17 <lambdabot>  "a functor inside a tractor"
07:17:36 <Iceland_jack> > do do do "bee doo"
07:17:38 <lambdabot>  "bee doo"
07:17:44 <ph88^> ok
07:17:46 <hc_> hi all, i'm looking for some usage examples for ed25519 crypto
07:17:52 <rotaerk> ...
07:18:11 <itachi> One more thing for what functions can we use ":t" type or ":k" kind?
07:18:29 <Iceland_jack> itachi: Explain?
07:18:37 <Gurkenglas> > toListOf (to concat.folded.Control.Lens.indices even) [[0], [1, 2], [], [3, 4, 5]]
07:18:39 <lambdabot>  [0,2,4]
07:19:09 <Iceland_jack> Gurkenglas: eh, I believe it's possible without concat-ing it first
07:19:11 <itachi> What is the basic difference between a type of a function and a kind of a function?
07:19:28 * shapr hops randomly
07:19:30 <shapr> GOOD MORNING!
07:19:34 <mniip> itachi, that doesn't make sense
07:19:37 <shapr> It's a beautiful day for Haskell code!
07:19:38 <mniip> functions don't have kinds
07:19:40 <Iceland_jack> itachi: Functions don't have kinds
07:19:44 <Iceland_jack> Types have kinds
07:19:52 <mniip> the funtion type has a kind however
07:20:19 <rotaerk> :t (+5)
07:20:21 <lambdabot> Num a => a -> a
07:20:32 <itachi> what is a function type?
07:20:36 <rotaerk> :k Num a => a -> a
07:20:38 <lambdabot> error: Not in scope: type variable ‘a’
07:20:38 <lambdabot> error: Not in scope: type variable ‘a’
07:20:38 <lambdabot> error: Not in scope: type variable ‘a’
07:20:51 <Iceland_jack> itachi: (->) is the function type (constructor)
07:21:14 <mauke> itachi: the type of a function :-)
07:21:21 <itachi> ohh so what does "kind" tell us?
07:21:28 <Iceland_jack> Which has the kind ((->) :: Type -> Type -> Type) (please don't correct)
07:21:59 <mauke> itachi: the "type" of a type
07:22:03 <Iceland_jack> itachi: for (->) it tells us you can apply 2 types to it
07:22:14 <mauke> more like you can apply it to two types
07:22:26 <Iceland_jack> ((->) Int) :: Type -> Type
07:22:33 <Iceland_jack> ((->) Int Bool) :: Type
07:22:47 <itachi> k
07:22:54 <Iceland_jack> itachi: This means that (->) and (Int -> Bool) cannot be a Functor
07:22:59 <Iceland_jack> but ((->) Int) can be (and is)
07:24:09 <nbro> > do "hey ya"
07:24:12 <lambdabot>  "hey ya"
07:24:46 <mniip> hc, what do you mean usage examples
07:24:51 <Iceland_jack> itachi: Same with (Either :: Type -> Type -> Type), you can apply it to two types just like (->)
07:25:00 <Iceland_jack> itachi: Does that make sense?
07:25:05 <mniip> I use ed25519 to sign into servers over ssh
07:25:09 <Gurkenglas> Iceland_jack, is there some other application for which the way you want works better than cobbling it together using to?
07:25:13 <itachi> Yup
07:25:36 <itachi> Either :: Type -> Type -> Type takes two types and returns a type?
07:25:42 <Iceland_jack> itachi: yes
07:25:48 <Iceland_jack> Gurkenglas: In this case it doesn't, but once you start using Traversals it starts mattering right
07:26:22 <Iceland_jack> itachi: Can you guess the kind of (,)
07:26:23 <shapr> Has anyone used https://github.com/pfq/PFQ ?
07:26:31 <Gurkenglas> Ah, like doubling every other number in that list of lists
07:26:35 <hc> mniip: specifically, i'm trying to use 25519 crypto with cryptonite... i've gotten as far as generating a DhSecret (https://hackage.haskell.org/package/cryptonite-0.22/docs/Crypto-PubKey-Curve25519.html#t:DhSecret), but I don't know which functions to use for encryption/decryption
07:26:42 <Iceland_jack> Gurkenglas: Yeah
07:26:52 <hc> so i was wondering if there are some usage examples for cryptonite/25519
07:26:53 <itachi> it take two types and returns a tuple?
07:27:07 <ski> god eftermiddag, shapr
07:27:09 <Iceland_jack> Takes two types and returns a type (of tuples)
07:27:15 <shapr> hejsan ski!
07:27:17 <shapr> god morgon!
07:27:23 <Iceland_jack> So same kind as Either: (,) :: Type -> Type -> Type
07:27:43 <itachi> yup makes sense now thank you very much
07:29:20 <hc> mniip: i don't just want to sign/verify payloads, but also encrypt them
07:31:40 <Gurkenglas> > indexing (traverse . traverse) . Control.Lens.indices even *~ 2 $ [[0], [1, 2], [], [3, 4, 5]]
07:31:43 <lambdabot>  [[0],[1,4],[],[3,8,5]]
07:32:40 <Iceland_jack> Ah thanks!
07:32:49 <Gurkenglas> (Found via seeing how itraversed -> traversed was implemented)
07:36:12 <itachi> is there any test library which checks that functor instances I have written is right?
07:37:28 <Iceland_jack> itachi: checkers is used for that (https://hackage.haskell.org/package/checkers-0.4.6/docs/Test-QuickCheck-Classes.html)
07:37:43 <Cale> itachi: Just check that fmap id = id
07:38:05 <erisco> does  fmap (f . g) = fmap f . fmap g  come for free?
07:38:11 <Iceland_jack> itachi: Usually you don't write your own Functor instance
07:38:16 <Cale> Yes, due to parametricity
07:38:33 <itachi> parametricity?
07:39:06 <erisco> Cale, you given given  fmap id = id ? because it is easy to see how an implementation wouldn't hold for that law only
07:39:29 <erisco> you mean given*
07:39:31 <Cale> yeah, given that fmap id = id, it follows that fmap (f . g) = fmap f . fmap g
07:39:34 <Cale> @free (Functor f) => (a -> b) -> (f a -> f b)
07:39:35 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
07:39:42 <Cale> @free fmap :: (Functor f) => (a -> b) -> (f a -> f b)
07:39:42 <lambdabot> Extra stuff at end of line
07:40:00 <Cale> @free fmap :: (a -> b) -> (f a -> f b)
07:40:01 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/Type.hs:(152,17)-(160,45): Non-exhaustive patterns in case
07:40:11 <nbro> > do "do you believe in the law of excluded middle?"
07:40:13 <lambdabot>  "do you believe in the law of excluded middle?"
07:40:16 <Cale> fine, maybe @free isn't as strong as I thought :)
07:40:23 <Cale> @free fmap :: (a -> b) -> [a] -> [b]
07:40:24 <lambdabot> g . h = k . f => $map g . fmap h = fmap k . $map f
07:40:34 <Cale> @free fmap :: (a -> b) -> Maybe a -> Maybe b
07:40:34 <lambdabot> g . h = k . f => $map_Maybe g . fmap h = fmap k . $map_Maybe f
07:40:56 <Cale> Ah, right
07:41:28 <Sornaensis> @premium fmap :: (a -> b) -> [a] -> [b]
07:41:29 <lambdabot> Unknown command, try @list
07:41:37 <Sornaensis> I want some premium theorems
07:41:47 <erisco> @unleaded fmap :: (a -> b) -> [a] -> [b]
07:41:47 <lambdabot> Unknown command, try @list
07:43:02 <Cale> Here, $map_Maybe stands in for a real law-abiding fmap, while fmap was just the arbitrary name that I gave the thing
07:43:06 <Cale> @free f :: (a -> b) -> Maybe a -> Maybe b
07:43:06 <lambdabot> h . k = p . g => $map_Maybe h . f k = f p . $map_Maybe g
07:43:14 <Cale> maybe that'll make it more obvious
07:43:28 <Cale> So, now suppose we pick k = id
07:43:47 <nbro> > do "we like order because we can’t understand otherwise"
07:43:49 <lambdabot>  "we like order because we can\8217t understand otherwise"
07:44:16 <Cale> We get  h = (p . g) => $map_Maybe h . f id = f p . $map_Maybe g
07:45:27 <Cale> If f id = id, then we get  $map_Maybe (p . g) = f p . $map_Maybe g
07:45:34 <nbro> > do "you made it up? oh yes, but that wasn’t that good anyways!"
07:45:36 <lambdabot>  "you made it up? oh yes, but that wasn\8217t that good anyways!"
07:45:43 <Cale> nbro: ???
07:46:23 <nbro> idk
07:46:43 <Sornaensis> Cale do you have a blog where you talk about haskell stuff
07:46:49 <Cale> Sornaensis: no
07:46:57 <Cale> I basically talk about Haskell stuff here.
07:47:15 <Cale> and occasionally on reddit
07:49:19 <Sornaensis> ah
07:51:26 <nbro> can you imagine that h a k?
07:52:19 <Cale> nbro: Please try to remain on topic here.
07:52:37 <nbro> Cale: I will try harder ;)
07:57:03 <nbro> is the only real (ever done) application of <|> to implement parsers in Haskell?
07:57:32 <Cale> Not the *only* one, but pretty close.
07:57:45 <cocreature> it’s sometimes convenient for Maybe
07:58:09 <Cale> Or other monads with nondeterminism
07:59:38 <Cale> You might use it in some cases where you were doing some other sort of combinatorial search
07:59:39 <nbro> can you be more specific of why?
08:00:29 <reactormonk[m]> nbro: ExceptT is also pretty useful.
08:00:30 <Cale> Well, it would typically express a similar thing to what it does for parsers -- combining the possible results of the actions involved.
08:01:03 <Cale> In cases like Maybe, it's just if the first thing is Nothing, you get the second thing
08:01:09 <Cale> > Nothing <|> Just 4
08:01:11 <lambdabot>  Just 4
08:01:15 <Cale> > Just 1 <|> Just 4
08:01:17 <lambdabot>  Just 1
08:01:32 <Cale> > Nothing <|> Nothing
08:01:34 <lambdabot>  Nothing
08:01:56 <Cale> For lists, it's concatenation
08:02:01 <cocreature> > asum [Nothing, Nothing, Just 1, Just 4]
08:02:01 <Cale> > [1,2,3] <|> [4,5]
08:02:04 <lambdabot>  Just 1
08:02:04 <lambdabot>  [1,2,3,4,5]
08:03:33 <Cale> One of my favourite monads is StateT s [], you could specialise s to something like String and then tie your hands a bit about how the state changes to get parsers, but you can also not do that, and use it for search algorithms more generally
08:04:22 <Cale> and so there, you have both state, and a way to select between many different options to try, and <|> gives you the latter
08:04:53 <ongy> I wonder how weird that sentence would be to haskell newbies "my favourite monad is...." 
08:05:27 <nbro> ongy: ahah :D
08:05:52 <dolio> One of my favorite monads is the completion of the rationals to the reals.
08:06:14 <Cale> The completion for metric spaces generally ;)
08:06:26 <cocreature> huh I’ve never thought of that as a monad
08:06:31 <nbro> I proved the language {i, j, k, for i, j, k in N} to be countable by using the fact that the rationals are countable 
08:06:38 <nbro> but ok
08:06:42 <nbro> it’s off-topic
08:06:46 <dolio> Cale: Yeah, good point. I don't like the reals.
08:07:27 <Cale> dolio: Well, also, if you specialise it, I'm not sure there's a way to think of just that one mapping as a monad.
08:07:44 <dolio> Yeah, that's true.
08:08:17 <Cale> It's sort of a trivial monad though, in that join is an isomorphism.
08:08:21 <Sornaensis> monads are really general
08:08:22 * ski . o O ( `MonoMonad' )
08:09:30 <Sornaensis> MonoMonad?
08:10:02 <Cale> hehehe
08:11:36 <Cale> Sornaensis: Like MonoTraversable (which operates on monomorphic containers, who only have some specific type of elements), but for Monad.
08:11:50 <Sornaensis> is that like (>>=) :: m a -> (a -> m a) -> m a ?
08:11:50 <hc> mniip: so basically my problem is how to get the secret key out of the DhSecret class. And I found out I can just convert it to a bytestring or directly pass it to a function accepting a scrubbedbytearray. since the length is 32 bytes i'm going to assume it's the full secret and no other bytes...
08:11:56 <Sornaensis> oh
08:12:15 <Cale> (>>=) :: m -> (Element m -> m) -> m
08:12:26 <Sornaensis> ah
08:12:37 <Cale> Please nobody actually write this
08:12:40 <Sornaensis> lol
08:13:42 <ph88^> does anyone know how i can put errors in a list while checking Either clauses?  https://bpaste.net/show/023ddc62fe47
08:14:03 <ph88^> i like to give the users all the errors back instead of error by error as he fix the mistakes
08:14:04 * ski . o O ( `(>>=) :: forall n. MonoMonad n => m -> (Element m -> n) -> n' )
08:19:02 <lyxia> ph88^: use Writer?
08:19:50 <cocreature> ph88^: but what do you do if you encounter an error? you need the value you get in the case of "Right something" to continue
08:21:51 <nbro> so apparently IO in Haskell was originally implemented using lists...
08:22:00 <Sornaensis> nbro: source?
08:22:02 <cspollard> I wonder if someone here could help me understand how to think about types with shape (m a) which are monoids forall a.
08:22:18 <nbro> Sornaensis: let me think I read it
08:22:31 <cspollard> like Map has mempty = empty and mappend = union
08:23:04 <cspollard> i.e. there is no constraint on a.
08:23:23 <Iceland_jack> cspollard: The canonical example of that are lists: (Monoid [a])
08:23:33 <cspollard> I posted a similar Q on reddit: https://www.reddit.com/r/haskellquestions/comments/63z52o/parameterized_monoids/
08:24:04 <cspollard> yep that's a good example. what if I want to use the monoid instance without referencing the "a"?
08:24:11 <Iceland_jack> cschneid: It is possible
08:24:15 <Iceland_jack> You can use Data.Constraint.Forall
08:24:24 <ph88^> cocreature, if i get any error i return Left, if i didn't get any error i should have all the values
08:24:28 <nbro> https://en.wikipedia.org/wiki/Monad_(functional_programming)
08:24:35 <nbro> "Early versions of Haskell used a problematic "lazy list" model for I/O, and Haskell 1.3 introduced monads as a more flexible way to combine I/O with lazy evaluation."
08:24:46 <cocreature> ph88^: so you want to put all values in a list instead of all errors?
08:24:53 <Iceland_jack> ForallF Monoid [] is the same as (forall a. Monoid [a])
08:24:56 <Iceland_jack> https://hackage.haskell.org/package/constraints-0.9.1/docs/Data-Constraint-Forall.html
08:25:11 <Iceland_jack> It's quite rare that this is useful, but when you need it you need it
08:25:23 <Iceland_jack> an example is (data Box f where Box :: f a -> Box f)
08:25:29 <cspollard> Iceland_jack: thanks. Is there a reason we don't have a type class for this?
08:25:55 <Iceland_jack> cspollard: It shouldn't be its own type class, it's a construction *on* type classes
08:26:00 <Iceland_jack> which is exactly what ForallF is
08:26:03 * ski . o O ( s/Box/Exists/ )
08:26:04 <lyxia> Forall is a bit annoying to use though.
08:26:21 <Iceland_jack> Ideally we would be able to write this as (forall a. Monoid [a])
08:26:27 <cspollard> Iceland_jack lyxia: if you take a look at the reddit post maybe it makes more sense
08:26:48 <cspollard> https://www.reddit.com/r/haskellquestions/comments/63z52o/parameterized_monoids/
08:27:13 <ph88^> cocreature, no i like to put all the errors in a list, and also i would like the syntax to be something like  https://bpaste.net/show/9e790a86b087
08:27:23 <cspollard> Iceland_jack lyxia: it seems to me this is similar to Alternative without any Applicative requirement
08:27:49 <cspollard> Iceland_jack lyxia: and many mapping types don't have Applicative instances
08:27:51 <ph88^> cocreature, so when it hit return in the last line it should check if there are any error in the list and then return   Left [errors, in, list]   otherwise right the return clause
08:28:21 <ski> Iceland_jack : .. did you mean for `Box' to be an existential or a universal ?
08:28:33 <cocreature> ph88^: which list are you talking about?
08:28:43 <ph88^> cocreature, lyxia mentioned WriterT, but how can i make it so that   if an error occurs here (Left situation)   port <- getPort table  that writer puts it in a list ?
08:28:54 <ph88^> cocreature, there isn't a list yet .. i want to make one for the errors
08:28:59 <Iceland_jack> existential
08:29:24 <Iceland_jack> double :: (forall a. Monoid (f a)) => Box f -> Box f; double (Box xs) = Box (xs ++ xs)
08:29:40 <Iceland_jack> (type checking done in my head, assume qualified contexts)
08:29:47 <cocreature> ph88^: sorry I’m still not following. could you name two operations that can return Left and from which you want the errors in a list?
08:29:52 <ski> ok
08:30:51 <ph88^> cocreature, line 9 and line 11 https://bpaste.net/show/9e790a86b087
08:31:38 <cocreature> ah ok so there it actually works because you don’t use "port" in "getDBURI table"
08:31:46 <ph88^> cocreature, if i only have 2 values i check in my config file .. imagine how this code would like like with 30 values
08:32:33 <ph88^> cocreature, yes i don't require to know port when i check the uri .. also i could swap the order around and it doesn't matter
08:33:59 <ph88^> maybe i run all the functions in a list and do a fold to check if there are any Left values ?
08:34:23 <ph88^> hhmm no that's not possible i think, because the function signatures are not the same
08:34:55 <ph88^> [Left "error 1", Right Int, Left "error 2", Right String]  not gonna work i think
08:35:19 <cocreature> ph88^: https://hackage.haskell.org/package/validation-0.5.4/docs/Data-Validation.html#t:AccValidation might be what you are looking for
08:35:25 <cocreature> but it looks like there is no transformer version
08:35:51 <cspollard> Iceland_jack: I'm not sure how to use (forall a. Monoid (f a)) in a class instance declaration
08:36:06 <ph88^> cocreature, ah that looks very interesting !
08:36:08 <Iceland_jack> cspollard: It's not valid syntax yet
08:36:28 <cspollard> Iceland_jack: so is there any reason *not* to define
08:36:28 <cocreature> it seems like you should be able to make a transformer version. I’m not quite sure why there is none
08:36:35 <Iceland_jack> You would have to write it as "ForallF Monoid f"
08:36:37 <cocreature> maybe it violates some laws
08:37:01 <cspollard> class PMonoid m where; pmempty :: m a; pmappend :: m a -> m a -> m a ?
08:37:46 <Iceland_jack> cschneid: If you are okay with Functor as a superclass, you can look into https://hackage.haskell.org/package/semigroupoids-5.0.0.1/docs/Data-Functor-Alt.html#t:Alt
08:37:50 <cspollard> Iceland_jack: this seems like it could be quite useful, but maybe I am missing the bigger Q
08:38:00 <cspollard> Iceland_jack: bigger picture*
08:38:10 <ph88^> cocreature, what would i need a transformer version for ?
08:38:33 <cocreature> ph88^: to be able to combine it with things like IO
08:39:12 <ph88^> cocreature, you mean this?  https://hackage.haskell.org/package/validation-0.5.4/docs/Data-Validation.html#t:ValidationT
08:39:23 <cocreature> ph88^: nah that’s just ExceptT
08:39:36 <cocreature> which for some silly reason is included in this package
08:39:46 <cocreature> https://github.com/NICTA/validation/issues/3
08:39:51 <ph88^> then i don't understand what kind of transformer you mean
08:40:02 <cocreature> AccValidation is the interesting type
08:40:07 <cocreature> and that doesn’t have a transformer
08:41:48 <Iceland_jack> cspollard: This seems like the right use case for ForallF, making your own type class is not a decision you make lightly
08:42:22 <ph88^> cocreature, can i do this with Either?  Validation seems to have bad support for GHC 8 too
08:43:12 <cocreature> ph88^: I don’t think it does. the release on hackage should support GHC 8. it looks like just nobody bothered to close the issue
08:44:04 <ph88^> cocreature, will it be difficult to write a transformer for AccValidation? i never worked with monad transformers before
08:44:13 <cocreature> ph88^: I’m honestly wondering that myself :)
08:44:26 <cocreature> ph88^: if it doesn’t exist I suspect there might be some problems but I haven’t tried it :)
08:45:05 <cspollard> Iceland_jack: ok thanks. I just worry that using these fancier type gymnastics make the code harder to understand and/or maintain.
08:45:19 <cspollard> Iceland_jack: will read up on constraints.
08:45:29 <Iceland_jack> It does, but this honestly doesn't come up /that/ often
08:45:49 <cspollard> Iceland_jack: thanks very much for your help!
08:46:09 <Iceland_jack> all it requires you to do is some \\ instF ... gymnastics to bring Monoid (f a) into scope for some a
08:46:17 <ph88^> cocreature, ok thanks for the help, i will leave the code as a pyramid right now, i'm a bit dissapointed not because of you but i thought this would be easier to do in haskell
08:46:30 <Iceland_jack> No problem, maybe someone has a better solution for ya
08:46:59 <Cale> cspollard: You might consider whether you actually want Alternative, in that particular case
08:47:13 <ph88^> feeling incompetent -___-
08:48:06 <cspollard> Cale: yeah unfortunately there aren't sensible Applicative instances for mapping types, which is primarily what I have in mind
08:48:21 <cspollard> Cale: seems to be a superclass of Alternative in some way.
08:48:46 <nbro> "This is a short tutorial on the state monad. Emphasis is placed on intuition. The types have been simplified to protect the innocent." 
08:48:48 <nbro> "to protect the innocent"
08:48:49 <nbro> ahahah
08:49:03 <Cale> cspollard: ah, okay
08:49:20 <cocreature> ph88^: there is no reason to feel incompetent. there are just some cases that don’t fit into a particular scheme and you actually have to handle the logic yourself (which can involve nesting) instead of relying on some monad instance :)
08:49:33 <Cale> cspollard: Another thing I might consider vs. using constraint hackery is just defining a new type class.
08:49:39 <ph88^> cocreature, one question though .. why do i need it to work with IO ? I don't have IO in the type signature
08:49:55 <cocreature> ph88^: oh indeed!
08:50:02 <cocreature> ph88^: well then you don’t need a transformer version :)
08:50:03 <cspollard> Cale: haha that's what I originally tried, but Iceland_jack thought it was a bit heavy.
08:50:14 <ph88^> ok great :D
08:50:18 <Cale> I would tend to see the constraints stuff as heavier :)
08:50:24 <Iceland_jack> ;) perspective perspective
08:50:42 <cspollard> Cale Iceland_jack: class PMonoid m where; pmempty :: m a; pmappend :: m a -> m a -> m a
08:51:37 <cspollard> Cale Iceland_jack: I'm trying to grok how map types play into this. there's another obvious Monoid instance of maps that requires (Ord k, Semigroup a) => Monoid (Map k a)
08:52:04 <cspollard> Cale Iceland_jack: where mempty = empty; mappend = zipWith (<>)
08:52:29 <ph88^> cocreature, wouldn't a Free monad solve these kinds of things ? i heard Free is like magic
08:52:40 <Cale> cspollard: Also known as "the instance that everyone always wants almost 100% of the time"
08:52:42 <cocreature> ph88^: I don’t see how it would
08:52:47 <Iceland_jack> cspollard: zipWith?
08:52:56 <cspollard> Iceland_jack: uniontWith ;-)
08:52:57 <ph88^> cocreature, just noticed that Free is a dependency of validation
08:53:08 <cspollard> Cale Iceland_jack: but there's something deeper going on here...
08:53:50 <cspollard> Cale Iceland_jack: those two instances seem to correspond to Monoid [a], Monoid (ZipList a)
08:53:54 <Cale> cspollard: Where I work, we have a newtype wrapper of Map, together with a complete module implementing all of Map's operations for the newtype (except some like union which use the old Monoid instance's behaviour)
08:54:28 <cspollard> Cale Iceland_jack: I'm pretty sure someone has thought carefully about this but I'm not sure who ;)
08:54:49 <Iceland_jack> cspollard: (you may be interested in the Alternative for ZipList, that was JUST added)
08:55:10 <Iceland_jack> https://ghc.haskell.org/trac/ghc/ticket/13520
08:55:19 <Iceland_jack> ZL xs <|> ZL ys = ZL (xs ++ drop (length xs) ys)
08:55:23 <cspollard> Cale: the same idea shows up in ekmett's Linear.Vector as liftI2 and liftU2...
08:55:33 <Cale> Iceland_jack: :(
08:55:48 <Iceland_jack> Cale: It's not too late if you disagree
08:55:57 <cspollard> Iceland_jack: yeah but again, no Alternative for maps ;)
08:56:23 <Cale> Iceland_jack: I think it probably ought to be the one which uses Semigroup's (<>) to combine corresponding elements.
08:56:37 <significance> If I write newtype Pair b a = Pair { getPair :: (a,b) }, does newtype just match up the arguments to getPair by type? 
08:56:46 <Cale> Iceland_jack: Then you can recover the instance there by using the First semigroup
08:56:49 <cocreature> ph88^: give me a few minutes and I’m done with my work and I’ll show you a largely pyramid-free version
08:56:52 <significance> What happens if I write newtype Pair a a = Pair { getPair :: (a,a) }?
08:56:58 <robertkennedy> Is WHNF for newtypes the same as the underlying type, or the data constructor for the newtype?
08:57:08 <Iceland_jack> Cale: Not a bad idea
08:57:35 <nshepperd> significance: you can't write 'newtype Pair a a'
08:57:42 <Cale> i.e. it ought to correspond with the Monoid instance everyone would like to have for Data.Map, but can't for purely political reasons
08:57:48 <significance> nshepperd: why is that?
08:58:05 <cspollard> Iceland_jack> Cale: I guess my pmonoid is somehow a "Free Monoid"?
08:58:07 <Cale> (well, not *purely* political -- it would be the ugliest transition ever)
08:58:21 <Cale> cspollard: List types are free monoids
08:58:34 <dolio> No they aren't. :P
08:58:36 <nshepperd> significance: the same reason you can't define an ordinary function with 'f a a = _'
08:58:37 <Iceland_jack> ssh
08:58:38 <cspollard> Cale: yes I'm trying to see how this generalizes to maps
08:58:57 <significance> nshepperd: derp, I'm an idiot -- thank you
08:59:42 <cspollard> Cale: I actually find the current Monoid instance of Map more "fundamental" in a sence
09:00:00 <dolio> Which one is current? Union?
09:00:02 <cspollard> Cale: sense*. it has no Monoid a constraint...
09:00:07 <cspollard> dolio: yes
09:00:24 <Cale> cspollard: The current one can be recovered from the Semigroup-requiring one by picking the First semigroup
09:01:42 <cspollard> Cale: true.
09:02:36 <cspollard> Cale Iceland_jack: I will see where I get... thanks!
09:02:42 <ph88^> anyone know how ApplicativeDo works ? i get an error when i try to use do notation https://bpaste.net/show/87375effab5a
09:02:55 <Iceland_jack> ph88: It is particular about the final expression (can't open bpaste)
09:02:58 <dolio> If only we could make First and Last semigroup-based instead of monoid based.
09:03:17 <Iceland_jack> it has to be of a certain form, (return x) originally and then it gets more permissive in later versions
09:03:21 <nshepperd> is Semigroup a => Monoid a ever going to be in base
09:03:49 <lyxia> ph88^: this code is not applicative
09:03:56 <Iceland_jack> nshepperd: in a few releases I believe (https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid)
09:04:04 <ph88^> lyxia, what's not applicative about it ?
09:04:15 <lyxia> ph88^: you are failing depending on the value of an intermediate computation
09:04:54 <ph88^> lyxia, yes, isn't the do-notation suppose to handle that ?
09:04:56 <dolio> The rules for being applicative are the same as the rules for ordinary 'let' in scheme.
09:05:15 <dolio> If you use something that would only be allowed by let*, it's monad.
09:05:22 <ph88^> i don't know scheme
09:05:40 <lyxia> ph88^: ApplicativeDo doesn't make any code using do work with any Applicative...
09:05:40 <dmwit> ApplicativeDo can't write some Applicative code that you can't write yourself. It's just a syntax sugar.
09:05:42 <nshepperd> Iceland_jack: sweet
09:06:06 <ph88^> lyxia, what's special about this applicative that it doesn't work with do ?
09:07:13 <nbro> just to make sure, the difference between >>= and >> in a monadiac context is that the latter ignores the value of the previous action, right? Or is there any other difference?
09:07:34 <lyxia> ph88^: the last action (AccSuccess or AccFailure) depends on the intermediate value "p"
09:07:35 <Cale> nbro: Nope, x >> y = x >>= const y
09:07:42 <dmwit> ph88^: Have you tried writing this logic with just the Applicative combinators? If not, I encourage you to give it a shot.
09:07:48 <Cale> nbro: I mean "there's no other difference"
09:07:52 <dmwit> ph88^: Like, without do.
09:08:13 <lyxia> dmwit++
09:08:19 <Cale> nbro: However, it's still possible to define (>>) differently in case there's a more efficient way of doing the same thing
09:08:38 <dolio> Alternately, the GHC documentation for ApplicativeDo has examples for which do expressions allow Applicative constraints instead of Monad.
09:08:44 <ph88^> ok dmwit 
09:09:57 <nbro> Cale: what should you example actually represent?
09:10:29 <Cale> nbro: example?
09:10:38 <Cale> nbro: You mean the definition of (>>) there?
09:10:57 <cocreature> ph88^: http://lpaste.net/354404 there you go
09:11:09 <nbro> Cale: x >> y = x >>= const y
09:11:30 <Cale> Yeah, that's a general definition for (>>)
09:11:43 <Cale> you can always expect x >> y to behave the same way as x >>= const y would
09:11:51 <dolio> Some things will override it to be more efficient.
09:11:56 <dolio> But it should still be equivalent.
09:14:27 <cocreature> ph88^: ignore the stubs at the top. I just added those to be able to load it into ghci
09:16:31 <nshepperd> Iceland_jack, Cale: 'SemiGroup a => Monoid (ZipList a)' works, but I don't think that would work for Alternative
09:16:36 <nshepperd> cos of parametricity
09:16:49 <ph88^> thanks a lot cocreature !!
09:17:11 <nshepperd> s/G/g/
09:17:25 <Cale> nshepperd: ah, yes, that's true
09:17:47 <ph88^> i need to take the train but i will try the code this evening
09:18:45 <nbro> ok
09:20:28 <Iceland_jack> nshepperd: right thanks
09:20:29 <ph88^> cocreature, by the way .. https://github.com/NICTA/validation/issues/3#issuecomment-292576113
09:21:16 <cocreature> ph88^: ah thanks. so I wasn’t being stupid in that I didn’t see a _technical_ reason for why there can’t be an AccValidationT
09:22:36 <ph88^> be back later
09:26:31 <itachi> If I am defining a Applicative instance is it also necessay to define a Functor instance for the same function
09:26:32 <itachi> ?
09:28:39 <Cale> yes, but you can use fmap = liftA to define it
09:28:59 <Cale> Also, if you can define a Monad instance, you can get pure = return and (<*>) = ap
09:29:30 <itachi> ap?
09:29:38 <Cale> Control.Monad.ap
09:29:52 <itachi> k
09:29:57 <Cale> ap mf mx = do f <- mf; x <- mx; return (f x)
09:30:09 <itachi> hmm
09:31:39 <Cale> and if you start with the Monad instance, you probably would rather use liftM to define fmap rather than liftA
09:31:48 <itachi> k
09:32:09 <itachi> I was defining applicative instance for data Pair a = Pair a a deriving Show
09:32:21 <itachi> instance Functor Pair where
09:32:34 <itachi>       fmap f (Pair a a') = Pair (f a) (f a')
09:32:38 <Cale> ah, right
09:32:39 * dmwit . o O ( `type Pair a = Bool -> a` )
09:32:46 <itachi> why so I need to use a and a'
09:33:14 <itachi> why can't I use (Pair a a)?
09:33:38 <dmwit> itachi: Would you be okay writing `add a a = a + a`? If not, why not?
09:33:41 <Cale> ... because the two arguments to the Pair data constructor might not be the same? Also, Haskell just doesn't support testing for equality that way.
09:33:56 <dmwit> (And if so, what would you expect it to mean?)
09:34:30 <Cale> @let data Pair a = P a a
09:34:31 <lambdabot>  Defined.
09:34:46 <Cale> @let instance Functor Pair where fmap f (P x y) = P (f x) (f y)
09:34:48 <lambdabot>  Defined.
09:34:58 <Cale> > fmap (*10) (P 2 3)
09:35:00 <lambdabot>  error:
09:35:01 <lambdabot>      • No instance for (Show (Pair b0))
09:35:01 <lambdabot>          arising from a use of ‘show_M555821134055307050519143’
09:35:11 <itachi> when i write Pair a = Pair a a does not in mean that a and a' will be same
09:35:12 <Cale> @let deriving instance Show a => Show (Pair a)
09:35:14 <lambdabot>  Defined.
09:35:16 <Cale> > fmap (*10) (P 2 3)
09:35:18 <lambdabot>  P 20 30
09:35:26 <Cale> itachi: It means they will have the same type
09:35:31 <Cale> That's not the same thing as being the same value
09:35:48 <itachi> Ohhh I always get confused :/
09:36:01 <Sornaensis> :t unsafePerformIO
09:36:03 <itachi> Cale I get you now
09:36:03 <lambdabot> error: Variable not in scope: unsafePerformIO
09:36:24 <Cale> :t System.IO.Unsafe.unsafePerformIO
09:36:26 <lambdabot> IO a -> a
09:36:39 <Sornaensis> O:
09:36:58 <itachi> Thanks
09:37:59 <Banana_> Given foo :: Foo f => f -> IO (), what is the overhead of storing a [IO ()] that are the result of applying a bunches of `f` ?
09:38:59 <dmwit> A few (O(1)) pointers per entry in the list.
09:39:02 <Banana_> I'm assuming the IO () computation in itself is just going to be a shared pointer, but then something is probably captured for that `Foo f => f` ?
09:39:31 <Cale> Banana_: Well, you're also going to store the expressions that the function was applied to
09:39:56 <Cale> If they were already evaluated, then it's the cost of storing the resulting values.
09:40:01 <Banana_> Let me give a better example by bringing ToJSON up. Would it store a bunch of IO computations with a bit of type information to know how to encode said value to JSON?
09:40:13 <Cale> If they weren't it's the cost of storing the thunks which represent those expressions at runtime.
09:40:47 <Banana_> I can expose my original problem to shed some light.
09:41:38 <Cale> Banana_: It's probably going to depend on what state of evaluation things are in, but it may retain a reference to the appropriate instance dictionary
09:41:52 <Banana_> I'm storing various values of different types in a in-memory store using Dynamic for the purpose of caching entities in a game that generates network calls.
09:41:57 <Cale> That's not too bad, because it's not like that's likely to ever be garbage collected in a typical case
09:42:15 <itachi> Do I have to import something to use liftA?
09:42:20 <Cale> Control.Applicative
09:42:50 <ggVGc> itachi: you can use Hoogle for things like that
09:42:54 <Banana_> The problem is that these sometimes need to be sent back over the network encoded as JSON, but this isn't possible since Dynamic looses type information, you need a monomorphic type for the inference to work.
09:43:20 <Banana_> So I was thinking, instead of just storing the Dynamic, I'll store (Dynamic, IO ()), which will include the network call prepared to be sent.
09:43:40 <Cale> Banana_: You could do that, or just (Dynamic, Value)
09:43:41 <itachi> k 
09:43:49 <jasondockers_> what exactly is wrong with this code: https://gist.github.com/anonymous/ecdadd332c874032458c735044b4518a ?
09:44:10 <Cale> Banana_: which would amount to about the same thing, in terms of space
09:44:19 <jasondockers_> syntactically, I guess
09:44:32 <Banana_> Cale: I wasn't able to decouple effects. So back to the question, what's the cost of storing a large amounts of IO () like that?
09:44:46 <Cale> jasondockers_: ([]:_) is necessarily a list of lists
09:44:59 <Cale> jasondockers_: but the type of next says it operates on a list of values of any type
09:45:02 <Banana_> Cale: They're all doing the same operation, just on different `ToJSON a => a` essentially. (And ToJSON is another simplification)
09:45:27 <jasondockers_> Cale, oh, that makes sense. thank you
09:45:37 <sshine> with Hspec, is there a neat way to specify that something must be Right and also propagate a potential Left error to the test output?
09:45:40 <jasondockers_> Cale, I am an oblivious person
09:45:52 <Cale> Banana_: If all you know about something is that it's an instance of ToJSON, then it might as well already be an aeson Value.
09:46:35 <Cale> Banana_: and if you're going to perform the same IO with that Value, there's not a whole lot of either benefit or harm in pre-applying the function to construct the IO action.
09:46:51 <Cale> (it's a constant amount of extra space, and restricts what you can do with it thereafter)
09:47:54 <Banana_> Cale: Since the purpose of that system is an optimization (of the network calls), I feel like I'd be taking a step back if I store the values in cache in a json format. Now I have to pay the cost of unserializing on each lookup to that cache.
09:47:58 <Cale> Banana_: Note that the "might as well already be a Value" there is in part due to the fact that Haskell evaluation is mostly lazy, and will only actually compute the Value once it's needed.
09:48:47 <Cale> Banana_: Even if you were to write it as an IO action, the first time that IO action is performed, the Value inside will get computed and retained so long as the IO action itself isn't GC'ed
09:48:52 <Banana_> Cale: Thing is, json is only only for the communication between client and server, the cache on the client side using Dynamic avoid network calls, but storing Value instead would slow down every lookup again.
09:49:08 <Cale> Why would it be any better with IO ()?
09:49:30 <Banana_> Oh you meant (Dynamic, Value)
09:49:33 <Cale> yes
09:49:35 <Banana_> I thought you mean (Value, IO ())
09:49:41 <Cale> right
09:49:44 <Banana_> Cale: We're on the same page then.
09:49:50 <Banana_> I'll try that, see how it goes.
09:50:18 <Banana_> Cale: Is the resistance agaisn't it because storing lots of IOs is not idiomatic or because it has a serious cost?
09:50:39 <Cale> Banana_: There's not likely to be a serious difference either way
09:50:52 <Cale> and I wouldn't say it's unidiomatic
09:50:57 <Cale> You can do it either way
09:51:03 <Banana_> Style :P
09:51:08 <Banana_> Cale-style :P
09:51:16 <Cale> The Dynamic is the unidiomatic part :)
09:51:31 <abysslurker> I'm looking for some literature on implementing type inference. I'm trying to implement a system which separates constraint generation, from constraint solving. I've read the chapter by Pottier and Remy, but it is not quite clear to me how to turn their trs into an algorithm. Does anyone here have some hints?
09:51:44 <Banana_> Cale: What until you see the Proxys and categories :p
09:51:57 <Cale> Banana_: One thing you might want to further consider is which operations you really need on the things which are stored as Dynamics
09:52:35 <Cale> Banana_: If you can determine that, then you might instead replace that with a record type containing those operations, pre-applied to the given values
09:53:01 <Cale> i.e. an "object" as the industry likes to call them
09:53:05 <Cale> :D
09:53:22 <Banana_> That can't be anything else than Dynamic, promise. They do not have any operation in common, other than being able to be json encoded/decoded, and it seems rediculous to me to do that encoding/decoding on every insert/lookup for an in-memory cache.
09:53:56 <Cale> If all you know about something is that it is possible to JSON encode it, there's no difference between that and Value.
09:54:13 <Banana_> I'll show you the result for feedbacks; I'd be glad to get a different perspective on it.
09:54:40 <Cale> Well, if you prefer, you might like to use:
09:54:59 <Banana_> Cale: Doesn't Value add a cost to convert back to `FromJSON f => f` ?
09:55:22 <Banana_> I'm not sure what Value is, but it's probably some map of key/value of all the fields.
09:55:38 <Banana_> Heck it's probably using some Dynamic mechanic underneath :P
09:55:38 <Cale> Value is just the Haskell representation of JSON
09:55:52 <Cale> It's a simple sum type with constructors for the various bits of JSON syntax.
09:56:25 <Banana_> Cale: That means it wont be parsed of every lookups, but it'll still be decoded :/
09:56:41 <Cale> It might not yet be decoded
09:57:06 <Cale> It might be a chunk of Text with decode applied to it, waiting.
09:57:23 <Banana_> *it'll be decoded on every lookup......
09:57:29 <Cale> lookup?
09:57:37 <Cale> I thought you said there were no other operations :)
09:57:44 <Banana_> Sorry, backtracking.
09:58:02 <Cale> What do you do with the Dynamics?
09:58:23 <Cale> Do you convert them back to their original types and do random things based on what you find?
09:58:29 <Banana_> Cale: If I store Value instead of Dynamic in my cache data structure, wont I have to pay that conversion cost from Value to some `FromJSON a => a` everytime I obtain something from that cache?
09:58:43 <Cale> I don't understand
09:59:08 <Cale> You're certainly never going to convert something of type Value to something of type (forall a. FromJSON a => a)
09:59:49 <Banana_> I do not do dynamic typing introspection stuff; merely using it as a way to get an homogeneous data structure at a small cost than encoding/decoding back to JSON.
09:59:52 <Cale> If you just mean that you're applying a function which polymorphically can use anything of a type which has an instance of FromJSON, then Value is an instance of FromJSON, so no conversion is needed there.
10:00:38 <Cale> You might prefer to use an existential, at least
10:01:21 <Cale> data JSONable where JSONable :: ToJSON a => a -> JSONable
10:01:39 <Banana_> Cale: existential on which type class? They have nothing in common, other than that they can be JSON serialized for when they're sent over the network, that's the very problem.
10:01:59 <Cale> ToJSON of course.
10:02:12 <Cale> But that's basically the same thing as using Value instead, due to laziness.
10:02:21 <Banana_> But every lookup of my cache, I have to decode that json, it's silly.
10:02:30 <Cale> I... I don't understand.
10:02:51 <Cale> What information are you using to do the cache lookup?
10:03:43 <Cale> Dynamic isn't an instance of Ord or anything, so you can't be using that as the key
10:03:51 <Cale> What keys are you using for your cache?
10:04:17 <Banana_> Cale: Fine, let's use a basic `Map Id JSONable`, (assuming JSONable is (ToJSON a, FromJSON a) => a), every lookup from that cache, you have to decode, every insert, you must encode.
10:04:28 <Banana_> Cale: Why are the keys relevant?
10:04:40 <Banana_> Cale: The data structure on its own shouldn't even matter.
10:05:11 <Cale> Because a lookup in a key/value store usually only requires evaluation of the key
10:05:25 <Cale> You don't have to do anything with the value just to do a lookup.
10:05:40 <Banana_> I see. Then yeah, only the key is needed for the lookups. It's some LRU cache.
10:06:26 <Cale> You can pull an unevaluated expression out of the Map, pass it around, shove it into another Map, and stash it somewhere else, without ever actually computing what the expression's value is -- you only need to do that if you pattern match the value somehow.
10:06:41 <Cale> (like when you actually need to serialise it)
10:07:19 <Banana_> Cale: But don't you think it's silly to encode to json and decode it just to have an homogeneous data structure? I know you can just existantial quantification, but you're still introducing a serialization cost that's not needed
10:07:35 <Cale> When though?
10:07:39 <Banana_> And additionally, the ToJSON and FromJSON constraints, which I happen to luckily already have, but normally that'd be a problem too.
10:07:49 <Cale> When do you incur that cost?
10:07:51 <barrucadu> Banana_: Why do you need a homogeneous cache in the first place?
10:07:54 <Cale> You only pay for what you use
10:08:15 <Banana_> barrucadu: Storing all the entities in a game, of various types.
10:08:33 <Banana_> As well as settings, as well as everything in the game.
10:09:01 <Banana_> All are serializable and exchangeable with the server.
10:09:26 <Banana_> They get cached to avoid asking the server the same information twice unnecessarily.
10:10:07 <Banana_> As you move around the world, some information becomes uneeded. Let's say, players, guilds, buildings, monsters, routes, stats, channels, items, so on.
10:10:26 <Banana_> These unloads and gets reloaded again later on if they're needed again. They're all kept in that memory cache under a Dynamic.
10:11:15 <Cale> Okay, what do you do after you fromDyn/fromDynamic the things?
10:11:29 <Banana_> Cale: I use it.
10:12:04 <Banana_> Cale: Since I always know the monomorphic type of what it was and what it will be, it's just merely temporarily stored in cache.
10:12:32 <Cale> okay, so you *do* need arbitrary operations on these values
10:12:40 <Cale> which are specific to their original types
10:12:54 <Cale> Not just conversion to JSON
10:12:59 <Banana_> The only issue, is that when it gets unloaded from the cache, the server gets notified and telling the server about it is a problem, since Dynamic looses type information, so I decided to store an extra IO () with it.
10:13:51 <sshine> using Megaparsec, I get an 'Either (ParseError (Token String) Dec) AST', and I wonder how to pretty-print that ParseError thingy.
10:14:44 <Cale> sshine: Have you tried just printing it? Does it not already prettyprint?
10:14:50 <sshine> ah, parseErrorPretty
10:14:58 <sshine> Cale, nah, its show isn't that nice.
10:15:03 <Cale> parseErrorTextPretty
10:15:40 <Cale> oh, yeah, and that
10:15:55 <sshine> thanks :)
10:25:02 <itachi> Every monad instance also hass a applicative instance right?
10:25:19 <ski> you can easily build one
10:25:30 <itachi> What is a example of an applicative instance which does not have a monad instance
10:25:30 <ski> `pure = return' and `(<*>) = ap'
10:26:01 <Cale> itachi: ZipList
10:26:20 <ski> and with `Monad' now being a subclass of `Applicative', it's enforced that an `Applicative' instance exists, if a `Monad' instance does
10:26:25 <Cale> oh, and there's a more important example now too... Validation
10:26:27 <glguy> itachi: Const
10:26:41 <Cale> and yeah, fine, Const
10:27:09 <itachi> k
10:42:57 <nagyf> Hello everyone, anyone used the SDL binding called sdl2?
10:43:45 <nagyf> I'm trying to run one of it's examples, but I get an error that it cannot find the Paths_sdl2 module
10:46:18 <byorgey> Cale: I think you mean AccValidation
10:47:15 <byorgey> Data.Validation defines both the Validation type (which is isomorphic to Either and has a Monad instance) and AccValidation (which is structurally isomorphic to Either, but the Applicative instance accumulates failures monoidally, and there is no Monad instance)
10:47:50 <zalezd> hey everyone
10:48:38 <ski> hello zalezd
10:48:48 <zalezd> new to coding and im looking for a little help on a code for school 
10:49:09 <c0dehero> zalezd: what's the problem?
10:49:11 <zalezd> I found this site on you tube and decidedxc to try it
10:49:11 <cocreature> zalezd: just ask your question directly :)
10:49:19 <c0dehero> also, starting with haskell?
10:49:28 <c0dehero> that's bold :D
10:49:46 <EvanR> good choice
10:49:51 <zalezd> ok thanks
10:50:31 <zalezd> can i paste a code on here?
10:50:48 <Ferdirand> please no
10:51:10 <cocreature> zalezd: paste on http://lpaste.net/ and then paste the link here
10:52:04 <zalezd> ok thanks
10:54:04 <zalezd> error: A namespace does not directly contain members such as fields or methods
10:54:08 <zalezd> http://lpaste.net/354407
10:54:22 <zalezd> thanks everyone in advance
10:54:31 <cocreature> zalezd: I’m sorry but this channel is about the Haskell programming language
10:54:44 <cocreature> zalezd: that looks like c++
10:55:03 <zalezd> ok can you direct me to a channel for begginers c#
10:55:31 <zalezd> im using Visual Studio 
10:55:39 <EvanR> /join ##csharp
10:55:42 <cocreature> https://stackoverflow.com/questions/3879140/channels-for-java-java-ee-c-asp-net-and-soa suggests ##csharp 
10:56:36 <zalezd> ok thanks everyone!!
10:56:50 <Sornaensis> SOA?
10:57:54 <nagyf> There are some image files that is needed to run my haskell program. I'm using stack as build tool. Is it possible to configure stack to copy these images next to the executable after build?
10:58:01 <dfeuer> glguy: one challenge is figuring out where getting easy reduction is helpful and where it's just confusing.
10:58:45 <dfeuer> For example, incrementing a number always gives a number with at least one bit.
10:59:06 <dfeuer> So should Inc n reduce immediately to hd ': tl, or not?
11:00:31 <zalezd> well no help in the other channel  ##csharp
11:00:44 <EvanR> you have to be patient
11:01:04 <EvanR> on the other hand you could drop c# and do haskell instead!
11:02:25 <zalezd> its for school not much choice
11:02:47 <ongy> and hey, C#8 will probably support pattern matching and record types
11:03:15 <EvanR> well then be patient in ##csharp
11:04:42 <ski> ongy : not variant types, then ?
11:05:32 <c0dehero> zalezd: ....
11:06:05 <c0dehero> i don't know what disappoints me more. that you ask this question in #haskell or that you can't understand the compiler message and google it..
11:06:12 <c0dehero> like ..... come on http://stackoverflow.com/questions/21175781/a-namespace-cannot-directly-contain-members-such-as-fields-or-methods-in-net-r
11:06:22 <glguy> c0dehero: No, that's neither necessary nor on topic
11:07:28 <c0dehero> oh wait, right
11:07:30 <c0dehero> i'm an idiot
11:07:32 <c0dehero> lol
11:08:04 <JuanDaugherty> c# and hs not same thing?
11:08:21 <JuanDaugherty> TIL
11:09:27 <EvanR> well theres apparently a functional style for c#
11:09:50 <EvanR> haskell is that influential
11:10:04 <dfeuer> You can write  pretty much anything functional-style, but it can be pretty hard.
11:10:29 <JuanDaugherty> haskell is just the major player in something it hardly started and prolly won't finish
11:10:31 <c0dehero> sry zalezd
11:11:04 <JuanDaugherty> just the most popular kid
11:11:23 <monochrom> No, I think it's Erik Meijer who is the influential one.
11:11:29 <dfeuer> Functional-style Postscript might not be that much harder than any other structured Postscript; those few Postscript programmers out there are already used to handling environments manually...
11:11:41 <dfeuer> monochrom: huh?
11:11:52 <JuanDaugherty> thing is when a lang or pkg get's that it never completely goes away until the adherents age out
11:12:00 <JuanDaugherty> *gets
11:12:15 <monochrom> to explain why C# supports functional style.
11:12:36 <dfeuer> Ah.
11:19:07 <zalezd> almost got it!!
11:19:18 <zalezd> still working on it!
11:20:09 <c0dehero> zalezd: nice. you know that you have mismatched braces, right?
11:21:24 <zalezd> yes 
11:21:39 <zalezd> only one error left
11:22:06 <c0dehero> okay
11:24:28 <tobiasBora> Hello,
11:24:53 <tobiasBora> Is there any way to install a stack project systemwise ?
11:25:14 <earldouglas> If I cabal install with --enable-coverage, then copy the binary onto another machine, no .tix file is generated when I run it.  Is there something environmental I need to do on the second machine to enable coverage?
11:25:17 <tobiasBora> I could manually copy the exec file, but I was looking for a "proper" install
11:28:01 <earldouglas> Strike that; I am able to generate the .tix file after all.
11:34:30 <significance> It seems pretty easy to implement foldr for lists (i.e. with type (a -> a -> a) -> a -> [a] -> a) recursively -- how might I implement foldl similarly?
11:35:00 <glguy> You'd also implement it recursively
11:35:08 <significance> glguy: Would my basecase be the same?
11:35:19 <significance> i.e. foldr _ [] s = s?
11:35:40 <glguy> yeah
11:36:05 <significance> how might I pattern match for the rightmost element of a list?
11:36:12 <glguy> You wouldn't
11:36:16 <monochrom> Cannot. And do not.
11:36:18 <glguy> (and can't)
11:36:30 <glguy> foldl and foldr both process the list from beginning to end, left to right
11:36:56 <Cale> It is physically impossible to process a list in any other order.
11:37:01 <significance> ahh, got it -- thank you!
11:37:02 <EvanR> its a simple matter to process a list from right to left, first reverse it
11:37:06 <monochrom> foldl will require you to think a bit differently from foldr
11:37:22 <Cale> Of course, reversing it will process it from left to right :D
11:37:50 <EvanR> but it doesnt make sense to process an infinite list starting from the end
11:37:50 <Cale> But that's not what foldl does
11:38:05 <Cale> (it doesn't need to reverse anything)
11:38:10 <EvanR> so it really is an asymmetric situation
11:38:32 <Cale> The r and l refer to the manner in which the expressions are associated into a tree, rather than the order in which they occur from left to right
11:38:52 <Cale> foldr's tree leans to the right, while foldl's tree leans to the left
11:39:00 <Cale> but the leaves are in the same order that they occurred in the list
11:39:41 <monochrom> reverse is actually a special case of foldl. You may or may not be able to draw inspiration from this.
11:39:58 <Cale> reverse = foldl (flip (:)) []
11:40:06 <Cale> id = foldr (:) []
11:43:01 <significance> thank you all!
11:46:37 <hc> hi, looking at https://hackage.haskell.org/package/scotty, why are some of the version numbers displayed in green?
11:46:52 <hc> what's the semantics behind this? :)
11:47:44 <geekosaur> https://hackage.haskell.org/package/scotty/preferred
11:47:52 <JuanDaugherty> build state looks like
11:47:55 <geekosaur> although I'd arguye orange and green should be swapped there
11:47:59 <hc> another question, anyone here who maintains scotty? the example in the readme looks like it's got an xss problem
11:48:00 <MarcelineVQ> hc: click the info link at the end of the versions :>
11:48:02 <hc> geekosaur: thanks
11:52:23 <hc> another question about scotty (https://hackage.haskell.org/package/warp-3.2.9/docs/Network-Wai-Handler-Warp-Internal.html#t:Settings): is it possible to limit the maximum size of uploaded files per http request?
11:52:42 <hc> (i don't see it in the list of settings)
12:02:18 <nagyf> :R
12:02:24 <nagyf> oops
12:06:39 <tobiasBora> Hello,
12:07:18 <geekosaur> world!
12:30:24 <WarmCookie> Hi. Is it possible to have a MINIMAL definition for a type class that says `If A is implemented, then so must be B` ?
12:33:57 <byorgey> WarmCookie: no, it's not.  You only get logical conjunction and disjunction.  There is no way to express implication.
12:34:32 <byorgey> Can you give an example of a situation where you would want it?
12:36:14 <byorgey> hmm, but can't you just add B as another conjunct in every disjunct where you would want A?    So if you had   A,D | A,C | C   you would change it to   A,B,D | A,B,C | C
12:37:57 <EvanR> isnt class A a => B a where implication (though backwards)
12:38:09 <byorgey> Hmm, yes, in fact, you can express any truth table using only AND + OR, so anything you could possibly want to express can be expressed already
12:38:15 <lyxia> it somehow works out because classes are finite
12:38:23 <merijn> WarmCookie: You can use and/or for specifying minimal sets
12:38:24 <byorgey> it might not be as concise as if you had an implication operator but you can do it.
12:38:41 <cocreature> EvanR: that’s implication on the class level. MINIMAL is about the definitions in a single class
12:39:07 <EvanR> oh i dont know what MINIMAL is
12:39:27 <merijn> EvanR: A pragma to indicate the minimal complete definition of an instance
12:39:32 <dolio> byorgey: How do I write NOT using AND + OR?
12:39:39 <merijn> EvanR: So "== OR !=" for Eq
12:39:56 <merijn> EvanR: because of default definitions :)
12:40:11 <WarmCookie> byorgey: I'd like it be so that {-# MINIMAL storeCreate, storeRead, storeUpdate, storeDeleted, Optionally(storeInit, storeQuit) #-}
12:40:32 <EvanR> if its optional, wouldnt minimal be just not implementing it
12:40:35 <byorgey> dolio: oh, duh, I'm wrong, aren't I.
12:40:39 <dolio> :)
12:41:06 <cocreature> WarmCookie: what are the semantics of Optionally here?
12:41:43 <WarmCookie> cocreature: Where this type class requires these 4 methods, and possibly two more methods if you chose to implement either storeInit or storeQuit.
12:41:51 <byorgey> maybe it means you can implement both or neither, but you can't just implement one of them?
12:42:07 <WarmCookie> byorgey: That's the goal, yes.
12:42:12 <glguy> WarmCookie: The purpose of the minimal pragmas is to avoid circular definitions because of default implementations
12:42:14 <byorgey> yeah, you can express that but it's going to be annoying: you have to write  A,B,C,D,E,F | A,B,C,D
12:42:17 <cocreature> that seems weird
12:42:21 <byorgey> i.e. you have to duplicate the four required methods
12:42:33 <cocreature> byorgey: that still won’t stop you from implementing only one method
12:42:41 <WarmCookie> byorgey: I was hoping for something nicer but I'll roll with that.
12:42:49 <byorgey> cocreature: oh, you're right, it won't.
12:42:59 <cocreature> the first part is completely redundant
12:43:14 <byorgey> WarmCookie: ignore me, cocreature is right, that doesn't work
12:43:28 <byorgey> I agree this seems weird.
12:43:45 <cocreature> WarmCookie: you got me interested. how can you make default definitions that break if you implement only one of them?
12:45:53 <WarmCookie> cocreature: In my case, the methods have effects using IO and am worried it could leave the remote resource in an inconsistent state.
12:46:28 <WarmCookie> Granted this is something that has to be robust anyway, I was just wondering if I could "express my intention" to people implementing the type class.
12:46:48 <WarmCookie> *their instance
12:46:53 <glguy> WarmCookie: What you could do is to make one of your class methods a tuple of two things
12:47:03 <arpl> Hello. New to Haskell. (From C/Asm) I find the paradigm shift interestingly challenging ... which is always a good thing : )
12:47:03 <arpl> I will have questions about using the language too, but I would like to ask a question now about how people who write a substantial project start the process.
12:47:03 <arpl> When setting up a project, do Haskellers generally start with an 'algorithmic structure' or rather with 'data modelling'? I have a feeling the latter (but of course that is not what you see in learning materials about the language). If it is indeed the latter, how do you prevent being over-specific? And in what way do you get the most from the help the type system has to offer?
12:47:19 <glguy> storeInitQuit :: (StoreInitType,StoreQuitType)
12:47:37 <WarmCookie> glguy: That's a great idea.
12:47:43 <glguy> now you can write some helpers for: fst storeInitQuit and  snd storeInitQuit
12:48:15 <cocreature> arpl: definitely the latter for me. I usually just define a few data types and then the type signatures of the main functions in my program and only then I start implementing them and thinking about the more fine grained control flow
12:48:22 <merijn> glguy, WarmCookie: Better yet, don't have separate init/quit but use a bracket pattern
12:49:07 <merijn> arpl: I'd say it depends on the problem
12:50:22 <WarmCookie> It's more intricate than that I fear. I will catch any problem during the operations; but I'd like each new data store implementation added to the project to consistently have the same interface, where if one data store decides to take the responsibility for initializing resources, it should also deinitialize them.
12:50:42 <WarmCookie> glguy: No need, the library will be the only one calling these methods internally :)
12:51:38 <merijn> WarmCookie: Are you familiar with bracket?
12:52:07 <WarmCookie> merijn: Yes. There's resource acquisition, use, and release.
12:52:36 <WarmCookie> But it's a pattern that works for expressions; not to encode or enforce your intentions in regards to the interface of a type.
12:52:39 <merijn> WarmCookie: Right, so wouldn't that avoid the entire "implemented acquistion but skipped release" issue by putting them in one definition?
12:53:23 <merijn> WarmCookie: I'm not sure I see why not? But it depends on the details of what you're doing, I suppose?
12:53:41 <WarmCookie> Probably. I think glguy's suggestion is as good as it gets.
12:54:18 <WarmCookie> byorgey: cocreature `a, b | a, b, c` doesn't work?
12:54:35 <cocreature> WarmCookie: that’s equivalent to a,b
12:55:01 <WarmCookie> Ah it's reductible. I see.
12:55:21 <cocreature> it’s the minimal set of definitions. not all possible combinations.
12:55:51 <WarmCookie> Do we have a {-# COMPLETE #-} :P ? 
12:56:10 <cocreature> I don’t think so :)
12:56:18 <WarmCookie> Ignoring my use case, I think it could be useful.
12:57:17 <cocreature> I’m not convinced tbh but I haven’t thought about it long enough to make a convincing argument for why this is not needed :)
12:57:19 <WarmCookie> cocreature: merijn glguy byorgey Much appreciated. Thanks for the help and warm support.
13:02:11 <arpl> cocreature, merijn: Thanks. And that is of course the problem with a question like that ... it depends : )         Specifically I was thinking about modelling a disk. Which (with LBA access) is just a list of sectors numbered from 0 to some maximum (or even infinity). But not all sectors are the same with regard to their usage. (LBA0 carries the information for the whole disk, partition table ...)         For learning I can just start so
13:03:30 <merijn> arpl: Modelling for what purpose? But yeah, I agree with cocreature that I usually start by defining datatypes (not even their constructors/what they look like) and the types of functions I'd like to perform on them
13:04:08 <ski> (suspected cut off near end of "..         For learning I can just start so")
13:08:03 <arpl> merijn: Disks is what I am familar with. I just want to get used to the type system and get the most out of it. So I have a familiar framework that I want to 'capture' in Haskell types.          My initial question was something I was wondering about. I guess for this I better write something down and then get back here.
13:11:18 * ski is suspecting arpl might want dependent types
13:14:14 <arpl> ski: I don't know about that (because I don't know enough about dependent types). I think that things can be expressed with the 'base' type system. Although I do think that certain things could be expressed better with 'type level programming' instead of relegating the validation to smart constructors (or similar).
13:15:06 <EvanR> dependent types can express anything, given enough patience and ideally an artificially intelligent assistant
13:15:53 <arpl> [Will check out <https://wiki.haskell.org/Dependent_type>]
13:16:43 <ski> arpl : perhaps <https://en.wikipedia.org/wiki/ATS_(programming_language)> will have some interest
13:18:16 <ski> with dependent types you could express in the types how many sectors you have, and express exactly how many blocks each sector is (which may vary depending on the sector number) .. and the compiler will check these sizes at compile-time
13:19:49 <ski> (you could use arrays (having a specified size) in C to express that information, but you'd have to divide it up in "chunks" depending on the sector size .. with dependent types, you don't need that)
13:20:28 <arpl> ski: Will look at that too.         For learning purposes I don't mind if things are initially a bit kludgy (because that also shows where the limits are). But being able to check those things at compile time is certainly a property I was looking for.
13:20:28 <ski> anyway, in Haskell (which doesn't have dependent types), you could e.g. use an array whose elements are arrays. the sizes would be checked at run-time
13:21:39 <ski> anyway .. i'd suggest trying to dive in to Haskell, and understand the basics of it "on its own merits", before thinking too much about how it compares to things you already know
13:23:06 <monochrom> Comparison is noble, but it also comes with the prerequisite of actually knowing.
13:24:17 <ski> being able to use the type system to your advantage is an acquired skill
13:26:18 <the_2nd> if I want to only pattern match a list with n parameters, is (x1:x2:x3:[]) fine?
13:26:18 <ski> as one of the initial steps, imho, you should aim towards being able to infer types of monomorphic and polymorphic operations in your head. the point being to *internalize* the type system (which is really quite reasonable, when you've familiarized yourself with it .. at least sans extensions)
13:26:35 <arpl> ski: That was the idea ... doing things the Haskell way. (I was merely using a familiar concept, not the techniques.) Like I said: a disk in LBA mode is nothing more than a l[Sector] of a certain size. And because there are different kinds of sector contents I would parameterize the Sector type.              And acquiring skill is the goal : )
13:26:35 <ski> the_2nd : in case `n = 3', yes
13:26:45 <the_2nd> ski, thanks
13:28:04 <cocreature> the_2nd: you can also use [x1,x2,x3]
13:28:24 <the_2nd> cocreature, that's slightly better
13:28:44 <ski> arpl : of course, there's many other lessons. expressing iteration and looping as recursion. learning about pattern-matching (no, not regexen, nor something as simple as `switch'). handling immutability, learning when you really need/want mutability and when you don't. non-strict evaluation. &c.
13:30:45 <ski> arpl : pattern-matching is tied to so-called "disjoint union" types (aka "variant types", "sum types", "~ algebraic data types", &c.). this is "dual" to record types (`struct'). it's important to realize that there's commonly a trade-off between these two
13:31:26 <merijn> the_2nd: Note that any other list will result in a crash, though :)
13:32:00 <ski> arpl : oh .. and of course treating functions as first-class values, passing them as arguments, returning them, storing them in data-structures, computing new functions at run-time (going beyond the use of function pointers in C)
13:32:15 <ski> in short, higher-order programming
13:33:04 <the_2nd> merijn, nope :) http://lpaste.net/2618949307662860288
13:35:02 <ski> arpl : then, also some Haskell specialities, like side-effect-freeness, and how that affects the I/O system, and other stuff that's traditionally been expressed through side-effects (mutable state, (erratic and angelic) nondeterminism, exceptions, `setjmp'/`longjmp', &c.)
13:35:45 <monochrom> erratic? heh.
13:35:51 <merijn> the_2nd: I meant if you don't have any other cases. If you do, it's fine :)
13:36:06 <ski> arpl : probably all these things doesn't tell you that much atm .. i'm merely trying to point out that there's (potentially) interesting things to learn here
13:36:17 <monochrom> It should be demonic and angelic, but I guess sometimes the demon can't make up its mind.
13:36:34 <the_2nd> merijn, doens't hurt to let you verify 
13:36:40 <ski> well, iiuc, demonic is when it's actively out to get you
13:36:49 <ski> erratic is when it doesn't care
13:36:55 <Gurkenglas> Is there some way that doesn't involve exceptions to get rid of "return" in each line? (The one with exceptions would be to use teaspoon to turn pattern match failure into Nothing)
13:37:11 <ski> so demonic reasoning would be used in worst-case scenarios
13:37:13 <merijn> Gurkenglas: It depends?
13:37:18 <ezyang> Gurkenglas: Does Either/Maybe monad count? 
13:37:29 <geekosaur> Gurkenglas, you might show the code in question
13:37:34 <geekosaur> since it's hard to answer that otherwise
13:37:42 <Gurkenglas> I meant <the_2nd> merijn, nope :) http://lpaste.net/2618949307662860288
13:37:53 <ski> (depending, the difference may not be that large)
13:37:58 <Gurkenglas> ezyang, but then you still have to say return/Just, right?
13:38:26 <ski> arpl : .. does that help any ?
13:38:33 <ezyang> Gurkenglas: what are you really trying to do 
13:38:34 <arpl> ski: Yes, that part (functions as first-class citizens) is part of the other thing I was contemplating to exercise with. (Which also has a clearer part to expansion.) A job is a pair of data and a list of functions that should act upon that data. What I want to explore with that is how I differentiate and order the functions that I am passed in. (In a specific case: Data is Text. Functions are encrypt and compress. Of course you will fir
13:38:44 * geekosaur thinks he's just seen the first thing that sends him seriously thinking about TH :)
13:38:45 <arpl> ski: Yes, that does help : )
13:39:07 <Gurkenglas> ezyang, I saw http://lpaste.net/2618949307662860288 and thought that it ought to be possible to get rid of those return lines
13:39:35 <monochrom> The "return" there means "Just". Look at the top type signature.
13:39:37 <merijn> Gurkenglas: You could replace the individual cases and do "return $ case vars of"
13:39:58 <geekosaur> doesn;t fly for Nothing/fail
13:40:12 <Gurkenglas> monochrom, yea but putting Just everywhere isnt better than putting return everywhere
13:40:49 <ezyang> I don't think there is a convenient way around this 
13:40:57 <monochrom> I don't think the "return" can be fundamentally eliminated.
13:41:20 <ski> arpl : the side-effect-freeness is related to making it easier to reason about and refactor a program ("predictive power" as monochrom calls it, as opposed to "cavalier power", being the same as "expressive power") .. 
13:41:27 <the_2nd> merijn, Gurkenglas "final" version, guess it's nice this way :) http://lpaste.net/8894904886655713280
13:41:52 <monochrom> Mainly because Haskell doesn't have "null". Every exception-like mechanism adds a Maybe or IO to your type.
13:41:53 <ski> arpl : .. people usually doesn't appreciate how important this is, until they've tasted it (and sometimes not even then, due to not clearly understanding what is making the difference)
13:42:33 <the_2nd> ski, coding c# at work, makes me cry
13:42:39 <the_2nd> null all the things
13:43:05 <ezyang> You can make it easier by defining a teeny helper function 
13:43:44 <the_2nd> ezyang, also with mixed param count?
13:43:45 <monochrom> ski: No, I coined "cavalier" because precisely there is some kind of expressive power that increases predictive power and decreases cavalier power, for example to be able to write the type "forall a. a -> a".
13:43:47 <arpl> ski: Yes I understand. When I wrote "a clearer part to expansion" I was meant refactoring. That the specifications would change and the implementation needs to change.        Goal: I want to refactor without fear! : )
13:43:53 <ski> arpl : yeah .. i'm not explicitly mentioning all the things that commonly is wrong in languages (like `NULL'), that Haskell gets right "automatically", so to speak. concentrating on the strengths (or at least interesting points), proper, not on weaknesses of other languages
13:43:59 <ezyang> the_2nd: yes you can do it 
13:44:06 <the_2nd> ezyang, I'll also add "sum" xs etc later on
13:44:25 <monochrom> In other words "expressive power" is simply a big mix bag that contains both and tells you nothing.
13:44:38 <ski> arpl : oh, actually, you said ".. (In a specific case: Data is Text. Functions are encrypt and compress. Of course you will fir", getting cut off and the end, a bit up
13:45:35 <Gurkenglas> Here's the aforementioned way to get rid of the returns using exceptions. http://lpaste.net/8894904886655713280#a354410
13:45:41 <arpl> ski: Better make the messages shorter then : )          Is there a limit? (Not only new to Haskell, new to IRC too. ; )
13:45:45 <ezyang> well, a simple way to do it is to just say f s [x] = helper s x 
13:45:45 <ski> arpl : .. this is not to say that Haskell doesn't have flaws, though
13:46:16 <monochrom> Yikes, teaspoon.
13:46:41 <ski> arpl : iirc, around fivehundred characters or so (perhaps less ?), depending on the IRC server in question one's connected to. this is a weakness/bug in the IRC protocol, yes
13:47:12 <ski> arpl : some IRC clients offer ways to automatically break your lines, by *guessing* the length (you can't really do better, iiuc)
13:47:27 <geekosaur> packet size 512 octets, minus protocol overhead
13:47:47 <glguy> and "protocol overhead" is dependent upon the length of your hostname :)
13:48:06 <geekosaur> and I think you can guess pretty accurately since the overhead is well characterized by the protocol. but it will depend on stuff not visible in a client like that
13:48:27 <geekosaur> also on things like mIRC color/attribute codes which take no space on the display but several octets in the packet
13:48:28 <glguy> and the server wil tell you what it's using as your hostname
13:48:45 <glguy> clients do the computation accounting for formatting control codes
13:48:53 <arpl> ski: Of course. Nothing is perfect.     I wanted to get my teeth into functional programming for some time. I like to be able to use the various paradigms (I even had fun programming in PostScript ... which is stackbased; as you may know, or similar to RPN.)
13:49:25 <monochrom> Did you write ray-tracing in Postscript? :)
13:49:34 <ski> monochrom : ok, so you're there using "expressive power" in a wider sense that i was using it (namely referring to the possible behaviours of a program .. and how that can be changed by *local* changes ion the program) -- but i agree that it's not clear this makes fully sense, due to contravariance ..
13:50:08 <monochrom> It is just like "nondeterminism".
13:51:25 <glguy> https://github.com/glguy/irc-core/blob/ccbd68b744d5d375e08c7fe570ba2acbdd641471/lib/src/Irc/Message.hs#L288
13:52:46 <arpl> monochrom: No : D          But I did use it as a 'general programming language', not just the page description part.
13:52:46 <arpl> ski: I have found a way to solve the length part quickly.
13:52:46 <arpl> ski: I just insert <CTRL-Enter> in the message and it gets posted as one blob, but not overflowing the max. length.
13:54:11 <koneida> hello haskell people. I have what I think is a simple parsec question. I'm trying to write a simple parser for lisp, and I want it to allow input like "( + 1 1 )" (with the extra spaces near the parens). I can get the open-parens to work, but not the close parens. I pasted the relevant code at https://pastebin.com/LN1sSnMd 
13:54:15 <ski> arpl : "Goal: I want to refactor without fear!" -- Haskell does help with that, both by side-effect-freeness (enabling more powerful equational/equivalence reasoning), and by usually pointing you to the code that needs to change, when you're changing your data types (in GHC, flags `-fwarn-incomplete-patterns',`-fwarn-overlapping-patterns')
13:55:02 <EvanR> koneida: after each logical token consume extra whitespace
13:55:08 <EvanR> and do nothing with it
13:55:21 <EvanR> and begin the entire parse by consume any leading whitespace, then do nothing with it
13:55:43 <the_2nd> EvanR, seems like he does so already
13:55:44 <koneida> I think that's what I'm doing -- I wrapped the parse in two calls to spaces
13:56:07 <monochrom> koneida: Here is my example of what EvanR said: https://wiki.haskell.org/Parsing_expressions_and_statements
13:56:26 <EvanR> make sure "spaces" works properly
13:56:41 <EvanR> the second spaces shouldnt be necessary if everything is doing this strategy
13:56:49 <arpl> ski: (22:54:10) ski: Received CTCP 'VERSION' (to arpl) from ski
13:56:49 <arpl> (22:54:36) arpl: Deliberate message or accidental?
13:56:49 <arpl> (22:54:36) ski <AUTO-REPLY> :  Security System Breached
13:56:58 <Gurkenglas> Maybe this way's acceptable? http://lpaste.net/8894904886655713280#a354411
13:57:22 <ski> deliberate, since i was wondering which version/client you were running
13:57:25 <ski> i used
13:57:34 <ski> /ctcp arpl version
13:57:52 <the_2nd> I'm out. As always, thanks everyone for the help
13:58:23 <monochrom> koneida: Notice that your current code does not eat spaces after ')', so you're inflicting on yourself a self-inconsistent convention and self-confusion.
13:58:58 <arpl> ski: Ok. Am using Pidgin on a Debian VirtualBox machine.
13:59:23 <koneida> monochrom: I see that now. thanks.
14:00:15 <monochrom> Intead, we are saying that you should strictly follow the consistent convention of "each conceptual token is responsible for trailing spaces". For example parseList is responsible for its trailing spaces, parseDottedList is responsible for its trailing spaces, and therefore the closing paren is not going to worry about spaces before it, but it also has to eat spaces after.
14:00:49 <joe9> I need a library to parse output from a socket. I can use cereal but am checking out attoparsec as it can handle partial/incremental input. Is attoparsec an alternative to cereal?
14:01:11 <koneida> monochrom: That makes sense. I'll give it a try and report back if I have no luck.
14:01:13 <glguy> joe9: all of binary, cereal, and attoparsec can process input in chunks
14:01:23 <EvanR> attoparsec is incremental but still hangs onto the entire input, so it wont work for an unlimited stream
14:01:49 <EvanR> unless you cancel out and start over from time to time
14:02:04 <merijn> EvanR: If you're getting a steam of small records that's easily solved
14:02:17 <joe9> EvanR: it is definitely not an unlimited stream.
14:02:17 <merijn> joe9: binary can do incremental input
14:02:18 <EvanR> is it easily solved?
14:02:29 <joe9> I am worried that the input might come in multiple chunks
14:02:30 <merijn> joe9: And it's more of an alternative to cereal than attoparsec
14:02:49 <merijn> joe9: Use something like pipes/conduit and the relevant parser wrappers to deal with that
14:02:49 <EvanR> it will certainly come in separate chunks
14:03:14 <EvanR> TCP has no knowledge of your content
14:03:24 <merijn> EvanR: Yeah, things like pipes-attoparsec can repeatedly apply a "chunk" parser to a stream of bytes, so you'll only need to keep one chunk of backtrack in attoparsec
14:03:37 <joe9> thanks folks.
14:03:48 <glguy> If you're parsing discrete messages using any of binary, attoparsec, or cereal, you can run the parser in incremental mode so that it completes after parsing a message message
14:04:07 <glguy> then you start a new parse initialized with the "remaining" input from the previous parse
14:04:16 <merijn> joe9: But anyway, I'd have a look at binary first
14:04:30 <merijn> As the name indicates, it's more aimed at binary formats than attoparsec
14:04:42 <glguy> "after parsing a complete message"*
14:04:47 <joe9> merijn: ok, Thanks.
14:05:12 <merijn> glguy: Right, but things like pipes can already take care of all that tediousness :)
14:05:42 <glguy> pipes is a big price to pay for what amounts to one line of calling the parser again
14:06:01 <koneida> monochrom: ok, got it working. thanks for your help!
14:06:32 <joe9> merijn: I have not ventured into pipes yet. It is a simple project and I do not want to use pipes for this.
14:06:36 <monochrom> koneida: And just now I found my s-expression parser: http://lpaste.net/114582
14:06:51 <merijn> glguy: big price? in what sense?
14:07:21 <glguy> Pipes brings in its own complexity that isn't needed for this simple situation
14:07:26 <merijn> glguy: Especially since it can help both handle cleanup of the socket and rechunking of input from said socket and consuming the stream of chunks
14:08:02 <glguy> If there was a significant amount of layering I'd agree that pipes could be beneficial
14:08:19 <glguy> perhaps chunks come in and then youre doing some kind of base 64 decoding and then some other layer, etc
14:08:33 <glguy> but not for just reading discrete binary messages off a socket
14:08:35 <EvanR> i would love a solution to this that doesnt involve pipes
14:09:08 <EvanR> this problem came up during a "do something useful with haskell" challenge
14:09:10 <joe9> I think Network.Connection.connectionGetChunk' and Cereal's Data.Serialize.runGetState seem to fill the need here.
14:09:24 <merijn> EvanR: conduit? ;)
14:09:27 <EvanR> for someone without much haskell experience
14:09:33 <EvanR> pipes was a non starter
14:09:49 <EvanR> trifecta was a non starter
14:12:28 <monochrom> getContents was a non starter too.
14:12:35 <monochrom> Or rather, would be.
14:12:43 <glguy> Oh, don't forget not to start with machines
14:12:48 <EvanR> getContents was a non starter
14:12:54 <EvanR> machines too
14:13:19 <EvanR> im not sure if the problem would have been easier in C
14:13:31 <glguy> starting was probably a non-starter
14:13:36 <EvanR> would have its own share of non-robustness
14:13:50 <monochrom> C would give the illusion of being easier.
14:14:50 <EvanR> problem: incrementally process new data from a java log output file, recognize when the log entries are beginning and send the previous one to a web server
14:25:28 <joe9> I have an integer value that is being sent on a socket as an ascii string. I plan to create a newtype ShowInt, instance Serialize ShowInt where put = pack . show . unShowInt
14:25:43 <joe9> not sure if that is overkill and if there might be a better way of going about it.
14:30:51 <Gurkenglas> EvanR, you mean "foo previous = do next <- fetch; if predicate next then send previous else foo next"?
14:31:29 <EvanR> probably not
14:32:51 <EvanR> read a character when available until the buffer fills up with a complete log entry, you only know its complete when you see the beginning of a new log entry (which might conceivably be a false positive due to java log file contents)
14:33:10 <EvanR> at which point send the contents of the buffer up to the cloud
14:33:17 <EvanR> and start over
14:56:10 <klottie> I have a data type in a module. It does not derive Read, but I need to use read function for that type. If there were 'deriving Read' at the end of the type definition line, there would be no problem but I do not have access to the module. Is there a way to add that functionality in a separate file? I tried 'instance Read Foo' but it did not work as I described.
14:56:41 <EvanR> theres standalone deriving clauses
14:57:59 <barryburd> Beginner question: I’ve defined “data Length = Length Double Units” and “data Currency = Currency Double Locale”. I want to create a “class Convertible” with two functions, fromUS and toUS. So, for example, toUS converts meter lengths to foot lengths and toUS converts euro amounts to dollar amounts. It seems to me that, in the declaration of the Convertible class, I ought to be able to define fromUS in terms o
14:57:59 <barryburd> toUS so that the minimal declaration for an instance is toUS. Is this possible? I understand that finding inverses is undecidable but this is such a simple inverse inverse function — only one value (the multiplier) to define for each instance.
14:58:10 <klottie> EvanR: Do you mean 'data Foo deriving Read' after the original definition as a separate line?
14:58:24 <EvanR> it doesnt look quite like that but yes
14:58:43 <EvanR> currency as a Double o_O
14:58:49 <EvanR> use Centi from Data.Fixed
14:59:35 <EvanR> or Rational if you want the inverse to actually work
14:59:41 <barryburd> EvanR: Sorry about using Double. It’s not meant to be an industrial strength app.
14:59:51 <barryburd> Rational might work.
15:00:00 <glguy> EvanR: Maybe it's needed to find the sin or cos of the money, too?
15:00:08 <EvanR> o_O
15:00:10 <glguy> sqrt of the dollars?
15:00:21 <EvanR> reimann zeta function of dollars?
15:00:36 <barryburd> OK. I get it. Don’t use Double.
15:02:05 <glguy> barryburd: sure, you can write a default definition for fromUS in terms of toUS
15:02:41 <glguy> it might even be the case that only one of the two actually needs to be in the class
15:04:55 <barryburd> giguy, Whenever I define an instance, I have to define how I’m going to pull the numeric value out of the value, and then put it back into the new value??
15:10:09 <monochrom> There was just a neat haskell-cafe thread on money.
15:10:42 <monochrom> (The trick is there are many ways to round, and you need to use the one your accountants or lawyers require. Or else.)
15:11:38 <monochrom> (And because of that, Double's semantics is unlikely to fit your semantics.)
15:13:50 <monochrom> (And more counterintuitively (for programmers anyway), sometimes the rounding requirement is not so much on individual numbers, but on a whole list. Round elements in the list such that the sum is nicely 100%, for example.)
15:14:33 <barryburd> I understand the dangers of using Double.
15:19:58 <glguy> Not to worry, no one is lecturing you
15:21:18 <barryburd> I’ve got to go, but anyway, if you say defining fromUS in terms of toUS is possible, I’ll keep working on it.
15:26:59 <EvanR> is there a name for the type Left a | Right b | Both a b
15:27:13 <Cale> These
15:27:23 <Cale> https://hackage.haskell.org/package/these-0.7.3/docs/Data-These.html
15:27:36 <EvanR> nice
15:27:45 <Cale> wow, such instances
15:28:26 <monochrom> Everything from JSON to bicrosswalk.
15:29:14 <Cale> https://hackage.haskell.org/package/these-0.7.3/docs/Control-Monad-Chronicle-Class.html#t:MonadChronicle
15:29:15 <Cale> wat
15:29:19 <monochrom> This is the true cause of dependency hell.
15:29:45 <lyxia> wtf is MonadChronicle
15:29:57 <nbro> ahah
15:29:58 <nbro> that’s nice
15:30:22 <glguy> If you didn't want all these sweet sweet instances, like MonadChonicle, you'd just write the line "data These a b = ..." in your file
15:30:47 <monochrom> confess, absolve, condemn...
15:31:02 <monochrom> Is this an April 1st thing or what? :)
15:31:04 <EvanR> "in C you end up rewriting a lot of stuff from scratch anyway" or haskell ;)
15:31:26 <EvanR> not because code is not reusable, but because of the dependencies
15:31:49 <Cale> We actually use These quite a bit in production code
15:32:19 <Cale> and Align
15:32:27 <Cale> But I'd never seen this Chronicle stuff
15:32:39 <Cale> https://hackage.haskell.org/package/these-0.7.3/docs/Data-Align.html -- quite useful
15:33:04 <EvanR> malign, nice
15:33:17 <Cale> haha, yeah, that's too fun a coincidence to pass up
15:33:51 <monochrom> This is a bad dream.
15:36:03 <Sornaensis> > malign
15:36:05 <Cale> Reflex's Event is an instance of Align
15:36:05 <lambdabot>  error: Variable not in scope: malign
15:37:01 <Cale> @let import Data.Align
15:37:01 <lambdabot>  .L.hs:66:1: error:
15:37:01 <lambdabot>      Failed to load interface for ‘Data.Align’
15:37:01 <lambdabot>      Perhaps you meant Data.Aeson (from aeson-1.1.1.0)
15:38:00 <monochrom> Yeah I don't think lambdabot knows about the these library at all.
15:38:30 <monochrom> If it did, we would have been using it to absolve each other since long ago. :)
15:39:16 <Cale> ahhhhh... newtype ChronicleT c m a = ChronicleT { runChronicleT :: m (These c a) }
15:39:52 <Cale> The names are ridiculous, but this makes it much clearer what's going on at least.
15:41:26 <monochrom> @type arr
15:41:28 <lambdabot> Arrow a => (b -> c) -> a b c
15:41:39 <monochrom> Nice, it's still there.
15:42:10 <EvanR> integration makes sense for types that can be scaled and added together, so does this amount to vector space? polynomial ring? er not sure i ever figured this out
15:42:27 <EvanR> modules?
15:43:45 <monochrom> Pretty sure you want division for scalers too. The scalers are a field, therefore the whole thing is a vector space.
15:44:07 <Cale> :t arr matey
15:44:08 <lambdabot> Arrow a => a Pirate's Greeting
15:44:14 <monochrom> YES!
15:48:15 <Cale> EvanR: measure space
15:48:31 <monochrom> In the limit you will need it a normed vector space because you need <= on magnitudes so you can talk about convergence.
15:49:07 <monochrom> And so indeed you get yourself into L^p spaces and beyond the point of no return.
15:49:41 <Cale> ah, for the codomain
15:50:23 <Cale> Yeah, you probably want that to be a Banach space of some sort, I guess.
15:50:30 <EvanR> for the domain
15:50:42 <EvanR> how does measure space pertain to integration
15:50:42 <Cale> For the domain, you want a measure space
15:51:34 <Cale> Lebesgue's approach to integration works over an arbitrary measure space
15:51:57 <Cale> https://en.wikipedia.org/wiki/Lebesgue_integration#/media/File:RandLintegrals.png
15:52:11 <EvanR> the basic setup i am imagning is functions R -> R and getting another R -> R out which is the integral "over time" of that
15:52:22 <EvanR> so im having a hard time seeing how measures work into that
15:52:31 <EvanR> or how it could generalize using measures
15:53:23 <EvanR> measures sounds like area or volume, but i guess im thinking about solving DEs
15:53:33 <Cale> Yeah, or length
15:53:53 <Cale> So, if you can define what the lengths of sufficiently arbitrary sets are
15:53:54 <EvanR> initial value problems
15:54:24 <Cale> Then you can consider the length of the set of points where your function's value is greater than t, for various t.
15:55:34 <EvanR> if the functions value is a vector...
15:56:10 <Cale> Well, right, it doesn't work out as nicely in that direction, and even just to make things work for negative values, you need to split things up a little
15:57:11 <Cale> To some extent you can integrate componentwise
15:57:32 <Cale> for vectors in spaces equipped with bases
15:57:50 <EvanR> that doesnt seem necessary
15:58:10 <Cale> Though I haven't seen many integration algorithms which actually take the Lebesgue approach to anything.
16:02:50 <Cale> Well, I suppose Monte Carlo approaches to various things could be said to be directly inspired by it
16:24:40 <NemesisD> hey folks. say i have data Foo = A | B | C, i think i should be able to create Proxy :: Proxy '[A, B], and if i can, is it possible to reflect that back into a value-level [A, B]
16:25:10 <NemesisD> or would '[A, B] technically be a heterogeneous list  and sink this idea
16:25:20 <glguy> NemesisD: It's possible to reflect it back, but it's not automatic. You'll have to define a class to do it
16:25:42 <glguy> or use something like the 'singletons' package to do that
16:26:46 <Cale> '[A,B] is homogeneous, it has kind [Foo]
16:27:10 <glguy> and it's actually  '['A, 'B]
16:27:17 <Cale> yeah
16:29:14 <NemesisD> glguy: ah so like write a instance Reifies 'A Foo where reify _ = A and so on, then class (Reifies x xs) => Reflectamundo (x :' xs) where reflectList :: (Proxy :: Proxy xs) -> uhh
16:30:06 <glguy> NemesisD: An example: https://github.com/glguy/lift-nary-operator/blob/master/Derive.hs#L37-L49
16:36:23 <NemesisD> glguy: i'm having trouble figuring out the type signature of the custom typeclass i'll write for this though,  class ReifyList (xs :: [*]) where reifyList :: proxy xs -> ???, i thought it may require another type param class ReifyList x (xs :: [*]) where reifyList :: proxy xs -> [x] but then i don't see how you'd write the instance for '[]
16:45:21 <monochrom> '['A, 'B] brings back memories of Lisp. :)
16:48:28 <NemesisD> woah i think i may have figured it out
16:51:18 <lpaste> glguy pasted “Demote for NemesisD” at http://lpaste.net/354413
16:51:59 * glguy fixes the extension list
16:52:40 <NemesisD> glguy: that's way more elegant than what i came up with. also i think what i came up with may actually be impossible to use :P
16:56:57 <lpaste> glguy annotated “Demote for NemesisD” with “single parameter type class, better type inference” at http://lpaste.net/354413#a354415
16:57:55 <NemesisD> TIL you need to put a space around the type level list opening bracket. Proxy '['A] is a parse error
16:58:29 <jle`> you don't necessarily need a space
16:58:54 <jle`> but quote-[-quote seems to be a parse error unfortunately, as some sort of Char
16:59:13 <jle`> ?
16:59:46 <jle`> you iften do '[A]
16:59:52 <NemesisD> it could be because the import was qualified, '['Mod.A]
17:00:08 <jle`> it's just '[' that causes problems
17:00:13 <NemesisD> oh ok
17:00:20 <NemesisD> haha! type level char that makes sense
17:00:21 <jle`> a bit unfortunate heh
17:00:34 <jle`> that's my theory, as someone who has little knowledge of ghc parsing
17:00:43 <NemesisD> glguy: thanks for this! is this something that exists in the wild or do people write this up themselves
17:00:58 <glguy> NemesisD: The singletons package is the sledge hammer for this stuff
17:01:02 <glguy> I don't know what people do in the wild
17:02:11 <jle`> NemesisD: the singletons package actually has this built-in
17:02:25 <jle`> it has a Demote type family
17:02:42 <nshepperd> glguy: even 'instance (Demote x, Demote xs) => Demote (x : xs)' works for me
17:02:54 <jle`> it exports instances for all of the main types in Prelude
17:02:55 <NemesisD> yeah, i've heard of that one, i was a bit uncomfortable bringing in all that in a previous incarnation of this but i actually may end up with enough constructors that using the TH demotion stuff may be smart
17:03:10 <jle`> and it gives you TH that lets you generate instances for your custom type
17:03:17 <glguy> nshepperd: Good fix
17:04:22 <Welkin> jle`: Nei sik m sik gong gwong dung wa aa?
17:04:41 <jle`> for singletons, there's `type family Demote (x :: k) :: Type`, and `instance Demote (x :: Bool) = Bool`
17:04:59 <jle`> type families take implicit kind arguments for some reason
17:05:03 <nshepperd> λ> :t demote
17:05:05 <nshepperd> demote :: Demote v => proxy v -> *
17:05:16 <jle`> Welkin: ?
17:05:16 <nshepperd> poor ghci can't handle it :)
17:05:33 <Welkin> jle`: guess that answers it :P
17:06:25 <NemesisD> thanks for the recommendations folks, ill check out singletons!
17:06:53 <jle`> for what its worth, this demoting stuff is a part of what singletons was made for
17:07:15 <nshepperd> ah, I need to set -XPolyKinds for ghci to get the type sig right
17:07:23 <jle`> i used to try to do it all by hand too
17:07:48 <jle`> back in the old days
17:07:55 <glguy> demote :: forall b (a :: b) (proxy :: b -> *). Demote a => proxy a -> b
17:07:59 <jle`> i suppose there is some value in doing it by hand to help yourself understand it, to undersatnd that it isn't magic
17:08:01 <glguy> That's a type!
17:08:10 <jle`> hooray for type in type
17:08:18 <glguy> the singletons package doesn't take advantage of this sweet TypeinType action
17:08:24 <glguy> at least afaik
17:08:26 <jle`> it does now actually
17:08:36 <glguy> oh, coool
17:08:38 <glguy> -o
17:09:42 <glguy> type Demote (a :: k) = DemoteRep k
17:09:44 <nshepperd> that's a interesting type signature indeed
17:10:38 <jle`> singletons has been taking advatnage of typeintype since soon after it was released
17:10:42 <nshepperd> it implies that the b that contains types, is the same thing as the b that contains values, not just some separate 'promoted' version of it
17:10:47 <jle`> mostly because the author of singletons was one of the people who implemented TypeInType
17:11:19 <nshepperd> which i guess is what TypeInType is all about?
17:12:00 <jle`> one of the most satisfying results was the ability to make  kindclasses
17:12:07 <jle`> ...or well, i guess they're typeclasses, heh
17:13:23 <jle`> a lot of singletons had "kind-classes" that were implemented using an ugly Proxy hack but now they'rvery natural and just normal typeclasses, which is nice
17:14:29 <nshepperd> couldn't you make kindclasses before?
17:17:00 <barrucadu> Is there a good blog post or something on using singletons? It's one of those libraries which looks pretty interesting, but I have no idea what I'd use it for.
17:17:05 <jle`> i think there was some issue
17:17:15 <jle`> nshepperd: i have trouble now making them until i turn on TypeInType
17:17:33 <jle`> barrucadu: i have a blog series that uses singletons heavily, if you want
17:17:38 <jle`> barrucadu: but the singletons library itself has pretty good documentation
17:17:59 <barrucadu> jle`: That'd be interesting
17:18:16 <jle`> https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html introduces and uses singletons as a means to an end
17:18:35 <nshepperd> I can make a useless kindclass
17:18:39 <barrucadu> Thanks
17:18:44 <lpaste> nshepperd pasted “Useless kindclass” at http://lpaste.net/354416
17:19:11 <nshepperd> maybe the issue was that you can only make useless ones? :p
17:19:19 <jle`> nshepperd: huh hm
17:20:18 <jle`> i wonder what the issue is
17:20:50 <nshepperd> one problem is that you can't put a Proxy k in that method signature to disambiguate the kind (because Proxy doesn't work for kinds)
17:21:17 <nshepperd> but that doesn't seem to be an impediment to anything
17:23:38 <jle`> maybe can you not make associated types?
17:23:46 <jle`> that might have been the problem
17:24:03 <jle`> hm
17:24:09 <glguy> You could make kind indexed type families before that
17:25:48 <glguy> Check out https://github.com/ekmett/hask/blob/master/old/src/Hask/Core.hs#L225-L233
17:28:47 <jle`> hm, i wonder what was forcing singletons to use the Proxy hack before TypeInType then
18:03:20 <Sornaensis> hi does anyone here know what systems' programming is
18:05:12 <tippenein> it's a marketing term, imo
18:05:22 <geekosaur> generally kernel or core system services, as opposed to application services
18:07:51 <geekosaur> for the webapp-on-the-cloud set: systems programming is what makes the cloud exist
18:30:40 <Cale> Or for certain types of people, "not just proving theorems"
18:44:06 <thimoteus> lol Cale
19:23:40 <mrjake> http://lpaste.net/354424 Anyone have any idea why accelerate-cuda isn't building?
19:25:25 <geekosaur> probably because it's deprecated/unmaintained and accelerate changed in a way that broke it
19:25:38 <geekosaur> "__This backend has been deprecated in favour of accelerate-llvm-ptx.__"
19:27:54 <mrjake> right, but accelerate-cuda is still a dependency of accelerate-examples...
19:28:13 <mrjake> should I just delete it from the .cabal file?
19:31:49 <geekosaur> hm. hackage thinks the only 1.x accelerate release is 1.0.0.0 and accelerate-cuda should still work with it. are you using accelerate from git?
19:32:47 <geekosaur> I expect removing accelerate-cuda from the accelerate-examples cabal file will just cause the examples to not build
19:32:49 <mrjake> nope, pulling straight from hackage
19:32:54 <mrjake> right
19:33:22 <geekosaur> your best bet might be to contact tmcdonell@cse.unsw.edu.au then
19:34:37 <geekosaur> oh, this is https://github.com/AccelerateHS/accelerate/issues/335 Build failure with ghc-8.0.2
19:36:55 <mrjake> ahh ok.  I googled but didn't find that.
20:38:17 <EvanR> :t (- 1)
20:38:19 <lambdabot> Num a => a
20:38:22 <EvanR> thats so annoying
20:38:49 <glguy> You can change it if you want to
20:38:55 <EvanR> oh?
20:39:22 <glguy> Oh, I guess NegativeLiterals doesn't change that to be a subtraction
20:41:14 <glguy> :t subtract 1
20:41:15 <lambdabot> Num a => a -> a
20:41:42 <EvanR> :t (+ -1)
20:41:44 <lambdabot> error:
20:41:44 <lambdabot>     The operator ‘+’ [infixl 6] of a section
20:41:44 <lambdabot>         must have lower precedence than that of the operand,
20:41:57 <glguy> (+ -1) :: Num a => a -> a
20:42:05 <EvanR> what
20:42:17 <glguy> Prelude Data.Word> :set -XNegativeLiterals 
20:42:22 <EvanR> ah
20:42:53 <EvanR> i dont really understand why the default is to use negate
20:43:01 <EvanR> when the class has a fromInteger
20:43:14 <glguy> > (-0) :: Double
20:43:16 <lambdabot>  -0.0
20:43:24 <EvanR> omg
20:43:33 <glguy> Prelude Data.Word> (-0)::Double -- 0.0
20:43:38 <glguy> with NegativeLiterals
20:44:22 * EvanR checks to see if gustafson eliminated negative zero 
20:46:22 <EvanR> i guess so if he eliminated +/- infinity
21:06:28 <EvanR> > sin 1e300
21:06:31 <lambdabot>  -0.8178819121159085
21:06:36 <EvanR> interesting
21:17:05 <significance> Hey all! I've been trying for the past while to figure out how to implement `foldl :: (a -> a -> a) -> a -> [a] -> a`. The recursive case for foldr, i.e. `foldr f s (x:xs) = f x (foldr f s xs)`, was quick to figure out, but I can't seem to figure out the one for foldl. Any other hints I could work from?
21:18:13 <significance> My issue is that if I peel off x from (x:xs), I don't know how to make it associate to the left recursively.
21:20:34 <glguy> Well, consider:
21:20:41 <glguy> > foldl f z [a,b,c]
21:20:43 <lambdabot>  error:
21:20:43 <lambdabot>      Ambiguous occurrence ‘b’
21:20:43 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.b’,
21:20:46 <glguy> ?undefine
21:20:46 <lambdabot> Undefined.
21:20:47 <glguy> > foldl f z [a,b,c]
21:20:50 <lambdabot>  f (f (f z a) b) c
21:20:58 <glguy> See that (f z a) in there?
21:21:29 <significance> Ahh, let me give it one more shot -- thanks!
21:24:04 <significance> glguy: thank you! that did it :)
21:24:31 <glguy> We did it!
22:09:11 <mrjake> What's the proper procedure for asking library maintainers to bump version bounds?
22:12:46 <edwardk> mrjake: a find getting a bottle of fine whisky delivered to your home to be a powerful motivator
22:12:53 <edwardk> mrjake: (true story, it even worked)
22:13:17 <mrjake> haha
22:13:24 <edwardk> if that is beyond your means simply begging and pleading upon bended knee might work
22:18:19 <significance> I read at this link (http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell) that when newtype is used, the constructor is "erased" from the data structure, i.e. newtype Book = Book (Int, Int) means Book (Int, Int) will have the same representation as (Int, Int) internally.
22:19:08 <significance> Is the constructor literally just erased after typechecking?
22:19:19 <WarmCookie> significance: Correct.
22:19:56 <significance> How would that work? The type Book has one field, but (Int, Int) has two
22:20:24 <Cale> significance: Well, pattern matching against the Book type constructor just turns into a no-op
22:20:46 <significance> Cale: ohh, like Book _ ?
22:21:03 <Cale> yeah, it doesn't force the evaluation of the scrutinee
22:21:07 <Cale> @let newtype Book = Book (Int, Int)
22:21:08 <lambdabot>  Defined.
22:21:16 <Cale> @let data Tome = Tome (Int, Int)
22:21:18 <lambdabot>  Defined.
22:21:21 <mrjake> edwardk: actually it's one of your libraries http://lpaste.net/354425
22:21:30 <Cale> > case undefined of Book _ -> 5
22:21:32 <lambdabot>  5
22:21:36 <Cale> > case undefined of Tome _ -> 5
22:21:39 <lambdabot>  *Exception: Prelude.undefined
22:21:44 <significance> whoa, awesome!
22:21:45 <significance> thank you :)
22:22:11 <significance> so wait, what happens if we define Book with getInts (via record syntax)?
22:22:31 <Cale> Well, that's just syntax sugar, it defines a function for you
22:22:41 <edwardk> mrjake: linear-accelerate has been released. cabal update?
22:22:45 <significance> if we run getInts $ Book 3 5, wouldn't that become getInts $ (3, 5), which would be an issue?
22:22:54 <Cale> That doesn't typecheck
22:23:13 <edwardk> mrjake: we released it the day after they shipped all the accelerate stuff
22:23:24 <edwardk> mrjake: i love it when i get requests that don't require me to do anything.
22:23:28 <significance> @let newtype Book a b = Book { getInts (a, b) }
22:23:28 <lambdabot>  Parse failed: Parse error: (
22:23:32 <Cale> newtypes are only allowed to have a single data constructor with a single field
22:23:40 <Cale> @undefine
22:23:40 <lambdabot> Undefined.
22:24:07 <Cale> @let newtype Book = Book { getInts :: (Int, Int) }
22:24:09 <lambdabot>  Defined.
22:24:27 <significance> > getInts $ Book 3 5
22:24:27 <Cale> :t getInts
22:24:29 <lambdabot> Book -> (Int, Int)
22:24:29 <lambdabot>  error:
22:24:30 <lambdabot>      • Couldn't match expected type ‘Integer -> Book’
22:24:30 <lambdabot>                    with actual type ‘Book’
22:24:35 <Cale> :t Book
22:24:36 <lambdabot> (Int, Int) -> Book
22:24:42 <significance> > getInts $ Book (3, 5)
22:24:44 <lambdabot>  (3,5)
22:24:49 <significance> > getInts $ (3, 5)
22:24:51 <lambdabot>  error:
22:24:51 <lambdabot>      • Couldn't match expected type ‘Book’
22:24:51 <lambdabot>                    with actual type ‘(Integer, Integer)’
22:25:16 <WarmCookie> significance: Only `data` can have multiple fields, and since they are algebraic, the constructor must be tagged for the sum types (otherwise you could accidently make a union).
22:25:16 <significance> So `getInts $ Book (3, 5)` works, but if we remove the Book constructor, we have `getInts $ (3, 5)`
22:25:21 <geekosaur> the type is erased *after* the typechecker; you need the Book constructor still
22:25:48 <significance> WarmCookie: ahh, thank you
22:26:13 <significance> geekosaur: But even if we typecheck first, wouldn't `getInts $ (3, 5)` still not make sense?
22:26:15 <WarmCookie> significance: This tag that exists at runtime isn't needed for newtypes.
22:26:37 <geekosaur> also the usual point of a newtype is to hide something (usually typeclass instances) about the original type, so you need the constructor to identify that you are using the newtype
22:27:12 <edwardk> mrjake: don't let that stop the whisky delivery though ;)
22:27:20 <significance> Ahh, gotcha. Why I'd want newtype makes a lot of sense -- just how it's handled internally I'm wondering
22:27:37 <mrjake> edwardk: haha ok.  just did cabal update but still not working... give me a minute
22:28:09 <geekosaur> so with data, you have a bunch of nested boxes <Book, <2-tuple <I# Int#> <I# Int#>>>
22:28:14 <significance> does it literally just delete the constructor (literally remove the string "Book") after typechecking, or does it handle the methods (like getInts) of newtypes specially as well?
22:28:19 <geekosaur> as the runtime representation
22:28:34 <significance> Sweet, following so far :)
22:28:35 <WarmCookie> edwardk: What's a good read on category theory? I'm getting acquinted with objects, morphisms, the laws, functors, categories of categories, but a lot of jargon and concepts are missing.
22:28:52 <geekosaur> the runtime representation for the newtype version omits the outer box. but the compile time representation still requires the box
22:29:24 <edwardk> WarmCookie: I gave a decently detailed response to that here: https://www.quora.com/What-is-the-best-textbook-for-Category-theory
22:29:25 <significance> WarmCookie: total noob here and haven't read it yet, but I've heard great things about CT for the Working Mathematician
22:29:47 <geekosaur> and if you go behind the compiler's back with something like unsafeCoerce, you can make the compiler think (3,5) is a Book (3,5) (but don't do that; types are there for a reason)
22:29:55 <WarmCookie> edwardk: Much appreciated.
22:30:17 <significance> geekosaur: if we omit the outer box in the runtime representation, how would Haskell handle something like getInts $ Book (3, 5) internally?
22:30:47 <significance> It would create the simplified runtime representation of Book (3, 5), right? But then how would it handle getInts?
22:31:07 <edwardk> significance: it becomes the identity function
22:31:13 <edwardk> after things desugar into core
22:31:14 <geekosaur> once you're past the typechecker, *all* types go away --- but the runtime representation still has constructor tags in it
22:31:47 <geekosaur> because you need to handle things like data Maybe a = Nothing | Just a, so a Maybe Int has to have a constructor tag (in ghc, 0 for Nothing and 1 for Just _)
22:31:54 <mrjake> edwardk: stack build says "WARNING: Ignoring out of range dependency (allow-newer enabled): linear-accelerate-0.2. accelerate-examples requires: >=0.3"  Not sure why it's still trying to build version 0.2 ?
22:32:06 <Cale> WarmCookie: btw, I agree with Ed on this, Awodey's book is probably the best modern intro to CT
22:32:27 <significance> edwardk: ahh, sweet, thank you
22:32:29 <WarmCookie> Cale: I just placed my order :)
22:32:38 <significance> geekosaur: that makes a ton more sense -- thank you!
22:32:41 <edwardk> mrjake: guessing you probably installed linear-accelerate already, so cabal is trying to reuse the existing version of your dependencies?
22:32:43 <WarmCookie> Cale: I shall watch TheCatsters in the mean time.
22:32:48 <geekosaur> but with newtype, you are prevented from doing things that require the constructor tag and the runtime rep doesn't have one. so after typechecking you have getInts :: (Int,Int) -> (Int,Int); getInts = id
22:33:10 <edwardk> did you do this in a sandbox or dump crud all over your global install?
22:33:28 <significance> geekosaur: ohhhhh, gotcha. does the constructor tag just say that "we may have several constructors, so watch out
22:33:29 <geekosaur> except faster because ghc usually just eliminates the function entirely
22:33:31 <significance> "?
22:33:39 <geekosaur> partly. it also enables laziness
22:33:48 <mrjake> edwardk: that's probably true.  Is there any way to avoid a full rebuild?  I'm on a slooooow machine.
22:33:53 <geekosaur> because you don;t have the actual value in the box, you have a pointer
22:33:54 <significance> how so?
22:34:04 <significance> ohh, neato
22:34:08 <geekosaur> and the thing pointed to may not have been evaluated yet
22:34:13 <edwardk> mrjake: well, you can do all sorts of scary cabal install --force stuff
22:34:15 <thimoteus> edwardk: appreciate the quora link. i'm going through mac lane right now, any suggestions for what to pick up afterwards?
22:34:31 <edwardk> thimoteus: depends on if you make it clean through or if you bounce half way =)
22:34:35 <significance> why can't we do that with several constructors?
22:34:40 <geekosaur> but with a newtype, neither tag nor pointer so you don't have that extra level of laziness
22:35:11 <significance> why don't we have a pointer for newtype but have one for data?
22:35:15 <Cale> If you're using nix, you can try sticking doJailbreak on things and seeing if that gets them to build :)
22:35:21 <thimoteus> edwardk: at the moment i'm enjoying lots of opportunities to do literally nothing except read, so i devote a few hours a day to it (literally nothing else to do)
22:35:58 <edwardk> thimoteus: anyways, i like Serge Lang's Algebra as a nice next step
22:36:14 <thimoteus> edwardk: thanks, i'll check it out :)
22:36:17 <edwardk> its about the same density as maclane, just about 10 times longer
22:36:50 <geekosaur> also, things can get more complex than this because you can mark fields as strict and then ghc will at higher optimization levels unpack them into the constructor, omitting the intervening pointer. but here things get complex, because it can't always do that
22:36:53 <edwardk> and it is kind of careful to introduce categorical analogues to the bits of algebra it introduces as it goes as i recall
22:37:43 <geekosaur> it needs to be able to determine the size of each chunk of memory, which is to some extent controlled by the tag (using the Maybe example, Nothing is just a Word# 0# but Just is Word# 1 followed by a pointer, so generally twice as large)
22:38:02 <mrjake> edwardk: I'll probably just do a full build, but I'll have the same problem with gloss-accelerate depending on accelerate-0.15.1.0.  Looks like I'll have to ping that maintainer?
22:38:05 <significance> ohh, awesome -- thank you!
22:38:07 <geekosaur> and it needs to know where things are inside that chunk of memory, so there are limits to what it can omit when and still be able to manage memory properly
22:38:44 <significance> is the reason that pattern matching a newtype is lazy just a design choice?
22:38:46 <geekosaur> if you want the full story, the ghc Commentary and various Notes in the source code discuss all the details.
22:38:51 <geekosaur> er?
22:39:13 <significance> The reason that a case on `Book _` wouldn't evaluate the inside value
22:39:32 <geekosaur> it's not truly lazy in the case you are thinking of, it just knows it doesn't have to look because at runtime there is no Book constructor tag to be checked
22:39:55 <significance> Why aren't wildcards like that always evaluated "lazily" like that?
22:39:58 <edwardk> significance:  anything in kind * in haskell is represented as some kind of object on the heap. that object is either a computation that will run and produce a data constructor, or a data constructor. newtypes are just a compiler trick to say 'hey look please don't make an extra level of indirection here for me' because data Foo = Foo Int -- is a either a
22:39:58 <edwardk> computation that'll yield a Foo Int or a tag that says "hey i'm constructor 0" followed by a pointer to the Int on the heap, which in turn is either a pointer to a computation that will return a number or a "I# 123#" for some primitive machine int
22:39:58 <geekosaur> whereas if it is a `data` then it has to look at least at the constructor tag, and will trip the `undefined`
22:40:25 <geekosaur> it never looks at the wildcard
22:40:36 <edwardk> significance: newtype Foo = Foo Int  -- on the other hand doesn't introduce the new level of indirection, its either a computation that will produce an integer, or an "I# 123#" constructor for some machine int
22:40:52 <geekosaur> it's only looking at the `Book` --- which for a newtype is a  no-op because it doesn;t actually exist except in the mind of the typechecker
22:41:02 <geekosaur> but for `data` it exists at runtime as a constructor tag
22:41:05 <edwardk> with data Foo = Foo Int, you can have _|_, Foo _|_, or Foo (I# someactualmachineint)
22:41:08 <geekosaur> so it has to be checked
22:41:14 <significance> ahh, I sorta see
22:41:27 <edwardk> with newtype Foo = Foo Int, _|_ = Foo _|_, so its just two cases
22:41:51 <significance> but for instance if we match, say, `Just _`, why would the value _ be evaluated?
22:42:05 <edwardk> significance: it isn't
22:42:08 <significance> derp
22:42:11 <geekosaur> remember, in the example you brought up, we were not looking at a (Book undefined), but at an (undefined)
22:42:26 <significance> geekosaur: oh, you're right
22:42:27 <mrjake> edwardk: wait, what is up with these gloss-accelerate version numbers? 0.2.0.0, 1.8.0.0, 1.8.15.0, 1.9.0.0      According to hackage website 0.2.0.0 is the newest
22:42:49 <geekosaur> [08 05:21:08] <Cale> > case undefined of Book _ -> 5
22:42:51 <significance> now I get it, awesome -- thank you!
22:43:16 <edwardk> mrjake: http://hackage.haskell.org/package/gloss-accelerate
22:43:20 <edwardk> i see 1.9.00 there
22:43:50 <significance> If we have a value that matches Book, we know that it only has one constructor with one field, so we can pretty much skip past?
22:44:12 <edwardk> the base bound seems tight though
22:44:15 <significance> > case undefined of Just _ -> 5
22:44:16 <lambdabot>  *Exception: Prelude.undefined
22:44:23 <significance> > case undefined of Book _ -> 5
22:44:26 <lambdabot>  5
22:44:39 <edwardk> mrjake: i have no idea what is going on with that package. you'd have to bug trevor
22:45:05 <edwardk> Explicitly deprecated versions for gloss-accelerate include: 1.8.0.0, 1.8.15.0, 1.9.0.0
22:45:16 <mrjake> edwardk: ok. as you can see version 0.2.0.0 is bolded and seemingly the default.  I'll bug him
22:45:18 <edwardk> i'm guessing there was some kind of snafu with the release?
22:45:44 <geekosaur> significance, no, the Book doesn;t actually exist so matching against just the Book part and having a wildcard for the field is a no-op
22:45:55 <significance> ah.
22:46:10 <geekosaur> but if you tried to inspect the value instead of matching with a wildcard, the undefined would explode
22:46:42 <edwardk> anyways explicit version deprecations don't work -- at least don't have an effect on cabal at last check, so he might have to go back and push a release of each to force them not to try to build
22:47:08 <significance> sorry I'm so slow at this -- what is it that the constructor tag declares?
22:47:08 <geekosaur> you could think of it as actually matching against _ _ instead of  Book _ (but you can't actually do that)
22:47:26 <edwardk> looks like he should have just released as a 2.0 or something
22:47:37 <edwardk> but then screwed up
22:47:42 <mrjake> edwardk: thanks for all your help!
22:47:48 <edwardk> and pushed out a release with a lower version number than what is already on hackage
22:47:50 <mrjake> edwardk: yeah exactly
22:48:01 <edwardk> no worries, wish i could be more help, but i don't have accelerate installed
22:48:15 <edwardk> and i've only used gloss once for a quick demo
22:48:32 <geekosaur> in a single constructor situation it does nothing but be consistent so the memory manager knows what's going on
22:48:54 <significance> ahh, gotcha -- but because newtype ensures it isn't dereferenced, it doesn't have a constructor tag (?)
22:49:09 <significance> the constructor is just declared "in place" without a pointer?
22:49:32 <geekosaur> (there are unboxed values though --- that's where the stuff I mentioned earlier with the #s appended came from --- and those are primitives that the memory manager knows about already. although that's a slight lie, you'd want to look up RuntimeRep in the ghc Commentary for the truth :)
22:49:46 <geekosaur> newtype is just a fiction of the typechecker
22:50:09 <geekosaur> beyond that it's just the field value
22:50:43 <geekosaur> no constructor tag, no pointer to the actual field value, just the field value itself and a note-to-self inside the typechecker to pretend that its type is actually different from that of the field
22:50:57 <significance> why don't the constructors for newtypes have the constructor tag?
22:51:09 <geekosaur> so that you can treat it differently, say by not mixing an Age with a Count. or so you can have both Sum and Product Monoids on Integer
22:51:36 <edwardk> significance: a newtype is just a pleasant fiction between you and the type checker. its used to help pick which instances will get selected. if we didn't have typeclasses all it'd do is prevent some things from typechecking
22:51:43 <edwardk> no runtime representation
22:52:31 <geekosaur> significance, what I just described is what newtypes are intended for. if you think about it, there's no need for any extra tagging or whatever, all there is is just a note to the typechecker to treat it as a distinct type
22:52:39 <geekosaur> that's all a newtype does
22:53:08 <significance> don't types declared with `data` have constructors with the constructor tag?
22:53:15 <geekosaur> yes
22:53:30 <edwardk> data isn't a pleasant fiction between you and the typechecker, it actually creates some structure
22:53:31 <geekosaur> and data is used for more than what I just described for newtype, so it needs the tag
22:53:48 <edwardk> data Either a b = Left a | Right b -- there are two cases there. it has to know which you have
22:54:12 <significance> but if we don't have the constructor tag for newtype constructors, how does ghc know that we're talking about a constructor?
22:54:23 <significance> and not some other piece of data?
22:54:41 <edwardk> the 'constructor and pattern matching for a newtype 'constructor' become identity functions and optimize away
22:54:51 <glguy> significance: The types aren't needed at runtime
22:54:52 <geekosaur> I think maybe all this stuff about the typechecker is just soaring far overhead...
22:54:52 <edwardk> then it matches like it would on whatever the underlying type is
22:55:18 <glguy> significance: They're needed to generate code. Once that's done they can be forgotten
22:56:15 <edwardk> if we didn't have a typechecker, and were just in lisp or something you could pretend newtypes don't exist, and just write code using the 'guts' of the newtype, no operational overhead. newtype induces no operational overhead, but provides a new "type", not any new things on the heap.
22:56:25 <edwardk> its just guidance to the typechecker to pretend something is different
22:56:49 <edwardk> newtype Foo = Foo (SomeCrazyThing) at runtime is just SomeCrazyThing
22:57:09 <significance> So (sorry, noob question) we typecheck, then optimize (stripping away newtype constructors) and finally run?
22:57:29 <edwardk> the act of typechecking compiles into a form where newtype constructors just don't exist any more
22:58:13 <jle`> hm, i wonder what was forcing singletons to use the Proxy hack before TypeInType then
22:58:33 <edwardk> typechecking produces a sort of "core" program as a witness that it checked the type correctly, in that core all the code for picking out instances is elaborated, newtypes don't exist any more except as type manipulations, etc.
22:58:35 <jle`> oh sorry, accidentally sent an old message
22:59:28 <edwardk> we then do optimizations on the core, then compile that to another representation that we can run
22:59:28 <significance> so then wherever a Book (Int, Int) and a (Int, Int) are are treated the same, as the newtype optimization skips the extra layer of <Book, ...> ?
22:59:33 <jle`> significance: well, we write a program to compile, and the type system helps us ensure that the program we compile makes sense
22:59:37 <edwardk> significance: exactly
22:59:48 <significance> ahh, thank you all so so much
22:59:49 <jle`> the type system doesn't play a role in the actual compiled code
22:59:56 <edwardk> and newtypes aren't just an "optimization" in that they have different semantics than having that indirection
23:00:18 <jle`> it's just a tool for us and for the compiler to make sure that the programs we write make sense before we compile them
23:00:30 <significance> ahh. a lot of new stuff for me tonight :)
23:00:39 <significance> thank you so much for putting up with me!
23:01:11 <edwardk> jle`: in a calculus a la curry thats true, we're a la church though -- our types guide instance selection so they change the semantics of your program, technically. without typeclass inference that statement is fully true though
23:13:21 <t4nk932> Hello, does anyone have experience with running haskell in a serverless (azure functions, google cloud functions, AWS lambda) environments?
23:18:38 <glguy> You're more likely to get help asking your actual question
23:22:43 <t4nk932> How can I execute a Hello world haskell function in AWS lambda? ghcjs ? spawning a chile process from node https://github.com/abailly/aws-lambda-haskell? I would like to learn from someone who has done something similar. 
23:22:53 <t4nk932> *child
23:28:35 <AbelianGrape> Anyone have any suggestions for why ByteStrings, which according to BS.length have length 20, are taking up 4kB of RAM *each*? This persists even using BS.copy and DeepSeq. I'm pretty befuddled
23:28:40 <brynedwards> t4nk932: Not me but here's a blog post that goes through it http://engineers.irisconnect.net/posts/2017-03-16-deploying-haskell-on-aws-lambda.html
23:29:29 <cocreature> AbelianGrape: do you have some minimal example that shows this?
23:29:40 <cocreature> AbelianGrape: how are you measuring memory usage of individual bytestrings?
23:30:00 <AbelianGrape> cocreature: Give me a minute. I'm allocating 20,000 of them and storing them in various data structures (to rule out data structure overhead)
23:30:18 <AbelianGrape> And I'm using -hp to look at allocation types
23:30:20 <AbelianGrape> it's all PINNED
23:30:27 <AbelianGrape> goes away  if I replace the bytestring with its hash
23:30:37 <cocreature> yeah PINNED is bytestring most of the time
23:31:32 <t4nk932> Thanks @brynedwards.
23:32:38 <moet> when using stack to build haddocks, it builds all the dependent packages.. it's crashing for me in the `gl` package with "too many files" .. how can i have it *just* build my current package and *not* the dependencies?
23:32:58 <moet> i've tried specifying the current package's name, but that still attempts to build the dependencie's haddocks first.
23:33:38 <moet> `--[no-]haddock-deps      Enable/disable building Haddocks for dependencies`
23:33:48 <moet> nevermind.. didn't see this on my first look
23:40:02 <AbelianGrape> cocreature: https://pastebin.com/R70qv9gN
23:40:25 <AbelianGrape> 20001 bytestrings, each 20 bytes long. Should come out to ~400k. But it's over 80 megs
23:40:46 <AbelianGrape> This is exactly what I'm doing in my real application btw
23:41:25 <AbelianGrape> I'm thinking maybe an FFI issue with the SECP library? But the memory leak does go away  if I hash the bytestrings and then store them...
23:41:55 <cocreature> hash and store the original bytestring or store the hash?
23:41:55 <AbelianGrape> Is it possible that there's some finalizer on FFI-allocated data that's not being triggered as long as the bytestring is in scope, even after calling BS.copy?
23:42:02 <AbelianGrape> Just store the hash
23:42:09 <AbelianGrape> I wanted to rule out a plain old failure-to-free
23:46:59 <cocreature> hm the code looks fine
23:47:13 <cocreature> I’m building haskoin to see if I can reproduce it
23:47:19 <AbelianGrape> Cool, thanks
23:48:49 <cocreature> gnah, I forgot to build with profiling enabled *rebuilds everything*
23:54:46 <ongy> note: ByteString has 2 Ints and a Ptr as management data, so slightly over 800k used memory should be expected
23:55:11 <AbelianGrape> I'd be fine with that. But 100x that is no good
23:57:22 <shtuka> I have a question on https://hackage.haskell.org/package/mathgenealogy: I have installed it on Windows 10 via "cabal install mathgenealogy". When executing "mathgenealogy <URL>$, I get the error "mathgenealogy: Error - Couldn't find the 'dot' program. Did you install GraphViz?" graphviz and dot are installed. What should I do?
23:57:58 <ongy> shtuka: is dot in your PATH?
