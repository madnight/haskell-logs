00:37:58 <kamyar> hello all
00:38:04 <kamyar> PLease help me with some haskell code
00:40:34 <tsahyt> kamyar: just state your question. and please use a pastebin for code
00:41:08 <kamyar> tsahyt: I did it 3 times, with no answer
00:41:18 <kamyar> tsahyt: I a trying to fix it myself, wait plz
00:47:07 <kamyar> I just want to serialize something using MessagePack
00:47:17 <kamyar> Since I am using GHC 8, I have to use data-msgpack
00:51:10 <pavonia> kamyar: What have you tried? What errors did you get?
00:51:48 <kamyar> pavonia: At last, I succeeded serializing using msgpack, using GHC Generics 
00:52:06 <dysfun> what is the correct 'modern haskell' form of EitherT A (ReaderT B (StateT C IO)) ? I've got MonadError A (MonadReader B (MonadState C)) but ghc isn't happy
00:52:26 <kamyar> pavonia: But there is another problem: I am trying to save the result into the redis. It is ok. But I want to call the function within scotty web action. 
00:52:38 <kamyar> pavonia: let me paste the code
00:53:55 <pavonia> dysfun: These Monad*s are typeclasses, no?
00:54:20 <dysfun> it's not clear from the material i'm using
00:54:22 <dysfun> how do i stack them?
00:54:45 <dysfun> do they just become constraints?
00:55:10 <kamyar> pavonia: Here is the code: https://pastebin.com/pVBz1mTJ
00:56:27 <pavonia> kamyar: I don't know about Redis, sorry
00:56:40 <pavonia> dysfun: What module are you using?
00:57:07 <dysfun> this is my own code. i'm just trying to tidy the code up
00:57:38 <pavonia> You wrote these monad transformers yourself?
00:57:45 <dysfun> oh, no, they're from mtl
00:58:17 <tsahyt> dysfun: (MonadError A m, MonadReader B m, MonadState C m) => ... -> m D?
00:58:23 <pavonia> So then yoe become constraints, yes
00:58:32 <pavonia> *they
00:59:13 <dysfun> so i am writing an interpreter and the line i am trying to change is the type of the monad stack for the runtime of the interpreter
00:59:27 <dysfun> i know the underlying monad will be IO, and i know which monads should be stacked in the stack
00:59:56 <tsahyt> dysfun: can you post some code?
00:59:59 <tsahyt> in a pastebin that is
01:00:34 <dysfun> it's one line
01:00:37 <dysfun> type Runtime = EitherT Error (ReaderT Scope (StateT Context IO))
01:00:52 <dysfun> i was wondering what that looks like in 'modern' haskell
01:02:16 <dysfun> i can use that as e.g. Runtime Int to return an Int
01:02:50 <dysfun> and this works fine with the line as it is there
01:03:28 <tsahyt> that's the concrete transformer stack. that's okay as is. where typeclasses come into play is when you define functions working on that stack
01:03:50 <dysfun> okay, so keep on with this structure except for places where it's meant to be generic?
01:03:50 <tsahyt> e.g. you'd have a foo :: (MonadError Error m) => Foo -> m Bar
01:04:01 <tsahyt> which would still run fine in your Runtime stack
01:04:21 <dysfun> ok
01:04:25 <tsahyt> but the type signature denotes that you only ever need some monad that can handle errors. that guarantees that you e.g. never touch the state part
01:04:44 <dysfun> but it will fill in the missing lifts conveniently?
01:04:55 <tsahyt> yes
01:04:59 <dysfun> neat
01:05:08 <dysfun> which leads to my second question
01:05:22 <tsahyt> except for when you have MonadIO m => m a. to use an IO function there you still need liftIO
01:05:48 <tsahyt> of course if you have a function that returns a MonadIO m => m a, then you don't. this is only for functions returning IO a.
01:05:51 <tsahyt> :t liftIO
01:05:53 <lambdabot> MonadIO m => IO a -> m a
01:05:56 <dysfun> i want to execute a Runtime m in the context of a changed Scope from the Reader, but GHC isn't happy because of the other things in the stack
01:06:22 <tsahyt> :t local
01:06:24 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
01:06:48 <tsahyt> how are you trying to execute this?
01:07:09 <dysfun> https://gist.github.com/jjl/32f98c12b3dbd5cb1456bf71bcb3699b
01:07:26 <dysfun> i have been playing around trying to make that work and i'm out of ideas
01:07:38 * dysfun has tried lift, etc.
01:08:55 <tsahyt> so basically you want to call a function in the same transformer stack but with a changed reader environment?
01:09:00 <dysfun> exactly
01:09:04 <tsahyt> local should work
01:09:16 * dysfun tries
01:09:17 <tsahyt> at least I think it should, I've never had that use case. my readers usually only carry config stuff etc
01:10:34 <dysfun> holy crap, it just worked
01:10:37 <dysfun> thanks! :)
01:33:34 <elementar> a question to people familiar with Attoparsec: why does the following parse fail?
01:33:41 <elementar>  parseOnly  ("foo" *> many1 anyChar <* "bar") "fooxxxbar"
01:35:44 * dysfun doesn't recall attoparsec accepting strings as parsers
01:35:53 <dysfun> don't you need a function for that?
01:36:54 <dysfun> it's called "string"
01:36:55 <dysfun> https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:string
01:37:48 <elementar> dysfun: oh, I'm using OverloadedStrings
01:38:07 * dysfun still doesn't recall attoparsec accepting strings as parsers
01:38:09 <elementar> by "fails" I mean parsing failure, everything typecheks
01:38:37 <sophiag> dysfun :)
01:38:47 <dysfun> oh god, are you haskelling now sophiag ?
01:38:54 <sophiag> yup
01:39:12 <dysfun> elementar: i don't remember in attoparsec specifically, but if i did that in megaparsec, many1 would eat all the chars
01:39:48 <elementar> dysfun: using "string" has the same result (failure)
01:40:06 <elementar> dysfun: but isn't Attoparsec supposed to always backtrack?
01:40:36 <dysfun> "always" is a rather strong statement
01:40:46 <dysfun> many1 hasn't actually failed
01:41:44 <dysfun> manyTill would be my suggestion anyway
01:41:45 <dysfun> https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-Combinator.html#v:manyTill
01:47:58 <tsahyt> is there any research on extracting test cases by inspecting functional code? e.g. something coverage based for example.
02:03:37 <Beginner_> Hi, I get "Failed to load interface.."  error when I :load the module. Only when not in base, e.g. I put ad (auto differentiation stuff) in the .cabal build depends. Stack build Ok. What's going wrong please?
02:25:22 <Beginner_> My Q is not right for here - will try elsewhere.
02:57:16 <frofru> hey there, I have a pipe question for you guys: http://lpaste.net/2888913544386969600 GHC complains that Couldn't match type ‘BS.ByteString’ with  'Data.ByteString.Lazy.Internal.ByteString'
02:57:34 <frofru> any idea why?
03:05:02 <tsahyt> frofru: presumably, you're trying to use strict bytestrings, but the library wants to use lazy ones
03:05:34 <tsahyt> btw, fromJust is already defined in Data.Maybe
03:07:33 <frofru> tsahyt: I forgot to mention that if I switch to lazy BS, it complains too: import qualified Data.ByteString.Lazy as BS => Couldn't match type ‘Data.ByteString.Internal.ByteString’ with ‘BS.ByteString’
03:07:36 <frofru> …
03:12:13 <tsahyt> frofru: it seems like pipes-zlib gives you a producer for strict bytestrings, but aeson's decode accepts a lazy one
03:12:15 <tsahyt> try decodeStrict
03:13:16 <frofru> tsahyt: ah, that was it! thanks!
04:36:10 <AWizzArd> (>>=) is pronounced “bind”. Is there aso a name for (>>)?
04:37:09 <ij> How do I make stack show me the path of the executable?
04:38:50 <tsahyt> AWizzArd: "then" or "sequence"
04:38:55 <tsahyt> source https://wiki.haskell.org/Pronunciation
04:40:02 <AWizzArd> tsahyt: ah right, good. Thx!
04:44:48 <f-a> I was looking for an extension to use distfix in my haskell project. Alas, there seems no such extension.
04:45:17 <f-a> is there a specific reason why it isn't so? Or just lack of someone implementing it?
05:05:07 <LAZAR> What is better practise? Using $ or parentheses? I mostly see $ being used with print...
05:05:39 <f-a> matter of personal choice, LAZAR . I prefer parentheses as $ $ $ $ makes it less readable to me
05:09:06 <AWizzArd> LAZAR: Coming from Clojure and Common Lisp there is some preferrence for parens, for me. However, for short examples I sometimes use a single $.
05:09:07 <dysfun> i think using a mixture is good
05:09:11 <LAZAR> f-a: yeah its a close call, print $ (2*) $ abs $ -5 vs print((2*)(abs(-5)))
05:09:28 <LAZAR> if you purely use parens it starts looking like lisp
05:10:03 <AWizzArd> You would still have to use the prefix variant for operators tho.
05:10:30 <f-a> LAZAR: when I see something like `print $ (2*) $ abs $ -5 vs print((2*)(abs(-5)))` I know I need some lets or wheres
05:11:12 <rmrfroot> I like to mix $, paratheses and . 
05:11:18 <rmrfroot> As much as possible
05:11:42 <LAZAR> f-a: can you refactor this example? im not quite familiar with the latter (i only used where in functions to remove redundancy yet)
05:12:12 <AWizzArd> f-a: I agree. Programs are written for human readers and it just is the case that also the computer must be able to read them.
05:12:31 <f-a> LAZAR: remember that function application has precedence over everything, too
05:13:00 <f-a> so 
05:13:04 <f-a> > print $ 2* abs (-5) -- this will do
05:13:06 <lambdabot>  <IO ()>
05:13:22 <f-a> 2 *, not 2*
05:15:15 <rmrfroot> haha, what about this version? isn't it lovely? `print . (*) 2 . abs $ -5`
05:15:52 <f-a> hehe
05:16:59 <rmrfroot> You know it bad when you have to put this disclaimer in your code: "Warning: do not look directly at this code, it may cause blindness" 
05:23:47 <Tuplanolla> It's the software equivalent of "do not look directly at the operational end of the device".
05:27:21 <troydm> I was always wondering why there is no search box for package on LTS Haskell web page because that is what mostly ppl do, they search for packages in LTS Haskell, that hoogle search box is totally useless there
05:33:10 <rmrfroot> Tuplanolla: haha
05:35:31 <LAZAR> Its just really weird that haskell allows function composition by no less than three different syntactic ways... (parens, $ and .)
05:35:55 <hpc> ($) and (.) aren't syntax
05:36:16 <hpc> also there's waaaaaay more than just those ;)
05:36:41 <hpc> @src ($)
05:36:41 <lambdabot> f $ x = f x
05:36:44 <hpc> @src (.)
05:36:44 <lambdabot> (f . g) x = f (g x)
05:36:49 <Tuplanolla> :t negate .: (*)
05:36:51 <lambdabot> Num b => b -> b -> b
05:37:27 <Tuplanolla> :t id &&& negate
05:37:28 <lambdabot> Num b => b -> (b, b)
05:37:35 <Tuplanolla> Have some more, LAZAR.
06:05:16 <superKiller> hello, I have a question. sudo apt-get install haskell-platform install haskell v7 , whereas i want v8.0.1, is that 'apt-gettable' ?
06:14:14 <Tuplanolla> Does Stack install local documentation by default? The user guide does not tell.
06:14:37 <Wheels_> Hey guys, I'm new to Haskell. I'm playing around with managing a list through pattern matching. Within GHCI I give the function the input "12356" 
06:14:39 <Wheels_> http://lpaste.net/354636
06:15:32 <Wheels_> I get some sort of type error, but I can't figure out why 
06:15:49 <Wheels_> Any help would be greatly appreciated! 
06:16:09 <Tuplanolla> You seem to be missing some cases, Wheels_.
06:16:24 <Clint> Wheels_: what happens when you pass sol a list of lengths 1 or 2?
06:16:57 <Wheels_> Oooh! I will get back to you in a moment! 
06:21:59 <Wheels_> Can there be ambiguity in the patterns, where I control which pattern is chosen first by putting the functions in desired order?  
06:22:10 <Tuplanolla> Yes.
06:22:24 <Tuplanolla> They just have to be exhaustive.
06:22:49 <Wheels_> Thanks a lot 
06:22:52 <Tuplanolla> The compiler can check this if you enable warnings.
06:30:07 <Tuplanolla> Stack's user guide does mention `build: haddock: true` in `~/.stack/global/stack.yaml`, but says that it could cause build failures. Is this really a problem?
06:34:42 <SrPx> What are the inference rules for Fix? Can someone link me to a paper / image?
06:39:32 <Wheels_> I figured it would be exhaustive now with the last sol function, however still getting (type) errors, I included them in the paste. http://lpaste.net/354639. Also included type signatures this time. Sorry if this is a very basic question! 
06:45:12 <Wheels_> Oh, the ':' operator only take a single Char on the left hand side? 
06:48:23 <tsahyt> :t (:)
06:48:24 <lambdabot> a -> [a] -> [a]
06:49:26 <tsahyt> specialized to String that is Char -> [Char] -> [Char]
06:50:19 <byorgey> Wheels_: in general, the ':' operator takes a single element on the left hand side and a list on the right hand side
06:50:58 <Wheels_> Yes, I feel silly for asking now, thanks guys
06:51:16 <tsahyt> It's useful to think of (:) not just as an operator but as the list constructor. Every element in a list is joined to the list after it by a (:). Indeed it actually *is* one of the list constructors, the other being []
07:01:43 <Wheels_> Oh yeah, [1,2,3] is just syntactic sugar for 1:2:3:[] right? 
07:05:12 <tsahyt> yes
07:05:31 <tsahyt> and "abc" is syntactic sugar for 'a' : 'b' : 'c' : []
07:05:43 <tsahyt> or for ['a','b','c'] if you prefer to desugar twice
07:05:58 <Wheels_> cheers! :) 
07:05:58 <tsahyt> (unless you use OverloadedStrings)
07:13:38 <fotonzade> guys I got a file like:
07:13:42 <fotonzade> (number of strings to read)
07:13:45 <fotonzade> (that number of strings)
07:13:50 <fotonzade> (number arrays)
07:14:17 <bartavelle> is there an established typeclass for things that just have "pure" from Applicative, and another from things that just have "extract" from comonads ?
07:14:21 <fotonzade> how do I split the file up and put it into variables?
07:14:24 <Tuplanolla> @hackage megaparsec
07:14:24 <lambdabot> http://hackage.haskell.org/package/megaparsec
07:14:29 <tsahyt> bartavelle: Pointed for pure
07:14:34 <Tuplanolla> Perhaps with that package, fotonzade.
07:14:41 <bartavelle> tsahyt, thx
07:14:49 <tsahyt> bartavelle: and Copointed too
07:14:55 <bartavelle> oh well :)
07:14:55 <fotonzade> Tuplanolla, I can't use anything fancy
07:15:17 <Tuplanolla> Use `readMaybe` then, fotonzade.
07:16:40 <fotonzade> thanks Tuplanolla 
07:54:48 <bartavelle> now, is there an established typeclass for "f a -> Maybe a" ?
07:57:58 <Gurkenglas> :t asum . fmap Just -- bartavelle, are there more examples you're thinking of than this could do?
07:58:00 <lambdabot> (Functor t, Foldable t) => t a -> Maybe a
07:58:08 <Gurkenglas> Also you might be interested in lens and using preview on its traversals
07:59:00 <Gurkenglas> :t getFirst . foldMap (First . Just)
07:59:02 <lambdabot> Foldable t => t a -> Maybe a
07:59:36 <bartavelle> hummm
07:59:59 <bartavelle> in my use case that's for things that can only ever hold a single 'a', but I am thinking about what that would mean for Foldable
08:00:21 <bartavelle> ie. several as
08:00:40 <Gurkenglas> Foldable needs not be several as. Maybe is a Foldable.
08:01:15 <tsahyt> Gurkenglas: is that a generalization of listToMaybe?
08:01:17 <bartavelle> yeah but then my code would also work for []
08:01:25 <Gurkenglas> tsahyt, yes
08:01:49 <tsahyt> that's quite nice
08:02:02 <bartavelle> and I have to think about what that would mean
08:02:06 <tsahyt> really this should be in base rather than just plain listToMaybe
08:02:18 <tsahyt> (getFirst . foldMap (First . Just)) (Right 1)
08:02:22 <tsahyt> > (getFirst . foldMap (First . Just)) (Right 1)
08:02:25 <lambdabot>  Just 1
08:02:39 <tsahyt> Either to Maybe conversion is something I need every now and then too
08:02:44 <tsahyt> > (getFirst . foldMap (First . Just)) (Left 2)
08:02:46 <lambdabot>  Nothing
08:02:53 <Gurkenglas> :t alaf First foldMap Just
08:02:55 <lambdabot> Foldable t => t b -> Maybe b
08:02:59 <tsahyt> :t alaf
08:03:01 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor g, Functor f) => (Unwrapped s -> s) -> (f t -> g s) -> f (Unwrapped t) -> g (Unwrapped s)
08:03:04 <tsahyt> lens?
08:03:06 <Gurkenglas> Yep :P
08:03:12 <tsahyt> nope nope nope
08:03:14 * tsahyt runs away
08:03:22 <bartavelle> haha
08:03:23 <Gurkenglas> It temporarily steals the powers of a newtype
08:03:53 <Gurkenglas> :t preview _Right :: Either a b -> Maybe b
08:03:55 <lambdabot> Either a b -> Maybe b
08:04:00 <Gurkenglas> :t preview _Left :: Either a b -> Maybe a
08:04:00 <tsahyt> :t preview
08:04:02 <lambdabot> Either a b -> Maybe a
08:04:02 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
08:04:32 <tsahyt> :t either (const Nothing) Just
08:04:34 <lambdabot> Either b a -> Maybe a
08:04:41 <tsahyt> ^ what I actually use
08:05:22 <Gurkenglas> :t preview (_Left . _Right) :: Either (Either a b) c -> Maybe b
08:05:24 <lambdabot> Either (Either a b) c -> Maybe b
08:05:43 <tsahyt> yeah once nesting comes into it, lens starts making some sense
08:06:01 <bartavelle> hum that's actually exactly a prism that I need here
08:10:03 <bartavelle> so, there isn't a typeclass like "HasPrism f where pr :: Prism' (f a) a" ?
08:12:25 <Gurkenglas> bartavelle, that would mean that f is isomorphic to Either b for some b
08:12:49 <bartavelle> yes
08:13:35 <Gurkenglas> So why not use Either b?
08:13:52 <bartavelle> because it makes the code harder to read than several custom type
08:13:59 <bartavelle> also some of these types are GADTs
08:14:19 <bartavelle> which I'm not sure how I would handle that way
08:15:09 <bartavelle> I like "Expr arch f a" better than "Either (NonConstant arch f a) a"
08:15:24 <bartavelle> even NonConstantExpr
08:16:31 <bartavelle> brb
08:16:45 <Gurkenglas> Ohh right the a may appear on the left. Hm.
08:17:36 <Gurkenglas> (so f isnt isomorphic to Either b)
08:17:48 <Gurkenglas> *need not be
08:19:30 <Gurkenglas> Suddenly it feels like it doesnt deserve a typeclass :3
08:20:58 <Gurkenglas> Because, like, ((,) Int) has a possible instance for each Int
08:27:37 <Tuplanolla> I'm about to build myself a new website, but I have to make a choice first: `hakyll`, `mathblog`, `muon`, `shikensu`, `heckle` or `haggis`?
08:29:04 <Akii> how about just using HTML?
08:30:09 <Tuplanolla> Most of the content will be project excerpts, software documentation and research papers, so I'd rather not retype all of that, Akii.
08:31:33 <tsahyt> I'm using hakyll. It does everything I need from it
08:31:46 <Wheels_> Hey guys, newbie question again: http://lpaste.net/354643. I can't figure out why this won't work, might be the point-free notation but I can't seem to fix it. 
08:32:09 <Tuplanolla> Would it have trouble integrating with existing build systems on other file systems, tsahyt?
08:32:34 <tsahyt> I have no idea. I run the site builder locally and then push everything via git.
08:33:05 <Tuplanolla> I'd like to be able to point it to a repository and a patch and go with that.
08:35:57 <Sornaensis> :t interact
08:35:58 <lambdabot> (String -> String) -> IO ()
08:36:21 <tsahyt> Tuplanolla: I think it should be possible with some setup
08:36:32 <Sornaensis> Wheels_: try replacing those $ with .
08:36:45 <Tuplanolla> Thanks, tsahyt. I'll take that into consideration.
08:36:53 <Sornaensis> $ does not work in pointfree because you need an x to apply f to
08:36:58 <tsahyt> if I understand you correctly anyhow. hakyll allows you to process some arbitrary directory through it and tie it into your routes
08:37:09 <tsahyt> all the contents of the directory will be processed via pandoc or whatever you have set up
08:37:22 <Sornaensis> . just composes functions
08:37:31 <Tuplanolla> I can probably launch Make etc from within Hakyll too, tsahyt.
08:38:07 <tsahyt> well you can launch arbitrary IO in the Rules monad, so yeah
08:38:30 <tsahyt> http://hackage.haskell.org/package/hakyll-4.9.5.1/docs/Hakyll-Core-Rules.html#v:preprocess
08:38:45 <Tuplanolla> Man, why do I have so many projects.
08:38:51 <Wheels_> @Sornaensis do I have to surround the map functions with parenthesis? 
08:38:51 <lambdabot> Unknown command, try @list
08:39:14 <Tuplanolla> I even had a project whose purpose was to assign project numbers to my projects, but it stalled.
08:39:27 <Wheels_> Still getting type errors 
08:39:40 <Jinxit> i have some deceptively repetitive code: http://lpaste.net/3585763033156157440 any ideas for making it less repetitive?
08:40:09 <Tuplanolla> My recursion scheme sense tingles, Jinxit.
08:40:17 <Tuplanolla> Have you heard of `Fix`?
08:40:33 <Jinxit> the uses of Fix i've seen only concern a single type
08:40:39 <Jinxit> sadly i have multiple mutually recursive types
08:41:19 <Tuplanolla> It should still be doable, or you could inline them together.
08:41:39 <Jinxit> got any examples?
08:41:44 <Jinxit> i'm not 100% sure on how it works
08:42:07 <Jinxit> (it's 12 types, fwiw)
08:43:29 <Tuplanolla> The idea would be to have `data SourceExprF f a = ...`, where `f` carries the mutually recursive constructors and `a` is the argument for the fixed point.
08:43:49 <Wheels_> http://lpaste.net/354643 The compiler freaks out because of ambiguity now, is it possible to specify types within this expression?  
08:44:08 <Tuplanolla> You could then permute `f` with the appropriate `newtype`s.
08:44:13 <Tuplanolla> I'm not sure how well that'd work for you though.
08:45:33 <Tuplanolla> If you want to keep the types as they are, the other option would be to derive `Generic` and use that to define the type class instances.
08:46:54 <Jinxit> so in this case it would be `SourceExprF f1 f2 a = Constructor (f1 a) (f2 a) a | ..` for example?
08:48:14 <Jinxit> what would this give me? would i still have to define walkDown/Up for every single constructor by hand?
08:50:14 <Jinxit> it's the kind of code that i can mechanically describe, but without resorting to TH i doubt i could 'generate' it
08:50:19 <Tuplanolla> I think it would be more like `data SourceExprF f c a = ConstructorF (f SourceExprF c a) [a] c | ...`.
08:50:45 <Tuplanolla> It's a bit tricky to say without trying it first.
08:51:16 <Tuplanolla> The idea is that `f` is sort of a continuation on the type level.
08:51:24 <Jinxit> yeah and it decimates any understanding you can get by reading the type definitions
08:51:38 <Gurkenglas> Jinxit, shouldn't it be m' = m <> m1 <> m2?
08:51:49 <Jinxit> let me think
08:52:38 <Tuplanolla> We don't do understanding around here.
08:52:52 <Jinxit> i believe m is already inside m1 and m2
08:54:27 <Jinxit> or to be specific, m has been passed to fSourceExpr (or similar) on a lower level, where it returns a new m', that shows up here as m1 and m2
08:56:06 <glguy> Wheels_: You can write:   (read :: String -> [Int]), for example
08:56:19 <xmonader3> I can't import Control.Monad.Reader is that still the correct module?
08:56:48 <Gurkenglas> Jinxit, I conjecture that this ends up looking like this: http://lpaste.net/3585763033156157440#a354646
08:57:11 <Gurkenglas> Congratulations on writing code that can be abstracted away immediately
08:57:35 <Tuplanolla> You missed the point where `SourceExpr` and `TypeInst` are mutually recursive, Gurkenglas.
08:57:45 <Gurkenglas> Dammit
08:58:22 <Jinxit> i wish it was that easy :)
08:58:23 <Tuplanolla> There are ways to resolve that, but they're all equally unpleasant.
08:58:59 <Jinxit> full types for the curious: http://lpaste.net/6928300002460565504
08:59:31 <Jinxit> but SourceExpr and TypeInst are directly mutually recursive, so i suppose they are minimal in a sense
08:59:36 <Jinxit> as a test case
08:59:55 <Tuplanolla> That looks oddly familiar, Jinxit. What is this for?
09:00:27 <Jinxit> AST for a programming language of my own invention
09:00:35 <Gurkenglas> I'm guessing this is one of the resolutions that are unpleasant? http://lpaste.net/3585763033156157440#a354647
09:00:35 <Jinxit> what's it look similar to?
09:01:04 <Tuplanolla> I recently discussed a very similar design with one of my former students.
09:01:30 <Jinxit> oh, wouldn't be me :)
09:01:39 <AWizzArd> What is the difference between  ap and <*>?  Shouldn’t <*> also work in monadic contexts?
09:01:41 <Tuplanolla> You work alone?
09:01:44 <Gurkenglas> (Whoops just took the m out of the class signature)
09:01:45 <Jinxit> yeah
09:01:56 <Gurkenglas> AWizzArd, monad is older than applicative
09:02:01 <Tuplanolla> Well, someone thinks alike!
09:02:15 <AWizzArd> Gurkenglas: so ap survived for compatibility reasons?
09:02:19 <geekosaur> yes
09:02:28 <Jinxit> i realize the common way to do it is to use Fix and have one "ASTNode" type for everything
09:02:37 <Jinxit> but i couldn't stomach losing so much type information
09:02:37 <geekosaur> and, well, most retrodfitted Applicative instances just set <*> to ap
09:02:55 <AWizzArd> k
09:03:26 <Jinxit> Gurkenglas: so correct me if i'm wrong, but that could automate all cases where it's self-recursive, but i'd have to write out all the other cases?
09:03:30 <Gurkenglas> Why didn't GHC magically add Applicative instance for every monad that didn't define them in order to not break things?
09:04:24 <Tuplanolla> You'd have to extend it the way I first described, Jinxit.
09:04:45 <Tuplanolla> The `Functor` instance would break otherwise (try it and see).
09:05:04 <geekosaur> Gurkenglas, because doing so is painful. I've been watching someone (dfeuer I think?) trying to add deriving code and getting a massive headache
09:06:08 <monochrom> I am philosophically against such magic. It makes the language more ad hoc.
09:07:11 <Jinxit> speaking of applicative - do 'many' and 'some' make sense outside of parsers?
09:07:24 <c0mrade> Can anyone help me troubleshoot a problem in an app, I've got it running but getting an exception, it's a web app. Here's some info about the app and how to set it up. https://github.com/ornicar/lila and https://github.com/ornicar/lila/wiki/Lichess-Development-Onboarding
09:09:50 <monochrom> many and some makes sense iff an action succeeds the first few times but if you keep doing it it eventually fails.
09:10:18 <monochrom> To a large extent that describes parsers and input takers.
09:10:18 <Jinxit> that's a good explanation
09:10:31 <Gurkenglas> Or it doesnt work immediately, or it keeps working forever
09:10:41 <Gurkenglas> *"immediately doesnt work"
09:10:56 <monochrom> I can also think up a "decrease internal counter until zero" example but it's artificial not real.
09:12:30 <monochrom> No, Gurkenglas, Maybe is an example of always-succeeds and always-fails and precisely because of this, many and some are problematic for Maybe, problematic being either bottom or trivial.
09:13:40 <monochrom> trivial being "yeah, some Nothing and some (Just 5) are OK, but why would you care"
09:15:51 <AWizzArd> What is the core motivation of having an IO Monad? Is it so that there is a “marker” in the type signature that tells that somewhere down the chain there IS some IO going on? That way devs can immediately see if they do a pure or impure computation.
09:16:16 <AWizzArd> Was that the design goal? IO is a monad so that IO is explicit?
09:16:21 <geekosaur> that's a large part of it, yes, it keeps the impure stuff separate
09:16:44 <geekosaur> but it also enforces sequencing, so you know IO actions take place in the right order
09:16:55 <AWizzArd> Yes good point.
09:19:53 <Gurkenglas> monochrom, no, Maybe can represent failing sometimes. See StateT s Maybe and https://hackage.haskell.org/package/pointedalternative-0.1.0.0/candidate/docs/Control-Alternative-Pointed.html
09:22:09 <Gurkenglas> (And many (Just 2) ought to be repeat 2)
09:31:15 <cheater> :t many
09:31:16 <lambdabot> Alternative f => f a -> f [a]
09:31:35 <cheater> :i Maybe
09:31:45 <cheater> o
09:36:03 <cheater> welp
09:36:12 <cheater> it seems like that's not correct, Gurkenglas.
09:36:33 <cheater> it would be something like Just $ repeat 2.
09:41:29 <Gurkenglas> uh of course, I must have been elsewhere mentally
09:53:56 <nshepper1> > many (Just 2)
09:54:02 <lambdabot>  mueval-core: Time limit exceeded
09:54:21 <c_wraith> nshepper1: some and many don't really work for a lot of instances of Alternative
09:54:40 <c_wraith> nshepper1: they mostly work with things that are parser-like.
09:54:40 <nshepper1> I've only seen them work for parsers lol
09:55:40 <c_wraith> I guess in theory, they can work with anything state-like
09:55:56 <c_wraith> parsers just happen to be state-like in a way that makes them always work.
09:56:43 <nshepper1> They can "work" with any action that can "sometimes fail", right?
09:57:35 <nshepper1> many . pure is probably never going to do anything useful, because pure never fails
10:02:25 <xcmw> Is there any downside to using 
10:02:37 <xcmw> freer-effects over transformers
10:29:25 <c_wraith> xcmw: some effects don't commute.  In the cases where you're using a set of effects that doesn't commute, freer-effects doesn't let you specify the order they need to happen in, but transformers does.
10:32:13 <xcmw> c_wraith: Don't they run in the order you run them in in both freer-effects and transformers?
10:33:27 <c_wraith> xcmw: they run in the order you specify the run operations, sure.  But with mtl/transformers, you can make it a type error to run them in the wrong order.  You can't do that with freer-effects
11:12:31 <Tuplanolla> John A De Goes gave a talk about this recently, xcmw.
11:13:04 <Tuplanolla> Here's the recording: https://www.youtube.com/watch?v=JLevNswzYh8
11:16:09 <dmj`> 11198 for # of hackage packages, does that sound right
11:26:20 <reactormonk[m]> To publish a package, should I read cabal or stack docs?
11:27:04 <monochrom> To publish it on hackage, read cabal docs. To publish it on stackage, read stack docs. To do both, read both docs.
11:30:16 <dmj`> reactormonk[m]: cabal check, cabal sdist, cabal upload dist/*.tar.gz
11:31:48 <dfeuer> reactormonk[m]: you should definitely publish on Hackage if you're publishing; Stackage is downstream from there.
11:32:00 <reactormonk[m]> A bit more specific, I wanted to create a package containing instances for aeson for a custom data type - which package name should it go to?
11:32:06 <reactormonk[m]> kk
11:32:30 <reactormonk[m]> Orphan instances, etc.
11:33:46 <Tuplanolla> How about `aeson-x-orphanage` with your type in place of `x`?
11:36:49 <iqubic> Hello Guys
11:58:28 <ertes> are ixset and ixset-typed still state of the art?
12:19:22 <kamyar> hi all
12:19:31 <kamyar> please help me with this wuestion
12:19:36 <kamyar> question
12:24:38 <geekosaur> you have to ask it to get help...
12:28:31 <tsahyt> Is it possible to partially apply a type family?
12:28:59 <kamyar> geekosaur: I need help about MessagePack
12:29:05 <kamyar> and I want to paste code
12:29:10 <hpc> tsahyt: no, type families behave like type aliases in that respect
12:29:12 <geekosaur> tsahyt, no, type level things can't be partially applied
12:29:20 <tsahyt> okay thanks
12:29:23 <hpc> tsahyt: iirc you can partially apply data families
12:29:26 <geekosaur> @paste -- kamyar, code goes here
12:29:27 <lambdabot> Haskell pastebin: http://lpaste.net/
12:29:37 <tsahyt> hpc: thanks, that might be worth a look
12:30:46 <kamyar> Ths is code : http://lpaste.net/256818986803527680
12:32:07 <tsahyt> hmm, there's no such thing as closed data families I suppose?
12:33:15 <kamyar> Any help?
12:35:59 <glguy> tsahyt: GADTs?
12:36:14 <tsahyt> ah right
12:36:25 <geekosaur> kamyar, so what is the question?
12:37:23 <kamyar> geekosaur: The part defining MessagePack instance is buggy
12:37:39 <kamyar> geekosaur: I just copied from Json but it is wrong
12:38:32 <Sh4rPEYE> I have hlint 1.9 installed with stack. How do I update it?
12:38:50 <cocreature> Sh4rPEYE: how exactly did you install it?
12:39:55 <cocreature> Sh4rPEYE: the short answer is: build a newer version and copy it to ~/.local/bin. for the latter you can use "stack install". how you build a newer version is up to you. one solution is to bump your global snapshot
12:40:02 <cocreature> another is to tell stack to install a specific version
12:40:10 <cocreature> or just checkout the hlint git repo
12:40:47 <Sh4rPEYE> stack install hlint, I think
12:41:32 <kamyar> geekosaur: Anyone answered?
12:41:52 <geekosaur> kamyar, I cannot answer this as I don;t use the web stuff
12:41:59 <geekosaur> but, so far what I know is exacly what you said.
12:42:25 <geekosaur> which is to say, not how it is buggy, not what errors it gave you or what behavior you expected vs. the behavior you got.
12:42:38 <geekosaur> and drawing details out little by little becomes tiring
13:06:45 <bollu> do failed pattern matches inside "do" use MonadFail?
13:08:55 <glguy> eventually
13:09:07 <cocreature> atm they use Monad’s fail method
13:09:16 <glguy> and specifically in the case of: pattern <- expression
13:09:46 <glguy> (not other lets or cases)
13:12:37 <cocreature> huh, apparently 8.0 already includes a -XMonadFailDesugaring extension that uses the new MonadFail class
13:14:50 <Gurkenglas> https://www.haskell.org/cabal/release/cabal-1.24.2.0/doc/API/Cabal/Language-Haskell-Extension.html <- "MonadFailDesugaring	
13:14:50 <Gurkenglas> A temporary extension to help library authors check if their code will compile with the new planned desugaring of fail."
13:15:12 <dfeuer> Nice. When't the change happen for real?
13:17:33 <Tuplanolla> Should I put `build: haddock: false` into `~/.stack/config.yaml` or `~/.stack/global/config.yaml`? The documentation doesn't say.
13:18:15 <dfeuer> Tuplanolla: that's because stack is poorly documented, IME.
13:18:58 <cocreature> Tuplanolla: I don’t think that has any effect since stack doesn’t build haddocks by default anyway
13:19:07 <cocreature> Tuplanolla: what are you trying to do?
13:19:17 <Tuplanolla> I want offline documentation for everything I install.
13:20:01 <cocreature> in that case don’t you want "haddock: true" instead of "haddock: false"?
13:20:15 <Tuplanolla> I do.
13:20:16 <cocreature> (I don’t know whether that works)
13:22:43 <Tuplanolla> It's not at all clear if I even want Stack.
13:23:20 <cocreature> Tuplanolla: https://github.com/commercialhaskell/stack/issues/880#issuecomment-230757744 seems like it does what you want
13:23:41 <Tuplanolla> Which file?
13:24:26 <cocreature> I think config.yaml should work
13:24:34 <cocreature> the other is for your global project not for global config options
13:24:54 <Tuplanolla> Very well; thanks.
13:25:01 <recycletrash> Hello, I was hoping someone could explain to me why this function is named accordingly. twiceOptional :: (a -> b -> c) -> Optional a -> Optional b -> Optional c ... twiceOptional f = applyOptional . mapOptional f
13:26:02 <cocreature> recycletrash: probably “twice” comes from receiving two Optional arguments and Optional comes from those arguments being optionals
13:26:21 <geekosaur> because it checks both Optional-s and shortcircuits for either, otherwise produces the result of applying the function
13:29:45 <recycletrash> Ah thanks. geekosaur & cocreature just made the light bulb go off. 
13:36:19 <monochrom> This is why I hate English. When the light bulb turns on, it goes off.
13:38:57 <Tuplanolla> If x, y, z, as expected.
13:39:26 <Tuplanolla> (Replace variables with expressions to recover four different meanings.)
13:45:21 <recycletrash> Yes, I apologize for the english expression. It most likely has to do with "goes off", often meaning happens suddenly. 
13:45:46 <geekosaur> yeh, but its especially unfortunate for light bulbs because you prefer them not to act like flashbulbs :p
13:46:41 <recycletrash> True. It's too bad english lightbulbs have to work twice as hard. 
13:55:39 <fotonzade> hey guys
13:55:42 <fotonzade> I'm back
13:56:26 <fotonzade> I read the contents of a file and I want to break it into an array of lines
13:56:34 <fotonzade> main = do
13:56:35 <fotonzade>     [f]     <- getArgs
13:56:35 <fotonzade>     content <- readFile f
13:56:35 <fotonzade>     [hargle] <- lines content
13:56:39 <fotonzade> what am I doing wron ghere
13:56:55 <fotonzade> I'm getting this error
13:56:56 <fotonzade>     parse error on input ‘<-’
13:56:56 <fotonzade>     Perhaps this statement should be within a 'do' block?
13:57:15 <geekosaur> sounds like indentation, so piut the actual code somewhere
13:57:16 <geekosaur> @paste
13:57:16 <lambdabot> Haskell pastebin: http://lpaste.net/
13:57:20 <geekosaur> ^
13:57:26 <geekosaur> that said I seea logic error
13:57:33 <geekosaur> [f] means match a 1-argument list
13:57:54 <fotonzade> ah
13:57:55 <geekosaur> likewise [hargle] means match a 1-element list... hope your file has one line in it
13:58:01 <geekosaur> also: lines is pure, use let not <-
13:58:18 <geekosaur> use <- when doing something in IO, like readFile
13:58:28 <thang1> I would've assumed [f] meant matching on a list of type f since that's what it is in type signatures
13:58:34 <fotonzade> let hargle = lines content ?
13:58:40 <geekosaur> fotonzade, yes
13:58:46 <fotonzade> gives me a parse error :(
13:58:55 <fotonzade> 47:9: parse error on input ‘let’
13:58:55 <geekosaur> again you still have that indentation issue
13:59:05 <fotonzade> I'm using tabs
13:59:10 <fotonzade> is that a problem :(
13:59:11 <geekosaur> repeating: put the actual code, and the full actual error message, in the pastebin
13:59:15 <fotonzade> okay cool
13:59:17 <geekosaur> @paste
13:59:17 <lambdabot> Haskell pastebin: http://lpaste.net/
13:59:42 <thang1> fotonzade: tabs "aren't" a problem, but your life becomes much easier if you use pure spaces for everything.
13:59:43 <geekosaur> and yes, tabs can be a problem. especially if mixed with spaces, because editors don't always agree how tabs and spaces match up
13:59:54 <fotonzade> http://paste2.org/kAh6CCvn
14:00:12 <fotonzade> oh theres a haskell pastebin, I'll use that 
14:00:20 <fotonzade> from now on. my code is above
14:00:50 <mauke> fotonzade: look at your paste
14:00:56 <fotonzade> ah it IS indentation
14:00:59 <fotonzade> thanks a lot guys
14:01:17 <thang1> No problem
14:01:34 <thang1> Also your allEqual looks really complicated for what should be a super simple function...
14:02:14 <thang1> I'm also of the opinion that if you have to comment your data types with what they represent, your data types aren't useful enough :p
14:02:18 <fotonzade> thang1, the problem is that I really dont know haskell
14:02:31 <fotonzade> and I have an assignment
14:02:34 <thang1> No problem! We're all here to learn
14:02:43 <fotonzade> I am having conflicting feelings about haskell
14:02:50 <fotonzade> its really cool but also infuriating
14:02:58 <thang1> Ahh you're learning from a class? What learning materials are y'all using?
14:03:15 <fotonzade> Thompson's textbook IIRC
14:03:55 <Tuplanolla> That's normal, fotonzade. Haskell is an ugly language for beautiful ideas.
14:04:33 <thang1> That looks like a horrifying textbook to learn haskell from...
14:05:13 <fotonzade> :D I just look at slides and LYAHFGG
14:05:38 <thang1> That book isn't super great for haskell either :p I much prefer Haskell from First Principles (which I'm learning from)
14:05:46 <geekosaur> .oO { I must not tab. tab is the code-killer. ... }
14:05:55 <dfeuer> If you really want to use tabs, use dmwit_'s style.
14:06:25 <thang1> for example, I look at your allEqual function and immediately think of foldl or simple recursion
14:06:28 <Cale> If you really want to use tabs, reconsider your life choices.
14:06:33 <thang1> (folding is also recursion)
14:07:09 <dfeuer> Cale: now now, tabs are really useful if you have a typewriter!
14:07:23 <maerwald> spaces increase file size
14:07:33 <dfeuer> Very true.
14:07:53 <Tuplanolla> Trailing spaces do that more elegantly.
14:08:06 <maerwald> I thought those are dead
14:08:18 * mniip is a proud tab user
14:08:33 <dfeuer> Spaces probably do actually increase the size of a large project (like GHC) substantialy.
14:09:02 <iqubic> I use spaces always
14:09:11 <dfeuer> It's probably best to avoid whitespace altogether, and just use braces and semicolons as necessary.
14:09:15 <mniip> dfeuer, that is easily defeated with virtually any compression algorithm
14:09:47 <dfeuer> mniip: for sure, but that doesn't help save disk space....
14:10:10 <dfeuer> (Unless you're using a compressed filesystem, and who does that?)
14:10:14 <fotonzade> s/\t/    /
14:11:08 <maerwald> dfeuer: yeah, probably has a real impact on world-wide resource consumption
14:11:27 <Cale> lol
14:11:37 <dfeuer> What is funny?
14:11:41 <Cale> I have entire series of television shows on my drive
14:11:57 <maerwald> do they use tabs?
14:12:00 <thang1> fotonzade: Your allEqual function can also be written as : allEqual xs = and $ map (== head xs) (tail xs)
14:12:04 <mniip> $ du -hd 0 ghc
14:12:05 <mniip> 2.0G	ghc
14:12:08 <mniip> that's a couple episodes
14:12:14 <thang1> or, alternatively: allEqual xs = all (== head xs) (tail xs)
14:12:42 <fotonzade> thang1, I realize that that is cooler
14:12:50 <fotonzade> but I really dont trust myself to understand that
14:12:52 <mniip> thang1, I'd replace tail with drop 1
14:13:02 <mniip> then you can avoid the empty list case
14:13:02 <[exa]> tabs vs spaces on #haskell? like, isn't there a text editor that abstracts that problem out transparently?
14:13:11 <maerwald> [exa]: oh you xD
14:13:14 <thang1> (tail in this case still works with empty lists because map does not evaluate the nodes, just hte spine)
14:13:18 <thang1> s/hte/the/
14:13:30 <mniip> no?
14:13:37 <mniip> @let allEqual xs = all (== head xs) (tail xs)
14:13:39 <lambdabot>  Defined.
14:13:41 <mniip> > allEqual []
14:13:44 <lambdabot>  *Exception: Prelude.tail: empty list
14:13:50 <thang1> oh whoops nvm
14:13:57 <mniip> @let allEqual' xs = all (== head xs) (drop 1 xs)
14:13:59 <lambdabot>  Defined.
14:14:00 <mniip> > allEqual' []
14:14:02 <lambdabot>  True
14:14:05 <thang1> if you write it as: and $ zipWith (==) xs (tail xs) 
14:14:08 <thang1> then it works with empty lists
14:14:10 <Cale> [exa]: It's not really much of a debate here -- all actual Haskell projects use spaces.
14:14:26 <mniip> thang1, that depends on the zipWith implementation
14:14:37 <mniip> which I'd advise to avoid
14:14:50 <thang1> True, good points. I don't really use it much for that reason
14:14:52 <Cale> [exa]: The reason for this is that it actually matters which column things line up in, so the fact that different editors treat tabs differently is just unacceptable.
14:15:04 <hpc> because haskell is alignment-sensitive, the tab stop behavior was chosen to match the typical defaults of text editors
14:15:07 <hpc> that
14:15:16 <hpc> and of course, those defaults are awful
14:15:35 <hpc> so tab moves alignment to the next 8-space tab stop
14:15:37 <Athas> Doesn't GHC warn about tabs these days?
14:15:42 <mniip> -fno-warn-tabs
14:15:46 <Cale> You can set your tabstops to be multiples of 8 spaces, and that'll match what the compiler treats them as, but people will *still* hate you, because their editor might not treat them that way.
14:15:52 <maerwald> is alignment-sensitivity really part of the report?
14:16:03 <Cale> yes
14:16:03 <hpc> yes
14:16:18 <thang1> fotonzade: Your solution checks the length a lot. So it'll perform pretty terribly, and it's also not very understandable compared to the other ones
14:16:20 <mniip> Cale, not if your code is not sensitive to the tab width
14:16:35 <Cale> Well, sure, you can very carefully avoid it
14:16:40 <thang1> "and" and "all" are very standard functions. So are things like map. They're difficult to really grasp at times, but once you understand them, they're very powerful
14:16:42 <hpc> fwiw, i hate when people use tabs even when it doesn't matter
14:16:48 <fotonzade> :(
14:16:53 <Cale> hpc: Yeah, me too.
14:16:54 <mniip> fite me
14:16:59 <maerwald> we should write a tab-safe subset of haskell
14:17:03 <hpc> seeing code randomly decrease in indentation because i have a different stop size is frustrating
14:17:11 <thang1> It's all good. Trust me, I wrote super terrible shit when I first started writing haskell. I still suck at it for anything that isn't trivial
14:17:13 <Cale> maerwald: That's easy, just always use braces and semicolons
14:17:19 <hpc> and i use :set list in order to see the true contents of a file in vim
14:17:22 <hpc> so tabs show up as ^@
14:17:30 <Cale> maerwald: Then it's whitespace insensitive.
14:17:30 <maerwald> Cale: like SPJ? :P
14:17:41 <mniip> ^@ ?
14:17:43 <mniip> not ^I ?
14:17:48 <mniip> that would make more sense
14:17:52 <hpc> i have seen both
14:18:01 <thang1> You can customize which symbol you see for tabs
14:18:11 <hpc> looks like it's ^I on this machine
14:18:12 <monochrom> Indent by 3.14159 spaces.
14:18:13 <thang1> I have a unicode -> arrow for my tab with :set show
14:18:38 <dfeuer> I hate to see excessive braces and semicolons, but SPJ has the cred to do whatever the heck he wants.
14:19:11 <Cale> SPJ looking out for the blind Haskell users.
14:19:35 <thang1> Anyway, I wanted to ask: I'm really interested in summer of haskell and really want to get in to that.
14:19:56 <dfeuer> Cale: I think blind programmers probably need to use tools that understand Haskell syntax well anyway.
14:20:04 <Cale> Yeah, probably.
14:20:11 <thang1> Only problem is I'm still around chapter 11 of HFFP (I plan to try and finish before summer). I don't quite know what sorts of projects the community is interested in, though.
14:20:21 <[exa]> anyway, I always wanted to ask whether there isn't an utf blank that would mean "indent one level in". That would probably solve all this
14:20:22 <monochrom> We do have a blind Haskell user. We should ask them.
14:20:29 <thang1> Anyone have any sorts of suggestions for me to look into?
14:20:33 <Cale> [exa]: Well, what's "one level"?
14:20:41 <hexagoxel> one space
14:20:43 <dfeuer> monochrom: who's "we"?
14:20:52 <monochrom> The Haskell community.
14:21:37 <monochrom> The only way I knew was because they asked people on haskell-cafe to cut back on attachments because attachments messed with their screen reader.
14:21:39 <[exa]> Cale: one level in current indentation. Like a tab, but without that ugly 8space measure stuck to it
14:21:42 <hexagoxel> you could just configure your editor so it shows multiple spaces per space. and use single-space indentation.
14:22:12 <Cale> [exa]: It matters which column things align to, since that determines whether they're a continuation of a block (the first non-whitespace character following a layout keyword sets the block depth), or close it (if they're shallower than that column), or are a continuation of a line in that block (if deeper than that column)
14:22:26 <[exa]> hexagoxel: that would do it, thanks for inspiration
14:22:39 <dfeuer> Ah. According to http://stackoverflow.com/a/2149878/1477667 at least one blind Haskell programmer uses braces and semicolons. Or did back in 2010.
14:22:41 <monochrom> Or maybe it was just non-ascii characters.
14:23:26 <Tuplanolla> I just have to say that two space per level is nice, because most fonts are about 1:2, so levels are built from squares.
14:23:49 <Cale> Yeah, my tab key is set to insert 2 spaces
14:25:19 <thang1> I honestly have never really gotten my tab key where I want it in emacs so I just kinda don't really bother with it
14:25:37 <[exa]> Cale: I thought that's easily decided by just counting columns (exactly the count of "magic spaces"). But I wouldn't like to be the actual editor trying to guess where to put which column. Good point
14:25:44 <boxscape> thang1 you just press space repeatedly?
14:26:02 <Cale> [exa]: You can have stuff like:
14:26:11 <monochrom> I like tibbe's advice on this. Four spaces because it's two spaces for "where" and two more spaces for the rest. Also makes "main = do { ... } where {...}" unmisleading.
14:26:13 <Cale> foo x y = let z = ...
14:26:32 <Cale> Now the following line has to line up with the z in order to be a continuation of the let
14:26:45 <thang1> pffh no, boxscape, I use spacemacs. I just use tab wherever and get things to close-enough and then let hindent and stylish-haskell take care of everything else
14:26:59 <thang1> I don't write enough haskell at a high enough level to be particular, yet.
14:27:29 <boxscape> So you do use tab. I parsed "I don't really bother with it" as meaning that you don't
14:27:39 <fotonzade> guys is there an easy way to split a string like "4 3 2 1" into an array from the spaces
14:27:54 <boxscape> > words "4 3 2 1" -- this?
14:27:56 <lambdabot>  ["4","3","2","1"]
14:27:57 <Cale> What I *would* really like is if my editor understood the layout rule properly and was able to move an entire block of code correspondingly whenever an edit caused the first non-whitespace character following a layout keyword to change position.
14:28:26 <boxscape> admittedly, that's a list, not an array, but if you really do want an array, a list is a good starting point
14:28:28 <[exa]> Cale: doesn't there have to be "in"? (maybe not, I don't know many details about hs syntax)
14:28:34 <Cale> boxscape: We use the tab *key*, but apart from a few weirdos here, not tab characters
14:28:41 <[exa]> :]
14:28:55 <Cale> [exa]: yeah, but you might want to put more definitions inside the let portion
14:28:55 <boxscape> Cale: right, but thang1 talked about their tab key
14:28:59 <Cale> ah
14:29:25 <monochrom> Now you get to debate over using the tab key vs the capslock key. :)
14:29:46 <Cale> I have caps lock as compose :)
14:29:48 <boxscape> I just have capslock mapped to escape
14:29:52 <Tuplanolla> Caps Lock for Hyper.
14:30:00 <[exa]> Ctrl here
14:30:37 <monochrom> Also ripe for a dvorak keyboard joke.
14:31:03 <monochrom> "I use the Q key for quotes" or something.
14:31:26 <[exa]> actually thinking about remapping tab to something after the discussion here, escape looks useful :]
14:32:07 <rightfold> I remapped numpad to additional function keys
14:32:58 <Tuplanolla> I'm surprised you didn't all die trying to figure out XKB.
14:33:12 <[exa]> :]
14:33:26 <monochrom> We did. Satisfaction brought us back.
14:33:43 <monochrom> "Curiosity kills the cat. Satisfaction brings it back!"
14:33:45 <thang1> My caps is control + escape :p
14:33:48 <rightfold> Windows Registry, actually.
14:34:13 <boxscape> I use xmodmap and AutoHotkey, depending on OS
14:34:55 <thang1> I use xkb but not super extensively
14:35:01 <geekosaur> you have to remap the numpad? try application keypad mode >.>
14:35:08 <geekosaur> alhtough I guess x11 makes that harder...
14:35:35 <thang1> I'd love to have an insane setup like this http://stevelosh.com/blog/2012/10/a-modern-space-cadet/
14:35:39 * geekosaur also uses wincompose on windows, so the compose key acts the same everywhere
14:36:10 <thang1> Well if nobody has any advice about Summer of Haskell, I'll start on my quantum computing homework
14:36:15 <rightfold> My setup is Linux in a VM for development, and Windows as host for Chrome, Spotify and games. Because drivers.
14:36:43 <thang1> man, fuck drivers. I feel your pain. I still haven't bothered to get printer drivers installed on arch linux... I'm sure it's easy, but I just can't be fucked
14:36:53 <Tuplanolla> How did we end up here?
14:37:12 <rightfold> Linux as workstation but not in a VM is too difficult IMO :)
14:37:27 <Cale> It's not that difficult
14:37:35 * geekosaur got epson drivers for debia/ubuntu/mint easily enough
14:37:55 <fotonzade> guys
14:37:56 <fotonzade> extractVotes :: Int -> [String] -> [[Int]]
14:37:56 <fotonzade> extractVotes num textlines = [singleVote x | x <- (splitAt (num+1) textlines !! 1)]
14:38:04 <geekosaur> also I do linux as a workstation... but I don't do much in the way of games. that's what the game console is for :p
14:38:04 <fotonzade> what's wrong with my list comprehension
14:38:30 <fotonzade> http://paste2.org/ZNzpeV7L
14:38:33 <fotonzade> ^ error output
14:38:42 <Cale> fotonzade: splitAt (num+1) textlines is a pair
14:38:47 <Cale> !! wants a list
14:38:55 <geekosaur> :t splitAt
14:38:57 <lambdabot> Int -> [a] -> ([a], [a])
14:39:11 <thang1> Most of my problems in haskell can be solved with the glorious :t command
14:39:13 <thang1> It's amazing
14:39:19 <Cale> But also, just never use (!!)
14:39:22 <iqubic> I like it.
14:39:26 <geekosaur> also note that splitAt only goes off once
14:39:37 <iqubic> Why should you never use (!!)?
14:39:41 <monochrom> fotonzade: What is a typical example of the [String] parameter?
14:39:41 <fotonzade> cool
14:39:41 <boxscape> is there a safe version of (!!)?
14:39:45 <iqubic> :t (!!)
14:39:46 <lambdabot> [a] -> Int -> a
14:39:48 <thang1> I find !! to be useful in small doses and sparingly, but if you're trying to find the indicies of things all the time, it's not very functional
14:39:49 <geekosaur> safety isn;t really the issue
14:39:52 <geekosaur> it's *slow*
14:39:55 <Cale> Because it kills your program if the index is out of bounds, and it's slow
14:40:02 <geekosaur> because lists are not arrays
14:40:07 <Cale> If you need !!, you shouldn't have been using a list to begin with
14:40:14 <thang1> It's also not really the right way to think about things, I've found. aka ^
14:40:27 <boxscape> I mean, if you have (!! 2) in your code, it's constant runtime
14:40:28 <geekosaur> fotonzade, in any case I suspect you didnot want splitAt
14:40:30 <geekosaur> :t chunksOf
14:40:31 <monochrom> And yeah, there is something to be said about a program both slow and incorrect :)
14:40:32 <lambdabot> Int -> [e] -> [[e]]
14:41:02 <Cale> Yeah, there are cases where you just don't really care very much and it's convenient that (!!) exists
14:41:07 <Cale> But generally, avoid it.
14:42:01 <Cale> thang1: It's not so much that it's not functional, but that it doesn't go well with linked lists
14:42:13 <boxscape> I found it a bit annoying that there's no safe version of Data.Array.!, unless I missed it
14:42:17 <Cale> thang1: This would be true of linked lists in any language
14:42:38 <monochrom> boxscape: You didn't miss it. Data.Array was specified at a time people didn't care about that.
14:42:42 <boxscape> I see
14:43:02 <geekosaur> for most things you probably want Vector instead of Array
14:43:07 <boxscape> that's good to know
14:43:08 <geekosaur> although Array certainly hs its uses
14:43:15 <thang1> Cale: that's what I was getting at, but you articulated it better. Thanks
14:43:30 <geekosaur> but Vector is what most people are thinking of when they think list/array
14:43:40 <dfeuer> I kind of like the arrays in the primitive package.
14:45:10 <boxscape> what's the difference between head and unsafeHead in Vector? the types are the same...
14:45:35 <monochrom> head still does a bound-check and bottoms out. unsafeHead doesn't even try that.
14:45:57 <monochrom> unsafeHead is directly C's "a[0]"
14:46:02 <boxscape> ah, ok, that makes sense
14:49:42 <iqubic> What is bottom?
14:50:06 <iqubic> Or undefined?
14:50:25 <Cale> Bottom is the mathematical value which we assign to nonterminating computations, or ones whose evaluation throws an exception
14:50:57 <Cale> Its name comes from a partial ordering on each type, of which it is the minimum value
14:51:30 <iqubic> So something like sqrt -1?
14:51:36 <iqubic> :t sqrt
14:51:38 <lambdabot> Floating a => a -> a
14:51:46 <iqubic> > sqrt -1
14:51:48 <lambdabot>  error:
14:51:48 <lambdabot>      • No instance for (Typeable a0)
14:51:48 <lambdabot>          arising from a use of ‘show_M47739095637439521496725’
14:51:50 <Cale> sqrt (-1) :: Complex Double
14:51:52 <Cale> > sqrt (-1) :: Complex Double
14:51:54 <lambdabot>  0.0 :+ 1.0
14:51:59 <Cale> > sqrt (-1) :: Double
14:52:00 <iqubic> That works??
14:52:01 <lambdabot>  NaN
14:52:05 <c_wraith> more like..
14:52:09 <Cale> ^^ NaN still isn't bottom
14:52:09 <c_wraith> > let x = x in x
14:52:15 <lambdabot>  mueval-core: Time limit exceeded
14:52:15 <Cale> yeah, more like that one ^^
14:52:25 <Cale> Or undefined, or error "foo!"
14:52:37 <iqubic> > error "foo!"
14:52:40 <lambdabot>  *Exception: foo!
14:52:46 <monochrom> I prefer the informational view. Insufficient data for a meaningful answer.
14:52:50 <Cale> > fix error
14:52:52 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
14:53:01 <iqubic> How does error handling work in haskell?
14:53:03 <iqubic> :t fix
14:53:05 <lambdabot> (a -> a) -> a
14:53:06 <geekosaur> iqubic, note with the one that failed on you that negative numeric literals are an odd corner case; it's safest to use parentheses
14:53:29 <iqubic> > sqrt (-1)
14:53:31 <lambdabot>  NaN
14:53:32 <geekosaur> there's also the NumericLiterals extension which changes things to behave a little more like expected... unless what you expect is IEEE negative zero to work >.>
14:53:46 <iqubic> What does fix do?
14:53:55 <boxscape> huh, fix error is interesting
14:53:58 <Cale> iqubic: Well, exceptions thrown from the evaluation of expressions can technically be caught, but pragmatically, I would always avoid it, to the extent that I would be willing to fork someone's library before bothering with it.
14:54:01 <boxscape> @src fix
14:54:01 <lambdabot> fix f = let x = f x in x
14:54:04 <boxscape> ^ iqubic 
14:54:05 <iqubic> > fix (\x -> x^2
14:54:07 <lambdabot>  <hint>:1:15: error:
14:54:07 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:54:08 <c_wraith> > negate 0 :: Double
14:54:10 <iqubic> > fix (\x -> x^2)
14:54:10 <lambdabot>  -0.0
14:54:16 <lambdabot>  mueval-core: Time limit exceeded
14:54:26 <iqubic> Why doesn't my fix operation work?
14:54:28 <iqubic> > fix (\x -> x^2)
14:54:34 <lambdabot>  mueval-core: Time limit exceeded
14:54:34 <Cale> It does
14:54:35 <boxscape> iqubic: this is a good read on fix: https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
14:54:42 <geekosaur> iqubic, it finds the least fixed point of an expression. of ten that is bottom/nontermination, but if an expression converges to a non-bottom constant value then fix will find that
14:54:45 <Cale> fix will compute the least-defined fixed point of a given function
14:54:47 <geekosaur> generally
14:55:00 <Cale> If bottom happens to be a fixed point of the function, that's what you will get
14:55:40 <Cale> i.e. if the function f gives a totally-undefined result for a totally-undefined input, then fix f will be totally undefined
14:55:41 <iqubic> geekosaur: Shouldn't 1^2 = 1 work though?
14:55:55 <Cale> iqubic: That's not the *least-defined* fixed point
14:56:15 <iqubic> > fix (\x -> false && x)
14:56:17 <lambdabot>  error:
14:56:17 <lambdabot>      • Variable not in scope: false :: Bool
14:56:17 <lambdabot>      • Perhaps you meant data constructor ‘False’ (imported from Data.Bool)
14:56:23 <iqubic> > fix (\x -> False && x)
14:56:26 <lambdabot>  False
14:56:29 <geekosaur> iqubic, you need to understand what least-defined means
14:56:36 <iqubic> What does it mean?
14:56:48 <Cale> Well, the ordering is defined separately for each type
14:56:58 <geekosaur> the least defined fixed point there is bottom, the non-value. 1 is a fixed point but it is more defined than bottom, so it is not found and bottom is
14:57:06 <fotonzade> okay so what should I use to get an element of a list by index
14:57:15 <fotonzade> like the 4th element of an array
14:57:16 <Cale> But generally, x <= y whenever one can substitute occurrences of _|_ (bottom) in x somehow in order to obtain y
14:57:17 <fotonzade> if not !!
14:57:29 <geekosaur> fotonzade, you use a Vector if you want to do that, generallyt
14:57:34 <fotonzade> :(
14:57:38 <c_wraith> fotonzade: you generally try to avoid needing to do that.
14:57:40 <geekosaur> the problem is not (!!) itself. the problem is lists are not arrays/vector
14:57:45 <geekosaur> lists are linked lists
14:57:51 <geekosaur> you have to iterate them to find the Nth element
14:57:52 <Cale> iqubic: For example, if we consider the type [Bool]
14:58:01 <iqubic> > fix reverse
14:58:03 <Cale> iqubic: You have _|_ at the bottom
14:58:07 <lambdabot>  mueval-core: Time limit exceeded
14:58:07 <geekosaur> if you;re going to be indexing a lot, lists are not your friend
14:58:08 <boxscape> > error (error "x") -- I would expect this to print just one exception. Is this really counter intuitive or is it me?
14:58:10 <lambdabot>  *Exception: *Exception: x
14:58:15 <Cale> and then immediately above that are [] and (_|_ : _|_)
14:58:20 <boxscape> Actually
14:58:23 <boxscape> I think I understand
14:58:26 <monochrom> The fun begins when you say "sometimes I need to append things, some other times I need the ith item"
14:58:27 <fotonzade> I'm getting this error in my code
14:58:29 <fotonzade> voting: Prelude.!!: index too large
14:58:41 <fotonzade> how do I find where in the code it happnes?
14:58:49 <Cale> and then above (_|_ : _|_) lies (False : _|_) and (True : _|_) and (_|_ : []) and (_|_ : (_|_ : _|_))
14:59:30 <Cale> This ordering is directed-complete, in that any infinite ascending chain will have a limit in [Bool]
14:59:49 <iqubic> > fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 5
14:59:51 <lambdabot>  120
15:00:01 <iqubic> what the heck is that???
15:00:06 <c_wraith> boxscape: technically, GHC is allowed to treat any bottom values as equivalent and optimize things out if it desires.  So when you have situations with nested exceptions like that, it's allowed to compile the code such that any of the contained exceptions are the ones that bubble out.
15:00:07 <Theophane> j #R
15:00:11 <Theophane> wooops
15:00:17 <geekosaur> fotonzade, you can try throwing a HasCallstack constraint on any function that uses (!!)
15:00:36 <boxscape> c_wraith: I see
15:00:44 <geekosaur> sadly the default is not to use call stacks because (a) they;re not, really (b) they're slow, because they're not really call stacks
15:00:57 <Cale> iqubic: fix f = x where x = f x
15:01:05 <sophiag> > (reverse . map (\x -> x -y)) . (map (\x -> y + x) . reverse)
15:01:07 <lambdabot>  <[Expr] -> [Expr]>
15:01:15 <geekosaur> what it really does is attach a big implicit parameter to everything carrying around its history
15:01:19 <iqubic> > fix (\rec f l -> if null l then [] else f (head l) : rec f (tail l)) (+1) [1..3]
15:01:20 <Cale> iqubic: So, if we have  x = (\rec n -> if n == 0 then 1 else n * rec (n-1)) x
15:01:22 <lambdabot>  [2,3,4]
15:01:23 <hpc> iqubic: or somewhat easier to understand, fix f = f (fix f)
15:01:30 <hpc> but cale's definition is faster
15:01:38 <hpc> well, "faster"
15:01:40 <iqubic> > fix (\rec f l -> if null l then [] else f (head l) : rec f (tail l)) (+1) [1..3]
15:01:42 <lambdabot>  [2,3,4]
15:01:42 <Cale> iqubic: then  x = \n -> if n == 0 then 1 else n * x (n-1)
15:01:43 <sophiag> hmm, not sure what the answer to that means. i guess lambdabot is morally correct
15:02:21 <iqubic> > map (fix (\rec n -> if n == 1 || n == 2 then 1 else rec (n-1) + rec (n-2))) [1..10]
15:02:24 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
15:02:30 <c_wraith> sophiag: it means lambdabot current has a Show instance for functions in scope.
15:02:44 <Cale> iqubic: Generally, you can take any simply recursive function, and encode it using fix by making the function itself the first argument to the lambda you supply to fix
15:02:46 <boxscape> > split
15:02:48 <lambdabot>  error:
15:02:48 <lambdabot>      • No instance for (Typeable a0)
15:02:48 <lambdabot>          arising from a use of ‘show_M78839445066777044367275’
15:02:53 <iqubic> Ah.
15:02:54 <fotonzade> http://paste2.org/vNz3N1Ny
15:02:55 <boxscape> not for functions in general though
15:02:59 <boxscape> it seems
15:03:04 <monochrom> @type split
15:03:04 <fotonzade> I am completely stumped as to where this !! problem could be happening
15:03:05 <lambdabot> Splitter a -> [a] -> [[a]]
15:03:18 <sophiag> c_wraith: i know. i was just seeing what would happen as that's the most common example of having to deal with bottom in lazy languages
15:03:20 <fotonzade> if you guys can spot it instantly could you help me out
15:03:23 <c_wraith> > fix $ (0:) . scanl (+) 1 -- iqubic or even recursive non-functions
15:03:25 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:03:31 <MarcelineVQ> :t y
15:03:33 <lambdabot> Expr
15:03:45 <Cale> sophiag: also, note that lambdabot has x and y in scope
15:03:50 <Cale> > x
15:03:52 <lambdabot>  x
15:03:54 <Cale> :t x
15:03:55 <lambdabot> Expr
15:03:57 <sophiag> oh
15:03:58 <MarcelineVQ> sophiag: idk it it was intentional but y isn't in scope in your expression, so lambdabot is using the y it does have in scope which is an Expr
15:04:22 <sophiag> i wasn't sure what i expected it to return anyway
15:04:24 <sophiag> id?
15:04:31 <sophiag> error?
15:04:34 <iqubic> Can I get someone to explain Prisms weird type synonym?
15:04:59 <monochrom> fotonzade: In getByNum, "x !! id-1"? "x !! (id-1)"?
15:05:16 <iqubic> type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
15:05:23 <iqubic> I don't get that.
15:05:37 <sophiag> iqubic: since you keep asking about optics i'm wondering if there's interest in going through an example of refactoring code to use lenses and prisms? (being clear that it would be a first for me as well)
15:05:52 <iqubic> But more specifically I don't understand this: prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b Source #
15:06:07 <iqubic> ignore the Source # there
15:06:15 <fotonzade> <monochrom> fotonzade: In getByNum, "x !! id-1"? "x !! (id-1)"?
15:06:21 <fotonzade> let me check this out
15:06:26 <fotonzade> thank you
15:06:41 <iqubic> why does it have Either as the return type of the second input function?
15:06:50 <iqubic> I don't understand that at all.
15:06:57 <Cale> iqubic: Because you might not find the thing of type a
15:07:05 <c_wraith> iqubic: because a prism is not a complete isomorphism.  It can fail in one direction
15:07:20 <Tuplanolla> Man, it took almost two hours to compile Hakyll...
15:07:51 <iqubic> Yes, but why is there an Either data type?
15:07:55 <iqubic> I don't get that.
15:08:12 <Cale> iqubic: So in the case where the prism fails to get your thing of type a, you're still going to have to produce something of type t in the end.
15:08:34 <Cale> So, it just makes you provide an Either t a, with the final result being the Left case of the Either.
15:09:18 <iqubic> So going from B to T always works.
15:09:36 <iqubic> however going from S to A might fail?
15:09:55 <c_wraith> yes
15:10:24 <c_wraith> and if it fails, you need to give a fallback value.
15:10:29 <Cale> iqubic: You can read the Prism definition above as
15:10:52 <Cale> type Prism s t a b = forall f. (Applicative f) => (a -> f b) -> (s -> f t)
15:11:04 <Cale> i.e. so it's the same as Traversal
15:11:10 <iqubic> How might someone write a prism into a Maybe?
15:11:28 <iqubic> toMaybe = Just
15:12:02 <iqubic> fromMaybe x
15:12:09 <iqubic>    | Just x = x
15:12:21 <iqubic>     | Otherwise = Nothing
15:12:35 <iqubic> prism toMaybe fromMaybe
15:12:39 <iqubic> Is that right?
15:12:44 <c_wraith> the basic idea is right, the syntax is...  in need of help. :)
15:13:07 <iqubic> Why is the syntax wrong?
15:13:21 <Cale> _Just = prism Just (maybe (Left Nothing) Right)
15:13:22 <c_wraith> also, you need an Either in the other case, so you need a Left or RIght constructor
15:13:45 <iqubic> Why do you need an Either?
15:13:55 <iqubic> isn't _Just a Prism'?
15:14:18 <Cale> yes, I just defined it
15:14:34 <iqubic> So why do you need an Either?
15:14:46 * sophiag is still serious about offering a practical case to refactor code with lenses and prisms...
15:14:46 <Cale> hm?
15:15:14 <glguy> :t matching _Just
15:15:15 <lambdabot> Maybe a -> Either (Maybe b) a
15:15:33 <glguy> In the case that _Just doesn't "match", it can change the type of its argument
15:15:44 <iqubic> Oh.
15:16:58 <iqubic> Why do you need an Either.
15:17:08 <c_wraith> iqubic: because that's what prism requires?
15:17:18 <c_wraith> iqubic: also, because otherwise the two cases don't return the same type
15:17:23 <Cale> :t prism
15:17:25 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
15:17:46 <Cale>                                                ^^
15:18:07 <c_wraith> sadly, the location of those carets depends on how you have things aligned. :)
15:18:17 <iqubic> Why is _Just a Prism and not a Prism'?
15:18:27 <c_wraith> :t _Just
15:18:28 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
15:18:40 <Cale> _Just :: Prism (Maybe a) (Maybe b) a b
15:18:51 <iqubic> What does that even mean?
15:19:05 <Cale> If it were Prism (Maybe a) (Maybe a) a a then we could use Prism' (Maybe a) a
15:19:26 <Cale> But it's allowed to change the type of the Maybe which is being traversed
15:19:29 <iqubic> Why is it not Prism (Maybe a) (Maybe a)?
15:19:37 <iqubic> How does it do that??
15:19:44 <Cale> > over _Just show (Just 5)
15:19:46 <lambdabot>  Just "5"
15:19:55 <Cale> > over _Just show Nothing
15:19:57 <lambdabot>  Nothing
15:20:23 <iqubic> I don't get it.
15:20:39 <Cale> > _Just (\x -> Identity (show x)) (Just 5)
15:20:41 <lambdabot>  Identity (Just "5")
15:20:49 <Cale> > runIdentity (_Just (\x -> Identity (show x)) (Just 5))
15:20:51 <lambdabot>  Just "5"
15:20:57 <iqubic> What is that doing?
15:20:59 <c_wraith> You can use _Just to "change" the type of an expression.
15:21:10 <Cale> It's a traversal
15:21:11 <c_wraith> That's why it has different type variables
15:21:15 <Cale> In the usual sense
15:21:48 <Cale> There is a difference between _Just and traverse though.
15:22:25 <Cale> :t traverse :: Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
15:22:27 <lambdabot> Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
15:22:31 <Cale> :t _Just :: Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
15:22:33 <lambdabot> Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
15:22:42 <Cale> even though they can have the same type
15:23:24 <iqubic> Can you show me an example of changing the type?
15:23:31 <Cale> I just did
15:23:34 <Cale> using show
15:23:49 <Cale> We turned the 5 :: Integer into "5" :: String
15:24:12 <glguy> over _Just show :: Maybe Integer -> Maybe String
15:25:14 <Cale> The difference between _Just and traverse is that since _Just is a prism, we can "turn it around" with re/review
15:25:23 <Cale> :t re _Just
15:25:25 <lambdabot> (Functor f, Contravariant f) => (Maybe a -> f (Maybe a)) -> a -> f a
15:25:55 <c_wraith> :t review _Just
15:25:57 <lambdabot> MonadReader a m => m (Maybe a)
15:26:19 <c_wraith> hah.  I forgot that uses MonadReader for maximal surprise.
15:26:27 <Cale> haha
15:26:36 <c_wraith> > review _Just 5
15:26:38 <lambdabot>  Just 5
15:26:38 <Cale> This stuff, man
15:27:05 <iqubic> is that turning a into Maybe a?
15:27:08 <c_wraith> yes
15:27:24 <iqubic> And is that why you need Either?
15:27:30 <Cale> Just to be clear, I *strongly* avoid lens in actual code unless there's really a good case for it.
15:27:55 <Cale> There are some cases where you're modifying some deeply nested field, and lens saves you a bunch of trouble
15:28:07 <iqubic> What's the definition of _Just again?
15:28:15 <Cale> But a lot of the time, lens is a great way to get trivial things done in an incomprehensible way
15:28:38 <Cale> _Just = prism Just (maybe (Left Nothing) Right)
15:28:56 <sophiag> Cale, you strongly avoid lenses? i'm debating right now whether to refactor my code with them...and i don't actually have nested records, just types that have turned into spaghetti
15:29:56 <boxscape> I like Lens with the State Monad. Though admittedly I haven't done much with it
15:29:59 <monochrom> My greatest (and only one) application of lens (just the idea anyway) so far is unifying two branches of the rotation algorithm for binary search trees.
15:30:28 <Cale> There are a bunch of things in the lens toolkit which I still sometimes make use of
15:30:30 <iqubic> :t maybe
15:30:31 <Cale> I use zoom
15:30:32 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:30:39 <sophiag> monochrom, that's pretty interesting.
15:30:43 <iqubic> What does maybe do?
15:31:01 <c_wraith> maybe is a destructor for Maybe values
15:31:14 <Cale> maybe nothing just = g where g Nothing = nothing; g (Just x) = just x
15:31:16 <c_wraith> it captures the entire logic of a pattern-match
15:31:16 <iqubic> I see.
15:31:23 <monochrom> in which you have one version for rotate-left and one version for rotate-right and they are exact mirror images of each other and you wonder "can I just plug in a parameter to request the left or right version?"
15:31:35 <EvanR> its kind of *the* destructor for Maybe, since you can do any other destructor with it
15:31:38 <sophiag> hmm
15:32:01 <monochrom> It turns out that it looks best with two parameters, not just one.
15:32:07 <sophiag> monochrom: that makes sense. do you have that code somewhere i can look at?
15:32:20 <iqubic> > maybe False odd (Just 2)
15:32:22 <lambdabot>  False
15:32:26 <iqubic> I see.
15:32:39 <iqubic> > maybe False odd (Nothing)
15:32:41 <lambdabot>  False
15:32:51 <monochrom> You say "rotate (the lens for left child) (the lens for right child)" for one direction, "rotate (the lens for right child) (the lens for left child)" for the other direction.
15:32:57 <Cale> maybe (Left ()) Right (Just 4)
15:33:02 <Cale> > maybe (Left ()) Right (Just 4)
15:33:04 <lambdabot>  Right 4
15:33:05 <Cale> > maybe (Left ()) Right Nothing
15:33:07 <lambdabot>  Left ()
15:33:20 <iqubic> :t maybe (Left Nothing) Right
15:33:21 <lambdabot> Maybe b -> Either (Maybe a) b
15:33:27 <monochrom> I don't have it handy right now.
15:33:30 <iqubic> What does that function do?
15:33:51 <sophiag> so basically instead of using a zipper you're treating the entire tree like a product type?
15:33:58 <iqubic> I was not aware that Right was a function.
15:34:00 <EvanR> often you can tell what a function does just from the type sig
15:34:12 <boxscape> :t Right
15:34:13 <lambdabot> b -> Either a b
15:34:18 <iqubic> I see.
15:34:31 <boxscape> iqubic: any data constructor that takes arguments is a function
15:34:38 <iqubic> Ah. I see.
15:34:45 <iqubic> :t (:+)
15:34:46 <lambdabot> a -> a -> Complex a
15:34:48 <monochrom> Yes, I am ignoring the Leaf case. (It is OK because by the time you decide to rotate, you already know it is not Leaf.)
15:35:05 <sophiag> that's kind of awesome
15:36:46 <sophiag> i'm just debating whether to use lenses to eliminate all these crufty helper functions for wrapping and unwrapping types, but probably need to at least try and simplify the types altogether first
15:37:46 <iqubic> So why isn't _Just a Prism'?
15:37:47 <sophiag> i feel like i've come up against something like a second learning curve with haskell where my programs are starting to get slightly too complex for the way i'm structuring the types in them
15:38:01 <iqubic> Can I see an example of a Prism'?
15:38:46 <Cale> Prism' a t is just shorthand for Prism a a t t
15:38:56 <boxscape> :t _Right :: Prism' (Either c1 t1) t1
15:38:58 <lambdabot> (Applicative f, Choice p) => p t1 (f t1) -> p (Either c1 t1) (f (Either c1 t1))
15:39:05 <Cale> er, that was backward, convention-wise
15:39:16 <Cale> type Prism' s a = Prism s s a a
15:39:29 <iqubic> Why is _Right a Prism'?
15:39:47 <iqubic> Can I see how you'd write _Right?
15:39:53 <Cale> :t _Just :: Prism' (Maybe a) a
15:39:54 <lambdabot> (Applicative f, Choice p) => p a (f a) -> p (Maybe a) (f (Maybe a))
15:40:04 <Cale> _Just *can* be a Prism'
15:40:09 <Cale> It's just that it's more general than that
15:40:20 <Cale> :t _Right
15:40:21 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either c a) (f (Either c b))
15:40:28 <Cale> Same goes for _Right
15:40:34 <iqubic> How would one write _Right?
15:40:46 <Cale> Click its source link
15:41:23 <Cale> on any of the documentation pages, in the right margin, you'll see # Source on every definition
15:41:39 <iqubic> Cool.
15:41:58 <boxscape> you can also search for _Right using hayoo, which might get you there faster
15:41:59 <Cale> The # is a link to that part of the documentation (so you can share it), and the Source link goes to highlighted, hyperlinked source.
15:42:18 <Cale> (note, different packages will differ in these features, but lens is good about it)
15:43:41 <SolitaryCypher> I'm reading the Parsec paper and have a quick question. It mentions XML requires a context-sensitive parser, but I thought that XML was a context-free langauge?
15:44:20 <SolitaryCypher> Oh wait I got it. Brackets are context free because they don't have labels. The labels require context. Nevermind
15:46:20 <unyu> SolitaryCypher: If you have only finitely many possible tags, the language becomes context-free again, me thinks.
15:47:15 <unyu> s/tags/labels/
15:51:05 <monochrom> Yes, it's just like having 3 kinds of parentheses, [] () {}
15:52:10 <Cale> I'm not sure about that though, since there's more to XML than just the tags.
15:52:14 <unyu> Anyway, now on to my actual question. I'm taking a survival analysis class, where we use R, but I want to use Haskell instead. I don't expect there to be many survival analysis libraries in Hackage, but I could implement my own if there are *good* numerical method implementations available - I shouldn't have to debug my programs only to find an error in the numerical method I'm calling.
15:52:31 <unyu> What's the state of numerical methods in Haskell today?
15:53:03 <Cale> unyu: There are various bits and pieces. hmatrix is a binding to a bunch of BLAS/LAPACK stuff.
15:53:30 <unyu> What about compile-time dimensional analysis?
15:53:38 <bollu> what's "survival analysis?"
15:53:43 <unyu> R's handling of multidimensional arrays is... well... atrocious.
15:54:10 <Cale> unyu: I know various people have done stuff for that, but I'm not sure what's usable
15:54:35 <monochrom> main = do <curry> print <round> head <square> 1, 2, 3 </square> </round> </curry>
15:55:07 <unyu> bollu: Inferential statistics, where the variable of interest is “time until X happens”. That time could be any nonnegative real number, but in practice, you can't wait infinite time until X happens. Or for whatever reason, one of your study subjects becomes impossible to observe after a point in time. So you need to deal with incomplete (statisticians call this “censored”) data.
15:55:26 <unyu> Cale: Ah!
15:55:34 <bollu> ah, that is interesting
15:55:49 <unyu> Yes, but R is incredibly frustrating to use.
15:57:13 <EvanR> its interesting to hear doubts about R and looking at haskell
16:01:56 <MarcelineVQ> what is meant by compile-time dimensional analysis?
16:02:14 <EvanR> unit checking?
16:02:22 <EvanR> unit conversion?
16:02:25 <unyu> Errr, I'm not so interested in units of measure. I'm mainly interested in matrix dimensions.
16:02:32 <EvanR> matrix dimensions
16:02:45 <MarcelineVQ> ah hmm well you can enforce dimentions at compile-time with hmatrix through https://hackage.haskell.org/package/hmatrix-0.18.0.0/docs/Numeric-LinearAlgebra-Static.html
16:02:54 <unyu> Oh, sweet! Checking.
16:02:55 <MarcelineVQ> jle` has a couple posts on it at   https://blog.jle.im/entry/practical-dependent-types-in-haskell-1.html   https://blog.jle.im/entry/practical-dependent-types-in-haskell-2.html
16:03:00 <iqubic> > review _Just "Hello"
16:03:03 <lambdabot>  Just "Hello"
16:03:13 <iqubic> > preview _Just Nothing
16:03:16 <lambdabot>  Nothing
16:03:23 <MarcelineVQ> It's evolving ground for Haskell though so there's a bit to learn to get going
16:03:23 <iqubic> > preview _Just Just "Hello"
16:03:25 <lambdabot>  error:
16:03:25 <lambdabot>      • Couldn't match type ‘Maybe b0’ with ‘[Char] -> t’
16:03:25 <lambdabot>        Expected type: (a0 -> Maybe a0) -> [Char] -> t
16:03:34 <iqubic> > preview _Just (Just "Hello")
16:03:36 <lambdabot>  Just "Hello"
16:04:17 <iqubic> :t Preview
16:04:18 <lambdabot> error:
16:04:18 <lambdabot>     • Data constructor not in scope: Preview
16:04:18 <lambdabot>     • Perhaps you meant one of these:
16:04:22 <iqubic> :t preview
16:04:24 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
16:04:33 <iqubic> :t review
16:04:35 <lambdabot> MonadReader b m => AReview t b -> m t
16:05:16 <c_wraith> > preview _Just (Nothing)
16:05:18 <unyu> I'd be happy if the compiler can keep track of how many indices a particular array has. I don't mind if the exact sizes of matrices are checked at runtime.
16:05:18 <lambdabot>  Nothing
16:05:58 <EvanR> unyu: isnt that the exact opposite expectations
16:06:12 <unyu> EvanR: Opposite to what?
16:06:17 <EvanR> tracking at compile time would obviously be better
16:06:19 <EvanR> than runtime
16:06:43 <EvanR> so either i misunderstand or it doesnt really matter what it does
16:06:52 <unyu> EvanR: What I'm saying is that there are two things to track: (0) how many indices an array has, (1) how many possible values does each index have.
16:07:03 <EvanR> oh
16:07:06 <unyu> I absolutely want (0) to be statically checked, but don't mind if (1) is dynamically checked.
16:07:10 <EvanR> 3d vs 4d vs whateverd array
16:07:14 <unyu> Yeah.
16:07:41 <EvanR> "how many indexes it has" confused me. i think they call that the shape
16:07:55 <unyu> Ah...
16:10:19 <iqubic> How does this work? maybe (Left Nothing) Right
16:11:28 <unyu> Mmm, maybe you want Left (), rather than Left Nothing?
16:11:33 <MarcelineVQ> iqubic: ask ghci about the types
16:12:30 <glguy> iqubic: What kind of answer are you hoping to get to that question?
16:12:30 <iqubic> unyu: That's exactly what I want.
16:12:53 <unyu> iqubic: Substituting into the definition of “maybe”, you should get something like “\x -> case x of { Just x -> Right x ; Nothing -> Left () }”
16:13:15 <iqubic> Ah, I see.
16:13:23 <iqubic> @src maybe
16:13:23 <lambdabot> maybe n _ Nothing  = n
16:13:24 <lambdabot> maybe _ f (Just x) = f x
16:14:00 <iqubic> I see how that works now.
16:14:02 <iqubic> Cool.
16:14:05 <unyu> :-)
16:21:29 <iqubic> @src ($)
16:21:29 <lambdabot> f $ x = f x
16:21:38 <iqubic> I see
16:33:58 <sleffy> Is there a reason that there appears to be no Random instance for Natural?
16:34:28 <EvanR> the api has a thing for uniformly random value of the type
16:34:59 <EvanR> which is fudged for Double by only going from 0.0 to 1.0
16:35:37 <EvanR> you can only get a random Natural by using a non uniform distribution
16:36:40 <EvanR> also Natural is relatively new on the scene and isnt recognized by many old guard libs
16:41:39 <EvanR> experiment: if you start at 0, flip a coin, heads return 0, otherwise increment the counter and try again... you get an exponential decay distribution. 
16:42:00 <EvanR> next, do it again rolling 1d4 and only return the counter if you get a 1
16:42:14 <unyu> How's Natural internally implemented? Is it a big unsigned int?
16:42:45 <EvanR> next, keep increasing the sides of the dice, your random Naturals will become bigger and bigger as it takes longer to return an answer
16:43:03 <EvanR> in the limit, the random Natural will be infinite and the algorithm "probably" never terminates
16:43:31 <EvanR> Natural is just an Integer that errors on negative
16:43:37 <unyu> Ah.
16:43:45 <EvanR> > (-1) :: Natural
16:43:47 <lambdabot>  *Exception: Natural: (-)
16:43:56 <EvanR> hmm 
16:44:03 <EvanR> > fromInteger (-1) :: Natural
16:44:05 <lambdabot>  *Exception: Natural: fromInteger
16:46:49 <MarcelineVQ> :t fromInteger . abs <$> getRandom :: m Natural
16:46:50 <lambdabot> error:
16:46:51 <lambdabot>     Variable not in scope: getRandom :: m1 Integer
16:47:08 <MarcelineVQ> :t fromInteger . abs <$> getRandom -- oops don't need the last bit :>
16:47:09 <lambdabot> error:
16:47:09 <lambdabot>     Variable not in scope: getRandom :: f Integer
16:47:19 <MarcelineVQ> oh, well there's that too, nvm me
16:49:48 <EvanR> actually, if you truncate that experiment at some very large dice size, youll get a working algorithm, though very slow and numbers will be huge
16:50:48 <EvanR> and kind of uniform
16:51:25 <EvanR> the difference in probability between n1 and n2 near each other is low
16:52:15 <monochrom> Integer is a Random instance and it is a bit mysterious which distribution it follows.
16:52:38 <monochrom> But whatever it does, Natural could suffer the same fate.
16:52:39 <EvanR> uniform in the range 0 to max int
16:53:37 <MarcelineVQ> you can pick distributions with random-fu but I don't know enough about distributions to try
16:54:17 <monochrom> Actually the range is min Int to max Int
16:55:21 <monochrom> Also I just learned that "Ival" is a cool way to spell "Interval"
16:55:34 <EvanR> oh
16:57:29 <monochrom> do { ct <- getCPUTime; (sec, psec) <- getTime; return (createStdGen (sec * 12345 + psec + ct + o)) }
16:57:56 <monochrom> Studies show that there was no studies to support the choice of multiplying by 12345 there. :)
17:01:05 <unyu> Data.List should totally have a function “sortDesc = sortBy (flip compare)”.
17:01:15 <unyu> I can't imagine being the only one who needs it.
17:01:46 <sophiag> ugh, anyone want to give me some advice on refactoring some complicated data types? 
17:01:49 <MarcelineVQ> monochrom: I saw that the other day when trying to figure out what MonadRandom did for IO :>
17:02:23 <ezyang> what kin dof advice 
17:05:10 <sophiag> ezyang: well the types i've defined have made it too complicated for me to debug the last remaining bit so i have to think there's a better way to do this. i tried simplifying it a bit, but just traded one operational issue for another with less type safety
17:06:19 <sophiag> like i considered using lenses, but it really has nothing to do with nesting
17:06:58 <sophiag> i'm not sure where to go from here other than that it's getting exponentially more difficult to fix the remaining code
17:07:42 <ezyang> what kind of invariants are you enforcing with types 
17:09:59 <sophiag> i have two records the each have fields that store multiple types, hence created ADTs for both. however, it's become increasingly difficult coercing them to interact to the point i have each ADT wrapping one another and both recursively wrapping themselves
17:10:31 <ezyang> so... they are interchangeable in some sense? 
17:10:52 <sophiag> what is "they"?
17:10:55 <ezyang> the two records 
17:11:26 <ezyang> you talked about coercing 
17:12:11 <sophiag> if they were interechangable i would not have two of them
17:12:16 <sophiag> so no
17:12:37 <ezyang> what are the problems when they interact? 
17:12:49 <sophiag> they're of different types...
17:12:49 <ezyang> is the problem that they form a cyclic graph and you want to update this graph? 
17:12:52 <sophiag> no
17:13:26 <ezyang> "they're of different types" elaborate? 
17:13:41 <sophiag> it's ok, i'll just repeat
17:14:26 <ezyang> The last message I read from you is 20:01 
17:14:48 <sophiag> there's a fundamental confusion here
17:16:58 <sophiag>  i have two adts. one are just list types of the same ones in the other because i don't want the lists to be heterogenous yet need to pattern match for them so some cases make it not feasable to use a type variable to enforce that. on top of that, each ADT has a data constructor that recursively wraps itself as a list type and (for purposes of type coercion) one that wraps the other ADT. so i've mentioned three things here that are
17:16:58 <sophiag>  convoluted hacks and they've caught up to me in terms of my ability to debug the few remaining problems with the code.
17:26:47 <ezyang> hmm, could you make a simple example? 
17:26:58 <ezyang> so, basically, you want to enforce an invariant that everything in the list has the same type? 
17:27:40 <sophiag> yes, that's one of the three issues i mentioned. 
17:28:01 <sophiag> here's an example: http://lpaste.net/354629
17:29:25 <ezyang> maybe you should have done a GADT/existential 
17:30:34 <ezyang> or the fancy new type-indexed Typeable hotness. What version of GHC do you need this to work for 
17:30:58 <sophiag> well it uses pattern synonyms so i suppose 7.8
17:31:32 <ezyang> this one: https://ghc.haskell.org/trac/ghc/wiki/Typeable 
17:31:34 <sophiag> anyway, i don't see how a GADT would solve any of the three problems i mentioned. can you explain that?
17:32:03 <sophiag> i know what Typeable is
17:32:19 <sophiag> again, i don't understand how any of these suggestions would solve any of the three problems i asked about
17:33:09 <Navajo> i need help
17:37:04 <Navajo> what is this channel
17:37:51 <asciiascetic> its about a programming language called haskell. Are you from kansas? I noticed a school called haskell is there :)
17:38:22 <Navajo> i'm not from kansas no, but I do want to learn haskell
17:38:33 <Navajo> you can teach me?
17:39:03 <asciiascetic> haha, probably not. But I am occassionally using it, and teachers are here.
17:39:23 <Navajo> in what ways is haskell used?
17:41:01 <asciiascetic> hmm... it is often used to write other langauges (see purescript and elm languages, for examples)
17:41:39 <Navajo> hmm
17:41:46 <asciiascetic> it is used to create web applications and to create other kinds of network server applications
17:43:07 <asciiascetic> and a great many other things - i'm sure that google is a better keeper of that information than I am, but thats how I've used it and seen it used.
17:43:37 <Navajo> I see
17:46:36 <unyu> If I do “data Foo = Foo { bar, qux :: !Double }”, it means that both “bar” and “qux” are strict fields, right?
17:49:12 <sophiag> unyu: do you not need to define fields distinctly?
17:49:23 <pacak> unyu: I would say so.
17:49:27 <unyu> Ah...
17:49:42 <unyu> sophiag: I'm pretty sure you can define two fields together, if both have the same type.
17:50:06 <unyu> Mmm... This OverloadedRecordFields seems not to interact very well with type inference. :-(
17:50:49 <sophiag> oh i see
17:51:05 <sophiag> sorry, i can't answer that
17:52:06 <pacak> unyu: Do you have a nice example when it's not working well even when it should be obvious?
17:55:54 <unyu> pacak: http://lpaste.net/354658
18:02:38 <sophiag> i'm using breakpoints in ghci for the first time and having a bit of trouble understanding them. what does it mean when it returns a hole? like "i :: Integer = _"
18:03:57 <peddie> sophiag: might that mean it's not yet been evaluated (it's still a thunk)?
18:04:20 <sophiag> really?
18:04:25 <peddie> I'm not sure
18:04:29 <sophiag> oh
18:05:41 <peddie> you could try    :force i   and see whether it has a value after that
18:06:33 <sophiag> well, following up on what you suggested yesterday...i couldn't figure out how to enforce homogeneity of lists with a type variable and still pattern match for them. but out of frustration i did just go ahead and allow for heterogenous lists anyway and it fixed one problem and now is breaking the part where i parse lambdas. my intuition is i was *never* parsing lambdas correctly and just didn't know because they weren't being applied
18:06:48 <sophiag> so now trying to debug that function in this new version
18:07:07 <sophiag> (it's returning Nothing no matter what...)
18:07:32 <peddie> sophiag: sounds like some progress.  out of curiosity, what does the whole program actually do?
18:07:49 <sophiag> it doesn't feel like much progress :(
18:08:01 <sophiag> i feel like i've hit a wall with haskell in general
18:08:16 <peddie> how so?
18:08:16 <sophiag> this program is a dsl for programming with constraints
18:09:02 <sophiag> like i understand the type system and monad hierarchy and such, but my programs are now just complex enough they become exponentially more difficult as i go along due to spaghetti-like type structure
18:09:45 <peddie> it can take a while to get the hang of designing the types so that they reduce complexity
18:09:49 <peddie> or at least it did for me
18:09:52 <sophiag> yeah exactly
18:10:08 <sophiag> i was thinking the solution might be optics, but i'm not actually nesting records here
18:10:35 <MarcelineVQ> sophiag: what code have you got atm?
18:10:52 <sophiag> i have literallly three versions...lol
18:11:15 <peddie> sophiag: do you have any tests for your program?  one thing that took me a while to discover was that if I refactored my program so I could write better quickcheck tests, it almost always made my program structure better as well
18:11:45 <sophiag> well i was just thinking maybe HUnit (which i normally woudln't be into) could be of use here
18:11:54 <sophiag> the problem is i'm parsing functions so there's no show instance
18:12:00 <sophiag> i'm trying to debug something that's totally opaque
18:12:09 <peddie> helps me think about separating things out when the properties can't be statically enforced
18:12:47 <sophiag> let me paste the version i refactored today since it has the old code commented out
18:13:09 <sophiag> so you can see two versions that compile yet both have different operational issues
18:13:58 <peddie> sophiag: OK, I'll take a look -- don't have a ton of time today, but we'll see how we go :)
18:14:02 <sophiag>  ok, here it is: http://lpaste.net/354660
18:14:09 <MarcelineVQ> peddie: that makes a lot of sense, a similar thing can happen when you break something down to ask a question about it, it can solve itself in a sense
18:14:58 <sophiag> so the main eval function i call from the dsl is on line 258...my best guess is that wasn't actually evaluating lambdas before i changed the types as you can see in the comments
18:15:36 <peddie> sophiag: I see you've now put the list types into `AmbVal` -- haven't made it to nearly 258 yet :)
18:15:43 <sophiag> the point it's failing is in parseExpr on line 185. it always returns Nothing. i didn't change that code at all hence why i think those lambdas just weren't being initially applied
18:16:15 <sophiag> peddie: right. as mentioned, i couldn't figure out how to make it work how you suggested so just allowed heterogenous lists in Amb
18:16:24 <sophiag> figured i'd solve that later
18:16:59 <sophiag> it really seems parsing lambdas is where it fails
18:17:34 <sophiag> and i'm not sure i'm parsing lists in them correctly to begin with, which is necessary for the dsl to actually do anything. however, it still returns Nothing without lists
18:19:03 <peddie> sophiag: any interest in using an external parsing library, like megaparsec or something?
18:19:14 <sophiag> for what?
18:19:32 <peddie> for doing your parsing
18:19:34 <sophiag> i'm already using a library to parse ASTs and that's all there is
18:20:06 <peddie> ah OK, I just saw this table of operators on 169 and thought "there's a library that can do this"
18:20:17 <sophiag> yeah, and i'm using it
18:20:19 <peddie> but if most of it is coming from an AST already, then never mind
18:20:27 <sophiag> megaparsec actually CANNOT do this
18:21:14 <peddie> hmm, what, have a table of reserved binary operators?  I thought it could -- but you're right, it's not relevant to the immediate problem here
18:21:28 <sophiag> it has nothing to do with this
18:21:49 <sophiag> i'm not parsing anything by hand
18:22:29 <sophiag> all i'm doing is storing the results of matching haskell ASTs in data structures
18:22:59 <peddie> sophiag: it seems at first glance like there is a lot of Maybe plumbing that is happening by hand, but that is also not relevant to why it's not parsing lambdas
18:23:47 <peddie> can you change your `parseExpr` from returning a `Maybe` to returning an `Either`, and in the case of failure, say something about why it failed or the term that didn't match?
18:24:15 <sophiag> Either what?
18:24:31 <Squarism> sometimes its not very obvious when you declare function signatures what things are. Like : type SomeFkn = String -> Bool -> Int
18:24:33 <sophiag> as stated, it does fail no matter what the input is
18:24:46 <sophiag> you can't print functions...
18:24:50 <Squarism> is there some common way to tackle that when implementation isnt around?
18:25:14 <Squarism> should one use type alias / designators? 
18:25:43 <peddie> sophiag: is there anything useful you could print when it returns `Nothing`?  for example, could you print the `Exp` value that failed to match?
18:25:49 <sophiag> Squarism: i'm not sure the question. that function would take a String and a Bool and return an Int
18:25:52 <peddie> sophiag: `Exp` has a `Show` instance, it looks like
18:26:17 <sophiag> peddie: i suppose...but i already know the Exp
18:26:22 <sophiag> that's the AST
18:26:31 <geekosaur> Squarism, I think you can feed a type to :kind! in ghci and get the expansion?
18:26:46 <sophiag> plus i'd have to refactor the entire code to accept an either type and print it in the dsl's repl
18:26:46 <geekosaur> (the ! is important)
18:27:47 <geekosaur> sophiag, the problem Squarism is talking about is when some other type uses SomeFkn and it looks like a "normal value" but is a function that is being partially applied
18:27:49 <peddie> sophiag: I don't understand this program well enough yet to have a better suggestion at the moment.  it seems like if it's returning `Nothing`, then at some point, the Exp doesn't match one of the cases you've laid out in `parseExpr`
18:27:57 <geekosaur> this does tend to lead to brain-breaking stuff
18:28:08 <sophiag> pedie: yes, exactly
18:28:09 <geekosaur> and the web frameworks all seem to thrive on it...
18:28:19 <Squarism> sophiag, yes.. but its not obvious what what they imply. Like String could be "A-prefix-that-will be added to something", Bool could be "Make warnings be failures" and Int could be "temperature"
18:28:31 <Squarism> ..bad example but you get my point
18:28:59 <geekosaur> Squarism, that's the downside of using short names for things. that's often a good thing for type variables, often bad for value bindings :/
18:29:13 <peddie> sophiag: so it seems like returning `Either Exp (AmbVal -> Maybe AmbVal)` or something like that would let you inspect the exact Exp that didn't match
18:29:21 <sophiag> peddie: here's what it the two variables look like
18:29:21 <Squarism> geekosaur, oh ok
18:29:29 <peddie> sophiag: and thus see why parsing failed
18:29:37 <sophiag> var: [PVar (Ident "x")]
18:29:46 <sophiag> body: (InfixApp (Var (UnQual (Ident "x"))) (QVarOp (UnQual (Symbol "=="))) (Lit (Int 0)))
18:29:53 <sophiag> some form like that
18:30:05 <sophiag> i don't need to print them since they always come in that form
18:30:25 <peddie> sophiag: if they always come in that form, then pattern matching always succeeds, right?  and thus parsing always succeeds?
18:30:51 <sophiag> parsing alwayss succeeds because they're not being parsed in this code
18:30:59 <sophiag> matching never succeeds, which is what we're discussing
18:31:32 <peddie> sophiag: sorry; when I say "parsing," I'm referring to what `parseExpr` is doing -- seems reasonable to call it parsing given that the function has "parse" in its name :)
18:31:36 <sophiag> oh i have an idea
18:31:36 <geekosaur> Squarism, however you also touch on another issue commonly described as "boolean blindness": people use a Bool because it exists, when data MyWhatever = This | That is cheap
18:31:42 <geekosaur> and makes the intent clearer
18:32:27 <geekosaur> likewise using tuples instead of an ADT; a tuple could be anything, the ADT at least can tell you what it's supposed to be
18:32:37 <Squarism> geekosaur, ah - glad there is a word for it!
18:32:59 <peddie> sophiag: let me rephrase without saying "parse": if they're always in that form, then matching always succeeds, and thus `parseExpr` always returns `Just <whatever>`.  but that's not happening, so at some point, the Exp has to not match, no?
18:33:21 <sophiag> well, i figured i could determine that with breakpoints...
18:33:39 <sophiag> geekosaur: do you know what it means when a breakpoint returns a hole?
18:34:13 <peddie> sophiag: you probably can, but if you just make it spit out the failing Exp every time, you will never have to enter the debugger to debug this bit . . . and it might be useful later on if you need to explain to the user why some input was invalid
18:34:27 <sleffy> Is it possible - I could not possibly care less about how hackily this has to work - to compare two functions for equality by their definitions?
18:34:36 <geekosaur> sleffy, no
18:34:42 <sleffy> i.e. if I define a function `foo`, and a function `bar`, I want to check if `foo` is *exactly* foo or some other function
18:34:47 <sleffy> In any other language I'd do this as function pointer equality
18:34:49 <sleffy> Really? No way?
18:35:24 <sleffy> I can't, say, export them as foreign and somehow get pointers and check equality there?
18:35:26 <geekosaur> there are ways to get pointer equality in Haskell, with some limitations (consider the name a warning: reallyUnsafePtrEquality#)
18:35:41 <sleffy> Yeah I'm willing to deal with that
18:35:47 <sleffy> This whole thing is a giant hack anyways
18:35:54 <geekosaur> but "by their definitions" would mean drilling down into the STG defining it and the machine code behind that, which.
18:36:08 <sleffy> Yeah, I figured that could cause issues
18:36:28 <sleffy> Really what I've got here is I'm abusing GHCi as a little repl, and I have functions to turn it into a little DSL-console
18:36:52 <sleffy> I want to write a `help` function which takes in something and then compares it to what it knows are the pointer-identities of all the functions I've made and maybe gives a nice little message
18:37:06 <geekosaur> sophiag, I'm not even sure what you are talking about, unless you used _ on the right side of a pattern match instead of the left
18:38:34 <sophiag> np
18:38:38 <sophiag> oops
18:38:41 <sophiag> i meant to say no
18:38:48 <sophiag> in fact, it is a problem :(
18:38:48 <geekosaur> a hole is not a thing that exists at runtime, generally. if the compiler said "Found hole at..." then you probably used _ in an expression when you intended a pattern
18:38:59 <sophiag> hmm
18:39:06 <sophiag> ok, that might help...
18:39:17 <geekosaur> or, if you used _ as the pattern, that does not let you refer to _ as the matched expression
18:39:22 <peddie> geekosaur: I thought an underscore in the debugger might mean a thunk that's not yet evaluated
18:39:24 <geekosaur> name it if you want to use it
18:39:35 <geekosaur> well it does depend on context
18:39:46 <geekosaur> if you used :print and it gave you a _, then yes, that's a thunk that was not evaluated
18:39:50 <geekosaur> you would have to step into it
18:39:57 <geekosaur> or force the expression
18:40:23 <geekosaur> :sprint might be your friend there
18:40:23 <peddie> sophiag: you gave context for this debugger question a few minutes ago, maybe you could paste it again?
18:40:48 <geekosaur> when you are debugging, you sometimes need to care what has been evaluated and what hasn't, so you get the _s. :sprint hsould force the whole expression
18:40:54 <sophiag> two examples: "_result :: Maybe (AmbVal -> Maybe AmbVal) = _" and "i :: Integer = _"
18:40:58 <geekosaur> but that could change what continuing execution will do
18:41:07 <geekosaur> ok, yes, those are unevaluated thunks
18:41:10 <geekosaur> try :sprint on them
18:41:17 <peddie> sophiag: I think  _result  is a special debugger variable
18:41:42 <geekosaur> the implicit result is "it"
18:41:54 <sophiag> how do i set :sprint on a breakpoint?
18:42:21 <geekosaur> oh right, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-result-variable
18:42:32 <sophiag> i mean on the rhs tho
18:42:37 <geekosaur> you want to read that
18:42:56 <geekosaur> because the breakpoint stopped when evaluating _result so it is always going to be _
18:43:12 <geekosaur> you can evaluate it explicitly to force it, but that can trigger other breakpoints etc.
18:44:24 <sophiag> uh... if i call ":force parseExpr" i get "parseExpr = _"
18:44:44 <sophiag> maybe it's not a thunk and just unmatched at that line?
18:44:46 <peddie> sophiag: if you use Either Exp instead of Maybe for the result of `parseExp`, you won't have to work out how the debugger works for this ;)
18:45:00 <sophiag> peddie...i already explained why that's prohibitory
18:45:15 <peddie> sophiag: I think you just said that you didn't want to :)
18:45:18 <sophiag> just look at the program and how many functions are between that one and actually printing
18:45:21 <sophiag> uh no
18:45:37 <sophiag> you can see the code and how many lines i'd have to change to do what you're suggesting...
18:46:04 <peddie> sophiag: it's a pretty mechanical change, though
18:46:17 <peddie> sophiag: it's pretty easy to get it right, I think
18:46:25 <sophiag> no it's not
18:46:48 <sophiag> it would require chaning the types of numerous functions, writing new ones to wrap and unwrap them, etc.
18:47:21 <sophiag> it's not "easy" in the scheme of "a test that seems eh ok"
18:47:34 <peddie> sophiag: not sure how to parse that last message
18:48:02 <peddie> sophiag: it would definitely require changing the types of numerous functions, I agree, but having done this same change in many programs, I still think it's quite mechanical.  anyway, good luck with the debugger; I have to run for now
18:48:02 <geekosaur> actually, isn't parseExpr a function here? don;t think you will get anything useful back but a thunk
18:48:08 <sophiag> i mean, it's just a test and not an amazingly great one. it's a large amount of work for an diea that's grasping for straws
18:48:11 <geekosaur> because the thunk can't run until given parameters?
18:48:16 <peddie> sophiag: you might have to apply `parseExpr` to an argument
18:48:29 <geekosaur> if you want the result of running parseExpr, ^ what peddie said
18:48:29 <peddie> or really 2 arguments
18:48:45 <sophiag> geekosaur; the problem is it's never matching so always returning Nothing
18:49:01 <geekosaur> then you need to step it with an expression, I think
18:49:09 <sophiag> oh you mean when i call :force it's not in the context of the breakpoint?
18:49:15 <sophiag> i need *new* arguments?
18:50:11 <geekosaur> you are assuming that the value of parseExpr is the result of running parseExpr
18:50:21 <geekosaur> if you want to see what it is doing, step from the breakpoint
18:50:28 <sophiag> i think i misunderstood you
18:50:40 <geekosaur> parseExpr is *always* a thunk, it is a function not the result of running the function
18:51:07 <geekosaur> either you step into invoking it with some parameters, or you step past the breakpoint to see what the invocation that triggered the breakpoint is doing
18:52:09 <sophiag> hmm so stepping once causes it to stop
18:52:52 <geekosaur> ok, I was afraid of that from what I was reading. I think you have to set breakpoints all over the place :/
18:53:07 <sophiag> inside that one function?
18:53:20 <sophiag> i really want to step through each line frankly
18:53:28 <geekosaur> since haskell code is a single expression, you'd have to set breakpoints in the things called from there
18:53:33 <geekosaur> there is no concept of "each line:
18:53:39 <sophiag> ah
18:53:50 <sophiag> wait, although nothing is called from that line
18:53:53 <sophiag> 186
18:53:53 <geekosaur> even if you used do notation, that turns into a single big expression using >> or >>=
18:54:10 <geekosaur> you *might* be able to set breakpoints in those and then :stepl
18:54:20 <geekosaur> to get the effect of "through each line"
18:54:39 <sophiag> does stopped mean it failed on that line tho?
18:54:51 <sophiag> frankly i'm really really confused
18:55:09 <sophiag> the first line in the function doesn't call any other functions
18:55:21 <sophiag> and that's the one it stops on when i step
18:55:31 <sophiag> so i've only seen holes
18:56:52 <sophiag> hmm ok so from what i can gather it does seem just that one line is breaking it
18:56:55 <sophiag> 186
18:58:55 <jackhill> l
18:59:06 <thang1> a
19:10:24 <unyu> When you freeze or thaw a vector, you're performing a full copy of its elements, right?
19:11:24 <pacak> unyu: Yes, but there's also unsafe  version of freeze and thaw
19:11:46 <Squarism> is there some nice utility that can parse compiler output and group compile errors in some easy navigatable manner? Instead of needing to scroll a long text of black and white console text 
19:12:20 <Squarism> (especially important if yo've done a refactoring that leads to 20 errors or more)
19:12:42 <pacak> Squarism: I usually start fixing them one by one
19:13:30 <MarcelineVQ> iirc there's also an option to spit them out in reverse order if you tend to want to look at the end
19:13:32 <Squarism> pacak, me too. But its still takes time and effort scrolling through a long output
19:13:38 <MarcelineVQ> *start
19:13:41 <Squarism> oh ok
19:13:54 <pacak> Squarism: You can start fixing them from the bottom...
19:14:46 <MarcelineVQ> it's called -freverse-errors
19:15:13 <Squarism> ok thanks
19:15:39 <Squarism> less also works. 
19:17:12 <pacak> Squarism: You can try using ghcid
19:18:35 <Squarism> pacak, thanks. Looks interresting
20:49:24 <moet> is there any real difference between defining a function (\_ -> ...) or (\_name -> ...) ?
20:49:38 <moet> does the compiler recognize both as "unused" variables?
20:49:49 <glguy> it does
20:50:29 <moet> thank you
20:50:41 <geekosaur> I think the main difference is the latter is a named typed hole these days?
20:51:03 <geekosaur> so you can use it afterward, potentially
20:51:16 <moet> hmm.. interesting
20:51:31 <moet> in my case these are typeclass functions, so it has a type.. i'm just not using it
20:51:48 <moet> s/it/the value/g
20:52:29 <geekosaur> hm, actually I don;t think typoed holes fire in patterns, so not even that; it;s just a named binding that the compiler won;t issue "binding not used" warnings for
20:58:39 <sophiag> is there anywhere i can find working code implementing the various interpreters in Wadler's "The Essence of Functional Programming" ? i've tried bits myself and can never get it to compile, but there's just so much in that paper i'd like to learn from. especially the section on continuations
22:12:06 <ertes> i finally sat down and wrote a library for live diagnostics of concurrent activity instead of reinventing it for every application
22:12:10 <ertes> https://hackage.haskell.org/package/progress-meter
22:14:49 <LordBrain> cool
22:22:39 <centril> HList 0.4.2.0 requires  base < 4.9 - but I have base == 4.9.1.0  - what to do in this situation ?
22:22:46 <centril> seems HList hasnt been updated for some time
22:23:38 <monochrom> Use an older GHC. Or modify HList for the newer base.
22:23:42 <pacak> ertes: 404 at linked source....
22:23:42 <moet> centril: sometimes it's sufficient to fork on github, adjust deps, and then reference your fork via stack/cabal file 
22:24:10 <moet> ah :/
22:24:25 <moet> wait, i didn't get a 404
22:24:25 <LordBrain> take what you need from HList and roll it into your own package
22:24:29 <centril> moet: ah :/ was hoping to avoid that... using a github package increases build times
22:24:29 <ertes> pacak: thanks…  it seems that i need to update my docs generation code
22:24:48 <centril> LordBrain: yeah, I'll probably do that
22:24:59 <ertes> pacak: the source code is here: https://github.com/esoeylemez/progress-meter
22:25:16 <centril> btw - what is ETA on GHC 8.4.*  ?
22:25:31 <monochrom> ertes: You have an "as" typoed to "es". :)
22:25:56 <ertes> monochrom: yeah, it's already fixed in the repo =)
22:26:02 <ertes> noticed as soon as i uploaded =)
22:26:10 <monochrom> Haha OK
22:26:13 <ertes> … of course
22:26:49 <pacak> ertes: Nice documentation.
22:26:55 <LordBrain> i didnt get a 404 either
22:27:11 <monochrom> ertes: Does this progress meter simply print to stdout?
22:27:25 <pacak> https://hackage.haskell.org/package/progress-meter-0.1.0/docs/src/System-ProgressMeter.html#runProgress 
22:27:27 <ertes> monochrom: stderr by default, or supplied handle
22:27:31 <pacak>  Page not found  Sorry, it's just not here.  
22:27:39 <monochrom> Ah OK.
22:27:53 <pacak> Not literal 404, but still the same.
22:27:54 <monochrom> w00t ANSI code.
22:27:59 <ertes> monochrom: hWithProgress v. withProgress
22:28:57 <LordBrain> what things were you working on when you needed a progress meter?
22:29:13 <LordBrain> are they on hackage too?
22:29:24 <glguy> ertes: I pushed out documentation with hyperlinked (new-style) source
22:29:35 <ertes> LordBrain: i have a lot of small applications that push data around
22:30:04 <ertes> glguy: thanks!
22:50:21 <iqubic> What's the right way to make a parallel traversal.
22:50:46 <jle`> what do you mean by 'parallel traversal'
22:50:49 <iqubic> Like when using over, my modification function will take a while to complete.
22:51:08 <iqubic> So I want it to be run in parallel on all the elements of my traversal.
22:52:34 <iqubic> So if my traversal is targeting the elements of a Vector, then I want to run my over function in parallel on all the elements of that vector
22:53:02 <unyu> Parallel map?
22:53:19 <unyu> Or parallel reduce?
22:53:31 <iqubic> Parallel map is what I want.
22:53:41 <jle`> there's the async package
22:53:43 <nshepperd> if it's lazy, you should be able to use a library like `parallel` to evaluate the elements in parallel
22:54:10 <nshepperd> after doing the map normally
22:54:45 <cocreature> that won’t work for unboxed vectors
22:56:20 <nshepperd> fmap f xs `using` parTraversable rseq -- for instance
22:57:20 <iqubic> what's parTraversable?
22:57:38 <cocreature> https://hackage.haskell.org/package/parallel-3.2.1.1/docs/Control-Parallel-Strategies.html#v:parTraversable
22:58:37 <iqubic> Ah. And why do you need all that extra stuff.
22:58:58 <iqubic> How do you create a strategy?
22:59:20 <unyu> there are combinators for building strategies out of simpler ones
22:59:26 <unyu> precisely in that module
22:59:28 <iqubic> I see.
22:59:42 <jle`> this book has a good chapter on it too http://chimera.labs.oreilly.com/books/1230000000929
22:59:47 <iqubic> I really need to read up on parallelism before asking questions.
23:01:55 <nshepperd> (rseq :: Strategy a) is a strategy that just evaluates the value to whnf
23:03:09 <iqubic> Sure.
23:03:21 <iqubic> And what does rpar do?
23:03:26 <nshepperd> (parTraversable x :: Traversable f => Strategy (f _)) is a strategy that applies strategy x to each value in the traversable, in parallel
23:03:59 <iqubic> parTraversable is what I wanted.
23:04:11 <iqubic> I just didn't know what it was called.
23:04:12 <nshepperd> so (parTraversable rseq) is a strategy that evaluates each element in a traversable structure to whnf in parallel
23:04:35 <iqubic> why isn't is parTraversable rpar?
23:06:02 <MarcelineVQ> parTraversable already adds rpar
23:06:55 <MarcelineVQ> specifialy using rparWith which is in the same section as rpar
23:08:45 <nshepperd> I think 'parTraversable rpar' would have almost the same effect, except that maybe it doesn't wait for all the evaluations to finish?
23:11:25 <nshepperd> not sure
23:25:00 <MarcelineVQ> seems it would be redundant, and result in unnecessary spark creation since it would be making two sparks for everything and only needing to evaluate one of them
23:27:49 <MarcelineVQ> though that larger the task the less fizzles occur with the doubled rpar
23:28:45 <MarcelineVQ> doesn't seems like it actually matters much on tasks of 100 items
23:29:52 <MarcelineVQ> but it does double spark creation to use  rparWith rpar  :>
23:30:17 <MarcelineVQ> which is what  parTraversable rpar  will do
