00:15:04 <Engen> if I have a list defined as [(String, Bool)] and then another type Formula which contains strings that I want to replace with the Bool equivalents previously defined, would [(a,b)] -> [c] -> [c] be on the right track for lookup in hoogle?
00:16:44 <Engen> actually no, it'd be [(a,b)] -> c -> c 
00:17:22 <cocreature> I don’t think hoogle will help you directly here
00:17:32 <cocreature> @hoogle Eq a => a -> [(a,b)] -> Maybe b
00:17:32 <lambdabot> Prelude lookup :: (Eq a) => a -> [(a, b)] -> Maybe b
00:17:32 <lambdabot> Data.List lookup :: (Eq a) => a -> [(a, b)] -> Maybe b
00:17:32 <lambdabot> GHC.OldList lookup :: (Eq a) => a -> [(a, b)] -> Maybe b
00:17:38 <cocreature> you can use that
00:17:48 <pacak> My brain just exploded.
00:18:06 <cocreature> pacak: you might want to see a doctor in that case
00:18:16 <cocreature> I don’t think brains are supposed to do that
00:19:47 <Engen> cocreature: cool thanks, I think that'll get me started
00:33:34 <dysfun> what's the current status of ghcjs's new code generator that makes smaller code?
00:33:45 <dysfun> is it at all usable yet?
00:34:36 <dysfun> i saw it got the dedupe option on a 6m old reddit post, but luite mentioned this new codegen in a comment and now i'm interested
00:47:13 <shadowswalker> akslfdjalkfjdalskdjflakfjds
00:50:21 <shadowswalker> where to start learning haskell ?
00:51:41 <LordBrain> shadowswalker, install it first, then try some tutorials, i'd say
00:52:11 <dysfun> stack is an easy way to get started
00:52:45 <LordBrain> naturally it depends some on your background
00:52:55 <LordBrain> as to what is probably your best bet for jumping in
00:53:14 <LordBrain> have you programmed other languages etc
00:55:19 <Engen> if I have something like: map (\x -> myFunction x xs) xs does the x take singular values from the list on the inside of the lambda function or from the list that it is being mapped onto?
00:55:46 <dysfun> x is a single item of the list at a time
00:56:03 <Engen> which list though
00:56:11 <dysfun> xs
00:56:15 <Engen> I guess it is cleared to see in map (\x -> myFunction x xs) xy
00:56:20 <Engen> xs or xy?
00:56:25 <dysfun> xy
00:56:35 <pacak> there is no xs declared in second version
00:56:46 <dysfun> you are mapping over xy, therefore x is from xy
00:56:47 <pacak> (no xy either)
00:57:22 <Engen> yeah ok
00:57:51 <Engen> I'm just trying to apply the same logic for replacing elements in some from a lookup table
00:58:23 <Engen> s/some/some data type/
01:02:30 <mjora7> Beginner here, should I be using Cabal?
01:02:44 <mjora7> Or sticking to GHC and makefiles?
01:02:55 <dysfun> cabal makes dependencies somewhat easier
01:03:15 <dysfun> you may wish to consider using stack, it's a very easy way to handle projects
01:03:40 <dysfun> it will deal with ensuring version compatibility in dependencies
01:04:08 <mjora7> Ok!
01:04:42 <mjora7> Yeah I'm not really sure how to import libraries or anything like that at the moment. So I'll probably keep using GHC and makefiles until my textbook gets there.
01:05:15 <dysfun> try stack. it can generate a skeleton project and guide you on adding dependencies
01:05:20 <dysfun> then they're just an `import` away
01:05:25 <mjora7> Awesome
01:05:43 <mjora7> So is Stack just a newer Cabal basically?
01:05:48 <mjora7> Or do they solve different problems?
01:05:55 <pacak> Cabal is a build tool.
01:05:57 <dysfun> no. stack uses cabal in fact
01:06:09 <mjora7> Oh ok
01:06:23 <pacak> stack is something that supposed ensure that whenever you install something - it works.
01:06:25 <dysfun> stack is designed to avoid so called 'cabal hell'
01:06:40 <pacak> (but it more or less creates it's own hell)
01:06:45 <dysfun> which is where you may find some versions of libraries installed clash
01:06:57 <dysfun> it can be very disconcerting for a beginner
01:07:07 <dysfun> stack is thus an appropriate tool to start with
01:07:30 <dysfun> i like stack actually. i didn't at first, but it improved a lot
01:08:34 <mjora7> Thanks!
01:09:26 <mjora7> I'm using MacOS, should I be expecting any weirdness with Haskell or does it work fine on any UNIX?
01:09:39 <dysfun> it works fine on even windows
01:09:43 <mjora7> Trying to decide whether or not to switch over to my Nix machine
01:09:48 <mjora7> Linux*
01:09:52 <mjora7> Ok great
01:09:55 <dysfun> allegedly. i don't run it on windows so i can't say for sure
01:10:16 <dysfun> with stack, i should imagine your mac will be just fine
01:10:25 <mjora7> I guess if it's non Microsoft and works on Windows then it almost assuredly works on MacOs
01:10:51 <dysfun> no. not really.
01:11:01 <dysfun> but i used to program haskell on osx with stack just fine
01:18:48 <mjora7> great
01:21:51 <_sras_> I cannot get the :type-at ghci command to work. What am I doing wrong? http://lpaste.net/5907372180118700032
01:32:00 <MarcelineVQ> you use the filename of your module in the module spot appearantly
01:34:10 <MarcelineVQ> e.g.  :type-at Main.hs 12 1 12 3 ""
01:34:28 <MarcelineVQ> or more correctly  :type-at Main.hs 12 1 12 3 rt   once you've verified it works with ""
01:35:55 <MarcelineVQ> if you really want to be sure use an identifier that doesn't exist and it'll complain if the span is wrong and that identifier doesn't exist,  :type-at Main.hs 12 1 12 3 warblegarble
01:40:57 <_sras_> MarcelineVQ:  ` :type-at Main.hs 12 1 12 3 asdsadfs` does not work either. It says 'Couldn't guess that module name. Does it exist?'..
01:41:16 <_sras_> same with 'src/Main.hs'
01:43:19 <MarcelineVQ> Hmm then it's not loaded for some reason, try :load ing it, but try app/Main.hs first because it's not in src
01:45:42 <_sras_> MarcelineVQ: It is shown right at the prompt, "*Main> :type-at Main.hs 12 1 12 3 asdsadfs"
01:47:22 <MarcelineVQ> hmm, seems to work differently in a project setting, what a pain in the ass
01:48:02 <_sras_> MarcelineVQ: You were right. "app/Main.hs" seem to work
01:48:49 <MarcelineVQ> oh good, maybe not a pain in the ass hehe :>
01:51:23 <_sras_> MarcelineVQ: So it seems that after setting +c, the module needs to be loaded by giving the path explicitly...and use the same path while querying
01:51:48 <MarcelineVQ> yes seems like it. The " " should be redundant as well, should be able to write   :type-at app/Main.hs 12 1 12 3 warblegarble
01:52:52 <MarcelineVQ> the example in the manual is  :type-at X.hs 6 6 6 7 f  which is where I got the idea that it wants the filename, the header is certainly more vague though  :type-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]  given how people tend to use the word module
01:53:46 <MarcelineVQ> that and [(name)] looks like a list rather than an optional parameter, just gotta be reading these like cli commands I guessw
02:16:27 <akr[m]> hello
02:16:49 <akr[m]> any tips on how to get a repl on top of a project which uses GHC 6.12 and builds with cabal-dev?
02:17:28 <ania123> if R is congurence relation, does f(A,B) R f(C,D)  imples A R C and B R D?
02:18:52 <akr[m]> I don't think so, ania123
02:20:40 <ania123> if \x.M R \x.N can we conclude M R N??
02:20:53 <ania123> akr[m]:]
02:20:56 <ania123> akr[m]:
02:28:48 <akr[m]> I guess it depends on what exactly R is, but I see you're getting more help in ##logic
02:29:10 <akr[m]> (which is probably a better place for this discussion anyway)
02:29:24 <cocreature> akr[m]: 6.12? you really have some old projects :)
02:30:34 <akr[m]> cocreature: indeed :/
02:31:15 <akr[m]> cocreature: do you think it might be a good idea to try and bump the GHC version up as much as possible?
02:31:27 <Taneb> ania123, not in general. 1 + 5 = 2 + 4 (and equality is most definitely a congruence relation), but 1 probably doesn't equal 2
02:31:46 <akr[m]> I'm not sure when exactly Applicative became a superclass of Monad
02:32:02 <cocreature> akr[m]: 8.0 or 7.10 I don’t quite remember
02:32:13 <cocreature> akr[m]: but getting to at least ghc 7.8 is probably a good idea
02:32:38 <cocreature> akr[m]: obviously it depends on why you want to build that project whether it makes sense to put in the effort
02:32:45 <Taneb> akr[m], 7.10 according to the changelog for base
02:33:06 <akr[m]> cocreature: do you have an estimate how many changes to the codebase would that take?
02:33:08 <akr[m]> cocreature: well they pay me for it, is that a reason good enough? :)
02:33:15 <cocreature> akr[m]: I guess so :)
02:33:42 <cocreature> akr[m]: the necessary changes heavily depend on how the code is written
02:33:59 <cocreature> some subsets of Haskell are relatively stable or at least the fixes are easy
02:34:10 <cocreature> others such as TH can require a significant amount of changes
02:34:59 <akr[m]> it's a server backend heavily using stuff like database queries, json parsing, date/time, and also template haskell
02:35:02 <akr[m]> hmm
02:35:18 <cocreature> just try it and see how many compilation errors you get
02:35:42 <cocreature> if you still want to use the project for anything serious you are definitely going to want to upgrade it
02:36:23 <akr[m]> okay, I'll give it a shot then
02:36:38 <akr[m]> btw I hate cabal-dev
02:36:48 <akr[m]> just needed to tell someone
02:36:55 <cocreature> just don’t use it?
02:37:24 <akr[m]> that's the plan, yeah
02:37:28 <akr[m]> but the project currently uses it
02:38:30 <cocreature> cabal-dev just manages sandboxes iirc so I don’t see how a project can depend on it
02:39:50 <akr[m]> well, the current build process depends on it
02:45:41 <akr[m]> there are some custom-patched libraries in the project
02:45:42 <akr[m]> basically it's a mess
03:05:07 <drninjabatman_> hey
03:05:53 <drninjabatman_> Is thare a way to evaluate a type synonym to the corresponding concrete type??
03:08:25 <cocreature> drninjabatman_: you mean in ghci?
03:11:22 <drninjabatman_> cocreature yes sorry
03:12:22 <akr[m]> is there any way to have `stack init` tell me more details about why it couldn't satisfy a dependency?
03:12:44 <akr[m]> it just says `Could not resolve dependencies: trying: HDBC-postgresql-2.3.2.0 (user goal)`
03:13:12 <akr[m]> but I have `HDBC-postgresql == 2.3.2.1` in my .cabal file
03:14:47 <MarcelineVQ> could another package you require need 2.3.2.0 ?
03:15:17 <akr[m]> yes, but I'd like stack / cabal to tell me which :P
03:16:09 <MarcelineVQ> are you sure it doesn't? try  stack init --solver  in case it can have Cabal be more specific
03:16:18 <cocreature> akr[m]: can you show us the full output from stack? it usually should tell you a bit more
03:17:15 <cocreature> drninjabatman_: :i T should show you what the type synonym expands to
03:17:35 <akr[m]> here it is: http://lpaste.net/354834
03:18:13 <cocreature> rty cabal update
03:18:16 <cocreature> *try
03:18:42 <akr[m]> same thing
03:18:48 <cocreature> hdbc-postgresql is not in stackage
03:18:53 <akr[m]> (also the warning about cabal update stays)
03:19:08 <akr[m]> ahh, I thought it looks in hackage as well
03:19:11 <cocreature> just use --omit-packages and add it to extra-deps
03:19:20 <cocreature> I wish there was a --force option for stack init
03:19:32 <MarcelineVQ> it will look in hacakge if you specify --solver
03:19:47 <drninjabatman_> cocreature hmm maybe I phrased the question badly: I want ghci to expand *all* type synonyms and type families in an expression.
03:19:48 <cocreature> I’ve never been in the situation where I didn’t had to add the packages right after I used --omit-packages
03:19:54 <cocreature> drninjabatman_: :kind!
03:20:42 <drninjabatman_> cocreature yes that worked!
03:21:26 <akr[m]> > :TODO: Document --solver
03:21:28 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:21:34 <akr[m]> MarcelineVQ: what does that do?
03:22:08 <MarcelineVQ> it uses cabal to solve dependencies and adds them to your stack.yaml extra-deps section to fetch them from hackage
03:22:36 <MarcelineVQ> that cabal error in your paste is pretty concerning though
03:22:44 <akr[m]> hmm why am I getting `Invalid option `--solver'`
03:23:00 <MarcelineVQ> I can't tell from just that
03:23:22 <akr[m]> this is stack 1.4.0
03:23:48 <cocreature> akr[m]: did you use --solver before init?
03:23:49 <MarcelineVQ> that's good, but I've no idea what you typed on your end when you got that error
03:24:09 <cocreature> stack --solver init probably doesn’t work
03:24:13 <cocreature> while stack init --solver should
03:24:14 <akr[m]> oh it goes after init, nevermind
03:24:21 <akr[m]> but I still get the same error :(
03:24:31 <MarcelineVQ> by the same you mean the cabal error?
03:24:40 <akr[m]> yup
03:24:55 <MarcelineVQ> and from the same directory you can run  cabal update  just fine?
03:25:05 <akr[m]> yeah
03:25:26 <MarcelineVQ> that's not fun :(
03:26:11 <akr[m]> :(
03:26:11 <MarcelineVQ> try  stack update
03:27:29 <akr[m]> oh, that helped
03:27:38 <akr[m]> I mean, I get a different error now :)
03:27:42 <MarcelineVQ> ah alrighty, that error comes from Cabal so it doesn't know any better I guess, as far as it knows cabal update is the right thing to do
03:28:46 <cocreature> reporting a bug might be a good idea
03:29:10 <cocreature> at least the error message could be better
03:29:44 <MarcelineVQ> I would almost be good if it just automatically tried to update the index, if the index wasn't so big
03:30:45 <akr[m]> I'm not sure what exactly I'm to report, though
03:30:52 <akr[m]> thank you for the help for now, bbl lunch
03:36:35 <OnkelTem_> Hi all
03:37:08 <OnkelTem_> I run a program (simple snap application) using 'stack exec prog-exe' 
03:37:29 <OnkelTem_> it binds to some port, and when I exit program by Ctrl-C in console it continues running
03:37:42 <OnkelTem_> Any ideas how to exit a program?
03:37:48 <OnkelTem_> how to terminate it easily
03:40:29 <rub_ixCube> have you tried Ctrl-D?
03:50:21 <Gurkenglas> Might it be possible to use the same trick the platey part of lens does to derive catamorphisms for large, mutually dependent ADTs like http://lpaste.net/6928300002460565504 ?
04:05:02 <cocreature> Gurkenglas: which trick are you referring to? iirc the platey part is just Data.Data and Data.Typeable
04:05:06 <cocreature> maybe a bit of Data.Generics
04:05:13 <cocreature> eh GHC.Generics
04:05:35 <cocreature> implementing catamorphisms using generic programming techniques should be doable
04:06:39 <Gurkenglas> I'm like barely competent enough to use plate, have ideas like this one on when it might be usable, and that it couldn't possibly be implemented without magic somewhere along the way, not where the magic lies :P
04:14:15 <Gurkenglas> Is there a version of template that finds occurences not of a type, but of all types that satisfy a constraint?
04:54:44 <KunoMark> Hmm... :-/
04:54:50 <KunoMark> I wonder...
04:55:12 <KunoMark> So, what's wrong with just leaving ApplicativeDo turned on all the time, then?
04:58:26 <KunoMark> The biggest danger I can see is that some broken "monads" out there might chage their behaviour, since their methods are unlawful. But there doesn't appear to be a performance hit...
05:00:00 <MarcelineVQ> the most likely hitch is the one mentioned here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#things-to-watch-out-for
05:01:33 <lyxia> join instead of (>>=) can hit performance. For instance with lists you go through an intermediate one that might not get inlined.
05:01:59 <KunoMark> Yep. I saw that, MarcelineVQ. Lawless, wayward, desperado monads!
05:02:20 <KunoMark> Interesting lyxia. That sounds more serious...
05:02:35 <merijn> KunoMark: Codensity to the rescue! ;)
05:04:00 <KunoMark> dafuq is dat? @merijn
05:04:41 <merijn> KunoMark: Are you familiar with DList?
05:04:47 <merijn> @where dlist
05:04:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
05:05:06 <merijn> Not the article I had in mind, and apparently dead
05:05:19 <merijn> @where + dlist http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
05:05:19 <lambdabot> I know nothing about +.
05:05:22 <KunoMark> Yep. Familiar. Cool hack to get around the performance issues of appending multiple lists. merijn
05:05:22 <merijn> @where+ dlist http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
05:05:22 <lambdabot> Done.
05:05:39 <merijn> KunoMark: Codensity transform is basically "DList generalised to any Monad"
05:06:18 <merijn> But eliminating unnecessary >>= applications, rather than ++
05:13:56 <KunoMark> I'll mull over that, merijn. Sounds extremely intewresting. DLists themselves are a very cool trick (converting a potentially quadratic action into a single linear scan).
05:15:40 <Gurkenglas> @let data Counter a = forall self. Counter { _this :: self, _inc :: self -> self, _output :: self -> a }
05:15:41 <lambdabot>  Defined.
05:15:51 <Gurkenglas> :t \(Counter a b c) (Counter d e f) -> Counter (a, d) (b &&& e) (c *** f) -- is there a way to zip these?
05:15:52 <lambdabot> error:
05:15:52 <lambdabot>     • Couldn't match type ‘self’ with ‘(self, self1)’
05:15:52 <lambdabot>       ‘self’ is a rigid type variable bound by
05:16:24 <merijn> KunoMark: Lemme look up the paper
05:17:40 <Gurkenglas> :t \(Counter a b c) (Counter d e f) -> Counter (a, d) (b *** e) (c *** f) -- oops, it was just a mundane misstep of mine.
05:17:41 <lambdabot> Counter t1 -> Counter t -> Counter (t1, t)
05:18:21 <merijn> KunoMark: I think this is the one: https://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
05:20:52 <KunoMark> Excellent merijn! The paper by Janis seems to be paywalled, but I will look at the one by Ralf you just linked. :-D
05:21:46 <merijn> KunoMark: *cough* Sci-Hub *cough*
05:21:58 <merijn> Also, Google Scholar is excellent at finding free versions of papers
05:23:46 <KunoMark> Of course I had that in mind when I said the paper is paywalled merijn! I just wanted to be PC. Hehe...
05:25:03 <KunoMark> " It is known
05:25:03 <KunoMark> that every Kan extension gives rise to a monad, the codensity monad, and
05:25:06 <KunoMark> furthermore that every monad is isomorphic to a codensity monad."
05:25:25 <KunoMark> Sounds like an amazing paper. Thanks, merijn! Cheers!
05:32:39 <drninjabatman_> does anyone know if TypeError is in GHC 8.0.2? https://ghc.haskell.org/trac/ghc/wiki/Proposal/CustomTypeErrors
05:32:54 <MarcelineVQ> tis
05:33:15 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#custom-compile-time-errors
05:33:35 <drninjabatman_> oh it's in typelits
05:33:42 <drninjabatman_> thnx MarcelineVQ
05:41:48 <merijn> I have a "Monad m => m a", a function "a -> a -> a" and I want basically run the action N times, combining results using said function. I'm sure there's a function like that, but I dunno where
05:44:30 <merijn> Something like a mix of replicateM and the nonexistent iterateM
05:46:47 <tsani> merijn: foldr1 foo . replicateM n ?
05:47:30 <tsani> uh, not quite
05:47:39 <tsani> but you get the idea
05:47:49 <merijn> tsani: Well, yes, except that has shitty performance :p
05:47:54 <tsani> ah
05:47:58 <OnkelTem_> Hi all :)
05:48:09 <OnkelTem_> A newbie has arrived
05:48:16 <merijn> tsani: Because it builds a large intermediate list :)
05:48:34 <OnkelTem_> Are you folks ready for a bunch of stupid questions?
05:51:29 <MarcelineVQ> :t \f n act -> foldr (\_ xs -> liftM2 f act xs) act [1..n-1]
05:51:30 <lambdabot> (Enum a, Num a, Monad m) => (a2 -> a2 -> a2) -> a -> m a2 -> m a2
05:51:38 <Gurkenglas> Etiquette around here has it to skip that question
05:55:04 <lpaste> merijn pasted “Monadic loop” at http://lpaste.net/354841
05:55:08 <merijn> That's whay I came up with so far
05:55:26 <merijn> I'm a bit unhappy with line 3 and 7 basically being the same :\
05:55:40 <Gurkenglas> :t \f n act -> foldr1 f <$> replicateM n act -- MarcelineVQ
05:55:42 <lambdabot> Applicative f => (b -> b -> b) -> Int -> f b -> f b
05:55:44 <merijn> But the only way I know how to remove that removes the tail recursion, which makes it more expensive
05:55:54 <merijn> replicateM is a no go, though
05:56:11 <merijn> That first builds the entire list
05:56:19 <merijn> Which is what I wanna avoid
06:00:18 <Gurkenglas> > runIdentity $ foldr1 (++) <$> replicateM maxBound (Identity [0]) -- are you sure? what about lazy IO?
06:00:20 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
06:00:48 <MarcelineVQ> which lazy IO?
06:00:51 <merijn> Gurkenglas: I don't see what lazy IO has to do with it?
06:01:07 <merijn> There is no lazy IO in my example
06:01:10 <MarcelineVQ> you'd need a unsafeInterleaveIO in there somewhere for that, which you can't insert into replicateM's workings anyway
06:01:37 <MarcelineVQ> rather, it wouldn't affect how replicateM works
06:02:40 <OnkelTem_> How to generate an infinite list of intergers? An easy way
06:02:54 <Gurkenglas> > [1..] :: [Integer] -- OnkelTem_ 
06:02:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
06:03:15 <OnkelTem_> Gurkenglas: sorry, I forgot one word: random integers
06:03:20 <Gurkenglas> I mean, Identity's replicateM doesn't wait for the whole list to be constructed, so it depends on the monad (say, Maybe would wait), and I thought lazy IO has to do with that
06:03:57 <merijn> Gurkenglas: Lazy IO is A LOT less common that people think
06:04:08 <merijn> Gurkenglas: base has all of 3 or so lazy IO things in it
06:04:11 <akr[m]> why is it that `stack solver` says that no changes are needed to `stack.yaml`, but `stack build` says that `<package> must match <version>, but the stack configuration has no specified version`
06:04:16 <merijn> Everything else, IO is strict
06:04:26 <akr[m]> I mean, I wish that the solver would add all those lines that are necessary into the yaml file
06:05:02 <MarcelineVQ> stack solver --update-config
06:05:09 <Gurkenglas> OnkelTem_, there is no uniform distribution on the Integers. Ints, maybe? getRandoms https://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random-Class.html#v:getRandoms
06:05:29 <MarcelineVQ> though it shouldn't say no changes are neccesary if update-config would do something, so your issue may be elsewhere
06:05:45 <akr[m]> MarcelineVQ: I think that is the default (and does nothing for me)
06:05:49 <MarcelineVQ> it's not
06:05:56 <MarcelineVQ> but with init it is
06:05:57 <akr[m]> ah okay
06:07:39 <akr[m]> http://lpaste.net/354842
06:07:40 <akr[m]> so should I add all those manually?
06:09:04 <lyxia> base 4.2 O_o
06:09:24 <lyxia> how old is that
06:09:44 <Gurkenglas> merijn, why is there an argument of type (IO () -> IO a) in your code? It doesn't seem to be used
06:09:45 <MarcelineVQ> 7 years
06:09:50 <lyxia> akr[m]: what are you trying to build
06:09:55 <akr[m]> lyxia: uhh I didn't notice that
06:10:00 <akr[m]> I was going for 4.7
06:10:30 <Gurkenglas> (... could be fun if record syntax could specify fields in negative position, and then {..} eats an identifier of that name)
06:10:34 <akr[m]> lyxia: it's a commercial thingie that currently runs on GHC 6.2
06:12:03 <lyxia> Gurkenglas: Isn't that RecordWildCard
06:12:08 <merijn> Gurkenglas: It is used, in "work" whose definition isn't in there
06:12:17 <merijn> Gurkenglas: Eh, you can do that
06:13:09 <lyxia> akr[m]: stackage doesn't have a snapshot for such old versions of GHC so you'll have to pin packages yourself
06:13:21 <lyxia> akr[m]: versions of base are linked to versions of GHC
06:13:38 <lyxia> you can't just tell it to pick base 4.7
06:13:39 <MarcelineVQ> lyxia: they're trying to update to ghc 7.8, or were earlier
06:13:50 <lyxia> oh
06:13:52 <MarcelineVQ> which is where 4.7 came from
06:14:14 <lyxia> nevermind
06:15:10 <akr[m]> lyxia: yeah I know I'm going for GHC 7.8 and base 4.7
06:15:12 <MarcelineVQ> well that could be my misunderstanding actually, I assumed that because they were using a 7.8 resolver and you don't normally stumble into resolvers that old
06:15:51 <OnkelTem> Gurkenglas: how to use it? I mean I can't just create a function like g3 = getRandomRs(1, 99) as I get this: Ambiguous type variable `m0' arising from a use of `getRandomRs' prevents the constraint `(MonadRandom m0)' from being solved.
06:16:06 <Gurkenglas> lyxia, I mean the dual of what RecordWildCard does - RecordWildCard makes {..} bring identifiers out of scope as provided by the record value. "could be fun" would use the value of an identifier in scope and give it to the record
06:16:58 <Gurkenglas> OnkelTem, random behavior of your code is a side effect. You can do "g3 <- getRandomRs (1,99)" as a line in the do block of your main, for example
06:17:39 <OnkelTem> Gurkenglas: ah, I see
06:18:28 <lyxia> you can build a record like let getSum = 3 in Sum {..}
06:19:19 <Gurkenglas> lyxia, oh, https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html only mentioned the other direction :)
06:20:50 <lyxia> akr[m]: it seems your packages specify exact versions for dependencies
06:20:59 <akr[m]> lyxia: indeed
06:21:12 <akr[m]> I should probably remove those hard versions
06:21:45 <merijn> I'm still confused no one has implemented this before :\
06:22:39 <Gurkenglas> OnkelTem, one reason to treat random values differently from deterministic ones is that for the latter, the compiler can tell two places far apart in time and/or space to recompute the value instead of communicating the result
06:24:08 <hexagoxel> :t foldr (>=>) return -- merijn does this not come close? you should be able to force the arg there.
06:24:09 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
06:24:33 <lyxia> akr[m]: indeed, stack will not build if it can't satisfy the dependencies as specified by the .cabal file
06:24:36 <hexagoxel> with  replicate (i-1) (\(!x) -> ..)
06:26:37 <merijn> hexagoxel: Well, I'm pretty sure what I have in the paste is about as efficient as it gets. Now I want to keep it as efficient, but make it less ugly :p
06:27:08 <hexagoxel> merijn: although i am unsure of the exact eval order you'd end up with. but i think in the worst case it'd only evaluate the full [a -> m a], which probably is tolerable.
06:27:25 <merijn> hexagoxel: Honestly, I don't give a shit about the evaluation order :)
06:27:50 <merijn> hexagoxel: Since I'm doing the exact same monadic operation at every iteration
06:29:08 <hexagoxel> merijn: but you do want forcing the intermediate values.
06:29:17 <hexagoxel> :t \i m c -> m >>= foldr (>=>) return (replicate (i-1) $ \(!x) -> fmap (c x) m)
06:29:18 <lambdabot> Monad m => Int -> m b -> (b -> b -> b) -> m b
06:29:46 <merijn> hexagoxel: Wait, I don't thing I understand why >=> is there?
06:29:51 <hexagoxel> well, really, that still is ugly.
06:30:31 <merijn> hexagoxel: Wouldn't that still consume quite a huge list?
06:30:39 <Gurkenglas> :t \n -> execWriterT . replicateM n . ?tellT -- merijn
06:30:40 <lambdabot> (?tellT::a1 -> WriterT w m a, Monoid w, Monad m) => Int -> a1 -> m w
06:30:42 <merijn> hexagoxel: Consider that i might be 10k or more
06:31:15 <merijn> hexagoxel: That way "foldr (>=>) return" would kinda suck
06:31:32 <Gurkenglas> (tellT :: m w -> WriterT w m ())
06:32:28 <Gurkenglas> (replicateM_, that is)
06:35:20 <akr[m]> ah stack build is silly, it tells me to add extra-deps at versions which don't work :(
06:35:55 <lyxia> "don't work" in what sense
06:36:23 <akr[m]> like, require newer version of base
06:36:23 <Gurkenglas> :t \n -> execWriterT . replicateM_ n . WriterT . fmap ((),) -- i guess saying this is less explicitly ugly than the last try
06:36:25 <lambdabot> (Monoid w, Monad m) => Int -> m w -> m w
06:36:28 <akr[m]> maybe I should fix base in my cabal
06:44:01 <lyxia> You should run stack build only after the versions have been figured out
06:45:48 <ggVGc> I'm pretty glad stack exists
06:46:03 <ggVGc> don't know if I'd stuck with haskell dev if stack hadn't been around when I started
06:46:12 <ggVGc> even though it was fairly new at the time
06:46:40 <ggVGc> tried several years earlier and got really demotivated by cabal
06:49:59 <lyxia> I hear cabal has gotten much better since then
06:54:58 <lpaste> merijn pasted “How to make this less verbose?” at http://lpaste.net/354843
06:54:59 <merijn> Next bit where I need advice :)
06:55:19 <merijn> Specificall line 16-31 are soulsucking
06:59:02 <Aruro> making instance of monoid?
06:59:23 <merijn> That doesn't really reduce the verbosity...
06:59:33 <merijn> I'd still have the exact same code, just somewhere different
07:00:16 <Aruro> derive Monoid?
07:00:37 <merijn> You can't derive Monoid
07:01:18 <Aruro> why not?
07:01:42 <merijn> Because it's not derivable?
07:01:47 <Aruro> generally if u have long names, i dont see how u can make code less verbose
07:02:46 <Aruro> monoid without mempty is possible to derive, i guess
07:03:32 <Aruro> tbh i think your code looks good
07:04:07 <Tuplanolla> This smells like a bifunctor, merijn.
07:05:39 <Aruro> why monoid is not superclass of num?
07:05:48 <merijn> Tuplanolla: Doubt it, what makes you say that?
07:06:53 <Tuplanolla> I'd look for a way to `addResults = join bimap (+)` with a `instance Num Measured`, merijn.
07:07:37 <Tuplanolla> If not `Num`, then at least `Monoid` over `Sum`.
07:07:41 <merijn> Tuplanolla: Except that a Num instance for measured makes no sense? And bimap only works if you parameterise Measured (wich also makes no sense AND which makes it impossible to be strict)
07:08:05 <merijn> oh, wait the bimap for the tuple
07:08:20 <Tuplanolla> Yes.
07:08:51 <merijn> Tuplanolla: Anyway, bimap would limit the GHC versions this can work with
07:09:51 <Aruro> merijn: your code is fine, your are over optimising, how do they call it? first mistake of coding? :)
07:10:46 <cocreature> if you have lots of functions similar to these, you could use some generics lib.
07:10:52 <reactormonk[m]> stack clean isn't enough for `can't load .so/.DLL for ...` - ideas?
07:11:02 <cocreature> but if you use that only once it’s not worth the effort
07:12:32 <hexagoxel> merijn: `on` removes a bit of duplication there.
07:12:47 <hexagoxel> (+) `on` measTime m1 m2
07:13:28 <merijn> hexagoxel: ah, right!
07:14:07 <merijn> cocreature: Yeah, but it never hurts to check whether someone has some clever trick somewhere :p
07:14:54 <Tuplanolla> This is the reason I never finish Haskell projects...
07:15:50 <Aruro> i say its fault of over smart community :D
07:16:05 <Aruro> *ly
07:17:45 <Aruro> merijn: for on u will need extra import, like Data.Function
07:18:09 <Aruro> i dont see how its better than making honest generalization and making and instance of monoid for Measure
07:18:42 <Aruro> Ed said make more instances, it was true.
07:19:04 <lyxia> merijn: one-liner++
07:19:07 <Tuplanolla> You should make a monoid out of it just to call `mempty` the zero measure.
07:19:26 <Tuplanolla> Analysis puns are the best.
07:21:12 <lyxia> oops, one-liner doesn't have a good simple zipWith, but at least it's possible through zipWithA.
07:22:25 <lyxia> actually it's called binaryOp.
07:22:50 <lyxia> m3 = binaryOp (For :: For Num) (+) m1 m2
07:26:26 <lpaste> merijn annotated “How to make this less verbose?” with “How to make this less verbose? (annotation)” at http://lpaste.net/354843#a354844
07:26:35 <Aruro> why Num is not directly subclass to monoid?
07:26:47 <merijn> Actually, that is a rather simple improvement :)
07:27:06 <merijn> Aruro: Because you can only have a single monoid instance per type, most numbers have multiple monoids
07:27:20 <Jafet> are StableNames always preserved over garbage collection? the haddock is nebulously vague here
07:27:24 <benzrf> merijn: but you could have a monoid instance for multiplication and then a wrapper for addition
07:28:07 <fXl> readX :: IO (Maybe DataX) , how can i make patter matching on this ?  i did readerX :: Maybe DataX -> String ; (Just a) -> a , it fails. 
07:28:24 <merijn> Jafet: What do you mean "preserved over garbage collection"
07:28:24 <Aruro> yes but there are no default instances of monoid for Num
07:28:33 <Aruro> why not making it at least plus
07:29:11 <Aruro> if u want Prod u add Data.Monoid
07:29:29 <Aruro> otherwise deafult is Sum , mappend 1 2 == 3
07:29:34 <Jafet> merijn: will makeStableName, on the same object, always return the same name?
07:30:44 <merijn> Jafet: Yes
07:30:58 <merijn> Jafet: Actually, maybe
07:31:19 <cocreature> I don’t think so. the same itself stays stable but creating a new name for the same object does not have to be stable afaik
07:31:43 <Jafet> (let's assume it's already in NF so that the object won't be changed by evaluation)
07:31:50 <merijn> "The reverse is not necessarily true: if two stable names are not equal, then the objects they name may still be equal. Note in particular that mkStableName may return a different StableName after an object is evaluated."
07:33:38 <Aruro> fXl: readX >>= \x -> case x of Just a -> .. ? 
07:34:55 <Jafet> it just seems nebulously vague for the documentation to not guarantee anything at all under any circumstances
07:35:35 <merijn> Jafet: Still better than reallyUnsafePtrEquality# :p
07:35:50 <merijn> At least StableName guarantees no false positives...
07:36:28 <fXl> Aruro, http://lpaste.net/354845
07:37:33 <fXl> Aruro, actually this one , http://lpaste.net/354845
07:38:11 <spatial> Which library should I use to get a random values from a uniform distribution of n values ?
07:39:32 <akr[m]> sorry I lost my connection
07:39:39 <spatial> hmatrix has it. How is it used ?
07:39:43 <akr[m]> lyxia: how do I know that the versions have been figured out?
07:39:44 <cocreature> :t randomR
07:39:46 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:39:50 <cocreature> ^ spatial
07:40:03 <merijn> cocreature: Does Random guarantees uniform distribution?
07:40:15 <merijn> Or rather, is that a law?
07:40:17 <cocreature> merijn: at least the docs claim it does
07:40:37 <cocreature> “Takes a range (lo,hi) and a random number generator g, and returns a random value uniformly distributed in the closed interval [lo,hi], together with a new generator.”
07:40:53 <Jafet> does Random even define what random is
07:40:54 <shafox> Is it difficult to code a Graph Database in Haskell ? I read couple of blogs but couldnt determine whether it is correct or not. 
07:41:19 <merijn> shafox: Well, yes, but then coding a Graph Database is difficult in any language
07:41:28 <lyxia> akr[m]: have you tried stack solver --update-config after relaxing your constraints
07:42:03 <Aruro> fXl: u can not put string in case of Nothing , it should be some value of type DataX, otherwise all fine
07:42:18 <lyxia> akr[m]: and after removing any extra-deps that were there, unless you are positive some versions are right
07:42:34 <fXl> what should i put ? :D secondly this fails i am stuck 
07:42:50 <lpaste> Gurkenglas annotated “How to make this less verbose?” with “How to make this less verbose? (annotation) (annotation) @merijn, plated with lens” at http://lpaste.net/354843#a354847
07:42:57 <akr[m]> lyxia: so stack init --solver put about 20 packages into extra-deps
07:43:09 <shafox> merijn: Yes I understand that, but I am asking particularly for Haskell, As seen in Github all the databases written in OOP languages such as Java (heavily). Is there any particular reason for the same or its just nobody has done it fully ?
07:43:27 <akr[m]> lyxia: and stack solver doesn't see anything wrong with the config, it says that the build plan succeeded
07:43:30 <Aruro> fXl: i dont know what is DataX depends on your code, post whole program, otherwise unclear
07:43:35 <lyxia> akr[m]: odd
07:43:36 <fXl> how can i use readerX to readX
07:43:39 <spatial> cocreature: Which function is that ?
07:43:43 <akr[m]> lyxia: but stack build suddenly figures out that there are missing packages in extra-deps
07:43:46 <Aruro> fXl: inside main
07:43:57 <cocreature> spatial: the one that I showed you
07:44:02 <Gurkenglas> Is there a version of template that finds occurences not of a type, but of all types that satisfy a constraint?
07:44:09 <merijn> shafox: Well, some HPC things are tricky to do in Haskell, especially if you're not very experienced in Haskell. But overall, it shouldn't be THAT much harder. Especially since there's an easy FFI
07:44:09 <fXl> i have something else there, like program menu
07:44:55 <Gurkenglas> merijn, are the WriterT/template suggestions adequate?
07:44:56 <lyxia> akr[m]: That doesn't sound normal, but I'm not sure what you can do about this :/
07:45:10 <akr[m]> lyxia: missing in the sense that stack build complains that a bunch of  additional packages need to be specified in extra-deps
07:46:28 <merijn> Gurkenglas: Elegant, but not something I can realistically use, since I don't think adding a lens dependency will be accepted :)
07:46:57 <akr[m]> lyxia: oh and stack build then tells me to add these missing packages to extra-deps, but the versions it selects are in conflict base == 4.7.*
07:47:05 <akr[m]> in conflict with*
07:47:27 <akr[m]> can I fix base version in stack.yaml somehow or something
07:47:34 * hvr can't help but wonder if using cabal instead of stack wouldn't be easier for akr[m]
07:48:13 <akr[m]> possibly, I should try
07:48:33 <hvr> akr[m]: is the project you're trying to build public somewhere?
07:48:34 <akr[m]> but it's annoying, stack at least sets up the correct version of GHC for me…
07:48:40 <akr[m]> hvr: afraid not
07:48:43 <lyxia> akr[m]: can you paste your stack.yaml
07:48:54 <hvr> akr[m]: what OS are you one?
07:48:56 <hvr> akr[m]: what OS are you on?
07:49:11 <lyxia> and maybe the dependencies
07:49:21 <Aruro> correct version of ghc, sounds interesting
07:49:51 <akr[m]> hvr: GNU/Linux
07:49:59 <akr[m]> here;s stack.yaml: http://lpaste.net/3036490076671442944
07:50:59 <lyxia> ghc-7.8 is that legal
07:51:11 <hvr> akr[m]: fwiw, at least on Debian/Ubuntu, setting up the "correct" GHC is just a matter of a simple `apt install` (after having done the one-time setup of adding the apt repo)
07:51:32 <merijn> hvr: Even installing the binary distro is fairly trivial
07:51:40 <hvr> true dat
07:51:48 <fXl> Aruro, https://hastebin.com/akomagobil.hs , whole is here
07:51:51 <akr[m]> lyxia: why not?
07:52:39 <fXl> Aruro, if you can't see hpaste, here lpaste http://lpaste.net/354849
07:52:41 <lyxia> akr[m]: because GHC versions are 7.8.1, 7.8.2, 7.8.3, 7.8.4
07:53:05 <Aruro> fXl: add stuff in main, after pring
07:53:14 <akr[m]> hmm, well `stack --resolver ghc-7.8` didn't complain
07:54:18 <lyxia> Okay, I guess it works
07:55:15 <fXl> Aruro, sx a = do ; f <- readConfig ; return (readConfigX f), this says no instance for show :D
07:56:18 <Gurkenglas> merijn, can I see the codebase to see if I can spot some more tricks? (just https://github.com/merijn/criterion ?)
07:57:06 <Aruro> fXl: main = readConfig >>= (print . readConfigX)
07:57:21 <Aruro> fXl: for Nothing case put undefined, otherwise will not compile
07:57:24 <_101010> Hey guys, quick question, what is the difference, if any between:
07:57:38 <_101010> sum' :: Num a => [a] -> a
07:57:47 <_101010> and sum' :: (Num a) => [a] -> a
07:57:52 <_101010> in terms of type signature
07:57:52 <mauke> none
07:58:16 <_101010> so what's the point of parentheses? just readibility?
07:58:21 <_101010> in this particular case
07:58:22 <mauke> :t sum :: (((Num a))) => (([(a)]) -> (a))
07:58:23 <lambdabot> Num a => [a] -> a
07:58:36 <Aruro> fXl: or main = a<-readConfig; print (readConfigX a)  -- u have to format 
07:58:46 <merijn> Gurkenglas: That one, yes, but I haven't committed/pushed these changes yet :)
07:58:59 <fXl> Aruro, i am so confused, why i can't do it
07:59:00 <fXl> :S
07:59:29 <Aruro> did u try what i suggested?
07:59:39 <merijn> _101010: The parens are mandatory if you have more than one class, i.e. "(Eq a, Enum a) => ..." so some people always add them for consistency
07:59:53 <fXl> Yes, it worked
08:00:04 <lyxia> akr[m]: can you show the current stack build
08:00:13 <lyxia> akr[m]: I mean, what it outputs
08:00:25 <Eduard_Munteanu> Actually if you have more or less than one class.
08:00:27 <Aruro> fX1 : it will crash if file can not be read and u hit Nothing branch 
08:00:32 <Jonas22> If im having difficulties with a task, do i just ask here or is there a volunteer to pm? :-) [beginner]
08:00:37 <Eduard_Munteanu> :t x :: () => [a] -> a
08:00:38 <fXl> what i want to do is, just take those Strings and put them in somewhere else and use in another function. why i have to use main for that ?
08:00:38 <lambdabot> error:
08:00:39 <lambdabot>     • Couldn't match expected type ‘[a1] -> a1’ with actual type ‘Expr’
08:00:39 <lambdabot>     • In the expression: x :: [a] -> a
08:00:43 <_101010> merijin, got it, thanks :)
08:00:54 <lyxia> Jonas22: just ask
08:01:03 <fXl> Aruro, what i want to do is, just take those Strings and put them in somewhere else and use in another function. why i have to use main for that ?
08:01:20 <Aruro> fXl: u can write it in your own function, but running only possible in main
08:01:26 <fXl> this shouldnt be this much hard, i should be idiot
08:01:52 <Aruro> myFun = readConfig >>= (mystuff . readConfigX)
08:01:54 <akr[m]> lyxia: http://lpaste.net/354850
08:02:19 <Aruro> fXl: your function will have type IO because readConfig has IO
08:02:44 <fXl> i want those strings not IO , IO is too hard for me too figure out :D
08:03:18 <Aruro> u can write function on IO, but eventually they need to be run in main
08:03:41 <fXl> Aruro, btw i want to ask you something, what if i want to read another Data, i have to do IO for every yaml data ? like readConfig ?
08:03:50 <c_wraith> Whenever possible, you should avoid IO in your types.
08:04:16 <Aruro> fXl: yes every file operation is IO u can stuck all in main function, for starters 
08:04:55 <Aruro> fXl: just make program working, u will understand step by step
08:05:07 <fXl> Aruro, yeap it works finally ty
08:05:41 <Jonas22> okay, problem being: i am given a matrix (NOT in list form and i am not allowed to use list syntax in this task), but like this: field 1 1 = 0, field 1 2 = 1, field 2 2 = 0 and so on. My task is to implement a function which takes the field and the x and y coordinate as arguments (like this: myFunctionfieldA 1 2) and always returns a zero, as in "r
08:05:41 <Jonas22> eplacing whatever number was there before". I've gotten a hint that an anonymous function would work well for that. Any advice?
08:05:56 <fXl> Haskell is too complicated for me :D i can't do anything :S
08:06:42 <c_wraith> Jonas22: so the matrix representation you're given is like (Int -> Int -> Int)?
08:07:47 <Jonas22> yes
08:08:15 <Jonas22> its basically meant as a playfield, with certain positions having players (-> numbers) on it.
08:08:25 <c_wraith> Jonas22: so what's the type of the update function?
08:08:31 <fXl> Aruro, Just b -> b , b is Pointer {point = "/home/user/file"}, how can i take that /home/user/file from there now on ?
08:08:54 <c_wraith> Jonas22: it's always best to start with the types.  Especially when they're kind of hairy, like this case. :)
08:09:07 <Jonas22> I've tried https://thepasteb.in/p/P1hvWXwpMw8tl
08:09:24 <c_wraith> Jonas22: but what's the type?
08:09:41 <Jonas22> Unfortunately i dont know which type you're refering to.
08:09:55 <c_wraith> what is the type of mark?
08:10:38 <Jonas22> well mark is supposed to be a function, which replaces given position with a zero
08:10:46 <Jonas22> as in "marking that spot"
08:10:56 <mauke> no, what is the type?
08:10:58 <c_wraith> Not "what does it do"...  what is its type?
08:11:43 <Jonas22> sorry, i dont get it :-(
08:11:54 <mauke> get what?
08:12:05 <Jonas22> the type of a function?
08:12:18 <c_wraith> So, you've got the start..  It's a function.  Work from there.  What are its arguments?  What does it return?
08:12:26 <Jonas22> ah
08:12:37 <Aruro> fXl: point b
08:13:05 <Aruro> fXl: its called record syntax
08:13:11 <mauke> the type of a function is written A -> B where A is the type of the argument and B is the type of the result
08:13:12 <Jonas22> yes, i tried giving in a signature, my idea would be: Int -> Int -> String, but that turned out to be wrong.
08:13:31 <Jonas22> Int -> Int because of the coordinates, which come first
08:14:16 <Jonas22> and since its supposed to work like mark x y f (f being a field like field1 1 2 = 3) i thought the third parameter is supposed to be a stringf
08:14:20 <c_wraith> Jonas22: well, Int -> Int -> something
08:14:29 <mauke> well, it should be something like Int -> Int -> Field -> Field
08:14:34 <mauke> where Field is the type of your field
08:14:39 <Jonas22> oh!
08:14:44 <mauke> I don't see where you're getting string from, though
08:14:49 <c_wraith> Field is apparently a type synonym for Int -> Int -> Int
08:14:55 <fXl> Aruro, the error,  Variable not in scope: point :: Pointer -> String , Perhaps you meant data constructor ‘Pointer’ (line 22)
08:14:57 <mauke> c_wraith: spoilers!
08:15:00 <Jonas22> I think i got something. The fields dont have any signatures ot all. Even before the change.
08:15:34 <Jonas22> and yes, field is indeed Int -> Int -> Int
08:15:38 <lyxia> akr[m]: and these missing dependencies are in the .cabal file?
08:15:53 <fXl> Aruro, i did Just b -> point b,        the error,  Variable not in scope: point :: Pointer -> String , Perhaps you meant data constructor ‘Pointer’ (line 22)
08:16:49 <Jonas22> thanks everyone, ill try for myself a little bit - you ignited a spark, very helpful, thank you :-)
08:16:58 <akr[m]> lyxia: yes, or at least some of them. Some of them are dependencies of dependencies, I think
08:17:00 <akr[m]> #dependencyhell
08:17:47 <lyxia> akr[m]: do you have to use a ghc resolver rather than lts-2.22
08:18:15 <akr[m]> lyxia: this is code that compiles on GHC 6.something
08:18:28 <akr[m]> I have a feeling trying to move it to 8.* would be rather painful
08:18:37 <spatial> randomR size (mkStdGen 66) How is size given ? (1,size) ?
08:18:47 <lyxia> akr[m]: lts-2.22 is a snapshot for ghc 7.8.4
08:18:48 <akr[m]> not sure even about 7.8, I wanted to see how many compilation errors I'd be getting, lyxia
08:18:53 <akr[m]> ah
08:20:02 <lyxia> it contains most (all?) of the packages listed in your extra-deps and the things that should have been there. The problem you are having is still puzzling however.
08:21:18 <akr[m]> I'll try with that lts version
08:21:20 <lyxia> akr[m]: can you share your cabal file too
08:23:11 <akr[m]> lyxia: I'll pm it to you
08:27:48 <Jonas22> Hi, me again. I've created a pastebin to better visualize the problem i'm having. I guess its simple, but i just cant get the hang of it. Any advice is greatly appreciated! https://pastebin.com/gMAx693b
08:28:42 <mauke> Jonas22: what is (\f k -> f 0) f (f x y) supposed to do?
08:29:48 <Jonas22> in the original task it said that a anonymous function might be useful for this. Thats what i tried, but terribly failed at.
08:30:09 <butterthebuddha> Hey peeps
08:30:32 <butterthebuddha> I have an array of strings and I wanna cast 2 of those into integers
08:30:37 <Jonas22> It was supposed to "overwrite the result only, which is (i guess) not possible in haskell. f stands for playfield and k is the result
08:30:53 <butterthebuddha> I have already have one "where" clause in my function and turns out you can't have more than one
08:30:57 <mauke> Jonas22: no, in your code f is bound to f and k is bound to f x y
08:31:03 <mauke> Jonas22: so the whole thing reduces to f 0
08:31:09 <butterthebuddha> How do I cast those values and get the result in a form I can use in the function?
08:31:12 <mauke> (k is unused)
08:31:39 <mauke> butterthebuddha: there are no casts in haskell, and you can as many bindings as you want in a where clause
08:31:44 <mauke> *can have
08:32:08 <butterthebuddha> mauke I believe there is a function that goes from String -> Integer called "read"?
08:32:17 <mauke> yes
08:32:54 <Jonas22> mauke yes, and f x y (playfield A 1 2) being reduced to 0 would work, so i hoped.
08:33:07 <Jonas22> (*playfieldA)
08:33:39 <mauke> er, what?
08:34:03 <mauke> let's say you're calling markSpot 1 2 playfieldA
08:34:23 <mauke> then your code tries to return playfieldA 0
08:34:29 <mauke> that makes no sense
08:34:53 <Jonas22> you are right. i get that part now.
08:35:19 <Jonas22> Is there another way to go about it?
08:35:22 <mauke> you can derive sort of a skeleton of the code from the type
08:35:35 <mauke> markSpot x y f = ...  -- you've already got this part
08:35:54 <mauke> with x :: Int, y :: Int, f :: Int -> Int -> Int
08:36:09 <mauke> now what you need to return is of type Int -> Int -> Int
08:36:14 <fXl> Aruro, thanks for your time, appreciated
08:36:25 <mauke> that's a function. so what's the syntax for a function?
08:37:59 <Jonas22> markspot :: Int -> Int -> (Int -> Int -> Int) -> (Int -> Int -> Int)
08:38:13 <Jonas22> inst that how its supposed to go?
08:38:33 <mauke> ... yes? worauf willst du hinaus?
08:38:35 <c_wraith> Jonas22: that looks like the right type
08:41:22 <butterthebuddha> So if if have a list like ["random str 0", "random str 1", "random str 2", ...]
08:41:43 <butterthebuddha> How do I get all the values from "random str 2" till the end as a space delimited string
08:42:01 <butterthebuddha> So something like "random str 2 random str 3...random str n"
08:42:18 <c_wraith> butterthebuddha: break it into pieces.  First, get strings you want.  Second, combine them.
08:42:45 <cocreature> dropWhile will help with the first part
08:43:03 <cocreature> intercalate helps with the second
08:43:15 <hexagoxel> (or unwords in this case)
08:45:44 <rotaerk> hmm I'm currently planning to use 0MQ for inter-process communication, using cereal to encode/decode haskell data types.  I also need to do some inter-thread communication, and I can do it the same way, but it just seems silly to be serializing/deserializing when it's never going to escape the same haskell process
08:46:11 <rotaerk> is there a more appropriate library for inter-thread message-passing in haskell
08:46:55 <butterthebuddha> cocreature: dropWhile is similer to filter in python from what I understand; how is that useful?
08:46:56 <cocreature> rotaerk: you can just use Control.Concurrent.Chan
08:46:57 <geekosaur> TChan?
08:47:01 <geekosaur> or just Chan
08:47:07 <rotaerk> thanks
08:47:31 <geekosaur> butterthebuddha, dropWhile and filter are different things
08:47:40 <cocreature> > dropWhile (/= "random str 2") ["random str 0", "random str 2", "random str 3"] -- butterthebuddha 
08:47:41 <geekosaur> although I think just drop here, not dropWhile
08:47:42 <lambdabot>  ["random str 2","random str 3"]
08:47:56 <geekosaur> (I took what you said to be positional, not string value)
08:48:39 <butterthebuddha> Ah, the literal strings I wanna join can be anything
08:48:48 <butterthebuddha> Not just "random string 2", "random str 3"
08:49:02 <butterthebuddha> Anyways, I ended up just using tail
08:55:18 <butterthebuddha> I was hoping for a "style analysis" of this code: https://gist.github.com/awesomeaniruddh/40ae0fbb5610b2cd9ad9bb72fc958294 (it's not a lot of code, just 18 lines); it's a solution to the first problem here: https://www.seas.upenn.edu/~cis194/spring13/hw/02-ADTs.pdf
09:10:23 <glguy> butterthebuddha: I'd prefer to see pattern matching to access the 1st, 2nd, and rest of the elements in the list
09:11:03 <glguy> or I'd expect to there to be some other justification for using !! and tail like a length check or an invariant of the function that returned the list
09:14:43 <spatial> http://lpaste.net/354857 There is  parse error at the first statement after case
09:15:01 <spatial> n < Q = do
09:15:23 <glguy> spatial: case match clauses expect patterns, not boolean expressions
09:15:45 <glguy> and you build those match clauses like:  'PATTERN -> EXPRESSION', rather than with an =
09:16:01 <glguy> It looks like you want: if n < Q then .... else ....
09:16:22 <glguy> Next, you don't need so many lets, you can just use one
09:16:26 <glguy> Next, you can't use a where like that
09:16:48 <glguy> where is associated with the definition of runsimulations, it is outside the scope of all of those let expressions
09:17:06 <glguy> so for example 'N' is not in scope in the where clause
09:17:07 <spatial> Let me iterate
09:17:29 <spatial> case cannot be used here at all ?
09:17:40 <spatial> 0 and > 0
09:17:55 <glguy> Right, those aren't patterns, that's not what case is for
09:18:14 <monochrom> Guards will do that nicely.
09:19:17 <glguy> Patterns are variables, and constructors applied to zero or more patterns
09:19:19 <monochrom> You cannot just go "in English 'case' means ___" and hope it extends to Haskell.
09:19:41 <monochrom> Or "I saw math proofs that use 'case' like this" for that matter.
09:20:04 <geekosaur> pascal, c (switch/case), etc. --- it's understandable
09:20:26 <geekosaur> it's just wrong, case means pattern matchiong on structure in Haskell
09:24:06 <hpc> i don't even want to know how "in english $keyword means _" would translate to bash
09:25:12 <monochrom> "if" translates pretty well. But "fi" will not mean "like wifi but with wire" :)
09:25:40 <mauke> esac
09:26:18 <EvanR> wirefull
09:26:28 <geekosaur> should called it logla >.>
09:45:14 <EvanR> wow... Data.Colour is intense
09:47:26 <EvanR> i had a feeling computer color was complicated and no one was doing it right, but i didnt know someone else was thinking the same thing. i guess thats haskell for you
09:49:01 <JuanDaugherty> it works in 8?
09:49:30 <kuribas> EvanR: add to that calibration of monitors...
09:50:02 <rotaerk> if only they'd spelled color the proper way
09:51:41 <JuanDaugherty> people in that lil island still think they own the english
09:52:57 <EvanR> GHC is british so
09:53:03 <EvanR> ive come to expect it
09:53:21 <c_wraith> isn't Glasgow in Scotland?
09:53:31 <JuanDaugherty> well it may not be in the UK for long
09:53:35 * EvanR checks the latest on british organization
09:53:37 <c_wraith> Oh, that is British.  But not English.
09:53:56 <EvanR> yeah its not obvious that scotland is still british, from what i heard
09:54:14 <JuanDaugherty> yeah the whole archipelago or whatever is britain
09:54:17 <c_wraith> It's still on the island of Britania
09:54:35 <EvanR> its still the worse part of ultima online
09:55:49 <EvanR> it really is interesting how little america is to blame for ML, haskell, stuff
09:55:58 <EvanR> were still stuck in lisp
09:56:15 <JuanDaugherty> little america? you mean the super continent?
09:56:22 <EvanR> americuh
09:56:40 <JuanDaugherty> when the UK was coming up China was the only continental size power
09:56:52 <JuanDaugherty> as a nation state anyway
09:57:07 <glguy> Seems like this has diverged from the topic
09:57:23 <JuanDaugherty> the end thing apparently will be little england if scotland joins the EU
09:57:33 <JuanDaugherty> uh, remains in the EU
09:57:54 <JuanDaugherty> oh sorry thought i was in off-topic
09:58:11 <mauke> btw, I was able to help out Jonas22 in /msg (and in German)
09:58:44 <c_my_nick> i am using attoparsec and have a function with a return type of `State ParserState (Parser r)`.  the function is supposed to parse some stuff, append the results of the parser to the state, and then return the results inside the Parser monad.
09:58:47 <c_my_nick> how do i get the result back into the Parser monad? http://lpaste.net/354860
10:00:59 <EvanR> is there a #haskell-de
10:01:35 <JuanDaugherty> are you in fact using Data.Colour in 8 without doing anything other than importing it from hackage?
10:01:43 <EvanR> ghc 8 ?
10:01:47 <JuanDaugherty> yes
10:02:02 <EvanR> i still have 7.10
10:02:05 <JuanDaugherty> ty
10:05:23 <JuanDaugherty> and there is a #haskell-de oder
10:05:41 <xenog> I'm writing a concurrency library and I would like to add generic TCP client and server to it. It seems that Data.Conduit.Network from conduit-extra is the way to go. Is there anything else?
10:06:29 * JuanDaugherty slams the door on the hurt locker on the way out.
10:27:46 <hexagoxel> es ist #haskell.de, aber auch da ziemlich leer.
10:32:06 <alx741>  /join #haskell.es
10:32:19 <alx741> oops, sorry
10:32:34 <alx741> hexagoxel: so is every other #haskell.something
10:47:35 <xcbot> 7107˵:12,0  
10:47:44 * xcbot afcondon_ Ϥ褦
10:48:35 * Clint squints.
10:49:23 <geekosaur> could the bot testing take place elsewhere please?
10:49:39 <geekosaur> you can create your own one-off channels just by joining them
10:49:54 <geekosaur> (also you appear to have an encoding problem)
11:24:12 <ertes> glguy: could you tell me which haddock command you used to generate hackage-compatible docs?
11:24:22 <ertes> i have used this one so far: ./Setup haddock --contents-location='/package/$$pkg-$$version' --hoogle --html --html-location='/package/\$$pkg-\$$version/docs' --hyperlink-source
11:25:25 <glguy> ertes: Here's my script https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
11:25:25 <cocreature> ertes: maybe take a look at what cabal haddock --for-hackage does
11:25:58 <glguy> and apparently I committed some local openssl nonsense
11:26:18 <ertes> oh, --for-hackage, nice
11:26:20 <ertes> thanks
11:27:33 <glguy> The script used to be more complicated before cabal-install added --for-hackage
11:28:18 <ertes> yeah, cabal has that flag, too
11:28:49 <ertes> is there a reason you used --haddock-option=--hyperlinked-source instead of --hyperlink-source?
11:31:58 <cocreature> ertes: the former is the new fancy syntax highlighting added in haddock 2.17 iirc
11:33:22 <ertes> ah
11:35:30 <ertes> hmm, cabal doesn't automatically generate the tar.gz as it seems
11:36:02 <cocreature> it did for me the last time I tried it which was a few weeks ago
11:36:07 <cocreature> so I’d be surprised if anything changed :)
11:36:19 <ertes> maybe i'm doing something wrong
11:36:30 <cocreature> what’s the exact command you’re running?
11:36:33 <ertes> docs: dist/setup-config Setup default.nix shell.nix
11:36:34 <ertes>     $(nixsh) "./Setup haddock --for-hackage --haddock-option=--hyperlinked-source"
11:36:44 <cocreature> so you’re not using cabal?
11:36:51 <ertes> well, not cabal-install
11:37:16 <ertes> i can't assume that it's available in the environment nix' ghcWithPackages generates
11:37:17 <cocreature> I’m not sure where --for-hackage comes into play
11:37:37 <cocreature> maybe it’s already processed in cabal-install?
11:38:07 <cocreature> hm doesn’t look like it
11:38:16 <ertes>     --for-hackage           Collection of flags to generate documentation suitable for upload to hackage
11:38:38 <ertes> i can imagine that cabal-install also generates the tar.gz
11:38:58 <ertes> but cabal by itself doesn't, because that would require support libraries/tools
11:40:03 <ertes> well, doesn't matter…  it's just an extra command
11:40:08 <bennofs> ertes: --for-hackage is implemented by Cabal-the-library and is just passed through by cabal-install
11:40:31 <bennofs> ertes: cabal-install has 'cabal upload --doc' though
11:41:28 <cocreature> I’m looking forward to the day when "cabal upload --doc" becomes the default and I don’t have to deal with missing docs anymore
11:43:52 <ertes> Cabal library version 1.24.0.0
11:43:57 <ertes> do you use a newer version?
11:45:04 <bennofs> ertes: ah it may be that cabal haddock in general, --for-hackage or not, does additional stuff compared to just ./Setup haddock
11:46:40 <winmillwill> anyone have a good method for debugging when Setup hits "Encountered missing dependencies"?
11:47:42 <ertes> winmillwill: it tells you which dependencies are missing
11:48:17 <winmillwill> yeah, I need more info though, ie where was it looking?
11:49:09 <ertes> winmillwill: in the case of cabal-install it looks at your local package database, the one 'cabal update' downloads, plus the sources you have added explicitly
11:50:12 <ertes> winmillwill: 'cabal list' gives you a complete list, and 'cabal info' gives you version information on individual packages
11:54:00 <winmillwill> hmmm -- looks like I can't get there anyway because I'm doing this with nix and the failed build doesn't keep the package conf dir
11:55:31 <Aruro> winmillwill: u can enter nix shell, there cabal will be ready for your failing build
11:55:43 <Aruro> and u can investigate whats wrong
12:06:03 <ertes> winmillwill: in that case you can examine the package set you're using via nix-repl
12:06:36 <ertes> winmillwill: use this command: nix-repl "<nixpkgs>"
12:06:47 <ertes> then you can tab-complete your way through haskellPackages.*
12:07:28 <winmillwill> I have no nix-repl...
12:07:53 <ertes> yeah, it doesn't come with nix:  nix-env -i nix-repl
12:08:04 <winmillwill> ah
12:10:11 <ertes> to see the version of, say, generic-deriving, type this:  haskellPackages.generic-deriving.name
12:11:09 <winmillwill> should I use nix-repl in a nix-shell or does it matter?
12:16:07 <winmillwill> ...and if I cd to the failed build and run nix-shell I don't have cabal
12:32:28 <arctictern> quick question about the Applicative ((->) a) instance. The type seems to be unnecessarily constrained. It's "(<*>) :: (a -> a -> b) -> (a -> a) -> a -> b", but wouldn't a type of "(<*>) :: (r -> a -> b) -> (r -> a) -> r -> b" (similar to the function Functor) make more sense?
12:34:19 <lyxia> it's already that general
12:35:02 <arctictern> do the a's not have to be the same type?
12:35:09 <lyxia> Not at all
12:36:12 <arctictern> hm i thought that was the case 
12:36:25 <lyxia> f (a -> b) -> f a -> f b,  you want to substitute f with ((->) a) but first you can rename
12:36:47 <lyxia> so instead substitute with ((->) r)
12:36:57 <arctictern> ok so it's different from, say, "head :: [a] -> a" means
12:37:00 <lyxia> there's a bit of confusion about where a is bound
12:37:20 <arctictern> and it's different because the a in ((->) a) and the other a get bound differently?
12:37:38 <lyxia> yes
12:39:01 <lyxia> Given an instance Applicative f, the type of (<*>) is more explicitly forall a b. m (a -> b) -> m a -> m b
12:39:13 <lyxia> a and b may not occur in m
12:39:43 <lyxia> oops, I mean Applicative m
12:41:34 <arctictern> Ok that makes sense, thanks. More generally, if a type appears in the "header" of an instance, e.g. the ((->) a) in Applicative ((->) a), then is it safe to say that it is independent of the types in the definition? 
12:41:48 <arctictern> I worded that fairly poorly, but not sure what certain parts are called
12:42:04 <Cale> Yeah, that's normally called the "instance head"
12:42:27 <Cale> Usually the types are independent, but with scoped type variables, you can make them available
12:43:02 <Cale> Though, you also won't be giving a type signature to the operations you're defining in the instance usually.
12:43:33 <Cale> It's implied by the class declaration, and Haskell 98/2010 won't let you write one there
12:43:53 <Cale> You can turn on InstanceSigs if you really want to give type signatures in instance declarations.
12:44:45 <arctictern> gotcha, thanks!
13:13:40 <ertes> winmillwill: you need to use cabal in such an environment…  personally i just compile the Setup script
13:25:27 <Gurkenglas> Is there a version of filtered that takes an (a -> Maybe b) and somehow gives access to the b while a is being traversed?
13:26:29 <Gurkenglas> *read access
13:27:36 <jle`> Gurkenglas: what is the type of what you're looking for?
13:28:47 <Gurkenglas> Applicative f => (a -> Maybe b) -> (b -> a -> f a) -> a -> f a
13:31:45 <Gurkenglas> :t \f small -> liftA3 maybe pure small f
13:31:46 <lambdabot> Applicative f => (a1 -> Maybe a) -> (a1 -> a -> f a1) -> a1 -> f a1
13:32:19 <Paulish> haskell is cool for web development?
13:36:58 <fresheyeball> how do yall feel about unit tests?
13:37:10 <fresheyeball> The longer I write pure fp code, the less I see a need for them
13:37:25 <fresheyeball> but there are also lots of testing tools for Haskell
13:37:35 <fresheyeball> so obviously others feel differently from me
13:41:06 <lyxia> parametricity helps avoid some testing
13:41:42 <lyxia> but a lot can go wrong in a large enough project
13:42:14 <monochrom> Right, you will still like to include a few unit tests and a few Quickcheck tests.
13:42:22 <monochrom> But not as many as Python projects.
13:42:39 <ggVGc> fresheyeball: my philosophy is often to unit test whe bug fixing but not initially
13:42:42 <ggVGc> but in reality I seldom follow it
13:42:44 <ggVGc> unfortunately
13:42:48 <ggVGc> simply because, well, Im lazy
13:42:55 <ggVGc> and I want to make more features
13:43:04 <monochrom> And Quickcheck is a triumphant story. Quickcheck was cool before fuzz-testing is cool. (Same difference.)
13:46:31 <sproingie> unit tests are good for integrating stuff.  you can still build a complete wreck out of precision-made parts
13:47:42 <sproingie> it's nice to find where your assumptions went wrong before you put everything together.  you're not debugging your code as much as you're debugging you
14:19:25 <int-index> what package defines most canonical sum-types (in the same sense that tuples are canonical product-types)?
14:19:42 <int-index> basically, I need Either for 3, 4, 5, ..., 62 elements
14:20:39 <int-index> for now I'm thinking maybe 'compound-types'
14:20:45 <jle`> i don't think there is a common package providing distinct types for all those sums
14:20:51 <jle`> but what would you want to use them for?
14:21:02 <jle`> there are generic sum types that can be a sum between an arbitrary number of elements
14:23:52 <mniip> int-index, tried unboxed sums?
14:24:36 <int-index> Well, they're unboxed, and that's the problem. 
14:25:50 <int-index> jle`: I need memory-efficient sums, so that they are stored as tag + payload in memory, they also can't have a Typeable constraint. 
14:26:31 <int-index> I could use something like (Word, Any) and a lot of unsafeCoerce. Btw, maybe there's a package like that...
14:26:55 <int-index> but for the sake of pattern-matching I'd prefer manually defined sum-types
14:27:49 <jle`> compound-types is probably the most direct realization of what you are asking for
14:27:56 <jle`> but, what do you really want?
14:28:05 <jle`> want to do?
14:28:31 <int-index> I want ExceptT (Sum5 E1 E2 E3 E4 E5)
14:28:36 <mniip> (# Word#, Addr# #)
14:28:37 <int-index> and similarly for any N
14:28:53 <int-index> mniip, unboxed sum types have non-* kind, correct?
14:29:06 <mniip> I'm not sure
14:29:08 <mniip> probably
14:29:14 <mniip> they have a different calling convention
14:29:22 <int-index> unless it's *, I can't use them as ExceptT parameter
14:29:26 <int-index> other than that they fit the bill
14:30:01 <lyxia> (Word, Any) + unsafeCoerce sounds like a lot of fun
14:30:31 <int-index> (# Word#, Addr# #) won't have good pattern matching. I could define pattern-synonyms but they have bad interactions with exhaustiveness checker
14:30:43 <akr[m]> hello
14:31:10 <akr[m]> hello
14:31:27 <int-index> hello akr[m] 
14:31:39 <akr[m]> my `stack build` is failing with: Cabal-simple_mPHDZzAJ_1.18.1.5_ghc-7.8.4: The program cpphs is required but it could not be found.
14:31:51 <int-index> stack install cpp2hs
14:33:37 <akr[m]> int-index (IRC): ah, thank you
14:33:54 <akr[m]> can I fix this in stack.yaml somehow?
14:34:14 <akr[m]> I mean, I do have cpphs in extra-deps…
14:34:26 <int-index> I don't think so, it's a tool dependency, you just need it in PATH
14:34:31 <int-index> stack manages libraries
14:38:45 <hvr> fwiw, cabal new-build also manages build-tools available on Hackage
14:39:27 <hvr> thereby allowing to have multiple versions of the same build-tool being used inside one install-plan
14:41:34 <int-index> cool, I should try new-build
14:41:49 <akr[m]> hmm okay
14:41:58 <akr[m]> what about necessary C system libraries? Do I have to install those manually as well?
14:42:41 <mniip> int-index, Addr# wasn't serious
14:43:00 <mniip> with Addr# you are playing a game with the GC
14:43:17 <int-index> whatever, 'Any' is safe there
14:43:32 <int-index> I haven't looked at what Addr# is
14:43:41 <int-index> (just copied your suggestion)
14:44:30 <mniip> one thing worth mentioning, Any is not a type
14:44:44 <hvr> int-index: see also http://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-tool-depends
14:44:49 <mniip> I've run into this issue before
14:45:25 <int-index> it's a poly-kinded type family with no clauses, yep
14:45:41 <int-index> what issues can this cause? You can't define instances for it, but that's about it I would think
14:45:43 <jle`> int-index: pattern matching becomes kind of confusing for anonymous sums like that, especially if you want to modify or remove anything
14:45:51 <jle`> why not just define a custom error type?
14:46:02 <jle`> and do you handle errors often enough taht performance is a bottleneck?
14:46:09 <mniip> one sec
14:46:30 <abhiroop> Can someone please explain, in the notation Γ⊢TY σ:κ where TY is subscript, what does the TY mean? I mean I know Γ ⊢ σ:κ means in an environment Γ, σ is of type κ
14:47:48 <int-index> jle`, I'm looking for ways to flatten nested ExceptT. Right now I can use ExceptT E1 (ExceptT E2 (ExceptT E3 ...)) and it works great except for performance, so I'd like to flatten them
14:47:58 <int-index> I can't define a custom error type because I'm writing a library, not an application
14:48:39 <mniip> int-index, with some combination of extensions I've got 'put [undefined :: Any]' to be a type error
14:48:44 <jle`> would the user ever directly work with Sum5 E1 E2 E3 E4 E5 ?
14:48:47 <mniip> https://ghc.haskell.org/trac/ghc/ticket/10939
14:49:11 <mniip> ah
14:49:15 <mniip> fixed since 7.10
14:49:33 <int-index> jle`, yes, when he writes `runExceptT` he well get `m (Either (Sum5 E1 E2 E3 E4 E5) a)`
14:49:39 <int-index> which is why I want good pattern matching
14:49:59 <jle`> if you're giving something to the user, you might as well use a custom Sum5 type
14:50:02 <jle`> that's more meaningful
14:50:07 <jle`> a throaway
14:50:12 <jle`> with meaningful constructors
14:50:38 <int-index> it's an effect libraries, those constructors don't have meaning, they are just a union of exceptions
14:51:02 <int-index> it's all for performance only
14:51:50 <jle`> are you working with a fixed E1/E2/E3 etc. set, that will never change?
14:52:30 <int-index> No. I have a lib that defines custom `MonadReader`, `MonadState`, `MonadExcept` that unlike the ones for mtl allow for multiple effects in the same transformer stack
14:52:41 <int-index> e.g. with mtl you can't have `MonadReader r1 m, MonadReader r2 m`, but with my lib you can
14:53:03 <int-index> to handle those effects you could either use nested transformers (multiple ReaderT, StateT, ExceptT) or flatten them
14:53:14 <int-index> to flatten ReaderT and StateT I use tuples, to flatten ExceptT I need sums
14:53:33 <mniip> what if you flatten 63 readers
14:53:57 <int-index> You'll have to flatten them to a custom type. I don't hardcode tuples, they're just the default options
14:54:23 <Gurkenglas> int-index, the last project I saw using multi-target reader/state/except eventually switched to using the regular version with lenses
14:54:53 <Gurkenglas> (um i think it was writer not except)
14:55:31 <int-index> the problem with the lensy approach is that you can't add layers on top. E.g. you can't flatten some layers but not all
14:56:16 <int-index> and sometimes you don't want to flatten some of the layers because they don't commute, e.g. ExceptT E1 (StateT S1 (ExceptT E2 ...)) can't be flattened.
14:56:34 <int-index> and sometimes you don't want to flatten because adding one more ReaderT on top is an implementation detail in some function
14:56:50 <int-index> and sometimes you don't want to flatten because you have both strict and lazy state
14:57:40 <Gurkenglas> But in those cases you never want to flatten, right? Is there a case where you don't know in advance which you'll want to flatten?
14:58:47 <int-index> Well, let's say I have some 'm' that holds some environment and I want to use `ReaderT R m'. How do I access the inner environment? (anything involving lift doesn't count)
14:59:38 <Gurkenglas> I don't follow. You've only given me lift to work with.
14:59:50 <int-index> (the reason it doesn't count because there are operations, such as 'local', 'listen', 'pass', 'catch', that aren't trivial to lift manually)
15:00:52 <int-index> Gurkenglas, that's the point, with mtl you can't write 'f :: MonadReader a m => ReaderT b m a' and use 'local' for 'a'
15:01:20 <int-index> You'll have to resort to 'mapReaderT', and it's not nice
15:03:29 <int-index> Generally, I want to write code that doesn't know in advance whether it will be run flattened or not, and make the decision at call-site
15:04:40 <lyxia> abhiroop: it's used to disambiguate different judgements
15:06:55 <lyxia> abhiroop: it's useful to annotate the turnstile when you have multiple similar looking judgements with different rules.
15:07:01 <Gurkenglas> int-index, sounds like you want the dual of an anonymous record library
15:07:57 <int-index> Well, given that the anonymous record library is just a bunch of tuples with labels, you could put it like that
15:09:13 <abhiroop> lyxia: Thanks
16:00:48 <Csmnt> Anyone here built llvm for accelerate? I'm trying to build it from source, set it to shared, but I'm missing libLLVMLanaiInstPrinter, which is needed by accelerate-llvm. I've ran into wall with google and hoping someone has more information here
16:51:47 <AfC> If I add a custom-setup stanza to the library's .cabal file (as I have been recommended to do), should I up the cabal-version: field? Presumably _not_, for backward compatibility.
17:06:04 <lolisa> Hi, I need a list of *, and I need to fold on it to get a function on * -> *, can anyone give me some pointer?
17:08:29 <pacak> O_o
17:09:45 <mniip> fold what
17:11:55 <lolisa> fold the list of * (the fold function parameter is fixed)
17:12:39 <mniip> something here doesn't check out
17:13:14 <mniip> could you rephrase a bit perhaps?
17:13:32 <ab9rf> lsit of *?
17:13:32 <lolisa> Sure. So I have a * -> * function, let's call it D.
17:13:38 <mniip> so far I'm getting the impression that you're trying to fold over a list of kinds at the type level with -XTypeInType
17:13:58 <lolisa> Yes, I think I need something similar
17:14:09 <monochrom> If not for TypeInType you would be one level above kind-level programming.
17:14:10 <lolisa> D is represented as a open type familiy
17:14:52 <mniip> ok
17:14:56 <lolisa> now, I need to represent D a (D b (D c ....))), (with the nest as long as I like)
17:15:06 <lolisa> so, it seems like I need a fold on D
17:15:11 <mniip> you have to write a dedicated type family
17:15:18 <mniip> as you can't pass type families to type families
17:15:49 <mniip> no higher order functions in type families
17:16:07 <lolisa> Yes, isnt a problem, but I am not very familiar with singleton, I just couldnt figure out how to do the list of * part
17:17:10 <mniip> also
17:17:17 <mniip> that would make D :: * -> * -> *
17:17:20 <mniip> not * -> *
17:17:39 <lolisa> yes, sorry my fault, it is indeed * -> * -> *
17:18:47 <lolisa> do i, like, just replicate the stucture of Nat singleton, but with an extra type param floating? 
17:19:25 <mniip> are you looking for something like
17:19:36 <mniip> @let type family D a b where D a b = (a, b)
17:19:38 <lambdabot>  Defined.
17:19:38 <mniip> @let type family FoldD z xs where FoldD z '[] = z; FoldD z (x ': xs) = D x (FoldD z xs)
17:19:39 <lambdabot>  Defined.
17:19:48 <mniip> :t undefined :: FoldD () '[Int, String, Char]
17:19:49 <lambdabot> (Int, ([Char], (Char, ())))
17:20:15 <lolisa> Oh yes! Why does this work?
17:20:25 <mniip> why not
17:20:38 <lolisa> I mean, what should I read to understand this
17:21:31 <mniip> I'm not sure
17:22:29 <mniip> lolisa, ghc commentary should suffice?
17:22:37 <mniip> assuming you have a good grasp of regular haskell
17:23:18 <ab9rf> is there is a good reason why you can't have higher order functions for type families
17:25:11 <lolisa> Thx. Off to reading :) As a side note, cant we have higher order function by representing them as AST?
17:28:27 <mniip> ab9rf, undecidable equality
17:30:01 <mniip> @let type family F f where F Maybe = []
17:30:03 <lambdabot>  Defined.
17:30:10 <mniip> :t undefined :: F Maybe Int
17:30:11 <lambdabot> [Int]
17:30:30 <Guest65324> Hello, trying to learn Servant. I am a bit confused about types like this: data ReqBody (contentTypes :: [*]) a I believed earlier that you had to specify at least one value constructor for a data type. Am I to understand that this type (containing the *) creates a new type constructor instead. And if so where would the value constructors for those types come from?
17:31:01 <mniip> ab9rf, there is an obvious workaround: assigning non-arrow kinds to type families
17:31:12 <mniip> which is already done in ghc core, but
17:31:24 <mniip> well, it's too late for me to be able to comprehend the complications of that
17:32:24 <sgronblo> Also, am I remembering correctly that the '[] is a type level list?
17:32:27 <lyxia> sgronblo: it's an empty type, it doesn't have any value
17:32:42 <geekosaur> sgronblo, welcome to type level programming. contentTypes has kind [*] (a kind is the "type" of a type)
17:33:15 <geekosaur> so yes, it's a type level list, and at value level it is not inhabited since it does not have kind *
17:34:35 <sgronblo> What about the data type that doesnt have any value constructors?
17:34:44 <lyxia> sgronblo: it's an extension https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#data-types-with-no-constructors
17:35:10 <monochrom> Do you mean Void?
17:35:34 <sgronblo> I'll re-ask the question: Hello, trying to learn Servant. I am a bit confused about types like this: data ReqBody (contentTypes :: [*]) a I believed earlier that you had to specify at least one value constructor for a data type. Am I to understand that this type (containing
17:35:38 <sgronblo>                     the *) creates a new type constructor instead. And if so where would the value constructors for those types come from?
17:35:50 <geekosaur> there are no value constructors
17:36:08 <geekosaur> in standard Haskell, which does not have type level programming, all types must have values
17:36:22 <geekosaur> ghc has been extended for type level programming
17:36:54 <geekosaur> in this case, you can have types which act as type level tags, and which can be accumulated into type level lists like (contentTypes :: [*])
17:38:02 <sgronblo> Hmm, but surely some code must access this as a value at some point?
17:38:25 <lyxia> no
17:38:43 <geekosaur> are you familiar with phantom types?
17:41:09 <geekosaur> data Foo e a = Foo a -- e is phantom, only takes part in type checking, never has an associated value, and can be used as a tag to separate different Foo-s.
17:41:22 <geekosaur> this is a more advanced form of that
17:42:54 <geekosaur> for a simpler example, Either String Int, Right 5 -- the Right 5 still has a String associated at type level but not at value level; if you are given a Right 5 :: Either String Int, it will not typecheck when used as (say) Either Bool Int
17:43:47 <sgronblo> Ok, that makes sense.
17:44:21 <sgronblo> But now I need to figure out how to get back from a simple example like that to the grandness of type-level programming.
17:45:07 <geekosaur> its like that data Foo e a I mentioned, where e is always phantom --- but here, it's not merely phantom, it's a *list* of phantom types
17:45:22 <geekosaur> which is what the :: [*] is saying
17:45:52 <geekosaur> (implicitly it would be :: * otherwise, a "normal" type like Int or String)
17:46:02 <sgronblo> Are you aware of any beginner-friendly articles about the topic?
17:46:34 <geekosaur> not really. I'm not actually much farther along in this than what I've said, so I could do with one myself >.>
17:47:47 <sgronblo> Ok :)
17:47:51 <MarcelineVQ> https://arow.info/blog/posts/2015-07-10-servant-intro.html
17:49:34 <sgronblo> Oh, it's by Dennis
17:51:40 <fXl> http://lpaste.net/354872, i am getting this error, Expected type: Parser Info, Actual type: Parser (Command -> Info). Can anybody help?
17:52:23 <sgronblo> fXl: My guess is that you forgot to apply a command argument to one of your functions
17:54:01 <lyxia> sgronblo: Stephanie Weirich gave a cool talk about type-level programming at POPL this year
17:54:46 <fXl> sgronblo, i didnt understand what u meant
17:55:02 <sophiag> i've never used F#, but i just came across this: http://fsprojects.github.io/FSharp.Quotations.Evaluator/
17:55:41 <sophiag> it allows you to transform their ASTs at compile time, seemingly similar to macros in Lisps
17:55:45 <lyxia> fXl: where is that error
17:56:26 <fXl> lyxia, line 10
17:56:27 <sophiag> i'm wondering if there's anything similar for Haskell? for quoting and evaluating Haskell ASTs? i'm essentially trying to DIY that myself right now and it's _really_ painful
17:56:42 <geekosaur> sophiag, that'd be Template Haskell
17:56:45 <Koterpillar> sophiag: other than TH?
17:56:47 <geekosaur> but it is specifically compile time
17:56:47 <Koterpillar> ...yeah
17:57:27 <sophiag> yes, i mean _other_ than TH
17:57:44 <sophiag> at least that seems like what this F# thing does
17:57:46 <lyxia> fXl: "data Info = Info {" I'm not sure how you can even get a type error here
17:58:26 <lyxia> fXl: BTW the code you pasted is not even syntactically correct
17:59:42 <fXl> lyxia, Couldn't match type ‘Command -> Info’ ,with ‘Info’
17:59:43 <sophiag> i've been parsing simple lambdas using haskell-src-exts to store in records, basically like quoting them in a Lisp to apply later, but making the types work was incredibly difficult and i still have a last bug i'm tried forever to figur out
17:59:46 <fXl> why incorrect ?
18:00:46 <lyxia> fXl: there's an extra comma line 2 and line 7 has a trailing operator
18:01:10 <lyxia> fXl: so the code you are compiling is not the code you have shown us
18:01:20 <fXl> i simplified it yeap
18:02:01 <monochrom> Simplification is OK but there is a different between lossless simplification and lossy simplification.
18:02:08 <geekosaur> that's not helpful unless the code compiles and shows the error
18:02:36 <monochrom> Incidentally it is also equivalent to the skill of good abstraction vs the skill of broken abstraction.
18:02:51 <AfC> Why would stack be bugging me about modules not in exposed-modules or other-modules for a *test suite*? Those modules from from the library under test, not the test suite (and in any case, da fu?)
18:03:49 <sophiag> geekosaur: perhaps i should actually be using template haskell? tbh i assumed that'd be like using C++ templates so figured it was a bad way to go if i had any other options. otoh, i feel like i've mostly figured out how to actually parse lambda ASTs to store as data although I may be fooling myself about the complexity i've created :/
18:04:44 <lyxia> AfC: the files that do not appear in your configuration will not be packaged up, so you end up with an incomplete package when you release it
18:04:44 <fXl> you are right
18:05:15 <fXl> lyxia, can i pm you ?
18:05:51 <geekosaur> sophiag, language-haskell-exts pretty much is the runtime version; there is a wrapper to make the types match up with TH but that won't help you. it's in any case going to be equally difficult with either one
18:06:20 <lyxia> fXl: as you wish
18:06:55 <lyxia> AfC: is your test directory the same as the one of your library
18:08:11 <sophiag> geekosaur: haskell-src-exts only parses Haskell expressions from my command line repl into ASTs. it doesn't allow me to quote them and then apply later. in between i need to parse the ASTs into a form i can store as data and then apply to what i want with the types all matching up. _that_ is the part that's adding all the complexity
18:09:07 <geekosaur> sounds like you are writing a typechecking compiler. guess what? it's hard.
18:09:32 <sophiag> ha
18:09:39 <geekosaur> and no, it's not generally "canned" because there's no single type environment that works for everyone\
18:09:44 <monochrom> Oh, type checking is already the easy one. Type inference is the harder one.
18:10:03 <sophiag> that's true. most of the difficulty is in mixing types in the expressions
18:10:12 <geekosaur> and while ghc exposes parts of its guts, they're not necessarily the right parts for you to reuse here
18:10:32 <sophiag> if i just said they all have to be of one type and didn't use ADTs it would be a whole lot simpler
18:11:20 <sophiag> but to be clear, i'm not actually typechecking them. as of where i'm at now it's still possible to use the DSL to apply the lambdas to data of the wrong type and crash the repl
18:13:06 <AaronFriel> Why does the newtype Kleisli have the role annotation `type role Control.Arrow.Kleisli representational representational nominal`, shouldn't that last parameter be representational? `newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }`. Shouldn't that be coercible?
18:13:56 <byorgey> AaronFriel: probably because the m can be instantiated with anything, and it might use its type argument in a nominal way
18:13:58 <sophiag> geekosaur: i was just thinking, regardless of types, it would so much easier if i could skip parsing the ASTs and just quote them and call eval on them later as in Lisps. as it stands my bug is largely due to the way i have to recursively parse the lambds to allow for nested expressions on the rhs, which leave me with two maybes to unwrap as well as the ADT compromising all the types. plus it's so hard to debug since there's no show
18:13:58 <sophiag> instance for them and any errors i'd have to propogate all the way through from low level parsing functions to the REPL i'm running in IO
18:14:09 <byorgey> AaronFriel: so you have to assign b a nominal role to be safe
18:14:18 <AaronFriel> @byorgey: Is there a way to construct a type like Kleisli with role representational in its output?
18:14:18 <lambdabot> Unknown command, try @list
18:14:53 <byorgey> AaronFriel: good question, I don't know.
18:15:23 <byorgey> AaronFriel: I suppose you would want a way to abstract over  m  whose type argument is representational, but I don't know if there's a way to express that
18:15:36 <byorgey> i.e. role-polymorphism
18:15:48 <AaronFriel> Anyone else have any idea? I am struggling with my research and I have hit and overcome a number of walls based on my understanding of GHC's typesystem, but it is getting harder ;_;
18:17:18 <byorgey> AaronFriel: this seems related, perhaps? https://ghc.haskell.org/trac/ghc/ticket/9123
18:17:41 <byorgey> AaronFriel: you should ask Richard Eisenberg
18:18:17 <byorgey> or just send an email to the haskell-cafe mailing list, he will probably respond
18:18:18 <AaronFriel> Indeed, he seems to be the person whose name keeps showing up in discussions on type features I'm trying to (ab)use.
18:18:35 <AaronFriel> byorgey: thanks for that tip! I will pursue that.
18:27:09 <ExpHP> I am having huge trouble with parsing a yaml file in a memory efficient fashion.  see here: https://github.com/ExpHP/haskell-memory-halp
18:27:52 <ab9rf> ugh
18:27:54 <ExpHP> my current issue is summarized under "Status" in the readme, but long story short I have no idea what I'm doing with conduit
18:28:08 <ab9rf> yaml shouldn't be that piggy to parse
18:28:32 <ExpHP> ab9rf: piggy?
18:28:50 <sophiag> geekosaur: actually this looks very similar to what i've been doing with haskell-src-exts: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell-quasi-quotation
18:28:52 * ExpHP @(O_O)
18:29:27 <ab9rf> the issue is at what point can the runtime determine that it no longer needs data
18:29:48 <ab9rf> otherwise it's forced to instnatiate the entire in-memory representatikon of the document you're parsing
18:32:30 <ExpHP> ab9rf in Attempt2 I tried using an implementation which only extracts the data I want, but it still seems to construct the full value in memory profiles https://github.com/ExpHP/haskell-memory-halp/blob/master/app/Attempt2.hs
18:33:08 <lyxia> as you already noticed fromJSON is not streaming
18:33:52 <ab9rf> it's likelyu that fromJSON is stricter than you'd like
18:34:04 * ExpHP ticks off a checkmark on his list of "possibly true conclusions I've come to"
18:37:06 <lyxia> I don't understand how Libyaml works
18:38:17 <ab9rf> just becuase haskell allows laziness doesn't mean the library you're fiddling with is lazy
18:42:57 <ExpHP> lyxia: It produces a stream of Events (like e.g. SequenceStart), which follow a certain structure that can be described with a grammar. Text.Libyaml provides a Conduit of these events.
18:43:15 <ExpHP> ConduitParser isn't part of that API, but rather,  I've chosen (perhaps poorly) to use ConduitParser to "parse" according to this grammar
18:44:16 <ExpHP> My big trouble right now is a limitation of ConduitParser, but I don't know if this limitation is a fundamental limitation, or an incidental one...
18:44:25 <ab9rf> hm, that's likely to force parsing the entire docuemnt
18:44:41 <ab9rf> if you're only interested in a tiny bit of it you probably need a different approach
18:45:25 <ab9rf> i'm not sure you can really lazy out of parsing most of a yaml document though
18:45:57 <ab9rf> you can probalby avoid calling deserializers for specific values yu don't care about but other than that it has to scan over the whole document
18:46:05 <ExpHP> ab9rf: My approach is that 90% of the file is only validated with "skipping" parsers that read the corresponding production, but only produce ()
18:47:07 <ExpHP> This is necessary to handle nested structures correctly, but has a flat memory profile
18:48:06 <ExpHP> Meanwhile I have a function that e.g. takes the event stream for a mapping (associative array), and reduces it to just those events for the one value I care about
18:48:47 <ExpHP> (The trouble is how to write something which forwards only those events into a parser)
18:50:33 <ExpHP> https://github.com/ExpHP/haskell-memory-halp/blob/master/app/Attempt4.hs#L258-L267
19:02:29 <pacak> How would I go about replacing one of the libraries used by stack project by locally patched version?
19:03:29 <Koterpillar> pacak: https://docs.haskellstack.org/en/stable/yaml_configuration/#local-dependency-packages-extra-dep
19:04:42 <pacak> Koterpillar: Thanks
19:06:52 <lyxia> ExpHP: memory remains bounded if you just run the libyaml event parser and let them through, right?
19:07:42 <ExpHP> lyxia: Yep. Stays under 100K. In fact I believe that's what the current 'main' does of Attempt4
19:12:04 <mjora7> Hey, could someone give me some insight on what the preferred style to use between these three solutions is? https://gist.github.com/aryaforghani/bc9fe7b78c000ff8cb1b0ad7ca2bc992#file-fib-hs
19:12:36 <mjora7> I'm leaning towards the first one (parameter pattern matching) because it seems the simplest to parse visually.
19:13:06 <monochrom> Yes.
19:15:16 <mjora7> Yay!
19:24:48 <ExpHP> added an image of the pure-Libyaml memory profile.  This is why I think something along my current strategy is viable goo.gl/1h2q3a
19:25:54 <ExpHP> contrast with https://goo.gl/tLdaJy for trivial use of fromJSON
19:42:44 <rotaerk> hmm is there some way to display the type of a caught exception
19:42:56 <rotaerk> I'd like to be more specific about which type I catch, but I don't know what its type is
19:43:03 <rotaerk> so for the moment I'm just catching SomeException
19:46:27 <ExpHP> rotaerk: SomeException is Show, right? Does that Show instance give what you need?
19:47:00 <rotaerk> nope, it just shows the message of the exception
19:47:13 <m0cesta> Hi all. How to run leksah IDE? :)
19:48:01 <Koterpillar> rotaerk: it's Typeable, which will help you
19:48:12 <Koterpillar> hmm... maybe not
19:48:16 <m0cesta> Every time I run leksah IDE building starts again
19:48:35 <m0cesta> /leksah.sh file
19:49:32 <rotaerk> Koterpillar, yea I saw that it was Typeable, but didn't see a way to get the runtime type information
19:50:01 <ExpHP> yeah looks like you really can't since Proxy# has "no runtime representation"
19:50:43 <Koterpillar> typeOf?
19:50:45 <rotaerk> oh wait, there's that
19:50:46 <rotaerk> yea
19:51:52 <rotaerk> ugh, it just gave me SomeException
19:52:33 <ExpHP> rotaerk can you catch the type "(Exception e)=> e" instead?
19:52:42 <ExpHP> (I don't use catching very often...)
19:54:24 <rotaerk> nope
19:55:41 <ExpHP> oh, rotaerk, you should deconstruct the SomeExtension
19:55:45 <ExpHP> rotaerk: http://stackoverflow.com/questions/9799734
19:56:00 <ExpHP> *SomeException
19:56:04 <rotaerk> .. interesting
19:56:05 <rotaerk> thanks
19:57:38 <rotaerk> yep, that did it :)
19:58:26 * ExpHP scratches his head at how Haskell's runtime works...
20:00:06 <pacak> ExpHP: https://media.giphy.com/media/12NUbkX6p4xOO4/giphy.gif
20:07:05 <iqubic> Anyone have a guide for emacs haskell-mode?
20:18:01 <MisterEcho> Hai
20:18:25 <SrPx> Why is "not A" defined as ∀ (C : *) . (A => C)? Something is not true if it implies everything? What
20:19:33 <iqubic> Can't you just use pattern matching to do not?
20:19:41 <iqubic> not True = False
20:19:48 <iqubic> not False = True
20:19:54 <SrPx> I mean logically not
20:20:17 <iqubic> What is that?
20:20:57 <SrPx> I mean the negation of a proposition
20:22:06 <rotaerk> :t liftA not
20:22:08 <lambdabot> Applicative f => f Bool -> f Bool
20:23:41 <ExpHP> SrPx: The False proposition is the one that can prove anything, i.e.  forall a. a
20:23:51 <ExpHP> SrPx: Then "not a" is just a -> False
20:24:59 <thimoteus> note that if A is true, then A -> False is false, and if A is false, then A -> True is true
20:25:18 <thimoteus> err, A -> False is true
20:26:20 <ExpHP> in fact both are true,
20:26:32 <ExpHP> that's kind of the issue with False :)
20:28:15 <Eucliffe> Hi
20:28:27 <lambdabot> Hello.
20:28:29 <SrPx> ExpHP: shouldn't `not A`, then, be `∀ (x : A) => ∀ (P : *) => P`? 
20:28:30 <jle`> hi Eucliffe 
20:28:51 <Eucliffe> What's up :D
20:30:07 <Eucliffe> It2 a lot of people in this channel 
20:31:09 <glguy> Eucliffe: This channel is specifically about the Haskell programming language. Did you come to chat about Haskell?
20:31:57 <rotaerk> hmm... I need a:  [a -> Bool] -> a -> Bool
20:32:05 <jle`> rotaerk: looks like 'sequence'
20:32:38 <jle`> oh wait, sequence :: [a -> Bool] -> a -> [Bool]
20:32:50 <jle`> how do you want to combine the Bool's?
20:32:55 <rotaerk> &&, in this case
20:33:05 <iqubic> That's just all
20:33:09 <iqubic> :t all
20:33:10 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
20:33:11 <jle`> :t \fs x -> all ($ x)
20:33:12 <rotaerk> not exactly
20:33:13 <lambdabot> Foldable t => t1 -> a -> t (a -> Bool) -> Bool
20:33:19 <jle`> er
20:33:21 <jle`> :t \fs x -> all ($ x) fs
20:33:23 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
20:33:39 <iqubic> Nope. Note the dangling t at front
20:33:45 <biglambda> What is required for a package to be fully indexed by Hackage?
20:33:48 <jle`> iqubic: t can be []
20:33:57 <iqubic> Right.
20:33:57 <jle`> [] is an instance of Foldable
20:34:01 <iqubic> I feel stupid
20:34:10 <biglambda> I’m interested in helping get this package working: https://hackage.haskell.org/package/qtah-qt5
20:34:10 <jle`> not stupid :)
20:34:26 <rotaerk> hmm thanks
20:34:29 <jle`> :t \fs -> and . sequence fs
20:34:31 <lambdabot> Traversable t => t (a -> Bool) -> a -> Bool
20:35:23 <iqubic> That works too in this case
20:35:24 <ExpHP> SrPx: I'm not sure what your notation means then.  I read "A => B" as "a witness to A admits a witness to B".  So with that, I'm not sure what the (x : A) accomplishes
20:35:24 <MarcelineVQ> that's quite nice
20:35:54 <jle`> sequence :: [a -> b] -> (a -> [b]), but you have to and-up the result
20:36:03 <jle`> all ($ x) is definitely more readable
20:36:14 <iqubic> Yeah. 
20:36:31 <iqubic> Isn't there a monoid we can use to make this simpler?
20:36:34 <iqubic> :t all
20:36:35 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
20:37:02 <iqubic> I think that using the all monoid could and up all the values.
20:37:06 <jle`> i doubt you can make it simpler, but you can implement it using monoid-polymorphic functions
20:37:14 <ExpHP> SrPx: and between  "A => forall (B : *). B" or "forall (B : *). A => B", I think both of which should be equivalent
20:37:30 <ExpHP> s/of which//
20:38:06 <jle`> :t \fs -> getAll . foldMap (All .) fs
20:38:07 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
20:38:20 <iqubic> That's not any simpler.
20:38:31 <jle`> that's my point :)
20:38:32 <iqubic> I like the ($ all)
20:40:42 <rotaerk> catchIf (\(ex :: IOException) -> all ($ ex) [...])
20:42:01 <SrPx> ExpHP: I get it thanks
20:42:50 <SrPx> ExpHP: not sure I get why those should be equivalent, though. I mean, logically it is obvious, but I can't just move foralls like that everytime I guess
20:45:47 <ExpHP> SrPx: foralls are like lambdas for types.   forall (B : *) . A => B is like a function that takes a type B and produces a witness to (A => B)
20:47:00 <ExpHP> SrPx then one can use this function to construct the function `forall (B: *) B` from a witness of A
20:47:07 <ExpHP> and vice versa
20:48:17 <ExpHP> SrPx: Actually don't take anything I say here too literally since my experience with dependent types is limited to about one week playing around with Lean :P
20:54:24 <SrPx> but you can't move lambdas like that too
20:54:30 <SrPx> I think I got confused with the syntax though
20:54:39 <SrPx> the question is:
20:55:06 <SrPx> why we call the "or" type Either
20:55:18 <SrPx> but we don't call the "and" type Both?
20:55:28 <Sornaensis> :info Or
20:55:31 <SrPx> sleep with that, good night
20:55:37 <Sornaensis> @info Or
20:55:37 <lambdabot> Or
20:55:40 <Sornaensis> @info And
20:55:40 <lambdabot> And
20:55:40 <ExpHP> Because we like (,,,,,,,)
20:55:47 <Koterpillar> SrPx: https://twitter.com/antiselfdual/status/855995687900561408
20:55:49 <Sornaensis> because And and Or are boolean monoids
20:55:50 <SrPx> ExpHP: :P
20:55:54 <rotaerk> :t \comb preds a -> comb ($ a) preds
20:55:54 <Sornaensis> and Either is differnt
20:55:55 <lambdabot> (((a -> b) -> b) -> t1 -> t) -> t1 -> a -> t
20:56:18 <jle`> SrPx: we do sometimes, but in haskell, it's just (,)
20:57:17 <SrPx> Koterpillar: that works? Even better if we could use "|" and "&", so they look like they look on JSDocs stuff so we make JS devs less afraid
20:57:55 <jle`> heh, we already have :*: and :+:
20:58:04 <jle`> maybe we can have :|: and :&: too
20:58:10 <rotaerk> :t \preds a -> all ($ a) preds
20:58:11 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
20:58:24 <SrPx> jle`: fair enough (:
20:58:26 <rotaerk> seems like a function like that might be useful to have around...
20:58:41 <jle`> rotaerk: feels a little too specialized
20:58:46 <jle`> fairnbarn threshold stuff
20:58:49 <rotaerk> catchIf (allPred [predicate1, predicate2])
20:59:12 <jle`> @let data a :|: b = Or1 a | Or2 b
20:59:13 <lambdabot>  Defined.
20:59:28 <jle`> @let data a :&: b = a :&: b
20:59:29 <lambdabot>  Defined.
20:59:32 <jle`> yay
20:59:45 <SrPx> @let data a || b = Or1 a | Or1 b
20:59:46 <lambdabot>  .L.hs:174:15: error:
20:59:47 <lambdabot>      Multiple declarations of ‘Or1’
20:59:47 <lambdabot>      Declared at: .L.hs:169:16
20:59:52 <SrPx> @let data a || b = Or1 a | Or2 b
20:59:53 <lambdabot>  .L.hs:174:15: error:
20:59:53 <lambdabot>      Multiple declarations of ‘Or1’
20:59:53 <lambdabot>      Declared at: .L.hs:169:16
20:59:58 <SrPx> uh
21:00:03 <jle`> @undefine
21:00:03 <lambdabot> Undefined.
21:00:05 <SrPx> @let data a || b = OrA a | OrB b
21:00:06 <lambdabot>  Defined.
21:00:10 <SrPx> yay 
21:00:19 <jle`> @let data a && b = a :&: b
21:00:20 <lambdabot>  Defined.
21:00:22 <jle`> neat
21:00:31 <SrPx> ok, hold on,
21:00:34 <SrPx> @undefine
21:00:34 <lambdabot> Undefined.
21:00:49 <SrPx> @let data a || b = OrA a | OrB b
21:00:51 <lambdabot>  Defined.
21:05:24 <SrPx> @let f :: Int -> (Bool || String); f 0 = OrA True; f x = OrB "aaaa"
21:05:25 <lambdabot>  Defined.
21:05:54 <SrPx> @show (f 0, f 1)
21:05:54 <lambdabot> "(f 0, f 1)"
21:06:03 <SrPx> thanks, lambdabot
21:09:28 <lpaste> ExpHP pasted “No title” at http://lpaste.net/8281982473349365760
21:09:43 <ExpHP> ^ SrPx: Interestingly, ghc even unifies these types
21:09:54 <ExpHP> lpaste: I thought I clicked "Private"!
21:12:56 <iqubic> What does that sysntax even mean??
21:13:31 <iqubic> Int -> (Bool || String)
21:13:39 <jle`> ExpHP: (A -> forall b. b) is the same as forall b. A -> b
21:13:39 <iqubic> What return type does that have?
21:13:47 <jle`> iqubic: the return type is Bool || String
21:13:52 <jle`> (||) is jsut a normal type constructor
21:13:54 <jle`> it was defined earlier
21:14:02 <jle`> about 14 minutes ago
21:14:12 <iqubic> Ah. I see that now.
21:14:26 <iqubic> What does forall mean???
21:14:37 <SrPx> "unifies"? ExpHP
21:14:48 <Xe> iqubic: it's explicitly saying that it can be literally any type with no constraints
21:14:58 <jle`> iqubic: it "scopes" a type variable
21:15:00 <ExpHP> SrPx it considers the two types to be equal
21:15:09 <iqubic> So why not just omit the forall?
21:15:10 <jle`> it brings a type variable into scope
21:15:10 <SrPx> ExpHP: how do you know?
21:15:15 <jle`> iqubic: usually forall is implicit
21:15:22 <jle`> but ghc lets you provide it explicitly
21:15:30 <Xe> iqubic: -XExistensialQuantification needs you to do it for one
21:15:30 <SrPx> ExpHP oh I see
21:15:31 <ExpHP> SrPx because the program I posted compiles
21:15:37 <jle`> for example, sort :: Ord a => [a] -> [a] is "actually" sort :: forall a. Ord a => [a] -> [a]
21:15:47 <iqubic> Why do you use a . after the forall declaration?
21:15:59 <jle`> that's just the syntax choice
21:16:03 <Xe> iqubic: that's the syntax
21:16:07 <iqubic> why forall a. and not forall a, Ord a?
21:16:14 <jle`> arbitrary decision
21:16:25 <iqubic> Why a period instead of a comma? Is that what people decided?
21:16:25 <jle`> from the people who made the syntax
21:16:34 <SrPx> ExpHP: wait LOL your program has crashed my mind
21:16:36 <jle`> yes, that's just the syntax in the spec
21:16:42 <iqubic> That's odd.
21:17:01 <Xe> makes reading for it easy
21:17:19 <jle`> iqubic: it borrows from math, actually
21:17:21 <iqubic> Yeah, I understand.
21:17:29 <iqubic> jle`: What do you mean?
21:17:37 <iqubic> "borrows from math"?
21:17:48 <jle`> from math notaiton
21:18:19 <SrPx> iqubic: he means math uses a "." too, ∀ a . b
21:19:13 <iqubic> SrPx: I'm not familiar with that construct.
21:19:33 <iqubic> Note: I haven't taken any pre-calc or beyond yet.
21:19:41 <SrPx> so wait, you can type any program that way
21:19:51 <iqubic> What way?
21:19:52 <jle`> people aren't really expected to be familiar with it, for the most part
21:20:05 <jle`> you can just assume it to be an arbitrary syntax choice
21:20:07 <ExpHP> Actually I almost never see that.  In physics they tend to write  "blah blah blah  (∀ x Real)"
21:20:09 <jle`> like how we use \ for lambdas
21:20:14 <SrPx> like, `x, y : forall a . a; x = y; y = x;` 
21:20:28 <SrPx> does that compile? I'm not with GHC on this machine
21:21:08 <ExpHP> > x, y : forall a . a; x = y; y = x;
21:21:10 <lambdabot>  <hint>:1:2: error: parse error on input ‘,’
21:21:13 <ExpHP> le gasp
21:21:21 <jle`> haskell is ::, anyway :o
21:21:32 <SrPx> > x : forall a . a; x = y; y : forall a . a; y = x
21:21:33 <ExpHP> > x, y :: forall a . a; x = y; y = x;
21:21:34 <lambdabot>  <hint>:1:17: error: parse error on input ‘;’
21:21:34 <lambdabot>  <hint>:1:2: error: parse error on input ‘,’
21:21:35 <SrPx> woops
21:21:39 <ExpHP> hehe
21:21:42 <jle`> another arbitrary syntax choice that we all sffer from even today
21:21:42 <SrPx> > x :: forall a . a; x = y; y :: forall a . a; y = x
21:21:44 <lambdabot>  <hint>:1:18: error: parse error on input ‘;’
21:21:59 <ExpHP> SrPx just tested on ghc and it does compile...
21:22:12 <jle`> lambdabot only evaluates expressions
21:22:19 <iqubic> What the heck is wrong with lambdabot then?
21:22:23 <SrPx> how did you come up with that idea? we just proved false, right?
21:22:28 <jle`> SrPx didn't type in an expression
21:22:36 <jle`> it was a declaration
21:22:37 <iqubic> Try using the @let
21:22:50 <m0cesta> stack with default latest lts can't build haskelldb package. I got error when change resolve. Can anyone help me with this?
21:22:50 <jle`> SrPx: you can prove false in haskell
21:22:54 <ExpHP> SrPx proving false is easy in a language that isn't total. 
21:22:58 <SrPx> also is that why a type system with recursion is always inconsistent?
21:23:07 <jle`> that's why haskell is called inconsistent
21:23:21 <iqubic> @let x :: forall a . a; x = y; y :: forall a . a; y = x
21:23:22 <lambdabot>  .L.hs:165:5: error:
21:23:22 <lambdabot>      Ambiguous occurrence ‘y’
21:23:23 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.y’,
21:23:23 <SrPx> jle`: among other reasons, right? Not only recursive bindings
21:23:28 <alpin> hi
21:23:32 <ExpHP> here's an easier proof of false:
21:23:34 <ExpHP> > undefined
21:23:36 <lambdabot>  *Exception: Prelude.undefined
21:23:39 <jle`> well, the fact that you can prove False is a necessary and sufficient condition for something being inconsistent
21:23:47 <iqubic> What are we trying to prove here?
21:24:26 <SrPx> I'm really glad for that actually, I was thinking a lot about this
21:24:31 <ExpHP> > let x :: forall a.a = x in x
21:24:33 <lambdabot>  error:
21:24:33 <lambdabot>      • Cannot instantiate unification variable ‘a0’
21:24:33 <lambdabot>        with a type involving foralls: forall a1. a1
21:24:41 <ExpHP> > let x :: a = x in x
21:24:43 <lambdabot>  error:
21:24:43 <lambdabot>      • You cannot bind scoped type variable ‘a’
21:24:43 <lambdabot>          in a pattern binding signature
21:24:55 <ExpHP> > let x = x in x
21:25:00 <lambdabot>  mueval-core: Time limit exceeded
21:25:09 <SrPx> so, if we extend the calculus of constructions with type-level recursion (i.e., the type of `fix x` is *), is that enough to make it inconsistent? I don't think you can do that trick we did here with that 
21:25:46 <iqubic> > fix (false &&)
21:25:48 <lambdabot>  error:
21:25:48 <lambdabot>      • Variable not in scope: false :: Bool
21:25:48 <lambdabot>      • Perhaps you meant data constructor ‘False’ (imported from Data.Bool)
21:25:54 <iqubic> > fix (False &&)
21:25:56 <lambdabot>  False
21:26:05 <iqubic> > fix (True ||)
21:26:07 <lambdabot>  True
21:26:32 <SrPx> iqubic: I was just surprised how easy it was to make an element of type `forall a . a` 
21:26:45 <iqubic> How did you do it?
21:27:02 <jle`> 'let x = x in x', or even 'undefined', etc.
21:27:16 <iqubic> Right.
21:27:29 <m0cesta> stack with default latest lts can't build haskelldb package. I can't change lts with --resolve because of building error. Can anyone help me with this?
21:27:34 <iqubic> :t let x = x in x
21:27:35 <ExpHP> funny how "let x = x in x" doesn't get hit by the monomorphism restriction
21:27:35 <lambdabot> t
21:27:44 <ExpHP> or ambiguous type errors
21:27:51 <iqubic> What restriction is that?
21:27:53 <jle`> ExpHP: there's defaulting
21:28:08 <SrPx> well ExpHP did it I guess, he used `x = y` where y was declared to have type `forall a . a`, then said `y = x`, which also was declared to have type `forall a . a`, so like, both terms are defined in term of each-other, they are never really defined, but it kinda tricks the compiler into accepting it 
21:28:09 <jle`> it would be affected by it when it's on
21:28:12 <iqubic> What is defaulting?
21:28:20 <jle`> @where DMR
21:28:20 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
21:28:37 <iqubic> Why is it DMR? What does that stand for?
21:28:43 <jle`> look at the link :)
21:29:35 <jle`> ExpHP: `let x = x in x` should be affected by the dmr just as much as anything else
21:30:08 <iqubic> except what value could the compiler assume for x
21:30:21 <glguy> jle`: I wouldn't expect so, there's no typeclass constraints on x
21:30:25 <iqubic> How do you make x less polymorphic in that case?
21:30:56 <ExpHP> SrPx actually though the only point of that program was to show that notA could be defined in terms of notA' and vice versa :P
21:31:34 <iqubic> Haskell is a weird programing language.
21:32:03 <iqubic> I like the theory behind it, but who thinks *this* much when writing a program?
21:32:15 <glguy> ExpHP: It doesn't get hit by the monomorphism restriction because its inferred type has no typeclass constraints
21:32:28 <jle`> iqubic: the advantage of haskell is that you don't have to think when writing your program
21:32:44 <jle`> iqubic: the compiler thinks for you, so the actual coding is something you can do on autopilot
21:33:18 <iqubic> And it's infered type can't have any typeclass constraints. What reasonable constraint can you give "let x = x in x"?
21:33:42 <ExpHP> seems to me that an awful lot of thinking is required to "debug" most type errors...
21:34:15 <Koterpillar> sometimes the compiler forces you to think. Usually about edge cases
21:34:22 <iqubic> Like what Koterpillar?
21:34:49 <Koterpillar> if something gives you a Maybe String and you want to give it to another function that expects a String, you have to think about the case of Nothing
21:35:24 <iqubic> Yes, but that's simple.
21:35:51 <iqubic> It's like passing Either a b into a function requires you to think about left a and right b
21:36:01 <ExpHP> what I mean is how type inference tends to take a mistake somewhere on line 135 and make it manifest as a very misleading/confusing type error on line 132
21:36:23 <ExpHP> "But IT IS a Maybe! I don't understand!"
21:37:13 * ExpHP starts inserting (id :: () -> ()) everywhere
21:37:27 <iqubic> Ah, yeah. That's why you should always use type signatures to aid the compiling proccess along.
21:37:37 <opqdonut> ExpHP: that's why it's common practice to add type signatures to all toplevel definitions
21:37:49 <opqdonut> limits how far type inference can propagate errors :)
21:38:03 <iqubic> That's talked about in the DRM article.
21:38:23 <iqubic> f1 x = show x
21:38:30 <iqubic> f2 = show
21:38:43 <iqubic> f3 = \x -> show x
21:38:51 <iqubic> f4 = \x -> show
21:39:04 <iqubic> Are all different because of DRM
21:39:41 <iqubic> however, all of the functions can be prefaced by: show a => a -> String
21:42:04 <Koterpillar> f4 is the wrong type
21:46:15 <m0cesta> heeeey, guys, help me with haskell stack
21:46:32 <SrPx> ExpHP: I know, I understood that, just caught my attention and now I'm reading about type level recursion
21:48:47 <iqubic> SrPx: you mean like Tree a = Leaf | Node (Tree l) a (Tree r)
21:48:59 <iqubic> Would that be type level recursion?
21:49:43 <pacak> Tree a b = Leaf | Node b a b?
21:49:57 <iqubic> pacak: What is that?
21:50:23 <iqubic> Usually a tree has plenty of branches.
21:50:39 <iqubic> Not seeing the branching structure in your code
21:51:02 <iqubic> Usually the branch of a tree is a tree itself. Not seeing that.
21:51:13 <pacak> Hmm... Actually Tree b a = Leaf | Tree b a b
21:51:14 <Koterpillar> m0cesta: ask the actual question
21:51:15 <pacak> :t Fix
21:51:16 <lambdabot> error:
21:51:17 <lambdabot>     • Data constructor not in scope: Fix
21:51:17 <lambdabot>     • Perhaps you meant one of these:
21:51:21 <jle`> iqubic: then you just need Tree a (Tree a b) :)
21:51:50 <iqubic> jle` How the heck does that work?
21:51:53 <pacak> Hmm... newtype Fix f = Fix (f (Fix f))
21:51:58 <jle`> iqubic: why wouldn't it work
21:52:00 <pacak> and Fix Tree  a
21:52:18 <iqubic> pacak: That looks a lot like the free monad.
21:52:19 <pacak> Recursion schemes all the way!
21:52:21 <glguy> Fix (Tree a)
21:52:37 <pacak> glguy: Right.
21:52:42 <pacak> iqubic: IT
21:52:43 <jle`> iqubic: you really want Tree a (Tree a (Tree a (Tree a ... forever ...))
21:52:49 <pacak> It's turtles all the way down.
21:52:53 <iqubic> Yeah, you do.
21:53:00 <iqubic> That's what you want.
21:53:09 <jle`> so, data TreeForever a = TreeForever (Tree a (TreeForever a))
21:53:16 <pacak> Easily achievable with Fix
21:53:26 <jle`> Fix is just TreeForever, parameterized by arbitrary constructor
21:53:28 <iqubic> Can't you use a free monad instead
21:53:38 <jle`> free monad is different
21:53:41 <johnw> the Free monad is just a specialization of Fix
21:53:42 <iqubic> It is?
21:53:47 <jle`> but do you see why TreeForever works ?
21:53:54 <iqubic> Yeah. I do>
21:53:59 <jle`> Fix is what happens when you parameterize TreeForever by Tree
21:54:05 <iqubic> Right, I see.
21:54:18 <iqubic> Fix is a generic form of TreeForever.
21:54:23 <jle`> TreeForever a = TreeForever (Tree a (TreeForever a))
21:54:52 <iqubic> How is the free monad different.
21:54:54 <nshepperd> newtype Fix f = Fix (f (Fix f))
21:55:02 <iqubic> What does newtype free look like?
21:55:14 <nshepperd> data Free f a = Pure a | Free (f (Free f a))
21:55:16 <jle`> Free has an extra constructor
21:55:32 <iqubic> Oh, right.
21:55:36 <jle`> that lets you terminate the recursion, so to speak
21:55:39 <nshepperd> Free has the option of terminating the recursion with a value
21:55:40 <iqubic> Yeah.
21:55:41 <jle`> it's like List, vs. Stream
21:55:49 <iqubic> Right. I got you.
21:55:54 <jle`> data Stream a = SCons a (Stream a)
21:56:00 <jle`> data List a = LCons a (List a) | Nil a
21:56:04 <jle`> er, | Nil
21:56:14 <jle`> list is like a stream you can terminate
21:57:00 <iqubic> Yeah, I get it.
22:04:57 <athan> Is there a common system of... concurrent continuations? Where I might `await` from multiple sources?
22:05:15 <athan> or some kind of indexed `await`, which could identify the data source or something? :s
22:05:31 <athan> muh programming paradigms
22:06:08 <systemfault> Something like await Promise.all([promise1, promise2, promiseN]); ?
22:06:54 <athan> something like that, yeah
22:07:16 <athan> or really, say I have some other thread going on, and it would like to `yeild` data `awaited` in my current one
22:07:19 <athan> is that just STM?
22:07:31 <athan> like a queue or something :s
22:08:04 <peddie> athan: can you use Control.Concurrent.Async.waitAny or waitAnySTM or something like that?
22:08:22 <athan> well the trick is the thread is already running
22:08:36 <athan> or the source thread's invocation is unknown
22:08:57 <athan> I think a queue or whichever might work :)
22:09:00 <athan> thanks everyone!
22:09:01 <systemfault> Oh damn, wow... Thought I was on the javascript channel for a second. My bad.
22:10:09 <mjora7> GHCi says that the type signature of a function is "(Ord t1, Num t1) => t1 -> [t] -> [t]", what does 't' (without the 1) refer to
22:10:22 <mjora7> And why is there a 1 to begin with
22:10:42 <glguy> t and t1 are just two different, unrelated variable names
22:12:01 <mjora7> Ok. Why didn't they use two different letters?
22:12:25 <glguy> Because it doesn't
22:13:36 <iqubic> I like lambdabot's way of just using a, b, c, ...
22:13:54 <iqubic> That's what I do in my type signatures all the time.
22:14:05 <mjora7> Yeah a, b, c make a lot more sense, unless there is a reason GHCi does it that I'm not seeing
22:14:21 <iqubic> mjora7: No. GHCi is just weird
22:15:20 <Sh4rPEYE> Hello. How do I update my stack snapshot? Also, on stackage the latest hlint version is 1.9, while on hackage it is already at 2.0. Is there any way to use the new one if I use stack for managing packages?
22:16:17 <Koterpillar> Sh4rPEYE: to answer the second question, put it in extra-deps: as, i.e. hlint-2.0
22:17:41 <Sh4rPEYE> Koterpillar: I don't have a stack project, though, because I only work with small scripts and individual files. I use stack mainly for package management, not project setup. How do I specify these extra deps globally?
22:18:29 <Koterpillar> then it's in .stack/global-project, I think
22:18:38 <Koterpillar> and that's the same place where you update the snapshot
22:18:39 <mjora7> iqubic: So "(Ord a, Num a) => a -> [b] -> [b]" is the more readable equivalent?
22:18:54 <moet> what does `withMVar` mean in "However, it is only atomic if there are no other producers for this MVar."?  ... if an mvar is held, then observers will block.. when the mvar is released, an observer will resume.. the operation will appear attomic to observers, right?
22:19:08 <Sh4rPEYE> Ok, I'll try to throw in the "resolver" and extra deps to stack.yaml in global-project
22:21:51 <cocreature> moet: withMVar can take the mvar but then another producer can put it back in
22:24:47 <moet> cocreature: ah.. thank you.. i was thinking of it purely as a lock, not as a container
22:25:11 <moet> if all users of the MVar use withMVar, then it should act pretty much like a lock, correct?
22:25:15 <cocreature> yep
22:28:54 <cocreature> moet: if you use an mvar as a lock you should consider wrapping it an a newtype and only exposing a withLock operation to prevent accidental use of putMVar, i.e., releasing a lock that you didn’t acquire. https://hackage.haskell.org/package/extra-1.5.2/docs/Control-Concurrent-Extra.html#t:Lock is just that if you’re fine with a dependency
22:38:03 <moet> cocreature: yeah, i might do that.. the mvar is hidden in my library atm, with an access function which saves me a bunch of extra typing so i always use it
22:38:45 <moet> the issue might actually be a crash, whose error is swallowed by the mvar checker.. i've had that issue before
22:40:28 <cocreature> mvar checker?
22:40:41 <cocreature> the deadlock detection?
23:17:33 <athan> Is there such a thing as a STM-backed map-queue? where `lookupTake :: k -> MapQueue k a -> STM a` blocks until a value is `insertPut :: a -> MapQueue k a -> STM ()`'d?
23:18:45 <athan> er... wait... I could probably just store the queue refs in a map. Duyyyyy sorry yall
23:20:50 <ExpHP> @tell SrPx proofs of "not A" in idris: http://lpaste.net/7530348284422914048
23:20:50 <lambdabot> Consider it noted.
23:21:53 <ExpHP> @tell SrPx by which I mean proofs INVOLVING "not A", not proofs OF "not A"
23:21:53 <lambdabot> Consider it noted.
23:22:13 <ExpHP> dang right lambdabot
23:23:49 <quchen> ExpHP: forall A. (A ∨ ¬ A) → (¬ ¬ A → A)  <-  This is maybe a simpler example
23:24:27 <quchen> Or A → ¬¬A even
23:28:06 <shauryab98> I was thinking of building something similar to Lichess ( https://github.com/ornicar/lila ) in haskell. Can someone please give me a general idea of how this could be done?
23:33:56 <quchen> shauryab98: Same way as in any other language. You need a server that takes in clients and manages messages between them.
23:35:52 <shauryab98> @quchen, how would I exchange information between the haskell game server and the front end?
23:35:52 <lambdabot> Unknown command, try @list
23:36:56 <shauryab98> how would I exchange information between the haskell game server and the front end?
23:37:42 <quchen> Websocket or standard server call. The crux is that both have to share the same data format to be able to talk to each other.
23:39:56 <shauryab98> Thanks.
23:39:59 <quchen> shauryab98: https://jaspervdj.be/websockets/
