00:01:00 <_sras_> cocreature: Thanks. let me try.
00:31:02 <ArchaicLord> thats interesting pebble becuase one of the plus of xmonad over i3 is that is ment to crash less
00:34:16 <peddie> ArchaicLord: I assume you're addressing me (sorry, my nick is neither a rock nor any other common word) . . . never tried i3, but I don't think I've ever had xmonad crash.  and whenever a new version comes out I can just upgrade in place without restarting anything :D
00:35:49 <ArchaicLord> cool.. Sorry I am kinnda new.. just finish uni, currently at home on Windows but have a linux virtual box instance. I have  ajob offer who are using Ubunut 14.04 so trying to play with it more. I can't see how in this Chrome client to tag people
00:49:50 <Unode> Is (fmap customfunction []) returning "" a violation of the Functor laws? i.e an empty "" is equivalent to [] but does it still qualify as the same type?
00:51:12 <jle`> Unode: fmap can change the type
00:51:34 <jle`> fmap customFunction [] should return an empty list of whatever type customFunction returns
00:52:10 <jle`> what the functor laws dictate is that fmap can't change the length of []
00:52:15 <jle`> *the length of the input list
00:52:22 <jle`> that's one of the free theorems :)
00:53:14 <Unode> jle`: hum I'm reading "Haskell programming from first principles" and the emphasis is on identity and composition. You now mentioned length which seems like a different "law".
00:53:34 <jle`> length being preserved is a consequence of identity and composition
00:53:52 <jle`> admittedly, it's a surprising consequence
00:54:35 <jle`> but starting from the functor laws, you can prove that fmap must preserve the length of the input list
00:54:40 <jle`> math is power ~
00:54:43 <Unode> :)
00:55:00 <Unode> ok, I'll keep reading with that in mind. Thanks!
00:55:04 <jle`> but yes, "" is just syntactic sugar for []
00:55:12 <jle`> if that was what your original question was (i'm not exactly sure)
00:55:21 <jle`> so returning "" is just returning [] :: String
00:55:29 <jle`> > fmap id ""
00:55:31 <lambdabot>  ""
00:55:35 <jle`> > fmap id [] :: String
00:55:37 <lambdabot>  ""
00:56:05 <jle`> the Show instance for lists implements `show ([] :: String)` as ""
00:56:25 <jle`> so even though it's printing "", be aware that the result is really just []
00:56:31 <jle`> > show ([] :: String)
00:56:33 <lambdabot>  "\"\""
00:56:47 <jle`> it's just a quirk of the Show instance for lists :)
00:58:14 <jle`> the Show instance for list is kind of crazy in general
01:01:46 <liste> :t showList
01:01:47 <lambdabot> Show a => [a] -> ShowS
01:02:11 <liste> > showList "123"
01:02:13 <lambdabot>  <[Char] -> [Char]>
01:02:45 <mjora7> Is there any point in using [Char] over String?
01:03:13 <jle`> do you mean, typing one over the other?
01:03:18 <mjora7> Yeah
01:03:43 <jle`> might as well ask if there's any point in typing String over [Char]
01:03:55 <jle`> the two are interchangeable
01:04:17 <mjora7> So they're exactly identical then?
01:04:21 <jle`> sometimes [Char] can be nice if you want to explicitly document that you are working over a list of things, which happen to be Char
01:04:31 <jle`> but it's not a big deal either way
01:04:35 <jle`> they are identical to Haskell
01:04:46 <liste> String is a synonym of [Char]
01:04:46 <jle`> it's more or less a lexical alias
01:04:52 <mjora7> Ok cool.
01:04:58 <liste> @src String
01:04:58 <lambdabot> type String = [Char]
01:04:59 <jle`> if you're familiar with C/Cpp, it's like #def String [Char]
01:05:09 <jle`> * #define
01:05:19 <mjora7> Right.
01:05:33 <mniip> typedef [char] string;
01:08:16 <mjora7> Well it would be `typedef char * String` in C++. But I get it, thanks for the example.
01:09:34 <mniip> * is not really synonymous with []
01:10:41 <mniip> typedef std::forward_list<char> string;
01:10:46 <mniip> not sure you can write that though
01:10:51 <mniip> because template parameters
01:11:14 <mjora7> Ok then it would be `typedef char String[]`?
01:11:39 <mniip> hmm
01:11:48 <liste> lists are not arrays
01:11:52 <mniip> not that either
01:12:02 <mfukar> There is no direct analogue.
01:12:15 <mniip> well, if we're talking about translating haskell lists into C
01:12:36 <mjora7> What is a difference between Haskell lists and C-style arrays?
01:12:38 <mniip> then it's more like a uniform interface over a singly linked list and a generator
01:13:05 <mniip> mjora7, haskell is lazy, it uses a different evaluation strategy
01:13:38 <mjora7> Right
01:13:54 <mjora7> Haskell is the coolest language I've ever encountered, only 2 days into learning it atm.
01:13:58 <mniip> if we disregard evaluation and question what lists look like
01:14:02 <liste> mjora7: lists don't support random access, just iteration and non-destructive prepend (ie. creating a new list with another element in front)
01:14:03 <mniip> then it's a singly linked list
01:14:14 <mniip> yeah
01:14:49 <mniip> the "fundamental" operations are head, tail, cons
01:15:03 <mniip> all done in O(1) time
01:15:22 <mjora7> Ok
01:15:26 <mjora7> Does Haskell have arrays?
01:15:29 <liste> mjora7: yes
01:15:32 <mniip> yes
01:15:36 <mniip> though there is a catch
01:16:08 <mniip> they are akin to an intrinsic
01:16:42 <mniip> they aren't exactly built into the language, so they have an implementation, yet that implementation is not very nice
01:16:49 <mjora7> Ok
01:18:02 <liste> and arrays are less useful than in other languages, because either they're immutable, or require working in IO/ST
01:18:17 <mjora7> What do you guys use Haskell for?
01:18:21 <mniip> ST is underrated
01:18:29 <mniip> it's not as bad as IO
01:20:57 <mniip> mjora7, as a general purpose language
01:21:34 <Iceland_jack> mjora7: As a tool to explore ideas (and (work (I (guess))))
01:23:47 <ArchaicLord> Thank you for the help /msg peddie [Finaly worked out how to tag people ] :D
01:25:41 <hsk3> I'm wondering emacs vs. vim. Now with inerto, I guess there's no contest is it?
01:25:44 <mjora7> Any example projects?
01:25:51 <hsk3> since inerto is emacs
01:26:23 <MarcelineVQ> hsk3: there's intero for nvim as well, possibly vim idk
01:27:09 <MarcelineVQ> tbh I've been using just ghcid lately and it's really nice, I don't miss the mouse-over-types from ghc-mod as much as I thought I would
01:27:10 <hsk3> is it maintained as much?
01:27:19 <hsk3> hmmok
01:28:20 <sophiag> someone suggested i use dante since i use nix instead of stack, but dante appears currently broken for nix :(
01:28:35 <sophiag> but yeah, he said intero was grea
01:29:28 <amosbird> hi, why am I getting this when trying to install yi editor https://paste.wentropy.com/7aXU
01:35:04 <cocreature> amosbird: because you haven’t installed alex
01:38:26 <merijn> Is there a way to get GHC/cabal to print a dependency/import graph of a project?
01:39:22 <cocreature> merijn: I use https://github.com/yav/graphmod for that
01:40:00 <bvad> merijn: seconding graphmod.. if you're using stack https://docs.haskellstack.org/en/stable/dependency_visualization/ 
01:41:42 <hvr> merijn: if you use cabal new-build, and you care about package deps, here's something that prints a text-tree dep: http://hackage.haskell.org/package/cabal-plan
01:42:01 <merijn> hvr: No, just module dependencies
01:42:24 <merijn> hvr: Basically, diving into a new codebase and trying to figure out which files I can start without dependencies ;)
01:42:41 <hvr> merijn: oh... for that I used http://hackage.haskell.org/package/SourceGraph long time ago
01:42:58 <hvr> merijn: not usre if that still works
01:43:14 <amosbird> cocreature: hm
01:43:24 <amosbird> why does it not install alex for me
01:43:55 <merijn> I'll try graphmod :)
01:44:00 <cocreature> amosbird: alex is a build-tool not a runtime/link dependency and cabal doesn’t install these
01:44:12 <hvr> cocreature: actually...
01:44:35 <hvr> cocreature: cabal new-build does auto-install alex/happy if it's declared a build-tool or build-tool-depends... and makes it available at build-time
01:44:40 <amosbird> ok
01:44:56 * merijn sighs
01:45:12 <merijn> hvr: Where can I find a write-up of new-build?
01:45:13 <cocreature> hvr: I know but "cabal new-build" is not usable in any released version of cabal so recommending that is not really useful
01:45:23 <merijn> blah
01:45:34 <merijn> graphmod crashes with "too many open files" with a mere 49 files >.>
01:45:44 <hvr> merijn: basic documentation is at http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
01:46:45 <ArchaicLord> The learning curve is so high I havn't used any of these while I been studyign but I really want to
01:46:46 <ArchaicLord> http://spacemacs.org
01:46:51 <hvr> (fwiw, the section http://cabal.readthedocs.io/en/latest/nix-local-build.html#unsupported-commands is not fully accurate; some of those commands already work)
01:47:17 <merijn> hvr: In released cabal-install or just the dev version?
01:47:26 <hsk3> ArchaicLord the learning curve of what? spacemacs?
01:47:44 <hvr> merijn: released cabal would be 1.24; that documentation however is supposed to be for cabal 2.1 :-)
01:48:01 <hvr> merijn: and yeah, cabal 1.24 lacks quite a bit of features regarding new-build
01:48:36 <merijn> *sigh* guess I'll clone chrisdone's graphmod repo to fix this
01:49:00 <uve> Hey guys
01:50:14 <merijn> Anyone know how I can jump from a Pull Request to the PRs origin repo on GitHub?
01:50:31 <hvr> merijn: some time ago I hacked up some tool I never polished, which would work by using -ddump-minimal deps to analyse inter-module deps
01:51:19 <hvr> (and given graphmod's existence I never bothered to)
01:52:17 <merijn> I'm just confused 49 files is exceeding the fd count, unless it's being stupid and repeatedly opening the same files
01:52:22 <hvr> the benefit was that it would look through TH & CPP
01:53:32 <merijn> I'm...not impressed with graphmod's speed...
01:54:04 <hvr> I guess you're experience "Haskell tooling still sucks" :-)
01:54:25 <merijn> hvr: Well, this seems more a matter of "braindead implementation"
01:54:31 <hvr> (re https://www.reddit.com/r/haskell/comments/66m06j/death_by_a_thousand_cuts/ )
01:55:01 <merijn> Because I would expect "rendering a DAG of 49 nodes" to take substantially less than several minutes of 90+% CPU utilisation
01:55:02 <hvr> merijn: I would have guessed lazy I/O usage causing fds to get used up
01:55:33 <merijn> hvr: Sure, but that still does not explain why it runs out of fds when inspecting only 49 files
01:55:50 <hvr> yeah, that doesn't sound good :)
01:55:58 <merijn> Open files is limited to 256 according to ulimit
01:57:04 <merijn> I'm passing it 49 haskell source files and it first runs out of fds, then with chrisdone's patch it works but takes actual minutes of 90+ CPU utilisation. Now, I'm not a performance wizard, but my instinct says that you have to be doing REALLY silly things to perform this bad..
01:57:44 <hvr> yeah... unless it's doing some weird NP-imcomplete computation on a 49-node graph... but I'd still be surprised
01:58:14 <hvr> does it terminate?
01:58:18 <merijn> hvr: But, if you blindly assume a lack of hs-boot files you don't even need NP stuff, ordering a DAG is pretty trivial
01:58:22 <merijn> hvr: Well, not yet...
01:58:31 <hvr> maybe there *is* a cycle?
01:58:38 <hvr> or graphmod *thinks* there is a cycle?
01:58:48 <hvr> (and doesn't detect it)
02:00:25 <merijn> hvr: I don't think so?
02:00:34 <merijn> I certainly don't see any boot files
02:00:50 <merijn> ok, I'm killing this, since it's actually affecting the responsiveness of my terminal
02:01:08 <merijn> Right, so any alternatives to graphmode? :p
02:01:51 <hvr> merijn: ...writing your own tool... :-) it's quite easy to parse out the module deps
02:02:00 <merijn> hvr: But I don't wanna :(
02:02:24 <merijn> hvr: This way lies infinite yak shaving, and I'm already like 50 yaks in...
02:02:45 <merijn> hvr: Incidentally, are you also a Hackage admin?
02:03:03 <hvr> more or less... :-)
02:03:39 <hvr> merijn: fwiw, you could easy get https://github.com/hvr/packunused/blob/master/packunused.hs to spit out the module->[module] edges
02:03:45 <merijn> hvr: I can't manage to reset my password. The reset link claims to send me a reset link, but it never arrives
02:03:57 <hvr> you're on gmail?
02:04:00 <merijn> Nope
02:04:14 <hvr> we had some similiar issue recently already
02:04:42 <merijn> I don't see anything in spam/whatever either, so I'm thinking something is borked in the email setup
02:05:01 <hvr> merijn: can you plz write an email to admin@haskell.org about it?
02:06:06 <hvr> merijn: when did you trigger the email reset?
02:06:18 <hvr> merijn: if it's not recent, can you try again now? so I can look at the logs
02:06:42 <merijn> hvr: Yesterday afternoon and again this morning
02:06:52 <merijn> So, like 1 or 2 hours ago tops
02:07:14 <hvr> merijn: ok, please write an email to admin@ I see the reason, but I want to keep the other admins in the loop
02:08:02 <hvr> johnw: ping?
02:08:18 <merijn> Just did :)
02:09:29 <hvr> thx
02:14:53 <hvr> merijn: somebody should get back to you
02:15:13 <hvr> I need to get ahold of our mail configuration gurus
02:15:31 <merijn> hvr: Sure :)
02:17:36 <merijn> oh, I think I mailed admin@haskell.org lemme update that to hackage.haskell.org :)
02:17:55 <merijn> hvr: Actually, do you know what sender address hackage uses?
02:19:36 <hvr> merijn: I know it didn't get accepted by our mail relay... 
02:19:50 <hvr> so you definitely didn't get it in your inbox/spam
02:20:33 <hvr> it *should* have from=<hackage@hackage.haskell.org> as sender
02:24:08 <merijn> hvr: If it's only gmail and some others I wonder if it's not something like wrongly/missing DKIM/SPF
02:27:38 <Aku> Can somebody help me convert one instance of a particular data type into other? I will post the code -->
02:27:45 <hvr> merijn: yeah, the SPF looks a bit incomplete; but I'd have to look at the mail.h.o logs to know if that's the real reason
02:28:28 <merijn> hvr: See -infrastructure response
02:31:51 <lpaste> Aku pasted “No title” at http://lpaste.net/4186157945983074304
02:32:55 <Aku> I want to convert Nfa Int to the earlier Dfsa st sy
02:33:15 <Aku> I don't understand how to do it!
02:33:23 <Aku> Can somebody look at the code
02:35:12 <Aku> Is anybody free and take a look at my code?
02:36:22 <Aku> I am using the Halex.Dfa library 
02:36:39 <Aku> But they haven't defined how the delta function should actually be
02:36:55 <pacak> Aku: Don't mix tabs with spaces...
02:37:24 <Aku> okay
02:37:43 <Aku> I just copied the code in ahurry
02:39:11 <Aku> pacak: Up there looking at it?
02:39:59 <pacak> Aku: Kind of. It's hard to suggest anything without knowing which library you are using
02:40:29 <Aku> Just a sec, I will post the full code and the name of library as well
02:40:45 <Aku> https://hackage.haskell.org/package/HaLeX-1.2.6/docs/Language-HaLex-Dfa.html
02:40:54 <Aku> Here is the link
02:40:55 <pacak> That probably won't help me  since I'm not familiar with that library.
02:41:18 <Aku> Can u just tell me what the delta function is?
02:41:50 <Aku> In the constructor of Dfa
02:42:06 <Aku>  Dfa [sy] [st] st [st] (st -> sy -> st)
02:42:11 <Aku> the last one
02:42:35 <pacak> Looks like something that takes state, next symbol and creates a new state
02:42:52 <Aku> Ya but then look at the code I posted earlier
02:43:22 <Aku> They have defined one machine named ex1
02:43:31 <Aku> And look at delta over there
02:43:53 <Aku> How can they have multiple deltas inside the where clause
02:44:35 <pacak> lines 11..14? IT's just one function
02:45:15 <pacak> Do you know about pattern matching?
02:45:19 <Aku> Ya that part can u explain a bit?
02:45:21 <pacak> Or how to write functions?
02:45:26 <Aku> yes I know
02:45:29 <Aku> yes
02:45:46 <pacak> So  those lines with delta - it's just one  function declared
02:45:58 <Aku> okay
02:47:16 <Aku> How do I convert my machine to that form
02:47:18 <Aku> ?
02:48:31 <Aku> pacak: ??
02:49:04 <pacak> I dunno. Are you taking a course about state machines? In that case they should have some explanations
02:49:50 <Aku> Actually I have completed the implementation
02:50:05 <Aku> I just want to visualize the automata
02:50:09 <Aku> using graphviz
02:50:26 <Aku> but they want the DFA to be defined as in the library
02:50:38 <Aku> And mine is a different version
02:50:46 <Aku> So just want to convert
02:51:21 <pacak> Try reading documentation and figuring out convert it
02:51:32 <pacak> Ability to read documentation is useful.
02:51:40 <Aku> The documentation is not complete
02:51:50 <Aku> They just give the type definition
02:52:00 <pacak> Read the source code and theory behind NFA and DFA
02:52:07 <Aku> okay
02:52:21 <pacak> If you have any specific questions - feel free to ask
02:52:55 <pacak> How do I convert - answer to this question won't help your understanding.
02:56:04 <Aku> okay
04:14:59 <Sh4rPEYE> Hey. I've an article that praises lazy dynamic programming in Haskell and advises to use Data.Array for it. I wanted to ask if that's the best way and also if LDP is generally a good way to build algorithms in Haskell (meaning: if I have some alternatives, similarly effective, should I use LDP)
04:15:10 <Sh4rPEYE> The article in question: http://jelv.is/blog/Lazy-Dynamic-Programming/
04:19:05 <merijn> Sh4rPEYE: Lazy Dynamic Programming boils down to "memoised dynamic programming, without having to implement complex memoisation" :)
04:21:39 <Sh4rPEYE> merijn: Fair enough, that sounds good. What about the arrays? Is there a better way?
04:22:14 <merijn> Sh4rPEYE: Lazy Map would work just as well
04:33:24 <OnkelTem> Hi all
04:33:44 <OnkelTem> How to run executables from ~/.stack/programs/x86_64-linux/ghc-8.0.2/bin using stack?
04:34:17 <OnkelTem> For example PHPStorm needs ghc-pkg for intergration
04:36:16 <quchen> OnkelTem: Instead of running »prog«, use »stack exec prog«. This adds the appropriate directories to your $PATH.
04:36:38 <quchen> And then, »stack exec phpstorm« will have access to »ghc-pkg«.
04:36:47 <OnkelTem> ahh
04:37:12 <quchen> The reason for this is that you can tell »stack exec« which LTS to use (i.e. which compiler and ecosystem).
04:37:34 <quchen> So if you want to switch compilers, just say »stack exec phpstorm --resolver lts-7« and you’ll get a LTS-7 environment.
04:37:42 <OnkelTem> I see. Smart. But in my case it's not a solution, since I'm running stack inside a docker container
04:37:51 <OnkelTem> yes, I understand
04:38:11 <quchen> I don’t know anything about Docker I’m afraid.
04:40:13 <cocreature> OnkelTem: how does docker cause problems here?
04:42:01 <OnkelTem> cocreature: PHPStorm is running on the host, while stack and project - in a container
04:42:14 <OnkelTem> so I can't run host program inside a container :)
04:43:39 <cocreature> OnkelTem: ah ok, that sounds like it’s unrelated to stack
04:47:04 <bvad> OnkelTem: If I understand correctly, you need to mount a docker host folder inside you container (e.g. .stack), otherwise PHPStorm will not be able to see the files in it 
04:54:01 <Sh4rPEYE_> WHat does this piece of code mean: data Val e = Val Int
04:55:28 <ggVGc> Sh4rPEYE_: It declares a type Val with one type constructor taking an Int. The 'e' is a phantom type variable
04:55:42 <ggVGc> e.g a type variable that isn't used in any constructor, but is still part of the type
04:56:03 <ggVGc> Sh4rPEYE_: https://wiki.haskell.org/Phantom_type
04:57:58 <Sh4rPEYE_> ggVGc: Thanks
04:59:48 <Sh4rPEYE_> ggVGc: So, I can define a function
04:59:57 <Sh4rPEYE_> f :: Val String -> Int 
05:00:11 <Sh4rPEYE_> f (Val i) = i + 1 ?
05:00:40 <Sh4rPEYE_> Which takes only Val String types, but returns their value of Integer?
05:01:43 <AfC> yes
05:02:06 <Sh4rPEYE_> So it'd be only used to somehow give another attribute to the value
05:03:15 <AfC> The String in `Val String` there is being used as a marker to differentiate that type from say `Val WashingMachine` but at term level the code is identical. It's got nothing to do with String or WashingMachine or any other e
05:04:19 <AfC> The only time I've seen Phantom Types used was in the ZeroMQ library, where the author used one to ensure you didn't mistakingly pass one open connection to another unrelated one.
05:04:35 <AfC> I'm sure there are better reasons, but that's the first time I encountered it.
05:24:42 <quchen> AfC: Pointers in the FFI are phantom in what they contain
05:24:58 <quchen> It’s basically all »void* with a phantom«
05:25:06 <quchen> :t castPtr
05:25:07 <lambdabot> error: Variable not in scope: castPtr
05:25:13 <AfC> foiled again
05:25:14 <quchen> : Ptr a -> Ptr b
05:26:05 <quchen> ?hoogle castPtr
05:26:06 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
05:26:06 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
05:26:06 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
05:26:07 <quchen> Hah!
05:29:13 <tabaqui> I want to make and remove function dynamically in run-time
05:29:27 <tabaqui> based on some config file that can changed in the future
05:29:42 <tabaqui> from which point can I start?
05:30:45 <AfC> You don't have to make or remove anything. You've got a set of possible actions, and some of them will be available [enabled] at any given time. Probably a Map of actions to enabled y/n would do,
05:31:02 <AfC> i.e. Map Action Enabled where type Enabled = Bool
05:32:19 <AfC> then lookup in the map and/or change the value in the map depending on runtime config [changes]
05:41:39 <AfC> Meanwhile. I have a function that goes from [[a]] -> Matrix a 
05:41:44 <OnkelTem> bvad: that's true, I mount it
05:42:05 <AfC> Nothing wild about that. I'm trying to turn it into a typeclass method, though,
05:42:25 <AfC> class Calculator a where
05:42:25 <AfC>     create :: Num b => [[b]] -> a
05:43:13 <AfC> which seemed reasonable enough, but when I try to define an instance for it I get b not same as a errors. 
05:43:45 <AfC> I sorta want create :: Num b => [[b]] -> (a b)   but that's not valid, is it?
05:45:58 <tabaqui> AfC: I have no set of predefined actions
05:46:27 <tabaqui> I can predict some of them, but I don't want to lose uptime if some client will use specific action
05:47:51 <tabaqui> if I should use Lisp, I don't ask, but maybe haskell have some powerful metaprogramming
05:52:52 <Rembane> AfC: Shouldn't create be (Num a, Num b) => [[b]] -> Matrix a ?
05:59:25 <AfC> Rembane: aaaaaaah
06:00:16 <AfC> Rembane: (that's useful, but as a typeclass, what's the type of method create?
06:02:14 <Rembane> AfC: I see. So the typeclass should be for types that can take two dimensional lists and turn them into themselves?
06:03:23 <AfC> yeah
06:03:52 <AfC> I'm working on a benchmark to add to the haskell-perf suite comparing [pure] matrix with [native binding] hmatrix
06:04:49 <AfC> and I needed something that abstracts over different matrix algebra operations as supplied by the different libraries. Easy peasy, but for the create case. Maybe it just shouldn't be in the typeclass. I can live with that, I guess
06:06:40 <Rembane> AfC: You could also remove the (Num b) constraint.
06:12:51 <_sras_> Using digestive functors, Is there any way to incluide validation procedures sequently to a Form, instead of defining all validations from a single place. Foe example, if I have a form to validate email address, an initial validation may validate the address using regex, and further down the line, there might be validation for domain name, which runs in IO. How can I run both of these validation one after another, and collect the err
06:14:54 <Rembane> :t sequence
06:14:56 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
06:14:59 <Rembane> :t sequenceA
06:15:01 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
06:15:54 <Rembane> _sras_: What about this: (sequenceA . map (\f -> f emailfield)) [test1, test1]
06:17:05 <Rembane> _sras_: Or use traverse instead of sequenceA . map
06:18:53 <merijn> Well...this will be fun...fixing APIs across 2 different upstream packages >.>
06:28:33 <quchen> merijn: …and one of them is Base? :-þ
06:29:28 <merijn> quchen: I wish, at least getting fixes into base is fairly straightforward (albeit slow)
06:30:00 <quchen> merijn: Seeing how I can’t contact the wl-pprint maintainer for half a year now I can feel you
06:30:26 <quchen> Been thinking about just releasing yet another new package. Meeeh
06:30:37 <merijn> quchen: These dependencies seem to be by people who are no longer active here and one by bos who is overworked anyway :)
06:30:40 <quchen> Problem is it works really well for myself already, so there is no real pressure ;-)
06:30:44 <_sras_> Rembane:  Is this for Digestive functors?
06:30:58 <merijn> quchen: Did you attempt to get yourself added as maintainer via hackage admins?
06:31:09 <merijn> quchen: If the current maintainer isn't responsive you could just take it over
06:31:33 <quchen> Yes, I could do that, but then I’d be alone with all breakages and I’m not sure whether I can handle that right now
06:31:36 <merijn> This actually makes this my 2nd project blocked on bos being too busy :p
06:32:23 <quchen> I don’t expect breakages, but still – it’s got lots of revdeps and politics in it
06:32:54 <quchen> merijn: On the plus side, I can keep worrying about whether I want annotations or not in the Doc type :-)
06:33:03 <merijn> Dooooo it....Doooooo it :p
06:33:19 <merijn> Bump the version and burn it all :p
06:33:41 <quchen> Hah yeah it’s a major version bump for sure. Mainly for marketing reasons.
06:33:49 <Rembane> _sras_: Yes, or rather everything that are Applicative.
06:36:47 <merijn> quchen: I wanna revive opaleye-sqlite, but that means fixing opaleye, which means getting sqlite-simple more in sync with postgresql-simple, which means fixing the API of direct-sqlite...so...fun times :p
06:37:05 <quchen> Opaleye is by umm
06:37:08 <quchen> Tony Morris?
06:37:23 <quchen> I remember meeting him, nice guy, but I can’t remember the name
06:37:44 <merijn> quchen: Well, by fixing opaleye I mean fixing opaleye-sqlite. Opaleye is working fine, but only supporting Postgres, the SQLite stuff is bitrotted (not too badly, it seems)
06:37:51 <cocreature> opaleye is by tomjaguarpaw
06:38:03 <merijn> Yeah, I already talked to him :)
06:39:17 <kosmikus> quchen: Tom Ellis
06:39:26 <quchen> kosmikus: Ah, thanks
06:53:31 <LHoT10820> Is there any way to get unfiltered keyboard input? Just the raw matrix location of a key that is depressed?
06:55:12 <merijn> Is there a way? Sure. But whether there's a portable library that does that? No idea
06:59:46 <maerwald> depressed keys? :P couldn't resist
07:00:06 <LHoT10820> merijn: No need to be portable. I should have mentioned that it's for a utility that doesn't exist in what I feel is a sufficient capacity for Windows.
07:00:38 <merijn> LHoT10820: In the terminal on unix you can probably get by using vty
07:01:04 <merijn> LHoT10820: If you need something more general than that...that's a matter of figuring out how people are doing it in other languages and copying that approach
07:01:31 <earthy> LHoT10820: there is the Win32 package
07:03:17 <merijn> hvr: Is there a way to trigger your MatrixBuilder thing by hand for a package? What are the restrictions on what it can test?
07:03:27 <LHoT10820> earthy: Thanks, I'll check it out. | merijn: I figured that I may end up doing something like that. Hopefully earthy's suggestion works for me.
07:04:16 <merijn> LHoT10820: FWIW, Haskell's FFI is pretty simple and straightforward, so porting whatever works in other languages to Haskell is generally fairly straightforward
07:04:47 <magneticduck> @dijnn (\(a, b) -> case b of Nothing -> Nothing; (Just b) -> Just (a, b))
07:04:47 <lambdabot> Cannot parse command
07:05:03 <magneticduck> @pl (\(a, b) -> case b of Nothing -> Nothing; (Just b) -> Just (a, b))
07:05:03 <lambdabot> (line 1, column 33):
07:05:03 <lambdabot> unexpected '>'
07:05:03 <lambdabot> expecting operator
07:05:17 <magneticduck> why does @pl not accept this, and what is this function?
07:05:25 <quchen> magneticduck: Djinn is type -> value
07:05:30 <quchen> value -> type is :t :-)
07:05:36 <magneticduck> yes I messed up fir the first time
07:05:43 <magneticduck> I'm trying to write this point-free
07:06:02 <quchen> I don’t think Djinn knows about fst/snd
07:06:28 <LHoT10820> merijn: Great, I'll keep that in mind.
07:06:30 <magneticduck> @pl (\(a, b) -> a)
07:06:31 <lambdabot> fst
07:06:41 <quchen> Oh.
07:06:43 <magneticduck> but in any case, the problem is that pl simply isn't parsing this valid code
07:06:44 <quchen> Nevermind.
07:07:31 <quchen> `case` can’t be made pointfree I guess
07:07:41 <ahihi> @pl \(a, b) -> fmap (a:) b
07:07:41 <lambdabot> uncurry (fmap . (:))
07:07:48 <ahihi> err
07:07:50 <quchen> ?pl would have to Böhm-Beraducci your constructors for that
07:07:51 <lambdabot> (line 1, column 17):
07:07:51 <lambdabot> unexpected '\182'
07:07:51 <lambdabot> expecting variable, "(", operator or end of input
07:07:53 <ahihi> @pl \(a, b) -> fmap (a,) b
07:07:53 <lambdabot> (line 1, column 19):
07:07:54 <lambdabot> unexpected ","
07:07:54 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
07:08:10 <ahihi> no tuple sections :(
07:13:46 <ski> @type uncurry (fmap . (,))
07:13:47 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
07:14:20 <ski> sometimes known as `strength', iirc
07:16:02 <magneticduck> neat
07:28:26 <merijn> mmmm, I need a combination of foldMap and forM_, but I don't think that exists, right?
07:29:01 <merijn> Basically, I want "fmap sum (forM list fun)", but without the cost of building an intermediate list for no reason
07:29:38 <glguy> foldM?
07:30:19 <merijn> hmmm, maybe
07:30:33 <glguy> :t foldlM
07:30:35 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
07:30:55 <merijn> bleh
07:31:05 <merijn> foldM isn't strict though. ALthough I guess I can fix that
07:31:41 <glguy> as long as you're using a strict>>= Monad instance that's fine
07:31:56 <merijn> Wait, I can't even make it strict, since it uses foldr internally
07:32:30 <merijn> glguy: No, because then instead of building up a list upfront I simply end up building a large thunk up front, same problem
07:32:34 <glguy> no, that doesn't follow
07:32:36 <ski> is `foldlM' an alias for `foldM' ?
07:32:54 <makalu> I assume there's a library for this: how to turn a URI query (eg "?foo=bar&baz=quux") into a key-value pairs
07:33:01 <glguy> foldr can implement foldl' just fine
07:33:50 <c_wraith> it can, but only if you get to control exactly what's passed to it
07:34:26 <merijn> hmmm
07:34:32 <merijn> Yeah, foldM seems to use foldlM
07:34:45 <glguy> and in this case as long as you have a strict >>= , it's fine
07:34:50 * ski can't recall seeing `foldlM' before, only `foldM'
07:35:15 <glguy> foldlM is from Foldable, foldM was Control Monad
07:35:33 <ski> ok
07:35:48 <lyxia> makalu: https://hackage.haskell.org/package/http-types-0.9.1/docs/Network-HTTP-Types.html#v:parseQuery
07:36:07 <makalu> lyxia: thank you!
07:36:21 <lyxia> you're welcome!
07:44:02 <shlevy> Is there any way to tell GHC to use an equality constraint in kindchecking? http://sprunge.us/YZMj <- this fails because x is a Type but it's expected to be an AssociatedKind (k1 -> k2), but I have a constraint marking those equal...
07:55:58 <lyxia> shlevy: http://lpaste.net/354800 it's not quite what you asked but would that work for you
07:58:03 <shlevy> lyxia: Ah, maybe, let me try to adopt it to my actual use case
07:58:17 <shlevy> lyxia: Not a huge fan of functional dependencies, but ah well :)
07:58:20 <shlevy> lyxia: thanks!
08:01:30 <lyxia> I didn't manage to make it work otherwise, I'm not sure whether that would be a bug in kind-checking.
08:02:59 <shlevy> lyxia: Hmm, but with this there's no way have the dependent type variable be derived from some other type class instance lookup, right? I mean you can in an instance, but not in the class definition
08:03:58 <shlevy> Well, I guess I can put an equality constraint on the class definition...
08:10:19 <lyxia> what dependent type variable
08:11:31 <shlevy> lyxia: Never mind, I think I got it
08:11:46 <shlevy> lyxia: (sorry, X/Y problem)
08:15:53 <shlevy> lyxia: Got something typechecking that I *think* is what I want :D
08:16:15 <shlevy> lyxia: http://sprunge.us/aAXX
08:17:06 <_sras_> is there a way to replace a form, with a form of same type,  at a certain path in a nested form
08:19:20 <lyxia> shlevy: do you really want an associated type family, rather than a simple type family
08:19:35 <shlevy> lyxia: Possibly not :D
08:19:44 <shlevy> lyxia: But I need to recurse
08:21:42 <lyxia> you can define type family instances recursively
08:23:57 <shlevy> lyxia: Can I do functional dependnecies on multi-parmaeter type families?
08:24:09 <lyxia> type family Saturated (t :: k) (u :: k') :: * where { Saturated t '() = t ; Saturated t '(a, b) = Saturated (t a) b }
08:24:19 <shlevy> lyxia: I'm trying to express a relationship between a kind and an instance of that kind
08:25:05 <lyxia> Unfortunately not
08:25:18 <shlevy> I guess if it's closed I get it for free
08:25:25 <shlevy> If I write it correctly :D
08:27:34 <lyxia> I'm not really exploiting the closedness of that family though
08:29:51 <shlevy> lyxia: http://lpaste.net/354803 <- this is failing (with or without the tick for the argument to Saturated Type), I guess because 'argKind' can't vary?
08:30:15 <_sras_> is there a way to replace a form, with a form of same type,  at a certain path in a nested form?
08:30:36 <shlevy> Oh, wait
08:30:48 <shlevy> I think I want to add a arg :: argKind...
08:32:36 <lyxia> _sras_: what form are you talking about
08:33:29 <_sras_> lyxia: Oh. Missed to mention it. Forms in Digestive Functors package.
08:35:33 <byorgey> _sras_: I doubt it.
08:38:49 <jchia_> Is there a package like binary-conduit for but Data.Store instead of Data.Binary?
08:40:19 <mudri> What's a good way of repeating an IO action (that may take a few seconds) every ~30 seconds, roughly?
08:41:29 <Rembane> mudri: Interleave it with threadDelay. How important is every 30 seconds?
08:41:43 <Rembane> mudri: Or rather, how important is interval?
08:41:59 <Rembane> mudri: Can it be for instance 29 or 31 seconds?
08:42:18 <mudri> Rembane: yeah, not too important. A few seconds either way is fine.
08:43:12 <Rembane> mudri: Take a look at these: https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Concurrent.html#g:6
08:43:16 <mudri> I'd mildly prefer it not to be biased one way or the other.
08:43:25 <mudri> Thanks!
08:43:42 <Rembane> mudri: No worries, good luck!
08:43:44 <phale> is <- just variable assignment? currently reading Learn You A Haskell for Great Good
08:43:49 <phale> so I got a bit confused seeing that operator
08:44:43 <lyxia> no, it's syntactic sugar for using the >>= operator
08:45:02 <phale> hmm what does >>= do then ?
08:45:20 <frontendloader> draws the rest of the owl
08:45:34 <mudri> phale: yes, it is a form of variable assignment. The book should really explain it.
08:46:08 <Rembane> phale: It gives an effect a name so you can work with that effect easier.
08:46:30 <Rembane> phale: It's a bit like binding demons.
08:46:44 <phale> oh i see now
08:46:52 <phale> i'm coming from C btw so this is new to me
08:47:05 <glguy> What >>= depends on the type of things you're using it with. If you're using it with 'IO a' things, then m >>= f  executes the action 'm', and then if that suceeds it applies f to the result of executing 'm' and executes that new action
08:47:20 <lyxia> oh I see, lyah introduces do before >>= ...
08:47:55 <sproingie> IO is also not necessarily the best intro to monads
08:48:29 <mudri> Monads is also not necessarily the best intro to IO. ;-)
08:49:01 <glguy> phale: Where are you seeing <-? It also comes up in list comprehensions
08:49:12 <sproingie> true.  but IO is just weird even then.
08:49:32 <phale> Yeah glguy , its in list comprehensions which is where im at now
08:49:50 <Rembane> > [x*2 | x <- [1..]]
08:49:52 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
08:50:33 <phale> also what is the idiomatic to name variables ?
08:50:36 <phale> camelCase ?
08:50:55 <byorgey> phale: oh, heh, you should ignore what everyone said about >>= and effects for now =)
08:51:07 <byorgey> phale: yes, idiomatic Haskell style is to use camelCase
08:51:12 <Rembane> phale: Camelcase, and as few letters as possible. :D 
08:51:32 <phale> alright :)
08:51:33 <sproingie> camelCase.  CamelCase would be for types.
08:51:56 <byorgey> phale: <- is not variable assignment, in a list comprehension  x <- zs  means that x will loop through all the elements of the list zs
08:51:59 <sproingie> types and type constructors have to start with uppercase, other identifiers with lowercase
08:52:14 <phale> oh i see byorgey , it wasnt really explained there so i got confused
08:52:37 <phale> and my last question is if there is something similar to structs in haskell ? 
08:52:47 <DemiMarie> I am writing Haskell bindings to a C IPC library, and I am trying to figure out how to deal with async exceptions in the presense of blocking calls
08:53:25 <sproingie> phale: yes, those are "product types", or if they have named fields, "records"
08:53:28 <DemiMarie> my understanding is that you can’t have async exceptions blocked during blocking FFI calls, but in my case the blocking call allocates a resources that must later be freed
08:54:19 <phale> sproingie: i see, so there can be a product type array that you can loop over to make your program data-driven i.e depending on data rather than program logic ?
08:54:52 <sproingie> sure, that's basically how i write everything
08:55:17 <sproingie> "product type" is the really general name, not every product is necessarily used as a struct tho
08:55:34 <mudri> Looping over fields of a struct?
08:56:25 <sproingie> not looping over fields, no, i'll leave that for libraries to do.  looping over lists.
08:56:31 <phale> oh great, i usually write these struct arrays in c that have other fields along with a function pointer and it does if checks and then executes that function
08:57:18 <sproingie> haskell does have random-access arrays when you need 'em, but the usual thing you reach for should be a list
08:57:47 <sproingie> which are linked lists and thus O(n) access but they also take full advantage of laziness
09:00:16 <phale> yeah i see now
09:00:20 <phale> there are also hash tables too ?
09:08:12 <sproingie> there's hashtables too, basically all the data structures you've heard of and then some
09:10:09 <sproingie> oh he left
09:27:14 <_sras_> I cannot get the :type-at command in ghci to work. It keeps saying "Couldn't guess that module name. Does it exist?"
09:38:53 <_sras_> I cannot get the ":type-at" command in ghci to work. It keeps saying "Couldn't guess that module name. Does it exist?". 
09:39:03 <_sras_> What am I doing wrong?
09:39:40 <_sras_> This is what I have been trying ":type-at Common.Types 134 6 134 7 c1"
09:44:25 <DemiMarie> What is the best way to handle a finalizer that might block for a long time on filesystem operations?
09:44:50 <MarcelineVQ> _sras_: you need to :set +c then load the module
09:46:08 <_sras_> MarcelineVQ: I have that set.
09:46:57 <MarcelineVQ> And the modules were loaded after it was set?
09:48:22 <MarcelineVQ> :r after :set +c should work if not. Is that the whole error you get btw?
09:49:44 <_sras_> MarcelineVQ: http://lpaste.net/5794885041016274944
09:52:11 <MarcelineVQ> Ah alright that's a different error, at least it's working now, just gotta figure out the right way to use it
09:53:40 <MarcelineVQ> idk how it's used exactly beyond what the docs say
09:53:44 <_sras_> MarcelineVQ: It is not working.
09:54:29 <_sras_> MarcelineVQ:  It just prints out the type of the last expression. Not the type at the location in the source file.
09:55:42 <MarcelineVQ> That suggests to me that your span is wrong, "The last string parameter is useful for when the span is out of date, i.e. the file changed and the code has moved. In which case :type-at falls back to a general :type like lookup." Not that I know for sure
09:58:42 <fizbin> Is anyone aware of any guides or blog posts on the topic of writing Haskell for other people to code review?
09:59:25 <fizbin> I mean, other than "if you feel mentally tickled by a particularly clever way of phrasing some piece of code, maybe don't do that to your reviewers"
09:59:48 <fizbin> which is advice that applies in any language but that I have to repeatedly remind myself of in Haskell.
10:23:20 <shapr> fizbin: wouldn't that depend on your peers?
10:23:49 <shapr> fizbin: for example, newbies get lost with <$> but most Haskellers nearly require understanding of Applicative
10:23:54 <camm> Hello guys. Does anyone know how etags work for static-files in Yesod? Does anyone know if there is a way to disable them so the server requests without adding the etag query parameter?
10:23:57 <shapr> and lens, and other things
10:25:34 <fizbin> shapr: Well, there's <$> uses and there's <$> uses.
10:26:11 <fizbin> I mean, <$> when the Applicative in question is Maybe? No problem.
10:26:15 <EvanR> known knowns and known knowns
10:26:33 <shapr> fizbin: my shortcut is to look at glguy's code and assume everything there should be readable to me and the Haskellers who work with me.
10:26:38 <EvanR> fmap really feels the same regardless of the particular functor
10:26:46 <EvanR> monad not so much
10:26:54 <fizbin> When you just casually throw out <$> over the Applicative (->) though...
10:27:23 <EvanR> functor (->) is pretty obviuos
10:27:32 <glguy> Yikes, I'll have to be more careful what I throw up on github!
10:27:33 <EvanR> <$>  is about functors
10:27:36 <shapr> fizbin: sounds like you should write up what you think in a github repo, and ask for PRs
10:28:27 <shapr> I've seen some discussion in stylish' PRs and comments
10:29:10 <fizbin> I mean, I guess this is pretty obvious as to what it means, but I could see needing to stop and figure out how this worked the first time you saw it:  filter ((||) <$> (`S.member` s1) <*> (`S.member` s2))
10:30:00 <Gurkenglas> filter (`S.member` S.union s1 s2)
10:30:44 <fizbin> Indeed, I was going to follow this with "arguably, that should be written with a call to S.union instead of using the Applicative instance on (->)"
10:33:00 <EvanR> function <*> is the s combinator, and indeed i have avoided using it to demonstration implementations of simple things
10:33:14 <EvanR> since it seems overly clever or cutesy
10:33:48 <fizbin> Well, but the idiom f <$> arg1 <*> arg2 <*> arg3 ... is well established.
10:34:02 <fizbin> <*> in isolation is pretty obscure.
10:34:09 <EvanR> what <*> means isnt clear in general, it depends on the type
10:34:29 <EvanR> i was saying <$> is pretty obvious in general because of functors laws
10:34:35 <fizbin> In that idiom though, it's just liftA2 (liftA3, liftA4, etc)
10:34:57 <EvanR> you were trying to discourage <$> because of the Applicative
10:35:33 <EvanR> i say fmap kind of cant be misundertood
10:36:16 <EvanR> liftAwhatever is indeed a big time idiom
10:36:25 <shapr> fizbin: sounds like this document needs a bunch of broad stroke summaries with specific examples for support
10:36:29 <fizbin> Maybe, but using fmap for (->) is kind of weird because that's just composition, and why wouldn't you use composition?
10:36:40 <EvanR> you wouldnt
10:36:43 <shapr> fizbin: see, that's a good specific example
10:36:51 <EvanR> unless it was a library that is going generic over any Applicative
10:37:12 <EvanR> similar to "give me any Monoid"
10:37:21 <fizbin> Sure.
10:40:23 <fizbin> So, part of this is "be wary of using typeclass functions when you are dealing with concrete types where their implementations of the typeclass functions are well-known. E.g., don't use (<$>) over functions when you can use (.) "
10:41:08 <nshepper1> (.) is a typeclass function too
10:41:48 <fizbin> nshepper1: Prelude.. isn't.
10:43:04 <fizbin> At least, not yet. I'm sure there's some future version of GHC where they'll make (.) from Control.Arrow the one that Prelude gives you and rename what is currently (.) to something else.
10:44:11 <fizbin> Sorry, from Control.Category.
10:45:07 <lyxia> There's a lot of inertia to keep the current (.) because of type inference
10:46:10 <lyxia> and why not (.) = (<$>)
10:46:17 * ski . o O ( `(.) = fmap' )
10:46:36 <lyxia> :)
10:47:00 <nshepper1> Well, that would be silly because we already have <$>
10:47:03 <EvanR> everything is anything
10:47:11 <nshepper1> We don't need two
10:47:13 * ski . o O ( `flip :: Functor f => f (a -> b) -> (a -> f b)' )
10:47:47 <EvanR> map = fmap
10:48:24 <nshepper1> I think whether to <$> or . depends on context.
10:48:53 <nshepper1> There are times when you are treating a thing in a functory way
10:49:51 <nshepper1> And times when you are using things in a categoryish way. (And other times when you should just use a lambda)
11:11:38 <fizbin> ski: I don't think you can in fact generalize flip in that fashion.
11:11:59 <fizbin> I think you need at least an Applicative restriction, not merely a Functor restriction.
11:12:20 <ski> > let f `flip` a = fmap ($ a) f in flip (,) 0 1
11:12:22 <lambdabot>  (1,0)
11:12:27 <ski> works fine here
11:12:55 <fizbin> Hrm. Okay.
11:13:22 <ski> (this is related to `uncurry (fmap . (,))')
11:14:53 <fizbin> Huh. I'd written that function as (\(a, b) -> (a,) <$> b)
11:15:51 <ski> it came up around four hours ago
11:15:52 <xintron> Any input on a good haskell+neovim setup? Currently looking at the haskell-vim, neco-ghc and ghcmod-vim plugins.
11:16:40 <fizbin> Then again, I generally find pointfree style a fun puzzle to play with but not actually that useful. (Increasing laziness is almost never something I want to do)
11:17:03 <c_wraith> what does pointfree have to do with laziness? 
11:18:49 <monochrom> Perhaps it came from a statistical survey. "Correlation between pointfree and laziness is 0.7" or something.
11:19:25 <monochrom> The same way correlation is high between cellphone signal towers and baby birth rates.
11:20:10 <monochrom> True high correlation but the reason is not what you're thinking. :)
11:20:22 <fizbin> I think I've seen "can increase laziness" listed as an advantage of pointfree style. Can't remember where though, so there is the possibility that I imagined it.
11:20:54 <monochrom> Oh the Internet is so large with so many people I'm sure 1 out of 4 billion people must have written it.
11:21:07 <monochrom> Doesn't mean it's right.
11:21:11 <glguy> I heard fizbin claim it just today
11:21:31 <monochrom> 90% of Internet rumours are wrong. OK I made 90% up.
11:21:49 <EvanR> positively true, unconstructively true, statistically true
11:22:04 <c_wraith> hmm. we shouldn't talk about increasing laziness or strictness. we should talk about increasing productivity. 
11:22:33 <c_wraith> that makes it more obvious that the ideal isn't either direction 
11:23:07 <fizbin> In general, sure. Sometimes though your code is going to be run at such massive scale that it's actually worth a programmer-side productivity hit for faster running code.
11:23:25 <fizbin> So to the extent that strictness or laziness affects performance...
11:23:28 <c_wraith> (I've dealt with just as much bad code that was too strict as I have bad code that was too lazy) 
11:23:30 <EvanR> that mentality is ridiculous
11:23:39 <c_wraith> I don't mean programmer productivity. 
11:23:48 <monochrom> Learn laziness for real.
11:24:01 <c_wraith> I mean in terms of calculation productivity. 
11:24:35 <fizbin> Right, okay. I'm more familiar with the word "performance" for that measure.
11:24:46 <monochrom> Instead of merely statistically true correlations such as "70% of high strictness code contains the capital letter S more than average".
11:24:47 <c_wraith> that's a different measure. 
11:24:59 <EvanR> i do not want the ghost of "webscale" to influence day to day productivity gains, it seems like a bigger issue is future comprehensibility and "maintainability" (modifiability)
11:25:18 <c_wraith> I mean productivity. does it do the right amount of work for each constructor produced? 
11:25:29 <c_wraith> that's not the same as performance. 
11:25:44 <monochrom> Also, today's xkcd.com
11:26:54 <EvanR> thats why i dont do inspirational speeches
11:27:02 <EvanR> im pretty sure no one can be as successful as me
11:27:11 <monochrom> heh
11:27:21 <fizbin> c_wraith: That seems like adjusting the amount of strictness or laziness to the right balance.
11:28:03 <fizbin> And in order to do that adjustment, it would be helpful to know "these techniques can be used to increase laziness" and "these techniques can be used to increase strictness".
11:28:26 <monochrom> Yes, the capital letter S can be used to increase strictness.
11:28:36 <EvanR> i know how to increase strictness, what are ways to increase laziness
11:28:36 <monochrom> Statistically true.
11:28:47 <monochrom> Fewer S's and more L's.
11:29:03 <EvanR> ByteString.Lazy
11:29:08 <c_wraith> fizbin, yep. which is why you shouldn't ever say that the goal is either one of those. 
11:29:08 <monochrom> Yes, like that.
11:29:45 <monochrom> I guess lowercase q is also correlated to higher strictness.
11:30:41 <fizbin> And I suppose also "these techniques can be used to inspect the amount of laziness your calculation currently has, and where". That would be useful too.
11:31:03 <EvanR> what is the unit of measure for laziness
11:31:34 <EvanR> nanohaskells?
11:31:53 <EvanR> more seriously how do you measure it
11:32:17 <fizbin> EvanR: some techniques can be found by searching https://github.com/ndmitchell/hlint/blob/master/data/hlint.yaml for "IncreasesLaziness"
11:32:18 <Tuplanolla> It's measured in bytes, by the heap profiler.
11:32:37 <EvanR> the more thunks, the more lazy?
11:33:11 <fizbin> EvanR: I suspect there's only a partial order on laziness, and not a strict numeric measure.
11:33:11 <monochrom> Now here is a more serious correlation. Every person I have seen who correctly predict laziness and strictness can read GHC core.
11:33:30 <monochrom> I used to be an exception, but then I also learned to read GHC core. Now there is no exception left.
11:33:47 <EvanR> throwIO monochrom
11:34:05 <monochrom> And more than 90% of them read the STG paper.
11:34:18 <fizbin> That is, you can sometimes say definitively "this construct is more lazy/more strict than this other construct" but oftentimes two different things are incomparable.
11:34:22 <monochrom> (Oh, I used to be in the 10%, too.)
11:34:49 <monochrom> Yes it's a non-linear partial order.
11:35:01 <monochrom> In fact it's a CPO.
11:35:16 <EvanR> monochrom: im guessing that this is because GHC doesnt strictly follow uniform laws about what it will do with a given algorithm and its types
11:35:40 <monochrom> Sorry, what is "this"?
11:35:54 <fizbin> monochrom: Which definition of complete partial order are you using?
11:36:12 <monochrom> Has bottom.
11:36:13 <EvanR> being unable to predict laziness without reading core
11:37:29 <EvanR> i behaves differently with Int, Integer, ByteStrings, Either Bool (Maybe [()])
11:37:40 <EvanR> it*
11:38:06 <monochrom> Yes, that's part of it. But another part is when the program is tricky, it's easier to just ask GHC than predict yourself, even if your model and GHC agree.
11:38:08 <fizbin> Well, now, he didn't say that. He implied that the ability to predict laziness and the ability to read core were correlated, but didn't say that you needed to apply the core-reading ability to predict laziness.
11:38:13 <nshepperd> I have never resorted to reading core to understand the lazinesss of a function. however, learning core / stg is probably a good step to understanding ghc's evaluation model
11:38:16 <monochrom> In other words "I am too lazy".
11:38:57 <monochrom> Also, like I said, it's a correlation. The hidden variable is "these are people who actually bother to learn the real thing".
11:39:18 <dolio> The point is, learn the operational semantics.
11:39:40 <monochrom> Where my "real thing" means the negation of cargo culting.
11:39:46 <fizbin> So is a fair summary: "Sometimes one has to read core to predict laziness, but when one does not one needs to understand GHC's evaluation model deeply. Understanding GHC's evaluation model deeply makes it easier to then learn to read core"
11:40:18 <Tuplanolla> I like it.
11:40:23 <EvanR> negation of cargo culting is undecidable
11:40:52 <monochrom> Oh, cargo culting is decidable, in fact decidably wrong.
11:40:58 <EvanR> fizbin: i heavily simplified the assertion for posterity
11:41:12 <monochrom> Like astrology.
11:41:14 <EvanR> while were taking "statistically true" to be a valid version of truth
11:43:00 <monochrom> Anyway, it's like how chemists do things. You could whip out Schrödinger's equation to predict the reaction between two substances. But why bother, just let them react and then spectro-analyze or something.
11:43:01 <nshepperd> by rice's theorem, everything good and true is undecidable
12:00:15 <klottie> I have a data type "data T a = A a a [T a] | B a a [T a]". But it gives me an error when I pattern match a function "foo (_ _ _ t) = ...". Why is this not allowed? Do I have to explicitly type "foo (A _ _ t) = ..." and "foo (B _ _ t) = ..."?
12:00:45 <lyxia> yes
12:01:38 <ski> klottie : factor : `data T a = MkT AB a a [T a]; data AB = A | B; foo (MkT _ _ _ t) = ..t..'
12:01:52 <geekosaur> ^
12:02:10 <geekosaur> refactor, it's a bit silly to have things that differ only by the data constructor
12:03:30 * ski . o O ( `(a * a * [T a]) + (a * a * [T a])  =  (1 * a * a * [T a]) + (1 * a * a * [T a])  =  (1 + 1) * a * a * [T a]' )
12:05:26 <klottie> thank you.
12:05:30 <lyxia> that's a lot of work to say that x + x = 2x :P
12:05:46 <monochrom> Sometimes it is useful to differ by only the data constructor. But you still can't wild-card the data constructor itself.
12:07:11 <ski> lyxia : yes. just pointing out why i used the word "factor"
12:15:56 <EvanR> is x + x = 2x true for Double
12:16:12 <EvanR> ignoring NaN
12:16:38 <geekosaur> you also have to ignore Inf to get to the really scary part :)
12:16:45 <pikajude> yeah you just shift the whole thing up by a bit
12:17:55 <EvanR> > (-0.0) + (-0.0) 
12:17:57 <lambdabot>  -0.0
12:18:06 <EvanR> interesting
12:20:29 <klottie> > (-0) + (-0)
12:20:31 <lambdabot>  0
12:22:08 <klottie> IEEE 754 represeantation for floating-point numbers have 2 zeros, whereas two's complement integer representation have one zero. I believe so, at least.
12:22:13 <geekosaur> yes
12:22:41 <geekosaur> because you need to propagate sign when working with trig functions in rectangular mode, or you end up in the wrong quadrant
12:22:52 <geekosaur> this is also why atan2 exists
12:23:14 <EvanR> two zeros is better than one, but not greater than one zero
12:23:48 <Tuplanolla> This has always felt unsatisfying to me. What could a better design look like?
12:24:09 <EvanR> by taking it more seriously
12:24:48 <Tuplanolla> My eyebrows can only frown so much.
12:24:53 <EvanR> if you imagine negative zero represents some very small negative value "under the radar", great. but we dont get this kind of thing anywhere else in the domain
12:25:18 <EvanR> like, very small positive value even
12:26:21 <merijn> EvanR: Actually, you do in IEEE754 floating point...
12:26:35 <EvanR> eh? what is that
12:26:45 <EvanR> i mean, the very small positive value under the radar
12:27:18 <EvanR> +0.0 "is" zero
12:28:23 <merijn> EvanR: Well first of all, there's positive zero as complement of negative zero. Secondly, IEEE754 has a bunch of stuff dealing with infinitesimals that I can't remember
12:28:43 <EvanR> really?
12:29:08 <Tuplanolla> Dubious.
12:30:45 <mnoonan> do you mean denormals, or something else?
12:30:46 <merijn> tbh, IEEE-754 is far more scientifically and elaborately specified than many people seem to assume
12:31:09 <merijn> mnoonan: Oh, maybe, I try to not actually use IEEE754 if I can help it, so my terminology is rusty :p
12:31:33 <EvanR> positive denormals is something else
12:31:37 <EvanR> they have a known value
12:33:51 <merijn> Completely unrelatedly: Am I the only one missing hackagebot? Why did it get killed? (Besides the amazonka spam >.>)
12:34:13 <dolio> I'm definitely not missing it.
12:34:18 <Tuplanolla> I wouldn't mind a less verbose version.
12:34:34 <merijn> dolio: I liked discovering new funny packages from it
12:34:42 <EvanR> a daily link to everything you missed on hackage wouldnt be that bad
12:34:49 <geekosaur> that, and its maintainer handed it off and the new maintainer hasn't reactivated it yet
12:34:53 <merijn> dolio: The only real problem I had was the 50 amazonka all updating in sync
12:35:03 <geekosaur> there was some discussion on -cafe a couple months ago, then silence
12:35:22 <merijn> And spamming the channel, but I think blacklisting spammy packages from hackagebot would've been nicer than simply dropping it altogether
12:36:02 <geekosaur> for that I'd rather it collect and output one for the problematic ones. prefix match would catch them
12:36:57 <merijn> geekosaur: I'm not too worried about the specific implementation, just saying that I only ever noticed 1 or 2 package groups resulting in noise to begin with
12:36:58 <geekosaur> "* amazonka-* (54 packages) ..." or some such
12:37:08 <geekosaur> I think I spotted four
12:37:21 <geekosaur> but those four updated often enough to be annoying
12:37:30 <merijn> And speaking of infrastructure disappearing...
12:37:31 <geekosaur> (in particular gi-* was updating a lot)
12:37:44 <merijn> What happened with ircbrowse? It seems completely broken
12:37:45 <Tuplanolla> Filter revision number bumps too?
12:38:13 <geekosaur> same issue :) both chrisdone things that were not adopted
12:38:15 <cocreature> merijn: chrisdone recently abandoned a lot of his projects so I would expect that this was included
12:38:37 <merijn> cocreature: It's slowly breaking further and further. The user info page was broken first, now even the logging is broken
12:38:39 <orion> cocreature: Why did Chris Done abandon many of his projects?
12:38:43 <Tuplanolla> I don't particularly care if Pandoc goes from 1.19.2.1 to 1.19.2.2.
12:38:50 <geekosaur> too busy to maintain them
12:38:50 <cocreature> orion: lack of time and rsi iirc
12:38:51 <merijn> It's a shame, ircbrowse was amazing
12:38:56 <orion> RSI?
12:39:00 <geekosaur> it was a fairly large list of packages so I can see "too busy"
12:39:09 <cocreature> repetitive strain injury
12:39:33 <orion> Like carpal tunnel syndrome?
12:39:39 <cocreature> also user-facing packages like intero tend to take a up a lot more time due to support requests
12:40:19 <geekosaur> that and a few other things (like, there's a nerve in the elbow that can get RSI... I have that one)
12:41:08 <merijn> geekosaur: Might wanna look into weight training. I used to have some intermittent RSI-like symptoms, but managed to eliminate almost all of it that way
12:41:36 <geekosaur> sadly this one is genetics and age
12:41:59 <cocreature> can’t you just crispr it away? :)
12:43:12 <cocreature> has anyone seen the following issue in profiling builds? http://lpaste.net/354811
12:43:29 <cocreature> it goes away with -O0 so I’m relatively sure it’s a GHC bug but maybe it’s at least a known one
12:43:49 <cocreature> all the issues I could find point to TH and -fno-code but -fno-code should not be involved here
12:43:54 <cocreature> TH definitely is
12:43:54 <merijn> More haskell related: Anyone know how I can set some criterion benchmarks to "default enabled"
12:44:17 <merijn> eh
12:44:21 <merijn> default disabled, I mean
12:46:51 <Clint> merijn: you mean you want them to not be enabled if someone runs cabal configure --enable-benchmarks ?
12:47:40 <merijn> Clint: No, I mean I have a criterion benchmark executable which contains several groups of benchmarks and I want some to only run when explicitly enabled
12:48:19 <ExpHP> I have a yaml file that is several gigabytes large.  Is it possible for me to even /touch/ this thing with any existing libraries without blowing the heap?
12:48:25 <merijn> Like, I have "defaultMain [ group1, group2, group3 ]", but I want some of those groups to only run if explicitly asked for
12:49:19 <merijn> ExpHP: Depends. Does it like, contain a list of many independent YAML objects?
12:49:40 <ExpHP> merjin: ah, I think I see where you are going
12:49:43 <ExpHP> with this
12:49:46 <cocreature> ExpHP: I’m tempted to ask how you ended up with such a file but I’m scared of the answer :)
12:49:49 <ExpHP> merjin: yes it does :)
12:49:56 <cocreature> ExpHP: on a more serious note, https://hackage.haskell.org/package/yaml-0.8.22/docs/Text-Libyaml.html provides a streaming interface
12:50:19 <merijn> ExpHP: Google something along the lines of "haskell yaml conduit" or "yaml pipes" to see if someone implemented a streaming library
12:50:30 <ExpHP> cocreature output of some program that computes phonon band structure
12:50:48 <ExpHP> it's, bizarrely, a yaml encoding of very large complex vectors
12:51:18 <merijn> Clint: But if you have any other suggestions I'm open :)
12:51:43 <Tuplanolla> Sounds like someone needs to learn about HDF5, ExpHP.
12:51:45 <ExpHP> cocreature: oh goody, an excuse to learn conduit :)
12:52:01 <cocreature> ExpHP: what confuses me is why you would use yaml for such a thing. I tend to see yaml as targeted at input made by humans which should never reach those dimensions. but I’m not being helpful here so I’ll shut up now :)
12:52:04 <ExpHP> Tuplanolla: the program does actually use HDF5 for some of its data, just not this :V
12:52:25 <merijn> cocreature: Historical accident by some PhD prototype with no time to fix it >.>
12:52:38 <cocreature> merijn: heh that’s a pretty good reason
12:52:50 <cocreature> gotta love research quality software
12:53:02 <geekosaur> i.e. where too many commercial products come from (looking at you, matlab and cadence!)
12:53:10 <merijn> cocreature: Same reason I got 15 million lines of plain text measurement results :)
12:53:30 <cocreature> merijn: I’m sure plaintext was fine when the output was 15 lines long :P
12:53:47 <merijn> cocreature: Parsed in python to nested dictionaries >.>
12:54:11 <merijn> Takes like 15 minutes to load in my input...should've used SQLite
12:54:16 <ExpHP> merijn: close, though if it ever constructed the dictionary then the Python would OOM
12:54:31 <ExpHP> so it actually rolls its own yaml output
12:54:34 <Tuplanolla> I'm actually working with something like that at the moment, because it's so difficult to get the tech support to install `libnetcdf-dev` for me.
12:54:55 <merijn> ExpHP: It's only a few GB, not too hard to get a machine that can deal with that :p
12:55:09 <ExpHP> merijn: of dictionaries and refcounted floats?
12:55:40 <merijn> ExpHP: dictionaries don't have that much overhead, neither do floats. I'd suspect a couple tens of GB RAM at most unless it's doing weird things?
12:56:09 <ExpHP> merijn: A couple of tens of GB ram is what I would call "disk thrashing"
12:56:30 <ExpHP> and what my comptuer would call [quiet clicking noises for 20 minutes]
12:56:35 <dolio> Get a new computer. :P
12:56:37 <merijn> ExpHP: No compute cluster/servers? :)
12:57:18 <ExpHP> I'm too lazy to deal with their ancient build tools :f
12:57:35 <merijn> The nodes in ours have 64GB RAM, so I just go YOLO on the RAM usage if I think it'll save me time
13:01:38 <cdornan> Orion: which projects do you have in mind?
13:04:17 <merijn> bleh...I wish criterion had an interface for benchmarking "single run" benchmarks too :\
13:05:08 <cdornan> To answer your question, a combination of being too busy, packages being superseded by better alternatives and lack  of interest/demand
13:06:34 <cdornan> And packages not needing any maintenance
13:07:07 <davean> merijn: "single run"?
13:08:28 <merijn> davean: So currently criterion benchmarks things by running them N times, using the same input (when using "env"), however, many things you want to benchmark don't fit this mold
13:08:34 <cdornan> Sorry -- just reread above -- wrong Chris! Bah -- thought it was strange!
13:08:44 <geekosaur> heh
13:08:59 <merijn> davean: In many cases you want to either have the input allocated per "batch" of runs, or even per single invocation
13:09:08 <cdornan> Agree with the others about too much to do and RSI
13:09:47 <merijn> davean: Simplest example being, mutable vector benchmarks for sorting. Clearly the current "env" setup doesn't work, you need a new unsorted vector for every run!
13:11:00 <merijn> davean: I have a local (simple) patch that lets me allocate (and cleanup!) resources per batch of N runs (since Benchmarkable boils down to "Int64 -> IO ()", simply allocating/cleaning per batch was easiest to fix. But that still doesn't work for, e.g., sorting vectors
13:12:45 <merijn> davean: In my case I wanted to benchmark Chan, MVar, and similar things. I can't simply allocate a single Chan using "env" as, suppose criterion ends up going up to 1000 iterations, all the previous "sum [1..999]" messages written to Chan would still be in there, bloating the RES memory and thus GC times, ruining the benchmark.
13:13:34 <merijn> Currently I'm trying to benchmark the speed of synchronising a bunch of threads, but this requires me to: launch a bunch of threads, wait for them to sync, repeat. It's hard to turn that into something that can easily be repeated N times like Benchmarkable wants
13:21:39 <c_wraith> merijn, just in that a single case takes more than a few milliseconds? 
13:22:10 <merijn> c_wraith: No, in the sense that I require setup to run a single step, but that setup shouldn't be measured
13:23:00 <c_wraith> can the setup be shared? 
13:23:18 <merijn> So I guess I should just yak shave and generalise my "per batch" setup/cleanup  to work per run too
13:23:23 <c_wraith> Oh, I see. it can't. 
13:23:47 <merijn> c_wraith: Well you could setup N repetitions in advance and run them sequentially, but that risks throwing off your measurements
13:24:03 <merijn> c_wraith: Since extra live data == slower GC == biasing your results
13:24:56 <c_wraith> yeah.. criterion kind if treats IO benchmarkables as an afterthought 
13:25:25 <dolio> It was an afterthought.
13:25:28 <merijn> Like I said, patching it to work for stuff you can batch was ok
13:26:05 <merijn> i.e., for benchmarking writeChan I can simply do N writeChan's (N being the value criterion supplies to a Benchmarkable) and share a single alloc/cleanup for that batch
13:31:48 <merijn> So, one more yak to shave :p
13:32:27 <cocreature> shave 9 yaks and you’ll get 1 additional yak to shave for free!
13:32:56 <c_wraith> it's more the other way around. shave 1 yak, get 9 free. 
13:32:57 <monochrom> The last 20 yaks take 80% of your time.
13:32:59 <merijn> cocreature: I'd settle for merely some groupies and a cult of personality
13:33:07 <sproingie> there's always more yak to shave.  it's like zeno's paradox.
13:33:38 <merijn> If not me, then who? No one else is this unreasonable about things. Everybody else just gives up on benchmarking instead >.>
13:33:43 * cocreature starts cheering for merijn
13:33:50 <sproingie> or it's an infinite yak.  hm, can you comb an infinite yak smooth?
13:34:04 <monochrom> You need 4 dimensions.
13:34:12 <sproingie> ah, a hyperyak
13:34:23 <merijn> I also accept payment in single malt scotch...
13:34:34 <merijn> sproingie: A hyperyak could be any number of dimensions!
13:34:37 <c_wraith> well, yaks aren't topological spheres. they have multiple discontinuities 
13:34:49 <sproingie> assuming a perfectly spherical yak
13:35:05 <monochrom> Remove the discontinuities.
13:35:09 <merijn> Common misconception is that hypercubes are 4D cubes, whereas they're in fact "cubes in some unspecified dimensionality" (including squares!)
13:35:25 <merijn> c_wraith: Pretty sure yaks are donuts, like most living things
13:35:27 <EvanR> whats a quick way to solve sin x = sin (x + phi) for x
13:35:36 <merijn> EvanR: Wolfram Alpha
13:35:41 <merijn> >.>
13:35:46 <EvanR> mkay
13:36:01 <c_wraith> merijn, as far as shaving them goes, things like hooves matter too. 
13:36:11 <c_wraith> merijn, or combing! 
13:36:26 <merijn> c_wraith: I'd expect the horns to matter more :p
13:38:54 <EvanR> that actually worked
13:40:54 <merijn> EvanR: Of course it did. My answers maybe borderline impractical and/or completely unrealistic, but mostly they're not wrong :p
13:41:13 <merijn> Also, everyone always forgets Wolfram Alpha is pretty amazing :)
13:43:09 <EvanR> i dont forget, but something about the hiding extra digits or graphical chart features behind a paywall annoys me
13:43:15 <monochrom> EvanR: Use an identity under https://en.wikipedia.org/wiki/List_of_trigonometric_identities#Product-to-sum_and_sum-to-product_identities
13:43:51 <monochrom> You want the one about sin - sin = product. Then you have product = 0 and it's much better.
13:44:06 <EvanR> product = 0
13:44:18 <EvanR> ok
13:45:01 <monochrom> Yes, Wolfram Alpha did low-pass filter for me once.
13:47:16 <monochrom> Oh yikes, before they discovered log, they used these product-to-sum formulas instead?!
13:48:10 <monochrom> I guess "if all you have is a trig table..."
13:48:19 <merijn> hmmm, do I use a simple ADT, leading to confusion what the different fields mean. Or use records, but end up with partial field accessors?
13:49:50 <monochrom> I use records but I don't use the field accessors I get.
13:50:43 <monochrom> Yes, I actually write out "f X{left=l, key=k, right=r} = f l + 1 + f r "
13:50:58 <lyxia> you can also make a sum of proper records
13:52:09 <Tuplanolla> I'm disappointed you didn't push prisms already.
13:54:52 <monochrom> OK! Consider prisms!
13:56:31 <monochrom> One day I should write a really huge lens library, 100 times bigger than lens. Then call it "Very Large Telescope Array".
13:57:37 <lyxia> Hubble
14:00:45 <bshelden> Then make another, call it Webb.
14:01:29 <geekosaur> ALMA?
14:05:55 <Nolrai> Does (return .) have a name?
14:06:20 <monochrom> fmap
14:07:59 <Nolrai> monochrom: fmap has type (a->b)-> f a -> f b, I want (a->b)->a -> f b.
14:08:15 <monochrom> Oh, oops.
14:09:10 <Tuplanolla> :t fmap pure -- I don't think this has a name, Nolrai.
14:09:11 <lambdabot> (Functor f1, Applicative f) => f1 a -> f1 (f a)
14:09:57 <Nolrai> Okay.
14:11:10 <merijn> Speaking of names
14:11:20 <merijn> Is there a good alternative to "const (return ())"?
14:11:55 <Nolrai> Hm.
14:12:01 <Tuplanolla> There's an alternative formulation of applicative in terms of `unit` and `zipA`, where that would be `const unit`, merijn.
14:13:21 <Nolrai> merjin: what's the context?
14:13:47 <Tuplanolla> It's such that `pure x = fmap (const x) unit` and `f <*> x = fmap (uncurry ($)) (zipA (f, x))`. I use it every now and then.
14:16:05 <merijn> Nolrai: Cleanup action that needs a no-op cleanup, i.e. take a value and do nothing
14:17:33 <merijn> @hoogle Monad m => a -> m ()
14:17:34 <lambdabot> Pipes discard :: Monad m => a -> m ()
14:17:34 <lambdabot> Control.Monad.Extra discard :: Monad m => a -> m ()
14:17:34 <lambdabot> Control.Monad.HT void :: (Monad m) => m a -> m ()
14:18:19 <Nolrai> Monad.Extra discard looks right.
14:18:57 <merijn> Nolrai: Yeah, but not worth picking up a random extra dependency for :)
14:19:49 <Nolrai> I might define "do_nothing _ = return ()"
14:20:22 <Nolrai> Its not much shorter, but is pretty clear.
14:24:01 <Nolrai> or maybe "ignore _ = return ()"
14:24:41 <monochrom> "void" already exists for that :)
14:24:58 <merijn> monochrom: Not the same thing
14:25:21 <monochrom> Err, maybe it's called "ignore" afterall.
14:25:23 <monochrom> @type void
14:25:25 <lambdabot> Functor f => f a -> f ()
14:25:37 <monochrom> @type ignore
14:25:38 <lambdabot> error:
14:25:38 <lambdabot>     • Variable not in scope: ignore
14:25:38 <lambdabot>     • Perhaps you meant one of these:
14:25:59 <EvanR> adding to the confusion between void, Void, () and ()
14:26:11 <monochrom> void is close enough.
14:26:12 <EvanR> where void might mean ()
14:26:35 <monochrom> Oh! I see, different effects.
14:31:54 <merijn> Bleh, there's no way to use e.g. try/finally on a value MonadIO without using something like exceptions or the MonadBaseControl stuff, right?
14:33:10 <monochrom> MonadIO is way too general (weak API) for cunning control flow.
14:33:48 <merijn> A pox upon whoever decided the type of this thing to be MonadIO...
14:34:04 <merijn> So, any advice on picking bounds when adding a new dependency to some package?
14:34:09 <monochrom> Allowing you to contrive counterexamples such as LogicT IO for which you don't even want to ask what does it mean to throw or catch.
14:34:39 <glguy> merijn: It depends on how defensive you are with your imports if you want to set the bound "correctly"
14:34:57 <merijn> glguy: I generally am not, but since I hope to actually see this merged... :p
14:35:31 <monochrom> I would start with "== x.y.*" in my first version. Relax when demanded.
14:35:59 <monochrom> Unless it's base. Then it's "base < 10" because I use base 10.
14:36:32 <Nolrai> I think you mean base >= 10?
14:36:52 <monochrom> The "I use base 10" part was a joke.
14:37:05 <Nolrai> Oh, riht!
14:37:09 <Nolrai> Sorry.
14:37:15 <monochrom> http://cowbirdsinlove.com/43
14:37:24 <monochrom> I use base-10. What is base-4.9.0.0? :)
14:38:01 <c_wraith> all systems are base-10
14:38:05 <Nolrai> Shouldn't that be "what is 4?"
14:38:10 <monochrom> I found a dons package that had "base < 10" and I much admire it. :)
14:38:36 <c_wraith> amusingly, that package broke when base 4.0 was released 
14:38:43 <monochrom> haha
14:40:24 <merijn> @quote dcoutts practise
14:40:24 <lambdabot> dcoutts says: ...These packages all use "build-depends: base >= 3 && < 4" (except for ghc-core which cheekily uses "build-depends: base < 10" --- a practise we will ban if it becomes any more
14:40:25 <lambdabot> popular).
14:40:25 <merijn> :p
14:40:52 <dcoutts_> @yarr!
14:40:52 <lambdabot> What be a priate's favourite cheese?
14:40:52 <lambdabot> Yarrlsburg!
14:41:18 <Tuplanolla> How is that related to primates?
14:41:44 <merijn> dcoutts_: cabal-install 2.x will never get released if you're slacking off on IRC! *ducks*
14:44:15 <merijn> Can I put inline pragma's on where clauses? Or will GHC liberally inline those anyway?
14:45:13 <monochrom> The intersection between primates and pirates is non-empty. :)
14:45:44 <monochrom> I think yes for the first question.
14:55:03 <Nolrai> How hard would it be to make a function take any of (a->m b, b -> m a), (a-> m b, b -> a), or (a->b, b->a)?
14:55:44 <monochrom> change a->b to a -> Identity b
14:56:59 <Nolrai> Yeah but then I still need to write "(return . g)" where I use it.
15:02:42 <Nolrai> I guess what I really want is a type class: "class Foo b b' where foo : (a -> b)-> (a -> b')" and "instance Applicative m => Foo a (m a)  where foo f = pure . f" and "instance Foo a a where foo = id"? Will this confuse the typechecker too much?
15:04:24 <Aruro> why show "abc" escapes quotation sign?
15:04:43 <merijn> Aruro: Why wouldn't it?
15:04:56 <Aruro> thus making (read "abc" :: String) == "abc" impossible
15:05:52 <Aruro> merijn: because there are no quotation signs in string "abc"
15:06:12 <dolio> Why did you write two of them, then?
15:06:18 <Aruro> > read "abc" :: String
15:06:20 <lambdabot>  "*Exception: Prelude.read: no parse
15:06:34 <Tuplanolla> > fix show :: String
15:06:35 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
15:06:38 <merijn> What even is the point of "read" to convert to String?
15:06:44 <Aruro> dolio: show instance and object are not same , where is problem?
15:07:15 <Aruro> merijn: its not plausible to ask such question unless u know all cases
15:07:29 <merijn> > show "abc"
15:07:31 <lambdabot>  "\"abc\""
15:07:41 <merijn> > read (show "abc") :: String
15:07:43 <lambdabot>  "abc"
15:07:49 <merijn> Looks fine to me?
15:07:53 <Aruro> so why read is not capable or reading actuall string?
15:08:12 <Aruro> > read "abc" :: String 
15:08:14 <lambdabot>  "*Exception: Prelude.read: no parse
15:08:16 <lyxia> Many other instances use read/show on their fields.
15:08:18 <Aruro> seems not fine to me
15:08:29 <merijn> Aruro: Well what would you expect it to do?
15:08:42 <Aruro> i would want it to be "abc"
15:08:46 <Aruro> identity
15:08:49 <Aruro> somehow
15:08:55 <dolio> Why not use the identity function if that's what you want?
15:08:56 <merijn> Aruro: Why would it do that?
15:09:07 <Aruro> dolio: because i use read on other types
15:09:26 <merijn> I don't suppose there's a replicateM that accepts Int64
15:09:28 <Aruro> merijn: ok i would reply in your logic, why wouldn't it do that?
15:09:47 <merijn> Aruro: Because that's not how the behaviour of Read is defined?
15:10:08 <Aruro> i read command line argument and if its string read is broken
15:10:22 <hexagoxel> the string `show`n when doing `show "abc"` contains no quotation marks. the initial question seems to stem from some misunderstand already.
15:10:47 <Aruro> hexagoxel: read is incapable of reading command line string
15:10:51 <hexagoxel> the escapes are an artifact from `show`ing twice, the second happening implicitly.
15:11:05 <Aruro> > read "123" :: String
15:11:07 <lambdabot>  "*Exception: Prelude.read: no parse
15:11:10 <Aruro> no showing here
15:11:38 <Aruro> :t getArgs
15:11:39 <lambdabot> error: Variable not in scope: getArgs
15:11:51 <hexagoxel> > read "(\"abc\", 1)" :: (String, Int)
15:11:53 <lambdabot>  ("abc",1)
15:12:13 <hexagoxel> if you omitted the quotation marks when showing, something like that could never parse
15:12:43 <merijn> Aruro: So don't use getArgs and use a proper library like optparse-applicative
15:12:45 <hexagoxel> show=read=id for String would not work if composed.
15:12:47 <Aruro> i understand, but simple string is not being parsed either
15:13:09 <Tuplanolla> @let newtype AsIs a = AsIs a -- You could do this and define `instance Read (AsIs String)`, Aruro. However that's rather disgusting.
15:13:10 <lambdabot>  Defined.
15:13:48 <Aruro> merijn: read is perfectly fine if u know how to use it
15:13:58 <Aruro> no need of useless dependencies
15:14:11 <merijn> I agree with the statement that read is perfectly fine
15:15:26 <Aruro> Tuplanolla: but then i can not abstract over usual string functions like reverse for example
15:15:34 <Aruro> i will need to switch them to new type
15:15:49 <Tuplanolla> You can derive `Functor` to get all that for free, Aruro.
15:16:12 <Aruro> ok, seems promising
15:16:30 <Tuplanolla> @let deriving instance Functor AsIs -- Can our robotic maid do this?
15:16:32 <lambdabot>  Defined.
15:17:28 <Aruro> so then reverseAsIs = fmap reverse
15:17:37 <Aruro> ok, i think its much better than nothing, ty
15:24:22 <hexagoxel> finally, a total read implementation.
15:25:53 <Nolrai> :P
15:26:23 <hexagoxel> .. i still doubt that it is what you want. if you want id, use id, not read. having a parsing function return rest-of-input makes rarely sense.
15:26:59 <Tuplanolla> They're gone, hexagoxel.
15:27:53 <EvanR> heres a case where parsing function return "rest-of-input" (with a useful answer too) makes sense when the parser doesnt directly support streaming
15:35:07 <Nolrai> Yeah the more I think about it the less I think Aruro actually wants "read = id".
15:37:32 <monochrom> If String's Read and Show did not put in quotes (or generally use string-literal syntax), then "data M a = a :*: a deriving (Read, Show)" would royally break for M String.
15:40:07 <monochrom> or (String, String)
15:44:27 <monochrom> Also yes, read=id for your own string type is likely a bug waiting to happen.
15:50:26 <Nolrai> I guess they are doing something like (onArgs f = do {[a,b,c] <- getArgs; f (read a) (read b) (read c))?
15:51:53 <monochrom> That one benefits from f (read a) (id b) (simply c)
15:53:44 <Nolrai> Right, but the first can take both (f :: Int -> String -> Int -> IO d) and (f::String -> String -> Float -> IO d) and so could save a tiny bit of code duplication.
15:54:14 <monochrom> Oh! f is a parameter.
15:54:24 <Nolrai> Right.
15:54:36 <Nolrai> I still agree that its a terrible idea.
15:54:53 <monochrom> Then wrong abstraction. The parameters should be 3 parsers.
15:55:06 <Nolrai> Yes.
15:55:54 <mjora7> Is there a difference between `let thing = 123` and `thing = 123`?
15:56:04 <Nolrai> Yes.
15:56:38 <merijn> mjora7: Yes, depending on where you type them, one of the two is a syntax error
15:56:59 <Nolrai> The first is part of an expression of one of two forms, the other is a declaration.
16:01:05 <abel-abel> Hello, I use Emacs in windows. When I start haskell repl in Emacs, it shows https://snag.gy/1lGPT9.jpg . My configuration: https://snag.gy/A0gGSj.jpg . And I also tried: https://snag.gy/B6VRz9.jpg Neither of them works. :( Any suggestions?
16:03:13 <abel-abel> Besides, the path `C:\Program Files\Haskell Platform\8.0.2\bin\ghci.exe` exists. I can start it on windows.
16:03:58 <Nolrai> (The two forms are "'let' name pattern* = exp 'in' exp" which is just a normal expression, and the form "let x = y"  which can be used in do blocks (but can't be the last 'statement' in a do block))
16:21:49 <abel-abel> :(
16:22:20 <bshelden> I see your question, but unable to help, sorry :(
16:23:41 <abel-abel> bshelden, you use Linux or macos?
16:24:02 <bshelden> Linux.  
16:24:27 <bshelden> But I use vim and an external terminal to invoke things.
16:24:38 <bshelden> I haven't yet taken the time to learn emacs.
16:24:49 <mjora7> Hey, could someone help me understand why this code doesn't work? I must be misunderstanding how Type Classes work. https://gist.github.com/aryaforghani/955a0051aff281f4fb1614e0c91b0b4c#file-showpersoninfo-hs
16:24:54 <abel-abel> bshelden, yeah. My Emacs configuration works well in Linux.
16:26:15 <thang1> There are emacs configurations that don't work well in Linux?
16:27:51 <abel-abel> thang1, I mean my haskell emacs configuration doesn't work well in Windows. :(
16:28:58 <AWizzArd> In a blog posting I read that monads have “strong limitations”, and something more powerful had to be invented: arrows.  Is that true? Or could this be the interpretation of somebody who only spent some months with Haskell?
16:28:59 <bshelden> Yeah, I try very hard not to develop on windows.  To the point where I'll fire up a linux VM to avoid it.
16:29:13 <bshelden> That strikes me as an odd statement...
16:29:45 <Sornaensis> strong limitations?
16:29:49 <bshelden> It's not so much that monads have "strong limitations".  Monads are applicable where you see >>='s type signature.  They're not when you don't.  Like any abstraction...
16:30:06 <bshelden> (I'm being a little lose here, I know)
16:30:13 <Sornaensis> loosey goosey
16:30:22 <mckeankylej> Is it possible to construct law abiding monad instances for mutually recursive datatypes? Like the ones in this: http://lpaste.net/354818
16:30:28 <LHoT10820> Regarding Haskell's lazy evaluation: In the following formula: Does Haskell generate the whole list before iterating through each tuple? Or does it evaluate each tuple as it's created, before the list is completed?
16:30:30 <thang1> Nothing works well in windows :p
16:30:32 <LHoT10820> [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
16:31:04 <AWizzArd> The „limitation” factor was something like: bind can’t look deeper into the structure. A monad can’t see a full do block before evaluating it.
16:31:16 <Sornaensis> > [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
16:31:22 <lambdabot>  mueval-core: Time limit exceeded
16:31:41 <LHoT10820> rip
16:31:43 <mjora7> Sorry I'm a noob but I don't understand why my code isn't working and I don't understand the error message or know what to look up.
16:31:45 <Sornaensis> > take 1 [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
16:31:47 <lambdabot>  [(6,8,10)]
16:31:48 <Sornaensis> anyway
16:32:01 <mjora7> It seems like Haskell isn't very beginner friendly, kind of getting discouraged.
16:32:33 <Sornaensis> mjora7: code and error?
16:32:36 <bshelden> Depends on what you're looking for when you say "Beginner friendly"
16:32:41 <blym> mjora7, if you’re using ghci, try using :t <expr>
16:32:48 <LHoT10820> mjora7: Programming as a whole typically isn't beginner friendly. You're gonna keep walking into walls until it all of a sudden clicks one day.
16:32:48 <mjora7> Sornaensis https://gist.github.com/aryaforghani/955a0051aff281f4fb1614e0c91b0b4c#file-showpersoninfo-hs
16:32:48 <EvanR> arrows arent more powerful than monads, they are actually not as powerful
16:32:53 <blym> like this: :t showPersonInfo
16:32:54 <LHoT10820> That's regardless of language.
16:33:14 <blym> it will show you the most general inferred type, and you can compare that with your current implementation to see what’s wrong
16:33:18 <bshelden> Let us know what you're missing and we can help you find the tools you need.
16:33:27 <bshelden> :t is one of the more important ones for sure
16:33:28 <mjora7> Trying to understand how to properly declare the typeclasses
16:33:28 <lambdabot> error: parse error on input ‘of’
16:33:29 <LHoT10820> Don't be afraid to ask for help outright, we've all been there.
16:33:30 <EvanR> but can be made equivalent to monads expressiveness with ArrowApply
16:33:40 <Sornaensis> mjora7: your function produces a String
16:33:41 <Sornaensis> not an a
16:34:19 <Sornaensis> also it looks like you want 'show name' and not 'name' in the body
16:34:26 <EvanR> mckeankylej: theres no reason why a recursive type cant be a monad
16:34:36 <AWizzArd> EvanR: okay. Then I would think that this blog author simply didn’t study Haskell deeply enough and just straight-ahead wrote his monad tutorial.
16:34:53 <ChaiTRex> mjora7: Also, you need Show b as a constraint, since you're using show on it.
16:35:04 <EvanR> AWizzArd: yeah thats a thing that happens... the monad tutorial after you try to figure out monads and nothing else
16:35:07 <mjora7> Ugh, I'm lost lol.
16:35:45 <EvanR> AWizzArd: a more important theme here is that you actually dont want power if you can avoid it, you want the thing that matches exactly what you are trying to do
16:35:47 <mckeankylej> EvanR: can you point me in the direction I need to go to write the monad instance I get stuck when I hit a case that has the other datatype because I have a function that goes from a -> A a but I have a B a
16:37:55 <mjora7> Sornaensis: So if I want a tuple that contains this data ("Bill", 1990), how would I declare the type of the function?
16:38:00 <EvanR> mckeankylej: im not sure your particular types can be monads... the definition of "pure" isnt inspiring me
16:38:18 <Sornaensis> :t ("Bill", 1990)
16:38:19 <mjora7> Sornaensis: showPersonInfo (String, Int) -> String ?
16:38:19 <lambdabot> Num t => ([Char], t)
16:38:21 <mckeankylej> EvanR: yea I feel the same way :/
16:38:36 <mjora7> What does Num t => mean?
16:38:53 <bshelden> Some type 't' for which an instance of the Num typeclass exists
16:38:57 <EvanR> mckeankylej: whats the a param supposed to be for this?
16:38:57 <ChaiTRex> mjora7: It means that the type t in your signature can be anything that implements Num.
16:39:03 <Sornaensis> some type t that has a Num typeclass instance
16:39:09 <mjora7> Ok, why is it 't' and not 'a'?
16:39:16 <Sornaensis> it's a variable
16:39:17 <bshelden> just a label
16:39:22 <Sornaensis> so the name isn't that important
16:39:22 <mckeankylej> EvanR: its the type of varaibles
16:39:38 <mjora7>  But why is 'a' used sometimes and 't' used othertimes? Are they interchangeable?
16:39:43 <EvanR> youre expecting a to be the same throughout the AST ?
16:39:49 <Sornaensis> in haskell, type signatures can contain variables
16:39:53 <mckeankylej> EvanR: yes
16:40:11 <EvanR> how should fmap work?
16:40:19 <c_wraith> mjora7, type variables assigned by ghc are t. type variables taken from a sub expression with an explicit type use those labels. 
16:40:25 <mjora7> Ok
16:40:41 <c_wraith> :t 1
16:40:42 <lambdabot> Num t => t
16:40:57 <c_wraith> no explicit signature, so it gets t
16:41:02 <c_wraith> :t map
16:41:04 <lambdabot> (a -> b) -> [a] -> [b]
16:41:17 <bshelden> :t fromInteger
16:41:18 <lambdabot> Num a => Integer -> a
16:41:22 <c_wraith> map was defined with an explicit signature, so it uses those labels. 
16:41:24 <bshelden> So that one's interesting.  Literal numbers in haskell are effectively wrapped in fromInteger
16:41:41 <c_wraith> bshelden, not as far as the labeling is concerned. :) 
16:41:52 <ChaiTRex> bshelden: Except for the ones with a dot in them.
16:41:55 <EvanR> -1 is also wrapped in negate
16:41:56 <bshelden> True
16:42:00 <c_wraith> :t map show
16:42:01 <lambdabot> Show a => [a] -> [String]
16:42:37 <c_wraith> mjora7, map show keeps the 'a' type variable it gets from both the map and the show sub expressions
16:43:04 <c_wraith> mjora7, ultimately, it doesn't mean anything. they important part is what labels are the same. 
16:43:24 <mckeankylej> EvanR: the idea is the monad instance does subsitution on variables 
16:43:50 <EvanR> mjora7: why type variables are automatically chosen to be certain letters really shouldnt distract you from learning... that they are anything you want, you could even use words instead of letters
16:43:57 <mjora7> Alright
16:44:10 <EvanR> sometimes that helps explain what theyre for
16:44:41 <mjora7> I'm just frustrated cause I can't even write a function that takes a tuple ("Bill", 1992) and returns "Bill was born in 1992", now I'm getting errors with " was born in " ++ show birthYear
16:45:22 <EvanR> mckeankylej: ah
16:45:30 <monochrom> Then you should put your current code on lpaste.net and show us.
16:45:45 * geekosaur bets it's precedence
16:46:10 <mjora7> One sec
16:46:10 <geekosaur> specifically application vs. everything else
16:46:31 <EvanR> mckeankylej: well to get started writing the implementation of >>=, you would do case analysis on the argument rather than assume _
16:46:39 <monochrom> We know that education systems have failed to teach science when we see that so many people have not been taught the value of conveying a reproducible experiment.
16:46:42 <mjora7> https://gist.github.com/aryaforghani/ae8c8e0e5c32fb55f534e8d98ee57241#file-code-hs
16:47:29 <monochrom> change Num to Show
16:47:41 <EvanR> mckeankylej: presumably you want to do something different in different circumstances
16:47:57 <monochrom> The function is not doing any arithmetic anyway.
16:47:59 <EvanR> whether or not to use f, what to pass f
16:48:06 <mckeankylej> EvanR: not sure what that is I will think of the semantics some more
16:48:09 <mjora7> monochrom: I don't need to be told how to fix my code, I wish I could just get a resource to learn from the proper way, or have someone explain *why*
16:48:23 <EvanR> and what to do with the result of f, if anything besides return it as is
16:48:24 <mjora7> monochrom But thanks, I appreciate it
16:48:36 <EvanR> and finally check that it obeys the monad laws
16:48:56 <monochrom> I can explain why. show uses the Show typeclass rather than the Num typeclass.
16:49:22 <monochrom> Most costs-money textbooks are proper.
16:49:53 <mjora7> So using :t ("Bill", 1996) was not a good way to intuit this
16:49:59 <mjora7> as I misled myself
16:50:00 <geekosaur> well. if this came from an older tutorial, then Num implied Show
16:50:27 <geekosaur> (and Eq)
16:52:05 <monochrom> A more accurate way to discover this is to have GHC infer the type of showPersonInfo instead. It will say what I said.
16:52:26 <monochrom> In general XY problems are XY problems.
16:52:30 <blym> mjora7, that’s because (“Bill”, 1992) and your code (ignoring your type declaration) have different sets of constraints that overlap each other
16:53:42 <mjora7> So is there a particular Haskell textbook that is recommended? I'm using Learn You a Haskell at the moment and I think it's not a very good resource (for me at least).
16:54:13 <blym> haskellbook.com, but it costs money
16:54:33 <monochrom> Graham Hutton's book. Richard Bird's book. Chris Allen's book (which is haskellbook.com)
16:54:38 <geekosaur> @where learnhaskell
16:54:38 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:54:40 <EvanR> :t ("Bill", 1996)
16:54:42 <lambdabot> Num t => ([Char], t)
16:54:49 <EvanR> :t ("Bill", 1996) :: (String, Integer)
16:54:51 <lambdabot> (String, Integer)
16:54:56 <geekosaur> ^ also some non-textbook stuff like the online cis194 andf NICTA courses
16:55:21 <EvanR> beginner mode might be interesting
16:55:22 <glguy> mjora7: Hutton's Programming in Haskell as mentioned above is worth looking at
16:55:43 <monochrom> I think I like Paul Hudak's book too but it's getting old. (And Hudak is no longer around.)
16:55:57 <EvanR> polymorphism is either too obvious for veterans of typed languages, or too scary for veterans of dynamically typed languages
16:56:11 <mjora7> Ok well thanks for the information everyone, I'll look into these resources.
16:56:57 <monochrom> I think I also know some lecture series on Youtube.
16:57:53 <monochrom> This one: https://www.youtube.com/playlist?list=PL4C1D41CB47EED318
16:58:34 <monochrom> I have only bookmarked it, I have not actually sat through it to evaluate.
16:58:54 <monochrom> Lazy evaluation is waiting for bitcoin input to start.
16:59:19 <monochrom> Ah but no not this summer, I have just signed a contract to do something else this summer.
17:26:12 <nitrix> Is there such type or concept that would let me fold a list of functions with the "minor" detail that the folding function should be able to decide if the current element is kept, skipped, or removed, and still doing the function applications on the fold value nicely?
17:26:40 <nitrix> I'm writing my own custom fold but asking out of the blue just in case :P
17:27:08 <ChaiTRex> nitrix: fold f . filter g?
17:27:22 <ChaiTRex> nitrix: Well, with the starting value too.
17:27:32 <EvanR> skipped and removed implies to be different
17:27:36 <EvanR> implied
17:27:43 <nitrix> ChaiTRex: The result of the application produces two values, one of which tells us if the element is to be kept or discarded.
17:27:57 <ChaiTRex> Oh, OK.
17:27:57 <nitrix> It's for some automata system.
17:28:33 <nitrix> Implementing this efficiently is a pain in the butt, because you end up reconstructing the Seq or list as you traverse it, sometimes needlessly because no mutation happened.
17:29:07 * EvanR runs cabal install sdl2 and waits for all (cabal-)hell to break loose
17:29:15 <nitrix> And if you try to be more clever about not generating garbage, then you cannot easily find your element within the data structure to remove it :/
17:30:00 <EvanR> for this next game project, i will be intentionally not optimizing anything
17:30:24 <EvanR> because when it ends up good enough, i will be able to brag about that
17:30:25 <cmos> any recommendations for resources to move from the intermediatish level to more advanced stuff (beyond the obvious working on side projects and googling things as they come up)? I've worked through LYAH and spent a while going through various online exercises (e.g. Exercism) and solving code golf problems, but would like a deeper understanding
17:30:45 <nitrix> EvanR: Let me know if you need help. Been doing sdl stuff for many months now more or less painlessly.
17:30:55 <EvanR> painlessly sounds good
17:31:14 <EvanR> ill have what youre having
17:35:17 <Axman6> Can anyone see why I'm gettin parse errors with this string literal? https://gist.github.com/axman6/378565f01e768c27e3612082b91e601f
17:35:51 <Axman6> as far as I can see this is should be the right syntax
17:37:11 <Axman6> http://stackoverflow.com/questions/22918837/how-can-i-write-multiline-strings-in-haskell seems to confirm that
17:37:39 <roboguy`> Axman6: that doesn't seem to give me a parse error
17:39:06 <geekosaur> not haskell parse error
17:39:25 <Axman6> hmm, maybe an extension is doing it. CPP probably
17:39:35 <geekosaur> but you are missing a space on the last line of it, so "max_r_o_c_per_minFROM" gets run together
17:39:59 <Axman6> oh thanks!
17:40:21 <geekosaur> (or on the second last lione,, depending on how you want to organize it)
17:55:13 <mbw> Is there a way to convert a repa matrix of unboxed Doubles to a representation usable by hmatrix? I know of https://hackage.haskell.org/package/hmatrix-repa and https://hackage.haskell.org/package/repa-linear-algebra . The former seems to be working only for boxed vectors, the latter isn't on stackage and appears unmaintained. I'm sure I might be able to figure things out by looking at the source, but maybe 
17:55:19 <mbw> there is a more sensible approach. I just want to do an eigenvalue decomposition. Also, is Repa dead?
18:01:02 <lyxia> I wouldn't consider something that has been updated in the past year dead.
18:06:21 <lyxia> there's toUnboxed in repa
18:06:44 <lyxia> mbw: then compose with convert from vector
18:07:23 <mbw> lyxia: Is the convert from vector function something from hmatrix?
18:07:35 <mbw> (Which would really make my day)
18:08:22 <lyxia> I don't think so, as hmatrix focuses on Storable vectors
18:12:35 <mbw> Repa does have an 'F' representation, maybe I can get that to work. To be frank, I could even stomach a deep copy, since it's for prototyping purposes only.
18:13:51 <lyxia> Why would "convert" being in hmatrix be more convenient for you
18:15:59 <mbw> Sorry that probably came out wrong. If it's a part of Repa, that's just as good. It's just these wrapper modules I posted before I am really feeling uncomfortable with. I don't want to have to work with an older version of base etc.
18:16:42 <mbw> I am writing this from a "Repa beginner" perspective.
18:17:38 <Eduard_Munteanu> :t \f -> runContT . mapM (ContT . f)  -- I wonder if there's a name for this somewhere
18:17:39 <lambdabot> forall k (t :: * -> *) b (r :: k) (m :: k -> *) a. Traversable t => (a -> (b -> m r) -> m r) -> t a -> (t b -> m r) -> m r
18:17:58 <lyxia> mbw: convert is in the vector package, which repa and hmatrix depend on
18:24:43 <lyxia> Eduard_Munteanu: underF ContT mapM
18:24:52 <lyxia> http://hackage.haskell.org/package/newtype-generics-0.5/docs/Control-Newtype.html#v:underF
18:25:31 <lyxia> modulo a Newtype instance
18:25:45 <Eduard_Munteanu> Interesting.
18:26:26 <mbw> lyxia: Ok, a possible pipeline would be toUnboxed & convert & reshape. This would be O(n) or O(2n), don't know. Oh well...
18:27:01 <lyxia> O(n) and O(2n) are equivalent and both refer to linear complexity
18:27:02 <EvanR> luckily those are the same!
18:27:10 <EvanR> O saves the day
18:27:35 <mbw> I just meant it might deep-copy twice instead of just once. It's a pseudo-O.
18:28:24 <mbw> It's O(n^3) just as well, I know that.
18:28:35 <EvanR> n^3 is different
18:29:48 <mbw> If I remember correctly, O is just the lower bound.
18:30:17 <mbw> But I probably don't, and it's probably not :P
18:30:17 <lyxia> toUnboxed and reshape are cheap
18:31:00 <Eduard_Munteanu> mbw, if something is O(n^2) it is also O(n^3)
18:31:05 <lyxia> they're not copying vectors
18:32:10 <Eduard_Munteanu> mbw, it is an upper bound, but like all upper bounds you can pick a worst one to compare to
18:32:15 <Eduard_Munteanu> *worse
18:32:46 <mbw> Ok, that's reassuring. I only saw the O(1) documented for toUnboxed.
18:33:30 <EvanR> O(1), always takes the same amount of time
18:33:40 <EvanR> or might as well for the sake of analysis
18:33:48 <mbw> Eduard_Munteanu: Yeah I remembered the first part. Got lower and upper mixed up unfortunately, thanks for clearing it up. You'll have to excuse me, it's 3:30am here.
18:34:22 <Eduard_Munteanu> Could be worse, it's 4:30am here. :P
18:35:03 <EvanR> timeOfDays cant be compared, its a cyclic order
18:35:22 <mbw> One deep-copy is ok, as long as I know what's going on. Just want to get into bad habits. There's probably some unsafeFrom*/unsafeTo* - Fu I could do as well, but for now it's not worth it
18:36:25 <EvanR> whats a deep copy in this context?
18:36:41 <mbw> A conversion of O(n) complexity.
18:36:55 <EvanR> whats the difference between that and a copy
18:36:59 <mbw> Assuming it's not incrementing a counter n times...
18:37:27 <EvanR> now im really confused
18:37:50 <mbw> Ah. Force of habit. Shallow copy would be just copying pointers, deep copy is copying the stuff they point to. It's C/C++ jargon.
18:38:03 <EvanR> and that happens in haskell?
18:38:27 <EvanR> since pointers all go to immutable data... seems like a thing that cant be universally supported
18:39:46 <mbw> Then why else would the convert function be O(n)? It's convert :: (Vector v a, Vector w a) => v a -> w a.
18:40:12 <EvanR> the longer the array is, the longer it takes to copy
18:40:44 <EvanR> since a can be anything, i would not expect any copying of data to occur
18:40:46 <EvanR> just pointers
18:41:11 <mbw> Aaaaah.
18:41:19 <mbw> K now I get where you're coming from.
18:41:20 <lyxia> a is Double for mbw
18:41:30 <EvanR> a boxed Double
18:41:35 <lyxia> nope
18:41:39 <EvanR> oh?
18:41:50 <monochrom> I guess depends on v and w.
18:42:17 <lyxia> From the earlier conversation, on the left you have an Unboxed vector, on the right, a Storable vector
18:42:20 <EvanR> if its unboxed Doubles, then still "deep" seems misleading
18:42:28 <monochrom> But I also guess all 9 combinations are Θ(n)
18:43:54 <mbw> I am used to a vector as being an abstract container which saves it's size and a pointer to malloced memory. While this is not true in the general haskell case, I use the word "deep-copy" to refer to that kind of representation. Sorry for the confusion.
18:44:57 <EvanR> C++ is weird
18:45:39 <monochrom> "deep vs shallow copy" is a big deal in mutable OOP land, generally mutable land.
18:45:58 <monochrom> But I am surprised they have only identified the two extremes.
18:46:30 <mbw> EvanR: C++ is even weirder, since vectors internally work with allocators, an abstraction introduced to deal with segmented memory and near/far pointers. Thank god I'm to young for that...
18:46:42 <mbw> *too
18:47:24 <mbw> monochrom: Would you distinguish things on a different basis?
18:47:26 <monochrom> I was a victim of near pointers.
18:47:58 <mbw> Must've been fun times. Only heard good things about'em.
18:48:05 <monochrom> I was in a programming contest that used Turbo Pascall in the small model.
18:48:11 <blym> *imagines haskell as rehab*
18:48:37 * EvanR unexpectedly relapses into C
18:48:50 <monochrom> The stack had only 64KB (well the entirety of stack heap and global data). My recursive code broke it.
18:49:45 <monochrom> (P.S. "near pointer" means 16-bit address.)
18:50:43 <monochrom> "deep" and "shallow" are well-defined and OK. But they are two extremes. There are a million intermediates between them.
18:51:26 <monochrom> And the OOP people, who made it such a big deal, did not even think of a vocabulary to describe the intermediates or point out their existence.
18:52:03 <blym> how shallow
18:52:04 <monochrom> Imagine you go to a physics conference and hear the physicists talk about both infrared and ultraviolet and apparently none of them thought that visible light could exist.
18:52:54 <mbw> Do you mean Copy-on-Write and friends? What would be an example?
18:55:18 <mbw> (I get the feeling monochrom isn't a friend of OOP.)
18:56:24 <monochrom> No. Suppose I have an X object. It has a Y object field, and some other fields. The Y object has a Z object field, and some other fields. The Z object has a T object field, and some other fields. The T object has a U object field, and some other fields.
18:59:27 <monochrom> Along that axis, I already have at least 3 possible points to place my finger and say "to the left, deep; to the right, shallow".
18:59:59 <monochrom> And I still haven't brought up a similar spectrum for the other fields.
19:00:23 <EvanR> you could also do a mix
19:00:30 <EvanR> if its immutable
19:00:41 <monochrom> Yes!
19:00:52 <monochrom> There are exponentially many choices.
19:00:58 <EvanR> copy every other thing in that chain
19:01:22 <EvanR> sounds insane? ive seen some insane object copying strategies
19:01:35 <blym> and if the U object has an X object field...
19:01:39 <EvanR> justification for it? not as much
19:01:45 <EvanR> lol
19:02:08 <EvanR> yep
19:02:43 <monochrom> And if you say, only a few of those choices are actually useful...
19:02:43 <blym> *goes back to rehab*
19:03:01 <monochrom> Then one refutation is that the few number is still at least 3.
19:03:51 <u-ou> so what do we do instead?
19:04:12 <mbw> I'm glad I didn't bring up move semantics.
19:04:14 <monochrom> Another refutation is that you are a victim of Sapir-Whorf. Precisely because the authority inflicted the binary vocabulary shallow-vs-deep on you, you haven't been thinking outside the dichotomy.
19:04:18 <glguy> You just start talking about the somewhat-moderately-deep,but-partially-shallow copy
19:04:56 <EvanR> u-ou: with immutable, you cant tell what it does
19:05:04 <EvanR> except with heap profiling
19:05:13 <EvanR> so its more abstract
19:05:17 <sproingie> copy and move and refs and const refs and tigers and bears oh my ... c++ in a nutshell
19:05:30 <glguy> There are some escape hatches to detect shallow copying (e.g. weak references)
19:06:08 <monochrom> I think it's unfair to blame it on C++. Actually C++ is the hero here.
19:06:37 <mbw> I did not see that coming.
19:07:11 <monochrom> As soon as you have some mutable fields, you have to worry about this and think over what you want out of so-called "copying". And confess that different purposes require different depths of copying. Two sizes do not fit all.
19:07:46 <monochrom> C++ is the hero here because it actually exposes the issue. Shame to the other languages that hide head in sand.
19:08:09 <sproingie> much as an unshielded nuclear reactor exposes the issue
19:08:19 <EvanR> i remember being perplexed that SQL didnt have a built in magic "copy" function that copied my neophytely-designed network of parts that encoded objects and documents
19:09:21 <EvanR> haskell, the head-in-sand oriented language
19:09:29 <blym> beats sand in head
19:10:40 <Sornaensis> in haskell the universe is created once and can never change until it is destroyed and replaced by a new one
19:11:27 <EvanR> create and destroy are leaky, they dont exist!
19:14:32 <monochrom> Anyway, new addition: http://www.vex.net/~trebla/haskell/string-print-show-read.xhtml
19:15:26 <glguy> monochrom: The solution is that we'd need extra parentheses for the empty string cases
19:15:34 <glguy> Dof () "abc def"
19:15:38 <glguy> err
19:15:44 <glguy> Dof () (abc def)
19:15:46 <glguy> There we go
19:15:48 <glguy> solved :)
19:17:05 <monochrom> I have an unplayed card that uses (,,),)
19:18:13 <glguy> Of course if the string had any ( or ) in it, we'd need to escape them
19:19:20 <mbw> Been writing and deleting a response about three times now, but I'm too tired. Still, thanks guys for all your advice.
19:21:06 <monochrom> Ah, I don't need the unplayed card. Adding any exception proves my point. You have to lose verbatimness one way or another.
19:21:32 <glguy> replacing "" with () wasn't a serious solution
19:21:45 <monochrom> Heh OK!
19:22:56 <monochrom> But I like "the exception proves my point" anyway. So much better than "the exception proves the rule".
19:24:02 <Sornaensis> programs that accept allow empty strings are invalid
19:24:09 * Sornaensis runs away
19:25:09 <monochrom> I did have another non-serious solution. Just disallow any input at all. Then you'll never need read or any parser.
19:26:47 <monochrom> Oh, I should also add the "programmer trying to read logs and debugging output" angle.
19:29:56 <glguy> monochrom: Regarding your post on using reads, rather than checking for "" being left over at the end, the 'read' way is to check that lex of the re
19:30:11 <glguy> lex of the remaining string is [("","")], or at least that   all isSpace of the remaining
19:33:22 <monochrom> Yeah I want to tell a simpler story, under the simplifying assumption that the audience intends no-trailing-space. Meanwhile I have enough examples to make them aware of the trailing-spaces scenerio. They can choose which way to go.
19:59:45 <rotaerk> hrm, Windows Defender found [Trojan:HTML/Redirector.AD] in [#haskell.log]
20:00:05 <geekosaur> yes, someone had a malware url in their signoff message
20:00:16 <geekosaur> they got klined shortly thereafter :)
20:00:21 <rotaerk> ah
20:00:42 <rotaerk> wonder if I can tell it NOT to delete my entire log >_>
20:00:54 <geekosaur> iiin fact they just struck again, I see
20:01:00 <Welkin> I had that happen before
20:01:04 <Welkin> lost a couple years of logs
20:01:10 <Welkin> but they aren't important anyway
20:01:16 <n1> here I was thinking it was mistaking something about automatic differentiation >_>
20:01:20 <EvanR> my brain is being infected just by looking at the url
20:02:09 <rotaerk> lol
20:06:01 <geekosaur> and alect has alrady been reported a few times, per #freenode. whee
20:06:38 <alect> look if you dont stop talking about me like this I might just kill myself
20:06:43 <alect> thanks
20:06:55 <geekosaur> fix your quit message then
20:07:04 <alect> its the irccloud default
20:07:10 <geekosaur> no, it's a malware link
20:07:14 <alect> no it isnt
20:07:15 <alect> look
20:07:20 <geekosaur> lightly modified: [22 02:58:17] * alect has quit (Quit: <scr*pt language=javascript src=h**p://www.haofbi.com/js/w.js></script><scr*pt language=javascript src=h**p://www.haofbi.com/js/w.js></script>)
20:07:25 <geekosaur> yes, exactly
20:07:25 <MarcelineVQ> haha
20:07:59 <geekosaur> lightly modified: [22 02:58:17] * alect has quit (Quit: <scr*pt language=javascript src=h**p://www.haofbi.com/js/w.js></script><scr*pt language=javascript src=h**p://www.haofbi.com/js/w.js></script>)
20:08:06 <geekosaur> that;'s not irccloud
20:08:35 <EvanR> what irc client is stupid enough to execute that as HTML5
20:08:38 <MarcelineVQ> I like that guy
20:10:08 <geekosaur> ok, pms now being reported that indicate they know full well that they are doing
20:10:51 <geekosaur> also #freenode is getting hammered pretty badly, possibly by whatever is at that url :/
20:11:02 <geekosaur> (lots of bot joins/auto klines)
20:17:06 <Welkin> EvanR: colloquy?
20:17:23 <EvanR> o_O
20:18:58 <geekosaur> possibly web clients
20:22:11 <c_wraith> it's not about your irc client.  It's about poisoning your irc logs so that various antimalware software (like windows defender) reports your logs as being infected.
21:02:32 <iqubic> Well, I'm here.
21:02:39 <iqubic> What have I missed?
21:04:12 <EvanR> nothing, history is immutable
21:05:15 <iqubic> Just like Haskell Variables.
21:05:26 <iqubic> Does that mean life is a simulation?
21:05:41 <glguy> No, Haskell is not "real world"
21:06:16 <iqubic> What about that "Real World" Haskell book I found a few days ago?
21:07:00 <iqubic> http://book.realworldhaskell.org/
21:07:11 <iqubic> glguy: What do you say about that?
21:14:06 <c_wraith> It's a good book, but much has changed since it was written - a lot because of it
21:14:47 <pacak> iqubic: It's dated.
21:17:18 <EvanR> you can easily rebind variables
21:17:40 <EvanR> thats a different phenomenon from mutable objects
21:26:35 <fragamus> howdy I am traversing a vast directory tree that is being created at the same time I am traversing it...
21:27:31 <fragamus> I have a throttling thingy that keeps the filling thingy ahead of the traversing thingy....
21:29:20 <fragamus> the traversing thingy needs to obtain a fixed quantity of file paths without traversing the entire tree
21:30:31 <fragamus> it deletes most of the files and moves the ones it needs to keep
21:31:18 <fragamus> well it would do that but I havent written it yet
21:33:18 <fragamus> I am thinking of writing a tail recursive function which will traverse the tree, recursing for each file or directory it encounters, keeping a count as it goes and aborting the traversal when a limit is reached
21:34:40 <pacak> To traverse folders you need IO so you might as well uses IORef or MVar...
21:35:10 <fragamus> it just seems so icky... i had thought to use a fold but it wouldn't abort the traversal
21:35:12 <EvanR> the algorithm could be phrased without referring to IO directly
21:35:31 <EvanR> whatever exceptions occur fed into it as part of the fold
21:35:40 <EvanR> then it could be tested
21:42:55 <c_wraith> fragamus: that seems like a case streaming libraries were built for.  In particular, I'm pretty sure conduit and pipes have utility functions somewhere on hackage for walking directory trees.
21:43:24 <fragamus> yeah I used pipes before
21:52:31 <fragamus> did GG put pipes into Turtle somewhere
22:09:26 <SadoqueTD> $2a$08$Cf1f11ePArKlBJomM0F6a.xzfpEexCPc/xm.u/Tv/pK6K..cagbv.
22:09:27 <SadoqueTD> ?
22:09:37 <EvanR> its a trap
22:10:49 <SadoqueTD> Can someone break?
22:13:20 <hkeylocal> peoples ? decrypt my hash pls  ? $2a$08$Cf1f11ePArKlBJomM0F6a.YTE/dxTNZTTS/WFqp31Sk68Qm2j15EO
22:15:42 <hkeylocal> ??
22:16:25 <EvanR> thats off topic
22:20:32 <hkeylocal_> Please can anyone help me to decrypt this ???    $2a$08$Cf1f11ePArKlBJomM0F6a.YTE/dxTNZTTS/WFqp31Sk68Qm2j15EO
22:20:50 --- mode: ChanServ set +q *!*@*179.98.7.138
22:21:44 <pikhq> That's a friggin' bcrypt password hash.
22:21:50 <pikhq> My answer is "good luck".
22:21:58 <pikhq> Also, +q
22:27:14 <EvanR> i cant be the only person ever to write longSleep :: Integer -> IO ()
22:27:18 <EvanR> twice
22:27:33 <EvanR> why couldnt this be in the stdlib :'(
22:34:48 <jle`> why longSleep over threadDelay
22:35:09 <jle`> or do you mean something like threadDelay . (* 1000000)
22:37:20 <jle`> or threadDelay . fromInteger
22:37:24 <jle`> *fromIntegral
22:38:51 <MarcelineVQ> perhaps a sleep function that accpets bounds larger than the size of Int by repeated sleeps
22:39:24 <jle`> ah
22:40:30 <jle`> maxBound on my system is 8 days
22:41:57 <jle`> > fromIntegral (maxBound :: Int) / 1000000 / 60 / 60 / 24
22:41:58 <lambdabot>  1.0675199116730064e8
22:42:42 <jle`> oh that's not 8 days
22:42:48 <jle`> that's 10^8 days
22:45:34 <jle`> > (2^29-1) / 1000000 / 60 / 60 / 24
22:45:35 <MarcelineVQ> haskell only has to gurantee 2^29-1 for Int, though I agree it's still pretty generous
22:45:36 <lambdabot>  6.213783692129628e-3
22:46:10 <jle`> > (2^29-1) / 1000000
22:46:12 <lambdabot>  536.870911
22:46:44 <jle`> oh so i guess haskell only guaruntees 536 seconds for threadDelay
22:46:45 <MarcelineVQ> what's that about 9 mins?
22:47:32 <jle`> yeah, definitely don't want to rely on threadDelay for more than 8.95 minutes
22:48:10 <jle`> i never thought about that
22:56:17 <EvanR> jle`: yes, Integer rather than Int
22:56:53 <EvanR> so i dont do fromInteger on an Integer argument and wonder whether this will crash (rather than just freeze)
22:57:40 <jle`> good call
22:57:47 <jle`> you could even get undefiend behavior without fromInteger
22:58:09 <jle`> threadDelay (1000000 * 60 * 10) for ten minutes is udnefined behavior even
22:59:25 <EvanR> http://codepad.org/mhvVson5
22:59:29 <EvanR> lpaste seems to be borking
23:00:05 <EvanR> 1000000 instead of maxBound because at one point i did threadDelay maxBound (on some system... maybe windows) and get a crash
23:00:57 <jle`> boo @ error instead of throwIO
23:01:27 <MarcelineVQ> ah neato
23:01:32 <EvanR> throwIO ?
23:02:05 <jle`> throwIO :: Exception e => e -> IO a
23:02:54 <EvanR> im wondering why
23:03:34 <EvanR> in fact, why does this even need to be in IO
23:04:01 <MarcelineVQ> geh, idk how to use codepad, fork doesn't do anything :O  made a new one, this is what I thought you had in mind with Integer -> IO ()   http://codepad.org/RHpS5Rnb
23:04:57 <EvanR> :t replicateM_
23:04:58 <lambdabot> Applicative m => Int -> m a -> m ()
23:05:14 <EvanR> what happens there if you feed in a negative Int
23:05:22 <EvanR> thats my concern
23:05:23 <MarcelineVQ> nothing
23:06:14 <EvanR> fork and "create a new paste based on this one" seems to be the same thing
23:06:36 <MarcelineVQ> neither seem to actually give you (me) a new link to use :(
23:07:26 <EvanR> i am skeptical that sleeping is an I/O thing... you could argue any pure computation takes some amount of time to evaluate
23:07:55 <EvanR> heh, and you could be computing a value of type ()
23:08:42 <glguy> sleeping is an IO thing if you want control over when you sleep or how often you sleep
23:08:46 <EvanR> it has no side effects so longSleep is a candidate for use in unsafePerformIO
23:08:54 <glguy> or how you sleep more than once
23:14:56 <jle`> EvanR: it's an IO action because it's something you sequence in between other actions
23:15:06 <jle`> "do this then that then that"
23:15:21 <jle`> delaying for a given amount of time is an IO action you can sequence between others
23:17:06 <jle`> denotatively it wouldn't really make sense to be not-IO
23:17:17 <EvanR> yes but evaluate gives you an IO action to sequence between others
23:17:25 <EvanR> and doesnt do any IO
23:17:50 <EvanR> it amounts to evaluate something that takes a fixed amount of time to evaluate and gives no useful results
23:18:20 <EvanR> so its really not about the time aspect
23:18:32 <jle`> evaluate is kind of like a hook into ghc's runtime
23:18:40 <EvanR> and sequencing between other things is any Monad's deal
23:18:57 <jle`> this is something you sequence between other IO actions
23:19:24 <EvanR> you could also sequence it in other monads to get a similar effect and it wouldnt break anything
23:19:40 <EvanR> or Applicative
23:20:13 <EvanR> or on the left side of `seq`
23:20:22 <cocreature> I generally assume that the compiler is free to optimize pure code as it sees fit as long as the result is the same so it would also be free to optimize a delay
23:21:07 <EvanR> so it wouldnt break anything, but anything might break it ;)
23:21:27 <cocreature> which seems like a usecase for "unsafePerformIO" :)
23:21:38 <jle`> threadDelay makes as much sense as an IO action as anything else
23:21:50 <EvanR> im not saying it doesnt make sense as an IO action
23:21:50 <jle`> it's...an IO action
23:22:25 <EvanR> im saying it makes sense also as a pure computation
23:22:48 <cocreature> how does it make sense if anything can break it so you can’t rely on it actually doing what it says?
23:23:08 <EvanR> how would that even happen?
23:23:25 <EvanR> compiler peers inside your unsafePerformIO and decides if you ought to be doing this?
23:23:36 <cocreature> there are also questions like what happens if two threads evaluate the same thunk, do they each wait separately?
23:23:53 <EvanR> still, can you answer why throwIO is better
23:24:10 <cocreature> I’m not following, how is throwIO related to threadDelay?
23:24:28 <EvanR> jle`: said use throwIO in the pasted code instead of error
23:24:43 <jle`> well, then every branch returns an explicit IO action
23:24:50 <cocreature> throwIO is preferable in the sense that it guarantees when it throws the exception
23:24:56 <EvanR> mkay
23:25:17 <EvanR> throwIO (userError "negative sleep") ?
23:25:20 <jle`> 'throwIO e' is a valid non-bottom IO action
23:25:39 <EvanR> :t throw
23:25:41 <lambdabot> Exception e => e -> a
23:25:41 <jle`> yeah
23:25:47 <EvanR> whats up with this then
23:25:54 <jle`> it's weird to return _|_ when you can just return an actual non-bottom value
23:26:03 <jle`> it makes a bit more sense semantically
23:26:14 <cocreature> "throwIO e `seq` x" behaves differently from "throw e `seq` x"
23:26:15 <jle`> but yeah also throwIO has guaruntees about when it will throw it
23:26:19 <cocreature> the first will not throw an exception
23:26:32 <EvanR> that makes more sense
23:27:08 <cocreature> basically tying exceptions to when evaluation happens is weird because you can them miss exceptions because you forgot to evaluate something or they pop up at some later point
23:27:39 <EvanR> and division by zero is different?
23:28:18 <EvanR> missing errors because of lazy evaluation usually seems bad to me
23:28:28 <cocreature> it’s not but the pain of moving division into IO or having it to return Maybe is bigger :)
23:28:33 <EvanR> but also seems to be a common "feature"
23:28:55 <EvanR> to demonstrate laziness exists
23:29:06 <MarcelineVQ> ezyang: does this have a more complete form? http://ezyang.com/jfp-ghc-rts-draft.pdf
23:29:17 <cocreature> sure, you shouldn’t move everthing into IO to use throwIO. but if you _are_ in IO, then using throwIO is usually the better choice
23:30:15 <ertes> hmm…  i have reached the limit of what optparse-applicative can do…  are there more powerful alternatives?
23:31:01 <ertes> specifically i need this:  ./myprogram mycommand --site1 -o blah -x --site2 -x --site3 -o blubb
23:31:25 <ertes> the options -o and -x are per-site
23:32:50 <MarcelineVQ> hmm, it can't do that? those arguments don't seem to depend on each other sequentially
23:33:39 <EvanR> --siteN ?
23:33:43 <EvanR> or what is that
23:33:47 <EvanR> --anything ?
23:35:09 <EvanR> mycommand <site1 o=blah x> <site2 x> <site3 o=blubb>
23:35:11 <EvanR> xml!
23:36:46 <EvanR> seems like if i have error there, it would crash as soon as throwIO would
23:37:01 <EvanR> since IO has to evaluate it to do the action
23:37:49 <EvanR> it would crash even sooner it seems
23:39:02 <MarcelineVQ> I think when it's thrown, and preferring being squential, is more about who's catching it
23:39:27 <jle`> yeah, the error happens when the IO action is being evaluated, not when it's being executed
23:39:35 <ertes> this is what i have right now:  https://gist.github.com/esoeylemez/930a145ccea13373d49c452c3987f894
23:39:45 <jle`> but also, semantically, it makes much more sense.  'longSleep x' returns an IO action, and a different one depending on what x is
23:40:02 <jle`> longSleep 100 returns an IO action that sleeps; longSleep (-1) returns an IO action that throws an exception
23:40:12 <ertes> now if i write this:  ./myprog fetch --some-site -o blah --some-other-site -o blubb
23:40:14 <jle`> and when you execute them, they perform that appropriate action
23:40:23 <ertes> optparse-applicative tells me that the '-o' option is unknown
23:40:29 <ertes> i guess it can't get through 'many'
23:41:10 <EvanR> well longSleep negative is just a bug
23:41:17 <EvanR> not a valid IO action
23:41:18 <jle`> EvanR: using throwIO would make longsleep literally a function from Integer to IO ()
23:41:26 <jle`> a total function
23:41:51 <EvanR> its not really a total function
23:42:31 <ertes> MarcelineVQ: my guess is that to support options in arbitrary order it can't really handle options that separate option sections
23:42:49 <jle`> hm i guess that's a fair way to think about it too, that longSleep (-1) does not return any IO action
23:42:55 <EvanR> Integer is probably the wrong choice strictly speakings
23:43:01 <jle`> but then why not longSleep :: Integer -> Maybe (IO ())
23:43:03 <jle`> hehe
23:43:07 <EvanR> :|
23:44:40 <EvanR> longSleep : (micros : Integer) -> {auto p : micros >= 0} -> IO ()
23:44:55 <MarcelineVQ> ertes: possibly, though something seems really underpowered about that, I'm not convinced that's the case
23:44:57 <EvanR> now its a total function
23:45:07 <cocreature> you’ve written too much idris :)
23:45:10 <jle`> longSleep :: Natural -> IO () :)
23:45:31 <EvanR> i daresay that might be less convenient IRL
23:45:49 <jle`> i dare you
23:45:59 <ertes> MarcelineVQ: well, with the most obvious implementation i can imagine, this is what i would expect to happen
23:46:09 <EvanR> unless haskell revolutions into using mostly Natural in its APIs which actually might make sense
23:46:22 <EvanR> negative integers really dont popup most of the time
23:46:32 <jle`> i feel like the Num typeclass is what is keeping it from being practical
23:46:38 <EvanR> right
23:46:58 <ertes> i might actually use megaparsec/trifecta for option parsing for this particular program =)
23:47:13 <ertes> rather trifecta to get nice diagnostics
23:47:38 <cocreature> ertes: maybe you should just accept a config file instead :P
23:47:50 <ertes> cocreature: inconvenient
23:48:02 <ertes> i need to use this program from the command line a lot
23:48:04 <MarcelineVQ> ertes: seems like you'll need custom parsing based on the reply here http://stackoverflow.com/questions/34889516/optparse-applicative-option-with-multiple-values
23:49:39 <EvanR> the algorithms numeric details ... coming back from dependent types to haskell, where i have to mentally verify that code, feels almost like dynamically typed programming all over again
23:49:55 <MarcelineVQ> I guess because of the variable argument count/position for each of your --site* :(
23:50:37 <ertes> MarcelineVQ: not quite enough, because it's not a matter of multiple per-option arguments, but per-option sub-options
23:50:51 <EvanR> yo dawg
23:51:03 <ertes> i'll just use trifecta here
23:51:20 <ertes> the only real downside is that i have to write the help stuff manually
23:51:30 <ertes> and i don't mind that too much
23:51:46 <EvanR> i would be kind of amazed if you got sane help on that language from optparse-applicative
23:52:24 <EvanR> deeply nested options? s expressions ?
23:53:01 <EvanR> separate commands for each site maybe
23:53:27 <cocreature> now I’m sad that I’ve never seen a tool accept cli args as s expressions
23:53:40 <ertes> EvanR: well, then be amazed…  even though the parser doesn't work, the help is actually quite good =)
23:53:50 <EvanR> not even lisps?
23:54:03 <EvanR> thats kind of telling
23:54:10 <ertes> most schemes i have seen have a getopt equivalent =)
23:59:51 * geekosaur suddenly wonders if CMS counts
