00:00:48 <Cale> Well, the stuff compiled with GHCJS can call out to other Javascript code
00:01:10 <iqubic> ertes: you got that example using the vector library?
00:01:38 <Cale> (and the stuff using JSaddle can run Javascript code as well, though that bit works a little different)
00:02:33 <Cale> kellytk: this is quite a good talk given by Ryan about reflex and reflex-dom https://www.youtube.com/watch?v=dOy7zIk3IUI
00:02:48 <Cale> He builds a little twitter client as an example
00:03:17 <kellytk> Cale: Thank you for your time you've been generous with it.  My last question for now, what are the 2 primary downsides to writing and running Haskell other than gaps in existing libraries
00:03:35 <kellytk> Thank you I look forward to watching it
00:03:58 <ertes> iqubic: i'm writing it
00:04:17 <iqubic> Got it. I'll wait.
00:05:13 <Cale> kellytk: 1) Compile times on large projects can be long -- there's stuff which can be done to mitigate that effect while developing, but for a real optimised build, our compile times are often pretty crazy. I think a full deployment on our largest project (including building the mobile apps, as well as the backend and web frontend) takes us about an hour now.
00:06:13 <Cale> The lion's share of that is due to our use of Template Haskell -- TH in GHCJS is quite slow, since it spins up a node instance to execute Javascript at compile time.
00:07:28 <ertes> iqubic: http://lpaste.net/354605
00:08:12 <ertes> iqubic: unlike the list traversal this one does not use recursion on the vector itself, but on a running index
00:08:38 <iqubic> I see.
00:08:45 <iqubic> I was thinking I'd do that too.
00:08:54 <Cale> 2) I dunno -- maybe the general fact that Haskell is pretty different, and so if you're new to it, you're going to need to relearn stuff like how to spot and deal with various performance issues, even once you have a good handle on the language.
00:09:15 <iqubic> ertes: I don't know what I'd do for the pure part at the end though.
00:09:47 <ertes> iqubic: look how i'm building a vector from scratch starting with the empty one
00:10:10 <iqubic> Why are you doing that? Isn't that bad??
00:10:21 <ertes> iqubic: look at the title of that paste =)
00:10:27 <Cale> I suppose an alternative to #2 is that the stuff in this particular area is all quite new and moving fast, and so the documentation is not as good as one would really hope in various places.
00:10:34 <iqubic> Ah.
00:10:44 <ertes> iqubic: it's bad for vectors, but it will be good for Word64 bits
00:10:49 <Cale> You will end up grepping source code more often than you might care to do.
00:10:51 <iqubic> I see.
00:11:53 <Cale> kellytk: We are hoping to work on that soon though, and there are some people starting to write reflex-dom documentation for us :)
00:12:07 <iqubic> I have just a little bit more of an idea how to do this traversal.
00:12:29 <ertes> iqubic: take your time…  this one is quite challenging
00:12:56 <iqubic> I will take my time.
00:13:02 <Cale> http://reflex-frp.readthedocs.io/en/latest/ -- Divam wrote some user contrib docs... I haven't even had the time to really read them, but it's good that people are getting into it. I feel a bit guilty for not actually doing this myself. :)
00:13:29 <iqubic> What is the type signature again?
00:13:32 <ertes> iqubic: if you can write this one, you can write any traversal you want =)
00:13:38 <iqubic> Really?
00:13:42 <ertes> bitsWord64 :: (Applicative f) => (Bool -> f Bool) -> Word64 -> f Word64
00:14:11 <iqubic> Do I import Data.Word?
00:14:19 <ertes> yeah, you need it for Word64
00:14:34 <iqubic> Cool
00:14:45 <iqubic> And do I need ot import Data.Bits?
00:15:01 <iqubic> *to
00:15:16 <ertes> if you want to write it in terms of clearBit/setBit/testBit, then yes
00:15:42 <iqubic> I will do that
00:16:18 <kellytk> Cale: Oh is Reflex your project?  You said Haskell can generate JS, can it also generate TypeScript?
00:16:39 <Cale> kellytk: I don't believe there's a typescript backend for GHC -- at least I haven't heard about one
00:16:46 <iqubic> Cale, did you help make Reflex
00:16:48 <iqubic> ??
00:17:40 <ertes> iqubic: one challenging aspect of this is that the compiler will not help you as much as it did with traverseFst…  there is in fact an enormous number of functions that fit this signature, only one of which is correct
00:17:45 <Cale> iqubic: only a very small amount -- basically I worked with Ryan on some earlier FRP systems (an arrowized system that we used on a gamedev project back in 2011-2012), and we figured out a lot of things about how we wanted our FRP system to work
00:18:10 <ertes> @djinn (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
00:18:10 <lambdabot> Error: Class not found: Functor
00:18:16 <ertes> really?
00:18:16 <iqubic> ertes: I will try to get something that will work
00:18:40 <Cale> iqubic: and then a few years later, Ryan started working on a new FRP system (which eventually became Reflex), and it has a bunch of features of the design of our earlier system
00:18:47 <ertes> @djinn (forall a b. (a -> b) -> f a -> f b) -> (a -> f b) -> (a, c) -> f (b, c)
00:18:48 <lambdabot> -- f cannot be realized.
00:18:53 <MarcelineVQ> ertes: exferenceBot can write that for you if you wanted it to be shown
00:18:56 <ertes> lambdabot: come on…
00:18:56 <Cale> iqubic: I've contributed a very very small amount of code to reflex and reflex-dom
00:19:08 <Cale> iqubic: Mostly my job just involves using those. :)
00:19:11 <ertes> MarcelineVQ: how do i talk to it?
00:19:14 <MarcelineVQ> :exf (Functor f) => (a -> f b) -> (a, c) -> f (b, c)
00:19:14 <exferenceBot> \ f1 b -> let ((,) d e) = b in fmap (\ h -> (h, e)) (f1 d)
00:19:20 <ertes> ah
00:19:25 <iqubic> what does exferenceBot do?
00:19:37 <kellytk> Cale: Thanks for your help
00:19:46 <ertes> it does what djinn is supposed to do =)
00:19:54 <ertes> :exf a -> b -> a
00:19:54 <exferenceBot> parse error: more than one input
00:19:55 <iqubic> LOL.
00:20:03 <Cale> kellytk: no problem, if you end up getting interested in playing with reflex, there's a #reflex-frp on this IRC network
00:20:12 <ertes> the bots don't like me today
00:20:15 <MarcelineVQ> bad luck tonight
00:20:16 <iqubic> Nope
00:20:27 <iqubic> :exf a -> b -> a
00:20:28 <exferenceBot> parse error: more than one input
00:20:38 <ertes> @djinn a -> b -> a
00:20:39 <lambdabot> f a _ = a
00:20:46 <iqubic> :exf a -> b -> (a -> b)
00:20:46 <exferenceBot> parse error: more than one input
00:21:27 <ertes> iqubic: given a type, @djinn writes a function of that type, if possible
00:21:59 <Myrl-saki> @djinn Int -> Int
00:21:59 <lambdabot> Error: Undefined type Int
00:22:02 <Myrl-saki> Oh.
00:22:12 <iqubic> Oh. I see.
00:22:19 <ertes> @djinn ((a -> b) -> f a -> f b) -> (a -> f b) -> (a, c) -> f (b, c)
00:22:19 <lambdabot> -- f cannot be realized.
00:22:30 <ertes> lambdabot: come on…  that one is easy!
00:22:40 <ertes> ah, no
00:22:47 <Myrl-saki> @djinn Functor f => (a -> b) -> f a -> f b
00:22:48 <lambdabot> Error: Class not found: Functor
00:22:57 <ertes> @djinn ((a -> (b, c)) -> f a -> f (b, c)) -> (a -> f b) -> (a, c) -> f (b, c)
00:22:58 <lambdabot> -- f cannot be realized.
00:23:13 <ertes> @djinn ((b -> (b, c)) -> f b -> f (b, c)) -> (a -> f b) -> (a, c) -> f (b, c)
00:23:13 <lambdabot> f a b (c, d) = a (\ e -> (e, d)) (b c)
00:23:15 <ertes> there we go
00:23:18 <ertes> a = fmap
00:23:39 <ertes> djinn can't handle higher-rank types?
00:23:45 <iqubic> I am having a lot of trouble witht the traversal into the Bits of a Word64
00:24:08 <ertes> @djinn (forall x y. (x -> y) -> f x -> f y) -> (a -> f b) -> (a, c) -> f (b, c)
00:24:08 <lambdabot> -- f cannot be realized.
00:24:14 <ertes> apparently not
00:24:33 <iqubic> I can't seem to get this traversal to work correctly.
00:24:34 <ertes> iqubic: if you can't figure it out, take a break
00:24:57 <ertes> let everything sink in for a while
00:25:06 <iqubic> I will try it again later.
00:25:22 <iqubic> Is it super hard???
00:25:32 <ertes> iqubic: not super-hard, but it's definitely challenging
00:25:39 <Myrl-saki> Would it be smart to have 2 compilations? Compile everything except main, then have a specialized compilation for main, which links the function calls?
00:25:56 <ertes> iqubic: i can give you super-hard ones, after you solved this one =)
00:25:56 <iqubic> No.
00:25:58 <Myrl-saki> Not smart.
00:26:08 <Myrl-saki> I mean, would it be a good idea.
00:26:08 <iqubic> ertes: I want to solvle this first.
00:27:34 <MarcelineVQ> what sig are we implementing?
00:27:48 <iqubic> @let x = traverse setBit [1..10]
00:27:50 <lambdabot>  Defined.
00:27:54 <iqubic> > x 0
00:27:56 <lambdabot>  error:
00:27:57 <lambdabot>      Ambiguous occurrence ‘x’
00:27:57 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
00:27:59 <ertes> MarcelineVQ: bitsWord64 :: (Applicative f) => (Bool -> f Bool) -> Word64 -> f Word64
00:28:10 <ertes> MarcelineVQ: a traversal into the individual bits of Word64
00:28:32 <iqubic> > (traverse setBit [1..10]) 0
00:28:34 <lambdabot>  [1,3,3,5,5,7,7,9,9,11]
00:28:37 <iqubic> > (traverse setBit [1..10]) 1
00:28:40 <lambdabot>  [3,2,3,6,7,6,7,10,11,10]
00:28:44 <iqubic> What is that doing?
00:28:47 <iqubic> > (traverse setBit [1..10]) 2
00:28:50 <lambdabot>  [5,6,7,4,5,6,7,12,13,14]
00:28:58 <iqubic> I don't understand that at all.
00:29:03 <Myrl-saki> :t traverse
00:29:05 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
00:29:16 <iqubic> :t setBit
00:29:17 <lambdabot> Bits a => a -> Int -> a
00:29:19 <ertes> iqubic: you're using the following Applicative instance:  instance Applicative ((->) a)
00:29:28 <iqubic> Sure am.
00:29:34 <iqubic> So what is it doing
00:29:42 <iqubic> :t x
00:29:44 <lambdabot> error:
00:29:44 <lambdabot>     Ambiguous occurrence ‘x’
00:29:44 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
00:29:52 <ertes> > (f <*> g) x = f x (g x)
00:29:54 <lambdabot>  <hint>:1:13: error:
00:29:54 <lambdabot>      parse error on input ‘=’
00:29:54 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
00:29:55 <ertes> whoops
00:29:58 <ertes> (f <*> g) x = f x (g x)
00:30:09 <ertes> iqubic: that's the semantics of this particular instance
00:30:14 <iqubic> Oh, I see.
00:30:21 <Myrl-saki> Ah. Reader.
00:30:26 <ertes> liftA2 (+) sin cos x = sin x + cos x
00:30:46 <ertes> iqubic: we call these reader monads =)
00:30:50 <iqubic> I see.
00:30:56 <iqubic> That's cool
00:31:07 <Myrl-saki> (Also called as the "please don't use this monad")
00:31:32 <ertes> or at least: don't abuse this monad for point-free style
00:31:35 <iqubic> I just figured out how to do this thing.
00:31:44 <Myrl-saki> ertes: I love the applicative instance though!
00:31:50 <iqubic> I think I figured out how to do the thing.
00:32:06 <iqubic> does the number 0 count as a word64?
00:32:15 <ertes> iqubic: sure
00:32:22 <ertes> it's 64 bits of 0
00:32:32 <iqubic> Cool.
00:32:36 <iqubic> That helps me.
00:33:17 <kellytk> Cale: What do you use to run Haskell apps on iOS?
00:33:38 <iqubic> > pure 0
00:33:41 <lambdabot>  error:
00:33:41 <lambdabot>      • Ambiguous type variables ‘f0’, ‘a0’ arising from a use of ‘show_M73440...
00:33:41 <lambdabot>        prevents the constraint ‘(Show (f0 a0))’ from being solved.
00:33:56 <iqubic> I don't think that's right.
00:34:07 <ertes> > pure 0 :: [Integer]
00:34:08 <iqubic> > pure 0 :: Int
00:34:10 <lambdabot>  [0]
00:34:10 <lambdabot>  error:
00:34:10 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘f0 Integer’
00:34:10 <lambdabot>      • In the expression: pure 0 :: Int
00:34:28 <iqubic> > pure 0 :: [Int]
00:34:30 <lambdabot>  [0]
00:34:52 <iqubic> Does Word64 have a pure function?
00:35:00 <Myrl-saki> No.
00:35:04 <Myrl-saki> It's not a Functor.
00:35:06 <ertes> 'pure' is unrelated to Word64 here
00:35:36 <iqubic> but how does our traversal return an f Word64?
00:35:37 <ertes> iqubic: but Identity and (Const a) have 'pure'
00:35:46 <Myrl-saki> :k Functor
00:35:47 <lambdabot> (* -> *) -> Constraint
00:35:54 <ertes> iqubic: using 'pure'
00:36:09 <ertes> you do need it, but it has nothing to do with Word64
00:36:13 <iqubic> but Word64 is not a functor?
00:36:20 <iqubic> What the heck is going on here???
00:36:21 <ertes> f is a functor
00:36:32 <ertes> look at the type signature again
00:36:38 <iqubic> yes, but of what type??
00:36:49 <iqubic> What kind of functor do I use here?
00:36:50 <ertes> f *is* a type
00:37:00 <ertes> you don't get to choose the functor
00:37:04 <iqubic> I don't
00:37:05 <ertes> all you know is that f is Applicative
00:37:09 <iqubic> right.
00:37:20 <iqubic> So I can use pure and have it work??
00:37:21 <ertes> that means you can use 'pure'
00:38:23 <iqubic> How do I create a Word64?
00:38:34 <Myrl-saki> > 0 :: Word64
00:38:36 <ertes> > 0 :: Word64
00:38:37 <lambdabot>  0
00:38:39 <lambdabot>  0
00:38:39 <ertes> hehe
00:38:41 <Myrl-saki> ertes: :D
00:39:04 <ertes> iqubic: Word64 is a Num and a Bits
00:39:09 <iqubic> LOL.
00:39:13 <iqubic> I see now.
00:40:52 <iqubic> This is hard. Can you just give me the solution?
00:41:47 <iqubic> Actually, don't do that. I like the challenge
00:42:27 <Myrl-saki> > me when trying to understand monads
00:42:30 <lambdabot>  error:
00:42:30 <lambdabot>      Ambiguous occurrence ‘trying’
00:42:30 <lambdabot>      It could refer to either ‘Control.Exception.Lens.trying’,
00:42:50 <iqubic> Myrl-saki: Do you understand monads?
00:42:53 <Myrl-saki>  > does it trigger with a space before it?
00:42:59 <Myrl-saki> Phew.
00:43:03 <Myrl-saki> iqubic: Now I do.
00:43:15 <MarcelineVQ> ​> space
00:43:32 <Myrl-saki> MarcelineVQ: H o w
00:43:36 <Myrl-saki> MarcelineVQ: NBSP?
00:43:45 <iqubic> I don't understand traversals at all.
00:43:46 <Myrl-saki> MarcelineVQ: Unprintable unicode?
00:44:07 <ertes> iqubic: i'm gonna give you the solution, but it will not help you, because i write it the ertes way =)
00:44:27 <ertes> :t foldr (\i go -> (\b y -> (if b then setBit else clearBit) y i) <$> f (testBit x i) <*> go) (pure 0) [0..63]
00:44:28 <lambdabot> error:
00:44:29 <lambdabot>     Ambiguous occurrence ‘x’
00:44:29 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.x’,
00:44:38 <ertes> :t \f x -> foldr (\i go -> (\b y -> (if b then setBit else clearBit) y i) <$> f (testBit x i) <*> go) (pure 0) [0..63]
00:44:39 <iqubic> Is that the solution??
00:44:40 <lambdabot> (Num b, Bits a, Bits b, Applicative f) => (Bool -> f Bool) -> a -> f b
00:44:49 <ertes> that's my solution =)
00:44:57 <Myrl-saki> ertes: lmao
00:45:01 <iqubic> But it doesn't have the right type.
00:45:07 <ertes> it does =)
00:45:19 <ertes> @let bitsWord64 :: (Applicative f) => (Bool -> f Bool) -> Word64 -> f Word64; bitsWord64 f x = foldr (\i go -> (\b y -> (if b then setBit else clearBit) y i) <$> f (testBit x i) <*> go) (pure 0) [0..63]
00:45:20 <iqubic> so a is the same type as b?
00:45:20 <lambdabot>  Defined.
00:45:22 <Myrl-saki> lambdabot: Can I try it out myself?
00:45:24 <ertes> :t bitsWord64
00:45:26 <lambdabot> Applicative f => (Bool -> f Bool) -> Word64 -> f Word64
00:45:33 <ertes> iqubic: ^
00:45:40 <Myrl-saki> ertes: Can I try it out myself?
00:45:47 <iqubic> How does that work?
00:45:52 <iqubic> How does that function work?
00:46:07 <ertes> Myrl-saki: what?
00:46:10 <Myrl-saki> ertes: What is being defined?
00:46:55 <ertes> iqubic: instead of using recursion on an index, i fold a list of indices
00:47:07 <ertes> iqubic: the result is the same…  it's just shorter to write
00:47:18 <iqubic> You do? why do you do that?
00:47:44 <iqubic> when do you apply the function f?
00:48:05 <ertes> look closely
00:48:10 <iqubic> I see it there.
00:48:18 <ertes> Myrl-saki: not sure what you mean
00:48:24 <iqubic> How does this let me right any traversal I want?
00:48:29 <Myrl-saki> ertes: I read the types. I understand now.
00:49:01 <ertes> > showHex ((bitsWord64 %~ not) 0xFFFFFFFF00000000) ""
00:49:03 <lambdabot>  "ffffffff"
00:49:11 <ertes> > showHex ((bitsWord64 %~ not) 0xFFFFFFFF) ""
00:49:14 <lambdabot>  "ffffffff00000000"
00:49:38 <ertes> iqubic: as i said, my solution is not going to help you
00:49:53 <ertes> iqubic: i've written it this way *specifically* to not be helpful
00:49:56 <iqubic> Wait, that's not the solution you want me to write?
00:50:03 <iqubic> Gosh darn it.
00:50:06 <ertes> iqubic: correct =)
00:50:12 <iqubic> I don't even understand that function.
00:51:01 <ertes> iqubic: look at the vector code from earlier…  that one i wrote to be helpful
00:51:21 <iqubic> I tried that. Couldn't get that to work.
00:51:49 <ertes> iqubic: then give it a break…  eat something, watch a movie, listen to some music, then try again
00:51:51 <iqubic> http://termbin.com/8v0v
00:51:56 <iqubic> That doesn't work.
00:52:12 <ertes> iqubic: allow your subconscious to work on it for a while…  that helps a lot
00:52:24 <MarcelineVQ> it does as annoying as that can seem
00:52:58 <ertes> iqubic: 'bit' does not do what you expect it to do
00:53:06 <iqubic> It doesn't?
00:53:10 <iqubic> What does it do?
00:53:12 <ertes> > bit 0 :: Integer
00:53:15 <lambdabot>  1
00:53:16 <ertes> > bit 4 :: Integer
00:53:18 <lambdabot>  16
00:53:18 <MarcelineVQ> "bit i is a value with the ith bit set and all other bits clear."
00:53:23 <kellytk> What kinds of programs is Haskell the wrong choice for?
00:53:32 <iqubic> Oh, yeah it doesn't do what I want
00:54:22 <ertes> iqubic: but you're on the right track with your template
00:54:35 <iqubic> Yeah, I know.
00:54:58 <iqubic> I copied the template from your vector example.
00:55:24 <Myrl-saki> traverse = sequence . map
00:55:29 <Myrl-saki> fmap*
00:55:38 <Myrl-saki> Errr, I'm probably missing some parentheses there?
00:56:03 <Myrl-saki> traverse f = sequence . fmap f
00:56:32 <MarcelineVQ> (sequence .) . fmap    if you're feeling adventurous
00:56:41 <MarcelineVQ> don't feel too adventurous
00:56:42 <iqubic> http://termbin.com/4sno
00:56:47 <iqubic> Not working either.
00:57:02 <iqubic> I think my combination function is wrong.
00:57:13 <mniip> traverse = ((.) . (.)) sequence fmap
00:58:17 <iqubic> (.|.) is not the right combination function to use there.
00:58:56 <iqubic> I don't know what is though.
00:59:23 <tsahyt> mniip: that's an evil way of writing this
00:59:39 <MarcelineVQ> sometimes being bad feels pretty darn good
01:00:13 <Cale> :t fmap fmap fmap sequence fmap
01:00:14 <lambdabot> (Monad m, Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
01:01:02 <ertes> @let bitsWord64' f x = foldr (\i -> liftA2 (fmap ($ i) . bool clearBit setBit) (f (testBit x i))) (pure 0) [0..63]
01:01:04 <lambdabot>  Defined.
01:01:23 <tsahyt> :t \f -> sequence . fmap f
01:01:25 <lambdabot> (Monad m, Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
01:01:42 <tsahyt> that's still not exactly traverse though
01:01:56 <tsahyt> :t \f -> sequenceA . fmap f
01:01:56 <Cale> :t fmap fmap fmap sequenceA fmap
01:01:57 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a) -> t a1 -> f (t a)
01:01:58 <lambdabot> (Applicative f, Traversable t) => (a1 -> f a) -> t a1 -> f (t a)
01:02:11 <iqubic> ertes: I think I cracked the code.
01:02:19 <ertes> @let bits f x = foldr (\i -> liftA2 (fmap ($ i) . bool clearBit setBit) (f (testBit x i))) (pure 0) [0 .. finiteBitSize x - 1]
01:02:21 <lambdabot>  Defined.
01:02:34 <ertes> > (15 :: Word8) ^.. bits
01:02:37 <lambdabot>  error:
01:02:37 <lambdabot>      Ambiguous occurrence ‘bits’
01:02:37 <lambdabot>      It could refer to either ‘Data.Bits.Lens.bits’,
01:02:42 <ertes> d'oh
01:02:47 <ertes> @let _bits f x = foldr (\i -> liftA2 (fmap ($ i) . bool clearBit setBit) (f (testBit x i))) (pure 0) [0 .. finiteBitSize x - 1]
01:02:49 <lambdabot>  Defined.
01:02:51 <ertes> > (15 :: Word8) ^.. _bits
01:02:53 <lambdabot>  [True,True,True,True,False,False,False,False]
01:03:13 <ertes> iqubic: great…  show me
01:05:13 <Myrl-saki> lmao
01:05:43 <mniip> > set _bits True undefined :: Int64
01:05:45 <lambdabot>  error:
01:05:46 <lambdabot>      • Ambiguous type variable ‘b10’ arising from a use of ‘_bits’
01:05:46 <lambdabot>        prevents the constraint ‘(FiniteBits b10)’ from being solved.
01:05:49 <mniip> > set _bits True (undefined :: Int64)
01:05:51 <lambdabot>  18446744073709551615
01:06:06 <mniip> wait... that's no Int
01:06:19 <ertes> huh?
01:06:27 <ertes> > finiteBitSize (0 :: Int64)
01:06:29 <lambdabot>  64
01:06:40 <ertes> that should be negative
01:06:52 <mniip> yes
01:06:56 <mniip> :t set _bits True (undefined :: Int64)
01:06:58 <lambdabot> (Bits t, Num t) => t
01:07:06 <mniip> that explaains it
01:07:07 <iqubic> Is there a way to get the number of bits a number has?
01:07:15 <mauke> define "has"
01:07:26 <ertes> > setBit 0 63 :: Int64
01:07:28 <lambdabot>  -9223372036854775808
01:07:29 <iqubic> Like find out that 4 takes two bits two right.
01:07:32 <iqubic> *write
01:07:38 <iqubic> *to
01:07:42 <mauke> ah, position of the highest bit
01:07:46 <iqubic> yes that.
01:07:53 <iqubic> That is what I nee
01:07:55 <iqubic> *d
01:08:10 <mniip> ceil . logBase 2
01:08:12 <mniip> or something
01:08:23 <ertes> iqubic: finiteBitSize
01:08:24 <mniip> otherwise bitwise tricks
01:08:34 <mauke> :t finiteBitSize
01:08:34 <iqubic> thanks ertes
01:08:35 <lambdabot> FiniteBits b => b -> Int
01:08:39 <mauke> > finiteBitSize 4
01:08:42 <lambdabot>  error:
01:08:42 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘finiteBitSize’
01:08:42 <lambdabot>        prevents the constraint ‘(FiniteBits b0)’ from being solved.
01:08:49 <mauke> > finiteBitSize (4 :: Integer)
01:08:51 <Myrl-saki> > bitSize (4 :: Integer)
01:08:51 <ertes> ah, wait
01:08:51 <lambdabot>  error:
01:08:51 <lambdabot>      • No instance for (FiniteBits Integer)
01:08:51 <lambdabot>          arising from a use of ‘finiteBitSize’
01:08:53 <lambdabot>  *Exception: Data.Bits.bitSize(Integer)
01:08:57 <mauke> > finiteBitSize (4 :: Int)
01:08:57 <Myrl-saki> Wait what
01:08:59 <lambdabot>  64
01:09:01 <ertes> iqubic: i think you're asking for something else
01:09:04 <mauke> yeah, no
01:09:13 <mauke> > finiteBitSize (undefined :: Int)
01:09:15 <lambdabot>  64
01:09:19 <Myrl-saki> Oh right.
01:09:20 <Myrl-saki> I had a gitlab.
01:09:21 <fuzzy-id> is there something shorthand to `h x = (>>= g) <$> f x`?
01:09:22 <ertes> not the position of the highest bit, but the position of the highest *set* bit
01:09:46 <ertes> fuzzy-id: unlikely
01:09:49 <mniip> :t \x -> (>>= ?g) <$> ?f x
01:09:51 <lambdabot> (Functor f, ?g::a -> m b, ?f::t -> f (m a), Monad m) => t -> f (m b)
01:10:10 <ertes> fuzzy-id: look if the 'free' library takes any shortcuts, but i doubt it
01:10:40 <Myrl-saki> I'm pretty sure I had some interesting bit twiddling hacks.
01:10:43 <Myrl-saki> In Haskell.
01:11:03 <ertes> still trying to figure out why my code fails
01:11:08 <Myrl-saki> https://gitlab.com/Myrl/mya/blob/master/lib/Primes/Testing.hs
01:11:31 <iqubic> ertes: What I want is the position of the highest set bit in a number.
01:11:54 <iqubic> Like for the number 15 that be 3
01:12:00 <Myrl-saki> > popCount (2^65 :: Integer)
01:12:02 <lambdabot>  1
01:12:03 <tsahyt> I had a fun bit hack to determine position of the highest (and only) set bit in a number 2^k.
01:12:07 <mniip> Myrl-saki, >bit twiddling >boxed types
01:12:08 <seequ_> Shift right until n == 0, the number of shifts is the position of the highest bit
01:12:09 <mniip> are you even
01:12:16 <Myrl-saki> mniip: :D
01:12:27 <Myrl-saki> mniip: I don't know man.
01:12:30 <tsahyt> > popCount (2^8 - 1 :: Word32)
01:12:32 <lambdabot>  8
01:12:38 <tsahyt> I think this was it
01:12:43 <Myrl-saki> mniip: It's still bit twiddling.
01:12:52 <geekosaur> that's number of set bits, I believe
01:12:57 <tsahyt> basically popCount (n - 1). only works for n = 2^k though, and should then return k
01:12:57 <Myrl-saki> geekosaur: Yep.
01:13:02 <Myrl-saki> tsahyt: Mhm.
01:13:06 <iqubic> I don't want the number of set bits.
01:13:13 <Myrl-saki> tsahyt: You can use bit twiddling hacks to still get the "next power of 2" though.
01:13:30 <iqubic> Let's take the number 6. the highest set bit is 3. That is what I want.
01:13:41 <ertes> iqubic: you have to search for it
01:13:45 <iqubic> I do?
01:14:02 <ertes> i'm not aware of any predefined function
01:14:08 <iqubic> Looks like I need to modify my template a bit to make this work better.
01:14:13 <Myrl-saki> Oh
01:14:16 <Myrl-saki> Found it.
01:14:33 <Myrl-saki> https://gitlab.com/Myrl/mya/blob/master/lib/Powers/Squares.hs#L40-48
01:14:38 <Myrl-saki> tsahyt: ^
01:14:42 <iqubic> what did you fing?
01:15:11 <Myrl-saki> iqubic: Magic.
01:15:18 <Myrl-saki> I call it... Haskell C.
01:15:33 * seequ_ sent a long message: seequ__2017-04-15_08:15:11.txt - https://matrix.org/_matrix/media/v1/download/matrix.org/NXhfHdrKCRqkNGaMXZSZVdgZ
01:15:34 <Myrl-saki> But mniip will hate me anyway for using Boxed types. ; ^ ;
01:16:10 <tsahyt> Myrl-saki: that's nice
01:16:35 <ertes> > (\x -> find (\i -> i <$ guard (testBit x i)) [finiteBitSize x - 1, finiteBitSize x - 2 .. 0]) (15 :: Word8)
01:16:37 <lambdabot>  error:
01:16:37 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘f0 Int’
01:16:37 <lambdabot>      • In the expression: i <$ guard (testBit x i)
01:16:38 <tsahyt> I should get in the habit of using state monads like this
01:16:41 <tsahyt> ad hoc I mean
01:16:50 <tsahyt> I usually just pass a parameter around
01:16:52 <ggVGc> I've never gound a good use of State
01:16:59 <ggVGc> I always end up just going with a fold
01:17:15 <ggVGc> State always ends up overly complicated for me
01:17:32 <ertes> :t find
01:17:33 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
01:17:42 <ertes> > (\x -> find (testBit x) [finiteBitSize x - 1, finiteBitSize x - 2 .. 0]) (15 :: Word8)
01:17:44 <lambdabot>  Just 3
01:17:48 <Myrl-saki> Oh what.
01:17:59 <ertes> iqubic: ^ like that
01:18:32 <seequ_> Seriously, that's wy overdoing it. :P
01:18:36 <seequ_> way*
01:18:36 <Myrl-saki> ggVGc: I needed to work on this like a tree.
01:18:50 <ertes> > (\x -> let i0 = finiteBitSize x - 1 in find (testBit x) [i0, i0 - 1 .. 0]) (15 :: Word8)
01:18:53 <lambdabot>  Just 3
01:18:54 <iqubic> ertes: I think I can get this to work.
01:18:54 <ertes> or more like that
01:19:27 <iqubic> bit numbers are [0,1..63] right?
01:19:55 <ertes> [0, 1 .. finiteBitSize (undefined :: A)]
01:20:06 <ertes> in the case of Word64:  [0..63]
01:20:09 <Sh4rPEYE> If I want to split String into [String] by upper-case letters, what's the best way to do that? Currently I'm using a weird fold with lambda... Is there a better way?
01:20:29 <Sh4rPEYE> Such that: "HelloMyWorld" -> ["Hello", "My", "World"]
01:20:36 <Myrl-saki> Also, I still think that the popCount is bad.
01:20:44 <Myrl-saki> I think it could have been done better.
01:20:49 <ertes> Sh4rPEYE: i'd use 'break'
01:20:55 <seequ> You are way ovethinking this..
01:20:55 <seequ> hbit_ 0 c = c
01:20:55 <seequ> hbit_ n c = hbit_ (shift n -1) (+ c 1)
01:20:56 <seequ> hbit n = hbit_ n 0
01:21:09 <tsahyt> > (\x -> listToMaybe . ($ reverse [0 .. finiteBitSize x]) . filter . testBit $ x) (16 :: Int)
01:21:12 <lambdabot>  Just 4
01:21:18 <tsahyt> > (\x -> listToMaybe . ($ reverse [0 .. finiteBitSize x]) . filter . testBit $ x) (15 :: Int)
01:21:19 <Myrl-saki> seequ: Anything other than pointfree is pointless. :D
01:21:21 <lambdabot>  Just 3
01:21:41 <tsahyt> arguably, using find is nicer though
01:22:13 <seequ> Myrl-saki: traversing lists for this is ridiculously inefficient :P
01:23:01 <Myrl-saki> @t unfolrd
01:23:01 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
01:23:06 <Myrl-saki> :t unfoldr
01:23:07 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
01:23:10 <Myrl-saki> Maybe?
01:23:14 <Myrl-saki> Knew it.
01:24:05 <jle`> > unfoldr (\x -> if x < 4 then Just (x, x+1) else Nothing) 0
01:24:07 <lambdabot>  [0,1,2,3]
01:24:40 <jle`> [a] is pretty much Maybe (a, [a]) anyway
01:25:39 <jle`> > unfoldr (\case [] -> Nothing; x:xs -> Just (x,xs)) [1..5]
01:25:41 <lambdabot>  [1,2,3,4,5]
01:25:50 <tsahyt> jle`: aka Maybe (NonEmpty a)
01:25:53 <Myrl-saki> jle`: Maybe (NonEmpty  a) = [a]
01:25:57 <Myrl-saki> tsahyt: :D
01:26:03 <jle`> :D
01:26:18 <Myrl-saki> I feel like I'm one of the cool kids now.
01:26:33 <jle`> luckily `\case [] -> Nothing; x:xs -> Just (x,xs)` is already in base
01:26:35 <iqubic> Ug. I don't understand why this code doesn't compile.
01:26:45 <tsahyt> I should not have picked up this idris book
01:26:47 <jle`> > unfoldr uncons [1..5]
01:26:49 <lambdabot>  [1,2,3,4,5]
01:27:02 <iqubic> http://termbin.com/tceo
01:27:12 <iqubic> Doesn't pass type checking.
01:27:30 <jle`> ejsy
01:27:33 <jle`> * what's the error
01:27:36 <tsahyt> I mean it's a good book, but it's also very good at showing you things that are currently very very hard to do in Haskell
01:27:45 <seequ> Yup.
01:28:03 <jle`> it's a book for dreamers
01:28:05 <tsahyt> but a decently sized chunk of the examples in the book can also be implemented very nicely in haskell
01:28:20 <lpaste> iqubic pasted “Type Checking Error” at http://lpaste.net/354607
01:28:30 <iqubic> I don't understand that.
01:29:00 <jle`> iqubic: f (testBit i w) is 'f Bool', but it needs to be 'f Int'
01:29:15 <jle`> so you just need to fmap some (Bool -> Int) function over it
01:29:17 <iqubic> why does it need to be f Int?
01:29:49 <tsahyt> jle`: I've skimmed richard eisenberg's thesis a bit, and on the surface, Dependent Haskell looks like it'd be very well capable of expressing all of the Idris tricks nicely
01:29:59 <jle`> iqubic: cause you're using the result in (\xs x -> shiftL 1 xs .|. x)
01:30:00 <tsahyt> so yeah, it's for dreamers. or for patient peopele.
01:30:03 <tsahyt> people*
01:30:10 <Cale> Or people who want to program in Idris
01:30:16 <tsahyt> Cale: oh yeah that too
01:30:19 <Cale> you know, what the book is about
01:30:21 <Cale> lol
01:30:30 <iqubic> why does it need to be type of (f Int)?
01:30:47 <jle`> iqubic: what's the type of shiftL
01:30:59 <iqubic> Oh. Right.
01:31:01 <ertes> @let camelSplit = unfoldr (\xs' -> case break isUpper xs' of ("", "") -> Nothing; ("", (y:ys)) -> Just $ Bi.first (y :) (break isUpper ys); r -> Just r)
01:31:02 <lambdabot>  Defined.
01:31:06 <tsahyt> it's certainly a nice side effect to have another language at my disposal. but realistically I'd rather stick with Haskell. the compiler produces better code, the eco system is better, it's lazy by default (which is what turns me off most from idris), etc etc
01:31:20 <Cale> Well, sure
01:31:24 <ertes> > map camelSplit ["HelloMyWorld", "elloMyWorld"]
01:31:27 <lambdabot>  [["Hello","My","World"],["ello","My","World"]]
01:31:43 <jle`> tsahyt: we might be able to express it in haskell, but the real barrier is those nice proof building tools and automated proof generators
01:31:44 <iqubic> jle`: I had my arguments backwards.
01:31:48 <tsahyt> Cale: it'd be interesting to have good Haskell <-> Idris interop though
01:32:16 <iqubic> I just got another weird error.
01:32:23 <jle`> idris without its proof building tools and automated proof tools is also not very fun
01:32:29 <tsahyt> jle`: if you want a theorem prover, Haskell will never be the right choice. Dependent Haskell will not suddenly turn it into a total language
01:32:30 <jle`> well, it is some amount of fun
01:32:36 <Cale> I honestly think that it's pretty likely that at some point GHC gets a new frontend with a better language for dependently typed programming.
01:32:56 <jle`> tsahyt: we don't need a total language
01:32:57 <tsahyt> Cale: so it'd be the Glasgow Not-only-Haskell Compiler?
01:33:02 <Cale> yeah
01:33:18 <tsahyt> jle`: well technically you do. if you want to actually proof theorems with it, non-termination is a big issue for correctness
01:33:24 <jle`> just tools to make writing `(x + 0) :~: x` nicer
01:33:34 <iqubic> http://termbin.com/iilx
01:33:38 <jle`> x + Z
01:33:47 <iqubic> http://lpaste.net/354608
01:33:48 <jle`> or (x ++ []) :~: x
01:33:54 <tsahyt> jle`: there've been attempts to integrate SMT solvers as type checker plugins iirc
01:33:55 <iqubic> Errors are weird.
01:34:01 <iqubic> I don't understand them.
01:34:09 <jle`> not just for type checking, but for actually writing proofs
01:34:22 <ertes> mniip: that's weird…  my bits traversal works locally
01:34:26 <jle`> iqubic: the error here is very similar
01:34:42 <ertes> @let bitsAgain f x = foldr (\i -> liftA2 (fmap ($ i) . bool clearBit setBit) (f (testBit x i))) (pure 0) [0..finiteBitSize x - 1]
01:34:43 <lambdabot>  Defined.
01:34:44 <jle`> iqubic: the function wants Word64, but you're giving it Bool
01:34:48 <Cale> We do need a termination checker, and a total language fragment, eventually.
01:34:48 <tsahyt> jle`: what's the difference really. for writing these proofs you mostly want a library of theorems like that available
01:34:51 <iqubic> Yeah, I got my argments backwards again.
01:34:56 <ertes> > set bitsAgain True undefined :: Int64
01:34:58 <lambdabot>  error:
01:34:59 <lambdabot>      • Ambiguous type variable ‘b10’ arising from a use of ‘bitsAgain’
01:34:59 <lambdabot>        prevents the constraint ‘(FiniteBits b10)’ from being solved.
01:35:11 <ertes> > set bitsAgain True (undefined :: Int64)
01:35:12 <jle`> iqubic: the error is actually pretty clear :)
01:35:13 <lambdabot>  18446744073709551615
01:35:23 <tsahyt> the harder part in my experience is convincing the type checker that say n + k - k ~ n
01:35:24 <jle`> iqubic: "Expected type: ____, Actual type: ____"
01:35:27 <Cale> It's not the top priority for practical work, but it would be very nice to have
01:35:32 <tsahyt> and that's where the type checker plugins come in
01:35:36 <lpaste> iqubic pasted “Bool does not equal Word64” at http://lpaste.net/354609
01:35:41 <iqubic> http://termbin.com/mgly
01:35:41 <Cale> and it's essential if we start proving stuff
01:35:51 <jle`> iqubic: means that haskell wants something from the "expected" thing, but you are giving it something from the "actual" line
01:35:52 <tsahyt> Cale: for the time being, I resort to liquid haskell for termination checking. it's certainly not perfect either, but then again no termination checker ever is
01:36:04 <ertes> does anyone need the definitions so far?
01:36:05 <ertes> good
01:36:06 <ertes> @undef
01:36:06 <lambdabot> Undefined.
01:36:15 <iqubic> That last error doesn't say where the error comes from.
01:36:18 <jle`> iqubic: so if the error says "expected: Foo, actual: Bar", it means that you're giving it a FOo, but it wants a Bar
01:36:18 <ertes> @let bits' f x = foldr (\i -> liftA2 (fmap ($ i) . bool clearBit setBit) (f (testBit x i))) (pure 0) [0..finiteBitSize x - 1]
01:36:19 <lambdabot>  Defined.
01:36:22 <Myrl-saki> You know what.
01:36:27 <ertes> > set bits' True (undefined :: Int64)
01:36:28 <Myrl-saki> I honestly have no idea what I wrote.
01:36:29 <lambdabot>  18446744073709551615
01:36:30 <Myrl-saki> :D
01:36:36 <jle`> iqubic: it does, though
01:36:37 <Myrl-saki> Not anymore, at least.
01:36:45 <ertes> something is wrong with lambdabot…  that definition works for me locally
01:36:47 <jle`> iqubic: "In the expression: go 64"
01:36:50 <iqubic> jle`: Where is the error coming from?
01:36:58 <jle`> iqubic: "in the expression: ____"
01:37:02 <jle`> that's where it tells you where the error is
01:37:14 <iqubic> Yeah, but that expression is really large.
01:37:16 <ertes> :t set
01:37:17 <jle`> no
01:37:18 <lambdabot> ASetter s t a b -> b -> s -> t
01:37:20 <jle`> the expression is 'go 64'
01:37:31 <jle`> "In the expression: go 64"
01:37:35 <jle`> are we reading the same error message?
01:37:39 <iqubic> yes.
01:37:56 <jle`> the expression is 'go 64'
01:37:58 <ertes> :t bits
01:37:59 <lambdabot> (Applicative f, Indexable Int p, Bits b, Num b) => p Bool (f Bool) -> b -> f b
01:38:01 <jle`> that's pretty small, as far as expressions go :)
01:38:02 <ertes> OH!
01:38:04 <jle`> only 5 characters
01:38:07 <ertes> stupid me
01:38:11 <ertes> @undef
01:38:12 <lambdabot> Undefined.
01:38:22 <iqubic> jle`: look at the where statement just below that.
01:38:31 <iqubic> That's the part that I can't seem to puzzle out
01:38:34 <ertes> @let bits' :: (Num a, FiniteBits a, Applicative f) => (Bool -> f Bool) -> a -> f a; bits' f x = foldr (\i -> liftA2 (fmap ($ i) . bool clearBit setBit) (f (testBit x i))) (pure 0) [0..finiteBitSize x - 1]
01:38:36 <lambdabot>  Defined.
01:38:37 <jle`> iqubic: you don't have to look at that
01:38:42 <jle`> iqubic: you just need to fix the error
01:38:43 <iqubic> Why not?
01:38:47 <ertes> > set bits' True undefined :: Int64
01:38:49 <lambdabot>  -1
01:38:52 <ertes> THERE we go
01:38:54 <iqubic> how do I fix the error?
01:39:04 <jle`> iqubic: the error is that 'go 64' is f Bool
01:39:09 <Cale> tsahyt: Well, we hope that e.g. Agda's is "perfect" in the sense of not admitting non-terminating programs. But there's always the question of whether it could perhaps admit more programs automatically.
01:39:13 <jle`> iqubic: but haskell wants it to be f Word64
01:39:25 <mniip> 1492245384 [11:36:24] <ertes> something is wrong with lambdabot…  that definition works for me locally
01:39:29 <jle`> iqubic: what's what it means when it says "Expected XXX, Actual YYYY, in expression ZZZ"
01:39:30 <mniip> it monomorphizes to Integer
01:39:35 <mniip> obviously
01:39:39 <jle`> iqubic: it means that ZZZ is type YYY, but haskell wants XXX
01:39:56 <iqubic> yes. I know. jle` I can't change the type of the funxtion without chaning the the where expression below.
01:40:05 <jle`> you don't have to change the type of the function
01:40:19 <jle`> you just need to change the type of what you put for bitsWord64 f w = ????
01:40:24 <jle`> instead of putting 'go 64', put something else
01:40:28 <iqubic> How do I do that?
01:40:32 <jle`> type it in
01:40:34 <jle`> where the ???? is
01:40:35 <iqubic> Like what?
01:40:44 <iqubic> What do I type in there?
01:40:54 <ertes> mniip: i didn't realise that this function is actually more generic…  the fact that the type signature on the result wasn't enough should have set off my alarm bells
01:41:08 <blender> Hello, I have a small issue Applicative Maybe and Monad Transformers, can anyone help or tell me if I'm holding it wrong? http://stackoverflow.com/questions/43408620/monad-transformer-and-applicative-maybe
01:41:58 <ertes> i think it's just regular defaulting in this case
01:42:06 <Myrl-saki> What does expected type and actual type mean again?
01:42:06 <iqubic> jle`: How do I change the type of my function?
01:42:09 <Myrl-saki> > 1 :: String
01:42:11 <lambdabot>  error:
01:42:11 <lambdabot>      • No instance for (Num String) arising from the literal ‘1’
01:42:11 <lambdabot>      • In the expression: 1 :: String
01:42:11 <[exa]_> Mmm guys. Anyone knowledgeable about how monad transformers and similar higher-kinded stuff are actually compiled? E.g.: I know how simple stuff like DataCon Int Int can be represented in STG. But how does one store e.g. the first parameter of MaybeT which is of kind (*->*) ? Or does it just get "optimized out"?
01:42:16 <ertes> @let genericBits f x = foldr (\i -> liftA2 (fmap ($ i) . bool clearBit setBit) (f (testBit x i))) (pure 0) [0..finiteBitSize x - 1]
01:42:18 <lambdabot>  Defined.
01:42:20 <ertes> :t genericBits
01:42:21 <lambdabot> (Bits b, Applicative f, Num b, FiniteBits b1) => (Bool -> f Bool) -> b1 -> f b
01:42:23 <Myrl-saki> Okay.. that was not what I was looking for.
01:42:32 <ertes> mniip: yeah, just defaulting, no monomorphisation
01:42:44 <mniip> er
01:42:46 <mniip> yes
01:42:47 <mniip> defaulting
01:43:12 <Myrl-saki> I like how this has no answer. http://stackoverflow.com/questions/44965/what-is-a-monad?rq=1
01:43:15 <mniip> defaulting is a typee of monomorphisation I guess
01:43:20 <Myrl-saki> Accepted answer, I mean.
01:43:24 <iqubic> Alright, I have no idea how to make a traversal over the bits of a word64.
01:43:41 <ertes> iqubic: you were really close
01:44:02 <iqubic> I was? How do I make this work?
01:44:27 <tsahyt> @mtl ReaderT Foo IO a
01:44:27 <lambdabot> Maybe you meant: url unmtl pl msg
01:44:30 <tsahyt> @unmtl ReaderT Foo IO a
01:44:31 <lambdabot> Foo -> IO a
01:44:50 <ertes> iqubic: go i | i < 64 = _combine <$> f (testBit w i) <*> go (i + 1)
01:45:21 <ertes> iqubic: _combine receives two arguments:  a boolean for the current bit, and the word built so far
01:45:22 <tsahyt> [exa]_: since all (I think) the transformers are just newtypes, their constructors should be erased. so you end up with Foo -> IO a for a ReaderT Foo IO for example
01:45:36 <tsahyt> all the wrapping and unwrapping itself should be free
01:45:49 <tsahyt> however, the dictionary passing for MonadReader isn't
01:46:02 <iqubic> What do I put as combine?
01:46:20 <ertes> iqubic: (\b w' -> …)
01:46:34 <ertes> iqubic: if b is True, you want to set the corresponding bit in w'
01:48:13 <iqubic> How do I know what bit to se?
01:48:25 <iqubic> I have the counter i
01:48:26 <ertes> iqubic: the bit at the current index
01:48:33 <ertes> what is the current index?
01:48:38 <[exa]_> tsahyt: so it gets evaluated out. Suspected that. Thanks!
01:49:10 <ertes> iqubic: hint: you are reading the bit at the current index in the same line
01:49:15 <tsahyt> [exa]_: kinda. due to the dictionaries at least you still end up with some overhead.
01:49:19 <iqubic> I know
01:50:09 <tsahyt> I'm not sure whether explicit lifting would be free either. I don't think it is. but in reality, this is hardly ever the bottleneck for performance.
01:50:38 <tsahyt> in any case, mtl outperforms any alternatives like extensible-effects afaik.
01:54:13 <Myrl-saki> unsafeReUnion sounds like dating your long lost sister.
01:54:42 <iqubic> I did a thing.
01:54:51 <iqubic> I GOT THE THING TO WORK.
01:54:54 <halogenandtoast> If I want to make a game with a GUI, is Cairo a good choice?
01:55:04 <Myrl-saki> iqubic: lmao
01:55:11 <Myrl-saki> iqubic: Show us.
01:55:22 <iqubic> http://termbin.com/cne7
01:55:29 <iqubic> I think that should work.
01:55:40 <iqubic> Type Signature check passes.
01:55:48 <ertes> iqubic: it looks correct, yeah
01:55:54 <iqubic> I did a thing.
01:55:59 <iqubic> That was super hard.
01:56:10 <ertes> congratulations =)
01:56:14 <Myrl-saki> `:D
01:56:38 <iqubic> Now, give me another traversal to write. I want to see if I can make another one.
01:56:55 <Myrl-saki> iqubic: https://media.tenor.co/images/6863669abb7bb57c71886bc8cbfb274f/tenor.gif
01:57:07 <iqubic> Thank you.
01:58:09 <ertes> iqubic: you want something harder, don't you…
01:58:15 <iqubic> Do I still need to use Template Haskell to generate lenses for records? Or is that not needed?
01:58:21 <Myrl-saki> I wonder how I'd do it.
01:58:23 <iqubic> ertes: I'd like to try something.
01:58:25 <Myrl-saki> Probably unfoldr + foldr?
01:58:25 <ertes> iqubic: TH is completely optional
01:58:40 <iqubic> How do you write a lens for a record?
01:58:41 <Myrl-saki> :t foldr
01:58:42 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:58:50 <iqubic> Is that hard to do?
01:58:59 <ertes> iqubic: tuples are records with two fields in a way
01:59:09 <iqubic> Or they?
01:59:20 <iqubic> How can you pattern match on a record?
01:59:48 <piyush-kurur> is there a way to run the example code given in the haddock documentation and check whether everything is fine?
02:00:03 <ertes> to write field lenses you generally don't pattern-match
02:00:06 <Lokathor> iqubic, (RecordName fieldA fieldB etc), like it was a normal data thing, the fields fall in order of their declaration
02:00:18 <iqubic> Ah.
02:00:40 <iqubic> ertes: You got a harder traversal for me to try writing?
02:01:00 <ertes> myField f x = (\a -> x { _myField = a }) f (_myField x)
02:01:02 <Lokathor> halogenandtoast, sdl2 is probably your best choice for a 2d game in Haskell
02:01:07 <ertes> iqubic: if you want, sure
02:01:40 <halogenandtoast> Lokathor: I'll check it out
02:01:42 <iqubic> Can I have something to make?
02:01:42 <halogenandtoast> it will be 2d
02:02:26 <ertes> iqubic: as you wish: write a traversal into the result of a boolean function
02:02:56 <iqubic> What?
02:03:00 <ertes> iqubic: boolCodomain :: (Applicative f) => (a -> f b) -> (Bool -> a) -> f (Bool -> b)
02:03:36 <iqubic> You can't control the output of a boolean function.
02:03:49 <ertes> iqubic: you can…  take your time =)
02:04:21 <iqubic> How do you change the output of a Boolean Function??
02:04:26 <ertes> iqubic: for this one you need to think outside the box a little
02:04:45 <ertes> iqubic: you can't *change* it, but you can construct functions based on other functions
02:04:51 <iqubic> What does it mean for something to be a Boolean Function?
02:05:07 <ertes> actually the correct term is "function of Bool"
02:05:17 <iqubic> Ah.
02:05:18 <ertes> a boolean function is a function that would return a Bool…  sorry
02:05:44 <iqubic> So how do I change the outcome of a function??
02:05:45 <Myrl-saki> :t (\b -> if b then 1 else 0)
02:05:47 <lambdabot> Num t => Bool -> t
02:05:59 <ertes> iqubic: (not .)
02:06:06 <ertes> :t (not .)
02:06:08 <lambdabot> (a -> Bool) -> a -> Bool
02:06:29 <iqubic> wait, so it's a travesal over both possible outputs?
02:06:39 <ertes> this one takes a function f and returns a function that is the same as f, but with the result inverted
02:06:44 <ertes> yes
02:06:55 <iqubic> So this is simple?
02:06:59 <iqubic> Or is it?
02:07:14 <ertes> it's simple, but a bit mind-bending, if you're not used to this =)
02:07:16 <Myrl-saki> ertes: Is there an actual use for this?
02:07:19 <iqubic> What would the (a -> f b) do?
02:07:35 <ertes> Myrl-saki: sure…  think of functions as an abstraction for arrays
02:07:54 <ertes> then you have a traversal into the array elements
02:07:59 <Myrl-saki> ertes: Are you talking about x^n == n -> x?
02:08:07 <ertes> Myrl-saki: exactly =)
02:08:36 <ertes> iqubic: take your time and think…  compare the type to other traversals you have written
02:08:39 <Myrl-saki> I'll be trying out this one. Been some time since I've done some weird stuff. :D
02:10:07 <iqubic> This is weird
02:10:27 <Myrl-saki> It's supposed to be weird. :D
02:10:37 <ertes> iqubic: you wanted a challenge =)
02:10:54 <iqubic> I have no idea what the (a -> f b) would do, other than operate on all the possible outcomes.
02:11:16 <ertes> iqubic: typically you would think of a value of type (Bool -> A) as "something that takes a Bool and returns an A"
02:11:26 <ertes> iqubic: can you think of any other interpretations for such a value?
02:11:36 <iqubic> No.
02:11:41 <Myrl-saki> ertes: Something that contains 2 As? :D
02:11:46 <ertes> iqubic: how many Bools are there?
02:11:52 <iqubic> Two.
02:11:54 <Myrl-saki> Rather, "contains"
02:12:13 <iqubic> It's like (Maybe -> a)
02:12:18 <ertes> iqubic: so if (f :: Bool -> A), how many possible results can f have?
02:12:24 <iqubic> two.
02:12:35 <ertes> iqubic: how do you get the first result?
02:12:44 <iqubic> you run the function.
02:12:54 <ertes> iqubic: give me code
02:13:01 <iqubic> f
02:13:12 <iqubic> that is the first result
02:13:13 <ertes> give me the code for one of the As
02:13:30 <iqubic> is not just 'f'?
02:13:32 <ertes> nope, f is not of type A
02:13:58 <iqubic> How do I extract the value?
02:14:05 <ertes> iqubic: you just told me
02:14:17 <iqubic> how do I run a function?
02:14:30 <ertes> you apply it
02:14:46 <iqubic> How do I apply it? I feel really stupid now.
02:14:49 <Myrl-saki> This sounds like it'd be way easier with a Monad instance. <.<
02:15:01 <ertes> iqubic: function application:  f False, f True
02:15:16 <iqubic> oh, right.
02:15:43 <ertes> iqubic: now, can you write a function that, given such a function, gives you the two results?
02:15:51 <ertes> toPair :: (Bool -> a) -> (a, a)
02:17:05 <iqubic> So what I do is this: toPair f b = (,) <$> f (b True) <*> f (b False)
02:17:08 <iqubic> Got it.
02:17:14 <ertes> nope
02:17:19 <iqubic> Why not?
02:17:24 <ertes> toPair takes only one argument
02:17:25 <iqubic> how is that wrong???
02:17:44 <ertes> (it's not anything lensy)
02:17:48 <iqubic> :t toPair
02:17:50 <lambdabot> error: Variable not in scope: toPair
02:17:51 <jle`> ask ghc :o
02:18:05 <iqubic> so what do I do then???
02:18:13 <iqubic> I'm a bit confused now.
02:18:13 <ertes> iqubic: write the function
02:18:27 <iqubic> what function am I trying to write? toPair?
02:18:32 <ertes> yeah
02:19:09 <NextHendrix> just been reading this interesting tidbit from the monad reader https://imgur.com/jVq8hgV
02:19:16 <iqubic> toPair f = (,) <$> f True <*> f False
02:19:25 <ertes> iqubic: you're overthinking it
02:19:36 <NextHendrix> question is, what is happening in that last line lol
02:19:38 <iqubic> or toPair f = (f True, f False)
02:19:49 <ertes> iqubic: yeah, that's the one
02:20:02 <iqubic> is that all you wanted?
02:20:07 <iqubic> or what?
02:20:16 <ertes> iqubic: not yet
02:20:25 <iqubic> what do you want?
02:20:26 <NextHendrix> reverse = foldl (flip (:)) []
02:20:31 <ertes> iqubic: now, could you also write a function that goes from a pair to such a function?
02:20:41 <ertes> iqubic: fromPair :: (a, a) -> (Bool -> a)
02:20:47 <jle`> NextHendrix: easiest way to decipher it is to just manually apply out the definition of foldl
02:20:49 <jle`> @src foldl
02:20:49 <lambdabot> foldl f z []     = z
02:20:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:21:01 <iqubic> I don't think you can do that.
02:21:10 <iqubic> ertes: you can't go back the other way.
02:21:18 <ertes> iqubic: try it
02:21:23 <NextHendrix> oh wait (:) is just prefix cons isnt it
02:21:27 <geekosaur> yes
02:21:38 <NextHendrix> lol, that article is really good
02:21:38 <jle`> :t flip (:)
02:21:39 <lambdabot> [a] -> a -> [a]
02:21:42 <geekosaur> operator as a function you can pass to other things
02:21:45 <jle`> > flip (:) [1,2,3] 0
02:21:47 <lambdabot>  [0,1,2,3]
02:21:47 <ertes> iqubic: remember currying:  (a, a) -> (Bool -> a) = (a, a) -> Bool -> a
02:21:49 <NextHendrix> yeah gotcha
02:21:57 <iqubic> :t curry
02:21:59 <lambdabot> ((a, b) -> c) -> a -> b -> c
02:22:02 <iqubic> :t uncurry
02:22:03 <lambdabot> (a -> b -> c) -> (a, b) -> c
02:22:08 <Myrl-saki> Can I use holes in ghci?
02:22:18 <Myrl-saki> Oh, I can.
02:22:19 <ertes> iqubic: it has nothing to do with curry/uncurry, just the way you read the type
02:22:20 <jle`> what happens when you try?
02:22:32 <iqubic> Ah.
02:22:47 <Myrl-saki> But not as a function argument..
02:22:56 <ertes> iqubic: the point is that fromPair actually takes two arguments
02:22:57 <jle`> as a function argument, it's not a typed hole
02:23:03 <jle`> it's just a wildcard pattern match
02:23:31 <iqubic> ertes: you want me to write fromPair??
02:23:36 <ertes> iqubic: yeah
02:23:41 <NextHendrix> extremely terse pointfree haskrll might as well count as a form of encryption
02:23:49 <geekosaur> sometimes it is :)
02:23:58 <iqubic> How will that work?
02:24:00 <geekosaur> that was in fact the point of that page of the Monad.Reader
02:24:04 <Myrl-saki> I wanted to work with holes. :(
02:24:06 <NextHendrix> yeah
02:24:16 <geekosaur> there's also an "evolution of a haskell programmer" joke along those lines
02:24:22 <NextHendrix> heh
02:24:27 <jle`> Myrl-saki: ghci works with holes the same way as normal haskell files do
02:24:37 <Myrl-saki> jle`: I don't normally use holes.
02:24:44 <jle`> oh
02:24:47 <jle`> holes are pretty useful
02:24:50 <jle`> but what do you want to use them for?
02:24:50 <Myrl-saki> jle`: Exactly!
02:25:02 <Myrl-saki> jle`: I want to know the type of an argument.
02:25:02 <iqubic> what will fromPair do?
02:25:08 <Myrl-saki> jle`: I mean, sure, I can easily figure it out.
02:25:19 <geekosaur> oh, you want ScopedTypeVariables and (_ :: _)
02:25:25 <ertes> iqubic: given a pair constructed via toPair, reconstructs the original function
02:25:32 <geekosaur> and I think another extension to turn on the _ as type thing
02:25:39 <ertes> iqubic: such that (fromPair . toPair = id)
02:25:40 <jle`> i think it's on by default
02:25:47 <Myrl-saki> Let me try.
02:25:49 <iqubic> I cna't do that. I have no idea how to do that?
02:26:23 <jle`> iqubic: just believe in your self ~
02:26:34 <ertes> iqubic: fromPair (x, y) True = _  -- this clause is supposed to return the component that the original function would have returned when given True
02:27:09 <ertes> iqubic: example:  f b = if b then 3 else 5
02:27:14 <ertes> iqubic: toPair f = (3, 5)
02:27:25 <iqubic> fromPair (x, y) True = x; fromPair (x, y) False = y
02:27:27 <iqubic> got it.
02:27:31 <geekosaur> oh, the extension is to enable it to actually continue using the inferred type
02:27:33 <ertes> iqubic: correct
02:27:39 <geekosaur> instead of throwing it as an error
02:27:41 <iqubic> Now what do you want me to do?
02:28:16 <bbear> hello
02:28:19 <bbear> I have a little problem.
02:28:21 <Myrl-saki> `• Found type wildcard ‘_’ standing for ‘t’`
02:28:22 <ertes> iqubic: now there is a good reason why i made you write those functions:  they are actually isomorphisms, meaning that they take a value of type (Bool -> a) to a value of type (a, a) and back without information loss, and vice versa
02:28:23 <Myrl-saki> :C
02:28:36 <ertes> iqubic: makes sense so far?
02:28:37 <Myrl-saki> I'm done. I'm sleepy.
02:28:38 <iqubic> I have fromPoint and toPoint.
02:28:48 <iqubic> Yes, ertes makes sense.
02:28:55 <iqubic> *pair.
02:28:55 <bbear> let say I partition the alphabet in three parts : [a..f] [g..u] [v..z]
02:29:13 <ertes> iqubic: then would it be fair to say that those two types are really just representations of the same concept, namely "pair"?
02:29:26 <iqubic> yes.
02:29:35 <iqubic> I think that is correct.
02:29:39 <ertes> iqubic: does that give you an idea on how to approach that traversal?
02:29:41 <geekosaur> Myrl-saki, if it's inferred polymorphic then you need to put the wildcard at the use site
02:29:45 <iqubic> What traversal?
02:29:52 <bbear> How can I do a function that returns three list of letters according to the set in which the initial letter is.
02:29:55 <ertes> iqubic: boolCodomain
02:30:11 <iqubic> What is the type signature.
02:30:13 <iqubic> ??
02:30:20 <bbear> :t boolCodomain
02:30:22 <lambdabot> error: Variable not in scope: boolCodomain
02:30:23 <ertes> iqubic: you really need to start taking notes =)
02:30:38 <iqubic> I'll start doing that.
02:30:42 <ertes> boolCodomain :: (Applicative f) => (a -> f b) -> (Bool -> a) -> f (Bool -> b)
02:30:43 <Myrl-saki> geekosaur: Actually used the value. `• Found type wildcard ‘_’ standing for ‘Int’`
02:30:47 <Myrl-saki> geekosaur: the argument*
02:31:21 <bbear> btw my question would
02:31:34 <bbear> how can I return 
02:31:39 <bbear> ok I found out I think
02:31:42 <iqubic> ertes: And I need to traverse both values?
02:32:02 <ertes> iqubic: yes
02:32:10 <iqubic> Is there a way to traverse both parts of a tuple?
02:32:20 <iqubic> Do I have that at my disposal?
02:32:26 <jle`> you just did it earlier, heh
02:32:27 <ertes> iqubic: you have done that
02:32:39 <jle`> granted, it was about four or five hours ago
02:32:52 <jle`> so you'd be forgiven for not recalling :)
02:32:55 <geekosaur> iqubic, I think you want to use the log links in the /topic and review this whole discussion
02:33:16 <geekosaur> because yeh, it's drawn out a bit and you could be forgiven for forgetting where it started (I did!)
02:33:27 <blender> How do I combine something like a -> b > ReaderT (Bool) IO () with Maybe a  
02:33:32 <iqubic> What did that look like again? This: traverseBoth f (x, y) = (,) <$> f x <*> f y
02:33:43 <iqubic> is that the correct form of that?
02:33:43 <ertes> that's the one
02:34:05 <Myrl-saki> &&& ?
02:34:20 <Myrl-saki> :t traverseBoth = join (&&&)
02:34:21 <lambdabot> error:
02:34:22 <lambdabot>     parse error on input ‘=’
02:34:22 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
02:34:30 <Myrl-saki> :t join (&&&)
02:34:31 <lambdabot> Arrow a => a b c' -> a b (c', c')
02:34:44 <Myrl-saki> Oh. No.
02:35:10 <mniip> :t join (***)
02:35:12 <lambdabot> Arrow a => a b' c' -> a (b', b') (c', c')
02:35:41 <Myrl-saki> mniip: Thanks. :C
02:36:17 <iqubic> boolCodomain f b = fromPair (traverseBoth f (toPair b))
02:36:26 <iqubic> I don't think that quite works
02:36:59 <ertes> iqubic: not quite
02:37:15 <iqubic> what am I missing?
02:37:32 <iqubic> I don't understand what I am doing wrong there.
02:37:34 <ertes> the result of traverseBoth is not quite a pair
02:37:40 <ertes> look at its type
02:37:45 <iqubic> No it isn't 
02:37:51 <iqubic> it's f (a, b
02:38:00 <iqubic> * f (a, b)
02:38:34 <iqubic> I don't know what to do from there.
02:38:41 <iqubic> I can't quite make this work
02:38:59 <ertes> you have an f X and an X -> Y, you want an f Y
02:39:05 <ertes> any idea?
02:39:18 <iqubic> So I use <*>
02:39:24 <ertes> nope
02:39:29 <iqubic> GRR
02:39:33 <iqubic> What do I use?
02:39:41 <ertes> (well, you can, but there is a more sensible choice)
02:39:59 <ertes> if you had an f (X -> Y), then (<*>) would be the right choice
02:40:10 <ertes> but you have an X -> Y
02:40:34 <iqubic> So I use fmap.
02:40:50 <iqubic> That's how that works
02:41:29 <iqubic> boolCodomain f b = fromPair <$> (traverseBoth f (toPair b))
02:41:38 <iqubic> Just trying stuff out.
02:41:43 <ertes> that's correct
02:41:58 <iqubic> But where's the applicative??
02:42:13 <ertes> you're using it implicitly via traverseBoth
02:42:21 <iqubic> Ah. I see.
02:42:40 <iqubic> Anything else I need to know about traversals and lenses?
02:43:14 <iqubic> Or do I just need practice with this
02:43:15 <iqubic> >>
02:43:17 <iqubic> ???
02:43:27 <ertes> practice is your first step now
02:43:38 <ertes> use lenses and traversals practically
02:43:48 <iqubic> Alright, what else can I learn about.
02:44:11 <iqubic> I've heard about prisms. Are those related to lenses and travesals?
02:44:23 <ertes> let me answer that in the form of a comic
02:44:26 <ertes> https://ro-che.info/ccc/23
02:44:34 <iqubic> I've read that they are.
02:44:58 <iqubic> I'm sorry for opening another can of worms
02:45:02 <ertes> the lens library refers to all these as "optics"
02:45:08 <ertes> there are lots of them
02:45:14 <ertes> and they form a kind of hierarchy
02:45:17 <Gurkenglas> There's a nice segue here into isos by saying that "boolCodomain f b = fromPair <$> (traverseBoth f (toPair b))" can be rewritten as "boolCodomain = au (iso fromPair toPair) traverseBoth"
02:45:28 <ertes> https://hackage.haskell.org/package/lens
02:45:38 <ertes> look at the diagram
02:45:43 <iqubic> What the heck is and iso?
02:46:20 <Gurkenglas> Every Iso is a Lens. It is a witness that two types are isomoprhic.
02:47:02 <iqubic> So fromPair . toPair = id?
02:47:18 <ertes> iqubic: i used the word isomorphism earlier…  it means that one type is just another type in disguise, because you can convert between them without information loss
02:47:35 <Gurkenglas> Yes I assumed that
02:48:44 <MarcelineVQ> I ​have got to say, the ((->) r) instance for functor and applicative made working that problem out by looking at type errors very difficult
02:51:47 <iqubic> Are isos and prisms required for me to learn about?
02:52:26 <jle`> nothing here is really required. just useful :)
02:52:59 <iqubic> Are Isos and Prisms easy to teach. Are they easy to learn about?
02:57:17 <dibblego> iqubic: yes, are you going to lambdaconf?
02:57:24 <iqubic> No.
02:57:34 <iqubic> Not going to lambaconf
02:58:19 <dibblego> or, if you are in .au the .au federal government occasionally runs free course on lens (iso, prism, etc)
02:58:35 <iqubic> I'm not in au
02:58:40 <iqubic> in USA
02:58:47 <dibblego> come to Boulder
02:59:01 <iqubic> I'm in the NW
03:01:01 <kellytk> What kinds of programs is Haskell the wrong choice for?
03:01:43 <ongy> low level embedded environments with memory constraints, or hard realtime. At least with current implementations.
03:02:38 <kellytk> I don't have projects of either kind in the works
03:02:46 <kellytk> Is there anything else?
03:04:17 <ongy> those are exampls where haskell will fail. For all others I think it's gradual. I don't think we have a native gui library on hackage either. So if you need that, you will either have to figure something out, or at least mix languages in the project
03:05:55 <kellytk> I'll try making a bot to begin with to see how Haskell feels to me
03:05:59 <kellytk> Thanks ongy 
03:06:00 <ongy> well, we have some bindings to gtk and wx I think. But I don't think they are considered complete or easy/intuitive to use.
03:06:33 <puregreen> I don't think gtk is easy/intuitive to use in general
03:06:42 <ongy> For things like irc bot, haskell works pretty well. Since they fit the functional paradigm pretty well (you take one line in, process it and return a line (or list of lines)
03:08:24 <iqubic> ongy: You can even use interact for that.
03:08:28 <iqubic> :t interact
03:08:29 <lambdabot> (String -> String) -> IO ()
03:08:36 <halogenandtoast> If I have a Text and I want to read it until a specific sequence of characters is there a function that lets me do that?
03:08:55 <ongy> does that line-buffer? If so, probably
03:09:51 <kellytk> How well can Haskell do what RxJS does, to allow composition of multiple event streams?  After the basics of the bot work, I'd like to make it trade stocks for me
03:10:10 <kellytk> That would require intaking data continually via API queries and processing the flow
03:12:14 <halogenandtoast> I think splitOn is what I wanted
03:22:38 <sssilver> Hey guys, anyone here knows Haskell?
03:22:43 <Sh4rPEYE> I stumbled upon Literate Haskell. Should I learn it/use it? I'm doing only fun little exercises, but there are some "organisation-ish" comments (like "this the task no. x, link: x), which could look better when put out of code.
03:23:21 <sssilver> I was having an interesting debate with my Clojure friend today. He was arguing that type systems are useless, because they're all deficient. And asked to model the following problem:
03:23:24 <Sh4rPEYE> Somewhere I read lhs is dead and one should use haddock... I've no idea what that is; should I use that instead?
03:25:06 <sssilver> imagine you have a function(m: hashmap, k: key), and it returns m[k]. Is it possible to model this in a way that the program won't compile if m[k] doesn't exist?
03:25:24 <sssilver> and I thought about it and realized that no I can't accomplish that using any language that I know
03:25:30 <sssilver> but then I remembered Haskell
03:25:51 <sssilver> and here I am, asking for your input
03:26:01 <Gurkenglas> You'll have to know the key at compile-time, obviously, so you just make a record with a field for each k
03:26:50 <sssilver> Gurkenglas: the set of possible hashables for k though, you can't define all of them
03:27:00 <sssilver> because there's infinite amount of them
03:27:11 <Gurkenglas> What decides whether m[k] exists?
03:27:51 <sssilver> the hashmap type I suppose
03:28:57 <Gurkenglas> Can infinitely many m[k] exist at a time, or are all m constructed by starting empty and filling up one by one?
03:28:59 <sssilver> my intuition was -- "do value types apply here"?
03:29:21 <sssilver> Gurkenglas: not sure I understand the question
03:29:36 <sssilver> OK let me rephrase the problem
03:30:25 <sssilver> can you model a hashmap such that a program that uses it won't compile if you're accessing a nonexistent key on it
03:30:39 <sssilver> it seems that this would be theoretically impossible
03:31:02 <Maxdamantus> with dependent types you could have something like `get :: (map: Map k v) -> (key: k) -> hasKey map key -> v`
03:31:31 <Maxdamantus> but in Haskell you'd just produce a `Maybe v`
03:31:36 <bollu> bgamari: ping
03:31:43 <sssilver> Maybe you still need to unwrap runtime though
03:31:44 <Maxdamantus> ie, `get :: Map k v -> k -> Maybe v`
03:31:53 <sssilver> I mean yes Maybe is the closest you get
03:31:58 <Gurkenglas> Note that the dependent types one would require you to prove that the hashmap contains the key
03:32:19 <Maxdamantus> Yes, what Gurkenglas said.
03:32:48 <sssilver> guess I need to do some reading on dependent types
03:32:51 <Maxdamantus> but the proof (namely, the term of type `hasKey map key`) could be passed in by the caller.
03:33:17 <Gurkenglas> (Which he presumably got from putting it in the map, but then why not just lug around the value instead?)
03:33:52 <sssilver> aha, I think this is looking very much like it's possible!
03:34:01 <sssilver> makes a lot of sense
03:34:11 <Maxdamantus> so the caller could just check once that the key exists (checking existence of the key would give you something like `Either (hasKey map key) (not (hasKey map key))`) then multiple lookups can use the same proof.
03:34:32 <sssilver> so setting a key on the map gives you a type that says "that thing has been put"
03:34:41 <Gurkenglas> If you pass the proof to multiple lookups, why not pass the value to multiple sites that might want to look it up?
03:34:43 <sssilver> and then you only access the value on the map using that type
03:34:48 <Maxdamantus> Yes, you could also get that proof from the set operation.
03:35:07 <sssilver> Gurkenglas: because the value may be coming from an arbitrary place
03:35:10 <Gurkenglas> And if you only get a Maybe proof that's no better than the maybe value
03:35:13 <sssilver> that hasn't been set on the map
03:35:45 <Gurkenglas> sssilver, I mean if you get the proof from the map in order to give it to multiple sites, you could just get the value immediately and pass that to the multiple sites
03:36:34 <sssilver> Gurkenglas: I guess I'm confused by what you mean. To me the difference is that "the value" could be coming from anywhere, and the "proof" can only come from the map.set operation
03:36:42 <sssilver> I'm sorry I'm not an expert on this at all
03:36:47 <sssilver> just trying to keep my head above water at this point
03:37:17 <Gurkenglas> If you can get the proof from the set operation, then you have the value, because you would need to pass it to the set operation
03:37:39 <sssilver> ah, yes
03:37:41 <Gurkenglas> And if you can then pass the proof to whoever needs the value, then you have a way to pass things to them, and can pass the value instead
03:37:43 <sssilver> that is true
03:38:07 <sssilver> yes that makes sense
03:38:09 <sssilver> darn it
03:38:45 <spion> Can something like TypeScript's "mapped types" be achieved Haskell? e.g. given a Vinyl record type, create a new record type with the same fields where for each field the original type is wrapped using `return`
03:39:55 <Gurkenglas> I think the usual way to achieve this is to start out with each value wrapped in an arbitrary m which is originally Identity
03:40:09 <Gurkenglas> See any of the monad transformers
03:43:30 <sssilver> Gurkenglas: so just to continue the proof discussion, what type would this proof be?
03:43:39 <sssilver> sorry I know you could as well pass the value instead
03:43:46 <sssilver> but curious about the type system still
03:43:55 <Gurkenglas> I mean, the value would be a pretty good proof. jk
03:46:25 <ixxie> Has anybody tried shell scripting in Haskell using Turtle? I am considering that is a route to learn some Haskell....
03:51:28 <Gurkenglas> I mean, that's what Turtle does. Googling "haskell shell scripting turtle" finds https://hackage.haskell.org/package/turtle-1.3.2/docs/Turtle-Tutorial.html
03:54:02 <ixxie> Gurkenglas: I get that, what I am wondering is if anybody has experience using this in practice
04:07:33 <Athas> :t state
04:07:34 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
04:17:45 <dysfun> anyone know any good libraries for concurrent append-only logging?
04:18:06 <dysfun> the sort of logging that needs fsyncing to disk, that is
04:21:52 <dramforever> Question: What are some use cases of ekmett
04:21:55 <dramforever> ekmett's ad
04:22:03 <dramforever> Stupid hands
04:24:19 <dramforever> Forward mode is relatively easy, everyone knows. Reverse mode as implemented in ad looks extremely complicated, involving various unsafe stuffs, and doesn't really look too efficient
04:26:55 <troydm> what are the options for interprocess communications in Haskell, for example I have two Haskell apps running on linux box and i want them to be able to communicate as quickly as possible
04:26:58 <troydm> ?
04:27:45 <terrorjack> mmap is your friend
04:29:12 <troydm> terrorjack: u mean shared memory?
04:29:25 <terrorjack> yep
04:29:42 <troydm> terrorjack: ic, thx
04:30:01 <terrorjack> there's an mmap package on hackage, too
04:33:20 <troydm> terrorjack: mmap I think can only working with memory-mapped  files, not shared memory
04:35:26 <terrorjack> troydm: you need also to use shm_open call
04:36:42 <troydm> terrorjack: found this http://stackoverflow.com/questions/30446690/how-do-i-read-a-shared-memory-using-haskells-mmap-library
05:19:40 <Eduard_Munteanu> troydm, I'd use Unix-domain sockets. They are fast and easy to extend to TCP sockets if you need to.
05:20:17 <troydm> Eduard_Munteanu: not fast enough, shared memory is faster
05:47:52 <Gurkenglas> Is there a way to get ":t x" to display the haddock type signature at least when x is a single token?
05:48:32 <Tuplanolla> Does it not, Gurkenglas?
05:48:53 <Gurkenglas> :t at
05:48:55 <lambdabot> (Functor f, At m) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
05:48:58 <Gurkenglas> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-At.html#v:at
05:51:30 <Tuplanolla> :t emptyMap
05:51:31 <lambdabot> Ord keyAsGiven => M.Map keyAsGiven valueAsGivenToo
05:51:44 <Tuplanolla> That package must be doing something strange there.
05:52:31 <blender> is there any nicer way to plug in Maybe half way here https://pastebin.com/L9J5kQRc other than using MaybeT and a lambda ?
05:58:55 <Gurkenglas> blender, http://lpaste.net/320937101866565632
05:59:59 <blender> Grunkenglas: oh wow, what is for ?
06:00:09 <Gurkenglas> for is flip traverse
06:00:25 <blender> :t for
06:00:26 <Gurkenglas> (Oh wait you want for_ because you don't care for the results)
06:00:27 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
06:00:29 <Gurkenglas> :t for_
06:00:31 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
06:00:51 <blender> amazing
06:00:54 <Gurkenglas> Note that lines 3 and 4 are interchangeable, and then one sees that saveVersionFileToLocalCache should have lCacheDir go as the last argument so you can eta-reduce the lambda away
06:01:53 <blender> thanks, I will try. This might solve me quite a headache 
06:04:43 <blender> Gurkenglas: this was the original question but I am also very happy with for_ http://stackoverflow.com/questions/43408620/monad-transformer-and-applicative-maybe
06:07:12 <Gurkenglas> Hint: Each use of for is a hint that there might be potential to refactor until you can replace for with a pointfree use of traverse
06:09:42 <blender> I understand. In the the case this was not my code and I could not change the oder of the arguments, do you suggest wrapping it?
06:10:30 <Gurkenglas> Nah, I'd let it stay ugly because it deserves to be and maybe write a pull request to the library
06:46:16 <bollu> I can't have derivingAny and generalizedNewtypeDeriving on the same module?
06:57:29 <bollu> cocreature: ping
07:00:28 <cocreature> bollu: pong
07:01:27 <bollu> cocreature: can I create new passes in haskell?
07:01:33 <bollu> cocreature: or will I need to do that in C++?
07:02:12 <cocreature> atm you need to do this in c++
07:02:18 <bollu> hm, I see
07:02:20 <bollu> unfortunate
07:02:34 <bollu> but "at the moment" is encouraging, I'm assuming you have a plan to bind this to haskell? :)
07:02:44 <cocreature> not really
07:02:47 <bollu> ah, OK
07:02:47 <fotonzade> fellas this is a horrible language
07:03:13 <bollu> cocreature: what files will I need to change? I assume I need to show the haskell PassManager the existence of my passes, for example?
07:03:14 <cocreature> bollu: the problem is that the AST exposed by llvm-hs-pure is not really meant to be processed by passes.
07:03:18 <bollu> ah
07:03:56 <cocreature> also the overhead of converting to the Haskell representation only to then convert to the C++ representation again is silly
07:04:36 <bollu> right
07:13:58 <kamyar> hi all
07:14:04 <kamyar> please help mw with Scotty
07:14:13 <kamyar> How can I use jsonData function?
07:14:22 <kamyar> parsing a post body
07:14:36 <kamyar> All samples use request itself
07:17:31 <Gurkenglas> kamyar, that question is hard to understand. If it's possible to restate it as a request for an expression of some type, that'd be better
07:18:15 <kamyar> Gurkenglas: I read Scotty samples for writing a JSON API: they used decode function from Aeson
07:18:33 <kamyar> Gurkenglas: But I just want to use jsonData function which is inside SCotty
07:19:16 <kamyar> Gurkenglas: I just need to extract GPS info form a post body sent by client as JSON
07:20:47 <Gurkenglas> Do you have a lens for the GPS info?
07:22:08 <kamyar> Gurkenglas: I have a Type for use with Aeson
07:22:27 <dgonyeo> I'm using the DuplicateRecordFields extension, and getting a bizarre error: https://gist.github.com/dgonyeo/ee28124518528db6dcd4f46f8e8ae1d1
07:22:32 <dgonyeo> has anyone seen that before?
07:23:01 <dgonyeo> the `Web.Mastodon.Lib.Types` function is coming from another package
07:23:11 <Gurkenglas> Let me rephrase. Do you have a function that'd give you the data you want given the value that corresponds to the JSON?
07:24:21 <kamyar> Gurkenglas: I think it is simple: I just need to use Scotty to arse some request body given as JSON! Is it ambigious/
07:25:02 <kamyar> Gurkenglas: *Parse
07:25:27 <kamyar> Gurkenglas: Now I guess using SCotty's internal function jsonData may help.
07:27:15 <Gurkenglas> kamyar, it doesn't seem to be internal http://hackage.haskell.org/package/scotty-0.11.0/docs/Web-Scotty.html#v:jsonData
07:28:21 <kamyar> Gurkenglas: It is defined within Scotty! Is'nt it?
07:28:49 <kamyar> Gurkenglas: As like reuqest and param
07:31:59 <kamyar> Gurkenglas: Why this phrase does not work: location <- jsonData :: (Maybe Location)
07:33:16 <Gurkenglas> ActionM, not Maybe
07:34:03 <kamyar> Gurkenglas: But in the sample you see param "word"! See the signature: Text - > ActionM a
07:34:38 <Gurkenglas> What function has that type? What sample do you mean?
07:34:56 <kamyar> Gurkenglas: Just see the first sample
07:35:07 <kamyar> https://hackage.haskell.org/package/scotty
07:35:07 <Gurkenglas> The first sample from what list
07:35:21 <kamyar> Gurkenglas: on the top of the page
07:36:28 <Gurkenglas> 'beam <- param "word"' <- This is in the ActionM monad. Using PartialTypeSignatures, 'beam <- param "word" :: ActionM _'
07:37:15 <Gurkenglas> "jsonData :: Maybe Location" this asserts that jsonData is in the Maybe monad, but it isn't
07:37:24 <kamyar> Gurkenglas: Now I just want to use jsonData like the way
07:37:47 <kamyar> Gurkenglas: Like the way it used param
07:38:03 <Gurkenglas> Why did you add ":: (Maybe Location)"?
07:38:18 <kamyar> Gurkenglas: I need a Location variable
07:38:25 <kamyar> Gurkenglas: PLease guide me
07:38:49 <kamyar> Gurkenglas: I have not used Haskell for about 6 months after my firts project and somewhat forgotten things
07:38:52 <Gurkenglas> Perhaps you want ":: ActionM Location" or ":: ActionM (Maybe Location)" there, and probably "" works as well
07:40:09 <kamyar> Gurkenglas: Yes empty works but how would I make GHC know how to parse json items and extract properties?
07:41:23 <kamyar> Gurkenglas: Does inference like "latitude location" work?
07:42:51 <kamyar> Gurkenglas: I guess it worked! Thanks anyway!
07:48:32 <Gurkenglas> kamyar, you can have it show you the type it infers using ":: _" there
08:05:04 <bollu> if I have a package compiled with stack in another location
08:05:07 <bollu> can I have it reuse that?
08:05:18 <bollu> I don't want to build it from scratch (LLVM, so it is quite large)
08:08:21 <sbrg> bollu: yep, I think you can just point to the package
08:08:31 <sbrg> eh.. point to the package's directory in your other project's stack.yaml
08:10:06 <maerwald> why would stack build llvm
08:38:33 <bollu> maerwald: because I'm using llvm-hs
08:39:03 <maerwald> so you don't mean llvm, but llvm-hs?
09:08:10 <Gurkenglas> Is there a way to get ":t x" to display the haddock type signature at least when x is a single token?
09:08:21 <osa1> anyone here use language-c? I can't figure how to function arguments with types e.g. `(int x, int y)`. I'd love to see some examples
09:08:59 <osa1> what is "haddock type signature" ?
09:09:47 <c_wraith> Gurkenglas: if x was defined with an explicit type signature, :t x should show that type signature.
09:14:56 <Gurkenglas> @let myat = at :: At m => Index m -> Lens' m (Maybe (IxValue m)) -- c_wraith
09:14:58 <lambdabot>  Defined.
09:14:59 <Gurkenglas> :t myat
09:15:00 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
09:16:31 <Tuplanolla> It expands higher-rank type synonyms for some reason, c_wraith.
09:17:00 <c_wraith> so that really only impacts lens type signatures?
09:17:02 <Gurkenglas> :t over -- I think it's when they're in positive position
09:17:04 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
09:21:04 <Gurkenglas> @let negativelens = undefined :: Lens' s a -> s -> a -- Um.
09:21:05 <lambdabot>  .L.hs:161:16: error:
09:21:05 <lambdabot>      • Cannot instantiate unification variable ‘a0’
09:21:05 <lambdabot>        with a type involving foralls: Lens' s1 a1 -> s1 -> a1
09:21:22 <Sornaensis> negative lens?
09:21:50 <Gurkenglas> Something with a lens in negative position
09:22:28 <Gurkenglas> > let foo = view :: Lens' s a -> s -> a in foo -- UM.
09:22:29 <Sornaensis> what's a negative position
09:22:32 <lambdabot>  error:
09:22:34 <lambdabot>      • Couldn't match expected type ‘()’
09:22:36 <lambdabot>                    with actual type ‘Lens' s0 a0 -> s0 -> a0’
09:22:38 <Gurkenglas> the left side of an arrow
09:22:53 <Sornaensis> why is it called negative?
09:23:00 <Gurkenglas> Coz you consume the value instead of producing it
09:23:13 <Sornaensis> ah
09:23:33 <Gurkenglas> So if you're in double negative position you're positive again: the a in (a -> x) -> x
09:23:55 <Gurkenglas> (I mean, not sure whether it's called positive, but you're producing again.)
09:25:26 <Gurkenglas> :t let foo = view :: Lens' s a -> s -> a in foo -- why no error here, compared to the last one? :(
09:25:27 <lambdabot> Lens' s a -> s -> a
09:27:25 <antky> @help
09:27:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:27:34 <antky> hello
09:27:53 <antky> who is use lambdabot as hoogle
09:27:54 <antky> ?
09:28:20 <Theophane> *how you mean?
09:28:27 <maerwald> @hoogle lens
09:28:28 <lambdabot> package lens
09:28:28 <lambdabot> Control.Lens.Lens lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
09:28:28 <lambdabot> Lens.Micro lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
09:29:25 <Sornaensis> @hoogle (a,b) -> c
09:29:26 <lambdabot> Prelude fst :: (a, b) -> a
09:29:26 <lambdabot> Data.Tuple fst :: (a, b) -> a
09:29:26 <lambdabot> CorePrelude fst :: (a, b) -> a
09:30:14 <antky> @type map
09:30:15 <lambdabot> (a -> b) -> [a] -> [b]
09:30:50 <bbear> hi
09:31:04 <bbear> should I use fromJust ?
09:31:06 <bbear> no
09:31:08 <bbear> I shouldn't
09:31:30 <maerwald> bbear: ?
09:31:31 <bbear> I am struggling with monad composition : [] and Maybe
09:31:38 <c_wraith> bbear: there are rare occasions when it's ok, but even then it usually indicates a problem someplace else.
09:31:48 <bbear> yes
09:31:56 <Sornaensis> > sequence [Just 5, Just 6]
09:31:59 <lambdabot>  Just [5,6]
09:32:02 <bbear> say I have a list of [Maybe 
09:32:04 <bbear> ha yes
09:32:09 <bbear> but what is sequence exactly ?
09:32:10 <antky> hi eatman
09:32:15 <Sornaensis> :t sequence
09:32:17 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:32:22 <c_wraith> > sequence [Just 5, Nothing]
09:32:24 <lambdabot>  Nothing
09:32:28 <bbear> ha yes
09:32:28 <antky> how i see the man
09:32:33 <antky> hey
09:32:33 <Sornaensis> it moves the monad outside the traversable
09:32:41 <antky> anybody here me?
09:32:41 <maerwald> fromJust is fine if you know it's safe, but you should mark that spot, because next time you refactor it might not be safe anymore
09:32:49 <bbear> I was reading something related to that in RWH but I got lost.
09:32:52 <bbear> thanks.
09:32:58 <bbear> That was just what I looked for.
09:33:08 <fotonzade> fellows how do I define a type with a list of integers
09:33:27 <fotonzade> something like type Guy = Int [Int]
09:33:35 <fotonzade> I want to have a normal int with it too
09:33:43 <geekosaur> not with type, for starters
09:33:46 <fotonzade> ah
09:33:51 <Sornaensis> data Guy = Guy Int [Int] ?
09:33:52 <geekosaur> data Guy = Guy Int [Int]
09:33:56 <fotonzade> thank you very much
09:34:05 <bbear> how do I combine sequence with map
09:34:13 <bbear> is doing sequence.map ok ?
09:34:22 <bbear> it sounds kind of weird to me.
09:34:24 <geekosaur> :t sequenceA
09:34:27 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
09:34:37 <geekosaur> :t mapM
09:34:39 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:34:45 <geekosaur> @src mapM
09:34:46 <lambdabot> mapM f as = sequence (map f as)
09:35:06 <bbear> Is it ok to use Maybe in real code ?
09:35:18 <geekosaur> why wouldn't it be?
09:35:25 <ChaiTRex> bbear: Maybe.
09:35:30 <bbear> I mean I started to write some code and now I think using Maybe at some point is kind of the right thing to do.
09:35:47 <bbear> I am still a noob so I wonder if effective use of Maybe may occur sometimes.
09:37:04 <bbear> I mean at some point my goal is to keep my code reasonably straightforward before doing weird stuff.
09:38:07 <bbear> problem is that it seems when you start to use Maybe somewhere, it kind of goes everywhere in your code like a plague.
09:38:18 <bbear> what do you think about this problem ?
09:38:30 <Sornaensis> sounds like your code might have encapsulation problems
09:38:35 <bbear> instead of Nothing, I could use empty list
09:38:48 <bbear> Sornaensis: possible.
09:39:51 <fotonzade> I'm having trouble with this function
09:39:52 <fotonzade> http://paste2.org/eW09JLHG
09:40:07 <fotonzade> the error is Couldn't match expected type ‘[a] -> Bool’ with actual type ‘Bool’
09:40:37 <c_wraith> fotonzade: on line 5, you are passing 2 arguments to allEqual, but it only takes 1
09:41:10 <fotonzade> oh good lord thanks a lot c_wraith 
09:41:20 <c_wraith> fotonzade: that error says it expects it to take another argument, given how you are using it
09:41:31 <glguy> fotonzade: How about: allEqual [] = True; allEqual (x:xs) = all (x==) xs
09:42:03 <Sornaensis> :t all
09:42:04 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
09:42:05 <glguy> fotonzade: generally if you find yourself using head and tail should should be using a pattern match instead
09:42:26 <Sornaensis> bbear: what are you trying to do that needs Maybe
09:42:27 <fotonzade> hmm
09:42:31 <fotonzade> thanks for the tip glguy 
09:43:18 <bbear> I am trying to find the closest element of an argument in a list
09:43:56 <bbear> minimumBy (on compare abs((-) x) mynumber
09:44:02 <bbear> something like that
09:44:10 <bbear> :t minimumBy (on compare abs((-) x)
09:44:11 <lambdabot> error:
09:44:12 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:44:16 <bbear> :t minimumBy (on compare abs((-) x))
09:44:17 <lambdabot> error:
09:44:18 <lambdabot>     • Couldn't match type ‘Ordering’ with ‘(Expr -> Expr) -> Ordering’
09:44:18 <lambdabot>       Expected type: (Expr -> Expr) -> (Expr -> Expr) -> Ordering
09:44:34 <bbear> foo x= minimumBy (on compare abs((-) x))
09:44:38 <bbear> ha shit
09:44:52 <bbear> well I'm using minimumBy on a list
09:45:00 <bbear> the problem is : what do I do when the list is empty ?
09:46:10 <Sornaensis> :t minimumBy
09:46:12 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
09:46:41 <bbear> > let closestTo intList int = minimumBy  (on compare abs((-) int)) intList in closestTo [1,2,3,4,8] 7
09:46:43 <lambdabot>  error:
09:46:43 <lambdabot>      • Couldn't match type ‘Ordering’ with ‘(a1 -> a1) -> Ordering’
09:46:43 <lambdabot>        Expected type: (a1 -> a1) -> (a1 -> a1) -> Ordering
09:46:48 <bbear> >let closestTo intList int = minimumBy  (on compare abs((-) int)) intList in closestTo [1,2,3,4,8] 7
09:46:50 <Sornaensis> it might be easier to avoid calling the function with an empty list
09:47:59 <bbear> okay
09:48:07 <bbear> I'll try that. Youre right.
09:48:14 <bbear> thank you
09:52:54 <ph88> hi guys, does anyone know what's the best way to serve static html from spock ?  just read file ?
09:57:57 <ph88> lol searching for SpockM  https://spockm.com/
10:00:26 <ph88> does anyone know how i can get hot code reloading with spock ? right now i open ghci and run main .. then when i change the code i have to abort  :r and main again
10:04:13 <ph88> is this not working because the code is using monad transformers and i have to use liftIO ?  https://bpaste.net/show/ce86a34285a7
10:04:16 <iqubic> What do I have to import to be able to work with lenses in GHCi?
10:04:34 <ph88> iqubic, the lenses package .. there are several you can choose from
10:04:42 <iqubic> Like what?
10:04:45 <ph88> https://hackage.haskell.org/package/lens
10:04:59 <ph88> import Control.Lens & friends
10:05:25 <iqubic> ph88: Why am i getting an error in GHCi?
10:05:30 <ph88> iqubic, also pays off to google for "haskell lens tutorial"
10:05:42 <ph88> iqubic, dunno, what error on what code ?
10:05:44 <iqubic> Could not find module Control.Lens
10:06:13 <iqubic> trying to import Control.Lens, and I'm told that it couldn't find that module.
10:06:49 <geekosaur> you have to install it, probably
10:07:10 <monochrom> That will open a whole can of worms.
10:07:27 <iqubic> monochrom: What does that mean
10:07:40 <iqubic> Why do I have to install Control.Lens?
10:07:51 <geekosaur> because it's not part of a basic install
10:07:54 <geekosaur> very little is
10:07:57 <iqubic> Isn't that a part of core Haskell.
10:08:12 <iqubic> geekosaur: How do I install Control.Lens?
10:08:17 <geekosaur> no, the core contains only the things needed for the compiler to work
10:08:24 <iqubic> Oh.
10:08:35 <iqubic> What's provided in the Basic Install?
10:08:42 <iqubic> very little?
10:09:02 <geekosaur> ...and sticks to that because ghc has "interesting" version relationships, so anything shipped with it is effectively version-frozen. so we want it to be as small as possible to restrict versions as little as possible
10:09:08 <monochrom> The documentation that comes with GHC lists what's included.
10:09:24 <geekosaur> (cross-module inlining is great for speed and horrible for version management)
10:09:49 <iqubic> How do I install Control.Lens? With Stack?
10:09:59 <geekosaur> stack or cabal, yes
10:10:08 <Tuplanolla> You probably want to start with Microlens.
10:10:25 <iqubic> Why is that?
10:10:26 <geekosaur> also lens is specifically not in most distributions because it depends on half the ecosystem (so it can provide lenses for half the ecosystem...()
10:10:32 <Tuplanolla> It's a bit less overwhelming to the package manager and you.
10:10:54 <Tuplanolla> They're compatible anyway.
10:10:56 <iqubic> Tuplanolla: What the heck does that mean?
10:11:04 <geekosaur> what I just said
10:11:07 <glguy> If you start with lens you can figure out if you will mind losing what you lose when you drop down to microlens
10:11:42 <iqubic> glguy: I was learning about lenses all last night. I think I know my way around the lens library.
10:11:48 <geekosaur> microlens gives you the lens machinery but very little in the way of predefined lenses for various data types
10:12:10 <iqubic> Oh. So I want to start with that?
10:12:15 <geekosaur> lens gives you a whole bunch of predefined lenses as well.. but that means it depends on every package that defiines data types for which it provides lenses
10:12:22 <geekosaur> so lens has a HUGE dependency list
10:12:32 <iqubic> I'll start with Microlens.
10:12:44 <iqubic> Does that contain prisms and isos too?
10:12:52 <iqubic> Or just lenses and traversals?
10:12:54 <glguy> It has lots of small dependencies and dependencies on things you'll likely depend on yourself anyway
10:13:41 <iqubic> How do I install microlens in a place that I can always access the library?
10:14:04 <iqubic> Like how I can always import Data.Bits.
10:14:39 <geekosaur> ph88, you not only need to liftIO, you also need to deal with the fact that readFile is in IO but text is pure; you can't just use ($)
10:15:47 <fotonzade> Guys what if I wanted to sum a column in a matrix
10:15:54 <fotonzade> or wait
10:15:55 <fotonzade> no
10:16:06 <fotonzade> I want to check how many 1's there are in a matrix column
10:16:08 <fotonzade> [[Int]]
10:16:10 <monochrom> I might transpose the matrix and sum the row.
10:16:19 <monochrom> Likewise.
10:16:28 <monochrom> Not the only way but I would try it first.
10:16:37 <fotonzade> what would you do if you didnt know haskell
10:16:47 <monochrom> I would learn Haskell.
10:16:56 <fotonzade> nice
10:17:05 <iqubic> How do I install microlens in a place that I can always access the library?
10:17:06 <iqubic> Like how I can always import Data.Bits.
10:17:12 <iqubic> Is that possible to do?
10:17:38 <monochrom> It would be the same approach (transpose then work on row) in Scheme or SML or... as long as your matrix is [[Int]].
10:18:02 <iqubic> Isn't transposition kinda hard to do though??
10:18:03 <monochrom> I mean, you could also say "what about Java" but you wouldn't use [[Int]] for matrix in Java.
10:18:19 <fotonzade> I mean I'm working on stuff that is trivial with imperative programming
10:18:27 <fotonzade> but I don't know how to do anything in haskell
10:18:40 <Tuplanolla> That's a linked list of linked lists, fotonzade.
10:18:54 <monochrom> Well yeah [[Int]] is not exactly an ideal matrix. You should use a real array. PEBKAC.
10:18:55 <fotonzade> right
10:19:00 <tsahyt> so I've now seen most of the new idris book.
10:19:10 <tsahyt> I have to agree that it's very good at making you jealous of dependent types
10:19:38 <ph88> geekosaur, i don't understand why i can't use $, why doesn't liftIO take care of that ?
10:19:39 <tsahyt> and also of idris' ability to deduce code via proof search. but that should be possible to some degree in haskell too, right?
10:19:53 <tsahyt> I've found ghc-mod's auto command, but unfortunately ghcmod-vim doesn't implement it
10:20:00 <geekosaur> ph88, for the same reason show (readFile "foo") doesn't worl
10:20:03 <monochrom> So maybe my first instinct should have been "who the hell chose [[Int]]???!!!!"
10:20:09 <tsahyt> does anyone here use an editor with support for it?
10:20:12 <geekosaur> liftIO doesn't help there, >>= does
10:20:15 <iqubic> sumCol [] = 0; sumCol [[x:xs]:rest] = x + sumCol rest
10:20:15 <geekosaur> or fmap
10:20:44 <iqubic> that's a terrible way to do that. It uses no transposing at all.
10:20:59 <ph88> iqubic, i would forget about the "can always access the library" right now, worry about that later
10:21:17 <iqubic> ph88, how would you install microlens?
10:21:24 <ph88> fotonzade, i think there are also special packages for dealing with matrices .. perhaps more efficient too than using list of list
10:21:25 <geekosaur> if you always use stack, you can install lens/microlens in the default project
10:21:33 <ph88> iqubic, stack install microlens
10:21:38 <glguy> If you're using cabal you can: cabal install microlens
10:21:50 <geekosaur> there is no "always availabel" because that tends to cause conflicts; you need to specify what versions of things you want
10:22:08 <ph88> tsahyt, can you link to the new idris book ?
10:22:20 <geekosaur> well, for just running ghc there is a global package space, but anything you install there WILL end up causing version conflicts and massive pain. DON'T.
10:22:25 <tsahyt> ph88: https://www.manning.com/books/type-driven-development-with-idris
10:22:56 <ph88> geekosaur, ok but since i was using liftIO i (maybe unreasonably) was expecting     show (liftIO $ readFile "foo") to work ..   how am i thinking about this the wrong way ?
10:23:09 <ph88> thank you tsahyt 
10:23:13 <iqubic> geekosaur: is running "stack install microlens" a bad idea?
10:23:51 <ph88> iqubic, first you should start a new project with    stack new myproject simple
10:24:06 <iqubic> Too Late. :)
10:24:37 <iqubic> I just ran "stack install microlens" in my home directory.
10:24:50 <ph88> iqubic, you can still do it and then use the generated files as doner files to your project i think
10:25:14 <iqubic> Where would the library have been installed?
10:25:17 <ph88> iqubic, that will install microlens in your global project .. which is ok .. but not really that maintainable in the long run .. better to start a new stack project
10:25:34 <ph88> iqubic, probably now it's installed somewhere in  ~/.stack/global-project
10:25:35 <iqubic> And then reinstall?
10:25:43 <Tuplanolla> Skim this page, iqubic: https://docs.haskellstack.org/en/stable/yaml_configuration/
10:25:55 <ph88> you can leave it in the global project and just install it again in a project
10:26:15 <geekosaur> iqubic, the point of stack is to avoid those kinds iof problems
10:26:33 <geekosaur> but when you set up a new stack sandbox with stack init, you need to specify what you want to be visible inside it
10:26:42 <geekosaur> and stack will manage the rest
10:26:49 <iqubic> geekosaur: Can I remove it from my global project?
10:26:55 <ph88> i never use   stack init
10:27:04 <ph88> iqubic, you tied on disc space? :P
10:27:12 <iqubic> no.
10:27:12 <ph88> tight
10:27:19 <iqubic> I have plenty of disk space
10:27:21 <ph88> ok so leave it .. it doesn't harm for the moment
10:27:25 <geekosaur> well, or just have a stack.yaml somehow. stack init creates one for you if you don;t have obne
10:27:39 <monochrom> But perhaps it's recompilation time at stake.
10:28:00 <iqubic> Installing in my stack project told me that it just used the precompiled version.
10:28:15 <iqubic> Is that bad
10:28:17 <iqubic> ??
10:28:22 <geekosaur> iqubic, I would not, no, but it will depend on what you are doing. I think at this point you would leave it unless you find it starts to cause version conflicts; then you'll want to sart using separate projects with their own stack.yaml files specifying what is to be visible
10:28:26 <ph88> no it's good, saves you time to use precompiled version
10:28:33 <ph88> it was already compiled by you another time
10:28:51 <iqubic> Yeah, just now when I installed it into the global project.
10:28:52 <iqubic> LOL
10:29:03 <ph88> geekosaur, do i need to use fmap for readFile ?
10:29:06 <geekosaur> ph88, if that still confuses you, you need to read http://www.vex.net/~trebla/haskell/IO.xhtml
10:29:21 <ph88> geekosaur, i've read that 2 days ago when you linked it for someone else
10:29:25 <geekosaur> liftIO does not mean "ohg go ahead and pretend you are in IO here"
10:29:29 <bbear> how do you concatMap ?
10:29:31 <bbear> : concat
10:29:32 <ph88> it doesn't cover liftIO 
10:29:33 <bbear> :t concat
10:29:35 <lambdabot> Foldable t => t [a] -> [a]
10:29:44 <geekosaur> except in the sense where you are in a monad stack ewith IO at its botto
10:29:52 <ph88> i thought liftIO was a monad transformer thing
10:29:57 <geekosaur> it doers not help you in a pure context like show (some IO thing here)
10:30:01 <geekosaur> fmap will help you with that
10:30:21 <iqubic> So I have microlens installed.
10:30:25 <iqubic> How do I import it?
10:30:25 <ph88> nice one
10:30:35 <ph88> import PACKAGENAME in your source file
10:30:36 <glguy> ?hackage microlens
10:30:36 <lambdabot> http://hackage.haskell.org/package/microlens
10:30:43 <ph88> in the documentation it says the name at the top
10:30:45 <glguy> You can review the documentation to find out what modules there are
10:30:45 <iqubic> What's the module name?
10:30:48 <glguy> and what's in those modules
10:31:10 <kellytk> iqubic: You were going strong with learning Haskell when I went to sleep, I just woke up, here you are you're relentless :-D
10:31:11 <iqubic> What is an ASetter?
10:31:26 <iqubic> Can I assume that is it is the same as a lens?
10:31:36 <bbear> is that something comparable to object inheritance in haskell ?
10:31:37 <iqubic> Looking at the type of over.
10:31:50 <iqubic> :t over
10:31:51 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
10:32:46 <iqubic> What does the type synonym Lens s a expand to?
10:33:11 <rotaerk> hmm seems odd to me that pipes-cereal and pipes-binary haven't really been maintained
10:33:18 <ph88> iqubic, i would assume that you already read https://hackage.haskell.org/package/microlens-0.4.8.0/docs/Lens-Micro.html#t:ASetter
10:34:10 <iqubic> Ah, ASetter is a lens with Identity as the Functor
10:34:25 <geekosaur> bbear, is what?
10:34:33 <geekosaur> but in general there is no inheritance, no
10:34:46 <geekosaur> there's something that is sometimes described in a way that sounds like inheritance but isn't
10:35:05 <ph88> geekosaur, i'm confused what function am i suppose to fmap over  IO action readFile  ?
10:35:10 <iqubic> geekosaur: I said: "Can I assume that ASetter is the same as a Lens?"
10:35:23 <iqubic> That's what bbear thinks is inheritence
10:35:36 <Tuplanolla> The footer `div` in Haddock documentation is stuck in its initial position, overlapping the contents of the page. Is this a bug in Haddock's CSS or in Firefox's renderer?
10:35:40 <geekosaur> that's not inheritance, just specialization
10:36:04 <geekosaur> slotting in some or all of the types called for by type variables in another type
10:36:16 <iqubic> Right.
10:36:33 <geekosaur> ph88, in this case, it won;t help you. in the show case it would, since you would fmap show over it.
10:36:45 <iqubic> I just pointed out that ASetter is a Lens with Identity as Functor
10:37:10 <ph88> geekosaur, can i even use readFile together with   Web.Spock.get   or do i have to use another function here ?
10:37:13 <iqubic> good bye for now.
10:37:15 <iqubic> I have to go
10:37:17 <geekosaur> but for your case, you need something like:    s <- liftIO $ readFile "whatever"; Web.Spock.get "/test" s
10:37:18 <ph88> bye iqubic 
10:37:29 <ph88> oooh
10:37:38 <geekosaur> but I don;t know if liftIO is right there because I don;t know whether there is an IO directly accessible there
10:37:48 <ph88> let's find out :P
10:37:50 <geekosaur> I seem to recall you need to get at the Spock context or something like that
10:38:01 <ph88> oh you worked with spock ?
10:38:36 <geekosaur> no, that's why I'm uncertain
10:38:52 <geekosaur> have run into its types before but have never sat down to understand what's going on with them, so.
10:39:00 <ph88> well good that you know about spock context then ^^
10:39:04 <ph88> ok
10:39:13 <ph88> well that code didn't type check
10:40:44 <ph88> geekosaur, i got it to type check now with    Web.Spock.get "/test" (text s)   .. i think text was some spock function to return an action
10:41:11 <ph88> it looks a bit stupid though .. 
10:41:19 <geekosaur> the one I found was in Data,Text and just pcks a String to make a Text
10:41:35 <geekosaur> but, I suppose Spock might have its own just to confuse things
10:42:02 <ph88> oh and also .. it serves up the html as text hahah
10:42:26 <ph88> ActionCtxT () (WebStateM SqlBackend MySession MyAppState) ()
10:42:58 <ph88> maybe i should use  https://hackage.haskell.org/package/Spock-0.1.0.0/docs/Web-Spock-StaticMiddleware.html
10:51:31 <bbear> I'm stuck in my programming
10:51:43 <bbear> The architectural flaw in my program prevents me to go forward.
10:51:48 <bbear> What can I do ?
10:52:28 <rotaerk> refactor
10:52:53 <rotaerk> also don't prematurely engineer/abstract
10:54:08 <ph88> i'm trying to follow this blog about spock serving static files http://watchchrislearn.com/blog/2014/12/24/spock-basics/  it talks about SpockT but i can't find this in the package .. anyone know if there is a replacement for it ?
10:54:23 <ph88> bbear, what is the flaw ?
10:58:04 <portu_> I dont know where is apropriate to ask such question, (newbie) it's related with nix-shell, emacs, and haskell development, I can not figure out how to use nix-shell via emacs by default, that flycheck and everything else can work out of the box
10:59:29 <bbear> It's ok I adde pattern matching to cover my track
11:02:15 <ph88> when i have [String] and i want Text, is it more efficient to go to [Text] first or String first ?
11:02:30 <ph88> i use   pack  and  concat
11:03:45 <jle`> ph88: my intuition says concat then pack, but it's worth benchmarking
11:03:51 <ph88> ok :P
11:03:54 <jle`> this is the sort of question that can be easily answered by a few benchmarks
11:03:57 <jle`> :)
11:04:14 <ph88> in my case, simple benchmarks, but not easy :P
11:04:20 <jle`> actually i could see why pack then concat might be faster
11:04:25 <sbrg> we need criterion support in lambdabot!
11:04:38 <jle`> that'd be nice actually :o
11:04:49 <jle`> these questions are actually pretty popular on #haskell
11:04:57 <ph88> when i have   F Char   can i   fmap []   to make it   F String  ?  
11:05:14 <ph88> it looks weird
11:05:16 <jle`> fmap (:[]), if F has a Functor instance
11:05:20 <jle`> the robot monkey operator
11:05:25 <sbrg> fmap return works as well
11:05:26 <sbrg> or fmap pure
11:07:50 <ph88> robot monkey ! :D
11:08:02 <texasmynsted> robot monkey?
11:08:13 <ph88> (:[])
11:09:32 <texasmynsted> Does anybody here have an opinion about the Category Theory "The Beginner's Introduction" videos from Dr. Martin J.M. Codrington?
11:09:46 <jle`> fmap (:[]) (Just 3)
11:10:06 <texasmynsted> I just watched the first one and so far I am liking it.  I hope it will help me with the way that categories and types work in Haskell.
11:10:29 <ph88> > fmap (:[]) 'A'
11:10:31 <lambdabot>  error:
11:10:31 <lambdabot>      • Couldn't match expected type ‘f a’ with actual type ‘Char’
11:10:31 <lambdabot>      • In the second argument of ‘fmap’, namely ‘'A'’
11:10:39 <ph88> > fmap (:[]) (Just 'A')
11:10:41 <lambdabot>  Just "A"
11:10:48 <ph88> > :t fmap (:[]) (Just 'A')
11:10:50 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:11:11 <ph88> texasmynsted, good tip, i will check them out too :P
11:11:25 <ph88> are they on youtube ?
11:14:04 <ph88> is there a function in applicative that takes an input and returns ()  ?  like void in purescript
11:14:13 <sbrg> yep, void
11:14:15 <sbrg> :t void
11:14:16 <lambdabot> Functor f => f a -> f ()
11:14:21 <sbrg> well, a functor
11:14:26 <kamyar> Hello again
11:14:30 <ph88> hello kamyar 
11:14:47 <kamyar> What is the equivalent of a void function in Haskell? I mean when declaration
11:15:01 <jle`> what is a 'void function' ?
11:15:03 <kamyar> For example, can I say MyFunc :: Int -> a
11:15:07 <ph88> kamyar,  it's  ()
11:15:17 <kamyar> I mean a function with interger argument and no return
11:15:19 <ph88> kamyar,  MyFunc :: Int -> ()
11:15:28 <kamyar> ph88: Thanks!
11:15:31 <jle`> kamyar: all functions return something in haskell, by definition
11:15:39 <sbrg> () is the simplest type that we have, because it just contains one inhabitant: the value ()
11:15:41 <jle`> but () conveys no information, so it's like "returning nothing"
11:15:49 <sbrg> so it is commonly used to denote "i'm not really returning anything important"
11:15:55 <kamyar> jle`: I Guess Int -> () is equvalent of Int -> a
11:16:11 <sbrg> kamyar: no, because you can't write a function with the latter type
11:16:11 <jle`> kamyar: they are different
11:16:17 <ph88> kamyar, but this type signature is weird ... maybe better use    :: Int -> IO ()    because why you want to put arguments in a function that returns nothing ? 
11:16:31 <sbrg> except for "foo :: Int -> a; foo _ = undefined"
11:16:48 <jle`> kamyar: a function in haskell is described as some A -> B, that takes an A and returns a B.  so a function that returns nothing is not a function, by definition
11:16:56 <M-kevinliao> Hi, I'm wondering how people feel is the best way to get started with GUI programming in Haskell?
11:17:12 <jle`> but yes, `foo :: Int -> a` is not possible to write without being an error or an infinite loop
11:17:18 <jle`> try it and see why :)
11:17:30 <texasmynsted> Here is the link I found for the videos… https://www.youtube.com/playlist?list=PLm_IBvOSjN4zthQSQ_Xt6gyZJZZAPoQ6v
11:17:46 <sbrg> yeah, there are essentially two valid definitions: foo a = foo a and foo _ = _|_ 
11:17:49 <kamyar> Actually I need to write some wrapper functions for writing data into redis and can be called from anywhere in my program
11:17:52 <ph88> kamyar, when you use a lowercase letter or word like "a" it can have all types .. you can then constrain the types by using =>  .. but if you don't use => then "a" just means "everything"    .. it then depends on the context where you use your function what is expected to be returned.  But you can not create a function that takes an Int and can return every possible type i think
11:17:56 <sbrg> which are kind of equivalent really
11:17:58 <kamyar> What signature do u recommend?
11:18:17 <ph88> M-kevinliao, i feel electron :P
11:18:27 <ph88> thx texasmynsted 
11:18:30 <jle`> kamyar: if you have something that writes to redis, it'll probably be IO (), or something similar
11:18:46 <jle`> kamyar: you'll be returning a computation, like IO () or Redis ()
11:18:49 <kamyar> jle`: Thanks!
11:19:10 <jle`> remember that haskell functions are pure, so foo :: Int -> () is kinda silly
11:19:13 <M-kevinliao> ph88: As in ditch Haskell altogether and just write an electron app?
11:19:15 <jle`> the only implementation is 'const ()'
11:19:38 <jle`> M-kevinliao: write an electron app in haskell
11:19:44 <sbrg> M-kevinliao: don't have to ditch Haskell. I think you could roll Haskell for the backend, for example. and you could use ghcjs
11:20:02 <ph88> M-kevinliao, no you stay with haskell, but then for frontend you can use  ghcjs or purescript, and for backend you just use haskell  ... it's just my opinion. Ask other opinions
11:20:06 <sbrg> I would personally probably just go the web route, and either just make a website, or make an electron application using Haskell and probably ClojureScript
11:20:35 <ph88> you can also use Qt with haskell or whatever .. i would just go for electron because i have affinity with web development
11:20:39 <ph88> it's what you want
11:21:15 <Tuplanolla> I would go with Brick, because text ought to be enough, M-kevinliao.
11:21:34 <sbrg> yeah brick is actually pretty cool.
11:21:37 <sbrg> very easy to get up and running
11:21:49 <ph88> he ask for gui :P
11:22:18 <M-kevinliao> Oooh Brick and GHCJS both look interesting... It seems like the current state of GUI programming is a bit of a mess...
11:22:18 <Tuplanolla> It may be half-g, but it's full-u and full-i.
11:22:27 <M-kevinliao> Anyone ever work with GTK on Haskell?
11:22:46 <sbrg> i tried a bit. it's a pain IMO
11:22:49 <Tuplanolla> I installed it once.
11:22:53 <glguy> M-kevinliao: I've made UIs with vty, gtk, and web-interfaces in Haskell
11:22:55 <sbrg> there's also FLTKHS 
11:23:05 <glguy> M-kevinliao: which is better will depend on what you're building
11:23:46 <M-kevinliao> I don't know exactly what I'm building yet. I'm just playing around with all sorts of different things and exploring a final project for Richard Eisenberg's FP class at Bryn Mawr. :P
11:24:49 <ph88> glguy, what did you like the best ?
11:25:18 <glguy> M-kevinliao: Examples http://imgur.com/a/ISOxN http://imgur.com/a/yoUHm
11:25:48 <sbrg> haha, cookie clicker
11:25:58 <glguy> example: https://www.youtube.com/watch?v=2NG4sqXLZlk lua debugger via webb interface
11:26:11 <ph88> Cookie Calculator looks like a very serious app
11:26:13 <glguy> ph88: I don't think one is best
11:26:31 <ph88> glguy, just what you like the best ;)
11:26:51 <glguy> ph88: The cookies accumulation rate isn't going to accelerate itself :)
11:27:14 <Tuplanolla> I'd be very surprised if the answer was GTK+.
11:27:45 <ph88> i'd go with Qt over GTK myself
11:27:58 <glguy> I really don't have a favorite. I wouldn't have wanted to do any of those three projects in a different UI environment than they were done in
11:28:28 <ph88> was the web-interface with electron ?
11:28:40 <glguy> snap-server and jQuery
11:29:06 <glguy> That lua debugger project distributes as a library you link into your actual program
11:29:27 <glguy> so that project can't take over the UI, it just opens an HTTP server
11:33:06 <glguy> I can't speak to the merits of Qt vs Gtk from Haskell. I've only tried Gtk. As far as GTK goes I liked the gi-gtk package over the gtk package
11:36:27 <srk> glguy: I can compare gtk and qt from before and qt was more stable and easier to work with
11:36:49 <srk> now I find qt kind-of hard to compile
11:37:10 <srk> I would like to try implementing gui in gl like https://github.com/ocornut/imgui
11:38:03 <srk> looks doable with e.g. gloss. there's also UISF which does similar thing
11:40:56 <glguy> Oh, I forgot about gloss, but I've made some stuff with gloss and it was nice, too.
11:41:32 <sbrg> M-kevinliao: https://maxow.github.io/posts/creating-a-desktop-application-with-threepenny-gui-and-cef3.html this may be relevant to your question
11:41:55 <M-kevinliao> Oooh I'll take a look at that. Thanks sbrg
11:43:39 <glguy> Yinsh game: http://imgur.com/a/25DGm
11:44:41 <Cale> :D
11:45:14 <Cale> I haven't played Yinsh, but I played a bunch of the Gipf project games with a friend of mine in university.
11:50:37 <glguy> updated with circular slide rule and Hidden in Plain Sight knockoff: http://imgur.com/a/25DGm :)
11:51:48 <glguy> Just imagine the productivity improvements of using your computer as a sliderule to do computations instead of doing them directly with the computer !
11:56:26 <srk> cool
11:57:13 <srk> do you think it would be possible to compose gloss with another 3d GL framework?
12:08:17 <Tuplanolla> There's `not-gloss`, srk.
12:08:22 <Tuplanolla> I haven't used it yet though.
12:08:50 <srk> Tuplanolla: haha, nice
12:09:57 <infinity0> is there a function to turn a State s a into a StateT s m a ?
12:10:20 <hpc> whoever wrote not-gloss missed an amazing opportunity to name it matte
12:11:14 <srk> :))
12:12:48 <infinity0> oh i guess "hoist generalize" from mmorph does what i want
12:13:05 <pavonia> infinity0: mapStateT should also work
12:13:38 <sbrg> hpc: submit a bug report ;)
12:13:54 <infinity0> pavonia: ah thanks
12:22:09 <infinity0> on second thoughts "hoist generalize" is what i actually needed, i don't have anything to pass to mapStateT's first argument
12:24:08 <glguy> :t state . runState
12:24:09 <lambdabot> MonadState s m => State s a -> m a
12:26:43 <glguy> or
12:26:43 <glguy> mapStateT (return . runIdentity) :: Monad m => State s a -> StateT s m a
12:28:57 <kellytk> Is PureScript and improvement upon Haskell?
12:29:22 <bbear> is there bug in GHC ?
12:29:33 <glguy> yes
12:31:06 <bbear> known bugs ?
12:31:08 <jle`> kellytk: they're different
12:31:17 <glguy> bbear: Yes, known and unknown
12:31:38 <terrorjack> kellytk: A different approach. Some problems are addressed though (monolithic IO monad, etc)
12:33:37 <sbrg> @let isBugInSoftware = const True
12:33:39 <lambdabot>  Defined.
12:34:00 <jle`> isBugInSoftware :: Software -> Bool ...?
12:34:45 <sbrg> i guess it's a bit too polymorphic
12:42:27 <bbear> ok
12:42:32 <bbear> was wondering
12:42:42 <bbear> you know this post on quora 
12:43:34 <bbear> https://www.quora.com/Which-of-Haskell-and-OCaml-is-more-practical/answer/Jon-Harrop-2
12:44:06 <bbear> don't read this it will hurt you but basically it says that ghc is bogus.
12:44:17 <bbear> well was wondering if it was true to some extent.
12:44:19 <infinity0> glguy: oh, thanks
12:44:56 <bbear> Don't take me wrong. I am sure that GHC is a fine piece of software. I am even more sure that it is kind of a masterpiece in the actual CS world.
12:46:20 <terrorjack> Before another Haskell versus OCaml flamewar starts...
12:46:21 <glguy> bbear: No need to be hurt by Jon Harrop's words
12:46:25 <terrorjack> Why not learn both
12:46:34 <glguy> starting flame wars is basically what he does
12:48:51 <glguy> Perhaps by the elevated profile of his regular posts drive more business to his consulting service. I like to think there's a point to it all
12:51:52 <jgt> how can I test if two lists have any common elements?
12:52:15 <jgt> don't need the common elements, just a bool result
12:52:23 <bbear> map elem 
12:52:47 <sbrg> > let (x, y) = ("foo", "boo") in any (`elem` x) y
12:52:49 <lambdabot>  True
12:52:50 <jle`> map . elem, but that's pretty inefficient
12:53:03 <bbear> not sure
12:53:07 <jle`> > "foo" \\ "bar"
12:53:10 <lambdabot>  "foo"
12:53:19 <jle`> oh
12:53:26 <jle`> > "foo" `intersect` "bar"
12:53:28 <lambdabot>  ""
12:53:30 <bbear> yes
12:53:31 <jle`> > "foo" `intersect` "bara"
12:53:33 <bbear> intersect
12:53:33 <lambdabot>  ""
12:53:35 <jle`> > "foo" `intersect` "barao"
12:53:37 <lambdabot>  "oo"
12:53:45 <terrorjack> f = (null .) . intersect
12:53:59 <jgt> so maybe I'm going to have to convert the lists to sets, intersect them, and test the length of the result
12:54:05 <jle`> if your type is Ord, then yeah, you should use Set instead
12:54:18 <jle`> you do'nt need to test the length; just check if it's empty
12:54:24 <jgt> right
12:54:24 <bbear> :t elem
12:54:26 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
12:55:07 <jgt> thanks :) 
12:55:33 <the_2nd> I want to have a simple json api for my lib / program. What framework should I use? 
12:55:56 <bbear> :t any(map (isIn foo) bar) where isIn b a=elem a b
12:55:57 <lambdabot> error: parse error on input ‘where’
12:56:20 <bbear> let isIn b b = elem a b in any(map(isIn foo) bar)
12:56:23 <glguy> where isn't part of an expression
12:56:39 <bbear> >let isIn b a = elem a b in any(map(isIn foo) bar)
12:57:38 <bbear> >let intersect foo bar = let isIn b a = elem a b in any(map(isIn foo) bar) in intersect [1,2] [2,3]
12:57:53 <bbear> weird
12:58:25 <jgt> the_2nd: you can do a simple json api in Yesod. It's what I use for everything.
13:00:29 <geekosaur> the space is mandatory
13:00:33 <geekosaur> > 0
13:00:36 <lambdabot>  0
13:01:58 <bbear> > let (isIn a b = elem b a) in intersect foo bar = any (isIn foo) bar
13:02:00 <lambdabot>  <hint>:1:15: error:
13:02:01 <lambdabot>      parse error on input ‘=’
13:02:01 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
13:02:12 <bbear> > let ((isIn a b) = (elem b a)) in intersect foo bar = any (isIn foo) bar
13:02:14 <lambdabot>  <hint>:1:17: error:
13:02:14 <lambdabot>      parse error on input ‘=’
13:02:14 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
13:02:16 <bbear> wow
13:02:21 <bbear> anyway
13:02:22 <bbear> it works
13:02:23 <jle`> bbear: you can always test it out in private chat too :)
13:02:34 <bbear> intersect foo bar = any (isIn foo) bar
13:02:43 <bbear> surpinsingly concise
13:03:02 <bbear> yes irc chan is not made to run cod
13:03:04 <bbear> ghci is
13:03:07 <geekosaur> you can't do definitions like that in lambdabot. it is NOT ghci
13:03:28 * bbear is wondering who is lambda bot
13:03:29 <geekosaur> "> " evaluates expressions. not definitions
13:03:41 <geekosaur> you can use @let for (some) definitions
13:04:03 <geekosaur> @version
13:04:03 <lambdabot> lambdabot 5.1.0.1
13:04:03 <lambdabot> git clone https://github.com/lambdabot/lambdabot
13:05:19 <the_2nd> jgt, already used happstack for some projects. scotty seems nice too
13:08:13 <infinity0> oh, looks like hoist is exactly mapStateT and generalize is exactly return . runIdentity
13:08:27 <jle`> except less polymorphic
13:08:51 <jle`> hoist only lets you lift a (forall a. m a -> n a)
13:14:44 <jgt> the_2nd: if that's what you're comfortable with, then go with that :)
13:20:11 <simukis_> a recent ghc on my new ryzen is taking 24 minutes now to compile release+profiling libraries of aeson. Is that expected? 
13:20:42 <simukis_> to be honest I haven’t built anything haskell for long time so I don’t know if its ghc, aeson change or anything else
13:21:05 <simukis_> (and by 24 minutes I mean that it has taken 24 minutes of cpu time already and is still going strong)
13:21:50 <Athas> Is that including all dependencies?
13:22:05 <Athas> If so, that might easily be the case.  Especially if you didn't utter enough magic words to make it build in parallel.
13:23:54 <simukis_> Athas: no, it is stuck eating a single core for 25 minutes now
13:24:13 <simukis_> oh its done
13:24:21 <simukis_> so approx 25-26 minutes
13:28:44 <xcmw> Is there a way to use Maybe with freer-effects or extensible-effects?
13:29:01 <the_2nd> I have a function a -> IO (Either e a)
13:29:22 <the_2nd> and would like to apply that to many [a] in such a way
13:29:36 <the_2nd> that I get a IO (Either e [a])
13:30:23 <the_2nd> I tried using mapM but end up with e.g. IO ([Either e a])
13:30:42 <xcmw> map then sequence
13:30:51 <xcmw> sequence twice
13:32:12 <xcmw> squence . sequence $ map function array
13:32:21 <Gurkenglas> :t alaf Compose traverse :: (a -> IO (Either e a)) -> [a] -> IO (Either e [a])
13:32:23 <lambdabot> (a -> IO (Either e a)) -> [a] -> IO (Either e [a])
13:34:55 <the_2nd> Gurkenglas, alaf? 
13:35:09 <the_2nd> I mean the signature looks good, but no idea what to use there
13:35:35 <the_2nd> ??? f xs
13:36:23 <Gurkenglas> alaf Compose traverse f xs
13:37:21 <the_2nd> alaf from Control.Lens?
13:38:21 <Gurkenglas> yep
13:38:41 <Tuplanolla> It's just `alaf Compose f = getCompose . f . Compose`, the_2nd.
13:39:21 <the_2nd> I guess I have to read up on lenses then :D
13:39:27 <kamyar> Hello fellows
13:39:28 <Tuplanolla> You don't necessarily need it.
13:39:36 <xcmw> fmap sequence . sequence $ map function array    works if you confused by alaf
13:39:37 <the_2nd> but Gurkenglas 's version seems to work fine, thanks
13:39:42 <Gurkenglas> no, alaf Compose f g = getCompose . f (Compose . g)
13:39:49 <kamyar> please help me use messagepack to serialize an object
13:39:55 <Tuplanolla> Ah, indeed, Gurkenglas.
13:40:01 <xcmw> I missed an fmap the first time
13:41:28 <the_2nd> xcmw, yeah it didn't work before
13:41:31 <the_2nd> that version does
13:41:50 <kamyar> Please give me a sample code for using MessagePack
13:41:59 <the_2nd> I'll go with xcmw's version then, so I won't hate myself in the future in case I still don't know much about lenses ;)
13:43:01 <the_2nd> fmap sequence . mapM f xs
13:45:52 <Gurkenglas> > (`runState` 0) $ alaf Compose traverse (maybe (return $ Left "Nothing encountered") $ \i -> modify (+i) *> gets Right) [Just 3, Just 2, Nothing, Just 4] -- the_2nd, it doesn't short-circuit though - EitherT does
13:45:54 <lambdabot>  (Left "Nothing encountered",9)
13:46:25 <kamyar> PLease reply me
13:46:46 <Tuplanolla> :t getCompose .: traverse . fmap Compose :: (a -> IO (Either e a)) -> [a] -> IO (Either e [a]) -- You don't need lenses for this, the_2nd.
13:46:48 <lambdabot> (a -> IO (Either e a)) -> [a] -> IO (Either e [a])
13:46:53 <Gurkenglas> (ExceptT here I guess since that's imported by lens and technically does the same thing)
13:47:06 <Gurkenglas> :t alaf ExceptT traverse
13:47:08 <lambdabot> (Monad m', Traversable t) => (a -> m' (Either e' a')) -> t a -> m' (Either e' (t a'))
13:47:36 <Gurkenglas> > (`runState` 0) $ alaf ExceptT traverse (maybe (return $ Left "Nothing encountered") $ \i -> modify (+i) *> gets Right) [Just 3, Just 2, Nothing, Just 4] -- See, now it doesn't add the 4 after failing on the Nothing
13:47:39 <lambdabot>  (Left "Nothing encountered",5)
14:01:56 <the_2nd> thanks
14:31:57 <ij> Is stack docker's integration for only building or running too?
14:42:26 <kellytk> I'm attempting to get started with Haskell.  I've downloaded ghc 8.2.1-rc1 to my Mac and in the directory I type ./configure per the README.  An error is generated "-bash: ./configure: No such file or directory"
14:43:31 <ij> I think using homebrew should be easier than compiling ghc yourself.
14:43:58 <kellytk> Can it be used to get 8.2.1?
14:44:15 <Tuplanolla> Can you explain why you need 8.2.1?
14:44:51 <kellytk> No reason really, I'm curious about Backpack
14:45:07 <Tuplanolla> I'm quite sure you don't need 8.2.1.
14:45:30 <ij> You're starting with haskell, but curious about backpack? That's interesting.
14:45:47 <Tuplanolla> Besides installing another version is not a lifelong commitment.
14:46:09 <kellytk> Fair enough, I'll install whatever it has
14:54:44 <fotonzade> how do I divide two integers and get a float result?
14:55:29 <geekosaur> > fromIntegral 5 / fromIntegral 2
14:55:31 <lambdabot>  2.5
14:55:58 <fotonzade> ah so fromIntegral is a function?
14:56:04 <geekosaur> yes
14:56:12 <Sornaensis> :t fromIntegral
14:56:14 <lambdabot> (Num b, Integral a) => a -> b
14:56:38 <fotonzade> you guys are the best
15:09:57 <Lokathor> : iterate
15:09:59 <Lokathor> :t iterate
15:10:01 <lambdabot> (a -> a) -> a -> [a]
15:23:14 <miaumiau> hello channel!
15:23:29 <miaumiau> I'm having several questions around the implicit extensions
15:23:43 <miaumiau> as I'm trying to port some Scala code that uses global implicits
15:24:13 <miaumiau> and reproducing it from GHCi is proving difficult
15:24:42 <miaumiau> along with parametrizing one of the implicit types
15:25:13 <miaumiau> getComponentForEntity:: (?r:: Reader EntityId (Component a))   => EntityId -> a
15:25:22 <miaumiau> Component a is not valid there
15:25:30 <lyxia> oh you meant ImplicitParams
15:25:43 <miaumiau> yeah, sorry, translation of nomenclature :D
15:26:08 <lyxia> what's the error
15:27:53 <miaumiau> expected a type but (Component a) was a constraint
15:28:14 <miaumiau> was a -> has a kind
15:28:44 <lyxia> looks like Component is a typeclass
15:29:13 <miaumiau> yes!
15:29:26 <miaumiau> I'm trying to constraint a to only be a Component a
15:29:58 <lyxia> perhaps you meant (Component a, ?r:: EntityId -> a)
15:31:13 <miaumiau> getComponentForEntity:: (Component a, ?r:: Reader EntityId a)   => EntityId -> a
15:31:16 <miaumiau> that worked, cheers
15:31:24 <miaumiau> now, for the next trick :D
15:31:41 <miaumiau> how do I materialize an implicit in ghci
15:31:57 <miaumiau> getImplicitComponent id =   let ?r = reader (\id -> Health 3 id)   in getComponentForEntity id
15:32:07 <miaumiau> that works as a function definition
15:32:15 <miaumiau> let ?r = reader (\id -> Health 3 id)   in getComponentForEntity id 
15:32:20 <miaumiau> that doesn't work on the REPL
15:32:42 <miaumiau> best guess the repl doesn't have implicis loaded, only my file?
15:32:58 <miaumiau> I start it using Intero in emacs
15:44:09 <barryburd> Hello. I’ve posted code at https://users.drew.edu/bburd//Main1.hs. I’m trying to create a Convertible class that works with different kinds of values with units (units of length, units of currency, units of whatever). As part of this, I’m trying to define fromUS in terms of toUS (the conversion functions) inside the class definition so I don’t have to define both individually for each instance of the class. If you l
15:44:10 <barryburd> at my code, you’ll see that I awkwardly define a bunch of additional functions in order to make this happen. Is there a way to avoid defining all the additional functions (getNumber, newUS, newNonUS, and so on).
15:53:24 <biglambda> What is the right forum to ask cabal-install questions?
15:53:36 <Cale> Here's probably fine
15:54:28 <miaumiau> is there any way to declare global implicit parameters a la scala, that you can import and use in all functions in a module?
15:54:54 <Cale> There are implicit parameters, but not global implicit parameters
15:55:30 <miaumiau> scoped implicit parameters?
15:55:42 <miaumiau> as it is right now they're indistinguishable from partially applied functions
15:55:43 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters
15:56:14 <Cale> People don't really use them very much though
15:56:39 <miaumiau> yep I checked that, the let ?bla in functionWithImplicit isn't much of an improvement
15:56:44 <miaumiau> okay, let me ask you this then
15:56:54 <miaumiau> I have a function that requires a reader instance
15:57:05 <miaumiau> for the same type as the return
15:57:13 <miaumiau> the function inside runs the reader and little else
15:57:24 <biglambda> I’m trying to cabal-install wxHaskell on a Mac and I’m getting a strange error: error: Unknown option "--sysconfdir=
15:57:36 <biglambda> Here’s the full output: https://pastebin.com/0VFh2rS1
15:57:49 <biglambda> Kind of stumped
15:57:57 <miaumiau> how do I pass the reader to the function without having to explicitly use the instance every time
15:58:37 <miaumiau> biglambda probably a config issue in wxHaskell's side? haveyou tried a prior version
15:58:46 <ertes> (OT) is there a C++ equivalent for Maybe, perhaps in the STL?
15:59:08 <biglambda> Now sure how to do that with cabal
15:59:18 <Cale> biglambda: That's a rather old version of wxcore that you're trying to install
15:59:26 <Cale> biglambda: Maybe try a newer version?
15:59:48 <biglambda> Do I need to do that outside of cabal
15:59:59 <MarcelineVQ> ertes: optional perhaps
16:00:06 <geekosaur> ertes, std::optional I think
16:00:24 <Cale> cabal install wx-0.92.2.0
16:00:26 <Cale> try that
16:00:51 <ertes> oh, i tried that, but i tried "Optional" =)
16:01:08 <MarcelineVQ> when it was part of boost is maybe have been Optional
16:01:14 <MarcelineVQ> *it may have
16:01:55 <Cale> ah, hm
16:02:56 <Cale> I can't get that to build either, due to a constraint that wxdirect places on the process package.
16:03:17 <Cale> My guess is that it's just in a bad state because nobody's bothered to maintain these packages in the last year
16:04:01 <Cale> It's probably possible to straighten everything out, but you might have to download the packages and relax some of the version constraints
16:04:41 <biglambda> Ok I can do that.
16:05:09 <biglambda> What is the cabal command to override your sandbox with a directory you cloned from github?
16:06:20 <glguy> cabal sandbox add-source
16:06:29 <biglambda> Cool thanks
16:06:59 <glguy> biglambda: check out 'cabal help sandbox' for more
16:09:32 <Sornaensis> mmm big lambdas
16:10:49 <biglambda> substitution…. burp.
16:48:16 <patriknygren> http://lpaste.net/5557497396792918016
17:01:37 <miaumiau> can anyone please help me form a MonadReader instance?
17:01:47 <miaumiau> I cannot for my life find a simple example anywhere on the internet
17:02:31 <miaumiau> I want an instance that takes a type Int as environment and returns a Maybe String
17:07:47 <Cale> miaumiau: I'm not sure I understand
17:08:23 <Cale> miaumiau: That doesn't sound like a description of a MonadReader instance
17:08:43 <Cale> miaumiau: Do you just mean you want to write a Reader action?
17:13:05 <sophiag> Cale: i'm still struggling with this eval function :(
17:13:46 <sophiag> i decided to take a different approach i think will work, but now i have a whole new set of type errors...
17:13:49 <Cale> sophiag: hmm
17:14:04 <sophiag> want to take a look? eh? eh?
17:14:40 <Cale> sure
17:15:51 <sophiag> i decided instead of using a list comprehension i'd take the permutations of each list and then put them back inside the records. then i could use when to recursively map over them and filter by the lambdas in the other records when the strings match, then return only what remains in the lists
17:16:11 <sophiag> it's only confusing looking because of all the data constructors... http://lpaste.net/354622
17:17:38 <Cale> Well, the top type error there is just the way that things are associating
17:17:53 <Cale> Well, hmm
17:17:59 <Cale> Amb isn't a monad
17:18:08 <sophiag> no, it's just a record
17:18:10 <Cale> So "when" doesn't exactly make sense
17:18:13 <Cale> :t when
17:18:15 <lambdabot> Applicative f => Bool -> f () -> f ()
17:18:23 <sophiag> oh, i was looking for a one-armed if
17:18:30 <Cale> Ah, right, it's been generalised a bit, but still
17:18:31 <sophiag> when seems like that, but only for applicatives
17:18:49 <Cale> when b x = if b then x else pure ()
17:19:18 <sophiag> in this case should i just use if and return unit?
17:19:25 <sophiag> on the else i mean?
17:19:35 <Cale> Well, your type signature says you're meant to be producing an Amb
17:19:45 <Cale> So if your type signature is right, then you need to pick an Amb to produce.
17:19:47 <sophiag> oh, wait. that's wrong
17:19:58 <sophiag> it should be [Amb]
17:20:12 <Cale> ah, so maybe you'd like to produce an empty list in the other case?
17:20:31 <sophiag> no, i'd like to keep the Amb as is
17:20:37 <sophiag> i.e. not filter it
17:20:59 <Cale> ahh
17:21:13 <Cale> So you want to actually filter the list
17:21:15 <sophiag> basically list comprehensions were becoming intractable so i went this way so i could just recurse down one of the lists of record (the Requires)
17:21:27 <iqubic> Alright folks. I have a question. What the heck is a Prism???
17:21:29 <Cale> Or indeed, use a list comprehension with some condition
17:21:40 <iqubic> Anyone care to help me understand prisms?
17:21:49 <Cale> iqubic: It's a little like a lens, but with the ability to fail to match
17:21:57 <sophiag> hmm
17:22:05 <iqubic> What does that mean Cale??
17:22:19 <sophiag> i'm interested in this as well 
17:22:38 <Cale> iqubic: So it's like a traversal which traverses 0 or 1 values
17:23:03 <iqubic> Oh. Like maybe is only 0 or 1 values
17:23:28 <sophiag> you'd use a prism instead of a lens when you have a Maybe type in nested records?
17:23:35 <sophiag> or when?
17:23:47 <sophiag> err actually that doesn't make sense
17:24:26 <Cale> sophiag: Well, that might make sense -- if the thing you're going to be focusing on might or might not exist in any given piece of data.
17:24:43 <sophiag> yeah i was trying to think when that would actually be the case tho
17:25:01 <sophiag> with Maybe you've designed it that way and could just get a Nothing with a lens
17:25:25 <Cale> Well, you could have a lens that extracts the Maybe field
17:25:34 <sophiag> right
17:25:34 <Cale> Or you could have a prism which extracts the contents of that Maybe
17:26:16 <Cale> :t _Just
17:26:18 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
17:26:20 <Cale> heh
17:26:23 <sophiag> oh i see. yeah of course most of the time you wouldn't want to return Nothing
17:26:44 <Cale> such abstractions
17:26:45 <sophiag> vat?
17:26:54 <Sornaensis> @info Choice
17:26:55 <lambdabot> Choice
17:26:56 <Cale> You can choose to read p there as (->)
17:27:05 <Gurkenglas> We need a version of :t that doesn't automatically inline type synonyms in positive position
17:27:35 <Gurkenglas> ...that contain a forall. I'm guessing that's the criterion.
17:27:36 <Cale> So that'd become (a -> f b) -> (Maybe a -> f (Maybe b))
17:27:53 <sophiag> ah that's much more legible
17:28:14 <Sornaensis> @src Choice
17:28:14 <lambdabot> Source not found. It can only be attributed to human error.
17:28:22 <Cale> > _Just (\x -> Identity (10*x)) (Just 5)
17:28:25 <lambdabot>  Identity (Just 50)
17:28:47 <Cale> Sornaensis: https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Prism.html#t:Choice
17:29:42 <iqubic> So what does a prism do??
17:29:54 <iqubic> Is _head a prism?
17:30:06 <iqubic> Because what if you give it to an empty list.
17:30:30 <Gurkenglas> iqubic, if I understand it right a Prism' s a is a witness that the type s is a disjoint union of a and something else, as a Lens' s a is a witness that the type s is a product of a and something else
17:30:31 <Cale> right, that'd make a good example
17:31:07 <iqubic> Cale, did I come up with a good example??
17:31:35 <iqubic> How does prism work?
17:31:48 <sophiag> Gurkenglas: that's a very good explanation
17:31:48 <iqubic> It's a 0 or 1 element traversal?
17:31:51 <iqubic> Is that all?
17:32:17 <iqubic> What is a disjoint union and a product??
17:33:05 <Gurkenglas> Umm, rephrasing: If I understand it right a Prism' s a is a witness that s looks like Either a b for some b, as a Lens' s a is a witness that s looks like (a, b) for some b
17:33:34 <iqubic> I see.
17:33:49 <iqubic> Either a b is an ADT.
17:34:08 <iqubic> And (a, b) is a single constructor data type.
17:34:37 <Gurkenglas> So prisms let you say something about types being subtypes of others
17:34:48 <iqubic> How so?
17:35:22 <Gurkenglas> a in that sense would be a "subtype" of Either a b because you can turn each a into an Either a b, and every Either a b might be an a
17:35:28 <iqubic> With either, you have two options for what the type can be. With (,) you only have single option.
17:35:45 <iqubic> Gurkenglas: That's right.
17:36:12 <iqubic> It gives you the functions (a -> Either a b, Either a b -> Maybe a)
17:36:27 <sophiag> Cale: i updated that paste if you're still looking http://lpaste.net/354622
17:36:30 <Gurkenglas> And like a lens can be described as a getter-setter pair, a prism can be described as a pair of that type you just wrote
17:37:20 <Gurkenglas> (And the "prism laws" would be that going from the smaller type into the larger and back lands you where you started and that kinda stuff)
17:37:31 <iqubic> Every Square is a Rectangle, but not every Rectangle is a Square.
17:38:08 <iqubic> And whether you give me 'Square 5 or Rectangle 5 5' it's the same shape.
17:38:10 <Gurkenglas> So you could write a Prism [a] (a,a,a), to say that the three-element lists are a subtype of all lists
17:38:22 <Gurkenglas> *Prism'
17:38:53 <iqubic> However if you give me 'Rectangle 10 5' I can't turn that into a square.
17:39:22 <iqubic> So you get Prism' Square Rectangle
17:39:34 <sophiag> down to three error :p http://lpaste.net/354622
17:39:37 <Gurkenglas> No, Prism Rectangle Square, because the Squares would be a subtype of the Rectangles
17:39:40 <Gurkenglas> *'
17:39:46 <iqubic> I see.
17:40:19 <iqubic> And the two functions are: toRectange Square x = Rectangle x x
17:41:00 <iqubic> and toSquare Rectangle x y = if x == y then Just (Square x) else Nothing
17:41:44 <iqubic> Or something rather similar to that.
17:41:47 <iqubic> I'd assume
17:41:57 <iqubic> Not sure how to create a prism though.
17:43:06 <iqubic> Like i get that Lens s t a b says that when the small part s turns into the small part t, data a becomes data b
17:43:07 <Cale> sophiag: Okay, so now your problem is that you have map applied to (filter ...) which is a list, rather than a function
17:43:35 <Cale> sophiag: Maybe you intended to map a particular function over that list?
17:43:38 <sophiag> yeah, i've solved the error in the second part of filter
17:43:52 <iqubic> I have no idea what Prism s t a b means.
17:44:03 <Cale> Or maybe you intended map (filter f) xs
17:44:07 <sophiag> what i intend is to filter the nested lists inside (map ListVal [ambVal x]))
17:44:12 <Cale> right
17:44:14 <Cale> okay
17:44:14 <sophiag> yes the latter
17:44:15 <Gurkenglas> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Prism.html#v:prism'
17:44:31 <sophiag> so that appears to be my last error
17:44:47 <sophiag> although i have a *whole* other issue that will likely prevent me from seeing whether this works...
17:45:33 <iqubic> Gurkenglas: what the heck is a choice, or do I not need to know for now?
17:46:06 <iqubic> Is that like how Either a b can be Left a or Right b?
17:46:09 <iqubic> Or what?
17:47:48 <iqubic> Also, Gurkenglas that page on Prisms mentions Isos. What are those?
17:47:58 <Gurkenglas> iqubic, I don't even know; it's what is needed to be able to get back either of the functions of the pair by setting some parameter to some newtype, like lenses use Identity and Const for setting and getting
17:48:18 <Gurkenglas> @what Choice is
17:48:18 <lambdabot> I know nothing about choice.
17:48:57 <iqubic> How does one write a Lens as a Getter and a Setter?
17:48:58 <Gurkenglas> iqubic, an Iso' s a is a witness that s and a are the same
17:49:08 <iqubic> Really?
17:49:17 <Gurkenglas> In the sense of there being functions s -> a and a -> s
17:49:24 <Cale> iqubic: https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Prism.html#t:Choice
17:49:25 <iqubic> I see
17:49:31 <Gurkenglas> Like, you can build an Iso' (Identity a) a
17:49:54 <iqubic> Cale: That's a rabbit hole I don't want to dive down.
17:49:54 <Cale> oh, they don't actually have the methods there
17:50:04 <iqubic> I don't ever know what a profunctor is.
17:50:34 <Cale> In that case, don't worry about it, all you need to know is that (->) is an instance
17:50:48 <Gurkenglas> And then there's Equality', which is a witness that two types aren't even kept apart by the compiler. You can build an Equality' a a :P
17:50:52 <iqubic> Of Choice.
17:51:02 <Cale> yeah
17:51:18 <iqubic> Gurkenglas: what does Equality' do?
17:51:40 <iqubic> Is that like saying there is a type synonym between a and b?
17:51:52 <Gurkenglas> sure why not
17:52:03 <iqubic> Is that the simple way of explaining it?
17:53:33 <Gurkenglas> Mentioning type synonyms makes it seem like that's their purpose, but what Equality' s a does is gurantee that s is a
17:54:04 <Gurkenglas> (While also being usable as an Iso', Lens' or Prism' if you need that for some reason :P
17:54:06 <Gurkenglas> *)
17:54:25 <Gurkenglas> (Also Isos can be used as Lenses and Prisms)
17:55:21 <iqubic> Is this an Iso'? 
17:55:49 <iqubic> toPair f = ((f True), (f False))
17:56:23 <iqubic> fromPair (x, y) = if True then x else y
17:56:24 <Gurkenglas> Can be turned into one, yep
17:56:45 <Gurkenglas> iso fromPair toPair is what does it (or iso toPair fromPair if you want it the other way)
17:56:56 <iqubic> no '?
17:57:20 <Gurkenglas> The same function is used to construct Isos and Iso's
17:57:24 <iqubic> it converts between (a, a) and (Bool -> a)
17:57:49 <iqubic> I like that.
17:57:54 <c_wraith> That Iso is just a witness to the equality of x * x and x^2
17:58:02 <iqubic> really?
17:58:05 <iqubic> How so?
17:58:19 <c_wraith> Algebraic interpretation of data types.
17:58:26 <c_wraith> Product types aren't called that accidentally.
17:58:33 <c_wraith> They correspond to multiplication.
17:58:45 <c_wraith> It turns out functions correspond to exponentiation.
17:58:49 <iqubic> c_wraith: Can I see an example of a product type?
17:58:56 <c_wraith> (,) is a product type
17:59:09 <c_wraith> Anything with multiple arguments to the same constructor is a product.
17:59:17 <Gurkenglas> If the number of values in the result type is x, then the number of possible pairs of values of that result type is x * x
17:59:19 <bollu> c_wraith: I was thinking about this: do you have any reasonable way to define logarithms?
17:59:35 <bollu> c_wraith: I was considering log_a(b) = "number of copies of a in b" which works out for a lot of cases
17:59:37 <c_wraith> bollu: I'm the wrong person to ask about that - I only know the basics.
18:00:02 <Gurkenglas> And the number of values in a function type with that same result type is x to the power of the number of values in the argument type
18:00:19 <iqubic> Is (->) a product type?
18:00:25 <iqubic> or No?
18:00:39 <c_wraith> No.  It doesn't have an algebraic constructor.  It's a bit weird.
18:00:45 <Gurkenglas> "a -> b" contains (number of values in b) ^ (number of values in a) values
18:00:46 <iqubic> Alright.
18:01:15 <Gurkenglas> (disregarding bottom-stuff)
18:01:30 <Cale> Yeah, it's an exponential.
18:01:48 <iqubic> So how does an iso act as a lens, or a traversal?
18:02:23 <iqubic> Wait, Isos aren't traversals, their prisms.
18:02:30 <iqubic> and Lens's
18:02:37 <iqubic> How does that work??
18:02:43 <Gurkenglas> Well prisms are traversals and lenses are traversals so isos are traversals too
18:02:56 <c_wraith> Carefully chosen types so that they unify correctly :)
18:03:11 <iqubic> Can I see the types of these things?
18:03:21 <sophiag> Cale: i don't understand the errors at this point at all. the two seems totally conflicting: http://lpaste.net/354622
18:03:26 <c_wraith> @hackage lens
18:03:26 <lambdabot> http://hackage.haskell.org/package/lens
18:03:38 <Gurkenglas> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Iso.html#t:Iso <- type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
18:03:50 <c_wraith> iqubic: I mean, we can point things out, but the types are one of the main things listed in hackage documentation
18:04:48 <Gurkenglas> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Lens.html#t:Lens <- type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
18:05:04 <Gurkenglas> An Iso can be treated as a lens by setting p to (->)
18:05:17 <iqubic> What is the point of Equality a b a b?
18:06:36 <Cale> sophiag: Well, ambVal x :: MultiList
18:06:59 <Cale> sophiag: But you're applying filter to it, so it must be a list of some sort
18:08:09 <iqubic> Gurkenglas: How does one create a prism?
18:08:26 <sophiag> oh, so since i wrapped the lists in that data type it's failing to typecheck?
18:08:41 <Gurkenglas> iqubic, you write that in the sort of places where a ~ b. I'd guess that happens once you start needing to be able to let the user choose the types you work with at runtime
18:08:58 <sophiag> i'm doing so much type contortion here. there's got to be a better way. i'd like to get it at least working correctly first tho
18:09:02 <Gurkenglas> *where you write things like "a ~ b" constraints
18:09:13 <Gurkenglas> iqubic, prism' constructs Prism's
18:10:02 <iqubic> what does that ~ mean?
18:10:09 <Gurkenglas> That a and b are equal.
18:10:35 <Gurkenglas> (Not in the (a -> b, b -> a) exists way, in the "those functions are both id" way)
18:11:05 <iqubic> why does the ~ operator exist, and what does it do???
18:11:38 <Cale> ~ is type equality
18:11:45 <Gurkenglas> As I just said, I'm guessing you need that once you stop knowing everything about your types at compile time.
18:12:36 <Cale> sophiag: Well, values of type MultiList aren't literally lists, they're one of those constructors, applied to a list.
18:13:22 <sophiag> i think i should use that helper function i made mapMultiList that unwraps them and wraps them back up
18:13:46 <sophiag> it's not quite working tho
18:13:48 <Gurkenglas> Like, when you want to write a server whose data structures you can refactor without restarting the server
18:15:12 <Gurkenglas> Can we get ircbrowse out of the topic until it's fixed?
18:17:06 <Cale> I suppose we could, but how long is it going to be down?
18:24:00 <peterbecich> this alternative to ircbrowse seems to work: http://irclogger.com/.haskell-beginners/2017-04-16
18:27:06 <xcmw> Which is better freer-effects, extensible-effects, or transformers? I just discovered effects systems and they seem better than monad transformers. Is there a catch?
18:28:40 <Gurkenglas> How long has it been down? I'd check when the first complaint was but ircbrowse is down
18:30:18 <Gurkenglas> (I complained once on 17th march)
18:33:39 <iqubic> What operations can you perform in Isos?
18:35:45 <xcmw> iqubic: Are you talking about the lens library?
18:36:03 <iqubic> Yes.
18:36:06 <iqubic> I am indeed.
18:36:13 <Gurkenglas> rtfm http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Iso.html
18:36:16 <ertes> edwardk: why does PlanT in 'machines' have a failure mode?
18:37:21 <Gurkenglas> (Dont forget that you can consume them in every way that works for traversals prisms and lenses tho)
18:38:42 <xcmw> iqubic: Iso means you can go from a to b and from b to a. I'm not quite sure what your question is.
18:40:33 <ertes> iqubic: you can do everything you can do with lenses, but you get an extra operation 'from'
18:40:45 <ertes> :t _polar
18:40:47 <lambdabot> (Functor f, Profunctor p, RealFloat a) => p (a, a) (f (a, a)) -> p (Complex a) (f (Complex a))
18:40:51 <ertes> :t from _polar
18:40:53 <lambdabot> (Functor f, Profunctor p, RealFloat a) => p (Complex a) (f (Complex a)) -> p (a, a) (f (a, a))
18:41:23 <ertes> > (0 :+ 1) ^. _polar
18:41:26 <lambdabot>  (1.0,1.5707963267948966)
18:41:33 <ertes> > (0 :+ pi/2) ^. from _polar
18:41:35 <lambdabot>  error:
18:41:35 <lambdabot>      • Couldn't match type ‘(a, a)’ with ‘Complex Double’
18:41:35 <lambdabot>        Expected type: Getting (Complex a) (Complex Double) (Complex a)
18:41:43 <ertes> > (0, pi/2) ^. from _polar
18:41:46 <lambdabot>  0.0 :+ 0.0
18:41:52 <ertes> > (1, pi/2) ^. from _polar
18:41:54 <lambdabot>  6.123233995736766e-17 :+ 1.0
18:53:18 <sophiag> i'm ending up with adts that are both recursive and have data constructors for other adts, which is creating a lot of problems wrapping and unwrapping them. what's the better way to handle these situations?
18:53:57 <sophiag> it's littering my code with helper functions and greatly overcomplicating things
18:54:25 <Axman6> can you give an example?
18:55:14 <sophiag> sure one sec
18:55:34 <Gurkenglas> sophiag, have you heard of lens? x)
18:56:19 <sophiag> ha, yeah i was thinking of lenses
18:56:22 <peddie> sophiag: perhaps classy lenses / prisms?
18:56:32 <sophiag> that would at least solve the problem of all the helper functions
18:56:44 <sophiag> i still feel like i could structure the data better, but idk
18:56:55 <sophiag> here's a snippet of what i'm dealing with rn: http://lpaste.net/354622
18:58:26 <sophiag> really, i'd just like to get that function working. but i've come up against problems like this soooo many times in this tiny program it's aggravating
18:58:53 <sophiag> like it's less than 300 lines and there's even one more adt than that...
19:01:01 <peddie> sophiag: I have no idea what's going on in this program yet, but why have MultiList instead of just a list of AmbVals?
19:01:15 <sophiag> because then the lists can be heterogenous
19:01:46 <peddie> sophiag: line 71, do you want fromJustAmbVal . reqVal r    instead of   fromJustAmbVal $ reqVal r  ?
19:01:58 <peddie> sophiag: oh, the entire list must be of the same type
19:02:04 <peddie> ok
19:02:09 <sophiag> i tried that before, but application is giving me a more sensible error
19:02:30 <peddie> or perhaps `fromJustAmbVal . reqVal` ?
19:02:39 <peddie> oh wait
19:02:44 <peddie> I misunderstood, ignore that
19:03:06 <peddie> I don't really grasp what this program is doing
19:03:11 <sophiag> i used composition before just like this and it was fine. but that was in a list comprehension, not as the predicate to filter
19:03:18 <sophiag> it's part of a dsl
19:03:46 <sophiag> i could describe the whole thing, but it's really besides the point re: type errors
19:05:34 <peddie> sophiag: so your `filter` call is meant to have a function as its first argument, but instead it has a `Bool`
19:05:44 <sophiag> oh
19:05:49 <peddie> the bit in braces doesn't take any arguments
19:05:50 <sophiag> so i can problem ommit that helper then?
19:06:10 <sophiag> do you mean parentheses?
19:06:17 <sophiag> and then...which ones?
19:06:52 <peddie> `fromJustAmbVal $ reqVal r` is of type `Bool`
19:06:56 <peddie> :t filter
19:06:57 <lambdabot> (a -> Bool) -> [a] -> [a]
19:07:06 <sophiag> ok, so you can see from the types that the function there is not going to work in a filter, right
19:07:14 <sophiag> hence why i used the helper?
19:07:48 <peddie> I don't know what you mean when you say "the helper," but I don't understand how any additional code could fix this type mismatch for you
19:08:13 <sophiag> what?
19:08:19 <peddie> it's not a function, so it's definitely not going to work in a filter
19:08:21 <sophiag> haskell is turing complete so, yes, i can write this function
19:08:42 <sophiag> i provided everything so it's self-explanatory
19:08:49 <peddie> sophiag: ok, you've totally lost me now :)  not sure how turing completeness comes into play here.  can we back up and start over?
19:09:10 <sophiag> you're saying that (AmbVal -> Maybe AmbVal) is not a function?
19:09:14 <sophiag> that's the type of a function
19:09:21 <peddie> what value has that type?
19:09:22 <sophiag> you said "it's impossible"
19:09:34 <sophiag> the value you've been discussing this entire time
19:09:59 <sophiag> the one you said isn't a function has that type and so is clearly a function
19:10:00 <peddie> `reqVal r` has that type, which is a subset of the value I'm discussing
19:10:18 <sophiag> and it's not the correct type for the predicate to filter
19:11:01 <peddie> so you're applying `fromJustAmbVal :: Maybe AmbVal -> Bool` to an argument `reqVal r :: AmbVal -> MaybeAmbVal`
19:11:16 <peddie> but `fromJustAmbVal` does not want an argument with a function type like that?
19:11:33 <sophiag> yes, that's why i'm asking a question
19:11:34 <peddie> shouldn't you rather compose them with `.` and get a value of type `AmbVal -> Bool` ?
19:11:47 <sophiag> that's no better
19:11:55 <sophiag> have you tried that?
19:11:59 <peddie> why not?  it seems to me like it would fix the type error
19:12:09 <peddie> have you?  ;)
19:12:37 <sophiag> <peddie> or perhaps `fromJustAmbVal . reqVal` ?  [22:02]
19:12:37 <sophiag> *** mod0 (~Mutter@115.60.81.134) has quit: Client Quit
19:12:37 <sophiag> <peddie> oh wait
19:12:37 <sophiag> <peddie> I misunderstood, ignore that
19:12:40 <sophiag> <peddie> I don't really grasp what this program is doing
19:12:43 <sophiag> <sophiag> i used composition before just like this and it was fine. but that
19:12:46 <sophiag> 	  was in a list comprehension, not as the predicate to filter
19:12:58 <peddie> yes, I remember this, but why is it not fine here?
19:13:09 <sophiag> you asked me whether i tried it
19:13:11 <sophiag> twice
19:13:18 <sophiag> and i'm answering that i did
19:13:31 <sophiag> it's obvious why it doesn't work. you said it yourself
19:13:36 <peddie> OK :)  that message before made it sound like you only tried it in a list comprehension, not here.  what goes wrong when you try it here?
19:14:05 <peddie> no, the comment of mine I corrected above was `fromJustAmbVal . reqVal`, not `fromJustAmbVal . reqVal r`
19:14:14 <Axman6> I too find that being agr4ssive to people trying to help you is an effective way to getting further help from them
19:14:22 <peddie> what error do you get if you replace the `$` with a `.`?
19:14:24 <Axman6> agressive*
19:14:37 <sophiag> here's the paste with new errors: http://lpaste.net/354622
19:14:41 <peddie> thanks
19:15:34 <ertes> you know what would be really useful?  if the things that http-conduit calls "request lenses" were actually lenses
19:15:37 <peddie> ah, you need something that will work for any `a`, and your function only works for `AmbVal`, is it?
19:15:58 <sophiag> peddie: i don't understand what you're referring to
19:16:29 <sophiag> i'm sorry, i just get fed up quickly with the communications issues in programming. my real life seeping into irc interactions :p
19:16:36 <peddie> sophiag: `appMultiList` requires an argument with type `[a] -> [a]`, but you're giving it one of type `[AmbVal] -> [AmbVal]`
19:16:49 <peddie> sophiag: no worries, let's keep truckin' :)
19:17:13 <peddie> sorry, `forall a. [a] -> [a]`
19:17:30 <peddie> it's going to be hard to write a filter that works on any possible element type ;)
19:17:47 <sophiag> it's not any possible type
19:17:50 <sophiag> it's literally one type
19:18:06 <peddie> `forall a. [a] -> [a]` means that it has to work for any possible element type
19:18:06 <sophiag> and changing the type signature of appMultiList just breaks the function
19:18:55 <sophiag> that's the type signature for that function. are you recommending i write a different function?
19:19:03 <peddie> sophiag: how does it break it?  what if you mapped the appropriate `AmbVal` constructor over the `MultiList` before applying the function, so that then your filter would have the appropriate type?
19:19:42 <peddie> sophiag: no; `appMultiList` will never try to call its argument at type `[()] -> [()]`, for example
19:19:58 <peddie> there's a closed set of types it can call it at, and they're described by `AmbVal`
19:21:06 <AWizzArd> Nothing >>= f1 >>= f2 >>= f3   -- none of the f1-f3 gets called. But: are all of the >>= called? Or does the computation end after the first bind?
19:21:10 <peddie> sophiag: in other words, I think `appMultiList` should be written so that its argument is a function of type `[AmbVal] -> [AmbVal]`
19:21:32 <sophiag> i think i sort of understand what you're saying, but it's very hard to tell
19:21:49 <ertes> sophiag: i realise that you have tags in multiple types, which indicates that you may want to abstract it out…  there is also a nice utility type for doing that:  (,)
19:22:01 <peddie> AWizzArd: check out the source code for the monad instance for `Maybe`: https://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#line-665
19:23:22 <ertes> s/abstract/factor/
19:23:59 <ertes> sophiag: then very quickly both Amb and Require become redundant altogether
19:24:25 <sophiag> how so?
19:24:45 <ertes> if you factor the tag out of Amb, what remains is Multilist
19:24:46 <sophiag> you understand this is a snippet, not an entire program, right?
19:24:58 <AWizzArd> I already saw the code before. My question is more like: „Ah okay, the first >>= returns Nothing. Good, now that we have this value the second >>= can be called, which also results in a Nothing. Now that this val was computed we can call the third >>=.
19:25:17 <Gurkenglas> sophiag, are you trying to do something like what Data.Dynamic does?
19:25:22 <sophiag> no
19:25:28 <sophiag> i don't know what any of these suggestions are
19:25:29 <AWizzArd> Does it work like this? Or will this short-circuit after the first?
19:25:34 <sophiag> i'm trying to fix one type error
19:25:43 <ertes> woah, sorry, i'll shut up again
19:26:39 <Gurkenglas> > sequenceA $ repeat Nothing -- AWizzArd, as you see, it doesn't traverse all of the infinite list :)
19:26:41 <peddie> AWizzArd: doesn't look like it short-circuits to me
19:26:42 <lambdabot>  Nothing
19:30:08 <AWizzArd> Gurkenglas: and how is this happening?
19:32:12 <peddie> AWizzArd: I think I'm still asleep or something, but it's probably to do with the associativity of >>=
19:32:53 <AWizzArd> Is Nothing >>= f1 >>= f2 >>= f3   ===   ((Nothing >>= f1) >>= f2) >>= f3
19:33:30 <peddie> yeah, that's why I said I didn't think it short-circuited
19:33:36 <peddie> hmm
19:33:45 <AWizzArd> Yes. But Gurkenglas showed it does.
19:34:12 <peddie> right
19:35:24 <Gurkenglas> sequenceA (repeat Nothing) = traverse id (repeat Nothing) = (foldr cons_f (pure []) (repeat Nothing) where cons_f x ys = (:) <$> id x <*> ys) = (cons_f Nothing (foldr cons_f (pure []) (repeat Nothing)) where cons_f x ys = (:) <$> id x <*> ys) = ((:) <$> id Nothing <*> (foldr cons_f (pure []) (repeat Nothing)) where cons_f x ys = (:) <$> id x <*> ys) = (Nothing <*> (foldr cons_f (pure []) (repeat Nothing)) where 
19:35:24 <Gurkenglas> cons_f x ys = (:) <$> id x <*> ys) = Nothing
19:35:59 * peddie hands Gurkenglas a barf bag
19:38:38 <Gurkenglas> Hmm but that wasn't quite the question was it. a >>= b >>= c >>= d >>= e associates to ((((a >>= b) >>= c) >>= d) >>= e) meaning that that one does pass all the Nothing's through.
19:38:44 <peddie> it seems like it must
19:38:58 <peddie> but it works fine on infinite lists, so we're missing something!
19:39:38 <nshepperd> sequenceA (Nothing : xs) = Nothing >>= (\a -> (a:) <$> sequenceA xs)
19:39:56 <peddie> oh, I see
19:40:21 <peddie> thanks nshepperd 
19:40:29 <nshepperd> :)
19:41:11 <glguy> sequenceA doesn't use >>=
19:41:34 <glguy> :t sequenceA
19:41:35 <nshepperd> oh yeah. well, whatever
19:41:35 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
19:42:24 <nshepperd> I guess it's more like sequenceA (Nothing : xs) = (:) <$> Nothing <*> sequenceA xs
19:42:45 <nshepperd> although these should be the same if Maybe obeys the monad laws
19:42:54 <peddie> glguy: <*> is defined on the Nothing case so that it works the same as >>=, I think you have to do it that way
19:42:59 <nshepperd> i guess
19:46:12 <peddie> AWizzArd: did you catch that?
19:48:32 <AWizzArd> I think I can take something from this.
19:48:46 <AWizzArd> Anyway, I just thought I will better test this.
19:49:22 <AWizzArd> So I implemented my own operator, by copying the implementation of (>>=) for Maybe.
19:49:27 <peddie> AWizzArd: the reason Gurkenglas' example short-circuited was due to the definition of `sequenceA`, not the `>>=` operator
19:49:28 <AWizzArd> But I put a trace in there.
19:49:35 <AWizzArd> peddie: yes.
19:49:40 <peddie> ok cool
19:49:51 <AWizzArd> The trace showed me: the Nothings get threaded through.
19:50:02 <sophiag> peddie: i fixed that error...by making the types even more convoluted :p
19:50:17 <AWizzArd> My >>= clone does get called as many times it shows up.
19:50:23 <peddie> sophiag: yikes!  does the program work now?
19:50:35 <sophiag> ha. not how i want it too
19:50:38 <sophiag> *to
19:51:05 <sophiag> i'm not certain whether it's because of that line... what i needed was: AList $ filter (fromJustAmbVal . reqVal r) [ListVal $ ambVal x]
19:51:06 <peddie> sophiag: on further reflection, it seems like the problem is that `AmbVal` and `MultiList` are related (they cover the same closed set of types), but they are independent as far as the type system is concerned
19:51:42 <sophiag> where AList is...you guessed it...a data constructor to wedge AmbVal into MuliList :p
19:52:05 <sophiag> yeah, so maybe a not too complicated improvement would be to just combine those two adts?
19:52:40 <peddie> sophiag: somehow, yes.  maybe you could make AmbVal take a type argument and use ordinary lists of them, so that you can't mix types?
19:52:43 <sophiag> at least then i wouldn't have to wrap each with each other
19:53:11 <sophiag> oh...i can't remember if there's a reason i didn't think of that
19:53:17 <sophiag> it sounds so simple now...
19:54:15 <sophiag> anyway, i'm not sure if in that expression i fixed whether it means it's now filtering for the *whole* list rather than nested lists inside it
19:54:27 <sophiag> that could explain my problem...i do obviously have an extra set of brackets
19:54:45 <sophiag> it's either that or a parsing error...
19:54:59 <sophiag> i'd like to rule out the easy part first :)
19:55:40 <eMapM> hey all; with esqueleto, has anyone tried to group on the dd/mm/yyyy part of a date?
19:55:47 <eMapM> it doesn't seem supported
19:57:49 <eMapM> i'm using postgres, so i'm wondering if there's a nice hack to just append `::date` onto my given field
19:58:38 <miaumiau> what the frickity fuck am I doing wrong here so that the instance cannot be found: http://imgur.com/dgx1SaH
19:59:46 <ertes> miaumiau: i don't see any reader there
19:59:52 <miaumiau> with full buffers, forgot to show the language pragmas http://imgur.com/p7CFHF5
20:00:01 <ertes> miaumiau: 'components', as far as i can tell, is a list
20:00:15 <miaumiau> that's the plan, right?
20:00:30 <ertes> miaumiau: but you're defining components = ask
20:00:36 <ertes> :t ask
20:00:38 <lambdabot> MonadReader r m => m r
20:00:52 <ertes> there is no MonadReader instance for []
20:00:57 <miaumiau> mind you, I'm just starting with Haskell
20:01:07 <miaumiau> apologies if I'm missing something obvious
20:01:23 <miaumiau> there is one in the bottom window, isn't it
20:01:28 <ertes> miaumiau: explain what you're trying to do
20:01:29 <miaumiau> and I import it by importing World
20:02:03 <ertes> ah, you're actually defining one, but that doesn't sound right
20:02:14 <miaumiau> get a global instance of the Reader monad for a given type T that has a Component instance
20:02:19 <ertes> there *should* be no MonadReader instance for []
20:02:25 <Cale> That instance doesn't make sense
20:02:50 <ertes> you might be misunderstanding the purpose of MonadReader
20:03:17 <miaumiau> bottomline I'm trying to reproduce this snippet: https://gist.github.com/memoizr/d197d30b0caad1d2b6fa9c195b74210f
20:03:29 <miaumiau> yes, that may be the case
20:04:06 <ertes> trying to do OOP in haskell is a recipe for sadness
20:04:06 <Cale> why are my eyes bleeding, what happened?
20:04:31 <ertes> not just because OOP is…  sad…  but because haskell doesn't support OOP
20:04:48 <Cale> Well, this is scala code, let's try and work out what the heck it says
20:05:04 <Cale> It *might* be reasonable to translate it to Haskell somehow
20:05:18 <sophiag> good Scala code seems just like super ugly Haskell to me
20:05:37 <sophiag> i guess bad Scala is like Java but less ugly
20:05:53 <ertes> my instinct says that you should start by defining the types in haskell while factoring out common fields
20:06:20 <ertes> i can't really tell what is a type and what is a field though
20:06:26 <miaumiau> there's no OOP that I can see
20:06:35 <miaumiau> on the snippet
20:06:39 <ertes> miaumiau: i can only guess, but i see an "extends" there
20:06:53 <miaumiau> it's a tag
20:06:57 <ertes> and i see "trait", too
20:07:27 <ertes> miaumiau: can you translate just the types to haskell?  without the operations
20:07:29 <miaumiau> I've reverted it in Haskell by making Component a typeclass that fetches the Entity, instead of the other way around
20:07:44 <Cale> miaumiau: Well, let's see if I can mimic what I think this is saying
20:07:52 <Cale> is Reader in Scala the same thing it is in Haskell?
20:08:17 <miaumiau> yes
20:08:26 <Cale> So a Reader[EntityId, Option[B]] basically the same thing as a function which takes an EntityId and produces an Option[B]?
20:08:33 <miaumiau> yes
20:08:34 <Cale> is*
20:08:37 <Cale> okay
20:08:54 <miaumiau> reader (\id -> Just B)
20:09:16 <ertes> so Reader in scala is (->) in haskell
20:09:40 <miaumiau> Kleisli?
20:09:49 <Cale> Just regular function arrow
20:09:51 <ertes> no, (->) is a family of reader monads
20:10:06 <Cale> You *could* use Reader, but you probably wouldn't here
20:10:08 <miaumiau> okok
20:10:18 <ertes> ask = id
20:10:45 <ertes> > (do x <- sin; y <- cos; pure (x^2 + y^2)) 5
20:10:47 <lambdabot>  0.9999999999999999
20:11:26 <miaumiau> why pure and not return?
20:11:31 <Cale> no good reason
20:11:35 <miaumiau> ok
20:11:50 <ertes> i consider 'return' a historical mistake, not because of its name, but because it's in Monad
20:12:04 <ertes> i've been using 'pure' since The Great AMP
20:12:05 <miaumiau> Ap fixes it, right?
20:12:09 <Cale> Well, you're using (>>=) there, so it's a moot point
20:12:10 <miaumiau> ye
20:12:29 <ertes> sure…  i'm almost surprised nobody "fixed" my code by rewriting it to applicative style =)
20:13:35 <Cale> I actually like 'return' a whole lot more as a name than 'pure', just because I'm usually thinking in a computational mindset, and like the fact that return v is the action which does nothing except to return v :)
20:14:24 <ertes> i don't mind the name either…  it's only the type of 'return' that bothers me =)
20:14:36 <ertes> miaumiau: ":" in scala means "of type"?
20:14:48 <Cale> yes
20:15:06 <Cale> and it has the function(arguments): resultType  thing
20:15:35 <ertes> and "object" defines a type along with its fields and associated procedures?
20:15:58 <miaumiau> <: Type is covariant fixation
20:16:20 <Cale> Yeah, that's not going to have a corresponding thing in Haskell
20:16:26 <miaumiau> object is a singleton, they're generally used as namespaces
20:16:34 <Cale> You might be able to get away with just a Component type of some sort though
20:16:41 <ertes> ah, so it corresponds to something like a module
20:16:53 <sophiag> that's interesting
20:17:00 <miaumiau> not necessarily, it can also be an actual instance of a type
20:17:14 <sophiag> i was thinking about that recently: how classes in most OOP languages are essentially used as namespaces
20:17:41 <miaumiau> OOP is procedural with classes as namespaces
20:17:49 <Cale> data Entity = Entity { getComponent :: (EntityId -> Maybe Component) -> Maybe Component } -- maybe something along these lines? I've left the entityId itself out, maybe we'd rather keep it
20:17:58 <miaumiau> the more mature the codebase, the more static global helpers it has
20:18:03 <sophiag> Clojure just overloads the term namespace for that instead of having modules, but then the problem is they can't use them as the unit of composition so use functions instead, which brings all kinds of trouble
20:18:11 <miaumiau> and the client code is just a procedural hydra hidden in hundreds of classes
20:19:01 <sophiag> i sort of wish i had learned Scala for work purposes before i learned too many adjacent languages to care :/
20:19:05 <ertes> miaumiau: my problem is:  right now i would translate this code to a unit type
20:19:10 <ertes> data Component = Component
20:19:12 <miaumiau> cale, I had something like that like 6 hours ago hahaha
20:19:22 <ertes> unless i really suck at reading scala code, there is no actual semantics
20:19:40 <Cale> Component probably needs to be a record of operations of some sort
20:19:47 <Cale> But I don't know which operations from this code
20:19:58 <ertes> yeah, perhaps with a separate type for component ids
20:20:06 <ertes> and perhaps a type argumen to tie the knot
20:20:25 <miaumiau> type EntityId = Int -- newtype Entity = Entity EntityId
20:20:31 <ertes> data Component x = Component  -- such that Fix Component would be a graph of all components
20:20:32 <miaumiau> missing from the screenshot
20:21:15 <ertes> miaumiau: i'm assuming you're modelling a game of some sort?
20:21:22 <miaumiau> there's a hard restriction, all the components of a single type must be packed together in an array
20:21:28 <Cale> miaumiau: I've come to regard the heart of traditional object oriented programming as simply programming which places an emphasis on defining data in terms of operations for taking it apart (methods, or messages)
20:21:28 <miaumiau> just one array per program
20:21:34 <miaumiau> yep
20:21:46 <ertes> why an array?
20:22:19 <miaumiau> in C++ because CPU cache misses are apparently one of the largest causes of perf loss 
20:22:38 <ertes> i would leave that to GC and use an IntMap
20:22:40 <miaumiau> so if you model things as Entities witha list of Components, you kind of miss the point of ECS
20:22:42 <Cale> If you care about CPU cache misses, just turn back now
20:22:55 <miaumiau> well nobody said I was sane
20:23:12 <miaumiau> I know the parf tradeoffs, doesn't mean it isn't wort trying to model it xD
20:23:24 <ertes> GHC is actually reasonably good at keeping data together with the caveat that IntMap is fairly large
20:23:39 <miaumiau> type safety is actually a missing part in ECS, many of the implementation rely on reflection and such
20:24:02 <ertes> but mutable vectors have their own caveat: fast removal, fast insertion, pick one
20:25:00 <miaumiau> I'd guess that fast addition is preferable in games, but it also has more deletions than your normal system
20:25:13 <Cale> miaumiau: So the first question I would want to tackle is how to translate B <: Component into Haskell. My first approach would be to say "fuck subtypes", and just see if I can get away with defining a single record of methods that every component will have, and then various ways of producing such records.
20:25:24 <ertes> insertions and deletions will be about the same on average
20:25:37 <ertes> anything else and you will either run out of objects or of RAM =)
20:25:49 <miaumiau> cale, I'd sin it around
20:25:56 <Cale> hm?
20:26:03 <miaumiau> I'd swap it around
20:26:10 <miaumiau> so instad of entities fetching components
20:26:19 <miaumiau> components contain their associated entity
20:26:30 <Cale> That's also possibly reasonable
20:26:37 <ertes> miaumiau: that's the point of my parametric Component
20:26:53 <miaumiau> so for a system you traverse all the components array
20:26:53 <ertes> data Component x = Component { parent :: x, draw :: IO () }
20:27:12 <miaumiau> no need to draw
20:27:21 <ertes> Component CompKey  -- here is a component that only has the key of its parent
20:27:23 <miaumiau> draw is a system
20:27:44 <miaumiau> for all Entities with components Renderable, Sprite, Position, or however you define it
20:27:50 <ertes> then you can use 'traverse' to turn Component CompKey into Component (Component CompKey)
20:27:51 <miaumiau> that's the missing piece of the puzzle
20:27:54 <ertes> to get the first layer of parents
20:28:27 <ertes> uhm…  i guess (parent :: Maybe x) makes more sense =)
20:28:42 <miaumiau> components can only be created with an associated entity
20:28:49 <miaumiau> no maybe needed
20:28:56 <miaumiau> and x is always EntityId
20:29:08 <miaumiau> there's no need to fetch a full entity, the id is enough
20:29:09 <ertes> what's the difference between components and entities?
20:29:24 <miaumiau> if you need it, you poll the world to fetch whatever component for an entityid
20:29:31 <miaumiau> it's really a thin abstraction
20:29:47 <miaumiau> an entity is an identity of anything in a world
20:30:03 <miaumiau> the entity has N components associated to it
20:30:32 <miaumiau> and the system processes all components that fulfill an aspect (sum of components for a single identity) 
20:30:44 <sveit> i am trying to understand the State monad, so I wrote my own and am comparing with the built-in version. i do not understand why in this code: http://lpaste.net/8156431319337795584 testMyStrict overflows but testBuiltInStrict doesn't. i don't see the (conceptual, my implementation is slightly different) difference between my code and the built-in classes. does anyone see the problem?
20:30:48 <ertes> so a player would be an entity, and, say, their set of weapons would be components?
20:31:17 <miaumiau> so a system is basically process:: a -> b -> c -> EntityId -> World -> World
20:31:22 <miaumiau> where a, b, c are components
20:31:45 <miaumiau> and there can be any number of, from 0 to however many components your system understands
20:31:56 <miaumiau> that's another thing I have to investigate how to do
20:32:20 <miaumiau> I do't see myself writing a System1, System2, System3 etc... if there's variadic polymorphism
20:32:30 <sophiag> Cale: do you want to see where i got with that problem from earlier? i fixed it, but it's misbehaving. i think the types i've defined are just far too messy at this point, although i got some good feedback on that
20:32:57 <miaumiau> ertes a player would be the entity with the Player component, which would have an inventory component, and the inventory can model whatever
20:33:43 <miaumiau> or maybe instead of an inventory component you prefer a sword component...the ida is to have a generalization
20:34:00 <miaumiau> and that also applies to part of the simulation, like speed, position in screen and world
20:34:24 <miaumiau> or the path to the sprite to be painted on screen
20:34:34 <ertes> miaumiau: i'm not sure i understand the distinction…  or the utility of that distinction
20:34:52 <ertes> miaumiau: do you mean that an entity is just a key?
20:34:56 <miaumiau> yep
20:35:04 <miaumiau> that's the implementation detail
20:35:33 <miaumiau> https://github.com/junkdog/artemis-odb/blob/master/artemis/src/main/java/com/artemis/Entity.java
20:36:17 <miaumiau> a component is literally whatever: https://github.com/junkdog/artemis-odb/blob/master/artemis/src/main/java/com/artemis/Component.java
20:36:51 <ertes> then Component is the actual implementation detail, as far as i see
20:38:02 <miaumiau> and a system is a glorified reduce: https://github.com/junkdog/artemis-odb/blob/master/artemis/src/main/java/com/artemis/BaseSystem.java#L43
20:38:10 <miaumiau> yeah
20:38:14 <ertes> let's say you want to use traditional imperative style to implement the game logic…  then i'd most likely use a StateT (if at all) to keep an IntMap to all the current entities in the game:  IntMap (Entity Key)
20:38:38 <miaumiau> simple, you reduce on that StateT
20:38:51 <miaumiau> that's what I'm calling world
20:39:00 <ertes> where:  data Entity k = Entity { draw :: IO (), parent :: Maybe k }
20:39:03 <miaumiau> so you process all your reducers (systems) to modify the world
20:39:17 <miaumiau> and at the end of the frame, you paint whatever is on the world
20:39:31 <miaumiau> so only one reduce per game tick, which is the tricky part
20:39:44 <miaumiau> game has to run at 60fps, which means all processing has to be within 16ms
20:39:59 <ertes> well, yeah, you also need a frame operation
20:40:17 <ertes> data Entity k = Entity { draw :: IO (), frame :: TimeDelta -> IO (Entity k), parent :: Maybe k }
20:40:47 <ertes> the actual frame is a 'traverse' over the IntMap
20:41:09 <miaumiau> where do you store the relations between the intmap and their components
20:41:19 <ertes> what does that mean?
20:41:31 <miaumiau> sorry, what's an intmap
20:41:35 <miaumiau> is it like a sparsemap
20:41:53 <miaumiau> an int -> value kind of deal
20:41:56 <ertes> i don't know what a sparsemap is, but it's a radix tree-based implementation of an association data structure
20:42:05 <miaumiau> that allocates space equal to the largest number?
20:42:09 <miaumiau> okok
20:42:14 <ertes> yeah:  (IntMap k a) behaves like (Int -> Maybe a)
20:42:40 <miaumiau> nice and fast, cool
20:43:04 <miaumiau> are updates just modifications of nodes in the tree, a la clojure?
20:43:45 <ertes> an update is a modified copy, but the copy shares most of the tree with its ancestor
20:43:51 <miaumiau> yep
20:44:12 <miaumiau> same, or sameish at least
20:44:21 <miaumiau> that's a library data structure, right?
20:44:35 <ertes> it's in Data.IntMap in 'containers'
20:44:39 <ertes> @package containers
20:44:39 <lambdabot> http://hackage.haskell.org/package/containers
20:44:41 <miaumiau> great
20:44:57 <miaumiau> I have to get going, it's 5 am and I'm pretty sure I skipped dinner
20:45:02 <miaumiau> can't remember
20:45:17 <miaumiau> I'll take another look tomorrow, a bit more fresh
20:45:21 <miaumiau> thank you for the help
20:46:00 <ertes> feel free to idle in #haskell-game, if you want =)
20:46:19 <miaumiau> oh wow the legend is true
20:46:28 <miaumiau> there're people more crazy than I am :D
20:46:33 <ertes> not that a lot is going on there, but at least most people interested in haskell game dev are there =)
20:48:13 <sveit> sorry to bump, but does anyone see why in http://lpaste.net/8156431319337795584 testMyStrict stack overflows but testBuiltInStrict does not?
20:52:49 <iqubic> Does (,) have a functor instance?
20:53:42 <sveit> iqubic: yes
20:53:55 <kamyar> Hello all
20:54:03 <kamyar> PLease help me use MessagePack
20:54:08 <sveit> well ((,) b) does
20:54:21 <iqubic> What I want is a function with this type signature: Applicative f => (a -> c) -> (b -> d) -> f a b -> f c d
20:54:21 <kamyar> I just want to pack (serialize) some object into MessagePack
20:54:47 <jle`> iqubic: that's not well-kinded
20:54:55 <iqubic> It it not?
20:54:59 <jle`> yes
20:55:01 <iqubic> What do you mean?
20:55:03 <jle`> Applicatives are all * -> *
20:55:08 <jle`> but f there is * -> * -> *
20:55:16 <jle`> that is, Applilcatives are things that take one argument
20:55:20 <iqubic> Oh.
20:55:28 <jle`> Maybe, IO, Either e, etc.
20:55:44 <jle`> that's the only way the type for 'pure' and <*> would make sense
20:55:47 <jle`> :t pure
20:55:49 <lambdabot> Applicative f => a -> f a
20:56:16 <jle`> you might be interested in Bifunctor
20:56:16 <iqubic> So how do I write a function like: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
20:56:24 <jle`> iqubic: that one isn't too hard
20:56:28 <iqubic> Is it not?
20:56:34 <jle`> :t \f g (x, y) -> (f x, g y)
20:56:35 <lambdabot> (t3 -> t2) -> (t1 -> t) -> (t3, t1) -> (t2, t)
20:56:42 <iqubic> Oh.
20:56:53 <jle`> :t \f g (x, y) -> (f x, g y) :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
20:56:55 <lambdabot> error:
20:56:55 <lambdabot>     • Couldn't match expected type ‘(a1 -> c1)
20:56:55 <lambdabot>                                     -> (b1 -> d1) -> (a1, b1) -> (c1, d1)’
20:57:07 <jle`> :t (\f g (x, y) -> (f x, g y)) :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
20:57:08 <lambdabot> (a -> c) -> (b -> d) -> (a, b) -> (c, d)
20:57:41 <jle`> iqubic: but this function is already provided in base (twice, actually) so you don't have to write it yourself
20:58:39 <iqubic> What if I want to make it generic? Like have it work with and Data tyoe that can be constructed with two arguments, and not just tuples.
20:58:53 <iqubic> Is that what bifunctor does?
20:59:11 <jle`> :t bimap
20:59:12 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
20:59:21 <jle`> yeah, it abstracts over things that are functors in both arguments
20:59:40 <jle`> it's not the most useful abstraction though, because there really aren't that many useful instances
21:00:00 <jle`> so writing 'generic' code isn't particularly useful
21:00:27 <iqubic> Yeah, what I want here is actually a traversal over my data.
21:00:38 <iqubic> I want to apply the same function to both parts.
21:00:52 <iqubic> I have a custom data type, and I need to make a traversal for it.
21:00:52 <jle`> is your data type a specific type?
21:01:13 <jle`> it'd probably be easiest to just write it non-generically
21:01:17 <dfeuer> sveit: your Applicative instance smells lazier than the one in transformers, but I haven't analyzed it fully.
21:01:24 <iqubic> jle`: It's a specific type that I defined for my own program.
21:01:36 <iqubic> And I need a way to traverse it.
21:01:52 <jle`> best way is probably to write a traversal
21:01:58 <jle`> by pattern matching etc.
21:02:09 <iqubic> newtype Scale = Scale a a
21:02:15 <iqubic> It looks like that.
21:02:35 <jle`> except different, right
21:02:48 <jle`> like data Scale a = Scale a a ?
21:02:50 <sveit> also, why is (snd $ flip runState 0 $ replicateM_ (10^7) (modify' (+1) >> get)) slow, even when i only import Control.Monad.State.Strict?
21:03:04 <iqubic> yeah, jle` that's what it looks like.
21:03:19 <iqubic> data Scale a = Scale a a
21:03:22 <jle`> yeah, you can probably just write a traversal by hand by pattern matching on the constructor
21:03:28 <iqubic> I can?
21:03:32 <jle`> traverseScale f (Scale a) = Scale <$> f a <*> f a
21:03:38 <jle`> er sorry
21:03:49 <jle`> traverseScale f (Scale x y) = Scale <$> f x <*> f y
21:04:21 <iqubic> Yeah, just because the two arguments are the same type doesn't mean they have the same value.
21:04:32 <jle`> GHC can actually derive this traversable for you
21:04:35 <iqubic> jle`: What would the type of that traversal be?
21:04:51 <jle`> the most generic type would be Applicative f => (a -> f b) -> Scale a -> f (Scale b)
21:05:02 <iqubic> jle`: What do you mean GHC can derive that for me?
21:05:07 <jle`> or Traversal (Scale a) (Scale b) a b
21:05:36 <jle`> @let data Scale a = Scale a a deriving (Show, Functor, Foldable, Traversable)
21:05:37 <lambdabot>  Defined.
21:05:48 <jle`> :t traverse :: Applicative f => (a -> f b) -> Scale a -> f (Scale b)
21:05:50 <lambdabot> Applicative f => (a -> f b) -> Scale a -> f (Scale b)
21:05:59 <sveit> dfeuer: thanks, i think it is as strict though. in any case i expanded my applicative definition and still get the overflow
21:06:02 <iqubic> It can just do that for me???
21:06:08 <dfeuer> liftA2 is arriving soon to an Applicative class near you :-)
21:06:23 <jle`> iqubic: yeah, because the process is really mechanical
21:06:25 <iqubic> How do I use the infix functions with that data?
21:06:34 <jle`> what data
21:06:36 <sveit> dfeuer: do you understand why the code is slow in either case in GHCI? replicateM_ is implemented as a loop, there shoudldn't be a data structure created, right?
21:06:42 <jle`> infix functions are just normal functions
21:06:45 <jle`> so you can use them with anything
21:07:03 <jle`> @let Scale x y +/+ Scale a b = Scale (x + a) (y + b)
21:07:04 <iqubic> jle`: I mean how do I traverse over a scale using the infix function?
21:07:05 <lambdabot>  Defined.
21:07:16 <jle`> iqubic: can you show a specific example
21:07:21 <jle`> of what you mean
21:07:44 <jle`> but yea,h GHC can derive the Traversable instance because the traversal is extremely mechanical
21:07:59 <jle`> (1) pattern match on each constructor, and apply f to everything of the right type
21:08:08 <jle`> traverse f (Scale x y) = Scale <$> f x <*> f y
21:08:13 <dfeuer> sveit: no, I don't, but you're comparing compiled code to interpreted... Some optimization is presumably helping.
21:08:19 <jle`> so mechanical that a computer could do it :)
21:08:34 <jle`> so mechanical that a machine could do it
21:09:29 <iqubic> How do I apply the infix traverse functions to my traversable scale?
21:09:45 <jle`> can you give an example of an infix traverse function
21:10:15 <jle`> i'm not sure what you mean
21:11:14 <iqubic> :t ^..
21:11:16 <lambdabot> error: parse error on input ‘^..’
21:11:34 <iqubic> Darn lambdabot doesn't have that???
21:11:38 <jle`> :t (^..)
21:11:39 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
21:11:43 <iqubic> I see.
21:11:45 <iqubic> cool
21:11:49 <jle`> well...traverse is just a normal Traversal
21:11:53 <jle`> so you can use it where you'd use any old traversal
21:12:02 <iqubic> :t traverse
21:12:02 <jle`> > Scale 10 3 ^.. traverse
21:12:03 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:12:04 <lambdabot>  [10,3]
21:12:13 <jle`> or Scale 10 3 ^.. traverseScale
21:12:16 <jle`> whatever you named it
21:12:28 <iqubic> jle` isn't ^.. just the infix version of toListOf?
21:12:36 <jle`> yes
21:12:38 <jle`> it is
21:12:47 <jchia_1> Can I get a code review? I'm making a type to support the notion of an IO action where I implicitly change directory to "/" before peforming the action itself. http://lpaste.net/354630
21:12:54 <jle`> iqubic: you can check the documentation if you aren't sure :)
21:13:01 <jle`> lens documentation is actually pretty clear/concise
21:13:17 <iqubic> What if I want to add five to both numbers in the scale, while traversing it.
21:13:27 <jchia_1> When I sequence two actions with >> or >>=, only one cd "/" is performed in the beginning.
21:13:44 <iqubic> jchia_1: Can we see some code?
21:13:52 <jchia_1> iqubic: In the lpaste
21:14:26 <iqubic> jchia_1: What lpaste?
21:14:31 <jchia_1> http://lpaste.net/354630
21:15:11 <jle`> iqubic: what do you mean 'while traversing it'
21:15:27 <jle`> "traversing" is a pretty vague word here
21:15:35 <jle`> you can add five to both numbers using fmap, or over traverse
21:15:43 <jle`> > over traverse (+5) (Scale 10 4)
21:15:45 <lambdabot>  Scale 15 9
21:15:58 <iqubic> Over is the function I was missing.
21:16:00 <jle`> or just fmap (+5) (Scale 10 4)
21:16:14 <glguy> traverse is more power than over needs
21:16:16 <iqubic> wait, why does fmap work in this case?
21:16:29 <jle`> iqubic: because Scale has a Functor instance
21:16:29 <iqubic> glguy: How would you have done it?
21:16:46 <iqubic> jle` So I don't need a traversal?
21:16:54 <jle`> you never need a traversal
21:16:54 <glguy> over just needs 'mapped'
21:17:11 <iqubic> > (Scale 2 3) <$> (+5)
21:17:13 <lambdabot>  error:
21:17:14 <lambdabot>      • Couldn't match expected type ‘a -> b’
21:17:14 <lambdabot>                    with actual type ‘Scale Integer’
21:17:16 <jle`> iqubic: what do you think you need a traversal for?
21:17:24 <jle`> you never *need* it
21:17:29 <jle`> it's just very useful and convenient :)
21:17:30 <iqubic> I'm actually not sure anymore. 
21:17:39 <jle`> it's a useful combinator
21:17:44 <jle`> for manipulating your data type
21:17:47 <iqubic> Why didn't my infix fmpa work?
21:17:51 <iqubic> *fmap
21:17:59 <jle`> iqubic: check the type of (<$>)
21:18:09 <jle`> the error message is also pretty clear
21:18:16 <iqubic> (+5) <$> (Scale 1 2)
21:18:22 <jle`> did you see the error message?
21:18:24 <iqubic> > (+5) <$> (Scale 1 2)
21:18:27 <lambdabot>  Scale 6 7
21:18:33 <iqubic> I is stupid
21:18:33 <jle`> (<$>) expected a function, but you gave it a Scale Integer
21:18:53 <jle`> nah :)
21:19:00 <jle`> just good to take things slow
21:19:08 <iqubic> Is there an infix function that will call over, but add some number n to the elements too?
21:19:09 <jle`> if something gives an error, try reading the error message, checking types, etc.
21:19:24 <jle`> > Scale 10 5 +~ 3
21:19:26 <lambdabot>  error:
21:19:26 <lambdabot>      • Couldn't match type ‘Scale Integer’
21:19:26 <lambdabot>                       with ‘(Integer -> Identity Integer) -> s -> Identity t’
21:19:35 <jle`> > Scale 10 5 & traverse +~ 3
21:19:37 <lambdabot>  Scale 13 8
21:19:40 <glguy> > (mapped +~ 3) (Scale 10 5)
21:19:43 <lambdabot>  Scale 13 8
21:19:48 <iqubic> :t mapped
21:19:50 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
21:20:01 <iqubic> :t &
21:20:02 <lambdabot> error: parse error on input ‘&’
21:20:09 <iqubic> :t (&)
21:20:10 <lambdabot> a -> (a -> b) -> b
21:20:18 <iqubic> I see.
21:20:32 <iqubic> What does mapped do?
21:20:41 <iqubic> glguy: looking at you.
21:20:47 <jle`> mapped uses the Functor instance instead of the Traversable instance
21:20:48 <iqubic> You used mapped just now.
21:20:51 <glguy> Look at the documentation firsr
21:21:37 <jle`> > over mapped (+3) (Scale 3 10)
21:21:39 <iqubic> glguy: So I can use mapped without needing my data type to be an instance of traversable?
21:21:39 <lambdabot>  Scale 6 13
21:21:50 <jle`> 'mapped' just needs a Functor instance
21:23:03 <iqubic> :t (+~)
21:23:04 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
21:23:30 <iqubic> so I don't need a traversal instance for my data to do this:
21:23:44 <iqubic> > (mapped +~ 3) (Scale 1 1)
21:23:46 <lambdabot>  Scale 4 4
21:24:11 <iqubic> :t (mapped +~ 3)
21:24:13 <lambdabot> (Functor f, Num b) => f b -> f b
21:24:16 <jle`> yup. mapped uses the Functor instance.
21:24:34 <iqubic> So why does anyone create a traversal then?
21:24:46 <jle`> when you want to do things that traversals can do
21:25:09 <iqubic> What other things can traversals do that can't be done with mapped?
21:25:11 <jle`> see the documentation http://hackage.haskell.org/package/lens
21:25:28 <jle`> mapped is a Setter, so it can do all of the things in the Setter box
21:25:39 <ertes> incoming rant
21:25:39 <jle`> over, set, +~, etc.
21:25:46 <glguy> Look in the module Control.Lens.Traversal to see consumers of Traversals
21:25:53 <jle`> but it can't do any of the things in the Traversal box
21:26:14 <ertes> STOP REINVENTING Either!  JUST USE FUCKING Either!
21:26:27 <ertes> sorry
21:26:38 <iqubic> What code are you looking at?
21:26:40 <jle`> iqubic: traversals can be used as Folds and Getters, too, so look at everything in the Fold box, and those are things that traversals can do that 'mapped' can't
21:27:10 <iqubic> Wait, if I have a traversal instance, I can also use foldL with it?
21:27:27 <iqubic> And other stuff like that??
21:27:29 <jle`> yeah, foldrOf, foldlOf, etc.
21:27:31 <jle`> look at the boxes
21:27:35 <iqubic> I will
21:27:49 <jle`> the arrows say "can be used as..."
21:28:01 <jle`> and the things in the boxes are the things you can do with them
21:28:22 <iqubic> I see.
21:28:29 <iqubic> Makes a lot of sense.
21:28:46 <jle`> for example, Prisms can be used as traversals, folds, and setters
21:29:09 <iqubic> I know.
21:29:25 <iqubic> Not too sure what a prism is, but I'm learning slowly.
21:29:57 <iqubic> What does the anyOf function do?
21:30:08 <iqubic> returns true if an element passes the test?
21:30:32 <jle`> i know one way to find out
21:31:06 <iqubic> > anyOf (== 1) (Scale 1 3)
21:31:08 <lambdabot>  error:
21:31:08 <lambdabot>      • Couldn't match type ‘Bool’ with ‘s -> Const Any s’
21:31:08 <lambdabot>        Expected type: Getting Any s a0
21:31:27 <iqubic> Alright, that has the right type.
21:31:31 <jle`> > anyOf traverse (== 1) (Scale 1 3)
21:31:33 <lambdabot>  True
21:31:41 <jle`> but the way i was hinting to was:
21:31:48 <jle`> reading the documentation for anyOf
21:31:50 <glguy> anyOf only needs a Fold :)
21:31:54 <iqubic> Why do you have to use traverse there???
21:31:55 <jle`> http://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-Fold.html#v:anyOf
21:32:09 <jle`> iqubic: anyOf's first argument is the Fold/Traversal
21:32:17 <jle`> same for toListOf
21:32:25 <jle`> same for 'over'
21:32:28 <jle`> same for 'view'
21:32:30 <jle`> same for 'set', etc.
21:32:38 <iqubic> No, the first argument is the boolean function.
21:32:41 <iqubic> :t anyOf
21:32:43 <lambdabot> Getting Any s a -> (a -> Bool) -> s -> Bool
21:32:48 <jle`> pretty much the same for any function in lens that uses lenses/traversals/folds/prisms, etc.
21:32:53 <iqubic> Okay, I'm wrong.
21:33:21 <jle`> it's the same as over, view, set, toListOf, etc.
21:34:15 <mstan> Anyone here?
21:34:23 <iqubic> :t each
21:34:25 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
21:34:56 <jle`> each is a traversal
21:35:19 <jle`> well, for instances of Each
21:35:29 <jle`> just like how 'traverse' is a traversal, for instances of Traversable
21:35:43 <sophiag> can anyone take a look at my weak attempt to refactor some gnarly types?
21:36:12 <iqubic> I think that I don't need a traversal here.
21:37:05 <sophiag> here's a version that compiles, but i'm having trouble debugging: http://lpaste.net/354629
21:37:16 <jle`> iqubic: it depends on what you want to do, of course
21:37:19 <sophiag> and here's the new way i'm trying to structure it: http://lpaste.net/354632
21:45:42 <jle`> sophiag: what's the issue?
21:48:03 <sophiag> well, if you look at the first paste you'll see two (actually there's a third, but let's ignore that) adts that both wrap each other and additionally the first just consists of list types of the second
21:48:24 <sophiag> it's making the code rather spaghetti-ish as i try to debug it
21:49:04 <sophiag> it was suggested i use a type variable in order to consolidate those two while still preventing heterogenous lists, which is what i'm trying in the new version of it
21:49:26 <sophiag> but having a lot of trouble...especially when wanting to define those homogenous list types
21:49:36 <sophiag> or moreso, pattern match for them
21:49:53 <sophiag> and i've resorted to existentials for my two record types as well
21:50:37 <sophiag> so i'm not sure whether it's a good idea to refactor this wasy and i just need to figure these things out (i think likely) or not
21:51:05 <sophiag> oh, the first paste does show the operational problems at the bottom as well
21:52:23 <sophiag> does this make sense? it's a nearly finished dsl yet i'm spending sooo much time trying to debug the last bit, getting what should be really simple functions to work by contorting the type system and becoming quite frustrated
22:02:19 <sophiag> jle`: did i overwhelm you? :)
22:29:22 <iqubic> I can't see any reason why anyone would want to use a traversal over a foldable instance with mapped
22:29:31 <iqubic> No reason at all.
22:30:27 <iqubic> Can someone enlighten me?
22:31:29 <jle`> sophiag: was just feeding you questions to help people help you :)
22:31:35 <jle`> iqubic: what is a 'foldable instance with mapped' ?
22:31:49 <iqubic> I'm not sure.
22:32:17 <iqubic> What I mean is, why have a full blown traversal instance when all you need is mapped?
22:32:20 <jle`> well, one reason to use a traversal ove a 'foldable instance with mapped' is that a traversal is a real thing
22:32:34 <jle`> by 'traversal instance', do you mean a traversal?
22:32:40 <iqubic> Yes.
22:32:56 <iqubic> I mean something that is an instance of traversal.
22:32:58 <jle`> i explained earlier that mapped can't be used with things that expects folds
22:33:04 <jle`> 'instance of traversal', what is that?
22:33:07 <iqubic> I know that.
22:33:15 <jle`> so, there is your reason
22:33:27 <iqubic> jle`: instance Traversal Scale a where...
22:33:40 <iqubic> But that's not how that works, is it?
22:33:43 <jle`> what typeclass is that?
22:33:58 <jle`> there is no Traversal typeclass that is commonly used
22:34:01 <iqubic> Are traversals not a typeclass???
22:34:06 <jle`> no
22:34:10 <iqubic> I thought they were.
22:34:19 <jle`> Traversable is a typclass
22:34:23 <jle`> but traversals are just things/normal values
22:34:32 <iqubic> What does Traversable do
22:34:33 <iqubic> ?
22:34:45 <jle`> Traversable provides a traversal for * -> *-kinded things
22:34:51 <jle`> a "canonical" traversal
22:35:05 <iqubic> I see.
22:35:39 <iqubic> So why would anyone use any of the functions in the traversal box every, when you have over and modify?
22:35:43 <iqubic> *ever
22:35:55 <jle`> over can't do everything
22:36:06 <iqubic> What can't it do?
22:36:19 <iqubic> I know it can't do to list of.
22:36:19 <jle`> literally anything besides applying an (a -> b) function
22:36:44 <iqubic> Wait, over can't sequence a bunch of IO actions?
22:36:50 <jle`> so it literally can do pretty much nothing except map an (a -> b)
22:36:59 <iqubic> Oh. I see.
22:37:02 <jle`> all it can do is map a function
22:37:08 <iqubic> That's pretty restricted?
22:37:19 <jle`> well, it depends on what you consider useful things
22:37:29 <jle`> but it literally only has one function, heh
22:37:40 <jle`> 'restricted' is a vague word i guess, so you have to clarify what you mean
22:38:28 <iqubic> What if I want to take a travesal over a list of IO () and do all the actions?
22:38:48 <iqubic> Or just sequence a bunch of monadic actions all in a row?
22:38:50 <jle`> that's just sequence :: [IO ()] -> IO ()
22:39:02 <jle`> which is sequenceOf traverse
22:39:05 <iqubic> jle`: Does that require a travesal?
22:39:07 <jle`> :t sequenceOf traverse
22:39:09 <lambdabot> (Monad m, Traversable t) => t (m b) -> m (t b)
22:39:10 <jle`> it requires a Fold
22:39:14 <jle`> which all Traversal's are
22:39:30 <iqubic> How can you ahve a fold that is not a traversal?
22:39:31 <jle`> literally anything that isn't "map a function over this thing" can't be done by 'over', heh
22:39:39 <glguy> The one that needs a Fold is sequenceOf_
22:39:44 <ertes> is there a way to use generalised newtype deriving for Show?  i would like to inherit the same instance
22:40:02 <jle`> ah yeah, sorry, sequence_ :: [IO ()] -> IO (), and sequenceOf_ traverse :: [IO ()] -> IO ()
22:40:10 <iqubic> How can you have a fold that's not a traversal?
22:40:16 <jle`> well, you can write one
22:40:27 <iqubic> How so?
22:40:41 <iqubic> What is the minimal complete definition of a fold?
22:40:46 <jle`> lens provies 'folded', which gives you a Fold for every Foldable instance
22:40:59 <jle`> but, the difeference between Foldable and Traversable is interesting
22:41:02 <glguy> ertes: There's stuff coming in GHC 8.2 to allow you to pick your 'deriving' strategy
22:41:08 <glguy> Maybe that will help
22:41:10 <jle`> Foldable's minimum interface is a "toList" function
22:41:22 <iqubic> What does toList do?
22:41:24 <jle`> Foldable lets you iterate through all the items in an object
22:41:28 <jle`> iqubic: i'll give you one guess :)
22:41:47 <iqubic> jle` Does it take an items objects and put them in a list?
22:42:04 <jle`> what Traversable adds to Foldable is that it lets you *reconstruct* the original structure, with the results of your traversing function
22:42:26 <iqubic> What does that mean?
22:42:31 <ertes> glguy: nice…  no way to achieve that with GHC 8.0 though, i take it
22:42:44 <jle`> iqubic: do you know about 'Map'?
22:42:47 <jle`> key-value pairs
22:42:48 <iqubic> I do.
22:42:55 <glguy> ertes: I'm not ready to say "no way" but I don't know of a way
22:43:00 <iqubic> I know about key-value pairs.
22:43:02 <jle`> 'Map k' has a Foldable instance, which lets you sequence all of the actions it contains
22:43:07 <jle`> but you can't "collect" the results back into a new Map
22:43:14 <jle`> you lose the original map's structure forever
22:43:24 <jle`> mapM_ :: (a -> f b) -> Map k a -> f ()
22:43:41 <jchia_1> When defining some function that returns an IO a, is it always better to define it in more general terms with constraint MonadIO m returning m a instead of returning IO a? When is it not a good idea?
22:43:44 <jle`> but, Traversable lets you reconstruct a new map with the results of your traversing function
22:43:54 <jle`> mapM :: (a -> f b) -> Map k a -> f (Map k b)
22:44:15 <jle`> what mapM does for Map k is it sequences the 'a -> f b' function for all the items in the map, and then collects the results
22:44:17 <iqubic> Is mapM provided by lens?
22:44:27 <jle`> mapM is a part of the Traversable typeclass
22:44:29 <ertes> jle`: side note: the primitive of Foldable is foldMap (or fold), not toList
22:44:31 <jle`> it's also called 'traverse'
22:44:41 <jle`> they are synonyms more or less
22:44:47 <glguy> jchia_1: In general it's best not to do that
22:44:48 <iqubic> Well, alrigt.
22:44:49 <jle`> traverse :: (a -> f b) -> Map k a -> f (Map k b)
22:44:56 <jle`> traverse_ :: (a -> f b) -> Map k a -> f ()
22:45:06 <jle`> *traverse_ is from Foldable
22:45:15 <iqubic> And a lens lets you look at just one item in your data, right?
22:45:19 <glguy> perhaps in some specific case it'll be more locally useful to do so, but if you're exposing functions for someone else to use it's better to just provide IO types
22:45:36 <jle`> yeah. a lens is a traversal over exactly one item
22:45:37 <jchia_1> glguy: Why? Doesn't it allow for more reuse?
22:45:48 <glguy> It makes things more complicated and slower
22:46:09 <ertes> glguy, jchia_1: i must say, i do find libraries that abstract over MonadIO to be more convenient to work with
22:46:10 <iqubic> jle`: After that you have isos and prisms.
22:46:11 <jle`> iqubic: the difference is pretty much that traverse/Traversable preserves the structure of the thing you are traversing
22:46:16 <iqubic> I see
22:46:24 <iqubic> How do isos and prisms work?
22:46:33 <iqubic> Do you have time to explain that?
22:46:36 <glguy> I find it quite unnecessary
22:46:47 <jchia_1> glguy: I now find myself having to edit existing code to change them to use MonadIO instead of IO because the users now use a MonadIO that's not IO.
22:47:03 <glguy> the user can just use liftIO if needed
22:47:16 <jchia_1> glguy: That seems like a lot of boilerplate to me.
22:47:18 <glguy> or whatever new class they've made to lift IO
22:47:19 <ertes> jchia_1: using IO is fine…  it also eliminates the discrepancy between returning IO and taking IO
22:47:33 <iqubic> How do prisms and isos work?
22:47:43 <glguy> jchia_1: I mean, I don't have to use any of your code, so do whatever you want :)
22:47:45 <iqubic> I want to understand those
22:47:52 <glguy> I'm just answering the question
22:47:58 <jchia_1> glguy: Just getting different points of view.
22:48:05 <ertes> jchia_1: for example you can't fully abstract something like 'catch' or 'withFile' without something like monad-control
22:48:11 <jle`> iqubic: if you can read the chart, you can see what prisms and isos can do
22:48:23 <iqubic> How can you have a Getter that is not a Lens?
22:48:38 <iqubic> Or a Setter that isn't a Traversal?
22:48:49 <jle`> in the box, the first section are ways to "construct" the thing
22:48:58 <jle`> so 'to' is a way to construct a Getter
22:49:06 <jle`> to :: (s -> a) -> Getter s a
22:49:19 <iqubic> Alright.
22:49:27 <iqubic> How does that differ from a lens?
22:49:28 <jle`> 'to f' is a getter, but not a lens
22:49:34 <jle`> well, lenses can modify things
22:49:39 <jle`> getters can only extract things
22:49:52 <iqubic> And setters can only place things back in?
22:49:53 <ertes> iqubic: you might encounter Getter when things are hidden and not supposed to be modified by the user…  however, in that case don't write a Getter, but just a function
22:50:11 <iqubic> Alright.
22:50:20 <jle`> iqubic: look at the box for Setter
22:50:22 <jle`> to see what a setter can do
22:50:23 <iqubic> Now can someone explain isos and lenses.
22:50:39 <iqubic> ???
22:50:55 <iqubic> I can't understand prisms or isos.
22:51:18 <jle`> prisms can be used as Reviews, Traversals, Folds, and Setters
22:51:22 <iqubic> SUre.
22:51:26 <iqubic> I get tht.
22:51:36 <jchia_1> What does it mean when GHC gives the warning "No explicit implementation for ..." with -Wmissing-methods. Does it mean that I end up with no implementation and may get a run-time error or does it mean that I end up with the default implementation provided by the typeclass?
22:51:40 <jle`> so you understand traversals, folds, and setters already
22:51:45 <jle`> you understand 75% of prisms :)
22:51:49 <iqubic> Yes I do.
22:51:54 <iqubic> What is a review?
22:52:01 <ertes> jchia_1: GHC does not warn about default implementations
22:52:09 <ertes> jchia_1: so it means there is something wrong
22:52:15 <jle`> iqubic: Review lets you construct a structure given one of its parts
22:52:25 <jle`> it's like the opposite of Getter, kinda
22:52:27 <jchia_1> ertes: That means I may get a run-time error when the missing function gets called?
22:52:34 <ertes> jchia_1: yeah
22:52:35 <iqubic> jle`: Isn't that what a lens does?
22:52:44 <jle`> iqubic: you can't do that with a lens
22:52:52 <jle`> for example, a lens that gets the first item in a tuple
22:52:56 <jle`> you can't create a tuple from just the first item
22:53:03 <ertes> iqubic: _Just is a prism…  it's an up-to-1 traversal with extra information in order to *construct* a Just
22:53:08 <ertes> > _Just # 5
22:53:08 <jle`> _1 gives you a (a, b) -> a, but it doesn't get you an a -> (a, b)
22:53:10 <lambdabot>  Just 5
22:53:40 <iqubic> You can't just pull the second element out of thin air though.
22:53:44 <jle`> exactly
22:53:44 <iqubic> How does that work?
22:53:47 <jle`> that's why _1 is not a prism
22:53:54 <jle`> that was my point :)
22:54:06 <iqubic> So what is an example of a valid prism?
22:54:18 <iqubic> Why is _just a prism?
22:54:19 <jle`> or well, what i meant to say is, that's why _1 is not a Review
22:54:31 <jle`> iqubic: _Just is a prism that looks at the value that a Maybe contains
22:54:42 <jle`> and, well, you can see that if you are given an 'a', you can create a 'Maybe a'
22:54:46 <ertes> Review may not be the best name =)
22:54:51 <iqubic> sure. But a Maybe might have 0 values.
22:54:58 <iqubic> Nothing has no values.
22:55:01 <jle`> yes, so it's not a lens
22:55:03 <jle`> it's a Traversal
22:55:23 <jle`> traversals can have 0, 1, or a buncha values.
22:55:27 <iqubic> Right. But you can still construct the original data if you want.
22:55:46 <jle`> yeah, so _Just is a Traversal + Review
22:55:56 <jle`> you can "traverse" the values inside the Maybe, if there are any
22:55:56 <spatial> Is there a haskell library equivalent to Python's matplotlib ?
22:56:08 <jle`> and, as a Review, you can have an a -> Maybe a
22:56:17 <iqubic> Are there other Reviews I need to know about?
22:56:39 <iqubic> Can you give me another Review?
22:56:41 <ertes> > _Left # 5
22:56:43 <lambdabot>  Left 5
22:56:48 <jle`> there aren't many things that are "only" Reviews
22:56:58 <jle`> but you can make an arbitrary one with 'unto'
22:57:01 <iqubic> Alright, so give me some prisms then.
22:57:04 <jle`> but, there are several useful prisms
22:57:11 <jle`> _Left, _Right, _Just are examples
22:57:18 <jle`> _Left is a prism into the "left" item in an Either e a
22:57:38 <iqubic> Can you have a prism into the first element of a list?
22:57:49 <iqubic> Because [] has no first element.
22:58:10 <iqubic> How come a prism is not a lens?
22:58:23 <ertes> you can have a prism that corresponds to the (:) constructor
22:58:43 <jle`> iqubic: lenses are traversals with exactly one item
22:58:48 <jle`> iqubic: but prisms might have 0 items
22:58:56 <jle`> as we have seen with _Just and _Left and _Right
22:59:00 <ertes> a prism can be a lens, but generally it's not
22:59:18 <iqubic> ertes, how would the prism of (:) work?
22:59:19 <jle`> one of my favorite prisms is hex
22:59:29 <iqubic> How does hex work?
22:59:34 <ertes> :t unto
22:59:36 <lambdabot> (Functor f, Bifunctor p, Profunctor p) => (b -> t) -> Optic p f s t a b
22:59:43 <jle`> hex is a prism into the integer encded as a hax value in a string
22:59:54 <jle`> > over hex (*2) "a7eb3"
22:59:56 <lambdabot>  "14fd66"
23:00:06 <jle`> > over hex (`div` 2) "a7eb3"
23:00:08 <lambdabot>  "53f59"
23:00:09 <iqubic> And a given string is either a hex number or not.
23:00:15 <jle`> yeah, a string might not contain a number
23:00:16 <ertes> > unto (:) # (1, [2,3,4])
23:00:18 <lambdabot>  <[(Integer,[Integer])] -> [(Integer,[Integer])]>
23:00:23 <jle`> > review hex "a7eb3"
23:00:26 <lambdabot>  error:
23:00:27 <lambdabot>      • No instance for (Integral [Char]) arising from a use of ‘hex’
23:00:27 <lambdabot>      • In the first argument of ‘review’, namely ‘hex’
23:00:30 <jle`> aw
23:00:34 <jle`> > preview hex "a7eb3"
23:00:36 <lambdabot>  Just 687795
23:00:45 <ertes> > unto (uncurry (:)) # (1, [2,3,4])
23:00:47 <lambdabot>  [1,2,3,4]
23:00:49 <jle`> > "a7eb3" ^.. hex
23:00:52 <lambdabot>  [687795]
23:01:12 <iqubic> "QQQ" ^.. hex
23:01:14 <ertes> (but that one is only a Review)
23:01:18 <iqubic> > "QQQ" ^.. hex
23:01:20 <lambdabot>  []
23:01:29 <iqubic> Why did I get that result?
23:01:38 <iqubic> Should I get Nothing?
23:01:39 <jle`> iqubic: well, "QQQ" contains no hex integer
23:01:43 <jle`> ^.. returns a list
23:01:47 <jle`> preview returns Just/Maybe
23:02:00 <iqubic> > preview hex "QQQ"
23:02:03 <lambdabot>  Nothing
23:02:13 <iqubic> > view hex 100
23:02:14 <jle`> preview is like toListOf + listToMaybe
23:02:15 <lambdabot>  error:
23:02:15 <lambdabot>      • Could not deduce (Num String) arising from the literal ‘100’
23:02:15 <lambdabot>        from the context: (Monoid t, Integral t)
23:02:24 <jle`> see, you can't use view with hex, because view only works for lenses
23:02:33 <iqubic> > review hex 100
23:02:36 <lambdabot>  "64"
23:02:43 <jle`> remember, review "creates" the structure from the part
23:02:51 <iqubic> Is there an ifix form of review?
23:02:59 <jle`> yes, ertes has been using it
23:03:01 <iqubic> and one for preview too?
23:03:13 <jle`> ^?
23:03:33 <iqubic> Now, let's talk about isos.
23:03:40 <iqubic> I think I want to learn about them now.
23:03:54 <iqubic> If you still have time and energy to explain them.
23:04:00 <jle`> you already know enough to understand iso's
23:04:03 <jle`> just from the chart
23:04:15 <jle`> iso's are prism + lens
23:04:23 <iqubic> How can you have something that acts like both a prism and a lens, at the same time?
23:04:26 <jle`> so they are also review, traversal, getting, fold, etc.
23:05:06 <jle`> well, what did we see before that prevented a prism from being a lens?
23:05:12 <jle`> a prism might have 0 values
23:05:17 <iqubic> Right.
23:05:26 <jle`> so maybe you can think of an iso as being a prism that always has exactly 1 value
23:05:26 <iqubic> So, how does an iso get around that?
23:05:30 <jle`> where preview is always Just
23:05:40 <kamyar> Hey anyone please answer my wuestion
23:05:44 <kamyar> question
23:05:45 <iqubic> Can I have an example of an iso?
23:05:59 <iqubic> Do you have a good one to show me?
23:06:01 <kamyar> I just want to use MessagePack
23:06:10 <kamyar> on GHC 8.0.2
23:06:19 <kamyar> I have to use data-messagepack
23:06:23 <kamyar> which is a fork
23:06:35 <kamyar> How can I serialize data using messagepack?
23:06:44 <jle`> iqubic: if two types are considered "identical" or isomorphic ot each other, then you can make an iso out of them
23:06:56 <iqubic> Can you give me an example of that?
23:07:03 <iqubic> I'm not understanding that at all.
23:07:24 <jle`> there's an isomorphismb etween (a, b) and (b, a)
23:07:31 <iqubic> Right.
23:07:43 <iqubic> Now how do I make an iso out of that?
23:07:45 <jle`> that's 'swapped'
23:07:46 <kamyar> Hey no one can answer my question?
23:07:56 <jle`> or well, you can make an iso if you can provide the "to" and "from" functions
23:08:02 <jle`> but lens already gives you 'swapped'
23:08:11 <jle`> > review swapped ('a',3)
23:08:13 <lambdabot>  (3,'a')
23:08:18 <jle`> > view swapped (3, 'a')
23:08:20 <lambdabot>  ('a',3)
23:09:04 <jle`> one of the more famous iso's is non
23:09:45 <jle`> oh, the most famous iso is 'id', of course
23:09:53 <jle`> which says that every type is isomorphic to itself
23:10:02 <jle`> the "thing inside" is just the thing itself
23:10:20 <jle`> > view id "hello"
23:10:22 <lambdabot>  "hello"
23:10:24 <jle`> > review id "hello"
23:10:26 <lambdabot>  "hello"
23:10:27 <jle`> > over id (*2) 10
23:10:29 <lambdabot>  20
23:10:36 <iqubic> Let me guess: 
23:11:31 <iqubic> if _iso_ is an iso then review _iso_ (view _iso_ x) = x
23:11:42 <iqubic> sorry bout that.
23:11:53 <jle`> yes :)
23:12:04 <iqubic> If I apply review and then view to an iso, I get the same value.
23:12:26 <iqubic> review iso (view iso) = id
23:12:29 <iqubic> for any iso
23:12:30 <jle`> mhm
23:12:45 <jle`> view i . review i = review i . view i = id
23:13:20 <iqubic> why aren't we using preveiw here?
23:13:26 <iqubic> *preview?
23:13:34 <jle`> preview returns a Maybe, remember
23:13:45 <jle`> for an iso, preview will always return Just
23:13:54 <Hail_Spacecake> is there a concise way to say "is a equal to anything in this list"? where a and hte list all implement Eq?
23:14:09 <Hail_Spacecake> basically I want to do if a == a' || a == a'' || a == a''' ,etc.
23:14:12 <Hail_Spacecake> in a more concise way
23:14:14 <iqubic> :t anyMatch
23:14:16 <lambdabot> error: Variable not in scope: anyMatch
23:14:20 <iqubic> :t any
23:14:22 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
23:14:28 <monochrom> elem
23:14:30 <jle`> Hail_Spacecake: yu want 'elem'
23:14:45 <iqubic> Hail_Spacecake: any (== a) [xs]
23:14:51 <Hail_Spacecake> ah, elem
23:14:51 <kamyar> How can I read Haddick for a package?
23:14:53 <iqubic> I think that's what you want.
23:14:53 <Hail_Spacecake> okay, thanks
23:14:55 <kamyar> Haddock
23:14:57 <jle`> > 'e' `elem' "hello"
23:14:59 <lambdabot>  <hint>:1:12: error: parse error on input ‘"’
23:15:01 <jle`> > 'e' `elem` "hello"
23:15:03 <lambdabot>  True
23:15:04 <jle`> > 'x' `elem` "hello"
23:15:06 <kamyar> how to get Haddocks?
23:15:06 <lambdabot>  False
23:15:14 <iqubic> Does my function work?
23:15:26 <iqubic> any (== a) [xs]
23:15:36 <monochrom> No.
23:15:42 <iqubic> why not?
23:15:49 <monochrom> Check its type.
23:15:51 <kamyar> Hey please
23:15:57 <kamyar> How can I use Haddock? 
23:16:01 <iqubic> :t any (== a) [xs]
23:16:02 <lambdabot> error:
23:16:02 <lambdabot>     • Variable not in scope: xs :: Expr
23:16:02 <lambdabot>     • Perhaps you meant one of these:
23:16:04 <kamyar> I just want to read some package docs
23:16:14 <jle`> kamyar: if it's on hackage, you can look there
23:16:19 <iqubic> :t any (== a) []
23:16:21 <lambdabot> Bool
23:16:42 <jle`> iqubic: maybe you mean any (== a) xs, instead of [xs]
23:16:51 <iqubic> Yeah, I think so.
23:16:55 <kamyar> jle`: On website? I cant find any! see msgpack package
23:17:02 <iqubic> :t any (== a) xs
23:17:03 <lambdabot> error:
23:17:03 <lambdabot>     • Variable not in scope: xs :: [Expr]
23:17:03 <lambdabot>     • Perhaps you meant one of these:
23:17:19 <jle`> @hackage mspack
23:17:19 <lambdabot> http://hackage.haskell.org/package/mspack
23:17:48 <jle`> @hackage msgpack
23:17:48 <lambdabot> http://hackage.haskell.org/package/msgpack
23:18:02 <iqubic> jle`: What's the difference between an iso and an equality?
23:18:09 <jle`> hackage should also have search functionality too
23:18:48 <jle`> iqubic: the only equality is 'id'
23:19:04 <iqubic> What does that mean?
23:19:17 <jle`> id is an Iso
23:19:22 <iqubic> why have the equality data then?
23:19:23 <jle`> and a Lens, and a Fold, and a Prism, and a Traversal
23:19:32 <jle`> none of these are data types, remember
23:19:44 <iqubic> jle`: how does id act like a prism?
23:19:53 <jle`> like i said earlier, its "part" is the thing itself
23:19:59 <iqubic> jle`: What are they then, if not data types?
23:20:01 <jle`> so id is a prism into the entire structure
23:20:05 <jle`> iqubic: they're just normal functions
23:20:10 <jle`> everyday haskell functions
23:20:19 <jle`> they're "families"
23:20:23 <jle`> implemented as type synonyms
23:20:54 <jle`> a Traversal is any function that fits the pattern Applicative f => (a -> f b) -> (s -> f t), for some a, b, s, and t
23:21:02 <iqubic> Alright then.
23:21:15 <jle`> (+ some laws)
23:21:18 <iqubic> Well I understand this library a lot better than I used to.
23:21:20 <jle`> id is a prism into the entire structure
23:21:24 <jle`> > review id 10
23:21:26 <lambdabot>  10
23:21:29 <jle`> > view id 10
23:21:29 <iqubic> Thanks for helping.
23:21:31 <lambdabot>  10
23:21:32 <jle`> no problem!
23:21:35 <Xnuk> @hackage msgpack https://www.stackage.org/nightly/package/data-msgpack
23:21:36 <lambdabot> http://hackage.haskell.org/package/msgpack https://www.stackage.org/nightly/package/data-msgpack
23:21:40 <iqubic> > previw id 10
23:21:42 <lambdabot>  error:
23:21:42 <lambdabot>      • Variable not in scope: previw :: (a0 -> a0) -> Integer -> t
23:21:42 <lambdabot>      • Perhaps you meant one of these:
23:21:49 <iqubic> > preview id 10
23:21:51 <lambdabot>  Just 10
23:22:14 <iqubic> wait, for id, preview = Just
23:22:51 <jle`> yes, preview "gets" the thing inside, and returns Just if there is anything inside, and Nothing if not
23:22:57 <jle`> for id, the thing inside is the thing itself
23:23:07 <jle`> so it will always just return Just the thing itself
23:24:10 <iqubic> I don't understand the type signature for prism.
23:24:31 <iqubic> Can you explain why those Eithers are hanging out there
23:25:38 <iqubic> prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b
23:25:47 <iqubic> How does that work>
23:25:48 <iqubic> ??
23:26:30 <iqubic> And what is the type synonym for Prism s t a b?
23:33:55 <iqubic> Oh, I see.
23:34:53 <iqubic> to construct Prism' you use: (s -> a) -> (a -> Maybe s) -> Prism
