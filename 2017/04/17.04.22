00:09:18 <jle`> i suppose json would sort of make sense as CLI options
04:30:44 <beaky> hello
04:30:56 <beaky> are there recommended tutorials for getting started with monad trnasfomrers
04:31:32 <vaibhavsagar> https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md
04:32:27 <beaky> ah thanks
04:38:05 <stringer> .
04:50:42 <LiaoTao> Hello
04:50:57 <LiaoTao> Has anyone here gotten around https://github.com/haskell/cabal/issues/2012 ?
04:51:09 <LiaoTao> I can't seem to install Haskell Network because of it
04:52:14 <cocreature> LiaoTao: I’m not following, installing the network package shouldn’t require "cabal repl"
04:53:24 <LiaoTao> cocreature, Honestly, I have no idea what the problem is
04:53:30 <LiaoTao> It's just that the compile errors are the same
04:53:43 <cocreature> LiaoTao: could you explain what exactly you did and what the exact error is?
04:55:14 <LiaoTao> cocreature, I'm trying to install Haskell Network on Funtoo using the Gentoo Haskell overlay ebuild
04:55:25 <LiaoTao> I'm not sure what the build itself is doing, but I can go reverse engineer it
04:56:07 <cocreature> LiaoTao: are you doing that because it’s a dependency for some tool written in Haskell or because you want to develop in Haskell?
04:56:19 <LiaoTao> Both
04:57:35 <cocreature> usually you are better of either using "stack" for everything or only installing ghc via your package manager and use "cabal" to install haskell packages
04:57:47 <cocreature> installing haskell packages globally tends to result in problems
04:58:06 <LiaoTao> Cabal is one of the dependencies for stack :(
04:58:09 <LiaoTao> Oh, I mean Network
04:58:45 <cocreature> I would recommend to just download a stack binary but I can see how a gentoo user might not want to do that :)
04:59:34 <cocreature> then again you’ll have to download at least a ghc binary to setup your haskell toolchain so downloading a stack binary might not be so bad
05:00:44 <LiaoTao> cocreature, GHC is bootstrapped on Gentoo AFAIK
05:00:50 <LiaoTao> Anyway it takes ages to build 
05:01:06 <cocreature> LiaoTao: to build GHC you need GHC so a binary has to come from somewhere :)
05:01:19 <LiaoTao> Right
05:01:49 <cocreature> anyway, if you tell us the commands executed by the gentoo scripts and the exact error message we might be able to help you
05:02:02 <fendoer> hey, quick question, will ghc support other llvm versions, too?
05:02:18 <cocreature> but setting up a Haskell toolchain only to then not use it because stack brings its own seems like time not well spent
05:02:37 <cocreature> fendoer: since 8.0 iirc only one version is officially supported per release
05:02:49 <cocreature> fendoer: different ghc releases support different llvm versions
05:03:05 <cocreature> 8.0 supports 3.7 while 8.2 will support 3.9
05:03:20 <cocreature> you can try to use it with a different one but usually that will fail
05:03:37 <cocreature> one notable exception to that is using 4.0 with 8.2 which seems to work since the textual IR format has not changed
05:03:39 <Freundlich> Why is that? Is LLVM not backwards-compatible?
05:03:47 <cocreature> yep
05:03:52 <Freundlich> Oh...
05:04:15 <fendoer> Freundlich, yeah, not even within minor version bumps, the api changes
05:04:27 <fendoer> every time
05:04:39 <fendoer> cocreature, ghc 8.2? i though the current version is 8.0.2?
05:04:52 <cocreature> fendoer: yeah but there’s already rc1 for 8.2
05:05:31 <fendoer> is that stable? on my OS, i only have llvm-3.9 and i would have to build it myself if i want to use version 3.7
05:06:04 <cocreature> fendoer: it’s called release _candidate_ for a reason :)
05:06:08 <cocreature> i.e. it’s not yet stable
05:06:44 <fendoer> well, yeah, makes sense :/ 
05:06:54 <fendoer> and i guess the release isn't even known yet?
05:06:58 <cocreature> yep
05:07:03 <fendoer> makes me sad :/ 
05:07:25 <fendoer> ok, then i'll have to build it from source, worked like a charm last time
05:07:32 <fendoer> just took 3 hours :D 
05:07:44 <cocreature> fendoer: you probably are aware of that but just to be sure: ghc includes its own code generator so you don’t _have_ to use llvm
05:08:34 <LiaoTao> cocreature, https://paste.pound-python.org/show/wqUg4vdtoYHd4X7JyQm7/
05:08:38 <fendoer> cocreature, yeah i want to compare it to ngc. It's for university. And the sample code could make heavy use of vectorized code
05:08:42 <LiaoTao> Those are the commands run in the source directory
05:08:44 <fendoer> *ncg
05:08:58 <cocreature> fendoer: ah yeah that sounds like something you want to use llvm for
05:09:47 <fendoer> cocreature, classic numerical problems, like nbody and so on, it already uses repa, so it might be a performance improvement
05:09:52 <LiaoTao> configure: WARNING: unrecognized options: --with-compiler, --with-hc-pkg
05:09:53 <LiaoTao> Hmm
05:09:56 <LiaoTao> Maybe this is a problem
05:11:36 <LiaoTao> https://paste.pound-python.org/show/ei9dWPHdlQ4KnbgVKfl5/
05:11:39 <LiaoTao> That's the configure log
05:12:38 <LiaoTao> https://paste.pound-python.org/show/qxbTU7OBmJ49exWzOmpM/
05:12:40 <LiaoTao> Build log
05:15:07 <jchia_> I know regular monads and monad transformers like those in mtl, but don't understand free monads. What are some good resources for starting to learn how to use them? The background of this problem is that I may have to use some functions from Data.Store.Streaming from the store package and they reference Control.Monad.Trans.Free.Church.
05:15:39 <cocreature> LiaoTao: looks like https://github.com/haskell/cabal/issues/849 but that was using an ancient version of Cabal which, according to the configure log, you don’t use so I don’t know what’s going on here
05:16:06 <LiaoTao> I think it might be related to GCC version
05:16:22 <LiaoTao> Looks C-related
05:17:30 <cocreature> LiaoTao: might be a good idea to try the gentoo bug tracker
05:20:06 <Freundlich> LiaoTao: Your configure log says it found both sys/socket.h and sys/un.h which are both included in HsNet.h which should be enough to have struct ucred defined.
05:20:20 <Freundlich> I can't really tell why this error happens.
05:20:59 <LiaoTao> Combed through the bugtracker and found nothing
05:21:11 <LiaoTao> Freundlich, I have no idea either
05:21:18 <cocreature> I was more suggesting that you report a bug :)
05:22:16 <LiaoTao> I'll try to solve it before
05:22:19 <Freundlich> I too have network-2.6.3.1 installed from gentoo-haskell and that works as far as I can tell.
05:22:22 <LiaoTao> Thanks for the help, though
05:22:50 <LiaoTao> Freundlich, GHC-8?
05:22:56 <Freundlich> 8.0.2
05:23:04 <LiaoTao> Same :(
05:29:02 <mbw> Could someone please explain to me how these Repa slice operations are supposed to work? It is terribly underdocumented.
05:29:03 <LiaoTao> Yeah that's really strange
05:29:21 <LiaoTao> HsNet.h includes sys/socket.h which includes bits/socket.h that has the definition
05:38:11 <mbw> In particular, is slice to supposed to be used ONLY with Any/All(s) and an Int in-between?
05:39:21 <LiaoTao> Freundlich, cocreature Found the problem
05:39:43 <LiaoTao> Compilation needs -D_GNU_SOURCE, otherwise the struct definition is hidden
05:39:55 <LiaoTao> Not sure what to blame for omitting it, though
05:42:47 <Cale> mbw: I'm pretty sure it will work a good deal more generally than that
05:45:32 <fendoer> hey guys, i want to start a little project with a friend. The idea is, to build a clone of the popular game civilization (sid meier's). We currently in the planning phase and I'm trying to determine which technologies shall be used. The frontend shall be a website written in elm and two players should play against each other. I thought, that a REST API would work really good for such a task. But it is probably not enough, since the 
05:45:32 <fendoer> server ought to push sometimes messages to each client (for example, the other player has finished its round). 
05:45:32 <mbw> Cale: Do you know the intuition behind it? For instance, the simple cases of row/column slices of a matrix. What is the role of All in this?
05:46:13 <Cale> All means you're taking all the indices in that dimension of the array
05:46:30 <mbw> Sorry.
05:46:33 <mbw> I meant Any.
05:46:35 <mbw> :/
05:47:09 <Cale> Any is sort of a placeholder for any possible shape whatsoever, so it's kind of like All, but for multiple dimensions.
05:47:26 <fendoer> so, i'm struggling to find out, which webserver shall be used, my candidates are snap or yesod, do you think that these two would work for a game like that?
05:47:29 <mbw> As I understand, a shape is more or less a snoc list. So Any could be the empty case. Is that the way to see it?
05:47:35 <Cale> yeah
05:48:33 <Cale> https://hackage.haskell.org/package/repa-3.4.1.2/docs/src/Data.Array.Repa.Slice.html#FullShape
05:48:50 <Cale> FullShape/SliceShape might help make it clear what's going on
05:50:01 <Cale> These provide a mapping back and forth between the types of indices you're going to be using on the original array, and on the sliced array
05:50:36 <mbw> If slice a (Any:.(0::Int):.All) is "a[0,:]", are expressions like "a[0,2:3]" possible as well with slice?
05:50:55 <Cale> I'm not sure I understand the latter notation.
05:52:28 <mbw> Instead of "All", it's [a[0,2],a[0,3]].
05:52:34 <Cale> The only instances of Slice that I see are for Any, All, Int, and Z
05:52:36 <mbw> Pseudocode.
05:53:29 <Cale> So, if you want to restrict the range of indices in some direction to something other than a single index, it doesn't appear like there's an appropriate instance for that. It might be possible to write one though.
05:54:05 <mbw> Those should definitely be possible with traverse. However, traverse is kind of a sledge hammer.
06:02:14 <mbw> Cale: Thanks for your help. Looking at the examples again, things seem clearer now
06:25:52 <m0cesta> Hi all. I'm new in Haskell. What does "s -> a" mean in this class definition:
06:25:54 <m0cesta>   class Coll s a | s -> a where
06:25:55 <m0cesta>     empty  :: s
06:25:57 <m0cesta>     insert :: s -> a -> s
06:31:08 <hexagoxel> m0cesta: keyword is "functional dependency", e.g. see https://wiki.haskell.org/Functional_dependency
06:31:34 <m0cesta> Thanks
06:42:15 <phale> hi, in the "syntax in functions - pattern matching" part of LYAH there is this excerpt `lucky :: (Integral a) => a -> String` but running it in ghci gives me this error: `Variable not in scope: lucky :: a1 -> String`
06:43:58 <MarcelineVQ> are you trying to paste the 3 line defintion into ghci?
06:44:06 <m0cesta> Of course, try do it without function signature
06:44:15 <m0cesta> Or run it from source fiile
06:44:40 <phale> oh wait, its all 3 lines ?
06:44:53 <m0cesta> Yes
06:45:03 <byorgey> phale: the ghci prompt is just for evaluating expressions, not really for entering definitions
06:45:13 <MarcelineVQ> yes, and you'll need to use :{  :}  or ; to enter it into ghci, like  lucky :: (Integral a) => a -> String; lucky 7 = "LUCKY NUMBER SEVEN!"; lucky x = "Sorry, you're out of luck, pal!"
06:45:18 <byorgey> try putting the definition of lucky into a .hs file and then  :load  it at the ghci prompt
06:45:38 <MarcelineVQ> a source file like m0cesta and byorgey suggest is also a great idea
06:48:00 <phale> oh okay, also wanted to ask what is the Integral type ?
06:48:59 <byorgey> phale: Integral is a type class, not a type.
06:49:17 <byorgey> Integral a => ...    means 'a' can be any type as long as it is an Integral type
06:50:27 <phale> oh i see
06:50:30 <phale> thank you
07:24:11 <piyush-kurur> byorgey: hey how are you?
07:27:02 <ezyang> MarcelineVQ: no sorry 
07:56:52 <sproingie> trying to understand rank-N and impredicative types... the wiki says "(forall a. [a] -> Int) -> Int really is different from forall a. ([a] -> Int) -> Int"
07:57:05 <sproingie> how are those different?
07:58:19 <hpc> sproingie: the latter will accept a parameter of type [String] -> Int, the former will not
07:58:39 <hpc> the former will only accept parameters with the type (forall a. [a] -> Int) - as in, they have to be polymorphic
07:58:44 <sproingie> ahhh
07:58:56 <hpc> what you get out of this is that, suppose you wrote
07:59:04 <hpc> foo :: (forall a. [a] -> Int) -> Int
07:59:06 <sproingie> oh, now it makes more sense when i leave out the forall in the second version
07:59:25 <hpc> foo f = f "string" + f ["list", "of", "strings"]
07:59:39 <hpc> that would typecheck because f is polymorphic
08:00:03 <hpc> and specifically with the higher-rank polymorphism, you don't have to pick any one type parameter for it
08:00:25 <hpc> so the type variable a there is being used as Char for the first case and String for the second
08:00:51 <hpc> but now it /has/ to be a polymorphic argument, or you wouldn't be able to use it on both
08:01:17 <hpc> you can't just give it something of type [Boolean] -> Int, it wouldn't work in either case
08:01:36 <Tuplanolla> One example of this I like is `apply p f x = (p f) (p x)`, sproingie.
08:01:44 <hpc> @let foo :: (forall a. [a] -> Int) -> Int; foo f = f "string" + f ["list", "of", "strings"]
08:01:45 <lambdabot>  Defined.
08:01:50 <hpc> > foo length
08:01:53 <lambdabot>  9
08:02:12 <Tuplanolla> It works in Scheme just like that, but in Haskell it is a bit trickier.
08:02:31 <sproingie> scheme of course doesn't have to worry about types most of the time
08:02:38 <hpc> :t sum . filter id
08:02:40 <lambdabot> error:
08:02:40 <lambdabot>     • No instance for (Num Bool) arising from a use of ‘sum’
08:02:40 <lambdabot>     • In the first argument of ‘(.)’, namely ‘sum’
08:02:48 <hpc> :t length . filter id
08:02:49 <lambdabot> [Bool] -> Int
08:03:06 <hpc> > foo (length . filter id) -- this is the sort of type error you get when a parameter is too monomorphic
08:03:08 <lambdabot>  error:
08:03:08 <lambdabot>      • Couldn't match type ‘a’ with ‘Bool’
08:03:08 <lambdabot>        ‘a’ is a rigid type variable bound by
08:03:54 <hpc> this whole thing is just RankNTypes btw
08:04:11 <hpc> the distinction between RankNTypes and ImpredicativeTypes is
08:04:33 <hpc> with neither, you can only put foralls outside or to the right of (->)
08:04:46 <hpc> with RankNTypes, you can put foralls to the left of (->)
08:04:59 <hpc> with ImpredicativeTypes, you can put foralls in data definitions as well
08:05:10 <hpc> ImpredicativeTypes are a lot rarer to need, in practice
08:06:02 <c_wraith> I run into cases where I want them all the time.
08:06:07 <c_wraith> But they don't actually work...
08:06:23 <c_wraith> So the workaround is hiding your forall inside a newtype
08:06:52 <sproingie> the example on the wiki looks a lot like an existential type (but using a plain func instead of a type constructor)
08:07:09 <sproingie> er *data constructor
08:08:40 <sproingie> existential types being what got me started on this, though i'm now told it's mostly an antipattern?
08:09:25 <c_wraith> Existentials are fine.  existential + class constraint is usually an antipattern
08:09:59 <c_wraith> But see things like Coyoneda for uses of existentials without class constraints
08:10:05 <Cale> There are cases where existential types are just fine, but you should usually consider other options, like just plain records of functions
08:10:39 <sproingie> Yoneda and such are probably a little over my head ATM 8-/
08:10:59 <c_wraith> data Coyoneda f a where Coyoneda :: (b -> a) -> f b -> Coyoneda f a
08:11:02 <Cale> sproingie: So what are you trying to do?
08:11:06 <c_wraith> It's not really that complex of a type. :)
08:11:20 <sproingie> Cale: i'm just poking around, trying to find something to do actually
08:11:24 <c_wraith> It's got an existential type variable in b
08:12:04 <sproingie> coming back to haskell after years away, a lot of it makes more sense than before
08:13:10 <c_wraith> I thought your name looked familiar
08:34:37 <paolino> Hi, I'm having hard times showing a GADT
08:34:41 <paolino> https://pastebin.com/NfMztHTq
08:35:58 <paolino> I extract it from a more complex one but the recursion schema is the same
08:37:57 <glguy> paolino, you should only need 1 instance
08:38:00 <paolino> I tried with one single instance 
08:38:31 <paolino> I try again then
08:39:33 <cocreature> paolino: note that in "D :: Char -> A b -> A Char" the b is unrelated to the b in "data A b where". (try changing it to a c to see that). You are introducing an existential here which is causing the problem
08:40:15 <paolino> cocreature, I see that
08:40:41 <glguy> the problem is just that there are two instances
08:40:49 <glguy> the existential doesn't really matter
08:40:59 <glguy> it's not used for anything
08:41:52 <paolino> glguy, you are right, I oversimplified the starting example
08:41:53 <cocreature> glguy: are you sure? it looks to me like the problem is that GHC doesn’t find a Show instance for the existential "A c"
08:41:56 <lordofthetards> What are some big/nice features Haskell has that OCaml does not have?
08:42:26 <glguy> cocreature: That's an artifact of the two instances
08:42:35 <cocreature> glguy: right
08:42:43 <sproingie> lordofthetards: type classes
08:43:02 <lordofthetards> sproingie: thanks, anything else?
08:43:19 <sproingie> laziness
08:43:23 <cocreature> purity
08:43:26 <sproingie> (sometimes a feature, sometimes not)
08:43:49 <lordofthetards> cocreature: ocaml is not pure like haskell?
08:44:21 <sproingie> lots of ocaml is written pure, but ocaml itself isn't
08:44:41 <lordofthetards> ah I see
08:45:00 <lordofthetards> So you can modify global state within a function like (Int -> Int) ?
08:45:08 <cocreature> yep
08:45:16 <lordofthetards> ah
08:45:41 <lordofthetards> Do you guys think its reasonable to write a modern web browser in haskell?
08:45:45 <sproingie> generally, you don't, but the fact that you can means you can't reason about code from types alone
08:46:03 <sproingie> or well, do as much reasoning anyway
08:46:07 <Tuplanolla> I don't think it's reasonable to write a modern web browser at all.
08:46:23 <lordofthetards> sproingie: is there like a compiler option or pragma or something that forces purity in ocaml?
08:46:34 <cocreature> at least not as a single-person-project in a reasonable time frame
08:46:38 <Welkin> Tuplanolla: what abou web browsers??
08:46:48 <lordofthetards> cocreature: well you could reuse stuff like webkit
08:46:52 <sproingie> lordofthetards: i doubt it, but i haven't looked at ocaml in 15+ years
08:46:53 <lordofthetards> not from scratch
08:46:56 <Welkin> oh
08:47:02 <Welkin> why would you want to write a web browser though?
08:47:05 <sproingie> there are existing haskell webkit bindings iirc
08:47:06 <cocreature> lordofthetards: well if you reuse webkit you basically have a web browser
08:47:19 <cocreature> I guess it depends on what you consider a web browser
08:47:27 <Welkin> it's been done so many times already and they are nearly as coplex as a modern operating system at this point
08:47:33 <cocreature> if you care about the user interface on top of web rendering then that might be doable
08:47:33 <Welkin> complex*
08:47:36 <lordofthetards> cocreature: but webkit doesnt provide a lot of stuff like tabs, history, syncinc, developer tools, ad blocking, etc
08:47:43 <cocreature> if you want to implement actual html/css/… rendering
08:47:47 <cocreature> then you need a lot of time :)
08:48:15 <Welkin> electron uses webkit right?
08:48:27 <Welkin> and I assume webkit-gtk does too
08:48:33 <Athas> lordofthetards: sure, if you use some other engine, Haskell is probably efficient enough for the UI.
08:48:41 <Welkin> it just renders in a single tab/window
08:48:52 <sproingie> lordofthetards: webkit includes a http user agent, html+css parser, renderer, and JS engine, which makes it pretty full-stack.  those other features are just extras
08:49:31 <sproingie> most of which are actually implemented in javascript on modern browsers
08:49:36 <lordofthetards> so from an efficiency point of view is it reasonable to implement something like webkit in haskell?
08:50:19 <lordofthetards> I would imaging it being hard because of garbage collection and lazyness
08:50:22 <Athas> lordofthetards: probably not.  For a browser engine, it seems that you need very high performance.  Haskell is not slow by any means, but it may not be fast enough.
08:50:36 <lordofthetards> ah ok
08:50:36 <Tuplanolla> I have different ideas of "high performance".
08:50:45 <sproingie> some parts would be easier, the parsers for example.  could probably even do a pretty good JS engine
08:50:46 <MarcelineVQ> hmm, I can't imagine why it would be insufficient
08:50:55 <sproingie> i wouldn't want to reinvent video codecs in haskell tho
08:51:08 <sproingie> (might close off a lot of security bugs if you did)
08:51:21 <Tuplanolla> Web browsers are not run on supercomputers and the load average is rather low.
08:51:23 <Athas> sproingie: they do all kinds of insane tricks in the parsers to get them to run fast.  It's not very principled at all.
08:51:44 <sproingie> Athas: haskell, or at least GHC, is not above dirty tricks when needed.
08:51:50 <Axman6> I can guarantee you that web browsers are run on supercomputers sadly :(
08:51:52 <monochrom> Pretty sure webkit does its own garbage collection.
08:52:09 <sproingie> yeah you'd be writing a new runtime in haskell
08:52:18 <Athas> sproingie: sure, you can just write everything in IO with low-level memory operations (like so many of the language benchmarks game benchmarks are written), but then it's not very nice Haskell anymore.
08:52:33 <Welkin> why would you *want* to write something like this in haskell?
08:52:38 <Welkin> Just to write it in haskell?
08:52:43 <sproingie> Athas: oh not every part would be *nice* haskell, no
08:52:43 <lordofthetards> Welkin: ya :D
08:52:48 <sproingie> not every part of webkit is nice c++ either
08:52:59 <cocreature> Welkin: s/in haskell//
08:53:15 <lordofthetards> C++ is such an ugly language blegh
08:53:34 <Athas> V8 does a lot of code generation at compile-time (for their Javascript interpreter, for example).  *That* code is extremely nasty and would be much nicer in Haskell.
08:53:37 <lordofthetards> I'd rather write C than C++
08:53:42 <Welkin> code that works and is already written doesn't matter if you never need to look at it
08:53:54 <sproingie> what makes haskell impractical for such a thing is that it (GHC at least) has a fairly heavy runtime
08:54:15 <Athas> The GHC runtime isn't really big compared to all the stuff you need in a browser anyway.
08:54:28 <Axman6> Welkin: that's just ignoring hidden costs which you'll probably have to pay for later :)
08:54:30 <MarcelineVQ> For the demoscene it has a heavy runtime, for a browser though I'm not sure what the issue would be :>
08:55:00 <lordofthetards> hmm, I wonder if it might be a good project to try and write a virtual machine (think jvm) for haskell?
08:55:09 <monochrom> "never need to look" is a self-fulfilling vicious cycle. Recall all those 100-year-old COBOL code that people don't dare to look, and therefore they euphemize it as don't "need" to look.
08:55:10 <Axman6> (but I would still use WebKit without auditing the code because enough of us are testing it in prod already)
08:55:50 <Axman6> lordofthetards: sure, you could even make a JIT using LLVM if you really wanted
08:56:33 <Athas> Web standards are changing/"improving" quickly enough that there's a lot of new browser code getting written all the time.
08:56:37 <sproingie> Axman6: until last year, that's precisely what webkit used
08:56:48 <Axman6> I know :)
08:56:49 <Athas> I think V8 by itself has three compilers and at least one interpreter.
08:57:03 <Axman6> WebKit has 4 IIRC
08:57:15 <sproingie> well one of those *is* V8
08:57:39 <Axman6> isn't that Chrome (blink?) only?
08:58:00 <Axman6> Google's and Apple's JS engines are pretty separate afaik
08:58:00 <sproingie> nowadays, sure.  the old webkit branch probably still works
08:58:32 <sproingie> but i guess we're not counting historical versions
09:01:39 <sproingie> more interesting would be replacing JS with haskell
09:02:28 <sproingie> wouldn't want to do it with today's libs, but it's getting easier to do "dynamic" idioms, and JS is embracing more static stuff
09:14:51 <jackhill> now that WebAssembly is more of a thing, I wonder when GHC will grow a backend for that as an alternative to ghcjs
09:15:36 <Athas> Does WebAssembly support interrupt handlers now?
09:15:46 <Athas> Last I looked it wasn't a nice fit for GC'd languages.
09:16:12 <jackhill> Athas: I have no idea
09:30:56 <nut> how to declare type signatures for several types on the same line?  func1,func2 :: int->int ?
09:31:01 <nut> doesnt work
09:32:05 <Welkin> :t f, g :: Int
09:32:06 <lambdabot> error: parse error on input ‘,’
09:32:26 <Welkin> I usally don't do that
09:32:29 <Welkin> use separate lines
09:32:32 <Welkin> but I know it can be done
09:33:25 <nut> ive seen it somewhere 
09:33:28 <geekosaur> actually that works fine
09:33:46 <cocreature> “f, g :: Int -> Int” works fine
09:34:28 <Zemyla> Ooh, kitty http://i.imgur.com/XXpj4R4.gifv
09:34:32 <Zemyla> Wait, wrong channel.
09:34:33 <nut> i got the same error with the parse error
09:34:48 <cocreature> nut: are you trying that in ghci or in a haskell file?
09:34:54 <cocreature> ghci tends to behave in weird ways
09:35:06 <dmj`> Zemlya: is that in japan ?
09:35:08 <nut> haskell file
09:35:11 <dmj`> Zemyla: * 
09:35:16 <Welkin> dmj`: looks like it
09:35:21 <cocreature> nut: can you show us the complete file?
09:35:30 <Welkin> tatami mats on the floor, sliding wooden doors
09:36:41 <miscyb> is there a special way to import pattern synonyms?
09:36:53 <geekosaur> lpaste seems a bit buggy thouygh...
09:37:11 <miscyb> i'm trying to pull in a constant from gi-glib, and it's giving me an import error
09:37:55 <geekosaur> https://bpaste.net/show/82d96be18d11 syntax works fine. will not work typed into ghci though
09:38:26 <geekosaur> miscyb, afaik it should just work although there is a syntax for specifically importing synonyms
09:39:06 <dmj`> miscyb:  import Module (pattern PatternSyn)
09:39:08 <miscyb> geekosaur: yeah i'm doing an "import GI.GLib (MY_PATTERN)
09:39:09 <miscyb> oh
09:39:12 <miscyb> thanks
09:39:14 <geekosaur> with rspect to gi, iirc it will customize itself to your instakled glib so you might make sure the ine you have installed supports that symbol
09:39:55 <miscyb> it's a priority symbol so it's probably there
09:40:15 <nut> https://bpaste.net/show/85cd6b97edc3
09:40:22 <nut> cocreature: 
09:40:56 <monochrom> Very likely you need to capitalize expr to Expr
09:41:04 <monochrom> Err, no.
09:41:23 <geekosaur> wha's the full error message?
09:41:24 <monochrom> You will need to show more complete code.
09:41:34 <cocreature> lowercase EarlierThan and LaterThan
09:41:43 <monochrom> Ah, that.
09:41:44 <miscyb> "import GI.GLib.Constants (pattern PRIORITY_DEFAULT_IDLE)" is giving me a parse error on "PRIORITY_DEFAULT_IDLE"
09:41:59 <miscyb> would that likely be from a missing symbol or something else?
09:42:20 <nut> oh yes, stupid me
09:43:26 <geekosaur> miscyb, I am pretty sure that import syntax needs {-# LANGUAGE ExplicitNamespaces #-}
09:44:11 <miscyb> geekosaur: that didn't seem to change anything sadly
09:44:33 <paolino> glguy, https://pastebin.com/ySWrPKj9 , sorry for confusion, this was the original error that I tried to solve splitting the instance
09:44:49 <geekosaur> the other thing is I suspect it needs to be pRIORITY_DEFAULT_IDLE or something, since it seems unlikely that they translate it to a constructor
09:45:32 <geekosaur> hm, but their docs say they do. fun
09:46:40 <paolino> glguy, splitting the instance should take away the R recursion leading to the previous problem, or, that was the path I followed
09:47:01 <miscyb> geekosaur: i just imported constants as qualified and it seems to be importing correctly
09:47:11 <miscyb> at least i think so i have other errors i need to fix now
09:53:32 <fizbin> Has someone here already emailed whoever maintains http://ircbrowse.net/browse/haskell about its non-working status?
09:59:02 <Gurkenglas> '<akegalj> hey guys. Are we maintainers of ircbrowse.net ? Seems like its down. Visiting http://ircbrowse.net/browse/haskell for example throws "libpq: failed (another command is already in progress)"' '<akegalj> ok, I contacted maintener. Thanks'
09:59:11 <Gurkenglas> Also '<peterbecich> this alternative to ircbrowse seems to work: http://irclogger.com/.haskell-beginners/2017-04-16'
10:02:07 <cloudhead> anyone familiar with Spock?
10:02:38 <EvanR> doesnt anyone have opinions on DSP libs for haskell, the one called DSP seems obvious but not sure if its overly presumptuous with that name
10:05:07 <glguy> paolino: The solution here is going to be to make this type less of a mess
10:07:13 <paolino> ok, I will rethink the original model and see if I get better
10:15:39 <sproingie> EvanR: maybe the fft library?
10:15:40 <glguy> paolino: {-# language TypeFamilies #-}
10:15:58 <glguy> paolino: https://paste.fedoraproject.org/paste/yELgrrQTDVmku1~kVmZ1Fl5M1UNdIGYhyRLivL9gydE=
10:16:52 <glguy> wow, that's quite a URL for a paste
10:17:23 <sproingie> helps for private pastes i suppose
10:20:31 <glguy> paolino: Or if we enable UndecidablesuperClasses, we can do this https://paste.fedoraproject.org/paste/zZo8slN8waybb8FqyKGQlV5M1UNdIGYhyRLivL9gydE=
10:26:27 <paolino> glguy, where is proxy function coming from ?
10:26:38 <glguy> it's a variable
10:27:20 <paolino> mh, a lot of concepts I don't know
10:27:38 <glguy> 'proxy' comes from the same place as 'o'
10:27:58 <glguy> all type variables are implicitly universally quantified by their type signatures
10:28:37 <monochrom> The same way you sometimes say "Applicative f => f ()"
10:28:45 <glguy> Well, in this case 'o' comes from the instance head, but it's just a normal type variable
10:30:01 <paolino> why it's not Proxy o ?
10:30:07 <glguy> because it doesn't need to be
10:30:47 <monochrom> "Nothing :: Maybe o" and "[] :: [] o" work just as well.
10:30:55 <glguy> accepting any type at all is more general than requiring the particular type 'Proxy'
10:31:09 <glguy> (any type at all with kind A -> *)
10:31:12 <monochrom> Anything that phantomly carries the type o
10:31:24 <paolino> ok, we don't use it
10:32:02 <paolino> so why not just o ?
10:32:13 <glguy> Because o has kind A
10:32:24 <glguy> but (->) has kind: * -> * -> *
10:32:30 <glguy> so you can't apply (->) to o
10:33:00 <monochrom> Oh! Then I guess Maybe and [] aren't good for this one.
10:33:43 <glguy> monochrom: but you know what is??
10:33:45 <glguy> I!
10:34:33 <glguy> https://paste.fedoraproject.org/paste/IhgWpX9EMvVRQgdVAj2M3l5M1UNdIGYhyRLivL9gydE=
10:34:43 <glguy> Now we don't need scoped type variables
10:34:57 <glguy> When you have a proxy hammer everything looks like a proxy nail...
10:35:10 <paolino> ah I see you need to pass a * to showPA, right ?
10:36:24 <paolino> so Proxy is polymorphic in the kind ?
10:36:31 <monochrom> Yes.
10:36:34 <glguy> Yes, the Proxy type is "polykinded"
10:36:47 <glguy> and you can only apply functions to values, and all values have types that have kind *
10:36:54 <paolino> while Maybe and [] not
10:37:17 <monochrom> Right, Maybe and [] want *
10:37:24 <glguy> Something doesn't have to be poly-kinded to have kind  A -> *
10:37:35 <glguy> but having a kind like   k -> *   certainly helps for having that kind
10:38:03 <glguy> We could have had a non poly-kinded  data AProxy :: A -> * where AProxy :: AProxy o
10:38:11 <paolino> I should have written one
10:38:14 <paolino> ok
10:38:21 <EvanR> to understand haskells type system, first understand dependent types, then smash it
10:38:59 <monochrom> When you're a manucare professional, everything looks like a finger nail. :)
10:39:20 <paolino> ok, now what is Dict ?
10:39:30 <glguy> monochrom: That sounds like a nightmare
10:39:48 <EvanR> when all the men and horses put it back together again, we will have -XDependentTypes
10:39:49 <glguy> paolino: start here http://hackage.haskell.org/package/constraints-0.9.1/docs/Data-Constraint.html#t:Dict
10:40:15 <paolino> bringing the constraint into the type
10:43:36 <paolino> so you separated the instance in the end
10:44:30 <paolino> at the right level
10:45:36 <paolino> pattern matching on Dict bring the Helper (R o) in scope 
10:45:41 <robertkennedy> > take 11$ (\x y -> x * 10 + y) <$> [0..9] <*> [0..9]
10:45:43 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
10:46:40 <robertkennedy> What is ekmett taking about here: concat :: [[a]] -> [a]
10:46:40 <robertkennedy> requires more power than ...
10:46:40 <robertkennedy> https://www.reddit.com/r/haskell/comments/66q5ez/why_is_list_a_monad/
10:47:15 <robertkennedy> Sorry I guess it copy pasted more than the link mb 
10:47:43 <cocreature> robertkennedy: you can implement concat using >>= but you can’t implement it using <$>,<*> and return
10:48:41 <robertkennedy> His last example doesn't seem to illustrate that, as you can write what I put above
10:48:57 <MarcelineVQ> hmm? take 11 isn't in his example
10:49:19 <robertkennedy> I took 11 to limit the output
10:49:30 <MarcelineVQ> oh I see you wer ejust shortening it hehe
10:51:04 <lyxia> robertkennedy: [x..9], not [0..9]
10:51:12 <monochrom> You are right, that example still stays within Applicative. In fact if you turn on ApplicativeDo, that do-block just uses <$> and <*>
10:51:25 <monochrom> Err, oops, yeah, what lyxia said.
10:51:26 <MarcelineVQ> > (do x <- [0..9]; y <- [x..9]; return $ x*10 + y) == ((\x y -> x * 10 + y) <$> [0..9] <*> [0..9])
10:51:29 <lambdabot>  False
10:51:47 <robertkennedy> Oh I didn't see the x, my bad, you are right
10:52:55 <lyxia> It seems pretty easy to miss :)
10:53:06 <MarcelineVQ> ye
11:04:39 <phale> when should I use [a] ++ [] over a : [] or vice versa ?
11:07:36 <sproingie> just plain [a] ought to do, no?
11:07:54 <sproingie> or were you looking for a binary op?
11:08:12 <phale> I was just reading the spring haskell guide
11:08:18 <phale> And they mentioned ":" being the cons operator for lists
11:08:25 <phale> And then I recall in LYAH they used ++ for concatenation
11:09:23 <sproingie> right, ++ concatenates two lists, : conses onto a list.  which you use depends on whether you want concat or cons
11:09:57 <Tuplanolla> > shows (42 :: Int) . shows (13 :: Int) $ "" -- The third option, phale.
11:09:59 <lambdabot>  "4213"
11:10:07 <Sornaensis> :t (:)
11:10:08 <lambdabot> a -> [a] -> [a]
11:10:09 <Sornaensis> :t (++)
11:10:11 <lambdabot> [a] -> [a] -> [a]
11:10:12 <MarcelineVQ> you can also call  :  prepend
11:10:26 <ChaiTRex> phale: In general, with one element to put on the front of the list, you use (:).
11:10:43 <ChaiTRex> phale: You use (++) to put an element on the end of the list.
11:10:57 <ChaiTRex> phale: Like xs ++ [a]
11:11:05 <phale> Oh, I see
11:11:06 <sproingie> or mappend if you want it really generic
11:11:08 <sproingie> :t mappend
11:11:09 <lambdabot> Monoid a => a -> a -> a
11:13:16 <sproingie> (which conicides nicely with that video just posted on /r/haskell)
11:16:33 <Beelsebob> so, I saw this... https://aphyr.com/posts/342-typing-the-technical-interview and I feel like whoever wrote it should be pleased to know that it inspired this horror https://gist.github.com/beelsebob/18e144d95aa7cd19161e387ec2ee8147
11:16:59 <Beelsebob> aside - clang manages to solve this for a 32x32 board in 2 seconds on my machine, so it's not as horribly inefficient as you might expect
11:17:50 <lolisa> Hi, a question purely on design taste
11:18:27 <lolisa> why does most function in https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-List.html take [a] as the last parameter (instead of the zeroth parameter?)
11:19:12 <Beelsebob> lolisa: generally functions have their parameters ordered in such a way that you can partially apply them and get something useful
11:19:24 <sproingie> doesn't c++17 let you omit 'typename'?
11:19:30 <XorSwap> so that you can stack them nicely: map f $ filter g $ takeWhile h [...]
11:19:35 <Beelsebob> which generally means you put the parameter you're most likely to "default" as the first
11:19:35 <sproingie> (not that it would make it much easier to read)
11:19:59 <Beelsebob> sproingie: plausible - I'm still in C++11 land
11:20:45 <lolisa> I mean, is there any heuristic I can use to figure out which parameter can get partially applied?
11:20:48 <Beelsebob> sproingie: if it does' that seems like a valid reason for me to update - missing out typename is my most common pointless error message
11:20:59 <Beelsebob> lolisa: mostly just think "how would most people use this"
11:21:04 <sproingie> ah i'd be on c++14 at least, it makes 'auto' a lot more useful
11:21:05 <Beelsebob> that's about the best you can do
11:21:47 <Beelsebob> sproingie: much like in Haskell, I *can* infer types, but I mostly write : X, purely for documentation; in C++, I tend not to use auto
11:21:51 <sproingie> might be you can only omit it if you don't actually use it in the expansion
11:22:07 <Beelsebob> although, doesn't C++14 allow you to omit template parameters on the right hand side when they're inferable?
11:22:11 <Beelsebob> because *that* would be useful
11:22:50 <Beelsebob> std::vector<SomeComplexType> x = std::vector<SomeComplexType>(...) is frustrating to write
11:23:03 <sproingie> get thee to auto
11:24:07 <sproingie> auto x = vector { 1, 2, 3 }
11:24:09 <sproingie> something like that
11:24:18 <Beelsebob> yeh - but again - I *like* having the type on the left
11:24:20 <Beelsebob> for documentation
11:24:33 <sproingie> sure, but it's nice when it's optional
11:24:33 <Beelsebob> it's the constructor I want to simplify, not the type
11:24:59 <sproingie> tho there are a few WTFs with initializer lists, usually only bite you when you're writing new types tho
11:25:39 <sproingie> initializer lists in the presence of overloaded constructors are ... yeah, i'm happy to be out of that swamp right now :)
11:25:42 <c_wraith> Yeah, I saw a blog post on that topic a while back.  The whole thing was nearly incomprehensibly complex for "correct" behavior. :)
11:25:55 <Beelsebob> sproingie: yeh, C++ has a *lot* of weird shit going on around initializer lists in general
11:25:59 <Beelsebob> I've met several bizare bugs there
11:26:09 <sproingie> the amount of bookkeeping you have to do by hand when making new C++ APIs is ... yeah
11:26:10 <Beelsebob> (in my code, that "obviously" did one thing)
11:26:14 <sproingie> it's getting better.  slowly.
11:26:53 <sproingie> 'default' and 'delete' keywords were a big help
11:26:59 <Beelsebob> unfortunately, C++ is the only language that outputs predictably fast code reliably that has a "real" type system
11:27:03 <Beelsebob> so, I'm stuck there for a while
11:27:21 <sproingie> FSVO "real"
11:28:02 <rightfold> Rust
11:28:33 <Beelsebob> sproingie: yarp
11:28:37 <sproingie> from reading about "ownership", rust seems to trade one headache for another
11:28:39 <XorSwap> I wonder how crazy a c++ parser would get if type names were mostly optional
11:28:58 <Beelsebob> XorSwap: you mean if you could simply omit auto?
11:29:05 <XorSwap> yeah
11:29:12 <Beelsebob> given how crazy C++ parsers already are, probably not much more crazy :P
11:29:30 <Beelsebob> I mean, in terms of absolute craziness increase, probably a large amount, but relatively... pffft
11:30:05 <sproingie> probably simplify things greatly if you converted everything to use postfix type syntax
11:30:13 <sproingie> keeping it compatible tho ... pretty awful
11:30:28 <XorSwap> c++ with postfix syntax would be neigh unreadable though
11:30:44 <Beelsebob> C++ already *has* some postfix type syntax
11:30:46 <Beelsebob> (for closures)
11:30:47 <sproingie> it already has it, you actually need it in some places
11:30:59 <Beelsebob> because they couldn't figure out how to make the syntax not horrible having dug themselves the prefix hole
11:31:14 <sproingie> "-> decltype(foo)" is pretty nice to have
11:31:18 <Tuplanolla> The committee should add templates to the preprocessor too.
11:31:40 <Beelsebob> Tuplanolla: I mean, no one using C++ really uses the preprocessor for anything other than #include
11:31:43 <Beelsebob> so... *shrug*?
11:31:46 <sproingie> the preprocessor is the crazy old uncle they keep locked in the basement, far as the committee is concerned
11:31:50 <XorSwap> there's an idea, haskell with c preprocessor
11:31:56 <sproingie> XorSwap: already a thing
11:32:00 <XorSwap> !
11:32:04 <Sornaensis> ghc has that extension
11:32:10 <sproingie> {-# LANGUAGE CPP #-}
11:32:13 <dimitrovskif> Is Prelude written in Haskell? Can you implement map without Prelude functions like folds
11:32:23 <sproingie> prelude is pure haskell
11:32:25 <Sornaensis> yes the prelude is written in haskell
11:32:34 <ChaiTRex> @src map
11:32:34 <lambdabot> map _ []     = []
11:32:34 <lambdabot> map f (x:xs) = f x : map f xs
11:32:52 <dimitrovskif> Oh. That's nice
11:32:54 <sproingie> the compiler makes some assumptions about prelude stuff afaik.  tho maybe that's all in rules too, i dunno
11:32:55 <Sornaensis> using #include in C++ is kind of bad already
11:32:59 <Tuplanolla> The only parts you can't implement is `Bool` and `GHC.Prim` stuff, dimitrovskif.
11:33:07 <dimitrovskif> Tuplanolla: Thanks
11:33:26 <dimitrovskif> So what parts are needed to be able to fully express any program / be Turing Complete?
11:33:28 <sproingie> c++ is getting real modules, so maybe #include will become legacy too
11:33:29 <Sornaensis> why can't you implement Bool
11:33:32 <glguy> many of the definitions exported by the prelude are implementable in standard haskell
11:33:53 <Sornaensis> data Bool = True | False
11:33:53 <Tuplanolla> You'd need `RebindableSyntax` for `if` et al, Sornaensis.
11:33:56 <Beelsebob> Tuplanolla: what's the problem with data Bool = True | False?
11:33:58 <sproingie> to be turing complete?  brainfuck is fairly minimal.  you want functional, S and K
11:33:58 <glguy> but other parts of it have to be primitives provided by the compiler
11:34:14 <Sornaensis> oh you mean if then else
11:34:20 <Tuplanolla> Yes.
11:34:25 <XorSwap> I think S and K are already in haskell
11:34:31 <sproingie> in several forms, i imagine
11:34:32 <XorSwap> s is ap?
11:34:47 <Athas> dimitrovskif: the Prelude cheats a little to get number types, I think.
11:35:01 <XorSwap> yeah, ap and const
11:36:03 <sproingie> unlambda would be the closest thing to functional brainfuck i suppose.  no one talks about unlambda anymore.
11:36:13 <dimitrovskif> I mean like what parts of Haskell (not the opposite, what do you need to have lambda calculus) can you throw out and still have turing complete lang/
11:36:29 <sproingie> well, start with Core and pare it down
11:36:45 <sproingie> Core is well outside of my wheelhouse tho
11:37:03 <XorSwap> unlambda isn't very functional though
11:37:07 <Cale> dimitrovskif: Perhaps a more interesting question is what little you can throw out to ensure that all programs terminate.
11:37:20 <sproingie> XorSwap: sure it is, every tick is "apply"
11:37:21 <Tuplanolla> All you need is iota or jot, but I don't know how well those fit in with Haskell's type system.
11:37:59 <XorSwap> unlambda relies on evaluation order though
11:39:03 <sproingie> sure, that doesn't keep it from being complete tho
11:39:33 <sproingie> me, i'm more a fan of befunge :)
11:39:56 <XorSwap> it is complete, I'm just saying it's not realy in the spirit of functional
11:40:02 <sproingie> there's another language out there where every instruction has a random chance of failure.  you program it stochastically
11:40:08 <sproingie> i wish i could remember the name of it
11:40:10 <XorSwap> java2k?
11:40:21 <sproingie> aside from PHP that is
11:40:30 <XorSwap> yeah, it's java2k
11:40:45 <sproingie> oh awesome :)
11:40:49 <dimitrovskif> And another question... Is partial evaluation a consequence of currying?
11:41:10 <Beelsebob> partial *application* and currying are related
11:41:12 <Athas> No partial evaluation is a program transformation technique.
11:41:12 <EvanR> no its a separate feature
11:41:14 <Cale> Partial evaluation is separate from currying, but not entirely unrelated
11:41:26 <sproingie> i'd love to see an actual serious non-esolang version of java2k
11:41:32 <Beelsebob> currying is what allows you to partially apply functions
11:41:47 <c_wraith> Cale: it's pretty unrelated. :)  Partial evaluation is things like supercompilation
11:41:48 <sproingie> but i suppose some bytecode hacking could do it for arbitrary java
11:41:48 <EvanR> javascript libraries like to give you partial application (-ish) but doesnt have currying
11:41:49 <dimitrovskif> Beelsebob: Yeah that's my question
11:41:52 <Cale> You can have one without the other
11:42:03 <dimitrovskif> Does Haskell explicitly implement partial evaluation
11:42:12 <c_wraith> only trivial things
11:42:19 <dimitrovskif> Or is the fact that functions are curried enough
11:42:25 <Cale> But you can get some effects of partial evaluation from partial application.
11:42:28 <EvanR> the main feature is partial application
11:42:43 <Cale> However, you kind of need to make it happen explicitly
11:42:52 <Cale> You'll end up writing things like:
11:43:13 <Cale> f x = let ... some stuff which uses x ... in \y -> ...
11:43:23 <phale> also i wanted to ask
11:43:27 <phale> how come in ghci variables are mutable ?
11:43:40 <sproingie> it's faking it
11:43:55 <Cale> (with possibly some seq's occurring ahead of that \y -> ...)
11:44:02 <EvanR> variables arent mutable
11:44:06 <EvanR> they are rebindable
11:44:11 <EvanR> and its not just in ghci
11:44:13 <geekosaur> they're not mutable, they're shadowed
11:44:18 <Cale> The idea being that you can expose some of the work that the function has to do after having been applied to a single argument
11:44:27 <Cale> and it can do that work before giving you a resulting function
11:44:38 <geekosaur> which means something referring to the old bin ding still refers to that old binding
11:45:16 <Cale> e.g. if you were implementing a regular expression matching function, you'd take the regular expression first, and then possibly compile that into a finite state machine before resulting in a function which uses that FSM to test if strings match
11:46:07 <Cale> Which is kind of similar to partial evaluation
11:47:11 <ChaiTRex> phale: See https://pastebin.com/EagTAHzB
11:49:11 <sproingie> istr ghci used to actually make you type 'let'
11:49:30 <monochrom> It is actually pretty hard to distinguish, observationally, between mutation and shadowing.
11:49:33 <geekosaur> before 8.0, yes
11:49:41 <dimitrovskif> Shouldn
11:49:46 <dimitrovskif> this work (uncurry map) ((\f x-> x), [1,2,3])
11:50:09 <EvanR> by hard you mean totally possible?
11:50:10 <dimitrovskif> Nvm, extra 'f'
11:50:21 <EvanR> therefore theoretically easy
11:50:23 <sproingie> basically, 'x = foo' in ghci implies a leading 'let', which is why it works.  basically it's "let foo = bar in <rest of ghci session>"
11:50:49 <sproingie> or something like that
11:50:57 <EvanR> yes
11:50:59 <monochrom> A value that was defined under the old binding can be explained in the mutation narrative as taking its snapshot back then and so will be unaffected by the new binding.
11:51:16 <XorSwap> huh, so will more and more rebindings increase memory usage?
11:51:23 <EvanR> heh. a "deep copy" ?
11:51:31 <EvanR> i.e. immutation
11:51:38 <phale> oh i see
11:51:47 <phale> i also wanted to ask about what identation should i use for haskell ? 2 spaces ?
11:51:57 <XorSwap> tabs
11:52:04 <EvanR> XorSwap: immutable data can use more memory yes
11:52:05 <phale> i do tabs and then ghc gives me warning
11:52:11 <sproingie> it should free any unused environments, otherwise recursive code would also be in trouble
11:52:34 <XorSwap> phale: ghc is wrong about the tabs
11:52:38 <sproingie> immutable data can also use less memory due to structure sharing.  depends how you use it.
11:53:08 <EvanR> sharing is an optimization though
11:53:11 <MarcelineVQ> phale: for general structure 4 for the most part, 2 for where, an example here: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
11:53:15 <monochrom> I recommend 4 spaces but it is really up to you.
11:53:22 <EvanR> the deep copy narrative would have you believe otherwise
11:53:23 <sproingie> ahh spring in colorado, the hail season is starting
11:53:48 <monochrom> All hail Colorado?!
11:53:58 <EvanR> all hail naw
11:54:13 <Tuplanolla> My observation has been that two spaces work the best when you have to deal with two dozen different languages and keep forgetting which style to use, phale.
11:54:14 <MarcelineVQ> the prevailing opinion is that spaces result in happier coding sessions with haskell
11:54:33 <EvanR> i wish tabs were illegal in haskell
11:54:53 <Sornaensis> they aren't?
11:54:59 <sproingie> i wish tabs were sane in general
11:55:25 <glguy> No, tabs are defined to advance to the next tabstop, and tabstops are defined to be multiples of 8 columns
11:55:28 <EvanR> tabs work but probably not how you think
11:55:31 <monochrom> A lot of other programming communities like tabs. They have a good reason. But that same reason turns against Haskell (generally any layout languages).
11:55:53 <sproingie> only language i know that standardizes on tabs for indent is go
11:56:01 <XorSwap> they should make {} and ; manditory
11:56:03 <EvanR> also Makefiles
11:56:05 <sproingie> well that and make but let's not talk about make as a "language"
11:56:06 <Tuplanolla> Don't forget GNU Make, sproingie.
11:56:14 <XorSwap> lol
11:56:18 <sproingie> (i've written way too much turing complete make)
11:56:20 <Tuplanolla> It's Turing complete and has io...
11:56:35 <MarcelineVQ> modern editors can turn your tab button into whatever number of spaces you like, or even adaptively, so I'm not sure what the advantage of tab is these days. bit of a dead-horse type opinion though
11:56:36 <tomskel> does anyone know much about atom-haskell?
11:57:07 <MarcelineVQ> tomskel: ide-haskell? having an issue?
11:57:35 <sproingie> go's approach is to make the reformatter part of the language distribution, so use whatever style you like, it'll all end up gofmt-style in the end
11:57:45 <sproingie> bit unusual approach but i guess it works for go
11:57:45 <tomskel> MarcelineVQ: yup ide-haskell. I am indeed having an issue, it's having problems with ghc-mod. After playing about with the commands it's executing, I worked out it's running ghc-mod with the wrong cwd ... so the commands are failing.
11:58:05 <EvanR> im glad haskell doesnt reformat my code to look terrible
11:58:10 <monochrom> MarcelineVQ: The advantage is that if you like to indent by 7 spaces and I like to indent by 3.14159 spaces, then we agree to put tabs in the file, you set your editor to display tabs as multiples of 7, I set my editor to display tabs as multiples of 3.14159, then we will not have a whitespace commit war.
11:58:16 <EvanR> or force me to write like everyone elses terrible formatting ;)
11:58:20 <sproingie> i don't think there's a way to make golang pretty
11:58:36 <MarcelineVQ> tomskel: is your project using stack?
11:58:48 <EvanR> lambdamoo is pretty funny, your source code is reconstructed from the compiled virtual machine code
11:58:55 <monochrom> Exactly the reason why, for example, tab works great for Java. And exactly the same reason why it completely breaks down with Haskell.
11:58:57 <tomskel> MarcelineVQ: I'm playing with the GHC codebase, so I don't think so :-)
11:59:00 <EvanR> so the formatting becomes standardized
11:59:07 <EvanR> and your comments dont survive
11:59:33 <hexagoxel> EvanR: and your variables become register names?
11:59:37 <EvanR> they survive
11:59:38 <sproingie> EvanR: which ruled out a whole lot of optimizations
11:59:52 <EvanR> well its based on C, so optimizations are not that happening
11:59:54 <sproingie> tho i suppose nothing stops it from just storing intermediate opcode
11:59:55 <hexagoxel> EvanR: there, i can comment. :D
12:00:06 <sproingie> MOO needed JIT anyway
12:00:22 <EvanR> hexagoxel: conventional comments are statements consisting of a string literal
12:00:25 <EvanR> which survives
12:00:37 <hexagoxel> yeah yeah :)
12:00:44 <sproingie> only JIT i can think of that MOO did was peephole optimizations to reduce copies
12:00:45 <EvanR> all in all kind of goofy
12:01:00 <MarcelineVQ> tomskel: hehe alright, in that case I probably don't have anything to add that would be helpful since you've likely already tried editing the paths in the haskell-ghc-mod plugin settings
12:01:17 <sproingie> since MOO primitives are also immutable
12:01:24 <sproingie> FP came easy to me after MOO
12:01:34 <tomskel> MarcelineVQ: ah no I haven't, didn't know that was a thing :-)
12:01:43 <MarcelineVQ> oop, well have a look :>
12:02:00 <EvanR> FOO, functional moo, still on my list of things to do
12:02:25 <sproingie> etamoo is a MOO server in haskell
12:02:52 <Sornaensis> lambmoo
12:02:59 <sproingie> docs say it's not complete, looks like it's pretty close tho
12:03:01 <MarcelineVQ> that being said ghc-mod might not play nice with the GHC codebase anyway given how it's layed out, but I'm not certain of that
12:03:31 <NextHendrix> i have a Double, its a big one, and its being printed out in the form 2.234523423452353e10
12:03:56 <Sornaensis> :t printf
12:03:58 <lambdabot> PrintfType r => String -> r
12:03:59 <sproingie> Sornaensis: no instance for (Cow t0) arising from a use of "moo"
12:04:03 <monochrom> Look into the Numeric module for tools to format Double in some other forms.
12:04:11 <NextHendrix> cheers
12:04:16 <NextHendrix> can't wrap my head around printf
12:04:18 <Sornaensis> λamoo
12:04:37 <Sornaensis> printf is a weird one
12:05:06 <EvanR> printf is more of a "look what haskell can do" rather than a good way to format doubles
12:05:16 <phale> when should i use $ over () ?
12:05:23 <monochrom> Never.
12:05:24 <sproingie> i had MOO doing garbage collection on objects as one of the last hacks i did
12:05:36 <sproingie> and the moo server in general using boehm gc
12:05:38 <phale> monochrom, y not?
12:05:40 <EvanR> do (
12:05:41 <EvanR>  ...
12:05:42 <EvanR> )
12:05:42 <phale> does it make it more unreadable
12:05:46 <EvanR> *error*
12:05:56 <sproingie> still had to keep refcounts tho, so it didn't gain much from the gc runtime
12:06:12 <EvanR> forever (do ... ) i mean
12:06:20 <monochrom> Parentheses tell me what the parse tree looks like. $ does not.
12:06:24 <MarcelineVQ> ehe, well it's good to learn how $ works because it'll teach you about precidence and fixity and other things but you do use it less and less as time goes on
12:06:38 <MarcelineVQ> s/you/I/
12:06:40 <Sornaensis> $ is ♥
12:07:00 <Sornaensis> im allergic to parentheses
12:07:16 <monochrom> Yes, most programmers are.
12:07:25 <EvanR> "haskell has a lot of parentheses" someone said to me
12:07:35 <monochrom> Most programmers chose to be programmers because they hated algebra, which is where parentheses came from.
12:07:59 <sproingie> "foo . bar . baz $ mumble frotz" was the prevailing style last i was doing haskell
12:08:13 <XorSwap> "if you hate math, you'll *love* haskell!"
12:08:16 <monochrom> It was a wonder that Fortran actually became more popular than its predecessors.
12:08:23 <EvanR> sproingie: gross
12:08:36 <sproingie> what's the current opinion then?
12:08:53 <Cale> monochrom: lol
12:08:59 <monochrom> "I can now write algebra formulas as-is!" You would think that programmers would revolt against that.
12:09:36 <sproingie> i was a math-o-phobe for the longest time.  i've recently decided i actually love math, i just hate numbers
12:09:48 <monochrom> If you loved math you would have become a Wall Street quant now and earn 10 times more money than programming.
12:10:15 <sproingie> having a soul might preclude that
12:10:16 <monochrom> If you loved read, writing, and reasoning about documentation you would have become a lawyer now, likewise.
12:10:34 <sproingie> again
12:10:38 * EvanR agrees with monochrom 
12:11:12 <monochrom> The conclusion is that the programming community is drained of any skill of math or documentation.
12:11:16 <MarcelineVQ> sproingie: to be on topic again, depending on other factors, that's just   foo . bar . baz . mumble
12:11:42 <sproingie> i see stuff like http://worrydream.com/LadderOfAbstraction/ and think "damn why wasn't i learning to think like this back when i was in school"
12:11:56 <EvanR> monochrom: as "coding" crash courses become the new norm, it will get even devoid of programming skill
12:12:19 <EvanR> the "everyone should be able to do maintenance on their car" of RMS is backfiring
12:12:33 <sproingie> i bet you a million dollars RMS hasn't the faintest idea how to fix a car
12:12:37 <EvanR> because theyre not learning lisp, theyre learning HTML5
12:13:05 <sproingie> (er wait, he probably knows a lot about fixing cars and cdrs)
12:13:48 <fXl> hello guys, i am trying to read yaml file but gettin error like  "Non-exashutive ..." the list returns empty, can anybody help? here what i did. https://hastebin.com/ukayuwusuf.hs
12:13:52 <sproingie> it'd be nice if brendan eich got his way and implemented scheme like he wanted
12:14:18 <monochrom> On the bright side, I can fix my HTML5 files too.
12:14:24 <EvanR> dont worry plenty of ways to make scheme suck too
12:14:34 <KunoMark> Hello peeps.
12:14:50 <sproingie> but aside from the awful 'new' operator semantics, the prototype OO trick of JS was actually a pretty neat addition
12:14:57 <KunoMark> I'm trying to do something which I feel is a little bit crazy, but I think aught to be possible.
12:16:08 <sproingie> haskell's the ideal language for crazy-but-possible
12:16:33 <KunoMark> I wanna see if I can use existentials, or something, to create a hashmap which doesn't know before-hand the types of its keys and values.
12:16:41 <monochrom> Yeah, JS taught me prototype OO.
12:17:01 <EvanR> KunoMark: check out "dependent map"
12:17:11 <monochrom> Previously I only saw prototype OO described handwavingly in books.
12:17:24 <EvanR> it wont be a hashmap, but youve already set it up for that not to be possible
12:17:29 <sproingie> was MOO that taught me prototype OO.  JS does it very differently tho.
12:17:32 <KunoMark> Let me take a look, EvanR.
12:17:52 <monochrom> Yes, I'm aware. JS is a leaky abstraction of OO.
12:18:02 <KunoMark> Hmm...
12:18:32 <KunoMark> I would like to use an existing data structure though, EvanR. That provided by LRUCaching library.
12:18:36 <sproingie> Self's prototype OO is different still.  much more powerful, since there's no single "parent" type, it's all delegated slots
12:18:42 <EvanR> the one im talking about exists
12:18:48 <sproingie> *"parent" slot
12:18:56 <EvanR> but sounds like yours already exists too
12:19:08 <KunoMark> I can already do something by converting my data to someserialisation format, but asking for the data to be instances of Store is too much...
12:19:55 <EvanR> KunoMark: this kind of thing requires step 0 to be "what sort of guarantees do i want the final thing to provide"
12:19:57 <KunoMark> Yeah. LRUCaching needs Hashable data. I'm trying to put a generic layer on top of it somehow, if that makes any sense EvanR...
12:20:58 <KunoMark> Guarantees? Well, the consumer will ask for a value giving a key, but the TYPE EXPECTED BY THE CONSUMER will be the type of the key returned. Normal Existentials stuff, I believe.
12:21:25 <EvanR> you can parameterize the value type in the key type
12:21:34 <sproingie> for caching arbitrary stuff locally, there's memoization
12:21:45 <EvanR> that will help make your API make sense
12:21:55 <KunoMark> I wanna use an LRU, sproingie
12:21:55 <sproingie> if it's serving some other process, i'd say just serialize all the things
12:22:27 <EvanR> for example https://hackage.haskell.org/package/vault-0.3.0.7/docs/Data-Vault-Lazy.html but this is a uniform key type, not an arbitrary key type
12:22:43 <monochrom> Hashing does not spare you from needing to know the type. You will have to perform ==, which requires types.
12:22:44 <EvanR> so falls short of your vague requirement that you dont know what the type of keys are
12:22:47 <KunoMark> Serialisation is too much, as I ave little control over some of the types. In particular, I can't seem to serialise Persistent's Key * type family...
12:23:01 <paolino> you hade Dynamic also
12:23:05 <fXl> hello guys, i am trying to read yaml file but gettin error like  "Non-exashutive ..." the list returns empty, can anybody help? here what i did. https://hastebin.com/ukayuwusuf.hs
12:24:00 <KunoMark> I'm taking a look at Vault, EvanR.
12:24:05 <sproingie> not sure why one cache would have wildly disparate types.  imagine an uncached version, you wouldn't have a single function return a type like that, would you?
12:24:17 <sproingie> if you need to cache different things, you probably need different caches
12:24:30 <EvanR> that would be easier to pull off yes
12:24:42 <EvanR> but it sounds like theres some legacy systems that need integration
12:24:57 <KunoMark> paolino Dynamic requires a Typeable instance. I literally can't seem to add any instances to my key types.
12:25:12 <EvanR> Typeable is automatically derived, or not possible
12:25:17 <KunoMark> But let me think over it a little mor, and maybe provide a better way to explain it...
12:26:38 <sproingie> stupid question, but how performant is Dynamic, if say, i wanted to write a slapdash little EDSL with it?
12:26:40 <monochrom> Turn on DeriveDataTypeable and write "data MyType = .... deriving Typeable"
12:27:32 <EvanR> sproingie: i havent seen Dynamic used for that purpose
12:27:45 <monochrom> Dynamic is a record of two fields, one for type and one for value.
12:27:46 <EvanR> wouldnt you want an EDSL to be well typed
12:28:23 <sproingie> let's say i wanted to demonstrate how haskell is the best duck-typed imperative language :)
12:28:36 <EvanR> i suspect youll fail miserably at that
12:28:48 <monochrom> I think it really is the most compact representation possible.
12:29:41 <sproingie> i guess it all depends on how many typechecks and casts i do
12:30:08 <EvanR> you cant cast, but with Dynamic you can check that a thing is the type you are expecting
12:30:11 <XorSwap> hey, so is there still an obfuscated haskell contest kicking around?
12:30:15 <monochrom> When it comes to duck typing, there are two opposite opinions on "best".
12:30:47 <EvanR> which is constantly happening (in more complex form) in other languages
12:31:52 <EvanR> sproingie: with ghc defer type errors, you get all the performance with none of the pesky type safety
12:32:05 <EvanR> might be a better angle for bragging
12:32:38 <paolino> defer type errors is producing executables ?
12:32:55 <sproingie> and if i was doing an actual scripting runtime ... well, i guess i'd be storing something like (tag,val) anyway
12:32:57 <EvanR> yeah
12:33:16 <EvanR> sproingie: with defer type errors, you dont even need to do that! :P
12:33:26 <monochrom> hugs defers type errors to interpret time. you get your freedom and also no more dependency hell. :)
12:33:41 <EvanR> more seriously, if you were doing a "dnyamic" DSL you d write your own sum type for that (tag, val) object
12:33:48 <sproingie> waaaay back i remember hugs having better error messages
12:34:11 <Cale> XorSwap: There was a long while ago, with some pretty nice entries
12:34:12 <EvanR> with the 7 magic primitive types everyone wants
12:34:18 <Cale> XorSwap: the IOHCC
12:34:30 <XorSwap> it's not on anymore?
12:35:01 <Cale> I think it only ran a couple times
12:35:02 <perebor> has anyone installed hmatrix on nixos with stack? I'm having trouble with the gfortran .so dependency
12:35:22 <sproingie> seven, eh?  bool, num, string, function, list, map ... what am i missing?
12:35:31 <EvanR> null of course
12:35:42 <EvanR> or nil
12:35:49 <sproingie> eh, every type can contain null, whaddya need another type for?
12:35:53 <sproingie> that's what everyone seems to want
12:36:06 <EvanR> i think weve lost contact with the subject
12:36:41 <fXl> hello guys, i am trying to read yaml file but gettin error like  "Non-exashutive ..." the list returns empty, can anybody help? here what i did. https://hastebin.com/ukayuwusuf.hs :D
12:36:41 <EvanR> Nil | MyBool Bool | MyString String | MyInt Integer | ...
12:36:48 <EvanR> without Nil ... you cant do nil
12:36:57 <sproingie> there's void, but you make that magical, not a real type.  (note: talking about how to design a crap language here)
12:37:06 <EvanR> me too
12:37:12 <EvanR> nil is not a bool
12:37:35 <monochrom> fXl: I can't see why it has that error. Perhaps your yaml file is bad?
12:37:44 <lpaste> K pasted “No title” at http://lpaste.net/354824
12:37:55 <sproingie> i think perl just has an "undef" bit in every SV
12:38:04 <EvanR> undefined could be yet another thing
12:38:14 <fXl> monochrom: what do you mean by yaml file is bad ?
12:38:16 <paolino> fXl can you paste the error ?
12:38:22 <fXl> okey
12:38:27 <EvanR> i have a FHIR standard here for like 39 different kinds of null, all different
12:38:33 <sproingie> but then again, perl SV's represent a lot of types under the covers
12:38:50 <EvanR> http://www.hl7.org/fhir/v3/NullFlavor/cs.html
12:38:53 <monochrom> That beats the IEEE 9-value logic I read about.
12:39:13 <sproingie> True, False, FileNotFound, Chocolate, Vanilla ...
12:39:17 <EvanR> hmm seems less than i remember
12:39:19 <monochrom> By a multiple of 4, no less.
12:39:44 <KunoMark> EvanR and sprongie, please consider the following, if you will: 
12:39:53 <EvanR> sproingie: so in retrospect, youd save that one bit of space by just rolling null into the tag, and thus null is born
12:40:15 <sproingie> i ought to get around to writing this language.  i think i'll call it Crap
12:40:18 <KunoMark> That's as far as I can get. But I wanna get rid of the Store dependency. I'm just using it to store everything as ByteStrings...
12:42:27 <sproingie> it'll be like python's wildly popular "flask" framework. it grew out of an april fools joke to make a web framework entirely out of antipatterns
12:43:58 <fXl> monochrom, paolino, https://hastebin.com/etemihefed.js
12:44:55 <monochrom> OK so it is not "Non-exashutive"
12:45:20 <fXl> https://hastebin.com/inefepobol.hs
12:45:29 <fXl> because, i did error "Error"
12:45:37 <fXl> :D
12:46:01 <monochrom> You need to be more self-consistent.
12:46:15 <EvanR> hmm
12:46:32 <fXl> monochrom, i added the other things to be precise for you
12:46:53 <fXl> *** Exception: Pe.hs:(20,10)-(21,26): Non-exhaustive patterns in function parseJSON
12:47:02 <monochrom> I don't actually know the YAML format, but this error is saying the program cannot find an object where it expects one.
12:47:24 <paolino> which is the all file content
12:47:46 <paolino> but it looks like it parsed it
12:47:48 <fXl> you mean, it cant read the file ?
12:48:03 <fXl> when i do Y.Value, it parses and shows values
12:48:17 <fXl> instead of IO (Maybe Point)
12:48:22 <monochrom> Not all values are objects.
12:48:28 <paolino> try to match the sibilings constructors of Object
12:48:29 <KunoMark> You know what? I think I'll just do a bunch of unsafePerformIO and be done with it. :-D Now to find all those references about how unsafePerformIO can be used to do unsafe coersions..
12:48:50 <monochrom> I don't know YAML but I actually know enough JSON to say this.
12:49:10 <EvanR> KunoMark: what on earth
12:50:17 <Cale> KunoMark: Looking back at the past conversation: are you aware of DMap?
12:50:24 <ADG> can anybody tell about what is probably the best setup for haskell on linux? atom? eclipse? vim(I hate vim/emacs)?
12:50:37 <Cale> (it's not quite what you're asking for, but depending on the reason you're asking, it might be what you want)
12:50:56 <dmj`> ADG: emacs / vim
12:50:59 <Cale> ADG: It doesn't really matter what editor you use
12:51:20 <Cale> Just don't worry about it. As long as it has the option to convert tabs to spaces.
12:51:27 <ADG> i like autocomplete, on-the-fly lint checking & stuff
12:51:31 <fXl> paolino, sibling cunstructors ?
12:51:56 <paolino> fXl , where is Object defined ?
12:52:28 <fXl> when using Y.Value, returns this Just (Array [Object (fromList [("point",String "/home/user/file"),("point2",String "/home/user/file2")])])
12:52:36 <KunoMark> That might just be it, Cale. I'll see if I can make it work, and hopefully even add LRU functionaility to it. :-)
12:52:48 <fXl> i think i should do pattern matchin "D
12:53:04 <fXl> or i dont know
12:53:05 <paolino> so it's an Array
12:53:14 <monochrom> There, it's an array not an object.
12:53:50 <fXl> parseJSON Array then ?
12:56:28 <fXl> Array returned this, Just [Object (fromList [("point",String "/home/user/file"),("point2",String "/home/user/file2")])]
12:56:33 <sproingie> intellij idea has a haskell plugin that might be ok.  it's stack enabled, so it's at least that much maintained.
12:56:46 <monochrom> Is it even legit YAML to have a top-level array?
12:56:50 <sproingie> oh he's gone.  silly me.
12:58:07 <fXl> monochrom, i found this https://stackoverflow.com/questions/13059806/reading-yaml-in-haskell, the last answered guy says i did it 3 liner but his code is too complicated for me :D https://github.com/jwiegley/pushme/blob/master/Main.hs
12:58:53 <johnw> 1. you need to define FromJSON instances for your types (which can be generated automatically for many types)
12:58:59 <fragamus> OK, I am trying to use Pipes and Turtle together
12:59:03 <johnw> 2. maybeObj <- Data.Yaml.decode <$> B.readFile (encodeString p)
12:59:09 <fragamus> i have this:    scrounge :: MonadIO m => Filesystem.Path.CurrentOS.FilePath -> Pipe a a m ()
12:59:25 <roger__> Anyone know of a way to represent an AST with associative operators (say + and *) without allowing a ton of redundant representations of the same expression?
12:59:28 <monochrom> johnw, I think 1 is done. What is p in 2?
12:59:33 <fragamus> i want something like this:    scrounge :: Shell m => Filesystem.Path.CurrentOS.FilePath -> Pipe a a m ()
12:59:37 <johnw> sorry, p should just be the name of the file
12:59:40 <johnw> ignore the encodeString
12:59:50 <monochrom> 2 is also done
12:59:58 <monochrom> Therefore I blame the input file.
12:59:59 <johnw> ok, we're good then
13:00:25 <fragamus> but I get errors and I am blocked
13:00:37 <fXl> i can read file i guess but it doesnt seem to work like the way on github there
13:01:24 <monochrom> johnw: Actually the actual code is Y.decodeFile "points.yml" :: IO (Maybe Pointer). Does it make a difference?
13:01:37 <monochrom> Y = Data.Yaml
13:01:55 <johnw> I don't think it does
13:02:52 <monochrom> The FromJSON instance assumes Object (rightfully, I would think). parseJSON (Object e) = Pointer <$> e .: "point"
13:03:07 <fragamus> it says Shell has kind *
13:03:15 <monochrom> ("Pointer" is a data constructor and has one field of type [String])
13:03:50 <johnw> I really just use TH to generate the parser
13:03:58 <johnw> deriveJSON ''Pointer
13:06:11 <fragamus> Expected a constraint, but Shell m has kind *
13:06:46 <fXl> johnw, whats the wrong thing in my code there ?
13:07:11 <johnw> can you link me to code that I can paste and try here?
13:08:04 <fXl> okey
13:08:08 <monochrom> This is really down the road of more recipes, less scientific method, and hell. There is evidence that the input file reads like [point: "xxx", point2: "yyy"] and nothing says why the program code should have any relation with the input file at all.
13:08:30 <fragamus> : |
13:08:50 <monochrom> We are basically looking for more and more automagical way to write code without even asking "do you actually know your file format?"
13:08:50 <paolino> fragamus: where is Shell defined ?
13:09:02 <geekosaur> fragamus, looks to me like it's telling you Shell is a type, not a typeclass
13:09:14 <geekosaur> also it reports Shell m is kind *, not Shell is kind *
13:09:14 <fXl> johnw, https://hastebin.com/ferorumuro.hs 
13:09:57 <geekosaur> that said, ... I am afraid to ask if this relates to the Type <=> Constraint silliness
13:10:31 <geekosaur> but I will echo paolino's question: where is Shell defined?
13:10:33 <johnw> what a badly behaved website is hastebin.com
13:10:39 <fXl> monochrom, :D
13:10:44 <fXl> haha kinda yes
13:10:54 <jle`> fragamus: do you know the difference between a typeclass and a type?
13:11:16 <fragamus> i dont now
13:11:20 <fXl> i am used to it, why using sorry jonhw :D
13:11:20 <Cale> geekosaur: Maybe in turtle? https://hackage.haskell.org/package/turtle-1.3.2/docs/Turtle-Shell.html
13:11:43 <jle`> fragamus: a typeclass is sort of like an 'interface', which many types may implement
13:11:44 <geekosaur> Cale, this relates to fragamus's question
13:11:51 <jle`> fragamus: so something like sort :: Ord a => [a] -> [a]
13:12:05 <jle`> fragamus: means that sort works for any type, as long as that type implements the Ord typeclass
13:12:27 <Cale> Oh, a Shell type class?
13:12:33 <Cale> I have no idea.
13:12:41 <fragamus> right i remember
13:12:55 <jle`> fragamus: if i wanted to have a function that takes an int and returns an int
13:13:03 <fragamus> yeah 
13:13:03 <jle`> i'd write foo :: Int -> Int
13:13:07 <jle`> i wouldn't write foo :: Int a => a -> a
13:13:11 <jle`> because Int isn't a typeclass
13:13:13 <geekosaur> well, we don;t know yet, fragamus should be telling us instead of making us guess
13:13:31 <fragamus> ok i will tell you
13:13:36 <geekosaur> oh, guess they mentioned turtle earlier
13:13:57 <geekosaur> which means it's a type, not a typeclass
13:14:02 <jle`> fragamus: so the error is saying that (Shell m) is not a typeclass constraint, but actually a type
13:14:03 <Cale> yeah
13:14:12 <geekosaur> and indeed should not be where you used it
13:14:16 <jle`> ie, it's like you're trying to do Int a => a -> a
13:14:21 <jle`> instead of just Int -> Int
13:14:30 <geekosaur> ghc used to let you do that :)
13:15:04 <jle`> or Maybe a => a -> a, instead of (Maybe a -> Maybe a)
13:15:28 <fragamus> Shell is defined here: https://hackage.haskell.org/package/turtle-1.3.2/docs/src/Turtle-Shell.html#Shell
13:15:35 <fragamus> it is indeed a type
13:15:49 <jle`> mhm, and not a typeclass constraint
13:16:00 <jle`> have you tried maybe FilePath -> Pipe a a Shell () ?
13:16:29 <jle`> not sure if the 'a' and 'a' are correct
13:16:30 <fragamus> il'll try that
13:16:54 <jle`> it's kind of like converting the silly `Maybe a => a` into `Maybe a`
13:17:08 <jle`> since Maybe isn't a typeclass
13:17:21 <fragamus> that worked
13:17:25 <fragamus> thanks all
13:17:27 <jle`> hooray!
13:17:46 <fragamus> you guys saved my weekend no kidding
13:17:50 <butterthebuddha> Hey peeps, I'm writing a function that takes a string as input. I wanna pattern match something like 'SINGLE_CHAR_HERE':' ':"String":' ':"String":' ':"String"
13:18:04 <butterthebuddha> I know how to match single characters, but I'm not sure how take extract the strings
13:18:08 <jle`> butterthebuddha: you should already be able to pattern match on that
13:18:25 <jle`> oh
13:18:32 <jle`> you don't mean to actually pattern match literally on the string "String"
13:18:40 <butterthebuddha> No
13:18:46 <jle`> what is an example of a string you want to see
13:18:52 <jle`> and what it would match on?
13:18:59 <butterthebuddha> 'E':' ':x:' ':y:' ':s
13:19:13 <butterthebuddha> ^ that's what I'm doing; x, y and s must be strings
13:19:20 <butterthebuddha> Example string: "E 2 148 #56k istereadeat lo d200ff] BOOTMEM"
13:19:21 <jle`> can x y and s contain spaces?
13:19:26 <butterthebuddha> Nope
13:19:29 <jle`> what would that match as
13:19:38 <fXl> johnw, is there any progress ? 
13:19:47 <johnw> no, I still haven't seen the code
13:19:47 <jle`> 'E', '2', '148', and '#56k istereadeat lo d..." ?
13:19:52 <butterthebuddha> Yep
13:20:17 <paolino> butterthebuddha, x y tare Char there
13:20:20 <butterthebuddha> From the match I posted above, I know that s is a string but x and y are Chars
13:20:32 <fXl> johnw, i can paste somewhere else if you want. 
13:20:34 <jle`> > case "E 2 148 #56k istereadeat lo d200ff] BOOTMEM" of x:xs -> (x, words xs)
13:20:36 <lambdabot>  ('E',["2","148","#56k","istereadeat","lo","d200ff]","BOOTMEM"])
13:20:40 <johnw> lpaste is fine, or gist, or anywhere else really
13:20:53 <MarcelineVQ> mmm, that's week2 of cis194 sping13
13:20:56 <johnw> the fact that even turning off all protections doesn't make hpaste work is troubling
13:21:07 <johnw> or hastebin, rather
13:21:11 <butterthebuddha> Can I do a case inside a function?
13:21:22 <jle`> you can but i'm just showing the pattern match
13:21:26 <jle`> the pattern match is the important part
13:21:33 <jle`> you can pattern match on (x:xs), and then use 'words xs'
13:21:47 <jle`> `x:xs` gives x as the first Char
13:21:54 <jle`> and words splits the remaining string on spaces
13:22:12 <fXl> johnw, http://lpaste.net/354826
13:22:18 <jle`> > let e:es = "E 2 148 #56k istereadeat lo d200ff] BOOTMEM"; x:y:s = words es in (e,x,y)
13:22:20 <lambdabot>  ('E',"2","148")
13:22:26 <jle`> > let e:es = "E 2 148 #56k istereadeat lo d200ff] BOOTMEM"; x:y:s = words es in (e,x,y,s)
13:22:28 <lambdabot>  ('E',"2","148",["#56k","istereadeat","lo","d200ff]","BOOTMEM"])
13:22:33 <jle`> hm, sorry
13:22:37 <jle`> > let e:es = "E 2 148 #56k istereadeat lo d200ff] BOOTMEM"; x:y:s = words es in (e,x,y,unwords s)
13:22:39 <lambdabot>  ('E',"2","148","#56k istereadeat lo d200ff] BOOTMEM")
13:22:44 <fXl> > print "lambda"
13:22:44 <EvanR> hax
13:22:46 <lambdabot>  <IO ()>
13:22:50 <johnw> ah, there we go
13:22:56 <fXl> :D
13:22:56 <jle`> be aware that this compresses spaces in the "leftovers"
13:23:22 <fXl> hmm
13:24:32 <EvanR> heh, doing putStrLn from two threads is literally "randomly interleaving" the characters
13:24:46 <EvanR> for short strings
13:24:48 <geekosaur> yep
13:24:51 <EvanR> i am impressed
13:25:08 <butterthebuddha> jle` So I'm trying to do this: "x:(words xs)"
13:25:11 <butterthebuddha> And that isn't working :/
13:25:14 <jle`> that's not how pattern matches work
13:25:25 <jle`> did you see what i wrote earlier?
13:25:34 <butterthebuddha> Yea I'm trying to parse that
13:25:40 <jle`> so do x:xs
13:25:51 <jle`> to get 'E':"2 128 ..."
13:25:54 <jle`> and then use 'words' on xs
13:26:07 <jle`> in like a 'where' clause or something maybe?
13:26:37 <johnw> fXl: your data types do not correspond to your data
13:26:47 <johnw> your data is a list of objects with two fields, point and point2
13:26:55 <johnw> your program is trying to read in a single object with only one field, point
13:27:02 <johnw> https://gist.github.com/d07bd481f6d527df4c9bdbe58302d4fa
13:27:08 <johnw> change that accordingly, and you'll be fine
13:27:42 <fXl> woaw, are you the guy of that answer :D
13:27:51 <jle`> butterthebuddha: if you match on x:xs, then x will be 'E' and xs will be "2 148 ..." etc.
13:28:11 <jle`> butterthebuddha: then you can use the 'words' function on xs to get ["2", "148", "#56k", "istrereadeat", ...]
13:28:21 <jle`> are you familiar with using functions?
13:28:25 <butterthebuddha> Yeeaa
13:28:41 <butterthebuddha> But I'm not sure how to assign the words function call to a variable
13:28:47 <jle`> you can name it
13:28:47 <butterthebuddha> without using something like a do
13:28:48 <johnw> fXl: I have to run now, good luck!
13:28:49 <jle`> using let, or where
13:29:02 <jle`> look up 'where' clauses, maybe? or 'let ... in ...'
13:29:18 <johnw> is the webpage linked here broken for anyone else: https://www.reddit.com/r/haskell/comments/66xqro/putting_lenses_to_work_talk_and_slides/
13:29:20 <fXl> johnw, thank you so much for your time, appreciated sir
13:29:26 <johnw> I've been having a heck of a time with DNS
13:29:30 <jle`> butterthebuddha: where clauses should hopefully be one of the first things covered in any haskell course :)
13:30:19 <fXl> johnw, it works for me
13:30:30 <johnw> fXl: thanks! it might be a localized issue then
13:30:31 <jle`> butterthebuddha: see http://learnyouahaskell.com/syntax-in-functions for a quick reference if you're unfamiliar
13:30:40 <geekosaur> johnw, works for me
13:30:42 <johnw> Gurkenglas_ was having the problem
13:30:42 <fXl> https://github.com/jwiegley/putting-lenses-to-work
13:31:21 <Gurkenglas_> johnw, works now, didn't work then
13:31:27 <johnw> ok
13:31:35 <EvanR> in ghci i can reload and loose my variables, but forkIO threads are still running
13:31:36 <johnw> maybe you hit it right when I was refreshing to fix a spelling error or something
13:31:40 <butterthebuddha> jle` Yea I was going through this course (https://www.seas.upenn.edu/~cis194/spring13) and they don't seem to cover it; at least not in the first two lectures
13:32:16 <jle`> ah
13:32:23 <jle`> that's a bit odd
13:32:30 <fXl> johnw, i just want to ask this if you have time, is this better way then saying instance FromJSON etc.. ?
13:32:56 <fXl> or you just made it worked :D
13:32:57 <jle`> 'let .. in ..' is one of the most fundamental parts of haskell, kind of weird that they'd skip thorugh it
13:33:05 <Gurkenglas> johnw, (?~ mx) makes it look like mx has type (Maybe _)
13:33:46 <jle`> i am perplexed :)
13:36:36 <Gurkenglas> johnw, 'prisms address some part of a "structure" that may exist' <- they adress the whole of the structure, not a part of it - prisms say that a structure might have some form. lenses do the part part
13:37:46 <fXl> johnw, your code didnt work for me, returns Nothing
13:38:02 <MarcelineVQ> jle` butterthebuddha: I'm surprised it's not covered in the lectures directly as well, however it is covered in the suggested reading at the top of the lectures one should be reading
13:38:33 <butterthebuddha> Ah, right
13:39:01 <tomskel> MarcelineVQ: sorry got dragged away. Yeah I don't think ghc-mod can cope with GHC's weird directory layout, there doesn't seem to be any option you can pass it that allows it to use a different cwd. From what I can tell it tries to infer the cwd itself, and the for the GHC codebase it infers wrong.
13:42:21 <MarcelineVQ> someone in ghc might have a workflow that you could adopt, due to the version shenanigans that happen with these sorts of things ghc-mod will be fairly brittle even if you do find a way to get it going
13:43:44 <tomskel> Cool, thanks for your help :-)
13:43:56 <MarcelineVQ> *someone in #ghc
13:50:04 <monochrom> ghc-mod on GHC itself is funnily self-referential, because ghc-mod uses the GHC API.
13:50:46 <mpickering> I doubt that you can use ghc-mod with #ghc
13:51:31 <mpickering> Is there a way to get happy parsers to tell you which tokens they were expecting to find rather than which token they unexpectedly found (on a parse error)
13:51:43 <monochrom> Oh, yeah, there can be a way GHC source code can confuse GHC API.
13:56:54 <perebor> has anyone installed hmatrix with stack?
13:57:31 <johnw> Gurkenglas: good point
13:58:11 <johnw> fXl: that's because of what I said above: your data is a list of objects with two fields, point and point2, and your program is trying to read in a single object with only one field, point
13:59:08 <fXl> johnw, okey i fixed it, what if i want to read dictionary then ?
14:01:06 <lyxia> perebor: I have
14:01:30 <lyxia> perebor: it's more efficient for you to just ask your question BTW
14:02:34 <phale> should i always explicitly set type for functions ?
14:03:15 <mpickering> yes you should always write type signatures for top level definitions
14:03:38 <phale> alright
14:03:51 <phale> im also failing to undestand what are Just ? wha does this mean
14:03:54 <phale> Just and Maybe
14:04:17 <EvanR> data Maybe a = Nothing | Just a
14:04:27 <phale> yes but whats the purpose of it ?
14:04:33 <EvanR> Maybe is a type, Just is one of its two constructors
14:04:45 <m0cesta> Just somevalue
14:04:49 <EvanR> it takes the place of "null" from other languages
14:04:51 <m0cesta> or Nothing
14:04:52 <fXl> there are lots of lots of concepts in Haskell and lots of them are hard to understand :D
14:05:04 <m0cesta> The idea is very simple
14:05:15 <EvanR> you wont find variables randomly holding the value "null" in haskell, but you can get the same result using a Maybe 
14:05:51 <EvanR> its actually more useful than null, because you can tell the difference between Nothing, Just Nothing, and Just (Just something)
14:06:22 <dolio> And once you check you get a value that tells you you never need to check again.
14:06:35 <EvanR> when youre using null for two different purposes, that often explodes in your face in other languages
14:07:41 <rotaerk> phale, what languages do you know?
14:08:45 <rotaerk> (if any)
14:11:12 <perebor> lyxia: I'm getting either totally inscrutable errors or segfaults if I link hmatrix with openblas. do you know if openblas is supported? or should I stick to trying to install with blas
14:14:22 <phale> rotaerk, programming languages?
14:14:32 <rotaerk> yea
14:14:34 <phale> C
14:15:00 <fXl> segmentation fault then :D
14:15:40 <rotaerk> hmm C has null but I'm not sure if it makes a good analogy
14:16:14 <rotaerk> since it's really just (T*)0
14:17:12 <rotaerk> phale, is there still any confusion regarding what Maybe and Just do?
14:18:55 <phale> so it basically tests if something is null?
14:19:37 <Cale> Nah, it's used in place of the cases where you might allow for something to possibly be null and test for that condition
14:20:17 <Cale> Or for example, in C sometimes people writing a function which produces an int that would normally be positive, might use -1 in the case that the function failed.
14:20:25 <|DM|> how would I repeatedly call a function that has no arguments in haskell ?
14:20:33 <|DM|> Map expects input, so does iterate. Im lost
14:20:33 <Cale> We would never do that in Haskell, such a function would instead produce a Maybe Int
14:20:49 <Cale> and give Nothing in the "failure" case
14:20:56 <Cale> and Just n in the case that it was successful
14:21:15 <Cale> |DM|: A function with no arguments is not a function.
14:21:36 <Cale> |DM|: What are you trying to accomplish?
14:21:53 <Cale> (every function in Haskell really has exactly one parameter)
14:22:07 <rotaerk> phale, the purpose of Maybe is to represent optionality or unreliability of a value
14:22:07 <|DM|> I want to repeatedly print hello world
14:22:18 <|DM|> I made a function that prints hello world, and takes no arguments
14:22:18 <Cale> main = do
14:22:25 <Cale>   putStrLn "Hello World!"
14:22:27 <Cale>   main
14:22:29 <|DM|> Oh, I see. If it has do its not a function ?
14:22:36 <|DM|> That loops forever.
14:22:37 <Cale> main isn't a function
14:22:39 <Cale> It's an IO action
14:22:46 <Cale> main :: IO ()
14:22:49 <rotaerk> phale, for instance if you had a simple int-parsing function, your first attempt may have a signature like:  String -> Int
14:23:03 <rotaerk> but if the string is "aoeu" what do you do in that case?
14:23:06 <tsani> |DM|: main is a value :)
14:23:15 <|DM|> Yes, but my hello world "function was foo = prtStrLn "Hello" , so I guess its not actually a function ?
14:23:23 <tsani> foo :: IO ()
14:23:24 <Cale> |DM|: You can also write  main = forever (putStrLn "Hello!")
14:23:26 <tsani> foo is also a value.
14:23:42 <rotaerk> phale, the fact that it can't *always* return an integer means you might want to use this signature instead:  String -> Maybe Int
14:23:43 <Cale> |DM|: Right, it's type is not of the form A -> B for some types A and B
14:23:46 <Cale> its*
14:24:01 <rotaerk> phale, and if the input string is not actually an integer, return Nothing
14:24:18 <|DM|> Oh I see now. Though im confused how IO actions are values
14:24:22 <rotaerk> you can also take Maybe as an *input* to your function if the value is optional
14:24:24 <glguy> |DM|  Suppose you had: sayHi = putStrLn "Hello,world". 'sayHi' is an action that when executed prints hello world to the screen once. Now that we have that we can make more actions like: sayHiTwice = sayHi >> sayHi
14:24:38 <|DM|> I guess the haskelly way to limit the iterations is like scheme, recursive function with a stop condition ?
14:24:44 <Cale> Well, they can be passed around like anything else, put in data structures, and manipulated in all the usual way values can
14:24:47 <fragamus> hi Im using pipes and I have a pipe that calls take such that I limit the number of items provided downstream.   DOES MY UPSTREAM producer run to completion producing stuff that gets ignored?
14:24:54 <Cale> Functions are also values, so it's not saying all that much.
14:25:14 <Cale> |DM|: You can also use mapM, replicateM
14:25:25 <Cale> replicateM 10 (putStrLn "Hello!")
14:25:33 <Cale> mapM print [1..10]
14:25:43 <Cale> forM [1..10] $ \n ->
14:25:43 <rotaerk> |DM|, think of an IO value as just being an immutable set of instructions, a plan or description for an IO action
14:25:48 <Cale>   print n
14:25:55 <|DM|> I see.
14:25:59 <lyxia> perebor: is it related to https://github.com/albertoruiz/hmatrix/issues/211
14:26:02 <glguy> An interesting aspect of Cale's example is that you can write: replicateM 0 (putStrLn "Hello"), and no printing happens
14:26:21 <glguy> applying putStrLn to "Hello" isn't what actuall prints, it's just building an action that could print if executed
14:26:41 <Cale> |DM|: because IO actions are values which merely describe things to be done, we can write functions which take them as arguments and do things with them before they get executed
14:26:59 <Cale> |DM|: For example, let's write the function replicateM which repeats something a given number of times
14:27:15 <Cale> (and collects the results in a list)
14:27:24 <fragamus> because if it does i want to cry
14:28:34 <Cale> replicateM n x | n <= 0 = return [] -- if the number of times to run x is not positive, just produce the action which does nothing except to result in an empty list when executed
14:28:48 <Cale> (return v is a no-op which produces v as its result)
14:29:08 <Cale> replicateM n x = do -- otherwise...
14:29:18 <Cale>   v <- x -- first run x, getting some result v
14:29:32 <perebor> lyxia: omg I'm been through all sorts of other issues all morning with openblas segfaults that have been resolved, and the documentation I've found has used the openblas flag. thank you so much for finding that
14:29:37 <Cale>   vs <- replicateM (n-1) x -- then run x again (n-1) more times, getting a list vs
14:29:57 <rotaerk> |DM|, the reason anything gets executed is because GHC expects you to produce an IO value (a plan of action) and call it main... it then compiles a program that executes this plan
14:29:58 <Cale>   return (v:vs) -- and return (v:vs) as the result
14:30:42 <|DM|> I see. Man this clears up haskell a lot
14:30:44 <Cale> |DM|: A more fundamentally useful function, similar to this, is sequence
14:30:52 <Cale> sequence :: [IO a] -> IO [a]
14:30:52 <|DM|> If I understand this right, replicateM isnt a function either in this case
14:31:05 <rotaerk> it is a function because it takes arguments
14:31:06 <Cale> replicateM actually does count as a function, because it takes an Int
14:31:07 <EvanR> functions have type A -> B
14:31:07 <|DM|> Though the various pieces under guards ARE ?
14:31:12 <EvanR> :t replicateM
14:31:13 <lambdabot> Applicative m => Int -> m a -> m [a]
14:31:22 <EvanR> Int -> (m a -> m [a])
14:31:37 <Cale> that's a type for a more general version than I implemented
14:31:41 <Cale> but still :)
14:31:54 <Cale> I was just hoping for  Int -> IO a -> IO [a]
14:31:56 <EvanR> Int -> (IO a -> IO [a])
14:32:05 <EvanR> thus its a function
14:32:24 <|DM|> So guards dont count as parameters at all?
14:32:39 <Cale> guards don't... the actual parameters do...
14:32:45 <|DM|> alright
14:32:51 <Cale> In this case, n and x are parameters to the function
14:33:14 <EvanR> convince yourself guards would not make sense as arguments
14:33:17 <Cale> Actually, let's do sequence as well
14:33:25 <Cale> sequence :: [IO a] -> IO [a]
14:33:46 <rotaerk> |DM|, in C and many other procedural languages, a "function" is a packet of steps to execute.  thus no-parameter "functions" make sense.  in haskell this is the role of an IO action.  in C, this procedure itself takes parameters.  in haskell, you just make a function that takes parameters and produces a different IO action based on them.  (the IO itself doesn't take args)
14:33:48 <Cale> It's a function which takes a list of IO actions, and turns them into a single action, whose result will be a list of their results
14:34:24 <Cale> sequence [] = return [] -- here, if the list is empty, we produce an action which does nothing except to result in an empty list
14:34:46 <rotaerk> so "function" doesn't correspond to functionality in haskell like it does in other languages... it just means parameterization
14:34:56 <Cale> sequence (x:xs) = do v <- x; ... -- if the list is nonempty, we first run the first action in it...
14:34:57 <rotaerk> any functionality would be encoded in the result of the function
14:35:20 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- then we run all the others (recursively) getting a list of their results
14:35:32 <EvanR> function corresponds to a mathematical function
14:35:43 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and produce a complete list of the results
14:36:06 <Cale> Make sense?
14:36:40 <|DM|> I think so
14:36:46 <Cale> So this sequence function is basically a primordial sort of loop: if we can decide ahead of times what each iteration of our loop will do, and construct a list of the actions, then it will stitch them all together
14:36:59 <Cale> Using it, we can rewrite replicateM more simply:
14:37:08 <Cale> replicateM n x = sequence (replicate n x)
14:37:20 <Cale> Here, replicate is just the function which produces a list of n copies of x
14:37:58 <Cale> mapM f xs = sequence (map f xs)
14:38:39 <Cale> This is like a for-each loop. Given a function which says what to do, given an element, and a list of elements, it will iterate over the list and perform all the actions
14:39:14 <|DM|> Im familiar with map yeah
14:39:17 <Cale> There's also forM which is mapM with the arguments in the opposite order for convenience (since usually the function is the longer bit and might span several lines)
14:40:17 <Cale> But yeah, you can also just write recursive things. Usually if the termination condition is anything more subtle than what's covered here, you'll see people go for direct recursion.
14:40:53 <|DM|> Alright
14:40:57 <|DM|> Thanks for the great intro.
14:46:04 <EvanR> i am kind of amazed that after install sdl2, i can ghc Main and get an executable without anything special
14:46:16 <EvanR> no linker shenanigans, telling it where sdl2 includes are
14:46:47 <EvanR> etc
14:54:54 <phale> what is a good haskell book with exercises ?
14:56:19 <tommd> I'm trying to remember if the "Craft of functional Programming" has exercises.
14:56:53 <phale> imo exercises seem to be better to learn from
14:57:14 <phale> im reading LYAH though, just wondering if there were any with exrcises
14:57:22 <tommd> Yes, it does.
14:57:35 <phale> is it a good read ?
14:57:52 <tommd> I read it back around 2007, but as I recall, yes.
14:58:03 <Cale> phale: There's http://www.cis.upenn.edu/~cis194/spring13/lectures.html
14:59:17 <phale> ok ill chek it out tommd, oh sweet Cale i was reading this earlier, looks like i overlooked the homework heh
15:08:54 <sproingie> EvanR: i found i had to help sdl2-ttf to build, but yeah sdl2 was pleasant
15:13:54 <ania123> I am interested whether following is true: If f(a,b) R f(c,d) then a R c and b R d  where R is a congurence relation. 
15:17:14 <erisco> can Mealy machines halt?
15:17:41 <EvanR> you can designate a particular state as the halt state
15:17:44 <EvanR> with no way out
15:18:30 <erisco> a partial transition function?
15:19:29 <EvanR> all roads lead back here
15:19:47 <EvanR> you could call it the STUCK state
15:19:53 <erisco> the translation is  Mealy :: a -> (b, Mealy a b)  but I am thinking  Machine :: a -> Maybe (b, Mealy a b)
15:20:20 <EvanR> youd have no idea what its final state was
15:20:53 <EvanR> if you want to detect if it is in the stuck state, you can provide a Mealy a b -> Bool
15:21:38 <EvanR> im using something like this right now with my HTTP server in C
15:21:59 <EvanR> theres a stuck state which is after it finishes outputting the response
15:22:06 <erisco> I was thinking  Machine :: a -> Maybe (a, Machine a)
15:22:23 <erisco> think this is more like a Moore machine, or something
15:22:35 <EvanR> since you get outputs upon transitions, you just made it impossible to output something right before halting
15:23:08 <EvanR> and you made the final state undefined
15:23:34 <erisco> maybe it doesn't make sense in context of "machines", alright
15:23:36 <EvanR> mealy and moore are almos the same thing, just one gets input
15:25:25 <erisco> yes, I am just thinking of something which goes through states
15:25:49 <erisco> but my context isn't machines... I thought it looked similar though
15:26:09 <EvanR> if you were to build a state machine out of metal, then it can always accept another input or time step. it doesnt go poof when you would halt
15:26:26 <EvanR> but you definitely use certain states for getting stuck or going permanently to sleep
15:26:37 <EvanR> when the machine becomes unreponsible
15:26:42 <EvanR> unresponsive
15:28:24 <EvanR> to stop it from bricking completely, youd put a reset path out of the stuck state
15:28:59 <EvanR> which requires mealy
15:29:22 <perebor> I'm getting this problem with hmatrix: https://stackoverflow.com/questions/35335947/duplicate-library-linking-with-stack-and-nix has anyone encountered it?
15:33:54 <DillyD> Hey
15:42:15 <erisco> forall a. f (Maybe a) -> Maybe (f a)  impredicative types nooo
15:52:02 <Cale> erisco: I don't know what we're talking about, but that doesn't look like an impredicative type to me
15:52:29 <erisco> I cut it out of a larger type
15:52:59 <erisco> I am going to instead cobble it together with Traversable... not exactly what I wanted (only one instance) but w/e
15:56:07 <typedrat> Does anyone know how to do a partial match based on timestamps in Opaleye? Is it possible? That is, to say "filter to things where the PGTimestamp has this day component"?
16:00:48 <typedrat> never mind lol, just a mental mismatch from being used to types making sense
16:01:47 <Cale> lol
16:07:31 <Renard_Chase> So, I have a list of tens of thousands of boolean, how would I go about checking if "false" appears a certain number of times in a row in that list?
16:09:52 <EvanR> well to get the thing-to-test in the proper shape you can do this
16:10:05 <EvanR> map (take 3) (tails [1,2,3,4,5,6,7,8,9])
16:10:08 <EvanR> > map (take 3) (tails [1,2,3,4,5,6,7,8,9])
16:10:10 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9],[9],[]]
16:10:24 <Cale> I would say start with group
16:11:49 <EvanR> group [0,0,1,0,1,0,0,0,1,1,1,1,0,1,1]
16:11:51 <EvanR> > group [0,0,1,0,1,0,0,0,1,1,1,1,0,1,1]
16:11:53 <lambdabot>  [[0,0],[1],[0],[1],[0,0,0],[1,1,1,1],[0],[1,1]]
16:12:17 <Renard_Chase> Oh, then I can use map length
16:12:23 <Cale> or map (drop n)
16:12:30 <muesli4> Renard_Chase: How is that list produced? Why not pattern match on: drop (n - 1) . filter not
16:12:34 <Cale> and check if the result is null or not
16:12:38 <Cale> yeah
16:12:46 <Cale> other way around
16:12:47 <Renard_Chase> drop n-1?
16:12:51 <EvanR> > find (\xs -> head xs == 0 && length xs == 3)
16:12:53 <lambdabot>  <[[Integer]] -> Maybe [Integer]>
16:12:55 <Cale> oh, filter not, yeah
16:13:04 <EvanR> > find (\xs -> head xs == 0 && length xs == 3) (group [0,0,1,0,1,0,0,0,1,1,1,1,0,1,1])
16:13:06 <lambdabot>  Just [0,0,0]
16:13:10 <muesli4> Renard_Chase: If it appears n times then it is a cons, otherwise it is a nil
16:13:12 <Cale> well, right idea, but that won't typecheck :)
16:13:39 <Cale> > filter (not . head) . group $ [True, False, False, True, False, False, False, True]
16:13:41 <lambdabot>  [[False,False],[False,False,False]]
16:13:52 <Cale> > map (drop 2) . filter (not . head) . group $ [True, False, False, True, False, False, False, True]
16:13:54 <lambdabot>  [[],[False]]
16:14:04 <Cale> > any (not . null) . map (drop 2) . filter (not . head) . group $ [True, False, False, True, False, False, False, True]
16:14:06 <lambdabot>  True
16:17:20 <Renard_Chase> Thanks
16:18:42 <Renard_Chase> I still find Haskell hard, especially with lists since my first instinct is to try and write a foreach loop
16:19:09 <EvanR> loops and mutable accumulating data structures?
16:19:20 <Renard_Chase> Yah
16:20:17 <EvanR> an issue i have is the sneaking suspicion that if i could figure out how to write a complicated algorithm that way, it will be super fast. and if not, it will be super slow
16:20:26 <muesli4> Renard_Chase: Most of those "loop" situations can be solved with higher order functions. And in every other case you can just simulate a loop by recursion.
16:20:40 <EvanR> if you dont learn to think that way in the first place, you might be better off! 
16:21:11 <frankc> I've now come to understand and love the currying of functions. I have a question regarding the compiler and run time treatment: If I've defined a function taking 4 arguments and call it with 3 of the four, is the implementation a sort of 'fold' or 'reduce' based on the passed arguments?
16:22:20 <muesli4> Renard_Chase: https://www.codewars.com is really nice to learn Haskell. In particular because you can view solutions of other users after you solved a task.
16:23:03 <Renard_Chase> muesli4: I know, it's just that when I try to say, use foldr, it feels like I'm trying to write it like a foreach function rather than taking what should be the "correct" solution, if that makes sense
16:23:15 <Renard_Chase> (Err, that was in response to your other statement)
16:23:45 <Renard_Chase> codewars seems useful
16:24:34 <EvanR> if you treat the accumulating parameter as the accumulating data structure, youre doing it right
16:25:19 <EvanR> on the other hand, you might be using the wrong fold
16:25:54 <Renard_Chase> EvanR: When my accumulator is in the form (Bool,Int,[(Bool,Int)]) I'm probably taking the wrong approach
16:26:17 <EvanR> hmm yeah
16:26:35 <EvanR> you might want to break up the problem into smaller bits
16:26:50 <EvanR> instead of trying to do all the work inside the fold
16:26:57 <Renard_Chase> Well the group function was basically the piece I was missing
16:27:05 <EvanR> yeah
16:27:43 <EvanR> functional algorithms ftw
16:27:51 <Renard_Chase> Indeed
16:28:25 <Renard_Chase> What I did learn of Haskell basically made me hate any language that doesn't support higher order functions
16:28:58 <EvanR> many that do still dont do it in a way that is conducive
16:29:12 <EvanR> one of the missing ingredients in laziness
16:29:20 <EvanR> er, is laziness
16:29:28 <frankc> if I create: multFour :: (Num a) => a -> a -> a -> a ->
16:30:06 <frankc> multFour w x y z = w * x * y * z
16:30:32 <Renard_Chase> Laziness is nice, but I don't think I've ever longed for it when using, say, Java
16:30:50 <EvanR> java clouds the mind
16:30:59 <EvanR> lots of distractions
16:31:06 <Renard_Chase> Where as the lack of being able to pass functions around (without using convoluted methods) made me want to bash my head into my desk
16:31:07 <frankc> let multThreeOfFour = multFour 1 2 3
16:31:34 <monochrom> You have Iterator which is equivalent to lazy list.
16:31:55 <EvanR> iterators in lua did not inspire me
16:32:10 <frankc> does it use 'fold' (for example) to iterate through calling multFour for each argument
16:32:11 <EvanR> the main thing, not being able to just combine them
16:32:20 <monochrom> You also have for-loops which relieves some nostagia for lazy list.
16:33:08 <Renard_Chase> For Lua I did write a function that lets me Curry other functions
16:33:46 <EvanR> so many loops
16:33:59 <frankc> or is there some internal 'trampoline' or iterate implementation?
16:34:42 <EvanR> multiFour x y z has type Num a => a -> a, its a function with some context
16:34:48 <EvanR> namely the x y and z
16:34:58 <EvanR> its not really folding or iterating
16:35:30 <tsani> frankc: it's more complicated than that. The GHC paper from way back describes the implementation of function application as using a technique called push-enter. You can check out the paper if you want the nitty gritty.
16:35:37 <tsani> frankc: How to Make a Fast Curry
16:35:39 <monochrom> frankc: I don't entirely understand the question. But multThreeOfFour is merely \z -> multFour 1 2 3. This form is preserved down to pretty low levels when compiled.
16:36:09 <EvanR> nothing is computed until you have all the arguments, at least
16:36:27 <EvanR> (and even then you dont necessarily compute it, becaue laziness)
16:36:45 <monochrom> Err, \z -> multFour 1 2 3 z
16:36:58 <frankc> I've seen the "How to Make a Fast.." and will dig deeper into it. I'm curious if the compiler emits "optimized" resolution when calling with more than 1 argument or the full signature
16:37:26 <EvanR> thats the simple case, having all the arguments up front
16:38:09 <frankc> I understand that providing the final argument (to the final 'returned' function) will compute it 
16:38:30 <EvanR> well, if necessary
16:38:35 <frankc> right
16:38:42 <frankc> I grok laziness as well
16:39:06 <EvanR> > fst ((), 1 * 2 * undefined * 4) 
16:39:08 <lambdabot>  ()
16:41:51 <frankc> to illustrate to a 'clojure' friend I did the nested returns and used reduce with the function as the accumulator and the argument list as the collection and when asked how Haskell implemented I drew a blank. Good thing it is a rainy night, I can read that paper! 
16:42:29 <EvanR> now your question makes more sense
16:42:47 <frankc> sorry I wasn't being clearer
16:42:50 <EvanR> > foldl' (+) 0 [1,2,3,4,5]
16:42:51 <monochrom> What you'll really miss when you have for-loops but not lazy lists is when you want several levels of nested for-loops, but the number of levels is variable.
16:42:52 <lambdabot>  15
16:43:05 <frankc> yes
16:43:10 <sproingie> haskell sends it to Oleg who computes it in his head :)
16:43:15 <monochrom> In Haskell it is simply:
16:43:18 <monochrom> @src sequence
16:43:18 <lambdabot> sequence []     = return []
16:43:18 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:43:18 <lambdabot> --OR
16:43:18 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:44:42 <monochrom> Before you learned about Haskell's "sequence" function, you had had no idea how to do this in Java sanely. (You might be able to think up a not-so-sane solution.)
16:44:51 <frankc> EvanR: am I to infer that foldl' is what the compiler emits?
16:45:15 <EvanR> that is regular code
16:45:44 <EvanR> i assumed something like that is what you showed the clojure dude
16:45:52 <frankc> ahhh, yes... 
16:46:10 <sproingie> @src foldl'
16:46:10 <lambdabot> foldl' f a []     = a
16:46:10 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:46:16 <EvanR> > foldl' (+) 0 [1..100000]
16:46:18 <lambdabot>  5000050000
16:46:23 <sproingie> seq is where things start getting magic
16:46:49 <EvanR> things start getting operationally semantic
16:46:50 <frankc> (reduce multFour 0 [1 2 3]) ; which returns the final function (partial application)
16:47:27 <EvanR> ah well that wont type check in haskell. it only works thats to clojure being loose with the dynamic types
16:47:35 <frankc> true
16:47:36 <EvanR> thanks to
16:47:57 <EvanR> btw multFour has a sane thing in haskell
16:48:02 <EvanR> > product [1,2,3,4]
16:48:04 <lambdabot>  24
16:48:13 <EvanR> now you can multFour Five and however many
16:48:33 <monochrom> multFour is a fine-tuned example that is susceptible to reduce. In reality you are more likely to encounter \x y z t -> (x + y*z)^(sin t)
16:48:34 <frankc> but I was trying to illustrate currying and what the compiler may emit when seeing that there is a partial application
16:49:18 <EvanR> ehhu...
16:49:49 <EvanR> well you need a better example, and bringin in Num instances of functions is likely to confuse everybody
16:50:11 <frankc> that paper may do me good to read first
16:51:14 <frankc> after 4 weeks of Haskell learning I can't believe I've wasted 10 years looking at everything else :)
16:51:33 <monochrom> Numbers and strings are the top two things people think of when they think of data and types.
16:52:00 <frankc> thanks for the help EvanR
16:52:09 <EvanR> comparisons of haskell and clojure are interesting, its a good puzzle trying to figure out where the two worlds were coming from and where they meet and differ
16:52:15 <monochrom> Booleans is the second to last and functions is the last.
16:53:12 <frankc> Yes, when it comes to currying functions, in clojure, it is a do-it-yourself proposition
16:53:27 <frankc> and I can see why
16:53:46 <frankc> with the variadic signatures
16:53:55 <monochrom> @quote monochrom download
16:53:55 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
16:54:32 <frankc> are variable arity as well
16:54:45 <EvanR> and variable meanings of the word "arity"
16:54:49 <frankc> yes
16:55:16 <frankc> I have a mathematician friend who labelled it "insanity"
16:55:41 <frankc> and he pointed me to Haskell
16:55:48 <monochrom> Ah yes, OCaml also wants you to write "\z -> f x y z" when f supports "optional parameters" because otherwise great ambiguity.
16:56:17 <monochrom> I wouldn't call it insanity but it's certainly a disappointment.
16:56:35 <frankc> I did see some examples at attempting the var-arity. in Haskell... polyvariadic ?
16:56:52 <EvanR> every function takes exactly one argument
16:57:00 <c_wraith> yeah, "polyvariadic" is the term.
16:57:04 <monochrom> Yes, Text.Printf does this. Suffers the exact same problem.
16:57:21 <frankc> I am too green to wrap my head around that yet
16:57:42 <monochrom> (\x -> printf "%d %d" 5 x) is alright, (printf "%d %d" 5) is not.
16:57:50 <EvanR> thats why you want to internalize every function takes exactly one argument ;)
16:58:00 <c_wraith> I've got almost a decade in Haskell, and I've determined that I'd rather not understand how printf works.  If I knew, I'd be tempted to use it. :)
16:58:22 <c_wraith> I'll wait for dependent haskell to introduce type-safe printf instead
16:58:49 <monochrom> Cale has a category-theoretic printf that doesn't use tricks. You may like it.
16:59:02 <frankc> I'll make note of that, my next deep dive would be Monads
16:59:27 <monochrom> But Text.Printf today has one more generalization so it's harder to see its core idea. Look for an old version, it's simpler and it's plain as day.
16:59:49 <frankc> will do
17:02:20 <monochrom> http://hackage.haskell.org/package/category-printf
17:02:40 <monochrom> No examples. What they complain about poor documentation applies. :)
17:05:55 <Cale> No examples?
17:06:26 <Cale> monochrom: No examples of what?
17:10:42 <mjora7> Is there a Haskell framework that solves the same problems as Django (Python), Rails (Ruby), Express (JS)?
17:12:23 <Cale> mjora7: There are several web frameworks for Haskell... perhaps the closest to rails would be Yesod, but personally, it's not my favourite.
17:12:49 <mjora7> Cale: What is the most popular one? That seems safest to me (mostly because there will be more educational material on it).
17:12:53 <Cale> mjora7: Have a look at Happstack or Snap
17:13:09 <Cale> Well, they're all reasonably popular and well documented
17:13:16 <EvanR> how popular stuff becomes popular...
17:13:22 <Cale> We're using Snap in production where I work
17:13:26 <EvanR> no matter how good/bad
17:16:01 <mjora7> Thanks for the suggestions
17:19:14 <saylu> Hey folks! Trying to read in a list of URLs from a CSV and having trouble with the url encoding.
17:19:22 <saylu> Some of the URLs have special characters like this:  …tanaka®…
17:19:29 <saylu> I’m getting lost because I’m not sure which `readFile` to use (System.IO? Text.IO? ByteString.IO?) to avoid getting those characters escaped with `\174` and so on.
17:19:44 <saylu> Of course, then I need to parse it, for which I’m planning to use `http-types` to just go ahead and URL encode it like this:  …tanaka%C2%AE…
17:19:49 <saylu> Any advice here?
17:20:42 <Cale> saylu: If you don't want to decode the special characters and would prefer to deal with raw bytes, then ByteString. Otherwise the stuff in Text will decode them
17:20:57 <saylu> I thought the Text package handled UTF-16, but playing around with it I'm getting escaped characters. I'm sure I'm missing something here.
17:20:57 <saylu> https://www.irccloud.com/pastebin/gp70rZrx/
17:21:15 <Eduard_Munteanu> saylu, there is no escaping in any of those, that's just for display purposes when you show them
17:21:57 <Cale> Try using putStrLn to print the Text back out
17:22:01 <EvanR> Text is an abstract unicode text type, UTF-16 shouldnt factor into anything you do with it
17:22:10 <EvanR> (except for one detail)
17:22:21 <EvanR> minor
17:22:59 <EvanR> UTF-16 is a property of ByteStrings
17:23:36 <saylu> Hmm OK. Let me check on that a bit more, thanks
17:25:04 <saylu> Hey, would you look at that -- using Data.Text.putStrLn does give the same back out.
17:26:12 <EvanR> and that is yet another thing... putStrLn sends to the output system an encoding that your terminal properly displays because of locale (or by accident)
17:27:05 <EvanR> we really should upgrade all links to be able to carry unicode directly to avoid these issues ;)
17:27:37 <EvanR> QAM-1114112
17:29:20 <mjora7> I'm just afraid that figuring out how to do database transactions and authentication and various other backend stuff in Haskell frameworks that are significantly less popular than the mainstream frameworks is going to be a nightmare for me
17:29:35 <mjora7> Or am I totally wrong about that?
17:29:53 <EvanR> i found transactions to be straightforward, but i havent used the most popular frameworks
17:30:02 <Cale> It's certainly no worse than in mainstream frameworks
17:30:14 <EvanR> authentication is a nightmare no matter what
17:30:34 <EvanR> i end up writing it myself in any system
17:32:03 <mjora7> Yeah I don't want to every write my own authentication haha
17:34:57 <mjora7> ever*
17:41:39 <Eduard_Munteanu> About that, does persistent even do transactions?
17:41:59 <mbw> Hello again. Still struggling with Repa. What is the idiomatic way of "zipWithing" more than two arrays? Repa does not seem to have anything in the way of zipWith3 etc., but there are function zip3 and up in Data.Array.Repa.Repr.Unboxed. Should I use those, or should I prefer something along the lines of traverse or interleave?
17:42:34 <EvanR> i cant imagine a popular database framework not doing transactions... besides mongo, doesnt count
17:43:55 <Eduard_Munteanu> I have assumed Yesod's runDB enclosed a transaction, but that can't be right because you can intersperse logic with database operations.
17:44:31 <EvanR> which you are supposed to do in SQL anyway
17:44:38 <Cale> That isn't right, you absolutely can intersperse logic with database transactions
17:44:54 <Eduard_Munteanu> Oh, hm.
17:45:10 <EvanR> especially the decision to abort
17:45:21 <Cale> The DB will give you the results of intermediate computations in your transaction
17:45:23 <EvanR> but also the decision to do random other IO
17:49:39 <orion> What's wrong with that?
17:50:54 <Eduard_Munteanu> Nothing, I assumed it was more constrained than non-transactional operations.
17:51:37 <EvanR> well STM has a lot more guarantees
17:51:58 <EvanR> a transaction can only depend on STM variables
17:52:04 <EvanR> and the inputs
17:52:16 <Eduard_Munteanu> Yeah, I was thinking of something like that.
17:52:25 <EvanR> you can retry as much as you want without causing weird stuff
17:52:29 <EvanR> not the case in SQL
17:52:36 <EvanR> but is nice when you set it up like that
18:00:29 <saylu> Well, well. If you so much as open one of these CSVs with Excel it automatically intersperses weird characters.
18:00:33 <saylu> That's the root of the problem
18:00:44 <saylu> God, what an afternoon
18:00:50 <saylu> Thanks for the help guys
18:01:18 <EvanR> probably an encoding issue
18:01:30 <EvanR> excel has permanently had unicode problems as far as i know
18:02:03 <saylu> Yea. I have most of the original CSVs that are fine, but a handful that were opened and briefly edited before they were sent to me
18:02:21 <saylu> Testing had been fine but when I got to those, suddenly...issues! but I didn't think to check on that.
18:11:08 <mbw> I hope it's not bad etiquette, but I'd like to ask my previous question again. Is there an idiomatic way of applying a zipWith function to more than two Repa arrays? While I can apply zip3/4/... to unboxed Repa vectors, these operations do not return a delayed representation and may not be the best way to go about this. On the other hand, only zipWith exists, no zipWith3 etc.
18:12:17 <Welkin> > (+) <$> [1,2,3] <*> [4,5,6]
18:12:19 <lambdabot>  [5,6,7,6,7,8,7,8,9]
18:12:45 <Welkin> > (+) <$> [1,2,3] <*> [1, 1, 1] <*> [2, 2, 2]
18:12:47 <lambdabot>  [2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4]
18:12:56 <Welkin> oh yeah
18:13:19 <EvanR> the heck
18:15:03 <Welkin> mbw: you can always apply it multiple times
18:15:03 <dmj`> someone added AI to lambdabot
18:16:08 <Welkin> no dmj`, you just have me on ignore
18:17:07 <Welkin> > hello dmj` 
18:17:09 <lambdabot>  <hint>:1:12: error:
18:17:10 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:17:48 <pacak> > (,,) <$> ZipList [1..5] <*> ZipList "abcde" <*> ZipList [100..]
18:17:49 <Welkin> > "dmj`: I am outside your window"
18:17:50 <lambdabot>  ZipList {getZipList = [(1,'a',100),(2,'b',101),(3,'c',102),(4,'d',103),(5,'e...
18:17:51 <lambdabot>  "dmj`: I am outside your window"
18:18:04 <pacak> > getZipList $ (,,) <$> ZipList [1..5] <*> ZipList "abcde" <*> ZipList [100..]
18:18:05 <lambdabot>  [(1,'a',100),(2,'b',101),(3,'c',102),(4,'d',103),(5,'e',104)]
18:18:07 * dmj` gasps
18:18:32 <pacak> mbw: You might need to write some instances for that. Or might not.
18:18:48 <rotaerk> hmm what's needed to allow (+) <$> [1,2,3] <*> [1,1,1] <*> [2,2,2] to work?
18:18:52 <rotaerk> it doesn't work in my GHCI
18:19:04 <pacak> rotaerk: import Control.Applicative?
18:19:09 <lyxia> mbw: the easiest seems to be either zipWith or fromFunction
18:19:15 <EvanR> hear hear how is + applying to 3 lists
18:19:17 <pacak> rotaerk: Are you on some ancient version?
18:19:17 <rotaerk> no, that's already in the prelude
18:19:32 <mbw> Welkin: Surely all ways lead to Rome. It's just that it feels kinda off. I could probably also do some fancy interleavings. Specifically it's something like p_uv = sum_i (n_i * c_ui * c_vi), with {i,u,v} being indices.
18:20:08 <mbw> I thought that would just be a sumAllS/P . zipWith3 ...
18:20:19 <rotaerk> :t (+) <$> [1,2,3] <*> [1,1,1] <*> [2,2,2]
18:20:21 <lambdabot> Num b => [b]
18:20:59 <rotaerk> for me, ghci says:  :: (Num (a -> b), Num a) => [b]
18:21:00 <mbw> That would be the function invoked by fromFunction.
18:21:28 <lyxia> rotaerk: someone just defined it in lambdabot
18:21:47 <rotaerk> :t (<*>)
18:21:49 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:21:52 <lyxia> it's not in any standard location
18:22:05 <pacak> :t (+)
18:22:06 <lambdabot> Num a => a -> a -> a
18:22:17 <rotaerk> :t (<$>)
18:22:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:22:19 <pacak> > let 2 + 2 = 5 in 2 + 2
18:22:21 <lambdabot>  5
18:22:29 <rotaerk> they all look standard though
18:22:29 <lyxia> rotaerk: "it" being instance Num b => Num (a -> b)
18:22:35 <rotaerk> ah
18:28:38 <mbw> Or let me ask this another way (since I'm sure I can figure out a way to do this via some fancy interleaving or something). The problem I see with using zip3 is that, although it is an O(1) operation, it returns a manifest Unboxed Array. Am I correct in that you should try to make a pipeline of Delayed representations and computeS/P as late as possible?
18:35:05 <lyxia> yes
18:35:51 <lyxia> actually no
18:36:00 <lyxia> zip3 is just that cheap
18:37:38 <mbw> But in my case I have to zip a vector, and two slices. Since zip3 expects Array Us, I have to compute those.
18:42:38 <lyxia> okay, zip3 is cheap if you actually have unboxed vectors in the first place
18:43:25 <lyxia> if you don't just make a function and (unsafe)index into your vectors with the index provided by fromFunction
18:44:06 <mbw> Maybe I am simply seeing too many nails to hammer at with sum . zipWith
18:45:09 <mbw> Repa is just to unusual if you would normally just write a triple for loop.
18:45:25 <mbw> *too
19:24:23 <biglambda> What is neccessary for hackage to index a library. I’d like to help get the qtah library working: https://hackage.haskell.org/package/qtah-qt5
19:28:12 <geekosaur> someone has to upload it
19:59:12 <EvanR> how big is a big Integer?
20:00:25 <geekosaur> limited by memory, at least for the default gmp backend
20:01:22 <EvanR> when it exceeds the value of a small Int, but isnt much bigger than that, how many bytes does i end up taking
20:01:29 <EvanR> does gmp expose that
20:04:44 <geekosaur> doesn't look like it
20:04:48 <geekosaur> at leats, not readily
20:04:59 <geekosaur> I can get digits, or I can get "limbs"
20:05:58 <EvanR> apparently Integer's backend got some attention https://ghc.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
20:06:21 <andrei> Is there a way to use lenses in order to zip a list onto two fields? I have data X = { a :: [Y], b :: [Y]}, and I want to give every a and b an identifier. Right now I do a zipWith on each field independently.
20:06:27 <EvanR> "if integer-simple is fast enough, then this solves all the issues with integer-gmp"
20:06:30 <andrei> And use their length to make ti unique
20:12:49 <EvanR> so haskell programs cant ffi to gmp normally since its already linked in and taking up those symbols, or something
20:13:39 <geekosaur> actually haskell programs can ffi to it fine, it's C programs that can't use it because they'd be manipulating Haskell's heap
20:13:48 <geekosaur> there's at least one library on hackage that does ffi to gmp
20:14:42 <geekosaur> unless gmp is statically linked but then you'd have problems anyway
20:15:01 <EvanR> man this licensing paragraph seems really bad
20:15:43 <EvanR> for people that care about licensing. i know a lot of haskell libs are BSD, but static GMP triggers a phase shift of the entire compiled program and ghc itself (???) to be LGPL
20:15:53 <geekosaur> yep
20:16:25 <geekosaur> that's precisely why some effort was put in to bring integer-simple up to snuff (both making a ghc with it, and making its performance not be utterly terrible)
20:16:31 <rotaerk> hmm is there some way to derive a typeclass instance for a type *after* the declaration of that type
20:16:42 <geekosaur> -XStandaloneDeriving
20:16:46 <rotaerk> thanks
20:16:52 <geekosaur> deriving instance Foo Bar
20:21:18 <EvanR> whats the latest on integer-simple then?
20:21:43 <geekosaur> unclear. it is believed that some commercial entities are using it, but they don't talk about it
20:22:03 <EvanR> heh
20:22:31 <geekosaur> (considering some of the commercial entities that I've worked with, admittedly indirectly, I can well imagine (a) severe allergy to GPL in any form (b) severe allergy to talking about anything they do
20:28:03 <freeside> unbalanced parentheses after token "do"
20:32:18 <geekosaur> normal for me >.>
20:33:18 <EvanR> gotta love how trivial Integer makes the calculations to synchronize monotonic clock nanoseconds and samples per second!
20:34:34 <EvanR> if i compile GMP into the binary, and run it on an arcade machine, which accepts quarters, does that mean i have to fork over the source code on demand
20:35:22 <freeside> :)
20:36:10 <monochrom> I don't think the quarter matters.
20:37:35 <freeside> use the arcade machine's LEDs as a communications channel to slowly blink out the source code over time
20:38:50 <EvanR> (i found out recently that LEDs can transmit data in the gbps range, or theoretically more, due to bandwidth of visible light)
20:39:06 <EvanR> (through air)
20:39:49 <freeside> i heard of an attack on a network switch once whose port LEDs were synchronized with the TX/RX -- attacker just drive up outside and focused a telephoto lens on the switch.
20:40:15 <EvanR> tell me another one
20:40:41 <freeside> after that the manufacturer had to decouple
20:44:16 <freeside> http://applied-math.org/optical_tempest.pdf
20:46:57 <frontendloader> EvanR: funny that transmitting data with LEDs should come up in here, I'm dorking around with an internet of things device that gets config data from your phone through a light sensor
20:47:06 <frontendloader> and your phone screen flashing rapidly
20:47:40 <EvanR> next thing itll be black monoliths
20:48:53 <geekosaur> and black helicopters
20:54:04 <freeside> is it purelifi or something else?
20:55:27 <freeside> ah, http://www.es.ewi.tudelft.nl/msc-theses/2015-Vasilakis.pdf
21:44:41 <EvanR> sdl2's open audio spec type wants a field of type forall actualSampleType. AudioFormat actualSampleType -> IOVector actualSampleType -> IO ()
21:45:09 <EvanR> i mandated actualSampleType to be Int16, but then my callback must be polymorphic for it to type check
21:45:26 <EvanR> so not sure how to treat that IOVector
21:47:20 <EvanR> ah hmm, pattern match on the audio format argument
21:48:07 <EvanR> sweet
21:48:19 <EvanR> haskell made easy
22:01:28 <Engen> hey everyone, I'm just trying to do some exercises with propositional logic and am having some trouble understanding the following syntax
22:01:55 <Engen> http://wklej.org/id/3093872/
22:02:46 <Engen> is line 2 simply defining two functions
22:03:14 <Engen> or is it defining that the variables true and false are of type PropFormula
22:04:18 <alx741> Engen: two variables of type PropFormula, which has constructors PTrue and PFalse
22:04:28 <Engen> http://wklej.org/hash/33a5917ef3b/ is the full given paste if it helps
22:08:57 <Engen> alx741: by being constructors, they always have the given values?
22:16:44 <pavonia> They never change their values
22:25:38 <alx741> Engen: PTrue and PFalse *are* the values in this case
22:47:05 <srk> looks like it is possible to compose pipes mvc and vinylgl into live plotting library \o/
23:06:25 <Engen> I'm not quite sure understanding where my function is going wrong here: http://wklej.org/hash/12d220293ca/ in the 3rd and 4th guard, the results that are either multiplied or added together are all Bool 
23:07:22 <Engen> yet the error I get from ghci when I try to load the function is "Couldn't make expected type `Bool' with actual type `PropFormula' referring to the PAnd a b and POr a b lines
23:09:03 <pavonia> Engen: "PAnd a b" is a value of type PropFormula, not type Bool
23:09:10 <cocreature> Engen: "PAnd a b" is of type "PropFormula" but "evalSimple a && evalSimple b" is of type "Bool". you can only compare things of the same type with "=="
23:10:12 <pavonia> Engen: You probably don't want to use guards there but just use pattern matching
23:10:34 <Engen> cocreature: but I'm not comparing it, I'm saying let the result be evalSimple a && evalSimple b
23:10:51 <cocreature> oh right, then pavonia’s answer is the one you’re looking for
23:11:16 <cocreature> you could use "PAnd a b <- p" as your guard if you really want to
23:13:51 <Engen> I see... 
23:14:02 <cocreature> regular guards need to be boolean expressions
23:14:11 <Engen> Oh I see my misunderstanding - I thought that doing pattern matching meant handling all your cases using guards
23:14:27 <cocreature> if that doesn’t work you either need to use regular pattern matching or pattern guards
23:14:47 <Engen> but I just need to define my function for the different use cases (which is what pattern matching actually is)
23:14:49 <cocreature> Engen: guards are indended when you want to check for something like "i >= 0"
23:15:00 <cocreature> not for differentiating between constructors
23:16:48 <Engen> gotcha
23:40:09 <LordBrain> Hey, i seem to have found an infinite (non-terminating) compile using ghc7.10.3, i did it by cabal installing primitive-0.6.1.0 into a shared sandbox. IS this a known issue?  I set it going 8 hours or so ago, and its still chewing on it... hovering around 70% cpu usage.
23:41:37 <LordBrain> could be cabal issue i dont know.. its cabal-install 1.22.9.0, with 1.22.8.0 Cabal library version
23:48:32 <pacak> LordBrain: ghc 7.10.3 is a bit old.
23:49:28 <LordBrain> yeah but so is everything else, so it shouldnt matter
23:50:01 <pacak> LordBrain: It's unlikely that bug will be fixed
23:50:17 <pacak> Unless it's reproduceable in newer versions
23:50:22 <LordBrain> i want to know if it is known or not, so i know what is going on
23:50:44 <LordBrain> if you find a trac link or something, i'd appreciate it
