00:12:48 <Gurkenglas> matrium, The simplest m to satisfy that would be Rdf r => ReaderT (RDF r) IO
00:18:29 <Gurkenglas> Lokathor, I feel uncomfortable about split. What if it leaks information?
00:19:21 <Lokathor> Gurkenglas, what information could it leak? Also, be aware that StdGen's version of split is just about as nonsense as what I wrote
00:19:30 <Gurkenglas> Then again, afaik it's no worse than the correspondent hackage implementation
00:19:36 <Lokathor> yeah
00:20:07 <matrium> Gurkenglas: Thanks! Just learned that "runReaderT (renderGraph a b) graph" works 
00:20:44 <Gurkenglas> Lokathor, the seed, so that someone observing what happens after a split could predict what values you'll generate
00:21:17 <Lokathor> well they can alraedy use show
00:21:26 <Lokathor> and it'll report the seed and inc values right there in the show string
00:21:37 <Gurkenglas> They're only observing the output values in the hypothetical
00:23:21 <Lokathor> I'm confused, so does the attacker have the generator that you're calling split on or not in this scenario?
00:23:25 <Gurkenglas> iirc a "cryptographically secure" (terminology possibly not precise?) random number generator can't be distinguished by its outputs in polynomial time from a true random number generator, such that, say, a webserver can use it to assign session ids or something to people without blackhats being able to walk all over it
00:23:55 <Lokathor> oh, well i don't this this is crypto secure rated
00:24:09 <Gurkenglas> Lokathor, the hypothetical attacker is reading the values you're outputting and wants to predict what you'll be saying
00:25:24 <Lokathor> well, i'm no PRNG expert, so I don't know
00:26:42 <_sras_> I am trying to implement a generic validation function for records (using Digestive functors). I am stuck here where I have to extract names a particular field using the generics.  http://lpaste.net/355022 , How can I make the function `filedLabel` return the name of the current field?
00:26:48 <Gurkenglas> If the original rng doesn't allow attackers to reconstruct missing values in a stream either, a convenient way to construct a secure split might be to simply put every other previously future value into the one side of the split and the rest into the other
00:27:42 <Lokathor> Gurkenglas, that's... not... Well at least I don't think that's possible, given how the numbers are generated
00:28:24 <Lokathor> the generator doesn't exist as a cycling list of values, so you can't just run a fold over those values to get a new cycling list, for example
00:28:42 <Lokathor> here i mean list in the haskell [Int] sense
00:29:05 <Gurkenglas> Naively implemented, this'll degenerate into exponential time used if the user keeps splitting the same generator, so one would want a generator such that applying it twice doesn't take any longer, like multiplying by a key modulo some number, where you can just multiply by key^2 instead. I'm just ranting here, you don't need to be better than hackage
00:30:32 <Lokathor> i figured that something less than 4 runs of the generator would be sufficient
00:30:55 <Lokathor> but that was also the most obvious route
00:31:28 <Gurkenglas> No, your version won't degenerate exponentially, I'm talking about the hypothetical splitting left-right-left-right of future values
00:32:06 <Lokathor> right
00:33:09 <nshepperd_> Splitting by skipping values like that gets exponentially slower, and the cycle length gets exponentially shorter
00:33:32 <Lokathor> but my cycles!
00:34:16 <Gurkenglas> Lokathor, any generator can be seen as a list of future values generated by unfold, such that the user can't even see the key, but then splitting can only work the way I said, but then unfolding that gen into a list of gens would have the 20th have to skip ~a million values each time
00:34:37 <Lokathor> right
00:34:39 <nshepperd_> You can implement a cryptographically secure split by hashing a bitstring corresponding to your path through a series of splits
00:34:45 <Lokathor> RandomGen has a method for that even
00:36:20 <Lokathor> QuickCheck and quickcheck-io
00:36:34 <Lokathor> can anyone else see the problem with these two packages :P
00:37:08 <nshepperd_> That is, the left output of the split is the current hash state updated with a 0, and the right output is the state updated with a 1
00:37:45 <Lokathor> ooh, package tests pass on my raspberry pi too
00:38:39 <nshepperd_> I think there's more stuff to add to the construction so that you can get a security proof but that's the basic idea
00:48:38 <_sras_> How can I fix this error (Generics) http://lpaste.net/355024?
01:59:01 <phz_> hey, I’m trying to use stack test --coverage
01:59:11 <phz_> but when the command has finished, I get the following in the index.html:
01:59:20 <phz_> No hpc_index.html files found in …
01:59:24 <phz_> any idea?
02:01:51 <phz_> and if I try stack hcp report, I get this:
02:01:52 <phz_> user error (Not generating combined report, because no targets or tix files are specified.)
02:02:32 <phz_> I guess I need those .tix :/
02:08:19 <matrium> what
02:09:17 <nilof> What is the "best" way to sort a persistent linked list if you ban mutation? Mergesort? Heapsort with persistent heaps?
02:09:18 <matrium> what's the best way to map an n-ary function over a list of (n-1)-tuples?
02:09:54 <matrium> e.g. (a -> b -> c -> d) -> [(a, b, c)] -> [d]
02:10:09 <matrium> can't find any good fit on hoogle
02:11:34 <phz_> matrium: map (\(a, b, c) -> f a b c)
02:12:09 <matrium> phz_: ok :/
02:15:41 <phz_> matrium: uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d; uncurry3 f (a, b, c) = f a b c
02:15:47 <phz_> and you can map (uncurry3 f)
02:28:48 <_sras_> Why is generics so damn complicated!
02:28:53 <_sras_> ?
02:29:13 <Aruro> which part?
02:30:27 <_sras_> Aruro: I have been trying to write a generic validation function using digestive functors from yesterday...
02:30:45 <_sras_> i mean...since yesterday
02:31:40 <_sras_> I cannot find a way to extract the field names from the types in the various class instances...
02:32:17 <_sras_> I am trying to use `selName` function, but the types woulnd't line up....
02:46:56 <kuribas> Should I make a version of my library for base without Traversable, Foldable, etc?
02:53:31 <kuribas> Do these only work with > ghc-8.0?
02:55:32 <kuribas> travis chokes on base >= 4.8: https://travis-ci.org/kuribas/cubicbezier/jobs/226740165
02:57:56 <kuribas> is base tied to the ghc version?
02:58:10 <opqdonut> yes, IIRC
02:58:28 <opqdonut> see here: https://wiki.haskell.org/Base_package
02:59:08 <MarcelineVQ> yes and Data.Foldable and Data.Traversable are both much older than you should ever have to worry about, what has changed in regards to them is that some functions in Prelude use Foldable constraints, which is since ghc 7.10 iirc
03:00:24 <kuribas> So it's no problem if I don't support <7.10?
03:01:09 <kuribas> hm, travis only supports ghc-7.8
03:03:28 <MarcelineVQ> surely that depends on what you set up on travis?
03:03:51 <MarcelineVQ> for example this person has set up multiple verions https://github.com/hvr/multi-ghc-travis
03:03:55 <Axman6> yeah it's definitely possible to use newer GHCs
03:04:06 <MarcelineVQ> oh it's hvr as well
03:08:16 <kuribas> MarcelineVQ: right, I'll try that
03:24:36 <torstein> Say I'm writing a game TicTacToe. A game can have three states: Empty (no moves done), InPlay (atleast 1 move, not finished) and Finished. I want to create two functions, one that takes either Empty or InPlay games and one that takes either InPlay or Finished games. I've tried with DataKinds, GADTs and TypeFamilies but I'm a bit stuck. Any suggestions?
03:27:47 <Boomerang> torstein: Couldn't you split the logic at the function level rather than the type level? Or does it have to be at the type level? Also there's an overlap where the two functions take an InPlay, which one should actually be executed? Are both executed?
03:28:57 <torstein> Boomerang, Yeah, I forgot to mention. It has to be type safe, i.e. compile time errors for calling a function that's supposed to operate on non-empty boards with an empty baord
03:30:14 <pacak> torstein: You tried "stuff" and it "didn't worked" - it's hard to suggest anything specific unless you provide more details about stuff you tried and error messages.
03:32:18 <opqdonut> torstein: you could use phantom types and type classes: "data Empty; data InPlay; data Finished; data Game state = ...; class DoSomething a where doSomething :: Game a -> String; instance DoSomething Empty where ...; instance DoSomething InPlay where ...; class DoOther where doOther :: Game a -> String; instance DoOther InPlay where ...; instance DoOther Finished where ..."
03:34:20 <opqdonut> torstein: or alternatively you could have an empty type classes EmptyOrInPlay and InPlayOrFinished and have function signatures like "doSomething :: EmptyOrInPlay a => Game a -> String"
03:36:16 <torstein> opqdonut, Would that allow me to infer return types? E.g. a function might take an InPlay board and return either a InPlay board or a Finished board. I tried inferring return types with type families but I couldn't use different constructors from the same data type
03:36:30 <opqdonut> torstein: that's hard, requires actual dependent types
03:36:55 <opqdonut> torstein: to make it work you'd need to track the number 
03:37:02 <opqdonut> of moves or the whole game state on tye type level
03:37:08 <opqdonut> otherwise you don't know when the game is Finished
03:37:42 <torstein> opqdonut, Yeah so tracking the moves is no good (I think) because while 9 moves guarantees that a game is finished, it might or might not be with 8 moves.
03:37:47 <opqdonut> yep
03:38:22 <torstein> So I want to track game state in type level, if possible, but then how can I create functions take a subset of game states?
03:38:38 <opqdonut> I don't think you really want to track the whole game state in types
03:38:52 <opqdonut> or if you do, you might be better of with agda or some other more powerful language
03:39:25 <opqdonut> you could consider something like "maybeFinishGame :: Game a -> (Game Finished -> b) -> (NotFinished s => Game s -> b) -> b
03:39:29 <opqdonut> for type safety
03:40:01 <opqdonut> type safety of your api that is, you would still need to trust the implementation
03:40:55 <mivael> hi all!
03:41:22 <mivael> I need hints on >>= implementation in IO.
03:41:36 <mivael> Which concept(s) should I learn to understand (>>=) implementation of the IO monad?
03:41:50 <mivael> (a.k.a. GHC.Base.bindIO)
03:42:02 <mivael> bindIO (IO m) k = IO (\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s)
03:42:22 <mivael> ( http://hackage.haskell.org/package/base-4.9.1.0/docs/src/GHC.Base.html#bindIO )
03:43:04 <mivael> It does not even compile with default options:  "Parse error in pattern: # new_s"
03:44:40 <torstein> opqdonut, I'm not sure I understand that function. But in essence, you mean using type classes to describe unions of types? data Empty derives NotFinished, data InPlay derives NotFinished etc 
03:44:51 <opqdonut> yeah
03:45:02 <torstein> allright Ill give that a go, thank you
03:45:22 <opqdonut> unions are doable, but they make this case a bit more hairy
03:45:33 <opqdonut> it all depends on which constraints do you want the compiler to check and where
03:45:38 <opqdonut> you can't have it check everything
03:46:00 <opqdonut> personally I prefer to compromise on implementation safety and provide a safe api
03:46:48 <torstein> If I do that, then I have to derive a common type class for all game states If I want functions that take any board, right
03:47:05 <torstein> there can't be a 'supertype' so to speak
03:47:36 <opqdonut> I guess you could use a datakind
03:47:55 <opqdonut> or just "fooBar :: forall a. Game a -> Something"
03:50:26 <opqdonut> mivael: I don't think you're supposed to understand the IO bind
03:50:36 <opqdonut> mivael: treat it as a compiler built-in
03:50:46 <opqdonut> mivael: I'm not even sure the source in GHC.Base is "real"
03:51:23 <MarcelineVQ> the syntax error is due to you needing to have UnboxedTuples turned on  https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-tuples
03:51:24 <mivael> opqdonut, but it seems to be a performance bottleneck, I wanted to investigate it further
03:52:05 <opqdonut> mivael: I'm sure the implementation of IO has been tuned to perfection over the years :) but if you're interested in the internals #ghc might be able to help you
03:53:55 <HKei> mivael: What makes you think it is a performance bottleneck?
03:55:16 <mivael> HKei, measurements (*.prof output file).  I can share my code and the *.prof file.
03:55:50 <opqdonut> that might be interesting
04:03:09 <mivael> HKei, opqdonut: ooops, seems like I can not reproduce :(   There were a *.prof file where >>= were blamed for 90+ percents of time (individual %time) but I lost it and now the 90+ is showed for 'interact'.
04:03:43 <opqdonut> mivael: yeah don't expect high performance out of interact
04:03:47 <opqdonut> mivael: or any other String-based IO
04:03:58 <opqdonut> mivael: use ByteStrings or Text
04:04:13 <opqdonut> and/or conduits or pipes
04:04:59 <HKei> didn't both of those have weird issues with actually closing streams and such? Maybe I'm misremembering
04:05:31 <mivael> opqdonut, I discussed related matters recently with mniip and others, now there will be a summary:
04:06:35 <mivael> opqdonut, I tried ByteStrings (Builder, etc) -- performance is okay, code is ugly and hard to remember (the context is competitive programming)
04:07:24 <mivael> opqdonut, I tried ByteString+Attoparsec -- performance is okay, code is okay, but competitive programming sites do not accept Attoparsec (it is not safe)
04:07:34 <HKei> mivael: Huh? ByteString has pretty much the same API as String, except you don't get pattern matching
04:10:00 <mivael> HKei, really?  Can I expect that just using same way I could get good performance?   I mean, how I should "translate to ByteString" the following: interact $ unlines . map show . (processing :: [Int64] -> [Int64]) . map read . words
04:10:25 <opqdonut> mivael: right. so you're sure the time is being spent by interact itself not the String->String function it calls?
04:11:19 <opqdonut> hmm ok you say "inidividual %time"
04:11:55 <mivael> opqdonut, I'm not sure, it is just that profiling results shows me that 'interact' is responsible for 90+ of time
04:12:17 <opqdonut> can you paste the code and input somewhere, I could try looking at it
04:12:30 <mivael> of course
04:12:37 <mivael> just a minute
04:12:41 <HKei> mivael: If you have "lines" and "words" you could do it with ByteString, but that sounds like a job for text, which does have interact, lines, unlines, words and such
04:13:11 <HKei> mivael: Except it isn't linked list based, so generally a lot faster under most circumstances
04:13:29 <HKei> ByteString is better if you're manipulating raw bytes, like binary formats and such
04:14:29 <HKei> mivael: also, in that example OF COURSE interact is 90+% of the time. Your main function is literally just interact, so what else do you expect?
04:16:04 <torstein> I'm getting some kind errors I don't understand when attempting to create empty type classes and instances: https://pastebin.com/0Y3W0DSf
04:17:10 <HKei> torstein: You can't derive arbitrary classes.
04:17:12 <opqdonut> torstein: just use manual instance declarations
04:17:23 <HKei> *arbitrary instances
04:17:25 <opqdonut> torstein: "instance NotFinished GEmpty;"
04:17:36 <opqdonut> oh right you have those already
04:17:38 <opqdonut> just remove the deriving
04:18:47 <opqdonut> torstein: also, that type signature for move means the caller gets to decide whether the result is Game InPlay or Game Finished
04:20:07 <mivael> HKei, opqdonut: http://codepad.org/toYymO59
04:20:48 <torstein> opqdonut, Okay so removing classes yields this: "Not in scope: type constructor or class ‘NotFinished’". Also, is there a way (type families perhaps) to make the function determine the return type (InPlay or Finished)?
04:22:01 <mivael> HKei, this is without actual processing for measurements.  My practice solution was reduced from 500+ ms down to about 120 ms using ByteString  (it is about 60 ms using the same algorithm implemented in C++)
04:22:02 <dysfun> are there any nondeterministic monads that have nothing to do with IO ?
04:22:04 <opqdonut> mivael: hmm, that seems like an IO-heavy task
04:22:20 <opqdonut> mivael: so it seems reasonable interact (i.e. the IO) takes most of the time
04:23:18 <mivael> opqdonut, yes, but it is reduced (approximatelty by 80%) by using ByteString
04:23:36 <opqdonut> mivael: 2x of C++ sounds reasonable to me. especially if you were using ByteString's interact and the vanilla read
04:23:42 <opqdonut> (Haskell Read is notoriously slow...)
04:24:01 <opqdonut> it's reduced because input for bytestring is more efficient
04:24:05 <mivael> +400 ms is important in competitive programming contexts (when there is 1000 ms overall time limit)
04:24:16 <opqdonut> can just read into a buffer instead of allocating a linked list element for every char
04:24:27 <opqdonut> yes
04:24:36 <opqdonut> so what was the problem with using ByteString?
04:24:38 * dysfun saw a job ad for a service with 10ms response SLAs recently
04:25:07 <opqdonut> In my experience of competitive programming, the inputs are usually pretty small so IO doesn't matter. In this case the input is pretty large so you have to use performant things like ByteString
04:25:17 <mivael> opqdonut, in theory, it is possible to use buffer, but would prefer to use lazy I/O because competitive programming problems also have memory limit...
04:25:18 <HKei> mivael: Again, if text is available you could also try Data.Text.IO.interact, which is... well, interact, except with Text
04:26:58 <mivael> opqdonut, "2x of C++" is reasonable for me too, I'm okak with 120 ms, I'm just not with 500+ ms  :)
04:27:08 <mivael> s/okak/okay/
04:27:11 <opqdonut> so what was the problem with ByteString?
04:27:37 <mivael> opqdonut, ugly code  :)
04:27:51 <mivael> hard to remember (and retype fast, if needed)
04:28:22 <mivael> I can show it too.  Maybe I just implemented it wrong...
04:28:37 <HKei> mivael: Do that, please. I'm having troubles imagining what your issue is
04:28:41 <mivael> HKei, so you think I should give a try to Text?
04:29:27 <mivael> HKei, just a sec...  I will provide a couple of links.
04:33:49 <Guest18903> hey guys
04:33:53 <Guest18903> i'm bax
04:34:10 <mivael> HKei, opqdonut: fast (ByteString, 124 ms): http://codeforces.com/contest/456/submission/26607428
04:34:41 <HKei> mivael: oh
04:34:44 <HKei> well...
04:34:51 <mivael> HKei, opqdonut: slow (514 ms): http://codeforces.com/contest/456/submission/26607734
04:35:02 <mivael> HKei, badly implemented?  :)
04:35:40 <HKei> mivael: you're losing a lot of time because of interact, instead of just using bytestring io
04:36:36 <mivael> HKei, this is ByteString's interact (if you are looking at the fast version), not the one from Prelude
04:36:58 <HKei> oohhh
04:37:01 <HKei> ah yeah, sorry
04:37:19 <HKei> didn't see you hid prelude interact, most people just import bytestring qualified
04:37:31 <mivael> sorry for that  :)
04:37:58 <mivael> It was my firts attempt, now I would prefix it...
04:38:12 <opqdonut> mivael: some tips, showResultsBS can be defined using BS.intercalate
04:38:19 <mivael> s/firts/first/
04:40:39 <opqdonut> mivael: and yeah, the lack of read for BS is a bit painful. I'd probably just do "unpackSingleInt = fromIntegral . fst . fromJust" and not check errors
04:40:45 <HKei> otherwise, this doesn't look so bad. Did the non-bs string look so much better? You're only doing IO in main anyway
04:40:51 <mivael> opqdonut, I had an impression that I must use Builder + toLazyByteString to optimize performance, instead of constructing one bytestring per number and that do 'unlines' or similar.
04:41:38 <opqdonut> mivael: might be, but do measure
04:42:26 <opqdonut> mivael: but with an explicit IO loop that goes getLine and putStrLn you can avoid the unlines/lines stuff all together
04:42:49 <mivael> HKei, yes, it did.  This is much better to memorize and, then, faster to re-type: interact $ unlines . map show . processing . map read . words
04:43:33 <opqdonut> mivael: or you can do a hybrid, input with getContents, but output with putStrLn
04:43:34 <mivael> It is clear and brief.
04:43:42 <opqdonut> mivael: ... but in this case the output is just one number on one line, right?
04:44:41 <mivael> okay, I will measure bs + unlines.  And I should probably also try Text?  Or not?
04:44:54 <opqdonut> Text should be pretty equivalent to ByteString
04:45:04 <opqdonut> might be more convenient depending on the exact functions available
04:46:27 <mivael> I should also use Builder there, yeah?
04:48:12 <opqdonut> if you're outputting a couple of lines, I doubt it
04:48:27 <torstein> Is it possible to call functions or do some logic in type family instances? Like this:   Move ('Game GInPlay b) pos = if someLogic b then 'Game GInPlay b else 'Game GFinished b
04:48:52 <opqdonut> torstein: you're looking for dependent typing
04:49:17 <opqdonut> torstein: you can do almost arbitrary computation with type families, but then you need to program in a painful typelevel language
04:49:18 <mivael> HKei, opqdonut:   Well...  1. Measure BS+unlines.  2. Maybe consider Text.  3.  Consider using explicit do-notation IO loop.    Thank you very much!  I will try.
04:49:33 <opqdonut> mivael: have fun
04:49:51 <opqdonut> torstein: see e.g. https://aphyr.com/posts/342-typing-the-technical-interview
04:50:36 <mivael> HKei, opqdonut:   Should I also look to the Pipes/Conduits side?  Or better not? :)
04:50:49 <torstein> Okay I'll read that. So it should be possible?
04:51:57 <opqdonut> mivael: probably overly complex for your use case
04:52:14 <opqdonut> torstein: everything is possible, but not everything makes sense
04:54:58 <mivael> opqdonut, I was afraid it is :)   I had an impression that they can be of use when I need more real-time kind of I/O  (when, for example I need to lazily read test cases and print a result for each one as fast as the whole test case available in input, not some time later).
04:56:27 <mivael> I mean that if a program should have worked not just in batch mode but in interactive contexts as well.
05:00:33 <fXl> hello guys, i have a list like  let x = unlines ["hola", vars ,"fire"] , i have another list vars and i want to add elements of vars one by one like in C. how can i do that ? 
05:02:03 <ketil_> Hi all!  I may be having some problems with Judy.  One option might be to move to a different associative map structure.  I only need Word64 keys (although Word128 would be awesome) and some integer type as values to be stored, but speed and especially compactness is essential.  Data.HashTable.IO?  Or are there other alternatives?
05:02:21 <mivael> fXl, add to what?
05:02:50 <fXl> let vars = [1,2,3] add this to x
05:03:07 <ketil_> fXl, x is a list of Char, how would you add numbers?
05:03:11 <fXl> let x = unlines ["hola",vars,"fire"]
05:03:45 <fXl> i know, i just saying , i want to do something like this
05:03:52 <ketil_> what would you like the result to look like?
05:04:13 <fXl> x = ["hola",1,2,3,"fire"]
05:04:23 <Boomerang> fX1 what output format do you want? "hola\n1 2 3\nfire"? If so try: let x = unlines ["hola", unwords (map show vars), "fire"]
05:05:46 <fXl> Boomerang, thanks i got the idea i guess, i will try
05:06:07 <ketil_> fXl,  x = ["hola",1,2,3,"fire"]  doesn't make sense, what is the type?  [String] or [Int]?  It can't be both.
05:06:20 <mivael> fXl, ["hola",1,2,3,"fire"] is not a valid list
05:06:30 <mivael> > ["hola",1,2,3,"fire"]
05:06:32 <lambdabot>  error:
05:06:32 <lambdabot>      • No instance for (Num [Char]) arising from the literal ‘1’
05:06:32 <lambdabot>      • In the expression: 1
05:06:38 <fXl>  ["hola","1","2","3","fire"]
05:06:45 <fXl> i just want this then :D
05:07:14 <fXl> but Boomerang's answer is what i need i guess
05:07:19 <mivael> > ["hola"] ++ map show [1,2,3] ++ ["fire"]
05:07:21 <lambdabot>  ["hola","1","2","3","fire"]
05:07:38 <mivael> oh, I missed that
05:07:43 <fXl> cool thanks
05:08:03 <ketil_> So...anybody use HashTable?
05:08:25 <fXl> mivael, can't i do this in unlines? i have to seperate them ?
05:09:35 <mivael> fXl, you can but you'll get different result
05:09:41 <mivael> which one you want?
05:09:43 <mivael> > ["hola", unwords (map show vars), "fire"]
05:09:45 <lambdabot>  error:
05:09:45 <lambdabot>      • Variable not in scope: vars :: [()]
05:09:45 <lambdabot>      • Perhaps you meant one of these:
05:09:52 <mivael> > ["hola", unwords (map show [1,2,3]), "fire"]
05:09:54 <lambdabot>  ["hola","1 2 3","fire"]
05:10:39 <fXl> yeah, "1 2 3" this is not what i intended to do
05:11:40 <mivael> fXl, unlines/unwords version makes 3-element resulting list, without them is is (2+len(vars)-element list
05:11:58 <mivael> s/is is/it is/
05:12:33 <Boomerang> /// Accelerometer sensor values (ADXL337) ///
05:12:35 <mivael> ketil_, I tried HashTable once
05:12:42 <Boomerang> (sorry wrong copy paste)
05:16:32 <ketil_> mivael, any idea how it performs, esp. compared to Judy arrays?
05:17:21 <ketil_> Guess I could just try it myself, of course - but I worry about memory use (so IntMap etc are right out).
05:18:57 <fXl> > unwords $ map (\y -> "\"" ++ y ++ "\"") $ map show [1,2,3]
05:19:00 <lambdabot>  "\"1\" \"2\" \"3\""
05:19:20 <fXl> mivael, i dont want those \ back slashes
05:19:21 <_sras_> Is there another function like `symbolVal` that can convert types of arbitrary kinds back to values?
05:31:40 <mivael> ketil_, I never used Judy arrays
05:32:14 <cocreature> _sras_: I’m not entirely sure I understand your question but maybe you’re looking for something like the singletons library? in particular, singByProxy
05:32:35 <niez> fXl, if I understand correctly, you want to convert a list of integers to some string representation, what is your desired output?
05:33:09 <ketil_> _sras_, undefined?  By some definitions, that is a value that inhabits any type.
05:33:56 <cocreature> ketil_: it’s just not a particularly useful value :)
05:34:05 <fXl> niez, lets say i have this list [1,2] what i want to do is "1 = {}" "2 = {}"
05:34:43 <ketil_> mivael, but HashTable performance?  And memory overhead?  Judy stores key-value pairs very close to the optimal 2*64bit.  Some space for hashtable sparsity is survivable, I guess, but boxing or copy-GC is out.
05:34:53 <fXl> > unwords $ map (\y -> "\"" ++ y ++ "\"") $ map show [1,2,3] and this works i guess 
05:34:55 <lambdabot>  error:
05:34:56 <lambdabot>      • Couldn't match expected type ‘([Bool] -> Bool)
05:34:56 <lambdabot>                                      -> t2 -> t1 -> Expr -> t0 -> [[Char]]’
05:35:08 <fXl> oops sorry lambdabot :D
05:35:29 <ketil_> cocreature, well if you want something useful, better to specify how it's intended to be used, don't you think? :-)
05:36:16 <niez> fXl, like this? map ((++ " = {}") . show) [1,2]
05:36:40 <fXl> > map ((++ " = {}") . show) [1,2]
05:36:42 <lambdabot>  ["1 = {}","2 = {}"]
05:37:08 <fXl> > unwords $ map ((++ " = {}") . show) [1,2]
05:37:10 <lambdabot>  "1 = {} 2 = {}"
05:37:23 <fXl> > unwords $ map ((++ " = {}\n") . show) [1,2]
05:37:26 <lambdabot>  "1 = {}\n 2 = {}\n"
05:38:10 <mivael> ketil_, oh I'm sorry, I confused HashMap and HashTable
05:38:20 <fXl> niez, thats cool though , i kinda understand  . show part :D
05:38:32 <ketil_> mivael, or maybe I confused them? 
05:41:32 <fXl> mivael, niez and others thank you for your suggestions, i learnt something new
05:42:00 <mivael> ketil_, I used HashMap only once.  Can't really judge about performance much.  In my case I switched (back) to array because interval of possible keys allowed that and time was more important.
05:43:09 <torstein> Quick question .. In type families, can the return type depend upon the value of the input types (in contrast to the input type itself)?
05:44:37 <niez> fXl, it's a function composition, first numbers are converted to strings and then this extra suffix " = {}\n" is appended to each item, you can write this in two steps (two maps) to understand what's going on: map (++" = {}\n") (map show [1,2])
05:45:19 <fXl> niez, for now only i have struggles about . show thing
05:45:19 <fXl> :D
05:45:20 <ketil_> HashMap is just an IntMap using hashes of keys.  So it will be memory expensive due to the IntMap tree, as well as needing to store the actual keys (in case of hash collisions).  So that's certainly not useful for my use.
05:45:24 <ketil_> But thanks anyway :-)
05:45:37 <_sras_> cocreature: can you please take a look here. Been hacking on this for a couple of days, and I am pretty sure there is a better way. http://lpaste.net/355027
05:45:52 <fXl> i always doing it wrong :D how can i now which function composition will work :D
05:46:16 <_sras_> cocreature: The aim is to implement a generic function that can return a Digestive Functors Form for any record....
05:46:16 <fXl> map ((++ " = {}") . show) [1,2] for this lets say
05:46:43 <fXl> (++ " = {}") . show  = (++ " = {}") is this input for show ?
05:46:52 <cocreature> _sras_: step 1: use generics-sop instead of GHC.Generics :)
05:47:39 <_sras_> cocreature: Really?  And I have been asking here for two days...Where have you been ? :)
05:51:27 <_sras_>  "As an example of a generic function, let us define a generic version of rnf from the deepseq package."  -- Why do Haskell documentation always use obscure examples?
05:52:00 <niez> fXl, no, show takes integer an converts it to string, so you get list of string out of list of integers, and after that this list is processed by (++ " = {}")
05:52:42 <niez> fXl, the (.) works from right to left
05:53:21 <niez> fXl, I hope it helps :)
05:54:00 <_sras_> cocreature: so should I throw away he current code and start in generics-sop?
05:54:17 <fXl> yeah thank you so much niez
05:54:31 <mivael> :t (.)   -- fXl
05:54:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:56:49 <cocreature> _sras_: I haven’t written a lot of generics code tbh, but the little I’ve written has been significantly more pleasant using generics-sop than using GHC.Generics
06:36:49 <vaibhavsagar> ketil_: I think you're describing Data.Map instead of Data.HashMap
06:37:54 <vaibhavsagar> Data.HashMap is implemented using HAMTs whereas Data.IntMap and Data.Map are implemented using Patricia tries
06:44:45 <adamCS> cocreature, _sras_: Yes, generics-sop.
06:54:32 <pfoetchen> hn nicht aufräumen ich muss
06:54:58 <pfoetchen> uups ;)
06:55:33 <Fendor> german is a great language :P
07:05:48 <ongy> the name gave it away either way
07:10:35 <erisco> what is the purpose of Show1?
07:13:00 <MitchellSalad> erisco: it lets you abstract over a Functor (or whatever * -> *) with no mention of its type parameter, yet still know that no matter what the type parameter ultimately is, you can show the whole thing
07:13:18 <erisco> how? what function lets me show it?
07:13:34 <MitchellSalad> (assuming the param itself has a Show instance)
07:13:42 <MitchellSalad> 'show' will show it, haha
07:14:11 <erisco> so why not  Show a => Show (F a)
07:14:26 <MitchellSalad> ah, so, say I write such an instance for my F
07:14:47 <MitchellSalad> how might some other code work generically over such F-things with that instance?
07:15:14 <MitchellSalad> that's what Show1 is for
07:15:22 <erisco> I am not following
07:15:40 <erisco> so I am writing a function that wants to show x :: F a ?
07:16:00 <erisco> then  (Show a, Show (F a) => ...
07:16:26 <nshepperd_> If the same function uses F at different types
07:16:43 <MitchellSalad> nshepperd_: that's not it
07:16:45 <nshepperd_> eg. Polymorphic recursion
07:17:16 <MitchellSalad> erisco: that constraint is totally fine, but what if you wanted to abstract over the F part? (i.e. 'f')
07:17:47 <nshepperd_> There's no (Show (F a)) constraint you can write that correctly expresses that this should work for all a
07:17:48 <erisco> then lowercase it? does that make GHC unhappy?
07:17:58 <MitchellSalad> nshepperd_: yes there is! -__-
07:19:05 <nshepperd_> Well, i suppose there's that hack in the constraints package
07:19:10 <MitchellSalad> erisco: no, that doesn't make GHC unhappy (if this is a function constraint)
07:19:19 <glguy> how about a Show instance for: data T f = forall a. Show a => C a 
07:19:24 <MitchellSalad> but consider if it was a constraint on a typeclass
07:20:11 <MitchellSalad> nshepperd_: no, I'm not talking about constraints... 'Show (F a)' is a perfectly valid constraint! 'F' here is a concrete type...
07:20:22 <glguy> how about a Show instance for: data T f = forall a. Show a => C ( f a )
07:21:13 <nshepperd_> MitchellSalad: yes, that's a valid constraint. But doesn't say "for all a". It says "for the previously instantiated a"
07:21:15 <glguy> you can have Show (f a) constraints. Show1 shines when a is unnameable
07:21:26 <MitchellSalad> glguy: yes! that's what I'm trying to say
07:21:46 <erisco> T :: (* -> *) -> *  and so does that work with  Show1 :: (* -> *) -> Constraint  ?
07:21:48 <MitchellSalad> this class is impossible to write ('a' is not in scope): class (Show a, Show (f a)) => Foo f where ...
07:22:15 <lyxia> erisco: think if the constraints you need for Show (T f)
07:22:40 <erisco> I am not disagreeing with that
07:23:29 <erisco> I don't see how I write a Show1 instance for it either
07:24:04 <MitchellSalad> hmm?
07:24:10 <erisco> kind mismatch
07:24:22 <MitchellSalad> wha? =)
07:24:32 <MitchellSalad> you'd have to write: class Show1 f => Foo f
07:24:49 <erisco> what is Foo?
07:25:06 <erisco> this is all over the board for me. I don't get what anyone is saying right now
07:25:17 <erisco> glguy brought up the type T
07:25:25 <erisco> I don't see how we can write a Show1 instance for T
07:25:37 <lyxia> because that's not the point of T
07:25:57 <lyxia> the point is to write a Show instance for T
07:26:08 <MitchellSalad> erisco: he meant to write 'data T f a = forall a. Show a => C (f a)'
07:26:11 <erisco> what does that have to do with Show1 then
07:26:45 <MitchellSalad> (I think)
07:26:54 <nshepperd_> erisco: the instance is Show1 f => Show (T f)
07:27:02 <lyxia> well try to write Show (T f) and you'll see that you need soomething like Show1
07:27:51 <MitchellSalad> whoops, I put an extra 'a' on T. heh
07:29:24 <erisco> okay, I know what is being said now, thanks
07:30:35 <erisco> what is showsPrec?
07:30:41 <nshepperd_> Show1 f is basically synonymous with (forall a. Show a => Show (f a)). Except that you can't write the latter in a constraint
07:31:12 <ski> `showsPrec' is what one should normally implement, if and when one manually makes a `Show' instance
07:31:30 <erisco> so what is the Int and what is the purpose of ShowS
07:31:51 <ski> it keeps track of the current precedence level, in order to determine (using `showParen') whether to wrap the shown value in a pair of brackets
07:32:21 <ski> `ShowS' is an optimization of `String', to avoid the inefficiency of left-associating `(++)'
07:33:35 <erisco> > (showsPrec 0 (Just 0) "", showsPrec 9 (Just 0) "")
07:33:37 <lambdabot>  ("Just 0","Just 0")
07:33:40 <erisco> at what point is it going to put parens around it
07:34:21 <ski> > showsPrec 11 (Just ()) ""
07:34:23 <lambdabot>  "(Just ())"
07:34:38 <ski> `10' is the precedence of application
07:34:49 <erisco> 11? then I need to read on these precedence levels
07:35:22 <nshepperd_> > showsPrec 10 (Just ()) ""
07:35:24 <lambdabot>  "Just ()"
07:35:32 <ski> consider something like
07:36:00 <ski>   data Tree a = Leaf a
07:36:01 <ski>               | Tree a :+: Tree a
07:36:18 <c_wraith> if you wanted to describe some precedence as 11, it'd be record updates 
07:36:21 <ski>   infix 5 :+:
07:36:30 <mivael> :t (:+:)
07:36:31 <lambdabot> error:
07:36:32 <lambdabot>     • Data constructor not in scope: :+:
07:36:32 <lambdabot>     • Perhaps you meant ‘:+’ (imported from Data.Complex)
07:36:45 <ski>   (:+:) :: Tree a -> Tree a -> Tree a
07:36:58 <ski> if one were to derive `Show' for this, it would generate the instance
07:37:04 <ski>   instance Show a => Show (Tree a)
07:37:06 <ski>     where
07:38:00 <ski>     showsPrec p (Leaf a)  = showParen (p > 10)
07:38:11 <ski>                           $ showString "Leaf "
07:38:19 <ski>                           . showsPrec 11 a
07:38:41 <erisco> > show (Just (Just 0))
07:38:41 <ski>     showsPrec p (l :+: r) = showParen (p > 5)
07:38:43 <lambdabot>  "Just (Just 0)"
07:38:53 <glguy> paste bin down?
07:39:03 <ski>                           $ showsPrec 6 l
07:39:05 <erisco> so going into show for Just 0 the precedence is 11?
07:39:11 <ski>                           . showString " :+: "
07:39:16 <ski>                           . showsPrec 6 r
07:39:30 <nshepperd_> Hm. So the int passed to showsPrec is the precedence of the operator applied to us, plus 1? Or 0 if there is none
07:39:50 <ski> the precedence for both operands of `:+:' is one more than the precedence of the operator, i.e. `5'
07:40:10 <ski> if `:+:' had been `infixl', then we'd have passed `5' for the left operand, and `6' for the right operand
07:40:19 <ski> if `:+:' had been `infixr', then we'd have passed `6' for the left operand, and `5' for the right operand
07:40:39 <ski> in the `Leaf a' case, conceptually we pass `10' for `Leaf' and `11' for `a'
07:40:51 <erisco> so why did you pass 6 for both?
07:40:59 <ski> but `Leaf' is always the same string, so the precedence disappears there
07:41:05 <glguy> since showsPrec doesn't know about left and right fixities, it's risky to assume that it's ok to send a5 there
07:41:11 <ski> because i defined `:+:' to be `infix', non-associative
07:41:11 <glguy> in general
07:41:32 <ski> so you need to increment the precedence level in both operands
07:41:36 <glguy> it works out here because we know it's another Tree
07:42:05 <ski> so that if you have `(...) :+: (...)', the brackets for the operand here will actually be emitted by `showParen'
07:42:41 <ski> similarly, you can't write `a == b == c', you must write either `(a == b) == c' or `a == (b == c)', depending on which you mean
07:43:06 <ski> brackets are required, since `==' is non-associative. so we need to increment the precedence level
07:44:12 <ski> in the `Just (Just 0)' case, the `showsPrec' defining equation will pass `11' as precedence level to the showing of `Just 0', and then `showParen (p > 10)' will then emit brackets around that
07:44:31 <glguy> If you had a datatype like: data Pair a b = a :.: b -- You'd need to increment the precedence no matter the associativity of (:.:)
07:44:42 <ski> no
07:45:24 <glguy> because if you had some other operator +++ with differing associativity you'd end up with situations like:
07:45:28 <glguy> x +++ y :.: z
07:45:36 <ski> `showsPrec' called on `a' and `b' here will be told the precedence level of the surrounding context (here being in the left or right operand of `:.:')
07:45:38 <glguy> and you'll just get an error trying to use that as Haskell syntax
07:46:17 <glguy> so you can't use whether it's a left or right associative operator to decide whether or not to increment the precendence, you just have to increment
07:46:38 <ski> i don't follow
07:46:54 <glguy> No matter if it's infix, infixl or infixr 5 :.:
07:47:06 <glguy> You'll need to call showsPrec with 6 on both the lft and right arguments
07:47:19 <ski> what is precedence of `+++' ?
07:47:42 <glguy> It could have been infixl 5 or infixr 5, we don't know
07:48:05 <glguy> showsPrec don't convey the associativity of the containing context
07:48:09 <glguy> just the precedence
07:48:53 <ski> if we have `infixl 5 +++,:.:' then given `(x +++ y) :.: z' we're safe to pass on `5' to `x +++ y', which will then omit the brackets, which is safe here
07:49:11 <glguy> If they're both infixl then it would have worked
07:49:19 <glguy> if +++ was infixr it won't be safe to omit
07:49:56 <ski> oh, i see what you mean. i stand corrected
07:50:01 <ski> thank you
07:52:35 <glguy> so you know of a complete document explaining how to work these things?
07:53:03 <ski> not apart from the description in the report
07:54:29 <sproingie> i'm trying to model RPG stats with some measure of type safety, but I'm not sure if I'm on the right track.  someone want to give me opinions on https://gist.github.com/chuckadams/e5ccd9e92b0c9c7c64d3e93a805a0024 ?
07:58:53 <erisco> am I supposed to implement readPrec or readsPrec?
08:01:45 <ski> `readsPrec'
08:01:52 <ski> @type readParen
08:01:54 <lambdabot> Bool -> ReadS a -> ReadS a
08:02:16 <erisco> says readPrec is newer
08:04:00 <Giulia> Hi
08:04:30 <Giulia> anyone located in the US and interested in Blockchain?
08:05:48 <Hafydd> Hi
08:05:49 <Hafydd> anyone located in the northern hemisphere and interested in Program?
08:06:47 <Giulia> @hafydd whats the tech stack?
08:06:47 <lambdabot> Unknown command, try @list
08:07:15 <Hafydd> Giulia: the HHHH (Haskell, Haskell, Haskell, Haskell) stack.
08:08:08 <Giulia> Hafydd: interest in Blockchain ?
08:08:29 <Hafydd> Giulia: mildly, but I'm afraid I am not located in the United Snakes.'
08:08:35 <Giulia> lol
08:08:38 <Giulia> where are you
08:08:55 <Hafydd> The United Kingdom.
08:09:22 <Giulia> whats your GitHub?
08:09:36 <Hafydd> I think it's too early in our relationship for that.
08:10:36 <Giulia> No worries :)
08:11:39 <Hafydd> Giulia: if you have some kind of proposal, you may as well just state it; but if it's not related to Haskell this might be the right channel for it. You might prefer #haskell-offtopic.
08:13:23 <shapr> Giulia: there are some haskell blockchain startups, are you working at one of them?
08:13:26 <Giulia> Hafydd: Yes I do, don't know if this appropriate here tho. I work with loads of interesting companies that are looking to hire Haskell engineers
08:13:42 <Giulia> Yes shapr, precisely 
08:14:15 <luntain> cassava problem: header names start with upper case and one is a reserved word. Is it possible to derive FromNamedRecord instance?
08:14:32 <Giulia> dont want to be rude or annoy anyone here with my recruitment talks, so let me know if this is the wrong channel 
08:15:35 <quchen> If it’s Haskell-related you can ask here. But don’t spam it.
08:16:42 <shapr> Giulia: what's the big advantage of combining Haskell and blockchain?
08:17:13 <quchen> shapr: (the answer is obvious, isn’t it) ;-)
08:17:37 <shapr> quchen: Yes? Haskell can do that?
08:19:46 <shapr> Giulia: What's the name of the company doing blockchain stuff in Haskell?
08:25:10 <Giulia> shapr: sorry for my short absence
08:25:37 <Giulia> shapr: mainly because this company have built their own language with haskell 
08:26:10 <Giulia> they build financial smart contracts for various banks 
08:32:17 <quchen> Giulia: Haskell-exclusive?
08:32:29 <quchen> Or is it just some internal tooling some devs managed to sneak in ;-)
08:36:40 <Giulia> I'm not sure
08:36:52 <Giulia> I think its exclusive 
08:39:35 <Giulia> I'd love to tell you more @quchen but I'm really unsure about saying more over this channel 
08:39:48 <kosmikus> _sras_: have you been able to solve your generics problem?
08:48:37 <bonparaara> when using State, can I modify the state for just one call? like `withState`, but with an undo after the action?
08:48:48 <LordBrain> if you save it
08:48:51 <LordBrain> sure
08:49:16 <dysfun> any recommendation on what Random to use for generating secure random UUIDs?
08:49:20 <bonparaara> I just wrote a helper that does that, but it seems like something basic, so I assumed that something like that is probably already out there
08:49:45 <LordBrain> bonparaara, well you might be thinking of reader monad
08:51:44 <LordBrain> then again, there might be something already out there bonparaara specifically for MonadState monads, i'm unfamiliar if so.
08:51:59 <bonparaara> maybe, my use case is recursive descent through a data structure where I want to have the path to the current node available
08:52:26 <bonparaara> still small enough where having the path as an explicit parameter is not really ugly, but i never really used State much, so I thought why not try it out
08:57:02 <c_wraith> neither state nor reader is exactly what you want, but you can fake it with either.. 
08:57:25 <Vulume> @pl \xs n -> take n xs
08:57:25 <lambdabot> flip take
08:58:08 <Vulume> @pl \ds -> ds == nub ds
08:58:09 <lambdabot> ap (==) nub
08:58:29 <c_wraith> I guess Reader's local is pretty close to what you want 
08:58:59 <Vulume> @pl \f -> (ap (==) nub) (zipWith f xs ns)
08:58:59 <lambdabot> ap (==) nub . flip (flip zipWith xs) ns
08:59:19 <LordBrain> could call your helper localState
08:59:55 <_sras_> kosmikus: No. :(
09:00:07 <ski> bonparaara : are you sure you need to get the updated state after an action ?
09:00:09 <Vulume> @pl \ds -> nub ds == ds
09:00:09 <lambdabot> (==) =<< nub
09:00:39 <LordBrain> if you dont run 'put' after the action, state disnt updated anyway
09:00:40 <byorgey> bonparaara: you want Reader.  Using the 'local' function this does exactly what you want.
09:00:53 * ski thinks it sounds like they want `local' and `Reader'
09:01:16 <LordBrain> well he might need it to be State in other parts of the program tho
09:01:25 <ski> yes .. hence my question
09:02:29 <bonparaara> yep, I definitely want local and maybe Reader is a good fit there
09:03:01 <byorgey> bonparaara: here's an example of this kind of style: https://github.com/disco-lang/disco/blob/master/src/Disco/Typecheck.hs  see especially the definition of TCM, extend, and extends
09:03:05 <bonparaara> true, with nested 'local
09:03:23 <bonparaara> nested 'local'-calls I get the behaviour I want
09:03:31 <ski> good
09:04:48 <bonparaara> thanks for the help guys :)
09:06:33 <bonparaara> as for the helper I used before: \f m = do s <- get; result <- withState f m; put s; return result;
09:06:46 <bonparaara> what's very ugly about this is that it has the same signature as withState
09:20:45 <kosmikus> _sras_: I'm willing to help, if you can explain to me what the problem is.
09:21:05 <kosmikus> _sras_: but I also have to leave for dinner in a few minutes. (but I'll be back later)
09:21:53 <kosmikus> _sras_: I've looked at your original paste. So this code compiles, but you say it's broken. what's the desired behaviour?
09:33:05 <Jinixt> what does it mean when there's a Constructor{} in a pattern matching?
09:34:28 <byorgey> Jinixt: it matches any value with that constructor, regardless of its arguments
09:34:42 <Jinixt> oh god damnit i've been wanting that for ages
09:34:47 <byorgey> i.e. it's like matching on  (Constructor _ _ _)  for however many _'s you need
09:34:52 <Jinixt> thanks
09:34:57 <byorgey> (it does this by abusing record pattern-matching syntax)
09:41:04 <geekosaur> it's not abuse when it's explicitly sanctioned by the Report :)
09:41:29 <geekosaur> (in particular, the Constructor{} syntax is explicitly available even when the constructor was not defined with record syntax)
09:43:03 <sproingie> NamedFieldPuns is nice to have too.  foo Constructor{bar,baz} = ...
09:44:36 <ondrejs> hello. Anyone using Liquid Haskell? I have GHC 8, LH works only with 7.10. However when importing a lib like GHC.Reals I think it tries to match the spec against GHC 8 version. Can I somehow tell it where to look for GHC libs?
09:45:30 <ondrejs> I have both GHC 7.10 and 8 installed with stack, but 8 is default (I suppose this is determined by my global config lts version)
09:46:29 <Jinixt> sproingie: how is that different from foo (Constructor bar baz)?
09:46:53 <sproingie> comes in handy when you only want a few out of a dozen fields
09:47:10 <Jinixt> but it has to be the first in order?
09:47:24 <sproingie> any order, does have to be declared as a record of course
09:47:25 <torstein> In regards to the blogpost 'typing the technical interview'... How does this work? instance (ListConcat as bs cs) => ListConcat (Cons a as) bs (Cons a cs)
09:47:51 <Jinixt> so wait, is bar and baz the record names or the names you give the values?
09:47:58 <sproingie> both!
09:48:13 <Jinixt> so it shadows i suppose
09:48:32 <sproingie> Foo{a,b} is short for Foo{a=a,b=b}
09:48:47 <mniip> that's what the "puns" means
09:48:48 <sproingie> works in pattern matching and updates both
09:48:56 <Jinixt> oh
09:49:12 <glguy> torstein: Maybe you can be more specific in your question, why shouldn't it work?
09:49:41 <kosmikus> or Foo{..} with RecordWildCards. although I guess that's a bit more controversial, because it brings "random" names into scope.
09:49:53 <torstein> glguy, I don't understand how that line concat's two lists by itself
09:50:00 <mniip> it doesn't
09:50:09 <sproingie> kosmikus: wildcards don't work in pattern matches
09:50:11 <mniip> you need 'instance ListConcat Nil bs bs'
09:50:30 <kosmikus> sproingie: they do, or I'm misunderstanding what you're saying
09:50:51 <sproingie> foo Bar{..} = show baz
09:51:05 <kosmikus> sproingie: that works
09:51:11 <torstein> mniip, yeah there's that line too. So does i pattern match on left or right side of => ?
09:51:14 <sproingie> oh hm nevermind i was typoing the damn thing every time
09:51:15 <torstein> it*
09:51:21 <kosmikus> sproingie: :)
09:51:23 <niez> I like Foo{..}, very handy sometimes
09:51:40 <kosmikus> niez: yes, I like it too. although I think it's a bit evil.
09:51:46 <mniip> torstein, first the instance head is matched, then the context is applied
09:51:59 <_sras_> kosmikus: Around?
09:52:03 <niez> kosmikus, why it is considered evil?
09:52:13 <sproingie> yah i'd generally want to make the names brought into scope explicit.  but i guess sometimes they're obvious
09:52:21 <kosmikus> _sras_: I am for the moment. Will have to leave again at some point soon for 15-30 minutes.
09:52:27 <EvanR> Foo{..} reminds me of PHP extract
09:52:35 <pikajude> :')
09:52:42 <kosmikus> niez: as I said, because it's not easy to see what names it introduces
09:52:58 <kosmikus> niez: so in particular if it leads to shadowing of other names that are in scope, it can be quite confusing
09:53:43 <sproingie> making some progress on my strongly typed D20 rules now
09:53:46 <_sras_> kosmikus: Ok. No problem. To answer your question, the problem with the code is that I cannot get the field names to match with the corresponding `Forms`...
09:54:07 <EvanR> sproingie: dependently typed?
09:54:20 <kosmikus> sproingie: heh, sounds interesting
09:54:22 <sproingie> EvanR: god no, i've no idea how to do that
09:54:30 <EvanR> heh
09:54:31 <niez> ok, I see, is it somewhat releated to importing stuff? is it considered evil to import implicit everything from a module? like 'import COntriol.Monad' ?
09:54:50 <sproingie> https://gist.github.com/chuckadams/e5ccd9e92b0c9c7c64d3e93a805a0024
09:54:56 <kosmikus> _sras_: do you have some example code that demonstrates the problem?
09:55:24 <sproingie> the design so far.  Caster is a hack til i figure out how to assemble all this later
09:55:27 <kosmikus> _sras_: I mean, given the code you pasted, an expression that yields one result where you want another?
09:56:42 <kosmikus> sproingie: reminds me of my library that implements quite a few of the Ars Magica rules, for an IRC bot
09:58:15 <_sras_> kosmikus: Yes
09:58:22 <kosmikus> _sras_: the thing is, I'm quite familiar with generics, but not with digestive-functors
09:59:22 <lazersmoke-w> It turns out you can fork free monads if it makes sense for your effect by "commuting" the effect outside of the typeindexed coproduct bit and into an actual value https://gist.github.com/Lazersmoke/d49ea7f7d715ac5d51d0b15afb229cc3
10:00:31 <EvanR> im forking free monads right now
10:00:39 <EvanR> didnt know it was that sophisticated!
10:03:08 <fragamus> https://hackage.haskell.org/package/pipes-4.3.3/docs/Pipes-Core.html#v:-62--43--62-
10:04:07 <fragamus> When I read about >~> in that page, it has a diagram which seems inaccurate based on my experience
10:04:08 <_sras_> kosmikus: I don't think you need to know about digestive-functors. Please take a look here. http://lpaste.net/355042, You can see how I am trying to get the fields names corresponding to `r` and `s` in `r :*: s`. The problem is that `r` and `s` can be nested and I cannot find a way to make it work for such cases..
10:05:40 <kosmikus> _sras_: I see
10:06:57 <fragamus> this is my example which seems to show that the data flow diagram is inaccurate
10:07:01 <fragamus> https://gist.github.com/fragamus/3cc5ab02a9ea89c42111ed7069d7e53b
10:10:26 <fragamus> it seems like the first data in "middle" comes from the function argument but the diagram implies it doesn't
10:15:55 <fragamus> anybody out there experienced with pipes
10:16:10 <kosmikus> _sras_: so I think you need to decouple the fieldName access from the product instance
10:16:16 <kosmikus> _sras_: let me prepare a paste
10:17:57 <_sras_> kosmikus: Yes. Thank you.
10:18:02 <kosmikus> _sras_: https://gist.github.com/kosmikus/33a1a7daa7f9dc8c51425e784d1c3063
10:19:05 <_sras_> kosmikus: Yes. Let me see...
10:23:59 <_sras_> kosmikus: Works!
10:25:10 <kosmikus> _sras_: ok, glad to hear it. I'll also try to produce a version using generics-sop for this, then you can compare the two. [because in principle, I agree that generics-sop is nicer to work with in most cases.]
10:29:30 <_sras_> kosmikus: I have lost last couple of days sleep over this. If it weren't for you, it would have been the same today  :)  So a big thank you! Now let me try to figure out what I was doing wrong...
10:32:12 <_sras_> kosmikus: I grappled a lot with `symbolVal` earlier today. Couldn't get it to work...Basically I didn't think I could implement an instance for MetaX like this. Can you tell me how the overlapping of instances work?
10:45:18 <kosmikus> _sras_: the general M1 instance and the specific S1 instance overlap, but because the S1 instance is strictly more specific, it takes precedence.
10:46:31 <_sras_> kosmikus: Specific, becuase of the constraints?
10:46:51 <kosmikus> _sras_: if you don't like overlapping instances, you can also define two instances for D1 and C1 instead.
10:47:08 <kosmikus> _sras_: no, the constraints are irrelevant for determining how specific an instance is.
10:48:55 <ondrejs> hello, can anyone please point me to an explanation of the meaning of the sharp symbols here? https://www.stackage.org/haddock/lts-8.9/base-4.9.1.0/src/GHC-Char.html#chr
10:49:52 <LordBrain> usually # means unlifted, but thats a convention is my understanding, it is just a regular identifier symbol
10:50:08 <kosmikus> _sras_: but the general instance is for "M1 i a r", and the more specific instance is for "M1 S (MetaSel ...) r"
10:50:12 <MarcelineVQ> ondrejs: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-magic-hash
10:50:14 <LordBrain> page is not loading for me
10:50:31 <_sras_> kosmikus: Yes,
10:51:02 <ondrejs> LordBrain, MarcelineVQ: oh, missed that in the header. Thank you
10:51:41 <kosmikus> _sras_: so if one of two matching overlapping instances is strictly more specific than the other, it "wins"
10:52:08 <lyxia> fragamus: I think it's more likely you're giving a meaning to the diagram that it doesn't have
10:52:15 <kosmikus> _sras_: that's why it works; but as I said, you can also replace the general M1 instance by two instances, one for "M1 D a r" and "M1 C a r", both with the same definition
10:52:23 <kosmikus> _sras_: then you don't need the overlapping instances
10:52:32 <LordBrain> typically, # types are strict, and are stored without any pointer to dereference
10:53:05 <lyxia> fragamus: but I don't understand what you find to be unexpected about this
10:53:14 <fragamus> lyxia: no it is the same diagram for >+>
10:54:12 <fragamus> the unexpected behavior is that the function on the right side of the >~> is receiving all of its data from the function argument and none of it from await
10:54:12 <lyxia> it's not
10:57:13 <lyxia> fragamus: does that mean the rightward arrow labelled with b should also feed into the input of g at the top ?
10:59:10 <lyxia> It doesn't sound like such a big deal, the argument of g has to come from somewhere, and there is only one place where it can come from...
11:21:10 <talet> Anyone familiar with accelerate? I have an implementation of the game of life using it, but it seems slower than it should be. My repa implementation was a little more than twice as fast, and using nvprof on the accelerate code shows 89% of the time is spent executing the generate function
11:30:01 <actualHuman_462> Hiya folks - Running windows 7, trying to build a haskell-gi package with stack. stack ghci works fine if executed from the shell launched by 'stack exec bash'. 'stack build' fails from any environment, with an error about missing routines in libcairo dlls. Anyone have any suggestions about where to start troubleshooting this?
11:30:21 <MitchellSalad> is there a reason why 'sameMutVar#' does not have type 'MutVar# s a -> MutVar# s b -> Int#'?
11:30:29 <MitchellSalad> it instead takes two 'MutVar# s a'
11:32:02 <MitchellSalad> i thinketh not, just checked the ghc source
11:39:15 <kosmikus> @tell _sras_ generics-sop-based solution for your problem: https://gist.github.com/kosmikus/3b88af208827db3c1bf413fc40aa4fc8
11:39:15 <lambdabot> Consider it noted.
11:53:46 <torstein> is it possible to import something like a type level prelude?
11:56:26 <geekosaur> I don't think there is one. I'm not sure there can be one without a bunch more plugins like http://hackage.haskell.org/package/ghc-typelits-natnormalise
11:57:16 <MarcelineVQ> the singletons package has quite a lot of type level prelude things, dunno if it's what you're looking for
11:59:33 <torstein> MarcelineVQ, seems perfect thx
12:19:42 <AaronFriel> Is my Haskell project Web Scale yet? "Result size of Tidy Core  = {terms: 2,122, types: 963,728, coercions: 979,013}"
12:28:37 <actualHuman_462> does anyone know what 'stack exec bash' actually -does- on windows? I can't seem to find any documentation on how it decides what to launch
12:31:20 <sm> maybe 'stack exec which bash' helps ?
12:36:25 <actualHuman_462> sm you're the best, yes, that does help
12:37:05 <ephemeral> why does `last [1..99999999999999999999]` take such a long time to evaluate?
12:37:16 <ephemeral> I thought GHC was smart ;D
12:37:21 <kadoban> xD
12:37:44 <ezyang> in principle, you could add a REWRITE rule which would ge tthis correct 
12:38:40 <ephemeral> what's that?
12:38:51 <ephemeral> I'm a total noob fwiw
12:39:10 <AaronFriel> ezyang: alternatively, you need to describe [1..x] in terms of more informative types which allow you to know the upper bound, and then implement "last" using "IfCxt"
12:40:02 <AaronFriel> ephemeral: A rewrite rule does what it says on the tin: you tell the compiler, "Hey, when you see __this__, replace it with __that__", where the burden is on you to know that the rule is correct.
12:40:17 <torstein> How to do lists with Singletons? This gives a kind error ([E00] != Nat): data Game = Game Nat (SList Nat)
12:40:42 <AaronFriel> torstein: You can't encode "nats" directly in singletons right now.
12:41:31 <AaronFriel> torstein: Use `data Game' n = Game n [n]`, and then outside of the $(singletons) declaration use `type Game = Game Nat`
12:41:32 <sm> ephemeral: List is an inherently inefficient data structure for accessing the last elements, there are alternative types that work better for that
12:41:57 <AaronFriel> torstein: Sorry,`type Game = Game' Nat`
12:42:53 <ephemeral> heh, sounds pretty ad hoc
12:43:03 <AaronFriel> ephemeral: ad hoc how?
12:43:14 <shapr> ezyang: oh hey, do I need to get credentials or anything from you for taking over TMR?
12:43:23 <shapr> ezyang: want to write an article? ;-)
12:43:32 <torstein> AaronFriel, can I put my own data structures inside an SList? E.g. a list of: data Cell = A | B | E
12:43:32 <actualHuman_462> ephemeral - Lists are sort of weird. They're more like a control structure than a general array type. Think of it as a way to abstract 'lazily' iterating over x things rather than as an array or list. I'd recommend using the Data.Sequence type if you're a total beginner, it has the easiest docs to understand.
12:43:37 <ephemeral> uh, as in the meaning of the term ad hoc? :P
12:43:44 <ezyang> yes, let me handle that tonight 
12:44:00 <AaronFriel> @torstein Yes, but if you're promoting things with singletons don't use SList in the declaration.
12:44:00 <lambdabot> Unknown command, try @list
12:44:02 <actualHuman_462> Data.Vector is probably the best for performance use-cases, but Sequences have friendly docs
12:44:11 <ephemeral> anyway, I'm just running through the real world haskell, finally a period of my life in which I have enough mental clarity and focus to actually comprehend it
12:44:16 <AaronFriel> @ephemeral 
12:44:16 <lambdabot> Unknown command, try @list
12:44:30 <ephemeral> marvel at the wondrous `lastButOne`-function:
12:44:31 <AaronFriel> Oops, ephemeral: Lists in Haskell are linked lists.
12:44:32 <ephemeral> lastButOne :: [a] -> a
12:44:32 <ephemeral> lastButOne xs = if length xs == 2
12:44:32 <ephemeral>                 then head xs
12:44:32 <ephemeral>                 else lastButOne $ tail xs
12:44:43 <ephemeral> such effective, much wow
12:45:01 <AaronFriel> What happens if you call lastButOne [1]?
12:45:07 <ephemeral> crash
12:45:11 <AaronFriel> That's not good
12:45:14 <ephemeral> well
12:45:25 <ephemeral> in-built last-function crashes on empty lists as well though
12:45:39 <AaronFriel> True, that's also not good :)
12:46:24 <AaronFriel> We're just stuck with it because of backwards compatibility (and ugly types/bending over backwards... that should improve some day.)
12:46:45 <ephemeral> you mean it should return something like Nothing?
12:47:10 <AaronFriel> That sounds good
12:47:13 <sm> exactly, like lastMay in the safe package
12:47:26 <ephemeral> last :: [a] -> Maybe a
12:47:41 <AaronFriel> Now that looks like it could be a good function
12:47:42 <ephemeral> not a bad idea
12:49:31 <actualHuman_462> ephemeral - Something that took a while for me to pick up on - multiple function declarations to specify different patterns is a really useful tool for problems like this
12:49:35 <actualHuman_462> example
12:49:47 <actualHuman_462> head' [] = Nothing
12:49:51 <actualHuman_462> head' (x:xs) = Just x
12:50:18 <ephemeral> yeah, I just posted a function I wrote with three declarations, heh
12:50:33 <AaronFriel> Does this look like what you wrote?
12:50:33 <AaronFriel> sndToLast :: [a] -> Maybe a
12:50:33 <AaronFriel> sndToLast []   = Nothing
12:50:33 <AaronFriel> sndToLast [x1] = Nothing
12:50:33 <AaronFriel> sndToLast (x1:x2:xs) = case xs of
12:50:33 <AaronFriel>     [] -> Just x1
12:50:34 <AaronFriel>     _  -> sndToLast (x2:xs) 
12:50:37 <ephemeral> oh, nvm
12:50:47 <ephemeral> but yeah, I get it
12:51:33 <AaronFriel> That last definition could be split out into two definitions instead of using "case", as well. Just a matter of preference.
12:53:02 * ski would use an "as"-pattern there
12:53:21 <ski> (well, unless you prefer overlapping patterns)
12:53:44 <MarcelineVQ> could also reverse the list it for some terseness since you have to get to the end anyway
12:53:50 <MarcelineVQ> *the list for
12:53:59 <ephemeral> ok, how about this:
12:54:00 <ephemeral> lastButOne :: [a] -> Maybe a
12:54:00 <ephemeral> lastButOne [] = Nothing
12:54:00 <ephemeral> lastButOne x:xs = if null xs
12:54:00 <ephemeral>                   then Nothing
12:54:00 <ephemeral>                   else if length xs == 1
12:54:01 <ephemeral>                        then Just x
12:54:03 <ephemeral>                        else lastButOne xs
12:54:08 <ephemeral> except it gives me a parse error
12:54:09 <ski> missing pair of brackets
12:54:17 <Aeroxam> Hello ! I'm curious about something : why am I allowed to do this ?
12:54:20 <Aeroxam> http://lpaste.net/355044
12:54:20 <ski> `lastButOne x:xs' means `(lastButOne x):xs'
12:54:23 <AaronFriel> wrap your "x:xs" in parenthesis
12:54:33 <ephemeral> ah, thanks
12:54:35 <ski> also, don't use `length' like that
12:54:41 <ski> it's inefficient
12:54:53 <AaronFriel> ephemeral: you're doing work twice, is what ski means
12:55:00 <AaronFriel> Actually, possibly many more times
12:55:04 <ski> if the list is long, it'll still need to traverse it to the end, only to determine whether it had a single element or not
12:55:06 <kadoban> Aeroxam: Any particular part?
12:55:12 <ski> much more efficient to use pattern-matching
12:55:21 <AaronFriel> ephemeral: as a thought experiment, imagine you had a list that was infinitely long
12:55:27 <AaronFriel> ephemeral: how long will it take to compute "length"?
12:55:33 <ephemeral> haha
12:55:39 <ski> > length [0 ..] == 1
12:55:44 <ephemeral> I know it's super inefficient guys, even though I'm a noob
12:55:45 <lambdabot>  mueval-core: Time limit exceeded
12:55:54 <AaronFriel> ^ it takes longer than time limit ;)
12:56:00 <ski> > case [0 ..] of [_] -> True; [] -> False; _:_:_ -> False
12:56:02 <lambdabot>  False
12:56:05 <Aeroxam> but not this : http://lpaste.net/355045
12:56:17 <Aeroxam> kadoban : yeah, last line.
12:57:05 <kadoban> Oh. Because sometimes recursive definitions make sense. That one doesn't seem like it does though
12:57:13 <ephemeral> ah
12:57:14 <ephemeral> so
12:57:50 <Aeroxam> I mean I didn't expect it to be allowed in the first one
12:58:11 <ephemeral> nvm, I get the idea, but need to think
12:58:15 <Aeroxam> is GHC "getting" that it won't ever have to evaluate it so it doesn't care ?
12:58:41 <Aeroxam> and if that's it, why does he bugger me in the second case ?
12:58:44 <Aeroxam> "he"
12:58:45 <ski> Aeroxam : sometimes "tying the knot" like that can be useful ..
12:59:02 <kadoban> Aeroxam: Are you just talking about the recursive definition of 'o' there?
12:59:43 <ski> > let x = 0 : y; y = 1 : x in x
12:59:45 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
13:00:31 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs  -- a traditional one
13:00:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:00:52 <ski> Aeroxam : can you figure out how that one works ?
13:01:22 <Aeroxam> Wew one minute lemme try to wrap my head around that
13:02:49 <Aeroxam> yep
13:02:53 <Aeroxam> I got it
13:04:17 <ephemeral> ok, I've got a definition now
13:04:37 <ephemeral> get an error for null list though :/
13:04:43 <Tuplanolla> > fix $ (0 :) . (1 :) . (zipWith (+) <*> tail) -- Have a better variation, Aeroxam.
13:04:45 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:04:54 <ephemeral> should I paste it in a separate paste, or are small functions fine in here?
13:05:10 <Aeroxam> kadoban : Yes. i'm basically trying to get a list of n "results" after a coroutine or a modstream (coroutine with same type of i and o) while disregarding the input. I wonder why I was allowed to do it for the ModStream and not for the Coroutine, I had to do this for the Coroutine : http://lpaste.net/355046
13:05:18 <Tuplanolla> (By better I mean more confusing.)
13:05:27 <ski> > let fibs = listArray (0,12) [case n of 0 -> 0; 1 -> 1; _ -> fibs ! (n-1) + fibs ! (n-2) | n <- range (0,12)] in fibs ! 12
13:05:30 <lambdabot>  144
13:05:34 <ski> Aeroxam : and that one ^ ?
13:05:52 <ski> @quote aztec
13:05:52 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
13:05:57 <ephemeral> http://lpaste.net/355047
13:06:15 <Aeroxam> basically I'm treating them as streams when the input doesn't matter, and I wonder why the trick of 'tying the knot' works for one and not the other.
13:06:24 <ski> ephemeral : annotate the original paste with updates, if you have one
13:06:33 <ephemeral> huh?
13:06:52 <ski> there's an "Annotate" button on LPaste
13:06:54 <Aeroxam> Tuplanolla: whoah hm what is '<*>' ?
13:07:08 <ephemeral> that's the first paste I've ever posted though
13:07:08 <ski> it will add your annotation to the existing paste page
13:07:13 <ski> ok
13:07:26 <ski> (that's wasn't clear to me)
13:07:27 <Tuplanolla> It's the `Applicative` instance for `(->) a`, Aeroxam.
13:07:44 <ephemeral> I get this though: Ambiguous type variable ‘a0’ arising from a use of ‘show’
13:07:44 <ephemeral>       prevents the constraint ‘(Show a0)’ from being solved.
13:07:49 <ski> (if you select the channel, then lpaste will itself announce the paste in here, btw)
13:07:55 <ephemeral> for an empty list
13:08:13 <ephemeral> right, I thought I marked for that, soI was kinda expecting it to do so, but didn't happen apparently :O
13:08:19 <ephemeral> or maybe I have to specify my nick as author?
13:08:44 <Aeroxam_> ski: I never tried to use arrays with haskell yet.. but I think I get the general idea even if I don't get the typeflow 
13:10:27 <ski> Aeroxam_ : the interesting thing here is that this (immutable, in this case) array is defined recursively. but the elements are lazily computed, so only the elements that actually need to be computed to determine the element you're accessing will actually be computed. in this case, all elements are computed, but one can often use this idea to code up dynamic programming algorithms in a nice way
13:11:30 <ski> Aeroxam_ : this would be top-down dynamic programming, as opposed to bottom-up, since demand is driving the computation from "top", rather than manually having to schedule the computation from the bottom (as you would do in a language with strict evaluation)
13:13:01 <Aeroxam> re. net hiccups
13:13:03 <ski> ephemeral : `xs' in your last defining equation must always be `[]'
13:14:00 <ephemeral> what if it has exactly two elements?
13:14:06 <ephemeral> ah
13:14:20 <ski> then the middle defining equation is used, with `xs' being `[]'
13:14:21 <ephemeral> I mean, what if it has one element
13:14:31 <ski> i'd use pattern-matching rather than `null' there
13:14:54 <ski> neither of the first two cases will match a singleton list. leaving the last case, which gives `xs = []'
13:15:52 <ski> (and, as i said, this is the only way that case can be reached, so it would be less confusing for a reader to write `[]' instead of `xs' there)
13:16:04 <ski> (or, simply, instead of `x:[]', one can of course write `[x]')
13:16:08 <ephemeral> ah, I understand
13:16:50 <ephemeral> what did you mean about using pattern matching instead of null, though?
13:18:42 <ephemeral> or maybe that's what you were referring to
13:18:49 <ephemeral> [] being null
13:19:40 <lpaste> ephemeral annotated “lastButOne” with “lastButOne (annotation)” at http://lpaste.net/355047#a355048
13:20:16 <ephemeral> I still get the same error when trying to pass it an empty list though
13:20:48 <ephemeral> seems to be a problem with show though, since I'm using it to print out the result
13:21:12 <ski> well, that's not a problem with `lastButOne'
13:21:29 <ski> that's GHCi not knowing what kind of list elements you want
13:21:50 <ski> try adding a type ascription like `:: Maybe [Integer]' after the call
13:21:56 <ski> anyway, instead of
13:22:06 <ski>   lastButOne (x:x':xs) = if null xs then ... else ...
13:22:08 <ski> you could say
13:22:24 <ski>   lastButOne [x,x'] = ...
13:22:35 <ski>   lastButOne (x:x':xs) = ...
13:22:53 <ski> splitting the two `if' branches onto separate defining equations
13:23:20 <ephemeral> right, of course
13:24:11 <ephemeral> what about the naming convention, is it normal to use x and x' like that there?
13:24:40 <ephemeral> what if I wanted another element, or even 4, x:x':x'':x''' looks kind of ugly
13:25:19 <MonadHendrix> shoutout to atan2 for being better than atan
13:25:26 <ephemeral> I suppose I could do `lastButOne (_:x:xs) = lastButOne (x:xs)` in this specific case though
13:25:49 <geekosaur> at some point on e usually nmoves to x0:x1:x2:...
13:26:01 <geekosaur> since it gets hard to count primes and it's typo-prone
13:26:51 <lpaste> ephemeral annotated “lastButOne” with “lastButOne (annotation) (annotation)” at http://lpaste.net/355047#a355049
13:27:18 <ephemeral> I thought that was nice, but now "pattern match is redundant" apparently
13:27:23 <ski> ephemeral : i'd often use `x0:x1:x2:xs' in such cases
13:27:34 <ephemeral> yeah, that sounds better
13:27:44 <ski> some people like it like `x:y:z:xs' or something
13:28:18 <ephemeral> right; why does it tell me that "pattern match is redundant" now though, pointing to the last pattern?
13:28:27 <ski> ephemeral : yes `x:xs' overlaps with `_:x:xs'. the latter will never be reached
13:28:47 <ephemeral> hmm
13:29:02 <geekosaur> swap them?
13:29:23 * ski generally prefers to not have overlapping patterns at all, when reasonable
13:29:45 <ephemeral> how about: lastButOne [x, _] = Just x
13:29:55 <ski> that's better :)
13:30:05 <ski> gets rid of the overlapping, so that ordering doesn't matter
13:30:22 <ephemeral> sweet; now what was that about the show function and the error on the empty list?
13:30:59 <ski> (iow, so that each defining equation can be understood in isolation, as a true thing to say about the function, without having to pay heed to the context (the preceding defining equations))
13:31:03 <lpaste> ephemeral annotated “lastButOne” with “lastButOne (annotation) (annotation) (annotation)” at http://lpaste.net/355047#a355050
13:31:08 <ephemeral> that's the final version btw
13:31:28 <ephemeral> yeah, agree that that's much nicer
13:31:32 <ski> the last defining equation could be written
13:31:41 <ski>   lastButOne (x:xs@(_:_)) = lastButOne xs
13:31:56 <ski> makes it more explicit that we know that `xs' will be a non-empty list here
13:31:59 <ski> this is the same as
13:32:10 <ski>   lastButOne (x0:x1:xs) = lastButOne (x1:xs)
13:32:51 <ski> except that using an "as"-pattern (the `xs@(_:_)') gives a strong hint to the implementation that it shouldn't allocate a new cons `x1:xs'
13:33:07 <ephemeral> ok, that went way over my head
13:34:01 <ski> an "as"-pattern is of the shape `<variable> @ <pattern>', it's "both eating the cake and having it". both giving a name to the value in that position, and also matching that value further with the pattern
13:34:22 <ski> > let xs0@(x:xs) [0,1,2] in (xs0,x,xs)
13:34:24 <lambdabot>  <hint>:1:24: error: parse error on input ‘in’
13:34:31 <ski> er, missing `=' :)
13:34:34 <ski> > let xs0@(x:xs) = [0,1,2] in (xs0,x,xs)
13:34:36 <lambdabot>  ([0,1,2],0,[1,2])
13:34:56 <ski> `xs0' is the whole thing, `x' is the first element, `xs' is the list of the remaining elements
13:35:00 <ski> (the tail)
13:36:52 * ski looks at ephemeral
13:36:58 * ephemeral is thinking
13:37:25 <ephemeral> so
13:38:32 <ephemeral> if the @ is 'as', I still don't get how (x:xs@(_:_)) makes sense
13:39:00 <ski> `x:xs@(_:_)' is parsed as `x:(xs@(_:_))'
13:39:35 <ephemeral> isn't that then parsed as x:(x:(xs@(_:_))) and so on?
13:39:50 <ski> so, to match, the input must be a non-empty list, and the first element (the head) must match with `x' (and it does, because a variable pattern like `x' matches anything, and in the process binding the variable `x' to that value, the head element of the list)
13:40:03 <kadoban> ephemeral: I think you're attributing more magic to @ than exists
13:40:04 <ephemeral> oh, nvm, disregard that last thing I said
13:40:11 <ephemeral> haha, yeah
13:40:37 <ephemeral> right, when it's parsed that way, I get it
13:40:44 <ski> further, the tail of the list must match `xs@(_:_)' .. since this is an "as"-pattern, this value (the tail) is given the name `xs' (`xs' is bound to the tail value)
13:40:56 <ski> and further, the tail value is *also* matched with `_:_'
13:41:30 <ski> which only works if the tail is a non-empty list, with first element (second element of the original list) matching `_', and list of remaining elements (after those two) matching `_'
13:41:32 <ephemeral> x:xs also needs a non-empty list to match, though?
13:42:19 <kadoban> Yep, there has to be a (:) to match on, so it's got to be non-empty
13:42:21 <ski> but `_' matches anything (and doesn't bind a variable in the process). `_' is sometimes known as the "wildcard" pattern, or the "anonymous" pattern (acting "like an anonymous variable", a new one each time it is used)
13:42:34 <ski> ephemeral, aye
13:42:38 <ephemeral> yeah, I know that
13:42:58 <ski> you can't actually write a "non-linear" pattern like `x:x:...', repeating the same variable name `x' in it
13:43:08 <ski> (but you can repeat `_' as many times as you like in a pattern)
13:44:24 <ephemeral> in this case though, since we not only want to make it clear that xs is not empty, but never even consists of just 1 element, would it be even better to write it as (x:xs@(_:_:_))? :P
13:44:38 <ski> (in some other programming languages with pattern-matching, you can actually write "non-linear" patterns, even match on the value in a previously bound variable)
13:45:09 <ephemeral> that doesn't sound very orderly
13:45:13 <ski> ephemeral : well, that would require it to have at least *three* elements ..
13:45:42 <ski> (think about it. each `:' corresponds to a cons cell, with an element, and a tail)
13:46:16 <ephemeral> right, right, it's me thinking wrong
13:46:19 <ephemeral> I get it
13:46:27 <ski> hm
13:46:52 <ephemeral> no
13:46:53 <ski> oh, you're right
13:46:58 <ephemeral> yeah, haha
13:47:00 <ski> (and i as well)
13:47:11 <actualHuman_462> Depends on whether or not you consider [] to be an element
13:47:21 <ski> one case of zero elements, one for one element, one for two elements, and one for at least three elements
13:47:29 <ski> yeah, that works fine
13:47:30 <ephemeral> right
13:48:09 <ephemeral> so...how about that error caused by show?
13:48:23 <ephemeral> I don't really get it, since it shows Nothing just fine
13:48:25 <ski> could you repeat the error, and what you did to provoke it ?
13:48:35 * ski possibly misunderstood the situation ..
13:48:44 <ephemeral> right, I'll put up a snippet with the code and the error
13:48:50 <ski> *nod*
13:49:41 <lpaste> ephemeral annotated “lastButOne” with “realworld.hs” at http://lpaste.net/355047#a355051
13:50:14 <ski> (btw, if you're in a situation where you want a non-linear pattern in Haskell, then you usually have to add a guard with an `==' check between the parts you want to check are equal)
13:50:35 <ski> @src print
13:50:35 <lambdabot> print x = putStrLn (show x)
13:50:48 <ephemeral> what's a non-linear pattern?
13:50:59 <actualHuman_462> The show thing
13:51:01 <ski> <ski> you can't actually write a "non-linear" pattern like `x:x:...', repeating the same variable name `x' in it
13:51:20 <Gurkenglas> ephemeral, it doesn't know what the a is in "show ([] :: [a])"
13:51:22 <actualHuman_462> You call show on a variable, which implies that it must implement an instance declaration for show
13:51:29 <ephemeral> also I remember guards briefly from previously going through real world haskell and other sources, but haven't comprehended it just yet, seem to recall it being a simple concept though
13:51:38 <Gurkenglas> So it doesn't know whether it should show all the elements of [] as Ints or as Strings or what
13:51:54 <actualHuman_462> Using a type variable without a constraint means 'This function should work for literally everything'
13:51:58 <geekosaur> worth noting here is that error doesn't happen in ghci because of ExtendedDefaultRules, so it picks ()
13:52:05 <Gurkenglas> If you add l :: [Int] before that l = [] line that should work
13:52:11 <ephemeral> but I never tell it to show any list
13:52:23 <ski> ephemeral : if you add a monomorphic type signature for `l', or type ascription for the use of `l', or the call to `lastButOne', in `main', that should do it
13:52:49 <Gurkenglas> ephemeral, right, you turn the [a] into Maybe a, meaning that instead you have "show (Nothing :: Maybe a)" for exactly the same problem
13:52:52 <ephemeral> yeah, that does fix it
13:53:02 <ski> geekosaur : yeah, i momentarily forgot that this wasn't an issue in the interactor anymore ..
13:53:02 <actualHuman_462> GHC isn't erroring because of what it's being passed, it's erroring because of what it COULD be passed
13:53:03 <ephemeral> ah
13:53:10 <ephemeral> right, yeah
13:53:39 <ski>   main = print (lastButOne l :: Maybe Integer)
13:53:41 <ski> would work
13:53:49 <ski> (that's a type ascription)
13:53:54 <Gurkenglas> (Does defer type errors make this work?)
13:54:12 <ski> Gurkenglas : i suspect not, but i don't know
13:54:37 <geekosaur> defer type errors just causes that call to resolve to one to error
13:54:44 <ski> (it's not a type inconsistency. it's an ambiguity)
13:55:21 <Gurkenglas> Is there a way to make this work because there isn't actually any a to call show on?
13:55:53 <geekosaur> do you know how typeclasses are implemented? if you do, think about it a bit
13:56:08 <ski> perhaps `-fdefer-type-errors' could spoof a `Show' instance for the skolem `a' ..
13:56:36 <geekosaur> regardless of what's going on, it needs to be passed a function pointer for the Show instance method, and the compiler has no clue which pointer to give it
13:56:36 <ski> (well, treating it as one, i mean)
13:56:57 <Gurkenglas> geekosaur, give it a call to error?
13:57:10 <geekosaur> that's what defer type errors does in this case
13:57:15 <Gurkenglas> (If you mean the a one, not the [a] one)
13:57:23 <geekosaur> uh
13:57:32 <geekosaur> there;s actually no difference here, I think
13:57:33 <ephemeral> alright people, thanks for all the help so far; now over to something even more challenging; I just checked the source for `lastMay`: liftMay null last
13:57:57 <geekosaur> since the [a] one immediately resolves to showList @a
13:58:15 <ephemeral> I've read vaguely about various forms of lift being functions to transform things into monads, in this case the Maybe monad I suppose, but don't really comprehend it
13:58:31 <Gurkenglas> We have an instance with the head [a] (instances not overlapping helps us here), you just pass it the pointer to the [a] instance and when that one says it actually needs a Show a instance then you pass that the call to error because theres no fully general instance
13:58:33 <ski> ephemeral : looks like it just checks `null' and then calls `last' if negative. wrapping results in `Maybe'
13:58:33 <kadoban> ephemeral: It's probably just a helper function defined somewhere in there
13:59:06 <MarcelineVQ> it's just a helper function from a module that isn't publicly exported https://hackage.haskell.org/package/safe-0.3.14/src/Safe/Util.hs
13:59:25 <ski> looks like `liftMay :: (a -> Bool) -> (a -> b) -> (a -> Maybe b)' if my internal type inferencer is working properly
13:59:42 <ephemeral> liftMay :: (a -> b) -> (a -> Bool) -> (a -> Maybe b)
13:59:42 <ephemeral> liftMay func test val = if test val then Nothing else Just $ func val
13:59:49 <ephemeral> sick skills
13:59:49 <ski> right
14:00:25 <ski> note the nice "ambiguity" there regarding whether it accepts two or three arguments
14:00:59 <ski> (compare the type signature with the definiendum, what's to the left of the `=')
14:01:42 <ephemeral> yeah, it looks like it takes three arguments to me :P
14:01:50 <ski>   liftMay :: (a -> b) -> (a -> Bool) -> (a -> Maybe b)
14:01:53 <ephemeral> yeah
14:01:53 <ski> is the same thing as
14:01:56 <ski>   liftMay :: (a -> b) -> (a -> Bool) -> a -> Maybe b
14:02:03 <ski> (`->' is right-associative)
14:02:06 <ephemeral> right, currying
14:02:22 <sproingie> though you're usually interested in the (a -> Maybe b) as the returned value, being lift and all
14:02:27 <ski> also, `liftMay func test val' is the same thing as `(liftMay func test) val' is the same thing as `((liftMay func) test) val'
14:02:36 <ski> (application is left-associative)
14:02:41 <ephemeral> so if I gave it 4 arguments, it would treat it like liftMay :: (a -> b) -> a -> Bool -> a -> Maybe b?
14:02:51 <ski> `liftMay' is written in "curried style", yes
14:03:11 <ski> no, you can't remove brackets to the left of `->' like that
14:03:19 <ski> only to the right
14:03:30 <ski> `X -> Y -> Z' means `X -> (Y -> Z)'
14:03:41 <ski> `(X -> Y) -> Z' is something else. very different
14:03:55 <eq4life1581_> Hi
14:04:00 <Gurkenglas> uh guys its "(a -> Bool) -> (a -> b) -> (a -> Maybe b)" as ski first said
14:04:14 <ski> you couldn't pass four arguments ("curriedly") to `liftMay'. you'd get a type error
14:04:33 <ski> hello eq4life1581_
14:04:52 <eq4life1581_> Hi
14:05:01 <ephemeral> Gurkenglas: it had the type signature liftMay :: (a -> b) -> (a -> Bool) -> (a -> Maybe b) in the Safe library
14:05:13 <ski> note that : all functions in Haskell takes *exactly* one argument. no more and no less
14:05:22 <ephemeral> I mean, those are basically equivalent I guess, if it's the order you're talking about
14:05:22 <ski> (there is no such thing as a "nullary function")
14:05:33 <ephemeral> right
14:05:38 <Gurkenglas> ephemeral, let me go ahead and stick my neck out really far on this one so it can be cleanly chopped off
14:05:38 <sproingie> a nullary function is also known as a value
14:05:49 <ephemeral> creds to curry, whose first name gave us the name of this glorious language, praise be
14:05:53 <Gurkenglas> and say that youre wrong and its the other way :D
14:05:53 <ski> however, there's two common *conventions* for *encoding* multiple arguments : one is known as "curried style", and the other as "tupled style"
14:06:26 <ephemeral> Gurkenglas: I just c/ped from here: https://hackage.haskell.org/package/safe-0.3/docs/src/Safe.html
14:06:46 <sproingie> according to his widow, Haskell Curry never actually liked his first name
14:07:00 <ski> to *encode* a function `f' taking both an `A' and a `B', returning a `C', in the *curried* fashion, we do `f :: A -> (B -> C); f = \a -> \b -> ..a..b..'. the definition can be more prettily written as `f = \a b -> ..a..b..' or `f a = \b -> ..a..b..' or `f a b = ..a..b..'
14:07:05 <Gurkenglas> ephemeral, ah you're looking at an old version of safe
14:07:16 <Gurkenglas> http://hackage.haskell.org/package/safe-0.3.14/docs/src/Safe.html#lastMay https://hackage.haskell.org/package/safe-0.3.14/src/Safe/Util.hs
14:07:49 <ski> (and the type signature can then be more prettily written as `f :: A -> B -> C', because "curried style" is expected to be the common convention in Haskell. so this gets the nicer looking type signature)
14:08:17 <ski> to *encode* a function `f' taking both an `A' and a `B', returning a `C', in the *tupled* fashion, we do `f :: (A,B) -> C; f = \(a,b) -> ..a..b..'. the definition can be more prettily written as `f (a,b) = ..a..b..'
14:08:24 <ephemeral> ah, I found that first file where they used liftMay all over, but couldn't find that second file; I see now
14:08:31 <actualHuman_462> ski - I know that it's technically correct that there are no nullary functions, but isn't it kind of useful to think of some things that way? For example, getLine is a 'value' by that definition, but it's a value that has side effects...
14:08:37 <lpaste> KernelJ pasted “What makes this slow?” at http://lpaste.net/355053
14:08:42 <ephemeral> ski: going a bit too fast atm
14:08:53 <ski> (btw, functions are also values ..)
14:09:06 <ephemeral> yeah, functions as values is comprehended
14:09:28 <ski> @where haskel
14:09:28 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
14:10:10 <kadoban> actualHuman_462: Sounds like that'd be at best confusing. Maybe calling :: IO a   a "procedure" or something could make sense, but personally I wouldn't call it a function.
14:10:26 <Tuplanolla> I think it's more common to consider the isomorphism between `a` and `() -> a`, actualHuman_462.
14:10:26 <pikajude> IO a is kind * so it's a value
14:10:35 <ski> actualHuman_462 : there are no *side* effects in Haskell. there are effects, however. `getLine' is a value (often called an action, or an I/O action, or an `IO'-action), that *encodes* an effect
14:10:53 <ski> actualHuman_462 : just like a recipe encodes some actions to do with foodstuffs
14:11:12 <Aruro> there are no side effect in haskell, but haskell program can crash, so yeah.
14:11:21 <pikajude> what's the difference between IO a being a value that produces an a when run and a C program being a value that produces a side effect when compiled and run
14:11:28 <ski> i believe the technical term is "abort" ;)
14:11:35 <ephemeral> hah
14:11:37 <Aruro> haskell program as a part of a bigger program is pretty usual, can crash do whatever.
14:11:43 <kernelj_arch> anyone have a quick look at this it's only 16 lines? http://lpaste.net/355053
14:12:05 <ski> pikajude : the difference lies at the *language* level. not at the level of a compiled executable
14:12:06 <Aruro> haskell program in vacuum is indeed pure and perfect.
14:12:14 <pikajude> oh
14:12:18 <pikajude> what does that mean
14:12:25 <ski> pikajude : the difference lies in what *reasoning* laws apply at this language level
14:12:37 <sproingie> pikajude: C won't let you treat gets() as a value, whereas getLine returns an action and actually does nothing until the evaluator gets ahold of it
14:12:37 <pikajude> oh
14:12:49 <actualHuman_462> Yeah ok. There's no side effect, except for the part where the value that it resolves to is determined by something completely external to the system. I get that there is another context which you're using to define 'side effects', but I am skeptical as to whether or not that's a more useful paradigm.
14:12:53 <pikajude> sproingie: but it lets me treat gets as a value
14:13:00 <sproingie> sure, the *function* gets
14:13:04 <sproingie> but not the return value of it
14:13:12 <pikajude> ok
14:13:19 <ski> (those reasoning laws being useful to be able to predict what a program should do, understanding it, analyzing it, refactoring it, &c.)
14:13:50 <pikajude> i'm not firmly on one side or other of the issue
14:13:58 <Aruro> ski:  not always, its hard to find leaks, so there is hard reasoning in haskell too
14:14:06 <pikajude> i just remember reading a (satirical) blog post by someone saying that the C language is a DSL for producing an IO action that does something when executed
14:14:09 <ski> sproingie : s/evaluator/executor/
14:14:14 <pikajude> and the counterargument wasn't obvious to me
14:14:39 <sproingie> ski: ah right, i'm constantly mixing those up
14:15:16 <ski> actualHuman_462 : it's not a side-effect because it's accounted for in the interface (the types). an expression of type `String' is distinguished from an expression of type `IO String'
14:15:57 <ski> and you can't mix one up for the other in code, even if you're not aware of which of those types it has (no implicit coercion between them)
14:15:58 <sproingie> unsafePerformIO will give you true "side" effects.  with a raft of gotchas of course, as the name should make clear
14:17:02 <kernelj_arch> bad algorithm, bad code or what? http://lpaste.net/355053
14:17:13 <ski> Aruro : yes. i was referring to reasoning about behaviour (as defined by e.g. denotational semantics, or axiomatic semantics). for performance, you do need some kind of operational semantics, yes
14:18:15 <Aruro> reasoning in declarative language has to be easy by default :), otherwise whats the point of declaring
14:18:25 <ski> pikajude : yes, `gets' will get you a function pointer .. but there's no way to express in C a function that doesn't, *potentially*, have some effect on the side, when called
14:18:26 <actualHuman_462> I guess what I'm saying is that distinguishing between effects that are not deterministic and effects which have are not deterministic but have a categorical boundary is useful from 1,000 feet, but can also introduce a false sense of security.
14:18:42 <lyxia> kernelj_arch: what kind of feedback are you looking for? are you having problems with your code?
14:18:54 <sproingie> i don't know that declarative necessarily makes it *easy* as much as it at least makes it *possible*
14:18:59 <lyxia> kernelj_arch: what does your code do?
14:19:17 <kernelj_arch> lyxia: it's for a problem I'm doing, the code works but it is too slow
14:19:24 <ski> actualHuman_462 : can you rephrase "effects that are not deterministic and effects which have are not deterministic but have a categorical boundary" ?
14:20:11 <Aruro> actualHuman_462: haskell has all best ideas, but it has a lot of problems too, thats in short :)
14:20:17 <kernelj_arch> lyxia: it finds the length of the range containing index d in the range a_d .. a_d+M
14:20:29 <sproingie> Aruro: Haskell has all the best problems :)
14:20:34 <Aruro> :D
14:20:44 <Aruro> of course, natural consequence of best ideas
14:20:57 <monochrom> easier = more possible.
14:21:24 <Aruro> reasoning from prehistory is based on declarations
14:21:32 <Aruro> nobody can think of mechanisms which are working
14:22:04 <Aruro> so declarative language is already perfect start
14:24:04 <lyxia> kernelj_arch: you're repeatedly traversing the list as with (!!), drop, countWhile. Look for better data structures.
14:26:16 <kernelj_arch> lyxia: Data.Array or something?
14:26:40 <kernelj_arch> doesn't countWhile kinda have to iterate over the list
14:26:47 <Aruro> wiki says curring has been first used by Frege
14:27:20 <ski> wouldn't surprise me
14:27:26 <sproingie> :t countWhile
14:27:27 <lambdabot> error: Variable not in scope: countWhile
14:27:40 <ski> he sure had functions as arguments
14:27:42 <lyxia> kernelj_arch: Structure your data so that you don't need to traverse all of your data.
14:28:40 <sproingie> Aruro: none of us really care to call it "Schönfinkeling" or "Fregification"
14:29:03 <pikajude> Fregging
14:29:05 <MonadHendrix> i do
14:29:17 <pikajude> you can always install acme-schoenfinkel
14:29:20 <sproingie> wouldn't be the first concept to be named for the guy with the catchier name
14:29:26 <MonadHendrix> 3>not finckeling your functions
14:29:29 <kernelj_arch> lyxia: binary tree with (min,max) stored on the nodes?
14:32:26 <jordan36363> hi guys
14:32:39 <ski> hello jordan36363
14:32:57 <jordan36363> i have a question concerning list  comparisions
14:33:00 <jordan36363> [1, 2] >= [1, 2, 0]
14:33:27 <jordan36363> this is obviously "False" but I wonder what it compared in the last step
14:33:40 <AaronFriel> Can someone explain the magic of the SPEC constructor to me?
14:33:41 <jordan36363> which value has a missing element?
14:33:42 <ski> > [] >= [0]
14:33:44 <lambdabot>  False
14:34:20 <ski> the shorter list is considered to be lesser, in case it is a prefix of the longer one
14:34:35 <jordan36363> [] is the empty element?
14:34:39 <ski> (i don't understand "which value has a missing element?")
14:34:42 <ski> there is no empty element
14:34:43 <monochrom> empty list.
14:34:56 <jordan36363> i thought every element in a list has to be the same type
14:34:59 <Aruro> > [] < [[]]
14:35:01 <lyxia> kernelj_arch: you can try things and see whether they work or not. Learn by practice.
14:35:01 <lambdabot>  True
14:35:02 <ski> jordan36363 : yes
14:35:03 <jordan36363> an empty list in a list of integers?
14:35:11 <ski> no
14:35:19 <sproingie> jordan36363: they do, but [] is polymorphic to any type
14:35:20 <ski> all the elements here are numbers
14:35:25 <monochrom> every element in the empty list has the same type as the type of 0, yes.
14:35:35 <sproingie> :t []
14:35:36 <lambdabot> [t]
14:36:08 <ski> lists are compared in "lexicographic" order, more or less the same as in a dictionary
14:36:15 <ski> "the" should come before "there"
14:36:27 <jordan36363> sproingie ty thats a good example
14:36:29 <ski> > "the" < "there"
14:36:32 <lambdabot>  True
14:36:45 <jordan36363> ok ski thanks!
14:37:17 <ski> jordan36363 : basically, as long as we haven't come to the end of any of the two lists yet, we compare the current two elements we're looking at
14:37:57 <ski> jordan36363 : if they're different, then their respective ordering determines the ordering of the two containing lists. only if they're equal do we proceed to look at the next two elements (if any)
14:38:05 <Aruro> jordan36363: u can see how ord instance is realized for [a]
14:38:36 <ski> jordan36363 : the list that runs out of elements first is considered the lesser. if both run out of elements at the same time, then the lists are equal
14:39:55 <ski> (to clarify, if the current two elements are not compared as equal, then we stop at this point, not bothering to look further into any of the lists)
14:41:04 <ski> > [0,0 ..] < [0] ++ [1,1 ..]  -- this works, despite the two lists being infinite in length
14:41:06 <lambdabot>  True
14:41:15 <ski> > [0] ++ [1,1 ..]  -- showing it's infinite
14:41:17 <lambdabot>  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:41:40 <ski> jordan36363 : makes sense ?
14:41:40 <jordan36363> nice, I got it
14:41:43 <ski> ok
14:41:44 <jordan36363> thanks a lot ski
14:41:49 <ski> no problem
14:42:11 <Aruro> jordan36363: btw lists can be compared only if elements can. there is Ord a constraint.
14:43:00 <Aruro> Ord a => Ord [a]
14:43:01 <geekosaur> ...which is why we recommend (null xs) instead of (xs /= []); the former needs no Ord
14:43:12 <ski> (well .. `Eq')
14:43:22 <geekosaur> yes, actually, Eq
14:43:28 * ski . o O ( `xs <= []' )
14:43:51 <geekosaur> but, you can test empty list without Eq because it's a constructor / structure test
14:44:09 <ski> @type null
14:44:11 <lambdabot> Foldable t => t a -> Bool
14:44:12 <ski> @src null
14:44:12 <lambdabot> null []    = True
14:44:12 <lambdabot> null (_:_) = False
14:44:40 <ski> oh, the type signature for this less general definition is actually `null :: [a] -> Bool'
14:45:09 <Aruro> @djin [a] -> Bool
14:45:09 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
14:45:51 <ephemeral> hmm
14:45:52 <ephemeral> <sproingie> :t []
14:45:52 <ephemeral> <lambdabot> [t]
14:45:57 <Tuplanolla> Not happening, Aruro.
14:46:01 <ephemeral> what kind of syntax is [t]?
14:46:07 <pikajude> it's a type
14:46:19 <pikajude> it means list of t
14:46:28 <ephemeral> but why not [a]
14:46:29 <sproingie> means for all types 't'.  the two t's have nothing to do with each other, it's just coincidence
14:46:38 <pikajude> great question
14:46:52 <pikajude> the type variable name selection happens somewhere in the compiler
14:46:54 <sproingie> ghc likes 't' to mean type, it uses a and b and such for functions
14:46:56 <pikajude> who knows where
14:47:00 <ephemeral> lol sproingie, I understood as much
14:47:01 <ephemeral> :D
14:47:56 <sproingie> actually it does seem to always generate 't' and 't0', 't1', and so on when there's no signature
14:48:16 <sproingie> :t \x y -> y
14:48:18 <lambdabot> t1 -> t -> t
14:48:24 <Aruro> :t Just
14:48:26 <lambdabot> a -> Maybe a
14:48:56 <sproingie> that was declared that way though
14:49:06 <sproingie> :t (\x y -> y :: a -> b -> b)
14:49:07 <lambdabot> error:
14:49:07 <lambdabot>     • Couldn't match expected type ‘a1 -> b1 -> b1’
14:49:07 <lambdabot>                   with actual type ‘t’
14:49:16 <sproingie> :t (\x y -> y) :: a -> b -> b
14:49:18 <lambdabot> a -> b -> b
14:49:22 <AaronFriel> I am very surprised the compiler is still okay with me doing this: Result size of Tidy Core = {terms: 626, types: 17,162,396, coercions: 14,588,102}
14:50:34 <ephemeral> AaronFriel: what's that?
14:50:43 <Aruro> :t undefined
14:50:44 <lambdabot> a
14:51:34 <AaronFriel> ephemeral: Oh, I am writing code that generates _lots and lots_ of intermediate types. "Core" is a language that Haskell compiles down to (as an intermediate step) before it compiles to machine code.
14:52:13 <Aruro> :t [undefined]
14:52:15 <lambdabot> [t]
14:52:24 <ephemeral> right, I remember briefly opening a paper on Core, but realized pretty quickly that it would still be quite a few years before I could hope to comprehend
14:52:50 <jordan36363> http://imgur.com/a/3Dcqa
14:52:52 <jordan36363> this is so cute
14:53:14 <ephemeral> heh, that's from learn you a haskell, right?
14:53:31 <jordan36363> yep ^
14:53:44 <AaronFriel> ephemeral: Core is, ostensibly, simpler than Haskell, but it could take a lot more work to do "interesting stuff" in it. Like assembly?
14:53:56 <jordan36363> did you read it too when u started out?
14:54:49 <ephemeral> I've read it on and off during the last couple of years, but until recently I haven't really been in a state to gain any comprehension, so should definitely pick it up again now that I'm actually learning well
14:55:00 <ephemeral> currently working on real world haskell though
14:55:27 <AaronFriel> Unless you need to debug the performance of something at a low level (as in, how language extensions are interacting) you probably will not need to look at core.
14:55:50 <ephemeral> right; perhaps some day in the distant future
14:56:14 <ephemeral> right now I'm still learning the language, baby steps
14:57:44 <thoughtpolice> AaronFriel: Well, it's "okay" with it only to the extent it doesn't choke out the optimizer, of course! There are some nasty cases where GHC can go exponential when at the Core level, though, and it's not clear anyone knows how to fix it at the moment other than some crude, large hammers.
14:58:35 <thoughtpolice> (e.g. the compiler begins generating types that are exponential in the size of the input program, which is clearly awful.)
15:00:31 <AaronFriel> @thoughtpolice Yeah, I can only really compile this at -O0, but that's okay because there's enough redundancy that LLVM output length is (approximately) constant relative to the types.
15:00:31 <lambdabot> Unknown command, try @list
15:00:38 <AaronFriel> Slack habits.
15:00:55 <thoughtpolice> The only "fix" I think that wasn't "hire someone to figure it out and publish a PhD about it" was, to essentially, not generate coercions. Coercions are important but their *existence* is only a witness to some equality. If you just assume the equality is legit, you don't need them. You can just throw them away; they are, after all, not present at runtime.
15:01:51 <thoughtpolice> This is horribly bad for a number of reasons though, the most important being that GHC can no longer typecheck its IR during compilation. That means bugs in the frontend are far more dangerous and difficult to find. It can be done, but only if you compile *with* coercions enabled. And that would require recompiling all of GHC, too. That's not good.
15:03:49 <jordan36363> who can u contact if u find errors in a book?
15:03:51 <jordan36363> https://imgur.com/a/FESeP
15:04:07 <jordan36363> it should say "from the end of a list" righ
15:04:11 <jordan36363> right
15:04:23 <AaronFriel> thoughtpolice: so you're saying there's a chance
15:04:36 <Tuplanolla> Nope, jordan36363.
15:04:42 <thoughtpolice> I mean it's not the end of the world... Most compilers, in fact, probably don't have as strong of types in the IR, much less typecheck their IR at all, or have as rigorous a theory as GHC's. But I can say that from direct experience: IR typechecking has found *lots* of bugs and helps fix them dramatically faster.
15:05:03 <actualHuman_462> > drop 1 [1,2] == 2
15:05:05 <lambdabot>  error:
15:05:05 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘==’
15:05:05 <lambdabot>        prevents the constraint ‘(Eq a0)’ from being solved.
15:05:14 <actualHuman_462> > drop 1 [1,2] == [2]
15:05:16 <monochrom> No, hire someone to do a PhD on proving EXPTIME-completeness :)
15:05:17 <lambdabot>  True
15:05:30 <thoughtpolice> I guess it would mostly just make life worse for GHC developers.
15:05:42 <AaronFriel> thoughtpolice: I am trolling, a little. My research project might be dead in the water from the type explosion though.
15:05:45 <kernelj_arch> learn you a haskell still thinks Monad isn't a subclass of Applicative
15:06:17 <sproingie> LYAH needs a fork.  and some editing.
15:06:23 <jordan36363> Tuplanolla what do you mean "nope"
15:06:35 <ski> @quote BONUS
15:06:35 <lambdabot> BONUS says: C++ is saner than something? imo C++ is like the guy that goes around shouting "I am napoleon!!!"
15:06:45 <Tuplanolla> Not wrong, jordan36363.
15:06:55 <sproingie> it's CC-BY-NC-SA plus you have to do it with a smile on your face
15:07:01 <jordan36363> why not
15:07:20 <nitrix> I try not to compare programming languages using analogies.
15:07:48 <sproingie> data IAm = HenryTheEighth IAm
15:07:51 <nitrix> Using analogies in general seems to be a pretty bad idea.
15:08:23 <thoughtpolice> AaronFriel: Mmm. It's certainly a problem for sure and has bitten me several times.Unfortunately, yeah, fixing it is hard :( Maybe we really could just turn off coercions, though, idk.
15:09:19 <thoughtpolice> I'm of two minds on that because on one hand it does make finding some bugs much harder, AND it is only really a sidestep of the problem, it feels like. (It might just get even worse and worse in the future). OTOH waiting around on the compiler going exponential isn't exactly fun, either, I admit.
15:09:52 <jordan36363> I mean the examples arent wrong, but the sentence describing it rather odd
15:10:00 <jordan36363> easy to misunderstand that is
15:10:34 <kernelj_arch> jordan36363: I think the examples were good enough to figure out what was going on in all cases
15:10:43 <AaronFriel> thoughtpolice: It seems like a target for partitioning the problem? If you can verify the coercions are valid at -O0, and the optimization passes preserve equality, can you erase coercions before optimization? I know very little about the core-to-core passes though, what I said could have made no sense at all.
15:12:02 <thoughtpolice> AaronFriel: Well, depends on what you mean. If you can *prove* that all optimization passes don't violate it, then sure, but now you're writing Coq. :) If you mean, "The input program at -O0 with coercions typechecked, so I am free to throw them away" -- that's true, but it doesn't really fix the problem.
15:12:27 <thoughtpolice> Because perhaps now, at -O2, after you threw away coercions early on, a bug in the optimizer causes you to generate invalid code. But you already threw the coercions away: so you can't typecheck to try and find the bug. Womp womp.
15:13:09 <AaronFriel> What does "-fno-opt-coercion" do?
15:13:19 <thoughtpolice> You'll probably notice, in your case (I'm just guessing) that if you actually look at the simplifier being run, your program doesn't *just* start off massive. It generally *becomes* massive with coercions, etc, after a few passes.
15:13:33 <thoughtpolice> Because the inliner, type checking etc just so "happened" to align the stars correctly and everything explodes.
15:13:36 <AaronFriel> Oh no it starts off pretty massive
15:14:11 <AaronFriel> I've been waiting five minutes for ghci to start so I can record the type of a function and throw it up on hpaste
15:14:34 <thoughtpolice> Also, -fno-opt-coercion, IIRC, just means that GHC won't optimize coercions away, later on. GHC *does* optimize them away so they are not present at runtime.
15:14:53 <thoughtpolice> So the proposed fix I mentioned earlier would be more like a -fno-never-generate-coercions, or something, in comparison.
15:15:24 <thoughtpolice> (Optimizing them away later is of course different from ever generating them at all)
15:16:06 <thoughtpolice> AaronFriel: Oh, that's a more interesting case then. I imagine the rough idea is probably still the same however, where typechecking elaborates a Core program that has some kind of non-linear behavior in the input. I'd have to look at the exact program, ofc.
15:16:34 <sproingie> -fno-never-dont-not-stop-generating-coercions
15:19:59 <jordan36363> its a bit sad that the factorial function is not included in the standard prelude
15:20:32 <kernelj_arch> product [1..n]
15:20:33 <AaronFriel> thoughtpolice: http://lpaste.net/355054
15:20:33 <sproingie> which one? https://www.willamette.edu/~fruehr/haskell/evolution.html
15:20:54 <jordan36363> kernelj_arch they should have just added "!"
15:21:09 <kernelj_arch> they use that for array indexing though
15:21:10 <AaronFriel> thoughtpolice: oops, just fixed the truncated function at the top
15:21:11 <jordan36363> especially since haskell often is used for maths
15:21:14 <pikajude> just need a dialect of haskell that replaces strictness with factorial
15:21:28 <kernelj_arch> people use haskell for maths?
15:21:40 <jordan36363> not theoretical maths
15:21:43 <AaronFriel> kernelj_arch: Haskell is maths
15:21:43 <thoughtpolice> "This continues for ~300,000 lines"
15:21:52 <thoughtpolice> Sounds about right.
15:22:09 <kernelj_arch> no Coq is maths, Haskell is a functional programming playground
15:22:41 <jordan36363> https://wiki.haskell.org/Haskell_and_mathematics
15:23:05 <actualHuman_462> Anybody have much experience building c ffi stuff in windows? I am drowning in dll errors here
15:23:10 <kernelj_arch> people use Python for maths, SciPy+NumPy and whatever
15:23:35 <kernelj_arch> or the programming language R
15:23:35 <monochrom> "maths" is a highly overloaded word.
15:23:47 <jordan36363> and so is "people"
15:23:56 <NikolajK> mathematicans use Mathematica and sometimes C. Python is used in data science and for statistics by scientists
15:23:57 <AaronFriel> kernelj_arch: well that's just being pedantic, nothing stops you from defining partial functions or using restricted domains in math. Coq is just different math, doesn't mean that you cannot use Haskell (or more likely, if you're writing a paper, Core/System F, etc.) to do math.
15:24:07 <thoughtpolice> pikajude: "In GHC 8.4, if GHC detects your program invokes undefined behavior, it will now replace your entire program with 'factorial 666'"
15:24:24 <pikajude> GHC 8.2 is the version that will add undefined behavior, right?
15:24:55 <AaronFriel> "Undefined behavior" has specific meanings in every language, what do you mean in the context of Haskell?
15:25:15 <kernelj_arch> isn't System F a bit useless in practice?
15:25:23 <sproingie> execvp "nethack"
15:25:29 <pikajude> GHC 8.4 will replace any usage of a monad with factorial 666
15:25:36 <AaronFriel> Nice
15:25:45 <thoughtpolice> AaronFriel: Nothing, I'm being tongue-in-cheek :) (It's actually a kind-of reference, yes, to GCC replacing your program with a call to invoke nethack back in the day, when it found UB)
15:25:58 <pikajude> that sounds cool
15:26:00 <hpc> i heard GHC 8.4 will only compile programs that can't compile themselves
15:26:02 <nitrix> kernelj_arch: It's a good foundation. I think Haskell is using System F for the general idea, then added turing completeness to it.
15:26:37 <pikajude> compiling any haskell program that won't terminate with GHC 8.4 will be a warning
15:26:39 <AaronFriel> System F isn't turing complete?
15:26:40 <pikajude> you can turn it off with -Wno-halt
15:27:02 <sproingie> haskell 8.5 will be copendently typed
15:27:12 <nitrix> AaronFriel: It lacks recursion.
15:27:17 <sproingie> *codependently
15:27:23 <centril> Turing complete in what? the type system or runtime values... ? im guessing the former
15:27:32 <nitrix> Type system yeah
15:27:41 <AaronFriel> Ah, yeah now I understand what you mean.
15:27:44 <monochrom> Is this April 1st?!
15:28:25 <actualHuman_462> April 1st was a Saturday
15:28:35 <kernelj_arch> it's Saturday tomorrow...
15:28:43 <actualHuman_462> *mind blown*
15:29:53 <centril> Isn't Haskell is System Fω ?
15:30:06 <jordan36363> Im confused about something
15:30:07 <centril> (remove the second is)
15:30:21 <centril> https://en.wikipedia.org/wiki/System_F#System_F.CF.89
15:30:27 <jordan36363> if you quote something in English and you dont use " but instead the thing where there is only one line
15:30:41 <jordan36363> which one do u use? ´, `, '
15:31:31 <nitrix> jordan36363: Seems to me that quoting should be done with quotes. Not apostrophe or ticks/backticks.
15:31:44 <centril> mmhm... in a bachelor thesis, would you use "w.r.t." or "with respect to" ?
15:31:50 <centril> monochrom: ^
15:31:55 <kernelj_arch> jordan36363: You use the ' normally
15:32:15 <jordan36363> ` and ´ are called backticks and ticks?
15:32:23 <jordan36363> what is ' called?
15:32:29 <sproingie> if you're james joyce, you don't use anything
15:32:30 <Tuplanolla> Why would you ever abbreviate if you're not running out of space or repeating the same phrase over and over, centril?
15:32:34 <monochrom> centril: I think both are fine.
15:32:43 <kernelj_arch> jordan36363: apostrophe usually
15:32:44 <centril> also... I need some volunteers to read ours in a few days ;)
15:32:57 <centril> Tuplanolla: it is repeated a few times
15:33:13 <centril> monochrom: but your bias is towards ?
15:33:23 <jordan36363> ok thx kernelj_arch
15:33:27 <monochrom> I use fewer abbreviations.
15:33:32 <nitrix> jordan36363: an apostrophe?
15:33:48 <centril> monochrom: =)
15:34:15 <monochrom> I repeat "almost everywhere" almost everywhere. :)
15:34:33 <jordan36363> i was just confused that "str" 'elem' ["a", "str"] didnt work
15:34:34 <ski>   ' APOSTROPHE
15:34:38 <ski>   ` GRAVE ACCENT
15:34:45 <ski>   ´ ACUTE ACCENT
15:34:46 <jordan36363> then i found out that u need to use "str" `elem` ["a", "str"]
15:35:20 <kernelj_arch> ` is sometimes called backtick, the acute accent isn't used much
15:35:24 <nitrix> Acute and grave are used in french on some characters, but you never see them used alone like this.
15:35:26 <jordan36363> aigu not acute
15:35:34 <jordan36363> i speak french
15:35:48 <ski>   ‛single quotation marks’
15:35:52 <nitrix> jordan36363: So do I, the name's acute in english.
15:36:05 <kernelj_arch> inb4 ski “double quotation marks”
15:36:10 <centril> nitrix speaks the truth.
15:36:12 <jordan36363> oh you have another word for it in english alright
15:36:26 <actualHuman_462> Exonyms forever!
15:36:43 <ski> kernelj_arch : or "‟"
15:37:08 <nitrix> jordan36363: English borrows some words rarely like risqué, so yeah.
15:37:27 <kernelj_arch> ski: too many damned characters aren't there?
15:37:45 <MarcelineVQ> kernelj_arch, nitrix, jordan36363: sometimes ' is called prime
15:38:00 <kernelj_arch> MarcelineVQ: that's usually typeset differently though
15:38:09 <kernelj_arch> it might even have its own unicode codepoint
15:38:16 <ski>   ′ PRIME
15:38:28 <actualHuman_462> What is the deal with that anyway? The only explanation I've heard for ' == prime is something like "Blah blah math blah math math blah"
15:38:37 <nitrix> MarcelineVQ: Should be ' apostrophe  ′ prime
15:39:22 <MarcelineVQ> keep your special chars out of my source code you damn dirty apes
15:39:23 <nitrix> I wouldn't want to be on the unicode commitee....
15:39:36 <kernelj_arch> committee
15:39:37 * centril concurs with MarcelineVQ
15:39:54 <centril> kernelj_arch: is this the correct-typos channel :P ?
15:39:59 <jordan36363> single quotation marks arent on my keyboard wth
15:40:10 <nitrix> centril: In this case it's appreciated to better my english (:
15:40:21 <MarcelineVQ> actualHuman_462: I've seen ' used for derivates in math where ' is first '' second ''' third etc
15:40:23 <kernelj_arch> centril: a channel like that exists???
15:40:57 <kernelj_arch> I imagine people would avoid saying anything in case they misspell something... is that even how you spell misspell?
15:41:07 <MarcelineVQ> a.k.a. prime notation for derivatives
15:41:08 <Tuplanolla> It's the universal "can't think of a new name for this variable" symbol, actualHuman_462.
15:41:30 <ski> ⌜f′⌝,⌜f″⌝,⌜f‴⌝
15:41:54 <Tuplanolla> Using it for derivatives is heresy anyway.
15:42:15 <sproingie> it's a pretty common notation for that
15:42:43 <ski> ⌜D f⌝,⌜D² f⌝,⌜D³ f⌝
15:42:45 <actualHuman_462> Is there some sort of relationship between the concept of derivatives and the word "prime"?
15:42:58 <sproingie> doubt it
15:43:16 <ski> not anymore than the derivative being a "variant" of the function, in some very rough sense
15:43:34 <ski> (being derived from it, by the process of differentiation)
15:43:35 <centril> ski: well - not a semantic preserving sense
15:43:57 <centril> so very rough indeed
15:44:01 <ski> aye
15:44:09 <kernelj_arch> usually f²(x) means f(f(x)) though
15:44:26 <ski> yes, and ⌜D² f⌝ means ⌜D (D f)⌝
15:44:26 <centril> just write  f . f $ x
15:44:41 <centril> or  (f . f) x
15:44:45 <kernelj_arch> except when f is a trigonometric function then for some reason it actually means squared
15:45:04 * ski dislikes that usage of exponent, refuses to use it
15:45:09 <sproingie> math is hard, let's go shopping
15:45:13 <jordan36363> then you wouldnt say f though
15:45:14 * centril agrees with ski
15:45:32 <actualHuman_462> Yeah, this is why I never did so well in math past a certain point, same reason I couldn't swallow perl, everything changes meaning based on context
15:45:34 <centril> what's wrong with good old function composition...
15:45:54 <centril> actualHuman_462: haha... type classes anyone... ?
15:46:02 <centril> they don't change meaning based on context ?
15:46:19 <ski> centril : at least there's a most general type there
15:47:22 <sproingie> with perl contexts there's really just list and scalar.  try C++ code where some twit decides to overload all the casts he can think of
15:48:30 <actualHuman_462> perl is full of magic syntactical constructs. Like '$_'
15:49:04 <actualHuman_462> There's sanity and consistency there - Like math, if you get all the rules, it's not ambiguous
15:49:14 <ertes> haskell has those, too
15:49:29 <sproingie> modern idiomatic perl tends to steer clear of the gotchas.  'course they're always *there*
15:49:47 <sproingie> with a few that can be turned off with pragmas
15:50:03 <actualHuman_462> I'm not aware of any in Haskell outside of do notation? Are there other examples?
15:50:44 <ski> perhaps you'd count list comprehensions and enumerations
15:50:56 <ertes> actualHuman_462: x <- (| f (c -< 5) (d -< y) |); …
15:51:02 <ski> (and definite lists)
15:51:06 <ertes> actualHuman_462: if you have no idea what that means, don't worry…  nobody does
15:51:15 * ski smiles
15:51:17 <actualHuman_462> ertes : lol
15:51:30 <sproingie> ertes: how does one actually enable that syntax?
15:51:41 <ertes> granted it's not haskell…  it's haskell + -XArrows
15:51:42 <ertes> =)
15:53:21 <ertes> sproingie: it's a "convenience" syntax for arrow notation…  to be honest it *is* convenient, because the equivalent syntax without those banana brackets is WAY worse
15:54:55 <ertes> it's bad enough when you have to use arrows, but when you have to use bananas, you know that you REALLY want to find a monad that does the job =)
15:56:21 * ski thinks `TransformListComp' is interesting
15:56:44 <ski> (though i think some parts of it could be done better)
15:57:22 <actualHuman_462> Why not just use do notation?
15:58:15 <actualHuman_462> Oh, nvm, additional research answers this question, that way lies madness
16:09:19 <ertes> i wish there was an IsString instance for (Vector Char)
16:09:44 <ertes> in fact i wish Vector had more text-related functions
16:12:48 <actualHuman_462> ertes : What's your usecase there? Just curious
16:14:58 <fXl> hello guys
16:15:26 <fXl> how can i define 3 variables, depends on something else ?
16:19:44 <Eduard_Munteanu> fXl, hi, can you explain that?
16:20:04 <Eduard_Munteanu> I don't understand what you're aiming for.
16:20:09 <kernelj_arch> haskell doesn't do variables
16:21:30 <fXl> Eduard_Munteanu, okey
16:23:11 <fXl> http://lpaste.net/355056, like here
16:24:09 <fXl> Eduard_Munteanu, fullPathEntryScript and entryScriptContent will be avaliable globally if entryScript /= ""
16:25:11 <ertes> actualHuman_462: i need O(1) splitting and indexing for text
16:25:24 <fXl> i am trying to read a file named in entryScript. if it has no value readEntryScriptContent fails of course
16:25:44 <ecognium> I have looked around but couldn't find a quick way to do some date manipulation. I have a date (usually end of the moth like "2017-04-30") and would like to generate the past x-months from this date so "2017-03-31", "2017-02-28", ... "2016-01-31", etc.  
16:25:59 <fXl> Eduard_Munteanu, obviously it tries to read folder not the file in that folder
16:26:06 <ecognium> Is there a quick way to "subtract months" from a `Day` type
16:26:43 <ertes> ecognium: i have written a library for that: https://hackage.haskell.org/package/timelike
16:27:18 <Eduard_Munteanu> fXl, '<-' belongs to a 'do' block, not 'let'.
16:27:21 <fXl> ertugrul yok artik :D
16:27:33 <fXl> Eduard_Munteanu, yeah i know ofc
16:27:40 <Welkin> hamjambo
16:27:45 <fXl> i just explained what i intended to do
16:28:47 <Eduard_Munteanu> fXl, can you test readEntryScriptContent separately?
16:29:00 <Eduard_Munteanu> e.g. in ghci
16:29:16 <fXl> Eduard_Munteanu, if i give file name, it works 
16:29:16 <ecognium> ertes: thanks. I just skimmed the package quickly the docs are available only for Data.Time.Class and I am not sure how I can subtract a month? 
16:30:14 <Eduard_Munteanu> fXl, what does the entryScript /= "" test return?
16:30:20 <ecognium> Do I need to know i am in end of Feb and I need to subtract the time equivalent of 28 days + some seconds to go to Jan 31?
16:30:28 <fXl> there is no problem about reading, i just want to do , if file name is not given then dont do these or if its given then do these..
16:30:39 <Welkin> use a proper calendar library
16:30:43 <Welkin> there should be one
16:30:56 <Welkin> you should be able to specify an offset in months and it will "do the right thing"
16:31:30 <ephemeral> https://hackage.haskell.org/package/time-1.8.0.1/docs/Data-Time-Calendar.html
16:31:57 <ephemeral> addGregorianMonthsClip :: Integer -> Day -> Day Source #
16:31:57 <ephemeral> Add months, with days past the last day of the month clipped to the last day. For instance, 2005-01-30 + 1 month = 2005-02-28.
16:32:32 <ertes> ecognium: you can use dateSkip with a negative count
16:32:55 <ertes> dateSkip (-4) Month
16:33:10 <Eduard_Munteanu> fXl, oh, you can just use 'case ... of ...' ?
16:33:27 <Eduard_Munteanu> Or guards, or if-then-else.
16:33:28 <Welkin> is `time` the best library?
16:33:29 <ertes> ecognium: oh, what ephemeral said
16:33:32 <Welkin> I haven't used it in a while
16:33:32 <ecognium> ertes: thank you. I did not see the DateUnit (I only looked at the TimeUnit and was not sure how to do it). I will check it out. 
16:33:39 <fXl> Eduard_Munteanu, original working one, http://lpaste.net/8287532481628864512
16:33:45 <Welkin> I have gotten used to using moment.js though, which is good (in js though)
16:34:08 <ertes> ecognium: then you don't need two extra library dependencies =)
16:34:16 <ephemeral> I have no idea, I'm still learning haskell, just googled it :P
16:34:33 <ertes> i forgot that the time library has that itself =)
16:34:59 <ecognium> ephemeral: thank you. your google-fu is much better than mine.. Maybe I was stuck on subtract month instead of addition with negative values
16:35:03 <ertes> but yeah, a lot of basic time arithmetic is surprisingly difficult with 'time', hence 'timelike'
16:35:33 <Welkin> (written by ertes)
16:35:38 <ertes> especially something like "skip to the next tuesday"
16:35:39 <fXl> :D
16:35:44 <Eduard_Munteanu> fXl, you can do something like     let entryScript = fromMaybe "" <$> useEntryPointPath
16:36:10 <Eduard_Munteanu> > fromMaybe "foo" Nothing
16:36:12 <lambdabot>  "foo"
16:36:18 <Eduard_Munteanu> > fromMaybe "foo" (Just "bar")
16:36:20 <lambdabot>  "bar"
16:36:22 <Welkin> ertes: does it have a nice api like moment.js?
16:36:28 <Welkin> It looks pretty good from a quick glance
16:36:34 <ertes> Welkin: i don't know
16:36:41 <ertes> but if you compare it, let me know =)
16:37:19 <fXl> Eduard_Munteanu, cool that fromMaybe thing exists :D
16:37:27 <ecognium> ephemeral: that may not quite work for subtraction it looks like.. let x = read "2017-04-30" :: Day;  addGregorianMonthsClip (-1) x  ... 2017-03-30 and not 2017-03-31
16:37:43 <ecognium> I will have to add timelike to see if it produces the behavior I want
16:38:26 <ephemeral> uh
16:38:41 <ertes> ecognium: timelike will also give you day 30
16:39:00 <ephemeral> it works as intended, I mean, how is any library supposed to know that you want the last day from that info alone?
16:39:00 <fXl> Eduard_Munteanu, then i will say if it is not Nothing then do line 10 and 11, http://lpaste.net/8287532481628864512
16:39:04 <ertes> it reads april 30th as the "30th day", not the "last day"
16:39:46 <ephemeral> it will clip down, but it won't add extra days :P
16:39:55 <Eduard_Munteanu> fXl, oh, if you only want to do it when it's a Just, then you can use mapM_/forM_
16:40:02 <Welkin> http://momentjs.com/docs/#/manipulating/end-of/
16:40:06 <ertes> i guess one could implement special variants
16:40:10 <fXl> Eduard_Munteanu, yes excatly
16:40:13 <Welkin> this is the best calendar/time api I have seen
16:40:17 <Eduard_Munteanu> > forM_ (Just 15) $ \n -> putStrLn (show n)
16:40:19 <lambdabot>  <IO ()>
16:40:46 <ertes> Welkin: not quite the same thing
16:41:15 <ecognium> ertes: I see. Ok. I may have to roll my own for my use case.   I probably have to just look up the month and do some subtraction so it takes me the end of the previous month.. or keep it simple and create a cycle on going back by months and just create the Day type once I know the month. 
16:41:49 <ertes> ecognium: what you could do is to check whether the original date was the last day, and if yes, set the day to the last day yourself…  be sure to use an API that understands stuff like feb 29th in leap years
16:42:10 <fXl> Eduard_Munteanu, can i pm you ?
16:42:50 <ertes> ecognium: BTW, if you implement extra functionality, i'll be happy to merge it =)
16:42:51 <Eduard_Munteanu> fXl, we should rather discuss Haskell stuff in here, more people can help, unless it's something else.
16:43:05 <fXl> yes its something else :D
16:43:18 <ephemeral> he's going to solicit sex services
16:43:21 <fXl> ^^
16:43:33 <fXl> ephemeral, will show my boobs
16:43:34 <ecognium> ertes: roger that. I am not very good at Haskell but if I create something that is not too hacky I will share it with you as a snippet first
16:44:16 <ertes> ecognium: don't worry about it, i don't mind improving your code
16:45:05 <ertes> or, if you want to learn, i can just tell you how to improve it yourself, and then you can just add more commits
16:45:58 <kernelj_arch> I really miss pointers and being able to walk around datastructures
16:46:15 <kernelj_arch> it just seems easier
16:46:16 <sproingie> walking around datastructures still happens.  you won't miss raw pointers.
16:46:47 <kernelj_arch> how do you do things like walk up to the parent node without pointers?
16:47:01 <Welkin> kernelj_arch: it's not easier, it's just different
16:47:01 <ski> no can do
16:47:03 <ertes> kernelj_arch: you return from a recursive function
16:47:05 <sproingie> by keeping the parent node in scope when you access the child
16:47:13 <Welkin> you use recursion
16:47:13 <sproingie> or when you return, yeah
16:47:15 <Welkin> you don't need pointers
16:47:43 <kernelj_arch> it's awkward having to write all the logic based on the top of the tree
16:47:45 <ski> (you could make the child "point" to the parent, by tying-the-knot .. but it's usually not that useful)
16:48:15 <sproingie> you don't have to keep it at the top of the tree either.  there's lots of ways to do it.
16:48:15 <ski> (since you can't change it to point to something else)
16:48:19 <Welkin> you can also, of course, use a zipper
16:48:30 <ertes> there is also the concept of paramorphisms, if you really need the "surrounding structure" in deeper recursion levels
16:48:40 <Welkin> forget about pointers and the way you already know how to do it
16:48:50 <Welkin> be ready to learn something totally new and maybe weird
16:48:50 <rotaerk> paramorphisms, like telekinesis
16:49:06 <ski> there's `STRef' if you really need pointers/references
16:49:15 <kernelj_arch> I don't of course
16:49:37 <ski> but learning when you can do without them can be helpful
16:49:39 <ertes> kernelj_arch: it does require a different way of thinking…  in many cases it's actually *easier* than pointer
16:49:41 <ertes> pointers
16:49:56 <Welkin> pointers are too low-level and prone to errors
16:49:59 <kernelj_arch> I just find it very unnatural this way
16:50:13 <ski> (oh, and `Ptr' is also a thing, if you want pointer arithmetic. usually when interfacing with foreign languages)
16:50:29 <ertes> kernelj_arch: because you're used to it…  once you get used to the algebraic approach, you will find pointers far less natural =)
16:50:39 <Welkin> you'll probably never use pointers in haskell unless you need to interact with a C librar/codebasy directly
16:51:02 <sproingie> "natural" is just a matter of what you're used to
16:51:08 <sproingie> there ain't nothing natural about programming anyway
16:51:26 <rotaerk> but cats program me
16:51:35 <rotaerk> very natural
16:51:38 <sproingie> they're better programmers :)
16:51:39 <kernelj_arch> well procedural programming is like following a recipe
16:51:46 <kernelj_arch> you know what the steps are
16:52:05 <sproingie> so is functional, you just describe the steps differently
16:52:11 <ertes> kernelj_arch: humans are good at following recipes, but rather bad at writing them =)
16:52:29 <Welkin> with haskell, you describe the result you want, not the details of how you get that result (at least that is a helpful way to think about it)
16:52:44 <kernelj_arch> if you mess up in haskell, you messed up bad
16:52:44 <rotaerk> "functional programming" is a bit too vague an umbrella term, IMO; I prefer to refer to concrete, specific concepts
16:52:45 <ertes> just try to assemble an ikea wardrobe, and you'll know exactly what i mean
16:53:03 <ertes> kernelj_arch: if you mess up *and* the compiler doesn't catch it
16:53:11 <kernelj_arch> that's what I meant
16:53:30 <ertes> but it's not just a matter of safety…  algebraic data structures are actually more convenient
16:53:37 <ertes> … most of the time
16:53:42 <rotaerk> one of those concepts is the distinction between expressions and statements; in procedural languages, you tend to write series of statements; in haskell you build expressions
16:53:59 * ski . o O ( commands )
16:55:20 <kernelj_arch> and that's why it takes forever to write one line
16:55:33 <ski> practice makes perfect
16:56:07 <ski> @quote rules.of
16:56:07 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
16:57:31 <Welkin> o.o
16:57:59 <ertes> too bad, she was young enough to learn go…  or FP
17:00:55 <kernelj_arch> is there a better way to calculate e.g. head . dropWhile (<100) . iterate (*2) $ 1
17:01:21 <kernelj_arch> here you're constructing a list for no reason, as opposed to a simple while loop
17:01:28 <ChaiTRex> kernelj_arch: 128
17:01:43 <ertes> kernelj_arch: calculate the integer logarithm to base 2
17:01:45 <Welkin> lists are loops
17:01:53 <Welkin> you'll learn that soon
17:02:09 <Welkin> lists are used more as control structures than as data structures
17:02:12 <ertes> kernelj_arch: https://hackage.haskell.org/package/integer-logarithms
17:02:46 <ertes> kernelj_arch: 2^(integerLog2 100) = 64
17:03:38 <ChaiTRex> There should be some neat trick to get the next higher power of two using bitwise stuff.
17:04:36 <Welkin> ChaiTRex: power of two?
17:04:37 <Welkin> just left shift
17:05:00 <ChaiTRex> No, the next highest integer that is a power of two.
17:05:11 <ChaiTRex> Like with 124, the next highest is 128.
17:05:33 <Welkin> > 124 / 2
17:05:35 <lambdabot>  62.0
17:05:42 <ertes> ChaiTRex: that's what integerLog2 does…  it basically just searches for the position of the highest bit
17:06:00 <ertes> oh, and actually you can get (2^) faster by using 'bit'
17:06:09 <ertes> > bit 6 :: Integer
17:06:11 <lambdabot>  64
17:08:31 <ChaiTRex> > 68 .&. (68 - 1)
17:08:33 <lambdabot>  64
17:08:56 <ski> wouldn't `integerLog2' round down ?
17:09:05 <ChaiTRex> > map (\x -> x .&. (x - 1)) [1..32]
17:09:07 <lambdabot>  [0,0,2,0,4,4,6,0,8,8,10,8,12,12,14,0,16,16,18,16,20,20,22,16,24,24,26,24,28,...
17:09:14 <ChaiTRex> Hmm, that's not it then.
17:09:20 <ertes> oh, yeah…  well, just add 1
17:09:46 <kernelj_arch> and you have to -1 the input to integerLog2
17:10:02 * ski nods
17:10:22 <ertes> i'd rather compare
17:10:31 <ertes> it's faster than doing arithmetic unconditionally
17:11:21 <kernelj_arch> what do you mean?  usually unconditional arithmetic is faster since no branching in the CPU
17:11:24 <ertes> unless GHC optimises it to do the (subtract 1) in-place, but i doubt it
17:11:51 <ertes> kernelj_arch: only if you can do it in-place
17:12:40 <ertes> alright, running out of battery…  bye =)
17:12:50 <kernelj_arch> yeah I'm quite far away from understanding the haskell internals and how things actually execute
17:12:57 <kernelj_arch> cya ertes
17:12:59 <ski> > until (>= 100) (* 2) 1  -- fwiw
17:13:01 <lambdabot>  128
17:13:16 <ski> @index until
17:13:16 <lambdabot> Prelude
17:13:19 <ski> @type until
17:13:20 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
17:13:38 <kernelj_arch> yea that's what I was looking for
17:14:43 <kernelj_arch> weirdly there's no 'while' to go with 'until'
17:16:02 <kernelj_arch> ChaiTRex: http://stackoverflow.com/questions/53161/find-the-highest-order-bit-in-c#53184
17:16:43 <kernelj_arch> essentially munge over all the bits to the right then do minus the right shift
17:44:55 <actualHuman_462> Wouldn't this be faster?
17:45:10 <actualHuman_462> > (\n -> take 1 . filter (>= n) . map (2^) $ [1..]) $ 100
17:45:12 <lambdabot>  [128]
17:45:39 <actualHuman_462> Or is there something expensive about exponents?
17:45:53 <kernelj_arch> > bit 6
17:45:55 <lambdabot>  64
17:46:11 <kernelj_arch> > (\n -> take 1 . filter (>= n) . map bit $ [1..]) $ 100
17:46:13 <lambdabot>  [128]
17:46:28 <Welkin> > bit 4 <> bit 2
17:46:30 <lambdabot>  error:
17:46:30 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M654175259134...
17:46:30 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:46:51 <Welkin> > bit 4 `Data.Monoid.mappend` bit 2
17:46:53 <lambdabot>  error:
17:46:53 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M847344327479...
17:46:53 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:47:00 <Welkin> o.o
17:47:02 <Welkin> :t bit
17:47:04 <lambdabot> Bits a => Int -> a
17:47:41 <Welkin> :t (bit 4) + (bit 2)
17:47:42 <lambdabot> (Bits a, Num a) => a
17:47:50 <Welkin> > (bit 4) + (bit 2)
17:47:53 <lambdabot>  20
17:47:58 <Welkin> okay
17:48:02 <Welkin> there is just no show instance...
17:48:04 <Welkin> weird
17:48:08 <Welkin> er
17:48:15 <Welkin> no monoid instance maybe?
17:48:54 <Welkin> > bit 4
17:48:56 <lambdabot>  16
17:49:01 <Welkin> > bit 2
17:49:03 <lambdabot>  4
17:49:06 <Welkin> > bit 0
17:49:08 <lambdabot>  1
17:49:20 <actualHuman_462> What would the identity be for an arbitrary set of bits?
17:49:28 <Welkin> 0
17:49:40 <Welkin> binary addition
17:50:23 <Welkin> > Sum (bit 4) <> Sum (bit 2)
17:50:24 <actualHuman_462> Oh, I guess 0 is always 0s forever , ja, this makes sense
17:50:26 <lambdabot>  Sum {getSum = 20}
17:50:31 <Welkin> lol
17:50:33 <Welkin> well that works
17:52:27 <kernelj_arch> > Product (bit 4) <> Product (bit 2)
17:52:29 <lambdabot>  Product {getProduct = 64}
18:05:43 <xcmw> State is to MonadState as Maybe is to what? I don't see a MonadMaybe typeclass. 
18:07:18 <monochrom> Perhaps MonadError ()
18:08:03 <geekosaur> Maybe doesn't really need one, does it?
18:08:03 <xcmw> monochrom: That would work. Thanks
18:08:55 <benzrf> is Perhaps a type constructor
18:09:26 <monochrom> No, it's my English.
18:10:00 <monochrom> Ahem. Our English.
18:11:31 * ski . o O ( "mayhaps","perchance" )
18:14:39 <kernelj_arch> I think I'm really slow at programming, especially Haskell
18:15:14 <kernelj_arch> but then it took me several days to write some Java app that only calculated the price of a shopping basket where special offers applied
18:15:31 <EvanR> theres speed of typing the code, and speed of getting a working program
18:15:49 <kernelj_arch> after having to include all the object orientation and writing unit tests for everything and writing javadoc etc.
18:15:59 <EvanR> if you consider production apps that go up and sit there broken for years... thats hotta hurt benchmarks
18:16:48 <EvanR> im surprised you took so long to write java, doesnt the IDE do most of the work
18:17:04 <EvanR> (of the typing part)
18:17:09 <kernelj_arch> it does a lot of it but somehow it still took forever
18:17:32 <monochrom> Relocate to Narnia. :)
18:17:33 <kernelj_arch> it doesn't type the javadoc for you, except for the parameter names etc.
18:17:49 <kernelj_arch> and refactoring is still hard with an IDE
18:18:20 <EvanR> if i randomly wake up and sample what im doing while programming, and its usually typing a for loop, i get mad
18:19:00 <EvanR> something is broken about that process
18:19:00 <monochrom> Also the IDE doesn't auto-type lens-style code, only getter-setter style code. That may matter. :)
18:20:00 <EvanR> i like that the IDE could type your lens style support code, but doesnt have to, because it can be autogenerated ahead of time
18:20:00 <kernelj_arch> because I'm writing the program top-down none of the classes or methods I'm using actually exist for it to type for me
18:20:25 <Welkin> there are no classes or methods in haskell
18:20:28 <kernelj_arch> the only part the IDE helps with there is doing the import line after you've wrote it
18:21:00 <kernelj_arch> I'm not aware that there are IDEs for Haskell neither?
18:21:09 <Welkin> emacs with haskell-mode
18:21:23 <Welkin> there is a text editor for haskell written in haskell called Yii
18:21:25 <Welkin> and leksah
18:21:51 <EvanR> screw IDEs, screw code generators, we need a paperclip AI to see what youre trying to do and suggest oddball courses of action
18:22:00 <Welkin> Yi*
18:22:28 <Welkin> https://github.com/Fuco1/clippy.el
18:22:30 <ski> there are methods of type classes in Haskell
18:23:07 <Welkin> Yi: http://yi-editor.github.io/
18:23:21 <Welkin> Leksah: http://leksah.org/
18:23:29 <Welkin> don't forget clippy, though
18:24:15 <Welkin> emacs is the best IDE
18:24:33 <kernelj_arch> I don't emacs
18:24:50 <kernelj_arch> also for some reason I'm writing this code in a web browser
18:26:54 <ertes> EvanR: if the IDE makes your work 5 times as efficient, but you still need to do 10 times the work, because it's java, it doesn't really help =)
18:27:34 <ertes> we need haskell-clippy.el
18:27:58 <Welkin> clippy should work with haskell
18:28:13 <monochrom> "It looks like you need to switch to Lisp." :)
18:28:41 <EvanR> i just rewrote some code that took somebody a couple months, because i couldnt read it, in a day. something is not good about "just get it working as fast as possible"
18:29:02 <ertes> "it seems like you are trying to create a module…  need any help?  a) read about the history of haskell modules, b) watch SPJ's famous ‹haskell is useless› remark, c) buy real support for real work for realz this time"
18:29:25 <EvanR> i realize this sort of thing is not taught in school
18:29:36 <EvanR> and wondering why, what to do about it
18:29:48 <Welkin> or as they say in afrikaans: skool
18:32:05 <ertes> recently i watched a talk about a company that started their business using clojure, and the presenter was always returning to: "well, you know, it's fine to start with something like clojure, because you can always switch to java when your business grows"
18:32:24 <EvanR> lol
18:32:37 <ertes> i couldn't help thinking: "that's the dumbest thing i've ever heard"
18:32:41 <EvanR> wait that sadly makes sense :(
18:33:02 <kernelj_arch> it's all about Scala nowadays
18:33:03 <ertes> why does it?  not that i'm a big fan of clojure, but it's way better than java at…  everything
18:33:22 <ertes> kernelj_arch: i'd probably choose clojure over scala, of those two were the only options
18:33:26 <EvanR> because when you grow to like 40 programmers, you cant find and or afford people that know clojure or scala or haskell
18:33:33 <EvanR> and theres no java-of-haskell
18:33:39 <kernelj_arch> I was trying to get an interview for a job doing Haskell and they decided they only wanted Scala developers
18:33:46 <ertes> EvanR: you don't need to find someone who knows clojure…  all you need is a smart programmer
18:33:54 <ertes> ironically he said that himsefl
18:33:55 <EvanR> same thing
18:34:02 <Welkin> kernelj_arch: don't bother looking for a job using a specific language
18:34:06 <EvanR> they have a hard time finding clojure people in new orleans
18:34:10 <Welkin> most of the places I have looked at that use haskell are terrible
18:34:19 <Welkin> just because they use haskell doesn't make it a good place to work
18:34:20 <kernelj_arch> Welkin: ironically I was looking for C/C++ jobs
18:34:25 <EvanR> either who know/like it, or who can learn it quickly
18:34:41 <EvanR> Welkin: id love to see a terrible haskell job
18:34:42 <Welkin> I work with a great startup now writing javascript and ruby
18:34:44 <kernelj_arch> and I ended up doing an assignment in Java for a Java job
18:34:48 <ertes> EvanR: what's the worst case?  you need to hire someone to work remotely
18:34:53 <ertes> it's not that bad
18:35:03 <EvanR> ertes: a single person?
18:35:08 <monochrom> The law of enlightened programming employment: The employers think the good employees are all out of town, the employees think the good employers are all out of town.
18:36:07 <Welkin> EvanR: one of those particular companies doesn't even exist anymore
18:36:13 <Welkin> it got killed off
18:36:26 <Welkin> the haskell job market just sucks
18:36:42 <iqubic> Is there a way to embed a gloss image view in a haskell gi-gtk program?
18:36:56 <Welkin> look for a good company and then introduce haskell, don't look for a company that uses haskell, becuse it very well may be a terrible place to work
18:37:07 <iqubic> Or is there another way to do Graphics in Gi-Gtk
18:37:26 <EvanR> yeeeah... right.
18:37:40 <ertes> Welkin: you shouldn't rate the entire haskell industry by the failure of one company…  the problem likely wasn't haskell =)
18:38:11 <Welkin> the problem isn't haskell
18:38:23 <Welkin> it is that you can't judge a company by the languages they use
18:38:33 <Welkin> it doesn't mean much, if anything
18:38:43 <EvanR> ive come to terms in my haskell evangelism that people are just dsyfunctional
18:38:56 <ertes> contrary to what paul graham believes a good language doesn't have too much influence on *whether* you succeed, but it may decide how well you do down the line
18:38:59 <EvanR> and bad at spelling
18:39:07 <Welkin> unfortunately, a lot of the companies I spoke with who use some kind of functional language were not very good
18:39:22 <Welkin> not that any of the mediocre java/.net/python ones were either
18:39:57 <dmj`> EvanR: :) 
18:40:06 <frontendloader> theres a lot of opportunity with Phoenix/Elixir now
18:40:11 <frontendloader> thats starting to take off
18:40:17 <frontendloader> not haskell, but still
18:40:32 <EvanR> i support the elixir fandom here in new orleans
18:40:36 <Welkin> frontendloader: I looked into it, and it is not looking good
18:40:45 <Welkin> phoenix is basically rails for elixir
18:40:51 <Welkin> with all of the problems/baggage of rails
18:40:59 <EvanR> but none of the performance issues
18:41:05 <EvanR> and none of the ruby
18:41:47 <Welkin> I don't see a reason to use elixir (or plain erlang for that matter) when you can use haskell
18:42:01 <Welkin> there are few, if any, situations where you gain an advantage using it
18:42:24 <Welkin> most people's web apps are not telecom infrastructure
18:42:27 <EvanR> any sort of functional-ish anything, if people get into it, will lead them to haskell, which leads them to leave the industry and pursue a PhD. mission accomplished
18:43:09 <iqubic> So, anyone know the right way to do graphics in gi-gtk?
18:43:15 <ertes> erlang does have a few advantages though like very good support for distributed programming and online migrations
18:43:32 <ertes> in comparison cloud haskell is pretty much a toy
18:43:43 <iqubic> I was thinking of using gloss, but then I decided I wanted a more sophisticated UI
18:43:52 <EvanR> cloud haskell has to deal with the fact that its haskell
18:44:04 <ertes> it has to deal with the fact that it's GHC
18:44:11 <iqubic> So I decided to use gi-gtk, but now I need a way to graphics in gi-gtk.
18:44:14 <EvanR> "cloud" anything = IO
18:44:21 <Welkin> to say the least, one startup I spoke with (that was using elixir) had their product manager call me, and she asked me some mind-bogglingly stupid questions that made no sense
18:44:25 <EvanR> which has no abstract form!
18:44:26 <ertes> IO is not really the problem
18:44:41 <ertes> erlang has IO, too…  it just doesn't know it =)
18:45:07 <EvanR> erlang is permanently in IO, any expression could evaluate to cause a message pass
18:45:28 <Welkin> so you can't judge a company by the languages they use
18:45:49 <EvanR> or an IO error
18:48:06 <iqubic> So no one knows how to do graphis in gi-gtk in haskell?
18:48:38 <monochrom> I say that people dig Elixir because they secretly dig dynamic typing.
18:48:57 <Welkin> the vast majority of the elixir community are ruby programmers
18:48:59 <Welkin> so it's no surprise
18:49:14 <Welkin> it was made to look like ruby even
18:49:17 <hamishmack> iqubic: https://github.com/haskell-gi/gi-gtk-examples/tree/master/fastdraw
18:49:37 <monochrom> Basically finally a Scheme that doesn't use s-expression syntax.
18:50:15 <hamishmack> iqubic: This might also be useful https://github.com/haskell-gi/gi-gtk-examples/blob/master/carsim/CarSim.hs
18:51:14 <iqubic> Why is that so confusing?
18:51:24 * ski . o O ( SRFI 49,"Indentation-sensitive syntax" by Egil Möller in 200[34] at <https://srfi.schemers.org/srfi-49/srfi-49.html> )
18:51:51 <iqubic> Why is graphics in Haskell-gi so confusing and hard?
18:52:32 <ertes> iqubic: what's the use case?
18:53:17 <hamishmack> There is a bit of a disconnect between the gi-gtk (which has GObject introspection) and cairo (which does not)
18:53:25 <hamishmack> The key is this https://github.com/haskell-gi/gi-gtk-examples/blob/master/fastdraw/FastDraw.hs#L81
18:54:43 <hamishmack> It takes you from gi-gtk land into cairo’s Render monad
18:56:53 <iqubic> How does that work?
18:57:49 <hamishmack> onWidgetDraw canvas $ \(Context fp) -> withManagedPtr fp $ \p -> (`runReaderT` Cairo (castPtr p)) $ runRender $ do …
18:58:47 <iqubic> Yes, I see it.
18:58:57 <iqubic> It's a callback function.
18:59:01 <hamishmack> canvas is Gtk DrawingArea you want to draw on
18:59:08 <iqubic> Sure. I get that.
18:59:22 <iqubic> And this is the Drawing function.
18:59:26 <hamishmack> It hooks the widget draw event
19:00:35 <hamishmack> So you can use http://hackage.haskell.org/package/cairo-0.13.3.1/docs/Graphics-Rendering-Cairo.html
19:00:45 <hamishmack> To draw on the widget
19:02:10 <hamishmack> Or you could use something else that works on top of cairo like https://hackage.haskell.org/package/diagrams-cairo
19:03:14 <iqubic> hamishmack: Will that also provide me the framework to create a GUI?
19:04:18 <iqubic> Also, what is the diagrams-rasterific that hackage page mentions?
19:04:46 <iqubic> Nevermind, I found that.
19:04:48 <hamishmack> Sorry perhaps I missunderstood what you meant when you said “but now I need a way to graphics in gi-gtk”
19:05:08 <iqubic> hamishmack: That is what I mean.
19:05:38 <iqubic> I want a way to have a gi-gtk application with gtk widgets and a way to draw graphics at the same time.
19:06:09 <hamishmack> Cool.  gi-gtk itself will let you create a lot of cool UI widgets
19:06:11 <minn> There is a graphic (maybe the cover of a journal or book) where the logical connectives 'morph' into their corresponding types. I can't find this anywhere via Google. I thought someone here might have it stored away.
19:06:49 <hamishmack> the DrawingArea widget gives you an easy way to draw stuf as well
19:06:56 <hamishmack> inside the bounds of the widget
19:07:11 <hamishmack> There are ways to draw over the top of stuff too IIRC
19:07:16 <iqubic> Will diagrams-cairo work with a DrawingArea Widget?
19:07:27 <hamishmack> Yes
19:07:44 <iqubic> The I have a working solution to my problem.
19:07:51 <hamishmack> You will need that magic onWidgetDraw line
19:08:15 <hamishmack> and then from there you should be able to call diagrams-cairo
19:08:27 <iqubic> What magic onWidgetDraw line?
19:10:37 <iqubic> Why not just use this
19:10:45 <iqubic> @hackage gi-cairo
19:10:45 <lambdabot> http://hackage.haskell.org/package/gi-cairo
19:10:54 <hamishmack> onWidgetDraw canvas $ \(Context fp) -> withManagedPtr fp $ \p -> (`runReaderT` Cairo (castPtr p)) $ runRender $ do …
19:11:15 <iqubic> hamishmack, I'll need to pick that apart sometime.
19:11:32 <iqubic> But is Diagram-Cairo any better that gi-cairo?
19:11:41 <hamishmack> cairo does not come with GObject introspection data, so gi-ciaro is almost completely empty
19:11:58 <hamishmack> just has a few types, non of the functions
19:12:23 <iqubic> Oh. So I should use Diagrams-Cairo instead?
19:12:45 <iqubic> Now how does that magic onWidgetDraw line work?
19:12:56 <iqubic> WHat exactly is that lamba doing?
19:13:13 <hamishmack> diagrams-cairo or https://hackage.haskell.org/package/cairo directly
19:13:42 <iqubic> What's the difference between the two packages?
19:14:09 <iqubic> And what is that lambda doing there in the onWidgetDraw function?
19:14:20 <hamishmack> diagrams is a higher level draing library
19:14:54 <hamishmack> It is unpacking the gi-cairo type
19:15:05 <hamishmack> it then gets cast to a https://hackage.haskell.org/package/cairo type
19:15:35 <iqubic> hamishmack: Why is it so complex though?
19:15:50 <hamishmack> We should have a helper function somewhere
19:15:58 <hamishmack> the problem is there is no good place to put it
19:16:12 <iqubic> So we don't have a helper function?
19:16:45 <iqubic> Why is the unpacking of the gi-cairo type so complex?
19:17:16 <iqubic> So if I want to use that magic onWidgetDraw line, what do hackage packages do I need?
19:17:33 <iqubic> And what comes after the do at the very end of that line?
19:17:54 <hamishmack> gi-gtk and cairo (probably gi-cairo too just for the types)
19:18:11 <hamishmack> https://github.com/haskell-gi/gi-gtk-examples/blob/master/fastdraw/FastDraw.hs#L81
19:20:01 <hamishmack> If you are going to use diagrams-cairo you may just need onWidgetDraw canvas $ \(Context fp) -> withManagedPtr fp $ \p -> let cairo = Cairo (castPtr p) in …
19:20:25 <iqubic> hamishmack: I am not going to use diagrams-cairo.
19:21:00 <iqubic> So I guess I need that magic line. 
19:21:16 <iqubic> As much as I want to know how it works, I don't think I will be able to.
19:21:43 <iqubic> I'll just treat like a black box function for now.
19:21:59 <hamishmack> Its basically an ungly cast from something we know is a pointer to a cairo context to another thing we know is a cairo context
19:22:12 <hamishmack> s/ungly/ugly/
19:22:31 <iqubic> So it uses FFI to do the cast?
19:22:54 <hamishmack> We could make a nicer cast function but it would have to live in a gi-gtk-cairo package or something like that
19:23:02 <iqubic> I see.
19:23:14 <hamishmack> to avoid adding unecessary dependencies
19:23:22 <iqubic> So, what type should the drawing function at the end be?
19:23:31 <hamishmack> Render ()
19:23:46 <iqubic> Cool.
19:24:17 <iqubic> And then why are we using return true?
19:24:38 <hamishmack> Oh yes sorry Render Bool
19:24:47 <hamishmack> Not sure if the return value is used
19:25:18 <iqubic> I think it is, but I'm not sure.
19:25:46 <iqubic> It is used.
19:26:20 <iqubic> A return of true tells GTK that we have finished processing onWidgetDraw.
19:26:44 <iqubic> And no other callback functions should be called for this widget and event.
19:27:06 <hamishmack> https://developer.gnome.org/gtk3/stable/GtkWidget.html#GtkWidget-draw
19:27:50 <iqubic> So the output is used.
19:27:57 <hamishmack> Yes
19:28:34 <iqubic> What is that statement about the Widget's UL corner must be painted at the origin?
19:29:35 <iqubic> hamishmack: Thank you so much for your help. However, now I must go. Sorry for leaving.
19:29:56 <hamishmack> No worries.  Good luck.
20:02:01 <kernelj_arch> it compiles and... it works for 3 out of 12 test cases!!!
20:02:39 <kernelj_arch> great, now I have to guess what's wrong with it
20:03:35 <kernelj_arch> at least it doesn't time out
20:09:30 <fresheyeball> so I just want to do a small thing with ghcjs
20:09:34 <fresheyeball> and its freakn' baffling
20:10:00 <fresheyeball> source code says
20:10:05 <fresheyeball> type MonadDOM = IO
20:10:15 <fresheyeball> err sorry
20:10:22 <fresheyeball> type MonadDOM = MonadIO
20:10:32 <fresheyeball> but when I try to use it in practice
20:10:40 <fresheyeball> with an IO Monad
20:10:53 <fresheyeball> I get No instance for (MonadDOM IO)
20:10:56 <fresheyeball> how is that possible?
20:11:16 <hamishmack> Are you compiling with GHC?
20:11:58 <hamishmack> When compiled with ghc (instead of ghcjs) MonadDOM is not MonadIO
20:12:18 <fresheyeball> I am compiling with GHC
20:12:38 <hamishmack> Instead it is a reader monad that has the javascript context
20:13:07 <hamishmack> You may need to choose a JSaddle runner package
20:13:39 <hamishmack> For instance jsaddle-warp, jsaddle-webkit2gtk or jsaddle-wkwebview
20:13:43 <fresheyeball> Would it be possible to get the hello world example updated?
20:13:51 <fresheyeball> thats all I want
20:13:57 <fresheyeball> also got to go ttyl
20:14:04 <hamishmack> They each have “run” functions
20:14:22 <hamishmack> Is ghcjs-dom-hello broken?
20:15:23 <hamishmack> The run functions take a JSM () and turn it into IO ()
20:17:51 <kernelj_arch> my god, I built the tree wrong, what a disaster
20:17:53 <hamishmack> The MonadDOM and DOM in ghcjs-dom are really just MonadJSM and JSM (there is a historic reason for the different name, but they are the same now)
20:18:10 <thang1> kernelj_arch: lol I do that all the time, no worries :p
20:19:53 <kernelj_arch> passed with flying colours, I forgot to add the size of the tree to the right to the size on the left
20:20:14 <thang1> is it just a normal BST?
20:20:28 <kernelj_arch> no it's a weird one
20:20:59 <thang1> Never heard of a Weird tree :p
20:22:41 <kernelj_arch> I have both leaf and emptybranch leaf nodes along with the node nodes
20:23:05 <kernelj_arch> and the nodes store the min&max of all the nodes underneath along with the count of leaves
20:24:20 <thang1> what's the difference between leaf and emptybranch leaf?
20:24:27 <lpaste> halogenandtoast pasted “DigestPassword.hs” at http://lpaste.net/355057
20:24:41 <halogenandtoast> Is there any good way to combine those into one line? ^^
20:24:43 <kernelj_arch> a leaf has a value inside it and is counted as a leaf, the emptybranch is more like a null
20:24:45 <halogenandtoast> or clean it up at least?
20:25:43 <thang1> kernelj_arch: you don't need to represent a null in haskell. The leaf signifies that it's the last one so it's useless redundancy to have a null leaf?
20:26:11 <kernelj_arch> halogenandtoast: I think you can use the Maybe monad
20:26:12 <thang1> Like, a node is either "I am a node with data and have at least one child" or "I am a node with data and have no children"
20:26:51 <halogenandtoast> kernelj_arch: What do you mean by that?
20:27:07 <thang1> http://stackoverflow.com/questions/19655870/simplifying-nested-maybe-pattern-matching
20:27:13 <thang1> check this out, halogenandtoast 
20:27:32 <kernelj_arch> thang1: the emptybranch signifies that there isn't a last one
20:27:49 <thang1> As in, it's an infinite tree?
20:28:01 <glguy> halogenandtoast: digestPassword x :: IO (Maybe SomeDigest) ?
20:28:14 <halogenandtoast> glguy: IO (Maybe Text)
20:29:39 <glguy> halogenandtoast: If there was more going on that this you could use MaybeT IO, but the syntactic overhead is too high in this small case
20:30:24 <halogenandtoast> Okay, I'm actually fine with this being the simplest solution I just keep feeling like I could use fmap and it keeps ending up with the wrong type.
20:31:10 <kernelj_arch> what type do you get?
20:31:36 <halogenandtoast> well, step by step I tried `  digest <- digestPassword <$> password
20:32:21 <halogenandtoast> Couldn't match type ‘Maybe’
20:32:23 <halogenandtoast>                      with ‘HandlerT Auth (HandlerT site IO)’
20:32:39 <kernelj_arch> yeah you're doing that wrong
20:32:51 <halogenandtoast> I didn't think I was doing it right :p
20:32:52 <kernelj_arch> lookupPostParam "password" is the Maybe value
20:33:02 <kernelj_arch> so that goes on the rhs of the fmap
20:33:31 <kernelj_arch> liftIO . digestPassword <$> lookupPostParam "password"
20:34:22 <halogenandtoast> kernelj_arch: your solution produces
20:34:22 <halogenandtoast> Couldn't match type ‘Maybe Text’ with ‘Text’
20:34:22 <halogenandtoast>       Expected type: Maybe Text -> Maybe Text
20:34:23 <halogenandtoast>         Actual type: Text -> Maybe (Maybe Text)
20:36:20 <kernelj_arch> oh is this inside a do
20:36:30 <halogenandtoast> yes
20:36:37 <halogenandtoast> isn't it always :p
20:39:02 <kernelj_arch> I think having a Maybe (Maybe x) is bad, you can use 'join' on it
20:48:09 <halogenandtoast> Okay, not sure where to use join, I'll probably stick with what I have and revisit it when I learn more.
20:53:25 <lyxia> :t (fmap . fmap) join . traverse
20:53:27 <lambdabot> (Applicative f, Traversable m, Monad m) => (a1 -> f (m a)) -> m a1 -> f (m a)
20:54:11 <thang1> oooh talk burrito me, baby, aww yiss
20:54:51 <lyxia> :t maybe (return Nothing)
20:54:52 <lambdabot> Monad m => (a1 -> m (Maybe a)) -> Maybe a1 -> m (Maybe a)
21:07:18 <thang1> hmm...
21:07:40 <thang1> can I just put a link to a google doc in the submission part of the haskell summer of code bit?
21:25:13 <sophiag`> i went through Huet's Zipper paper and translated the code from OCaml (which i hardly know) and it was mostly pretty easy except for this one function that uses a recursive where expression that doesn't make any sense to me. here's the code with the function in question on line 44 if anyone is willing to take a look: https://gist.github.com/Sophia-Gold/2562237e6f1964ce7edb30dcb6027db1
21:26:54 <sophiag> there was also a function using an @ symbol, which i couldn't find in any OCaml references but based on context assumed was an infix concat. not sure if i'm correct abou that though...
21:27:43 <Axman6> something definitely looks odd there. can you add the ocaml version? (and maybe give the gist a .hs file name so it gets syntax highlighting)?
21:28:00 <Axman6> oh I'm an idiot, it's thete
21:28:01 <sophiag> the OCaml version is right beneath it
21:28:01 <Axman6> there*
21:28:08 <sophiag> good call on syntax highlighting tho
21:28:34 <Axman6> I think you have the wype wrong, looks like it should be nth :: Location a -> Int -> Either String (Either String (Location a))
21:28:53 <sophiag> it does...except the OCamL version only takes one argument
21:28:56 <Axman6> man, can't type at all today
21:29:02 <sophiag> that's what confused me
21:29:14 <sophiag> it seems it should be nth Loc n = nthrec n
21:29:21 <geekosaur> I don;t see where n is supposed to come from there... but suspect it should be loc
21:29:30 <geekosaur> er, x
21:29:36 <sophiag> err actually wait not exactly (referring to my last comment)
21:29:50 <sophiag> n is the depth of the node it's looking for
21:31:20 <sophiag> and x actually represents a tuple since Location is a product type...
21:38:51 <ski> sophiag : yes, `@' would be `++' in Haskell
21:41:35 <ski> sophiag : no, it shouldn't be `nth Loc n = nthrec n' (or rather, that wouldn't help .. though i guess it strictly speaking wouldn't hurt either). instead of `nthrec = case n of' you want `nthrec n = case n of'
21:41:41 <iqubic> It looks correct.
21:41:52 <iqubic> Not sure what the issue is.
21:42:21 <sophiag> ski: right, that's why i corrected myself
21:42:25 <ski> if you enable `LambdaCase', then you could say instead `nthrec = \case of'
21:42:32 <ski> `\case' corresponds to `function'
21:43:25 <iqubic> What's LambdaCase? Is it a language pragma?
21:43:25 <sophiag> right i figured something like \n -> case n of
21:44:21 <ski> iqubic : it's a language extension
21:44:29 <ski> sophiag : aye, also works
21:44:34 <sophiag> ski: but then do i need to change the type signature? i'm not sure where the n comes from in nth (Loc x) = nthrec n
21:45:10 <ski> no, it should be `nth (Loc x) = nthrec', as you had it in the gist
21:45:16 <ski> no `n' there
21:45:44 <iqubic> So then where does the n come from
21:45:44 <ski> i'm wondering whether you want to use `error' in place of `failwith' ..
21:45:55 <ski> iqubic : from `nthrec'
21:46:02 <sophiag> yeah it would make more sense to use Maybe than Either, but i was trying to be faithful to the original
21:46:25 <sophiag> but i'm still confused about "where nthrec = \n -> case n of 
21:46:50 <iqubic> It's a where binding. Not sure how the n gets there though
21:46:51 <ski> `nthrec' is a function
21:46:59 <iqubic> Yes, it is.
21:47:11 <sophiag> i just mean it's not compiling. could be the type signature
21:47:16 <ski> `nth (Loc x)' will return `nthrec', a function, that expects a further argument (called `n' in there)
21:47:17 <iqubic> Defined in that where statement
21:47:53 <ski> i suppose something like
21:47:59 <ski>   nth :: Location a -> Integer -> Either String (Either String (Location a))
21:48:08 <ski> .. though it might be better to use
21:48:11 <ski>   nth :: Location a -> Integer -> Either String (Location a)
21:48:34 <ski> if you want it to be pretty faithful, while using `Either' for the failures
21:48:36 <iqubic> And that's the correct type signature for the function.
21:49:06 <sophiag> i'm still getting errors
21:49:08 <ski> but then you shouldn't wrap the `goDown' and `goRight' calls in `Right'
21:49:23 <ski> because those calls will themselves decide whether to return `Left' or `Right'
21:49:27 <sophiag> ah there we go
21:49:39 <ski> this way, you'll be merging the different failure conditions into the same `Left ...'
21:49:42 <sophiag> right, that's why i had them wrapped in _two_ Eithers before
21:49:55 <sophiag> the answer is no Eithers because they're already in the other signature
21:50:03 <sophiag> or rather no constructors
21:50:04 <ski> rather than having both `Left ...' and `Right (Left ...)' as failure cases (and `Right (Right ...)' as success case)
21:50:54 <iqubic> Yes, that sound good.
21:51:09 <iqubic> OCaml sounds like a pain to work with, I'd have to say
21:51:29 <ski> it's not that bad, i think
21:51:40 <sophiag> yeah i like OCaml
21:51:51 <sophiag> don't confuse my ignorance in reading it with the language :)
21:52:40 <ski> it seems there's two classes of failure cases here
21:53:01 <sophiag> hmm. even with all the Right constructors moved GHC still expects it to return Location a 
21:53:27 <iqubic> What's the type signature you have for that function currently?
21:53:28 <ski> on the one hand, failure classes that could reasonably be avoided by making sure to fulfil the preconditions (like passing a positive integer to `nth')
21:53:43 <ski> s/failure classes/failure cases/
21:54:33 <ski> on the other hand, failure cases that it seems couldn't reasonably always be avoided in bugfree code (like going up from the top)
21:55:17 <iqubic> So what is the right way to write this function?
21:55:23 <ski> the latter might be nicely expressed by `Maybe' (or `Either', but preferably not with `String' as describing the failure condition) in Haskell
21:55:27 <ski> @quote stark
21:55:27 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21:55:39 <ski> the former could well use `error' instead, i think
22:01:49 <sophiag> ski: Either vs. Maybe doesn't explain why this is one function isn't compiling though
22:02:40 <ski> i don't know how your code looks currently
22:03:58 <sophiag> here's the updated version: https://gist.github.com/Sophia-Gold/2562237e6f1964ce7edb30dcb6027db1
22:06:15 <biglambda> Why would all of my values be less than one if I’m generating random CFloats?
22:07:01 <biglambda> using System.Random for fuzz testing.
22:07:19 <biglambda> So I’m hoping to have the full range of values.
22:08:21 <ski> sophiag : ah, i see :)
22:08:23 <sophiag> biglambda: how would you generate random floats over an arbitrary range?
22:08:44 <ski> `goRight $ nthrec (n-1)' should be `goRight =<< nthrec (n-1)'
22:08:46 <biglambda> I’m just using the standard instance of Random
22:09:27 <sophiag> i'm just saying it doesn't make much sense to have random floats in a range of say 1..100. i suppose you mean a random integer 0-9 for each digit of precision over that range?
22:10:01 <sophiag> ski: thanks. sadly, i think i never would have picked up on that
22:10:19 <biglambda> Well I’m fuzz testing so I want the FULL range of possible values.
22:10:22 <sophiag> because goRight returns an Either monad i need to bind the value to it?
22:10:37 <biglambda> I need to see if any inputs to my system can crash it.
22:10:39 <sophiag> err function, not value
22:10:49 <ski> sophiag : yes. you could also manyally `case' on it, but using `=<<' is simpler. it's what it's intended for
22:10:52 <sophiag> biglambda: just scale it up to the range you need
22:11:11 <ski> sophiag : well, an `Either'-action, not an `Either' monad
22:11:27 <ski> (or an `Either String'-action, to be pedantic)
22:12:00 <sophiag> can you explain that distinction?
22:12:27 <ski> `Either String' is a monad
22:12:49 <ski> a value of type `Either String T', for some type `T' (in your case `Location a'), is not a monad
22:12:52 <ski> it's a monadic action
22:13:09 <sophiag> oh interesting. i never realized that
22:13:18 <ski> monads are not run-time things
22:13:36 <sophiag> could you say the same for Maybe and the Just type?
22:13:40 <ski> there is only a single `Maybe' monad. but many values of type `Maybe T' (assuming `T' has some values)
22:13:56 <ski> `Maybe' is a type. `Just' is not a type, it's a value
22:14:07 <ski> `Maybe' is a type constructor. `Just' is a data constructor
22:14:13 <ski> all data constructors are values
22:14:55 <sophiag> i mean the value constructed by Just. returning that would be an action of the Maybe monad?
22:15:08 <sophiag> i suppose it's quite obvious when i put it that way
22:16:01 <ski> the value itself is a `Maybe'-action
22:16:23 <ski> `Nothing' is a `Maybe'-action, that represents failure to compute a result
22:16:39 <ski> `Just x' is a `Maybe'-action, that represents success to compute the result `x'
22:17:08 <ski> `Maybe' is a monad for expressing possible failure to compute a result (but no further information in case of failure)
22:17:52 <sophiag> right, got it
22:17:53 <ski> `Either E' tags failures with values of type `E'
22:18:13 <andersamer> hello
22:18:17 <Maxdamantus> I'd say to be more accurate, the thing defined when you write `instance Monad Maybe` is a monad.
22:18:35 <ski> for lists, `[]' (the empty list value) is a `[]'-action, representing no solutions being computed
22:18:46 <ski> `[x]' represents a single solution, `x', being computed
22:18:49 <ski> and so on
22:18:49 <Maxdamantus> "here is a Monad Maybe: return = Maybe; (>>=) = .."
22:19:07 <Maxdamantus> er, return = Just
22:19:14 <ski> yes, the monad is `Maybe', together with the implementation of `return' and `(>>=)', satisfying the laws
22:19:23 <ski> for short, we say "the monad `Maybe'"
22:19:32 <Maxdamantus> I'd say "the Maybe monad"
22:19:39 * ski nods
22:19:44 <Maxdamantus> Because Maybe itself is not a monad. It's just a type constructor.
22:20:04 <ski> but since we're using the type class system, each type, like `Maybe' can be associated in at most one way to such implementations
22:20:30 <ski> so the type serves to uniquely identify the monad, in Haskell's type class system
22:20:36 <Maxdamantus> You could theoretically (maybe not in Haskell) have a type constructor defined like `type Identity x = x` then have an "identity monad" that would be defined using `instance Monad Identity`
22:21:03 <ski> hello andersamer
22:21:05 <Maxdamantus> return = id; (>>=) = id
22:21:33 <ski> `(>>=) = flip ($)', rather
22:23:35 <Maxdamantus> ah yes, that.
22:24:14 * Maxdamantus sometimes imagines the function to be the first argument.
22:25:19 * andersamer stares in awe at the level of intelligence of the people on #haskell
22:25:28 <sophiag> wait, why would it be like reverse application in that case?
22:26:17 <ski>   (>>=) :: Identity a -> (a -> Identity b) -> Identity b
22:26:25 <ski>   (>>=) :: a -> (a -> b) -> b
22:26:25 <Maxdamantus> well, if you imagine `map :: (a -> b) -> a -> b`, `map f` is the same as `f`
22:26:45 <Maxdamantus> and in the identity monad, `map` is the same as `bind`
22:26:53 <ski> andersamer : .. did you have a question ?
22:27:07 <Maxdamantus> but since you have `a -> (a -> b) -> b` in Haskell, you have to flip the application around.
22:27:27 <sophiag> so it's because in the case of identity you want to return a not b?
22:27:40 <andersamer> ski no sorry i kinda just wanted to see this channel for a bit 
22:27:44 <johnw_> Maxdamantus: in non-Haskell, you can certainly do that
22:27:49 * ski will leave this one for Maxdamantus ..
22:28:03 <Maxdamantus> johnw_: yeah, I know.
22:28:04 <ski> andersamer : feel free to lurk
22:28:25 <Maxdamantus> The only reason it doesn't make sense in Haskell is because Haskell wants to infer the instance from types.
22:29:09 <Maxdamantus> and then whenever you write `a >>= b`, it could just decide to use the identity monad if it allowed such ambiguous instances.
22:30:05 <Maxdamantus> sophiag: it's just a matter of input order.
22:30:43 <Maxdamantus> sophiag: in Haskell you have `(>>=) action fn` rather than `(>>=) fn action`
22:33:09 <sophiag> ah i see. realistically though, you wouldn't want an identity Monad so that wouldn't be an issue
22:33:42 <johnw_> why wouldn't you want one?
22:33:59 <Maxdamantus> Well, an identity monad is useful when you're writing monad combinators.
22:34:39 <Maxdamantus> and it does exist in mtl, but it has something like `newtype Identity a = Identity a`
22:34:57 <johnw_> or any time you need to prove a functor, but don't need one; it turns monad transformers into plain monads, for example
22:35:01 <johnw_> s/prove/provide
22:35:30 <Maxdamantus> Yeah, it's sort of like thinking about the unit type/value
22:35:35 <johnw_> exactly
22:35:36 <Maxdamantus> it's useless at some level.
22:35:49 <johnw_> zero doesn't seem very useful for doing addition, until it totally is :)
22:35:56 <Maxdamantus> but if you're trying to use parametric code it's potentially useful.
22:36:19 <johnw_> it's the mempty of the endfunctor world
22:37:09 * ski idly ponders functors between categories of ends
22:38:43 <sophiag> johnw_: that's a very good way of thinking about it
22:40:13 <johnw_> it's not just a metaphor
22:40:27 <johnw_> there's a category in which Identity actually is the moral equivalent to what "mempty" means
22:43:30 <sophiag> do you just mean the category of endofunctors or more specifically?
22:43:50 <sophiag> lists?
22:44:24 <johnw_> there's a monoidal category where monads are represented as the monoid object "(Endo[Hask], Identity, Compose)"
22:45:55 <sophiag> i thought that was the very definition of a monad?
22:46:05 <johnw_> it's one definition
22:46:29 <johnw_> there's another in terms of adjunctions, where you don't talk about monoids that much
22:47:56 <sophiag> i think that's how they're defined in the Catsters videos, which was a bit confusing for me. i need to rewatch that section
22:48:17 <johnw_> yeah, the adjunction approach is a bit more "fundamental"
22:48:28 <johnw_> since the monoid object approach only deals with the composite functor of the two adjoints
22:49:03 <retry> I'm using intero on emacs, the dropdown menus specific to intero are blank. Why is this ?
23:59:07 <retry> Anybody here use intero ?
