00:00:34 <joneshf-laptop> halogenandtoast, Is it safe to assume that `getPosition` as you wrote it type checks?
00:00:35 <tsahyt> I've been playing around with this sort of thing for a while now and I'm getting more and more convinced that there's a sort of triviality threshold where stronger guarantees just don't pay anymore as the machinery necessary to get them just outpaces all the benefits
00:01:00 <tsahyt> especially when you're dealing with things that can be verified via equational reasoning in a matter of minutes
00:01:12 <joneshf-laptop> tsahyt, i love that sentiment
00:02:03 <tsahyt> It turns out that liquid haskell can verify equational reasoning proofs though. in principle anyhow, in practice I've found a few bugs with that.
00:02:10 <halogenandtoast> joneshf-laptop: getPosition type checked
00:02:12 <tsahyt> but it's still improving I think
00:02:18 <halogenandtoast> I feel like I'm "closer" now: getMove = MaybeT (Reveal . parsePosition <$> getInput) <|> getMove
00:02:22 <halogenandtoast> still wrong but closer
00:02:37 <halogenandtoast> Expected type: Maybe Position -> IO (Maybe Move) Actual type: Position -> Move
00:04:24 <joneshf-laptop> halogenandtoast, so `(parsePosition <$> getInput) :: IO (Maybe Position)` yeah?
00:04:36 <halogenandtoast> Yes
00:05:00 <joneshf-laptop> And `Reveal :: Position -> Move`, yeah?
00:05:05 <halogenandtoast> correct
00:05:33 <joneshf-laptop> :t fmap . fmap
00:05:34 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
00:06:46 <halogenandtoast> hmm
00:07:34 <halogenandtoast> Okay that works, I sort of get it, but it's definitely on the fringes for me.
00:07:41 <halogenandtoast> getMove = MaybeT ((fmap . fmap) Reveal (parsePosition <$> getInput)) <|> getMove
00:08:06 <halogenandtoast> ah I could rewrite that I assume
00:08:12 <joneshf-laptop> Yep!
00:08:25 <joneshf-laptop> :t (<$>) <$> (<$>)
00:08:26 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
00:08:31 <joneshf-laptop> :P
00:08:37 <halogenandtoast> getMove = MaybeT (fmap Reveal <$> (parsePosition <$> getInput)) <|> getMove
00:09:27 <halogenandtoast> joneshf-laptop: I have no idea what you just wrote there. I would have assumed that was three fmaps...
00:09:44 <halogenandtoast> of
00:09:49 <halogenandtoast> <$> for functions is just .
00:09:53 <halogenandtoast> s/of/oh/
00:10:03 <joneshf-laptop> Yep!
00:10:50 <halogenandtoast> Is there any subjectively cleaner way to write: getMove = MaybeT (fmap Reveal <$> (parsePosition <$> getInput)) <|> getMove
00:11:00 <halogenandtoast> perhaps with less parens
00:11:26 <joneshf-laptop> I'd say change the first `(<$>)` to `(.)`
00:11:46 <joneshf-laptop> wait, is that right?
00:11:50 <halogenandtoast> but the rhs is not a function
00:11:51 <joneshf-laptop> that's probably not right.
00:12:18 <halogenandtoast> my limited knowledge says it's not right.
00:12:19 <joneshf-laptop> what typeis `parsePosition`?
00:12:26 <Zemyla> Isn't a <$> (b <$> x) = (a . b) <$> x?
00:12:27 <halogenandtoast> parsePosition :: String -> Maybe Position
00:13:12 <halogenandtoast> Zemyla: yes
00:14:01 <halogenandtoast> that would look like
00:14:01 <halogenandtoast> getMove = MaybeT ((fmap Reveal . parsePosition) <$> getInput) <|> getMove
00:14:03 <Zemyla> :t \a b x -> ((a <$> b) <$> x) `asTypeOf` (a <$> (b <$> x))
00:14:05 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
00:14:35 <Zemyla> So the free theorem basically says that fmap is associative?
00:14:57 <halogenandtoast> err
00:14:58 <halogenandtoast> getMove = MaybeT (fmap Reveal . parsePosition <$> getInput) <|> getMove
00:16:36 <halogenandtoast> that's slightly better. Thanks joneshf-laptop and Zemyla 
00:16:49 <Zemyla> halogenandtoast: Couldn't you go getMove = fmap Reveal $ let x = MaybeT (parsePosition <$> getInput) <|> x in x?
00:17:08 <joneshf-laptop> halogenandtoast, I feel like I didn't really explain how to arrive at it, but instead just blurted an answer.
00:17:08 <Zemyla> SinceReveal seems to be a data constructor mapping over the Maybe?
00:17:28 <halogenandtoast> joneshf-laptop: that's true, I planned on messing with fmap . fmap a bit more.
00:17:53 <halogenandtoast> Zemyla: not sure that will work when I add another Alternative
00:18:21 <halogenandtoast> actually pretty sure I'm going to have to change a lot once I try to add another Alternative :(
00:18:53 <joneshf-laptop> Hmm, well.
00:19:20 <halogenandtoast> because the next Alternative depends upon the result of getInput
00:21:33 <halogenandtoast> and found myself in an infinite loop again
00:21:34 <halogenandtoast> blarg
00:21:40 <halogenandtoast> getMove = do
00:21:41 <halogenandtoast>   input <- liftIO getInput
00:21:41 <halogenandtoast>   MaybeT (return . fmap Reveal . parsePosition $ input) <|> getMove
00:22:27 <joneshf-laptop> I'm sorry.
00:22:51 <joneshf-laptop> I hope someone else cna provide a more in depth explanation that actually helps you understand.
00:23:13 <halogenandtoast> No worries
00:23:35 <halogenandtoast> thanks for all you have explained joneshf-laptop 
00:23:53 <Zemyla> halogenandtoast: Why not do getMove = liftIO getInput >>= maybe getMove (return . Reveal) ?
00:24:55 <Zemyla> That's what MaybeT would be doing internally anyways.
00:25:00 <halogenandtoast> Zemyla: because there are multiple moves that need t be parsed
00:25:08 <halogenandtoast> *to I just haven't added them yet
00:26:02 <halogenandtoast> so if one parse fails, I want it to use the Alernative parsing
00:26:06 <halogenandtoast> *Alternative
00:27:34 <halogenandtoast> I'm assuming it's something similar to this
00:27:35 <halogenandtoast>   MaybeT (return . fmap Reveal . parsePosition $ input) <|> MaybeT (return . fmap PlaceFlag . parseFlagPosition $ input) <|> getMove
00:28:36 <halogenandtoast> but that is wrong
00:44:49 <osa1> does lens have an operator for `fmap . view` ?
00:48:01 <quchen> :t fmap . view
00:48:03 <lambdabot> Functor f => Getting b s b -> f s -> f b
00:48:17 <quchen> :t views
00:48:18 <lambdabot> MonadReader s m => LensLike' (Const r) s a -> (a -> r) -> m r
00:48:27 <ph88_> good morning all
00:48:38 <quchen> osa1: Hmm, maybe that’s it. Maaaybe.
00:48:49 <quchen> :t [fmap . view, views]
00:48:50 <lambdabot> [Getting s s s -> (s -> s) -> s -> s]
00:48:53 <quchen> Wooo! :-)
00:49:00 <osa1> nice
00:49:05 <quchen> But that can’t change the result type. Hmm.
00:49:12 <quchen> Anyway, look in the docs next to »view«.
00:49:21 <ph88_> ertes, what timezone are you on ?
00:49:31 <quchen> The examples are much better than the type signatures.
00:49:36 <quchen> osa1: ^
00:50:12 <quchen> ph88_: He’s from central Europe
00:50:31 <quchen> …timezone wise at least.
00:50:40 <quchen> So this includes South Africa. Anyway, that. :-)
00:51:58 <ph88_> i have a large file with data points, and i need a sliding window (i will use a ring-buffer), within the window i need to calculate the difference between min and max like this  http://users.rcn.com/wpacino/jitwtutr/jw-f4.gif  after i done this i need to increase the size of the window and go over the points again. But i figured since i know the next window will be larger than the previous one i only need to look at the previous calculated min/max. What 
00:51:58 <ph88_> kind of data structure is good to store a list where i can remove elements from in the middle?
00:53:49 <halogenandtoast> joneshf-laptop: btw, I didn't have an infinite loop, I wrote my lens incorrectly :(
00:53:55 <halogenandtoast> red herring
00:54:42 <merijn> ph88_: Honestly, I'd probably just use an array and some offsets?
00:54:48 <merijn> ph88_: What's the file format?
00:55:16 <ph88_> merijn, textual
00:55:37 <merijn> ugh :p
00:56:00 <ph88_> merijn, what format would you recommend ?
00:57:00 <pacak> ph88_: For a bigger window you will need to consider already known min/max plus some extra elements right next to that window
00:57:04 <merijn> ph88_: For this specific problem? A binary format of ints/double so you could just mmap the entire thing and it becomes trivial :)
00:57:09 <pacak> so you will have to keep them in memory anyway
00:57:55 <ph88_> pacak, why do i have to consider some extra elements right next to that window ?
00:58:08 <ph88_> merijn, you mean map it directly into memory ?
00:58:27 <merijn> ph88_: Yes, because <3 mmap
00:59:04 <ph88_> nice :P
00:59:14 <pacak> 11211 -- original elements, use window of size 2: 11, 12, 21, 11 and so on. You'll get minmax (1,1), (1,2), (1,2), (1,1)
01:00:10 <pacak> now make window wider - 3 so elements are 111, 112, 121 and 211. for first two elements you already know min/max, but to get min/max for window of size 3 you need to look at 2 as well.
01:01:31 <pacak> merijn: Imagine it's xml. mmap won't help much
01:02:11 <pacak> ph88_: How big is the file?
01:02:43 <ph88_> i have a file right not that's 158 MB and takes more than half an hour to process with an old (non-haskell) program
01:02:49 <ph88_> right now *
01:02:58 <ph88_> but we can generate new files if we do new measurements
01:03:08 <jchia> Is it a known issue that Posix.changeWorkingDirectory fails if the current working directory doesn't exist?
01:03:26 <pacak> ph88_: Just parse it and put into vector.
01:03:37 <jchia> System.Posix.Directory.changeWorkingDirectory
01:04:13 <ph88_> pacak, i didn't understand what you mean before with your example  https://bpaste.net/show/1292a57a5652  i wanted to save the min/max values and their offset
01:04:48 <ph88_> not sure why this little parser doesn't work https://bpaste.net/show/72edcfeb9558
01:05:02 <ph88_> oh maybe because i forgot end of line
01:05:16 <ph88_> hhmm no i put \n and still doesn't work
01:05:17 <pacak> ph88_: I showed min maxes as tuples, you can add their offsets as well
01:05:34 <ph88_> pacak, if i know the offsets i don't need to remember the original data i think
01:05:53 <merijn> pacak: Well, that's why I said I dislike textual formats :p
01:06:17 <pacak> ph88_: Still. When you make window wider - you need to look at new data and compare it with original one
01:06:51 <ph88_> pacak, i just don't see it  .. why i need to look at new data
01:07:41 <pacak> You have a window: 12. You know min, max and indices. Now you want to look at the same data with window of size 3
01:08:00 <pacak> THat'll be [1]12 or 12[1] - with new data added on the left or on the right.
01:13:21 <halogenandtoast> Minesweeper is susprisingly difficult to implement in Haskell
01:13:50 <pacak> ph88_: You have  skipSpace at the end which can take more data
01:14:03 <Cale> I wouldn't expect it to be very different from implementing it in various other languages, at worst.
01:14:04 <halogenandtoast> took me 190 lines of code
01:14:06 <pacak> I'm not sure why you are getting Fail - it supposed to be Partial
01:14:27 <halogenandtoast> well less, because type signatures and newlines and all that.
01:15:35 <pacak> ph88_: Hmm... Actually skipSpace consumes both - spaces and end of line
01:16:23 <pacak> ph88_: use "many1 (satisfy (== ' '))"
01:17:35 <pacak> halogenandtoast: I imagine it would be easier with Comonad...
01:18:34 <ph88_> pacak, here for larger window i reuse the min/max found from previous window without scanning original data  https://bpaste.net/show/1233a064775f
01:19:52 <merijn> halogenandtoast: What makes it so different compared to other languages?
01:20:57 <ph88_> merijn, when you said "just use an array"  you mean Data.Array  ? and why you prefer this over Vector ?
01:21:34 <merijn> ph88_: No, I meant array as in C-like thing, so I guess that'd probably be a Storable vector or whatever they're called
01:22:19 <EvanR> a Ptr a
01:22:39 <ph88_> merijn, if i remove elements from that the whole array needs to be reallocated ?
01:22:43 <merijn> EvanR: Sure, but you probably want a vector wrapper to deal with some of the boiler plate
01:23:10 <merijn> ph88_: Why would you remove elements if you're computing min/max over a window?
01:23:17 <ph88_> halogenandtoast, can i see? i'm a big fan of minesweeper
01:23:50 <ph88_> merijn, because i would like to remove the min/max themselves as the window increases
01:26:23 <ph88_> maybe a linked list is just the best structure here? removing an elements should just be changing a pointer, no ?
01:29:45 <_sras_> Is there any was I can make a haskell evn and ghc-mode and such tools running in a virtual machine communicate with the editor running in my host machine?
01:30:03 <ph88_> pacak, i thought it over, i think you're right i need to look at the original data again :P
01:30:15 <mtesseract> Hmm, haddock renders type classes strange in the presence of -XPolyKinds.
01:30:33 <jle`> it's definitely weird, and it's been going on for a while now
01:31:01 <jle`> it's not really clear what it means either for most normal haskell users
01:31:36 <mtesseract> jle`: the haddock output you mean?
01:31:40 <jle`> yeah
01:33:12 <ph88_> pacak, since i need to re-inspect the original data .. wouldn't it be best if i load it all into memory instead of lazy ?
01:33:22 <mtesseract> jle`: Interestingly there are at least two open issues about this, one from 2014 and one from 2016. I guess the haddock team could use some help, given that they have 200 open issues.
01:33:56 <Cale> mtesseract: Are you referring to the extra kind arguments?
01:34:35 <Cale> It's somewhat understandable why it's rendering them, those are present at a lower level, but usually not visible to the Haskell programmer.
01:34:42 <mtesseract> Cale: Yes
01:34:44 <halogenandtoast> ph88_: sure making a gist
01:35:03 <Cale> But yeah, it's a bug which would be good to fix :)
01:35:30 <ph88_> halogenandtoast, i want to play it xD
01:36:34 <halogenandtoast> ph88_: https://gist.github.com/halogenandtoast/9abb7e0ccd411ac558f0874783f7006d
01:37:18 <merijn> halogenandtoast: I would probably use ADTs rather than record for Square
01:37:19 <halogenandtoast> merijn: I've done a lot of OO languages and having state you can easily change makes some things a lot easier (or more concise at least)
01:37:27 <ph88_> halogenandtoast, does it work with the mouse ?
01:37:28 <merijn> halogenandtoast: This seems like a bunch of boolean blindness :)
01:37:32 <halogenandtoast> ph88_: nope
01:37:36 <ph88_> :/
01:37:41 <halogenandtoast> merijn: curse you and your boolean blindness
01:37:42 <ph88_> i only play minesweeper with mouse
01:38:02 <halogenandtoast> ph88_: but the game logic is abstracted from the UI so you could "trivially" write a gui interface for it
01:38:07 <merijn> halogenandtoast: Why not combine Square and SquareType into a single data type?
01:38:14 <tdammers> well, state that is easy to change is obviously convenient
01:38:25 <pacak> ph88_: Load everything, parse incrementally into a strict vector.
01:38:40 <tdammers> the problem is that without further protection, you'll quickly lose track of who changes state when and in what ways
01:38:48 <halogenandtoast> merijn: This was also a first pass, I've done no refactoring to it yet, a lot of it was learning or messing around with new things
01:39:32 <merijn> halogenandtoast: Sure, these are just suggestions for improvement, not accusations :)
01:39:41 <halogenandtoast> pacak: What did you mean about Comonads?
01:39:53 <ph88_> pacak, do you know how i can change the parser so that it puts stuff in a strict vector ?
01:40:33 <halogenandtoast> brb my computer keeps randomly locking up for a few seconds
01:40:40 <pacak> halogenandtoast: cellular automatas are easy to implement with comonads. minesweeper looks a bit comonadish to me as well.
01:41:19 <pacak> ph88_: Yes.
01:41:23 <merijn> halogenandtoast: btw, do you know brick? It's a library for terminal UIs, you could use that to allow people to select the position to reveal/flag using the cursor, rather than typing in coordinates :)
01:43:02 <halogenandtoast> back reading logs
01:43:29 <halogenandtoast> merijn: I've seen brick
01:43:40 <halogenandtoast> I didn't want to mess with it too much while learning a few other things.
01:43:59 <ph88_> pacak, how can i do it ?
01:44:24 <merijn> halogenandtoast: Just thought it might be neat if you decide to expand this into a 2.0 version :)
01:44:42 <halogenandtoast> merijn: fair enough. Can I probe your mind about Boolean blindness and ADTs?
01:45:09 <merijn> halogenandtoast: Sure
01:45:37 <pacak> ph88_: Read incrementally chunk by chunk, create a bunch of smaller vectors then concat them all together.
01:45:53 <halogenandtoast> So what did you mean by ADT for Square? Just a normal data constructor?
01:46:41 <ph88_> pacak, since i'm using lazy it should already do chunk by chunk, no ?
01:47:20 <merijn> halogenandtoast: Rather than having a record for Square and having SquareType I'd try to consolidate them into a single type, especially since a bunch of the bool's in your Square are mutually exclusive
01:47:29 <merijn> halogenandtoast: i.e. a square can never be both flagged and revealed
01:47:29 <pacak> Kind of. But lazy io is problematic in general.
01:48:09 <ph88_> pacak, what's a good size of the chunk ?
01:48:45 <halogenandtoast> merijn: sure, but having the type together with square doesn't make it not a record. I'm not sure I understand what an ADT is I'm not sure what the eventual intent is.
01:49:02 <pacak> you can impelement it to be chunk size agnostic and just try several different versions.
01:49:15 <pacak> You can look at iteratess/pipes/conduit/whatever
01:50:13 <ph88_> pacak, hows conduit gonna help ?
01:50:46 <merijn> halogenandtoast: All haskell type are ADT (Algebraic Data Types), but in common usage it refers to using Sum types over records, such as having "data Square = Unrevealed ? | Revealed Int" with Int allowed to be zero, or, alternatively using "Revealed (Maybe Int)" Which leaves the question of how to deal with Unrevealed and the fact that they can have a flag and mine.
01:52:10 <pacak> ph88_: I'm using iteratees for similar task, but my files are bigger. The idea is to have Enumerator that produces stream of bytestrings, then several enumeratees that parse data in steps then iteratee that collects result into a single vector.
01:52:33 <halogenandtoast> merijn: sure, I wasn't sure how to encapsulate the idea that a square could be in many different related states. Flagged Mine, Flagged Not Mine, Unrevealed Mine, Unrevealed Not Mine, Revealed Mine, Revealed Not Mine
01:52:48 <ph88_> pacak, aaaah ok, that sounds very very optimized :P
01:53:02 <merijn> halogenandtoast: Yeah, I agree that that specific case is a bit awkward
01:53:41 <merijn> halogenandtoast: But I'd at the very least split the "revealed/unrevealed" case apart, since flag/mine can't appear for revealed
01:54:14 <phz_> hey, what is the recommendation on documenting instances?
01:54:22 <phz_> doc on the instance? on the method?
01:54:29 <merijn> phz_: Both?
01:54:47 <phz_> well, the typeclass has only one method
01:54:47 <halogenandtoast> merijn: type Square = (State, IsMine)
01:54:53 <phz_> that seems like redundancy
01:55:13 <merijn> phz_: I'd be suspicious of a class with only one method?
01:55:28 <dmj`> phz_: pretty sure for 100% haddock coverage you have to document the top level of an instance. Unsure about instance methods though… maybe just document it at the class
01:55:38 <phz_> merijn: FromJSON
01:55:56 <phz_> even though it has two, but the other one has a default implementation I don’t give a heck yet
01:56:08 <halogenandtoast> phz_: He just said suspicious, not that it should never happen.
01:56:18 <phz_> and you have a lot of classes with one methods
01:56:22 <phz_> I think it’s saner that way
01:56:24 <merijn> phz_: I suppose in that case documenting the instance seems redundant in the first place
01:56:25 <phz_> yeah yeah
01:56:32 <phz_> merijn: why?
01:56:56 <phz_> I need documentation because the instance doesn’t tell enough
01:57:11 <halogenandtoast> merijn: Also I wanted to encode the neighboring mine count somehow so maybe type Square = Square Status IsMine MineCount
01:57:14 <phz_> because the representation of the type is ambiguous
01:57:47 <merijn> phz_: I haven't actually used FromJSON, so I can't be much more helpful
01:57:50 <halogenandtoast> *not type
01:58:22 <merijn> halogenandtoast: And then have "data Status = Flagged | Revealed | Blank"?
01:58:24 <phz_> thank you anyway :)
01:58:30 <merijn> halogenandtoast: That sounds reasonable too
01:59:03 <merijn> halogenandtoast: I would definitely prefer that to the current type
01:59:10 <halogenandtoast> it's encodes the related parts in a single type
01:59:40 <halogenandtoast> type Square = Mine Status | Empty Status MineCount
01:59:45 <halogenandtoast> or something like that ?
01:59:51 <halogenandtoast> *data
01:59:58 <eatman> Hi there.
02:00:02 <srhb> eatman: Hello.
02:00:06 <merijn> halogenandtoast: I think I like the Square Status IsMine MineCount one best
02:00:14 <eatman> I'd like to load Data.Magma in GHCI.
02:00:26 <halogenandtoast> merijn: what is the advantage over the alternative I just proposed?
02:00:26 <eatman> How can I install it (Using stack).
02:00:33 <srhb> eatman: stack install magma
02:00:35 <srhb> I think.
02:01:06 <merijn> halogenandtoast: That 2nd ons is also ok, avoids the boolean :)
02:01:11 <eatman> Is there an option that allow to instlal dependencies?
02:01:24 <srhb> eatman: It does that automatically, but it may actually not work with the latest snapshot
02:01:29 <eatman> (First stack install use)
02:01:29 <srhb> eatman: So you might have to use an earlier one
02:01:38 <srhb> eatman: I'm guessing you're seeing: profunctors >=3.2 && <5.2
02:01:42 <eatman> Yep.
02:01:51 <srhb> eatman: Right, you will need an earlier snapshot for that.
02:02:06 <eatman> I'm ok for a global update as well.
02:02:09 <halogenandtoast> I feel like this is the exactly problem lts is supposed to solve :(
02:02:22 <srhb> eatman: Update won't help you. It's incompatible with ghc > 8.0 I think.
02:02:29 <eatman> Ha, ok.
02:02:36 <srhb> eatman: Either you'd have to patch the package or use an earlier version entirely.
02:02:47 <halogenandtoast> merijn: While it's okay, does one have an advantage over the other?
02:03:03 <merijn> halogenandtoast: Maybe, but not one that I can immediately think off :)
02:03:09 <pacak> ph88_: Or you can simply write a loop, read a bit, parse, pack into vector, read more, parse leftovers from previous run with current data and so on. The idea is not to parse all the numbers at once because it will create a ton of object that needs to be GCed - doubles and []
02:03:19 <eatman> Well, I don't care, I just wanted to know if a Magma is enough to make a foldable instance.
02:03:20 <merijn> halogenandtoast: Well, I guess the first one is easier to make a lens for
02:03:29 <merijn> halogenandtoast: The second would require prisms?
02:03:55 <eatman> srhb: I don't think I'm good enogh at Haskell in order to patch any package right now.
02:04:28 <srhb> eatman: Can you use groupoids instead?
02:04:31 <srhb> Isn't that the same thing?
02:04:43 <srhb> Er, semigroupoids
02:04:50 <eatman> Don't know it but I'll have a look.
02:04:56 <eatman> Ah , semigroup ok.
02:05:01 <srhb> https://hackage.haskell.org/package/semigroupoids
02:05:03 <halogenandtoast> merijn: interesting, I'll mess around with changing the types now that I have a working instance.
02:05:16 <eatman> Well, if you've a semigroup, you've a Magma.
02:05:42 <srhb> Really? I thought magma needed associativity
02:05:56 <eatman> Nop, I guess not.
02:06:01 <phz_> a Magma doesn’t have associativity
02:06:08 <phz_> it’s a semigroup without it, IIRC
02:06:15 <srhb> Oh, it's the other way around.
02:06:18 <merijn> Isn't the lack of associativity what distinguishes a magma from a semigroup?
02:06:18 <phz_> yep
02:06:18 <srhb> Right, thanks :)
02:06:18 <eatman> Yep.
02:06:27 * srhb cries
02:06:31 <srhb> Never speak too soon in #haskell :-)
02:06:52 <phz_> srhb: though, you’re the first person I hear talking about magma here
02:07:02 <phz_> I didn’t know such an abstraction was interesting
02:07:04 <phz_> :D
02:07:07 <srhb> phz_: Then you missed eatman doing so, since that's what I'm responding to ;-)
02:07:38 <eatman> So, I guess that if I've a Magma (with the <> internal law), I can make it foldable cna't I?
02:07:58 <eatman> phz_: Yeah, Magma are not so ommon.
02:08:06 <phz_> eatman: well, that’s contrary
02:08:14 <phz_> they’re so common we don’t need them
02:08:23 <eatman> True.
02:08:28 <phz_> you can’t reason correctly with something that abstract, IMHO ^^
02:08:41 <eatman> Yes, not enough constraints.
02:09:18 <phz_> a list over concatenation is a magma, numbers over product or addition are magmas, etc.
02:09:25 <phz_> I tend to stop at Semigroup
02:09:27 <phz_> for NonEmpty
02:09:37 <phz_> because NonEmpty is the free semigroup for anything
02:09:54 <eatman> phz_: Sum and Prod are Magams becouse they're Monoids.
02:10:25 <eatman> I mean, the law is assossiative.
02:10:33 <phz_> eatman: yes
02:10:40 <phz_> but they’re magmas first ;)
02:10:44 <eatman> Yep.
02:10:49 <phz_> I mean
02:10:53 <phz_> I don’t know a thing that is a magma only
02:10:59 <eatman> So, in the end : How can I get the Magams?
02:11:04 <phz_> and I can’t see a scenario in which I’d like to work with magma only
02:11:07 <phz_> I couldn’t do much
02:11:07 <phz_> like
02:11:23 <phz_> doMagmaWork :: (Magma a, Other b) => a -> a -> b
02:11:28 <phz_> you can’t do much here
02:11:41 <phz_> what do you mean get?
02:11:48 <eatman> stack install magma.
02:11:56 <phz_> I think they’re in semigroupoids
02:12:09 <eatman> Ho... I'll look at that.
02:12:36 <phz_> or
02:12:38 <phz_> @hoogle magma
02:12:39 <lambdabot> Control.Lens.Iso magma :: LensLike (Mafic a b) s t a b -> Iso s u (Magma Int t b a) (Magma j u c c)
02:12:39 <lambdabot> package magma
02:12:39 <lambdabot> module Control.Lens.Internal.Magma
02:12:44 <phz_> there’s a magma package
02:12:53 <phz_> I’m a bit disappointed though
02:12:59 <phz_> it’s not from edwardk 
02:13:02 <phz_> what is going on?!
02:13:03 <phz_> :D
02:13:06 <eatman> So, stack install what ?
02:13:11 <phz_> stack install magma
02:13:24 <eatman> Nop     profunctors-5.2 must match >=3.2 && <5.2 (latest applicable is 5.1.2)
02:13:26 <phz_> if they’re not part of stackage
02:13:33 <phz_> you’ll have to pinpoint them in your stack.yaml
02:13:41 <eatman> I've none here.
02:14:15 <phz_> haha
02:14:38 <phz_> there’s a BinaryTree type constructor in that package
02:14:45 <phz_> why do you need magmas in the first place?
02:14:47 <phz_> I’m curious now
02:14:51 <eatman> I'm just doing some tests in /tmp.
02:14:56 <phz_> alright
02:15:02 <eatman> phz_: I wanted to try to fold using <>
02:15:36 <eatman> I'm reading the "Haskell from first principle" book and wanted to try some things out.
02:15:45 <ph88_> pacak, should i use a mutable or immutable vector ?
02:16:33 <phz_> eatman: magmas are not very spread in the ecosystem, I’d say
02:16:34 <pacak> ph88_: I'd go for immutable one. Mutable will require to perform any operations incluing reading in IO or ST monad.
02:16:37 <phz_> you should stick to Semigroup
02:16:57 <phz_> if you have a very good reason not to want associativity
02:17:02 <phz_> you should use a Magma
02:17:06 <phz_> but that sounds crazy :D
02:17:22 <phz_> semigroups are very common in Haskell
02:17:26 <phz_> I think they’re in base now?
02:17:38 <phz_> https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Semigroup.html
02:17:40 <phz_> they are!
02:17:41 <Iceland_jack> They are, along with Data.List.NonEmpty
02:17:52 <phz_> see
02:17:54 <phz_> nothing to stack install ;)
02:18:02 <Iceland_jack> I'll start a gang for people who hate associativity
02:18:15 <Iceland_jack> I'll call it.. http://bulbapedia.bulbagarden.net/wiki/Team_Magma
02:18:22 <phz_> Iceland_jack: call it the MR
02:18:25 <phz_> MagmaRacists
02:18:52 <Iceland_jack> I may need a better PR dep :)
02:19:06 <halogenandtoast> I'm really wondering how the name Magma came about
02:19:25 <phz_> halogenandtoast: it’s exotic
02:19:36 <eatman> Ok, I know that I don't NEED them, it was just "for fun".
02:19:55 <phz_> eatman: well, use the magma package then
02:20:02 <phz_> though, last update is form 2015
02:20:05 <Iceland_jack> halogenandtoast: A lot of abstract algebra names are, for lack of better word, BS :)
02:20:08 <phz_> not sure you can build it against a recent LTS stackage
02:20:15 <Iceland_jack> Relevant: http://english.stackexchange.com/questions/63210/etymology-of-magma-in-abstract-algebra
02:20:25 <phz_> Iceland_jack: don’t say that
02:20:27 <ph88_> pacak, sorry for stupid questions, but how can i write a loop on the line parser ?
02:20:28 <eatman> Yes, So the question was about How to install it using stack.
02:20:34 <phz_> I love the algebraic names
02:20:40 <Iceland_jack> fine: arbitrary
02:20:49 <phz_> right, thank you ♥
02:20:58 <halogenandtoast> Thanks for the link
02:21:04 <phz_> eatman: stack install magma
02:21:05 <srhb> ph88_: The line parser?
02:21:06 <phz_> in your project
02:21:09 <halogenandtoast> Is there any "good" way to clean this up?
02:21:09 <halogenandtoast>     parsePosition s = case readMaybe <$> words s of
02:21:09 <halogenandtoast>                            [x, y] -> (,) <$> (subtract 1 <$> x) <*> (subtract 1 <$> y)
02:21:09 <phz_> if it fails
02:21:12 <halogenandtoast>                            _ -> Nothing
02:21:12 <phz_> wait.
02:21:20 <pacak> ph88_: write a parser for one line, read a chunk, feed it to parse (many line), parse will return parsed data and leftovers.
02:22:04 <phz_> eatman: magma doesn’t seem to live in stackage, so you have to add it to the extra packages field in your stack.yaml
02:22:24 <eatman> Ok, so I definitly need a stack.yaml file.
02:22:31 <phz_> sure you do
02:22:38 <phz_> stack init
02:22:40 <phz_> if you have a .cabal file
02:22:56 <srhb> I think they are working with the "global" environment
02:23:00 <ph88_> pacak, that parser will return [[Double]] i think
02:23:07 <srhb> So I assume it would be ~/.stack/something
02:23:12 <ph88_> pacak, maybe it will be easier to have state in the parser ?
02:23:19 <ph88_> and also faster
02:23:34 <phz_> extra-deps: ["magma-0.4.0.0"]
02:23:37 <phz_> stack install magma
02:23:40 <phz_> you should have it now.
02:24:06 <pacak> ph88_: If chunk is small enough GC for [[Double]] will be cheap. Once you get this [[Double]] you pack that into Vector Double or [Vector Double] depending on your data shape.
02:24:16 <phz_> when a package doesn’t belong to any LTS / nightly / whatever snapshot of stackage, you have to declare it as an extra-dep
02:24:30 <phz_> so that stack look it up in hackage for you
02:24:48 <ph88_> pacak, maybe i can use this ?  https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString.html#v:scan
02:25:15 <ph88_> pacak, or this http://stackoverflow.com/a/30508695
02:25:35 <eatman> Thanks ph88_ I'll give it a try.
02:25:44 <ph88_> ???
02:26:06 <pacak> ph88_: Scan will return you a ByteString - which is probably not something you want.
02:26:14 <ph88_> oh ok
02:26:17 <ph88_> what about StateT ?
02:26:50 <ph88_> i could push the Doubles directly onto the vector and not put them in linked list first
02:26:56 <pacak> StateT foo Parser will give you Parser inside State, not State inside Parser.
02:27:23 <ph88_> and that's not what i want ?
02:27:35 <pacak> ph88_: You can't push them directly to the vector since you don't know upfront amount to allocate
02:28:44 <pacak> ph88_: StateT Foo Parser is a state that can also parse, not parser that can have state.
02:30:01 <phz_> merijn: https://github.com/bos/aeson/pull/541 (why I wanted instance documentation) cc phadej 
02:31:56 <maerwald> slightly offtopic, but potentially not. I'm reading about propagating refinement types through higher order functions via pre/post-conditions: https://www.microsoft.com/en-us/research/publication/pre-post-conditions-security-typechecking/ ...then I wondered how much of protocol verification can one actually do on type level. I mean... we're kind of assuming here that all the important protocol logic is somehow expressed in the type system (directly or
02:33:00 <ph88_> pacak, i was using readFile from https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy.html  but to read in chunks i think i will need to use another (maybe strict) function
02:33:04 <halogenandtoast> This seems like a very beginner question so I feel derpy for asking, but if I have [Maybe Int] how can I apply (Int -> Int) to it?
02:33:18 <srhb> halogenandtoast: fmap more!
02:33:29 <halogenandtoast> (a -> b) -> [f a] -> [f b]
02:33:34 <halogenandtoast> fmap . fmap ?
02:33:44 <ph88_> anyone know a function to read a file in chunks ?
02:33:54 <srhb> halogenandtoast: Yep.
02:33:59 <eatman> phz_: The stack.yaml file is not ok for me.
02:34:25 <halogenandtoast> srhb: but my eyes!
02:34:39 <eatman> Anyway, not a real problem.
02:34:45 <pacak> ph88_: enumFile from iteratees. https://hackage.haskell.org/package/iteratee-0.8.4.6/docs/Data-Iteratee-IO-Fd.html
02:35:03 <pacak> ph88_: There should be something in conduit/pipes/whatever
02:35:25 <pacak> Or you can simply open a handle and use hGetSome
02:37:05 <srhb> halogenandtoast: Awh, it's not that bad... :-)
02:37:12 <ph88_> pacak, i still have a last resort if hGetSome fails https://youtu.be/-nr59jF7JHU
02:37:29 <srhb> halogenandtoast: When you get to fmap . fmap .fmap you really start to wish for "exponentiation" of function composition.
02:37:36 <srhb> Then you are allowed to be sad. ;-)
02:38:08 <phz_> eatman: hm?
02:38:14 <phz_> not okay for you?
02:38:21 <phz_> then edit it! :)
02:39:25 <halogenandtoast> srhb: I'm assuming you just write a helper function fmap3 = fmap . fmap . famp
02:39:31 <halogenandtoast> s/famp/fmap/
02:39:45 <halogenandtoast> and then promptly hate yourself for it.
02:39:58 <pacak> halogenandtoast: How would you call this: fmap fmap $ fmap fmap fmap?
02:40:29 <halogenandtoast> pacak: f2fmap3
02:40:40 <pacak> Or fmap (<*>) $ fmap (<*>)?
02:40:59 <pacak> That's something one of my collegues srsly considers to add.
02:41:06 <halogenandtoast> actually I'm changing my roll, fffmap = fmap . fmap . fmap
02:41:27 <tdammers> something like an indexed monoid would be great
02:42:01 <halogenandtoast> fStarMoMoneyfStar = fmap (<*>) $ fmap (<*>)
02:42:06 <tdammers> then you could mconcat (replicate 3 fmap)
02:42:15 <pacak> ph88_: It won't fail, it will simply look ugly.
02:42:22 <opqdonut> tdammers: :D
02:42:46 <halogenandtoast> next derpy question [Maybe a] -> Maybe [a] ?
02:42:53 <opqdonut> halogenandtoast: sequence
02:42:55 <opqdonut> :t sequence
02:42:56 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:42:59 <halogenandtoast> aww snap
02:43:17 <opqdonut> m = Maybe, t = []
02:43:22 <pacak> :t sequenceAa
02:43:23 <pacak> :t sequenceA
02:43:23 <lambdabot> error:
02:43:24 <lambdabot>     • Variable not in scope: sequenceAa
02:43:24 <lambdabot>     • Perhaps you meant one of these:
02:43:25 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
02:43:30 <halogenandtoast> thanks opqdonut haven't used it yet
02:43:36 <halogenandtoast> this is a glorious day
02:44:11 <ph88_> pacak, do i need this too ? https://hackage.haskell.org/package/conduit-extra-1.1.15/docs/Data-Conduit-Attoparsec.html
02:45:00 <maerwald> I don't even understwand why it should be Maybe [a] and not simply [a]
02:45:16 <pacak> ph88_: I'm not sure about conduits.
02:45:42 <tdammers> maerwald: what should, sequence?
02:45:54 <tdammers> maerwald: [Maybe a] -> [a] also exists, it's called catMaybes
02:45:57 <ph88_> pacak, if it will work, or what functions to use ?
02:45:57 <maerwald> I know
02:46:10 <maerwald> I don't see a use case for  [Maybe a] -> Maybe [a]  is what I am saiyng
02:46:14 <opqdonut> :t catMaybes
02:46:14 <pacak> ph88_: It will work, I just don't know how to use it myself.
02:46:15 <lambdabot> [Maybe a] -> [a]
02:46:25 <opqdonut> catMaybes is the more specific function
02:46:29 <maerwald> for other monads its a different thing
02:46:33 <pacak> @src catMaybes
02:46:34 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:46:41 <ph88_> ok
02:47:00 <halogenandtoast> maerwald: trying to do something like this
02:47:01 <halogenandtoast>     parsePosition s = toTuple <$> sequence (fmap (subtract 1) . readMaybe <$> words s)
02:47:05 <halogenandtoast>     toTuple [x, y] = Just (x, y)
02:47:07 <halogenandtoast>     toTuple _ = Nothing
02:47:31 <halogenandtoast> to convert a string "1 2" into Just (1, 2)
02:47:38 <halogenandtoast> err
02:47:42 <halogenandtoast> Just (0, 1)
02:48:47 <halogenandtoast> but I'm just derping my way through types at the moment.
02:49:08 <ph88_> maerwald, what are you asking about the paper
02:49:58 <maerwald> ph88_: they're assuming the protocol logic maps to the types. How do you know it does and does so consistently that you don't need design/spec-level verification?
02:52:47 <maerwald> (and... imagine process communication, then it goes even more out of the window)
02:52:50 <ph88_> maerwald, you still need to verify that, but after you verified the type level constructs you can reuse the types if you want to do another implementation on the same protocol
02:54:09 <maerwald> so "Operating at the level of source code ensures that both design and implementation flaws will be caught" is basically a bit over the top then I guess
02:54:18 <tdammers> maerwald: first, it would be more effort to disallow calling sequence on Maybe while keeping it around for other monads
02:54:29 <maerwald> tdammers: haha
02:54:40 <tdammers> maerwald: second, if you actually use Maybe monadically, sequence makes enough sense as it is
02:54:47 <maerwald> you could do it with refinement types xD
02:55:06 <halogenandtoast> thanks all, time for dinner and then boardgames.
02:55:53 <maerwald> reusing "type frames" for different implementations is an interesting idea though
02:56:02 <ph88_> maerwald, check this out http://wiki.clean.cs.ru.nl/images/e/e7/2017-FP-Dag-TDD-Sessions.pdf
02:56:18 <ph88_> Type-Driven Verification of Communicating Systems
02:56:42 <ph88_> oh ye i remember they are called Session Types
02:56:43 <maerwald> does that make something like PROMELA unnecessary?
02:56:53 <tdammers> maerwald: generally speaking though, restricting the use of lawful functions just because you can't think of a way to make them useful is a bit idiotic IMO
02:57:04 <maerwald> tdammers: :*
02:57:15 <tdammers> :t pure x >> a
02:57:17 <lambdabot> error:
02:57:17 <lambdabot>     • Couldn't match expected type ‘m b’ with actual type ‘Expr’
02:57:17 <lambdabot>     • In the second argument of ‘(>>)’, namely ‘a’
02:57:26 <tdammers> wat
02:57:48 <tdammers> anyway, pure x >> a is perfectly lawful, nothing wrong with it, but it's not useful at all
02:57:56 <tdammers> should we prohibit it? I think not.
02:58:06 <ph88_> maerwald, i'm pretty sure that when they talk about preventing design and implementation flaws they talk about what you want to do with the protocol AFTER it has been layed out in the type system
02:58:50 <maerwald> ph88_: the thing is, I can't think of a way to examine inter-process comunication state space within just the type system of the client/server implementation
02:59:18 <ph88_> what you mean state space ?
02:59:38 <ph88_> the possible amount of states ?
03:00:13 <maerwald> yeah, arising from the protocol, or even the implementation
03:00:23 <maerwald> depending on when what message got somewhere
03:00:44 <maerwald> which is what you can model in promela for example, but that's explicit
03:00:50 <ph88_> maerwald, when you have a communication protocol, not just what matters is the state at one point, but the sequences of different states
03:01:08 <maerwald> sure
03:01:25 <ph88_> maerwald, i think for a single state you can read the types, but i'm not sure about that
03:02:11 <ph88_> if you talk about what are all the possible sequences of state my program can find itself in .. it's a hard problem i think .. i remember the busy beaver
03:02:47 <maerwald> you'd basically need refinement types for the state of the client you don't know about :P
03:02:54 <maerwald> which is a funny thought, actually
03:03:22 <maerwald> s/client/process/
03:03:43 <ph88_> not sure i follow there .. the possible state should be encoded in the types .. and the actual state is on runtime ..
03:03:47 <ph88_> maybe i should read the paper :P
03:04:05 <ph88_> off to lunch
03:08:29 <maerwald> ph88_: it's not just about your own state though, which is why you model client and server in promela and can watch all possible states of the two during each asynchronous process communication. Exploring all possible internal states too, depending on the order of messages.
03:08:50 <maerwald> and that's not encoded in the type system imo, because it involves more than one process
03:12:12 <maerwald> or to put it simpler: you can't tell your protocol is deadlock free just because your implementation is totally type-verified
03:13:21 <tdammers> doesn't that depend on the type system, and what kind of constraints it can express?
03:19:12 <Jinxit> are 'some' and 'many' useful outside of parsers?
03:28:28 <nilof> Are there any cases where You want to use the lazy version of foldl instead of the strict one, or lazy foldr ?
03:29:03 <srhb> nilof: If you're implementing foldr in terms of foldl I guess.
03:29:16 <srhb> But yeah, you still lose laziness there.
03:29:27 * srhb can't think of a good reason
03:30:18 <magthe> I'm looking around for examples of how to do 'multipart/x-mixed-replace' responses in any of the Haskell web libs/frameworks... I'm not finding much though... anyone in here who can offer me a pointer?
03:36:44 <nilof> So lets see if I understood monad transformers, is say, maybeT Identity  isomorphic to Maybe ?
03:37:10 <merijn> nilof: Correct
03:37:42 <merijn> nilof: In fact, State/Reader/Writer from transformers are literally just StateT/ReaderT/WriterT over Identity
03:38:42 <shiona> I assume the only reason for Maybe to not share that is to allow for easier-to-understand error messages
03:39:11 <merijn> shiona: Well, it's also because Maybe is defined inside Prelude, while MaybeT is not in base
03:40:09 <merijn> Additionally, you often want to pattern match on Maybe (unlike the ones mentioned above) which would become more annoying if it was defined using Identity
03:40:41 * ski would like it if `newtypes' could have multiple definitions, as long as they're consistent
03:41:00 <merijn> ski: How would that help?
03:41:48 <nilof> Can you redefine any monad as a monad transformer and get back the monad instance from transformer on identity?
03:41:53 <nilof> Or are there exceptions?
03:42:06 <ventonegro> the whole point of `newtype` is to create a new type :)
03:42:15 <ventonegro> newtype ID = ID String
03:42:27 <merijn> nilof: I think that should hold for any monad that has a transformer, but I don't think all monads can be turned into transformers
03:42:28 <nilof> ignoring the issue of pattern matching
03:42:33 <nilof> ah ok
03:42:38 <ski> (iow both `newtype State s a = State (s -> (a,s))' and `type State s = StateT s Identity; newtype StateT s m a = StateT (s -> m (a,s))', in this case)
03:42:46 <merijn> nilof: Consider IO/STM/ST, those can't (at least not obviously) be turned into transformers
03:42:59 <Iceland_jack> ski: If data families could have polymorphic return types (not data instances) we could get something like that
03:43:13 <Iceland_jack> where the newtype in question was dispatched on based on kind
03:43:39 <Iceland_jack> well, could be tagged by Symbol I suppose
03:43:48 <merijn> ski: If I ever get around to inventing my own language, dealing with newtypes for class selection would be one of the main focuses to improve
03:51:54 <maerwald> tdammers: but how would you know that in e.g. a p2p system. You implement the client and do state transitions based on input and whatnot. But you don't see beyond your own internal state as soon as it becomes real-world (multiple clients talking to each other).
03:55:04 <maerwald> can you infer the whole internal state of a remote based on the message it sent? Maybe in some cases, but consistently?
03:59:08 <ph88_> anyone know how i can make a conduit Producer from stdin ?
04:01:11 <Axman6> isn't that already defined somewhere?
04:03:01 <Axman6> https://hackage.haskell.org/package/conduit-combinators-1.1.1/docs/Data-Conduit-Combinators.html#v:stdin exists
04:04:36 <ph88_> oh combinators
04:26:51 <ertes> ph88_: CET/CEST
04:27:01 <ertes> currently the latter
04:27:09 <Jinxit> when doing applicative parsing, is it possible to check that two different parses both match on the next token?
04:27:10 <ph88_> :P
04:27:59 <tsahyt> Is there some variation of djinn/exference that can work on a file and row/column, and takes import information into account?
04:28:42 <tsahyt> or even better, knows what is in scope at that position
04:29:14 <inkbottle> [newbie] On debian I have the choice between "haskell-platform" and "stack": I guess there is nothing wrong going one way or the other...
04:29:59 <opqdonut> inkbottle: yeah. for a newbie haskell-platform might be nicer
04:30:02 <opqdonut> less complexity
04:30:11 <opqdonut> for "real" development, stack is great
04:30:19 <inkbottle> OK
04:30:34 <opqdonut> but they don't conflict in any way, you can use both
04:30:56 <inkbottle> thanks
04:31:02 <opqdonut> (stack does sandboxed installations of ghc and libraries like python virtualenv or npm)
04:31:46 <inkbottle> sandboxed=userspace?
04:31:52 <opqdonut> yeah
04:31:57 <inkbottle> OK
04:47:54 <ph88_> what's the difference between Source/Producer and Sink/Consumer in conduit ?
04:50:01 <bennofs> ph88_: I think you can pipe input into a Producer if you wish without a type error, but the Producer will ignore it and never read it
04:50:25 <bennofs> ph88_: whereas a Source requires the input type to be (), so it can only be used at the start of the chain 
04:51:00 <ph88_> oh
05:07:25 <Licen> ciao
05:07:37 <Licen> !list
05:13:41 <ph88_> what is this MonadResource m0 here and what can i pick for it ?  https://bpaste.net/show/83867d9333bf
05:14:58 <Axman6> ResourceT is the standard choice
05:19:58 <bennofs> ph88_: it's basically a monad that allows you to run IO actions at the end to cleanup resources
05:20:01 <bennofs> iirc
05:20:12 <jasondockers_> Do we prefer to create return types instead of directly returning a tuple? like `type Whatever = (A,B)`?
05:20:35 <ph88_> what can i put as argument to ResourceT ?
05:20:51 <bennofs> jasondockers_: probably better to do data Whatever = Whatever { descriptiveNameForA :: A, descriptiveNameForB :: B }
05:20:54 <ph88_> IO ?
05:21:01 <bennofs> ph88_: yea
05:21:18 <jasondockers_> bennofs, ah, okay. so returning bare tuples isn't usually preferable?
05:21:30 <bennofs> jasondockers_: well for simple things you can return a tuple directly
05:21:43 <merijn> jasondockers_: "It Depends (TM)"
05:21:48 <jasondockers_> heh, okay. 
05:22:03 <merijn> jasondockers_: However, if you do returna tuple directly, then I would avoid type aliasing it
05:22:17 <jasondockers_> I guess it doesn't really matter. I'm just going through data structures exercises.
05:22:32 <merijn> i.e. either return (A,B) or define a custome type Whatever, but don't alias (A,B) to Whatever, because that leaves me guessing
05:22:38 <jasondockers_> merijn, alright
05:36:05 <mutsig> I'm trying to get my head around parallelization. If I have a list `lst` of expensive computations, would "foldr par () lst" be a suitable way perform those computations in parallel?
05:37:01 <opqdonut> that should work IIRC, as long as you force the result
05:37:11 <opqdonut> but I recommend starting with Control.Parallel.Strategies
05:37:21 <opqdonut> raw `par` usage is hard to get right
05:38:17 <halogenandtoast> As a quick survery, how many of you put two new lines between functions?
05:38:24 <halogenandtoast> s/survery/survey/
05:38:27 <mutsig> Ok, I was hoping to not have to deal with NFData, but perhaps that's easier after all...
05:38:37 <bennofs> halogenandtoast: i put one
05:38:43 <mutsig> halogenandtoast: two here
05:40:37 <codedmart> Is there a way to do something like `someField -~ 1` for lens of only if `_someField` is `> 0`?
05:40:57 <codedmart> So basically I don't want `someField` to ever be less then 0.
05:42:02 <opqdonut> codedmart: I'd just define a subtractOneButDontGoNegative function and map that
05:42:14 <Athas> mutsig: NFData is your fate if you want to parallelise Haskell.
05:42:23 <Athas> Or else a very very good operational understanding.
05:42:53 <Athas> But I mean, some Haskell bigwigs wrote a paper about a new model of parallelism (the Par monads), and the magic sauce was pretty much deepseq'ing everything.
05:42:59 <bennofs> codedmart: i'd do someField -~ max 0 . subtract 1
05:43:11 <mutsig> Athas: Ok. So be it... I'll go for NFData.
05:43:33 <bennofs> s/-~/%~
05:44:50 <halogenandtoast> bennofs: mutsig thanks, so far that's 50/50
05:45:42 <Athas> halogenandtoast: one line here.  Or sometimes zero, for where-bound one-liners.
05:45:44 <codedmart> Thank!
05:55:03 <ph88_> how can i control the chunksize with conduit >
05:56:27 <lyxia> mutsig: what kind of computations are in your list? NFData is unnecessary if their WHNF is their NF, like primitive numerical types.
05:57:48 <c_wraith> NFData also isn't harmful if WHNF is their normal form, because rnf will just be seq
05:58:18 <c_wraith> The problem is when rnf is recursive but doesn't need to be due to details of how the value is generated
05:58:54 <ph88_> i would like to use the conduit Producer and give it to the parser, then put numbers in a vector, run calculations on them and write the results back to a file  .. not sure how i can tie the code together, i have this at the moment  https://bpaste.net/show/007ef13dfa75
06:02:01 <mutsig> lyxia: Well, it isn't primetives, but I thought of making them Text, since thats the final result, for printing. Right now WHNF /= NF.
06:12:54 <mbw> I have a question about Haskell/GHC performance. There are a lot of wiki entries, blogposts, stackoverflow answers etc. which claim that GHC-compiled code was on par with hand-optimized C or even Fortran. Often they come with links to benchmarks to the "Great Language Shootout", which doesn't exist anymore and is called "The Benchmark Game", because someone was offended apparently. However, browsing this 
06:13:00 <mbw> site doesn't make it look like these claims are true at all, at least not anymore. Assuming they were in the past, are there good reasons for this (appart from manpower)? Like performance regressions in newer GHC versions, larger vector registers that GHC can't use or something like that?
06:17:23 <Philonous> mbw, Well, benchmarking is hard. Haskell used to fare OK in the shootout (generally withing an order of magnitude of Java/C), but AFAIK nobody is investing much tie into that any more. Part of the problem is that it's pretty meaningless. Just because some carefully optimized program runs as fast as another carefully optimized program means that the typical program you would write runs as fast. 
06:17:25 <merijn> mbw: It's not really so much an issue of GHC regressions as much as "it depends on the code you write"
06:17:39 <Philonous> investing much time*
06:17:52 <Philonous> doesn't mean*
06:17:58 <merijn> mbw: Comparing speed of languages is kinda pointless, since a lot of things depending on the optimisation of the program
06:18:10 <merijn> mbw: What is "this site"?
06:18:28 <merijn> It also depends strongly on the benchmark
06:19:02 <reactormonk[m]> Weren't there some libraries to run code on the GPU too?
06:19:55 <merijn> reactormonk[m]: You mean accelerate?
06:20:11 <lieven> mbw: here's a recent article about a neat haskell solution to a problem: https://byorgey.wordpress.com/2017/01/27/advent-of-code-16-solution-an-algebra-of-bitstrings/
06:20:17 <srhb> merijn: The computer language benchmarks game, I think: http://benchmarksgame.alioth.debian.org/
06:20:46 <lieven> mbw: once you see this solution youc an code it in another language fairly easily. but thinking in haskell makes it more likely you come up with such a solution.
06:20:49 <Athas> Philonous: the Haskell programs also used to be really ugly.
06:21:08 <Philonous> Athas, That too
06:22:01 <Athas> mbw: Haskell is pretty fast for the things that Haskell is good at (symbolic/tree/list processing).  It has higher overheads than C unless you program in a very weird (low-level) style.  It cannot reasonably match or beat C or Fortran for loopy numeric code.
06:22:14 <Philonous> mbw, It's really hard to say that a language is "faster" than another. Consider python. You wouldn't expect an interpreted language to fare well with heavy numerical computations. And yet it does thanks to carefully crafted libraries that offload the number crunching to C.
06:22:25 <Athas> The interesting part about Haskell is that you can generally program at a very high and compositional level, and expect the compiler to remove a good bit of the overhead.
06:22:54 <Athas> In other languages, you tend to create specialised implementations if you want performance.  In Haskell, you can re-use components and still get performance.
06:22:57 <mbw> You are right that it's maybe a little childish. Still, people strongly believe in things like "Garbage Collection makes everything slow" or something like that. The specific site that caused me to ask this was the performance article on the wiki: https://wiki.haskell.org/Performance/GHC. Especially the first paragraph sound very opinionated. Further down: "This entry in fact runs faster than hand optimised 
06:23:03 <Athas> In the benchmarks game, everyone specialises everything, so it doesn't matter.
06:23:03 <mbw> (and vectorised) GCC!".
06:23:26 <mbw> Also, even if you consider these things pointless, you still get an opportunity to learn more about the language's implementation.
06:23:47 <Athas> There is a lot of ridiculous hype about Haskell performance.
06:24:50 <cocreature> I thought java and recently go stopped the “gc makes everything slow” attitude
06:25:06 <Philonous> mbw, There where examples of idiomatic (GHC-compiled) Haskell that ended up running faster than heavily hand-optimized C code. But those cherry-picked examples don't tell you much except maybe that GHC can sometimes do a good job of producing fast machine code even without resorting to tricks like moving your heavy lifting to C 
06:25:53 <Athas> Philonous: do you know of any examples?
06:25:53 <srhb> A much better point to make about Haskell, I think, personally, is that general performance is pretty damn good and when it's not good enough, it's fairly easy to lift things over in C or something instead.
06:25:56 <srhb> That keeps me happy.
06:26:24 <Athas> Depends on what you are doing.  Haskell performance is generally pretty good for things that cannot be fast (like working with pointer-heavy structures).
06:26:47 <mbw> In my opinion, people should emphasize the productivity/performance ratio, maybe. And stop ending sentences with exclamation marks and talking about things like "aggressive optimizations" and "going down to the bare metal" :/
06:26:48 <Athas> If you are doing things that _can_ be fast (numerical or array-heavy code), Haskell is generally not very good (with a few exceptions, like Repa or vector for simple cases).
06:26:51 * EvanR is being persuaded with this gratuitous banter to lift his C code to haskell
06:26:57 <srhb> Oh, sure, all my number crunching (which, honestly, I don't anymore do now that uni is over) was in something else, like a fortran or c library.
06:27:06 <srhb> EvanR: :P
06:27:18 <Philonous> Athas, I'm sorry, I can't seem to find it any more. I think it was something about using conduits/pipes for data streaming 
06:27:39 <cocreature> mbw: I think most people would agree with that (myself included) :)
06:27:40 <srhb> mbw: If you're wrangling huge matrices, it might matter to you. Then again, people talk about "language speed" and never consider their different needs.
06:27:52 <Athas> Philonous: oh, if it's IO code, then I easily believe it can beat C.  GHC has a pretty good IO manager, and Haskell is great for reasoning about IO.
06:27:54 <srhb> mbw: (So yeah, I basically agree, I guess.)
06:28:08 <kuribas> unsafePerformIO makes my head hurt...  I am trying to set debug messages of with a IORef, it doesn't seem to work...
06:28:25 <eschnett> if you’re wrangling large matrices, then nothing beats numpy. that is, the libraries that numpy uses. which can be called from haskell just fine.
06:28:34 <opqdonut> kuribas: why not Debug.Trace?
06:28:41 <srhb> eschnett: fasta, blas, that kind of stuff.
06:28:48 <Athas> You can beat BLAS/Lapack with fusion, sometimes.
06:29:11 <srhb> Athas: That sounds fun!
06:29:12 <kuribas> opqdonut: I want to turn them off...
06:29:43 <opqdonut> ah
06:29:52 <Athas> srhb: it is!  It's not even that hard.  If you want to sum N matrices with BLAS, then you usually end up manifesting the N-1 intermediate results to memory, which is slow (even if the addition itself will be fast).
06:30:17 <Athas> With fusion, those intermediates could go away.  It's the one big advantage languages (including Haskell) have over optimised libraries.
06:30:28 <srhb> Huh, interesting.
06:30:31 <Athas> ...unless, of course, the library has a specialised routine for just this task.
06:30:37 <kuribas> opqdonut: What I am doing is I am calculating the intersection of a large number of circles, and if there is an error, remove every circle that doesn't remove the error.  But I don't want a log (100s of MB) for every iteration.
06:30:39 <Athas> (And you know it's there and you use it.)
06:30:45 <srhb> Yeah, but then that would be doing the job of the fusion anyway
06:30:56 <mbw> Athas: Or you do your homework and come up with a better algorithm :)
06:31:03 <srhb> mbw: :P
06:31:32 <kuribas> I think haskell is quite good at numeric code.
06:32:02 <kuribas> But it cannot beat C, without SSE, etc...
06:32:32 <Athas> It's not _terrible_.  And the code itself can be nice to look at.  But it's not very fast, in my experience.
06:32:52 <cocreature> -fllvm is often really helpful for numeric code
06:32:53 <Athas> Although it's hard to find examples of people using it in anger, so there is little evidence one way or the other.
06:33:42 <kuribas> Athas: i am writing a numerical library, but I have no comparison with C...
06:33:52 <Athas> kuribas: which numerical library?
06:34:13 <kuribas> Athas: https://hackage.haskell.org/package/cubicbezier
06:34:57 <Athas> Cool!  Are you using vector for the heavy lifting?
06:35:03 <mbw> I think one thing where haskell shines is it's surrounding culture of equational reasoning, emphasis on purity etc. And I think there are number crunchers out there that appreciate that. There is a paper about GPU programming in the financial sector where people prototype in haskell, apply homomorphism theorems etc. etc. and implement it in Fortran.
06:35:17 <kuribas> athan: sometimes...
06:35:51 <Athas> mbw: definitely Haskell is very very good for *expressing* the algorithms (even if multidimensional arrays can be awkward).  Only the performance can be a problem.
06:36:20 <Athas> Numerical algorithms are often well-behaved with respect to functional purity, too.
06:36:22 <cocreature> if performance becomes a problem you can always try making a dsl that generates C/llvm/whatever :)
06:36:30 <mbw> Sadly, equational reasoning is not much use when you have to parallelize Fortran77 code with several nested routines that each do IO and modify blank common blocks. If you don't know what blank common blocks are, think nasal demons.
06:36:32 <cocreature> e.g. accelerate
06:37:37 <Athas> mbw: ugh.  I have the naive hope that it wasn't written like that because the programmer *wanted* to...
06:37:45 <merijn> cocreature: Honestly accelerate isn't too great for GPU stuff, except maybe simple matrix stuff
06:38:08 <Athas> cocreature: that's a good approach, but it doesn't seem to perform as well in practice as in theory.
06:38:22 <cocreature> merijn: well as always it depends on your requirements :)
06:38:41 <Athas> Maybe it could be made to work, but an interesting case is that the vector library is much more used than Repa, despite Repa in principle being faster and more powerful.
06:39:10 <tsahyt> merijn: in what way is it not too great? performance?
06:39:36 <merijn> tsahyt: Performance, yes
06:39:59 <mbw> Athas: Computational chemistry. I.e. not "programmers" per se, a codebase dating back to times where it was cheaper to save previously computed integrals on tape (er, disk) and read it back again. Also as we all know, compiler warnings are just recommendations and probably bugs anyway.
06:40:03 <tsahyt> is there even any way to utilize the GPU well in haskell?
06:40:18 <tsahyt> bonus points for it being a sane way, not some inline-c hackery or so
06:40:39 <merijn> tsahyt: Calling existing kernels from Haskell? Sure. Kernels written in Haskell? Not really
06:40:50 <chip_> is there a way to see the code behind a certain module function?
06:40:56 <Athas> tsahyt: Obsidian, maybe.  It's a fairly clean model, but low-level (i.e. doesn't hide the GPU architecture).
06:41:11 <opqdonut> chip_: click on "Source" in the haddock documentation is the most reliable way
06:41:12 <chip_> for example, i want to see how intercalate works in Data.List
06:41:14 <tsahyt> @hackage obsidian
06:41:14 <lambdabot> http://hackage.haskell.org/package/obsidian
06:41:23 <tsahyt> oh, capital O
06:41:25 <Athas> mbw: my condolences.
06:41:41 <opqdonut> chip_: so https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-List.html -> https://hackage.haskell.org/package/base-4.9.1.0/docs/src/Data.OldList.html#intercalate
06:41:48 <tsahyt> merijn: I suppose where accelerate fails is the lack of a good optimizing compiler step then?
06:41:54 <Athas> I think Obsidian is still research-quality, though.
06:42:13 <Athas> tsahyt: yes, but Accelerate is also kind of restricted in expressivity (e.g. no nested parallelism).
06:42:26 <merijn> tsahyt: Naah, it fails in "abstracts away hardware details", since "hardware details" is where you get the performance :)
06:42:31 <mbw> Athas: There are source files you can only translate with O0 (compiler bug). At one point they deleted all comments to safe space. You know, makes the program run faster, probably.
06:42:43 <mbw> *save
06:42:44 <chip_> thank you @opqdonut
06:42:49 <opqdonut> np
06:42:54 <tsahyt> merijn: it's not like haskell as such would liberally offer up hardware details in general, and still you can write decently performant code in many cases
06:43:00 <Athas> mbw: maybe those comments made the difference of whether the code would fit on a floppy.
06:43:08 <merijn> mbw: A development version of GHC once had a bug where it deleted any source file that contained a type error ;)
06:43:16 <mbw> haha
06:43:26 <Athas> merijn: they should bring that back as --hardcore-mode.
06:43:35 <tsahyt> --hardcore-mode would seriously break my workflow
06:43:44 <tsahyt> every typed hole is a type error in principle
06:43:47 <tsahyt> I could never get anything done at all
06:44:04 <mbw> Haskell is the Dark Souls of programming after all.
06:44:07 <Athas> flymake would be suicide.
06:44:32 <ystael> mbw: meaning if you get a type error once, your next compile has to be successful or it deletes your whole program?
06:44:47 <tsahyt> mbw: Haskell is more the civilization of programming. "just one more abstraction"...
06:45:32 <merijn> tsahyt: Not if you use -fdefer-typed-holes ;)
06:46:15 <tsahyt> ah.. --python-mode
06:46:30 <merijn> tsahyt: No, that's -fdefer-type-errors
06:46:53 <merijn> tsahyt: -fdefer-typed-holes only defers typed holes so you can test code that has holes in it :)
06:47:19 <tsahyt> I never found much use for that tbh. If it has a hole in it, I can't really test it most of the time anyhow, since it will just run into that hole.
06:47:40 <merijn> tsahyt: That assumes you're testing the code path with the hole :)
06:47:46 <kuribas> Any idea why this doesn't work?  http://lpaste.net/354510
06:47:56 <Athas> tsahyt: when it comes to optimising compilers, it's important to remember that you don't have to beat the best hand-optimised code to have something useful, you just have to beat the code that humans tend to write.
06:47:58 <merijn> tsahyt: Maybe you have a hole for error-handling (since you didn't implement it yet) but wanna see if the rest works
06:48:19 <merijn> kuribas: Can you be more specific than "doesn't work"? :)
06:48:25 <kuribas> enableTrace is "enableTrace t = unsafePerformIO $ writeIORef traceOn t"
06:48:34 <kuribas> merijn: it shouldn't output debug messages...
06:48:45 <tsahyt> Athas: I suppose that's true, but then you realize that numeric computing is full of libraries that have been optimized to death. things like fftw, or lapack.
06:48:47 <kuribas> merijn: because of enableTrace False
06:49:12 <Athas> tsahyt: ah, but a compiler can optimise composition, which those libraries can't!
06:49:20 <Athas> Sometimes that can give you enough of an edge.
06:49:48 <tsahyt> Athas: that is true indeed. GHC can even inline and perform such optimizations across module and even package boundaries.
06:49:51 <tsahyt> at least afaik
06:50:02 <Athas> Indeed, that's why it compiles so slowly.
06:50:04 <tsahyt> the downside is of course that you end up with ginormous executables at times
06:50:06 <merijn> kuribas: It's not clear to me why "enableTrace False" wouldn't output debug? That seems to only write to an IORef? Nothing there seems to output anything at all?
06:50:22 <tsahyt> my little gtk doc viewer compiles to a massive 50M...
06:50:28 <mbw> kuribas: By the way, I got it down to perform within 40% or so of the equivalent c++ code. If the elapsed time were an indicator, it would be exactly on par. Sadly, there is a 100ms difference between total time and elapsed time and I don't know where it's coming from.
06:50:41 <tsahyt> tbh I find that much worse than the compile times. although those got really really bad with the gi-gtk code that was using lots of overloaded labels
06:50:45 <Athas> Not bad.  My current project compiles to 20MiB, and that's over 40k SLOC of Haskell.
06:50:51 <tsahyt> I don't know why exactly, but those really slow compilation down to a crawl
06:50:53 <kuribas> merijn: http://lpaste.net/354510#a354511
06:51:05 <kuribas> mbw: that's great!
06:51:06 <tsahyt> Athas: it depends a lot on the amount of dependencies you have
06:51:17 <merijn> tsahyt: Have you tried using split-objs?
06:51:29 <tsahyt> I haven't, I just ended up using -dynamic :P
06:51:34 <mbw> I should probably blog about it, like the cool kids do.
06:51:39 <merijn> tsahyt: How does -dynamic help?
06:51:52 <merijn> tsahyt: That just changes from 50M single executable to 50MB executable + libraries
06:51:53 <tsahyt> with the file size? well almost all of it is dependencies that are statically linked
06:51:58 <bennofs> merijn, tsahyt: split-sections is faster than split-objects (compile time)
06:52:05 <joe9> I am using the package for writing to a socket https://hackage.haskell.org/package/connection-0.2.8/docs/Network-Connection.html . Whenever there is a byte of "\a", the bytestring is being split into multiple chunks. This is breaking the interface of the legacy app that I am connecting to. Is there a raw socket interface that is widely used?
06:52:14 <joe9> to avoid such an issue.
06:52:17 <merijn> tsahyt: Well yes, but switching from static to dynamic linking doesn't shrink the amount of binary required...
06:52:43 <tsahyt> merijn: well I have the library binaries lying around anyhow
06:52:56 <tsahyt> so bottom line I do save some space
06:54:07 <tsahyt> I'll try split objects
06:55:46 <kuribas> merijn: the IORef should switch error reporting on/off
06:56:09 <kuribas> merijn: the trace I mean
06:56:27 <merijn> kuribas: Honestly, I have no clue what'll happen
06:56:34 <merijn> @quote not.a.bug
06:56:35 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
06:56:39 <tsahyt> that did not seem to help at all
06:56:41 <mbw> Still, since there is some activity now, I'll try to ask this again. If I profile and application and I see a computationally expensive function at the top, and if it is something general like "basicUnsafeRead" or something. How can I find out where it is called most often? .prof files tend to be a little unwieldy in my opinion and don't compare to call graphs.
06:57:14 <opqdonut> mbw: scroll down in the prof file and you'll see the call tree
06:57:46 <opqdonut> mbw: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
06:58:02 <opqdonut> mbw: (search for "The usefulness of cost-centre stacks")
06:58:11 <mbw> opqdonut: That is true in principal, but with deeply nested functions living inside nested modules, everything scrolls off to the right...
06:58:33 <kuribas> mbw: I use flamingra
06:58:43 <opqdonut> mbw: you mean the output gets truncated somehow? haven't seen that
06:59:25 <mbw> No not truncated. The lines just become very long. So I either have to decrease the font size, or do some grep/awk-foo or something.
06:59:32 <opqdonut> right
06:59:36 <mbw> kuribas: What is flamingra?
06:59:55 <kuribas> https://hackage.haskell.org/package/flamingra
07:00:30 <opqdonut> mbw: you could try manual cost centers
07:01:16 <opqdonut> mbw: or something like -fprof-auto-top
07:02:58 <mbw> opqdonut: Do you know how to make that work with stack? There's "stack build --profile", but I think it uses -auto-all or whatever it's called now.
07:03:17 <mbw> kuribas: Thanks, I'll try that too.
07:04:02 <opqdonut> mbw: I guess you could try --ghc-options, but I don't know
07:04:45 <shapr> GOOD MORNING!
07:04:50 <Athas> Hello!
07:04:55 <mbw> Well hi there.
07:08:53 <cocreature> mbw: I use https://github.com/fpco/ghc-prof-flamegraph which looks similar to the one kuribas linked to
07:09:08 <Athas> cocreature: that one doesn't work with huge .prof files, does it?
07:09:42 <cocreature> Athas: I haven’t encountered any problems but I also haven’t tried feeding it gigantic .prof files :)
07:09:54 <cocreature> Athas: what makes you think it doesn’t work?
07:10:01 <Athas> cocreature: naive use of String functions.
07:10:04 <mbw> I haven't even heard about FlameGraph until now.
07:10:18 <Athas> But maybe I'm wrong!
07:14:08 <cocreature> mbw: it’s quite popular in the C/C++ crowd
07:17:49 <merijn> Meh, give me VTune instead :p
07:19:10 <mbw> I have a 1-year trial version installed (which I can't use anymore) and find it annoying to use. Still, the optimization output of icc is pretty great.
07:19:58 <mbw> But I think I installed the cluster-edition by accident, so it's my own damn fault.
07:23:44 <Boarders> I have just got a copy of the book Real World Haskell but read somewhere online that a lot of the code in the book no longer works, to what extent is that the case?
07:26:08 <mbw> Boarders: I think there is an answer on SO: https://stackoverflow.com/questions/23727768/which-parts-of-real-world-haskell-are-now-obsolete-or-considered-bad-practice . Practically speaking, the book still has its merits and the online version http://book.realworldhaskell.org/read/ has comments below every other paragraph where people describe what as changed and workarounds.
07:28:57 <merijn> Boarders: A lot of the code won't work when copy pasted, since, for example Parsec has evolved since RWH was published. But the underlying explanation of Parsec is still relevant, so understanding the new Parsec docs after reading RWH should be pretty trivial
07:29:00 <boxscape> what's the infix level of `op` infix style?
07:29:14 <merijn> boxscape: It depends :p
07:29:18 <boxscape> ah..
07:29:20 <boxscape> on what?
07:29:25 <merijn> boxscape: You can specify it the same way you can for infix operators
07:29:28 <boxscape> ah, I see
07:29:34 <merijn> boxscape: i.e. "infixl 4 `op`"
07:29:39 <boxscape> what is the default then?
07:29:42 <boxscape> if you don't set it
07:29:45 <merijn> boxscape: infixl 9
07:29:49 <boxscape> ok, thanks
07:29:51 <merijn> For both operators and `` notation
07:29:56 <boxscape> ah, interesting
07:31:01 <Boarders> thanks merijn and mbw
07:50:15 <camm> Hello. Do you know how can I parse the Yesod Routes and use them in an application that doesn
07:50:25 <camm> 't need the context of MonadHandler
07:55:55 <tdammers> maerwald: oh, you mean deadlocked at the protocol level... no, I don't think you can do that
07:56:18 <tdammers> maerwald: I guess you could design the protocol to never deadlock, and use a type system to verify this
08:01:19 <infandum> In optparse-generic, why can't I have a nested (non-recursive) ADT as generically derived?
08:01:50 <infandum> It says in the documentation that you can't have nested records, but says nothing about things like data Traffic = Green | Yellow OtherType | Red
08:04:20 <infandum> Even without that, just having a String type with read x :: Traffic does compile, but complains when running it that "OtherType" is an invalid argument when called with program --input "Yellow OtherType" (where that othertype is one of those types
08:05:49 <Jinxit> i have multiple data structures forming an AST together (mutually recursive), what is the best way to introduce annotation to all constructors?
08:06:09 <infandum> Nevermind, I just realized that it's due to eval, the lil' devil
08:09:28 <joe9> it is a pita to load all the modules in the project that I am working on with :m + . Is there a project specific ghci file/command that can help? I noticed that if I add a .ghci and put a :m+ module name, it does not work (says that the modules are not loaded yet)
08:10:14 <Jinxit> joe9: i use stack with "stack ghci"
08:11:00 <lyxia> Jinxit: I'd define the AST via Fix
08:11:05 <joe9> Jinxit: That is what I am using too. I can see the modules getting loaded. but, they are not in the context. For example, I do not have getCurrentTime
08:11:19 <joe9> Jinxit: I have to do :m +Data.Time before I can use it.
08:11:30 <lyxia> Jinxit: then you can just insert metadata via a separate functor
08:11:39 <Jinxit> lyxia: got a link or example or something?
08:11:43 <Jinxit> not familiar with Fix
08:12:01 <lyxia> type AST = Fix ASTF ; type AnnotatedAST = Fix (AnnotationF :.: ASTF)
08:13:05 <Jinxit> where ASTF is what?
08:14:40 <lyxia> you take "data AST", you rename it to "data ASTF a" and in every occurence of AST in a constructor you replace it by a.
08:14:53 <lyxia> https://www.reddit.com/r/haskell/comments/4x22f9/labelling_ast_nodes_with_locations/
08:15:11 <lyxia> Cofree is another solution
08:16:39 <Jinxit> i'll check out that thread, thanks
08:19:18 <Jinxit> lyxia: i see what you mean now i think, but only if my AST is one big sum type. what if it's multiple data declarations? ( http://lpaste.net/2642574045857447936 )
08:20:33 <lyxia> hmmm it becomes tricky to do with fix if you want to annotate every node no matter its type
08:21:50 <Jinxit> i could be doing this in a very odd way i guess, i'm just going on gut feeling :)
08:22:13 <Jinxit> but i wanted the type system to prohibit invalid ASTs as much as possible
08:23:55 <Jinxit> my first instinct was to parameterize all types on some 'a', and let the user (me) supply the annotation type that way
08:24:14 <lyxia> you can also open the recursion with a parameter f of kind (* -> *). data Statement i f = Assignment (f (TargetExpr f)) (f (SourceExpr f)) | ... ; 
08:25:03 <lyxia> oh right that is simpler, I just dislike having fields with the same meaning in different constructors.
08:25:15 <lyxia> haskell-src-exts does what you said
08:26:55 <Jinxit> because you could theoretically build them using different 'a'?
08:29:42 <lyxia> No. I mean that since they are the same, why should they occur in different places? Basically factor out Either (a, b) (a, c) into (a, Either b c).
08:30:50 <Jinxit> aha
08:32:19 <ph88^> how can i go from float 32 bits to integer 32 bits ?
08:34:03 <lyxia> floor?
08:34:30 <hexagoxel> ph88^: like reinterpret_cast?
08:34:59 <ph88^> i'm not familiar with reinterpret_cast
08:35:38 <mbw> ph88^ reinterpret_cast is a C++ thing.
08:36:25 <mbw> And most certainly not what you want. It means just "reinterpreting" bits in a different way.
08:36:30 <camm> Does anyone know how to generate a route from a Resource in Yesod (https://hackage.haskell.org/package/yesod-routes-1.2.0.7/docs/Yesod-Routes-TH.html#t:Resource)? 
08:41:03 <nshepperd_> ph88^: there are a few different ways to turn a float into Int, such as rounding. Which are you talking about?
08:41:42 <hexagoxel> ph88^: btw the ring buffer benchmark from yesterday has one significant error: `seq` does not force the elements of a list.
08:43:59 <ph88^> hexagoxel, which benchmark the one from ertes  ?
08:44:10 <ph88^> nshepperd_, truncating
08:44:11 <hexagoxel> ph88^: no, the old one
08:44:22 <ph88^> hexagoxel, the one from the blog ?
08:44:41 <hexagoxel> yes
08:45:25 <ph88^> well i already had concluded by various comments that it wasn't the greatest code there :P
08:45:51 <mbw> ph88^: Which one is your block if I might ask?
08:45:57 <mbw> *blog
08:46:04 <hexagoxel> good :)
08:46:10 <nshepperd_> ph88^: then you probably want one of the RealFrac methods
08:46:32 <ph88^> it's not my blog, but we were refering to https://johnlato.blogspot.nl/2011/07/circular-buffers.html
08:46:45 <nshepperd_> 'truncate' for instance
08:47:27 <mbw> Isn't there a goto ring buffer on hackage or something?
08:47:54 <ph88^> mbw, yeah there is actually :P but ertes was beating performance and we had fun with it
08:48:23 <mbw> Ah so it's a golfing thing :)
08:49:18 <ph88^> why does this program yield 3212 https://ideone.com/5fH6E2 in c i get different results https://ideone.com/U0elfF  the difference in these numbers occur already at 9 bits which should be well within the 32 or 64 bits precision
08:50:31 <ph88^> 0.321300 = 0b0,010100100  1000000101101111000000000110100011011011100010111010110010
08:50:35 <ph88^> 0.321200 = 0b0,010100100  0111010001010011100011101111001101001101011010100001011000
08:51:01 <ertes> hexagoxel: the element is already forced
08:51:10 <ertes> it's an Int generated from mwc-random
08:52:04 <hexagoxel> ertes: but isn't it supposed to force the values at those random indices?
08:52:45 <nshepperd_> ph88^: presumably it's 0.3213000000001... vs 0.32129999999997... or something
08:52:46 <ertes> hexagoxel: no, because they are already computed…  if you seq them, nothing changes
08:53:27 <hexagoxel> ertes: but there is a difference between computing indices and values at those indices, no?
08:53:31 <nshepperd_> Truncate throws away the fractional part. Maybe you want 'round' instead
08:53:43 <ertes> hexagoxel: ah, no, the indices aren't random
08:53:52 <ertes> the values themselves are random, and they are already computed
08:54:26 <ertes> yesterday i have verified that it doesn't make a difference, but it didn't expect it to either
08:54:41 <ertes> s/it didn't/i didn't/
08:55:33 <boxscape> http://lpaste.net/354516 something like this isn't in the lens library, is it? `alongside` is similar, but not quite the same
08:56:23 <bennofs> boxscape: that is not in the lens library because the result won't satisfy the lens laws in the general case
08:56:30 <boxscape> ah, I see, thanks
08:56:39 <bennofs> boxscape: combine _1 _1 would break the lens laws for example
08:56:45 <boxscape> ok, that makes sense
08:57:14 <ph88^> ertes, is the ring-buffer ready? :P
08:58:51 <camm> Maybe, someone of you know how to transform a [Piece typ] (http://hackage.haskell.org/package/yesod-routes-1.2.0.7/docs/Yesod-Routes-TH.html#t:Piece) into a route? 
08:58:53 <hexagoxel> ertes: well nothing is random, because the "random" indices are precomputed anyways. but forcing the elements should still make a difference, given non-constant-time access for Seq.
09:00:38 <bennofs> Hmm, I just noticed that stack does not fully lockdown the build plan. It uses hfsevents on mac and hinotify on linux
09:01:28 <bennofs> I guess there is no way to improve on this?
09:03:47 <hexagoxel> ertes: there is no need to discuss that benchmark if it is obsolete anyways, still i'd be interested if my criticism is indeed wrong.
09:05:05 <ertes> i'm happy to discuss this later…  i have to go now
09:05:22 <ertes> ph88^: no, but i'm still planning to do it today
09:05:42 <ph88^> sweet, there is no rush, but i'm just curious to see what you come up with :D
09:21:43 <NemesisD> what is the official name for a type alias associated with a typeclass, e.g. class Foo a where type Bar a
09:22:56 <Iceland_jack> that's an associated type FAMILY
09:23:00 <Iceland_jack> or type function
09:24:51 <NemesisD> Iceland_jack: i'm noticing some ambiguity issues, for instance class Job a where type JobOutput a; mkOutput :: JobOutput a -> SomethingElse, I get expected type JobOutput a0 -> RawJobOutput but got JobOutput a -> RawJobOutput
09:25:04 <NemesisD> erm s/RawJobOutput/SomethingElse/g
09:25:57 <Iceland_jack> NemesisD: type families aren't necessarily injective
09:26:13 <Iceland_jack> you can have (type JobOutput A = Int) and (type JobOutput B = Int)
09:26:18 <Jinxit> why is it that you can't pattern match on any constructor? i realize it doesn't always make sense, but sometimes it does
09:26:40 <Iceland_jack> if you pass an Int to a function (JobOutput a -> ...) is (a ~ A) or (a ~ B)
09:26:48 <NemesisD> Iceland_jack  i've seen that term come up from ghc and i'm not sure what it means. should i be using a multi param typeclass and fundeps or something?
09:27:01 <Jinxit> data Foo = Bar a | Baz a, someMap f (b a) = b (f a)
09:27:04 <Jinxit> like so
09:27:13 <Iceland_jack> NemesisD: Will JobOutput ever map two types to the same type?
09:27:37 <Iceland_jack> If not, you can define it as (type JobOutput a = res | res -> a) and it will work
09:27:39 <NemesisD> Iceland_jack: no, for every input there is exactly 1 associated output type
09:28:05 <Iceland_jack> no two inputs map to the same output?
09:28:14 <NemesisD> correct
09:28:23 <Iceland_jack> okay then you can enable TypeFamilyDependencies
09:29:13 <NemesisD> Iceland_jack: is this preferable to just a multiparam typeclass class Job i o | o -> i where mkOutput :: o -> SomethingElse?
09:29:40 <Iceland_jack> It's the more modern version
09:30:24 <Iceland_jack> although there are some things multiparam can do that it can't, I don't know details
09:30:38 <Iceland_jack> (you can always add a Proxy argument, or use AmbiguousTypes)
09:31:07 <Iceland_jack> using AmbiguousType means you have to use TypeApplications to specify the type with @Int)
09:31:51 <NemesisD> i'll give multi param type classes a try and see if i run into usability problems, since its more familiar
09:31:59 <Iceland_jack> okay
09:32:01 <Iceland_jack> afk
09:32:04 <ickabob> is 
09:36:39 <the_2nd> Is there no Alternative instance for Either?
09:38:48 <the_2nd> No instance for (GHC.Base.Alternative (Either MyErrorType))
09:38:48 <the_2nd>         arising from a use of ‘<|>’
09:40:16 <the_2nd> am I missing something?
09:40:51 <geekosaur> you want Except, not Either
09:44:44 <Zemyla> Hm, would it be possible at all for Haskell to special-case the form of a strict Maybe-like constructor?
09:45:54 <Zemyla> Wait, no. I was thinking that it might be possible to have, if data MaybeS a = NothingS | JustS !a, to basically have pointers to it be isomorphic to a union NULL, but what if a is a pointer type of that kind? :V
09:47:28 <geekosaur> sounds like you want to get down and dirty with the RuntimeRep stuff going on in ghc8
09:49:34 <the_2nd> geekosaur, the error now changed to
09:49:43 <the_2nd> No instance for (Monoid MyErrorType) arising from a use of ‘<|>’
09:50:08 <the_2nd> I guess I have to include <|> from somewhere else? (currently Control.Applicative)
09:50:47 <the_2nd> type MyEither a = Except MyErrorType a
09:51:01 <the_2nd> where MyErrorType is just a SumType
09:54:23 <ysahil> Hey, I wanted to add command line interface to my IRC bot using forkIO.Can someone describe exactly how do we achieve this?
09:54:33 <the_2nd> geekosaur, the syntax here is a bit more complex
09:54:46 <the_2nd> I guess I assumed something that was only true for Maybe
09:54:50 <the_2nd> one sec, pasting
09:55:39 <the_2nd> geekosaur, all functions are of the MyEither type http://lpaste.net/8449282552019025920
09:55:58 <the_2nd> seems like the combination of <|> and do seems to create problems
09:56:35 <ysahil> maxbound ::Int
09:57:58 <MarcelineVQ> it's the instance for Alternative for Except that matters in regards to the error you got
09:58:02 <geekosaur> there is not enough here for me to know what is going on
09:58:55 <the_2nd> geekosaur, type annotations for the used functions + type of MyEither?
10:04:49 <the_2nd> geekosaur, MarcelineVQ this should contain most of it : http://lpaste.net/5066810134982819840
10:05:03 <MarcelineVQ> when you use <|> with Except the instance of Alternative you're using is   (Functor m, Monad m, Monoid e) => Alternative (ExceptT e m)   where m is something called Identity when you use Except instead of ExceptT, it can be said that you're using   (Monoid e) => Alternative (Except e)   which says that the first type you provide Except must have a Monoid instance
10:05:47 <MarcelineVQ> that's a bit much at once but what it comes down to is that Except needs a way to combine the values it collects, which Monoid provides
10:06:15 <the_2nd> MarcelineVQ, is there a way around it? Why doesn't it abort on the first failure?
10:06:44 <MarcelineVQ> So you either need to have a monoid instance for MyErrorType, or use a type that already has one, like a list    [MyErrorType]
10:07:07 <the_2nd> I guess using a list would be better
10:07:35 <MarcelineVQ> it does abort, that didn't compile, I'm not quite sure what you're asking
10:08:15 <the_2nd> I mean your suggestion with [MyErrorType]
10:08:33 <the_2nd> I guess the alternative would be to simply use a string
10:10:22 <MarcelineVQ> I've not used Except so​ I don't have advice to offer on it but I understand that using a list to collect your error type is an easy way to go
10:10:53 <MarcelineVQ> something like this perhaps   type MyErrors a = Except [MyErrorType] a
10:11:40 <the_2nd> MarcelineVQ, yep exactly. I got it to compile. Thanks a lot
10:31:05 <jophish> Keep up the hard work, QuickCheck: "Gave up after 0 tests"
10:32:29 <monochrom> haha
10:33:16 <kadoban> Heh
11:39:32 <rubenwardy> Hi! I'd like help with monoids and types: https://gist.github.com/rubenwardy/0ce4b0be4c0b56e9e3b5a8e9482be831
11:40:08 <rubenwardy> basically I want to make it so different types conform to those functions
11:40:22 <rubenwardy> but there's a syntax error on the instance declaration line
11:40:35 <rubenwardy> ‘PState’ is applied to too many type arguments
11:40:35 <rubenwardy>     In the instance declaration for ‘StateM (PState n)’
11:40:53 <rubenwardy> is it possible to use Monoids with types? Or does it need to be a constructor?
11:41:05 <glguy> rubenwardy: Your paste doesn't appear to have anything to do with monoids
11:41:20 <glguy> You can't apply the type PState to n, it has kind *, it doesn't take a parameter
11:41:31 <rubenwardy> what's that structure called then?
11:41:40 <glguy> Also PState is a type synonym, you shouldn't be making an instance for it
11:42:19 <glguy> You can't put type signatures (lines 8 and 11) in an instance declaration without a language extension
11:43:40 <rubenwardy> I want to make both (String->Integer) and [(String,Integer),[Integer]) conform to an "interface" as you will, so I can make a future function generic (with no need to C+P)
11:44:27 <rubenwardy> I can't change the definition of PState, but I could wrap it up - but I feel like that's not very clean
11:45:40 <hhhhhhhh> > ghci
11:45:42 <lambdabot>  error: Variable not in scope: ghci
11:45:42 <hhhhhhhh> GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
11:45:44 <hhhhhhhh> ghc: panic! (the 'impossible' happened)
11:45:46 <hhhhhhhh>   (GHC version 7.10.3 for x86_64-unknown-openbsd):
11:45:48 <hhhhhhhh>         interactiveUI:setBuffering2
11:45:50 <hhhhhhhh> anyone know what to do about that :d
11:46:04 <glguy> don't type "> ghci"?
11:46:17 <cocreature> hhhhhhhh: upgrade ghc and see if you can reproduce it with 8.0.2?
11:46:19 <c_wraith> what os are you on? 
11:46:35 <cocreature> glguy: well that shouldn’t cause a ghc panic
11:46:53 <hhhhhhhh> c_wraith: openbsd 6.1
11:46:54 <glguy> cocreature: I didn't realize at first that the rest of that was a pasted error message, I read it as lambdabot output
11:47:27 <cocreature> there was some discussion about ghc on openbsd on ghc-devs a day ago but I haven’t read what it was about
11:47:42 <hhhhhhhh> cocreature: openbsd only has 7.10.3 in the ports tree
11:48:52 <c_wraith> hhhhhhhh, report an upstream bug. clearly something is broken in how ghc is packaged. 
11:49:22 <c_wraith> hhhhhhhh, but it looks like ports isn't doing anything interesting 
11:49:36 <maerwald> you mean a downstream bug
11:49:45 <c_wraith> err, yes 
11:50:16 <c_wraith> hhhhhhhh, try just installing a more recent binary distribution of ghc 
11:50:17 <cocreature> a coupstream bug
11:50:51 <cocreature> hhhhhhhh: you can find a build of 8.0.2 here https://downloads.haskell.org/~ghc/8.0.2/
11:51:51 <c_wraith> hhhhhhhh, you can (and should) install it user-local, so it doesn't interfere with anything from portage
11:55:23 <hhhhhhhh> that doesn't appear to actually contain any binaries :d
11:56:01 <hhhhhhhh> and the configure script doesn't work
12:10:20 <tsahyt> is there a library implementing something like data Some (x :: k -> *) = forall a. Some (x a)?
12:10:43 <jle`> tsahyt: there are several floating around
12:11:19 <tsahyt> Hoogle is not very helpful unfortunately
12:11:21 <jle`> tsahyt: the one i normally use is from http://hackage.haskell.org/package/type-combinators-0.2.4.3/docs/Type-Class-Higher.html#t:Some
12:11:25 <jle`> type-combinators
12:11:38 <jle`> but another popular one is in dependent-sum
12:11:40 <jle`> http://hackage.haskell.org/package/dependent-sum-0.4/docs/Data-Some.html
12:11:43 <jle`> since it integrates with dependent-map
12:12:04 <tsahyt> thanks
12:12:17 <tsahyt> the first one looks exactly like what I had in mind, with versions for arities other than 1
12:12:51 <jle`> the two are identical, but i often find myself using a lot of type-combinators functionality in general, so i just use that one 
12:13:35 <tsahyt> I should take a closer look at that package. I've never used it
12:14:22 <jle`> it's basically all of the typical type-level combinators you run into when doing normal dependently typed stuff in haskell, like hvecs, indexors, generic products, etc.
12:14:34 <jle`> all of the inductive versions
12:29:33 <joe9> any experiences with liquid haskell? Is it used widely? It seems a step down from dependent types. but, probably better a good idea to use it for existing code without breaking anything.
12:29:50 <c_wraith> I much prefer Rich Eisenberg's "basic" type level programming examples. though they might require a new ghc release to work.. 
12:29:53 <emc2> so, forgive my ignorance, but I've finally decided to take the plunge and convert my projects over to Stack
12:30:37 <emc2> how do I actually publish a project so that it's available to Stack?
12:31:05 <jackhill> emc2: you mean so that its availbe via Stackage?
12:31:18 <emc2> I uploaded a new rev of the first of the series (HUnit-Plus) to hackage last night, but it seems that stack isn't picking it up
12:31:31 <c_wraith> https://m.youtube.com/watch?v=soKl1IslU-I here are his examples... 
12:31:32 <emc2> yeah
12:32:31 <tsahyt> emc2: stackage requires manual adding
12:32:36 <MarcelineVQ> c_wraith: https://www.youtube.com/watch?v=P4Io2CRpwyg is pretty neato too
12:32:42 <emc2> more generally, 'stack test' on projects that depend on HUnit-Plus complains about having no specified version
12:33:03 <tsahyt> https://github.com/fpco/stackage#add-your-package
12:33:12 <emc2> but google (or rather, duckduckgo) doesn't seem to produce any guide
12:33:18 <c_wraith> MarcelineVQ, ooh, thanks. I haven't seen this one. 
12:33:43 <MarcelineVQ> stephanie focuses on trees in that one iirc
12:34:08 <tsahyt> emc2: until your package is on stackage, you'll need to specify a version under extra-deps in your stack.yaml
12:34:42 <tsahyt> i.e. HUnit-Plus-2.0.0
12:34:49 <c_wraith> I haven't seen any of her talks yet. I'm happy to come across one, because of all the great ghc type system work she's been leading. 
12:35:14 <MarcelineVQ> hehe yeah, well she's richard's sup afaik, or whatever the term is in the academic world
12:36:00 <ezyang> advisor 
12:36:17 <c_wraith> she was until he got his degree and moved to another university. :) 
12:36:22 <MarcelineVQ> :>
12:36:31 <cocreature> iirc nomeata is now working there
12:37:10 <MarcelineVQ> yeah, actually I still have to watch https://www.youtube.com/watch?v=jcL4bp4FMUw
12:37:42 <cocreature> heh that’s on my list as well :)
12:40:52 <joe9> anyone has an Arbitrary instance for Text or Bytestring that does not generate NULL's ?
12:44:16 <Cale> joe9: Note that rather than a separate Arbitrary instance, you can use  forAll  with a generator that filters out NULLs
12:45:24 <Cale> something like  forAll (BS.filter (/= 0) <$> arbitrary) (\s -> ...)
12:45:36 <joe9> Cale, Thanks, will try to do it.
12:46:40 <cocreature> joe9: if you do want to write an instance "suchThat" might come in hand
12:46:42 <cocreature> *handy
12:47:12 <joe9> Cale, I have a bunch of data types using the Text data type. But, all these Text's cannot have Null values. I plan on having a newtype NonNullText and then use the above Arbitrary instance for it. good idea? or, is there a better way of going about it.
12:48:00 <Cale> That's a reasonable idea. You might find the newtype wrappers a little annoying depending on what you're doing.
12:48:11 <Cale> But it'll work
12:48:38 <joe9> cocreature: Thanks , will check suchThat.
12:48:40 <joe9> Cale, Thanks.
12:51:02 <joe9> cocreature: suchThat is a very good idea. Thanks again.
12:52:18 <cocreature> joe9: I was in a pretty similar situations recently and was very happy to discover that “suchThat” exists :)
12:54:08 <WarmCookie> Cale: ping :3
12:54:46 <WarmCookie> Guess what I just received? :D (Spoiler: http://i.imgur.com/mthYv7d.jpg)
12:55:04 <cocreature> WarmCookie: good choice :)
12:55:31 <WarmCookie> cocreature: I think you made the original recommendation actually :P
12:55:39 <cocreature> I did? I don’t even remember :)
12:57:23 <thimoteus> nice!
13:00:57 <mniip> is that a second order checkerboard
13:05:02 <DrMentats> so, I recently got started with haskell and purely functional programming in general and I'm still getting used to it
13:05:11 <DrMentats> so I was wondering if this is the right place to ask for some more "practical," amateurish advice?
13:05:21 <brynedwardz> Sure is
13:05:39 <DrMentats> cool
13:05:52 <Tuplanolla> We also have #haskell-beginner if you feel overwhelmed by the types in here, DrMentats.
13:06:13 <merijn> DrMentats: This is the place to ask anything from practical amateurish to "impractical, theoretical and professional" :p
13:06:23 <WarmCookie> * #haskell-beginners  (plurial)
13:06:56 <Tuplanolla> You can tell I don't go there very often, WarmCookie.
13:07:14 <DrMentats> thanks, guys
13:07:22 <merijn> I think being overwhelmed here is a good way to learn by osmosis :p
13:07:29 <WarmCookie> In the end, it's the same people. As long as we're aware of the level of the question, we'll answer accordingly.
13:08:13 <DrMentats> well, type theory still overwhelms me quite a bit, but hopefully I'll get the hang of it at some point
13:09:01 <tolt> Is there an easy way to hide a list of imports in the repl? I'd like to have some more room....
13:09:20 <Tuplanolla> You can `:set prompt`, tolt.
13:09:32 <tolt> ah thanks! Tuplanolla
13:09:35 <Tuplanolla> What operating system are you using, tolt?
13:09:42 <tolt> debian
13:10:02 <joe9> Cale, cocreature: as an fyi, http://dpaste.com/3N9W3Q5 this is what I ended up with. Thanks.
13:10:16 <Tuplanolla> Try this one, tolt: `:set prompt "\ESC[37m\x2508\x2504\x254c\x2500\x254c\x2504\x2508 \ESC[93m\x03c2( \x361\ESC[92;1m\xb0\ESC[91m \x35c\ESC[93;22m\x296 \x361\ESC[32;1m\xb0\ESC[93;22m)\x0242\ESC[37m \x2508\x2504\x254c\x2500\x254c\x2504\x2508\ESC[0m\n"`
13:10:33 <Tuplanolla> Debian should have the fonts for it.
13:11:00 <tolt> lol Tuplanolla
13:11:11 <WarmCookie> tolt: You should be able to create a ~/.ghc/ghci.conf file with `set prompt ">"` in it to make it permanent then.
13:11:41 <tolt> Yeah. I just couldn't remember the way to change the prompt. I imported a lot of things and had no room to see anything!
13:14:06 <merijn> WarmCookie: Clearly the right way to do things is: https://github.com/merijn/dotfiles/blob/master/dotfiles/ghci#L1
13:16:24 <sm> merijn: that's nice, but I think I'd need "λ> " to see it as a prompt
13:19:18 <sm> incidentally, I wish you could exit ghci with ctrl-d. Now I see why it appears to work sometimes (stty echo gets set in my emacs shell)
13:20:29 <koala_man> sm: can't you?
13:21:11 <sm> woah. It's only when in emacs, isn't it
13:21:33 <sm> stupid shell-mode
13:21:54 <Sornaensis> today I put haskell in a toaster
13:25:38 <hexagoxel> testing some new monad-is-just-$FOOD theory?
13:33:12 <johnw> has anyone used z3 to build a register allocator?
13:33:40 <zv> johnw: donald knuth describes the process in his latest fascicle of 'The Art of Computer Programming'
13:33:46 <zv> Under the heading of graph coloring
13:33:56 <johnw> is this only available in print?
13:34:06 <zv> No, it's available on his website for free
13:34:10 <johnw> thanks!
13:34:27 <zv> The Art of Computer Programming Volume 4, Fascicle 6: "Satisfiability"
13:35:03 <johnw> I have a theoretical machine with multiple execution "slots", and where each operation can have variable latency (e.g., may occupy multiple execution "steps"), and I want to build execution plans based on criteria like "early as possible" and "late as possible"
13:35:04 <zv> if you are intent on doing it in z3, it depends on if you want to use the API or write your solution in SMTLIB/Datalog/etc
13:35:20 <johnw> I'd rather do it in Haskell
13:36:57 <zv> i personally dont understand sbv, but you could make a good run of it.
13:37:14 <johnw> Tikhon Jelvis was recommending that I bypass sbv and just using the haskell-z3 bindings
13:40:10 <Tuplanolla> What do you get when you halve an "octet"? A "quad"?
13:40:20 <mniip> nibble
13:40:52 <Tuplanolla> Is that actually half a byte or half an octet?
13:41:11 <pmn> yes
13:41:18 <mniip> https://en.wikipedia.org/wiki/Nibble
13:41:27 <zv> it doesn't seem sensical to half a byte, so I would assume octet
13:41:49 <Tuplanolla> Thank you.
13:41:51 <pmn> half-byte or semi-octet
13:42:20 <mniip> half-half-halfword
13:42:31 <mniip> or even half-half-half-halfword on some
13:43:19 <pmn> we can abbreviate each 'half' as 'ha'
13:43:39 <kazagistar> "roflword"
13:50:17 <nbro_> hey guys
13:51:00 <nbro_> what’s the name of the <- in a do block, i.e. the symbol that binds an action’s result to a variable?
13:53:58 <johnw> it's sugar for bind, where the result is given a name:  x <- foo  ==  foo >>= \x -> ...
13:56:08 <nbro_> johnw: I’m asking if there’s a specific name that you give to that symbol
13:56:13 <glguy> It doesn't have a name, "<-" is just part of the syntax of do expressions.
13:56:17 <nbro_> can I call it an operator?
13:56:24 <glguy> No, it's not an operator
13:56:37 <nbro_> glguy: what’s it then?
13:56:53 <glguy> it part of the syntax of do expressions
13:57:20 <Tuplanolla> Maybe "bind syntax" if you insist giving it a name, nbro_.
13:57:30 <nbro_> glguy: so it’s part of a do expression in the same way that in is part of the let … in … expression?!
13:57:38 <glguy> yeah
13:57:43 <nbro_> another unrelated question
13:59:00 <nbro_> I have read that IO actions can only be performed in the main, but there are exceptions, which ones?
13:59:12 <nbro_> (not so unrelated, actually)
13:59:23 <johnw> unsafePerformIO is probably the main exception
13:59:27 <merijn> nbro_: The only exception is "if you use unsafeX"
13:59:30 <johnw> (I couldn't resist)
13:59:36 <merijn> nbro_: Other than that, there aren't any
13:59:41 <glguy> Foreign exports lead to actions that are run outside of main
13:59:52 <glguy> There doesn't even need to be a Haskell main with foreign exports
14:00:09 <merijn> glguy: Only if control flow doesn't start in Haskell main?
14:01:13 <glguy> foreign exports are a bit of a peer to main for being entry points into Haskell, like main they run in their own bound thread
14:04:43 <johnw> is there an "N Color Theorem" for arbitrary dimensions?
14:06:40 <merijn> johnw: I dunno what your problems are, but I'm glad I'm not having them ;)
14:06:50 <johnw> this last one was just a curiosity :)
14:06:57 <johnw> since I'm reading that fascile that I was referred to earlier
14:07:10 <Tuplanolla> That certainly sounds fun, johnw.
14:07:41 <johnw> right now I just need to learn how to express the input to z3 for the theoretical machine I mentioned above
14:07:53 <Tuplanolla> I recently spent some time on classical mechanics in arbitrary dimensions.
14:08:07 <Tuplanolla> I need a blog so I can write about these silly adventures.
14:08:22 <johnw> you do, so that I can read them
14:08:48 <Tuplanolla> I can tell you now that the highlight was the infinite-dimensional the moment of inertia.
14:09:16 <johnw> I call that moment "8am"
14:11:15 <Tuplanolla> For example for a r-radius m-mass ball it approaches that of a r-distance m-mass point perpendicular to the axis of rotation.
14:14:13 <nbro_> another question
14:14:34 <nbro_> is main considered a special name in Haskell, right?
14:14:57 <johnw> yes, it's what the linker looks for
14:16:28 <merijn> nbro_: Not "more special" than, e.g. main in C, though
14:16:43 <merijn> nbro_: And you can simply invoke the main action in other actions
14:17:59 <c_wraith> you can name something main at the top level in every module, and you can name a local declaration main any time. 
14:18:09 <c_wraith> so it's really not very special. 
14:18:19 <glguy> (and you can tell GHC to use a different name)
14:18:34 <nbro_> merijn: you can invoke the main action in other actions? but isn’t the main action the entry point of an Haskell program?
14:19:03 <c_wraith> nbro_, that doesn't make it special. 
14:19:31 <glguy> main = putStrLn "Keep looping" >> replicateM 2 main
14:19:31 <c_wraith> nbro_, it's still an IO action that can be used just like any other IO action. 
14:19:57 <Tuplanolla> Does the C standard prohibit calling `main` again?
14:19:57 <merijn> nbro_: What glguy wrote, you can simply invoke it recursively
14:20:03 <merijn> Tuplanolla: Don't think so
14:20:08 <c_wraith> Tuplanolla, nope. 
14:20:31 <Tuplanolla> Something did!
14:20:31 <c_wraith> Tuplanolla, look up the famous 12 days of Christmas from ioccc
14:20:51 <nbro_> merijn: you mean we can invoke it infinitely
14:21:11 <merijn> nbro_: Sure. Probably not very useful, but you can
14:21:20 <nbro_> ok
14:24:13 <c_wraith> Tuplanolla, http://udel.edu/~mm/xmas/
14:24:46 <Tuplanolla> I have the entire IOCCC archive already, c_wraith.
14:25:17 <Tuplanolla> It's a must-have on any system.
14:25:29 <nbro_> a few days ago I said in another chat that IO in haskell is performed using monads
14:25:37 <c_wraith> Tuplanolla, then why did you ask if main could be recursive in C? I think that feature is used more there than in all other software. :) 
14:25:48 <nbro_> but someone which is also part of this channel got angry
14:25:53 <nbro_> because apparently that’s wrong
14:26:10 <c_wraith> nbro_, nah. monad is just a handy abstraction that IO values support. 
14:26:15 <Tuplanolla> I recalled that it was left undefined by the standard, but usually allowed by implementation for consistency, c_wraith.
14:26:38 <nbro_> c_wraith: can you clarify you better?
14:26:39 <c_wraith> nbro_, the important part is that IO actions are values. 
14:27:01 <Tuplanolla> The no-recursive-main idea must originate from somewhere.
14:27:26 <c_wraith> nbro_, that's how you get purity and interaction with the world at the same time. 
14:28:03 <c_wraith> nbro_, you define IO values as representing system interaction, but inert in and of themselves. 
14:28:42 <c_wraith> nbro_, and then the linker is responsible for connecting up the runtime to execute the instructions within the IO value named main. 
14:29:01 <nbro_> c_wraith: of course I understood that using monads is a way to get purity from an unpure world, but I do not understand what exactly do you mean with "io values support monads"
14:29:20 <c_wraith> nbro_, monads have nothing to do with purity. 
14:29:56 <c_wraith> nbro_, you can have monads in languages that don't enforce purity. like.. um, well, Scala. 
14:30:03 <johnw> monads can be used to embed certain notions within a pure context, but they are not themselves related to purity
14:30:18 <nbro_> c_wraith: of course I understood you can have monads in a language that doesn’t enforce purity
14:30:21 <nbro_> that’s no my doubt
14:30:24 <nbro_> of course!
14:30:30 <nbro_> I understood what monads is
14:30:50 <nbro_> but in haskell, if aren’t monads which provide purity when performing IO, then what’s that?
14:31:02 <Tuplanolla> Just the `IO` type, nbro_.
14:31:08 <c_wraith> the IO type provides purity when using IO 
14:31:21 <nbro_> you mean Monad IO?
14:31:24 <c_wraith> the fact that it can be made a monad is 100% irrelevant 
14:31:34 <c_wraith> no, I mean IO
14:31:44 <nbro_> :t IO
14:31:45 <lambdabot> error:
14:31:45 <lambdabot>     • Data constructor not in scope: IO
14:31:45 <lambdabot>     • Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
14:31:49 <johnw> also, the specification of IO actions is totally pure; it's the execution of them at runtime which can involved effects outside the program
14:31:49 <c_wraith> with zero uses if the word monad. 
14:31:52 <nbro_> :k IO
14:31:54 <lambdabot> * -> *
14:31:57 <nbro_> :i IO
14:33:45 <c_wraith> nbro_, are you able to concatenate lists because [a] is an instance of Monoid? 
14:33:56 <Tuplanolla> @google haskell i/o is not a monad
14:33:58 <lambdabot> https://www.haskell.org/tutorial/io.html
14:34:10 <Tuplanolla> No, bad lambdabot.
14:34:28 <Tuplanolla> @google haskell "i/o is not a monad"
14:34:29 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
14:34:48 <Tuplanolla> Check that one out, nbro_.
14:35:26 <nbro_> Tuplanolla: ok, I will read it ;)
14:35:30 <nbro_> but now my question is
14:35:54 <nbro_> why is the monad word mentioned when talking about IO?
14:36:15 <Tuplanolla> You've moved on to the hard questions now.
14:36:32 <nbro_> for example, it’s very clear the usefulness of monads in maybe
14:36:34 <nbro_> :t maybe
14:36:36 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:37:04 <Sornaensis> nbro_: monads are used for sequencing IO
14:37:07 <Sornaensis> well the idea
14:37:32 <c_wraith> nbro_, because lots of people make haskell sound harder than it is. 
14:38:07 <c_wraith> nbro_, anyone who focuses on Monads is making it harder for themselves (and everyone they talk to) to learn haskell. 
14:39:19 <nbro_> c_wraith: monads are not difficult, what’s difficult is interpreting ambiguous statements
14:39:44 <MarcelineVQ> nbro_: hmm? Monad isn't involved in the maybe function
14:40:29 <Tuplanolla> You could as well say "list monoid" or "product bifunctor", nbro_.
14:40:36 <c_wraith> monads are a level of abstraction most people aren't equipped to handle immediately, as beginners, because it depends on ideas they're not yet comfortable with. 
14:40:40 <Tuplanolla> It's superfluous, not ambiguous.
14:41:18 <c_wraith> so when a beginner thinks Monad is important and demands they must learn what it is first, they are making things harder for themselves. 
14:42:02 <c_wraith> so when you say things like IO uses monads, you are helping to convince beginners that haskell is harder than it is. 
14:42:51 <nbro_> c_wraith: well, I think people should learn well the concepts that are discussed most when first approaching a language, and that’s the case of monads in haskell
14:43:55 <c_wraith> nbro_, it's almost pointless to try to learn monads as used in Haskell before you're comfortable with parametric polymorphism and higher-kinded type variables. 
14:44:26 <c_wraith> you just don't have the base knowledge to make sense of the type of (>>=) without those. 
14:45:31 <nbro_> c_wraith: of course you should learn the prerequisites first
14:45:35 <mengu> hi all
14:45:46 <mengu> i was reading this post https://aphyr.com/posts/342-typing-the-technical-interview
14:45:48 <c_wraith> nbro_, but you can write a lot of haskell without ever knowing what a monad is. 
14:46:14 <mengu> i saw this line "class First list x | list -> x ". did some digging turns out it is called functional dependency
14:46:16 <ggVGc> you can write monads too without really knowing what a monad is!
14:46:24 <mengu> so what exactly this is doing?
14:47:30 <c_wraith> nbro_, but every time you talk about how important monads are, you contribute to the impression that haskell is weird and arcane and demands you know everything before you start. 
14:47:50 <c_wraith> mengu, in general, or in the context of that (comedic) article? 
14:47:59 <mengu> c_wraith: in general
14:48:11 <lordcirth> mengu, that blog is great
14:48:22 <mengu> lordcirth: i loved the hexing post
14:48:30 <mengu> cuz i could understand it lol
14:48:39 <mengu> but cannot move on before understanding this line :D
14:49:06 <c_wraith> a functional dependency tells ghc that if it knows some of the parameters to the multi-parameter type class, the rest can be figured out from what it knows. 
14:49:53 <mengu> so when it only has list, it can figure out x?
14:50:10 <c_wraith> this is different from a multi-parameter type class without a functional dependency, where it has to know every type argument to figure out which instance to use. 
14:50:15 <c_wraith> mengu, yes
14:50:29 <mengu> c_wraith: that's why he defined two instances
14:50:37 <mengu> instance First Nil Nil
14:50:37 <mengu> instance First (Cons x more) x
14:50:43 <mengu> this is actually how ghc knows it?
14:51:11 <c_wraith> ghc does a bit of trickery.. it just assumes it will know, and figures it out later. :) 
14:51:24 <mengu> okay, did not make any sense lol
14:51:37 <c_wraith> yeah, it's... kind of odd at first. 
14:51:54 <c_wraith> also, the way it's being used within the context of that post is more... abused. 
14:52:08 <c_wraith> it's being used to create type level functions. 
14:52:30 <c_wraith> which you can kind of claim they always do, but that's usually not the point. 
14:53:01 <mengu> he's actually using types whereas he could use functions, imho
14:53:39 <c_wraith> I'm not sure it's a he, but that's the whole point of that post. everything is being done at the type level just to be ridiculous
14:54:05 <mengu> yup, it's a he
14:54:52 <Tuplanolla> This reads like Prolog with the return value there as an argument.
14:55:29 <c_wraith> the hexing example is completely ridiculous because people using clojure do not really write custom classloaders to load optimized byte code written by hand in hex. 
14:56:07 <c_wraith> the typing example is ridiculous because people using haskell don't really write their whole program at the type level. 
14:57:01 <ystael> c_wraith: more importantly, i want to know where i can sign up to program with a coven of seiðkonur
14:57:25 <c_wraith> ystael, that is the most important question. I wish I knew. 
15:04:17 <nbro_> Tuplanolla: in tha article you mentioned, it says: "A model of I/O is a data type, not a data type constructor." what’s the difference? Even though I could infer from the info in the same article, reading a precise definition gives you a better understanding and you memorize better
15:04:25 <nbro_> (not you)
15:04:26 <nbro_> lol
15:04:34 <nbro_> (I wanted to say that it’s mentioned)
15:04:54 <Tuplanolla> It may have kind `*` instead of `* -> *` as we have it, nbro_.
15:06:38 <nbro_> when you say "it" you’re referring to the data type or data type constructor? the data type constructors, in one example, is "data IO a"
15:06:51 <nbro_> :k IO
15:06:52 <lambdabot> * -> *
15:07:31 <Tuplanolla> They're saying the type parameter is not essential to the concept of io itself, nbro_.
15:07:43 <Tuplanolla> Don't read too deep into it.
15:08:26 <nbro_> ok
15:08:29 <nbro_> one more question
15:08:58 <nbro_> it’s also stated that: "All we have done is add a parameter to Stop to hold a polymorphic value. The resulting data type IO ()"
15:09:06 <nbro_> why is the resulting type IO ()
15:09:09 <nbro_> why ()?
15:09:32 <nbro_> :t ()
15:09:34 <lambdabot> ()
15:09:41 <nbro_> :i ()
15:09:43 <Tuplanolla> You ought to finish the sentence before asking questions, nbro_.
15:10:44 <nbro_> I finished the reading the sentence
15:11:11 <nbro_> it doesn’t tell you why the resulting type is IO ()
15:11:53 <sphinxo> So I want to use: https://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Applicative-Lift.html to accumulate errors as I typecheck
15:12:22 <sphinxo> I need to write a monoid instance for my error data type?
15:12:22 <Tuplanolla> The unit type is there just to pose an example, nbro_. It doesn't say the type argument has to always be `()`.
15:12:46 <sphinxo> ( more specifically this: https://hackage.haskell.org/package/transformers-0.5.4.0/docs/Control-Applicative-Lift.html#t:Errors )
15:13:44 <nbro_> Tuplanolla: then that article is very ambiguous
15:14:15 <sphinxo> ahh wait, I can just do: type ValidatorM = Errors [ValidationError]
15:14:31 <sphinxo> and then failure [SomeError]
15:14:37 <c_wraith> sphinxo, yeah. pre-existing instances. :) 
15:15:36 <nbro_> for example, this sentence is full of ambiguities "These combinators satisfy the monad laws, so this data type constructor IO is a monad, even though the type modeling input and output, which is IO ()"
15:15:40 <hololeap> I'm hitting an error I don't quite understand: https://gist.github.com/hololeap/281c9af389e1278b04c64791aa52dae9
15:17:18 <Gurkenglas> hololeap, add {-# LANGUAGE FlexibleContexts #-} at the top of the file
15:17:41 <Tuplanolla> Hmm. I don't see it, nbro_.
15:18:05 <hololeap> Gurkenglas: is that necessary though? i have used the MonadState class before and didn't have to use that pragma
15:18:30 <Gurkenglas> hololeap, you can also add a type signature to process that does not involve MonadState
15:20:10 <nbro_> Tuplanolla: "even though the type modeling input and output, which is IO ()" is not understandable because "the type modeling input and output" is not defined
15:20:10 <c_wraith> hololeap, there is a bit of a new thing in ghc 8.. before that, you could leave out extensions that enabled types that appeared implicitly in your terms, if they never appeared explicitly. 
15:20:39 <nbro_> IO(), again, if that’s an example, it’s still not understandable why one would choose () instead of another type as argument to IO
15:20:47 <c_wraith> hololeap, as of ghc 8, you need to enable the extension if any term has an inferred type that requires it. 
15:21:16 <Tuplanolla> They chose `IO ()`, because it's isomorphic to `Dialogue2`, nbro_.
15:21:26 <c_wraith> hololeap, this mostly (only?) applies to Flexible contexts and FlexibleInstances 
15:21:54 <Tuplanolla> It all goes back to simply offering a different representation for the original `Dialogue`.
15:22:03 <hololeap> I just added `process :: CardSet -> CardM String` above the process definition. It's kind of silly that I have to do that or use a pragma, IMO
15:23:28 <c_wraith> hololeap, why is that? the inferred type is illegal without the pragma. 
15:25:11 <nbro_> Tuplanolla: I understood that Haskell has algebraic data types and those one can have morphisms between them, but in this case, in a high level description, what would be a morphism between IO() and Dialogue2?
15:25:14 <hololeap> since `get` is returining a CardSet, and `processCard` is returning a CardM String, it seems obvious that the type signature of `process` would be `CardSet -> CardM String`. i obviously don't understand something here
15:25:18 <nbro_> *and thus
15:26:21 <nbro_> after this I’ll stop bothering you :D
15:26:25 <c_wraith> hololeap, what part of that definition allows it to infer the return type is CardM String? 
15:28:13 <hololeap> `processCard c = get >>= process`. if processCard has a type declaration that says it returns CardM String, wouldn't it follow that `process` also returns it since it is last in the bind chain?
15:28:36 <Tuplanolla> Let `f` be such that `f (StopIO ()) = Stop2; f (ReadChanIO str cont) = ReadChan2 str (f . cont); ...`, nbro_.
15:28:55 <c_wraith> hololeap, what part of the definition of process is that specific? 
15:29:54 <c_wraith> hololeap, all I see in process are a couple MonadState operations. not enough context to pin things down further. 
15:32:16 <hololeap> c_wraith: I'm not trying to argue, but I just don't see how it's ambiguous. `processCard` returns a CardM String, and that would mean that `process` also returns a CardM String
15:33:06 <hololeap> let me just upload the whole thing...
15:37:35 <nbro_> the craft of understanding when to delve deeper
15:38:39 <EvanR> we must go deeper
15:40:09 <hololeap> c_wraith: ok, it's compiling now. my question is why do i need to explicitly give the type signature for `process` on line 82: https://gist.github.com/hololeap/281c9af389e1278b04c64791aa52dae9
15:40:14 <nbro_> EvanR: if possible, but we need a good scheduler
15:42:28 <c_wraith> hololeap, look at what the type inference has to go on. you use (>>), pure, modify, and retry. 
15:42:43 <c_wraith> hololeap, none of those are specific to CardM
15:43:24 <sphinxo> safe (!!) to use?
15:43:40 <c_wraith> hololeap, so all it knows is a bunch of constraints.. MonadState, Applicative, Monad, whatever retry is from.. 
15:43:51 <sphinxo> or maybe I should use arrays or vector?
15:43:53 <nbro_> lol, linux uses a completely fair scheduler
15:43:54 <nbro_> ahah
15:44:17 <nbro_> that’s kind of a paradox
15:44:22 <c_wraith> hololeap, but no concrete type. 
15:45:11 <darpan> whats up folks
15:45:35 <hololeap> c_wraith: ok, i'm starting to see the picture. but, since CardM is just a synonym of sorts, and `StateT CardSet IO` is the only StaetT transformer in the stack, what else would `get` return other than CardSet?
15:45:53 <darpan> can anyone recommend a good books on learning categories w/ Haskell or the otherway around
15:46:46 <c_wraith> hololeap, well, it does know it returns a CardSet. there is enough to infer that. and that's actually the problem. it knows one concrete argument to MonadState, but not the other. 
15:47:36 <c_wraith> hololeap, in order to express a constraint with two type arguments where one is concrete and the other is polymorphic, you need to enable FlexibleContexts
15:48:19 <hololeap> the only other thing i added to the type definition was that it returns CardM String and that should be obvious given the type of `processCard`. _that_ is where i don't see the ambiguity
15:48:33 <EvanR> darpan: not sure thats a great way... categories via haskell is kind of like looking through a insect eye lens
15:50:14 <darpan> EvanR: yeah I guess you're right. I have some books I'm trying to get around to on category theory but I learn through interacting with things so I figured I'd try to see if I can include Haskell :P 
15:51:04 <hololeap> `processCard c = get >>= process :: Card -> CardM String` ... it's obvious what `process` returns just from this line
15:53:27 <EvanR> darpan: i did some category theory with agda
15:53:41 <c_wraith> hololeap, oh! you're actually running into let-generalization. 
15:54:04 <darpan> EvanR oooh that's interesting, I didnt know something like this existed
15:54:25 <c_wraith> hololeap, bindings made in a let expression or where clause are made polymorphic, regardless of the context in which they are used. 
15:54:55 <c_wraith> hololeap, that's part of the hindley-milner type inference algorithm. 
15:56:00 <c_wraith> > let f x = x in (f 1, f ()) -- hololeap
15:56:02 <lambdabot>  (1,())
15:56:31 <c_wraith> hololeap, without let-generalization, that wouldn't type check 
15:57:54 <c_wraith> hololeap, that's why knowing the type of processCard doesn't monomorphize the type of process
15:58:34 <sphinxo> Why might this be occuring? Module ‘Data.Sequence’ does not export ‘lookup’
15:58:49 <sphinxo> - containers >=0.5 && <0.6
15:59:14 <barrucadu> sphinxo: Data.Sequence.lookup was introduced in 0.5.8, see the comment: https://hackage.haskell.org/package/containers-0.5.10.2/docs/Data-Sequence.html#v:lookup
15:59:21 <barrucadu> Is your version older than that?
15:59:30 <sphinxo> ahh, I would guess so, thanks
16:01:08 <hololeap> c_wraith: ok, i can see that. is `where` a sugared version of `let`?
16:02:12 <sphinxo> containers-0.5.7.1 must match ==0.5.8
16:02:36 <sphinxo> ( have updated my cabal file, on stack build )
16:04:00 <c_wraith> hololeap, yeah. scoping rules and syntax are a bit different, but they both map down to let expressions in ghc's core 
16:04:13 <sphinxo> Oh I need to update my stack resolver?
16:04:33 <hololeap> c_wraith: i understand a lot better now, thanks!
16:04:36 <Koterpillar> you don't need version constraints in cabal file if you're using stack
16:04:42 <Koterpillar> ^ sphinxo
16:05:18 <kadoban> Well, for development you don't. Eventually it's nice to put them in for cabal-install people
16:05:47 <sphinxo> looks like 5.7.1 is the latest for my resolver 7.20: https://www.stackage.org/lts-7.20/package/containers-0.5.7.1
16:06:07 <Koterpillar> you can override a version via extra-packages
16:06:31 <Koterpillar> sorry, extra-deps
16:07:18 <sphinxo> ahh that's what that is all about
16:07:47 <sphinxo> ( just understands this for the first time )
16:08:44 <Koterpillar> well, extra-deps can _add_ packages to a resolver
16:08:51 <Koterpillar> but they can also override versions for existing
16:10:22 <c_wraith> hololeap, if it makes you feel any better, it took me a while to understand exactly why it was blowing up, too. :) 
16:15:59 <DrMentats> hey, say I want to make something like: class Named t where name :: String
16:16:07 <DrMentats> I understand why it doesn't make sense
16:16:16 <DrMentats> but is there any way to attach information to types like that?
16:16:19 <Koterpillar> class Named t where name :: proxy t -> String
16:16:27 <DrMentats> ohh
16:16:31 <DrMentats> I need to check that
16:16:32 <DrMentats> thanks
16:16:47 <Tuplanolla> Note that `proxy` is a type variable too, DrMentats.
16:16:58 <Koterpillar> you can call this as, for example, name (proxy :: Proxy Int)
16:17:08 <Koterpillar> or name ([] :: [Int])
16:17:29 <DrMentats> I see. does this require any extensions?
16:17:36 <Koterpillar> or if you already have something of that type, name [1] (note that this is for Int, not [Int])
16:18:05 <Koterpillar> no, just checked
16:18:20 <DrMentats> very interesting
16:19:34 <Koterpillar> the data type Proxy is in Data.Proxy, I think: data Proxy a = Proxy; proxy = Proxy
16:19:55 <Koterpillar> but see above, 'proxy' is anything of kind (* -> *)
16:30:06 <c_wraith> DrMentats, if you're comfortable restricting yourself to ghc 8+, there is a more direct solution involving -XTypeApplications and -XAllowAmbiguousTypes
16:40:25 <et09> hey, if someone has 3 minutes and could spare some professional advice in PM, i'd appreciate
16:48:06 <Jinxit> got some typeclass issues: http://lpaste.net/9221708763524759552
16:48:13 <Jinxit> any idea what i'm doing wrong?
16:48:21 <joe9> can someone please help with this parsing: >  (t :: UTCTime) <- (parseTimeM False defaultTimeLocale "%Y%m%d %H:%M:%s%Q %Z" ) "20170411 23:37:06.662591551 UTC"
16:48:29 <joe9> 1970-01-01 00:00:06.662591551 UTC
16:48:34 <joe9> is what it is getting parsed as
16:48:55 <joe9> any suggestions on what I am missing, please?
16:50:04 <glguy> joe9: Don't use '%s'
16:50:30 <glguy> use %S
16:51:05 <joe9> glguy: That worked like a charm. Thanks.
16:51:53 <glguy> Jinxit: The 'i' in instance Walkable (Root i a) is unrelated to th 'i' in walk :: Walker i a -> t -> t
16:52:11 <Jinxit> how do i relate them?
16:53:27 <glguy> you can either rearrange your types so that it's: class Walkable t where walk :: Walker i a -> t i a -> t i a
16:53:47 <glguy> or project the 'i' out of t using a type family, or using a functional dependency
16:54:53 <Jinxit> i can't do the former since some of the implementations will only have a, not i a
16:55:05 <Jinxit> unless i misunderstood
17:06:48 <Jinxit> glguy: how would you do it with fundeps? they're still somewhat arcane to me
17:07:18 <glguy> class Walkable t i | t -> i where walk :: Walker i a -> t -> t
17:24:40 <robkennedy> Is there a version of `fold` for associative folds, which spawns multiple folds throughout the list? I might be describing a magic function
17:24:48 <joe9> utcToMillis :: UTCTime -> Integer ; utcToMillis = numerator . toRational . (* 1000) . utcTimeToPOSIXSeconds
17:25:03 <joe9> is my function. I am definitely doing something wrong as I keep getting different values here.
17:25:20 <glguy> You don't want to use numerator
17:25:24 <joe9> I think it is the pico seconds that are messing the calculation
17:25:41 <joe9> glguy: What do you recommend using, please?
17:26:03 <joe9> when I just give a number of milliseconds, it works fine.
17:26:16 <joe9> but, if the time has some pico seconds in there, it messes up.
17:26:19 <c_wraith> robkennedy, foldMap can do that, depending on the specific Foldable instance in use. it will use that approach for a tree, but not for a list. (lists are inherently linear) 
17:27:04 <joe9> I need UTCTime ->  milliseconds as Integer
17:28:38 <robkennedy> Ty c_wraith
17:29:32 <DrMentats> sorry, I was away for a bit
17:29:37 <DrMentats> so if I understand this right
17:29:45 <DrMentats> in name :: proxy t -> String
17:29:51 <DrMentats> proxy stands for a type constructor, basically?
17:30:21 <Koterpillar> yes
17:30:30 <Koterpillar> _any_ type constructor with one argument
17:30:31 <c_wraith> DrMentats, in fact, it stands for *any* type constructor 
17:30:40 <glguy> proxy is any type with the correct kind
17:30:44 <Koterpillar> :k Maybe
17:30:44 <glguy> it doesn't have to be a type constructor
17:30:46 <lambdabot> * -> *
17:30:52 <DrMentats> that's really nice actually
17:30:59 <Koterpillar> glguy: isn't anything of that kind a type constructor?
17:31:04 <glguy> no
17:31:27 <c_wraith> how can you possibly use a type family there? 
17:31:30 <glguy> Type constructors are the capitalized names introduces by data, newtype, type, etc at the type level
17:31:50 <glguy> proxy can be 'Either Int'
17:31:52 <c_wraith> Oh, you are counting partially applied type constructors 
17:32:06 <glguy> or it can be a type variable you have in scope
17:32:31 <c_wraith> it does have to be generative. ie, not a type family 
17:32:49 <glguy> type variables can't be instatiated with unsaturated type families
17:33:04 <glguy> so proxy won't be one of those
17:41:18 <glguy> it also can't be the type constructor Int (as another counter example)
17:42:02 <Koterpillar> OK, thanks for clarifying my definition of a type constructor
17:43:51 <joe9> glguy, would you recommend properFraction. this seems to work: +utcToMillis = fst . properFraction . (* 1000) . utcTimeToPOSIXSeconds
17:44:31 <glguy> joe9: how about just 'floor' ?
17:44:57 <joe9> if it works, sure. Thanks. glguy.
17:45:53 <joe9> glguy: it worked . Thanks.
17:50:53 <joe9> glguy: How do I convert an integer to the DiffTime? fromInteger does not seem to do the correct thing.  http://codepad.org/KXIbiFQU is what I am trying to do. I am writing a quickcheck instance to test the above code. I want to ensure that the time is in millisecond precision and not below.
17:53:50 <pacak> joe9: picosecondsToDiffTime and diffTimeToPicoseconds
17:55:50 <joe9> pacak:  Thanks.
17:59:12 <joe9> pacak:  you would need to convert UTC to DiffTime, correct? The DiffTime in the UTC is only for this day, correct?
18:00:13 <pacak> UTCTime - specific time stamp DiffTime - relative between two timestamps
18:00:28 <joe9> pacak: ok, Thanks.
18:00:45 <pacak> I think there's some epoch UTCTime you can use
18:04:33 <joe9> pacak, got it. figured it out, I think.
18:10:17 <halogenandtoast> Morning everyone
18:15:53 <nshepperd> glguy: 'type' doesn't define a type constructor does it?
18:18:15 <glguy> nshepperd: it does
18:19:14 <nshepperd> you're saying that a 'type constructor' is literally just any type with a capitalized name?
18:20:59 <ezyang> Man, we should really have overloaded case 
18:21:29 <glguy> nshepperd: there are type constructors and type variables
18:22:22 <bsima> is there a function IO [a] -> IO () that prints all the a's?
18:22:24 <glguy> type variables are the lower cased ones, type constructors are uppercased and with extension can be operator symbols
18:23:14 <Koterpillar> bsima: with a Show a constraint, traverse print
18:25:59 <halogenandtoast> If I have a list of lists [[1,2,3],[4,5,6],[7,8,9]] and a list of 2-tuples containing Ints [(1,1),(2,2)] can I use a lens (traversal?) to get a list of Maybe Ints corresponding to the positions [Just 5, Just 9] ?
18:26:53 <Welkin> what is the point of the Maybe?
18:27:42 <halogenandtoast> Welkin: that list of tuples could have invalid values
18:27:57 <halogenandtoast> [(10, 10)] should result in [Nothing]
18:28:00 <Welkin> just throw them out then
18:28:47 <nshepperd> halogenandtoast: I don't think you can make one traversal that does that. has the same problem as combining lenses - with [(1,1),(1,1)] you would break the laws
18:29:04 <halogenandtoast> Welkin: this sounds like a tangential problem unless doing so makes my initial problem easier somehow.
18:29:22 <nshepperd> halogenandtoast: but if you have a function that can turn a (Int,Int) into the right lens, you can just map that over your list of positions
18:29:49 <halogenandtoast> nshepperd: sure I could write that myLens (x, y) = ix x . ix y; I assume
18:30:10 <halogenandtoast> I'll try it out
18:30:31 <Welkin> a list seems like the wrong data structure
18:30:36 <Welkin> what are you trying to do with it?
18:30:39 <Welkin> Why not use a Map?
18:30:39 <nshepperd> \xxs positions -> map (\(i,j) -> xxs ^? (ix i . ix j)) positions
18:30:46 <nshepperd> somethn like that
18:30:52 <Welkin> you can use tuple keys
18:31:27 <halogenandtoast> Welkin: Given a list of neighboring positions, I want to count how many in my nested structure are flagged
18:31:40 <halogenandtoast> the positions and nested structure are independent.
18:32:11 <Welkin> even still, a list is not right if you want to reference them by index
18:32:14 <Welkin> use an array
18:32:29 <Welkin> or array of arrays
18:33:28 <halogenandtoast> Welkin: I haven't yet used Array in Haskell, I'll check it out.
18:33:38 <Welkin> there is Array and Vector
18:33:52 <Welkin> Array is more flexible for how you index it
18:33:59 <halogenandtoast> and Sequences it seems
18:34:02 <Welkin> you can use whatever you want, including tuples
18:34:08 <Welkin> Sequence is my favorite
18:34:17 <Welkin> List is almost never the right data structure
18:34:26 <Welkin> it's more of a control structure, like for creating a "loop"
18:35:01 <halogenandtoast> Welkin: Yeah I'm reading that, I think that's a powerful observation I hadn't yet made.
18:36:36 <halogenandtoast> thanks nshepperd and Welkin 
18:36:50 <halogenandtoast> Time to do a major refactoring
18:54:32 <bsima> thanks Koterpillar, mapM_ ended up working for me
18:54:49 <bsima> plus do-notation (which I've been trying to avoid, but oh well)
18:55:08 <Koterpillar> :t  traverse print
18:55:10 <lambdabot> (Show a, Traversable t) => t a -> IO (t ())
18:55:41 <Koterpillar> :t traverse_ print
18:55:42 <lambdabot> (Show a, Foldable t) => t a -> IO ()
18:56:17 <bsima> yeah, the error was "No instance of Traversable" or something like that
18:56:42 <Koterpillar> lists are
18:56:48 <Koterpillar> what did you end up with?
18:57:07 <bsima> I've got a list of records
18:57:37 <bsima> mapM_ print myList
18:57:54 <Koterpillar> :t mapM_
18:57:55 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
18:57:59 <Koterpillar> :t traverse_
18:58:00 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
18:58:12 <bsima> ah, so they are basically the same
19:20:26 <lpaste> DrMentats pasted “GADTs Are Fun” at http://lpaste.net/354525
19:20:28 <joe9> http://dpaste.com/3CYNA05 is my code . I figure there is a way to used Data.Fixed.Pico instead of Integer when converting to and from UTCTime to picoseconds. any suggestions on how , please?
19:21:10 <Koterpillar> DrMentats: do you want Typeable and/or Generic?
19:22:57 <thang1> summmer of haskell 2017 looks awesome
19:22:58 <DrMentats> well, what I wanted originally was a way to pass types around as values but while still being able to use them as instances
19:23:31 <thang1> DrMentats: why? (jumped into the middle of that and I have no context)
19:24:34 <DrMentats> I hadn't described the problem yet actually, but what I'm making is an interpreter for a dynamic language, and there is a data type that represents arbitrary haskell values wrapped in Dynamic
19:25:07 <DrMentats> but I also wanted to pass some information around, such as type names, so I could say things like "got an int where a string was expected"
19:26:22 <thang1> Have you looked at how GHC's error reporting tells you what type it wanted and what type it got?
19:27:46 <DrMentats> well, the GADT approach seems to work great, and is also extensible, which is perfect for my needs
19:31:07 <thang1> Ooh, also
19:31:43 <WarmCookie> Hi guys, can I create a sum type that also uses existantial quantification?
19:32:29 <thang1> have you seen this paper, DrMentats? https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf
19:32:58 <Zemyla> WarmCookie: You may need to use GADts for htat.
19:33:30 <DrMentats> I definitely will read it
19:34:25 <WarmCookie> Also, is this legal or can I make it legal easily?
19:34:26 <WarmCookie> data Ui = exists c. Ui  { uiUpdate :: Event -> Game c Result, uiRender :: Renderer c () }
19:36:33 <thang1> (The paper paper goes over a syntax tree that can be extended to add new constructors and new fields to existing constructors fairly easily)
19:39:29 <thang1> Dumb question, why do you name it Ui instead of UI, WarmCookie?
19:39:40 <DrMentats> it may be a little too academic for a humble hacker like me, but I'll see if I can make sense of it
19:40:52 <thang1> The actual idea behind it is actually relatively simple. They talk about things as fully general as possible (of course), but starting with section 3 is the explanation for what their solution is. The paper itself also is a literate haskell file so you can run all of the code in it and try it out
19:41:52 <DrMentats> oh I think I see it now
19:42:21 <DrMentats> so the general gist is that you can extend the tree without having to change its internals?
19:42:30 <DrMentats> because if that's it then I really am interested
19:42:38 <thang1> Much of the paper is actually revolving around taking the very simple idea and hiding much of the implementation so that it doesn't feel any more cumbersome. Yeah that's the idea behind it
19:43:40 <WarmCookie> Zemyla: Worth checking, thanks.
19:45:04 <thang1> Midele of page 5 is how they write the extensible version of the data type. It's relatively simple to see the changes they made, which is why I like it so much
19:45:56 <DrMentats> so you fancy this kind of thing too? compilers and the such?
19:45:57 <thang1> top of page 6 shows the "undecorated" version of the tree. Most of the rest of the paper details ways to hide away the added complexity and added typing that the extensible solution requires
19:46:12 <DrMentats> it's been a favorite subject of mine in programming for the longest time
19:46:43 <thang1> I love Haskell in general. Functional languages, etc. Not so much compilers, but they're also super neat. I'm more into data structures, algorithms, how things are written and how to write programs that generate programs as well.
19:47:06 <thang1> I have a feeling I'd really like writing compilers and languages since I come up with toy ideas all the time; I've never gotten around to it yet, though. I'm still only on chapter 11 of the haskel from first principles book
19:48:43 <DrMentats> I usually just caught glimpses of this kind of thing, before coming to haskell
19:49:02 <DrMentats> now it seems to me that this is all it's about
19:49:15 <thang1> lol funny how that works
19:50:12 <thang1> before haskell I was fine writing imperative code. Now that I've taken a well designed C++/OOP intro-ish course series at my University and used Java/C++ for "semi real" stuff and am finally getting into how to actually think in Haskell... I'm really enjoying it all
19:50:42 <thang1> It's pretty neat to actually understand most of what's on the subreddit now. Before it was "oh cool, *save link*, I'm sure I'll understand that in a year or three"
19:51:17 <thang1> Now, what's your dynamic language like?
19:51:21 <thang1> I'm curious :)
19:51:58 <DrMentats> I hate to admit it, but I used to be scared of monads. When I heard about Haskell, I just though "well, you can't have side effects in it? what's it good for then?"
19:52:08 <DrMentats> little did I know
19:52:52 <thang1> hah that actually was just relevant today outside of programming
19:53:07 <thang1> in my quantum computing class at uni, we were going over quantum gates and measurement
19:53:53 <thang1> In quantum computing, you have to delay measurement until the very end of the computation, so the question was "is it still as powerful as classical computing?" and my immediate response was "of course. Function transformations are a valid way to program in pure languages with referential transparency"
19:54:09 <thang1> took a few of the imperative people a bit to catch on though
19:54:29 <DrMentats> heh I can imagine that
19:54:39 <DrMentats> speaking of how great Haskell is
19:54:42 <DrMentats> http://lpaste.net/354526
19:54:50 <DrMentats> I still can barely believe that this works AND is type safe
19:55:43 <DrMentats> if I had used a traditional data type for TypeInfo, I couldn't guarantee that Magic contains the type it describes
19:56:38 <thang1> I swear, type systems are magic in haskell sometimes
19:56:45 <lordcirth> DrMentats, it looks interesting but I don't really understand it
19:56:51 <lordcirth> I'm a beginner
19:56:53 <thang1> I just type a bunch of shit out. Hit save and think "this probably won't work; it's literally the first thing that came to mind..." and it typechecks
19:57:05 <thang1> then I'm like "huh... neat... did that work?" (and it does). Great feeling
19:57:13 <DrMentats> lol exactly
19:57:18 <lordcirth> DrMentats, you have a typeclass that lets you print the name of the type, is that it?
19:57:52 <DrMentats> yes, any type can be an instance of TypeInfo if it can be named
19:57:53 <thang1> Yeah, he's writing a dynamic language and wants error messages that are useful
19:58:22 <Welkin> just add static types
19:58:23 <DrMentats> this uses GADTs, which is an extension of haskell, so you're not likely to see it every day
19:58:30 <Welkin> like javascript's flow
19:58:54 <DrMentats> I might, eventually
19:59:37 <DrMentats> but the language is more aimed at quick scripting, so I don't want to make it too strict
19:59:45 <thang1> You mean, too useful? :p
19:59:51 <DrMentats> lol
20:00:05 <DrMentats> I'm a big ruby fan, I'll have you know
20:00:27 <DrMentats> anyway, you asked about the language before
20:00:34 <thang1> I'm a lisp fan :D
20:00:39 <thang1> dem macros <3
20:00:48 <DrMentats> I'll put it on my github once I refactor it a bit, code is really ugly right now
20:00:56 <DrMentats> oh I love lisp too
20:01:15 <thang1> nice!
20:01:30 <DrMentats> I'd like to support macros, I just don't know how to implement them lol
20:01:42 <thang1> I need to learn Lisp... One thing at a time, though. I'm taking 4 classes (full time) and don't want to kill myself
20:02:05 <thang1> DrMentats: If your language is homiconic, it's much easier
20:02:32 <DrMentats> that's true, but it's just
20:02:42 <DrMentats> have you seen any homoiconic languages beside lisp?
20:02:46 <thang1> Then it's a simple matter of text expansion, is it not?
20:02:50 <DrMentats> there might not exist others at all lol
20:03:16 <Sornaensis> prolog
20:03:32 <thang1> http://wiki.c2.com/?HomoiconicLanguages
20:03:47 <DrMentats> prolog huh? I had no idea
20:03:54 <Sornaensis> prolog programs are prolog terms
20:04:14 <thang1> which makes sense considering that predicate calculus itself is built inductively
20:04:17 <Sornaensis> it's a neat concept
20:05:07 <DrMentats> either way, afaik, lisp macros go much beyond simpe text substitution
20:05:22 <DrMentats> there's the whole evaluation phase thing
20:05:22 <thang1> https://en.wikipedia.org/wiki/Rebol Rebol is a multi paradigm homoiconic language as well
20:06:50 <DrMentats> I'm deeply inspired by Rebol, too bad it's very slow to parse, since semantics change based on function arity and you can only detect this at runtime (for a dynamic language)
20:07:54 <thang1> http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html and more than you ever wanted to know about lisp macros is here 
20:09:16 <DrMentats> I think it depends a lot on whether we're talking about common lisp or scheme though
20:10:22 <DrMentats> Racket's (a scheme) macros are lexically scoped, for example
20:10:58 <thang1> Really? That's neat
20:11:19 <DrMentats> yeah, they really focus on macro hygiene there
20:11:27 <thang1> Now I'm curious as to whether or not Clojure macros can be typechecked...
20:12:25 <DrMentats> I wonder if Rebol could be typechecked to make it possible to parse it ahead of time
20:12:53 <DrMentats> which understandably would make it less flexible though
20:13:21 <DrMentats> speaking of languages that are parsed during run time, I believe Tcl is the ultimate one
20:13:49 <thang1> Is that the language that has zero difference between runtime, compile time, and evaluation?
20:13:59 <DrMentats> everything is a string lol
20:14:02 <thang1> (even lisp has a tiny difference)
20:14:10 <thang1> lol that would do it
20:14:51 <DrMentats> you need to use a function to do arithmetics, which is basically a fully fledged parser
20:15:09 <DrMentats> you don't even know if you got the syntax right until the program is already running
20:17:21 <DrMentats> anyway, sorry for going off-topic. lordcirth, if you have any more questions about my code, I would be happy to explain, even though I'm a bit of a beginner myself.
20:19:10 <parolang> Wow funny you guys are talking about Prolog while I was reading about it
20:19:34 <thang1> what were you reading?
20:21:26 <joe9> what is the function to do Integer -> Data.Fixed.Pico?
20:22:05 <Sornaensis> @hoogle Integer -> Data.Fixed.Pico
20:22:05 <lambdabot> No results found
20:22:08 <Sornaensis> :(
20:22:20 <thang1> ? are you trying to use an integer in a function that uses *.Pico?
20:23:17 <thang1> FromInteger is probably what you want, in that case?
20:23:36 <Sornaensis> :t fromInteger
20:23:37 <lambdabot> Num a => Integer -> a
20:23:48 <joe9> http://codepad.org/2YAnRnJj I am doing this. but want only second precision
20:24:05 <joe9> I can use arbitrarySizedIntegral but cannot figure out how to go from Integer to pico
20:24:27 <geekosaur> it has a Num instance, so fromInteger
20:24:59 <thang1> Well, as a side note, why do you care about less precision vs more precision? There are no performance concerns Haskell the same way there are in C-style languages
20:25:20 <thang1> But yeah, fromInteger can be thought of as a "cast" into any type that derives from Num
20:26:36 <joe9> thang1: I am parsing it out to a file and reading back in and the data is in second format. If I go for more precision the tests are failing.
20:28:35 <parolang> thang1: http://stackoverflow.com/questions/8297574/difference-between-logic-programming-and-functional-programming
20:29:08 <joe9> newtype NominalDiffTime = MkNominalDiffTime Pico deriving (Eq,Ord is not exposed in Data.Time.Clock.Internal. How do you build up the NominalDiffTime?
20:29:19 <joe9> I have a pico value but the constructor is not exposed.
20:29:40 <DrMentats> if the tests pass with less precision but fail with more, then I might suggest that you change the tests instead of the data itself
20:30:17 <joe9> DrMentats: That is what I am doing . trying to get a better or more suitable Arbitrary instance
20:30:43 <DrMentats> ah, I see, forgive my misunderstanding
20:33:06 <joe9> geekosaur: would you mind helping, please? I want to build a NominalDiffTime but the constructor does not seem to be exposed. http://codepad.org/aAPWCVTL
20:34:00 <joe9> Is there a better time package? this seems bad.
20:37:18 <geekosaur> I see NominalDiffTime having Enum and Num instances. I also see in the documentation "Conversion functions will treat it as seconds."
20:38:25 <joe9> when there is a Num instance, does that mean I can just do x = (100 :: Uni) where x :: POSIXTime?
20:38:40 <joe9> geekosaur: POSIXTime is a type synonym for NominalDiffTime
20:39:08 <joe9> I cannot figure out how to do x :: NominalDiffTime when I have the value that belongs in that newtype.
20:39:15 <joe9> geekosaur: Does that make sense?
20:39:35 <geekosaur> Num instance means fromInteger will work. Enum instance means toEnum will work
20:39:35 <joe9>  http://codepad.org/NIkJBXMV
20:39:55 <joe9> geekosaur:     it is a hidden module in the package ‘time-1.6.0.1@time-1.6.0.1’
20:40:09 <DrMentats> maybe you can generate two UTCTimes instead and then get the difference between them?
20:40:11 <joe9> when I try to load Data.Time.Clock.UTC
20:40:16 <thang1> parolang: thanks! Looks interesting
20:40:25 <thang1> Have you read up on anything about the programming language Curry?
20:40:57 <geekosaur> that means you are yusing cabal repl or stack ghci and did not declare the time package as a dependency
20:41:14 <geekosaur> ...or maybe you did so but with an older version that lacks those, but I doubt that
20:41:47 <joe9> geekosaur:  :m +Data.Time.Clock works fine.
20:42:10 <joe9> geekosaur: I will follow your advice and use UTCTime's instead.
20:42:18 <geekosaur> in any case I am looking at Data.Time.Clock not Data.Time.Clock.UTC
20:42:42 <geekosaur> in fact I see no such public module in time-1.6.0.1. what led you to try to use it?
20:42:52 <joe9> but, the constructor of NominalDiffTime is defined in the UTC file and it does not seem to be exported.
20:43:15 <geekosaur> maybe there's a reason for that
20:43:21 <joe9> makes sense.
20:43:26 <joe9> Thanks.
20:43:31 <geekosaur> do you normally source dive to look for constructors to use instead of sticking to the documented public interface?
20:44:11 <geekosaur> I mean, I'm just looking at the haddock for Data.Time.Clock. I'm not sure why you need help with that.
20:44:47 <joe9> geekosaur: I was going by what the info of ghci suggested.
20:45:33 <geekosaur> you need to be careful with that, yes, it will happily lead you to internals you probably shouldn't poke at directly. Doublecheck against the haddock.
20:45:35 <thang1> GHCI is fameously simultaneously incredibly useful and incredibly useless
20:45:51 <parolang> thang1: I've been reading about it too. Interesting.
20:46:25 <thang1> My professor fall quarter  for discrete structures  is one of the main guys who's been working on Curry
20:46:28 <geekosaur> ghci has only limited ways to control what it shows you; normally it drills as deep as it can. but it has no way to know whether a module is part of the exposed interface or not
20:46:38 <thang1> I'm hoping to pick his brain about it because that language fascinates the fuck out of me
20:47:09 <parolang> yep
20:48:52 <parolang> Maybe they key is to think in terms of relations rather than (mathematical) functions.
20:49:32 <parolang> Thats why logic programming seems so weird.
20:52:54 <parolang> A function is only half of a relation :)
20:53:08 <thang1> For logical languages you think in terms of logical predicates
20:53:39 <parolang> Predicate = Relation roughly
20:58:00 <DrMentats> well, I'm getting sleepy. it was nice talking to you all. see you guys tomorrow!
20:58:04 <thang1> see ya
20:58:08 <parolang> night
20:58:26 <thang1> ironically I found the lowest answer on the stack overflow page to be the most enlightening
21:10:58 <joe9> is the quickcheck arbitrary strict?     arbitrary = ModifiedJulianDay <$> (elements [40587 .. ]) hangs  the system
21:16:54 <iqubic> Is there a suitable data type for x y co-ordinate points?
21:18:35 <MarcelineVQ> joe9: the way elements is written needs to know the size of the list in order to pick one randomly
21:18:35 <joe9> Data.V2?
21:18:49 <MarcelineVQ> and length on an infinite list is a bad time
21:19:18 <joe9> oh, ok. Thanks. any recommendations on how I can tell Quickcheck to take any number greater than a particular number?
21:19:40 <joe9> I can hardcode the max value, but, it would be ideal to let quick check pick what it likes.
21:20:16 <iqubic> joe9: Where can I find a link to Data.V2?
21:20:23 <MarcelineVQ> I'm sorry I don't really understand the question, what does it mean for quickcheck to take a number?
21:20:50 <joe9> MarcelineVQ: do not worry. I think I figured it out. Sorry for the bother.
21:21:03 <MarcelineVQ> np
21:21:10 <joe9> i think diagrams uses points quite a bit
21:22:31 <MarcelineVQ> did you mean Linear.V2? if so then  https://hackage.haskell.org/package/linear-1.20.5/docs/Linear-V2.html
21:23:48 <joe9> MarcelineVQ: I notice something similar with this too:  instance Arbitrary Text where arbitrary = suchThat arbitrary (T.all ((/=) '\0'))
21:24:03 <joe9> I want to generate text elements that do not have null in them. q
21:24:13 <joe9> quick check hangs when I use that arbitrary instance.
21:24:21 <joe9> Yes, Linear.V2
21:26:49 <iqubic> Is Linear.V2 the best library for dealing with 2-d points?
21:31:07 <MarcelineVQ> joe9: hmm well consider which arbitrary you're passing to suchThat
21:33:18 <joe9> oh, yeah. good point. MarcelineVQ
21:33:56 <_sras_> I want to the hash of the currently checkout commit to a file, before a stack build. Is there any way to include this step in the `stack build` command  itself so that it won't be missed?
21:34:35 <_sras_> srry. I mean, I want to write the hash of the currently checked out commit to a file...
21:35:34 <MarcelineVQ> Yes, but it's likely easier to write a shell script or makefile or something and use that to build with
21:36:28 <MarcelineVQ> Depends on where your strengths are is what I mean by that. You can customize Setup.hs to do pretty much anything
21:37:39 <joe9> MarcelineVQ: any suggestions on how to go about building an arbitrary without null values for Text, please? most of the quickcheck functions such as bounded, etc. are for integers.
21:37:46 <joe9> s/integers/numbers/
21:38:36 <MarcelineVQ> I probably wouldn't, I'd use a full normal arbitrary for Text and modify that when I need a specific kind of Gen
21:39:19 <iqubic> Is Linear.V2 the best library for dealing with 2-d points?
21:41:49 <MarcelineVQ> joe9: iow I wouldn't try to customize the instance, at least not without a newtype wrapper. I'd use a normal one like you'd find in https://hackage.haskell.org/package/quickcheck-instances and then use something like suchThat on it where it to be more specific
21:43:28 <MarcelineVQ> iqubic: no idea, if people don't answer you btw it's usually that people don't know or people that do know aren't around
21:49:50 <joe9> MarcelineVQ: Thanks. good idea.
21:49:57 <iqubic> I'll look aroujnd.
21:50:19 <joe9> iqubic: I think it was when I was checking out Diagrams. and Diagrams uses it extensively (I think)
21:50:30 <MarcelineVQ> iqubic: possibly a good lead is to look at programs likely to deal with 2d things and see what they dso
21:50:30 <halogenandtoast> So this reddit post intrigues me a little: https://www.reddit.com/r/haskell/comments/64ui11/reasons_i_dislike_type_synonyms/
21:50:52 <halogenandtoast> I was using a couple of type synonyms and I wonder if they fall into the same pitfalls (if those are actually pitfalls)
21:51:11 <halogenandtoast> I had the following type Dimensions = (Int, Int) and type Position = (Int, Int)
21:51:19 <halogenandtoast> should these be ADTs instead?
21:51:35 <halogenandtoast> err newtype Dimensions = Dimensions Int Int for example
21:51:48 <MarcelineVQ> often​ I start with 'type' like that and move them to data or newtype as the program forms
21:52:42 <MarcelineVQ> Mostly to be more descriptive when things are still forming,  foo :: Width -> Height -> Waffle  is nicer than Int -> Int -> (Int,Int)
21:52:58 <MarcelineVQ> for someone's opinion of nicer :>
21:54:06 <halogenandtoast> MarcelineVQ: yeah I was trying to get to the point where you could understand functions from the type signature fairly easily
21:59:18 <cocreature> MarcelineVQ: personally I mostly stopped using type synonyms and use newtypes/adts instead
21:59:41 <cocreature> having the compiler yell at me when I mix things up is really helpful :)
22:00:29 <cocreature> halogenandtoast: also you probably also want the fields of Dimensions and Position to be strict in most cases so that’s another reason to go for ADTs instead of type synonyms
22:01:15 <halogenandtoast> cocreature: what do you mean by strict?
22:01:31 <cocreature> halogenandtoast: data Position = Position !Int !Int
22:02:25 <halogenandtoast> What does that do?
22:03:39 <halogenandtoast> is it just more efficient in regards to the heap?
22:04:24 <iqubic> What's ADT?
22:04:50 <halogenandtoast> iqubic: I'm 99% certain I used it incorrectly there but I meant Algebraic Data Type
22:05:31 <cocreature> halogenandtoast: when you apply a data constructor each argument with a strictness annotation, i.e. !, is evaluated to whnf.
22:05:39 <cocreature> algebraic data type is correct
22:06:17 <iqubic> What's Weak Head Normal Form???
22:06:45 <halogenandtoast> iqubic: I sort of have the same question, but mine is, what benefit does having something evaluate to whnf have?
22:06:46 <cocreature> iqubic: https://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
22:07:00 <cocreature> halogenandtoast: it avoids space leaks
22:07:40 <cocreature> halogenandtoast: let’s say we have a function "(Int, Int) -> (Int, Int) -> (Int, Int)" that does elementwise addition
22:08:16 <halogenandtoast> so f (1, 2) (3, 4) = (4, 6)
22:08:18 <cocreature> now you are given a list [(Int, Int)] and since you know about space leaks you think it might be a good idea to use foldl' here
22:08:37 <halogenandtoast> "and since you know about space leaks" big assumption there :p
22:08:56 <halogenandtoast> but let's roll with it.
22:08:57 <cocreature> halogenandtoast: oh sorry, let me go back
22:09:20 <cocreature> halogenandtoast: so do you know why implementing "sum = foldl (+) 0" can cause problems?
22:09:41 <cocreature> specifically why it doesn’t run in constant memory
22:10:38 <halogenandtoast> because it can't reduce?
22:10:47 <halogenandtoast> or the reduction happens rightmost
22:10:51 <halogenandtoast> not that it can't
22:11:25 <halogenandtoast> 0 + (1 + (2 + 3))) vs (((0 + 1) + 2) + 3)
22:11:35 <cocreature> so if we run "foldl' (+) 0 [1,2,3]" we end up with a thunk representing (((0+1)+2)+3)
22:11:56 <halogenandtoast> @define thunk
22:11:56 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
22:12:03 <cocreature> but that’s not what we want! we want to force the evaluation of the accumulator at each step
22:12:22 <cocreature> a thunk is a value that still needs to be evaluated
22:12:31 <halogenandtoast> 理解
22:13:01 <cocreature> so what we are looking for is first add 0+1, force the evaluation so we get 1, then add 2, force the evaluation so we get 3, …
22:13:19 <halogenandtoast> okay
22:13:31 <cocreature> that’s what foldl' gives us
22:13:53 <moet> how does STM interact with IO?
22:14:19 <moet> i don't think IO actions can be undone in a transaction which fails...
22:14:36 <moet> you generally don't want IO actions to be retried if a transaction is retried...
22:15:01 <cocreature> moet: that’s why you can’t embed IO actions in STM :)
22:16:32 <moet> cocreature: what.. hrm.. i haven't finished rewriting a file to use STM, but i'm pretty sure the part that does liftIO in STM is typechecking
22:17:06 <cocreature> moet: STM is not an instance of MonadIO so you can’t use liftIO
22:17:49 <iqubic> Alright what does seq do?
22:19:06 <moet> cocreature: hmm.. maybe there's a later typechecker pass which will find that.. thanks for clarifying!
22:19:33 <monochrom> There is only unsafeIOToSTM if you want to risk it, but it is still not made liftIO.
22:21:28 <monochrom> The official bridge between STM and IO are only atomically and newTVarIO. And they are a one-way street.
22:22:04 <iqubic> So, what does seq do? Is it useful?
22:22:43 <opqdonut> iqubic: it allows you to influence evaluation order and strictness
22:23:13 <opqdonut> iqubic: it's very useful, but it's a bit of a hack
22:24:04 <opqdonut> often instead of explicit seq one uses BangPatterns or strict data
22:24:23 <iqubic> So, how does one use seq?
22:24:54 <pacak> :t seq
22:24:55 <lambdabot> a -> b -> b
22:25:10 <iqubic> That's not too helpful.
22:25:20 <opqdonut> well as a toy example "strictAnd x y = y `seq` (x && y)"
22:25:34 <pacak> You pass whatever you want to evaluate as a and whatever you want to return - as b
22:25:34 <cocreature> "seq a b" evaluates to "b" but before returning it will also evaluate "a"
22:25:52 <iqubic> What the heck???
22:25:57 <opqdonut> now "strictAnd False undefined" is an error, unlike "False && undefined" which is False
22:26:09 <pacak> :t const
22:26:10 <lambdabot> a -> b -> a
22:26:16 <pacak> > const () undefined
22:26:17 <halogenandtoast> cocreature: so I'm not sure how what you said related to doing Dimensions !Int !int
22:26:18 <lambdabot>  ()
22:26:22 <pacak> > seq undefined ()
22:26:24 <lambdabot>  *Exception: Prelude.undefined
22:26:30 <pacak> Something like that
22:26:38 <opqdonut> for a real use of seq, consider:
22:26:39 <opqdonut> @src foldl'
22:26:40 <lambdabot> foldl' f a []     = a
22:26:40 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:26:46 <opqdonut> the strict foldl
22:26:56 <halogenandtoast> I'd assume with my limited knowledge that an Int would already be in normal form
22:27:06 <glguy> (1 + 2) :: Int
22:27:10 <cocreature> halogenandtoast: that ensures that you can’t build up thunks inside of the fields of Dimensions: whenever you apply the Dimensions constructors, the arguments will be evaluated first
22:27:13 <pacak> halogenandtoast: Nope.
22:27:19 <pacak> > const (1 + undefined) ()
22:27:21 <lambdabot>  *Exception: Prelude.undefined
22:27:29 <pacak> > const () (1 + undefined) 
22:27:31 <lambdabot>  ()
22:27:33 <cocreature> pacak: that’s Integer :)
22:27:57 <pacak> > const () ((1 :: Int) + undefined) 
22:27:59 <lambdabot>  ()
22:28:12 <pacak> >  seq ((1 :: Int) + undefined)  ()
22:28:13 <cocreature> halogenandtoast: for Int whnf and nf is the same but an Int can still be unevaluated
22:28:14 <lambdabot>  *Exception: Prelude.undefined
22:28:24 <halogenandtoast> cocreature: I see
22:28:28 <moet> ah, there it is
22:28:39 <halogenandtoast> I now understand the effect, but not the side-effects.
22:28:47 <moet> i guess i was still in the 'in scope' pass.. it wasn't checking typeclass contexts
22:28:53 <moet> thanks cocreature 
22:28:53 <halogenandtoast> Would I want to make all types like that strict?
22:29:27 <cocreature> halogenandtoast: definitely not. e.g. if [] was defined like that you couldn’t have infinite lists
22:29:52 <cocreature> usually it makes sense to make “small” fields strict. so things like Bool, Int, …
22:30:04 <cocreature> but be lazy especially when it comes to recursive data types
22:30:39 <iqubic> Yeah. You don't want a strict list.
22:40:40 <monochrom> I wouldn't call seq a hack where BangPatterns and StrictData aren't. They are equivalent. So either all of them are hacks or none of them are.
22:42:19 <halogenandtoast> cocreature: thanks for the explanation.
22:42:45 <halogenandtoast> It's seems like a neat part of Haskell I haven't tinkered with yet.
22:45:34 <opqdonut> monochrom: agreed, they're equivalent. maybe hack was the wrong word... necessary evil? practical but impure?
22:50:05 <monochrom> They can be hacks. John Hughes invented seq to reduce laziness so when you think that laziness uses more memory than necessary you can kill it. And it has the non-ideal consequence of bursting the denotational dream of bottom = \_ -> bottom
22:50:27 <opqdonut> indeed
22:55:25 <thang1> A nice way to think of whether or not to be strict vs lazy is "lazy in the spine, strict in the leaves"
22:55:48 <thang1> or, to expand on those definitions slightly, the organization and evaluation of the STRUCTURE of the data type should be lazy as possible
22:56:17 <thang1> However, the organization and evaluation of the CONTENT of the data type should be strict as possible
22:56:36 <thang1> When you do 1 + 1 you don't want to wait, you want a 2 the second you type 1 + 1
22:57:14 <thang1> But when you define a list [1..] you don't actually care about the list yet, you're just saying "this data structure has a structure of a list that counts from 1 up to infinity" and that's all you care about
22:58:04 <monochrom> Unless and until one person's content is another person's structure. For example Map Int (Map Tree (InfiniteList Bool))
22:59:23 <thang1> Which is why it's a rule of thumb and not a biblical rule ;)
22:59:46 <thang1> But still, why would you do that anyway...?
23:00:08 <ongy> monochrom: is that actually a problem? afaik that would only evaluate the outer constructor? So probably the root node
23:00:43 <monochrom> Sure, I wouldn't go that far. But Map Int (InfiniteList Double) is already pretty plausible and proves the point.
23:00:59 <ongy> oh I parsed that one wrong, but same thing, afaik that's Cons 1 <thunk>
23:01:09 <thang1> Fair :)
23:01:16 <monochrom> In other words Map Int [Double] could be when you want Data.Map.Lazy again.
23:01:38 <thang1> Isn't map strict, though? Iirc, it forces evaluation
23:01:56 <monochrom> It forces its spine and the keys.
23:02:13 <ongy> and there's Data.Map.Strict
23:02:17 <thang1> Right, so in your above example you'd try to apply int to an infinite list of doubles and everything would break
23:02:21 <monochrom> (More accurately, it forces the keys as much as to perform Ord operations.)
23:02:35 <thang1> (if I got that right)
23:04:33 <monochrom> ongy: Yes, due to the definition of [], if you use Data.Map.Strict on Map Int [Double], it is not all that strict anyway. But imagine one day tibbe gets drunk and inflict Data.Map.DeepSeq on us.
23:08:54 <thang1> Hmm...
23:09:08 <monochrom> Debate topic: Should it be Control.DeepSeq or should it be Data.DeepSeq? :)
23:09:39 <mniip> Seq.Deep
23:09:44 <Koterpillar> monochrom: careful, with some thinking you can put everything in Data.
23:09:55 <mniip> Koterpillar, -> ?
23:10:03 <glguy> Data.Control.Monad?
23:10:10 <monochrom> Naw, no one would propose "Data.IO".
23:10:25 <Koterpillar> glguy: Data.Monad, using Free or something :P
23:10:27 <monochrom> Not to mention possible trademark infringement to Data I/O, a company.
23:10:29 <glguy> what about Data.IO?
23:10:30 <kadoban> Heh, the whole Data/Control split is kind of obsolete and weird anyway, isn't it?
23:10:50 <thang1> Data.Control.Monad.IO
23:11:09 <glguy> we already have Data.Data
23:11:24 <glguy> what could we put in Control.Control?
23:11:44 <monochrom> I don't know yet, but good idea for next April 1st. :)
23:11:49 <thang1> higher dimensional control abstractions!
23:12:07 <thang1> I'm thinking Logic related stuff
23:12:38 <monochrom> How about Control.Control contains generic derivation tools for deriving Functor, Applicative, Monad, DeepSeq, and Arrow?
23:12:48 <thang1> "is your life out of control? Use the Control library! Are your Controllers out of Control? Control them with Control.Control!"
23:13:06 <glguy> Pest.Control
23:13:36 <glguy> helps with bug elimination
23:13:44 <thang1> pffh this isn't OOP
23:13:49 <thang1> it's Control.Pest
23:13:58 <monochrom> haha
23:14:19 <Koterpillar> Control.Self?
23:14:42 <thang1> (error: module imports Control.Netflix which imports Control.Self)
23:15:11 <thang1> (fucked the wording up slightly but hopefully the gist is gotten)
23:18:04 <thang1> "If you think C++ is not overly complicated, just what is a protected abstract virtual base pure virtual private destructor, and when was the last time you needed one?"  -- Tom Cargil
23:20:29 <monochrom> GHC unifies data and control under closure. So maybe we should just create and use the Closure prefix. Closure.List, Closure.Monad
23:21:06 <jle`> Data.IO makes sense, cause IO is data
23:21:15 <mauke> "pure virtual" and "abstract" mean the same thing. "protected" and "private" contradict each other. "virtual" is listed twice.
23:26:11 <thang1> mauke: http://stackoverflow.com/questions/3618760/c-protected-abstract-virtual-base-pure-virtual-private-destructor
23:27:13 <mauke> oh, the first part qualifies "base"
23:27:19 <mauke> ok then
23:27:56 <thang1> I mean, it's written in a purposely obtuse way and the actual code is basically useless, but it's /possible/
23:28:41 <mauke> but also useless
23:29:50 <mauke> you might as well ask "what is a constant volatile register variable-length array?" in C
23:30:48 <thang1> hah, true. Sure, you can do it, but why the fuck do you even want to
23:31:02 <thang1> This is my favorite example of practical-yet-fucked-up C++: http://duramecho.com/ComputerInformation/WhyHowCppConst.html
23:31:27 <mauke> there are non-obvious uses for 'const volatile' but the real joke is the 'register' array
23:32:15 <mauke> 'register' prevents taking the address of a variable so with "register int a[5];" you can't access the elements
23:32:32 <thang1> ahh got it.
23:32:55 <thang1> Knew there was a reason I've never heard about the register keyword
23:33:42 <thang1> (I love how, in C++, you can declare something const int*const Method3(const int*const&)const and then inside the method write mutable and /still/ change it)
23:35:09 <thang1> or by using const_cast willy nilly
23:35:25 <mauke> "... but requires the every use of the variable in the called routine altered like that and the calling routine also altered to pass a pointer to the variable. It is rather cumbersome." <- it's also explicit at the call site. you know that f(&x) may change x but f(x) won't
23:35:41 <mauke> some people consider that an advantage
23:36:14 <ongy> mauke: what if it's void f(int &x), then callsite will have a harder time to see it :) (but I think C++ isn't terribly on topic)
23:36:48 <mauke> thang1: mutable is just a shortcut. you can get the same effect by using a pointer
23:38:43 <quchen> q
23:39:00 <thang1> True. I forget that raw pointers bypass so many things
23:39:15 <monochrom> My heart has a soft spot for f(int &x) because my heart has a soft spot for Pascal (and Algol) and Pascal has f(var x : Integer)
23:39:32 <mauke> also, putting const on a function's return type is silly
23:39:33 <thang1> Now that I've successfully derailed a bunch of fp nerds... *cough* I'm off to bed. I'm still pretty sick and need to go to the DEQ tomorrow to get my car tags renewed
23:41:11 <quchen> mauke is fairly easy to derail, just say anything about C and he will correct you
23:41:29 <ongy> C is the captial letter of c
23:41:49 <monochrom> @quote monochrom faster.than
23:41:49 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
23:42:18 <quchen> I wish I knew as much about Haskell as he about C :-)
23:42:46 <thang1> haaa, funny
23:43:02 <thang1> Also, I wish I knew as much about C as he about C :p
23:43:16 <thang1> There's a sort of beauty to looking insanity in the eye and somehow staying mostly sane
23:43:46 <mauke> "an object or variable which has been declared ‘const’ can be converted to changeable by use of ‘const_cast’" <- I'm pretty sure that's not true
23:44:05 <mauke> in that trying to modify a const object is UB
23:44:14 <thang1> http://en.cppreference.com/w/cpp/language/const_cast
23:44:22 <mauke> const_cast is like unsafeCoerce
23:44:34 <thang1> (I can't grok most of that, but this is what hte standard has to say about it)
23:44:41 <mauke> it's for when you know it's actually mutable but you can't convince the type system
23:44:52 <johnw> mauke: except all that it can do is cast away constness
23:45:40 <mauke> yes
23:45:45 <mauke> (and volatile)
23:45:48 <joe9> anyone tried curry? any first impressions that you could share? like it or hate it?
23:45:55 <thang1> (of the systems languages, though, Rust is the one I'm looking forward to learning the most, and I suppose I shall learn C++ too if I have to)
23:46:16 <mauke> I've recently started reading The C++ Programming Language
23:46:23 <thang1> joe9: my professor from fall quarter is one of the designers of the language
23:46:59 <thang1> I've yet to try it, though. I'm going to take a crack at it sometime after finishing "haskell from first principles"
23:47:37 <joe9> thang1: cool, is it an improvement over dependent typed languages?
23:48:48 <thang1> I wouldn't say improvement, I would say "alternative"
23:49:11 <thang1> Dependent types are a way of meshing together and blurring the lines between types and values
23:49:20 <thang1> (cue cannonical example of type-safe length vector)
23:49:26 <joe9> have you tried refinement types (liquid haskell)?
23:49:54 <thang1> This allows the compiler to act as a basic proof assistant to a greater extent than in a language like vanilla Haskell
23:50:02 <thang1> (no I haven't. It sounds cool, though)
23:50:04 <quchen> Dependent types don’t »blur« the lines, they simply don’t have the lines
23:50:18 <quchen> Like Haskell does not »blur« the lines between Bool and Int
23:52:44 <thang1> You're correct. I still sort of find it useful to think of it as a line blurring because dependent types are types that are dependent on values of the function. So the values and types become much more tightly bound together in the thinking and reasoning about a program
23:54:13 <thang1> Whereas traditional Haskell has the types and the values very separate. Your values have types but the types are purely a way to ensure program safety and sketch out data flow. No concept of proofs, depndency, quantifiers, and so on
23:54:36 <thang1> Probably not the best way to think about them, but it's what I've got for now until I get more mature in functional programming :)
23:55:33 <thang1> Anyway, joe9, one of the main uses of dependent types can be thought of as (roughly) a sort of "constraint checking".
23:57:11 <thang1> To use the length vector as an example. A vector of length n + vector of length m = vector of length n+m. That sort of function is using dependent types to declare constraints on what the acceptable values and inputs are beyond merely the "type"
23:57:11 <thang1> Logical functional programming also allows you to do that sort of constraint programming
23:57:16 <quchen> What usually gets me when thinking this way is when types and kinds are also »blurred«.
23:57:38 <quchen> And then I try to find a value of kind Int, or have a 1 that I’d like to have type Set, and so on.
23:57:47 <thang1> Consider a function that yields the last element of a list.
23:57:52 <joe9> I am thinking of Curry vs LH for my next learning step.
23:58:09 <thang1> In Curry, this is a valid solution: last xs | ys++[e] =:= xs = e where ys,e free
23:58:47 <thang1> Narrowing (finding a solution that works in the solution space of any possible solution) is then used to "solve" the function
23:59:25 <thang1> You can also define it, validly, in Curry like so: last (ys++[e]) = e
23:59:32 <nshepperd> with TypeInType, types *are* kinds, right?
