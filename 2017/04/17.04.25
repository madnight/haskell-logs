00:03:35 <iqubic> So, if haskell was *NOT* lazy then the tardis monad would be impossble to create
00:04:02 <jle`> i don't think i'd say impossible
00:04:17 <jle`> but it might be a bit more complicated to implement
00:04:23 <jle`> since right now its implementation is like silly simple
00:05:12 <iqubic> I think the backwards traveling stream would be impossible in a non-lazy language.
00:05:50 <jle`> have you considered the fact that it's possible to implement lazy algorithms in a strict language
00:05:56 <iqubic> no.
00:06:04 <iqubic> It's not possible.
00:06:05 <jle`> http://danieltao.com/lazy.js/, for instance
00:06:19 <jle`> the language just makes it simpler to do
00:06:35 <jle`> https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/
00:07:11 <jle`> heck, even python has generators, which can be thought of as lazy lists
00:07:27 <jle`> laziness is just semantics, and it can be implemented in any language
00:08:15 <jle`> the only role a programming language has is making it easier or harder to write lazy algorithms
00:09:43 <LiaoTao> jle`: But isn't that just semantics? You would just be implementing another (lazy) language in terms of your strict language?
00:09:49 <LiaoTao> woudln't*
00:09:54 <LiaoTao> wouldn't* dammit
00:10:07 <jle`> yes, you could go about it by implementing thunks in whatever language you are using
00:10:51 <jle`> the language wouldn't become a lazy language
00:10:58 <jle`> but it lets you implement algorithms that rely on laziness
00:11:08 <jle`> and get similar operational complexities
00:11:57 <jle`> you can implement algorithms that rely on laziness (and data structures that rely on laziness) in any language, it just is easier in some than others
00:12:18 <LiaoTao> jle`: Which makes the distinction less poignant?
00:12:43 <jle`> yeah, this was in response to saying "X can't be implemented in a language without laziness"
00:13:01 <yushyin> iqubic: yup, implemented lazy eval in java once for an assignment 
00:13:54 <jle`> or rather, the statement was "if haskell was not lazy, it would be impossible to implement X"
00:15:00 <thang1> lazy eval in java? good lord
00:15:16 <nshepper1> The TARDIS monad in a strict language would probably be gross and not as impressive though
00:15:45 <thang1> The key thing about laziness for me (personally) is that if you design a language/compiler/etc toolchain around laziness
00:15:55 <thang1> It's far easier to include an opt-in strictness evaluation model
00:16:07 <jle`> nshepper1: it's definitely not something i would want to be put in charge of :)
00:16:20 <thang1> However with a strict-model toolchain, it's almost always 10x uglier and ridicuous to try and strap in a lazy model on top of that
00:16:27 <thang1> So... lazy > strict ;)
00:16:59 <thang1> Also, I really like things like cycle and [1..]
00:19:41 <jle`> thang1: btw, is your username a reference to the nonstandard spelling of 'thing', or to one of the many potential vietnamese words it is? :o
00:21:39 <moet> hmm.. i'm having trouble exporting the field names of an associated data constructor .. https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/type-families.html#data-family-import-export this link seems to indicate that i must explicitly mention the field names
00:24:22 <moet> naming them explicitly works
00:39:22 <thang1> jle`: It's a really obtuse reference to doctor seuss
00:39:50 <thang1> It used to be thang1thang2 (my reddit username) but I shortened it to thang1 on irc because shortnames are nicer
00:40:30 <thang1> thang1 and thang2 really being the characters "thing 1" and "thing 2" of doctor seuss's books
00:49:08 <ij> Can I export a name from a module under a different name?
00:49:26 <thang1> Sure, why not?
00:50:04 <thang1> wait... I might be thinking of import. jle` help pls
00:50:51 <ij> I think you can export only under the real name.
00:51:05 <jle`> yeah you can't rename exports in general, that's actually one of the common complaints about the haskell module system
00:51:30 <jakub_> Hi, I currently have code like 'SomeTrans . put =<< (traverseOf lenses someTransAction) =<< SomeTrans get, is there a nicer way with lens library (to hide reading and writing the state, something like the %= but for a monadic action rather than plain old function)?
00:51:39 <thang1> Thanks. At first I was like, sure just import qualified as... but then I realized it was Export, not Import. Too late over here :)
00:51:40 <jle`> it prevents people from doing a lot of things that would make alternative Preludes useful
00:51:58 <jle`> with functions you can re-name the function and export the new binding, and same with type synonyms to some extent
00:52:21 <tsahyt> is there a schedule somewhere for the next GHC release? The wiki says mid April for the final release, but that's over already.
00:52:52 <jle`> jakub_: you might want to look into zoom
00:53:18 <tsahyt> I'm asking because apparently Cabal 2.0 should release with it, and I need foreign library support for something. So if the release is soon enough I can just wait a bit rather than trying to convince stack to use the new cabal somehow
00:53:38 <jakub_> jle`: thanks, i am reading it now
00:54:11 <jle`> i'm not sure if it's the exact pattern you're looking for, but it might be similar
00:54:48 <jakub_> jle`: hopefully we will see soon :) but currently i have no idea what zoom does :)
00:55:21 <jle`> jakub_: zoom :: Lens' s1 s2 -> State s2 a -> State s1 a
00:56:57 <jakub_> jle`: the challenge for me is that i want something that takes (a -> m b) and modifies the state accordingly, if i had a constant (m b) i guess i could just do <~
01:01:03 <thang1> welp it's 1am over here and I finally finished this dumbass assignment so I'm gonna go to bed and see how much sleep I can get before I need to wake up (hint: not enough)
01:17:39 <ph88_> jle`, do you know a lot about Conduit ?
01:18:12 <jle`> i have used it before
01:18:55 <cocreature> asking your question directly usually works better than asking if someone knows something about the topic of your question
01:20:32 <ph88_> cocreature, ye ok, but i asked it yesterday and it's a hard question i think. Not sure how to tie together Conduit State and IO
01:20:48 <ph88_> ok i re-ask
01:22:44 <ph88_> so ye basically i want to combine two functions https://bpaste.net/show/f541df9320e5
01:23:03 <ph88_> the second conduit function i want to call evalState on it, but i don't know how
01:23:24 <ph88_> i did some trial and error putting evalState in a few places but that was a dead end
01:23:59 <cocreature> where should the initial state come from?
01:24:05 <ph88_> i think this stackoverflow answer possibly contains an important hint http://stackoverflow.com/a/24528696
01:24:29 <cocreature> one option would be to mmorph both conduits to ConduitM … (StateT StreamState IO) …
01:24:34 <osa1> is there a way to encode a Csv type in cassava without generating a [Record] from `Csv` ?
01:24:41 <ph88_> i have this for the initial state https://bpaste.net/show/667e3809ad7f
01:25:21 <cocreature> ph88_: maybe add a type annotation to pipe to make it clearer what you expect the result of the composed conduits to be
01:25:37 <ph88_> cocreature, i don't have any expectations about that yet
01:26:10 <ph88_> can i use StateT and use liftIO as the SO answer suggest ?
01:26:26 <srhb> osa1: Can you explain why you want this? It doesn't sound like it makes a lot of sense, if you have just one "Record", using encode is as simple as making a one-element list.
01:26:27 <cocreature> sure
01:26:41 <ph88_> but how ?
01:26:42 <cocreature> that’s what I meant by mmorphing to ConduitM … (StateT StreamState IO)
01:26:48 <ph88_> oh
01:27:01 <ph88_> i thought you wanted me to use this package https://hackage.haskell.org/package/mmorph
01:27:09 <cocreature> I do :)
01:27:12 <ph88_> o_O
01:27:21 <cocreature> conduit already depends on it anyway
01:27:26 <cocreature> and provides the necessary MFunctor instance
01:27:38 <osa1> srhb: I don't have a single Record, I have a vector of Records (type Csv = Vector Record)
01:28:01 <srhb> osa1: Ah, so you want to avoid going through list because you already have the vector?
01:28:07 <osa1> srhb: yes
01:28:10 <cocreature> ph88_: https://hackage.haskell.org/package/mmorph-1.0.9/docs/Control-Monad-Morph.html#v:hoist is the relevant function
01:28:36 <cocreature> you need a function "IO a -> StateT s IO a" to lift one of the conduits into StateT
01:28:54 <srhb> osa1: You are right that there's no out of the box encode that does that (and I doubt it would perform much better anyway)
01:28:58 <cocreature> and you need "State s a -> StateT s IO a"
01:29:15 <osa1> srhb: I don't care about performance, I don't want to introduce vector dependency just for this
01:29:23 <ph88_> cocreature, i have some resistance here because my expectations were that this would be trivial to solve because in the tutorial they also use state https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview  can you tell me that your way is the most straightforwaded way to do it and i will belief you
01:29:52 <osa1> srhb: also, it's weird that there's no way to encode Csv type
01:30:24 <cocreature> ph88_: the tutorial doesn’t seem to combine State and IO
01:30:31 <cocreature> ph88_: which is what is causing problems in your case
01:30:49 <ph88_> true .. but that just make me think i setup my functions wrongly in the first place and possibly should rewrite them
01:31:19 <cocreature> ph88_: if you can change the defintiion and the type of adjustSampleInterval and the other thing you can avoid hoisting
01:31:35 <ph88_> adjustSampleInterval has to have state
01:31:44 <ph88_> don't know how to change it's type
01:31:49 <cocreature> try getting something of type "MonadState StreamState s => Conduit Double m Double"
01:32:13 <cocreature> and "MonadIO m => ConduitM ByteString Double m ()"
01:32:19 <cocreature> then you should be able to just compose them
01:32:26 <ph88_> i'm confused by that because i don't see s reappear after the => arrow
01:32:40 <cocreature> oh that should be MonadState StreamState m
01:32:42 <cocreature> typing is hard
01:33:36 <ph88_> i don't know how to change both functions to get those type signatures
01:33:46 <cocreature> change the type signatures and try to follow the errors
01:33:56 <ph88_> ConduitM BSC.ByteString Double IO ()  into  MonadIO m => ConduitM ByteString Double m ()
01:34:00 <cocreature> it should be relatively easy to figure out where you need liftIO
01:34:07 <ph88_> Conduit Double (State StreamState) Double  into  "MonadState StreamState s => Conduit Double m Double
01:34:12 <ph88_> ok
01:34:26 <ph88_> you want to see the function implementation ?
01:34:27 <cocreature> the latter might work out of the box if you’re lucky
01:37:00 <ph88_> cocreature, i changed the first type signature but i didn't get a type error
01:38:05 <cocreature> ph88_: great :)
01:38:33 <ph88_> same with second one
01:39:15 <cocreature> so now you should be able to compose them
01:39:28 <ph88_> where should i put evalState ?
01:39:48 <ph88_> conduitParserEither parseLine .| selectColumn .| (evalState adjustSampleInterval startStreamState)    ??
01:40:00 <cocreature> I don’t know, that depends on what you want to do
01:40:14 <cocreature> you can use conduitParserEither parseLine .| selectColumn .| adjustSampleInterval
01:41:10 <ph88_> cocreature, i changed the types as you suggested and used .|  now i get this type error  https://bpaste.net/show/fd283543c425
01:41:42 <ph88_> i saw this error before by the way, but i don't know what to do with it
01:42:00 <cocreature> what’s the type of selectColumn?
01:42:52 <cocreature> it means something is forcing m to be IO so it seems like you forgot to change one of the type signatures
01:43:11 <ph88_> cocreature, https://bpaste.net/show/6845acc97a97
01:43:54 <cocreature> ph88_: what’s the type of conduitParserEither?
01:44:22 <ph88_> ghci infers:  conduitParserEither parseLine .| selectColumn :: MonadIO m => ConduitM BSC.ByteString Double m ()
01:45:25 <ph88_> cocreature, https://hackage.haskell.org/package/conduit-extra-1.1.15/docs/Data-Conduit-Attoparsec.html#v:conduitParserEither
01:45:31 <ph88_> conduitParserEither :: (Monad m, AttoparsecInput a) => Parser a b -> Conduit a m (Either ParseError (PositionRange, b))
01:45:44 <anoe> there is a booleaQueryParser ::  String -> Tree a     already ?
01:47:31 <ph88_> anoe, hhmm not by searching https://hayoo.fh-wedel.de/?query=String+-%3E+Tree+a
01:49:00 <alexbiehl> ph88_ the hayoo database is quite old
01:52:58 <cocreature> ph88_: http://lpaste.net/354913 works just fine so it seems like you’re doing something different than you are telling me
01:53:55 <ph88_> cocreature, the type signature you put on pipe is different than mine
01:54:24 <ph88_> i changed it now my code works too
01:54:32 <cocreature> ph88_: you said you didn’t have a type signature :P
01:54:40 <ph88_> did i ? :/
01:55:08 <cocreature> maybe I misunderstood. anyway I’m glad you got it working
01:55:43 <ph88_> ye me too
01:57:38 <ph88_> how do i turn a   ConduitM BSC.ByteString Double IO ()   into a   Source IO Double   ??   i have these two functions that i want to make compatible  https://bpaste.net/show/572100c2c0c7
01:58:15 <ph88_> streamToVector pipe    just gives type error that types don't match
01:59:18 <ph88_> by the way ... this piece here    (MonadIO m, MonadState StreamState m) =>    is kind of an eye opener for me ^^
01:59:33 <ph88_> it's like an on-the-fly monad isn't it ?
02:05:55 <kubrat> ~.
02:10:12 <ph88_> oh i think i need a source :P
02:19:29 <tsahyt> is there a really compact TLDR for compact regions, just as a reference point before I start into the paper?
02:20:47 <merijn> tsahyt: Ok, so I have to admit I haven't read it and only now some high level things, but afaict it boils down to the following.
02:20:56 <merijn> tsahyt: Are you a little familiar with how GHC does GC?
02:21:00 <tsahyt> roughly
02:21:23 <merijn> tsahyt: i.e., it copies every bit of live data into a new heap and then throws away the entire old one
02:21:43 <tsahyt> yes
02:21:46 <merijn> tsahyt: From this obviously follows: having lots of live data requires A LOT of copying, which means your GC is slower
02:22:31 <merijn> tsahyt: So, suppose we have a huge (few GB, maybe?) static data structure that we keep around to compute, whatever the fuck on. Every single time we trigger GC we have to copy the entire damn thing
02:22:53 <tsahyt> I never quite realized how inefficient that gets
02:23:07 <tsahyt> I always just assumed that GHC would be more clever about this, with unchanging data
02:23:10 <merijn> tsahyt: Well, if we know AHEAD that we have such a huge thing and we know we'll never GC parts of it (i.e. we always either keep the entire thing or throw all of it away)
02:24:22 <merijn> tsahyt: The idea behind compact regions is, "let's just allocate this huge thing once in this special region and then never copy is, since we assume the entire region stays alive" (you could GC the entire region based on whether *anything* points into it, or you could require explicit freeing, not sure what GHC does
02:24:27 <merijn> tsahyt: But that's the high level gist
02:25:14 <merijn> tsahyt: Well, the copying happens in parallel and there's a bunch of clever things in the GC to reduce this problem, but it can be an issue for some specific cases
02:25:17 <tsahyt> hmm okay. so this region is then also immutable?
02:25:59 <cocreature> compact regions can only point into themselveso so you also don’t need to trace inside the region
02:26:29 <cocreature> iirc a region is freed automatically as soon as there is no pointer pointing inside the region
02:26:46 <tsahyt> alright. does this require some special programmer intervention, e.g. some allocing or so?
02:26:51 <merijn> tsahyt: Yeah (note, I'm guessing from skimming text), you basically trigger a "custom" GC for an object, but instead of copying it into the new "heap" we copy it into a special separate heap that we then know not to inspect further
02:27:16 <merijn> tsahyt: Yeah, there's an API you can call to "compactify" some data structure
02:27:22 <tsahyt> alright, thanks! I think that's enough for motiviation :)
02:27:34 <alexbiehl> Here is a quick starter: https://github.com/ezyang/compact#tutorial
02:27:49 <merijn> I was just about to link that :)
02:29:31 <ph88_> i have some conduits and it seems one is missing a ResourceT .. so i try to add it in the type signature but that just makes things worse ad the conduits no longer seem to be compatible with each other ..  https://bpaste.net/show/5163654a06ac
02:29:43 <tsahyt> so here the Compact pointer gets discarded, doesn't it? set <- fmap getCompact (compact (Set.fromList (words dict)))
02:30:04 <tsahyt> so set holds a reference to the compact region, and when set goes out of scope, the region can be discarded?
02:32:23 <merijn> tsahyt: Yes, so it seems the GC takes care of tracking the liveness of the region (which I hoped, but wasn't sure)
02:32:47 <merijn> tsahyt: It's just that the GC knows that "as long as I have a pointer to anywhere in the region, I don't have to throw it away"
02:32:49 <tsahyt> that's nice. but couldn't I get something like that by abusing the FFI and finalizers a bit?
02:33:24 <merijn> tsahyt: That requires you to be able to convert your Haskel data structure to a C one, which might not be possible
02:33:58 <merijn> tsahyt: Consider a huge data structure containing, I dunno, IORefs, MVars, sockets, file descriptors, what not. Can't easily serialise that to C via FFI
02:33:59 <tsahyt> right. also I think that you can't just hold on to the memory using *any* pointer into it
02:34:43 <merijn> tsahyt: I agree that it solves a rather niche problem, but it's also a problem that if you're running into it, would be really hard to solve without GHC support :)
02:35:03 <merijn> So it's a neat trick to be aware of, should you ever need it
02:35:24 <tsahyt> I think it might help with keeping latency down in some appliations
02:35:53 <tsahyt> I wonder whether there can be some interesting interplay between that and the proposed linear types extension
02:35:57 <merijn> Certainly, reduced latency AND improved GC efficiency
02:36:14 <merijn> Also, reduces the time of global GC stops
02:36:57 <tsahyt> why does the GC have to be stop-the-world to begin with?
02:37:08 <merijn> tsahyt: Because GHC does compacting GC
02:37:33 <merijn> tsahyt: i.e. "objects" are moved to different addresses. Other threads may be using those objects
02:38:05 <merijn> tsahyt: Other GCs keep objects whereever they're initially allocated, but that has the downside of fragmenting memory
02:38:08 <tsahyt> oh, so you'd essentially have to put everything into mutexes otherwise
02:38:18 <tsahyt> or rather locks around everything
02:38:43 <merijn> tsahyt: Which would kill performance anyway, since you'd have to take a lock for every single operation
02:38:59 <tsahyt> is fragmenting memory really that big a deal? I guess it could mess with caching due to decreased locality in some cases
02:39:11 <merijn> tsahyt: There's two ways to avoid this: 1) per thread heaps, like Erlang has and copy by value 2) global GC stop
02:39:25 <merijn> tsahyt: Well, fragmenting memory means more complex allocation routine, which means slower allocation
02:39:32 <tsahyt> I see
02:39:41 <tsahyt> and since basically everything possibly allocs in haskell, that'd be bad
02:39:52 <merijn> tsahyt: GHC's memory allocation is currently literally an increment followed by an if
02:40:14 <merijn> tsahyt: if you want to allocate 100 bytes, look at the current heap size, increment by 100, check for heap overflow, done
02:40:17 <tsahyt> is that why the runtime just fetches a ton of virtual memory from the outset?
02:40:37 <tsahyt> it started doing that with GHC 8 iirc
02:41:07 <merijn> tsahyt: That's to simplify the GC by allowing GHC to assume the heap is *always* contiguos, instead of spread out through memory
02:41:36 <tsahyt> and then just let the OS handle the rest
02:42:16 <merijn> tsahyt: The advantage of this allocation method is that if you assume most allocations die quick (they mostly do) you can allocate, say, 50MB by incrementing pointers and if only 200bytes are still alive, then GCing those 50MB means "reset heap offset and copy 200 bytes to new heap"
02:43:23 <kuribas> is there a lossless way to read and write a Double?
02:43:53 <merijn> kuribas: Can you be more specific about the usecase?
02:44:14 <kuribas> merijn: debugging
02:44:33 <kuribas> I get different results in my program when testing on ghci
02:44:44 <merijn> That's peculiar
02:45:15 <merijn> The 100% guaranteed lossless way would be to dump them out as raw bytes
02:46:05 <kuribas> hm, I should try that
02:51:24 <merijn> How have I not seen edwardk's structs before? :o
02:51:50 <osa1> does servant have something like the Server type but for documentation generation? closest thing I could find was the API type but that doesn't check type of my documentation against the API type
02:52:18 <osa1> I want to avoid HasDocs typeclass
03:14:09 <mniip> hmm
03:14:58 <mniip> considering that in system fc tyfams don't really have a function kind, and their application is significantly different from tycon application
03:15:21 <mniip> what if we made tyfams have a special arrow kind, distinct from the tycon arrow kind
03:15:32 <mniip> and add the ability to partially apply tyfams
03:15:47 <mniip> but not pattern match types of that special arrow kind
03:15:55 <mniip> would that be inconsistent?
04:03:12 <lyxia> basically, type level lambdas
04:11:40 <ertes> once again ertes returns to haskell, this time from scheme and clojure…  i'm giving up on finding a separate language for "scripting"
04:12:38 <hpc> have you tried perl?
04:12:52 <ertes> hpc: does it have concurrency?
04:12:58 <hpc> not really :P
04:13:06 <ertes> then i won't even consider it =)
04:13:08 <hpc> you can pull some pretty stupid FP tricks in it though ;)
04:14:35 <ertes> clojure came closest, but its STM is simplistic and not very powerful
04:20:10 <ertes> i have to admit though: easy anonymous records were quite refreshing to have…  and no, vinyl is nowhere near easy =)
04:25:22 <tdammers> clojure is terrible for scripting
04:25:44 <tdammers> the language could work, but the implementation is just not suitable at all
04:29:14 <ertes> it doesn't seem to offer any advantage over haskell anyway that isn't quickly overshadowed by its relative shortcomings
04:30:31 <ph88_> what shortcomings ?
04:31:22 <ertes> missing type system, poor concurrency in comparison, and its hack for JVM's lack of proper tail calls
04:32:25 <capisce> what are the disadvantages of haskell for scripting?
04:32:52 <ertes> capisce: deployment
04:33:42 <ertes> GHC is not available everywhere, and when it's available, it only makes you want to shout at debian maintainers
04:33:49 <tdammers> almost everything that clojure does well, haskell does it better
04:34:13 <ertes> there are solutions though…  if all else fails i'll just deploy nix closures
04:34:34 <srhb> ertes: If that's an option, I don't understand why you would even look further. :)
04:35:33 <ertes> srhb: i really just wanted to try something else…  it doesn't hurt to get new perspectives from time to time =)
04:36:24 <srhb> ertes: Right, I'm just being jealous that that's an option for you. ;-)
04:43:35 <ertes> srhb: i used to do PHP eight hours a day, so i had that, too…  and yes, i was already a hobby haskeller at that point =)
04:48:19 <EvanR> the freer monad frees us from monads
04:52:13 <ph88_> ertes, ah me too !
04:52:21 <ph88_> which frameworks did you use ?
04:53:18 <merijn> dolio: ping?
04:56:38 <ertes> ph88_: the worst: zend framework, with occasional GlobalVariables3 nightmares
04:56:45 <ertes> s/GlobalVariables3/TYPO3/
04:56:54 <ph88_> zend is not so bad is it
04:57:40 <ph88_> how did you get into haskell then ?
04:58:02 <ertes> well, to keep it short: it was semi-useful as a library, and horrible as the actual MVC framework it sells itself as
04:58:40 <tdammers> zend framework isn't the worst
04:59:01 <tdammers> home-grown framework that was lead (and only) programmer's first ever programming project
04:59:04 <ertes> actually i don't remember how i discovered haskell…  my first memory of haskell was when i tried to learn it using the haskell road to logic
04:59:14 <kamyar> Please help me understand the code here: https://bendyworks.com/blog/authentication-via-haskell
04:59:28 <EvanR> i learned about haskell after looking into ocaml
04:59:34 <KingBuzzo> Hey! Little question: I need to access previously computed values of an unboxed vector for calculating the current one (for example like the Fibonacci progression). How can I access those? 
05:00:02 <ertes> KingBuzzo: as in state, or as in dynamic programming?
05:00:21 <KingBuzzo> as in dynamic programming
05:01:11 <ertes> KingBuzzo: you can use laziness for DP, for example a lazy list or a lazy vector
05:01:23 <ertes> @let import qualified Data.Vector as V
05:01:25 <lambdabot>  .L.hs:130:1: error:
05:01:25 <lambdabot>      Data.Vector: Can't be safely imported!
05:01:25 <lambdabot>      The module itself isn't safe.
05:01:29 <ertes> too bad
05:02:07 <ph88_> ertes, why haskell and not another language instead of php ?
05:02:17 <ertes> KingBuzzo: the following is going to be inefficient, because lists aren't suitable for this, but you can use it as inspiration for vector or Seq-based implementations
05:03:54 <ertes> @let f = f'; where xs = map f' [0..];  f' 0 = 0; f' 1 = 1; f' x = xs !! (x - 1) + xs !! (x - 2)
05:03:54 <lambdabot>  Parse failed: Parse error: where
05:04:03 <ertes> @let f = f' where xs = map f' [0..];  f' 0 = 0; f' 1 = 1; f' x = xs !! (x - 1) + xs !! (x - 2)
05:04:05 <lambdabot>  Defined.
05:04:15 <ertes> oh crap
05:04:25 <ertes> > map L.f [0..]
05:04:27 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:04:40 <ertes> @undef
05:04:40 <lambdabot> Undefined.
05:04:52 <ertes> KingBuzzo: of course with lists you would simply use state instead of DP
05:05:11 <ertes> > map fst (iterate (\(x, y) -> (y, x + y)) (0, 1))
05:05:13 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:05:21 <KingBuzzo> yeah thank you, i know this works fine :) my problem is that I struggle to find an appropriate data structure for my problem.
05:05:26 <Maxdamantus> > let fibs = 1 : 1 : [(fibs !! (n - 1)) + (fibs !! (n - 2)) | n <- [2..]] in fibs !! 100
05:05:28 <lambdabot>  573147844013817084101
05:05:57 <ertes> KingBuzzo: the fibonacci sequence is not a very good use case to begin with
05:06:11 <Maxdamantus> > let fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 100
05:06:17 <lambdabot>  mueval-core: Time limit exceeded
05:06:22 <Maxdamantus> list wins
05:06:36 <KingBuzzo> asked the question yesterday already here but didn't find a proper solution yet. I need to build a two dimensional table and access values i've computed already when computing a new one. Sounds easy but apparently isn't. Normal Data.Array seems horribly inefficient for this
05:06:59 <ertes> @let fib = fib' where xs = map fib' [0..];  fib' 0 = 0; fib' 1 = 1; fib' x = xs !! (x - 1) + xs !! (x - 2)
05:07:00 <lambdabot>  Defined.
05:07:03 <ertes> > fib 100
05:07:05 <lambdabot>  354224848179261915075
05:07:14 <KingBuzzo> so I was told to try Data.Vector.Unboxed (for which I had to translate the table's coordinates to a single value)
05:07:25 <KingBuzzo> but accessing older values doesn't work here
05:08:02 <ertes> KingBuzzo: you need to use a boxed structure
05:08:08 <ertes> Data.Vector will work
05:08:27 <KingBuzzo> and hopefully faster than Data.Array?
05:08:32 <ertes> unlikely
05:08:43 <ertes> as i said, fib is not a good use case
05:09:07 <KingBuzzo> was just an example anyway ;)
05:09:46 <KingBuzzo> basically all i need is an efficient data type which allows dyn prog
05:10:09 <ertes> depending on your access patterns you can use any structure that fits the problem
05:10:20 <ertes> Map, Seq, Vector, …
05:10:45 <KingBuzzo> for a table entry (i,j) i need to access values (k,l) with k<i and l<j
05:11:17 <ertes> sounds like a 2D array to me
05:11:31 <KingBuzzo> which have obviously already been computed. exactly. Data.Array is horribly slow though :(
05:11:50 <ertes> now there is a middle ground, if you're fine with precomputing an entire table
05:12:27 <ertes> vector has the 'constructN' function
05:12:41 <ertes> which is available for all vector flavours
05:12:41 <Maxdamantus> Weird. I Googled that `fibs !! 100` number and found: http://www.cgpgrey.com/573147844013817084101/
05:12:57 <Maxdamantus> interesting job filter.
05:14:17 <ertes> if you want efficiency *and* laziness, you probably need to layer a plane wrapper over unboxed vectors
05:15:10 <ertes> type SemiLazyPlane a = V2 Int -> Vector a
05:16:22 <KingBuzzo> o-kay... this is beyond my knowledge to be honest
05:17:10 <ertes> the idea is simple: imagine a plane of boxed values…  that's what a boxed Vector is…  but it's also inefficient
05:17:55 <KingBuzzo> the table values are a custom data type that has three Integer values if that's relevant
05:18:03 <ertes> now imagine that you split the plane into 16x16 squares, each individual square being an *unboxed* vector
05:18:13 <ertes> whenever you get a value from a square, the whole square is computed
05:18:25 <ertes> and you keep those squares in a boxed plane instead
05:18:29 <barryburd> Too many parentheses? How to convert the following code into idomatic Haskell?
05:18:31 <barryburd> module Main where
05:18:31 <barryburd> median xs = head [ x | x <- xs,
05:18:32 <barryburd>     length([y | y <- xs, y < x]) == length([y | y <- xs, y > x]) ]
05:18:33 <barryburd> main = putStrLn $ "The median is " ++ show (median [4,7,2,1,0,9,6])
05:18:59 <KingBuzzo> like type XY = T Int Int Int
05:22:00 <KingBuzzo> so to sum it up, what would data structure would you recomment that suits my needs?
05:24:53 <lyxia> KingBuzzo: Vector
05:25:51 <lyxia> barryburd: sort then pick the middle
05:26:03 <ertes> > let median xs' = let xs = sort xs' in head (drop (length xs `div` 2) xs) in median [1,5,3,8,9,4,2]
05:26:04 <lambdabot>  4
05:26:41 <ph88_> ertes, i also used php and wanted to try a new language, i was looking at a few options. Did you consider any other languages then ?
05:27:44 <ertes> ph88_: C++ came to my mind, as it was the language i was most familiar with beside PHP…  FP was very new to me
05:28:18 <barryburd> ertes, I really like the elegance of the list comprehension approach. Is that approach so bad?
05:28:55 <ph88_> barryburd, you can also use the list monad
05:29:00 <ertes> barryburd: compare:  filter (< x) xs
05:29:21 <ph88_> ertes, how long ago was this ?
05:29:24 <ertes> vs. [ y | y <- xs, y < x ]
05:29:52 <ertes> ph88_: 2007
05:30:25 <barryburd> ertes, you make a good point
05:30:47 <KingBuzzo> lyxia: but when using a Vector and the constructN function, i don't have direct access to the current index right?
05:31:03 <ertes> barryburd: note: you received answers to two different questions:  one is about efficiency/algorithm, the other is about style
05:31:31 <ertes> barryburd: i generally prefer combinator syntax over comprehensions, because combinators are composable
05:31:45 <ertes> but there are some legitimate use cases for comprehensions as well
05:32:05 <barryburd> ertes, I prefer style over efficiency
05:32:52 <ertes> barryburd: then you haven't watched this yet: https://www.youtube.com/watch?v=fHNmRkzxHWs
05:35:20 <ertes> i think it's not necessary to squeeze the last nanosecond and byte of memory out of code, but in my view efficiency should always be taken seriously
05:35:57 <EvanR> we have the luxury of caring about efficiency because there exist possible routes to get it in haskell which dont resort to FFI
05:36:20 <EvanR> which is weird for a high level language
05:37:17 <barryburd> ertes, I’m teaching people who are uncomfortable with code, so the ability to read the code and the clarity of the code that they write is of utmost importance. Efficient code that’s the least bit difficult to read would make them run in the other direction. (But I understand arguments to the contrary.)
05:37:59 <ertes> barryburd: ironically in haskell efficient code is usually also the most readable, because you get an API that actually fits your problem =)
05:38:14 <EvanR> i wish efficient code thats the least bit difficult to read made people run the other direction in other circumstances
05:38:30 <EvanR> or inefficient code for that matter
05:40:04 <ertes> this is something that is often misunderstood: if you want to make haskell code run fast, you should write it in an idiomatic way
05:40:20 <tdammers> there are a few exceptions though
05:40:31 <ertes> IntMap/Map, Seq, IntSet/Set…  and never share lists
05:40:57 <ertes> sure, but it's a good general rule
05:41:11 <ertes> s/rule/guideline/
05:43:03 <EvanR> never share lists?
05:44:01 <ertes> EvanR: median xs' = let xs = sort xs' in head (drop (length xs `div` 2) xs)  -- xs is shared, and that's bad
05:45:06 <tdammers> why is it bad?
05:45:11 <merijn> tdammers: Prevents GC
05:45:16 <tdammers> oh, ok
05:45:18 <merijn> tdammers: Thus leaks memory
05:45:26 <Boomerang> No list fusion? Is that something linear types can help with?
05:45:35 <tdammers> thought this was the exuberant laziness problem
05:45:56 <merijn> tdammers: Well laziness ensures things are kept alive longer
05:46:12 <merijn> tdammers: Consider "avg l = sum l / length l"
05:46:41 <merijn> Sum forces the entire list and it can't be GCed since length keeps it alive
05:47:00 <tdammers> right
05:47:09 <GeorgeEdward> does anybody know of any papers tackling halo exchange in functional languages?
05:47:32 <tdammers> funnily, this particular implementation wouldn't have crossed my mind
05:49:06 <EvanR> in avg l = sum l / length l, how do you "unshare" l ?
05:49:18 <ertes> EvanR: you use a single fold
05:49:53 <ertes> :t uncurry (/) . foldl' (\(s, l) x -> (s + x, l + 1)) (0, 0)
05:49:54 <davean> GeorgeEdward: what would be special about it in a functional vs. non-functional language?
05:49:55 <lambdabot> (Foldable t, Fractional c) => t c -> c
05:50:00 <ertes> EvanR: like that
05:50:09 <EvanR> well, im not going to call this a more natural way
05:50:12 <tdammers> tuple up (x, 1) for each x in l, then fold that with a sum-both operation
05:50:45 <ertes> EvanR: you can make it nicer by using a composable folds library like 'foldl'
05:50:46 <GeorgeEdward> davean: just curious as to thinking of implementation
05:51:16 <GeorgeEdward> davean: I'm not sure whether it'd be better in a multiple process capacity or if there's some clever monad-fu to be done
05:51:29 <ertes> EvanR: then you can write: liftA2 (/) Foldl.sum Foldl.length
05:51:42 <EvanR> o_O
05:52:14 <EvanR> i dont know if this is idiomatic, but it doesnt sound like an obvious route to get haskell to go fast, at least for beginners
05:53:07 <ertes> EvanR: i had beginners come up with that fold on their own…  you're underestimating them =)
05:53:34 <ertes> in fact i'd say they should be taught to
05:53:42 <osa1> is there a GHC flag for dumping all instances of T when compilation fails with `no instance for T x ...` ?
05:54:09 <EvanR> this is an instance of having to understand operational semantics to write something in a non obvious way to get performance boost
05:54:43 <sproingie> beginners needn't be obsessed with performance.  get the complexity order right and call it done.
05:54:54 <barryburd> Beginners come up with all kinds of things, but that doesn’t mean they can use a feature sensibly more than once. Besides, there are different kinds of beginners. Some are very quick but many need lots and lots of practice with basics.
05:56:23 <osa1> I found -fprint-potential-instances but I don't think it's working. maybe a bug
05:57:14 <ertes> well, there is a recurring theme: beginners learn all the basics, while swiftly skipping over details like proper handling of strictness, because teachers think they are "too difficult" or "unimportant for beginners"…  those same beginners end up not being able to write any real programs without repeatedly running into these issues and being unable to solve them on their own
05:57:29 <ertes> it's a mistake to swipe this under the rug
05:57:35 <sproingie> -fprint-potential-instances is the only one i know of.  :i SomeClass will show all of them afaik
05:58:07 <EvanR> not saying its unimportant, but saying its not what id brag about as a language strength
05:58:18 <cocreature> also you can easily end up in the wrong complexity class when it comes to memory usage if you don’t pay attention to this
05:58:19 <sproingie> it's also a mistake to pull out the rug
05:58:42 <ertes> it's not a strength, but it is an inherent feature of haskell that needs to be explained – and it needs to be explained early
05:59:05 <sproingie> early and clearly.  the latter usually fails.
06:00:00 <sproingie> the language does need more and better teachers, sure
06:01:07 <sproingie> right now this channel's the best resource.  takes patience tho, the genius of IRC is more an emergent property than inherent
06:01:59 <capisce> https://en.wikipedia.org/wiki/Gotcha_(programming)
06:02:15 <capisce> "In programming, a gotcha is a valid construct in a system, program or programming language that works as documented but is counter-intuitive and almost invites mistakes because it is both easy to invoke and unexpected or unreasonable in its outcome."
06:06:01 <lyxia> KingBuzzo: well it is the length of the already constructed part. You can also use generate and define the vector recursively
06:06:22 <sproingie> haskell steers away from whole classes of gotchas.  purity has its advantages.  there's tradeoffs, of course.
06:06:27 <KingBuzzo> that's what I figured. Thanks!
06:09:03 <sproingie> a "teaching subset" of haskell might be worth considering.  then again, perhaps that's what Elm is.
06:09:51 <EvanR> no
06:10:15 <sproingie> i know, not a great subset
06:10:16 <EvanR> haskell is the teaching subset
06:10:46 <sproingie> Prelude used to be a lot simpler.  not saying better, but simpler for sure.
06:10:49 <ertes> sproingie: based on all the workshops i ran i don't see value in teaching a beginner subset of haskell
06:11:11 <GeorgeEdward> I've never had the opportunity of taking a haskell course
06:12:34 <sproingie> ertes: yeah i'm actually a bit skeptical about subsetting languages.  scala tried that, it went nowhere.  i'm willing to be surprised tho.
06:12:57 <ertes> under the premise that i expect people to actually use haskell for real stuff
06:12:59 <sproingie> different language entirely is probably the better way to do gradualism
06:13:15 <EvanR> that seems like a giant waste of work
06:13:20 <ertes> you won't be doing that, unless you understand the language as well as some of the common extensions
06:13:22 <EvanR> to set up something that cant do as much
06:13:48 <ertes> well, remember helium?
06:13:50 <sproingie> naw.  i actually do believe in "teaching languages", they specifically shouldn't be industrial-strength "real world" languages
06:14:03 <sproingie> they teach java in schools.  now schools graduate people who can only think in java
06:14:13 <ertes> it was a haskell-like language that dispensed with type classes in order to be simpler to learn
06:14:18 <EvanR> imagine a "teaching" version of java
06:14:23 <EvanR> be horrified
06:14:25 <sproingie> it existed, it was called BlueJ
06:14:26 <ertes> unfortunately it's useless
06:14:38 <sproingie> BlueJ had some really nice tools.  crappy language tho.
06:14:49 <ertes> it hides one of the main abstraction capabilities of haskell, and you can't do anything real with it
06:14:57 <EvanR> so people graduate only thinking in blueJ, according to this theory
06:15:16 <sproingie> no, they learn in that then transfer their knowledge to another language
06:15:32 <EvanR> well i did that in haskell
06:15:38 <sproingie> learning to make that mapping is the target skill, not learning to grind out code in Blub
06:15:50 <ertes> i think the main mistake here is to make assumptions about beginners
06:16:17 <ertes> in particular the "beginners need support wheels" assumption
06:19:51 <sproingie> well they do need support, whether it's training wheels or people helping catch them
06:24:52 <EvanR> if i iterate through a hashmap and either decide to modify or not modify each value, and possible delete it, is it more efficient to just build a whole new hashmap
06:25:19 <EvanR> or use a list instead entirely
06:25:21 <EvanR> or
06:26:02 <sproingie> if you're iterating, may as well construct a new map.  technically you're doing that on any change.
06:26:37 <pacak> mapMaybeWithKey ?
06:26:40 <EvanR> if during the iteration you only modify/delete 1 item, then its not rebuilding the entire map
06:27:53 <EvanR> mapMaybeWithKey would certainly rebuild everything, it has no way to know you didnt change some part
06:28:35 <EvanR> and i guess a list would be the same way, but its a list so its cheaper to do that
06:28:37 <GeorgeEdward> I'd just use a map tbh, you have to traverse this thing once anyway
06:28:55 <GeorgeEdward> have a look at the implementation of those functions
06:29:39 <sproingie> could carry the map around as state while you iterate i suppose
06:29:53 <EvanR> huh?
06:31:41 <ertes> EvanR: you should do unions and intersections instead
06:31:50 <ertes> if possible
06:32:21 <EvanR> you think that would be faster?
06:32:21 <GeorgeEdward> are you just trying to map a function over the hashmap?
06:32:31 <Squarism> I see my application is taking cpu cycles when i expect no activity at all. Is there some way to see what threads contribute to that cpu utilization?
06:32:55 <ertes> EvanR: if you can preconstruct the changes as a submap efficiently, then yes, likely
06:33:10 <GeorgeEdward> Squarism: try threadscope
06:33:12 <EvanR> iterating over a hashmap, coming up with a collection, probably small, of items to delete or modify. probability is the item does not change
06:33:13 <ertes> EvanR: of course no guarantees…  benchmark if you want to know for sure =)
06:33:38 <EvanR> so reconstructing the thing seems bad in this case
06:33:53 <EvanR> so ertes's suggestion might work
06:34:08 <Squarism> GeorgeEdward, thanks
06:34:47 <GeorgeEdward> there's nothing better than trying both and seeing which is more performant
06:35:05 <EvanR> yeah too lazy
06:35:13 <EvanR> if i pick the wrong one, not a big deal
07:04:06 <ph88_> i have some conduits and it seems one is missing a ResourceT .. so i try to add it in the type signature but that just makes things worse ad the conduits no longer seem to be compatible with each other ..  https://bpaste.net/show/5163654a06ac  what can i do about this ?
07:08:54 <cocreature> ph88_: pretty much the same thing that I explained to you earlier today: don’t write your conduits against conduit transformers but write them against an abstract monad and add the necessary typeclass constraints
07:09:31 <cocreature> (or mmorph your way to glory)
07:10:23 <ph88_> lets keep with the abstract monad
07:10:47 <ph88_> i try   adjustSampleInterval :: (ResourceT s, MonadState StreamState s) => Conduit Double s Double   Expecting one more argument to ‘ResourceT s’
07:11:02 <cocreature> ResourceT is not a typeclass
07:11:17 <cocreature> it’s called MonadResource iirc
07:11:26 <filostrato> what exactly is a Conduit?
07:12:04 <cocreature> ph88_: remember that everytime you use ".|" the conduit on the left and the conduit on the right need to be written on top of the same monad. that’s why you are getting these errors
07:12:08 <mizu_no_oto_work> filostrato: conduit is a library for streams.
07:12:13 <ph88_> filostrato, it's like a unix pipe .. helps with streaming
07:12:39 <ph88_> cocreature, ok that "remember" was the first time i heard that :\
07:12:51 <cocreature> :t (.|)
07:12:52 <lambdabot> error:
07:12:53 <lambdabot>     • Variable not in scope: .|
07:12:53 <lambdabot>     • Perhaps you meant one of these:
07:12:55 <cocreature> gnah
07:13:09 <cocreature> (.|) :: Monad m => ConduitM a b m () -> ConduitM b c m r -> ConduitM a c m r
07:13:21 <cocreature> ph88_: see how the m is the same for both arguments
07:13:28 <cocreature> so you can’t use IO for one and ResourceT IO for the other
07:14:32 <ph88_> ye ok i still have to learn to make such deductions
07:15:18 <cocreature> ph88_: maybe we should take a step back, do you understand why "(1 :: Int) + (2 :: Double)" doesn’t work?
07:15:44 <ph88_> so i was thinking to change the nice conduit in the chain from    doubleToByteString :: Conduit Double IO BSC.ByteString    to  doubleToByteString :: (MonadResource m, MonadIO m) => Conduit Double m BSC.ByteString
07:16:13 <ph88_> cuz Int and Double don't share a typeclass for + ?
07:17:11 <cocreature> if you have a function "a -> a -> a" (like (+)) the fact that both arguments are of type "a" means that they need to have _exactly the same type_
07:17:25 <cocreature> "a" can be arbitrary but it needs to be the same everywhere it appears in the type signature
07:17:46 <cocreature> just like the "m" in the type signature of (.|) can be arbitrary but needs to be the same everywhere it appears in that signature
07:18:11 <ph88_> ok
07:18:27 <cocreature> :t (>>)
07:18:29 <lambdabot> Monad m => m a -> m b -> m b
07:18:42 <cocreature> you also can’t do Just 1 >> putStrLn "hello world"
07:19:37 <ph88_> i think i have more trouble with the process of of debugging this stuff than to understand that a -> a -> a  all a are the same
07:20:28 <cocreature> “couldn’t match x with y” is GHC’s way of telling you, you tried to use x for m and y for m, but x and y are not the same
07:21:37 <filostrato> I guess long before inquiring about conduit, I should learn more about the basics, as there are still things about monads I don't understand; is there a separate channel for noobs to ask questions, or would that be here? :P
07:22:08 <ph88_> filostrato, here or #haskell-beginners
07:22:09 <cocreature> filostrato: beginner questions are completely fine here :)
07:25:58 <ph88_> cocreature, on adjustSampleInterval  i have  MonadState StreamState s =>    do i need to put this constraint on all the other functions too ?  i think this is ugly because the other functions don't use state !
07:26:08 <filostrato> I'll join it anyway, but good to know; I'm currently building a website for a friend, to display some of his art, and as I came to a point in the JS client where the backend REST API would be nice to have available, I started considering trying to make it using Servant and something like Persistent; only problem is that I'm still a real beginner at Haskell, but I thought it would be a nice way to learn 
07:26:45 <benzrf> neat
07:26:56 <mekeor> cool
07:27:11 <cocreature> ph88_: no you don’t. however, you do need to put it on the result of applying .| to adjustSampleInterval or something else
07:27:28 <ph88_> filostrato, i just started with a REST API in haskell as well .. i considered some frameworks and then decided on Spock .. the example app of spock was recently updated to new GHC version. And i was asking for an example of static HTML with REST endpoints .. 
07:28:10 <reactormonk[m]> filostrato: given that servant gives you swagger for free, see if you can make use of that for your client side.
07:28:28 <filostrato> hmm, interesting; I was looking at a blog post where someone combined Servant and Persistent, but it's not as up-to-date
07:28:29 <ph88_> cocreature, then i don't understand if i don't put the constraint .. how is it still the same monad  m  ? 
07:28:40 <filostrato> reactor: what kind of swagger? :P
07:29:54 <cobreadmonster> I'm trying to build a parser for a language that doesn't have an EBNF form using Parsec.
07:29:58 <cobreadmonster> Think Markdown.
07:30:28 <cobreadmonster> So I'd like to encounter a "*", and then push a token like BOLD onto a stack held in the parser state.
07:30:41 <benzrf> cobreadmonster: that's not how you use parsec
07:30:50 <cobreadmonster> benzrf: How do I use parsec?
07:31:27 <benzrf> well, you could tokenize by hand first with simple pattern-matching lookahead
07:31:34 <cobreadmonster> Okay.
07:31:36 <benzrf> or you could do something like
07:31:41 <benzrf> uh, idk,
07:31:47 <ph88_> lol
07:31:54 <cobreadmonster> lol
07:32:04 <benzrf> parseBold <|> parseItalic
07:32:17 <Kototama> why does t need to be Traversable in the cataM function whereas it's only a Functor for cata ?
07:32:17 <benzrf> actually don't listen to me, i don't really know the correct way to deal with this in parser combinators
07:33:15 <cobreadmonster> benzrf: Yeah, that was my first approach too.
07:33:24 <cobreadmonster> But what do you do if you have nested things?
07:33:45 <benzrf> well... recursive definitions, of course
07:34:04 <cobreadmonster> So for instance "this is *some +text as+ an +example* to illustrate+"
07:34:17 <cobreadmonster> That's perfectly valid Markdown.
07:34:25 <cobreadmonster> But something that assumes things are nested would break down.
07:34:28 <lyxia> Kototama: because cataM is effectful, so the order in which you compose actions matters, and that order is determined by Traversable
07:35:05 <cobreadmonster> benzrf: any other ideas?
07:35:12 <Kototama> lyxia: what does cataM brings that traversable does not?
07:35:20 <cobreadmonster> The explicit stack is ugly af but there's really no cleaner way to do this.
07:35:21 <sproingie> markdown is a wretched awful standard and parsing it fully is not fun
07:35:38 <benzrf> cobreadmonster: i mean, you can certainly use a stack
07:35:45 <benzrf> but in that case don't bother with parsec!
07:35:52 <sproingie> but there's quite a few markdown parsers in parsec that will show how it's done
07:36:06 <cobreadmonster> benzrf: Parsec does a lot of the tokenizing and shit for me.
07:36:10 <cobreadmonster> sproingie: Really? Any links?
07:36:41 <sproingie> just googled "markdown parsec".  i'm seeing a couple so far.
07:37:42 <c_wraith> I mean, isn't pandoc the ideal?
07:37:52 <c_wraith> though the real problem is that markdown isn't a spec
07:37:54 <cobreadmonster> sproingie: Okay, fantastic thanks!
07:38:08 <cobreadmonster> c_wraith: I'm trying to write my own markdown-y language to convert.
07:38:10 <c_wraith> markdown is a huge family of incompatible-but-slightly-related specs
07:38:11 <lyxia> Kototama: folds the Fix t structure, traverse can only traverse a (t a).
07:38:11 <sproingie> pandoc is old, its parser might be using a similarly old parsec API
07:38:18 <cobreadmonster> Also, this is a very instructive exercise.
07:38:33 <sproingie> c_wraith: there is an actual spec for markdown.  go read it sometime if you're into the horror genre.
07:38:42 <cobreadmonster> sproingie: Where?!
07:38:44 <c_wraith> sproingie: sure, but no one implements it
07:39:02 <sproingie> of course not.  reading the spec should instantly demonstrate why,
07:39:24 <sproingie> cobreadmonster: again i use the googlez: commonmark.org
07:39:33 <sproingie> well, spec.commonmark.org
07:39:40 <filostrato> latest: http://spec.commonmark.org/0.27/
07:40:26 <ph88_> cocreature, i logically try to apply what i think you were trying to tell me .. but it doesn't make sense to me. First you say that all m need to be the same .. now i find examples that they are not the same but work anyway ?! and also i find examples where they are not compatible but i don't understand why  https://bpaste.net/show/1e3d57143046
07:41:52 <cobreadmonster> Man, is there a Parsec tutorial?
07:42:16 <sproingie> lots.  watch out for old ones.
07:42:42 <cobreadmonster> Yeah.
07:42:51 <cobreadmonster> I found one that uses Parsec 3.1
07:42:58 <cobreadmonster> But it's new enough for my purposes.
07:43:08 <cobreadmonster> Parsec is so fucking awesome, why does ghc use happy?
07:43:13 <sproingie> the ideas still all apply, it's the syntax that changes
07:43:37 <filostrato> does anyone use darcs over git?
07:43:46 <sproingie> a few die-hard holdouts
07:44:20 <c_wraith> I liked the idea of darcs, but the exponential-time bad cases just weren't workable.  and by the time most of them had been worked out, everyone was using git.
07:44:23 <sproingie> i like the idea of darcs, but it was never all that zippy
07:44:29 <Kototama> lyxia: and the difference between cataM and foldable?
07:44:50 <sproingie> (heh, said the same thing)
07:45:14 <c_wraith> I mean, I started using darcs when most people were on CVS and waiting for SVN.
07:45:34 <c_wraith> both of which are terrible.  So anything was an improvement.  But then git came along.
07:45:58 <sproingie> yah, there was some effort to get linux to switch to darcs after the bitkeeper kerfuffle.  but darcs pretty much fell over with it.
07:46:28 <lyxia> Kototama: Foldable does less than Traversable, folding a (t a), whereas Fix t is recursive.
07:46:58 <sproingie> linus was probably never going to accept it ayway
07:48:29 <filostrato> I see; how about xmonad? :P
07:49:02 <Kototama> lyxia: Foldable does not recur?
07:49:10 <sproingie> never took a shine to tiled wms.  i like a blend of tiled and non.
07:49:43 <sproingie> (and being on a mac now, my preference of window managers is kinda academic)
07:52:19 <lyxia> Kototama: Fix t is isomorphic to something that would look like   t (t (t ...))   fold/traverse are only able to look at one layer, whereas cataM can collapse them all.
07:53:29 <sproingie> it's ironic that the thing that frequently breaks my brain is called "Fix"
07:54:34 <cobreadmonster> c_wraith: Can I PM?
07:55:05 <mizu_no_oto_work> filostrato: My current machine's a mac, but on Linux I prefer xmonad.
07:55:42 <Kototama> lyxia: excuse me to ask further, but why can't foldMap recurse like cataM?
07:56:46 <mizu_no_oto_work> filostrato: Probably, the biggest problem with darcs is that github won.  Regardless of the technical merits of various SCMs (pijul looks pretty cool), if you're on github you're much more likely to get issues filed or pull requests.
07:57:01 <lyxia> Kototama: because it doesn't have the right type
07:58:03 <filostrato> I was considering trying out xmonad (I'm on Arch), but I think I'll stick with this web project for learning more Haskell for now
07:58:16 <filostrato> and yeah, maybe it would be more popular with a DarcsHub
08:00:04 <mizu_no_oto_work> filostrato: https://hub.darcs.net/
08:00:54 <mizu_no_oto_work> The issue is that darcshub is even less popular than bitbucket, and you're not going to get anywhere near as many pull reqs on bitbucket.
08:01:22 <filostrato> right
08:01:35 <filostrato> what exactly just happened, node split?
08:02:55 <lyxia> Kototama: it doesn't make sense for foldMap and other foldable functions to recurse like cataM does because it only takes a value of type "t a" for a parametric a. You need a type like Fix to be able to express that recursive structure in the first place.
08:03:37 <Cooler> lambdabot hey
08:03:48 <Cooler> lambdabot, hello?
08:04:01 <Cooler> lambdabot, \x = x + 2
08:04:09 <Cooler> \x = x + 2
08:04:17 <abbas> hey every body , i have simple function but i cant understand why it give error . CODE AND ERROR:  https://paste.ubuntu.com/24454556/
08:04:19 <Cooler> how do you activate it?
08:04:21 <lyxia> > "spamming is bad"
08:04:24 <lambdabot>  "spamming is bad"
08:04:51 <lyxia> Cooler: you can also talk to lambdabot in private
08:05:09 <Clint> abbas: what is the type of (:) ?
08:06:12 <sproingie> you're trying to cons a list onto the head of a list
08:06:14 <c_wraith> cobreadmonster, sure, I suppose 
08:06:30 <sproingie> you may be looking for ++ instead of :
08:08:29 <Kototama> lyxia: what about something like http://stackoverflow.com/questions/23319683/foldr-foldl-for-free-when-tree-is-implementing-foldable-foldmap
08:08:40 <Kototama> it is recursive
08:11:00 <Cooler> > (++ "1") . concat . (take 24) . repeat $ "1+"
08:11:02 <lambdabot>  "1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1"
08:11:08 <Cooler> is there a better way to do this?
08:11:12 <Cooler> show 25 1s
08:11:20 <Jayhet> hello, can anybody help me in a function that I can't resolve?
08:11:51 <sproingie> Cooler: there are infinity ways to golf that.  "better" is something you ask for code that's actually useful.
08:12:12 <filostrato> Jayhet: I've learnt over the years that it's often better to just ask, than asking to ask ;)
08:13:54 <Jayhet> first time, okay, the function is: " f::(a,b) -> c -> (a -> b -> c)" and below is "f h _________" what is "f h = ___" ?
08:14:49 <lyxia> Kototama: It is, but in a different way.
08:15:02 <mniip> Cooler, (take N . repeat) = replicate N
08:15:08 <lyxia> Kototama: the recursion I'm talking about would in this case correspond to trees within a tree
08:15:51 <Kototama> i see. So the recursion of Foldable is nonetheless necessary for cataM
08:16:01 <Kototama> whereas functor is enough for cata
08:16:02 <ClaudiusMaximus> Cooler: Data.List.intercalate may be useful
08:17:07 <Kototama> but why use cataM over foldMap?
08:17:51 <Jayhet> first time, okay, the function is: " f::(a,b) -> c -> (a -> b -> c)" and below is "f h _________" what is "f h = ___" ?
08:18:25 <cocreature> ph88_: I don’t know what exactly you’re doing, but 1 and 2 are definitely not compatible
08:19:39 <sproingie> Jayhet: sounds like you're being asked to fill in the blank.
08:19:40 <eschnett> Jayhet: This is a strange function. Are you sure you got your parentheses correct?
08:19:48 <sproingie> eschnett: it's curry
08:20:13 <sproingie> except hm, curry would need extra parens 
08:20:33 <Jayhet> yes, i know thats curry, but I can't fill the blank
08:21:29 <sproingie> :t curry
08:21:30 <lambdabot> ((a, b) -> c) -> a -> b -> c
08:21:44 <sproingie> yeah the parens are all wonky on f
08:24:16 <Jayhet> are you sure? my professor gave that question, and I have looked anywere and nothing... I have been trying this for 2 days
08:25:40 <eschnett> Jayhet: Yes, we are sure.
08:25:48 <Jayhet> unless you tell me that function "f :: (a,b) -> c -> (a -> b -> c)" is impossible
08:26:16 <eschnett> Jayhet: This function is either impossible or trivial.
08:26:38 <eschnett> Jayhet: The other one (see lambdabot’s answer) is quite fundamental, and it seems you are asked to implement it.
08:27:02 <cocreature> it’s as trivial as "a -> b -> (c -> b)"
08:27:11 <filostrato> oh, can anyone use lambdabot?
08:27:17 <cocreature> filostrato: sure
08:27:25 <filostrato> :t map
08:27:27 <lambdabot> (a -> b) -> [a] -> [b]
08:27:31 <filostrato> nice
08:27:33 <cocreature> filostrato: but if you want to play arount with it, stick to private messages to avoid spamming the channel
08:27:43 <sproingie> it's possible, it just isn't necessarily interesting.  i'd ask your prof or TA for clarification
08:27:43 <filostrato> kk, I won't, hehe
08:27:46 <eschnett> … as in “/msg lambdabot”…
08:28:11 <sproingie> if it's just a typo in parentheses, your prof would be the only one to know for sure
08:28:29 <Kototama> lyxia: there is a pretty good explanation there http://stackoverflow.com/questions/27769688/what-is-the-most-general-way-to-compute-the-depth-of-a-tree-with-something-like/27783737#27783737
08:29:14 <Jayhet> okay guys, i'll look around, thank you all
08:30:55 <glguy> ?djinn (a,b) -> c -> (a -> b -> c)
08:30:55 <lambdabot> f _ a _ _ = a
08:30:56 <sproingie> add the parens yourself and implement curry and your prof might like your initiative.  or might robotically mark it wrong.
08:31:19 <sproingie> that's why you go find your prof in office hours
08:31:54 <cocreature> or just send them an email :)
08:32:03 <sproingie> or in this newfangled century, that
08:32:34 <cocreature> welcome to the future
08:32:39 <sproingie> i had to send 'em a wax tablet and I LIKED IT
08:33:17 <dequbed> Proof over avian carrier? :P
08:33:25 <filostrato> "At the moment one starts acquiring a skill, one is completely incompetent, which triggers an initial period of frustration and being stymied while waiting for someone, like an instructor, to spoon-feed process steps to the acquirer (or else, as Dreyfus and Dreyfus put it, they “like a baby, pick it up by imitation and floundering”)."
08:33:33 <filostrato> me in Haskell right now ;D
08:33:45 <ReinH> everyone in Haskell at some point
08:33:48 <filostrato> "After a relatively short phase of being a complete initiate, however, one reaches a point where the skill acquisition becomes possible as a solo activity via practice, and the renewed and invigorated acquirer begins to improve quite rapidly as he or she picks “low hanging fruit.”"
08:33:56 <filostrato> hopefully me in Haskell in a few months
08:40:52 <Kototama> filostrato: there is no low hanging fruits, only low bounded fruitomorphisms
09:05:13 <Guest92555> is there some setting I can use to make haskell escape non-printable chars in strings/bytestrings as hexadecimal?
09:06:15 <lyxia> don't use show
09:06:46 <Guest92555> it's not practical for me translating stuff like \GS \SOH \ETX because they aren't even fixed length, for example, I see \GSE\ETX
09:06:50 <Guest92555> it's plain tricky
09:07:00 <Guest92555> sometimes it's 3 letters, sometimes 2
09:07:02 <Guest92555> sucks
09:07:43 <Guest92555> yeah, will have to make my own printer
09:08:56 <ExpHP> I have a Get, how do I decode a bytestring with it
09:09:14 <Kototama> is it possible to implement Foldable on something like data Tree a = Leaf Int | Node (Tree a) (Tree a) ? I guess not
09:09:19 <ExpHP> or do I have to make some dummy wrapper type just to have a Binary instance
09:09:50 <cocreature> :t runGet
09:09:52 <lambdabot> error: Variable not in scope: runGet
09:09:59 <cocreature> lambdabot does really not like me
09:10:06 <cocreature> ExpHP: anyway, that’s what you’re looking for
09:10:10 <ExpHP> Data.Binary.Get is opaque
09:10:23 <cocreature> no?
09:10:40 <ExpHP> also its record field is unGet
09:10:45 <ExpHP> or am I in the twilight zone?
09:10:57 <cocreature> I really mean runGet
09:11:02 <cocreature> it’s exposed from Data.Binary.Get
09:11:13 <cocreature> so "import Data.Binary.Get" and use runGet
09:11:18 <ExpHP> wow, I was on some very old docs
09:12:16 <ExpHP> thanks
09:12:44 <lyxia> Kototama: the fold will simply do nothing
09:13:12 <lyxia> Kototama: try DeriveFoldable
09:25:55 <ExpHP> sigh... lazy bytestring to strict bytestring?
09:27:09 <ExpHP> haddock docs need a really good integrated search feature like rustdoc has
09:28:02 <ExpHP> especially with how haskell's module system forces some modules to be really ridiculously smal
09:29:13 <davean> ExpHP: which modules are you thinking of specificly when you think they're really rediculously small?
09:29:43 <davean> And there are a bunch of search systems for them
09:30:03 <ExpHP> davean Some.Module.Types, which inevitably contains some extremely important documentation for anyone using Some.Module
09:30:08 <davean> Like https://www.haskell.org/hoogle/ specificly searches for signatures, like you're asking about above
09:30:27 <ExpHP> the only hoogle only seems to cover a small portion of hackage
09:31:13 <ExpHP> and then on my local machine I run into trouble with stack versions and large databaases
09:31:29 <ExpHP> s/only hoogle/online hoogle/
09:31:45 <davean> Ick, yah, I don't like anything to do with stack personally
09:31:51 <davean> hoogle works fine with cabal though
09:32:36 <davean> I've never seen any issues wiht hoogle and size, and I've installed basicly all of hackage
09:32:48 <ExpHP> davean I used cabal sandboxes for a year and could never stand to sit through the repeated rebuilds of all of hackage
09:33:12 <ExpHP> of course, there's new-build, but I had to roll my own scripts for that and 90% of editors just assume it doesn't exist
09:33:33 <ExpHP> when I switched to stack it was like an angel choir
09:34:37 <ExpHP> ...except for using hoogle
09:34:55 <ExpHP> @hoogle Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString
09:34:56 <lambdabot> Data.ByteString tail :: ByteString -> ByteString
09:34:56 <lambdabot> Data.ByteString init :: ByteString -> ByteString
09:34:56 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
09:35:20 <ExpHP> oh of course, there's also the fact that it doesn't give a shit about anything beyond the unqualified name
09:35:31 <davean> Its toStrict BTW
09:37:03 <glguy> ExpHP: fwiw when you resort to whining, "sigh..." complaints, etc, you drive away people who might have otherwise volunteered to help
09:37:21 <ExpHP> no wonder, all the conversion functions are in Data.Bytestring.Lazy
09:37:25 <davean> Why do you think I didn't just answer?
09:38:41 <ExpHP> thanks
09:44:50 <ph88_> cocreature, you were right i made a mistake, this is the updated paste https://bpaste.net/show/262ab3b65dea
09:45:02 <orion> https://github.com/haskell-crypto/cryptonite/pull/156 <-- What does "pin status" mean here?
09:46:10 <davean> orion: I'd assume pinned memmory
09:46:22 <davean> But I'd have to review the patch to be sure
09:55:49 <ExpHP> glguy: I'm just frustrated.  Haskell presents me with difficulties in finding information that I have not had to face in any other language.  Given an object of some arbitrary type, it is surprisingly difficult to find out what one can do with said object
09:56:06 <ExpHP> typeclasses, as wonderful as they are, often hide key pieces of a type's API
09:56:22 <glguy> I'm just warning you that taking that frustration out on the channel is a good way to get less help
09:56:25 <ExpHP> and I cannot rely on autocomplete due to the lack of name-directed method resolution
09:57:06 <davean> ExpHP: I find your issues divergent, perhaps you're going about it wrong
09:57:20 <davean> but yes
09:57:36 <davean> you'd have gotten far more help from me if you'd not made an ass of yourself. I'd have just told you
09:57:44 <ExpHP> the "sigh" is because I feel like an asshole repeatedly asking "how do I get from a -> b" questions on here
09:58:05 <ReinH> It's not the questions you're asking so much as your method of asking them.
09:58:35 <ReinH> We get a large number of very basic questions every day, clearly we're pretty ok with answering basic questions.
09:59:18 <ReinH> But most people don't pair them with a diatribe on why the language we like is terrible.
10:00:15 <ExpHP> hey, it's my favorite language, too
10:00:27 <sproingie> it's beautiful and terrible
10:00:51 <ph88_> i have some basic questions in here https://bpaste.net/show/262ab3b65dea .. i think they are basic anywayz
10:01:55 <davean> ph88_: have you tried a lift variant?
10:02:04 <ph88_> what's a lift variant ?
10:02:13 <davean> Do you know what lift is?
10:02:29 <ph88_> seen liftIO to access IO from other monad
10:02:35 <cocreature> ph88_: the type signature you’re claiming for the combination of 2 and 3 is incorrect I think
10:02:44 <ph88_> ok let me double check that
10:02:55 <cocreature> 2 and 3 should fail
10:03:02 <davean> Hum, ok, so I'm not sure I'm ready to do the transformers speal ATM
10:03:23 <davean> ph88_: http://hackage.haskell.org/package/conduit-1.2.10/docs/Data-Conduit.html#v:transPipe
10:03:30 <ph88_> cocreature, ghci infers that type
10:03:48 <ReinH> MonadIO m => m unifies with ResourceT IO iff ResourceT IO is an instance of MonadIO.
10:03:48 <cocreature> ph88_: then parseAndSelect has a different signature than the one you’re claiming it has
10:04:07 <cocreature> ah you have a different signature below
10:04:10 <cocreature> with that it can work
10:04:12 <ph88_> ah shit ye ... let me update the paste again -___-
10:04:14 <cocreature> with the one at the top it can’t
10:04:18 <ph88_> ye
10:04:42 <ph88_> i updated the paste for the mistake on combination of 1 and 2 and then forgot to update paste of combination of 2 and 3
10:05:28 <halogenandtoast> If anyone has Yesod experience (or not), could someone help me understand this error and perhaps point me in a direction on how to fix it? I can't seem to get the types to line up: https://gist.github.com/halogenandtoast/f17c35acd446f380b32aea1842c2b931
10:06:06 <davean> ph88_: So, clearly you've worked with monad transformers?
10:07:48 <ph88_> here is updated paste https://bpaste.net/show/6e4ce11f213d
10:09:49 <ReinH> So what's the question now? Why does ResourceT IO unify with MonadIO m => m?
10:10:08 <cocreature> ph88_: so do you understand the things above line 50?
10:10:20 <ph88_> davean, i barely touched monad transformers .. but yes i've "worked" with them
10:10:45 <davean> Right, so not exactly about your problem but in 1, you get "Couldn't match type ‘IO’ with ‘ResourceT IO’"
10:10:56 <davean> so "lift" is the m a -> t m a transfomration
10:11:09 <cocreature> you can’t use lift directly here
10:11:16 <davean> cocreature: I already linked what you can use
10:11:28 <davean> cocreature: I'm explaining how it works
10:11:31 <ph88_> cocreature, yes i understand the errors now above line 50
10:11:31 <cocreature> ah sry
10:11:53 <halogenandtoast> In my code I've tried both `redirect` and `redirectUltDest` both provide the same issue.
10:12:02 <mivael> hello all!  Could anyone please point me out to a minimalistic example of using Data.Attoparsec.ByteString.Lazy for simplest cases?
10:12:03 <mivael> (Like, for example, reading from stdin a large number of decimal integers separated by spaces/newlines and feeding them to a pure function as a lazy list for actual calculations.)
10:12:36 <cocreature> ph88_: ResourceT IO and m are compatible because GHC can just set m = ResourceT IO. it also needs to satisfy a constraint but there is an instance of MonadIO for "ResourceT IO"
10:13:16 <cocreature> in the second case GHC tries to set s = IO, but there is no instance of MonadState StreamState for IO
10:13:18 <cocreature> so that fails
10:13:33 <ph88_> davean, can i do without hoist and use more abstract monads only? (from what i understand more abstract monads to be is   => m  with more constraints put on it)
10:13:36 <davean> ph88_: Theres a less common ability to take t m a -> t n a, when you have an m a -> n a, in this case thats transPipe, and of course lift is the m a -> n a
10:13:46 <davean> ph88_: generally yes
10:13:59 <davean> but you're functions will have to support it also, which either means a lot of type classes or lifts
10:15:45 <ph88_> what do you mean with ability "t m a -> t n a" ?   how can you loose monad m here? where it go?
10:15:53 <ph88_> what's t even ?
10:16:53 <davean> t is the transformer
10:17:03 <davean> and you ddon't "lose" the m, you transform it
10:17:19 <ph88_> what does that mean transform ?
10:17:24 <davean> in the case of lift you actually get "t m a -> t (g m) a"
10:17:57 <davean> Well, some monads can be rewriten into other ones
10:18:07 <ph88_> is t a typeclass that has instances for m and n ?
10:18:17 <davean> 've failed :(
10:18:21 <ph88_> :(
10:19:15 <davean> t is a type variable, you have to actually fill it in with something specific at some point
10:19:26 <ph88_> ah ok
10:20:12 <ph88_> how do you know which monads can be rewritten into which other monads ?
10:20:16 <davean> in your case its Producer or ConduitM or something
10:20:21 <davean> well, you have functiosn that do it
10:20:27 <davean> for example, lift
10:20:29 <davean> or runReaderT
10:20:38 <ph88_> ah ok
10:20:50 <davean> tranPipe just *takes* one of those
10:21:04 <davean> and knows how to move its stuff over based on that
10:21:21 <ph88_> transPipe takes on of what ?
10:21:42 <davean> transPipe :: Monad m => (forall a. m a -> n a) -> ConduitM i o m r -> ConduitM i o n r
10:21:55 <ph88_> it takes a function lift ?
10:22:08 <davean> Well, lift is one option, there are other options
10:22:12 <ph88_> oh transPipe stands for transform pipe ?
10:22:13 <davean> you provide the appropriate function
10:22:15 <ph88_> ok
10:22:17 <davean> in your case, yes, lift
10:22:27 <davean> but, there are other cases
10:22:44 <davean> like one could have a ConduitM BSC.ByteString Double (ReaderT r IO) ()
10:22:50 <davean> and want an ConduitM BSC.ByteString Double IO ()
10:23:03 <davean> We could push runReaderT down to convert in the other direction
10:23:21 <ph88_> oh that's nice
10:23:29 <ph88_> what did you mean before with "which either means a lot of type classes or lifts" ?  where does transPipe fit into this? the "lifts" option ?
10:23:56 <davean> That fits in avoiding transPipe and just making your function more generic
10:24:15 <davean> transPipe is a way of taking two specific things that are different and making them match
10:24:19 <ph88_> so i have 3 options, lot of type classes, lifts or transPipe .. is that right ?
10:24:29 <davean> lift and type classes are ways of taking something specific and something generic and making them match
10:24:36 <davean> Yah
10:25:00 <ph88_> can you tell a little bit about the other two options .. i think i have get the basics of transPipe now
10:25:01 <davean> so, the type class version would be removing the IO and making it MonadIO m
10:25:19 <ph88_> ye i think that was the path i was on at the moment ..
10:25:20 <davean> this is the one I'd generally recomend
10:25:24 <ph88_> ya
10:25:40 <davean> Though I fell understanding the transPipe version is more important for your understanding of whats actually happening
10:25:51 <ph88_> ye ok
10:25:57 * mivael is lost in Attoparsec docs...
10:25:59 <davean> the lift, well, thats more constrained
10:26:14 <davean> lift just takes some m a and makes it into a t m a for any given t
10:26:23 <davean> with is a less general form of what liftIO does
10:26:26 <ph88_> using typeclasses would mean that all 5 functions would need to be of type signatures   (foo, bar) => m   without any concrete type for m, is that right ?
10:26:36 <davean> not quite
10:26:44 <davean> you can have some concret ms
10:26:50 <davean> just not more then one really
10:27:06 <davean> and some might be something like ResourceT m
10:27:17 <ph88_> but that one needs to have an instance for all the constraints given in the other functions ?
10:27:21 <davean> where we know we're in something transformed by ResourceT but not what it is specificly
10:27:38 <davean> No, functions only need to knwo what THEY require
10:28:04 <ph88_> i mean for it to work with you chain them with  .|
10:28:32 <ph88_> when you have  a .| b .| c    and b has a concrete type, i think this type needs instances of the constraints given on the types in a and c
10:28:36 <mivael> Does anyone know how to parse a decimal integer using attoparsec?
10:28:45 <ph88_> mivael, ya i do
10:29:09 <mivael> ph88_, Can you please give me a hint?  :)
10:29:11 <ph88_> https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-ByteString-Char8.html#v:double
10:29:18 <ph88_> https://hackage.haskell.org/package/attoparsec-0.13.1.0/docs/Data-Attoparsec-Text.html#v:double
10:29:31 <davean> ph88_: yes, the concret types need to be instances
10:29:48 <ph88_> mivael, oh i gave the wrong links .. but just scroll up for decimal
10:29:49 <mivael> thanks!   I did not look into Char8 and Text (I thought somehow they are not related)
10:30:35 <davean> ph88_: so maybe you understand a little more haskell now, or maybe I'm a massive failure as a teacher. Sadly my bet is on the later ATM
10:30:39 <davean> but I hope it helped
10:30:49 <ph88_> ye it helps
10:31:10 <ph88_> davean, for my problem when i choose to solve it with typeclasses and i can have 1 function with a concrete type .. which type should i choose ?
10:31:22 <ph88_> thanks very much
10:31:27 <davean> ph88_: probably ResourceT m
10:31:35 <davean> and then in the end ResourceT IO, most likely
10:31:59 <ph88_> then i will get that IO does not implement MonadState MyState IO   i think
10:32:27 <davean> ph88_: well, ResourceT m doesn't say IO then
10:32:43 <davean> ResourceT m could be ResourceT (StateT MyState IO)
10:32:45 <ph88_> oh it's ResourceT which has to implement MonadState ?
10:32:59 <ph88_> aah ok
10:33:34 <ph88_> type parameters combined with typeclass constraints are still confusing
10:33:47 <davean> why is that?
10:34:04 <davean> So you can have "MonadState MyState m => ResourceT m"
10:34:06 <ph88_> partly because of the syntax
10:34:16 <davean> Hum, what is it about the syntax?
10:34:25 <davean> would it be better with explite foralls for you?
10:34:31 <ph88_> no
10:34:58 <davean> "Forall m such that m is an instance of MonadState MyState we work with ResourceT of said m"
10:35:12 <davean> forall m. MonadState MyState m => ResourceT m
10:35:36 <ph88_> if you have a  ResourceT (MonadState MyState m)  .. you don't really notice is that you are using a constraint here wrongly ... they both are a normal word which starts with a capital
10:36:11 <davean> No
10:36:19 <davean> MonadState is a typeclass constraint, not a type
10:36:20 <ph88_> so i found that there is some kind of correspondence between  MonadState and State  .. but there is no hint in my editor that they belong together or i can interchange them (sometimes)
10:36:36 <davean> You can never interchange them
10:36:38 <cocreature> davean: yeah but I think ph88_’s point is that you can’t see that syntactically
10:36:42 <cocreature> which is a valid point
10:36:49 <davean> sure
10:37:15 <ph88_> you can change around    MonadState x m => m    with   State x   sometimes  
10:38:07 <ph88_> i dunno, it just seems there are a lot of options to do stuff .. i think the design space for the language is pretty big ... so to figure out how all the combinations work together is not straightforward
10:38:16 <ph88_> but your explanation helped a lot already
10:38:17 <davean> ... sorta, you're not changing around there
10:38:23 <davean> you'e specifyin WHICH MonadState to use
10:38:33 <davean> State and StateT are specific MonadStates
10:38:43 <davean> I'm glad it helped a little, I was worried I'd lost you :)
10:38:54 <nitrix> namely, Monad m => MonadState s (StateT s m)
10:39:17 <nitrix> and State should be a type alias of StateT
10:39:28 <ph88_> ye sometimes i get the higher level concepts even though i don't understand the lower level concepts which they are based on o_O
10:40:13 <nitrix> One would argue it's the other way around. You understand some applications of these concepts on their lower level, but don't recognise the generalization for them on a higher level of abstraction.
10:40:20 <nitrix> Abstraction goes upwards.
10:40:30 <nitrix> At least, I've always seen it described this way.
10:42:22 <ph88_> dunno ..
10:42:36 <ph88_> this comes to mind though "It was clear, from the questions students asked me in office hours, that those who were underperforming weren’t struggling with the fundamental concepts in the class, but with algebra: the problems were caused by not having an intuitive understanding of, for example, the difference between f(x+a) and f(x)+a." https://danluu.com/teach-debugging/
10:42:42 <ph88_> have to go
10:42:46 <ph88_> thanks again davean & cocreature 
10:42:47 <ph88_> bye bye
10:44:37 <davean> ironically thats almost litterly the monad transformers issue :)
10:45:25 <sproingie> i had a typical US math education too.  in other words, i grew up hating math.
10:45:34 <sproingie> now i find i actually love math, i just hate numbers.
10:46:41 <davean> numbers are uselessly specific
10:46:49 <koala_man> they don't teach math in the US. they teach calculation
10:47:16 <koala_man> at least up until common core
10:50:57 <fragamus> https://gist.github.com/fragamus/56e570e2df276de569c68d018d54aaae
10:55:01 <fragamus> can anyone tell me why i is always zero in that gist
10:56:17 <monochrom> Is 0 printed just once? Is 0 printed multiple times?
10:56:27 <fragamus> multiple times
10:56:41 <fragamus> wierd huh
10:56:51 <monochrom> Yeah, I don't know why.
10:57:21 <monochrom> And "TEN" never happened, right?
10:57:58 <fragamus> it always happens
10:57:58 <monochrom> Actually "TEN" should happen once, first iteration, at least.
10:58:04 <monochrom> Ah OK.
10:58:26 <fragamus> 0 `mod` 10 is always 0
10:59:07 <fragamus> weird maybe i can simplify the code and the bug will pop out
10:59:16 <monochrom> I am even comparing all the "filePathPipe2" occurences at almost pixel level to look for typos :)
11:01:28 <monochrom> At present the only plausible conjecture I have is "maybe filePathPipe 1 dies before getting to print 1; all the printings of 0 come from multiple calls to filePathPipe from the outside".
11:01:29 <fragamus> oooh I moved the  liftIO $ putStrLn $ show i     to be the first thing in the do block
11:01:42 <fragamus> now it says 1 but also says TEN
11:02:31 <fragamus> seems to back your theory
11:02:34 <tabaqui> @let a = 1000 :: PortNumber
11:02:36 <lambdabot>  .L.hs:163:13: error:
11:02:36 <lambdabot>      Not in scope: type constructor or class ‘PortNumber’
11:02:43 <tabaqui> hm
11:02:53 <tabaqui> can anyone test this code?
11:02:58 <tabaqui> a = 1000 :: PortNumber
11:03:00 <tabaqui> a < 2000
11:03:07 <tabaqui> in my ghc it returns False
11:04:01 <tabaqui> it's strange, because PortNumber is deriving Ord from Word16
11:04:09 <tabaqui> and the same code with Word16 works fine
11:04:23 <Tuplanolla> Which version of `network`, tabaqui?
11:04:35 <Tuplanolla> I think they changed the type quite recently.
11:05:09 <glebec> howdy y'all
11:05:16 <geekosaur> tabaqui, be very careful with PortNumber
11:05:44 <monochrom> Oh! PortNumber \xabcd would become \xcdab
11:05:45 <geekosaur> network has a tendency to byteswap values to network byte order
11:05:53 <geekosaur> or, what monochrom just said
11:06:02 <Squarism> is there a nicer way of filtering "Right"'s from let k :: [Either String Int] ; k = [Right 1,Left "a"] ? My best is this clumsy one : concatMap (\x -> case x of ; Right r ->  [r] ; o -> [])  k
11:06:02 <ClaudiusMaximus> i think that fromInteger for PortNumber does some byte swapping for network byte order maybe?  which would make deriving Ord a bug
11:06:02 <tabaqui> Tuplanolla: 2.6.3.1
11:06:43 <Squarism> oh
11:06:45 <Squarism> "rights"
11:07:19 <monochrom> You probably want to "toInteger a < 2000" for higher reliability
11:08:05 <monochrom> or fromIntegral and choose your type if you think Integer is overkill.
11:08:07 <tabaqui> monochrom: looks fine, so I'll do it
11:08:14 <tabaqui> thanks
11:08:23 <Tuplanolla> It has an `Ord` instance, so there should be no problem there.
11:08:31 <fragamus> ok thanks monochrom i have to go to lunch but ill try that later 
11:09:02 <tabaqui> ClaudiusMaximus: Data.Either.rights
11:09:24 <tabaqui> ClaudiusMaximus: sorry, wrong recepient
11:10:07 <filostrato> so, who wants to take a crack at giving me a good intuitive understanding of (>>) and (>>=)?
11:10:21 <Tuplanolla> This looks like a bug to me, tabaqui.
11:11:02 <monochrom> Well, the rest of network's code is consistent with that, so it is arguably a "feature" or at least a design decision.
11:11:25 <geekosaur> it's a fairly well known gotcha with network
11:11:25 <Tuplanolla> The source code says `newtype PortNumber = PortNum Word16 deriving (Eq, Ord, Typeable)`, yet `(1000 :: PortNumber) < (2000 :: PortNumber)` is `False`.
11:11:38 <ReinH> filostrato: what do you already know?
11:11:45 <davean> Tuplanolla: so? It has an Ord, it just doesn't have the Ord you expect
11:11:48 <monochrom> But you've got to look at its Num instance
11:11:52 <geekosaur> ^
11:11:53 <davean> Tuplanolla: Its a perfectly valid ordering
11:12:02 <ReinH> Tuplanolla: what does the fromInteger do?
11:12:06 <monochrom> What does fromInteger do?
11:12:20 <ReinH> monochrom: I got u
11:12:24 <Tuplanolla> Oh, I see now.
11:12:53 <davean> ReinH: this is why I didn't like your implicite Ord instance dependancy last night
11:12:56 <mivael> Now I know how to parse one integer  :)
11:12:58 <mivael> A8.parseOnly (A8.decimal <* A8.endOfInput) $ B8.pack "123"  -- Data.ByteString.Char8 as B8, Data.Attoparsec.ByteString.Char8 as A8
11:13:04 <ReinH> davean: yes, it was just clever
11:13:12 <ReinH> clever is bad but also fun
11:13:19 <monochrom> I agree that it's a bad choice. People actually want to test my_port_number > 1024. But apart from that it is a legit choice.
11:13:25 <ReinH> anyway I'm not the one who has to live with the code so YOLO
11:13:33 <davean> ReinH: :(
11:13:51 <davean> I often depend on Ord being an ordering but I generally try avoid depending on WHICH ordering it is
11:14:06 <monochrom> In fact if their Ord instances do the inverse swapping before comparing, you would never know this one little implementation detail.
11:14:12 <mivael> Any hints about my next step?  How to combine attoparsec parsers?  How to parse two integers?  N integers?
11:14:27 <dysfun> sepBy?
11:14:29 <ReinH> Arguably, there should be a coherence between whatever fromInteger does and whatever compare does.
11:15:04 <ReinH> i.e. x :: Integer < y :: Integer => x :: PortNumber < y :: PortNumber
11:15:07 <monochrom> Yeah
11:15:12 <mivael> dysfun, thanks
11:15:15 <Sh4rPEYE> Hello. I'm trying to understand this simple function. Well, I know it should be simple, but it just doesn't click to me... How does that work? I tried to work it out with pen and paper, but there is just too much things to keep eye on, for me at least
11:15:17 <Sh4rPEYE> combinations'' 0 _ = [[]]
11:15:28 <Sh4rPEYE> combinations'' n xs = [ y : ys | y:xs' <- tails xs, ys <- combinations'' (n - 1) xs' ]
11:16:07 <Gurkenglas> davean, sounds like a line that I should use to shill for a paper that sounds related from a lecturer I know https://link.springer.com/chapter/10.1007/978-3-642-38536-0_10
11:16:10 <ReinH> > tails [1,2,3,4]
11:16:12 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
11:16:41 <Sh4rPEYE> Yes I know that. But I don't see how that helps me to get the combinations :/
11:16:53 <ReinH> I wasn't suggesting that you didn't
11:16:55 <filostrato> ReinH: well, ok, (>>=) goes by the name bind, and has the type m a -> (a -> m b) -> m b; essentially that means it takes a monadic value, and a function from that value to a monadic value of a different type, and returns a monadic value of that latter type, by collapsing m (m b) to m b I suppose
11:17:18 <ReinH> filostrato: that's correct, at least conceptually
11:17:29 <filostrato> so I kind of get it, but it's the intuitive part I struggle with, I don't really grok it
11:17:31 <ReinH> (often join is written in terms of bind, rather than vice versa, but the two ways of writing it are equivalent)
11:17:56 <ReinH> filostrato: Look at the type types and ask yourself, "what happens to the 'a'"?
11:18:10 <ReinH> :t (>>=)
11:18:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:18:14 <ReinH> :t (>>)
11:18:16 <lambdabot> Monad m => m a -> m b -> m b
11:18:53 <ReinH> s/type types/two types
11:19:16 <sproingie> i usually find the fmap+join (aka flatMap) a lot more intuitive than bind.  kind of depends on the monad tho.
11:19:27 <ReinH> specifically, what is the difference between (a -> m b) and (m b)?
11:19:32 <filostrato> type types?
11:19:41 <ReinH> type types is a typo, I meant "two types"
11:19:47 <filostrato> oh, right,
11:19:50 <mivael> dysfun: thank you much:   A8.parseOnly (((A8.decimal) `A8.sepBy1` (A8.char ' ')) <* A8.endOfInput) $ B8.pack "123 456"
11:20:09 <ReinH> >>=, as you already noted, uses a function a -> m b to produce an m b from an m a
11:20:15 <ReinH> what does >> do to produce an m b?
11:20:28 <filostrato> just m b, seems like it just discards m a
11:20:31 <ReinH> well, there are a couple things it could do
11:20:33 <ReinH> that's one of them
11:20:42 <ReinH> what else could it do?
11:20:50 <dysfun> mivael: there are other things to play with in the Combinators namespace
11:21:00 <ReinH> here's a hint: can you write a function that turns an m b into an a -> m b?
11:21:08 <ReinH> what would that function do with the 'a'?
11:21:29 <filostrato> let me think; I enjoy being taught socratically btw
11:21:37 <ReinH> excellent
11:22:27 <ReinH> f :: Monad m => m b -> a -> m b; f mb a = ???
11:22:35 <sproingie> you can even ignore the 'm' there.  there's only one way to write a -> b -> b
11:22:39 <ReinH> that's true
11:22:44 <ReinH> we can ask djinn
11:22:59 <ReinH> @djinn mb -> a -> mb
11:22:59 <lambdabot> f a _ = a
11:23:16 <ReinH> @. pl djinn mb -> a -> mb
11:23:17 <lambdabot> f = const
11:23:18 <ReinH> it's const
11:23:22 <ReinH> it just throws away the a
11:23:27 <filostrato> heh
11:23:33 <ReinH> so >> is an >>= that throws away the 'a'
11:23:38 <ReinH> but keeps its m context
11:23:41 <filostrato> that's what I said to begin with though, just throw away the m a
11:23:43 <mivael> dysfun, you mean they are compatible with attoparsec?
11:23:45 <ReinH> and combines it with the m b context
11:23:48 <ReinH> @src (>>)
11:23:48 <lambdabot> m >> k = m >>= \_ -> k
11:23:56 <sproingie> you use it for stuff where the return value doesnt matter, i.e. side effects in IO
11:23:59 <ReinH> it's literally >>= and const
11:24:07 <dysfun> mivael: i mean Attoparsec has a combinators namespace full of things like sepBy
11:24:23 <ReinH> filostrato: no, not throw away the m a
11:24:27 <ReinH> throw away the *a*
11:24:51 <ReinH> > [1,2] >> "hello"
11:24:52 <mivael> dysfun, understood.  I'm starting to like this way of parsing :)
11:24:53 <lambdabot>  "hellohello"
11:25:02 <ReinH> the context in this case is that the list has two elements
11:25:08 <ReinH> the 'a' is what the elements are, which is thrown away
11:25:16 <dysfun> mivael: yes, it's quite nice compared to the alternatives
11:25:33 <filostrato> but isn't the m the same in all instances in the signature?
11:25:51 <filostrato> ooh
11:25:52 <ReinH> [1,2] and "hello" are the same m
11:25:54 <filostrato> I get it
11:26:08 <ReinH> same type, that is
11:26:13 <filostrato> I think; the m is still needed to determine the context
11:26:15 <ReinH> but m has some structure
11:26:15 <sproingie> ReinH: albeit kind of sneaky syntax for it
11:26:22 <ReinH> and the structure is different
11:26:32 <ReinH> or m is some sort of computation or effect, and those may differ
11:26:54 <ReinH> :t putStrLn "foo" >> putStrLn "bar
11:26:55 <lambdabot> error:
11:26:55 <lambdabot>     lexical error in string/character literal at end of input
11:27:02 <ReinH> :t putStrLn "foo" >> putStrLn "bar"
11:27:03 <lambdabot> IO ()
11:27:08 <ReinH> :t putStrLn
11:27:10 <lambdabot> String -> IO ()
11:27:20 <sproingie> notice the a -> m b there
11:27:26 <ReinH> putStrLn "foo" gives back an m a where m ~ IO, a ~ ()
11:27:33 <sproingie> a is String, m is IO, b is ()
11:27:42 <ReinH> we don't care about the a, but we very much care about the m context
11:27:45 <sproingie> () usually pronounced "unit" btw
11:27:57 <filostrato> right; the context needs to be the same
11:27:57 <davean> Why do we use ~ for type equality BTW?
11:28:24 <ReinH> because we are silly
11:28:35 <davean> Ok, because I've found it perpetually annoying
11:28:40 <ReinH> there's no good reason
11:28:41 <monochrom> Because = is already taken (to mean "definition").
11:28:46 <filostrato> I understand it better now; that lead me to another thing though, what exactly is this ()?
11:28:46 <ReinH> that is a reason
11:28:48 <sproingie> using = would make the grammar even more nuts than it is
11:28:52 <ReinH> I dispute whether it is a *good* reason
11:29:07 <ReinH> Other languages get away with it
11:29:12 <sproingie> filostrato: it's a type called unit.  it has only one value.  it's basically what you return when you don't return anything
11:29:15 <davean> I'm rather unhappy with ~
11:29:19 <ReinH> filostrato: data () = () is a type with one value
11:29:28 <monochrom> I totally agree with you definition should be :=, equality should be =, nothing should be == or ~
11:29:34 <davean> ReinH: two values?
11:29:41 <ReinH> two values, including bottom
11:29:44 <davean> correct!
11:29:52 <dysfun> monochrom: woohoo, pascal back in fashion!
11:29:56 <ReinH> it's a boring type we use when the value is boring
11:29:58 <geekosaur> but then there's the internal ~~ silliness
11:30:16 <ReinH> IO () does some IO but that no interesting result so we use the boring type for the result type
11:30:19 <sproingie> yeah, everything can have bottom, but we don't account for it.  you hit bottom, program goes boom.
11:30:24 <ReinH> er, "but has"
11:30:36 <filostrato> haha
11:31:02 <davean> sproingie: I don't know about you, but I find it pretty important to reason about the bottoms
11:31:02 <ReinH> it's the smallest possible thing you can use to indicate that something exists, but is otherwise uninteresting
11:31:18 <geekosaur> ob "fast and loose reasoning is morally correct" >.>
11:32:51 <filostrato> "It is very different from the empty type, called (by people I wish had chosen a better name like the one I suggested) in Haskell Void. The empty type is very exciting, because if somebody ever gives you a value belonging to it, you know that you are already dead and in Heaven and that anything you want is yours."
11:33:02 <ReinH> filostrato: Moving up, we have Bool, which is the type with two inhabitants (not bottom), which we use when we have a choice of two things, like for if.
11:33:32 <filostrato> right, so () is a type with only one value
11:33:35 <ReinH> IO Void is an IO computation that can't be executed because it would have to produce a value that doesn't exist.
11:33:37 <filostrato> a boring type with a boring value
11:33:50 <monochrom> When I'm dead, I want a mechanism to bring me back to life, thus completing the contradiction. :)
11:33:53 <ReinH> heh
11:33:58 <nitrix> filostrato: See `absurd`.
11:34:00 <nitrix> :t absurd
11:34:01 <lambdabot> Void -> a
11:34:19 <ReinH> see also a -> Void, which is logical negation.
11:34:31 <sproingie> :t absurd (unsafeCoerce 1 :: Void)
11:34:33 <lambdabot> error:
11:34:33 <lambdabot>     Variable not in scope: unsafeCoerce :: Integer -> Void
11:34:38 <sproingie> go fig
11:34:56 <mniip> :t absurd undefined
11:34:58 <lambdabot> a
11:36:02 <nitrix> mniip: The real question is if it's implemented as absurd = undefined or absurd Void = undefined
11:36:14 <mniip> absurd Void - can't write that
11:36:24 <filostrato> when is the empty type ever used?
11:36:27 <nitrix> whoopsie.
11:36:34 <ReinH> filostrato: you can imagine a function a -> b for some a and b as a way to make (sizeof a) choices of b, for examble Bool -> Int picks one of two Ints.
11:36:35 <mniip> Void either has no constructors or has an unary strict constructor
11:36:36 <filostrato> or is it just a joke? :P
11:36:38 <mniip> either
11:36:47 <nitrix> mniip: Sorry I meant absurd x = x `seq` undefined
11:36:48 <mniip> data Void; absurd x = case x of {}
11:37:00 <ReinH> filostrato: () -> Int just selects an Int (picks one of one Ints)
11:37:01 <mniip> data Void = Void !Void; absurd (Void x) = absurd x
11:37:17 <ReinH> Void -> Int selects zero Ints
11:37:25 <sproingie> filostrato: Void is fairly uncommon in day-to-day code, it's useful for type-level programming as analogous to "false"
11:37:54 <monochrom> Such strictly Void. Much bottom in bottom.
11:37:54 <mniip> (x -> Void) ~ not x
11:38:07 <dysfun> i guess that'll be less needed with TypeInType
11:38:14 <ReinH> filostrato: you might ask yourself, what is sizeof (a -> b)?
11:38:16 <sproingie> -Xzibit?
11:38:25 <ReinH> for example, how many ways can you write Bool -> Bool?
11:38:29 <mniip> sizeof?
11:38:35 <mniip> you mean cardinality of the set?
11:38:37 <filostrato> what does sizeof do?
11:38:37 <ReinH> yes
11:38:43 <filostrato> ok, hmm
11:38:46 <ReinH> filostrato: sizeof is how many inhabitants a type has
11:39:00 <ReinH> I could say |a -> b|, I guess
11:39:02 <filostrato> infinite? :P
11:39:08 <mniip> card(...)
11:39:14 <sproingie> such wonderful tangents
11:39:15 <mniip> filostrato, wrong!
11:39:30 <mniip> filostrato, if a = (), b = (), there's only one
11:39:37 <ReinH> filostrato: what is |() -> ()|?
11:39:42 <mniip> and one is a finite number
11:39:44 <ReinH> how many ways can you go from () to ()?
11:40:02 <filostrato> one, I suppose
11:40:09 <ReinH> ok, what about |() -> Bool|?
11:40:17 <filostrato> still one
11:40:20 <ReinH> really?
11:40:31 <monochrom> Three ways if you allow bottom and insist on monotonicity.
11:40:42 <ReinH> what about \() -> True and \() -> False?
11:40:44 <mniip> ew
11:40:47 <mniip> bottoms
11:40:54 <filostrato> oh, okay
11:40:58 <ReinH> we're all going to hold our noses and pretend there are no bottoms.
11:41:09 <ReinH> filostrato: now, what about |Bool -> Bool|?
11:41:14 <mniip> monochrom, I cound about 5?
11:41:15 <filostrato> 4
11:41:16 <monochrom> OK, sorry I was just digressing.
11:41:16 <ReinH> you can write them out if it helps
11:41:17 <mniip> count*
11:41:25 <ReinH> filostrato: now, given Data Three = A | B | C
11:41:27 <monochrom> mniip: I am slow and I was still at ()->().
11:41:32 <ReinH> what is |Bool -> Three|?
11:41:33 <mniip> ah
11:41:38 <filostrato> no,I get the combinatorics of it now, I believe
11:41:40 <mniip> yes with ()->() there's 3
11:41:43 <filostrato> 8
11:41:49 <filostrato> 6*
11:41:51 <monochrom> Bottom slows me down.
11:41:54 <ReinH> filostrato: and what is |Three -> Bool|?
11:42:15 <byorgey> uh, |Bool -> Three| is neither 8 nor 6
11:42:16 <filostrato> also 6?
11:42:22 <ReinH> write them down
11:42:29 <filostrato> kk
11:42:33 <ReinH> for both
11:42:40 <ReinH> since you didn't get either of them right ;)
11:43:14 <ReinH> Once you finish writing them down, try to figure out what the relationship between |a -> b| and |a| and |b| is
11:43:35 <filostrato> \True -> A, \True -> B, \True -> C, \False -> A, \False -> B, \False -> C
11:43:52 <filostrato> for the first one, still 6, so I guess I'm missing something crucial
11:44:07 <Gurkenglas> @tell Sh4rPEYE Here's a step by step evaluation for combinations'' http://tinyurl.com/mjj63qw
11:44:07 <lambdabot> Consider it noted.
11:45:03 <nshepper1> \True -> A isn't a total function. You need two cases
11:45:46 <ReinH> filostrato: \case { True -> A; False -> B }, \case { True -> A; False -> C } ...
11:45:54 <filostrato> oh
11:46:03 <filostrato> of course
11:46:08 <filostrato> that's how functions work
11:46:11 <filostrato> :D
11:46:13 <ReinH> :)
11:46:43 <mniip> for ease of notation you can use bool
11:46:45 <mniip> :t bool
11:46:46 <lambdabot> a -> a -> Bool -> a
11:46:55 <ReinH> an easier one that demonstrates the same thing
11:47:07 <ReinH> what is |() -> Bool| and what is |Bool -> ()|?
11:47:20 <filostrato> so it's 9 then
11:47:22 <ReinH> yeah
11:47:36 <ReinH> and now |Three -> Bool|
11:47:37 <filostrato> AA, AB, AC, BA, BB, BC, CA, CB, CC
11:48:14 <filostrato> that would be 8
11:48:36 <mniip> and now for something completely different: Integer -> Bool
11:48:46 <filostrato> 000, 001, 010, 011, 100, 101, 110, 111
11:49:18 <ReinH> ok, so we have |Bool| = 2, |Three| = 3, |Bool -> Three| = 9, |Three -> Bool| = 8
11:49:25 <filostrato> mniip: Integer holds infinite values, no?
11:49:44 <ReinH> so what might you guess about the relationship between |a -> b| and |a| and |b|?
11:49:50 <filostrato> exponentiation
11:49:53 <ReinH> yep
11:50:04 <ReinH> |a -> b| = b^a
11:50:17 <filostrato> yeah, it makes sense now that I think about how functions map
11:50:27 <mniip> filostrato, sure does
11:50:28 <ReinH> in algebra, you actually see b^a used as notation for a -> b
11:50:34 <ReinH> that's because the types form an algebra
11:50:37 <mniip> |Integer| = aleph_0
11:50:46 <mniip> 2^aleph_0 = aleph_1
11:51:01 <ReinH> and that algebra happens to have exponentiation, but only when we pretend that Haskell is well-behaved.
11:51:13 <ReinH> which is why I've been ignoring bottoms this whole time
11:51:18 <Sh4rPEYE> ReinH: Can I have one more question about the combinations?
11:51:24 <ReinH> sure
11:51:30 <filostrato> so that's where R^3 comes from when talking about three-dimensional space, and similar?
11:51:56 <mniip> you could imagine a point in R^3 to be a function from Three to R
11:52:07 <filostrato> yeah, exactly
11:52:12 <filostrato> that makes sense, nice
11:52:27 <ReinH> filostrato: x^3 = x * x * x and (R, R, R) = Three -> R
11:52:31 <mniip> well really
11:52:37 <mniip> it stands for R*R*R
11:52:44 <mniip> which, in set algebra, happens to equal R^3
11:53:00 <ReinH> (a,a) is isomorphic to Bool -> a
11:53:11 <ReinH> can you write the to and from functions that exhibit this?
11:53:19 <Sh4rPEYE> ReinH: I understand the code conceputally. When I call tails, though, I get also the tails which are shorter than my 'n'. How come the code doesn't also list combinations of lengths n-1, n-2...0?
11:53:34 <mniip> I remember there was a paper on how division by 3 in constructive set theory was actually super hard
11:54:00 <filostrato> ReinH: don't really understand what that means
11:54:13 <mniip> filostrato, you know what an isomorphism is?
11:54:26 <ReinH> mniip: can you convert between (a,a) and Bool -> a
11:54:46 <mniip> that was not addressed at me was it
11:54:47 <ReinH> to :: (a,a) -> Bool -> a, from :: (Bool -> a) -> (a,a)
11:54:55 <ReinH> such that to . from = id and from . to = id
11:55:00 <ReinH> mniip: sorry
11:55:04 <ReinH> filostrato: ^
11:56:09 <filostrato> only concept I have of isomorphism is some kind of equivalence; I'm going to have to process that @ ReinH
11:56:39 <ReinH> filostrato: the above is what it means to be an isomorphism
11:56:48 <mniip> filostrato, bijection? 
11:56:55 <filostrato> right, I just need to think about how to write the functions
11:57:08 <filostrato> right, a bijection is a one-to-one
11:57:14 <mniip> exactly
11:57:15 <ReinH> start with: to (a,a') b = ?
11:57:21 <mniip> a bijection can be represented with a pair of functions
11:57:29 <mniip> a forward and a backward correspondence
11:57:44 <ReinH> filostrato: then split b into cases
11:57:46 <mniip> but the laws that ReinH stated have to hold
11:57:51 <filostrato> a and a'?
11:57:58 <ReinH> two values of type a
11:58:22 <filostrato> I thought that was just denoted (a, a), why the apostrophe?
11:58:28 <ReinH> because this is the type level
11:58:31 <ReinH> er
11:58:32 <ReinH> value level
11:58:33 <ReinH> gosh
11:58:34 <ReinH> this is the value level
11:58:46 <ReinH> you're defining the function `to'
11:58:56 <ReinH> maybe it's my fault for reusing 'a' at both levels
11:59:00 <ReinH> to (x,x') b = ?
11:59:28 <ReinH> well, the only thing you can do is case b to figure out which one you have
11:59:50 <ReinH> and then depending on which one you have, select one of the members of the tuple
12:00:13 <filostrato> I don't mean to be that guy, but you've kind of lost me right now
12:00:17 <ReinH> ok
12:00:20 <ReinH> we want to write `to'
12:00:29 <ReinH> to :: (a,a) -> Bool -> a
12:00:47 <ReinH> to is a function that takes a pair and then a Bool that is used to choose a member of the pair
12:01:00 <filostrato> right, with you so far
12:01:06 <ReinH> so the Bool selects the first or second member of the pair
12:01:14 <filostrato> yep
12:01:26 <filostrato> so
12:01:38 <ReinH> so to (x,x') b = case b of { True -> x; False -> x' }
12:01:40 <filostrato> to True = x
12:01:43 <filostrato> to False = x'
12:01:44 <ReinH> yep
12:01:56 <ReinH> well, doing it that way to (x,x') True = x
12:01:57 <ReinH> but yes
12:02:03 <ReinH> now com ing the other way
12:02:33 <ReinH> from choose = ?
12:02:44 <ReinH> so choose :: Bool -> a
12:02:59 <ReinH> we make both choices and put them in the right spot in the result tuple
12:03:08 <ReinH> from choose = (choose True, choose False)
12:03:49 <filostrato> lost me again
12:03:53 <ReinH> ok
12:04:08 <ReinH> from :: (Bool -> a) -> (a,a)
12:04:18 <ReinH> from takes a function for choosing an a
12:04:23 <ReinH> where you can make two choices
12:04:28 <alx741> shouldn't that be choose :: a -> Bool -> (a, a) ?
12:04:30 <ReinH> because |Bool| = 2
12:04:42 <ReinH> should it?
12:04:50 <filostrato> right
12:05:01 <ReinH> choose is the argument to from
12:05:05 <ReinH> so its type is what?
12:05:21 <filostrato> choose :: Bool -> a
12:05:23 <mniip> alx741, no?
12:05:24 <ReinH> Right
12:05:35 <mniip> alx741, you need a function from a -> Bool to (a, a)
12:05:39 <mniip> oops
12:05:42 <ReinH> Bool -> a
12:05:45 <mniip> alx741, you need a function from Bool -> a to (a, a)
12:05:53 <ReinH> filostrato: so from takes as its argument a function Bool -> a
12:05:58 <ReinH> this function chooses an a
12:06:03 <ReinH> making one choice for each inhabitant of Bool
12:06:09 <alx741> mniip: so choose :: Bool -> a -> (a, a) , right?
12:06:10 <ReinH> so a choice for True and a choice for False
12:06:10 <filostrato> right
12:06:16 <ReinH> alx741: no
12:06:16 <mniip> alx741, no?
12:06:32 <ReinH> filostrato: so to get an (a,a) back, we make both choices
12:06:34 <ReinH> and pair them up
12:06:36 <mniip> alx741, you're confusing this with A -> (B -> C) = A -> B -> C
12:06:44 <ReinH> from choose = (choose True, choose False)
12:07:01 <mniip> which is because we made -> associate that way because it is useful
12:07:10 <alx741> oh! got it, thanks for the clarification
12:07:11 <mniip> (A -> B) -> C /= A -> (B -> C)
12:07:11 <ReinH> choose is the function that takes a Bool and gives an a, it records the choices that were originally made by pairing the two values
12:07:33 <ReinH> the only gotcha is that you have to remember whether True represents the first or second part of the pair
12:07:36 <ReinH> you could write it wrong
12:07:45 <ReinH> like from choose = (choose False, choose True)
12:08:12 <ReinH> the type of from isn't restrictive enough to prevent you from writing the wrong implementation
12:08:24 <ReinH> you could write a dependent version that was guaranteed to be correct
12:08:35 <ReinH> filostrato: do to and from make sense now?
12:08:57 <filostrato> eh, it's very conceptual; how did we end up on that tangent again?
12:09:07 <mniip> ReinH, now explain why '\choose -> (choose True, choose True)' and '\(x, y) -> const x' don't make an isomorphism!
12:09:13 <ReinH> filostrato: because I wanted to show you that R^3 = (R,R,R)
12:09:41 <ReinH> so we can use a triple to represent 3D space
12:09:48 <ReinH> rather than being forced to use a function Three -> R
12:10:21 <ReinH> filostrato: it has almost nothing to do with your original question
12:10:26 <ReinH> well it sort of does
12:10:31 <ReinH> but only barely
12:10:45 <filostrato> right; I intuitively understand that very well, but I see now that it's nice to understand the actual underlying functions and types
12:10:50 <ReinH> > [(),()] >> "hello"
12:10:52 <lambdabot>  "hellohello"
12:10:57 <ReinH> why does that have 10 characters?
12:11:11 <filostrato> now that's a good question
12:11:15 <ReinH> because join is a product, and join for [] specifically is cartesian product
12:11:24 <ReinH> and that's how products work
12:11:29 <filostrato> why is join a product?
12:11:29 <ReinH> 2 * 5 = 10
12:11:43 <ReinH> join :: m (m a) -> m a
12:11:49 <mniip> uhhh
12:11:52 <ReinH> join takes a product
12:11:59 <ReinH> m . m
12:12:02 <mniip> are you referring to the tensor product in the monoidal cat of endo functors?
12:12:03 <ReinH> and does something product-y with it
12:12:05 <c_wraith> join is mappend
12:12:14 <ReinH> er, sorry
12:12:19 <c_wraith> in the sense that monads are endofunctors
12:12:28 <ReinH> yeah, I got that twisted
12:12:31 <mniip> I'm not sure filostrato has the knowledge to understand the productness
12:12:38 <ReinH> >> is a product under the hood, the applicative product
12:12:39 <sproingie> mniip: i'm plenty tickled that i finally learned enough to understand what you said
12:12:41 <c_wraith> or, rather, monoids of endofunctors
12:12:58 <filostrato> I don't, Your Productness
12:13:11 <mniip> sproingie, monads are monoids in the endofunctor category
12:13:18 <sproingie> mniip: what's the problem? :)
12:13:25 <mniip> sproingie, it's a really cool fact and I was amazed myself
12:13:27 <ReinH> and the applicative product for [] is the cartesian product
12:13:39 <mniip> sproingie, do you know that applicatives are monoids in a category as well!
12:13:41 <ReinH> rather than the pointwise product of ZipList
12:13:49 <sproingie> been studying category theory at the university of YouTube
12:14:01 <sproingie> i should probably get back to it soon
12:14:53 <mniip> sproingie, if you take the category of endofunctors
12:15:06 <mniip> but instead of the composition tensor product you use something a tad bit different
12:16:06 <mniip> F \otimes G = (a \mapsto \int_x \int_y Fx * Gy * (x -> y -> a))
12:16:15 <mniip> or, in haskell terms,
12:16:32 <mniip> data Apply f g a where Apply :: forall x y. f x -> g y -> (x -> y -> a) -> Apply f g a
12:17:06 <mniip> the identity of that tensor product is still Identity
12:17:20 <mniip> and I have the proofs for the assoc/unit axioms handy
12:17:20 <Zemyla> Would it be possible to have a Haskell variant where every type is linear by default, and the ones that aren't are instances of Comonoid?
12:17:41 <Zemyla> class Comonoid a where { duplicate :: a -> (a, a); destroy :: a -> () }
12:17:47 <mniip> sproingie, the monoids in *this* monoidal cat are precisely Applicative functors
12:18:00 <mniip> @let data Apply f g a where Apply :: forall x y. f x -> g y -> (x -> y -> a) -> Apply f g a
12:18:01 <lambdabot>  .L.hs:167:31: error: Not in scope: type variable ‘f’
12:18:01 <lambdabot>  
12:18:01 <lambdabot>  .L.hs:167:38: error: Not in scope: type variable ‘g’
12:18:10 <mniip> @let data Apply f g a where Apply :: f x -> g y -> (x -> y -> a) -> Apply f g a
12:18:11 <lambdabot>  Defined.
12:18:20 <mniip> :t \(Apply (Apply fx gy xyz) hw zwa) -> Apply fx (Apply (fmap (flip xyz) gy) (fmap (flip zwa) hw) (flip (.))) (flip id)
12:18:21 <lambdabot> (Functor t1, Functor t2) => Apply (Apply t3 t2) t1 t -> Apply t3 (Apply t2 t1) t
12:18:25 <dolio> The unit isn't identity, is it?
12:18:27 <mniip> :t \(Apply fx (Apply gy hz yzw) xwa) -> Apply (Apply (fmap xwa fx) (fmap yzw gy) (.)) hz id
12:18:29 <lambdabot> (Functor t1, Functor t3) => Apply t3 (Apply t1 t) t2 -> Apply (Apply t3 t1) t t2
12:18:34 <mniip> :t \(Apply (Identity x) gy xya) -> fmap (xya x) gy
12:18:36 <lambdabot> Functor t1 => Apply Identity t1 t -> t1 t
12:18:39 <dolio> It's Const I, where I is the monoidal identity object.
12:18:44 <mniip> :t \ga -> Apply (Identity ()) ga (const id)
12:18:45 <lambdabot> g a -> Apply Identity g a
12:18:46 <ReinH> filostrato: sorry, I bungled that last bit
12:18:57 <mniip> dolio, here's your proof!
12:19:42 <filostrato> that's fine; I think that's enough for me for today anyway
12:20:00 <ReinH> filostrato: There's a reason that length (xs >> ys) = length xs * length ys
12:20:52 <ReinH> that is, it isn't an accident that the relationship between lengths is the product of lengths, it has to do with what join does for [].
12:21:53 <filostrato> yeah, I have a vague notion of why, but probably need to learn some of that aforemention cat theory first
12:21:54 <mniip> sproingie, cool huh
12:22:09 <mniip> dolio, monoidal identity object?
12:22:12 <filostrato> but thanks for the help; I'll prob be back over the coming days, hopefully weeks and months, heh
12:22:14 <mniip> what
12:22:34 <sproingie> mniip: once i can parse it.  i find it easier to understand when it's circles and dots and arrows :)
12:23:00 <dolio> The construction you're talking about involves two monoidal categories.
12:23:11 <mniip> I only see one
12:23:11 <ReinH> filostrato: the Monad instance for [] represents choice (at least, that's one interpretation). >>= says "for each item in the list, I'll give you some choices to make, and then you combine them together"
12:23:29 <dolio> They each have tensors and unit objects.
12:23:52 <LordBrain> monoid is a binary operation with an identity, such as the empty string "" and concatenation, monoidal identity object would be the empty string in that case, but something else for a different monoid
12:23:57 <mniip> (day convolution, Identity) induces a monoidal category
12:24:02 <mniip> on End(Hask)
12:24:09 <mniip> monoids in that are applicatives
12:24:35 <mniip> well
12:24:37 <LordBrain> okay, nvm.. i just walked in
12:24:40 <ReinH> :t (>>=) `asAppliedTo` []
12:24:42 <lambdabot> [a] -> (a -> [b]) -> [b]
12:24:42 <mniip> I have proof that every monoid is an applicative
12:24:49 <LordBrain> no idea what you two are talking about
12:24:52 <mniip> not vice versa but I'm fairly certain
12:24:56 <sproingie> LordBrain: welcome to #haskell :)
12:25:08 <LordBrain> thaks
12:25:16 <LordBrain> its not my first time, just first time today
12:25:23 <ReinH> filostrato: for each a, provide a choice of b's, and the result will be every choice that can be made
12:25:31 <ReinH> :t (>>) `asAppliedTo` []
12:25:32 <dolio> mniip: Identity doesn't even make sense in the general case, actually.
12:25:33 <lambdabot> [a] -> [b] -> [b]
12:25:34 <sproingie> anyway, here's the CT youtube series i've been watching: https://www.youtube.com/watch?v=I8LbkfSSR58&list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
12:25:35 <Tuplanolla> I've been following along, but got lost at the not-integral integral signs.
12:25:53 <ReinH> is, isntead, for each a, throw it away and just choose these b's
12:25:55 <dolio> Because the general case is that the source and target are not the same.
12:26:13 <LordBrain> i'm not sure we should be proud of our abstractness or mathematicalness
12:26:34 <sproingie> oh i'm proud about it in an abstract way :)
12:26:36 <LordBrain> abstractness in terms of applicability sure
12:26:45 <dolio> Because monoidal functors aren't necessarily endofunctors.
12:26:56 <LordBrain> but i mean, we shouldnt create the impression that you need to know category theory to write haskell
12:27:11 <LordBrain> or to understand haskell
12:28:00 <sproingie> i think this is more a phenomenon of bored mathematicians playing around
12:28:34 <dolio> The more general case is that you have a monoidal category (V, *_V, I_V) and a monoidal category (C, *_C, I_C) enriched in V, and you consider monoidal functors C -> V.
12:28:41 <LordBrain> well, if i am honest, knowing some category theory is helpful perspective
12:28:52 <Aruro> its not
12:28:58 <LordBrain> whats not
12:28:58 <dolio> Or, actually, you consider all enriched functors C -> V.
12:29:09 <Aruro> CT is useless, it has no tools
12:29:15 <LordBrain> hmm
12:29:20 <LordBrain> its language tho
12:29:23 <Aruro> otherwise so beloved applicative will be long known
12:29:31 <dolio> And that turns out to be a closed monoidal category, with day convolution as the tensor. And the monoids are monoidal functors.
12:29:33 <LordBrain> applicative is well known in here
12:29:55 <Aruro> CT is 50 years old, applicative is younger than cat
12:30:10 <Aruro> so no, CT did not help discover anything usefull
12:30:10 <ReinH> idk, we've had closed functors for a long time
12:30:28 <LordBrain> well okay, but dont pick a fight wiht the CT guys
12:30:30 <Aruro> it help to pretend to be smart yes
12:30:34 <LordBrain> hahahaha
12:30:52 <sproingie> i'm always pretending
12:31:07 <ph88_> mivael, what are you parsing ?
12:31:08 <ReinH> well, understanding algebra is super helpful
12:31:16 <ReinH> and CT is just extra abstract algebra
12:31:18 <Aruro> algebra is not CT
12:31:25 <ReinH> CT is the algebra of abstract functions
12:31:27 <sproingie> everything is CT :)
12:31:27 <LordBrain> Aruro, maybe the CT people should be studying haskell instead of the other way around eh?
12:31:29 <Aruro> algebra is algebra
12:31:36 <ReinH> CT is algebra
12:31:50 <Aruro> LordBrain: perhaps there will be more use like that :D
12:32:08 <LordBrain> well, i love math, majored in it, but i admit CT has a strange flavor, its like every proof is trivial.. this diagram commutes, etc
12:32:26 <Aruro> yeah! and most important laymen LOVE It
12:32:36 <ReinH> In as much as functional programmers concern themselves with functions, an algebra of functions is often useful to them
12:32:43 <sproingie> CT has "diagram chasing".  everyone understands that, just follow the arrows.
12:33:38 <LordBrain> i dont think layman loved it until haskell came along and popularized it
12:33:43 <ReinH> I mean, sure, you can do Haskell without understanding CT. Of course.
12:33:52 <Aruro> ReinH: same u can say about philosophy, CT is as usefull to programming as general wisdom
12:33:57 <ReinH> It turns out that you can also do introductory Algebra courses without understanding Algebra
12:34:02 <alx741> mniip: every monoid is an applicative? interesting, how is that?
12:34:06 <ReinH> It just requires memorizing everything
12:34:10 <LordBrain> but Aruro, you could view CT as a generalization of haskell
12:34:13 <ReinH> since you don't have a unifying model
12:34:39 <dolio> mniip: Oh, and I think the unit is Hom_C(I_C, -), so that's why it's identity in the special case of endofunctors on Hask.
12:35:03 <Aruro> ReinH: i think haskell presents rather coherent system, functions and stuff for them
12:35:09 <dolio> Because () -> A ~ A.
12:35:25 <Tuplanolla> In many other fields of mathematics it feels like the level of abstraction is completely wrong. Definitions and theorems are not chosen in a way that makes results obvious.
12:35:28 <sproingie> haskell was created because theorists wanted a better tool
12:35:49 <sproingie> tho i dunno how many of the committee were CT people
12:36:33 <ReinH> Aruro: there are two things going on imo. One is that they are learning concepts and developing models that implicitly algebraic or categorical, without having a way to formalize them. The other is that Haskell isn't actually a perfect, pure embodiment of category theory, so there's some impedance mismatch.
12:36:51 <sproingie> "CT" in my previous circles would expand to "Conspiracy Theory"
12:37:03 <ReinH> And a lot of the day to day work of being a Haskell programmer lives in that grey area
12:37:34 <ReinH> I've often had the experience of explaining a CT concept to a Haskeller and having them just go "oh, that's what that' is."
12:37:42 <Tuplanolla> For me the primary appeal of category theory is turning a few complicated and difficult theorems into a large collection of mundane or even uninteresting consequences.
12:37:45 <ReinH> because they had already developed a pretty sophisticated model just by doing haskell
12:38:44 <LordBrain> CT seems to me less complicated than set theory
12:39:10 <LordBrain> which gives it greater elegance
12:39:10 <ReinH> CT conveniently avoids most of the hard parts of set theory by basically being set theory agnostic
12:39:20 <LordBrain> (as subjective as 'elegance' is...)
12:40:09 <ReinH> "this will all work with your set theory, whatever that may be, so we don't really care what your set theory is"
12:40:43 <sproingie> it was created to unify set theory and topology, right?
12:40:57 <ReinH> it was created to be able to talk about natural transformations
12:41:05 <ReinH> or possibly Kan extensions
12:42:25 <sproingie> wrath of Kan
12:43:12 <Aruro> formalisation is only part of the problem, it useless if there are no Methods developed with it
12:43:19 <Aruro> CT to my knowledge has 0 methods
12:43:24 <Aruro> to find Nothing new
12:43:38 <ReinH> LordBrain: sort of like the analyst who wants the real numbers to form a complete ordered field, but doesn't particularly care if they are Dedekind cuts or classes of Cauchy sequences or whatever else, category theorists mostly just get on with their work and forget about the underlying set theory.
12:43:50 <ReinH> Or at least that's how it seems to me.
12:43:54 <LordBrain> in theory tho, it gives you greater lateral transfer Aruro 
12:44:38 <LordBrain> does it work that way in practice... i'm not actually good enough wiht it to say
12:44:52 <LordBrain> it seems like it should... conceptually
12:44:52 <dolio> The nice way of saying things in category theory says a lot of stuff about the category of sets, though.
12:45:05 <sproingie> plus it gives the great phrase "true by abstract nonsense" :)
12:45:58 <ReinH> LordBrain: I guess if you really want to know how the sausage is made, you spend $30 on https://link.springer.com/chapter/10.1007/BFb0059148
12:46:04 <LordBrain> suppose CT gave you 0 new results, but it helped you more easily jump from one field to the next, thats still a contribution
12:46:12 <dolio> But yes, it's similar to not caring exactly how the reals are constructed.
12:46:32 <Aruro> certainly it is advantage, thats why we have philosophy of science :)
12:47:41 <LordBrain> once we have the properties of real numbers tho, they're construction is more or less irrelevant anyway... construction is just to satisfy to those theorists who require things like that, to justify their existence... But the axioms are not in terms of the construction, so just real analysis of the vanilla sort is agnostic to construction.
12:47:47 <ReinH> Or I guess Grothendieck universes
12:48:05 <LordBrain> regular real analysis already provides that
12:48:13 <LordBrain> without CT
12:48:54 <ReinH> I'm not suggesting that real analysis requires CT
12:49:01 <ReinH> I'm suggesting a parallel between the two
12:49:40 <ReinH> in terms of their relationship to the underlying set theory
12:50:03 <dolio> Your choice of set theory may affect some properties that it has that are relevant to category theory, though.
12:50:03 <Aruro> there can be many set theories
12:50:10 <Aruro> same with CT
12:50:20 <johnw> Aruro: are you here to troll, or did you have something Haskell-related to say?
12:50:35 <dolio> Or, whatever foundation you choose to apply category theory to.
12:50:38 <mniip> 1493148820 [22:33:40] <alx741> mniip: every monoid is an applicative? interesting, how is that?
12:50:49 <mniip> every monoid in (End(Hask), Day convolution, Identity)
12:50:57 <Aruro> johnw: so far i see You, trolling me. add meaning to conversation.
12:51:16 <LordBrain> its hard to know there is no use to CT, unless you literally are a foremost expert in CT
12:51:49 <sproingie> that would actually be a little ironic
12:51:55 <johnw> Aruro: I'm giving you a warning to cease bashing CT, it is not contributing to the discussion
12:51:56 <LordBrain> meaning you've read all the papers etc, understood them all, and found nothing of value... thats a tall order
12:53:07 <mniip> dolio, are we talking about the same thing?
12:53:55 <Aruro> johnw: are you doing CT? :)
12:54:04 <johnw> Aruro: in fact, I am, just a few minutes ago
12:54:26 <LordBrain> however, as i already pointed out, suppose there is no new results, nothing we didnt already know, the unification alone is theoretically useful, theoretically it allows you to operate a higher level of abstraction, and that has 2 benefits, one is your results, should you find any are more general, ie contribute to more fields, and two when you move from one field to another, you have a good idea of how much you take with you.
12:54:47 <dolio> mniip: Yes. There's a generalization I mentioned, though.
12:55:15 <LordBrain> the draw back tho is now everyone has to learn yet more jargon to understand 
12:55:19 <Aruro> johnw: i think bashing CT has brought some interesting ideas in this chat.
12:55:41 <sproingie> LordBrain: new concepts require new language.  new languages start with jargon.
12:55:58 <sproingie> hell, "quaternion" used to be crazily obscure jargon, now every game programmer uses 'em
12:56:02 <LordBrain> yeah, doesnt mean its not a draw back
12:56:30 <johnw> Aruro: bashing in general is not our approach, so let's avoid it. Asserting a global negative without proof or evidence serves little purpose. We have lots of constructive things to talk about.
12:56:42 <Aruro> sproingie: somebody like me probably even once said that quaternions are useless! :D
12:57:26 <sproingie> eh, we went to the moon with euler angles
12:57:36 <LordBrain> one could argue there is some point of diminishing returns in abstractness, and perhaps we should consider that
12:57:40 <sproingie> 'course the ship used *actual* gimbals too
12:58:56 <Aruro> my point is that CT is very much a research and what is needs more than beginners HOT and intense debate
12:59:01 <sproingie> fsm knows i only treat quats as an opaque encoding of euler angles.  visualing 4d complex numbers is not my bag.
12:59:06 <sproingie> *visualizing
12:59:19 <Aruro> is*
12:59:31 <johnw> Aruro: that's an assertion, and you're welcome to it, but there's little purpose in trying to convince us that you're right.  Some of us are using CT quite productively.
13:00:08 <Aruro> im trying to convince that abstractions fomr CT which are usefull do Not need full machinery of CT
13:00:16 <sigsin> Hey, I am using Haskell Stack @ Windows 10 with Creator's Update. And after the update it's broke. What should I do now?
13:00:23 <johnw> Aruro: OK, I think we all already accept that
13:00:26 <sproingie> but even without the understanding of the internals, i get enough about their behavior.  same with other abstract concepts
13:00:40 <LordBrain> Aruro, do they ever have it.. in haskell i mean.. 'full machinery'
13:00:56 <LordBrain> they generally dont
13:01:29 <LordBrain> there's a sort of pragmatic concern tho, in terms of, nobody wants to use a library if they cant understand its documentation
13:01:55 <sproingie> sure, because if they can't understand it, they can't use it
13:02:16 <LordBrain> well
13:02:19 <LordBrain> sometimes they could
13:02:24 <LordBrain> but even then
13:02:27 <sproingie> unless it's such a black box that it has a tiny simple API they can just drop it into some recipe
13:02:30 <sproingie> (like me and quaternions)
13:02:38 <LordBrain> they dont enjoy doing so, tis not open source in the sense that its not penetrable code
13:03:04 <LordBrain> but you know, i'm ont saying people should stop writing code or such
13:04:23 <zaghiesags> any burritos in here?
13:04:57 <LordBrain> open source hackers might use a library that works, even if they dont understand how, but they'd prefer using one that they could actually understand how and get in if necessary and tweak even.
13:05:41 <sproingie> everyone draws a line somewhere though
13:07:12 <LordBrain> it creates incentive to roll your own... so you pass up an existing library really
13:07:16 <sproingie> most people trust their compiler without ever eyeballing its source
13:07:22 <sproingie> (and yes i know about ken thompson)
13:08:19 <LordBrain> i am talking about preference, i'm not saying its a red line
13:08:40 <mniip> huh
13:08:45 <mniip> does lambdabot not support record gadts?
13:08:46 <LordBrain> well, depending on the hacker and what they are trying to do and why, they might actually make it a read line
13:09:08 <mniip> @let data Foo where Foo :: { test :: Int } -> Foo
13:09:09 <lambdabot>  Defined.
13:09:12 <mniip> wut
13:09:15 <sproingie> i like knowing a little about how everything works.  my preference is toward the abstract though
13:10:53 <mniip> @let data Foo where Foo :: Show a => { test :: a } -> Foo
13:10:53 <lambdabot>  Parse failed: Parse error: {
13:11:04 <sproingie> but not as much as some.  some part of me always thinks "how can i make a bitchin' game with this?" ;)
13:11:11 <mniip> that's valid ghc syntax
13:11:24 <sproingie> lambdabot doesn't have a whole lot of extensions enabled
13:12:36 <sproingie> come to think, is it still speaking caleskell?
13:12:46 <sproingie> > [1,2,3] . (1 +)
13:12:47 <lambdabot>  error:
13:12:48 <lambdabot>      • Couldn't match expected type ‘b -> c’
13:12:48 <lambdabot>                    with actual type ‘[Integer]’
13:12:57 <sproingie> survey says no
13:13:02 <sm> if you're interested in windows support for vty: https://mail.haskell.org/pipermail/haskell-cafe/2017-April/126890.html
13:13:07 <LordBrain> sproingie, yeah, i dont think people mind the abstract, if they get it, its just if they dont know the jargon and stuff, and if it is questionable that the jargon was necessary to get it... you know... its like if you speak chinese, you dont mind that all the code and comments and stuffa re in chinese i assume.
13:13:12 <MarcelineVQ> hmm that's GADT syntax but lambdabot can do GADT's can't it
13:13:25 <ReinH> What about Conorskill where : is , and , is also , and everything is , in either blue, red, or green.
13:13:32 <ReinH> Oh that's epigram.
13:13:51 <ReinH> oh, and binary operations in three variables are everywhere
13:15:11 <MarcelineVQ> hmm, maybe not actually
13:15:15 <sproingie> LordBrain: jargon can be alienating, yeah.  but we couldn't work effectively without it.  so it's a constant effort to find analogies in the middle
13:15:29 <LordBrain> sproingie, i think they know that too
13:16:01 <mniip> sproingie, that''s not an extension
13:16:03 <sproingie> speaking as someone largely in the middle, i'm hardly an expert in anything
13:16:09 <mniip> it's part of GADTs
13:16:11 <MarcelineVQ> ohh it has -XGADTSyntax but not -XGADTs
13:16:20 <LordBrain> sproingie, but someone like Aruro might have some doubts about whether it was necessary, you know, or whether it was used unnecessarily just to show off or something
13:16:29 <Aruro> i do
13:16:35 <sproingie> mniip: GADTs would be one of them glasgow extensions enabled with a pragma :)
13:16:49 <sproingie> i'd be surprised to not see \bot support it tho
13:16:50 <Aruro> especially seeing how much and effort beginners put in CT
13:16:54 <Aruro> time*
13:17:09 <Aruro> better would be to write a couple of good haskell libs
13:17:32 <sproingie> beginners don't put anything into CT, if all the beginners i've come along with are any indication
13:17:53 <Aruro> they do
13:18:04 <Aruro> because Some people Talk about it non stop :)
13:18:08 <mauke> no, they don't
13:18:16 <sproingie> some beginners go and write language interpreters as their first haskell project
13:18:58 <davean> sproingie: thats a pretty typical first project?
13:19:12 <LordBrain> its not that they dont know the value of jargon generally, but you know its a trust issue... is this jargon justified/useful or not, is it a good mix, a good balance... naturally every programmer knows some jargon is justified, but we also know that it is possible to make a bunch of big words or show off unnecessarily, and its sort of you know, whats your assessment or faith in the average person/coder and your temperment and so on.
13:19:16 <davean> In any language, not just Haskell
13:19:18 <sproingie> no, and these beginners were usually pretty skilled in some other language
13:19:37 <sproingie> but their brains just have no problem bending to haskell's shape.  or were already in that shape.
13:19:54 <MarcelineVQ> it's a little typical due to things like write yourself a scheme
13:19:58 <davean> sproingie: I think of a language interpriter as the stereotypical first project in a new language
13:20:04 <sproingie> perl6's first implementation was in haskell, audrey tang hardly knew any haskell
13:20:08 <MarcelineVQ> One doesn't often go all the way through it first try though
13:20:08 <mniip> 1493151578 [23:19:38] <lambdabot>  That paste is too long! (maximum length: 4096)
13:20:12 <mniip> who the hell made that
13:20:31 <mniip> (also, it can't count, my paste is 4036 bytes)
13:20:50 <mauke> audrey tang is a monster, though
13:21:08 <Aruro> mauke: ?
13:21:09 <osfameron> davean: I don't think most programmers write a language interpreter as their first project
13:21:17 <sproingie> some beginners are natural geniuses, sure
13:21:36 <osfameron> it might be more common among comp-sci grads I suppose?
13:22:47 <davean> osfameron: well I do tend to pay attention to the trained more then the untrained
13:23:17 <davean> The untrained are often uninteresting in that they don't make any informed decisions at all
13:23:21 <sproingie> Aruro: monster as in freakishly talented
13:24:19 <Tuplanolla> Do you remember your first projects?
13:25:11 <davean> Yah, I remember my first projects
13:25:19 <davean> well, at least in CS land
13:25:29 <LordBrain> i think i would break down and learn the ct necessary, but others might not, and i already have a math background so thats another factor too... now what about chinese? if it were chinese, would i break down and learn the chinese.. no.
13:25:37 <sproingie> i typed in a lot of source from Compute! magazine.  first from-scratch stuff was C64 BASIC stuff for helping generate GURPS characters
13:25:50 <davean> sproingie: :)
13:25:58 <Tuplanolla> There should be a poll about people's first Haskell projects. That would probably be interesting.
13:26:01 <[exa]> watching this conversation, how many of you are university-related and/or university teachers?
13:26:12 <sproingie> Compute! actually did more harm than good to my programming ability
13:26:16 <cocreature> [exa]: are students university-related?
13:26:17 <davean> oh ... my first Haskell project was a Prolog
13:26:18 <LordBrain> well i like languages, so i guess i might, if i was already interested in chinese.. but you know what i mean
13:26:25 <sproingie> i thought i was stupid because i couldn't understand what all those DATA statements meant
13:26:31 <sproingie> not knowing that nobody else could either
13:26:40 <[exa]> cocreature: yep
13:26:45 <LordBrain> and of course, if i have to learn chinese before i hack on a library, its going to take me a long time before i make any contribution for sure
13:26:49 <mauke> my first haskell project was trying to figure out this $@%&* language
13:26:50 <mauke> and giving up
13:26:52 <cocreature> then I definitely fall into that category :)
13:27:11 <Tuplanolla> My first Haskell project was a field equation solver and it was absolute horse shit.
13:27:22 <MarcelineVQ> the difference is that the chinese languages have a lot more primops than ghc does
13:27:32 <davean> My prolog wasn't good but it wasn't terrible, it was just very straight forward
13:27:52 <LordBrain> MarcelineVQ, well the analogy is not very good for a number of reasons, but it shows the point nevertheless... chinese also falls apart before the mighty google translate
13:27:54 <sproingie> nothing wrong with that.  start with obvious, generalize from there.
13:27:58 <MarcelineVQ> haskell's voca is pretty small really
13:28:02 <MarcelineVQ> *vocab.
13:28:25 <sproingie> LordBrain: my favorite channel lately has been "google translate sings"
13:28:26 <LordBrain> the point is, the more you have to learn before you can code, that is indeed a barrier to entry
13:28:30 <MarcelineVQ> sure
13:28:50 <[exa]> cocreature: well I'm actually teaching this stuff to students, so just kindof asking out for experiences
13:29:12 <LordBrain> i think a lot of people might not care about barriers to entry tho, they want to make code for themselves, and dont expect anyone to contribute anyway
13:29:53 <davean> [exa]: I was in college when I did my first Haskell, but I only did that one project and put haskell down for like 8 years after
13:30:06 <davean> [exa]: I was in no way associated with education when I came back
13:30:09 <LordBrain> but ideally, we should care, i mean, it is better if we do probably
13:30:09 * srk working on plotting lib http://48.io/~rmarko/random/liveplot.jpg
13:31:05 <Tuplanolla> Apply directly to the foreh... screen buffer, srk?
13:31:25 <srk> Tuplanolla: opengl
13:31:52 <mauke> I think the one thing that made me "get" it on my second attempt was concentrating on understanding IO and ignoring do syntax
13:32:06 <srk> combination of mvc, pipes, vinyl-gl and andromeda
13:32:15 <mauke> do notation was a significant barrier to understanding
13:32:28 <Aruro> srk: why not on hub?
13:32:43 <srk> Aruro: gimme a minute :D
13:32:47 <Tuplanolla> Make sure to implement automatic recursive subdivisions unlike all other "plotting" libraries, srk.
13:32:48 <Aruro> :D
13:32:51 <davean> I think what mattered for me was enough ecosystem to make doing Haskell worthwhile
13:33:05 <LordBrain> fair point mauke, but is it not a worthy sugar anyway?
13:33:12 <mauke> sure
13:33:15 <srk> Aruro: it needs few upstream patches but it's buildable with stack
13:33:17 <mauke> after you understand >>=
13:33:23 <srk> Tuplanolla: for zooming?
13:33:29 <mauke> it's not good for teaching/learning
13:33:43 <Tuplanolla> For good quality around singular and high-curvature points, srk.
13:33:50 <srk> ah, ok
13:34:06 <LordBrain> i dont know if i agree or not, but i've seen that expressed before
13:34:28 <srk> Tuplanolla: my requirements for now are simple - plot live data from pipes into multiple graphs. will extend it later with more feats and graph types
13:34:49 <sproingie> i first learned haskell from A Gentle Introduction.  which had ... mixed results
13:34:59 <glguy> mniip: Speaking of GADT record syntax, do you happen to remember when that was added?
13:34:59 <Aruro> its good book
13:35:04 <LordBrain> i think the issue is the types and how they interact with do, maybe >>= is one way to make that more obvious, but i bet you could do it without >>=
13:35:05 <mniip> no
13:35:16 <srk> best way to learn haskell is to write haskell for everything :D
13:35:21 <mauke> I'm skeptical
13:35:22 <[exa]> :]
13:35:30 <Aruro> srk: +1
13:36:02 <mauke> I knew Perl and OCaml, so I was familiar with closures, callbacks, higher-order functions, algebraic types, pattern matching, etc.
13:36:09 <mauke> I understood purity intuitively
13:36:20 <mauke> but the whole IO thing was an incoherent mess
13:36:28 <[exa]> good point about the do notation
13:36:32 <sproingie> purity i got.  i suffered through *every* monad tutorial.
13:36:54 <mauke> like, you have types randomly "tagged" with IO to show the operation is impure
13:36:57 <LordBrain> btw, i wasnt talkkng about barrier to entry for beginners
13:36:58 <[exa]> and monad tutorials on IO suck, people have already mixed opinions on IO
13:37:22 <mauke> but why is it e.g. putChar :: Char -> IO () and not putChar :: IO (Char -> ())?
13:37:22 <LordBrain> i was talking about barrier to entry for experienced haskellers who just arent great with CT
13:37:34 <sproingie> IO is too magical to use as the canonical introductory monad
13:37:42 <sproingie> Maybe and List are much better for that
13:38:15 <[exa]> I was thinking about List actually
13:38:16 <mauke> you have to randomly use 'let' and '<-', and a type like 'IO (IO ())' makes no sense
13:38:21 <sproingie> maybe Reader after those
13:38:25 <[exa]> looks like prolog, works kindof so
13:38:32 <davean> mauke: how does IO (IO ()) not make sense?
13:38:37 <davean> mauke: that was one of the best parts for me learning
13:38:39 <LordBrain> so, people who have already suffered through monad tutorials and such
13:39:06 <mauke> davean: if you're a beginner who's only seen bad tutorials that explain IO as kind of an "this is impure" tag ...
13:39:10 <[exa]> davean: is there an useful example for that?
13:39:29 <davean> [exa]: I mean, passing around actions to do? All over?
13:39:44 <davean> [exa]: I guess one of the most common would be returning a finalizer of some sort
13:39:53 <sproingie> "You Could Have Invented IO"
13:40:01 <[exa]> davean: no, just some motivating example that would contain IO(IO a)
13:40:06 <Tuplanolla> It comes up in `resourcet`, [exa].
13:40:31 <davean> [exa]: anything about talking and selecting actions
13:40:36 <davean> *talking about
13:40:42 <mauke> [exa]: register :: Handler -> IO (IO ())
13:40:55 <mauke> the action registers a handler for some event
13:40:59 <sproingie> a -> m m b?
13:41:02 <mauke> it returns an unregister action
13:41:07 <sproingie> that's an odd signature
13:41:11 <mauke> that can be used to undo the registration
13:41:13 <davean> deciding what action to take, instead of actually TAKING the action was where it came up for me
13:41:28 <davean> which immediately leads to talking about actions as actual things
13:41:29 <[exa]> oh cool, thanks!
13:41:31 <c_wraith> [exa], I built an interface that builds and returns IO actions once. 
13:41:32 <davean> and tada, I'm done
13:42:24 <sproingie> i invented IO in other languages long before i heard of haskell
13:42:30 <LordBrain> i did something similar once, i think working on an lmbd interface, dont recall now exactly
13:42:52 <sproingie> the benefit of collecting actions into some list then executing them in one place was just *obvious* to me, and i wasn't even an FP geek at the time
13:43:02 <sproingie> tho i had been exposed to a lot of lisp via my emacs hacking
13:43:09 <LordBrain> i knew a lot of other langauges before i finally came to haskell, and i have to admit, i never invented io in any of them :/
13:43:40 <sproingie> the language i did that in was MOO, actually
13:43:56 <davean> mauke: Its that it *undoes* bad monad tutorials that makes it important I tihnk?
13:44:00 <LordBrain> not familiar with moo
13:44:13 <davean> LordBrain: not from the 90s?
13:44:20 <Sonolin> for programming MUDs/MOOs right?
13:44:33 <sproingie> yep.  lambdamoo specifically
13:44:37 <Sonolin> nice
13:44:49 <LordBrain> i am from the 90s
13:44:53 <LordBrain> sure
13:44:56 <LordBrain> i guess
13:44:56 <Sonolin> damnit all this MUD talk makes me want to re-experience them
13:44:58 <LordBrain> whatever that means
13:45:25 <LordBrain> i did oo, mostly in c++
13:45:31 <sproingie> Sonolin: it makes me want to *write* one.  but hardly anyone plays text MUDs anymore
13:45:40 <Sonolin> not true!
13:45:43 <mauke> davean: I don't know if there were monad tutorials at the time
13:45:47 <sproingie> no, really, hardly anyone
13:45:49 <Sonolin> I've heard at least 3 people in the last day say they're playing a MUD :p
13:45:53 <davean> mauke: as when?
13:45:57 <Sonolin> (in IRC at least)
13:46:07 <davean> mauke: I was talking about IO (IO ())
13:46:07 <sproingie> IRC is perhaps a little self-selecting there
13:46:09 <kadoban> I play nethack ... but no muds
13:46:14 <Sonolin> Aardwolf is still pretty popular I think
13:46:23 <LordBrain> we're too much of a hive minmd
13:46:25 <sproingie> i was into nethack for a while.  hell, i had my own fork of nethack for a while.
13:46:34 <LordBrain> people say stuff while i think it
13:46:44 <kadoban> It's pretty fun. 3.6 is hard though
13:46:46 <sproingie> then a couple months ago i disastrously burned out and deleted it and the repo copies
13:46:58 <Sonolin> damn that really sucks
13:47:14 <sproingie> it was very educational, i learned a lot of modern c++ along the way
13:47:22 <kadoban> I can't even imagine forking nethack. The code looks so so bad. It's like 80s awful horror code.
13:47:24 <sproingie> (my project was a port of the nethack codebase to c++)
13:47:38 <Aruro> i think data<+>instance declaration mastery is when u start thinking now i got it.
13:47:39 <sproingie> and yes, i deliberately chose something that awful, because it was both awful and fun
13:47:59 <sproingie> lambdamoo's codebase by comparison is the picture of elegance
13:48:06 <[exa]> sproingie: sorry to say that but porting nethack to c++ was predetermined to fail, the C-styled mess is actually a feature
13:48:24 <sproingie> [exa]: i did it, and was making pretty good progress at porting large chunks of it
13:48:32 <kadoban> Port nethack to haskell? Hehe
13:48:46 <davean> I feel porting nethack to Haskell would be far easier then to C++
13:48:50 <Aruro> there is already some dangeon crawler in haskell
13:48:57 <Aruro> or library to make one
13:49:08 <davean> Nethack and Haskell seem like they'd be pretty compatible
13:49:08 <sproingie> [exa]: however big picture, you're right.  NH's codebase at root is pretty damn intractible
13:49:10 <Sonolin> yea Lambdahack
13:49:17 <[exa]> sproingie: I didn't want to say that it's a bad idea, its actually a very good idea, but the good point about nethack is that the language is primitive and therefore hacking is game
13:49:29 <sproingie> [exa]: that's how i saw it
13:49:30 <Sonolin> in the README it also specifically mentions Nethack-like features as welcome PRs :)
13:49:40 <sproingie> the game here was simply to port it
13:50:08 <[exa]> if you ever found a last repo copy please ping me. :]
13:50:11 <LordBrain> i think someone should port llvm to haskell
13:50:20 <davean> LordBrain: ... why?
13:50:21 <LordBrain> as in, not even bindings, the whole thing in haskell
13:50:43 <davean> Oh I understood the horror you proposed
13:50:46 <[exa]> LordBrain: actually working on a similar ll language now
13:50:52 <sproingie> naturally it wasn't really for technical reasons i burned all my work
13:51:13 <LordBrain> exa great, i really just mean that kind of thing actually, it doesnt have to truly be llvm, just something that fills that niche
13:51:41 <[exa]> LordBrain: it will produce assembly from llvm-like code
13:51:50 <LordBrain> i have made some stuff myself, but i didnt publish
13:51:51 <sproingie> [exa]: it wasn't really that far along, it compiled as C++, but was still almost entirely ANSI C
13:52:03 <Myrl-saki> Does anyone here who visit /r/haskell remember the link to that reader thing that could be configured using CSS?
13:52:08 <[exa]> sproingie: did you ascend btw?
13:52:10 <sproingie> hell, converting NH's source to ANSI (it's K&R, yes) was actually more annoying
13:52:25 <sproingie> [exa]: yunno, i've never ascended a char outside of wizard mode
13:52:36 <Aruro> do u guys have thinking sessions, like no internet, no computer, just table and window?
13:52:36 <[exa]> nethack is brutal.
13:52:40 <sproingie> being a source hacker, naturally i played a lot in wizard mode
13:52:44 <LordBrain> i have, unpublished, a intel x86 assembly validator, sort of almost dissassembles completely, but not quite... really just enough to know instruction boundaries
13:52:51 <Myrl-saki> Ah, mdviewer.
13:52:58 <sproingie> Aruro: yep.  i call those "hikes"
13:53:00 <Myrl-saki> It was posted one month ago, wow, that's so long ago.
13:53:05 <LordBrain> exa, does it sound like something useful to you?
13:53:16 <sproingie> been raining and hailing, so no hikes lately.  sad sproingie :(
13:53:35 <Aruro> sproingie: yeah, or that :)
13:53:41 <LordBrain> it could be used for unit testing for example in your code gen
13:53:55 <[exa]> LordBrain: I'm actually doing a project that compiles out all gc-requiring stuff from haskell-like language, that llvm-alike only recently surfaced as a necessity
13:54:07 <[exa]> not a priority
13:54:34 <LordBrain> well, i'm hoarding it for now
13:54:38 <LordBrain> heh
13:54:40 <[exa]> :]
13:54:52 <LordBrain> let me know tho if you think it sounds valuable
13:55:23 <[exa]> Aruro: I'm riding a bike to work, if you choose a quiet path it's the best environment for practical thinking
13:55:47 <Tuplanolla> The beauty of LLVM is in the `.a` file architecture, but people always overlook that aspect, [exa].
13:55:49 <LordBrain> if there is an interest in people using it to unit test their code gens, then i might be persuaded to stop sitting on it and publish
13:56:18 <[exa]> Tuplanolla: really? please explain
13:56:24 <LordBrain> but if nobody cares anyway, i'll just continue hoarding
13:56:36 <Tuplanolla> @google aosa llvm
13:56:37 <lambdabot> http://www.aosabook.org/en/llvm.html
13:56:37 <lambdabot> Title: The Architecture of Open Source Applications: LLVM
13:56:45 <[exa]> LordBrain: published code without documentation is better than unpublished
13:56:57 <Tuplanolla> Read the part about linking, [exa].
13:59:23 <[exa]> Tuplanolla: yeah, this is supercool
13:59:29 <LordBrain> [exa], well, lets put it this way, as a hoarded thing, its my own little tool, an advantage over everyone else, that may not be much, but its a little something of value right, now if i publish and nobody uses it, i just gavve that up for no reason, but if people are going to use it, then i'll have the value it is to have contributed and enhanced the community code base and such. So... its only worth it to me to publish, if truly people would use i
13:59:29 <LordBrain> t.
13:59:33 <[exa]> didn't know about the suffix though :]
14:00:09 <davean> LordBrain: I sorta doubt your analysis
14:00:12 <[exa]> LordBrain: hard decision awaits!
14:00:16 <LordBrain> how so davean 
14:01:34 <Froggman> hi, guys, can someone give one or two examples where could I use (zip, unzip, zip3 and unzip3). Like a common usage for them
14:01:53 <tobiasBora> Hello,
14:02:00 <[exa]> LordBrain: approach it ecologically; will the publication enrich the world? :]
14:02:12 <LordBrain> its not hard actually, i am already decided to hoard, unless someone says, yeah i could really use a thing like that.. 
14:02:21 <tobiasBora> I'm doing a function to catch the errors of any function, with something like:
14:02:30 <tobiasBora> avoidErrors :: IO a -> IO a
14:03:02 <tobiasBora> However I've an error: Couldn't match type ‘a’ with ‘()’ ‘a’ is a rigid type variable bound by the type signature
14:03:05 <LordBrain> you get what it does, do you need that or not, what it does is you feed it a byte and anotehr and another, and you can check each time whether you are an instruction boundary or not, and so you can test your expectations about instruction boundaries
14:03:14 <tobiasBora> Expected type: IO a, Actual type: IO ()
14:03:28 <tobiasBora> Why () cannot be seen as 'a' ?
14:03:29 <[exa]> LordBrain: I guess  I don't need it now. But I'll remember you! :D
14:03:38 <pikajude> tobiasBora: () is (), not any type
14:03:48 <LordBrain> okay
14:03:50 <pikajude> nothing is type IO a
14:03:54 <Aruro> Froggman: zipWith is good
14:03:55 <Myrl-saki> Froggman: I use zip for parallel list processing.
14:03:57 <pikajude> except for, like, undefined
14:04:09 <dyreshark> Froggman: `Map.fromList $ zip foos bars` will give you a map of foos to bars.
14:04:16 <pikajude> tobiasBora: code?
14:04:33 <Aruro> Froggman: zip == zipWith (,)
14:04:55 <Aruro> @src zip
14:04:55 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
14:04:55 <lambdabot> zip _      _      = []
14:05:02 <LordBrain> [exa], i imagine this kinda thing might be useful for certain kinds of AI too, where you're trying random code, like genetic algorithms
14:05:18 <sproingie> logically it's zipWith (,) anyway
14:05:30 <tobiasBora> pikajude: What? I don't understand...
14:05:32 <mniip> dolio, hey look
14:05:34 <tobiasBora> my code looks like:
14:05:35 <Froggman> I need a common usage for zip3 and unzip3
14:05:36 <tobiasBora> avoidErrors f = do
14:05:38 <tobiasBora>     f `myCatchAny` -- Check if an error occured
14:05:40 <tobiasBora>          (\ex -> do putStrLn "An error occured")
14:05:44 <pikajude> can you use hpaste or something instead
14:05:49 <pikajude> oh, is that it?
14:05:56 <tobiasBora> pikajude: http://paste.debian.net/929338
14:06:01 <mniip> > Just reverse ~<*> Just "moo"
14:06:03 <lambdabot>  Just "oom"
14:06:06 <mniip> :t (~<*>)
14:06:06 <glguy> tobiasBora: then avoidErrors :: IO () -> IO ()
14:06:08 <lambdabot> Monoid' f (NT (->) (->)) Apply => f (a -> b) -> f a -> f b
14:06:14 <pikajude> tobiasBora: `f` can be IO a where a is any type
14:06:16 <sproingie> Froggman: zip3 is just for zipping three lists.  haskell isn't so hot at variable-arity functions, so it needs zip3 where some languages do it all with zip
14:06:24 <[exa]> Froggman: 2 weeks ago I gave students an assignment to write matrix multiplication only with zips/maps/folds; turned out to be lot shorter than handmade
14:06:32 <geekosaur> tobiasBora, in general when you have a type constraint IO a, it means a was specified by the caller, not by you
14:06:37 <tobiasBora> glguy: Oh yes of course, the "putStrLn" forces a to be ()...
14:06:40 <geekosaur> so you can't just say ()
14:06:47 <geekosaur> (or somethingt hat leads to ())
14:07:08 <tobiasBora> geekosaur: Yes, but I forgot that in case of error I force it to be IO ()
14:07:17 <tobiasBora> so now everything is clear, thank you
14:07:23 <dolio> mniip: What?
14:07:30 <mniip> dolio, applicatives as monoids
14:07:56 <mniip> :t mappend'
14:07:57 <lambdabot> forall o (p :: (o -> o, o -> o) -> o -> o) (k :: (o -> o) -> (o -> o) -> *) (f :: o -> o). Monoid' f k p => k (p '(f, f)) f
14:08:15 <mniip> :t \f k -> runNT mappend' $ Apply f k id'
14:08:17 <lambdabot> Monoid' g (NT (->) (->)) Apply => g (y -> a) -> g y -> g a
14:08:36 <mniip> I have monads too
14:08:38 <mniip> :t join'
14:08:40 <lambdabot> Monoid' f (NT (->) (->)) Compose => f (f a) -> f a
14:09:49 <sproingie> whaaaah?
14:10:35 <sproingie> that context doesn't parse for me
14:10:42 <mniip> which
14:10:49 <sproingie> Monoid' f (NT (->) (->)) Compose
14:10:52 <mniip> :k Monoid'
14:10:53 <lambdabot> (o -> o) -> ((o -> o) -> (o -> o) -> *) -> ((o -> o, o -> o) -> o -> o) -> Constraint
14:10:57 <mniip> :k NT
14:10:59 <lambdabot> (o -> o -> *) -> (* -> * -> *) -> (o -> *) -> (o -> *) -> *
14:11:03 <mniip> :k Compose
14:11:05 <lambdabot> (k -> *, k1 -> k) -> k1 -> *
14:11:16 <sproingie> well my head done asploded now
14:11:43 <[exa]> sproingie: it's a multiparameter typeclass
14:11:43 <Aruro> :k Monoid'
14:11:45 <lambdabot> (o -> o) -> ((o -> o) -> (o -> o) -> *) -> ((o -> o, o -> o) -> o -> o) -> Constraint
14:11:54 <Aruro> beauty
14:12:03 <mniip> well, Monoid' has 2 methods
14:12:08 <mniip> :t mempty'
14:12:10 <lambdabot> forall o (p :: (o -> o, o -> o) -> o -> o) (k :: (o -> o) -> (o -> o) -> *) (f :: o -> o). Monoid' f k p => Proxy p -> k (Id p) f
14:12:14 <mniip> :t mappend'
14:12:15 <sproingie> what's with the ticks?
14:12:15 <lambdabot> forall o (p :: (o -> o, o -> o) -> o -> o) (k :: (o -> o) -> (o -> o) -> *) (f :: o -> o). Monoid' f k p => k (p '(f, f)) f
14:12:27 <mniip> sproingie, I can't import Prelude hiding... in lambdabot
14:12:34 <mniip> so I had to define them as mappend' etc
14:12:47 <sproingie> ah
14:13:00 <Froggman> it's right that I can use zip and unzip to compress files? to compare 3 lists? 
14:13:27 <mniip> Froggman, zip/unzip have nothing to do with the DEFLATE compression algorithm
14:13:40 <mniip> :t zip
14:13:41 <lambdabot> [a] -> [b] -> [(a, b)]
14:13:53 <mniip> it's a function that takes two lists and returns a list of respective pairs
14:14:21 <sproingie> > zip [1,2,3] ["foo", "bar", "baz"]
14:14:23 <lambdabot>  [(1,"foo"),(2,"bar"),(3,"baz")]
14:15:12 <Tuplanolla> @hoogle gzip
14:15:12 <lambdabot> Data.Generics.Twins gzip :: GenericQ (GenericM Maybe) -> GenericQ (GenericM Maybe)
14:15:12 <lambdabot> Data.Conduit.Zlib gzip :: (MonadThrow m, MonadBase base m, PrimMonad base) => Conduit ByteString m ByteString
14:15:12 <lambdabot> Network.Wai.Middleware.Gzip gzip :: GzipSettings -> Middleware
14:15:23 <[exa]> what does the apostrophe in  »'(f, f)« mean anyway?
14:15:26 <ExpHP> > zip [0..] "Froggman"
14:15:28 <lambdabot>  [(0,'F'),(1,'r'),(2,'o'),(3,'g'),(4,'g'),(5,'m'),(6,'a'),(7,'n')]
14:15:34 <LordBrain> gzip is unrelated
14:15:36 <mniip> [exa], lifted tuple
14:15:36 <sproingie> @hoogle zlib
14:15:36 <lambdabot> package zlib
14:15:37 <lambdabot> Codec.Compression.Zlib.Lens zlib :: Format
14:15:37 <lambdabot> module Data.Conduit.Zlib
14:15:46 <sproingie> that's what you'd want for compression
14:15:49 <mniip> :k (Int, Char)
14:15:51 <lambdabot> *
14:15:52 <mniip> :k '(Int, Char)
14:15:54 <lambdabot> (*, *)
14:15:56 <LordBrain> gzip = compression, zip = making a list of pairs from two lists
14:16:06 <Tuplanolla> The first result is actually a generic zip.
14:16:13 <LordBrain> oh
14:16:20 <Tuplanolla> That's the joke.
14:16:30 <[exa]> oh, tuple of kinds. oh my.
14:16:34 <LordBrain> okay
14:16:36 <mniip> tuple of types
14:16:42 <LordBrain> are you sure its a joke?
14:16:46 <Froggman> thanks, so to compare 2 lists or processing 2 lists is right?, 1 digit/caracter by 1
14:16:52 <geekosaur> might be worth remembering that zip (not just gzip) is also a compression format, largely used on windows
14:16:53 <sproingie> it's a terrible name that's for sure
14:17:01 <[exa]> mniip: thanks :]
14:17:12 <sproingie> (gzip for generic zip that is)
14:17:21 <[exa]> oh so it's datakinds thing
14:17:25 <geekosaur> yes
14:17:43 <mniip> [exa], if we had 'data TC x y = DC x y', then (Int, Char) would be TC Int Char
14:17:51 <mniip> and '(Int, Char) would be DC Int Char
14:17:57 <mniip> and DC Int Char :: TC * *
14:18:14 <mniip> makes sense?
14:19:01 <alexv19> Can this code be simplified?
14:19:08 <alexv19> (r ^? responseBody . key "collection" . nth 0 . key "track" . key "id" . _Integer) <|> (r ^? responseBody . key "collection" . nth 0 . key "playlist" . key "id" . _Integer)
14:19:44 <[exa]> mniip: yeah, that's reasonable
14:20:07 <alexv19> is there a way to combine two prisms, so when one fails use another?
14:21:50 <mniip> alexv19, what would such a prism review?
14:21:55 <edwardk> alexv19: yes
14:22:05 <edwardk> (the first question anyways.)
14:22:37 <mniip> ay edwardk 
14:22:53 <edwardk> you can use <> to append two different folds into one fold
14:22:57 <mniip> look applicatives are monoids
14:23:01 <mniip> :t (~<*>)
14:23:03 <lambdabot> Monoid' f (NT (->) (->)) Apply => f (a -> b) -> f a -> f b
14:23:40 <edwardk> r^? responseBody . key "collection" . nth 0 . (key "track" . key "id" <> key "playlist" .  key "id") . _Integer
14:23:44 <edwardk> or something probably works
14:24:03 <edwardk> or even (key "track" <> key playlist)
14:24:07 <edwardk> factoring it further
14:24:27 <mniip> key ("track" <> "playlist")
14:24:28 <mniip> :D
14:24:48 <edwardk> r ^? responseBody . key "collection" . nth 0 . (key "track" <> key "playlist") . key "id" . _Integer
14:25:11 <edwardk> thats almost pretty
14:25:29 <edwardk> mniip: i don't recommend that last step =)
14:26:16 <edwardk> alexv19: that work for you?
14:26:39 <alexv19> edwardk: yes, thank you!
14:26:58 <edwardk> it still amuses me how much utility folks have gotten out of those combinators
14:27:18 <edwardk> the api was basically "write down true stuff about json"
14:27:24 <edwardk> oh it compiles, next.
14:31:27 <nitrix> What are the limitations of a language without first-class functions? Presumably you can still have higher-order functions, possibly via some function name/axiom/label system.
14:32:27 <nitrix> I'm assuming partial application becomes impossible?
14:32:37 <kadoban> Depends how not-first-class they are I suppose.
14:32:51 <Tuplanolla> I frequently use higher-order functions in C, nitrix.
14:33:03 <Tuplanolla> You just have to pass in the closure in a `void*`.
14:33:25 <nitrix> So you end up emulating the capture of the environment when needed?
14:34:31 <nitrix> Second question; is there a library for Haskell that works similarly to Chan and MVar but would be over the network?
14:35:05 <nitrix> (Been playing with erlang and I'm in exploratory bastard child phase of Haskell having a baby with Erlang :P)
14:37:01 <sproingie> cloud-haskell perhaps
14:38:15 <LordBrain> i think in old versions of ghc, i could use __LINE__ as the cpp macro for line number, but currently its assuming i mean a typed hole, how do i tell it i mean the CPP thing?
14:38:32 <glguy> LordBrain: did you turn on CPP?
14:38:35 <LordBrain> yes
14:38:49 <LordBrain> am i remembering wrong about the name of the macro?
14:38:55 <LordBrain> thats possible, i did it off my head
14:39:16 <glguy> LordBrain: works for me
14:39:25 <LordBrain> this is 7.10.3
14:39:33 <LordBrain> is it a known bug?
14:39:39 <sproingie> should work back to ancient ghc versions
14:40:02 <LordBrain> ancient didnt have the holes thing
14:40:11 <glguy> LordBrain: I'd guess you got the {-# Language CPP #-} pragma wrong in some way
14:40:38 <geekosaur> ^
14:40:50 <geekosaur> because if cpp is expanding it then it's not there for ghc to see as a hole
14:41:00 <geekosaur> so you are somehow not getting it expanded
14:41:07 <glguy> or you got the wrong number of underscores on each side (2)
14:41:20 <geekosaur> beware of things like primes, which confuse cpp into thinking it's not supposed to expand in a (char) literal
14:41:31 <geekosaur> or # which also means something special to cpp
14:41:35 <LordBrain> its highlighted correctly in vim, its only three letters other than the language part
14:41:46 <LordBrain> {-# LANGUAGE CPP #-}
14:41:49 <LordBrain> see an issue?
14:41:50 <Tuplanolla> See if you can `#define __LINE__` yourself and change the outcome, LordBrain.
14:42:15 <Tuplanolla> You should not be able to.
14:42:24 <LordBrain> i tried using -XCPP on the command line, still got the hole error
14:42:37 <sproingie> just add #error hey, cpp works
14:42:50 <glguy> LordBrain: It's going to be hard to guess what you're doing wrong. Can you paste some code that doesn't work to lpaste.net?
14:42:51 <sproingie> if you don't get that error, cpp ain't working
14:43:26 <LordBrain> it worked
14:43:31 <LordBrain> the #error i mean
14:43:52 <LordBrain> its __LINE__ yes? two underscores each side?
14:44:00 <geekosaur> yes
14:44:02 <sproingie> well that's just weird then.  should be __LINE__ yes
14:44:18 <Tuplanolla> What does my suggestion do, LordBrain?
14:44:48 * geekosaur will second glguy, send failing code to lpaste (or gist, etc.)
14:45:33 <LordBrain> warning: "__LINE__" redefined [-Wbuiltin-macro-redefined]
14:45:47 <LordBrain> but it still said   Found hole __LINE__ with type: [Char]
14:45:51 <Tuplanolla> Good. Your compiler is not to blame.
14:45:59 <Tuplanolla> Paste code now.
14:47:53 <LordBrain> the __LINE__ is inside a macro definition
14:48:00 <LordBrain> see if your compilers still work when thats the case
14:48:26 <LordBrain> i could paste, but its all intwined with nonpublic code, so you couldnt run it anyway
14:48:57 <glguy> That means you have to make a bit of code that isn't intertwined, but which exhibits the same problem.
14:49:35 <LordBrain> okay, i'll work something up
14:49:51 <Tuplanolla> The solution to nonpublic code is to publicize it.
14:53:22 <geekosaur> if it's inside a macro definition, the question might be how / where that macro is expanded
14:53:47 <geekosaur> traditional cpp has some weird gotchas (ANSI cpp tried to clean this up a bit with token splicing)
14:54:16 <lpaste> LordBrain pasted “cpp __LINE__ &  found hole” at http://lpaste.net/354931
14:55:05 <LordBrain> could be using __LINE__ inside a macro is improper.. maybe i need to notate that different, been a long time since i messed with cpp
14:55:42 <geekosaur> it should be usable in a macro
14:55:50 <geekosaur> again, depends on how it gets expanded
14:56:53 <LordBrain> does my lpaste code actually work for you? it gives the same error over here
14:56:54 <geekosaur> in partiuclar, __FILE__ and __LINE__ don't get expanded in a macro parameter list, but when that macro is expanded.
14:57:27 <geekosaur> (otherwise something like #define logger(x) _logger(x, __FILE__, __LINE__) wouldn't work as expected)
14:57:35 <hexagoxel> LordBrain: i doubt CPP parses bloo' as one full identifier. is ' even allowed in idents?
14:57:42 <LordBrain> ah
14:57:46 <LordBrain> that might be my issue
14:57:47 <hexagoxel> if you rename bloo' it works
14:57:50 <geekosaur> ut;s the '
14:57:55 <LordBrain> yeah
14:57:58 <LordBrain> thanks
14:57:59 <geekosaur> as I mentioned earlier be careful with primes
14:58:08 <geekosaur> cpp expects C code, it thinks it's in a char constant
14:58:19 <geekosaur> (yes, they can be multicharacter. traditional cpp doesn't check this)
14:58:47 <sproingie> it's almost as if cpp is some sort of bolted-on hack!
14:59:32 <sproingie> that is kinda blogpost-worthy though.  very unobvious behavior
15:00:23 <LordBrain> its working
15:00:41 <fragamus> monochrom are you here
15:19:54 <athan> Is there a... Cont RPC specification, which could define something like "run this JSON rpc method, then invoke this URL upon completion"? So we can be all asynchronous and stuff without discipline
17:01:43 <ertes> athan: sounds like something you would do with threads, not callbacks
17:02:36 <Welkin> athan: maybe you are thinking of javascript
17:05:12 <tobiasBora> Hello,
17:05:23 <tobiasBora> Can anyone explain me why this very short code : http://paste.debian.net/929372
17:05:35 <tobiasBora> gives me an error : ‘rawParse’ is not a (visible) method of class ‘RawRead’
17:07:29 <ertes> tobiasBora: the System.Console.ArgParser module only exports the *class* RawRead, but not its members
17:08:04 <geekosaur> or, check your argparser package version
17:08:30 <ertes> also consider using a different library…  last argparser release is from 2014
17:08:33 <pacak> So evilll
17:08:34 <benzrf> tobiasBora: also, that's just "rawParse = Just . rawParse"
17:09:13 <ertes> tobiasBora: optparse-applicative comes to mind
17:09:33 <ertes> not overly fond of it, but it's reasonably easy and reasonably powerful
17:14:42 <tobiasBora> Ok I'll try it thank you
17:15:34 <ertes> tobiasBora: here is a tutorial: https://ocharles.org.uk/blog/posts/2012-12-17-24-days-of-hackage-optparse-applicative.html
17:16:09 <ertes> at least for the very basics
17:31:06 <tobiasBora> ertes: I don't understand how you would define a builder for a "Maybe string", such that if the string is provided, it's "Just mystring", and else it's Nothing
17:32:01 <tobiasBora> Hum, maybe this is the solution http://stackoverflow.com/questions/32422339/how-to-parse-maybe-with-optparse-applicative
17:32:47 <ertes> tobiasBora: there are many ways, depending on what exactly you need
17:34:02 <ertes> tobiasBora: example: optional (strOption …)
17:43:26 <tobiasBora> ertes: I tried that, but I have an error:
17:43:37 <tobiasBora> The operator ‘<>’ [infixr 6] of a section must have lower precedence than that of the operand,
17:44:04 <tobiasBora> oh my bad
17:44:12 <tobiasBora> I forgot to remove a trailing <>
17:44:48 <tobiasBora> But I've a bug much more mysterious:
17:44:50 <tobiasBora> ghc: panic! (the 'impossible' happened)
17:45:24 <jordan35332> hi
17:45:36 <jordan35332> i need help on a really simple problem ^
17:46:17 <jordan35332> https://pastebin.com/MbZaJWGF
17:46:28 <jordan35332> i dont understand why this short code doesnt work
17:47:49 <jordan35332> "No instance for (Num String) arising from the literal ‘20’" what does this even mean
17:48:14 <geekosaur> it means you tried to compare a String to a number of some kind
17:48:47 <thimoteus> jordan35332: what do you expect will happen?
17:48:50 <geekosaur> Haskell does not convert things automatically for you. getLine produces a String; you cannot compare it directly to 20
17:48:51 <jordan35332> how can i transform the input of getLine to an int
17:48:57 <jordan35332> oh i see
17:49:53 <geekosaur> > read "20" :: Int
17:49:56 <lambdabot>  20
17:51:48 <jordan35332> alright im updating my code
17:52:48 <geekosaur> also I would suggest that instead of the `else error ""` you want something like `else return ()`
17:53:28 <tobiasBora> Ouch
17:53:55 <tobiasBora> I've so much errors that all the lines cannot fit in the Konsole history
17:54:08 <tobiasBora> I'm not sure to understand this error
17:54:16 <tobiasBora> Here is my portion of code:
17:54:18 <tobiasBora> http://paste.debian.net/929378
17:55:08 <tobiasBora> and the error : Couldn't match expected type ‘Integer -> b4’ with actual type ‘Parser (Int -> Int -> String -> String -> Maybe String -> UserParamScrapeTag)
17:55:13 <tobiasBora> Possible cause: ‘(<$>)’ is applied to too many arguments
17:55:21 <jordan35332> @geekosaur thx so much else return () is perfect
17:55:21 <lambdabot> Unknown command, try @list
17:57:50 <geekosaur> tobiasBora, shouldn't that be thing <$> param1 <*> param2 <*> ... ?
17:58:35 <tobiasBora> geekosaur: Hum well done, thank you!
18:17:52 <jordan35332> my uni forces us to go from python to haskell
18:17:55 <jordan35332> thats super weird
18:18:03 <EvanR> could be worse
18:18:11 <jordan35332> like i do stuff wrong all the time because i think of imperative programming
18:18:30 <ChaiTRex> Yeah, learning functional programming is hard at first.
18:18:55 <jordan35332> and there are so many weird rules
18:19:07 <jordan35332> "there has to be an else statement"
18:19:19 <jordan35332> "the function has to return sth"
18:19:20 <EvanR> because if then else isnt a statement
18:19:34 <EvanR> functions always return something in python too
18:19:48 <monochrom> "function"s
18:20:03 <jordan35332> yeah but it doesnt give errors when i just wanna run it to check for syntax errors
18:20:13 <jordan35332> when im not finished u know
18:20:17 <EvanR> part of functional programming is coming to terms with the hard truth of all these phenomena, and not just misunderstanding them 
18:20:40 <monochrom> OK, learn to use "undefined" for checking for syntax errors.
18:20:42 <jordan35332> i hope i will soon see the pros of functional programming
18:20:55 <dyreshark> what environment are you writing code in? some of them will tell you about syntax errors as you write your code
18:20:56 <jordan35332> yeah i guess i will have to do that
18:21:08 <monochrom> or, error "TODO"
18:21:10 <EvanR> missing an else *is* a syntax error
18:21:19 <jordan35332> im using sublime with sublimehaskell
18:21:30 <jordan35332> but most of the time i compile in the bash
18:22:07 <monochrom> But people who hate to be told "you're wrong" are going to have a hard time with Haskell (generally any statically typed language).
18:22:29 <EvanR> "i wish i didnt have to close tags in HTML, when i just want to check for syntax errors"
18:22:32 <jordan35332> nah im fine with that but at the moment all i see is what annoys me about haskell
18:22:43 <jordan35332> like i cant see the advantages at this point+
18:22:47 <jordan35332> i just started tho
18:23:07 <dyreshark> well, sublimehaskell's readme seems to indicate that it should be checking for errors as you code. i dunno why it's not in your case. ¯\_(ツ)_/¯
18:23:16 <EvanR> i didnt see theadvantage over python in the beginning, but i also didnt see any advantage in python either. it was too hard for me
18:23:23 <monochrom> If you're imperatively minded, you won't see advantages, you will only see disadvantages.
18:23:26 <jordan35332> evan what i mean is that in pythin i sometimes check "if blabla" and haskell tells me "yeah dont do that u have to use if then else"
18:23:50 <monochrom> The same way because I don't buy OO, every OO advantage you posit is going to be a disadvantage in my eyes.
18:23:54 <EvanR> if in python and haskell are two different things, thats why
18:24:06 <EvanR> you are thinking of haskells "when"
18:24:08 <jordan35332> yeah i didnt know that
18:24:19 <monochrom> Off-the-top-of-my-hat example being: every method must belong to one and only one class/object.
18:24:53 <jordan35332> haskell is fairly new isnt it? i would have to guess without that knowledge id say its very old
18:25:11 <Hafydd> No, Haskell is quite old.
18:25:19 <dyreshark> https://en.wikipedia.org/wiki/Haskell_(programming_language)
18:25:22 <EvanR> its python and haskell are about the same age
18:25:24 <dyreshark> >first appeared 1990
18:25:36 <monochrom> Some people are going to call it an advantage because it means with a good IDE you can just type in the name of a class/object and then press <tab> and then you get a "comprehensive" list of methods.
18:26:03 <jordan35332> i mean C is from 1972 and it feels much more modern to me than haskell haha
18:26:12 <taktoa> dyreshark: yeah but miranda was basically the same language and was around since 1985 https://en.wikipedia.org/wiki/Miranda_(programming_language)
18:26:24 <EvanR> that sounds like a gross misunderstanding of C
18:26:26 <monochrom> I call it a disadvantage because every really interesting operation is an interaction between several objects and it does not "belong" to one and only one of them.
18:26:44 <Hafydd> And of Haskell.
18:27:15 <dyreshark> taktoa: my point ("it's mildly old") still stands :p
18:28:11 <jordan35332> facebook is using some kind of haskell to filter spam, for performance reasons
18:28:17 <taktoa> dyreshark: yeah I was agreeing and adding that basically-haskell predates 1990
18:28:26 <monochrom> (To sure, you can correct me by pointing out: I've only described single-dispatch OO, there is multiple dispatch which resolves my issue. But then plain functions are simpler.)
18:28:27 <jordan35332> so i guess at least its easier to write efficient code in haskell?
18:28:28 <dyreshark> fair
18:28:41 <taktoa> jordan35332: I mean, it doesn't have performance issues, but it's not like you write haskell *for* performance
18:28:47 * geekosaur wonders idf "modern" here is supposed to mean "guesses the programmer's intentions, and enjoy the core dump or nonsense behavior when it guesses wrong"
18:28:59 <taktoa> like unless your measuring stick is python
18:29:14 <jordan35332> nah lol, compared to python haskell is super fast
18:29:24 <taktoa> yeah that's what I was saying
18:29:40 <dyreshark> nah, modern = resilience. it should corrupt random memory when it guesses wrong.
18:29:44 <dyreshark> this way, your program can keep running
18:29:49 <EvanR> C sort of took a turn for the unmodern when it came out, lisp was out dynamicing everybody at the time
18:29:57 <jordan35332> i think the article mentioned that facebook uses c++ layers for the performance sensitvie parts
18:29:59 <monochrom> Anyway, "a function has to return something" is already an advantage in itself, for its own sake. In my eyes anyway.
18:30:16 <jordan35332> yeah because you are used to it
18:30:16 <monochrom> If you already see it as an hindrance, you can give up all hope now.
18:30:25 <jordan35332> i never give up :p
18:30:42 <EvanR> jordan35332: its a good opportunity to think logically: if a  function literally returned *nothing*, what would happen?
18:30:56 <jordan35332> it shouldnt be executed imo
18:31:01 <jordan35332> haskell should just ignore it
18:31:01 <EvanR> segfault?
18:31:10 <monochrom> And underlying that is the more fundamental debate "what counts as a function?"
18:31:12 <EvanR> freeze?
18:31:26 <jordan35332> i see your point
18:31:38 <jordan35332> is haskell used for mathematical proofs?
18:31:44 <jordan35332> "proofs" sry
18:31:49 <taktoa> it's definitely inspired heavily by mathematics
18:31:52 <monochrom> No.
18:31:59 <taktoa> and similar languages are used for proofs
18:32:05 <jordan35332> alright
18:32:07 <monochrom> Agda would be used for mathematical proofs. Haskell isn't.
18:35:31 <EvanR> jordan35332: in a more sophisticated type system you could say your function or your procedure returns type Void (which is a type that has no hope of having a value)
18:36:01 <EvanR> and we could return to the question of what that would mean
18:36:37 <jordan35332> i think puting void in python is optional, like its the same as if the argument list were empy
18:36:55 <EvanR> do you mean Nothing, this is not the same thing
18:37:02 <dyreshark> you're thinking of C, i think
18:37:18 <jordan35332> oh yeah it could be C
18:37:29 <EvanR> void means something else in C
18:37:41 <taktoa> jordan35332: are you talking about a function that returns a value that logically carries 0 bits of information, or are you talking about a function that returns *nothing*?
18:37:53 <EvanR> that the return value is uninteresting, to the point of it warning you that you didnt ignore it
18:38:02 <jordan35332> i meant a function that doesnt return anything
18:38:35 <jordan35332> what i meant it in python "void function() and function() is the same thing if there is no return used in this function
18:38:42 <Maxdamantus> void in C means there is no value, but it's not used sensibly. They should've just had a unit type that had zero size.
18:38:43 <taktoa> like the type that represents values containing 0 bits of information is called () and can be thought of as a 0-tuple
18:38:55 <taktoa> there is exactly one value with the type ()
18:39:07 <taktoa> it is also called ()
18:39:51 <taktoa> (it's less confusing if you remember how the tuple syntax puns between the type and value level: (0, 0) :: (Int, Int))
18:40:41 <Maxdamantus> it's not just a warning if you didn't ignore it; it's an error. You can declare a variable as having `void` type, so you can't pass the result to a function or assign it to a variable.
18:40:55 <Maxdamantus> can't declare*
18:41:57 <monochrom> Here is another trait advantageous to some people and disadvantageous to the others. Haskell makes equational reasoning (analogous to highschool algebra) easier and running code by hand harder.
18:42:12 <EvanR> when one line of 100000 is wrong, you dont know which, and the result of the program is a white webpage, you begin to question the utility of "just having haskell (or PHP) ignore something"
18:42:27 <monochrom> It is an advantage to me. I want to do algebra. I don't want to simulate a computer.
18:43:07 <monochrom> But most programmers chose to be programmers precisely because they hate algebra. They want to run code by hand to "understand" what the code does.
18:43:08 <dolio> Does it actually make running code by hand harder?
18:43:20 <monochrom> Yes.
18:43:30 <EvanR> since the code is explicit, seems like itd be easier
18:43:30 <taktoa> monochrom: I'm not convinced that anyone is actually better at being a finite-state-automaton than a graph-reduction-machine
18:43:31 <Hafydd> [citation needed]
18:43:42 <taktoa> monochrom: because working memory is limited
18:43:44 <EvanR> you dont need to remember the invisible dynamic context
18:43:48 <taktoa> (in your brain)
18:43:55 <taktoa> EvanR: precisely
18:44:46 <monochrom> OK, I worded it wrong.
18:45:36 <monochrom> Haskell makes running code by hand look like doing highschool algebra rather than updating a program counter and a stack.
18:45:45 <monochrom> Better?
18:45:51 <taktoa> I agree with that.
18:45:57 <monochrom> Now the math haters have just cause to hate Haskell.
18:46:33 <EvanR> the question is, what mental model do people use to understand BASIC, perl, ruby, etc
18:46:41 <EvanR> its not algebra, and its not program countering
18:46:56 <EvanR> it seems almost mystic
18:46:59 <monochrom> a program counter and a table of mutable variable values and a stack.
18:47:12 <taktoa> EvanR: it's State (Map Text Text) :^)
18:47:13 <vaibhavsagar> monochrom: updating a program counter and a stack is still math, it's just really boring and tedious arithmetic
18:47:18 <monochrom> Usually the program counter is represented by a human finger.
18:47:28 * EvanR checks the standards for those languages
18:47:46 <monochrom> vaibhavsagar, you're preaching to a choir member.
18:48:24 <vaibhavsagar> "preaching to the converted" should be #haskell's motto
18:48:38 <monochrom> EvanR, the model I just described is explicitly taught by standard curricula.
18:49:04 <EvanR> it doesnt seem quite right
18:49:06 <monochrom> In fact you're preaching to a math major and a compsci phd.
18:49:07 <jordan35332> is it possible to call a function inside an (if then CALL FUNCTION else)?
18:49:14 <dolio> monochrom: I guess that works for C. Most languages are going to be more complicated than that these days, though.
18:49:28 <dolio> Have fun writing down all your closures. :)
18:49:40 <taktoa> jordan35332: if you want "if-then-else without the else", you probably want Control.Monad.when
18:49:54 <monochrom> Yes, Java adds a heap. (Well C does too, but not too necessary to make explicit.)
18:49:57 <jordan35332> nono i want the else
18:50:08 <taktoa> do you want "without the then"
18:50:12 <jordan35332> its just that i need to execute a function in the "then" part
18:50:25 <taktoa> by function do you mean "something that has side effects"
18:50:38 <jordan35332> sth that return an int
18:50:49 <monochrom> Indeed my university explicitly taught the explicit PC x global-vars x stack x heap model. (When it taught Java to 1st year's)
18:51:00 <ChaiTRex> > let f = (+ 1) in if 1 == 1 then f 1 else f 2
18:51:03 <lambdabot>  2
18:51:11 <monochrom> (These days it teaches Python instead. But I think same difference.)
18:51:21 <ChaiTRex> jordan35332: Yes, see above.
18:51:40 <na_th_an> my university still does java heap stack etc. We never really covered functional programmingd
18:51:47 <jordan35332> parse error (possibly incorrect indentation or mismatched brackets)
18:52:07 <taktoa> jordan35332: can you define it mathematically? if so, it is a function. if not, it is a program (in Haskell, a program with return type XYZ is denoted by the type IO XYZ)
18:52:07 <jordan35332> compared to the python interpreter i think that haskells error reports are hard to understand
18:52:31 <monochrom> jordan35332, you want to show the actual code you have so far, so we talk concretely not handwavingly "yes you can" "no you can't" "can too" "can not".
18:52:37 <jordan35332> ok
18:53:14 <jordan35332> https://pastebin.com/HsPDpwVh
18:53:23 <jordan35332> the part at the bottom is what is important
18:54:03 <monochrom> You can use "else return ()" or the "when" thing mentioned above.
18:54:07 <jordan35332> like i call the function flossaufField and i wanna check which argument is used, because there are two different play fields
18:54:07 <taktoa> jordan: indent "else if" by two spaces
18:54:22 <monochrom> ("when" is coded up by using "else return ()")
18:54:26 <taktoa> jordan35332: "return ()" is the IO action that means "do nothing"
18:54:54 <monochrom> But you can't have "then let a = whatever"
18:55:25 <jordan35332> yeah thats the part where im stuck
18:55:50 <jordan35332> because the second function call depends on the arguemnts used in the first function call
18:56:16 <jordan35332> @taktoa the two spaces didnt change anything
18:56:17 <lambdabot> Unknown command, try @list
18:56:27 <jordan35332> taktoa the two spaces didnt change anything
18:56:27 <taktoa> jordan35332: yeah the problems run deeper than that
18:56:47 <jordan35332> its not ur language, but u get what im trying to do?
18:56:57 <monochrom> Yes.
18:57:18 <jordan35332> at the end i just wanna know if the field that is chosen has value 1 and if it has value it should say true
18:57:30 <taktoa> you want `let a = if s == "foo" then Just (foo x y) else if s == "bar" then Just (bar x y) else Nothing`
18:57:57 <taktoa> and then use `case` to inspect `a`
18:58:03 <monochrom> if s == "spielfeldA" then print (spielfeldA x y == 1) else if if s == "spielfeldB" then print (spielfeldB x y == 1) else print "You misspelled the name of the spielfeld!"
18:58:14 <taktoa> that also works
18:58:23 <monochrom> If you really want to factor out the "== 1", there is a way. But KISS for now.
18:58:54 <monochrom> Also in a few minutes you will want to read my newly written http://www.vex.net/~trebla/haskell/string-print-show-read.xhtml
18:59:11 <monochrom> (Consider it a prophecy!)
19:00:10 <jordan35332> thanks taktoa but it says
19:00:33 <taktoa> jordan35332: use monochrom's thing
19:02:21 <jordan35332> im so confused
19:02:33 <jordan35332> i used yours monochrom
19:02:36 <jordan35332> but it still says
19:02:45 <jordan35332> parse error (possibly incorrect indentation or mismatched brackets)
19:02:56 <geekosaur> @paste your current code
19:02:56 <lambdabot> Haskell pastebin: http://lpaste.net/
19:03:02 <Koterpillar> you have two "if" there
19:03:03 <monochrom> It may be sensitive to how you break lines and indent.
19:03:06 <Koterpillar> "else if if s"
19:03:14 <monochrom> Oh hehe, my typo
19:03:31 <jordan35332> now it works i think
19:04:29 <glguy> ?type \ a b c d e -> if if a then b else c then d else e
19:04:30 <lambdabot> Bool -> Bool -> Bool -> t -> t -> t
19:05:35 <jordan35332> Couldn't match expected type ‘[Char]’
19:05:35 <jordan35332>                 with actual type ‘Integer -> Integer -> Integer’
19:05:40 <EvanR> are we overlooking jordan35332's overuse of Bools?
19:05:43 <jordan35332> : (
19:06:02 <jordan35332> Probable cause: ‘spielfeldB’ is applied to too few arguments
19:06:58 <jordan35332> EvanR this is my first haskell program, dont me so strict on me :D
19:08:50 <jordan35332> i think the problem is that the function parameters are treated as chars and we use them as int
19:09:59 <monochrom> There is no overuse of Bool.
19:10:11 <EvanR> just what i suspect from nested if then elses
19:10:35 <dmj`> is there no intercalate for Builder
19:12:01 <glguy> dmj`: You'll probably have to mix mconcat and intersperse
19:14:05 <jordan35332> idk why it doesnt work
19:14:15 <monochrom> Show latest code.
19:15:53 <jordan35332> https://pastebin.com/fUM4d315
19:16:05 <jordan35332> there is sth wrong in line 59
19:16:21 <jordan35332> https://thepasteb.in/p/Z4hPlwo9WzNiG
19:17:29 <monochrom> It loads fine in my ghci. No error.
19:17:49 <jordan35332> yeah it loads fine
19:17:51 <Koterpillar> you didn't paste any code that has that expression
19:18:00 <jordan35332> but what happens if you use this:
19:18:01 <Koterpillar> ah
19:18:07 <Koterpillar> you have to refer to it as a string
19:18:09 <jordan35332> flossAufFeld 1 2 spielfeldA
19:18:13 <jordan35332> in ghci that is
19:18:18 <Koterpillar> flossAufField 1 2 "spielfeldA"
19:18:39 <jordan35332> omg
19:18:44 <jordan35332> Koterpillar youre right
19:19:05 <jordan35332> is it possible to make it work when you forgot the " " =
19:19:06 <jordan35332> ?
19:19:15 <monochrom> This is why it is important to tell people how to reproduce the error, step by step.
19:19:21 <Koterpillar> yes
19:19:33 <dmj`> glguy: ah hmm, can’t find a more general interperse than one that operates on lists
19:19:35 <jordan35332> how?
19:19:38 <Koterpillar> do you want the answer or hints?
19:19:46 <dmj`> intersperse* :) 
19:19:49 <jordan35332> ill take the answer its 4:19 am
19:20:01 <Koterpillar> flossAufFeld x y s = print (s x y == 1)
19:20:06 <glguy> dmj`: I don't know of one either. I'd have expected an intercalate to work on lists, too
19:20:17 <glguy> what type do you need to support?
19:20:19 <monochrom> But then you can't give a string parameter.
19:20:25 <Koterpillar> yeah
19:20:33 <jordan35332> Koterpillar instead of "do" ?
19:20:48 <Koterpillar> you don't need "do" for just one expression
19:21:18 <monochrom> Actually you need to understand why the double quotes.
19:21:30 <dmj`> glguy: Data.ByteString.Builder (Builder)
19:21:42 <Koterpillar> jordan35332: in ghci, run :t "spielfeldA" and :t spielfeldA
19:21:55 <glguy> dmj`: No, in place of the list I mean
19:22:03 <monochrom> You're hardcoding a string, this is why you need double quotes. The same way you write like s=="xxx", rather than s==xxx.
19:22:39 <jordan35332> i cant compile it since i added flossAufFeld x y s = print (s x y == 1)
19:22:48 <jordan35332> blatt1.hs:100:17: parse error on input ‘if’
19:22:58 <monochrom> If the string comes from user input and you put it in a variable, you don't worry about double quotes.
19:23:07 <glguy> itercalate :: [a] -> [[a]] -> [a]; so for Building I would expect :: Builder -> [Builder] -> Builder
19:23:16 <jordan35332> https://pastebin.com/5QQE01Mn
19:23:31 <glguy> builderIntercalate x y = mconcat (intersperse x y)
19:23:31 <Koterpillar> jordan35332: that is your _whole_ function now
19:23:40 <Koterpillar> remove lines 2 and 3 now
19:25:14 <Koterpillar> you don't need that "else" portion because if you misspell the name of the spielfeld (as I did every time now, lol) the compiler will tell you
19:25:34 <jordan35332> wow thats awesome Koterpillar
19:25:43 <dmj`> glguy: oh nice, that’s perfect
19:26:25 <jordan35332> Koterpillar now it gives the error if you use flossAufFeld 2 3 "spielfeldB" instead of flossAufFeld 2 3 spielfeldB
19:26:33 <Koterpillar> right
19:26:36 <jordan35332> there isnt any easy fix to this right?
19:26:41 <jordan35332> i mean i dont need it
19:26:48 <Koterpillar> you can go back to where you were
19:26:56 <Koterpillar> there are ways, but no easy ways
19:26:58 <jordan35332> nah ill stick with urs ^
19:27:03 <jordan35332> alright
19:27:09 <Koterpillar> and do you really need the string version?
19:27:40 <Koterpillar> you might, if you, for example, take the function names from user/network (which might or might not be a good idea)
19:30:51 <ertes> jordan35332: is there any meaning to the number 1 that the spielfeld function returns?
19:31:00 <ertes> or does that 1 just represent "yes"?
19:31:14 <jordan35332> there are two players who play that game where u destroy ships
19:31:17 <monochrom> Haha, underuse of Bool.
19:31:23 <jordan35332> if there is a boat of player one its 1
19:31:27 <jordan35332> if there isnt its 0
19:31:35 <jordan35332> if theres a boat of player two its 2
19:31:46 <sm> old school! like it!
19:32:03 <ertes> jordan35332: then you may want to define an extra type:  data Player = Black | White  deriving (Eq, Ord, Show)
19:32:16 <ertes> jordan35332: type Spielfeld = Int -> Int -> Maybe Player
19:32:27 <ertes> or… well…
19:32:38 <ertes> data Spieler = Schwarz | Weiß  deriving (Eq, Ord, Show)
19:32:38 <ertes> =)
19:32:49 <taktoa> lol
19:32:59 <jordan35332> i really like this irc channel btw
19:33:04 <jordan35332> super helpful
19:35:13 <ertes> jordan35332: also the 'flossAufBrett' function is kind of an anti-pattern…  you should just use the individual spielfeld function directly
19:35:36 <ertes> if the information whether a field is occupied is really the only information you need, then you can just use 'isJust'
19:35:41 <jordan35332> some code is like a template we got
19:35:54 <jordan35332> and we need to fill in a few functions
19:36:07 <jordan35332> so atm we dont have the freedom to change stuff for this exercise ^
19:37:04 <ertes> @let data Spieler = Schwarz | Weiß  deriving (Eq, Ord, Show);  spielfeld 3 _ = Just Schwarz; spielfeld _ 4 = Just Weiß; spielfeld _ _ = Nothing
19:37:06 <lambdabot>  Defined.
19:37:08 <ertes> :t spielfeld
19:37:10 <lambdabot> (Eq a1, Eq a, Num a1, Num a) => a1 -> a -> Maybe Spieler
19:37:24 <ertes> > spielfeld 3 7
19:37:27 <lambdabot>  Just Schwarz
19:37:29 <ertes> > isJust (spielfeld 3 7)
19:37:32 <lambdabot>  True
19:38:01 <jordan35332> look at this
19:38:08 <jordan35332> sehrSchlechteIdee k x y s = if k == 1 then print (s x y == 1) else if k == 2 then print (s x y == 2)
19:38:21 <jordan35332> k is now either 1 or 2 (which players turn it is)
19:38:23 <monochrom> Is that your prof's code?
19:38:29 <jordan35332> but i need the integer of k not the char
19:38:45 <ertes> k is a numeric type
19:38:49 <jordan35332> i think some higher semester students made it
19:39:20 <jordan35332> parse error on input ‘bombeAuf’
19:39:21 <monochrom> OK, what ertes is saying is that the author is not using the strength of Haskell.
19:39:41 <ertes> :t let sehrSchlechteIdee k x y s = if k == 1 then print (s x y == 1) else if k == 2 then print (s x y == 2) in sehrSchlechteIdee
19:39:43 <lambdabot> error: parse error on input ‘in’
19:39:51 <ertes> :t let { sehrSchlechteIdee k x y s = if k == 1 then print (s x y == 1) else if k == 2 then print (s x y == 2) } in sehrSchlechteIdee
19:39:52 <monochrom> I will add that you should demand a refund. :)
19:39:53 <lambdabot> error: parse error on input ‘}’
19:40:01 <ertes> oh, come on…
19:40:27 <ertes> oh, there is no 'else'
19:40:38 <jordan35332> haha :D
19:40:55 <jordan35332> i study computer science its just for a semester
19:40:55 <ertes> ok, then k isn't really anything…  the whole thing is a syntax error =)
19:41:15 <jordan35332> ertes i just forgot the else ^
19:41:23 <jordan35332> i cant get used to it haha
19:42:44 <jordan35332> i have a question concerning the style guide of haskell
19:43:02 <jordan35332> is it like python that there is a char limit of 79 i think per line?
19:43:28 <m0cesta> sequenceA lazy or not?
19:43:44 <taktoa> jordan35332: I always obey the 80 character limit, but I'm kind of OCD about that in any language
19:43:44 <monochrom> Some people say yes, some people say no.
19:43:56 <m0cesta> WTF?
19:44:00 <jordan35332> and if so, is it allowed to break a string by starting a new line?
19:44:06 <taktoa> no, you can't
19:44:07 <monochrom> I use 89. It's the 21st century already.
19:44:07 <jordan35332> or do i have to use sth like \
19:44:16 * geekosaur uses 96
19:44:31 <geekosaur> string literals? you can use string gaps
19:44:32 <taktoa> jordan35332: use `concat ["foooooooooo","baaaaaaaaaar"]`
19:44:36 <geekosaur> althpugh most people hate them
19:44:42 <Sornaensis> string gaps?
19:44:53 <dyreshark> m0cesta: i think that answer wasn't directed at you :)
19:45:17 <monochrom> Actually, my answer is good for both questions.
19:45:30 <m0cesta> dyreshar: ok, and what about question? :)
19:45:42 <dyreshark> 80 column limit
19:45:55 <dyreshark> is it a good thing
19:46:00 <ertes> jordan35332: write code that is readable and appeals to your sense of aesthetics…  some people even dispense with layout entirely and uses braces and semicolons everywhere, but it's a rare sight =)
19:46:30 <taktoa> I mostly see it in GHC's code
19:46:53 <jordan35332> ok
19:47:23 <lpaste> geekosaur pasted “string gaps” at http://lpaste.net/354937
19:47:36 <ertes> even this horrible, ugly, despicable, disgusting style of starting lines with punctuation is popular for some reason
19:47:53 <MarcelineVQ> ertes: oh you :>
19:48:00 <taktoa> e.g.: https://github.com/ghc/ghc/blob/master/compiler/hsSyn/Convert.hs#L147-L153
19:48:47 <monochrom> ertes: There was a time I did that. But only to please the dumber auto-indenter in the old days.
19:48:59 <jordan35332> Ipaste ty
19:49:04 <jordan35332> lpaste ty
19:49:37 <monochrom> But I don't know why for example SPJ did it.
19:49:40 <jordan35332> did i just say ty to a bot
19:49:47 <monochrom> Yes.
19:49:50 <jordan35332> its 5 am
19:49:56 <jordan35332> ty geekosaur
19:50:02 <geekosaur> heh
19:50:21 <monochrom> Don't worry, I thank my computers and iPhone all the time.
19:50:25 <geekosaur> ('sokay, I just tried to reply into my mail window. getting late here too...)
19:50:40 <monochrom> Especially just before I dispose of them.
19:51:21 <ertes> when i thank my computer it means that i haven't been out for too long
19:51:24 <taktoa> reminds me of when people type "ls" into irc :)
19:51:25 <dyreshark> is it more of a "thank you for your service," or "thank you for going quietly"?
19:51:31 <jordan35332> whenever i type sudo init 0 i feel like a bad person
19:51:40 <taktoa> I use sudo systemctl poweroff
19:51:51 <ertes> i just press the power button…
19:51:55 <geekosaur> just make sure it's to the correct system...
19:52:06 <monochrom> for their service and parting sadly
19:52:53 <taktoa> pressing the power button feels like smothering your computer
19:52:55 <jordan35332> touch /this
19:53:01 <jordan35332> cannot touch '/this': Permission denied
19:53:15 <ertes> why?  it's just another button that triggers just another event
19:53:21 <monochrom> Just last week I said goodbye to 20 floppy diskettes that was OS/2 Warp installation diskettes.
19:53:25 <geekosaur> enh. on modern systems just pressing it can send shutdown or suspend, it's press and hold that crashes it
19:53:48 <monochrom> (But don't worry, I already tested that they have gone bad and no longer readable.)
19:53:48 <jordan35332> press and hold makes me feel like a murder
19:53:56 <jordan35332> shhh itll be all over soon lmao
19:53:58 <ertes> if i use it only for powering on, it will be useless 99% of the time, which seems like kind of a waste =)
20:05:29 <monochrom> I recommend reprogramming it for Morse code input. :)
20:07:04 <Chong> hi everyone
20:07:15 <Chong> would I be able to get some help with type families
20:07:49 <Chong> I have a type
20:07:51 <Chong> newtype Column pgType = Column HPQ.PrimExpr deriving Show
20:08:26 <Chong> and I just want a type function that turns (Column a) into a (Column Maybe a)
20:12:14 <ertes> Chong: your question seems to have a kind error
20:12:28 <ertes> try to explain the application instead
20:14:43 <jordan35332> do you remember my ship battle program
20:14:54 <jordan35332> now I need to change values
20:15:06 <jordan35332> but i thought haskell would have immutable data types
20:15:28 <ertes> jordan35332: state doesn't require mutability
20:15:42 <ertes> > iterate (\x -> 2*x + 1) 0
20:15:45 <lambdabot>  [0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,2...
20:15:47 <ertes> this is a stateful list
20:16:09 <jordan35332> https://pastebin.com/zZJ9hu1H
20:16:22 <jordan35332> from line 7 to line 43
20:16:40 <jordan35332> when you throw a bomb, i want the field to get the value 0
20:16:48 <jordan35332> but im not sure if i can do that in haskell
20:17:18 <c_wraith> You can't change a constant.
20:17:43 <c_wraith> But you can pass a current state around, and pass a new current state to the next round when needed
20:18:12 <ertes> jordan35332: exercise: write a function:  bomb :: Int -> Int -> (Int -> Int -> Int) -> (Int -> Int -> Int)
20:18:19 <Axman6> Chong: as far as I can see foo (Column x) = Column x should do what you want, but obviously doesn't make a change to the PrimExpr which you might need
20:18:20 <jordan35332> yeah i think i redraw the whole board and change only one value -- where the bomb was thrown
20:18:37 <ertes> jordan35332: this function should return a spielfeld with the given position changed to 0
20:19:05 <jordan35332> yeah this is what i need
20:19:43 <ertes> jordan35332: try to write it, and keep the following in mind: whenever you see a type of the shape "A -> B -> C" you can read it as "A -> (B -> C)" and vice versa
20:20:06 <jordan35332> im not sure what that means
20:20:17 <jordan35332> i guess those arent implications
20:20:27 <taktoa> jordan35332: it means "a function that takes A and returns a function that takes B and returns C"
20:20:33 <ertes> it means: in haskell "binary function" and "function that returns a function" are the same concepts
20:20:48 <taktoa> X -> Y means "a function that takes X and returns Y"
20:21:01 <ertes> jordan35332: you haven't learned about types i take it?
20:21:23 <jordan35332> i didnt have a single class on haskell yet
20:21:46 <jordan35332> this is the first exercise but the class didnt start yet which is a bit stupid
20:21:55 <ertes> "::" means "of type"
20:22:03 <ertes> > 3 :: Integer
20:22:05 <lambdabot>  3
20:22:21 <jordan35332> > "asdf"  :: String
20:22:23 <lambdabot>  "asdf"
20:22:26 <ertes> that's called a type signature
20:22:30 <ertes> :t "asdf"
20:22:32 <lambdabot> [Char]
20:22:46 <jordan35332> okay
20:22:51 <ertes> :t replicate
20:22:53 <lambdabot> Int -> a -> [a]
20:23:03 <jordan35332> but i have no clue how to reassign the whole board
20:23:15 <ertes> replicate is a function…  it takes an Int and an 'a' and return a list of 'a', for all types 'a'
20:23:28 <ertes> > replicate 4 'a'
20:23:31 <lambdabot>  "aaaa"
20:23:34 <ertes> makes sense so far?
20:23:52 <monochrom> Do not "change" the board. Create a new board, based on the old board but also with the updates you want.
20:24:16 <jordan35332> yes
20:24:27 <taktoa> also jordan35332, they actually are implications in a certain sense. in logic, P -> Q means "given P, I can prove Q". a function is a thing that takes a value (a value can be thought of as a proof that a type has at least one inhabitant) and returns another value. so when you write a function of type X -> Y you are basically proving that, if a value of type X exists, then a value of type Y exists.
20:24:54 <jordan35332> yeah i have a maths backround
20:24:55 <ertes> now the notation "Int -> a -> [a]" may look a bit weird, but there is a very good reason for it:  it's actually read like this:  Int -> (a -> [a])
20:25:07 <jordan35332> im a math senior who switched to cs
20:25:21 <ertes> which would mean: 'replicate' does not actually take two arguments, but it takes one argument of type Int and returns a *function*
20:25:26 <ertes> would you agree?
20:25:55 <jordan35332> yeah i guess so
20:26:06 <monochrom> My http://lpaste.net/52480 is a toy game where you would think I should have "changing" numbers but I don't need "change".
20:26:07 <ertes> (BTW, you can read the "->" like set notation for functions)
20:26:31 <ertes> jordan35332: this is actually the truth…  'replicate' is indeed that
20:26:35 <ertes> :t replicate 4
20:26:38 <lambdabot> a -> [a]
20:26:42 <taktoa> yeah (X -> Y) is morally the same as (Y^X) where ^ is superscript
20:26:54 <ertes> (replicate 4) is the function that takes an 'a' and returns a list of 'a', namely the given argument repeated 4 times
20:27:09 <ertes> for all 'a'
20:27:17 <ertes> > (replicate 4) 'a'
20:27:19 <lambdabot>  "aaaa"
20:27:28 * taktoa lambdabot screams
20:27:44 <ertes> and indeed the notation "replicate 4 'a'" is read as "(replicate 4) 'a'"
20:28:56 <jordan35332> the exercise sheet tells us to not use list syntax or list functions
20:29:11 <jordan35332> idk if i can use replicate
20:29:20 <monochrom> Sure, but they're teaching you how to read types.
20:29:25 <taktoa> jordan35332: they want you to define it inductively (with recursion)
20:29:30 <ertes> 'replicate' is a function…  not to use list syntax probably means not to use something like "[x,y,z]"
20:29:38 <ertes> but use (x : y : z : []) instead
20:30:04 <monochrom> You can surely study replicate and learn some lessons and still not use it in your code.
20:30:07 <Chong> I'm a newbie with type families
20:30:09 <Chong> I have
20:30:15 <Chong> type family ColNul (a :: Column *) :: * 
20:30:17 <Chong> type instance ColNul ('Column a)  = Column (Nullable a)
20:30:37 <Chong> but it gives the error "‘Column’ of kind ‘* -> *’ is not promotable"
20:30:56 <taktoa> jordan35332: try writing `length` using recursion. then you'll get the flavor of how to write a function like replicate
20:31:06 <Chong> is there any way around this?
20:31:36 <Koterpillar> Chong: what's Column, and why don't you want ColNul a = Column (Nullable a) instead?
20:32:41 <jordan35332> i cant do it rn
20:32:43 <jordan35332> idk
20:32:44 <Chong> I want to convert a column to a nullable column
20:33:07 <Chong> newtype Column pgType = Column HPQ.PrimExpr
20:33:14 <ertes> jordan35332: exercise: write an infinite list of ones
20:33:29 <ertes> > ones
20:33:32 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:33:33 <Chong> so Columns are all actuall the same type
20:33:34 <ertes> jordan35332: like this one
20:33:43 <monochrom> It's 5am there and I think you should prescribe sleep rather than moar exercises. :)
20:34:02 <Chong> ColNul should be more aptly called ColToNullableCol
20:34:11 <Koterpillar> Chong: so why not ColNul :: * -> *
20:34:23 <Koterpillar> Chong: ColNul (Column a) = Column (Nullable a)
20:34:38 <ertes> well, we're in the same time zone apparently, and i'm fully awake…  i shouldn't assume that everybody has a messed up sleep cycle like me =)
20:35:07 <MonadHendrix> what timezone is that
20:35:26 <ertes> CEST
20:35:50 <Chong> I can't do that
20:35:53 <Chong> it's just a syntax error
20:36:18 <Axman6> Chong: I think you'll need to share more of your code, it appears you trying to make something quite simple more complex than it needs to be, but it might be warranted in the context of the other work you're doing
20:37:52 <Koterpillar> Chong: works for me: type family ColNul (c :: *) :: *; type instance ColNul (Column a) = Column (Nullable a)
20:38:39 <iqubic> Hello guys.
20:38:50 <iqubic> > show "Hello World"
20:38:53 <lambdabot>  "\"Hello World\""
20:39:02 <iqubic> What is that weirdness there?
20:39:26 <monochrom> Read my http://www.vex.net/~trebla/haskell/string-print-show-read.xhtml for why.
20:39:30 <Koterpillar> iqubic: lambdabot always applies show to the result
20:39:59 <Koterpillar> iqubic: otherwise, how can it print the value (which might or might not be of type String)?
20:40:38 <iqubic> Ah, I see.
20:40:49 <iqubic> So it took my String, and showed it twice.
20:41:53 <Chong> holy shit
20:42:01 <Chong> thanks Koterpillar
20:42:18 <Koterpillar> yw
20:42:19 <MarcelineVQ> idk about that double show explanation, read requires the escaped \" as well. read and show are typically defined to interperet what you give them in the same way you'd see them in source code. and since " " has meaning to ghc and ghci you need to escape them
20:44:08 <MarcelineVQ> I suspect monochrom's link will say similar but much more clearly
20:49:40 <monochrom> This breaks my heart: Between Haskell 1.2 and 1.3, "Import declarations no longer have a renaming clause. Qualified names should be used to handle name clashes."
20:50:14 <monochrom> But there is also this gem: "n+k patterns are still present, but their use is officially discouraged."
20:50:32 <monochrom> It took that long to kill n+k patterns :)
20:50:43 <MarcelineVQ> what was the downside of n+k?
20:50:48 <iqubic> What is an n+k pattern?
20:51:39 <ertes> fib (x + 2) = fib x + fib (x + 1)
20:51:56 <jle`> iqubic: back in the old days, we'd write things like fac (n + 1) = (n+1) * fac n
20:52:23 <jle`> but it was pretty silly
20:53:20 <jle`> http://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010
20:53:26 <MarcelineVQ> but the same can be done with viewpatterns in an even odder looking way yeah? foo ((+1) -> x) = x
20:53:57 <MarcelineVQ> are n+k discouraged because it's both weird and not general enough?
20:54:43 <MarcelineVQ> I guess the difference is you don't have n anymore with that view example
20:55:34 <MarcelineVQ> nvm, you don't anyway
20:56:33 <geekosaur> n+k is discouraged because it can easily lead to hard to diagnose partial functions
20:57:31 <MarcelineVQ> hmm, I see that here https://sites.google.com/site/haskell/notes/nkpatterns
20:57:39 <ertes> MarcelineVQ: i think that's not the same
20:58:25 <ertes> foo (subtract 5 -> n) | n >= 5 = …
20:58:28 <ertes> more like that
20:59:31 <ertes> at least view patterns support easy binding
20:59:43 <ertes> foo n'@(subtract 5 -> n) = …
20:59:49 <Axman6> > let foo 0 = 1; foo 1 = 1; foo (pred -> n) = foo n + foo (pred n) in foo 15
20:59:52 <lambdabot>  987
21:01:04 <MarcelineVQ> oh yeah neat so you can 'get the n back'
21:01:37 <monochrom> https://sites.google.com/site/haskell/notes/nkpatterns is wrong to use the "informal semantics" and "formal semantics". Both of them are not for types, only for what happens when a program is run.
21:01:38 <ertes> i think the idea of n+k patterns wasn't so bad, but it had weird extra "features"
21:02:18 <ertes> also it would work much better if we had a Group class
21:03:01 <ertes> hmm, probably not
21:04:05 <ertes> the way you can write code in curry and mercury is quite nice, which is basically n+k patterns on steroids…  i wish we had that in haskell
21:04:08 <monochrom> Oh yikes, I'm wrong, there is a paragraph saying "These identities all preserve the static semantics".
21:06:26 <ertes> reverse (xs ++ [x]) = x : reverse xs
21:08:26 <monochrom> You won't want to know how the compiler does it.
21:08:35 <MarcelineVQ> too much x rev (\(x:xs) -> xs ++ [x] -> x:xs) = x : reverse xs
21:08:58 <monochrom> Because if you know, then the logical (pun intended!) conclusion is that time and space are even harder to predict than Haskell's.
21:09:24 <MarcelineVQ> oops, should be rev
21:09:49 <MarcelineVQ> also that lambda isn't exhuastive, exit stage left
21:10:13 <monochrom> Whereas Haskell just requires you to understand lazy evaluation, and once you do, it's pretty invariant across different compilers and different versions...
21:11:45 <ertes> yeah, sure
21:11:59 <monochrom> This logic programming nicety requires you to know exactly what heuristics the compiler is using to solve the constraints, what are the complexities of the multitudes of clever constraint solvers, under what brittle condition does the compiler fall back to brute-force search. And it changes every time a new version comes out.
21:12:31 <ertes> the code is still nice though =)
21:12:52 <ertes> at least for some algorithms
21:13:22 <monochrom> Whereas predicting Haskell time and space is merely chemistry, predicting logic language time and space is biochem.
21:20:12 <rotaerk> hmm not really sure how best to format a big chunk of code wrapped in a finally
21:20:31 <rotaerk> seems like it'd have been more convenient if the arguments hadn't been reversed, such that the final action be specified first
21:23:24 <rotaerk> hmm, guess it looks the best if I wrap it in ``
21:23:52 <monochrom> I sometimes do this. When formatting "x = A `finally` B" (in which A is a do-block and B is a do-block), I indent A by 4, put `finally` on its own line and indent by 2, and B by 4.
21:27:10 <monochrom> Haha there are Coq proofs and others for how STG correctly implements lazy evaluation. https://wiki.haskell.org/Language_and_library_specification#Related_work
21:29:20 <monochrom> Actually it may be more like: "x = do" 1st line, rest of A below and by 4, "`finally` do" on its own line and by 2, rest of B below and by 4.
21:31:11 <rotaerk> monochrom, thanks
21:42:58 <Myrl-saki> Hai. I need halp.
21:44:19 <jmnoz[m]> do you have an appointment?
21:44:28 <Myrl-saki> lmao
21:44:34 <Myrl-saki> I'm thinking of a proper type for it.
21:44:49 <Myrl-saki> foo :: MVar -> IO String -> IO a
21:45:00 <Myrl-saki> MVar serves as a buffer, IO String as a producer and IO a as a type.
21:45:24 <tsani> (you're missing a type parameter for your MVar)
21:45:29 <Myrl-saki> MVar String
21:45:43 <tsani> Cool
21:45:55 <tsani> A return type IO a suggests that this runs forever
21:45:59 <Myrl-saki> Basically, a serial ExtensibleState(think XMonad) thingy.
21:47:27 <JuanDaugherty> unresolved anaphora: the it for which you need halp
21:50:55 <Axman6> Myrl-saki: what is the a?
21:51:18 <Axman6> your description doesn't make much sense :\
21:52:10 <Myrl-saki> You use it like..
21:52:29 <Myrl-saki> foo buffer (read file) :: Io Int
21:52:31 <Myrl-saki> IO*
21:53:05 <Myrl-saki> The reason why there is a buffer there is because if it doesn't match, you add it to the buffer.
21:53:12 <Myrl-saki> You can have multiple `foo` reading for different types.
22:07:00 <ertes> Myrl-saki: why don't you explain what you're trying to do…  in your explanation try not to use the words "buffer", "producer" and "lmao"
22:08:23 <ertes> rotaerk: another option is:  (`finally` c) $ do …
22:08:37 <rotaerk> good point
22:09:05 <ertes> rotaerk: and if your name happens to be ertes, you might also do this:  do Codensity (\k -> k () `finally` c); …
22:09:10 <ertes> =)
22:12:19 <Myrl-saki> ertes: foo acc call, `foo` will first check if `acc`, an `MVar String` contains the data it needs. (A type-value tuple), and if it does, then `foo` will return with the value and the tuple removed from acc. Otherwise, keep running `call` and appending to acc.
22:13:18 <ertes> Myrl-saki: explain the problem, not the solution
22:13:50 <Myrl-saki> ertes: I did explain the problem. A serial ExtensibleState.
22:14:09 <iqubic> Well, I'm lost.
22:14:25 <iqubic> I don't understand that short problem description.
22:14:26 <Myrl-saki> I guess the proper method is to just have one huge sum type.
22:14:55 <Myrl-saki> iqubic: Serial. In the Haskell-sense, encoding as a byte stream or whatsover.
22:15:15 <ertes> i think you're explaining only a small part of the problem, and it doesn't really help in isolation
22:15:25 <iqubic> Can someone give me an example of a product data type in Haskell?
22:15:30 <ertes> iqubic: (,)
22:15:47 <iqubic> ertes: Why is that not a sum data type.
22:15:57 <ertes> iqubic: it is, but it's a trivial one
22:15:59 <iqubic> I don't really understand the difference there.
22:16:07 <jle`> iqubic: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
22:16:20 <ertes> iqubic: read 'Either' as (+), and (,) as (*)
22:16:39 <iqubic> How does that help?
22:16:41 <ertes> iqubic: alternatively: read constructors as summands and fields as factors
22:16:44 <Myrl-saki> ertes: It's really just extending ExtensibleState. A proper example would be interfacing between server and client.
22:17:09 <Myrl-saki> ertes: You have a `send :: a -> IO ()` in the client
22:17:28 <Myrl-saki> ertes: And `recv :: MVar String -> IO String -> IO a` in the server.
22:17:33 <Myrl-saki> That's mixing some typeclasses.
22:17:45 <iqubic> Myrl-saki: "Extending and Extnsible state" seems like a tautology.
22:17:54 <ertes> Myrl-saki: like a concurrent queue?
22:18:19 <Myrl-saki> ertes: Concurrent in the sense of multiplexing?
22:18:37 <ertes> Myrl-saki: in the sense of "can be written to and read from from multiple haskell threads"
22:18:46 <Myrl-saki> ertes: Ah nah.
22:19:02 <Myrl-saki> ertes: The MVar there was for state.
22:19:17 <Myrl-saki> s/MVar/IORef/g
22:19:19 <Myrl-saki> My mistake.
22:19:41 <ertes> ok, now it makes slightly more sense…  now why is it mutable state?  why is it not just…  well…  state?
22:20:07 <Myrl-saki> ertes: Well.
22:20:28 <Myrl-saki> ertes: I guess it's because the type system is not expressive enough, or so.
22:21:01 <Myrl-saki> ertes: I'd totally prefer `:: IO String -> IO a`, where `IO String` would preserve state if "reading" fails.
22:21:21 <Myrl-saki> ertes: But we can't express that in the type system. So instead, we append it to the buffer.
22:22:02 <ertes> Myrl-saki: i'm at a loss…  i have no idea what you're trying to do…  so you're reading, say, from a file and updating some state based on the data read, and if reading fails, you want to rewind the state to some earlier one?
22:22:21 <iqubic> So a rational number of the form (a % b) is a product type?
22:22:31 <Myrl-saki> ertes: I think I have to give an actual example.
22:22:31 <Axman6> iqubic: yep
22:22:33 <ertes> iqubic: well, it is internally
22:22:41 <iqubic> ertes: What do you mean?
22:22:53 <ertes> iqubic: it's a type with two fields internally: a numerator and a denominator
22:22:57 <Myrl-saki> ertes: Let me write up a quick program.
22:23:03 <Myrl-saki> Err... "program.
22:23:12 <ertes> Myrl-saki: yeah, that would be helpful
22:23:57 <ertes> iqubic: the idea of products and sums is that types form a commutative semiring w.r.t. isomorphisms
22:24:28 <iqubic> Right. I understand that.
22:24:33 <Axman6> iqubic: they're porduct types in the sense that: () can be thought of as 1, Bool can be thought of as 2 (it has two constructors, 1 + 1), Maybea can be thought of as a + 1 (it has as many inhabitants as a, plus the Nothing constructor). Either a b is a + b because it has as many inhabitants as a plus as many inhabitants as b, and (a,b) is a * b, because it has as many inhabitants as all combinations of the inhabitants of a and b
22:24:34 <ertes> iqubic: a type like (Either A B, Either A C) can be read as (A + B) * (A * C)
22:24:41 <ertes> whoops
22:24:47 <ertes> (A + B) * (A + C)
22:25:35 <iqubic> So a function of type (a -> b) is a product type? Is that correct?
22:25:55 <iqubic> Because each value of a could map onto any one of the values of b.
22:26:07 <ertes> it is a product type, but a special one:  b^a
22:26:08 <Axman6> a -> b is actually b^ a
22:26:14 <Axman6> b^a
22:26:17 <iqubic> Why do you say that?
22:26:31 <iqubic> Oh wait, I just explained that.
22:26:32 <iqubic> LOL
22:26:39 <ertes> iqubic: Bool -> Integer ≃ Integer^Bool ≃ Integer^2 ≃ (Integer, Integer)
22:27:21 <iqubic> ertes: Right. If f1 :: Bool -> Interger then we have (f1 True, f1 False)
22:27:30 <Axman6> it basicaslly counts "how many possible functions can have the type a -> b"
22:27:33 <ertes> iqubic: yeah
22:27:35 <iqubic> I actually know how to write the iso for that.
22:28:14 <ertes> iqubic: exercise:  data Lens a b = Lens (a -> b) (b -> a -> a)
22:28:27 <iqubic> Sure.
22:28:31 <iqubic> I know what a lens is.
22:28:34 <ertes> show why this is isomorphic to:  newtype Lens a b = Lens (a -> (b, b -> a))
22:28:47 <Axman6> there's a whole series of exercises around that type if you're interested
22:28:51 <jle`> iqubic: don't worry about what Lens is, just think of it as an arbitrary name
22:28:59 <ertes> iqubic: ^ that's the exercise
22:29:09 <iqubic> How can you do it?
22:29:17 <ertes> iqubic: use the laws of semirings
22:29:23 <jle`> might as well be Foo a b = Foo (a -> b) (b -> a -> a), and Foo a b = Foo (a -> (b, b -> a))
22:29:27 <ertes> iqubic: commutative semirings that is
22:29:30 <iqubic> The the laws of WHAT NOW?
22:29:43 <ertes> iqubic: associativity, commutativity, distributivity
22:30:00 <Axman6> https://github.com/tonymorris/lets-lens if you're interested, the first exercise is build around the Lens type above
22:30:18 <taktoa> ertest is saying to prove b^a * (a^a)^b = (b * a^b)^a
22:30:21 <jle`> iqubic: start with the first one being (a -> b, b -> a -> a
22:30:32 <jle`> convert it to your familiar algebra language
22:30:37 <iqubic> Axman6: You don't need to give me a lesson on lenses, I know what those are.
22:30:41 <ertes> iqubic: let me give you a shorter version of the same exercise:  prove: ∀ a b. (a -> b, b -> a -> a) ≃ a -> (b, b -> a)
22:31:00 <iqubic> Not possible. Sorry.
22:31:21 <jle`> iqubic: convert it to your familiar algebra symbols if you're more comfortable with that
22:31:33 <jle`> iqubic: what is (a -> b, b -> a -> a) ?
22:31:36 <iqubic> I don't know how to do that. Sorry.
22:31:40 <ertes> iqubic: start by converting (->) to (^) and (,) to (*)
22:31:41 <jle`> you were just doing it fine earlier :)
22:31:47 <iqubic> I was?
22:31:48 <iqubic> How?
22:31:50 <Myrl-saki> ertes: http://ix.io/rPg
22:31:50 <jle`> iqubic: you were able to see that (a -> b) as b^a
22:31:53 <jle`> and that (a, b) was a + b
22:31:55 <jle`> er, a * b
22:32:14 <iqubic> Oh, yeah I was
22:32:15 <abb4s> hey every body i have a simple lookup function  but it give a error  about "‘v’ is a rigid type variable bound by the type signature for lookup ..." .source and error : https://paste.ubuntu.com/24458506/
22:32:31 <jle`> mhm. you already showed that you know enough to do this
22:32:32 <iqubic> I'll try to convert (a -> b, b -> a -> a)
22:32:35 <abb4s> im new in haskell thankyou if you can help me
22:32:55 <jle`> abb4s: the error is actually one line above that one
22:33:09 <jle`> 'Cannot match type `v` with `Maybe v`'
22:33:10 <iqubic> (,) is a sum type? I thought ertes said it was a product type
22:33:12 <Myrl-saki> ertes: The typeclasses there are either (a) not complete; or (b) wrong.
22:33:15 <ertes> Myrl-saki: and server and client are on different machines?  that's what i take from the Serial constraint
22:33:19 <jle`> iqubic: it is a product type, i mentioned that i made a typo :)
22:33:34 <iqubic> Ah, I didn't see that.
22:33:36 <Myrl-saki> ertes: Well, the only requirement is that they're different programs.
22:33:45 <jle`> abb4s: the line you pasted tells you where 'v' comes from, but the actual error is that you are giving a 'v' when it's expecting 'Maybe v'
22:33:49 <jle`> abb4s: are you familiar with Maybe ?
22:34:01 <ertes> iqubic: you can use regular equational reasoning, except that you're not using the equation symbol, but the isomorphicness symbol =)
22:34:22 <iqubic> What is the isomorphicness symbol?
22:34:27 <ertes> Myrl-saki: or that
22:34:30 <iqubic> And what am I trying to prove?
22:34:36 <iqubic> I lost that.
22:34:36 <Myrl-saki> ertes: Mhm.
22:34:41 <ertes> iqubic: there is one in the exercise i gave you =)
22:34:46 <ertes> iqubic: the last version
22:34:49 <jle`> prove that (a -> b, b -> a -> a)   is the same as     (a -> (b, b -> a))
22:35:08 <iqubic> I have no idea how to type that isomorphicness symbol on my machine.
22:35:10 <jle`> sorry i probably shouldn't be saying anything
22:35:19 <abb4s> jle`: it say i should do some thing like this : lookup :: Eq k => k -> [(k,Maybe v)] -> Maybe v
22:35:21 <ertes> iqubic: just use "~" or something…  it's not terribly important
22:35:26 <iqubic> jle`: It's fines.
22:35:36 <ertes> iqubic: it's just important to keep in mind that those aren't *equal*, but just *isomorphic*
22:35:40 <taktoa> iqubic: the exercise is basically prove that b^a * (a^a)^b = (b * a^b)^a using only the commutative semiring laws
22:35:57 <jle`> aka, the things you learned in 8th grade algebra
22:36:13 <jle`> abb4s: your original type seems reasonable
22:36:32 <jle`> abb4s: it's the stuff you're doing in your lambda that is ill-typed
22:36:34 <ertes> iqubic: start by converting (->) and (,) notation to your more familiar symbols
22:36:36 <jle`> try pulling it out as a helper function
22:36:45 <iqubic> ertes, I'll do that.
22:36:53 <Myrl-saki> a -> b -> c ~ b -> a -> c
22:36:54 <jle`> abb4s: lookup k l = foldr f Nothing l
22:37:03 <jle`> what would the type of 'f' be ?
22:37:15 <iqubic> a -> b ~ b^a
22:37:28 <iqubic> (a, b) ~ a * b
22:37:36 <ertes> iqubic: yeah
22:37:42 <abb4s> jle`:  IT is a function : foldr :: (a -> b -> b) -> b -> [a] -> b
22:37:53 <Myrl-saki> b^a * (a^a)^b = b^a * (a^b)^a = (b*a^b)^a
22:37:58 <Myrl-saki> I think?
22:38:16 <jle`> abb4s:i mean, the function 'f'
22:38:21 <jle`> in what i wrote
22:38:25 <jle`> foldr (some function) Nothing l
22:38:30 <jle`> what is the type of "some function", here?
22:38:48 <taktoa> Myrl-saki: I would expand out the first step into two steps by using (X^Y)^Z = X^(Y * Z) and the commutativity of *
22:38:57 <Myrl-saki> taktoa: Ah
22:38:59 <Myrl-saki> True.
22:39:07 <Myrl-saki> That also make
22:39:12 <Myrl-saki> a -> b -> c ~ (a, b) -> c
22:39:15 <Myrl-saki> :D
22:39:18 <ertes> please try not to spoil it for iqubic, if you know the answer =)
22:39:19 <taktoa> yep :)
22:39:49 <abb4s> jle`: you mean the data type of return value ??
22:40:04 <jle`> abb4s: you have `foldr (blahblah) Nothing l
22:40:07 <jle`> what is the type of blahblah?
22:40:09 <jle`> is it Int -> Bool?
22:40:16 <jle`> is it Char -> (String, Double) ?
22:41:27 <jle`> every value in haskell has a type
22:41:28 <iqubic> Guys, stop spoiling the answer for me.
22:41:28 <ertes> Myrl-saki: so it is about concurrent state, as well as IPC
22:42:03 <iqubic> Anyways I see what a -> b -> c ~ (a, b) -> c
22:42:20 <abb4s> jle`: thank you dude , it is solved , the type should be f::a->b->Maybe b and i dont have care for it 
22:42:22 <ertes> iqubic: prove it
22:42:24 <iqubic> f a b c = f (a, b) c
22:42:43 <iqubic> Or not that.
22:42:46 <jle`> abb4s: not quite
22:43:03 <jle`> abb4s: in the function input for foldr, the second argument and the result type should be the same type
22:43:12 <jle`> it's (a -> b -> b) for some a and b
22:43:22 <jle`> so in your case, it can't be (a -> b -> Maybe b)
22:44:23 <jle`> it should actually be (a -> Maybe b -> Maybe b) :)
22:44:38 <abb4s> jle`: you are right , but it works
22:45:04 <ertes> abb4s: you may be interested in my foldr tutorial: http://ertes.eu/tutorial/foldr.html
22:45:48 <abb4s> jle`: the source : https://paste.ubuntu.com/24458566/ , so why it works ??
22:45:50 <abb4s> !!
22:45:54 <iqubic> a -> b -> c ~ (c^b)^a
22:46:27 <jle`> abb4s: let's look at the types of everything going on
22:46:35 <abb4s> ertes: thank you
22:46:36 <iqubic> (a, b) -> c ~ c^(a * b)
22:46:40 <jle`> abb4s: foldr :: (a -> b -> b) -> b -> [a] -> b
22:46:50 <jle`> your list here is [(k,v)], so a ~ (k, v)
22:47:03 <jle`> so you have foldr :: ((k, v) -> b -> b) -> b -> [(k, v)] -> b
22:47:15 <abb4s> yes
22:47:16 <jle`> your result type is 'Maybe v'
22:47:19 <jle`> so b ~ Maybe v
22:47:23 <iqubic> (c^b)^a = c^(a * b)
22:47:27 <iqubic> a -> b -> c ~ (c^b)^a
22:47:31 <iqubic> (a, b) -> c ~ c^(a * b)
22:47:33 <iqubic> (c^b)^a = c^(a * b)
22:47:36 <jle`> abb4s: so you have foldr :: ((k, v) -> Maybe v -> Maybe v) -> Maybe v -> [(k, v)] -> Maybe v
22:47:40 <iqubic> There. That proves that.
22:48:12 <jle`> abb4s: so that actually matches the function you wrote
22:48:29 <jle`> abb4s: the function you wrote was ((k, v) -> Maybe v -> Maybe v), so that's why it typechecks :)
22:48:45 <iqubic> can we get back to my isomorphism puzzle?
22:48:48 <jle`> abb4s: in `\(k2,val) y -> if k1==k2 then Just val else y`, k2 :: k, val :: v, and y :: Maybe v
22:49:11 <iqubic> I figured out that a -> b -> c ~ (a, b) -> c
22:49:19 <ertes> iqubic: sure, go ahead
22:49:22 <jle`> abb4s: in your if/then/else statement, you return (Just val :: Maybe v) if the keys match, or (y :: Maybe v) if they don't.  success!
22:49:43 <jle`> abb4s: but note that this behavior is a bit different than 'lookup' usually behaves or is expected to behave
22:49:51 <iqubic> I got that far. Not sure where to go next though.
22:50:01 <jle`> abb4s: your implementation typechecks, but the behavior might not be what you want
22:50:24 <jle`> er actually, wait, this might already be ok, nvm :)
22:50:51 <abb4s> jle`: becuase we dont want Maybe v as return data type for lookup ? yes ? 
22:51:05 <jle`> you do want Maybe v as the result of lookup
22:51:12 <jle`> you're good
22:51:15 <jle`> i just misread something :)
22:51:45 <ertes> iqubic: b^a * (a^a)^b ≃ (b * a^b)^a
22:52:00 <ertes> iqubic: for all a, b
22:52:13 <iqubic> Sure.
22:52:14 <ertes> iqubic: this is the original exercise translated into (*) and (^)
22:52:26 <iqubic> And I understand the translation.
22:52:46 <abb4s> jle`: all is becuase of returning Nothing , i want to if lookup fail then return Nothing , so i has to return all as Maybe v , is there another solutoin for it ?
22:53:01 <jle`> abb4s: this is the typical way it is done
22:53:08 <ertes> iqubic: (b * a^b)^a ≃ b^a * (a^b)^a  -- (^) distributes over (*)
22:53:17 <jle`> abb4s: you could also define a version that finds *all* matches, as well
22:53:21 <iqubic> Sure
22:53:44 <ertes> iqubic: (a^b)^a ≃ a^(b*a)  -- exponential law
22:53:46 <jle`> lookupAll :: Eq k => k -> [(k, v)] -> [v]
22:53:48 <abb4s> jle`: how ? 
22:54:04 <iqubic> ertes: where next?
22:54:07 <ertes> iqubic: b*a ≃ a*b  -- commutativity
22:54:10 <jle`> instead of returning `Maybe v` (zero or one result), you can return `[v]` (any number of results)
22:54:29 <iqubic> Right, and then you just undo the exponential law you just did.
22:54:33 <iqubic> And that's that.
22:54:33 <ertes> iqubic: (a^b)^a ≃ a^(b*a) ≃ a^(a*b) ≃ (a^a)^b
22:54:49 <abb4s> jle`: so what happen if lookup fail ? it just return empty list ?
22:54:58 <ertes> iqubic: which is basically a prove that 'flip' is an isomorphism
22:55:03 <jle`> yes; it'll return an empty list if there are no matches
22:55:03 <ertes> s/prove/proof/
22:55:08 <iqubic> Yeah. It really is.
22:55:33 <iqubic> Now can you bring it all together?
22:55:48 <abb4s> jle`: you are right ! :) really thank you 
22:55:54 <jle`> no problem!
22:56:23 <ertes> iqubic: to sum up:  (b * a^b)^a ≃ b^a * (a^b)^a ≃ b^a * a^(b*a) ≃ b^a * a^(a*b) ≃ b^a * (a^a)^b
22:56:33 <iqubic> Right.
22:57:02 <ertes> i have left out quite a few details, which would be required in a formal proof, but it's good enough
22:57:06 <iqubic> Can I have another excercise like this? Took me a bit to understand what you wanted me to do.
22:57:31 <iqubic> I'd like to try the next one all on my own though.
22:58:17 <ertes> iqubic: easy or challenging?
22:58:18 <jle`> what does `(a + b)^2 = a^2 + 2ab + b^2` mean, in types?  and, can you write the isomorphism it implies?
22:59:21 <ertes> iqubic: jle` actually already give you the easy one i would have given you, so try that next =)
22:59:26 <ertes> *gave
22:59:40 <iqubic> (a + b)^2 is (a, b) -> Bool
22:59:59 <jle`> almost
23:00:11 <iqubic> That's not quite right?
23:00:16 <iqubic> I thought it was.
23:00:46 <Koterpillar> iqubic: check with 1^2 or 0^2
23:00:55 <jle`> iqubic: (,) is a product, right?
23:01:07 <jle`> and a -> b is b^a, right?
23:01:26 <iqubic> wait, (a + b)^2 is Bool -> Either a b
23:01:35 <jle`> yes
23:01:44 <iqubic> Because Either is a sum tyoe
23:01:45 <ertes> although i would have phrased it very differently
23:01:56 <iqubic> how would you have phrased it?
23:02:38 <iqubic> now, what do I do with a^2 + 2ab + b^2
23:02:52 <jle`> i believe in you
23:03:02 <iqubic> Also, I know the binomial expasion laws, so the original equation must be true.
23:03:23 <iqubic> It comes back to Pascal's triangle there.
23:03:29 <ertes> conjecture: (Bool -> Either A B) is isomorphic to Either (Bool -> A) (Either (Either (A, B) (A, B)) (Bool -> B))
23:03:35 <jle`> mhm. it's definitely true
23:03:37 <iqubic> Now I need to put it in types
23:03:38 <ertes> is that true, and if yes, does it look like something familiar?
23:04:01 <jle`> iqubic: once you get the types, the interesting part is writing the isomorphism
23:04:12 <iqubic> I don't have the types yet.
23:04:13 <ertes> gives the exercise a bit of a mystery touch =)
23:04:20 <jle`> the function from (Bool -> Either a b) -> (whatever the second thing is)
23:04:28 <jle`> and the function from (whatever the second thing is) -> (Bool -> Either a b)
23:04:42 <iqubic> jle` I know what an isomorphism is.
23:06:19 <iqubic> Alright time to turn a^2 + 2ab + b^2 into a type.
23:06:29 <ertes> it's already a type
23:06:44 <iqubic> yeah, but I need the haskell type signature.
23:06:57 <iqubic> a^2 is Bool -> a
23:07:08 <iqubic> b^2 is Bool -> b
23:07:27 <iqubic> What the heck is 2ab?
23:07:37 <ertes> iqubic: what's 2?
23:07:38 <jle`> maybe try looking at it as 2*a*b
23:07:50 <jle`> and recognizing that you've seen * somewhere before :o
23:08:08 <iqubic> Oh, I'm stupid
23:08:18 <jle`> definitely not stupid :)
23:08:21 <iqubic> (2, (a, b))
23:08:38 <iqubic> 2ab is this ^^^
23:08:40 <MarcelineVQ> oh neat, I see it now
23:08:42 <ertes> or (a, b) + (a, b), if you want =)
23:08:52 <iqubic> sure.
23:08:53 <jle`> or (Bool, a, b)
23:09:27 <iqubic> ertes, that makes 2ab = Either (a, b) (a, b)
23:09:45 <ertes> iqubic: not equal to
23:09:53 <iqubic> but an isomorphism
23:10:05 <jle`> the fact that (Bool, a, b) is isomorphic to Either (a, b) (a, b) is itself an interesting thing :)
23:10:22 <iqubic> Yeah. It is.
23:11:05 <jle`> @djinn (Bool, a, b) -> Either (a, b) (a, b)
23:11:06 <lambdabot> f (a, b, c) =
23:11:06 <lambdabot>     case a of
23:11:06 <lambdabot>     False -> Left (b, c)
23:11:06 <lambdabot>     True -> Right (b, c)
23:11:18 <jle`> @djinn Either (a, b) (a, b) -> (Bool, a, b)
23:11:18 <lambdabot> f a =
23:11:18 <lambdabot>     case a of
23:11:18 <lambdabot>     Left (b, c) -> (False, b, c)
23:11:18 <lambdabot>     Right (d, e) -> (False, d, e)
23:11:22 <jle`> aw, so close
23:11:31 <jle`> would have been really cool if djinn had got the second one right
23:11:46 <jle`> but i suppose that's not super fair to ask
23:12:08 <jle`> i'm actually surprised it got something reasonable for the first one
23:12:32 <iqubic> So a^2 + 2ab + b^2 ~ Either (Bool -> a) (Either (Bool, a, b) (Bool -> b)
23:12:36 <iqubic> )
23:12:44 <ertes> iqubic: here is an interesting exercise:  find a type x such that: Maybe (Bool, Maybe (Either Ordering Ordering)) ≃ (Ordering, x)
23:12:46 <jle`> mhm.  it might be nice to write Either in infix
23:12:52 <jle`> s/nice/neat i guess
23:13:05 <jle`> (Bool -> a) `Either` (Bool, a, b) `Either` (Bool -> b)
23:13:11 <iqubic> Sure.
23:13:28 <jle`> to make it a bit more visually similar
23:13:37 <jle`> but yeah, now just to write the isomorphisms
23:13:41 <jle`> i wonder if djinn gets this right
23:14:00 <jle`> close your eyes if you want to figure this out on your own :)
23:14:27 <jle`> @djinn ((a, b) -> Bool) -> ((Bool -> a) `Either` (Bool, a, b) `Either` (Bool -> b))
23:14:27 <lambdabot> Cannot parse command
23:14:31 <jle`> aw
23:14:54 <iqubic> Now I need to prove that Bool -> (a, b) ~ (Bool -> a) `Either` (Bool, a, b) `Either` (Bool -> b)
23:15:03 <jle`> @djinn ((a, b) -> Bool) -> (Either (Bool -> a) (Either (Bool, a, b) (Bool -> b)))
23:15:03 <lambdabot> -- f cannot be realized.
23:15:27 <iqubic> Where is it getting f from?
23:15:35 <jle`> it's calling whatever i wrote f, i guess
23:15:49 <iqubic> So, the isomorphisms.
23:16:00 <jle`> the proof is simpler to do in algebra form, (a + b)^2 = (a + b)(a + b) = a^2 + ab + ba + b^2 = a^2 + 2ab + b^2
23:16:02 <iqubic> I don't see how *I* can do it.
23:16:07 <jle`> but the interesting thing is writing the function
23:16:10 <jle`> the two functions
23:16:15 <iqubic> It is a complex function?
23:16:20 <ertes> the isomorphisms are tedious, but possible
23:16:35 <iqubic> I don't like writing tedious and hard code.
23:16:47 <jle`> for me it's kind of simple if you reason about it in english
23:16:49 <ertes> you pretty much need to enumerate all the individual cases
23:17:20 <jle`> if i have (a + b)*(a + b), what do i really have?
23:17:24 <jle`> i either have (1) two a's
23:17:27 <jle`> (2) an a and a b
23:17:31 <jle`> (3) a b and an a
23:17:34 <jle`> (4) two b's
23:17:40 <iqubic> Right.
23:17:53 <jle`> so that's exactly what a^2 + ab + ba + b^2 means
23:17:58 <iqubic> Let me look at the type signatures, and try to get something that works
23:18:02 <jle`> or, what a^2 + 2ab + b^2 means
23:18:35 <jle`> you either have (1) two a's, (2) an a and a b, in two different orderings, or (3) two b's
23:18:49 <jle`> but yes the isomorphism is admittedly a bit tedious so feel free to skip it if you understood what i just wrote
23:18:51 <ertes> also you need to make sure that the two halves of the isomorphism are actually inverses of each other, which is easy to get wrong
23:19:32 <iqubic> Right for any isomorphism from (to a) = id
23:19:43 <iqubic> and to (from a) = id
23:19:59 <ertes> interestingly, if you use curry-howard to express what isomorphism means, and then use that to construct the semiring, you will construct those isomorphisms as a side effect of proving that types are isomorphic
23:20:19 <ertes> the virtues of constructive mathematics
23:20:21 <iqubic> What is curry-howard?
23:20:44 <jle`> another way of looking at +/* and Either/(,), fun stuff
23:20:58 <iqubic> https://hackage.haskell.org/package/semiring-simple-1.0.0.1/docs/Data-Semiring.html
23:21:04 <iqubic> That's a cool package
23:21:29 <iqubic> It expands the monoid to include multiplication like operations.
23:21:38 <ertes> iqubic: type theory is a logical calculus constructed in such a way that types are propositions and terms are proofs of those propositions…  this is called the curry-howard correspondence
23:21:59 <iqubic> Right, I see.
23:22:19 <ertes> iqubic: if haskell were a bit stricter, then the function 'id' would be a formal proof that for all propositions 'a', from 'a' follows 'a'
23:22:34 <iqubic> ertes: Have *you* written the isomorphism we are disscussing?
23:22:37 <ertes> in other words:  forall a. a -> a
23:22:45 <ertes> iqubic: no
23:22:51 <iqubic> Why not?
23:23:10 <ertes> because i'm satisfied with the fact that it exists…  i don't need to actually see it =)
23:23:23 <iqubic> I also know that it exists.
23:23:37 <iqubic> I don't really want to take the time to write it out.
23:23:40 <iqubic> Sounds hard.
23:23:55 <ertes> iqubic: then try to solve the last exercise i gave you
23:24:06 <iqubic> Which was...?
23:24:14 <ertes> iqubic: here is an interesting exercise:  find a type x such that: Maybe (Bool, Maybe (Either Ordering Ordering)) ≃ (Ordering, x)
23:24:37 <iqubic> Is there such a type in Haskell?
23:24:45 <ertes> data Ordering = LT | EQ | GT
23:24:48 <ertes> > compare 3 5
23:24:51 <lambdabot>  LT
23:24:51 <ertes> > compare 5 3
23:24:54 <lambdabot>  GT
23:24:55 <ertes> > compare 4 4
23:24:55 <iqubic> That's a sum type.
23:24:58 <lambdabot>  EQ
23:25:00 <ertes> yeah
23:25:05 <iqubic> Ordering is a sum type
23:25:21 <iqubic> Is that important to the solution?
23:25:41 <ertes> it's a matter of how you think about it
23:25:53 <ertes> Ordering ≃ Maybe Bool
23:26:06 <iqubic> Why is that?
23:26:16 <lpaste> jle` pasted “pascal's isomorphism” at http://lpaste.net/354939
23:26:26 <jle`> you can think of Bool as 2 and Ordering as 3
23:26:29 <jle`> and () as 1
23:26:41 <jle`> oh yeah i wrote out the isomorphism because i was bored
23:26:47 <ertes> i wish iqubic would have figured that out by themselves…
23:26:50 <jle`> s/the isomorphism/an isomorphism
23:26:54 <jle`> ertes: ah, sorry
23:27:20 <iqubic> It's cool. I was not going to write that myself ever.
23:27:38 <jle`> that's what i would have said if someone told me two years ago
23:27:41 <jle`> but look where i am now
23:27:42 <ertes> iqubic: well, Maybe, as a type function, is much like (1 +)
23:27:48 <iqubic> Sure.
23:27:50 <iqubic> I get that.
23:28:02 <iqubic> Oh and Bool = 2
23:28:16 <iqubic> Sorry is isomorpic to 2
23:28:24 <ertes> yeah, or alternatively:  Either ()
23:28:28 <ertes> where () ≃ 1
23:28:33 <cocreature> iqubic: now try to figure out Either and (,) :)
23:28:35 <iqubic> Sure.
23:28:53 <ertes> iqubic: now rewrite the equivalence
23:29:16 <ertes> i.e. apply what you have learned to this:  Maybe (Bool, Maybe (Either Ordering Ordering)) ≃ (Ordering, x)
23:29:32 <ertes> hint: you can reduce the whole left side to something *very* small
23:30:06 <iqubic> Maybe (Bool, Maybe (Either Ordering Ordering) ~ 1 + (2 * (1 + (3 + 3))
23:30:15 <rotaerk> hmm... wonder how I'm supposed to catch the "invalid argument" exception if InvalidArgument isn't exposed from System.IO.Error...
23:30:18 <ertes> iqubic: yeah
23:30:27 <ertes> iqubic: feel free to give that type a name: 15
23:30:42 <iqubic> Ah, That just 2 bytes.
23:30:50 <ertes> characters =)
23:30:57 <rotaerk> seems like a weird error to catch, but in this case it's being thrown by TCP.recv
23:31:13 <rotaerk> when the socket's closed before or while it runs
23:31:15 <ertes> iqubic: now rewrite the right side to something nicer
23:31:24 <iqubic> ertes: Or Word16 works too.
23:31:38 <rotaerk> hmm guess I'll filter on message instead of type
23:31:44 <iqubic> No, actually that's too large
23:31:59 <iqubic> ertes: How can I rewrite the Right side?
23:32:06 <ertes> iqubic: Ordering ≃ 3
23:32:15 <ertes> (Ordering, x) ≃ ?
23:32:15 <iqubic> So...?
23:32:30 <iqubic> Ah. x ~ 5
23:32:47 <ertes> there you go =)
23:32:49 <iqubic> But what Haskell type has 5 values?
23:33:00 <ertes> Maybe (Either Bool Bool)
23:33:08 <iqubic> Alright then. That works
23:33:23 <jle`> rotaerk: you can check the show, heh
23:33:24 <ertes> note: try not to reason in terms of size, because that will be a problem with infinite types
23:33:26 <cocreature> rotaerk: you can get it from GHC.IO.Exception
23:33:36 <rotaerk> ahh
23:33:50 <ertes> we don't have cardinal numbers in type theory…  at least not in the way they work in set theory
23:35:39 <iqubic> Now write this in mathematical symbols. Bool -> a ~ (a, a) -> Bool
23:36:07 <iqubic> I think that's an isomorphism I remember seeing. Not sure if it actually works.
23:36:19 <cocreature> that’s not an isomorphism
23:36:25 <iqubic> It isn't?
23:36:29 <iqubic> I thought it was.
23:36:53 <iqubic> Yeah, your right it isn't
23:36:54 <cocreature> the first is a^2 while the second is 2^(a^2)
23:36:55 <jle`> iqubic: you're trying to say that a^2 is the same as 2^(a*a)
23:37:06 <rotaerk> worked
23:37:09 <ertes> iqubic: refutation: a = 1:  1^2 ≠ 2^1
23:37:47 <ertes> read "≠" as "/≃" there…  i don't have "not isomorphic" on my keyboard =)
23:38:46 <iqubic> toPair f = (f True, f False) ~ fromPair (a, b) = if true then a else b
23:38:53 <iqubic> That's what I was going for.
23:39:08 <iqubic> Not sure if that actually works though.
23:39:18 <cocreature> "if true" ?
23:39:23 <cocreature> what’s true supposed to be
23:39:30 <iqubic> I don't know.
23:39:40 <cocreature> well you wrote this, shouldn’t you know? :)
23:40:45 <iqubic> (Bool -> a) -> (a, a) ~ (a, a) -> (Bool -> a) 
23:40:55 <iqubic> That's the isomorphism I was looking for.
23:41:18 <iqubic> toPair f = (f True, f False) ~ fromPair (a, b) c = if c then a else b
23:41:39 <iqubic> That's the isomorphism as two functions.
23:42:06 <iqubic> Now, I want to know the algebra of that isomorphism
23:42:37 <ertes> iqubic: that's an actual isomorphism
23:42:44 <iqubic> I know.
23:42:53 <iqubic> Now I want to put it into symbols.
23:43:07 <ertes> but note that it proves that *conversion functions* are isomorphic
23:43:13 <iqubic> I know.
23:43:18 <iqubic> I like it a lot
23:43:29 <ertes> (a*a)^(a^2) ≃ (a^2)^(a*a)
23:43:33 <ertes> for all a
23:44:06 <iqubic> And I ca clearly see how that works.
23:44:14 <iqubic> s/ca/can
23:47:34 <iqubic> How many isomorphisms exist?
23:48:00 <cocreature> you first need to define when two isomorphism are different before you can answer that question
23:48:24 <iqubic> LOL
23:48:47 <cocreature> I’m not joking. it’s not clear what the right notion of equality on functions is
23:48:48 <rotaerk> hmm annoying.  ioeGetErrorString is implemented to return the error *type* if the IOError is anything but a UserError
23:48:49 <ertes> iqubic: it's not a joke
23:49:05 <rotaerk> so I can't get the "Bad file descriptor" string from the exception
23:49:48 <ertes> iqubic: you are now entering the realm of infinity-groupoids and homotopy type theory =)
23:49:51 <cocreature> rotaerk: GHC.IO.Exception exposes the constructor of IOException so you should be able to just pattern match
23:50:06 <rotaerk> ah, cool
23:50:25 <cocreature> rotaerk: but I feel your pain. working with IOException is really weird
23:50:58 <iqubic> I don't know anything about haskell exceptions.
23:51:07 <iqubic> I avoid them like the plague.
23:51:09 <ertes> iqubic: your seemingly innocent question is a subject of active research by very smart people
23:51:12 <MarcelineVQ> it really is, a lot of the time the useful info is locked behind  ioe_description  as plain text
23:51:17 <rotaerk> yep, that worked
23:51:34 <ertes> IO exceptions are actually quite nice, once you understand how they work and interact in concurrent programs
23:52:14 <cocreature> ertes: I’m not talking about IO exceptions, I’m talking about the IOException type
23:52:43 <MarcelineVQ> ResourceExhausted for example has many causes and your only lead is what ioe_description might or might not report
23:53:12 <ertes> cocreature: i was answering to iqubic 
23:53:16 <cocreature> ah sry
23:53:36 <ertes> and yes, IOException is perhaps my least favourite type in the base library
23:53:40 <MarcelineVQ> I wonder if there's an exceptions lib around that has better categorisation for those vaguer errors
23:54:07 <ertes> MarcelineVQ: it wouldn't help, because base still throws the regular ones
23:54:39 <ertes> MarcelineVQ: i have such a library, which is supposed to make error responses easier to program, but it's awkward to work with
23:54:58 <MarcelineVQ> well what I mean is something to interpered the base version into something richer, for example for ResourceExhausted it could do the work of deciding if ioe_description is talking about file handles or disk space etc
23:55:01 <cocreature> lens at least makes the interface slightly better than these weird boolean functions for checking which kind of IOException was thrown
