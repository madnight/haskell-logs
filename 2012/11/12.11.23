00:00:06 <copumpkin> it has approximations for comparisons and show instances
00:00:10 <copumpkin> but there's noting else you can do
00:00:30 <copumpkin> I'd just throw out the Ord and Eq instances altogether!
00:00:35 <copumpkin> and Show while we're at it
00:00:38 <lispy> It's been a while, but I thought he complained about undefined things or maybe it was FIXMEs or ?
00:00:47 <copumpkin> maybe
00:00:52 <copumpkin> it seems to work just fine for our fooling in here :)
00:01:00 <copumpkin> but it's so slow that I doubt anyone wants to use it for anything real
00:01:24 <edwardk> lispy: the code is ugly, but it does work pretty well. http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/src/Data-Number-CReal.html#CReal
00:01:27 <copumpkin> johnw: honestly, if you're just using it to view decimals, what's wrong with Double/Float?
00:01:45 <johnw> copumpkin: because the decimals I want to view often won't fit in a Double
00:01:47 <edwardk> i can't even say its ugly any more. the errors are necessary.
00:01:54 <copumpkin> oh, I figured you just wanted a couple for currency
00:01:58 * ion looks at http://hackage.haskell.org/packages/archive/Decimal/0.2.3/doc/html/Data-Decimal.html
00:02:02 <edwardk> give me the floatRadix of a CReal
00:02:04 <johnw> that is why I want them
00:02:09 <copumpkin> johnw: have you looked at Data.Fixed?
00:02:11 <johnw> but the numbers involved can get large, on both sides of the decimal
00:02:19 <lispy> johnw: calculating the national debt? ;)
00:02:26 <johnw> lispy: I don't restrict :)
00:02:39 <lispy> johnw: would a large fixed point work for you?
00:02:41 <johnw> i hate the idea of building in artificial limits
00:02:45 <copumpkin> > 5.323426 / 4 :: Fixed E8
00:02:47 <lambdabot>   Not in scope: type constructor or class `E8'
00:02:47 <lambdabot>  Perhaps you meant one of thes...
00:02:50 <copumpkin> hmm
00:02:52 <johnw> lispy: I don't know what numbers my users will crunch with this library
00:03:02 <johnw> so I just want the limits to be memory-bounded, not decided by me
00:03:10 <copumpkin> anyway, Fixed is nice if you have a precision in mind
00:03:25 <johnw> copumpkin: ok, so let me explain what I'm doing
00:03:29 <copumpkin> > 5.323426 / 4 :: Fixed E9
00:03:30 <johnw> I have an Amount type, which uses Ratio
00:03:31 <lambdabot>   1.330856500
00:03:43 <johnw> Integer plus an Int precision
00:03:57 <johnw> as Amounts are used arithmetically, I track how much precision is needed to faithfully convey the result
00:04:25 <copumpkin> ah
00:04:32 <johnw> so, a + b keeps the widest precision of a or b, and a * b keeps prec a + prec b, and a / b keeps prec a + prec b + 6 (an arbitrary extension value that seems to work well enough)
00:04:46 <johnw> so is Fixed the right library to use for rendering Amount to a decimal?
00:05:16 <mgsloan> someone needs to write a program that uses cloud-haskell to send CReals as intermediate values :D
00:06:00 <copumpkin> johnw: it might be! I think it'll serve your purposes
00:06:03 <johnw> the problem with CReal is that in some cases, users want to convert to decimal with a specific kind of rounding, and then convert back to Rational
00:06:04 <shachaf> mgslon: CReal-as-a-Service?
00:06:17 <shachaf> Keep your CReals on your server, let people find out a finite amount of information about them.
00:06:32 <mgsloan> shachaf: That's the idea.  It should work, right?  I'm led to believe cloud haskell can serialize thunks
00:06:51 <ion> johnw: I think Decimal may do what you want wrt. keeping track of how much precision is needed.
00:07:33 <johnw> ion: well, I only want to render to Decimal at the very last minute.  Until then, I keep Rationals as they cannot lose precision
00:07:42 <shachaf> mgsloan: Well, I'm suggesting the opposite.
00:07:58 <shachaf> mgsloan: Let people who want to make use of your CReal at some particular precision send requests to you.
00:09:06 <johnw> > Fixed (19 % 7)
00:09:08 <lambdabot>   Not in scope: data constructor `Fixed'
00:09:22 <mgsloan> shachaf: actually, yeah, I hadn't quite thought of that -  I wonder if you could make it fast enough to fill your browser window on demand.  Scroll until it reaches the point that the server can't handle (within reasonable cost)
00:09:35 <ion> > 19 / 7 :: Fixed E9
00:09:37 <lambdabot>   2.714285714
00:10:06 <johnw> hmm.. does it support arbitrary precisions?
00:10:47 <johnw> > 19 / 7 :: Fixed E4
00:10:49 <lambdabot>   Not in scope: type constructor or class `E4'
00:10:49 <lambdabot>  Perhaps you meant one of thes...
00:10:50 <mgsloan> yup, and I think the thunk serialization of a CReal ought to be proportional to the size of its computation?
00:11:17 <mgsloan> (its computation being all of the Num, etc operations that led to its existence)
00:11:42 <jamy23> Some programmers can say "I store the function which contains the io-action". Forexample javascript
00:13:45 <yaw> Hey. Is there a recommended, up-to-date resource out there for learning about Haskell's exception handling semantics? (Ideally, without having to read research papers :P) I'm picking up bits and pieces here and there in the docs about when exceptions can interrupt a thread, when they can be caught, etc; but would be nice to read something that summarises all the important points in one place
00:14:36 <ion> jamy23: You can explicitly create functions around side-effectful code to defer evaluation, but IO actions aren’t first-class values in them and you can’t call an arbitrary function and know that the act of evaluating that call won’t have side effects.
00:15:32 <sclv> yaw: the best source i know is papers :-(
00:15:49 <sclv> actually I don't think there's anything outside of discussions and the basic code for the new mask stuff
00:16:22 <yaw> heh, ok
00:16:36 <sclv> you really need to decide whether you're interested in imprecise exceptions in general or async exceptions especially
00:16:49 <sclv> the former are pretty easy to reason about and the paper is still good on them.
00:16:56 <jamy23> But in javascript you cant guarantee that the IO runs in strong sequence
00:16:56 <yaw> i guess a related question: what is the minimal set of things to ensure when writing code, to avoid correctness issues regarding exceptions
00:17:05 <yaw> assuming my own code doesn't throw exceptions to other threads, etc.
00:17:07 <sclv> async exceptions are actually more about ffi than anything else, oddly enough.
00:17:27 <sclv> what do you mean by "correctness issues"?
00:17:31 <yaw> e.g.
00:17:45 <yaw> thread A crashes due to a bug and leaves some data in an inconsistent state
00:18:03 <sclv> depends what you mean by "inconsistent"
00:18:19 <sclv> you'll never get "inconsistent" in the "partially written" sense
00:18:42 <sclv> the worst you'll get is "inconsistent" in the broader sense of "one value was updated but not another"
00:18:50 <sclv> or "something was incremented that should now be decremented"
00:18:50 <yaw> yep
00:19:16 <sclv> basically use bracket and finally where they make sense
00:19:57 <yaw> ok. that level of inconsistency makes sense
00:20:24 <sclv> and remember that an exception can "hide inside" a data structure, so make sure to have a `catch` block around wherever you fully evaluate the structure that can catch the exception then and keep going
00:20:44 <yaw> (if this question even makes sense) is evaluating a thunk thread-safe?
00:20:58 <sclv> haskell is always thread-safe!
00:21:04 <shachaf> sclv: Sort of.
00:21:08 <yaw> e.g. if i put some lazy thing in an IORef and read it from two threads, is that OK?
00:21:09 <sclv> (in the sense that ppl talk about thread safety in java i mean)
00:21:10 <shachaf> Not if you use unsafeDupablePerformIO
00:21:18 <yaw> will one block while the other evaluates the thunk?
00:21:21 <ion> The async package can help making sure that you don’t leave any orphan threads hanging around if their “parent” dies. Or the more heavyweight distributed-process package.
00:21:44 <shachaf> yaw: When two threads start evaluating the exact same thunk at the same time, they might duplicate a bit of work.
00:21:49 <sclv> its totally fine for two threads to try to evaluate a lazy value
00:21:54 <shachaf> It doesn't matter because the results of one will be thrown away.
00:21:57 <sclv> (you can get this even without an ioref)
00:22:00 <yaw> ok
00:22:07 <yaw> makes sense
00:22:17 <sclv> purity makes things much cleaner
00:22:20 <shachaf> If it doesn't happen *exactly* at the same time, the thunk will be updated with a placeholder value such that other threads will block when they try to evaluate it.
00:22:32 <yaw> ok, cool
00:22:56 <yaw> so there's no runtime magic that uses mutability under the hood for whatever optimisation reason, which could break
00:23:10 <sclv> oh there's mutability under the hood, but it is written so as not to break
00:23:24 <sclv> i.e. the thunk is updated in place with its value
00:23:32 <sclv> but thats deep rts stuff
00:24:02 <sclv> from a userland perspective, as long as you're doing vanilla things, they operate cleanly
00:24:06 <shachaf> Which someone just needs to get right once.
00:24:09 <yaw> okay
00:24:11 * shachaf wonders who that someone will be.
00:24:28 <sclv> all reads and writes of IORefs are atomic
00:24:45 <sclv> but modify reads, then updates with a new value, so there's also a slightly more expensive atomicModifyIORef
00:25:06 <sclv> STM lets you extend atomicity to whole chains of mutation operations within a block
00:25:17 <sclv> again, deep magic under the hood, but simple for the end user
00:25:23 <yaw> yep i'm comfortable with all that high level stuff
00:25:41 <shachaf> @google mainisusuallyafunction blackholes
00:25:43 <lambdabot> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
00:25:47 <shachaf> yaw: ☝
00:26:05 <yaw> cool, thanks, i'll read that :)
00:26:54 <johnw> Decimal may be just what I need, thanks
00:28:00 <sclv> unless you're reimplementing primitives over some transformer stack, using the exception combinators the naive way is all you need for exception handling.
00:30:09 <yaw> okay
00:30:36 <yaw> i think 80% of the queries in my head are answered, i'll do a bit more reading before bugging you guys about the last 20%
00:38:28 <evacchi> Hi everybody I need to propose a little project to pass a beginner Haskell course I followed for my PhD, can you point me to some resources where I can find an idea that I could realize?
00:39:11 <evacchi> I know of the 99 Haskell problems but most of them look easy. Maybe you could point me to some of the most interesting?
00:41:37 <Leif_Bork> Hi, I want to use lists where the elements have the same type class
00:42:01 <Leif_Bork> When I use forall a. in the type declaration I get an illegal symbol error
00:42:08 <shachaf> Leif_Bork: You probably don't. :-)
00:42:14 <shachaf> It's possible to do it, but often there's a better solution.
00:42:22 <shachaf> So you should mention your specific problem.
00:42:42 <Ralith> evacchi: implement a simple game
00:42:48 <shachaf> To get "forall" you can enable ExistentialQuantification or something.
00:43:26 <evacchi> Ralith, do you mean something with graphics?
00:43:37 <simpson> evacchi: A classic problem: Implement a Diplomacy adjudicator.
00:43:49 <Leif_Bork> shachaf: When I use heap profiling, I get a constantly growing thunk
00:44:12 <Leif_Bork> I thought I'd try to force evaluation at a stage using deepseq
00:44:27 <shachaf> DeepSeq is *also* very often not what you want. :-)
00:44:38 <shachaf> If you're just using this for debugging you can try it.
00:44:47 <evacchi> ooh, cute
00:44:48 <shachaf> But I imagine it'll help less than you think.
00:44:48 <Leif_Bork> Yep, I am
00:44:58 <shachaf> If your code is small you can @paste it
00:46:34 <Ralith> evacchi: if you like!
00:47:25 <evacchi> simpson, that's a cute idea
00:47:34 <johnw> > realFracToDecimal 2 (52345 % 1000)
00:47:36 <lambdabot>   Not in scope: `realFracToDecimal'
00:47:45 <johnw> that results in 52.34
00:47:48 <johnw> how come not 52.35?
00:47:58 <johnw> is it just truncating?
00:48:05 <evacchi> Ralith, maybe a very simple textual adventure? would it fit into Haskell?
00:48:37 <Jafet> > round 5234.5
00:48:39 <lambdabot>   5234
00:48:42 <johnw> even roundTo 2 (realFracToDecimal 3 (52345 % 1000)) => 52.34
00:49:05 <johnw> hmm
00:49:12 <Jafet> :t (%)
00:49:14 <lambdabot> a -> (a -> b) -> b
00:49:22 <johnw> i need 52.35 from that
00:49:41 <shachaf> It's probably rounding to the nearest even or something?
00:49:56 <Ralith> evacchi: if you want it to!
00:49:57 <johnw> using 52355  % 1000 => 52.35
00:50:16 <Leif_Bork> shachaf: http://hpaste.org/78109
00:51:49 <shachaf> That's not your code. :-)
00:51:57 <shachaf> Leif_Bork: You could probably just rnf the list instead of folding.
00:53:23 <Leif_Bork> Damn, of course!
00:55:15 <shachaf> I'm not sure what your question there was, though.
00:55:33 <shachaf> (rnf .) . sequence :: NFData a => [b -> a] -> b -> ()
00:57:31 <evacchi> Ralith, I found a library using Parsec, maybe I could implement the rules of the game using native haskell, and the player actions using a deeply embedded DSL
00:57:43 <evacchi> (my research area is DSL development :) )
01:00:07 <borkdude> what is the "best" web framework to get started in Haskell (OSX)?
01:00:55 <Leif_Bork> shachaf: Thank you
01:03:18 <shachaf> Does GHC compile C code when it compiles for profiling?
01:03:45 <zhulikas> borkdude, it depends on your personal style I believe
01:03:54 <zhulikas> all main frameworks are equally capable
01:05:17 <Jafet> It probably compiles C code if there is C code to be compiled.
01:06:10 <Jafet> Or one might say that it doesn't compile any C code
01:07:03 <johnw> mpfrToString Near 4 10 (Data.Number.MPFR.div Near 128 (fromIntegerA Near 64 52345) (fromIntegerA Near 64 1000))
01:07:07 <johnw> that rounds the way I need
01:07:23 <shachaf> Jafet: Well, it seems to be compiling a big generated C file.
01:07:30 <borkdude> zhulikas ok thanks, I guess I just have to pick one and see how it works out
01:07:38 <zhulikas> yeah
01:07:54 <zhulikas> borkdude, run over 'getting started' guides for them and see which one you prefer
01:08:25 <zhulikas> because of the framework war and all marketing effort it's impossible to say which one is better
01:08:31 <edwardk> johnw: be careful. hmpfr has been known to cause all sorts of segfaults even if you do mostly innocent things with it
01:08:44 <zhulikas> but you may prefer one or the other because they have quite different approaches to web development
01:08:47 <johnw> really, even just simple a divide&print?
01:09:03 <johnw> those are the only two operations I need
01:09:08 <edwardk> i have yet to find ANY safe usage profile for the package =P
01:09:13 <borkdude> zhulikas for now I just prefer the one which allows me to get something going real quick, just to experiment
01:09:16 <johnw> grr
01:09:30 <johnw> then is there any safe way to get the results I want in Haskell?
01:10:10 <johnw> Decimal doesn't round correctly; Fixed is too inflexible in the precisions it offers, and CReal is too slow (by copumpkin's declaration)
01:10:26 <johnw> and Double is just too narrow
01:10:28 <shachaf> What's the incorrect rounding here?
01:10:45 <johnw> you saw above, 52.34 from 52.345, instead of 52.35
01:10:52 <shachaf> Is that wrong?
01:11:00 <shachaf> What does it do with 52.335?
01:11:17 <zhulikas> borkdude, if you want something real quick, I'd suggest scotty :P
01:11:38 <zhulikas> borkdude, with no setup and 5 lines of code you can have a hello world on a web
01:11:39 <johnw> shachaf: with Decimal?  52.33
01:11:41 <neutrino_> johnw: maybe it uses round-to-nearest-even?
01:11:44 <johnw> it always seems to round toward 0
01:12:09 <zhulikas> borkdude, https://github.com/xich/scotty
01:12:20 <borkdude> zhulikas ah, great :)
01:16:51 <johnw> shachaf: so, do you know of something that will do what I need and round as I expect?
01:17:19 <shachaf> Nope.
01:17:21 <johnw> this is how I do it in C++: https://github.com/ledger/ledger/blob/next/src/amount.cc#L134
01:17:47 <johnw> but edwardk has me afeared of doing that same thing in Haskell now -- but it's what I need
01:18:21 <edwardk> johnw: use CReal. wait until it bites you in the ass. upgrade
01:18:32 <johnw> upgrade to what?
01:18:40 <edwardk> to rounded, by fixing rounded ;)
01:18:42 <osa1> I don't unerstand how maxSize parameter in quickcheck works, it sometimes creates small data, but sometimes it creates so big that it never ends
01:18:49 <johnw> ah
01:18:51 <johnw> fair enough
01:18:55 * hackagebot warp 1.3.5 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.5 (MichaelSnoyman)
01:18:57 * hackagebot warp-tls 1.3.4 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.4 (MichaelSnoyman)
01:18:59 <edwardk> by then i'll have a captive audience, since you'll need it ;)
01:19:08 <johnw> i've done a fair bit of stuff in this space, including writing my own rounding library, so I'd be happy to help you
01:19:29 <edwardk> rounded is just a patched MPFR with a haskell wrapper
01:19:35 <johnw> (well, it wasn't my own, it was for a client, which is why I can't just use it)
01:19:45 <edwardk> you can learn more than anyone will ever want to know about writing foreign prims ;)
01:19:47 <johnw> rounded is on your github i take it
01:19:56 <edwardk> and about the ghc RTS's builtin linker
01:20:06 <edwardk> yeah mine and copumpkins', not sure which is more current
01:20:36 <edwardk> i think my last few patches were from a bunch of in-flight mods we were doing one night, and then he went off to go study for some financial engineering exam and we never got back to it
01:21:33 <johnw> gotta port numbers to 7.6 now
01:22:10 <johnw> it may make more sense to just start with rounded and get it to work
01:23:47 <neutrino_> http://news.ycombinator.com/item?id=4820812
01:23:52 <neutrino_> this person is insane.
01:25:04 <deus_rex> "Wouldn't that just be the grooviest?" excellent pun
01:25:39 <zhulikas> (str "(" (str obj) ")." meth "(" (str p1) ")"))
01:25:42 <zhulikas> he must be on meth
01:26:23 <simpson> Huh. Somehow, my karma's good enough to actually downvote him.
01:26:25 <simpson> So tempting.
01:26:30 <johnw> edwardk: Command "ar -x /Users/johnw/Projects/haskell/tools/rounded/dist/build/libHSrounded-0.0.1.a" failed with exit code: 1
01:26:40 <johnw> library doesn't exist
01:26:50 <edwardk> linux or mac?
01:26:55 <johnw> mac
01:27:13 <edwardk> hrmm, copumpkin might be able to help you get it working better than i can at this point
01:27:24 <edwardk> i'm about to fall asleep
01:27:32 <johnw> sleep tight, edwardk
01:27:53 <edwardk> a few revisions ago the build system worked entirely differently
01:27:58 <edwardk> you might have better results there
01:28:22 <borkdude>  (str "(" obj ")." meth "(" p1 ")") is good enough since str returns the str concatenations of multiple values
01:30:06 <shachaf> Jafet: So it looks like it generated 5MB of profiling initialization code.
01:33:55 * hackagebot persistent 1.0.2.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.0.2.2 (MichaelSnoyman)
01:34:32 <johnw> > showCReal 2 (52345 % 1000)
01:34:35 <lambdabot>   "1000.0"
01:34:43 <johnw> ?
01:35:13 <shachaf> ?
01:35:31 <johnw> i was expecting 52.35!
01:35:52 <shachaf> @ty (%)
01:35:55 <lambdabot> a -> (a -> b) -> b
01:36:00 <johnw> oh, meh!
01:36:10 <shachaf> You don't want (%) anyway.
01:36:10 <eikke> did anyone ever experience huge performance issues with simple-sendfile?
01:36:12 <shachaf> You want (/)
01:36:15 <eikke> (or sendfile(2) in general)
01:36:21 <johnw> i want to apply CReal to a Rational
01:36:26 <johnw> so I don't want /
01:36:27 <shachaf> @ty fromRational
01:36:29 <lambdabot> Fractional a => Rational -> a
01:36:32 <johnw> thanks
01:36:46 <shachaf> eikke: sendfile doesn't interact badly with GHC's RTS?
01:36:47 <johnw> yay, that works
01:37:06 <eikke> shachaf: care to explain what you mean?
01:37:14 <shachaf> "Cross platform library for the sendfile system call." -- does that exist anywhere other than Linux?
01:37:49 <eikke> shachaf: there are similar things on BSD, Windows and OSX as well, but this is on Linux
01:38:29 <shachaf> eikke: Well, they're importing it unsafe.
01:39:05 <shachaf> Looks like they're doing their own asynchronous thing.
01:39:06 <eikke> basically, I have an app which should send data from a file to a client. I'm using conduits, and have 2 implementations of the 'sending' part: one uses pread (from unix-bytestring) to retrieve, then pushes the data to the conduit sink (which results in sendto), the other one uses simple-sendfile. First gets +- 11MB/s throughput, second 710KB/s :-/
01:39:50 <shachaf> Are you using -threaded?
01:40:11 <eikke> number of syscalls is equivalent (pread = 1 pread + 1 sendto, sendfile = 1 sendto (with MSG_MORE) and 1 sendfile)
01:40:27 <shachaf> You straced it?
01:40:27 <eikke> shachaf: yes
01:40:31 <eikke> shachaf: yes
01:40:35 <shachaf> Hmm.
01:40:56 <shachaf> So it's just doing one sendfile() call?
01:41:08 <eikke> and packet sizes should be the same (pread: sendto of 1040 bytes, sendfile: sendto of 16, then sendfile of 1024)
01:41:09 <shachaf> Is the fd that it's doing on opened as NONBLOCK?
01:41:47 <eikke> not sure about that
01:41:48 <shachaf> How big is the file?
01:41:54 <shachaf> strace should tell you.
01:41:54 <eikke> 64MB
01:42:00 <shachaf> grep for the fd number or something.
01:42:09 <shachaf> The socket, I mean.
01:43:21 <eikke> might be it's not set to nonblocking operation, although then it's not set like that in the pread case either
01:44:17 <shachaf> I'm talking about the socket, not the file.
01:44:22 <shachaf> Though, hmm.
01:44:23 <eikke> me too
01:44:30 <shachaf> GHC reads from files with a thread pool.
01:44:33 <b__> I love my dayjob
01:44:44 <shachaf> sendfile() might be blocking on "reading from disk".
01:44:47 <shachaf> I don't know.
01:44:50 <shachaf> Too many possibilities. :-)
01:46:09 <b__> company wants to try drupal: <div id="edit-customer-profile-billing-commerce-customer-address">foo</div>
01:46:10 <eikke> shachaf: this pread thing isn't from ghc (internals). both implementations execute both syscalls from the same thread
01:46:30 <shachaf> You're doing pread manually?
01:46:32 <b__> anyone have some cyanide for me
01:46:53 <eikke> shachaf: http://hackage.haskell.org/packages/archive/unix-bytestring/0.3.5.4/doc/html/src/System-Posix-IO-ByteString-Lazy.html#fdPread
01:47:05 <shachaf> Anyway, who knows about their specific implementations.
01:47:12 <shachaf> Lots of things could be different.
01:53:18 <zhulikas> b__, it's ok as long as you don't need to write code for it :D
01:53:40 <zhulikas> I mean... navigating through admin panel and doing stuff through there is OKish
01:53:45 <zhulikas> you can do a lot actually
01:53:56 * hackagebot nerf 0.2.1 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.2.1 (JakubWaszczuk)
01:55:19 <b__> zhulikas, ye or if you have to style it, but nvm not Haskell related
02:23:10 <mcstar> i was wondering if you guys heard of something like this: im describing a projective interval composition
02:23:40 <mcstar> imagine the number line, there are segments from it, [a,b] for example
02:23:45 <mcstar> on it*
02:24:05 <mcstar> but these segments have an ordering, perpendicular to the number line
02:24:37 <mcstar> you look at them from that direction, and what you see, is the composition of intervals, that i need
02:24:51 <mcstar> (these intervals are 'named' i.e. they carry an id)
02:25:16 <mcstar> have you heard, something like this?, is there a name for this?
02:29:11 <mcstar> http://sketchia.com/draw.html#W2GPHpo this is an example of such a composition
02:29:55 <mcstar> if CD would be behind AB, wrt the view direction, the result would only be AB
02:36:23 <mcstar> i know it is OT, but obviously ill be using haskell to implement it, and there are interval libraries, im wondering if one of them could accomodate this
02:41:14 <adimit> say, I have an action f :: a -> m b, and I have a pair (c,a). Now I'd like to have a function secondM or so :: (a -> m b) -> (c,a) -> m (c,b). second does something similar, but it leaves the monad action in the pair: (c, m b). I'd like to get it out. Is there a good way to do that?
02:41:24 <borkdude> is haskell suited as a sysadmin scripting language? (beginner's question)
02:41:56 <borkdude> (because it's startup time is fast, contrary to a JVM-based language)
02:41:58 <mcstar> i think it is only called an action if m is IO?
02:42:01 <adimit> borkdude: probably not your best choice, no. Except you're a sysadmin with extensive knowledge of Haskell.
02:42:27 <adimit> mcstar: well, incidentially, m = SomeTransformer IO in my case…
02:42:44 <RichyB> mcstar: isn't that, like, z-indexed rendering?
02:43:12 <mcstar> RichyB: yes, of line segments, but they are 'named', carry an id
02:43:55 <mcstar> but im asking in the context of interval computations
02:44:08 <mcstar> i have a problem, and i abstracted this away
02:44:32 <typoclass> borkdude: i think haskell is an excellent 'scripting' language. i've pretty much stopped using shell scripts for anything > 5 lines, using haskell instead. but yeah, it has a learning curve :-) whether you use it for scripting or something else
02:44:39 <typoclass> @where lyah
02:44:39 <lambdabot> http://www.learnyouahaskell.com/
02:44:49 <typoclass> borkdude: have you seen this? ^^ it's a good book available free of charge
02:45:05 <borkdude> typoclass I'm now reading Real world haskell
02:45:35 <typoclass> borkdude: that's a very good book too. maybe not completely beginner-friendly, but yeah
02:45:41 <mcstar> typoclass looks up, what RWH is
02:45:50 <borkdude> typoclass I like functional languages, I used clojure, F#, common lisp and Miranda (old time language)
02:46:02 <Ralith> adimit: I wrote that yesterday
02:46:14 <Ralith> no, not quite that
02:46:21 <Ralith> but it's easily written
02:46:30 <adimit> Ralith: interesting. What did you write exactly? Yeah, I know, I'm writing it myself right now.
02:46:41 <adimit> just thought I could avoid it :-\
02:46:42 <borkdude> typoclass I'm kind new with the Haskell ecosystem. How portable is a binary that I compiled with "ghc --make" to another system, etc?
02:46:54 * Ralith needed (a -> m b) -> a -> m (a, b)
02:46:56 <fmap> borkdude: there are some attempts to write shell-like libraries in haskell
02:47:02 <fmap> @hackage shelly
02:47:02 <lambdabot> http://hackage.haskell.org/package/shelly
02:47:19 <deus_rex> @hoogle (a -> m b) -> a -> m (a,b)
02:47:19 <lambdabot> No results found
02:47:24 <adimit> Ralith: well, that's an almost trivial difference.
02:47:29 <Ralith> indeed.
02:47:35 <Ralith> it is: liftM2 fmap (,)
02:47:49 <adimit> ah. Neat.
02:48:01 <deus_rex> @help djinn\
02:48:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:48:04 <deus_rex> @help djinn
02:48:04 <lambdabot> djinn <type>.
02:48:04 <lambdabot> Generates Haskell code from a type.
02:48:04 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
02:48:12 <adimit> well, let's try.
02:48:16 <typoclass> borkdude: nope, not as far as i know. but the same source code will typically compile on all OSes
02:48:18 <deus_rex> @djinn (Monad m) => (a -> m b) -> a -> m (a,b)
02:48:19 <lambdabot> -- f cannot be realized.
02:48:50 <borkdude> fmap tnx
02:48:51 <adimit> yeah, it's probably not trivial enough for djinn
02:48:58 <borkdude> typoclass thanks,
02:49:01 <borkdude> .
02:49:15 <deus_rex> @djinn a -> a
02:49:16 <lambdabot> f a = a
02:50:34 <FireFly> @djinn Monad m => a -> m a
02:50:34 <lambdabot> f = return
02:51:11 <adimit> @djinn (Arrow a, Monad m) => a b (m c) -> a (d, b) (m (d, c))
02:51:12 <lambdabot> Error: Class not found: Arrow
02:51:12 <deus_rex> @djinn Monad m => m a -> (a -> m b) -> m b
02:51:12 <lambdabot> f = (>>=)
02:51:23 <adimit> @djinn  a b (m c) -> a (d, b) (m (d, c))
02:51:24 <lambdabot> -- f cannot be realized.
02:51:28 <adimit> :-S
02:51:50 <mcstar> @djinn a -> a
02:51:51 <lambdabot> f a = a
02:51:59 <adimit> djinn knows nothing about Arrows!
02:52:21 <shachaf> djinn and type classes don't mix well
02:52:35 <adimit> well, it does get Monads.
02:56:07 <johnw> @tell Cale FYI: Account for domain analogical-engine.com has been suspended.
02:56:08 <lambdabot> Consider it noted.
02:56:38 <adimit> well, \k (c,a) = k a >>= return . (c,) does what I want.
02:56:53 <adimit> dunno if it's the most elegant way to solve the problem… but it does the trick.
02:57:02 <johnw> @pl \k (c,a) = k a >>= return . (c,)
02:57:02 <lambdabot> (line 1, column 10):
02:57:03 <lambdabot> unexpected "="
02:57:03 <lambdabot> expecting pattern or "->"
02:57:09 <johnw> @pl \k (c,a) -> k a >>= return . (c,)
02:57:10 <lambdabot> (line 1, column 32):
02:57:10 <lambdabot> unexpected ","
02:57:10 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
02:57:21 <adimit> it doesn't like the tuple section
02:57:38 <johnw> adimit: how about fmap k (c,a)?
02:57:45 <adimit> @pl \k (c,a) -> k a >>= \b -> return . (c,b)
02:57:45 <lambdabot> (`ap` snd) . (. fst) . (. (((return .) .) . (,))) . flip . ((>>=) .)
02:57:47 <johnw> k is a monadic function?
02:57:51 <adimit> johnw: yes.
02:57:51 <mcstar> @pl \k (c,a) -> k a >>= return . ((,)c)
02:57:51 <lambdabot> (`ap` snd) . (. fst) . (. ((return .) . (,))) . flip . ((>>=) .)
02:58:59 * hackagebot rethinkdb 0.1.0.0 - RethinkDB client library for haskell  http://hackage.haskell.org/package/rethinkdb-0.1.0.0 (EtienneLaurin)
02:59:02 <adimit> :t \k (c,a) -> fmap k (c,a)
02:59:04 <lambdabot> (a -> b) -> (t, a) -> (t, b)
02:59:06 <johnw> so you need an (a, m b) -> m (a, b) to apply after the fmap
02:59:07 <adimit> wrong type :-\
02:59:16 <adimit> yeah.
03:00:12 <johnw> seqprod (x,y) = y >>= \z -> return (x,z)
03:00:40 <johnw> then seqprod $ fmap f (a,b)
03:01:21 <adimit> johnw: that works, too :-) — But it's not really a lot more readable.
03:01:26 <johnw> kinda makes you want fmapM
03:01:33 <adimit> jup.
03:01:37 <adimit> or secondM
03:01:40 <adimit> :-)
03:01:52 <johnw> i'm sure there's a lens around here somewhere...
03:02:03 <adimit> I haven't looked at lenses yet.
03:02:10 <adimit> I've been meaning to. Just haven't gotten around to it.
03:02:25 <johnw> adimit: http://newartisans.com/2012/11/getting-started-with-lenses/
03:02:39 <edwardk> :t \k (c,a) = k a >>= return . (c,)
03:02:41 <adimit> yeah, I'll do that tomorrow. It's been getting time :-)
03:02:41 <lambdabot> parse error on input `='
03:02:46 <edwardk> :t \k (c,a) -> k a >>= return . (c,)
03:02:48 <lambdabot> Illegal tuple section: use -XTupleSections
03:02:54 <edwardk> :t \k (c,a) -> k a >>= return . (,) c
03:02:56 <lambdabot> Monad m => (t -> m a) -> (a1, t) -> m (a1, a)
03:03:09 <edwardk> :t mapMOf _2
03:03:11 <lambdabot> (Monad m, Field2 s t a b) => (a -> m b) -> s -> m t
03:03:24 <johnw> i thought he was asleep, there you go
03:03:57 <edwardk> if the traversable instance for (,) e  was in place it'd just be Data.Traversable.mapM
03:03:58 <johnw> mapMOf _2 ("Hello","World")
03:04:03 <johnw> > mapMOf _2 ("Hello","World")
03:04:05 <lambdabot>   Couldn't match expected type `a0 -> m0 b0'
03:04:05 <lambdabot>              with actual type `(...
03:04:05 <ion> johnw: That article doesn’t show composition of lenses at all, does it?
03:04:09 <johnw> ion: not yet
03:04:12 <johnw> it's just the beginning
03:04:15 <shachaf> Of course, you can drop "mapMOf" and it'll still work.
03:04:24 <adimit> voodoo. I'll have to look at lenses, relly.
03:04:25 <edwardk> :t mapMOf _2 putStrLn ("Hello","World")
03:04:26 <johnw> well, i wanted to apply return there
03:04:27 <lambdabot> IO ([Char], ())
03:04:34 <edwardk> :t _2 putStrLn ("Hello","World")
03:04:35 <lambdabot> IO ([Char], ())
03:04:37 <johnw> > mapMOf _2 return ("Hello","World")
03:04:40 <lambdabot>   No instance for (GHC.Show.Show
03:04:40 <lambdabot>                     (m0 ([GHC.Types.Char], [...
03:04:51 <shachaf> johnw: Just wait 'til you see what's coming in lens 3.6
03:05:00 <johnw> frankenlenses?
03:05:01 <shachaf> The biggest thing to happen to lens since lens
03:05:07 <johnw> hah!  what??
03:05:08 <shachaf> (Not really.)
03:05:14 <c_wraith> more stabbing
03:05:19 <shachaf> upon is "pretty nifty"
03:05:24 <ion> Now with more unsafePerformIO and unsafeCoerce!
03:05:27 <johnw> show me
03:05:39 <adimit> I had a free day planned for tomorrow. I'll guess I'll blow it on lenses. And hookers.
03:05:42 <shachaf> upon fst +~ 1 $ (1,5) ===> (2,5)
03:05:54 <johnw> oh, that was edwardk's field earielr
03:05:57 <shachaf> Yes.
03:06:01 <johnw> did you solve the performance problem?
03:06:02 <shachaf> ion: Actually 3.6 is getting rid of BazaarT
03:06:06 <edwardk> johnw: its gotten safer and faster
03:06:06 <shachaf> No.
03:06:09 <shachaf> Well, somewhat.
03:06:25 <edwardk> it'll also do 'upon last' correctly
03:06:33 <johnw> wow
03:06:35 <edwardk> well, once i push my current patch
03:06:37 <johnw> that's very cool
03:06:40 <johnw> now make it fast, and I'll get excietd
03:06:42 <shachaf> @ty GHC.Exts.the
03:06:45 <lambdabot> Eq a => [a] -> a
03:06:51 <c_wraith> what's the type for upon?
03:06:51 <johnw> then I can stop using _1 and _head
03:07:03 <shachaf> upon :: (Data s, Typeable a) => (s -> a) -> Simple Traversal s a
03:07:06 <edwardk> upon :: (Data s, Typeable a) => (s -> a) -> Simple Traversal s a
03:07:06 <ion> shachaf: Alright. What will replace it?
03:07:08 <c_wraith> ah, Data
03:07:14 <typoclass> so lens 3.6 has fst now? not bad
03:07:18 <shachaf> ion: undefined
03:07:24 <c_wraith> Ok, data and typeable explain how it can do that
03:07:24 <shachaf> typoclass: No, that's Prelude fst
03:07:30 <edwardk> you give it a function that returns something biplate cna find and it'll give it to you
03:07:30 <johnw> typoclass: no, it has upon which transforms accessors into lenses automagically
03:07:37 <shachaf> It magically turns fst into a setter.
03:07:40 <ion> (BrentSpinder a, Typeable a)
03:07:42 <typoclass> oooh i see. thanks guys
03:07:43 <ion> Spiner
03:08:08 <c_wraith> So this means it can work with standard record syntax now
03:08:14 <johnw> edwardk: can you memoize lenses yet?
03:08:18 <c_wraith> upon accessor %~ foo
03:08:31 <edwardk> ?
03:08:39 <edwardk> c_wraith: yes
03:08:47 <edwardk> c_wraith; not efficiently, but it works
03:08:55 <johnw> well, maybe my question is not relevant
03:09:02 <shachaf> johnw: You can't memoize what "upon" returns so it turns into an efficient lens.
03:09:24 <c_wraith> well, sure, data and typeable will never lead to *fast* code.  But they can do simple stuff
03:09:28 <johnw> make "upon <field>" fast!
03:09:36 <c_wraith> err, make some stuff fast
03:09:45 <johnw> we'll just put lens into GHC Core
03:09:50 <c_wraith> man, I'm failing to communicate
03:09:54 <shachaf> johnw: I think no matter what you do to it, you'll never get compiletime inlining, so it'll never be as fast as defining your own lens.
03:10:10 <johnw> shachaf: I give you a seagull shaped frowny
03:10:35 <luite> y not runtime inlining
03:10:47 <shachaf> luite: nominolo is working on that.
03:11:03 <luite> yeah i know
03:11:20 <edwardk> :t iforOf (indexed template)
03:11:22 <lambdabot> (Data.Data.Data t, Typeable b, Applicative f) => t -> (Int -> b -> f b) -> f t
03:26:39 <edwardk> >>> upon last +~ 1 $ [1,2,5]    ==> [1,2,6]
03:26:43 <edwardk> woot
03:29:25 <edwardk> that really reduces the pressure to write 'uponTheDeep'
03:32:55 <t7> can someone update the haskell platform in debian please :3 its been ages now
03:34:17 <hiptobecubic> t7, that's debian's main feature
03:34:25 <hiptobecubic> It's like a time capsule
03:34:30 <t7> wheezy
03:34:48 <t7> 'testing'
03:34:48 <ChristianS> wheezy is on its way to became stable
03:34:52 <typoclass> t7: i thought debian has those old-but-stable repos, and the fairly-current-but-you-have-to-flip-some-switch repos
03:35:08 <ChristianS> i doubt anything can be updated until is it stable and there is a new testing
03:35:14 <t7> even sid (unstable) has 2012.20.0.0
03:35:23 <t7> 2012.2.0.0 *
03:36:10 <sopvop> just install platform to $HOME
03:36:24 * sopvop is on centos 6, older than wheezy
03:39:00 <chersanya> hi everyone) how to force haskell NOT to install documentation for packages in /usr/local/share/doc?
03:39:36 <ion> Do you mean your system’s package manager by “Haskell”?
03:40:31 <chersanya> probably not only it, but also cabal: i installed happstack for example using cabal install, and documentation for it appeared there
03:41:01 <chersanya> taking hundreds of Mb
03:41:39 <mcstar> jesus. you need multiple hard drives for that
03:42:26 <chersanya> ehm? why?
03:42:31 <ion> I’m not even sure what makes cabal install stuff outside the home directory. Does sudo cause that or do you need additional flags? I’d recommend just installing things to your home directory when not using the system’s package manager. There’s a setting for documentation in ~/.cabal/config.
03:42:35 <t7> chersanya: ignore mcstar
03:43:02 <mcstar> that was a joke on how expensive hard disk space was in the 90's i guess
03:44:04 <ibid> my first computer had 20 MB of hard disk.  i deinstalled the editor and installed the compiler every time i wanted to compile, and vice versa when the compilation failed :-D
03:44:06 <mapf> how to install cabal-dev properly? i cabal install cabal-dev and alias cabal-dev=~/.cabal/bin/cabal-dev so cabal-dev works but cabal-dev ghci isn't
03:44:11 <ibid> (you can guess which editor:)
03:44:30 <zhulikas> netbeans?
03:44:41 <ibid> didn't exist back then
03:44:53 <chersanya> ion: and when installing into home directory, how to turn off documentation installation? (i have a vps with not a lot storage)
03:44:55 <mcstar> i guess emacs?
03:44:56 <luite> mapf: why don't you add ~/.cabal/bin to your $PATH ?
03:45:17 <ion> chersanya: There’s a setting for documentation in ~/.cabal/config.
03:45:25 <ibid> mcstar: right :)
03:45:33 <mapf> luite: because i forget
03:45:37 <mapf> heh
03:45:59 <luite> mapf: cabal-dev also needs fake-ghc-cabal-dev to be in your path
03:46:02 <luite> in the same dir
03:46:18 <mapf> ok, thanks
04:04:02 * hackagebot CarneadesDSL 1.0 - An implementation and DSL for the Carneades argumentation model.  http://hackage.haskell.org/package/CarneadesDSL-1.0 (BasVanGijzel)
04:04:04 * hackagebot hprotoc 2.0.13 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.13 (ChrisKuklewicz)
04:10:27 <b_jonas> ibid: even without the editor, how did ghc fit on the 20 MB hard drive?
04:10:38 <b_jonas> :-)
04:14:37 <borkdude> what is the best place to go for documentation in Haskell world, for simple functions like foldr, etc?
04:14:47 <danr> @where hoogle
04:14:47 <lambdabot> http://haskell.org/hoogle
04:14:49 <zhulikas> lambdabot
04:14:52 <zhulikas> @hoogle foldr
04:14:53 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
04:14:53 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
04:14:53 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
04:14:59 <zhulikas> but in private chat :D
04:15:18 <zhulikas> @src foldr
04:15:18 <lambdabot> foldr f z []     = z
04:15:18 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:15:22 <zhulikas> really helpful bot
04:15:32 <borkdude> zhulikas tnx
04:15:59 <kennyd> @hoogle (a -> b) -> [a] -> [b]
04:16:00 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
04:16:01 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
04:16:01 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
04:16:24 <zhulikas> although setting up a custom search engine in chrome to use hoogle is also a good option
04:20:09 <mcstar> and hackage
04:20:16 <mcstar> 'hk'
04:20:35 <ibid> b_jonas: gcc, badly.  haskell did exist but i was not aware of it
04:21:59 <kgabis> when trying to compile first example from chapter 4 of Real World Haskell I get the following error: "internal error: evacuate(static): strange closure type 32
04:21:59 <kgabis>     (GHC version 7.4.2 for x86_64_apple_darwin)" (I updated it from 7.4.1 where this problem also existed), anyone got an idea why is that happening?
04:22:27 <kgabis> (runhaskell works alright)
04:22:57 <sopvop> which example?
04:23:11 <sopvop> oh, first
04:23:16 <kgabis> ch04/InteractWith.hs
04:24:57 <shachaf> Works for me.
04:25:01 <borkdude> it beats me why they are using foldr instead of foldl on page 106 of Real world Haskell, but maybe I'm overlooking smth
04:25:01 <shachaf> kgabis: Try the 32-bit version of GHC?
04:25:08 <sopvop> works 7.4.2 on linux, must be mac bug
04:25:16 <shachaf> borkdude: If I had the book with page numbers, I might be able to help you.
04:25:47 <borkdude> schachaf the code is: dlts = foldr step [] . lines
04:25:55 <kgabis> ok, I'll install 32 bit version, it must be a bug in a compiler
04:26:18 <shachaf> I hear the 64-bit version of GHC is a little funny.
04:26:24 <borkdude> shachaf the goal is to extract macro names from C headers
04:26:48 <shachaf> borkdude: If you could link to the relevant part of realworldhaskell.org it would be probably help. :-)
04:27:44 <borkdude> shachaf of course, I will look it up
04:28:59 <mutha> if I want to have Map with caseless comparison function for strings as key should I do something like this?  data StringNC = string, and then write a custom compare for that type?
04:31:50 <mcstar> you can lowercase the keys, and store values of [(value,key)]
04:32:01 <mutha> i want to keep the case
04:32:12 <mcstar> yes, thats why you store the original key too
04:32:37 <sopvop> I would rather newtype it
04:32:41 <shachaf> mutha: You can do that, yes.
04:32:49 <shachaf> newtype is better than data here.
04:32:54 <shachaf> But either would work.
04:32:55 <mcstar> but a map has unique keys
04:33:06 <mcstar> so, you need multimap, i think
04:33:22 <shachaf> ?
04:33:41 <aetcore> in the moment, how do you quit ghci ?
04:33:49 <shachaf> :q?
04:33:50 <shachaf> ^D?
04:34:03 <aetcore> ah thanks! :)
04:34:03 * hackagebot fb 0.13.1 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.13.1 (FelipeLessa)
04:34:18 <mutha> with data StringNC = String  I am not sure how to get the string back
04:34:46 <sopvop> mutha: newtype StringNC = StringNC (String, String)
04:34:47 <borkdude> shachaf the comments on the rwh page explained it to me, I was confused about foldr
04:34:51 <chra> mutha: http://hackage.haskell.org/package/case-insensitive
04:35:00 <mutha> thanks
04:35:11 <mutha> sopvop: why two strings?
04:35:13 <mcstar> shachaf: if you have keys, that are equal, if they only differ in case, then you will miss key-value associations if you just put them into a map
04:35:31 <mcstar> if im not mistaken
04:35:37 <sopvop> mutha one string, I'm just being stupid
04:35:37 <shachaf> I think mutha defined their own notion of "equality"
04:35:45 <mutha> ok :)
04:35:46 <shachaf> As long as it's self-consistent it should be fine.
04:36:27 <sopvop> mutha: you should just use package chra linked though
04:37:58 <kgabis> I installed 32-bit version of ghc and still get the same error (internal error: evacuate(static): strange closure type 3840)
04:38:51 <c_wraith> how are you installing ghc?
04:39:15 <c_wraith> the version in macports is totally broken
04:39:32 <kgabis> from haskell platform installer
04:39:51 <c_wraith> hmm.  That should be ok, afaik.  Though I don't use it myself
04:42:01 <kgabis> hah, I found a solution
04:42:07 <sopvop> share it
04:42:14 <kgabis> I installed ghc through homebrew
04:43:19 <sopvop> Does not help to diagnose though :)
04:44:28 <kgabis> yeah :/
04:51:31 <killy9999> I've ran into strange thing in Criterion
04:51:49 <killy9999> I have a benchmark that runs slower if it is preceeded by any other benchmark
04:52:00 <killy9999> but if it runs first it returns correct results...
04:54:04 <mcstar> slower vs. correct?
04:54:05 * hackagebot language-puppet 0.3.1.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.3.1.0 (SimonMarechal)
04:56:10 <killy9999> mcstar: I'm able to estimate the runtime of my function
04:56:20 <killy9999> if should be arround 9 microseconds
04:56:49 <killy9999> when the test is run first I get about 10 microseconds - this corresponds with my estimation
04:57:02 <mcstar> i just couldnt understand your original question, but i dont know anything about criterion
04:57:04 <killy9999> the "incorrect" result is about 15 microseconds more
04:57:11 <killy9999> sure
04:59:05 * hackagebot puppetresources 0.4.1 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.4.1 (SimonMarechal)
05:00:44 <Saizan> killy9999: gc?
05:01:54 <killy9999> Saizan: running between benchmarks
05:02:11 <killy9999> so that's not gc
05:04:06 * hackagebot yesod-auth-fb 1.3.1 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.3.1 (FelipeLessa)
05:04:07 * hackagebot skein 0.1.0.10 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.10 (FelipeLessa)
05:04:10 <shachaf> ?
05:05:01 <shachaf> Anyway I think people won't be able to say much without code.
05:06:52 <killy9999> shachaf: I'm sort of aware of that
05:07:21 <killy9999> but there's quite a bit of code, so I think not many people would be willing to spend their time reading it
05:07:45 <killy9999> I guess I'll try to create some sort of minimal working example and maile that to haskell-cafe
05:07:48 <mcstar> except the ones that would eventually help you
05:08:04 <quchen> Now that I've heard of Simon Marlow being "Mr. GHC", what's SPJ's title?
05:08:24 <mcstar> Mr. Unicycle
05:08:50 <killy9999> mcstar: but I think I should help people that help me, that is prepare *short* piece of code that demonstrates the problem with
05:08:51 <quchen> That brings me to another question: what's the joke with the unicycle?
05:08:58 <shachaf> You could call Marlow "Mr. RTS".
05:09:12 <mcstar> oh? he plays much?
05:09:17 <bartavelle> :)
05:09:20 <kranius> o:
05:09:23 <shachaf> Now the RTS will be an orphan. :-(
05:09:34 <bartavelle> he is the only one touching it ?
05:09:57 <mcstar> killy9999: thats a good idea
05:10:10 <byorgey> bartavelle: no, but he's certainly done the most
05:10:48 <sopvop> I just hope what he left because he wanted so, not because MS thinks what Haskell does not worth their support
05:11:10 <mcstar> 'what'?
05:11:22 <quchen> Maybe MS is trying to ruin everything whe it heads to version 8, so they fired Marlow
05:11:22 <Saizan> *that
05:11:49 <Philippa> quchen: even if they did, we could tell them to fork off
05:11:54 <byorgey> sopvop: it seems pretty clear to me that the former is the case
05:12:03 <killy9999> Marlow left MS? When?
05:12:20 <quchen> killy9999: http://www.haskell.org/pipermail/haskell/2012-November/023566.html
05:12:33 <sopvop> this 'what/that' is about my wrong usage?
05:12:37 <bartavelle> facebook is chasing FP people, he certainly had a nice offer
05:12:58 <mcstar> sopvop: yes, wasnt sure how to interpret the sentence
05:13:13 <sopvop> which one would be appropriate here?
05:13:22 <mcstar> thats, ofc
05:13:24 <mcstar> that
05:13:52 <sopvop> It seems I mapped what/that to wrong russian meanings :)
05:13:58 <killy9999> I wonder why I didn't get that mail from Haskell-cafe....
05:14:06 * hackagebot crypto-conduit 0.4.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.4.1 (FelipeLessa)
05:14:19 <typoclass> sopvop: just to be clear, the first 'what' should be 'that' :-) not the second one
05:14:32 <byorgey> sopvop: they are fairly similar, I doubt there is a nice clean mapping to russian =)
05:14:37 <byorgey> (not that I know any russian)
05:15:18 <mcstar> what is like pulling, that is like pushing
05:17:03 <sopvop> Thanks guys. I should finally step on my pride and study with teacher :)
05:17:18 <mcstar> isnt that a bit telling, when high profile researchers go into industry?
05:18:10 <byorgey> telling how?
05:19:33 <mcstar> well, how well are researchers paid?
05:19:38 <mcstar> these days
05:20:05 <mcstar> would i be wrong to assume he will earn much better with Facebook?
05:20:18 <Saizan> i doubt money is the primary factor
05:20:52 <Saizan> maybe he wanted to try out in a large scale what he has built in this years, just speculating though :)
05:21:29 <luite> mcstar: i assume that your assumptions are correct
05:22:44 <sopvop> With 3 kids in family, money can become major factor.
05:26:57 <quchen> GHC developer: no money, lots of thanks. Facebook: lots of money, no thanks. http://xkcd.com/664/
05:28:37 <mcstar> i think, you can collect 'likes' with facebook
05:29:31 <mcstar> (soo annoying, it is even part of our language, hungarian)
05:29:45 <mcstar> (at least, it is part of 'television speak')
05:30:06 <quchen> Liking things?
05:30:13 <quchen> Yeah, we don't have that concept in Germany
05:30:38 <sopvop> Even beer and sausages?
05:30:55 <quchen> That would be like saying you like air ;-)
05:32:03 <mcstar> no, i mean, when you push that Like button, that action is described as 'you are liking this', now, there is weird sounding word for that, 'lájkolja'
05:35:15 <borkdude> what is the easiest way to see the intermediate results of foldl and foldr? in clojure foldl is essentially called reduce, and there is also a function called reductions, which collects all intermediate results in a list
05:35:50 <mcstar> :t scan
05:35:52 <lambdabot>     Not in scope: `scan'
05:35:52 <lambdabot>     Perhaps you meant one of these:
05:35:52 <lambdabot>       `scanl' (imported from Data.List),
05:35:54 <rwbarton> the scan* functions
05:35:54 <shachaf> scanl and scanr
05:35:58 <mcstar> :t scanl
05:36:00 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
05:36:04 <shachaf> Unlike foldl1, scanl1 is safe
05:36:07 * shachaf is pleased with this fact
05:36:23 <borkdude> ok, scan
05:36:25 <borkdude> tnx
05:36:28 <mcstar> also, you dont see the result, you get it
05:36:37 <mcstar> you can use 'trace' to see the intermediate results
05:36:39 <borkdude> mcstar yes, in clojure you get it also
05:36:42 <shachaf> rwbarton: I managed to get rid of the unsafeCoerce!
05:36:55 <shachaf> But as soon as I did that, he introduced another one elsewhere.
05:37:09 <shachaf> >>> upon (!!1) .~ 123 $ [1,2,3,4]
05:37:13 <shachaf> [1,123,3,4]
05:38:49 <rwbarton> wacky
05:39:14 <watermind> is there any reason not to have liftM and join in Monad and make them an alternative to bind?
05:39:38 <shachaf> "as long as we're changing the class, let's change it properly"?
05:39:47 * rwbarton . o O $(setf ([1,2,3,4] !! 1) 123)
05:39:50 <atriq> watermind, theoretically, no
05:39:55 <borkdude> mcstar just discoverd trace but the output of trace gets mingled with the output of foldr, so that's not too great
05:39:56 <watermind> schlumpi:  well, I can see the argument for not having Monad as a subclass of Functor...
05:39:59 <watermind> ops
05:40:04 <rwbarton> poor schlumpi
05:40:05 <watermind> shachaf: ^
05:40:43 <shachaf> rwbarton: upon :: forall s a. (Data s, Typeable a) => (s -> a) -> SimpleIndexedTraversal Int s a
05:41:01 <watermind> since some would be annoyed at having to implement map when they don't need it, since they implemented bind directly anyway
05:41:14 <PatrixCR> data A = A
05:41:19 <shachaf> I don't even know what to think.
05:41:29 <rwbarton> how can this work
05:41:32 <sopvop> once . upon time .~ somethingcleverhere
05:41:34 <shachaf> watermind: You don't have to implement map.
05:41:51 <shachaf> sopvop: The version of upon that goes deep into the structure is caleld uponTheDeep
05:41:56 <shachaf> Well, it's not implemented yet.
05:42:02 <rwbarton> shachaf: it's not a higher rank thing?
05:42:05 <watermind> shachaf: if you had  Functor a => Monad a?
05:42:12 <shachaf> watermind: Then life would be good.
05:42:20 <shachaf> rwbarton: The type of upon isn't higher-rank, no.
05:42:32 <sopvop> lens package is a Pandora's box.
05:42:38 <rwbarton> upon (\x -> x !! 1 + x !! 2) .~ 123 $ [1,2,3,4] -- ?
05:42:42 <watermind> shachaf: how would you then iinstanciate Monad without implementing map ?
05:42:54 <shachaf> rwbarton: "you're not supposed to do that"
05:42:57 <rwbarton> He'd use "deriving Functor", right shachaf??
05:43:00 <shachaf> It gives you a 1-or-0 traversal.
05:43:08 <watermind> rwbarton: ah :P
05:43:18 <shachaf> And whether it takes the second or the third depends on order of evaluation.
05:43:24 <rwbarton> I see.....
05:43:29 <mutha> is foldr essentially reverse + foldl?
05:43:33 <watermind> rwbarton: Functor can't be derived in general though
05:43:34 <shachaf> What upon does is replace every part of the structure with an exception giving the index into the structure.
05:43:44 <shachaf> watermind: It can't?
05:43:44 <rwbarton> watermind, do you have an example
05:43:50 <shachaf> mutha: More like the other way around.
05:44:15 <shachaf> Then it applies your exception and sees which exception gets raised.
05:44:17 <watermind> shachaf: ah sorry missunderstood you then, you were saying "you don't have to implement map"
05:44:20 <shachaf> s/exception/accessor/
05:44:21 <rwbarton> mutha: foldl is essentially reverse + foldr
05:44:27 <watermind> rwbarton: an example of?
05:44:33 <rwbarton> < watermind> rwbarton: Functor can't be derived in general though
05:44:56 <watermind> rwbarton: ah yes   data F a = F (a -> Int)
05:45:04 <rwbarton> well that's because it's not a functor...
05:45:08 <rwbarton> and therefore not a monad...
05:45:09 <shachaf> GHC can't derive Functor in general without a quadratic slowdown. :-(
05:45:19 <mutha> couldnt foldr be implemented with foldl?
05:45:24 <shachaf> mutha: Nope.
05:45:30 <shachaf> But foldl can be implemented with foldr
05:45:36 <shachaf> @google foldl foldr
05:45:38 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
05:45:38 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
05:46:10 <rwbarton> I wonder if GHC can derive Functor for stuff like data X i a where X :: a -> X () a
05:46:27 <killy9999> shachaf, mcstar: https://gist.github.com/4135698
05:46:39 <killy9999> here's the code that demonstrates my problem with criterion
05:46:39 <shachaf> Can't make a derived instance of `Functor (X i)': Constructor `X' must not have existential arguments
05:46:48 <rwbarton> seems like a wrong error message
05:46:51 <shachaf> Hmm, that's not existential.
05:46:56 <shachaf> Right.
05:46:58 <killy9999> a minimal example, that is
05:47:21 <rwbarton> standalone deriving didn't help either
05:47:31 <rwbarton> hmm
05:48:12 <rwbarton> how about a mode for ghci that greps ghci's error messages for -X[A-Za-z0-9]+ and automatically enables the extension
05:48:24 <shachaf> I just enable them all in .ghci
05:48:33 <shachaf> http://slbkbs.org/ghci.txt
05:49:22 <shachaf> (That's a bit older than my current ghci, but you get the idea. I only ever enable any particular extension once. :-) )
05:49:47 <shachaf> Oh, by "mode" you mean "emacs mode"
05:50:03 <rwbarton> no i meant a ghci thing really, but that would be good too
05:51:44 <mcstar> sry, killy9999, as i said, i havent played with criterion at all
05:52:41 <watermind> so how do you do when you want to write >>= using join? define a join'?
05:52:45 <killy9999> mcstar: sure, but you can see the problem :)
05:52:58 <killy9999> I guess this deserves a mail to Haskell-cafe
05:54:08 * hackagebot TCache 0.10.0.5 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.5 (AlbertoCorona)
05:54:36 <sopvop> is there lensy way to "compare on" ?
05:55:09 <shachaf> Why?
05:55:49 <shachaf> killy9999: I don't see this behavior.
05:56:16 <killy9999> shachaf: you get consistent runtime for all benchmarks ?
05:56:58 <shachaf> Consistentish.
05:57:19 <shachaf> Hmm, I get very high stddev
05:57:24 <killy9999> always?
05:57:40 <killy9999> if you get hogh stddev it means that probably all benchmarks are sloving down
05:58:06 <killy9999> no, wait
05:58:30 <killy9999> I;m not sure on this one
05:59:09 <shachaf> I'm just getting some serious outliers.
05:59:21 * shachaf hasn't actually looked at the code, mind you.
05:59:49 <killy9999> shachaf: what OS and GHC version do you have?
06:00:28 <shachaf> x86_64-linux-7.6.1/
06:01:23 <killy9999> http://img641.imageshack.us/img641/5683/fficrit.png
06:01:54 <killy9999> that's how first two benchmarks look on my machine. First one is the faster one, second is slower
06:02:09 <shachaf> That's a fancy report.
06:02:13 <killy9999> hm... I'm on x86_64-linux-7.4.1
06:02:28 <killy9999> fancy? why?
06:03:52 <shachaf> I didn't know Criterion did that.
06:04:46 <killy9999> oh
06:05:05 <killy9999> you need to pass -o=somefile.html to criterion binary
06:05:17 <gfredericks> is it plausible that the haskell blowfish cipher and the jvm version are incompatible?
06:05:44 <killy9999> sorry, no = sign
06:06:05 <killy9999> -o somefile.html
06:06:49 * killy9999 goes for a lunch
06:07:21 <mcstar> im having trouble writing my interval merging function :(
06:07:39 <mcstar> it is a much harder problem than i anticipated
06:08:04 <mcstar> easy on paper, hard to formalize
06:09:51 <nyc> mcstar: How are you representing the set of intervals?
06:10:11 <mcstar> list of markers
06:10:22 <mcstar> the list is always sorted
06:10:42 <bartavelle> then it should be pretty straightforward ?
06:10:43 <mcstar> a marker is either a Point of point, or an Inerval, with a name and bounds
06:11:00 <mcstar> bartavelle: i thought so, too :)
06:11:19 <shachaf> What does it mean if I'm seeing sZJ4_info in the generated file but not in any of the intermediate files?
06:11:33 <shachaf> E.g. not in -ddump-asm or in any of the -keep-tmp-files
06:11:34 <bartavelle> with two consecutive intervals, there are only 3 cases : disjoint, second is in the first, second goes past the first (if you sort by interval start)
06:11:58 <rwbarton> shachaf: maybe it comes from base?
06:12:10 <luite> shachaf: those are labels for functions inside a closure
06:12:37 <shachaf> I'm looking at "perf" output and the code is spending most of its time here.
06:12:43 <mcstar> bartavelle: it is a z-ordered merge, the new interval, that im adding has priority, and can shadow the old named intervals
06:12:44 <shachaf> How would I track it down?
06:12:55 <mcstar> and consequently, partition them apart
06:13:06 <luite> it should be part of a function group
06:13:15 <luite> shachaf: oh you can see the labels with -ddump-cmm
06:13:24 <mcstar> bartavelle: did you see my sketch that i linked earlier?
06:13:56 <shachaf> luite: When -ddump-asm isn't showing them?
06:13:58 <bartavelle> mcstar, oh I have no clue about the problem, sorry for the bad suggestion
06:14:20 <shachaf> I guess it's linking against something in base or somewhere, like rwbarton said.
06:14:25 <luite> shachaf: dunno why -ddump-asm doesn't show them, perhaps they're already converted to offsets there
06:14:25 <shachaf> But I don't know where.
06:15:04 <luite> or it's indeed from somewhere else :)
06:15:12 <mcstar> bartavelle: http://sketchia.com/draw.html#W2GPHpo if you want to take a look :)
06:15:23 <shachaf> Oh, it's in criterion.
06:16:18 <shachaf> OK, that's enough.
06:16:20 * shachaf sleep
06:16:33 <mcstar> gn
06:16:37 <bartavelle> mcstar, ah, yes, it is not what I expected
06:17:46 <mcstar> the problem is similar to reading 2 streams, and merging them
06:17:55 <mcstar> but the rule is not too simple
06:18:08 <bartavelle> not if there are 3 overlapping segments, right ?
06:18:43 <mcstar> you always only merge the whole line against a segment
06:18:46 <mcstar> or interval
06:19:21 <mcstar> so there can only be 2 overlapping intervals at once
06:45:11 <beaky> quiet today :D
06:45:17 <atriq> Indeed
06:46:12 <beaky> what is the most interesting thing about haskell
06:46:58 <atriq> The unexpected consequences of type safety and the class system
06:47:22 <arcatan> separation of pure and impure
06:47:28 <t7> whats the name of ? that hire contractors ?
06:47:33 <t7> contractees?
06:47:34 <beaky> ah
06:47:36 <mcstar> the way it can pin down your attention
06:47:50 <beaky> I like how in haskell, you can define your own operators
06:47:56 <beaky> it's like inventing your own DSL
06:48:15 <atriq> I wouldn't say that's particularly interesting, but Haskell is the only language I know
06:48:38 <mcstar> lisp is all about dsl, yet no infix
06:48:49 <beaky> ah
06:48:55 <mcstar> (well, you can make a reader macro...)
06:49:18 <beaky> what's a reader macro
06:49:26 <mcstar> #lisp
06:49:30 <mcstar> :)
06:49:48 <mcstar> it has a programmable input reader
06:49:57 <beaky> so it's like parsec?
06:50:16 <mcstar> idk what parsec is like
06:50:32 <mcstar> but it is closer to an ad-hoc system
06:52:43 <Hermit> beaky: a reader macro is an expression that will be transformed into something else the moment it's read
06:53:05 <Hermit> and it will act just as if you had originally written that result in the code
06:54:12 <atriq> Things I need to understand: CPS, some other things
06:54:28 <mcstar> lol
06:54:33 <barrucadu> atriq: That appears to be a lazily-evaluated list of things
06:55:55 <atriq> barrucadu, the AtriqsMemory Monad blocks sometimes
06:56:46 <rwbarton> Either IForgot a
06:57:14 <barrucadu> IForget Either This That
06:58:06 <mcstar> if(item.age()>2years){item.forget();}
06:59:56 <atriq> > let fact n r = case n of {0 -> r 1; n -> r (fact (pred n) (* n))} in fact 10 id
06:59:59 <lambdabot>   3628800
07:00:11 <atriq> I think that's CPS
07:00:21 <prophile> that certainly smells like CPS
07:00:48 <prophile> although in that particular case you can factor the 'r' out of the case statement
07:00:57 <atriq> True
07:01:21 <mcstar> cant you always? if there is 1 continuation?
07:01:35 <watermind> would be nice to have context variables, so we could write:  class ctx a => Monad m where;  return::ctx a=>m a;  (>>=)::(ctx a,ctx b)=>m a->(a->m b)-> m b
07:01:35 <atriq> > let fact n r = r $ case n of {0 -> 1; _ -> fact (pred n) (* n)} in fact 10 id
07:01:37 <lambdabot>   3628800
07:02:21 <dtruby> Does anyone know of any examples of how to use Data.Tree and it's associated functions? I've been looking on the internet for a while now and I can't find any..
07:02:49 <chreekat> dtruby: I used it for a Project Euler solution, though not a particularly elegant one :)
07:02:53 <rwbarton> > Node "a" [Node "b" [], Node "c" []]
07:02:55 <lambdabot>   Node {rootLabel = "a", subForest = [Node {rootLabel = "b", subForest = []},...
07:03:01 <rwbarton> > text . drawTree $ Node "a" [Node "b" [], Node "c" []]
07:03:04 <lambdabot>   a
07:03:04 <lambdabot>  |
07:03:04 <lambdabot>  +- b
07:03:04 <lambdabot>  |
07:03:04 <lambdabot>  `- c
07:03:28 <hpaste> wm pasted “monad tree for dtruby” at http://hpaste.org/78112
07:03:29 <mcstar> heh, could be used to flood the channel
07:03:37 <rwbarton> ("text" is for lambdabot to display the output as multiple lines)
07:03:39 <mcstar> it has output with newlines in it
07:03:48 <rwbarton> I think it caps at around 5
07:04:01 <watermind> dtruby: I pasted there some examples
07:04:36 <watermind> dtruby: just building 2 simple trees and combining them using its monad instance
07:04:36 <mcstar> text $ intersperse '\n' [0..]
07:04:51 <mcstar> text $ intersperse '\n' ['a'..'z']
07:05:00 <mcstar> forgot the >
07:05:05 <mcstar> oh, yes
07:05:11 <mcstar> > text $ intersperse '\n' ['a'..'z']
07:05:13 <lambdabot>   a
07:05:14 <lambdabot>  b
07:05:14 <lambdabot>  c
07:05:14 <lambdabot>  d
07:05:14 <lambdabot>  e
07:05:15 <lambdabot> [21 @more lines]
07:05:41 <dtruby> I got the hang of the drawtree etc. stuff, just not unfoldTree etc.
07:05:56 <t7> @hoogle [a] -> IO a
07:05:56 <lambdabot> Prelude head :: [a] -> a
07:05:57 <lambdabot> Data.List head :: [a] -> a
07:05:57 <lambdabot> Prelude last :: [a] -> a
07:06:06 <dtruby> I may well be using this for the wrong purpose, I'm trying to build an AST from Tokens, is Data.Tree the best thing for that?
07:06:06 <roconnor> @hoogle (m a) -> (m b) -> m (a,b)
07:06:07 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
07:06:07 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
07:06:07 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
07:06:26 <atriq> Favourite library for prime factorization?
07:06:37 <roconnor> is there no zip for applicative?
07:06:43 <fmap> watermind: that looks a lot like -XConstraintKinds
07:06:51 <t7> is there no random from list?
07:07:00 <fmap> (re: context variables)
07:07:10 <atriq> :t liftA2 (,)
07:07:12 <lambdabot> Applicative f => f a -> f b -> f (a, b)
07:07:40 <dtruby> watermind: Thanks for the example, that helps a lot!
07:08:02 <watermind> fmap: I don't know that one... doesn't surprise me to much though, there's a few cases where we can use both classes and kinds to the same effect
07:08:10 <rwbarton> you can write that buildTree with unfoldTree
07:08:13 <rwbarton> @type unfoldTree
07:08:15 <lambdabot> (b -> (a, [b])) -> b -> Tree a
07:08:22 <watermind> fmap: let me check that
07:08:30 <watermind> dtruby: no problem ;)
07:09:05 <rwbarton> unfoldTree (\(c,i) -> ([c]++show i, [(succ c, j) | j <- [0..i-1]]))
07:10:45 <rwbarton> @type unfoldTree (\(c,i) -> ([c]++show i, [(succ c, j) | j <- [0..i-1]]))
07:10:47 <lambdabot> (Enum t, Num t, Show t) => (Char, t) -> Tree [Char]
07:11:03 <rwbarton> > unfoldTree (\(c,i) -> ([c]++show i, [(succ c, j) | j <- [0..i-1]])) ('a',2)
07:11:05 <lambdabot>   Node {rootLabel = "a2", subForest = [Node {rootLabel = "b0", subForest = []...
07:12:41 <watermind> fmap: ohhh it's not what I expected
07:12:45 <watermind> fmap: this is really nice
07:14:12 * hackagebot hgeometry 0.1.1.0 - Geometry types in Haskell  http://hackage.haskell.org/package/hgeometry-0.1.1.0 (FrankStaals)
07:16:24 <xd> :quit
07:17:33 <watermind> fmap: not entirely sure why in those last example in the documentation the type checker wouldn't terminate.... how is that different from writing class Cls a => Cls a where ?
07:17:55 <dropdrive> rwbarton: Do you remember my question about writing a function that tracks what files it requires and then caching and reusing the result if the required files haven't changed?  People suggested writing a monad (FileIO a) and a function: runFileIO :: CacheLocation -> FileIO a -> IO a (and presumably functions like f :: a -> FileIO b).
07:18:20 <dropdrive> But I'm having a bear of a time trying to define (FileIO a) --- any obvious pointers?
07:19:12 * hackagebot alpha 1.0 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0 (MarcCoiffier)
07:19:45 <dropdrive> (The other key function would be read :: FilePath -> FileIO String which reads a file and somehow (??) tracks the modification time of the file read (???).)
07:20:16 <rwbarton> you might want to just use something like 'operational' to define the monad
07:20:32 <rwbarton> and put all the tricky tracking logic in the interpreter
07:20:38 <rwbarton> @hackage operational
07:20:38 <lambdabot> http://hackage.haskell.org/package/operational
07:21:33 <rwbarton> hmm
07:21:37 <dropdrive> rwbarton: Okay, thanks for that pointer.
07:22:03 <rwbarton> I'm not really sure you can do this with a monad
07:22:09 <dropdrive> rwbarton: I guess I would also want to make these f :: a -> FileIO b functions composable -- though maybe that comes for free.
07:22:27 <dropdrive> rwbarton: Why do you say that?
07:22:28 <rwbarton> with 'operational' you just define what you want the primitive operations for your monad to be
07:22:52 <dropdrive> rwbarton: You're not sure if it can be done with a monad defined by operational, or by a monad at all?
07:23:20 <rwbarton> with a monad at all... or rather I should say, I'm not sure you can expose a monad API for "FileIO"
07:23:24 <Philonous> dropdrive:  This kind of static information cannot (in general) be tracked in a monad
07:23:27 <rwbarton> you can definitely expose an applicative API
07:24:14 <rwbarton> the problem is--what if you read one file and its contents determine what file to read next
07:24:41 <dropdrive> rwbarton: Yes, my understanding is that with that dependence one "needs" monad and not applicative
07:24:45 <rwbarton> or hm
07:24:52 <Philonous> dropdrive:  As soon as IO is involved the set of files that you need can change every time you run it without any way of statically knowing them beforehand, so caching becomes impossible
07:25:25 <rwbarton> well hang on, the problem is that "CacheLocation -> FileIO a -> IO a" is wrong
07:25:33 <rwbarton> it needs to be "CacheLocation -> FileIO a -> IO (IO a)"
07:26:04 <rwbarton> is this supposed to cache computations between runs of your entire program?
07:26:12 <dropdrive> rwbarton: Yes.
07:26:14 <rwbarton> ugh
07:26:23 <rwbarton> how do you expect to identify the computation you are repeating then
07:26:49 <rwbarton> even if you have a computation that reads the same files, it might not apply the same function to the results of those files
07:26:56 <dropdrive> rwbarton: By something like: (Eq a, Serialize a) => a -> FileIO b ?
07:26:56 <rwbarton> or the contents or whatever :P
07:27:05 <Philonous> dropdrive:  Arrows can statically capture the set of files they access
07:27:06 <rwbarton> but the whole *arrow* there needs to be serialized
07:27:19 <rwbarton> so that I can know whether I have computed it before
07:27:46 <rwbarton> or: you need to manually label those arrows, and hope you don't screw it up by reusing a label
07:28:08 <rwbarton> basically you would need to do Cloud Haskell's closure conversion thing which doesn't really exist
07:28:17 <dropdrive> rwbarton: I'm willing to manually provide a unique cache location for each function.
07:28:24 <rwbarton> okay
07:28:43 <rwbarton> I see, each function but not each argument
07:28:48 <rwbarton> each possible argument to the function
07:29:13 <dropdrive> rwbarton: Yes.  Arguments are serializa ble and equality-testable.
07:29:39 <rwbarton> so I guess in the cache, you will need to store too what files the computation read from
07:29:45 <dropdrive> Philonous: "arrow" in which sense?
07:30:00 <dropdrive> rwbarton: Yes, absolutely right.  Sorry if i wasn't clearer!
07:30:21 <Philonous> dropdrive:  "Idioms" as in Control.Arrow
07:30:39 <rwbarton> no, I'm just catching up :)
07:31:02 <dropdrive> rwbarton: So it goes like ... f 1 2 --> "have I evaluated f 1 2 before?" --> yes --> "what files did I read in doing so?  have they changed?" --> nope --> use cached result
07:31:24 <rwbarton> right
07:31:30 <t7> @hoogle [a] -> [a]
07:31:30 <rwbarton> and the problem is to identify "f 1 2"
07:31:30 <lambdabot> Prelude cycle :: [a] -> [a]
07:31:31 <lambdabot> Data.List cycle :: [a] -> [a]
07:31:31 <lambdabot> Prelude init :: [a] -> [a]
07:31:32 <dropdrive> rwbarton: Or --> yes, the files have changed --> rerun the function, cache out the new results for tomorrow.
07:31:44 <rwbarton> and when running the function keep track of what files it reads
07:31:55 <rwbarton> so that part is easy, and you can use operational for it
07:32:28 <rwbarton> though honestly I guess you can just use a newtype around WriterT [FilePath] IO and just export your modified readFile
07:32:35 <dropdrive> rwbarton: So a monad API is reasonable there?
07:32:35 <Philonous> rwbarton:  You still don't know that the set of files it reads remain constant
07:33:00 <rwbarton> Philonous, right but it doesn't have to. if we do the same computation again and none of the files it accesses have changed, then it will do the same computation and read the same files
07:33:18 <Philonous> rwbarton:  With IO involved. how do you know?
07:33:33 <rwbarton> because he is exporting only a single readFile' :: a -> FileIO a
07:33:37 <rwbarton> *FileIO String
07:33:38 <dropdrive> Philonous: I'm restricting myself to reading files in a particular way.
07:33:38 <Philonous> rwbarton:  It might get the list of files over the network
07:33:41 <rwbarton> nope
07:33:53 <rwbarton> his computation is in a specific "read files" monad
07:35:19 <dropdrive> rwbarton: I didn't understand the newtype statement, but maybe I'll get started with operational.
07:35:19 <rwbarton> dropdrive: are you familiar with Cloud Haskell at all?
07:35:37 <dropdrive> rwbarton: (I'm just trying to learn.)
07:35:41 <Philonous> OK, but you'd still only know the set of files after you had run the computation.
07:35:52 <dropdrive> rwbarton: Not really, no.
07:35:52 <rwbarton> yes
07:36:14 <Philonous> But I guess working around that is easier than using Arrows
07:36:24 <rwbarton> Philonous: so after the computation runs the first time, you put into the cache an identifier for the computation, the result and the list of all the files it read
07:37:11 <geekosaur> Philonous, you are correct in some "things can be modified without updating metadata if a cosmic ray hits at the wrong time" sense, but it seems to me what drpdrive is trying to do is otherwise sensible.  Yes, at a very low probability literally anything can happen, but the described operation is sufficiently constrained that they're not trying to model the entire universe.  (Or put otherwuise:  you are claiming Squid can't exist!)
07:37:12 <Philonous> rwbarton:  You can do that. But that'd be shoehorning the wrong abstraction into this use case.
07:37:26 <rwbarton> it doesn't seem like shoehorning
07:37:29 <rwbarton> it seems pretty direct to me
07:38:03 <watermind> Problem is, suppose you have a huge program that consistently uses a Monad abstraction, and then to make it more efficient you need your join have an Ord constrain... then you basically have to rewrite everthing, and basically redo the Monad lib with an added Ord context
07:38:13 <watermind> Or am I missing something?
07:39:19 <geekosaur> ...
07:39:31 <rwbarton> Philonous: maybe he *wants* to have which files he reads depend on the contents of previous files. i don't know
07:39:47 <Philonous> rwbarton:  OK, in that case arrows don't work anyway.
07:40:04 <dropdrive> rwbarton: Yes, my toy target example is to read a file of filenames and compute the hash of the catenation of those files
07:40:08 <rwbarton> agreed that if not, then arrows or applicative would have advantages
07:41:24 <dropdrive> rwbarton: Anyway, bringing the discussion back down to my level -- "operational" is the easiest way forward?  (Note again that this is for learning, not for real-life...)
07:42:12 <Philonous> dropdrive:  operational is a way of building custom monads. You define the operations you want as constructors of a type that becomes the Monad and write an interpreter of the operations
07:42:56 <rwbarton> I think it's sort of overkill, really, having thought about this some more--but it would be a pretty easy way to do it, and it's very flexible
07:44:01 <rwbarton> can't you just use WriterT [FilePath] IO?
07:44:29 <Philonous> or even WriterT (Data.Set.Set FilePath) IO
07:44:58 <rwbarton> ah yeah, that is a monoid under union, nifty
07:46:32 <dropdrive> Okay, thanks all for the help.
07:47:28 <dropdrive> I guess I'll try it both ways and compare the experiences.
07:48:08 <HugoDaniel> i like ziplists
07:48:29 <HugoDaniel> save a lot of time when im coding with my brain in energy saving mode
07:53:11 <Sculptor> hi
07:54:13 * hackagebot hipe 0.1.1.0 - Support for reading and writing ipe7 files (http://ipe7.sourceforge.net)  http://hackage.haskell.org/package/hipe-0.1.1.0 (FrankStaals)
07:58:47 <mm_freak_> HugoDaniel: if you like ziplists, you may fall in love with the automaton arrow
07:59:48 <HugoDaniel> mm_freak_: i should read up on that :)
08:00:54 <quchen> If I have some CAF used by different functions, can I assume GHC doesn't inline it, or do I need a NOINLINE pragma? Example: Fibonacci sequence at top level, multiple different functions use it for calculations.
08:01:26 <quchen> Would surprise me if GHC wasn't smart enough to do that, but better safe than sorry :-)
08:01:44 <mm_freak_> HugoDaniel: don't read, but try to define the Category instance for that one:  newtype Auto a b = Auto (a -> (b, Auto a b))
08:02:57 <mm_freak_> HugoDaniel: the idea is this:  an instant of one automaton receives its input from the same instant of another automaton
08:03:29 <mm_freak_> quchen: you need NOINLINE
08:03:58 <quchen> mm_freak_: Oh, didn't expect that. Is there a specific reason for that?
08:04:23 <quchen> I mean it's quite clear that CAFs need to be calculated once only
08:04:37 <mm_freak_> quchen: no formal reason…  it's just an unsafe assumption
08:05:04 <mm_freak_> quchen: the compiler may very well decide to inline it
08:05:16 <rwbarton> you probably don't want NOINLINE
08:05:37 <quchen> rwbarton: Hmm? Why's that?
08:05:38 <mm_freak_> quchen: reason: CAFs when never inlined always eat up your heap space at all times
08:05:54 <quchen> Hm, makes sense for large CAFs, right.
08:06:01 <rwbarton> if you write "fib = 0 : 1 : zipWith (+) fib (tail fib)" and then later use "head fib" wouldn't you prefer it got inline to "0"
08:06:37 <rwbarton> I don't think GHC will inline a recursive definition anyways.
08:06:53 <quchen> rwbarton: Well, not sure. The price of that would be re-calculating 10000 terms of the series somewhere else.
08:07:11 <rwbarton> I really don't think GHC would do that.
08:07:42 <quchen> So as a general conclusion: if inlining is an issue, do it manually to be sure?
08:08:07 <weox> why i cant install gio ??  : http://pastebin.com/2yyeMiiN
08:08:16 <rwbarton> my general conclusion would tend to be: let GHC worry about the inlining until you have a specific performance problem
08:08:41 <rwbarton> then you can decide whether you want NOINLINE or INLINE or what
08:08:46 <quchen> ... as in a constant base level in the heap profile?
08:10:33 <osa1> I don't understand how quickcheck works, why does it have 2 different definition of Result data type ?
08:11:05 <typoclass> osa1: you mean there's 2 different "instance Result ... where ..." definitions?
08:11:15 <rwbarton> in general GHC is a lot more likely to share a value you didn't want to share than the reverse
08:11:18 <typoclass> osa1: that's normal :-) that's how typeclasses work
08:11:27 <osa1> typoclass: no, it has two `data Result` definitions
08:11:39 <rwbarton> osa1, link?
08:11:42 <typoclass> osa1: oh interesting. do you have a link?
08:11:48 <osa1> http://hackage.haskell.org/packages/archive/QuickCheck/2.5.1.1/doc/html/src/Test-QuickCheck-Test.html#Result and http://hackage.haskell.org/packages/archive/QuickCheck/2.5.1.1/doc/html/src/Test-QuickCheck-Property.html#Result
08:12:25 <HugoDaniel> mm_freak_: interesting, and what is an automaton ?
08:12:29 <quchen> rwbarton: Thanks, I'll make sure to sprinkle more NOINLINES in my code from now on
08:12:55 <fmap> weox: did you upgrade gtk2hs-buildtools to 0.12.4?
08:13:03 <typoclass> osa1: yeah, those are in different modules. that's always possible. but you're right, it could be confusing for a human reader
08:13:19 <HugoDaniel> oh i see, like in automata theory
08:13:33 <HugoDaniel> cool
08:13:58 <watermind> which pragma do I need to access the kind Constraint ?
08:14:06 <`nand`> ConstraintKinds
08:14:16 <watermind> hmm I have it
08:14:20 <typoclass> osa1: note the line "import qualified Test.QuickCheck.Property as P" in T/Q/Test.hs. it means Result will be the one defined in Test.hs, and P.Result will refer to the one from Property.hs
08:14:20 <`nand`> oh
08:14:22 <`nand`> you need to import it
08:14:25 <`nand`> GHC.Exts (Constraint)
08:14:28 <watermind> oh
08:14:34 <watermind> thanks `nand`
08:14:49 <mcstar> `nand`? who is that?
08:14:57 * `nand` is secretly nand`
08:15:02 <mcstar> oh
08:15:03 <`nand`> but shh
08:15:13 <rwbarton> quchen, the only use for NOINLINE I have ever heard of is in conjunction with unsafePerformIO (or if you are very concerned about code size I guess)
08:15:17 <weox> fmap : thanks for helping , wait 2 min , i reinstall alex and gtk2hs-buildtools , i give you answer after 2 min :d
08:15:35 <quchen> Speaking of QuickCheck, why was the Batch module removed in 2.0? I haven't seen a replacement when going through the other new modules. Right now, I'm mapM-ing individual tests.
08:15:47 <rwbarton> quchen, here is an experiment for you, try with INLINE and see whether ghc recomputes the value at each call site :)
08:16:06 <rwbarton> I bet it won't
08:16:21 <rwbarton> at least not if the definition is recursive
08:16:50 <weox> fmap : it seems problem is from alex , i reinstall alex , but when i want to install gtk2hs-buildtools it says : alex not found cabal: The program alex is required but it could not be found.
08:17:14 <dcoutts> weox: probably need to add ~/.cabal/bin to your $PATH
08:17:51 <mm_freak_> HugoDaniel: it's a generalized ziplist
08:18:09 <mm_freak_> HugoDaniel: a very useful one…  AFRP is based on it
08:18:20 <osa1> typoclass: so which one should I use ? I need to indicate what was expected and what was found in case of an error. I think one way to do that is to return one of these data types in Testable typeclass's property method
08:19:10 <mcstar> how does 'extra-libraries:
08:19:15 <mcstar>  ' work with cabal?
08:19:24 <mm_freak_> HugoDaniel: the following type is isomorphic to Auto and provides some insight:  data LS a b = forall s. LS s ((a, s) -> (b, s))
08:19:32 <mm_freak_> HugoDaniel: the "LS" stands for "local state" =)
08:19:49 <dcoutts> mcstar: lists libraries to link in with the code
08:19:56 <mm_freak_> younnes is spamming me via notice
08:20:10 <mcstar> dcoutts: yeah, but how does it work?
08:20:11 <typoclass> osa1: i don't know about quickcheck. i'd try one Result, if you get a tpye error, try the other *shrug*
08:20:24 <mcstar> how does it determine if something is there or isnt there?
08:20:38 <dcoutts> mcstar: ah ok, you mean during configure.
08:20:44 <mcstar> for example, i have 'glu' installed, but it doesnt recognize it
08:20:55 <mcstar> yeah
08:21:04 <dcoutts> mcstar: it makes a trivial .c file and asks gcc to link using the given library
08:21:24 <dcoutts> mcstar: on the basis that if gcc can't find it then we're screwed.
08:21:40 <mcstar> hm, thanks
08:22:16 <dcoutts> mcstar: so you say glu is installed, but is it installed in the expected place, would one normally have to specify extra linker dirs, or perhaps glu uses pkg-config to find the right flags
08:22:42 <dcoutts> mcstar: extra-libraries: foo corresponds to compiling with -lfoo
08:22:47 <mcstar> it is installed by pacman, like all my libs
08:23:00 <dcoutts> so if you need more than -lfoo then you need more than extra-libraries: foo
08:23:20 <mcstar> /usr/lib/libGLU.so
08:23:27 <mcstar> that looks pretty normal
08:23:31 <dcoutts> ah so it's not called glu then but GLU
08:23:43 <mcstar> yeah, but GLU is in the cabal file
08:23:59 <mcstar> i was just sloppy, writing it here :)
08:24:15 <dcoutts> mcstar: well run configure again with -v3, you'll see what gcc says when it tries to link it
08:25:05 <mcstar> /usr/bin/ld: cannot find -lGLU
08:25:35 <mcstar> younnes: problem?
08:25:46 <mcstar> younnes: you dont need to flood me, thanks
08:26:03 <rwbarton> doesn't it need libGLU.so.3 or whatever
08:26:08 <klasdavid> is an int always 32bits or is that platform dependent?
08:26:23 <quicksilver> it is platform and compiler dependent
08:26:28 <mm_freak_> again, younnes is spamming via notice
08:26:38 <mcstar> mm_freak_: you too?
08:26:40 <mm_freak_> yes
08:26:46 <quicksilver> on GHC it is the native int size of the machine
08:26:46 <mm_freak_> it's a bot i guess
08:26:58 --- mode: ChanServ set +o quicksilver
08:27:04 <rwbarton> oh me too, fortunately I hardly noticed in irssi
08:27:12 --- kick: younnes was kicked by quicksilver (younnes)
08:27:16 <mm_freak_> thanks
08:27:23 <quicksilver> removing him here won' stop hiim noticing you
08:27:24 <simpson> I thought that Ints were 30 bits.
08:27:33 <quicksilver> and if he's a bot he will already have the complete channel list
08:27:38 <quicksilver> so it's a fairly token gesture :P
08:27:39 <geekosaur> that's the minimum required, not the fixed size
08:27:40 <mm_freak_> simpson: at least 29 bits without sign, something like that
08:27:41 <rwbarton> in GHC Int is 32 bits on x86 and 64 bits on x86_64
08:27:56 <int-e> simpson: the report specifies that they are *at least* that size
08:28:04 <simpson> Ah.
08:28:20 <mm_freak_> quicksilver: the spam trigger is a message to this channel, so the kick indeed stopped him
08:28:29 <mm_freak_> (it)
08:29:03 <quicksilver> mm_freak_: oh, strange
08:29:18 <mm_freak_> probably some new trolling scheme
08:29:50 <mcstar> i wonder if we did receive the same message?
08:30:03 <mm_freak_> 523 172630 [fn] -younnes(~younnes@146.185.24.207)- Hey mm_freak_ ! don't say bullshit on #haskell please, thanks
08:30:14 <mm_freak_> not quite the same, but the edit distance should be small
08:30:14 <mcstar> then no
08:30:28 <mcstar> it says, Hey mcstar in mine
08:30:38 <mcstar> ...
08:30:39 <int-e> ;)
08:30:46 <weox> dcoutts : i add ~/.cabal/bin to my $PATH but still dosnt work !!
08:30:48 <geekosaur> probably thinks it makes it harder for them to be klined or something.  I suggest dropping into #freenode
08:30:50 <mm_freak_> hehe
08:31:08 <dcoutts> weox: what does: which alex   say?
08:31:46 <weox> ~/.cabal/bin/alex
08:31:50 <mcstar> oh! my lib doesnt actually exist!
08:32:32 <weox> dcoutts :  http://pastebin.com/5YbXcHNW
08:32:33 <dcoutts> weox: hmm, I'm not sure if literally using ~ in the $PATH works
08:32:45 <geekosaur> it does not, reliably
08:32:57 <geekosaur> ~ is a shell-ism, anything that uses the C API will not expand it
08:33:02 <dcoutts> weox: oh ok it does work, now it's asking about happy.
08:33:02 <`nand`> hey, I was on the receiving end of that spambot before
08:33:15 <mcstar> dcoutts: thanks, a reinstall of the lib solved it
08:33:18 <rwbarton> "cabal: The program happy is required but it could not be found"
08:33:20 <`nand`> but I think under a different name
08:34:22 <weox> dcoutts : thanks a lot , sorry for mis understanding :D
08:34:27 <dcoutts> np
08:34:49 <mm_freak_> now this feels like a huge step back…  the GLFW library actually signals failure by returning False…  this is about the worse possible instance of "Bool is evil"
08:35:54 <watermind> is explicit kind signature in class declarations possible? e.g.  class M (m :: *->*) where
08:36:36 <hpc> yes
08:36:53 <hpc> i think KindSignatures is the extension you need
08:36:59 <watermind> hpc: do you know the required pragama?
08:37:24 <watermind> I was searching for it but only was able to find DatatypeContexts
08:37:51 <watermind> hpc: hmmm I have KindSignatures
08:37:52 <Philonous> watermind:  {-# LANGUAGE KindSignatures #-}
08:38:20 <watermind> Philonous: I do have that... not working when I try to use it in classes
08:38:50 <rwbarton> surprised it doesn't work
08:39:14 <rwbarton> it does work for me
08:39:28 <watermind> really?
08:39:51 <watermind> I'm on 7.4.1
08:39:57 <rwbarton> {-# LANGUAGE KindSignatures #-} class Foo (m :: * -> *)
08:39:59 <rwbarton> 7.4.2 here
08:40:12 <watermind> actually 7.4.2 now that you mention it
08:40:25 <Philonous> watermind:  Maybe paste your entire file?
08:40:36 <Philonous> watermind:  Might be another problem
08:40:50 <Philonous> @where paste
08:40:51 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
08:41:18 <beaky> Why is the Curry-Howard correspondence so significant?
08:41:34 <rwbarton> adsfafdsaf
08:41:39 <copumpkin> I agree with rwbarton
08:42:01 <hpaste> watermind pasted “test” at http://hpaste.org/78114
08:42:30 <watermind> rwbarton: ^
08:43:07 <watermind> rwbarton: sorry for the delay, my firefox was acting up
08:43:21 <rwbarton> watermind: needs spaces
08:43:24 <rwbarton> *->* is a single token
08:43:31 <watermind> argh
08:44:03 <watermind> rwbarton: thanks... as you can see I haven't used kind signatures that often
08:44:18 <hpc> haha
08:44:28 <hpc> i had no idea that kind of error was possible
08:44:49 <rwbarton> I didn't realize that was the problem when you wrote it the first time even though I have seen this issue before
08:44:53 <rwbarton> it's very misleading, *->* :)
08:44:57 <hpc> perhaps using "prefix" (*) instead of * would be better?
08:46:37 <atriq> Is there a Data.Set.Bind floating about somewhere?
08:47:11 <lispy> beaky: it ties together programmer and logic
08:48:01 <lispy> beaky: it allows you to use the type system of a programming language to state propositions (lemmas and theorems) and then to use the program that implements that type as a proof of that proposition
08:48:02 <weox> i have problem with cabal , cabal dosnt work well for some reason ( i dont know ) , look at this : http://pastebin.com/Uvhm5u8h ,, or look at this : http://pastebin.com/2yyeMiiN
08:48:04 <atriq> :t S.foldl S.union mempty
08:48:06 <lambdabot> Ord a => S.Set (S.Set a) -> S.Set a
08:48:20 <beaky> ah
08:48:33 <atriq> :t \f -> S.foldl S.union mempty . S.map f
08:48:35 <lambdabot> (Ord a1, Ord a) => (a1 -> S.Set a) -> S.Set a1 -> S.Set a
08:48:35 <beaky> so the curry-howard isomorphism is the reason djinn works?
08:48:50 <beaky> @djinn (a -> b) -> (b -> a)
08:48:50 <lambdabot> -- f cannot be realized.
08:48:53 <beaky> :(
08:48:59 <dcoutts> weox: looks like you've got a broken Cabal lib, probably want to unregister it
08:49:07 <lispy> beaky: Right although djinn brings in other ideas too
08:49:34 <beaky> @djinn (a -> b -> c) -> (b -> a -> c)
08:49:34 <lambdabot> f a b c = a c b
08:49:38 <beaky> wow
08:49:39 <weox> dcoutts : yes, i think some of lib in aur arch ( i install 3 4 hr ago ) is broken !! how can i fix that ??
08:49:39 <rwbarton> weox: the second paste indicates that gio isn't updated for ghc 7.6
08:49:44 <watermind> copumpkin: by the way... do you kind of remember this: http://hpaste.org/77930 ?
08:49:47 <dcoutts> weox: oh, rather it's deps are broken, run ghc-pkg check
08:49:47 <simpson> beaky: How would you write the function whose type you passed in?
08:50:05 <beaky> simpson: that first one? I don't know :(
08:50:07 <lispy> beaky: Keep in mind, the programming language/logic you pick changes how strong the proof is. For example, Haskell makes for an inconsistent logic because we _|_ inhabits every type and we have general recursion.
08:50:22 <beaky> ah
08:50:25 <watermind> copumpkin: the idea was to restrict a phantom type to only 2 possible types Poly and Mono
08:50:27 <atriq> :t Data.Foldable.fold `asTypeOf` S.foldl S.union mempty
08:50:28 <lambdabot> Ord a => S.Set (S.Set a) -> S.Set a
08:50:34 <beaky> what about conventional programming languages like C
08:50:36 <beaky> or Java
08:50:47 <beaky> or the other purely-functional ones like Agda and Coq
08:51:38 <lispy> beaky: in Agda and Coq proofs have the normal mathematical rigor  you would expect because they were carefully designed to disallow inconsistencies
08:51:50 <weox> dcoutts : http://pastebin.com/ExZX3WTc
08:51:52 <copumpkin> watermind: I do, but I need to leave right now, sorry! I'll probably be offline for a while today
08:51:54 <watermind> copumpkin: actually we can always extend it by definin a new  type of kind system via type families, e.g.: type family New :: System
08:51:56 <lispy> Java and C, not so much
08:51:56 <copumpkin> ciao :)
08:52:02 <copumpkin> I'll check logs
08:52:05 <watermind> copumpkin: no worries have a good day
08:53:05 <lispy> beaky: in math you pick an underlying logic that will give you the "power" your argument needs. Math traditionally uses "classical logic".
08:53:22 <beaky> the one that socrates and plato used?
08:53:23 <lispy> beaky: but there is also "constructive logic" which more closely relates to Agda/Coq
08:53:29 <dcoutts> weox: hmm, strange, it says Cabal, array etc are not broken
08:53:34 <beaky> what is constructive logic?
08:54:03 <lispy> constructive logic is like classical, but without the law of the excluded middle. Hang on, I have a good intro for this and the history significance.
08:54:09 <beaky> ah
08:54:13 <beaky> what is excluded middle
08:54:27 <dcoutts> weox: do you have more than one ghc installed?
08:55:13 <weox> dcoutts : no ,which ghc just say /usr/bin/ghc
08:55:30 <dcoutts> weox: and ghc-pkg also from /usr/bin ?
08:55:32 <beaky> http://lambda-the-ultimate.org/node/1532#comment-17867 I read from this
08:55:44 <hpc> beaky: in a sense, constructive logic is where you prove things by "here's an example of it"
08:55:59 <hpc> where classical logic can prove things by "it's not possible for this to be false"
08:56:19 <mm_freak_> is there a name for automorphisms f with the property f . f = id?
08:56:25 <beaky> ah
08:56:30 <rwbarton> mm_freak_: involutions
08:56:32 <hpc> mm_freak_: self-inverse?
08:56:41 <weox> dcoutts : yes , i am going to uninstall whole of haskell from my computer , and re isntall ghc from pacman , and lib from cabal , ( yasterday i made mistake and install 4 5 lib from aur.arch)
08:57:00 <dcoutts> weox: ok, while you're at it, make sure you rm -r ~/.ghc
08:57:09 <dcoutts> weox: or perhaps just try that first
08:57:13 <mm_freak_> rwbarton: can i use this term in the context of category theory?
08:57:13 <rwbarton> weox: are you trying to build some specific package? I would tend to recommend sticking with ghc 7.4 which is no longer in arch
08:57:29 <beaky> so constructive logic is like making proporisitions from prototypes?
08:57:35 <rwbarton> mm_freak_, hmm, I guess? normally I hear it used in the context of permutation theory
08:57:40 <weox> dcoutts : thnks
08:58:16 <weox> rwbarton : if it dosnt work , i downgrade to 7.4 !!
08:58:28 <rwbarton> ok :)
08:58:40 <lispy> beaky: http://www.andrew.cmu.edu/user/avigad/Teaching/classical.pdf
09:00:05 <lispy> beaky: law of excluded middle basically says, something is either True or False, so if I show it is either not True or not False then it must be the other.
09:00:10 <mm_freak_> rwbarton: thanks
09:00:30 <mm_freak_> i confused endomorphism with automorphism, but thankfully in this context both are right =)
09:00:37 <lispy> beaky: if you remove the law of the excluded middle from your bag of tricks (eg., remove it from the logic) then you lose things like proof by contradiction
09:01:09 <lispy> beaky: It may still be the case that something is either True or False, but now you have to show that for each "thing" you consider instead of having a general rule that says you can do this.
09:02:03 <beaky> ah
09:03:46 <kqr> typoclass, regarding you thinking `f' and `xs' are okay variable names if they are defined almost immediately afterwards
09:04:03 <typoclass> kqr: right
09:04:06 <kqr> typoclass, i wonder how common your line of thinking is among haskell users compared to users of other programming languages
09:04:26 <typoclass> kqr: i think it is fairly common in haskell
09:04:32 <`nand`> typoclass/kqr: what's this about? :)
09:04:49 <hpc> it's easier in haskell because such names are rarely in scope for longer than a couple of lines
09:04:51 <monochrom> look at the Prelude. short, generic names are very common
09:05:14 <monochrom> short name for generic things. long name for specific things
09:05:21 <kqr> `nand`, we provided alternative refactorings for someones short snippet yesterday
09:05:27 <`nand`> my philosophy is that scoped names should be as short as possible, while exported names needn't
09:05:34 <typoclass> `nand`: i said 1 or 2 days ago that i'm fine with 1-letter variable names in a 5-line function, and in general my rule of thumb is the bigger the scope, the longer the name
09:05:38 <monochrom> and also yeah, short name for small scope, long name for large scope
09:05:41 <kqr> `nand`, i suggested more descriptive variable names than `f' and `xs' but typoclass disagreed
09:05:59 <monochrom> people outside participate in the religion of "meaningful names"
09:06:24 <lispy> another consideration is that when you're passed a function it can be hard to give a good name for it (you don't know what it does! only what you expect it to do...)
09:06:30 <`nand`> if I assign semantic to some variable, then I take the first letter of whatever descriptive name I can come up with :)
09:06:39 <rwbarton> the same rule is even in Java. they have their SimpleBeanFactoryAwareAspectInstanceFactory but don't they still use "int i" in a loop
09:06:44 <`nand`> for example, assuming we didn't have the whole ‘x:xs’ convention; I could use ‘h:t’ for head : tail
09:06:55 <kqr> lispy, yeah, of course, but this time the function/list was very well defined
09:07:05 <hiptobecubic> i think 'f' is pretty well understood to mean "some blackbox function" as a variable and "functor" as a type
09:07:07 <kqr> for a general function/variable name, of course choose any name you like
09:07:17 <`nand`> int descruptivelyMutableEnumerationVariable
09:07:21 <`nand`> descructively, even
09:07:42 <kqr> but in this case they referred to something specific
09:07:44 <kqr> whatever that was
09:07:46 <beaky> interesting typo
09:07:49 <kqr> my memory isn't *that* good
09:08:05 <beaky> how do typos where the misspelled letters are transposed happen?
09:08:28 <typoclass> kqr: i think the important thing is to think about clarity, and try to make it as clear as possible. if you have 79 variables, it'd be very unclear to have only 2-letter names. if you have 3 variables and you give each a name that is 11 words long, i'd argue that this is unclear too, because of needless clutter
09:08:33 <hiptobecubic> beaky, race condition
09:08:38 <beaky> ah
09:08:48 <monochrom> typoclass++
09:09:12 <hiptobecubic> particularly in a totally obvious context like (x:xs)
09:09:13 <`nand`> laziness trumps clarity for me
09:09:13 <kqr> typoclass, so 'xs' is a better variable name than, say, 'students' for a list of students?
09:09:24 <typoclass> kqr: so i think you can adopt a rule of thumb or two, but really, the only fixed rule is, make it as clear as you can :-) be kind to the kqr of 2013 that will look at the code again and go "oh god what did i do here"
09:09:25 <`nand`> I want to type less rather than more :)
09:09:43 <`nand`> so if something is simple enough so that I as programmer don't get confused, I'll assume it's simple enough for anybody reading my source code
09:09:53 <beaky> I like using x and xs for generic functions, and student or students for functions on [student] types
09:10:01 <kqr> beaky, that's what i suggest too
09:10:16 <Nereid> "student" is a lot of typing
09:10:18 <lispy> It should also be noted that several Haskell idioms exist that remove the need to even create names for things.
09:10:21 <kqr> beaky, but the general opinion here almost seems to be that laziness trumps that
09:10:27 <beaky> ah
09:10:29 <monochrom> clearly, a student is just a number, so, x and xs.  <duck>
09:10:34 <beaky> lol
09:10:38 <hiptobecubic> i just switch to a letter suggests the type
09:10:43 <hiptobecubic> s:ss for example
09:10:45 <beaky> right
09:10:48 <fryguybob> kqr: xs has the advantage of being similar to a lot of other code where students is rather specific (which can be good in some cases).
09:10:53 <kqr> lispy, of course
09:11:04 <beaky> pointfree ftw!
09:11:05 <typoclass> kqr: sure, i'd definitely call it students. however if i implement some general function that processes any list, i'm happy with xs. that's the usual name for "some kind of list, doesn't matter which"
09:11:10 <kqr> lispy, i was thinking of breaking stuff out to assignments for the sake of easier reading and/or self-documentation
09:11:10 <`nand`> to avoid the naming issue I run everything through @pl
09:11:18 <kqr> typoclass, oh, definitely xs then
09:11:25 <`nand`> I mean, if you ever get lost in the resulting soup, you can always just @unpl it for clarity
09:11:41 <hiptobecubic> lol
09:11:43 <typoclass> kqr: it's hard to say without context :-) it's like that judge said about pornography, "i can't really define it in the abstract, but i know it when i see it"
09:11:43 <hiptobecubic> yes
09:11:47 <lispy> kqr: I didn't look at your code, but as was already pointed out clarity should be the guiding principle here. So yeah, sounds about right.
09:11:55 <hiptobecubic> Nothing says "clarity" like a round trip through pl
09:12:00 <rwbarton> `nand`: the assembly of Haskell
09:12:04 <kqr> typoclass, haha
09:12:10 <`nand`> rwbarton: :)
09:12:24 <beaky> @pl \f l -> case l of {[] -> [];(x:xs) -> f x : map f xs};
09:12:24 <lambdabot> (line 1, column 19):
09:12:25 <lambdabot> unexpected '{'
09:12:25 <lambdabot> expecting variable, "(", operator or end of input
09:12:27 <beaky> :(
09:12:30 <`nand`> rwbarton: I honestly want a Haskell-to-pure-lambda-calculus-with-C-FFI (co)mpiler
09:12:30 <hiptobecubic> I don't know why acted like there was no good definition for porn
09:12:57 * ocharles screams at hs-boot files
09:13:04 <ocharles> even my hs-boot has a cycle >.<
09:13:13 <typoclass> kqr: sure, i do that as well sometimes. i have a long expression that doesn't seem easily digestable anymore, and i pull out 1 or 2 parts of it, using a 'where' to name the parts just for clarity
09:13:14 <lispy> ocharles: I always break the cycle by adding a new module
09:13:18 <hiptobecubic> why he*
09:13:21 <kqr> http://pastebin.com/3ZbjGF6d <---- that was the particular example i was thinking of
09:13:23 <mauke> The paste 3ZbjGF6d has been copied to http://hpaste.org/78115
09:13:23 <ocharles> i haven't managed to do that lispy, that's my normal approach
09:13:25 <kqr> generic or specific variable names?
09:13:27 <lispy> ocharles: IMO, recursive modules are not worth the trouble
09:13:35 <ocharles> this shit is so intertwined it's a complete mess
09:13:45 <ocharles> soon i'm just going to cat it all into a single damn file i've wasted so much time on this
09:13:53 <monochrom> I am not convinced that it is productive to argue over students vs xs for a function consisting of just 5 lines of code. a single function consisting of 100 lines of code, sure.
09:13:56 <lispy> ocharles: :(
09:14:02 <typoclass> monochrom++
09:14:17 <monochrom> however, you don't bloody write 100 lines of code for a single function
09:14:29 <hiptobecubic> pos instead of xs and you're good.
09:14:36 <lispy> 100 lines of Haskell could take a very long time to understand.
09:14:44 <rwbarton> or how about xys
09:14:50 <lispy> It's unlikely you could hold that function in your working memory
09:14:54 <typoclass> kqr: i think in a 5-line function, it could be "f xs" and just as well "setpos coords". either one is fine. and what monochrom says
09:14:56 <hiptobecubic> or that
09:15:03 <kqr> typoclass, right
09:15:16 <monochrom> so, with just 5 lines of code, or maybe 6, it seems religious dogma to insist on "students" and go evangelize the doctrine of "meaningful" names
09:15:43 <kqr> oh i'm not insisting
09:15:50 <kqr> i was just curious about the statistics of it
09:15:56 <kqr> to see if i could learn something one way or the other
09:16:09 <typoclass> kqr: that's what i meant with the "big scope long name" rule. if the f is defined one line after it's used, no worry. if it's defined 100 lines after it's used, double-check that
09:16:27 <kqr> i don't think i've seen anything similar with users of other programming languages
09:16:31 <kqr> there sure has to be a reason for that
09:16:34 <monochrom> alright, the statistics is we use shorter, more generic names. since we can afford to.
09:17:01 <hpaste> rwbarton annotated “Alternative suggestion (untested)” with “Alternative suggestion (untested) (annotation)” at http://hpaste.org/78115#a78117
09:17:08 <typoclass> kqr: i think "for i = 0 ; i ++ ; ..." is pretty common in many languages (whatever the exact syntax)
09:17:10 <rwbarton> would probably rewrite it something like that
09:17:22 <rwbarton> and avoid all the extraneous names 'f', 'p'
09:17:25 <monochrom> for some reason or another, the language lets us write shorter units, which unit more generic
09:17:31 <rwbarton> I see I dropped a } on line 2
09:17:50 <kqr> typoclass, true, but that is indeed for a generic counter variable
09:17:59 <kqr> typoclass, you coud name it 'counter' but you wouldn't really gain anything
09:18:22 <monochrom> s/which/each/
09:18:34 <typoclass> kqr: exactly! so in haskell, there's no 'i' because there's no for loops, but there's the convention of x, xs, and maybe one or two others
09:18:59 <kqr> typoclass, but they are not only used for generic variables
09:19:40 <int-e> @src id
09:19:41 <lambdabot> id x = x
09:19:44 <kqr> typoclass, also in very specific cases, which i feel is one missed opportunity of making the code more self-documenting
09:19:44 <typoclass> rwbarton: i like it. needs a little moar >> however :-)
09:20:06 <rwbarton> could have done, would have needed to tweak the $ stuff though
09:20:14 <lispy> :t for
09:20:16 <lambdabot>     Not in scope: `for'
09:20:16 <lambdabot>     Perhaps you meant one of these:
09:20:16 <lambdabot>       `Data.Traversable.for' (imported from Data.Traversable),
09:20:35 <lispy> > for [1..3] show
09:20:37 <lambdabot>   Not in scope: `for'
09:20:37 <lambdabot>  Perhaps you meant one of these:
09:20:37 <lambdabot>    `Data.Traversable.f...
09:20:51 <monochrom> in the limit, we sometimes use 0-length names
09:20:53 <lispy> > Data.Traversable.for [1..3] show
09:20:55 <lambdabot>   ["123"]
09:21:07 <monochrom> > filter (> 0) [-1, 1, -2, 4]
09:21:09 <lambdabot>   [1,4]
09:21:21 <typoclass> kqr: yup, as i said before, for me clarity is the most important thing. if "xs" gets in the way of being self-documenting, i'll take it out. if "students" gets in the way by being needless clutter, i'll take that out
09:21:22 <monochrom> (> 0), (\x -> ...) etc have 0-length names
09:21:42 <quchen> Wait, why is my GHCi writing functions on its own? Oh, Lambdabot again.
09:21:44 * typoclass has got to run now. as they say, "i've already told you more about this than i know"
09:21:49 <monochrom> in stupid languages, you must give them non-empty names
09:22:15 <kqr> typoclass, haha, sounds fair enough
09:22:20 <monochrom> when you collect statistics for our name lengths, don't forget to count our 0-length names
09:22:22 <kqr> typoclass, i just can't stop finding it very interesting
09:23:10 <int-e> monochrom: that would be pointless
09:23:13 <mcstar> @hoogle (<>)
09:23:13 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
09:23:13 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
09:23:13 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
09:23:15 <typoclass> monochrom: sometimes i wish we had (map _ $ reverse $ doodle _ u) expand to (\x y -> map x $ reverse $ doodle y u)
09:23:26 <mcstar> isnt <> the monoid mconcat?
09:23:40 <rwbarton> hoogle may be out of date
09:23:44 <rwbarton> > "a" <> "b"
09:23:44 <monochrom> it would be fun to present in a programming conference, "average name length in haskell is 0.98". people will go nuts, "wait a second, how can it be lower than 1!" :)
09:23:46 <lambdabot>   "ab"
09:23:49 <rwbarton> hooray
09:23:50 <typoclass> mcstar: yes, in recent base versions. it was only introduced a few months ago
09:24:09 <mcstar> oh, which module do i need to import?
09:24:09 <kqr> monochrom, hahaha
09:24:35 <mcstar> ah, Data.Monoid
09:24:40 <mcstar> thx
09:24:56 <beaky> what is a monoid
09:25:09 <donri> :t (<>)
09:25:11 <lambdabot> Monoid m => m -> m -> m
09:25:15 <beaky> oh
09:25:18 <mcstar> something concatenateble?
09:25:19 <donri> oh nice, that used to be a pretty printer thing in lambdabot
09:25:24 <beaky> > [1..3] <> [1..10]
09:25:24 <mcstar> my working definiton :(
09:25:26 <mcstar> :)
09:25:27 <lambdabot>   [1,2,3,1,2,3,4,5,6,7,8,9,10]
09:25:31 <beaky> oh
09:25:35 <beaky> :t mappend
09:25:37 <lambdabot> Monoid a => a -> a -> a
09:25:44 <beaky> > mappend "foo" "bar"
09:25:46 <lambdabot>   "foobar"
09:25:49 <donri> beaky: anything that has an identity element and an associative binary operation is a monoid
09:25:53 <beaky> so monoids are just that?
09:26:06 <beaky> @src Monoid
09:26:07 <lambdabot> class Monoid a where
09:26:07 <lambdabot>     mempty  :: a
09:26:07 <lambdabot>     mappend :: a -> a -> a
09:26:07 <lambdabot>     mconcat :: [a] -> a
09:26:09 <mcstar> > 1 <> 2
09:26:11 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:26:11 <lambdabot>    (GHC.Num.Num a0)
09:26:12 <lambdabot>      a...
09:26:16 <donri> for lists, the empty list is the identity element and concatenation is the associative binary operation
09:26:30 <beaky> > mconcat "bar"
09:26:32 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
09:26:32 <lambdabot>    arising from a use o...
09:26:33 <donri> for numbers, there are at least two possible monoids, 1 and * or 0 and +
09:26:34 <beaky> :(
09:26:38 <mcstar> beaky: 'binary'
09:26:51 <kqr> > mempty :: String
09:26:53 <lambdabot>   ""
09:26:55 <kqr> neat
09:26:59 <HugoDaniel> http://www.haskell.org/pipermail/haskell/2012-November/023566.html :(
09:27:00 <beaky> > mconcat ["foo","bar"]
09:27:02 <lambdabot>   "foobar"
09:27:02 <beaky> ah
09:27:03 <donri> mempty :: Sum Int
09:27:09 <donri> > mempty :: Sum Int
09:27:11 <lambdabot>   Sum {getSum = 0}
09:27:12 <beaky> what are some cool things we can do with monoids?
09:27:21 <kqr> turn two strings into one!
09:27:22 <mcstar> you just witnessed them
09:27:24 <HugoDaniel> simon marlow is stopping from developing ghc fulltime :(
09:27:25 <beaky> that's it?
09:27:31 <mcstar> HugoDaniel: old news
09:27:33 <parcs`> HugoDaniel: old news, man
09:27:39 <mcstar> parcs`: high five
09:27:45 <parcs`> :)
09:27:54 <donri> monoids don't do a whole lot themselves. they're useful bread and butter for building further abstractions like foldable/traversable and the writer monad
09:27:56 <mzero> > getFirst $ mconcat $ map First [ [], [3], [3,5], [], [7] ]
09:27:58 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0'
09:27:58 <lambdabot>              with actual...
09:27:58 <beaky> I heard that monoids were monads in the category of endofunctors. is that true?
09:27:59 <kqr> beaky, strings are "that's it?"
09:28:03 <kqr> beaky, my strings are pretty useful
09:28:04 <mzero> d'oh
09:28:13 <rwbarton> beaky, no
09:28:14 <kqr> beaky, the other way around!
09:28:20 <mzero> > getFirst $ mconcat $ map First [ Nothing, Just 3, Nothing, Just 8 ]
09:28:22 <lambdabot>   Just 3
09:28:23 <HugoDaniel> sorry, ive only seen this now
09:28:32 <beaky> so monads are monoids with superpowers
09:28:34 <mzero> > getLast $ mconcat $ map Last [ Nothing, Just 3, Nothing, Just 8 ]
09:28:36 <lambdabot>   Just 8
09:28:36 <HugoDaniel> what will happen now ?
09:28:38 <parcs`> HugoDaniel: we're joking :)
09:28:40 <rwbarton> beaky, also no
09:28:46 <HugoDaniel> :)
09:29:00 <mzero> Notice that there are two ways to make Maybe be a Monoid - and we express that in Haskell by the newtypes First and Last
09:29:03 <rwbarton> unless you interpret words in a specific way
09:29:28 <donri> mzero: three ways? :)
09:29:44 <mzero> mconcat [ Nothing, Just 3, Nothing, Just 8 ]
09:29:53 <mzero> > mconcat [ Nothing, Just 3, Nothing, Just 8 ]
09:29:54 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:29:55 <lambdabot>    (GHC.Num.Num a0)
09:29:55 <lambdabot>      a...
09:30:09 <donri> Num isn't a monoid itself
09:30:11 <parcs`> HugoDaniel: simon marlow is like the only person who deeply understands ghc's rts and codegen, so less development will be done on those aspects of ghc. other than that it should be business as usual
09:30:13 <mzero> just two I think - at least not counting the trivial and useless   "all things are Nothing"
09:30:20 <beaky> > ['\0'..\127] >>= show
09:30:23 <donri> > Just "hello" <> Just "world" <> Nothing
09:30:23 <lambdabot>   Not in scope: `..\'
09:30:25 <lambdabot>   Just "helloworld"
09:30:30 <beaky> > ['\0'..'\127'] >>= show
09:30:32 <lambdabot>   "'\\NUL''\\SOH''\\STX''\\ETX''\\EOT''\\ENQ''\\ACK''\\a''\\b''\\t''\\n''\\v'...
09:30:38 <`nand`> mzero: depends on whether or not you allow extra constraints
09:30:52 <mzero> ah - yes, if x is a Monoid, THEN there is another way to make Maybe x a Monoid
09:30:57 <HugoDaniel> parcs`: :(
09:31:13 <donri> yea
09:31:15 <HugoDaniel> facebook is paying well i guess
09:31:44 <kqr> > Just "hello" <> Nothing <> Just "world"
09:31:45 <lambdabot>   Just "helloworld"
09:31:48 <kqr> now that was cool
09:32:24 <donri> of course with that monoid there are at least two identity elements
09:32:30 <donri> Nothing and Just mempty
09:32:38 <rwbarton> only one is actually an identity of course
09:32:39 <beaky> > mconcat ["Foo", "Bar"]
09:32:41 <lambdabot>   "FooBar"
09:32:49 <beaky> monoids are awesome
09:32:58 <donri> only one is what mempty is defined as, at least
09:32:59 <rwbarton> Just mempty is an "almost identity"
09:33:01 <beaky> I can define DNA bases to be a monoid
09:33:22 <donri> rwbarton: is it in any way not quite identity?
09:33:33 <rwbarton> a monoid can only have one identity (since if e and e' are identities then e = e . e' = e')
09:33:38 <rwbarton> > Nothing <> Just ""
09:33:40 <lambdabot>   Just ""
09:33:48 <donri> ah, good point
09:33:58 <rwbarton> but for multiplying by any other element, it is an identity
09:34:15 <donri> are there other monoids where this is the case?
09:34:50 <donri> beaky: what is the identity for dna bases?
09:34:55 * donri not a biologist
09:35:23 <donri> but i suspect you might be after semigroups
09:35:44 <rwbarton> beaky: monoid for DNA *sequences* surely
09:35:51 <rwbarton> which is just the standard list monoid instance
09:35:56 <_mpu> hehe, what about a magma...
09:37:27 <beaky> so there are amazing algorithms for monoids besides concatenation? :D
09:38:00 <atriq> > GT `mappend` EQ
09:38:02 <lambdabot>   GT
09:38:10 <atriq> One of the less interesting ones
09:38:25 <parcs`> > sortBy (comparing snd <> comparing fst) [(1,2), (2,1), (3,2), (5,5)]
09:38:27 <lambdabot>   [(2,1),(1,2),(3,2),(5,5)]
09:38:33 <mzero> beaky: it may sound dull - but turns out that all sorts of things in programming end up being Monoids
09:38:40 <mzero> with just mappend
09:39:03 <atriq> > appEndo (mconcat [Endo (+ 1), Endo (* 2), Endo id]) 7
09:39:05 <lambdabot>   15
09:39:05 <`nand`> @google monoid pearl
09:39:08 <mzero> consider, for example:  option flags -- you can consider the set of flags for a program to be a Monoid, and each flag is just the option set of one flag
09:39:08 <lambdabot> http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
09:39:08 <lambdabot> Title: ≡ ] , , [
09:39:15 <`nand`> curious title
09:39:16 <mzero> and the mappend operation puts them together
09:39:25 <hpaste> gertc pasted “hidden module workaround” at http://hpaste.org/78118
09:39:25 <parcs`> beaky: the 'Monoid Comparing' instance is a particularly neat monoid instance
09:39:27 <mzero> this is very common for all sorts of "settings" data types
09:39:46 <`nand`> Monoid a => Monoid ((->) a); right?
09:39:50 <`nand`> uh
09:39:52 <`nand`> that's not what I meant
09:39:56 <`nand`> Monoid (r -> a)
09:40:15 <`nand`> mempty = const mempty; mappend = liftM2 mappend ?
09:40:27 <`nand`> I guess any Monoid a, Applicative f => Monoid (f a)
09:40:41 <ulfdoz> namd
09:40:45 <beaky> where does the name monoid come from
09:40:55 <donri> category theory
09:41:08 <cmccann> I think that predates category theory...
09:41:12 <parcs`> abstract algebra
09:41:18 <beaky> category theory has a lot to say about programming :D
09:41:26 <donri> what does the name mean, though? single identity?
09:41:37 <`nand`> how many thousand years ago was the first monoid introduced?
09:41:58 <donri> monoid: world's oldest profession
09:42:00 <`nand`> donri: makes sense
09:42:05 <`nand`> I never thought about it
09:42:28 <rwbarton> I think it might be because it has a single operation
09:42:30 <rwbarton> not sure though
09:42:31 <beaky> what came first, the monad or the monoid?
09:42:41 <`nand`> as do ‘magma’, ‘group’, etc.
09:42:46 <atriq> Or do you mean the First monoid?
09:42:54 <rwbarton> monoid
09:42:55 <parcs`> donri: Monoid – From the Greek, mon(o) + oid. Fulfills only one of the axioms for a group (associative but no identity or inverses).
09:42:57 <`nand`> atriq: :)
09:43:20 <`nand`> no identity?
09:43:21 <xunatai> what's an endofunctor
09:43:22 <`nand`> huh?
09:43:34 <atriq> Wouldn't that be a semigroup?
09:43:35 <`nand`> xunatai: a functor from a category to itself
09:43:44 <`nand`> atriq: possibly the name has been mishandled since
09:43:45 <rwbarton> apparently monoid used to mean semigroup
09:43:50 <`nand`> I prefer donri's explanation ;)
09:44:01 <donri> let's rewrite history
09:44:06 <`nand`> TardisT
09:44:19 <`nand`> TardisT RealWorld RealWorld
09:44:29 <xunatai> so, a monad is a functor from the category of monoids to the category of monoids?
09:44:36 <rwbarton> no
09:44:42 <rwbarton> well
09:44:49 <rwbarton> it happens to give you one of those
09:46:35 <watermind> done it :)
09:46:47 <rwbarton> but that's not what it is
09:46:59 <`nand`> a monad is just a lax 2-functor from a terminal bicategory
09:47:36 * xunatai retracts back into his shell of ignorance and stupidity
09:47:54 <`nand`> please don't be intimidated, I have no idea what what I said means either
09:47:58 <`nand`> there are much simpler definitions
09:48:00 <watermind> Monads with Contexts unsing ConstrainKinds and Type Families :)
09:48:03 <watermind> is this a known trick?
09:48:12 <parcs`> yes :P
09:48:14 <Eduard_Munteanu> It is a monoid in the category of endofunctors.
09:48:23 <`nand`> even simpler
09:48:32 <hpaste> watermind pasted “Monad with Class Constrains” at http://hpaste.org/78119
09:48:33 <xunatai> i'm not intimidated, i've just accepted my own self-defeat
09:48:41 <watermind> ^ :)
09:49:19 <Eduard_Munteanu> For more such negative feelings, other customers have tried: ##categorytheory
09:49:28 <watermind> so that allows us to use Monads with class restrictions for return and bind
09:49:46 <`nand`> ‘A functor together with two natural transformations μ : 1 → F and η : F∘F → F satisfying ...’
09:50:07 <`nand`> I forgot how to write down the laws in category theory lingo
09:50:42 <watermind> :S well it's still a functor now? in some kind of sub-category...
09:50:43 <Eduard_Munteanu> They're commutative diagrams usually.
09:50:53 <watermind> s/now/no
09:51:05 <romildo> @pl \(n,t) x -> (n,(t,x))
09:51:06 <lambdabot> uncurry ((. (,)) . (.) . (,))
09:51:12 <beaky> lol
09:51:13 <parcs`> waterlaz: i wonder if the 'Ctx m a' constraints are necessary
09:51:19 <parcs`> watermind: ^
09:51:33 <parcs`> watermind: i feel like only the Ctx m b constraint is necessary
09:51:37 <beaky> @pl \x y -> x * x + y * y
09:51:37 <lambdabot> (. join (*)) . (+) . join (*)
09:51:42 <beaky> :t join
09:51:43 <watermind> parcs`: hmmm
09:51:44 <lambdabot> Monad m => m (m a) -> m a
09:52:09 <watermind> parcs`: in that instance yes
09:52:14 <`nand`> @hoogle ((a,b),c) -> (a,(b,c))
09:52:14 <FireFly> @src (->) join
09:52:14 <lambdabot> No results found
09:52:15 <lambdabot> Source not found. That's something I cannot allow to happen.
09:52:30 <`nand`> FireFly: join f x = f x x
09:52:34 <parcs`> watermind: what about in general, though
09:52:37 <watermind> parcs`: but you may need a constraint for return
09:52:41 <FireFly> `nand`: ah
09:52:53 <`nand`> what was that super elegant way to write ((a,b),c) -> (a,(b,c)) again?
09:53:06 <watermind> parcs`: to be honest I thought of having 2 different constrains, one for a and one for b
09:53:13 <watermind> parcs`: but seemed overkill
09:53:23 <watermind> parcs`: signature is complex enough
09:53:35 <beaky> does haskell have anything equivalent to python's random library?
09:53:39 <rwbarton> `nand`: \((a,b),c) -> (a,(b,c)) :P
09:53:40 <beaky> like randint
09:53:44 <`nand`> rwbarton: :)
09:53:54 <`nand`> I guess, uh, pointlessly
09:54:05 <`nand`> I seem to remember something, maybe involving lenses
09:54:40 <sclv> @pl \((a,b),c) -> (a,(b,c))
09:54:40 <lambdabot> uncurry (uncurry ((. (,)) . (.) . (,)))
09:54:56 <sclv> much more elegant
09:55:00 <xunatai> f ((a, b), c) = (a, (b, c))
09:55:14 <rwbarton> @type (fst . fst) &&& (snd . fst &&& snd)
09:55:16 <lambdabot> ((a, c), c') -> (a, (c, c'))
09:55:44 <`nand`> rwbarton: no, nicer than that
09:55:49 <rwbarton> yeah that is still bad
09:56:13 <rwbarton> well I'm sure it has a name in some category-extras package
09:56:41 <Eduard_Munteanu> Looks like the associator map for a monoidal category.
09:58:05 <watermind> parcs`: in any case I guess this is enough for a proof of concept, but yeah maybe having a CtxA and a CtxB is a good idea to avoid uneeded restrictions
09:59:52 <beaky> how do I define variadic functions
09:59:53 <beaky> in haskell
10:00:14 <atriq> beaky, if all the arguments are of the same type, use a list
10:00:20 <atriq> Otherwise, use Maybes?
10:00:22 <monochrom> id is variadic
10:00:24 <Eduard_Munteanu> beaky: see printf
10:00:45 <atriq> Or make it polymorphic, yeah
10:00:48 <simpson> beaky: Well, why do you want one?
10:00:50 <Eduard_Munteanu> > printf "%d, %d" 1 2
10:00:51 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:00:51 <lambdabot>    (GHC.Show.Show a0)
10:00:51 <lambdabot>     ...
10:00:54 <Canar> :t printf
10:00:56 <lambdabot> PrintfType r => String -> r
10:01:06 <beaky> :t printf
10:01:07 <lambdabot> PrintfType r => String -> r
10:01:10 <atriq> > printf "%d, %d" 1 2 :: String
10:01:12 <lambdabot>   can't find file: L.hs
10:01:17 <beaky> lol
10:01:18 <mcstar> @undef
10:01:21 <Eduard_Munteanu> > printf "%d, %d" 1 2 :: String
10:01:23 <lambdabot>   "1, 2"
10:01:48 <beaky> I want to write a lisp-like add function
10:01:57 <donri> :t sum
10:01:58 <lambdabot> Num a => [a] -> a
10:01:59 <kqr> yeah sum
10:02:00 <mcstar> > sum [1..10]
10:02:01 <lambdabot>   55
10:02:12 <beaky> so I can do things like (add x y) or (add x y z)
10:02:18 <geekosaur> haskell is not lisp
10:02:23 <kqr> sum [x, y] or sum [x, y, z]
10:02:32 <mcstar> next, you want optional and keyword arguments too
10:02:46 <donri> mcstar: records!
10:02:56 <kqr> i just realised i've never missed optional and keyword arguments i haskell
10:02:58 <kqr> i wonder why that is
10:03:14 <donri> maybe because you have records
10:03:15 <mcstar> granularity
10:03:18 <kqr> possibly
10:03:20 <flux> kqr, you've never had the need to modify an interface without breaking existing code?-)
10:03:24 <flux> (s/modify/extend/)
10:03:44 <flux> (which is really something one can have, because compiler is very helpful in pointing out the places needing updating)
10:03:49 <kqr> yeah
10:05:30 <gertc> is it possible to solve this with a newtype? http://hpaste.org/78118
10:06:42 <gulk> whats wrong here? assuming i want the loop to test if x1,y1,r1 intersects x2,y2,r2
10:06:43 <gulk> testaXY :: (Float, Float, Float) -> (Float, Float, Float) -> ((Float, Float), Float)
10:06:43 <gulk> testaXY (x1,y1,r1) (x2,y2,r2) = go (x1,y1,r1) (x2,y2,r2)
10:06:43 <gulk>   where
10:06:43 <gulk>     go (x1,y1,r1) (x2,y2,r2)  | testa (x1,y1,r1) (x2,y2,r2) == True = return ( ((x1,y1),r1) )
10:06:43 <gulk>     go (x1,y1,r1) (x2,y2,r2)           = go ((x1+0.2),(y1+0.2),r1) (x2,y2,r2)
10:07:21 <watermind> what is the identifier for the empty Constraint?
10:08:06 <gulk> testa is another function that do the math
10:08:26 <gertc> watermind: depends coudl be 0 or 1 or [] ...
10:08:47 <watermind> gertc: depends on... ?
10:09:24 <fmap> watermind: ()
10:09:55 <Chathurga> Hey would anyone be able to tell me what areas of maths I would need to have an understanding of if I wanted to have a serious go at category theory?
10:10:14 <monochrom> gulk: delete "return"
10:10:20 <watermind> fmap: hmm I tried that
10:10:37 <Eduard_Munteanu> Chathurga: I'd say a bit of abstract algebra helps, if only to understand certain examples.
10:10:47 <watermind> fmap: says () has kind *
10:11:04 <gulk> thank you monochrom
10:12:13 <Eduard_Munteanu> Chathurga: but if you read something like Awodey's book, it doesn't assume a lot of knowledge on your part..
10:12:20 <Chathurga> Eduard_Munteanu: I'll have a ponder on that, thanks. I was watching the intro to category theory and I think I need to brush up on my maths first!
10:12:35 <ocharles> oh ffs, now after spending another hour getting this to build with ghc, haddock can't parse it
10:13:11 <fmap> watermind: should work, what if you explicitly annotate (() :: Constraint) ?
10:13:37 <watermind> fmap: yeap tried that...
10:14:03 <fmap> :k (() :: Constraint)
10:14:07 <lambdabot>     Illegal kind signature for `()'
10:14:08 <lambdabot>       Perhaps you intended to use -XKindSignatures
10:14:12 <hpaste> watermind pasted “empty constraint error ” at http://hpaste.org/78120
10:14:23 <watermind> fmap: ^
10:15:35 <Chathurga> Eduard_Munteanu: That book looks perfect, thanks!
10:15:36 <rwbarton> watermind: I think currently you just have to define a "trivial" type class
10:16:06 <rwbarton> class Nothing a; instance Nothing a
10:16:09 <watermind> rwbarton: I see
10:16:32 <rwbarton> your line 22 is a kind error
10:16:37 <fmap> watermind: well, `Constraint' wouldn't work if you want `* -> Constraint'
10:16:43 <rwbarton> CtxA is supposed to have kind * -> Constraint, yeah
10:16:55 <watermind> ops good point
10:16:56 <rwbarton> try it with the real type? but I think edwardk said he ends up defining an empty class
10:17:01 <rwbarton> the real kind, I mean
10:17:25 <watermind> yes it still doesn't work
10:18:08 <watermind> I guess a trivial class does the trick... shame it makes contexts a bit more Ugly though
10:18:28 <edwardk> yeah i generally make a class named 'Trivial' for that.
10:18:49 <edwardk> if you put an issue on constraints to remind me. i'll add it to the next release, so folks can avoid duplicating the work
10:18:57 <rwbarton> was just looking there for it :)
10:19:42 <watermind> thanks edwardk!
10:19:56 <edwardk> sclv: the \((a,b),c) -> (a,(b,c)) thing is in http://hackage.haskell.org/packages/archive/categories/1.0.4/doc/html/Control-Category-Associative.html
10:20:32 <sclv> nice
10:22:31 <edwardk> sopvop: re: compare on some getter, compare `on` view l  will work, but there is nothing fancy
10:29:30 <hpaste> gertc annotated “hidden module workaround” with “does this do what i think its doing?” at http://hpaste.org/78118#a78122
10:32:54 <rwbarton> gertc: it doesn't do anything useful
10:33:35 <gertc> the only thing it has to do is derive Eq?
10:33:38 <rwbarton> didn't I already suggest a solution? allocate some unique identifier (e.g. an IORef or something from a Unique supply) each time you establish a websockets client
10:33:58 <rwbarton> gertc: Sink's Eq instance will be defined in terms of WS.Sink's
10:34:27 <rwbarton> so all the Sink wrapping on line 8 is useless
10:34:57 <en> wait. is it correct that ($) = id :: (a -> b) -> a -> b
10:35:09 <gertc> rwbarton: yes it will after it has been pulled but it is not getting pulled in the websocket source
10:36:35 <gertc> rwbarton: so i can't expect user to first modify the source of websockets before trying out the example?
10:37:32 <gertc> rwbarton: so i assume the wraping does ad the Eq for me but i am not sure it is teh same thing as the pull request?
10:39:41 <gertc> rwbarton: in short is this newtype Sink p = Sink{..} deriving (Eq) exactly the same effect as newtype Sinkwrap = Sinkwrap {getSink::WS.Sink WS.Hybi10} deriving Eq ?
10:48:47 <hatds> how does one give a flag -i<dirs>  to ghc if dirs contains spaces?   -i"C:\\test dir" and -i:"C:\\test dir" don't work
10:50:50 <monochrom> wait, at the command prompt level, you don't need that many backslashes. just "C:\test dir"
10:51:20 <hatds> that's true, but I tried variations since it wasn't working
10:51:22 <monochrom> because it's command.exe parsing it, not haskell syntax
10:51:28 <monochrom> ah
10:51:48 <rwbarton> edwardk (or other lens aficionados): do you know anything about the type (forall f. (Functor f) => (a -> f a) -> (b -> f b) -> (c -> f c))
10:51:58 <rwbarton> can I "eliminate the quantifier"?
10:52:19 <parcs`> are the two ints in 'data Foo = Foo Int# Int#' adjacent to each other in memory?
10:52:21 <edwardk> those are lens-like 'multiplates' or what have you
10:52:47 <edwardk> rwbarton: you can in some places, depends on where you are using it, of course. e.g. if thats a function signature ;)
10:52:55 <edwardk> if you want it to mean what a Lens means, then you can't
10:53:10 <rwbarton> well for Lens I have an isomorphism from the type to a type with no quantifiers
10:53:12 <edwardk> e.g. type Barton f a b c = forall f. Functor f => (a -> f a) -> ...
10:53:21 <hatds> ghci tells me:   Some flags have not been recognized: dir"   so it doesn't see the quote as being syntax for a quoted path
10:53:43 <rwbarton> (forall f. Functor f => (a -> f a) -> (b -> f b)) =~ (b -> a, b -> a -> b)
10:54:06 <edwardk> sure.
10:54:10 <edwardk> oh you want to do the same here
10:54:14 <rwbarton> can I do something similar for that type, yeah
10:54:16 <Cale> hatds: That really depends more on how your shell does quoting, I'd expect...
10:54:19 <rwbarton> (c -> Either a b?, ...???)
10:54:27 <edwardk> (c -> Either a b, c -> Either a b -> c)
10:54:42 <edwardk> you can only use one of the functions, since you are given no way to fuse f's
10:54:46 <rwbarton> so just a lens of a Either a b
10:54:48 <rwbarton> right
10:54:49 <edwardk> yep
10:55:30 <Eidel> How can I check which datatype a variable is?
10:55:33 <edwardk> the lens laws on that are enough to keep you from 'twisting' the either wrong, etc.
10:55:35 <hatds> Cale: but what about using the  ":set" command in ghci, there shouldn't be quoting from the shell interefering
10:56:00 <Cale> hatds: hmm
10:56:19 <atriq> :t fmap ?f "hello" --Eidel
10:56:20 <lambdabot> (?f::Char -> b) => [b]
10:56:24 <atriq> Well
10:56:30 <atriq> lambdabot lets you
10:56:33 <Cale> ghc -iStarCraft\ II World.hs -- worked on my commandline at least
10:56:39 <atriq> I'm not sure how, though
10:56:53 <rwbarton> Cale: yeah but you probably don't have a path C:\test dir
10:57:01 <rwbarton> (or do you?)
10:57:04 <Cale> I don'
10:57:05 <monochrom> you... put haskell code in your starcraft directory?! :)
10:57:07 <Cale> I don't
10:57:13 <Cale> (to both)
10:57:21 <monochrom> haha
10:57:23 <Cale> I'm just testing giving -i some directory with a space in it
10:57:45 <rwbarton> right but you are probably using some sh derivative rather than an unknown windows-y shell
10:58:02 <Cale> ghc "-iStarCraft II" World.hs -- also worked
10:58:03 <Eidel> atriq: Maybe I formulated the question wrong... Say I have Color = Blue | Red and i want do take a Color as argument in a function and want do to one thing if the color is Blue and another if the color is Red
10:58:14 <Cale> yeah, I don't know how the windows shell works
10:58:27 <Cale> But maybe the ideas are helpful
10:58:42 <rwbarton> Eidel: pattern matching (either with 'case' or in the syntax of a function definition)
10:58:44 <atriq> Eidel, oooh
10:58:44 <hiptobecubic> Cale, T, P, or Z?
10:58:48 <hatds> :set -iC:\test dir  (inside ghci)  invariably is giving me the error that it didn't recognize the flag called dir or dir"  (depending on if I tried to quote it)
10:58:49 <Cale> :set "-iStarCraft II"
10:58:57 <atriq> "foo Blue = ...; foo Red = ..."
10:59:21 <Eidel> atriq: thanks! Gonna try it :)
10:59:43 <hatds> Cale: bingo!   :set "-iC:\\test dir"
10:59:47 <hatds> :)
11:00:30 <Cale> hiptobecubic: I've mostly played Protoss in the past, though I'm conceptually more interested by Zerg (and have watched a lot of it). Haven't played in a long while though.
11:00:48 <hiptobecubic> Why does everyone play protoss :(
11:01:01 <Cale> It's easy to start with, I feel.
11:01:07 <hiptobecubic> perhaps
11:01:10 <atriq> I don't even play Starcraft
11:01:22 <hiptobecubic> atriq, that's really the best solution.
11:02:13 <hiptobecubic> life is better spent trying to figure out how multiplate your isomorphic lens laws
11:02:18 <hiptobecubic> how to*
11:02:25 <edwardk> well, yes
11:02:34 <rwbarton> lenscraft
11:02:38 <illissius> hello
11:02:41 <parcs`> rwbarton: taken :(
11:02:58 <parcs`> wait, no, that's lenscrafters
11:03:01 <hiptobecubic> :D
11:03:03 <edwardk> great, now i'm an optometrist.
11:03:18 <hiptobecubic> decent pay, little work. sounds ok
11:03:26 <Cale> hiptobecubic: It's basically fun to mass stalkers, lol.
11:03:33 <illissius> anyone know if GHC head is safe for building/tinkering (basically want to check on a bug), or if I'll get eaten by the static vs. dynamic libraries thing?
11:04:20 <Cale> I wasn't really competent enough for strategy to actually matter for me, so I thought I might as well do something simple and versatile while working on mechanics.
11:04:26 <hiptobecubic> "Your eyes are broke, sir. That'll be $300. Would you like to buy some plastic circles with $2 worth of glass in them for another $300?"
11:04:38 <parcs`> illissius: works for me
11:05:30 <hiptobecubic> Cale, i haven't played II at all actually. But i liked terran in the original, as complicated as it was to orchestrate anything.
11:05:39 <monochrom> aw, please don't mock prices by referring to raw material prices
11:05:41 <illissius> parcs`: I'll give it a try then, thanks
11:05:53 <hayashi> god damn it, now even #haskell is reminding me that i play too little sc2
11:06:13 <illissius> (there were some worrying noises on the GHC list, but maybe that's just about cabal...)
11:06:18 <hiptobecubic> monochrom, ok let's throw in another 20 dollars for the guy in the back room to push the 'grind' button
11:06:37 <monochrom> all your sophisticated CPU, RAM, SSD... could be called "$0.05 worth of sand"
11:06:47 <roadfish> Does Haskell have zero-argument functions? In Python, I can do "def x(): return a" ... and x() will track "a" as it changes. In ghci, "let b x = a" tracks "a" but "let b = a" becomes fixed on initial of "a". But I guess in stateless languages, "tracking a" doesn't even make sense.
11:07:05 <hpaste> romildo pasted “GHCi fatal error” at http://hpaste.org/78123
11:07:10 <Cale> roadfish: You can make functions which take an empty tuple as their argument
11:07:20 <Iceland_jack> roadfish: nullary/constant functions?
11:07:27 <romildo> When experimenting with the module LLVM.Core, I have got a fatal error with GHCi: http://hpaste.org/78123
11:07:29 <romildo> Any clues?
11:07:36 <Cale> roadfish: There's no such thing as a nullary function though -- that doesn't really make sense
11:08:02 <Cale> A function is something which assigns to each element of some domain exactly one element of some codomain.
11:08:18 <parcs`> roadfish: 'a' is immutable. it has no value other than its initial value
11:08:25 <gecko900> ciao
11:08:37 <rwbarton> ooh
11:08:39 <hiptobecubic> monochrom, if research in 13th century optics were costing us billions a year, then I'd support the pricing a little more
11:08:40 <roadfish> ok, so a "function with zero arguments" is just another way of saying "constant"
11:08:41 <rwbarton> mauke: are you ready
11:08:48 <roadfish> ... in Haskell that is
11:08:51 <gecko900> :list
11:09:06 <rwbarton> or was it monochrom's bot
11:09:07 <Cale> roadfish: If you're weird enough to actually say "function with zero arguments" in the first place.
11:09:15 <Cale> roadfish: I wouldn't say that's a function.
11:09:21 <sipa> i still think variable is a bad name here... it's just a shorthand name for an expression
11:09:21 <mcstar> oh guys help me, i forgot, whats the conversion function between types of Floating?
11:09:22 <mauke> rwbarton: hmm?
11:09:28 <rwbarton> who has the !list bot
11:09:29 <parcs`> mcstar: realToFrac
11:09:33 <mcstar> thanks
11:09:34 <monochrom> my bot answers !list, but not :list
11:09:38 <rwbarton> ah, sorry mauke
11:09:56 <Cale> A function is a function *because* it has a parameter. If it doesn't, then it's a value of some other type.
11:10:03 <Iceland_jack> Cale: Within Computer Science, the terms nullary and 0-ry functions are used
11:10:30 <Cale> Well, it's not something we tend to say in terms of Haskell.
11:10:31 <sipa> i guess the point is that haskell follows the mathematical meaning of function
11:10:45 <Cale> Another way you could put it is that a function is a value of type A -> B for some types A and B
11:11:00 <sipa> it's not a name for a subroutine to calculate something
11:11:09 <Iceland_jack> That's right, it follows from the more common and less mathematical meaning of function in CS
11:11:22 <sipa> it's a value that represents a mapping from one type to another
11:11:37 <Cale> If you start including 0-ary functions, then everything is a function and the word is indistinguishable from "value"
11:11:47 <Cale> which would be silly
11:11:56 <gecko900> :list
11:11:58 <monochrom> in haskell, the only arities are 0 and 1. it's a boolean now. here it makes sense to distinguish, not unify
11:12:01 <sipa> oooh, so Bool is a nullary type function? :p
11:12:08 <Iceland_jack> Cale: What about functions with side-effects?
11:12:15 <roadfish> ok, so whenever I use ghci to testing things, my state mindset from Python is isappropriately transferred to Haskell
11:12:17 <Cale> Those aren't functions
11:12:23 <spaceships> routines
11:12:26 <Iceland_jack> They are functions
11:12:27 <Cale> I might call them procedures
11:12:43 <monochrom> getLine is a 0-ary function
11:12:54 <Cale> Or "actions", if I'm being particularly Haskelly
11:13:11 <sipa> what makes getLine a function?
11:13:31 <monochrom> anyway, since the only arities are 0 and 1, may as well call the 0 case "not function", it doesn't hurt. it also helps type-checking to draw the line.
11:13:33 <watermind> monochrom: isn't it just a value of type IO a denoting an action?
11:13:44 <monochrom> yes, that's why 0-ary
11:13:47 <Cale> watermind: Yes, IO String, specifically
11:14:02 <Cale> I would say getLine isn't a function at all
11:14:05 <monochrom> type is X->Y ==> 1-ary.  type is not X->Y ==> 0-ary
11:14:08 <roadfish> I guess getLine is just the next piece of a super-huge constant called "stdin"
11:14:12 <Cale> and calling it one is just confusing and pointless
11:14:23 <watermind> Cale: pointless ah
11:14:44 <Iceland_jack> In Haskell it would be pointless yes
11:14:55 <gecko900> ciao
11:15:03 <gecko900> !list
11:15:03 <monochrom> gecko900: http://okmij.org/ftp
11:15:14 <Cale> It's similarly confusing and pointless in the context of all other languages, but we can't really fix everyone else's terminology
11:15:18 <roadfish> is "getLine" considered one of these "impure" operations?
11:15:32 <watermind> not really
11:15:34 <roadfish> ... I was going to say function but caught myself
11:15:58 <Iceland_jack> Certain terminology has been established, even though it doesn't perfectly coincide with mathematical definitions
11:16:03 <Cale> getLine is a value which describes the action of getting a line of text from the user
11:16:03 <Iceland_jack> Such is life
11:16:11 <Cale> It has no parameters, and as such is not a function.
11:16:27 <monochrom> screw mathematical definitions. is 0 a natural number or not?
11:16:33 <Cale> Yes.
11:16:43 <Iceland_jack> On #haskell it is
11:16:52 <atriq> It is if you beliiiiiieeeeeeve
11:16:53 <Iceland_jack> Outside of #haskell it depends whom you ask
11:16:59 <atriq> Do you believe, monochrom?
11:17:01 <atriq> Do you?
11:17:04 <Iceland_jack> Like those filthy number theorists
11:17:06 <watermind> I learned to distinguish between N and N_0 but we didn't have a name for N_0 :S
11:17:16 <monochrom> you can easily find two math books disagreeing on this. try: a real analysis textbook, and a set theory textbook
11:17:56 <monochrom> so, even if you speak of coinciding with math definitions --- which math?
11:18:13 <roadfish> I believe, different texts sometimes define natural numbers to include 0 and sometimes not. I've heard of "whole numbers" defined as {0,1,2,...}.
11:18:14 <Cale> N *usually* has 0 in mathematics, apart from some particularly old-fashioned real-analysis folks, and number theorists who primarily want to talk about multiplicative properties.
11:18:15 <Iceland_jack> “That math that is convenient.”
11:18:37 <Cale> For the most part, the conventions I've seen lately are that N has 0, and Z+ doesn't.
11:19:07 <monochrom> that is not the end of math disagreement. 0^0 is my next example
11:19:10 <roadfish> so Z+ = {1,2,3,...}?
11:19:22 <roadfish> is Z- = {-1,-2,-3,....}?
11:19:28 <Cale> 0^0 = 1 for anyone who's bothered to think about it for any amount of time at all
11:19:42 <Iceland_jack> Cale: I know a lot of people that would not agree :)
11:19:49 <atriq> It's the empty product
11:19:52 <monochrom> ah, yes, but not all mathematicians bother to think about it
11:19:55 <Cale> Iceland_jack: They've not put much thought into it then
11:19:56 <Iceland_jack> heh
11:19:56 <atriq> If you work backwards, 0^1 = 0
11:20:09 <atriq> 0^1/0 = 0^0 = 0/0 = whatever
11:20:12 <Iceland_jack> gcd 0 0 is undefined, except when it is defined
11:20:15 <roadfish> 0^0 is 1 in the Church encoding ... which should be Haskell dogma
11:20:24 <Cale> atriq: what the fuck are you doing? :)
11:20:35 <Cale> 0^1 / 0 doesn't make sense to begin with
11:20:38 <atriq> Cale, destroying the universe
11:20:42 <atriq> Don't mind me
11:20:43 <monochrom> haha
11:20:49 <Iceland_jack> atriq: are you one of those wheel theorists?
11:20:55 <Cale> why do you say that it's equal to 0^0 anyway?
11:21:02 <rwbarton> 0^1 = 0^2 / 0^1 = 0 / 0 = whatever so let's undefine 0^1 too
11:21:17 <atriq> n^m * n = n^(n+m)
11:21:44 <monochrom> anyway, "think about it for some time" is right
11:21:48 <rwbarton> @type non
11:21:48 <atriq> rwbarton, wow
11:21:49 <Cale> Unless n = 1, that seems pretty unlikely
11:21:50 <lambdabot>     Not in scope: `non'
11:21:50 <lambdabot>     Perhaps you meant one of these:
11:21:50 <lambdabot>       `not' (imported from Data.Bool),
11:21:56 <atriq> I really need to think about everything
11:22:01 <atriq> Forever
11:22:06 <Polarina> Is there a function like { :: Maybe b -> a -> Either a b }?
11:22:29 <monochrom> there is a reason in haskell we don't talk about 0-ary functions, and there is a reason in some logic courses we do
11:22:30 <Cale> atriq: n^m * n = n^(m+1)
11:22:40 <atriq> Ah, yes
11:22:50 <hiptobecubic> @djinn  Maybe b -> a -> Either a b
11:22:50 <lambdabot> f a b =
11:22:51 <lambdabot>     case a of
11:22:51 <lambdabot>     Nothing -> Left b
11:22:51 <lambdabot>     Just c -> Right c
11:22:59 <notdan> Hi! I have a piece of code in SML which uses mutable hashtables (maps) quite a lot (for a sort of memoization), how would you go by implementing that in Haskell?
11:23:00 <hiptobecubic> Polarina, ^ there's one
11:23:00 <watermind> Cale: real analysis isn't my strong... but your reasoning with products seemed to be based on  ^ : R -> N -> R  and not ^ : R_0^+ -> R -> R
11:23:16 <notdan> I guess I am wondering, is there a particularly good pattern?
11:23:25 <Cale> watermind: I actually didn't say anything much about products...
11:23:40 <monochrom> haha great, what have I done :)
11:23:42 <Polarina> hiptobecubic, I know I can make one, just wanted to know if one exists in a library somewhere, because hoogle turned up nothing. :)
11:23:42 <atriq> notdan, Data.HashMap.[lazy/strict]
11:23:55 <watermind> Cale: oh true it was atriq, so what is your reasoning?
11:24:03 <notdan> atriq: yeah, but what about the mutable part?
11:24:13 <monochrom> anyway, I think the person who asked for list is happy now? :)
11:24:29 <Cale> watermind: For 0^0 = 1? That if you leave it undefined, you constantly find yourself needing to separate off the first term of power series
11:24:47 <Cale> For example, you'll no longer be able to write  exp(x) = sum over k >= 0 of x^k/k!
11:24:53 <Cale> because that will break at x = 0
11:25:08 <watermind> Cale: right
11:25:10 <roadfish> 0^0 -> (/fx.x)(/fx.x) -> /x.x -> /fx.x = 1  QED
11:25:14 <watermind> Cale: good point
11:25:33 <atriq> notdan, you rarely need as much mutability as you think you do
11:25:49 <atriq> But either the State monad or ST
11:26:06 <rwbarton> watermind: < watermind> ... based on  ^ : R -> N -> R  and not ^ : R_0^+ -> R -> R
11:26:06 <Chathurga> Is there anyway to make a function automatically memoize in haskell? I've wondered why there isn't since it seems like a good fit
11:26:08 <Cale> and also, for natural numbers n and m, you have that n^m is the number of functions from a set of size m to a set of size n. There's exactly one function from the empty set to itself which is required to be there in order for sets to be a category -- the identity function on the empty set.
11:26:11 <rwbarton> watermind: yes, exactly right
11:26:14 <Chathurga> Is there a specific reason why?
11:26:24 <rwbarton> the former is much more important. the latter actually has a separate name in haskell
11:26:26 <Cale> So 0^0 = 1 is sensible combinatorially as well
11:26:27 <rwbarton> @type (**)
11:26:29 <lambdabot> Floating a => a -> a -> a
11:26:47 <notdan> atriq: well, the problem is I have this inductive function, and in order to calculate the result for C a b I need to calculate the result for a, the result for b + I have a modified table. It is possible to make it just return a tuple (hashtable,result), but this might look ugly
11:26:53 <Cale> It doesn't make anything more convenient to leave it undefined
11:26:56 <notdan> and I was wondering if there is a better abstraction for this case
11:27:10 <Cale> and it gets in the way and makes things awkward if you don't define it
11:27:44 <watermind> rwbarton: I know we're typing ^ but I *think* :) they're talking about real exponentiation
11:29:27 <notdan> atriq: I am not sure I can use ST in that case, since I want to share state between the current function call and the recursive call
11:29:40 <Cale> Now, for exponentiation with a real exponent, you might be content just to define a^b = exp(b log a), but if you don't throw in all the points which that definition misses, you'll be notationally hindering yourself in various ways (like with that power series I mentioned)
11:33:10 <gertc> for mapreduce like queries on a Data.Map do i just use the build in functions or do i need lens stuff or maybe this http://hackage.haskell.org/package/reducers-3.0.0.1 ?
11:33:13 <Cale> (and of course, if you're talking about the complex numbers, then the situation is even more complicated still, as you have infinitely many reasonable definitions of the logarithm, so you have to be quite careful about what's intended there)
11:33:50 <edwardk> gertc: you can use the built in functions, or lenses or reducers to accomplish this task ;)
11:33:53 <edwardk> pick
11:35:43 <gertc> ok the reduce stuff is like wtf? so i was hoping i would not need to figure that out :)
11:35:48 <edwardk> :t foldMap
11:35:49 <lambdabot>     Not in scope: `foldMap'
11:35:50 <lambdabot>     Perhaps you meant one of these:
11:35:50 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
11:35:53 <edwardk> :t Data.Foldable.foldMap
11:35:55 <lambdabot> (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
11:36:00 <Okasu> hello
11:36:07 <roadfish> !list
11:36:08 <monochrom> roadfish: http://hpaste.org
11:36:30 <edwardk> cale: would it be possible to add Data.Foldable.foldMap/fold to lambdabot ? i think i asked before and you mentioned the module list was long, but it comes up an awful lot.
11:36:43 <Cale> okay
11:37:18 <Cale> errr
11:37:21 <Cale> :t foldMap
11:37:23 <lambdabot>     Not in scope: `foldMap'
11:37:23 <lambdabot>     Perhaps you meant one of these:
11:37:23 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
11:37:26 <Cale> hmm
11:37:29 <edwardk> o.O
11:37:31 <Cale> oh, right, it's imported qualified
11:37:36 <edwardk> ah
11:37:53 <Cale> @undefine
11:37:55 <Cale> :t foldMap
11:37:57 <lambdabot> (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
11:37:57 <rwbarton> the "Perhaps you meant" errors are so helpful nowadays
11:38:00 * edwardk hugs Cale.
11:38:05 <Okasu> how can i lift io in arrow expression? runX . xshow $ doc >>> css "title" -- erroneos, doc is in the IO, i can just use 'do' with "doc' <- doc" but i what oneliner
11:38:08 <Cale> @undefine
11:38:10 <Cale> :t foldMap
11:38:11 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:38:12 <rwbarton> :t non
11:38:14 <lambdabot>     Not in scope: `non'
11:38:14 <lambdabot>     Perhaps you meant one of these:
11:38:14 <lambdabot>       `not' (imported from Data.Bool),
11:38:24 <edwardk> rwbarton: lambdabot is a little behind on lens ;)
11:38:38 <Okasu> want*
11:38:41 <edwardk> i'm holding off putting in an upgrade request until we finish up 3.6
11:39:15 <edwardk> i want the new upon stuff to work better first
11:41:24 <gertc> any learn you a mapreduce on the internet?
11:42:33 <Okasu> runX . xshow $ doc >>> css "title" {- wrong -}    do doc' <- doc; runX . xshow $ doc' >>> css "title" -- fine, but is it possible to do it in oneliner?
11:42:39 <Okasu> a bit clearer :)
11:43:00 <Okasu> in oneliner without 'do'*
11:43:33 <sipa> do is just syntactic sugar, so yes
11:43:39 <mauke> @undo do doc' <- doc; runX . xshow $ doc' >>> css "title"
11:43:39 <lambdabot> doc >>= \ doc' -> runX . xshow $ doc' >>> css "title"
11:43:44 <mauke> @. pl undo do doc' <- doc; runX . xshow $ doc' >>> css "title"
11:43:44 <lambdabot> runX . xshow . (>>> css "title") =<< doc
11:44:22 <Okasu> mauke: great, thanks
11:44:22 * hackagebot dawg 0.7.0 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.7.0 (JakubWaszczuk)
11:44:42 <Iceland_jack> “dawg”
11:45:57 <monochrom> hehe
11:45:58 <Iceland_jack> Also when is the Emacs haskell-mode going to allow splitting on arguments like Agda :)
11:46:15 <Iceland_jack> (so I heard you liked directed acyclic...)
11:46:29 <monochrom> yeah!
11:47:00 <Iceland_jack> also allowing something like ? as a placeholder for undefined
11:47:14 <Iceland_jack> I feel spoiled
11:48:20 <monochrom> I think GHC may acquire placeholder soon
11:48:23 <johnw> Iceland_jack: that's coming in GHC 7.8
11:48:27 <johnw> they call it a "hole"
11:48:34 <Iceland_jack> johnw: really?
11:48:37 <Iceland_jack> That's fantastic then
11:48:38 <johnw> yes
11:48:51 <monochrom> soon, you will say, "I can't tell your code from a hole" :)
11:48:52 <johnw> and I would love to port over some of the agda-mode code for handling holes
11:49:01 <Iceland_jack> johnw: absolutely
11:49:18 <Iceland_jack> also never say “handling holes” again
11:49:20 <Iceland_jack> :)
11:53:08 <johnw> :)
11:57:17 <elliott> edwardk: the new field looks nicer, but it's still worrying in one respect... doesn't the fact that "upon tail" catches tail's exception and turns it into a value mean you can violate semantics like you can with the spoon package?
11:58:06 <edwardk> elliott: i'm torn between the two possibilities
11:58:26 <edwardk> one is to 'let it crash' when handed upon tail. the other is to let it gracefully degrade to an accessor
11:58:42 <edwardk> the latter seems less bug prone
11:59:02 <johnw> Cale: does lambdabot build with 7.6 yet?
11:59:15 <elliott> edwardk: right, the current behaviour might be nicer... but isn't it unsafe?
11:59:24 <edwardk> upon tail .~ "foo" $ []  -- then just leaves the target unmodified rather than crashing. you asked for a traversal, it seems to be the most sound
11:59:33 <Cale> johnw: I don't know that anyone's been working on that
11:59:41 <Cale> (I certainly haven't)
12:00:06 <edwardk> define unsafe in this setting. the fact that it catches exceptions?
12:00:39 <elliott> it seems like you could construct a snippet that uses upon to distinguish two _|_s in pure code
12:00:42 <edwardk> it doesn't actually use tail to do the reading, it just runs your function, and looks at the exception it gets back before proceeding with it again
12:01:03 <elliott> hmm
12:01:47 <edwardk> once i know the exception i go and use that value. i don't use your function's result. upon' may give you fits because its more trusting, but upon is pretty crafty
12:02:32 <elliott> right, it seems to avoid all the problems I can think of
12:02:44 <edwardk> sure you can use it to do something you can't traditionally do with pure code. i mean after all it runs a function _backwards_ =P
12:09:01 <johnw> next up: the Tardis lens
12:09:31 <edwardk> johnw: turns out vertical composition is pretty much impossible. with it you could implement 'join' on an Applicative.
12:10:02 <johnw> would you need to move Bazaar to Monad to support it?
12:10:18 <edwardk> more than Bazaar.
12:13:04 <edwardk> basically the result would be a forall f. (Applicative f, Monad f) => (a -> f b) -> s -> f t  -- pseudo-Traversal, but then you can't read from it, because Const isn't a valid Monad, almost nothing works on it
12:13:27 <johnw> ok, i guess close out that bug then ;(
12:13:43 <edwardk> sadly
12:13:43 <edwardk> i'll post the findings on the issue and close it wontfix
12:13:49 <johnw> ok
12:13:53 <johnw> thanks for looking!
12:14:05 <edwardk> it would have been a really nice API to be able to offer
12:14:18 <johnw> at least in Haskell we often have a hard _reason_ not to hack something in just because the behavior sounds like something we'd want
12:14:47 <johnw> "I can't do it because the lax monoidal functor doesn't have access to μ" is a very compelling argument :)
12:15:04 <edwardk> ahahaha
12:19:42 <shergill> lol
12:20:49 <xunatai> > cycle "ah"
12:20:51 <lambdabot>   "ahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
12:23:41 <beaky> cycle "lol"
12:23:48 <beaky> oops
12:23:56 <beaky> > cycle "lo"
12:23:58 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
12:24:17 <kqr> haha
12:25:08 <jix> is there a class for types Foo f where when you have a function (f a -> g a) you can turn that into  Foo f -> Foo g?
12:25:52 <sipa> can you give an example where such a thing would be useful?
12:26:43 <edwardk> in my quest to eradicate partial lenses i'm thinking about dumbing 'element' down to a Traversal. any objections?
12:27:44 <johnw> haven't used it yet enough to know if I do, but I trust ya
12:28:21 <jix> data Foo v = Foo { foos :: v [Foo], bars :: v [Bar] }; data Bar v = Bar { baz :: v String } .... v is usually a TVar ... but now I want to serialize a snapshot so I want to turn TVar into Identity and eh that would have to be in the STM monad so I doubt I can use anything already existing
12:28:32 <Eidel> I want my data type to only take natural numbers. Eg. data Length = Meter Natural | Feet Natural. Is this possible?
12:28:35 <edwardk> the same arguments that made _head, _tail, etc. into traversals apply i guess
12:30:23 <edwardk> it also lets me make the ElementOf implementation a lot less evil.
12:32:18 <burbul> My collaborator just asked me whether there was a standard name for this class:
12:32:29 <burbul> class WithDefault f where
12:32:29 <burbul>    default :: f
12:32:36 <johnw> Data.Default
12:32:38 <edwardk> data-default 'Default'
12:32:43 <edwardk> the method is 'def'
12:32:43 <burbul> He also said, 'WithDefault might be called 'pointed' (as in pointed category) and might be built in to Haskell under some standard name but I couldn't find it.'
12:32:45 <Eidel> :r
12:32:46 <burbul> thanks!
12:33:24 <edwardk> we have Pointed, but we apply it to functors instead of objects: see Data.Pointed in pointed.
12:35:41 <Cale> Eidel: it's possible if you defined a Natural type, but there isn't one in the Prelude
12:40:12 <xunatai> > read $ concat $ map (show . length) $ words "we guarantee certainly clearly referring to this light mnemonic" :: Int
12:40:14 <lambdabot>   299792458
12:40:58 <xunatai> oops
12:41:39 <sipa> > read $ concat $ map (show . length) $ words "now i even i would celebrate in rhythms unapt the great immortal syracusan rivaled nevermore who in his wondrous lore passed on before gave men his guidance how to circles mensurate" :: Int
12:41:41 <lambdabot>   6245918019252202479
12:42:16 <sipa> > map (show . length) $ words "now i even i would celebrate in rhythms unapt the great immortal syracusan rivaled nevermore who in his wondrous lore passed on before gave men his guidance how to circles mensurate" :: Int
12:42:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:42:18 <lambdabot>              with actual type ...
12:42:25 <sipa> > map (show . length) $ words "now i even i would celebrate in rhythms unapt the great immortal syracusan rivaled nevermore who in his wondrous lore passed on before gave men his guidance how to circles mensurate"
12:42:27 <lambdabot>   ["3","1","4","1","5","9","2","7","5","3","5","8","9","7","9","3","2","3","8...
12:43:14 <sipa> > concat $ map (show . length) $ words "now i even i would celebrate in rhythms unapt the great immortal syracusan rivaled nevermore who in his wondrous lore passed on before gave men his guidance how to circles mensurate"
12:43:16 <lambdabot>   "3141592753589793238462643383279"
12:43:56 <sipa> > map (show . length) $ words "now i even i would celebrate in rhymes unapt the great immortal syracusan rivaled nevermore who in his wondrous lore passed on before gave men his guidance how to circles mensurate" :: Integer
12:43:58 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
12:43:58 <lambdabot>              with a...
12:44:05 <sipa> > read $ map (show . length) $ words "now i even i would celebrate in rhymes unapt the great immortal syracusan rivaled nevermore who in his wondrous lore passed on before gave men his guidance how to circles mensurate" :: Integer
12:44:07 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:44:07 <lambdabot>              with actual type...
12:56:43 <johnw> your pi is wrong
12:56:55 <johnw> it should be 926535, not 927535 in the beginning
12:57:15 <sipa> johnw: that's why i switched from "rhythms" to "rhymes" :)
12:57:19 <johnw> ah
12:57:27 <sipa> i remembered the digits, but not the poem, it seems
12:57:44 <johnw> i remember memorizing those digits in high school
12:57:56 <sipa> i think i still know around 50
12:58:04 <johnw> i only remember those 30
12:58:16 <johnw> at the time, i knew 100 well
12:58:24 <sipa> r-e-s-t-e-c-p
12:58:33 <xunatai> i used to know 100, but it's degraded down to 33: 3.14159265358979323846264338327950
12:58:57 <sipa> 288419716939937510 after that, i think
12:59:16 <xunatai> that looks familiar :P
12:59:22 <johnw> i found it interesting that there seemed to be "patterns" in the number
12:59:25 <Peaker> Data.Text.IO.getLine seems to wait for a lot more than a single line, blocking. How do I wait for just a single line?
12:59:28 <johnw> like, "trills" are common; and 8 is always an odd-ball
12:59:43 <xunatai> no 0 in the first 32 digits
12:59:48 <Rotaerk> nerds !
12:59:51 <Peaker> Something that's equivalent to a non-blocking read that doesn't wait after there're some bytes ready?
12:59:56 <sipa> depends where you start counting; the 32nd is a 0
12:59:59 <sipa> so is the 50th
13:00:11 <lispy> http://www.smbc-comics.com/index.php?db=comics&id=1777
13:00:15 <xunatai> start at 3, duh
13:00:21 <lispy> Totally relevant to remembering digits of i
13:00:22 <sipa> xunatai: ok then!
13:00:22 <lispy> pi*
13:00:51 <xunatai> digits of i...
13:00:54 <xunatai> hm
13:03:37 <mcstar> yay! my line of sight algorithm is working
13:03:56 <johnw> it only works when you can observe it?
13:04:05 <mcstar> no
13:04:20 <johnw> that's how my LoS spells are in WoW... :)
13:04:21 <mcstar> (then, how do you know it works, when you dont observe it?)
13:16:06 <xunatai> what's a good thing to program in haskell that would flex a lot of things in haskell?
13:16:23 <johnw> writing a compiler
13:16:50 <johnw> or a web browser
13:17:14 * cmccann has always been a fan of simple games as a way to exercise a lot of aspects of programming
13:17:41 <johnw> yeah, so code Diablo
13:17:41 <xunatai> i'll go the simple game route, seeing as i already started a simple game in haskell the other day
13:18:11 <crdueck> what is the best way to update multiple fields of a data structure using Control.Lens?
13:18:22 <johnw> chain .~
13:18:28 <monochrom> I recommend against flexing a lot of things. information overload
13:18:36 <johnw> field1 .~ blah $ field2 .~ blah $ field3 .~ blah $ record
13:18:36 <xunatai> true
13:18:57 <johnw> is equiv. to record { field1 = blah, field2 = blah, etc.
13:19:16 <edwardk> record & field1 .~ blah & field2 .~ blah & … even looks kinda like the latter
13:19:45 <johnw> yeah, true
13:20:37 <monochrom> simple game to exercise unsafeInterleaveIO: http://hpaste.org/77457
13:20:42 <Peaker> Under the hood (of GHC 7.6+), strict "getLine" should translate to a non-blocking read of some large chunk that eventually gets whatever amount of bytes from the OS, and if enough for a line, yields that immediately, right? Or does it wait for some whole chunk and may wait far longer than the line itself?
13:20:59 <johnw> getLine should get lines
13:21:07 <Crockeo> xunatai, cmccann: I'm actually doing that to learn to think more functionally.
13:21:09 <johnw> aka, line-buffered I/O
13:22:12 <Peaker> johnw, I'm using System.Process to create a process with stdout/stderr being pipes, and Data.Text.IO.getLine seems to wait until the entire process is over, and not until first line is written. Even when that process writes its unlines without any buffering
13:22:16 <monochrom> hrm, "strict" getLine? I never heard of "non-strict" getLine
13:22:25 <xunatai> haskell makes me excited, until i try to think about the big-picture of a functional program, then i get confused and scared
13:22:33 <johnw> non-strict getLine smokes pot while waiting for the next line
13:22:50 <xunatai> hehe
13:22:51 <johnw> xunatai: then for now, think of the small pieces and how to compose them
13:22:55 <Peaker> monochrom, Lazy I/O could be hiding anywhere :)
13:23:10 <monochrom> conventional getLine isn't lazy to begin with
13:23:14 <Peaker> ah, ok
13:23:49 <xunatai> i like the idea that haskell sort of forces things to be very modular in order to be reasonably implemented in haskell
13:24:41 <monochrom> (getLine >> putStrLn "thank you") does not output "thank you" immediately
13:25:00 <johnw> i found an online course which I think several people in here who are not yet mathematically inclined would enjoy
13:25:01 <johnw> https://class.coursera.org/maththink-2012-001/lecture/index
13:25:09 <johnw> it's called "Introduction to Mathematical Thinking"
13:25:34 <johnw> i like the presenters affect
13:27:45 <xunatai> i'm mathematically inclined, but my further education/advancement in mathematics is stagnating, out of some kind of apathy or something
13:27:51 <cl1> johnw: is coursera free?
13:27:56 <johnw> yes
13:28:28 <cl1> i think that heterogeneous parallel programming class looks interesting too
13:29:01 <johnw> i'm sort of learning math "anew", since I was never so inclined before; so I've been scouring the web for ways of changing my thinking about it
13:29:19 <johnw> and it's helping
13:29:20 <xunatai> i'm trying to figure out how to renew my interest in it
13:29:30 <johnw> xunatai: Haskell is why I'm interested now
13:29:36 <monochrom> coursera is free. but I still don't feel like creating yet another account to just see a summary
13:30:21 <johnw> monochrom: the lectures are: Logical Combinators; Implication; Equivalence; Quantifiers; Proofs, Number Theory; Real Analysis
13:31:01 <johnw> and they're all downloadable as MP4, so I have them on my iPad now :)
13:31:30 <Peaker> ok, I see my problem. If I use "waitForProcess" while trying to read its stdout -- it stalls the stdout until the process is done
13:31:38 <jix> Monad m => (forall a b. (a -> m b) -> f a -> m (g b)) -> (forall a. IO a -> m (v a)) -> x f u -> m (x g v) -- I don't think I ever wrote such a complex type signature before (not counting agda code)
13:32:12 <Peaker> Oh, this is in the doc for waitForProcess: "GHC Note: in order to call waitForProcess without blocking all the other threads in the system, you must compile the program with -threaded."
13:32:16 <Peaker> I'd appreciate a warning there :)
13:32:47 <Peaker> Why does GHC_OPTIONS pragma not allow -threaded?
13:32:54 <jix> but it allows me to use the same code to a) snapshot a data structure using TVars into something pure (which I can serialize then) b) restore it back from the pure data structure
13:33:46 <Peaker> Nice -- I wrote a little utility to timestamp the stdout/stderr lines of other utilities :)
13:34:18 <rwbarton> because it is not a per-module option
13:34:49 <rwbarton> though arguably it could work in your Main module somehow
13:35:25 <Peaker> a per-module flag could just carry over to link time maybe?
13:35:41 <Peaker> (WARNING: Using -threaded because module X.Y.Z requires it)
13:35:55 <rwbarton> sounds pretty creepy if a library I use can turn on -threaded
13:36:40 <shachaf> A warning would be good, though.
13:37:17 <rwbarton> yeah
13:37:22 <johnw> Peaker: isn't it OPTIONS_GHC?
13:37:59 <shachaf> johnw: Oh, well in *that* case.
13:38:47 <cl1> um, why wouldn't threading be in there all the time? why do you need to enable it?
13:38:48 <Peaker> oh, whoops :)
13:39:00 <lispy> warnings are not so great. We can't use -Werror and it's hard to see all the warnings sometimes (like with cabal install)
13:39:02 <Peaker> cl1, the threaded runtime has some extra overhead to make sure all the operations are safe
13:39:11 <startling> cl1, -threaded just uses the threaded runtime.
13:39:15 <lispy> (we can't use -Werror because each version of ghc changes warnings)
13:39:40 <cl1> is threading that big of an overhead?
13:39:56 <lispy> I've never noticed it
13:40:32 <cl1> seems like uneeded complexity to have to diferentiate between the two
13:40:41 <lispy> But, I guess I've never tried it with my high performance Haskell code
13:41:21 <johnw> cl1: sometimes I think -threaded / +RTS -N -RTS should be the default, and you have to choose to turn it off
13:42:44 <cl1> i don't know what the -N switch does, but i would agree that at a minimum -threaded should be the default. but better yet, not even be a choice
13:42:56 <cl1> sometimes having choices is not the best solution
13:43:06 <johnw> cl1: having -threaded without -N is a might bit useless
13:43:10 <c_wraith> the non-threaded runtime is better at some things.  like debugging.
13:43:18 <lispy> for something as sophisticated as a compiler, choices are nice
13:43:23 <johnw> +RTS -N sets the number of available capabilities = the number of cores on your machine
13:43:38 <thoughtpolice> there are also some actual semantic differences that can expose themselves between -threaded and non threaded IIRC, but i can't recall details
13:43:43 <Peaker> given that it is really easy for correct programs to go wrong without -threaded, it should really be the default
13:44:06 <johnw> i use -threaded in pretty much all of my packages, because I like concurrency
13:44:17 <johnw> on an 8 core machine, concurrency is pretty much like free speed
13:44:23 <cl1> concurrency is teh awesum
13:45:13 <weox> http://pastebin.com/DFeyf8QK , what is my problem ??  why i dont have doc file of libs !!
13:45:17 <mauke> The paste DFeyf8QK has been copied to http://hpaste.org/78126
13:45:41 <rwbarton> you don't need to use doubled question marks or exclamation points
13:45:42 <johnw> you didn't build with "documentation: true" in your ~/.cabal/config
13:45:42 <rwbarton> one is enough
13:45:49 <johnw> and guess what, there's no way to fix that without rebuilding the world
13:46:09 <johnw> welcome to cabal's mystifying defaults
13:46:19 <johnw> enabling profiling while you're at it too, and then come back and thank us alter
13:46:38 <weox> johnw : thank you :D
13:47:31 <shergill> yeah i ran into that when i first wanted to start profiling my stuff. talk about annoying
13:47:50 <lispy> using cabal-dev makes this less annoying
13:48:19 <lispy> It's easy/cheap to blow away the local cabal-dev directory. Turn on those cabal options, and rebuild your deps
13:48:44 <thoughtpolice> i really wish hsenv was fixed already for cabal 1.16
13:48:51 <shergill> using virthualenv/hsenv made it easier too. but still annoying
13:49:11 <shergill> thoughtpolice: ditto
13:49:59 <lispy> Sounds like the solution is to submit a patch to cabal changing the defaults
13:50:12 <lispy> will forcing haddocks to build cause build failures?
13:50:20 <weox> johnw : i change the setting to what i want , is there anyway to auto rebuild everything installed , or just should i uninstall and then re install it ??
13:50:22 <lispy> That might be the reason for having it off
13:51:02 <lispy> weox: You would need to rebuild everything listed here: ghc-pkg list --user
13:51:30 <lispy> weox: and as far as I know, you have to request each package to rebuild by hand (you could make a script I suppose)
13:51:33 <thoughtpolice> lispy: i believe the library is registered with ghc-pkg before haddock is run, but i might be wrong
13:51:47 <thoughtpolice> either way, if it doesn't, that's a bug too IMO
13:52:15 <dsantiago> Beginner question: Is there some polymorphic version (or Haskell equivalent) of functions like filter and map? I wrote a little program that uses ByteString and Set, and seemingly most function calls, like words, filter, and map, require me to disambiguate them with Set.map, for example.
13:53:15 <bgamari> colah, ping
13:53:18 <lispy> dsantiago: We just disambiguate like you did (the way you do imports can make that easier). You could look at ListLike.
13:53:28 <lispy> ?hoogle ListLike
13:53:28 <lambdabot> package ListLike
13:53:28 <lambdabot> package listlike-instances
13:53:37 <johnw> weox: try this: cabal install world --reinstall --force-reinstalls
13:53:39 <thoughtpolice> Set is also a little bit of a special case, due to the Ord constraint.
13:53:43 <watermind> dsantiago: for map, you have fmap
13:54:20 <weox> johnw : seems worked , thanks
13:54:29 <thoughtpolice> you can get around this and write a version of Functor using ConstraintKids and associated types, so that you can have 'fmap (+1) $ Set.fromList [1,2,3]', but i don't think anyone has made any library out of it
13:54:29 * hackagebot timestamp-subprocess-lines 0.1.0.0 - Run a command and timestamp its stdout/stderr lines  http://hackage.haskell.org/package/timestamp-subprocess-lines-0.1.0.0 (EyalLotem)
13:54:43 <dsantiago> Hm, OK. I thought there'd be something like typeclasses that these data structures have, like the way I saw in Learn You a Haskell about how you can implement map for tree-like structures or lists.
13:54:44 <thoughtpolice> there are already a couple of prelude alternatives, maybe one of them did something different
13:55:01 <johnw> dsantiago: it's called Functor
13:55:09 <dsantiago> Right.
13:55:58 <johnw> dsantiago: however, thinking of Functor as just "a way of mapping over structures" is selling the Functor concept short by a mile, although it's a decent start
13:56:02 <thoughtpolice> dsantiago: you can do something like this, it's just a bit more involved if you're a newbie. the trick is that a type like Set has the 'Ord' constraint, because internally sets are ordered trees. so now you need a version of 'map' or filter that can work over something like [a], with no constraint, and Set a, with the constraint Ord a
13:56:03 <geekosaur> the problem is that it's difficult to have restricted Functors (Set and Map require the keys be Ord)
13:56:14 <thoughtpolice> so you need a bit of type-level machinery to support that
13:56:26 <thoughtpolice> and it may be intimidating, but it can be done :)
13:56:49 <thoughtpolice> (actually it's maybe not that intimidating, you probably just haven't seen the features)
13:57:25 <dsantiago> Hm, yeah. That's interesting, and beyond me right now.
13:57:29 <thoughtpolice> dsantiago: so you need some function like 'map :: ??? => (a -> b) -> ...', where the ??? constraint needs to be derived from the type
13:57:38 <thoughtpolice> GHC has only recently supported this too
13:57:43 <thoughtpolice> and it's a little hacky in 7.4.x, at that
13:57:57 <dsantiago> Perhaps my problem come from stepping into Sets.
13:58:03 <watermind> thoughtpolice: I was just playing around with that :)
13:58:25 <thoughtpolice> dsantiago: it's a well known problem, so it's entirely possible you want to do something reasonable. the same problem appears for example, when you want to make Set an instance of Monad
13:58:53 <watermind> or even Functor
13:58:57 <thoughtpolice> right
13:58:59 <dsantiago> I'm a clojure guy, so it was natural to reach for a set for this.
13:59:03 <thoughtpolice> since fmap/bind/return all have to mention Ord a now
13:59:08 <thoughtpolice> for that instance to make sense
14:04:30 * hackagebot bytestring-nums 0.3.6 - Parse numeric literals from ByteStrings.  http://hackage.haskell.org/package/bytestring-nums-0.3.6 (JasonDusek)
14:06:49 <dsantiago> Here's my little program, if you guys have any other tips I'd appreciate it. https://gist.github.com/4137077
14:07:16 <shachaf> dsantiago: I bet hpaste would give you a couple of tips if you pasted on hpaste.org. :-)
14:07:43 <dsantiago> Ah, yeah, OK.
14:07:55 <shachaf> hpaste just runs hlint on your code
14:08:25 <dsantiago> Is that gonna spam the channel with it when I hit Submit?
14:08:34 <johnw> no
14:08:58 <Ralith> otherwise we wouldn't recommend it
14:09:03 <johnw> dsantiago: recommendation #1: add more type signatures
14:09:17 <johnw> Emacs can add them for you automatically, if you have it setup correctly
14:09:31 * hackagebot timestamp-subprocess-lines 0.1.0.1 - Run a command and timestamp its stdout/stderr lines  http://hackage.haskell.org/package/timestamp-subprocess-lines-0.1.0.1 (EyalLotem)
14:09:37 <Ralith> I still haven't found out how to get that set up correctly.
14:09:46 <johnw> Ralith: what, ghc-mod?
14:09:48 <Ralith> everyone obliquely mentions that it can be done, nobody knows how to do it
14:09:49 <Ralith> yes
14:09:57 <johnw> the function is `ghc-insert-template'
14:10:11 <johnw> do that on flymake-highlighted lines, and it will insert whatever the related suggestion is (in most cases)
14:10:20 <Ralith> oh nice
14:10:20 <johnw> for "function missing type signature", it inserts the type signature
14:10:36 <Ralith> very nice
14:10:40 <Ralith> Just Works ^^
14:10:43 <johnw> it worked?
14:10:45 <johnw> cool!
14:11:01 * Ralith supposes he needs to read the docs more carefully
14:13:14 <johnw> is there any idiom like this already for record fields: overField field f x = x { field = f (field x) }
14:13:52 <shachaf> johnw: Yes, lenses.
14:14:01 <shachaf> Except you fmap
14:14:01 <johnw> i meant, pre-lens
14:14:13 <shachaf> I think people usually just wrote setField
14:14:32 <Peaker> Our project had its own TH to generate func lifters for each record field
14:14:33 <dsantiago> ghc-insert-template didn't do anything for me.
14:15:24 <Peaker> (Recently I converted all of its uses to use lens instead)
14:17:04 <ParahSail1in> in Data.HashSet, it seems that it's telling me that I should say Data.Set instead and that Data.HashSet is deprecated?
14:17:28 <shachaf> ParahSail1in: Read more carefully.
14:19:30 <ParahSail1in> Deprecated: "HashSet is deprecated. Please use Set instead."
14:20:05 <shachaf> http://hackage.haskell.org/packages/archive/hashmap/latest/doc/html/Data-HashSet.html
14:20:10 <shachaf> Maybe the message could be improved.
14:20:23 <bgamari> colah, In GetLoops, I think you'll be much better off using, say, Data.Sequence instead of []
14:20:39 <bgamari> colah, You traverse the entire list every time you need last
14:21:06 <mcstar> shachaf: how long did you sleep?
14:21:13 <geekosaur> that particular message could do with a little disambiguation, I think
14:21:31 <shachaf> Yep.
14:21:34 <shachaf> mcstar: Who knows?
14:22:17 <mcstar> i remember, you said 'enough, i go to sleep' and now youre back, seems too soon
14:33:18 <yepyep> Is there any good way to test pattern matches while debugging in ghc, aside from stepping through line by line?
14:34:13 <yepyep> *ghci rather
14:39:03 <mreh> I don't get this in netwire
14:39:17 <mreh> for 3 . "hello" === "hello" . for 3
14:39:32 <deus_rex> @hoogle for
14:39:32 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
14:39:32 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
14:39:32 <lambdabot> Foreign module Foreign
14:39:33 <mreh> I thought "hello" was a pure wire
14:39:49 <mreh> deus_rex: it's in the netwire package
14:41:09 <deus_rex> ahhh...
14:41:32 <donri> instance (IsString b, Monad m) => IsString (Wire e m a b) where fromString = pure . fromString
14:41:33 <mreh> it inhibits after 3 seconds, but I don't quite get inhibition yet maybe
14:41:48 <mreh> indeed
14:41:57 <donri> mm_freak_ is the author in here btw
14:42:09 * donri innocent highlight
14:46:30 <dsantiago> I tried to cabal install ghc-mod, and it seemed successful, but there is no ~/.cabal/bin, as the instructions here suggest should happen: http://www.mew.org/~kazu/proj/ghc-mod/en/install.html  Bit confused about where things should go.
14:50:19 <fmap> hpaste cabal log
14:50:22 <fmap> @hpaste
14:50:22 <lambdabot> Haskell pastebin: http://hpaste.org/
14:51:16 <dsantiago> cabal log complains that log is an unrecognized command.
14:52:19 <fmap> dsantiago: mean `cabal install ghc-mod' log you've get while installing ghc-mod
14:52:24 <fmap> I*
14:52:52 <dsantiago> Ah, whoops, yes.
14:53:07 <dsantiago> Doh. Just rang someone's bell.
14:58:01 <hpaste> “ dsantiago” pasted “cabal log for install ghc-mod” at http://hpaste.org/78128
14:59:31 <rwbarton> Installing executable(s) in
14:59:32 <rwbarton> /Users/David/Library/Haskell/ghc-7.4.1/lib/ghc-mod-1.11.2/bin
15:00:44 <dsantiago> Oh, hm.
15:01:08 <rwbarton> ~/.cabal/bin/ is the unix-y path, on Macs it puts it somewhere else apparently
15:01:34 <dsantiago> Stupid Mac. Now I gotta add each directory individually to exec-path to make ghc-mod work.
15:01:45 <rwbarton> huh, weird, yeah
15:02:40 <aetcore> dsantiago: did you install it with brew or with the Haskell Package?
15:03:11 <dsantiago> Hm, good question. I have absolutely no idea. Whatever I did I did like months ago.
15:03:47 <dsantiago> Which is preferable?
15:04:07 <aetcore> Ok, the default installation with the Haskell Package, provided by Haskell, you shouldnt need to, but you can add ~/.cabel/bin/ to your enviroment and you should be ok
15:04:22 <aetcore> i came in late, but i have it installed on mac, if you need a hand
15:04:42 <aetcore> what was your problem that you were having? not being able to use cabel?
15:04:50 <aetcore> cabal**
15:05:57 <aetcore> kyle@Kyles-MacBook-Pro:s000 ~❯ whereis cabal
15:05:58 <aetcore> /usr/bin/cabal
15:06:17 <dsantiago> aetcore: I was trying to follow these instructions, http://www.mew.org/~kazu/proj/ghc-mod/en/install.html  but then the emacs mode can't find anything in ~/.cabal/bin
15:07:04 <dsantiago> It looks like I *did* install haskell platform via brew.
15:07:08 <aetcore> did you use sudo prior to installing or without, without should use the default directory
15:07:36 <rwbarton> in your ~/.cabal/config (haha it's probably somewhere else though!) I think you can configure where it will put executables
15:08:28 <aetcore> also if you cabal --help
15:08:47 <aetcore> it will print at the bottom where the config file is, it *should* say its in your home directory
15:09:05 <dsantiago> Yeah, that is in my home dir.
15:12:05 <cl1> if i'm accessing a list via the index operator (!!), are they zero based or one based?
15:12:24 <shachaf> Try it out!
15:12:25 <aetcore> dsantiago: try appending the ~/.cabal/bin path to your PATH and try re-opening emacs
15:12:44 <dsantiago> aetcore: The issue is, ~/.cabal/bin doesn't exist.
15:13:18 <cl1> shachaf: i forget about the interactive
15:13:18 <dsantiago> ~/.cabal/ just has config and config.platform
15:13:29 <aetcore> try installing something
15:13:34 <aetcore> via cabal
15:13:41 <aetcore> hang on let me look at your tut
15:13:47 <rwbarton> he did, it went to /Users/David/Library/Haskell/ghc-7.4.1/lib/ghc-mod-1.11.2/bin
15:14:21 <aetcore> oh i see
15:15:28 <aetcore> mine is like this too
15:15:39 <aetcore> everything is in the above dir
15:16:47 <ziarkaen> In GHCi, I type ":s +s" at the prompt, but receive error: "IO error:  "+s" does not exist".  What is wrong?
15:16:52 <aetcore> dsantiago: give me like 5 mins, im going to install this too and see how far i get
15:17:07 <dsantiago> thanks so much
15:18:12 <ziarkaen> Never mind, the ":s" option is interpreted as something else.  I should have used ":set"
15:24:42 <aetcore> its taking its sweet time :D
15:24:53 <dsantiago> Yeah, it takes a few minutes to do all the compiling.
15:26:15 <dsantiago> Actually, I think it might be putting things in /Users/David/Library/Haskell/bin
15:26:18 <dsantiago> Which solves the problem.
15:28:27 <hilhil> Can I take this...
15:28:28 <hilhil> data Worker x y = forall b. Buffer b => Worker {buffer :: b, input :: x, output :: y}
15:28:30 <dsantiago> Yay, it works now.
15:28:39 <hilhil> and abstract out 'Buffer' to get something like
15:28:52 <hilhil> data Worker x y ? = forall b. ? b => Worker {buffer :: b, input :: x, output :: y}
15:29:03 <rwbarton> with ConstraintKinds you can, new in GHC 7.4
15:29:04 <hilhil> where '?' is a var. ranging over classes,
15:29:07 <hilhil> THank you.
15:29:15 <rwbarton> just turn on ConstraintKinds and write 'c' instead of '?'
15:32:01 <ParahSail1in> @type newArray
15:32:02 <lambdabot> Not in scope: `newArray'
15:34:08 <hpaste> cl1 pasted “I can't get this to compile” at http://hpaste.org/78129
15:34:20 <cl1> why doesn't liftM String gen_name work?
15:34:47 <rwbarton> you tell us
15:34:51 <cl1> or better yet how do I get the string out of Gen Name
15:35:16 <shachaf> cl1: "I can't get this to compile" isn't very useful for getting help. :-)
15:35:20 <rwbarton> what is String
15:35:27 <shachaf> You should paste the error message, if there is one, as well as what you expect.
15:35:42 * osfameron guesses he expected it to compile ;-)
15:35:43 <cl1> it says Not in scope: data constructor 'String'
15:35:56 <deus_rex> is there a function :: Int -> [a] -> [[a]] which will return all sublists of a given length from a list?
15:36:01 <rwbarton> Name is already a String
15:36:11 <rwbarton> and it looks like the result of gen_name is a String too?
15:36:17 <osfameron> deus_rex: as in chunked?
15:36:24 <nicoo_> @hoogle Int -> [a] -> [[a]]
15:36:24 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:36:25 <lambdabot> Data.List drop :: Int -> [a] -> [a]
15:36:25 <lambdabot> Prelude take :: Int -> [a] -> [a]
15:36:46 <deus_rex> so chunk 3 "foobar" return ["foo", "oob", "oba", "bar"]
15:36:54 <byorgey> cl1: String is a type
15:36:55 <rwbarton> also you won't be able to write an Arbitrary instance for String
15:37:00 <byorgey> cl1: it cannot be used as an expression
15:37:28 <cl1> i replace liftM String gen_name i get Illegal instance declaration for 'Arbitrary.Name' and something about -XTypeSynonymInstances
15:37:45 <cl1> OMG i can't type
15:37:59 <cl1> *if i replace liftM String gen_name with gen_name
15:38:02 <shachaf> cl1: Not in expression context, no.
15:38:36 <cl1> I thought get_name returns Gen Name
15:38:54 <byorgey> cl1: that's because Name is a type synonym, and by default you cannot make type class instances for type synonyms.
15:39:08 <deus_rex> ah, seems there is a function in Data.List.Split which does this
15:39:17 <byorgey> cl1: you can enable it with the TypeSynonymInstances extension.
15:39:26 <rwbarton> cl1: "type Name = String" means Name and String are the same
15:39:34 <deus_rex> oh, no there isn't
15:40:09 <rwbarton> cl1: you can delete lines 5-9 and replace Name on line 15 by String and your program will mean exactly the same thing
15:40:53 <rwbarton> and then you can't define an instance Arbitrary String because there already is one
15:41:18 <byorgey> cl1: if you want some Arbitrary behavior specific to Names, then you have to define Name using a newtype
15:41:24 <rwbarton> (in addition, in standard Haskell you can't write an instance declaration for a type synonym, which is what ghc is currently complaining about)
15:41:58 <cl1> which makes sense
15:43:38 <osfameron> deus_rex: something like https://gist.github.com/4137727 ?
15:43:49 <aetcore> dsantiago is where i found the make path ./Library/Haskell/ghc-7.4.2/lib/ghc-mod-1.11.2/share
15:43:52 <cl1> but assuming that Arbitrary String didn't already exists, which would be correct liftM2 String gen_name or just gen_name?
15:43:54 <aetcore> lol oh awesome you fixed it
15:43:56 <aetcore> :)
15:44:02 <dsantiago> Why would one use liftM (* 3) [1, 2, 3] instead of map (* 3) [1, 2, 3] ?
15:44:08 <osfameron> deus_rex: (probably a terrible implementation)
15:44:39 <dsantiago> Yeah, thanks for your help aetcore
15:44:51 <aetcore> its ok :) i didnt do much
15:44:55 <aetcore> glad you got it sorted
15:45:01 <rwbarton> 'gen_name' is already fine, 'liftM2 String gen_name' makes no sense, even if you meant 'liftM String gen_name', unless you have defined String as a data constructor
15:45:02 <dsantiago> I reinstalled the Haskell platform, and the new version was making symlinks to that dir.
15:45:14 <dsantiago> Which, I had to blow away all the symlinks and rebuild to get them back.
15:45:33 <aetcore> ah i see, that sounds a little extreme
15:45:46 <cl1> rwbarton: thanks
15:45:47 <dsantiago> Yeah, well, I have no idea what I'm doing.
15:45:49 <rwbarton> cl1: if you defined 'newtype Name = X String', then you would need 'liftM X gen_name'
15:45:56 <cl1> and yes i meant liftM
15:46:19 <deus_rex> osfameron: i came up with this: https://gist.github.com/4137736
15:46:26 <deus_rex> kind of ugly though :<
15:46:58 <franco_> > /whois gwern
15:47:00 <lambdabot>   <hint>:1:1: parse error on input `/'
15:47:06 <rwbarton> @where sneaky
15:47:07 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
15:47:08 <cl1> rwbarton, thanks
15:47:34 <osfameron> deus_rex: it's not that ugly.  but having to do length each time seems inefficient
15:48:04 <rwbarton> > let dropFromEnd n xs = zipWith const xs (drop n xs) in let n = 3 in map (take n) . dropFromEnd n . tails $ "abcdefg"
15:48:06 <lambdabot>   ["abc","bcd","cde","def","efg"]
15:49:59 <osfameron> oh that's a nice side-effect of zip's semantics with const
15:50:08 <ohbewan> Is there an easier way to write this type declaration?  fAdd :: ([Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char].  Is there a typeclass that let me do something like this fAdd :: (StringTypeclass a) => (a -> a) -> (a -> a)...
15:50:50 <shachaf> ohbewan: That type class sounds terrible. What are you actually asking here?
15:50:58 <shachaf> Do you not like typing String 6 times?
15:51:09 <osfameron> rwbarton: cute
15:51:15 <shachaf> You can say fAdd :: (a ~ String) => (a -> a) -> (a -> a) -> a -> a
15:51:25 <aristid> ohbewan: type StringFn = String -> String
15:51:33 <aristid> then StringFn -> StringFn -> StringFn
15:51:51 <shachaf> What does fAdd do, anyway?
15:51:58 <shachaf> aristid: As it happens StringFn is already defined.
15:52:01 <shachaf> @src ShowS
15:52:02 <lambdabot> type ShowS = String -> String
15:52:04 <osfameron> rwbarton: that's probably a tad more efficient than deus_rex or my implementation?  there's the repeated take, but he had a length, and I had a ++
15:52:45 <bitonic> what’s the hot command line args parsing library now?
15:52:48 <ohbewan> Well it basically accepts functions that return strings and puts a plus sign between then.  Nothing too complicated, but I'm learning about type declarations right now.
15:52:51 <aristid> shachaf: ah yeah
15:52:53 <bitonic> is it still cmdargs?
15:52:57 <cl1> okay, so say i turn on that switch does Arbitrary Name hide Aribtrary String is is it polymorphic?
15:52:58 <ohbewan> The third string is used to evaluate the two functions
15:53:22 <aristid> ohbewan: did you understand my suggestion, or was it cryptic for you?
15:53:25 <shachaf> ohbewan: I think code would be shorter than English for describing what that function does. :-)
15:53:48 <rwbarton> the implementation may also be shorter than the type signature
15:53:54 <shachaf> Yep.
15:54:04 <shachaf> I thought before that the implementation might be (.)
15:54:12 <shachaf> But I guess it's more like liftA2 (++)
15:54:14 <ohbewan> aristid should I type that in GHCI?
15:54:29 <shachaf> ohbewan: Do you know what it means?
15:54:31 * cl1 wonders why this tutorial would suggest I try to create Arbitrary Name in the first place
15:55:23 <aristid> ohbewan: no
15:56:04 <ohbewan> Do I need to import a module to use ShowS and StringFn?
15:56:52 <cl1> this hitchhikers guide to haskell is quite frustrating
15:57:46 <aristid> ohbewan: no
15:58:00 <aristid> ohbewan: you can just add type StringFn = String -> String to your .hs file.
15:58:12 <aristid> ohbewan: and use it to simplify the type signature of fAdd.
15:58:44 <aristid> ohbewan: consider that fAdd has the type signature fAdd :: ([Char] -> [Char]) -> ([Char] -> [Char]) -> ([Char] -> [Char])
15:59:06 <rwbarton> cl1: "GHC Interactive, version 6.4.1, for Haskell 98"
15:59:08 <aristid> ohbewan: those [Char] -> [Char] in that type signature can be replaced by StringFn
15:59:23 <aristid> rwbarton: ghc 6.4?! seriously?
15:59:28 <rwbarton> so you may encounter some obsolete information
15:59:43 <rwbarton> haskell wiki has all kinds of ancient stuff
16:00:04 <shachaf> Oh, man, 6.4
16:00:10 <shachaf> That was before -threaded
16:00:25 <ohbewan> ohh Ok I see now, aristid.  I got it now.  That's cool you can simplify like that
16:00:43 <ohbewan> Thank you
16:00:47 <aristid> ohbewan: yes, it makes it a lot clearer i think
16:00:51 <cl1> rwbarton: guess I should move to a different tutorial then
16:01:12 <rwbarton> I think in this instance the tutorial is just lame rather than outdated
16:01:34 <thoughtpolice> shachaf: and STM
16:01:53 <cl1> rwbarton: different reason, same solution, lol
16:01:59 <rwbarton> true
16:02:31 <cl1> i'm going to give the Programming Haskell tutorial a try
16:02:41 <shachaf> Which one is that?
16:02:48 <shachaf> Hutton's book _Programming in Haskell_ is good.
16:03:00 <ciaranm> ENOTLYAH
16:03:01 <cl1> http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell
16:03:48 <rwbarton> "GHC Interactive, version 6.6, for Haskell 98." "much better"
16:05:21 <xunatai> cycle "makeitstop"
16:05:30 <xunatai> > cycle "makeitstop"
16:05:33 <lambdabot>   "makeitstopmakeitstopmakeitstopmakeitstopmakeitstopmakeitstopmakeitstopmake...
16:12:41 <|||tux||>  !add fort6
16:20:42 <Peaker> My compilations are so slow due to lens th and some binary derivations :(
16:20:49 <edwardk> doh
16:21:01 <Peaker> what good workarounds are there besides manually writing the boilerplate?
16:21:21 <shachaf> You could paste in the code -ddump-splices gives you, maybe.
16:21:25 <edwardk> we could provide function for generating the TH code fragments as text so you can splice them
16:21:31 <shachaf> Or that.
16:21:35 <edwardk> or you could just do that
16:22:29 <c_wraith> You could use the generic lenses and just derive Generic?
16:22:44 <shachaf> GHC doesn't optimize reverse [] to [] :-(
16:23:06 <Peaker> TH also requires ordered definitions... maybe some more restricted form of TH could be nicer..
16:23:10 <c_wraith> needs more partial evaluation
16:25:43 <Peaker> TH modules requires about 10 times more time to compile
16:26:22 <shachaf> GHC uses the bytecode evaluator to run TH
16:27:39 <Peaker> and preemptively loads way too many packages
16:27:59 <Peaker> (when I don't think any of my TH code actually depends on any of them)
16:31:42 <aristid> oh, MaybeT is in transformers and i didn't notice!
16:31:57 <shachaf> It is?
16:32:20 <shachaf> I didn't know that.
16:32:54 <aristid> shachaf: verify it for yourself
16:33:08 <shachaf> I did, between "It is?" and "I didn't know that.".
16:33:18 <aristid> :)
16:33:24 <aristid> you were quick, too
16:35:37 <franco_> @src map
16:35:37 <lambdabot> map _ []     = []
16:35:37 <lambdabot> map f (x:xs) = f x : map f xs
16:35:51 <franco_> @src foldl'
16:35:52 <lambdabot> foldl' f a []     = a
16:35:52 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:41:54 <Raynes> Using Aeson, is there a way to parse a small piece of json and pluck out a single string value without having to implement FromJSON on some new type? I could do that, but the type would be pointless in this situation.
16:43:21 <parcs`> Raynes: you want to extract a string literal
16:43:23 <parcs`> ?
16:44:00 <Raynes> I have json like "{\"contents\": \"some text\"}", and I'd just like that some text string.
16:44:27 <rwbarton> sure, you can decode to Value, use Data.HashMap.Strict.lookup, etc.
16:44:50 <franco_> @src concat
16:44:50 <lambdabot> concat = foldr (++) []
16:45:01 <rwbarton> or you can use one of the provided "JSON parsers" I suppose
16:45:26 <Raynes> Oh, cool.
16:45:37 <franco_> @type concat
16:45:38 <lambdabot> [[a]] -> [a]
16:45:39 <Raynes> I didn't realize I could decode to Value.
16:45:52 <Raynes> rwbarton: That's exactly what I wanted. You are a gentleman and a scholar. Thank you.
16:45:58 <rwbarton> no problem
16:53:22 <bgamari> colah, 500 LoC touched and yet everything still seems to work, https://github.com/bgamari/ImplicitCAD/commit/418defc912b818b4ae2da38c92c065d43f5ef17b
16:55:12 <xunatai> that's haskell for you
17:01:39 <bgamari> colah, The P applications provide a bit of noise
17:01:47 <nicoo_> bgamari: As long as it type-checks and your commit was sane-looking, it probably isn't broken in any obvious way :]
17:02:12 <bgamari> colah, but again, I think the ability to distinguish affine points from vectors is worth exploiting here
17:02:27 <bgamari> colah, It does require a break in API, however
17:02:48 <bgamari> colah, That being said, I think this is one thing that diagrams got very much right
17:03:20 <bgamari> nicoo_, sadly I still haven't seen a compiler that can catch a flipped sign ;)
17:03:39 <nicoo_> bgamari: Coq can :]
17:03:48 <bgamari> heh, fair enough
17:03:54 <nicoo_> (or any other proof assistant)
17:05:03 * nicoo_ spent 10+ hours head0butting against Coq before realizing the pen-and-paper proof was wrong (the headbutting was about getting it to make an induction the way I wanted)
17:06:44 <Ferdirand> hello #haskell, what would be the difference between StateT s (ErrorT e IO) and ErrorT e (StateT s IO) ?
17:07:04 <nicoo_> IO is sin-bin.
17:07:23 <Ferdirand> ok, replace IO by m then, my question still stands
17:08:14 <nicoo_> Ferdirand: It's just that I am way too tired to really think; thankfully, trolling doesn't involves the brain (outside the stem) that much
17:09:03 <Ferdirand> I can relate to that :)
17:10:30 * nicoo is beginning to recover from a 3-weeks-long rush.
17:12:43 <Ferdirand> so if I get this right, the former would be equivalent to s -> IO (Either e (a,s)), and the latter to s -> IO (s, Either e a)
17:14:12 <Ferdirand> my intuition tells me that if I want an error to cancel the possible state changes, I want the former ?
17:14:23 <rwbarton> yes
17:14:40 <rwbarton> @unmtl StateT s (ErrorT e IO) a
17:14:41 <lambdabot> s -> IO (Either e (a, s))
17:14:45 <rwbarton> @unmtl ErrorT e (StateT s IO) a
17:14:46 <lambdabot> s -> IO (Either e a, s)
17:15:08 <Ferdirand> that's quite a convenient command, thanks rwbarton !
17:16:45 <Ferdirand> i'm writing an interpreter for a stupid language, which for nows runs in a StateT s IO
17:17:10 <edwardk> >>> zipper ("hello","world") & fromWithin (upon fst. traverse) & focus .~ 'j' & farthest right & focus .~ 'y' & rezip
17:18:10 <Ferdirand> and instead of having to match stuff at many places, i'd like to be able to write partial matches in do-blocks and have a way to transform match failures into named errors, then in the eval loop replace them by something that dumps the machine state and stops
17:18:26 <Ferdirand> ErrorT vaguely seemed like the tool for that
17:18:30 <edwardk> (yes, _1 is better than upon fst)
17:19:00 <Ferdirand> @type (&)
17:19:01 <lambdabot> a -> (a -> b) -> b
17:19:45 <Ferdirand> @type (>>>)
17:19:47 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
17:20:04 <edwardk> (>>>) is to (.) what (&) is to ($)
17:20:36 <hilhil> Is there a standard naming convention for types like this?
17:20:51 <edwardk> hilhil: like which?
17:20:56 <edwardk> the flipped versions of things?
17:21:07 <hilhil> data SomeC = forall a. C a => SomeC a
17:21:18 <hilhil> [sorry, was copy/pasting]
17:21:21 <hilhil> types like that
17:21:27 <hilhil> types which sum up a class
17:21:42 <edwardk> oh
17:21:42 <edwardk> hilhil: not really
17:21:55 <shachaf> hilhil: Often the convention is not to name them. :-)
17:22:09 <shachaf> By which I mean that they're not a good solution as often as people think.
17:22:14 <shachaf> (Or I'm just a h8r.)
17:22:15 <hilhil> And can one abstract out a ::class -> type operator  O s.t.
17:22:17 <edwardk> i use SomeFoo, or AFoo, or AnAwesomeFoo, or Foo_ or Bar_ when i'm forced to have them but i try to avoid going out to existential land at all
17:22:24 <aristid> @src (&)
17:22:24 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:22:30 <hilhil> O C = forall a. C a => SomeC a
17:22:35 <edwardk> hilhil: you could make such an abstraction using constraint kinds
17:22:51 <hilhil> Yes, rwbarton mentioned those
17:22:52 <edwardk> data Some p = forall a. p a => Some a
17:22:54 <shachaf> data O c = forall a. c a => O a
17:22:59 <hilhil> anyway, thanks!
17:23:08 <edwardk> data A p = forall a. p a => Some a
17:23:09 <aristid> is (&) defined only in lambdabot, or does lens give us this left-to-right goodness?
17:23:17 <edwardk> than lets you talk about A Monoid
17:23:29 <edwardk> aristid: its in current versions of lens
17:23:39 <edwardk> it used to be (%) in lens, but the Data.Ratio squad complained
17:23:41 <shachaf> So is unsafeCoerce. :-(
17:23:53 <rwbarton> :t unsafeCoerce
17:23:54 <edwardk> shachaf: not user visibly =P
17:23:55 <lambdabot> Not in scope: `unsafeCoerce'
17:24:29 <shachaf> edwardk: If you import BazaarT!
17:24:45 <edwardk> in 3.5.1. if you'd finish uponTheDeep we could ship 3.6 ;)
17:25:10 <aristid> shachaf: you don't finish uponTheDeep? slacker!
17:25:35 <shachaf> I haven't even started on that yet.
17:25:43 <edwardk> he and mgsloan suggested the name, and i threw it out there that if they implemented it, i'd take the name =P
17:25:49 <aristid> ok hoogle does not know what BazaarT is
17:25:52 <shachaf> I'll go eat something and then maybe look into it.
17:25:56 <shachaf> aristid: BazaarT is a great evil.
17:26:00 <shachaf> Well, OK, it's a minor evil.
17:26:06 <shachaf> It's great in 3.5
17:26:08 <aristid> shachaf: i'd give you some of my salami but i've already eaten it all :/
17:26:23 * shachaf is vegetarian anyway.
17:27:53 <aristid> BazaarT does not seem to be exported in 3.5.1?
17:28:09 <aristid> or at least the module is not documented in the haddocks
17:28:11 <edwardk> aristid: in 3.5.1 it wasn't safe to export. in 3.6 we restructured so you can safely import it
17:28:28 <edwardk> with 3.5.1 you could write unsafeCoerce with access to the internals of it
17:28:41 <edwardk> with 3.6 you can just get an undefined ;)
17:29:24 <aristid> edwardk: uponTheDeep is unrelated to that, but is just a "blocker" for 3.6?
17:29:35 <edwardk> unrelated and currently just a blocker
17:29:37 <edwardk> yes
17:30:00 <edwardk> its a big enough addition that it'd be nice to get in to 3.6 while we're doing breaking API stuff
17:30:37 <aristid> what is uponTheDeep? (i say that aware of the risk i might not be able to understand the answer)
17:31:08 <edwardk> with 3.6 you can say over (upon fst) (+1) (1,2)    -- and get (2,2)
17:31:20 <edwardk> upon fst makes a traversal out of a field accessor
17:31:22 <aristid> :t over
17:31:23 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
17:31:40 <edwardk> over someLens   acts like 'fmap' over the target of the lens
17:31:48 <edwardk> > over _1 (+1) (1,2)
17:31:50 <lambdabot>   (2,2)
17:31:51 <aristid> edwardk: and fst is a lens itself or just regular old tuple fst?
17:31:56 <edwardk> just tuple lens
17:32:04 <edwardk> upon does black magic to figure out what it accesses
17:32:12 <edwardk> and gives you the lens to write back there
17:32:16 <aristid> so upon more or less makes a lens from a plain stupid function?
17:32:34 <edwardk> upon last +~ 2 $ [1,2,3,4,5]    gives you [1,2,3,4,7]
17:32:38 <edwardk> yep
17:32:42 <aristid> and i suppose uponTheDeep takes it even further
17:33:03 <aristid> this is evil.
17:33:22 <edwardk> but it only works if the function is one that gives you a member of the structure that would be visited by 'template', and only then if you never look at any of the other things template would return with that type
17:33:33 <parcs`> > upon last +` 2 $ [1..5]
17:33:35 <lambdabot>   <hint>:1:12: parse error on input ``'
17:33:37 <parcs`> > upon last +~ 2 $ [1..5]
17:33:38 <lambdabot>   Not in scope: `upon'
17:33:42 <edwardk> parcs`: its not in lambdabot yet
17:33:52 <parcs`> how would it work?
17:34:11 <edwardk> https://github.com/ekmett/lens/blob/master/src/Data/Data/Lens.hs#L172
17:34:11 <aristid> edwardk: and uponTheDeep fixes some of that limitation with the function needing to fit a specific template?
17:34:29 <edwardk> uponTheDeep would let you deal with descedants of your descendants.
17:34:33 <parcs`> ah
17:34:56 <edwardk> its like searching 'contexts' vs 'holes' in Plated terminology
17:35:33 <aristid> edwardk: i guess a nice use case for upon itself is record accessors that have not been lensified with TH
17:35:35 <edwardk> upon is a hack, its slow, its also cute, and easy to work with for third party code
17:35:58 <edwardk> yeah. if you just need to reach for a third party field accessor and haven't lensified it, you can easily upon it and move on
17:36:16 <edwardk> and then later on maybe you refactor to write a lens or makeLenses, etc.
17:36:52 <edwardk> anyways if mgsloan or shachaf write it it'll be uponTheDeep. if i write it it'll probably be 'thereupon' ;)
17:37:54 <aristid> shachaf: eat your veggies quick so edwardk doesn't beat you to it!
17:39:56 <aristid> edwardk: so i can see the usefulness of upon for things like record accessors, but something like "upon last" is just a bit scary to me, perhaps because it breaks the illusion of equational reasoning too violently
17:40:08 <donri> edwardk: what do s and t stand for?
17:40:11 <donri> s t a b
17:40:26 <Jafet> Soprano, tenor
17:40:33 <simpson> Ha.
17:40:41 <simpson> I figured that they were from STRQ coordinates.
17:41:35 <edwardk> upon last is pretty terrifying i admit. the intended purpose of upon is for field accessors
17:41:42 <donri> 'upon' sounds crazy magical
17:41:50 <edwardk> s is used because its a state parameter in many combinators.
17:42:16 <edwardk> upon is deep voodoo, but its actually pretty clean code-wise
17:42:46 <edwardk> upon :: (Data a, Typeable b) => (a -> b) -> Simple Traversal a b
17:43:02 <donri> ah Data magic
17:43:05 <edwardk> upon' :: (Data a, Typeable b) => (a -> b) -> Simple Lens a b
17:43:14 <dmwit> Is there a reason "lookahead" was removed from binary? The commit that removes it says nothing more than "merge CPS", and does about a million other things, too.
17:43:19 <edwardk> the latter gives you one that trusts you more
17:43:56 <edwardk> donri: basically i use template to rewrite the structure you give me to sprinkle it with exceptions, then run your action and see which one i get =P
17:44:05 <edwardk> donri: thats the field you are accessing ;)
17:44:31 <donri> cuh-razy alright
17:44:58 <edwardk> it won't look for 'b's within 'b's though, hence uponTheDeep
17:45:14 <edwardk> so upon tail works but not upon (tail.tail)
17:45:28 <edwardk> but uponTheDeep (tail.tail) would work
17:45:33 <edwardk> it'd just be slower
17:45:52 <donri> and FieldException is hidden so you can't confuse it, yea
17:46:01 <edwardk> yep
17:46:39 <dmwit> I would settle for a replacement for "lookAhead" instead of a justification of its removal... =P
17:46:49 <edwardk> dmwit: =)
17:47:08 <edwardk> donri: sclv is to thank for the core idea of this craziness
17:47:41 <donri> a bit like the kind of code i used to write in python
17:48:11 <donri> "works by intentional accident"
17:48:57 <edwardk> yeah
17:50:39 <donri> ah it's in data.data.lens, not anywhere in control.lens, that makes it less scary
17:50:42 <xunatai> i have no idea how my imperative code ever worked at all
17:51:10 <edwardk> yeah. there'll probably be a GHC.Generics.Lens version too eventually
17:59:35 <xunatai> it seems like my imperative algorithms are almost always only almost right
17:59:41 * hackagebot encoding 0.6.7.2 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.6.7.2 (DanielWagner)
18:01:33 <elliott> donri: well it was in Control.Lens before :P
18:01:46 <edwardk> moved for convenience and correctness ;)
18:02:26 <donri> yea i prefer such dark magic be more explicitly opt-in
18:04:22 <donri> are there anything with Data constraints in Control.Lens publicly?
18:05:43 <edwardk> class Plated a where plate :: Simple Traversal a a -- will default to uniplate if you don't specify the plate function
18:05:46 <edwardk> uniplate uses Data
18:05:51 <edwardk> default plate :: Data a => Simple Traversal a a
18:06:22 <edwardk> but we don't export anything explicitly with Data or Typeable in Control.Lens
18:06:32 <donri> ah you changed it to use default signatures?
18:06:49 <edwardk> it used to use 'ignored' as the default, but the uniplate default signature is more useful
18:07:05 <donri> yea we discussed that before
18:14:55 <deus_rex> is there a good guide to getting started with Parsec? the RWH chapter on it is confusing me
18:15:23 <aristid> deus_rex: there's also the old and somewhat outdated paper (it's mostly right but the module names have changed)
18:16:54 <aristid> i believe it was this one: http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec.pdf
18:19:04 <johnw> dues_rex: what do you want to parse?
18:19:16 <johnw> parsec is actually really easy to use
18:23:31 <hpaste> “sarienpalth@AT@hotmail.DOT.com” pasted “Using Step Value for Range Generation Where Step Equals First Value Results in Infinite Nonincrementing Range Generation” at http://hpaste.org/78131
18:24:52 <shachaf> Is sarienpalth in this channel?
18:26:35 <donri> edwardk: why are Control.Lens.{Classes,Combinators} plural? *ocd*
18:26:50 <Guest62964> commands
18:26:59 <shachaf> donri: Because they contain multiple classes/combinators?
18:27:00 <edwardk> because there Control.Lens.Type is for the type of Lens, and Control.Lens.Classes contains a bunch ;)
18:27:33 <Guest62964> NICK
18:29:05 <Guest62964> setname sarienpalth
18:29:11 <Guest62964> SETNAME
18:29:21 <edwardk> shachaf: making headway on uponTheDeep for you =P
18:29:32 <Guest62964> Whee. Way, way, way too long since I've used IRC.
18:29:46 <simpson> Guest62964: /nick <new nick>
18:29:46 <shachaf> Guest62964: Try /nick sarienpalth
18:29:58 <shachaf> edwardk: Oh, that.
18:30:16 <sarienpalth> Thank you. To answer your earlier question, shachaf, yes, I'm on the channel. :)
18:30:31 <edwardk> for a second there it sounded like you were really angry with some poor guy named Nick.
18:31:19 <shachaf> sarienpalth: To the second thing you said, b in [a,b..c] isn't a step, it's a second value.
18:31:22 <shachaf> So
18:31:26 <shachaf> > [2,4..20]
18:31:28 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
18:31:48 <shachaf> Actually that answers both of your questions, I guess.
18:32:26 <simpson> sarienpalth: The other thing is that Haskell *does* allow infinite lists.
18:32:37 <simpson> > [2..]
18:32:39 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
18:32:43 <sarienpalth> shachaf: Right. If I'm reading the site I'm learning out of, A is the "Stepping value" and B..C is the range you want to go through when generating a list, yes?
18:32:46 <nicoo> > [2,1..3]
18:32:48 <lambdabot>   []
18:33:28 <shachaf> sarienpalth: No, the stepping value is b-a
18:33:35 <shachaf> > [0,5..100]
18:33:37 <lambdabot>   [0,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
18:33:45 <shachaf> Um, not a good example.
18:33:49 <shachaf> > [5,10..100]
18:33:51 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100]
18:34:28 <edwardk> > [20,19..1]
18:34:30 <lambdabot>   [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
18:34:45 <edwardk> notice the delta there is the difference between the first two values
18:35:12 <sarienpalth> simpson: Oh, that doesn't bother me at all. I'm just learning and was confused by the fact that when I did [2,2..20] I got [2,2,2,2..]
18:35:12 <edwardk> it is chosen because it reads like it does when a mathematician writes { 1, 2, 3, 4 … 10 }
18:35:25 <edwardk> thats because 2 - 2 = 0, so its adding 0 each time
18:35:59 <shachaf> > [2,2..2]
18:36:02 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
18:36:03 <shachaf> Aw.
18:36:03 <edwardk> so you told it 'keep adding 0 to 2 until you get to 20'
18:36:08 <sarienpalth> Indeed! That explanation makes a lot more sense!
18:36:21 <edwardk> needless to say this will take it a while ;)
18:37:07 <edwardk> shachaf: that one is interesting. i'd have to see how that gets implemented. i don't understand what happened there
18:38:32 <shachaf> > [2,2..2] :: [Int]
18:38:34 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
18:39:13 <rwbarton> guess it does something like takeWhile (<= 2)
18:39:29 <shachaf> This looks like intended behavior.
18:39:59 <shachaf> > [(),()..()]
18:40:01 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
18:40:01 <shachaf> > [()..()]
18:40:03 <lambdabot>   [()]
18:40:24 <rwbarton> > [1,1..2] :: [Double]
18:40:26 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
18:40:36 <sarienpalth> Yikes!
18:41:11 <sarienpalth> That was really the one that concerned me the most, really. I figured the second case was just me doing something wrong or a quirk of my just learning.
18:41:32 <deus_rex> > [Just 1, Just 2, .. Just 20]
18:41:33 <lambdabot>   <hint>:1:18: parse error on input `..'
18:41:34 <sarienpalth> The a == b case, that is.
18:41:37 <deus_rex> > [Just 1, Just 2 .. Just 20]
18:41:39 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe a0))
18:41:39 <lambdabot>    arising from a use...
18:41:47 <shachaf> sarienpalth: This isn't the case you were looking at.
18:41:56 <deus_rex> > Just <$> [1..20]
18:41:57 <shachaf> sarienpalth: [2,2..20] being [2,2,2,2,2,...] makes sense.
18:41:57 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10,Jus...
18:42:30 <sarienpalth> shachaf: Alright. I'll be quiet, then, and going back to trying to learn. Thank you for the clarification, everyone!
19:00:20 <edwardk> woot. >>> uponTheDeep (fst.fst) .~ 10 $ ((1,1),2)
19:00:20 <edwardk> ((10,1),2)
19:01:11 <byorgey> uponTheDeep, haha
19:01:16 <hiptobecubic> how is that better than before?
19:02:00 <hiptobecubic> > ((1,1),2) .^ _1._1 .~ 10 -- no?
19:02:02 <lambdabot>   Not in scope: `.^'
19:02:02 <lambdabot>  Perhaps you meant one of these:
19:02:02 <lambdabot>    `.' (line 106), `P.....
19:02:07 <hiptobecubic> er
19:02:10 <edwardk> >>> uponTheDeep (tail.tail) .~ [10,20] $ [1,2,3,4,5]
19:02:11 <edwardk> [1,2,10,20]
19:02:20 <edwardk> >>> upon (tail.tail) .~ [10,20] $ [1,2,3,4,5]
19:02:20 <edwardk> [1,10,20]
19:02:51 <byorgey> why does  upon (tail.tail) do that?
19:02:53 <edwardk> upon only looks 'one level down' in template for places it can target.
19:03:22 <edwardk> upon can't find the nested tail because it only searches entries in template.
19:03:44 <rwbarton> hmm, can you sanity check the result of upon somehow to give a runtime error for things lik upon (tail.tail)?
19:03:48 <edwardk> it finds the tail, and then writes to it an exception, then attempting to access tail.tail causes that exception, and it thinks it found the field
19:04:10 <byorgey> that sounds... icky
19:04:17 <shachaf> Oh, you wrote it?
19:04:21 <edwardk> upon is intended for field accessors only really
19:04:27 <byorgey> waiter, there's an exception in my lenses!
19:04:27 <edwardk> that it works for head, tail, etc is 'cute'
19:04:41 <edwardk> shachaf: yeah
19:04:48 <rwbarton> sure, but in general noticing when the user misused it would be good
19:05:01 <rwbarton> since it mostly for convenience, and silently wrong answers are not convenient
19:05:01 <shachaf> rwbarton: upon gives you a Traversal
19:05:06 <shachaf> You can check whether it's empty or not.
19:05:10 <edwardk> rwbarton: the issue is i can't know =(
19:05:22 <rwbarton> why can't you apply your function to the result, for example
19:05:26 <edwardk> yeah but upon (tail.tail) gives you a non-empty traversal
19:05:37 <rwbarton> yes but you can check and see it is the wrong one, can't you
19:05:40 <rwbarton> at least in your test case
19:06:02 <edwardk> because the two functions i have are from s -> a where i know nothing about a. and that probably does trigger the exception
19:06:06 <shachaf> Oh, by applying the function and comparing the result?
19:06:07 <edwardk> and one from a -> f a
19:06:09 <rwbarton> for example
19:06:17 <edwardk> where i can't compare the answer there because i don't know anything about f
19:06:45 <rwbarton> hm
19:06:55 <edwardk> upon, when used as directed is fine. ;)
19:06:59 <yasir> :p
19:07:02 <rwbarton> sure
19:07:28 <rwbarton> but you can offset any convenience you gain from it awfully quickly if you use it wrong and don't notice
19:07:31 <edwardk> upon works well for trees where you only walk down one level at a time, and is safe in the presence of infinite depth recursion because it doesn't go deeper
19:07:42 <edwardk> upon isn't something i heavily advocate using ;)
19:07:54 <rwbarton> is uponTheDeep an extension of upon?
19:07:55 <edwardk> its more an intellectual exercise that is relegated to Data.Data.Lens and not the main API
19:08:06 <rwbarton> when you restrict upon to intended use cases
19:08:29 <edwardk> uponTheDeep :: (Data s, Data a) => (s -> a) -> Simple Traversal s a
19:08:39 <edwardk> upon :: (Data s, Typeable a) => (s -> a) -> Simple Traversal s a
19:08:56 <rwbarton> well, okay
19:09:19 <edwardk> with work i might be able to weaken uponTheDeep to have the same signature as upon, by using a custom exception type that captures the Data instance
19:10:05 <edwardk> but upon works even when given a structure with infinite depth recursion, while uponTheDeep will spin forever. also upon is quadratically faster than uponTheDeep which is quite expensive
19:10:11 <shachaf> I thought you were going to call it thereupon.
19:10:29 <edwardk> shachaf: i was saying that to spur you to action, but it didn't work ;)
19:11:15 <edwardk> if uponTheDeep terminated everywhere upon does then I'd be happy to use it as upon and retire the other
19:11:36 * shachaf ended up having some other things to do!
19:11:42 <rwbarton> sounds reasonable
19:11:43 <edwardk> likely story =P
19:35:41 <cl1> is there a way to get input from stdin without printing it to the console?
19:36:59 <parcs`> hSetEcho stdin False
19:37:09 <parcs`> er, stdout*
19:37:20 <parcs`> one of those *shrug*
19:37:46 <shachaf> stdin, I assume
19:41:29 <cl1> it was stdin
19:42:00 <cl1> didn't work like i expected, was hoping to print out '-' instead of the letter, but it waits until the whole line to consume it
19:42:37 <cl1> I wanted it to consume stdin as I type
19:42:45 <rwbarton> hSetBuffering stdin NoBuffering
19:44:08 <siracusa> which doesn't work on Windows, IIRC
19:45:14 <cl1> siracusa: you recall correctly
19:50:03 <rwbarton> on windows you probably FFI to conio.h as though it were the 80s
19:55:41 <johnw> rwbarton: you know Windows 2 came out like 1990, yeah?
19:56:42 <rwbarton> conio.h is DOS, no?
19:59:02 <shachaf> Oh, man, <conio.h>
20:00:30 * shapr conio's shachaf into installing Windows 8
20:00:56 <shachaf> conio is dolio's long lost brother, right?
20:01:15 <shapr> My sister got me to setup her Windows 8 laptop today. Then she asked me to install Linux on top of it as soon as possible. She's never wanted anything to do with Linux previously.
20:01:39 <djahandarie> Windows 8, being useful by sucking.
20:05:28 <\xDE\xAD\xC0\xDE> i've never even seen windows 8 yet
20:06:51 * geekosaur has seen tv ads the past several days.  it looks like microsoft still hasn't figured out why iphone and android both ate their small-device-os lunch
20:08:56 <parcs`> windows 8, being useful by being different from windows 7 in silly ways, thereby giving curious users an excuse to finally try that linux thing
20:09:23 <geekosaur> (also can;t help but think a lot of folks will buy it, then try to figure out how to get real ms office running on it and return it forthwith.  not so much becausew windows 8 as because current win8 devices are barely tablets and can't run real ms office)
20:14:55 <lewis1711> silly question, but... which higher order function has a pattern like this?
20:14:56 <lewis1711> [(g h), (g (h x)), (g ((h x) x)) ...]
20:15:19 <startling> huh?
20:15:21 <johnw> hmm, something about that feels familiar
20:15:38 <startling> oh, they're church numerals almost
20:15:38 <lewis1711> to be a tad clearer
20:15:48 <lewis1711> foo h = [(g h), (g (h x)), (g ((h x) x)) ...]
20:16:06 <startling> where g and x are constants?
20:16:08 <lispy> lewis1711: but where does x come from in the definition of foo?
20:16:10 <lewis1711> yes
20:16:13 <johnw> what is the next in the sequence?
20:16:21 <rwbarton> that doesn't look very likely to typecheck unless g is polymorphic
20:16:36 <startling> lewis1711: you could do something like it with a scan.
20:16:37 <lewis1711> lispy: it's also a constant
20:16:44 <lewis1711> johnw: one moment
20:16:45 <startling> g could be "id" I guess.
20:16:54 <shachaf> ==rwbarton -- are you sure you're getting the sequence right?
20:17:26 <lispy> shachaf: The IRC parser in my brain just exploded
20:17:48 <startling> lispy, time to rewrite it!
20:18:12 <shachaf> dmwit can fix it.
20:19:03 <lewis1711> johnw: [(g h), (g (h x)), (g ((h x) x)), (g (((h x) x) x))]
20:19:08 <lewis1711> startling: will check out scan thanks
20:19:23 <shachaf> What's the type of h here?
20:19:44 <johnw> lewis1711: in pointfree, your sequence starts: $, (.), (. join) . (.)
20:19:59 <shachaf> Uh oh. johnw is at "that" phase.
20:20:11 <johnw> what, the phase of using @pl?
20:20:23 <johnw> i'm just trying to look for the pattern from another angle
20:20:30 <lispy> pointfree all the functions!
20:20:36 <startling> @pl johnw
20:20:37 <lambdabot> johnw
20:20:40 <startling> uh-oh
20:20:41 <johnw> i'm no pointfree zealot
20:20:46 <startling> it's conclusive, johnw is pl'd.
20:20:54 <johnw> although, i tend to like one less point than shachaf
20:21:19 <johnw> shachaf x = f . g x
20:21:24 <johnw> johnw = (f .) . g
20:21:39 <johnw> that's the real difference between us
20:21:50 <johnw> but we're isomorphic, so that makes us friends
20:21:54 <lewis1711> has noone told me about scan before. this is great
20:22:11 <lispy> shachaf - johnw = eta
20:22:14 <anxex> I don't understand why Haskell can't derive an Enum type, when it derives Ord just fine. http://hpaste.org/78132
20:22:23 <lewis1711> shachaf: not sure yet :/
20:23:28 <shachaf> anxex: "(an enumeration consists of one or more nullary, non-GADT constructors)"
20:24:15 <anxex> shachaf: if I understood the error, I wouldn't have asked.
20:24:32 <shachaf> anxex: "nullary" means "taking no arguments"
20:25:06 <anxex> shachaf: my question is: why? If the Ord works, why can't the Enum?
20:25:45 <shachaf> anxex: What instance do you expect it to write?
20:26:06 <anxex> shachaf: the exact same order already specifed by Ord
20:26:20 <shachaf> Enum gives you more than order.
20:26:21 <Cale> anxex: deriving is a convenience thing which only works in specific cases for a specific (and short) list of type classes.
20:26:37 <shachaf> data Foo = Foo Integer Integer
20:26:44 <shachaf> What Enum instance do you want derived for that?
20:26:49 <shachaf> It's easy to compare two Foos
20:27:14 <anxex> shachaf: Dictionary order, of course. The order automatically given by Ord.
20:27:23 * dmwit looks around sleepily
20:27:24 <shachaf> @src Enum
20:27:25 <lambdabot> class  Enum a   where
20:27:25 <lambdabot>     succ                     :: a -> a
20:27:25 <lambdabot>     pred                     :: a -> a
20:27:25 <lambdabot>     toEnum                   :: Int -> a
20:27:25 <lambdabot>     fromEnum                 :: a -> Int
20:27:27 <lambdabot> [3 @more lines]
20:27:29 <shachaf> hi dmwit
20:27:40 <dmwit> o/
20:27:44 <shachaf> anxex: What should fromEnum/toEnum be?
20:28:11 <geekosaur> anxex, so let me ask you these:  (1) which Integer gets incremented "first" (2) under what conditions would the *other* one be incremented
20:28:25 <shachaf> geekosaur: Well, that's easier to answer.
20:28:38 <shachaf> Just go by the ordering Ord derives, like anxex said.
20:28:58 <anxex> fromEnum Foo1   --> 0
20:29:05 <geekosaur> sure.  but I bet this does not do what anxex is somehow thinking about
20:29:19 <ion> What’s Foo1?
20:29:23 <geekosaur> Foo1 is not a value of Foo Integer Integer
20:29:50 <NihilistDandy> fromEnum (Foo 2 3) = ?
20:29:58 <geekosaur> ^^
20:29:59 <dmwit> anxex: The order that Ord gives isn't a good order to use for Enum, because you'd have to enumerate infinitely many things to reach certain (otherwise finite) values.
20:30:13 <geekosaur> which is what I was getting at with my questions
20:30:34 <dmwit> It just so happens that in the (Integer, Integer) case there is a good order, but there's no reason to think that should always be true.
20:31:10 <dmwit> (And yes, geekosaur, shachaf, and NihilistDandy have been attempting to ask you enough leading questions that you'd figure this out for yourself.)
20:31:36 <ion> For Bounded a => Foo a a, Enum would be easier. :-P
20:31:39 <anxex> dmwit: Ord is already giving me a "good order" -- the dictionary order. I have two Enums. I don't see any reason why I can't get dictionary order with two Enums, since dictionary order for Ord is already there.
20:31:52 <dmwit> anxex: You say it's a good order, but I don't agree.
20:32:02 <mm_freak_> @tell mreh event wires like 'for' act like the identity wire except when the event did not happen, in which case they inhibit…  let i* be wires that inhibit…  the properties are x . i = i . x = i' and of course the typical category laws:  x . id = id . x = x
20:32:02 <lambdabot> Consider it noted.
20:32:10 <dmwit> anxex: I don't agree, because enumeration would never get be from (2, 2) to (3, 3).
20:32:12 <anxex> dmwit: it's the default order. Forget the "good" part. It's the default order.
20:32:39 <dmwit> If it's not a good order for enumeration, then you shouldn't use it for an Enum instance. =)
20:32:42 <dmwit> That's the point. =)
20:32:46 <mm_freak_> @tell mreh that's why you observe "blah" . for 3 = for 3 . "blah"…  in fact when a wire inhibits with 'mempty' the laws are literal
20:32:47 <lambdabot> Consider it noted.
20:32:56 <dmwit> (It's a fine order for comparisons, and that's why it's okay to use it for Ord.)
20:33:02 <geekosaur> and Integer is actually the worst possible case, because it's "infinite" precision.  you will only ever reach *one* of those Integer-s, and you cannot assign any meaningful value whatsoever for fromEnum of your Foo Integer Integer
20:33:29 <Maxdamantus> > map (toEnum :: Integer -> Int) [0, 1, 2, -1, -2, -3]
20:33:31 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
20:33:31 <lambdabot>              with a...
20:33:39 <geekosaur> anxex:  also, if your answer is "I don't care about fromEnum" then our answer is "then you do not want Enum at all"
20:33:46 <Maxdamantus> > map (fromEnum :: Integer -> Int) [0, 1, 2, -1, -2, -3]
20:33:47 <lambdabot>   [0,1,2,-1,-2,-3]
20:34:01 <Maxdamantus> Ah. They're allowed to be negative :\
20:35:41 <anxex> Do people at least understand my point? I already have an order. Ord gives me an order. I don't need to tell you how to order. It's already the dictionary order. It's already there. I don't see any reason why Enum can't be based off that.
20:35:52 <rwbarton> no
20:35:56 <anxex> Is it because Haskell considers that it could be infinite?
20:35:57 <geekosaur> I understand that you dont understand Enum
20:36:28 <anxex> Or I need to specifiy a starting point integer?
20:36:30 <copumpkin> anxex: how do I ask for "next" using compare or <=
20:36:31 <copumpkin> ?
20:36:39 <geekosaur> anxex, uyou are ignoring a bunch of stuff.  Yes, I grok that you don't care about it.  What *you* don't get is that these "useless" things are what Enu, is actually about
20:36:39 <geekosaur> It
20:36:46 <anxex> Like I might want 999 to map to the first element?
20:36:51 <ion> anxex: What’s fromEnum (Foo 2 3)? What’s a in toEnum a = Foo 2 3?
20:37:03 <dmwit> anxex: The real numbers have an ordering, but not an enumeration.
20:37:07 <dmwit> anxex: Does that help?
20:37:25 <dmwit> (forgetting Haskell for the moment)
20:38:00 <dmwit> (the point here being that it makes sense to separate the two concepts, independently of the hash Haskell has made of them)
20:38:03 <shachaf> dmwit: The computable reals have an enumeration. :-)
20:38:21 <akahn> It seems like I can't use 'type' as the name of a field in a record. Is there any way around this?
20:38:26 <dmwit> shachaf: Yes, but that doesn't further the conversation in a very interesting direction. =)
20:38:27 <shachaf> akahn: Nope.
20:38:39 <rwbarton> anxex: yes, the issue is that the fields might have types with infinitely many values
20:38:46 <dmwit> akahn: You can use a close name, like type_, type', kind, sort, etc.
20:38:46 <johnw> ℚ is ordered, but has no enumeration either; what comes after 1/2?
20:38:49 <shachaf> That's one of the issues.
20:39:01 <dmwit> johnw: The rationals can be enumerated.
20:39:06 <shachaf> Another one of the issues is that Enum is a mess in other ways, such as having fromEnum :: a -> Int
20:39:12 <johnw> oh, by that diagonal zigzag thing?
20:39:14 <akahn> shachaf: thanks. I guess I can't use Aeson's generics feature for this JSON, since the document has a type field that I need to use
20:39:18 <dmwit> johnw: for example
20:39:26 <johnw> i forgot about that, thanks
20:39:34 <Maxdamantus> You can enumerate them in the same way that you enumerate (Z, Z) values.
20:39:37 <shachaf> akahn: Maybe something like "_type"? I don't know.
20:39:43 <shachaf> It depends on how Aeson's feature works.
20:39:58 <Maxdamantus> or .. (Z, N)
20:39:59 <ion> shachaf: And by not having e.g. pred :: a -> Maybe a
20:40:02 <johnw> is ℂ ordered?
20:40:21 <shachaf> johnw: Complex Real or Complex Rational? :-)
20:40:29 <johnw> touché
20:40:37 <akahn> I think if I use aeson with generics I have to match JSON to haskell record fields directly, but maybe there's a way to tweak things. but it's okay, I can define my own FromJSON instance
20:41:09 <dmwit> johnw: ordered? no
20:41:10 <johnw> akahn: why not use aeson-lens?
20:41:16 <dmwit> johnw: Not in a meaningful way.
20:41:20 <shapr> Sounds like steampunk!
20:41:22 <akahn> johnw: hadn't heard of/come across that
20:41:27 <rwbarton> "is X ordered" is one of those ill-formed questions
20:41:32 <rwbarton> except in an informal sense
20:41:37 <johnw> akahn: with it, you won't have to create any records to extract data from deep JSON structures
20:41:45 <anxex> rwbarton: thanks, that's the only answer to my question. Two finite Enums have a natural (dictionary) ord, and a natural Enum. It's just a matter of Haskell not treating the special case of finiteness, which is understandable. Am I on the right track?
20:41:47 <dmwit> Yes, I'm with rwbarton on that.
20:41:54 <akahn> johnw: can I get around the 'type' issue?
20:41:57 <johnw> rwbarton: how is it ill-formed?
20:42:08 <johnw> akahn: one sec
20:42:12 <geekosaur> anxex, you still have not answered ewhat you think fromEnum (Foo 2 3) should mean
20:42:19 <akahn> btw I'm a haskell novice, so I feel like I may not want to approach lenses just yet
20:42:21 <rwbarton> "ordered" is not a property
20:42:23 <geekosaur> if you cannot define that you cannot define Enum
20:42:23 <rwbarton> it is extra structure
20:42:24 <dmwit> johnw: If you believe in the axiom of choice, you can put an ordering on any set.
20:42:43 <rwbarton> contrast: is the group of integers commutative
20:42:44 <NihilistDandy> dmwit: Big if.
20:42:52 * dmwit nods agreeably
20:42:57 <parcs`> > logBase 10 (2^11)
20:42:59 <lambdabot>   3.311329952303793
20:43:13 <rwbarton> anxex, I think so. in general Enum is kind of wonky
20:43:17 <Maxdamantus> Are Fibonacci numbers ordered?
20:43:45 <rwbarton> anxex: are you looking for a particular Enum function?
20:44:30 <johnw> akahn: i no longer remember where I answered this question
20:44:59 <johnw> akahn: but say the element you want to dig out is a string
20:45:06 <johnw> you just :: String on the lens composition
20:45:48 <rwbarton> or contrast with these other well-formed questions: "does there exist an ordering on X?" "how many different orderings on X are there?"
20:46:14 <rwbarton> and informally, "is there a standard ordering on X that is conventionally assumed by default?"
20:46:16 <akahn> johnw: thanks
20:46:37 <Maxdamantus> What doesn't there exist an ordering on?
20:47:03 <rwbarton> nothing
20:47:16 <parcs`> > logBase 10 (2^(1023-11))
20:47:18 <lambdabot>   304.6423556119489
20:47:31 <Maxdamantus> The order of that is: []
20:47:42 <rwbarton> I mean: there is nothing that there doesn't exist an ordering on
20:47:50 <Maxdamantus> Ah.
20:47:54 <rwbarton> I didn't say it was an interesting question, just a well-formed one :)
20:48:02 <shachaf> I bet rwbarton believes every set can be well-ordered, too.
20:48:05 <rwbarton> yep
20:48:12 <rwbarton> otherwise it's not really a set, now is it
20:48:16 <NihilistDandy> Void has trivial ordering, then?
20:48:25 <Maxdamantus> [()]
20:48:40 <Maxdamantus> Yes, any set of size 1 or 0 has one order.
20:48:46 <anxex> rwbarton: that requires axiom of choice, iirc
20:49:01 <rwbarton> axiom of choice is assumed by default :)
20:49:35 <johnw> akahn: I found the cdoe
20:49:41 <shachaf> rwbarton: Around constructivist circles like #haskell?
20:49:44 <hpaste> johnw pasted “json.hs” at http://hpaste.org/78133
20:50:04 <johnw> I'm using Value there because I don't use the value in Haskell code, I just pass italong
20:50:09 <johnw> but I could make it Maybe String, for example
20:50:43 <akahn> johnw: very cool!
20:51:46 <edwardk> i need to spend some time on aeson-lens and see if a er… more legal set of lenses can be derived =P
20:52:09 <johnw> aeson-lens is proving to be an easy way for me to sell lens to people, btw
20:52:18 <anxex> geekosaur: we already settled your (Foo 2 3) issue, no? I was talking about finite Enums, not your issue.
20:52:20 <edwardk> yeah thats why i kinda want to fix it before it gets too far gone =P
20:52:32 <johnw> i caught snoyman's interest because he needed to do some ad-hoc json extraction
20:52:36 <NihilistDandy> johnw: I can see why
20:53:28 <geekosaur> I'm not seeing an answer, Im seeing you saying things implying you consider it irrelevant.  Haskell does NOT consider it irrelevant; it's part of the definition
20:53:50 <johnw> are we still arguing about what Enum means?
20:54:20 <geekosaur> I don't really care.  if we want to pretend Haskell is Java, go nuts.  but don't expect much help when the inevitable occurs.
20:54:45 <edwardk> anxex: you can make up your own Enum instance for your own types, but Enum doesn't come with inherent bounds that it knows can exist.
20:55:29 <edwardk> so given (Int,Int) i have no way to enumerate it, but given your own data Foo = Foo Ordering Ordering -- which can only have 9 different elements sure you can make that enum
20:55:59 <rwbarton> I've been using my own objectAt :: Text -> Simple Traversal Object Object, integerAt :: Text -> Simple Traversal Object Integer, etc.
20:56:05 <anxex> geekosaur: That's pretty silly. Not sure why you are being so hostile. I didn't imply anything was irrelevant. The issue was resolved a while back when the finiteness of my Enums were not taken into account, which is understandable.
20:56:12 <rwbarton> I assume they are also IndexedTraversals or whatever
20:56:20 <edwardk> given Enum and Bounded you might concoct something that multiplied the ranges, but then you'd have to pick starting points, etc.
20:56:28 <anxex> s/back/back when I realized/
20:57:53 <rwbarton> these Traversals are areally 0-or-1 traversals (or as I like to call them "zoots")
20:58:42 <akahn> johnw: wait, but I'm *decoding*. how can I decode JSON without defining any types? oh, wait, Data.Aeson.Lens didn't compile successfully
20:59:13 <johnw> for decoding, you'll need to specify a type
20:59:22 <johnw> and note I said this was a good approach if you just want to sniff data out
20:59:24 <shachaf> rwbarton: Cω has types "foo?" "foo+" "foo*" for a type "foo", I'm told.
20:59:34 <johnw> if you want to represent the whole thing in Haskell, then you'll want FromJSON and records, yeah
20:59:39 <shachaf> That would be a good naming scheme.
20:59:45 <shachaf> Lens Lens? Lens+ Lens*
20:59:46 <akahn> johnw: gotcha
20:59:53 <rwbarton> yeah
21:00:00 <shachaf> (And if we had the right hierarchy... Sigh.)
21:00:08 <johnw> and be sure to check out Aeson's TH support, it will free you from having to write any FromJSON instances
21:00:19 <edwardk> it'd be nice if we had a better hierarchy, but its not too bad as is
21:00:36 <shachaf> edwardk Maybe it's worthwhile to have type synonyms for zero-or-one and one-or-more traversals?
21:00:41 <shachaf> :
21:00:53 <shachaf> Would help in documentation if nothing else.
21:00:56 <rwbarton> just as informal docs?
21:00:59 <edwardk> the problem is to give them the right types is hideous
21:01:08 <shachaf> The right types?
21:01:14 <johnw> akahn: here's an example of a type I read from JSON:
21:01:18 <shachaf> I mean type Zoot = Traversal
21:01:19 <hpaste> johnw pasted “deriveJSON.hs” at http://hpaste.org/78134
21:01:30 <shachaf> No difference except documentation.
21:01:32 <edwardk> as docs i'm kinda afraid of adding more distinctions to a library that already arguably makes too many to have as many users as it does ;)
21:01:51 <shachaf> Hmm. I suppose.
21:02:00 <shachaf> But it's a pretty important distinction.
21:02:15 <johnw> most libraries are things we use to write better code; lens is a library we use just to be become better
21:02:29 <akahn> haha, what do you mean by that?
21:02:33 <shachaf> If it's not in the documented types, it should be mentioned in the comments for every traversal.
21:02:40 <johnw> akahn: i am being facetious :)
21:02:44 <edwardk> I'd be okay with that.
21:02:57 <edwardk> better documentation is always good
21:03:04 <akahn> looks like I'd still have the issue of the JSON having a 'type' key
21:03:07 <shachaf> Oh, were we going to do Zipper.Internals?
21:03:19 <edwardk> I wish the canonical name 'PartialLens' for a 0or1 traversal wasn't so encumbered.
21:03:30 <edwardk> feel free to split it out and move the Level stuff out of Internal.
21:03:40 <johnw> PartialLens is a bad name for it, if you keep the name traverseLeft
21:03:45 <shachaf> OK. Internal.Zipper?
21:03:49 <shachaf> johnw: traverseLeft is gone.
21:03:50 <edwardk> johnw: its _left now
21:03:54 <johnw> nice
21:03:57 <johnw> i was wanting tha
21:03:57 <johnw> t
21:03:57 <NihilistDandy> shachaf: Lens!
21:04:00 <edwardk> in general traverseFoo became _foo
21:04:17 <johnw> i understood why it was traverseLeft, but it was ugly
21:04:17 <shachaf> Good old alpha-reduction.
21:04:23 <johnw> haha
21:04:24 <edwardk> =)
21:04:40 <edwardk> shachaf: just you wait, i'll alpha reduce farthest to far ;)
21:05:05 <anxex> edwardk: the reason I expected the auto-Enum was because derive(Enum) already picks starting points. It's possible for Haskell to similarly derive an Enum out of two finite Enums, whether or not that's desirable.
21:05:48 <shachaf> anxex: Well, it doesn't. :-)
21:06:07 <edwardk> anxex: it isn't possible with the way Bounded works. Bounded is a separate class. to know something is a finite enum you'd need (Bounded a, Enum a) -- now, there it is sometimes possible. but only sometimes, because the product of the enumerable ranges usually blow past the size of Int.
21:06:52 <edwardk> so to figure out the Enum (a,b)  you'd need (Bounded a, Enum a, Bounded b, Enum b)  -- what does it start at? lots of enums start with negative numbers -- take Int.
21:07:24 <anxex> edwardk: yes in my non-toy example I am deriving Bounded too.
21:08:12 <edwardk> anyways Enum deriving follows a principle of least surprise as it stands. ;)
21:08:14 <anxex> I suppose there is no Finite thing, which would imply Bounded
21:08:43 <edwardk> also Enum has lots of fake as all hell instances like Float, Double, etc.
21:09:07 <edwardk> you could make a more compelling case if you required Enum to go to and from Integer and then defined fair interleaving, etc.
21:09:31 <edwardk> but this doesn't yield the ordering most users would sanely expect
21:09:43 <edwardk> so I can't say its a bad thing that the designers of Haskell back in the day decided to punt ;)
21:12:02 <anxex> Yeah succ 1.0 is strange. Perhaps the next largest machine float makes sense, but not really useful.
21:12:18 <Nereid> the Enum instance for Double is pretty awful.
21:12:25 <edwardk> then [1..4] :: Float will take a long time ;)
21:13:04 <edwardk> > succ (1 R.% 2)
21:13:06 <lambdabot>   3 % 2
21:13:07 <bgamari> colah, So I have a change set on top of the current state of the tree
21:13:13 <edwardk> that one is also likely to be a problem ;)
21:13:29 <bgamari> colah, Things have been moved to vector-space, including separating points from vectors
21:13:36 <shachaf> > [1,3..4] :: [Double] -- good old Enum Double
21:13:38 <lambdabot>   [1.0,3.0,5.0]
21:13:42 <bgamari> colah, Unfortunately it's (as expected) an extremely intrusive changeset
21:14:16 <bgamari> colah, consequently, it would be nice if we could discuss it soon and see what could be done to get a merge finished if that's alright
21:14:30 <simpson> > succ 1.2 :: Double -- I must confess that I don't know what happens nor why
21:14:31 <lambdabot>   2.2
21:14:37 <bgamari> colah, In the meantime, maintenance will be quite tricky
21:15:07 <djahandarie> > [3..4] :: [Double]
21:15:09 <lambdabot>   [3.0,4.0]
21:15:25 <shachaf> > [3,5..4] :: [Double]
21:15:27 <lambdabot>   [3.0,5.0]
21:15:44 <shachaf> > [3,5..0] :: [Double]
21:15:46 <lambdabot>   []
21:15:55 <shachaf> > [3,5..3] :: [Double]
21:15:57 <lambdabot>   [3.0]
21:16:25 <djahandarie> Haha, that's even worse than the first example.
21:16:52 <shachaf> Why?
21:17:40 <tricorder42> [5..4] :: Double
21:17:44 <tricorder42> sorry
21:17:49 <tricorder42> > [5..4] :: Double
21:17:51 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
21:17:51 <lambdabot>              with actual ty...
21:18:00 <tricorder42> nvm
21:28:16 <hpaste> ryanos pasted “multiple parses” at http://hpaste.org/78135
21:29:07 <ryanos> hello, hello... is *anybody* out there..?
21:29:15 <ryanos> i have this function that is trying to parse some string
21:29:20 <ryanos> and compiles well
21:29:47 <Crockeo> Though I'm probably not the best guy to help, I'll give it a look.
21:29:54 <Crockeo> What's the error?
21:30:13 <ryanos> when i pass some strange parameters it gets "Non-exhaustive pattern match"
21:30:27 <Ferdirand> if I have a large function with many clauses, is there a way to automatically insert an SCC in each clause ?
21:30:31 <ryanos> and i don't know where is not exhaustive - in the case section or in the function section ?
21:30:54 <ryanos> Crockeo: thanks
21:31:08 <Crockeo> ryanos: If I'm not mistaken it tells you where the error occurs, right?
21:31:25 <latermuse> ryanos: try ghc -Wall and it will tell you where the problem is
21:31:35 <mauke> ryanos: where's the error message?
21:32:09 <ryanos> latermuse: i tried -Wall and gives the same error
21:32:39 <ryanos> there is no error if i pass the proper parameters starting with "string1", "string2", etc
21:33:08 <ryanos> if i pass some random unformatted string i get the "non-exhaustive" exception
21:33:11 <mauke> WHAT IS "THE SAME ERROR"
21:33:12 <xunatai> you need to include _ -> at the bottom
21:33:19 <xunatai> and deal with that
21:33:47 <NihilistDandy> ^
21:33:55 <xunatai> if you have a string of length 2 through 6, or > 7, it will not fall under anything
21:34:01 <NihilistDandy> Change [_] to _
21:34:04 <NihilistDandy> And you'll be fine
21:34:12 <xunatai> or 7 chars and not string 1 2 or 3
21:34:28 <xunatai> ^
21:34:33 <ryanos> NihilistDandy: that works, thanks :)
21:34:50 <ryanos> now.. what was the reason ?
21:34:55 <xunatai> i explained
21:35:06 <xunatai> [_] only matches single char strings
21:35:10 <NihilistDandy> ^
21:35:17 <ryanos> xunatai: thanks, didn't see it
21:35:24 <mapf> why package "monoids" is obsolete?
21:35:36 <ryanos> thanks everybody, great help as always
21:37:18 <ryanos> now.. any suggestions on how to do that better? (a more idiomatic haskell approach) ?
21:37:31 <ryanos> (talking about http://hpaste.org/78135)
21:39:52 <xunatai> well, i'd say remove line 2
21:40:04 <xunatai> isn't necessary
21:40:24 <xunatai> in light of the change of line 7
21:40:49 <ryanos> xunatai: thanks, agree on line 2 - removed
21:40:59 <xunatai> er
21:41:03 <xunatai> hm
21:41:14 <Crockeo> ryanos: Couldn't you also use guards instead of a case statement.
21:41:58 <ryanos> Crockeo: i guess i could do that too, was just trying to play with case.. what would be the benefits of guards in this case ?
21:42:24 <xunatai> on the other hand
21:42:26 <Crockeo> I've no idea; they're just what's commonly used in this context.
21:42:33 <ryanos> and was also trying to extract info as much as possible in an implicite way
21:42:39 <ryanos> (with minimal amt of code)
21:42:57 <ryanos> letting haskell do it's magic
21:43:10 <ryanos> (which i am frequently burn myself with lately :) )
21:43:11 <Crockeo> I suppose so, in this context I would've used guards just because that's what I know.
21:43:32 <ryanos> Crockeo: got u - agree, both are equally useful
21:43:51 <xunatai> "(a:b:c:d:xs) = words x" is presumtive, what if there are three or less words?
21:44:27 <Crockeo> I'd imagine that guards are more often used in this context while cases are used mid-functioon.
21:44:55 <ryanos> xunatai: great question - always there are more than 3 words BUT.. if there aren't  - how could i write some defensive code in that case ?
21:45:29 <ryanos> Crockeo: agreed
21:46:55 <xunatai> also
21:47:03 <ryanos> xunatai: how to write code defensive, preferable without having to go through all the possible combinations (one empty, two empty, three empty, etc...)
21:47:20 <xunatai> i would suggest using Maybe String or something instead of regular string for failing
21:47:25 <xunatai> not sure
21:47:28 <xunatai> yet
21:48:31 <xunatai> or Either, with Left as a parsed string, and Right as the error message if one results
21:48:44 <ryanos> wouldn't that Maybe add more complex stuff ?
21:49:19 <ryanos> so how would my function look then ? if i wanted to use Either for example ?
21:49:37 <ryanos> where did i put the Either ?
21:49:46 <xunatai> it would allow the caller to fail elegantly with a pattern match
21:50:05 <xunatai> rather that say, == ""unable to parse"
21:50:21 <xunatai> which is a silly way to detect an error
21:50:47 <ryanos> xunatai: agree on silliness, i'm just starting with this
21:50:55 <ryanos> that's why i need some insight on how to do it better
21:51:04 * xunatai modifies parseString
21:51:36 <Ankhers> How can I tell what version of GHC I used to compile a package?
21:51:48 <mzero> xunatai: it would be more idomatic to make the Left be the error message, and Right be the parsed string
21:52:58 <ryanos> mzero: agree on that, i heard the "Right is right" idiom from the wise guys on #haskell
21:53:55 <mzero> ryanos: not sure what you meant by "wouldn't that Maybe add more complex stuff ?" --- but you should start to think of Maybe and Either this way: they make explicit the complexity that was already there, just hidden
21:54:23 <ryanos> mzero: agree on making things explicit
21:54:25 <mzero> returning a 'magic string' to indicate failure is hidden complexity - without looking at your implementation, how would one know
21:54:46 <ryanos> but because i am not familiar with haskell that much i just want to write the minimum amt of code that does that
21:55:15 <ryanos> in this particular case that is just a playing function
21:55:20 <mzero> whereas returning Maybe String makes such possibilities (that it didn't parse, so you don't get a String) not only explicit .... but difficult to ignore
21:55:41 <mzero> oh, the code would be the same or _smaller_ if you used Maybe
21:55:55 <mzero> over all, that is
21:55:58 <ryanos> mzero: agree - i guess i didn't look at that just because i was playing with the function directly, nobody else was calling it yet
21:56:27 <mzero> remember: every function is a message in a bottle to your future self
21:56:41 <ryanos> mzero: :)) good one, i will remember..
21:56:51 <sclv> mapf: like the documentation says, the functionality in monoids was refactored and split among a number of libraries, culminating in "reducers"
21:57:17 <mzero> besides I like to think that writing    parseString :: String -> Maybe String      starts off by expressing clearly, to myself right now, what I think this funciton should do!
21:57:41 <mapf> sclv: thanks
21:57:59 <mapf> i should learng about semigroups then
21:59:07 <ryanos> mzero: agree, the Maybe String will take care of the possibility of not returning the expected stuff. any dev worth his salt will think about what he returns from a func and how he handles errors.. i'll add more haskell salt on my tail soon
22:00:06 <sclv> semigroups are just monoids without necessarily having an mzero
22:00:09 <sclv> even easier
22:01:26 <mzero> I don't care to belong to any semigroup that will have me as a member!
22:01:40 <ryanos> mzero: besides the Either part - how could i make that funct better ? (more haskell-idiomatic). did i use well the lang features or wrong ?
22:01:50 <sclv> well done :-P
22:01:58 <ryanos> mzero: u should put the quotes around that :)
22:02:36 <ryanos> mzero: as a mzero - you definitely belong in a semigroup
22:02:43 <mzero> "mzero: I don't care to belong to any semigroup that will have me as a member!"
22:02:46 <mzero> :-)
22:02:55 <ryanos> :)
22:03:35 <ryanos> Groucho Marx thought the same
22:03:50 <mzero> Indeed!
22:04:10 <ryanos> Groucho Marx’s letter of resignation to the Friars’ Club: “I don’t want to belong to any club that would accept me as one of its members.”
22:04:42 <ryanos> but in your context is even better - considering u r a mzero
22:04:52 <ryanos> :)
22:05:27 <NihilistDandy> That got meta quickly
22:07:38 <mzero> Well, I never met a meta I didn't like...
22:07:50 <mzero> (I'm here all week, folks!)
22:08:33 <hpaste> mzero annotated “multiple parses” with “multiple parses (annotation)” at http://hpaste.org/78135#a78139
22:09:07 <mzero> ryanos: the big difference is that you had a possible pattern match failure in your while clause: What if x was "foo bar" -- it would have crashed
22:09:39 <ryanos> agree
22:09:51 <mzero> er, my line 5 is missing a close parens
22:10:13 <mzero> also, expressed this way, the somewhat strange picking of various sub words is rather more clear
22:12:03 <ryanos> mzero:that looks great, you definitely belong in this group
22:19:04 <xunatai> ryanos: http://hpaste.org/78141
22:19:32 <xunatai> maybe not idiomatic, but employs Maybe, and correctly detects all cases
22:21:35 <ryanos> xunatai: looks great too
22:22:01 <ryanos> goes through all the details and tries to identify the various exceptions
22:22:27 <mzero> xunatai's is subtly different than your original
22:22:41 <ryanos> the + of testing for 4 at the begining can become a - though if i change the patterns
22:22:48 <mzero> in particular, it doesn't work if there are five or more words in the input, whereas your original (and mine) do
22:23:19 <xunatai> why not?
22:23:47 <mzero> because you check for length (words x) == 4
22:23:59 <mzero> also, xunatai's version computes words x twice
22:24:02 <mzero> (potentially)
22:24:48 <ryanos> xunatai: the function tries to concatenate all the words past 4 at the end
22:24:57 <xunatai> missed that fact
22:25:04 <ryanos> if there are more than 4 should add them all to the end not return Nothing
22:25:07 <ryanos> not a problem
22:25:17 <ryanos> i got the idea, looks nice
22:25:26 <xunatai> herm
22:25:30 <xunatai> in that case..
22:25:38 <mzero> changing == to >= would fix that in xunatai's - but I think case matching on    words x    is probably better
22:26:36 <mzero> but - really, now we are in a realm of not knowing the realy problem domain, and these kinds of style choices will really be about what you are trying to express with the code -
22:26:41 <ryanos> personally i think the case matching on words x looks a bit more idiomatic (and shorter)
22:27:04 <ryanos> mzero: i am just trying to "play" with code, not at "express" level yet :)
22:27:30 <ryanos> and was trying to be as "idiomatic" as possible, both of you provided great insight
22:28:39 <ryanos> i've chosen the case matching because it seems to fit better in the haskell philosophy of using pattern matching to reveal structure
22:28:53 <ryanos> (to reveal hidden structure)
22:29:20 <ryanos> and allow the typing system - in this case the list of strings - do some lifting for me
22:29:58 <Crockeo> Hey, anyone here know how to determine the equality between two different states in a data declaration?
22:30:17 <mzero> all code is haiku / express your meaning, no more / moon on a clear night
22:30:26 <Crockeo> Like having data Tile = Player { x :: Int, y :: Int, under :: Tile]
22:30:33 <Crockeo> (with other Tile definitions)
22:30:43 <Crockeo> and checking if a value is that specific state of Tile.
22:31:01 <shachaf> I think you have to decide what equality means yourself.
22:31:08 <shachaf> Maybe I don't understand your question.
22:31:14 <ryanos> mzero: a clap in a forest / a case / or parse / nevermind...
22:31:20 <Crockeo> One sec, I'll put something in a paste.
22:31:23 <shachaf> (Or your type. That's a syntax error that could mean two very different things.)
22:33:09 <mm_freak_> i think randomR, randomRs and randomRIO should be in a separate class
22:33:13 <hpaste> Crockeo pasted “Data Question” at http://hpaste.org/78142
22:33:18 <ryanos> mzero: i also liked the "result = Just . unwords " and how u used the result to provide more meaning to what i was planning to return.. that looked like a nice enhancement i would have probably not think about in a while
22:33:51 <Crockeo> The alignment on 'Test2' is better in my text editor, so it doesn't look as ridiculous.
22:34:05 <xunatai> i just did that to avoid duplicating it three times
22:34:05 <mm_freak_> then you could write an instance (Floating a) => Random (Complex a)
22:35:19 <mm_freak_> or randomR should not take bounds, but instead a center and a radius, then a random number between 0 and 1 would be randomR (0.5, 0.5)
22:35:40 <ryanos> xunatai: yours looks neat also and v well organized - tx
22:36:19 <Crockeo> shachaf: Just to give you a buzz, I pasted some code on hpaste.
22:36:40 <shachaf> Crockeo: You can do that if you want.
22:36:55 <shachaf> case x of Test1 a -> ...; Test2 a -> ...
22:37:06 <hpaste> mzero annotated “Data Question” with “Data Question (annotation)” at http://hpaste.org/78142#a78143
22:37:13 <Crockeo> Okay
22:37:14 <shachaf> Crockeo: The reason the alignment looks bad is that you're using tabs.
22:37:24 <Crockeo> Are spaces standard in Haskell?
22:37:25 <shachaf> Crockeo: Don't use tabs. If you do use tabs, make them 8 spaces.
22:37:36 <shachaf> Er, make a tabstop 8 spaces.
22:37:41 <Crockeo> Alright.
22:38:22 <mm_freak_> the eight-spaces assumption is going to look weird here…  for me a tab is four spaces in general
22:38:23 <mzero> Crockeo: I answered you with code - it is not just okay - it is THE WAY
22:38:28 <mm_freak_> in other words:  don't use tabs
22:38:38 <Crockeo> THE WAAAAAAAAAAY
22:38:40 <Crockeo> (Thank you)
22:38:41 <mzero> as for testing - you do it with pattern matching
22:38:41 <xunatai> for haskell at least
22:39:20 <mzero> er, my -> should be = on lines 12 ~ 14
22:39:29 <mzero> (that's what I get for copy-pasting)
22:39:39 <Crockeo> mzero: I was 'Okay'ing shachaf, not you. I didn't even /realize/ you posted that! Thank you again.
22:40:09 <shachaf> mzero: Note that after your change, x/a/e are partial functions.
22:40:16 <mzero> you can pattern match in function clauses like I did there, or via a case expression
22:40:17 <OceanSpray> in type unification, what happens if the algorithm encounters two different type variables?
22:40:35 <shachaf> Crockeo: Another thing that's OK to do is data TestSort = One | Two; data Test = Test TestSort Int
22:40:51 <shachaf> Crockeo: Those are pretty much equivalent but sometimes one is more convenient than the other
22:40:56 <OceanSpray> if it supposed to fail, or is it supposed to arbitrarily try to create a constraint "one of these should be substituted to be the other"?
22:40:59 <mzero> shachaf: true dat - Crockeo - don't feel compelled to always name your data members there
22:41:16 <Crockeo> How about in this context: [y | x <- (getTiles board), y <- [0..], <Checking if x is a specific type, lets say Test1>]
22:41:27 <Crockeo> Is it possible there?
22:41:39 <mzero> data Test = TestLessThan Int | TestEquals Int | TestRange Int Int
22:41:45 <mzero> would be very idomatic and normal
22:41:58 <Crockeo> getTiles :: Board -> [Tile], by the way.
22:42:06 <mzero> no need to name the Ints - they are clear by the constructor names, and you will give them names when you pattern match them
22:42:11 <Nereid> Test1 _ <- getTiles board
22:42:13 <shachaf> Crockeo: [... | Test1 x <- getTiles board, y <- [0..]]
22:42:33 <Nereid> or x
22:42:40 <Crockeo> Thank you!
22:42:45 <Crockeo> Problem = solved.
22:42:54 <Crockeo> And I learned a lot too.
22:43:04 <Nereid> > [x | Left x <- [Left 1, Right 2, Left 3, Right 4]]
22:43:07 <lambdabot>   [1,3]
22:44:12 <darkf> Is there any moderately recommended IDE for Haskel? (Something where you can easily view the types of expressions and online compiling maybe?) Leksah looks like one.
22:44:23 <Nereid> leksah is the only one I've heard of.
22:44:49 <Nereid> although there are things for emacs or whatever too.
22:44:52 <mzero> I use leksah - it does completion suggestions with their type annotations - which I love
22:44:59 <Crockeo> Though it's far from an IDE in its 'natural' state, I suppose you could make either Vim or Emacs into a pretty good Haskell IDE.
22:45:05 <darkf> mzero: Nice :)
22:45:17 <darkf> Crockeo: I'm not too comfortable with vim/emacs, unfortunately.
22:45:27 <Crockeo> To be honest, neither am I.
22:45:38 <Crockeo> As of right now I'm just using Sublime Text 2 to work in Haskell.
22:45:41 <mzero> and it will compile as you type if you want -
22:45:41 <OceanSpray> according to the following link, unifying two different type variables just adds to the substitution a mapping from one variable to the other:
22:45:46 <OceanSpray> http://www.cs.cornell.edu/courses/cs3110/2012sp/lectures/lec27-type-inference/lec27.html
22:45:49 <johnw> Emacs is very nice for working on Haskell code
22:45:49 <ryanos> i am using textmate but not v happy
22:46:00 <shapr> Yes, emacs is a great tool for writing Haskell code.
22:46:04 <ryanos> johnw: tried to setup emacs but didn't work..
22:46:07 <OceanSpray> how does it just arbitrarily say that the left one is supposed to map to the right one?
22:46:15 <johnw> try looking at github.com/jwiegley/haskell-config
22:46:18 <ryanos> do you guys have a .emacs file around ?
22:46:23 <mzero> Sublime Text 2 is my other editor for code - I sometimes code in Haskell in it
22:46:30 <shachaf> OceanSpray: Well, either they unify or they don't.
22:46:37 <mzero> actually, right now I have btoh it and Leksah open on my code base at th same time --
22:46:41 <NihilistDandy> Vim is also nice for Haskell
22:46:58 <Crockeo> mzero: I feel like I want to buy a license for it, but I want to spend my money on other things.
22:47:00 <NihilistDandy> ST2 has been improving, as well
22:47:10 <Crockeo> Like reserving a Leap Motion in Febuary.
22:47:31 <OceanSpray> shachaf: what's that supposed to even mean?
22:47:33 <Crockeo> That reminds me, I wonder if they're going to provide a Haskell API for it.
22:47:33 <darkf> It looks like Sublime2 has a nice Haskell package too
22:47:40 <shachaf> OceanSpray: Maybe I don't understand your question.
22:47:46 <shachaf> OceanSpray: Which part of that page is the trouble?
22:47:54 <Crockeo> Probably not, considering that lazy evaluation may not play too well with the need for real-time interaction, though as a noob I could be completely wrong.
22:48:08 <NihilistDandy> ryanos: I suggest looking into the Emacs Prelude from Bozhidar Batsov
22:48:10 <OceanSpray> unify (Variable i) (Variable k) | i == k = [] --okay good and fine
22:48:22 <NihilistDandy> Lots of sane defaults and Haskell support
22:48:23 <OceanSpray> | i != k = ???
22:48:56 <ryanos> NihilistDandy: will do, tx
22:48:57 <johnw> ryanos: my whole .emacs is on github.com/jwiegley/dot-emacs
22:48:57 <OceanSpray> should ??? = [(k, Variable i)] or [(i, Variable k)]?
22:49:11 <johnw> i split out the haskell-config to spare others the madness
22:49:16 <ryanos> johnw: thanks will ck
22:49:19 <OceanSpray> basically, why is type unification not commutative?
22:51:11 <Crockeo> I'd imagine that well written Haskell is quicker than C, am I right?
22:51:25 <Crockeo> Considering that, supposedly, the compiler can make much more optimizations with Haskell than it can with C.
22:51:38 <shapr> It depends on what you're doing.
22:51:44 <shachaf> But the human can make more optimizations with C. :-)
22:51:52 <shapr> If you're trying to fit the Haskell runtime onto an Arduino, C is a much better choice.
22:52:11 <shapr> If you're trying to write composable threaded programs, Haskell is pretty much the only choice.
22:52:13 <NihilistDandy> Crockeo: I can optimize the hell out of terrible C code, but it'll still be terrible C code
22:52:21 <shachaf> shapr: The only choice?
22:52:43 <shapr> shachaf: Are there other production quality languages that have STM?
22:52:53 <shapr> Oh wait, Clojure has STM now, right?
22:53:07 <darkf> shapr: yes
22:53:40 <shapr> Ok, so there are at least two choices then.
22:53:41 <NihilistDandy> shapr: Implying that Haskell is production quality /troll
22:53:50 <shapr> NihilistDandy: Yah, totally :-)
22:54:52 * hackagebot templatepg 0.2.3 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/templatepg-0.2.3 (ChrisForno)
22:57:25 <yaw> So... what's the latest regarding record name clashes - I'm loving haskell but this one little syntax issue is almost a show stopper :S
22:57:49 <shapr> I haven't heard anything about changing that.
22:58:56 <Nereid> there are a number of proposals for dealing with it but yeah
22:59:52 * hackagebot binary 0.6.4.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.6.4.0 (LennartKolmodin)
23:02:43 <yaw> okay
23:03:00 <Crockeo> shapr: I was more talking about how many people attempt to do benchmarks in Haskell, which end up showing C is 'faster'.
23:03:07 <yaw> so is the current best practice just to either prefix the field names with something, or put everything in a separate module
23:03:08 <Crockeo> I was thinking they were probably just bad at writing Haskell
23:03:12 <Nereid> http://hackage.haskell.org/trac/ghc/wiki/Records
23:03:27 <shachaf> Crockeo: "Haskell is faster than C" is certainly a false statement.
23:03:29 <Nereid> lots of ways
23:03:48 <shachaf> True statements are trickier to say precisely. At any rate languages don't have speeds.
23:03:58 <shachaf> monochrom got it right, though.
23:03:59 <shapr> Crockeo: Oh... well, laziness on strict hardware has some extra cost.
23:04:00 <shachaf> Quote einstein
23:04:05 <shachaf> @quote einstein
23:04:06 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
23:04:59 <shapr> Crockeo: Usually C can produce a faster executable than Haskell at the cost of having WAY more bugs and writing the program in C takes WAY more time.
23:05:00 <Crockeo> I'd imagine that an imperative programmer wanted to benchmark Haskell vs. C and write imperative-like Haskell code.
23:05:00 <Crockeo> Then again
23:05:03 <Crockeo> it's more likely that I'm just trying to defend a false position to the end.
23:05:22 <shapr> Crockeo: No, I agree with what you're saying. Some Erlang guys successfully wrote Erlang in Haskell and cause no amount of entertainment.
23:05:41 <shapr> er "no small amount"
23:05:42 * shapr is tired
23:06:10 <Crockeo> shapr: Assuming that the programming in the respective languages are both relatively experienced. I could make a bad program quickly in C, but I can't even make a bad program relatively quickly in Haskell.
23:06:34 <Crockeo> That's not completely true, I could just pretend I'm programming in C and use all the dos.
23:06:57 <shapr> More practice in Haskell leads to the ability to produce really nifty programs in a small amount of time :-)
23:07:08 <shapr> and those programs are much more likely to work correctly than doing the same thing in C
23:07:27 <Crockeo> That, along with Haskell just being a really fun programming language, is why I'm learning it.
23:07:29 <Crockeo> Oh, and the experience of using functional programming languages.
23:07:41 <Crockeo> I've a feeling if I go back to Java any time soon I'm going to be using 'final' a lot more.
23:08:14 <Crockeo> I won't even remember how to do things with mutable data anymore.
23:09:02 <shapr> It's a good feeling to find it easier to write recursive code than iterative code.
23:09:15 <shapr> Although it does confuse my teammates in C++ part III
23:10:03 <xunatai> i find a lot of joy in puzzling over how i can make bits of haskell code simpler and more elegant
23:10:11 <mm_freak_> Crockeo: my story as a former C++ programmer is that after more than four years of haskell experience i'm finding myself having a hard time writing code in any imperative language, including C++
23:10:29 <xunatai> there seems to be a zillion more ways to do things in functional languages than imperative ones
23:11:16 <Crockeo> mm_freak_: I'm scared to go back to an imperative programming language because I'm afraid I'll lose all the progress I've made.
23:11:41 <Crockeo> Then again, some of my non-programmer friends decided they were going to learn C++ and asked if I could help them with it.
23:11:58 <Crockeo> I tried to convince them to choose Haskell instead, just because it was what I'm working in right now
23:12:00 <mm_freak_> Crockeo: you won't, but you will find that going back may be frustrating, because things like mapping and writing monadic combinators became so natural
23:12:00 <hpaste> ryanos pasted “What is your favorite haskell IDE ?” at http://hpaste.org/78144
23:12:32 <Crockeo> but when they found out that /I/ was having trouble learning a programming language they decided to run in the other direction.
23:12:47 <ryanos> not sure if it is #haskell idiomatic to do surveys, but i'm curious what would be the most common ide used by the gang :)
23:12:58 <Crockeo> I'm notorious for learning programming languages quickly among my friends, only because I'm the only one who programs extremely often.
23:13:03 <mm_freak_> ryanos: emacs and vim
23:13:35 <mm_freak_> Crockeo: offer them to learn haskell together with them instead of teaching them
23:13:42 <mm_freak_> grab a copy of LYAH and work on it together
23:14:01 <ryanos> mm_freak_: team - just open the http://hpaste.org/78144 and click on the survey. then select your preferences. this way we'll have a nice final decisive answer on IDE usage ...
23:14:07 <xunatai> but doesn't LYAH mention former programming experience?
23:14:20 <Crockeo> Well, I'm working on the digital version of LYAH, so I've already got 8 chapters of a head start on them
23:14:22 <mm_freak_> ryanos: post that on haskell-cafe rather than here
23:14:26 <Crockeo> and anyways, they're no longer interested.
23:14:36 <Crockeo> They got scared when I got confused.
23:14:42 <ryanos> mm_freak_: apologies - where is haskell-have ?
23:14:48 <ryanos> haskell-cafe
23:14:51 <Nereid> it's a mailing list
23:14:56 <gulk> can i do that for a tuple? func ((a,b):(c,d))
23:15:02 <Crockeo> They just don't understand that whole "Having been rooted in imperative programming" thing.
23:15:04 <gulk> a list of tuples
23:15:07 <Crockeo> They don't have that handicap :P
23:15:12 <copumpkin> gulk: that isn't well typed
23:15:14 <mm_freak_> @where haskell-cafe
23:15:14 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
23:15:18 <mm_freak_> @ ryanos
23:15:19 <copumpkin> gulk: but you can in theory, if you write it right :P
23:15:40 <xunatai> gult, you'd need to do ((a,b):[(c,d)])
23:15:51 <copumpkin> which is equivalent to writing [(a,b), (c,d)]
23:15:52 <Nereid> xunatai: maybe he does, maybe he doesn't
23:15:53 <Crockeo> So I've seen people use the lambdabot occasionally, do you just put a @ in front of a statement?
23:15:53 <copumpkin> as a pattern
23:15:55 <mm_freak_> ryanos: another good option is to post on reddit…  best you do both
23:16:11 <Nereid> Crockeo: all commands start with @, but there are some shortcuts
23:16:13 <gulk> k thanks guys
23:16:14 <Nereid> like > for @run, :t for @type, etc
23:16:24 <Crockeo> Like: @[x | x <- [1..5]] would just make it output [1,2,3,4,5]?
23:16:25 <ryanos> mm_freak_: i am not *that* interested :) the cafe sd b fine
23:16:31 <mm_freak_> Crockeo:
23:16:35 <mm_freak_> > iterate (*2) 1
23:16:37 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:16:39 <Crockeo> @[x | x <- [1..5]]
23:16:40 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc thx v wn
23:16:54 <mm_freak_> ryanos: if you're not that interested, it's not a survey ;)
23:16:55 <Nereid> lambdabot does lots of things other than evaluate expressions
23:17:06 <Nereid> @type filter
23:17:07 <lambdabot> (a -> Bool) -> [a] -> [a]
23:17:15 <Nereid> @pl c f g x = f (g x)
23:17:16 <lambdabot> c = (.)
23:17:27 <xunatai> iterate.. thanks for reminding me that exist, that just solved one of my problems
23:17:33 <xunatai> exists*
23:17:36 <Crockeo> mm_freak_: So for Haskell it's >?
23:17:40 <ryanos> mm_freak_: i want to have a general idea for the active haskell population. agree smth like cafe will do
23:17:45 <Nereid> @run map (5+) [1..]
23:17:47 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
23:17:52 <Nereid> but > is short for @run
23:17:57 <mm_freak_> ryanos: using a single platform you risk bias, so you need multiple platforms to collect data…  for example many people use mailing lists through emacs (gnus)
23:17:58 <Nereid> so everyone just uses >
23:18:29 <Crockeo> Nereid: ty
23:18:48 <Crockeo> > [x | x <- [1..5]]
23:18:50 <lambdabot>   [1,2,3,4,5]
23:18:58 <Nereid> > [1..5]
23:19:00 <lambdabot>   [1,2,3,4,5]
23:19:18 <ryanos> mm_freak_: you are taking it a lot further than i was planning. was just thinking abt getting a good idea of the most popular ide-s. a subset would do.
23:19:22 <Crockeo> > [(x, y) | x <- [1..], y <- (iterate (*2) 1)]
23:19:24 <lambdabot>   [(1,1),(1,2),(1,4),(1,8),(1,16),(1,32),(1,64),(1,128),(1,256),(1,512),(1,10...
23:19:35 <Crockeo> Hmmmm
23:19:45 <Crockeo> > [(x, y) | x <- [1,2..], y <- (iterate (*2) 1)]
23:19:47 <lambdabot>   [(1,1),(1,2),(1,4),(1,8),(1,16),(1,32),(1,64),(1,128),(1,256),(1,512),(1,10...
23:19:47 <mm_freak_> ryanos: your result will be that most haskellers use one of emacs and vim
23:19:50 <Nereid> Crockeo:
23:19:56 <Nereid> > [(x,y) | x <- [1,2,3], y <- [10,20,30]]
23:19:58 <lambdabot>   [(1,10),(1,20),(1,30),(2,10),(2,20),(2,30),(3,10),(3,20),(3,30)]
23:20:04 <mm_freak_> occasionally you will find EclipseFP and leksah
23:20:09 <ryanos> mm_freak_: let's see
23:20:11 <Crockeo> Man,
23:20:14 <Crockeo> I'm just derping everywhere.
23:20:21 <Nereid> > zip [1..] (iterate (*2) 1)
23:20:23 <lambdabot>   [(1,1),(2,2),(3,4),(4,8),(5,16),(6,32),(7,64),(8,128),(9,256),(10,512),(11,...
23:20:27 <Crockeo> It's zip I'm looking for
23:20:44 <Crockeo> Also my irc app is bugged, brb.
23:21:00 <mm_freak_> i don't know why but often i find myself using liftA2 (,) instead of zip
23:21:12 <Nereid> those do different things
23:21:22 <mm_freak_> uhm, yeah…  confusing ZipList with []
23:21:25 <Nereid> heh
23:21:39 <mm_freak_> seems like i've been working on netwire for too long =)
23:22:07 <xunatai> hmm.. how would i produce an infinite list of input of key presses with getChar?
23:22:11 <Crockeo> 1) Back 2) Nereid: I feel like a fool :(
23:22:21 <Nereid> :t getChar
23:22:23 <lambdabot> IO Char
23:22:23 <mm_freak_> xunatai: you wouldn't
23:22:28 <xunatai> not possible?
23:22:33 <mm_freak_> xunatai: however getContents does that
23:22:36 <Nereid> why not use getContents?
23:22:53 <mm_freak_> xunatai: possible and predefined, just not a good idea in general
23:22:54 <xunatai> ah
23:23:01 <xunatai> didn't know getContents existed
23:23:16 <Nereid> and you might want to turn off buffering on stdin
23:23:22 <xunatai> already did
23:23:27 <Nereid> :)
23:23:28 <Crockeo> (Completely unrelated to the current topic, but it just popped into my head: One of my favorite things coming from Java, Integers. Unlimited range is A++++)
23:23:48 <mm_freak_> Crockeo: the current topic is haskell
23:23:50 <Crockeo> well
23:23:50 <Crockeo> not /unlimited/
23:23:50 <Crockeo> but, y'know
23:23:56 <mm_freak_> (which is not to be taken for granted here)
23:24:00 <Nereid> > 2^10000
23:24:02 <lambdabot>   199506311688075838488374216268358508382349683188619245485200894985294388302...
23:24:02 <Crockeo> Maaaaaaaaaaaaaaan, why you always gotta be on my side?
23:24:21 <xunatai> on the other hand, getContents may pose a problem
23:24:23 * xunatai tests
23:24:32 <mm_freak_> xunatai: it poses a number of problems ;)
23:24:40 <Nereid> lazy IO is scary.
23:24:42 <mm_freak_> searching for lazy I/O you get an overview
23:24:49 <shachaf> Crockeo: Java has BigIntegers!
23:25:23 <Crockeo> Yeah but you gotta be like BigInteger bigInt = new BigInteger();
23:25:32 <shachaf> Sure, but that's a syntax thing.
23:26:29 <mm_freak_> Crockeo: in haskell when you write "3" you're actually writing "fromInteger theValueThree"
23:26:38 <Crockeo> On the topic of Integer, how would one define a boundless datatype?
23:26:45 <mm_freak_> that's a bit like new BigInteger(), just a lot faster =)
23:26:53 <shachaf> Crockeo: What's "boundless"?
23:26:55 <mm_freak_> boundless in what way?
23:27:09 <Crockeo> mm_freak_: The more I talk about Haskell with you people the more I learn Haskell is just sugar upon sugar.
23:27:21 <Crockeo> Well, I was under the impression that Integer had no minimum and no maximum.
23:27:31 <mm_freak_> Crockeo: all of haskell can be reduced to a very small core language, which is one of the beautiful things of it
23:27:31 <Crockeo> Though that could have been LYAH just simplifying it.
23:27:35 <Nereid> the term is "unbounded"
23:27:37 <shachaf> Crockeo: Lists have no minimm and no maximum.
23:27:47 <shachaf> They can be as long as you like.
23:27:48 <Nereid> > maxBound :: Int
23:27:49 <shachaf> So there you go.
23:27:50 <lambdabot>   9223372036854775807
23:27:52 <Nereid> > maxBound :: Integer
23:27:52 <otters> @instances Bounded
23:27:54 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
23:27:54 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
23:27:54 <lambdabot>    arising from...
23:27:55 <mm_freak_> Crockeo: data InfiniteList a = Cons a (InfiniteList a)
23:28:01 <otters> yeah, just pick every datatype that isn't in that list
23:28:06 <mm_freak_> InfiniteList is usually called Stream
23:28:15 <shachaf> mm_freak_: That's not the same as Integer.
23:28:17 <mm_freak_> (and i really think that Stream belongs into the base library)
23:28:20 <shachaf> Integer has a lot of finite inhabitants.
23:29:01 <Crockeo> I mean, if infinity were a concept in Haskell (is it?) you could just define the bounds to "(-infinity) | infinity"
23:29:11 <mm_freak_> well, then [()] is unbounded in the same sense as Integer
23:29:14 <Maxdamantus> > 1/0
23:29:16 <lambdabot>   Infinity
23:29:36 <Crockeo> Shouldn't that be Undefined?
23:29:39 <mm_freak_> Crockeo: infinity has many meanings in haskell depending on context
23:29:45 <Nereid> well, you could define data IntegerWithInfinity = NegativeInfinity | Finite Integer | PositiveInfinity
23:29:50 <Maxdamantus> > 1 `div` 0
23:29:51 <Crockeo> I mean, in math 1/0 isn't infinity, it's undefined.
23:29:52 <lambdabot>   *Exception: divide by zero
23:29:52 <Nereid> etc
23:30:07 <Nereid> Crockeo: sometimes it's defined to be infinity
23:30:11 <Maxdamantus> Crockeo: it's ±infinity.
23:30:16 <xunatai> no
23:30:18 <Nereid> sometimes +infinity = -infinity
23:30:20 <mm_freak_> Crockeo: think in limits:  1/x as x goes to 0
23:30:20 <xunatai> it's complex infinity
23:30:21 <Maxdamantus> 0/1 might be undefined.
23:30:26 <Nereid> 0/1 is 0 duh
23:30:37 <Maxdamantus> Oh, er.
23:30:38 <Maxdamantus> 0/0
23:31:07 <mm_freak_> > -1 * 1/0
23:31:07 <Nereid> but usually you can do some sort of thing to get something useful where you had 0/0
23:31:09 <lambdabot>   -Infinity
23:31:52 <Crockeo> Waaaaaait a second.
23:32:10 <gulk> conf :: [Circle] -> [Circle]
23:32:10 <gulk> conf [] = []
23:32:10 <gulk> conf ((a,b):[(c,d)])
23:32:10 <gulk> 	| (intersect (a,b) (c,d)) == False = (a,b) : conf[(c,d)]
23:32:10 <gulk> 	| (intersect (a,b) (c,d)) == True = newXY (a,b) (c,d) : confere [(c,d)]
23:32:16 <gulk> what else should i match here?
23:32:22 <Nereid> @where hpaste
23:32:22 <gulk> *** Exception: Main.hs:(80,1)-(84,80): Non-exhaustive patterns in function conf
23:32:23 <lambdabot> http://hpaste.org/
23:32:23 <Nereid> for large pastes
23:32:24 <mm_freak_> gulk: please use hpaste
23:32:28 <gulk> sorry
23:32:40 <Nereid> gulk: ((a,b):[(c,d)]) is not what you want.
23:32:41 <shachaf> gulk: You're only matching lists of length 0 and length 2
23:32:44 <Crockeo> > (-1)/0
23:32:46 <lambdabot>   -Infinity
23:32:48 <Crockeo> I'd assume it's the-
23:32:49 <Crockeo> up
23:33:00 <Crockeo> yup*
23:33:00 <Crockeo> the same.
23:33:15 <Maxdamantus> > 1/(-0)
23:33:17 <lambdabot>  Terminated
23:33:20 <Nereid> > 1/(-0)
23:33:22 <lambdabot>   -Infinity
23:33:24 <gulk> Nereid what should i get?
23:33:47 <xunatai> > let f = 2
23:33:47 <Guest32494> hi guys
23:33:48 <lambdabot>   not an expression: `let f = 2'
23:33:55 <mm_freak_> gulk: have you written some of the list functions yourself?  like map, filter, etc.?
23:33:56 <xunatai> > f = 2
23:33:58 <lambdabot>   <hint>:1:3: parse error on input `='
23:34:04 <Nereid> > let f = 2 in f
23:34:06 <lambdabot>   2
23:34:07 <gulk> mm_freak_ yeah
23:34:17 <xunatai> ._.
23:34:34 <mm_freak_> gulk: traversing a list is encoded by foldl and foldr…  try to express your algorithm in terms of one of them
23:34:40 <shachaf> error "jerks: negative jerk count"
23:34:44 <Guest32494> i need ta fold over (data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)). Any Suggestions?
23:34:49 <Crockeo> > 0/0
23:34:51 <lambdabot>   NaN
23:35:00 <mm_freak_> Guest32494: well, write a fold combinator
23:35:01 <shachaf> Guest32494: Define a foldTree function?
23:35:05 <shachaf> It depends on what you mean by "fold"
23:35:11 <Guest32494> jep
23:35:13 <Nereid> derive Foldable
23:35:14 <shachaf> If you want a monoidy thing, you can use Foldable
23:35:16 <Guest32494> just normal fold
23:35:22 <Nereid> except hmm
23:35:24 <shachaf> There's no such thing as "normal fold"
23:35:31 <Guest32494> okay :D
23:35:35 <mm_freak_> Guest32494: fold :: (a -> c) -> (c -> b -> c) -> Tree a b -> c
23:35:46 <mm_freak_> that's the type of a fold for your type
23:35:49 <shachaf> Nereid: But deriving Foldable is O(n^2) :-(
23:35:51 <Guest32494> foldT :: (a -> b -> b -> b) -> b -> (Tree a b) -> b
23:35:54 <Nereid> :-(
23:35:56 <Guest32494> thats my type
23:35:58 <xunatai> liberals think a normal fold is foldl, republicans think a normal fold is foldr
23:36:06 <mm_freak_> Guest32494: your type does not yield a fold
23:36:08 <Guest32494> :D
23:36:33 <Guest32494> hm
23:37:19 <mm_freak_> Guest32494: you're requiring that the result type of your fold is the same as the 'b' in your Tree
23:37:35 <mm_freak_> which is unlikely to be what you want and is even less a real fold
23:38:11 <mm_freak_> write my type signature for your fold and then try to write the definition yourself…  the type signature leaves little room for errors
23:38:13 <Nereid> yeah Foldable won't do it because you have more than one parameter
23:38:16 <Crockeo> mm_freak_, Nereid: While I enjoyed our little correcting me session, I'll be finishing my game-sort-of-thing written in Haskell.
23:38:23 <Nereid> :)
23:38:28 <mm_freak_> Nereid: Foldable is a generalized toList, which is also not a fold for Tree
23:38:31 <Crockeo> I'll probably post it in hpaste afterI finish it.
23:38:39 <Nereid> oh that too
23:40:02 <mm_freak_> Guest32494: as a side note, my type signature is wrong =)
23:40:10 <mm_freak_> Guest32494: fold :: (a -> c) -> (c -> b -> c -> c) -> Tree a b -> c
23:40:15 <mm_freak_> that's the correct one =)
23:40:40 <Nereid> and whatever it is, you should have fold Leaf Node = id
23:40:46 <Crockeo> Holy-shit-it's-2:40-never-mind-I'll-be-going-to-sleep.
23:41:05 <Nereid> :t maybe
23:41:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
23:41:08 <Nereid> :t either
23:41:10 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
23:41:12 <Nereid> :t foldr
23:41:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:41:29 <Nereid> :t flip foldr -- I like this better
23:41:30 <lambdabot> b -> (a -> b -> b) -> [a] -> b
23:41:50 <Nereid> :t \x y b -> if b then y else x
23:41:52 <lambdabot> t -> t -> Bool -> t
23:41:58 <Nereid> I want this function.
23:42:24 <mm_freak_> ryanos: btw, there is no "other" option in your survey
23:42:24 <otters> :t if'
23:42:26 <lambdabot>     Not in scope: if'
23:42:26 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
23:42:55 <Nereid> I'd call it bool
23:43:43 <mm_freak_> integer :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> …
23:43:49 <Nereid> haha
23:44:13 <elliott> mm_freak_: useful if you reject induction?
23:44:22 <mm_freak_> probably
23:44:39 <Nereid> nat :: a -> (a -> a) -> Nat -> a
23:44:40 <mm_freak_> integer :: a -> (a -> a) -> (a -> a) -> Integer -> a
23:44:50 <Nereid> :t \z f n -> iterate n f z
23:44:52 <lambdabot>     The function `iterate' is applied to three arguments,
23:44:52 <lambdabot>     but its type `(a0 -> a0) -> a0 -> [a0]' has only two
23:44:52 <lambdabot>     In the expression: iterate n f z
23:44:55 <Nereid> oops
23:45:04 <Nereid> what am I thinking of
23:45:10 <Nereid> :t \z f n -> iterate f z !! n
23:45:12 <lambdabot> a -> (a -> a) -> Int -> a
23:45:15 <Nereid> good enough
23:45:25 <otters> :t nat
23:45:27 <lambdabot>     Not in scope: `nat'
23:45:27 <lambdabot>     Perhaps you meant one of these:
23:45:28 <lambdabot>       `not' (imported from Data.Bool),
23:45:58 <mm_freak_> Nereid: a fold for Int has to take two function arguments
23:46:16 <mm_freak_> otherwise you can't write the identity fold (portably)
23:46:17 <Nereid> I know. this is a fold for naturals.
23:46:51 <mm_freak_> no worries, i'm abusing Integer for naturals as well =)
23:50:12 <ryanos> mm_freak_: correct, no "other" option - wanted to add one but had to pay for it.. so i've got the free version for now.. no "other" - but can add more to the list if anything is missing
23:50:54 <Nereid> :t ord
23:50:56 <lambdabot> Char -> Int
23:51:04 <Nereid> this has nothing to do with Ord. I am displeased.
23:57:07 <Nereid> how big can the types be in ghc, anyway?
23:57:13 <Nereid> like how big can a -> a -> ... -> a get
23:57:21 <shapr> I think tuples are only defined up to 42 items.
23:57:34 <Nereid> I'm not talking about tuples. (and that's 62)
23:57:42 <shapr> oh, sorry... my info must be out of date.
23:57:51 <mm_freak_> is there a library that presents a canvas in which i can draw?  like gloss, but not gloss
23:58:10 <Nereid> except I just tried (,,,,,,,,,,,...,) with lots of ,s in ghci 7.4.1 and it worked fine
23:58:14 <shapr> I believe I read about hyper-something functions that have an infinite type, and yet can still be compiled in Haskell. I wonder how that works?
23:58:58 <mm_freak_> Nereid: tuples are not bounded in GHC, but there is a limit on type size
23:59:08 <Nereid> that's what I'm wondering about.
23:59:21 <Nereid> for no particular reason.
23:59:30 <mm_freak_> in particular there is a recursion limit and GHC recognizes some infinite recursions right away
23:59:54 <mm_freak_> yes, there is a particular reason:  GHC shouldn't crash your machine when you have an infinite recursion =)
